00:00:09 <jle`> this would just be a drop-in replacement
00:00:35 <jle`> hm...wait
00:00:39 <jle`> scratch that, this won't work
00:01:22 <levi> ctangent: Yesod has very difficult-to-satisfy dependencies. It probably *will* break some other things if you allow it to do reinstalls, but you may be able to reinstall the broken things just fine afterward; they're probably more flexible with versions.
00:01:59 <ctangent> hmm, I see
00:02:09 <wz1000> So I just did a fresh install of Arch. How do I set up GHC and cabal so that it doesn't explode every few days? I also want to install Yesod and GHCJS
00:02:23 <jle`> Aleksejs: actually yeah, this should work
00:02:29 <levi> ctangent: What version of ghc are you using?
00:02:37 <levi> ctangent: And which cabal version?
00:02:38 <ctangent> ghc is 7.6.3, cabal is 1.21.0.0
00:04:18 <MP2E> wz1000 : install ghc and cabal-install from the repos, put 'export PATH=~/.cabal/bin:$PATH' in your .bashrc or something similar, and use lots of cabal sandboxes
00:04:32 <MP2E> wz1000: make a cabal sandbox for yesod and a seperate one for ghcjs
00:04:41 <levi> Well, good news! Your cabal supports sandboxes. This can help you avoid dependency problems, at the cost of a bit more compile time and disk space. :)
00:05:12 <wz1000> Will GHCJS's cabal work in a sandbox?
00:05:23 <levi> My suggestion would be to wipe out your current user-specific installed packages and reinstall the things you want in sandboxes.
00:05:32 <ctangent> great, thanks levi!
00:05:40 <levi> wz1000: I'm afraid I don't know anything about how GHCJS's stuff works.
00:05:57 <levi> ctangent: You can delete the packages you've got by removing ~/.ghc
00:06:06 <ctangent> oh, okay
00:06:29 <MP2E> wz1000 : from the looks of it actually yeah, maybe ghcjs shouldn't go in a sandbox
00:07:01 <MP2E> that looks like something that should be compiled and put in its own directory on your system, I'd do /opt/ghcjs or something
00:07:10 <MP2E> then add that to your path
00:07:13 <ctangent> cool, I'll let that run while I sleep. thanks levi :)
00:07:15 <MP2E> keeps it nice and seperate
00:07:29 <MP2E> one thing to note though: there might be an AUR package for GHCJS
00:07:36 <MP2E> this would maek your life a lot easier because then you wouldn't realy have to do anything :D
00:07:38 <levi> ctangent: If you want to try out a Yesod site, you'd make a directory and do a 'cabal sandbox init', then 'cabal install yesod-platform <other packages>' where <other packages> are any others you know you'll want.
00:07:40 <dwcook> Is there even a cabal package for ghcjs? It's not under that name
00:08:02 <levi> ctangent: The engine that resolves dependencies does a better job when you list everything you need on the same install line.
00:08:06 <MP2E> dwcook : nah I looked it up and you need to download a source tarball or from git :V
00:08:06 <wz1000> GHCJS ships with its own special version of cabal.
00:08:22 <ctangent> levi: yeah, that's what I did and it seems to be working
00:08:28 <ctangent> i'm sure it'll take a while
00:09:02 <MP2E> right I'd symlink the new cabal to cabal-ghcjs or something
00:09:14 <MP2E> err the ghcjs cabal*
00:09:40 <levi> ctangent: Yeah, yesod does a lot of cool stuff, but it leverages a lot of libraries to do so.
00:10:43 <willqw> Hi, I find the examples in Real World Haskell's chapter 17 on FFI are hard to reproduce on both Linux and Windows.
00:10:52 <willqw> What is currently the recommended way to learn FFI?
00:11:07 <willqw> Is the chapter 17 on Real World Haskell outdated?
00:12:46 <int3__> when I split a line of code over multiple lines in a do block, it seems like I need to indent the subsequent lines by 8 spaces instead of 4 (even though 4 works everywhere else.) why is this so?
00:13:43 <tdammers> int3__: you don't
00:13:47 <jle`> int3__: can you give an example?
00:13:53 <int3__> k give me a sec
00:13:58 <tdammers> int3__: you have to indent "enough"
00:16:18 <int3__> tdammers: jle`: http://lpaste.net/107871
00:16:51 <tdammers> int3__: first thing after `let` defines indent for subsequent let expressions
00:16:52 <Cale> int3__: Make sure there are no tab characters in your file
00:16:55 <jle`> int3__: ah.  that's because you can possibly make multiple declarations on a single let
00:17:04 <tdammers> ...but only in do notation
00:17:14 <jle`> let   x = 4
00:17:16 <tdammers> (at least using this indented multiline syntax)
00:17:17 <Cale> not only in do notation
00:17:18 <jle`>       y = 5
00:17:25 <jle`>        z = True
00:17:25 <tdammers> hmm wait
00:17:27 <jle`> oops
00:17:28 <Cale> You can put multiple declarations in any let
00:17:28 <tdammers> right
00:17:35 <tdammers> you're right, I'm an idiot
00:17:43 <jle`> but yeah...so...as soon as you "indent less" than you should, it counts that as you are no longer in that let
00:17:47 <gamegoblin> Does Data.Serialize.Get steal a lot of Attoparsec code?
00:17:58 <int3__> oh, I don't use let anywhere else other than in do blocks, I suppose that's why I didn't notice it earlier
00:18:02 <gamegoblin> Sure seems like it
00:18:05 <Cale> The first non-whitespace character after 'let', 'do', 'of', or 'where' sets the indentation level for the block
00:18:37 <Cale> in order to be subsequent entries in the block, the following lines have to line up with that character
00:18:50 <Cale> deeper lines will be continuations of previous ones
00:18:58 <Cale> and any shallower line closes the block
00:19:36 <Aleksejs> jle`: could you give me an example of RWS usage?
00:19:39 <Cale> gamegoblin: Or does Attoparsec steal a lot of Data.Serialize.Get's code?
00:19:43 <int3__> Cale: right, and 'let' creates a block, and then the '= ...' creates another block, yes? so I need to indent twice if I want to continue assigning to my 'y'
00:19:50 <Cale> The = doesn't
00:19:55 <Cale> (not really)
00:19:59 <gamegoblin> Cale: I think Data.serialize is a subset of attoparsec
00:20:20 <Cale> 'let', 'do', 'of', and 'where' are the only things which really deal with layout (well, and 'mdo' if you have that extension on)
00:20:44 <Cale> But you should generally try to line things up a little more than the bare minimum requires, of course :)
00:21:25 <int3__> Cale: ok, but the problem with my example is that GHC treats my lambda as the LHS of a new let declaration if I only indent it to line up with the 'x', right
00:21:26 <Cale> int3__: You need to indent past the 'y' in order to continue the definition of y
00:21:32 <int3__> right
00:21:35 <int3__> ok
00:21:47 <jle`> Aleksejs: your code would be unchanged, except instead of runReaderT run st, you'd do runRWST run st initialQueue
00:21:58 <Cale> It can just be one space more even, though pushing it past the = is usually a good thing
00:22:09 <jle`> Aleksejs: to 'access' the underlying queue, you would use get, put, and modify
00:22:18 <int3__> okay, makes sense
00:22:55 <jle`> Aleksejs: x <- get gives you the current queue; put x "replaces" the current queue, and modify f applies the function to the current queue and replaces it with the result
00:23:18 <jle`> Aleksejs: this is not the only way to do this, but it's probably the way with the minimum changes to the existing architecture :)
00:23:55 <jle`> besides maybe using IORefs, which are probably not the best idea in this situation
00:26:55 <gamegoblin> I put on {-# LANGUAGE DeriveGeneric #-} but I am still getting the error “Not in scope: type constructor or class `Generic' “
00:26:57 <gamegoblin> ideas?
00:27:14 <jle`> gamegoblin: you need to import GHC.Generics
00:27:19 <gamegoblin> ohthx
00:27:46 <gamegoblin> worked
00:28:08 <jle`> hooray
00:28:31 <gamegoblin> because ain’t nobody got time to make their own serializable instances
00:30:52 <tac_> I just spent the last 8 hours trying to get Haskell to properly do HTTPS
00:31:06 <tac_> If I can find time for that, you can find time to serialize your own data.
00:33:02 <tdammers> tac_: server-side or client-side?
00:34:13 <tac_> client
00:34:19 <tac_> Trying to make an API call to google
00:34:23 <tac_> I chased the yak for hours
00:34:29 <gamegoblin> LOL
00:34:30 <gamegoblin> Oh man
00:34:35 <gamegoblin> I went through that a few months ago
00:34:36 <tac_> I reinstalled haskell-platform twice
00:34:38 <gamegoblin> gave up after 6 hours
00:34:45 <tac_> but I made it
00:34:49 <gamegoblin> clearly I should have stuck it out another 2
00:35:07 <tac_> hi sudlowbot
00:35:08 <sudlowbot> I AM SUDLOWBOT
00:35:08 <gamegoblin> google’s auth scheme is annoying
00:35:15 <tac_> !shorten http://haskell.org/
00:35:15 <sudlowbot> http://goo.gl/8hDku
00:35:20 <tac_> thank you sudlowbot
00:35:21 <tac_> !banish
00:35:35 <tac_> The above is the fruit of my labor
00:35:44 <gamegoblin> Oh wow
00:35:45 <gamegoblin> cool
00:35:54 <tac_> but now is sleep time
00:36:07 <jle`> tac_: expect the api to last for at most a month
00:36:10 <jle`> before it is depreciated :)
00:36:15 * tac_ dies
00:36:22 <tac_> thanks to anyone who helped me today
00:39:33 <frerich> tac_: It seems to me that "http://haskell.org/" is as long as "http://goo.gl/8hDku" :-)
00:39:51 <frerich> tac_: If you want to be crazy hip, you could use 9m.no as the shortening service (which was written in Haskell, too!).
00:40:15 <frerich> Oh, I'm too late.
00:41:36 <nschoe> frerich: ho neat ! I've just tested it. Unicode characters for shortening. This is taking it to the extreme ^^
00:54:28 <jle`> so this http://hackage.haskell.org/package/gloss tells me that the cabal package takes flags
00:54:39 <jle`> in this case to change the graphics backend
00:54:52 <jle`> ...how can i specify this when i use cabal install, on a package that depends on this?
00:55:07 <jle`> as in...gloss is a dependency...how can i get cabal install to make it build gloss with a specific flag?
00:57:41 <Pythonfant> jle`: --flags?
00:57:59 <jle`> Pythonfant: is there a way i can put in the cabal file...?
00:58:07 <jle`> so i don't need to do it whenever i run cabal install?
00:58:15 <Pythonfant> hm sry no idea
01:00:00 <nschoe> jle`: isn't what "ghc-options:" in the .cabal file is for ? (sorry if I mis-understood your question)
01:00:16 <jle`> nschoe: can i use ghc-options to do --flags?  i thought that was a cabal thing
01:00:25 <levi> jle`: It's part of the configure flags, I think. You usually specify those with "cabal configure".
01:00:38 <flan3002> Someone said yesterday that instancing typeclasses just because of the syntax is bad (Num in this case). Why so and what are the alternatives?
01:00:53 <levi> And I'm pretty sure you can change the configure flags in the .cabal file.
01:00:56 <nschoe> jle`: ah... well then I don't know. Sorry :/
01:01:05 <solidus-river> is it always considered bad to raise an exception in haskell?
01:01:06 <jle`> levi: hm.  do you know the field/syntax?
01:01:31 <solidus-river> theres a state in my program where i SHOULD never get an empty list but if i do theres no sane default action to take
01:01:39 <jle`> flan3002: there are some good examples...Text and ByteString, for instance
01:02:28 <jle`> also sometimes people like to derive Num instances for newtypes wrapping numbers...so they can enter them as integer literals.  i really don't see the huge harm
01:02:29 <levi> jle`: You might want to cabal unpack it in another directory and build it there if you want non-default flags.
01:03:43 <levi> flan3002: Usually a type class captures some well-defined operation or set of operations; making instances that don't follow the rules of the type class betrays the expectations of Haskell programmers.
01:03:45 <jle`> hm
01:03:47 <jle`> thanks
01:03:58 <flan3002> jle`: Okay, that makes sense. Now what if I need operator overloading, but not just for values of the same type (a * a) but also for other combinations (b * a and a * b)?
01:04:13 <jle`> you can't use (*) for that
01:04:20 <jle`> :t (*)
01:04:21 <lambdabot> Num a => a -> a -> a
01:04:22 <nschoe> jle`: Maybe http://stackoverflow.com/questions/18941087/how-to-access-custom-cabal-flags-inside-setup-hs can help you ? It talks about configConfigurationFlags and ConfigFlags. I think it has  to do with Setup.hs not being the default one
01:04:27 <levi> If you want to install it in a sandbox, you can always point the sandbox of the unpacked directory to the other sandbox you want it to install into.
01:04:29 <jle`> you have to convert them into the same type
01:05:14 <levi> flan3002: Type classes don't provide dynamic dispatch like OOP interfaces do.
01:06:05 <flan3002> So I need a set of methods (name /= (*)) for that?
01:06:18 <levi> flan3002: That type signature from lambdabot shows that all three types involved are 'a', meaning they could be any type that provides a Num instance, but they are all the *same* type.
01:06:38 <Pythonfant> solidus-river: well even in other languages I would say it's considered bad practise to terminate your program by throwing an exception. You're going to handle it and then exist cleanly. And if you do this you can just aswell use a Maybe or something and pattern match on Nothing and then exist cleanly.
01:06:54 <jle`> flan3002: yeah, you will need a function that is not (*) from the Num typeclass
01:07:10 <jle`> the recommended route is just to convert them to a common type
01:07:15 <levi> No, all your types can have a (*) operation, but you will have to provide some translation *between* types so that all the operands are the same type when you apply (*).
01:07:48 <tac_> Pythonfant: but it's almost always better to crash than to handle an error poorly.
01:07:48 <flan3002> Now I'm confused...
01:08:07 <jle`> flan3002: you can't use (*) to do a * b where a and b are different types...but you can use (*) if you convert them to the same type
01:08:15 <levi> There are instances of Num for Int, Integer, Double, etc.
01:08:35 <jle`> > (1 :: Int) * (3.0 :: Double)
01:08:37 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
01:08:37 <lambdabot>              with actual type ‘GHC.Types.Double’
01:08:40 <levi> So you can multiply an Int * Int, an Integer * Integer, a Double * Double, etc.
01:08:52 <jle`> > (fromIntegral (1 :: Int)) * (3.0 :: Double)
01:08:53 <levi> But you can't multiply Int * Double.
01:08:53 <lambdabot>  3.0
01:09:03 <jle`> in that case, i converted the 1 into a Double, so it's Double * Double
01:09:16 <flan3002> levi: My specific example is three-dimensional vector. I may want scalar multiplaction for it...
01:09:30 <flan3002> *+ a
01:10:07 <jle`> flan3002: then you will probably define your own function for scalar multiplication ... this is the route taken in the popular linear package
01:10:23 <levi> flan3002: You only want to use the standard type classes for things that actually *are* the same mathematical operation.
01:10:31 * hackagebot ordrea 0.3.0.0 - Push-pull implementation of discrete-time FRP  http://hackage.haskell.org/package/ordrea-0.3.0.0 (AkioTakano)
01:10:34 <lfairy> flan3002: try the packages linear or vector-space
01:11:34 <flan3002> lfairy: This is not for production. I don't want to use these libraries, I want to understand how it works. And as I'm learning Haskell, I don't think I understand these libraries yet. :)
01:11:39 <jle`> linear uses (*^) and (^*) for left and right scalar products... these aren't from any typeclass, it's just them
01:12:06 <lfairy> yeah, custom operators are great for this sort of thing
01:13:10 <jle`> interestingly enough, linear does have Num instance for its vectors
01:13:24 <jle`> where 3 is a vector of all 3's
01:13:31 <frerich> Is there an abstraction based on monads which encapsulates the pattern of defining (and composing) 'actions' of some sort and then executing them as one atomic invocation? E.g. what the STM monad does. I suppose the same could be useful for executing e.g. SQL commands or for updating a file hierarchy on disk, guarded by a lock file.
01:13:41 <jle`> and (+), (*), etc. are component-wise adding and multiplication
01:13:57 <jle`> V2 3 4 + V2 1 4 = V2 4 8
01:14:15 <Pythonfant> component-wise multiplication?
01:14:18 <Pythonfant> is that used anywhere?
01:14:30 <jle`> i doubt it...
01:14:35 <jle`> i think it's just there for the convenient syntax
01:14:40 <jle`> so you can write, say, 0 for the zero vector
01:14:59 <Pythonfant> I would guess that's the reason why they didn't provide a num instance
01:15:15 <jle`> what reason? that component wise (*) is meaningless?
01:15:15 <levi> If you're familiar with the concept of an algebraic ring, that's *roughly* what the Num typeclass represents, and the sort of behavior you should implement for (+) and (*) if you make a Num instance.
01:15:23 <Pythonfant> jle`: yep
01:15:25 <jle`> er...useless
01:15:35 <jle`> it behaves groupy laws though, so it's ok
01:15:40 <jle`> er, ringy laws
01:16:02 <Pythonfant> hm right
01:16:37 <jle`> i think it's mostly for the ability to use Integer literalls, heh.
01:16:53 <jle`> edwardk isn't online atm so we can't pester him
01:17:36 <Pythonfant> hm why does linear not have any docs on hackage
01:17:38 <jle`> there is also a Fractional instance...so you can use (/) for component-wise division
01:17:43 <jle`> Pythonfant: go back a version
01:17:50 <XexonixXexillion> http://lpaste.net/107874 can anyone think of a way to make line 31 type check? (aside from what's on line 32 XD )
01:17:59 <jle`> i think there's something weird going on with hackage right now because a lot of packages i've seen today act the same way
01:18:05 <levi> So you could reasonably make a Num instance for square matrices, for example, with matrix addition and matrix multiplication.
01:18:15 <Pythonfant> jle`: thx
01:18:38 <levi> Hackage's haddock-building is busted lately. :(
01:19:09 <jle`> XexonixXexillion: what's the error?
01:19:56 <jle`> linear doesn't have a separate Matrix type, apparently...so (*) between Matrices (the type synonym) is still component wise >_>
01:20:12 <jle`> i imagine that edwardk must have felt some amount of pain when realizing or deciding that
01:20:33 * hackagebot herringbone 0.1.0 - A library for compiling and serving static web assets.  http://hackage.haskell.org/package/herringbone-0.1.0 (hdgarrood)
01:20:35 * hackagebot herringbone-embed 0.1.0 - Embed preprocessed web assets in your executable with Template Haskell.  http://hackage.haskell.org/package/herringbone-embed-0.1.0 (hdgarrood)
01:20:37 * hackagebot herringbone-wai 0.1.0 - Wai adapter for the Herringbone web asset preprocessor.  http://hackage.haskell.org/package/herringbone-wai-0.1.0 (hdgarrood)
01:20:52 <levi> Well, Num is not quite as principled as some of the more "categorical" type classes anyway.
01:21:05 <frerich> jle`: Secret tip: you can say a magic word starting with "l" and ending in "ens" to make his IRC client blink
01:21:16 <XexonixXexillion> couldn't match b with b1 'b' is a rigid type variable bound by ... Expected type: (a -> CataList a -> b1 -> b1) -> b1 -> b1 Actual type: (a -> CataList a -> b -> b) -> b -> b ... which seems a bit strange since the type should be forall b . (a -> CataList a -> b -> b) -> b -> b
01:22:36 <jle`> frerich: he's offline :)
01:23:02 <frerich> jle`: I'm sure he has some tricks to overcome such petty limitations.
01:23:41 <flan3002> Thank you, jle and levi. :)
01:24:24 <levi> flan3002: You're welcome!
01:27:30 <jle`> frerich: i wouldn't be surprised, actually :)
01:36:17 <Welkin2> ghci broke when I switched to using a real build of gcc instead of osx's "wrapped" clang
01:36:43 <Welkin2> it can't find the proper dylibs
01:37:06 <Welkin2> has anyone solved this issue?
01:41:22 <christiaanb> Welkin2: better ask your question on #ghc, also, carter is in that channel (away now though) who worked on making c-compiler configurable in ghc 7.8.3
01:41:58 <Welkin2> thanks christiaanb
01:45:36 * hackagebot Zora 1.1.10.2 - Graphing library wrapper + assorted useful functions  http://hackage.haskell.org/package/Zora-1.1.10.2 (bgwines)
02:05:38 * hackagebot hspec 1.11.0 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.11.0 (SimonHengel)
02:15:39 * hackagebot hspec-meta 1.11.0 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.11.0 (SimonHengel)
02:20:40 * hackagebot hspec2 0.4.0 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.4.0 (SimonHengel)
02:21:33 <kvanb> hspeception?
02:56:14 <ocharles> Does anyone have a registerDelay :: Integer -> STM.TVar Bool ?
02:56:19 <ocharles> base has one for Int, but not Integer
02:56:30 <ocharles> unbounded-delays is in IO, not STM
02:57:33 <merijn> ocharles: What would that do?
03:01:55 <bennofs> @hackage stm-delay -- ocharles, maybe this works?
03:01:55 <lambdabot> http://hackage.haskell.org/package/stm-delay -- ocharles, maybe this works?
03:02:32 <ocharles> merijn: what do you mean what would it do?
03:02:45 <ocharles> it would delay for the given number of microseconds as specified by the Integer
03:05:05 <ocharles> It seems my Int here has a maxBound of at least 2^45 though, which is a year
03:05:09 <ocharles> I doubt we'll reach a year of uptime :)
03:05:24 <ocharles> (specifically, maxBound seems close to 2^62
03:06:28 <bennofs> ocharles: oh, base has registerDelay in STM for Int?
03:06:33 <ocharles> yea
03:06:38 <ocharles> oh sorry, not base
03:06:41 <ocharles> but the stm package
03:06:49 <ocharles> But "base stm", if you will :)
03:09:58 <RchrdB> ocharles, FWIW, the Haskell 98 standard requires that Int must have a range of at least -(2^29) to (2^29)-1 inclusive.
03:10:03 <ocharles> yea, I know
03:10:20 <ocharles> 2^29 is not enough, but I'll leave life on the edge and rely on architecture specific details for now...
03:10:31 <ocharles> (I'm going to error on startup if it's too low for now)
03:10:34 <kgadek> I'm having difficulties setting up GHC 7.8.2 on Amazon EC2. The build log is here: https://gist.github.com/91831be7cbe72d3455a0
03:10:35 <kgadek> Any ideas?
03:10:55 <RchrdB> It'll happen to be 2^63-1 if you're using GHC on a 64-bit platform these days.
03:22:30 <ocharles> RchrdB: yea, figured it'd be something like that
03:31:15 <kgadek> followup story: I have no idea why, but now it works. The differences that should not make any actual difference: I installed libgmp from sources & this time I was not in a chroot (chroot into /, YEAH strange but that's a different story)
03:31:32 <kgadek> oh, and I redownloaded the sources of GHC
03:47:46 <teakay> hey guys.  I know very little about lenses, still messing around with them.  Is there anyway to use setters with actions ?
03:48:08 <edwardk> teakay: sadly no. actions are kind of a mostly aborted side-experiment
03:48:28 <edwardk> they never matured into 'monadic lenses' for fundamental reasons
03:49:04 <teakay> cool thanks. figured it would be a stretch
03:55:55 <jle`> edwardk: oh hey.  we were wondering earlier what the motivations of a Num instance for various Vector types in linear were...was it purely to be able to use numeric literals and component wise addition?
03:56:08 <jle`> edwardk: because component wise multiplication feels kinda weird
03:56:13 <jle`> especially for matrices
03:58:39 <jle`> component-wise division too :|
04:10:28 <NikolajK> Formally, the unit of a monad maps m^2 to m, so if a if b is a type, then you can in particular map from m m b to m b. However, in Haskell, since the type constructors seem to always be given as "wrap x", I even know how to map from just m b down to b, right?
04:11:17 <NikolajK> e.g. just by looking at it, I know that Just 3 in Maybe Int comes from 3. That's kind of invertibility is stronger than what's required from a monad.
04:11:51 <haasn> (What about (->) r?)
04:13:39 <jle`> NikolajK: you might possibly be conflating type constructors and data constructors
04:14:12 <NikolajK> in any case I ment co-unit
04:14:21 <NikolajK> jle`: why? where?
04:14:44 <NikolajK> Just x is the term and I know how to map it to the term x, right?
04:14:59 <jle`> yeah, but this isn't the case in general for all Monad instances
04:15:03 <jle`> and it doesn't even apply to Maybe
04:15:13 <jle`> because Maybe Int is also inhabited by Nothing
04:15:23 <jle`> how can you map Nothing to an Int?
04:15:39 <NikolajK> okay, that's right
04:15:56 <NikolajK> but are all terms in the image of return of the form "wrap x"?
04:15:59 <jle`> TypeConstructor a does not imply DataConstructor (x :: a)
04:16:20 <haasn> NikolajK: What is “wrap”?
04:16:26 <NikolajK> the terms constructor
04:16:35 <haasn> Some constructor, then?
04:16:36 <NikolajK> I might just not know examples which are different
04:16:37 <jle`> not all types even have meaningful data constructors
04:16:42 <NikolajK> k
04:16:52 <jle`> ((->) r) is a good example, like haasn pointed out
04:16:55 <haasn> What about, say, return x = (:) x []
04:17:00 <haasn> Or return x = \_ -> x
04:17:09 <haasn> Or return x = Const ()
04:17:33 <tech2> does the boolean type have a meaningful constructor?
04:17:46 <haasn> @src Bool
04:17:46 <lambdabot> data Bool = False | True deriving (Eq, Ord)
04:17:46 <jle`> return x = \s -> (x, s)
04:17:51 <jle`> tech2: it has two :)
04:17:52 <NikolajK> don't know if those are monads, though
04:18:28 <jle`> NikolajK: do you want to take our words for it, or do you want us to define join for you too? :)
04:18:40 <NikolajK> the example return x = \s -> (x, s) is invertible, isn't it? Apply it to some value for s and project out the first component
04:18:46 <haasn> jle`: define join, *and* prove the laws
04:19:03 <haasn> NikolajK: What about s ~ Void
04:19:10 <haasn> err s :: Void
04:19:20 <jle`> i was hoping to imply that from a definition of join, NikolajK could prove the laws himself if he wanted to :)
04:20:44 <jle`> NikolajK: you can recover the x, but not generically for all Monads.  these are just properties of specific instances, not of all haskell monads in general
04:20:59 <NikolajK> k
04:21:35 <jle`> in all of these cases, the 'work' you do (if possible) is different...so...it's not generic, it's from that specific type.
04:21:49 <jle`> there's also the classic example of IO
04:22:07 <jle`> but that might just be because the imaginary constructors are hidden/abstracted away
04:23:38 <jle`> ...if i'm interpreting your question right, you are noting that in some cases, you can recover x from return x, for different monad instances
04:24:16 <NikolajK> yeah, from the examples I looked at, it seemed like that might be in general true for monads as implemented in Haskell
04:25:38 <NikolajK> the "only" thing I still don't understand is why I/O wouldn't be possible without monads. I mean I like the concept, but if I had to argue for them in Haskell, I could only say because it's a common design pattern
04:25:56 <jle`> IO works fine without monads
04:25:56 <rio> I/O is possible without monads
04:26:06 <NikolajK> ah, k
04:26:14 <jle`> it's just a little less useful :)
04:26:15 <hpc> Monad simply provides a convenient interface
04:26:32 <hpc> if Monad didn't exist you could still use IO assuming reasonable primitives
04:26:33 <haasn> IO is possible as an ADT, too
04:26:50 <hpc> it'd be really convenient if you wrote (a -> IO b) -> IO a -> IO b though
04:26:58 <hpc> using whatever primitives you have
04:27:24 <haasn> data IO :: * -> * where Return :: a -> IO a; PutStrLn :: String -> IO (); GetLine :: IO String; ...
04:27:38 <jle`> well if you did, you'd pretty much be implementing a monadic interface.  if you had an a -> IO a to go along with it
04:27:48 <haasn> Hmm, actually I'm not sure if that one's useful
04:27:58 <haasn> But there are representations in which you can do binding and stuff using just the data constructors
04:28:03 <NikolajK> what I also find interesting is that no Haskell example I've seen uses the monad at least three levels down. I mean the whole fmap or bind structure, which would also work for m m m m m a -> m m m m m b, is only ever used for m a -> m b. Same for the "diagonal" maps you plug into >>=
04:28:05 <hpc> haasn: it's a common example of alternative IO
04:28:10 <hpc> which has the issue of being closed
04:28:25 <tdammers> there's a blog post somewhere that builds up from the blank question "how can we do I/O in a pure functional language"
04:28:28 <hpc> you can't add new IO primitive operations because each one is a constructor
04:28:35 <tdammers> creates a whole I/O minilanguage
04:28:45 <tdammers> some combinators to chain I/O things together
04:29:06 <tdammers> and at the very end arrives at the conclusion that the minilanguage fits the monad laws
04:29:16 <jle`> you'd probably have to do GetLine (String -> IO a)
04:29:16 <tdammers> and at that point, making IO a Monad is trivial and natural
04:29:23 <tdammers> shame I can't remember the URL
04:29:27 <jle`> or else wrap it in Free i think
04:29:34 <jle`> tdammers: are you referring to the chris taylor post?
04:29:40 <tdammers> jle`: maybe
04:29:41 <jle`> hm
04:29:43 <jle`> http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
04:29:44 <haasn> Oh, here's a better IO ADT:
04:30:04 <haasn> data IO a = Return a | GetLine (String -> IO a) | PutStrLn String (IO a) | ...
04:30:13 <tdammers> jle`: yeah, I think that's the one
04:30:20 <jle`> you can probably just define an IO ADT as a Functor and then toss it into Free
04:30:26 <haasn> hpc: Fortunately, the haskell report only mentions a select number of primitive IO operations - implement all those and you have Haskell covered
04:30:41 <hpc> haasn: one of those is FFI :P
04:31:08 <NikolajK> cont.: in particular, I view the monad as the laws associated with a diagram
04:31:08 <NikolajK> a    m a
04:31:08 <NikolajK> b    m b
04:31:08 <NikolajK> and then in my mind, what is characteristic to the monad is the endofunctor structure to the left
04:31:08 <NikolajK> a    m a    m m a   …
04:31:09 <NikolajK> b    m b    m m b   …
04:31:09 <NikolajK> but programmers use the whole framework rather downwards
04:31:10 <NikolajK> a    m a
04:31:10 <NikolajK> b    m b
04:31:11 <NikolajK> c    m c
04:31:11 <NikolajK> …   ...
04:31:31 <hpc> unless you did something like Foreign :: Word -> IO a
04:32:22 <jle`> NikolajK: yeah, as it turns out, when it comes to practical usefulness, it's not always aligned with what you'd expect from the theory in a vacuum
04:32:55 <haasn> hpc: | forall a b. FFITypes a b => FFI FFIDescription a (b -> IO x) -- or whatever :p
04:33:07 <haasn> FFIDescription a b
04:33:49 <haasn> (I'm not arguing this is necessarily a good IO representation, just that it's possible)
04:34:01 <NikolajK> I've seen there is an adjoint functors package - are hom-set adjunctions actually used in some implementation of something?
04:34:09 <rio> NikolajK: well instead of going m m a -> m m b you can always go m m a -> m a -> m b -> m m b, don't you? so there's really no point in going deeper
04:34:50 <rio> hm, those things don't commute, nevermidn
04:35:35 <NikolajK> rio: my point is also more that types like "Maybe Maybe Maybe Int" aren't used
04:35:41 <NikolajK> it appears
04:36:14 <rio> in the maybe case there's really no point
04:36:18 <jle`> in practice you rarely work directly with things more than a couple levels deep
04:36:26 <jle`> i've used Maybe (Maybe Int) before
04:36:33 <jle`> and IO (IO ()) comes up occasionally too
04:37:01 <rio> in the maybe-case you don't loose anything by going Maybe Maybe a -> Maybe a, do you?
04:37:22 <rio> in the general case you might, for example for lists you loose the inner grouping
04:37:23 <jle`> rio: it was the specific application, and in that case, i did --- but i probably should have refactored it to use a different type anyway
04:38:01 <jle`> the thing was Nothing if the game was in-progress, and Just x if the game was over; Just (Just p) with the winning player, and Just Nothing with a tie.  admittedly it's pretty ugly and i'm slightly embarassed to talk about it >_>
04:38:01 <haasn> In the places I've seen IO (IO ()), it was semantically *very* different from the result of “join” on those operations
04:38:11 <rio> jle`: so in your case there was a semantic difference betweend Just Nothing an Nothing?
04:38:12 <haasn> eg. spawning an asynchronous computation while returning an action to force it
04:38:17 <jle`> rio: yeah
04:38:22 <haasn> join on that would accomplish nothing
04:38:25 <rio> jle`: ok, i get it
04:38:54 <jle`> haasn: yeah, that sounds like a good description of the cases when IO (IO ()) is useful
04:38:58 <rio> jle`: let's not talk about it again
04:39:03 <jle`> rio: :)
04:39:05 <rio> ;)
04:39:10 <NikolajK> I feel return, viewed as collection of terminal morphisms giving rise to the adjoints is the prettiest thing about the whole structure. Programmers rather need the "vertical" map >>=, which has a fairly complicated type m a -> (a->m b)->m b and in turn I've not seen a single satisfying monad tutorial.
04:39:37 <haasn> An example of Maybe (Maybe Int) could be a possibly empty configuration of, say, an upper bound
04:39:55 <haasn> Nothing means “no configuration given, use default”, Just Nothing means “configuration given - no upper bound” and Just (Just x) means “configuration given - upper bound is x”
04:40:05 <rio> NikolajK: you don't need a tutorial anyway, you know the stuff pretty damn well ;)
04:40:18 <haasn> If the default is, say, Just (Just 1024) then this would clearly be quite different from Just Nothing
04:40:19 <jle`> NikolajK: perhaps you might like the type of (=<<) :: (a -> m b) -> (m a -> m b)
04:41:27 <jle`> NikolajK: but yeah...really, we are using Monad for practical purposes in Haskell.  there's a lot of pretty things about the monad structure, but...we haven't found much use for it, i think, so...
04:41:32 <rio> jle`: i guess it lifts an a -> m b to m a -> m m b an then postcomposes join?
04:41:52 <jle`> rio: yeah, but the type signature is a little nicer than (>>=)
04:41:59 <jle`> it lines up well with fmap
04:42:04 <kvanb> hey
04:42:09 <kvanb> does anyone know a good way to inverse a map
04:42:16 <kvanb> i.e. keys -> values and values -> keys
04:43:11 <quchen> kvanb: bimap package
04:43:34 <kvanb> is there a good way using only the containers package?
04:43:51 <quchen> Implement it yourself
04:44:22 <quchen> The bimap package is pretty old, but I don't think much of the functionality it uses changed, so it should still work.
04:44:59 <pjdelport> kvanb: You could use fromList . map swap . assocs
04:45:00 <quchen> Writing a bimap based on Map is pretty easy, if the package doesn't compile you can either fix it or roll your own implementation inspired by its source.
04:45:20 <kvanb> :t swap
04:45:20 <lambdabot> (a, b) -> (b, a)
04:45:24 <pjdelport> kvanb: (or fromListWith / fromListWithKey as appropriate)
04:45:35 <pjdelport> (depending on how you want duplicates to be handlede)
04:45:40 <kvanb> thanks
04:45:41 <pjdelport> (handled, even)
04:46:43 <pjdelport> :t :t M.fromList . map swap . M.assocs
04:46:43 <lambdabot> parse error on input ‘:’
04:46:48 <pjdelport> :t M.fromList . map swap . M.assocs
04:46:49 <lambdabot> Ord k => M.Map a k -> M.Map k a
04:46:53 <NikolajK> does anybody else think of fish when reading ">=>"?
04:47:35 <quchen> All the time.
04:47:41 <quchen> (:[]) is robot monkey.
04:47:46 <quchen> <>~ is rat.
04:48:42 <arancia> :t (<>~)
04:48:43 <lambdabot> Monoid a => ASetter s t a a -> a -> s -> t
04:49:07 <haasn> :t (.)(.)(.)
04:49:08 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
04:49:18 <quchen> > ("hello", "wor") & _2 <>~ "ld"
04:49:20 <lambdabot>  ("hello","world")
05:05:16 <exoarn> hello, can anyone explain to me what the difference in type deceleration is between "funcname :: Int a => a -> [a]" and "funcname :: Int -> [Int]"? because i see the first a lot when i use :t in ghci but i can't get it to work in my own code.
05:05:46 <Cale> In order for the first to make sense, Int would have to be a type class, which it's not
05:06:01 <Cale> Perhaps you mean Num a => a -> [a] ?
05:06:13 <exoarn> oh, yeah that is possible
05:06:45 <Cale> Type classes are used to constrain the types over which type variables range to just those which support a given interface
05:07:40 <Cale> For example, the constraint Num a means that whichever type 'a' you choose had better support some basic numeric operations like (+), (*) and fromInteger
05:08:25 <Cale> @let foo x y = x^2 + y^2
05:08:26 <lambdabot>  Defined.
05:08:29 <Cale> :t foo
05:08:30 <lambdabot> Num a => a -> a -> a
05:08:38 <Cale> > foo 3 4 :: Integer
05:08:40 <lambdabot>  25
05:08:43 <Cale> > foo 3 4 :: Double
05:08:45 <lambdabot>  25.0
05:08:51 <Cale> > foo 3 4 :: Complex Double
05:08:52 <lambdabot>  25.0 :+ 0.0
05:09:32 <joshkirklin> For the yesod users: I don't seem to be getting gzip compression on statically served files with the scaffolded site. Is this the default behaviour?
05:09:43 <exoarn> ah so Num is a set off types that support mathmatic operations?
05:09:51 <Cale> yeah
05:10:09 <exoarn> ok I think I get it, thanks a lot :)
05:11:11 <tech2> Cale: if Num is a type class, then what's Int, a concrete type? If so, why shouldn't you be able to specify it left of => as a short-hand?
05:11:46 <joash> you can just write Int -> Int in that case
05:12:10 <Cale> tech2: Int is a type
05:12:12 <jimki> hey how would one use cabal-repl with a project which has a library and an executable? `cabal repl exe:foo` fails with errors about the library's dependencies being hidden
05:13:00 <jimki> I can make it work by duplicating all the build-depends entries in the library section to executable, but I'd rather not do that
05:13:21 <tech2> joash: yes, but then if you had  funcname :: Num a => a-> [a] -> Int -> Int    it's a bit messy. Just wondered why it's not accepted?
05:14:00 <Cale> tech2: If you turn on enough extensions, you can write (Int ~ a) => a -> a  or whatever
05:14:18 <Cale> The  Int ~ a  is a type equality constraint, specifying that the types Int and a must be equal
05:14:31 <Cale> I wouldn't do that without a good reason though.
05:14:50 <tech2> Cool, thanks Cale (and others)
05:16:32 <haasn> (ReallyLongAndComplexTypeNameThatIReallyDon'tWantToWriteTwice ~ a) => a -> a -> [a]
05:17:06 <Cale> If you're naming your types like that, maybe you should consider better names, or synonyms
05:17:42 <tdammers> modules, too
05:17:45 <joash> what's a good reason to use a type equality constraint?
05:17:53 <tdammers> can just alias those while importing
05:18:05 <Cale> When you're also using type families
05:18:29 <Cale> So as to be able to express the idea that some type family applied to a given parameter is equal to some specific type
05:19:11 <Twey> Zekka: There are lots of categories in Haskell, and you can define your own.  Hask is just the category of Haskell types.
05:20:30 <Twey> And that's what a Functor is a(n endo)functor over
05:21:09 * hackagebot api-tools 0.4.0.1 - DSL for generating API boilerplate and docs  http://hackage.haskell.org/package/api-tools-0.4.0.1 (AdamGundry)
05:23:44 <Tjr> How much of "backpack"  is usable right now, to replace "cabal"?
05:23:44 <Tjr> The paper says it's awesome (good to know), and reddit says it's not complete (booh).
05:51:58 <merijn> Tjr: Implementation started only a few weeks/months back, afaik
05:52:17 <merijn> Tjr: I wouldn't expect it to be available for production use until at least 1 to 2 years from now
05:52:20 <Tjr> IOW, it's not worth reading the paper, right?
05:52:27 <merijn> That depends
05:52:49 <merijn> Do you care about the general principles or about practically using it *right now*
06:01:21 <kvelicka> hi, does anyone here have experience with Data.Binary.Get incremental interface?
06:02:41 <alpy> is normal ghc --make command does not produce a executable?
06:03:26 <merijn> kvelicka: It's better to just ask your question :)
06:04:45 <kvelicka> merijn: I suppose, just not sure whether I could phrase it simply
06:05:15 <kvelicka> I guess it would be "what is the idiomaic way of using the helper functions for the incremental interface of Get?"
06:05:53 <kvelicka> I've looked at examples for the cassava library that also provides an incremental interface but it doesn't work quite the same way
06:06:50 <merijn> kvelicka: It really depends on what you want to do? If you want to just loop, I think pushChunks/pushEndOfInput is all you need
06:06:54 <merijn> That, or pattern matching
06:07:43 <kvelicka> merijn: pushChunks is lazy, avoiding laziness is at the core of what I'm trying to do :)
06:08:52 <merijn> kvelicka: Then just repeatedly call pushChunk or pattern match?
06:09:23 <merijn> kvelicka: I'm not really sure what the difficulty you're seeing is? :)
06:31:36 <raschwell> Is HSQL up-to-date?
06:39:03 <ppseafield> With an aeson Object how would I insert an additional key: value?
06:45:18 <gregnwosu> anyone know if there is a ghc 7.8.x armhf binary anywhere ?
06:51:48 <k00mi> ppseafield: Object is just a HashMap, so you can use the functions from Data.HashMap
06:53:06 <k00mi> e.g. Data.HashMap.insert "foo" Null obj
07:04:22 <tylerholien> Question about using a Haskell library from foreign code (as in http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/ffi-ghc.html#ffi-library)
07:04:43 <tylerholien> If the call to hs_exit is forgotten, what happens?
07:05:06 <tylerholien> e.g. if the program using the library exits prematurely
07:10:00 <ppseafield> k00mi: I thought so, but is there no other way? Is there no aeson function that does that? Using Data.HashMap.insert I have to unwrap the Object constructor and then rewrap it.
07:10:49 <k00mi> ppseafield: Object is just a type synonym, there is no constructor
07:11:09 <ppseafield> Right, but I have a Value.
07:11:25 <ppseafield> data Value = Object !Object ....
07:11:30 <k00mi> ah
07:15:18 <ineol> How could I pass an arbitrary option to gcc (eg, to use c++11) through GHC when compiling a file for FFI ?
07:16:36 <bergmark> ppseafield: make a combinator for it, modifyObject :: (HashMap Text Value -> HashMap Text Value) -> Value -> Value
07:18:00 <SrPx> Hello, what is this? dr2 m = unfoldr ((\x-> fmap (,drop m x) (listToMaybe x)))
07:19:16 <bergmark> @type \m -> unfoldr ((\x-> fmap (,drop m x) (listToMaybe x)))
07:19:16 <lambdabot> Int -> [a] -> [a]
07:19:30 <tylerholien> ineol: -foptc should work
07:19:46 <Algebr> Why do some languages allow for implicit coercion? Is it because that makes things easier to implement? Or because it gives a programmer more flexibility?
07:19:47 <tylerholien> ineol: e.g. -optc-ffast-math
07:20:11 <bergmark> Algebr: i'm sure it's more work to implement it
07:20:12 <ppseafield> bergmark: Yeah, thanks. That's what I'll do.
07:20:55 <SrPx> bergmark: I mean, what is the colon for?
07:21:03 <SrPx> ",drop" ?
07:21:05 <bergmark> Algebr: the ecmascript spec contains a pretty complicated ruleset for it
07:21:08 <tylerholien> ineol: Check out the "FORCING OPTIONS TO PARTICULAR PHASES" section of the ghc man page
07:21:21 <bergmark> SrPx: TupleSections
07:21:22 <michaelt> SrPx: TupleSections ?
07:21:28 <SrPx> vish
07:21:33 <Algebr> bergmark: then why go through all that trouble? Was it then for programmer's ease of use?
07:21:34 <bergmark> (,x) = (\y -> (y,x))
07:21:36 * frerich wishes GHC would allow something like '(id :: Word16 -> Word16) (3:: Word8)', i.e. passing a value of a type with a smaller range where a type with a larger range is expected.
07:21:37 <SrPx> oh ok I get it, thanks
07:21:56 <SrPx> so it is the same as (, (drop m x))
07:22:05 <michaelt> Yes
07:22:22 <SrPx> for a little moment I had some lispy feeling
07:22:23 <michaelt> oh wait not the reverse
07:22:36 <bergmark> Algebr: yeah i suppose that was their thought, but there are so many edge cases (at least in JS) that it more often than not just causes problems
07:22:55 <michaelt> SrPx: oh double wait, (, (drop m x)) is already a tuple sectioin
07:23:13 <michaelt> tuple section, rather
07:23:57 <bergmark> Algebr: garbage in garbage out
07:24:24 <pjdelport> frerich: You'd still need a fromInteger or similar to coerce the actual representation
07:25:14 <merijn> ineol: There's two easy ways 1) use cabal for compiling your code which has a C options field and 2) manually compile your C file using a Makefile/whatever and link the object file using GHC
07:25:27 <merijn> ineol: GHC is perfectly happy to link C object files into your haskell binaries
07:28:39 <ineol> merijn: actually I'm trying to compile a cabal project, but when I added a cc-options field, it could't find the include dirs, so it seemed to me it erased the options that came from the Setup.hs file
07:31:23 <michaelt> ineol: Do you have a c-sources and include-dirs field in the .cabal file?
07:31:43 <merijn> ineol: There's an include-dirs field too
07:33:04 <ineol> Basically what they do is call a program 'llvm-config' that generates the options, so everything is done in Setup.hs
07:48:12 <Marquis> hello haskellers. how is it possible to change the way something is calculated in my programm? like i have 3 different functions i could use. how can i select a certain one if i add a special argument when i start my programm. or is it possible to return a function from a function?
07:49:07 <kvanb> Marquis: you're in luck
07:49:17 <kvanb> you're using a functional programming language, and everything is a function.
07:49:49 <c_wraith> kvanb: no, a string is not a function
07:49:52 <merijn> kvanb: That's not true
07:49:58 <c_wraith> kvanb: or any other data type
07:50:01 <kvanb> > let { x = (+3); y = (+100); z = True } in (if z then x else y) 5
07:50:03 <lambdabot>  can't find file: L.hs
07:50:03 <kvanb> shush
07:50:07 <kvanb> > let { x = (+3); y = (+100); z = True } in (if z then x else y) 5
07:50:08 <lambdabot>  8
07:50:12 <merijn> @google conal everything is a function in haskell
07:50:14 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
07:50:14 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
07:50:25 <merijn> See that for details
07:50:45 <merijn> Marquis: Anyway, the good news is that you have been returning functions from function since you started using Haskell!
07:51:21 <gregnwosu> http://learnyouahaskell.com/input-and-output#command-line-arguments
07:51:25 <c_wraith> Marquis: functions in haskell only take one arg.  So if you write a function that looks like it takes two args, it's actually a function that takes one arg and returns a function.
07:52:01 <Marquis> okay, i know that
07:52:10 <gregnwosu> main = do
07:52:10 <gregnwosu>    args <- getArgs
07:52:10 <gregnwosu>    progName <- getProgName
07:52:13 <gregnwosu>    putStrLn "The arguments are:"
07:52:13 <gregnwosu>    mapM putStrLn args
07:52:17 <gregnwosu>    putStrLn "The program name is:"
07:52:20 <gregnwosu>    putStrLn progName
07:52:34 <c_wraith> gregnwosu: please use lpaste for code samples longer than 1 line
07:52:37 <c_wraith> @where lpaste
07:52:37 <lambdabot> http://lpaste.net/new/haskell
07:52:52 <merijn> > let f b = if b then (+) else (-) in f True 2 3
07:52:53 <lambdabot>  5
07:52:57 <merijn> > let f b = if b then (+) else (-) in f False 2 3
07:52:58 <lambdabot>  -1
07:53:04 <merijn> Marquis: Something like that?
07:53:07 <Marquis> i would like something like this: choose x | x == 0 = fakulty | x == 1 = fibonacci | x == 2 = acc 2 x
07:53:19 <Marquis> yes something like that
07:53:28 <merijn> Marquis: As long as all your functions have the same type, it will "Just Work" (TM)
07:53:38 <hexagoxel> fyi two days ago i wondered how to handle problem that (f)mapping breaks sharing. stable-memo (Data.StableMemo) seems to address exactly that issue (it internally uses stablenames, just like Data.Reify)
07:53:57 <Marquis> i will make them have the same type
07:54:21 <Marquis> okay i will try now with a small example
07:54:43 <gregnwosu> c_wraith:
07:54:48 <gregnwosu> sure sorry
07:56:49 <c_wraith> gregnwosu: anyway, what's your question about that code?
08:00:51 <Marquis> works perfect. thanks merijn
08:01:43 <haasn> f x | x == 0 = ... | x == 1 = ... | x == 2 = ...  is needlessly verbose
08:01:55 <haasn> You can just write that as f 0 = ...; f 1 = ...; f 2 = ...
08:02:02 <haasn> It's semantically the same thing
08:03:15 <frerich> haasn: Using guards allows having a 'where' clause affect all possibilities though.
08:04:23 <haasn> f x = case x of ...  :)
08:04:30 <haasn> f = \case ... -- woo GHC 7.6
08:11:19 <SrPx> How do I enable TupleSections without a compile flag?
08:11:47 <haasn> {-# LANGUAGE TupleSections #-}
08:12:03 <haasn> Somewhere at the top level of your module, preferably at the beginning of the file
08:13:47 <Marquis> i have type Point a = (V.Vector Double, a) and type Distance = V.Vector Double -> V.Vector Double -> Double   .  How can i make Distance look like this: type Distance = Point a -> Point a -> Double? type variable a is not in scope
08:14:17 <SrPx> haasn: thanks, just a question, is that common / acceptable, or is it considered a bad practice?
08:14:24 <SrPx> I mean, that kind of pragma
08:15:09 <merijn> Marquis: "type Distance a = Point a -> Point a -> Double"?
08:15:10 <haasn> SrPx: Do you mean TupleSections in particular?
08:15:18 <SrPx> no, that pragma in general
08:15:26 <SrPx> and also tuplesections, why not
08:15:39 <Marquis> so i just need an a in Distance...
08:16:09 <Marquis> thanks, worked
08:16:18 <Marquis> merijn you are smart
08:16:27 <haasn> SrPx: It's considered idiomatic to have every language pragma used by a file in a {-# LANGUAGE #-} at the top of the file
08:17:02 <haasn> SrPx: Using compiler flags is rather uncommon, though it can be seen from time to time in .cabal files if you need that flag in your entire library
08:17:13 <SrPx> I see, but it is not a problem to use them at all, right? Not like it would be to, say, use JS Harmony features in a page.
08:17:44 <haasn> Do you mean the practice of using language extensions in general?
08:18:09 <SrPx> yea
08:18:24 <SrPx> is it something I should worry about, or just use and abuse without fear
08:18:33 <SrPx> ie, is there any cons?
08:20:18 <merijn> SrPx: The cons are "it might not compile on a non-GHC compiler or on old GHC versions", depending on which extension
08:20:27 <SrPx> hm I see (=
08:20:35 <SrPx> how do I tell the bot to make something infix?
08:20:39 <merijn> SrPx: If you only care about recent-ish versions of GHC for your code, then there is no cons (well mostly, some extensions are somewhat unsafe)
08:20:44 <SrPx> wow, no. I mean point-free *
08:20:59 <SrPx> merijn: OK (=
08:21:08 <merijn> Mostly You usually want to stay away from things like IncoherentInstances, OverlappingInstances and UndecidableInstances
08:21:23 <c_wraith> eh?  UndecidableInstances is fine
08:21:28 <c_wraith> The other two are not
08:21:37 <SrPx> Hm I have no idea what they are
08:22:05 <merijn> c_wraith: I didn't mean to imply undecidable was unsafe (although I just realise I did), just that you probably want to avoid it :)
08:22:29 <c_wraith> merijn: I use it all the time.  There are lots of things that require it that are perfectly sane things to do. :)
08:22:37 <SrPx> > point-free
08:22:38 <lambdabot>  Not in scope: ‘point’
08:22:38 <lambdabot>  Perhaps you meant ‘print’ (imported from Prelude)Not in scope: ‘free’
08:22:47 <merijn> SrPx: GHC's manual on the various extensions is pretty good at describing if and how extensions can break things
08:23:02 <khyperia> @pl (\x -> x)
08:23:02 <lambdabot> id
08:23:03 <SrPx> merijn: hm okay! thank you
08:23:09 <SrPx> @pl (\x -> fmap (,(drop 2 x)) (listToMaybe x))
08:23:09 <merijn> c_wraith: That's because you haven't embraced out new TypeFamilies overlords? ;)
08:23:09 <lambdabot> (line 1, column 15):
08:23:09 <lambdabot> unexpected ','
08:23:09 <lambdabot> expecting expression
08:23:20 <merijn> s/out/our
08:23:29 <SrPx> @pl (\x -> fmap (\i→(i,(drop 2 x))) (listToMaybe x))
08:23:29 <lambdabot> (line 1, column 17):
08:23:29 <lambdabot> unexpected "\134"
08:23:29 <lambdabot> expecting letter or digit, operator, pattern or "->"
08:23:34 <SrPx> @pl (\x -> fmap (\i->(i,(drop 2 x))) (listToMaybe x))
08:23:35 <lambdabot> ap (fmap . flip (,) . drop 2) listToMaybe
08:23:37 <merijn> Most things I would've used UndecidableInstances for I'd much rather implement using TypeFamilies now
08:23:38 <SrPx> oh no
08:24:05 <c_wraith> merijn: I can't use type families with UndecidableInstances, usually. :)
08:24:22 <SrPx> I just want the bot to eliminate the first \x →, what can I do?
08:24:52 <SrPx> oh wait
08:24:55 <khyperia> SrPx, note that a) there's a package on hackage that allows you do do that command locally so you don't spam irc, and b) pointfree is usually not a good idea, it gets really complicated and unmaintainable when you get into big expressions
08:25:03 <c_wraith> merijn: for instance, when I wrote up http://stackoverflow.com/a/24739111/383200, I was surprised I needed UndecidableInstances. :)
08:25:15 <SrPx> khyperia: ah, I didn't know, sorry. Is there an web app?
08:25:47 <khyperia> You could also PM lambdabot. I'm not saying you're in the wrong, just for the future when you don't want to bug people :)
08:25:51 <khyperia> Don't think there's a web app
08:26:23 <SrPx> khyperia: okay (:
08:26:41 <khyperia> Lemme try manually point-free-i-fy-ing that for you, though
08:28:05 <khyperia> I think, if I matched parens right, it's just (fmap (\i->(i,(drop 2 x))) . listToMaybe), simple case of (\x -> f (g x)) to f . g
08:28:56 <fread2282> any pipe experts here?
08:29:16 * fread2282 is way confused with pipes
08:29:42 * michaelt  saw k00mi around a while ago
08:30:20 <michaelt> oh, what's your problem though fread2282 ?
08:30:26 <klao> fread2282: what are you interested in?
08:31:06 <khyperia> but yeah, SrPx, for future note, how I figured that out was replaced that inner lambda with "undefined", so it read (\x -> (fmap undefined) (listToMaybe x)), and from there it's a simple case of (.), and then re-add the undefined to the original lambda.
08:31:11 <fread2282> specifically (I think): how do I connect ‘P.Proxy () ByteString () ByteString m r' where ‘P.G.Producer ByteString m2 r1 -> P.G.Producer ByteString m2 r1’ is expected
08:31:30 <khyperia> I did that to reduce noise so I could see patterns better.
08:31:38 <michaelt> so the first is pipe bs bs; the second is a function on producers
08:31:52 <fread2282> here's my attempt so far, w/ context: http://lpaste.net/1695494067296665600
08:32:11 <michaelt> fread2282: so >-> proxythingy makes a function on producers, fread2282
08:32:44 <fread2282> michaelt: gives me http://lpaste.net/2440059427248668672 error
08:33:35 <klao> fread2282: can you paste your actual code, not just the error message? :)
08:33:50 <SrPx> khyperia: hey sorry, I'm back
08:33:54 <fread2282> http://lpaste.net/1695494067296665600
08:34:01 <fread2282> that's the code
08:34:28 <klao> But, it generally worries me that you are mixing pipes and conduits...
08:34:45 <EvanR_> dont cross the streams!
08:34:54 <MP2E> haha
08:35:02 <fread2282> klao: I'm not?
08:35:22 <fread2282> I'm switching to pipes from conduit
08:35:51 <EvanR_> pipe × conduit
08:36:24 <michaelt> using pipes with conduit is like using lists or maybes with conduit.
08:36:59 <EvanR_> > let (×) = const id in 3 × 4
08:37:00 <michaelt> P.P.map (fromJust. IRC.decode) is the same as something like P.map decode >-> P.concat
08:37:01 <lambdabot>  4
08:37:28 <khyperia> SrPx, out of curiosity, what exactly is that expression for? It's a bit... strange. As far as I can tell, it's taking the head, skipping an element, then the rest of the list?
08:37:48 <khyperia> You might be better with a case block instead of that wonkyness.
08:39:08 <SrPx> khyperia: I'm not sure I understand you, if I just replace undefined by the original lambda and simply use function composition, then it will not have access to the "x" out there
08:39:20 <khyperia> Oh, right, forgot about that, sorry.
08:39:25 <khyperia> Hmm.
08:39:26 <SrPx> khyperia: and it is just an exercise about how to create a function that skips each other 2 elements in a list
08:39:29 <SrPx> khyperia: oh, okay!
08:39:41 <SrPx> khyperia: I was just implementing it in different ways to practice
08:39:57 <SrPx> that was the shortest I got, but not the cleanest
08:40:25 <khyperia> Oh, as in takes a list, and removes all the odd elements? Or just removes the first two, as well as returning head?
08:40:30 <SrPx> but the cleanest is an actual recursive algorithm so I couldn't actually do a good job here
08:40:36 <fread2282> cleaned up the code a bit: http://lpaste.net/7823885771273666560
08:40:47 <SrPx> khyperia: it returns each other two, ie, foo [1,7,2,9,5,5,0] = [1,2,5,0]
08:41:50 <fread2282> michaelt: yep, but P is Pipes and P.P is Pipes.Prelude
08:42:39 <michaelt> fread2282: yeah, i'm decoding it. 'maps' places a pretty strong requirement on the argument.  I think thats part of this.
08:43:20 <michaelt> maps :: (Functor g, Monad m) =>  (forall r. f r -> g r) -> FreeT f m x -> FreeT g m x
08:43:45 <b_jonas> > let { foo x = let { m (_ : u : v) = u : m v; m _ = []; } in m (undef : x); } in foo [1,7,2,9,5,5,0];
08:43:46 <lambdabot>  <hint>:1:100: parse error on input ‘;’
08:43:48 <SrPx> I am just learning about classes... is it wrong to think of a class declaration as a function over types?
08:43:58 <SrPx> from types to types
08:44:39 <b_jonas> what? parse error where?
08:44:52 <fread2282> michaelt: yea, but lines :: Monad m => Lens' (Producer ByteString m x) (FreeT (Producer ByteString m) m x)
08:45:09 <b_jonas> > let { foo x = let { m (_ : u : v) = u : m v; m _ = []; } in m (undef : x); } in foo [1,7,2,9,5,5,0]
08:45:10 <lambdabot>  Not in scope: ‘undef’
08:45:10 <lambdabot>  Perhaps you meant ‘under’ (imported from Control.Lens)
08:45:12 <k00mi> michaelt: why did you mention me?
08:45:17 <b_jonas> > let { foo x = let { m (_ : u : v) = u : m v; m _ = []; } in m (undefined : x); } in foo [1,7,2,9,5,5,0]
08:45:18 <lambdabot>  [1,2,5,0]
08:45:21 <b_jonas> better
08:45:22 <michaelt> k00mi: sorry, it was a mistake
08:45:43 <k00mi> ah, ok
08:47:10 <pjdelport> SrPx: A class is more like a bundle of polymorphic functions that must all be implemented together for some concrete type.
08:47:22 <michaelt> k00mi: k0001 is a pipes expert, so inadequate attention and autocomplete led to grief
08:47:29 <mokkake> hi, does anyone know good learning ressources about arrows ?
08:48:08 <Gurkenglas> :t splitOn
08:48:08 <lambdabot> Eq a => [a] -> [a] -> [[a]]
08:48:11 <Gurkenglas> @hoogle splitOn
08:48:12 <lambdabot> Data.Text splitOn :: Text -> Text -> [Text]
08:48:12 <lambdabot> Data.Text.Lazy splitOn :: Text -> Text -> [Text]
08:48:14 <Gurkenglas> What is this
08:48:26 <michaelt> fread2282: yes, 'over lines' isn't the problem. it's that 'p' is not general in its return type
08:48:40 <SrPx> pjdelport: hmm
08:48:44 <SrPx> I see
08:49:29 <michaelt> fread2282: so xyz f g  = over lines (maps (>-> (P.map f >-> P.map g)))  typechecks
08:49:36 <k00mi> michaelt: I see, no problem ;-)
08:49:48 <michaelt> fread but xyz f g p = over lines (maps (>-> (P.map f >-> p >-> P.map g))) doesn't
08:49:55 <pjdelport> SrPx: That's why type classes are referred to as "ad hoc" polymorphism, as opposed to parametric polymorphism.
08:51:24 <pjdelport> SrPx: A type like map :: (a -> b) -> [a] -> [b] is an example of parametric polymorphism, because it must work for *any* types a and b as parameters to it.
08:52:06 <pjdelport> SrPx: Among other things, this gives you a guarantee that map cannot inspect or behave differently for individual types of a and b: all it can do is apply the provided function to them.
08:52:24 <pjdelport> (That's why parametric polymorphism gives you theorems for free.)
08:52:45 <fread2282> michaelt: right, I got it to work by giving (runClientSimpleP :: P.MonadIO m => P.N.Socket -> (forall r. P.Pipe IRC.Message IRC.Message m r) -> m ())
08:53:35 <michaelt> fread2282: right, that's the kind of thing you need to take account of. I was wondering what this pipe was supposed to be like
08:53:39 <fread2282> It'd be nice to be able to use the return type, but the conduit version doesn't let you so eh
08:54:12 <pjdelport> SrPx: Type classes, on the other hand, *do* give you a way to operate differently on individual polymorphic types passed to a function, but in a way where you explicitly have to provide different "ad hoc" implementations for each concrete type that you want to operate on.
08:54:13 <fread2282> Ideally it would be (runClientSimpleP :: P.MonadIO m => P.N.Socket -> P.Pipe IRC.Message IRC.Message m r -> m r)
08:54:39 <michaelt> fread2282: well, it has to be scrapped whatever it is, since it's being replaced at each FreeT layer
08:54:43 <pjdelport> SrPx: So you might have: map show :: Show a => [a] -> [String]
08:55:11 <SrPx> pjdelport: the thing that confused me is when I was reading about functors and trying to implement them. `class Mappeable t where mapp :: (a → b) → t a → t b`. Here, `a` and `b` are values, but `t` is a type, right? So that's why I have `instance Mappeable [] where...`. I'm sending the type [] to the function Mappeable, which then returns another type. That is why I made
08:55:21 <SrPx> the association that Mappeable is kinda like a function between types
08:55:22 <fread2282> michaelt: right. I guess I could wrap it in a StateT somewhere to get it to work
08:55:34 <michaelt> fread2282: i mean, if i'm understanding
08:55:40 <fread2282> or no, but something
08:55:58 <fread2282> michaelt: yea that makes sense
08:56:13 <michaelt> so the user defines a Pipe as the client?
08:56:24 <pjdelport> SrPx: Now, the a type variable is still polymorphic, but it's more restricted than it was before with unrestricted parametric polymorphism: instead of it being any type, it must now be any *showable* type (i.e., any type that provides an instance of show, ad hoc)
08:56:30 <khyperia> b_jonas, that "skip every other one" is impressive, heh.
08:56:49 <fread2282> michaelt: yep
08:58:32 <pjdelport> SrPx: In a sense, all parametric types are a function between types.
08:58:45 <michaelt> fread2282: right, I'm sort of getting the structure now.  Yes, you could somehow store the result of the last invocation of the pipe in a StateT layer. The number of transformers would be getting close to my limit though...
08:59:04 <SrPx> pjdelport: (I don't exactly follow how `map :: (a → b) → [a] → [b]` gives you that guarantee and what kind of guarantees you can have from parametric polymorphism, in general, but it kinda makes sense, intuitively)
08:59:17 <pjdelport> SrPx: That's why you can read the full type of something like map as: map :: forall a b. (a -> b) -> [a] -> [b]
08:59:20 <Gurkenglas> > catMaybes $ zipWith $ (cycle [Just, const Nothing])
08:59:21 <lambdabot>  Couldn't match expected type ‘[Data.Maybe.Maybe a]’
08:59:21 <lambdabot>              with actual type ‘[a0] -> [b0] -> [c0]’Couldn't match expected t...
08:59:21 <lambdabot>              with actual type ‘[a1 -> Data.Maybe.Maybe a1]’
08:59:26 <fread2282> michaelt: also I could maybe make my own maps that does something else (or maybe just expects r to be ()), but this works for now
08:59:30 <Gurkenglas> > catMaybes $ zipWith $ (cycle [Just, const Nothing]) [1,7,2,9,5,5,0]
08:59:32 <lambdabot>  Couldn't match expected type ‘[Data.Maybe.Maybe a]’
08:59:32 <lambdabot>              with actual type ‘[a0] -> [b0] -> [c0]’Couldn't match expected t...
08:59:32 <lambdabot>              with actual type ‘[a1 -> Data.Maybe.Maybe a1]’
08:59:44 <Gurkenglas> > catMaybes $ zipWith ($) (cycle [Just, const Nothing]) [1,7,2,9,5,5,0]
08:59:45 <lambdabot>  [1,2,5,0]
08:59:48 <Gurkenglas> There we go
09:00:23 <pjdelport> SrPx: The "forall" is kind of like a type-level lambda of two variables: you "call" it with two types, e.g. String and Int, and that gives you back a concrete type like (String -> Int) -> [String] -> [Int]
09:01:04 <pjdelport> SrPx: So in a certain sense you can also think of instantiating a type class in that sense, as instantiating a type variable, but it's not special to type classes themselves.
09:02:04 <michaelt> fread2282: can you just make the user define a transformation on a producer : p :: Producer IrcMessage m r -> Producer IrcMessage m r
09:02:06 <btcNeverSleeps> Which dead-tree Haskell book would you recommend to an Haskell beginner to read while on extended vacation, next to the pool, while (moderately) drinking mojito's?  (I've done quite some Clojure so I'm familiar with lazyness --but not non-strictness-- and FP --even if Clojure is less pure than Haskell)
09:02:54 <dottedmag> btcNeverSleeps: http://www.nostarch.com/lyah.htm
09:02:54 <michaelt> btcNeverSleeps: Parallel and Concurrent Haskell should be the second one.
09:03:05 <pjdelport> SrPx: Type class instances are actually a lot less like functions than other things that take type parameters, because they specifically do not take any type and give you a new type: the instance you provide only works with the individual type parameter(s) for the instance.
09:04:03 <fread2282> michaelt: yea I guess, but I still have to use maps, right?
09:04:17 <Gurkenglas> I imported Data.Text.Lazy, and now it makes ambigious a whole lot of the Prelude functions I was using. Can I remedy that without having to prepend Prelude. everytime?
09:04:19 <btcNeverSleeps> Online I did prefer: www.seas.upenn.edu/~cis194/lectures.html to LYAH.  Is there any other beginner book that you'd recommend instead of LYAH?
09:04:39 <pjdelport> So with "instance Mappeable [] ...", you're not providing a type and getting a type back: it's more like providing an *implementation* (i.e. the instance for []) as parameter to an existing set of types (i.e., the methods of Mappeable)
09:04:41 <fread2282> what does that get me?
09:04:45 <michaelt> fread2282: yes, I was thinking you are parsing IrcMessages out of the lines of a bytestream
09:04:59 <michaelt> and writing them back
09:05:13 <moghedrin> Gurkenglas: import qualified Data.Text.Lazy as TL
09:05:21 <Gurkenglas> Thanks
09:05:54 <moghedrin> Gurkenglas: Then whenever you have a function from Data.Text.Lazy you want, you'll prepend that with TL.
09:06:07 <Gurkenglas> Ya, I remember now, thx
09:06:15 <moghedrin> Gurkenglas: np :)
09:06:19 <btcNeverSleeps> michaelt: you mean the O'Reilly book "Parallel and Concurrent Programming in Haskell" by Simon Marlow?
09:06:27 <fread2282> michaelt: yep, but I'm actually the user of this function and build a abstraction of IRC on top of this function
09:06:38 * hackagebot pngload-fixed 1.0 - Pure Haskell loader for PNG images  http://hackage.haskell.org/package/pngload-fixed-1.0 (robagar)
09:07:15 <michaelt> btcNeverSleeps: yes, I think it's the most up to date book, but it presupposes you know a bit. It explains things like STM, the async library
09:07:18 <michaelt> eetc
09:08:18 <michaelt> fread2282: I'm not sure, but I have a suspicion that a function Producer IrcMessage -> Producer IrcMessage will give you more control, though it might seem less "pipes like"
09:09:04 <fread2282> michaelt: yea Ioll do that if I need
09:09:11 <fread2282> s/o/'/
09:09:40 <Gurkenglas> If I know I'm going to call foo 25 a lot of times, how do make Haskell save the result after doing it the first time?
09:09:54 <MP2E> Gurkenglas: http://www.haskell.org/haskellwiki/Memoization
09:10:03 <MP2E> memoization will help with that
09:10:19 <EvanR_> you can use foo25 = foo 25 instead of foo 25
09:10:22 <EvanR_> ;)
09:11:46 <Gurkenglas> EvanR_, won't that just substitute the definition and recompute foo25 each time?
09:11:54 <EvanR_> nope
09:12:36 <EvanR_> that would be a waste
09:12:53 <Gurkenglas> So I don't want to put humongous intermediate results into a top-level constant?
09:13:18 <pjdelport> Gurkenglas: As a rule of thumb, all Haskell bindings (i.e., anything you give a name to) gets shared.
09:13:57 <Gurkenglas> It doesn't seem elegant that foo25 and foo 25 get treated differently, but okay
09:14:36 <EvanR_> they are treated the same, but i dont think it will often identify different "foo 25"s as the same thing, i.e. common subexpression elimination
09:14:41 <EvanR_> not sure though
09:15:29 <EvanR_> Gurkenglas: also it may not be as obvious what 'gigantic intermediate results' are
09:15:38 <Gurkenglas> If it doesn't do common subexpression elimination on that, then they are treated differently, right?
09:15:53 <EvanR_> the semantics of the program are the same
09:16:11 <EvanR_> but space performance is not easy to infer
09:16:27 <Gurkenglas> Like, I don't want to write:
09:16:29 <pseudolio> Doing CSE on everything isn't a good policy.
09:16:53 <EvanR_> explicit memoization as mentioned above is probably a more reliable way when thats what youre trying to do
09:17:11 <Gurkenglas> a :: IO String            a = readFile "a.txt"
09:17:18 <Gurkenglas> b :: IO String            b = readFile "b.txt"
09:17:26 <EvanR_> now thats a whole nother case
09:17:43 <EvanR_> if youre thinking of the actual effects
09:17:53 <Gurkenglas> c :: IO String         c = iocrossproduct a b
09:18:04 <EvanR_> whats iocrossproduct?
09:18:05 <cin> > map snd . filter fst . zip (cycle [True,False]) $ [1..10]
09:18:06 <lambdabot>  [1,3,5,7,9]
09:18:11 <cin> Gurkenglas, ^ :)
09:18:46 <Gurkenglas> Noice.
09:19:24 <Gurkenglas> iocrossproduct is some function defined elsewhere that takes two io strings and crossproducts the chars together somehow, returning a humongous string
09:19:47 <EvanR_> it doesnt return a string at any point
09:20:11 <Gurkenglas> Sure, it takes a string and turns it into an io via returning
09:20:25 <Gurkenglas> -a+the
09:21:58 <michaelt> fread2282: oh wait, I'm getting a little clearer on this. You should use something like folds B.append B.empty decodeIrcMessage (view lines bytestringsource) :: Producer IrcMessage m r
09:22:12 <cin> Gurkenglas, i tried to do it with a foldr but realised that wouldn't work
09:22:38 <cin> > foldr ($) [] (zipWith ($) [(:),flip const] [1..5])
09:22:40 <lambdabot>  [1]
09:22:43 <cin> stops at the first =p
09:23:48 <Gurkenglas> Umm you forgot the cycle there.
09:24:06 <cin> oh, duh
09:24:19 <cin> > foldr ($) [] (zipWith ($) (cycle [(:),flip const]) [1..20])
09:24:20 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
09:24:23 <cin> i'm awesome!
09:24:49 <Gurkenglas> T'is not lazy tho
09:25:04 <cin> you sure?
09:25:05 <Gurkenglas> Or is?
09:25:10 <cin> > take 10 $ foldr ($) [] (zipWith ($) (cycle [(:),flip const]) [1..])
09:25:11 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
09:25:29 <Gurkenglas> Hmkay we're even on the stupid score
09:25:34 <cin> ^_^
09:26:27 <cin> the Maybe and Bool ones seem to be encodings of the consing decision directly, so i thought i'd try that
09:26:40 <Gurkenglas> consing?
09:26:49 <cin> using (:) directly, i mean
09:27:10 <cin> (:) is pronounced "cons", fwiw
09:27:28 <Gurkenglas> for what I... "wonder"?
09:27:38 <cin> construct a list. comes from lisp nomenclature
09:27:38 <josephle> for what it's worth
09:27:39 <MP2E> Constructor
09:28:05 <MP2E> oh right fwiw is for what it's worth
09:28:21 <cin> in case y'all didn't already know that factoid
09:28:27 <michaelt> fread2282: something like decodeWith dec producer = folds B.append B.empty dec (view PB.lines producer) ; this has type :: Monad m => (ByteString -> b) -> Producer ByteString m r -> Producer b m r
09:28:30 <MP2E> I didn't know it came from lisp :P
09:28:38 <Gurkenglas> Pretty sure we didn't all know that factoid.
09:28:41 <Gurkenglas> Dangit
09:28:44 <khyperia> cons, car, and cdr, whee
09:28:45 <MP2E> I just saw cons and assumed 'oh, List constructor.'
09:28:56 <int3___> cadaddadar
09:29:05 <Gurkenglas> Forgot a not, can't even do the straight math guy
09:29:20 <josephle> and then, if you go into Vector and Text and other "list-like" libraries, you might even see a snoc!
09:29:27 <Gurkenglas> consing=con sin *g*
09:29:43 <pjdelport> Does cons really come from Lisp, or predate it?
09:30:08 <cin> i'd expect it comes from lisp as a naming convention as lisp is like 50's old
09:30:21 <osfameron> it may have come from the *maths* that led to lisp ?
09:30:56 <int3___> if it came from math, i'd expect it to be some greek letter
09:30:57 <cin> possibly, but car and cdr do not
09:31:01 <michaelt> osfameron: I don't think they got car and cdr from math...
09:31:08 <josephle> car and cdr definitely come from lisp: http://en.wikipedia.org/wiki/CAR_and_CDR
09:32:15 <osfameron> "car and cdr have the advantage that short compositions of the functions can be given short and more or less pronounceable names" er, no
09:32:23 <michaelt> hah, right.
09:32:26 <lamehaskeller> how do i get out of prelude on the command line?
09:32:36 <tolt> :q
09:32:37 <int3___> what's so hard about cadddr? just roll your d's
09:32:39 <josephle> cdr is pronounced "cooder" iirc
09:32:48 <josephle> at least that's how the SICP pronounced it
09:32:50 <lamehaskeller> thanks tolt
09:33:14 <khyperia> thought it was "cadder", but that was my uni comp sci teacher who may have been wrong.
09:33:17 <MP2E> Lisp should come with a pronunciation guide ;P
09:33:17 <michaelt> lamehaskeller: other commands are shown with :?
09:33:22 <cin> the original 1960 lisp paper by mccarthy featured cons
09:33:42 <cin> that's pretty far back, going further would require some serious arcodeology
09:34:41 <osfameron> caar should be spelt something like '(index 0 0)' for preference.  encoding indexing in a funny looking word is possibly the most annoying thing I've ever seen in a programming language :-)
09:35:11 <cin> cdr is pronounced with a schwa
09:35:38 <cin> like the 'a' in america, əmerica
09:35:41 <cin> cədr
09:35:54 <josephle> or we can just call them head and tail like we do now
09:35:59 <cin> and cadr is pronounced as it looks.  "kadder"
09:36:34 <osfameron> with an "a" that's differentf from the one in "america" ?
09:36:34 <cin> i don't think anyone was proposing we use car and cdr in haskell
09:36:51 <cin> osfameron, yeah
09:36:58 <cin> as in "car"
09:37:10 <michaelt> Hm, "The function cxyr is a composition of the function cxr with cyr" ; this is curious notion of 'function composition'
09:37:13 <osfameron> so "carder" ?
09:37:26 <Hafydd> @let (car, cdr) = (head, tail)
09:37:28 <lambdabot>  Defined.
09:37:38 <Hafydd> > car [1..]
09:37:40 <lambdabot>  1
09:37:43 <cin> no first r, just "kadder". like "adder" with a k at the start
09:38:00 <osfameron> ah.  that's an entirely different vowel to the one in "car" in my English :D
09:38:06 <cin> they pronounce it in the SICP lectures
09:38:30 <michaelt> Oh, that would be decisive pronunciation at least in US English
09:38:53 <michaelt> osfameron may need a different authority.
09:38:56 <cin> osfameron, true, "car" and "adder" are different in american. forget car then
09:39:15 * osfameron will stick to "head" and "tail" :-)
09:40:19 <osfameron> @let headeadail = head . head . tail
09:40:20 <lambdabot>  Defined.
09:40:24 * osfameron runs away
09:40:25 <prophile> "fst" and "snd" are also quite good
09:40:58 <levi> The way that car and cdr compose is really cool and helpful, *if* you are writing lisp in the 70s. Everything in your program is some cons-tree structure, so shortcuts for extracting the right thing out of a weirdly-shaped cons-tree are nice.
09:40:59 <prophile> "laurel" and "hardy" might also qualify
09:41:00 <cin> yeah, lispers don't really do function composition
09:42:18 <cin> levi, yeah, when you can't write (. car cdr car), cadar seems attractive
09:42:30 <AleksejsHome> Hi, what am I doing wrong here? http://vpaste.net/o7d4M I took a bot from here http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source and modified to use RWS so I can save messages in stack.
09:42:34 <cin> of course, pattern matching is better
09:42:34 <levi> Thank goodness we have a variety of structured types and pattern matching now, though.
09:43:15 <orion> Hi. Why do people dislike TH so much?
09:43:39 <osfameron> cin: but even then, why not (index 0 0) ?  that's the intent, effectively
09:44:24 <cin> ofsameron: maybe if that produced a function
09:44:44 <cin> orion, because the interface it exposes to users is untyped and it's unclear what it will generate, making it effectively "magic"
09:45:13 <ruun> asfameron: there is one function for it (list-ref 0 0)   (in scheme) :]
09:45:17 <cin> orion, that's the technical side. socially, people who use TH tend not to bother documenting their functions very well so people have a bad experience
09:45:47 <osfameron> ruun: woo!
09:46:44 * hackagebot gang-of-threads 3.2.1 - Non-deterministic parallelism with bags  http://hackage.haskell.org/package/gang-of-threads-3.2.1 (bholst)
09:46:54 <monochrom> I don't dislike TH.
09:47:19 <orion> cin: Is it theoretically possible to make the TH interface typed?
09:47:42 <ruun> i guess it's a simple homage for lisp machine experiments :3 where car and cdr are primitive cpu instructions
09:47:58 <adas> if i see a typeclass like this -> 'class ObjectiveFunction f a' and a function of the typeclass like so -> 'evalObjective :: f -> [Genome a] -> Population a ... then is it safe to assume that the author of the lib is using MultiParam typeclasses?
09:49:28 <MP2E> orion : afaik typed Template Haskell is in the latest GHC
09:49:41 <jfischoff> adas: it you see ‘class ObjectiveFunction f a’ that implies MultiParam
09:49:41 <MP2E> it's just it was untyped for a long time, now you can have it typed or untyped though
09:49:56 <monochrom> yes adas, "class ObjectiveFunction f a" requires it, the two parameters are "f" and "a"
09:50:16 <HugoDaniel> what has happened to the haskell platform ? is it dead ?
09:50:17 * dfeuer untypes his last sentence.
09:50:20 <HugoDaniel> it kind smells like dead
09:50:33 <dfeuer> HugoDaniel, it's actually nearing a release.
09:50:34 <monochrom> it will come back
09:50:45 <adas> jfischoff: that alone couldn't imply 'multiparam'.. it could be a type with kind 'f a *'?
09:50:48 <monochrom> it is like Godzilla
09:50:51 <dfeuer> The website ... needs some work.
09:51:02 <monochrom> it will come back just when you think it's finally dead
09:51:23 <adas> oh but that be in paranthesis..no?
09:51:31 <monochrom> and then it will be the last one standing
09:51:38 <dfeuer> "paranthesis" is a misspelling of "parenthesis".
09:51:38 <adas> like so .. 'ObjectiveFunction (f a) where' if it was not multiparam
09:51:54 <monochrom> (f a) would be one parameter
09:52:01 <geekosaur> HugoDaniel, it's in testing
09:52:03 <dfeuer> But actually, in this case, that should be "parentheses".
09:52:17 <jfischoff> adas: that would be syntax error as written I think
09:52:38 <jfischoff> adas: you could write 'ObjectiveFunction (f :: * -> *) where
09:53:03 <adas> jfischoff: so how do you differentiate when a class is using Multiparam and when it is not?
09:53:13 <HugoDaniel> thanks
09:53:14 <HugoDaniel> :)
09:53:16 <adas> especially, when you can't see the source?
09:53:37 <jfischoff> adas: it is easy. You count the type variables.
09:53:58 <jfischoff> Foo a b —>  two type vars
09:54:04 <jfischoff> Foo a —> on type var
09:54:05 <monochrom> haddock shows you the header "class X a b c". ghci shows you the header too when ":info X"
09:55:02 <RyanGlScott> Is there a way to make a FunPtr from a Haskell function? e.g., withFun :: a -> (FunPtr a -> IO b) -> IO b
09:55:03 <monochrom> but if you're saying you don't understand the difference between "class X a b c" and "class X (a b c)" then that's another story.
09:56:46 * hackagebot cmdargs 0.10.9 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.10.9 (NeilMitchell)
09:57:03 <adas> think im getting it .. 'class ObjectiveFunction f a' and 'class Monad Either e' look similar. The former multiparam and the later is normal because 'Either' is a type and 'f' is a type var
09:57:30 <monochrom> no
09:57:32 <jfischoff> ‘class Monad Either e’ is a sytnax err
09:57:32 <josephle> RyanGlScott: foreign import ccall "wrapper"? http://hackage.haskell.org/package/base-4.7.0.1/docs/Foreign-Ptr.html#t:FunPtr
09:57:47 <adas> 'class Monad (Either e)'
09:57:57 <jfischoff> only type variables can appear in a class definition
09:58:02 <joelteon> RyanGlScott, why would you want to do that?
09:58:08 <jfischoff> instance Monad (Either e)
09:58:09 <RyanGlScott> josephle: Ah, I was wondering if there was a built-in way of doing it. I guess not.
09:58:23 <jfischoff> class Monad m
09:58:47 <RyanGlScott> joelteon: For convenience, mostly. It seems like code smell to have C functions for some simple things (especially pure functions).
09:58:59 <adas> geez i suck. mixed classes and instances.
09:59:19 <joelteon> well, if you have a Haskell function, you can call it already
09:59:27 <jfischoff> adas: seen worse ;)
09:59:29 <RyanGlScott> joelteon: Also, I'm working with an API that requires passing in function pointers.
10:00:38 <RyanGlScott> joelteon: Specifically, http://git.kernel.org/cgit/bluetooth/bluez.git/tree/lib/sdp.c#n1802
10:00:42 <joelteon> RyanGlScott: oh, fair point
10:01:24 <monochrom> use Control.Exception.bracket to do it yourself.
10:01:31 <int3___> the interface to the Read typeclass makes it look like calls to readsPrec are designed to be chained together... but how? I'm guessing that the List monad accumulates all possible parses, and the Writer monad can be used to accumulate the results of a parse... I feel like there must be a more out-of-the-box solution though
10:02:17 <monochrom> you have to do it yourself because you have to obtain your "X -> IO (FunPtr X)" from a foreign import call "wrapper" in the first place.
10:03:01 <monochrom> since there is no polymorphic "a -> IO (FunPtr a)", the library cannot provide you a polymorphic withFunPtr
10:03:02 <RyanGlScott> monochrom: Ultimately, I'll still have to create the function pointer with C code, right?
10:03:19 <monochrom> no
10:03:48 <AleksejsHome> any help?
10:03:52 <RyanGlScott> monochrom: ...explain further? You just said you'd need foreign imports.
10:04:25 <monochrom> it's foreign import ccall "wrapper" to be precise
10:04:40 <RyanGlScott> monochrom: Is "wrapper" not a C function?
10:04:43 <monochrom> and after being precise, it is not C code.
10:04:48 <monochrom> no
10:04:52 <int3___> ah, after looking at the gentle guide to haskell, I suppose I'm just supposed to write some function in the list monad that assembles the parsed pieces. scratch that question
10:05:03 <monochrom> you have read the doc of Foreign.Ptr, right?
10:05:18 <RyanGlScott> monochrom: Yes.
10:05:36 <monochrom> there is an example "mkCompare". no C code. all Haskell.
10:05:58 <RyanGlScott> monochrom: Oh, is "wrapper" automatically generated via macros?
10:06:27 <monochrom> I don't know about "via macros". the compiler auto-gen it in whatever way it sees fit
10:06:28 <RyanGlScott> monochrom: I mean, it's importing something.
10:06:41 <RyanGlScott> monochrom: That's what I meant. That's nifty.
10:07:05 <dfeuer> What is "C"?
10:07:09 <RyanGlScott> monochrom: I was under the impression that "wrapper" was an example C function. Looks like I didn't get adventurous enough and try that literally.
10:07:30 <monochrom> you need to read the Haskell 2010 report on FFI
10:07:45 <monochrom> chapter 8
10:07:52 <SrPx> What is the theory behind typeclasses? For everything else, I see there is an underlying theory. But where is type classes a part of system F?
10:08:02 <dfeuer> char [] C = "The C Programming Language";
10:08:11 <dfeuer> SrPx, type classes are not a part of system F.
10:08:22 <dwcook> SrPx, it's not, but you could consider each typeclass to be a datatype that gets passed implicitly.
10:08:29 <orion> 12:49:54 < dfeuer> HugoDaniel, it's actually nearing a release.
10:08:36 <SrPx> dfeuer: so Haskell is pretty much system F, except for typeclasses *specifically* ?
10:08:41 <orion> dfeuer: What about the language itself?
10:08:54 <triliyn> SrPx: GHC represents type classes as an additional argument
10:09:24 <dfeuer> SrPx, there are other important extensions to System F. I think case is one of them.
10:09:34 <dfeuer> orion, what about what language itself?
10:09:35 <SrPx> So it could be interpreted as a syntax sugar? It is not present, ie, in Core?
10:09:35 <triliyn> So Show a => a -> String is compiled to something resembling (a -> String) -> a -> String
10:09:40 <triliyn> I'm not sure if that's what you were asking about
10:10:03 <orion> dfeuer: Will there be anything like Haskell 2014?
10:10:07 <dfeuer> SrPx, Core has some extensions to System F.
10:10:09 <triliyn> (Show actually has more methods; in general, type classes end up as more like record arguments than like single functions)
10:10:31 <dfeuer> orion, how should I know? The language does continue to develop, especially on the type system front.
10:10:34 <MP2E> Core is technically based off System FC, itself an extension of System F that adds generalized algebraic datatypes
10:10:45 <dwcook> data Functor f = Functor { fmap :: forall a b. (a -> b) -> f a -> f b }
10:10:50 <SrPx> MP2E: ah makes sense
10:11:32 <SrPx> triliyn: I don't understand the conversion :(
10:12:10 <dfeuer> orion, I'd be very surprised to see a Haskell 2014, but maybe a Haskell 2016 or 2020.
10:12:52 <dfeuer> orion, there's also a huge difference between language development and standard development.
10:12:53 <triliyn> SrPx: you can imagine (though I don't think it works EXACTLY this way) that each typeclass compiles down to a "record type", like data Show a = MkShow { show :: a -> String }
10:13:20 <triliyn> Or data Num a = MkNum { (+) :: a -> a -> a; fromInteger :: Int -> a; ... }
10:13:35 <dfeuer> I believe it first tries to specialize, and if that fails it passes a record. Could be wrong though.
10:13:42 <monochrom> some compilers work that way. but note: some compilers don't.
10:13:50 <SrPx> triliyn: ok, so what about that record?
10:14:57 <SrPx> (btw quick question, is "Mappeable" a correct way to interpret the meaning of the word "Functor"?)
10:15:21 <lispy> SrPx: lispy feeling?
10:15:41 <triliyn> SrPx: GHC then passes these around (unless, as dfeuer mentioned, it can kind of inline the appropriate record), and that's how it knows which behavior to get out of typeclass-polymorphic functions
10:15:44 <SrPx> lispy: loooooool
10:16:01 <orion> dfeuer: I see.
10:16:35 <orion> GHC is written in Haskell, right? Does it use TH for itself?
10:16:42 <triliyn> (monochrom is also right: this is not actually part of the haskell standard, and if another compiler doesn't do this that would be fine)
10:16:59 <lispy> orion: it's written in Haskell, but I'm not sure how much (if any) TH is used.
10:17:05 <StoneToad> orion: my understanding is that it's written in a simple subset of haskell
10:17:10 <MP2E> orion: GHC is written in Haskell, the runtime system is written in a combination of C and C--. I don't think GHC uses TH
10:17:13 <triliyn> But I think it's a useful way to think about typeclasses
10:17:13 <lispy> orion: https://github.com/ghc/ghc
10:17:25 <StoneToad> 'simple' -> simple to implement
10:17:43 <MP2E> Reason I don't think GHC uses TH is because TH doesn't work in cross compilation mode right now
10:17:47 <MP2E> and GHC can still be cross compiled
10:20:09 <levi> StoneToad: GHC uses pretty much normal Haskell code. I'm pretty sure parts of it use some GHC-specific extensions as well.
10:20:23 <triliyn> SrPx: it might be nice to consider the case of polymorphic numeric literals. num :: Num a => a; num = 5
10:20:51 <levi> StoneToad: You may be thinking of the fact that GHC has a number of intermediate languages that it uses as it's compiling your code.
10:21:20 <triliyn> You can imagine this as being similar in spirit to data Num a = MkNum { ... }; num :: Num a -> a; num MkNum {fromInteger = f} = f 5
10:21:21 <MP2E> Actually GHC is riddled with extensions :D
10:21:25 <triliyn> And compiling down to similar Core
10:21:28 <MP2E> It needs quite a lot of them
10:23:02 <StoneToad> levi: ahh interesting, so it doesnt use an easily implmented subset to bootstrap itself on new hardware
10:23:45 <levi> StoneToad: No, but you can enable a C backend to help the bootstrap process.
10:24:09 <StoneToad> isn't that -fvia-C deprecated?
10:24:25 <levi> Except for bootstrapping purposes, yes.
10:24:35 <levi> You have to recompile GHC with it enabled.
10:24:48 <RyanGlScott> What does this kind of pattern matching do (App {})? https://github.com/ku-fpg/hermit/blob/master/src/HERMIT/Dictionary/Local/Let.hs#L209
10:25:12 <triliyn> RyanGlScott: it ignores all the fields
10:25:12 <dwcook> RyanGlScott, don't bind any of its fields
10:25:23 <RyanGlScott> So is it equivalent to (App _ _)?
10:25:28 <triliyn> Yeah
10:25:30 <dwcook> Yes, just more convenient
10:25:34 <RyanGlScott> Ah, makes sense.
10:25:37 <StoneToad> but it stil lworks if app gets a 3rd field
10:25:41 <triliyn> Also you won't have to change it if you add or remove  fields from App
10:25:47 <RyanGlScott> Nifty.
10:26:22 <triliyn> Also, in function definitions, {} has very high precedence
10:26:28 <triliyn> So you don't need parentheses
10:26:43 <triliyn> (In case definitions it doesn't matter because the -> has very low precedence anyway)
10:26:48 <SrPx> triliyn: I've tried but I don't understand how a record helps emulating typeclasses at all
10:27:06 <SrPx> typeclasses kind of allow you to define a function with the same name more than once
10:27:24 <dwcook> SrPx, data types also let you do that, by having that function as a field
10:28:08 <SrPx> dwcook: how? data foo = { add :: Int → Int, add :: Float → Float } doesn't make sense
10:28:11 <dwcook> (Also it's not just functions, it's any value)
10:28:26 <SrPx> right?
10:28:40 <triliyn> SrPx: more like data Foo a = {add :: a -> a}
10:28:41 <dwcook> SrPx, well, I don't know what you're after there, though it seems like you've translated something wrong
10:28:49 <triliyn> intInstance :: Foo Int
10:28:54 <triliyn> floatInstance :: Foo Float
10:29:15 <SrPx> triliyn: ok but now you still have only onde add and only one definition
10:29:34 <SrPx> how would you define 2 different adds
10:30:01 <dwcook> SrPx, do you know how fields work?
10:30:02 <triliyn> intInstance = MkFoo {add = addInts}; floatInstance = MkFoo {add = addFloats}
10:30:07 <SrPx> dwcook: I think I do
10:30:49 <SrPx> triliyn: hmm alright, but how do you use those instances.
10:30:59 <dwcook> SrPx, so if I declared data Foo = Foo { a :: String } and gave you x :: Foo, how would you get a String?
10:31:13 <SrPx> dwcook: (a x) ?
10:31:17 <dwcook> SrPx, right
10:31:18 <dwcook> now
10:31:20 <triliyn> You could say something like add intInstance 5 5
10:31:28 <triliyn> Or add floatInstance 2.5 2.5
10:31:45 <triliyn> Typeclasses in GHC work like this, except it automatically passes the right instance around
10:31:52 <triliyn> Which is more convenient
10:31:55 <dwcook> SrPx, say instead I declared data Foo = Foo { f :: Integer -> String } and gave you x :: Foo and y :: Integer. Now try getting a String
10:32:07 <SrPx> triliyn: aaah I get it... you mean you can emulate typeclasses by doing all that and sending the instance to a unique add function
10:32:09 <triliyn> (And it only lets you have one instance for each type)
10:32:25 <triliyn> Right
10:32:29 <SrPx> triliyn: ah GHC does it behind the curtains with typeclasses because that is a common pattern
10:32:36 <SrPx> dwcook: uhm..
10:33:13 <SrPx> dwcook: (f x) y
10:33:13 <SrPx> why
10:33:30 <dwcook> SrPx, right
10:33:36 <dwcook> I'm getting there, one sec
10:33:39 <SrPx> kay
10:34:08 <dwcook> Now let's try: data Foo a = Foo { f :: a -> String } and gave you x :: Foo Integer. Tell me what you need in order to get a String.
10:35:33 <SrPx> hmm ... (f x) 5 ?
10:36:00 <dwcook> Not what I was asking, but that's right, that'd get you a String
10:36:08 <dwcook> Okay, so you seem to understand all that
10:36:14 <StoneToad> shouldnt it be (f x) x?
10:36:19 <SrPx> but you didn't give me an Integer ?
10:36:24 <dwcook> StoneToad, why?
10:36:40 <dwcook> SrPx, right, the answer to the question I asked was Integer.
10:36:54 * hackagebot directory-layout 0.7.4 - Directory layout DSL  http://hackage.haskell.org/package/directory-layout-0.7.4 (MatveyAksenov)
10:36:54 <SrPx> dwcook: ah okay
10:37:31 <StoneToad> dwcook: hmm you're right, nm, ther'es no field other then the function in x
10:37:50 <dwcook> SrPx, so, you understand the types involved at least. Now, given just the definition data Foo a = Foo { f :: a -> String }, give me two values of the same type constructed with Foo.
10:38:14 <dwcook> Feel free to pick any a you know of
10:38:44 <dwcook> I'll get to a point after this
10:39:11 <SrPx> of the same type, hm
10:39:32 <SrPx> so I will use Foo Integer, but I don't really know two functions that receive an Integer and return a String. well whatever I will just ignore the integer
10:39:56 <SrPx> x = Foo (\x → "hi") :: Foo Integer; y = Foo (\x → "hey") :: Foo Integer
10:40:05 <dwcook> Yep, those work
10:40:09 <int3___> how do I expose a package from within a ghci session?
10:40:22 <SrPx> (:
10:40:32 <StoneToad> int3___: expose?
10:40:35 <int3___> without restarting the entire session, that is
10:40:48 <dwcook> SrPx, okay, so I asked that particular question to showcase where typeclasses *differ* from standard datatype. You can have more than one of the same "type" in scope.
10:41:00 <int3___> StoneToad: yeah, the package is currently hidden, not in my cabal deps list
10:41:19 <dwcook> SrPx, however, did you notice how the Foo type is similar to a reduced version of the Show typeclass?
10:41:54 * hackagebot STL 0.2 - STL 3D geometry format parsing and pretty-printing  http://hackage.haskell.org/package/STL-0.2 (bergey)
10:41:58 <dwcook> I could have changed its name like so: data Show a = Show { show :: a -> String }
10:42:09 <dwcook> and of course the real Show class has more than one method, but we'll ellide those for now
10:42:18 <dwcook> SrPx, does that make sense?
10:43:12 <StoneToad> int3___: ah, I don't have any experience with that, does import Blah not work?
10:44:04 <int3___> StoneToad: nope, see http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/packages.html for what exposing is about
10:44:25 <int3___> StoneToad: I know how to get stuff exposed, it was just annoying to have to restart my ghci session to do that, so I was wondering if there was some other way
10:50:12 <Ainieco> hello
10:51:07 <dwcook> o/
10:51:40 <Ainieco> how to install packages from multiple dirs into one sandbox? suppose i have cabal project and sanbox at "." then "cabal install" just works, but also i want to install package at "./foo" in sanbox at "."
10:51:44 <Ainieco> how to do it?
10:52:07 <supki> cabal install foo/
10:52:17 <Ainieco> oh, that's cool
10:53:04 <Ainieco> supki: nah, it doesn't work
10:53:05 <jfischoff> you might want `cabal sandbox add-source foo` instead, which will track changes and reinstall if necessary
10:53:20 <Ainieco> it treats "foo/" as package in hackage and can't find it
10:53:37 <supki> Ainieco: the / is important
10:54:00 <Ainieco> supki: indeed, sorry, my bad
10:54:05 <Ainieco> supki: thank you!
11:01:37 <orion> hm
11:02:27 <orion> if I have "data X = A Int | B Int | C Int", what is the difference between "A 5" and "B 7" insofar as the type system is concerned?
11:03:03 <rio> it's a different type constructor
11:03:06 <orion> What is "5" as it applies to "A"?
11:03:21 <orion> Don't you mean data constructor?
11:03:25 <enthropy> they have the same type
11:04:00 <enthropy> so probably you can say the type system doesn't care whether you used an A or a B
11:04:08 <SrPx> sorry I lost connection dwcook
11:04:13 <rio> orion: errm, yes
11:04:43 <SrPx> you guys know I'm in a farm...
11:05:38 <orion> To me, if I have an "A 5" and a "B 7", they're both of type X, but they feel like different "things".
11:06:19 <orion> I am trying to work out in my brain how they can be the same type, even though they represent completely different data.
11:06:52 <rio> orion: data AnimalOfAge = Elephant Int | Dog Int
11:07:05 <rio> Dog 4 is a 4 year old dog
11:07:14 <rio> Elephant 4 is a 4 year old elephant
11:07:36 <rio> both are of type AnimalOfAge
11:07:47 <orion> Ok, so my brain is still in OO mode then.
11:08:06 <rio> get it to algebraic mode
11:10:25 <orion> In "Dog 4", what is 4?
11:10:37 <orion> Dog is the data constructor.
11:10:46 <orion> Is 4 a parameter to the constructor?
11:11:36 <rio> orion: yes
11:12:21 <orion> It's weird to me that the choice of constructor fundamentally changes the underlying value.
11:13:27 <orion> For example, when I write OO code I can have 2 different constructors for a class/type, but it doesn't matter which constructor I use... the object which is creates is fundamentally of the same type.
11:14:34 <orion> But the value resulting from the evaluation of "Dog 4" is fundamentally different from that of "Elephant 4", but I don't know how to put it in to words.
11:14:54 <tnks> orion: you can make a function that turns any number of parameters to an Animal.
11:15:08 <tnks> and then only export Animal from the module.
11:15:20 <tnks> so that users have to call you functions to create animals.
11:15:27 <tnks> this makes Animal "abstract"
11:15:38 <tnks> so you have an abstract data type (that is also algebraic)
11:15:58 <rio> orion: think about data Bool = True | False
11:16:14 <rio> orion: theres no such thing as a "member variable" you know from OO
11:16:49 <tnks> certainly the "variable" part.
11:17:04 <danilo2> Hello! Are we able to keep (*->*) types in type tuples? Something like ' let x = (undefined :: ("test", ())) ' ?
11:17:05 <orion> "Dog 4" and "Elephant 4" are variants of AnimalOfAge. Is "variants" the right word here?
11:17:06 <rio> what a Bool is, really depends on the data constructor you used to make it
11:17:34 <tnks> orion: yes, "sum types" can also be called "variant types"
11:18:46 <tnks> orion: sum types and product types are important building blocks for building an "algebra" of sums and products, which is how you get to algebraic data types.
11:20:09 <tnks> orion: algebration data types and abstract data types can feel like duals to the "objects" you're used to working with in OO-ish languages.
11:20:27 <josephle> danilo2: what is the kind of ("test", ())?
11:20:28 <tnks> s/bration/braic/
11:20:36 <fread2282> can i zip Pipes?
11:22:17 <orion> tnks: So, the reason my brain hurts is because I am trying to read Haskell with an abstract data type mindset, instead of an algebraic mindset?
11:22:25 <willbuntu> I know that I can create an infinite list of cycled values with cycle, and I know that I can map functions to lists with map, and I know that I can zip lists together with zip and zipWith, but how would I map the cycling of calling and not-calling a function to a list?
11:23:03 <willbuntu> Sort of like map (cycle [drop, notdrop]) xs
11:23:13 <willbuntu> But not, since that wouldn't work - but that's the concept
11:23:18 <danilo2> josephle: It would be ... ah right, it would be strange. So it is impossible, right?
11:23:43 <josephle> danilo2: it seems strange right now, but perhaps you just have the wrong type
11:24:38 <rio> orion: acknowledge that the "Elephant" in "Elephant 4" is part of the data and your brain should stop hurting
11:24:42 <danilo2> josephle: I'm just asking myself if it is possible - with just an empty file - so this is not connected with anything else. I'm just asking myself if am I able to keep thghe Symbol kind inside of tupel if that makes any sense
11:26:08 <danilo2> josephle: I understand that it is impopssible or are there any "exceptions" ? :)
11:26:20 <orion> rio: hmm, ok.
11:26:39 <croyd> :t zipWith ($)
11:26:40 <lambdabot> [b -> c] -> [b] -> [c]
11:27:01 <croyd> willbuntu: will that help?
11:27:19 <enthropy> danilo2: you can have a value  Proxy :: Proxy '("test", () )
11:27:25 <rio> orion: as an exercise, bild you own list type
11:27:47 <orion> data List a = Nil | Cons a (List a)
11:28:00 <_0xAX> Hello All
11:28:04 <michaelt> fread2282: does the zip in Pipes.Prelude do what you want?
11:28:12 <rio> orion: exactly
11:28:20 <rio> orion: does that make your brain hurt?
11:28:32 <orion> rio: Not yet.
11:28:33 <_0xAX> I need to read big file and use it's content in different functions, how to do it better in haskell?
11:28:42 <_0xAX> Don't want to read file every time
11:28:45 <josephle> danilo2: I feel like we're getting into dependent types here
11:29:00 <orion> rio: What makes my brain hurt is trying to approach things "the Haskell way".
11:29:12 <danilo2> enthropy: hmm, could you tell me why can I have undefined :: Proxy ("test", ()) but not undefined ::  ("test", ())  ? I understand, that "test" is of kind Symbol, () is of kind *, so we can get something strange with ("test", ()), but why your example works ?
11:29:24 <fread2282> michaelt: no, but the ArrowChoice stuff from pipes-extras should
11:29:39 <enthropy> danilo2: I'm pretty sure you can't leave off the '
11:29:44 <enthropy> :k '(,)
11:29:45 <lambdabot>     Data constructor ‘(,)’ cannot be used here
11:29:45 <lambdabot>       (Perhaps you intended to use DataKinds)
11:29:45 <lambdabot>     In a type in a GHCi command: (,)
11:29:52 <enthropy> :k (,)
11:29:53 <lambdabot> * -> * -> *
11:29:57 <michaelt> fread2282: that was going to be my next suggestion. I think there are still too few combinators for that sort of thing anyway.
11:30:01 <rio> orion: what is that? ;)
11:30:08 <enthropy> '(,) :: k1 -> k2 -> (k1, k2)
11:30:09 <orion> rio: I feel like I have OO-related PTSD and Haskell is the psychotherapist trying to help me get over it.
11:30:23 <danilo2> enthropy: ah! I was sure it was just misspeled. What does it mean? is it the same as in TemplatEHaskell ?
11:30:37 <enthropy> no this is DataKinds stuff
11:31:06 <josephle> ah, DataKinds.
11:31:30 <michaelt> _0xAX: what is the problem with Text (or ByteString if thats appropriate?)
11:31:52 <enthropy> danilo2: or maybe you're looking for a data like:   (Proxy, ()) :: (Proxy "test", ())
11:31:52 <danilo2> enthropy: I see, thank you! It clarifies a lot! :)
11:32:00 * hackagebot dockercook 0.1.0.0 - A build tool for multiple docker image layers  http://hackage.haskell.org/package/dockercook-0.1.0.0 (AlexanderThiemann)
11:32:30 <danilo2> enthropy: yes I would stick with the later one - I was just cleaning my mind - now I understand better DataKinds, thank you once again! :)
11:33:06 <enthropy> the latter is better as  Tagged () :: Tagged "test" ()
11:34:18 <TheKing444> hello, there wouldn't happen to be an "unSafeShow :: a -> String" out there
11:34:23 <enthropy> since you probably don't want these extra values:  (undefined, ()) undefined  for that type
11:34:50 <TheKing444> for ghc
11:35:09 <enthropy> TheKing444: maybe http://hackage.haskell.org/package/vacuum or the ghci debugger
11:35:14 <danilo2> enthropy: I want to create a nice type level set with type families like Insert, Remove etc for elements. And I wanted to do it as general as possible - looking for information if am I able to keep there string-like keys (If it is unclear - i can expalin it better) - but the solution with Proxy "test" is good enought - I was just looking for possibilities :)
11:35:15 <willbuntu> croyd: Perhaps, but I don't know how I could use that personally. What I want to do is cycle dropping and not dropping elements from a list.
11:35:26 <TheKing444> Well actually, it is for my error messages.
11:35:40 <willbuntu> croyd: That is, something like zip [drop, notDrop] [1,2]
11:36:33 <TheKing444> If my library crashes, I want to show my users why it crashed.
11:36:42 <orion> rio: Can I legitimately call AgeOfAnimal a union?
11:36:47 <TheKing444> something like (show . unSafeCoerce) I was thinking
11:37:02 <TheKing444> And since this was caused in response to an error, it doesn't have to be safe
11:37:04 <enthropy> TheKing444: you can be bad and write  instance Show a where showsPrec _ _ = "<cannot show>"
11:37:10 <TheKing444> (An impossible error by the way)
11:37:23 <rio> orion: no, this is not C
11:37:53 <TheKing444> Well, it is a library, and that may leak.
11:38:03 <TheKing444> You can't choose what instances to export ya know.
11:38:34 <willbuntu> To all: I know that I can use cycle for cycling values, and I know how to map and zip things, but can I make a cycle of two different functions and map their application to a list?
11:38:56 <orion> rio: What about "disjoint union" or "tagged union" or "sum type"?
11:39:08 <Zekka> willbuntu: zipWith ($) (cycle [f, g]) yourList ?
11:39:30 <TheKing444> willbuntu sounds like zipList
11:39:46 <Zekka> @hoogle zipList
11:39:47 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
11:39:47 <lambdabot> Control.Applicative newtype ZipList a
11:39:47 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
11:39:57 <rio> orion: sum type would be a common term to use i guess
11:40:09 <Zekka> TheKing444: You can do it with ZipList but I'm not sure what the advantage is over using just zipWith
11:40:19 <TheKing444> it scales better
11:40:34 <TheKing444> What if instead of two arguments, you have 50,00000000000000000000 arguments
11:40:51 <TheKing444> then you would be wishing that you used zipWith
11:41:00 <TheKing444> I mean zipList
11:41:01 <MP2E> if you have that many arguments, you have bigger problems
11:41:02 <MP2E> :P
11:41:02 <Zekka> TheKing444: But that's not really his usecase?
11:41:08 <Zekka> or anyone's usecase?
11:41:18 <TheKing444> how do you know, he may just be simplifying
11:41:29 <TheKing444> You have to look past the A-B ya know.
11:41:34 <enthropy> TheKing444: -XDefaultSignatures might make it bearable for people to write instances for a new class that has the debugShow method
11:41:40 <TheKing444> :t <*>
11:41:41 <lambdabot> parse error on input ‘<*>’
11:41:46 <TheKing444> :t (<*>)
11:41:47 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:42:02 <Zekka> I like the Applicative instance for ZipList but I also think it's a lot of boilerplate if you only have one argument
11:42:22 <TheKing444> I suppose so, I just though <*> would work perfectly.
11:43:27 <danilo2> Ok, one more simpel question - is there in type families anything similar to OverloadedInstances?
11:43:47 <enthropy> OverlappingInstances?
11:44:28 <danilo2> enthropy: yes
11:44:38 <danilo2> enthropy: ohh, closed type families can work this way!
11:49:40 <enthropy> danilo2: it's possible that HList has all the operations you need for sets
11:51:22 <ybit> https://gist.github.com/jorendorff/a3005968adc8f054baf7
11:51:26 <ybit> any ideas how to make this faster?
11:52:25 <willbuntu> Zekka, TheKing444: I can see the potential for your suggestions to solve my problem, but how I would actually use them to do so. Here's the overarching challenge: https://www.hackerrank.com/challenges/fp-filter-positions-in-a-list
11:52:29 <ybit> it's allocating something like 10 to 40GB of memory
11:52:48 <danilo2> enthropy: oh cool! I did no knwo about it. I'm looking into HList right now - do you have any further hints? If not I'm digging throught it right now! :)
11:53:24 <Zekka> willbuntu: You probably don't need to do anything this complicated to solve this problem
11:53:30 <fread2282> how can I conditionally apply a pipe?
11:53:43 <fread2282> I did http://stackoverflow.com/questions/24050141/how-can-i-conditionally-apply-a-conduit/24053267#24053267 w/ conduit
11:53:52 <Zekka> Just recurse over the list
11:54:06 <TheKing444> :t concat . zipWith ($) (replicate [const [], :[])
11:54:07 <lambdabot> parse error on input ‘)’
11:54:17 <TheKing444> :t concat . zipWith ($) (replicate [const [], :[]])
11:54:18 <lambdabot>     A section must be enclosed in parentheses thus: (: [])
11:54:26 <enthropy> danilo2: just treat http://hackage.haskell.org/package/HList-0.3.4.1/docs/Data-HList-Record.html like you would   type Set k = Map k ()
11:54:30 <TheKing444> :t concat . zipWith ($) (replicate [const [], (:[])])
11:54:31 <lambdabot>     Couldn't match expected type ‘[b -> [a]]’
11:54:31 <lambdabot>                 with actual type ‘a0 -> [a0]’
11:54:31 <lambdabot>     Probable cause: ‘replicate’ is applied to too few arguments
11:54:42 <dncr> Does Data.Vector.Unboxed store the vector as a continuous memory block?
11:54:46 <Zekka> TheKing's got the right idea
11:54:52 <TheKing444> :t concat . zipWith ($) (repeat [const [], (:[])])
11:54:53 <lambdabot>     Couldn't match expected type ‘b -> [a]’
11:54:53 <lambdabot>                 with actual type ‘[t0 -> [t0]]’
11:54:53 <lambdabot>     In the first argument of ‘repeat’, namely ‘[const [], (: [])]’
11:54:58 <TheKing444> ah man
11:54:59 <danilo2> enthropy: thank you very much!
11:55:11 <Zekka> :t concat . zipWith ($) (cycle [const [], (:[])])
11:55:12 <lambdabot> [a] -> [a]
11:55:24 <Zekka> :@let evensOnly = concat . zipWith ($) (cycle [const [], (:[])])
11:55:27 <Zekka> @let evensOnly = concat . zipWith ($) (cycle [const [], (:[])])
11:55:29 <lambdabot>  Defined.
11:55:33 <TheKing444> concat . zipWith ($) (cycle [const [], (:[])]) $ [1,2,3,4,5]
11:55:37 <Zekka> > evensOnly [1, 2, 3, 4, 5, 6, 7]
11:55:38 <lambdabot>  [2,4,6]
11:56:17 <willbuntu> Zekka, TheKing444: Thank you.
11:56:44 <enthropy> danilo2: at some point I broke the HLeftUnion (because of PolyKinds) but it's possible the hackage version is ok
11:57:32 <zq> what is this if'
11:57:34 <zq> @hoogle if'
11:57:35 <lambdabot> No results found
11:58:04 <Zekka> zq: When I've seen that name used it's in reference to an "if" implementation without special syntax
11:58:17 <Zekka> just a function along the lines of when
11:59:01 <glguy> dncr: Depends on the type you use Vector at. For example an unboxed Vector (a,b) is two vectors, one of a and one of b
11:59:28 <glguy> while primitive types are contiguous
11:59:36 <willbuntu> Zekka, TheKing444: But how can zipWith take "($)" as its first argument? It's first argument must be a function, whereas my understanding is that "$" is just an operator meaning "whatever is to the right of this operator, apply the *preceding* function to it. What I mean is, I don't see how $ can be a valid first argument to zipWith.
11:59:37 <zq> Zekka: where is it defined?
11:59:47 <Zekka> zq: I don't know
11:59:51 <TheKing444> @src ($)
11:59:51 <lambdabot> f $ x = f x
11:59:52 <Zekka> willbuntu: It's a function.
12:00:07 <TheKing444> > ($) repeat 4
12:00:08 <lambdabot>  [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
12:00:11 <ajcoppa> :t ($)
12:00:12 <lambdabot> (a -> b) -> a -> b
12:00:20 <TheKing444> Ta da, standard haskell thing
12:00:26 <TheKing444> Shown in 3 different ways.
12:00:37 <Zekka> It's actually a special case of the identity function with some special rules for syntax
12:00:40 <TheKing444> compare to
12:00:44 <Exio> all operators are functions anyway!
12:00:47 <TheKing444> @src (+)
12:00:47 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:00:55 <TheKing444> never mind
12:01:06 <dncr> glguy: Hm. I want 10M Doubles that I can read from a file once, very fast, then use read-only. Is there some mutable array type that will just keep this in a simple memory block?
12:01:07 <Zekka> http://www.haskell.org/haskellwiki/Keywords#infix.2C_infixl.2C_infixr
12:01:13 <Zekka> syntax rules that you have access to, of course
12:01:31 <peddie> zipWith ($) (repeat succ) [1..10]
12:01:35 <peddie> agh
12:01:38 <peddie> > zipWith ($) (repeat succ) [1..10]
12:01:39 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
12:01:43 <ajcoppa> willbuntu: that make sense?
12:01:49 <Zekka> peddie: Better to write this, though
12:01:52 <Zekka> > succ <$> [1..10]
12:01:54 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
12:02:15 <peddie> Zekka: not if you want to demonstrate that $ is a function and can be an argument to zipWith
12:02:17 <peddie> :P
12:02:46 <willbuntu> ajcoppa: Yes. I understand ... it's just proving somewhat difficult to get used to the Haskell paradigm.
12:02:51 <TheKing444> one last example to make sure you understand
12:02:53 <TheKing444> > zipWith (zipWith (+)) [[1,2,3],[4,5,6]] [[7,8,9,10]]
12:02:55 <lambdabot>  [[8,10,12]]
12:02:59 <Zekka> willbuntu: It's totally a syntax thing if that helps
12:03:57 <Zekka> it's not as if anything's magical or special about infix operators
12:04:05 <glguy> dncr: Doubles will be stored contiguously in unboxed vectors
12:04:38 <TheKing444> let us make our own
12:04:38 <Zekka> A lot of your garden-variety operators (in fact, almost all of them!) have types
12:04:47 <Zekka> :t (+)
12:04:48 <lambdabot> Num a => a -> a -> a
12:04:49 <TheKing444> @def ($$) = f (f(x))
12:04:50 <lambdabot>  .L.hs:164:8:
12:04:51 <lambdabot>      Could not deduce (Show t0) arising from a use of ‘f’
12:04:51 <lambdabot>      from the context (FromExpr t)
12:04:51 <lambdabot>        bound by the inferred type of L.$$ :: FromExpr t => t
12:04:51 <lambdabot>        at .L.hs:164:1-16
12:05:01 <Zekka> :t (*)
12:05:02 <lambdabot> Num a => a -> a -> a
12:05:38 <Zekka> :t (<<>=)
12:05:39 <lambdabot> (MonadState s m, Monoid r) => LensLike' ((,) r) s r -> r -> m r
12:05:40 <dncr> glguy: Huh. I wonder why the speed is still so much slower than C. I wonder if I'll have to use FFI.
12:05:50 <Zekka> TheKing444: Perfectly simple!
12:05:58 <Zekka> er, not you
12:06:03 <Zekka> willbuntu: Perfectly simple!
12:06:10 <Exio> @def ($$) = \f -> \x -> f(f(x))
12:06:11 <lambdabot>  Defined.
12:06:22 <Exio> > (+2) $$ 3
12:06:23 <lambdabot>  Ambiguous occurrence ‘$$’
12:06:24 <lambdabot>  It could refer to either ‘L.$$’, defined at L.hs:164:1
12:06:24 <lambdabot>                        or ‘Text.PrettyPrint.HughesPJ.$$’,
12:06:24 <lambdabot>                           imported from ‘Text.PrettyPrint.HughesPJ’ at L.hs:1...
12:06:40 <TheKing444> @def f $$ x = f (f x)
12:06:42 <lambdabot>  Defined.
12:06:43 <Exio> > (L.$$) (+2) 3
12:06:45 <lambdabot>  7
12:06:55 <Zekka> > (+2) L.$$ 3
12:06:56 <lambdabot>  7
12:07:08 <glguy> dncr: Possibly something about the way you ported the algorithm to Haskell
12:07:19 <willbuntu> The examples suffice. You don't have to show any more if you don't wish to.
12:07:57 <TheKing444> @def f $$$ x = foldr (.) (replicate x f) (repeat f) $ x
12:07:57 <lambdabot>  .L.hs:150:22:
12:07:57 <lambdabot>      Couldn't match expected type ‘Int -> b’ with actual type ‘[b -> b]’
12:07:57 <lambdabot>      Relevant bindings include
12:07:57 <lambdabot>        f :: b -> b (bound at .L.hs:150:1)
12:07:57 <lambdabot>        ($$$) :: (b -> b) -> Int -> b (bound at .L.hs:150:1)
12:08:12 <Zekka> willbuntu: If you end up with more questions we'll probaly be able to explain
12:08:19 <TheKing444>  .@def f $$$ x = foldr (.) (replicate x f) id (repeat f) $ x
12:08:25 <TheKing444> @def f $$$ x = foldr (.) (replicate x f) id (repeat f) $ x
12:08:26 <lambdabot>  .L.hs:150:22:
12:08:26 <lambdabot>      Couldn't match expected type ‘[a] -> Int -> t’
12:08:26 <lambdabot>                  with actual type ‘[a]’
12:08:26 <lambdabot>      Relevant bindings include
12:08:26 <lambdabot>        f :: a (bound at .L.hs:150:1)
12:09:04 <TheKing444> @def f $$$ x = foldr (.) (replicate x f) id $ x
12:09:05 <rio> @pl \f -> f.f
12:09:05 <lambdabot>  .L.hs:150:22:
12:09:05 <lambdabot>      Couldn't match expected type ‘Int -> b’ with actual type ‘[a]’
12:09:05 <lambdabot>      Relevant bindings include
12:09:05 <lambdabot>        f :: a (bound at .L.hs:150:1)
12:09:05 <lambdabot>        ($$$) :: a -> Int -> b (bound at .L.hs:150:1)
12:09:07 <lambdabot> join (.)
12:10:00 <TheKing444> @def f $$$ x = foldr (.) id (replicate x f) $ x
12:10:01 <lambdabot>  Defined.
12:10:07 <TheKing444> (+4) $$$ 4
12:10:15 <TheKing444> > (+4) $$$ 4
12:10:16 <lambdabot>  20
12:10:22 <TheKing444> :t $$$
12:10:23 <lambdabot> parse error on input ‘$$$’
12:10:27 <TheKing444> :t ($$$)
12:10:28 <lambdabot> (Int -> Int) -> Int -> Int
12:11:58 <TheKing444> :t (.).(.).(.).(.).(.)
12:11:59 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> a3 -> a4 -> b) -> a -> a1 -> a2 -> a3 -> a4 -> c
12:12:43 <rio> uhm, why is \f -> f.f given by join (.)?
12:13:09 <TheKing444> uhm, functions are the reader monad
12:13:14 <TheKing444> so let's figure this out
12:13:15 <Ch0c0late> Is it a bad solution to FizzBuzz problem? http://hastebin.com/atebiqazuc.coffee. It's not code golf friendly?
12:13:18 <TheKing444> :t join
12:13:19 <lambdabot> Monad m => m (m a) -> m a
12:13:22 <TheKing444> :t (.)
12:13:23 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:13:37 <rio> guess i'll have to check out the reader monad
12:13:42 <orion> Is it correct to say that newtype "elevates" a data variant to a fully fledged type which doesn't contain bottom?
12:14:08 <TheKing444> so, . is something that con take something of type ((r->r)->(r->r)) and return (r->r), so it is a reader which returns a reader
12:14:36 <TheKing444> wait no, nevermind
12:15:05 <rio> it takes (r->r) and returns (r->r)-(r->r)
12:15:14 <rio> it takes (r->r) and returns (r->r)->(r->r)
12:15:15 <TheKing444> id-const
12:15:18 <TheKing444> > id-const
12:15:19 <lambdabot>  Occurs check: cannot construct the infinite type: a ~ b0 -> a
12:15:20 <lambdabot>  Expected type: a -> a
12:15:20 <lambdabot>    Actual type: a -> b0 -> a
12:15:29 <TheKing444> up sorry, functions aren't numbers
12:15:54 <TheKing444> id - (const 4)
12:16:01 <TheKing444> > id - (const 4)
12:16:03 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
12:16:03 <lambdabot>    arising from a use of ‘M79764746810281494068409.show_M79764746810281494068...
12:16:03 <lambdabot>  The type variable ‘a0’ is ambiguous
12:16:03 <lambdabot>  Note: there are several potential instances:
12:16:03 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
12:16:31 <rio> where can i read about functions being examples of the reader monad?
12:17:58 <Zekka> rio: They're not "examples" -- the reader monad is defined as newtype Reader r a = Reader { runReader :: r -> a }
12:18:03 <Zekka> (or words to that effect)
12:18:26 <jhance> Reader is really just a monad instance encapsulated over ->
12:18:43 <TheKing444> when you make a reader monad, you don't say the enviroment, so it is a function from the enviroment to the final value
12:20:51 <rio> so (.) which is (a->b)->(b->c)->(a->c) is Reader (Reader a)?
12:21:38 <Zekka> Reader (Reader (Reader a b) (Reader b c)) (Reader a c)
12:21:42 <Zekka> But you would never write that
12:22:04 * hackagebot dockercook 0.1.1.0 - A build tool for multiple docker image layers  http://hackage.haskell.org/package/dockercook-0.1.1.0 (AlexanderThiemann)
12:22:32 <rio> well join :: Monad m => m (m a) -> m a, i wanted to see what are m and a, when i write join (.)
12:23:03 <rio> so in this case i have join :: Reader (Reader a) -> Reader a, right?
12:23:06 <Zekka> AFAIK you can't do that
12:23:09 <Zekka> No, that's invalid
12:23:28 <Zekka> like I said, . is Reader (Reader (Reader a b) (Reader b c)) (Reader a c)
12:23:48 <Zekka> It would have to be Reader a (Reader a c) for you to be able to join it like that
12:23:55 <Zekka> e.g. a -> a -> c
12:24:03 <Zekka> :t join (.)
12:24:04 <lambdabot> (c -> c) -> c -> c
12:24:10 <Zekka> Wait, really? That's weird
12:24:18 <Zekka> Oh, I know what it did
12:24:37 <Zekka> It specialized it to (c -> c) -> (c -> c) -> (c -> c)
12:25:04 <Zekka> Oh, I think my expansion above may be incorrect too
12:25:14 <Zekka> It may actually be this:
12:25:35 <Zekka> Reader (Reader a b) (Reader (Reader b c) (Reader a c))
12:25:42 <tolt> If you use twitter you might want to check out https://twitter.com/Hackage2Bot . I made it to do the same thing that hackagebot does but for twitter.
12:26:02 <Zekka> In that case then you can join iff a b is b c
12:28:36 <mmachenry> Can anyone tell me why my applicative parser of my DB results doesn't work? I thought I was copying the example code from hackage (link in the comments) but I'm getting a type error (which is also in the comments) http://lpaste.net/107897
12:29:47 <Zekka> mmachenry: Are you clear on what <$> and <*> mean?
12:29:54 <Zekka> It looks like you don't quite understand them
12:30:10 <mmachenry> Likely not :(
12:30:15 <mmachenry> One sec
12:30:21 <Zekka> The short answer is "write Call <$> x <*> y <*> z"
12:30:30 <Zekka> the long answer involves the types of <$> and <*>
12:30:55 <dmj`> he just flip flopped em, but yea f (a -> b) -> f a -> f b is different from (a -> b) -> f a -> f b
12:31:18 <NemesisD> hey guys. my test suite needs to run some executables that respond differently to POSIX signals. is there a way to rig cabal to build these executables for me or failing that, is there a way to build a dependable executable that can trap signals (like bash script i guess?)
12:33:27 <danilo2> enthropy: Thank you for the links. The HList seems great - I'm reading still about it. By the way - fo you know if there is any possibility, that Data.HList.Record will be less performant than just datatypes? (memory layout etc) ? Or GHC handles it as fast as datatypes?
12:36:32 <dmj`> NemesisD: pretty sure SIGINT (Ctrl+C) will stop an IO action from running (on unix systems), I use it to set off bracket. I'd check out "installHandler" from unix
12:36:36 <dmj`> http://www.haskell.org/hoogle/?hoogle=installHandler
12:37:02 <rio> Zekka: what about join :: (Reader a) ((Reader a) a) -> (Reader a) a?
12:37:15 <Zekka> rio: You are not understanding types
12:37:23 <Zekka> At least I don't thikn yo uare
12:37:26 <Zekka> hold up a second
12:37:40 <Zekka> No, my mistake, you are -- you're just using parentheses strangely
12:37:54 <rio> Zekka: i'm matching up for m (m a) -> m a
12:38:02 <rio> that's where the parenthesis come from
12:38:09 <enthropy> danilo2: yes it should be slower. But maybe it's not that bad. See http://code.haskell.org/~aavogt/HList-benchmark/a.html (some of the text is out of sync with the graphs)
12:38:10 <mmachenry> Zekka: I see now. Yes I was just very mistaken about <*> and <$>. I thought I knew. :)
12:38:11 <rio> m is Reader a
12:38:16 <Zekka> This is acceptable: join :: Reader a (Reader a a) -> Reader a a
12:38:22 <Zekka> (just a rewrite of yours)
12:38:43 <Zekka> That works for (.) if you substitute a for (a -> a)
12:38:51 <Zekka> :t join `asAppliedTo` (.)
12:38:51 <lambdabot> ((c -> c) -> (c -> c) -> c -> c) -> (c -> c) -> c -> c
12:40:00 <rio> neat, didn't know about asAppliedTo
12:40:21 <enthropy> it's not standard
12:40:40 <rio> thought so
12:40:49 <NemesisD> dmj`: oh i have no problem writing haskell code to eat signals. i'm saying i need to have some executables as support for my tests. i don't know how to get cabal to build those for me. so i'll either need to use something like make or somehow write a shell script that can do this (trap sigint correcty)
12:40:49 <orion> > pl \x y -> x y
12:40:50 <lambdabot>  <hint>:1:4: parse error on input ‘\’
12:40:59 <orion> :<
12:41:03 <enthropy> @pl \x y -> x y
12:41:03 <lambdabot> id
12:41:11 <orion> ah
12:41:31 <enthropy> it's usually called ($)
12:41:48 <Zekka> orion: Or id.
12:42:38 <danilo2> enthropy: this comparison is great! I do not know where have you got it from, but thank you very much for sharing it!
12:43:00 <enthropy> oh I am aavogt
12:43:14 <Gurkenglas> http://www.haskell.org/haskellwiki/Memoization <- Would this become crappily slow if instead of memoized_fib = (map fib [0 ..] !!) you wrote memoized_fib i = (map fib [0 ..] !!) i?
12:46:27 <darthdeus> can I put a typeclass constraint on a newtype type parameter?
12:49:05 <danilo2> enthropy: to be 100% sure I get what you were previosuly suggesting me (while developing the type sets) - you suggest to just tread HRecord as a set of fields - add some labels, remove them and threat it as set ?
12:49:16 <lyxia> Gurkenglas: Yes because it would recompute the list every time.
12:49:59 <Gurkenglas> Yeah I asked because I thought of that possibility ^^
12:50:13 <enthropy> danilo2: yes
12:50:46 <danilo2> enthropy: ok, thank you! :)
12:55:44 <zq> what's the most efficient way to hexify a bytestring?
12:56:07 <zq> as in map intToDigit . BS.unpack
12:56:22 <Gurkenglas> Would for the same reason "crappyadd a b = map [a..] !! b" be way faster than "fastid a = (map [a..]) !!" if a happened to be the same value during each run of my .hs?
12:57:07 <Gurkenglas> *happened to not change its value during any run of my .hs
12:57:41 <Gurkenglas> -fastid+lesscrappyadd
12:57:43 <zq> :t Data.ByteString.Char8.pack . map (intToDigit . fromIntegral) . BS.unpack
12:57:44 <lambdabot> BSC.ByteString -> BSC.ByteString
12:57:51 <zq> i can haz more efficient version?
12:57:56 <rwbarton> well, recomputing the value [a..] is not any more expensive than reading it from memory
12:58:26 <Gurkenglas> It would save [a..] in the memory?
12:58:33 <tolt> "No instance for (Functor Set) arising from a use of ‘<$>’ " makes me sad every time.
12:58:54 <rwbarton> but ignoring that... it would only save [a..] if you gave "fastid a" a name somehow
12:59:08 <Gurkenglas> But then why doesn't it save (map fib [0 ..] !!) from the crappy second version of memoized_fib  in the memory, then?
12:59:10 <dmj`> tolt: couldn't you write one?
12:59:30 <Gurkenglas> Okay, got you now, that's what I suspected
12:59:30 <tolt> dmj`: I believe it breaks the functor laws.
13:00:28 <dmj`> well, you could just turn it into a list, apply the function, then back into a set.
13:00:45 <dmj`> @typ \f -> Data.Set.fromList . fmap f . Data.Set.toList
13:00:46 <lambdabot> Ord a => (a1 -> a) -> S.Set a1 -> S.Set a
13:00:54 <dmj`> #hacks
13:01:06 <pseudolio> That won't work.
13:01:09 <Gurkenglas> Wait, why would it break the functor laws?
13:01:20 <dmj`> pseudolio.. why?
13:01:21 <lyxia> Gurkenglas: The problem is that the binding is inside the function definition, and GHC doesn't take it out from it even though it could, because that may actually not have been your intention
13:01:27 <pseudolio> dmj`: Look at the type.
13:01:38 <dmj`> The Ord constraint?
13:01:41 <pseudolio> Yes.
13:01:43 <tolt> I thought it was the Ord requirement on Set
13:02:19 <tolt> It just makes me sad because Set is a functor. It's the functor I first learned about in math.
13:02:47 <rwbarton> Gurkenglas: (disclaimer: GHC may actually float the value "map fib [0..]" outside your second memoized_fib even when it isn't your intention. often annoying)
13:03:16 <dncr> ok, here's an example of my Haskell taking 3.73s to load 70M Int16s to an unboxed vector and C taking 0.03: https://github.com/dancor/slurp
13:03:20 <dncr> glguy: any advice?
13:03:24 <pseudolio> The first function you learned about in math is finite sets of types with decidable ordering?
13:03:29 <pseudolio> Functor, even.
13:03:53 <dmj`> Sets are balanced trees, so they need an Ord, makes sense
13:03:59 <dmj`> aren't Maps functors?
13:04:04 <joelteon> it's not a functor because you can't guarantee f is monotonic, right?
13:04:06 <Gurkenglas> rwbarton, is writing in such a way that I always would want that good style?
13:04:15 <joelteon> The Functor instance for Map is on the values
13:04:47 <pesbvef> Is there a concept of a monotone function?
13:05:04 <dmj`> Maps also require Ord instances...
13:05:15 <joelteon> dmj`: they have Ord on the key
13:05:37 <Gurkenglas> Why can't we have a functor on set? Just make fmap f {x, y, z, ...} = {f x, f y, f z, }?
13:05:56 <joelteon> Gurkenglas: because if f x and f y are the same, only one will be in the resulting Set
13:05:58 <dmj`> I still don't see what's wrong with pulling the a's out of the Set and applying fmap f to them, then converting back into a Set
13:06:14 <joelteon> I think it's because it violates one of the Functor laws
13:06:21 <pseudolio> @type fmap (+)
13:06:22 <lambdabot> (Num a, Functor f) => f a -> f (a -> a)
13:06:33 <pseudolio> What would happen if f were Set there?
13:06:44 <dmj`> Lists are functors though... and at that point you're outside of the Set
13:06:49 <joelteon> for example, fmap id (fromAscList [1,1]) /= id (fromAscList [1,1])
13:06:53 <Gurkenglas> joelteon, I fail to see the problem with that
13:06:58 <Gurkenglas> What functor law does that violate?
13:07:01 <joelteon> that one
13:07:18 <joelteon> of course, that does rely on constructing an unsound Set
13:07:20 <joelteon> so...hmm
13:07:35 <Mon_Ouie> Isn't it because you need Eq a to be able to insertion in a set?
13:07:43 <Gurkenglas> What is an unsound set, and of course fmap id x is x
13:07:49 <josephle> Ord is a subclass of Eq
13:07:50 <Gurkenglas> (You put in an extra id there)
13:08:30 <pesbvef> If there is a concept of a strictly increasing function, then I think one could define a functor from [the category of ordered types and strictly increasing functions] to [the category of maps with a fixed value type].
13:08:40 <Gurkenglas> id is injective, no problem there.
13:08:44 <dmj`> It makes sense, since the only way to be efficient asymptotically on a tree is to order the elements. Otherwise you have a linked list. Sacrifice abstraction for efficiency
13:09:06 <pesbvef> Is this not doable using Haskell's standard library? :-O
13:09:17 <Mon_Ouie> But you can't guarantee there is an instance of eq/Ord for any a. And the functor instance needs to hold for Set as whole.
13:09:29 <joelteon> pesbvef, you can't prove that any function is strictly increasing
13:09:34 <joelteon> not in Haskell
13:09:46 <josephle> you'll need dependent types to enforce monotonicity of functions
13:09:46 <joelteon> you might be able to in, like, Agda or something
13:09:53 <joelteon> but Haskell isn't capable of it
13:10:18 <Gurkenglas> You wouldn't have to if you just say that the result is not determined if you give the functor an ordered type with a not strictly increasing function
13:10:19 <mr-> Hey, given http://lpaste.net/107907 (type level Nat, fixed length vectors and a heterogeneous (in the number of elements) list of vectors). How would I define a map :: (Vec a n -> Vec b m) -> VecList ns -> VecList ms for that? (I know that type cannot be that)
13:10:33 <josephle> I think the second functor law is violated by the proposed definition of fmap for Set
13:10:58 <jorendorff> My program is allocating a lot of memory: https://gist.github.com/jorendorff/a3005968adc8f054baf7
13:10:59 <joelteon> oh, that's fmap f . fmap g === fmap (f . g) right?
13:11:06 <josephle> yeah
13:11:18 <joelteon> violated if (f . g) is monotonic but g is not
13:11:25 <rwbarton> dncr: your C program is in a sense doing something different from your Haskell program
13:11:27 <jorendorff> profile here: https://gist.github.com/jorendorff/ae002cd85dd4eb30b3e4
13:11:38 <pesbvef> joelteon: josephle: We could make a "newtype Monotone a b = Mono (a -> b)", and document that this should only be used with actual monotone functions. Nobody would enforce the laws, but at least the presence of the Mono data constructor would indicate where laws have to be enforced.
13:12:05 <rwbarton> dncr: in that it assumes that the in-memory format of short [] matches the format of your input file
13:12:06 <pesbvef> It is kinda like how we know laws have to be enforced whenever we make a type class instance.
13:12:11 <dncr> rwbarton: Is there a way to do something in Haskell that is closer to the C program? I just want fast loading of a bunch of (say) Int16 that I can then have read-only access to.
13:12:47 <dncr> rwbarton: Do you think if I add some simple byte munging to the C program it will get much slower?
13:12:49 <Gurkenglas> fmap (f.g) x = {(f.g) x, ...} = {f (g x), ...} = fmap f {g x, ...} = fmap f (fmap g {x, ...}}, I don't see the problem
13:13:13 <Gurkenglas> (Umm the first x there is supposed to be {x, ...}
13:13:16 <Gurkenglas> *)
13:13:30 <joelteon> Gurkenglas, if g isn't monotonic, fmap g x will have fewer elements than x
13:13:38 <pseudolio> Gurkenglas: You're not writing Haskell. That's the problem.
13:13:45 <joelteon> if (f . g) is monotonic, fmap (f . g) x will have more elements than fmap f . fmap g $ x
13:13:53 <Gurkenglas> pseudolio, replace all = with === <.<
13:14:09 <Gurkenglas> (Boom, infinite string explosion.)
13:14:21 <rwbarton> dncr: yes, you could read the file into a buffer and turn it into a storable vector
13:14:39 <dmj`> jorendorff: can you give a proof by counter-example of how Set violates functor the 2nd law (composition?)
13:14:40 <joelteon> that said, I don't know how (f . g) could introduce monotonicity if g wasn't.
13:14:52 <pseudolio> There is no way to compute {f x, f y, ...} for all possible choices of f.
13:14:52 <josephle> dmj`: perhaps it doesn't
13:14:56 <Gurkenglas> joelteon, you mean injective, and I fail to see the problem
13:15:21 <pseudolio> Not for the representation in Data.Set, at least.
13:16:06 <dmj`> pseudolio: where is the counter-example?
13:16:11 <dmj`> for Sets not being functors
13:16:22 <pseudolio> @type fmap (+)
13:16:23 <lambdabot> (Num a, Functor f) => f a -> f (a -> a)
13:16:30 <pseudolio> Equality of functions is not decidable.
13:16:32 <Gurkenglas> collapsing {x, ...} into smaller sets by noninjectivity by first g, then through f, yields the same as collapsing it via (f.g)
13:17:15 <dncr> rwbarton: Data.Vector.Storable or Data.StorableVector?
13:17:15 <pseudolio> Nor ordering.
13:17:25 <josephle> pseudolio: an elegant counterexample
13:18:29 <dmj`> pseudolio: what is the *simplest* counter-example of Sets not being functos
13:18:33 <dmj`> functors*
13:18:52 <dmj`> well, Data.Set, not mathematical sets
13:18:52 <dmj`>  
13:19:00 <rwbarton> dncr: well, either one I suppose, but I was thinking of the former
13:19:13 <Gurkenglas> Why yes I am bested.
13:19:26 <pseudolio> What is not simple about that example.
13:20:08 <pseudolio> You can't build Sets of functions.
13:20:11 <klao> jorendorff: does that profile correspond to the input file you have in the gist?
13:20:22 <jorendorff> klao: If you refresh the profile, yes
13:20:25 <josephle> fmap (+) (Data.Set.fromList [1,2,3]) will not form a valid Data.Set is what pseudolio is trying to say
13:20:39 <jorendorff> klao: sorry, at the time i posted the link, the profile was out of date w.r.t. the gist, but then i updated it
13:20:39 <joelteon> @type fmap const
13:20:40 <lambdabot> Functor f => f a -> f (b -> a)
13:20:49 <pseudolio> But 'fmap (+)' if fmap works on Data.Set, says that I can build a set of functions.
13:21:09 <pseudolio> Well, you can build empty and singleton sets of functions.
13:21:14 <dmj`> @typ Data.Set.fromList [(+1), (*2)]
13:21:14 <lambdabot> (Ord (a -> a), Num a) => S.Set (a -> a)
13:21:21 <Zekka> Hey, can I generate assembly using ghc --make?
13:21:21 <pseudolio> But that's it.
13:21:27 <klao> jorendorff: I see. It didn't change much though.
13:21:28 <dmj`> seems like you can build sets of functions
13:21:29 <Zekka> GHC explicitly says I can't but I'm curious if I can cheat it somehow
13:21:43 <josephle> dmj`: you can't define an ordering on functions
13:21:50 <josephle> it's an undecidable problem
13:21:53 <klao> Weird. You don't seem to do anything stupid...
13:21:55 <Zekka> One of my friends wanted to see what GHC's output looked like so I figured I'd just build one of my projects to show him
13:22:10 <joelteon> dmj`, you can assuming you can define Ord (a -> b)
13:22:46 <bennofs> Zekka: ghc --make -ddump-asm doesn't work?
13:22:52 <jorendorff> klao: It seems like for some reason GHC isn't figuring out that listArray is strict in the first n elements of the list
13:23:07 <dmj`> josephle: sure, I'm looking for a counter-example of how the Ord instance violates the fmap (f . g) = fmap f . fmap g in Data.Set
13:23:16 <Zekka> bennofs: Unrecognized flags "--ddump-asm"
13:23:21 <pseudolio> Why?
13:23:25 <pseudolio> You don't need one.
13:23:29 <bennofs> Zekka: without double dash, just -ddump-asm
13:23:40 <pseudolio> The proposed implementation you gave for fmap earlier won't even type check.
13:23:44 <Zekka> bennofs: Seems to have worked
13:23:48 <Zekka> I was using -S, thanks
13:24:06 <rwbarton> jorendorff: I'm not sure what the problem is? allocating memory is what Haskell programs do
13:24:09 <dmj`> pseudolio: which code?
13:24:19 <Zekka> Well, except that I can't figure out where it dumped it to
13:24:26 <rwbarton> jorendorff: from +RTS -s I see "179,856 bytes maximum residency (1440 sample(s))" and "%GC     time       4.3%  (4.4% elapsed)"
13:24:34 <pseudolio>  \f -> Data.Set.fromList . fmap f . Data.Set.toList
13:24:38 <bennofs> Zekka: stdout normally
13:24:45 <dmj`> @typ \f -> Data.Set.fromList . fmap f . Data.Set.toList
13:24:46 <lambdabot> Ord a => (a1 -> a) -> S.Set a1 -> S.Set a
13:25:02 <dmj`> pseudolio: what doesn't type check
13:25:03 <pseudolio> It will not type check if given as an implementation for fmap in an instance declaration for Functor.
13:25:47 <jorendorff> rwbarton: I wouldn't mind, except it's awfully slow.
13:25:56 <bennofs> Zekka: or maybe try --keep-s-files
13:25:58 <rwbarton> the allocation is not slow
13:26:25 <bennofs> Zekka: there is also -dumpdir, not sure what that does
13:26:53 <rwbarton> why does readInt show as having 86210000 entries?
13:27:17 <jorendorff> rwbarton: I'm not sure; does that mean it's called that many times? It seems like rather a lot, since there are only ~40,000 numbers in the input.
13:27:22 <bennofs> Zekka: and -ddump-to-file :O
13:27:35 <rwbarton> it's supposed to mean that
13:27:40 <rwbarton> I think
13:28:27 <klao> jorendorff: OK, I got the problem, I think
13:29:02 <toblerone> I'm interested in contributing to a haskell project, so I've just cloned the repo. Should I now run "cabal sandbox init; canbal install --only-dependencies"?
13:29:03 <Zekka> bennofs: That generated the best output
13:29:16 <klao> jorendorff: put a 'return $! arr' after 'let arr =...'
13:29:22 * jorendorff looks
13:29:59 <klao> jorendorff: You were trying to force the creation of the array, but put it in the wrong place
13:30:00 <rwbarton> oh yes, the optimizer is going badly wrong here
13:30:15 <jorendorff> yes, i believe that. compiling...
13:30:19 <klao> rwbarton: yeah, it's really weird
13:30:35 <bennofs> toblerone: seems like a good idea to me
13:30:38 <jorendorff> woot, cut the runtime in half
13:30:51 <toblerone> bennofs: ha okay
13:30:53 <toblerone> thanks
13:31:09 <rwbarton> if you just run without any optimizations it completes nearly instantly
13:31:16 <rwbarton> I guess it is inlining 'arr'
13:32:39 <klao> jorendorff: it's more like quarter for me (from 10s to 2.6s)
13:34:35 <dncr> rwbarton: thanks! this equalized the times exactly: http://hackage.haskell.org/package/spool-0.1/docs/Data-Vector-Storable-ByteString.html
13:35:00 <dncr> i feel like this changes everything
13:35:19 <rwbarton> ah yeah, that is a handy packaging
13:35:39 * dncr could not ask for better
13:36:36 <luite> hmm, that looks useful
13:36:39 <jorendorff> klao, rwbarton: "alloc bytes" went from 49 billion to 14.5 billion, down 70%. I think when Haskell makes a lot of thunks like this, it's spending most of its time touching memory
13:36:57 <luite> unaligned ByteString to Vector would break on GHCJS though :(
13:37:17 <toblerone> anyone have any experience using haste?
13:37:38 <dncr> luite: are you saying i can't carry C performance over to JS
13:37:39 <jorendorff> this is great, thanks! now I wonder if I can fix the rest myself...
13:38:01 <klao> jorendorff: there's still a mystery
13:38:12 <rwbarton> jorendorff: did you try just building the original with -O0?
13:38:30 <klao> it should be much-much faster
13:38:32 <rwbarton> in general allocation is proportional to work
13:38:55 <luite> dncr: it'd be a big performance hit to allow unaligned reads, so this limitation makes it faster
13:38:58 <rwbarton> the thing to watch out for is high heap size/high GC overhead
13:39:16 <rwbarton> that doesn't seem to be an issue here
13:39:27 <rwbarton> if your program is allocating much more than it should, it is also likely doing much more work than it should
13:39:36 <rwbarton> e.g. here calling readInt 86 million times
13:39:47 <jorendorff> rwbarton: oh, i see. hmm.
13:40:22 <luite> dncr: oh i'm wrong though
13:41:03 <luite> dncr: unaligned reads do work on Vector.Storable, since it's implemented with a ForeignPtr, which uses an Addr# primitive
13:41:24 <dncr> that's pretty amazing if this works in GHCJS
13:41:33 <dncr> sure beats parsing XML
13:42:10 <klao> jorendorff: and there's only 27244 ints to read :)
13:42:17 <luite> dncr: normal vectors use the ByteArray# primitive. GHCJS compiles Addr# lookups to generic DataView calls that allow unaligned read/write. ByteArray# lookups are always aligned and are mapped to typed arrays, which are much faster but only allow aligned
13:42:19 <dncr> <waveform><sample1 time=1.0001>0x10010<..
13:43:12 <dncr> keep up the good work
13:45:53 <luite> mixing them is a bit wacky though, typed arrays use the system's endianness, DataView uses whatever you specify. fortunately pretty much everything that runs browsers is little endian
13:48:02 <systemfault> Hmm, what about phones?
13:48:11 <systemfault> Is ARM little endian?
13:48:46 <dncr> systemfault: it's bi-endian but little by defualt
13:48:54 <systemfault> Ah, good to know, thanks :)
13:49:11 <dncr> which is a more confusing answer than i would have thought possible
13:49:12 <luite> yeah all arm android and ios devices use little endian
13:49:22 <toblerone> luite: sorry to ask as I'm sure you get this a lot, but how does ghcjs compare to haste?
13:51:35 <luite> toblerone: i might not be the most impartial person to ask since i made pretty much all of the ghcjs design decisions :)
13:54:25 <toblerone> hmm, but as far as feature set and project goals, are they comparable?
13:55:48 <luite> toblerone: haste has focused much more on code size from the start than ghcjs, at the expense of features. their base lib is a fork that is mostly the same a ghc base, but has some differences
13:57:17 <toblerone> and ghcjs uses ghc base I presume?
13:57:44 <luite> toblerone: for example haste doesn't have threading, so they change the type of MVar operations to run in their own monad (see poor man's concurrency monad if you want to find out more, it has some limitations compared to regular threads)
13:58:30 <klao> jorendorff: are you still here?
13:58:45 <jorendorff> klao: Yep. I saw your last line, I just didn't have any useful response
13:58:47 <klao> jorendorff: the real bug was that the RangeMap data was lazy
13:58:51 <luite> toblerone: there's a patch to change the underlying implementation of some of the functions, and some operations will always return an error in some environments (you can only read/write files if you run your script in node.js for example)
13:59:07 <klao> and you did the computation over and over again
13:59:33 <rwbarton> what I don't understand is that even with {-# NOINLINE rangeMap #-} it is slow
13:59:33 <jorendorff> klao: It wasn't my bug, though, right? I mean -- the way I wrote it, it should only be computed once
13:59:56 <klao> jorendorff: you are right
14:00:13 <klao> the _real_ real bug is GHC's overaggressive inlining
14:00:18 <luite> toblerone: but the ghcjs base doesn't change types of behaviour
14:01:19 <klao> jorendorff: http://lpaste.net/107913
14:01:33 <toblerone> luite: interesting, thanks. How do they compare to things like clojurescript or elm in term of maturity?
14:01:40 <klao> jorendorff: There's two changes that I made:
14:01:55 <klao> 1. $! in the makeRangeMap
14:02:08 <toblerone> meanining, would you consider it "production ready"?
14:02:09 <klao> 2. force the rangeMap function
14:02:31 <klao> And now it's instantaneous, as it should be
14:02:41 <luite> toblerone: anyway, haste was in usable state much earlier than ghcjs, even though ghcjs started earlier. i don't know much about haste's long term goals, but for ghcjs it's still to stay relatively close to native haskell and integrate well with the ecosystem. i joint the core libraries committee to take care these platform-specific issues in the base library
14:04:36 <klao> rwbarton: hmm, interesting
14:06:07 <luite> toblerone: currntly i'm working on a better optimizer that reduces the code size more, and will offer an option to give up preemptive threading and unlimited stacks in exchange for more performance and smaller code (code would look more similar to what haste/fay produce, although it might still do full tail-call optimization unlike them, but i can't guarantee that yet)
14:06:55 <toblerone> luite: well I'm interested in playing around with one of the two projects. I'm not really experienced in these things so I can't say I'll be able to contribute much, ghcjs does seem better documented for "hacking" at the moment...
14:07:01 <rwbarton> maybe NOINLINE doesn't really work with let-in-do?
14:07:28 <toblerone> and of course you'd recommend i give ghcjs a try ; )
14:08:05 <luite> toblerone: ghcjs is just getting there i think, the core of the compiler has been fairly stable, although i occasionally find bugs, but ease of installation always an issue
14:08:09 <klao> rwbarton: yeah, I also don't know what it means there
14:08:39 <toblerone> luite: well i'm trying to install it now. I'll let you know how it goes
14:08:54 <luite> toblerone: but last month i merged new template haskell support, which doesn't require native code for TH anymore, and made the installation script much better
14:09:41 <ZettaBlade> Anyone know of a good library for read 3d model formats?
14:09:41 <luite> (haste doesn't support th, so they didn't have the problem of having to build native code correctly))
14:09:54 <toblerone> yeah i saw that
14:10:50 <mgaogw> how could i define a data type that is a list of lists that ensures that all of the internal lists are the same length?
14:11:02 <klao> rwbarton: and I can't even understand which optimization is doing this...
14:11:12 <toblerone> luite: hmm so I need to use a patched version of cabal?
14:11:36 <luite> toblerone: Template Haskell and Cabal are the reason you need node.js installed to use ghcjs. it also compiles Setup.hs scripts to javascript
14:12:51 <luite> toblerone: yeah, the changes haven't been merged yet upstream. almost everything is done now, but there are still a few missing features (cabal repl, cabel run, cabal test support for ghcjs) and some bugs that affect non-ghc in general (some GHC-specific assumptions in sandboxes)
14:13:52 <luite> toblerone: but the plan is to submit the change for review fairly soon now, my plan was this week, dunno if i'm going to make that
14:14:02 <toblerone> oh so eventually cabal will officially support ghcjs as a compiler?
14:14:21 <luite> yes, i hope in the next major release
14:15:08 <bennofs> luite: wow, would that allow to run cabal *in the browser* ?
14:15:23 <bennofs> luite: if you compile cabal to js, and then compile Setup.hs to js also
14:15:43 <TheKing444> That would be wierd and awesome.
14:15:46 <luite> but it's a fairly big change, and i want all important features to work. there's lots of platform specific assumptions in the Cabal lib everywhere
14:15:47 <toblerone> okay, and sorry for the naive questions... but assuming that use this patched version I can simply upgrade to a newer, official version later on with "cabal install cabal-install"?
14:16:08 <luite> toblerone: yes
14:16:44 <toblerone> but this version doesn't currently support cabal repl or sandbox?
14:17:00 <luite> toblerone: it does for GHC, but not yet for GHCJS
14:17:06 <toblerone> ah ok
14:17:36 <luite> toblerone: sandboxes work, but require a minor workaround to fix some GHC-specific assumptions about the package db location
14:18:00 <luite> if you want to use ghcjs inside the sandbox
14:18:12 <jorendorff> klao: well ... this is just weird. "return $! rangeMap" definitely doesn't force the whole list (it is infinite)
14:18:36 <jorendorff> klao: and I wouldn't expect it to anyway, seq being "shallow"
14:18:51 <klao> jorendorff: it's not about forcing the list
14:18:52 <luite> toblerone: also since it's following the master branch you might want to pull and install the latest version from the ghcjs branch from time to time, to get more recent ghcjs suport and upstream fixes
14:18:57 <rwbarton> it must just be stopping some "optimization"
14:19:10 <jorendorff> rwbarton: ok, great -- just wanted to make sure i understood
14:19:15 <klao> more about preventing the GHC from stupidly "inlining" the definition into the loop
14:19:15 <jorendorff> thanks very much
14:19:16 <luite> toblerone: see upgrading ghcjs on the wiki, in particular you need to clean the setup-exe-cache if you do that
14:19:25 <klao> or something like that
14:19:32 <etandel> simple question: is there a std function equivalent to `(take 1) . repeat`?
14:20:04 <jesyspa> etandel: (:[])?
14:20:06 <rwbarton> etandel: (:[]) (or return)
14:20:32 <luite> bennofs: the Cabal library can be compiled to JS without problems yeah, which is what's required for Setup.hs scripts (and used when installing things with build-type: Custom with ghcjs)
14:20:35 <jesyspa> Or pure, that's even shorter.
14:20:56 <Pythonfant> @pl (\x -> [x])
14:20:56 <lambdabot> return
14:21:02 <Pythonfant> oh right obviously
14:21:20 <bennofs> luite: so you could make a js-only shell were you can install haskell libraries and run haskell code? nice
14:21:31 <luite> bennofs: the cabal-install program can be made to work in principle, but it uses a bit more foreign code, for example for the network package (for HTTP) and zlib
14:22:06 <toblerone> luite: ha okay. I ought to read a book on *nix administration. I've gotten very hesitant when it comes to package management and what not. The ETA for the official support is 1-2 weeks?
14:22:12 <luite> bennofs: i had a version that could do cabal update in js, but haven't pushed the required node.js implementation yet
14:23:19 <luite> toblerone: nah the ETA for discussing/reviewing the patch is that, then it'll probably take some time to fix things and a bit more for the next stable release
14:23:49 <luite> toblerone: some people made a nix package for ghcjs by the way
14:24:16 <luite> although i'm not quite sure how well it works, i don't use nix myself
14:24:37 <toblerone> oh you are on windows?
14:24:53 <luite> oh and you didn't mean NixOS i guess :)
14:25:07 <toblerone> ha no.
14:25:52 <toblerone> thats mainly popular with haskell developers right/
14:25:52 <toblerone> ?
14:26:44 <luite> toblerone: if you're worried about packages clashing or the cabal-install executable causing problems, you can give the executable a different name, so you still have the old version
14:26:49 <etandel> jesyspa rwbarton thx, but I was actually looking for a name to this operation. Consify? cons? anyway, thanks.
14:27:13 <toblerone> luite: yeah I
14:27:20 <toblerone> m planning on doing that
14:27:22 <luite> toblerone: and you can unregister the Cabal library from the GHC package DB after you boot GHCJS
14:28:09 <toblerone> what is this "booting" thing you refer to? I saw a similar concept in the haste code
14:28:31 <luite> toblerone: for ghcjs it's running the ghcjs-boot program, that builds all th libraries that come with the compiler
14:28:31 <toblerone> Does it just setup the environment and get all the libraries and what not?
14:29:57 <luite> toblerone: while booting, ghcjs still requires ghc for some tasks (building Setup for Cabal packages), after the boot is done, you can even remove your complete GHC installation and GHCJS will continue to work
14:30:47 <luite> which is the reason that a Cabal library that knows the ghcjs compiler has to be in GHC's package database while booting
14:31:34 <luite> bennofs: yeah, although the compiler itself cannot be compild to JS, so the shell would still need to call external programs
14:31:38 <rwbarton> jorendorff: this may actually be a real bug rather than just inlining heuristics gone astray
14:31:45 <rwbarton> jorendorff: mind if I throw it up on GHC trac later tonight?
14:32:57 <benmachine> rwbarton: I imagine you as one of those birds who goes out into the wild to find bugs to eat and then comes back to their nest to throw them up into the mouths of your little trac chicks
14:33:02 <luite> bennofs: but this is more or less how i want to implement ghcjsi, run the interpreter session in a js engine (browser or node) and request new code or type info form the compiler running in the background
14:33:37 <toblerone> well thanks a lot for your patience, and of course for your work on ghcjs : P I must be going now, but will be sure dive in some more later on tody
14:33:39 <toblerone> today
14:34:26 <luite> toblerone: there is #ghcjs by the way, it's still unreleased software so things do break from time to time
14:34:56 <luite> usually someone there (often me ;p) knows what's the current status and how to fix common issues
14:38:20 <luite> bennofs: most of the difficult bits have already been implemented for template haskell, but of course user interfaces tend to take a lot of time. hopefully osa1's gui stuff for heap profiling in the browser will be easily extensible
14:43:12 <mmmm_> What's the difference between cabal build and cabal install?
14:43:27 <MP2E> cabal build just configures and builds the thing, it doesn't install it
14:43:32 <MP2E> install does everything
14:43:33 <sm> it's like make and make install
14:44:01 <jorendorff> rwbarton: not at all, feel free
14:44:15 <mmmm_> what does "install" mean
14:44:21 <jorendorff> rwbarton: do they have good tools to minimize test cases, or do you think it'd help if i did so manually?
14:44:25 <mmmm_> register with hc-pkg?
14:44:34 <mmmm_> because build still builds the executable
14:44:35 <jle`> mmmm_: hm...it copies the binaries over into a bin/ directory
14:44:40 <sshine> mmmm_, one thing could be to put it in ~/.cabal/bin/...
14:44:54 <jle`> in sandbox it moves it to .cabal-sandbox/bin
14:45:01 <sshine> right.
14:45:07 <jle`> mhm
14:45:08 <monochrom> mmmm_: see my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#install
14:45:11 <mmmm_> ok right
14:46:39 <mmmm_> and cabal build builds all executables defined in your cabal file or just the default one with no flags?
14:47:41 <monochrom> I don't think that's the right way to look at it.
14:48:12 <monochrom> how about this: there is no "default one". all executables not disabled by flags during configure time are built
14:49:12 <monochrom> configure time already completely determines what will be skipped and what will be done
14:51:27 <mmmm_> What is the equivalent cabal confgure step to "cabal install -f executable"?
14:52:15 <monochrom> cabal configure -f executable
14:52:51 <monochrom> have you read "cabal configure --help" lately?
14:54:08 <mmmm_> Thank you for your help
15:06:13 <TheKing444> quick question about Rational from Data.Ratio
15:07:05 <TheKing444> I know that if I multiply two floating numbers, the sum may not be the actual sum, but an approxmation of such.
15:07:20 <TheKing444> Is there any operation that is done on Rational that would approximate?
15:07:36 <dmwit> TheKing444: fromRational ;-)
15:07:50 <monochrom> @type fromRational
15:07:51 <lambdabot> Fractional a => Rational -> a
15:07:56 <TheKing444> oh okay
15:08:05 <bennofs> :t toRational
15:08:05 <lambdabot> Real a => a -> Rational
15:08:06 <TheKing444> I mean between to Rational numbers
15:08:23 <TheKing444> does it ever approximate its own operations instead of being exact
15:08:29 <dmwit> The standard instances for Rational don't approximate anywhere.
15:08:34 <TheKing444> Nice
15:08:35 <geekosaur> the point of Rational is that it does exact math. that said, it does not implement irrational functions; there may be add-on functions somewhere that produce rational approximations to, say, sine or square root
15:08:46 <bennofs> > sqrt (3 :: Rational)
15:08:48 <lambdabot>  No instance for (GHC.Float.Floating GHC.Real.Rational)
15:08:48 <lambdabot>    arising from a use of ‘GHC.Float.sqrt’
15:08:48 <Zekka> You'll have to write your own sqrt/etc. functions if you need them
15:08:55 <hpc> or use CReal
15:08:59 <TheKing444> Well, there are an uncountable infinity of real numbers.
15:09:00 <hpc> which has termination issues
15:09:13 <monochrom> do you want to control the approximation?
15:09:15 <dmwit> or cyclotomic numbers, which are exact and have no termination issues
15:09:29 <TheKing444> I don't want to approximate at the moment.
15:09:41 <TheKing444> Or rather, I was wondering if Rational had "rounding errors."
15:09:49 <dmwit> TheKing444: CReal is the computable reals, which are countable.
15:09:52 <monochrom> yeah, it doesn't round
15:10:12 <companion_cube> oh, computable reals are countable... indexed by their program?
15:10:18 <TheKing444> So, if a fraction gets to complicated (say, ackerman's number%raymen's number) would it tell me (by overflowing)
15:10:24 <dmwit> companion_cube: right
15:10:43 <monochrom> you run into out-of-memory or you're good
15:10:47 <geekosaur> Rational is Ratio Integer
15:10:52 <TheKing444> I know
15:11:02 <bennofs> TheKing444: Integer is practically unbounded
15:11:02 <geekosaur> it's essentially limited my available memory and you'll get heap errors if you overflow
15:11:07 <TheKing444> Would Ratio Int go around modolou two style?
15:11:08 <companion_cube> I suppose it means that they might not be sufficient for many parts of analysis
15:11:09 <bennofs> > maxBound :: Integer
15:11:09 <geekosaur> *by
15:11:10 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
15:11:10 <lambdabot>    arising from a use of ‘GHC.Enum.maxBound’
15:11:14 <TheKing444> good
15:11:31 <TheKing444> (I don't think any machine could handle ackerman's number in binary though.)
15:11:46 <monochrom> Ratio Int is going to be problematic. but Rational doesn't use Int
15:11:54 <TheKing444> okay
15:12:21 <TheKing444> They should implement rational arithmetic it integrated circuits instead of floating numbers.
15:12:24 <monochrom> @type (%)
15:12:25 <lambdabot> Integral a => a -> a -> Ratio a
15:12:55 <dmwit> Rational arithmetic generally gets into largish numbers after even a modest number of operations.
15:12:55 <monochrom> > product [1..70] / product [2, 4 .. 140]
15:12:57 <lambdabot>  8.470329472543003e-22
15:13:01 <monochrom> oops
15:13:02 <dmwit> Unbounded-ness is tough for hardware.
15:13:05 <monochrom> > product [1..70] % product [2, 4 .. 140]
15:13:07 <lambdabot>  1 % 1180591620717411303424
15:13:59 <TheKing444> Well, even Ratio Int would be better (computers can't even represent a third right.)
15:14:04 <haywood> Hello all!
15:14:15 <bennofs> > foldl1' lcm [1..1000]
15:14:17 <lambdabot>  7128865274665093053166384155714272920668358861885893040452001991154324087581...
15:14:20 <dmwit> I suspect you would find Ratio Int very unpleasant if you tried it in anything serious.
15:14:33 <monochrom> > (3^5 :: Int) % (4^6)
15:14:35 <lambdabot>  243 % 4096
15:14:40 <monochrom> @type (3^5 :: Int) % (4^6)
15:14:41 <lambdabot> Ratio Int
15:14:58 <bennofs> > length $ base 10 # foldl1' lcm [1..1000]
15:15:00 <lambdabot>  433
15:15:36 <monochrom> you have to watch out for large numbers if you use Ratio Int.
15:17:34 <TheKing444> Oh, a related but different question.
15:17:53 <TheKing444> Does `toRational` always produce a fraction whose denominator is a power of two?
15:18:03 <TheKing444> Or is it only for the cases I have tried so far?
15:18:31 <benmachine> TheKing444: probably it always does for floating-point input
15:18:52 <benmachine> because all floating-point numbers are fractions with denominator a power of two
15:19:07 <luite> > toRational (1/3 :: CReal)
15:19:08 <lambdabot>  *Exception: CReal.toRational
15:19:11 <luite> :(
15:19:22 <benmachine> > toRational (1 % 3) -- I suppose this is probably cheating :P
15:19:24 <lambdabot>  1 % 3
15:19:35 <TheKing444> okay, what about for Floating and Double?
15:20:03 <benmachine> TheKing444: as I said, that's what they "really are"
15:20:15 <TheKing444> and it doesn't round?
15:20:19 <josephle> > toRational (1/3:: Double)
15:20:21 <lambdabot>  6004799503160661 % 18014398509481984
15:20:29 <benmachine> no
15:20:34 <TheKing444> oh that is good
15:20:41 <benmachine> you want fromRational (toRational x) to be x, roughly speaking
15:20:46 <benmachine> so it can't round
15:20:53 <bennofs> > hex # 18014398509481984
15:20:54 <lambdabot>  "40000000000000"
15:21:02 <benmachine> I might be wrong about that, actually
15:21:07 <benmachine> but I believe it to be true
15:21:47 <TheKing444> > toRational (1/3 :: Double)
15:21:48 <lambdabot>  6004799503160661 % 18014398509481984
15:21:49 <josephle> how to quickcheck with lambdabot?
15:21:59 <monochrom> it's probably @check
15:22:13 <benmachine> be sure to set your types
15:22:22 <TheKing444> it says so
15:22:26 <josephle> @check \ x :: Double -> fromRational (toRational x) == x
15:22:26 <lambdabot>  <unknown>.hs: 1: 5:Parse error: ::
15:22:27 <monochrom> yeah, don't let it default to ()
15:22:33 <benmachine> @check \xs -> xs == reverse xs
15:22:35 <lambdabot>  +++ OK, passed 100 tests.
15:22:41 <benmachine> @check \xs -> (xs :: [Int]) == reverse xs
15:22:43 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 2 shrinks):
15:22:43 <lambdabot>  [0,1]
15:22:52 <benmachine> <3 shrinks
15:23:08 <josephle> @check \ x -> fromRational (toRational (x :: Double) ) == x
15:23:09 <lambdabot>  +++ OK, passed 100 tests.
15:23:13 <monochrom> did it consult 2 clinical psychologists? :)
15:23:18 <benmachine> :P
15:23:42 <TheKing444> Can we get quick check to check all floating numbers?
15:24:02 <benmachine> there are too many
15:24:12 <benmachine> > 2 ^ 64 -- this many, roughly
15:24:14 <lambdabot>  18446744073709551616
15:24:30 <TheKing444> What do you mean, finite is never too many for mathematics!
15:24:41 <quchen> josephle: You need parentheses around the "x :: T" part in lambdas, like `\(x :: T) -> v`. (Lambdabot doesn't have ScopedTypeVariables enabled though.)
15:24:47 <benmachine> Doubles aren't mathematics, they're engineering :P
15:25:03 <TheKing444> Okay, how do you test if something is a power of two?
15:25:07 <josephle> quchen: that's good to know
15:25:09 <TheKing444> Just to be more sure.
15:25:18 <benmachine> hmm
15:25:26 <monochrom> repeated division by 2
15:25:36 <benmachine> Data.Bits.popCount?
15:26:11 <benmachine> make sure your version of GHC isn't that one with the embarassing bug where that function just didn't work at all >_>
15:26:48 <TheKing444> I got to go, I'll do it later.
15:27:25 <bennofs> @check \x -> let _ % d = toRational x in (x /= 0) ==> (popCount x == 1)
15:27:29 <lambdabot>  (0 tests) (0 tests; 1 discarded) (0 tests; 2 discarded) (0 tests; 3 discarde...
15:27:47 <bennofs> @check \x -> x == 0
15:27:49 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 1 shrink):
15:27:49 <lambdabot>  1
15:27:50 <benmachine> bennofs: that pattern doesn't do what you think it does
15:28:06 <benmachine> that's a function binding for %
15:28:17 <bennofs> oh
15:28:18 <monochrom> bennofs: % is not a constructor. you have just defined your own % :)
15:28:21 <benmachine> :t den
15:28:21 <lambdabot>     Not in scope: ‘den’
15:28:22 <lambdabot>     Perhaps you meant ‘def’ (imported from Data.Default)
15:28:23 <benmachine> hm
15:28:28 <benmachine> :t denominator
15:28:29 <lambdabot> Integral a => Ratio a -> a
15:28:32 <benmachine> there we go
15:28:33 <bennofs> @check \x -> let d = denominator $ toRational x in (x /= 0) ==> (popCount d == 1)
15:28:34 <lambdabot>  +++ OK, passed 100 tests.
15:28:42 <bennofs> @check \x -> let d = denominator $ toRational x in (x /= 0) ==> (popCount d == 1)
15:28:44 <lambdabot>  +++ OK, passed 100 tests.
15:29:04 <benmachine> @check \x -> let d = denominator $ toRational x in popCount d == 1
15:29:06 <lambdabot>  +++ OK, passed 100 tests.
15:29:29 <bennofs> > denominator $ toRational 0
15:29:31 <lambdabot>  1
15:29:41 <bennofs> > denominator $ toRational 0.6
15:29:42 <lambdabot>  9007199254740992
15:29:45 <bennofs> :o
15:30:02 <benmachine> > denominator $ toRational (0.6 :: Rational)
15:30:03 <lambdabot>  5
15:30:07 <bennofs> heh
15:30:14 <Pythonfant> are there some environment variables (or something else) to get programs that aren't cabal sandbox aware to still search in the sandboxfolder for libraries?
15:30:47 <benmachine> Pythonfant: some tools will take command line arguments that allow you to specify a package database
15:30:52 <MP2E> 'cabal run $SHELL' in the sandbox directory, then run whatever you want that isn't sandbox aware
15:31:03 <benmachine> ooh, ingenious
15:31:38 <MP2E> I think it's a wrapper script that sets up some environment variables, itself :)
15:31:46 <bennofs> MP2E: actually, it's cabal exec IIRC
15:31:54 <Pythonfant> I went with cabal exec
15:31:55 <MP2E> Yep bennofs you're right
15:31:55 <MP2E> whoops
15:31:57 <benmachine> cabal run does *something*
15:31:58 <bennofs> MP2E: cabal run runs a target of the current project
15:32:00 <benmachine> ah
15:32:07 <MP2E> I'm too used to nix :V
15:32:08 <MP2E> sorry
15:32:08 <MP2E> hehe
15:32:09 <Pythonfant> thx for your help
15:47:26 <educated_idiot> what's a good way to fork, develop and test a package, while still using one that's installed via emacs24 package manager? I'm guessing copy over version control on the installed package directory?
15:47:50 <educated_idiot> oops, wrong channel :)
15:50:30 <Desheng_> what's the difference between String and [Char] ?
15:50:48 <MP2E> Desheng_ : nothing, in fact String is a type synonym for [Char]
15:51:22 <Desheng_> thank you very much
15:54:43 <Desheng_> is there a more canonical way to get the ASCII value of a Char, other than (\x -> fromEnum x :: Int) ?
15:55:09 <monochrom> in Data.Char, there is ord
15:56:02 <hpc> technically unicode codepoint, but same thing in the ascii range
15:57:01 <Desheng_> thank you
16:13:43 <arancia> What does IR stand for in this article? http://blog.ezyang.com/2013/05/the-ast-typing-problem/
16:14:32 <quchen> Internal representation?
16:14:34 <liyang> probably intermediate representation.
16:14:57 <jfischoff> I vote with liyang (quchen forgive me)
16:15:18 <quchen> jfischoff: I vote for liyang as well :-)
16:15:43 <quchen> "GHC IR" certainly means intermediate and not internal representation.
16:15:43 <liyang> I don't know. I haven't actually clicked on the link. :)
16:15:53 <arancia> Hhm, why intermediate?
16:19:13 <josephle> because it's between source code and bytecode/assembly
16:19:27 <mmmm_> arancia: I imagine because if you consider an arithmetic expresion such as "2+2" then you start with "2 + 2", the IR is then Add (Num 2) (Num 2) and the final evaluation could be 4
16:19:29 <liyang> It'd be one of several representations of the program from the translation from the source code to the final binary.
16:20:27 <arancia> I see
16:31:18 <mokkake> hi, i need to use "partition" with a filter function that outputs IO Bool, is this doable with Functors ?
16:31:47 <c_wraith> mokkake: no, you need at least Applicative
16:32:32 <c_wraith> mokkake: though IO is Applicative and Monad, so...  (It's easier to write with Monad)
16:33:16 <mokkake> c_wraith: okay. I tried with Applicative too actually, but i don't really know to do it either… Something like partition <$> filterFunction ?
16:33:36 <c_wraith> mokkake: No, it's more sophisticated than that.
16:34:41 <mokkake> i'm confused.
16:34:59 <c_wraith> mokkake: you can't use partition directly.  You have to write it without an appeal to partition
16:35:35 <mokkake> c_wraith: okay, that's what i thought
16:35:37 <mokkake> thanks
16:40:20 <c_wraith> mokkake: Is this something you're trying to figure out on your own, or would you like to see what it looks like?
17:00:25 <GeraldCode> hello
17:00:26 <GeraldCode> How many haskell jobs are there? IS the supply greater than the demand?
17:00:27 <mmmm_> hello
17:00:37 <mmmm_> I would say yes at the moment
17:00:52 <GeraldCode> I mean I study haskell tobe a better programmer in general..but I wouldnt mind being in a job with great job security if I got good
17:00:56 <GeraldCode> ok mmm
17:01:02 <TFT> I'm having trouble figuring out where to head next: http://pastebin.com/S6mavSA1 I'm trying to grab a variable based on a field, but am not sure that's the correct path.
17:01:42 <GeraldCode> mmm, can you recommend a good blog or news site deveoted to haskell?
17:01:51 <GeraldCode> I just want to keep my ear to the ground
17:02:03 <GeraldCode> I have seen some blogs..a lot of them go belly up
17:02:05 <c_wraith> The subreddit is pretty good.
17:02:12 <GeraldCode> ok thanks
17:02:18 <GeraldCode> I hadnt thought of that
17:02:24 <c_wraith> http://www.reddit.com/r/haskell/ to be precise. :)
17:02:32 <GeraldCode> right right thanks :)
17:04:22 <geekosaur> there aren't that many haskell jobs /per se/. but there are a lot of places which consider haskell experience a major plus, because in general people who've taken the time to learn haskell end up being better programmers in any language
17:04:40 <arancia> TFT: "income >= info" doesn't make sense, one is a Float and the other is a composed data type
17:04:53 <GeraldCode> thats a good sentiment...I was thinking something similar
17:05:03 <GeraldCode> the discipline it takes is much higher than anything I have encountered
17:05:09 <noteventime> GeraldCode: There are a couple of good blogs, I find Gonzalez' (http://www.haskellforall.com) blog to be really good, with a nice balance of very "practical" and more "theoretical" things
17:05:23 <GeraldCode> you wont get a lot of punk kids who think they are the next Turing doing haskell
17:05:36 <TFT> arancia: I know, I got stuck in my efforts to filter based on field, googled a bit and thought I might be doing something wrong, sorry for the inconsistancy
17:05:44 <GeraldCode> oh that sounds precisely what I need..a good mix of theoretical and practical...
17:05:58 <GeraldCode> Gotta have the practical so I dont lose motivation..but I axctually find the theory more fun..need both
17:06:06 <arancia> TFT: What exactly do you want to do with this value and the list?
17:06:39 <mmmm_> all the good blog posts end up on the subreddit
17:07:03 <TFT> arancia: I want to use the first field to filter Info type variables and use information from the other fields as parameters in the taxes function
17:07:11 <GeraldCode> great, bookmarked it. I thank you mmmm
17:07:16 <noteventime> Yea, the subreddit is great
17:07:32 * hackagebot ascetic 0.0.0.4 - Generic markup builder.  http://hackage.haskell.org/package/ascetic-0.0.0.4 (AndreiLapets)
17:07:34 * hackagebot richreports 0.0.3.0 - Integrated pretty-printing and error/static analysis reporting.  http://hackage.haskell.org/package/richreports-0.0.3.0 (AndreiLapets)
17:07:52 <GeraldCode> I gotta say though, I have no love for cabal
17:08:06 <GeraldCode> and in the early linux days I didnt enjoy building C and C++ source either
17:08:12 <GeraldCode> wish that part would go away :)
17:09:00 <arancia> TFT: Oh, I'd use zip to make both list a list of pairs, then use filter to find the correct pair, and finally return the second parameter of that pair (if I understood correctly)
17:09:06 <mmmm_> you'll see the subreddit goes in cycles, it has been on a bit of an anti-cabal slant recently
17:09:17 <noteventime> GeraldCode: cabal/cabal-install usually works fine if you use sandboxes
17:09:19 <mmmm_> few months ago it was all about lens
17:09:34 <GeraldCode> yeah I gotta check out lens..still have no clue
17:09:42 <noteventime> mmmm_: And before that pipes vs. conduit? :P
17:09:46 <GeraldCode> noteventime, ok, maybe thats my issue then
17:09:56 <GeraldCode> So the sandbox gets everything that is not prelude?
17:09:59 <c_wraith> GeraldCode: cabal's improving a ton.  There's currently an experimental branch that allows parallel installs of the same version of the same package.  Just that should fix nearly every existing problem.  (Except that it doesn't know how to handle it when happy and alex aren't installed and something uses them)
17:09:59 <mmmm_> yep so I expect we'll get back around to pipes vs conduit in a bit
17:10:12 <TFT> arancia: I'm having trouble figuring out how to pull the lists out of the type without resorting to record syntax
17:10:32 <arancia> You need to pattern match on the info value
17:10:40 <GeraldCode> c_wraith, oh ok..sort of like implicit sandboxing almost?
17:10:55 <TFT> arancia: thank you
17:11:02 <c_wraith> GeraldCode: sort of.  It still has some technical problems, but it's a really solid idea to improve things.
17:11:04 <noteventime> c_wraith: That would also fix Haskell in portage, right?
17:11:36 <c_wraith> noteventime: I have no idea what the problems in portage are.  If it's breaking caused by continuous upgrades, then yes.
17:12:27 <kristof> c_wraith: If they're the same version of the same package, aren't they... the same?
17:12:44 <c_wraith> kristof: not if they're built against different dependencies.
17:13:03 <kristof> example
17:13:12 <GeraldCode> ah interesting
17:13:21 <GeraldCode> I think thats the problem I am having with Yesod and mongo, c_wraith
17:13:42 <GeraldCode> gave up :)
17:13:45 <GeraldCode> went backto mysql
17:15:23 <c_wraith> kristof: library A builds against bytestring 0.9.something.  Library B depends on library A *and* bytestring 0.10.*. If you install it, it will rebuild the same version of A against bytestring 0.10.whatever
17:15:52 <kristof> c_wraith: But that's a package with a *different* version
17:16:08 <kristof> c_wraith: You said "parallel installs of the same version fo the same package"
17:16:15 <c_wraith> kristof: No, it's the same version of package A either way
17:16:21 <kristof> Oh!
17:16:23 <kristof> Now it makes sense.
17:17:05 <kristof> c_wraith: So why wouldn't you want to just rebuild library A?
17:17:33 <c_wraith> kristof: well, it's likely to break anything that was built against A.  That's the reason cabal upgrade was removed.
17:17:54 <c_wraith> kristof: that is, anything that was built against the older version of A
17:18:24 <c_wraith> kristof: and if you try to resolve it by rebuilding everything that was based on A, you typically end up in the situation named "cabal hell"
17:18:31 <kristof> Yes, I've heard of that
17:18:48 <kristof> c_wraith: So this only matters with shared libraries, then
17:19:08 <c_wraith> kristof: true enough.  But haskell libraries tend to actually be shared.
17:19:26 <kristof> Ah, ok
17:19:43 <c_wraith> That is, code reuse is real in haskell. :)
17:20:04 <kristof> c_wraith: So what's the trick?
17:20:07 <GeraldCode> it almost seems like you have to re-use code in haskell..(which is good :)
17:20:16 <GeraldCode> It doesnt seem conducive to making monolithic source files
17:20:28 <GeraldCode> and referential transparency seems to help
17:20:40 <kristof> c_wraith: Do we just identify each version of Library A with something that says "Compiled with thisLibv0.2.0" and another that has a different version?
17:20:51 <kristof> Like library metadata, I guess
17:21:16 <c_wraith> kristof: in the cabal branch? It identifies package by a package key, rather than a package id.  Package ids are more or less a hash of their exported api.  package keys are a hash of the package ids of all of the package's transitive dependencies
17:21:32 <kristof> c_wraith: Oh, that's clever
17:22:01 <isomorpheous> Here's the topic
17:22:02 <c_wraith> kristof: more information here - http://permalink.gmane.org/gmane.comp.lang.haskell.ghc.devel/5413
17:22:07 <isomorpheous>  Topic for ##etc is "if you came here because of spam, just leave. it's not us   │@Khatsabz
17:22:09 <isomorpheous>              | and we're not interested. kthx"
17:22:11 <isomorpheous> y
17:22:14 <kristof> c_wraith: I think I'll let the fellows over in #lisp know about that, because I think they were trying to solve the same problem with ASDF
17:23:41 <Hafydd> Nice nick, isomorpheous.
17:23:52 <isomorpheous> Hafydd: thank you
17:23:57 <Hafydd> I only wonder if "isomorpheus" would be better.
17:24:35 <isomorpheous> Hafydd: maybe
17:24:45 <dfeuer> scanl is actually a right fold, right?
17:24:45 <isomorpheous> Hafydd: you can be isomorpheus
17:25:06 <Hafydd> isomorpheous: that would be terribly confusing.
17:25:14 <isomorpheous> oh shit guys sorry for spamming earlier, I thought this was #archlinux
17:25:23 <isomorpheous> Someone was spamming #archlinux with links to ##etc
17:25:39 <isomorpheous> Hafydd: Well, this is #haskell, after all
17:25:54 <c_wraith> dfeuer: I suppose it is.  It's lazy, after all.
17:26:21 <Hafydd> #haskell is a force that directly opposes confusion.
17:26:53 <GeraldCode> hmm
17:26:55 <dwcook> Hafydd, if you also subscribe to the belief that every force brings its opposite into existence, then Haskell is resonsible for confusion
17:27:39 <GeraldCode> is that a thing dwcook?
17:27:44 <Hafydd> Thankfully, I don't think confusion is a conserved quantity.
17:27:48 <GeraldCode> well I guess in physics
17:27:51 <solidus-1iver> how do you resolve an ambigouse reference to a local scope?
17:27:59 <solidus-1iver> do you have to import the other as qualified?
17:28:47 <dfeuer> solidus-1iver: if you don't need the other name, you can import Foo hiding (bar)
17:28:54 <kristof> dwcook: Forces don't create opposite forces
17:29:33 <dwcook> I'm aware, I was simply being facetious with something I heard quoted that, come to think of it, I can't remember the source of
17:29:39 <dwcook> So, feel free to ignore what I said :P
17:29:45 <GeraldCode> heh
17:31:36 <dfeuer> c_wraith: tonight I plan to give RULES a try for the first time. There seem to be some missed opportunities for foldr/build fusion in basic list functions like takeWhile, scanr, and scanl.
17:32:11 <c_wraith> dfeuer: I don't think scanl is going to be an instant win.  It's going to look like the foldl-as-foldr code.  That's not a win at the moment.
17:32:50 <GeraldCode> dfeuer, neophyte question..what missed opportunities?
17:33:48 <dfeuer> c_wraith: I don't think it will look like that, but I haven't actually tried it yet.
17:35:02 <c_wraith> dfeuer: it *is* foldl, with extra outputs.  You need to get the associativity to go in the right direction.
17:35:07 <dfeuer> GeraldCode, takeWhile, scanr, and scanl don't currently participate in fusion at all. In the case of scanr, it looks to me like it's *free* to make it a good consumer, and not hard to make it a good producer as well, but I'll have to do some work.
17:36:43 <dfeuer> c_wraith: you could be right, but the fact that it produces stuff lazily, unlike foldl, suggests to me that the situation could be different.
17:36:58 <GeraldCode> ok interesting, thank you dfeuer
17:37:08 <c_wraith> GeraldCode: backing up a bit...  Fusion is the name of a trick used to avoid creating unnecessary data structures only to be broken down immediately afterwards.
17:37:10 <GeraldCode> I may only vaguely get it, but this will stick in my subconscious for later :)
17:37:22 <GeraldCode> oh I see
17:37:30 <GeraldCode> I need to google this, becausze I never heard of it
17:37:36 <GeraldCode> That is a problem I have been thinking about
17:38:01 <dfeuer> GeraldCode: What GHC uses is mostly something called foldr/build fusion. It's moderately powerful and moderately awkward.
17:38:07 <GeraldCode> Because one of the canonical things intermidate and beginners do is make tree structures
17:38:10 <c_wraith> GeraldCode: if you want to dig straight into the details of how it is done for the list type, check https://github.com/quchen/articles/blob/master/build.md
17:38:29 <GeraldCode> kk thanks dfeuer , c_wriath, I will look now
17:41:22 <GeraldCode> is this considered the primary way to opimize large data structure usage?
17:41:28 <wting> I'm trying to get lambdabot working on an private IRC server. I have it installed via cabal, but can't find any documentation on how to set it up / connect to a server.
17:41:32 <GeraldCode> It's too advanced for me to spend time on if it isnt
17:43:43 <c_wraith> GeraldCode: automatic fusion is definitely a primary way to optimize things.  Many libraries attempt to support automatic fusion for their types.
17:43:58 <GeraldCode> awesome, its on  my list
17:44:02 <c_wraith> GeraldCode: But you don't really need to understand it now.  It all happens behind the scenes.  Mostly.  :)
17:44:36 <c_wraith> GeraldCode: there are a couple other fusion techniques, as well.  lists use foldr/build fusion.  the text and bytestring libraries provide stream fusion.  They're good at different use cases.
17:44:57 <GeraldCode> ok c_wriath, I will wait
17:45:09 <GeraldCode> I guess this is too soon for me now
17:45:27 <GeraldCode> the data structures I deal with shouldn't ever be more than like 1k anyway
17:45:33 <GeraldCode> at the most (DB records)
17:46:47 <GeraldCode> and there seems to be lazy way to deal with sets
17:47:23 <dfeuer> GeraldCode: one idea us that in many cases, using higher-order library functions like foldr, map, etc., in place of explicit recursion will often, but not always help the compiler produce good code.
17:47:47 <dfeuer> Uhhh... mentally delete the redundancy from that sentence :P
17:48:28 <GeraldCode> I seee thatmakes sense
17:48:54 <GeraldCode> The compiler designers have propbably spent htousands of man hours figuring out howo make those core functions work well
17:49:02 <GeraldCode> And they have to be twenty times smarter than me
17:49:50 <dfeuer> GHC is very good at optimizing plain non-recursive code, and also very good at optimizing certain kinds of combinations of higher-order functions that can often take the place of recursion. Use them and profit.
17:50:13 <GeraldCode> ok
17:51:50 <c_wraith> GeraldCode: you don't need to be smart to improve function performance - you just need to be persistent.  :)
17:52:09 <c_wraith> GeraldCode: so don't think of it in genius spent.  Think of it in thousands of man-hours spent. :)
17:52:21 <GeraldCode> aye, good way to see it :)
17:52:36 <GeraldCode> I do admit occasionally I feel dumb doing this...which is odd because I did ok on SAT and IQ tests
17:52:45 <GeraldCode> but encouragement from haskell developers helps
17:53:22 <GeraldCode> but I eventually grocked monads, which opened up everything
17:53:39 <dfeuer> GeraldCode: reading the commentary in the source code accompanying this stuff will give you a sense of how many things the developers must have thrown at the wall before they got something to stick.
17:53:40 <GeraldCode> I had to find a tutorial that first talked about functors and applicatives first..then I got it :)
17:53:58 <GeraldCode> dfeuer, ok good advice
17:54:45 <c_wraith> Using haskell involves a different way of thinking.  But that's not a bad thing.  You learn to lean on the compiler so you don't need to know everything at once.  One of the guys involved with writing a lot of cutting-edge haskell code likes to say that he often writes code he's not smart enough to write.  It's just learning to use a tool to amplify your brain power. :)
17:56:54 <GeraldCode> haha I like that
17:57:23 <GeraldCode> one of the things I always stress out about is does my code actually work..I work at a place where I dont get time for full design or full unit testing..at least not the past year
17:57:37 <GeraldCode> I need a better way of doing things :) even if I dont fully undxerstand
17:57:48 <Cale> Yeah, sometimes there's only one sensible thing which would typecheck, and while you might not have been able to think of that code all at once, you can work out how to fit the available puzzle pieces together according to their types and end up with it anyway.
17:58:17 <GeraldCode> right yes :)
17:58:33 <GeraldCode> would you say it might be harder to write crap code in haskell than good code?
17:58:39 <GeraldCode> It almost seems that way :)
17:59:19 <c_wraith> No...  I've still written crap code.  :)
17:59:19 <Cale> It's not that hard to write crap code, but things are pretty concise typically, so you don't feel too bad about throwing it away and doing it again. Also pure code is easy to refactor.
17:59:35 <GeraldCode> ah ok
17:59:42 <GeraldCode> hello Cale, thank you for your help the other day
17:59:49 <Cale> no problem :)
17:59:55 <GeraldCode> I was sick passed few days hence why I did not take your offer to continue study
18:00:01 <GeraldCode> well more like exhausted
18:00:10 <c_wraith> Haskell does make it harder to do bad things than most languages, though.  But the number of ways in which code can be bad is far greater than the number of things Haskell can help with. :)
18:00:43 <GeraldCode> ok c_wraith , I guess I dont know neough to be dangerous yet
18:22:41 * hackagebot peyotls 0.1.2.0 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.2.0 (YoshikuniJujo)
18:31:33 <dfeuer> c_wraith: regarding scanl:  foldl f s = last . scanl f s  My limited intuition suggests that from a foldr/build perspective the scanl part is the easy part and the last is the hard part.  last can be written naturally as a foldl, which seems currently the best but is not perfect, or a foldr1, which is lousy for foldr/build.
18:42:13 <GeraldCode> for a strictly academic pursuit, or there any libraries for haskell that can correctly determine algorithmic complexity for a given referrentially transparent function?
18:47:35 <Cale> GeraldCode: I don't know of any
18:47:52 <Cale> GeraldCode: There exist such algorithms for functional programs under strict evaluation
18:47:54 <GeraldCode> Cale, is it even feasible? I guess not. or someone would do it
18:48:02 <GeraldCode> ahh yes I see
18:48:08 <Cale> (but I don't know of any programs which do that either)
18:48:20 <GeraldCode> thanks cale
18:48:24 <pjdelport> GeraldCode: I doubt there's anything really general, but you can probably do things like that for algorithms stated in particular ways that lend themselves to analysis.
18:48:55 <GeraldCode> right, I cant even think of how to code it
18:50:37 <kynan> anyone here familiar with OpenGL programming in Haskell?
18:51:02 <Cale> I don't know if I'd say I was familiar with it, but I've done a little bit
18:51:28 <kynan> how about opengl on mac? i'm trying to run https://github.com/madjestic/Haskell-OpenGL-Tutorial on mavericks
18:52:04 <kynan> it's an issue loading the shaders
18:52:13 <kynan> Main: user error (compile log: ERROR: 0:1: '' :  version '430' is not supported
18:53:01 <GeraldCode> insignificant comment, but why Mac?
18:53:06 <GeraldCode> I had to give up on Windows
18:53:08 <kynan> it's the machine i have
18:53:11 <GeraldCode> Does MAc work well?
18:53:13 <GeraldCode> for haskell
18:53:21 <GeraldCode> I mean, I had to put a linux vm on windows
18:53:33 <Cale> GeraldCode: When Apple isn't causing it to break horribly
18:53:39 <GeraldCode> lol
18:53:43 <kynan> well, i got the haskell part to build just fine
18:53:54 <GeraldCode> ok
18:54:19 <kynan> i think it's a matter of figuring out which version of opengl is supported in mavericks and changing the code to load that profile/context/whatever-it-is-called
18:54:41 <kynan> i tried #version 330 core and #version 330 in the shader and its' the same error
18:55:16 <GeraldCode> I had some opengl experience in python and C++ many years ago
18:55:22 <GeraldCode> but cant say I can help
18:55:27 <GeraldCode> and virtually no mac experience
18:55:30 <kynan> same
18:55:45 <kynan> well, thx for the attention =)
18:56:01 <GeraldCode> np, wish I could say more
18:56:07 <ctangent_> am I totally screwed if two cabal installs are failing due to incompatable dependencies?
18:56:51 <Cale> ctangent_: I'm not sure exactly what you mean by that
18:56:52 <benzrf> ctangent_: lol
18:57:11 <ctangent_> I'm trying to install yesod and elm, and elm fails to install due to a conflict with what yesod installed
18:57:17 <GeraldCode> cale you were right
18:57:23 <GeraldCode> most cabal problems here are about yesod
18:57:24 <Cale> kynan: Weird, pretty much everything in recent history should support OpenGL 3.3 at least
18:57:24 <benzrf> ctangent_: welcome to cabal
18:57:25 <benzrf> ;-;
18:57:30 <ctangent_> :'(
18:57:47 <luite> ctangent_: install elm in a sandbox
18:57:50 <GeraldCode> I that was you who said that anyway
18:57:58 <ctangent_> I'm already in a sandbox for yesod
18:58:10 <ctangent_> That's sad I can't have them in the same sand box :(
18:58:17 <ctangent_> at least I can mess with my path I guess
18:58:23 <Cale> Cabal is actually pretty good so long as you're not trying to install one of those monstrous frameworks with lots of fiddly dependency issues
18:58:37 <ctangent_> ouch
18:58:43 <GeraldCode> like yesod?
18:58:48 <Cale> yes, like yesod
18:58:49 <dcoutts> ctangent_: if they have incompatible dependencies then yes they cannot live in the same sandbox
18:59:13 <dcoutts> ctangent_: indeed sandboxes exist to allow you to have multiple independent projects with incompatible dependencies
18:59:22 <ctangent_> sure
18:59:37 <c_wraith> So if I have a benchmark where switching from Vector (basic) to Vector (unboxed) slowed things down, does that mean that other code is requiring reboxing the values from the Vector?
18:59:56 <Cale> c_wraith: likely
19:00:12 <dcoutts> c_wraith: or you were saving time due to lazyness, not having to calculate the vector elements
19:00:32 <c_wraith> dcoutts: eh, the benchmark didn't ocunt creation of the vector.
19:00:35 <c_wraith> *count
19:01:22 <dcoutts> I've no idea what the code is, just pointing out that Vectors are lazy in the elements, so that can be a time saving if they don't all need to be evaluated
19:01:57 <c_wraith> Yeah, that was definitely not the case here.  I'm microbenchmarking with criterion. The same vector is used in every iteration of the test. :)
19:02:22 <dcoutts> ok
19:03:03 <dcoutts> c_wraith: check the +RTS -S alloc stats
19:03:07 <Cale> c_wraith: If you're applying polymorphic functions to the elements (or even perhaps if not), they'll have to be boxed again when they're extracted from the vector, which will involve some additional allocation.
19:09:59 <GeraldCode> Blondtranscendenchello cutey
19:10:06 <GeraldCode> oops
19:10:08 <GeraldCode> :)
19:37:50 <kynan> GeraldCode I got 330 to work yay
19:39:50 <kynan> sweet 410 works too
19:40:16 <kynan> in case anyone else has the problem: http://stackoverflow.com/questions/22887922/glfw-fails-to-open-window-in-osx
19:46:38 <GeraldCode> sweet kynan
19:48:03 <stolaruk> Do ppl ever have both State and ST in the same stack?
19:48:30 <GeraldCode> Isn't State just ST with Identity?
19:49:28 <stolaruk> I think they are two different things.
19:50:10 <GeraldCode> oh, I thought you meant StateT
19:50:15 <GeraldCode> my apologies
19:50:58 <stolaruk> GeraldCode: Well it would be StateT in the transformer stack.
19:51:07 <GeraldCode> oh
19:51:39 <GeraldCode> I think maybe I dont know what you mean by stack
19:51:50 <stolaruk> GeraldCode: Monad transformer stack
19:51:58 <GeraldCode> ah ok
19:52:25 <stolaruk> GeraldCode: I'm curious if anybody has StateT in their transformer stack and they also use ST
19:52:35 <GeraldCode> ok
19:52:58 <GeraldCode> so is this meaning using multiple States in the same function?
19:53:03 <GeraldCode> or am I totally off base?
19:53:22 <geekosaur> I would guess it's not common, since in general you use ST as little as possible to constrain the range of mutability, and you'd probably use an STRef instead of State in that case
19:53:24 <stolaruk> GeraldCode: You could use multiple in the same function
19:53:44 <geekosaur> GeraldCode, ST is not really related to State
19:53:50 <GeraldCode> ok
19:54:23 <stolaruk> Is ST/STRef used to write fast algorithms, more than to thread state into many functions?
19:54:46 <geekosaur> State is an implicit tuple acting somewhat like mutable state; ST is used to constrain mutable state so it can't escape into pure code
19:54:58 <GeraldCode> interesting
19:54:59 <geekosaur> you mostly use it when you need to use a mutable algorithm for speed
19:55:08 <stolaruk> geekosaur: Yeah ok
19:55:08 <GeraldCode> ButI thought state was just "sugae"
19:55:10 <GeraldCode> sugar*
19:55:14 <GeraldCode> it isnt really state at all
19:55:22 <geekosaur> the State monad is sugar for a tuple
19:55:36 <geekosaur> State = s -> (a, s)
19:55:56 <GeraldCode> ok
19:56:04 <stolaruk> Is it a common technique to put a mutable reference (such as IORef) in the Reader monad?
19:56:09 <geekosaur> so the "state" is passed as a parameter, and returned as part of a tuple, but the State monad lets you ignore that part and just worry about the "a"
19:56:22 <GeraldCode> right, thanks for confirming geekosaur
19:56:38 <geekosaur> not actual mutable state, it's a pure simulation of it
19:56:41 <geekosaur> that works for most uses
19:56:48 <GeraldCode> :) ok I am starting to understand
19:56:56 <GeraldCode> this was also a big part of me feeling more confident
19:56:56 <geekosaur> stolaruk, it's a convenient way to pass an IORef around, yes
19:56:59 <GeraldCode> when I learned that
19:57:34 <geekosaur> you never change the IORef itself so Reader is appropriate; and you can easily get at the mutable data "contained" within it
19:57:42 <GeraldCode> helped understand other things in do notation that seemed weird
19:58:01 <stolaruk> geekosaur: You can "writeIORef" tho, right?
19:58:04 <geekosaur> yes
19:58:14 <geekosaur> because it does not change the IORef itself.
19:58:48 <geekosaur> think of it this way, an IORef contains a pointer to something else. the IORef itself does not change but you can follow (with readIORef) or change (with writeIORef etc.) the pointer
19:59:00 <benzrf> geekosaur: you mean pointee?
19:59:18 <geekosaur> benzrf, no, I'm talking a level above that
19:59:33 <benzrf> oh
19:59:44 <GeraldCode> haskell is hard :)
19:59:45 <geekosaur> the pointee I consider normal pure data. the pointer to it is contained in the "value slot" of the IORef
19:59:46 <stolaruk> geekosaur: I already have a State monad and I need to add mutable state of a different kind; thus I'm thinking of passing it around in some way other than the same State monad I already have.
19:59:50 <geekosaur> but the IORef itself is constant
19:59:52 <GeraldCode> harder than c++ which I thought was hard 15 years ago
20:00:07 <benzrf> GeraldCode: haskell is much easier than c++
20:00:14 <GeraldCode> benzrf really?
20:00:22 <GeraldCode> Why does it seem so hard then?
20:00:23 <stolaruk> Yeah I would tend to agree
20:00:34 <geekosaur> mm, not sure how to describe this with modern terminology. in the old days we distinguished between pointers and handles; handles were pointer-to-pointer-to-data and you could modify the inner pointer
20:00:46 <geekosaur> used with C-with-garbage-collection
20:00:56 <benzrf> GeraldCode: c++ wouldve been as hard if you learned it from scratch as your first language
20:00:59 <benzrf> :-)
20:01:00 <GeraldCode> maybe I think its hard because so many people do things in such exotic ways
20:01:24 <geekosaur> so the handle itself was static but the pointer inside it changeable, and the data pointed to buuy that might be either (in Haskell it's usually pure/immutable)
20:01:25 <benzrf> GeraldCode: also, haskell makes it harder to get things done if you dont really understand what you're doing
20:01:39 <GeraldCode> yes, a subset of c++ is easy
20:01:41 <benzrf> GeraldCode: imperative languages like c++ make it much easier to write code you don't fully understand
20:01:44 <GeraldCode> you can get things done
20:01:52 <GeraldCode> but you have to understand haskjell to get things done
20:01:59 <benzrf> GeraldCode: so you get the illusion of understanding it sooner
20:02:07 <GeraldCode> good point
20:02:14 <GeraldCode> I was a an amateur
20:02:19 <benzrf> heh
20:02:20 <GeraldCode> but still able to make production code
20:02:57 <GeraldCode> I am quite sure Id get fired from a pro haskell job within a month
20:02:59 <geekosaur> stolaruk: so you could do it with a ReaderT, or with a pair of StateT-s and "accessors" which do `get` or `lift get` as appropriate
20:03:14 <geekosaur> (and corresponding put/modify)
20:03:43 <stolaruk> geekosaur: Yes I could just put it all in StateT
20:03:44 <GeraldCode> I take that back
20:03:51 <GeraldCode> Id work my butt off :)
20:04:00 <GeraldCode> and survive...but it would not be easy
20:04:11 <geekosaur> in most cases it's easier to modify the state to use a record and gets/puts instead, but if you don't have direct control over the original state for some reason (e.g. it's used elsewhere that expects no additional stuff) you could use the wrapper
20:05:05 <geekosaur> using an IORef may be overkill in this case, I'd tend to think `lift get` is cheaper
20:06:42 <stolaruk> geekosaur: Yes I have nested record types in the State monad, and I'm using lenses so drilling down is easy.
20:06:49 <stolaruk> geekosaur: I'm trying to figure out how to use "zoom"
20:08:11 <benzrf> :t zoom
20:08:12 <lambdabot> (Zoom m n s t, Control.Lens.Internal.Zoom.Zoomed n ~ Control.Lens.Internal.Zoom.Zoomed m) => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
20:08:17 * benzrf flinches
20:08:23 <benzrf> i always forget how truly horrifying it is
20:08:34 <benzrf> q_q
20:08:52 <geekosaur> zoom :: Monad m             => Lens' s t      -> StateT t m a -> StateT s m a
20:09:26 <geekosaur> so given a Lens from a state s to a state t, apply an action intended for StateT t to a StateT s
20:09:35 <geekosaur> (well, Lens')
20:09:40 <benzrf> > runState $ do {put (("foo", "bar"), 5); zoom _1 $ do {_2 %= (++"baz")};}
20:09:43 <lambdabot>  <(([Char],[Char]),Integer) -> ((),(([Char],[Char]),Integer))>
20:09:47 <benzrf> oops
20:10:22 <benzrf> > runState (zoom _1 (_2 %= (++"baz")) (("foo", "bar"), 5)
20:10:23 <lambdabot>  <hint>:1:56:
20:10:23 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
20:10:29 <benzrf> > runState (zoom _1 (_2 %= (++"baz"))) (("foo", "bar"), 5)
20:10:31 <lambdabot>  ((),(("foo","barbaz"),5))
20:10:36 <benzrf> :-)
20:11:28 * geekosaur not exactly a lens expert, but the examples on Control.Lens.Zoom haddock seem to make sense
20:12:17 <GeraldCode> what do lens help one do?
20:12:34 <GeraldCode> Since it seems to be a fashion...I imagine they arent all that necessary?
20:12:57 <geekosaur> in one sense, it's the record system everyone wishes Haskell had
20:13:04 <GeraldCode> oh
20:13:22 <geekosaur> in another sense, it's a generics library to end all generics libraries
20:13:28 <GeraldCode> so why the dissent against it
20:13:44 <benzrf> GeraldCode: >x to end all x
20:13:47 <benzrf> >why dissent
20:13:59 <GeraldCode> ok
20:14:12 <geekosaur> it's rather large and complex. it reduces type safety, since it tries to make sense of requests to do pretty much anything to anything
20:14:28 <geekosaur> (and the error messages when it fails stand some chance of causing insanity)
20:14:35 <GeraldCode> If I dont have type safety then I mijght as well do PHP?
20:14:39 * benzrf went insane from lens errors long agolsme_ 
20:14:40 <benzrf> *ago
20:14:43 <benzrf> and i dont even use lens!
20:14:53 <benzrf> GeraldCode: cmon
20:14:58 <GeraldCode> interesting. thanks. I wont be using them then
20:14:59 <benzrf> there are much better dynamically typed langs than php
20:15:01 <GeraldCode> benzrf,  lol
20:15:14 <benzrf> GeraldCode: i kinda like lenstr
20:15:16 <benzrf> *lens
20:15:23 <benzrf> feel like it's a little bit overcomplicated
20:15:28 <GeraldCode> ok
20:15:28 <benzrf> but it has a good heart :y
20:15:40 <benzrf> dont trust me on this one, i have little experience
20:15:43 <geekosaur> I think the most common complaint I've heard is just its size
20:15:55 <geekosaur> it does a lot of things, and as a result is a very large package
20:16:04 <GeraldCode> ok
20:16:15 <GeraldCode> haskell is like pholosophy or math
20:16:20 <GeraldCode> you will never know everything
20:16:29 <geekosaur> if all you're after is the simpler record manipulation things, it looks a lot like massive overkill, because you can't really break it into small parts
20:16:36 <GeraldCode> let me guess, both of you have been at this for years
20:16:38 <geekosaur> and only use the part you care about
20:16:43 <GeraldCode> and still things confound you
20:16:45 <levi> GeraldCode: on the contrary, lens is very helpful, and it can clean up really messy code.  It's worth learning and using, but you can put off learning it right now if your plate is full.
20:17:01 <GeraldCode> ok levi
20:17:18 <geekosaur> at what? I've been doing Haskell seriously since around 2007, but I'm not really an expert (mostly because 99% of my usage is for xmonad)
20:17:20 <__jim__> Hey, quick noobie cabal question. I have a project that will have a server side binary and a client side binary. Is the proper way to manage this with two cabal projects, or is there a way to have cabal compile two branches?
20:17:39 <GeraldCode> geekosaur,  yeah I meant haskell...so that is 7 years for you
20:17:47 <GeraldCode> that is a long time for something IT related
20:17:55 <benzrf> ive been doing haskell for like
20:17:58 * benzrf ponders
20:18:01 <benzrf> 2-3 years
20:18:11 <benzrf> i dont actually write much in it though
20:18:16 <benzrf> mostly i read papers and write one liners
20:18:17 <geekosaur> but I'm also 50 >.>
20:18:17 <benzrf> :y
20:18:29 <GeraldCode> geekosaur, nice to meet an older feller like myself :)
20:18:33 <levi> GeraldCode: If you think you've mastered a mature programming language after a few years, you need to rethink your idea of mastery.
20:18:40 <benzrf> geekosaur: is that the source of the 'saur' in your nick
20:18:44 <GeraldCode> Im not quite at your age, but been doing it a while
20:18:46 <benzrf> levi++
20:19:00 <geekosaur> and I didn't get any formal schooling, so Haskell tends to hit me in the places where I have the least actual foundations (like, say, algorithms)
20:19:00 <GeraldCode> levi, I agree..I thought I was smart when I graduated college
20:19:06 <GeraldCode> I didnt know sh--------d
20:19:11 <levi> Heh. :)
20:19:19 <GeraldCode> I dont think I finally knew anything until about 7 years in
20:19:40 <benzrf> GeraldCode: same
20:19:54 <savanni> That sounds about right.
20:20:06 <geekosaur> (no formal CS schooling, that is. I don't think the fortran and cobol classes in what little university training I got count for much...)
20:20:08 <levi> You can certainly be proficient in something after a couple of years, but I think people tend to claim mastery too early.
20:20:19 <benzrf> i think i started doing python about uh
20:20:27 <GeraldCode> heh geek
20:20:28 <benzrf> between 3 and 4 years ago
20:20:41 <benzrf> and i only really started to know anything a while into my python phase
20:20:49 <GeraldCode> yeah
20:21:02 <GeraldCode> when you meet professional practical programmers, you get humbled quick
20:21:07 <GeraldCode> unless you are a real douche
20:21:09 <GeraldCode> which I was
20:21:37 <__jim__> so, any takers to help a new guy out?
20:21:40 <GeraldCode> fortunately I had a boss who knew how to train people a few years in
20:21:44 <GeraldCode> and I started to figure things out
20:21:46 <benzrf> __jim__: w/ what?
20:21:59 <__jim__> i had a quick cabal question
20:22:08 <__jim__> I have a project that will have a server side binary and a client side binary. Is the proper way to manage this with two cabal projects, or is there a way to have cabal compile two branches?
20:22:11 <[erk]hacker> hi
20:22:12 <geekosaur> __jim__, cabal's kinda weak in the area of multiple executables. I'd use separate projects, and if there's a common core then a third library project
20:22:13 <benzrf> oh
20:22:20 <benzrf> hello [erk]hacker
20:22:21 <__jim__> ah
20:22:40 <__jim__> Glad I came here, thanks for the helps guys
20:22:49 <[erk]hacker> hello benzrf
20:22:59 <geekosaur> (I did see your original query but was hoping someone better versed... oops)
20:23:18 <levi> I often scratch my head at people who tell stories about switching jobs every year or two.  I guess if you're doing basically the same thing over and over, you might be able to accomplish something worthwhile in that time, but it seems unlikely.
20:23:20 <benzrf> same as geekosaur
20:23:25 <GeraldCode> ___jim___ yeah this appears to be the most helpful community on freenode
20:23:30 <geekosaur> they left
20:23:34 <benzrf> GeraldCode: we're so helpful, we help trolls
20:23:40 <GeraldCode> maybe because they have the most unusual devotion
20:23:40 <geekosaur> hence my "oops"
20:23:47 <GeraldCode> benzrf, yes I notice
20:23:50 <GeraldCode> noticed
20:23:58 <lamehaskeller> levi: You switch for $'s not cos you know everything.
20:24:21 <lamehaskeller> You also switch cos you hate the job and your boss knows you know nothing.
20:25:01 <GeraldCode> levi, if you switch job every 2 years (like some people are advocating programmers should do) you never become an expert
20:25:04 <lamehaskeller> At the end of two or three such changes, you know something.
20:25:26 <GeraldCode> There are articles..written by CEOs of places like Twitter I think...(or some big recent tech giant) saying that
20:25:34 <lamehaskeller> Then recession hits and you lose your job ...
20:25:59 <GeraldCode> But even worse...a prospective employee look  at your resume..and has no confidence that you will stay
20:26:03 <GeraldCode> or thay you have discipline
20:26:17 <GeraldCode> This is a good reason to work at non programming companies
20:26:25 <GeraldCode> as an inhouse code early on, I think
20:27:01 <GeraldCode> or that you have NO discipline
20:27:15 <lamehaskeller> well true.
20:27:25 <GeraldCode> If I am a hiring manager..and I see a 27 year old come into my office for an interview..and I see his longest job at 18 months, I wont hire him
20:27:30 <GeraldCode> unless I love his/her personality
20:27:37 <GeraldCode> dont care how smart he is
20:27:51 <GeraldCode> I got lucky....I gig get hired in such a circumstance
20:27:57 <levi> I have mostly worked in companies that had an EE emphasis with software support rather than pure software companies.  It's a very different environment from the "tech startup" world, it seems.
20:28:00 <GeraldCode> but I the market is too saturated now
20:28:23 <GeraldCode> levi, oh yeah, its totally different
20:28:33 <GeraldCode> Ive worked in both, and its too different worlds
20:29:32 <GeraldCode> one thing that has intrigued me is...there are no unions
20:29:35 <GeraldCode> none with any power
20:29:49 <GeraldCode> There are a lot of programmers...but we have zero power
20:30:20 <lamehaskeller> cos of the H1b workers.
20:30:29 <GeraldCode> yes :(
20:30:48 <benzrf> GeraldCode: well, we have tagged unions
20:31:20 <levi> Hmm. It's a bit of a different dynamic than traditional captal/labor division, though. What's the "means of production" in a software company?
20:31:32 <GeraldCode> benzrf, , lol
20:32:06 <splintax> levi: the money used to pay salaries until the company is profitable, or, if it's already profitable, the software/IP itself
20:32:49 <GeraldCode> I think its simpler than econ
20:32:54 <GeraldCode> I think programmers are whores
20:32:57 <GeraldCode> most of us
20:33:12 <GeraldCode> and we wil become canablas in a heartbeat
20:33:19 <levi> splintax: Sure, but this is a bit different than the massive infrastructure required to mass-produce physical products.
20:33:25 <GeraldCode> :)
20:34:11 <GeraldCode> And because our industry moves so fast..we will not mature fast enough to deal with the market
20:34:13 <levi> The economics of sofware production are, like the actual methods of software production, still a bit new and weird.
20:34:23 <GeraldCode> eventually you will have programmers who are born in the west making 20k a year
20:35:18 <splintax> levi: most companies aren't mass-producing physical products. i don't see anything unique about the software industry
20:35:24 <splintax> as far as IR goes
20:36:06 <splintax> hmm, except maybe the whole open source thing. there's definitely not a lot of analogues to that
20:36:37 <splintax> i withdraw my previous remarks
20:36:40 <benzrf> splintax: f-free software
20:36:49 <benzrf> splintax: FOSS is obviously communism
20:37:14 <benzrf> just look at that hippie stallman
20:37:20 <d3m1g0d-> under windows, how do I copy the output from the GHCI terminal ?
20:37:30 <benzrf> d3m1g0d-: step 1: install a better OS
20:37:36 <benzrf> step 2: click and drag
20:37:45 <splintax> d3m1g0d-: is it a cmd.exe thing? you can right click the title bar, and choose "edit > mark" if so
20:37:48 <GeraldCode> d3m1g0d-, first I suggest using a proper text editor
20:37:53 <GeraldCode> I suggest Notepadd++
20:37:56 * hackagebot bindings-GLFW 3.0.3.3 - Low-level bindings to GLFW OpenGL library  http://hackage.haskell.org/package/bindings-GLFW-3.0.3.3 (BrianLewis)
20:38:06 <benzrf> GeraldCode: you dont even know what editor d3m1g0d- is using
20:38:07 <GeraldCode> but if you dont want to do that, do as splintax  suggested :)
20:38:11 <Cale> GeraldCode: but that has nothing to do with copying the output of GHCi
20:38:14 <GeraldCode> benzrf,  yes I do
20:38:16 <GeraldCode> he is using cmd
20:38:21 <benzrf> no...
20:38:23 <benzrf> that's for ghci
20:38:24 <Cale> ...
20:38:43 <GeraldCode> There is a GHCI specific terminal?
20:38:47 <dfeuer> @tell q_wraith I understand what you mean about scanl now. It doesn't look like it will be easy to make it a good consumer. That said, it looks to me like it *can* be made a good producer without any serious complications.
20:38:47 <lambdabot> Consider it noted.
20:38:50 <Cale> Unless you're talking about running ghci inside of emacs or something
20:38:54 <benzrf> blllllllllllllllllllllllllugh
20:38:59 <GeraldCode> how is it different from cmd?
20:39:03 <benzrf> GeraldCode: d3m1g0d- is using cmd to run ghci
20:39:06 <benzrf> not to edit code
20:39:10 <Cale> It'll run in a windows cmd terminal. cmd is not a text editor
20:39:16 <GeraldCode> I have experience with several "layers" over cmd that seem like something new
20:39:20 <GeraldCode> but they are still just cmd
20:39:31 <GeraldCode> benzrf, I understand that
20:39:35 <benzrf> GeraldCode: i hope you are not using Windows
20:39:41 <GeraldCode> you still need to use the same cmd functions to COPY code
20:39:41 <d3m1g0d-> splintax:  thank you, that worked.
20:39:55 <benzrf> d3m1g0d-: i still strongly recommend using another os
20:39:57 <Cale> GeraldCode: He said he wants to copy the *output* of GHCi
20:40:07 <GeraldCode> He wants to PAST outside of it
20:40:27 <d3m1g0d-> benzrf: like which one ?
20:40:29 <GeraldCode> yes, its not a hard thing to understand
20:40:38 <benzrf> d3m1g0d-: gnu/linux is generally my first choice
20:40:41 <GeraldCode> he is using a console in windows and he wants to copy and paste yes?
20:40:53 <Cale> GeraldCode: That has nothing to do with which text editor you're using. Any text editor will accept text from the windows clipboard
20:40:58 <GeraldCode> I suggested using a better system
20:41:00 <benzrf> bsds are technically superior i suppose
20:41:09 <GeraldCode> Cale, it for damn sure does
20:41:11 <splintax> who cares
20:41:18 <benzrf> os x is fairly good but proprietary :[
20:41:22 <GeraldCode> I can use in in built console INSIDE of notepadd++, got it
20:41:28 <benzrf> GeraldCode: ah
20:41:35 <dfeuer> BSDs seem to have their pluses, but there is no one "technically superior".
20:41:36 <benzrf> GeraldCode: that's a better *shell* though
20:41:38 <d3m1g0d-> benzrf: your choice is bad. That's an OS with a 2% market share on a REALLY good day. They're actually not even "bad", they're "unusable". Please refrain from such advices.
20:41:53 <GeraldCode> true benzrf
20:41:53 <benzrf> d3m1g0d-: nice trolling bro :^)
20:41:54 <Cale> benzrf: Or a better terminal emulator
20:42:00 <benzrf> Cale: gah
20:42:22 <benzrf> i tripped :'(
20:42:27 <dfeuer> Linux definitely has the driver advantage. d3m1g0d-, what OS has a 2% market share on a good day?
20:42:43 <dolio> What does this have to do with Haskell?
20:42:45 <levi> Come on guys, let's not have OS/editor/terminal fights.
20:42:46 <d3m1g0d-> dfeuer: linux on desktop PCs
20:42:54 <benzrf> d3m1g0d-: ( ͡° ͜ʖ ͡°)
20:43:03 <GeraldCode> dolio, nothing
20:43:08 <GeraldCode> and I apologize
20:43:11 <dolio> Then you should stop talking about it.
20:43:19 <GeraldCode> dolio, I just said I apologize
20:43:52 <benzrf> d3m1g0d-: your choice is bad. That's an OS with 2% free components on a REALLY good day. They're actually not even "bad", they're "unusuable" for anything more in-depth than web browsing. Please refrain from such advices.
20:44:07 <__jim__> one more question for you guys, I'm thinking about getting into some FRP for this project, so I was wondering if anyone knew of a good FRP framework for a client / server network interface
20:44:18 <benzrf> __jim__: i only know reactive-banana
20:44:23 <benzrf> but netwire is literally called netwire
20:44:24 <benzrf> :y
20:44:45 <d3m1g0d-> That's the problem with Haskell. It's too close to the "linux cult" and to fanatics, like you benzrf
20:44:46 <__jim__> how was your experience with reactive-banana?
20:44:53 <d3m1g0d-> that's why it will never go mainstream in the industry
20:44:56 <dolio> That goes for everyone.
20:45:16 <GeraldCode> I think linux is fine, personally d3m1g0d-
20:45:19 <benzrf> d3m1g0d-: pls come back when youve mastered the art of subtlety in trolling
20:45:24 <GeraldCode> It is clearly better for development
20:45:35 <GeraldCode> I use windows because its just easier
20:45:36 <d3m1g0d-> it's unusable.
20:45:43 <d3m1g0d-> ofc u use it, it gets shit done
20:45:44 <dfeuer> I don't know about a Linux cult, but I know Windows has gotten so painful that even my mother doesn't use it anymore.
20:45:46 <GeraldCode> got linux on a vm
20:46:05 <benzrf> dfeuer: i put mine on ubuntu
20:46:25 <benzrf> dfeuer: she seems to like it but it occasionally causes issues when she needs proprietary software for her work
20:46:54 <GeraldCode> d3m1g0d-, but this is interesting...I cant really get most things working on haskell in windows
20:46:58 <GeraldCode> except simple things
20:47:07 <benzrf> GeraldCode: dont feed trolls
20:47:15 <GeraldCode> oh ok benzrf
20:47:17 <benzrf> unless you're feeding them haskell evangelism
20:47:36 <GeraldCode> well I was curious about what he meant
20:47:41 <GeraldCode> because Id rather do this on windows
20:48:01 <benzrf> GeraldCode: do what?
20:48:04 <GeraldCode> And I remember when I was big into linux..most things you couldnt build on windows
20:48:09 <GeraldCode> even with Visual Studio
20:48:16 <Cale> A lot of Haskell code, I would say the majority of it, is cross platform
20:48:33 <Cale> and should build equally well on Windows, Mac OS X and Linux at minimum
20:48:48 <GeraldCode> Cale, I m sur eit is..but maybe not for a newb
20:48:58 <GeraldCode> I have the latest Haskell polatform on windows, and I could not build yesod
20:49:02 <GeraldCode> that was final straw..
20:49:02 <benzrf> 10:47 < GeraldCode> because Id rather do this on windows
20:49:04 <benzrf> ??
20:49:07 <levi> GeraldCode: There are definitely challgenges involved with some libraries on Windows, especially GUI ones. But Windows is definitely a supported platform for GHC itself and many libraries.
20:49:26 <GeraldCode> ok, im sure I just screwed up
20:49:29 <GeraldCode> lets leave this alone :)
20:49:46 <GeraldCode> I dont want to waste time on something that other people dont have problems with
20:49:55 <GeraldCode> besides I am fine now..except for Mongo with yesod
20:50:20 <dfeuer> I don't think it's a Haskell issue, really. I think *most* open source developers prefer working on some sort of Unix, so most open source software supports Unix better.
20:50:27 <levi> Well, I'm not sure I ever tried yesod on windows, so I couldn't give particular advice.
20:50:32 <GeraldCode> benzrf,  yeah I prefer windows
20:50:38 <GeraldCode> I just dont like the security problems
20:50:56 <GeraldCode> and the fact you need ming or cygwin to build lots of open source (maybe that is changing , I dont know)
20:51:01 <benzrf> GeraldCode: eesh
20:51:08 <dfeuer> It's often easy to make such stuff work on Mac, but Windows tends to add a lot of special weirdness.
20:51:26 <benzrf> how can you like a system that uses back slashes as a dir separator?
20:51:38 <GeraldCode> dfeuer, aye, linux is where its at
20:51:42 <GeraldCode> for that crowd
20:52:32 <benzrf> windows is the php of operating systems
20:52:42 <GeraldCode> oh and btw even with ming or cygwin, much of that open source will not build
20:52:47 <dolio> benzrf: Why are you continuing this off topic discussion?
20:52:48 <GeraldCode> unbless you jump through lots of hoops
20:52:57 <GeraldCode> that make take days to solve...might as well install linux
20:53:49 <benzrf> dolio: because im opinionated
20:53:57 <benzrf> that's a nice way of saying various negative things
20:53:59 <GeraldCode> so takes days to solve WITH google
20:54:02 <benzrf> which i will refrain from listing
20:54:07 <GeraldCode> imagine what people 20 years ago went through
20:54:22 <d3m1g0d-> as an ex- .NET developer noone wants windows to die more than me, but there is simply nothing better. 2% market share is not "bad" , it's "unusable".
20:54:36 <benzrf> d3m1g0d-: ll
20:54:38 <benzrf> *lol
20:55:10 <GeraldCode> dont know if cygwin existed back thn
20:55:11 <d3m1g0d-> I really can't manage to do sh*t in that OS. I need like 3 months preparation in order to get everything straight up, people don't care about that. People wanna get sh*t done
20:55:14 <GeraldCode> but you get my point
20:55:24 <benzrf> d3m1g0d-: lol
20:57:31 <splintax> looks like this dumb discussion has driven away at least 2 people who were actually talking about haskell already :)
20:57:33 <dolio> Being opinionated is not an excuse for prolonging inflamitory, off topic discussions in here.
20:58:44 <d3m1g0d-> this stupid kid, got on my nerves, called me I troll. That's not trolling, that's not an opinion, that's a fact. It's unusable.
20:59:45 <dolio> Can we all agree to stop discussing who is in the wrong for liking one operating system or another?
20:59:45 <GeraldCode> and there is nothing to demonstrate that what you said dolio is anymore helpful to the haskell discussion that the previous few comments
21:00:01 * levi sighs.
21:00:15 <GeraldCode> lets all just shut up for amoment maybe
21:00:22 <GeraldCode> and remember why we are here..
21:01:22 <benzrf> dolio: by "im opinionated" i meant "I prolong inflamitory, off topic discussions in here"
21:02:42 <zematis>  /join #python
21:02:42 <GeraldCode> d3m1g0d- I dont know why it was a big deal
21:02:50 <GeraldCode> d3m1g0d-,  maybe just ask your question
21:02:52 <dolio> And you'll be unable to refrain from this in the future?
21:03:24 <benzrf> dolio: it usually doesnt get this bad >.>
21:03:26 <GeraldCode> since we have you-know-who being seargent-at-arms in the channel...
21:03:27 <benzrf> ill try
21:03:39 <d3m1g0d-> GeraldCode: I did ask my question and my question was adequately answered by another user. What this moron suggested as a response was to simply change the OS.
21:03:57 <GeraldCode> oh wait...was it me who did that?
21:03:59 <GeraldCode> lol
21:04:01 <benzrf> GeraldCode: no, i did
21:04:09 <benzrf> you did partially endorse the idea tho
21:04:10 <GeraldCode> ah
21:04:25 <GeraldCode> ok lets leave it
21:04:31 <GeraldCode> I dont see why we have to fight
21:04:38 <GeraldCode> please?
21:04:59 <GeraldCode> this is the one channel I dont bother getting my emotions up
21:05:09 <GeraldCode> and I was told most people are that way here
21:05:22 <mmachenry1> GeraldCode: Most are
21:05:29 <GeraldCode> ok
21:05:59 <mmachenry> This is, in fact, the best channel on the IRC. I don't even know how to program. I just come for the lovely people.
21:06:08 <GeraldCode> oh thats sweet
21:06:26 <mmachenry> I'm just kidding. I write Haskell. But it is a nice community. :)
21:06:31 <GeraldCode> LMAO
21:07:08 <mmachenry> I am, actually, just on the edge of writing my first piece of code in Haskell professionally.
21:07:12 <GeraldCode> d3m1g0d-,  most people arent assholes
21:07:18 <GeraldCode> the internet is a bad way to communicate
21:07:32 <GeraldCode> most communication is through body language..you dont get that here
21:07:47 <d3m1g0d-> I am. I find myself constantly explaining stupid people why they're stupid. But that's just the way I was born. Don't be a moron and I'll be a nice guy
21:07:50 <mmachenry> I've written a lot of Haskell code privately but I am really close to convincing my team to let me write a new piece of software in Haskell.
21:07:51 <GeraldCode> mmachenry,  you are farther than me
21:07:53 <d3m1g0d-> and stop putting oil in the fire.
21:08:00 <mmachenry> Figured you guys would appreciate that.
21:08:14 <djahandarie> GeraldCode, d3m1g0d-, maybe this meta-discussion would be better in #haskell-blah or PM?
21:08:23 <GeraldCode> djahandarie,  sorry
21:08:27 <GeraldCode> Ill end it
21:08:32 <GeraldCode> mmachenry,  what industry?
21:08:44 <mmachenry> GeraldCode: Healthcare.
21:09:00 <GeraldCode> Ive heard about haskell being used in missles ?? and finance alot
21:09:06 <GeraldCode> is this healthcare in the US?
21:09:28 <mmachenry> GeraldCode: I think missile launching might just be a community in-joke example.
21:09:30 <benzrf> GeraldCode: i'm sure the us gov considers missiles to be healthcare
21:09:35 <mmachenry> Yes it is.
21:09:53 <GeraldCode> mmachenry,  really? lol
21:10:03 <GeraldCode> I swore I saw that on some official seeming haskell website
21:10:17 <GeraldCode> maybe it was general armed forces
21:10:59 <mmachenry> GeraldCode: Well I know it's *very* often given as an example as a joke in code of when IO can be dangerous. So lots of people write code like "launchMissile :: IO ()" as their example in the slides.
21:11:01 <levi> "launch the missiles" is sort of the canonical "non-benign side effect"
21:11:10 <GeraldCode> lol ok
21:11:13 <mmachenry> I can't say I actually know if it really is or is not used in industry.
21:11:19 <GeraldCode> got it levi , mmachenry
21:11:31 <GeraldCode> don't I feel stupid
21:11:42 <GeraldCode> well congrats on your new gig
21:12:05 <mmachenry> But you see a lot of talks say stuff like "Well STM doesn't allow you to do IO because it can be rolled back. So we want to make sure that we haven't done anything we can't undo, like launch missiles."
21:12:16 <GeraldCode> ah
21:12:20 <GeraldCode> it makes sense now
21:12:29 <GeraldCode> every language has their own little thing
21:12:34 <GeraldCode> this must be haskells thing
21:12:38 <mmachenry> Welcome to the inside of the joke, GeraldCode
21:12:44 <GeraldCode> thanks :)
21:13:38 <GeraldCode> mmachenry, how di you get this job?
21:13:48 <mmachenry> GeraldCode: Craigslist :)
21:13:53 <GeraldCode> oh nice
21:14:10 <mmachenry> I mean we're hiring like crazy and through all different vectors. I just happened to have been looking through CL
21:14:11 * benzrf should go on craigslist
21:14:19 <GeraldCode> so maybe the haskell jobs are increasing
21:14:26 <benzrf> no experience though :[
21:14:26 <mmachenry> Not sure we even post there anymore. We're now big enough that we have hiring ads on the subway.
21:14:46 <mmachenry> GeraldCode: Not sure. This is one sub project that I'm working on where switching language is actually the right call.
21:15:04 <GeraldCode> cool, im not there yet
21:15:07 <mmachenry> But there will be a Haskell job created by this effort, maybe two.
21:15:10 <GeraldCode> which makes me embarresed to say
21:15:16 <GeraldCode> beeen at it a comnbined 5 months or so
21:15:21 <GeraldCode> but Id like a haskell job too
21:15:21 <mmachenry> Embarassed to say you're not where?
21:15:31 <GeraldCode> because I know that is job security for at least another decade
21:15:45 <GeraldCode> not skilled enough to do professional haskell
21:15:50 <GeraldCode> Im not there yet
21:15:59 <savanni> I did a haskell contract in medical billing very early this year.
21:16:03 <mmachenry> Ah. I wouldn't worry about that.
21:16:15 <savanni> It's interesting to hear of another company moving in that direction.
21:16:16 <mmachenry> savanni: Really? Which company?
21:16:28 <savanni> EMR Technical Solutions.  It was a tiny startup.
21:16:51 <savanni> Unfortunately, things didn't work out.  I am probably largely to blame for that since really I got in over my head.
21:16:56 <mmachenry> savanni: I wish I could say moving in that direction. Who knows. Perhaps my efforts will show people that when performance and concurrency are vital that Haskell is a great choice.
21:17:31 <johnw> and sanity
21:17:37 <johnw> (in the face of those two)
21:17:39 <savanni> Indeed!  Haskell is a great choice... unless you're a missile guidance program and need real-time response. :)  (I wanted to say that back in the missile conversation)
21:17:40 <mmachenry> But generally, we do horizontal scaling through more machines and shitty languages are just fine. So I personally believe, actually, that it's only the right choice to move to Haskell for this one small project.
21:18:01 <mmachenry> Moving the company to Haskell in general would be silly since it would require rewriting perfectly good code.
21:18:01 <GeraldCode> mmachenry,  I started because I want to be more sure my code works..are you piutching that too?
21:18:28 <mmachenry> But you know, maybe we'll develop a policy of very vital concurrent apps be written in Haskell.
21:18:33 <GeraldCode> ah you work with big data I imagine..finance
21:18:33 <mmachenry> And have a few sub projects.
21:18:45 <tac_> Is there a std library function for Text for joining a list of texts together with a fixed delimiter?
21:18:56 <joelteon> intercalate?
21:19:07 <tac_> thanks
21:19:10 <tac_> that's it
21:19:15 <joelteon> don't blame you on that one, it's a weird name for sure
21:19:28 <mmachenry> tac_: Do you know hoogle?
21:19:31 <tac_> a little bit
21:19:39 <tac_> mmachenry: it's faster a lot of the time to just ask here
21:19:49 <dolio> @hoogle Text -> [Text] -> Text
21:19:51 <lambdabot> Data.Text intercalate :: Text -> [Text] -> Text
21:19:52 <lambdabot> Data.Text.Lazy intercalate :: Text -> [Text] -> Text
21:19:52 <lambdabot> Data.Text append :: Text -> Text -> Text
21:19:55 <dolio> Hey.
21:19:59 <johnw> hi dolio
21:20:07 <dsturnbull> @hoogle [Text] -> Text -> Text
21:20:07 <lambdabot> Data.Text intercalate :: Text -> [Text] -> Text
21:20:07 <lambdabot> Data.Text.Lazy intercalate :: Text -> [Text] -> Text
21:20:07 <lambdabot> Data.Text append :: Text -> Text -> Text
21:20:15 * dsturnbull boggle
21:20:27 <mmachenry> Alright, good night all.
21:20:32 <mmachenry> I'll see you tomorrow.
21:21:02 <benzrf> > text me
21:21:04 <lambdabot>  Not in scope: ‘me’
21:21:04 <lambdabot>  Perhaps you meant one of these:
21:21:04 <lambdabot>    ‘m’ (imported from Debug.SimpleReflect),
21:21:04 <lambdabot>    ‘e’ (imported from Debug.SimpleReflect),
21:21:04 <lambdabot>    ‘re’ (imported from Control.Lens)
21:21:12 <benzrf> > text "testing testing 123"
21:21:13 <lambdabot>  testing testing 123
21:21:16 <splintax> hoogle is a really neat idea. why did it return Data.Text append though :/
21:21:31 <johnw> it's a fuzzy algorith
21:21:32 <johnw> m
21:21:33 <joelteon> because its type signature is similar to the search
21:21:40 <benzrf> > intercalate (text ", ") (map (text . show) [1..10])
21:21:42 <lambdabot>  Couldn't match expected type ‘[a]’
21:21:42 <lambdabot>              with actual type ‘Text.PrettyPrint.HughesPJ.Doc’Couldn't match t...
21:21:42 <lambdabot>  Expected type: GHC.Base.String -> [a]
21:21:42 <lambdabot>    Actual type: GHC.Base.String -> Text.PrettyPrint.HughesPJ.Doc
21:21:49 <johnw> he has a blog post about the search algorithm it uses for type matching in fact
21:21:54 <benzrf> > Data.Text.intercalate (text ", ") (map (text . show) [1..10])
21:21:55 <dfeuer> @type text
21:21:56 <johnw> or a presentation
21:21:56 <lambdabot>  Not in scope: ‘Data.Text.intercalate’
21:21:56 <lambdabot>  Perhaps you meant ‘Data.List.intercalate’ (imported from Data.List)
21:21:56 <lambdabot> String -> Doc
21:21:59 <benzrf> lame
21:22:05 <benzrf> h
21:22:27 <joelteon> :t T.intercalate
21:22:28 <lambdabot>     Not in scope: ‘T.intercalate’
21:22:28 <lambdabot>     Perhaps you meant one of these:
21:22:28 <lambdabot>       ‘BS.intercalate’ (imported from Data.ByteString),
21:22:34 <joelteon> That's dumb.
21:22:59 <splintax> johnw: cool, checking it out now
21:31:05 <benzrf> is BS.pack O(n), O(2n)
21:31:32 <benzrf> its an interface to c arrays right
21:31:47 <pingu> benzrf: do you mean is it O(n), or O(2n)?
21:32:07 <splintax> isn't O(2n) == O(n)
21:32:52 <pingu> splintax: yes
21:33:02 <pingu> I believe it is.
21:33:17 <d3m1g0d-> yes it is
21:33:20 <d3m1g0d-> since it's an upper bound
21:33:44 <pingu> benzrf: You can think of it like an interface to c arrays if you like
21:33:45 <d3m1g0d-> and constants are ommited
21:33:51 <pingu> it's pretty close.
21:34:03 <pingu> It's stored internally as an array of word8s
21:34:04 <benzrf> splintax: i know, i guess i was informally talking about how many times it traverses the array
21:34:16 <benzrf> that doesnt exactly map to big O
21:34:31 <pingu> benzrf: Yeah, I get what you mean and I think O(n) then
21:34:36 <benzrf> kk
21:34:50 <pingu> basically, take every character out of a list of chars and pack it into an array
21:34:56 <benzrf> how does it know how much space to allocate
21:35:00 <joelteon> bytestring pack is on [Word8]
21:35:10 <pingu> benzrf: I've no idea actually
21:35:48 <pingu> benzrf: you're right, it's O(2n)
21:35:55 <pingu> it needs to traverse twice for the length
21:36:02 <benzrf> ok
21:36:07 <pingu> https://hackage.haskell.org/package/bytestring-0.9.2.1/docs/src/Data-ByteString.html#pack
21:37:40 <d3m1g0d-> pingu:  it's also O(n^15)
21:38:02 <benzrf> orly
21:38:04 <joelteon> why?
21:38:17 <c_wraith> well, yes.
21:38:59 <d3m1g0d-> because it's an upper bound
21:39:06 <d3m1g0d-> everything above an upper bound is also an upper bound.,
21:39:14 <c_wraith> f = O(g(n)) means there exist constants n0 and c such that for all x >= n0, f(x) <= c * g(x)
21:39:33 <joelteon> the upper bound for bytestring's pack operation is O(n), not O(n^15)
21:39:50 <c_wraith> joelteon: Doesn't mean the operation isn't O(n^15)
21:39:54 <solidus-1iver> why are linear's lenses _x instead of x
21:39:54 <enthropy> there is another letter for "tight" upper bounds
21:39:57 <c_wraith> joelteon: it's just *an* upper bound
21:40:07 <c_wraith> tight bounds are theta
21:40:19 <glguy> solidus-1iver: probably because 'x' is far too common a name to claim
21:40:21 <pingu> we totally don't need to have this discussion ;)
21:40:24 <joelteon> if you know the upper bound, "an" upper bound is useless information
21:40:35 <solidus-1iver> glguy: the world makes sense
21:40:38 <c_wraith> joelteon: it's cute that you think "the upper bound" is defined.
21:40:51 <d3m1g0d-> pingu: yea , but if you actually understand the definition you wont say stuff like "Its O(2n)"
21:40:51 <joelteon> thanks, my mom always used to say i was cute
21:40:55 <d3m1g0d-> he constant actually makes no sense.
21:41:03 <d3m1g0d-> thats not "number of comparisons that the algorithm performs"
21:41:13 <pingu> defanor: if you read the discussion we're asking simply how many times it traverses the list
21:41:35 <pingu> and we've established early along that we are abusing O notation for this purpose
21:41:49 <pingu> d3m1g0d-: ^^
21:42:06 <pingu> defanor: disreguard, apologies :)
21:42:13 <defanor> np
21:42:31 <enthropy> you can probably say "n pattern matches on : ", but maybe there's an off-by one?
21:43:15 <c_wraith> anyway..  Hmm.  I guess pack is a case where length is forgiveable.  It's not a use case that can unload values after examining them.  And the alternative approach of doubling an array would have similar cost but allocate more.
21:43:49 <joelteon> guessing that's why, after 12 minor versions, that's still the implementation
21:44:00 <joelteon> oh 10
21:44:04 <joelteon> I'm getting my libraries mixed up
21:44:27 <pingu> I actually read those as major versions
21:44:42 <pingu> are they minor?
21:44:46 <c_wraith> They're major.
21:44:47 <joelteon> well, it's 0.
21:44:53 <c_wraith> A.B is the major version on hackage
21:45:04 <joelteon> oh
21:45:46 <joelteon> so 0.8 -> 0.9 and 0.9 -> 1.0 are both major version changes?
21:45:50 <c_wraith> yes
21:46:01 <joelteon> why is there a dot between the numbers?
21:46:23 <klugez> http://www.haskell.org/haskellwiki/Package_versioning_policy
21:46:39 <c_wraith> Because "major" is defined specifically to mean certain things.  You can have little major changes, or very big major changes.
21:46:59 <joelteon> well that doesn't explain it either
21:47:04 <joelteon> oh, ok
21:47:14 <joelteon> by "that" I mean the wiki page, I came back and typed my response before I saw your message c_wraith
21:47:35 <c_wraith> Like, adding an instance is a major change.
21:47:47 <c_wraith> So is changing half the API.
21:48:22 <joelteon> so it's like "major major version, minor major version, minor version"
21:49:58 <pingu> yeah, this is why i just drop the major major versions and use semantic versioning personally
21:50:12 <pingu> seems too easily misinterpreted.
21:51:23 <solidus-1iver> welllllllll, that is amazing
21:51:33 <centrinia> How do I get Yesod to compress my static files?
21:52:19 <solidus-1iver> i added about 10 modules, rewrote 60% of my code base, added collision, hitbox checking, abstractions for variable world sizes, a gamestate wire that produces a frame, added collection of wires within that and compiled...
21:52:25 <solidus-1iver> first time i ran it, it worked as expected
21:52:34 <joelteon> centrinia, let me get you a link
21:52:42 <solidus-1iver> haskells type system ++
21:53:06 <joelteon> also, centrinia, did you ask in #yesod? I'm usually in that channel, but I wasn't just now
21:53:22 <centrinia> Yeah, no one has responded so far. :p
21:53:26 <joelteon> let's take it there
21:57:47 <benzrf> bye
21:58:52 <joelteon> I hope that doesn't become a regular thing
22:06:31 <Leona21>  Here some videos. I hope you like them! http://bit.ly/1qzcONY
22:06:39 <isomorpheous> @ops
22:06:39 <lambdabot> Maybe you meant: pl oeis docs
22:06:50 <isomorpheous> @help
22:06:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:06:54 <isomorpheous> @list
22:06:54 <lambdabot> What module?  Try @listmodules for some ideas.
22:06:59 <isomorpheous> @listmodules
22:06:59 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
22:07:17 <isomorpheous> Who are the ops here?
22:07:40 <apples> @where ops
22:07:40 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:07:42 <michaelt> @where ops
22:07:42 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:07:59 --- mode: ChanServ set +o copumpkin
22:08:00 <bitemyapp> not that uh, I'm generally apt to defend spam bots
22:08:02 --- mode: copumpkin set +b *!~Leona21@37.221.169.149
22:08:03 --- kick: Leona21 was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
22:08:12 <bitemyapp> but was flagging every single op necessary?
22:08:21 <bitemyapp> either way, I'm sure the vigilance is appreciated.
22:08:28 <c_wraith> bitemyapp: isn't that the point of @where ops?
22:08:39 <bitemyapp> c_wraith: I guess I think of it as being a batsignal for outright abusive, spammy people
22:08:47 <bitemyapp> c_wraith: rather than one-off spam bots.
22:08:53 <bitemyapp> c_wraith: but they're not my norms, so *shrug*
22:09:03 <geekosaur> most of those get hanndled by idoru, but if it misses then it's useful to call for ops
22:09:04 <bitemyapp> dysinger: hi :)
22:09:27 * geekosaur notes that he was in the process of going to bed. also that he forgot to turn sound off... whoops
22:09:45 <dysinger> bitemyapp: !
22:11:16 <tac_> Is there a good, short cheatsheet of Haskell's Core language?
22:11:41 <tac_> ah, as soon as I give up searching, the next link gives me something good
22:11:51 <tac_> http://i.stack.imgur.com/RP6fQ.png
22:15:31 <michaelt> what does dons mean writing " And, not so well known, you can write directly in Core to program GHC." do I write a .core module?
22:16:08 <dmj`> How do I call toLower on a bytestring? I need to make a base16 encoded bytestring lowercase so (encode "m") == "6d" and not "6D"
22:16:15 <michaelt> oh indeed .hcr
22:16:37 <dmj`> caveat: w/o making it a string
22:17:25 <Composition4> interesting. porn-bot on #haskell?
22:18:07 * hackagebot linklater 1.0.0.0 - Write bots for your Slack account, and then go to sleep (because it's so easy and late at night)  http://hackage.haskell.org/package/linklater-1.0.0.0 (hao)
22:18:35 * Composition4 bids Leona21 farewell
22:20:58 <genericpersona> haha, great description
22:21:33 <AleksejsHome> Hi, how to catch (runRWST)? It throws an error
22:21:33 <AleksejsHome> http://vpaste.net/o7d4M
22:22:50 <michaelt> dmj`: Is Data.ByteString.Char0.map toLower going to get everything wrong?
22:23:12 <michaelt> Data.ByteString.Char8.map, rather
22:24:23 <glguy> AleksejsHome: You seem to have applied too many arguments to runRWST
22:24:34 <glguy> runRWST :: RWST r w s m a -> r -> s -> m (a, s, w)
22:25:17 <glguy> (but I think you'll get a new error when you fix that)
22:26:42 <dmj`> michaelt: well data.bytestring.char8 assumes ascii encoding.. I'm formulating an http request, which uses ascii, so it seems OK
22:28:02 <dmj`> michaelt: let me tinker
22:32:11 <dmj`> michaelt: it seems to work, thanks
22:33:09 * hackagebot keystore 0.3.0.0 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.3.0.0 (ChrisDornan)
22:35:32 <Cale> Aleksejs: You seem to be giving way too many parameters to runRWST
22:35:37 <Cale> :t runRWST
22:35:38 <lambdabot> RWST r w s m a -> r -> s -> m (a, s, w)
22:35:44 <zq> (MonadTrans t, MonadReader r m) => MonadReader r (t m) ?
22:36:20 <Cale> zq: Not in general, but you might hope for an instance like that from each monad transformer
22:36:39 <zq> Cale: how not? ask = lift $ ask
22:36:46 <zq> :t lift $ ask
22:36:47 <lambdabot> (MonadTrans t, MonadReader a m) => t m a
22:37:35 <Cale> and local?
22:37:50 <Cale> :t local
22:37:51 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
22:38:07 <zq> ugh
22:38:10 * hackagebot conduit-combinators 0.2.7 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.7 (MichaelSnoyman)
22:38:12 * hackagebot linklater 1.0.0.1 - Write bots for your Slack account, and then go to sleep (because it's so easy and late at night)  http://hackage.haskell.org/package/linklater-1.0.0.1 (hao)
22:38:25 <Cale> Also, that instance, if you provided it in generality like that, would result in overlaps with pretty much everything else
22:38:50 <zq> i am so frkin stuck
22:38:55 <Cale> Remember that when selecting instances, the constraints on the type variables can't be accounted for, since instances might exist in future modules to satisfy them
22:39:13 <Cale> (so you can never rely on an instance not being present)
22:43:14 <Cale> zq: What are you trying to do?
22:43:48 <zq> Cale: ScottyT
22:46:26 <dmj`> zq: can you show code?
22:46:48 <Cale> zq: that's... not really enough information to know how to help you :)
22:48:11 * hackagebot linklater 1.0.0.2 - Write bots for your Slack account, and then go to sleep (because it's so easy and late at night)  http://hackage.haskell.org/package/linklater-1.0.0.2 (hao)
22:48:13 * hackagebot linklater 1.0.0.3 - Write bots for your Slack account, and then go to sleep (because it's so easy and late at night)  http://hackage.haskell.org/package/linklater-1.0.0.3 (hao)
22:48:14 <zq> it's just that i'm trying to encase my app as a monad transformer but it won't listen
22:48:56 <dmj`> what is your app?
22:49:50 <Cale> zq: Is there a particular reason you need it to be a monad transformer?
22:49:59 <Cale> That's the sort of thing which you usually shouldn't try to force
22:50:20 <Cale> If it's *naturally* a monad transformer, go ahead and add an instance, if not, well, usually that's not such a huge deal.
22:50:25 <zq> because monad transformers are the secret sauce to modularity? like mongodb? idfk anymore
22:51:46 <Cale> Monad transformers are overrated. There are very particular cases where they can make things convenient, but in general you're going to want to hide the fact that you're using them from the users of your library anyway.
22:51:47 <glguy> ScottyT will run on top of whatever monad you want it to. You just can't write (without some heavy lifting) a MonadReader instance
22:51:48 <zq> the stack i had in mind for a generalized web app would be ReaderT AppCfg (StateT AppState m) but ScottyT shits all over that
22:51:51 <glguy> but that's OK because you shouldn't need one
22:52:37 <Cale> I'm not sure that polymorphism is really warranted
22:52:39 <zq> glguy: ghci won't stop coming after me for MonadReader (ScottyT Text (MyBadAssT IO))
22:52:57 <glguy> That means you're using "ask" somewhere without lifting it
22:53:05 <zq> well i don't want to lift it
22:53:15 <glguy> It's not a good idea to expose the various MTL transformers, anyway
22:53:19 <zq> it should know how to lift it without needing me to lift $ ask all the time
22:53:36 <glguy> figure out what monad you want under your scottyT, newtype it, write the operations you need
22:53:37 <glguy> and use those
22:53:38 <zq> glguy: what does "expose" mean?
22:53:40 <Cale> also, the base monad for ScottyT needs to be a MonadIO anyway, which means that StateT is a little silly
22:53:48 <Cale> (as you have access to IORefs and such)
22:54:07 <Cale> and I never really bother with ReaderT either -- just use a function parameter
22:54:08 <glguy> MTL is an implementation detail. You shouldn't really see it while writing your web app after you define whatever your monad is
22:54:31 <zq> so i'd need GeneralizedNewtypeDeriving
22:54:48 <glguy> and then write functions like: getMySweetAppConfig :: ScottyT ... YourMonad AppConfig
22:54:52 <Cale> zq: That tends to be very convenient if you're actually going to be using monad transformers, yes.
22:55:47 <Cale> But I would recommend trying just sticking with ScottyM/ActionM and see how the code looks
22:55:53 <glguy> ask and set and put and mtl friends exist to help make it easier for you to define those operations
22:55:56 <allsystemsarego> Cale, so if monad transformers are overrated, what else is state of the art?
22:55:58 <zq> Cale: already did that
22:56:01 <glguy> Also, I suppose Cale's advice
22:56:16 <zq> Cale: there so much lifting going on
22:56:32 <Cale> zq: Adding more monad transformers is only going to make the lifting worse
22:56:48 <glguy> zq: you should only write the lifts one time
22:57:03 <glguy> getTheAppConfig = whatever lifts you need ot get the app config
22:57:39 <zq> glguy: it just feels wrong to have everything camped out in the io monad
22:57:47 <dmj`> zq: if all you're trying to do is persist some state amongst web handlers, you could use an IORef, or switch frameworks.. check out Snap, it uses snaplets for this sort of thing, and loads up the configuration data at the beginning, and makes it accessible via lenses.
22:57:57 <glguy> zq: I'm not talking about IO at all
22:58:23 <zq> dmj`: you said the L word
22:58:33 <zq> dmj`: i can't wrap my head around lenses yet
22:59:26 <Cale> zq: Well, factor out the bits of the web application which don't involve real I/O and define pure functions which handle that stuff. Monad transformers aren't really going to help anything be more pure.
22:59:42 <dmj`> zq: you don't have to master lenses to use Snap
23:00:41 <dmj`> zq: what is your app supposed to do?
23:00:42 <Cale> The stuff which should be going on in ActionM/ScottyM ought to be directly related to the configuration of how the webserver does I/O to manage requests.
23:00:54 <zq> dmj`: it's just crud
23:00:59 <zq> create-read-...
23:01:34 <Cale> Well, then there's very little about your application which isn't I/O
23:01:46 <Cale> so you shouldn't be surprised that a lot of the code involves IO actions
23:02:01 <zq> right now, i have a bunch of functions that c-r-u-d to the database in the form of (a :: *) -> AppM (rettype :: *)
23:02:21 <dmj`> zq: what database?
23:03:34 <zq> then i somehow managed to trim out the monad so the crud functions are instead ConnectionPool m => (a :: *) -> m a
23:03:36 <Cale> allsystemsarego: Good old-fashioned functional programming? Using monads without transforming them? I dunno. If all you're using is ReaderT, or StateT over a monad which already has facilities for state, well, it's questionable that you should be doing that.
23:04:06 <Cale> allsystemsarego: The extra lifting that you need to do will usually be worse than the parameter passing that ReaderT is helping you avoid
23:04:09 <zq> dmj`: i'm using persistent as my data access layer
23:04:21 <Cale> (or in the best case, equivalent to it)
23:05:00 <zq> Cale: were those two last ones for me?
23:05:10 <Cale> zq: Well, kind of also for you
23:05:13 <allsystemsarego> Cale, fair points, I've seen people recommend "free" instead of mtl, and was wondering why
23:05:27 <Cale> zq: allsystemsarego asked what the alternatives to using monad transformers were
23:06:37 <jle`> allsystemsarego: free can be used to make your monads w/ full effects from scratch, instead of acreating them by composing smaller 'effect primitives'...i'm not sure if that's why people recommend it over mtl; i actually haven't heard the two used in direct comparison before
23:06:38 <Cale> Free monads are pretty cool in some cases, particularly if you want to be able to have more than one way to interpret the actions being described.
23:06:56 <jle`> ah yeah.  multiple backends is great :)
23:07:08 <dmj`> zq: so if you're already performing crud operations, what is the MonadReader for?
23:07:24 <dmj`> not the database connection it seems
23:08:11 <zq> dmj`: the app config. it could be that some future variant of crud would require reading the app config.
23:08:44 <Cale> zq: Are you allergic to function parameters? :)
23:09:00 <jle`> if you're juggling multiple effects though, i kind of like the system that mtl sort of sets up.  if you want to write a part that "only errors", or a part that "only has state", or a part that "errors with state", or a part that "only has an environment"...you can mix and match without actaully worrying about the actual monad
23:09:16 <jle`> and then you can assimilate/bring them all into your "big monad" without any extra lifting
23:09:45 <zq> Cale: honestly? function params were the first to go becuase it'd mean passing a param from a function app in main alll the way down to crud
23:09:53 <jle`> if i want something that only errors, without state, i can just do (MonadError e m) => ... or something that errors and reads, (MonadError e m, MonadReader r m) ...
23:10:04 <zq> so, main-some_scottym_controller-crud
23:10:05 <jle`> max and match arbitrarily, without worrying about what `m` actually *is*
23:10:13 <jle`> and m can be your own custom Free...or a stack of transformers...
23:10:22 <jle`> or your own custom ADT...
23:10:26 <Cale> zq: Yeah, but it makes testing simpler, and makes it clear exactly which parts of the application depend on that configuration
23:10:39 <jle`> you can mix and match everything and then have it all be used in your "final giant monad", without explicit lifting
23:10:40 <zq> ugh
23:10:51 <zq> seriously, the more things change, the more they stay the same
23:11:05 <zq> we had this exact problems back in the days of pylons vs. django
23:11:20 <zq> explicit passing vs. a local environment
23:11:55 <Cale> I tend to always come down on the side of explicit passing of function parameters, especially when it's "environment" and not "state"
23:13:35 <Cale> For IO stuff, I've often found that rather than passing an r :: IORef t around, instead passing writeIORef r :: t -> IO () and readIORef r :: IO t around can help you better control access to the state, as well as providing a place to add logging or locking or things like that in the future.
23:14:27 <Cale> (i.e. to add logging of changes to that state, you just pass in an action which writes to the log as well in place of the writeIORef)
23:15:19 <Cale> Or of course you can play around with things like MVar/Chan/SampleVar/etc. if you start using multiple threads.
23:15:29 <Cale> (without changing the interface)
23:16:18 <dmj`> You could use the logging pattern from marlow's book, fork a reader / eval thread, and many writer threads, have the reader block on reading a TChar / TQueue, and the writer's just add stuff to it.
23:17:20 <dmj`> TChar :)
23:18:01 <zq> what's the alternative to GND when deriving mtl instances of a newtype wrapper?
23:18:52 <glguy> writing a couple simple functions by hand
23:19:38 <glguy> You shouldn't be writing instances, you just need the operations specific to your monad
23:20:16 <Cale> (of course, you'll probably want to write the Monad instance still)
23:20:50 <Cale> But the others perhaps not -- usually there are operations more specific to your use case which you'd rather provide rather than the generic "get" and "put" of MonadState for instance
23:21:04 <Cale> at least, in any case where using monad transformers makes any amount of sense
23:21:29 <zq> so if i had newtype zqT r s m a = ZqT ReaderT r (StateT s m) a, i'd have to redefine my own get, put, modify, ask, so forth?
23:22:02 <Cale> yes -- you probably wouldn't want those r and s to be parameters
23:22:04 <zq> Cale: well the primitive ops would ultimately be defined in terms of getputask blah
23:22:10 <Cale> You'd probably have specific types in mind
23:22:20 <zq> right right
23:22:25 <Cale> also, providing a monad transformer rather than just a monad is usually of limited usefulness
23:22:40 <zq> what
23:22:42 <Cale> Usually you'll want to pick a specific m
23:22:53 <Cale> because there's very little that you can do without knowing what m is
23:23:08 <zq> every package i read from hackage uses their own specialT
23:23:12 <Cale> I mean, it's literally just the operations from ReaderT and StateT then
23:23:35 <Cale> Then you're choosing to read somewhat weird packages :)
23:24:42 <allsystemsarego> these days, we're starting to witness the "lensification of hackage"
23:25:04 <mr-> Hey, I am trying to define a type-safe inits using type level Nats: http://lpaste.net/107933 but I can't make sense of the error message it is giving me (or rather, how to fix it)
23:25:24 <Cale> There's a lot of questionable taste surrounding lens as well. Lenses are really cool, but it's super-easy to abuse them for no reason whatsoever.
23:25:46 <glguy> that's just Haskell programming :)
23:25:59 <glguy> tastes vary wildly and evolve per person over time
23:26:57 <Cale> It also doesn't help that lens provides 80 kajillion infix operators which will instantly reduce the readability of your code
23:27:25 <Cale> (relative to the prefix names for the same operations)
23:27:29 <joelteon> there are some operators that lens makes excellent use of, though
23:27:32 <joelteon> like (+=)
23:27:41 <glguy> You'll get no argument from me about the operator proliferation :)
23:28:27 <levi> The operators are questionable, sure, but they follow a reasonable scheme.
23:28:35 <Cale> joelteon: I hate all of those. We're using a functional programming language for a reason -- a single higher-order operation can take the place of all of those.
23:29:07 <MP2E> mr- : That's a pretty dense error message there, but basically it is saying that it can't find a type equality between VecList (IncList n) and VecList ('Zero : Map 'Suc (Reverse (DecList n1)). As for why.. I'll have to look a little more
23:29:14 <dolio> You mean, exactly what lens does?
23:29:30 <Cale> dolio: Yeah, lens even provides this operation
23:29:31 <MP2E> seems to me as though they *should* be equivalent
23:29:46 <Cale> (but it also provides all these needlessly specialised versions that pollute the namespace)
23:30:16 <MP2E> Cale : which function are you referring to? overF? :)
23:30:21 <mr-> MP2E: I thought so too. Is it possible that it is the case, but the compiler just cannot deduce it?
23:30:24 <glguy> All the cool kids stick to Control.Lens.Combinators ;-)
23:30:47 <mr-> MP2E: hmm.. or maybe
23:31:41 <mr-> Inclist n = Zero : Map Suc (Reverse (Declist n-1))
23:32:42 <MP2E> Ahh yeah Map Suc could be confusing it, try that
23:32:58 <dolio> Control.Lens doesn't seem to export all the operators.
23:33:37 <Cale> MP2E: just "over" (along with modify) or (%=) perhaps
23:33:41 <dolio> Unless one of the other modules exports operators.
23:33:54 <Cale> You don't need += if you have %=
23:34:06 <glguy> It exports most of them except for the package specific ones
23:34:52 <Cale> l += 5 can always be written l %= (+5), which uses a couple more characters, but is conceptually much simpler
23:36:10 <glguy> Cale: checkout the header comment for http://hackage.haskell.org/package/lens-4.3/docs/src/Control-Lens-Combinators.html :)
23:36:11 <dolio> glguy: How do they get from Control.Lens.Operators into Control.Lens?
23:36:19 <Cale> glguy: Yeah, I caught that :)
23:36:33 <dolio> It looks like the latter just exports modules.
23:36:35 <glguy> dolio: they aren't defined in Operators
23:37:02 <glguy> They're defined all over the place and reexported from various modules by .Lens
23:37:04 <Cale> dolio: It does the import of Control.Lens hiding all the operators
23:37:28 <dolio> Oh, they're all in Control.Lens.Lens.
23:37:33 <glguy> The Operators module exists so people can import it unqualified
23:37:39 <glguy> but the rest of the library qualified
23:37:53 <dolio> Weird.
23:38:03 <glguy> In case you're hiding some Perl in your code ^_^
23:39:20 <glguy> lens attempts to accommodate various preferences
23:39:59 <dolio> Haddock could be better about reexports, it seems.
23:40:41 <mr-> MP2E: try what? ;-)
23:42:38 <MP2E> the Inclist signature you typed up that that uses Map Succ with n-1 instead of just using Reverse (Declist n)
23:42:47 <MP2E> unless you already did
23:44:47 <Darwin226> Hey guys, is there a way to check if an int is one of the possible values of an enum?
23:47:17 <allsystemsarego> Darwin226, make it an instance of Bounded, then convert the list to a set, then test membership?
23:47:53 <Darwin226> allsystemsarego: What list?
23:48:02 <dolio> glguy: Combinators doesn't even have (<&>).
23:48:05 <dmj`> :t \val int -> fromEnum val == int
23:48:06 <lambdabot> Enum a => a -> Int -> Bool
23:48:06 <dolio> Lame.
23:48:24 <allsystemsarego> Darwin226, [minBound :: YourType .. maxBound :: YourType]
23:48:51 <Darwin226> allsystemsarego: Oh, neat.
23:48:53 <glguy> dolio: It's like a bandaid, just rip it off and you'll feel better straight away
23:49:14 <dolio> (<&>) is useful all the time.
23:49:15 <mr-> MP2E: Could not deduce (Map 'Suc (Reverse (DecList n1)) ~ Map 'Suc (IncList n1)) ...
23:49:32 <dolio> I'd put it in base.
23:50:00 <vlatkoB> hmax, GHC complains 'No instance for (Show a0)...' for "myprint = print", but not for "myprint a = print a" or when there is a signature? Why can't it infer?
23:51:21 <glguy> dolio: I mostly see it used to write opaque code. People can't seen to restrain themselves once they get using it
23:51:42 <glguy> but in moderation, sure :-p
23:51:59 <dolio> It's the Functor version of for.
23:52:08 <glguy> I know what it *is*
23:53:14 <mr-> vlatkoB: http://www.haskell.org/haskellwiki/Monomorphism_restriction here's an explainaition
23:55:20 <vlatkoB> mr-: Thanks, that's it.
