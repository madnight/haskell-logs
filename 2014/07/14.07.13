00:03:23 <lfairy> dfeuer: signed types use logical shifts by default irc
00:03:27 <lfairy> *iirc
00:04:00 <dfeuer> lfairy, signed types definitely do not. They use arithmetic shifts according to the Data.Bits documentation.
00:04:54 * lfairy looks it up
00:05:03 <lfairy> oh, I got logical/arithmetic mixed up
00:05:16 <lfairy> if you use unsigned types, it's a logical shift by default
00:05:37 <lfairy> so simply convert to Word first
00:05:39 <dfeuer> Huh.
00:05:41 <dfeuer> OK.
00:05:46 <dfeuer> Thanks, lfairy.
00:05:51 <dfeuer> Do you know about the masked version?
00:05:51 <lfairy> np :)
00:06:15 <lfairy> not sure about the mask thing
00:06:45 <dfeuer> Also, how *do* you convert between Int and Word?
00:06:52 <lfairy> fromIntegral
00:07:18 <trinity> http://www.nbcnews.com/storyline/texas-family-killings/was-texas-shooting-suspect-ronald-haskell-seeking-vengeance-n153811
00:07:23 <trinity> i knew it, haskell is bad for ya
00:08:04 <lfairy> > fromIntegral ((-1) :: Int) :: Word
00:08:05 <lambdabot>  18446744073709551615
00:08:10 <dfeuer> lfairy, that's weird. I'd've expected fromIntegral to be checked and reject such things.
00:08:31 <lfairy> nah, all fixed length integer types don't check overflow
00:09:18 <cariveri> hey there. can anyone help me uploading documentation to hackage?
00:09:37 * hackagebot HsOpenSSL 0.10.5 - Partial OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.5 (MasatakeDaimon)
00:09:38 * hackagebot HsOpenSSL 0.11 - Partial OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.11 (MasatakeDaimon)
00:10:21 <dfeuer> lfairy, and you're right about shifting words, it appears. Prelude Data.Bits Data.Int Data.Word> (fromIntegral (-1 :: Int)) `shiftR` 60 :: Word
00:10:21 <dfeuer> 15
00:10:43 <lfairy> dfeuer cool
00:24:02 <dfeuer> What module do I need to get the GHC types Word64# and Int64# and their associated primops?
00:33:17 <Cale> dfeuer: GHC.Prim or GHC.Exts
00:34:08 <dfeuer> Cale, I see Int# and Word# and the associated I# and W#, and I see various SSE operations, but I don't see Word64#, Int64#, and whatever their wrapper-constructors are.
00:34:35 <Cale> dfeuer: I dunno, I just tried importing it in ghci, and they seemed to be there
00:35:08 <dfeuer> lfairy, it looks like they actually are masking in GHC, but I don't see anything documenting that.
00:35:23 <dfeuer> Cale, I thought GHCi didn't support unboxed types at all.
00:35:52 <Cale> dfeuer: Sure, it supports pretty much everything that GHC does.
00:36:07 <dfeuer> Oh wait, it's unboxed *tuples*, right?
00:36:17 <dfeuer> (that are not supported)
00:38:06 <dfeuer> Huh. You're right about those things being in GHC.Exts. I didn't see them in the source, so they must be imported somehow I didn't notice.
00:39:34 * hackagebot base-prelude 0.1.1 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.1 (NikitaVolkov)
00:39:42 <lfairy> dfeuer: http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Word.html#g:3
00:39:46 <lfairy> last bullet point
00:40:37 <lfairy> the constructors are in GHC.Int, btw
00:42:49 <platz> I wonder if people would use SIMD if it were available
00:43:24 <platz> sounds kind of like one of those things that people only use for mandelbrot demos and then go back to their regular stuff
00:45:22 <dfeuer> platz, it is available.
00:45:34 <alpounet> platz: for numeric stuffs people tend to want it :)
00:45:56 <platz> oh? without downloading a different branch?
00:46:08 <dfeuer> platz, if you scroll through GHC.Prim, you'll see a bunch of basic stuff, and then *most* of the module is SIMD.
00:46:47 <platz> thats nice.  Got confused by the page on trac that must be a few years old
00:46:57 <alpounet> https://ghc.haskell.org/trac/ghc/wiki/SIMD/Design
00:46:57 <dfeuer> Go to Hackage.
00:47:29 <alpounet> platz: also related, http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf
00:47:32 <platz> might have to experiment with this
00:47:51 <platz> was feeling bad because C# is getting SIMD already
00:48:41 <dfeuer> What unboxed type is C# the constructor for :-?
00:49:05 <platz> hah
00:50:56 <Sculptor> is that a bad thing
00:52:44 <platz> Although I imagine actually writing a numeric lib against this would more involved
00:55:32 <platz> actually that paper is pretty neat.. will spend some time reading it
01:34:17 <merijn> Let's try again: Can anyone tell me what the most accurate/up-to-date description of the STG used by GHC is?
01:39:39 <arancia> What is STG?
01:40:51 <merijn> The Spineless Tagless G machine + language
01:41:14 <merijn> It's the machine model/IR GHC compiles too
01:41:24 <darthdeus> I know I ask about this like every other day, but I still don't understand why is the forall needed in this?
01:41:26 <darthdeus> view :: (forall f. Functor f => (a -> f a) -> (s -> f s)) -> s -> a
01:41:26 <darthdeus> view ln s = getConst $ ln Const s
01:41:51 <merijn> darthdeus: The forall forces the function to work for any functor
01:42:04 <ski> because `view' expects its argument `ln' to be polymorphic
01:42:13 <merijn> darthdeus: Without the forall, the *caller* gets to decide what 'f' is, with the forall the *callee* gets to pick f
01:42:24 <ski> @type let view ln s = getConst $ ln Const s in view
01:42:25 <lambdabot> ((a1 -> Const a1 b1) -> t -> Const a b) -> t -> a
01:42:27 <ski> also works
01:42:48 <ski> but using the above type signature, we *hide* the implementation details from the type
01:42:56 <darthdeus> hmm, still don't understand
01:43:01 <bennofs> darthdeus: if you had view :: Functor f => ((a -> f a) -> (s -> f s)) -> s -> a, then view had to work for any functor
01:43:06 <darthdeus> merijn: so the forall says the function itself and not the caller determines the final type?
01:43:44 <bennofs> darthdeus: so with that signature, I could also do view (id :: (Int -> Maybe Int) -> Int -> Maybe Int)
01:43:54 <darthdeus> oh hmm
01:43:55 <merijn> darthdeus: No, without the forall the type says "give me a function that works for *a* Functor f, and I'll return this"  and then you go "here is a function that only works on Maybe"
01:44:15 <bennofs> darthdeus: but view wants to use Const, so it uses forall to say: the function I pass to view works *for all* functors f
01:44:19 <merijn> darthdeus: The forall makes the type say "give me a function that works for *all* Functor's f, and I'll return this"
01:44:28 <ski> darthdeus : the signature makes it so that `ln :: forall f. Functor f => (a -> f a) -> (s -> f s)', iow `ln' is polymorphic, iow the *user* of `ln' determines what type to use for `f'. but the *user* of `ln' is `view' itself, so it's `view' that determines that
01:45:08 <darthdeus> hmm
01:45:16 <gipp> in other words, the argument functions have to have type (Functor f) => a -> f a -- you CAN'T just use e.g. a -> Maybe a
01:45:23 <gipp> without the forall you could
01:45:25 <ski> darthdeus : if one had attempted what bennofs said, then `view' would have had to be polymorphic, so the *user* of `view', not `view' itself, would then be the one that decided on which `f' to use
01:45:35 <gipp> as long as the functor matched for each arg
01:46:07 <ski> (however, with the given code for `view', bennofs's type signature wouldn't be type correct)
01:46:22 <darthdeus> still confused :( so basically the use of Const would kind of change the signature from "any functor", but giving it the forall it's like saying "the implementation doesn't affect the type"?
01:46:43 <ski> darthdeus : do you understand ordinary (parametric) polymorphism ?
01:47:10 <ski> darthdeus : using the `forall' like that allows us to not expose what actual functor we use, to the caller of `view'
01:47:13 <darthdeus> ski: well i understand it in a way that I use it, but I'm sure you'll come up with something I wont understand :D
01:47:20 <darthdeus> oh
01:47:25 <darthdeus> now that makes sense
01:47:52 <darthdeus> but isn't this a bit of a hack?
01:47:56 <ski> darthdeus : instead of saying "i want to use `Const a'", it says "i want to be able to use any functor", and then secretly it always decides to use `Const a' anyway
01:48:12 <gipp> darthdeus: why a hack?
01:48:28 <darthdeus> gipp: it feels to me a little bit like cheating
01:48:34 <merijn> darthdeus: How so?
01:48:48 <darthdeus> it's saying "give me any functor, but i will just ignore it"
01:49:02 <gipp> darthdeus: the type system is there to serve you. Whatever you need to do to tell GHC how to typecheck, it's all good if it works
01:49:03 <ski> no
01:49:05 <merijn> Now it doesn't
01:49:07 <gipp> you're not ignoring it
01:49:10 <merijn> s/Now/No
01:49:26 <darthdeus> hmm seems that i understood it backwards
01:49:31 <darthdeus> so basically
01:49:35 <gipp> ok
01:49:47 <ski> darthdeus : it's not saying "give me any functor", it's saying "give me the ability to use any functor"
01:49:56 <darthdeus> without the forall i'm saying "I want a function that accepts Const", but with it I'm saying "I want a generic function on any functor, even though I'll only use it with const"
01:50:05 <darthdeus> yeah
01:50:06 <darthdeus> lol
01:50:10 <ski> right
01:50:14 <darthdeus> interesting
01:50:20 <darthdeus> I had it completely backwards in my head
01:50:21 <darthdeus> :O
01:50:27 <ski> it's a form of information hiding
01:50:42 <darthdeus> so using forall I can basically "relax" a type signature of something
01:50:56 <darthdeus> and make it more generic
01:51:00 <darthdeus> even though secretly i'm not using it that way
01:51:04 <ski> not sure what you mean, here ..
01:51:32 <gipp> it's not relaxing the type signature, it's restricting it by only allowing it to take arguments of a more general type
01:51:48 <darthdeus> well without it the first parameter would be (a -> Const a b), but given a forall I can say I just want a Functor and not a Const
01:52:28 <gipp> ok, let's simplify
01:53:02 <bennofs> darthdeus: note that the first parameter is the function ((a -> Const a b) -> t -> Const a b), not just (a -> Const a b)
01:53:18 <darthdeus> bennofs: yeah I didn't want to write the whole thing out :P
01:53:25 <gipp> we have g :: (Functor f) => (a -> f b) -> (a -> f b) -> c, let's say
01:53:40 <gipp> and h :: (forall f. Functor f) => with the rest the same
01:53:58 <bennofs> darthdeus: but putting a forall there doesn't relax anything. It says: I want a function that works for all functors, not just for Const, as an argument
01:54:05 <ski> gipp : the latter can't currently be written
01:54:31 <ski> (and is probably not what you intended)
01:54:38 <darthdeus> bennofs: maybe my word choice of "relax" isn't the best, but yeah what I meant is generalize
01:54:52 <ski> anyway, as gipp said
01:54:54 <ski>   view :: (forall f. Functor f => (a -> f a) -> (s -> f s)) -> s -> a
01:55:08 <ski> is not more generic, but more *restricted* than
01:55:11 <ski>   view :: ((a -> Const a a) -> (s -> Const a s)) -> s -> a
01:55:26 <gipp> because the arguments *must* accept *all* functors f
01:55:34 <darthdeus> ski:  how so? the former works on any functor, the latter only Const
01:55:35 <gipp> without the forall, they can just accept any *particular* functor f
01:55:44 <darthdeus> isn't "all functors" more general?
01:55:48 <bennofs> darthdeus: it's the *argument* that has to work for all functors
01:55:48 <ski> both can be applied to an argument of type `forall f. Functor f => (a -> f a) -> (s -> f s)'. but only the latter can be applied to an argument of type `(a -> Const a a) -> (s -> Const a s)'
01:56:03 <bennofs> darthdeus: so, *you* have to *provide* something which works for all functors
01:56:05 <ski> so the latter can be applied to things of more types than the former, so the latter is more generic
01:56:36 <ski> darthdeus : ok ?
01:56:43 <darthdeus> ok now i'm super confused ... you're saying that (a -> Const a a) -> (s -> Const a s) is more general
01:56:49 <ski> no
01:56:57 <codygman> Is this a horrible way to [(String, String)] -> [(BS, BS)]: map ((C.pack) *** (C.pack)) params ?
01:57:08 <merijn> codygman: Yes
01:57:26 <ski> darthdeus : if `T1' is more general than `T0', then `T1 -> U' is more *restricted* than `T0 -> U'
01:57:27 <merijn> codygman: In fact, any use of Char8.pack is grounds for flogging
01:57:27 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
01:57:45 <bennofs> darthdeus: let's use a simpler example. h :: (forall a. a -> Int) -> Int and g :: (a -> Int) -> Int
01:57:48 <codygman> merijn: What should I do instead?
01:58:01 <gipp> darthdeus: the *arguments* are *required* to be more general. less general arguments are no longer allowed. therefore the overall type is *more* restricted
01:58:07 <merijn> codygman: Data.Text.pack and Text.Encoding.encodeUtf8 (or whatever encoding you want)
01:58:09 <lfairy> codygman: what encoding do you want to use for the strings?
01:58:37 <merijn> Text.pack takes you "String -> Text" and encodeUtf8 takes you "Text -> ByteString"
01:58:38 <ski> bennofs : those aren't directly comparable
01:58:38 <darthdeus> gipp: riiight, that makes sense
01:58:52 <codygman> lfairy: Ascii is all I need
01:59:06 <codygman> merijn: Why specifically is Char8.pack bad?
01:59:17 <darthdeus> ski: yeah I had it backwards again :D
01:59:21 <merijn> codygman: Because it silently drops data
01:59:26 <lfairy> codygman: it fails silently on codepoints > 255
01:59:30 <lfairy> what merijn said
01:59:43 <codygman> merijn, lfairy: Thanks
01:59:51 <lfairy> even if you only need ascii, you should use encodeUtf8 anyway
01:59:52 <darthdeus> bennofs: in my head those two are the same
02:00:28 <ski> darthdeus : `(forall a. a -> Int) -> Int' is very different from `forall a. (a -> Int) -> Int'
02:01:04 <ski> darthdeus : a value of the former type chooses `a' itself. a value of the latter type expects the user/caller to choose `a'
02:01:29 <darthdeus> oh interesting
02:01:37 <darthdeus> so forall means "whatever you give me, I can deal with it"
02:01:38 <gipp> so "g (+)" typechecks, but "h (+)" does not
02:01:49 <gipp> since g is allowed to restrict a, but h is not
02:01:52 <ski> darthdeus : yep
02:02:01 <darthdeus> now it's starting to make sense
02:02:01 <darthdeus> :D
02:02:39 <ski> darthdeus : and if an *argument* type is wrapped in `forall', then it means that the *argument* is promising to be able to deal with any choice the function makes for the argument (it can make more than one choice, if it uses the argument more than once)
02:02:58 <darthdeus> so basically "h" can't accept (+) because the caller can't give it anything else but a function "a -> Int"
02:03:30 <darthdeus> but with "g" that works, since the caller will .. uhm what's the word, "specify" ... the type of "a"
02:03:39 <ski> the caller can't give it anything else but a function of type `a -> Int', polymorphic in `a', yes
02:03:44 <darthdeus> awesome!
02:03:56 <ski> or shorter : can't give it anything else but a function of type `forall a. a -> Int'
02:04:11 <ski> "specify" is fine
02:04:47 <darthdeus> I'm enlightened
02:04:59 <darthdeus> thank you guys
02:05:02 <ski> np
02:05:04 <darthdeus> this channel is the best on all IRC :P
02:06:07 <ski> gipp : i suppose you meant something like `(3 +)' ..
02:06:59 <gipp> ski: indeed i did
02:07:10 <gipp> i have a bad irc habit of typing faster than i think
02:10:00 <merijn> A type can have only one functor instance, multiple applicative instances, but is it possible to have more than one monad instance?
02:10:35 <darthdeus> how can you have multiple applicative instances?
02:11:35 <jle`> darthdeus: [] is a commonly cited example
02:11:51 <gipp> darthdeus: you can't semantically, but if you put a newtype wrapper around it you can
02:12:08 <gipp> darthdeus: it's just a question of whether there are multiple useful ways of implementing applicative for the type
02:12:12 * ski thinks that's a strange use of "semantically"
02:12:21 <gipp> ski: there i go again
02:12:43 <jle`> there are at least two combinations of implementations of (a -> [a]) and ([a -> b] -> [a] -> [b]) that make sense
02:12:47 <jle`> and are lawful
02:13:02 <jle`> but there is only one lawful (a -> b) -> [a] -> [b]
02:13:02 <darthdeus> gidogeek: oh, right
02:13:09 <jle`> oh he left
02:13:14 <darthdeus> -_-
02:13:45 <jle`> merijn: i have asked this before
02:14:05 <jle`> hm
02:14:38 <jle`> well, the infinite list type technically has at least two...but one of them is pretty useless
02:14:44 <teakay> hey guys. wonder if anyone can help me
02:14:56 <jle`> i'm trying to see if that one follows the laws
02:15:04 <jle`> teakay: just ask your question :)
02:16:31 <teakay> i'm trying to create a cookie, using SetCookie from Web.Cookie.  I have the latest version of cookie installed, listed in my cabal build-dependencies, imported in the file, and yet it still tells me the SetCookie  data constructor is not in scope
02:16:42 <jle`> merijn: data Stream a = a :> Stream a ... first instance return x = x :> return x, (x :> _) >>= f = f x ... is this lawful?
02:17:46 <jle`> second instance return x = x :> return x; (x :> xs) >>= f = case f x of (y :> _) -> y :> (xs >>= f)
02:17:57 <ski> jle` : fails `forall ma. ma >>= return = ma'
02:18:04 <ski> (the first instance, i.e.)
02:18:10 <jle`> hm
02:18:15 <jle`> okay let me redo the first one
02:19:47 <jle`> ...it's just supposed to be the same as (>>=) for []
02:19:55 <jle`> but i didn't want to write the helper functions
02:20:05 <jle`> heh
02:22:58 <merijn> Can you even write a monad instance for Stream at all?
02:23:01 <merijn> I'm not sure...
02:23:11 <jle`> well the idea was...to basically diagonalize the streams
02:23:33 <jle`> if each item in the stream is laid along one line
02:23:43 <jle`> the fmapped stream would extend perpendicular
02:23:48 <jle`> and the resulting stream would be the diagonal
02:24:36 <augur_> merijn: lets try!
02:24:45 * hackagebot tropical 0.0.0.2 - A library for tropical mathematics.  http://hackage.haskell.org/package/tropical-0.0.0.2 (pharpend)
02:24:56 <augur_> jle`: yeah, you'd need to diagonalize somehow
02:24:57 <jle`> the diagonal elements
02:25:03 <augur_> the map is easy, but the join isnt
02:25:06 <jle`> so that's i think the standard monad
02:25:13 <jle`> but i'm not sure if you can do the []-like monad
02:25:28 <augur_> but, does the diagonalization satisfy the laws?
02:25:44 <jle`> ...i think johnw told me it did
02:26:10 <isomorpheous> Is there some reason Hackage doesn't show documentation for any of my packages?
02:26:17 <augur_> in a way, IO is a kind of stream
02:26:23 <augur_> that was one of the views of IO for a while i think
02:26:25 <isomorpheous> http://hackage.haskell.org/user/pharpend
02:26:35 <augur_> so we might be able to steal that definition
02:27:06 <jle`> isomorpheous: if it's recently uploaded, it takes a while for the first documentation path
02:27:20 <isomorpheous> jle`: stuff that I uploaded months ago has no documentation
02:27:29 <jle`> isomorpheous: have you checked your build logs?
02:27:40 <isomorpheous> jle`: where do I find those?
02:27:46 <jle`> teakay: is the constructor exported?
02:27:56 <jle`> teakay: can you post some code?
02:27:59 <jle`> for your imports
02:28:56 <jle`> isomorpheous: http://hackage.haskell.org/package/eros-0.5.2.0/reports/
02:29:01 <jle`> ...admittedly not very helpful, sorry :/
02:29:17 <jle`> hm.
02:29:23 <isomorpheous> nothing
02:29:28 <isomorpheous> on semiring-simple
02:29:29 <jle`> you might be able to upload it manually, http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
02:29:39 <isomorpheous> jle`: just reading that
02:30:22 <isomorpheous> jle`: for one of my packages (eros, I think), I put the docs on gh-pages
02:30:28 <isomorpheous> jle`: but that seems stupid
02:30:42 <isomorpheous> jle`: and defeats the point of hackage
02:30:48 <isomorpheous> jle`: or, like 20% of the point
02:31:00 <jle`> :
02:31:03 <jle`> :/
02:31:17 <jle`> do the haddocks build fine locally?
02:31:20 <isomorpheous> yep
02:31:33 <isomorpheous> not full documentation coverage
02:31:39 <isomorpheous> like 70%
02:31:46 <isomorpheous> but it builds fine
02:32:09 <merijn> FYI, the enter key is not a comma
02:32:25 <isomorpheous> merijn: i disagree
02:32:36 <alpounet> isomorpheous: if you want a "definite" answer, check out the github issues for hackage: http://github.com/haskell/hackage-server/issues -- see if there's some issue related to docs not being built, if not create one by giving the right details
02:32:50 <isomorpheous> alpounet: thanks
02:32:53 <alpounet> there's also #hackage
02:33:39 <cariveri> my newly created and uploaded package has got the same problem. no documentation despite successful production by haddock.
02:35:27 <isomorpheous> cariveri: that is probably because hackage hasn't gotten to building it
02:35:43 <isomorpheous> cariveri: but that still doesn't explain why my package from 2 months ago has no documentation
02:37:16 <cariveri> isomorpheous: what do you mean, it hasnt gotten to building it?
02:37:39 <isomorpheous> cariveri: hackage builds documentation en bulk 2 or 3 types per day
02:37:52 <isomorpheous> cariveri: so, if it's super new, it hasn't been build yet
02:38:01 <cariveri> isomorpheous: from yesterday evening
02:38:14 <isomorpheous> cariveri: :/
02:39:44 <cariveri> I rather suspect that either cabal sdist does not include documenation being tuil by haddock, or that if hacke does its own run on building the documentation it might fail to see that it needs an --executables flag, which was necesary on th elocal production.
02:40:35 <ZettaBlade> I've seen so many recent package versions with broken documentation. This is madness.
02:40:51 <cariveri> isomorpheous: but there has been a transition of the hackage version. perhaps something went wrong ther?
02:40:59 <isomorpheous> hm
02:41:00 <MP2E> THIS IS HACKAGE! *kicks ZettaBlade into abyss*
02:41:08 <MP2E> couldn't resist :V
02:41:13 <isomorpheous> you know what we should do
02:41:18 <isomorpheous> start a new site
02:41:25 <isomorpheous> take all the packages from hackage
02:41:45 <isomorpheous> and generate working documentation for them
02:41:51 <isomorpheous> And use better styling
02:42:32 <cariveri> isomorpheous: did you try upload the docs again with this script?
02:42:45 <isomorpheous> cariveri: which script?
02:43:45 <cariveri> the one linked here http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
02:46:13 <isomorpheous> cariveri: didn't work :/
02:47:10 <isomorpheous> http://lpaste.net/107421
02:47:51 <ZettaBlade> Wait, so hackage generates the documentation for every package 2 or 3 times a day?
02:48:06 <isomorpheous> I don't know exactly how it work
02:48:11 <isomorpheous> I think it's just new packages
02:48:25 <isomorpheous> the remainder from the previous batch
02:48:27 <ZettaBlade> Haha I'd hope so
02:48:29 <alpounet> ZettaBlade: no, it just tries to generate them when the package is uploaded
02:48:55 <alpounet> and if it fails, it doesn't retry I think. you can however upload docs manually if hackage failed to generate them.
02:49:29 <isomorpheous>  ,oei
02:49:31 <isomorpheous> ';ra;uaA
02:49:43 <isomorpheous> god dammit
02:49:51 <isomorpheous> my cat walked on the fucking keyboard
02:49:53 <systemfault> isomorpheous: Kill the cat
02:49:57 <systemfault> :P
02:49:59 <isomorpheous> don't buy a cat
02:50:09 <isomorpheous> if you want to get anything done
02:50:56 <jle`> merijn, augur_ : made the implementations http://lpaste.net/107422
02:51:56 <jle`> oh wait i can simplify sDiag
02:52:31 <jle`> ok
02:52:35 <cariveri> alpounet so have you got some news how to upload the docs manually ?
02:52:37 <jle`> now to see if they are both Monads
02:53:45 <cariveri> isomorpheous: I think you missed to rename the docs forlder as described on the page I refered to.
02:54:00 <isomorpheous> cariveri: oh, I just wgot the script
02:54:37 <alpounet> cariveri: just the goold old article on fuuzetsu's blog
02:54:41 <alpounet> good old*
02:54:44 <klrr_> anyone know a project that have a naive (easy to understand) cps converter?
02:54:54 <alpounet> http://fuuzetsu.co.uk/blog/posts/2014-01-06-Hackage-documentation-v2.html
02:54:57 <jle`> return a >>= f = f a passes for both
02:55:19 <klrr_> for some basic "lambda languages" (donno what to call it, i mean the usually "data Exp = blablalb | Lam blabl | App Exp Exp")
02:55:58 <jle`> m >>= return = m does not pass for the one w/ concat
02:56:00 <jle`> darn
02:56:02 <jle`> :|
02:56:05 <jle`> well there goes that
02:56:20 <jle`> it passes for the one with the diagonalization though
03:07:37 <cariveri> isomorpheous: it kind of worked now! but the links are broken, need to fix that with haddock i think.
03:30:32 <tsahyt> Is there a function with a type like [Int] -> Vector a -> Vector a, which takes multiple indexes from a vector, that is a "subvector" defined by the [Int]?
03:31:49 <johnw> I think you would sort the index list and fold down the vector
03:32:43 <johnw> other than that, I don't know of any such "cut across" function
03:33:19 <tsahyt> Hoogle doesn't give me anything with that type either. Well, seems like I'll implement it myself then
03:34:16 <int3__> does anyone else find it a hassle to convert between Lists of Lists and Lists of Maybes? I know of catMaybes and other related functions, but it just seems like there should be some way to abstract flatMap over both types...
03:35:47 <mwhit> depends on what you mean by "convert between", i'm not sure i see the conversion there
03:36:00 <jle`> int3__: well there's Data.Foldable.concat
03:36:06 <jle`> if that helps at all
03:36:16 <jle`> > F.concat (Just [1,2,3])
03:36:18 <lambdabot>  [1,2,3]
03:36:52 <jle`> and then the other way you can do catMaybes
03:37:00 <jle`> :t F.concat `asAppliedTo` Nothing
03:37:01 <lambdabot> Maybe [a] -> [a]
03:37:06 <jle`> :t catMaybes
03:37:07 <lambdabot> [Maybe a] -> [a]
03:37:42 <mwhit> oh, Maybes of Lists, not Lists of Lists
03:37:48 <jle`> :t F.concat `asAppliedTo` []
03:37:49 <lambdabot> [[a]] -> [a]
03:37:49 <int3__> jle` mwhit: I guess I was hoping for some way to generalize concatMap
03:37:51 <mwhit> that makes more sense
03:37:56 <jle`> there is a generalized concatMap i believe
03:37:59 <jle`> :t F.concatMa
03:38:00 <lambdabot>     Not in scope: ‘F.concatMa’
03:38:00 <lambdabot>     Perhaps you meant one of these:
03:38:00 <lambdabot>       ‘F.concatMap’ (imported from Data.Foldable),
03:38:02 <jle`> :t F.concatMap
03:38:03 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
03:38:20 <jle`> so it can be (a -> [b]) -> [a] -> [b]
03:38:28 <jle`> and (a -> [b]) -> Maybe a -> [b]
03:38:53 <jle`> > F.concatMap (\x -> [x, x+1, x+2]) (Just 4)   --?
03:38:54 <lambdabot>  <hint>:1:49:
03:38:54 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
03:39:00 <jle`> > F.concatMap (\x -> [x, x+1, x+2]) (Just 4)   -- ?
03:39:01 <lambdabot>  [4,5,6]
03:39:32 <jle`> Data.Foldable basically has a bunch of functions that lets you treat Maybe's as if they were lists of 0 or 1 elements...and generalizes many list functions to that
03:39:33 <int3__> yeah, but that doesn't handle lists of maybes
03:39:42 <int3__> I mean, it should be something like (Monad m) => (a -> m b) -> t a -> [b]
03:39:53 <int3__> but that probably doesn't generalize beyond Lists and Maybes
03:40:09 <jle`> you want to treat [Maybe a] as if it were [a] ?
03:40:15 <jle`> er, [[a]] ?
03:40:19 <int3__> yup
03:41:36 <mwhit> :t (catMaybes .)
03:41:37 <lambdabot> (a -> [Maybe a1]) -> a -> [a1]
03:41:44 <mwhit> what's wrong with that?
03:42:04 <jle`> int3__: do you want a Foldable f => (a -> f b) -> [a] -> [b]
03:42:07 <cariveri> isomorph1smes: now it works even better. fixed the links now.
03:42:29 <jle`> so it would unify with both (a -> Maybe b) -> [a] -> [b], and (a -> [b]) -> [a] -> [b]
03:42:51 <int3__> jle`: ahh yes
03:43:09 <int3__> that seems to be what I was (trying to) think of
03:43:20 <int3__> @hoogle Foldable f => (a -> f b) -> [a] -> [b]
03:43:22 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
03:43:22 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
03:43:22 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
03:45:06 <jle`> hm i don't see anything like it in Data.Foldable, sorry
03:45:30 <int3__> yeah, I find myself switching between mapMaybes and concatMaps as I refactor my code, so I thought there should've been something like that in a library.. but apparently not
03:45:37 <jle`> you can write your own
03:45:50 <int3__> thanks for helping me clarify my thoughts though. I was confused about what type I actually wanted.
03:46:11 <jle`> :t \f xs -> concatMap (F.toList . f) xs
03:46:11 <lambdabot> Foldable t => (a -> t b) -> [a] -> [b]
03:46:41 <jle`> @let concatMap2 f xs = concatMap (F.toList . f) xs
03:46:43 <lambdabot>  Defined.
03:46:49 <grn> Hi! I'm trying to do exercise 3 from http://www.seas.upenn.edu/~cis194/hw/05-type-classes.pdf and don't know how to approach it.
03:47:19 <jle`> > concatMap2 (\x -> guard (even x) >> Just (x `div` 2)) [1..10]
03:47:20 <lambdabot>  [1,2,3,4,5]
03:47:32 <jle`> > concatMap2 (\x -> [x,x+1,x+2]) [1..10]
03:47:34 <lambdabot>  [1,2,3,2,3,4,3,4,5,4,5,6,5,6,7,6,7,8,7,8,9,8,9,10,9,10,11,10,11,12]
03:48:29 <int3__> jle`: got it, thanks :)
03:48:34 <grn> I think the solution will look like" class Expr a where lit :: a -> ???   add :: ??? -> ??? -> ???    mul :: ??? -> ??? -> ??? where ??? is the expression type. However I don't know what type it should be.
03:49:34 <jle`> grn: what was your type signature of Lit ?
03:49:54 <jle`> grn: also, are you familiar with how type constraints and type classes work?
03:50:45 <grn> jle`, Lit :: Integer -> ExprT
03:51:11 <jle`> grn: so now, you want to generalize over all "ExprT-like things"
03:51:28 <jle`> which is represented by the typeclass Expr
03:51:55 <jle`> can you say. lit :: Integer -> somethingintypeclassexpr ?
03:51:58 <grn> jle`, ok, I think I know what I did wrong. Let me try again ...
03:52:56 <jle`> oh, i forgot, you are defining the methods, so you don't need to put any constraints
03:53:44 <jle`> Lit says "give me an Integer and I'll give you an ExprT".  now, you are defining a new typeclass, Expr, which says, for each instance, "i have a method lit, that says give me an Integer and I'll give you back an item of this instance"
03:53:50 <jle`> ...hope that makes sense >.<  i should be off to bed :)
03:53:52 <jle`> good luck!
03:54:56 * hackagebot definitive-base 1.2.1 - The base modules of the Definitive framework.  http://hackage.haskell.org/package/definitive-base-1.2.1 (MarcCoiffier)
03:56:17 <grn> jle`, done. Thanks for help! My initial attempt was to construct a type class that can handle arbitrary values, not only Integers, and wrap them in an arbitrary expr type.
03:56:35 <grn> btw, is it possible to extend this type class to, lets say, matrices?
03:57:00 <jle`> grn: "extend"?
03:57:29 <jle`> well, your typeclass is anything that can implement lit, add, and mul
03:57:36 <jle`> so...if you have a Matrix type
03:57:45 <jle`> and your Matrix type can implement all of those
03:57:47 <jle`> then yeah :)
03:59:27 <jle`> off the top of my head, if your type is an nxn matrix, lit n = i * (3x3 identity matrix)...and i'll leave to think of what add and mul can be ;)
03:59:47 <jle`> *leave you
04:01:56 <grn> jle`, thanks for help!
04:02:45 <jle`> grn: np :)
04:04:57 * hackagebot Grow 1.1.0.1 - A declarative make-like interpreter.  http://hackage.haskell.org/package/Grow-1.1.0.1 (MarcCoiffier)
04:09:14 <Jeanette21>  Here some videos. I hope you like them! http://bit.ly/1rihPY0
04:16:44 <bennofs> @where ops
04:16:44 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
04:17:02 <bennofs> oh sorry, already left.
04:17:28 <Cale> Yeah, those bots have been doing that for days now, and they usually get k-lined
04:19:58 * hackagebot Grow 1.1.0.2 - A declarative make-like interpreter.  http://hackage.haskell.org/package/Grow-1.1.0.2 (MarcCoiffier)
04:35:00 * hackagebot Grow 1.1.0.3 - A declarative make-like interpreter.  http://hackage.haskell.org/package/Grow-1.1.0.3 (MarcCoiffier)
04:40:00 * hackagebot shadowsocks 1.20140713 - A fast tunnel proxy that help you get through firewalls  http://hackage.haskell.org/package/shadowsocks-1.20140713 (rnons)
05:00:39 <Flonk> Does anyone in here know about a good introduction to quantum computing? Usually half of the articles I find on the web are like "Quantum Computers do everything at once hurr Schroedingers Cat durr" and the other half are about Hermitian, traceless Pauli matrices and I don't get them at all.
05:00:45 <Flonk> I'd really like to get into the topic!
05:06:52 <nexx> Flonk I haven't tried it but maybe http://qcplayground.withgoogle.com/#/home
05:08:09 <dagle> Flonk: MIT have an open course on it, http://ocw.mit.edu/courses/mathematics/18-435j-quantum-computation-fall-2003/
05:08:19 <dagle> Though it's a bit old
05:09:30 <Flonk> dagle: Oh, that's cool! I'll give it a read.
05:10:12 <Flonk> nexx: Hmm, I'll check it out! The example looks pretty much like a regular program
05:11:18 <rkday> What's the best Haskell HTTP microframework? I'm looking for the equivalent of Sinatra in Ruby - something to just do HTTP parsing and route dispatch for a JSON API - whereas Yesod seems more like the equivalent of Rails. Has anyone used Happstack or Snap for this?
05:14:16 <Nimatek> rkday: scotty
05:19:41 <rkday> Nimatek: Thanks! Trying it now.
05:25:04 <ph88> how can i do two pattern matching while using let ?
05:25:12 <ph88> i noticed the second time i use let it removes the first time
05:25:37 <klrr_> what you mean?
05:26:05 <ph88> http://learnyouahaskell.com/syntax-in-functions
05:26:19 <ph88> let lucky 7 = "LUCKY NUMBER SEVEN!"
05:26:29 <ph88> let lucky x = "Sorry, you're out of luck, pal!"
05:26:40 <klrr_> are you working in the repl?
05:26:49 <ph88> yes ghci
05:26:53 <klrr_> because it will redefine lucky the second time
05:27:02 <klrr_> do this instead:
05:27:31 <klrr_> let lucky x = case x of { 7 -> "blablabl"; _ -> "blablalbba" }
05:27:58 <klrr_> (i dont usually use brackets so might not be syntatically correct, but you get what i mean at least)
05:28:58 <ClaudiusMaximus> ph88: or,  let lucky 7 = "lucky" ; lucky x = "sorry" -- if you want to stick to pattern matching function definition syntax - the main thing is you have to define all the cases at once, otherwise you shadow the previous definition in ghci
05:31:46 <twanvl__> you can also use multiple lines with :{
05:31:49 <twanvl__> :{
05:31:49 <twanvl__> let lucky 7 = "yay"
05:31:50 <twanvl__>     lucky _ = "boo"
05:31:50 <twanvl__> :}
05:37:24 <rio> twanvl__: as a bonus, you seem to start sad :{ and then end up happy after defining lucky :}
05:40:06 * hackagebot cabal-bounds 0.7 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.7 (DanielTrstenjak)
05:44:13 <ph88> good suggestions guys, thx
05:46:58 <ski> ph88 : `let lucky 7 = "yay"; lucky _ = "nay"' will also work
05:47:34 <ski> (oh, ClaudiusMaximus already said)
05:48:14 <ph88> i like that one the best, unless really long ones then twanvl__
05:53:19 <klrr_> i wish you could easily use haskell on android
05:53:36 <ski> oh, it's a twanvl__
05:54:25 * ski shirks
05:55:10 <klrr_> this might seem like a stupid question, but: anyone know what program to write? i wanna practice but my current project is just too difficult to finish
05:56:17 <ski> klrr_ : if you want a simple math problem, you could implement the inverse of Euler's totient function
05:56:49 <ski> perhaps you wanted some suggestion for a larger thing, though
05:57:03 * ski can't recall how much Haskell klrr_ knows
05:57:33 <klrr_> i know the basics
05:58:41 <ski> IRC bots seem to be popular to write
05:59:02 <klrr_> already written like two irc bots :P
05:59:17 <klrr_> googling that math function
05:59:50 <ski> <https://en.wikipedia.org/wiki/Euler's_totient_function>
06:00:37 <ski> this is a quite interesting function in number theory and finite algebra
06:00:48 <ski> in some cases, inverting it can be useful
06:01:30 <ski> for any given `k', there may be any number (including zero) of `n's satisfying `phi(n) = k'
06:01:55 <ski> so the problem then is to compute all of the `n's, given a `k'
06:02:03 <ski> (in a list, or a set, or however you please)
06:03:06 <ski> it can be used to decide question twelve at <http://cl.ly/image/2y003O2B113F>, which someone mentioned somewhere, yesterday
06:03:38 <klrr_> so many new words
06:03:45 * ski notes a Zekka
06:04:11 <klrr_> phi is the function itself?
06:04:16 <ski> yes
06:04:18 <klrr_> okey
06:04:31 <ski> klrr_ : basically, `phi' is defined like
06:04:35 <ski>   phi(1) = 0
06:05:01 <ski>   phi(p^n) = (p - 1) * p^n  <=  prime(p)
06:05:20 <ski>   phi(a*b) = phi(a)*phi(b)  <=  gcd(a,b) = 1
06:05:48 <klrr_> i dont get what it's useful for
06:05:58 <ski> er, sorry, the middle equation should be
06:06:04 <ski>   phi(p^{n+1}) = (p - 1) * p^n  <=  prime(p)
06:06:13 <ski> (`n' a natural number)
06:06:25 <ski> klrr_ : do you know modular arithmetic ?
06:07:10 <klrr_> no
06:07:34 <ski> well, let's say we number the days of the week from `0' to `6'
06:08:12 <ski> and we define addition on them, except that if the result is over `6', we subtract `7' until it's between `0' and `6' again
06:08:16 <ski> and similarly for multiplication
06:08:53 <ski> or, instead we could take the hours from `1' to `12', and subtract (or add) twelve to results until they fit in that interval again
06:09:00 <ski> that latter is sometimes called "clock arithmetic"
06:09:31 <ski> we say that "`1' is congruent to `13', modulo `12'", and we write that as `1 = 13 (mod 12)'
06:09:31 <klrr_> okey
06:09:44 <ski> this is e.g. use in the RSA cryptographic algorithm
06:10:42 <klrr_> ?src mod
06:10:42 <lambdabot> Source not found. Are you on drugs?
06:11:01 <ski> consider again integers modulo `7'. if we subtract or add `7' enough times to make a result into the (integer) interval from `0' to `6', we say that we have reduced the result to principal form
06:12:35 <ski> now, even though we're only considering integers, we can often now perform more divisions (exactly) that we could otherwise
06:13:23 <ski> e.g. since `6 * 6 = 36 = 35+1 = 5*7+1 = 1 (mod 7)', we know that `1 / 6 = 6 (mod 7)'
06:13:28 <ski> so `6' is its own inverse
06:13:53 <ski> this is perhaps not so surprising, since `6 = -1 (mod 7)', and `-1' is always invertible, and is its own inverse
06:14:24 <ski> it turns out that, modulo `7', all numbers except `0' are invertible
06:15:06 <ski> (and when i say "all numbers except `0'", i also exclude numbers like `-7',`7',`14', which are multiples of `7', and therefore congruent to `0', modulo `7')
06:15:59 <ski> however, if we pick some other modulus instead of `7', it might be that only some of the numbers are invertible
06:16:08 <ski> e.g., modulo `6', only `1' and `5' are invertible
06:16:36 <ski> klrr_ : now, modulo `m', the number of invertible numbers are `phi(m)'
06:18:11 <wjw_> Can one try a floating divide and catch overflow and zerodivide?
06:18:20 <ski> one can think of modulo arithmetic as having a cirle of numbers spaced out at even intervals
06:18:42 <klrr_> > 24 `mod` 24
06:18:44 <lambdabot>  0
06:18:54 <klrr_> > (24+2) `mod` 24
06:18:56 <lambdabot>  2
06:19:04 <klrr_> > (24-24) `mod` 24
06:19:06 <lambdabot>  0
06:19:09 <klrr_> > (24-25) `mod` 24
06:19:10 <lambdabot>  23
06:19:16 <klrr_> okey i think i get how it works
06:19:18 <ski> in Haskell  n `mod` m  computes the principal residue/remainder for `n', modulo `m'
06:19:54 <ski> in terms of Haskell, `a = b (mod m)' means :  a `mod` m == b `mod` m
06:20:28 <ski> mathematically, `a = b (mod m)' means that there is some integer `k' such that `a = b + k*m', or equivalently, such that `a - b = k*m'
06:20:45 <ski> so the differene between `a' and `b' must be some multiple of `m'
06:20:58 <ski> if so, we consider `a' and `b' to be equal, in modular arithmetic
06:21:37 <ski> another way to state is is : `m | (a - b)' to be read as "`m' (evenly) divides `a - b'"
06:22:03 <ski> we can treat equations `a = b (mod m)' almost like ordinary equations
06:22:25 <wjw_> > 1.0 / 0.0
06:22:27 <lambdabot>  Infinity
06:22:54 <ski> e.g., we can try to find roots `x' of equations like `x^2 = -1 (mod 10)'
06:23:05 <wjw_> > 0.0 / 0.0
06:23:07 <lambdabot>  NaN
06:23:26 <ski> @type isInfinite
06:23:26 <lambdabot> RealFloat a => a -> Bool
06:23:27 <ski> @type isNaN
06:23:27 <lambdabot> RealFloat a => a -> Bool
06:23:51 <wjw_> @type (/)
06:23:52 <lambdabot> Fractional a => a -> a -> a
06:24:47 <ski> in the equation above, there is actually a square root of `-1', modulo `10' (can you find it ?)
06:25:23 <wjw_> Exhaustive search will find it.
06:25:26 <ski> yes
06:26:21 <wjw_> Normalize -1 mod 10, you have 9
06:26:26 <wjw_> sqrt 9 is 3.
06:26:36 <ski> that's one of the roots, yes
06:28:11 <ski> klrr_ : one potentially interesting question, for arithmetic modulo some `m', is whether there is some number, which if you add it to itself enough times, can generate *all* the numbers (module `m')
06:28:11 <wjw_> > 64 `mod` 10
06:28:13 <lambdabot>  4
06:28:28 <ski> klrr_ : any idea of an answer to that ?
06:28:57 <wjw_> Another root is 7.
06:29:02 <ski> yep
06:29:40 <ski> note that `-3 = 7 (mod 10)', so the two square roots `3' and `7' (of `-1' here) are the negatives of each other
06:30:30 <klrr_> ski: 1?
06:30:46 <wjw_> Is there an interesting modular arithmetic for complex numbers?
06:32:54 <klrr_> :t contramap
06:32:55 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
06:33:19 <klrr_> > contramap (-1) [2,3,4]
06:33:21 <lambdabot>  Could not deduce (Data.Functor.Contravariant.Contravariant [])
06:33:21 <lambdabot>    arising from a use of ‘Data.Functor.Contravariant.contramap’
06:33:21 <lambdabot>  from the context (GHC.Num.Num (a -> b), GHC.Num.Num b)
06:33:21 <lambdabot>    bound by the inferred type of
06:33:21 <lambdabot>             it :: (GHC.Num.Num (a -> b), GHC.Num.Num b) => [a]
06:33:59 <ski> klrr_ : yes, that's the obvious answer
06:34:05 <ski> it always works, for any `m'
06:34:19 <ski> klrr_ : will `0' ever work ?
06:34:35 <klrr_> no
06:34:42 <ski> wjw_ : otoh, note that modulo `6', there's only one square root of `3'
06:35:01 <ski> wjw_ : and sometimes there's more than two square roots
06:35:14 <wjw_> I see.
06:35:20 <ski> klrr_ : right. except when `m = 0' (then `0 = 1 (mod m)', so `0' is the same as `1' there)
06:35:39 <ski> klrr_ : er, sorry, i meant, `m = 1'
06:35:47 <wjw_> Modulo 0 is an extremely uninteresting regime.
06:35:48 <ski> (`m = 0' is possible, but different)
06:36:30 <ski> klrr_ : anyway, except from `0', which only works for `m = 1', does any other number work as a *generator* ?
06:36:51 <wjw_> Generator of what, by what interpretation?
06:37:10 <ski> in that every number can be generated, by adding the generator enough times to itself
06:37:24 <klrr_> i dont know
06:37:33 <wjw_> -1
06:38:21 <ski> klrr_ : how about `m = 9' ?
06:38:33 <wjw_> Any number that doesn't divide the modulus.
06:38:43 <ski> we know `1' is a generator : 0,1,2,3,4,5,6,7,8,0,1,...
06:38:54 <ski> how about `2' ?
06:39:08 <klrr_> nope
06:39:12 <ski> well : 0,2,4,8,1,3,5,7,0,2,4,...
06:39:17 <ski> seems to work fine
06:39:23 <klrr_> eh
06:39:27 <klrr_> okey
06:39:36 <ski> `3' ?
06:40:04 <wjw_> Not for mod 9.
06:40:32 <ski> (i started from `0' because the "empty sum" is zero. however, if you don't like that, we'll eventually reach zero again, anyway)
06:40:44 <ski> right : 0,3,6,0,3,6,0,3,...
06:40:46 <klrr_> 0,3,6,9,4,7
06:41:01 <ski> klrr_ : now you're considering modulo `10', not modulo `9'
06:41:11 <klrr_> okey
06:41:11 <ski> hm, no
06:41:31 <klrr_> yeah
06:41:40 <wjw_> I think the general rule is that a number that divides the modulus is not a generator, and all other members are generators.
06:41:47 <klrr_> (i know its wrong, my math is shitty)
06:41:48 <ski> that's modulo `11', actually, and it's mssing the `1' between `9' and `4'
06:42:00 <ski> wjw_ : close, but not quite
06:42:14 <int3__> wjw_: try 6 :)
06:42:17 <ski> wjw_ : modulo `9', `6' is not a generator. `6' doesn't divide `9'
06:42:48 <ski> wjw_ : but you were on the right track
06:42:48 <wjw_> I think the factoring into primes might tell us something.
06:43:16 <ski> what matters is whether the modulus, and the purported generator, has any common factors (aka divisors), apart from `1'
06:43:42 <ski> the greatest common divisor of `9' and `6' is `3', not `1'
06:43:45 <ski> > gcd 9 6
06:43:46 <wjw_> This reminds me of gears.
06:43:47 <lambdabot>  3
06:44:01 <ski> wjw_ : yes :)
06:45:10 <kqr> i feel like this should be really obvious, but i just don't get it... how do i convert MarkupM to Html in blaze-html? or don't i do that?
06:45:11 <ski> this is also related to the number of years various cikada lie hidden in the earth before emerging to eat and mate
06:45:25 <wjw_> Designers of gear trains don't want any two meshing gears to mesh such that a given tooth of one gear eventually goes in each intertooth notch of the othe gear.
06:45:39 <wjw_> I mean they do want that.
06:46:39 <ski> yep, to even out strain/wear
06:47:30 <ski> <http://www.cicadamania.com/cicadas/cicadas-and-prime-numbers/>
06:47:48 <klrr_> anyone know a program to write? my current project is to difficult for me to finish, it would be fun if i could apply some more "advanced" (at least advanced for me personally) haskell to learn
06:48:02 <kqr> yeah, it was really obvious... Html *is* MarkupM ()
06:48:03 <wjw_> And I guess the benefit with the cicadas is to reduce the  chances of having to compete for food with another group frequently?
06:48:25 <ski> well, predators as i understood it. possibly what you said as well
06:49:45 <ski> klrr_ : anyway, the generators modulo `m' is exactly the invertible elements modulo `m', so there are therefore `phi(m)' generators modulo `m'
06:50:07 <wjw_> So for example, there's a famous 17-year cicada species.  If they came out every 16 years, how would they be more vulnerable?
06:50:20 <ski> and `n' is invertible modulo `m', iff `gcd m n = 1'
06:51:00 <ski> wjw_ : a predator with a four-year cycle could lock-step with that, and hit the cikadas with greater number every time they emerge
06:51:02 <klrr_> phi(m) is the number of generators, or a set of them?
06:51:08 <ski> the number of them
06:51:14 <klrr_> okey
06:51:29 <ski> now, i was only talking about *additive* generators, above
06:51:55 <ski> one could also think about multiplying an element with itself over and over, and see which elements can be generated
06:52:32 <ski> it turns out that starting from a non-invertible element is a bit boring
06:53:41 <wjw_> Is it a general rule in Haskell that every primitive function is defined over the full set of possible argument values implied by the declared type of the parameter?
06:54:25 <wjw_> > (/) 1.0 1.0
06:54:26 <lambdabot>  1.0
06:54:44 <kvanb> wjw_: there is not many rules for floating point right now
06:55:00 <kvanb> floating point support in ghc is basically just barebones or completely broken
06:55:02 <ski> consider modulo `12', and let's start multiplying `2' by itself
06:55:21 <ski>   1,2,4,8,4,8,4,8,...
06:55:54 <ski> after some initial cruft, we get stuck in a cycle, not reaching back to `1' at all (`1' being the "empty product")
06:56:23 <ski> this happens for all non-invertible elements
06:57:07 <ski> so, it makes sense to restrict attention to only the invertible elements
06:57:24 <ski> and ask which (invertible) elements can be used to generate the rest of them
06:57:37 <wjw_> I suppose that in mod 12, if you start with any number and proceed by doubling your previous number, you'd end up in a loop of size 2.
06:58:14 <klrr_> anyone know a good practice project?
06:58:18 <ski> yeah, but what i was doing here was `1,g,g^2,g^3,g^4,...', not `1,g,g*2,g*2^2,g*2^3,...'
06:59:15 <heatsink> Have you seen Project Euler, klrr_?
06:59:27 <klrr_> yes
06:59:29 <klrr_> not my thing
06:59:37 <ski> consider modulo `10'
06:59:47 <ski> we get
06:59:56 <ski>   1,0,0,...
07:00:05 <nys> klrr_: this might be a bit too small for your scope, but i recently wrote a program that takes a small phrase and generates a table by "adding" that phrase to itself
07:00:05 <ski>   1,1,1,...
07:00:06 <heatsink> Another practice project for learning a programming language is to write a ray tracer
07:00:19 <ski>   1,2,4,8,6,2,...
07:00:30 <ski>   1,3,9,7,1,...
07:00:46 <wjw_> Write a self-rep.
07:00:56 <ski>   1,4,6,4,...
07:00:59 <klrr_> wjw_: what's that?
07:01:00 <ski>   1,5,5,...
07:01:08 <ski>   1,6,6,...
07:01:18 <wjw_> klrr_, a program that produces its own source code as output.
07:01:20 <ski>   1,7,9,3,1,...
07:01:20 <osfameron> heatsink: that sounds rather more involved than most practice projects...
07:01:26 <ski> klrr_ : aka a Quine
07:01:56 <wjw_> So for example in the Bourne shell language, an empty file is the shortest quine.
07:02:00 <ski>   1,8,4,2,6,8,...
07:02:08 <ski>   1,9,1,...
07:02:30 <ski> the only numbers that loop back to `1' are `1',`3',`7',`9', the invertible elements
07:02:48 <ski> and of those, only `3' and `7' generates all the invertible elements
07:03:06 <heatsink> Well, it is one of the practice projects I did for myself.
07:03:35 <ski> (invertible) elements which (multiplicatively) generate all the (invertible) elements are called "primitive roots"
07:03:35 <heatsink> it has the advantage that seeing pretty pictures come out is rewarding
07:03:49 <trap_exit> good morning,
07:03:50 <trap_exit> wait ....
07:03:54 <trap_exit> this is not #ghcjs
07:03:56 <klrr_> maybe im not suited for programming, because none of these problems seem to trigger any interest
07:04:16 <ski> this amounts to saying that there's a solution `k' for `g^k = n', for an invertible element `n' and a primitive root `g'
07:04:30 <wjw_> klrr_, what areas of math or logic or application thereof draw your interest?
07:04:43 <ski> or, in other words, the primitive roots are the bases one can compute the *logarithm* wrt !
07:05:26 <ski> it's a fun fact that if there's any primitive roots for modulus `m' at all, then there are `phi(phi(m))' of them
07:06:04 <ski> klrr_ : btw, regarding whether `phi(m)' was the count or the set, usually it's the count, but i think one could construe it as the set as well
07:06:10 <osfameron> heatsink: yeah, that's true.  I wouldn't even know how to begin with the maths though
07:06:26 <osfameron> I did once copy out a ray-tracing program from a magazine
07:06:44 <klrr_> mjo: i barely know math and i know zero stuff related to logic
07:06:54 <osfameron> (it didn't work.  I didn't understand it well enoguh to fix.  That, and the internet, is why nobody ever copies programs out of magazines any more :D)
07:06:56 <klrr_> s/mjo/mjw_ sorry
07:07:13 <wjw_> Simulate simple quantum-mechanical experiments regarding the spin on the electron.
07:07:31 <heatsink> osfameron: Have you learned vectors in school?  Like, dot products and rotations?  That was in one of my calculus classes.
07:07:53 <heatsink> You can work out how to ray trace using that.
07:08:04 <osfameron> heatsink: yeah, I'd forgotten all about it though (but revised it doing ai-class, up to a point)
07:08:41 <wjw_> Computer programming is applied math.
07:08:50 <wjw_> All you can program is logic and math.
07:08:52 <ski> in that case, `logBase :: Phi (Phi (Mod m)) -> Phi (Mod m) -> Mod (phi m)', or something like that
07:08:55 <osfameron> yeah.  but mostly it's applied symbolic maths
07:09:23 <osfameron> all the geometric stuff is something that most programming doesn't really touch, so that part of maths atrophies
07:09:38 <osfameron> (I pick up basic trig once every couple of years, but mostly only for personal projects)
07:10:23 <wjw_> exp(i theta) = cis theta; that's all trig in one formula.
07:10:59 <ski> klrr_ : there are many different kinds of programming problems. it's hard for us to determine what you'd be interested in
07:11:37 <wjw_> The only class of programming problem that I can think of as departing from math and logic is AI.  Try to build a machine that learns.
07:11:51 * ski tends to think math and logic is often fun. YMMV
07:12:03 <`Jake`> You need lots of math in machine learning
07:12:13 <heatsink> Yes
07:12:36 <klrr_> gonna google what logic is
07:12:52 <heatsink> A big class of machine learning problems are linear algebra.
07:13:02 <wjw_> Something I haven't grasped about logic is, why do logicians talk about more than one logic.
07:13:40 <`Jake`> Because some are more simple and some are more complicated. It's easier to handle the simpler ones, but for some problems, they are not expressive enough, so you need something more complex
07:13:52 <klrr_> meh its a lot of things
07:15:14 * hackagebot arithmoi 0.4.1.1 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.4.1.1 (DanielFischer)
07:15:54 <heatsink> It's also disputable how to assign a truth value to some kinds of statements
07:16:23 <heatsink> Different logics deal with them in different ways
07:16:56 <wjw_> OK, I can sort of see the value in studying more than one way to deal with wonky statements.
07:17:54 <pjdelport> wjw_: Different logics can have different strengths and complexities, like different type systems.
07:18:06 <nys> ooooh
07:18:35 <wjw_> + I heard that fuzzy logic seems to make smoother train control than engineered solutions.
07:23:39 <wjw_> Thanks for the conversations; I'm dropping out of the room.
07:24:01 <ski> have fun
07:25:01 <kqr> is there a common way to express map ($x) fs without the x?
07:25:10 <kqr> zipWith ($) fs . repeat
07:25:12 <kqr> maybe
07:25:17 <kqr> but that's not any more clear to read
07:25:35 <tremon> wjw_: fuzzy logic is every bit an engineered solution
07:25:55 <darthdeus> is there an easy way to find all packages that are installed that depend on a certain package?
07:25:56 <BMeph> kqr: I call it, "mip" and define it that way. :)
07:25:57 <wjw_> Aborting my planned departure.
07:26:04 <darthdeus> so that when i do ghc-pkg unregister so i dont break anything
07:26:13 <kqr> BMeph, why that name
07:26:27 <wjw_> tremon, why is that?  I thought it was just trial and error, with the test being human experience.
07:27:20 <BMeph> kqr: Probably, some sort of mash-up of 'flip' and 'map'.
07:27:35 <wjw_> tremon, an engineerd solution would say, we want to limit the jerk and acceleration to which we subject the passengers, to within certain thresholds.
07:27:36 <darthdeus> or in another words, when I try to cabal install darcs, it tells me it has an issue with `deepseq`
07:27:37 <darthdeus> uhm
07:27:57 <darthdeus> but i tried cabal-db revdeps deepseq and i get a bunch of things
07:28:02 <darthdeus> https://gist.github.com/darthdeus/73a84ced9aa8c27582f0
07:28:03 <kqr> BMeph, ah
07:28:26 <Mysterious_Light> @type map . flip ($)
07:28:27 <lambdabot> a -> [a -> b] -> [b]
07:29:29 <darthdeus> specifically i'm confused that i get this when using a sandbox though
07:29:46 <darthdeus> i mean i tried to cabal unpack darcs and then build it in a sandbox, but it won't install
07:30:00 <tremon> wjw_: don't let me keep you, though. Fuzzy logic is a representation system first, a way to reason about uncertainties on otherwise discrete systems
07:30:22 <ski> > sequence [cos,sin] (pi / 3)  -- kqr ?
07:30:23 <lambdabot>  [0.5000000000000001,0.8660254037844386]
07:30:23 <wjw_> tremon, train control is a continuous system.
07:30:38 <tremon> wjw_: trains are controlled by analog control systems. You can do that without using fuzzy logic
07:30:50 <kqr> ski, impressive! thank you
07:30:59 <wjw_> tremon, an engineering solution models the diffeqs relating position, velocity, acceleration, and jerk.
07:31:54 <wjw_> tremon, it seeks a solution that brings the train from 30mph or whatever two miles from the station, to a standstill at the correct spot by the platform, without exceeding limits of acceleration and jerk.
07:32:05 <ski> @let flap :: Functor f => f (a -> b) -> (a -> f b); flap ff a = fmap ($ a) ff
07:32:08 <lambdabot>  Defined.
07:32:19 <ski> @let flap :: (a -> b -> c) -> (b -> a -> c)
07:32:20 <lambdabot>  .L.hs:149:1:
07:32:20 <lambdabot>      Duplicate type signatures for ‘flap’
07:32:20 <lambdabot>      at .L.hs:147:1-4
07:32:20 <lambdabot>         .L.hs:149:1-4
07:32:22 <ski> @type flap :: (a -> b -> c) -> (b -> a -> c)
07:32:23 <lambdabot> (a -> b -> c) -> b -> a -> c
07:32:25 <ski> @type flip
07:32:26 <lambdabot> (a -> b -> c) -> b -> a -> c
07:32:27 <PotatoGim> hello
07:32:37 <ski> > [cos,sin] `flap` (pi / 3)
07:32:39 <lambdabot>  [0.5000000000000001,0.8660254037844386]
07:32:52 <ski> at some point, `flip' in lambdabot was the above `flap'
07:32:56 <ski> kqr ^
07:32:58 <wjw_> tremon, but I read that some fuzzy logic solution to train control resulted in passengers reporting a better experience.
07:33:04 * ski nods towards PotatoGim
07:33:13 <pjdelport> kqr: (fs <*>) . pure
07:33:23 <kqr> now the suggestions are raining in
07:33:40 <kqr> ski, very cool relation
07:33:47 <ski> `flap' is a variant of `strength'
07:33:55 <pjdelport> Or of course ap fs . return
07:34:09 <tremon> wjw_: that may be true. I was just responding to your assertion that applying fuzzy logic made the system less "engineered"
07:34:51 <ski> @let strength :: Functor f => (a,f b) -> f (a,b); strength = uncurry (fmap . (,))
07:34:52 <lambdabot>  Defined.
07:34:52 <wjw_> tremon, well, I guess it might or might not.  Depends on the design process.
07:35:02 <ski> every functor in Haskell is a strong functor
07:35:08 <tremon> wjw_: to me that implied artificial learning systems, not fuzzy logic and ai have no relation. You may not have intended that though :)
07:35:18 <tremon> s/not/but/
07:35:31 <int3__> hm, it doesn't look like hlint accepts a config file of language extensions, and everything must be passed as a command line option... that's perturbing
07:35:36 <wjw_> tremon, no, I didn't intend to relate fuzzy logic to AI.
07:36:15 <wjw_> tremon, I imagine the fuzzy-logic solution to train control could have been crafted rather than engineered.
07:38:05 <tremon> wjw_: where's your distinction between craft and engineering? paper calculations vs field measurements+adjustments?
07:38:49 <wjw_> tremon, engineering has a reason for everything it does.  It models the causal link from the proposed solution to correct output.
07:39:28 <wjw_> tremon, craft work might try solutions and decide to be happy with them because they seem to work.
07:40:17 <tremon> wjw_: ah. It's a definition problem. To me, science it was has the reasons and causes, and engineering is where you incorporate real-world effects :). Sorry to keep you then
07:40:34 <tremon> bah s/it was/is what/
07:41:19 <heatsink> science is toward the goal of gathering information
07:41:21 <wjw_> tremon, rocketry is very engineered, right?  And you can do train control just the same way as rocketry.
07:42:01 <wjw_> tremon, the rocket scientist can solve the equations that express the requirements for getting to Mars.
07:42:05 <heatsink> If the goal is to accomplish something, it's engineering rather than science
07:42:39 <wjw_> tremon, similarly, a train-control engineer can set up the equations that say whether the train arrives where it should.  And can solve those.
07:43:11 <wjw_> heatsink, a footballer has a goal, and probably isn't engineering the solution.
07:43:35 <sm> GOOOOOOOAAAAAALLLLLL!!!!!!!!
07:43:42 <Sculptor> speaking of goals, brazili finals is in 4hrs
07:43:49 <Sculptor> brazil
07:43:51 <sm> OLE OLE OLE
07:44:05 <Sculptor> i might as well watch the game
07:45:06 <wjw_> Football is craft work.
07:45:10 <darthdeus> http://www.reddit.com/r/haskell/comments/2al3vx/how_do_you_avoid_the_cabal_hell/
07:45:22 <tremon> wjw_: I just didn't understand why you considered automated train systems that employ fuzzy control to be less "engineered" than train systems that don't
07:45:22 <darthdeus> all tips are welcome :P
07:46:00 <wjw_> tremon, well, those that use fuzzy logic _could_ be engineered, but if so, I don't know how to approach it.
07:46:36 <wjw_> tremon, if they are engineered, than the engineers have some explanation that I don't happen to have encountered or imagined.
07:46:58 <wjw_> tremon, but I can imagine doing it as craft.
07:47:44 <tremon> I guess I hard distinction between what you consider to be craft and engineering
07:47:53 <tremon> gah. "I guess I have no"
07:48:17 <wjw_> tremon, one of the variables in a fuzzy-logic solution could be "we are almost there".
07:48:49 <wjw_> tremon, one of the variables could be "we're going a little faster than we should be".
07:50:25 <wjw_> tremon, so a designer could cobble up some design in fuzzy logic using variables like that, and guess at what equations to use to calculate some of the variables from some of the others, and what functions to use from those to run the controls, then simulate the train or try it with a real train and a group of passenger judges.  That would not be engineering.
07:50:57 <tremon> within the system though, those would probably be represented as $\Delta X + \epsilon$ and $t\_{arrival} + \epsilon$
07:52:43 <tremon> you don't think rockets are ever field-tested?
07:53:04 <wjw_> tremon, I believe that in fuzzy logic, you write expressions that look syntactically like propositions, but instead of asking whether they are true or false, you assign them a number from 0 to 1 indicating sort of a degree of truthiness.
07:53:54 <wjw_> tremon, I think the reason to field-test rockets is to check for mistakes in the design or manufacture.
07:53:54 <tremon> yes, that's true
07:54:14 <tremon> (p=0.9 ;)
07:55:10 <kqr> uh. i have a Text value which I want to turn into an AttributeValue (Text.Blaze.Html5.Attributes). my current idea is to do "toAttr = fromString . Text.unpack". is there a better way i'm missing?
07:55:12 <wjw_> tremon, I'm not saying engineering is characterized by lack of field testing.  I'm saying it is characterized by designing based on a model of the system to be built.
07:56:22 <sithrak> or swat it together with steel wire duckt tape and chewing gum :)
07:58:47 <tremon> wjw_: so, if I understand correctly, your model presupposes a craftsman to determine empirically the threshold levels above which a signal is to be interpreted as "start braking now"?
08:00:03 <wjw_> tremon, yes.  The design might or might not be mathematically tractible, and even if it is tractible, the designer might not do full mathematical reasoning about how and if it works.
08:00:15 <tremon> wjw_: btw I have no experience with train control systems, just minor (R/C-scale) controls
08:00:30 <wjw_> tremon, neither do I.
08:03:45 <tremon> wjw_: I'm not sure such a decision is really needed. I tend to approach fuzzy decisions like that as analog controls, not binary statements. So a brake signal with p=0.6 would apply only very little braking power, whereas a brake signal with p=1.0 would almost be an emergency stop
08:04:03 <tremon> I would guess (wild guess) that the "less jerkiness because of fuzzy control" would have more to do with foregoing binary judgement than forestalling it
08:04:38 <wjw_> tremon, makes sense to me.
08:04:54 <tremon> although that still requires field testing and adjustments, so would still require craftsmanship :)
08:05:19 * hackagebot prednote 0.24.0.0 -   http://hackage.haskell.org/package/prednote-0.24.0.0 (OmariNorman)
08:05:44 <Algebr> Are Monads the only way to sequence code?
08:05:45 <wjw_> tremon, yes, and so I contrast it with an "engineered" solution based on the laws of motion.
08:06:06 <tremon> the laws of motion are still continuous though. Only boolean logic isn't
08:06:09 <joelteon> Algebr: no; you can do it yourself
08:06:19 <Algebr> joelteon: How could I do it?
08:06:31 <wjw_> tremon, both classes of solution are continuous.
08:06:34 <rio> monads are not a language feature, it's just a pattern
08:06:50 <joelteon> let (new_state, ret) = someOperation; (new_state', ret') = someOperation' ret; -- etc.
08:07:16 <Algebr> Ah, so lots of temporary variables.
08:07:43 <joelteon> the State monad is a way not to use temporary variables
08:10:09 <rio> you just hide them behind a type constructor, don't you
08:10:14 <wjw_> Resuming plan to go AFK.
08:18:27 <Fuuzetsu> any good guides/tutorials/manuals/whatever on writing bindings to C libraries?
08:20:30 <heatsink> Do you already know the basics of how to write wrappers around C functions, Fuuzetsu?
08:20:41 <heatsink> Like the "foreign import" syntax and the Foreign.* libraries
08:20:42 <Fuuzetsu> assume no knowledge
08:21:56 <SrPx> Hey, is there any way I get the bitwise representation of a float?
08:21:57 <heatsink> Hmm, I don't know.  I learned it by reading the FFI adendum to H98 and experimenting.
08:22:11 <Fuuzetsu> seems the wiki has some tools on it already, maybe all the work is done for me already
08:22:16 <heatsink> Referencing an existing C binding library is useful help
08:25:21 * hackagebot quickpull 0.2.0.0 - Generate Main module with QuickCheck tests  http://hackage.haskell.org/package/quickpull-0.2.0.0 (OmariNorman)
08:26:06 <heatsink> Fuuzetsu: You can do it in Haskell with FFI.  On top of that, you could get the help of a few preprocessors.
08:26:35 <heatsink> hsc2hs deals with the details of C data structure layout and simple type conversions
08:27:12 <Fuuzetsu> FTR I'm probably going to be wrapping libtorrent which does networking and stuff
08:27:19 <aspidites> what ever happened to the mezzo haskell book of 2012?
08:27:34 <aspidites> seeemed like a great idea, but doesn't seem to have materialized
08:29:14 <heatsink> Looks like libtorrent is a C++ library.  That's a bit more complicated.
08:31:25 <Fuuzetsu> oh what, I hope it isn't
08:31:27 <Fuuzetsu> thought it was C
08:31:39 <Fuuzetsu> damn you're right
08:32:15 <heatsink> I don't think the preprocessors work with C++.  Though you can check if the gtk library uses anything.
08:32:54 <heatsink> Well, the approach I've used is to write C wrappers around the C++ functions
08:33:03 <heatsink> Haskell proxy data types for the C++ objects
08:33:13 <heatsink> and Haskell foreign imports around the C wrappers
08:33:50 <EvanR_> total of 1337 nicks
08:33:52 <heatsink> Pretty simple, but tedious.  You'll probably see opportunities to improve the interface on the Haskell side with polymorphism and type classes
08:34:08 <Fuuzetsu> I think at this point it might be easier to write a native Haskell lib to do the same thing although I really don't want to
08:34:45 <heatsink> How complex is the bittorrent protocol?
08:35:18 <Fuuzetsu> a lot of stuff goes into it
08:35:22 * hackagebot rainbow-tests 0.14.0.2 - Tests and QuickCheck generators to accompany rainbow.  http://hackage.haskell.org/package/rainbow-tests-0.14.0.2 (OmariNorman)
08:36:20 <Fuuzetsu> I could probably steal some stuff from combinatorrent
08:38:36 <Tjr> Hi, I'm trying to understand http://tel.github.io/2014/07/12/mutable_algorithms_in_immutable_languges_part_1/
08:38:41 <heatsink> Ooh.  What's missing from combinatorrent for your purposes?
08:39:13 <SrPx> This SO answer doesn't compile: http://stackoverflow.com/a/2270879/1031791 - because of the # symbols. Does anyone know why?
08:39:43 <heatsink> Use the MagicHash extension to allow # characters in variable names, SrPx
08:39:47 <Algebr`> Where can I put the type declaration in this code so that show doesn't complain? ex1 = return 1 >>= (\a -> (putStrLn . show))
08:39:49 <Iceland_jack> SrPx: You need MagicHash
08:40:03 <Fuuzetsu> heatsink: support for tons of deps and IIRC the performance is not up to par
08:40:03 <SrPx> how do I use it? Can't I just use other variable names?
08:40:04 <Tjr> type family Val r :: *
08:40:04 <Tjr> deref :: Ref r -> r (Val r)
08:40:05 <Tjr> But later, in the "alter" function, f is composed with deref.
08:40:05 <Tjr> f takes the type "Val r", but deref delivers "r (Val r)"
08:40:07 <Fuuzetsu> also it hasn't been maintained for years
08:40:20 <joelteon> Algebr`: return (1 :: Integer)
08:40:24 <joelteon> or whatever else you're using
08:40:27 <Iceland_jack> SrPx: Read up on the extension, you need it if you want to use that example
08:40:30 <heatsink> I see
08:40:32 <EvanR_> man, type families and constraint kinds just to get mutable memory?
08:40:37 <joelteon> Algebr`: actually, what are you applying putStrLn . show to there?
08:40:40 <SrPx> :( okay thanks
08:40:57 <heatsink> It sounds like you'll either have to take over combinatorrent, or wrap an actively maintained library.
08:41:22 <Algebr`> joelteon: (putStrLn . show) should be getting the a, which should be 1 ::Int
08:41:23 <Tjr> Obviously, the "r" must get eaten by a >>=, but it's not spelled out.
08:41:38 <joelteon> Algebr`: ok but you're not applying that to the a
08:41:43 <joelteon> :t \a -> putStrLn . show
08:41:43 <lambdabot> Show a => t -> a -> IO ()
08:41:49 <joelteon> it discards the argument 't'
08:43:09 <Algebr`> joelteon: ah, I didn't even need the lambda
08:43:19 <Algebr`> just, ex2 = return (1::Int) >>= (putStrLn . show)
08:43:35 <Fuuzetsu> heatsink: I'll probably take over combinatorrent or just borrow some of it; the issue I have with wrapping C/C++ library is that its faults remain and the API ends up nasty. I'm currently using rtorrent and that crashes pretty much daily nowadays due to corrupted doubly-linked lists, segfaults and all that other great manual memory management stuff
08:43:57 <Fuuzetsu> (also the interface is shit)
08:44:19 <joelteon> Algebr`: yeah
08:44:45 <heatsink> Ugh, memory corruption
08:45:10 <heatsink> Alright then, hope it goes smoothly.
08:45:12 <SrPx> Iceland_jack: worked, thanks
08:45:30 <pjdelport> "Manage your own memory, they said. It'll be efficient, they said."
08:46:25 <Fuuzetsu> pjdelport: well, it's efficient when it works
08:46:40 <Fuuzetsu> I have like 12k torrents active in under 1GB of RAM
08:46:45 <Fuuzetsu> but it crashes ;)
08:47:13 <Fuuzetsu> I just wonder if I can achieve similar size with Haskell
08:47:59 <pjdelport> I'm sure it's doable, with careful design of the core data structures.
08:48:07 <EvanR_> Tjr: i started reading this, and im about to get confused by the use of r as the monad, and r as a variable holding a reference
08:48:56 <pjdelport> And on the whole it's probably easier to go from "correct" to "correct and fast" in Haskell than from "broken and fast" to "correct and fast" in C++
08:49:11 <SrPx> Is that correct? `foo :: Word32 → Word32 → Word64; foo x y = (shiftL (fromIntegral x) 32) .|. (fromIntegral y)` - I want to convert a Word32 to a Word64 by concatenating the bits
08:49:15 <SrPx> 2 Word32s *
08:49:22 <EvanR_> Tjr: but the alter function makes sense
08:49:36 <SrPx> I'm not sure I'm using fromIntegral correctly there
08:49:49 <Fuuzetsu> pjdelport: I agree, seems like there's a lot of work for me to be done
08:50:14 <Tjr> EvanR: regarding r: one sort if the monad, another sort is prefixed by Val / Ref, a third kind is the variable passed around in alter by the do block.
08:50:24 <heatsink> SrPx: That's correct
08:50:35 <SrPx> heatsink: thanks
08:50:36 <EvanR_> Tjr: when you do v <- deref r, v is a "Var r" not a r (Var r)
08:51:03 <Tjr> EvanR: yes, I see it now, too. My error was that I didn't realize the author simply assumed the monad machinery.
08:51:14 <EvanR_> thats the do notation
08:51:21 <Tjr> indeed
08:51:58 <Tjr> however, the article says they will construct such a monad explicitly, so I didn't notice they construct the use case first.
08:51:58 <EvanR_> it looks like he went through two blog posts beating around the bush, he wants to write an algorithm with mutable memory with a pure interface
08:52:09 <EvanR_> and still isnt telling you about ST ;)
08:52:29 <Tjr> he/she did on the reddit comments :-)
08:52:44 <od__> i have an enum like data type, is there a way to derive/copy Storable instances from another type like Word8 or something?
08:54:33 <EvanR_> this isnt one of them but i am really tickled by the proponderance of haskell blogs written in the style of "so youre an idiot and still dont understand this thing in haskell"
08:54:42 <EvanR_> it means avoiding success is getting harder
08:55:08 <kqr> @pl \a f x -> a >> f x
08:55:08 <lambdabot> (.) . (>>)
08:55:26 <kqr> i could swear i have known some better way to write that
08:56:08 <kqr> "\a f -> const a >=> f" maybe... if that works
08:56:25 <kqr> no not the same thing
08:57:02 <EvanR_> id a >> f x
08:57:17 <EvanR_> something id a f x
08:57:27 <EvanR_> >> something id
08:58:39 <EvanR_> @pl \f a x -> a >> f x
08:58:39 <lambdabot> flip ((.) . (>>))
08:58:46 <EvanR_> @pl \f x a -> a >> f x
08:58:47 <lambdabot> (flip (>>) .)
08:59:25 <EvanR_> @pl \f x g y -> f x + g y
08:59:25 <lambdabot> (((.) . (+)) .)
09:02:03 <EvanR_> really a >> f x seems good
09:02:53 <kqr> yeah, i'm going with thtat
09:02:55 <EvanR_> (>>) a (f x)
09:02:57 <EvanR_> heh
09:06:35 <SrPx> What is a faster structure to hold maps between Word64s and some type else, when you need to use `lookup` a lot: Data.HashMap.Strict or Data.Map ?
09:06:51 <SrPx> (or what else)
09:07:34 <Tjr> EvanR: "avoiding success is getting harder" --> So haskell might affect employability.
09:09:29 <heatsink> SrPx: With word64 keys, a hash-based map will be faster than a tree-based one.  Data.Map is tree-based.
09:10:02 <SrPx> heatsink: thanks
09:10:39 <int3__> maybe I should ask this in #vim, but has anyone had problems with parenthesis matching for lambdas in vim? in particular, (\(x, y) -> x) confuses vim (I suspect) because it thinks '\(' is an escaped paren
09:10:52 <heatsink> emacs has that problem too
09:11:01 <int3__> ah
09:11:16 <EvanR_> SrPx: IntMap heh
09:11:25 <SrPx> int3__: looks like it works here: http://o7.no/1kRUqHZ
09:12:18 <int3__> SrPx: where is that from? also, weirdly enough, highlighting matches works for me, but '%' (jump to matching paren) doesn't
09:14:10 <SrPx> int3__: vim. Indeed, % doesn't work here. Weird.
09:19:06 <int3__> ah, I remembered the #1 rule of hacking vim: `:help` is usually more effective than googling.
09:19:13 <int3__> SrPx: `au FileType haskell set cpoptions+=M` fixes things
09:20:20 <SrPx> int3__: what did you type after :help ?
09:20:27 * hackagebot Spock-auth 0.2.0.1 - Provides authentification helpers for Spock  http://hackage.haskell.org/package/Spock-auth-0.2.0.1 (AlexanderThiemann)
09:20:32 <int3__> SrPx: :help %
09:20:38 <SrPx> makes sense.
09:20:45 <int3__> yup :P
09:21:12 <SrPx> EvanR_: are those better than HashMaps for my case?
09:23:02 <SrPx> EvanR_: I guess it only words for Int keys, not Word64 ):
09:24:01 <EvanR_> thats the rub
09:24:17 <EvanR_> doesnt work on 32 bit
09:25:10 <EvanR_> besides that i think you can unsafe coerce Int64 and Word64
09:25:28 * hackagebot Spock-worker 0.1.0.5 - Background workers for Spock  http://hackage.haskell.org/package/Spock-worker-0.1.0.5 (AlexanderThiemann)
09:27:40 <asayers> #/quit
09:40:29 * hackagebot prednote-test 0.24.0.0 - Tests and QuickCheck generators to accompany prednote.  http://hackage.haskell.org/package/prednote-test-0.24.0.0 (OmariNorman)
10:09:39 <isomorpheous> @ops
10:09:39 <lambdabot> Maybe you meant: pl oeis docs
10:11:04 <quchen> isomorpheous: Check #haskell-ops
10:18:24 <senft> Is it possible to have patterns match only if the first two elements of a list a equal? Something like:
10:18:28 <senft> distinct :: (Eq a) => [a] -> [a]
10:18:31 <senft> distinct (x:x:xs) = x:xs
10:18:47 <isomorpheous> senft: use guards
10:19:01 <senft> isomorpheous: ok, thanks
10:19:03 <isomorpheous> distinct (x:y:xs) | x == y
10:19:04 <jmcarthur> senft: distinct (x:y:xs) | x == y = x:xs
10:19:16 <isomorpheous> distinct (x:y:xs) | x == y = blah | otherwise = ...
10:19:38 <wz1000> Why does unsafePerformIO exist?
10:19:56 <merijn> wz1000: To implement dirty hacks inside the runtime
10:20:02 <donri> ffi
10:20:11 <merijn> And the FFI, yes
10:20:31 <jmcarthur> wz1000: it's really only there for (a) FFI and (b) doing low-level things that are somewhat like implementing new primitives
10:20:49 <jmcarthur> (a) is a lot like (b) anyway
10:21:23 <EvanR> (c) global mutable variables!
10:21:25 <Kron> > [1,1.3..10]
10:21:27 <lambdabot>  [1.0,1.3,1.6,1.9000000000000001,2.2,2.5,2.8,3.0999999999999996,3.39999999999...
10:21:40 <Kron> accursed floating point numbers
10:21:49 <Kron> abandon all sanity, ye who enter the floating realms
10:22:00 <EvanR> dont try to use that operation on floats ;)
10:22:05 <wz1000> I feel like it corrupts the very idea of Haskell.
10:22:07 <Kron> indeed
10:22:17 <jmcarthur> EvanR: (c) is also like (b)
10:22:22 <Kron> do floats obey Eq?
10:22:29 <Kron> > 0.3 == 0.3
10:22:30 <isomorpheous> I'm curious what would happen if I typed in "> [1 ..], but I don't want to destroy lambdabot
10:22:31 <lambdabot>  True
10:22:32 <quchen> You mean a == a? No.
10:22:35 <Qfwfq> > [1, 13%10,..10]
10:22:36 <lambdabot>  <hint>:1:11: parse error on input ‘..’
10:22:37 <geekosaur> they pretend to
10:22:42 <quchen> > (0/0) == (0/0)
10:22:42 <jmcarthur> Kron: (1/0) == (1/0)
10:22:43 <lambdabot>  False
10:22:44 <Qfwfq> > [1, 13%10..10]
10:22:45 <lambdabot>  [1 % 1,13 % 10,8 % 5,19 % 10,11 % 5,5 % 2,14 % 5,31 % 10,17 % 5,37 % 10,4 % ...
10:22:47 <merijn> > [1..]
10:22:47 <Kron> elaborate on how they pretend to...
10:22:48 <jmcarthur> oh right
10:22:49 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
10:22:50 <jmcarthur> 0/0
10:22:52 <jmcarthur> derp
10:22:54 <isomorpheous> :i float
10:23:02 <EvanR> NaN != NaN so its not an equivalence relation
10:23:02 <isomorpheous> :i Float
10:23:08 <quchen> Floats are probably the main reason Eq doesn't have any laws.
10:23:09 <pjdelport> isomorpheous: Things like [1..] are fine in Haskell.
10:23:20 <isomorpheous> pjdelport: I'm aware, because laziness
10:23:29 <pjdelport> isomorpheous: And in lambdabot. It only evaluates as much of it as it wants to, to display it.
10:23:32 <geekosaur> Kron: ieee754 elaborates on it
10:23:33 <Qfwfq> :t enumFrom
10:23:34 <lambdabot> Enum a => a -> [a]
10:23:48 <Kron> I'm teaching a friend of mine Haskell and it's really reigniting my love for the language ^_^
10:23:51 <EvanR> > [..1]
10:23:52 <lambdabot>  <hint>:1:2: parse error on input ‘..’
10:24:11 <Qfwfq> @info Enum
10:24:11 <lambdabot> Enum
10:24:19 <quchen> The main problem with floats is that one would really like it to represent real numbers, and it's easy to forget that they aren't.
10:24:37 <quchen> (==) is well-defined on Float, it's just not what you'd expect from mathematical equality.
10:24:38 <Qfwfq> > type ℝ = Double
10:24:40 <lambdabot>  <hint>:1:1: parse error on input ‘type’
10:24:52 <isomorpheous> What does % do
10:24:59 <quchen> Fractions.
10:25:01 <isomorpheous> in that range
10:25:02 <isomorpheous> ah
10:25:03 <isomorpheous> hm/
10:25:05 <EvanR> i like the classes which split Enum into an increasing and decreasing pair of classes but i cant remember the names
10:25:06 <quchen> numerator % denominator
10:25:13 <pjdelport> Floats are perfectly fine if you take them for what they are: a specialized number type with certain desirable numeric properties.
10:25:17 <EvanR> EnumUp?
10:25:33 * hackagebot Spock 0.6.1.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.6.1.0 (AlexanderThiemann)
10:25:34 <isomorpheous> quchen: something I need to import?
10:25:38 <pjdelport> (which do not include being precise real/rational numbers)
10:25:39 <Qfwfq> instance EnumUp a => EnumDown a => Enum a
10:25:50 <quchen> isomorpheous: It's Data.Ratio I think.
10:26:05 <jmcarthur> > (sin^2 + cos^2) 4
10:26:06 <lambdabot>  No instance for (GHC.Show.Show a0)
10:26:06 <lambdabot>    arising from a use of ‘M24800752620673085613158.show_M24800752620673085613...
10:26:06 <lambdabot>  The type variable ‘a0’ is ambiguous
10:26:06 <lambdabot>  Note: there are several potential instances:
10:26:06 <lambdabot>    instance [safe] GHC.Show.Show
10:26:07 <EvanR> pjdelport: and certain undesirable properties
10:26:19 <jmcarthur> > (sin^2 + cos^2) 4 :: Double
10:26:19 <isomorpheous> quchen: thank you
10:26:20 <lambdabot>  No instance for (GHC.Num.Num
10:26:21 <lambdabot>                     (GHC.Types.Double -> GHC.Types.Double))
10:26:21 <lambdabot>    arising from a use of ‘GHC.Num.+’
10:26:26 <Qfwfq> jmcarthur: Endofunctions aren't an instance of Num?
10:26:29 <jmcarthur> aw, i forgot NumInstances is gone
10:26:42 <pjdelport> EvanR: Well, I should qualify, sorry: it's desirable for some applications, undesireable for others.
10:26:52 <quchen> Qfwfq: You can write an instance, but it's very confusing and not really helpful at all.
10:26:54 <jmcarthur> Qfwfq: NumInstances is a package lambdabot used to include that provided   instance Num b => Num (a -> b)
10:27:05 <jmcarthur> i think it's not confusing and makes a lot of code nicer
10:27:15 <Qfwfq> I'd use that.
10:27:40 <quchen> 2 3 4 -- What does that evaluate to?
10:27:49 <jmcarthur> 2
10:28:00 <EvanR> found it
10:28:02 <EvanR> http://hackage.haskell.org/package/prelude-safeenum-0.1.1.1/docs/Prelude-SafeEnum.html
10:28:07 <EvanR> UpwardEnum
10:28:11 <ReinH> The NumInstances one is quite useful
10:28:19 <jmcarthur> > (sin 4)^2 + (cos 4)^2 :: Double
10:28:20 <lambdabot>  1.0
10:28:23 <jmcarthur> > (sin 4)^2 + (cos 4)^2 :: CReal
10:28:24 <lambdabot>  1.0
10:28:29 <jmcarthur> huh double got it right
10:28:41 <jmcarthur> need more rounding error to demonstrate the awesomeness of CReal
10:28:57 <EvanR> show float with more digits
10:29:43 <isomorpheous> I think I found a bug in the sin function
10:29:48 <isomorpheous> > quickCheck (\s -> ((\x -> (cos x)^2 + (sin x)^2) s) == 1 )
10:29:50 <lambdabot>  <IO ()>
10:30:09 <ion> No, you only found out that (==) is not appropriate with IEEE floats.
10:30:12 <Qfwfq> You found a "bug" in floating point equality.
10:30:17 <EvanR> haha
10:30:21 <isomorpheous> Ah - what should I do instead
10:30:37 <Qfwfq> Accept the error, use CReal, or define approximate equality.
10:31:00 <EvanR> numeric stability
10:31:07 <ion> https://github.com/ekmett/lens/blob/master/src/Data/Complex/Lens.hs#L33
10:31:23 <pjdelport> isomorpheous: Have you read http://floating-point-gui.de/ ?
10:31:33 <Dodek> hey, i want to have a line-buffered network socket. what's the easiest way to acomplish this?
10:31:37 <Qfwfq> ion: Is ε=1e6 arbitrary or chosen for some reason?
10:31:43 <ion> Arbitrary
10:31:45 <jmcarthur> CReal does not have a total (==), so don't rely on that
10:31:50 <Kron> how does one fold a list via a monoid?
10:31:56 <Qfwfq> mconcat.
10:31:56 <Kron> "foldSomething (+) [1,2,3]"
10:32:01 <jmcarthur> (well, it does have (==) actually, but it's not exact!)
10:32:05 <Qfwfq> Oh, in that case:
10:32:06 <pjdelport> isomorpheous: And http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html if you want dive into more depth.
10:32:22 <Qfwfq> getSum . mconcat . map Sum
10:32:33 <rwbarton> if you want to know whether two real numbers are equal your best bet is to ask a mathematician
10:32:57 <EvanR> > (sin 4)**2 + (cos 4)**2 == 1 :: CReal
10:32:59 <lambdabot>  Couldn't match expected type ‘Data.Number.CReal.CReal’
10:32:59 <lambdabot>              with actual type ‘GHC.Types.Bool’
10:33:01 <Kron> foldMap Sum?
10:33:06 <ion> > ala Sum foldMap [1..10]
10:33:08 <lambdabot>  55
10:33:12 <EvanR> > (sin 4)**2 + (cos 4)**2 == (1 :: CReal)
10:33:13 <lambdabot>  *Exception: log of negative number
10:33:18 <Qfwfq> Kron: Yeah, that'd do it.
10:33:32 <Kron> thanks!
10:33:43 <EvanR> when you said non total you werent kidding
10:33:53 <rwbarton> that is ** being non-total
10:34:04 <Qfwfq> getSum . foldMap Sum
10:34:13 <EvanR> > (-1.0)**2
10:34:15 <lambdabot>  1.0
10:34:18 <rwbarton> you want ^
10:34:43 <EvanR> confused
10:35:07 <EvanR> > (-1.0::CReal)**2
10:35:08 <lambdabot>  *Exception: log of negative number
10:35:11 <rwbarton> ** is for raising a number to a fractional power, and in general you can't raise a negative number to a fractional power
10:35:24 <EvanR> oh
10:35:27 <rwbarton> I don't know why it worked for (-1.0)**2 :: Double
10:35:38 <EvanR> because theres no irrational powers in double
10:36:00 <ion> > (-1 :: Complex CReal)**2
10:36:01 <lambdabot>  1.0 :+ 0.0
10:36:20 <EvanR> :|
10:36:47 <EvanR> why cant computer math
10:37:03 <Qfwfq> Because finite tape.
10:37:28 <EvanR> infinite tape also would not help
10:37:45 <EvanR> finite patience ;
10:37:46 <EvanR> )
10:38:08 <Qfwfq> If you want termination, there's always #agda. :D
10:39:22 <EvanR> "ill be back"
10:39:31 <EvanR> in finite time
10:40:17 <Qfwfq> Has anyone worked on worst-case runtime guarantees using dependent types?
10:41:43 <c_wraith> Qfwfq: I think I've heard of some work in that direction, but I don't remember any details.
10:43:14 <dagano> what is wrong with : Data.IntMap.filterWithKey (\k -> (elem k explored)) imap    ... where explored is [Int] ?
10:43:47 <dagano> i want a subset of the imap where the keys have to be in 'explored'
10:43:59 <c_wraith> dagano: not enough arguments to the lambda function
10:44:14 <c_wraith> dagano: which should be what the error message is telling you
10:44:16 <Qfwfq> That and you aren't composing with imap.
10:44:45 <dagano> oh durr .. explored is nowhere in the function arg list
10:46:03 <Qfwfq> I don't think that's it? c_wraith is saying you want "\k _ ->", rather than "\k ->", not that explored isn't in scope.
10:46:15 <wz1000> is there any nice combinator that is like (.) but waits for multiple args before piping on? The syntax becomes very ugly. Eg:- (+1) .. (+) instead of ((+1) .) . (+) waits for (+) to receive two values before piping to (+1). The current syntax could be tidied up.
10:46:27 <Qfwfq> fmap fmap fmap
10:46:33 <dagano> where _ is the 'value' for each key in the intmap?
10:46:53 <c_wraith> dagano: yes
10:46:54 <Qfwfq> Yeah. Though I don't know the type of filterWithKey.
10:47:04 <c_wraith> :t M.filterWithKey
10:47:06 <lambdabot> (k -> a -> Bool) -> M.Map k a -> M.Map k a
10:47:08 <dwcook> wz1000: so you want (c -> d) -> (a -> b -> c) -> a -> b -> d ?
10:47:19 <c_wraith> That's for Data.Map, but it's the same type for Data.IntMap
10:47:19 <dagano> c_wraith: that was correct .. one more arg in the lambda works
10:47:20 <dwcook> @djinn (c -> d) -> (a -> b -> c) -> a -> b -> d
10:47:20 <lambdabot> f a b c d = a (b c d)
10:47:22 <pjdelport> @hackage composition
10:47:22 <lambdabot> http://hackage.haskell.org/package/composition
10:48:19 <pjdelport> wz1000: That defines (.:) = (.).(.) among others, which lets you state e.g. concatMap f xs = concat (map f xs) as concatMap = concat .: map
10:48:39 <Qfwfq> fmap . fmap . fmap . fmap . fmap
10:48:57 <dwcook> Qfwfq: for more confusion, write (.) as fmap as well.
10:49:03 <dwcook> fmap fmap fmap fmap fmap fmap fmap fmap fmap
10:49:11 <quchen> > (fmap fix return) "hello world"
10:49:12 <dwcook> Wait, that's not quite right, is it?
10:49:12 <lambdabot>  "hello world"
10:49:15 <Qfwfq> dwcook: I did so in my third most recent message, but I think the precedence is weird in that case.
10:49:54 <Qfwfq> (fmap fmap fmap) `fmap` (fmap fmap fmap) should typecheck.
10:50:18 <Qfwfq> 'fmap fmap fmap fmap fmap fmap fmap' should not.
10:50:30 <dwcook> Well, it does type check, it just has another type.
10:50:36 <Qfwfq> Oh, right. Yeah.
10:50:54 <joelteon> :t ((.) . (.)) . ((.) . (.))
10:50:54 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> a3 -> b) -> a -> a1 -> a2 -> a3 -> c
10:50:55 <quchen> Is there something with fmaps that doesn't typecheck? :-x
10:50:57 <wz1000> dwcook: yes, but a more generalized form with nice syntax. Notice how in order to wait for 'n' arguments, you have to use n (.)'s with the current syntax. The only problem is the huge amount of parenthesis involved
10:51:04 <quchen> fmap (fmap fmap) fmap (fmap fmap) fmap fmap -- Typechecks.
10:51:17 <joelteon> @let buffalo = fmap
10:51:18 <lambdabot>  Defined.
10:51:26 <dwcook> I don't think there is any tree of fmap that does not typecheck.
10:51:27 <Qfwfq> wz1000: You could write TH functions to write the definitions for you, I wouldn't go so far as changing the syntax.
10:51:29 <pjdelport> joelteon: hah
10:51:30 <Qfwfq> joelteon: haha
10:51:32 <quchen> joelteon: Poem incoming? :-)
10:51:35 <dwcook> (Someone feel free to prove me wrong)
10:51:38 <senft> Why are these two definitions not equal? Or asked differently, why is the second one wrong? http://lpaste.net/5418101475832233984
10:52:01 <senft> Doesn't it mean "call distinct after you have called merge"?
10:52:11 <SrPx> Okay, I want a structure that maps Word64 to values. IntMap will only accept Ints. What now?
10:52:17 <pjdelport> senft: That's actually exactly what we were discussing just above
10:52:31 <robbins> :t flip
10:52:32 <lambdabot> (a -> b -> c) -> b -> a -> c
10:52:34 <senft> pjdelport: oh :D let me see
10:52:43 <dagano> en how do i 'safely' get around the error : Expected type : [Key] Actual type: [Integer]?
10:52:44 <pjdelport> senft: To compose like that, you'd have to use the (.:) combinator mentioned above: combine2 = distinct .: merge
10:52:48 <_deepfire> Why's the Haskell FFI so ascetic, when it comes to C structure manipulation?
10:52:55 <dagano> en how do i 'safely' get around the error : Expected type : [Key] Actual type: [Integer]?
10:52:56 <pjdelport> (it's from the 'composition' package)
10:53:00 <dwcook> senft: You have to be aware that every function has exactly one parameter. (.) is not aware of how many times a function appears in the result of your function.
10:53:08 <pjdelport> senft: (.:) = (.) . (.)
10:53:12 <senft> pjdelport: I assume it has something to do with the fact that both functions expect different kinds of arguments?
10:53:14 <dagano> if Key is just an alias for Integer?
10:53:34 <senft> I see. thanks guys!
10:53:45 <dwcook> senft: Let's try reducing combine2 step-by-step.
10:53:50 <dwcook> combine2 x y = distinct (merge x y)
10:53:55 <dwcook> So the first step here that I'd take is
10:54:01 <dwcook> combine2 x y = distinct . merge x $ y
10:54:03 <Qfwfq> dagano: Is it a type synonym or a newtype?
10:54:06 <dwcook> Now you can clearly eta reduce
10:54:12 <dwcook> combine2 x = distinct . merge x
10:54:17 <dwcook> Now how do you get rid of the x?
10:54:17 <dagano> type Key = Int
10:54:20 <pjdelport> senft: No, it's just the number of arguments to merge. "combine2 = distinct . merge" means the same as "combine2 x y = distinct (merge x) y"
10:54:20 <dagano> in the spec for IntMap
10:54:25 <senft> dwcook: ah.. sure
10:54:38 <pjdelport> senft: Note that distinct receives y, not merge.
10:54:41 <Qfwfq> dagano: I don't know why that doesn't work.
10:54:50 <yitz> pjdelport: (.:) is a terrible name. it's the most natural operator name to use for time-related functions. people use it all the time.
10:54:51 <Qfwfq> dagano: Oh, Integer Int
10:54:51 <dwcook> senft: do you see the problem?
10:54:57 <senft> pjdelport: yeah that is kinda what I meant. different number of arguments. bad wording on my side
10:55:00 <Qfwfq> dagano: You want fromInteger I think.
10:55:01 <senft> dwcook: yeah, I do. thanks!
10:55:14 <bb010g> (Sorry, had to go unexpectedly last time & was sleepy. Awake now. :) ) So, is there a way to give a constraint on a Functor, rather like the impossible ``instance Ord a => Functor (\a -> Set a) where```. jle` mentioned constraint kinds with type families, but I'm not really sure how that works. You'd end up with the specialized fmap typed ``(Ord a, Ord b) =>
10:55:15 <bb010g> (a -> b) -> Set a -> Set b``.
10:55:18 <dagano> oooh
10:55:27 <pjdelport> yitz: I don't disagree, but that's the main reference I know of on hackage for it. :)
10:55:36 <mwhit> :t (.) . (.)
10:55:37 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:55:38 <wz1000> senft: to ugly it up in a beautiful way, combine = (distinct .) . merge
10:56:29 <pjdelport> Pity you can't say (.²) = (.) . (.), heh
10:56:43 <quchen> ಠ_ಠ
10:57:11 <bb010g> I know I could make a ``newtype OrdMap a = OrdMap {getOrdMap :: Ord a => Map a}``, but I'm trying to avoid that.
10:57:20 <pjdelport> Tonight, on "terrible operators in Haskell"
10:57:22 <Clint> pjdelport: why can't you?
10:57:37 <benzrf> hey, i'm writing a simple framework for making reactive irc bots
10:57:49 <benzrf> right now im making a data decl for actions the bot can take
10:58:03 <Qfwfq> Clint: I don't think that character is permitted in names of operators.
10:58:07 <benzrf> i'm thinking i'll have user-supplied command impls return a list of actions
10:58:10 <Clint> hmm
10:58:11 <pjdelport> Clint: Unicode counts ² as a number, not punctuation, IINM.
10:58:19 <benzrf> or should i add a Nop and Cons constructor and make it, itself, a monoid?
10:58:23 <isomorpheous> @let (...) a b = a . b . a $ b
10:58:23 <lambdabot>  .L.hs:164:3:
10:58:23 <lambdabot>      Multiple declarations of ‘...’
10:58:23 <lambdabot>      Declared at: .L.hs:157:1
10:58:23 <lambdabot>                   .L.hs:164:3
10:58:25 <benzrf> the latter sounds like overthinking it
10:58:34 <isomorpheous> @unlet (...)
10:58:34 <lambdabot>  Parse failed: TemplateHaskell is not enabled
10:58:35 <benzrf> isomorpheous: how is that useful
10:58:40 <ion> > let a = 4; a² = a^2 in a²
10:58:41 <isomorpheous> benzrf: it's not
10:58:42 <lambdabot>  16
10:58:45 <quchen> ?let (...........) = (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
10:58:46 <lambdabot>  Defined.
10:58:50 <quchen> :t (...........)
10:58:51 <lambdabot> (a -> b -> c) -> a -> (a1 -> a2 -> b) -> a1 -> a2 -> c
10:59:02 <isomorpheous> hahaha
10:59:07 <quchen> ?undef
10:59:07 <lambdabot> Undefined.
10:59:21 <quchen> It's pronounced "dotdotdotdotdotdotdotdotdotdotdot".
10:59:24 <benzrf> @let (...) = enumToFrom
10:59:24 <lambdabot>  .L.hs:146:9:
10:59:24 <lambdabot>      Not in scope: ‘enumToFrom’
10:59:24 <lambdabot>      Perhaps you meant ‘enumFrom’ (imported from Prelude)
10:59:33 <benzrf> @let (...) = flip enumfromTo
10:59:33 <lambdabot>  .L.hs:146:14:
10:59:33 <lambdabot>      Not in scope: ‘enumfromTo’
10:59:33 <lambdabot>      Perhaps you meant one of these:
10:59:33 <lambdabot>        ‘enumFromTo’ (imported from Prelude),
10:59:33 <lambdabot>        ‘enumFrom’ (imported from Prelude)
10:59:37 <benzrf> @let (...) = flip enumFromTo
10:59:38 <lambdabot>  Defined.
10:59:46 <benzrf> > [1...5]
10:59:47 <lambdabot>  Ambiguous occurrence ‘...’
10:59:47 <lambdabot>  It could refer to either ‘L....’, defined at L.hs:146:1
10:59:47 <lambdabot>                        or ‘Control.Lens.Plated....’,
10:59:47 <lambdabot>                           imported from ‘Control.Lens’ at L.hs:41:1-43
10:59:47 <lambdabot>                           (and originally defined in ‘lens-4.1.2:Control.Lens...
10:59:52 <benzrf> man!
11:00:04 <Qfwfq> Also, wouldn't that give you Num a => [[a]]?
11:00:08 <benzrf> Qfwfq: yeah
11:00:10 <benzrf> no, Enum
11:00:17 <joelteon> Num a, Enum a
11:00:19 <Qfwfq> Num a, Enum a
11:00:27 <joelteon> E?(N|n)um a
11:00:35 <joelteon> {-# LANGUAGE RegexpConstraints #-}
11:00:40 <Qfwfq> Haha
11:01:03 <quchen> At this pace we'll hit the sound barrier of awfulness soon.
11:01:18 <Qfwfq> Would the implementation find all matching classes in scope?
11:01:38 <joelteon> Absolutely.
11:01:39 <Qfwfq> That seems difficult to reason about, if those can't be listed.
11:01:49 <yitz> > let (!○) = (.) . (.); (!○!) = (.) . (.) . (.) . (.) . (.) -- etc.
11:01:50 <lambdabot>  not an expression: ‘let (!○) = (.) . (.); (!○!) = (.) . (.) . (.) . (.) . (....
11:01:56 <benzrf> joelteon: do you mean [Nn]
11:02:00 <ion> Listen to the Japanese translation https://translate.google.com/?source=osdd#en/ja/dot%20dot%20dot%20dot%20dot%20dot%20dot%20dot%20dot%20dot%20dot%20dot
11:02:08 <yitz> hrmph. worked in ghci.
11:02:19 <benzrf> ion: lol
11:02:25 <yitz> > let (!○) = (.) . (.)
11:02:27 <lambdabot>  not an expression: ‘let (!○) = (.) . (.)’
11:02:27 <joelteon> benzrf, no. do you?
11:02:35 <quchen>  ?let (!○) = (.) . (.)
11:03:03 <benzrf> joelteon: [Nn] is 1 char shorter than (N|n)
11:03:04 <benzrf> ^_^
11:03:22 <Qfwfq> benzrf: It's very important that the capture be referenceable in the type defn. ;-)
11:03:30 <Qfwfq> *signature
11:04:07 <SrPx> Is there something similar to Data.IntMap, but for Word64 ?
11:04:28 <joelteon> aren't Int and Word64 the same size?
11:04:35 <joelteon> that's probably a terrible assumption to make isn't it
11:04:43 <yitz> SrPx: just use IntMap with fromIntegral
11:04:43 <SrPx> Oh...
11:05:08 <yitz> SrPx: GHC has built-in specializations of fromIntegral that make that essentially free
11:05:15 <SrPx> yitz: but Word64 is > than Int32, if that is what it will use... so I will have wrong maps
11:05:16 <hwut> wha
11:05:21 <benzrf> @src Int -- joelteon
11:05:21 <lambdabot> Source not found. Whoa.
11:05:23 <benzrf> @src Int
11:05:23 <lambdabot> data Int = I# Int#
11:05:25 <yitz> ohh different sizes?
11:05:34 <joelteon> right, Word64 is probably larger than Int
11:05:44 <joelteon> SrPx, why not check the source of IntMap and write your own variant for Word64?
11:05:55 <ion> > (maxBound :: Word64, maxBound :: Int)
11:05:56 <lambdabot>  (18446744073709551615,9223372036854775807)
11:05:59 <SrPx> oh damn :(
11:06:03 <yitz> well no on a 64-bit machine they are the same size.
11:06:09 <joelteon> I'm on a 64-bit machine.
11:06:12 <SrPx> let me check it here
11:06:13 <ion> > (maxBound :: Int64, maxBound :: Int)
11:06:14 <lambdabot>  (9223372036854775807,9223372036854775807)
11:06:24 <joelteon> Word64 is non-negative right
11:06:35 <quchen> Is the behaviour of `fromIntegral` specified if one type doesn't fit inside the other?
11:06:41 <joelteon> Let me find out!!
11:06:50 <quchen> joelteon: Yes, Word is unsigned Int
11:07:07 <joelteon> fromIntegral (300 :: Integer) :: Word8 is 44
11:07:08 <Qfwfq> > (fromIntegral (-1)) :: Word64
11:07:10 <lambdabot>  18446744073709551615
11:07:16 <yitz> quchen: all of the common combinations are explicitly special-cased (in GHC.Int, I think) for both 32-bit and 64-bit GHC.
11:07:26 <ion> > fromIntegral (0x1001 :: Word16) :: Word8
11:07:27 <lambdabot>  1
11:07:43 <joelteon> But the point is, Word64 doesn't fit inside Int, so SrPx can't just fromIntegral the input.
11:07:46 <quchen> yitz: Special-cased for what? Overflow is modulo target length?
11:08:12 <yitz> joelteon: it will coerce the larger values to negative Ints, which will still work in an IntMap
11:08:20 <joelteon> oh really
11:08:53 <yitz> quchen: special-cased to coerce directly, without going via Integer as per the default implementation of fromIntegral.
11:10:01 <yitz> > fromIntegral ((2^63) :: Word64) :: Int64
11:10:02 <lambdabot>  -9223372036854775808
11:10:41 <bb010g> Does UndecidableInstances give runtime performance hits?
11:10:50 <jmcarthur> @check \x -> (fromIntegral (fromIntegral (x :: Word64) :: Int64) :: Word64) == x
11:10:51 <lambdabot>  +++ OK, passed 100 tests.
11:11:03 <ion> “Passed 100 tests, QED.”
11:11:18 <yitz> ion: we need smartcheck around here
11:11:25 <joelteon> @check \x -> fromIntegral (fromIntegral (x :: Word64) :: Int) == x
11:11:26 <lambdabot>  +++ OK, passed 100 tests.
11:11:28 <joelteon> oh, man, I just did that
11:11:31 <joelteon> damn it jmcarthur
11:11:43 <Qfwfq> @smallcheck \x -> fromIntegral (fromIntegral (x :: Word64) :: Int) == x
11:11:43 <lambdabot> Unknown command, try @list
11:12:03 <jmcarthur> not sure smallcheck would be that helpful here anyway ;)
11:12:03 <ion> @check \x -> (fromIntegral (fromIntegral (x :: Word64) :: Word32) :: Word64) == x
11:12:05 <lambdabot>  *** Failed! Falsifiable (after 54 tests and 16 shrinks):
11:12:05 <lambdabot>  4294967296
11:12:10 <SrPx> So, I'm in a 64 bit machine, seems like maxBound Int64 == maxBound Int here. So indeed, I guess I just have to convert the Word64 to Int64 without changing any bits. I have no idea what you are doing though
11:12:18 <jmcarthur> ion: well of course that fails :\
11:12:53 <ion> jmcarthur: I wanted to verify it will actually generate numbers that result in a failure.
11:12:55 <jmcarthur> it is a little sad to rely on Int being the same size as Word64 though. if it was Int64 it wouldn't be so bad
11:12:59 <jmcarthur> ah
11:13:04 * joelteon writes new package: word64-map
11:13:37 <SrPx> joelteon: (:
11:13:52 <SrPx> joelteon: ah I just noticed your nick, cool
11:14:08 <joelteon> thanks :)
11:14:51 <SrPx> so, after all, how do I convert the W64 to Int safely?
11:14:55 <benzrf> i have:
11:14:57 <benzrf> type Command = forall t. Event t [String] -> Moment t (Event t BotTask)
11:15:00 <benzrf> data Bot = Bot {commands :: Map String Command, botInfo :: BotInfo}
11:15:02 <joelteon> SrPx: fromIntegral
11:15:03 <benzrf> it says:
11:15:08 <joelteon> SrPx, what arch is your machine?
11:15:12 <benzrf>  Illegal polymorphic or qualified type: Command
11:15:16 <benzrf> i have RankNTypes on
11:15:18 <benzrf> whats goin on
11:15:25 <SrPx> joelteon: it works even for large ints such as 2^64-2?
11:15:42 <joelteon> SrPx: on a 64-bit machine it should. Word64 is just Int without signedness.
11:15:49 <joelteon> if you're on 32-bit, it won't work for large inputs.
11:16:17 <SrPx> but doesn't fromInteger try to convert it to the right representation? There is no representation for 2^64-2 in an Int64
11:17:07 <joelteon> that's -2, right
11:17:42 <benzrf> pls help
11:17:43 <joelteon> please correct me if I'm wrong #haskell, but SrPx I think that in the case of fromIntegral :: Int -> Word64 that coercion is special-cased in the compiler
11:17:48 <joelteon> because they have the same internal representation
11:17:58 <rwbarton> it would work anyways
11:18:01 <joelteon> so even though you have a value that might not be a valid Word64 the data will be preserved
11:18:15 <rwbarton> Integer -> Int is modulo the appropriate power of 2
11:19:03 <benzrf> @src Integer
11:19:04 <lambdabot> data Integer = S# Int#
11:19:04 <lambdabot>              | J# Int# ByteArray#
11:19:48 <rwbarton> what's special-cased (hopefully) is that the conversion won't actually construct an intermediate Integer object
11:20:27 <joelteon> okay, that sounds better
11:20:43 <SrPx> rwbarton: ah ok then
11:41:32 <benzrf> :t pack
11:41:33 <lambdabot>     Not in scope: ‘pack’
11:41:33 <lambdabot>     Perhaps you meant one of these:
11:41:33 <lambdabot>       ‘BS.pack’ (imported from Data.ByteString),
11:41:34 <SrPx> How do I get the "x" part from a (State a x)
11:41:37 <benzrf> :t BS.pack
11:41:38 <lambdabot> [Word8] -> BSC.ByteString
11:41:48 <ion> @type runState
11:41:48 <benzrf> @hoogle String -> ByteString
11:41:49 <lambdabot> State s a -> s -> (a, s)
11:41:50 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
11:41:51 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
11:41:51 <lambdabot> Prelude error :: [Char] -> a
11:41:53 <ion> @type execState
11:41:54 <lambdabot> State s a -> s -> s
11:42:00 <joelteon> it's evalState
11:42:05 <ion> I always confuse execState and evalState.
11:42:07 <ion> @type evalState
11:42:08 <lambdabot> State s a -> s -> a
11:42:13 <joelteon> Me too. What a weird naming system.
11:42:16 <SrPx> execState did it, thanks
11:42:22 <joelteon> well okay.
11:42:25 <SrPx> I mean I had to replace runState by it (:
11:42:34 <benzrf> well
11:42:40 <benzrf> the way i think about it is
11:42:52 <benzrf> execState executes it but ignores the result
11:43:01 <benzrf> like exec system call vs system system call
11:43:06 <benzrf> evalState gives you the result
11:43:07 <SrPx> makes sense
11:43:16 <SrPx> like `eval` in a prog lang
11:43:17 <joelteon> :t execState
11:43:18 <lambdabot> State s a -> s -> s
11:43:25 <joelteon> I feel like execState and evalState should be swapped
11:43:32 <benzrf> joelteon: oh?
11:43:34 <joelteon> evalState = 'evaluate all the state transitions'
11:43:39 <joelteon> execState = 'execute this state computation'
11:43:45 <benzrf> joelteon: evalState to me means 'evaluate a state mobit'
11:43:55 <joelteon> well, you're weird.
11:44:01 <benzrf> ;)
11:44:25 <benzrf> joelteon: it's because of the naming convention
11:44:33 <benzrf> all of the monads have run<Monad>
11:44:43 <benzrf> therefore i see 'runState' as the run function for the State monad
11:44:47 <benzrf> not as running state
11:45:05 <EvanR_> you evaluate an expression to get a value, you dont execute it
11:45:10 <benzrf> EvanR_: exactl
11:45:12 <benzrf> y
11:45:33 <benzrf> the 'side effects' of the State monad are the state modifications
11:45:36 <EvanR_> you execute a command to get an effect, at least we shouldnt be calling that evaluate
11:45:40 <ion> s/side //
11:45:41 <benzrf> therefore if you 'execute it', that implies running it for its side effects
11:45:50 <EvanR_> in the case of state, its evaluation either way
11:45:57 <benzrf> makes perfect sense to me :-)
11:46:11 <bb010g> Why are foralls not allowed in type family instances? (Ord a) => Set a is kinded *, and there's a type family Ord' a :: * -> *, but Ord' (Ord a => Set a) isn't allowed. I'm not getting the restriction.
11:46:16 <EvanR_> but the idea is that you are emulating the effect with the state value, not the result value
11:56:26 <EvanR_> does anyone use hugs?
11:57:51 <Taneb> EvanR_, hugs is, I gather, somewhat unmaintained
11:58:18 <EvanR_> the site isnt really working
11:59:16 <Taneb> No :(
11:59:22 <Taneb> Any reason you're using hugs?
11:59:54 <EvanR_> im not using it, i was just curious about its state
12:00:18 <EvanR_> in particular i heard something about "better error messages" which is what im reading about right now
12:00:43 <Taneb> I think GHC's error messages have improved since?
12:00:46 <Taneb> Not sure though
12:00:49 <EvanR_> and whether ghc has made advancements in this since then
12:01:04 <zq> how do i tell ghc to use -fllvm by default?
12:04:15 <donri> zq: not sure you can, but you can tell cabal to pass that for your package or all your installs
12:05:29 <Qfwfq> Or possibly `alias ghc='ghc -fllvm'`.
12:06:39 <EvanR_> ghc = ghc -fllvm
12:06:41 <EvanR_> _|_
12:06:41 <donri> sure, but alieases aren't picket up by anything except manual shell invocations :)
12:07:38 <donri> i guess you could write a wrapper script if you were so inclined
12:08:26 <Qfwfq> And then 'cabal' would invoke that version, I hope.
12:09:21 <Qfwfq> Maybe read the NixOS cabal wrapper.
12:10:09 <dagano> > map fromInteger [1,2]
12:10:10 <lambdabot>  [1,2]
12:10:51 <dagano> having a problem with the following :
12:10:55 <dagano> f exp = Data.IntMap.filterWithKey (\k _ -> (elem k exp))
12:11:42 <Qfwfq> Should be fine if exp :: [Int].
12:12:06 <EvanR_> :t elem
12:12:07 <lambdabot> Eq a => a -> [a] -> Bool
12:12:26 <EvanR_> :t Data.IntMap.filterWithKey
12:12:27 <lambdabot> (IS.Key -> a -> Bool) -> IM.IntMap a -> IM.IntMap a
12:12:46 <dagano> if i call with : f [1,2,3] my function works
12:12:46 <dagano> if i let x = [1,2,3] then call with "f x" i get a type error
12:12:48 <dagano>  Expected type: [Key]
12:12:48 <dagano>       Actual type: [Integer]
12:12:55 <dagano> type Key = Int
12:13:13 <EvanR_> dagano: yeah, it says [Integer]
12:13:16 <Qfwfq> let x = [1..3] :: [Int]
12:13:29 <donri> Qfwfq: well you can already configure cabal to do it, so no need to do hacks for that
12:13:32 <dagano> ah i can just 'cast' like that
12:13:39 <dagano> what if the list already exists
12:13:43 <EvanR_> > (3 :: Int) + (4 :: Integer)
12:13:44 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
12:13:44 <lambdabot>              with actual type ‘GHC.Integer.Type.Integer’
12:13:46 <dagano> map fromInteger doesn't seem to be working
12:14:03 <EvanR_> try fromIntegral
12:14:18 <EvanR_> but seems like fromInteger is the right
12:14:45 <dagano> :t fromInteger
12:14:46 <lambdabot> Num a => Integer -> a
12:14:54 <EvanR_> > fromInteger (3 :: Integer) + (4 :: Int)
12:14:55 <lambdabot>  7
12:15:12 <dagano> do i need to do something like (map (fromInteger::Int) [1,2,3]) ?
12:15:12 <EvanR_> > fromInteger (3 :: Integer) + (4 :: SI.Key)
12:15:13 <lambdabot>  Not in scope: type constructor or class ‘SI.Key’
12:15:13 <lambdabot>  Perhaps you meant one of these:
12:15:13 <lambdabot>    ‘IS.Key’ (imported from Data.IntSet),
12:15:13 <lambdabot>    ‘IM.Key’ (imported from Data.IntMap)
12:15:28 <EvanR_> > fromInteger (3 :: Integer) + (4 :: IS.Key)
12:15:29 <lambdabot>  7
12:15:36 <EvanR_> you shouldnt need that, even if it were right
12:15:47 <dagano> mkay thanks .. will mess around with this
12:15:47 <EvanR_> but paste your source code with the error
12:16:57 <EvanR_> :t let f exp = Data.IntMap.filterWithKey (\k _ -> (elem k exp)) in f
12:16:58 <lambdabot> [IS.Key] -> IM.IntMap a -> IM.IntMap a
12:17:18 <EvanR_> :t let xs = [1,2,3]; f exp = Data.IntMap.filterWithKey (\k _ -> (elem k exp)) in f xs
12:17:19 <lambdabot> IM.IntMap a -> IM.IntMap a
12:17:33 <EvanR_> :t let xs = [1,2,3] :: [Integer]; f exp = Data.IntMap.filterWithKey (\k _ -> (elem k exp)) in f xs
12:17:34 <lambdabot>     Couldn't match type ‘Integer’ with ‘Int’
12:17:34 <lambdabot>     Expected type: [IS.Key]
12:17:34 <lambdabot>       Actual type: [Integer]
12:17:44 <EvanR_> :t let xs = [1,2,3] :: [Integer]; f exp = Data.IntMap.filterWithKey (\k _ -> (elem k exp)) in f (map fromInteger xs)
12:17:45 <lambdabot> IM.IntMap a -> IM.IntMap a
12:19:18 <zq> donri: i ended up sticking it into ghc's wrapper script
12:22:39 <waynr> is there a way to use infix operators as prefix operators
12:22:48 <EvanR_> > (+) 1 2
12:22:49 <lambdabot>  3
12:23:09 <waynr> > (>) 3 4
12:23:10 <lambdabot>  False
12:23:19 <waynr> okay, thanks
12:29:46 <Zekka> waynr: Surrounding an operator by () allows you to work with it as a value
12:29:58 <Zekka> just like any other function
12:30:05 <Zekka> (the non-parenthesized syntax is a special ase)
12:31:14 <waynr> i think i'm starting to understand that
12:31:24 <EvanR_> :t (+)
12:31:25 <lambdabot> Num a => a -> a -> a
12:31:58 <waynr> i'm following a tutorial, writing the functions in the way the tutorial shows, then trying to write them in different was using function composition
12:32:48 <EvanR_> :t (+) . (-)
12:32:49 <lambdabot> (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
12:32:56 <EvanR_> urg
12:33:14 <EvanR_> :t (+) .: (-)
12:33:15 <lambdabot>     Not in scope: ‘.:’
12:33:15 <lambdabot>     Perhaps you meant one of these:
12:33:15 <lambdabot>       ‘.’ (imported from Data.Function),
12:33:48 <EvanR_> @define (.:) = (.) . (.)
12:33:49 <lambdabot>  Defined.
12:33:53 <EvanR_> :t (+) .: (-)
12:33:54 <lambdabot> Num b => b -> b -> b -> b
12:35:55 <isomorpheous> Does anyone here use Leksah?
12:36:07 <isomorpheous> If so, what do you think of it?
12:36:10 <bb010g> isomorpheous: I tried to get it to work, but it kept crashing.
12:36:26 <isomorpheous> bb010g: the EclipseFP plugin sucks
12:36:33 <isomorpheous> bb010g: shm is buggy as fuck
12:36:45 <bb010g> isomorpheous: I just use vim w/ a couple of plugins.
12:37:00 <isomorpheous> bb010g: That's disgusting
12:37:05 <EvanR_> lol
12:37:06 <bb010g> isomorpheous: :D
12:37:27 <bb010g> At least I'm not using ed.
12:37:32 <isomorpheous> bb010g: real men have emacs configurations 220K lines in length
12:37:36 <EvanR_> emacs is popular for haskell
12:38:01 <zapds> sublime and lighttable both have pretty good haskell support
12:38:07 <bb010g> isomorpheous: But...the chording...
12:38:10 <Sculptor> why emacs. why not vim. why not memorizing logical key sequences instead of cryptic ones
12:38:13 <isomorpheous> bb010g: evil-mode
12:38:28 <isomorpheous> bb010g: it brings the vi keybindings to emacs
12:38:28 <EvanR_> haskell mode
12:38:30 <isomorpheous> That's what I use
12:38:50 <isomorpheous> Really, it's elisp
12:38:52 <Qfwfq> I just 'cat' my code to a file, and re-enter the duplicate parts whenever I feel the need to change anything.
12:39:02 <isomorpheous> Qfwfq: O_o
12:39:19 <raschwell> Are there common remaps, like in emacs control -> capslock?
12:39:27 <Qfwfq> Oh, I'm sorry, I thought we were doing 'editor wars'.
12:39:31 <isomorpheous> http://xkcd.com/378/
12:39:33 <bb010g> If you're looking for a good backend, neovim should help with that in a couple of months. It'll have way better plugin APIs. You could probably even use Haskell.
12:39:39 <EvanR_> honestly i cant see why more people dont write haskell code with a feather quill pen in light of an oil lamp
12:39:47 <isomorpheous> M-x butterfly is actually a pretty cool command
12:39:59 <Qfwfq> Tim Pope is working on a Clojure-like language that compiles to Vimscript.
12:40:03 <Qfwfq> 'timl' I think.
12:40:14 <bb010g> Ooh.
12:40:14 <isomorpheous> Viml is hilariously awful
12:40:24 <isomorpheous> Elisp is pretty bad
12:40:26 <isomorpheous> But come on
12:40:30 <isomorpheous> You can do better than Viml
12:40:36 <EvanR_> isomorpheous brings the flame
12:40:43 <bb010g> {-# LANGUAGE CPP #-}
12:40:50 <bb010g> *derp*
12:40:53 <bb010g> https://github.com/tpope/timl
12:41:21 <isomorpheous> Okay
12:41:26 <isomorpheous> Now that we're on flame wars
12:41:34 <isomorpheous> What's everyone's favourite lisp dialect?
12:41:41 <bb010g> Also, neovim.org
12:41:43 <Zekka> Why can't any text editors just use modern, sane scripting languages
12:41:55 <Zekka> like, instead of rolling their own crazy one
12:41:55 <joelteon> because the text editors aren't modern or sane
12:41:57 <isomorpheous> Zekka: Because the editors predate the languages
12:42:04 <bb010g> I'd have to go with Racket, probably.
12:42:05 <isomorpheous> Zekka: Emacs is from the mid 1970s
12:42:12 <donri> i like the lisp dialect with dependent types i haven't written yet
12:42:12 <EvanR_> yeah like ruby python and perl
12:42:13 <isomorpheous> bb010g: I've heard good things about Racket.
12:42:16 <EvanR_> sane and modern
12:42:18 <Zekka> isomorpheous: Yeah, I forget how old they are
12:42:33 <EvanR_> and lua
12:42:34 <wz1000> Racket is amazing
12:42:36 <EvanR_> sane and modern
12:42:47 <isomorpheous> Racket looked childish to me
12:42:52 <bb010g> It handles state nicely (for effectual langs).
12:42:54 <Qfwfq> EvanR_: 'vim' has a foreign interface to all of those languages, but I challenge "sane and modern."
12:43:01 <EvanR_> haha
12:43:04 <Zekka> EvanR_: I wish people actually used Yi: I like its scripting interface
12:43:04 <EvanR_> exactly
12:43:14 <Qfwfq> Anyway, this discussion probably belongs in #haskell-blah.
12:43:15 <isomorpheous> Once I learned Haskell, I came to hate scripting languages
12:43:27 <isomorpheous> Qfwfq: fuck off with your relevance
12:43:28 <bb010g> isomorpheous: They have a #language construct that encourages DSLs. I think that's pretty awesome.
12:43:29 <Zekka> last time I stopped by their channel though I was told I was one of two people who had actually tried to use it for anything
12:43:37 <EvanR_> haskell IDE should be scripted in haskell
12:43:46 <bb010g> See also: Yi.
12:43:48 <isomorpheous> EvanR_: There's Leksah and Yi
12:43:58 <isomorpheous> EvanR_: Yi seemed overly complicated
12:44:08 <isomorpheous> EvanR_: I also have the hell configured out of Emacs
12:44:11 <Zekka> Really? I thought it was pretty easy to get started hacking Yi
12:44:16 <isomorpheous> EvanR_: 220K lines of code
12:44:25 <Zekka> I mean, yeah, it's big
12:44:36 <bb010g> I think there's some GSoC work being done on it.
12:45:19 <wz1000> What about Atom? I mean who doesn't like beautiful, bug free, fast and secure javascript in their editor.
12:45:20 <EvanR_> personally i use malbolge backed RNG to output haskell code which is correct by evolution selection by type checker
12:45:36 <bb010g> EvanR: :)
12:45:46 <bb010g> wz1000: Do you use it?
12:45:48 <Qfwfq> :-D
12:45:52 <EvanR_> wz1000: i looked at this, i feel like i have to point and click to get anything done
12:46:01 <wz1000> I was being sarcastic
12:46:01 <joelteon> I think wz1000 is being ironic
12:46:05 <EvanR_> oh
12:46:06 <bb010g> EvanR: Ick
12:46:07 <isomorpheous> Atom isn't actually all that bad.
12:46:08 <Zekka> wz1000: I feel like Atom could be alright in principle because you can program it in lots of languages that aren't Javascript
12:46:11 <isomorpheous> It doesn't have a haskell mode
12:46:19 <isomorpheous> But it didn't look too bad
12:46:24 <isomorpheous> I used it for all of 30 seconds
12:46:26 <Zekka> but I can't get it to build and the devteam basically just comes back to my bug report every two weeks and says "does that still happen?"
12:46:29 <isomorpheous> But it didn't seem too awful
12:46:31 <Zekka> and I say "yes" and then they ignore me for two more weeks
12:46:37 <bb010g> https://github.com/neovim/neovim/wiki/Plugin-UI-architecture
12:46:38 <isomorpheous> Zekka: what distro are you on?
12:46:43 <Zekka> isomorpheous: Ubuntu.
12:46:45 <isomorpheous> Zekka: on Arch, there's a binary
12:46:53 <isomorpheous> Zekka: :/
12:46:59 <wz1000> It's was very slow when I tried it.
12:47:14 <Zekka> There are like six or seven people subscribed to my issue with the same problem and they still just come by every two weeks and say "does it still happen?"
12:47:23 <isomorpheous> Zekka: that's hilarious
12:47:28 <isomorpheous> Has anyone tried libressl?
12:47:32 <isomorpheous> I can't get it to build on Arch
12:47:40 <bb010g> isomorpheous: Didn't they just update?
12:47:49 <isomorpheous> bb010g: libressl or atom?
12:47:55 <bb010g> Libressl
12:48:25 <isomorpheous> The last update was 7 hours ago
12:48:26 <isomorpheous> so yes
12:48:28 <isomorpheous> I'll try again
12:49:07 <dagano> can I use some lambda with Prelude.min on a 2-tuple so that it compares 2nd elements rather than 1st , or do i need to write my own function?
12:49:11 <wz1000> What is the best dependently typed language out there?
12:49:16 <isomorpheous> OpenSSL's CLI is just godawful
12:49:29 <isomorpheous> wz1000: dependently typed?
12:49:33 <pantsman-> Julia
12:49:34 <pantsman-> </troll>
12:49:39 <isomorpheous> dagano: hm?
12:49:43 <isomorpheous> dagano: can you elaborate?
12:49:43 <EvanR_> julia is pretty awesome
12:49:48 <EvanR_> except no concurrency
12:49:59 <wz1000> dagano: look into Control.Arrow
12:50:05 <Zekka> dagano: min `on` fst?
12:50:08 <Zekka> er, min `on` snd?
12:50:10 <bb010g> darthdeus: You should just be able to do \(_,a) (_,b) -> Prelude.min a b
12:50:10 <EvanR_> > min [(1,2),(-1,3)]
12:50:11 <dagano> isomorpheous: so that min (8,3) (2,4) returns (8,3)
12:50:11 <lambdabot>  <[(Integer,Integer)] -> [(Integer,Integer)]>
12:50:16 <dagano> as of now it would return (2,4)
12:50:18 <bb010g> or Control.Arrow
12:50:18 <quchen> dagano: 2-tuples have an Ord instance that compares the first element, and if it's equal it compares the second. If you want different behaviour, you'll have to write that function yourself.
12:50:32 <isomorpheous> dagano: make an instance of Ord for (Int, Int)
12:50:36 <Zekka> https://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Function.html <- 'on' is defined here
12:50:43 <darthdeus> bb010g: uhm what was my question?
12:50:52 <darthdeus> i think you've mistaken me for someone else :P
12:50:55 <EvanR_> min (2,1) (1,2)
12:50:58 <EvanR_> > min (2,1) (1,2)
12:51:00 <lambdabot>  (1,2)
12:51:07 <Zekka> > (min `on` snd) (1, 2) (3, 1)
12:51:09 <lambdabot>  1
12:51:11 <dagano> if i make an explicit instance of Ord for (Int,Int) .. it overrides anything defined elsewhere correct?
12:51:14 <Zekka> Oh, wait, silly me
12:51:27 <EvanR_> dagano: you have to use a newtype wrapper
12:51:34 <Zekka> minimumBy (comparing `on` snd) (1, 2) (3, 1)
12:51:37 <Zekka> > minimumBy (comparing `on` snd) (1, 2) (3, 1)
12:51:38 <lambdabot>  Couldn't match type ‘b0 -> GHC.Types.Ordering’
12:51:39 <lambdabot>                with ‘GHC.Types.Ordering’
12:51:39 <lambdabot>  Expected type: (b0 -> a0) -> (b0 -> a0) -> GHC.Types.Ordering
12:51:39 <lambdabot>    Actual type: (b0 -> a0) -> b0 -> b0 -> GHC.Types.OrderingCouldn't match ty...
12:51:39 <lambdabot>  Expected type: ((t2, t3) -> t) -> b0 -> a0
12:51:43 <bb010g> darthdeus: I thought you were comparing the second elements of 2-tuples...
12:51:44 <EvanR_> or use minimumBy
12:51:49 <Zekka> > minimumBy (comparing snd) (1, 2) (3, 1)
12:51:50 <lambdabot>  Couldn't match type ‘(a1, a0)’ with ‘(t2, t3) -> t’
12:51:50 <lambdabot>  Expected type: ((t2, t3) -> t) -> a0
12:51:50 <lambdabot>    Actual type: (a1, a0) -> a0Couldn't match expected type ‘[(t2, t3) -> t]’
12:51:50 <lambdabot>              with actual type ‘(t0, t1)’
12:51:54 <quchen> dagano: Writing that instance is not even possible (without extensions), and it would also be an orphan instance. That's two reasons not to write an (Int, Int) instance.
12:51:57 <isomorpheous> dagano: http://lpaste.net/107444
12:51:58 <Zekka> oh, wait, it expects a list, doesn't it?
12:52:05 <isomorpheous> dagano: something like that
12:52:06 <Zekka> I'll take it to PMs
12:52:21 <Zekka> > minimumBy (comparing snd) [(1, 2), (3, 1)]
12:52:23 <lambdabot>  (3,1)
12:52:23 <EvanR_> Zekka: minimum does by hes asking about min...
12:52:28 <bb010g> darthdeus: Sorry, meant dagno. *derp*
12:52:50 <darthdeus> bb010g: herp derp :P
12:53:00 <Zekka> EvanR_: Do you think a newtype wrapper is more or less work than rewriting his code to use a lambda or minimumBy?
12:53:11 <dagano> ok thanks folks
12:53:31 <EvanR_> or sortBy
12:53:49 <Zekka> minimumBy is just a case of sortBy, isn't it?
12:54:16 <EvanR_> min is probably the hard way to do whatever hes doing
12:54:21 <Zekka> It's actually defined as foldl1 minBy, apparently
12:54:35 <bb010g> @src Functor (,)
12:54:36 <lambdabot> Source not found. Just try something else.
12:54:36 <Zekka> where minBy is exactly what you'd think in a where clause
12:54:43 <Zekka> http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Data-List.html#minimumBy
12:54:55 <EvanR_> > minBy (comparing snd) (1,2) (2,1)
12:54:56 <lambdabot>  Not in scope: ‘minBy’
12:55:02 <EvanR_> theres no minBy
12:55:04 <Zekka> EvanR_: It's in a where clause
12:55:05 <quchen> bb010g: fmap = (.)
12:55:11 <Algebr> for Control.Category.Category, there's a method that is defined as (Control.Category..) :: cat b c -> cat a b -> cat a c. What does the .. mean after the Control.Category?
12:55:26 <bb010g> quchen: That's for (->)
12:55:27 <EvanR_> Algebr: everything
12:55:28 <quchen> bb010g: Oh wait, I misread.
12:55:55 <Algebr> EvanR_: Everything in that module?
12:56:11 <quchen> bb010g: fmap f (x,y) = (x, f y)
12:56:45 <EvanR_> Algebr: actually ive never seen .. in that position before
12:57:06 <quchen> bb010g: Note that (w,a) is the same as Writer w a.
12:57:07 <Zekka> @src Functor(a,)
12:57:08 <lambdabot> Source not found. :(
12:57:15 <EvanR_> Algebr: link?
12:57:20 <bb010g> Then it could be also be \a b -> snd $ min <$> a <*> b
12:57:23 <isomorpheous> I'm thinking that simultaneously building leksah, yi, and libressl is a bad idea
12:57:28 <isomorpheous> on a shitty old laptop
12:57:34 <Zekka> isomorpheous: Live dangerously!
12:57:37 <Qfwfq> Algebr: (.) in that module.
12:57:38 <bb010g> @src Functor Maybe
12:57:38 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:57:39 <EvanR_> Algebr: looks like its defining .
12:57:52 <zwer> :t (\f -> head . sortBy f)
12:57:53 <lambdabot> (c -> c -> Ordering) -> [c] -> c
12:57:56 <quchen> ?src Maybe fmap
12:57:57 <lambdabot> fmap _ Nothing       = Nothing
12:57:57 <lambdabot> fmap f (Just a)      = Just (f a)
12:58:00 <bb010g> Am I using lambdabot wrong, or has something changed...
12:58:01 <Qfwfq> Generalisation of function composition to arbitrary categories.
12:58:01 <bb010g> Oh
12:58:06 <quchen> Lambdabot @src database: https://github.com/int-e/lambdabot/blob/master/lambdabot/State/source
12:58:07 <bb010g> ?src Functor (,)
12:58:07 <lambdabot> Source not found. Just try something else.
12:58:32 <bb010g> :t \a b -> snd $ min <$> a <*> b
12:58:33 <lambdabot> (Monoid a, Ord b) => (a, b) -> (a, b) -> b
12:58:48 <bb010g> :t min
12:58:48 <lambdabot> Ord a => a -> a -> a
12:59:00 <bb010g> :t (<*>)
12:59:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:59:11 <bb010g> Where's the Monoid from?
12:59:24 <quchen> bb010g: The Applicative instance of tuples
12:59:32 <quchen> pure x = (mempty, x)
12:59:37 <bb010g> Oh
12:59:37 <wz1000> Is there any way to build ghcjs without screwing everything up? What should I use, vagrant, docker or something else?
13:00:04 <wz1000> And I don't feel like switching to Nix
13:00:26 <benmachine> (interestingly, if you have a law-abiding applicative strucutre on tuples, that gives you a monoid structure on the first component, so in fact monoid is /exactly/ what you need)
13:01:15 <bb010g> wz1000: Why not Nix? :)
13:01:40 <wz1000> Don't want to put in the effort
13:01:57 <Qfwfq> You can use Nix without NixOS, and it is simple to install.
13:02:31 <bb010g> Is there a way to access non-exported functions/constructors from a module? I'm making some Data.Set instances and need to use the Set constructors.
13:02:46 <EvanR_> no
13:03:27 <wz1000> Qfwfq: I've had a few bad experiences using different package managers on the same system
13:03:29 <quchen> bb010g: That's the point of not exporting something: it's not available anywhere.
13:03:56 <quchen> What Set instance are you trying to write?
13:04:56 <bb010g> I have a newtype OrdSet a = OrdSet { getOrdSet :: Ord a => Set a } and am making Foldable. I would use GND, but it gets tripped up on the constraint.
13:05:22 <quchen> That constraint is not a good idea there in the first place.
13:05:27 <Qfwfq> wz1000: I like to think of Nix more as an environment manager than a package manager. Outside of 'nix-shell', none of its packages are available (without the hackery it itself performs), and in that state conflicting system packages are overriden if available.
13:05:36 <quchen> bb010g: https://github.com/quchen/articles/blob/master/fbut.md#imposing-constraints-on-data-types
13:05:57 <Qfwfq> wz1000: If you have unexpected package, it's because you haven't specified your environment well enough.
13:07:11 <bb010g> quechen: I'm trying to make a Functor Set, but I need a Ord constraint on Set's argument.
13:07:33 <quchen> You can't (easily) make Set a Functor for that reason.
13:08:19 <quchen> There's `Data.Set.map` to map over a Set.
13:08:45 <wz1000> Why not just use fromList and toList, and recycle the list functor?
13:09:03 <Qfwfq> That sounds fairly expensive.
13:09:18 <bb010g> I'm trying to get an Applicative instance.
13:09:36 <quchen> Since Set can't be a Functor, it can't be an Applicative either.
13:09:56 <bb010g> I figured the Functor instance wouldn't be that hard, but it looks like I'm stuck with just Semigroup & Monoid.
13:11:30 <quchen> Map, a close relative of Set, is a Functor. Maybe try writing an instance for that one?
13:12:39 <bb010g> quchen: I think it already has one.
13:12:56 <quchen> Sure it has. But you're practicing, no?
13:13:06 <quchen> (If Set had a Functor instance it would be there as well.)
13:13:39 <quchen> On second thought, writing Functor for Map is probably a bit backwards since you'd have to use its API to write it anyway.
13:14:04 <bb010g> quchen: I'm actually trying to make a custom Graph for a package manager.
13:14:18 <bb010g> I may end up implementing it a different way, though.
13:14:40 <EvanR_> heh graph with an ord instance
13:15:08 <wz1000> How would you make a graph a functor? What about making it a monad?
13:15:21 <EvanR_> urg
13:15:30 <bb010g> It's not the Data.Graph you're thinking of.
13:15:35 <EvanR_> a functor makes more sense
13:15:57 <EvanR_> what would the monad do?
13:16:09 <quchen> Sounds list-y.
13:16:31 <mwhit> yeah i was going to say combine graphs combinatorially somehow
13:16:33 <mwhit> sounds like a nightmare
13:16:57 <quchen> join = union of all subgraphs
13:17:16 <wz1000> My brain hurts.
13:17:35 <wz1000> An applicative graph kind of makes sense
13:17:39 <wz1000> kind of
13:17:47 <benmachine> bb010g: so, the problem with the idea of making Set a Functor is that you can't really have a Set of things without decidable equality
13:17:55 <quchen> wz1000: Combine a graph of functions with a graph of things those functions can act on? :-x
13:17:59 <benmachine> well, that's one problem with it
13:18:09 <bb010g> With a Graph of Vertecies and Edges, you can have a cliqueSum of just the union of the Verticies and Edges.
13:18:23 <benmachine> it just doesn't make sense to have Set (a -> b) because you can't tell whether an arbitrary (a -> b) is equal to one of its elements
13:18:47 <bb010g> benmachine: I know, but the default Data.Set doesn't require Ord in the type, but in the functions, which messes with fmap.
13:19:17 <quchen> bb010g: No, it requires Ord in the functions only when it actually needs Ord. Set.singleton does not have an Ord constraint, for example.
13:19:35 <benmachine> quchen: it might as well do, to be honest
13:19:35 <quchen> :t S.singleton id
13:19:35 <lambdabot> S.Set (a -> a)
13:19:43 <benmachine> that's not really a useful set
13:19:48 <bb010g> quchen: I get _why_ it doesn't have Ord in the type, but it would be convenient. :)
13:20:01 <quchen> benmachine: It has a well-defined size, for example.
13:20:08 <benmachine> quchen: ...great? :P
13:20:49 <bb010g> That's why I was trying to make OrdSet, but they don't export the necessary constructors. I would have to pretty much manually overhaul the Data.Set source.
13:20:50 <quchen> benmachine: You can check whether it's null. You can filter it. You can retrieve elements by index.
13:21:13 <benmachine> quchen: yes but you can't do any actual *set* operations on it
13:21:18 <bb010g> Or just export the constructors, I guess.
13:21:37 <quchen> You can map over it. You can fold it. You can find its minimum element.
13:21:38 <benmachine> bb010g: the argument I gave applies regardless of whether or not you have the constructors; I'm claiming that the idea is nonsense
13:21:42 <benmachine> well, not nonsense
13:21:43 <EvanR_> bb010g: you can require Ord on the things in your OrdSet
13:21:43 <quchen> All of these are Set API functions.
13:22:00 <EvanR_> in the functions
13:22:02 <quchen> In other words, you can still do a lot with a "non-Ord Set".
13:22:13 <benmachine> bb010g: to claim that f is a Functor is to say "I can store whatever I like in this thing"
13:22:29 <benmachine> quchen: you can't map over it unless the codomain of your map is Ord
13:22:29 <bb010g> EvanR_: I know; that's the point. fmap needs the input and the output to be the same types, but only the output of fmap would have Ord.
13:22:47 <benmachine> quchen: and in any case you can't make a set that's not a singleton or empty
13:22:50 <quchen> benmachine: Sure, but that's independent of what's in the set we're talking about.
13:23:00 <mwhit> depending on what you want to do, you can jsut use MonoFoldable:
13:23:01 <mwhit> https://hackage.haskell.org/package/mono-foldable
13:23:15 <mwhit> err https://hackage.haskell.org/package/mono-traversable
13:23:38 <EvanR_> bb010g: oh right youre trying to make a Functor instance, yeah so were back to the original problem
13:23:44 <EvanR_> no functor for sets
13:23:58 <benmachine> bb010g: a general functor has separate "shape" and "contents", but in a Set the shape is dependent on the contents
13:24:09 <mwhit> there's a monofunctor class in that package, basically does what you want
13:24:37 <benmachine> (what I'm saying is vague but can be made precise for Traversable functors)
13:25:37 <bb010g> benmachine: Can't you make a Functor that satisfies the laws on an ordered set?
13:25:58 <benmachine> bb010g: what do you mean by "on an ordered set"?
13:26:00 <bb010g> id wouldn't change the contents and thus the shape
13:26:16 <EvanR_> btw
13:26:24 <bb010g> A hypothetical Set with an Ord constraint on the contents always
13:26:26 <EvanR_> the map in set is literally doing what someone suggested already http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.5.5.1/src/Data-Set-Base.html#map
13:26:34 <EvanR_> tolist . map . fromlist
13:26:41 <EvanR_> er other way around
13:26:57 <wz1000> Anyone ever write a join instance for graphs
13:26:57 <benmachine> bb010g: you would have to make the (not entirely unreasonable) constraint that all Ord instances only considered things equal if they really were
13:27:17 <quchen> There are two ways to map over a Set, both of them can't be used to make it a Functor. a) Set.map requires an Ord constraint for the codomain, which fmap cannot have; b) Set.mapMonotonic does not require an Ord constraint, but allows construction of bad data, which fmap should not have.
13:27:21 <bb010g> benmachine: ...Isn't that what Ord does?
13:27:24 <Algebr> What is Arrow?
13:27:41 <benmachine> bb010g: well, for example the ord instance for Set considers two distinct trees equal if they have the same elements
13:28:09 <bb010g> benmachine: Ok...
13:28:31 <Qfwfq> Algebr: You can think of it as a generalisation of function composition. Read the class definition.
13:28:38 <Qfwfq> @src Arrow
13:28:38 <lambdabot> class Arrow a where
13:28:38 <lambdabot>     arr, pure   :: (b -> c) -> a b c
13:28:38 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
13:28:38 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
13:28:38 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
13:28:40 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
13:28:42 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
13:28:44 <Qfwfq> A generalisation of functions, rather.
13:29:06 <quchen> Qfwfq: Category is the generalization of composition, Arrow is a bit more.
13:29:20 <benmachine> bb010g: so, suppose there was some way of observing that, e.g. if the constructors were exported
13:30:04 <benmachine> bb010g: then you could have sets a and b which appeared equal according to Ord, but a function f such that f a and f b were not equal (according to some other type class instance)
13:30:05 <bb010g> benmachine: And fmap (g.h) = fmap g . fmap h would work because the instances of merging h would be when items were identical, which would happen also in g because they are the same inputs and therefore the same outputs. I don't see why shape changing would break the Functorness.
13:30:48 <benmachine> bb010g: then you define g such that g . f = id, and you have fmap (g . f) = id, but fmap g . fmap f can't be id because fmap f (fromList [a,b]) only has size 1
13:30:48 * hackagebot definitive-filesystem 1.2 - A library that enable you to interact with the filesystem in a definitive way.  http://hackage.haskell.org/package/definitive-filesystem-1.2 (MarcCoiffier)
13:30:50 * hackagebot definitive-graphics 1.2 - A definitive package allowing you to open windows, read image files and render text to be displayed or saved  http://hackage.haskell.org/package/definitive-graphics-1.2 (MarcCoiffier)
13:30:52 * hackagebot definitive-parser 1.2 - A parser combinator library for the Definitive framework  http://hackage.haskell.org/package/definitive-parser-1.2 (MarcCoiffier)
13:30:54 * hackagebot definitive-reactive 1.0 - A simple Reactive library.  http://hackage.haskell.org/package/definitive-reactive-1.0 (MarcCoiffier)
13:30:56 * hackagebot definitive-sound 1.0 - A definitive package to handle sound and play it back  http://hackage.haskell.org/package/definitive-sound-1.0 (MarcCoiffier)
13:31:03 <benmachine> bb010g: mapping over a set can reduce its size but can't increase it
13:31:12 <bb010g> benmachine: It's not a problem if the constructors aren't exposed, though. The only reason I wanted them exposed was because I was trying to re-implement some instances.
13:31:27 <benmachine> bb010g: right, but as soon as they're exposed you run into the problem I just described :)
13:31:33 <benmachine> which is actually kind of a coincidence
13:31:42 <benmachine> just so happens that the best type to break Set is Set itself
13:32:24 <bb010g> An ordered set with no exported constructors would work as a Functor, though, right? I don't get your second reply.
13:32:35 <EvanR_> i didnt think about that, mapping over a set changes its size
13:32:41 <EvanR_> makes no sense
13:32:46 <EvanR_> in functor terms
13:32:53 <bb010g> EvanR_: It's not against the laws, though.
13:32:59 <EvanR_> no?
13:33:18 <benmachine> EvanR_: not immediately, but I'm trying to argue that it makes the laws really difficult to hold
13:33:32 <benmachine> bb010g: okay, so the fact that I've used Set as an element type in this example is pretty confusing
13:33:52 <bb010g> I get it if the constructors are exposed.
13:34:04 <benmachine> bb010g: I'm just using it as an example of a type that could have an Ord instance such that compare a b == EQ, but there might be some bijective function f such that compare (f a) (f b) /= EQ
13:34:16 <quchen> EvanR_: fmap (const "hello") would be a valid thing to do, given a Functor instance of Set.
13:34:24 <benmachine> bb010g: if that ever happens with any type, your Functor fails a law
13:34:30 <quchen> EvanR_: The result is of course a singleton set with only "hello" in it.
13:34:34 <bb010g> But if they're held _and_ there's an OrdSet that's identical save for the constraint, it would work.
13:35:00 <EvanR_> quchen: im guessing this is exactly what Set.map does
13:35:04 <quchen> EvanR_: Yup
13:35:34 <bb010g> EvanR_: Except there's an Ord constraint on the b in (a -> b) -> Set a -> Set b
13:36:00 <EvanR_> yes on a and b
13:36:07 <quchen> No, only on b.
13:36:08 <benmachine> bb010g: does my example make sense yet?
13:36:12 <EvanR_> eh?
13:36:18 <EvanR_> funky
13:36:30 <quchen> > S.map (const "hello") (S.singleton id)
13:36:31 <bb010g> benmachine: I get your example, but it depends upon inspection of the implementation of a Set instance.
13:36:31 <lambdabot>  fromList ["hello"]
13:36:40 <benmachine> bb010g: no, it doesn't
13:36:51 <EvanR_> this set library is a house of fun
13:36:57 <bb010g> benmachine: Could you give an example?
13:36:58 <benmachine> bb010g: it just depends on *some* data type *somewhere* having an Ord instance or an Eq instance that's not preserved by every function
13:37:19 <bb010g> benmachine: Wouldn't that be a bad instance of the other type, then?
13:37:31 <benmachine> bb010g: well, maybe :)
13:37:33 <quchen> EvanR_: It demands Ord when it needs Ord. mapping doesn't need Ord in the domain. Conceptually, "map f" just applies "f" to every element to get a new Set, which may need to be rearranged.
13:37:43 <quchen> So only in the resulting Set there is need for comparisons.
13:37:51 <benmachine> bb010g: some people would definitely argue that yes, that's a bad instance
13:38:07 <EvanR_> quchen: right
13:38:11 <benmachine> bb010g: some people would argue that it's an OK instance if you can only do it by looking in an Internal module or something
13:38:26 <benmachine> bb010g: some people would argue that it's an OK instance anyway
13:38:34 <bb010g> benmachine: So, with proper instances for types, there would be no problem for an ordered set type that doesn't allow internal inspection.
13:38:42 <EvanR_> quchen: but like benmachine was saying there would be no point to using Set on stuff without Ord
13:38:46 <benmachine> bb010g: another good example is Data.ByteString.Lazy, for which toChunks exposes that ==-wise equal things are not
13:40:02 <quchen> EvanR_: It's a degenerate use case. I haven't needed it, but it would be very awkward to add the unnecessary Ord constraints.
13:40:18 <quchen> EvanR_: Like the absence of IO, the absence of an Ord constraint says "there will be no use of Ord".
13:40:29 <benmachine> bb010g: you would need to argue that the Data.ByteString.Lazy instances should change, or that toChunks should go away
13:40:35 <quchen> If your comparison is expensive, that's valuable information.
13:40:36 <EvanR_> quchen: nah, seems like a good place to put the API
13:41:02 <EvanR_> the programmer would be notified early if they accidentally used the wrong type
13:41:05 <benmachine> quchen: I don't think it is valuable information because I think any real use of a set will give rise to the constraint anyway
13:41:28 <bb010g> benmachine: It seems fine as long as you state that use of the function can break Law x for Class y.
13:41:40 <rio> it looks like you are trying to find a haskell analog for the powerset functor in category theory, are you?
13:41:43 <benmachine> bb010g: but the writer of bytestring might know nothing about containers
13:41:50 <benmachine> bb010g: and vice versa
13:41:53 <quchen> benmachine: Sure you can think that, but the way it is it's statically verified that nothing goes wrong.
13:42:10 <benmachine> quchen: I claim that no-one ever uses that fact
13:42:18 <bb010g> benmachine: Stick it in a separate module that you have to inport, like Data.ByteString.Lazy.Unsafe
13:42:39 <benmachine> bb010g: but it's only unsafe if people insist that Ord/Eq have to have the semantics you require
13:42:45 <benmachine> bb010g: clearly *someone* thinks otherwise
13:43:01 <benmachine> and, it's not like bytestring is a niche or poorly-designed library
13:43:09 <bb010g> benmachine: Ord/Eq themselves *require* their laws to be met; hence *laws*
13:43:11 <benmachine> someone probably quite respected had the opinion that this sort of thing was OK
13:43:26 <benmachine> bb010g: but the thing I'm describing *isn't* a law of Ord/Eq as far as I'm aware
13:43:40 <quchen> Eq and Ord don't really have any laws besides "make instances with good intentions".
13:44:03 <benmachine> yep, according to the docs I can find, Eq has literally no laws
13:44:22 <EvanR_> (0/0) == (0/0)
13:44:24 <benmachine> whatever laws Ord has, I promise Float breaks them :P
13:44:24 <bb010g> I'd consider "the things have to be (not) equal" to be a law.
13:44:26 <EvanR_> False
13:44:37 <quchen> > ((0/0) == (0/0)) == ((0/0) /= (0/0))
13:44:38 <bb010g> benmachine: Nobody likes Float. :D
13:44:39 <lambdabot>  False
13:44:43 <rio> benmachine: it would be useful to make Eq reflexive, symmetric and transitive
13:44:44 <benmachine> bb010g: you can consider things all you want, it's not in the docs so it's not a law :P
13:45:00 <mwhit> that's not even possible as a law of Ord/Eq is it? if it holds for type a, and I write a type b for which it *doesnt* hold, and a function (a->b), i've externally invalidated the law for type a
13:45:03 <bb010g> rio++
13:45:30 <bb010g> mwhit: You've invalidated all functions that depend on that function *and* your type.
13:45:31 <benmachine> rio: I think I would agree with that
13:45:41 <quchen> Float ruins the show again
13:45:45 <rio> i.e. an equivalence relation
13:45:59 <bb010g> mwhit: If they never touch your type, they don't deal with your problems.
13:46:01 <benmachine> rio: however that's (a) not the case at the moment (b) false for Float, as described (although I think that should be fixed) and (c) not enough to save bb010g
13:46:04 <EvanR_> there should be a NonFloat type class
13:46:15 <EvanR_> and things that rely on laws depend on it ;)
13:46:41 <bb010g> I have to go for a bit, but thanks for the insight. Pleasure conversing with you gentlemen/ladies.
13:46:59 <rio> bb010g: be safe :]
13:47:04 <EvanR_> im trying to find some archived discussion about the set functor thing
13:47:25 <quchen> Hmm, NaN /= NaN here.
13:47:32 <quchen> I would have expected … well I wasn't sure what to expect.
13:47:43 <EvanR_> its not equal in ieee754
13:47:57 <quchen> I was expected to be surprised I guess, which I was.
13:48:00 <benmachine> quchen: :P
13:48:08 <bb010g> I may try to make that OrdSet later; I'll put it here if I do.
13:48:11 <benmachine> the result was surprisingly unsurprising
13:48:22 <rio> just get rid of NaN
13:48:37 <benmachine> rio: I don't think you need to do that, just have Eq and Ord have non-IEEE semantics on it
13:48:49 <benmachine> and provide the IEEE comparisons as named functions in Data.Whatever
13:48:54 <EvanR_> id get rid of nan
13:49:02 <EvanR_> and infinity
13:49:12 <rio> it literally says it's not a number
13:49:25 <quchen> EvanR_: But I like my infinity.
13:49:31 <benmachine> Float is an evil you have to live with, I think
13:49:49 <benmachine> avoid it where you can, but it's going to be lurking somewhere for you
13:50:12 * EvanR_ gives quchen an exception
13:50:14 <benmachine> there's nothing necessarily wrong with infinity, imo
13:50:27 <quchen> Infinity makes a fine number, even in mathematics.
13:50:41 <EvanR_> yeah but not if im trying to use floats to do integer arithmetic
13:50:49 <EvanR_> or rational
13:50:54 <rio> quchen: depends on what you think a "fine" number is
13:51:12 <quchen> rio: And on what you think a "number" is :-)
13:51:32 <benmachine> EvanR_: if you're trying to use floats to do arbitrary-precision arithmetic you are just choosing tools incorrectly
13:51:34 <joelteon> and what you think "makes" means
13:51:38 <rio> i like my numbers to form a ring at least
13:51:57 <benmachine> rio: there are plenty of sensible numbers which don't
13:52:05 * quchen likes making small circles around infinity
13:52:05 <EvanR_> not arbitrary precision
13:52:15 <benmachine> e.g. ordinal/cardinal numbers
13:52:29 <benmachine> octonions, perhaps
13:52:58 <joelteon> onions are great
13:53:08 <quchen> Onion rings!
13:53:27 <rio> now we're cooking
13:53:31 <EvanR_> i wonder what opengl does with vertexes positioned at NaN
13:53:32 <nys> now we're kuchen
13:53:42 <rio> mmmh kuchen :]
13:53:52 <quchen> (That's where my name comes from.)
13:54:25 <nys> :D
13:54:35 <quchen> Anyway, I've had a case where (==) on Double was useful. I'm still looking for a good use case for foldl to get my Haskell knighthood.
13:55:19 <EvanR_> find a use case for 1 tuples
13:55:37 <quchen> EvanR_: Identity?
13:55:56 <quchen> Booya :-þ
13:55:58 <joelteon> you mean, like 'a'?
13:55:59 <EvanR_> what
13:56:21 <EvanR_> how does it help Identity
13:56:26 <benmachine> quchen: you mean as opposed to foldl'?
13:56:31 <quchen> Well, Identity is the 1-tuple.
13:56:33 <quchen> benmachine: Yes
13:56:52 <benmachine> quchen: ah. um, preventing apostrophe key wear?
13:57:13 <quchen> Best guess so far! :-)
13:57:23 <quchen> But there apparently is a story of someone needing foldl and not foldl'.
13:57:51 <EvanR_> they are trying to demonstrate stack overflow
13:58:12 <EvanR_> and foldl' cant do it
13:58:12 <quchen> http://www.well-typed.com/blog/90/  --  This mentions a valid use case for foldl.
13:59:19 <EvanR_> reading this, interesting to think there is no observable difference up to running out of memory
14:00:45 <quchen> I guess if your function can short-circuit and the thunk it itself builds is larger than what you need to run through the entire list, foldl is preferrable.
14:00:52 <benmachine> that's not true, foldl and foldl' do actually differ in what they force to be evaluated
14:01:13 <benmachine> it's just that usually you don't care about the difference :P
14:01:17 <benmachine> (almost always)
14:01:26 <quchen> Sure, but suppose "f _ c = c", then
14:01:27 <quchen> > foldl f z [a,b,c] :: Expr
14:01:28 <lambdabot>  f (f (f z a) b) c
14:01:44 <quchen> It would be useful to not force the other fs, if f is very expensive.
14:02:28 <benmachine> quchen: sorry, wasn't saying "that's not true" in response to you
14:02:37 <benmachine> quchen: your example there is very much like the "last" example
14:02:40 <quchen> Oh.
14:03:12 <benmachine> I suspect it's less efficient than the direct definition of last
14:03:31 <benmachine> i.e. what you say is true, but if you don't actually need the thunk then you're better off not even creating it
14:03:37 <benmachine> rather than creating it and throwing it away unevaluated
14:03:59 <EvanR_> would a strictness analysis automatically take care of a foldl doing the "wrong thing"
14:04:07 <quchen> Yeah, I'm just trying to come up with a potential use case. But you're right, it heads a bit into the "last" direction, which is a fairly artificial example.
14:04:50 <EvanR_> to me whatever foldl does wrong also goes wrong in general code, most of which (at least my code) needs to get run and im not putting strictness annotations
14:05:01 <EvanR_> i was told strictness analysis
14:05:37 <benmachine> EvanR_: it's often the case that foldl can become foldl' with strictness analysis
14:05:40 <benmachine> often but not always
14:06:03 <benmachine> especially in the cases where the transformation is unsafe in the presence of bottoms and only you know that there aren't any
14:06:04 <EvanR_> so should the programmer often care
14:06:35 <benmachine> EvanR_: I don't have enough experience to know how often typical programmers should care
14:07:05 <suOya_> > randomRIO (False, True) >>= (\x -> if x then return "Germany" else return "Argentina") >>= (\s -> putStrLn (s ++ " wins!"))
14:07:06 <EvanR_> is there a ghc flag which assumes nothing has any bottoms anyway
14:07:07 <lambdabot>  <IO ()>
14:07:11 <EvanR_> anywhere
14:07:27 <benmachine> I suspect it is still the case that people seeking to write high-performance Haskell, or Haskell that works on nontrivial amount of data, need to know about the performance implications of poor strictness
14:07:41 <benmachine> EvanR_: I doubt it, because that's almost never the case
14:07:51 <benmachine> (I'd guess)
14:08:07 <benmachine> like, try using any IO functions, at all
14:08:09 <quchen> EvanR_: -funbox-everything? :-)
14:08:19 <EvanR_> IO functions throw exceptions
14:08:52 <benmachine> EvanR_: I suppose that is different
14:08:54 <EvanR_> to me this seems like a different thing than a thunk deep in my pure computation will fail to terminate
14:09:22 <benmachine> still, having undefined behaviour on use of 'error' is going to lead to bad things
14:09:34 <benmachine> go learn Idris :P
14:09:38 <EvanR_> yeah exactly
14:09:39 <Cale> EvanR_: There's this GHC flag called Agda
14:09:47 <benmachine> heh
14:09:49 <benmachine> that too
14:09:58 <EvanR_> bottom sucks
14:10:07 <benmachine> EvanR_: programming sucks
14:10:19 <quchen> Petition to fund solving the Halting Problem, sign now
14:10:20 <EvanR_> 19th and 20th century programming sucked ;)
14:10:32 <EvanR_> need to get with a new program
14:10:36 <benmachine> EvanR_: have you *tried* statically proving that *all* your functions terminate? good luck with that
14:10:49 <avocado> what is 19th century programming?
14:10:51 <benmachine> EvanR_: dont' get me wrong, I think it's the future, but it's emphatically not the present :P
14:10:58 <EvanR_> ada
14:10:59 <benmachine> avocado: difference engines, presumably
14:11:03 <EvanR_> lol
14:11:21 <Cale> quchen: Didn't someone prove that obtaining funding for that was impossible? :D
14:11:36 <EvanR_> benmachine: yeah i got stuck writing pacman because i could not figure out how to write the type so that references never pointed to the wrong nodes and stuff
14:12:00 <EvanR_> obtaining funding for impossible things is totally possible
14:12:09 <quchen> Cale: There was this "freelancer ebay" thing where someone wanted a program to check other programs for termination with a lot of entries by Gödel etc, if that's what you mean.
14:12:12 <isomorpheous> Hey, I'm having trouble with quickcheck
14:12:17 <isomorpheous> here's the test file -http://lpaste.net/107446
14:12:42 <isomorpheous> Here's the error - http://lpaste.net/107447
14:12:52 <isomorpheous> I think it's because my function needs two arguments
14:13:07 <EvanR_> benmachine: that is, non existent nodes, Map.lookup being Nothing, which i said would be impossible, yet could not bring myself to use fromJust
14:13:23 <quchen> isomorpheous: There is no line 36 in your pasted source, which is where the error comes from.
14:13:37 <Cale> isomorpheous: It's ambiguous at which type you want to apply testOrdering
14:14:14 <isomorpheous> Cale: even though testordering is explicitly typed?
14:14:37 <Cale> isomorpheous: Its type is polymorphic, and it computes something different based on which type you use it at
14:14:45 <isomorpheous> Ah
14:14:47 <isomorpheous> okay
14:14:56 <isomorpheous> So, perhaps use numbers
14:15:29 <Cale> isomorpheous: Yeah, you could write  quickCheck (testOrdering :: Tropical Double -> Tropical Double -> Bool)
14:16:06 <Cale> isomorpheous: Also, your instance of Arbitrary looks weird
14:16:20 <Cale> isomorpheous: Is Tropical really a data constructor?
14:16:49 <Cale> In compareTropical, you match on Infinity, but the instance of arbitrary you wrote will never produce that.
14:19:16 <Algebr> Is there a way for ghci/ghc to dump out what a do block looks like desugared?
14:19:24 <Cale> Lambdabot can do it
14:19:40 <isomorpheous> Cale: Here's what I have now - http://lpaste.net/107448
14:19:51 <Cale> @undo do v <- x; w <- y; let { a = v + w }; return (a,v,w)
14:19:51 <lambdabot> x >>= \ v -> y >>= \ w -> let { a = v + w} in return (a, v, w)
14:20:09 <isomorpheous> Cale: how do I get arbitrary to also make Infinity objects?
14:20:58 <hiptobecubic> @do x >>= \v -> y >>= \w -> let {a = v+w} in return (a, v, w)
14:20:58 <lambdabot> do { v <- x; w <- y; let { a = v + w} in return (a, v, w)}
14:21:09 <hiptobecubic> @undo @do x >>= \v -> y >>= \w -> let {a = v+w} in return (a, v, w)
14:21:10 <lambdabot> <unknown>.hs: 1: 1:Parse error: @
14:21:12 <quchen> isomorpheous: 'frequency' from QuickCheck.Gen might be what you're looking for.
14:21:18 <Cale> isomorpheous: The easiest way to get a high quality generator would be to use the one for Maybe
14:21:31 <hiptobecubic> i thought there was a way to have recursive lambdabot commands, wasn't there?
14:21:51 <Cale> arbitrary = do m <- arbitrary; case m of Nothing -> Infinity; Just x -> Tropical x
14:21:56 <Cale> er
14:22:03 <Cale> stick a return in there
14:22:12 <Algebr> @undo do response <- simpleHTTP $ myRequest "poon"; html <- getResponseBody response; let {doc = readString [withParseHTML yes, withWarnings no] html; rows <- runX $ doc >>> css "td" //> getText;printrows
14:22:12 <lambdabot> <unknown>.hs: 1: 151:Parse error: <-
14:22:29 <Cale> fmap (maybe Infinity Tropical) arbitrary   would also work
14:22:49 <Algebr> ha, lambdabot also has a @do
14:22:51 <hiptobecubic> the `maybe` function is underused
14:23:12 <Cale> hiptobecubic: In real code, I often end up replacing it with a case expression eventually
14:23:29 <quchen> (Maybe's Arbitrary instance just chooses Nothing with 1/4 probability using 'frequency', if you want different probabilities you'll have to roll your own generator.)
14:23:55 <Cale> It's easy to make your code a bit less easy to read or modify using the maybe function.
14:24:03 <Cale> But sometimes it's exactly what you want
14:24:16 <isomorpheous> Cale: here's my current thing - http://lpaste.net/107449
14:24:24 <isomorpheous> Cale: thoughts?
14:24:57 <Cale> isomorpheous: That'll work, but you might like the probability of Infinity to be a little lower.
14:25:24 <isomorpheous> Cale: hm
14:25:27 <isomorpheous> Cale: yeah
14:25:27 <Cale> (which is why I recommended hijacking the Maybe instance, which lowers the probability of obtaining Nothing a bit)
14:26:39 <EvanR_> replicateM arbitrary fmapped on several maybes ;)
14:26:48 <EvanR_> 1/4 1/8 /16 ...
14:26:58 <isomorpheous> Cale: http://lpaste.net/107451
14:27:06 <EvanR_> er 4 16 64
14:27:26 <Cale> isomorpheous: yeah
14:28:53 <quchen> EvanR_: Using <|> you can approximate anything with arbitrary precision! :-D
14:34:14 <beckyconning__> hi iam new to haskell! do i want to install the os x platform before or after i run the clang wrapper script?
14:34:28 <mzero> either way
14:34:31 <mzero> makes no difference
14:34:35 <mzero> er
14:34:35 <mzero> no
14:34:38 <mzero> run it after
14:34:52 <mzero> silly me!
14:35:14 <mzero> (I should know better... I wrote the wrapper!)
14:35:19 <beckyconning__> haha! : )
14:35:22 <beckyconning__> thanks!
14:36:03 <beckyconning__> so run the clang wrapper script and then run the installer?
14:36:40 <mzero> no - exactly the opposite
14:36:42 <mzero> run the installer
14:36:46 <mzero> then run the clang-wrapper
14:36:48 <beckyconning__> kk : )
14:36:59 <Algebr> what clang-wrapper?
14:37:12 <beckyconning__> http://www.haskell.org/pipermail/haskell-cafe/2013-October/111174.html
14:37:32 <mzero> If you are on a Mac where "gcc" is really Clang (basically 10.9, or anything using Xcode 5 or later)
14:37:33 <Cale> I believe it should tell you if you do it in the wrong order
14:37:43 <mzero> then you need "the clang wrapper" for GHC 7.6.3
14:37:55 <Cale> (The wrapper script installer will complain that you don't have HP installed)
14:38:04 <mzero> actually - it does: It tells you there is nothing to "fix" when you run it before you install the HP
14:38:36 <mzero> and -- as soon as HP 2014.2.0.0 is out.... the wrapper will be a thing of the past! woot!
14:41:14 <isomorpheous> Other than ordering, what should I test?
14:41:41 <sshine> cool, someone answered my 11 month old Alex question on StackOverflow.
14:42:45 <isomorpheous> Question
14:42:52 <isomorpheous> My library is a math library
14:43:06 <isomorpheous> I've been using unicode chars for the math notation in the documentation
14:43:10 <isomorpheous> is there a better system?
14:43:16 <joelteon> no reason not to
14:43:27 <SrPx> I've noticed something. Every time I want to change some structure I use, I have to perform a *lot* of code modifications. For example, say I'm using lists in a file. Then I decide to change it by arrays. I need to change the code in a lot of places.
14:43:47 <joelteon> yep
14:43:49 <SrPx> Now I'm thinking, shouldn't this be an easier process, considering the API is the same?
14:43:50 <EvanR_> good thing the compiler tells you about it
14:44:11 <SrPx> EvanR_: that is true, it is not a hard process, at least. The compiler helps a lot. Still boring, though.
14:44:12 <mzero> SrPx: Well... it isn't the same, actually! Hence why you have to change alot
14:44:25 <EvanR_> list and array are pretty different
14:44:30 <joelteon> the identifiers aren't even the same, except to the uneducated eyes of humans :)
14:44:42 <mzero> in other langauge systems, the API is superficially the same (say, some of the methods are named the same short string) --- the semantics are different, and your code may or may not work
14:44:43 <SrPx> But when all I'm using is the common  subset of those... appending elements, accessing, etc...
14:45:03 <joelteon> the only thing common about them is their name
14:45:08 <sshine> SrPx, you could introduce a layer of abstract syntax if you use arrays and lists in the same way. then you only need to update one set of functions. I think it is a quite common practice to carve out a set of helper combinators as you progress. falling back to them means only changing theam.
14:45:47 <EvanR_> SrPx: appending and accessing lists and arrays isnt even spelled the same way?
14:46:14 <EvanR_> or the same api
14:46:16 <SrPx> yes, no?
14:46:19 <`Jake`> @pl (\x -> x + max 2 (x * 0.2))
14:46:19 <lambdabot> ap (+) (max 2 . (0 . 2 *))
14:46:20 <Algebr> mzero: So is ghcforosx the way to go from now on on osx? no more haskell-platform?
14:46:33 <mzero> Not at all
14:46:41 <mzero> Haskell Platform 2014.2.0.0 will go alpha this week
14:46:49 <`Jake`> Oh, so lambdabots pl doesn't parse Floating point numbers, apparently
14:47:03 <geekosaur> platform builds are being collected now for various platforms
14:47:30 <mzero> ghcforosx is an interesting approach - but doesn't perhaps set up as much of the envinronment as the platfrom does... and it doesn't come with anything besides the core (GHC) packages.
14:48:01 <mzero> for example, the HP will take care of the whole gcc/clang issue on installation, and will handle switching between two or more HP installs.
14:48:23 <geekosaur> ghcforosx is an easier way to have multiple versions of ghc installed, compared to ghc bindists (personally I'd still use hsenv), bit not really a replacement for the platform
14:48:28 <mzero> it also will set your .cabal/config up to have full profiling, and doc by defaut
14:50:16 <beckyconning__> i think i'd definitely like to try that out eventually but for now i just want to get started trying out some of the basic haskelly things i've read about
14:50:38 <mzero> then Haskell Platform is your friend
14:51:03 <mzero> and don't worry about it being GHC 7.6.3 -- if you're just getting going, you'll be fine with that for months before you get to stuff that 7.8.3 can do...
14:54:51 <beckyconning__> i'm coming from javascript app development where i do a lot of monad-style stuff and generally write stuff functionally (lots of recursion, flow control, as few void methods as frameworks allow etc). i've not written with a 'proper' type system before though so its quite exciting : ). i might even learn some proper maths lol!
14:55:29 <EvanR_> you might end up with an advance degree in mathematics
14:55:42 <mzero> or just coming to loath coding in JavaScript!
14:55:47 <bitemyapp> beckyconning__: it is extremely unlikely you used monads in JavaScript
14:55:57 <bitemyapp> beckyconning__: we're glad to see you're learning new things
14:56:03 <beckyconning__> bitemyapp: this is why i said 'monad-style' : P
14:56:14 <EvanR_> like what, chaining?
14:56:14 <sshine> bitemyapp, how come?
14:56:26 <bitemyapp> beckyconning__: that's a misappropriation of the word monad.
14:56:33 <bitemyapp> beckyconning__: if you mean method-chaining, you could say that.
14:56:33 <beckyconning__> bitemyapp: no they support left, right and assoc : P
14:56:57 <sshine> ah, foo().bar().baz()-style calls where each method returns its own object for further calls?
14:57:05 <bitemyapp> which has nothing to do with monads.
14:57:14 <EvanR_> beckyconning__: what allows left right and assoc, coffee script?
14:57:19 <mzero> (and why are you assuming that is what beckyconning__ was referring to?)
14:57:27 <Cale> It's possible to be using particular monads in Javascript, but actually using the abstraction is hard, because you pretty much have to pass around dictionaries as explicit parameters.
14:57:34 <bitemyapp> mzero: probability based on past experience.
14:57:44 <beckyconning__> and are made up of kleisli triples : P
14:57:49 <bitemyapp> mzero: what Cale said matches my experience. Trying to do the "real thing" instead of slapping the word on something that isn't a monad is quite difficult.
14:58:00 <bitemyapp> mzero: if Crockford can get it wrong, who can get it right in that community?
14:58:20 <bitemyapp> OTOH, if they knew what a kleisli triple is, benefit of the doubt may be in order.
14:58:24 <Cale> It sounds like beckyconning__ knows what monads actually are though, so I have a bit more confidence :)
14:58:34 <bitemyapp> Cale: right.
14:58:43 <bitemyapp> beckyconning__: you are a rare thing. Congrats.
14:59:00 <bitemyapp> beckyconning__: I'll try to find the other 2 javascript users that know what monads are for you, so you can have a meetup.
14:59:01 <EvanR_> screw monads
14:59:09 <bitemyapp> EvanR_: screw arrows.
14:59:15 <sshine> I don't really know what a monad is yet.
14:59:45 <EvanR_> btw im one of the other two js users who knows what monads are
14:59:45 <Cale> With some smallish tweaks, Arrow would be an excellent abstraction.
14:59:46 <bitemyapp> I think I've convinced myself I know what a monad is, but I think I'm lying and just mechanically applying laws and types.
14:59:59 <sshine> Cale, in javascript, you mean?
14:59:59 <bitemyapp> which works brilliantly, for the record.
15:00:14 <Cale> sshine: This last comment is for Haskell
15:00:52 <EvanR_> beckyconning__: im curious to know what javascript thing you are using with all this "monad-like" stuff
15:00:54 <Cale> sshine: My earlier comments were about applying monads in Javascript or other languages without anything such as type classes.
15:01:22 <bitemyapp> or higher kinded types.
15:01:25 <sshine> Cale, can't you achieve some overloading through prototypes?
15:01:35 <Cale> sshine: It's hard to really apply the abstraction in a way which counts. In order to actually be making use of the fact that something happens to be a monad, you need to be able to write code which will work with an arbitrary monad.
15:01:43 <beckyconning__> yeah i think i'm not clever enough to say they are real monads cos i don't know types and category theory and stuff
15:01:51 <beckyconning__> but they are definitely 'monad-style'
15:01:52 <sshine> Cale, e.g. use an object's prototype bind-operator
15:01:57 <Cale> sshine: and in order to do that, you end up taking the implementation of return and bind as an explicit parameter
15:02:13 <Cale> return is particularly tricky
15:02:16 <Cale> :t return
15:02:17 <lambdabot> Monad m => a -> m a
15:02:17 <EvanR_> and example of something that would be nice in javascript that you can easily do is a MaybeT or ExitT monad, which lets you backtrack from deeply nested calls
15:02:33 <EvanR_> ... cant easily do
15:02:34 <Cale> ^^ it's polymorphic in its result type in a way which is impossible to determine from its argument alone
15:03:18 <Cale> (i.e. if you see an occurrence of "return v" somewhere, you can't tell from the type of v which monad is in use, you need to get that from the context)
15:03:33 <bitemyapp> Cale: tag-driven development lol
15:03:41 <sshine> maybe if return could create an object in which it doesn't actually know what kind of monad it is untill bound to an action.
15:03:57 <Zekka> :t return "fisk"
15:03:57 <lambdabot> Monad m => m [Char]
15:04:01 <Zekka> sshine: Like that one?
15:04:10 <EvanR_> Cale: i would be very interested to see something like Cont work in javascript
15:04:32 <Cale> sshine: anyway, the right way to do it is just to add a parameter to both return and bind, which is the monad to use
15:04:56 <dagano> i have a bizarre data handling question: i have data like the following :
15:04:57 <dagano> fromList [(3,(2,1)),(4,(1,3))]
15:04:57 <sshine> Cale, but... sugar!
15:05:01 <Cale> sshine: But that's just awkward enough that you'll probably hate yourself for trying to use the abstraction, unless you really really care.
15:05:37 <Cale> and tbh, the stuff you get from knowing that something happens to be a monad isn't a big enough deal to care that much
15:05:40 <Cale> (typically)
15:05:43 <dagano> and i want the tuple (3,2) from it ... because the 1 in the 2nd tuple of the first tuple is less than the 3 in the second tuple of the second tuple
15:05:45 <Zekka> sshine: You can basically implement do notation using Reader over the monad type and get the same sugar
15:05:46 <dagano> ugh
15:06:11 <Cale> The whole point of writing instances of Monad in Haskell is to get all the stuff like sequence and mapM and whatnot from Control.Monad for free.
15:06:43 <EvanR_> you can do that in js with passing the dictionary, and its not a monad benefit its a typeclass benefit
15:06:49 <Cale> If we didn't have the typeclass, you'd probably just implement whatever of that stuff made the most sense for your specific case by hand.
15:07:01 <EvanR_> im curious to see Cont work, or Exit
15:07:04 * sshine sees a point in knowing when something is a monoid.
15:07:35 <sshine> but *shrug* it's probably equally inconvenient without typeclasses.
15:07:51 <beckyconning__> here is a question: can you have a monad that calls a bound function more than once? or is it something else then?
15:07:57 <Cale> EvanR_: The main purpose in recognising that certain type constructors happen to be monads is so that we can use code which will work with any monad.
15:08:01 <beckyconning__> like in my head its like an event monad type thing
15:08:24 <Cale> beckyconning__: Sure, if I understand what you mean
15:08:26 <EvanR_> Cale: yeah, or applicative or monoid
15:08:41 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a)
15:08:45 <Cale> instance Monad Tree where
15:08:51 <Cale>   return v = Leaf v
15:09:06 <Cale>   Leaf x >>= f = f x
15:09:23 <Cale>   Branch l r >>= f = Branch (l >>= f) (r >>= f)
15:10:19 <Cale> beckyconning__: The function is being applied at all the leaves of the tree, and the resulting trees spliced in at each point.
15:10:49 <beckyconning__> Cale: cool : ) i know some of those words!
15:10:54 <bitemyapp> could make a tree doubler function. Leaf x -> Branch (Leaf x) (Leaf x)
15:10:59 <Cale> Or for instance, the list monad
15:11:08 <Cale> return v = [v]
15:11:14 <Cale> xs >>= f = concat (map f xs)
15:11:38 <Cale> You apply the function f to each of the elements of the list xs, obtaining a list of lists, which are then concatenated
15:11:42 <EvanR_> bitemyapp: crash on a branch? ;)
15:11:48 <Cale> > [1,2,3] >>= (\x -> [x, 10*x])
15:11:49 <lambdabot>  [1,10,2,20,3,30]
15:12:13 <bitemyapp> EvanR_: huh?
15:12:23 <EvanR_> bitemyapp: i guess fail triggers
15:12:48 <beckyconning__> Cale: oh cool : )
15:12:48 <EvanR_> your function does not handle Branch
15:13:02 <beckyconning__> this is all really exciting!
15:13:09 <bitemyapp> EvanR_: this is like when people tell me I'm not being pedantic enough in my 140 character tweets.
15:13:13 <bitemyapp> EvanR_: are you one of those people?
15:13:25 <EvanR_> yes
15:13:46 <sshine> Cale, hm... concat only appears when the tree becomes n-ary. peculiar. couldn't there be some kind of instance of a fixed-width tree type in which fmapping over a tree resulted in a tree of trees?
15:13:53 <bitemyapp> "22:11 Ignoring ALL from EvanR_" - thanks for the warning
15:14:12 <Cale> sshine: Not sure what you mean there
15:14:57 <Cale> sshine: Every monad instance is to some extent like the one for lists, in that  x >>= f = join (fmap f x)  is always the case
15:15:19 <Cale> sshine: where  join :: M (M a) -> M a  and  fmap :: (a -> b) -> M a -> M b
15:18:51 <sshine> Cale, for your tree type above, what would join perform in join (fmap id integerTree)? I seem to miss a dimension here.
15:19:44 <beckyconning__> ok i made a little maybe monad-style thing, am i thinking along the right lines? http://jsfiddle.net/NC92C/ i want to learn the proper way either way lol : ) and obvs its kinda messed in with some sort of oo stuff i guess i could refactor that and make it flat functional instead but its kinda harder to use with js lol
15:20:17 <Cale> sshine: join (Leaf t) = t; join (Branch l r) = Branch (join l) (join r)
15:20:29 <bitemyapp> beckyconning__: in what way is .bind returning a Maybe value?
15:20:34 <bitemyapp> :t (>>=)
15:20:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:20:49 <bitemyapp> beckyconning__: you have Maybe a, but you're not returning Maybe b.
15:21:02 <bitemyapp> beckyconning__: see why doing this in an untyped language is hard?
15:21:09 <bitemyapp> there's no discipline or clarity.
15:22:06 <EvanR_> the .bind with an action on the end is the js chain-style
15:22:08 <bitemyapp> beckyconning__: you'd have an easier time getting it right by doing it in Haskell first, transcribing to JS after it's proven sound.
15:22:18 <beckyconning__> bitemyapp: hey don't have a go at me i'm in here for a reason : P i get paid to write js and thats not my fault : x i'm trying to work out how to be clever like you and learn this stuff.
15:22:19 <EvanR_> not called the right thing in haskell terms
15:22:33 <bitemyapp> I'm not having a "go" at you, I'm highlighting why this is hard.
15:22:48 <bitemyapp> I'm also asking where the Maybe value went with alert
15:23:23 <beckyconning__> alert is a function that takes a string
15:23:30 <Zekka> It's easier to do a lot of this stuff in Haskell
15:23:37 <bitemyapp> beckyconning__: and returns nothing.
15:23:48 <bitemyapp> :t (>>=)
15:23:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:24:16 <bitemyapp> alert is supposed to be (a -> m b) but doesn't satisfy that type because it doesn't return Maybe.
15:24:26 <sshine> beckyconning__, it should preferrably take a string and return yet another maybe..
15:24:32 <EvanR_> .bind f is returning the value returned by executing f
15:24:37 <bitemyapp> beckyconning__: part of the reason I use Haskell to teach FP is it sweeps away the nonsense and fuzziness.
15:24:45 <bitemyapp> beckyconning__: you'd be better off focusing on learning Haskell.
15:24:51 <bitemyapp> beckyconning__: https://github.com/bitemyapp/learnhaskell
15:25:11 <sshine> bitemyapp, I'm linking to your github repo on my website :)
15:25:13 <beckyconning__> bitemyapp: apart from i don't get paid to do that and thats why i'm spending my free time, in hospital, learning haskell : P
15:25:27 <benmachine> bitemyapp: while in general I agree that there are a lot of advantages to learning haskell, you're coming off as kind of dismissive of people who do anything else
15:25:34 <bitemyapp> I don't know what getting paid has to do with it.
15:25:46 <beckyconning__> also i see what you mean about the default returning maybe its not returning a monad and it should be so i messed up : P
15:25:46 <bitemyapp> benmachine: I've seen people attempt this 'monads in something untyped' over and over
15:25:53 <beckyconning__> bitemyapp: being able to eat : P
15:25:57 <bitemyapp> benmachine: you can only watch people cliff dive without a parachute so many times
15:26:02 <benmachine> bitemyapp: then stop watching
15:26:05 <bitemyapp> beckyconning__: are you somehow unable to learn unless you're racking up hours?
15:26:09 <bitemyapp> benmachine: dude, go away.
15:26:12 <sshine> beckyconning__, eating is this side-effect that some Haskell programmers don't get ,)
15:26:42 <bitemyapp> people pay money to learn, such as with university. You can learn Haskell for free, which would seem to be massively better than paying lots of money.
15:26:56 <beckyconning__> if i missed a deadline i'd be kicked out of my house, i've got time to learn haskell cos i'm in hospital XD
15:26:59 <benmachine> bitemyapp: this is seriously not the venue for judging people's life choices
15:27:21 <beckyconning__> so let me fix that example and get back to you : )
15:27:32 <benmachine> bitemyapp: if you can't be kind about how you give advice then your advice is worse than useless
15:27:42 <bitemyapp> beckyconning__: a suggestion, if you're going to do something with Maybe and a String, try a function that "validates" the contents of the string.
15:27:59 <mmmm> Is there a good way to profile memory usage?
15:28:03 <bitemyapp> beckyconning__: then think about how to chain validations.
15:28:14 <int3__> benmachine: sigh, I'm sure he meant well. terseness and unkindness aren't the same thing, although one is easily mistaken for the other.
15:28:18 <quchen> mmmm: Do you know the RWH chapter on profiling?
15:28:18 <EvanR_> or bails early on the first occurrence of null
15:28:20 <merijn> mmmm: Yes, Real World Haskell has a chapter on doing that
15:28:27 <bitemyapp> beckyconning__: Just "1" >>= isThisANumber >>= isThisLessThanTen
15:28:39 <bitemyapp> beckyconning__: see if you can do something like that using the scaffolding you set up.
15:28:58 <bitemyapp> or more realistically (return "1") >>= isThisANumber >>= isThisLessThanTen
15:29:11 <benmachine> int3__: I appreciate that, I really do, but sometimes even people who mean well can cause more harm than good
15:29:30 <bitemyapp> benmachine: I don't really care what people that don't teach have to say, as a general rule.
15:29:37 <sshine> bitemyapp, as a TA, I tried using a bind-operator in an intro FP course with Standard ML. only one monad (Maybe, then Either String), no typeclasses, was still somewhat convenient.
15:29:44 <bitemyapp> benmachine: this is difficult for most to swallow, but it's the truth.
15:30:02 <bitemyapp> sshine: anything ML based is going to be a lot easier than JS, lol.
15:30:13 <bitemyapp> sshine: did you hear about MultiMLTon?
15:30:21 <benmachine> bitemyapp: do you mean teach professionally, or what?
15:30:27 <sshine> bitemyapp, I did not.
15:30:29 <EvanR_> no, this channel is peculiar for having a record low amount of attitudes like bitemyapp's
15:30:35 <EvanR_> theres not really any justification
15:30:46 <Zekka> For what it's worth, I don't think defining types/typeclass instances from Haskell would necessarily be that hard in a language lke Javascript,  but I think learning about them might be
15:30:57 <bitemyapp> has nobody noticed that I directed them to a more productive way to validate the Maybe monad?
15:31:07 <bitemyapp> I've spent more time helping them than any of the complainers have, so far.
15:31:16 <bitemyapp> and instead of helping them, you're complaining about the person helping them.
15:31:20 <benmachine> bitemyapp: to say that you've done something wrong is not to say that you've done nothing right
15:31:23 <bitemyapp> self-parody that isn't funny
15:31:30 <bitemyapp> sshine: may interest you: http://multimlton.cs.purdue.edu/mML/Welcome.html
15:31:41 <bitemyapp> benmachine: shush.
15:32:14 <benmachine> bitemyapp: I like that you're helping people, but I want you to not antagonise people while you do it, and I don't think that's too much to ask
15:32:28 <bitemyapp> benmachine: dude, not in here and not right now.
15:32:44 <bitemyapp> benmachine: help the person. Be a shining light.
15:32:48 <sshine> bitemyapp, it does, but I've sort-of vowed to pause a little on parallel programming. :)
15:32:56 <mmmm> thanks quchen merijn
15:33:11 <bitemyapp> sshine: this is how I teach P&C generally: http://chimera.labs.oreilly.com/books/1230000000929
15:33:22 <EvanR_> Zekka: with a chaining-only syntax for it, it would at best be crippled
15:33:23 <bitemyapp> sshine: it's an excellent book and Marlow was very kind to make it freely available.
15:33:32 <EvanR_> Zekka: you cant compose chain segments
15:33:33 <bitemyapp> sshine: has one of the best explanations of WHNF and laziness I've seen.
15:33:35 <EvanR_> since they arent first class
15:33:48 <sshine> bitemyapp, I've got a bookmark in it somewhere.
15:34:01 <Zekka> EvanR_: I feel like there's a serious language barrier
15:34:06 <quchen> bitemyapp: Oh? I'm still not sure what exactly WHNF is.
15:34:07 <bitemyapp> sshine: I think Marlow's book makes the subjects pretty approachable, relative to most texts.
15:34:18 <bitemyapp> quchen: are you being insincere?
15:34:26 <Zekka> Even if  you translate them it's hard to get the neatness
15:34:47 <quchen> bitemyapp: No, I'm being serious here. I have a working knowledge of what WHNF is, and maybe I could get the definition together as well. But I don't know what it actually means.
15:34:52 <EvanR_> Zekka: but the chaining style is really popular, and in switch this is used to implement a first-order maybe-like thing, which thoretically will cure people from the null pointer exception issue
15:34:54 <Infandum> I'm making an application using haskell. I'm trying to decide between a desktop app and a web app. What's everyone's opinion for a "future-proof" app?
15:35:06 <EvanR_> its just not monads
15:35:07 <bitemyapp> quchen: have you read the book I linked?
15:35:09 <Infandum> Also the ease of use for guis on haskell for web apps vs desktop apps
15:35:27 <Zekka> Infandum: If you write a web app you won't have to deal with areas Haskell's historically a little weak in like desktop gui libraries
15:35:31 <EvanR_> Zekka: i meant to say swift
15:35:38 <sshine> Infandum, REST. you can write the front-end whichever way you like and change it later.
15:35:38 <bitemyapp> quchen: here's the section on laziness in general, I don't know how much of it would be new for you: https://github.com/bitemyapp/learnhaskell#laziness-strictness-guarded-recursion
15:35:53 <hiptobecubic> And there's haskell->JS or purescript
15:35:58 <hiptobecubic> And threepenny
15:35:59 <bitemyapp> quchen: Marlow's book is more to the point if you want to understand NF, WHNF, etc.
15:36:41 <EvanR_> Infandum: for desktop app i would do everything in opengl ;)
15:36:44 <sshine> Infandum, I'm in the same situation, and I've currently decided to make a REST server in Haskell and a front-end in JavaScript. if I don't like the front-end, I'll make a GUI in Java instead.
15:36:54 <Zekka> Why Java?
15:36:54 <EvanR_> glfw-b
15:36:59 <sshine> Zekka, because I like Swing :)
15:37:01 <platz> Sensing the Dunning–Kruger effect.  'Do you know stats?' person 1: yes i know standard deviation.  Person 2: I mean I've taught a few graduate-level stats classes, but I don't really know stats
15:37:03 <Zekka> I'm pretty sure applets aren't supported in a lot of places anymore
15:37:08 <sshine> Zekka, I know, it's a fetish.
15:37:09 <hiptobecubic> sshine, christ, seriously?
15:37:10 <quchen> bitemyapp: My current knowledge is that NF, HNF and WHNF are certain levels of "evaluatedness", and I remember hearing that certain functions terminate iff its argument is in some *NF. For practical purposes (i.e. in Haskell) I would say I understand the concepts quite well.
15:37:15 <bitemyapp> platz: that's my suspicion.
15:37:18 <bitemyapp> but in reverse
15:37:19 <sshine> hiptobecubic, yeah. usually it's the part people hate.
15:37:26 <quchen> bitemyapp: Marlow probably explains the "practical for Haskell" part.
15:37:31 <bitemyapp> quchen: yes, he does.
15:37:36 <Infandum> sshine: So you'll avoid doing any kind of GUI in haskell?
15:37:41 <sshine> hiptobecubic, I'm sure GUI programming has advanced since Swing.
15:37:42 <StoneCypher4k> ahh, dunning krueger, how redditors who haven't read the paper feel superior to people in what they think is a fancy way
15:37:54 <hiptobecubic> sshine, you are literally the first person i've ever even heard of that prefers it over other toolkits
15:37:54 <bitemyapp> quchen: I mean, are you looking for a rigorous exploration of graph reduction?
15:37:58 <Krenium> I've never seen a gui library I've liked
15:38:01 <sshine> Infandum, not at all. but I'm granting myself the freedom to choose. also, if someone joins the project, they can make a client in whatever language they like.
15:38:06 <bitemyapp> quchen: your standard for grokhood is probably higher than most.
15:38:14 <hiptobecubic> sshine, and it looks so bad! It's hideous. Worse than tk.
15:38:18 <sshine> Infandum, only thing I'm certain of is that I want the back-end in Haskell.
15:38:19 <Zekka> I wrote a GUI library a while back that I liked OK, but I don't know if anyone else would like it
15:38:28 <Zekka> (not for Haskell, but for terminal applications)
15:38:31 <sshine> hiptobecubic, I only have experience with Swing and Tk.
15:38:32 <bitemyapp> quchen: you probably understand beta redex fine.
15:38:34 <Zekka> er, and for*
15:38:39 <quchen> bitemyapp: Yes.
15:38:50 <sshine> hiptobecubic, and HTML/JavaScript/CSS. which is honestly my preference right now.
15:39:01 <bitemyapp> quchen: I'm afraid I'm just at the informal level, probably weaker than you are. So I don't know what good papers on graph reduction are.
15:39:14 <Infandum> hmm. Basically I'm deciding between qt and yesod/happstack/snap
15:39:27 <bitemyapp> quchen: but I know that's the search query I'd use to try to hunt for material.
15:39:34 <sshine> Infandum, you'd have to try them and decide for yourself. I ended up with Snap.
15:39:37 <Infandum> whichever has the easiest drag and drop and variable layout is prefered
15:40:15 <Infandum> sshine: The only issue is that I've never programmed a gui before (since high school at least, which was forever ago)
15:40:23 <sshine> Infandum, the only GUI framework I've seen recommended by people I trust is Qt. I've never touched it myself.
15:40:23 <Infandum> sshine: Let alone a web app
15:40:52 <EvanR_> all toolkits suck
15:40:52 <benmachine> sshine: you can actually write HTML and JavaScript in Haskell, sort of
15:40:54 <quchen> bitemyapp: I guess I just really don't know much about lambda calculus in general. I don't know how to express an ADT there, for example. The problem is the books I've seen were either too basic or too complicated for me. (Maybe the answer is in the complicated parts ...)
15:40:55 <sshine> Infandum, there's certainly a learning curve. and you can make websites (and GUIs in general, I suppose) in a lot of wrong ways. there's a lot of event handling and wiring.
15:41:39 <bitemyapp> quchen: well, comfort with lambda calculus is definitely what's needed then.
15:42:07 <bitemyapp> quchen: a goal you could set is being able to represent and reduce lambdas according to WHNF vs. NF with pen and paper.
15:42:20 <Infandum> sshine: I started writing it in threepenny-gui but I realized that I would rather have a native or web based app as opposed to a weird combo of both. Also, it's lacking in tutorials. When I was using it, there was also a lot of biolerplate code which drove me NUTS and made me curse GUIs haha.
15:42:25 <quchen> bitemyapp: "According to"? Those aren't evaluation strategies, are they?
15:42:40 <Infandum> sshine: And threepenny-gui was supposed to be anti boilerplate!
15:42:45 <benmachine> quchen: they tell you when to stop
15:42:55 <sshine> Infandum, I don't know threepenny-gui. and I am on the same page as you wrt. either web or native.
15:43:02 <bitemyapp> quchen: have you tried http://www.cs.ox.ac.uk/files/293/lazy.pdf ?
15:43:36 <sshine> Infandum, my front-end is a cash register for a food cooperative. another front-end is a webshop. the back-end keeps track of sales and deliveries.
15:44:06 <Infandum> sshine: Nice! And it's working well?
15:44:06 <jle`> bb010g: sorry, was out during your reply.  did you figure out your answer?
15:44:24 <Infandum> sshine: Why did you choose snap over happstack and yesod?
15:44:28 <quchen> bitemyapp: I didn't know that one yet, thanks!
15:44:30 <bitemyapp> quchen: http://homepages.inf.ed.ac.uk/wadler/topics/call-by-need.html#need-journal http://www.itu.dk/~sestoft/papers/sestoft-lamreduce.pdf
15:44:34 <sshine> Infandum, I've only just started. all my venturing into Snap and REST have so far been toy apps (a small online banking thing, a webshop, etc.)
15:44:57 <bitemyapp> quchen: np, hope that helps.
15:45:04 <Infandum> sshine: True, but you must have chose it for a reason
15:45:51 <bb010g> jle`: Ish. :) Sorry about some things, I was sleepy. If you look back to around 20 UTC you should see the conversation.
15:46:38 <bitemyapp> quchen: I added those links to the guide: https://github.com/bitemyapp/learnhaskell#laziness-strictness-guarded-recursion
15:48:38 <quchen> bitemyapp: Oh, in the setsoft-lamreduce the table on normal forms looks golden.
15:48:52 <quchen> Superficially this might be exactly what I had been looking for.
15:48:57 <jle`> bb010g: read over this and see if it helps you make your degenerate Functor typeclass :) http://blog.omega-prime.co.uk/?p=127
15:49:06 <jle`> degenerate is probably the wrong word
15:49:09 <joelteon> so uh
15:49:15 <joelteon> why would "cabal get" be saying "cabal: does not exist"
15:49:17 <joelteon> cabal definitely exists
15:49:32 <EvanR_> lol
15:49:34 <jle`> bb010g: this goes over the same thing http://jeltsch.wordpress.com/2013/02/14/the-constraint-kind/
15:49:43 <bitemyapp> quchen: I hope it leaves you feeling more grokky. Leave me a message (I check lastlogs) please so I know how it turned out in the end and what you liked the most.
15:49:47 <bb010g> jle`: I messed around with those, but couldn't get anywhere.
15:50:15 <dcoutts> joelteon: it's complaining that something else, probably a file, does not exist. But it's swallowing part of the exception info in the way it formats the error message.
15:51:41 <bb010g> jle`: That second article may help, however. Thanks.
15:51:41 <jle`> bb010g: :/ do you have any code up?
15:52:03 <jle`> bb010g: np; it mostly goes over the same thing iirc but it's worth a shot
15:52:21 <lysergide___> Hi
15:52:22 <lysergide___> http://pastebin.com/BEB22TY7
15:52:28 <lysergide___> I get
15:52:29 <lysergide___> haskell.hs:19:13: parse error on input `<-'
15:52:37 <lysergide___> It is a code from a tutorial.
15:52:40 <EvanR_> whitespace?
15:53:00 <quchen> Whitespace.
15:53:21 <jle`> lysergide___: you need to align "people_text" with "putStr"
15:53:24 <EvanR_> needs more whitespace
15:53:27 <jle`> and...everything else
15:53:30 <jle`> heh
15:53:31 <quchen> ?quote Cale layout
15:53:32 <lambdabot> Cale says:  'let', 'do', 'of', and 'where' are the layout keywords. The first non-whitespace character following one of these sets the column that you must align subsequent lines to in order to continue the block. The first line which is shallower will close the block, and deeper lines will continue a previous line.
15:53:47 <bb010g> jle`: I'd have to redefine Functor, though, from the looks of it. :(
15:53:49 <jle`> i got a fever
15:54:05 <jle`> and the only prescription is
15:54:07 <jle`> more whitespace
15:54:08 * EvanR_ plays doctor mario music
15:54:12 <lysergide___> jle`: It does not work
15:54:25 <jle`> bb010g: yeah :)  well, you are essentially defining something very different than a Functor
15:54:26 <lysergide___>     parse error (possibly incorrect indentation or mismatched brackets)
15:54:44 <jle`> lysergide___: post your new code :)  are you alining the "entire" rest of the file to putStr?
15:54:49 <bb010g> jle`: Not really; I just want Ordered sets.
15:54:50 <jle`> lysergide___: also, be sure you are using spaces and not tabs
15:54:57 <jle`> bb010g: you already have ordered sets?
15:55:11 <lysergide___> Oh tabs are a problem?
15:55:22 <jle`> bb010g: you want to be able to map functions on ordered values on ordered sets
15:55:27 <quchen> lysergide___: Yes. https://github.com/quchen/articles/blob/master/fbut.md#tabs-vs-spaces
15:55:27 <jle`> bb010g: this is very different from Functor
15:55:45 <bb010g> jle`: Sets where the contents are Ord, always. (I know there are cases where it can be useful to have the constraint in the function, see the conversation around 20:00 UTC)
15:55:58 <jle`> bb010g: there are cases where it'd be useful, and your new type is useful
15:56:01 <jle`> bb010g: er, new typeclass
15:56:10 <jle`> bb010g: but it is very different than what Functor is supposed to be
15:56:15 <bb010g> jle`: That's what I'm trying now.
15:56:17 <bb010g> jle`: How so?
15:56:18 <jle`> at its core
15:56:19 <lysergide___> http://pastebin.com/r2HBxN7G
15:56:26 <lysergide___> So here is the new code.
15:56:28 <bb010g> jle`: It would follow the laws...
15:56:29 <EvanR_> i was confused by this earlier bb010g, you are doing ordered sets, like sets where elements keep their order with respect to each other, and can be swapped. or just a set using Ord as an implementation detail
15:56:34 <jle`> Functor is supposed to be able to map *anything*
15:56:44 <bb010g> Not ordered sets, just sets of Ord elements.
15:56:47 <jle`> that is at the heart of it
15:56:47 <EvanR_> ok
15:56:54 <quchen> lysergide___: Everything from line 18 needs to be indented by the same amount of whitespace.
15:57:18 <jle`> it's clear from the type of fmap, fmap :: Functor f => (a -> b) -> f a -> f b
15:57:22 <lysergide___> http://pastebin.com/7wsSwbkq
15:57:27 <bb010g> newtype OrdSet a = OrdSet { getOrdSet :: Ord a => S.Set a }
15:57:29 <lysergide___> Now I get haskell.hs:22:10: parse error on input `='
15:57:30 <bb010g> That
15:57:32 <jle`> "give me your tired, your weary, your a -> b, anything..., and i'll change an f a into an f b"
15:57:38 <quchen> lysergide___: Looks good now.
15:57:44 <beckyconning__> btw bitemyapp i wasn't saying you were wrong at any point, or that i knew what i was talking about i just found the way you put it to be really discouraging. i think people respond to different types of re-enforcement, but for me i already think i'm super stupid so for everything i have been doing to get to this point to be dismissed as useless chucks away
15:57:44 <beckyconning__> my achievements and makes me feel as if i am so incapable of learning this stuff. if it wasn't for a couple of people in channel messaging me to say not to get discouraged i probably would have left and not come back : P. so yeah, especially as you are a teacher i would err on the side of positive re-enforcement so you don't leave your students with less
15:57:44 <beckyconning__> confidence behind, but thats just me.
15:57:48 <beckyconning__> i'm gonna fix this javascript monad-ish thing first (obvs the bound function needs to return a "monad") and then carry on with installing haskell platform.
15:57:57 <quchen> lysergide___: Oh.... hold on, you have a "let" in there.
15:57:59 <bb010g> jle`: I know, but the f would have the Ord constraint in it.
15:58:04 <jle`> the type signature of fmap broadcasts that Functor does not discriminate, and it can't "care" about what is inside
15:58:10 <lysergide___> I should not use let?
15:58:19 <quchen> lysergide___: http://lpaste.net/107452
15:58:25 <jle`> Functor isn't allowed to "care" about what the items are, or what the function is
15:58:30 <bb010g> jle`: Yeah, I know I need a new type now.
15:58:34 <jle`> yeah, it's a new typeclass
15:58:38 <quchen> lysergide___: "let" opens a new block inside the "do" block, so it has a new alignment level.
15:58:41 <jle`> it has similar ideas to Functor
15:58:46 <jle`> but it is different on a fundamental principle
15:58:50 <quchen> lysergide___: See the paste I just posted.
15:59:00 <jle`> because the fundamental principle is different, of course it is a different typeclass :)
15:59:21 <jle`> it's like why Maybe and List are different types;  yeah, they can both represent an absense of values, or the presence of values
15:59:30 <jle`> but List represents any number of values whereas Maybe represents 0 or 1
15:59:39 <jle`> they are similar in many ways...but there is a fundamental difference too
15:59:43 <jle`> so they are different types
15:59:51 <bb010g> "I want a new type / One that won't make me sick / One that won't make me crash my GHC"
16:00:05 <lysergide___> quchen: Thank you. Why do I have to do 4 spaces below the let
16:00:08 <lysergide___> and not 2 spaces
16:00:17 <jle`> Functor, and your constrained Functor-like thing...are similar in many ways, but different enough that they do not represent the same fundamental ideas
16:00:25 <jle`> nothing wrong with that :)
16:00:31 <tomejaguar> n
16:00:46 <quchen> lysergide___: The type signature you're writing after the "let" defines where the block begins. Everything after that should be aligned with that.
16:01:17 <lysergide___> Oh okay I get it, thank you very much !
16:01:49 <EvanR> im diving into this... ive got this ruby AST, im going to write a damned type inferencer for it
16:02:02 <EvanR> or bust
16:02:07 <quchen> bitemyapp: So NF is either a lambda with a body in NF, or a value applied to terms in NF. HNF either a lambda with body in HNF, or a value applied to arbitrary terms. Correct so far?
16:02:20 <quchen> (Trying to make sense of this in the context of what I already read some time ago)
16:02:59 <quchen> bitemyapp: NF smells a lot like Control.DeepSeq. I mean I knew that's what that module (almost) does, but I didn't realize how very close it comes.
16:03:11 <quchen> (Almost because of a->b)
16:03:16 <beckyconning__> tl:dr you could have just pointed out that alert doesn't return a monad and that a proper type could have helped me avoid that issue rather than preaching to the new choir member : P
16:03:53 <beckyconning__> anyway feeling self conscious now so i'll shut up! ty!
16:04:13 <quchen> beckyconning__: Don't worry about it too much. Your goal is noble, but choosing JS to reach it is not optimal.
16:04:21 <quchen> Maybe whoever you were talking to had a bad day or something.
16:04:22 <benzrf> why can't i use a type synonym that has a forall in it in my data decl
16:04:25 <quchen> Don't be discouraged!
16:04:27 <benzrf> i have RankNTypes on
16:04:37 <benzrf> it suggests ImpredicativeTypes
16:04:58 <geekosaur> sounds right?
16:05:47 <benzrf> ok...
16:06:27 <beckyconning__> quchen: i guess the point is that i would never have chosen to learn haskell if it wasn't for javascript? i liked how i could do stuff with functions in javascript more easily than i could with procs and lamdbas in ruby so i learnt js in my free time and eventually a different job doing javascript, and then i became more and more functional (less and less
16:06:27 <beckyconning__> state) and learnt about promises and monad type stuff which lead me towards haskell so now i'm here : )
16:06:28 <jle`> benzrf: what is your data teclaration
16:06:42 <jle`> benzrf: it does depend on where it is
16:06:52 <jle`> ImpredicativeTypes is needed for stuff like Maybe (forall a. a -> a)
16:06:53 <benzrf> the type is:
16:06:54 <benzrf> type BotCommand = forall t. Moment t (Behavior t ([String] -> BotTask))
16:07:02 <jle`> if the forall is inside the type
16:07:03 <benzrf> the data is:
16:07:04 <benzrf> data Bot = Bot {commands :: M.Map String BotCommand, botInfo :: BotInfo}
16:07:11 <beckyconning__> but thanks! and yeah i'll stop spamming now lol
16:07:26 <benzrf> jle`: i thought that was RankN
16:07:46 <quchen> beckyconning__: I learned Haskell because I liked the pictures in LYAH, so I don't judge.
16:07:59 <jle`> benzrf: RankN is for functions on types...but you need Impredicative types to have quantifiers "inside" type parameters
16:08:08 <benzrf> oh
16:08:12 <benzrf> :L
16:08:20 <jle`> forall a. Maybe (a -> a)  vs.  Maybe (forall a. a -> a)
16:08:39 <beckyconning__> i literally want to learn haskell so i can write less code and make the same amount of money : P
16:08:44 <jle`> i think impredicative types are considered one of the dangerous extensions
16:08:46 <jle`> *is
16:08:54 <geekosaur> sort of
16:09:06 <geekosaur> more that it's just problematic because type inference fails in their presence
16:09:15 <geekosaur> and they tend to behave oddly
16:09:25 <quchen> merijn likes to say that it's broken, but he's not here right now.
16:09:43 <geekosaur> pretty much, yes. ghc keeps tinkering with them and they keep behaving oddly
16:09:47 <benmachine> ImpredicativeTypes has had bugs in the past, I don't know if it still does
16:10:10 <geekosaur> so they're not unsafeCoerce dangerous so much as "things may randomly fail to typecheck"
16:10:14 <geekosaur> it does
16:10:14 <jle`> they just give me the heebie jeebies
16:10:16 <geekosaur> it always does
16:10:28 <geekosaur> they're very bad neighbors in the type system
16:10:32 <geekosaur> (ghc's at least)
16:10:37 <benmachine> I don't think ImpredicativeTypes is dangerous (at least, not to my knowledge), but it's power-to-weight ratio is kind of meh
16:10:38 <jle`> i look at something like Maybe (forall a. a -> a) and i shiver
16:10:48 <EvanR> beckyconning__: i daresay that in pretty short time that you will end up writing less code, not necessarily in haskell but whatever it is you are forced to go back to in the real world. all other things being equal thats more money per line of code
16:10:51 <jle`> i feel something drop deep in my soul
16:11:04 <benmachine> so if you think you need it the likelihood is that you need to think about your problem again
16:11:13 <Saizan> jle`: it should!
16:11:13 <benmachine> however there are legitimate uses
16:11:22 <EvanR> beckyconning__: its a tradeoff because you will hate that language you are forced to go back to ;)
16:11:26 <quchen> I don't even understand what that means, jle`. Isn't that the same as "type T = forall a. a -> a; data Foo = Foo T"?
16:11:46 <jle`> quchen: i don't know; they are powers beyond my comprehension :|
16:11:46 <benmachine> quchen: yes, that's the same (I think)
16:12:04 <quchen> benmachine: Oh, I thought what I wrote was legal without ImpredicativeTypes. Maybe I'm wrong then.
16:12:20 <benmachine> http://stackoverflow.com/q/14047241/812053 ← "Simple example for ImpredicativeTypes"
16:12:24 <jle`> EvanR, beckyconning__: http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
16:12:24 <geekosaur> I... think whether it's impredicative depends on what you do with it?
16:12:28 <bb010g> jle`: That's allowed with ImpredictiveTypes? I thought you needed RankNTypes also.
16:12:32 <geekosaur> all the examples I see are functors, for example
16:13:03 <jle`> bb010g: Impredicative is necessary for that; not sure if it's sufficient ofc.  probably need RankNTypes.
16:13:13 <benmachine> quchen: I just tried the following in GHC:
16:13:22 <benmachine> er, GHCi
16:13:23 <geekosaur> I would think impredicative implies rank n
16:13:29 <jle`> likel
16:13:31 <jle`> y
16:13:39 <benmachine> ghci> :set -XRankNTypes
16:13:39 <benmachine> ghci> type T = forall a. a -> a
16:13:39 <benmachine> ghci> Nothing :: Maybe T
16:13:41 <benmachine> ^ fails
16:13:55 <benmachine> and suggests Impredicative
16:13:59 <jle`> it's what benzrf tried to do, and it failed too w/o impredicative
16:14:04 <jle`> he tried putting it in a Map
16:14:10 <EvanR> jle`: nice
16:14:13 <EvanR> "Further, my experience with Haskell means that I now see potential bugs everywhere in imperative code."
16:14:19 <quchen> benmachine: Oh, okay. I'm less confused then.
16:15:03 <geekosaur> although I guess the haskellwiki example for impredicative types suggests anything like that is impredicative.
16:15:13 <geekosaur> they make my head hurt (worse); I try not to think about them
16:15:27 <jle`> yes let's move on too more happy topics please
16:15:30 <benmachine> geekosaur: I wrote the haskellwiki article, I don't promise it's any more informed than any of us :P
16:16:06 <quchen> jle`: Could you explain the Maybe Functor to me please? :-D
16:16:41 <EvanR> > fmap even Nothing
16:16:42 <lambdabot>  Nothing
16:16:46 <jle`> quchen: it's like the List functor but with only 0 or 1 items only
16:16:54 <jle`> quchen: also it's like the Identity functor but possibly with 0 items
16:16:58 <benmachine> :P
16:17:03 <jle`> also it's like the Either () Functor
16:17:05 <jle`> :)
16:17:24 <EvanR> too bad theres no () functor
16:17:30 <benmachine> there's Const ()
16:17:32 <quchen> There can't be.
16:17:45 <jle`> () is the wrong kind >_>
16:17:51 <jle`> i think Maybe can be like forall r. Cont r Functor
16:17:57 <quchen> jle`: Oh, is it also similar to the Free Const ()?
16:18:01 <EvanR> i should make an alernative functor class that admits ()
16:18:16 <quchen> Wait does that typecheck … my free monad fu is weak
16:18:37 <benmachine> quchen: Free (Const ())
16:18:38 <quchen> EvanR: I think () is instance of enough things already.
16:18:42 <Zekka> () isn't a functor?
16:18:47 <EvanR> :k ()
16:18:48 <lambdabot> *
16:18:49 <jle`> quchen: did you forget  a parentheses
16:18:51 <Iceland_jack> () isn't a Functor, and can't be
16:18:53 <Zekka> You can define a version of Const that takes an argument it doesn't do anything with
16:18:53 <benmachine> Zekka: doesn't take a type parameter
16:18:55 <Iceland_jack> :k Functor
16:18:56 <lambdabot> (* -> *) -> Constraint
16:18:57 <Iceland_jack> :k ()
16:18:58 <lambdabot> *
16:19:00 <Iceland_jack> Doesn't fit
16:19:07 <EvanR> constraint kinds
16:19:15 <Zekka> In which case it's like Const without the Monoid constraint for Applicative!
16:19:37 <benmachine> jle`: I'm currently thinking about your forall r. Cont r Functor remark but I don't "get it" yet
16:19:45 <quchen> benmachine: Free (Const ()) = Maybe, that looks right, yes
16:20:26 <jle`> benmachine: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
16:21:02 <benmachine> jle`: I've read that post (it's great) but I still don't know what you mean
16:21:08 <quchen> jle`: I keep hearing that article is wrong though, "you can't write State" etc. But I don't have proof, authority or references.
16:21:15 <jle`> it can be used to emulate Maybe
16:21:19 <benmachine> that article is right up to strictness
16:21:26 <jle`> if you pass in a parameter ignoring continuation
16:22:02 <benmachine> jle`: what I take from that article is that you can do Maybe's monad stuff using only Cont stuff
16:22:09 <jle`> oh yeah it's the Monad stuff
16:22:12 <benmachine> but the type you use is Cont (Maybe r) a
16:22:22 <benmachine> so you can't really define Maybe itself that way :P
16:22:43 <jle`> oh darn did i get that wrong >_>
16:23:06 <jle`> wait i think any Cont (\_ -> blah) is the same as fromMaybe blah
16:23:07 <Saizan> well, you csna do Maybe with Ran though
16:23:15 <jle`> with Nothing
16:23:23 <Saizan> *can
16:23:27 <jle`> or `maybe`, sorry
16:23:34 <benmachine> jle`: oh, I see, that perhaps makes a bit more sense to me
16:23:42 <benmachine> jle`: I think that's not what the article is about though
16:23:47 <jle`> benmachine: heh, yeah, sorry
16:24:03 <benmachine> yeah, I'm with you now
16:24:09 <benmachine> Cont is "bigger" than Maybe though
16:24:12 <benmachine> it can do what Maybe can do and more
16:24:27 <jle`> you can emulate maybe d f w/ Cont (\_ -> d) for Nothing and Cont f for Just....i think........
16:24:48 <benmachine> oh ok
16:24:56 <jle`> er
16:25:13 <jle`> no
16:25:25 <jle`> but it's something like that >_>
16:25:27 <benmachine> heh
16:25:33 <benmachine> I am going to go to bed without figuring it out
16:25:36 <benmachine> early morning tomorrow :(
16:25:39 <jle`> :(
16:25:48 <jle`> night
16:25:54 <benmachine> night
16:26:00 <beckyconning__> night!
16:26:47 <jle`> now onto implementing minimax in haskell
16:30:12 <jle`> ...on to?
16:31:59 <geekosaur> the latter
16:32:25 <jle`> thanks
16:38:08 <haasn> Does anybody know a good illustration of the lambda cube with vertices annotated with language examples?
16:43:36 <dolio> haasn: Does this help? http://hub.darcs.net/dolio/pts
16:44:29 <haasn> By illustration I'm really looking for an image file or similar
16:45:00 <suOya_> How do I export the lenses generated by using makeLenses so that other modules can use them? Example: data Person = Person { _name :: String }. TH should generate a 'name'-lens for that, is there a way to automatically export it? At this point exporting Person(..) exports '_name' only, not 'name'
16:46:41 <jle`> suOya_: i think you'll have to manually export it
16:46:53 <jle`> because the lenses that are made are just normal functions
16:47:10 <suOya_> yeah
16:47:22 <jle`> that you could write your own, but are written for you programatically
16:47:24 <suOya_> that's what I feared
16:47:29 <jle`> alas!
16:47:50 <jle`> i wonder if you could TH splice export lists ...
16:48:01 <jle`> (probably not)
16:48:43 <quchen> suOya_: I recommend generating lenses in a separate module that does only that. You can export everything from there then.
16:49:12 <quchen> You can also import that module "qualified as L" so your code is very explicit about what is a lens and what is not at the call site.
16:49:19 <suOya_> I already have all my types in a single module
16:49:58 <quchen> What I mean is something like this: https://github.com/quchen/amoeba/blob/master/src/Types/Lens.hs
16:50:06 <quchen> "Import all types, then make the lenses in isolation"
16:51:07 <suOya_> I see, thanks
16:55:47 <l0cust> So, I'm clearly doing something wrong with quickcheck
16:56:05 <l0cust> because this is passing - http://lpaste.net/107453
16:56:21 <carter> what version of quick check
16:56:56 <carter> ohhh
16:56:57 <carter> huhg
16:57:34 <bb010g> I think I officially dislike Set now. I can't make an OrdSet Foldable due to fold :: (Monoid m) => OrdSet m -> m not working due to the Ord constraint on m. Erg. I'm just going to find another (Set-free) way to do this. :)
16:57:50 <carter> fromList / toList bb010g  :)
16:58:11 <EvanR> bb010g: just dont use the Ord constraint on the set ;)
16:58:23 <bb010g> EvanR: But functors... :D
16:58:31 <EvanR> functors dont care about ord
16:58:35 <l0cust> > quickCheck ((\x -> False) :: Int -> Bool)
16:58:36 <lambdabot>  <IO ()>
16:58:41 <EvanR> neither do sets, mathematically
16:58:42 <l0cust> Why is that passing?!
16:58:43 <carter> sets don't form functors
16:58:53 <bennofs> @check (\x -> False) :: Int -> Bool
16:58:54 <lambdabot>  *** Failed! Falsifiable (after 1 test):
16:58:54 <lambdabot>  0
16:59:35 <l0cust> bennofs: hm
16:59:42 <l0cust> bennofs: why is my test suite passing then
17:00:08 <EvanR> bb010g: you can implement a set based on hashing instead of ordering
17:00:14 <EvanR> possibly other ways
17:00:33 <EvanR> unsafe perform IO stable name ;)
17:00:57 <EvanR> or simply magic
17:03:51 <bb010g> I have OrdSet a = OrdSet { getOrdSet :: Ord a => Set a }, and instance Functor OrdSet where { fmap f (OrdSet s) = OrdSet $ map f s } but GHC complains about no Ord constraint for the given OrdSet, despite it being in the declaration of OrdSet. What?
17:05:26 <bb010g> I doesn't work with the mysterious ImpredicativeTypes either. :(
17:06:22 <bb010g> Why would GHC even complain? The Ord is built into the type...I'm confused.
17:07:00 <bb010g> OrdSet :: (Ord a => Set a) -> OrdSet a
17:07:28 <EvanR> OrdSet :: Ord a => Set a -> OrderSet a ?
17:07:31 <jle`> because of the type of fmap
17:07:49 <bb010g> jle`: The Ord is in the f, though.
17:07:55 <jle`> fmap :: (a -> b) -> OrdSet a -> OrdSet b
17:08:02 <jle`> bb010g: the ord is in the OrdSet
17:08:02 <bb010g> (By f I mean type Functor F)
17:08:02 <Cale> bb010g: There's no guarantee that the codomain of f has an instance of Ord
17:08:04 <jle`> but it's not in the function
17:08:14 <jle`> it's not in the (a -> b)
17:08:17 <Cale> bb010g: Like, what if I fmap putStrLn ?
17:08:23 <Cale> :t fmap putStrLn
17:08:24 <lambdabot> Functor f => f String -> f (IO ())
17:08:24 <bb010g> IT'S IN THE SMEGGING OrdSet TYPE!
17:08:29 <Cale> bb010g: ^^
17:08:39 <Cale> bb010g: There's no instance of Ord for IO ()
17:08:53 <Cale> but I should be able to apply fmap putStrLn to one of these things if it's a valid instance of Functor
17:09:10 <bb010g> Oh...
17:09:13 * bb010g is sad
17:09:50 <bb010g> This all makes sense now.
17:09:51 <jle`> remember, fmap :: forall a b. Functor f => (a -> b) -> OrdSet a -> OrdSet b
17:09:52 <EvanR> an ordset of io actions would be odd
17:09:59 <jle`> the forall was always there
17:10:04 <jle`> just...implicit
17:10:13 <Archelon> anyone in here that could help with math?
17:10:20 <bb010g> Archelon: Shoot.
17:10:30 <Archelon> http://pbrd.co/1q8LZQh
17:10:34 <Archelon> b)
17:10:47 <Archelon> Don't know how to do it
17:11:03 <jle`> Archelon: maybe #math or #haskell-blah is better if it doesn't relate to Haskell :)
17:11:20 <jle`> for (b) they're asking you to find the zeroes of the first partial derivatives tho
17:11:41 <Archelon> Ty, going to connect there aswell, just heard that the ppl in here are nice and helpful :)
17:11:44 <jle`> the mutual zeroes of d/dx and d/dy
17:12:36 <trap_exit> is it possible to write an epub in haskell?
17:13:05 <trap_exit> trap_exit: look @ https://hackage.haskell.org/package/epub-tools
17:13:07 <Archelon> bb010g: was it something you could solve? :)
17:13:10 <jle`> trap_exit: there might be an epub library on hackage...but you can always use Pandoc's builder library
17:13:17 <jle`> it's a bit limiting tho
17:13:20 <bb010g> Archelon: I didn't know. :)
17:13:27 <Archelon> ah bummer
17:13:34 <Archelon> thnx anyway :)
17:13:35 <trap_exit> jle`: yeah, I need something a bit more powerful
17:13:37 <trap_exit> like ability to include svg graphics
17:13:44 <Cale> http://hackage.haskell.org/package/epub-metadata
17:13:48 <trap_exit> I'm getting conflicting reports: one saying that HTML can only include jpegs
17:13:52 <trap_exit> and anoter saying epub supports svg
17:13:58 <bb010g> Archelon: Think about merging together sets of extrenum points for each axis.
17:15:37 <Archelon> bb010g: Ok
17:15:55 <bb010g> Archelon: Do you know Haskell?
17:16:03 <Archelon> bb010g: Nope
17:16:07 <Cale> Archelon: did you succeed in your math problem?
17:16:16 <Archelon> Cale: I didn't
17:16:36 <bb010g> Archelon: http://learnyouahaskell.com/introduction
17:16:37 <Archelon> bb010g: But it sounds interesting though :)
17:16:38 <Cale> What seems to be the difficulty?
17:16:55 <Archelon> the b) question
17:17:21 <Cale> Archelon: So you want to find points where the partials are both 0
17:17:22 <bb010g> What's the first derivative requested?
17:17:47 <jle`> Archelon: remember that the extremum of a single variable function is points were f' = 0.  so in this case you found f'_x and f'_y.  so find places where both f'_x and f'_y are zero :)  those are the candidates
17:18:27 <Archelon> Cale: Ok
17:18:48 <Archelon> bb010g: Don't have the calculations right here
17:19:10 <Archelon> jle`: Hmmm, Ok
17:19:27 <Archelon> you guys are really helpful i must say! :)
17:19:51 <bb010g> Archelon: A lot of multi-dimensional calculations are like normal calculations, but more generic.
17:20:01 <jle`> just more multi-
17:20:04 <jle`> :D
17:20:09 <Cale> Archelon: The partial derivative f'_x(x,y) = 2x - 4y, so that's 0 if and only if 2x = 4y and x = 2y. The partial derivative f'_y(x,y) = y^2 - 4x + 15. If x = 2y and that's to be 0, then we have y^2 - 8y + 15 = 0. You can solve this for y.
17:20:16 <bb010g> You can think of any function f(x) as a f(x,y) where y is always 0.
17:21:03 <Archelon> Cale: OK, thanks!
17:24:00 <Archelon> Cale: So if y=0, x=15?
17:24:24 <EvanR> calculus sucks, lets talk about haskell
17:24:41 <bb010g> :)
17:24:49 <jle`> calculus doesn't suck ;_;  it's off topic probably, but not suck
17:24:57 <jle`> s/probably/definitely
17:25:01 <Cale> Archelon: What's this about y = 0?
17:25:04 <EvanR> > U+ME=US
17:25:05 <bb010g> Derivatives are awesome.
17:25:05 <lambdabot>  <hint>:1:5: parse error on input ‘=’
17:25:06 <Mardolf> hi  everybody
17:25:08 <djahandarie> @hackage ad
17:25:08 <lambdabot> http://hackage.haskell.org/package/ad
17:25:11 <jle`> hello Mardolf
17:25:24 <carter> ad is awesome
17:25:35 <jle`> indeed it is
17:25:39 <bb010g> > let U = 1; ME = 2; US = 3 in U+ME==US
17:25:40 <lambdabot>  Not in scope: data constructor ‘U’Not in scope: data constructor ‘ME’Not in ...
17:25:46 <Mardolf> I would like to ask something
17:25:54 <jle`> does it bother anyone else that "Just n" is not the same number of characters as "Nothing"
17:25:55 <Cale> Mardolf: go for it :)
17:25:56 <bb010g> > let u = 1; me = 2; us = 3 in u+me==us
17:25:57 <lambdabot>  True
17:25:57 <jle`> it really gets me every time
17:26:11 <Cale> jle`: Just add some spaces to make things line up
17:26:18 <Mardolf> why would someone prefer this Store representation data Store a = Store [String] (String->a)
17:26:18 <jle`> Cale: i know, that's what i do
17:26:27 <jle`> but still :/
17:26:31 <Mardolf> instead of this  data Store' a = Store' [(String,a)]
17:26:47 <Cale> Mardolf: Well, they're not quite the same thing
17:26:48 <bb010g> Mardolf: Less space consumed?
17:26:53 <Archelon> Cale: I thoght that was how I was going to do? Calculate x and y?
17:26:57 <jle`> cause you can comonad
17:27:08 <Cale> Mardolf: In the former representation, you can apply the function to Strings which are not in the list.
17:27:17 <Mardolf> hmmm
17:27:45 <Cale> It's unclear whether you'd really save space, and in some cases, you might use more space with the former representation.
17:28:12 <Cale> But the types aren't quite isomorphic
17:28:46 <Mardolf> Isn't just more simple to use  [(String,a)] ?
17:29:15 <Cale> Archelon: I'm not sure where you got y = 0, and from x = 2y, you'd have x = 0 as well if that y value were even important...
17:29:18 <Zekka> Mardolf: Well, the 'a's are then automatically updated if you update the strings
17:29:32 <jle`> why have (+) :: Num a => a -> a -> a
17:29:37 <Zekka> or if you update the function describing the relationship
17:29:42 <jle`> when you can have (+) :: Num a => [(a, a, a)]
17:29:48 <Mardolf> Oh... i see
17:30:00 <jle`> er, [((a, a), a)]
17:30:17 <Zekka> Keeping the function around enforces the relationship
17:30:30 <Mardolf> oh..
17:30:43 <sshine> jle`, a -> a -> a is one way to describe a relation while [(a,a,a)] is another.
17:30:48 <Mardolf> Well, thanks guys! i'll keep working on  haskell, i've got to go now.. i  got more questions for later..
17:30:52 <snyp> How is this desugared like this? http://paste.debian.net/109569/ ... the (hx -> ...) is confusing me.
17:31:15 <Cale> snyp: Really weird to use f and g for things which aren't functions
17:31:20 <mjo> Has anyone written a library yet that will basically let me run `du` in haskell?
17:31:32 <jle`> snyp: i don't think that's valid
17:31:32 <Archelon> Cale: Well how do I find the candidates then from what you gave me?
17:31:45 <Cale> snyp: The desugaring is wrong
17:31:55 <jle`> @undo do { x <- f; g; y <- h x; return y }
17:31:56 <lambdabot> f >>= \ x -> g >> h x >>= \ y -> return y
17:32:01 <Cale> Archelon: Use the quadratic formula on that polynomial in y
17:32:32 <Cale> well, "wrong", someone replaced >>= with ->
17:32:54 <snyp> jle`, Cale ah.. the '->' should be '>>='
17:33:05 <snyp> so there's an error in the book.
17:33:15 <bb010g> snyp: Which book?
17:33:22 <snyp> Beginning Haskell
17:33:34 <jle`> snyp: better submit a correction :)
17:33:56 <snyp> yeah.. i will check the errata first
17:33:56 <bb010g> snyp: Have you read any other books?
17:33:56 <jle`> not that it's your responsibility ofc
17:34:53 <snyp> bb010g, first 3 or 4 chapters of learn you a haskell about a year back, but gave up then.
17:35:11 <bb010g> snyp: Check through that again, and also Real World Haskell.
17:35:16 <jle`> bb010g: try  https://github.com/bitemyapp/learnhaskell
17:35:19 <jle`> ooops
17:35:22 <jle`> snyp:
17:35:40 <bitemyapp> hrm, quchen left. That's annoying. Well, he seems to have figured it out anyway.
17:35:47 <bb010g> jle`: Oooh, haven't ran into that before. Nice. :)
17:36:22 <bitemyapp> beckyconning__: I provided you a way to make it "real", just follow through on that and you'll be that much closer.
17:36:42 <snyp> will check out the cis194 course.
17:36:49 <bb010g> bitemyapp: Nice job on the Learn Haskell thing. 👍
17:36:53 <bitemyapp> bb010g: <3
17:38:08 <bb010g> bitemyapp: The only other thing I could think of glancing through it would be the Lambda Calculus Wikipedia page. I worked through a paper version of that when I began and it helped more than you'd think.
17:39:18 <Archelon> Cale: Ok, I'll try
17:39:41 <beckyconning__> i've been working through these videos for the last few days https://www.youtube.com/watch?v=pIW-_E0w6h4&index=13&list=PLPqPwGvHPSZB-urE6QFjKYt6AGXcZqJUh then i'll do the Learn Haskell thing and have a look at the Lamda Calculus page : )
17:39:44 <Cale> Archelon: you should get y values of 3 and 5 unless I'm mistaken
17:39:58 <bitemyapp> bb010g: I didn't want to seem like I was condescending to quchen which is why I tried to avoid "herp derp lambdas" material.
17:40:21 <bitemyapp> bb010g: I simply assumed he knew basic LC. And he did, it's connecting it to lazy LC that was needed.
17:40:48 <bb010g> bitemyapp: Is that for quechen? I thought it was just a page for anyone.
17:40:59 <bb010g> And LC is inherently lazy.
17:41:10 <bitemyapp> bb010g: the order of the guide is important
17:41:16 <Cale> LC doesn't say anything about order of evaluation
17:41:21 <bitemyapp> bb010g: you wouldn't reach the laziness section without understanding something.
17:41:26 <Cale> It just defines an equivalence between terms
17:41:51 <Cale> (well, two or three of them)
17:42:20 <bb010g> Cale: Hence laziness is a better representation than strictness. (E.g. Y vs Z combinator)
17:42:37 <Cale> Er
17:43:00 <Cale> Strict evaluation is justified by lambda calculus too!
17:43:54 <Cale> It's just that lazy (or outermost-first) evaluation has the really nice property that if some evaluation order produces a normal form, then it does.
17:44:04 <Cale> and strict evaluation lacks that property
17:46:18 <SamB> Cale: neglicting such possibilities as OOM, sure ...
17:46:54 <Archelon> Cale: Thanks for the help, going to bed now
17:47:01 <Archelon> Bye all
17:47:35 <bb010g> Archelon: Night. Also, keep this ( https://github.com/bitemyapp/learnhaskell ) around for looking at. :)
17:51:14 <jmcarthur> SamB: yeah, OOM is not exactly a nice mathematical theory to work with :)
17:52:17 <jfischoff> what is a simple way to write a Word8/Word32 to handle?
17:54:05 <heatsink> jfischoff: Data.ByteString.hPut
17:54:45 <jfischoff> fair enough
17:55:23 <benzrf> :t foldMap
17:55:24 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
17:58:14 <jfischoff> I think is it odd thought that there is no easy way to write binary data to a FD without allocating a Ptr of some kind
17:58:34 <wolfspaw_away> Is the Official Monads+Monads-Transformers Tutorial "All About Monads" updated, or is it outdated? (http://www.haskell.org/haskellwiki/All_About_Monads)
17:58:52 <jfischoff> creating a ForeignPtr just to write a Word8 to a file handle seems wrong
17:59:32 <jle`> Wolfspaw: the only official monad tutorial is the original philip wadler paper :)
17:59:48 <bb010g> Wolfspaw: Monads are like tacos...
18:00:33 <Wolfspaw> hehe, okay. But is the tutorial "All About Monads" updated to the latest changes on monads? (I read that State and ST changed recently. I'm a beginner)
18:01:52 <Wolfspaw> (It was pointed to me that the Monad part on Real World haskell is outdated, since the way the State monad is defined changed, and the part on Bloom Filters does not compile because of changes on ST monad)
18:02:30 <jle`> Monads don't become outdated, but the various Monad instances in popular libraries change :)
18:02:44 <jle`> the types themselves
18:02:52 <jle`> monads are forever
18:02:59 <jle`> .~*~ forever ~*~.
18:03:04 <bb010g> jle`: I'm still waiting for a Monad tutorial for extensible-effects/effin
18:03:05 <Cale> lol
18:03:16 <glguy> jfischoff: If you don't want to make a foreignptr, you can go via: hPutBuf :: Handle -> Ptr a -> Int -> IO ()
18:03:54 <beckyconning__> how would i sort a list of lists by their first elements? i.e this: [[1,2],[2,2],[2,1],[1,4],[1,5]] to this: [[1,2],[1,4],[1,5],[2,1],[2,1]]
18:03:56 <Wolfspaw> Makes sense, then let me rephrase the question: Does the tutorial "All About Monads" takes in consideration changes on the Monad Instances of State and ST?
18:04:18 <beckyconning__> * ...[2,1],[2,2]]
18:06:04 <bb010g> beckyconning__: sortBy (f . head) where f is the sorting fun
18:06:36 <bb010g> > sortBy (min . head) [[1,2],[2,2],[2,1],[1,4],[1,5]]
18:06:38 <lambdabot>  Couldn't match type ‘[GHC.Types.Ordering]’
18:06:38 <lambdabot>                with ‘GHC.Types.Ordering’
18:06:38 <lambdabot>  Expected type: GHC.Types.Ordering -> GHC.Types.Ordering
18:06:38 <lambdabot>    Actual type: [GHC.Types.Ordering] -> GHC.Types.OrderingCouldn't match expe...
18:06:38 <lambdabot>              with actual type ‘[t0]’Couldn't match expected type ‘GHC.Types.O...
18:06:45 <beckyconning__> ah cool : ) so head takes the first element from a list and f can be something like compare?
18:06:50 <bb010g> Wait...
18:06:56 <bb010g> :t sortBy (min . head)
18:06:56 <lambdabot>     Couldn't match type ‘[Ordering]’ with ‘Ordering’
18:06:57 <lambdabot>     Expected type: Ordering -> Ordering
18:06:57 <lambdabot>       Actual type: [Ordering] -> Ordering
18:07:07 <bb010g> :t min
18:07:08 <lambdabot> Ord a => a -> a -> a
18:07:11 <Cale> You want comparing :)
18:07:23 <beckyconning__> :t sortBy (compare . head)
18:07:23 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ [a]
18:07:24 <lambdabot>     Expected type: [a] -> [a]
18:07:24 <lambdabot>       Actual type: [a] -> a
18:07:31 <Cale> > sortBy (comparing head) [[1,2],[2,2],[2,1],[1,4],[1,5]]
18:07:32 <lambdabot>  [[1,2],[1,4],[1,5],[2,2],[2,1]]
18:07:40 <bb010g> I apparently don't know what I'm doing. ;)
18:07:53 <Wolfspaw> Re-rephrasing my question: Is the tutorial http://www.haskell.org/haskellwiki/All_About_Monads a good/recommended guide for someone seeking to understand Monads+Monad Transformers?
18:08:15 <Cale> (but note that if there's an empty list, "head" will fail, so you may want to use  comparing (take 1)  instead)
18:08:18 <beckyconning__> thats good though! it lets me know its hard and i'm not the only one who doesn't get it straight away : ) even super smart people don't get it right first time
18:08:37 <beckyconning__> cool thanks y'all : )
18:08:40 <Krenium> Except for Cale
18:08:58 <SamB> Wolfspaw: understanding monads is a lot easier than realizing that you have done so, IME
18:09:07 <bb010g> @src comparing
18:09:07 <lambdabot> Source not found. Are you on drugs?
18:09:10 <jle`> Wolfspaw: i don't quite trust haskellwiki for a lot of stuff, even though it has a lot of good stuff in it.  i recommend the wadler paper for monads if you must, and  the step-by-step tutorial at http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf for understanding transformers
18:09:19 <jle`> the best way to understand how to use monads is to not
18:09:19 <ddellacosta_> Wolfspaw: I'm fond of this introduction to monads: http://dev.stephendiehl.com/hask/#monads
18:09:20 <Cale> That tutorial is older than the wiki
18:09:35 <Cale> It was around when I was learning about monads.
18:09:38 <jle`> just use the Monad instance for different types
18:09:44 <jle`> Cale: ah, thanks for the heads up :)
18:09:48 <ddellacosta_> and yeah, the Wadler paper...that
18:09:50 <bb010g> From Data.Ord: comparing p x y = compare (p x) (p y)
18:09:52 <ddellacosta_> ...is the best
18:09:55 <SamB> know instances, know the laws ...
18:10:00 <Cale> It's not terrible, and it's reasonably comprehensive, but it's not really excellent either.
18:10:20 <jle`> Wolfspaw: basically, you have a lot of types in various libraries.  most of them have useful convenience/helper functions for working with them more easily
18:10:35 <jle`> Wolfspaw: some of those convenience functions align with methods from the Monad typeclass
18:10:51 <jle`> Wolfspaw: how helpful that is to actually know is...questionable.  at first, for someone just learning.
18:11:14 <jle`> the main advantage of knowing it is from Monad is that you can use functions like sequence and mapM, that are defined generically for all Monad instances
18:11:27 <jle`> but other than that...the insight you might expect to gain at first is very not worth it
18:11:45 <jle`> you would benefit more by just using the various types as you need them, with their various helper functions
18:11:55 <SamB> there is nothing at the bottom of the rabbithole; the hole isn't even really all that deep
18:12:09 <jle`> then one day, when you're eating or driving somewhere or something, you will see the connections between all of them
18:12:34 <SamB> and you'll be like "that was *it*?"
18:12:38 <jle`> haha
18:12:50 <jle`> it will either be a very disappointing or very satisfying moment.
18:12:58 <jle`> flip a coin
18:13:02 <Wolfspaw> Okay, thanks for the info. I'm going to check those sources. I wanted to learn because in some places/tutorials people use the State Monad, or IORef a lot and I'm sad for not understanding it completely
18:13:08 <Wolfspaw> hehe
18:13:14 <jle`> Wolfspaw: that might be one reason why it is tricky
18:13:20 <jle`> don't think of it as how to use "the State Monad"
18:13:23 <jle`> or how to use "the IO Monad"
18:13:26 <jle`> learn how to use the State type
18:13:28 <jle`> how to use the IO type
18:13:46 <jle`> undoubtedly you will find the helpful helper functions and combinator functions that come from the Monad typeclass
18:13:49 <SamB> jle`: IO is a glorious cheat
18:13:59 <jle`> but you will learn them in the context of working better with the State/IO types
18:14:00 <SamB> Wolfspaw, rather
18:14:23 <Cale> Well, the actual implementation of IO in GHC is a cheat, but I don't think the concept of the IO type is a cheat at all.
18:14:28 <jle`> the State type is very useful; it has a very useful Functor instance, a very useful Applicative instance, and a very useful Monad instance
18:14:46 <jle`> you are probably aware that the list type has a very useful Functor instance --- it gives you map!
18:14:52 <Cale> It *could* be a big GADT with constructors for all the I/O primitives, as well as some higher-order abstract syntax connectives
18:15:01 <jle`> but you didn't learn map by going "okay, i will try to understand Functors.  let's look at the List functor."
18:15:06 <SamB> the glorious part is where you get to not tie your brain in knots trying to avoid consuming input before you've requested it ;-)
18:15:10 <Cale> (which the runtime system would then decompose and carry out)
18:15:19 <jle`> you most likely learned map by going "this list is sure a useful type.  and i can define this map function to work with it in nice ways."
18:15:22 <SamB> Cale: how does that work with FFI ;-P
18:15:42 <jle`> you didn't set out to "learn Functor", and then study the Functor instance for list
18:15:52 <bb010g> jle`: I'm still not exactly sure how the List monad is broken. Also, why is it still the default if it's broken? (Or is it ListT?)
18:15:55 <jle`> map for list is useful in its own right, in and out of itself
18:16:09 <SamB> I think it's ListT ?
18:16:17 <Cale> SamB: Well, yeah, that would be the most tricky bit, particularly as type-level computation isn't so easy in Haskell.
18:16:23 <jle`> bb010g: the ListT from tranformers is broken because of strictness stuff, I believe.  but the pipes library has a lawful ListT
18:16:24 <Wolfspaw> jle`: true xD, I learned about functors learning first about list, and map
18:16:54 <jle`> Wolfspaw: as it turns out, all Monad instances are just normal types, and their method implementations are just useful convenience functions on that type
18:16:57 <Cale> SamB: With dependent typing you could do even that really nicely
18:16:58 <jle`> like map is useful for list
18:17:07 <SamB> Wolfspaw: that's the way to go with Monad too, really ;-)
18:17:11 <beckyconning__> i did a haskell : > groupBy (\([e11, _]) ([e12, _]) -> e11 == e12) (sortBy (comparing (take 1)) [[1,2],[2,1],[2,2],[1,4],[1,5]])
18:17:24 <Cale> (compute the type of the action from the information about the foreign call to be made)
18:17:45 <jle`> everyone's favorite "first Monad" example is Maybe.  but.  studying "why is Maybe a monad?" is less useful.  studying "how can i use this useful Maybe combinator/helper function" is very useful.
18:18:01 <Wolfspaw> SamB: hehe, okay. I'll try to achieve illumination and will se if I get to the point where I worry on not consuming input before requesting it @o@
18:18:31 <SamB> Wolfspaw: you won't; that was in a very, very old version of Haskell
18:18:39 <bb010g> Wolfspaw: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
18:18:40 <Wolfspaw> ah xD
18:18:48 <SamB> at least, not the way I meant
18:18:53 <SamB> back before IO
18:19:04 <jle`> Wolfspaw: if you have ever worked with a lot of Maybe, you will very much appreciate a Maybe a -> (a -> Maybe b) -> Maybe b.  like.  a *lot*.  but the fact that it happens to match with (>>=) is not quite relevant at first :)
18:19:08 <SamB> I've never used that old a version either, but just imagining it makes my brain hurt
18:19:22 <Wolfspaw> bb010g: thanks, I'll check that one.
18:19:24 <Cale> Wolfspaw: SamB is talking about before we had an IO type, and the actions to be carried out were determined by a function from a list of responses to a list of requests.
18:19:56 <Wolfspaw> jle`: I read a bit on maybe, and already saw that the bind function is very useful at propagating failure
18:20:12 <Wolfspaw> Cale: ah @o@
18:20:40 <jle`> Wolfspaw: you saw that "bind as instanced w/ Maybe is useful for propagating failure" :)
18:21:21 <bb010g> What typeclass should fail go into if it was cut out of Monad?
18:21:53 <marchelzo_> I can't install Text.Regex.Base with --enable-shared in cabal. It says: cannot find -lHSmtl-2.2.1-ghc7.8.2 and cannot find -lHStransformers-0.4.1.0-ghc7.8.2
18:22:05 <Wolfspaw> jle`: hehe, yes. I'll try to discover the bind applications for other instances xD
18:22:29 <bb010g> marchelzo_: Are you sure mtl & transformers are working otherwise?
18:22:43 <marchelzo_> bb010g: I have absolutely no idea what they are, so no.
18:22:48 <jle`> i think the biggest stumbling block for people trying to learn monads is that they are trying to learn monads
18:22:54 <bb010g> Wolfspaw: That post focuses a lot on how they arise from normal use.
18:22:59 <marchelzo_> bb010g: Should I reinstall haskell-platform?
18:23:19 <bb010g> marchelzo_: Try compiling those with --enable-shared too. I'm not quite sure about how it works, but it should help.
18:24:22 <marchelzo_> bb010g: Trying to reinstall mtl results in a whole slew of errors
18:24:35 <Wolfspaw> bb010g: going to read/study it now xD.
18:24:41 <bb010g> Do they all look like "cannot find -lHSx"?
18:25:00 <marchelzo_> they said couldn't find transformers
18:25:10 <bb010g> Try transformers first then.
18:25:16 <marchelzo_> yeah i did, and that worked.
18:25:20 <bb010g> \o/
18:25:49 <marchelzo_> should i change my cabal config to make everything shared?
18:26:45 <bb010g> marchelzo_: Depends on what you want. I haven't dealt with --enable-shared before, so you should wait for somebody else who knows or search around a bit to figure out whether you want it.
18:27:15 <marchelzo_> yeah I never had to do it on windows, but I can't use any packages that I install on here without using it it seems
18:27:33 <bb010g> marchelzo_: Ick.
18:28:22 <Mardolf> foldr (+) 0 [1,2,3]
18:29:06 <bitemyapp> > foldr (+) 0 [1,2,3]
18:29:08 <lambdabot>  6
18:30:44 <Mardolf> thx!
18:31:07 <bb010g> aspidites: Hey! :)
18:34:23 <Algebr> If you have Foo <$> func1 <*> func1, is that the same as: fmap Foo (<function for <*>> func1 func1)
18:34:57 <bb010g> Algebr: <function for <*>> is (<*>) (the same for any other infix function)
18:35:09 <jle`> Algebr: (Foo <$> func1) <*> func2
18:35:33 <bb010g> Algebr: They are the same. It's just prefix vs infix.
18:35:44 <bb010g> Er...no...derp
18:36:03 <Algebr> bb010g: I understand they are infix version, I'm confused about the order of exection.
18:36:08 <jle`> probably a better way of looking at it is (pure Foo <*> func1) <*> func2
18:36:12 <Algebr> execution
18:36:24 <jle`> for the (->) r instance?
18:36:38 <bb010g> @hayoo (<$>)
18:36:39 <lambdabot> Unknown command, try @list
18:36:44 <bb010g> @hoogle (<$>)
18:36:45 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
18:36:45 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
18:36:46 <jle`> f <$> g <*> h = \x -> f (g x) (h x)
18:36:48 <Algebr> for the example I posted, is it going from right to left?
18:36:52 <bb010g> Err. No links
18:36:54 <jle`> for the (->) r instance of Applicative
18:37:29 <bb010g> Algebr: It's infixl 4, so it wouldn't grab the right.
18:37:37 <jle`> in terms of precedence, it's (Foo <$> func 1) <*> func 2;  you can also look at it as ((pure Foo) <*> func1) <*> func2
18:37:46 <trap_exit> coding in haskell  -- is like driving on a road with gaurd rails. Suppose you're drunk -- and you code in lisp ... and you go off the cliff, the compiler's there like "sure, that's fine, go off the cliff, deal with it at run time". Suppose you're coding drunk ... and you're in haskell, the compiler's a guard rail ... it's like "no, you can't go there" ... and it forces you to amke progress
18:37:47 <jle`> sorry, func1 and func2 in the line above
18:38:18 <bb010g> Precedences are here: http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Applicative.html
18:38:57 <marchelzo_> I am reading a regex tutorial and he uses this as an example: "foo foo foo" =~ "foo" :: [String]. I tried it in ghci and got an error. Has something changed about the regex-posix package that would make this no longer valid?
18:39:17 * Hodapp throws Emacs at SamB
18:39:42 <SamB> lol
18:39:44 <Fuuzetsu> marchelzo_: it helps to say what the error is
18:40:05 <Fuuzetsu> @hoogle (=~)
18:40:05 <lambdabot> Text.Regex.Posix.Wrap (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
18:40:05 <lambdabot> Text.Regex.Posix.Wrap (=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
18:40:28 <Fuuzetsu> :t ("foo foo foo" =~)
18:40:29 <lambdabot>     Not in scope: ‘=~’
18:40:29 <lambdabot>     Perhaps you meant one of these:
18:40:29 <lambdabot>       ‘==’ (imported from Data.Eq), ‘#~’ (imported from Control.Lens),
18:40:36 <marchelzo_> Fuuzetsu: Sorry. No instance for (RegexContext Regex [Char] [String]) arising from a use of '=~'
18:40:44 <jle`> marchelzo_: it looks like you might need :set -XOverloadedStrings
18:40:48 <Fuuzetsu> marchelzo_: try ^
18:40:58 * Fuuzetsu shakes fist at jle`
18:41:00 <Algebr> Is there a rigorous definition of what the difference is, if any, between a function and operator? (in programming land, not math land where I know there is a formal difference)
18:41:19 * hackagebot aur 2.0.0 - Access metadata from the Arch Linux User Repository.  http://hackage.haskell.org/package/aur-2.0.0 (fosskers)
18:41:43 <bb010g> Algebr: Give the mathy operator definition.
18:41:51 <marchelzo_> I just did that and now I get: No instance for (Data.String.IsString source0) arising from the literal '"foo"'
18:42:03 <jle`> Fuuzetsu: ;_;
18:42:18 <Algebr> operators are mappings between vector spaces
18:42:49 <Algebr> so i think its, all operators are functions, but not all functions are operators?
18:42:51 <bb010g> marchelzo_: Give :t "foo foo foo" =~ "foo" to ghci and post it's output
18:42:54 <jle`> in Haskell an operator is a function whose names are only symbols
18:43:08 <bb010g> jle`: ?
18:43:09 <Algebr> jle`: that's it, right?
18:43:10 <jle`> (valid operator symbols)
18:43:23 <jle`> to be used in prefix they must be surrounded by parentheses; otherwise they are used infix
18:43:37 <jle`> they also have associated fixity rules i guess
18:44:12 <marchelzo_> http://lpaste.net/107455 this is the output. quite long
18:44:14 <Algebr> jle`: then somewhat related, why is sizeof an operator and not a function? is it because its provided by gcc/baked into C language?
18:45:19 <jle`> Algebr: i don't know about terminology in C.  but sizeof in C is very different than most C "functions"; it is resolved at compile-time
18:45:47 <jle`> it's also applied to types
18:46:21 <jle`> so in many ways it's almost like a CPP #define
18:46:25 <bb010g> Algebr: It's macroish...called an operator in C because it's built in.
18:46:27 <jle`> take that for what it's worth :)
18:46:29 <timemage> and you can't take the address of it.  or create a proper c declaration for it.
18:46:31 <apples> well, it's not always at compile time :)
18:46:36 <jle`> apples: really? :O
18:46:39 <jle`> then i don't know anything :|
18:46:46 <Algebr> apples: not at compile time??
18:46:50 <bb010g> It's converted to the size of the type/thing put in at compile time.
18:46:50 <apples> yeah, sizeof on a VLA will be at runtime
18:47:04 <Algebr> VLA == variable length array?
18:47:07 <apples> yup
18:47:12 <haasn> The distinction between function and operator seems to be greater in languages which don't allow defining your own operators
18:47:17 <bb010g> Nobody likes C VLAs. :D
18:47:32 <Algebr> heh. So <$> is an operator, but fmap is a function?
18:48:04 <haasn> Those are both true
18:48:08 <haasn> <$> is also a function
18:48:21 <bb010g> Algebr: They're both functions. I'd guess an operator is a function named with symbols and automatically infix. You can also do `fmap` as infix and even give it a fixity.
18:48:39 <Algebr> haasn: so is fmap an operator?
18:48:52 <Algebr> bb010g: that's where I'm leaning towards now
18:48:59 <Algebr> that understanding
18:51:13 <haasn> bb010g: I'd say that still doesn't make it an operator; you're just using it infix
18:51:45 <EvanR> operator vs function in this case is a syntax topic, they are both functions semantically
18:52:35 <EvanR> operator and function are two distinct things in the syntax with different rules
18:52:39 <bb010g> haasn: It acts exactly like one, though (save for partial application IIRC).
18:53:17 <haasn> Hmm, according to the report, <$> and `fmap` would both syntactically be “variable operators”
18:54:54 <haasn> The report name for a name like fmap that doesn't consist of symbols is “identifier”
18:55:00 <bb010g> :t ((+1) `fmap`)
18:55:01 <lambdabot> (Num b, Functor f) => f b -> f b
18:55:08 <Algebr> haasn: that's rather generic.
18:55:09 <bb010g> Oh, you can partially apply
18:55:15 <AshyIsMe> god i have no idea what im doing with haskell
18:55:16 <haasn> Which are subdivided into variable identifiers (lower-case start) and constructor identifiers (upper-case start)
18:55:17 <bb010g> Algebr: Correct. :)
18:55:29 <AshyIsMe> is there an example project for using the hedis package somewhere?
18:57:12 <bb010g> Algebr: Can't find an example elsewhere quickly, but you can see an example of named operator fixity here: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#local-fixity-declarations
18:57:59 <bb010g> Support for them also just got added to Haddock: http://fuuzetsu.co.uk/blog/posts/2014-03-24-New-Haddock-released!-A-visual-guide-to-changes.html
18:58:31 <haasn> In other words, fmap is an identifier, <$> is an operator symbol, both <$> and `fmap` are operators, both fmap and (<$>) are variables, and coincidentally both fmap and <$> are functions
18:58:49 <haasn> At least if you want to use report terminology
19:01:27 <bb010g> haasn: Wouldn't `fmap` and (<$>) be operators too?
19:01:34 <bb010g> s/operators/functions/
19:01:44 <marchelzo_> If I have a regex like "Name: ([a-zA-Z]+)" and a string like "Name: Bob, Name: Jim", how would I simple get a list of all the matches, in this case ["Bob", "Jim"]? The documentation for the Regex modules is very difficult to understand. I really think this should be a simple task to accomplish
19:01:56 <bb010g> marchelzo_: Use parsec.
19:02:13 <marchelzo_> bb010g: I want to use regex, though
19:03:55 <orzo> parsec is too old to use
19:04:26 <bb010g> orzo: Too old?
19:04:28 <orzo> maybe attoparasec or something is a better suggestion
19:04:43 <orzo> yes, too old, makes dll hell
19:04:47 <haasn> bb010g: There's no clear answer on this; “function” is not a clearly defined lexical item but rather a name we assign to anything we can apply, which is dependent on type checking rules. I'd say yes to both
19:04:54 <bb010g> Upload date	Sat Jan 11 06:13:21 UTC 2014
19:04:58 <orzo> oh
19:05:05 <haasn> Simply because `fmap` and (<$>) both type-check the same as fmap and <$> do
19:05:09 <marchelzo_> What is the most practical, beginner friendly way to achieve this? I'm not totally against using parse combinators, but I just think regex is easier. I've never used Parsec or Attoparsec
19:05:17 <orzo> well, i dont know that means its sufficiently updated
19:05:24 <bettyclamp> Does parsec have a way to negate a string, ie., to accept anything that isn't that string?
19:05:35 <orzo> i wouldnt use parsec myself
19:05:56 <bb010g> marchelzo_: You want to match a sequence of Latin letters?
19:06:32 <EvanR> bettyclamp: yes
19:06:48 <marchelzo_> bb010g: Yes, while at the same time, extracting the matches and returning a list of all of them
19:07:03 <haasn> marchelzo_: A simple parsec example of that regex could be something like: string "Name: " >> many1 letter
19:07:49 <haasn> And to get a list of those, separated by commas, you could extend this using “sepBy”, eg.
19:08:14 <EvanR> marchelzo_: "Name: " followed by one or more (whatever letters) is one parser which produces the name, and you apply this to a whole thing to get repetitions of names separated by a comma with a combinator. this would give the list of names
19:08:15 <haasn> parser = (string "Name: " >> many1 letter) `sepBy` string ", "
19:08:18 <haasn> Does that make sense?
19:08:25 <bb010g> marchelzo_: With Control.Applicative & Text.Parsec, name = "Name:" *> some letter
19:08:59 <EvanR> alternatively figure out how to use regex and then come back and explain it to me because im curious ;)
19:09:16 <EvanR> parser combinators are more flexible though
19:09:47 <bb010g> marchelzo_: parser = let name = string "Name:" *> some letter in name `sepBy` string ","
19:10:16 <bb010g> I would recommend importing Control.Applicative and using that; you can do a lot and the functions make more sense (to me at least)
19:10:17 <marchelzo_> EvanR: I really don't think that's going to happen. I don't know what RegexLike is. I don't know what RegexContext is. I don't what any of the types or typeclasses used in the documentation for regex modules are.
19:10:32 <EvanR> marchelzo_: yeah :\
19:10:45 <EvanR> regex sucks anyway ;)
19:10:55 <marchelzo_> I don't have Parsec or Attoparsec.. shouldn't they by default?
19:11:03 <haasn> bettyclamp: EvanR: I guess something like that would involve “try” and “guard”? Or would it be possible to do it more elegantly using notFollowedBy?
19:11:05 <marchelzo_> they be installed*
19:11:50 <bb010g> marchelzo_: Changing from Parsec to Attoparsec is like changing from String to Text; do it if you hit speed concerns.
19:12:31 <marchelzo_> bb010g: Is the syntax the same? Because I was reading a little introduction on fpcomplete just now that uses attoparsec and it seems pretty intuitive
19:13:00 <bb010g> marchelzo_: When I checked, Attoparsec was a bit weirder; it may be different now.
19:13:09 <EvanR> haasn: to check that a whole string does not match a given string, thats simply a /=. to check that a string does not occur next, use notFollowedBy
19:13:27 <haasn> Oh, yes; I looked at Text.Parsec.Token and it does if (isReservedName name) then unexpected ..
19:13:32 <haasn> which is semantically equivalent to mzero aka guard
19:14:27 <bb010g> Parsec could stand to use Control.Applicative/other standard libraries more.
19:14:53 <haasn> I guess the modern variant would be something like trifecta
19:15:09 <haasn> Or the “parsers” api (which can work with parsec, attoparsec, trifecta, etc.)
19:15:23 <bb010g> Ooh, kmett. :)
19:16:19 <bb010g> I'll have to look into Trifecta
19:17:47 <marchelzo_> haasn: Ok, so I have defined that parser. But it's type signature is weird and I don't know what to do with it :/
19:17:58 <bb010g> What's the signature
19:18:17 <marchelzo_> Stream s m Char => ParsecT s u m [[Char]]
19:18:28 <marchelzo_> Not very helpful to me
19:18:41 <enthropy> > getAllTextSubmatches  ("Name: Bob, Name: Jim" =~ "Name: ([a-zA-Z]+)(, Name: ([a-zA-Z]+))*") :: [ String ]
19:18:42 <lambdabot>  Not in scope: ‘getAllTextSubmatches’Not in scope: ‘=~’
19:18:42 <lambdabot>  Perhaps you meant one of these:
19:18:42 <lambdabot>    ‘==’ (imported from Data.Eq), ‘#~’ (imported from Control.Lens),
19:18:42 <lambdabot>    ‘&~’ (imported from Control.Lens)
19:18:46 <enthropy> boo
19:19:05 <marchelzo_> enthropy: if only it were that easy
19:19:36 <marchelzo_> s/it's/its :(
19:20:12 <enthropy> well that one gives you ["Name: Bob, Name: Jim","Bob",", Name: Jim","Jim"]
19:20:16 <Algebr> say you have function foo with type: IO Bar -> String -> Bar. How can I write foo (done action for IO) "something".
19:20:42 <enthropy> probably there's some other instance of RegexContext that doesn't collapse everything together
19:21:05 <marchelzo_> enthropy: I've been converted to parsec
19:21:14 <enthropy> regex-applicative is a nice middle ground
19:22:01 <bb010g> marchelzo_: runParser parser () "ghci"
19:22:50 <EvanR> marchelzo_: the type should probably be Parser [String]
19:23:11 <orzo> the main reason to use Text over String imo is to be compatible with xml libraries
19:23:27 <EvanR> also Text a megabyte long will not crash your stick
19:23:28 <marchelzo_> EvanR: the type of what?
19:23:37 <EvanR> marchelzo_: the parser you originally were trying to write
19:23:46 <orzo> meshing with libraries is far more significant in making these choices than efficiency
19:23:49 <EvanR> Stream s m Char => ParsecT s u m [[Char]]
19:24:22 <bb010g> marchelzo_: runParser (let name = string "Name: " *> some letter in name `sepBy` string ", ") () "ghci" "Name: Bob, Name: Jill" gives Right ["Bob","Jill"]
19:24:25 <EvanR> orzo: ok but if you do an operation on String and it causes a full program termination due to stack overflow, thats not an efficiency problem
19:24:56 <marchelzo_> bb010g: what's with the () "ghci" ?
19:25:24 <bb010g> The most general way to run a parser over the Identity monad. runParser p state filePath input runs parser p on the input list of tokens input, obtained from source filePath with the initial user state st. The filePath is only used in error messages and may be the empty string. Returns either a ParseError (Left) or a value of type a (Right).
19:25:25 <EvanR> thats the state
19:25:38 <bb010g> From the docs
19:26:20 <bb010g> And I would recommend using import Text.Parsec hiding (many, many1, skipMany, skipMany1, optional, (<|>))
19:26:22 <orzo> i think utf8 bytestrings are a reasonable default orientation
19:26:24 * hackagebot word8 0.1.0 - Word8 library  http://hackage.haskell.org/package/word8-0.1.0 (KazuYamamoto)
19:26:48 <bb010g> And these definitions:
19:27:00 <bb010g> https://www.irccloud.com/pastebin/KPrtvOBL
19:27:10 <EvanR> orzo: really, Text is better
19:27:29 <orzo> not as a default
19:27:39 <EvanR> which is easily converted between utf8 bytestring and back
19:28:10 <orzo> that makes sense if you need a lot of that Text functionality
19:28:22 <EvanR> orzo: nah i prefer my text strings to give me character by character
19:28:22 <orzo> but as a default, in simple cases, it seems stupid to convert to and fro pointlessly
19:28:47 <EvanR> 1/3 of a utf8 character is a silly unit when trying to do text
19:29:08 <orzo> i dont understand
19:29:13 <EvanR> simple things like length the text, in characters, not good with bytestrings
19:29:21 <EvanR> String or Text, better
19:29:26 <EvanR> Text, even better
19:29:28 <carter> yes
19:29:36 <carter> unlessyou're doing binary data, bytestrings will troll you
19:29:45 <carter> it'll wokr until its totally broken
19:29:51 <bb010g> See also: C char*
19:29:51 <suOya_> How can I turn a list's tail into a traversal with the lens library?
19:30:06 <orzo> um, the simplicity of conversion to Text works as well for ByteStrings
19:30:13 <carter> yup
19:30:21 <orzo> so you cant argue that it will totally ruin you if you use ByteStirng mostly
19:30:32 <EvanR> if you are doing binary data, use bytestrings
19:30:36 <EvanR> if its 100% text, Text
19:30:40 <carter> yes
19:30:41 <EvanR> two different things
19:30:48 <marchelzo_> bb010g: thank you
19:30:50 <carter> EvanR ++
19:30:56 <marchelzo_> we had success
19:31:00 <orzo> shrug
19:31:04 <bb010g> C went through all this already; learn from their mistakes with Unicode.
19:31:07 <carter> orzo: are you a student? :)
19:31:08 <EvanR> do not want ascii-ish limitations in my program in 2014
19:31:22 <orzo> if you have UTF8 stream, then ideal would be a utf8-capable text library
19:31:26 <bb010g> marchelzo_: Glad to help. :)
19:31:31 <carter> yes, thats calle dtext
19:31:36 <EvanR> yep
19:31:41 <carter> you can decode/encode from utf8
19:31:52 <EvanR> you can pretend its utf8 heh
19:31:57 <carter> and internally its an unboxed vector of word8
19:32:00 <EvanR> after obeying the type system
19:32:04 <orzo> oh no
19:32:13 <orzo> carter: Text is internally word16
19:32:18 <carter> oh yeah
19:32:23 <EvanR> its the same thing
19:32:32 <carter> orzo: well, if you wanna patch text to use utf8, please share the benchmarks
19:32:33 <carter> :)
19:32:33 <EvanR> dont worry about the implementation ;)
19:32:54 <carter> it'd probably be pretty easy to just instead do a compressed Text type
19:32:57 <EvanR> some damn bits and bytes that we dont have to deal with
19:32:57 <orzo> its not just about benchmarks
19:32:59 <carter> easier even
19:33:09 <orzo> in a unixy environment, utf8 is more interoperable with c libraries
19:33:30 <EvanR> the Text library handles it for you
19:33:37 <EvanR> write Text to a file, works
19:33:47 <EvanR> utf8
19:33:56 <orzo> i gues syou could incorporate c libraries in your benchmarks
19:34:01 <EvanR> in my code i do not want to deal with utf8 or anything
19:34:38 <orzo> are you on a unix?
19:34:39 <carter> i've had code break because of encoding assumptions
19:34:45 <EvanR> you are contradicting yourself by saying it is text data and that you do not want to treat it as text data
19:34:46 <carter> encodings are a pain
19:34:50 <orzo> utf16 is like way way windows-centric
19:34:53 <carter> encoding != text
19:35:10 <EvanR> utf16 is an implementation detail for performance
19:35:36 <EvanR> its clear that you may need to use raw bytestrings if you find it beneficial to performance
19:35:44 <EvanR> but that shouldnt be the default
19:35:45 <orzo> "performance" according to some set of biased benchmarks
19:35:51 <Algebr> @undo  do
19:35:51 <lambdabot> <unknown>.hs: 1: 3:Parse error: Last statement in a do-block must be an expression
19:35:51 <Algebr>   conn <- open "test.db"
19:35:51 <Algebr>   r <- query_ conn "Select * from test" :: IO [TestField]
19:35:54 <Algebr>   mapM_ print r
19:35:57 <Algebr>   close conn
19:36:00 <Algebr>  
19:36:05 <carter> orzo: whats your goal
19:36:10 <orzo> linux software
19:36:19 <EvanR> Text works
19:36:19 <bb010g> It doesn't matter how it's handled internally interfacing wise as long as you can convert it to a WordWhatever, as you can convert those. What's most important is how fast it is internally in Haskell code most of the time. If Word16 is faster, it should be used and good on Microsoft.
19:36:21 <orzo> interoperating with libs
19:36:26 <orzo> efficiently
19:36:33 <orzo> also, i have protocol on the wire that is ut8
19:36:34 <orzo> utfr8
19:36:36 <orzo> er
19:36:38 <carter> whats efficiently
19:36:38 <orzo> you get the iea
19:36:45 <carter> define efficiency
19:36:51 <EvanR> microsoft is probably utf8 these days mostly
19:37:07 <bb010g> @undo do {conn <- open "test.db"; r <- query_ conn "Select * from test" :: IO [TestField]; mapM_ print r; close conn}
19:37:07 <lambdabot> open "test.db" >>= \ conn -> (query_ conn "Select * from test" :: IO [TestField]) >>= \ r -> mapM_ print r >> close conn
19:37:12 <bb010g> Algebr: ^
19:37:19 <EvanR> orzo: yeah but most of the time you are probably not operating "in the protocol" throughout your program, you want a easy interface
19:37:22 <Algebr> bb010g: yay, thanks!!
19:37:32 <EvanR> you dont want to be doing bit flipping to read the values of your data, explicitly
19:37:57 <orzo> scan a utf8 string for an ascii substring?  Text version: convert both to utf16, perform search.  UTF8 version: strstr()
19:37:59 <EvanR> just like you dont usually define your datatypes with bitfields
19:38:02 <EvanR> even in C
19:38:06 <Iceland_jack> Yeah, the reasons for picking UTF-16 are detailed in the paper
19:38:17 <bb010g> Iceland_jack: Link?
19:38:19 <Iceland_jack> (internally) compared to UTF-8 and and UTF-32 I believe
19:38:48 <orzo> to poo poo conversions is stupid, on unix, nearly every input is going to be utf8
19:38:54 <EvanR> orzo: substring search on bytestrings has a really good implementation on hackage, and you can use it if you want to bitfiddle some performance ;)
19:39:20 <orzo> and your output is often utf8 also
19:39:27 <EvanR> orzo: if you consider all the inputs and outputs as binary data, just use bytestring, which we already said
19:39:42 <EvanR> agreeing that utf8 is the assumed encoding
19:39:49 <Iceland_jack> bb010g: It was a long time ago that I read it, searching for 'haskell text thesis ext:pdf' is probably as good as my guess
19:39:55 <EvanR> do not recommend text operations though
19:40:05 <Iceland_jack> 'fusion' and 'utf*' as well
19:40:10 <Algebr> bb010g: ah, I was so close. I'm trying to not do do notation.
19:40:12 <carter> chart counts are hard in utf8
19:40:37 <orzo> right, which is what my code used to do until i wanted to use libraries which switched used Text and then i eventually rewrote it all as Text for simpler looking code, but ultimately i don't think Text does the right thing for me
19:40:47 <Iceland_jack> bb010g: I think this is it http://www.cs.ox.ac.uk/files/3929/dissertation.pdf [Fusion on Haskell Unicode Strings]
19:40:54 <orzo> thus the primary to use Text: the libraries that use Text
19:40:59 <orzo> primary reason
19:40:59 <EvanR> yeah, instead feed the binary data to the library and convert there
19:41:08 <Iceland_jack> carter: The fourth sectino includes benchmarking between encodings
19:41:09 <bb010g> Algebr: You can even do some changes, like \r -> mapM_ $ print r to mapM_ . print
19:41:10 <Iceland_jack> *section
19:41:18 <EvanR> orzo: xml is text, not binary data
19:41:20 <EvanR> use Text
19:41:21 <EvanR> hehe
19:41:22 <orzo> well Text could have offered me a utf8 impelmentation
19:41:30 <bb010g> Iceland_jack: Thanks.
19:41:32 <carter> orzo: write the patch :)
19:41:46 <orzo> xml is encoded on the wire in some format, and in my case, that format is not utf16
19:41:47 <EvanR> insisting on optimizing while using xml hehe
19:42:11 <EvanR> next we will optimize haskell performance inside ruby on rails
19:42:24 <EvanR> by changing default core features
19:43:06 <bb010g> https://www.irccloud.com/pastebin/jIXKVyQ9
19:43:15 <orzo> i also dont like utf16 simply because it seems pointless
19:43:17 <bb010g> orzo: This may shed some light on UTF-16: ^
19:43:26 <EvanR> orzo: would be interested in the benchmark for a conforming xml system that used utf8 internally
19:43:27 <bb010g> Copied from the paper Iceland_jack dug up
19:43:40 <orzo> page didnt load, bb010g
19:43:55 <bb010g> Which one? The pastebin loads fine for me.
19:44:08 <bb010g> Try reloading.
19:44:13 <orzo> it worked afte ri enabled javascript
19:44:14 <Iceland_jack> pastebin loads for me
19:44:16 <orzo> kind of annoying
19:44:19 <EvanR> utf anything is pointless in the face of a world with just ascii text
19:44:33 <EvanR> i.e. 1989
19:44:48 <bb010g> EvanR: Flip side is ASCII anything is pointless in the face of a world with just UTF text
19:44:56 <bb010g> i.e. now
19:45:02 <EvanR> no, thats utf8
19:45:06 <orzo> bb010g: i read a few sentences and see no reason to continue
19:45:08 <EvanR> ascii anything == utf8 ;)
19:45:15 <suOya_> Lens question: How can I get a traversal over the values in a Map?
19:45:21 <orzo> obviously i know what utf8,utf16, and utf32 are
19:45:25 * EvanR puts feed bag away
19:45:40 <bb010g> UTF-16 is often less compact than UTF-8 due to the fact that even the lowest value
19:45:40 <bb010g> characters are represented by a 16-bit (2 byte) value. Some characters, however, only take one
19:45:40 <bb010g> UTF-16 word but three UTF-8 bytes. Validation and parsing of UTF-16 is far easier than
19:45:40 <bb010g> UTF-8, however, because of the simpler encoding scheme. This can yield greater performance
19:45:40 <bb010g> at the cost of memory.
19:45:46 <bb010g> From that snippet
19:45:55 <bb010g> EvanR: :)
19:46:18 <orzo> parsing is not easier
19:46:42 <EvanR> requesting the next n characters dequeue from a stream is most costly with utf8
19:46:51 <orzo> since typically all the interesting lexemes are ascii substrings, parsing is not easier
19:47:04 <suOya_> Can someone help me with lens? I have a small question
19:47:18 <carter> suOya_: #haskell-lens is better for that
19:47:27 <bb010g> I don't know much, but I would trust the person who wrote the 60-page paper on it
19:47:32 <suOya_> Oh, I didn't know that existed, thanks
19:47:38 <EvanR> bb010g: probably not a good argument
19:48:03 <carter> yeah, i could write 100 pages of lies :)
19:48:05 <EvanR> orzo: of course youre right, but the parser is not intended to only process ascii text
19:48:17 <EvanR> its xml
19:48:33 <bb010g> EvanR: He put a bunch more work into it and it got accepted by the general Haskell community.
19:49:28 <orzo> utf-16 is pointless and wrong, you can google and find plenty of smart people to agree with me
19:49:30 <bb010g> It's hard to bluff your way to a solid library.
19:50:00 * EvanR trolls back at orzo 
19:50:22 <carter> i feel like folks outside of europe probably like utf16
19:50:28 <orzo> that troll was meant for bb010g, not EvanR
19:50:39 <orzo> please take back your counter troll
19:50:39 <bb010g> orzo: Well, put an issue here: https://github.com/bos/text/issues
19:50:51 <EvanR> utf16 sucks for interchange, american bias
19:50:54 <EvanR> unix bias talking
19:51:52 <orzo> unix bias is justifiable on social grounds because its basically where the commons is
19:52:37 <EvanR> of course this isnt about interchange at all
19:52:50 <EvanR> if it used utf32 it would have been even better ;)
19:53:21 <carter> yeah
19:53:22 <carter> so true
19:53:25 <orzo> utf32 > utf16, agreed
19:53:29 <carter> better asymptotics
19:53:33 <suOya_> carter: No one seems to be active, so can I ask you?
19:53:34 <bb010g> :)
19:53:45 <carter> suOya_: TRY asking there
19:53:50 <bb010g> carter: He did
19:54:02 <carter> ah
19:54:10 <carter> suOya_: i barely know how to use lens
19:54:13 <carter> i know many things
19:54:15 <carter> but not that
19:54:17 <suOya_> carter: Alright :)
19:54:26 <carter> oh
19:54:30 <carter> i'd jsut use traverse
19:54:35 <carter> isn't traverse a Traversal?
19:54:46 <bb010g> @hoogle traverse
19:54:47 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
19:54:47 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
19:54:47 <lambdabot> package traverse-with-class
19:55:12 <carter> Data.Map * should have traversable instances
19:55:48 <suOya_> I tried that but traverse didn't work
19:55:54 <suOya_> I'll keep searching though ^^
19:57:01 <carter> why not?
19:57:06 <carter> what happened?
19:57:20 <carter> when something iddn't work
19:57:23 <carter> something HAPPENED
19:57:24 <carter> what ahppened?
19:58:01 <suOya_> Okay, small description: I have a World which contains a Map Int Player -datatype, and I'm trying to get a Traversal' World [Player]
19:58:03 <carter> http://lens.github.io/tutorial.html
19:58:50 <suOya_> I tried "playerMap . traversal" but the types didn't match
19:59:15 <suOya_> "playerMap . traverse"*
19:59:21 <carter> and what hapepned
19:59:22 <EvanR> wish i knew anything about lens
20:00:32 <suOya_> well the type error is somewhat long, I'll paste it...
20:00:57 <suOya_> carter: http://lpaste.net/107456
20:01:18 <bb010g> Has anyone here worked with wreq? I've dealt with pipes-network a bit, but only looked at wreq and it looked nice.
20:01:22 <carter>  Couldn't match expected type `Player Alive'
20:01:23 <carter>                 with actual type `[Player Alive]'
20:01:27 <carter> suOya_: is all you need to know
20:02:00 <suOya_> the thing is I'm expecting a [Player Alive]
20:02:07 <suOya_> shouldn't traverse return a list like that?
20:02:09 <carter> suOya_: pause and STARE at the type
20:02:18 <carter> you want f x = [x]
20:02:21 <carter> or?
20:02:33 <carter> thats a pretty small type error message :)
20:02:35 <suOya_> no, I just want the values of the Map inside a list
20:02:38 <carter> ok
20:02:46 <carter> lets do something differnt
20:02:46 <suOya_> traversed over, I mean
20:02:57 <carter> to make your life simpler
20:02:59 <carter> lets try
20:03:18 <carter> mapPlayers . toList
20:03:19 <carter> :)
20:03:27 <carter> erm
20:03:35 <carter> mapPlayers . map snd . Map.toList
20:03:59 <suOya_> yeah, I know how to do it without lenses
20:04:10 <carter> ok
20:04:11 <suOya_> but here I want a traversal over those values
20:04:18 <carter> why
20:04:29 <carter> anyways, i 'm the worst person to ask for help wrt this
20:04:38 <suOya_> so I can edit them on the fly like lenses allows you to do
20:04:53 <carter> suOya_: people are replying
20:04:56 <carter> go talk with tem
20:05:27 <suOya_> thanks for your time
20:07:01 <jmcarthur> sometimes i wish i could get ghci to just use :print in place of Show. maybe there's some magic to use...
20:07:51 <carter> :print 7 didn't wokr
20:08:06 <carter> jmcarthur: only works on variables
20:08:08 <carter> gotcha
20:09:16 <jmcarthur> carter: that's just a silly limitation. i could always just put in the expression and then type:   :print it
20:09:36 <carter> WOAH
20:09:45 <carter> are you a wizzard
20:09:51 <jmcarthur> it is redefined for each unbound expression you type in
20:10:05 <jmcarthur> so you can say   7+7   and then   it+8
20:11:03 <bb010g> jmcarthur: That...is amazing. Why did I not think of that before...
20:11:54 <suOya_> carter: OH now I got why my code was wrong... I realized why it has to be Player in the signature not [Player]
20:12:02 <carter> :)
20:12:05 <carter> yay
20:12:05 <suOya_> carter: I started learning lenses today so.. ^^
20:12:11 <carter> suOya_: read the type errors
20:12:15 <carter> stare at then
20:12:18 <carter> cherris them
20:12:22 <carter> go on bike rides with them
20:12:24 <jmcarthur> anyway, unlike the print function, :print actually works for types that don't have a Show instance
20:12:25 <suOya_> carter: Yeah I stared at it for a long time
20:12:25 <carter> get to know them really well
20:12:31 <carter> you'll get better
20:12:34 <jmcarthur> which is why i want it to be the default in this particular case
20:12:37 <carter> then oyu'll be able to deal with crazy stuff
20:13:00 <jmcarthur> even though it means i have to force the whole value to WHNF
20:13:31 <jmcarthur> a  :whnf  command would be nice in ghci, actually...
20:13:37 <jmcarthur> instead of relying on some type class
20:13:55 <EvanR> suOya_: today when doing some research i reasoned that explicit type annotations that the programmer put should have a higher priority when computing error messages, maybe im wrong ;)
20:14:10 <carter> suOya_: https://gist.github.com/cartazio/9150170 is one of the simpler type errors i've had to deal with in the past few months :)
20:14:37 <jmcarthur> A pattern match on a GADT requires GADTs or TypeFamilies ... seems straightforward ;)
20:14:49 <suOya_> carter: Okay what the **** is that?
20:14:54 <carter> :)
20:15:02 <jmcarthur> actually, it's weird that TypeFamilies would enable pattern matching on a GADT
20:15:09 <suOya_> EvanR: What do you mean, exactly?
20:15:16 <jmcarthur> or at least there is something i don't understand there
20:15:29 <EvanR> suOya_: id think that typing the top level signatures is easier than writing the code correctly
20:15:43 <EvanR> so the compiler would take those to be more likely to be right
20:15:57 <EvanR> i dont think it does, but you are making me second guess my assumption ;)
20:16:24 <suOya_> I don't think it does either, but I also don't think it should
20:16:35 <EvanR> yeah
20:16:51 <suOya_> Compiler is there just to cuss at you when you do things wrong
20:17:00 <EvanR> personally i cant continue unless i get that top level signature right
20:17:33 <suOya_> EvanR: That's why I like Haskell, it feels like a puzzle when you build your program signature by signature
20:17:45 <EvanR> legos
20:17:47 <EvanR> lol
20:17:56 <suOya_> advanced legos, yes
20:18:03 <Hodapp> that's sort of how it is for me too, in the limited Haskell I've written
20:18:46 <suOya_> I think I'd have a hard time moving to a weakly typed language after getting used to Haskell
20:19:02 <EvanR> its definitely a missing feature
20:19:19 <Hodapp> suOya_: weakly, or dynamically? ;)
20:19:21 <EvanR> i do not find it entertaining to be able to run my program before it remotely made any sense
20:19:33 <suOya_> Hodapp: dynamically, actually
20:20:08 <EvanR> its as if your program could run with syntax errors (which is possible in my popular systems)
20:20:24 <suOya_> Dynamically written programs give me this 'leaky' feeling when they go past medium size
20:20:29 <EvanR> why this is thought of as a feature i do not know
20:21:07 <EvanR> in php a program 1 line long is leaky
20:21:13 <suOya_> Heh
20:21:41 <suOya_> Yeah Haskell forces you to think about structure before you can even run your program
20:21:41 <EvanR> youll never know what a documented function like mixed foo(mixed, mixed, mixed, ...) does
20:21:50 <suOya_> EvanR: Exactly
20:23:16 <suOya_> With some good type and variable names Haskell code is pretty self-documenting
20:23:22 <suOya_> Lens is an exception to this
20:23:25 <EvanR> hah
20:25:00 <carter> suOya_: wanna see my most comlicated piece of haskell ? :)
20:25:09 <carter> you'll not understand it very easily :)
20:25:13 <carter> its got no lens
20:25:23 <carter> about 1 line of comment for every line of code
20:25:24 <EvanR> obfuscated code contest
20:25:25 <suOya_> carter: well go on
20:25:38 <tgeeky> that's not saying much; I can (and have) written plenty of code that even I don't understand :o
20:25:39 <enthropy> there's conflict between short names that let you see the shape of an expression
20:25:45 <enthropy> and descriptive names
20:26:05 <carter> enthropy++
20:26:09 <suOya_> enthropy: Yeah, you shouldn't go full Java
20:26:14 <johnw> also, descriptive names don't necessarily describe anything
20:26:22 <bb010g> carter: Are you going to show it? :)
20:26:23 <carter> johnw: they do for my stuff
20:26:29 <johnw> i could have a function named "harmless" that shoots ze missiles
20:26:37 <carter> https://github.com/wellposed/numerical/tree/master/src/Numerical/Array :)
20:26:43 <johnw> dontCallMe
20:26:47 <suOya_> johnw: That's not a good name then
20:26:47 <carter> please dont share or circuitlate
20:26:50 <carter> still pre alpha
20:26:52 <bb010g> carter: Just pick one?
20:26:59 <carter> ?
20:27:07 <tgeeky> dontCallMe Maybe?
20:27:31 <bb010g> carter: You linked to a directory
20:27:36 <carter> yes
20:27:43 <carter> its a whole project
20:27:55 <gamegoblin> link to a particularly bad bit please
20:28:01 <carter> hrmmm
20:28:09 <johnw> suOya_: good vs. not good comes down to discipline, and in programming, discipline always fails.  I'll take one letter names and a meaningful type, or descriptive names with liberal types, any day.
20:28:19 <johnw> s/or/over
20:28:26 <carter> gamegoblin: nothings bad
20:28:32 <carter> its just its pretty intricate
20:28:34 <EvanR> enthropy: more like the time and place for both are mostly mutually exclusive ;)
20:28:51 <gamegoblin> So I have this type that contains a few lists in it. Oftentimes, the lists are empty. So I have a lot of code that looks like MyType [] [] [] [some stuff] []. Is there a good idiom for avoiding this?
20:28:55 <EvanR> the x and xs would be pretty wrong to describe in haskell code
20:29:05 <EvanR> the name of a function shouldnt be "foo"
20:29:13 <suOya_> gamegoblin: Use data records?
20:29:25 <carter> https://github.com/wellposed/numerical/blob/master/src/Numerical/Array/Layout/Dense.lhs was tricky to write,
20:29:32 <gamegoblin> suOya_: Will it initialize stuff to empty lists?
20:29:37 <carter> well, not as tricky as some other stuff
20:29:46 <Krenium> I thought you had to initialize every field in a record
20:30:00 <EvanR> you dont have to but
20:30:03 <suOya_> gamegoblin: you can just write MyType [] [] [] [] [] and there you'll have a record with empty lists
20:30:34 <EvanR> Krenium: you can leave them uninitialized or explicitly put undefined in them
20:30:50 <EvanR> if you are feeling lucky
20:31:08 <Krenium> If I leave one out I get an error. I'm learning about them now.
20:31:11 <suOya_> Only leave them undefined if you're sure you initialize them later
20:31:26 <SamB> gamegoblin: you could make a short name for the one with all-[] fields and then use record update to fill in whichever?
20:31:33 <dagano> i'm trying to find the minimum 'value' for an intmap. can i just use pattern matching and recursion? what is a good way to deal with this?
20:31:41 <dagano> can i find a minimum with fold?
20:31:46 <EvanR> Krenium: i knew the compiler can warn you, but i guess its the default now
20:31:58 <Krenium> Oh, and it's in ghci btw
20:31:59 <carter> dagano: maybe you want a heap :)
20:32:07 <carter> hackage.haskell.org/package/heaps
20:32:12 <SamB> dagano: not the minimal key?
20:32:13 <dagano> carter: :) but my graph is already in an intmap .. should i heapify it?
20:32:20 <carter> idk
20:32:22 <dagano> SamB: no the value
20:32:24 <carter> whatever works for you
20:32:25 <carter> :)
20:32:35 <SamB> if you want the minimal value, it really doesn't matter that it's an IntMap
20:32:38 <carter> dagano: you could track it as you insert
20:32:49 <carter> dagano: o you need to query for min and extract
20:32:52 <carter> or just once?
20:33:06 <bb010g> carter: Very nice code. :)
20:33:20 <carter> bb010g: do you know what it does? :)
20:33:29 <bb010g> carter: Ish.......?
20:33:32 <carter> guess
20:33:36 <carter> lets go to #numerical-haskell
20:33:41 <carter> and i'm happy to talk about it
20:33:48 <carter> and hearing how people guess walk their way through
20:33:55 <carter> helps me understand hwo to help people use it
20:34:05 <dagano> SamB: how do i traverse the intmap though?
20:34:26 <dagano> using something like x:xs for lists
20:35:13 <dagano> mapAccum?
20:35:34 <glguy_> ?type F.foldl' min 0
20:35:35 <lambdabot> (Foldable t, Ord a, Num a) => t a -> a
20:35:53 <glguy_> Works on an intmap
20:36:04 <glguy_> If you want minimum value
20:36:14 <glguy_> And if 0 is your min
20:36:41 <dagano> glguy_: thanks
20:36:51 <SamB> ?type F.foldl1' min
20:36:51 <lambdabot>     Not in scope: ‘F.foldl1'’
20:36:52 <lambdabot>     Perhaps you meant one of these:
20:36:52 <lambdabot>       ‘F.foldl1’ (imported from Data.Foldable),
20:37:00 <SamB> aww
20:37:07 <SamB> ?type F.foldl1 min
20:37:08 <lambdabot> (Foldable t, Ord a) => t a -> a
20:38:48 <glguy_> Or just use minimum . IntMap.toList
20:39:13 <dmj`> dagano: there is a map :: (a -> b) -> IntMap a -> IntMap b
20:39:14 <dagano> does the fcn Data.IntMap.fold have to be an instance of Foldable class?
20:39:55 <dagano> generally, how can i use map to find a minimum? can someone show me a list example?
20:40:15 <SamB> glguy_: that last one sounds like the simplest way ;-)
20:41:22 <dmj`> dagano: since IntMap has an instance for Foldable you can use the fold function yes
20:41:26 <Krenium> Anyone know why [1..10] works but [LT..GT] produces an error?
20:41:29 <dmj`> dagano: the minimal key or value?
20:41:32 <Krenium> Yet [LT .. GT] works
20:41:52 <glguy_> Because Capital looks like a module name
20:41:53 <tgeeky> Krenium: I doubt it; what you are saying is that the spacing difference matters?
20:41:54 <SamB> Krenium: because tokens
20:41:57 <bb010g> > F.Foldl1 min [LT..GT]
20:41:58 <lambdabot>  Not in scope: data constructor ‘F.Foldl1’A section must be enclosed in paren...
20:42:06 <bb010g> > F.foldl1 min [LT..GT]
20:42:08 <lambdabot>  A section must be enclosed in parentheses thus: (LT.. GT)Not in scope: ‘LT..’
20:42:20 <bb010g> > F.foldl1 min [LT .. GT]
20:42:21 <lambdabot>  LT
20:42:28 <jle`> Krenium: it treats it like (LT..) ... as in, the operator (.) from the LT module
20:42:35 <dmj`> dagano: if value, then do you have an a such that Ord a => IntMap a
20:43:04 <dmj`> dagano: if key, there is findMin :: IntMap a -> (Key, a)
20:43:29 <SamB> Krenium: basically, by adding spaces, you prevent it from trying to consume a bigger token than you intended
20:44:10 <Krenium> I see, thanks
20:44:10 <tgeeky> > F.fold1 min [LT ..GT]
20:44:11 <lambdabot>  Not in scope: ‘F.fold1’
20:44:12 <lambdabot>  Perhaps you meant one of these:
20:44:12 <lambdabot>    ‘F.foldl1’ (imported from Data.Foldable),
20:44:12 <lambdabot>    ‘F.foldr’ (imported from Data.Foldable),
20:44:12 <lambdabot>    ‘F.foldl’ (imported from Data.Foldable)
20:44:18 <tgeeky> > F.foldl1 min [LT ..GT]
20:44:19 <lambdabot>  LT
20:44:32 <tgeeky> well at least I wasn't exactly wrong
20:46:28 <jmcarthur> > succ Prelude.. succ $ 5
20:46:29 <lambdabot>  7
20:48:43 <EvanR> > succ . succ $ 5
20:48:45 <lambdabot>  7
20:48:57 <jle`> > succ Category.. succ $ 5
20:48:58 <lambdabot>  Not in scope: ‘Category..’
20:49:00 <jle`> oops
20:49:04 <jle`> > succ C.. succ $ 5
20:49:06 <lambdabot>  7
20:49:11 <bb010g> :t (.)
20:49:11 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:49:30 <bb010g> :t (C..)
20:49:30 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
20:49:46 <bb010g> jle`: Why would you expect a difference?
20:50:29 <jle`> bb010g: oh, i didn't.  just wanted to show another module that had a (.) defined
20:50:43 <jle`> ...that's the only other one I know, I think.
20:52:38 <bb010g> ?hoogle (.)
20:52:39 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
20:52:39 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
20:52:39 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
20:53:03 <bb010g> Data.Function has one for some reason...
20:53:31 <jle`> it must be defined in Data.Function
20:53:39 <jle`> and reexported in Prelude
20:53:44 <jle`> i don't think Prelude actaully defines anything itself
20:54:22 <jle`> funny you should mention that actually, i litearlly just imported Data.Function into something I was working on and got a dozen errors because I now had ambiguous (.) and id's
20:54:34 <bb010g> No, it's in GHC.Base: http://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-Base.html#.
20:55:03 <jle`> bb010g: ah
20:55:04 <jle`> how weird
20:55:06 <jle`> :)
20:55:26 <SamB> well, . is pretty handy; I guess they wanted it even for the lowest level stuff!
20:56:34 <jle`> that makes sense
20:57:17 <SamB> ?hoogle map
20:57:17 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
20:57:17 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
20:57:17 <lambdabot> Data.ByteString.Char8 map :: (Char -> Char) -> ByteString -> ByteString
20:57:31 <SamB> ?hoogle map :: (a -> b) -> [a] -> [b]
20:57:32 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
20:57:32 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
20:57:32 <lambdabot> Control.OldException mapException :: (Exception -> Exception) -> a -> a
20:57:48 <bb010g> ?hoogle fmap
20:57:48 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
20:57:48 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
20:57:48 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
20:58:01 <bb010g> Hmm, no Data.Set
20:58:16 <SamB> :i Functor
20:58:41 <EvanR> \o/
20:59:14 <bb010g> EvanR: What?
20:59:24 <SamB> EvanR: what're you doing that for? also did you know there's a unicode codepoint of that?
21:03:16 <EvanR> bb010g: anticipating getting back on the subject of Functor Set
21:03:35 <jle`> now that i implemented minimax, my game is no fun anymore :/
21:03:38 <jle`> because i can't win ;_;
21:03:53 <bb010g> EvanR: Anticipating something external or another discussion?
21:03:56 <EvanR> give yourself some kind of edge
21:04:05 <jmcarthur> jle`: what kind of game is it?
21:04:09 <jle`> it's just connect 4
21:04:12 <jle`> lol
21:04:13 <jmcarthur> ah
21:04:17 <EvanR> oh connect 4
21:04:21 <jle`> i literally can't think more than 4 moves ahead in that game
21:04:21 <MP2E> hehe Super Connect 4 AI
21:04:21 <EvanR> human cannot win
21:04:21 <bb010g> I've pretty much figured out that it can't happen. Ever. :(
21:04:39 <jle`> so...set the lookahead to 5+, and i can't win v.v
21:04:56 <bb010g> jle`: Try a Battleship AI.
21:05:41 <jle`> the thing is that i display the minimax results for debugging so like
21:05:45 <jle`> sometimes i think i'm winning
21:05:52 <jmcarthur> i think games with incomplete information are more fun, with AI
21:05:58 <jle`> and then i notice that the debug says "win guarunteed."
21:06:00 <jle`> and i'm like oh :|
21:06:16 <jle`> jmcarthur: it wasn't for fun, it was mostly to test out my library :)  writing example programs in it
21:06:20 <jmcarthur> i see
21:06:28 <EvanR> is connect 4 a solved game?
21:06:30 <bb010g> jle`: Library for what?
21:06:30 <Adeon> if you believe in yourself maybe even impossible can be overcome
21:06:35 <jmcarthur> EvanR: recently solved, i think
21:07:00 <jle`> EvanR: it is actually is, but i don't think it admits any heuristic that a human player can use
21:07:08 <bb010g> The game was first solved by James Dow Allen (October 1, 1988), and independently by Victor Allis (October 16, 1988).[4]
21:07:15 <bb010g> From Wikipedia
21:07:21 <jmcarthur> ah, nope, solved a while ago
21:07:34 <SamB> what, that's not recent enough for you?
21:07:35 <jle`> bb010g: discrete time automations/simulations/interactive things
21:07:36 <bb010g> Connect Four has since been solved with brute force methods beginning with John Tromp's work in compiling an 8-ply database[4][8] (Feb 4, 1995)
21:08:09 <jle`> bb010g: https://github.com/mstksg/auto and https://github.com/mstksg/auto-examples  .... still in pre pre alpha though
21:09:12 <SamB> ... what's the point of applying brute-force methods to an already-solved game ... ?
21:09:36 <bb010g> SamB: Quick lookup times?
21:10:36 <SamB> bb010g: does the human really care how slowly they lose at connect 4?
21:11:00 <MP2E> hahah
21:11:11 <abc56889_> Is there a ghc setting to allow returning data of ambiguous type, but always with the same typeclass?
21:11:17 <EvanR> reading about the cold solution to connect 4, imaging reading the same sort of analysis in the year 3000 or something about chess... creepy ;)
21:11:48 <bb010g> abc56889_: forall a. whatever -> a?
21:11:56 <bb010g> Or just plain w/o the forall
21:12:22 <bb010g> abc56889_: Sorry, with typeclass T whatever -> T a
21:12:35 <Krenium> Is it going to take that long to solve chess?
21:12:45 <jle`> how about year 4000 when they solve go
21:12:58 <jle`> by they i mean the overlord robots
21:12:59 <EvanR> yeah 3000 chess, 4000 go. thats the sequence
21:13:05 <abc56889_> bb010g: honestly im not sure what to do with that... but yes, the signature would be (SomeClass a) => b -> a, where it will return a different type depending on b
21:13:25 <bb010g> abc56889_: That's a constraint, not a typeclass.
21:13:45 <EvanR> 2000, connect 4
21:13:50 <EvanR> 1000 tic tac toe
21:14:11 <SamB> jle`: their loss!
21:14:26 <bb010g> https://en.wikipedia.org/wiki/Solving_chess
21:14:29 <abc56889_> bb010g: aaha. So is there an easy way to do what I want?
21:14:42 <bb010g> abc56889_: Yes. Give an example of what you're trying
21:15:49 <abc56889_> bb010g: https://gist.github.com/anonymous/155277afac3bd3f4e8b1
21:17:32 <gamegoblin> does a ++ b ++ c evaluate as (a ++ b) ++ c or a ++ (b ++ c) ?
21:18:17 <bb010g> @hoogle (++)
21:18:17 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
21:18:18 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
21:18:18 <lambdabot> Text.ParserCombinators.ReadP (+++) :: ReadP a -> ReadP a -> ReadP a
21:18:46 <bb010g> It's infixr 5, so it does a ++ (b ++ c)
21:19:21 <gamegoblin> Ah ok
21:20:33 <jle`> do we have a safe maximum anywhere?
21:21:08 <gamegoblin> jle`: I also have a haskell connect 4 AI, we should fight them
21:21:14 <jle`> gamegoblin: the end result is technically the same, but can you guess why it's infixr?
21:21:19 <MP2E> oh man
21:21:21 <MP2E> AI fight!
21:21:23 <MP2E> :P
21:21:40 <jle`> gamegoblin: haha mine is still being tweaked ^_^
21:21:48 <gamegoblin> jle`: I know why, and I was making sure it was because of that (the performance reason, in a++b a new copy of a must be allocated)
21:22:14 <gamegoblin> So it’d be really dumb to be infixl
21:22:23 <benzrf> :t BS.concat
21:22:24 <lambdabot> [BSC.ByteString] -> BSC.ByteString
21:22:30 <benzrf> :t BS.++
21:22:31 <lambdabot> parse error on input ‘BS.++’
21:22:35 <benzrf> :t (BS.++)
21:22:36 <lambdabot> Not in scope: ‘BS.++’
21:22:41 <benzrf> how :{
21:22:50 <benzrf> :t BS.append
21:22:51 <gamegoblin> benzrf: ++ is only for lists
21:22:51 <lambdabot> BSC.ByteString -> BSC.ByteString -> BSC.ByteString
21:22:54 <benzrf> ah
21:22:58 <gamegoblin> you can use append or mappend
21:22:58 <abc56889_> bb010g: seems i was looking for ExistentialQuantification
21:23:01 <benzrf> > BS.append "foo" "bar"
21:23:02 <lambdabot>  Couldn't match expected type ‘Data.ByteString.Internal.ByteString’
21:23:02 <lambdabot>              with actual type ‘[GHC.Types.Char]’Couldn't match expected type ...
21:23:02 <lambdabot>              with actual type ‘[GHC.Types.Char]’
21:23:06 <benzrf> blah
21:23:23 <gamegoblin> mappend I think being the most general for all of these types
21:23:34 <bb010g> abc56889_: I'm not seeing how a forall would fix that...
21:23:38 <SamB> iirc, there was a time when ++ wasn't only for lists, back before monomorphism came into vogue ...
21:23:59 <abc56889_> bb010g: just found http://stackoverflow.com/a/1553507/81557
21:24:06 <bb010g> :t (<>)
21:24:06 <SamB> that was a long time ago though
21:24:07 <lambdabot> Monoid m => m -> m -> m
21:24:14 <EvanR> jle`: https://hackage.haskell.org/package/safe-0.3.6/docs/Safe.html
21:24:15 <SamB> before my time
21:24:29 <jle`> EvanR: thanks :)
21:24:44 <Cale> SamB: Yeah, in Haskell 1.4, it was mplus, essentially
21:25:02 <joelteon> SamB: those were the good old days
21:25:26 <joelteon> back then I'd have a bifunctor tied to my belt; it was the fashion at the time
21:25:58 <bb010g> "back before monomorphism came into vogue ..." Hmm?
21:26:14 <joelteon> back before everything in the prelude was monomorphic
21:26:50 <MP2E> ... So prelude used to be polymorphic and awesome and then we broke it to make it easier for newcomers? :(
21:26:58 <jle`> and map was Functor f => (a -> b) -> f a -> f b
21:26:58 <joelteon> yes
21:27:01 <MP2E> ouch
21:27:06 <MP2E> I didn't know that :V
21:27:22 <jle`> well...imagine it being your first day in haskell and using `map` wrong...and getting an error about Functor instead of an error about [] :)
21:27:37 <jle`> honestly i think it was a problem with error reporting, not a problem with polymorphism
21:27:46 <jle`> but then also :t was a bit less useful for new people
21:27:48 <jle`> :t map
21:27:49 <lambdabot> (a -> b) -> [a] -> [b]
21:27:49 <joelteon> I don't know about you, but I'm going to teach my children about typeclass polymorphism as soon as they can walk.
21:27:50 <jle`> :t fmap
21:27:51 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:28:01 <jle`> which one would you rather a new person see on day 1?
21:28:07 <SamB> joelteon: what does it have to do with walking?
21:28:15 <joelteon> SamB, it's just an arbitrary benchmark
21:28:23 <joelteon> maybe before they can walk.
21:28:25 <EvanR> day 1 should be the hindly milner type inference formulas
21:28:25 <joelteon> Never had kids.
21:28:26 <SamB> jle`: can't they just have a special tutorial-prelude for that?
21:28:43 <bb010g> SamB: I would like TutorialPrelude.
21:28:43 <EvanR> just in case ghc breaks down they can do it themselves
21:28:52 <prophile> I seem to recall that originally monad comprehensions were standard too
21:28:53 <joelteon> bb010g, this is an argument many people have had quite a few times
21:29:34 <MP2E> probably yeah
21:29:46 <EvanR> im glad <> exists now
21:29:56 <platz> typeclasses, sharing toys, or learning to swim - pick 2
21:30:00 <MP2E> I can see why it was changed. I dunno, I just wish there was a better way. I'm sure that's how everyone feels about it though
21:30:59 <EvanR> if you teach your kids haskell youll be guaranteeing they will be unable to learn C++
21:31:12 <joelteon> that would be a shame
21:31:13 <EvanR> though i guess c++ did that first
21:31:27 <platz> there was a similar argument about difficutly vs accomodating beginners with the String = [Char] recently
21:31:49 <platz> it's a tough dynamic to balance
21:32:02 <SamB> EvanR: that's not true actually
21:32:34 <platz> (i.e. vs String = Text)
21:33:29 <EvanR> its good how it is
21:34:14 <EvanR> i appreciate not having to explain the entire body of haskell implementation decisions at the very beginning of using the interpreter
21:39:03 <bb010g> What should I use for pointers & direct memory access?
21:39:21 <bb010g> (I know it's horribly unsafe, but a guy's asking if you could write a C compiler
21:39:22 <bb010g> )
21:39:34 <johnw> bb010g: you can always use the FFI to do whatever you'd do in C
21:39:50 <johnw> in fact, in that case, just write that part in C and link to it from Haskell
21:40:53 <jle`> bb010g: you can write a C compiler fine
21:41:38 <EvanR> heh C interpreter
21:41:42 <jle`> i think there are libraries for type safe and IO-semantics pointer and memory manipulation
21:41:46 <EvanR> which uses ffi for pointer stuff
21:41:47 <jle`> but
21:41:52 <jle`> i do'nt think you'd need it for a C compilter
21:41:56 <zwer> you don't need pointers or direct memory access to translate a text file (C source) into executable
21:42:01 <jle`> yeah, a C "interpreter" is a different story
21:42:13 <jle`> ...does C have a runtime?
21:42:21 <EvanR> yeah
21:42:22 <platz> bb010g: not c but getting there   http://www.stephendiehl.com/llvm/
21:42:36 <johnw> jle`: yes
21:42:39 <jle`> you might need some pointer stuff to write the C runtime, right?
21:42:40 <SamB> platz: honestly, that seems more relevant for a compiler
21:42:42 <johnw> heh, we had this exact discussion recently
21:43:08 <SamB> jle`: you remember all those library functions?
21:43:19 <EvanR> malloc
21:43:20 <jle`> SamB: from C?
21:43:24 <jle`> oh yeah
21:43:53 <jle`> is malloc really a part of the runtime though?
21:43:58 <SamB> plus you tend to need out-of-line routines for some math stuff
21:44:12 <EvanR> good luck writing malloc in C without the runtime ;)
21:44:16 <jle`> oh you need to keep track of free memory
21:44:19 <SamB> so, you've got your glibc and your libgcc ;-P
21:44:46 <johnw> malloc is based on the kernel call setbrk(); it knows how to divvy up the memory into the chunks you "allocate" in your program
21:45:06 <EvanR> static unsigned char ram[1>>31];)
21:45:20 <johnw> yay, BSS-heap :)
21:47:20 <SamB> EvanR: I think you got your >> mixed with << ;-P
21:47:32 <EvanR> i think it should be 30
21:48:20 <EvanR> i dont even remember if that is valid in the type annotation
21:49:13 <SamB> constant expressions are fine, though that probably will never work on a 32-bit system
21:49:42 <EvanR> haha
21:49:57 <EvanR> it runs on the abstract C machine
21:51:01 <SamB> well, I mean, you won't often be able to squeeze a whole contiguous gig into the address space, nevermind two!
21:51:47 <EvanR> i raise you a memory management unit!
21:52:15 <SamB> that was *with* an MMU
21:52:21 <prophile> MMU or no, there's often a 2GiB or 3GiB limit on addressable memory on 32-bit x86
21:52:42 <EvanR> my C code assumes 128 bit ints
21:53:03 <prophile> http://en.wikipedia.org/wiki/High_memory
21:53:14 <SamB> it could go as high as, say, 3.5GiB -- or even 4GiB if the kernel is actually 64-bit
21:54:54 <EvanR> i wonder what would happen if i tried that...
21:56:08 <EvanR> 1>>20 works ;)
21:56:28 <EvanR> 1>>30 works
21:56:31 <EvanR> lol
21:56:49 <EvanR> my program writes a number to ram[4] prints a message and exists
21:56:51 <EvanR> exits
21:57:38 <EvanR> on my 32bit machine with 1G ram
21:59:02 <willrandship> question: are there any features that haskell provides that are not available in other languages, say, C?
21:59:45 <EvanR> .oO( STM ...
21:59:45 <gamegoblin> willrandship: tons, too many to list
21:59:55 <willrandship> I've heard on so far, Lazy evaluation
21:59:59 <gamegoblin> willrandship:  Some off the top of my head: function currying, pattern matching, algebraic types, lazy evaluation
22:00:11 <willrandship> one*
22:00:19 <zwer> yeah comparing it to C sets a pretty low bar
22:00:28 <splintax> a type system
22:00:34 <EvanR> garbage collection
22:00:35 <willrandship> C has a type system....
22:00:44 <bb010g> splintax: C does have a type system, just not as complex
22:00:59 <gamegoblin> a *robust* type system might be more apt
22:01:05 <EvanR> a working type system
22:01:20 <willrandship> what does 'robust' mean in this context?
22:01:44 <MP2E> Well, C has strong typing which is supposed to stop you from mixing up apples and oranges... but oh wait you can still totally do that
22:01:49 <gamegoblin> willrandship: Type errors are easy to miss in C and the source of a lot of bugs
22:02:15 <splintax> the type system is robust because it's capable of describing a much larger subset of a program's intended behaviour than C's
22:02:16 <gamegoblin> willrandship: Consider this code to set the 50th bit of a 64 bit int in C:     myInt |= (1 << 50);
22:02:21 <gamegoblin> what’s the problem with that code?
22:02:22 <willrandship> ok
22:02:32 <gamegoblin> The compiler will compile it just fine
22:02:35 <willrandship> hmm
22:02:40 <willrandship> depends on what the types evaluate to
22:02:46 <splintax> type inference might also be considered to be a feature that makes the type system "robust"
22:02:47 <gamegoblin> Exactly
22:02:55 <willrandship> because if they default to (int) it will be fine if myInt isn't a long
22:02:59 <gamegoblin> In Haskell, you don’t have that ambiguity
22:03:02 <gamegoblin> myInt is 64 bits
22:03:11 <gamegoblin> We want to set the 50th bit
22:03:18 <willrandship> ah
22:03:35 <gamegoblin> But according to the C spec, 1 will become an int, and 1 << 50 will result in 0, rather than 2^50
22:03:35 <willrandship> solution is ofc to put (long) in front
22:03:41 <zwer> willrandship ignoring ghc extensions haskell program can't produce a runtime type error
22:03:44 <gamegoblin> yes exactly, but the compiler doesn’t force it
22:03:49 <gamegoblin> so you can introduce subtle bugs
22:03:57 <willrandship> *features
22:04:03 <gamegoblin> In Haskell, the type system is much more strict
22:04:13 <willrandship> ok but that's not really a feature in my eyes
22:04:14 <MP2E> yeah what zwer said is probably my favorite feature. It's very difficult to write code that doesn't just work. If it builds, it probably works
22:04:18 <MP2E> that means getting it to compile is harder of course
22:04:18 <willrandship> just a syntactical difference
22:04:20 <MP2E> but still :P
22:04:46 <willrandship> so here's a question
22:04:54 <willrandship> how would you access a memory-mapped device in haskell?
22:05:33 <splintax> probably using one of the packages that comes up when you google haskell mmap
22:05:35 <bb010g> But you stick algebraic data types over that, and GADTs, and type families, and you get a bunch of (admittedly synatical) power.
22:05:55 <willrandship> when I looked up memory mapping I found a bunch about memory mapped files
22:05:59 <willrandship> not what I was looking for
22:06:02 <bb010g> ?hackage mmap
22:06:03 <lambdabot> http://hackage.haskell.org/package/mmap
22:06:05 <EvanR> STM is a really far out feature not found in C or anything ive heard of
22:06:26 <bb010g> http://hackage.haskell.org/package/mmap-0.5.9/docs/System-IO-MMap.html
22:06:26 <platz> EvanR: Clojure has it
22:06:29 <EvanR> ah
22:06:36 <willrandship> not really sure what STM actually is
22:06:41 <bb010g> EvanR: Clojure, Perl 6 (thanks to Hugs)
22:06:41 <willrandship> I looked it up when you said it first
22:06:48 <Cale> willrandship: If you *really* want to do it, you do it in pretty much the same way as you do in C (apart from all the baseline differences in Haskell)
22:06:48 <EvanR> bb010g: wait what
22:06:57 <gamegoblin> willrandship: software transactional memory, really powerful thread safety
22:07:13 <willrandship> Cale, so you're saying I could say "go to 0x1000 and write these bytes"
22:07:17 <Cale> Sure
22:07:18 <splintax> solve memory concurrency problems the same way everyone currently solves database concurrency problems (transactions)
22:07:22 <bb010g> EvanR: What about what?
22:07:31 <Cale> There's Foreign.Ptr which has a bunch of stuff related to that
22:07:32 <willrandship> but that causes side effects, right?
22:07:34 <EvanR> bb010g: what does perl6 and hugs have to do with each other
22:07:40 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html
22:07:41 <Cale> yes
22:07:43 <willrandship> so it's discouraged
22:07:48 <bb010g> EvanR: Sorry, s/Hugs/Pugs
22:07:49 <Cale> You describe effects using IO actions
22:07:51 <EvanR> haha
22:08:04 <Cale> So, you can't do this as part of the evaluation of an expression, only the execution of an IO action
22:08:35 <willrandship> but you could use foreign pointers inside functions, right?
22:08:38 <Cale> (well, "can't", there are low-level hooks for that if you really know what you're doing, but you wouldn't tend to need or want them in normal everyday programming)
22:08:48 <willrandship> ok
22:08:56 <willrandship> that's what I was looking for really
22:09:00 <EvanR> :t poke
22:09:00 <willrandship> it can do it
22:09:00 <lambdabot> Not in scope: ‘poke’
22:09:05 <willrandship> it's just discouraged
22:09:11 <splintax> and awkward
22:09:12 <Cale> The evaluation of a function application doesn't cause effects
22:09:16 <bb010g> Would you be able to use Foreign pointers in ST?
22:09:37 <Cale> (unless you make use of unsafe primitives which cause you to need to be really careful about how things get compiled)
22:09:44 <bb010g> (Probably not, as you can grab from outside)
22:09:58 <EvanR> :t grab
22:09:59 <lambdabot> Not in scope: ‘grab’
22:09:59 <bb010g> (And the other uses could be replaced with IORefs)
22:10:02 <willrandship> Cale unsafe primitives would basically be like using pointers in C, right?
22:10:06 <bb010g> @hackage grab
22:10:06 <lambdabot> http://hackage.haskell.org/package/grab
22:10:11 <bb010g> @hoogle grab
22:10:12 <lambdabot> package statgrab
22:10:53 <Cale> willrandship: I would consider using unsafePerformIO (which is what I'm talking about) as a sort of last-ditch effort before I modify my compiler to make it do something new in the course of evalution.
22:10:56 <Cale> evaluation*
22:11:05 <willrandship> definitely
22:11:26 <EvanR> the ffi operations are what youd use to do pointer stuff like in C
22:11:35 <EvanR> not unsafePerformIO
22:11:39 <Cale> It's useful for adding new primitive datastructures, (ByteString uses it a bit), but it's not something you use every day.
22:11:41 <bb010g> But it breaks referential transparency, so it's pretty well discouraged
22:11:47 <willrandship> well that's a much more sane response than I was expecting, considering the goal of a "pure" language
22:12:09 <Cale> willrandship: In C, you're pretty much forced to use pointers to do anything meaningful
22:12:10 <willrandship> allowed but discouraged is much better than just saying "don't do that"
22:12:13 <Cale> so this is pretty different than that
22:12:19 <willrandship> Cale, yes, but they're very powerful
22:12:26 <Cale> this is like, you could program every day for 10 years without ever really needing it
22:12:45 <willrandship> because you use abstractions that use pointers or pointer-like constructs internally
22:13:02 <johnw> I come from a heavy C/C++ background; in 2 years of Haskell coding, I've reached for pointers zero times
22:13:08 <platz> don't forget MonadRandom
22:13:14 <johnw> it's just a different way of programming
22:13:14 <EvanR> even in Java you do not mess with pointers
22:13:29 <johnw> well, in Java everything is effectively like a pointer
22:13:30 <willrandship> that's not how I remember it
22:13:34 <johnw> not a REAL pointer, mind you
22:13:36 <Cale> I've used unsafeCoerce (safely) more often than I've used unsafePerformIO.
22:13:41 <gamegoblin> pointer vs. reference
22:13:43 <zwer> the only time I used pointers in haskell is when interfacing C functions
22:13:50 <willrandship> well Java is an example of a less sane language, like I was saying before
22:13:50 <johnw> whenever I use unsafePerformIO, I smack my own hands
22:14:09 <willrandship> "don't do that. do this more limited version of it instead"
22:14:15 <lithiumdeuteride> how does one pattern-match a sequence of characters (of unspecified length) in the middle of a [Char]?
22:14:18 <willrandship> and there's no other option
22:14:24 <willrandship> well thanks! you answered my question
22:14:28 <Cale> unsafeCoerce :: a -> b is a way to tell the type system "please just trust me, I take full responsibility for the random code execution which will ensue if a and b are not the same type"
22:14:30 <gamegoblin> lithiumdeuteride: you don't
22:14:33 <carter> unsafePerformIO, is pretty safe
22:14:35 <carter> as things go
22:14:42 <carter> Cale: its also fun :)
22:14:46 <EvanR> lithiumdeuteride: with parser combinators
22:14:48 <carter> great way to get heap pointers
22:15:03 <gamegoblin> lithiumdeuteride: you can do something like myFunction (_:_:_:’h’:’i’:_:_:_) = “hi”
22:15:04 <Cale> It depends on your definition of safety
22:15:10 <gamegoblin> lithiumdeuteride: but you can’t do it on arbitrary values
22:15:11 <Cale> unsafePerformIO is really hard to reason about
22:15:16 <lithiumdeuteride> hmm
22:15:17 <gamegoblin> lithiumdeuteride: at least not in the pattern match
22:15:21 <gamegoblin> lithiumdeuteride: use a parser
22:15:28 <Cale> and you pretty much ought to be looking at the generated code to make sure that it's what you expect
22:15:36 <bb010g> Example of reasoning: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
22:15:58 <bb010g> Stuff like that is what can make Haskell great compared to C.
22:15:58 <Cale> Optimisations that the compiler makes can affect the behaviour of code which uses unsafePerformIO
22:16:01 <carter> Cale: you mean core :)
22:16:03 <carter> yeah
22:16:05 <Cale> yes
22:16:08 <carter> some suprise sharing for everyone :)
22:16:20 <carter> sharing when you mutable don't expect it can make for FUN bugs
22:16:24 <carter> and pretty patterns
22:16:39 * hackagebot egison 3.3.8 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.8 (SatoshiEgi)
22:16:43 <lithiumdeuteride> i'm assuming the parser just scans through the [Char] and returns a Bool if the substring was found or not
22:17:01 <gamegoblin> lithiumdeuteride: what exactly are you trying to do?
22:17:15 <lithiumdeuteride> imaging a file-renaming operation, executing a 'replace' command
22:17:16 <bb010g> lithiumdeuteride: It deconstructs the list and matches on specific Char values.
22:17:17 <Cale> It's safe enough to play around with for the most part of course, but there are very few real excuses to put unsafePerformIO into production code.
22:17:28 <EvanR> lithiumdeuteride: if its a substring match, then theres a better way, using a substring search
22:17:40 <EvanR> if its a replacement, thats yet another thing
22:18:10 <Cale> One thing that unsafePerformIO *can* do is expose things about evaluation so that you have a better idea of how bad your model of what order things are getting evaluated in is :)
22:18:14 <platz> I think folks are forced to learn about unsafePerformIO because of randomRIO . doing random stuff is very common when building small exercises
22:18:31 <Cale> platz: It's easier just to learn to do randomness correctly
22:18:49 <Cale> In one of the many ways of making that happen :)
22:18:51 <lithiumdeuteride> replaceString :: [Char] -> [Char] -> [Char] -> [Char]
22:18:54 <platz> Cale: I don't disagree
22:18:56 <lithiumdeuteride> something like that
22:19:03 <Cale> Either using StdGens and split or just writing things in IO
22:19:16 <lithiumdeuteride> a string, a substring to find, a string to replace it with, and the result
22:19:18 <EvanR> getting random numbers on demand is an instant gratification thing when people use dynamic languages and feel better
22:19:42 <Cale> Or using some other representation for random distributions (there are good monad instances for these)
22:19:54 <EvanR> randomRIO works for this in haskell, as long as its IO
22:20:38 <Cale> If you think about it hard enough though, it's actually quite a good thing not to be able to obtain random numbers anywhere. It makes tests much more reliable.
22:20:44 <EvanR> lithiumdeuteride: http://hackage.haskell.org/package/MissingH-1.0.0/docs/Data-String-Utils.html
22:20:50 <EvanR> see replace
22:21:32 <EvanR> this will work for short strings like filenames but you should use the Text version for large blobs of text
22:22:14 <platz> yeah LYAH teaches using getStdGen
22:23:45 <platz> so I blame haskellwiki then
22:24:50 <gamegoblin> So here’s my problem. I am trying to make data types for various CSS property values. For example, DisplayValue = Inline | None | Block … . The problem is that some constructors (notably None) would have to be in several different types. What are my options for overcoming this?
22:26:04 <EvanR> you can use a different None for each one
22:26:14 <dmj`> gamegoblin: you could make a standalone newtype to represent None
22:26:19 <trap_exit> Core/SIO.hs:8:10: Warning:     ‘SIO’ is an instance of Monad but not Applicative - this will become an error in GHC 7.10, under the Applicative-Monad Proposal.
22:26:23 <trap_exit> how do I get rid of this error
22:26:28 <trap_exit> s/error/warning
22:27:07 <gamegoblin> But what would my type for the actualy CSS property be then? So I’d like it to look like:  data Rule = Display DisplayType | Color ColorType | etc
22:28:05 <EvanR> wonder what the benefit / risk of using the same None in all css rules is
22:28:52 <Cale> gamegoblin: Change the name to DisplayNone or something?
22:30:38 <trap_exit> Core/SIO.hs:8:10: Warning:     ‘SIO’ is an instance of Monad but not Applicative - this will become an error in GHC 7.10, under the Applicative-Monad Proposal.
22:30:41 <trap_exit> hwo do I kill this warning
22:31:06 <Cale> trap_exit: instance Applicative SIO where pure = return; (<*>) = ap
22:31:23 <EvanR> gamegoblin: i see where you are going with this, you dont want to be allowed to represent invalid css. but is that a safe bet, since for example chromes debugger will allow you to put in invalid css, just mark it red and ignore it. your structure wouldnt be able to be used for that
22:31:33 <Cale> trap_exit: Or otherwise implement a reasonable Applicative instance for it
22:31:58 <gamegoblin> If I make multiple None’s in each type, it’ll say Multiple declarations of None
22:31:58 <gamegoblin> and won’t compile
22:31:59 <gamegoblin> I could make a giant type of all of the possible values, but then you’d be able to do stuff like: Color InlineBlock. That is, mix and match properties and values that don’t go together.
22:32:00 <carter> trap_exit: sounds like a GHCJS thing?
22:32:09 <EvanR> gamegoblin: another way is to make a data type to represent every kind of css attribute, and a rule just groups them, even if they make no sense
22:32:22 <splintax> gamegoblin: hmm, could http://www.haskell.org/haskellwiki/Scoped_type_variables help?
22:32:24 <EvanR> in this way thered be only one none
22:32:28 <trap_exit> carter: ah, perhaps -- I thought it was ghc 7.8.3, but you're probably riht that hts' a ghcs thing
22:33:04 <Cale> gamegoblin: I meant having something like data DisplayValue = DisplayInline | DisplayNone | DisplayBlock | ...
22:33:20 <Cale> gamegoblin: and then similarly for other types, just add a prefix which makes the names unique
22:33:34 <Cale> so then it's obvious which type ought to be inferred for the constructors
22:34:04 <Cale> You could go off and make a type class for all the types which have a "none", but I'm not sure that's particularly meaningful.
22:34:05 <lithiumdeuteride> thanks for the link, EvanR - i will check out this module
22:34:05 <gamegoblin> splintax: I don’t see how :(
22:34:06 <splintax> use a different None for each type without getting the multiple declarations problem
22:34:06 <gamegoblin> example?
22:34:08 <trap_exit> Cale: where do I get ap from ?
22:34:16 <Cale> trap_exit: Control.Monad
22:34:32 <gamegoblin> Cale: I could definitely do that, but that’s super tedious to type T_T
22:35:08 <gamegoblin> I am beginning to think it’s the only way though
22:35:11 <Cale> trap_exit: Or you could write mf <*> mx = do f <- mf; x <- mx; return (f x)
22:35:29 <trap_exit> Cale: I pulled from Control.Monad; I think now, I need to do instance Functor ... also
22:35:30 <trap_exit> brb
22:35:47 <Cale> trap_exit: yeah, you can do that with  instance Functor SIO where fmap = liftM
22:36:24 <EvanR> gamegoblin: i dont think your second idea of having the type describe css tokens, or rule tokens and property tokens is bad. it sacrifices strict representation for ease of modeling
22:36:45 <trap_exit> Cale: compiler now happy; thanks!
22:37:05 <EvanR> but it does allow representing literally nonsense css files which exists all over the place
22:37:14 <EvanR> a renderer will just ignore it
22:37:26 <gamegoblin> EvanR: My goal is to enforce correct CSS at compile time ;)
22:37:35 <EvanR> a validator could validate it (without parsing)
22:37:43 <Cale> You could use phantom types
22:38:01 <gamegoblin> Cale: I don’t think phantom types solve the problem of constructors with the same name
22:38:17 <EvanR> constructors with the same name is a namespace issue, use qualified imports
22:38:47 <gamegoblin> EvanR: I’d literally have to make a new file for every css property, no thanks
22:38:51 <bb010g> Just when I think I know what I'm doing, BAM, category theory.
22:38:59 <EvanR> makes sense to me
22:39:01 <Cale> gamegoblin: They *kind of* do, in that it's easier to make a type class for valid instantiations of that type parameter
22:39:22 <gamegoblin> EvanR: and with qualified imports, I might as well use the DisplayNone rather than Display.None or even D.None
22:39:23 <EvanR> gamegoblin: at this rate youll have thousand line file
22:39:48 <EvanR> gamegoblin: i see a lot of people go that way but then you dont have the option to drop the namespace when you want to
22:40:17 <Cale> I just hate the appearance of module qualifying dots
22:40:29 <EvanR> Display'None is another prefix way
22:40:37 <bb010g> gamegoblin: Maybe DisplayValue?
22:40:40 <gamegoblin> I think I am going to go with my second option. Make one type of CSS properties and another of CSS values. My main motivation is avoiding CSS errors due to typos, so that accomplishes taht at least
22:40:45 <gamegoblin> that*
22:41:19 <bb010g> What are the common values?
22:41:19 <bb010g> You mentioned None
22:41:29 <EvanR> Pixels Int
22:41:35 <EvanR> colors
22:41:41 <EvanR> Auto
22:41:43 <EvanR> etc
22:42:08 <bb010g> Just put them in a data CSS a = None | Auto | Whatever a | ...
22:42:25 <bb010g> Then CSS DisplayValue
22:42:53 <EvanR> yurg
22:42:55 <bb010g> And you can just catch the fallthroughs in verification functions
22:45:29 <EvanR> a type for properties, Width | Display | Color, a type for values Red, Pixels 2.34, Auto ...
22:46:17 <gamegoblin> EvanR: That’s what I’m doing. So you’ll be able to do Color InlineBlock but… dgaf
22:46:32 <EvanR> yeah but you wouldnt write that ;)
22:46:32 <bb010g> What's the advantage of Free & a type vs a recursive type? I know do notation, but is there anything else?
22:46:36 <gamegoblin> This is a hard problem in any language. Same issue with enums in other langauges.
22:49:31 <EvanR> yeah this kind of "issue" seems to crop up, where its nice and easy but theres a nagging "but i might mess up" feeling
22:50:23 <EvanR> in this case though messing up probably means an ignored css property, not a segfault
22:50:35 <bb010g> You could try autogenerating with TH from external docs, but that may become icky.
22:54:26 <bsrk> I have an algebraic data type that is generated using template haskell,
22:54:37 <bsrk> can I see it's constuctors manually?
22:56:45 <arancia> bsrk: You cann pass -ddump-splices to GHC to see the generated code
22:57:43 <bsrk> arancia: thanks! I will try it now
23:02:27 <augur> when someone finds a solution to cabal hell
23:02:35 <augur> can we please call the thing
23:02:37 <augur> cabal jesus?
23:02:52 <joelteon> it's called nix already
23:03:19 <augur> ???
23:07:02 <dmj`> augur: http://www.bioinf.uni-leipzig.de/conference-registration/13haskell/submissions/hal8_submission_15.pdf
23:07:58 <augur> what an awful name
23:08:52 <Cale> cabal atheism
23:09:11 <zq> hm
23:09:21 <zq> any hindley milner people around?
23:09:30 <augur> "There's no Cabal Hell, so stop worrying!" - Cabal Richard Dawkins
23:09:37 <augur> zq: we're all HM people here
23:09:42 * augur zombie stare
23:09:45 <bb010g> augur: http://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html & http://fuuzetsu.co.uk/blog/posts/2014-06-28-My-experience-with-NixOS.html
23:10:17 <zq> augur: hm the theory, not as a user of the type system
23:10:21 <Cale> Is either J. Roger Hindley or Robin Milner here?
23:10:21 <augur> yes
23:10:26 <zq> arf
23:10:29 <augur> fra
23:10:33 <zq> so i just realized
23:10:53 <zq> that algorithm w implicitly requires that the top level expression be a let
23:10:57 <zq> a let-in
23:11:02 <zq> what is going on here
23:11:11 <augur> in what sense
23:11:15 <zq> algo w isn't consistent with h-m's rules
23:11:15 <Cale> Robin Milner would have a hard time being on IRC, given that he died :(
23:11:49 <zq> or maybe it's not complete, whichever of those two means w places a restriction on h0m
23:11:52 <zq> h-m*
23:11:59 <augur> what do you mean
23:12:09 <zq> 08:08:48 < zq> that algorithm w implicitly requires that the top level expression be a let
23:12:12 <zq> that's what i mean
23:12:15 <augur> yes
23:12:18 <augur> but what does THAT mean
23:12:54 <Cale> zq: I was under the impression that Algorithm M and W were both directly derived in an obvious ways from the rules of H-M, and the difference between them was pretty much the order in which constraints were discovered and solved.
23:13:02 <zq> Cale: no
23:13:28 <zq> Cale: by merging inst/spec and gen with var and let, there's a restriction placed on what the top level expression could be
23:13:41 <zq> Cale: for instance, you wouldn't be able to type \x y -> x
23:13:44 <Cale> I suppose it's been a while since I looked at this stuff
23:14:05 <zq> wait there's an algorithm m?
23:14:16 <Cale> Yeah, it's top-down vs. bottom-up
23:15:34 <zq> Cale: would you happen to have a link?
23:15:38 <zq> that isn't paywalled
23:16:43 <Cale> Googling gets me http://gergo.erdi.hu/projects/tandoori/Tandoori-Compositional-Typeclass.pdf which seems to contain a sketch of both algorithms
23:17:52 <Cale> http://gergo.erdi.hu/projects/tandoori/Tandoori-Compositional-Typeclass.pdf
23:17:53 <Cale> oops
23:17:57 <Cale> http://www.cs.mu.oz.au/~sulzmann/publications/flops01.ps.gz
23:18:16 <augur> mm tandoori
23:18:25 <augur> i should get some tandoori chicken tomorrow
23:20:18 <zq> Cale: thank you
23:20:53 <gamegoblin> Is there a more efficient way of getting a bytestring representation of a number than (pack . show) ?
23:21:07 <Cale> zq: In some cases, I can imagine someone making the assumption that the program as a whole is a giant let-expression
23:21:57 <Cale> gamegoblin: Well, there are things which write the number in binary
23:22:18 <gamegoblin> Cale: need a char8 rep =/
23:22:22 <Cale> Which is more likely what you want if you're using ByteString and not Text
23:23:28 <Cale> zq: http://www.grabmueller.de/martin/www/pub/AlgorithmW.pdf looks useful
23:24:04 <Cale> gamegoblin: I'd just use pack . show then
23:25:22 <gamegoblin> I wish overloaded strings could turn chars into word8s
23:25:34 <Cale> That's kinda evil
23:26:01 <gamegoblin> doing cons 35 myByteString is so much uglier than cons ‘#’ myByteString
23:26:02 <Cale> y u no UTF-8?
23:26:26 <gamegoblin> I always have to comment in the various ascii values
23:26:29 <Cale> Use Text instead, it's nicer :)
23:26:36 <gamegoblin> Attoparsec
23:26:55 * hackagebot lens 4.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.3 (EdwardKmett)
23:26:58 <Cale> Or use Data.ByteString.Char8.cons instead, if you must
23:27:10 <Cale> :t Data.ByteString.Char8.cons
23:27:11 <lambdabot> Char -> BSC.ByteString -> BSC.ByteString
23:27:16 <Cale> :t Data.ByteString.cons
23:27:17 <lambdabot> Word8 -> BSC.ByteString -> BSC.ByteString
23:27:19 <gamegoblin> I think the word8 cons is faster
23:27:25 <zq> Cale: now i feel stupid for spending the weekend implementing h-m in haskell :\
23:27:39 <Cale> zq: You probably learned something
23:28:14 <gamegoblin> zq: I have spent the last 6 months implementing an http server, parser library, database, and web framework in haskell, even though they all already exist. Just wanted to learn how it’s all done.
23:28:24 <edwardk> gamegoblin: its a good way to learn
23:28:44 <zq> great way to learn the language, sure
23:28:58 <zq> but i know the language already and was really aiming for novelty
23:29:46 <zq> whatevs
23:29:53 <zq> i'll add row polymorphism to this or something
23:30:55 <Cale> zq: You may or may not be on the way to implementing Ermine ;)
23:32:43 <zq> wow look at me rediscovering edkmett's ideas
23:32:51 <bb010g> How do I get a value out of a Bi (from Data.Semifunctor)?
23:33:00 <zq> why do i even bother thinking, i should just ask cale
23:35:06 <edwardk> bb010g: pattern match on it =)
23:36:04 <codygman> I have a list of Elements who I would like to build a list of key value pairs out of. I'm thinking I should use a fold but I don't know how to create an empty tuple.
23:36:48 <Maxdamantus> > ()
23:36:49 <lambdabot>  ()
23:37:34 <bb010g> codygman: You could use foldl1 or ensure that the contents are Monoid and use (mempty, mempty)
23:38:50 <dmj`> anyone care to do a code review? Wrote a simple thread supervision library based on async today. The code is short
23:38:54 <codygman> Maxdamantus: This for example won't work: foldl (\x -> (1,1)) () [1..4]
23:39:04 <codygman> bb010g: I'm not sure how you mean
23:39:35 <bb010g> codygman: Give your goal input and output
23:39:38 * waynr imagines how awesome libreoffice would be if it were written in haskell
23:40:08 <hc> libr tex als office ;p
23:40:09 * dv- would rather have a web browsr
23:40:23 <mayski> more like... lambdaoffice?
23:40:24 <mayski> ;)
23:40:39 <hc> haha, lambdaoffice :)
23:42:26 <Krenium> codygman: so you want to turn [1,2,3,4] into [(1,2),(3,4)] or?
23:43:01 <waynr> i like the sound of that, "lambdaoffice"
23:43:35 <codygman> Krenium: Well Yes I think
23:43:43 <waynr> one could probably write a haskell plugin system for libreoffice
23:44:45 <dv-> > let pairup [] = []; pairup (x:y:xs) = (x,y):pairup xs in pairup [1,2,3,4]
23:44:46 <lambdabot>  [(1,2),(3,4)]
23:44:49 <waynr> as long as the libreoffice api isn't so broken that for example the low-level call that applies styles doesn't actually modify the size of objects
23:44:51 <codygman> Krenium: I actually have a [Cursor] and want [("key", "value"] of the attributes for each element.
23:46:48 <codygman> I guess I need to map the [Cursor] asking for the attribute and value at the same time, but I'm not sure how.
23:46:56 <Krenium> zip [1,2,3] ['a','b','c']
23:51:24 <prophile> is there a rem-esque function that gives 2 for -1 `f` 3?
23:53:58 <opqdonut> prophile: mod
23:54:13 <prophile> > -1 `mod` 3
23:54:14 <opqdonut> > -1 `mod` 3
23:54:15 <lambdabot>  -1
23:54:16 <lambdabot>  -1
23:54:29 <opqdonut> ah
23:54:39 <opqdonut> > (-1) `mod` 3
23:54:41 <lambdabot>  2
23:54:46 <prophile> aha!
23:54:54 <opqdonut> recall that `operators` have the highest precedence
23:55:07 <prophile> rookie error
23:55:07 <prophile> thanks
23:55:48 <ion> > let a `f` b = 42; infix 0 `f` in 2 `f` 3 + 4
23:55:49 <lambdabot>  42
