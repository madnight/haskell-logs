00:00:11 <jle`> sometimes i imagine a dialog where i tell someone 'implement this same sorting algorithm in haskell', and then point out that they are missing like twenty lines of run-time type checks
00:00:16 <jle`> to guaruntee the same safety
00:01:18 <jle`> but foldMap is a good example i think
00:01:28 <gfixler> I'm still impressed by little things I learned recently, like how pattern matching happens against constructors
00:01:31 <orion> In the course of writing a large haskell application, is it ever beneficial to design and write out the type structure first, and leave all the functions undefined? Or is that a waste of time?
00:01:44 <jle`> orion: that's actually how a lot of people do it :)
00:01:47 <jle`> orion: i'd almost say "most"
00:01:56 <orion> I see.
00:01:57 <gfixler> it made me think "When the heck does this thing actually become a thing? Why is the constructor still hanging around?"
00:01:57 <jle`> we call it "hole-based development"
00:02:43 <jle`> orion: a lot of times, you'll only have one possible implementation of a function of a certain type
00:02:54 <jle`> orion: so you can almost completely specify your entire program with types alone
00:03:01 <jle`> and build off of that
00:03:21 <gfixler> jle`: example?
00:03:49 <aarvar> if you make your types generic it reduces the number of possible implementations
00:03:51 <Adeon> id
00:04:12 <jle`> (a -> b) -> (a -> c) -> a -> (b, c)
00:04:18 <aarvar> there's only one way to implement a function of type a -> a, ignoring undefined
00:05:21 <tac> @type string
00:05:22 <lambdabot>     Not in scope: ‘string’
00:05:22 <lambdabot>     Perhaps you meant one of these:
00:05:22 <lambdabot>       ‘storing’ (imported from Control.Lens),
00:05:24 <jle`> @djinn (a -> b) -> (a -> c) -> a -> (b, c)
00:05:25 <lambdabot> f a b c = (a c, b c)
00:05:32 <stalintrotsky> @type String
00:05:33 <lambdabot> Not in scope: data constructor ‘String’
00:05:43 <stalintrotsky> @kind String
00:05:44 <lambdabot> *
00:06:08 <trap_exit> https://gist.github.com/anonymous/12e7d7c929fdf995879b <-- can I make this any more strict?
00:06:19 <scriptdevil> jle`: I was about to ask for exactly that type. Isn't there a predefined function that does it, though?
00:06:23 <zwer> orion another often used approach I like is this: todo = error "Not defined yet". someFunc = todo; and then later you can delete todo definition to get compile error for all the functions that weren't defined
00:06:48 <orion> zwer: I see.
00:06:52 <jle`> scriptdevil: there's a function that's a bit overly generic/polymorphic that does that, (&&&)
00:07:09 <jle`> one day i hope for there to be a less polymorphic one in base or prelude somewhere
00:07:13 <orion> < aarvar> there's only one way to implement a function of type a -> a, ignoring undefined <-- what about x = x + 1; x = x + 2; ... ?
00:07:22 <orion> Don't those two have type a -> a?
00:07:34 <zwer> no, + has a Num constraint
00:07:39 <zwer> :t (+)
00:07:40 <lambdabot> Num a => a -> a -> a
00:07:40 <jle`> orion: try it :)
00:07:41 <aarvar> exactly
00:07:45 <jle`> see what ghc tells you :)
00:07:52 <jle`> > let f :: a -> a; f x = x + 1
00:07:53 <lambdabot>  not an expression: ‘let f :: a -> a; f x = x + 1’
00:07:54 <aarvar> you know nothing about a, because its entirely generic with no constraints
00:08:06 <jle`> :t let f :: a -> a; f x = x + 1 in f
00:08:07 <lambdabot>     No instance for (Num a1) arising from a use of ‘+’
00:08:07 <lambdabot>     Possible fix:
00:08:07 <lambdabot>       add (Num a1) to the context of
00:08:22 <orion> So, a Great Haskeller will always make his functions as generic as possible.
00:08:23 <jle`> a type signature like (a -> a) means "this has to work for *ANY* a you give me"
00:08:35 <jle`> orion: what if i run your function on a String?
00:09:10 <aarvar> just define a Num String instance
00:09:29 <jle`> orion: generic functions let you leverage the power of parametricity
00:09:43 <jle`> so why give up power? :)
00:09:59 <scriptdevil> jle`: fanout is a nice name for that function... I got it from Control.Arrow's docs
00:10:36 <tac> Generic as possible is often maximally difficult to understand
00:10:49 <tac> There's an art to choosing the right level of genericness to your program
00:10:59 <jle`> i'll concede that
00:11:29 <tac> Something like lens is certainly a bit overgeneralized. Many libraries which give you IO exports are certainly undergeneralized.
00:11:35 <pjdelport> On the other hand, more generic can also be easier and simpler, by focusing exactly the interesting parts of a problem without any extraneous details.
00:11:45 <edwardk> tastes vary =P
00:11:45 <jle`> pjdelport: so it's a balance :)
00:12:01 <jle`> find the level of genericness that captures the essence of what you are trying to say.
00:12:04 <pjdelport> (If a generic version isn't easy to understand, it might be a sign that it's the wrong kind of genericness.)
00:12:15 <pjdelport> (Because "generic" isn't just a linear scale.)
00:12:17 <aarvar> or just that you dont understand it
00:12:26 <jle`> :P
00:12:28 <aarvar> there's really no good rule for this
00:12:30 <tac> edwardk: I think my server has spent more time compiling lens than running the app that depends on it :P
00:12:41 <edwardk> tac: time to move to nix
00:13:01 <tac> nix?
00:13:12 <tac> what's that?
00:13:34 <jle`> i have hopes for mitigating the tradeoffs of genericness with some tweaks to how types are reported, and error messages
00:14:24 <aarvar> Haskell should allow optional weak typing
00:14:51 <aarvar> then beginners can just let their program crash rather than try to interpret the error message
00:14:51 <jle`> what does weak typing mean in this sense?
00:14:53 <mkrtem> tac: it is a package manager on steroids
00:15:11 <tac> aarvar: You can deferr error messages to runtime
00:15:12 <jle`> i don't think that the crash would be any easier to debug than an error message
00:15:12 <aarvar> allow a program to compile even if it doesnt type check
00:15:15 <tac> there's a flag for that
00:15:24 <aarvar> oh, cool
00:15:31 <int3__> aarvar: fdefer-type-errors
00:15:36 <trap_exit> https://gist.github.com/anonymous/12e7d7c929fdf995879b <-- can I make this any more strict?
00:15:39 <jle`> many type errors usually are things that don't even make sense to compile
00:15:43 <tac> Technical issues aside, generic things are hard to understand until you have a good library of examples to draw from.
00:15:53 <aarvar> obviously it wouldnt apply to all type errors
00:16:10 <tac> which is why we teach algebra of the reals before introducing the more general notion of fields
00:16:42 <aarvar> It's certainly easier to start from a concrete example in most cases
00:17:20 <Cale> trap_exit: yes, you could put a ! before the StrictMap
00:17:33 <tac> of course, generalization can make it much easier to retain and reason about things.
00:17:49 <trap_exit> Cale: nice, thanks!
00:18:02 <tac> but that's basically my thoughts on why monads are so terrible to teach
00:18:10 <Cale> Whether that's a good idea is another thing :)
00:18:21 <tac> It's like trying to teach someone what a field is up front. What they really want is a number.
00:18:28 <trap_exit> Cale: actually, I can put the ! before k and v too
00:18:36 <Cale> no, that's syntactically invalid
00:18:37 <trap_exit> Cale: so I can do "store_data :: !StrictMap !k !v" ... no ?
00:18:51 <tac> after they have real numbers down, you can introduce complex numbers, and then unify the two with the general notion
00:18:55 <Cale> The ! is actually not part of the syntax of types
00:19:01 <Cale> It's part of the syntax of data declarations
00:19:35 <trap_exit> hmm, I can not, I got a compile error
00:19:48 <Cale> It means that occurrences of the data constructor in expressions will be replaced by a version which involves some seqs
00:20:56 <pjdelport> tac: That's why Functor and Applicative should be taught before Monad :)
00:21:45 <aarvar> Maybe we should quit referring to IO as the IO monad
00:22:06 <tac> pjdelport: I'd say so
00:22:14 <tac> although, having IO up front is nice
00:22:27 <tac> for the wee lambdalytes
00:22:41 <Cale> trap_exit: http://www.haskell.org/onlinereport/decls.html#strictness-flags
00:22:53 <bitemyapp> pjdelport: def teach functor and applicative before monad.
00:22:57 <trap_exit> Cale: thanks
00:23:24 <tac> aarvar: I like it when authors introduce IO a as "IO actions that result in a"
00:23:33 <pjdelport> aarvar: Definitely. I always say "IO action", and sometimes "functorial / monadic interface to IO" if the interfaces specifically are at question.
00:23:35 <tac> actions are tangible and intuitive
00:23:57 <aarvar> I agree
00:24:09 <tac> then, the only rule is you can't choose to run any action you want... only main gets run, and whatever main is defined in terms of, those get run
00:24:10 <Cale> I'm not sure I agree about Applicative
00:24:26 <tac> Monoidal is the better pedagogical option ;p
00:24:28 <Cale> Applicative is probably harder to understand than Monad, and fewer libraries really require its use.
00:24:32 <pjdelport> (I'm also thinking these days that it's a good idea to refer to monads as "monadic functors", rather.)
00:24:33 <aarvar> Just teach functor first
00:25:28 <pjdelport> Cale: I think that varies; certainly myself, and the majority of people I've tried to explain it to seem to grok Functor and Applicative easier than Monad.
00:25:42 <Cale> Applicative also is more general than monad in a way which makes expressing what (<*>) means in a computational way even harder.
00:25:46 <glguy_> The "algorithmic heights" and "bioinformatics stronghold" problem sets on Rosalind.info seem very nice and with recommending to people looking for that sort of thing as they're learing Haskell. Is certainly recommend it over Euler for this purpose. The site isn't language specific
00:25:50 <Cale> You can make vague statements about types
00:25:50 <trap_exit> where do I add "(Ord k) =>" to make https://gist.github.com/anonymous/6157bdefd6029cea8db3 compile ?
00:26:07 <Cale> But it's hard to really say something meaningful about what's happening to the values, because of the generality.
00:26:27 <mr-> pjdelport: calling them monadic functor would be an unfortunate clash with notation in mathematics, I think.
00:26:39 <Cale> Yes, it does.
00:26:41 <gfixler> I like johnw's writeup, at least for the 1000-yard view; it's the simplest I've seen so far: https://web.archive.org/web/20120822135719/http://newartisans.com/2012/08/monads-in-pictures/
00:26:51 <glguy_> Trap, none of those lines
00:27:03 <Cale> trap_exit: you don't?
00:27:08 <gfixler> web.archive.org link, because the original doesn't have the pictures anymore
00:27:16 <glguy_> Put it on the function that needed it
00:27:22 <Cale> trap_exit: You add it to the types of things which construct or deconstruct values of this type
00:27:26 <pjdelport> mr-: Arguably not any more than the existing clash of Haskell calling them Functor and Monad, surely?
00:27:37 <pjdelport> mr-: Or are you referring to something more nuanced?
00:27:46 <Cale> trap_exit: (specifically, when they have to do operations on the map)
00:27:49 <trap_exit> Cale: right, I just realized that
00:27:51 <trap_exit> Cale: thanks :-)
00:27:55 <mr-> pjdelport: no, because they are functors and they are monads (in the mathematical sense), but a monadic functor is something else mathematically
00:28:25 <Cale> pjdelport: A functor is monadic if it's equivalent to the forgetful functor from a category of algebras over a monad.
00:28:40 <Cale> i.e. it's part of a monadic adjunction
00:29:37 <Cale> There's a theorem, called Beck's monadicity theorem, which characterises such functors precisely
00:29:45 <Cale> http://ncatlab.org/nlab/show/monadicity+theorem
00:29:48 <mr-> (I agree that it is an unfortunate name, but now we have it..)
00:36:34 <jle`> @src Const
00:36:34 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:36:45 <jle`> :t Const
00:36:47 <lambdabot> a -> Const a b
00:37:07 <Cale> I guess part of the reason there isn't a distinction is that classically, there's no difference between a functor T equipped with an eta and mu (return and join) that turn it into a monad, and a functor T which could be so equipped. There's no way at the formal level to say that eta and mu exist but we don't know what they are.
00:37:37 <jle`> if i had data Const' a b = Const' b
00:37:52 <jle`> ...i have a Category instance, don't i?
00:38:05 <jle`> hm no wait.
00:38:18 <jle`> no
00:38:57 <jle`> there is (.) but no id
00:38:59 <Cale> You have a semicategory or something
00:39:00 <Cale> heh
00:39:16 <jle`> is that a thing?
00:39:23 <aarvar> It is now
00:39:36 <Cale> Well, I just invented that name, but yes, other people it turns out have explored that notion.
00:39:40 <Cale> http://ncatlab.org/nlab/show/semicategory
00:39:45 <jle`> Const' g . Const' f = Const' g
00:39:53 <jle`> it doesn't sound very useful at first glance
00:39:57 <jle`> a semicategory
00:40:02 <jle`> but i shall read it and wait to be proven wrong
00:40:07 <Cale> Well, it's something in between a graph and a category
00:40:16 <ruzu> pseudocategories and quasicategories and inverse categories
00:40:43 <Cale> and you get to talk about the adjunctions that it has with Cat
00:41:04 <jle`> hm
00:42:46 <Cale> Proposition. The functor U of def. 3 has a left adjoint, which freely adjoins identity morphisms to a semicategory in the obvious way. It also has a right adjoint, which sends a semicategory S to the category whose objects are the idempotents of S and whose morphisms are the morphisms of S that commute suitably with them, as described at Karoubi envelope. Indeed, the monad on Cat generated by this latter adjunction is
00:42:46 <Cale> exactly the monad for idempotent completion, also called Cauchy completion. (Note, however, that this is not a 2-monad, because the right adjoint of U is not a 2-functor.)
00:43:19 <Cale> U here is the forgetful functor Cat -> SemiCat
00:43:39 <Cale> The left adjoint is the one you'd expect to get just because it's a forgetful functor
00:43:51 <Cale> but that there would be a right adjoint is a bit surprising
00:44:20 <Cale> (I suppose a little less surprising once you know what it is)
00:44:51 <jle`> i understand some of those words :)
00:45:48 <Cale> No, I take that back, it's still surprising :)
00:47:43 <Cale> It's really cool how concepts from analysis and not just topology end up generalising into category theory sometimes, because of the way that metric spaces are a special sort of enriched category.
00:52:01 <latk> I'm trying to parse a sum type with attoparsec. I have a parser for each of the "branches" (what is the actual word?), but when I create the overall parser, it complains that the types don't match.
00:52:15 <latk> Any ideas what I'm doing wrong ?
00:53:24 <pyon> latk: If you have a parser for each branch, the all you need to do is "choice [branch1, branch2, branch3 ...]".
00:53:38 <pyon> latk: Or, equivalently, "branch1 <|> branch2 <|> branch3 <|> ...".
00:53:57 <latk> pyon: Yeah, that is what I'm doing. I must be doing something else stupid..
00:54:22 <pyon> latk: Just a sanity check -- make sure the parsers for all the branches have the same type.
00:54:29 <orion> Hypothetically, I could write a Monad to model sending data out of a socket, right? Each line of the do-block would return, say, a bytestring with data to be written.
00:56:01 <BESSDER55> http://hd18xxxmovies.blogspot.com/2014/07/2014-best-hd-movies-adults-only.html
00:56:37 <Cale> orion: A writer monad would pretty much be it
00:57:15 <latk> pyon: I think that might be the problem. So I have something similar to : http://lpaste.net/108411 for my types. I then have parsers for Plane and Car, and want to combine them as transportParser = planeParser <|> carParser
00:57:25 <latk> Is this fundamentally wrong for some reason ?
00:58:02 <pyon> latk: Ah, then you probably want "transportParser = Plane <$> planeParser <|> Car <$> carParser".
00:59:32 <pyon> latk: I am guessing "planeParser" has type "Parser Plane" (Parser could stand for some larger type expression). If so, then "Plane <$> planeParser" has type "Parser Transport".
00:59:48 <pyon> latk: And similarly for "carParser" and "Car <$> carParser".
01:00:34 <latk> pyon: Ok, that makes sense. However, when I do this, I get the error "Couldn't match expected type 'Car -> Transport' with actual type 'Transport'
01:00:39 <latk> "
01:01:08 <pyon> latk: Mmm, could you show your code?
01:01:25 <latk> pyon: Yeah, just a sec
01:24:02 <bluezone> functional programming seems to be the new old thing, i have experience on the Java platform, what are the pros and cons of learning haskell over something like scala or clojure
01:24:46 <solatis> bluezone: haskell is pure, scala is pragmatic, clojure i don't know
01:25:07 <aarvar> clojue ir dynamically typed, so I dont think it compares well
01:25:47 <solatis> i found myself wanting to write more and more 'pure' code, so i ended up with haskell
01:25:49 <kvanb> You dont really want a dynamically typed functional programming language
01:26:00 <trap_exit> how can I have a monad
01:26:02 <kvanb> that sounds like honestly the worst ..
01:26:08 <trap_exit> that uses both IO () and State ?
01:26:15 <kvanb> trap_exit: a monad transformer
01:26:18 <kvanb> @where transformers
01:26:18 <lambdabot> I know nothing about transformers.
01:26:19 <aarvar> scala can do a lot of what haskell does, but its more verbose, and purity isnt enforced
01:26:21 <trap_exit> kvanb: have you heard of scheme?
01:26:28 <solatis> kvanb: actually, LiveScript is a haskell-ish language that compiles to javascript.. it's actually remarkably pleasant to work with
01:26:29 <kazagistar> yeah, like lisp, how horrible to have dynamic typing in a functional language
01:26:43 <solatis> kvanb: it even comes with its own prelude
01:26:50 <kvanb> @hackage transformers
01:26:50 <lambdabot> http://hackage.haskell.org/package/transformers
01:26:56 <kvanb> solatis: I use closure compiler + javascript at work
01:26:57 <pjdelport> bluezone: Haskell will probably let you learn a lot more about FP quicker than a more mixed-paradigm language.
01:26:59 <kvanb> its very pleasent.
01:27:01 <kvanb> *pleasant.
01:27:12 <pjdelport> bluezone: And what you learn will translate well.
01:27:18 <solatis> i can imagine
01:27:25 <aarvar> I dont think learning scala as an intermediate step to haskell is a bad idea
01:27:31 <kvanb> I was not being sarcastic :\
01:27:39 <kvanb> javascript + static types is pretty win
01:27:47 <dfeuer> Gleepers. Wasn't expecting it to be that easy. A fixed unfoldr, working with long-established ++, augment/build, foldr/build, etc. rules, actually seems to make an *extremely naive* version of enumFromTo produce good code.
01:27:48 <kvanb> its inherently a very functional language, kind of.
01:27:49 <dfeuer> Coooool.
01:28:09 <kvanb> dfeuer: I idolise your work
01:28:14 <kvanb> keep making prelude faster
01:28:15 <dfeuer> PFFF
01:28:18 <solatis> aarvar: i actually went that route, it made me 'click' things like pattern matching and immutability
01:28:25 <dfeuer> kvanb, I am stumbling about in the dark.
01:28:32 <bluezone> feels like i have to learn programming all over again :\ this is a very scary place
01:28:34 <kvanb> and then we should rewrite the benchmark game challenges as like 2 line compositions of functions
01:28:34 <aarvar> I went that route too
01:28:37 <kvanb> and laugh when we win.
01:28:54 <Kinnison> bluezone: most of us went through that, and then felt awesome afterwards
01:28:54 <dfeuer> And I feel very lucky when I hit something nice.
01:29:10 <kvanb> while learning haskell I had to unlearn C
01:29:21 <kvanb> I found even after 5 years I forgot how to do imperative algorithms and stuff
01:29:34 <trap_exit> i fucking hate haskell
01:29:36 <kvanb> 1.5 yrs later I can do both types fluently again and haskell improved my C alot
01:29:37 <trap_exit> I can never program in clojure again
01:29:39 <Kinnison> trap_exit: :-(
01:29:50 <trap_exit> I loved lisp for 10+ years ever since reading SICP
01:29:55 <aarvar> Haskell destroys your ability to use other languages, because you always wish they were haskell
01:29:56 <trap_exit> but now, I love types
01:30:01 <solatis> bluezone: fwiw, i'm currently 7 days in learning haskell full-time... i feel like i now know that there are very few people that actually know exactly what they're doing
01:30:08 <solatis> haskell is a very expert-friendly language :)
01:30:14 <trap_exit> aarvar: yeah, I refuse to use javascript, and am using ghcjs
01:30:15 <bluezone> haha
01:30:22 <aarvar> does that work well?
01:30:27 <trap_exit> and if I ever had to write assembly, I'd start by writing a x86 DSL in haskell
01:30:30 <dfeuer> kvanb, what happened, I think, is that some people who are much smarter and more knowledgeable than I am figured out some cool stuff to make things fast/efficient, and wrote a lot of that into code, but then they got distracted by rainbows and birds and forgot to finish the job.
01:30:34 <trap_exit> aarvar: it works fantastic, luite is a fucking badass
01:30:54 <aarvar> just think of haskell as offering more room to grow
01:30:55 <kvanb> dfeuer: more likely just prelude is massive
01:30:58 <aarvar> you can start out simple
01:31:04 <kvanb> and there was lower hanging fruit everywhere else at the time
01:31:05 <trap_exit> what I don't understand
01:31:07 <trap_exit> is why other languages exist
01:31:15 <dfeuer> C is very nice for certain kinds of programming.
01:31:16 <kvanb> actually, the ddc guys are busy making everything fusable without fusion rules!
01:31:24 <aarvar> but in another language you eventually reach a ceiling, where you can no longer improve your code
01:31:27 <dfeuer> kvanb, what is ddc?
01:31:33 <kvanb> dialect of strict haskell
01:31:38 <kvanb> https://github.com/DDCSF/ddc
01:31:38 <solatis> kvanb: oh god, that reminds me of c++ too much
01:31:58 <solatis> anyone else had the pleasure of having to work with c++ and boost.mpl ?
01:32:00 <kvanb> I think it's kind of aiming to be like fortan-mode haskell or something like that
01:32:03 <kvanb> for big compute
01:32:06 <kvanb> by the creator of repa.
01:32:48 <trap_exit> the onloy thing that can make haskell better
01:32:52 <trap_exit> would be if I coulld, within emacs, use ghci to search for types
01:32:56 <trap_exit> instead of having to use hoogle
01:33:15 <aarvar> what about if you could use yi instead of emacs
01:33:20 <aarvar> that would make it even better
01:33:21 <kvanb> hoogle is not very useful
01:33:25 <kvanb> I much prefer hayoo
01:33:51 <solatis> trap_exit: i'm pretty sure that's possible with ido
01:33:55 <trap_exit> hayoo is a search engine
01:34:00 <trap_exit> how has yahoo not sued them?
01:34:28 <solatis> trap_exit: they probably have sent a trademark infrigment letter alread
01:34:36 <solatis> if they don't, they lose their trademark:)
01:34:57 <solatis> or, perhaps more likely, the legal department doesn't know about hayoo :)
01:34:58 <trap_exit> but the hayoo lawyers are like: there's no confusion
01:35:06 <trap_exit> beucase anyone smart enough to use haskell is smart enough to not use yahoo
01:35:18 <solatis> no but yahoo simply *must* fight their trademark in order to keep it
01:35:25 <trap_exit> different markets
01:35:33 <solatis> that's up to a judge to decide
01:36:04 <solatis> the fact of the matter is that if they don't legally challenge it, other companies can use that as a precedence that they don't care about their trademark
01:36:31 <solatis> that's why you see certain companies trademarking certain shades of colors and uch
01:36:41 <solatis> and getting into ridiculous lawsuits
01:36:46 <tejing> as an exercise, I'm trying to write a very general arithmetic coder. in particular, I want it to work on any sensible symbol type (basically any finite totally ordered set) and with any kind of adaptive probability model. I'm having trouble making the typeclasses work out the way I want though, as the choice of symbol type is involved in the probability model's typeclass definition, but I'm not quite sure how to express that
01:36:54 <solatis>  /offtopic
01:37:18 <silasm> solatis: a few things... firstly, I think yahoo's trial period on its trademark is long over by now. Secondly, Yahoo's shifting focus from search to news (which is still pretty bad but has gotten a lot better over the years) and probably doesn't care all that much (they shouldn't).
01:38:40 <solatis> silasm: could be. i just know that keeping a trademark means that you must proactively protect it.
01:39:49 <solatis> so you could be correct that, if they indeed haven't sent a big scary letter to hayoo, they don't care about their trademark in the search market anymore
01:39:57 <solatis> but i find that hard to believe
01:40:32 <silasm> I could be wrong (I don't know a ton about such things), but I think that lessens after the trademark is actually registered. Once you have a registered trademark, my understanding is you /can/ be mean about it, but you don't /have/ to.
01:41:00 <shmookey> trademarks are generally 'use it or lose it'
01:41:12 <solatis> silasm: that is incorrect
01:41:17 <solatis> you /have/ to
01:41:26 <solatis> otherwise you get the situation with patents
01:41:55 <dutchie> what's the best way to get haskell onto ubuntu 14.04 these days? apt-get install haskell-platform? download h-p from haskell.org?
01:42:15 <dfeuer> tejing, I think that may be what functional dependencies are about.
01:42:22 <solatis> lots of "dead" trademarks, which suddenly have a lot of value, and can be abused by "evil" companies that just use the trademark portfolio to sue andget money
01:42:37 <hyPiRion> dutchie: https://github.com/bitemyapp/learnhaskell has good installation guides
01:42:49 <hyPiRion> See "Getting Started"
01:42:56 <dutchie> ta
01:43:27 <aarvar> Oh, it turns out this is #haskell after all
01:43:36 <solatis> sorry, i was going offtopic, my bad
01:44:10 <trap_exit>  for State + IO, how do I decide which monad is the outer monad ?
01:45:06 <augur> trap_exit: what are you looking to do?
01:45:26 <dfeuer> Isn't IO special enough that it can only go one way?
01:45:29 <trap_exit> so I start out with the state monad
01:45:32 <trap_exit> bercuase I have a "db" of sorts
01:45:39 <joneshf-laptop> is there a law for alternative like: f x <|> f y == f (x <|> y)
01:45:40 <joneshf-laptop> ?
01:45:41 <trap_exit> which I represent as a state monad, which I can query + update
01:45:47 <augur> trap_exit: if you have State outside, you can compute IO actions hich depend on the state. if its on the inside, the IO cant depend on the state in any way
01:46:12 <trap_exit> augur: ah, I need State oputisde then
01:46:15 <trap_exit> augur: thanks
01:46:20 <augur> fwiw, in general, the tendency is to have State outside
01:46:25 <trap_exit> augur: but can you explain why IO cant depend on state if State is inside?
01:46:37 <augur> trap_exit: because the state is inside!
01:46:54 <augur> the IO action you perform cant depend on it, because the IO action _gives you_ the state
01:47:05 <dfeuer> The first rule of tautology club is the first rule of tautology club.
01:47:16 <augur> IO (State s a) is an IO computation that gives you some state thing
01:47:26 <augur> so obviously the State thing cant impact what the IO computation will be
01:47:37 <trap_exit> dude
01:47:37 <augur> State s (IO a) on the other hand is a stateful computation of some IO action
01:47:40 <trap_exit> so I just fucking read the type signature?
01:47:44 <trap_exit> I'm an idiot
01:47:46 <trap_exit> this makes so much sense now
01:47:57 <augur> not sure if serious
01:48:06 <trap_exit> I am serious
01:48:24 <trap_exit> in State _ (IO ... )
01:48:28 <trap_exit> the IO can depend no the state
01:48:37 <trap_exit> in IO (State ...), its weird, because the Staet isn't 'persistent'
01:48:41 <augur> right
01:48:42 <trap_exit> each IO ( ... ) creates a new State monad
01:48:48 <trap_exit> so I'm like "fuck, how is this connected/continuous"
01:48:53 <trap_exit> and haskell is like "it's not, stupid"
01:48:59 <dfeuer> :D
01:49:01 <trap_exit> and I'm like "oh, I should use State _ (IO ... )"
01:49:05 <augur> data State s a = WrapState (s -> (a,s))
01:49:14 <trap_exit> then I hook all the (IO ... ) together somehow via sequence_ or something
01:49:17 <trap_exit> yeeah, this makes sense
01:49:21 <trap_exit> augur: thanks :-)
01:49:23 <augur> so   State s (IO a) ~ s -> (IO a, s)
01:49:34 <kvanb> don't you need StateT to wrap IO ?
01:49:35 <augur> so the IO a you return can be computed based on the input s
01:49:44 <augur> kvanb: if you want to use monad transformers
01:49:59 <trap_exit> "monad transfomers" sounds so scary
01:50:02 <kvanb> you can go one layer without, can you?
01:50:03 <trap_exit> but it's so fucking simple
01:50:06 <kvanb> trap_exit: it's easier than monads
01:50:07 <trap_exit> like "monads" too
01:50:09 <kvanb> get mtl
01:50:10 <kvanb> and its godmode
01:50:12 <augur> its kind of scary but its not, in principle
01:50:24 <trap_exit> i totally buy into haskel''s claim of
01:50:28 <trap_exit> "avoid success at any cost"
01:50:31 <augur> its just kind of awful because its not clear what order they go in
01:50:43 <kvanb> its awful because the errors mostly suck
01:50:43 <trap_exit> if instea dof "monad tutorials / monad transforrmers" people were jiust "go read the **** type signatures", it'd be so much easier
01:50:45 <trap_exit> and so much clearer too
01:50:50 <augur> actually for state i think the monad transformer is even more nuance
01:51:02 <augur> because State s (IO a) is not a monad over a
01:51:24 <augur> StateT s m a  ~  s -> m (a,s)     iinm
01:51:58 <trap_exit> what? State s (IO a) is not a monad over a?
01:52:14 <trap_exit> so I don't understand monad transformers then?
01:52:38 <augur> trap_exit: oh, were you expecting that it was?
01:52:43 <augur> @src StateT
01:52:43 <lambdabot> Source not found. Where did you learn to type?
01:52:45 <augur> :(
01:52:53 <trap_exit> augur: yeah, I thought you were a genius teacher
01:52:55 <jle`> State s (IO a) is the wrong kind to be a Monad anyway
01:53:08 <augur> jle`: no i meant abstracting over a
01:53:24 <augur> trap_exit: so with State s (IO a)
01:53:24 <jle`> but if you mean type Foo s a = State s (IO a), then i don't think Foo s is a monad either
01:53:32 <jle`> hm.
01:53:37 <augur> trap_exit: the next-state cant be affected by the IO action
01:53:48 <augur> trap_exit: whereas with StateT s IO a ~ s -> IO (a,s)  it can
01:54:51 <jle`> State s (IO a) can be useful if you are building up an IO a using stateful operations....but that's usually not what you want.  you probably want to be able to simultaneously have state and do IO, and branch/logic on the results of both
01:55:23 <jle`> State s (IO a), the (IO a) is a black box that you can't really use the result of in the State monad at least
01:55:28 <trap_exit> hmmmmm
01:55:31 <jle`> i wonder how useful State (IO s) a would be
01:55:45 <jle`> >___>
01:55:53 <augur> jle`: i think i might have used it before
01:56:05 <merijn> jle`: Not useless, but not very useful either
01:56:11 <augur> oh, State (IO s) a
01:56:13 <augur> sorry
01:56:13 <trap_exit> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Strict.html
01:56:16 <jle`> i'm trying to imagine which one is more useful
01:56:31 <merijn> jle`: Definitely "State s (IO a)" will be more useful
01:57:29 <jle`> modify (>> print 4) >> modify forkIO >> ..
01:57:35 <trap_exit> newtype StateT s m a
01:57:35 <jle`> hm
01:57:38 <jle`> no those don't work
01:57:40 <trap_exit> runStateT :: s -> m (a, s)
01:57:40 <kvanb> @hackage loop
01:57:41 <jle`> cause they change the type
01:57:41 <lambdabot> http://hackage.haskell.org/package/loop
01:57:47 <orion> jle`: Do you know when the next platform might be released?
01:58:07 <jle`> trap_exit: i like thinking of StateT s m a as just a fancy alias around the (s -> m (a, s))
01:58:11 <jle`> orion: RC2 is already out iirc
01:58:37 <jle`> trap_exit: you probably can implement the Monad instance yourself :)
01:58:50 <jle`> i dare you
01:59:07 <trap_exit> jle`: peer pressure ftw
01:59:15 <jle`> here are your type sigz
01:59:20 <orion> jle`: I'm having trouble finding a download for the RC.
01:59:33 <jle`> bind :: (s -> m (a, s)) -> (a -> (s -> m (b, s))) -> (s -> m (b, s))
01:59:45 <orion> http://trac.haskell.org/haskell-platform/wiki/ReleaseCandidates <-- old
01:59:51 <orion> outdated
01:59:57 <jle`> andThen :: (s -> m (a, s)) -> (s -> m (b, s)) -> (s -> m (b, s))
02:00:06 <jle`> ^ you should probably start with that one
02:00:17 <jle`> lift :: m a -> (s -> m (a, s))
02:00:18 <orion> archaic
02:00:41 <merijn> orion: RC's are on the mailing list
02:00:54 <jle`> orion: http://www.haskell.org/pipermail/haskell/2014-July/024276.html
02:01:03 <merijn> orion: They're not intended for "general consumption", the mailing list suggests a release later this week if no bugs are found
02:01:48 <jle`> trap_exit: get :: s -> m (s, s); put :: s -> (s -> m ((), s)); modify :: (s -> s) -> (s -> m ((), s))
02:01:51 <jle`> trap_exit: i believe in you :)
02:02:03 <kvanb> full laziness strikes again
02:02:06 <orion> merijn: Awesome, thank you.
02:02:11 <kvanb> they should just delete the pass
02:02:44 <arianvp> morning
02:02:51 <jle`> morning arianvp
02:03:19 <arianvp> I actually dreamt about my lens build issues
02:03:21 <arianvp> I need a break
02:03:28 <arianvp> :/
02:03:35 <trap_exit_> jle`: your type signatures for bind, andThen, and lift had so much content that my internet connection disconnected
02:03:38 <trap_exit_> jle`: here, is m a monad?
02:03:46 <trap_exit_> or, the 'inner monad' to be precise?
02:03:53 <jle`> it is any monad! :D
02:04:08 <jle`> remember that your type of interest is s -> m (a, s)
02:04:14 <jle`> and i claim that that is StateT s m a
02:04:19 <jle`> Monad m => for all of them ofc
02:04:24 <orion> merijn: Do you know where to get a "GHC_BINDIST_TARBALL" ?
02:04:33 <jle`> there are link to logs in the topic :)
02:05:19 <merijn> orion: The GHC site has binary distributions
02:05:35 <merijn> orion: http://www.haskell.org/ghc/
02:05:38 <augur> trap_exit_: a monad transformer is defined as a higher-order type operator t, such that if m is a monad, t m is a monad
02:05:46 <augur> trap_exit_: so t :: (* -> *) -> * -> *
02:05:52 <trap_exit_> augur: hang on
02:06:00 <arianvp> I'm trying to understand FunDeps
02:06:06 <trap_exit_> augur: let me get jle`'s type signatures to work by brute force first
02:06:10 <trap_exit_> then the intuition will follow
02:06:12 <arianvp> ddo they have anything to do with FunDeps in relational algebra?
02:06:35 <merijn> arianvp: According to the GHC manual they were inspired by fundeps in databases, so I'm guessing yes
02:07:19 <jle`> trap_exit_: start with (s -> m (a, s)) -> (s -> m (b, s)) -> (s -> m (b, s)); the implementation is that the result of andThen x y will be a function that feeds the state into the x, and feeds the resulting state into y, and returns the resutl of y
02:07:23 <orion> merijn: Ah, so the platform script is expecting a binary distribution, not a source tree, right?
02:07:45 <jle`> perhaps andThen f g are better variable names
02:08:00 <merijn> orion: I assume so, you need GHC to compile platform and you need GHC to compile GHC, so you need a binary GHC from *somewhere*
02:08:35 <orion> merijn: I already have 7.6 installed.
02:08:44 <merijn> Any pipes geniuses around that can help clarify/explain one of Tekmo's mailing list answers to me?
02:08:49 <bitemyapp> jle`: I'm about to post something written totally different from the way you do :)
02:08:49 * arianvp takes out my undergraduate database systems book
02:08:53 * arianvp opens the page on fundeps
02:09:03 <bitemyapp> arianvp: wait what
02:09:05 <jle`> bring it
02:09:10 <merijn> orion: Yeah, but building GHC 7.8 will probably take like an hour, so I'd recommend just downloading the binary anyway :)
02:09:11 <bitemyapp> jle`: it's mostly code
02:09:18 <arianvp> bitemyapp: what?
02:09:20 <bitemyapp> jle`: I included a smart-ass point-free impl too
02:09:25 <bitemyapp> arianvp: fundeps and database systems?
02:09:41 <darthdeus> what's the difference between Endo and Dual in Data.Monoid? they seem the same
02:09:44 <arianvp> bitemyapp: defenitly! fundeps play a major (maybe the biggest role) in normalizing databases
02:10:13 <trap_exit_> jle`: got the easy 4, https://gist.github.com/anonymous/d22868b9df493def79bc ... looking at bind + andThen now
02:10:20 <bitemyapp> arianvp: TIL. Time to read.
02:10:39 <jle`> trap_exit_: ooh hoo
02:10:49 <arj> configuration is best handled using a reader monad, isn't it?
02:10:53 <jle`> trap_exit_: um do those compile?
02:10:56 <kvanb> woah implicit lambda return is wierd
02:10:59 <arj> or is there some other approach i am not aware of?
02:11:00 <kuribas> Isn't "if then else" unnecessary?  Since I can write "a = if b then c else d" as "a | b = c | otherwise = d"
02:11:01 <bitemyapp> arianvp: can you link something about that?
02:11:07 <arianvp> bitemyapp: http://www.cs.uu.nl/docs/vakken/db/
02:11:11 <bitemyapp> arianvp: I'd appreciate it, my google-fu is on strike today.
02:11:11 <arianvp> the slides are in english
02:11:17 <bitemyapp> arianvp: <3 thank you
02:11:23 <arianvp> basically chec out the one on  FD's andd normalisatie
02:11:25 <kvanb> kuribas: does that work on one line?
02:11:27 <aarvar> :kuribas yes
02:11:30 <kvanb> or in brackets?
02:11:37 <jle`> guards work on line actually
02:11:41 <jle`> it's kind of weird though
02:11:41 <aarvar> you could write a function 'if using guards
02:11:57 <aarvar> if'
02:12:07 <arianvp> bitemyapp: chec out "Het relatiponele model; RA" if you're unfamiliar with the underlaying algebra we use for reasoning about databases as well
02:12:15 <jle`> if/then/elses tend to be pretty rare in Haskell because of guards, case statements, and our aversion to boolean blindness
02:12:20 <jle`> they pop up here and there
02:12:22 <kvanb> > let x = 3 in (3 | x == 3 = 2 | otherwise = 1)
02:12:24 <lambdabot>  <hint>:1:17: parse error on input ‘|’
02:12:24 <jle`> but they're rare compared to other languages
02:12:29 <kuribas> > let a | True = 2 | False = 3 in a
02:12:31 <lambdabot>  2
02:12:33 <bitemyapp> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
02:12:41 <bitemyapp> "I hate Booleans!" - never change Bob.
02:12:44 <kvanb> can you use it in brackets
02:13:22 <jle`> they aren't a part of expression syntax; they're only a part of declaration syntax
02:13:40 <jle`> (guards)
02:13:57 <kvanb> oh, lame
02:14:06 <bitemyapp> kvanb is disappoint.
02:14:16 <pjdelport> darthdeus: Why do Endo and Dual look the same?
02:14:19 <bitemyapp> jle`: quick, toss kvanb a classy lens or something.
02:14:24 <kuribas> jle`: True, but you can always use let
02:14:28 <arianvp> bitemyapp: http://en.wikipedia.org/wiki/Boyce%E2%80%93Codd_normal_form,  http://en.wikipedia.org/wiki/Relational_model#Key_constraints_and_functional_dependencies
02:14:45 <bitemyapp> arianvp: *______*
02:14:53 <jle`> kuribas: yeah, in the declaration :)
02:14:54 <pjdelport> darthdeus: Endo is specifically (a -> a) function composition; Dual is the swapped version of any other monoid.
02:14:55 <bitemyapp> arianvp: I have too much to read already ;_;
02:14:58 <bitemyapp> arianvp: (thank you!)
02:15:19 <kvanb> yeah I really miss the ? operator
02:15:31 <kvanb> I feel like I kind of need something really similar to `maybe`
02:15:39 <kvanb> but as an operator somehow, I don't know.
02:15:39 <jle`> the if/then/else syntax in haskell is extremely ugly
02:15:43 <jle`> but i think that was on purpose
02:15:47 <BartAdv> anyone tried/did something with mflow?
02:15:48 <arianvp> bitemyapp: Don't worry. It took me quite some time to grok. + cheated because I actually had a lecturer
02:15:50 <jle`> to discourage us from using it, heh
02:16:04 <jle`> kvanb: how about `bool` ?
02:16:06 <jle`> :t bool
02:16:08 <lambdabot> a -> a -> Bool -> a
02:16:32 <jle`> > map (bool "im false" "im true") [True, False]
02:16:33 <lambdabot>  ["im true","im false"]
02:16:34 <kuribas> jle` I like multiway if for expressions.
02:16:36 <bitemyapp> arianvp: I'm only awake so I can post the post I just wrote.
02:16:42 <bitemyapp> then I am getting TF to sleep.
02:16:52 <kvanb> > map (bool "im false" "im true") [False..]
02:16:54 <lambdabot>  <hint>:1:41: parse error on input ‘]’
02:16:59 <arianvp> bitemyapp: basically, identifying functional dependencies allows us to split up a table in such way that there is no (or at least as little) redundancy as possible
02:17:00 <kvanb> ;P
02:17:04 <trap_exit_> jle`: https://gist.github.com/anonymous/694fbd0b3c2561ae5dac <-- did you copy these type signatures from somewhere
02:17:07 <kuribas> > if | even 2 -> "even" | odd -> "odd"
02:17:09 <lambdabot>  <hint>:1:1: Multi-way if-expressions need MultiWayIf turned on
02:17:09 <trap_exit_> or did you create them mentally
02:17:18 <jle`> i will from now on call that the jenn schiffer quirk
02:17:21 <jle`> [False..]
02:17:25 <bitemyapp> arianvp: that's fantastic.
02:17:33 <trap_exit_> augur: I'm reading for our conversatinoa bout monad transformers now, if you still have time
02:17:38 <bitemyapp> arianvp: I actually need to be able to reason like this in a principled way in my day-to-day work *right now*
02:17:44 <trap_exit_> nderstanding to discuss abstract intuition
02:17:45 <jle`> trap_exit_: they're the actual type signature sof those functions, with the newtype wrapper unwrapped
02:18:01 <augur> trap_exit_: im probably going to crash soon, but
02:18:01 <trap_exit_> jle`: yes, but did you copy them from hackage ... or how did you have them?
02:18:05 <bitemyapp> trap_exit_: http://vimeo.com/73648150
02:18:08 <arianvp> bitemyapp: humans have a pretty  good intuition on performing this algorithm without knowing it to be honest
02:18:19 <bitemyapp> arianvp: I guess I'll find out. Thanks again.
02:18:22 <trap_exit_> augur: ah, goodnight!
02:18:30 <augur> trap_exit_: consider first a boring type:   data AppInt f = WrapAppInt (f Int)
02:18:34 <arianvp> bitemyapp: I'm pretty sure you're already identifying functional dependencies without actually having noticed it
02:18:40 <augur> trap_exit_: then consider   data App f a = WrapApp (f a)
02:18:44 <bitemyapp> mebbe so.
02:18:48 <jle`> trap_exit_: it's from memory, but that's not that impressive heh
02:18:56 <jle`> trap_exit_: next step would be to add the newtype wrapper back in
02:18:59 <bitemyapp> arianvp: all the same, I like mechanical processes - less thinking!
02:19:13 <trap_exit_> bitemyapp: you traitor! aren't from from #erlang? :-)
02:19:15 <jle`> trap_exit_: newtype StateT s m a = StateT { runStateT :: s -> m (a, s) }
02:19:19 <augur> trap_exit_: then consider   data MaybeApp f a = NothingMA | JustMA (f a)
02:19:26 <jle`> trap_exit_: and rewrite everything in terms of that
02:19:43 <bitemyapp> trap_exit_: wait wut. I used to use Clojure pretty seriously. I only dabbled in Erlang with an eye towards theft.
02:19:53 <bitemyapp> trap_exit_: if you used Clojure you might've used one of my libraries.
02:19:57 <kuribas> kvanb: let (True ? a) b = a; (False ? a) b = b in (even a ? "even" $ "odd")
02:20:00 <kuribas> > let (True ? a) b = a; (False ? a) b = b in (even a ? "even" $ "odd")
02:20:02 <lambdabot>  "odd"
02:20:05 <jle`> trap_exit_: then the next step in this tutorial is to instead write the functions directly as the typeclass instances, for Monad, MonadTrans, MonadState
02:20:06 <bitemyapp> trap_exit_: but I am a traitor yes  ^__^
02:20:22 <jle`> ...and that's where it ends
02:20:35 <kvanb> kuribas: That's interesting.
02:20:40 <trap_exit_> bitemyapp: ah, pot / kettle
02:20:50 <trap_exit_> jle`: noted, thanks
02:20:51 <jle`> kuribas: clever usage of ($) :P
02:21:00 <trap_exit_> I'm going to sleep on this, and continue with moand transformers tomorrow
02:21:10 <arianvp> bitemyapp: plz tell me you wrote the core async stuff in clojure. that is hot
02:21:18 * bitemyapp laughs and snorts
02:21:21 <bitemyapp> no that was Baldridge
02:21:22 <jle`> trap_exit_: there was one paper that literally single handedly caused me to understnad monad transformers
02:21:24 <jle`> i can't make any promises
02:21:37 <arianvp> that stuff landed straight from heaven
02:21:38 <augur> jle`: do tell!
02:21:38 <bitemyapp> I wrote a thing that prints pretty colors to your stdout when you execute a query, maintained a db client, helped write another one, etc.
02:21:43 <jle`> but http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
02:21:43 <trap_exit_> jle`: where is that apper ?
02:21:50 <jle`> i remember vividly the moment i read it
02:21:53 <bitemyapp> arianvp: nothing so glorious: http://github.com/bitemyapp
02:21:53 <jle`> and the moment it all made sense
02:22:03 <jle`> and i never had problems with the concept again
02:22:13 <trap_exit_> jle`: did the heavens part and angels start singing?
02:22:15 <jle`> it was during a vacation in canada...and we were stopping at a strabucks
02:22:22 <jle`> and i sat down and read it on my phone
02:22:29 <augur> in general i think its probably best to just define your own monad and avoid transformers entirely
02:22:30 <jle`> or maybe it was my tablet
02:22:40 <jle`> i guess my memory was not so vivid after all
02:22:45 <arianvp> bitemyapp:  writing DB Stuff without knowing relationa algebra? blaphemy ;)
02:22:51 <arianvp> :D
02:22:55 <kvanb> > browse for 3 seconds in source code, find great rage comment
02:22:56 <kvanb> https://github.com/bitemyapp/revise/blob/master/src/bitemyapp/revise/connection.clj#L37
02:22:56 <lambdabot>  <hint>:1:22: parse error on input ‘in’
02:23:02 <bitemyapp> arianvp: I was more daring than that.
02:23:03 <kvanb> damnit lambdabot .
02:23:07 <jle`> there's this weird interplay with understanding things by implementing them and understanding things by using the API they offer
02:23:07 <trap_exit_> jle`: it was so vivid, that it overwrote all unnecessary space in your brain and you can't remember insignifncant details like tablet vs phone
02:23:26 <jle`> presumably vividness would involve by definition memory of insignificant details!
02:23:27 <bitemyapp> arianvp: I wrote a conn mgmt system for a database client for a new database I knew little/nothing about and made it a pipelined, async connection system.
02:23:28 <jle`> :o
02:23:31 <merijn> kvanb: lambdabot is great at unlearning 4chan-isms like greentexting and twitter-isms like @name :p
02:23:32 <bitemyapp> arianvp: with no global variables!
02:23:48 <kvanb> merijn: I do it once per day
02:23:52 <kvanb> and have been for the last like 6 months
02:23:53 <jle`> sometimes i feel liek we are all relational algebras
02:23:53 <arianvp> bitemyapp: yay no globals!
02:23:58 <kvanb> ;_;
02:24:03 <arianvp> bitemyapp: Hope you wrapped it up in a Reader monad .... hehehe
02:24:13 <kvanb> maybe I am incapable of learning from my mistakes
02:24:22 <bitemyapp> arianvp: it was Clojure - no.
02:24:29 <arianvp> ... wait
02:24:36 <arianvp> guys guys.  is the Reader monad  just S K I?
02:24:38 <arianvp> :O
02:24:41 * bitemyapp blinks
02:24:51 <merijn> arianvp: The reader monad is just "r ->"
02:25:08 <bitemyapp> why do I keep compiling pandoc.
02:25:08 <merijn> "newtype Reader r a = Reader (r -> a)" :p
02:25:10 <bitemyapp> I am an idiot.
02:25:34 <arianvp> so   bind =   Sxyz=xz(yz) and  return = Kxy=x
02:25:34 <hamid> bitemyapp, idiots compile pandoc? :P
02:25:39 <kvanb> monads why are you so slow
02:25:47 <jle`> help i am addicted to inlining
02:25:51 <bitemyapp> hamid: I feel like I should cache the build in a modularized sandbox.
02:25:55 <bitemyapp> hamid: but I am too lazy.
02:25:57 <kvanb> wowsers at conduit benchmarks that suggest IO packing/unpacking nerfed his bench by 10x
02:25:59 <arianvp> merijn: but bind and return correspond to the K and S combinator from SKI combinatory calculus :D
02:26:02 <jle`> bitemyapp: blah blah nix blah
02:26:13 <bitemyapp> jle`: yeah. well. I failed to get nix to work ~3 times.
02:26:22 <bitemyapp> jle`: I missed being able to have johnw get me started.
02:26:25 <bitemyapp>  :(
02:26:25 <jle`> you are further than me
02:26:31 <hamid> bitemyapp, it's haskell you are fine as long as you are lazy ;)
02:26:32 <arianvp> bitemyapp: I'm also trying to set up nix. where are you stuck?
02:26:43 <bitemyapp> arianvp: I don't want to reopen old wounds. it's 0425
02:26:49 <jle`> im addicted to inlining
02:26:51 <bitemyapp> maybe when I've rested I'll give it a shot and report back.
02:26:53 <jle`> someone tell me to stop
02:26:55 <bitemyapp> jle`: it's called mainlining
02:27:09 <aarvar> what is this nix everyone is talking about
02:27:16 <arianvp> aarvar: It's heaven basically
02:27:27 <arianvp> aarvar: it's a purely functional package manager
02:27:27 <jle`> magic OS where everything is a sandbox
02:27:30 <kvanb> nothing like derping out at like 6am and posting a stupid thing on the haskell pipes list because you only skimmed the question
02:27:34 <aarvar> interesting
02:27:39 <kvanb> mailing lists are so embarassingly answer-edit-proof
02:27:56 <arianvp> aarvar: and there is an OS built on top of it. basically all uddates have ACID properties so you can rollback to any previous config
02:27:57 <bitemyapp> arianvp: written in C++ and Perl (lol)
02:27:57 <jle`> its ok i will literally inline every function in this module and nobody can stop me
02:28:06 <arianvp> aarvar: all configuration is  declarative too.
02:28:06 <jle`> not until i see that my binaries literally triple in size
02:28:07 <bitemyapp> jle`: no no, you have to add RULES
02:28:14 <bitemyapp> jle`: always add RULES
02:28:14 <jle`> what is rules
02:28:16 <aarvar> I just set up arch a few days ago
02:28:19 <jle`> sounds like something i hvae to actaully think about
02:28:21 <aarvar> and now I have to switch to this NixOS?
02:28:23 <bitemyapp> jle`: LOL
02:28:23 <jle`> and apply reason
02:28:31 <arianvp> aaarrvar:  You can use  Nix without NixOS :)
02:28:33 <aarvar> I should do it
02:28:49 <arianvp> you just don't get the hotness of "rolling back the entire OS when you fuck up config"
02:29:05 <arianvp> which is pretty amazing, considering how many times i've bricked an arch installation before. lol
02:29:09 <aarvar> how does NixOS do as far as package availability?
02:29:28 <bitemyapp> jle`: http://bitemyapp.com/posts/2014-07-30-aeson-with-uncertainty.html
02:29:42 <merijn> jle`: inline is something you have to think about too, it will blow up your compile times and won't always help and can actively hurt occasionally
02:29:44 <arianvp> aarvar: sometimes it's lacking, but it's really easy to build own package configs.  most stuff is there though:  https://github.com/NixOS/nixpkgs/tree/master/pkgs
02:30:05 <arianvp> aarvar: when you find something that isn't there.. a simple pull request gets handled rather quickly
02:30:07 <bitemyapp> merijn: `cabal install lens`
02:30:14 <jle`> merijn: yeah, i'm joking, heh.
02:30:16 <kvanb> it's more likely to hurt when you inline the body of loops
02:30:25 <kvanb> since it kills the thing that turns them into tight loops
02:30:39 <arianvp> I should pay my hosting bills... so I can freakin blog again
02:30:49 <aarvar> Now I want to try it even though I just spent all that time isntalling arch
02:30:56 <bitemyapp> arianvp: using Hakyll was my best idea ever.
02:30:57 <jle`> i'm mostly inlining what are supposed to be helper functions...but i feel like ghc would inline them anyways.  but i'm scared to look at the core
02:31:05 <bitemyapp> aarvar: p sure you can use nix pkg manager on arch quite nicely.
02:31:09 <bitemyapp> aarvar: try it that way.
02:31:24 <aarvar> I see it's in the AUR
02:31:27 <bitemyapp> jle`: let me know what you think of my terrifying horrible JSON crap.
02:31:27 <jle`> bitemyapp: typo on  e’re
02:31:29 <kvanb> jle` INLINE everything that's less than 4 lines long and doesn't call itself
02:31:30 <bitemyapp> dammit
02:31:32 <kvanb> is a pretty good call
02:31:35 <magthe> possibly quite silly question, but searching has turned up nothing so far, how do I specify 'void *' in bindings-DSL? "#field userdata, Ptr ?????"
02:31:35 <kvanb> INLINEABLE everything else.
02:31:53 <arianvp> bitemyapp:  I run Ghost at the moment.   I like it pretty good. but it's not very hackerish
02:31:56 <bitemyapp> jle`: fixed
02:32:04 <kvanb> arianvp: +1 for ghost
02:32:08 <bitemyapp> arianvp: hakyll is just so dead simple.
02:32:20 <bitemyapp> arianvp: static files, zippy build, I have a Makefile to do everything.
02:32:22 <kvanb> but you have to actually set it up
02:32:29 <kvanb> ghost is just like
02:32:34 <kvanb> install, cron, done
02:32:34 <bitemyapp> set what up?
02:32:48 <arianvp> bitemyapp:  can I do cool stuff like precompile assets like Fay and GHCJS stuff?
02:32:56 <arianvp> bitemyapp: OH it's just haskell. ofcourse I can
02:33:07 <bitemyapp> arianvp: let your imagination soar.
02:33:10 <kvanb> bitemyapp: set up the look and feel
02:33:20 <kvanb> and stuff that I can't be bothered doing
02:33:27 <jle`> bitemyapp: can you write out a naive instance
02:33:36 <jle`> bitemyapp: so i can remember how ToJSON wrks
02:33:38 <jle`> hehe
02:33:41 <arianvp> has anybody have any experience with the  gdiff package?  I want to implement DOM diffing in haskell...
02:33:46 <bitemyapp> jle`: hum.
02:33:50 <bitemyapp> jle`: yes?
02:33:53 <merijn> arianvp: GHCJS should (or will) work well with cabal, I think. Fay is not actually haskell, so I don't know about it
02:33:55 <bitemyapp> h/o
02:33:57 <arianvp> I just have no idea about the performance characteristics, and I cant find anything in the author's master thesis ether
02:34:05 <kvanb> someone rewrite mithril in haskell please. That is all I need to be truly complete.
02:34:54 <arianvp> merijn:  yeh GHCJS is good stuff.  and  luite is really responsive.  Found some bugs yesterday and he responded within like 5 minutes on IRC. that ninja
02:35:08 <luite> arianvp: i fixed the lens installation problem on ghcjs (was the lens cabal file trying to use a cpp option that conflicted with some files requird for template haskell) and also the ghcjs-jquery evnt handling problem
02:35:16 <arianvp> merijn: see what I mean. he did it again
02:35:18 <luite> lol
02:35:33 * aarvar is building nix
02:35:35 <bitemyapp> @karma+ luite
02:35:35 <lambdabot> luite's karma raised to 15.
02:35:36 <jle`> bitemyapp: ty
02:35:54 <xxen> lol
02:36:07 * aarvar has finished installing nix
02:36:26 <arianvp> luite: got that fork of lens on github? I'll see if It works :)
02:36:38 <luite> arianvp: i fixed it in ghcjs
02:36:46 <arianvp> luite: oh sweet.
02:36:47 <edwardk> luite: is that still happening?
02:36:53 * arianvp git pull origin master
02:36:59 <edwardk> luite: if so, send me a patch. it'll go in
02:38:35 <arianvp> luite: so how did you fix the garbage collection problem with the callbacks eventually?
02:38:46 <arianvp> luite: just return an IO () ?
02:40:05 * arianvp reads ghcjs-jquery source code
02:40:06 <arianvp> luite: sweet. I didn't know about the   "js-sources:"  options
02:40:13 <bitemyapp> jle`: I added an example and links just for you.
02:40:20 <bitemyapp> jle`: http://bitemyapp.com/posts/2014-07-30-aeson-with-uncertainty.html
02:40:24 <jle`> thank you kind sir
02:40:36 <kvanb> heh
02:40:44 <kvanb> ghcjs code sharing looks kind of like godmode
02:40:56 <danou_> my girlfriend : http://70.81.112.235:81/C%3A/Dan/photos/m/mylene2.jpg
02:40:58 <bitemyapp> kvanb: blackdog will tell you all about it.
02:41:00 <luite> edwardk: i remove the -traditional option now in ghcjs, when processing javascript sources, so it does work now. i'm not sure if the package should be changed, since the problem is with files not included in the lens package
02:41:11 <edwardk> k
02:41:11 <kvanb> it would certainly making testing a lot easier
02:41:23 <edwardk> if you come to feel strongly about it. let me know
02:41:40 <luite> edwardk: and hackage won't accept a fix yet anyway, since it doesn't know the impl(ghcjs) flag
02:42:21 <bitemyapp> kvanb: I use Hakyll partly because i work more quickly editing text and code in Emacs and pushing from terminal
02:42:32 <bitemyapp> kvanb: also, pandoc understands how to handle rendering Haskell code
02:42:44 <bitemyapp> jle`: okay, that's all the edits for now. cheers.
02:43:07 <luite> arianvp: that's a new field supported only in the ghcjs branch
02:43:09 <jle`> bitemyapp: it's nice
02:43:12 <kvanb> this all still looks like an enormous hack though
02:43:19 <bitemyapp> kvanb: ?
02:43:37 <kvanb> it looks like jquery plugins all over again
02:43:41 <kvanb> with all those rts/ includes
02:44:01 <bitemyapp> jle`: phew. okay. posted to lobstahs.
02:44:03 <bitemyapp> jle`: goodnight!
02:44:06 <jle`> bitemyapp: id do
02:44:12 <jle`> base : maybeAdd
02:44:12 <arianvp> luite:  Yeh. I'm using   ghcjs/cabal   on the ghcjs branch
02:44:16 <jle`> and make base just the one thing
02:44:17 <jle`> but that's me
02:44:29 <jle`> insignificant style choice
02:44:33 <luite> arianvp: yeah everything returns an IO action for unregistering now
02:44:54 <jle`> also i'd maybe align all your stuff in catMaybes
02:44:56 <jle`> hm.
02:44:59 <jle`> you can be sneaky
02:45:31 <jle`> bitemyapp: and do mapMaybe (uncurry mField) [("fields", sqsFields), ...]
02:45:36 <jle`> heh
02:45:36 <luite> kvanb: rts includes? do you mean in the shims repository?
02:45:39 <arianvp> holy shit so many people are joining
02:45:51 <bitemyapp> jle`: vut
02:46:00 <bitemyapp> arianvp: netsplit.
02:46:04 <NinjaPenguin> arianvp: They're probably coming back from netsplit.
02:46:19 * hackagebot gpolyline 0.1.0.1 - Pure module for encoding/decoding Google Polyline  http://hackage.haskell.org/package/gpolyline-0.1.0.1 (FinnEspenGundersen)
02:46:39 <ticktockman> This may be interesting: https://github.com/fiendfan1/Haskell-GLSL-eDSL . GLSL codegen and graphics pipeline. Uses lots of dependant-ish typing and cool GHC features.
02:46:44 <jle`> bitemyapp: don't mind me :)
02:46:50 * arianvp building ghcjs..
02:47:16 <bitemyapp> jle`: if you come up with any, email me edit suggestions pls
02:47:19 <arianvp> luite: when would a  "synchronous"  callback be desirable?
02:47:21 <bitemyapp> jle`: cheers and goodnight
02:47:23 <jle`> night
02:48:36 <bitemyapp> jle`: wait, what's your twitter again?
02:48:40 <bitemyapp> jle`: auto-complete is failing me.
02:49:02 <jle`> mstksg
02:49:14 <jle`> blame literally 9 year old me
02:49:16 <bitemyapp> @mstk
02:49:16 <lambdabot> Maybe you meant: msg ask
02:49:21 <jle`> oh is it @mstk
02:49:24 <bitemyapp> jle`: yeah
02:49:27 <jle`> heh sry
02:49:28 <bitemyapp> that's why I couldn't autocomplete
02:49:28 <bitemyapp> yeesh
02:50:10 <jle`> i used to do mstk unless the other few people who also use mstk are already registered, otherwise mstksg
02:50:22 <jle`> it's like a race
02:50:25 <kvanb> luite: the examples I looked at used several rts includes
02:51:14 <kvanb> I don't know how big they are, but I'd like to think that my programs are self contained (no http gets) and only pull in parts of the runtime they use (i.e. not > 10kb, please).
02:51:15 <luite> arianvp: those execute immediately in the handler, so you're still able to call stopPropagation() on the event for example. async callbacks run in the background
02:52:31 <kvanb> there are major practical applications for ghcjs at my work
02:52:47 <darthdeus> is there a way to define something like Foldable but that all of the contained "elements" must be a monoid? I'm not sure how to syntactically put the typeclass restriction when the kind is * -> *
02:52:51 <luite> kvanb: not sure what examples you mean then, could you give a url?
02:53:09 <zomg> kvanb: I was thinking of playing with ghcjs to see if I can have a haskell compiler in browser =)
02:53:18 <arianvp> kvanb: same here.  We're building a CMS with both haskell on the frontend and backend
02:53:19 <zomg> just for funzies
02:53:20 <darthdeus> like something like   class Monoid m => Something (s m) where
02:53:26 <darthdeus> though that's not syntactically correct
02:53:36 <arianvp> :)
02:53:49 <kvanb> okay, I suck.
02:53:55 <kvanb> you know what, I'm a retard.
02:54:00 <arianvp> kvanb: why?
02:54:15 <kvanb> I was looking in examples/fay and didn't even realise that rts/ was the fay runtime not the ghcjs runtime
02:54:16 <kvanb> I think
02:54:31 <kvanb> so now I can blame fay for being fat and give ghcjs a hallpass
02:54:34 <arianvp> kvanb: hehehe
02:54:44 <mmmm> Is there a nice way to use a different representation for a sub-tree of your AST without polluting the whole thing?
02:55:27 <arianvp> mmm: couldn't you just like lens into the subtree and then fold over it?
02:55:48 <mmmm> lens isn't a dependency I have access to
02:57:08 <arianvp> mmmm: have you got a way to get to your subtree yet?
02:58:13 <mmmm> What do you mean by get to?
02:58:44 <jle`> my data type has 6 constructors so now i have to write 36 cases for a combining function >______>
02:58:52 <jle`> hopefully after writing all of these out i can notice patterns and reduce them
02:59:06 <jle`> the things i do for performance hacks
03:00:54 <jle`> there is some sort of thrill that rushes through my veins when i press save after writing a new case and wait to see if it typechecks
03:02:17 <gfixler> jle`: can you write something to write the combining functions for you?
03:02:37 <jle`> no they all have unique logic
03:02:40 <jle`> well
03:02:44 <jle`> i'm just going to write them all out first
03:02:50 <jle`> and then see the repeating patterns that i can unify
03:03:03 <jle`> but first i'm going to see if this offers any performance boost at all
03:03:19 <arianvp> mmmm: say you got an Ast:  data Tree a = Empty | Leaf a | Node (Tree a) (Tree a)
03:03:33 <arianvp> mmm: then you can just derive Foldable to change the representation
03:03:54 <arianvp> say      foldr (:) [] mySubTree => subtree is now represented as a list
03:05:01 <arianvp> mmm: is that what you're looking for?
03:05:11 <mmmm> no
03:05:15 <arianvp> darnit
03:06:42 * arianvp still waiths for ghcjs-boot to finish 
03:06:46 * arianvp yawns
03:07:26 <luite> use --no-prof if you don't need profiling libs, and -jN should also work
03:08:18 <luite> gotta go now, if you ask questions in #ghcjs i'm more likely to see hem later
03:08:39 <arianvp> luite: great :) . take care!
03:10:34 <jle`> wow
03:10:51 <jle`> cut down the time by two thirds
03:10:56 <jle`> i guess it was worth it
03:11:10 <arianvp> jle`: what did?
03:11:56 <jle`> oh refactoring my ADT of one constructor into six constructors
03:12:02 <jle`> and having to write 36 case statements
03:12:04 <jle`> oh he/she left
03:13:15 <jle`> wb
03:31:48 <arianvp> thanks
03:32:44 <kvanb> is ocaml worth learning
03:32:48 <kvanb> if I already know haskell
03:33:44 <termos> only if you want to apply for jane street
03:33:55 <byorgey> kvanb: probably not.  But you are asking in the wrong place if you want an unbiased opinion.
03:34:08 <kvanb> ok
03:34:15 <kvanb> I'm picking free books to get
03:34:17 <byorgey> on the other hand, there is really no such thing as an unbiased opinion.
03:34:32 <kvanb> was tossing between real world haskell, having already known haskell, or the ocaml equivalent
03:34:53 <byorgey> if you already know haskell then you shouldn't get either one.
03:35:10 <kvanb> I already have simons book on paralellism on the list
03:35:29 <kvanb> and I can only go oreilly so that doesn't leave much choice :\
03:37:26 <byorgey> kvanb: ok, so get RWH and give it as a gift to a friend who wants to learn Haskell
03:40:14 <kvanb> are there any good books on proofing stuff?
03:42:51 <supki> kvanb: have you seen software foundations?
03:42:53 <supki> it's great
03:43:23 <kvanb> is it 'Software Testing Foundations' ?
03:43:36 <supki> http://www.cis.upenn.edu/~bcpierce/sf/current/index.html
03:43:59 <Tinned_Tuna> That book is grand
03:44:14 <kvanb> oh, cheers
03:57:33 <mmmm> Any good way to say that a certain constructor will only appear at the end of a list of elements (I assume not..)
03:58:18 <merijn> mmmm: Nope, unless you write a custom list type that enforces this
04:08:13 <Sagi> supki: any idea whether there's an .epub around? My google-foo is failing me.
04:20:22 <mmmm> Sagi: You can try using pandoc to convert it to an epub
04:21:30 * hackagebot haroonga 0.1.4.0 - Low level bindings for Groonga.  http://hackage.haskell.org/package/haroonga-0.1.4.0 (cosmo0920)
04:22:09 <arianvp> Suddenly. javascript is bearable: http://lpaste.net/108414
04:28:08 <kgadek> hi. What's your opinion on record sum types like: `data Gene = X {_ident::Int, _xx::String} | Y {_ident::Int, _yy::Char}` ? I know this is considered a bad style since `_xx` & `_yy` are partial functions but… there comes edwardk with his prisms and it's as always a game-changer ;) still yet I'd like to (^.) not typecheck with partial functions, not to return mzero. How's that possible? Snippet here:
04:28:08 <kgadek> https://gist.github.com/ae8b4079e0d4e181d006
04:41:24 <supki> kgadek: wrap String in newtype without defining Monoid for it?
04:41:45 <supki> it's actually mempty, not mzero, the two are just happen to be the same in that case
04:43:07 <kgadek> supki: yeah, that's one way to do it but it's quite… tiresome. I think better would to `data Gene = X GeneX | Y GeneY` and `data GeneX = GeneX {…}`. Still I think it could be done better
04:45:22 <supki> kgadek: alternatively, you can define your own (^.)-like that only works on Lens, so it won't typecheck when you actually have a traversal
04:47:17 <darthdeus> can "t (f a) -> f (t a)" be called something like "commuting t and f"?
04:49:27 <darthdeus> also, why does Traversable require a Functor and not just a Foldable, since it's not using the Functor directly (all functions require Applicative anyway) ... is it because of the Functor laws?
04:54:05 <NikolajK> what was again an example for the use of the expression "[]" within code?
04:54:57 <merijn> NikolajK: Passing an empty list to something?
04:55:18 <NikolajK> like
04:56:03 <NikolajK> fmap (\x->x*x) []
04:56:51 <pavonia> fmap f [] == []
05:02:52 <faern> NikolajK: Pattern match empty lists in your functions
05:03:11 <NikolajK> got it, thx
05:03:11 <faern> isEmpty [] = True
05:03:15 <faern> isEmpty _ =False
05:03:34 <NikolajK> I wanted to make a joke in a mail and needed some
05:03:52 <NikolajK> mail sent, so problem earased
05:04:08 <pjdelport> darthdeus: Commutation is probably not the right intuition for "t (f a) -> f (t a)"; it's not invertable.
05:04:11 <NikolajK> can you write code postfix, btw.? [] /postfix
05:04:32 <pjdelport> darthdeus: More accurate perhaps is lifting the traversable structure into the functor.
05:04:35 <darthdeus> pjdelport: hmm interesting, i never thought of that
05:05:12 <pjdelport> darthdeus: If you look at the simple case of sequence on lists:
05:05:12 <pjdelport> :t sequence
05:05:13 <lambdabot> Monad m => [m a] -> m [a]
05:05:37 <pavonia> NikolajK: What do you mean by postfix?
05:05:41 <pjdelport> darthdeus: Then what's happening is quite literally lifting the applications of (:) and [] from outside the functor to inside it.
05:05:43 <darthdeus> pjdelport: but sequence doesn't lift it into the functor, since that would be return/pure, no?
05:05:47 <NikolajK> argument followed by function
05:05:58 <darthdeus> pjdelport: maybe my understanding of the word "lifting" is wrong :D
05:06:00 <NikolajK> 3 magic (\x->x^2) should be 9
05:06:03 <pjdelport> darthdeus: (I say "Functor", because sequence doesn't actually need Monad, only Applicative.)
05:06:21 <l0cust> So, having an odd issue with Yesod. The newest Yesod conflicts with the newest XMonad, so I sandboxed my installation of Yesod. Now, when I try to run my web app with "yesod devel", I get this error - http://lpaste.net/108417
05:06:35 <pavonia> NikolajK: You can define an operator for that
05:06:37 <pjdelport> darthdeus: Well, it is liftA2 and pure, to be exact. :) And yes, that's the right understanding of lifting, probably.
05:06:52 <l0cust> The error message is just false, because this is my $PATH - http://lpaste.net/108418 .
05:06:57 <pavonia> > let x # f = f x in 3 # (\x -> x^2)
05:06:59 <lambdabot>  9
05:07:41 <darthdeus> pjdelport: hmm, good :)
05:08:04 <darthdeus> pjdelport: do you happen to know why Traversable requires a Functor? is that because of the laws to kind of force that a traversal doesn't change the structure?
05:08:21 <NikolajK> pavonia: and can I then use this further, or must I write let—in every time?
05:08:49 <pavonia> You can define it top-level and use it like any other operator
05:09:13 <NikolajK> where do I define it for it to be top-level?
05:09:43 <pavonia> Do you know how to define functions?
05:09:55 <pjdelport> darthdeus: No reason other than that's what Traversable was designed to capture.
05:10:15 <pjdelport> darthdeus: Traversable without Functor is more or less Foldable
05:10:20 <bennofs> darthdeus: every Traversable can be made a Functor
05:10:39 <darthdeus> pjdelport: why? all Traversable functions require an Applicative
05:10:46 <l0cust> Any ideas?
05:10:56 <darthdeus> bennofs: you mean that you can use traverse to define fmap?
05:11:06 <pavonia> NikolajK: Top-level means somewhere in your module, but not in a let- or where-block
05:11:09 <bennofs> darthdeus: yeah, just traverse with the Identity applicative
05:11:31 <bennofs> @hoogle fmapDefault
05:11:33 <darthdeus> but what is then enforcing that `traverse` doesn't change the shape?
05:11:33 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
05:11:37 <quchen> :t \f -> runIdentity . traverse (Identity . f)
05:11:38 <lambdabot> Traversable t => (a -> b) -> t a -> t b
05:11:50 <arianvp> When would one use Reader instead of just simply passing the parameter?
05:11:52 <darthdeus> it seems that the functor laws should kind of do that
05:12:01 <darthdeus> at least i think i've read that somewhere
05:12:02 <darthdeus> but not sure
05:12:09 <arianvp> I got this API where you need to pass a Handle to every function. should I use reader?
05:12:32 <arianvp> i'm scared it will just confuse people. nvm
05:12:38 <pavonia> arianvp: When you get annyed of passing that parameter to all functions that need it
05:12:44 <pavonia> *annoyed
05:12:46 <quchen> arianvp: Reader is mostly useful if you have a transformer stack. When you only have ReaderT IO, then you'll trade the explicit parameter passing with lots of liftIOs, so it's not really worth it.
05:13:20 <merijn> quchen: You can just use the "r ->" instance of reader...
05:13:21 <l0cust> If anyone is interested, the fix is to put the sandbox into the path, rather than the build dir
05:13:56 <quchen> merijn: That's even more confusing since "ask" is implicit
05:14:15 <quchen> darthdeus: The Traversable laws guarantee certain shape properties.
05:14:47 <quchen> For example, `traverse Identity = Identity` is a law. (From that follows that my "fmap" implementation above actually defines a Functor.)
05:15:14 <pjdelport> darthdeus: To make clearer what i said earlier about sequence, you know how foldr (:) [] is the identity fold for lists?
05:15:20 <pjdelport> :t foldr (:) []
05:15:21 <lambdabot> [a] -> [a]
05:15:51 <pjdelport> Now, consider:
05:15:51 <pjdelport> :t foldr (liftA2 (:)) (pure [])
05:15:53 <lambdabot> Applicative f => [f a] -> f [a]
05:16:51 <pjdelport> That's the same as the identify fold, except that instead of replacing each constructor with an application of itself, you're replacing each constructor with the *lifted* application of itself.
05:17:38 <pjdelport> darthdeus: So in a literal sense, you can think of it as moving the constructor applications from outside the functor to inside it.
05:18:38 <pjdelport> Traversable's traverse / sequenceA just generalizes this idea from lists to any (Traversable) structure.
05:24:41 <darthdeus> pjdelport: hmm that's really good, thanks :)
05:24:59 <darthdeus> quchen: there are no traversable laws in the documentation though
05:25:37 <darthdeus> quchen: and there are laws for Functor, which is why I assumed that the laws for Traversable can be derived from the Functor
05:25:39 <quchen> darthdeus: Sure there are
05:26:01 <quchen> Six of them, in the docs of "class Traversable ...".
05:26:07 <quchen> Three for traverse, three for sequence.
05:26:10 <darthdeus> oh lol
05:26:20 <darthdeus> my local docs are broken
05:26:32 <darthdeus> well not broken but for base 4.6
05:26:44 <darthdeus> which does not mention them :P https://hackage.haskell.org/package/base-4.6.0.0/docs/Data-Traversable.html
05:27:27 <NikolajK> can someone tell me in what sense applicative is a special case of monad? what are the ingrediences you put together in a monad, which gives you the applicative map f(a->b)->fa->fb?
05:27:29 <quchen> Hmm, odd.
05:27:56 <quchen> NikolajK: It's the other way round, Monad is a special case of Applicative.
05:28:08 <quchen> Namely, Monad is an Applicative that also has a "join" or ">>=" function.
05:28:40 <quchen> And you can write (<*>) in terms of those (and return).
05:28:47 <mbrock> @src ap
05:28:47 <lambdabot> ap = liftM2 id
05:28:53 <mbrock> :t ap
05:28:54 <lambdabot> Monad m => m (a -> b) -> m a -> m b
05:29:03 <darthdeus> quchen: http://www.haskell.org/pipermail/libraries/2012-October/018706.html hmm
05:29:46 <quchen> darthdeus: Yeah the base 4.6 docs are a bit fuzzy. I can't tell whether the laws follow from the documentation there, but they certainly are not very explicit in any case.
05:29:59 <pjdelport> NikolajK: The hierarchy is basically that Functor gives fmap, Applicative adds pure and <*> (or return and ap), and Monad adds join (or (>>=), which is just fmap and join together)
05:30:07 <NikolajK> :t liftM2
05:30:08 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:30:18 <NikolajK> :t id
05:30:20 <lambdabot> a -> a
05:30:22 <NikolajK> how can you pass id to that?
05:30:31 <quchen> ($) = id
05:30:36 <quchen> … with a specialized type
05:30:42 <quchen> So maybe "liftM2 ($)" is clearer
05:30:56 <quchen> liftM2 f mx my = do { x <- mx; y <- my; return (f x y) }
05:31:09 <NikolajK> ($) is when you want to write f $ x as ($) f x, right?
05:31:42 <dario> yep
05:32:04 <quchen> ($) is function application with very low precedence. For example `f . g . h x` is `f . g . (h x)` because "space" binds very tightly. On the other hand, ($) binds very loosely, so `f . g . h $ x` means `(f . g . h) x`.
05:32:25 <quchen> And using ($) you can pass "apply this function" as a parameter, which is what happens with "ap".
05:33:02 <quchen> liftM2 f mx my = do { x <- mx; y <- my; return (f x y) }   ⇒   liftM2 id mf mx = do { f <- mf; x <- mx; return (if f x) }
05:33:03 <arianvp> I'm porting elm-html to haskell :D
05:33:10 <quchen> s/if/id/
05:33:30 <arianvp> http://lpaste.net/108421 :D
05:36:33 <chaosmasttter1> :t id
05:36:34 <lambdabot> a -> a
05:38:00 <NikolajK> na, I don't see it. What is "liftM2 id"
05:38:16 <NikolajK> I've seen liftM2 (+) before, but that is binary
05:38:53 <quchen> I just wrote it down above. So let's do it again. The source of "liftM2" is this:
05:38:53 <quchen> liftM2 f mx my = do { x <- mx; y <- my; return (f x y) }
05:39:03 <quchen> Now insert "id" for "f". You'll get
05:39:08 <quchen> liftM2 id mx my = do { x <- mx; y <- my; return (id x y) }
05:39:23 <NikolajK> > id 1 2
05:39:25 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
05:39:25 <lambdabot>    arising from the ambiguity check for ‘e_112’
05:39:25 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
05:39:25 <lambdabot>    bound by the inferred type for ‘e_112’:
05:39:25 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
05:39:27 <quchen> In the "return", you can now apply the "id". This gives you
05:39:30 <quchen> liftM2 id mx my = do { x <- mx; y <- my; return (x y) }
05:39:59 <quchen> This applies x to y. For this to work x has to be a function of course.
05:40:18 <quchen> Or type-wise, you've got
05:40:19 <quchen> :t liftM2
05:40:20 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:40:46 <quchen> Now insert "id" as the first parameter. The first parameter is, with explicit parentheses, (a1 -> (a2 -> r)).
05:41:19 <NikolajK> so because of automatic currying, there are no proper binary functions to begin with, and if you code stuff like that then the type inference restricts what you do and says "okay, if you do that then the arugment must be of function type"
05:41:20 <quchen> So when you insert "id" there, which has type "a -> a", it unifies if "a1 = a2 -> r".
05:41:27 <quchen> So then you end up with
05:41:41 <quchen> liftM2 id :: Monad m => m (a2 -> r) -> m a2 -> m r
05:42:37 <pjdelport> It's worth nothing that id makes a perfectly good ($) too.
05:42:41 <pjdelport> > negate `id` 5
05:42:43 <lambdabot>  -5
05:42:44 <quchen> :t [id, ($)]
05:42:45 <lambdabot> [(a -> b) -> a -> b]
05:43:00 <NikolajK> does the computer literally see that, because I passed id, the resulting type equates a1 and a2 -> r?
05:43:01 <pjdelport> :t id `asTypeOf` ($)
05:43:02 <lambdabot> (a -> b) -> a -> b
05:43:16 <NikolajK> I mean does it do this computation and recalculates the type
05:43:29 <pjdelport> (a -> b) -> (a -> b) is just a special case of id
05:43:49 <quchen> NikolajK: The type inference algorithm does something like that, yes. It's called unification, which means "see how these types can be made compatible".
05:44:00 <pjdelport> You can think of id f x or f `id` x as id just returning f, which then still gets applied to x as before.
05:44:20 <quchen> So if you have "id :: a -> a" and you want to apply it to "foo :: Int", the type inference algo has to find out that "a = Int" is the best choice here.
05:44:46 <amf> is there a function to convert a hex string to int?
05:44:55 <quchen> A parser?
05:45:01 <witek> Hi. I'm new here ;). I want to make an interactive app that allows user to create and modify points that defines curve. I found Gloss package and I think it fits my needs, but I'm still a bit confused... Any suggestions?
05:45:56 <mmmm> yes amf there is.. let me remember
05:45:57 <amf> im using n <- read <$> many1 hexDigiti; fromIntegral n; but just learned that isnt right
05:46:23 <NikolajK> the accounts for Applicative always speak of monodial categories, i.e. ones with product. Meanwhile the type f(a->b)->fa->fb only concernes function spaces. Do I have to do a lot of exp-prod-adjunction business to see why the "lax monodial functor" thingy is what we deal here? is that hard to see?
05:46:53 <quchen> amf: If you're using Parsec, it has a "hexadecimal" parser in the tokenizer.
05:47:46 <quchen> NikolajK: Oh, Applicative's functions are a bit different than what you'd expect from mathematics. There is an alternative formulation of Applicative that is harder to program with, but it's closer to math.
05:48:07 <quchen> unit :: Applicative f => f (); a ** b :: Applicative f => f a -> f b -> f (a,b)
05:48:20 <quchen> You can write "pure" and "<*>" in terms of those, and vice-versa.
05:48:34 <quchen> I think Typeclassopedia speaks about those a little more
05:48:37 <quchen> @where typeclassopedia
05:48:37 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
05:49:52 <quchen> NikolajK: Similarly, Monad doesn't look like the mathematical monad because >>= is convenient to program with. You can write the mathematical "µ" function in terms of that. In the standard lib it's called "join".
05:50:02 <amf> quchen: the docs say the number should be prefixed with 0x, but that won't be in my case
05:50:02 <quchen> :t join -- = µ
05:50:04 <lambdabot> Monad m => m (m a) -> m a
05:50:58 <NikolajK> wait
05:51:21 <NikolajK> there is a difference between "different things are used" and "different primitives are used"
05:51:37 <NikolajK> I thought you mean the former, but >>= is perfectly find with mathematical monads too
05:52:21 <quchen> Oh, I misunderstood then. Let me try to say it differently, "Haskell uses Applicative/Monad in their meanings equivalent to the mathematical ones, but chooses a more convenient API".
05:57:56 <NikolajK> I find the symbol <*> a little strange. It feels like it's trying to suggest the input types on the left and right hand side would be the same
05:58:14 <mmmm> amf: Prepend 0x then?
05:58:15 <NikolajK> while the left side is must more functiony
05:58:36 <darthdeus> I guess the best way to get a canonical answer is SO :P http://stackoverflow.com/questions/25037098/can-the-traversable-laws-be-derived-from-the-fact-that-every-traversable-is-also
05:58:51 <quchen> NikolajK: It makes more sense when you add *> and <* to the mix. The arrow points in the direction of the result you want to keep.
05:59:03 <quchen> a <* b -- executes both a and b, but keeps only a's value
05:59:09 <quchen> a *> b -- same but keeps b instead of a
05:59:20 <quchen> a <*> b -- keeps both results (applying the first to the second)
06:00:39 <pjdelport> The choice of only (>>=) instead of join as primitive in the Monad class does have some practical problems, if i understand it right.
06:01:22 <bartavelle> Couldn't match type IPAddress4 with IPAddress IPv4
06:01:29 <bartavelle> in the module where this is defined : data instance IPAddress IPv4 = IPAddress4
06:01:53 <bartavelle> is there something I am doing wrong ? why doesn't it resolve the type operator thingie ?
06:01:55 <NikolajK> the type of >>= is "diagonal" —I bet that's one of the reasons people don't understand monads so well
06:02:01 <quchen> pjdelport: That wasn't the reason I think. It's that >>= is really more practical since you're "piping" more than you're "flattening". *Right now* join has a couple of problems because of the roles mechanism in GHC, but that's not something that was around back then.
06:02:09 <pjdelport> Namely that it forces a stricter order of evaluation on ap / liftM* than <*> / liftA* does.
06:02:49 <quchen> I don't think Applicative was around either when monads were introduced.
06:03:01 <quchen> (Hence the whole Applicative =/=> Monad chaos)
06:03:17 <NikolajK> I just came across a paper on Applicative, presenting it as a new idea seeminly, in 2008
06:03:24 <NikolajK> is that possible?
06:03:39 <quchen> Maybe not 2008, but somewhere in the 2000s wouldn't surprise me
06:03:53 <k00mi> yes, Applicative is rather fresh
06:03:54 <NikolajK> Monads where part of Haskell more or less from the start, as I understand
06:04:16 <k00mi> not from the very beginning, but for a long time
06:04:17 <quchen> NikolajK: Not from the very beginning, but they made it in comparatively early.
06:04:24 <quchen> IO without monads is *awkward*.
06:04:51 <k00mi> bartavelle: can you show us the entire code?
06:05:11 <bartavelle> k00mi, I suspect it's a linking problem of some sort, when I'll cabal clean first
06:05:31 <bartavelle> yes that fixed it
06:05:37 <bartavelle> thanks ;)
06:05:46 <k00mi> heh, ok
06:06:08 <Darwin226> Hey guys. There was a moderate interest last time I posted that I was making a VS integration package for haskell. Here's my current progress: http://i.imgur.com/IIPnB7l.png
06:06:40 <Darwin226> You can see syntax highlighting (very quickly done, comments don't work yet), type checking with quickinfo, error reporting and a GHCi window
06:07:28 <NikolajK> fmap (g *** h) (u ** v) = fmap g u ** fmap h v
06:07:29 <NikolajK> I think that's a typo in the typeclassopedia entry
06:07:50 <quchen> Where?
06:07:59 <quchen> (f *** g) (x,y) = (f x, g y)
06:08:07 <quchen> ** is the "alternative Applicative operator"
06:08:19 <pjdelport> NikolajK: The introduction of Applicative to Haskell was relatively recent, yes, and AIUI motivated in part because of inefficiencies due to the excessively strict ordering I was talking about above.
06:08:42 <pjdelport> NikolajK: In the context of applicative parsers, particularly.
06:10:10 <NikolajK> k
06:16:23 <prooftechnique> Is there a way to reduce the fromByteString noise when using blaze-builder?
06:19:54 <bartavelle> http://lpaste.net/108423 doesnt type checks for me, No instance for (Num (Foo String)) arising from the literal 12
06:20:03 <bartavelle> isn't it supposed to work ?
06:20:32 <bartavelle> if I explicitely say 12 is an Int, I get "Couldn't match expected type Foo String with actual type Int"
06:21:59 <k00mi> bartavelle: I think you want a type family, not a data family
06:22:15 <bartavelle> yes .. I want a type family :)
06:22:18 <bartavelle> thanks !
06:23:02 <k00mi> the way you wrote it Int is a new data contstructor
06:23:06 <k00mi> no problem :)
06:23:12 <bartavelle> OIC
06:23:17 <bartavelle> I'll read some docs
06:23:22 <bartavelle> thanks a lot
06:24:02 <k00mi> it's always a good idea to read docs, especially with fancy new extensions ;)
06:25:28 <quchen> Wait, there are data families and type families?
06:25:37 <quchen> I thought those were synonyms
06:26:35 <bennofs> quchen: yes, data families force you to create a new data type for each instance
06:27:27 <bennofs> quchen: data families allow this: data instance Foo Int = FooInt Int | FooInt2 Integer
06:27:28 <quchen> Ah, so data declared by data family instances can only be created by those means
06:27:54 <quchen> Uh okay, that's confusing. I should read up on that.
06:28:43 <bennofs> quchen: the advantage is that data families are injective, i.e. if F a ~ F b, then a ~ b, iirc
06:29:40 <k00mi> right, singletons makes great use of a data family :)
06:31:09 <quchen> Singletons as in Foo :: "Hello"?
06:32:04 <k00mi> the singletons library
06:38:47 <arianvp> :)
06:39:10 <rwbarton> not only are they injective, but they are genuine type constructors -- you can use F as an argument to another type constructor, or write a type class instance for F
06:54:16 <Guest50631> hey guys, I have some question around TyDD
06:55:00 <Guest50631> So basically my question is coming from TDD, and personally I have love-hate relationship with TDD
06:55:30 <bernalex> Guest50631: uh, what *is* the question?
06:56:47 <Guest50631> most of the time I dont see my design is driven from TDD, but some times when I like to write test first just to get initial context, and question is does TyDD asks you write types first amndatory?
06:57:37 <Guest50631> how much is it help? How many of our haskell community foollow TyDD on daily basis?
06:57:50 <bernalex> what is TyDD?
06:58:03 <Guest50631> Type driven development?
06:58:44 <bernalex> I write types first, then documentation for what the function will do, then the function itself. then I play with it in ghci. then, if appropriate, I add a test for it.
06:58:45 <pjdelport> Guest50631: I don't think there's anything formal enough to talk about following it or not.
06:58:52 <pjdelport> That style certainly arises, though.
06:59:50 <quchen> ♥ holes
06:59:51 <quchen> > runState _oh_my_got_what_do_I_put_here "hello"
06:59:53 <lambdabot>  Found hole ‘_oh_my_got_what_do_I_put_here’
06:59:53 <lambdabot>    with type: Control.Monad.Trans.State.Lazy.State [GHC.Types.Char] a
06:59:53 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
06:59:53 <lambdabot>             the inferred type of it :: (a, [GHC.Types.Char]) at Top level
07:00:09 <quchen> "Got"... oh well.
07:00:34 <quchen> Anyway, type driven development is more of a guideline than an actual way to write everything.
07:00:38 <Guest50631> pjdelport: that's sound good
07:01:46 <Guest50631> quchen: :) nice
07:01:48 <latk> Is there some way to use attoparsec to scan through any text, until a parser matches ?
07:04:40 <bernalex> hm. is there some nice list of all ghc pragmas?
07:04:53 <mbrock> I've never heard of "TyDD" as a definite thing, but designing modules to have sensible & clear types certainly makes everything better
07:05:27 <bernalex> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html is much too verbose & outdated
07:05:53 <bernalex> mbrock: never heard the expression TyDD, but I definitely develop in a type-driven fashion. I always write types first.
07:06:51 <mbrock> yeah, I tend to use tons of typed `where` clauses (or helper functions) just to get more clarity re: types of intermediate values
07:06:52 * hackagebot yesod-form 1.3.14 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.14 (MichaelSnoyman)
07:06:54 * hackagebot yesod-core 1.2.19 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.19 (MichaelSnoyman)
07:07:25 <mbrock> and if the meaning of a function isn't clear from the name and its type signature, I try hard to make it that way
07:11:41 <mbrock> often the implementation of a function seems like a detail, and I often wish GHC could just infer the correct expression :)
07:11:53 * hackagebot resourcet 1.1.2.3 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-1.1.2.3 (MichaelSnoyman)
07:13:01 <dcoutts> mbrock: try agda :-)
07:13:16 <agatam> mbrock: really sounds like you should play with Agda or Idris sometime ;P
07:14:07 <mbrock> yeah, I took Ulf Norell's course at Chalmers :)
07:14:16 <supki> bernalex: ghc --supported-languages
07:14:29 <mbrock> and wrote some Agda proofs for my abstract algebra class
07:14:37 <mbrock> very fun indeed!
07:15:04 <mbrock> never really looked at Idris though
07:16:01 <agatam> it seems to a bit more about programming rather than proving (but still with dependent types)
07:16:33 <agatam> *to be a bit
07:16:47 <mbrock> yeah, I never actually executed a single Agda program, I think
07:18:31 <bernalex> supki: preferably something in between. with a line or two of description.
07:19:33 <mbrock> does Idris have actual tactics, like "auto" in Coq?
07:20:45 <darthdeus> this is probably a dumb question, but how can i use fmapDefault to define a Functor for a Traversable, when the Traversable itself must already be a Functor?
07:21:17 <agatam> well, it has tactics (http://eb.host.cs.st-andrews.ac.uk/Idris/theorems.html#Tactics) but I'm not exactly sure how sophisticated they are. what it does have for sure is space invaders implementation (playable!) :P
07:22:47 <k00mi> mbrock: you might want to join #idris and ask there
07:23:03 <supki> darthdeus: instance Functor X where fmap = fmapDefault; instance Traversable X where ...
07:23:17 <darthdeus> supki: oh lol didn't realize that would work :X
07:28:37 <darthdeus> supki: though I still need to define the Applicative instance myself, right?
07:30:13 <supki> darthdeus: I don't think you need Applicative for X to be Traversable
07:30:34 <supki> only Functor and Foldable
07:31:36 <darthdeus> supki: yeah but you need Applicative to actually use `traverse`
07:32:41 <darthdeus> oh shit no
07:32:47 <darthdeus> i'm just doing it wrong
07:41:55 <sdx23> hi. I can't find the definition of (:) in hoogle - why is this and where can I find it?
07:43:14 <mbrock> sdx23: it's actually syntax, so you'll find it in the language standard
07:43:25 <mbrock> eh, I think?
07:43:59 <Exio> @ty (:)
07:44:00 <lambdabot> a -> [a] -> [a]
07:44:40 <mbrock> I think it counts as syntax and not a regular operator because you can use it in patterns
07:45:21 <mbrock> ...and because the other parts of the list type, i.e., the type syntax [a] and the nil syntax [] are both special
07:46:10 <HexSquid> :q
07:46:14 <HexSquid> lol
07:46:25 <HexSquid> habit
07:46:32 <merijn> mbrock: In fact, you are allowed to have operator constructors
07:46:39 <Exio> @let data Something a b = a :~<: b
07:46:41 <lambdabot>  Defined.
07:46:48 <merijn> mbrock: The report defines : as 'uppercase' operator symbol
07:46:59 <merijn> mbrock: So any operator starting with : is actually an infix data constructor
07:47:19 <merijn> > 1 :~<: 'c' -- as shown by Exio
07:47:20 <lambdabot>  No instance for (GHC.Show.Show (L.Something a0 GHC.Types.Char))
07:47:21 <lambdabot>    arising from a use of ‘M169108967410229068730426.show_M1691089674102290687...
07:47:21 <lambdabot>  The type variable ‘a0’ is ambiguous
07:47:21 <Exio> @let something-take-a x :~<: _ = x
07:47:21 <lambdabot>  Note: there are several potential instances:
07:47:21 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
07:47:22 <lambdabot>  Parse failed: Parse error in pattern:
07:47:22 <merijn> aww
07:47:24 <merijn> duh
07:47:29 <merijn> @undefine
07:47:29 <lambdabot> Undefined.
07:47:41 <merijn> @let data Something a b = a :~<: b deriving (Show)
07:47:42 <lambdabot>  Defined.
07:47:48 <Exio> ew! :P
07:47:49 <merijn> > 1 :~<: 'c'
07:47:51 <Exio> but yeah
07:47:51 <lambdabot>  1 :~<: 'c'
07:47:54 <mbrock> good point, but (:) is not exported as a regular Prelude constructor, right? presumably because such a data type would also need to have a [] constructor
07:47:58 <merijn> :t 1 :~<: 'c'
07:48:00 <lambdabot> Num a => Something a Char
07:48:06 <Exio> :t ([])
07:48:07 <lambdabot> [t]
07:48:14 <merijn> mbrock: You're right that just a "bare" : is special
07:48:27 <merijn> I just wanted to point out that you could define operator constructors :)
07:48:45 <mbrock> yeah, and pattern match on them too just like you pattern match on x:xs :)
07:48:45 <Exio> you could use a normal constructor with ´´
07:49:42 <sdx23> mbrock: ah, i see. So I'll have to look in the haskell98-report.
07:49:50 <merijn> sdx23: For all practical purposes (:) is defined as "data [] a = [] | a : ([] a)"
07:50:26 <sdx23> merijn: yeah, I was searching for the "infixr p" where p is the priority (not directly clear)
07:50:27 <merijn> It's just that the syntax doesn't allow you to define that type yourself, it's identical too "data List a = Nil | Cons a (List a)", though
07:50:42 <klzzvn> haskell newb here, trying to install Leksah in cabal sandbox... it fails with this error: Configuring webkitgtk3-0.12.6.1... setup: The pkg-config package webkitgtk-3.0 version >=1.8 is required but it could not be found.
07:50:47 <merijn> sdx23: Oh, you can query fixity in ghci
07:50:49 <klzzvn> any idea what to do?
07:51:01 <sdx23> merijn: ah, didn't know that.
07:51:04 <merijn> sdx23: ":i (:)"
07:51:11 <merijn> sdx23: Prints fixity, amongst other things
07:51:14 <sdx23> merijn: nice, thanks.
07:51:22 <merijn> sdx23: If it doesn't print fixity it means "default", which is infixl 9
07:51:58 * hackagebot profunctors 4.2.0.1 - Profunctors  http://hackage.haskell.org/package/profunctors-4.2.0.1 (EdwardKmett)
07:52:19 <sdx23> merijn: this sure helps, thanks a lot (also to mbrock)
07:53:09 <dv-> klzzvn: it's not finding webkit
07:53:09 <supki> klzzvn: cabal does not install non-haskell dependencies, so you need to install webkitgtk-3.0 separately via your system package manager
07:54:15 <klzzvn> dv- supki: ah, i see... thanks, will dig some more :)
07:54:53 <cryon> There seems to be a couple of SDL2 bindings around, if you have any experience SDL in haskell, which lib would you recommend?
07:56:13 <cryon> I jjust poked around a bit with Lemmih's hsSDL2 lib (on github) and while the lib seems okey, the examples where out of date and it's not yet released to hackege as far as I can tell
07:59:24 <rufs> lets say you have a list of functions [func1 . func2, func1 . func3, func1 . func4] would it be better or worse to write it like (func1 .) <$> [func2, func3, func4] instead?
08:03:43 <Cale> rufs: I guess it depends? It shouldn't hurt. I'd probably just use map instead of <$>
08:04:24 <rufs> hm and you mean map and not fmap?
08:04:33 <Cale> well, fmap for lists is called map
08:04:46 <Cale> :t map
08:04:47 <lambdabot> (a -> b) -> [a] -> [b]
08:05:02 <rufs> yeah, but I got the impression you should prefer fmap
08:05:08 <Cale> map (func1 .) [func2, func3, func4]
08:05:50 <Cale> If the goal is to be more general, you might prefer fmap sometimes, but in this case, we know which instance it is
08:05:59 <Cale> We could actually replace (.) with fmap as well
08:06:07 <Cale> But I'm not sure it helps clarity
08:06:11 <sdx23> When would I use "const"? (in Prelude)
08:06:17 <aarvar> or we could redfine (.) as fmap
08:06:22 <shachaf> If Cale had his way, you would write fmap fmap fmap func1 [func2, func3, func4]
08:06:31 <Cale> > (fmap . fmap) func1 [func2, func3, func4]
08:06:33 <lambdabot>  can't find file: L.hs
08:06:49 <Cale> If I had my way?
08:07:15 <shachaf> fmaps everywhere
08:07:20 <shachaf> It is not really your way.
08:07:26 <mbrock> sdx23, here's a silly example: modifyTVar (const 1) v
08:07:50 <mbrock> sdx23: or traverse (const 1), to replace all nodes in a structure with a constant 1...
08:08:19 <Cale> :t (\f g -> (fmap . fmap) f [g,g,g])
08:08:20 <lambdabot> Functor f => (a -> b) -> f a -> [f b]
08:08:30 <mbrock> sdx23: any time you need a function that ignores its argument and gives some particular value back
08:09:02 <Cale> :t (\f g -> (map . (.)) f [g,g,g])
08:09:03 <lambdabot> (b -> c) -> (a -> b) -> [a -> c]
08:09:12 <mbrock> sdx23: you can of course just write (\_ -> 1), but const is easier to type, and a clear signal that you're doing some ignoring
08:09:19 <sdx23> mbrock: ah, ok. So in the end it's only sensible in higher order context, i see. I was thinking of something like "when you get back two results and care only about one - but you can't get back two results"
08:09:22 <rufs> so many choices :p
08:09:48 <Cale> [f . g | g <- [g1,g2,g3]]
08:09:52 <sdx23> mbrock: makes sense, thanks.
08:10:17 <Cale> There's always the list comprehension option :)
08:10:32 <Cale> That's quite likely to be among the clearest?
08:12:35 <rufs> hm
08:14:44 <YurasShumovich> Hello
08:15:10 <YurasShumovich> is it possible to make cabal use different ghc when compiling custom Setup.hs?
08:15:10 <Cale> hi!
08:15:12 <yitz> rufs: our motto is: There's More Than One Way To Do It But Not As Many As In Perl And Each Way Actually Makes Sense
08:15:23 <YurasShumovich> because I'm crosscompiling
08:16:23 <aarvar> I think the clearest would be let foo f = f (foo f) in (\f g -> (foo (\_ -> fmap)) (f .) [g, g, g])
08:16:44 <Cale> YurasShumovich: I honestly have no idea, but perhaps you can compile Setup.hs by hand?
08:17:24 <rufs> I think I need to start reading code from some other haskell projects
08:17:36 <rufs> to get a better feeling for whats a good style and whatnot
08:17:39 <Cale> aarvar: hehe
08:18:21 <yitz> YurasShumovich: there is this option to cabal install: --with-ghc=PATH but i don't know how that works with a custom Setup.hs
08:42:19 <mmmm> I love types but I wish I knew how to express myself better
08:46:01 <aarvar> What's the point of the Reader type, why not just use a normal function?
08:46:30 <zereraz> hello people, is there a function that counts the number of digits of a number?
08:46:48 <aarvar> that would be mod
08:47:23 <hiptobecubic> you mean log?
08:47:41 <zereraz> like input 12341 output 5
08:47:44 <aarvar> oh boy im tired
08:48:27 <zereraz> I can do with mod
08:48:33 <zereraz> ok fine
08:48:34 <zereraz> thanks
08:48:45 <josephle> zereraz: http://hackage.haskell.org/package/digits-0.1/docs/Data-Digits.html
08:48:55 <josephle> if you don't want to roll your own :)
08:49:20 <Ankhers> > length $ show 12345
08:49:22 <lambdabot>  5
08:49:26 <zereraz> I actually have made my own
08:49:32 <zereraz> josephle: thanks
08:49:41 <zereraz> Ankhers: thanks, that is smart
08:50:19 <Ankhers> zereraz: Haskell makes things easy to do.
08:50:40 <zereraz> Ankhers: yeah :)
08:50:47 <k00mi> horribly inefficient though
08:50:51 <Ankhers> fact
08:51:27 <enthropy> aarvar: probably it's clearer if you use ask and return instead of id and const
08:51:49 <k00mi> aarvar: you don't have to pass the value around by hand everywhere
08:52:14 <aarvar> k00mi: you dont have to with normal functions, they're monads too
08:52:47 <aarvar> I think
08:52:48 <aarvar> idk
08:53:07 <k00mi> oh, that's what you mean
08:53:08 <enthropy> aarvar: there's no equivalent of ReaderT without the newtype though
08:53:09 <k00mi> yes, they are
08:53:28 <aarvar> Yeah I realize that
08:54:32 <enthropy> so in some sense it's simpler to have type Reader = ReaderT Identity; than type Reader = (->)
08:55:02 <aarvar> I suppose so
08:57:08 * hackagebot monad-gen 0.2.0.0 - A simple monad for generating fresh integers  http://hackage.haskell.org/package/monad-gen-0.2.0.0 (jozefg)
09:06:25 <tib> Is haskell any good for making love?
09:07:11 <quchen> Go away.
09:07:26 * hackagebot monad-gen 0.2.0.1 - A simple monad for generating fresh integers  http://hackage.haskell.org/package/monad-gen-0.2.0.1 (jozefg)
09:09:00 <jlouis> Fuuzetsu: pong? :)
09:09:11 <TheKing444> ping
09:09:14 * TheKing444 pings
09:09:29 <jlouis> TheKing444: TTL for this one is around 24 hours, so ...
09:10:03 <jlouis> Might even be a misprod, so to speak
09:12:26 * hackagebot monad-gen 0.2.0.2 - A simple monad for generating fresh integers  http://hackage.haskell.org/package/monad-gen-0.2.0.2 (jozefg)
09:17:27 * hackagebot keystore 0.5.0.3 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.5.0.3 (ChrisDornan)
09:17:44 <TheKing444> Oh, secret things.
09:18:24 <tib> quchen
09:18:30 <tib> r u a nig
09:18:45 <DarkTiger> @botsnack
09:18:45 <lambdabot> :)
09:18:58 <quchen> ?where ops
09:18:58 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
09:19:00 --- mode: ChanServ set +o geekosaur
09:19:05 --- mode: geekosaur set +b *!*alex@162.221.200.*
09:19:05 --- kick: tib was kicked by geekosaur (tib)
09:19:13 --- mode: geekosaur set -o geekosaur
09:22:29 * hackagebot monad-gen 0.2.0.3 - A simple monad for generating fresh integers  http://hackage.haskell.org/package/monad-gen-0.2.0.3 (jozefg)
09:22:29 <joelteon> not to be confused with tibbe
09:22:46 <ion> Yes, monad-gen is easy to confuse with him.
09:23:16 <joelteon> I'm sure he gets that all the time.
09:23:26 <joelteon> "cabal install monad-gen" "I didn't know he was on Hackage."
09:35:40 <Fuuzetsu> jlouis: you here?
09:36:39 <TheKing444> Who needs help haskell'in in here?
09:41:48 <jlouis> Fuuzetsu: yeah
09:42:10 <Fuuzetsu> jlouis: talk to me about combinatorrent
09:42:14 <Fuuzetsu> is it abandoned?
09:42:18 <jlouis> More or less
09:42:34 <jlouis> It was a fun experiment, but I'm not really working on it anymore
09:42:46 <Fuuzetsu> are there many known problems? are all the known problems listed on GitHub issues?
09:42:56 <jlouis> Likewise for its sister-project etorrent
09:43:03 <Fuuzetsu> are there any benchmark numbers up anywhere? I remember watching a video with something like this few years back
09:43:19 <jlouis> Well, it performed quite well at the time
09:43:25 <Fuuzetsu> mhm
09:43:26 <Fuuzetsu> are there things you would do differently now?
09:43:38 <jlouis> But nowadays there is a new I/O manager so a lot of the code should be able to go away
09:43:44 <Fuuzetsu> ah
09:44:04 <jlouis> Iteratees or something like that would definitely be a way to get around stuff
09:44:26 <jlouis> The approach is messaging. You might want to try out one based on STM
09:44:42 <Fuuzetsu> I'm planning to write a torrent client that I'd actually use, would you recommend combinatorrent as something to look at or even as a base?
09:45:12 <jlouis> Some of the ideas in it are rather sound, but do note it is Haskell from 3-4 years ago
09:45:17 <jlouis> lots of stuff happen in that time frame
09:45:39 <jlouis> And I don't do too much Haskell these days, so it is hard to say exactly what is missing in it :)
09:45:57 <Fuuzetsu> hm
09:46:09 <Fuuzetsu> is there any reading/watching material beyond what's listed on the GitHub page?
09:46:20 <jlouis> Not really
09:46:35 <jlouis> The Bittorrent spec is rather straightforward though
09:46:45 <jlouis> The only hard part is how to handle choking
09:47:32 <hiptobecubic> choking?
09:47:34 <Fuuzetsu> hard because you couldn't figure out how to do it in general or hard because you couldn't figure out how to do it well in Haskell?
09:48:31 <The_other_cat> Hi there. I have a function "deep" which leads to ambigous occurence since there is another function "deep" imported from another Module. I know how to import using qualified names, but can i also enfore the usage of the local definition of the function "deep"?
09:48:48 <bb010g> Fuuzetsu: What directory is your config in under yi-contrib?
09:48:56 <Fuuzetsu> none
09:49:05 <Fuuzetsu> I have my config in a github repository though
09:49:09 <triliyn> The_other_cat: import OtherModule hiding (deep)
09:49:23 <triliyn> import qualified OtherModule
09:49:25 <Fuuzetsu> haven't hacked on Yi for a month or two though so no idea if it's up to date (it should)
09:49:38 <Fuuzetsu> bb010g: https://github.com/Fuuzetsu/yi-config/blob/master/yi.hs
09:53:35 <jlouis> Hard because it is not really documented that well
09:54:13 <jlouis> hiptobecubic: choking is a concept in bittorrent. You have maybe 40 TCP connections, but you only choose a few, say 6 on which to communicate to avoid too much congestion
09:54:38 <jlouis> the process of denying peers communication is called choking
09:55:14 <hiptobecubic> ah
09:55:15 <joelteon> "cabal install monad-gen" "I didn't know he was on Hackage."
09:55:17 <joelteon> whoops
09:55:21 <joelteon> sorry, wrong pane
09:57:10 <jlouis> https://github.com/jlouis/combinatorrent/blob/master/src/Process/ChokeMgr.hs is the choke manager used in combinatorrent
09:57:40 <jlouis> It is a forkio'ed process which understands messages and reacts on those
09:58:49 <josephle> the bittorrent spec gives a pretty good explanation of all the important concepts, iirc
10:00:07 <Fuuzetsu> the official ‘spec’ seems pretty hand-wavy
10:00:32 <jlouis> josephle: it does! There is also https://wiki.theory.org/BitTorrentSpecification
10:00:42 <jlouis> Fuuzetsu: actually, it is not that handwavy
10:01:02 <jlouis> Once you start implementing it, you will learn that it specifies the absolute minimum required
10:01:11 <jlouis> In the same wasy the TCP spec does
10:01:16 <Fuuzetsu> cool
10:01:29 <jlouis> It is written so deliberately in order to make it possible for clients to act freely
10:01:35 <Fuuzetsu> btw I tried to download an ubuntu iso with combinatorrent yesterday and it failed to parse the announce URL
10:01:49 <jlouis> Doesn't surprise me
10:01:56 <jlouis> BitTorrent is kind of a moving target
10:02:09 <Fuuzetsu> I don't think the bencoding spec changed at all, did it
10:02:18 <jlouis> Also, note that there are extensions to the protocol and the Ubuntu tracker might be different
10:02:28 <jlouis> IIRC there is no DHT implementation in combinatorrent
10:02:37 <Fuuzetsu> right
10:02:38 <jlouis> and if they use DHT or multi-tracker...
10:02:57 <jlouis> etorrent supports both, but it is also a rather rotting project
10:03:31 <jlouis> I ended up with work obligations in Erlang :)
10:03:42 <jlouis> And then the projects kind of stalled a bit
10:03:54 <jlouis> I'd do one in OCaml next I think
10:03:59 <jlouis> on top of Core.Async
10:04:10 * jlouis vanishes for f00d, back later
10:04:19 <Fuuzetsu> well, I want one to be able to use one rather than for the sake of just making one
10:04:20 <Fuuzetsu> alrighty
10:09:00 <RyanGlScott> Why isn't (<**>) defined as flip (<*>)?
10:09:15 <TheKing444> @src (<**>)
10:09:15 <lambdabot> (<**>) = liftA2 (flip ($))
10:09:22 <TheKing444> huh, weird
10:09:37 <TheKing444> @check a <**> b == b <*> a
10:09:38 <lambdabot>  Precedence parsing error
10:09:38 <lambdabot>  cannot mix ‘Control.Applicative.<**>’ [infixl 4] and ‘GHC.Classes.==’ [infix...
10:10:00 <TheKing444> @check (a <**> b) == (b <*> a)
10:10:02 <lambdabot>  Couldn't match expected type ‘f0 a0’
10:10:02 <lambdabot>  with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match expected type...
10:10:10 <k00mi> RyanGlScott: to keep the order of effects in tact probably
10:10:34 <k00mi> you want the first argument to be executed first, but flip would change that
10:10:53 <RyanGlScott> Oh, that makes sense.
10:16:46 <pjdelport> RyanGlScott: A kind-of alternative to <**> would be this newtype: http://lpaste.net/107551
10:17:49 <pjdelport> That wrapper flips the underlying Applicative's effect order / associativity.
10:22:37 <hexagoxel> oh, leksah _does_ compile if you use ghc-7.6.3
10:23:28 <beaky> hello
10:23:33 <hexagoxel> well i guess that that still is the current platform version, but still.. it should be mentioned that 7.8 is not working yet.
10:24:54 <utdemir> Hi. Can anyone tell me a way to convert a String to AttributeValue? I'm using OverloadedStrings, but now I have a string and I can't convert it to AttributeValue.
10:25:11 <utdemir> (Sorry, it's about blaze-html
10:25:30 <quchen> OverloadedStrings is for string literals, not for general "String -> x" conversion.
10:26:04 <utdemir> quchen, Yes, that's the problem. I can't find a way to convert a string to AttributeValue.
10:26:05 <beaky> how do i learn haskell
10:26:28 <boogyman> beaky: by reading and trying
10:28:04 <quchen> utdemir: There are lots of conversion functions here, http://hackage.haskell.org/package/blaze-markup-0.6.1.0/docs/Text-Blaze-Internal.html#g:5
10:28:21 <dfeuer> beaky, most people like the online book Learn You a Haskell for Great Good, but there are plenty of other options.
10:28:43 <quchen> It's an Internal module though, you should probably look for reexports of those functions somewhere.
10:28:55 <prooftechnique> beaky: http://www.seas.upenn.edu/~cis194/
10:29:00 <beaky> im stuck at designing haskell programs
10:29:04 <prooftechnique> byorgey's course is quite good, along with a book
10:29:14 <zereraz> hello can someone tell me what is wrong here http://lpaste.net/108427
10:29:49 <beaky> how do i design programs that have shared mutable state between multiple objects
10:29:49 <ARM9> oh hey it's beaky
10:29:52 <quchen> utdemir: Oh, there's a "ToValue" class in blaze-markup.
10:30:01 <beaky> in another language i would use something like singletons
10:30:07 <utdemir> quchen, stringValue worked
10:30:09 <beaky> or plain global variables
10:30:10 <utdemir> thank you very much
10:30:32 <prooftechnique> zereraz: What's the error?
10:30:40 <quchen> utdemir: You should not use "Internal" modules by third party libraries, those aren't meant for the public.
10:30:42 <zereraz> prooftechnique: error is in paste
10:30:50 <quchen> They're mostly exported so that testsuites etc. can use them.
10:30:53 <prooftechnique> Oh, indentation error
10:31:01 <quchen> The ToValue class looks like the thing you're looking for.
10:31:06 <prooftechnique> Wait, maybe not
10:31:20 <zereraz> prooftechnique: do I need to put an 'in' there
10:31:31 <prooftechnique> Nope
10:31:35 <zereraz> why not
10:31:49 <prooftechnique> let doesn't use in when you're in a do block
10:31:57 <zereraz> prooftechnique: oh, thanks
10:32:04 <dfeuer> beaky, you are talking in OO generalities. That's not usually the way to learn something about Haskell, which is not object-oriented.
10:32:21 <beaky> ah
10:32:31 <beaky> so what should i use instead
10:32:57 <dfeuer> I don't know, beaky, but it usually depends on what you're actually trying to do, rather than the object-oriented conceptualization of what you're trying to do.
10:34:51 <prooftechnique> zereraz: Found it
10:34:57 <prooftechnique> The where isn't indented enough
10:35:17 <zereraz> prooftechnique: I am using where first time, is this the correct indentation
10:35:22 <zereraz> usage*
10:35:51 <prooftechnique> zereraz: The where clause needs to be at the next level of indentation with respect to the block it's a part of
10:36:01 <prooftechnique> Just indent where a little more and you'll get past the parse error
10:36:55 <zereraz> prooftechnique: like 4 spaces?
10:37:05 <prooftechnique> Yeah, that should be fine
10:37:37 * hackagebot Spock-worker 0.2.0.0 - Background workers for Spock  http://hackage.haskell.org/package/Spock-worker-0.2.0.0 (AlexanderThiemann)
10:37:51 <zereraz> prooftechnique: still getting error
10:38:09 <prooftechnique> zereraz: Also, you'll want a $ between reverse and the generator
10:38:35 <zereraz> I am getting not in scope 'pseudoRandomGenerator'
10:40:04 <prooftechnique> zereraz: Try this: http://lpaste.net/108430
10:40:19 <prooftechnique> The not in scope error is just down to a typo
10:40:28 <zereraz> ok got it, the where should be just below
10:40:49 <prooftechnique> Your code says "psudoRandomGenerator" rather than "pseudoRandomGenerator"
10:41:13 <zereraz> I'll change that :P
10:41:34 <zereraz> thanks allot
10:41:39 <prooftechnique> No problem
10:43:29 <yk> warning
10:43:29 <yk>  you may be  watched
10:43:29 <yk> do usa&israel use the internet(facebook,youtube,twitter, chat rooms ..ect)to spy??
10:43:29 <yk> do usa&israel use the internet 2 collect informations,,can we call that spying??
10:43:29 <yk> do they record&analyse everything we do on the internet,,can they harm you using these informations??
10:43:29 <yk> 
10:43:29 <yk> warning
10:44:13 <limepod> pure functions have nothing to hide
10:44:27 <joelteon> which informations?
10:45:00 <yk> warning
10:45:00 <yk>  you may be  watched
10:45:00 <yk> do usa&israel use the internet(facebook,youtube,twitter, chat rooms ..ect)to spy??
10:45:00 <yk> do usa&israel use the internet 2 collect informations,,can we call that spying??
10:45:00 <yk> do they record&analyse everything we do on the internet,,can they harm you using these informations??
10:45:09 <josephle> @ops
10:45:09 <lambdabot> Maybe you meant: pl oeis docs
10:45:23 <josephle> ?where ops
10:45:24 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
10:45:48 --- mode: ChanServ set +o geekosaur
10:45:52 --- mode: geekosaur set +b *!*yk@197.123.76.*
10:45:52 --- kick: yk was kicked by geekosaur (yk)
10:45:57 --- mode: geekosaur set -o geekosaur
10:46:03 <marchelzo_> is there a very simple image creation library for haskell? All I want to do is turn a [[(Int, Int, Int)]] in to an image, where the three ints are RGB values
10:46:45 <quchen> marchelzo_: juicy pixels
10:47:02 --- mode: ChanServ set +o glguy
10:47:15 --- mode: glguy set -o+b glguy *!*@197.123.76.3
10:47:54 <marchelzo_> quchen: thank you. this is exactly what I was looking for :)
10:47:57 <Fuuzetsu> sure is spammy here today
10:48:23 <zereraz> error type signature for pseudoRandomGenerator lacks accompanying binding , http://lpaste.net/108427
10:48:33 * angerman feels stupid now. I've just watched about 2hours of Monadic design Patterns for the web, in the hope to be taken through some real world examples of using monads in webapps :( There were none.
10:49:23 <angerman> After all a monad is just a typeclass, with some added laws. What's the magic special thing? And why are they apparently so hyped?
10:49:43 <beaky> templating engines use monads for the views dsl
10:49:54 <angerman> I feel like I'm missing something very big.
10:50:13 * geekosaur needs to learn how to use chanserv effectively...
10:50:18 <marchelzo_> angerman: i'm with you
10:50:40 * Hodapp sneezes on beaky
10:51:43 <josephle> angerman: that is a good view to take about monads, imo
10:51:47 <angerman> If I do not need dependend computations, monads don't buy me anything over applicative functors. Applicative functors are nice because they provide a generic interface on how to operate on data structures.
10:51:52 <johnw> bitemyapp: heya
10:52:10 <angerman> beaky: hmm. Maybe I should study one of those closer.
10:52:22 <zereraz> prooftechnique: what is wrong with my type in pseudoRandomGenerator http://lpaste.net/108427
10:52:34 <Hodapp> angerman: depended computations?
10:52:42 <angerman> josephle: so there is nothing special?
10:52:56 <josephle> as you say, it's just a typeclass
10:53:01 <Exio> it is just a very abstract thing that all the people loves
10:53:36 <josephle> it allows you to write, as Bob Harper would say, bad looking Algo code :P
10:53:44 <orion> The haskell platform is ridiculously difficult to build on FreeBSD.
10:53:55 <Fuuzetsu> aren't there pre-builts?
10:54:11 <orion> No.
10:54:21 <orion> Not for 2014.
10:55:02 * yogurt_truck is trying to think of a place in his web application codebases where he doesn't use monads
10:55:20 <angerman> Hodapp, well with a functor, you have your computations "in context" already. A monad through bind allows you to use the computation, and channel it into the next one. Say for a Functor F a <*> F b, F b is independend of the computation (or say result) that Fa produces. For a Monad M a >>= M b, M b depends (or better *can* depend) on the computation of M a.
10:55:29 <josephle> yogurt_truck: it's not that monads aren't necessary, it is just that they are overglorified in the learning literature
10:55:32 <yogurt_truck> angerman: ah. form validation logic is an obvious one. where applicative is what you want.
10:55:32 <Fuuzetsu> you should probably pipe up with any difficulties on the HP threads then
10:55:42 <Fuuzetsu> no point suffering in silence
10:56:16 <yogurt_truck> josephle: example?
10:56:18 <angerman> Exio: love it because it's "abstract"?
10:56:39 <quchen> orion: Why do you want the Platform anyway? Why not install GHC alone and then use Cabal to get the rest?
10:56:45 <josephle> yogurt_truck: just look at all the monad tutorials and complaints about monad tutorials on the internet
10:56:57 <hiptobecubic> ghc + cabal + stackage is working nicely for me
10:57:07 <negatratoron> I wonder what it would take to write a Monad class with verified monad laws
10:57:15 <negatratoron> I believe it's done in Idris with dependent types
10:57:22 <Hodapp> negatratoron: verified monad laws?
10:57:24 <negatratoron> but maybe you can do it without those
10:57:25 <josephle> you probably do need dependent types
10:57:28 <geekosaur> new compiler / meta compiler, I think
10:57:34 <bb010g> Can Traversable be used to make the scan functions?
10:57:36 <geekosaur> idris/agda
10:57:44 <quchen> Statically verified Monad laws would probably break a lot of good instances
10:57:57 <negatratoron> it would reveal them as bad instances :)
10:58:17 <yogurt_truck> josephle: that's not an example
10:58:25 <geekosaur> like, o, say, IO? (a) you can't statically verify IO actions (b) exceptions kinda mess with things
10:58:27 <yogurt_truck> angerman: I guess people love tools when they work
10:58:39 <angerman> josephle: Most of the code one finds online, looks most of the time like syntax massaging. Or quite disconected from a practiacl example :(
10:58:41 <prooftechnique> zereraz: What's the type error?
10:58:51 <Hodapp> yogurt_truck: No, I just throw them at the wall a little bit less.
10:59:14 <negatratoron> geekosaur: (a) IO doesn't statically instance Monad anyway so I don't see the problem, (b) you may be right
10:59:33 <prooftechnique> zereraz: Also, you need to fix the typo in the type signature and where you call the function
10:59:57 <angerman> yogurt_truck: Hmm? Tools that work. Monads because they belong to the same typeclass.
10:59:59 <josephle> negatratoron: I wonder if you could use quickcheck as empirical "verification" of laws?
11:00:05 <bennofs> I think many monads fail the monad laws if you're very pedantic with laziness
11:00:19 <joe9> need some design advice, please? I am writitng an application to interface with a system using json. I am replicating their datatypes as haskell datatypes witht a prefix of "Json". It appears that it might be easier if I could just move all theer data types into a module and drop the prefix.
11:00:25 <joe9> Any thoughts, please?
11:00:30 <yogurt_truck> angerman: You are supposed to use abstractions only when they apply, and that's pretty much the end of it. Monads happen to apply *a lot*. Like, so often, that they're either used, or reinvented everywhere all the time. Same goes for Functor, etc.
11:00:33 <josephle> it wouldn't give you enough confidence as actual static proofs, though
11:00:37 <joe9> I have all their data types in different modules/files now.
11:01:19 <joe9> I am talking about moving all those files/modules into a cabal package with Data.AppXXX or something like that.
11:01:24 <yogurt_truck> angerman: I was responding to the "love them because they're abstract" message. I don't know why people "love" monads, or applicatives, or arrows, or {insert abstraction here}.
11:01:30 <quchen> geekosaur: Even supposing you have no exceptions and can statically verify IO actions, it's still not law-obedient. See 'evaluate's documentation for an example.
11:01:38 <geekosaur> yeh
11:01:42 <monochrom> monad is not special, magical, or deep. it is not hyped as far as I'm concerned, i.e., I don't hype it. I can't control other people. why do other people hype it? because they're the easily excited vocal minority.
11:01:49 <geekosaur> I was trying to remember the horky case
11:01:58 <zereraz> prooftechnique: sorry, it was the typo that was giving the error, thanks
11:02:06 <quchen> monochrom: 90% of everything is crap ;-)
11:02:11 <bb010g> monochrom: CATEGORY THEORY!!! EVERYBODY RUN!!!
11:02:26 <monochrom> this is why I am skeptical to, for example, "teachers should show enthusiasm". there is a slippery slope from enthusiasm to self-congratulation.
11:02:54 <angerman> yogurt_truck: so basically, because when ever I need to chain computations, I'm already having a monad sort of?
11:03:09 <negatratoron> I predict Microsoft will soon latch onto Monad as a buzzword
11:03:29 <ReinH> They haven't yet, and it's not like they don't know about them.
11:03:31 <negatratoron> C# is a great language, look at all the monads!
11:03:34 <pjdelport> (negatratoron: Wasn't that LINQ? :)
11:03:38 <prooftechnique> negatratoron: I think they'll call it a Workflow
11:03:40 <quchen> negatratoron: Reader is another example of something that doesn't obey "m >>= return = m".
11:03:45 <angerman> monochrom: It's more like... haskell. Ahh that's about monad.
11:03:46 <ReinH> pjdelport: Meijer certainly knows what a monad is :)
11:03:47 <quchen> I imagine State fails as well.
11:04:08 <joelteon> Reader doesn't obey that??
11:04:10 <pjdelport> angerman: Functor and Applicative definitely deserve more love and awareness.
11:04:14 <joelteon> how?
11:04:16 <RchrdB> quchen, er, what?
11:04:27 <quchen> ⊥ >>= return = \r -> return (⊥ r) r = \r -> const (⊥ r) r = const ⊥ ≠ ⊥
11:04:48 <joelteon> oh :/
11:05:00 <joelteon> that kind of "doesn't obey"
11:05:04 <RchrdB> Meh, fast and loose reasoning is morally correct.
11:05:06 <quchen> It's always that kind.
11:05:08 <ReinH> It is morally obedient :p
11:05:12 <quchen> Stupid halting problem should be abolished
11:05:25 <yogurt_truck> angerman: if it complies with the respective "laws", yes. Same as with functors, applicatives, etc. And same as NaturalNumber abstractions have laws that they must comply with.
11:06:17 <angerman> pjdelport: alright. Maybe that's historical and will be corrected, once the applicative => monad stuff is through?
11:06:23 <angerman> yogurt_truck: well then, pretty simple.
11:06:31 <pjdelport> angerman: Hopefully!
11:07:24 * yogurt_truck would <3 using applicative syntax in Haskell
11:07:40 * hackagebot htsn-import 0.1.0 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.1.0 (MichaelOrlitzky)
11:07:51 <ndrr> joe9: why a different package? Are multiple projects going to depend on that package?
11:07:53 <angerman> pjdelport: the thing is, I started writing down my understanding of the matter so far, and came to the conclusion that a monad does not offer more than the mentioned depended computation over an applicative functor, which started me on a journey to figure out what I'm missing.
11:08:16 <pjdelport> angerman: You're not missing anything. Monad is just Applicative + join, basically.
11:08:47 <angerman> pjdelport: maybe I should finish my notes, proofread them proper and publish them :D
11:09:01 <yogurt_truck> angerman: btw mcbride's paper on applicative goes into this (obviously). give it a read.
11:09:13 <monochrom> angerman, I think you are missing nothing.
11:09:19 <pjdelport> Now, obviously, for many important functorial / monadic types, like IO actions, the join is rather important, but for others you can end up using just Functor and Applicative a lot more.
11:09:57 <negatratoron> a multidimensional array would be an applicative but not a monad
11:09:58 <angerman> yogurt_truck: let me see if I can find it :D
11:10:12 <ReinH> negatratoron: why?
11:10:14 <pjdelport> angerman: It's better to see it as 75% of the enthusiasm over monads actually being enthusiasm about Functor and Applicative, instead. :)
11:10:14 <Zekka> Minding that join is pretty important!
11:10:22 <pjdelport> (Even if the enthused don't realize it yet.)
11:10:24 <yogurt_truck> angerman: http://strictlypositive.org/IdiomLite.pdf
11:10:33 <quchen> angerman: When you finally think you understand monads, please don't write a tutorial. That's where the Monad tutorial flood comes from :-|
11:10:34 <Zekka> it's not something you get for free
11:10:51 <monochrom> yeah, the hyping tutorials were all written long before we talked about Applicative
11:10:52 <negatratoron> it's not a monad because you can't join, and turn a 2D array of 2D arrays into a 2D array
11:10:59 <angerman> yogurt_truck: ohh that one, yes that I already read!
11:11:24 <orion> "hlint: Cannot expand #if directive ... MIN_VERSION_bytestring(a,b,c) is not a defined macro" -- anyone know what could be going wrong here?
11:11:36 <negatratoron> but it is an applicative because if you've got an array of data and a parallel array of functions you can match 'em up
11:11:39 <yogurt_truck> angerman: "The moral is this: if you’ve got an Applicative functor, that’s good; if you’ve also got a Monad, that’s even better! And the dual of the moral is this: if you want a Monad, that’s good; if you only want an Applicative functor, that’s even better!"
11:11:43 <yogurt_truck> :D
11:12:54 <joe9> ndrr:  No, but, I have a lot of "Json.." prefixed data types and putting them somewhere else might let me drop that prefix.
11:14:22 <angerman> quchen: I don't write a monad tutorial :D I basically stared by wondering what data is. Motivating functors without using their name, going to see what applicatives offer over functors, again without naming them, and then ended up figureing: the thing I could want now, which I so far cannot do, is feed the result of one thing into another thing (making the second thing dependend on the result of the first thing). If I give that the name
11:14:22 <angerman>  "bind", I'd have a monad if it also adheres to the laws. But I never used the word monad, I only motivated, chaining stuff in an abstract data representation together.
11:14:34 <marchelzo_> How do I make a Vector (PixelBaseComponent a)? (Trying to use JuicyPixels)
11:15:22 <ReinH> negatratoron: I think you can join them, though, via concatenation in the (not quite) obvious way that preserves the 2D structure.
11:15:33 <quchen> angerman: If I had a time machine I'd go back to 1990 and make SPJ name Functor/Applicative/Monad Mappable/MultiMappable/Chainable. I would then compare how that influences the public view and do science.
11:15:44 <quchen> I'm still stuck on the prerequisites though.
11:16:25 <prooftechnique> You should also go back to the Gang of Four and make them give all the patterns math-y names
11:16:29 <prooftechnique> Do both parts of the science
11:16:41 <ReinH> for instance, x = [[1,2],[3,4]]; join [[x,x],[x,x]] = [[1,2,1,2],[3,4,3,4],[1,2,1,2],[3,4,3,4]]
11:16:44 <monochrom> I concur! :)
11:16:59 <negatratoron> ReinH: I should have specified, I was talking about matrices of specific dimensions
11:17:10 <negatratoron> not just List (List a)
11:17:19 <ReinH> negatratoron: Ah.
11:17:24 <angerman> quchen: well I don't mind the naming so much, though, I think (at least to me that is) there's to much theory driven micro examples. Which I hate about the math so much. Even though I love it enogh to have studied it proper.
11:18:10 <angerman> prooftechnique: or better, take the GoF and present the patterns in a haskell, math annotated way ;-)
11:18:44 <prooftechnique> Madness
11:18:54 <ReinH> The thing about such patterns is that they are designed to fill in gaps in the language
11:19:02 <prooftechnique> "Let me tell you about Traversables"
11:19:15 <ReinH> Languages with better iterator/enumeration/generator support just don't have need for an Iterator or Visitor pattern or w/e
11:19:19 <monochrom> the Lambda design pattern :)
11:19:27 <Hodapp> ReinH: People always get pissy when I tell them that that book is just a list of ways their language sucks.
11:19:33 <ReinH> Hodapp: pretty much
11:19:57 <prooftechnique> Well, it's pretty hard to take that tone in a positive way, true or not
11:19:59 <angerman> quchen: there is actually a very excellent book on non-eucledean geometry by Felix Klein, who does an amazing job at explaining and motivating concepts, instead of hiding them in formulas.
11:20:15 <quchen> angerman: Non-Euclidean as in Riemannian?
11:20:16 <prooftechnique> angerman: Title? I'd like to read that
11:20:28 <ReinH> me too
11:20:30 <angerman> http://www.springer.com/mathematics/geometry/book/978-3-642-95027-8
11:20:54 <monochrom> Felix Klein. that was a long long time ago.
11:21:03 <ReinH> in a galaxy far away?
11:21:09 <quchen> That's pretty German though. Which is fine for me, but probably not many others in here.
11:21:14 <pjdelport> Someone should cross-reference the GoF patterns to a list of Haskell library implementations.
11:21:25 <quchen> pjdelport: … fits in a Gist? :-þ
11:21:27 <monochrom> a long long time ago, in a non-Euclidean galaxy far far away...
11:21:32 <angerman> quchen: someone should translate it :D It's just too awesome!
11:21:37 <Hodapp> pjdelport: Why?
11:21:43 <prooftechnique> pjdelport: Data.Traversable, Data.Foldable, Control.Lens?
11:21:43 <angerman> monochrom: haha!
11:22:00 <pjdelport> prooftechnique: Is that a candidate list for the whole thing? :)
11:22:07 <quchen> Posting that on HN would be an interesting sociological experiment.
11:22:09 <pjdelport> Hodapp: Just so you can point people at it.
11:22:14 <josephle> pjdelport: http://blog.ezyang.com/2010/05/design-patterns-in-haskel/
11:22:14 <josephle> ?
11:22:16 <angerman> quchen?
11:22:27 <monochrom> Einstein came along and said, "simply say: in a non-Euclidean space-time far far away..."
11:22:32 <pjdelport> quchen: Post and then duck for cover, probably!
11:22:45 <pjdelport> josephle: Neat!
11:22:48 <pjdelport> josephle++
11:22:56 <angerman> josephle; ohh!
11:23:43 <monochrom> pjdelport: I want to know how you implement the Singleton pattern!
11:24:00 <pjdelport> monochrom: Lazy evaluation, surely :)
11:24:13 <pjdelport> (and top-level definitions)
11:24:14 <monochrom> actually, Flyweight looks tricky.
11:24:27 <dfeuer> @tell dcoutts stream-fusion's version of inits has the same performance bug as the one currently in Data.List. It can probably be fixed in a similar fashion, but the details may be different.
11:24:28 <lambdabot> Consider it noted.
11:27:25 <quchen> monochrom: Memoization and sharing are often tricky in Haskell too (at least for me), regardless of how the design pattern carries over. It's good to know that this is also a problem in other languages. (I secretly assumed this is one of the places where immutability sucks.)
11:27:25 <prooftechnique> I like that Flyweight is supposed to be intuitively obvious, but Functor is ivory tower craziness
11:27:48 <prooftechnique> (naming-wise, that is)
11:28:31 <ReinH> What is Flyweight?
11:28:32 <josephle> it can't be that bad if C++ has 'functors' now
11:28:39 <monochrom> it's why I chose it as a challenge to "implement GoF patterns in haskell" :)
11:28:56 <prooftechnique> ReinH: http://en.wikipedia.org/wiki/Flyweight_pattern
11:29:15 <quchen> josephle: Functors in C++ are objects with overloaded () operator.
11:29:20 <pjdelport> josephle: I think C++ Functor is a completely different thing.
11:29:35 <ReinH> I actually don't remember that one from GoF at all
11:29:48 <Fuuzetsu> yes, C++ functors are not Functors
11:29:52 <josephle> they are, hence the quotes. But apparently they're not ivory tower craziness enough if C++ overloads the name
11:30:23 <ReinH> Well, CT overloaded "monad", so I guess turnabout is fair play.
11:30:24 <monochrom> ReinH: GHC itself does some sort of Flyweight for Char. the letter 'a' is shared by every value that contains it
11:30:24 <quchen> C++ functors are severely ad-hoc, hence not ivorytower.
11:30:52 <monochrom> at least every [Char] that contains it
11:30:52 <ReinH> monochrom: Yeah, but why say "some sort of flyweight" when you could just say "shared"? ;)
11:31:00 <bb010g> ReinH: Also J.
11:31:06 <ReinH> monochrom: the first 256 of them iirc
11:31:07 <monochrom> I don't know
11:31:15 <josephle> I understood the complaint as saying that Functor as a name was ivorytower, not the semantics
11:31:21 <josephle> perhaps I misunderstood
11:31:27 <ReinH> so most printable strings take up very little memory
11:31:41 <ReinH> or at least, most ASCII strings
11:31:46 <ReinH> sorry for the anglocentrism
11:31:55 <quchen> > 'N' : repeat 'o' -- ReinH
11:31:57 <lambdabot>  "Noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
11:32:08 <quchen> Well, depends on what you mean with "memory".
11:32:14 <bernalex> does cabal-install have a developer chan?
11:32:23 <ReinH> quchen: I think I'm just going to take that whole statement back.
11:32:23 <bernalex> alternatively, any developers in here? :-]
11:32:25 <joelteon> no, use here
11:32:59 <nezt> so function evaluation is left associative by default (without $ or .) and -> is right associative ?
11:33:00 <quchen> ReinH: Well, the above indeed takes very little memory, but if you print it it grows of course.
11:33:14 <ReinH> quchen: sure
11:33:19 <marchelzo_> What is the best data structure for a 2d collection of points, where I want to mutate the points? I don't want to constantly do (take n xs) ++ [x] ++ (drop (n+1) xs))
11:33:38 <pjdelport> nezt: Yep
11:33:39 <joelteon> you can use zippers for thaot
11:33:46 <marchelzo_> s/))/)
11:34:09 <orion> In a piece of code I saw this comment: -- >>> verify pk (sign sk xs) <-- however I don't know where "xs" came from, yet the doctest succeeds! Where does `xs' come from?
11:34:26 <joelteon> orion: it's probably in the $setup block
11:34:33 <joelteon> the whole module is evaluated top to bottom by doctest
11:34:35 <quchen> machrider: (Somewhat unrelated, but) you should use split instead of take+drop; the former only requires one list traversal, the latter two. Also zippers and Set/Map.
11:34:45 <orion> joelteon: Oh, cool!
11:34:50 <orion> Totally missed that
11:34:55 <ReinH> quchen: *cough* comonads *cough*
11:35:29 <quchen> ReinH: Zippers are comonads, but in general comonads are unrelated here, no?
11:36:06 <ReinH> quchen: store comonads, specifically
11:36:18 <quchen> Oh Store, my arch enemy.
11:36:22 <ReinH> :)
11:36:29 <quchen> Every time I understand it I don't. And then someone tells me it's actually very easy.
11:36:46 <ReinH> if you consider it represented as a function from N^2 -> a ;)
11:37:05 <ReinH> or Z^2 even, no reason to restrict ourselves to infinity in only two directions
11:37:21 <quchen> ReinH: ಠ_ಠ http://www.theproofistrivial.com/
11:37:27 <ReinH> or R^2, no reason to restrict ourselves to discrete space representation
11:37:28 <ReinH> ;)
11:37:43 <ReinH> quchen: that's amazing :)
11:38:03 <orion> "hlint: Cannot expand #if directive ... MIN_VERSION_bytestring(a,b,c) is not a defined macro" -- anyone know what could be going wrong here?
11:38:37 <joelteon> orion, you need to add your dist/autogen/cabal_macros.h to the CPP defines for hlint
11:41:32 <Fuuzetsu> quchen: that is awesome
11:42:59 <orion> joelteon: I don't seem to have an autogen directory in dist.
11:43:05 <joelteon> oh, really?
11:43:09 <joelteon> that's interesting
11:43:23 <joelteon> my mistake, it's dist/build/autogen
11:43:25 <joelteon> sorry
11:43:27 <orion> ah, there it is
11:48:31 <darthdeus> how should I represent something like    data Value = Foo Int | Bar String | Baz Double; data Operation = OpPlus Value Value | OpMult Value Value | ....   without having to explicitly implement every possible combination?
11:50:16 <jcowan> Is there an obvious way (short of recursion) to detect the point at which two lists are no longer equal element-wise?
11:50:48 <lispy> darthdeus: https://gist.github.com/nebuta/6096345
11:50:57 <lispy> darthdeus: GADTs are one solution to that problem
11:51:38 <darthdeus> lispy: is reify like show?
11:51:50 <lispy> darthdeus: http://en.wikibooks.org/wiki/Haskell/GADT A better explanation of the same idea
11:52:13 <darthdeus> lispy: I guess my problem is that my values aren't haskell primitives
11:52:28 <lispy> I have to run
11:52:35 <lispy> Sorry I can't stick around to help more
11:52:38 <monochrom> jcowan: does "dropWhile (\(x,y) -> x==y) (zip list1 list2)" help?
11:52:39 <darthdeus> I'll write a SO question :P
11:52:42 <darthdeus> thanks anyway :)
11:53:02 <nezt> another really newbie question here, when i try to open a program with Data Maybe a = Nothing | Just a, it says "parse error on input `|' "
11:53:26 <darthdeus> nezt: what's the whole error message?
11:53:35 <darthdeus> nezt: data or Data?
11:53:52 <nezt> data,
11:54:22 <jcowan> monochrom: Looks good, thanks.  Does it realize the storage for the zipped list, though?  A recursive solution would just count things.
11:54:37 <ReinH> nezt: can you pastie the code and the error please?
11:54:38 <nezt> nvm i think my character encoding is messed
11:54:48 <ReinH> Ah. That would do it.
11:55:01 <RyanGlScott> I've heard that using something like "type NumFun = (Num a, Num b) => a -> b" is discouraged. What is a better way of doing this?
11:55:04 <monochrom> it doesn't, assuming laziness
11:55:17 <marchelzo_> is it inefficient to use a Map (Int, Int) a as an alternative to [[a]] or Vector (Vector a) ?
11:55:24 <jcowan> monochrom: Thanks
11:55:46 <Fernandos> hi
11:56:14 <ReinH> marchelzo_: probably not, but benchmarks will tell you better than random people on the internet.
11:56:26 <pjdelport> marchelzo_: Depends on sparseness, probably.
11:56:33 <ReinH> It depends on the shape of your problem
11:56:46 <monochrom> it really depends on what operations you use most
11:56:46 <prooftechnique> marchelzo_: Also, do whatever fits the problem best. Worry about efficiency later
11:56:59 <prooftechnique> monochrom said it better
11:57:03 <ReinH> that too
11:57:04 <kazagistar> marchelzo_: usually, it is a pretty good first approximation, and then you can swap in something else later
11:57:21 <monochrom> no, I said it better here: http://www.vex.net/~trebla/humour/tautologies.html #5
11:57:35 <enthropy> at least it's not a unicycleshed
11:57:36 <marchelzo_> I need a dynamic 2d collection. With lists / vectors there is no way to do xs[2][4] = 3 for example
11:57:40 <ReinH> monochrom: :p
11:57:44 * hackagebot idris 0.9.14.1 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.14.1 (EdwinBrady)
11:58:50 <ReinH> Well...
11:58:52 <ReinH> > [[1,2]] & element 0 . element 1 .~ 3
11:58:53 <lambdabot>  can't find file: L.hs
11:59:07 <ReinH> What.
11:59:10 <Fuuzetsu> RyanGlScott: put the constraint on functions using your type
11:59:13 <ReinH> You literally just did it in /q
11:59:14 <prooftechnique> marchelzo_: Lenses can do pretty much everything
11:59:21 <ReinH> > [[1,2]] & element 0 . element 1 .~ 3
11:59:23 <lambdabot>  [[1,3]]
11:59:25 <ReinH> thank you
11:59:37 <monochrom> "can't find file: L.hs" is an intermittent error.
11:59:41 <ReinH> Ah ok.
11:59:42 <marchelzo_> how do I into lens
12:00:03 <kazagistar> L.hs is the file that stores the @define stuff, right?
12:00:09 <monochrom> yes
12:00:22 <monochrom> probably also the expression you're entering
12:00:22 <jedai> marchelzo_: That's probably not a good idea for a beginner
12:00:33 <marchelzo_> ReinH: What is the time complexity of that operation?
12:00:43 <ReinH> marchelzo_: Not very good, but better than "impossible"
12:00:46 <prooftechnique> marchelzo_: This isn't bad. https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
12:01:03 <ReinH> marchelzo_: if you think a Map is appropriate, go with that.
12:01:10 <marchelzo_> prooftechnique: thank you
12:01:19 <ReinH> It won't really be a bad choice
12:01:21 <jedai> marchelzo_: Anyway you can do what you ask for in any collection, the difference will be the complexity of the operation (Map is not too bad for this one)
12:01:37 <ReinH> Once you know more about what shape your data is and how you access it, you might profile some other approaches
12:01:47 <kazagistar> marchelzo_: it is slow. But lens does a pretty good job abstracting collection access and mutation, so you can swap out the container reasonably well
12:01:48 <ReinH> but this is a perfectly reasonable choice to get started with
12:02:09 <marchelzo_> ok
12:02:10 <marchelzo_> thanks
12:02:37 <ReinH> The advantage of lens here is that you can write an indexed traversable for your grid/space and, if you write your code in terms of it, swap out the underlying representation by re-implementing the traversal.
12:03:49 <RyanGlScott> Fuutzetsu: So would having "type Fun a b = a -> b" and "foo :: (Num a, Num b) => Fun a b" be the alternative?
12:03:56 <ReinH> without changing your code that uses it, assuming the representation is similar enough
12:04:10 <ReinH> you might need to make some modifications if you switch from a sparse to a dense representation or vice versa
12:04:23 <ReinH> but I'd say just start out with a Map and the Map operations
12:04:26 <empyreal> Arranged marriages are the best amirite
12:04:28 <jcowan> Another similar question: given a sequence, replace all members that satisfy some predicate with a replacement computed from the member.
12:04:40 <marchelzo_> ReinH: Yeah I think that is what I'll do
12:05:10 <bitemyapp> johnw: hi
12:05:26 <prooftechnique> jcowan: List comprehension with a filter in it?
12:05:37 <orion> I just found a function named `morallyDubiousIOProperty' and lol'd.
12:05:41 <ReinH> > map (\x -> if even x then succ x else x) [1..10] -- jcowan
12:05:43 <lambdabot>  [1,3,3,5,5,7,7,9,9,11]
12:06:03 <ReinH> depending on what you want to do with the members that don't satisfy
12:06:05 <jcowan> ReinH: Thanks.
12:06:38 <prooftechnique> orion: I think it's deprecated now
12:07:13 <prooftechnique> This is pretty good, though: https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L624
12:07:16 <quchen> > map ((+1) . (*2) . (`div` 2)) [1..10] -- ReinH :-D
12:07:18 <lambdabot>  [1,3,3,5,5,7,7,9,9,11]
12:07:51 <prooftechnique> "If you enjoy sharing an address space with a malevolent agent of chaos, try 'accursedUnutterablePerformIO'."
12:07:53 <stalintrotsky> :t bracket
12:07:54 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
12:08:06 <ReinH> prooftechnique: <3
12:11:46 <eikke__> is there any type-safe way to cast (e.g.) an unboxed Vector of 16 Word16's to an unboxed Vector of 4 Word64's?
12:14:16 <orion> http://lpaste.net/471649540097703936 <-- haskell-src-exts-1.15.0.1 build fails with GHC 7.8.3.
12:14:47 <bluezone> if i navigate into a folder containing script.hs, then i run ghci and follow that with ':1 script' what is ':1 script' supposed to do exactly
12:14:57 <bluezone> i'm following http://learnyouahaskell.com/starting-out
12:15:22 <Pythonfant> bluezone: are you sure it's not :l instead of :1?
12:15:23 <enthropy> orion: sounds like it's code generated by happy which cabal includes in the sdist
12:15:41 <Pythonfant> :l loads the module into the current session
12:15:53 <enthropy> if you "cabal unpack haskell-src-exts", and cabal install from there it'll probably re-run happy?
12:15:57 <Pythonfant> so you get the functions and variables defined in this module
12:16:31 <bluezone> Pythonfant, l seems to work, but in the guide it really looks like a 1
12:16:57 <bluezone> heh
12:17:00 <Pythonfant> bluezone: searching for :1 on the page does only return one match that is unrelated
12:17:13 <Pythonfant> so your definitly looking for :l
12:17:49 <bluezone> yeah, if you look up 'baby' you'll see what i was talking about :)
12:18:00 <mietek> Anyone using http-streams?
12:18:07 <mietek> I'm getting a SIGSEGV in SSL_CTX_set_cipher_list with libssl.0.9.8 on OS X 10.9
12:18:09 <mietek> When trying to use baselineContextSSL
12:18:53 <orion> enthropy: I see. Do you know what config directive I need to specify so cabal tells the linker to search in the correct directory?
12:19:07 <Pythonfant> mietek: could it be related to https://github.com/afcowie/http-streams/issues/60
12:19:09 <Pythonfant> ?
12:19:15 <Pythonfant> I remember having a similar problem
12:19:32 <dcoutts> orion: I'm missing context, but probably --extra-lib-dirs
12:21:40 <mietek> Pythonfant: doh, you're right.  I was misled by the docs saying this is already done for us.
12:21:44 <mietek> Thanks.
12:22:03 <mietek> Pythonfant: any chance you've also seen ProtocolError "error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol"?
12:22:09 <Pythonfant> no sry
12:22:23 <Pythonfant> I ended up not using http-streams because I didn't got something to work back when I tried it
12:22:28 <Pythonfant> and went with http-conduit
12:22:55 <Pythonfant> now I would probably go with wreq but I didn't knew about it a month ago
12:23:02 <mietek> Oh right, wreq§
12:23:03 <mietek> !
12:23:06 <mietek> Thanks for reminding me.
12:24:22 <orion> dcoutts: /usr/local/bin/ld: cannot find -lHSrandom-1.0.1.1-ghc7.8.3 <-- the file is in ~/.cabal/lib/random-1.0.1.1/ghc-7.8.3/. Not sure why cabal is having trouble finding it.
12:25:09 <mmachenry> Does anyone know how to pull a value out of an Aeson object while I'm parsing it so that I can chose which constructor to use?
12:25:35 <mmachenry> I want which data constructor I am using to depend on one of the values set in my JSON object.
12:25:50 <mmachenry> But I don't see anything in the interface for Aeson other than applicative parser stuff.
12:27:44 <enthropy> orion: ghc-pkg describe random -- should have a library-dirs that matches the path in ~/.cabal/
12:29:10 <orion> enthropy: Indeed.
12:29:31 <mietek> Pythonfant: it's a shame, as I was quite happy with http-streams' small amount of dependencies...
12:29:32 <orion> There are two files in that directory: HSrandom-1.0.1.1.o and libHSrandom-1.0.1.1.a
12:29:46 <enthropy> so it's missing the shared one?
12:29:55 <orion> Right. It's
12:29:58 <orion> got the static one
12:30:11 <SegFaultAX> I'm looking for a function like `iterate`, but that returns `[x, x >>= f, x >>= f >>= f, ...]`. Does such a thing already exist?
12:30:45 <jle`> SegFaultAX: i think there's one in monad-extras
12:30:49 <benmachine> SegFaultAX: iterate (>>= f), surely
12:31:05 <jle`> or that ;)
12:31:19 <SegFaultAX> Oh duh. Thanks :)
12:31:22 <orion> Is with-hc-pkg the correct directive to set if you have a non-standard ghc-pkg?
12:31:30 <jle`> monad-extras is different
12:31:48 <enthropy> jle`: not monad-loops?
12:32:01 <SegFaultAX> I was looking in monad loops already.
12:32:22 <jle`> monad-loops has different things too
12:32:51 <jle`> monad-extras is johnw's misc monadic helpers collection
12:33:50 <mietek> Pythonfant: but wreq works.  So there.  Thanks again.
12:34:16 <Pythonfant> np
12:35:47 <bb010g> When will GHC make an Integer computation with just (+) an Int# computation with (+#)?
12:35:47 <TheKing444> :t mfix
12:35:48 <lambdabot> MonadFix m => (a -> m a) -> m a
12:37:44 <kazagistar> > mfix (\a -> [a,a]) 1
12:37:46 <lambdabot>  Couldn't match expected type ‘a1 -> t’ with actual type ‘[a0]’
12:38:02 <kazagistar> oh, er right
12:38:03 <kazagistar> nevermind
12:40:44 <benmachine> > length . take 10 $ mfix (\a -> [a,a])
12:40:46 <lambdabot>  2
12:40:53 <benmachine> hm.
12:41:06 <monochrom> do you need help you mfix?
12:41:52 <prooftechnique> If it ain't mbroke, don't mfix it
12:41:57 <monochrom> hehe
12:43:01 <chip_buster> I've been trying to do the Write Yourself a Scheme exercise, but GHC keeps telling me that Control.Monad.Error is deprecated and I should use Except instead
12:43:01 <pavonia> > mfix (\a -> [a,a])
12:43:03 <pqmodn__> the type of fix is puzzling, (a -> a) -> a... since i never provide an "a" to the first argument, does that hint that something funny is going on? i've worked through how it's derived, but just looking at the type alone, what does it mean?
12:43:06 <lambdabot>  mueval-core: Time limit exceeded
12:43:15 <chip_buster> but Except doesn't seem to have the Error class used in the tutorial
12:43:29 <benmachine> this is because the Error class is kinda sucky
12:43:30 <monochrom> read my http://www.haskell.org/haskellwiki/MonadFix for mfix
12:44:06 <chip_buster> benmachine: so would the best way forward be to rewrite the code using Except instead?
12:44:19 <prooftechnique> That would be a very good learning experience
12:44:26 <prooftechnique> Then you could update the exercise, too!
12:44:27 <benmachine> chip_buster: yes, but be careful
12:44:45 <chip_buster> what should I be watching out for?
12:44:59 <benmachine> chip_buster: if you see a pattern-match on the left of an <- arrow in a do-block
12:45:05 <benmachine> the behaviour of those has changed
12:45:13 <benmachine> you might be lucky, there might not be any
12:45:27 <benmachine> part of the reason it changed is because people didn't like the old behaviour, so many people avoided using it
12:46:05 <TheKing444> length $ mfix (\a -> [a,a])
12:46:12 <benmachine> roughly speaking you should try the switch and if the result doesn't crash then you're good
12:46:16 <TheKing444> > length $ mfix (\a -> [a,a])
12:46:18 <lambdabot>  2
12:46:26 <chip_buster> alright then
12:46:35 <prooftechnique> :t mfix
12:46:36 <lambdabot> MonadFix m => (a -> m a) -> m a
12:46:43 <chip_buster> I guess I'll write it with the deprecated stuff first, then try to switch it over
12:46:45 <chip_buster> thanks for the tips!
12:46:53 <TheKing444> > mfix (\a -> replicate a a)
12:46:57 <lambdabot>  mueval-core: Time limit exceeded
12:47:06 <TheKing444> :(
12:47:45 <TheKing444> > mfix (\a->[1]:a)
12:47:47 <lambdabot>  Occurs check: cannot construct the infinite type: t ~ [t]
12:47:47 <lambdabot>  Expected type: [[t]]
12:47:47 <lambdabot>    Actual type: [t]
12:47:47 <lambdabot>  Relevant bindings include a :: [t] (bound at <interactive>:1:8)
12:47:51 <monochrom> mfix (\a -> [a,a]) is equivalent to (let {xs = [a,a]; a = head xs} in xs)
12:47:59 <monochrom> read my http://www.haskell.org/haskellwiki/MonadFix for mfix
12:48:29 <TheKing444> > mfix return
12:48:30 <monochrom> it does not recurse on control flow. it only recurses on the data used
12:48:31 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
12:48:31 <lambdabot>    arising from a use of ‘M16501059830362287631689.show_M16501059830362287631...
12:48:31 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
12:48:31 <lambdabot>  Note: there are several potential instances:
12:48:31 <lambdabot>    instance [safe] GHC.Show.Show a =>
12:49:45 <monochrom> actually, (let {xs = [a,a]; a = head xs} in xs) is still wrong, but close.
12:52:13 <latk> Is there some clever way of squashing (Either String (Either String a)) into Either String a ?
12:52:35 <TheKing444> join $ Right $ Left "Yolo"
12:52:46 <TheKing444> > join $ Right $ Left "Yolo"
12:52:48 <lambdabot>  Left "Yolo"
12:52:57 <latk> Thanks :p
12:52:58 <TheKing444> latk Ta DA!
12:53:03 <TheKing444> :t join
12:53:04 <lambdabot> Monad m => m (m a) -> m a
12:53:22 <TheKing444> :t join :: (Either r (Either r a)) -> Either r a
12:53:23 <lambdabot> Either r (Either r a) -> Either r a
12:55:22 <monochrom> @type mfix (\a -> [a,a])
12:55:23 <lambdabot> [a]
12:55:38 <orion> In a cabal sandbox, if a dependency is met by a package installed in ~/.cabal, will it use that instead?
12:58:55 <MP2E> orion : Yes, it will use packages outside the sandbox
12:59:14 <geekosaur> um
12:59:23 <geekosaur> it will use *global* packages
12:59:37 <geekosaur> but the sandbox, as seen by cabal, *replaces* ~/.cabal
12:59:46 <geekosaur> that's kinda the point
13:00:07 <ReinH> :t join `asAppliedTo` Left "error"
13:00:08 <lambdabot> Either [Char] (Either [Char] a) -> Either [Char] a
13:00:46 <ReinH> :( it isn't good with type synonyms
13:00:48 <ReinH> :t join `asAppliedTo` Left ("error" :: String)
13:00:49 <lambdabot> Either String (Either String a) -> Either String a
13:01:39 <joelteon> > fail "failure" :: Either String Int
13:01:40 <lambdabot>  *Exception: failure
13:01:45 <joelteon> :D
13:02:21 <ReinH> :t do { fail "failure"} :: Either String Int
13:02:22 <ReinH> :D
13:02:22 <lambdabot> Either String Int
13:02:35 <beaky> i love monads
13:03:37 <dfeuer> What's your favorite monad law, beaky.
13:03:51 <joelteon> it was considerate of category theorists to add "fail" to the definition of a monad
13:04:13 <nezt> the more i read about this language the more i realize how beautiful it is
13:04:16 <nezt> why is this not more popular
13:04:24 <joelteon> We're working on it
13:04:24 <Exio> > do { a <- undefined; fail "test"; } :: Either String Int
13:04:26 <lambdabot>  *Exception: Prelude.undefined
13:04:41 <ion> joelteon: They call it φ, of course.
13:04:47 <Exio> :(
13:04:58 <joelteon> Can we use that
13:07:26 <dfeuer> Is there a scanr/scanr law like the map/map law? It seems like there should be, but I haven't been able to find one yet.
13:08:30 <wolfspaw> Is there some place where one can see an "Alpha-Alpha-Alpha Draft" for the next haskell report? Like, what extensions have a community consensus of being incorporated, and changes like the AMP that was accepted for 7.10
13:10:07 <prooftechnique> wolfspaw: Like this? https://ghc.haskell.org/trac/haskell-prime/query?status=new&status=assigned&status=reopened&group=state
13:11:05 <wolfspaw> prooftechnique yes xD, thanks
13:11:32 <nadirs> Hello, a question about (im)mutability trade-offs: is it fine to use immutabile data types when writing an emulator? (I think it falls under the realtime things)
13:11:43 <nadirs> My worry is about hardware registers
13:12:09 <Athas> nadirs: it is always fine to use immutable data.
13:12:18 <nadirs> does immutability in the implementation of the emu memory and registers lead to bloat in memory usage?
13:12:24 <Athas> In this case, it seems rather important for performance.  I would recommend looking into the ST monad.
13:12:30 <Athas> It might.
13:12:37 <Athas> And it might also cause space leaks due to laziness.
13:12:45 <nadirs> Athas: thanks for the directions. Will look into it :)
13:13:21 <jfischoff> I have code that compiles fine but haddock dies on it with the error: parse error on input `<-‘, what gives?
13:13:25 <nadirs> Athas: so I should look into strict alternatives too
13:13:28 <mmmm> What's the lightest lens library?
13:13:41 <prooftechnique> @hackage lens-family
13:13:41 <lambdabot> http://hackage.haskell.org/package/lens-family
13:13:43 <prooftechnique> I think
13:13:44 <edwardk> Prelude
13:13:45 <Athas> nadirs: definitely, use a strict ST array to model your register bank.
13:13:48 <ReinH> nadirs: it's a good idea to work with the immutable structures until you understand their limitations :)
13:14:09 <prooftechnique> jfischoff: Parse error?
13:14:19 <Athas> But I would say that Haskell is a slightly odd choice to use for a low-level emulator.
13:14:29 <ReinH> Athas: depends on how low-level :)
13:14:40 <jfischoff> prooftechnique: well ghc does not think there is a parse error only haddock
13:14:42 <prooftechnique> nadirs: You could spec it out in Haskell and have it generate C or something for the low-level bits
13:14:46 <nadirs> ReinH: I'm thinking maybe my case might get away with those since I'm targeting a simple 8-bit system
13:15:03 <prooftechnique> jfischoff: Link to the code, maybe?
13:15:07 <prooftechnique> That seems weird
13:15:16 <ReinH> You can write a perfectly cromulent Z-Machine emulation in Haskell ;)
13:15:25 <Athas> ReinH: in an emulator, you usually have simple, flat data structures, simple control flow, and little abstraction.
13:15:37 <Athas> So that elegantly avoids touching Haskells greatest advantages.
13:15:47 <ReinH> Athas: fair enough
13:15:58 <Athas> But sure, I would use it for emulating something complex, like maybe a computing grid.
13:16:02 <nadirs> prooftechnique: maybe, I actually started writing it in C long time ago, then lost interest. I'm planning this in order to learn some of the many are of Haskell that are unknown to me :)
13:16:03 <ReinH> Athas: although structuring that control flow using (free) monads is quite nice
13:16:11 <prooftechnique> Athas: But think of all the bit-twiddling combinators you could write!
13:16:20 <prooftechnique> Get that namespace good and dirty
13:16:21 <edwardk> clearly we need a z-machine jit that targets the gpu
13:16:31 <edwardk> run the entire game in a shader
13:16:36 <ReinH> hahaha
13:16:45 <edwardk> including font render
13:16:50 <edwardk> should be quite doable
13:16:53 <ReinH> edwardk: I guess I know what we're writing for Hac Boston
13:16:55 <nadirs> Athas: looks like my choice for a learning project couldn't be worse then, haha
13:17:14 <ReinH> nadirs: do it anyway :p
13:17:20 <Athas> nadirs: well, most people never learn how to write low-level code in Haskell, so it's not too bad.
13:17:22 <edwardk> current plan is actually to try to get Univariant good enough to take over hask with it
13:17:23 <ReinH> It's good to learn where a system's edges are
13:17:36 <Athas> I agree.
13:17:41 <ReinH> edwardk: disregard Hask acquire GPU-based Z-Machine
13:17:43 <nadirs> ReinH: :D
13:17:59 <Athas> What is Univariant?
13:18:06 <arianvp> yo guys
13:18:11 <kazagistar> nadirs: I used a simple emulator as my learning project, I just forced myself to not be TOO concerned with optimal memory efficiencies or perfect performance
13:18:25 <ReinH> arianvp: not all guys here, but hi :)
13:18:29 <edwardk> Athas: i gave a talk a couple weeks ago on some kind indexed category theory i was doing
13:18:34 <nadirs> kazagistar: in fact it seems the best approach
13:18:40 <edwardk> it was full of apologia about how it cheated on the category theory.
13:18:46 <edwardk> univariant is about removing the cheats
13:18:49 <nadirs> kazagistar: (I mean, not worrying about performance)
13:19:10 <arianvp> ReinH:  Meh I consider "guys" to be a rather unisex term in that context
13:19:11 <edwardk> i mean it defines the yoneda embedding before it defines a category =)
13:19:18 <Athas> nadirs: a gentleman emulator, one that takes its time to savor every instruction.
13:19:23 <ReinH> arianvp: and other people don't.
13:19:26 <arianvp> but fine, hi people!
13:19:33 <ReinH> Thanks.
13:19:44 <prooftechnique> edwardk: The scandal!
13:20:08 <vanila> maybe let women speak for themselves?
13:20:16 <edwardk> prooftechnique: https://github.com/ekmett/hask/blob/master/wip/Univariant.hs is the code we're working on
13:20:30 <edwardk> vanila: maybe they shouldn't have to
13:20:54 <vanila> what?
13:21:05 <nadirs> Athas: I think I'll call the project "gentleman"! That punchline is simply perfect
13:21:21 <prooftechnique> edwardk: Seeing lots of unsafe-y, coerce-y stuff. Looks fancy :D
13:21:37 <kazagistar> nadirs: if you want an array for memory, its fine to toss in an ST, I think it helps to see how immutable and mutable coexist
13:21:39 <arianvp> unsafeCoerce ftw
13:21:55 <edwardk> prooftechnique: heh, github.com/ekmett/hask is the current version, talk here: https://www.youtube.com/watch?v=Klwkt9oJwg0&feature=youtu.be
13:22:14 <prooftechnique> Yeah, I watched the talk. Very neat, though I had to keep pausing to let stuff sink in
13:22:16 <ReinH> vanila: no thanks.
13:22:17 <arianvp> woop. I used a lens for the first time in code .
13:22:35 <luite> arianvp: got it installed with ghcjs now?
13:22:40 <edwardk> univariant removes the Any hack in exchange for a bunch of other Any hacks ;)
13:22:43 <arianvp> luite: yep :)
13:22:53 <vanila> as a woman I'm telling you this bothers me
13:23:10 <arianvp> luite: http://lpaste.net/108425 :-)
13:23:54 * nadirs pushes ST on the top of the to-learn list
13:23:56 <luite> arianvp: is that Html from Hom.DOM ?
13:24:15 <ReinH> vanila: I realize that some women don't have an issue with that use of gendered language, but some do and you don't speak for all women either.
13:24:28 <prooftechnique> arianvp: Took me a minute to spot what lens function you used
13:24:34 <vanila> gendered language isn't the issue here
13:24:48 <arianvp> luite: yeh.
13:25:02 <arianvp> luite: it's basically a wrapper around  the virtual-dom package from nodejs
13:25:03 <luite> which is a cool name btw :)
13:25:10 <ReinH> Why can't I be bothered by it?
13:25:38 <prooftechnique> Take it to #haskell-blah
13:25:41 <vanila> you can do what you want, i.e. ignore input from women on how to make the channel a nicer place for us
13:26:03 <vanila> http://pastebin.com/f0YwKfM2 previous examples
13:26:05 <dfeuer> Oh! There are people here now! I was trying to work out if there's a nice scanr/scanr rule to match the map/map rule, but I got stuck. Anyone know?
13:26:15 <arianvp> so now I can do really efficient dom updates a la ReactJS
13:26:16 <Athas> dfeuer: there is not.
13:26:26 <Athas> dfeuer: scan has pretty poor fusion semantics.
13:26:51 <dfeuer> Athas: so there's no nice way to combine them at all?
13:27:09 <Athas> dfeuer: not in general, I don't think.
13:27:28 <ReinH> I'm happy to take it to #haskell-blah, but I'm not ignoring your input at all. I'm weighing it against other input from other women.
13:27:28 <Athas> Hmm...
13:27:53 <Athas> Really, there should be a way to do something...
13:28:11 <kazagistar> nadirs: haskell does not do mutation directly, but it does let you construct and compose operations that do mutation, and use them to build a pure exterior
13:28:32 <luite> arianvp: I'd like to help improve performance at some point, it's easy to lose all gains again if conversion is done inefficiently
13:28:44 <stolaruk> Anybody find much use for lambda case?
13:29:03 <carter> vanila: how can i help (if i can)
13:29:03 <arianvp> luite: awesome. I'll put it up on github once I've decided on a good API And wrapped all the calls
13:29:14 <jfischoff> stolaruk: many of my functions start with it
13:29:24 <jfischoff> the others, a record wildcard
13:30:04 <luite> arianvp: also like react, it might make sense to move the whole main loop to requestAnimationFrame, or at least have a thread that batches DOM updates from there
13:30:05 <stolaruk> jfischoff: I'm looking for places where I can use it in my code. Haven't found many places that begin like "\x -> case x of"... maybe I'm missing something.
13:30:22 <arianvp> luite: yeh I've been struggling to come up how to do that properly though
13:30:38 <jfischoff> stolaruk: what about foo x = case x of ?
13:30:39 <arianvp> luite: currently the app main-loop looks likes this: http://lpaste.net/449156491425873920
13:31:06 <stolaruk> jfischoff: I did actually just find a function like that, but in the case there is a place where I reference the x
13:31:27 <stolaruk> jfischoff: I just discovered record wildcards
13:31:30 <stolaruk> , too
13:31:33 <arianvp> it's really greedy. does a  DOM-patch every time the state changes. instead of batching
13:31:46 <arianvp> not very efficient once the events come in faster than the framerate :)
13:32:31 <luite> arianvp: i changed the ghcjs scheduler yesterday to be more on-demand. it used to do a setTimeout every 20ms in an idle situation. event handlers (when the haskell action is asynchronous at least) used to add a thread to the run queue and it would get picked up the next iteration
13:32:51 <nadirs> kazagistar: I mean, mutability happens only at low level in Haskell, right? It's not like you can re-assign values or propagate side-effects "inside the high-level language"
13:32:54 * hackagebot yesod-text-markdown 0.1.3 - Yesod support for Text.Markdown.  http://hackage.haskell.org/package/yesod-text-markdown-0.1.3 (ArashRouhani)
13:33:10 <arianvp> luite: ah I was already wondering why my app kept firing setTimeout events in the profiler.
13:33:25 <Athas> nadirs: what is high-level and what is low-level?
13:33:45 <Athas> Fundamentally, all mutability happens in the IO monad, but you can package that up in wacky high-level ways.
13:34:12 <carter> Athas: AND you can use ST monad
13:34:21 <carter> to do mutable things in pure looking code to package up a faster alg
13:34:32 <jle`> the runST is pure :D
13:34:33 <Athas> Right, but the ST monad is just unsafePerformIO.
13:34:38 <luite> arianvp: but now the main loop doesn't have a spinning idle wait anymore, if thre are still runnable threads, it reschedules itself with setImmediate (or one of the alternatives in the polyfill), if there's nothing to do, it sets a setTimeout only for running finalizers, the delay is much longer (and actually can be disabled completely if a bit more work if no haskell code has been run)
13:34:47 <jle`> impelementationally perhaps, but semantically, no
13:35:02 <Athas> That's what I mean by "packaging it up".
13:35:30 <luite> arianvp: if there are delayed threads, it schedules itself when the earliest of those has to wake up (they're on a min-heap so that's easy)
13:36:33 <nadirs> Athas: I think I mean: high-level=Haskell, low-level=assembly
13:36:50 <nadirs> (assembly=compiled Haskell)
13:36:55 <luite> arianvp: so now when an event fires, it immediately runs the code for it. if it's an asynchronous handler, the thread will get preempted after the scheduling quantum and managd like other background threads
13:37:22 <Athas> nadirs: that's a weird distinction.  You can have fully observable mutation in Haskell by using IORefs and similar.
13:37:23 <carter> nadirs: asm is high level, microcode is low level :)
13:37:52 <Athas> Really, the only special part about Haskell, purity-wise, is that side effects are part of the type.
13:38:06 <Athas> Well, some side effects, anyway.
13:38:10 <kazagistar> :t writeArray
13:38:12 <lambdabot> Not in scope: ‘writeArray’
13:38:14 <Athas> Termination isn't.
13:38:47 <carter> you actually dont wanna put too much info in your types
13:38:47 <kazagistar> writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
13:38:51 <carter> or your code gets less generic
13:39:19 <carter> like, its harder to write generic code because too much info === you get less parametric
13:39:28 <arianvp> luite:  I'm probably gonna do the scheduling like : https://github.com/Raynos/main-loop/blob/master/index.js .. Just gotta find a good way to translate it to haskell
13:39:32 <luite> arianvp: so what you can do is do a synchronous callback in the animation loop, that runs the complete gui update every frame. have handlers be normal async threads. if they're fast, no background threads will happen, if they're slow, they'll yield
13:39:44 <stalintrotsky> Can I define a type variable for a data constructor?
13:39:57 <kazagistar> "given an array mutable over a monad, and index, and an element, return the monadic action that mutates that array index to that element"
13:40:02 <arianvp> hmm
13:40:07 <nadirs> Athas: I was unaware :)
13:40:22 <nadirs> carter: microcode?
13:40:31 <arianvp> luite: but you dont always have to update the gui every frame though.
13:40:46 <stalintrotsky> like if I want one of the inputs to be an element a and another to be a function that takes element a
13:41:27 <luite> arianvp: yeah you probably want to requestAnimationFrame when something has changed
13:41:30 <arianvp> luite: though I doubt it will be a real performance penalty to not just do it every frame. as in the case there is no state change, the   "patch" procedure is basically a NoOp. so I doubt it has any benifit to smartly schedule updates and just run an "update" every animation frame
13:41:48 <arianvp> luite: but still, would be more elegant to do it the good way, I guess.
13:42:07 <luite> arianvp: still it's nicer to the browser (and user, power consumption) to only do it when needed
13:42:19 <Raynos> arianvp: oh hi
13:42:30 <arianvp> Raynos: hey :-)
13:42:53 <nezt> http://benchmarksgame.alioth.debian.org/ claims that Haskell ran faster than any other language in a task of "repeatedly switching from thread to thread passing one token" does anyone know the real world implications of this?
13:42:57 <arianvp> Raynos: I'm writing bindings for your libs hehe
13:43:08 <Raynos> arianvp: really cool, let me know if I can help.
13:43:13 <luite> arianvp: unfortunately the setImmediate rescheduling of the main loop appears to hang the whole gui
13:43:24 <luite> arianvp: in firefox
13:43:31 <Raynos> arianvp: wanted to write clojurescript bindings myself :)
13:43:32 <luite> arianvp: so i might need to find a workaround for that
13:44:05 <arianvp> Raynos: clojurescript seems a really good fit for it.  Om was pretty nice,, though a bit complex due to React's way of things
13:44:08 <luite> also firefox's generational gc makes performance much worse on some of the nofib tests
13:44:42 <Athas> nezt: very low thread switching overhead.
13:44:47 <josephle> nezt: it means pthreads are slow :P
13:45:09 <Athas> That's not very representative of real-world workloads.
13:45:11 <Raynos> arianvp: remember to look at https://github.com/evancz/elm-html an elm binding to virtual-dom. Although he uses his own main loop thing in elm.
13:45:22 <luite> nezt: it means that you can write a web server running 100k connections for websockets with a different thread for each
13:45:25 <Raynos> It might have useful techniques because it has a similar haskell / js boundary
13:45:36 <arianvp> Raynos: yeh I've been stealing some of his JS code :)
13:46:04 <arianvp> Delegator();  // This manages event listeners. Somehow...
13:46:15 <arianvp> Lol.  I should probably read into the code of that
13:46:27 <arianvp>  that's from the elm-html source-code
13:47:34 <arianvp> Raynos: ah dom-delegator is your work.  So basically, all standard events get delegated by default? or?
13:47:48 <latk> I have a datatype that represents something I want to store in db. Do people generally just include a key field on that datatype, but have it as Maybe key for things that have not yet been inserted?
13:47:54 <luite> arianvp: i'm not 100% convinced that virtual dom and diffing is actually the best way to do these things
13:48:12 <Athas> nezt: also, it seems like the Haskell implementation puts every thread on the same CPU, which probably helps.
13:48:16 <arianvp> luite: how come?
13:49:58 <johnw> bitemyapp: hi
13:51:08 <luite> arianvp: since it's not an incremental data structure. updates are still based on finding changes in the output, instead of combining output from unchanged parts with new output from changed input
13:51:29 <carter> nadirs: modern intel cpus don't actually directly run x86 asm, they compile it again to a more RISC like thingy
13:51:37 <bitemyapp> johnw: hi
13:52:03 <arianvp> bitemyapp: how's the fundeps going. hehe
13:53:16 <johnw> latk: I would not include the key field
13:53:42 <johnw> latk: you would distinguish between values and labelled values (where a key is known)
13:53:49 <RchrdB> Athas, you get to choose that. IIRC, you build (or just link?) with the "-threaded" flag and run with "+RTS -N 8 -RTS" to multiplex Haskell threads (forkIO threads) across multiple pthreads.
13:53:56 <johnw> several libraries take this approach
13:54:16 <latk> johnw: How do you mean? wrap the inner type in one that also has a key, or somethign ?
13:54:26 <bitemyapp> arianvp: I had to sleep last night
13:54:31 <bitemyapp> arianvp: now I'm working
13:54:31 <latk> johnw: Or just have two types
13:54:33 <johnw> latk: that's one way.  (Key, Value)
13:54:39 <Athas> RchrdB: sure, but the code uses forkOn to ensure that all lightweight threads are scheduled to the same processor.
13:54:47 <johnw> latk: it depends on how you're going to actually use the keys and values
13:54:52 <Athas> Which means you get lower communication overheads.
13:54:53 <arianvp> I've got holidays :-)
13:54:53 <luite> arianvp: but it's probably better to make something that works ok for practical use first
13:55:01 <nadirs> carter: ah, ok. My asm knowledge is actually limited to z80 sharp :P
13:55:04 <orion> /usr/local/bin/ld: dist/build/src/cbits/hmac-sha512256/hmac-sha512256.o: relocation R_X86_64_32S against `.rodata' can not be used when making a shared object; recompile with -fPIC <-- how can I instruct cabal to build with -fPIC?
13:55:05 <Athas> Especially when only one lightweight thread is going to run at a time.
13:55:07 <carter> nadirs: happy joyes
13:55:13 <RchrdB> Athas, oh sorry, I think I missed that part of the discussion.
13:55:23 <jfeltz> is something like this possible: (a -> m b) -> m (a -> b) ? I can't seem to wrap my head around that
13:55:30 <latk> johnw: The key is pretty much just to make querying a bit easier
13:55:49 <Fuuzetsu> RyanGlScott: It'd be the right way to do it because it allows you to put additional constraints on a and b as you need them in your functions
13:56:08 <Athas> jfeltz: I think it is not.
13:56:13 <luite> arianvp: but it'd like to try/discuss some alternatives at some point :)
13:56:20 <johnw> latk: I mean, in the end it depends on what you want to do, but if you're making a library for general consumption...
13:56:40 <vanila> it's not possible, but how would we prove that?
13:56:40 <arianvp> luite: sounds fun :). Pretty sure Raynos would enjoy such a discussion as well
13:57:10 <latk> johnw: Well, most likely not - but I would like to do things the right way, where such a thing exists :p
13:57:22 <luite> arianvp: okay
13:57:25 <bergey> luite: I like the virtual DOM because it provides a simple programming model.  Maybe the StableName way makes sense as an optimazation, falling back to diff when the inputs differ?
13:57:29 <luite> hello Raynos by the way :)
13:57:44 <carter> bergey: and stablenames work again in 7.8!
13:57:46 <carter> .3
13:57:47 <carter> :)
13:58:17 <arianvp> TIL: stable-name
13:58:26 <carter> @hackage data-reify
13:58:27 <lambdabot> http://hackage.haskell.org/package/data-reify
13:58:28 <carter> and
13:58:32 <carter> @hackage data-treify
13:58:33 <lambdabot> http://hackage.haskell.org/package/data-treify
13:58:43 <carter> are really clever apis to make using stable names easier
13:58:53 <carter> *-reify is for untyped ASTs
13:59:00 <carter> treify is for reifying on typed asts
13:59:01 <johnw> latk: I can't if it's right, just what I've seen other libraries do
13:59:03 <arianvp> Maybe I should try implementing the diffing/patching in pure haskell instead of  wrapping a js-lib
13:59:11 <carter> mebe :)
14:00:02 <latk> johnw: Fair enough! I'll test to see what works.
14:01:42 <trap_exit> https://gist.github.com/anonymous/9a192d992393f1d97565 <-- how does this code compile? how does the return work since I didn't define anything as inheritng from class Monad ?
14:01:53 <trap_exit> how does return work? it looks like magic
14:02:03 <johnw> Identity is known to be a Monad
14:02:13 <johnw> it's the same as Identity (IntVal i)
14:03:01 <orion> Is anyone familiar with how to tell cabal to use -fPIC when compiling cbits?
14:03:41 <monochrom> for Identity, return x = Identity x. and it's a newtype Identity a = Identity a. it's just a wrapper over a.
14:03:47 <johnw> you'd probably say something like --cc-options "-fPIC -Wl,-fPIC"
14:04:09 <luite> bergey: yes it's close to the actual output required. but if instead you produced not a DOM but a tree that instead represents building the tree such that the trees overlap, then if you have (t1 <> t2 <> t3 <> t4) and some data producing t2 changes the renderer remembers the nodes affectd by the original t2, and can then rerender as (everythingLeftOfT2 <> t2' <> everythingRightOfT2)
14:04:40 <luite> bergey: and since (<>) is associative you can dynamically balance association to get the most efficient updates
14:04:49 <orion> johnw: That was it, thanks!
14:05:36 <arianvp> carter: Awesome :D
14:06:15 <luite> bergey: so for this example the best association would be (t1 <> t2 <> (t3 <> t4)), and that would be cached after the t2 update
14:06:54 <luite> bergey: like a splay tree
14:08:21 <luite> bergey: anyway i haven't actually worked out the required structure and replacement algorithm/effect-cache, so there could be some problems with this approach
14:09:29 <ReinH> trap_exit: you defined a type synonym for a type constructor that is already an instance of Monad. (Also typeclasses are not OO classes and instances do not "inherit from" typeclasses.
14:10:14 <trap_exit> ReinH: ah, Identity is a Monad ?
14:10:22 <trap_exit> ReinH: okay, this makes sense now :-)
14:10:23 <johnw> trap_exit: didn't I say that?
14:10:25 <ReinH> trap_exit: yes
14:10:42 <ReinH> johnw: yeah, but you used too few words :p
14:10:46 <trap_exit> johnw: you did, but I didn't see it until now, because it was missing a "trap_exit: "
14:11:04 <trap_exit> I was off reading docs until ReinH used "trap_exit:" and made my computer go *beep*
14:11:37 <Raynos> arianvp: dom-delegator listens to most events by default globally then delegates to correct listeners as defined with `'ev-click'` etc.
14:11:43 <Raynos> arianvp: maybe move discussion to #virtualdom
14:11:53 <luite> bergey: but if this works, then the replacement algorithm can always reliably identify nodes produced by unchanged data, so there's no risk of skewed matches when an item gets inserted into a list of similar items
14:12:20 <bb010g> When will GHC make an Integer computation using only (+) an Int# computation using (+#)?
14:12:31 <Raynos> luite: would love to discuss alternatives. Feel free to hang in #virtualdom
14:13:01 <luite> bergey: and for the changed data it can still diff results to minimize the actual DOM updates
14:13:14 <Raynos> arianvp, luite: if you have any haskell github projects, link me and ill watch them
14:13:21 <geekosaur> bb010g, have you considered asking in #ghc, since mobody here seems to know and it is something of a compiler internal thing?
14:13:30 <luite> Raynos: http://github.com/ghcjs/ghcjs
14:14:12 <Raynos> luite: i meant related to virtual dom or any similar UI systems to react / mercury / om / etc
14:14:19 <luite> oh :p
14:14:32 <bb010g> geekosaur: Thanks for the channel. :)
14:15:01 <luite> Raynos: the thing i described doesn't exist yet (and it might not work), but i'll link you when i have a prototype
14:16:21 <arianvp> Raynos: https://github.com/arianvp/Hom   though this is currently in Haste and I'm converting it to GHCJS
14:17:19 <bergey> luite: If it still diffs the VDOM I'm happy :)
14:19:03 <apriori> hello guys, did anyone of you succeeded in compiling gtksourceview2 on osx with quartz gtk lately? I get linking errors, because it still tries to link against gtk-x11-2.0
14:20:39 <mmachenry> I'm new to applicative parsers. Can someone verify for me that I need a monadic parser for this fromJSON parser? I want the constructor to be based off of a field, as is done in my helper function. http://lpaste.net/108448
14:21:52 <johnw> you need monadic only if a later parse depends on the result of an earlier parse
14:22:13 <glguy> In this case Aeson's parser type is a monad,so it doesn't really matter
14:22:31 <glguy> also, you can use Alternative's "empty" to fail in your parser rather than "    parseJSON _ = undefined"
14:22:58 * hackagebot tidal 0.4.8 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.8 (AlexMcLean)
14:23:04 <luite> bergey: the diff would only save work if the nodes produced are actually different, and not used by anything other than the thing where th data changed
14:24:21 <joelteon> is stringprep known to take a long time to build?
14:24:24 <joelteon> i'm at 11 minutes and counting
14:24:49 <johnw> it's doing a lot of "prep" I guess
14:25:17 <joelteon> ok, it's 2300 lines, i guess that's reasonable
14:25:24 <joelteon> cool
14:25:34 <joelteon> johnw, i set up my own hydra server, so now i get second granularity of build times
14:25:42 <johnw> oh nice
14:25:48 <johnw> can you blog about how you set it up?
14:26:05 <joelteon> oh, good idea
14:26:08 <joelteon> i haven't blogged in motnhs
14:26:09 <joelteon> months
14:26:15 <johnw> I will be your first avid reader
14:26:20 <gcganley> johnw: are you an admin i always see on here
14:26:29 <johnw> gcganley: I am both an admin, and always on here
14:27:43 <luite> bergey: for example if user :: User -> Html produced something like "<div class=user><div class=name>{{name}}</div><div class=email>{{email}}</div></div>" and the instructions looked like (userDiv <> userNameDiv <> userNameDivText <> userPasswordDiv <> userPasswordDivText) then most of those nodes would be unchanged if a user was replaced by a new user, only the text nodes would be affected
14:28:07 <gcganley> johnw: do you have a blog or a github or something of the sort?
14:28:34 <johnw> http://newartisans.com, http://github.com/jwiegley
14:29:51 <Maerten> Hi, is it possibel to use Database.Persistent with the Thyme library? I replace my Data.Time import with Data.Thyme.Time but now i get this error: No instance for (PersistFieldSql UTCTime) arising from a use of `sqlType'
14:29:56 <Maerten> possible*
14:30:03 <johnw> you'll need to create the missing instances
14:30:32 <johnw> i doubt snoyberg will add them to persistent (he doesn't want the thyme dependency), and I doubt the thyme author will add them either
14:30:57 <Maerten> hm ok
14:31:04 <johnw> you could make a thyme-instances package
14:31:12 <johnw> for the benefit of others who run into the same problem...
14:31:19 <arianvp> mmachenry: any langauge that can be described with BNF can be expressed with an applicative parser
14:31:51 <johnw> yeah, Applicative is sort of the essence of what it means to be "context-free", while monadic is context-aware
14:32:05 <arianvp> and as far as I know JSON is fully "context-free"
14:32:07 <luite> bergey: but if things come from different Haskell values and you can't see into the thing that produced them, then diffing might be the only option
14:32:13 <benmachine> Applicative is actually stronger than context-free in the presence of laziness, I've heard
14:32:14 <arianvp> so yes. parsing JSON can be done using only applicatives
14:32:15 <bergey> luite: I guess I've been picturing swapping out the type Html, or the leaf calls that produce it, with your stable-name-checker.  So I'm worried about what happens when some value x hasn't changed, but the <p> call is on (f x).  I think (f x) is repeatedly recomputed.
14:32:19 <benmachine> because you can have infinite recursion
14:32:24 <johnw> benmachine: ah, nice to know
14:32:52 <luite> bergey: yes you'd have to do (memo f) x
14:32:59 * hackagebot geodetics 0.0.1 - Terrestrial coordinate systems and associated calculations.  http://hackage.haskell.org/package/geodetics-0.0.1 (PaulJohnson)
14:33:00 <benmachine> johnw: don't call it knowledge until you've heard it from someone who knows what they're talking about :P
14:33:04 <marchelzo_> I have a Map (Int,Int) Pixel where (0,0) is the center and x and y increase as you move up and to the right. I want to transform it such that (0,0) is the top left corner and the ys get larger as you go down. I can't figure out how to do it. I tried this: http://lpaste.net/6160887658466770944
14:33:09 <luite> bergey: if you'd want to do ad hoc memoization in nodes
14:33:17 <johnw> benmachine: oh, did you just make that fact up?
14:33:29 <johnw> my friends call them "dubious facts"
14:33:33 <benmachine> johnw: no, I think it's true, but I don't remember it well enough to be sure
14:34:23 <k00mi> johnw, benmachine: http://byorgey.wordpress.com/2012/01/05/parsing-context-sensitive-languages-with-applicative/
14:34:24 <svercer> marchelzo_: what about mapKeys?
14:34:41 <johnw> k00mi: thanks!
14:35:26 <benmachine> k00mi: thanks :)
14:35:41 <marchelzo_> svercer: thanks, I didn't know about that. But the problem is that I don't really know how to transform the points in order to achieve what I want
14:35:59 <k00mi> it's pretty neat
14:37:17 <luite> bergey: but i think (or hope) that most of this can be done at an earlier level. if you have a query selecting some ranges from an IntMap, then a generic traversal can use the trie structure to walk the requested ranges, and use stablename inspection to skip unchanged parts. so then that what makes updates to IntMap efficient, sharing most of the data structure, also makes this traversal / render efficient
14:37:31 <dfeuer> I wish ghc could run on my phone. I'm not at home right now, so I can only play with rewrite rules by hand.
14:37:50 <johnw> visit tryhaskell.org
14:37:58 <johnw> oh, rewrite rules
14:37:59 * hackagebot anonymous-sums-tests 0.4.0.0 - QuickCheck functions to accompany the anonymous-sums package  http://hackage.haskell.org/package/anonymous-sums-tests-0.4.0.0 (OmariNorman)
14:37:59 <arianvp> luite: Why would you use setImmediate if we have requestAnimationFrame?
14:38:42 <luite> arianvp: the work might not be gui related
14:39:05 <bergey>      luite: OK, if you're checking the stable names higher up the call tree, I think I see where you're going.  I'll have to think more about that.
14:39:14 <bergey> luite: Thanks for explaining.
14:39:35 <mmachenry> arianvp: Thanks. Do you know how I might actually write this reasonably?
14:39:42 <mmachenry> This can't be the best way.
14:39:43 <orion> I wish cabal didn't recompile the cbits every time I wanted to run a test.
14:39:55 <arianvp> mmachenry: could you relink?
14:40:04 <trap_exit> anyone here seen jle`? I have a bone to pick
14:40:06 <mmachenry> http://lpaste.net/108448
14:40:25 <mmachenry> Notice I have an extraneous "RawMessage" type which I then convert to Message in my helper.
14:40:41 <mmachenry> I'd like to just parse directly to Message, making it an instance of fromJSON
14:40:52 <arianvp> I dont see you use any monadic code though?
14:40:54 <trap_exit> jle`: page 4 of http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf ... eval1, "eval1 env (Var n) = Map.lookup n env" has type Maybe instead of Identity
14:41:06 <mmachenry> But the fact that which constructor of Message I should use is dependent on one field in my JSON has me stumped.
14:41:46 <johnw> mmachenry: you'd say: d { x <- v .: "field"; if x == ? then ... else ... }
14:41:50 <johnw> something along those lines
14:41:54 <luite> bergey: yeah i hope that if you have an efficiently updatable pure application state, that would give you reasonably efficient way to update the render it incrementally, but i'd have to think about it more too :)
14:42:07 <trap_exit> this code is supposed to compile https://gist.github.com/anonymous/f3c1ac785a831155e91d because Map.lookup is supposed to call fail monad or somethnig like that
14:42:08 <trap_exit> however, it does not compile for me
14:42:10 <trap_exit> how do I make this compile ?
14:42:11 <trap_exit> thanks
14:42:38 <luite> bergey: but i'd be happy if you'd want to do some of the thinking :p
14:42:56 <arianvp> mmachenry: let me mess with it
14:43:28 <mmachenry> johnw: d { … } = do { … } ?
14:43:31 <bergey>  I want to write some easy GHCJS bindings first. :)
14:43:32 <johnw> yeah, sorry
14:43:43 <trap_exit> luite: ^ how do I make https://gist.github.com/anonymous/f3c1ac785a831155e91d compile? how do I get Map.lookup to use fail monad ?
14:43:45 <kini> trap_exit: you forgot your imports
14:43:47 <svercer> marchelzo_: I haven't actually tried it but maybe http://lpaste.net/6160887658466770944
14:43:48 <geekosaur> trap_exit, actually it doesn't compile because Map.lookup returns a Maybe
14:43:54 <johnw> of course you don't need braces and colons, that's just for writing it as a one-liner here
14:44:15 <geekosaur> you probably want something using the maybe combinator to do something sane when it produces Nothing
14:44:18 <trap_exit> geekosaur: so is page 4 of http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf outdated?
14:44:21 <mmachenry> johnw: I can have DO in the applicative type?
14:44:33 <johnw> trap_exit: maybe: Map.lookup <$> pure n <*> env
14:44:56 <marchelzo_> svercer: I came up with the same thing on pen and paper. I think it should work. I will try
14:45:01 <trap_exit> johnw: please assume I'm a retard and explain something simpler
14:45:33 <johnw> trap_exit: wow, you're using Haskell?  Good job!
14:45:41 <geekosaur> trap_exit, yes, I think it is. it used to be that using `fail` was considered a good idea
14:45:41 <trap_exit> screw it, I'll use "return $ fromJust $ Map.lookup"
14:45:47 <trap_exit> johnw: I am, do I get cookie?
14:45:48 <luite> trap_exit: you could make it an Alternative and use empty
14:45:53 <trap_exit> geekosaur: okay, that makes sense then
14:46:05 <Cale> trap_exit: It already uses Maybe
14:46:10 <Cale> :t Map.lookup
14:46:12 <lambdabot>     Not in scope: ‘Map.lookup’
14:46:12 <lambdabot>     Perhaps you meant one of these:
14:46:12 <lambdabot>       ‘M.lookup’ (imported from Data.Map),
14:46:14 <Cale> :t M.lookup
14:46:15 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
14:46:19 <luite> trap_exit: not sure if the rest of your structure is ok for this
14:46:24 <geekosaur> yes, but in the very old days it used m
14:46:29 <geekosaur> I remember using it back then
14:46:40 <trap_exit> luite: that is not my problem, taht is "future trap_exit"'s problem -- who cares about that gbuy
14:46:47 <geekosaur> and it called the fail method, which for Maybe was Nothing
14:47:09 <Cale> Yeah, which is bad style.
14:47:19 <MP2E> trap_exit : isn't Haskell all about ensuring your future self's sanity? :P The type system, referential transparency, etc?
14:47:36 <geekosaur> yes, which is what I said, that used to be considered good style but more experience determined that it was bad, so it was specialized to Maybe
14:47:42 <marchelzo_> svercer: success. thanks
14:48:07 <trap_exit> MP2E: I don't know haskell yet
14:48:20 <Cale> trap_exit: So, if you want, you could replace type Eval1 a = Identity a with  type Eval1 a = Maybe a
14:48:47 <MP2E> Well, I'm not expert. That wasn't a rhetorical question :P
14:48:58 <MP2E> not an expert*
14:49:01 <Cale> and that should at least make it typecheck, hopefully
14:49:23 <Cale> oh, right, you'll also have to fix up runEval1 to do something more sensible
14:49:48 <Cale> Or just pattern match a Just, and hope for the best :)
14:52:10 <trap_exit> what does the "|" in "| m -> e" in https://gist.github.com/anonymous/7a3fbec2a7c4c3ea21e1 mean ?
14:52:15 <trap_exit> it's clearly not separating consturctors
14:52:25 <kini> that is a functional dependency annotation
14:52:29 <kini> if I'm not mistaken
14:52:31 <Cale> yes
14:52:37 <MP2E> it is yes
14:52:42 <kini> pretty advanced stuff imho :) at least for me
14:52:49 <MP2E> In this case, m determines the type of e
14:52:58 <Cale> It asserts that for each type m, there is at most one type e for which there is an instance MonadError e m
14:54:05 <trap_exit> explain it like I'm 5 ... a five year old learning Haskell
14:54:06 <Cale> which means that if the compiler knows the type m, it can look for an instance of MonadError e m, and if that exists, then it can determine the type e as specified by the instance, because multiple instances for the same m won't be allowed
14:54:13 <johnw> trap_exit: omg, where are your parents??
14:54:24 <trap_exit> johnw: they're hacking on idris
14:54:24 <MP2E> hahah
14:54:25 <vanila> trap_exit, those are fundeps, not for kids
14:54:41 <vanila> like, I suggest learning some more basic things first
14:54:57 <trap_exit> I actually understand monads + basic haskell
14:55:00 <trap_exit> I'm trying to read http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
14:55:06 <trap_exit> to get monad transformers
14:55:08 <trap_exit> this example is from top of page 6
14:55:09 <vanila> oh okay, well that's more than enough prereqs
14:55:10 <kini> Cale: are functional dependencies ever really necessary, or do they just allow you to write fewer type annotations elsewhere?
14:55:14 <vanila> i think you can do transformers without fundeps
14:55:24 <vanila> yeah that paper is very good
14:55:29 <trap_exit> fundeps is a real word / term ?
14:55:35 <kini> fundeps = functional dependencies
14:55:39 <merijn> trap_exit: Short for functional dependencies
14:55:44 <johnw> kini: they are necessary unless you are willing to pass proxies everywhere
14:55:49 <Cale> trap_exit: Consider what might happen if you used catchError like:  catchError foo (\e -> bar) where bar doesn't mention e. The type e wouldn't normally be determined, so if the functional dependency weren't there, you'd get a complaint about the type e being ambiguous.
14:55:51 <ion> fundeps is rot13 for shaqrcf
14:55:57 <kini> johnw: what do you mean by "proxies"?
14:56:02 <Cale> (and hence, which instance of MonadError to use would be ambiguous)
14:56:11 <johnw> consider class MonadFoo e m | m -> e where foo :: a -> e
14:56:15 <Cale> kini: They can be pretty necessary
14:56:28 <johnw> consider class MonadFoo e m | m -> e where foo :: a -> m a
14:56:35 <johnw> in that case, you know what e is
14:56:38 <johnw> because you know what m is
14:56:52 <johnw> without the fundep, you'll get unification errors about failing to detremine that e ~ e0
14:57:06 <johnw> when using MonadFoo in places you'd expect it to work
14:57:23 <Cale> Right, it's especially important if you have operations in the class whose types don't mention one of the type variables that the class is parameterised over
14:57:36 <kini> hmmm
14:57:39 <trap_exit> o0kay okay
14:57:40 <johnw> i've been in situations where I tried hard to get by without fundeps
14:57:43 <trap_exit> so according to google
14:57:54 <trap_exit> class Blah foo1 foo2 foo3 | foo1 foo2 -> foo3 where
14:58:01 <trap_exit> just means that given foo1/foo2, type of foo3 is uniquely determined, right?
14:58:06 <Cale> right
14:58:08 <trap_exit> so it
14:58:25 <trap_exit> so it's "class Constructor_Name args | list_of_stuff -> other_type where"
14:58:28 <Cale> which means you can only write at most one instance of the class for any given (foo1,foo2)
14:58:32 <trap_exit> where given "list_of_stuff", "other_type" is uniquely determined
14:58:35 <trap_exit> is that all what fundeps is?
14:58:53 <johnw> yep
14:58:59 <Cale> You can have multiple variables before and after the arrow
14:59:00 <trap_exit> so in particular, we don't specify how the new type is determined, we just specify that it's  unique
14:59:01 <trap_exit> okay
14:59:04 <johnw> fixing one type fixes another type
14:59:10 <Cale> and you can have multiple arrows
14:59:13 <Cale> separated by commas
14:59:20 <johnw> you, even mutual dependencies
14:59:23 <johnw> s/you/yeah
14:59:39 <johnw> a -> b, b -> a; knowing either one you know the other
14:59:39 <kini> lenses probably have a bunch of those don't they
14:59:45 <johnw> they sure do
14:59:48 <Cale> a b -> c d  "a and b together determine both c and d"
15:00:13 <johnw> the question "given m, what is e" can be done with type families too
15:00:18 <johnw> but fundeps are sooo convenient
15:00:32 <johnw> because you can specify both m and e as simple arguments to the constraint
15:02:44 <mietek> @pl \n -> x !! n : []
15:02:44 <lambdabot> return . (x !!)
15:03:00 <johnw> eww
15:03:06 <johnw> return from the list monad there is really unclear
15:03:21 <johnw> even (:[]) . (x!!) would be better
15:03:23 <mietek> @unpl (: []) . (x !!)
15:03:23 <lambdabot> (\ e -> (x !! e) : [])
15:03:27 <MP2E> yeah lambdabot really traded size for readability there :P
15:03:29 <mmirman> has anybody ever used uniform buffer objects (in the form of blocks) with fragment shaders from the haskell api?
15:03:30 <glguy> "clear" isn't really the point of ?pl
15:03:47 <johnw> glguy++
15:03:58 <josephle> is the goal of pl to win at codegolf?
15:04:00 <MP2E> rename pl to golf
15:04:02 <kini> @pl \n -> [x !! n]
15:04:02 <MP2E> haha
15:04:02 <lambdabot> return . (x !!)
15:04:18 <johnw> the goal of pl is to turn functions into comprehension puzzles
15:04:20 <pqmodn__> > pl pl
15:04:22 <lambdabot>  Not in scope: ‘pl’
15:04:22 <lambdabot>  Perhaps you meant one of these:
15:04:22 <lambdabot>    ‘pi’ (imported from Prelude),
15:04:22 <lambdabot>    ‘p’ (imported from Debug.SimpleReflect),
15:04:22 <lambdabot>    ‘l’ (imported from Debug.SimpleReflect)Not in scope: ‘pl’
15:04:29 <mietek> kini: doh
15:04:46 <johnw> @obfuscate should be a synonym for @pl
15:04:46 <lambdabot> Unknown command, try @list
15:05:17 <orion> thoughtpolice: Hey there. I made some commits after submitting my pull request, and they all got pulled in to your repo. In the future I will make different branches and submit each one separately.
15:05:24 <trap_exit> hmm
15:06:54 <trap_exit> since MonadReader has "local" which does local modification
15:06:59 <trap_exit> isn't it basically a State Monad?
15:07:09 <johnw> no
15:07:14 <johnw> local isn't changing anything
15:07:16 <Cale> @pl (\a b c d e f g h i j k l m n o p q r s t u v w x y z -> s u c h g o l f)
15:07:20 <lambdabot> const (const (const . const . ((((const . const . const . (const .) . (const .)) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . ((((((const .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .)
15:07:20 <lambdabot>  . (((((((const .) .) .) .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . ((flip .) .) . (((flip .) .) .) . flip . (flip .) . ((flip .) .) . flip . (flip .) . flip flip))
15:07:20 <lambdabot> optimization suspended, use @pl-resume to continue.
15:07:23 <bitemyapp> Cale: why.
15:07:24 <johnw> it's like calling runReader within your reader
15:07:25 <vanila> lol
15:07:25 <kini> oh my god
15:07:27 <pqmodn__> yee haw!
15:07:28 <bitemyapp> Cale: WHY
15:07:36 <MP2E> Wow
15:07:49 <kazagistar> yeah, pl isn't very well behaved
15:07:54 <pqmodn__> trap_exit: consider that in reader, subcomputations cannot change the parent's state
15:07:58 <kini> dare I @pl-resume
15:08:13 <bitemyapp> kini: gooby pls
15:08:59 <ReinH> :t \a b c d e f g h i j k l m n o p q r s t u v w x y z -> s u c h g o l f
15:09:00 <lambdabot> t -> t1 -> t20 -> t2 -> t3 -> t25 -> t22 -> t21 -> t4 -> t5 -> t6 -> t24 -> t7 -> t8 -> t23 -> t9 -> t10 -> t11 -> (t19 -> t20 -> t21 -> t22 -> t23 -> t24 -> t25 -> t18) -> t12 -> t19 -> t13 -> t14 -> t15 -> t16 -> t17 -> t18
15:11:13 <sipa> :t \a b c d e -> d b
15:11:15 <lambdabot> t -> t4 -> t1 -> (t4 -> t3) -> t2 -> t3
15:15:31 <Cale> How to make the typechecker consume lots of space:  let l = (\a b c d e f g h i j k l m n o p q s t u v w x y z r -> r (t h i s i s a f i x e d p o i n t c o m b i n a t o r)); y = l l l l l l l l l l l l l l l l l l l l l l l l l l in y
15:16:05 <hpc> there's also fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap ...
15:17:07 <vanila> :t \a b c d e f g h i j k l m n o p q s t u v w x y z r -> r (t h i s i s a f i x e d p o i n t c o m b i n a t o r)
15:17:08 <lambdabot>     Occurs check: cannot construct the infinite type:
15:17:08 <lambdabot>       t19
15:17:09 <lambdabot>       ~
15:17:53 <Cale> Yeah, it's obviously supposed to be a type error, and if you just typecheck the 'l' bit, then you get to that error quickly.
15:17:59 <bb010g> @unpl fmap (<*>) (.) . (.) <$> const
15:18:00 <lambdabot> : -1: -1:Ambiguous infix expression
15:18:08 <bb010g> @unpl fmap (<*>) (.) . ((.) <$> const)
15:18:09 <lambdabot> (\ j -> fmap (<*>) (\ a b c -> a (b c)) (((\ d e f -> d (e f)) <$> \ g _ -> g) j))
15:18:13 <vanila> ohh
15:18:21 <Cale> (it actually works as a fixed point combinator in untyped lambda calculus though)
15:18:23 <vanila> I tought it was a fixed point combinator like y
15:18:27 <Cale> (the y does)
15:18:34 <Exio> @unpl (.).(.)
15:18:36 <lambdabot> (\ i b c f -> i (b c f))
15:18:37 <Cale> y won't typecheck without help either
15:18:47 <vanila> ah, makes sense>
15:18:59 <Cale> :t (\f -> (\x -> f (x x)) (\x -> f (x x)))
15:19:01 <lambdabot>     Occurs check: cannot construct the infinite type: t0 ~ t0 -> t
15:19:01 <lambdabot>     Expected type: t0 -> t
15:19:01 <lambdabot>       Actual type: (t0 -> t) -> t
15:19:23 <Cale> However, you can define a type like...
15:19:30 <Exio> datatypes to the rescue?
15:19:51 <Cale> newtype Rec a = In { out :: Rec a -> a }
15:19:53 <Cale> > newtype Rec a = In { out :: Rec a -> a }
15:19:54 <lambdabot>  <hint>:1:1: parse error on input ‘newtype’
15:20:00 <Cale> > data Rec a = In { out :: Rec a -> a }
15:20:02 <lambdabot>  <hint>:1:1: parse error on input ‘data’
15:20:07 <Cale> oh, right, @let
15:20:13 <Cale> @let newtype Rec a = In { out :: Rec a -> a }
15:20:14 <lambdabot>  .L.hs:150:27:
15:20:14 <lambdabot>      Ambiguous occurrence ‘Rec’
15:20:14 <lambdabot>      It could refer to either ‘L.Rec’, defined at .L.hs:150:1
15:20:14 <lambdabot>                            or ‘Lambdabot.Plugin.Haskell.Eval.Trusted.Rec’,
15:20:14 <lambdabot>                               imported from ‘Lambdabot.Plugin.Haskell.Eval.Tr...
15:20:21 <Cale> ah, already defined
15:20:27 <Cale> :t In
15:20:28 <lambdabot> f (Mu f) -> Mu f
15:20:30 <Cale> :t InR
15:20:32 <lambdabot> (Rec a -> a) -> Rec a
15:20:35 <Cale> aha
15:21:05 <Exio> wow
15:21:11 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
15:21:13 <lambdabot>  3628800
15:21:17 <Exio> who would have said that was defined
15:21:43 <Cale> :t outR
15:21:44 <lambdabot> Rec a -> Rec a -> a
15:21:57 <Cale> InR and outR are isomorphisms between Rec a and (Rec a -> a)
15:22:16 <Cale> which are no-ops at runtime
15:22:40 <Cale> and by sticking them into the y combinator appropriately, we can get it to typecheck
15:23:47 <Cale> So, recursion at the type level can be used to recover recursion at the value level.
15:25:22 <johnw> kini: a proxy is a value (it can be unevaluated, so just "undefined" works) which carries the type you need to know about
15:25:35 <kini> ah, ok
15:25:36 <johnw> kini: the tagged package makes working with proxy about as painless as it can get
15:25:41 <kini> that makes sense
15:25:47 <kini> yeah actually I think I remember seeing Proxy before
15:25:50 <johnw> but at the simplest: foo :: a -> proxy e -> m a
15:25:53 <johnw> now e is fixed
15:26:15 <johnw> the call would be: foo a (undefined :: proxy Int), and now e ~ Int
15:26:27 <kini> gack, lol
15:26:34 <kini> let's have dependent types so I can just do "foo a Int" :P
15:29:17 <NetDandy> I might be wrong, but you just need GADTs for that type
15:29:26 <NetDandy> or is that not a type?
15:30:12 <johnw> this is for typeclass methods
15:30:16 <johnw> where 'e' needs to be fixed
15:30:29 <dolio> This is orthogonal to dependent types.
15:30:53 <vanila> you could do  foo :: a -> e -> proxy e -> m a
15:31:00 <vanila> and then pass in (undefined :: Int)
15:31:11 <johnw> well, in that case you don't need the proxy
15:31:26 <johnw> naming it "proxy e" just makes it clear in the type that foo doesn't need an 'e' value
15:31:38 <johnw> you could use an unused 'e' argument, sure
15:31:40 <vanila> oh sorry, we were saying the same thing then
15:32:22 <johnw> generally proxy here means that it carries type information only, no value
15:32:35 <vanila> I see - cool
15:33:30 <kini> dolio: I just meant that I would like to literally pass the type Int into a function, rather than (undefined :: Proxy Int)
15:33:31 <kini> I don't think there's any way you can do that without dependent types, right?
15:33:43 <kini> I mean, proxies work fine too
15:33:48 <aphury> I want to split up my project into several files, but ghc complains about „module main:Main is defined in multiple files“ what am I doing wrong?
15:33:48 <dolio> Doing that has nothing to do with dependent types.
15:33:55 <kini> not a question of expressive power or anything, just beauty of notation
15:33:56 <glguy> If you're going to be using the actual "Proxy" type, then use: Proxy :: Proxy Int
15:34:10 <dolio> It has to do with not having explicit quantification over types for your polymorphism.
15:34:17 <benmachine> passing types to values is different from passing values to types
15:34:29 <kini> ah, I see
15:34:33 <glguy> If you're satisfying a lowercase "proxy"' you can use Proxy, or even just "Nothing :: Maybe e"
15:34:34 <benmachine> isn't GHC getting explicit type application at some point in the future?
15:34:48 <kini> yes, I remember reading about that!
15:34:49 <kini> 7.10 even
15:34:52 <dolio> People have been talking about it.
15:35:26 <kini> right, of course. Passing types to values is just explicit forall specialization, isn't it :) Sorry, I was confused!
15:36:11 <monochrom> in the limit, GHC will support {-# LANGUAGE SystemFomega #-} and let you write in System F omega directly :)
15:36:25 <pqmodn__> yesssss!
15:36:33 <benmachine> {-# LANGUAGE Agda #-} -- why settle for half measures >_>
15:36:58 <monochrom> {-# LANGUAGE Agda #-} would complete the cycle
15:36:59 <vanila> What about mixing Agda and haskell together?
15:36:59 <josephle> benmachine: one day we can even have {-# LANGUAGE HoTT #-}!
15:37:10 <vanila> could that be possible
15:37:14 <josephle> gotta have that univalence
15:37:23 <benmachine> vanila: yes, I believe that's possible
15:37:29 <vanila> today?
15:37:33 <dolio> Agda has an ffi to Haskell.
15:37:38 <benmachine> vanila: as long as you don't ask me how to do it :)
15:37:50 <vanila> lol
15:37:53 <vanila> that's really cool though
15:38:04 <ReinH> vanila: may I PM you? It will be civil, I promise.
15:38:08 <vanila> please do
15:38:47 <johnw> ok, now I'm curious ReinH
15:39:07 <monochrom> it's just a vanilla PM
15:39:27 <johnw> R rated at least, for ReinH
15:40:44 <zereraz> hello, how to print each element of a list on different lines, like [1,2,3]
15:40:45 <zereraz> 1
15:40:45 <zereraz> 2
15:40:46 <zereraz> 3
15:41:05 <johnw> mapM_ print
15:41:39 <zereraz> ok thanks
15:45:51 <pavonia> @src print
15:45:51 <lambdabot> print x = putStrLn (show x)
15:50:44 <ReinH> johnw: I was rude earlier, so the caveat was important :/
15:50:50 <johnw> ah, ok :)
15:51:03 <ReinH> monochrom: I see what you did there
15:51:11 <monochrom> heh heh heh
15:51:12 <johnw> it sounds like a movie: "ReinH, On the Edge of Vanilla"
15:52:17 <kini> it seems like typeclasses can both allow client code to implement stuff for library code, and library code to implement stuff for client code, at the same time
15:52:19 * benmachine curious and scrolls up a couple of hours
15:52:28 <kini> feels kind of magical
15:52:47 <zereraz> hello can some one tell me what is wrong here http://lpaste.net/108453  , error is parse error on '|' , am I using guards right?
15:52:58 <vanila> ReinH, I don't think you were rude at all earlier :)
15:53:06 * hackagebot tidal 0.4.9 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.9 (AlexMcLean)
15:53:11 <ReinH> vanila: you don't get to tell me what I think! ;)
15:53:17 <kini> zereraz: you can't write that let before the guard afaik
15:53:19 <vanila> lol
15:53:35 <zereraz> kini: even if did not
15:53:47 <zereraz> 'if' was giving error too
15:54:07 <kini> if?
15:54:18 <zereraz> kini: I changed from guard to 'if'
15:54:24 <zereraz> kini: even then I got parse error
15:54:47 <zereraz> kini: so what do I do to make this work? remove let
15:55:22 <johnw> kini: it's helpful to try working with type classes without typeclasses
15:55:37 <johnw> you just pass around a record of functions
15:55:58 <zereraz> kini: I tried doing without let, still getting error
15:56:26 <johnw> fo example, foo :: MonadRecord Foo -> Foo a, where data MonadRecord m = MonadRecord { return' :: a -> m a }
15:56:40 <geekosaur> zereraz, you have to use a where clause after the guard, not a let before it
15:56:54 <johnw> then to call foo, you need to construct a MonadRecord, which is similar to what GHC does when it looks up an appropriate instance
15:57:05 <zereraz> geekosaur: what to do in the where?
15:57:13 <geekosaur> what you're doing in the let
15:57:17 <johnw> fooMonad = MonadRecord { return' = fooReturn }, etc.
15:57:23 <geekosaur> the difference is that stiuff defined in where is visible in guiards
15:57:28 <kini> zereraz: http://lpaste.net/108453
15:58:01 <zereraz> ok got it thanks allot!!
15:58:15 <kini> notice that I changed the type signature of check3Or5 as well
15:58:55 <zereraz> yeah ok
15:59:04 <zereraz> also what if I am not using let
15:59:14 <zereraz> | (n-1)`mod`3 == 0 || (n-1)`mod`5 == 0 = print a
15:59:26 <zereraz> then I won't need where
15:59:27 <kini> that should be fine too
15:59:31 <zereraz> its not working
15:59:40 <kini> you probably have an extra equals sign on the previous line
16:00:00 <Tekmo> merijn: Hey, are you here?
16:00:24 <zereraz> oh yeah
16:00:32 <zereraz> kini: why do we remove the function =
16:00:49 <kini> zereraz: the form of a function definition with guards is, LHS | guard = RHS
16:00:54 <kini> not LHS = | guard = RHS
16:01:10 <zereraz> kini: ok thanks!
16:01:13 <kini> sure :)
16:01:43 <kini> johnw: I'm thinking of default implementations of class functions
16:02:21 <kini> like, by defining a typeclass with a few class functions that need an implementation, and then a bunch more where you provide the implementation in terms of internal functions in the module exporting the typeclass
16:02:24 <kvanb> Tekmo: hello
16:02:30 <ijp> can anyone here explain to me what is meant by "contravariant" recursion?
16:03:07 <kvanb> and my apoligies for spamming the list; it was early and I misread the question.
16:07:36 <zereraz> can someone tell me why this is slow http://lpaste.net/108456 , I am solving a question and it is exceeding its time limit
16:08:02 <kvanb> zereraz: first thing is first, don't use replicateM
16:08:06 <kvanb> it has a space leak I think
16:08:21 <zereraz> kvanb: then how to take multiple inputs?
16:08:27 <zereraz> recursive functions
16:08:43 <merijn> Tekmo: Hey, yeah, but not for very long
16:08:47 <zereraz> and I think list comprehension is also making it slow
16:08:55 <Fuuzetsu> ijp: there are contravariant types which can be recursive if that's what you mean
16:09:06 <kvanb> zereraz: your numbers are not very big are they?
16:09:13 <kvanb> I'd say leave it as it is, it's probably not a bottleneck.
16:09:29 <kvanb> Second thing, change all your `mod`s to `rem`
16:09:36 <zereraz> kvanb: they are big
16:10:01 <zereraz> why is rem faster?
16:10:10 <glguy> zereraz: You don't actually need to sum up the numbers from 1..n
16:10:22 <glguy> zereraz: You can compute the answer with a little bit of math
16:10:26 <kludgy> bitemayapp: Beautiful way to express the problem. The exercise always seems to be finding these nicely closed free forms, no?
16:10:46 <kvanb> zereraz: rem is sometimes faster iirc because it doesn't have a branch for the negative case
16:10:50 <zereraz> glguy: I need to sum all those divisible by 3 or 5
16:11:01 <zereraz> kvanb: oh nice
16:11:03 <glguy> zereraz: that's fine, you can still compute the answer
16:11:11 <kludgy> bitemyapp: also I need to learn how to computer. That was meant for response in #haskell-beginners
16:11:11 <zereraz> glguy: how?
16:11:28 <ijp> Fuuzetsu: well, the term is only used in passing in this paper by Gibbons and Wu "We consider here just polynomial algebraic datatypes....Thus, we rule out contravariant recursion, polymorphic datatypes, higher kinds and other such esoterica"
16:11:30 <glguy> zereraz: That's the puzzle :)
16:11:51 <ijp> I figured someone on here would know
16:12:13 <Fuuzetsu> I'm guessing they mean contravariant type recursion
16:12:24 <glguy> The only reason not to use replicateM here is if the list of inputs is huge and you want to process htem as you get them instead of after you've read them all in
16:12:24 <zereraz> glguy: are you saying that I should not sum or approach this in a different way?
16:12:26 <ijp> Fuuzetsu: so types like data Foo = Bar (Foo -> Int) ?
16:12:34 <benmachine> ijp: that's what I would assume
16:12:40 <ijp> right, gotcha
16:13:01 <glguy> zereraz: If you want a fast solution to that take you won't use sum. How big are the arguments they are giving you and how many are they giving?
16:13:07 <zereraz> what alternative is there to replicateM, should I make a recursive function
16:13:19 <benmachine> the replicateM is not your biggest problem
16:13:23 <benmachine> don't worry about it for now
16:13:26 <glguy> replicateM isn't the issue
16:13:31 <glguy> mod/rem isn't the issue
16:13:38 <zereraz> how many 10^5 , how big 10^9
16:14:26 <glguy> That's too many to be using sum
16:14:34 <glguy> you're expected to find a closed form solution
16:14:52 <zereraz> glguy: what does that mean?
16:14:55 <kvanb> it fuses ok
16:15:05 <kvanb> problem is with the algorithm
16:15:18 <benmachine> zereraz: it means find a different way to get the answer
16:15:27 <zereraz> benmachine: ok
16:15:33 <benmachine> zereraz: like, suppose I told you to find the sum of 700 copies of the number 5
16:15:40 <benmachine> you would not do 5 + 5 + 5 + ... + 5
16:15:48 <zereraz> 700*5
16:15:51 <benmachine> right
16:15:58 <zereraz> ok
16:16:40 <benmachine> so you need to do some maths to find a simpler or faster way of doing your sum
16:16:40 <Fuuzetsu> @define data Foo = Bar (Foo -> Int)
16:16:43 <lambdabot>  Defined.
16:16:59 <zereraz> benmachine: I have a list, should I not create one?
16:17:16 <Fuuzetsu> :t let f (Bar x) = x (Bar x); g = f (Bar f) in g
16:17:17 <lambdabot> Int
16:17:40 <zereraz> any clue?
16:17:46 <glguy> zereraz: Maybe search for the phrase: sum of arithmetic progression
16:17:53 <kvanb> > 31 `div` 30
16:17:55 <lambdabot>  1
16:17:58 <zereraz> glguy: got it
16:17:59 <glguy> zereraz: and then only read as much as you want
16:18:06 <zereraz> I should have thought of that
16:18:09 <kvanb> > 31 `quot` 30
16:18:11 <lambdabot>  1
16:18:20 <zereraz> its an ap
16:18:30 <benmachine> kvanb: they're only different for negative inputs
16:18:34 <Fuuzetsu> there's an `ap` for that ;)
16:18:35 <Tekmo> merijn: Oops, sorry I missed you again
16:18:41 <merijn> Tekmo: No worries :)
16:18:42 <Tekmo> merijn: I just wanted to help you with your pipes-parse issue
16:18:46 <johnw> hiya Tekmo
16:18:53 <Tekmo> merijn: I figured it would be easier to explain in person than over e-mail
16:18:58 <johnw> i've been pondering your FoldM type more
16:19:02 <Tekmo> johnw: Hi!
16:19:05 <kvanb> oh gosh it was merijn on the list. I feel worse now.
16:19:08 <glguy> zereraz: It's just a little more complicated than a single arithmetic progression. Come back if you get stuck
16:19:20 <ReinH> Tekmo: hai
16:19:22 <glguy> zereraz: But it'll be more fun to read and learn about it than for us to tell you the answer :)
16:19:23 <zereraz> glguy: I realized its not just an ap :( , but I will try
16:19:26 <merijn> Tekmo: Initially I thought you meant just running "runEffect" inside the eventual Producer, but I don't see that working without needing to move all the socket writing logic in there as well
16:19:33 <dfeuer> I'm still looking for actual applications of scanr and scanl in real life. Anyone presently here know of such? I see one scanl in the GHC type checker and no scanrs.
16:19:35 <zereraz> glguy: agreed!
16:19:46 <Tekmo> merijn: So the issue is that you can represent your left-overs passing computation as a `StateT`, but pipes-parse doesn't provide tools for working with values of type `StateT (Producer i m r) (Producer o m) r`
16:19:50 <ReinH> dfeuer: for some value of "real life":
16:19:53 <ReinH> > let fibs = fix ((0:) . scanl (+) 1) in fibs !! 5
16:19:54 <ReinH> ;)
16:19:55 <zereraz> thanks!
16:19:55 <lambdabot>  5
16:20:01 <Fuuzetsu> dfeuer: I think there's a scan in Haddock parser atm
16:20:05 <bmuk> I'm running out of memory running cabal install cabal-install :/
16:20:27 <Tekmo> merijn: For intermediate transformations (i.e. lenses or functions from producers to producers) you have to mainly settle for explicit passing of the `Producer`-based leftovers
16:20:38 <Fuuzetsu> oops, just scan, no scan(l|r)
16:20:47 <Tekmo> merijn: It's possible to simplify that using `StateT`, but I haven't yet figured out what are the right idioms for that
16:21:01 <Tekmo> merijn: You can't reuse the existing `Parser`-based idioms for these intermediate transformations
16:21:01 <benmachine> dfeuer: I don't think I've ever seen a scanr in the wild, but I feel like scanl isn't so rare
16:21:13 <merijn> Tekmo: Yeah, but even ignoring the whole frame decoding bit I still don't know what the basic outline would work with pipes-parse
16:21:14 <benmachine> dfeuer: well. scanl isn't exactly common, but I've seen it ever
16:21:17 <benmachine> hmm
16:21:39 <jfischoff> dfeuer: scans are useful for windowed computations (running average, etc)
16:21:39 <Tekmo> merijn: Let me open up your code again to refresh my memory on the specifics
16:22:00 <Tekmo> merijn: Oh, okay
16:22:05 <Tekmo> merijn: So here's the basic outline
16:22:11 <jfischoff> scanr works with infinite lists (I assume)
16:22:18 <Tekmo> merijn: YOu know how you were threading a `ByteString` leftovers throughout your old program, right?
16:22:24 <merijn> i.e. if I consider just the handshake, if I don't have a Proxy in my monad stack, so just "Parser ByteString m Whatever" then I don't know how to communicate intermediate output out of the handshake again
16:22:28 <merijn> Tekmo: Yeah
16:22:36 <benmachine> > take 30 . fix $ \xs -> 0 : scanl (+) 1 xs -- this counts, right
16:22:38 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
16:22:38 <dfeuer> jfischoff: that's great ... theory. I am looking for practice, with which to benchmark different scanr and scanl implementations.
16:22:40 <Tekmo> merijn: The main difference in `pipes-parse` is that instead of threading a `ByteString` you thread a `Producer ByteString m r`
16:23:00 <Tekmo> merijn: That `Producer ByteString m r` is basically all the unconsumed input from your socket
16:23:09 <Tekmo> merijn: The way you undraw input is to prepend values onto that producer
16:23:10 * hackagebot messagepack-rpc 0.1.0.1 - Message Pack RPC over TCP  http://hackage.haskell.org/package/messagepack-rpc-0.1.0.1 (rodrigosetti)
16:23:25 <kvanb> when there is intermediate input the producer is put back something like this; p >> old where p is the remainders and old is what was there before
16:23:33 <benmachine> dfeuer: my friend's birthday present has a scanl in it
16:23:38 <merijn> Tekmo: Right, but my initial StateT with bytestring had a Pipe in the monad stack to yield bytestring's downstream during the parsing
16:23:45 <Tekmo> merijn: Right, and you can still do that
16:23:46 <benmachine> not exactly what you'd call industry code but it is at least a program that does something
16:24:10 <kvanb> benmachine: I love scanl because it's so hard to do clever things with it
16:24:11 <Tekmo> merijn: The difference is that instead of a `Pipe` to yield stuff downstream you will use a `Producer`
16:24:11 <merijn> Tekmo: But then I force my input producer (and thus leftovers) to also have a Proxy in their stack, no?
16:24:25 <Tekmo> merijn: Correct
16:24:28 <benmachine> purpose: given a list of words, find out how many of them you can take while remaining under n characters
16:24:28 <Tekmo> merijn: That's the ugly part
16:24:32 <merijn> i.e. that's what happened in my initial email
16:24:34 <kvanb> @message lambdabot > scanl 1 . (+1) $ 3
16:24:34 <lambdabot> Maybe you meant: messages messages-loud messages?
16:24:41 <kvanb> @botsnack
16:24:42 <lambdabot> :)
16:24:48 <merijn> And I don't know how to unwrap that, I don't think that's even possible?
16:24:50 <Tekmo> merijn: This only happens if you use the `Parser` type synoym
16:24:57 <zereraz> I found a pattern
16:25:15 <zereraz> 2131 233
16:25:20 <zereraz> this repeats
16:25:31 <Tekmo> merijn: One second
16:25:33 <zereraz> I checked till 40
16:25:41 <benmachine> zereraz: what does that mean
16:25:45 <zereraz> oh
16:25:47 <merijn> Yeah, I guess I could just use my own StateT synonym, but then I lose the ability to interact with all the rest of the pipes-parse ecosystem, no?
16:25:53 <zereraz> its difference of consecutive numbers
16:25:56 <benmachine> oh right
16:26:05 <merijn> Tekmo: i.e. pipes-binary, et al. accept/return Parsers
16:26:07 <zereraz> am I right?
16:26:17 <benmachine> I don't know, haven't thought about it
16:26:33 <benmachine> I know that in general there are patterns that seem to be true initially and turn out not to be
16:26:40 <Tekmo> merijn: So in the `Parser` type, it mandates that the base monad of the `Producer` leftovers matches the base monad of the parser
16:26:44 <dfeuer> Joachim Breitner found a great way to use scanl' to implement inits, but I don't know who uses that either (and scanl' isn't in Data.List (yet)).
16:26:49 <benmachine> you should try to show that your pattern always happens, instead of just checking that it does sometimes
16:26:52 <Tekmo> merijn: However, this doesn't work if the `Parser` wants to yield things further downstream
16:26:52 <benmachine> do some algebra
16:26:57 <benmachine> or some clever thinking, either way
16:27:04 <Tekmo> merijn: The solution is to define a new parser type synonym that correctly matches the monad
16:27:08 <Tekmo> merijn: Let me write it out for you
16:27:10 <zereraz> benmachine: first I will try to see if this works
16:27:32 <zereraz> I could use cycle
16:27:33 <Tekmo> merijn: type Parser' i o mr = StateT (Producer i m r) (Producer o m) r
16:27:40 <Tekmo> merijn: That's the type synonym you want to use
16:27:44 <merijn> Tekmo: Right, so I already thought about doing "StateT (Producer ByteString (SafeT IO) r) (Producer ByteString (SafeT IO)) r", etc.
16:28:11 <merijn> Tekmo: Isn't the problem that m is still the same in both cases?
16:28:43 <Tekmo> merijn: Well, you can make them different if you want
16:28:54 <Tekmo> merijn: Just add another type parameter `n` to that parser type
16:29:11 <Tekmo> merijn: Oh, I see what you are asking
16:29:23 <merijn> Tekmo: Right, but then I lose all my ability to interact with anything written for pipes-parse, no?
16:29:24 <Tekmo> merijn: You want to know how to obtain the leftovers when the base monads don't match
16:29:42 <merijn> Yeah
16:29:44 <Tekmo> merijn: Give me a second to study your code again.  Just a second
16:30:16 <Tekmo> merijn: So why do the base monads not match?
16:30:31 <Tekmo> merijn: Shouldn't they both be `ReaderT SockConfig (SafeT IO)`?
16:32:16 <tejing> can someone explain to me why fix (\(_,x)->(x,1)) doesn't return? it seems like it should
16:32:56 <orion> Why is Maybe an Applicative and Either a Monad? Why can't Either be a Monad too?
16:33:02 <tejing> fix (\x->(snd x,1)) does, however
16:33:07 <Tekmo> orion: Either is a Monad, too
16:33:11 <Tekmo> orion: import Control.Monad.Instances
16:33:30 <merijn> Tekmo: Well, that config + the ability to output ByteStrings is really only needed for the handshake. After the handshake I just have a separate producer and consumer for reading from/writing to the socket, which I hook up to my application code, which is just a Consumer/Producer for Frame's, I guess I can superfluously wrap them with "ReaderT SockConfig", and do "runReaderT undefined"
16:33:31 <Tekmo> orion: There are a lot of people who strongly believe that the `Either` `Monad` instance should be imported by default
16:34:36 <Tekmo> merijn: Note that you can wrap it in `ReaderT SockConfig` after the fact
16:35:03 <Tekmo> merijn: hoist lift :: Producer a (SafeT IO) r -> Producer a (ReaderT SockConfig (SafeT IO)) r
16:35:28 <Tekmo> merijn: You can apply `hoist lift` at the last moment
16:35:45 <orion> err
16:35:51 <orion> Why can't Either be an Applicative?
16:35:57 <Tekmo> orion: It's an Applicative, too
16:36:09 <orion> I see.
16:36:17 <merijn> Tekmo: Yeah, but then I still don't have a valid SockConfig to pass to that, as only the handshake cares about that. hmm, maybe it'd work to hoist the ReaderT out on top of the StateT?
16:36:26 <Tekmo> orion: import Control.Applicative to get that instance, I think
16:36:38 <orion> Tekmo: thank you
16:36:41 <Tekmo> orion: You're welcome
16:37:06 <Tekmo> orion: If you feel that these instances should be imported by default, the appropriate place to complain is the libraries mailiing list (libraries@haskell.org or something like that)
16:37:50 <merijn> So instead I do "ReaderT SockConfig (Parser ByteString (Producer ByteString (SafeT IO))) r", although I'm not sure that doesn't run afoul of needing ImpredicativeTypes...
16:37:54 <Tekmo> merijn: So remind me, is the input producer (the leftovers) the one with the ReaderT layer or is it the output producer?
16:38:30 <Tekmo> merijn: Actually, I have to head out at the moment.  Will you be on again tomorrow afternoon?
16:38:37 <merijn> 1 sec, lemme try this, it might just disappear all my problems
16:38:52 <merijn> Tekmo: Yeah, I'm generally around almost all day, with various degrees of responsiveness :)
16:39:09 <Tekmo> merijn: Alright
16:39:20 <Tekmo> merijn: I will catch you again tomorrow, then.  Sorry for the delays in responding
16:41:22 <kludgy> tejing: interesting
16:41:33 <merijn> Tekmo: No worries, thanks for the help! :)
16:46:34 <Luonnon> Does anyone have any favorite Github repos that exhibit really good, clean code?
16:47:24 <vanila> not github but check out ReadP
16:47:33 <dwcook> tejing, not sure, but you might find the behavior of this interesting as well: fix (\(~(_,x))->(x,1))
16:48:10 <MitchellSalad> Luonnon: check out xmonad source, i hear it purdy
16:48:53 <benmachine> tejing: seems like to call the lambda forces a pattern-match on the tuple, which forces its evaluation up to the tuple constructor
16:49:20 <benmachine> tejing: which makes that lambda strict, which means that fix returns ⊥
16:50:02 <Luonnon> Those two should be good for some bedtime reading.  Thanks!
16:54:48 <tejing> I guess I've gotten too used to the pervasive laziness of haskell... I didn't realize pattern matches were strict by default
16:56:44 <ReinH> tejing: pattern matching is the thing that causes lazy values to be evaluated, basically.
16:56:59 <enthropy> > let Just () = Nothing in 2
16:57:01 <lambdabot>  2
16:57:58 <tejing> ReinH: well that and output :-)
16:58:11 <ReinH> tejing: right, but how does output happen? ;)
16:58:25 <carter> ReinH: its a bit more subtle as enthropy  points out
16:58:54 <trap_exit>  on s sclae of 1 to 10, where 1 = "main = return ()" and 10 = simon peyton jones, does understanding moands + monad transformers put me at 1.5 or 1.6 ?
16:59:06 <ReinH> enthropy: what is happening there?
16:59:12 <ReinH> Ah.
16:59:21 <enthropy> case and lambdas are strict, let/where are not
16:59:32 <dwcook> trap_exit, is this a log scale or…?
16:59:45 <enthropy> > let x @ (Just ()) = Nothing in x `seq` 2
16:59:47 <lambdabot>  *Exception: <interactive>:3:5-27: Irrefutable pattern failed for pattern x@(...
16:59:57 <ReinH> enthropy: the let desugars into a lambda, and nothing evaluates the lambda?
17:00:00 <trap_exit> dwcook: this is definitely log scale
17:01:16 <ReinH> trap_exit: an 8 so you're only 2 orders of magnitude less knowledgeable than SPJ? ;)
17:02:25 <orion> Are type families dangerous?
17:02:29 <trap_exit> is this base 2 or base 10 order of magnitude ?
17:02:30 <enthropy> ReinH: what does the desugared to lambda version look like to you?
17:03:15 * hackagebot strive 0.6.0 - A Haskell client for the Strava V3 API.  http://hackage.haskell.org/package/strive-0.6.0 (fozworth)
17:03:17 * hackagebot diagrams-qrcode 1.2 - Draw QR codes to SVG, PNG, PDF or PS files.  http://hackage.haskell.org/package/diagrams-qrcode-1.2 (FelipeLessa)
17:04:09 <tejing> enthropy: (\x@(Just ())->x `seq` 2) Nothing
17:04:26 <trap_exit> so is the writer monad basically like alogging monad, but it only logs the last item ?
17:04:47 <carter> trap_exit: no
17:04:53 <dfeuer> Uh-uh.
17:04:53 <hpc> it "adds" the "log entries"
17:04:53 <carter> it has a monoid constraint right?
17:05:00 <hpc> for strings, that's concatenation
17:05:08 <hpc> (for lists in general)
17:05:09 <carter> there no semantical requirement of "ordering"
17:05:13 <trap_exit> runWriter :: Writer w a -> (a, w) <-- so why is the output w, not [w] ?
17:05:14 <carter> in the associated monad
17:05:16 <hpc> for other things it could be something else
17:05:24 <carter> :t mappend
17:05:25 <lambdabot> Monoid a => a -> a -> a
17:05:40 <enthropy> tejing: yeah, but what about the earlier version that's missing the 'x'?
17:05:47 <Fuuzetsu> > 0x20
17:05:49 <lambdabot>  32
17:06:02 <Fuuzetsu> hm, I thought that was only coming with an extension in the future
17:06:12 <Fuuzetsu> or am I thinking of b01010110 format
17:06:19 <enthropy> > 1e10 :: Integer
17:06:21 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
17:06:21 <lambdabot>    arising from the literal ‘1e10’
17:06:34 <hpc> > 0b101
17:06:35 <lambdabot>  Not in scope: ‘b101’
17:06:36 <MP2E> Fuuzetsu: you're thinking of binary literals, yeah
17:06:43 <Fuuzetsu> ok
17:07:05 <dfeuer> Monoid instances had $&^* well better be real monoids.
17:07:31 <dfeuer> Sorry, sidetracked.
17:07:45 <ReinH> enthropy: generally, let f x = y in z <=> (\f -> z) (\x -> y), right?
17:08:16 * hackagebot semigroupoids 4.2 - Semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-4.2 (EdwardKmett)
17:09:28 <kvanb> does anyone know how to  get the type of a function in a where
17:09:51 <kvanb> which can't be pulled out because it has a really fat usage of its parents arguments and stuff
17:10:09 <merijn> kvanb: Use something like hdevtools/ghc-mod to query the type from GHC
17:10:12 <kvanb> I thought 7.8 had some form of type level holes, but I can't find anything about it
17:10:19 <kvanb> merijn: does that work if it's not top level?
17:10:55 <merijn> kvanb: Works with arbitrary expressions, vim and emacs both have plugins for them (as do some other popular editors, most likely, but I'm not familiar with those)
17:11:20 <Snail__> ello, I have a question
17:11:24 <merijn> kvanb: hdevtools use the GHC API to run your code through GHC and query the types of arbitrary expressions, including local functions, etc.
17:11:25 <tejing> enthropy: let seems to desugar to a lambda with a lazy pattern match
17:11:38 <dfeuer> You can also -ddump-types; not sure if that gives you what you need.
17:12:04 <jesyspa> You can always put a (myfun :: ()) in somewhere and look at the "could not unify" error.
17:12:53 <orzo> in stateful build algorithms, it is common to have an accumulator object.  In functional coding, it is common to have a not-yet-processed remainder object that shrinks to nothing at finish.  Is there any idiomatic name for that vanishing input object?
17:12:56 <kvanb> ddump types is a cool trick but it doesn't dump stuff in where
17:13:01 <dfeuer> One problem with the type hole approach: it will sometimes be able to tell you what type *should* be there, but not what type *is* there.
17:13:02 <tejing> enthropy: so 'let pat = expr1 in expr2'  becomes '(\~(pat) -> (expr2)) (expr1)'
17:13:08 <johnw> orzo: example?
17:13:09 <ReinH> enthropy: so let is just defined as a lazy pattern match?
17:13:11 <kvanb> short of installing ghc-mod and tools I'm going to try jesyspas approach first
17:13:31 <Snail__> I'm trying to get Control.Lens installed with haste-inst but the lack of template haskell is causing issues, in particular with the syb dependency. Anyone had any luck with it?
17:13:32 <johnw> orzo: I usually call it "rest", if I understand you
17:13:44 <orzo> yeah, i sometimes have called it rest
17:13:48 <ReinH> i.e., let matches the outer-most constructor lazily? Is that in the report somewhere?
17:14:16 <johnw> and usually I read it as "the rest of the computation", rather than the rest of the elements
17:15:14 <orzo> oh, well it's not recursion, this is *input* i'm talking about, it will be "" when i'm finished
17:15:16 <dfeuer> ReinH, tejing, let is not sugar in Haskell.
17:15:41 <johnw> yeah, but usually rest is a thunk representing a computation that will provide the next element
17:15:50 <orzo> oh
17:16:11 <orzo> in my case right now it's a string and i keep tearing off the front of it
17:16:25 <tejing> dfeuer: I'm more making a point about what's equivalent than about exactly how it's implemented
17:16:30 <johnw> that string might not be in memory
17:16:33 <johnw> can I see the code?
17:16:53 <johnw> Haskell is great at making computations masquerade as strings
17:17:26 <orzo> its simple code, i can show you if you want, but the string was obtained via readFile
17:17:37 <johnw> it does it so well, that I cry that idris doesn't have a lazy-by-default pragma.  sigh
17:17:48 <johnw> orzo: show!
17:17:53 <johnw> readFile gives you a lazy string :)
17:17:56 <sm> simple code, *hollow laugh*
17:18:00 <enthropy> tejing: I think there might be a difference with respect to monomorphism
17:18:13 <heatsink> Is it awkward to use () -> T for laziness?
17:18:17 <orzo> http://jerkface.net/~joe/SimpleConfig.hs
17:18:19 <orion> You know what's ridiculous? When your program silently compiles and executes even though you used the wrong function as a result of functions being masked by others in the import list.
17:18:40 <enthropy> > let n = 3 in (n, n) :: (Int, Double)
17:18:42 <lambdabot>  (3,3.0)
17:18:46 <johnw> orzo: yeah, I really think your string isn't a string
17:18:54 <johnw> it just looks and acts like a string
17:18:59 <ReinH> enthropy: huh
17:19:02 <enthropy> > case 3 of ~n -> (n, n) :: (Int, Double)
17:19:04 <lambdabot>  Couldn't match expected type ‘GHC.Types.Double’
17:19:04 <lambdabot>              with actual type ‘GHC.Types.Int’
17:19:08 <orzo> i understand, johnw
17:19:20 <ReinH> enthropy: interesting
17:19:29 <orzo> just when you said "rest of the computation" it made me think you intended a recursive step or something
17:19:35 <ReinH> dfeuer: right, I shouldn't have said "desugars to", just "is equivalent to"
17:19:36 <orzo> divide and conquer style
17:19:37 <dfeuer> let is more complicated even than that; I guess you could say it is sugar, but it "desugars" either to Core let or Core letrec, depending on whether things are recursive, so some lets stay lets.
17:19:39 <orzo> but i see now what you mean
17:19:40 <johnw> ah, I see
17:19:47 <enthropy> ReinH: I think it's wonderful how you can usually forget about those subtleties
17:19:53 <johnw> yeah, I just mean "when I force this, Haskell is gonna do something and give me more stuff"
17:20:08 <ReinH> enthropy: :)
17:20:19 <johnw> that more stuff *could* already be in memory, in which case "do something" is nothing more than peeling away constructors and following pointers
17:20:54 <sm> I have a module that used to compile with or without using cabal, but now without cabal it complains No instance for (Control.Monad.IO.Class.MonadIO (Wizard Haskeline)), even though I see the instance at http://hackage.haskell.org/package/wizards-1.0.1/docs/System-Console-Wizard.html. I'm stumped, could anyone suggest a cause ?
17:21:01 <orzo> still wish we had an immediately recognizable idiomatic name for the object
17:21:10 <orzo> "rest" is too vague
17:21:33 <johnw> sm: it sounds like Haskeline dosen't have an AribtraryIO instance
17:21:48 <johnw> "remainder" "next" "continuation"
17:21:54 <orzo> i like to use the name 'ac' formy accumulator object
17:22:02 <sm> hmm I'll expore that, thanks johnw
17:22:23 <johnw> oh, it looks like it does
17:22:30 <orzo> but its short for a very specific word, accumulator
17:22:46 <sm> this used to compile fine, and still does if I use cabal
17:22:52 <johnw> sm: wait, make sure you're not getting MonadIO from different package versions
17:23:07 <orzo> i use kont for continuation, but that's typically when i pass it around, i dont ordinarly think to call my rest a continuation
17:23:16 <johnw> sm: i.e., wizards compiled using one version, and you're trying to use another version
17:23:31 <sm> hmm, that sounds good, I'll reinstall a few libs
17:23:40 <johnw> "cont" as in "to be continued" :)
17:23:45 <orzo> would using kont for rest cause confusion though?
17:23:52 <johnw> oh I sure bet it would
17:24:02 <dfeuer> orzo: it makes reading Haskell a bit like reading assembly, I think. What's AX mean? Well, it depends what you put in it.
17:24:47 <johnw> is Tim Williams on?
17:25:17 <orzo> i'm not sure why i say kont instead of cont
17:25:18 <orzo> heh
17:25:23 <dfeuer> Speaking of such: I would love a GHC option to produce Core with variable names that can be recognized without going character by character.
17:25:56 <dfeuer> Maybe add syllables instead of letters and numbers?
17:26:06 <orzo> do you guys use the name "kont" ?
17:26:28 <dfeuer> I use kons and knil sometimes.
17:26:29 <orzo> or a name starting with k
17:26:39 <dfeuer> I dunno about kont. Maybe ever?
17:27:01 <enthropy> because SKI isn't called SCI?
17:27:05 <orzo> well i'm wondering why i spell it with a k, its something i do without thinking now
17:28:08 <orzo> oh well
17:30:09 <sm> johnw: hmm, reinstalling haskeline and wizards didn't help. Tomorrow I'll try a fresh sandbox.
17:36:27 <ReinH> kons, ok, but knil?
17:36:48 <mwhit> sure, the k is silent
17:37:40 * ReinH facepalms
17:37:50 <ReinH> mwhit: you win
17:42:31 <mietek> How do I use a Traversal' to set a value?
17:46:39 <edwardk> > set _2 100010010 (1,2)
17:46:40 <lambdabot>  (1,100010010)
17:46:53 <shachaf> set
17:47:05 <edwardk> > set traverse 10 [1...100]
17:47:07 <lambdabot>  Could not deduce (GHC.Num.Num
17:47:07 <lambdabot>                      (Control.Lens.Type.LensLike f0 s0 t0 c0 c0))
17:47:07 <lambdabot>    arising from the literal ‘1’
17:47:07 <lambdabot>  from the context (GHC.Num.Num b)
17:47:07 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num b => [b]
17:47:23 <mietek> OK, slightly confused.
17:47:25 <mietek> http://hackage.haskell.org/package/wreq-0.1.0.1/docs/Network-Wreq.html#v:cookie
17:48:00 <mietek> This works for me:
17:48:01 <mietek> defaultsWithCookie = defaults & header "Cookie" .~ [myRenderCookie c]
17:48:07 <edwardk> a traversal gives you a bunch of cookies you have
17:48:16 <edwardk> cookie :: ByteString -> Traversal' Options Cookie
17:48:21 <mietek> But I suspect the provided cookie function should be used to avoid implementing my own myRenderCookie
17:48:21 <edwardk> that will walk the cookie if its present
17:48:28 <edwardk> and if you have several cookies tagged the same way
17:48:34 <edwardk> it'll get you _all_ of them
17:48:42 <mietek> I don't want to _get_ a cookie here
17:48:52 <mietek> I want to set the "Cookie: XXX" header
17:49:01 <edwardk> my point is if you want to insert a new one you're dead in the water using that thing, unless you are replacing another cookie
17:49:06 <edwardk> you need to move up to the cookie jar
17:50:23 <mietek> edwardk: I guess my confusion is stemming from the fact that I don't know if Traversal' is something I could use to set things
17:50:49 <edwardk> you can modify something  that is already there with a traversal, but you can't make 'new stuff'
17:51:04 <int3__> say I have a pipeline of computations that I now want to add 'caching' to, so that as the input changes incrementally, the output doesn't have to be recomputed from scratch. how should I store the cached states -- is StateT the right idea? Do I have to add a layer of StateT for each item in my pipeline, then?
17:51:13 <mietek> Ah.
17:51:50 <edwardk> so use lens to the cookie jar, get out the cookie jar, edit it and put it back
17:51:58 <edwardk> that you can get. modify and put back
17:51:59 <edwardk> it is a lens
17:52:09 <edwardk> so there is exactly one cookie jar in your options
17:52:09 <mietek> Thanks.
18:02:14 <thoughtpolice> orion: heh, no prob. i saw that but read all three anyway, they seemed fine.
18:06:52 <zachmassia> Any Mac users in here? Having trouble getting glib to build, and as a result cannot get Helm installed. (More info here: https://github.com/switchface/helm/issues/57)
18:12:52 <Andrey_> Hi, could someone please help me out with understanding of how to access Scotty middleware? Meaning, let's say I have a middleware that checks authorization for every request, and I want to set some variables somewhere if auth is successful (for example username) and throw noAuth instead? How and where would I set that username and how would I access it in my route functions? thank you!
18:14:46 * hackagebot semigroupoids 4.2 - Semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-4.2 (EdwardKmett)
18:14:46 * hackagebot lens 4.3.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.3.3 (EdwardKmett)
18:15:12 <Andrey_> As, I already understand, I would return username from middleware by changing Application signature, for example (Text -> Application) -> Application, but how would I get the value from route functions?
18:16:09 <LadyAurora> Can somebody ELI5 lenses?
18:16:39 <trap_exit> LadyAurora: lenses is a way to define a "location", which you can both read + update
18:17:10 <edwardk> LadyAurora: you've ever used a field accessor to do get/set in an imperative language?
18:17:17 <LadyAurora> Yes.
18:17:28 <edwardk> when you move to a functional setting you have a problem. we're immutable. how does a setter work?
18:17:30 <trap_exit> edwardk: what 5 years old has used get/set field acessors in imperative languages?
18:18:03 <edwardk> if you want to modify something 2-3 levels deep, foo.bar.baz.quux += 2now you're up to your elbows in data structures.
18:18:04 <LadyAurora> trap_exit: oh come on, not everything is literal, you know.
18:18:30 <edwardk> lenses capture that pattern of getting down to the data, and coming back up with a modified structure
18:18:31 <benzrf> edwardk: are you propagandizing
18:18:36 <edwardk> benzrf: i'm answering
18:19:07 <ruzu> are there any handy tricks to optimizing the behavior of haskells gc?  ie avoid/favor certain classes of algorithms, etc
18:19:08 <edwardk> now, lenses generalize the idiom you know and (love? hate?)
18:19:12 <benzrf> i just realized that zoom is kind of a lot like zippers
18:19:16 <edwardk> you can hit multiple targets with a lens
18:19:21 <edwardk> well, with generalizations of a lens
18:19:37 <edwardk> we have lenses that work like getter/setter pairs equipped with laws so you can actually reason about them
18:19:47 <edwardk> we have traversals that are like lenses that can hit lots of little targets
18:20:07 <edwardk> we have isomorphisms, prisms, indexed traversals, equalities, there is a whole menagerie of these concepts
18:20:26 <benzrf> just in case you were feeling sad about your head not hurting anymore :-)
18:20:26 <edwardk> but they all fit into the same general API, the same combinators work with all of them and 'do what they must because they can'
18:20:52 <edwardk> so once you learn how to use one of the tools in the toolbox you learn a lot about how all the others work
18:21:04 <MP2E> benzrf : I don't understand the bad rap that lenses get. They really aren't that difficult
18:21:15 <MP2E> I see so much FUD surrounding them and it's silly
18:21:23 <edwardk> MP2E: its mostly that they tend to provoke a very vocal reaction on both sides ;)
18:21:46 <edwardk> they didn't try to be 'haskelly', they tried to follow the laws and see what happened when expressed in its full generality
18:21:46 <benzrf> MP2E: well, not lenses themselves
18:21:50 <LadyAurora> edwardk: now you started talking about generalizations in, er, general.
18:21:53 <benzrf> but the entire zoo of types and polymorphic stuff in lens
18:22:53 <benzrf> MP2E: the denotational semantics of lenses are easy. van laarhoven lenses are not very hard.
18:23:03 <benzrf> but lens has much more than just those
18:23:05 <edwardk> LadyAurora: anyways, the core idea of lens is splitting 'what to do' from 'what to do it to', and the vocabulary of what to do is borrowed from combinators folks already know.
18:23:12 <benzrf> and a lot of it hurts my brain ;=;
18:23:23 <MP2E> Prisms and traversals seem like natural extensions of lens to me :) And the fact that Lens is based off of Isomorphism makes perfect sense to me. Now there are a variety of other typeclasses and combinators that I'm not 100% familiar with but you don't need to know all of it to use it :P
18:23:25 <edwardk> the trick is the implementation of it relies on math a lot of folks never learn =)
18:24:18 <edwardk> on the plus side you can use the library without understanding the math, and absorb some of it by osmosis. on the minus side if you are a very much bottom up kind of person then it'll be a lot of vocabulary coming fast and hard for a long time
18:24:35 <MP2E> ah okay, I could see it from that perspective
18:24:37 <LadyAurora> My head just started to hurt. Coincidence?
18:24:59 <LadyAurora> edwardk: I'm fine with using stuff I don't understand.
18:25:01 <benzrf> MP2E: do you understand how lenses and prisms and traversals all work with view, review, and over, though?
18:25:10 <benzrf> do you grok the fake subtyping?
18:25:15 <edwardk> benzrf: sure, its a trivial application of the yoneda lemma ;)
18:25:23 <benzrf> edwardk: fie
18:25:30 <trap_exit> do you get haskell?
18:25:31 <benzrf> edwardk: which is?
18:25:43 <edwardk> get and beget   er.. view and review in lens parlance
18:26:00 <MP2E> The Yoneda Lemma is an observation that if you have a Functor over a and a function a -> b then you can get a Functor over b, right?
18:26:07 <benzrf> oh wait i meant preview
18:26:07 <benzrf> bleh
18:26:11 <benzrf> not review
18:26:18 <edwardk> both use the yoneda lemma in diguise
18:26:21 <edwardk> er disguise
18:26:34 <benzrf> yoneda lemma, i need an explanation
18:26:55 * benzrf feels guilt @ pun reuse
18:27:18 <MP2E> I stated it, I thought :P
18:27:27 * MP2E reviews definition
18:27:33 <edwardk> MP2E: well, first you note that if you take the notion of arrows for your category we say they have some 'set' of arrows the 'hom-set' for the category, its indexed by the objects. you give me 2 objects in the category and i'll give you the homset of arrows between them
18:27:39 <edwardk> :k (->)
18:27:40 <lambdabot> * -> * -> *
18:28:19 <edwardk> (->) is the Hom of haskell, it takes two types and gives you the arrows between them. haskell is particularly nice in that (->) takes two objects and turns into an arrow that _also_ lives in the same place
18:28:23 <edwardk> it is 'enriched over itself'
18:28:59 <edwardk> now, when category theorists work with the Hom they tuple up both choices of objects, like its an uncurried function
18:29:06 <edwardk> and write Hom(x,y)
18:29:26 <edwardk> Hom is contravariant in its first argument, and covariant in its second.
18:29:43 <hellen_haskeller> profunctor
18:30:23 <edwardk> yoneda noted that if you have a locally small category (that the space of arrows between any two objects is small enough to be a set) then we can curry that functor
18:30:30 <shachaf> Are there categorical examples of adjointness that don't specifically involve Hom?
18:30:49 <shachaf> I.e. P(F(A),B) ~ Q(A,G(B))
18:30:58 <edwardk> basically if you fix an object on one side of the arrow or the other then you can look at the space of all arrows going to or from that object
18:31:11 <shachaf> For some profunctors (or something) P/Q.
18:31:14 <benzrf> edwardk: sweet
18:31:55 <edwardk> this is analogous to the fact that (->) is 'curried' and takes two arguments it isn't a functor from a product category as a functor from the opposite category of haskell to the category of functors from hask -> hask
18:32:30 <edwardk> you can partially apply ((->) a) and get a functor
18:32:34 <benzrf> edwardk: wait, is a homset a category somehow? otherwise how is Hom a functor
18:32:37 <edwardk> we call it reader
18:32:54 <edwardk> its a functor to a category in which the objects are functors
18:32:55 <Welkin2> reading steiner!
18:33:01 <benzrf> edwardk: oh
18:33:02 <edwardk> and the arrows between them are natural transformations
18:33:07 <benzrf> alright
18:33:49 <edwardk> so (->) :: * -> (* -> *) takes us from the category *  with objects in haskell and haskelll types to the category (* -> *) of functors from haskell to haskell.
18:34:24 <shachaf> Well, * -> * also has things that aren't functors.
18:34:30 <edwardk> so (->) a is a functor   and given (a -> b)   we can go from (->) b -> (->) a --
18:34:35 <edwardk> yeah i was getting there slowly
18:34:36 <edwardk> =)
18:34:50 <edwardk> in this case (->) really does go to where i said, but there are other things in * -> *
18:35:02 <edwardk> it goes to a nicely behaved sub-category of * -> *
18:35:15 <shachaf> This is the wrong channel for my question anyway.
18:35:43 <edwardk> shachaf: most adjunctions wind up being talked about as an isomorphism of hom-sets somehow
18:35:44 <benzrf> >>>##math
18:36:54 <mmarusea1ph2|umb> but I liked the discussion
18:36:59 <edwardk> so the tricky part is (->) is contravariant in its first argument, it goes from Hask^op,   and we have 'profunctors' which are functors from C^op * D -> Set     -- but Set is basically * in haskell, and C and D here are also *
18:37:41 <edwardk> but when we write a profunctor we don't have a product like that we don't work with a functor f :: (c,d) -> *   we work with f :: c -> d -> * !
18:37:53 <edwardk> so we can do the same thing, with that, with bifunctors, etc
18:38:02 <Dacto> Using aeson I can decode JSON source into a defined data type. How can I encode data back into JSON that including source objects that I did not parse into a data type?
18:38:11 <edwardk> we don't 'tuple' the args of our bifunctors up into one kind argument
18:38:31 <T55555> question... i just put this --~ ( tile char  just after -- ) for comment and got parser error. for the comment --, tile new line, and why cannot put tile char as comment (directly after -- ) ? any other char restriction, I check the grammar BNF , seems to me no such limitation, bug of GHC?
18:38:51 <shachaf> T55555: --~ is an operator.
18:39:00 <shachaf> > let a --~ b = a + b in a --~ 5
18:39:01 <lambdabot>  a + 5
18:39:10 <edwardk> but we can come up with a world in which that is okay. category theory has products and cartesian structures, monoidal structures, etc. , but it also has 'closed' structures which are like arrows internal to the category in question
18:39:23 <Welkin2> ...what kind of operator?
18:39:26 <edwardk> and the yoneda embedding is just that applied to the set of arrows
18:39:35 <Welkin2> that is also confusing because it looks too much like -
18:40:06 <edwardk> T55555: you can make an operator that starts with -- in haskell
18:40:07 <T55555> oh... --~ is operator. oh mine... thanks.
18:40:07 <edwardk> -->
18:40:26 <Welkin2> :t (--~)
18:40:28 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
18:41:02 <dwcook> T55555, http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-170002.3 "The sequence of dashes must not form part of a legal lexeme."
18:41:08 <edwardk> anyways, in nice enough categories you can go back and forth across this sort of embedding, you can find things that look like cps'ing, generalize the difference list trick to arbitrary monoids, monads, arrows, etc.
18:41:12 <edwardk> because its all the same thing
18:41:30 <edwardk> codensity is a difference list for a monad
18:42:50 <Abathurr> why is haskell so dismally boring
18:42:53 <Abathurr> oops
18:43:01 <Abathurr> i meant high school math
18:43:51 <LadyAurora> lol
18:43:51 <Welkin2> haskell is high school math?
18:43:56 <mwhit> haha what
18:44:01 <Welkin2> my mind would have been blown if that were the case
18:44:04 <Abathurr> no i just
18:44:20 <Abathurr> typed the wrong thing because I joined this channel
18:44:25 <Abathurr> little slip of the mind I guess
18:44:44 <mwhit> well, just write a haskell program that does your homework for you
18:44:46 <mwhit> problem solved
18:45:09 <Welkin2> you can write a symbolic integrator using only 26(?) rules
18:45:11 <LadyAurora> In the language of the country I live in, literal translation of "high school" would mean "university".
18:45:29 <Welkin2> da xue
18:45:37 <Abathurr> I
18:45:41 <viszu> \o/ any recommended gui library ?
18:45:49 <LadyAurora> So in a way, Haskell is high school math.
18:45:51 <Abathurr> am not in high school I just was reading my younger sibling's textbook
18:45:52 <Welkin2> viszu: for what?
18:45:59 <Welkin2> application? menus?
18:46:03 <Abathurr> and was reminded of how painfully dull some of it is
18:46:03 <mwhit> highschool = zhongxue
18:46:16 <viszu> I just wanna write simple app with tray icon
18:46:38 <mwhit> which, ironically, is literally "middle school"
18:46:42 <Welkin2> viszu: there is wxHaskell, GTK, Qt, etc
18:47:28 <viszu> hmm wxhaskell looks pretty dead to me, at least arch linux package which is from 2007
18:47:45 <Welkin2> http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
18:47:55 <Dacto> viszu: wxHaskell is still alive
18:48:28 <Dacto> compatible with wxWidgets 3.0.0, most recently.
18:48:30 <dwcook> viszu, it's best not to grab Haskell packages from your distro PM. Most people use cabal to get them.
18:48:50 <Welkin2> most distros are years out of date
18:48:57 <Welkin2> package managers*
18:49:08 <Dacto> viszu: It would be better to get the wxHaskell and wxWidget sources and build that.
18:49:42 <Welkin2> I like that for the most part because of the stability
18:49:43 <Dacto> There is a relatively decent guide on how to do both on the wxHaskell wiki site
18:49:49 <Welkin2> but it isn't good for haskell
18:50:54 <viszu> ok wxhaskell than, ty all
18:53:32 <Abathurr> does anyone know how to use split windows in irssi
18:53:44 <Abathurr> I have two windows up but I want to be able to connect to a different server in window 2
18:55:11 <mayski> try #irssi
18:55:29 <mayski> it's in ircnet though
18:55:31 <kristof> Sometimes I read irc conversations and marvel at how bizarre they can be.
18:55:32 <Welkin2> just use /connect
18:55:57 <hellen_haskeller> edwardk: thanks for that, you are in an incredble level of understanding the type system.
18:56:18 <edwardk> hellen_haskeller: happy to help
18:56:32 <Welkin2> I don't understand most of what edwardk says
18:56:33 <Abathurr> what I mean is that I don't know how to switch from one window to the next
18:56:56 <Welkin2> but I learn something every time
18:57:00 <hellen_haskeller> well, not sure it helped more than made me realize how much more I have to go
18:58:13 <hellen_haskeller> mazbe it was a good thing to start with fortran, haskell at the time might have blown my mind
18:58:32 <Welkin2> I wish I started with haskell
19:00:01 <hellen_haskeller> pascal was cool in the day, everyone was cursing cobol
19:00:28 <Welkin2> @commands
19:00:29 <lambdabot> Unknown command, try @list
19:00:33 <Welkin2> @list
19:00:34 <lambdabot> What module?  Try @listmodules for some ideas.
19:00:44 * Welkin2 puts a quarter into lambdabot 
19:01:02 <Welkin2> lambdabot needs some games
19:01:37 <MP2E> Super Turbo Turkey Puncher 3!
19:02:17 <tbmcmullen> Kinda odd question. Let's say I have `data X = A Int | B Int | C Int` and I want to write a function, which regardless of the constructor, returns the Int field from any X... how would I do that?
19:02:48 <copumpkin> use record syntax :)
19:02:49 <Welkin2> just pattern match
19:02:59 <tbmcmullen> copumpkin: was afraid you were going to say that :)
19:03:00 <shachaf> Or just f (A x) = x; f (B x) = x; f (C x) = x
19:03:06 <solatis> record syntax ? evil...
19:03:20 <shachaf> You can also use a tag, as in data T = A | B | C; data X = X T Int
19:03:23 <copumpkin> tbmcmullen: or more realistically, just factor it out
19:03:23 <tbmcmullen> shachaf: yeah, that's what I did, but it's kind of annoying to maintain
19:03:24 <copumpkin> yeah
19:03:24 <copumpkin> that
19:03:37 <tbmcmullen> ahhh
19:03:38 <bb010g> Welkin2: Insult dueling is fun.
19:04:32 <Welkin2> can you use the same record name with multiple value constructors?
19:04:32 <tbmcmullen> bleh... alright. I have a bunch of code to change now. :)
19:05:25 <mwhit> a little late but
19:05:27 <mwhit> @where commands
19:05:27 <lambdabot> http://users.ece.cmu.edu/~allbery/lambdabot/COMMANDS
19:05:31 <mwhit> added that a little while ago
19:07:08 <Welkin2> @todo
19:07:09 <lambdabot> 0. SamB: A way to get multiple results from a google search
19:07:09 <lambdabot> 1. dons: improve formatting of @dict
19:07:09 <lambdabot> 2. dons: write Haskell Manifesto
19:07:09 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
19:07:09 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
19:07:11 <lambdabot> [40 @more lines]
19:07:16 <Welkin2> oh
19:08:50 <mwhit> i feel like this is almost too obvious to ask, but I want to be totally sure: since newtypes don't exist at runtime, newtype contructors/pattern matches get compiled to nothing at all, correct?
19:10:33 <Welkin2> newtypes are analagous to type synonyms for a constructor with one field
19:10:40 <Welkin2> at least that it what I remember from LYAH
19:12:48 <mietek> Record syntax and the State monad.
19:13:08 <mietek> Is there an one-liner for  { st <- get ; put $ st { stField = val } } ?
19:13:50 <dwcook> @type modify
19:13:52 <lambdabot> MonadState s m => (s -> s) -> m ()
19:14:11 <dwcook> Hrm, you'd have to write it slightly differently though
19:14:13 <dwcook> with modify
19:14:19 <hellen_haskeller> copumpkin: do you advocate record syntax?
19:14:21 <mwhit> if you have a lens, modify (\st -> stField .~ val st)
19:14:22 <copumpkin> no
19:14:48 * hackagebot async-extras 0.1.2.0 - Extra Utilities for the Async Library  http://hackage.haskell.org/package/async-extras-0.1.2.0 (JonathanFischoff)
19:14:50 <mwhit> or i guess just modify $ stField .~ val
19:15:05 <dwcook> Those two aren't equivalent
19:15:13 <edwardk> mietek: _stField .= val
19:15:16 <Welkin2> isn't lens going into base?
19:15:24 <edwardk> Welkin2: not exactly
19:15:50 <edwardk> in general if you have a lens operator foo~   then there is foo= that uses it directly on state
19:16:16 <mwhit> oh yeah i read that once
19:16:28 <mwhit> maybe one day i will remember more than 5 of the operators
19:17:02 <edwardk> you can work with lens entirely operator free
19:17:06 <mwhit> yeah i know
19:17:10 <edwardk> i think the people who do are silly, but so be it =)
19:17:40 <Welkin2> I don't know how I feel yet about some of the lens operators that are from imperative programming, like +=
19:17:48 <dwcook> mwhit, to answer your earlier question: Types don't exist at runtime at all, but newtypes are defined to be representationally identical to the underlying type, only distinct in the type system.
19:17:59 <edwardk> Welkin2: there are times when that is precisely what you want to say
19:18:09 <edwardk> vocabulary is vocabulary =P
19:20:33 <vanila> could lens be considered a new programming language?
19:20:47 <mietek> So -- it's either  "modify (\st -> { stField = val } )"  or  what exactly with lenses?
19:21:01 <Welkin2> vanila: you could say that about a lot of libraries
19:22:10 <edwardk> > [1..10] &~ do Lens.ix 1 *= 3; traverse += 1
19:22:13 <lambdabot>  [2,7,4,5,6,7,8,9,10,11]
19:23:12 <edwardk> vanila: some folks have trotted that out as a talking point. its worth debating. it doesn't try to follow pre-existing idioms. it builds a large vocabulary for working with its chosen problem domain and it is deliberately crafted to have a consistent 'morphology', so there are definitely some language like aspects to its design
19:23:39 <edwardk> i personally think its just haskell a bit purified and refined ;)
19:24:01 <mietek> edwardk: ah, so you meant "stField .= val", without the _
19:24:03 <edwardk> its still got its selection of hacks, we know how to do somethings much better, but are limited by wanting to fit better into haskell
19:24:05 <mietek> That is nice.
19:24:29 <edwardk> mietek: the _stField was to distinguish the lens from the field, pick one, mangle the other ;)
19:25:03 <mietek> edwardk: right, but I guess the default is to have _field accessors for makeLenses?
19:25:23 <edwardk> the default is to have _field's and then have makeLenses take the non-_'d names
19:25:52 <mietek> So -- what's the lens way to write  "val <- gets _stField" ?
19:25:53 <Welkin2> does anyone actually use record syntax, or do they just use lens?
19:26:20 <yukko2_> hi! I have a few questions about this piece of code: http://lpaste.net/108467
19:26:22 <mietek> Or, same thing, "val <- _stField <$> get"
19:26:29 <shachaf> val <- use stField, probably
19:26:52 <benzrf> :t use
19:26:54 <lambdabot> MonadState s m => Getting a s a -> m a
19:26:57 <benzrf> oh right
19:26:58 <yukko2_> if you can construct a value of a type with no constructors, then isn't Haskell's type system inconsistant/broken?
19:27:01 <benzrf> :t view
19:27:02 <lambdabot> MonadReader s m => Getting a s a -> m a
19:27:04 <benzrf> eesh
19:27:13 <benzrf> yukko2_: the only way to do that is with bottom
19:27:28 <vanila> since haskell has general recursion you can always prove false
19:27:35 <benzrf> yukko2_: and you can have turing completeness xnor bottom
19:27:42 <mietek> shachaf: cool
19:27:56 <shachaf> yukko2_: Yep.
19:27:57 <fread2282> yukko2_: record syntax is broken, it uses undefined
19:27:58 <vanila> languages whose type system have logical interpretation like agda or coq require strong normalization
19:28:03 <fread2282> > Just{}
19:28:05 <lambdabot>  Just *Exception: <interactive>:3:1-6: Missing field in record construction
19:28:12 <Iceland_jack> > (:){}
19:28:13 <lambdabot>  [*Exception: <interactive>:3:1-5: Missing field in record construction
19:28:18 <Iceland_jack> > null (:){}
19:28:19 <lambdabot>  False
19:28:30 <shachaf> yukko2_: A language like Agda wouldn't allow that program, because you have (type-level) recursion in negative position.
19:29:01 <yukko2_> shachaf oh okay
19:29:09 <shachaf> @where y -- another example
19:29:10 <lambdabot> \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
19:29:15 <shachaf> @src InR
19:29:15 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
19:29:16 <fread2282> yukko2_: haskell has undefined, so yes you could say it's broken
19:29:28 <vanila> that is not in the negative position - it's actually a strictly positive definition
19:29:30 <fread2282> but avoid undefined
19:29:47 <benzrf> fread2282: even without undefined, you can do this:
19:29:52 <edwardk> mietek: x <- use stField
19:29:54 <benzrf> @let bottom = bottom
19:29:57 <lambdabot>  Defined.
19:29:58 <benzrf> :t bottom
19:29:59 <lambdabot> t
19:30:02 <fread2282> benzrf: true
19:30:30 <benzrf> and they have the same effect of ending your program's normal execution
19:30:34 <benzrf> albeit in different manners
19:30:41 <shachaf> I feel like people are ignoring yukko2_'s actual question here and just answering something that sounds vaguely similar.
19:30:43 <mietek> edwardk: thanks, this is very cool
19:30:51 * benzrf realizes that he just used the phrase 'albeit in different manners'
19:30:54 <benzrf> tfw im a pompous academic
19:30:58 <shachaf> The linked paste doesn't use undefined or x = x
19:31:06 <Welkin2> tfw?
19:31:06 <benzrf> shachaf: oh
19:31:07 <benzrf> oops
19:31:13 <benzrf> Welkin2: a terrible 4chanism
19:31:15 <benzrf> 'that feel when'
19:31:20 <Welkin2> benzrf: you btard
19:31:24 <benzrf> :[
19:31:47 <Welkin2> benzrf: get off my lawn!
19:31:55 <LadyAurora> tfw somebody uses 4chanisms
19:31:57 <mietek> I have to say, wreq + lens makes for pretty neat code
19:32:17 <mietek> + tagsoup
19:32:37 <mietek> And a bank site scraper is born
19:32:48 <benzrf> it looks to me like  yukko2_'s link is basically similar to `x = x'
19:32:54 <benzrf> although i havent read it carefully
19:33:19 <vanila> Inductive J (c : Set -> Set) : Set := MkJ : c unit -> J c.
19:33:19 <vanila> Inductive R : Set -> Type := MkR : forall c, (c (J c) -> False) -> R (J c).
19:33:21 <vanila> is accepted in Coq
19:34:16 <benzrf> just fancier
19:34:22 <benzrf> yukko2_: have you tried running that?
19:34:29 <yukko2_> yes
19:34:30 <benzrf> yukko2_: i have a feeling that it's an infinite loop
19:34:35 <benzrf> @undef
19:34:35 <lambdabot> Undefined.
19:34:58 <yukko2_> it typechecks and calling absurd seems to terminate
19:35:09 <benzrf> yukko2_: it doesnt, show is just lazy
19:35:09 <benzrf> look:
19:35:14 <benzrf> @let data Foo
19:35:16 <lambdabot>  Defined.
19:35:25 <benzrf> @let instance Show Foo where show _ = "what how"
19:35:27 <lambdabot>  Defined.
19:35:30 <benzrf> > show (undefined :: Foo)
19:35:32 <lambdabot>  "what how"
19:36:07 <benzrf> yukko2_: try rewriting show like `show f = seq f "false"'
19:36:13 <benzrf> that will probably fail to terminate
19:38:12 <yukko2_> benzrf you're right!
19:38:31 <yukko2_> I actually just did f :: False -> String; f !x = "hello"
19:38:34 <yukko2_> but it failed to terminate
19:38:57 <benzrf> yukko2_: ultimately, that's just normal infinite-recursion-allowing-total-polymorphism but with more fancy types
19:39:12 <yukko2_> I see!
19:39:20 <mietek> Is there a way to import a type from a hidden module?
19:40:19 <mietek> Otherwise, GHC's suggestion to just add (wreq-0.1.0.1:Network.Wreq.Internal.Types.Postable a) to the context is a bit cheeky
19:40:47 <benzrf> mietek: why do you need it
19:41:02 <benzrf> mietek: im gonna guess that the hidden module is where it's defined
19:41:02 <Welkin2> I hear cheeky used to describe everything
19:41:11 <Welkin2> what does this british-derived slang mean?
19:41:11 <benzrf> but its reexported from a public module
19:41:45 <benzrf> Welkin2: sort of jokey crossed with disrespectful crossed with having some nerve
19:42:22 <mietek> benzrf: absolutely right
19:42:26 <mietek> On both counts
19:42:27 <mietek> Thanks.
19:43:47 <benzrf> npcomp:
19:43:49 <benzrf> *np
19:51:19 <jle`> trap_exit: did you figure out your problem?
19:54:30 <trap_exit> jle`: well
19:54:39 <trap_exit> jle`: my "problem" was that the papaer was using outdated notation
19:54:45 <trap_exit> jle`: but it's all resolved now
19:54:46 <jle`> ah! sorry about that
19:54:48 <jle`> hoorah
19:54:50 <trap_exit> jle`: thanks for recommending the paper!
19:56:21 <jle`> np :) hope it helped make things a little clearer
19:59:25 <solirc> orion: Either $setup or a previous `>>> ` in the same Haddock comment or a top-level definition in the module or imported from somewhere
19:59:38 <solirc> orion: I think that are your options
20:00:26 <orion> solirc: hah, I figured it out, thanks. :)
20:00:38 <solirc> orion: Ok, cool
20:00:52 <solirc> Also, feel free to ask doctest related stuff in #hspec ;)
20:00:57 <orion> ok
20:03:23 <benzrf> :t (>>)
20:03:24 <lambdabot> Monad m => m a -> m b -> m b
20:03:25 <benzrf> :t (>>>)
20:03:26 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
20:03:32 <benzrf> :t (>>>>)
20:03:34 <lambdabot>     Not in scope: ‘>>>>’
20:03:34 <lambdabot>     Perhaps you meant ‘>>>’ (imported from Control.Arrow)
20:04:01 <benzrf> @let (>.<) = text "dang it"
20:04:02 <lambdabot>  Defined.
20:04:07 <benzrf> > (>.<)
20:04:09 <lambdabot>  dang it
20:07:40 <augur> lenses arent accessors you shouldnt use that analogy :(
20:07:46 <augur> edwardk: ^
20:08:26 <edwardk> they are 'like' lots of things, one of the things they subsume is accessors
20:08:46 <Kron> @let (^.^) = text "Yay!"
20:08:47 <lambdabot>  Defined.
20:08:51 <Kron> > (^.^)
20:08:52 <lambdabot>  Yay!
20:08:55 <augur> yeah but i think that analogy causes a lot more confusion than it gets rid of
20:08:55 <Kron> :D
20:09:14 <augur> edwardk: the closest thing to a lens, i would argue, is a map
20:09:17 <LadyAurora> "like" is an overly broad word.
20:09:26 <edwardk> they are also cover the model view update problem and do lots of other things, injections into structures, are a weird kind of tambara module, act as costate comonad coalgebras, are monad algebras of a particular monad in the slice category over the value type, etc.
20:09:26 <augur> but unlike maps, lenses focus on one position, not all of them
20:09:52 <edwardk> this is one of those monad tutorial moments. when whatever way you learned them third is the one you espouse for the rest of your life
20:10:19 <augur> :p
20:10:27 <mmarusea1ph2|umb> that would be the burito analogy :)
20:10:29 <augur> i dont think i learned them "as maps" so
20:10:40 <edwardk> generalized 'semantic editor combinators' is another viewpoint
20:10:46 <augur> im just speaking from experience trying to explain them to people
20:10:58 <shachaf> that is a good viewpoint
20:11:06 <vanila> tambara module, act as costate comonad coalgebras, are monad algebras of a particular monad in the slice category over the value type <--- these sound hard...
20:11:08 <edwardk> he problem with the map analogy is that it misses that you can read back
20:11:11 <shachaf> because it generalizes to profunctors easily
20:11:33 <shachaf> edwardk: But people already have intuition of going from map to mapM.
20:11:33 <edwardk> but i will say this, that viewpoint is the closest to the one i use in my own work
20:11:39 <shachaf> So it's the same deal.
20:11:46 <edwardk> the profunctor approach is my preferred style of thinking of lenses
20:12:49 * shachaf remembers when edwardk said it was a cute toy.
20:12:56 <shachaf> Admittedly it is.
20:13:03 <johnw> "a particular monad in the slice category over the value type" -- what is an example of that?
20:13:21 <edwardk> you can do them pretty much with any proarrow equipment, which is something i've been meaning to explore in them in the Relation equipment
20:13:34 <jle`> i think of lenses like...a way to deal with something as if it were something else
20:13:38 <edwardk> shachaf: its grown up a bit since then ;)
20:14:20 <shachaf> I think the "isomorphism to a product" viewpoint is also very good.
20:14:37 <spott> is there a way to make a constraint that simplifies a type:  for example constrain type variable tt to: MyType t v
20:14:38 <spott> ?
20:14:51 <edwardk> johnw: you can build a slice category over some value v. objects are pairs of objects "a" and morphism alpha :: a -> v, arrows are a morphism between objects such that the triangles commute
20:15:05 <edwardk> now there is a forgetful functor from C/v to C that just forgets the arrows to v
20:15:26 <triliyn> spott: I think that would be (tt ~ MyType t v)
20:16:18 <johnw> you mean values like 42, and an object (12, (+30))?
20:16:19 <edwardk> and there is an adjoint functor from C -> C/v that takes you to pairs (C,V) with the projection that just projects out the second half of the pair
20:17:18 <edwardk> compose those and you get a monad, the monad algebras of that monad are lenses, they are 'updates' (C * V -> C)  that respect the 'view' morphism C -> V
20:17:49 <edwardk> the problem with this view is it doesn't give you how lenses prisms, etc. all interact
20:17:57 <stelleg> hey guys, playing around with arbitrarily nested types, any way to make this mor concise? http://sprunge.us/HGCY
20:18:08 <edwardk> its just 'accidental' like the encoding of lenses as 'costate comonad coalgebras'
20:18:32 <edwardk> it is a sort of local optimum in the design space
20:19:28 <LadyAurora> I guess I'm not smart enough to understand lenses, then.
20:19:55 <vanila> this sounds difficult
20:20:02 <gp5st1> hello. I'm super green to haskell and can't figure out this error message: https://dpaste.de/KocL/raw
20:20:04 <mwhit> you don't need to understand any of that to *use* lenses
20:20:20 <vanila> It would be nice if there was a paper that explains this stuff
20:20:39 <splintax> ugh what's best practice for avoiding cabal issues
20:20:46 <mwhit> always sandbox
20:20:56 <vanila> stelleg, you could define it as a singel GADT
20:20:58 <MP2E> gp5st1 : basically what it is saying is that it doesn't know what type you want it to give you. It can give you any type that is a valid RealFrac
20:21:08 <LadyAurora> gp5st1: (99 :: Double)
20:21:10 <MP2E> gp5st1: try concatMap (\x -> [x,(quot 99 x)]) (filter (\x ->  (mod 99 x) == 0) [2..(floor (sqrt(99)))]) :: Double
20:21:33 <vanila> stelleg, maybe even as a nested ADT
20:21:36 <Abathurr> I really like the formatting on www.learnyouahaskell.com
20:21:37 <MP2E> err I said that wrong
20:21:39 <MP2E> do what LadyAurora said
20:21:40 <MP2E> :P
20:21:54 <jle`> @pl \r -> (\_ g -> r g)
20:21:55 <lambdabot> const
20:21:56 <splintax> mwhit: if i want to start again and always sandbox, can i just nuke ~/.cabal?
20:21:57 <stelleg> vanila: you mean fold the type class functionality into the GADT?
20:21:59 <jle`> huh
20:22:01 <jle`> i feel silly
20:22:09 <vanila> just define it as a GADT, no type classes
20:22:16 <stelleg> or just the seperate N and NestList
20:22:17 <jle`> :t \r -> (\_ g -> r g)
20:22:18 <lambdabot> (t2 -> t1) -> t -> t2 -> t1
20:22:22 <edwardk> LadyAurora: there is a vanishingly small pool of people who understand the issues in the design space around lens, but there is a very large pool of people who consume them
20:22:26 <gp5st1> MP2E: LadyAurora: oh, I just figured it'd pick the most common type possible and chug on. thanks
20:22:34 <vanila> let m try
20:22:45 <jle`> oh tha makes sense...it's \r _ -> r
20:22:49 <edwardk> all this abstract nonsense flying is the bleeding edge of what we're thinking about
20:23:16 <splintax> related, what's the best way to get a consistent dev environment on osx and linux
20:23:20 <pingu> edwardk: hey, is it possible to rebuild a structure with a parts of it removed with lenses?
20:23:28 <edwardk> #haskell-lens is over there, lots of helpful folks willing to get people bootstrapped on lenses. some of them get obsessed with the internals and become category theorists ;)
20:23:36 <swgillespie> splintax: I'd highly recommend osx running linux vms
20:23:36 <dfeuer> And it makes me jealous that other people understand it and I'm not really in a position to study it properly at the moment.
20:23:45 <pingu> oh. I should ask there.
20:23:47 <LadyAurora> splintax: ditching osx
20:23:58 <splintax> install ghc + cabal-install with brew/apt, and then use cabal sandbox for everything else?
20:24:02 <carter> swgillespie: no
20:24:06 <edwardk> pingu: it is often possible to build a lens to 'all of the stuff except for what you want to cut out and swap out the region you are cutting out in one operation basically
20:24:09 <carter> splintax: NO BREW
20:24:11 <mwhit> splintax: i *believe* nuking .cabal should work, but i also disavow responsibility for any disasters
20:24:11 <swgillespie> carter: ?
20:24:15 <carter> autocmplete
20:24:26 <splintax> swgillespie: hmm really? i already run linux VMs for other projects that can't easily be run on osx and it's a bit of a pain
20:24:40 <splintax> i really like the fact that it's easy to use haskell natively
20:24:44 <dfeuer> Why would you run Linux in a Mac VM to do Haskell development?
20:24:51 <augur> anyone familiar with the FFI know how to create a storable instance for compound data like lists?
20:24:51 <MP2E> haha
20:25:06 <vanila> stelleg, http://pastebin.com/raw.php?i=JrtvQ5ws
20:25:16 <edwardk> in general though you should ask yourself 'could i undo this operation perfectly'? if they fused two passes into one pass could they observe a difference? if the answer to both is yes, and the information needed to do both is contained in what you view, then you probably have a lens
20:25:22 <edwardk> there are tons of useful things that aren't lenses though
20:25:24 <LadyAurora> GHC is so grand, it even supports Windows!
20:25:32 <edwardk> mostly they are written as combinators using lens as building blocks
20:25:35 <augur> or, alternatively: how to get config data into haskell in a way that doesnt need to be redone?
20:25:40 <splintax> carter: don't use homebrew? how should i install ghc, the haskell platform is no longer the best option right?
20:25:44 <swgillespie> splintax: I do most of my development on a linux VM and it's great. I've got ghc installed on mac for local hacking though
20:25:53 <carter> splintax: i just install a ghc
20:26:01 <carter> build my own in my backyeard
20:26:04 <carter> do make install
20:26:07 <carter> and voila
20:26:10 <splintax> isn't that basically what homebrew will do for me
20:26:12 <carter> nope
20:26:14 <MP2E> no
20:26:15 <edwardk> i tend to make fairly dumb obvious lenses and compose them with interesting combinators
20:26:16 <stelleg> vanila oh cool, thanks
20:26:32 <augur> what i have is, im calling a haskell from outside of haskell, but the function has some parameters that it uses to parse and manipulate data
20:26:41 <carter> splintax: as MP2E  and other folks will agree, i spend a LOT of time helping make sure OS X stuff works
20:26:48 <carter> no one maintains the brew formula
20:26:50 <carter> they do weird stuff
20:26:53 <carter> no one maintains it
20:26:58 <carter> and they do weird stuff
20:27:00 <augur> and ideally i dont want to convert to and from haskell every time i need to call that function
20:27:11 <carter> storable vectors
20:27:14 <enthropy> augur: http://hackage.haskell.org/package/vinyl-0.4.3/docs/src/Data-Vinyl-Core.html has a Storable instance
20:27:21 <carter> huh
20:27:32 <enthropy> but I don't think it addresses the actual problem
20:27:36 <splintax> carter: ok cool, i'll build my own ghc from source and see how it goes. thanks for the advice
20:27:42 <LadyAurora> What if I want storable lists?
20:27:43 <augur> carter: elaborate?
20:27:51 <carter> splintax: well, you can install the bindists from the ghc website
20:28:01 <carter> http://www.haskell.org/ghc/download_ghc_7_8_3
20:28:06 <snickle> couldn’t you just brew edit and then have homebrew manage it…? or better yet, submit a pull request…?
20:28:08 <stelleg> vanila: so I guess the take away from that is that I don't have to build up the induction by hand with the type class
20:28:17 <carter> snickle: not that simple
20:28:30 <vanila> typeclasses are for open worlds
20:28:34 <vanila> data types for closed worlds
20:28:47 <vanila> your nested list thing is closed so you can develop it this way
20:28:52 <snickle> carter: :( i’m literally `brew install ghc`-ing right now so this is relevant to my interests lol
20:28:57 <augur> carter: how do storable vectors work for this?
20:29:08 <stelleg> Great, thanks for the help I'll do that
20:29:17 <carter> snickle: for one , dont use brew for ghc
20:29:22 <carter> http://www.haskell.org/ghc/download_ghc_7_8_3
20:29:40 <carter> brew still has the 7.6 as the "stable"
20:29:41 <mwhit> @where ghcformac
20:29:41 <splintax> this page is strongly encouraging me to use the haskell platform
20:29:42 <lambdabot> I know nothing about ghcformac.
20:29:48 <mwhit> @where+ ghcformac http://ghcformacosx.github.io/
20:29:49 <lambdabot> Good to know.
20:29:57 <mwhit> use ^^^
20:30:23 <LadyAurora> Seriously, what if I want storable lists?
20:30:51 <enthropy> LadyAurora: well you'd have to decide what kind of representation it should have on the C side
20:31:11 <enthropy> probably it should be a linked list over there too
20:31:17 <splintax> mwhit: looks good. (i uninstalled my homebrew ghc and then realised that will prevent me from building my own ghc...)
20:31:29 <carter> splintax: :)
20:31:33 <carter> you gotta boostrap
20:31:39 <carter> also its a good learning exercise to build your own
20:31:45 <carter> no reason to unless you're contribing to ghc
20:31:55 <carter> but its a short walk from building to contribing
20:32:00 <carter> and building is low pain these days
20:32:02 <carter> time consuming
20:32:03 <carter> but lowpain
20:32:20 <splintax> yeah. i'm keen to have a look into ghc soon, but right now i just want to stop feeling scared every time i install a new package
20:32:23 <swgillespie> bootstrapping in general takes forever :/
20:32:32 <swgillespie> rustc and gcc take forever
20:32:41 <carter> splintax: dont be scared
20:32:48 <carter> a) use cabal-install 1.20
20:32:54 <carter> there a binary of that prbbuild online
20:33:38 <carter> b) rm -rf ~/.ghc is SAFE
20:33:40 <carter> BUT
20:33:47 <carter> never rm ~/.cabal
20:34:26 <Ralith> carter: why not?
20:34:29 <LadyAurora> Why not?
20:34:43 <carter> well, if you know what you're doing, do it
20:34:51 <carter> but a) you never have to to fix ANYTHING ever
20:35:02 <carter> b) certain tools depend on file based assets
20:35:05 <carter> and those tend to live there
20:35:16 <carter> you don't want happy or pandoc or whatever suddnely breaking
20:35:42 <Ralith> well of course everything that lives in .cabal will be killed by rm -rf .cabal
20:35:47 <Ralith> that's trivial
20:36:01 <carter> Ralith: point being, Rming there will never fix anything
20:36:05 <carter> unless you're short on disk space
20:36:14 <Ralith> that's good to know
20:36:20 <Ralith> it just sounded like you were suggesting it was unsafe
20:36:27 <carter> well yeah,
20:36:52 <carter> if all your haskell tools but ghc live in ~/.cabal/bin
20:36:58 <carter> you'll have the sads
20:37:29 <augur> carter: if i use storable, wont i have to continuously translate the data between haskell and C?
20:38:03 <bms1> carter: Are you familiar with the arb-fft package? I'm wondering why he decided to use the less common sign convention for the FFT
20:39:28 <carter> augur: depends
20:39:37 <carter> bms1: lets ask iross  :)
20:39:41 <carter> bms1: to the #numerical-haskell!
20:39:46 <augur> carter: on?
20:40:10 <carter> augur: could you just user a Storable Vector?
20:40:12 <snickle> every haskell resource is telling me not to do something :( now i’m crying
20:40:29 <LadyAurora> Don't cry.
20:40:41 <snickle> >:(
20:40:48 <carter> snickle: literally? or just confusion?
20:40:56 <carter> write stuff and see what type checks
20:41:16 <augur> carter: well, what i need to store is non-trivial
20:41:25 <carter> pray elaborate
20:41:29 <augur> carter: its not like.. a list, right. its a bunch of complex data
20:41:35 <snickle> just confused all around
20:41:42 <carter> snickle: learning new things is confusing
20:41:49 <carter> snickle: what learning resource are you using?
20:42:12 <augur> carter: one type is essentially a tuple of lists, the lists contain representations of "predications"
20:42:29 <snickle> i’m using carter from #haskell, http://ghcformacosx.github.io, and http://www.haskell.org/ghc/download_ghc_7_8_3
20:42:56 <carter> snickle: ok, https://github.com/bitemyapp/learnhaskell/blob/master/README.md is pretty decent getting started meta tutorial
20:43:07 <augur> carter: the other thing i need to store is a Map String [Sign] (Sign is a complex data type as well)
20:43:13 <carter> augur: hrmmm
20:43:21 <carter> maybe you need to "denormalize" it
20:43:26 <augur> ?
20:43:26 <carter> ala SQL dbs
20:43:38 <augur> i dont know what you mean
20:44:05 <carter> so instead of having nested data structures you have flat refernces to values
20:44:05 <carter> http://en.wikipedia.org/wiki/Denormalization
20:44:58 <snickle> Ah thank you carter
20:45:33 <augur> carter: im not sure how that would work here
20:45:50 <augur> is there really no way to collect up some haskell data and send it out to C?
20:45:59 <carter> no, you can totes just bit bang
20:46:00 <orion> How can I configure the path of the haddock binary that cabal uses?
20:46:02 <carter> but its a pint
20:46:10 <carter> orion: you mean add it to the path?
20:46:16 <augur> carter: a what?
20:46:38 <carter> http://hackage.haskell.org/package/base-4.6.0.0/docs/Foreign.html
20:46:41 <carter> mallock and stuff
20:46:45 <augur> all i need to do is get this data out, hold on to it until the next function call, then shove it back in
20:47:09 <augur> i mean, ideally i wouldnt even do that, i just want the haskell function to keep ahold of this junk on its own
20:47:31 <orion> carter: I can specify the location of GHC with --with-compiler. I am looking for an option that does the same for haddock.
20:47:42 <carter> orion: what cabal version
20:47:56 <augur> like, i have a function that kind of simulates state, and i have an interaction loop that bounces that state around between calls of that function
20:47:59 <orion> 1.20.0.3
20:48:00 <carter> check your ~/.cabal/config file
20:48:11 <carter> if it doesn't have that field, you have an old cabal config file
20:48:19 <enthropy> augur: did you try storing that stuff in an IORef?
20:48:24 <carter> do mv ~/.cabal/config ~/.cabal/config-old ; cabal update
20:48:35 <orion> carter: If it doesn't have which field?
20:48:45 <carter> orion: you'll know
20:48:51 <augur> enthropy: i need to get it _out_ of haskell because i need to make the interaction happen outside haskell
20:49:11 <augur> enthropy: afaik there's no way to call haskell from C, in such a way that the haskell side maintains state
20:49:21 <carter> augur: you totes can
20:49:21 <augur> you have to bounce the state in and out of Haskell yourself
20:49:29 <augur> carter: how? oh god please how
20:49:30 <carter> i think
20:49:34 <carter> you startup the RTS
20:49:39 <augur> RTS?
20:49:46 <carter> you can write a c app that calls into hs
20:49:51 <carter> and back again
20:49:53 <carter> back and forther
20:49:55 <carter> back and forth
20:49:58 <carter> if you really want to
20:50:10 <augur> whats the RTS?
20:50:20 <augur> oh the haskell runtime
20:50:27 <gp5st1> I'm sorry I'm being entirely https://dpaste.de/KocL/raw stupid about this, but I can't get the typing correct. I want the sig to be Int -> [Int]
20:50:36 <carter> if you wanna persist state, ioref works
20:50:38 <gp5st1> sig of factors*
20:50:57 <augur> how do i do that from C in such a way that i can load some haskell code tho?
20:51:13 <orion> carter: thank you
20:51:20 <augur> i mean, what im envision is, if i have an executable, it interacts and can maintain state within that interaction at the shell
20:51:25 <augur> (within a single session)
20:51:35 <carter> augur: zoom out
20:51:37 <carter> why do you need c
20:51:54 <augur> carter: calling from ObjC
20:52:03 <carter> oh
20:52:08 <carter> you could do language-inline-c
20:52:18 <carter> https://hackage.haskell.org/package/language-c-inline
20:52:37 <orion> carter: This is strange... why is there ghc-location AND with-compiler?
20:52:39 <augur> carter: im going to (probably) do ObjC for plugins and UI junk and Haskell for the serious processing
20:52:54 <carter> orion: ?
20:52:56 <augur> carter: i'd like to avoid ObjC if possible but i dont think thats an option
20:53:30 <orion> carter: The default config file I just generated has both with-compiler and ghc-location.
20:53:34 <orion> It seems redundant.
20:53:38 <carter> idk
20:53:45 <carter> orion: but you see the other fields
20:53:47 <carter> right?
20:53:50 <Enigmagic> augur: you can create a global IORef (icky) or if you own the C side of things use a StablePtr instead.. you can use them over the ffi boundary
20:53:54 <orion> I do
20:54:03 <augur> Enigmagic: tell me more
20:54:19 <Enigmagic> augur: http://hackage.haskell.org/package/base-4.7.0.1/docs/Foreign-StablePtr.html
20:54:49 <augur> Enigmagic: thats the solution i needed!
20:55:03 <augur> Enigmagic: thank you so much!
20:55:22 <Enigmagic> np
20:57:13 <augur> ok im off to sleep i think
20:57:17 <augur> night Enigmagic, carter
20:58:14 <Enigmagic> augur: https://github.com/alphaHeavy/quickfix-hs/blob/master/src/AlphaHeavy/QuickFIX/Foreign.hs#L161
20:58:24 <Enigmagic> have a good night
20:59:00 <genisage> gp5st1: replace `[2..(floor (sqrt(n)))]` with takeWhile (\x -> n > x*x)
20:59:16 <genisage> gp5st1: replace `[2..(floor (sqrt(n)))]` with `takeWhile (\x -> n > x*x) [2..]`
21:00:22 <snickle> yay carter thanks for your help
21:00:34 <genisage> Or write your own function that does floor . sqrt and takes an Int
21:00:36 <carter> snickle: see why the new cabal config file has nice things?
21:01:39 <snickle> btw i did actually need to rm -rf ~/.cabal, but only because i upgraded to yosemite and cabal had been installed in there, and i ended up switching to ghcformacosx
21:02:01 <snickle> but that’s 100% edge case ;)
21:02:17 <gp5st1> genisage: is getting the typing to work that hard or is that just more idiomatic?
21:02:20 <cgag> trying to play with snap, can't get it to build, looks like lens is failing to compile and complaining about multiple instance declarations, does this sound like it's more like it's a problem on my end or on snap/len's end?
21:02:43 <bb010g> How does this look for an alternate Prelude? It's not documented really yet, but the core is there. https://github.com/bb010g/yapp/blob/master/src/YAPP.hs
21:02:55 <gp5st1> genisage: sorry, I know very little about haskell except that I think it's the language I keep kind of creating in my head :-p or at least very close
21:02:59 <edwardk> cgag: pull the latest version hackage
21:03:08 <carter> snickle: you ddin't need to RM
21:03:12 <edwardk> cgag: there was a snafu where someone sent me a patch that looked good and applied clean in 7.8
21:03:18 <carter> snickle: you enver have to rm
21:03:19 <carter> there
21:03:19 <edwardk> but had an issue i'd forgotten about for 7.6 or so
21:03:20 <carter> ever
21:03:32 <edwardk> so i had to ship out new versions of semigroupoids and lens
21:04:36 <snickle> eh i’d rather start fresh than have a dead outdated version of cabal sitting in there waiting to cause issues
21:04:43 <mwhit> genisage: Numeric types are often a prickly point for beginners, because Haskell is very precise about what operations can be applied to what sorts of numbers
21:04:51 <mwhit> it demands type rigor from people who are still getting used to the idea
21:05:35 <carter> snickle: you can cabal install cabal-install
21:05:39 <carter> snickle: ALWAYS
21:06:06 <snickle> oh word
21:06:06 <mwhit> so I wouldn't say "getting the typing to work [is] that hard" so much as "numeric types in particular are finicky"
21:06:17 <snickle> lol my bad then
21:06:22 <carter> math is tricky
21:06:25 <mwhit> err
21:06:28 <mwhit> that should all be
21:06:32 <mwhit> gp5stl:
21:06:50 <gp5st1> mwhit: yeah. I'm not opposed to strict typing:) but trying to figure those conversions out is...challenging :-p
21:07:03 <mwhit> when in doubt, fromIntegral
21:07:09 <genisage> gp5st1: It's not really hard. It's a matter of keeping track of the type of every function you use. Sometimes functions you'd really like to use have irritating types (I'm looking at you length) and that's a bit annoying.
21:07:22 <genisage> Definitely takes getting used to.
21:09:11 <bb010g> genisage: There's nothing stopping you from making a length' with the definition from GHC.List save the use of Integer.
21:09:52 <funnybutton> how do I write an IRC bot in haskell?
21:10:08 <funnybutton> I need a mentor as I'm a newbie programmer that has never written a line of code
21:10:16 <johnw> funnybutton: take an unformed lump of Haskell, and remove everything which is not an IRC bot
21:10:29 <aarvar> download lambdabot and put your name on it
21:10:33 <bb010g> funnybutton: Have you taken a look at https://github.com/bitemyapp/learnhaskell?
21:10:45 <funnybutton> no, thanks
21:11:07 <mwhit> find the utf-8 encoded program in pi
21:11:13 <mwhit> if we're giving snarky answers for some reason
21:11:21 <genisage> mwhit: what it it's not there?
21:11:24 <carter> darn
21:11:33 <carter> is funnybutton gone?
21:11:34 <mwhit> we're assuming pi is normal for the sake of this argument
21:11:38 <genisage> ok
21:11:55 <carter> this also wasn't a very welcoming response
21:12:00 <carter> oh well
21:12:09 <carter> johnw: did folks snark too hard?
21:12:25 <johnw> snark about what?
21:12:41 <carter> ways to write an irc bot
21:12:42 <carter> idk
21:12:43 <carter> i'm tired
21:12:48 <aarvar> I think he left to read the link
21:12:51 <carter> ah
21:13:12 <bb010g> johnw: I now want to make a esoteric language where you have to "carve" out programs. :)
21:13:32 <aarvar> Carving oriented programming
21:13:44 <aarvar> Sculpture oriented programming
21:13:54 <johnw> gives new meaning the burrito analogy
21:14:10 <mwhit> has anyone done the satirical "programming oriented programming" blog post yet?
21:14:37 <snickle> to be fair “i’ve never written a line of code in my life and i want to write an IRC bot in haskell” is umm…ambitious?
21:14:47 <carter> true
21:14:52 <carter> networking engineering aint trivial
21:14:58 <carter> even in the easy case
21:15:25 <lispy> someone who doesn't know about programming is more likely to not understand that it's unrealistic
21:15:46 <glguy> It's good to have a goal when you're learning a language. I'd expect that as he tries to figure out how to get to IRC bot he'll learn some new stuff along the way
21:15:46 <bb010g> mwhit: A quick DDG search says no.
21:15:57 <aarvar> He'll probably give up on the bot though
21:16:00 <lispy> glguy: that too
21:16:02 <__jim__> does anyone have any experience capturing audio with the openAL bindings?
21:16:47 <__jim__> or has suggestions for a better library for playing and capturing audio?
21:17:12 <snickle> i mean my first foray into haskell was LYAH and i’m pretty sure they abstracted i/o into a tiny dark corner of the mansion that was never to be touched
21:17:27 <lispy> __jim__: sorry, no first or second hand experience over here
21:17:36 <__jim__> ah, np
21:18:57 <aarvar> I started reading learn you a haskell but stopped because it spent so much time just listing functions
21:19:19 <lispy> aarvar: did you replace it with something else?
21:19:46 <aarvar> no, but since I know scala im probably not the target audience
21:20:21 <lispy> time to move on to conference papers :)
21:20:34 <snickle> lispy: i’m going back and doing the upenn tut now
21:21:00 <lispy> (the functional pearls are quite nice and usually approachable)
21:21:18 <lispy> The monad reader is another source of interesting haskell topics
21:22:28 <carter> hackage has some gems too
21:22:34 <lispy> once you get past the basics it's all about the cycle of "read something, write something"
21:23:09 <aarvar> Is it possible to have open union types in a language like haskell?
21:23:22 <johnw> what is that?
21:23:39 <aarvar> Like, to be able to create a type A|B which is a union of the existing types A and B
21:23:48 <johnw> you mean like (A,B)?
21:23:52 <dfeuer> How many phases of RULES does GHC have?
21:23:55 <aarvar> No
21:23:56 <aarvar> A or B
21:24:00 <johnw> Either A B?
21:24:08 <aarvar> yeah, but for any arity
21:24:11 <jle`> data Either a b = Left a | Right b
21:24:15 <aarvar> you cant say Either A B C
21:24:19 <johnw> oh, I see what you mean
21:24:20 <jle`> a tagged union
21:24:28 <aarvar> an untagged union I think
21:24:29 <shachaf> @google ghc phases
21:24:30 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Using_rules
21:24:30 <lambdabot> Title: GHC/Using rules - HaskellWiki
21:24:37 <jle`> you can do A `Either` B `Either` C
21:24:39 <shachaf> The answer is on that page.
21:24:46 <aarvar> ADTs force you to declare constructors at the declaration site
21:24:52 <jle`> or A `Either` B `Either` C `Either` D
21:24:53 <carter> dfeuer: 4?
21:24:59 <carter> at least 0-3
21:25:25 <aarvar> I was thinking if you could have A|B for existing A and B, then for certain typeclasses you could construct an isntance of A|B from an isntance of A and an instance of B
21:25:27 <shachaf> aarvar: If you want you can write a type Sum where Sum [A,B,C,D] is like Either A (Either B (Either C (Either D)))
21:25:38 <shachaf> whoa, whoa, whoa
21:25:44 <shachaf> Type classes?
21:25:57 <lispy> dfeuer: This page says to use -dverbose-core2core to see the sequence of phase numbers: https://www.haskell.org/ghc/docs/7.6.3/html/users_guide/pragmas.html#phase-control
21:26:03 <lispy> dfeuer: but I don't see a specific number
21:26:35 <lispy> ah, sorry I see shachaf has the answer
21:26:36 <aarvar> I suppose nested eithers might work
21:27:00 <jle`> aarvar: it's somewhat equivalent to (A,B,C)
21:27:12 <jle`> (A `Either` B `Either` C)
21:27:31 <jle`> if you substitute (,) with Either
21:27:37 <jle`> it's not really, but
21:27:41 <aarvar> but then you'd have to convert between types which should be equivalent right?
21:27:59 <shachaf> Sum [A,B] would be equivalent to Either A B
21:28:23 <aarvar> but would be different from Sum[B, A]
21:28:40 <shachaf> Of course.
21:28:46 <splintax> sorry to bring up the cabal/ghc/haskell-platform question again, but is haskell platform definitely "deprecated" by this irc channel?
21:28:52 <dfeuer> I kind of wish the rule application order were done by analyzing stated dependencies, rather than by phase number.
21:28:57 <shachaf> Sum [A,A] would also be different from A.
21:28:59 <splintax> from what i can tell it comes with ghc 7.6?
21:29:08 <aarvar> If you had a lot of possible types it would be a pain to reorder them to be equivalent
21:29:15 <johnw> somebody here wrote something that used type lists to provide something like this, IIRC
21:29:27 <johnw> I think it may be have been lispy
21:29:52 <aarvar> I was messing aroud in Scala and I wrote something was sort of able to emulate this
21:29:54 <dfeuer> splintax: no, HP is not deprecated. In fact, it's in RC2 coming up to a new release.
21:30:16 <splintax> ok. i was just strongly encouraged to use ghc 7.8 by some people here earlier
21:30:31 <splintax> it looks like not even debian unstable has 7.8 :/
21:31:22 <aarvar> Arch has 7.8
21:31:23 <dfeuer> splintax: wait a week or two, and then you can download the new platform. Not sure when distros will get packages out.
21:31:23 <lispy> johnw: oh I think I know what you're talking about. I think that example actually comes from the ghc user guide?
21:31:40 <dfeuer> Unfortunately, Fedora 21 won't have 7.8 :-(
21:31:41 <johnw> hmm.. maybe it wasn't you then
21:32:12 <stelleg> succ Arch
21:33:44 <stelleg> so I have a challenge, who can write the following without the type classes: http://sprunge.us/QZIW
21:33:57 <stelleg> s/classes/class
21:35:07 <shachaf> Yes, by deleting every class and instance declaration.
21:35:13 <aarvar> Is there a way to express something like mathematical expressions where you can add both new data types and functions
21:35:13 <cgag> edwardk, this was lens 4.1.2.1 i believe, upgrading to the latest version fixed it but it might not be related to what you desribed, i guess the snap init project should just depend on a newer version of lens, i'll make an issue or something
21:36:02 <stelleg> shachaf: but then you have multiple instances of empty?
21:36:38 <shachaf> No, I have zero instances of empty.
21:37:08 <stelleg> *whoosh* goes the joke
21:37:29 <solidus-river> jle`: when using a statefull wire and gettin gin the interval is that interval itself a raw timedelta or is it a session :\
21:37:37 <solidus-river> i'm back to the point where i gotta turn the crank and i'm confused about the types
21:37:51 <shachaf> Your joke is not very good, and neither is your challenge.
21:38:06 <stelleg> I was assuming you were joking
21:38:18 <stelleg> I want to implement empty
21:38:31 <stelleg> without the type classes
21:38:33 <shachaf> Oh. In that case, never mind.
21:38:46 <stelleg> I could have been more clear
21:38:57 <shachaf> I can't help you, but I think that's better phrased as a question rather than a challenge, and with enough clarity that people know what you're trying to do.
21:39:00 <shachaf> Anyway.
21:41:07 <trap_exit> I'm looking at http://www.haskell.org/haskellwiki/Generalised_algebraic_datatype ... and it looks like standard haskell code. Are GADTs part of standard haskell now, or if not, what problem do they soove?
21:42:19 <bb010g> trap_exit: I find this helps more: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
21:42:20 <enthropy> stelleg: you could make another gadt that you pattern match on to go from (S n) to n
21:42:57 <enthropy>  data ANat n where AS :: n -> ANat (S n); AZ :: ANat Z
21:43:57 <solidus-river> so i guess once the dtime is extracted
21:44:06 <kvanb_> if you have a GADT sum type
21:44:28 <kvanb_> can you somehow subtly change its type without reconstructing it
21:44:29 <solidus-river> nvm, learning to read types ftw
21:44:33 <enthropy> so then you can combine the right-hand sides of the two instances in a function  mkEmpty :: ANat n -> Nested n a
21:44:46 <trap_exit> bb010g: so the point of GADTs is that the _return type_ of a _constructor_ can be different ?
21:44:59 <trap_exit> s/constructor/a constructor with all arguments filed in/
21:45:25 <trap_exit> i.e. data Term = T_Int Int | T_Bool Bool <--> all constructors, after having all terms filled in, have the same type, "Term"
21:45:57 <trap_exit> but now, we can do data Term a = T_Int Int -> Term Foo, T_Bool Bool -> Term Bar <--> that T_Int and T_Bool constructors, after having all arguments filled in, ahve different return types
21:46:00 <enthropy> but now you have the same problem of getting an ANat from a type n which needs a class as far as I know
21:46:03 <trap_exit> is this the key / the point of GADTs ?
21:46:40 <dfeuer> aarvar: there was an experimental ML dialect that was supposed to do that add functions and add values thing. Not sure if anyone's still playing with that.
21:46:53 <trap_exit> someone please resolve my GADt insecurity by telling me I'm right
21:46:57 <bb010g> trap_exit: Yep.
21:48:04 <bb010g> That a in Term a is called a phantom type, as it isn't ever "needed" by the type itself but just hangs around giving context.
21:49:27 <mwhit> an extra difference is that you can put typeclass constraints on GADT constructors and they will behave as you'd expect
21:50:01 <mwhit> i.e. pattern-matching on the contructor makes that constraint available for the value found in the pattern
21:50:59 <jle`> solidus-river: having any luck?
21:51:22 <enthropy> you could look at "data Term a where T_Int :: Int -> Term Int" as "data Term a where T_Int :: (a ~ Int) => a -> Term a"
21:51:40 <hiptobecubic> In parsec, how should I structure this if I want to parse something like "3.4+8i" but also just "8i"
21:51:45 <enthropy> so there's just one concept to keep track of
21:52:19 <hiptobecubic> So possibly read a float and then a '+' and then read an imaginary number
21:52:38 <enthropy> 3.4-8i -- not allowed?
21:53:27 <splintax> if i have documentation: True in ~/.cabal/config, then installing dependencies in a cabal sandbox should generate documentation in .cabal-sandbox/share/doc right?
21:53:38 <splintax> i've got a directory for each package in there, but no documentation, just LICENCE files
21:54:03 <splintax> including aeson, which should come with some documentation right?
21:56:35 <Enigmagic> splintax: it needs to go into a cabal.config file in the sandbox
21:56:47 <Enigmagic> splintax: take a look at the cabal.sandbox.config file
21:57:01 <Enigmagic> or pass --enable-documentation when you're installing stuff
21:58:59 <splintax> ah i must have misread as thinking it would inherit from ~/.cabal/config rather than ./cabal.config
21:59:24 <kvanb_> my cabal config keeps corrupting itself for no reason
22:00:38 <dwcook> Enigmagic, I don't think that's true. I have compiled documentation with no extra effort besides enabling it in ~/.cabal/config
22:01:35 <glguy> It could be something like the haddock in the $PATH doesn't match the GHC version being used to compile
22:01:37 <trap_exit> alright
22:01:37 <trap_exit> I give up
22:01:38 <splintax> dwcook: i am using 1.20; Enigmagic's advice worked for me
22:01:42 <trap_exit> what is the easy way to install ghc 7.8.3 on osx ?
22:01:47 <trap_exit> I give up compiling from source
22:01:50 <dwcook> splintax, I was contesting the "needs to" part.
22:01:56 <splintax> dwcook: however, i'm trying to build the documentation for my dependencies, not my package
22:01:56 <bb010g> trap_exit: You could try Nix
22:02:08 <dwcook> splintax, understood
22:02:17 <mwhit> @where ghcformac
22:02:18 <lambdabot> http://ghcformacosx.github.io/
22:02:20 <mwhit> ^^^
22:02:28 <benzrf> bbl
22:02:40 <benzrf> bye
22:02:51 <trap_exit> bb010g: damn, Nix looks awesome
22:03:17 <bb010g> trap_exit: This is a good overview focusing on Haskell: http://fuuzetsu.co.uk/blog/posts/2014-06-28-My-experience-with-NixOS.html
22:03:23 <mwhit> it does, though I'm not sure that counts as "the easy way"
22:03:48 <bb010g> mwhit: Better than compiling from source manually.
22:04:05 <mwhit> not as good as drag-and-drop into Applications
22:04:23 <orion> fmap unzip . forM tests $ \(s, a) -> printf "%-45s: " s >> a -- could someone please put parentheses around this according to how haskell would parse it?
22:05:01 <bb010g> (fmap unzip) . (forM tests (\(s,a) -> (printf "%-45s: " s) >> a))
22:05:16 <trap_exit> bb010g: nix is  package manager; is NiXOS a entire separate OS? as it it repalces OX ?
22:05:18 <orion> Composition always throws me for a loop.
22:05:24 <bb010g> You don't really need that $ as \ is right associative
22:05:26 <mwhit> nixOS is a linux distro
22:05:26 <dwcook> orion, ((fmap unzip) . (forM tests)) $ (\(s, a) -> (((printf "%-45s: ") s) >> a))
22:05:35 <splintax> how do people experiment with new hackage libraries? i'm using a sandbox for my project now which seems to be working well, but what i need is like a sub-sandbox just to put the new packages in until i decide i definitely want to depend on them
22:05:47 <splintax> i can just install the package into my sandbox but then i can't uninstall it
22:05:56 <splintax> and rebuilding the whole sandbox from scratch takes like 5 minutes
22:05:57 <bb010g> trap_exit: NixOS is Linux using Nix as a package manager. The information in the post is still relevant.
22:06:12 <mwhit> splintax: so just leave them there, unless they start causing issues
22:06:33 <splintax> ok, in which case i will just wait 5 minutes and rebuild using --only-dependencies
22:06:47 <carter> splintax: cabal sandbox add source
22:06:48 <trap_exit> bb010g: you've convinced me to fire up virtualbox and try nixos
22:06:50 <carter> or whatever the command it
22:07:08 <jle`> solidus-river: https://gist.github.com/mstksg/278c43f4a825af9523a0
22:07:11 <jle`> for an example
22:07:22 <dwcook> bb010g, that's not right, ($) binds less tightly than (.)
22:07:24 <carter> splintax: cabal sandbox add-source  [PATHS]
22:07:30 <carter> try it out in a sandbox
22:07:33 <carter> idk
22:07:36 <splintax> is there a quick command that opens up local documentation for the specified package?
22:07:45 <carter> @hackage vector
22:07:45 <lambdabot> http://hackage.haskell.org/package/vector
22:07:48 <carter> splintax: :)
22:08:01 <carter> OR have a url to you rlocal docs
22:08:01 <bb010g> dwcook: Thanks for catching that
22:08:07 <carter> splintax: OS X?
22:08:11 <splintax> carter: yeah
22:08:21 <splintax> i can write a quick function in bash to do it
22:08:24 <jle`> what's the best way to apply a function to every item in a Vector in parallel
22:08:24 <carter> it'll be something like file:///Users/carter/.cabal/share/doc/index.html
22:08:27 <splintax> but thought haddock might do it or somethign
22:08:30 <jle`> fixed length, same function
22:08:30 <carter> jle`: map
22:08:34 <carter> :)
22:08:37 <jle`> :P
22:08:45 <jle`> multi core parallelism
22:08:49 <jle`> or gpu parallelism
22:08:53 <splintax> carter: yeah i can get to the docs, i just want to open them from the cli with "docs Data.Tree" or something
22:09:00 <carter> jle`: dpeends
22:09:03 <jle`> the vector's contents are boxed
22:09:12 <carter> jle`: well, if its boxed, no gpu for you
22:09:14 <bb010g> trap_exit: If you want more info/help, check out #nixos
22:09:16 <jle`> o yea
22:09:18 <jle`> drat
22:09:18 <carter> jle`: chunk up the array into slices
22:09:27 <carter> and have a parallel worker queue
22:09:28 <jle`> how about cpi
22:09:30 <jle`> cpu
22:09:30 <trap_exit> bb010g: there already
22:09:32 <jle`> hm
22:09:35 <trap_exit> jle`: !
22:09:49 <carter> jle`: honestly, paralle work queue
22:10:09 <carter> if yiou wannt make it look pure, you'll have to unsafePerformIO somehwere
22:10:31 <carter> and you'll spend a buncha time messing with RTS options and stuff
22:11:17 <carter> jle`: basically, writing parallel stuff is ahrd
22:11:29 <jle`> isn't haskell supposed to make parallelism easy
22:11:36 <carter> normally its just impossible
22:11:39 <carter> in haskell its hard
22:11:41 <carter> well
22:11:44 <carter> easy / hard depends
22:11:44 <jle`> parallel worker queue, as in using concurrency tools?
22:11:48 <carter> yeah
22:11:54 <carter> you can't just say "rub concurrency on it"
22:12:04 <jle`> what about these http://chimera.labs.oreilly.com/books/1230000000929/index.html
22:12:17 <carter> well yeah
22:12:19 <carter> those are haskell tools
22:12:39 <jle`> none of these tools seem really suitable for the kind of batch processing
22:12:44 <carter> lol
22:12:46 <Total_1mmersion> Is QuickCheck a good tool to use when refactoring to help ensure that the changes do not break the behavior?
22:12:49 <carter> jle`: false
22:12:54 <jle`> are they all built around GHC's concurrency primitives?
22:12:55 <carter> jle`: you haven't read the book yet properly
22:13:00 <carter> jle`: go read the book
22:13:01 <jle`> i read it last year :|
22:13:02 <carter> youv'e not read it
22:13:06 <carter> read it again
22:13:06 <carter> :)
22:13:15 <jle`> they seem to all deal with forky branchy logicky stuff
22:13:17 <carter> nope
22:13:19 <carter> read more
22:13:19 <jle`> except for repa/accelerate
22:13:25 <carter> duh
22:13:30 <carter> they ALLL use threads
22:13:34 <carter> allll of them
22:13:46 <carter> any flat parallelis just hides that from you
22:13:49 <jle`> but can't i tak advantage of the non-forky branchy nature of my computation?
22:13:52 <orclev> haskell makes concurrency harder to screw up, it doesn't really make it easier to implement, just easier to implement correctly
22:13:52 <carter> nope
22:13:55 <carter> you can
22:14:05 <carter> orclev: ++
22:14:15 <carter> jle`: i suggest you read the book when you're not tired
22:14:17 <carter> and epxeriment
22:14:30 <jle`> ok
22:14:32 <bb010g> Total_1mmersion: As good as it would be the first time around, so yes.
22:14:57 <carter> orclev: i actually added a parallel hash based duplication detector to a batch processing app today
22:15:21 <carter> ie i was already processing things in paralle, and i needed to add duplication detection to the parallel computation
22:15:38 <jle`> carter: so should i be looking at repa then, because accelreate is gpu?
22:15:38 <orclev> that sounds... tricky
22:15:58 <carter> jle`: whats teh computation
22:16:08 <carter> jle`: repa packages it up so you just parallel map
22:16:14 <jle`> just applying a the same function on every item on a vector
22:16:16 <jle`> repeated
22:16:18 <jle`> ly
22:16:26 <carter> jle`: read what I just said
22:16:31 <carter> jle`: and read that book again
22:16:40 <carter> i don't think you internalized the ways you can use all those tools :)
22:17:06 <carter> jle`: yes try out repa
22:17:11 <carter> orclev: yes and no
22:17:54 <carter> was a 3 liner
22:18:12 <carter> http://lpaste.net/108477
22:18:21 <carter> and then i got a nice little thread safe predicate
22:18:32 <ddellacosta> there was this great article I saw recently about benefits of typing, and it talked a bit about the red flag of seeing Strings in code at decision points, and how types obviate that...does this article ring a bell for anyone?  I can't find it
22:18:32 <jle`> i looked at all the non-repa tools and i didn't see how they could take advantage of the non-forky branchy nature of my computation.  but i'll look at them again, and at repa too
22:18:44 <carter> jle`: work queue
22:18:57 <carter> jle`: you need to think more abstrctly
22:19:08 <orclev> carter: yeah, I was just about to ask if you did it by pushing the hashes into a set as you processed them
22:19:09 <carter> every say 100/1000 entries gets a name/number
22:19:12 <jle`> i ran into some issues when using repa on a project about a year ago because i felt like i was just playing a guessing game with fusion
22:19:18 <carter> jle`: no fusion for you
22:19:21 <carter> orclev: yup
22:19:24 <carter> basically CAS
22:19:37 <carter> well, that op is a retry loop of casing
22:19:46 <hiptobecubic> @pl f c = g >>= \x -> h c >> return x
22:19:46 <lambdabot> f = (g >>=) . (. return) . (>>) . h
22:19:55 <hiptobecubic> ... nope
22:19:58 <orclev> Stringly typed code is a code smell
22:20:00 <jle`> carter: yeah i was using it to do some complexish finite element stuff and i couldn't get it to parallelize for some reason
22:20:14 <carter> orclev:?
22:20:19 <jle`> but this is something pretty simple
22:20:22 <orclev> what ddellacosta was saying
22:20:23 <carter> jle`: i know what you did
22:20:32 <glguy> hiptobecubic: g <* h c
22:20:34 <carter> jle`: you tried to do nested array computation in repa
22:20:40 <carter> you can't do nested stuff in repa
22:20:42 <carter> or you'll get the slows
22:20:43 <hiptobecubic> glguy, que?
22:20:52 <jle`> worker queue sounds nice but it feels like there's a lot of overhead in doing it manually
22:20:57 <carter> jle`: lol
22:20:59 <jle`> but i guess deep down all of these are implemented that way?
22:21:05 <carter> jle`: you don't know what you're tlaking about :)
22:21:06 <hiptobecubic> glguy, ohhh nice
22:21:07 <glguy> ?type \g h c -> g <* h c
22:21:08 <lambdabot> Applicative f => f a -> (t -> f b) -> t -> f a
22:21:19 <jle`> carter: that does happen a lot :|
22:21:27 <carter> jle`: you need to experiment and benchmark
22:21:45 <carter> spawning a thread takes < 1 microsecond
22:22:03 <hiptobecubic> oh i get it... the arrow thing points to the thingy
22:22:05 <jle`> the marlow book made me afraid of spawning threads
22:22:15 <carter> nope
22:22:18 <hiptobecubic> :t (*>)
22:22:19 <lambdabot> Applicative f => f a -> f b -> f b
22:22:24 <hiptobecubic> :t (<*>)
22:22:25 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:22:26 <carter> it should make you realize that you don't need the full generality
22:22:52 <jle`> there is some sweet spot, and too small chunks = too much overhead, too large chunks = not enough benefit
22:22:58 <carter> wat
22:23:00 <ddellacosta> orclev: thanks, that was helpful. This may be the article I was thinking of: http://techblog.realestate.com.au/the-abject-failure-of-weak-typing/
22:23:05 <carter> jle`: no
22:23:18 <carter> the issue with too large chunksis some threads idle while other finish
22:23:24 <carter> but thats not gonna be your problem
22:23:26 <jle`> oh yea
22:23:40 <carter> jle`:just write stuff and measure
22:23:43 <carter> stop over thinking
22:23:53 <jle`> but how do i know how to properly chunk for a generic situation
22:23:56 <carter> no
22:23:58 <carter> measure
22:24:07 <carter> theres no such thing as generic when it comes ot performance engineering
22:24:23 <jle`> such sad
22:24:24 <carter> no
22:24:30 <carter> such powah
22:24:44 <carter> also if it was that easy, the underlying problems wouldnt be so compute consuming
22:24:57 <carter> orclev: anyways atomics ftw!
22:25:02 <carter> nuclearly powered predicates
22:25:05 <jle`> i'll bet back to you
22:25:06 <carter> *nuclear
22:25:08 <jle`> get
22:25:17 <carter> jle`: read thebook, try all the approaches
22:25:21 <carter> measure
22:25:32 <carter> using the ghc-event log tools + criterion
22:25:43 <orclev> carter: I had done something similar in a toy piece of code I wrote, but I used STM and a bounded channel in my case
22:26:17 <carter> orclev: yeah, STM makes more sense when you don't have a sort of idempotence
22:26:32 <carter> in this case its "is it in the set? nope? ok, add it"
22:27:31 <carter> because STM lets you get a consistent view on multiple thing
22:27:54 <orclev> carter: in my case I was using it to calculate primes (demonstration of a port of some existing code to haskell), so I was trimming non-primes out of the set as I went
22:28:49 <orclev> or something like that... its been a while since I wrote it
22:29:14 <carter> i've yet to write concurrent enough software to need STM
22:29:29 <carter> any code i've written so far has like 1 shared variable
22:29:32 <carter> well
22:29:33 <carter> not quite
22:29:37 <dwcook> carter, no network servers so far?
22:29:40 <carter> dwcook: nope
22:29:47 <carter> the internet is scary
22:30:06 * hackagebot vty 5.1.4 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.1.4 (CoreyOConnor)
22:30:13 <carter> dwcook: well, i guess mutable arrays count as "lots of mutable variables"
22:30:14 <carter> :P
22:30:17 <edwardk> cgag: i know the thing i mentioned is an issue, the latest version of semigroupoids added instances that broke lens. i went back and took the opportunity since everything was already broken to move more instances down there
22:31:34 <dwcook> carter, you said "concurrent enough"… so it was concurrent but not to the point where you needed much protection? What parts were concurrent?
22:31:50 <carter> dwcook: if theres more than one writer to a variable
22:32:01 <carter> well
22:32:03 <carter> hrmm
22:32:08 <carter> if you have 2 variables
22:32:17 <carter> and two seperate thread that migth read/write them
22:32:19 <carter> in some combination
22:32:29 <carter> the semantics of those reads and writes is easier to understand with STM
22:32:33 <orion> hmm
22:33:02 <carter> because otherwise you need to coordinate with somethign thats a lock
22:33:13 <carter> i generally try to write codes in a way that is lock free
22:33:16 <dwcook> carter, all I know is I don't know much about the nitty gritty of concurrency and STM seems to have made it so I don't need to :)
22:33:21 <orclev> found it... I think in my case the use of STM and the channels was driven more from my using conduit and there being simple bindings available for it... anway, it's probably terrible code, but here it is: https://github.com/orclev/concurrent-prime/blob/master/main.hs
22:33:32 <dwcook> carter, I'm sure there are things I'm missing but I'll pick those up as necessary
22:34:10 <dwcook> Like I didn't know the rules for retrying until semi-recently
22:42:15 <hiptobecubic> Is there a reason to use things like `optional` from Parsec instead of just Control.Applicative?
22:42:22 <hiptobecubic> Or is just reexported for convenience
22:42:44 <johnw> optional is not a re-export, it seems
22:43:11 <johnw> but no, no reason
22:43:22 <orion> How does function composition work if you have two functions of different arity?
22:43:33 <johnw> you need to do things like (f .) . g
22:43:39 <johnw> if f is 2-arity and g is 1
22:43:44 <johnw> it can get ugly fast
22:43:50 <carter> or flip?
22:44:07 <carter> it winds up looking like circuits
22:44:15 <johnw> most people introduce the points manually: (\x y -> f (g x y))
22:44:31 <johnw> where by "most" I mean a completly unknown quantity
22:44:52 <orclev> it's arguably easier to understand than some convoluted mixture of (.) and flip
22:45:14 <Enigmagic> @pl f x y a b c = (x a b) (y c)
22:45:14 <lambdabot> f = flip . ((flip . ((.) .)) .)
22:45:26 <orclev> yeah... that
22:45:31 <Enigmagic> looks okay to me ;)
22:45:58 <orion> In a way, (.) sequences evaluation, am I right?
22:46:21 <lispy> not evaulation, but it does data flow
22:46:34 <carter> @pl f x y g h i k =   g k i $ h x y
22:46:34 <lambdabot> f = (flip ((.) . flip . (flip .) . flip) .) . flip . flip id
22:46:37 <johnw> in the presence of laziness, it may be opposed to the sequence you think it has
22:46:38 <carter> wooo
22:46:41 <johnw> opposite*
22:46:49 <orclev> when things start heading that way I usually reach for Arrow and Applicative before I start playing games with (.) and flip
22:47:03 <johnw> a . b . c -- a may never use its argument, and so b . c is unevaluated
22:48:03 <hiptobecubic> @pl \f c -> f c c
22:48:03 <lambdabot> join
22:48:08 <hiptobecubic> ... oh
22:48:11 <hiptobecubic> :t join
22:48:12 <lambdabot> Monad m => m (m a) -> m a
22:48:32 <johnw> for the function monad: (a -> a -> r) -> (a -> r)
22:48:39 <hiptobecubic> So this is the (-> a) monad?
22:48:45 <johnw> yep
22:48:58 <orclev> this first time I saw that it blew my mind
22:49:15 <hiptobecubic> i see what it does, i just don't see how it maps to my understanding of functions or monads
22:49:16 <zRecursive> :t (-> a)
22:49:17 <lambdabot> parse error on input ‘->’
22:49:21 <lispy> Using join that way in "real code" is not ... recommended :)
22:49:49 <johnw> it can be a tad too clever
22:49:52 <johnw> but sometimes... :)
22:50:36 <hiptobecubic> :t join between (char '"')
22:50:37 <lambdabot> Not in scope: ‘between’
22:50:40 <hiptobecubic> oh well
22:51:26 <johnw> if you're using Parsec, you may want to look at using a Tokenizer
22:51:35 <johnw> it'll handle the intricacies of literal strings for you
22:53:48 <roboguy_> :k forall a. ((->) a)
22:53:49 <lambdabot> * -> *
22:54:00 <roboguy_> zRecursive: ^ maybe that's closer to what you're interested in?
22:55:57 <dwcook> > join (++) "choo"
22:55:59 <lambdabot>  "choochoo"
22:56:09 <hiptobecubic> why doesn't (<$>) have low precedence like ($)?
22:56:36 <dwcook> hiptobecubic, I suppose because its main purpose is to be an infix fmap rather than to avoid parens.
22:56:46 <hiptobecubic> johnw, working through Write Yourself A Scheme
22:56:52 <dfeuer> As a general rule, any time you're tempted to write (.) as something other than the first argument to fold ... think again.
22:56:56 <roboguy_> hiptobecubic: it also associates the other way
22:58:00 <hiptobecubic> hmm, indeed
22:58:26 <zRecursive> roboguy_: yeah
22:59:12 <carter> dfeuer: 'cause of saturation?
23:00:09 <dwcook> dfeuer, that sounds much too general. Do you mean as an argument to a fold that isn't the first one?
23:00:30 <mwhit> :t (.) . (.)
23:00:32 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
23:00:42 <roboguy_> I wonder why they decided on left associativity for $
23:00:45 <roboguy_> *right
23:00:55 <dwcook> Though I've never seen a situation where someone has used (.) as an argument to a fold except as the first
23:01:45 <roboguy_> > foldr _ (.)
23:01:47 <lambdabot>  Found hole ‘_’
23:01:47 <lambdabot>    with type: a
23:01:47 <lambdabot>               -> ((b -> c) -> (a1 -> b) -> a1 -> c)
23:01:47 <lambdabot>               -> (b -> c)
23:01:47 <lambdabot>               -> (a1 -> b)
23:01:57 <orclev> I'd say anytime you're tempted to write (.) as an argument to (.) think again, but that's mostly personal preference, and if it really did make a piece of code simpler to understand I'd ignore that rule
23:02:18 <finlandssvensk> So I finally sat down and read Learn You a Haskell
23:02:34 <mwhit> oh I wasn't trying to imply the boobies operator should be used in real code
23:02:51 <finlandssvensk> I think I had a haskgasm
23:03:37 <orclev> finlandssvensk: lol... LYAH is pretty good although it does drag a big in places, particularly if you've already got a functional background
23:03:42 <orclev> bit
23:04:07 <finlandssvensk> I am also going to read Real World Haskell
23:05:11 <orclev> I was not as impressed with real world haskell... a lot of what's covered in it actually seems to be out of date now... in particular the file IO stuff I don't feel is very good
23:05:19 <mwhit> read the online version for RWH
23:05:26 <mwhit> there are inline comments that can tell you where it's out of date
23:05:28 <tac> bah. How do you tell if a FilePath points to a regular file, not a directory?
23:05:45 <mwhit> also these are probably more modern resources:
23:05:48 <mwhit> @where yorgey
23:05:48 <lambdabot> http://www.seas.upenn.edu/~cis194/lectures.html
23:05:51 <mwhit> @where nicta
23:05:51 <lambdabot> https://github.com/nicta/course
23:06:02 <finlandssvensk> I find $ and . amusing for some reason...
23:06:19 <dfeuer> carter: because most other uses are obfuscated.
23:06:28 <carter> ah
23:06:33 <finlandssvensk> And yet strangely beautiful
23:06:49 <roboguy_> dfeuer: you don't like the pipeline style?
23:06:54 <carter> i just use it when i have f . g . h . k . l . m . n . p . help . i'm . stuck . in . pointfree . notation
23:06:56 <dfeuer> Folding (.) Seems sensible, however.
23:07:37 <dfeuer> roboguy_: what pipeline style?
23:07:38 <finlandssvensk> So does lambdabot evaluate code?
23:08:03 <mwhit> finlandssvensk: yes, just start the line with "> "
23:08:09 <Enigmagic> > sum [1..10]
23:08:10 <dfeuer> No, finlandssvensk. Lambdabot reads your mind and tells you what *you* think your code should do.
23:08:11 <lambdabot>  55
23:08:12 <carter> > "yes" ++ " it does"
23:08:14 <lambdabot>  "yes it does"
23:08:15 <roboguy_> dfeuer: you know, like "someFn x = thirdOperation x . secondOperation . firstOperation" that kind of thing
23:08:34 <orclev> lately I've been leaning towards not mixing $ and . with each other... I.E. f . g . h, or f $ g $ h x y, but not f . g $ h x y
23:08:50 <roboguy_> or something like fn x a = thirdOperation a . secondOperation . firstOperation $ x
23:08:51 <mwhit> i think he meant literally (.), as in passing it around unapplied
23:09:00 <roboguy_> oh
23:09:03 <dfeuer> > sum [p..q]
23:09:05 <lambdabot>  *Exception: not an integer: p
23:09:06 <dwcook> orclev, it's a bit non-obvious sometimes when to cut it off, isn't it? That's one reason I favor parens unless I can omit the argument.
23:09:54 <dfeuer> roboguy_: I've written such from time to time, but it's not my favorite. But yeah, I mean brain-twisters like ((.).)
23:11:00 <roboguy_> yeah, that's never a good idea I think. fmap fmap fmap fmap is worse though
23:11:14 <dfeuer> If GHCi crashes on something, will lambdabot? Like
23:11:24 <carter> lambdabot is pretty hardened
23:11:36 <mwhit> he's seen some shit
23:11:37 <carter> like, if you coudl break it now, thats quite a feet
23:11:48 <dfeuer> > (1::Integer) `shiftL` (2^62)
23:11:50 <lambdabot>  gmp: overflow in mpz type
23:11:52 <Enigmagic> > sum [1..10] :: Expr
23:11:54 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
23:12:41 <dfeuer> That expression I gave it crashes GHCi. I don't know how to tell if lambdabot crashed and restarted or didn't crash.
23:13:00 <finlandssvensk> Does lambdabot crash on `fix show'?
23:13:13 <Enigmagic> try it out :P
23:13:20 <finlandssvensk> > fix show
23:13:21 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
23:13:39 <finlandssvensk> Well nice to know it handles infinite output well
23:13:46 <dwcook> dfeuer, having problems with lambdabot? I know just what to do
23:13:47 <dwcook> > fix error
23:13:49 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
23:13:52 <tac> How do you tell if a FilePath points to a regular file, not a directory?
23:13:54 <dwcook> Uh, well then.
23:13:54 <dfeuer> Huh? Where are those backslashes from?
23:14:23 <Enigmagic> escaping the quote
23:14:24 <dfeuer> That's kind of hilarious, dwcook.
23:14:25 <orclev> dfeuer: it's escaping the quote
23:14:26 <finlandssvensk> > let x = show x in x
23:14:26 <tac> dfeuer: the show gives you a string
23:14:28 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
23:14:36 <tac> and when you show any string, it opens up with a "
23:14:38 <orclev> then it's escaping the escape
23:14:50 <dfeuer> Whoa.
23:15:18 <dfeuer> > take 50 $ fix show
23:15:20 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
23:15:30 <dwcook> tac, how much do you care about portability? I believe there's an isDirectory in some POSIX-related module.
23:15:57 <tac> dwcook: not really. I saw System.Posix in base, but that didn't look like it had all the posix stuff
23:16:22 <dwcook> http://www.haskell.org/hoogle/?hoogle=isDirectory
23:16:23 <Enigmagic> > map length $ group (fix show)
23:16:28 <lambdabot>  mueval-core: Time limit exceeded
23:16:28 <dfeuer> dwcook: POSIX is a family of standards. Conforming to them renders code portable.
23:16:43 <dwcook> Hmm, that search results seems weird
23:16:45 <Enigmagic> > take 10 $ map length $ group (fix show)
23:16:46 <lambdabot>  [1,1,1,3,1,7,1,15,1,31]
23:16:52 <dwcook> I would've expected FilePath -> IO Bool or something
23:17:09 <dfeuer> @let potatoe = "Al Gore"
23:17:09 <dwcook> dfeuer, yes, between things that implement POSIX.
23:17:10 <finlandssvensk> > let doTheThing = (show doTheThing) ++ (show doTheThing) in doTheThing
23:17:12 <lambdabot>  Defined.
23:17:12 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
23:17:17 <hiptobecubic> @pl \f op a b -> f a `op` f b
23:17:17 <tac> ty
23:17:17 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
23:17:19 <dfeuer> Yes, a joke.
23:17:22 <hiptobecubic> hah
23:17:32 <dfeuer> Because that was Dan Quayle.
23:17:38 <dfeuer> Anyone else remember him?
23:17:46 <hiptobecubic> 92?
23:17:58 <dfeuer> > potatoe
23:18:00 <lambdabot>  "Al Gore"
23:18:14 <mwhit> haha
23:18:26 <dfeuer> > (1::Integer) `shiftL` (2^60)
23:18:28 <lambdabot>  gmp: overflow in mpz type
23:18:29 <dfeuer> > potatoe
23:18:31 <lambdabot>  "Al Gore"
23:18:38 <dfeuer> Ah, so it did not crash.
23:18:49 <roboguy_> Enigmagic: that's interesting
23:18:50 <dfeuer> Very interesting.
23:18:55 <hiptobecubic> hmm. isn't that `on` ?
23:18:57 <hiptobecubic> :t on
23:18:58 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
23:18:58 <mwhit> doesn't it keep all the local bindings in a module somewhere
23:19:01 <dfeuer> @let potatoe = Dan Quayle
23:19:01 <mwhit> the L module
23:19:01 <lambdabot>  .L.hs:154:1:
23:19:02 <lambdabot>      Multiple declarations of ‘potatoe’
23:19:02 <lambdabot>      Declared at: .L.hs:153:1
23:19:02 <lambdabot>                   .L.hs:154:1
23:19:02 <lambdabot>  
23:19:05 <mwhit> ^^^
23:19:17 <dfeuer> @forget potatoe
23:19:17 <lambdabot> Incorrect arguments to quote
23:19:31 <hiptobecubic> @pl \op f a b -> f a `op` f b
23:19:31 <lambdabot> join . ((flip . ((.) .)) .) . (.)
23:19:52 <dwcook> tac, jackpot http://hackage.haskell.org/package/directory-1.2.1.0/docs/System-Directory.html#v:doesFileExist
23:20:01 <mwhit> @pl \a b c d -> a b d b c b
23:20:02 <lambdabot> join . ((flip . (flip .) . flip) .) . (flip =<<)
23:20:02 <tac> thanks
23:20:17 <mwhit> @pl \a b c d -> a b d =<< b c b
23:20:18 <lambdabot> (`ap` join flip) . (((.) . flip . ((=<<) .)) .)
23:20:39 <dfeuer> > drop 4 potatoe
23:20:40 <lambdabot>  "Quayle"
23:20:57 <bb010g> I wish @pl knew Applicative
23:20:59 <mwhit> > take 4 potatoe
23:21:00 <lambdabot>  "Dan "
23:21:24 <greenElephant> ....
23:22:24 <dwcook> bb010g, it has ap as a primitive operation, which might be the next best thing
23:22:59 <finlandssvensk> > let greeting = "Hello!"
23:23:00 <lambdabot>  not an expression: ‘let greeting = "Hello!"’
23:23:06 <dwcook> bb010g, or, did you mean something besides the Applicative instance for functions?
23:23:07 <finlandssvensk> Oh
23:23:13 <finlandssvensk> I see how it is
23:23:20 <roboguy_> finlandssvensk: try @let
23:23:23 <vanila> @let greeting name = "Hello " ++ name ++ "!"
23:23:24 <lambdabot>  Defined.
23:23:29 <vanila> > greeting "finlandssvensk"
23:23:31 <lambdabot>  "Hello finlandssvensk!"
23:23:37 <vanila> :)
23:24:06 <bb010g> dwcook: I didn't really think of ap; I guess that works.
23:24:15 <finlandssvensk> Ah
23:24:49 <dfeuer> @help eval
23:24:49 <lambdabot> eval. Do nothing (perversely)
23:25:02 <roboguy_> :t let f a = (a, a, a); g a = (f a, f a, f a); h a = (g a, g a, g a); p a = (h a, h a, h a) in p
23:25:02 <dfeuer> Yeah, whose idea was that?
23:25:04 <lambdabot> t -> ((((t, t, t), (t, t, t), (t, t, t)), ((t, t, t), (t, t, t), (t, t, t)), ((t, t, t), (t, t, t), (t, t, t))), (((t, t, t), (t, t, t), (t, t, t)), ((t, t, t), (t, t, t), (t, t, t)), ((t, t, t), (t, t, t), (t, t, t))), (((t, t, t), (t, t, t), (t, t, t)), ((t, t, t), (t, t, t), (t, t, t)), ((t, t, t), (t, t, t), (t, t, t))))
23:25:04 <bb010g> @eval
23:25:56 <mwhit> @src eval
23:25:57 <lambdabot> Source not found. Whoa.
23:26:02 <finlandssvensk> @let very f x = f (f ( x))
23:26:03 <lambdabot>  Defined.
23:26:21 <finlandssvensk> > very greeting "finlandssvensk"
23:26:23 <lambdabot>  "Hello Hello finlandssvensk!!"
23:26:27 <vanila> hehe
23:26:28 <roboguy_> how much can type inference take advantage of sharing? I've heard that there isn't really around it being O(n^2) in certain cases...
23:26:38 <solidus-river> :e .
23:26:42 <solidus-river> d'o
23:26:45 <solidus-river> d'oh
23:26:50 <mwhit> use your words
23:26:54 <finlandssvensk> > very very greeting "vanila"
23:26:55 <lambdabot>  "Hello Hello Hello Hello vanila!!!!"
23:27:00 <vanila> hahaha
23:27:03 <vanila> tthat's great
23:27:12 <mwhit> pull request: add very to prelude
23:27:12 <meoranas> Fun^42=420
23:27:34 <roboguy_> like the type of this starts to get crazy: let f a = (a, a, a); g a = (f a, f a, f a); h a = (g a, g a, g a) in h . h
23:27:34 <finlandssvensk> > very very very very very greeting "mwhit"
23:27:36 <lambdabot>  "Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hel...
23:27:50 <bb010g> @let such f m x = m . m $ f x
23:27:51 <lambdabot>  Defined.
23:28:10 <finlandssvensk> we should implement a doge dsl
23:28:26 <bb010g> > such greeting very "finlandssvensk"
23:28:28 <lambdabot>  Couldn't match type ‘t0 -> t0’ with ‘[GHC.Types.Char]’
23:28:28 <lambdabot>  Expected type: [GHC.Types.Char] -> [GHC.Types.Char]
23:28:28 <lambdabot>    Actual type: (t0 -> t0) -> t0 -> t0
23:28:44 <vanila> :t such
23:28:45 <lambdabot> (t -> s) -> (s -> s) -> t -> s
23:28:51 <finlandssvensk> @let such x = x ++ x
23:28:53 <lambdabot>  .L.hs:151:1:
23:28:53 <lambdabot>      Equations for ‘such’ have different numbers of arguments
23:28:53 <lambdabot>        .L.hs:151:1-24
23:28:53 <lambdabot>        .L.hs:152:1-15
23:29:00 <dfeuer> mwhit: request denied. The prelude only has stuff in the standard.
23:29:00 <finlandssvensk> Mmkay
23:29:09 <bb010g> 23:26:54 <bb010g> @let such f m x = (m . m) f x
23:29:25 <tac> If you want to use a cabal package you created locally... but haven't uploaded it to Hackage.... where do you put it?
23:29:34 <finlandssvensk> @let such' x = x ++ x
23:29:36 <lambdabot>  Defined.
23:29:36 <bb010g> @forget such
23:29:37 <lambdabot> Incorrect arguments to quote
23:29:39 <tac> and how do you notify cabal build to look for your package?
23:29:41 <mwhit> dfeuer: i can't tell if you're going along with the joke or taking that seriously
23:29:50 <tac> (I'm using a sandbox if that matters)
23:30:06 <bb010g> @unlet such
23:30:06 <lambdabot>  Parse failed: TemplateHaskell is not enabled
23:30:11 <dfeuer> mwhit: going along.
23:30:12 <tac> do I just cabal install <pathto .cabal file?>?
23:30:16 <vanila> TemplateHaskell? Now we're in real trouble
23:30:28 <mwhit> @del
23:30:28 <lambdabot> Maybe you meant: url tell pl let keal help do
23:30:35 <mwhit> @undef
23:30:35 <lambdabot> Undefined.
23:30:39 <mwhit> oh
23:30:42 <mwhit> undefined what
23:30:44 <finlandssvensk> @let so x = such' such' x
23:30:45 <lambdabot>  .L.hs:149:8: Not in scope: ‘such'’
23:30:46 <lambdabot>  
23:30:46 <lambdabot>  .L.hs:149:14: Not in scope: ‘such'’
23:30:50 <bb010g> @undef such
23:30:51 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
23:30:57 <bb010g> @let such f m x = m . m $ f x
23:30:59 <lambdabot>  Defined.
23:31:06 <bb010g> Dang it
23:31:11 <bb010g> @undef
23:31:11 <lambdabot> Undefined.
23:31:24 <bb010g> @let such f m x = (m . m) f x
23:31:25 <lambdabot>  Defined.
23:31:42 <bb010g> @let very f = f . f
23:31:42 <mwhit> @let very f = f . f
23:31:43 <lambdabot>  Defined.
23:31:44 <lambdabot>  .L.hs:150:1: Warning:
23:31:44 <lambdabot>      Pattern match(es) are overlapped
23:31:44 <lambdabot>      In an equation for ‘very’: very f = ...
23:31:44 <lambdabot>  
23:31:45 <lambdabot>  <no location info>:
23:31:56 <finlandssvensk> @let enthusiastically x = x ++ "!!!!"
23:31:58 <lambdabot>  Defined.
23:32:26 <finlandssvensk> > very very enthusiastically greeting "finlandssvensk"
23:32:27 <lambdabot>  Not in scope: ‘greeting’
23:32:32 <finlandssvensk> Aaaaaah
23:32:46 <bb010g> @let greet x = "Hello " ++ x
23:32:48 <lambdabot>  Defined.
23:33:16 <bb010g> such greet very "finlandssvensk"
23:33:20 <vanila> lol
23:33:23 <finlandssvensk> > very very enthusiastically greet "finlandssvensk"
23:33:24 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’
23:33:24 <lambdabot>                with ‘[GHC.Types.Char] -> [GHC.Types.Char]’
23:33:25 <lambdabot>  Expected type: ([GHC.Types.Char] -> [GHC.Types.Char])
23:33:25 <lambdabot>                 -> [GHC.Types.Char] -> [GHC.Types.Char]
23:33:25 <lambdabot>    Actual type: [GHC.Types.Char] -> [GHC.Types.Char]
23:33:46 <finlandssvensk> I'm no doctor, but
23:33:53 <bb010g> > such greet very "finlandssvensk"
23:33:55 <lambdabot>  "Hello Hello Hello Hello finlandssvensk"
23:34:05 <hiptobecubic> @pl \f g x -> f . g x x
23:34:06 <lambdabot> (. join) . (.) . (.)
23:34:09 <finlandssvensk> Now we need much
23:34:09 <mwhit> @let majestic x = "**" ++ x ++ "**"
23:34:11 <lambdabot>  Defined.
23:34:15 <mwhit> @let wow = "wow"
23:34:16 <lambdabot>  Defined.
23:34:22 <roboguy_> > very . very . enthusiastically . greet $ "finlandssvensk"
23:34:23 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’ with ‘a -> a’
23:34:24 <lambdabot>  Expected type: [GHC.Types.Char] -> a -> a
23:34:24 <lambdabot>    Actual type: [GHC.Types.Char] -> [GHC.Types.Char]
23:34:27 <mwhit> > such greet very $ majestic wow
23:34:29 <lambdabot>  "Hello Hello Hello Hello **wow**"
23:34:42 <finlandssvensk> @let majestically x = majestic x
23:34:43 <lambdabot>  Defined.
23:34:56 <finlandssvensk> > magestically greet "doge"
23:34:57 <lambdabot>  Not in scope: ‘magestically’
23:34:57 <lambdabot>  Perhaps you meant ‘majestically’ (line 153)
23:34:58 <roboguy_> > (very . very $ enthusiastically) . greet $ "finlandssvensk"
23:35:00 <lambdabot>  "Hello finlandssvensk!!!!!!!!!!!!!!!!"
23:35:11 <finlandssvensk> Oh
23:35:14 <vanila> @let much = (=<<) (replicate 2)
23:35:15 <lambdabot>  Defined.
23:35:32 <finlandssvensk> > majestically greet "doge"
23:35:33 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char] -> t’
23:35:33 <lambdabot>              with actual type ‘[GHC.Types.Char]’Couldn't match expected type ...
23:35:34 <lambdabot>              with actual type ‘[GHC.Types.Char] -> [GHC.Types.Char]’
23:35:41 <vanila> > much wow
23:35:43 <lambdabot>  "wwooww"
23:35:56 <bb010g> @let doge = "doge"
23:35:57 <lambdabot>  Defined.
23:36:03 <finlandssvensk> > such very majestically greet doge
23:36:05 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’
23:36:05 <lambdabot>                with ‘([GHC.Types.Char] -> [GHC.Types.Char])
23:36:05 <lambdabot>                      -> [GHC.Types.Char] -> [GHC.Types.Char]’
23:36:05 <lambdabot>  Expected type: (([GHC.Types.Char] -> [GHC.Types.Char])
23:36:05 <lambdabot>                  -> [GHC.Types.Char] -> [GHC.Types.Char])
23:36:09 <mwhit> @let majestically f x = f (majestic x)
23:36:10 <lambdabot>  .L.hs:155:1:
23:36:11 <lambdabot>      Equations for ‘majestically’ have different numbers of arguments
23:36:11 <lambdabot>        .L.hs:155:1-27
23:36:13 <lambdabot>        .L.hs:156:1-33
23:36:15 <hiptobecubic> @pl \f g x y -> f (g x y)
23:36:16 <lambdabot> (.) . (.)
23:36:25 <finlandssvensk> > such very majestic doge
23:36:26 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’ with ‘(a -> a) -> a -> a’
23:36:27 <lambdabot>  Expected type: ((a -> a) -> a -> a) -> (a -> a) -> a -> a
23:36:27 <lambdabot>    Actual type: [GHC.Types.Char] -> [GHC.Types.Char]Couldn't match expected t...
23:36:27 <lambdabot>              with actual type ‘[GHC.Types.Char]’
23:36:34 <hiptobecubic> boob operator ...
23:36:34 <finlandssvensk> > majestic doge
23:36:36 <lambdabot>  "**doge**"
23:36:54 <finlandssvensk> > majestic greet doge
23:36:56 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char] -> t’
23:36:56 <lambdabot>              with actual type ‘[GHC.Types.Char]’Couldn't match expected type ...
23:36:56 <lambdabot>              with actual type ‘[GHC.Types.Char] -> [GHC.Types.Char]’
23:37:10 <mwhit> > magestic $ greet doge
23:37:11 <lambdabot>  Not in scope: ‘magestic’
23:37:12 <lambdabot>  Perhaps you meant ‘majestic’ (line 154)
23:37:13 <mwhit> > majestic $ greet doge
23:37:15 <lambdabot>  "**Hello doge**"
23:37:23 <orion> Is there a nice and simple way to refactor this code in to one function?: http://lpaste.net/4556762577941561344
23:37:24 <bb010g> > greet $ majestic doge
23:37:26 <lambdabot>  "Hello **doge**"
23:37:49 <dfeuer> WELL.
23:38:02 <bb010g> That was fun.
23:38:09 <finlandssvensk> > very majestic doge
23:38:11 <lambdabot>  "****doge****"
23:38:19 <codolio> That's quite enough.
23:39:06 <orion> I think I am violating DRY.
23:39:10 <bb010g> I think #haskell-blah is good now.
23:39:23 <roboguy_> orion: yeah, make the "quickCheckResult prop" things an argument
23:40:25 <vanila> or make a new function for the 'case r of ...' bit
23:40:49 <roboguy_> that's what I mean
23:41:09 <roboguy_> also, I feel like you could use record syntax in the pattern matching to make that shorter
23:41:12 <dwcook> The two functions have this in common: (>>= \case of …)
23:41:39 <vanila> wow, is \case of real syntax?
23:41:46 <dwcook> With LambdaCase enabled it is
23:41:50 <vanila> that's neat
23:41:55 <vanila> I like that
23:42:15 <tac> @src ap
23:42:15 <lambdabot> ap = liftM2 id
23:42:19 <tac> :<
23:42:26 <tac> @src liftM2
23:42:27 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:42:30 <dwcook> Yeah, often I'd rather write let f = \case of … than let f x = case x of …
23:42:33 <roboguy_> ap = (<*>)
23:42:42 <roboguy_> when there's an Applicative instance at least
23:42:47 <dwcook> Oh, woops, the "of" isn't part of LambdaCase syntax
23:42:51 <roboguy_> (which there should be)
23:43:24 <orion> I'm confused... are there times when using composition is the same as application?
23:43:31 <dwcook> orion, nope
23:43:34 <dwcook> Well
23:43:41 <vanila> f $ g $ x is the same as f . g $ x
23:43:46 <orion> A ha
23:43:50 <vanila> but $ and . are different
23:43:50 <dwcook> g . f is an application of (.) to g and the application of that result to f
23:44:07 <vanila> note these parse as
23:44:10 <dwcook> But I assume that's not quite what you were asking
23:44:16 <vanila> f $ (g $ x)  and  (f . g) $ x
23:44:22 <vanila> so the similarity is only superficial
23:44:22 <orion> dwcook: vanila knows what I mean
23:44:32 <roboguy_> orion: you could also do something like this I think, in the case pattern matches: Failure {numTests=n} -> return (False, n)
23:44:37 <roboguy_> and avoid all those _s
23:44:49 <dwcook> orion, yeah, I figured you were alluding to that. The fact that (.) and ($) are sometimes syntactically interchangeable is merely a pun.
23:44:54 <orion> roboguy_: What kind of syntax is that?
23:44:55 <orion> dwcook: I see.
23:44:59 <roboguy_> orion: record syntax
23:45:02 <orion> ah
23:45:58 <orion> Wow, this is cool. Thank you all.
23:46:31 <Enigmagic> orion: another idea: http://lpaste.net/108478
23:46:37 <roboguy_> orion: in fact, some of the internal parts of quickcheck uses that kind of pattern matching (it's what reminded me): http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/src/Test-QuickCheck-Test.html#isSuccess
23:47:55 <finlandssvensk> Sorry for my ridiculous connection
23:48:58 <finlandssvensk> @let sqrt' n = n ** 0.5
23:49:00 <lambdabot>  Defined.
23:49:19 <finlandssvensk> > sqrt' 49
23:49:21 <lambdabot>  7.0
23:49:29 <finlandssvensk> Yays
23:52:11 <orion> gr
23:53:03 <orion> I am aggravated that `cabal build blah' insists on rebuilding all my cbits even though they haven't changed at all.
23:53:18 <splintax> i am writing a DSL that compiles to a directory full of ugly XML, much of which is boilerplate. what's an easy way to store that boilerplate as a directory in my source tree, and give my compiler a way to access it?
23:53:30 <splintax> currently i have just hard-coded the path to the boilerplate directory into my program and it works fine
23:53:47 <finlandssvensk> I have yet to learn how to use cabal
23:53:47 <splintax> but i don't want to have to distribute that directory with the compiler
23:55:51 <trap_exit> does haskell have a queue that supports blocking read? http://hackage.haskell.org/package/stm-2.4.2/docs/Control-Concurrent-STM-TBQueue.html seems to be non-blocking
23:55:56 <trap_exit> since it returns a Maybe
23:56:08 <trap_exit> I want a bblocking queue since I'm using Concurrent.forkIO to creat multiple threads
23:56:31 <Enigmagic> trap_exit: readTBQueue is blocking
23:58:31 <orion> Would it be accurate to describe a haskell application as a large tree whose trunk is IO, the branches are other monads, and the leaves are pure functions?
23:59:18 <vanila> orion, I've never thought of it that way, but that's quite reasonable!
23:59:42 <dwcook> orion, there's nothing fundamental about monads
23:59:45 <Enigmagic> aren't most monads pure?
23:59:54 <dwcook> Yes, Enigmagic raises a good point
23:59:57 <c_wraith> If you pretend IO is a free monad, it *is* a tree.
