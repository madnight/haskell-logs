00:00:01 <jle`> program things, ask for code review, dig into new topics that you don't understand
00:00:07 <Guest21244> yeah, is there any good set of coding excercises I can solve along
00:00:16 <jle`> have you programmed before?
00:00:17 <MP2E> Project Euler is pretty fun in the beginning
00:00:27 <jle`> i don't really think coding exercises were too useful for me
00:00:28 <MP2E> it's mostly mathematics though, it's not really "real world programs"
00:00:33 <MP2E> which are also pretty important
00:00:33 <jle`> i liked programming things that i wanted to see happen
00:00:37 <Guest21244> yeah I have programmed in Scala, Java, a little bit of clojure
00:00:47 <jle`> what have you programmed in those languages...?
00:00:48 <Guest21244> hmm like web ;)
00:01:00 <jle`> hmmmmm web might be a tall order for a first project in haskell
00:01:03 <Guest21244> real life projects, mostly web applications
00:01:10 <jle`> it was my second or third, and it took me a whole summer to get my blog up
00:01:13 <Guest21244> and couple of publishing projects
00:01:27 <jle`> what sort of publishing?
00:01:53 <Guest21244> catalogue publishing
00:02:05 <jle`> oh, for web?
00:02:11 <Guest21244> its a kinda marketing product
00:02:15 <Guest21244> yeah its web based
00:02:56 <jle`> did you ever take programming classes at school?  do you remember any assignments you enjoyed doing?
00:03:26 <Guest21244> yeah, I loved spam filtering algorithms
00:03:27 <mkrtem> You don't have to be great at haskell to do web stuff with yesod
00:03:32 <Guest21244> and kinda alogos
00:03:35 <jle`> i think seeing how haskell fits into the context of what you are already known and familiar with is nice
00:03:53 <jle`> Guest21244: you can implement a spam filtering algorithm...that sounds like something haskell would fit well into :)
00:04:02 <jle`> it sounds like you're already familiar with the mathematics
00:04:25 <Guest21244> yeah, I am a computer science becheoler
00:04:26 <Guest21244> :)
00:04:31 <jle`> noice
00:04:39 <Guest21244> but I missed to look into haskell in my college days
00:04:43 <ruuns> bayes rocks :]
00:04:51 <jle`> yeah, haskell sounds like it would be a good fit
00:04:52 <Guest21244> bayes was my last year project
00:05:29 <jle`> my personal recommendation (which you can choose to head or ignore) is to make a web project your second or third haskell one
00:05:44 <jle`> if web is what you are really familiar with
00:05:57 <jle`> but i think seeing how awesom haskell fits into a mathematical domain would be a fun experience
00:06:04 <Guest21244> yeah that make sense to me as well
00:06:22 <jle`> haskell has a lot to offer in web
00:06:25 <jle`> trust me
00:06:36 <jle`> but it will take a bit more experimenting, i think, before you can really appreciate it
00:07:11 <jle`> (but what do i know...?)
00:07:29 <Elyse21>  Hi! I give you some videos. I hope you like! http://bitly.com/WOkDBU
00:08:04 * hackagebot easy-file 0.2.0 - Cross-platform File handling  http://hackage.haskell.org/package/easy-file-0.2.0 (KazuYamamoto)
00:08:04 * hackagebot wai-logger 2.1.2 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-2.1.2 (KazuYamamoto)
00:08:15 <Guest21244> thanks guys, you are so awesome, I see I am going to enjoy haskell community
00:08:27 <jle`> Guest21244: no problem. i've enjoyed it :)
00:08:36 <trap_exit> there's something I hate about haskell
00:08:37 <jle`> you also might want to subscribe to the haskell reddit, some nice articles pop up there
00:08:38 <trap_exit> and I'm not sure how to fix it
00:08:50 <Guest21244> sure, I will
00:08:53 <trap_exit> every time I use haskell, I end up thinking: damn it, when didn't I take it seriously 7 years ago?
00:08:59 <trap_exit> how do I kill this regret
00:09:05 <jle`> trap_exit: you need to program a time machine in haskell
00:09:08 <MP2E> hahaha
00:09:10 <jle`> completely in software, of course
00:09:16 <Guest21244> ha ha,  that thing is started wid me
00:09:18 <MP2E> Time Monad
00:09:23 <trap_exit> jle`: I think I saw a monad for time travel the other day
00:09:38 <MP2E> libtardis
00:09:43 <jle`> there's a Tardis monad
00:09:49 <jle`> that allows forward and backwards state
00:09:56 <mkrtem> trap_exit: i suffer the same way
00:10:05 <Guest21244> Elyse gave a porn url
00:10:09 <Guest21244> :(
00:10:28 <MP2E> yeah unfortunately 'Nickname21' bots sometimes show up placing NSFW videos
00:10:29 <trap_exit> was it high quality?
00:10:36 <Pythonfant> Guest21244: when someone posts a bit.ly url you can expect it to be spam
00:10:37 <MP2E> for some reason their names are always suffixed with 21
00:10:38 <trap_exit> I actually started learning haskell 7 years ago
00:10:55 <trap_exit> but then was: "well, this syntax is ridiciousl ; I like lisp"
00:10:58 <jle`> Guest21244: well...one way you can tell is that they were kicked with a "no spam" message :)
00:11:04 <trap_exit> and thus, the seven worst years of my life
00:11:32 <MP2E> ... you picked Lisp over Haskell because of the syntax?
00:11:33 <MP2E> XD
00:11:41 <MP2E> I hated the brackets
00:11:45 <MP2E> err parenthesis
00:11:50 <MP2E> they drove me nuts :V
00:11:51 <jle`> that's a bit opposite of what most people do ;)
00:11:58 <jle`> MP2E: they're called brackets in some cultures, i believe
00:12:29 <pzel> I also prefer lisp syntax, and I worked in haskell for 3 years -- I think its genetic
00:12:30 <trap_exit> well, I read SICp
00:12:33 <trap_exit> and after SICP, I loved ()'s
00:12:48 <trap_exit> haskell's syntax was a bit daunting
00:13:10 <trap_exit> then there's the name clash with records
00:13:23 <jle`> i think one thing is that people think functional programming and they think "oh so it's like lisp", as if lisp represented all functional programming...and other languges are just lisp with different syntax
00:13:32 <trap_exit> like data Blah = Blah { x :: Int, y :: Int }; data Foo = Foo { x :: int, y :: Int}
00:13:32 <trap_exit> you just redefined x
00:13:34 <trap_exit> wtf ????
00:13:41 <jle`> in the same way that you think all imperative programming is like C or java with different syntax or something
00:13:50 <trap_exit> is there was .x, .y, which took the arg in front of into account, I'd be happy
00:14:11 <jle`> but haskell is very much unlike the flavor of functional programming that lisp represents...in fact, i don't even think the main benefits of haskell are its functional style at all
00:14:15 <isomorpheous> trap_exit: I don't think that would compile
00:14:21 <jle`> that might be a nice secondary or ternary benefit
00:14:45 <isomorpheous> jle`: it's the corollaries that are nice
00:15:11 <jle`> yeah, it's a nice means to an end, but not an end in and of itself
00:15:22 <pzel> jle`:  what corollaires do you have in mind?
00:15:48 <isomorpheous> pzel: lazy evaluation, strong typing, monadic I/O
00:16:03 <jle`> type-safe higher order functions (especially with typeclasses) allow things like parametricity, free theorems, and implementation/type safety
00:16:09 <jle`> well
00:16:11 <jle`> and code-reuse
00:16:28 <jle`> type-safe code re-use benefiting from parametricity
00:16:47 <jle`> i think the type system is really the greatest benefit, and almost all of the benefits of haskell stem from the type system
00:16:53 <jle`> the functional style helps out in its own way
00:16:56 <isomorpheous> yeah
00:16:58 <pzel> jle`: that pretty much nails it
00:17:20 <jle`> and that's just the parts that i can link to 'functional style'
00:17:43 <jle`> which i am taking vaguely to mean reliance on higher order functions and pure functions
00:17:56 <trap_exit> haskell is better than lisp for handling higher order functions
00:17:58 <jle`> and a declarative-ish style
00:17:58 <trap_exit> especially currying
00:18:17 <jle`> the best parts of haskell i believe don't link too closely to that directly
00:18:18 <trap_exit> but it's really the type system taht gets me
00:18:21 <jle`> yeah, definitely so
00:18:26 <jle`> the type system is something i did not expect
00:18:33 <trap_exit> the whole notion of "if it compiles, it proably either (1) works or (2) does somethign completely fucked up"
00:18:45 <jle`> i thought, 'hey, i know functional programming!  map, filter...pure functions!  what could haskell possibly offer that lisp doesn't have?'
00:18:54 <Pythonfant> I used to hate static type systems untill I started learning haskell
00:19:05 <isomorpheous> Pythonfant: i'm with you there
00:19:08 <jle`> i repeated that mantra as if it were absolute truth
00:19:14 <jle`> "dynamic types help me be more productive!
00:19:17 <jle`> i can write code faster!"
00:19:19 <jle`> lol
00:19:21 <isomorpheous> jle`: haha
00:19:31 <jle`> >_>
00:19:52 <jle`> i mean it would be more funny if it wasn't actually taken as truth by so many people
00:20:41 <sgronblo> jle`: thats what dynamic proponents do
00:20:53 <jle`> yeah :/
00:21:09 <isomorpheous> jle`: well, it sort of does
00:21:19 <isomorpheous> jle`: you can get code out faster
00:21:25 <MP2E> If you count pure LOC output as 'more productive' :P
00:21:25 <jle`> heh
00:21:33 <isomorpheous> jle`: but it takes a lot longer to get production-quality code
00:21:34 <jle`> oh yeah, i guess rate of typing code is faster
00:21:43 <pzel> dynamic typing only works if you anally-retentively test everything... but I don't see that argument rolled out a lot
00:21:44 <jle`> if WPM is a good metric of productivity
00:21:52 <isomorpheous> pzel: yeah
00:21:57 <triliyn> No instance for (MonadState s (MaybeT (State s))
00:21:59 <isomorpheous> pzel: I cringe at TDD
00:22:01 <triliyn> I'm pretty sure this exists
00:22:16 <jle`> triliyn: hm.  that sounds like it should exist
00:22:19 <jle`> is MaybeT from mtl??
00:22:23 <pzel> isomorpheous: you cringe from the comfort of a static type system :)
00:22:24 <isomorpheous> triliyn: are you sure you don't mean StateT (Maybe s)
00:22:26 <triliyn> Yeah
00:22:35 <jle`> how did that extra question mark get there...
00:22:46 <jle`> isomorpheous: haven't you heard? TDD is dead :)
00:22:54 <isomorpheous> jle`: I hope so
00:22:57 <frerich> Is there a nice function for getting all files in a directory (not recursively) and for getting all subdirectories of a directory (without ./..), and which does not use getDirectoryContents/doesFileExist/doesDirectoryExist?
00:22:58 <frerich> I found System.FilePath.Find which seems quite nice (albeit possibly overkill) but I can't seem to beat it into submission. E.g. for finding subdirectories I tried ' find (depth ==? 0) (fileType ==? D
00:22:58 <frerich> irectory) "/tmp/blah"' but that yields '/tmp/blah' as well.
00:23:09 <triliyn> I'm not sure what order I want them in, but I've been looking at the mtl haddocks and the instance should exist either way
00:23:12 <jle`> it is being echoed by a lot of top peoples in the dynamic programming world
00:23:15 * frerich could always roll his own stuff but refuses to accept that there's no ready-made function for this :)
00:23:18 <jle`> triliyn: yeah, it should exist
00:23:52 <jle`> hm i guess it doens't exist, according to the docs
00:23:58 <isomorpheous> jle`: TDD just seems like trying to bring functional coding practices to the world of shitty scripting languages
00:24:04 <DarkCthulhu> What am I doing wrong in using Random? http://ideone.com/FwOsai
00:24:11 <jle`> oh wait i'm looking at transformers
00:24:33 <triliyn> The docs say there's MonadState s m => MonadState s (MaybeT m)
00:24:51 <Guest21244> what about ppl who ask you TDD in language like Scala
00:24:52 <triliyn> And Monad m => MonadState s (StateT s m)
00:24:58 <triliyn> And I'm pretty sure there's also Monad Identity
00:25:11 <jle`> DarkCthulhu: do you have the random package installed?
00:25:27 <jle`> triliyn: yeah, i see it.
00:25:30 <supki> frerich: shouldn't depth be 1?
00:25:34 <jle`> are you sure you are using the same version of mtl that the docs have?
00:25:38 <DarkCthulhu> jle`: Yes, I do. oops, I guess ideone doesn't. I'll pastebin the error I get.
00:25:49 <supki> frerich: that's what I would expect from a find-like function
00:25:50 <triliyn> Not sure how to verify that
00:26:07 <triliyn> hmmm, if I use StateT s Maybe, it works
00:26:12 <jle`> that's weird
00:26:13 <triliyn> How strange
00:26:18 <jle`> let me see
00:26:34 <DarkCthulhu> jle`: This is the error I get. http://pastebin.com/uks41dL6 .
00:26:51 <triliyn> I'm using mtl-2.2.1 (I just installed it so I still have the cabal output)
00:26:58 <triliyn> And the docs also say 2.2.1
00:27:00 <frerich> supki: Hm. The first argment is the 'recursion predicate', i.e. it controls whether to recurse into a subdirectory. Since I didn't want to recurse in the subdirectories I left it to zero. But maybe you're on the right path: Maybe you can only find directories which you already recursed in, so I need to use 'depth ==? 1' for the recursion predicate and 'depth ==? 1' in the other one (filter predicate? forgot the name)
00:27:03 <frerich> supki: Let me try that...
00:27:07 <jle`> triliyn: are you importing the module that the instanace is defined in?
00:27:14 <jle`> triliyn: Control.Monad.State.Class ?
00:27:37 <triliyn> I imported Control.Monad.State
00:27:38 <triliyn> hmmm
00:27:47 <jle`> remember that MaybeT the type is defined in transformers, which does not have a MonadState typeclass
00:28:02 <jle`> so it has an orphan instnace in Control.Monad.State.Class
00:28:08 <lfairy> DarkCthulhu: are you trying to generate a random string?
00:28:10 <jle`> but it should be re-exprted in Control.Monad.State...right?
00:28:21 <triliyn> I think so
00:28:26 <DarkCthulhu> lfairy: I'm trying to generate a random number between 0 and the upperbound provided by the user.
00:28:28 <frerich> supki: Ha, indeed! Thanks for that comment -- 'find (depth <=? 1) ((depth ==? 2) &&? (fileType ==? Directory)) "/tmp/blah"' yields '/tmp/blah/a' but not '/tmp/blah' :-)
00:28:42 <triliyn> And importing Control.Monad.State.Class doesn't help
00:29:03 <jolyon> DarkCthulhu: you are passing a string to ran not an int
00:29:05 <lfairy> DarkCthulhu: getLine returns a string. What you need is readLn
00:29:12 <trap_exit> dynamic types lets me write code faster
00:29:13 <lfairy> :t readLn :: IO Int
00:29:13 <lambdabot> IO Int
00:29:16 <trap_exit> static types lets me debug code faster
00:29:23 <trap_exit> I do not write perfect code
00:29:25 <trap_exit> static types wins
00:29:28 <jle`> trap_exit: MonadState just exports MonadState(..),
00:29:31 <jle`> hm.
00:29:37 <jle`> does that mean it exports all instances too?
00:29:43 <trap_exit> jle`: wrong nick ?
00:29:45 <jle`> oh i mean, Control.Monad.State just exprots that
00:29:48 <jle`> oh yeah, triliyn
00:29:48 <lfairy> jle`: instances are exported implicitly
00:29:50 <jle`> sorry
00:29:55 <lfairy> you can't control that
00:29:59 <trap_exit> jle`: either that, or your time machine went back a few weeks when you were helping me with this
00:30:08 <jle`> haha oops
00:30:13 <jle`> that might have been it
00:30:29 <jle`> too bad i have Int blindness
00:30:31 <trap_exit> http://www.youtube.com/watch?v=dQw4w9WgXcQ // please don't ban me
00:30:35 <DarkCthulhu> lfairy: Ah, I see. I just changed it to readLn and I get : No instances for (Num [Char], Random [Char])  arising from a use of `ran'
00:30:48 <jle`> trap_exit: :P
00:31:05 <lfairy> DarkCthulhu: that's because you can't concatenate a String and an Int
00:31:15 <lfairy> change the last line to "Whoo!" ++ show random
00:31:19 <triliyn> I'm trying to figure out if I want MaybeT (State s) or StateT s Maybe
00:31:35 <triliyn> I want to lose the state if the computation fails
00:31:36 <lfairy> DarkCthulhu: show converts things to strings
00:32:05 <lfairy> @unmtl MaybeT (State s)
00:32:05 <lambdabot> Plugin `unmtl' failed with: `MaybeT (State s)' is not applied to enough arguments, giving `/\A. (State s) (Maybe A)'
00:32:09 <lfairy> @unmtl MaybeT (State s) a
00:32:09 <lambdabot> (State s) (Maybe a)
00:32:18 <lfairy> @unmtl StateT s Maybe a
00:32:18 <lambdabot> s -> Maybe (a, s)
00:32:25 <lfairy> triliyn: there you go
00:33:18 <triliyn> okay, so I do want StateT s Maybe... which is the one I tried first but also the one that mysteriously doesn't work
00:33:31 <jle`> but !! it seems that State s a isn't even a MonadState instance
00:33:33 <jle`> ...
00:33:46 <triliyn> State s is StateT s Identity
00:33:51 <jle`> yeah
00:33:53 <lfairy> triliyn: are you importing Control.Monad.State, or Control.Monad.Trans.State?
00:34:12 <triliyn> lfairy: the former
00:34:32 <triliyn> Control.Monad.Trans.State doesn't have the MonadState class and importing both gets "ambiguous name" errors
00:34:44 <jle`> yeah, MonadState comes from mtl, not transformers
00:34:55 <lfairy> triliyn: okay, can you give us the error message?
00:35:13 <jle`> here, i can reproduce it in lambdabot
00:35:18 <jle`> :t get :: State s a
00:35:19 <lambdabot>     No instance for (MonadState a1 (StateT s1 Identity))
00:35:19 <lambdabot>       arising from a use of ‘get’
00:35:19 <lambdabot>     In the expression: get :: State s a
00:35:27 <jle`> :t get :: State Int Bool
00:35:28 <lambdabot>     No instance for (MonadState Bool (StateT Int Identity))
00:35:28 <lambdabot>       arising from a use of ‘get’
00:35:28 <lambdabot>     In the expression: get :: State Int Bool
00:35:54 <triliyn> That's not quite right though
00:35:58 <triliyn> :t get :: State Int Int
00:35:59 <lambdabot> State Int Int
00:35:59 <lfairy> :t get :: State s s
00:36:00 <lambdabot> State s s
00:36:01 <jle`> aoh yeah
00:36:03 <jle`> oops
00:36:06 <triliyn> So it works in lambdabot
00:36:06 <lfairy> :P
00:36:09 <jle`> darn
00:36:16 <jle`> my bad
00:36:34 <DarkCthulhu> lfairy: Sorry about this, but I'm still unable to get it working. I get: Couldn't match expected type `IO b0' with actual type `[a0]'  In a stmt of a 'do' block: putStrLn "Whooo!!! " ++ show random. :-|
00:36:40 <jle`> :t get :: MaybeT (State s) s
00:36:41 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
00:36:41 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
00:36:49 <triliyn> http://lpaste.net/108087 my error
00:36:50 <jle`> ...well, the above works for my on my ghci
00:37:07 <lfairy> DarkCthulhu: putStrLn $ "Whooo!!! " ++ show random
00:37:09 <triliyn> (Also trying to play with lens)
00:37:16 <triliyn> (which is where "use" comes from)
00:37:38 <lfairy> triliyn: what's the definition of BFState?
00:37:56 <DarkCthulhu> lfairy: No instance for (Show (IO Int)) arising from a use of `show'
00:38:00 <triliyn> data BFState = B { _tape :: Zipper Int
00:38:00 <triliyn>                  , _programStack :: [[BFCommand]]
00:38:00 <triliyn>                  , _input :: String }
00:38:12 <triliyn> er, I should pastebin all my types, probably
00:38:53 <triliyn> http://lpaste.net/108088
00:39:19 <lfairy> triliyn: actually, paste all your code :)
00:39:53 <triliyn> http://lpaste.net/108089
00:40:59 <triliyn> hmmm, earlier uses of "use" don't trigger this error
00:41:11 <DarkCthulhu> lfairy: There seems to be no easy way to get an Int out of an IO Int. Printing that returned value seems complex.
00:41:20 <lfairy> DarkCthulhu: you need to bind it
00:41:22 <ruuns> DarkCthulu, x <- random before your statement
00:41:24 <lfairy> r <- blahblah
00:41:36 <jle`> x <- (y :: IO Int), you'll get x :: Int
00:41:50 <jle`> to use in your do block
00:42:15 <jle`> (you're not actually extracting an Int out of IO Int, you're just 'naming' the result :) (which is an Int))
00:43:21 <DarkCthulhu> lfairy: Okay, but how does one bind a type of Int to the variable I'm reading it into?
00:43:33 <DarkCthulhu> jle`: ah, let me try that.
00:44:09 <jle`> it's the same way that x <- (getLine :: IO String) allows you to use x as a String for the rest of the do block
00:46:33 <DarkCthulhu> Argh. I need to learn to read these errors :/
00:46:45 <jle`> don't worry, it takes a while to get used to, for eveyone
00:47:00 <jle`> learning haskell is like learning 3 languages, almost
00:47:12 <DarkCthulhu> It now gives me "Ambiguous type variable `t0' in the constraint:   (RandomGen t0) arising from a use of `randomR'"
00:47:35 <DarkCthulhu> Input & errors: http://pastebin.com/Y2kJvKdF
00:47:40 <jle`> DarkCthulhu: it means that you never specify what type of random value you want
00:48:04 <jle`> oh wait
00:48:10 <jle`> no, it's RandomGen
00:48:12 <jle`> let me read the error, sorry :)
00:48:45 <jle`> ...are you using the same name on purpose?
00:48:51 <jle`> for the new gen and the old gen?
00:49:18 <jle`> i recommend you use a dev cycle that allows you to see warnings like this as you go along :)  using ghc-mod and syntastic if you have vim, or some other system
00:49:32 <jle`> this could have also been pointed out if you compiled with -Wall
00:49:34 <DarkCthulhu> jle`: I execute it exactly once, so I thought it wouldn't matter if I overwrite g.
00:49:40 <DarkCthulhu> ah, why is it invalid?
00:49:42 <lfairy> DarkCthulhu: change the g in the binding to g' or something
00:49:44 <jle`> the problem is that it's a recursive binding
00:49:58 <lfairy> DarkCthulhu: if you use the same name on both sides, it loops on itself
00:50:06 <jle`> the g in "randomR (0, x) g" is assumed to be the same g in (a, g)
00:50:24 <jle`> as in...it's saying: "I'm defining a new g, and here is how to get it:  you do randomR (0, x) with itself, g"
00:50:32 <jle`> so it loops forever
00:50:36 <jle`> it's like saying:
00:50:39 <jle`> > let x = x in x
00:50:41 <lfairy> > do let xs = 'a' : xs; putStrLn xs
00:50:43 <lambdabot>  <hint>:1:34:
00:50:43 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
00:50:43 <lambdabot>  mueval-core: Time limit exceeded
00:50:52 <lfairy> :\
00:50:54 <DarkCthulhu> jle`: ohhh, I get it! It works now too. :)
00:50:59 <jle`> yay!
00:51:02 <lfairy> :D
00:51:04 <DarkCthulhu> jle`: lfairy: Thanks a lot.
00:51:05 <jle`> yeah, all lets in haskell are recursive lets
00:51:12 <jle`> this is in contrast to other languages like ocaml
00:51:44 <DarkCthulhu> I thought the type system was supposed to work for me :-/ It's troubling me with weird errors most of the time. I guess I still need to get out of the "traditional" programming mindset.
00:52:08 <jle`> DarkCthulhu: GHC would warn you :)
00:52:11 <jle`> if you do -Wall
00:52:21 <jle`> it'll say something like "g is shadowing" or something
00:52:26 <DarkCthulhu> I'll do that in future. I was just doing runhaskell <something.hs>
00:52:35 <jle`> what IDE do you use?
00:52:38 <jle`> or text editor
00:52:49 <jle`> most should have some plugins where warnings like that show up as you are coding, before you run anything
00:52:49 <Geraldus> Hi friends! I've tried to updgrade my Yesod installation (cabal install yesod-platform --force-reinstalls), but it failed, because of missing library HSskein. I've guessed that installing`skein` package will resolve this issue. However, skein was already installed. When I've tried to reinstall skein, I had another error about HScrypto-api library
00:52:58 <DarkCthulhu> jle`: geany. Is there a better alternative?
00:53:20 <ruuns> vim :-)))
00:53:21 <Geraldus> Is it a sign that something terrible happened with my haskell packages?
00:53:23 <jle`> DarkCthulhu: i'm not familiar with geany, so you might have to ask around if there is any ghc-mod integration
00:53:28 <jle`> or stuff like that
00:53:36 <jle`> i use vim myself, and i haven't had too many problems with it
00:53:41 <zomg> Geraldus: in my experience --force-reinstalls always breaks something :P
00:53:47 <jle`> a lot of people here also use emacs, which makes it also easy
00:53:55 <jle`> ..."also makes it easy"
00:53:56 <DarkCthulhu> I don't use vim unless I'm ssh-ing into something. I'm too used to browser-like keybindings.
00:54:04 <DarkCthulhu> okay, I'll check for a ghc-mod package.
00:54:05 <jle`> well, it's up to you :)
00:54:20 <jle`> look for a haskell package, it might have some warn/highlight stuff there too
00:54:28 <levi> I think SublimeText might have some ghc-mod integration.
00:54:41 <jle`> ah yeah, if you're on a mac, i've heard good things about sublime + haskell
00:54:43 <Geraldus> zomg: yes, but this is preffered way to update Yesod (
00:54:59 <DarkCthulhu> I have another question. When a function returns tuple, I can always do (a,b) = function args?
00:55:09 <lfairy> Geraldus: nuke ~/.ghc and start over
00:55:11 <jle`> DarkCthulhu: yeah, it's called pattern matching :)
00:55:23 <jle`> it's neat
00:55:54 <DarkCthulhu> jle`: I thought pattern matching was in the function definitions. Here, (a,b) are the return values.
00:56:01 <Geraldus> lfairy: Thanks, I thought about it, and actually came here to have a prove, that I should do that.
00:56:07 <jle`> you can pattern match on any declaration
00:56:09 <triliyn> hmmm. I just installed mtl-2.2.1 (according to my cabal output), but ghc is using 2.1.3.1
00:56:22 <DarkCthulhu> jle`: ah..
00:56:23 <jle`> (a, b) = blah is a declaration
00:56:34 <jle`> ...i'm not sure if you can pattern match at the top level, though
00:56:43 <levi> Geraldus: What lfairy said. When there are current packages installed, and you have a complex web of dependencies like Yesod, the solver will sometimes not be able to get you a solution.
00:56:50 <jle`> like you can't write (a, b) = (1, 2) at the top level.  well.  you can do it in a let binding for sure, at least
00:56:55 <jle`> > let (a,b) = (1,2) in a + b
00:56:56 <lambdabot>  3
00:57:11 <jle`> it can be said that function declarations are a subset of declaration syntax
00:57:16 <lfairy> jle`: you can pattern match at the top level
00:57:19 <DarkCthulhu> jle`: that makes sense :) When exactly does one use "let", and "<-" ?
00:57:23 <Geraldus> My experience: purchased SubliText 3, then switched to Emacs, and now I'm happy with VIM :)
00:57:30 <jle`> lfairy: really?  neat
00:57:39 <lfairy> jle`: even partial matches work -- it's weird
00:57:43 <Cale> DarkCthulhu: v <- x inside a do-block means "execute the action x, and call its result v"
00:57:44 <jle`> DarkCthulhu: so if you have an IO Int, and you want to name the Int, you use <-
00:57:52 <jle`> DarkCthulhu: if you have an Int, and you want to name the Int, you use let
00:57:59 <Cale> DarkCthulhu: let v = x rather means "define v to be the same thing as x"
00:58:12 <Cale> So if x is an action, v will be the same action.
00:58:19 <Cale> (not the result of executing that action)
00:58:19 <jle`> in general if you have an a and you want to name the a, you use let; if you have an (m a) and you want to name the a, you'd use <-
00:58:24 <DarkCthulhu> Within a function, is it possible to skip the "let"? If I do "v = x", is that valid?
00:58:40 <Cale> DarkCthulhu: It's not valid inside a do-block
00:58:42 <jle`> DarkCthulhu: you can't have naked declarations in a do block, if that's what you are asking
00:58:50 <Cale> But you can have multiple declarations inside a single let
00:59:06 <DarkCthulhu> Cale: That relies on indentation?
00:59:06 <Cale> if you line them up vertically (or put braces around them and semicolons between them)
00:59:14 <Geraldus> So, is removal of .ghc folder is only one mandatory step?
00:59:34 <jle`> if you want to use indentation, then the "first character of the identifier" after the let is where you have to line things up with
00:59:38 <jle`> let  x = ...
00:59:43 <jle`>      ^-- here
00:59:54 <jle`> as soon as you go to the left of that, you're out of the let
01:00:03 <levi> Geraldus: I think that'll do it.
01:00:33 <Cale> Yeah, 'let', 'do', 'where', and 'of' are the layout keywords, and it's the first non-whitespace character after the keyword which sets the column which lines have to start in for the block to be continued
01:00:44 <levi> Geraldus: But when you try to install your Yesod stuff, make sure you specify *all* the packages you're going to need in the same cabal install command.
01:00:48 <Geraldus> levi: Ok, I'll try now, It is not harmful for me as I use only Yesod, GHCJS and Sodium for now.
01:01:04 <jle`> you can "turn off" layouting by using brackets {}, let {x = 1; y = 2}
01:01:17 <jle`> but i don't think this shows up that much in idiomatic code
01:01:39 <levi> SPJ uses braces & semicolons a lot.
01:01:39 <DarkCthulhu> I don't think I've ever seen it, except in error messages, where everything is bracketed up.
01:01:57 <Cale> Effectively, if subsequent lines start in that column, a semicolon is inserted. If they start in a deeper column, nothing gets inserted, allowing continuation of the previous line. If they start in a shallower column, the block closes.
01:02:10 <jle`> oh, i think i heard about SPJ doing that
01:02:19 <Geraldus> levi: Hmmm. Ok
01:02:21 <jle`> well if spj does it, who am i to argue
01:02:32 <Fuuzetsu> he does
01:02:35 <levi> He also uses Comic Sans for his slides; he's clearly not very concerned about the opinion others have of his stylistic choices. :)
01:02:37 <Cale> It's also useful in ghci or when communicating to lambdabot
01:02:39 <triliyn> hmmm, so I got ghci to use the more recent version of mtl (I know because I'm using an import that didn't exist in the old version)
01:02:43 <triliyn> But now I'm getting:
01:02:49 <Cale> Note that you can have semicolons but no braces
01:02:50 <DarkCthulhu> I think I got it! Thank you jle` and Cale. I understand <- and let more clearly now :)
01:02:54 <triliyn>     No instance for (mtl-2.1.3.1:Control.Monad.State.Class.MonadState
01:02:54 <triliyn>                        BFState (WriterT String (ExceptT BFExc (State BFState))))
01:03:09 <triliyn> Which sounds like it's somehow using BOTH versions
01:03:39 <lfairy> ghc gets confused like that
01:03:46 <jle`> DarkCthulhu: you can think of it as each line in a do block sequencing "m a"'s.  so do { (ma :: m a); (mb :: m b); (mc :: m c) } :: m c, every line you give it a new m a, and it sequences them together
01:03:52 <lfairy> it usually gets it wrong, without cabal to guide it
01:04:04 <jle`> DarkCthulhu: but each m a also has a result of type a, and in this way, you "lose" the result
01:04:07 <jle`> you can't access it later
01:04:21 <jle`> but if you do x <- (ma :: m a), you get access to the result, and it's named `x`
01:04:26 <jle`> x :: a
01:04:29 <jle`> for use later in the do block
01:04:50 <lfairy> triliyn: try ghc -hide-package mtl-2.old.version
01:04:56 <jle`> ...i'm not sure if that answer unnecessarily complicates things
01:05:32 <DarkCthulhu> jle`: "m a" is the equivalent of "IO Int"?
01:05:43 <jle`> in IO Int, m ~ IO, and a ~ Int
01:05:52 <lfairy> triliyn: wait a sec -- did you install mtl after you installed lens?
01:06:07 <lfairy> lens could be using the old mtl
01:06:08 <triliyn> I think I did
01:06:17 <jle`> so an IO Int does "fit" into m a, if m is IO, and a is Int
01:06:19 <triliyn> oh, hmm
01:06:20 <lfairy> there you go
01:06:21 <DarkCthulhu> jle`: What else could m be? Other than IO.
01:06:22 <triliyn> Reinstall lens?
01:06:29 <jle`> DarkCthulhu: any instance of the Monad typeclass
01:06:33 <lfairy> ghc-pkg unregister lens, yeah
01:06:35 <jle`> but that's not too important, for now :)
01:06:55 <jle`> you probably have met other instances in the past, but not been exposed to their Monad methods
01:07:03 <jle`> for now you can just think about IO
01:07:13 <Cale> DarkCthulhu: any other instance of Monad, generally.
01:07:34 <jle`> remember that do notation is just syntactic sugar
01:07:47 <jle`> do { ma; mb }  ---> ma >> mb
01:07:49 <Cale> So, Maybe, [] (the list type constructor), STM, Parser, State s, (->) e
01:08:01 <Cale> and various other things
01:08:03 <DarkCthulhu> jle`: I haven't studied Monads yet. I get the types in general, but not what IO Int actually means, except that when I define that as the return type, the function is impure.
01:08:06 <jle`> do { x <- ma; mb x}  --> ma >>= (\x -> mb x)
01:08:17 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
01:08:18 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
01:08:36 <lfairy> DarkCthulhu: oh -- IO Int is a program, that when executed, yields an Int
01:08:38 <jle`> so all a type needs to do is instance (>>=) meaningfully, and you can use it in a do block
01:08:52 <jle`> DarkCthulhu: IO Int can represent a computer action that when executed produces an Int
01:08:55 <lfairy> DarkCthulhu: since Haskell itself is pure, you can't run IO values directly -- only chain callbacks to them
01:09:02 <triliyn> Reinstalling lens, I get: "Loading package mtl-2.1.3.1 ... linking ... done."
01:09:10 <Cale> > let dict = [(0,2),(1,4),(2,3),(3,4)] in do x <- lookup 0 dict; y <- lookup x dict; return y
01:09:11 <lambdabot>  Just 3
01:09:12 <jle`> DarkCthulhu: Haskell can only 'evaluate' these instructions, not 'execute' them
01:09:20 <jle`> IO Int is just a normal data thingy
01:09:21 <Cale> > let dict = [(0,2),(1,4),(2,3),(3,4)] in do x <- lookup 0 dict; y <- lookup x dict; z <- lookup y dict; return z
01:09:22 <lambdabot>  Just 4
01:09:24 <jle`> like a list, or an Int
01:09:25 <lfairy> jle`: dammit, we're saying the same thing :D
01:09:31 <Cale> > let dict = [(0,2),(1,4),(2,3),(3,4)] in do x <- lookup 0 dict; y <- lookup x dict; z <- lookup y dict; w <- lookup z dict; return w
01:09:32 <lambdabot>  Nothing
01:09:37 <DarkCthulhu> ah.. and it is the thing that helps me realize something similar to imperative programming right?
01:09:47 <jle`> an IO Int is just a normal data thingy that represents the act of a computer producing an int somehow
01:09:50 <jle`> lfairy: sorry ^_^
01:09:55 <Cale> DarkCthulhu: IO is the thing which helps you do something like imperative programming
01:10:03 <Cale> DarkCthulhu: Other monads work differently
01:10:26 <jle`> so what haskell does is it gives you "first class statements"
01:10:34 <jle`> statements being imperative actions, in other languages
01:10:43 <DarkCthulhu> Hmm.. That makes sense. That also explains why most tutorials don't start with the "hello world" program. This is the less interesting part of Haskell ;)
01:10:45 <jle`> in other languages, "print" is something magical.  it does something when you have it
01:10:53 <jle`> when you evaluate a print statement, something happens on the screen
01:10:58 <jle`> in haskell, print is just a normal data object
01:10:58 <ruuns> it's just a logical firewall for the beatiful, pure functional world :P
01:11:03 <jle`> like an Int or a Bool or a list
01:11:15 <jle`> an IO statement is just a normal thing in Haskell, like anything else
01:11:21 <jle`> evaluating it doesn't cause any execution...it's just a normal data type
01:11:24 <Cale> ruuns: IO is, kinda
01:11:26 <kvanb> This is dejavu I swear ...
01:11:52 <jle`> kvanb: oh, i hope i can apologize for last night :/
01:11:54 <DarkCthulhu> jle`: "evaluating it doesn't cause any execution"?
01:12:01 <jle`> i think i was a bit sleepy or something and i sohuldn't have went off
01:12:13 <kvanb> it was only yesterday that we had to tell a beginner to never come into #haskell and ask about IO
01:12:25 <kvanb> because the end result is undoubtedly chaos and confusion.
01:12:28 <jle`> DarkCthulhu: yeah, if you evaluate "print 'hello world'", you're just evaluating a normal data structure, nothing special
01:12:37 <Cale> The big thing which helps Haskell be pure is this distinction between execution and evaluation. It has nothing to do with monads really, apart from the fact that IO happens to be an example of a monad.
01:13:06 <isBEKaml> hi, I had installed ghc7.8.2 some time back and I'm thinking about updating cabal. Before that, I'm about to blow off my .cabal + .ghc folders. Does anyone know of any resources that tell me how to go about installing cabal standalone?
01:13:07 <jle`> DarkCthulhu: print "hello world" represents an IO action.  GHC has the ability to look at an IO action and compile it to somethign a computer can execute
01:13:13 <Cale> Evaluation means reducing expressions to values, ultimately for the purposes of pattern matching
01:13:20 <triliyn> After uninstalling mtl-2.1.3.1 and attempting to reinstall lens again, lens wanted to redownload that old version
01:13:26 <isBEKaml> I'm on win7 and I'm okay going through steps to download dependencies if needed.
01:13:30 <Cale> Evaluation has no user-visible effects apart from perhaps making your CPU a bit hot
01:13:42 <triliyn> Even though hackage claims the upper bound is 2.3
01:13:42 <Cale> Execution means carrying out the effects described by IO action values
01:13:44 <kvanb> isBEKaml: uh, my advice is, don't.
01:13:51 <DarkCthulhu> Ah.. I see the distinction.
01:13:55 <jle`> DarkCthulhu: when you name an IO action 'main', ghc knows to compile it to something.  and then you compile it, and then your computer/cpu can run the compiled IO action
01:14:04 <lfairy> triliyn: cabal favors installed packages unless told otherwise
01:14:05 <Cale> Execution can cause your computer to do anything that your computer is capable of doing
01:14:07 <kvanb> blow everything except ~/.cabal/bin away
01:14:14 <kvanb> then cabal install cabal-install
01:14:16 <kvanb> and you're done
01:14:23 <jle`> kvanb: sorry again :/
01:14:27 <isBEKaml> kvanb: why? most of the old packages don't work for me.
01:14:28 <jle`> i've felt bad about it most of today v.v
01:14:37 <kvanb> building cabal from source requires a bootstrap
01:14:39 <kvanb> it's not trivial
01:14:42 <jle`> i went to sleep with much regret in my heart
01:14:50 <kvanb> jle`: soke
01:14:54 <Cale> kvanb: hm?
01:15:00 <Cale> oh, on Windows
01:15:02 <ruuns> can i represent <- operator in this context as an execution?
01:15:07 <kvanb> haha, "oh Windows"
01:15:14 <kvanb> yeah. That. "platform". it exists.
01:15:17 <jle`> ruuns: hm. not really
01:15:17 <isBEKaml> Cale: yeah :/
01:15:18 <triliyn> lfairy: this was after I ghc-pkg unregistered the old version of mtl, and while I had the new version installed
01:15:33 <isBEKaml> I don't want to wait for Platform and I'm going ahead with whatever's available.
01:15:35 <Cale> ruuns: Yeah, "v <- x" means "execute the action x, and call its result v"
01:15:37 <triliyn> (I think I've actually unregistered the old version twice at this point)
01:15:43 <kvanb> isBEKaml: platform is right around the corner
01:15:45 <kvanb> according to the list
01:15:54 <kvanb> might even be a download link somewhere in the list iirc
01:15:57 <jle`> ruuns: nvm i guess you can :)
01:16:03 <ruuns> np :)
01:16:03 <isBEKaml> kvanb: Yeah, I saw the mail. It's on RC
01:16:44 <isBEKaml> kvanb: I read "right around the corner" as months. :)
01:17:17 <Cale> ruuns: and you can think of do-notation as gluing together IO actions in such a way as to produce an action which will execute various sub-actions and determine what to do next using the results of each.
01:17:19 <jle`> ruuns: one way to think about it is that main :: IO (), so it's one IO thing.  so but if you have two IO ()'s, and you want to pass them to main...what can you do?  well, you can use (>>) :: IO a -> IO b -> IO b.  you can "merge together" two IO a's., and the new IO action represents the sequential execution of both.  so do { ma; mb; mc } is syntactical sugar of (ma >> mb) >> mc :: IO a, one IO.
01:17:23 <int3__> can I tell cabal to reinstall all packages that would be broken by a dependency change?
01:17:30 <Cale> (when it is itself executed)
01:17:46 <jle`> ruuns: the new IO thing represents the three smaler IO things executed sequentially
01:18:09 <Cale> jle`: "pass them to main" sounds weird, as main isn't a function and doesn't have parameters, but probably that made sense anyway :)
01:18:11 <jle`> ruuns: now, in this case, the "result" of every IO a is 'thrown away', except for the last one.  but if you use <-, you name it and save it, and are able to reference it for later
01:18:18 <jle`> hm
01:18:23 <jle`> maybe i should say "name it main"
01:18:25 <jle`> :)
01:19:18 <jle`> the result of the do block is still a new IO (), that represents doing all of the IO a's in order, sequentially
01:19:32 <jle`> except now you can use the reuslt of one line in the rest of the do block
01:19:38 <DarkCthulhu> It's important for me to start with actually building something and get some visual feedback from a general purpose programming language, and that is impossible with just the "pure" components. LYAH started off too slow in this respect and with nothing to do, I just gave up on it. Can you guys suggest books which might let me use haskell to build something real, rather than just learn FP?
01:19:47 <ruuns> if you mean name and save it for reference, i guess you are only corresponding to the given do-block isn't it ?
01:19:57 <jle`> ruuns: yeah, it lets you refer to it in the rest of the do block
01:20:13 <jle`> so if i do x <- getLine; i can refer to the String produced by getLine in the rest of the do block
01:20:35 <jle`> if i do { getLine; ...; ...}, then the String produced by getLine is lost forever
01:20:37 <kvanb> int3__: rm -rf
01:20:39 <kvanb> cabal install worl
01:20:43 * jle` cues sad music
01:20:44 <kvanb> *cabal install world
01:20:45 <kvanb> :(
01:21:13 <Cale> DarkCthulhu: You might try Real World Haskell
01:21:15 <zwer> DarkCthulhu real-world haskell, but unfortunately the code is a bit outdated
01:21:17 <ruuns> keke :)
01:21:35 <kvanb> DarkCthulhu: that's hard with haskell
01:21:42 <jle`> DarkCthulhu: oh, i have a very visual introduction to haskell book somewhere
01:21:44 <jle`> let me find it
01:21:56 <jle`> and it's aged well too, i think
01:21:57 <kvanb> naturally it's nothing like you would have ever used before
01:22:03 <zomg> I found the haskell tutorials a bit limited in terms of practicality
01:22:08 <int3__> kvanb: so this is the hell they speak of
01:22:13 <zomg> RWH included, unless the things RWH talks about are the things you wanna do
01:22:16 <kvanb> int3__: edwardk fixed it
01:22:18 <kvanb> in cabal recently
01:22:24 <Cale> It's hard (though not impossible) to *start* with I/O heavy stuff in Haskell before you really have a good sense of evaluation and the type system under your belt.
01:22:24 <zomg> of course this was a while ago, so maybe there's something new and better now
01:22:33 <zwer> I just went through LYAH and then read documentation on the libraries I was interested in. worked fine
01:22:38 <jle`> DarkCthulhu: Haskell School of Expression
01:22:50 <jle`> http://www.amazon.com/gp/product/0521644089
01:22:53 <kvanb> int3__: basically, now you can install multiple packages with different version dependencies
01:22:57 <kvanb> or the same versions with different depends
01:23:00 <jle`> it's a book that introduces Haskell from a visual/media perspective from the get-go
01:23:02 <kvanb> it's not out of cabal HEAD yet though
01:23:10 <zomg> Cale: I'm personally still of the opinion that for example web development is relatively straightforward to start with just a basic understanding :)
01:23:12 <lfairy> kvanb: that reminds me -- I only found out about world a few days ago, while adding a feature to cabal-install
01:23:29 <snyp> What do you all think of Beginning Haskell?
01:23:33 <kvanb> after edwards changes
01:23:37 <jle`> i've worked through it and i think it's rther nice; i also took a Haskell course that used it as teaching material
01:23:41 <kvanb> cabal install world should be renamed to "bloat my disk please"
01:23:42 <Cale> But yeah, if you just want to dive in, look through at least what the Prelude provides in terms of IO stuff, and just start writing some basic code (maybe just using stuff like getLine and putStrLn), and you'll probably start to get it pretty quickly.
01:23:47 <kvanb> or maybe even "I wish my ssd to die"
01:23:57 <DarkCthulhu> jle`: Awesome. I'll order that. I also found the online version of RWH. It does seem to be more practical-focussed.
01:24:28 <Cale> zomg: That's funny, I consider some of the web development libraries some of the least straightforward stuff to deal with among all the code available for Haskell right now.
01:24:52 <int3__> kvanb: but it's not been released yet?
01:24:54 <jle`> DarkCthulhu: np :)  make sure to corraborate with the comments online if you work through RWH, as it is generally considered a bit dated, if you aren't prepared for it
01:24:55 <Cale> But it's good if you think that's straightforward :)
01:25:02 <int3__> oh
01:25:07 <int3__> you said that, sorry i missed it
01:25:08 <kvanb> int3__: reddit has article about it and stuff
01:25:10 <isBEKaml> Cale: what do you think about Yesod?
01:25:14 <kvanb> if you want to read about it
01:25:21 <isBEKaml> I found that working with it is fine, but updating it is hellish.
01:25:36 <int3__> kvanb: I'll look it up later if I have time haha
01:25:44 <jle`> DarkCthulhu: you might also just like trying to work out your own projects from your previous languages, and seeing how they translate to haskell
01:25:58 <zomg> Cale: haha =) Yeah some of the libs are tricky, and it's not like I've tried to teach it to anyone, but at least Scotty feels reasonably straightforward to deal with
01:26:03 <jle`> DarkCthulhu: and reading papers or blog posts to fill in your blanks...assuming you've already worked through enough of LYAH or something to be able to learn more
01:26:04 <Cale> isBEKaml: Well, yeah, Yesod in particular is perhaps the hardest to really understand what you're doing with, because of all the template haskell, on top of all the conduit stuff.
01:26:33 <ruuns> DarkCthulhu: if you are used to IO, things get much easier :] don't give up. It feels in the beginning very strange (that was my problem too)
01:26:46 <jle`> everything feels very strange!
01:26:48 <jle`> ahh!
01:26:52 <jle`> i freak out all the time still
01:26:55 * jle` calms himself down
01:27:00 <DarkCthulhu> haha.. :D
01:27:01 <zomg> Cale: also just plain wai apis are reasonably simple I think
01:27:10 <jle`> slowly, less and less things feel strange :)
01:27:12 <jle`> trust me
01:27:28 <jle`> one thing i like to say is...remember how long it took for you to learn your first programming language
01:27:34 <Cale> It took me about 2 months to feel like I could do useful things, and about a year to feel comfortable, back when I learned Haskell around 2001-2002
01:27:43 <jle`> and try to set up your expectations on your haskell progress based on that
01:27:45 <isBEKaml> damn, I really need to blow out everything before I get to install cabal...
01:27:50 <snyp> For me Beginning Haskell proved to be a bit too fast paced as opposed to Real World Haskell, but the book is really good judging from the contents. So I am going through RWH atm, and will continue with BH later.
01:28:01 <isBEKaml> this cabal is tightly bound to old Haskell Platform (ghc-7.4.1)
01:28:09 <jle`> Beginning Haskell is that 'project based approach' one, right?
01:28:13 <snyp> Yes
01:28:40 <zwer> Cale did IO type exist back then?
01:28:45 <jle`> i remember it coming out but i don't remember a huge splash about it.  but i haven't heard anything awful about it either.  it's nice that it's good :)
01:29:39 <frerich> Cale: You started with Haskell ~2001? Did that time overlap with Julian Seward working on GHC by any chance?
01:30:52 <jle`> i wonder why DeepSeq is in Control
01:31:00 <int3__> guh. ghc-mod HEAD uses features from the latest mtl, which uses a version of transformers that is newer than the one ghc-7.8.3 uses... I suppose this means they must be building against ghc HEAD? I'm in a sandbox, but cabal still refuses to install a conflicting version of transformers, probably because the ghc library lives outside the sandbox and can't be installed via cabal itself
01:31:07 <jle`> ...knowing well that the distinctions are kind of ad-hoc and arbitrary
01:31:19 <jle`> but i guess lazyness is used for control flow in haskell
01:31:24 <jle`> maybe that's why
01:31:34 <jle`> laziness ?
01:31:38 <jle`> english is weird
01:32:30 <lfairy> int3__: install an older ghc-mod :P
01:32:54 <int3__> lfairy: I was trying to be helpful by writing a patch for ghc-mod... lol
01:33:37 <triliyn> Using a cabal sandbox now. It looks like it's finally building lens against the right version of mtl
01:34:40 <triliyn> It would be nice if I could get ghci to use the sandbox though
01:35:10 <mkrtem> cabal repl?
01:35:50 <triliyn> ah, yeah, I just googled and found that
01:35:55 <triliyn> It seems to work!
01:41:36 <isBEKaml|2> why is this broken? http://www.haskell.org/cabal/release/cabal-install-latest/cabal.exe
01:41:47 <isBEKaml|2> I found this in cabal readme.
01:42:08 <isBEKaml|2> here: https://github.com/haskell/cabal/blob/master/cabal-install/README.md
01:42:24 <isBEKaml|2> More specifically here: https://github.com/haskell/cabal/blob/master/cabal-install/README.md#quick-start-on-windows-systems
01:43:14 <MP2E> dunno, the folder still has stuff in it
01:43:15 <MP2E> http://www.haskell.org/cabal/release/cabal-install-latest/
01:43:20 <MP2E> I don't see cabal.exe though
01:44:29 <isBEKaml> MP2E: yeah, I see that folder
01:44:43 <aloiscochard> Cale: wow, 13 years of haskell... you must be dreaming in Core now ;-)
01:45:03 <DarkCthulhu> How do I search for a function to convert Ints to Floats? http://www.haskell.org/hoogle/?hoogle=Int+-%3E+Float doesn't have much. Is the type name actually "Float or "Floating"?
01:45:20 <jle`> :t fromIntegral
01:45:21 <lambdabot> (Num b, Integral a) => a -> b
01:45:35 <jle`> admittedly it's not very easy to search for
01:46:08 <DarkCthulhu> :t log
01:46:09 <lambdabot> Floating a => a -> a
01:46:22 <DarkCthulhu> Why does it say "Floating" jle` ? Is that the type name?
01:46:26 <isBEKaml> jle`: fromInt something?
01:46:44 <isBEKaml> DarkCthulhu: that's a typeclass -
01:46:53 <saep> :i Floating
01:47:18 <isBEKaml> DarkCthulhu: It simply tells the compiler that whatever the type is in `a`, it should conform to this typeclass.
01:47:29 <DarkCthulhu> Ah. I see!
01:47:52 <jle`> DarkCthulhu: it's a typeclass, like Num
01:47:54 <jle`> :t (+)
01:47:55 <frerich> Is there some sort of guide on the typical filesystem structure of a Cabal-based project? I saw that many projects store e.g. the 'main' action in 'src/Main.hs' but I wonder about the rest. Where do project-specific modules go, what about test executables etc..
01:47:55 <lambdabot> Num a => a -> a -> a
01:48:14 <jle`> (+) is an a -> a -> a, where a is an instance of the Num typeclass
01:48:35 <jle`> it also tells you that (+) is defined on *any* Num you might ever want to use for it
01:52:55 <saep> frerich: I like the guide described here:  http://taylor.fausak.me/2014/03/04/haskeleton-a-haskell-project-skeleton/
01:54:43 <saep> But I don't think there is a real standard, at least I haven't found one.
01:54:43 <surfer77> #channelStarter_supporters
01:54:44 <surfer77> You want to start a new Channel with more than 3 people?! no problem we're getting on it for free, so that you got it made!
01:55:58 <DarkCthulhu> jle`: let chances = truncate . log . fromIntegral$ uBound. This works, but now how do I subtract 1 from the end result? The $ is equivalent to putting parens on either side right?
01:56:24 <jle`> yeah, like the spine of a beautiful butterfly :)
01:56:29 <jle`> (truncate . log . fromIntegral) (uBound)
01:56:33 <jle`> it spreads its wings
01:56:38 <DarkCthulhu> :D
01:56:42 <DarkCthulhu> what I want to do is truncate the logarithm and then subtract 1.
01:56:50 <jle`> okay then, so you need
01:57:08 <jle`> well, first, let's split things off and name them for easies
01:57:17 <jle`> let trlfi = truncate . log . fromIntegral
01:57:17 <frerich> saep: Interesting page! I think I'll apply a couple of tips given in there to my own project
01:57:19 <ruuns> saep: this skeleton is awesome :]
01:57:32 <jle`> so you want f . trlfi $ uBound
01:57:35 <jle`> what is f ...?
01:57:54 <jle`> f . truncate . log . fromIntegral $ uBound, if you want to see the whole chain
01:57:55 <isBEKaml> jle`: Nice - I like this way of questioning. :)
01:58:15 <jle`> you want to "subtract 1"
01:58:17 <jle`> :)
01:58:22 <DarkCthulhu> jle`: I want to apply  trlfi on uBound and subtract 1 from it.
01:58:33 <jle`> yeah, so f should be a function that subtracts 1
01:58:43 <jle`> i wonder if there is a function that lets you `subtract 1`....
01:58:53 <DarkCthulhu> jle`: :D okay, I get the reasoning.
01:59:14 <jle`> f . trlfi $ uBound = (f . trlfi) uBound) = f (trlfi uBound)
01:59:24 <jle`> that's from expanding out the definition of ($) and (.)
01:59:27 <jle`> @src ($)
01:59:27 <lambdabot> f $ x = f x
01:59:29 <jle`> @src (.)
01:59:29 <lambdabot> (f . g) x = f (g x)
01:59:29 <lambdabot> NB: In lambdabot,  (.) = fmap
02:00:26 <DarkCthulhu> jle`: Okay.. Composition I do understand. I was thinking of it differently, not as applying the decrement function to the overall result.
02:00:50 <trap_exit> when "func" is a complciated function, instead of doing [ func x | x <- lst], is tehre a way to do "for x in lst:\n func x"  (I'd like to define func in place, rather than use let/where)
02:00:53 <jle`> ah :)
02:01:36 <jle`> DarkCthulhu: one way you can see it is that your result is (trlfi uBound), and if you want to subtract 1, you can do f (trlfi uBound)...and you can use the backwards definition of (.), to turn f (trlfi uBound) = (f . trlfi) uBound
02:01:39 <frerich> trap_exit: You could do '(flip map) lst $ \x -> ...'
02:01:40 <isBEKaml> trap_exit: Aren't they the same?
02:01:51 <jle`> where f is a function that lets you `subtract 1`
02:01:57 <trap_exit> when func is multi line [ ... \n ... \n ... \n .. \n | x <- lst ]
02:02:08 <trap_exit> does not look as good as "for x in lst: .... \n .... \n .... \n ... \n "
02:02:24 <trap_exit> frerich : that is clever
02:02:37 <DarkCthulhu> jle`: Understood. So, I should use the (-) function and 1 as the second argument as the outermose.
02:02:40 <DarkCthulhu> *outermost
02:03:03 <jle`> DarkCthulhu: taht's a good approach, but unfortunatelly haskell is really annoying with (-)
02:03:03 <isBEKaml> trap_exit: I missed the part about defining func itself. Yeah, use what frerich mentioned.
02:03:35 <solidus-river> do list comprehensions evaluate the whole result before continuing or are they lazy?
02:03:36 <jle`> normally that *should* work, but haskell is annoying in this specific instance
02:03:37 <trap_exit> isBEKaml: understood
02:03:44 <DarkCthulhu> a - b is (-) applied to a and b as arguments right? Is it a bad idea to use this notation alongside $ and grouping?
02:03:47 <DarkCthulhu> jle`: Ah
02:03:52 <trap_exit> solidus-river: except seq, everything is lazy
02:03:56 <jle`> yeah, a - b = (-) a b
02:04:05 <jle`> also, a + b = (+) a b
02:04:14 <jle`> normally, if you want to pass in the "second" argument, you can use sectioning syntax
02:04:23 <jle`> (+ 3) === \x -> (x + 3)
02:04:34 <jle`> (+ 3) means it's a function "waiting" for the left hand side
02:04:35 <solidus-river> thanks :)
02:04:49 <jle`> > let f = (/ 4) in f 20
02:04:50 <lambdabot>  5.0
02:05:07 <DarkCthulhu> jle`: I see. This is the "currying" advantage isn't it?
02:05:13 <DarkCthulhu> So the shorthand is just (- 1) in this case.
02:05:50 <jle`> in this case it might be more relevantly attributable to operator section syntax in haskell, which could be called syntactic sugar.  currying does play a role, yes
02:06:09 <trap_exit> oh shit
02:06:10 <jle`> yeah, you would do (- 1), but...haskell is annoying here
02:06:17 <trap_exit> I can do "for = flip map"
02:06:26 <trap_exit> then I can do "for lst $ \x -> ... "
02:06:27 <trap_exit> teehee
02:06:27 <chrisdone> (-1) is a special case, it means simply -1
02:06:36 <trap_exit> this is so evil
02:06:38 <DarkCthulhu> jle`: What is the sectioning syntax. I haven't seen it before.
02:06:47 <jle`> it's what i did with (+ 3) and (/ 4)
02:06:59 <frerich> trap_exit: It's not as evil as you might think. There are existing functions 'forM = flip mapM' and 'forM_ = flip mapM_' for the exact same reason.
02:07:05 <jle`> you get to say "(/ 4) is a function 'waiting' for a number on the left hand side of the /"
02:07:09 <trap_exit> + , / : Int -> Int -> Int
02:07:22 <DarkCthulhu> jle`: Ohh, the partial application with a single argument that we later supply. Right?
02:07:27 <trap_exit> jle`: it's not on the rhs ?
02:07:34 <trap_exit> , (/ 4) 2
02:07:38 <jle`> trap_exit: it's the "missing" side
02:07:38 <trap_exit> > (/ 4) 2
02:07:40 <lambdabot>  0.5
02:07:51 <jle`> so (/ 4) 2 puts the 2 in the missing spot
02:07:56 <trap_exit> wtf, I thought it would be the first as in partial application
02:07:59 <jle`> (/ 4) 2    --> 2 / 4
02:08:00 <trap_exit> > / 4 2
02:08:02 <lambdabot>  <hint>:1:1: parse error on input ‘/’
02:08:06 <jle`> yeah, this is section syntax
02:08:16 <trap_exit> > (/) 4 2
02:08:17 <lambdabot>  2.0
02:08:25 <trap_exit> > ( (/) 4) 2
02:08:26 <lambdabot>  2.0
02:08:29 <jle`> ((/) 4) is just normal function application
02:08:30 <trap_exit> > (/ 4) 2
02:08:32 <lambdabot>  0.5
02:08:37 <trap_exit> okay, I get it now
02:08:41 * trap_exit pats lambdabot
02:08:45 <DarkCthulhu> It's applying the second argument and waiting for the first. :-o
02:08:58 <jle`> you can do the wait-for-the-second using sectioning syntax too, but it's not as common
02:09:01 <trap_exit> I will ask this question
02:09:01 <jle`> > (4 /) 2
02:09:02 <lambdabot>  2.0
02:09:04 <trap_exit> to anyone climiang ot know haskell
02:09:30 <DarkCthulhu> Ohh.. is this a special case because it takes 2 arguments in total?
02:09:30 <jle`> DarkCthulhu: if you tried doing (- 1), you might have noticed that it is parsed as (-1), negative one
02:09:38 <trap_exit> "expalin to me why( (/) 4 2) and (/ 4) 2 both return "2.0" --- and if they give me an explaination, they don't know haskell"
02:09:40 <randen> isBEKaml: http://www.haskell.org/cabal/download.html
02:09:50 <jle`> DarkCthulhu: well, you can do it for functions that take three arguments, too
02:09:54 <isBEKaml> randen: yeah, I got that much later. Thanks
02:10:24 <jle`> > let three x y z = x + y * z in (`three` 2) 4 6
02:10:25 <lambdabot>  16
02:10:33 <randen> isBEKaml: We just fixed the link on that page about an hour or so ago; just in time for you
02:10:59 <jle`> (`three` 2) = \x z -> (x `three` 2) z == three x 2 z
02:11:22 <jle`> trap_exit: (/ 4) 2 doesn't return 2.0
02:11:31 <trap_exit> jle`: exactly
02:11:37 <jle`> oh i see
02:11:43 <trap_exit> that's why any one who gives me an explaination is lying on their resumee
02:11:43 <merijn> jle`: He means that he wants to use that as "test" to see how well people know haskell :)
02:11:45 <jle`> 'you will' as in, you will in the future
02:11:53 <trap_exit> jle`: you pass the test
02:11:58 <trap_exit> jle`: want a job?
02:12:01 <DarkCthulhu> jle`: I meant, it is only when you take 2 args that you can put the function in between right? Like 2 / 4 being equivalent to (/) 2 4
02:12:01 <chrisdone> darkcthulhu: operator sections are purely a syntactic trick, the translation is:
02:12:02 <chrisdone> darkcthulhu: so (* 2) 5
02:12:02 <chrisdone> darkcthulhu: -> (\x -> x * 2) 5
02:12:02 <chrisdone> darkcthulhu: -> (5 * 2)
02:12:05 <chrisdone> darkcthulhu: -> 10
02:12:09 <trap_exit> jle`: I can pay in chicken ramen and beef ramen
02:12:25 <jle`> @check \x y -> (/) x y == (/ x) y
02:12:25 <DarkCthulhu> > (4 /) 2
02:12:26 <lambdabot>  *** Failed! Falsifiable (after 1 test):
02:12:27 <lambdabot>  0.0 0.0
02:12:27 <lambdabot>  2.0
02:12:48 <jle`> @check \x y -> (x * y /= 0) ==> (/) x y == (/ x) y
02:12:49 <lambdabot>  *** Failed! Falsifiable (after 1 test and 1085 shrinks):
02:12:50 <lambdabot>  5.0e-324 0.5000008309822124
02:12:53 <isBEKaml> randen: The page still shows the old url  - I don't know what you refer to as a link fix?
02:12:55 <merijn> DarkCthulhu: Haskell is perfectly okay with you defining operators that take more than two operators, they're just rather awkward to use
02:12:56 <chrisdone> darkcthulhu: but operators themselves are also purely syntactic
02:12:57 <chrisdone> darkcthulhu: so 5 * 2
02:12:57 <chrisdone> darkcthulhu: -> (*) 5 2
02:12:57 <chrisdone> darkcthulhu: -> 10
02:13:11 <isBEKaml> randen: this is what I'm looking at: https://github.com/haskell/cabal/blob/master/cabal-install/README.md
02:13:12 <DarkCthulhu> Hmm.. got it. I misunderstood one of the statements above. Clear now :)
02:13:22 <jle`> a common example of an operator defined as taking three arguments is (.)
02:13:27 <jle`> @src (.)
02:13:27 <lambdabot> (f . g) x = f (g x)
02:13:27 <lambdabot> NB: In lambdabot,  (.) = fmap
02:13:32 <merijn> chrisdone: "(*2) is not translated to "\x -> x *2"
02:13:37 <frerich> trap_exit: A more interesting brain teaser might be to explain the type (and behaviour) of (`id` 1)
02:13:41 <merijn> chrisdone: The latter has different strictness properties
02:13:53 <trap_exit> > :t id
02:13:54 <lambdabot>  <hint>:1:1: parse error on input ‘:’
02:14:01 <trap_exit> frerich: i fail
02:14:05 <chrisdone> merijn: please proceed to explain this to the haskell newbie, i'll be back tomorrow when you're done
02:14:05 <jle`> id x = x
02:14:08 <trap_exit> frerich: enlignten me ... isn't it just Int ?
02:14:27 <isBEKaml> trap_exit: "just" ? :)
02:14:34 <jle`> trap_exit: id 1 is Num a => a, but what is (`id` 1) ?
02:14:44 <frerich> trap_exit: You started the whole 'test' story, now think about it. ;-)
02:14:47 <jle`> you just told us that f x /= (`f` x), after all :)
02:14:57 <lfairy> merijn: how is it different?
02:14:59 <trap_exit> id is a unary function
02:15:01 <DarkCthulhu> jle`: Okay. One more question. In function (/) for example, can I bind only the second argument and wait for the first? If yes - how?
02:15:05 <merijn> chrisdone: :)
02:15:11 <jle`> DarkCthulhu: yeah, (/ 4)
02:15:11 <trap_exit> how the fuck do we do `` to an unary function ?
02:15:28 <DarkCthulhu> > (/ 4) 2
02:15:29 <lambdabot>  0.5
02:15:38 <merijn> lfairy: Lemme look up an example
02:15:39 <pjdelport> merijn: To be fair, the Haskell Report does require the identity "(op e) = \ x -> x op e" to hold
02:15:45 <chrisdone> trap_exit: language, s'il vous plaît
02:15:47 * Xack is trying to install network-fancy
02:15:47 <jle`> trap_exit: id :: a -> a, but a can be anything
02:15:49 <Xack> Network/Fancy.hsc:290:32: Not in scope: ‘unsafeForeignPtrToPtr’
02:15:55 <Xack> The Glorious Glasgow Haskell Compilation System, version 7.8.2
02:16:03 <jle`> trap_exit: a can be an Int...or it can be an (Int -> Int)...or it can be a (Bool -> Int -> Double)...
02:16:24 <Xack> anybody else have this issue?
02:16:34 <Xack> (when using cabal install network-fancy)
02:16:37 <jle`> :t id `asAppliedTo` (1 :: Int)
02:16:38 <lambdabot> Int -> Int
02:16:41 <trap_exit> ah, id can be (a -> b) -> a -> b
02:16:48 <lfairy> Xack: I prefer network-simple, if that helps
02:16:53 <jle`> :t id `asAppliedTo` (*3)
02:16:53 <lambdabot> Num a => (a -> a) -> a -> a
02:16:54 <trap_exit> `id` ` has type (Int -> b) -> b ?
02:17:02 <trap_exit> :t `id` 1
02:17:03 <lambdabot> parse error on input ‘`’
02:17:03 <jle`> trap_exit: that doesn't unify
02:17:11 <jle`> id :: a -> b
02:17:18 <jle`> oops
02:17:20 <jle`> id :: a -> a
02:17:26 <jle`> if it was (Int -> b) -> b...what is `a` ?
02:17:28 <chrisdone> merijn: probably something involving the operator containing _|_ before it accepts it second argument which the lambda would not have
02:18:05 <jle`> DarkCthulhu: anyways, back to your original question, you might see that yuo can't do sections with (-), because (-) is the single exception, because (- 1) is parsed as (-1), or negative one
02:18:07 <Cale> zwer: Yes, it did. Haskell 98 came out a few years before I began after all.
02:18:20 <jle`> so we have a function that we use to cicumvent this
02:18:28 <trap_exit> I don't get this
02:18:29 <jle`> > subtract 1 10
02:18:30 <Cale> frerich: I'm not entirely certain who was working on GHC at the time
02:18:30 <lambdabot>  9
02:18:30 <trap_exit> someone enlighten me
02:18:37 <trap_exit> `id` 1 ... how does this work
02:18:40 <trap_exit> I feel stupid
02:18:47 <trap_exit> do not let me go to sleep feeling stupid
02:18:53 <jle`> trap_exit: don't feel stupid :)
02:18:56 <jle`> it's not an easy question!
02:19:06 <merijn> lfairy: Ugh, I can't quickly find an example of the details and I should be working, sorry! It's a really minor and ignorable difference anyway
02:19:09 <trap_exit> jle`: the solution is not self-esteem, but ability
02:19:15 <DarkCthulhu> jle`: Yes, I saw that when I tried. Trying subtract now.
02:19:16 <trap_exit> :t (`id` 1)
02:19:16 <Cale> (`id` 1) = (\x -> id x 1) = (\x -> x 1)
02:19:16 <randen> isBEKaml: Thanks. I'll fix and send them a pull request
02:19:17 <lambdabot> Num a => (a -> t) -> t
02:19:37 <trap_exit> Cale: ah, that makes sense now
02:19:41 <jle`> you might see something if we do some magic alpha substitution
02:19:42 <DarkCthulhu> jle`: Works as expected :) ty
02:20:01 <jle`> (`id` 1) => (\f -> id f 1) => (\f -> f 1)
02:20:15 <Cale> jle`: :)
02:20:16 <trap_exit> jle`, Cale: great, I can sleep happy now
02:20:23 <jle`> look familiar?
02:20:27 <jle`> @src ($)
02:20:28 <lambdabot> f $ x = f x
02:20:36 <jle`> :t ($ 1)
02:20:37 <lambdabot> Num a => (a -> b) -> b
02:20:38 <lfairy> merijn: no worries :) I did some experiments, but could only differentiate left sections
02:20:42 <jle`> :t (`id` 1)
02:20:42 <Cale> (it should look familiar, it's almost identical to what I wrote a couple lines up)
02:20:43 <lambdabot> Num a => (a -> t) -> t
02:21:13 <jle`> Cale: :P
02:21:34 <jle`> DarkCthulhu: i was trying to drop clever hints by saying "subtract 1" all over the place
02:21:47 <jle`> it's ...definitely really cool.
02:21:48 <frerich> trap_exit: Rest assured, it really tripped me up when I learned that the 'a' in 'id :: a -> a' can actually be a function as well -- in particular, if GHC decides to infer this. Makes for really unexpected error messages.
02:21:49 <jle`> im so cool
02:21:58 * jle` is the coolest
02:22:14 <jle`> yea
02:22:21 <chrisdone> @quote cool
02:22:21 <lambdabot> islands says: how will people know I'm cool if I'm not wearing my sunglasses?
02:22:31 <trap_exit> frerich: you can be VP of recruiting
02:22:33 <mgoszcz2> Hi. (rwbarton?) I've got my yesterday's problem to compile.. sort off: http://lpaste.net/108091. It seems to work only sometimes, always on my machine, but fp complete doesn't like it
02:22:36 <chrisdone> •_•)
02:22:37 <chrisdone> ( •_•)>⌐■-■
02:22:37 <chrisdone> (⌐■_■)
02:22:44 <frerich> trap_exit: Everytime somebody seems really smart, it's only because their "Wha....?!" moment is in the past instead of the present. ;-)
02:22:55 <jle`> chrisdone: for a second there i thought that  •_•) was a lambdabot command
02:23:03 <jle`> and lambdabot completed it for you
02:23:10 <chrisdone> =)
02:23:15 <hyPiRion> jle`: oh, that would be amazing
02:23:19 * hackagebot simple-pipe 0.0.0.6 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.6 (YoshikuniJujo)
02:24:24 <pjdelport> It becomes easier to see that application is a special case of id if you write f `id` x as id f x
02:24:25 <jle`> @let (•.•) = text "( •_•)>⌐■-■\n(⌐■_■)"
02:24:27 <lambdabot>  Defined.
02:24:39 <jle`> > (•.•)
02:24:41 <lambdabot>  ( •_•)>⌐■-
02:24:41 <lambdabot>  (⌐■_■)
02:24:43 <ruuns> lol
02:24:58 <osfameron> see how unicode makes things clearer
02:25:00 <pjdelport> because the (id f) in (id f) x must of course just be f
02:25:07 <chrisdone> lol, encoding is hard, let's go stÿFFFFF6fum
02:25:28 <pjdelport> So (id f) x  is f x
02:25:29 <dsturnbull> heh
02:25:32 <jle`> i don't even know what happened
02:25:35 <DarkCthulhu> jle`: http://ideone.com/qz3Ry5; This is a 3 parameter function to which I bound th first 2 arguments 2 and 4 and later applied the last argument. How do I bind the last 2 arguments instead in the first step.
02:25:36 <DarkCthulhu> ?
02:25:57 <chrisdone> :t (•.•)
02:25:57 <lambdabot> Doc
02:26:03 <ruuns> link is not working for me DarkCthulhu
02:26:15 <pjdelport> > let (+) = 5 in (+)
02:26:17 <lambdabot>  5
02:26:17 <chrisdone> the chinese translation of that is: (Rustic "_ rustic")> Queue must spread - fence
02:26:18 <jle`> DarkCthulhu: you can't use operator section syntax easily to partially apply the third+ arugment
02:26:19 <ruuns> oh, damn ;
02:26:20 <isBEKaml> ruuns: s/;//
02:26:24 <grohne> I am looking into eliminating a MonadError at http://lpaste.net/108094. It seems that conceptually after catchError no errors should remain, so I hope to get rid of the MonadError requirement. is that actually possible?
02:26:27 <jle`> DarkCthulhu: only the first and the second
02:26:33 <pjdelport> There's no requirement that operators actually be binary functions, or functions at all :)
02:26:34 <jle`> s/and/or
02:26:55 <DarkCthulhu> ruuns: The semicolon is not a part of the link. Sorry. -> http://ideone.com/qz3Ry5
02:26:57 <dsturnbull> :t ($)
02:26:57 <lambdabot> (a -> b) -> a -> b
02:27:11 <merijn> grohne: What if the error handler throws a new error?
02:27:19 <DarkCthulhu> jle`: I see.. It's only the first and second that I can bind in any order.
02:27:26 <DarkCthulhu> Weird
02:27:26 <grohne> merijn: in my case the error handler does "return False"
02:27:30 <jle`> yeah, at least using operator section syntax
02:27:32 <pjdelport> DarkCthulhu: You can say "print" instead of "putStrLn . show"
02:28:00 <DarkCthulhu> pjdelport: ah, yes :) ty
02:28:19 <jle`> DarkCthulhu: actually it is not too easy to partially apply arbitrary arguments.  there is a library that implements combinators ... like a (??) operator, that lets you do something like this i think...but it's not very popular
02:28:25 <grohne> I was hoping to be able to use like runExceptT but I don't see how
02:28:32 <jle`> i think it'd let you do something like (f x y ?? z) h = f x y h z
02:28:50 <latk> I'm having some trouble setting up test-suite. I get this error when I run cabal test: http://lpaste.net/8907905791315410944
02:29:31 <chrisdone> jle`: what would let you do that?
02:29:33 <jle`> grohne: in other news, how excited are you that Functor will finally be a superclass of Monad in 7.10 ?
02:29:36 <latk> Any ideas what I'm doing wrong ?
02:29:40 <DarkCthulhu> jle`: Reminds me of SQL parametrized statements. :)
02:29:43 <jle`> chrisdone: i think there's a library somewhere that implements a (??) that way?
02:29:56 <jle`> i remember hearing about it
02:30:01 <merijn> grohne: Right, my point was that the type system doesn't let you prove that your error handler doesn't throw a new error
02:30:05 <Xack> @version
02:30:06 <lambdabot> lambdabot 5.0-int-e
02:30:06 <lambdabot> git clone git://github.com/int-e/lambdabot.git
02:30:21 <merijn> grohne: That's why the result of catchError is still in MonadError, because it needs to be able to deal with that scenario :)
02:30:22 <chrisdone> > 1
02:30:23 <lambdabot>  1
02:30:28 <chrisdone> my lambdabot was faster than this lambdabot
02:30:43 <jle`> grohne: you can't "run" the m, yeah
02:31:13 <jle`> it's impossible access the errorness directly from the monad itself...you can imagine that it's outside of the semantics of (>>=)
02:31:38 <grohne> can't I simply wrap the "m" up in an ExceptT and then use runExceptT instead of catchError?
02:31:55 <jle`> like you can't write an Either e Bool that tells you if you have "already failed" or not
02:32:02 <jle`> or well
02:32:09 <jle`> wait
02:32:14 <jle`> you can't write an (>>= f) that does that
02:32:41 <jle`> grohne: that would only catch the errors on the layer that you just wrapped
02:32:55 <grohne> jle`: I believe that's what I want here.
02:33:00 <jle`> which would have none, because the only function you use in that outer ExceptT is return/lift
02:33:05 <jle`> and return/lift doesn't error
02:33:17 <jle`> or ExceptT
02:34:04 <jle`> you'd be catching errors in the (MonadError e m) => m a -> ExceptT e' m a step, which doesn't error
02:35:03 <jle`> :t ExceptT
02:35:04 <lambdabot> Not in scope: data constructor ‘ExceptT’
02:35:11 <jle`> :t ErrorT
02:35:12 <lambdabot> m (Either e a) -> ErrorT e m a
02:35:16 <grohne> I don't quite get that yet. My goal is to call somecheck (which requires MonadError) but discarding the MonadError requirement afterwards. Why is that not possible by introducing an ExceptT for calling somecheck? then all of its errors should be within ExceptT which I can eliminate using runExceptT, no?
02:35:39 <grohne> or ErrorT for that matter, I don't get the difference. %-)
02:35:47 <jle`> all of its errors are in (MonadError e => m a)
02:35:52 <jle`> er, MonadError e m => m a
02:36:10 <jle`> if you wrap an ErrorT around it, you have a (MonadError e m => ErrorT e' m a)
02:36:19 <jle`> (note that the two error types are in general different)
02:36:21 <supki> latk: your test-suite does not have Main module so ghc does not build an executable
02:36:50 <jle`> you have "two layers" of errors, "running" the outside ErrorT will only give you the errors on the outside layer
02:37:00 <jle`> of type e', not e
02:37:03 <trap_exit> what is a good library
02:37:07 <trap_exit> for receiving / sending meails in haskell ?
02:37:07 <jle`> hm...
02:37:10 <jle`> i like pipes
02:37:11 <jle`> oh, for that
02:37:11 <trap_exit> s/meails/hemails
02:37:23 <grohne> jle`: I understand that I may have two error layers now, but shouldn't somecheck only use my added layer now?
02:37:53 <grohne> jle`: and shouldn't I be able to catch the errors occuring within somecheck that way?
02:38:10 <jle`> hm
02:38:25 <jle`> well you can monomorphize somecheck
02:38:38 <grohne> that means?
02:38:41 <jle`> somecheck :: Error e m ()
02:38:51 <jle`> as in, use it inside bettercheck as if it were an ErrorT e m ()
02:38:57 <jle`> and then you can run that
02:39:02 <jle`> hm
02:39:12 <jle`> @unmtl ErrorT e m ()
02:39:12 <lambdabot> m (Either e ())
02:39:42 <jle`> so you can use somecheck as if it were an ErrorT e m (), and then bind it
02:39:48 <jle`> and then you'll get an Either e () to work with
02:39:57 <jle`> hm this might work
02:40:07 <grohne> I believe I was trying to do that and only got type errors.
02:40:30 <isBEKaml> randen: right, great
02:40:37 <grohne> Admittedly, I started with a larger example involving more transformers, but even this smaller example proves hard to me.
02:40:41 <jle`> how about
02:40:56 <jle`> fmap (either (const False) (const True)) somecheck
02:41:01 <jle`> that should give you :: Bool
02:41:08 <jle`> oh you need to runErrorT
02:41:19 <jle`> fmap (either (const False) (const True)) (runErrorT somecheck)
02:41:21 <jle`> :t runErrorT
02:41:22 <lambdabot> ErrorT e m a -> m (Either e a)
02:41:37 <jle`> runErrorT someCheck :: m (Either e ())
02:41:46 <jle`> and it should be liftM, not fmap
02:41:59 <ruuns> :t liftM
02:41:59 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
02:42:01 <grohne> that solution was one of those I tried.
02:42:03 <ruuns> :t fmap
02:42:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:42:06 <jle`> liftM (either (const False) (const True)) :: m (Either e b) -> m Bool
02:42:10 <grohne> it fails to deduce Error e
02:42:16 <jle`> ah
02:42:25 <jle`> just set it to ()
02:43:04 <jle`> oh () is not an instnace
02:43:10 <grohne> String is an instance
02:43:14 <jle`> thats lame
02:43:17 <jle`> yeah, set it to String then
02:43:26 <grohne> but how do I set a type variable?
02:43:31 <jle`> using ::
02:43:41 <jle`> or well, you can specify a type using ::
02:43:52 <grohne> but then I'd need to use m which is not in scope, no?
02:44:12 <jle`> you can use the m in the scope of the top level type signature if you turn on ScopedTypeVariables
02:44:21 <jle`> or you don't even need to do that
02:44:32 <jle`> you can do it when you do either
02:44:41 <tdammers> my strategy is to just specify types locally and then enable whatever extension the compiler wants
02:45:07 <jle`> either (\_ -> False) (\_ -> True) :: Either String () -> Bool
02:45:07 <tdammers> m (Either (e :: String) b) -> m Bool
02:45:07 <tdammers> eh
02:45:07 <grohne> that sounds better. thanks
02:45:07 <tdammers> disregard me, Ihaven't had enough coffee yet
02:45:07 <jle`> but i think it looks nicer with scoped type variables
02:45:10 <jle`> honestly
02:45:16 <tdammers> listen to jle`
02:45:16 <jle`> scoped type variables should just be on by default :/
02:45:22 <grohne> \o/
02:45:38 <jle`> then you can do (runErrorT someCheck :: m (Either String ())
02:45:43 <grohne> so the small example works now.
02:45:58 <jle`> or even either (\(_ :: String) -> False) (\_ -> True)
02:46:00 <grohne> now I need to get it working for the big one as well. :)
02:46:22 <randen`> isBEKaml: actually, I ended up just submitting an issue; cabal-install-latest isn't linking to the right place.
02:46:30 <merijn> Note that "\_ -> x" is just "const x"
02:46:35 <jle`> "cannot deduce" is a weird error when you first run into it, because the first time you really run into it in a real program you don't expect it
02:46:49 <grohne> jle`: the latter one also needs ScopedTypeVariables. ;-)
02:47:07 <jle`> merijn: yeah, i wrote const earlier...but i wanted to demonstrate how one could use scoped type variables
02:47:12 <grohne> I'd rather not enable more extensions or I'll quickly fail to understand the present zoo of extensions
02:47:41 <grohne> thank you very much for the help!
02:47:43 <jle`> scoped type variables is an extension that i never choose to leave off
02:48:01 <jle`> it letns you write :: m (Either String ()) in your function, and assume that the `m` there si the same `m` as in the top level type signature
02:49:20 <jle`> grohne: good job on the intuition though, believing that this could be done :)
02:49:53 <isBEKaml> randen`: I'm not worried about it anymore. I got a standard build and used it to get a working cabal :)
02:49:59 <systemfault> What is the name of this applicative “operator” <*> ?
02:50:12 <Cale> systemfault: 'ap'
02:50:19 <jle`> grohne: yeah, "cannot deduce" means that you don't specify a type variable and there is no way for ghc to infer it, and it can't find a meaningful default instance.
02:50:20 <isBEKaml> randen`: my cabal is now on 1.20.0.3 built using 1.20.0.1
02:50:24 <systemfault> Cale: Thank you
02:50:29 <jle`> grohne: i remember my first time running into it...it took me a couple days to figure it out
02:50:44 <jle`> >_>
02:51:14 <jle`> the problem is that ghc needs to compile *something*.  it can't just pretend to not compile anything.  it has to compile some specific concrete type
02:51:35 <isBEKaml> jle`: about (`id` 1) - I did :t to find out my answer. Is that considered cheating? :)
02:51:54 <jle`> isBEKaml: no, that is using good tools :)  the real puzzle was being able to explain it
02:52:06 <jle`> also i wasn't the one who asked it, so i probably shouldn't be the one deciding the rules
02:52:09 <jle`> heh
02:52:13 <isBEKaml> heh
02:52:14 <merijn> To be fair, learning to do type inference in your head by doing it yourself is a good exercise
02:52:18 <frerich> Oh you're still talking about that? :)
02:52:26 <jle`> yeah, listen to merijn
02:52:32 * frerich suggested it as a brain teaser and then minimized his chat client...
02:52:43 <jle`> doing (`id` 1) in ghci robbed you of a nice learning experience
02:52:48 <jle`> so sad!
02:52:56 * jle` mourns the lost experience
02:52:59 <merijn> IMO, one of the best exercise for haskell beginners is writing down types and manually doing substitution of type variables on a piece of paper
02:53:04 <isBEKaml> well, I thought it can't be something related to values, could be a function instead (something like what const does)
02:53:12 <isBEKaml> and :t confirmed it.
02:53:51 <jle`> for extra credit try using it to get a value
02:56:23 <jle`> um.  well functions are values
02:56:32 <jle`> i mean a non-function...data?
02:56:37 <jle`> >_>
02:56:41 <merijn> jle`: "a non-function value"?
02:56:59 <frerich> jle`: A non-function value, you mean?
02:57:05 <frerich> Ah, beat me to it.
02:57:07 <randen> isBEKaml: Good to know there are others using haskell on Windows; I've been packaging up the upcoming Haskell Platform for Windows
03:00:39 <jle`> is (a, Maybe a) a comonad?
03:01:14 <jle`> newtype Mebbe a = Mebbe (a, Maybe a)
03:01:50 <jle`> extract = uncurry fromMaybe
03:01:51 <aloiscochard> hey folks, I'm preparing an abstract for a talk at a local conf, if there is any native english (or just good english ;-)) speaker that could take a look at my abstract that would be awesome: http://pastebin.com/jDWD30EC
03:02:03 <aloiscochard> any suggestion welcome :-)
03:02:56 <jle`> aloiscochard: for english or for content?
03:03:18 <aloiscochard> jle`: mainly english, but I welcome comments about content too!
03:03:23 * hackagebot contravariant 0.6.1.1 - Contravariant functors and Day convolution  http://hackage.haskell.org/package/contravariant-0.6.1.1 (EdwardKmett)
03:03:51 <aloiscochard> the audience should include FP coders but it's not a FP only conf (it's just a track about FP)
03:04:14 <isBEKaml> randen: I once emailed Mark about helping package HP for windows - never got a reply back.
03:04:28 <isBEKaml> randen: good that there's still effort to package HP for Windows.
03:04:56 <isBEKaml> aloiscochard: s/technics/techniques/
03:05:01 <Kinnison> aloiscochard: http://pastebin.com/CwVa069n
03:05:06 <aloiscochard> isBEKaml: oh thanks, I tried to google that one without success!
03:05:06 <xinming> Just curious for State monad, When we use get, that the value returned by state will be updated to    \s -> (s, s)      <--- Does this mean we can never get the old value back?
03:05:08 <Kinnison> aloiscochard: Purely a rework of some of the sentences
03:05:46 <isBEKaml> aloiscochard: another sentence rework - numerous programming languages which integrate ...
03:06:00 <aloiscochard> Kinnison: this is perfect! thank you so much for that, really appreciated
03:06:07 <aloiscochard> isBEKaml: oh nice, ty
03:06:12 <jle`> aloiscochard: http://pastebin.com/9YChKaKc , with as-minimal-as-possible-edits for satisfying the arcane laws of english grammar
03:06:16 <bergmark> xinming: correct, but you can just change it to keep a history if you want
03:06:39 <aloiscochard> what an awesome community! thanks everyone :)
03:06:40 <Kinnison> aloiscochard: I look forward to you coming back here with a youtube or vimeo link of your talk later :-)
03:06:49 <jle`> ^^ same :)
03:07:08 <aloiscochard> Kinnison: I'll do for sure, but first it have to be accepted!
03:07:10 <randen> isBEKaml: And we'll have the HP on 64-bit this time!
03:07:13 <Kinnison> :-)
03:07:20 <isBEKaml> aloiscochard: OOC, are there languages that conflate who/which? :)
03:07:29 <xinming> bergmark: Thanks, I just try to understand monad working by writing it in perl.
03:07:30 * Kinnison has colleagues who think that because python has map-like, filter-like and lambda-like stuff, it's functional-enough
03:07:32 <isBEKaml> randen: Oh, that's great news!
03:08:07 <jle`> xinming: the \s -> (s, s) itself doesn't have a "previous value"
03:08:13 <xinming> bergmark: Yes, We need another placeholder for something like,      \s -> (s, s, v_backup)  :-)
03:08:28 <randen> isBEKaml: So, no more <4GB heap size limitations
03:08:32 <aloiscochard> isBEKaml: not user I got what you mean, you mean example of "mostely" FP lang?
03:08:40 <jle`> xinming: "previous value" only makes sense when you think about sequencing them with (>>) or (>>=)
03:08:42 <xinming> jle`: Yes, That's what I meant. So, I think in monadic operations, when we do get, We can't get the old value.
03:08:51 <jle`> xinming: well, we can, with (>>=) :)
03:08:56 <isBEKaml> jle`: typing let foo = (`id` 1) in (foo $ 1) :: Int hilariously blew up on ghci!
03:08:58 <jle`> you can't with (>>)
03:09:15 <isBEKaml> aloiscochard: I was referring to human languages, not programming ones. :)
03:09:21 <jle`> isBEKaml: hahaha
03:09:24 <jle`> btw, foo $ 1 = foo 1
03:09:29 <aloiscochard> isBEKaml: hahaha :)
03:09:49 <jle`> xinming: you can keep previous values with (>>=), that's a part of the neat thing about (>>=) :)
03:10:09 <jle`> s1 >>= (\x -> put >> ... >> stuff >> ...)
03:10:12 <aloiscochard> I'm native french speaker actually, that's why I struggle ;-)
03:10:21 <ruuns> aloiscochard, are you also preparing some slides? i would be interested to get them :)
03:10:22 <jle`> xinming: anything in that lambda can use the 'previous value'
03:10:40 <jle`> as in, x is in scope throughout the entire lambda
03:10:45 <jle`> x being the 'previous value'
03:10:50 <aloiscochard> ruuns: sure, I'll just wait for the abstract to be accepted and then I'll (hopefully) write them
03:11:08 <ruuns> awesome
03:11:52 <xinming> jle`: I understand this, What I mean is something like,   s1 >>= get >>= process_with_state >>= get_original_value
03:12:03 <jle`> xinming: if you think about it...no single State object/function gives you access to the previous value
03:12:17 <jle`> can you think of an \s -> (something,something) that gives you the previous value?
03:12:27 <xinming> Yes, Only lambda.
03:12:37 <jle`> \s -> (something1, something2), i mean
03:12:44 <xinming> nope
03:12:48 <jle`> the actual State function doesn't have "access" to the previous value
03:12:56 <jle`> you can only do it in the context of (>>=)
03:13:02 <jle`> so:
03:13:19 <jle`> s1 >>= (\x -> get >> process >> return x)
03:13:30 <jle`> you actually can't write a "get_original_value" State function
03:13:40 <xinming> yes, Understand that.
03:13:45 <jle`> ah, ok :)
03:13:57 <jle`> we leave that job to the magic of (>>=)
03:14:07 <jle`> (not really magic)
03:14:20 <jle`> i also am not sure that you would be able to implement the v_backup version either
03:14:32 <jle`> but i recommend you try, and seeing why it's troublesome :)
03:14:49 <frerich> xinming: I recommend spinning 'A kind of magic' by Queen.
03:15:29 <jle`> try making your own State type that can encapsulate \s -> (s, s, v_backup)
03:15:41 <jle`> you will run into some trouble, but it's nice to see why
03:15:56 <jle`> fun times
03:16:02 <xinming> I'm kind of person if I don't know how it works, I don't know how I can use it. So, I try to do Monadic thing in perl, as I am familiar with perl.
03:16:19 <xinming> jle`: Yes, I know, the third value is hard to retrieve
03:16:26 <frerich> jle`: I suppose the question is warranted - what do you do in your life other than helping other people on IRC? :-}
03:16:37 <jle`> xinming: the problem is actually with the type system
03:16:41 <jle`> what type would v_backup be?
03:16:48 <jle`> and how would it be reflected in the type of State s a?
03:17:08 <jle`> traditionally, newtype State s a = State (s -> (a, s))
03:17:16 <jle`> if you added a third value with the old state, what type would it be?
03:17:27 <jle`> and if you added a new parameter to the State...could you instance it as Monad?
03:18:27 <xinming> Don't know, still trying something else.
03:18:28 <xinming> bbl
03:18:39 <jle`> oh yea,h you don't have to answer them, just things to think about
03:18:49 <jle`> i'm probably going to force myself to sleep
03:18:51 <jle`> night all
03:20:37 <xinming> jle`: good night.
03:21:29 <Athiwat> Hi guys
03:22:39 <Athiwat> Does anyone know how do I convert a string like "\xxxx\xxxx\xxxx\1234" to a readable string?
03:23:52 <frerich> Athiwat: Depending on who you ask, that might be considered a readable string already. What output would you expect?
03:24:09 <Athiwat> frerich: it's should be some Thai language.
03:24:25 <frerich> Athiwat: I.e. those are Unicode code points in hexadecimal?
03:25:03 <Athiwat> frerich: I think so!
03:25:44 <Athiwat> frerich: they are returned by the Facebook library. They are in Thai langauge.
03:25:51 <DarkCthulhu> If I have a function which is of type f :: Int -> IO(), how do I make it recurse? Can I do imperative style if..else decisions and multiple return statements?
03:26:03 <Yuu_chan> @pl \_ x -> return x
03:26:03 <lambdabot> const return
03:26:21 <zomg> Athiwat: it should be a readable string if you just output it, assuming whereever you're outputting has the correct charset
03:26:33 <frerich> Athiwat: Sounds like it would be useful to convert each '\xxxx' chunk into a Char. Which means you first have to split the input string into five-character chunks. Then you could convert each hexadecimal number to an integer. And then you could convert each of those numbers to a Char.
03:26:42 <pjdelport> Athiwat: Is this JavaScript / JSON?
03:26:44 <frerich> Athiwat: So you end up with a list of Chars. Which happens to be a string.
03:26:59 <zomg> If it's output from FB API or such, and it's supposed to be thai, I would say it's just UTF8 encoded thai characters
03:27:05 <pjdelport> Athiwat: Those *should* be using \uXXXX (note the "\u" prefix) for unicode
03:27:13 <zomg> you probably won't be able to convert it into standard ascii
03:27:37 <Athiwat> pjdelport: I'm getting something like this in return Just "\3619\3657\3634\3609 Aoikaaaaaa"
03:27:39 <DarkCthulhu> jle`: If you're around, could you please help me out with that? Recursion/loops with an "impure" function.
03:27:40 <Athiwat> So confusing
03:27:46 <pjdelport> Athiwat: From where exactly?
03:27:49 <Twey> DarkCthulhu: if youWantToRecurse then f newArgument else return ()
03:27:58 <Athiwat> pjdelport: Facebook library "fb"
03:28:09 <Athiwat> frerich: I will try that
03:28:14 <DarkCthulhu> Twey: That can be done within a do block?
03:28:15 <pjdelport> Athiwat: From where in the Facebook API, i mean?
03:28:16 <Twey> DarkCthulhu: Or: when youWantToRecurse $ f newArgument
03:28:21 <Twey> DarkCthulhu: Yes, of course
03:28:58 <Twey> DarkCthulhu: You can have any expression you like in a do-block.  It just has to return a value in the monad you're using.  ‘return ()’ and ‘f newArgument’ both have type IO (), so that's fine.
03:29:24 <DarkCthulhu> Twey: Cool. Will try. Thanks Twey.
03:29:34 <Athiwat> pjdelport: from a search return
03:29:39 <Twey> DarkCthulhu: ‘when’ is a shortcut for that particular pattern.  when p x = if p then x else return ()
03:29:51 <Twey> (from Control.Monad)
03:30:48 <pjdelport> Athiwat: Hmm, doesn't look like that's Thai, if it's Unicode
03:30:51 <Athiwat> pjdelport: I called show on it if you need to know.
03:31:23 <pjdelport> Athiwat: As "\u3619\u3657\u3634\u3609", that gives me: 㘙㙗㘴㘉
03:31:39 <Athiwat> pjdelport: it's not \u, it's just \3619
03:32:01 <Athiwat> pjdelport: the type is Maybe Data.Text.Internal.Text
03:32:02 <pjdelport> Athiwat: I know; I'm trying to determine what was actually intended.
03:32:06 <frerich> pjdelport: Given that there are no letters, maybe they are decimal numbers instead of hex.
03:32:18 <frerich> pjdelport: I just did an educated guess about 'hex' :)
03:32:30 <pjdelport> frerich: Good point.
03:33:14 <haasn> > read "\"\3619\3657\3634\3609\""
03:33:15 <lambdabot>  *Exception: Prelude.read: no parse
03:33:25 * hackagebot taggy 0.1.2 - Efficient and simple HTML/XML parsing library  http://hackage.haskell.org/package/taggy-0.1.2 (vi)
03:33:26 <haasn> > read "\"\\3619\\3657\\3634\\3609\""
03:33:28 <lambdabot>  *Exception: Prelude.read: no parse
03:33:39 <haasn> > read "\"\\3619\\3657\\3634\\3609\"" :: String -- there
03:33:40 <lambdabot>  "\3619\3657\3634\3609"
03:33:46 <haasn> > text $ read "\"\\3619\\3657\\3634\\3609\""
03:33:47 <lambdabot>  can't find file: L.hs
03:33:51 <haasn> > text $ read "\"\\3619\\3657\\3634\\3609\""
03:33:52 <lambdabot>  ร้าน
03:33:57 <haasn> that look right?
03:34:31 <Athiwat> haasn: YUP!
03:34:45 <haasn> Oh, you don't actually have a string containing literally \3619\3657 .. do you
03:34:56 <haasn> I think I misread the problem
03:35:02 <pjdelport> Athiwat: Oh, it looks like your string is fine.
03:35:04 <wobbledops> Hi, is there a deque with indexing support?
03:35:10 <pjdelport> Athiwat: That's just how it gets shown
03:35:27 <Athiwat> I see
03:35:31 <Athiwat> I called show on it
03:35:34 <Twey> > text "\3619\3657\3634\3609"
03:35:35 <lambdabot>  ร้าน
03:35:37 <Athiwat> which is incorrect I guess?
03:35:39 <pjdelport> Athiwat: If you do e.g. putStrLn "\3619\3657\3634\3609 Aoikaaaaaa" you'll see the raw Unicode
03:35:53 <haasn> Athiwat: yes, ‘show’ will convert non-printable strings to decimal notation like \3619
03:35:58 <Athiwat> I see
03:36:00 <haasn> characters*
03:36:10 <Twey> Athiwat: It's not incorrect, but show is meant for debugging output, so it shows all characters that aren't ASCII-printable as escapes
03:36:25 <Twey> Athiwat: If you just pass the string to e.g. putStrLn then that won't happen
03:36:49 <haasn> Although what happens when passing a string to putStrLn depends on your system encoding
03:36:52 <grohne> jle`: so even though we figured the small example, it seems unapplicable to the real example, because the ExecptT is stacked to the wrong end. :-(
03:37:11 <DarkCthulhu> Twey: That worked. How can I have multiple statements within an if.. or else...?
03:37:55 <DarkCthulhu> Just indent them?
03:37:57 <Twey> DarkCthulhu: You can open another do-block
03:38:06 <grohne> jle`: what I really have looks more like somecheck :: (Error e, MonadError e m) => SomeTransformer m (), so I'd need to place the ExceptT into the inner stack and write a MonadError instance
03:38:17 <Twey> DarkCthulhu: Unless you're in a do-block, there's no concept of a ‘statement’
03:38:18 <DarkCthulhu> Twey: nested do blocks?
03:38:22 <Twey> Sure
03:38:26 <DarkCthulhu> I am already in a do block
03:38:34 <Athiwat> Twey: where is text located btw?
03:38:35 <Twey> DarkCthulhu: Not if you opened an if, you're not
03:38:52 <DarkCthulhu> Twey: The if.. is within a larger do block.
03:38:58 <pjdelport> Athiwat: That's a lambdabot-specific thing, if i'm not mistaken.
03:38:58 <Twey> Athiwat: It's part of the pretty-printing library that lambdabot uses.  You probably don't need it — it's just useful to stop lambdabot from ‘show’ing things.
03:39:02 <DarkCthulhu> I'll try the nesting.
03:39:19 <pjdelport> Athiwat: It's basically a lambdabot replacement for putStrLn
03:39:35 <Athiwat> pjdelport Twey and how do I get the text to show without using "show"
03:39:42 <Twey> DarkCthulhu: do (do x; y); z  is guaranteed to be the same as do x; y; z by the monad laws (up to binding)
03:39:46 <pjdelport> Athiwat: putStrLn :)
03:39:48 <haasn> show doesn't show text
03:39:54 <haasn> But that depends on your definition of “show”
03:40:22 <Twey> Athiwat: ‘show’ just converts things into a ‘readable’ form.  You don't want to do that here, so just don't call ‘show’.  Pass the string directly to ‘putStrLn’ or whatever you want to do with it.
03:40:42 <grohne>     Expected type: ReaderT () m0 () -> m (Either String ())
03:40:42 <grohne>       Actual type: ReaderT () m0 () -> m (Either String ())
03:40:57 <grohne> what is that kind of error?
03:40:58 <crodjer> Is HackageDB down?
03:41:06 <Cale> grohne: That's always fun :P
03:41:13 <haasn> grohne: Probably different definitions of ReaderT
03:41:16 <haasn> one strict and one lazy, perhaps?
03:41:17 <Cale> yeah
03:41:26 <haasn> I wonder why it doesn't show them qualified
03:41:27 <grohne> I have only one ReaderT imported
03:41:28 <haasn> I thought it shows them qualified
03:41:36 <hc> hi, is it possible to "convert" a list of tuples into a tuple of lists, like so: [(a, b)] -> ([a], [b])?
03:41:42 <Cale> Perhaps they're from different packages even?
03:41:47 <dibblego> @type unzip
03:41:48 <lambdabot> [(a, b)] -> ([a], [b])
03:41:54 <hc> thanks!!
03:41:55 <dibblego> hc: unzip
03:41:56 <haasn> Cale: Oh, that sounds like fun
03:42:20 <pjdelport> @hoogle [(a, b)] -> ([a], [b])
03:42:21 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
03:42:21 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
03:42:31 <haasn> imported module A re-exports module B from package 1, and you import module B from package 2, ending up with different versions of the same type from the same module?
03:42:36 <Athiwat> Thanks you all, great community!
03:42:55 <wobbledops> /bye/bye
03:44:00 <wooblydops> Hey I'm still here
03:44:02 <grohne> http://lpaste.net/108103 <- full error message
03:44:26 <Pythonfant> I'm having some trouble with xml-conduit not matching some elements in a document generated with html-conduit. If I print out the Document and do a grep all elements seem to be in it but is soon as I get a cursor using fromDocument and then try to match them a lot of elements seem to be missing. Also when I print the Cursor and do a grep there those elements are also not in there. Any idea what could be
03:44:28 <Pythonfant> causing this? http://lpaste.net/108102
03:44:45 <grohne> can anyone try the above on ghc 7.8?
03:47:10 <Pythonfant> grohne: http://sprunge.us/JeTK
03:47:33 <grohne> Pythonfant: much better, thanks
03:51:38 <Cale> grohne: oh, it's a panic
03:52:36 <Cale> grohne: What package is import Control.Monad.Trans.Except from?
03:52:50 <grohne> Cale: mtl or transformers I guess
03:53:02 <grohne> Cale: I had to hide transformers-compat
03:53:06 <Cale> oh, new transformers
03:53:41 <grohne> Cale: the goal is to make bettercheck do the same as boolcheck but without MonadError in the type signature
03:54:12 <MrPopinjay> Hey all. I use vim- is there a good plugin that will allow me to evaluate a visually selected block in ghci?
03:54:21 <grohne> Cale: without the ReaderT transformer, jle` worked out a solution
03:54:40 <MrPopinjay> Or am I doomed to be envious of emacs users?
03:56:00 <pjdelport> MrPopinjay: Check some of the options listed in http://www.haskell.org/haskellwiki/Vim
03:56:46 <pjdelport> MrPopinjay: There's also http://www.vim.org/scripts/script.php?script_id=2356
03:57:52 <Cale> grohne: Here I get different errors from GHC
03:57:56 <Cale> grohne: for your file
03:58:35 <Cale> http://lpaste.net/108103 -- see my annotation
03:59:02 <grohne> Cale: using ghc 7.8 I guess
03:59:09 <Cale> I'm on 7.8.2
03:59:43 <MrPopinjay> Thanks pjdelport
04:00:02 <MrPopinjay> I still feel like I ought to learn emacs. The plugin ecosystem is amazing
04:00:06 <grohne> Cale: and how do I make it "work"? ;-)
04:00:23 <Cale> grohne: That kind incompatibility is really interesting
04:01:01 <grohne> Cale: there is MonadError e m => MonadError e (ReaderT r m), so I should be able to put the ExceptT at the inner place
04:01:03 <Cale> It thinks that ReaderT takes another type parameter somehow
04:01:30 <Cale> and then shortly thereafter, the compiler freaks out
04:01:49 <Cale> So you're triggering some bug in GHC 7.6.3 which has apparently since been fixed
04:02:24 <Cale> You're probably aware of this, but ReaderT () is pretty silly
04:02:45 <grohne> Cale: in reality there is something different to ()
04:02:58 <Cale> I figured :)
04:03:00 <grohne> Cale: I can give you the real example, if you want to see it
04:03:06 <Cale> nah, it's okay
04:03:36 * grohne just tried to make a small illustrating example
04:03:37 <Cale> Possibly the best way to sidestep this issue is just to upgrade GHC
04:03:47 <Cale> because it looks like the bug is no longer there
04:03:54 <grohne> Cale: well, it doesn't build on ghc 7.8 either, so that won't solve the problem
04:03:59 <Cale> Well, yes
04:04:09 <Cale> but you'll at least be getting a correct error message :D
04:04:25 <grohne> I already asked for my ghc to be upgraded. that'll happen "soon". %-)
04:04:58 <Cale> So, the problem in what follows is that it doesn't know which type of error you want to use
04:05:13 <Cale> The (\_ -> return False) doesn't make that apparent
04:05:31 <grohne> but the "Either String () -> Bool" should
04:06:16 <kvanb> type inference is far from perfect
04:06:17 <grohne> oh well ghc 7.6 figures boolcheck, ghc 7.8 doesn't. more fun
04:06:33 <grohne> now we have a bug in 7.8?
04:07:03 <xinming> anyone here familiar with perl? Not a perl question, But a monad question by doing it in perl.
04:07:24 <xinming> should I ask in #perl channel?
04:08:50 <Cale> xinming: I'm not terribly familiar with perl, but my guess is that unless your implementation of monads is annoyingly awkward to use, it's wrong.
04:08:55 <zomg> I get the feeling it's more likely that someone here knows Perl enough to answer that, than someone on #perl knowing enough about monads :D
04:09:05 <grohne> I guess I should just replace all those MonadError thingies with Either
04:09:08 <Cale> xinming: (Most implementations of monads in dynamically typed languages are incorrect)
04:09:11 <osfameron> xinming: I'm happy to talk about that in #haskell-blah ?
04:10:21 <Cale> xinming: In particular, whatever you're calling 'return' will need to take 2 parameters, because you can't work out which monad instance to use from the type of the result.
04:10:38 <Cale> :t return
04:10:39 <lambdabot> Monad m => a -> m a
04:10:58 <osfameron> you can partly get around that by hacks with dynamic scoping
04:10:58 <Cale> ^^ this is polymorphic in its result type in a way which cannot be determined by the value of the argument
04:11:34 <Cale> osfameron: Can you do that and still write a polymorphic sequence function?
04:11:39 <osfameron> e.g. once you're "in" a monad, then subsequent calls to "return" can work it out (obviously the first call can't)
04:11:50 <Cale> If you can't write a sequence function that'll work with an arbitrary monad, then there's no point in even talking about monads
04:13:24 <osfameron> hmmm, been a while since I last attempted to implement this, can't remember
04:13:55 <dibblego> I have done it using python. It works, but is extremely silly.
04:14:20 <Cale> The whole point of monads is to be able to get all that stuff in Control.Monad (and stuff elsewhere which'll work with an arbitrary monad) for free
04:14:26 <Cale> after having implemented return and bind
04:14:26 <NikolajK> if f is a functor and k a function, am I write that (fmap k) mx is equal to mx >== \x-> (return (f x))
04:14:41 <Cale> >>=
04:14:45 <NikolajK> mx >== \x-> (return (k x))
04:14:46 <Cale> but yes
04:14:49 <xinming> Cale: osfameron thanks for your notes, I'll post this later, I just realized something.
04:15:13 <NikolajK> okay thank you
04:15:17 <xinming> Cale: Yes, It's awkward, But what I am trying to achieve is try to know how does the monad processing is done internally.
04:15:45 <xinming> Just like when we do oop. It takes me a lot time to understand what the word "this" pointer in oop mean.
04:16:34 <Cale> xinming: So the first thing to understand is how type classes are implemented in general
04:17:02 <xinming> and how it is created. So, I want to use the same idea to learn monad in haskell too. and yes, It's awkward, Because it ends up too many   bind(bind(bind(bind()))) ...
04:17:12 <NikolajK> what are the unnecessary brackets in mx >== \x-> (return (f x)). I'm sure there are some
04:17:23 <Cale> xinming: oh, but it should be even worse than that, since every bind should have three parameters instead of two
04:17:25 <xinming> But it's still ok for me to understand how they updated.
04:17:42 <merijn> NikolajK: Your bind operator is wrong
04:17:45 <NikolajK> mx >>= \x-> return . f x ??
04:17:58 <Cale> xinming: In Haskell, we can get away with bind having two parameters, but in any dynamically typed language (or any language without something close enough to type classes) it'll have to take three
04:17:59 <NikolajK> or maybe mx >>= \x-> $ return . f x
04:18:03 <merijn> NikolajK: Even simpler would be "mx >>= return . f"
04:18:04 <dibblego> mx >>= \x-> (return . f) x
04:18:19 <Cale> :t (>>=)
04:18:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:18:32 <Cale> ^^ this "Monad m" thing needs to become an additional function parameter
04:18:52 <Cale> because it can't be supplied automatically by the compiler in all cases
04:18:58 <Cale> (especially in the case of return)
04:19:07 <Cale> :t sequence
04:19:08 <xinming> Cale: Did you ever done Monad thing in other language instead of haskell?
04:19:08 <lambdabot> Monad m => [m a] -> m [a]
04:19:28 <Cale> xinming: I've thought about how to do it, and then not actually done it, because it's silly
04:19:38 <Cale> Actually, that's not true, I've actually done it in scheme
04:19:42 <NikolajK> oh, then the wikipedia example "add mx my = mx >>= (\x -> my >>= (\y -> return (x + y)))" introduces x and y unnecessarily
04:19:45 <Cale> But it sucked :P
04:19:52 <dibblego> there are other languages for which it isn't silly e.g. Scala
04:20:31 <osfameron> I think the dynamic "$CurrentMonad" thing isn't terrible.  You can simply make "return" error if it isn't called within a monadic scope
04:20:33 <Cale> xinming: Consider what sequence needs to produce if the list of m-actions is empty
04:20:36 <xinming> Cale: I try to do it so I think I can learn it. Otherwise, the monad thing is really hard to understand for me, and I don't like to use something I can understand.
04:20:42 <dibblego> trait Monad[F[_]] { def bind[A, B](f: A => F[B]): F[A] => F[B]; def pure[A]: A => F[A] }
04:21:01 <Cale> xinming: Well, why not just try to understand it in the context of Haskell first?
04:21:05 <dibblego> xinming: Haskell is the best language to use as far as learning how to effectively use monads
04:21:06 <merijn> NikolajK: No, the wikipedia example needs those parameters due to the nesting of >>=
04:21:14 <Cale> xinming: It doesn't translate very well to many other languages
04:21:29 <Cale> xinming: It just becomes way more confusing
04:21:39 <merijn> Cale: Sure it does! ML, Agda, Coq, Idris, oh...wait >.>
04:21:50 <Cale> Monads also suck in ML
04:21:56 <xinming> Cale: Because I tried it before, and every time I try to read <<All about monads>> tutorial, I lost. And this was almost 10 years ago, later I got busy with other things. and have some time in these days. :-)
04:21:56 <Cale> you can use the module system, kinda
04:22:02 <merijn> I guess you need ugly module hacks, yeah
04:22:23 <merijn> Don't read monad tutorials, they're terrible
04:22:28 <dibblego> xinming: the material on http://github.com/nicta/course is designed to help you effectively use monads
04:22:30 <BoR0> box analogy helps (enough) about monads, but don't restrict your thinking to that
04:23:01 <Cale> If you really want to read a monad tutorial, you might try this: http://www.haskell.org/haskellwiki/Monads_as_computation
04:23:12 <Cale> But there's really not a whole lot to it when you get down to it
04:23:16 <xinming> bbl, I think I can understand some reason of it now. But I think there is still something critical I didn't understand. But I don't know where it is.
04:23:24 <Cale> There's a lot to *specific examples* of monads
04:23:29 <xinming> dibblego: Thanks, I'll go with it first.
04:23:30 <dibblego> monad tutorials are not written using spoken languages
04:23:49 <dibblego> xinming: no problem, there is also #nicta-course for others who are doing the same
04:23:58 <Cale> A lot of monad tutorials, especially early ones, miss the point
04:24:11 <BoR0> monads are too abstract to explain everything they can do. but what they have in common is return, bind, and rules that follow them.
04:24:13 <dibblego> even recent ones
04:24:28 <Cale> The whole point of having this monad abstraction is so that we can write functions which'll work using an arbitrary monad
04:24:39 <Cale> sequence is probably the simplest example of one
04:24:42 <xinming> as far as I understand about monad is, It is a way to combine many "chained" functions to make it calls one after another so it can do something where pure functional languages can't.
04:24:47 <Cale> or things like mapM, filterM, etc.
04:24:50 <Cale> liftM2
04:24:55 <Cale> things like that
04:24:56 <xinming> for example, keep the state, and IO.
04:25:07 <Cale> If you can't have stuff like that, then there's no point in even talking about monads
04:25:09 <osfameron> xinming: they're not really chained, they're nested
04:25:13 <dibblego> xinming: the practical purpose of monads is abstract away code repetition — the nicta course deliberately steers you to clearly see this point
04:25:17 <Cale> Monads actually have nothing to do with IO or state
04:25:22 <Cale> Those just happen to be monads
04:25:29 <xinming> that's what I understand, But I think I still need more digging on this
04:25:38 <osfameron> Cale: that's not entirely true.  the patters is still really useful (Maybe, List comprehensions, Continuations) *even* if you didn't then make it higher order
04:25:39 <xinming> osfameron: Yes, nested,  bind(bind(bind(bind(bind(bind(....))))
04:25:44 <dibblego> Cale: I am in USA to say this at a conference :)
04:25:50 <Cale> dibblego: cool
04:25:57 <osfameron> xinming: yeah -- I have soem Devel::Declare stuff to make that prettier
04:26:09 <dibblego> and I will be saying the same at a Python conference in Australia next week
04:26:15 <osfameron> xinming: and there was another very clever, pure perl implementation of it which is on CPAN (I don't understand how it works)
04:26:21 <Cale> osfameron: Well, there were a lot of combinator libraries which existed before anyone in the functional programming world started using the word "monad" for this
04:26:22 <aloiscochard> dibblego: which conf are you gonna give talk to in US?
04:26:36 <dibblego> aloiscochard: already done, lambdajam.com (I am in Chicago)
04:26:41 <Cale> libraries which happened to have good monad instances
04:26:48 <xinming> dibblego: Yes, Oop is another direction to do code reuse.
04:26:54 <Cale> but there's not much point in talking about that if you're not going to abstract over it
04:26:59 <aloiscochard> dibblego: oh yeah of course :)
04:26:59 <dibblego> aloiscochard: https://dl.dropboxusercontent.com/u/7810909/media/doc/scalaz-history/074ea0b71744511c050c98bc82b82f13a53fc322/scalaz-history.pdf
04:27:02 <xinming> I now understand oop, so, now go with haskell
04:27:08 <Cale> because knowing that something happens to be a monad doesn't really tell you a whole lot
04:27:09 <aloiscochard> dibblego: that what I was going to ask, ty mate
04:27:19 <BoR0> understanding oop is not a pre-requisite for Haskell
04:27:55 <merijn> I would actually say OOP actually is harmful to haskell understanding
04:27:58 <xinming> Cale: It's just someone's way of learning. Before I learn oop, I try to do some ugly dynamic method dispatch to learn how oop helped
04:28:25 <BoR0> I agree with merijn. harmful at least to the point where you stop trying to make analogies :)
04:28:32 <Cale> xinming: Well, if you really want to implement this, you should start by implementing some other type classes
04:28:35 <Cale> xinming: like Eq
04:28:37 <Cale> and Ord
04:29:08 <aloiscochard> agree with merijn, one should actually unlearn oop when digging haskell
04:29:22 <xinming> Nope, I understand how is type system in haskell different from oop.
04:29:34 <Cale> I don't know, Haskell (or just functional programming more generally) has given me a new way to look at OOP. There is a good idea in there.
04:29:38 <xinming> Thanks for your time, I'll go read again.
04:29:44 <Cale> But there's also lots of junk that people get hung up on.
04:30:18 <Cale> Inheritance and subtyping are both red herrings with regard to what object oriented programming is about IMO
04:30:30 <aloiscochard> Cale: those good ideas could be seen as a sophistacted module system in FP, innit?
04:30:44 <mbrock> I don't even think classes are very important
04:30:52 <Cale> and all, or at least most of the typed OO languages seem to screw up their type system so as to attach the definitions of methods to the types of objects
04:31:31 <Cale> At least in my opinion, the type of an object should only inform you about which methods it has and what their types are.
04:31:52 <Cale> and then you don't need so much hierarchy
04:32:05 <Cale> you just have objects with different method implementations
04:32:08 <zomg> What else does the type inform you in OOP beyond that?
04:32:37 <Cale> zomg: In order to write new method implementations in, say, Java, you need to define a new class.
04:32:40 <Cale> i.e. a new type
04:33:32 <zomg> How would you do that without doing it though? Assuming of course that the goal is not to replace all instances of the old behavior
04:33:34 <dibblego> you don't need to, for some definition of "a new type"
04:33:48 <Cale> There's no way to construct a new object of an existing type just by supplying implementations of all the methods, but there ought to be.
04:33:49 <dibblego> new Blah() { … defines a new type that cannot be referenced
04:33:57 <dibblego> yes there is
04:33:59 <zomg> Ah that's what you meant
04:34:00 <dibblego> not in C# though
04:34:13 <Cale> dibblego: Oh, is there now?
04:34:13 <zomg> iirc you can do it in some languages yeah
04:34:18 <dibblego> Cale: always has been
04:34:19 <Cale> There wasn't when I learned Java, at least.
04:34:22 <Cale> errr
04:34:36 <zomg> x = new SomeClass() { someMethod() { newstuff(); } }
04:34:43 <zomg> I think Java has inline classes like that
04:35:09 <dibblego> it is C# that doesn't, which causes much pain
04:35:10 <Cale> Okay, but that still technically creates a new type which is a subtype of SomeClass?
04:35:16 <zomg> Probably
04:35:29 <dibblego> yes it does, but that type cannot be referenced
04:35:31 <Cale> I'd just do away with subtyping altogether
04:35:38 <dibblego> so it is questionable whether it is a type
04:35:46 <dibblego> so would I, tell the scala guys :)
04:35:47 <Cale> and leave that as the primary way of defining objects
04:35:57 <aloiscochard> yeah indeed :)
04:36:10 <zomg> It almost sounds like prototypal inheritance in a way
04:36:24 <dibblego> zomg: it is, with lots of ceremony attached
04:37:15 <zomg> Personally I don't see much benefit from that though
04:37:27 <zomg> At least often when I actually need a subclass it's just to replace some instance of the behavior
04:37:33 <Cale> zomg: Well, then you get really good type inference
04:37:39 <Cale> for one
04:37:59 <dibblego> yeah, to quote Erik Meijer two days ago, "VB has better type inference than Scala"
04:38:11 <dibblego> and it is a true statement
04:38:26 <zomg> I don't really see how that would work, but who knows
04:38:31 <Cale> It simplifies the world, you don't have to worry about co/contra/invariance
04:38:58 <zomg> I mean technically it seems like the result is the same still, you're just replacing the methods with something else... which seems to me pretty much the same as subclassing :)
04:38:58 <Cale> zomg: This encoding of objects works perfectly okay in Haskell, so you can try it :)
04:39:15 <Cale> zomg: Just define datatypes which are records of functions for the methods
04:39:32 <Cale> and then functions that take the private stuff as parameters, and construct records of that type
04:40:09 <Cale> It works beautifully, and you find that you don't really need subclassing very much because you can just define lots of different object constructing functions.
04:40:29 <zomg> It sounds like it's just a different way of thinking of the same thing tbh :D
04:40:55 <dsturnbull> it's more about composition rather than inheritance
04:40:56 <zomg> I mean you could hide the detail that it's a subclass in Java so the consumer doesn't see it
04:41:28 <dibblego> the scalaz project has spent years battling all of this
04:41:30 <zomg> you could even go as far as just having an interface, then it doesn't have to be a hierarchy
04:41:55 <Cale> zomg: Right, I'm saying *only* have interfaces in the language, and no classes.
04:42:11 <Cale> (or at least, that's roughly equivalent to what I'm saying)
04:42:36 <zomg> heh
04:42:45 <zomg> I forget if you can actually do that in Java with the inline class stuff
04:42:52 <zomg> new IWhatever { stuff() { blah(); } }
04:42:59 <zomg> oh I think you actually can =)
04:43:12 <dibblego> you can, it is called anonymous classes
04:43:13 <Cale> It's also a cultural thing
04:43:18 <Cale> Nobody programs like that in Java
04:43:28 <Cale> even if it really is possible
04:43:28 <dibblego> Cale: yes they do http://functionaljava.org
04:43:33 <zomg> inline classes are generally recommended to be avoided if I remember correctly
04:43:36 <Cale> Okay, maybe some weirdos do ;)
04:43:50 <dibblego> functionaljava has been very successful in convincing others to stop using java
04:43:55 <Cale> hahaha
04:44:01 <dibblego> "This is your language doing its very best."
04:44:24 <dibblego> Brisbane Functional Programming Group started on the premise of that project
04:46:06 <Cale> But yeah, if you do that, and throw out all the nonsense about inheritance and class hierarchies, you end up with a leaner view of what OOP is about, which I think actually succeeds sometimes at being the right approach for some problems.
04:46:39 <zomg> tbh I rarely find myself using subclassing anyway
04:46:59 <zomg> beyond something like sharing the base functionality/data in certain scenarios
04:47:10 <Cale> Yeah, over the years everyone has been gradually moving away from it, because it causes problems
04:47:22 <zomg> I remember I used it a lot more when I wasn't very good at it yet =)
04:47:29 <blakehaswell> Evening
04:47:31 <zomg> and then it was a beautiful long subclasss chain and it sucked
04:47:31 <zomg> lol
04:48:01 <merijn> I'm convinced inheritance of anything other than interfaces is evil, even when doing OO
04:48:20 <xinming> totally magic, I finaly done
04:48:30 * hackagebot tidal 0.4.7 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.7 (AlexMcLean)
04:48:53 <zomg> Yeah I used to do some game programming in OO langs where it seemed to make sense to use base classes for things like game entities
04:48:55 <xinming> I've finally done it. thanks for your time. simulate the state Monad in perl and doing update on both value and the state. It's a really wonderful taste. :-)
04:49:09 <zomg> so you could have commonly used logic like how the entity moves shared
04:49:28 <zomg> but I think that can be achieved by using composition just the same
04:49:38 <zomg> and you run into less problems in cases where you need some sort of special behavior
04:50:00 <Cale> zomg: Yeah, in a functional language where you're using an OO design, you just plug in the same functions to implement those methods.
04:50:37 <Cale> (more or less)
04:57:39 <varnie> hello.
04:58:22 <ruzu> nice.  actually, i think having a "functional best practices" for java would be handy
04:58:31 <ruzu> sometimes you're ... stuck with writing java
04:58:45 <ruzu> pain, but slightly dulled
04:59:48 <varnie> newbie here. could you help me with a piece of code?
04:59:53 <blakehaswell> That's always unfortunate
05:00:03 <blakehaswell> @ruzu
05:00:04 <lambdabot>  not an expression: ‘’
05:00:58 <frerich> To be fair, inheritance in Java or C++ is often abused for implementation (i.e. code) reuse instead of interface reuse. So instead of factoring common code out into a free helpre function, people sometimes pull things into a baseclass.
05:01:12 <frerich> ...to avoid having to pass an explicit 'this' pointer around. :-(
05:01:47 <frerich> So it has a really bad reputation by now, but I suppose the same concerns about abusing language features could be raised for e.g. do-notation.
05:02:17 <joshc> varnie: we certainly can, our preferred pastebin is lpaste.net.  you may also be interested in #haskell-beginners
05:18:19 <arj> Is it normal/expected, that cabal repl does not use the environment of the shell it is called from?
05:19:36 <arj> ghci inherits the environment, cabal repl doesn't
05:21:07 <kstt> Hello
05:22:38 <arj> can anyone confirm this?
05:23:32 <kvanb> arj: if you can confirm it, post it as a cabal bug
05:23:34 * hackagebot semigroups 0.15.2 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.15.2 (EdwardKmett)
05:23:55 <kstt> I really need some help from GHC wizards here. I am working on a project that build fine on my linux box. Now I need to build my project on WINXP, and it fails with a "unknown symbol" error : http://lpaste.net/108110
05:24:13 <arj> kvanb: I am checking if this has already been listed, but couldn't find anything so far. Can you reproduce it?
05:24:15 <kstt> I really don't know where to start
05:24:28 <kvanb> I can't think of a use case to reproduce
05:25:15 <kvanb> kstt: seems to be a known issue
05:25:23 <arj> kvanb: change your PATH environment variable, start a cabal repl from an arbitrary project, and check if the System.Environment.getEnviroment result reflects your change
05:25:54 <kstt> kvanb: really ?
05:26:54 <kvanb> arj: hold on, installing depends for an arbitrary package
05:27:04 <kvanb> kstt: I saw a thing on the mailing list from a while ago about it
05:27:23 <kvanb> no solution though.
05:27:31 <kvanb> they seem to think it was gmp related maybe
05:27:38 <kstt> kvanb: I can find a mail from SPJ complaining of this error when building GHC head. But there is no follow up, so I don't know what to do from here.
05:27:55 <kvanb> gcc --version ?
05:28:34 <kstt> $ gcc --version  ~~~>  gcc.exe (GCC) 4.6.2
05:28:35 * hackagebot semigroupoids 4.0.3 - Semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-4.0.3 (EdwardKmett)
05:28:56 <kvanb> should be ok
05:28:58 <kvanb> ghc --version ?
05:29:03 <kstt> 7.4.1
05:29:10 <kvanb> oh that's rather old.
05:29:27 <kstt> I'm rather old myself
05:29:52 <kvanb> packages tend to kind of really only support 1 or 2 versions back
05:30:08 <kvanb> I don't know whether its related to your issue though
05:30:46 <kstt> I can certainly try to update, as a first step.
05:31:02 <kvanb> arj: I cannot reproduce
05:31:12 <kvanb> I export FOO='BAR' and getEnvironment prints it correctly after cabal repl
05:31:18 <kvanb> ("FOO","BAR")
05:31:19 <kstt> I'll report back if it does not solve the issue, thank you.
05:31:20 <kvanb> osx 10.9
05:31:51 <kvanb> $ cabal --version
05:31:52 <kvanb> cabal-install version 1.18.0.5
05:31:54 <kvanb> ghc 7.8.3
05:38:36 * hackagebot comonad 4.2.1 - Comonads  http://hackage.haskell.org/package/comonad-4.2.1 (EdwardKmett)
05:44:25 <arj> kvanb: I can confirm that it works correctly with NEW environment variables, but not with PATH.
05:45:43 <arj> i.e. existing variables
05:45:52 <arj> have you tried with PATH?
05:46:05 <kvanb> you are correct, PATH does not work.
05:46:23 <arj> kvanb: thanks. strange bug. I will file one.
05:48:36 * hackagebot trifecta 1.5 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-1.5 (EdwardKmett)
05:53:05 <wz1000> How is aura?
06:00:36 <bernalex> is there a function that does case x of Just y -> stuff; Nothing -> return ()?
06:01:14 <merijn> forM, I think?
06:01:16 <merijn> :t forM
06:01:17 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
06:01:20 <merijn> :t forM_
06:01:21 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
06:01:48 <bernalex> I'm not sure how that makes sense
06:01:49 <Cale> :t Data.Traversable.forM_
06:01:51 <lambdabot> Not in scope: ‘Data.Traversable.forM_’
06:02:19 <Cale> :t Data.Traversable.forM
06:02:20 <lambdabot> (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
06:02:49 <merijn> oh, right
06:02:55 <bernalex> Cale: there's a Foldable one
06:02:59 <Cale> right
06:03:00 <bernalex> :t Data.Foldable.forM_
06:03:01 <lambdabot> (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
06:03:06 <merijn> I keep forgetting those stupid monomorphic versions in prelude
06:03:10 <bernalex> thanks
06:03:20 <Cale> merijn: Not Prelude, Control.Monad
06:09:01 <vektor> Hey folks. I dunno how to deal with numerical types, sometimes... downfall of having such an awesome type system.
06:10:42 <vektor> http://lpaste.net/108113
06:11:03 <vektor> sequenceRatio trifibseq won't work...
06:11:44 <merijn> vektor: It's not that bad, it's a bit annoyingly explicit at times, but after you spend a week hunting for a silent coercion error in C you'll quickly prefer explicitness over bug hunting ;)
06:11:51 <vektor> No instance for Fractional Integer arising from use of sequenceRatio
06:11:54 <merijn> vektor: Well, first off, what are the types of everything supposed to be?
06:12:06 <vektor> I do prefer the explicitness over the bugs
06:12:28 <merijn> vektor: / is only defined on Fractional values, but GHC is inferring (from somewhere not in your pasted example) that you want to use Integer
06:12:42 <merijn> vektor: Integer is not an instance of the Fractional typeclass, so / doesn't work on it
06:13:20 <vektor> div is the cutoff version of /, right?
06:13:31 <merijn> vektor: But without type signatures/surrounding code it's impossible to tell where the integer restriction comes from
06:13:41 <merijn> vektor: div does integer division, yes.
06:13:46 <vektor> Well, I definitely need some form of floating point for the end result. The trifibseq can be whatever GHC needs
06:13:54 <merijn> I think it truncates towards zero, but you'd have to check docs
06:14:30 <merijn> vektor: Try adding "sequenceRatio :: [Float] -> [Float]"?
06:14:30 <vektor> I definitely need decimals.
06:14:47 <ClaudiusMaximus> i think div truncates towards -Infinity because mod is always non-negative
06:14:52 <merijn> Also, sequenceRatio has a potential crash (which GHC would warn you about if you used -Wall to compile)
06:15:19 <merijn> ClaudiusMaximus: Ah, yeah, docs agree with you
06:15:31 <vektor> can't match int with float now... I guess I need the same for trifibseq
06:15:42 <vektor> I'm GHCi'ing atm.
06:15:48 <vektor> what's that crash?
06:16:27 <merijn> vektor: One element lists :)
06:16:43 <merijn> vektor: Starting ghci with "-Wall" should have the same effect
06:17:01 <vektor> what does it do?
06:17:06 <vektor> the -Wall that is
06:18:15 <vektor> also, if float doesn't do it for me, I go with Double I asssume?
06:18:40 * hackagebot mono-traversable 0.6.1 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.6.1 (MichaelSnoyman)
06:18:42 * hackagebot parsers 0.12.1 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.12.1 (EdwardKmett)
06:18:44 * hackagebot conduit-combinators 0.2.8 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.8 (MichaelSnoyman)
06:19:25 <joebobjoe> hello
06:19:49 <ClaudiusMaximus> vektor: i think you're hitting the monomorphism restriction and defaulting to Integer, at least if you're entering definition by definition in ghci
06:19:51 <remdezx> Hello! How can I do something like (a -> Maybe String) which returns Just when 'a' is instance of Show?
06:20:25 <vektor> I load it from a hs file.
06:20:32 <vektor> Using :l that is
06:20:39 <merijn> vektor: -Wall = enable "all" warnings
06:20:50 <vektor> haha, ok. makes sense
06:21:43 <merijn> vektor: GHC will check that your pattern matches are exhaustive (i.e. they cover all cases)
06:21:52 <ClaudiusMaximus> vektor: oh, right - maybe put   test = sequenceRatio trifibseq  into the file too
06:22:19 <joebobjoe> I have a question about currying. if I have a type of kind *->*->* can i apply a function *->* and get *->*?
06:22:44 <BoR0> remdezx, myFn :: Show a => a -> Maybe String ?
06:22:47 <vektor> That would force ghci to assert that sequenceRatio trifibseq matches types, I assume? I guess test is not a keyword, it's just some random name?
06:22:55 <ClaudiusMaximus> yes
06:23:19 <Twey> joebobjoe: Apply a function * -> * to what?
06:23:40 <dibblego> joebobjoe: you apply a type constructor of kind *->*->* to a type to give a type constructor of kind *->*
06:23:50 <edwardk> wow i pushed out the wrong branch for trifecta to hackage. ouch
06:23:53 <remdezx> BoR0: yes, something like that
06:24:20 <Twey> joebobjoe: If you have a type function of kind * -> * -> * then you can apply it to the function *type* a -> b, which has kind *, and get a type function of kind * -> *
06:24:21 <merijn> edwardk: You accidentally pushed the branch with documentation? ;)
06:24:40 <edwardk> i accidentally pushed the branch using Text that wasn't finished rather than master
06:24:46 <Twey> joebobjoe: Is that what you're asking?
06:25:02 <edwardk> time for another major version bump =P
06:25:17 <Twey> joebobjoe: E.G. Either (Int -> String) :: * -> *
06:25:33 <Twey> Either :: * -> * -> *, Int -> String :: *
06:25:44 <edwardk> oh, maybe i didn't do that badly
06:26:01 <Twey> Hahah.
06:26:53 <joebobjoe> twey i see thanks
06:27:52 <Twey> joebobjoe: The important thing to note that a *value-level* function is not a *type-level* function: a -> b is already a complete type and doesn't need to be applied to a type variable
06:28:11 <Twey> joebobjoe: Though (->) itself is a type function of kind * -> * -> *
06:28:35 <Twey> Er, s/that a/that the type of a/
06:29:00 <vektor> Is there a decent numerical type for when double doesn't cope anymore?
06:31:38 <Twey> vektor: You mean, bigger than Double?
06:32:04 <vektor> yeah.
06:32:24 <merijn> CReal?
06:32:36 <merijn> Or whatever like that
06:32:41 <vektor> Whatever haskell defaults to when all I need is +, it's damn good. Soo big numbers
06:32:44 <merijn> It depends on what you're doing
06:32:44 <Twey> vektor: CReal will give you arbitrary-precision real numbers, but that might be overkill
06:32:56 <vektor> Well, doubles are overflowing to NAN
06:32:59 <Twey> You throw away computable numerical operations, for example
06:33:00 <Cale> also, its performance sucks
06:33:04 <merijn> NaN is not overflowing
06:33:10 <merijn> vektor: Double overflow to Infinity
06:33:18 <vektor> Derp, yeah
06:33:19 <Twey> vektor: NaN doesn't mean you overflowed, it means you performed an undefined operation
06:33:22 <merijn> vektor: NaN means you have a bug, dividing by 0 or something
06:33:25 <Twey> … other than division by zero
06:33:30 <Cale> > sum [1..1000] :: CReal
06:33:34 <Twey> > 1/0
06:33:34 <ClaudiusMaximus> and Double infinity/infinity -> nan  probably
06:33:34 <lambdabot>  mueval-core: Time limit exceeded
06:33:35 <lambdabot>  Infinity
06:33:36 <vektor> the ratio of them goes to hell after the single operands overflow
06:33:41 <Twey> > 0/0 -- this gives you NaN
06:33:41 * hackagebot trifecta 1.5.1 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-1.5.1 (EdwardKmett)
06:33:42 <lambdabot>  NaN
06:33:45 <merijn> > 0/0 :: Double
06:33:46 <lambdabot>  NaN
06:34:04 <vektor> > 100^10000
06:34:05 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
06:34:10 <vektor> > 100^10000 : Float
06:34:12 <lambdabot>  Not in scope: data constructor ‘Float’
06:34:15 <vektor> > 100^10000 :: Float
06:34:16 <lambdabot>  Infinity
06:34:19 <ClaudiusMaximus> > (1/0) / (1/0)
06:34:20 <lambdabot>  NaN
06:34:27 <vektor> > Infinity / Infinity :: Float
06:34:28 <lambdabot>  Not in scope: data constructor ‘Infinity’Not in scope: data constructor ‘Inf...
06:34:39 <vektor> well, that's what happened anyways...
06:34:46 <vektor> Do I need a package fro CReal?
06:34:59 <ClaudiusMaximus> perhaps you want Rational ?
06:35:27 <merijn> > (2 % 5) + (3 % 5)
06:35:29 <lambdabot>  1 % 1
06:36:06 <merijn> > 1 / 5 :: Ratio Int
06:36:07 <lambdabot>  1 % 5
06:36:25 <phaazon> woh!
06:36:40 <phaazon> I’ve just discovered the ICFP challenge!
06:36:42 <vektor> Those are barely readable.
06:36:51 <phaazon> is there any folks here doing it?
06:37:08 <merijn> vektor: They're arbitrary precision fractions, though :) It depends what you're doing with the computed values
06:37:42 <vektor> Well, right now I'm just fooling around. Which means I need a representation I can at least somehow grasp
06:38:09 <Twey> vektor: If you're going to be using rational numbers, use Rational
06:38:42 <vektor> Again, I can barely tell the value of a 100-digit numer / 100-digit number. Impractical
06:38:43 <Twey> vektor: (read the % as a division slash — like in a fraction)
06:38:47 <Twey> vektor: If you're going to be using ‘reals’, you probably want to approximate them with Double
06:38:47 <vektor> Double is better.
06:39:06 <Twey> vektor: That's just a presentation detail
06:39:20 <vektor> I mean, technically it is.
06:39:42 <steamboat> phaazon: reading it over now
06:39:59 <phaazon> I don’t have time for it, but next year I’ll try for sure!
06:40:15 <steamboat> phaazon: I'm not sure how much time I'm gonna put to it
06:40:20 <Twey> :t fromRat
06:40:21 <lambdabot> RealFloat a => Rational -> a
06:40:34 <Twey> > fromRat 532453425325345 % 65365432535354
06:40:35 <lambdabot>  No instance for (GHC.Show.Show a0)
06:40:35 <lambdabot>    arising from a use of ‘M308181497905630015122218.show_M3081814979056300151...
06:40:35 <lambdabot>  The type variable ‘a0’ is ambiguous
06:40:35 <lambdabot>  Note: there are several potential instances:
06:40:35 <lambdabot>    instance [safe] GHC.Show.Show
06:40:37 <steamboat> phaazon: but we'll see
06:40:39 <Twey> > fromRat $ 532453425325345 % 65365432535354
06:40:40 <lambdabot>  8.145795180615664
06:41:18 <Twey> vektor: But sure, if you want Double, use Double.  You'll only get NaN if you do something wrong.
06:41:34 <vektor> Or with insanely big numbers
06:41:42 <vektor> Dividing two infinities, for example
06:41:59 <Twey> > (1/0) / (1/0) :: Double
06:42:00 <lambdabot>  NaN
06:42:07 <Twey> I think that counts as doing something wrong
06:42:17 <Twey> But yes, Doubles are approximations
06:42:34 <Twey> Because your computer only has finite memory ☺
06:43:01 <vektor> In my case, it's not really wrong. I mean, what I'm doing is ridiculous anyways, but not wrong
06:43:07 <Cale> Well, and Doubles only have a tiny amount of that memory
06:50:37 <vektor> CReal is slower by a margin
06:51:58 <vektor> I assume that that the division is done in software?
06:53:13 <michaelt> vektor: oh yeah, the individual number is a function
06:53:25 <michaelt> vektor: I mean in CReal?
06:54:56 <int3__> we should have a vim plugin that auto-suggests the addition of imports
06:55:01 <int3__> and automates the removal of stale ones
06:55:40 <michaelt> vektor: have you seen cyclotomic? I think it's distinctly faster but much more limited.
07:03:05 <frerich> Hrm, documentation like "guard b is return () if b is True, and mzero if b is False." is not very helpful. It's an exact translation of the definition to english. I wish it had some examples on when/why you can use it.
07:05:08 <michaelt> frerich: intuitively if you have a line "guard $ len < 3000" in a do block, if it is false the rest is not run, if it is true its like writing throwing a  return () line in
07:06:37 <michaelt> > do {a <- Just 3 ; guard (a < 4); return (a*a)}
07:06:39 <lambdabot>  Just 9
07:06:47 <michaelt> > do {a <- Just 3 ; guard (a < 2); return (a*a)}
07:06:49 <lambdabot>  Nothing
07:08:03 <michaelt> frerich: the assertions in a list comprehension are sugar for 'guard'
07:08:22 <frerich> michaelt: Hmm, there's no MonadPlus instance for IO, i.e. in my case I'm in the IO monad but 'guard' wouldn't help here?
07:09:03 <frerich> Aaah, mzero as in 'a*0 = 0'?
07:09:44 <michaelt> frerich: right, I guess that's the analogy. if >> is multiplication, so to speak
07:09:52 <frerich> I.e. Nothing for Maybe, and the Monad instance for Maybe causes the whole rest to become Nothing
07:10:22 <michaelt> frerich: right you a Nothinglike thing in each IO a
07:10:35 <frerich> True.
07:15:24 <mbrock> you can always use MaybeT
07:15:30 <Sculptor> friday! hi!
07:18:02 <noobie_> Hello all, I'm having this strange issue with ghc
07:18:11 <michaelt> noobie_: but what is it?
07:18:13 <Sculptor> don't we all
07:18:21 <noobie_> I installed cassy (a cassandra lib)
07:18:36 <noobie_> when I do import Cassandra_Types in ghci it runs fine
07:18:47 * hackagebot classy-prelude 0.9.3 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.9.3 (MichaelSnoyman)
07:18:49 * hackagebot classy-prelude-conduit 0.9.3 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.9.3 (MichaelSnoyman)
07:18:51 * hackagebot classy-prelude-yesod 0.9.3 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.9.3 (MichaelSnoyman)
07:19:11 <noobie_> however, when I write that in a file, and try to compile using ghc, it says not found
07:19:20 <noobie_> Could not find module `Cassandra_Types'
07:19:34 <noobie_> I installed it using cabal with configure --user flag
07:20:04 <noobie_> Is there a way I can ask ghc to look for user packages? Searched google couldn;t find anythiong useful
07:20:16 <michaelt> import Cassandra.Types ?
07:20:28 <noobie_> import Cassandra_Types*
07:21:17 <michaelt> import Database.Cassandra.Types or is this your own module
07:21:44 <noobie_> It is not my own module, installed from cabal
07:22:14 <michaelt> If I understand you should be writing "import Database.Cassandra.Types"
07:22:19 <noobie_> @michaelt gimme few mins, lemme check if that import works
07:22:19 <lambdabot> Unknown command, try @list
07:22:33 <noobie_> @ michaelt gimme few mins, lemme check if that import works
07:22:40 <michaelt> ok
07:23:04 <michaelt> people just write michaelt or michaelt: to address each other since @xyz is reserved
07:23:51 <noobie_> michaelt: got it :)
07:23:59 <michaelt> noobie_: ah, good
07:24:03 <Twey> Or rather, @xyz is reserved because people just write michaelt: to address each other
07:24:19 <michaelt> Twey: yeah, I wasn't sure how to put it best
07:25:26 <noobie_> michaelt: you were right Database.Cassandra.Types is the right way, thanks!
07:25:55 <zzbacon> hm, could haskell be used to implement a db like cassandra? or is that outside it's domain
07:26:44 <noobie_> zzbacon: cassandra as far as I know is built using java, uses thrift layer
07:30:09 <michaelt> I don't know if anyone has attempted to implement a database system directly in haskell; there are things like acid-state http://hackage.haskell.org/package/acid-state though that approach is hardly going e.g to generate reports etc.
07:31:21 * merijn repeats his "acid-state is not a database" mantra
07:32:25 <michaelt> merijn: yes, the similarities are remote
07:33:02 <merijn> Don't get me wrong, acid-state is really cool and awesome, but I think that calling it a database is not really honest
07:33:46 <michaelt> merijn: yes, note that this follows from the first part of my sentence, but yes it should be emphasized
07:34:24 <zzbacon> has there been any large scale projects in haskell on "par" with something like cassandra, or is it generally used in smaller scale projects?
07:34:34 <merijn> michaelt: But no, I don't think anyone has attempted to implement a database system directly in haskell. It'd be hard to compete with things like postgres
07:34:39 <michaelt> yes
07:34:59 <merijn> zzbacon: Some of the banks using haskell have codebases measured in hundreds of thousands, if not millions of lines of haskell
07:35:53 <merijn> zzbacon: I read a blogpost by a guy whose company had an ActionScript 3 compiler written in haskell of about 100k lines of code, so there are definitely lots of large scale haskell codebases, a lot of them just aren't closed source
07:37:00 <michaelt> zzbacon: what kind of thing are you thinking of?  It's true most open source haskell is libraries.
07:37:21 <zzbacon> just considering haskell and it's adoption
07:37:35 <zzbacon> it seems to be gaining more interest, but a large open source project could be a real boon
07:37:53 <Hodapp> zzbacon: Why are you concerned with adoption?
07:38:03 <zzbacon> more adoption, more jobs :P
07:38:21 <merijn> zzbacon: We have a large open source project, it's called GHC :>
07:41:37 <Hodapp> zzbacon: More jobs, more crappy applicants.
07:42:05 <Ankhers> Hodapp: PHP came to mind when you said that...
07:42:35 <zzbacon> in my area: Haskell -> 0 results, Java -> 1400 results
07:42:42 <zzbacon> a marginal improvement would be nice :p
07:42:47 <mzero> does some standard package have an instance of Num for Num a => (a, a)  ?
07:44:45 <noobie_> mzero: learnt this in tutorial, try hoogle
07:45:11 <noobie_> http://www.haskell.org/hoogle/
07:45:25 <mzero> noobie_: Hoogle can't search for instances
07:45:58 <noobie_> mzero: that's something new, lemme read on it, thanks
07:46:56 <michaelt> mzero: http://hackage.haskell.org/package/NumInstances for example, dunno
07:47:15 <mzero> ha - of course it would be Conal's package!
07:48:20 <mzero> thanks
07:54:32 <lsdafjklsd> How can I grab the first two elements of a list via pattern matching, like this? someFn (x:y:xs) = ...
07:54:54 <joshc> lsdafjklsd: yes.
07:55:11 <lsdafjklsd> ok, just trying to get this working: doubleEveryOther (x:z:xs) = z:doubleEveryOther xs
07:55:20 <Ankhers> lsdafjklsd: Though, that assumes there are two+ elements in the list.
07:55:24 <lsdafjklsd> [3,7*** Exception: week1.hs:11:1-49: Non-exhaustive patterns in function doubleEveryOther
07:55:31 <lsdafjklsd> ahh
07:56:44 <Ankhers> You will want to have a definition for an empty list, and a single element in the list.
07:56:48 <frerich> lsdafjklsd : As it is, that function seems to be more like 'drop every other'
07:56:56 <lsdafjklsd> I'm just doing a test
07:57:01 <lsdafjklsd> trying to eventually double every other
07:57:14 <lsdafjklsd> the error is gone now
07:57:17 -lsdafjklsd(~lsdafjkls@38.104.247.242)- doubleEveryOther          :: [Integer] -> [Integer]
07:57:17 -lsdafjklsd(~lsdafjkls@38.104.247.242)- doubleEveryOther []       = []
07:57:17 -lsdafjklsd(~lsdafjkls@38.104.247.242)- doubleEveryOther [x]      = [x]
07:57:19 -lsdafjklsd(~lsdafjkls@38.104.247.242)- doubleEveryOther (x:z:xs) = z:doubleEveryOther xs
07:57:52 <Ankhers> based on the name, I would doubleEveryOther [x] = []
07:58:36 <lsdafjklsd> yes
07:59:00 <Ankhers> lsdafjklsd: I would do http://lpaste.net/108118
07:59:04 <Ankhers> basically the same.
07:59:21 <Ankhers> actually... replace (x:xs) with _
07:59:46 <lsdafjklsd> that will match anything that's not x:y:xs right
07:59:49 <lsdafjklsd> thats better
07:59:54 <joshc> yeah, you still need to handle []
08:00:07 <Ankhers> http://lpaste.net/108119
08:00:09 <Ankhers> that
08:00:14 <lsdafjklsd> I'm working through the cis194
08:00:19 <lsdafjklsd> beginner haskell class
08:00:47 <rola> lsdafjklsd, some people in #haskell-beginners are also going through it
08:00:53 <lsdafjklsd> ah
08:00:54 <lsdafjklsd> ya
08:01:00 <lsdafjklsd> probably more appropriate
08:08:34 <xificurC> haywood: 2 things - 1) you lose every odd element because you don't use x; 2) you are doubling every second element from the left but the assignment says from the right. This works the same for lists with odd length but not with even
08:08:50 <haywood> I'm working on that now
08:08:51 <haywood> hehe
08:09:17 <haywood> I've got it working, except it doesnt work from the right
08:09:57 <haywood> (:) is right associative right? I forgot what I can do to make it left
08:10:39 <haywood> doubleEveryOther (xs:z:x) = doubleEveryOther xs : (z * 2) : x
08:10:59 <haywood> I guess that will work
08:11:58 <NikolajK> What does a function look like which prints two different things to the terminal, but avoids "do"?
08:13:05 <geekosaur> putStrLn "thing 1" >> putStrLn "thing 2"
08:13:06 <monochrom> it may use >>
08:13:09 <geekosaur> see also: @undo
08:13:27 <geekosaur> do notation has a formulaic translation to the underlying operations
08:13:45 <zzbacon> printEm = putStrLn "bacon" >>= (\() -> putStrLn "bacon")
08:13:53 <xificurC> haywood: that still wont work, xs is now the first element (head) of the list, z the second and x the rest. This will only double the second element (still from left) and rebuild the list
08:13:56 * hackagebot LambdaHack 0.2.14 - A roguelike game engine in early development  http://hackage.haskell.org/package/LambdaHack-0.2.14 (MikolajKonarski)
08:14:30 <Pythonfant> any idea where I could get help concerning an xml-conduit problem? I asked here several times but didn't receive a response or should I just ask again in random intervals in the hope that someone comes around and can help me?
08:14:32 <NikolajK> I was wondering about how to translate it, as the translations to >== always involved somehting along the lines of "x <- mx", which is missing for prining
08:15:06 <monochrom> _ <- putStrLn "thing 1"
08:16:30 <zzbacon> random intervals
08:16:35 <supki> Pythonfant: I'd try stackoverflow
08:16:44 <Pythonfant> supki: ah good idea, thx
08:18:41 <NikolajK> what's >> in terms of other operations? does it have a name like "bind", "return" etc?
08:18:52 <haywood> :P http://lpaste.net/108121
08:21:21 <monochrom> x >> y  =  x >>= \_ -> y
08:21:40 <frerich> haywood: I suspect one could also define 'doubleEveryOther' without any recursion by using 'zipWith' and 'cycle'...
08:22:08 <haywood> yessir
08:22:31 <haywood> thank you for the hint :D
08:22:58 <haywood> I'm not used to thinking recursively, so just wanted to try something
08:24:15 <zereraz> hello people, can a function have 2 return types, like either string or int
08:24:34 <zereraz> like in 1 case its a string in other case its int
08:24:41 <frerich> zereraz: 'Either String Int' would be a valid type.
08:24:46 <NikolajK> monochrom: isn't \_ -> y the constant function returning y? Does the value of x >>= \_ -> y depend on x then??
08:24:55 <n-dolio> @type \n -> if n < 5 then Left "hello" else Right (5 :: Int)
08:24:55 <lambdabot> (Ord a, Num a) => a -> Either [Char] Int
08:25:02 <zereraz> frerich: ok thanks
08:25:08 <monochrom> yes. yes.
08:25:45 <michaelt> zereraz: in Text.Read, readEither :: Read a => String -> Either String a , according to whether it parses
08:26:29 <michaelt> zereraz: otherwise it gives you back the input String. Is that an example?
08:26:32 <zereraz> michaelt: so I could use a right
08:26:45 <zereraz> 'a'
08:27:09 <zereraz> what do you mean example?
08:27:10 <NikolajK> monochrom, but "x >>= f = (join . (fmap f)) x". So if f is constant, then fmap f is too and join (fmap f) is as well and x doesn't have an effect
08:27:45 <n-dolio> f being constant doesn't imply that fmap f is constant.
08:27:52 <michaelt> zereraz: well, readEither "12" =  Right (12 ::Int); readEither "x12" = Left "x12"; so you pattern match to decide what to do with the result
08:27:52 <monochrom> your theory is refuted by simple experiments
08:28:16 <NikolajK> ah okay
08:28:24 <NikolajK> foolish me
08:28:28 <chrisdone> theories tend to be things that have been confirmed by years of sophisticated experiments ;)
08:29:24 <zereraz> michaelt: I don't understand the right and left thing
08:29:27 <kstt> Hi : could someone help me to work around this bug please : https://github.com/gtk2hs/gtk2hs/issues/26
08:31:23 <michaelt> zereraz: well suppose your program gets user input you might write main = putStrLn "welcome to number squarer" >> loop; loop = do {s <- getLine ; case readEither s of Right n -> print (n*n); Left s -> putStr $ s ++ " is not a number"}
08:32:33 <kstt> This bug makes GTK librairies failing to build with Cabal 1.20
08:32:33 <zereraz> michaelt: we are able to do this because of readEither?
08:32:33 <joshc> NikolajK: consider the (State s) monad, where 'x' can impact/change the state in some way, and 'y' acts on the state
08:32:42 <zereraz> michaelt: this won't work with print
08:32:48 <zereraz> right
08:32:51 <zereraz> ?
08:34:03 <NikolajK> in a monad, not every map a->mb is for the form return f, for some f::a->b, right? What are some counterexamples?
08:34:33 <monochrom> hGetLine cannot be return . f
08:34:42 <n-dolio> const Nothing
08:34:45 <NikolajK> right
08:35:24 <michaelt> zereraz: try this, http://lpaste.net/7418819124890959872 there's something wrong with buffering, or else with the implementation of readEither, but it sort of works
08:35:34 <zereraz> what is wrong with this type signature ? countTill :: Int -> Int -> Either String (IO Int)
08:35:57 <zereraz> michaelt: I have never used right and left
08:36:03 <allsystemsarego> how can I make Data.Sequence.index return a Maybe instead of bombing out?
08:36:50 <monochrom> however, "g :: forall m. Monad m => A -> m B" is forced to be return . f, since the user can now plug in m = Identity
08:36:51 <michaelt> zereraz: oh it behaves 'badly' because I wrongly expected the Left value to be the input string, but it's the error message ghc would have given.
08:37:24 <joshc> zereraz: what is countTill supposed to do?
08:37:31 <zereraz> michaelt: what is wrong iwth my type signature countTill :: Int -> Int -> Either String (IO Int)
08:38:05 <zereraz> joshc: it is supposed to count between 2 numbers if the number is even then it prints "even" else it prints the odd number
08:38:22 <monochrom> equivalently, from the author's point of view, to fulfill "forall m. Monad m =>" the author cannot use any IO stuff, any Maybe stuff, any [] stuff... only the methods of the Monad class
08:38:24 <zereraz> so string and Int
08:38:49 <n-dolio> allsystemsarego: Looks like you can't. I guess you just have to use splitAt and viewl.
08:39:02 <n-dolio> Kind of an oversight.
08:39:05 <allsystemsarego> n-dolio, thanks
08:39:15 <michaelt> zereraz: that is a legitimate signature, you you presumably want countTill :: Int -> Int ->  IO (Either String Int)
08:39:36 <zereraz> michaelt: ok that makes sense, i'll try that
08:39:45 <monochrom> Data.Sequence was written long before Maybe became fashionable
08:39:56 <monochrom> back then, partial functions were fashionable
08:40:34 <michaelt> zereraz: the second of these http://lpaste.net/7418819124890959872 is the program I meant, for what it's worth.
08:41:45 <SrPx> Is there something like d3.js for hs?
08:41:46 <zereraz> michaelt: ok I understood, its a thing that will go in right if number else it will print not a number
08:41:47 <haywood> frerich: can't figure out a solution with zipWith and cycle :P
08:42:02 <michaelt> zereraz: right
08:43:25 <NikolajK> so when I write
08:43:25 <NikolajK> putStrLn "thing 1" >> putStrLn "thing 2"
08:43:25 <NikolajK> am I write that I create a single value which is the printing of both things? I.e. when does the computer do the computations? At first for both, or is there computation after the first returning of "thing 1" ?
08:44:00 * hackagebot nc-indicators 0.3 - CPU load and memory usage indicators for i3bar  http://hackage.haskell.org/package/nc-indicators-0.3 (GergelyRisko)
08:44:28 <chrisdone> when you evaluate it, you get an IO () value, when you execute the IO value it will print the things in sequence
08:44:44 <glguy> You create a single value of type IO () that if executed would print the first anad then the second. The only way to execute of one those is to sequence it together with other stuff and call it "main"
08:45:11 <NikolajK> k, thanks
08:47:57 <kstt> Can we get in touch with people from Cabal here or on an other chan ?
08:48:23 <chrisdone> if they're around, yeah
08:51:00 <chrisdone> does anyone have experience with shadowing stdout and stderr in ghc?
08:51:14 <chrisdone> i saw someone here post about it ages ago but can't remember who
08:51:26 <stolaruk> If I do "replicateM 2 $ newTVarIO IntMap.empty", will I get 2 different TVars and 2 different tables?
08:51:44 <chrisdone> stolaruk: yup
08:51:56 <stolaruk> rock on
08:52:07 * chrisdone proceeds to rock
08:52:34 <kstt> chrisdone: thank you. This GTK/Cabal issue is driving me mad : https://github.com/gtk2hs/gtk2hs/issues/26
08:53:37 <joshc> chrisdone: I suspect you could do some trickery with System.Posix.dupTo
08:54:31 <chrisdone> joshc: seems so, i was just reading http://stackoverflow.com/questions/4832603/how-could-i-temporary-redirect-stdout-to-a-file-in-a-c-program
08:54:34 * chrisdone checks out System.Posix
08:59:02 <zereraz> this is my program http://lpaste.net/108122 its not working
09:00:13 <chrisdone> zereraz: haskell is not smart enough to do that
09:00:24 <michaelt> zereraz: on line 14 you have 'then n' which is an Int; on line 15 'else "even"' which is a string
09:00:43 <zereraz> I put an Either
09:01:05 <chrisdone> it's the `if' which is bad
09:01:14 <chrisdone> > if True then 1 else "hi"
09:01:16 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
09:01:16 <lambdabot>    arising from the literal ‘1’
09:01:17 <zereraz> chrisdone: not smart enough to do what?
09:01:20 <chrisdone> > if True then 1 :: Int else "hi"
09:01:21 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
09:01:21 <lambdabot>              with actual type ‘[GHC.Types.Char]’
09:01:37 <zereraz> I tried that
09:01:41 <zereraz> I did n::Int
09:01:42 <chrisdone> zereraz: to realise that both String and Int are instances of Show
09:01:44 <zereraz> it did not work
09:01:49 <chrisdone> zereraz: yes, see the compile error
09:02:03 <chrisdone> both if branches need to be the same type
09:02:13 <chrisdone> > if True then show 1 :: Int else "hi" -- for example
09:02:15 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’ with ‘GHC.Types.Int’
09:02:15 <lambdabot>  Expected type: GHC.Types.Int
09:02:15 <lambdabot>    Actual type: GHC.Base.StringCouldn't match expected type ‘GHC.Types.Int’
09:02:15 <lambdabot>              with actual type ‘[GHC.Types.Char]’
09:02:18 <chrisdone> uh
09:02:21 <chrisdone> > if True then show (1 :: Int) else "hi" -- for example
09:02:23 <lambdabot>  "1"
09:02:41 <zereraz> so I must put a show
09:02:50 <zereraz> then what is the point of Either
09:03:39 <chrisdone> zereraz: in "do return 'a'; return ()" what is the type of the whole expression?
09:04:14 <zereraz> Either Char IO , I think
09:04:21 <zereraz> I learnt about Either here only
09:04:49 <dwcook> zereraz, to use Either, you need to explicitly tag which is which. For an Either Int String, pass the Int to Left and the String to Right, e.g., Left 22, Right "hey"
09:05:09 <zereraz> is left and right only for cases?
09:05:11 <athan> Is there an easy way to invert theoretically bijective functions? Is there a typeclass or something?
09:05:39 <chrisdone> zereraz: Either is just a normal data type with normal constructors, Left and Right
09:05:50 <chrisdone> > if True then Left 'a' else Right ()
09:05:51 <lambdabot>  Left 'a'
09:05:53 <chrisdone> > if False then Left 'a' else Right ()
09:05:54 <lambdabot>  Right ()
09:05:58 <zereraz> oh, left and right are part of either
09:05:58 <chrisdone> :t if False then Left 'a' else Right ()
09:05:59 <lambdabot> Either Char ()
09:06:03 <chrisdone> @src Either
09:06:04 <lambdabot> Source not found. Take a stress pill and think things over.
09:06:08 <ReinH> athan: you can construct an isomorphism in the lens library
09:06:12 <chrisdone> ew, lambdabot sucks
09:06:15 <zereraz> so now I just have to put Left and Right
09:06:19 <chrisdone> yeah
09:06:20 <joshc> using "show" in your function versus returning an Either String Int is a design decision, effectively chosing one or the other is an answer to the question "who's responsibility is it to handle both of these cases?" in the case of "show", you handle it directly in your function, using Either String Int means the caller must handle it
09:07:16 <zereraz> its working now, I will use Either after I read up more on it
09:07:22 <zereraz> thanks people
09:07:31 <zereraz> one last thing
09:07:41 <zereraz> I am trying to implement a prime check function
09:07:46 <athan> ReinH: Hmm! Perfect, thank you! I'm just doing some haskell encoded logic practice, and am stuck proving isomorphic composition to be distributive of it's inverse ((f.g)^-1) == (f^-1).(g^-1), and couldn't help but think of some kind of reverse lookup table mechanism. Thanks!
09:08:08 <zereraz> what I am going to do is first check the number only if its odd
09:08:33 <ReinH> athan: if they form a group you can do that too / instead
09:08:37 <zereraz> if its odd then create a list from that number
09:08:58 <zereraz> to the floor(number^1/2)
09:09:08 <athan> ReinH: Hmm! Interesting, I'll keep that in mind
09:09:11 <zereraz> then check if any part of list divides
09:09:17 <zereraz> if yes
09:09:22 <zereraz> then its not prime
09:09:28 <zereraz> is this implementation fine?
09:09:42 <stolaruk> Ever find you have to write a bunch of import statements in your module just to be able to write the type signature of a top level def? Any way around this?
09:10:19 <zereraz> is there an easier or better way in haskell to find primes?
09:10:46 <ReinH> athan: invertible subsets of ensomorphisms form a group, sometimes that group is isomorphic to some other group, and that knowledge is useful for reasoning about your program.
09:11:06 <ReinH> @Google Haskell prime numbers
09:11:06 <lambdabot> Maybe you meant: hoogle google
09:11:13 <ReinH> heh thanks
09:11:25 <ReinH> @google Haskell prime numbers
09:11:26 <lambdabot> http://www.haskell.org/haskellwiki/Prime_numbers
09:11:26 <lambdabot> Title: Prime numbers - HaskellWiki
09:11:33 <athan> ReinH: ensomorphism? Very interesting
09:11:39 <zereraz> what about my implementation
09:11:43 <TallerGhostWalt> on the last haskell cast (which was awesome) Ocharles mentioned a query library... Is that publically available ?
09:11:50 <SrPx> I understand most agree langs such as Idris/Agda are not really practical yet, but I don't see why. Is there an intuitive explanation why system F is more practical than martin lof for our daily programming?
09:11:55 <ReinH> a function a -> a is an endomorphim.
09:11:57 <simukis_1> @google genuine prime sieve
09:11:58 <lambdabot> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
09:11:59 <lambdabot> Title: The Genuine Sieve of Eratosthenes
09:11:59 <athan> ReinH: Something like an automorphism?
09:12:16 <SrPx> ie, why are dependently typed languages "hard"?
09:12:18 <zereraz> ok thanks
09:12:26 <ReinH> And automorphism is endo and ISO
09:12:27 <monochrom> system F is not practical either
09:13:04 <dzhus> Can I force "No explicit method or default declaration for…" warnings to be actual errors (without -Werror)?
09:13:08 <SrPx> I mean haskell type's system vs dependently typed languages. We all know haskell is pretty practical (right?) but nobody in #agda would say they'd attempt to do game programming in agda, for example.
09:13:33 <ReinH> athan: for example, functions that rotate a 2048 board so you can slide it in one direction and rotate back from a group. this group is isomorphic to the group of symmetries of the square.
09:13:36 <athan> ReinH: Ahh I see, so with that property you could reason about your structure in a ton of different fashions, that's really cool
09:14:21 <ixmatus> I'm newtyping some standard types, like so: newtype Aid = Aid C8.ByteString, how do I automatically inherit (Show, Eq, Ord, etc...) from ByteString without typing out the deriving clause?
09:14:23 <ReinH> athan: so you can write out that group structure: data Dih8 = R0 | R1 ...
09:14:36 <dzhus> ixmatus: see extension GenericNewtypeDeriving
09:14:36 <monochrom> haskell type system is system F plus arbitrary recursion.
09:14:38 <athan> ReinH: Ahh!
09:14:43 <ixmatus> +1 dzhus thanks
09:14:47 <ReinH> athan: and then a group homomorphism to describe your functions.
09:14:52 <monochrom> or rather, haskell type system is like system F plus arbitrary recursion
09:15:20 <ixmatus> GeneralizedNewTypeDeriving
09:15:23 <dzhus> yep
09:15:39 <athan> ReinH: This is all starting to come together :) Thank you for your help
09:15:53 <ReinH> like: R0 = id, M1 = map reverse, D1 = transpose, etc
09:15:53 <phaskell> M1: Datadog metrics on Monitor.h.o - https://phabricator.haskell.org/M1
09:15:54 <phaskell> D1: Add LICENSE and update README.md - https://phabricator.haskell.org/D1
09:16:25 <ReinH> athan: then your board turning thing is a group conjugation:
09:17:17 <ReinH> move Up = tr R1 . slide . tr (invert R1)
09:18:04 <ReinH> where tr :: Dih8 -> Board -> Board is your homomorphism.
09:19:49 <chrisdone> ohhhh
09:20:26 <chrisdone> joshc: trying this out https://hackage.haskell.org/package/system-posix-redirect
09:20:53 <chrisdone> do putStrLn "Do"
09:20:59 <chrisdone>    redirectStdout (putStrLn "Rey")
09:20:59 <chrisdone>    putStrLn "Me"
09:20:59 <chrisdone> →
09:20:59 <chrisdone> Do
09:21:00 <chrisdone> Me
09:21:04 <chrisdone> \o/
09:21:28 <ion> Doy Rey Mey
09:21:44 <athan> ReinH: Very cool. What other example applications do you have experience with? *drooling* (you don't have to if it's a waste of your time, I just love to hear about industry applications for abstract algebra / c.t.)
09:24:14 <ReinH> athan: you can use this to solve rubix cubes
09:24:36 <n-dolio> The very competitive rubix cube solving industry. :)
09:24:39 <ReinH> athan: a surprising number of things form groups
09:24:41 <athan> ReinH: And anything backtracable, correct?
09:24:41 <ReinH> n-dolio: :p
09:24:43 <athan> man...
09:24:45 <athan> too cool
09:25:13 <ReinH> athan: groups are monoids with inverses
09:25:39 <athan> ReinH: Groupoid is one with commutativity too, right?
09:26:08 <n-dolio> Groupoid has two different meanings.
09:26:15 <athan> ahh'
09:26:15 <n-dolio> But neither is that, I think.
09:26:16 <rio> a group with commutativity is an abelian group
09:26:25 <ReinH> a groupoid used to mean a semigroup
09:26:28 <athan> rio: There you go, sorry I'm still new to this :S
09:26:35 <athan> hmm
09:26:36 <ReinH> now it more usually means a category where arrows have inverses
09:26:46 <athan> hmm
09:27:38 <chrisdone> oh this is gonna be so legit
09:27:45 <dropdrive> I have a question about http://stackoverflow.com/a/24711334: How can we "statically determine the set of filenames that will be modified" given "copy x y :: IOA () ()"?
09:27:51 <ReinH> athan: algebra in general can be used for program derivation and optimization
09:27:51 <n-dolio> Category theory people tend to use -oid as a suffix to mean a category version of an abstract algebra concept.
09:27:58 <ReinH> athan: see Richard Bird's stuff
09:28:00 <n-dolio> Although that doesn't always work.
09:28:05 <ReinH> n-dolio: right
09:28:14 <ReinH> monoidoid
09:28:36 <athan> ReinH: That's the feeling that I've been getting
09:28:38 <ReinH> He even wrote a book called Algebra of Programming
09:28:47 <rio> well in category theory a group is a groupoid with one object
09:28:51 <athan> n-dolio: Hahaha, awesome I'll remember that
09:29:00 <ReinH> rio: right
09:29:23 <athan> :O
09:29:58 <ReinH> Most people are probably more familiar with his Pearls of Functional Algorithm Design or Introduction to FP with Haskell, both of which are great books
09:30:16 <n-dolio> Algebra of Programming is pricey.
09:30:20 <n-dolio> Since it's not in print.
09:30:21 <ReinH> It is :(
09:30:35 <ReinH> But it's so good. Maybe your library can get a copy.
09:30:50 <athan> ReinH: I think I have pearls!
09:31:18 <ReinH> The sudoku chapter in Pearls is one of my favorites
09:31:37 <ReinH> it doesn't implicitly use group structure but it does conjugate over an isomorphism
09:31:46 <ReinH> (the isomorphisms happen to be involutions)
09:32:31 <joshc> chrisdone: it's interesting that the library explicitly flushes libc's io buffer...I guess it's assuming that the haskell runtime isn't maintaining it's own io buffers and instead is using libc's
09:32:47 <athan> is it common practice to reason about a function's one-to-one-ness, onto-ness, etc. and other logical properties in curried form? Ie: instead of segregating domain and codomain, you could perform set-theoretic stuff on the A x B tuples?
09:33:35 <simcity2000> when it comes to convention in importing packages, is it better to default to qualified or non-qualified imports?
09:34:07 * hackagebot servant 0.1 - A library to generate REST-style webservices on top of scotty, handling all the boilerplate for you  http://hackage.haskell.org/package/servant-0.1 (AlpMestanogullari)
09:34:08 * hackagebot servant-pool 0.1 - Utility functions for creating servant 'Context's with "context/connection pooling" support  http://hackage.haskell.org/package/servant-pool-0.1 (AlpMestanogullari)
09:34:10 * hackagebot servant-postgresql 0.1 - Useful functions and instances for using servant with a PostgreSQL context  http://hackage.haskell.org/package/servant-postgresql-0.1 (AlpMestanogullari)
09:34:13 * hackagebot servant-response 0.1 - Machinery to express how servant should turn results of database operations into proper JSON-encodable response types  http://hackage.haskell.org/package/servant-response-0.1 (AlpMestanogullari)
09:34:14 * hackagebot servant-scotty 0.1 - Generate a web service for servant 'Resource's using scotty and JSON  http://hackage.haskell.org/package/servant-scotty-0.1 (AlpMestanogullari)
09:34:48 <ReinH> athan: well, reasoning about functions on sets sometimes involves the definition of sets, which is usually given in terms of those tuples ;)
09:34:50 <chrisdone> joshc: i'm copying the code into my project so i can patch it, i need to be able to access incoming stdin/stderr as it arrives in the action =)
09:34:58 <ReinH> But I'm not sure if people do it explicitly very much
09:35:07 <ReinH> er, the definition of functions
09:35:41 <snyp> If I import a module in my module, and the imported module itself imports another module, is the other module's data types and functions visible through my module?
09:35:53 <snyp> s/through/from
09:36:59 <joshc> chrisdone: sounds like a useful thing for a shell to be doing
09:36:59 <athan> ReinH: Blast. Well, at least I'm getting somewhere... wherever that is.
09:37:01 <chrisdone> joshc: for my ghc-server project, in the REPL i want to be able to evaluate arbitrary IO actions but capture their stdout and stderr and exceptions separately from their return value, rather than the server just writing to its own stdout, it should send it back to emacs. i think this is as close as i'll get
09:37:03 <SrPx> Just wondering, is there any reason for not having a syntax sugar for (f <$> x <*> y <*> z...) ? Is it not common enough? Or not ugly enough?
09:38:07 <chrisdone> srpx: google idiom brackets
09:38:12 <ion> http://www.haskell.org/haskellwiki/Idiom_brackets
09:38:18 <orion> What is the formal name for <$> and <*>?
09:38:24 <pyon> orion: fmap and ap
09:38:42 <pyon> SrPx: I do not see how it is ugly, but, yeah, it is so common it could benefit from a little syntactic sugar.
09:38:46 <orion> thakn you pyon
09:38:49 <ion> Or just “map” and “ap” if it’s clear which map you’re referring to.
09:39:42 <ion> srpx: The link i gave talks about something else than idiom bracket sugar. Never mind.
09:40:45 <SrPx> ion: yea I was reading it but didn't understand what is the link
09:40:47 <ion> srpx: It defines something approximating such sugar, but done properly it should support things like (| Foo{ bar = action } |)
09:40:56 <SrPx> pyon: maybe `f (x,y,z)` ?
09:41:13 <ion> and (| action + action |)
09:41:14 <SrPx> hmm..
09:42:45 <joshc> chrisdone: how are you proxying back exceptions?  I'm assuming you're serializing them somehow?
09:44:01 <snyp> nvm. it doesn't
09:45:23 <xinming> Hi, Just curious, Since ghc is not able to be used on haskell x32 ABI, whatelse is the recommend implementation for ghc to use please?
09:45:32 <xinming> for learning purpose
09:45:34 <xinming> hugs?
09:45:36 <ReinH> athan: what people often do is reason about the algebraic properties of their functions: are they homomorphisms? What kind? etc
09:46:18 <ion> xinming: Anything running x32 should be able to run i386 stuff as well, shouldn’t it? There’s an i386 build.
09:46:37 <kstt> Well .. I have been programming for the last 10 years. Doing Haskell for the last 4 years. Working on a commercial project for the last 8 monthes. And I have spent half my week trying to build this stupid project on windows. This is a terrible experience.
09:46:54 <kstt> Really terrible.
09:46:58 <xinming> ion: Yes, But in gentoo, I don't know how to mix these libs.
09:47:11 <xinming> ion: but ignore me, I just find a way to use chroot to achieve it
09:47:37 <kstt> This is the first and the last time I sell a haskell-based software that must build on windows.
09:48:03 <orion> http://en.wikibooks.org/wiki/Haskell/Applicative_Functors <-- this article says, "(<*>) changes a function inside the functor to a function over values of the functor." What does "function *inside* the functor" mean?
09:48:05 <orion> Inside?
09:48:13 <athan_> ksst: ):
09:48:37 <n-dolio> I think the gtk bindings are pretty notorious for being hard to build on any system.
09:48:40 <athan_> orion: f(a->b) -> fa -> fb
09:49:01 <kstt> n-dolio: I swallowed that in a couple of hours actually.
09:49:07 <ion> orion: That sounds like pretty horrible language. This might be a better article: http://www.haskell.org/haskellwiki/Typeclassopedia
09:49:15 <benzrf> orion: i like to think of applicatives as a way of combining 2 functorial values together
09:49:20 <kstt> But bugs are creeping everywhere, I mean everywhere.
09:49:36 <nick_named> Is it possible to make a dependently typed list an instance of Monoid?
09:49:47 <benzrf> orion: one use case for combining two functorial values is, if one 'contains' a function and one 'contains' an argument, to squish them together and apply the func to the arg
09:49:47 <luite> chrisdone: the stderr/stdout Handle contains an MVar that has the actual Handle__, so you can overwrite it with an internal handle that does something other than writing to those streams
09:50:07 <kstt> I thought 10 times I'd be ok when fixing the blocking bug. And 10 times, I just met the next bug.
09:50:11 <benzrf> orion: i think it's a little simpler to say that Applicative allows you to write a function of type `f a -> f b -> f (a, b)'
09:50:39 <SrPx> (sorry I gtg, later I read the log)
09:50:42 <SrPx> see you
09:50:44 <benzrf> orion: (<*>) is equivalent to doing that, then fmapping '\(f, a) -> f a'
09:50:46 <kstt> linker error with missing symbol, Gtk mess, cabal mess ...
09:50:54 <kstt> and now, GHC is crashing !!!!
09:51:04 <kstt> yes, ghc just crashed
09:52:05 <chrisdone> joshc: because i'm evaluating the expression myself, if the expression throws an exception then i can catch it send it back to emacs. i won't be able to catch exceptions thrown in threads, but that's ok
09:53:18 <dfeuer> Hey all. Can RULES in one module use non-exported names in another module?
09:53:24 <kstt> should I use GHC 7.6 instead of 7.8 ?
09:53:37 <n-dolio> dfeuer: I wouldn't bet on that.
09:53:41 <monochrom> I like to look at this disappointment economically. how much money has been spent to get GHC to work on windows?
09:54:17 <benzrf> monochrom: too much, i'm sure
09:54:22 <frerich_> Does anybody here have experience with not using the Haskell Platform on OS X but rather using Homebrew to install ghc and cabal-install directly? Yay? Nay? Soso?
09:54:36 <int3__> n-dolio: well, Algebra is available online if you know where to look (not that I would normally advocate doing so, but since it's out of print...)
09:54:45 <monochrom> somehow, on the linux front, supply of bug fixers exceeds demand of bug fixing. and on the windows front, demand exceeds supply.
09:54:46 <dfeuer> n-dolio: I don't want to bet on it either. Unfortunately, list functions are spread across GHC.Base, GHC.List, and Data.List. So if I want to get my hands on mapFB in a scanr fusion rule, I have a problem.
09:55:22 <n-dolio> dfeuer: The easiest way to check is to write a rule and see if GHC complains.
09:55:53 <n-dolio> But it does type check stuff in the rules/pragmas.
09:56:00 <monochrom> why are so many people saying both "I want to use GHC on windows to make money" and "I want to pay $0 for it"?
09:56:06 <n-dolio> Like, if you write a specialize pragma, you have to have the types in it imported.
09:56:08 <dfeuer> n-dolio: one slightly insane thought would be to extract all the xxxFB names into a separate module.
09:58:22 <carter> monochrom: yup
09:58:32 <n-dolio> Why not just export them from the GHC modules?
09:58:43 <n-dolio> It's not like the modules people use just re-export the GHC modules wholesale.
09:58:57 <dfeuer> n-dolio: that's a better idea.
09:59:42 <joshc> chrisdone: yeah, I was more asking about the ghc-server <-> emacs interface; are you actually passing file descriptors back and forth? or is ghc-server multiplexing the stdout/stderr/exception streams from the evaluated code?
09:59:59 <joshc> chrisdone: feel free to point me to the source; it's Friday and I'm curious :)
10:00:22 <luite> chrisdone: or is the problem that non-haskelly things also write to stderr?
10:00:49 <chrisdone> joshc: https://github.com/chrisdone/ghc-server
10:01:05 <chrisdone> luite: it's that the server needs to send all stdout back over a socket back to emacs
10:01:10 <int3__> so I'm trying to write a function that writes some data into, say, the $HOME directory. retrieving $HOME is an IO operation, but I don't expect the result to change over the course of the program, so I'd like to cache it, instead of redoing that IO action each time I write some data. I was thinking (aside from unsafePerformIO) I could return a Reader monad that would get the $HOME directory from some other IO function like main; is that the b
10:01:10 <int3__> est way to do this? Of course, I'm aware that retrieving $HOME is an inexpensive operation, but I'm curious as to how this pattern is usually dealt with.
10:01:19 <dfeuer> Any idea how to figure out when writing dropWhile as build/foldr is a good idea? Because when it's bad it's really really bad.
10:01:34 <benzrf> :t build
10:01:35 <lambdabot>     Not in scope: ‘build’
10:01:35 <lambdabot>     Perhaps you meant ‘buildG’ (imported from Data.Graph)
10:02:32 <dwcook> int3__, depends, but the simplest thing would just be to bind it to a variable using the <- syntax and just reference it later in the same do expression.
10:02:43 <dwcook> do { home <- getHomeDirectory ; doStuffWith home }
10:03:02 <n-dolio> dfeuer: Rewriting back into dropWhile fixes some of them. But I think that's not really sufficient.
10:03:07 <int3__> dwcook: right, but then each time we want to doStuffWith, we also call getHomeDirectory, right?
10:03:09 <TheKing444> @undo do { home <- getHomeDirectory ; doStuffWith home }
10:03:09 <lambdabot> getHomeDirectory >>= \ home -> doStuffWith home
10:03:12 <dwcook> int3__, no.
10:03:41 <dario> @do getHomeDirectory >>= doStuffWith -- why not this?
10:03:41 <lambdabot> do { a <- getHomeDirectory; doStuffWith a}
10:03:44 <dwcook> int3__, the getHomeDirectory action gets executed precisely once, and then its result can be used as long as you want without performing the action again.
10:03:44 <chrisdone> joshc: similar to SLIME. emacs sends requests over a socket, the server replies with a stream of results until a final result or an error. compile warnings, stdout and stderr are all "results" (strings) that can be streamed back before the final result, which will be a resulting value, if there is one
10:04:02 <chrisdone> joshc: yes, it's proxying the data itself, i'm not passing handles
10:04:05 <michaelt> dfeuer: it seems its just defined in the obvious way in GHC.List Is there some other place to look?  There are no associated rules I can see.
10:04:08 <int3__> dwcook: I mean I want to write something like `f x = do { a <- getHomeDirectory; doStuffWith a x}`
10:04:33 <dwcook> int3__, ah, I see. So you want it to persist across calls to that function.
10:04:40 <luite> chrisdone: oh that's not too hard, get a Handle for that socket, then let (FileHandle _ mv1) = stdout; (FileHandle _ mv2) = socketHandle; readMVar mv2 >>= putMVar mv2
10:04:52 <int3__> dwcook: yup
10:04:53 <michaelt> dfeuer: wait, now I get you; the question is why not write it that way.
10:05:28 <chrisdone> luite: you can pattern match on a handle?
10:05:33 <dwcook> int3__, well one way would be to define the function such that a variable containing the home directory is already in scope, and just reference it from there.
10:06:04 <chrisdone> bbl, shopping
10:06:04 <dwcook> do { home <- getHomeDirectory ; let f x = doStuffWith home x ; … }
10:06:09 <rufs> Hi, I have just strangled myself with phantom types and feel there should be a more elegant solution than the partial functions I am forced to use now http://lpaste.net/6535767015540391936. I really feel like fOnValue should be possible to make
10:06:20 <dfeuer> n-dolio: I'll have to experiment some, I guess. I'm not sure it's always okay even when it does fuse.
10:06:29 <triliyn> int3__: you could also do something like XType -> IO (IO ())
10:06:54 <dwcook> int3__, you could also change that function to make it take in a directory and pass home when needed.
10:06:59 <vanila> rufs,
10:07:05 <luite> chrisdone: you need to import GHC.IO.Handle.Types
10:07:07 <dwcook> int3__, and in this case you could define it when home isn't in scope
10:07:11 <int3__> dwcook: yup, but then every function that logs some user data has to care about what the home directory is
10:07:31 <int3__> dwcook: an extra param is pretty much equivalent to returning Reader values, I guess.
10:07:31 <vanila> newtype FriendlyValue = FriendlyValue Value
10:07:32 <vanila> newtype EvilValue     = EvilValue Value
10:07:38 <dwcook> int3__, yes, it is actually :)
10:07:55 <dwcook> Reader a b is equivalent to a -> b
10:08:05 <dfeuer> michaelt: yeah. DropWhile can be written as a foldr (using a technique I saw in Hutton's tutorial paper) but if it doesn't fuse with something, it ends up copying the whole part of the list that's not dropped.
10:08:07 <luite> chrisdone: oh socket could be a DuplexHandle
10:08:22 <rufs> vanila: ?
10:08:34 <dwcook> int3__, I don't know what you mean about introducing a dependency though.
10:08:36 <n-dolio> dfeuer: Right. Cases like 'dropWhile p (filter (const True) longList)' will fuse, but it still might not be good.
10:08:37 <chrisdone> luite: well, it's not a direct proxy, i wouldn't want to pipe it directly to my socket
10:08:38 <vanila> in response to your paste
10:09:28 <chrisdone> luite: i'll try that if this dup2 approach is problematic, as this approach handles c libs too
10:09:32 <dfeuer> n-dolio: that's not a sane example....
10:09:50 <n-dolio> const True is a stand in for something that doesn't make the list appreciably shorter.
10:09:58 <michaelt> iisn't it a good example
10:10:37 <int3__> dwcook: I mean like, in an imperative language, we could write f x = log (compute x). but now we have to write f home x = log home (compute x). threading the extra 'home' value through code that just cares about logging 'to some fixed location' is kind of noisy
10:10:55 <dfeuer> Ah. Well, I don't think it's likely to be terribly much worse fused than with the usual definition. Have to benchmark.
10:11:11 <rufs> vanila, I don't see how that would solve my problem, I need to have functions that operate on types (Value a) where a is a phantom type
10:11:28 <luite> chrisdone: oh, hDuplicateTo would be nicer to use, no need for those low-level things
10:11:34 <n-dolio> dfeuer: Are there definitely cases where the fused version is better?
10:11:35 <vanila> I suggest a different solution
10:11:53 <vanila> what you have doesn't seem to be a good way to do this
10:12:02 <n-dolio> dfeuer: Maybe I should refine that. Cases that don't involve foldr (+) 0. :)
10:12:11 <luite> chrisdone: it even has redirecting stdout as an example in the haddock
10:12:50 <rufs> The example here is very bad
10:12:50 <triliyn> int3__: how would you know where the home directory is in your imperative snippet without getting it every time?
10:13:07 <dfeuer> n-dolio: I don't know how it's used in real programs, but it should play very nicely with map, I think.
10:13:10 <rufs> i think it makes more sense on my real problem
10:13:21 <triliyn> A global variable I guess?
10:13:25 <dibblego> use the reader monad
10:13:27 <int3__> triliyn: yup
10:15:05 <chrisdone> luite: i saw that, but didn't see a way to restore the handle afterwards
10:16:36 <dibblego> use pure-functional imperative programming to thread a pure value through pure computation by exploiting the reader monad
10:16:49 <luite> chrisdone: first hDuplicate stdout
10:16:51 <rufs> Since I have a lot of functions that operate on my Value type, I cant use newtype since that would mean a lot of code replication. I also need to make sure I have two Value types that can't be mixed
10:16:51 <michaelt> Is there some natural FreeT combinator one could use to zip or interleave suitable FreeT f m x and FreeT g m y ?
10:16:52 <dwcook> int3__, oh, I see what you mean. Well, in that case you did have a good idea with Reader, though in particular it seems you might want ReaderT
10:17:05 <rufs> a Phantom type felt like the best solution
10:17:09 <n-dolio> dfeuer: I mean more like: that dropWhile implementation is building up pairs of stuff. It's conceivable that doing that doesn't actually win over building a list and then destroying it.
10:17:29 <int3__> dwcook: yeah, I thought it was time for me to look into monad transformers. thanks!
10:18:20 <dwcook> int3__, in particular, this makes it easy to do things like lift a function that doesn't care about the ReaderT environment so that they can be composed together with ones that do
10:18:31 <snyp> What is meant by 'isormorphic'?
10:18:45 <int3__> ah okay
10:18:52 <dibblego> snyp: iso means "one" and "morphic" means form, so isomorphic means to have one (the same) form
10:18:57 <TheKing444> snyp isomorphic means the sturcture is the same
10:19:11 <dfeuer> n-dolio: that it doesn't. The pairs are unboxed without any trouble. But I think there's a bigger problem. Much bigger...
10:19:15 <n-dolio> dfeuer: There also might be a different way of writing it that works out better. More like the foldl from head. But you'd need head ghc to test that.
10:19:15 <dibblego> sorry, iso means equal, not one
10:19:25 <michaelt> I have zipWithF :: (Monad m, Functor f, Functor g, Functor h) => (forall x y . f x -> g y -> h (x,y)) -> FreeT f m r -> FreeT g m s -> FreeT h m (Either (r, FreeT g m s) (FreeT f m r, s)) but that seems a bit hackish
10:19:30 <dibblego> therefore, isomorphic means equal form or structure
10:19:30 <TheKing444> for example, if I define data bla a = a | bloop a (bla a), that is isomorphic to list
10:19:36 <nh2> does somebody understand Test.QuickCheck.cover? It doesn't seem to do anything for me
10:19:41 <dibblego> TheKing444: not quite
10:19:57 <TheKing444> oh wait, whoops
10:20:14 <dfeuer> n-dolio: I think what kills it is that it tests the predicate on every element, even once it's gone far enough, which could actually produce bottoms that shouldn't be there.
10:20:22 <dibblego> data bla a = bla (forall b. (a → b → b) -> b -> b)) -- bla is isomorphic to []
10:20:34 <dibblego> Maybe () is isomorphic to Bool
10:20:35 <dfeuer> It's *toast*.
10:20:49 <dibblego> (Either () a) is isomorphic to (Maybe a)
10:21:03 <dibblego> \footnote{bottom values blah blah}
10:21:15 <merijn> dibblego: I wouldn't say they have equal structure, I'd describe it as a "lossless bidirectional mapping"
10:21:23 <snyp> dibblego, i see. i kinda knew the literal meaning, but what rules or whatever must 2 data types have to be isomorphic in Haskell?
10:21:31 <dibblego> merijn: that is the meaning of iso (equal) morphic (form)
10:21:35 <dfeuer> I was about to say that, dibblego. Maybe () has four values and Bool has only three.
10:21:39 <merijn> dibblego: I know that :)
10:21:56 <merijn> dfeuer: Fast and loose reasoning is morally correct! :p
10:21:59 <ion> snyp: That you’re able to convert between both losslessly. If you write a pair of functions that does that, you have proven they’re isomorphic.;
10:21:59 <n-dolio> dfeuer: I don't think that's right.
10:22:02 <snyp> s/rules/property
10:22:21 <n-dolio> merijn: That's not what that means.
10:22:25 <snyp> ion, i see.
10:22:38 <chrisdone> luite: this doesn't work http://lpaste.net/5352233702761955328
10:22:43 <merijn> n-dolio: It means I get to pretend bottom doesn't exist and still talk sense!
10:22:44 <chrisdone> luite: the "Me!" never gets printed
10:22:45 <dibblego> snyp: write a bijective transformation between the two
10:23:15 * chrisdone really does go shopping now
10:23:19 <dibblego> must go bye
10:23:21 <n-dolio> merijn: It doesn't mean you get to rewrite functions into other functions that have different behavior on bottoms.
10:23:25 <aloiscochard> bye dibblego
10:23:27 * dibblego heads back to Australia, bye USA
10:23:36 <aloiscochard> have a good flight
10:23:45 <dfeuer> n-dolio: I'm looking at it again. Oh, I think you're right. Brain twister.
10:24:06 <n-dolio> dfeuer: You're throwing away a lot of the ys. Specifically the ones on which dropWhile wouldn't have run the predicate.
10:24:09 <luite> chrisdone: origStdout <- hDuplicate stdout; hDuplicateTo h stdout; someAction; hDuplicateTo origStdout stdout
10:24:11 * hackagebot binary-typed 0.2.0.0 - Type-safe binary serialization  http://hackage.haskell.org/package/binary-typed-0.2.0.0 (quchen)
10:24:22 <dfeuer> Yes, you're right, n-dolio.
10:24:25 <merijn> snyp: An isomorphism are two transformations "f :: a -> b" and "g :: b -> a" such that "g (f x) == x" and "f (g y) == y"
10:24:27 <marchelzo_> What is the preferred way to install haskell on arch linux?
10:24:31 <n-dolio> That's still doing extra work, though, I think.
10:24:41 <aloiscochard> marchelzo_: I'm using the haskell-core repo to have last GHC
10:24:46 <dfeuer> You're wrong about the pairs, though, because they get unboxed with no difficulty.
10:25:00 <marchelzo_> aloiscochard: thanks
10:25:15 <n-dolio> The pairs aren't the problem. It's the work in each half of the pair.
10:25:33 <merijn> n-dolio: Who said anything about that, I was just arguing that an isomorphism in the absence of bottoms was "good enough" for me
10:25:48 <michaelt> marchelzo_: just use the tarball on the GHC homepage, I'd think; you can install it locally. http://www.haskell.org/ghc/download_ghc_7_8_3#x86linux or the like.
10:26:02 <snyp> merijn, ok.
10:26:19 <merijn> michaelt: btw, that zipWithF type is a type signature to be proud of ;)
10:26:21 <n-dolio> merijn: Then why did you yell that in a conversation about rewrite rules?
10:26:49 <michaelt> merijn: hah, thanks. I have a few simpler ones...
10:26:51 <merijn> n-dolio: I didn't see a conversation about rewrite rules, I saw a conversation about values being isomorphic
10:27:04 <dfeuer> n-dolio: I doubt any of these will be worse than the effects of the current lack of fusion.
10:27:13 <merijn> If anyone was discussing rewrite rules then that was off my screen already
10:27:17 <n-dolio> Ah.
10:28:10 <dfeuer> But if it doesn't fuse, or possibly even if it fuses with the wrong sort of thing (I'm not sure) then it's wretched.
10:29:33 <michaelt> marchelzo_: https://github.com/quchen/articles/blob/master/zero_to_local_ghc.md makes it seem more complicated than it is, but that sort of thing. once you have ghc you need to compile the cabal library and maybe alex and happy
10:29:49 <quchen> Apologies for that :-S
10:29:50 <n-dolio> dfeuer: Building a bunch of closures isn't inherently better than building a bunch of data (which actually look a lot like closures).
10:30:21 <n-dolio> That's why foldl being written in terms of foldr wasn't done, even though it could be.
10:30:45 <michaelt> quchen: I think I just meant, it seems harder in writing than it is once you've done it once or twice.
10:30:52 <n-dolio> So if you fuse such that you build more closures than you did data before, it's not necessarily better.
10:30:54 <charlie> h
10:31:45 <dfeuer> n-dolio: I understand that; I don't see what closures you're talking about in this case.
10:31:58 <michaelt> quchen: but you agree that you describe a fairly sensible plan for "<marchelzo_> What is the preferred way to install haskell on arch linux?"
10:32:57 <n-dolio> "let xs' = x `c` xs" that is a closure build, unless it turns into a non-let in the core.
10:33:03 <aloiscochard> machineslearn: also, there is #archlinux-haskell if you have specific question :-)
10:33:09 <aloiscochard> oops
10:33:13 <aloiscochard> s/machineslearn/marchelzo_ /
10:33:30 <n-dolio> Also, to put things in a more normalized form, you will have "let z = if p x then ys else xs' in (z, xs')"
10:33:39 <n-dolio> Which also builds a closure.
10:34:16 <n-dolio> And go demands its pair, so I think all of those closures might get built, all the way down the list.
10:35:03 <marchelzo_> aloiscochard: I got ghc and cabal from haskell-core and everything seems to be okay
10:35:05 <n-dolio> And even if there isn't a list, proper, they might get built for every would-be element of a fused list.
10:35:54 <aloiscochard> marchelzo_: awesome :) you are ready to rocks
10:36:07 <n-dolio> So it's conceivable to me that this implementation is never a win over a non-fused dropWhile.
10:36:24 <n-dolio> But you need to do benchmarks to determine that.
10:36:39 <michaelt> marchelzo_: ah good. at first I thought your question presupposed that the ones you can get with pacmac etc are out of date.
10:37:16 <carter> int-e: is lambdabot hosed right now?
10:37:27 <marchelzo_> michaelt: Well I tried to install haskell-platform, and I kept getting an error. I just wanted to do a fresh install of ghc and cabal
10:37:28 <carter> nvm, just laggy
10:38:14 <michaelt> marchelzo_: if you don't have the happy' and 'alex'
10:38:31 <michaelt> marchelzo_: ... executables, you might need to cabal install them
10:38:48 <n-dolio> dfeuer: I also think it's unlikely that the closure built for xs' will get optimized away, becuase xs' gets used twice.
10:39:01 <michaelt> marchelzo_: have you used ghc and cabal before?
10:39:25 <dfeuer> n-dolio: the original in the Hutton paper didn't have that let; it duplicated the x `c` xs. Could that ever be better?
10:39:39 <n-dolio> I don't know.
10:40:07 <marchelzo_> michaelt: not much. I am quite new to haskell. But something was wrong with my installation so I just wanted to get a clean one
10:40:22 <kazagistar> how accurate of a depiction of GHC runtime internals is this? http://research.microsoft.com/apps/pubs/default.aspx?id=67083 (Spineless Tagless G-machine paper)
10:41:14 <michaelt> marchelzo_: I see; I was just going to mention obvious things about cabal and so on; like that you might want $HOME/.cabal/bin in path etc etc
10:41:39 <marchelzo_> michaelt: it appears to be there already
10:41:45 <rufs> I have shortened my problem now, Is there any way to make fOnFoo to work in this case when using phantom types? http://lpaste.net/6414051804195061760
10:42:47 <michaelt> marchelzo_: oh okay.
10:43:17 <n-dolio> kazagistar: There are many things that are probably no longer precisely accurate about that paper, but the abstract machine model is probably still pretty close.
10:44:09 <vanila> rufs, I annotated your paste if you would like to see an alternative way to do it http://lpaste.net/6414051804195061760
10:44:16 <merijn> kazagistar: If you're interested, last time I asked this someone linked me a follow-up paper in #ghc
10:44:22 <merijn> kazagistar: Lemme look up the exact title
10:45:13 <merijn> kazagistar: "Making a Fast Curry: Push/Enter vs. Eval/Apply for Higher-order Languages" by the Simons
10:46:11 <merijn> kazagistar: I think the STG paper is very much worth reading, though. Even if it's not exactly how GHC works currently
10:46:56 <n-dolio> Is the STG paper push/enter? I kind of thought it was agnostic to that.
10:47:17 <n-dolio> I guess the parts I read closely are. The rest might not be.
10:47:42 <merijn> rufs: For the phantom type you'd have to switch to Rank2Types
10:47:49 <michaelt> merijn: my FreeT zips and Producer/FreeT zips are here, https://gist.github.com/michaelt/ab11ddeeb5470c2871cd lines 74ff.  Maybe you can think of something more lovely?
10:48:00 <orion> :t (***)
10:48:00 <vanila> n-dolio, it uses slide/unwind
10:48:00 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
10:48:11 <kazagistar> merijn: I read it briefly, but I guess I am looking for something to give me a way to connect my low level performance intuitions about assembly to haskell (even if that is a task with only limited value anyways)
10:48:24 <n-dolio> I haven't even heard of that one.
10:48:53 <vanila> it's explained in more detail in the SPJ lester book
10:49:29 <meretrix> If I want to install my ghc-7.8 compiled binary on a 6 year old linux server (old glibc, libgmp, etc.), is there any option other than installing a complete ghc setup on the old server?
10:49:42 <merijn> rufs: http://lpaste.net/6414051804195061760
10:50:40 <merijn> kazagistar: I think the STG paper is a good way to form some initial intuition on performance of haskell, it's a good starting point even if it is outdated. At least if, like me, you had zero intuition before
10:50:42 <Pythonfant> meretrix: afaik not really, I ended up just creating a centos vm locally (that's the system the webspace I'm using is running on) and that works pretty well
10:51:00 <spopejoy> @pl \f -> StateT $ Identity . f
10:51:00 <lambdabot> StateT . (Identity .)
10:51:15 <dfeuer> Remind me ... how do I cabal install for a particular GHC build?
10:51:29 <michaelt> cabal install ghc ?
10:51:36 <michaelt> that would be strange
10:52:02 <rwbarton> cabal install -w ghc-X.Y.Z
10:52:03 <carter> dfeuer: theres a flag
10:52:05 <carter> yes
10:52:05 <n-dolio> merijn, kazagistar: Yeah. A lot of performance doesn't require knowing about the exact details of the machine implementation (which has changed) but on the operational semantics of something a bit below the surface (which hasn't much).
10:52:25 <merijn> dfeuer: cabal automatically uses the first GHC on your path
10:52:32 <meretrix> Pythonfant: Thanks. That's what I figured.
10:52:44 <rwbarton> dfeuer: or cabal install -w path/to/ghc
10:52:59 <rwbarton> all it needs is the path to the ghc executable
10:54:19 <michaelt> dfeuer: i usually make an alias kabal="cabal -w path/to/ghc" and similarly khc, khc-pkg.  Brilliant, no?
10:54:21 <dfeuer> Thanks, all. It looks like tab-completion on the path specified with -w is broken.
10:54:29 <dfeuer> Brilliant.
10:54:45 <rufs> vanila, thank you, I do prefer a Phantom-type solution for the moment since it fits very elegant with the rest of my codebase
10:54:58 <merijn> rufs: Did you see my version just now?
10:55:09 <rwbarton> dfeuer: yeah I've noticed that too, so I'm really good at typing $HOME/ghc/inplace/bin/ghc-stage2
10:55:16 <rufs> merijn, yes I think this is it but I need to think very hard now
10:55:38 <rufs> :p
10:55:41 <merijn> rufs: The datakinds bit is not strictly necessary, but it's a nice bit of extra safety
10:55:51 <dfeuer> rwbarton: you seem to be an insufficiently lazy hacker.
10:56:11 <vanila> rufs, oh that's okay - I just show this because I have often found this works well!
10:56:36 <merijn> rufs: With the normal phantom type "Value 1 :: Value Char" would be correct, with my version "Value 1 :: Value Char" is a type error, because Char is not of kind Quality
10:56:52 <merijn> (Technically in my version it would be a type error, but still!)
10:56:57 <merijn> s/type/kind
10:57:03 <merijn> Dammit, botched my correction
10:57:24 <rufs> merijn, that is actually a very nice thing for me in my case, I only want two valid phantom types
10:57:36 <merijn> rufs: That's what I guessed, yeah :)
10:57:53 <dfeuer> Dammit. What I meant to do I did not.
10:58:08 <mmirman> so in case anybody was interested in the OpenGL problem - You need to use GLUT’s initialContextProfile and initialContextVersion to update it to Core profile and version X.X.  Sadly this only works with freeglut, which isn’t the glut that comes with OSX.   At the moment, either GLFW-b or bindings-GLFW’s build is broken on OSX and I can’t figure out how to get the GLUT package to install with the brew installed freeglut framework.  Anybody have any
10:58:09 <mmirman> ideas?  This seems like it should really be easier to do.
10:58:42 <michaelt> dfeuer: my alias is kabal="cabal --with-compiler=path/bin/ghc --with-hc-pkg=path/bin/ghc-pkg"  I wonder if there's a reason for that ... I settled on it so long ago
10:59:05 <merijn> rufs: Without the forall in "fOnFoo" it's acceptable to pass a function with type "Value Good -> Int" to fOnFoo. The explicit forall (RankNTypes) I added, says that the function doesn't just have to work for *an* 'a', it says your function has to work for *all* possible a's
10:59:18 <dfeuer> I don't know what hc-pkg means...
11:00:04 <dfeuer> Argh! With the GHC head, vector-algorithms does not compile.
11:00:16 <dfeuer> It gets a type error.
11:00:28 <dfeuer> This is what happened to me the last time I tried this too.
11:00:45 <merijn> @quote cutting.edge
11:00:45 <lambdabot> edwardk says: {-# LANGUAGE time to pay the cutting edge typing features tax #-}
11:00:56 <dfeuer> That was weeks ago.
11:01:08 <michaelt> dfeuer:  It just directs ghc to the right ghc-pkg
11:01:09 <dfeuer> How am I supposed to test anything without Criterion?
11:01:24 <merijn> dfeuer: By patching criterion for us :D
11:01:44 <dfeuer> merijn: what have *other* people been doing;
11:01:44 <dfeuer> ?
11:01:47 <michaelt> Is vector-algorithms the source of the trouble, or something else
11:02:05 <merijn> dfeuer: Developing with 7.6 or something?
11:02:29 <orion> Why doesn't it make sense to say instance Functor Integer, but it does make sense to say instance Functor Maybe? What about Functor's class definition makes this so? What would Functor's class definition have to be to make instance Functor Integer valid?
11:02:33 <snyp> So, MonadPlus is Monoid for Monads ?
11:03:06 <dfeuer> michaelt, I haven't a clue. I installed the latest GHC source and I want to find out how well it compiles something, but I can't get it to compile criterion; it fails on the vector-algorithms dependency.
11:03:21 <rufs> merijn, ah I see thank you. That would be a lot safer and exactly what I want to enforce
11:03:22 <n-dolio> dfeuer: I can fix vector-algorithms. I haven't gotten around to it.
11:03:28 <snyp> (seems so.)
11:03:46 <snyp> ah yes.
11:06:18 <quchen> michaelt: Sorry for the late answer, went shopping. That file was written basically to guide myself through reinstallations, I guess it makes sense for an Arch install as well.
11:06:21 <dfeuer> Well, n-dolio, since you're the one telling me to benchmark things .....
11:06:30 <benzrf> snowp_: sort of
11:06:40 <benzrf> err, snyp
11:06:43 <benzrf> oh they left
11:07:00 <n-dolio> It doesn't seem likely that GHC 7.9 will affect that definition of dropWhile.
11:07:14 <michaelt> quchen: anyway, it turns out he got it from the arch haskell community.
11:08:39 <dfeuer> n-dolio: no, dropWhile seems unlikely for now and maybe forever. takeWhile, scanr, and scanl seem much more likely.
11:12:38 <intrados> What's they syntax for adding `+RTS -sstderr` to `cabal run Program`?
11:14:27 <michaelt> intrados: Usage: cabal run [FLAGS] [EXECUTABLE] [-- EXECUTABLE_FLAGS] suggests -- +RTS ... ?
11:14:34 <merijn> rufs: The only downside of RankNTypes is that GHC can't infer RankNTypes, so any function you define using them will need an explicit type signature
11:17:38 <intrados> michaelt: That doesn't seem to work. I get an error about failing to link with -rtsopts (which does not appear if I just invoke the executable directly)
11:18:22 <michaelt> intrados: I don't know, there is always the expedient of just running dist/build .../program +RTS ...
11:18:34 <michaelt> intrados: and skipping cabal run ?
11:18:56 <michaelt> intrados: oh, I see you already did that
11:19:16 * hackagebot binary-typed 0.2.0.1 - Type-safe binary serialization  http://hackage.haskell.org/package/binary-typed-0.2.0.1 (quchen)
11:19:43 <zzbacon> is monad in french, le monade
11:21:16 <chrisdone> le meaunadique
11:21:32 <benzrf> zzbacon: (☞ﾟ∀ﾟ)☞
11:21:45 <benzrf> zzbacon: fu now i want lemonade ;-;
11:21:58 <bitemyapp> benzrf: lol
11:22:46 <chrisdone> luite: aha!
11:24:57 <orion> Something interesting I just learned, that I've never read anywhere online: When you define a class which takes a type constructor (such as 'class Functor f'), the kind of f is determined by the first type signature that uses f, such as fmap :: (a -> b) -> f a -> f b
11:24:59 <chrisdone> luite: i wonder whether this works for c libs too?
11:25:11 <luite> chrisdone: it doesn't
11:25:30 <chrisdone> luite: this will actually do for my work for now, anyway, thanks. i'll keep the low-level version around, but the high-level one is cleaner
11:25:46 <orion> If you define another signature within the class and the kinds don't match up, the first signature wins.
11:26:33 <n-dolio> If the kinds don't match up, then you'll get an error, no?
11:26:38 <n-dolio> I'm not sure that's winning. :)
11:26:59 <benzrf> orion: do you mean 'wins' as in the error says that the 2nd one is wrong?
11:27:05 <rufs> merijn, ok I don't think that will be a problem as I have type signatures everywhere already
11:28:57 <orion> benzrf: yes
11:29:16 * hackagebot inc-ref 0.1.0.0 - A STM reference that is useful for incremental computing  http://hackage.haskell.org/package/inc-ref-0.1.0.0 (JonathanFischoff)
11:29:33 <orion> benzrf: This is a rule I've never read about anywhere, but would be helpful for beginners like myself.
11:29:45 <chrisdone> omg seriously
11:29:53 <chrisdone> i write delayThread EVERY DAMN TIME
11:30:03 <chrisdone> for years. i will never learn to write threadDelay
11:30:16 <chrisdone> it's like, "fileWrite"
11:30:22 <chrisdone> D:
11:31:39 <benzrf> orion: how is it useful ?
11:34:17 * hackagebot inc-ref 0.2.0.0 - A STM reference that is useful for incremental computing  http://hackage.haskell.org/package/inc-ref-0.2.0.0 (JonathanFischoff)
11:34:50 <orion> benzrf: Because when someone asks me what the kind of 'f' is, I want to be able to read and understand the class declaration properly.
11:34:58 <orion> And give them the correct answer.
11:35:04 <benzrf> orion: it should be p obvious
11:35:14 <orion> It's not to a beginner.
11:35:16 <benzrf> if you see 'foo :: f a', then f is clearly * -> *
11:35:26 <benzrf> orion: ill give you that
11:35:36 <benzrf> but i dont see how the specific thing you pasted helps
11:36:35 <orion> It helps understand how the compiler is interpreting your code, so when it spits error messages at you you understand better how to fix it.
11:37:11 <benzrf> ok......
11:37:25 <orion> ok......
11:37:30 <michaelt> orion: is the topic you are discussing with the person something like "why isn't it 'instance Functor Int' or 'instance Functor (Maybe Int)' or 'instance Functor (Maybe a)', but instance Functor Maybe
11:37:38 <dncr> Even on a big-endian machine, bytes are stored in memory and on disk in the same bit-order right?
11:37:50 <quchen> If you see "foo :: f a", then f :: (a's kind) -> * I think.
11:37:56 <quchen> And a does not necessarily have to have kind *.
11:38:18 <benzrf> bah
11:38:32 <orion> michaelt: I answered my own question from earlier, essentially.
11:39:17 * hackagebot inc-ref 0.3.0.0 - A STM reference useful for incremental computing  http://hackage.haskell.org/package/inc-ref-0.3.0.0 (JonathanFischoff)
11:39:25 <michaelt> A huge amount of the trouble people have with Functor and Monad is just getting the idea of a (* -> *) thing, it seems.
11:41:49 <ph88> hey guys. I use print to print a list like [1,2,3]  instead i would like it displayed as 1 newline 2 newline 3 .. how can i do this ?
11:41:54 <quchen> benzrf: Example: http://lpaste.net/108147
11:42:08 <michaelt> mapM_ print [1,2,3]
11:42:28 <michaelt> ph88 ^^
11:42:35 <TheJhonny> < mapM_print [1,2,3]
11:42:57 <mmachenry> I am trying to figure out how to get my code to work without -XOverloadedStrings because I am reading things in from networks and files so the strings are not in my code.
11:43:12 <TheJhonny> *Damn you hackbot!
11:43:18 <ph88> that's great michaelt, where did you found this function ?
11:43:18 <arityfn> Does the NICTA course comes with with some lectures?
11:43:19 <mmachenry> I have this simple program using Aeson "decode "[1,2,3]" :: Maybe Value" which works with -XOverloadedStrings but not without.
11:43:22 <dv-> > concatMap (\x -> show x ++ "\n") [1,2,3]
11:43:24 <lambdabot>  "1\n2\n3\n"
11:43:47 <mmachenry> I think I might need to use a specific fromString but I have a bunch of Stringy types all over my program.
11:43:59 <michaelt> ph88: I think it's in the Prelude, no?
11:44:12 <quchen> mmachenry: 'decode' expects a ByteString as argument.
11:44:31 <ph88> michaelt: i mean how do you know about it ?
11:44:35 <mmachenry> If I run this it complains of not being a Data.ByteString.Lazy.Internal.ByteString
11:44:54 <quchen> Yes.
11:45:01 <mmachenry> So when I try to import Data.ByteString.Lazy and use pack It complains that that is Char and not Word8
11:45:21 <michaelt> ph88: oh, I just picked it up ages ago. The distinction between mapM and mapM_ is of some interest.
11:45:25 <michaelt> @type mapM
11:45:26 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
11:45:30 <michaelt> @type mapM_
11:45:30 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
11:45:38 <ph88> i havent covered monads yet
11:45:40 <michaelt> @type mapM_ print
11:45:41 <lambdabot> Show a => [a] -> IO ()
11:45:45 <michaelt> @type mapM print
11:45:46 <lambdabot> Show a => [a] -> IO [()]
11:46:00 <kazagistar> quchen: yeah, I was trying to explain something recently, and realized that I was confused on what is the nature of [Int] or whatever...
11:46:10 <quchen> Strings and ByteStrings don't have much in common, really. You can serialize String to ByteString though, you can use the (awful and hacky) IsString instance of ByteString (which is what OverloadedStrings does). You can also serialize your value using 'encode' and then decode that.
11:46:28 <michaelt> I remember freaking out when I first used Haskell that mapM print xs, and things like that would print stuff but end with [(),(),(),()] and the like.
11:46:42 <benzrf> what i want is
11:46:50 <mmachenry> quchen: I'll write up what I have in a paste, one sec
11:46:54 <ph88> yes its not really clear with the default print
11:47:40 <michaelt> ph88: if you import Control.Monad you can use forM_ [1,2,3] print which is in some ways pleasing
11:47:44 <benzrf> @pl p a = do {v <- a; print a; return a}
11:47:44 <lambdabot> (line 1, column 10):
11:47:44 <lambdabot> unexpected '{'
11:47:44 <lambdabot> expecting variable, "(", operator or end of input
11:47:48 <benzrf> hmmmmmmmmmmmmmmmmmmmmmm
11:48:30 <josephle> @undo do { v <- a; print a; return a; }
11:48:31 <lambdabot> a >>= \ v -> print a >> return a
11:48:55 <michaelt> @pl f x =  a >>= \ v -> print a >> return a
11:48:55 <lambdabot> f = const (a >> (print a >> return a))
11:49:01 <Ankhers> If I use forkIO, is there a way to guarantee that it starts running immediately?
11:49:02 <michaelt> @pl f a =  a >>= \ v -> print a >> return a
11:49:03 <lambdabot> f = ap (>>=) (const . liftM2 (>>) print return)
11:49:03 <kazagistar> michaelt: I was pretty comfortable with [()], since I had done code golf-y things in languages that had a map() before and done horrible things like { map(print, ...) } before :P
11:49:26 <johnw> Ankhers: you don't really have that much control over the scheduler
11:49:36 <mmachenry> quchen: http://lpaste.net/108148
11:49:36 <johnw> Ankhers: and what if your user doesn't compile with -threaded
11:49:48 <Ankhers> johnw: I figured as much. Thanks.
11:49:58 <mmachenry> I think there's another ByteString I need.
11:50:03 <mmachenry> I tried with Lazy
11:50:24 <mmachenry> And I still get the Word8 vs Char problem
11:50:57 <Ankhers> mmachenry: lpaste.net can you post your code?
11:51:04 <michaelt> ph88: in some ways sequence and sequence_ are closer to the main point.  [print 1, print 2, print 3] is just a list of IO actions; but sequence_ [print 1, print 2, print 3]  does them in succession
11:51:15 <quchen> :t BS.pack -- mmachenry: pack expects [Word8], i.e. a list of bytes
11:51:16 <lambdabot> [Word8] -> BSC.ByteString
11:51:16 <mmachenry> Ankhers I did
11:51:24 <ph88> ah i see
11:51:25 <michaelt> ph88: that is, it's not a list of actions, but an action itself
11:51:56 <Ankhers> mmachenry: can you post the link again? Apparently I was disconnected when you did.
11:52:17 <quchen> mmachenry: Your problem is pretty artificial, since you don't usually enter JSON by hand anywhere. Aeson expects ByteStrings, and those are usually generated by Aeson (or some external program).
11:52:45 <quchen> You can of course do `decode (encode [1,2,3])`.
11:53:15 <mmachenry> quchen: Yeah I'm trying to get stuff out of Postgres and turn it into JSON
11:54:13 <quchen> mmachenry: Anyway, when you *do* have a String and really need to read it as JSON you can serialize it first and then decode the result (and hope for the best).
11:54:20 <michaelt> ph88: so mapM_ print [1,2,3] is the same as sequence_ (map print [1,2,3]), where map print [1,2,3] = [print 1, print 2, print 3], which again, is just a list of actions not action.
11:54:46 <quchen> Inb4 someone suggests the evil cousin of ByteString that pretends to work with String
11:55:18 <ph88> what's the difference between sequence and sequence_ then ?
11:55:29 <jle`> :t sequence
11:55:30 <lambdabot> Monad m => [m a] -> m [a]
11:55:32 <jle`> :t sequence_
11:55:33 <lambdabot> Monad m => [m a] -> m ()
11:55:36 <quchen> sequence_ x = sequence x >> return ()
11:55:42 <michaelt> ph88: mapM also returns the result list
11:56:02 <jle`> in sequence/mapM, you are sequencing things and you care about the results produced by each action
11:56:10 <kazagistar> _ tends to mean "I dont care about the result, just the monadic side effects"
11:56:20 <jle`> in sequence_/mapM_, you don't care about the result, you are only using them for their side effects
11:56:25 <quchen> This may help understanding sequence/mapM. https://github.com/quchen/articles/blob/master/functions_comprehensible.md#sequencemapm
11:56:33 <benzrf> @src sequence_
11:56:33 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
11:56:37 <kclark> i'm working through the Real World Haskell book and have a question about let vs "<-"
11:56:39 <benzrf> quchen: y-youre wrong!
11:56:40 <kclark> cf http://lpaste.net/108149
11:56:47 <michaelt> ph88: in this case the return value of print 1 is (), so mapM print [1,2,3] would return [(),(),()] after printing, which is not too exciting.
11:56:49 <kclark> line 11
11:56:54 <ph88> is the side effect described in the type of sequence(_) ?
11:56:56 <kazagistar> mneumonic is "_ means I dont care about the value, so _ at the end of a function means I dont care about the result of the function"
11:57:07 <benzrf> kclark: let and <- are just entirely separate things
11:57:07 <quchen> benzrf: Duly noted
11:57:31 <michaelt> kclark: because f is pure. if it were FilePath -> IO FilePath you would extract the filepath that way
11:58:09 <kclark> ok, that sort of makes sense
11:58:14 <michaelt> kclark: i mean you would write "path' <- f path"
11:58:41 <michaelt> kclark: it's a little crazy but you could write :  path' <- return (f path)
11:59:28 <michaelt> kclark: that way you put the filepath that (f path) is into IO ... but only to extract it again, so to speak.
12:00:25 <michaelt> "let x = f y" in the do notation context is the same as ... ; x <- return (f y); ...
12:00:38 <michaelt> kclark: or about the same.
12:01:11 <kclark> ok, i'll just keep working through the book, i'm sure it will make sense eventually
12:01:16 <kclark> thanks for the help
12:01:27 <kazagistar> kclark: just to make it clear, no "real" extraction is taking place, since the result of the "do" block will always still be inside the monad, you will see :D
12:02:19 <jle`> michaelt: i like to think of it as... if you have an IO a, and you want to "name" the a, you use <-
12:02:21 <chrisdone> Iceland_jack: hacking on formatting =3
12:02:29 <jle`> michaelt: if you have an `a`, and you want to name the `a`, you use let
12:02:47 <michaelt> kclark: right, like jle` says.
12:02:57 <jle`> oops
12:03:02 <jle`> tht should be directed at kclark
12:03:15 <Iceland_jack> chrisdone: haha sorry for spamming you with issues
12:03:50 <chrisdone> Iceland_jack: haha nah it's cool someone else is using it =)
12:05:05 <benzrf> bbl
12:05:15 <eacameron> So running `IO Int` gives me a strict Int; but does IO [Int] give me a strict list? How can that be lazy/infinite?
12:05:47 <michaelt> kclark: I remember finding the 'let' in do notation a little confusing at first, too.
12:06:21 <luite> eacameron: running that IO action does not force the Int by itself
12:06:27 <spopejoy> @undo do a -> get; return a
12:06:27 <lambdabot> <unknown>.hs: 1: 6:Parse error: ->
12:06:39 <eacameron> michaelt: the "let" syntax in do "desugars" really simply; that's how I think of it
12:06:48 <michaelt> eacameron: readFile "txt" is an IO [Char]
12:07:19 <eacameron> luite: hmm how so? I thought IO was strict
12:07:28 <luite> eacameron: return (error "a") >> putStrLn "b"  will not raise an exception
12:07:48 <eacameron> luite: whoa; my brain esplode
12:07:56 <eacameron> luite: what forces the eval?
12:08:10 <jle`> eacameron: you can think of return x as returning the thunk pointing/containing the x
12:08:34 <kazagistar> it strictly will force the side effects of reading the int, though?
12:08:55 <spopejoy> @undo do a <- get; return a
12:08:56 <lambdabot> get >>= \ a -> return a
12:08:56 <luite> eacameron: using the value, or forcing explicitly, like return $! error "a"
12:09:21 <eacameron> so the IO monad isn't strictly strict, it just defines ordering (dependencies)?
12:09:33 <kkarlton> Is there a ghci equivalent of @src?
12:09:37 * chrisdone . o O ( how does return $! differ to evaluate )
12:09:55 <jle`> kkarlton: no, @src is just a lookup on a text file on lambdabot's server
12:10:01 <kkarlton> jle`: damn
12:10:03 <jle`> kkarlton: you can download the text file yourself if you want
12:10:08 <jle`> it's on the repo
12:10:12 <kkarlton> jle`: got it
12:10:15 <chrisdone> kkarlton: haskell isn't that awesome yet ;)
12:10:22 <luite> chrisdone: the type for starters :)
12:10:26 <jle`> wb isomorpheous
12:10:39 <chrisdone> luite: can't be bothered hoogling them to import and see
12:10:53 <quchen> chrisdone: See the docs, http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Exception-Base.html#v:evaluate
12:10:53 <isomorpheous> jle`: hm?
12:10:56 <luite> :t evaluate
12:10:56 <lambdabot> a -> IO a
12:11:11 <johnw> chrisdone: o/
12:11:11 <chrisdone> :t ($!)
12:11:12 <lambdabot> (a -> b) -> a -> b
12:11:18 <jle`> isomorpheous: welcome back
12:11:26 <isomorpheous> jle`: ah, I had to google that
12:11:29 <quchen> :t (return $!)
12:11:30 <lambdabot> Monad m => a -> m a
12:11:38 <isomorpheous> jle`: watching old psych episodes, hence kkarlton
12:11:48 <jle`> :) it was actually one of the first web acronyms i ever learned....and it was actually while using irc
12:11:49 <chrisdone> so evaluate is stuck in the IO monad
12:11:58 <johnw> @src evaluate
12:11:59 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:12:04 <chrisdone> hey johnw =)
12:12:06 <jle`> evaluate is an IO action
12:12:09 <jle`> that evaluates the thing
12:12:16 <chrisdone> jle`: where did you get that idea? ;)
12:12:19 <quchen> evaluate a = IO $ \s -> seq# a s
12:12:22 <quchen> Hope that helps ;-)
12:12:45 <jle`> chrisdone: i met a prophet
12:13:15 <chrisdone> ah:
12:13:16 <chrisdone> evaluate x = (return $! x) >>= return
12:13:39 <quchen> chrisdone: I wonder how the Monad laws fit into that.
12:13:45 <jle`> surely there is a monad law about (>>= return)
12:14:04 <quchen> jle`: Yes, but the Monad laws often hold only in the absence of ⊥
12:15:01 <Iceland_jack> chrisdone: Hm should I just copy what Kmett has in https://hackage.haskell.org/package/lens-3.9.0.2/docs/src/Numeric-Lens.html for showing numbers at some base? It only uses base libraries but it improves on them slightly so I can either use the simple version or effectively copy paste what he has
12:15:12 <jle`> quchen: really?
12:15:23 <jle`> quchen: i always thought they attempted to say stuff about bottom too
12:15:37 <quchen> jle`: Reader doesn't obey the laws as well, for example.
12:15:38 <johnw> >>= return cancels
12:15:42 <johnw> m >>= return = m
12:15:46 <jle`> like, return undefined >>= return should = return undefined
12:15:51 <johnw> so really then evaluate = (return $!)
12:15:56 <johnw> if chrisdone is right
12:16:12 <luite> johnw: the difference is that you can force the (m a) value you get from evaluate
12:16:13 <jle`> whaaaaa reader is not a law abiding monad?
12:16:30 <luite> johnw: but without the extra return that would give you an exception due to $!
12:16:39 <johnw> jle`: what do you mean?  it is
12:16:39 <jle`> > runReader 1 (return undefined >>= return)
12:16:40 <lambdabot>  Could not deduce (GHC.Num.Num
12:16:41 <lambdabot>                      (Control.Monad.Trans.Reader.Reader (m0 b0) a))
12:16:41 <lambdabot>    arising from the ambiguity check for ‘e_11’
12:16:41 <lambdabot>  from the context (GHC.Num.Num
12:16:41 <lambdabot>                      (Control.Monad.Trans.Reader.Reader (m b) a),
12:16:50 <jle`> johnw: quchen seems to be saying that it isn't
12:16:56 <johnw> luite: hmm
12:17:00 <jle`> > runReader (return undefined >>= return) 1 :: Int
12:17:01 <kazagistar> this seems really silly, but I cant seem to find a { IO String }, like a raw version of readLn...
12:17:01 <lambdabot>  *Exception: Prelude.undefined
12:17:03 <chrisdone> Iceland_jack: sure, the impl. is pretty simple in any case, whatever's simplest
12:17:14 <jle`> kazagistar: getLine
12:17:18 <jle`> @hoogle IO String
12:17:20 <lambdabot> Did you mean: :: IO String
12:17:20 <lambdabot> System.IO.Error ioeGetErrorString :: IOError -> String
12:17:20 <lambdabot> System.IO.Error ioeSetErrorString :: IOError -> String -> IOError
12:17:28 <jle`> darn you hoogle
12:17:41 <kazagistar> jle`: yeah, I tried hoogle, it just crapped out on me like that :/
12:17:58 <quchen> Reader: ⊥ >>= return = \r -> return (⊥ r) r = \r -> const (⊥ r) r = const ⊥ ≠ ⊥
12:18:08 <quchen> I think it was along those lines.
12:18:51 <michaelt> it seems it doesn't quite cancel, but (>>= return) is the same as id. At least it doesn't matter whether I define eval x = (return $! x) >>= return or eval x = id (return $! x) .
12:19:33 <chrisdone> i think perhaps the presence of seq changes the situation with commonly reliable expectations
12:20:38 <jle`> > runReaderT (undefined >>= return) 1 :: Int
12:20:39 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
12:20:39 <lambdabot>              with actual type ‘m0 a0’
12:20:44 <jle`> > runReader (undefined >>= return) 1 :: Int
12:20:45 <lambdabot>  *Exception: Prelude.undefined
12:21:07 <jle`> oh
12:21:18 <quchen> Hence me saying "along those lines" ;-)
12:21:19 <jle`> const bottom /= bottom ?
12:21:22 <quchen> Yes
12:21:29 <quchen> > const undefined `seq` ()
12:21:30 <lambdabot>  ()
12:21:35 <ph88> i have this float 2.220446049250313e-16  where i expect 0. How can i correct this with haskell ?
12:21:47 <jle`> ohi never realized that
12:21:47 <chrisdone> :t const undefined
12:21:48 <lambdabot> b -> a
12:21:49 <jle`> ph88: you can round it
12:22:05 <jle`> ph88: but this is an inherent property of floating point numbers
12:22:06 <quchen> ph88: Haskell is right, you should not "correct it". Floating point numbers are complicated, in Haskell and anywhere else.
12:22:16 <chrisdone> seq on a function will only force the thunk to make the function, obv. not force the fully applied version
12:22:17 <jle`> you can also use Rational, if it is appropriate
12:22:27 <quchen> ph88: Typically you'd check whether your result is in a certain distance from zero to accept it as "zero".
12:22:30 <ph88> what's Rational ?
12:22:46 <michaelt> > 1 / 3 :: Rational
12:22:47 <lambdabot>  1 % 3
12:22:52 <jle`> > 382 / 8124 + 94234 / 8243
12:22:53 <lambdabot>  11.479024083397858
12:22:56 <jle`> > 382 / 8124 + 94234 / 8243 :: Rational
12:22:57 <lambdabot>  384352921 % 33483066
12:22:57 <Pythonfant> ph88: if your comparing floating points like a = b you should usually test if abs(a-b) < epsilon with epsilon being something like 10^-9
12:22:58 <quchen> jle`: Let me see whether I can construct that Reader example properly.
12:23:01 <jle`> infinite precision rational numbers
12:23:01 <etandel> ph88: if you are trying to compare (myvar == 0), then use a threshold, like `abs (myvar - 0) < threshhold`
12:23:36 <michaelt> ph88: with tons of calculations, the numator and denominator tend to get a little big ;)
12:23:43 <etandel> ph88: value of threshold depends on the order of magnitude of your domain
12:23:43 <jle`> > runReader (undefined >>= return) `seq` ()
12:23:44 <lambdabot>  ()
12:23:46 <ph88> i'm not comparing floats. Rational is not appropriate. How can i round with a given precision of decimals ?
12:23:49 <jle`> > runReader (undefined) `seq` ()
12:23:50 <lambdabot>  ()
12:24:02 <jle`> it still seems to be equivalent to me, or maybe i'm forcing the wrong thing
12:24:05 <etandel> ph88: http://floating-point-gui.de/
12:24:23 <n-dolio> That's interesting.
12:24:42 <n-dolio> I guess the auto-generated runReader eta expands?
12:25:12 <ph88> :t round
12:25:13 <lambdabot> (RealFrac a, Integral b) => a -> b
12:25:26 <randen> ph88: check out Numeric.IEEE for epsilon
12:25:30 <ph88> > round 1.46334 3
12:25:31 <lambdabot>  Could not deduce (GHC.Num.Num a0)
12:25:31 <lambdabot>    arising from the ambiguity check for ‘e_11463343’
12:25:31 <lambdabot>  from the context (GHC.Num.Num a, GHC.Real.Integral (a -> t))
12:25:31 <lambdabot>    bound by the inferred type for ‘e_11463343’:
12:25:31 <lambdabot>               (GHC.Num.Num a, GHC.Real.Integral (a -> t)) => t
12:25:41 <n-dolio> Or wait, runReader is not auto-generated anymore, is it?
12:25:43 <jle`> round only takes 1 argument
12:25:51 <jle`> n-dolio: yeah, it's not
12:25:58 <n-dolio> Okay, that explains it.
12:26:16 <jle`> @src runReader
12:26:17 <lambdabot> Source not found. stty: unknown mode: doofus
12:26:31 <jle`> runReader r = runIdentity . runReaderT r, i think
12:26:33 <ph88> so i should multiply then round, then divide for given how much decimals to round ?  i guess this would be the equivelant to setting some kind of treshold
12:26:43 <randen> ph88: ieee754 package
12:27:22 <ph88> randen: Convert Float and Decimal values to/from raw octets.    why octets ?
12:30:18 <michaelt> >  let digitPrecise n x = fromIntegral (round ((10 ^ n) * x)) / 10 ^ n in map (flip digitPrecise (382 / 8124 + 94234 / 8243)) [0..10]
12:30:19 <lambdabot>  [11.0,11.5,11.48,11.479,11.479,11.47902,11.479024,11.4790241,11.47902408,11....
12:30:27 <n-dolio> > ((undefined >>= return :: Reader () ()) `seq` (), (undefined :: Reader () ()) `seq` ())
12:30:28 <lambdabot>  ((),*Exception: Prelude.undefined
12:30:43 <michaelt> ph88: ^^ this is a little shabby, digitPrecise
12:30:47 <jle`> nice n-dolio
12:30:47 <frankle> my first time playing with cabal went something like this:  http://pastie.org/private/jgtx3dfji4n08gyv3dqfsg.  anyone have any ideas what's going on and how to resolve it?
12:30:48 <ph88> randen: do you know some documentation for that? or how would i do that with the ieee754 package ?
12:31:01 <jle`> well this makes me sad about monad laws
12:31:07 <jle`> because i always have been using them to reason about bottom
12:32:14 <jle`> my entire life has been a li
12:32:16 <jle`> e
12:32:40 <quchen> ?google fast and loose reasoning is morally correct
12:32:41 <lambdabot> http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html
12:32:42 <lambdabot> Title: Fast and Loose Reasoning is Morally Correct
12:32:47 <n-dolio> It should make you sad about seq.
12:32:58 <jle`> nah seq is cool, we are buddies
12:33:00 <quchen> jle`: We've all been there. Read the abstract of the above paper to feel better again.
12:33:17 <n-dolio> seq is the problem. It shouldn't work on functions.
12:33:18 <quchen> Short version: reasoning without ⊥ is usually fine.
12:33:28 <ph88> > Numeric.IEEE.epsilon 1.3523462
12:33:29 <lambdabot>  Not in scope: ‘Numeric.IEEE.epsilon’
12:33:29 <jle`> oh i see
12:33:41 <ph88> :m Numeric.IEEE
12:34:10 <jle`> going back to the (one of the) original questions, i have been known to use a Show instance as a free deepseq
12:34:19 <normalhum> http://paste.ubuntu.com/7858466/
12:34:26 <quchen> jle`: That's evil though :-þ
12:34:34 <randen> ph88: I was suggesting this for the question of comparing values.  For example, Data.AEq has an approximate equal and Numeric.IEEE defines an epsilon that you can use
12:34:38 <jle`> it works and nobody actually reads the server logs >____>
12:34:55 <n-dolio> Does that even work? Oh, you're forcing the entire string.
12:35:06 <jle`> it's a deep nested data structure
12:35:11 <ph88> randen: ok but i dont need to compare, just for displaying 0 instead of Numeric.IEEE
12:35:15 <quchen> jle`: I recently deepseq'd the ByteString encoding (via Binary) of some data I was too lazy to write a NFData instance for ;-)
12:35:17 <jle`> lots of deeply nested things
12:35:24 <jle`> quchen: hahaha
12:35:33 <jle`> that works too
12:35:42 <jle`> OH that works
12:35:48 <jle`> i should probably have been deepseqing the string
12:35:53 <jle`> instead of printing it >_>
12:35:57 <jle`> <__<
12:36:08 <jle`> or evaluating it i guess
12:36:20 <quchen> Feel slapped for that :-þ
12:36:26 <n-dolio> You have to deepseq the string if you want it to have any effect.
12:36:41 <jle`> oh yeah, evaluate is whnf
12:36:48 <n-dolio> > fix show
12:36:49 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
12:36:59 <jle`> i figured out that much so i used the show as a deepseq
12:37:07 <jle`> er the print as a deepseq
12:37:29 <jle`> maybe i should have just converted it to text and evaluated the text
12:37:46 <quchen> I wonder why there is no "evaluate . force" in DeepSeq.
12:38:15 <jle`> oh i just realized why force is useful
12:38:25 <jle`> when i first read the source i was like...isn't seq x x = x
12:38:32 <jle`> so why would deepseq x x /= x
12:38:36 <quchen> :-)
12:38:38 <jle`> but it all makes sense now
12:39:49 <randen> ph88: maybe you know this already, but chapter 6 of of Real World Haskell has a nice summary table of how to get from one type of numeric to another
12:40:08 <mmachenry> What do people this make for good guidelines are how to import modules in a large project with multiple people? Do people think naming the imported functions is good? Do people think qualifying is good? I think I tend to use a mix based on context.
12:40:21 <ph88> randen: no didnt know. i only covered lyah
12:41:18 <mmachenry> I want to come up with some standards if there are any the Haskell community thinks are worth following. I will be working on a large project with some first-time Haskellers so clarity to outsiders (even at the expense of being idiomatic) might be worth it
12:41:27 <zzbacon> i hear that record syntax is "bad" from a few places, but it seems very common
12:41:29 <jle`> curry . uncurry = id is not true in the presence of bottom
12:41:35 <jle`> wow
12:41:50 <zzbacon> is record data unavoidable or just super convenient?
12:41:52 <quchen> jle`: A lot of things aren't true in the presence of bottom.
12:42:00 <quchen> zzbacon: Both
12:42:16 <quchen> Lens makes it much more bearable though if you have nested records
12:42:41 <jle`> :t curry . uncurry
12:42:42 <lambdabot> (a -> b -> c) -> a -> b -> c
12:42:58 <randen> ph88: I haven't read all lyah yet; RWH ch6 here http://book.realworldhaskell.org/read/using-typeclasses.html
12:43:00 <n-dolio> It's the other one.
12:43:36 <n-dolio> Well, I suppose technically that one doesn't hold, either.
12:43:46 <n-dolio> But it's seq's fault that that one doesn't hold.
12:44:08 <jle`> :t uncurry . curry
12:44:09 <lambdabot> ((a, b) -> c) -> (a, b) -> c
12:44:16 <jle`> i should probably eat lunch
12:44:36 <zzbacon> the potential name collisions seem scary, though i suppose if you limit things it's avoidable
12:44:37 <ph88> guys, how can i round a complex number ??
12:45:00 <zzbacon> (well, always avoidable, just inconvenient at a certain point)
12:45:01 <frankle> damn is cabal painfully slow to install new packages
12:45:01 <rwbarton> id . f = f is not true in the presence of bottom either, nor f . id = f
12:45:12 <frankle> building 1000s of dependencies
12:45:21 <quchen> ph88: Round the real part, round the imaginary part, put them together again
12:45:54 <quchen> Or whatever you want to round based on
12:47:00 * frerich_ gets “stats.txt: openBinaryFile: resource busy (file is locked)” for the umpteenth time and decides it’s time to figure out what’s going on...
12:47:53 <kazagistar> @let ultrasweedish = fix (intersperse 'f')
12:47:55 <lambdabot>  Defined.
12:48:15 <frerich_> I *bet* it’s because I do ByteString.readFile multiple times on the same file and the file is opened with exclusive access but not closed yet.
12:49:05 <quchen> frerich_: readFile is lazy, and lazy IO is often a bad idea. Consider using withFile and friends, and forcing file contents early.
12:50:21 <frerich_> quchen: Yeah, I read about that. I suppose ‘withFile’ would work well but before I consider that - how could I ‘force file contents’? Would that be, like, ‘contents <- B.readFile “foo.txt”’ and then somehow applying ‘seq’ to ‘contents’?
12:50:32 * frerich_ isn’t friends with ‘seq’ yet, always tip-toed around it
12:51:13 <quchen> frerich_: That's one way. To be sure something is fully forced use "evaluate . force".
12:51:17 <n-dolio> frerich: Are you using Data.ByteString or Data.ByteString.Lazy?
12:51:50 <quchen> There are also more elegant ways of dealing with this problem, like Pipes and Conduit.
12:52:12 <frerich_> n-dolio: It’s ByteString.Lazy right now. However, even if I had ByteString (strict) then readFile() would still not guarantee that the handle is closed, would it? Even though I get a strict bytestring?
12:52:20 <n-dolio> Yes, it would.
12:52:50 <frerich_> Really! So closing the handle is somehow tied to all input being read?
12:52:52 <n-dolio> That is the only change necessary, if this is the problem.
12:52:55 <n-dolio> Yes.
12:53:12 <n-dolio> Data.ByteString.readFile doesn't attempt to do lazy I/O at all.
12:53:28 <n-dolio> But in the lazy case, the file is closed when the string is fully forced.
12:53:34 <frerich_> Which makes me wonder why the existing file isn’t fully read yet… as in, the contents are not fully processed.
12:53:36 <n-dolio> Or when it gets garbage collected.
12:55:25 <n-dolio> If you're building other lazy structures from the lazy byte string, and not consuming them before opening the file again, it wouldn't be closed.
12:55:58 <frerich_> Yeah, I’m currently tracing what I’m doing with the file contents (and why it would be opened a second time)
12:57:27 <Athiwat> How can I implement a instance ToJSON from Data.Aeson if I don't own the "data x = x..."
12:58:02 <dibblego> Athiwat: probably best to write your own newtype Y that wraps your data X.
12:58:32 <Athiwat> dibblego: I see, thanks guess I missed it.
12:58:44 <ph88> i can't seem to get this type declaration right    testComplex :: Complex -> Complex    testComplex a = (2 :+ 2) + a      Expecting one more argument to `Complex'
12:59:03 <Athiwat> dibblego: is there anyway to convert old type to new type then?
12:59:08 <ph88> in the tutorial there are also no arguments on the declaration http://learnyouahaskell.com/types-and-typeclasses#believe-the-type
12:59:27 <Athiwat> dibblego: Oh, sorry I get it now.
12:59:30 <dibblego> Athiwat: yes, newtype Y = Y X then just call Y to convert X to Y
13:01:35 <ph88> (2 :+ 3) :: Num a => Complex a   <-- this is strange. Expecting   Complex a :+ a    or   Num a => Imaginary a
13:02:43 <spopejoy> @pl \ ~(a, s') -> (runStateT (f a) s')
13:02:43 <lambdabot> (line 1, column 3):
13:02:43 <lambdabot> unexpected "~"
13:02:43 <lambdabot> expecting pattern
13:03:10 <blueclaude> quick way to get unique list of elements, not necessarily ordered?
13:03:14 <rwbarton> ph88: Complex a is the type of complex numbers whose fields are of type a -- don't know why you expect anything else
13:03:29 <spopejoy> Looks like lambdabot doesn’t like lazy patterns
13:03:58 <rwbarton>  @pl doesn't like patterns much in general
13:03:59 <ph88> rwbarton: i just realize this mistake. So i change it to  testComplex :: (Complex a) => a -> a
13:04:13 <rwbarton> @pl \ (a, s') -> (runStateT (f a) s')
13:04:14 <lambdabot> uncurry (runStateT . f)
13:04:32 <rwbarton> hm
13:04:32 <spopejoy> Which raises the point: whence pointfree laziness??
13:04:42 <ph88> rwbarton: however that also brings a problem    Couldn't match expected type `a -> a'                 with actual type `Complex Integer'
13:06:24 <quchen> Complex is a type, not a type class.
13:06:44 <quchen> So you can't have "(Complex a) =>".
13:06:52 <quchen> You can have "Complex a -> Complex a".
13:06:59 <ph88> ok i thought it was a type class
13:07:43 <ph88> quchen: i tried that first with   testComplex :: Complex a -> Complex a    testComplex a = (3 :+ 2
13:07:54 <ph88> )
13:07:56 <ph88> No instance for (Num a) arising from the literal `3'
13:08:30 <triliyn> Num a => Complex a -> Complex a
13:08:55 <frerich_> What’s a good way to get programs like hlint, hdevtools or ghc_mod on OS X? I can’t find any ready-made packages so I went for ‘cabal sandbox init && cabal install hdevtools’ and then copying the built binary into ~/bin — is there a nicer way maybe?
13:08:55 <ph88> yes works
13:09:04 <ph88> dont understand why this was needed
13:09:15 <spopejoy> @pl \ s -> (\ ~(a, s') -> (runStateT (f a) s')) (runIdentity $ runStateT m s))
13:09:15 <lambdabot> (line 1, column 11):
13:09:15 <lambdabot> unexpected "~"
13:09:15 <lambdabot> expecting pattern
13:09:25 <rwbarton> Complex a is still a valid type even if a is String or something.
13:09:33 <rwbarton> Your program doesn't have the type Complex String -> Complex String.
13:09:37 <rwbarton> So you need to write a constraint.
13:09:43 <spopejoy> @pl \ s -> (\ (a, s') -> (runStateT (f a) s')) (runIdentity $ runStateT m s))
13:09:43 <lambdabot> (line 1, column 73):
13:09:43 <lambdabot> unexpected ')'
13:09:43 <lambdabot> expecting variable, "(", operator or end of input
13:09:58 <quchen> You can also message lambdabot in private (/msg lambdabot) when you just want to try things out (as opposed to demonstrating code to others).
13:10:20 <spopejoy> ok will do
13:11:07 <spopejoy> although I am interested in whether pointfree style can replicate the laziness in \ ~(a, s') -> (runStateT (f a) s')
13:11:46 <ph88> rwbarton: thanks. I still get confused over type classes VS composed types (types that take other types)
13:12:49 <rwbarton> just remember that unlike in certain other languages (Java), type classes and types are never interchangeable things
13:13:08 <rwbarton> you can never use a type where you need a type class, nor a type class where you need a type
13:13:12 <ph88> in  Complex a   how would i know all possible types for a  ?
13:16:14 <quchen> ph88: *all* types are possible for a.
13:16:24 <quchen> :t "Hello" :+ "World"
13:16:25 <lambdabot> Complex [Char]
13:16:44 <n-dolio> spopejoy: liftM2 (runStateT . f . fst) snd
13:16:56 <quchen> :t (Left "hello") :+ (Right 12)
13:16:56 <lambdabot> Num b => Complex (Either [Char] b)
13:17:05 <ph88> quchen: rwbarton just told me that Complex String is not possible
13:17:18 <kazagistar> ph88: however, a lot of the methods defined over Complex a may have additional constraints and thus not be useable
13:17:33 <quchen> ph88: No, rwbarton said "Complex a is still a valid type even if a is String or something.", which is the opposite.
13:17:45 <ph88> oh
13:17:56 <spopejoy> @src fst
13:17:56 <lambdabot> fst (x,_) =  x
13:17:57 <kazagistar> > Complex "hello"
13:17:59 <lambdabot>  Not in scope: data constructor ‘Complex’
13:18:01 <ph88> so it depends on the return value of my function what the type class should be ?
13:18:03 <kazagistar> oh, well, anyways
13:18:04 <quchen> You can't add two (Complex String), and you cannot extract its real part
13:18:15 <triliyn> > "Hello" :+: "There"
13:18:16 <lambdabot>  Not in scope: data constructor ‘:+:’
13:18:16 <lambdabot>  Perhaps you meant ‘:+’ (imported from Data.Complex)
13:18:20 <quchen> Well actually you can, by pattern matching. But not using "realPart".
13:18:21 <n-dolio> spopejoy: \ ~(x,y) -> E is the same as \p -> E[x := fst p, y := snd p]
13:18:21 <triliyn> > "Hello" :+ "There"
13:18:23 <lambdabot>  "Hello" :+ "There"
13:19:20 <kazagistar> > realPart ("Hello" :+ "There")
13:19:21 <lambdabot>  No instance for (GHC.Float.RealFloat [GHC.Types.Char])
13:19:21 <lambdabot>    arising from a use of ‘Data.Complex.realPart’
13:19:35 <rwbarton> ph88: in order for testComplex a = (3 :+ 2) to have type Complex a, 3 needs to have type a
13:19:44 <spopejoy> > fst(,)
13:19:45 <lambdabot>  Couldn't match expected type ‘(a, b0)’
13:19:45 <lambdabot>              with actual type ‘a0 -> b1 -> (a0, b1)’
13:19:56 <rwbarton> ph88: that means a needs to be an instance of Num
13:20:01 <quchen> > let (r :+ _) = "Hello" :+ "World" in r
13:20:02 <lambdabot>  "Hello"
13:20:05 <spopejoy> n-dolio: thanks
13:20:42 <ph88> roger
13:20:59 <ph88> ill makes notes ^^
13:21:38 <spopejoy> fst, snd better than ‘uncurry’ to my eyes
13:21:52 <spopejoy> with liftM2. nice.
13:29:35 <ph88> testComplex :: RealFloat a => Complex a -> Complex a    testComplex a = (realPart a) :+ (imagPart a)    testComplex (1.12 :+ 1.34)    Couldn't match expected type `[a0]' with actual type `Complex a1'
13:29:41 <ph88> why do i get this message ?
13:31:44 <ph88> where does a0 come from anyway
13:32:29 <quchen> Paste your code somewhere?
13:32:42 <quchen> The actual code, that is
13:32:46 <quchen> The one you ran
13:32:54 <quchen> ?paste
13:32:54 <lambdabot> Haskell pastebin: http://lpaste.net/
13:35:09 <eacameron> what's the common library for parsing and dealing with dates/times/etc
13:36:41 <glguy> eacameron: Have you looked at http://hackage.haskell.org/package/time-1.4.2/docs/Data-Time-Format.html
13:37:02 <eacameron> glguy: no, I'll look at that. This is my first need of doing date stuff
13:48:59 <ph88> hhmm quchen left. Anyway here is my paste http://lpaste.net/5989239711388925952
13:50:35 <glguy> ph88: That paste looks pretty incomplete, you've got a stray "in". Also you're trying to mapM_ print  a Complex
13:51:02 <glguy> it might be worth reading the error message you pasted and asking specific questions about which part you didn't understand
13:52:10 <michaelt> ph88: you don't need mapM_ since you only have one thing, not a list.
13:52:39 <michaelt> ph88: just  :  main = \print $ testComplex (1.12 :+ 1.34)
13:52:43 <glguy> It's probably more useful to ph88 to make sense of the error message in this case
13:53:06 <ph88> hhmm this code works outside of the main program -___-
13:53:07 <michaelt> right that's what I was doing. He doesn't have a list, but ghc wants one.
13:53:31 <ph88> the problem was the MapM_
13:53:45 <ph88> so where does the a0 come from ?
13:54:29 <michaelt> ph88: from mapM. The typechecker sees mapM and looks for a list, but it doesn't know what it would be a list of
13:54:50 <ph88> but why not [a] instead of [a0]  ?
13:55:03 <ph88> a0 = the first occurence of a ?
13:55:05 <michaelt> ph88: oh, pure compiler complexity
13:55:05 <rwbarton> why not [a0] instead of [a]?
13:55:39 <josephle> all about generating unique type variables I assume
13:55:47 <GeraldCode> Hello, how would one concatenate two symbols of type (Maybe String)?
13:56:00 <GeraldCode> with of course the possibility of getting a nothing
13:56:02 <michaelt> liftM2 (++) ?
13:56:11 <Exio> how could i make a function 'strict as' "mapM_ (putStrLn) $ foo x" without making it printing anything to screen? (i'd like to profile some parts of the app and keep the 'strict-ness' in some parts)
13:56:17 <GeraldCode> oh, thinks..I knew I saw something to do it, but couldnt remember
13:56:18 <GeraldCode> thanks
13:57:07 <GeraldCode> I should reread the chapter in LYAH about lifting...
13:57:07 <rwbarton> mapM_ (evaluate . length) $ foo x -- would be one way
13:57:15 <josephle> GeraldCode: you could also use mappend, as String is a monoid
13:57:56 <GeraldCode> josephle,  hello..yeah that was my first thought actually , but I got stuck because I forgot how to take the strings out  of the maybe context
13:58:15 <michaelt> > (<>) <$> Just "Hello" <> Just " World"
13:58:17 <lambdabot>  Just <[Char] -> [Char]>
13:58:19 <michaelt> oh
13:58:24 <michaelt> > (<>) <$> Just "Hello" <*> Just " World"
13:58:25 <lambdabot>  Just "Hello World"
13:58:38 <GeraldCode> hmm I havent seen (<>) before
13:58:42 <GeraldCode> at least I dont remember it
13:58:43 <ion> It’s just mappend
13:58:45 <michaelt> it's mappend
13:58:46 <josephle> that's the operator for mappend
13:58:47 <GeraldCode> ojjj
13:58:48 <GeraldCode> ohhh
13:59:01 <GeraldCode> thanks :)
13:59:37 <michaelt> one advantage over (++) for Strings as in the case you mentioned is you can easily go over to `text` when the time comes...
13:59:46 <GeraldCode> Is this the preferred way? is there nothing that automagically will concaenate to Maybe Strings together and hide the details from me?
13:59:52 <GeraldCode> ok
13:59:59 <ph88> how can i delimit multiple type classes? parse error on input `,'    testComplex :: RealFloat a, Integral b => Complex a -> Complex b
14:00:08 <joshc> You don't even have to use the applicative instance, because there is an instance (Monoid a) => Monoid (Maybe a)
14:00:11 <ion> > Just "foo" <> Just "bar" <> Nothing
14:00:12 <lambdabot>  Just "foobar"
14:00:15 <josephle> ph88: need parens around your constraints
14:00:23 <josephle> (RealFloat a, Integral b)
14:00:25 <michaelt> oh I forgot that instance
14:00:28 <GeraldCode> oh nice ion
14:00:31 <michaelt> that's the right answer
14:00:35 <GeraldCode> that looks like the ticket
14:00:35 <GeraldCode> thanks
14:00:45 <ph88> thx josephle
14:01:00 <ion> > (\a b c -> a ++ b ++ c) <$> Just "foo" <*> Just "bar" <*> Nothing
14:01:01 <lambdabot>  Nothing
14:01:12 <ion> Note the difference between the Applicative instance and the Monoid one.
14:01:16 <kini> GeraldCode: do you just want to treat Nothing as an empty string when concatenating, or do you want to make the whole thing Nothing?
14:01:23 <kini> yes, as ion says
14:01:36 <GeraldCode> ion, yeah huge difference
14:01:44 <GeraldCode> to me anyway
14:01:52 <GeraldCode> kini, well hmm good question
14:02:04 <GeraldCode> I guess I want empty strings and Nothings to be distinct
14:02:25 <ion> I was referring to the difference in behavior.
14:02:36 <GeraldCode> kini, oh
14:02:40 <GeraldCode> ion I mean
14:02:46 <GeraldCode> yes I took anothe rlook
14:02:51 <GeraldCode> the latter will give you Nothing
14:02:55 <GeraldCode> which is probably what I want
14:03:13 <GeraldCode> BEcause I dont think its right to treat Nothing like an empty string...I do that in PHP all the time and it feels wrong
14:03:26 <michaelt> There would still be the difference, but <> doesn't use it
14:03:41 <GeraldCode> ok
14:04:55 <GeraldCode> So what is the theoretical basis for the difference in behavior between the monoid and applicative versions?
14:05:12 <Exio> neat, i'll force it to evaluate
14:05:40 <GeraldCode> not sure if my question makes sense
14:06:01 <ion> geraldcode: Just like 0 + x = x and 1 * x = x, mempty <> Just x = Just x.
14:06:22 <ion> That’s a monoid law.
14:06:28 <GeraldCode> oh right
14:06:33 <GeraldCode> identities ?
14:06:49 <GeraldCode> Now I remember
14:06:58 <GeraldCode> it is fundamental to the concept of monoid to work that way
14:07:12 <michaelt> > Nothing <|> Just "hello" <|> Nothing <|> Just "world"
14:07:14 <lambdabot>  Just "hello"
14:07:59 <GeraldCode> hmm
14:08:02 <GeraldCode> oh
14:08:06 <GeraldCode> the firt 2 become Nothing
14:08:09 <GeraldCode> then you hit another Nothing
14:08:13 <GeraldCode> then you hit Just "world"
14:08:50 <GeraldCode> > Just 4 <|> Just 56 <|> Nothing
14:08:51 <lambdabot>  Just 4
14:08:54 <michaelt> after the first success, here Just "hello", the alternative instance is done.
14:08:56 <michaelt> right
14:08:59 <GeraldCode> I see
14:09:11 <GeraldCode> ahh..short circuit type deal
14:09:26 <jle`> > Just 5 <|> Just (sum [1..])
14:09:27 <lambdabot>  Just 5
14:09:28 <michaelt> I think it's arranged so that is the right picture, yeah
14:09:29 * hackagebot htsn-import 0.0.9 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.0.9 (MichaelOrlitzky)
14:11:19 <jle`> > ala First [Just 1, Just 2, Nothing]
14:11:21 <lambdabot>  Couldn't match expected type ‘(Control.Lens.Wrapped.Unwrapped
14:11:21 <lambdabot>                                   (Data.Monoid.First b)
14:11:21 <lambdabot>                                 -> Data.Monoid.First b)
14:11:21 <lambdabot>                                -> e -> Data.Monoid.First b1’
14:11:21 <lambdabot>              with actual type ‘[Data.Maybe.Maybe a0]’
14:11:28 <chrisdone> :t ala
14:11:29 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
14:11:46 <flebron> Hi. Is there any way, without a newtype, to have type Bar = Foo, type Baz = Foo, and an instance C Bar and instance C Baz?
14:12:02 <jle`> > ala First foldMap [Just 1, Just 2, Nothing]
14:12:04 <lambdabot>  Just 1
14:12:09 <jle`> > ala Last foldMap [Just 1, Just 2, Nothing]
14:12:10 <lambdabot>  Just 2
14:12:26 <TheKing444> :t ala
14:12:27 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
14:13:51 <michaelt> There's a lens signature for you....
14:14:26 <michaelt> >  catMaybes [Nothing, Just "hello " , Nothing, Just "world"]
14:14:27 <jle`> the signature isn't actually too lensy
14:14:28 <lambdabot>  ["hello ","world"]
14:14:45 <michaelt> no is in the newtype library, I remember
14:14:58 <jle`> i'm not sure which one lambdabot uses...
14:15:02 <jle`> i mean the lenses are still here
14:15:07 <michaelt> jle`: I meant its in the newtype library.
14:15:16 <michaelt> lambdabot uses the lens one
14:15:30 <michaelt> I mean the `ala`
14:15:38 <jle`> > view _Unwrapped 5 :: Sum Int
14:15:39 <lambdabot>  Sum {getSum = 5}
14:15:51 <jle`> it seems that the wrapped/unwrapped lenses are all here
14:15:55 <jle`> and lens provides ala i think as well
14:16:00 <michaelt> right
14:16:10 <jle`> hm
14:16:32 <michaelt> lambdabot used to have `newtype` if I remember, but then came the lenses.
14:16:48 <jle`> haha
14:16:53 <jle`> "but then came the lenses"
14:17:02 <jle`> ...something that will be said of literally everything in haskell
14:17:31 <GeraldCode> are lenses just "cool" or do they help you a lot?
14:17:46 <jle`> they help you a lot
14:17:50 <GeraldCode> ok
14:18:27 <GeraldCode> its weird how new concepts like that appear long after the language was created
14:18:33 <spopejoy> are lenses useful w/o TH?
14:18:37 <GeraldCode> interesting also :)
14:18:37 <jle`> spopejoy: yes
14:18:40 <ion> spopejoy: yes
14:18:41 <jle`> i don't use any TH for my lenses
14:18:49 <jle`> lens actually doesn't hav emuch to do with TH...
14:18:57 <jle`> i think that's a misconception that is pretty prevalent for some reason
14:18:58 * jle` wonders
14:19:12 <GeraldCode> oh thats another thing...
14:19:22 <jle`> GeraldCode: it's neat, yeah :)  that the language has enough power that we are still finding new ways to express things and new abstractions all the time
14:19:29 <GeraldCode> So from what I have read here and on the yesod website..TH breaks all the rules about type safety
14:19:34 <rasfar> makeLenses
14:19:36 <josephle> it's a nice way of getting lenses for records, but not in anyway necessary
14:19:36 <jle`> but it's not like imperative people have stopped inventing new data structures, right?
14:19:44 <GeraldCode> jle, yeah...its like math itself I guess
14:19:50 <GeraldCode> jle, true
14:19:55 <jle`> we're still inventing new data structures... fifty or sixty years after computers
14:19:55 <ion> geraldcode: The code that is generated by TH code will be type-checked as usual.
14:20:25 <GeraldCode> ion, yeah thats what yesod website says..they say it only is weird to create the TH itself
14:20:29 <GeraldCode> but the users of it have no issues
14:21:37 <GeraldCode> ion, so one shouldnt create TH unless they know what they are doing I guess
14:22:01 <josephle> I think the same can be said of any macro system
14:22:07 <GeraldCode> yeah
14:22:24 <GeraldCode> yeah, I mean..take even a non macro system/.take PHP
14:22:32 <GeraldCode> in the wrong hands you can make so many mistakes
14:22:36 <GeraldCode> thats what I imagine TH is like
14:22:58 <ion> B-but i don’t want to take PHP
14:23:01 <spopejoy> lens w/o TH, does that involve getter/setter boilerplate?
14:23:12 <GeraldCode> lol, good idea ion
14:23:12 <chrisdone> yesod's TH is mostly boiler plate removal
14:23:15 <GeraldCode> it's really bad
14:23:21 <chrisdone> generating routes and data types that are pointless to write out
14:23:28 <josephle> TH is more akin to #defines and lisp macros, but deliberately scarier so people won't touch it as readily
14:23:28 <GeraldCode> ok chrisdone
14:23:38 <josephle> at least that's my interpretation
14:23:41 <GeraldCode> is that all it is?
14:23:44 <GeraldCode> just a preprocessor?
14:23:55 <chrisdone> no it's similar to lisp
14:23:57 <shachaf> spopejoy: Well, usually combined "mapMer" boilerplate.
14:24:07 <GeraldCode> yeah dont know lisp
14:24:10 <vanila> you can embed entire new languages with their own syntax into haskell with it
14:24:21 <GeraldCode> but it expands custom syntax into haskell code?
14:24:42 <spopejoy> snap’s init program makes interesting use of TH to basically dump an entire directory tree into an executable.
14:24:43 <chrisdone> in lisp a macro is called with (foo bar), in haskell it's $(foo bar)
14:24:49 <ion> Lisp macros are arguably more enjoyable to write than TH actions.
14:25:20 <chrisdone> quasiquotes in lisp are `(foo ,unq ,@splice), in haskell it's [|foo $(unq) $(unq)|]
14:25:36 <chrisdone> ion: i'd agree to that, and more enjoyable to use
14:26:02 <spopejoy> lisp macros are dangerous as well though. the general feeling is they make code unapproachable by mortals
14:26:12 <ion> Lisp is especially suitable for that because code basically is already the AST.
14:26:14 <bitemyapp> that's not really the main problem with macros.
14:26:57 <vanila> there are different lisp macro systems
14:27:04 <vanila> some scarier than others
14:27:26 <vanila> there is a simple pattern matching and substitution one
14:27:41 <chrisdone> scheme's is cleaner but hard to write in
14:28:06 <vanila> haskells lazyness allows you to define a lot of things as functions, which would be macros otherwise
14:28:21 <GeraldCode> vanila, example please
14:28:27 <chrisdone> :t when
14:28:27 <lambdabot> Monad m => Bool -> m () -> m ()
14:28:28 <GeraldCode> not questioning you,m just dont know
14:28:35 <vanila> GeraldCode, if/then/else is one, parser combinator libraries is a more involved example
14:28:56 <GeraldCode> I see
14:29:15 <spopejoy> clojure macros offer some nice things, mainly the # gensym stuff.
14:29:34 <spopejoy> of course some people will rant that clojure’s not a lisp
14:29:48 <GeraldCode> no more than f# is caml I guess
14:29:49 <chrisdone> who rants that?
14:30:01 <spopejoy> some smug lisp weenies on HN
14:30:11 <chrisdone> oh, smug lisp weenies gonna ween
14:30:30 <spopejoy> ‘spretty hilarious. clojure is lisp FTW and yet SLW’s whine
14:30:50 <vanila> solution: stop reading HN
14:30:50 <GeraldCode> but wait
14:30:51 <bitemyapp> spopejoy: Clojure is more like a Scheme with unified namespace and lisp macros than a Lisp.
14:31:00 <GeraldCode> there have been attempts to make Haskell.NET and HAskell on the JVM
14:31:04 <GeraldCode> what would you think of that?
14:31:10 <chrisdone> bitemyapp: unified namespace?
14:31:13 <spopejoy> bitemyapp: now we’re talking.
14:31:14 <bitemyapp> chrisdone: Lisp-1
14:31:21 <bitemyapp> spopejoy: a lot of what made Lisp, Lisp was the interactivity, debugging, etc. - stuff that inspired Smalltalk. None of that exists in Clojure.
14:31:23 <chrisdone> scheme isn't a lisp-1?
14:31:27 <bitemyapp> er, sorry
14:31:29 <bitemyapp> I derped.
14:31:35 <bitemyapp> Clojure is more like a scheme with Lisp macros
14:31:37 <chrisdone> ohk
14:31:41 <bitemyapp> there.
14:31:53 <tac-tics> chrisdone: lisp-1.... I haven't heard that term in a long time >_>
14:32:00 <bitemyapp> I still have more Clojure than Haskell on my github. The only reason I haven't deleted the repos and clojars is because friends of mine use my libraries.
14:32:14 <chrisdone> tac-tics: i was reading the lisp-1 manual the other day :3
14:32:16 <bitemyapp> jle`: you're too late! I've seen past your cloak :)
14:32:33 <spopejoy> My SLW cred isn’t deep enuf to say clojure isn’t a lisp. My background is elisp :)
14:32:33 <jle`> ;_;
14:32:34 <bitemyapp> I'm a believer in burn-your-ships.
14:32:42 <bitemyapp> spopejoy: CL, Elisp, and Clojure in my case.
14:32:44 <jle`> im naked
14:32:44 <vanila> elisp is the worst language
14:32:45 <chrisdone> tac-tics: (was trying to see whether it had QUOTE back in the original lisp)
14:32:53 <chrisdone> for me, lisp is all about dat quote
14:33:05 <ruuns> vanila: Can you really compare lazyness with macros? I always thought macros are used in the compile step where lazyness seems to move the problem to the runtime system.
14:33:08 <tac-tics> The original lisp had quote, I believe. Lisp is nothing without quote.
14:33:20 <bitemyapp> ruuns: laziness replaces some use-cases for macros but they are not the same thing and laziness doesn't cover all of it.
14:33:22 <tac-tics> well, it's just noisey lambda calculus without it.
14:33:31 <chrisdone> quasiquotes, macros, etc. are all just convenient ways to do what you can do with QUOTE
14:33:32 <bitemyapp> ruuns: the more compelling reasons for laziness have to do with function composition, fusion.
14:33:33 <spopejoy> my drift toward haskell from lisp is i need types. lisp with types is no fun.
14:33:45 <bitemyapp> spopejoy: that's why I burnt my ships in Clojure and jumped over.
14:33:50 <bitemyapp> spopejoy: I wanted real FP with types.
14:33:56 <chrisdone> spopejoy: no like Shen?
14:33:56 <bitemyapp> not pseudo-FP because we have something called "map"
14:34:06 <bitemyapp> chrisdone: come on. Shen is unabomber-mode.
14:34:21 <vanila> ruuns, In scheme if you tried to define a procedure (define (if b t e) ...) it would evaluate the 'then' AND 'else' cases
14:34:32 <vanila> ruuns, so scheme needs if built-in or defined by a macro
14:34:50 <vanila> ruuns, but in haskell you can add new language constructs like 'if' just by writing them as functions
14:34:56 <spopejoy> chrisdone: dunno Shen
14:35:04 <chrisdone> spopejoy: it's the new name for Qi
14:35:08 <chrisdone> if that helps
14:35:14 <spopejoy> it doesn’t :)
14:35:26 <chrisdone> some lisp with dependent types
14:35:37 <bitemyapp> chrisdone: I didn't know they were dependent.
14:35:56 <EvanR_> vanila: if evaluating a pure non bottom expression, it should matter if its lazy or not ;)
14:36:05 <EvanR_> evaluate everything!
14:36:16 <spopejoy> again, lisp with types is a drag. in fact clojure is kind of a drag. if parens aren’t enough syntax for you, then you shouldn’t be lisping.
14:36:30 <vanila> ruuns, it's a good point to raise the question about compile time vs run time but
14:36:33 <bitemyapp> spopejoy: enough about impractical languages :)
14:36:38 <spopejoy> :)
14:36:41 <ph88> > let roundDec :: (Fractional a, Integral b) => a -> b -> a;  roundDec numb deci = ((round $ numb * deci)) / deci $ roundDec 1.23 10
14:36:42 <lambdabot>  not an expression: ‘let roundDec :: (Fractional a, Integral b) => a -> b -> ...
14:36:51 <EvanR_> impractical programming paradigm
14:36:59 <ph88> > roundDec :: (Fractional a, Integral b) => a -> b -> a;  roundDec numb deci = ((round $ numb * deci)) / deci $ roundDec 1.23 10
14:37:00 <lambdabot>  <hint>:1:54: parse error on input ‘;’
14:37:07 <vanila> compilers may do partial evaluation to recover the compile-time execution
14:38:13 <vanila> I was only talking about the semantics
14:38:30 <spopejoy> chrisdone: dependent types == subtypes?
14:38:35 <ph88> can someone tell me what am i doing wrong here?  http://lpaste.net/6979151702280634368
14:39:02 <bitemyapp> spopejoy: not precisely.
14:39:09 <dwcook> ph88, the user could choose different a and b, but (*) in numb * deci requires that they be the same type
14:39:14 <spopejoy> does haskell have either? :)
14:39:24 <bitemyapp> spopejoy: you can replace some of what you would want subtype'ish stuff for by using fibration/path spaces/type families in dependently typed languages
14:39:29 <bitemyapp> spopejoy: but it's a vaster universe than that.
14:39:37 <ruuns> vanila, i see :) i'm also having the (define-macro ..) (define-syntax) constructs in mind, which i always see as compile-time template transformation of the source code.
14:39:44 <mmachenry> Isn't there a way to unpack all of the names of a data type within a pattern match? So I can do foo (MyThing..) = and have all the named fields of MyThing bound to the accessor?
14:39:52 <dwcook> ph88, try fromIntegral deci
14:39:58 <dwcook> numb * fromIntegral deci
14:40:04 <mmachenry> Is this a language extension? I saw this at a Haskell meetup once and now I don't know the words to search for it :)
14:40:09 <dwcook> Oops, misread
14:40:12 <arancia> :t let roundDec numb deci = (round $ numb * deci) / deci in roundDec
14:40:13 <lambdabot> (RealFrac a, Integral a) => a -> a -> a
14:40:18 <dwcook> Wait, no I didn't
14:41:10 <chrisdone> bitemyapp: actually i don't know that they're dependently typed, just turing complete, never really looked at it
14:41:41 <vanila> turing complete -> inconsistent
14:41:52 <spopejoy> any relation btwn dependent types and existential types?
14:42:56 <josephle> an existential type can be represented as a dependent sum, I think
14:42:56 <chrisdone> i thought i remembered seeing some thing like type-safe vectors and proofs on numbers and stuff, but looking at the site again, i don't see it
14:44:48 <spopejoy> shen looks cool. but you wanna go with a winner, know’msayin?
14:44:55 <bitemyapp> chrisdone: their attitude on C-H-L is pretty annoying.
14:45:13 <bitemyapp> chrisdone: they're equivalently powerful due to turing completeness but not strictly speaking dependently typed.
14:45:40 <bitemyapp> chrisdone: you'd be doing something like http://strictlypositive.org/Easy.pdf it seems/
14:46:11 <vanila> bitemyapp, isn't it unsound though? Since you can extend the type system with non-sensical things
14:46:36 <bitemyapp> vanila: right. That's turing-completeness for you.
14:47:37 <vanila> but a proper type system should be sound, so that your programs have meaning and don't crash etc.
14:47:54 <kini> having a turing complete language in the type system doesn't *have* to make the type system unsound, does it?
14:47:55 <chrisdone> bitemyapp: it's nice that the dependent types simplify thought and implementation in many ways
14:48:20 <bitemyapp> kini: the fixed point of that sentiment is using assembler.
14:48:21 <jle`> well it means your type system is potentially non-halting
14:48:24 <kini> in the sense that if the type checker terminates, then your have safety properties
14:48:31 <kini> *you
14:48:38 <bitemyapp> chrisdone: aye.
14:48:48 <bitemyapp> chrisdone: I still like things like Holey Monoids for Formatting better than relying on DTs.
14:48:53 <bitemyapp> chrisdone: maybe I'm backwards.
14:48:57 <chrisdone> yeah?
14:49:02 <bitemyapp> more elegant IMO
14:49:14 <johnw> holy monoids, batman!
14:49:17 <chrisdone> lol
14:49:30 <chrisdone> bitemyapp: there's the easily-extensible part, i guess
14:49:31 <bitemyapp> don't get me wrong, printf in Idris is hella neat, but I like the way Formatting works better.
14:49:51 <kini> mmachenry: looks like -XRecordWildCards (?)
14:49:58 <kini> see https://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards
14:50:07 <bitemyapp> @karma+ kini
14:50:08 <lambdabot> kini's karma raised to 1.
14:50:17 <vanila> @karma+ holey monoids
14:50:18 <lambdabot> holey's karma raised to 1.
14:50:28 <chrisdone> @quote monoids
14:50:28 <lambdabot> shachaf says: edwardk will try to get you addicted to monoids. The first one is always free.
14:50:40 <edwardk> hah
14:50:52 <GeraldCode> so ive read monoids are good for representing infinite data structures
14:50:54 <isomorpheous> You have to admit, monoids are pretty awesome
14:50:58 <GeraldCode> what else are they generally used for?
14:51:04 <chrisdone> what's not to love?
14:51:06 <MP2E> Monoids are great for so many things
14:51:13 <isomorpheous> GeraldCode: Anything that acts like a list, but isn't actually a list
14:51:20 <GeraldCode> I dunno, I have a hard time figuring out why we do some things
14:51:23 <mmachenry> Thanks, kini
14:51:25 <isomorpheous> GeraldCode: because singly linked lists are hilarously inefficient
14:51:28 <GeraldCode> isomorpheous,  oh
14:51:37 <GeraldCode> thats a good explanation
14:51:38 <kini> mmachenry: sure - is that what you were looking for? I wasn't quite sure
14:51:39 <isomorpheous> GeraldCode: for instance, lists are a monoid
14:51:40 <GeraldCode> they are good for efficiency?
14:51:43 <ph88> dwcook: i got that one working, but what about this one ?  http://lpaste.net/2725178228443447296
14:51:45 <chrisdone> that's an ok approximation but list-like is just one
14:51:54 <chrisdone> there're all sorts of monoids
14:52:00 <chrisdone> someone should compile all of hackage and find all the monoids
14:52:03 <bitemyapp> isomorpheous: GeraldCode they're the free monoid.
14:52:17 <isomorpheous> GeraldCode: they don't provide efficiency in themselves. They're just a way of saying that "this behaves like a list"
14:52:26 <GeraldCode> OH!
14:52:27 <GeraldCode> ok
14:52:32 <GeraldCode> so its just a generalization
14:52:37 <kini> yup
14:52:38 <GeraldCode> saying my non-list can kind of seem like one
14:52:49 <bitemyapp> chrisdone: https://github.com/search?q=instance+Monoid+where&type=Code&ref=searchresults
14:52:51 <kini> well, can "kind of seem like one" in some pretty specific ways
14:52:57 <GeraldCode> ok
14:52:58 <bitemyapp> GeraldCode: Monoids are an algebra.
14:53:01 <bitemyapp> :info Monoid
14:53:05 <bitemyapp> sigh, really?
14:53:10 <bitemyapp> :t mappend
14:53:11 <lambdabot> Monoid a => a -> a -> a
14:53:15 <bitemyapp> :t mempty
14:53:16 <lambdabot> Monoid a => a
14:53:21 <isomorpheous> GeraldCode: For instance, Text is a monoid. Text is basically a more-efficient String representation. It's not a list, though.
14:53:21 <jle`> GeraldCode: there's a nice byorgey paper on why monoids are so neato
14:53:21 <chrisdone> > Sum 2 <> Sum 4
14:53:23 <lambdabot>  Sum {getSum = 6}
14:53:23 <bitemyapp> GeraldCode: ^^ that plus associativity and identity.
14:53:27 <chrisdone> > Product 2 <> Product 4
14:53:28 <lambdabot>  Product {getProduct = 8}
14:53:32 <chrisdone> ^ not really list-like
14:53:35 <GeraldCode> ok
14:53:38 <bitemyapp> > mappend [1, 2, 3] []
14:53:40 <lambdabot>  [1,2,3]
14:53:44 <bitemyapp> > mappend [] [1, 2, 3]
14:53:45 <lambdabot>  [1,2,3]
14:53:48 <bitemyapp> identity.
14:53:50 <GeraldCode> so you can use text in an intuitive way, because it implements monoid
14:53:50 <spopejoy> I need to understand Sum and Product better
14:53:52 <isomorpheous> GeraldCode: mempty, mappend, and mconcat are the list operations
14:53:57 <bitemyapp> spopejoy: they're just newtypes
14:54:01 <isomorpheous> GeraldCode: *monoid operations
14:54:05 <spopejoy> I mean the concepts
14:54:08 <chrisdone> spopejoy: they're just newtype wrappers that make a + or * instance of Monoid
14:54:10 <jle`> spopejoy: do you see that the integers for a monoid under (+), with 0 as the identity?
14:54:17 <GeraldCode> ok bitemyapp
14:54:19 <spopejoy> yep
14:54:19 <bitemyapp> spopejoy: the newtype lets you choose which valid monoid for numbers you want.
14:54:23 <jle`> spopejoy: do you see that the integers for a monoid under (*), with 1 as the identity?
14:54:24 <isomorpheous> GeraldCode: for lists, those are, respectively, [], (++), and concat
14:54:27 <chrisdone> instance Monoid Product where Product x <> Product y = Product (x * y)
14:54:27 <chrisdone> easy
14:54:29 <jle`> so...which monoid instance do we pick for numbers?
14:54:36 <bitemyapp> jle`: you pick, with newtype.
14:54:39 <spopejoy> Sum or Product, yep.
14:54:40 <chrisdone> jle`: multiplication!
14:54:40 <bitemyapp> oh woops
14:54:42 * chrisdone runs for the hills
14:54:43 <bitemyapp> you were explaining
14:54:48 <jle`> oops
14:54:53 <quchen> chrisdone: minBound and max!
14:55:02 <spopejoy> Where I lose it is Sum or Product applied to things other than the number line
14:55:05 <chrisdone> quchen: you saw the augustsson post? =p
14:55:11 <quchen> No?
14:55:14 <chrisdone> :(
14:55:27 <jle`> spopejoy: well, look at the definition of the Sum/Product monoid instance
14:55:38 <isomorpheous> GeraldCode: Here, this should clear it up for you: monads are just monoids over the category of endofunctors
14:55:41 <jle`> instance Num a => Monoid (Sum a) where
14:55:47 <chrisdone> spopejoy: like what?
14:55:49 <spopejoy> :)
14:55:53 <dwcook> ph88, func cannot be applied because there is no a available. Perhaps you meant to make it have type b -> b
14:55:53 <quchen> chrisdone: Or the silly monoid, instance Monoid Int where mempty = 1; _ <> _ = 1
14:55:53 <GeraldCode> isomorpheous,  good one :)
14:55:54 <spopejoy> what’s the problem?
14:55:54 <jle`>     Sum x <> Sum y = Sum (x + y)
14:56:15 <jle`> spopejoy: so it just works on any Num
14:56:18 <jle`> aka anything that implements (+)
14:56:25 <GeraldCode> isomorpheous,  I do plan to read a book onm category theory one day
14:56:28 <isomorpheous> GeraldCode: the thing is, if you know about mon(a|oi)ds, that makes perfect sense, sadly enough
14:56:32 <GeraldCode> But it sounds like PhD level stuff
14:56:41 <jle`> there are...various Num instances that can't really be said to directly represent numbers
14:56:42 <ph88> thx dwcook now that i think about it it makes sense that it should also be b!
14:56:43 <isomorpheous> GeraldCode: nah, I'm just an undergrad
14:56:47 <spopejoy> from diehl’s “WIWIKWIWLH”: “The usual hand-wavy of describing algebraic datatypes is to indicate the how natural correspondence between sum types, product types, and polynomial expressions arises.”
14:56:48 <jle`> GeraldCode: nah, high school level
14:56:50 <jle`> GeraldCode: at best
14:56:54 <GeraldCode> isomorpheous,  I dont understand the theory, but I DO understand how to use monads, and for the most part why they are useful
14:56:58 <spopejoy> what’s a sum type, product type? waah
14:56:58 <ij> What does the forall part in "logic :: (forall r. (a -> r -> r) -> r -> r) -> Logic a" do?
14:56:59 <GeraldCode> jle, really?
14:57:04 <chrisdone> i'd characterize CT more in the level of ``abstract bullshite''™ than PhD-level
14:57:12 <MP2E> heh
14:57:18 <jle`> GeraldCode: yes, it's not really that complicated
14:57:22 <GeraldCode> ok
14:57:27 <chrisdone> (i'm quoting here)
14:57:33 <GeraldCode> jle, well the symbols confuse me, and the terminology
14:57:33 <jle`> also it's not really that directly useful to Haskell at most levels, anyway
14:57:38 <vanila> spopejoy, data Sum = A A | B B | C C | D D is the sum of the types A,B,C,D,   data Product = Pr A B C D is the product of the types A,B,C,D
14:57:40 <GeraldCode> I did  pretty well in math..took 3 levels in college
14:57:44 <josephle> well, their concrete examples can be pretty annoying without *some* college math
14:57:45 <jle`> GeraldCode: ah.  well, you don't have to be smart to understand symbols.
14:57:48 <jle`> they're just symbols
14:57:50 <GeraldCode> but I just have a hard time reading the wikipedia articles on math
14:58:02 <MP2E> But yeah let's break that sentence down. "Monads are monoids in the category of endofunctors" => "Monads are monoids formed [Dby Haskell functors"
14:58:03 <GeraldCode> 3 levels calc I mean
14:58:04 <jle`> i taught a kindergardener once what (+) meant
14:58:07 <vanila> spopejoy, it's called that because the number of elements is the sum (resp. product) of the number of elements
14:58:11 <jle`> at first it was a weird symbol to them
14:58:11 <josephle> but CT is more of a language, as my teacher once said
14:58:14 <isomorpheous> GeraldCode: where are you, math-wise?
14:58:15 <jle`> but after a while...they understood it
14:58:25 <jle`> later on i taught them the minus sign too
14:58:30 <ruuns> Does anyone know a method how i can fold a list of [m Bool] with e.g. any function [Bool] -> Bool  and returns m Bool in the end?
14:58:32 <chrisdone> jle`: oh, yeah, then what does… THIS mean? .̺̜͇͡ͅ
14:58:32 <jle`> and at first they said 'this symbol is too weird'
14:58:32 <kini> ij: polymorphic types in haskell have an implicit "forall" at the very outside; the -XRankNTypes language extension allows you to put them inside parenthesized expressions within a type, too
14:58:32 <kini> ij: are you familiar with polymorphic types generally?
14:58:38 <jle`> after a while, they were o k
14:58:41 <dwcook> spopejoy, in Haskell, Either represents the sum of types and (,) the product
14:58:50 <GeraldCode> isomorpheous,  I was once pretty good...I still understand integrals and derivitives..
14:58:55 <jle`> chrisdone: somehow you have managed to make a weird smudge on my screen
14:58:59 <jle`> that moves with the irc client
14:59:01 <jle`> and i can't scrape it off
14:59:02 <dwcook> Either Int String is like Int + String, (Int, String) is Int × String
14:59:05 <chrisdone> jle`: hahaha
14:59:12 * chrisdone cackles in triumph
14:59:14 <GeraldCode> jle ok
14:59:23 <ij> kini, I might be, I don't know what polymorphic means in this case.
14:59:26 <isomorpheous> GeraldCode: ah, okay, I take it you aren't a student
14:59:31 <ij> I used to know what it meant in OOP once.
14:59:33 <jle`> GeraldCode: a symbol isn't inherently difficult
14:59:41 <isomorpheous> GeraldCode: this shit only started to make sense for me when I took a class on algebraic geometry
14:59:44 <kini> ij: so, you're comfortable with types like "map :: (a -> b) -> [a] -> [b]"?
14:59:47 <GeraldCode> isomorpheous,  nah, I am about 15 years beyond that now...forgotten most of itr
14:59:50 <kini> ij: ah, in OOP it's a bit different
14:59:53 <jle`> the concept behind what the symbol represents might be difficult to understand
14:59:59 <jle`> but it's the concept, not the symbol
15:00:07 <GeraldCode> ok
15:00:10 <ij> kini, Yup, I am well aware of those.
15:00:16 <GeraldCode> Maybe what I needed was encouragement
15:00:16 <isomorpheous> بامي يامب فنبي قسنببخ اشسل بك هتلنسيبشتل مث خكه شسنتطب ش ةشبانةشبمؤمشت
15:00:20 <jle`> GeraldCode: you can do it :D
15:00:21 <isomorpheous> god dammit, sorry
15:00:21 <GeraldCode> I will try again
15:00:25 <isomorpheous> Switched to arabic
15:00:32 <spopejoy> so a product type can represent all of the type values at once, whereas a sum type can only represent one of the values at a time?
15:00:41 <ij> kini, Oh, and now that I looked up the def I'm sure.
15:01:00 <jle`> spopejoy: can you imagine why it relates to sum and product from traditional maths?
15:01:04 <kini> ij: so the real type of map there is actually "map :: forall a b. (a -> b) -> [a] -> [b]"
15:01:04 <kini> ij: which means that map works for any two types a and b, if you plug in those types for "a" and "b" in the rest of the type
15:01:06 <dwcook> spopejoy, right, although you can also have combinations thereof
15:01:35 <GeraldCode> jle, thanks :) after all I tried haskell twice before I started to make progress
15:01:40 <spopejoy> jle`: i can try but it might not go very well :)
15:01:41 <GeraldCode> so Ill just keep at it
15:01:52 <kini> ij: in haskell, the "forall a b." at the outside there is unnecessary because it's implicitly assumed, when you introduce the type variables 'a' and 'b' in the type (and in fact isn't even allowed unless you have -XRankNTypes turned on, iirc)
15:01:55 <jle`> spopejoy: think about it :)  it's a pretty neat thing
15:02:15 <jle`> one hint - think about the number of inhabitants of a type
15:02:33 <jle`> and then the number of inhabitants under a product, and a sum
15:02:42 <jle`> ...that might be too much of a hint
15:02:43 <ij> kini, Oh, okay. And why in my case is the forall embedded in brackets?
15:02:47 <dwcook> There's also a certain equation relating addition and multiplication that applies to types as well
15:02:57 <josephle> jle`, you gave it away! :)
15:02:58 <spopejoy> and a monoid?
15:03:02 <jle`> darnit!
15:03:13 <jle`> i should have said
15:03:18 <jle`> "under an Either, and a (,)"
15:03:18 <bitemyapp> kini: outermost forall is fine with Rank2
15:03:23 <spopejoy> don’t worry, he didn’t give it away for me. wtf is a type ‘inhabitant'
15:03:27 <bitemyapp> you don't need RankN for that
15:03:29 <jle`> because of the linguistically polymorphic definitions of product and sum
15:03:38 <dwcook> spopejoy, a value v of type T is said to inhabit T.
15:03:45 <jle`> spopejoy: number of values of that are of that type
15:03:53 <bitemyapp> kini: there's also ScopedTypevariables and ExistentialQuantification but that's a bit off to the side.
15:03:55 <jle`> spopejoy: for example, Bool has two inhabitants
15:03:56 <kini> ij: so, in "logic :: (forall r. (a -> r -> r) -> r -> r) -> Logic a", you have something a bit more complicated
15:03:56 <kini> ij: the type is saying, the 'logic' function takes a function which is itself known to be defined over all possible types 'r', and then produces a Logic a
15:03:56 <kini> ij: whereas if you had just written "logic :: ((a -> r -> r) -> r -> r) -> Logic a", or "logic :: forall r. ((a -> r -> r) -> r -> r)", then your 'logic' function would be able to accept a function only defined for a particular type r
15:03:58 <jle`> True and false
15:04:00 <jle`> False
15:04:08 <pjdelport> spopejoy: This 3-part series is a pretty good introduction and overview of the "algebraic" of algebraic data types: http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
15:04:09 <kini> bitemyapp: right, I thought Rank2 was deprecated though
15:04:23 <kini> ... and yup, it is, according to the ghc docs
15:04:29 <spopejoy> pjdelport: thanks
15:04:42 <bitemyapp> kini: I didn't know it was. Interesting.
15:04:50 <bitemyapp> kini: It makes sense, but surprises me a little.
15:05:02 <spopejoy> again, if there are sum and product types, is Hask a monoid?
15:05:04 <kini> the exact language doesn't say it's deprecated, just "obsolete"
15:05:12 <pjdelport> spopejoy: That shows why product types are related to multiplication, sum types are relate to addition, and even how function types are related to exponentiation.
15:05:13 <kini> " The obselete language options -XPolymorphicComponents and -XRank2Types are synonyms for -XRankNTypes. They used to specify finer distinctions that GHC no longer makes. (They should really elicit a deprecation warning, but they don't, purely to avoid the need to library authors to change their old flags specifciations.) "
15:05:14 <benzrf> spopejoy: under which operator?
15:05:15 <bitemyapp> spopejoy: Haskell types are a seminearring
15:05:20 <bitemyapp> spopejoy: IIRC
15:05:26 <benzrf> haskell types
15:05:27 <bitemyapp> spopejoy: I'd avoid making it about "Hask" here.
15:05:31 <jle`> seminearrings admit two monoids so...
15:05:42 <benzrf> haskell sum and product dont have inverses
15:05:48 <spopejoy> sorry, trying out category terminology and failing as usual
15:05:49 <shachaf> spopejoy: It's a monoidal category.
15:05:50 <benzrf> and identities are only isomorphic, not actual identities
15:05:50 <bitemyapp> benzrf: neither do monoids
15:05:54 <benzrf> other than that, it forms a ring
15:05:57 <jle`> oh wait no
15:05:58 <shachaf> That's probably what you're getting at.
15:06:20 <jle`> seminearrings admit two semigroups...one monoid
15:06:35 <bitemyapp> jle`: I see one monoid, one semigroup.
15:06:42 <jle`> well the monoid is also a semigroup
15:06:44 <benmachine> semin earrings
15:06:55 <GeraldCode> whats a semigroup?
15:06:56 <bitemyapp> S 0 +, S *
15:07:02 <dwcook> Someone just implied this but the equation I was talking about earlier is the distributive property, a(b+c) = ab+ac
15:07:03 <GeraldCode> how do I ask the bot?
15:07:11 <bitemyapp> @hoogle Semigroup
15:07:13 <lambdabot> package Semigroup
15:07:13 <lambdabot> package semigroupoid-extras
15:07:13 <lambdabot> package semigroupoids
15:07:17 <jle`> GeraldCode: a kind of like a monoid (associative combiner) but with no identity element
15:07:25 <jle`> common examples include Min/Max, or a non-empty list
15:07:27 <bitemyapp> GeraldCode: https://hackage.haskell.org/package/semigroups-0.15.2/docs/Data-Semigroup.html
15:07:34 <GeraldCode> ok thx
15:07:34 <bitemyapp> :t (<>)
15:07:35 <lambdabot> Monoid m => m -> m -> m
15:07:37 <bitemyapp> dammit.
15:07:44 <GeraldCode> jle, ok so help me understand
15:07:44 <jle`> GeraldCode: Min 3 <> Min 4 = Min 3
15:07:44 <bitemyapp> you get the idea.
15:07:49 <GeraldCode> why would I want it without identity?
15:07:50 <ij> kini, But when you ay "it takes a function known to be defined over all possible types 'r'", does it mean it is actually unbounded? What would be the point of this type then? It seems like it never gets inferred to anything then.
15:07:53 <jle`> Min (-1) <> Min 100 = Min (-1)
15:07:58 <jle`> what's the identity of Min ?
15:08:02 <GeraldCode> oh
15:08:04 <MP2E> you wouldn't *want* it without identity, but what if you don't have identity?
15:08:05 <GeraldCode> got it
15:08:18 <Jeanne-Kamikaze> when you just have nothing and want to pretend it's something, you just tackle 'semi' onto it
15:08:25 <spopejoy> jle`: if Boolean has two inhabitants, Sum can only have two inhabitants, but Product can have four
15:08:26 <kini> ij: the 'logic' function might want to use this inputted function on various different types within the definition of 'logic'
15:08:28 <MP2E> 'loose and fast reasoning is morally correct'
15:08:37 <benzrf> Jeanne-Kamikaze: negative infinity
15:08:37 <jle`> spopejoy: sum/product of what?
15:08:38 <MP2E> or however it goes
15:08:40 <benzrf> er, jle`
15:08:44 <spopejoy> Booleans
15:08:45 <vanila> spopejoy, sum is 4 and product is 4
15:08:47 <jle`> spopejoy: how many inhabitants are in Bool + Bool, and how many are in Bool * Bool ?
15:08:47 <GeraldCode> hmm
15:08:50 <kini> ij: so it would need the inputted function to be possible to use on multiple types
15:09:00 <jle`> spopejoy: remember, a sum is a *tagged* union, so Left True /= Right True
15:09:04 <vanila> 2 is the worst thing to choose here, lol
15:09:07 <jle`> benzrf: :P
15:09:14 <jle`> vanila: haha yeah >____>
15:09:18 <spopejoy> What is False + False?
15:09:26 <bitemyapp> > Sum 3 <> Sum 3
15:09:27 <lambdabot>  Sum {getSum = 6}
15:09:29 <jle`> spopejoy: we're talking about sums on the type evel
15:09:33 <jle`> let's keep it in Haskell words
15:09:34 <bitemyapp> > Product 3 <> Product 3
15:09:34 <spopejoy> ok
15:09:35 <lambdabot>  Product {getProduct = 9}
15:09:38 <MP2E> False + False? 'No instance for Num Bool'?
15:09:39 <jle`> (Bool, Bool) vs Either Bool Bool
15:09:42 <ij> kini, I would expect some restiction then, but this "no-restriction" restriction ristricts types available to an empty set, no?
15:09:47 <vanila> let's define |T| to tell you how many values there are of type T
15:09:54 <jle`> admittedly Bool isn't a good example because both of these have the same number of inhabitants
15:09:57 <kini> ij: I'm not sure what you mean
15:09:59 <jle`> how about
15:10:00 <vanila> then |Either T T'| = |T|+|T'|
15:10:07 <vanila> and |(T,T')| = |T|*|T'|
15:10:09 <Sonarpulse> does anybody have any TH so that pattern failure in do notation bindings in a MonadPlus evaluates to mzero ?
15:10:14 <jle`> @let data Throol = Thrue | Thralse | Thneither
15:10:15 <lambdabot>  Defined.
15:10:17 <spopejoy> but it’s at least a tractable number of inhabitants.
15:10:19 <bitemyapp> > data Triple = Nada | Single | Double
15:10:20 <lambdabot>  <hint>:1:1: parse error on input ‘data’
15:10:25 <bitemyapp> jle`: well that works, lol
15:10:41 <ij> kini, Hmm, I messed up.
15:10:43 <spopejoy> Thus, Either Boolean Boolean is inhabited by True _, _ True, False _, _ False
15:10:52 <shachaf> Sonarpulse: You could redefine fail with RebindableSyntax.
15:10:53 <bitemyapp> jle`: I've done that before.
15:10:56 <jle`> spopejoy: no, it's inhabited by Left True, Left False, Right True, and Right False
15:11:04 <bitemyapp> data Schrodinger = True | False | Both
15:11:05 <benmachine> is no-one going to make a FileNotFound joke
15:11:06 <spopejoy> that’s what I was trying to type :)
15:11:10 <jle`> spopejoy: ah :)
15:11:14 <benzrf> benmachine: acme-php already did it
15:11:20 <spopejoy> in some non-Haskell language :)
15:11:20 <jle`> how about Either Bool Triple ?
15:11:25 <jle`> using bitemyapp's Triple type
15:11:44 <bitemyapp> @let data Triple = Nada | Single | Double
15:11:45 <lambdabot>  Defined.
15:11:50 <bitemyapp> @let data Triple = Nada | Single | Double deriving (Eq, Show)
15:11:50 <lambdabot>  .L.hs:160:1:
15:11:50 <lambdabot>      Multiple declarations of ‘Triple’
15:11:50 <lambdabot>      Declared at: .L.hs:156:1
15:11:50 <lambdabot>                   .L.hs:160:1
15:11:50 <lambdabot>  
15:11:54 <bitemyapp> sigh. fine.
15:12:00 <spopejoy> undef?
15:12:02 <bitemyapp> @unlet Triple
15:12:02 <lambdabot>  Parse failed: TemplateHaskell is not enabled
15:12:03 <jle`> i wonder if lambdabot has standalone deriving
15:12:06 <vanila> @undef
15:12:06 <lambdabot> Undefined.
15:12:10 <bitemyapp> @let data Triple = Nada | Single | Double deriving (Eq, Show)
15:12:11 <lambdabot>  Defined.
15:12:16 <jle`> then you can derive Show/Eq standaloney
15:12:19 <GeraldCode> > let g = Nada
15:12:20 <lambdabot>  not an expression: ‘let g = Nada’
15:12:21 * chrisdone still uses ghc --make despite that not doing anything anymore
15:12:22 <bitemyapp> > :t Right Double
15:12:23 <lambdabot>  <hint>:1:1: parse error on input ‘:’
15:12:28 <bitemyapp> :t Right Double
15:12:29 <lambdabot> Either a Triple
15:12:29 <bitemyapp> derp
15:12:35 <bitemyapp> :t Left Double
15:12:36 <lambdabot> Either Triple b
15:12:39 <jle`> if only Either was Enum
15:12:50 <Sonarpulse> RebindableSyntax ? I don't really know anything about TH
15:12:52 <kini> in the list monad, binding a monadic value corresponds to observing a quantum-superposed state :P
15:12:55 <spopejoy> OK, Either Boolean Triple has 5 inhabitants
15:13:02 <jle`> spopejoy: nice!
15:13:03 <GeraldCode> kini WTF
15:13:07 <GeraldCode> you just blew my mind
15:13:08 <jle`> spopejoy: how about (Bool, Triple) ?
15:13:10 <shachaf> RebindableSyntax is a GHC extension that doesn't have to do with TH.
15:13:19 <spopejoy> right … 6
15:13:24 <jle`> woo hoo!
15:13:30 <spopejoy> sweet!
15:13:43 <jle`> yeah, that is one sense in which product and sum correspond to products and sum in your more familiar maths
15:13:54 <bitemyapp> > [1, 2, 3] >>= return . (+2)
15:13:54 <chrisdone> shachaf: was that grammaro intentional?
15:13:55 <lambdabot>  [3,4,5]
15:13:59 <jle`> note that you can do some neat algebra things with this
15:14:05 <jle`> like
15:14:11 <jle`> x * (y + z)
15:14:17 <jle`> = x * y + x * z
15:14:23 <ij> kini, No, I'm still not sure why (forall a b. a -> b -> b) is the same as ((forall a. a -> b) -> b). I think the case I wrote is similar to the logic one.
15:14:31 <vanila> jle`, and here is a fun one d/dx (x * (y + z))
15:14:35 * hackagebot messagepack 0.1.1 - Serialize instance for Message Pack Object  http://hackage.haskell.org/package/messagepack-0.1.1 (rodrigosetti)
15:14:40 <bitemyapp> vanila: ad / zip :)
15:14:41 <kini> ij: it is not the same at all.
15:14:42 <jle`> and surely enough, (a, Either b c) is equivalent under isomorphism to Either (x, y) (x, z)
15:14:44 <shachaf> That sentence seems perfectly grammatical to me.
15:14:59 <jle`> oops
15:15:04 <jle`> some letters got mixed up
15:15:04 <kini> ij: in the first place, even throwing away all the foralls and type variables, Int -> Int -> Int is not the same as (Int -> Int) -> Int
15:15:12 <frerich> Next up: the power type ‘Bool -> Triple’!
15:15:22 <spopejoy> (x, Either y z)
15:15:25 <jle`> (a, Either b c) ==> Either (a, b) (a, c)
15:15:35 <jle`> just like a * (b + c) ==> a * b + a * c
15:15:39 <chrisdone> shachaf: the "have anything" or "have something" makes sense, but "have to do with" is awkward to my eyes. maybe it's a $nationality dialect thing, where $nation is where you live
15:15:44 <ij> kini, Sorry, I wanted to write that (Int -> Int)
15:16:08 <kini> ij: so you mean, (forall a b. (a -> b) -> b) vs. (forall a b. a -> b -> b) ?
15:16:17 <jle`> vanila: i saw a stack overflow once that had a power series or something
15:16:19 <kini> erm
15:16:26 <chrisdone> shachaf: the reduced form "doesn't do with" is proper odd
15:16:28 <kini> ij: so you mean, (forall a b. (a -> b) -> b) vs. ((forall a b. a -> b) -> b) ?
15:16:36 <ij> yup
15:16:51 <vanila> jle`, yeah, infinite series is a useful tool in general but not here
15:17:05 <ij> and (forall a b. (a -> b) -> b) vs. ((forall a. a -> b) -> b)
15:17:06 <vanila> only for recursive types
15:17:15 <kini> ij: those are different
15:17:26 <kini> all those are different :P
15:17:27 <jle`> yeah, i'm just saying something cray i saw with this algebra on types :|
15:17:35 <ij> Hmm, I am missing something then.
15:17:38 <spopejoy> is forall specific to GHC?
15:17:39 <kini> god, sometimes I really hate the fact that forall is implicit in haskell
15:17:40 <shachaf> chrisdone: Possibly.
15:17:54 <bitemyapp> kini: it makes learning later things harder, earlier things easier.
15:18:02 <kini> it makes it very confusing to talk about type metavariables
15:18:03 <bitemyapp> kini: makes people less likely to write code that doesn't infer nicely
15:18:05 <shachaf> chrisdone: I don't think that "reduced form" makes sense.
15:18:41 <shachaf> It's more like "X has [something] to do with Y".
15:18:43 <kini> ij: lemme get back to you in a bit
15:18:47 <spopejoy> frerich: joking?
15:18:48 <djahandarie> bitemyapp, I'm pretty sure the fact you need to add LANGUAGE pragmas to make things not infer nicely is already a sufficent control.
15:18:53 <ij> kini, ok, I'll run to the kitchen
15:19:01 <shachaf> Anyway, this is probably not the right channel for that.
15:19:05 <chrisdone> shachaf: ah, never heard that phrasing. good to know
15:19:15 <chrisdone> spopejoy: pretty sure i've seen it in UHC
15:19:28 <kini> hi djahandarie
15:19:35 * hackagebot messagepack 0.2.0 - Serialize instance for Message Pack Object  http://hackage.haskell.org/package/messagepack-0.2.0 (rodrigosetti)
15:20:06 <djahandarie> Hey.
15:20:41 <frerich> spopejoy: Actually not, ‘a -> b’ is a power type, or so was told. The inhabitants are all total functions with that type. So for ‘Bool -> Triple’  there are 3^2 functions.
15:21:25 <frerich> spopejoy: s/so was told/so I was told/
15:21:38 <kini> so was told, by the bards of old
15:22:12 <vanila> |a -> b| = |b|^|a|
15:22:43 <bitemyapp> frerich: (->) is exponentiation/implication
15:22:47 <vanila> because there is 'b' choices for each 'a' to go to
15:22:51 <bitemyapp> frerich: zippers are the derivative/differentiation
15:23:10 <vanila> also called: one hole contexts
15:23:14 <frerich> bitemyapp: Right, that’s why I wrote ‘power’, as in - exponentation
15:23:32 <bitemyapp> frerich: seeing how the zippers transform function types is fun.
15:23:58 <spopejoy> hmm. isn’t \_ -> Nada the same total function that works for both True and False?
15:24:11 <spopejoy> thus three functions, not nine?
15:24:14 <Sonarpulse> shachaf are you saying make my own monad instance to tweak the fail method?
15:24:28 <shachaf> Sonarpulse: I mean to define your own function called fail.
15:24:31 <shachaf> fail _ = mzero
15:24:39 <shachaf> And hide the Prelude fail. It should just work.
15:24:44 <shachaf> Maybe.
15:25:49 <Sonarpulse> I didn't realize fail was called on refutable pattern match
15:26:00 <Sonarpulse> I'll try
15:26:09 <jle`> spopejoy: we can try enumerating them
15:26:12 <shachaf> Ah. Yes, that's what's defined in the Report.
15:26:26 <shachaf> Usually it's hard-wired to call Prelude.fail, but with RebindableSyntax it'll call whichever fail is in scope.
15:26:27 <spopejoy> What are the other total inhabitants of Bool -> Triple, other that \_ -> Nada, \_ -> Single, \_ -> Double
15:26:44 <jle`> True -> Nada, False -> Single
15:26:59 <jle`> True -> Single, False -> Nada
15:27:06 <frerich> spopejoy: How about ‘\b -> if b then Nada else Single’
15:27:34 <jle`> True -> Single, False -> Double ...and then the flipped version (True -> Double, False -> Single)
15:27:43 <jle`> and then True -> Nada, False -> Double (and the flipped version)
15:28:08 <spopejoy> i must be misunderstanding “total function"
15:28:17 <jle`> defined on all inputs
15:28:23 <jle`> in this context
15:28:37 <frerich> spopejoy: A function which is defined for all possible inputs (no matter what the function maps those inputs to)
15:28:37 <spopejoy> as opposed to “for all inputs”, a la Wolfram
15:29:14 <geekosaur> conversely, a partial function is something like head
15:29:18 <chrisdone> hm, anyone know offbyheart the arg to pass to ghc to make it compile and link against a .c?
15:29:19 <geekosaur> > head []
15:29:20 <lambdabot>  *Exception: Prelude.head: empty list
15:29:20 <chrisdone> geekosaur!
15:29:33 <geekosaur> o.O
15:29:51 <shachaf> chrisdone: Just pass it the .c file?
15:30:20 <geekosaur> afaik you just pass it the .c
15:30:20 <chrisdone> shachaf: ohh. i didn't think it was that easy
15:30:26 <chrisdone> works =)
15:30:40 <ph88> does haskell have automatic threading and multi-core support ?
15:30:43 * chrisdone is used to doing everything from cabal configurations
15:30:44 <spopejoy> I’m having trouble seeing Bool -> Triple having “total” inhabitants, if an inhabitant can only accept a single domain value at a time
15:31:02 <chrisdone> ph88: what's automatic threading?
15:31:09 <Sonarpulse> shachaf: wow that is weird, breaks the lambda desugaring most things teach
15:31:15 <shachaf> spopejoy: A total inhabitant of the type (Bool -> Triple) tells you which Triple value each Bool value goes to.
15:31:28 <ph88> chrisdone: compiler inject threading code instead of programmer
15:31:35 <spopejoy> oh i see.
15:31:53 <shachaf> Sonarpulse: That's why you read the Report.
15:32:29 <spopejoy> Thus one inhabitant is (True -> Nada, False -> Nada), another (True -> Nada, False -> Single), etc
15:32:39 <frerich> Sonarpulse: To be fair, I think RWH teaches the ‘correct’ desugared version
15:32:44 <pjdelport> ph88: Not entirely automatic, but you can declare opportunistic parallelism pretty easily.
15:32:55 <shachaf> Yes. There are nine inhabitants.
15:33:02 <shachaf> (Each inhabitant is a pair of Triple values.)
15:33:05 <ph88> pjdelport: where can i find the docs on that ?
15:33:32 <frerich> Sonarpulse: (Indeed, RWH gives the real desugaring in “Desugaring of do blocks” on http://book.realworldhaskell.org/read/monads.html )
15:33:49 <chrisdone> @google data parallel haskell
15:33:50 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
15:33:50 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki
15:34:21 <pjdelport> ph88: http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html#id675076 has one basic introduction
15:34:32 <ph88> oki thx
15:34:36 * hackagebot tn 0.2.0.0 - A journaling program for Linux  http://hackage.haskell.org/package/tn-0.2.0.0 (pharpend)
15:34:51 <geekosaur> automatic parallelism is still a very open research topic
15:35:01 <pjdelport> http://chimera.labs.oreilly.com/books/1230000000929/pt01.html has a lot more detail
15:35:21 <pjdelport> ph88: http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html is the library you'll want to be familiar with.
15:35:38 <ph88> ill have a look
15:35:46 <spopejoy> pjdelport: yes that’s a good one, “Parallel and Concurrent Programming in Haskell"
15:36:02 <pjdelport> That lets you take a plain program and declare where and how you want it to be opportunistically parallel.
15:36:30 <pjdelport> Then, when you run it in a multicore GHC, it'll automatically evaluate sparks in parallel across workers.
15:36:32 <chrisdone> i wish IOException was a sum type i could easily read the list of like a human being
15:36:44 <kini> ij: sorry, I'm going to cop out and link you to http://stackoverflow.com/questions/3071136/ .  Thought for a while about what to say about -XRankNTypes but didn't come up with anything very enlightening.
15:36:47 <bitemyapp> chrisdone: ditto.
15:37:07 <chrisdone> instead i gotta read that sauce
15:38:34 <bitemyapp> kini: I don't actually have a good tutorial on RankNTypes yet.
15:39:01 <jle`> there was one on reddit a few months ago, wasn't there?
15:39:06 <chrisdone> i never actually read a tutorial on RankNTypes
15:39:19 <bitemyapp> kini: this is why there's nothing expressly about forall, rankntypes, etc. in my guide.
15:39:23 <bitemyapp> kini: I haven't found anything I like.
15:39:24 <kini> bitemyapp: sometimes I think I might not be great at CS pedagogy since I come from a math background
15:39:25 <kini> "embedded" quantifiers are the most natural thing in the world for me
15:39:26 <spopejoy> So back to Sum types (Either): semigroup or monoid?
15:39:39 <bitemyapp> kini: totally alien to people like me.
15:39:41 <chrisdone> i heard about it from the dutch utrecht group in zurihac and thnen made do with reading the manual and fiddling with ghc
15:39:45 <benzrf> spopejoy: well
15:39:45 <Sonarpulse> frerich good find
15:39:54 <benzrf> spopejoy: Either Void X is isomorphic to X
15:39:58 <benzrf> but not actually equal
15:40:19 <josephle> that's because you lack univalence! ;)
15:40:20 <bitemyapp> chrisdone: I get the difference between universal and existential quantification but the implications of the ranks aren't something I grok.
15:40:30 <Sonarpulse> Shachaf well if we ever have an underhanded haskell contest...
15:40:51 <kini> my explanation of rank n types would be, like, "it's the difference between saying 'for all x, if P(x), then Q(x)' and 'if for all x, P(x), then for all x, Q(x)'"
15:41:10 <shachaf> Sonarpulse: Then having that extension on would be a big red flag.
15:41:15 <bitemyapp> kini: that seems a promising place to start if you can explain wth it means.
15:41:58 <jle`> was this the article? http://sleepomeno.github.io/blog/2014/02/12/Explaining-Haskell-RankNTypes-for-all/
15:42:01 <jle`> i forgot
15:42:06 <jle`> the name is cute though
15:42:10 <jle`> so that should be a bonus
15:42:12 <isomorpheous> My favorite metaphor is a train
15:42:25 <bitemyapp> jle`: I hadn't seen that one yet.
15:42:28 <bitemyapp> isomorpheous: :\
15:42:44 <jle`> i forgot which one i am thinking of, but that one seems nice ish on first glance
15:43:03 <isomorpheous> Rank1Type is like getting on a train to go to your destination. It might make some stops along the way. But, once you get on the train, you can be assured you will get to your destination.
15:43:09 <jle`> some of the formatting is a little funky tho
15:43:24 <jle`> i should just publish my starred articles in my Pocket
15:43:31 <chrisdone> bitemyapp: i get them in the sense i use them and have made plenty of my own, but yeah a tutorial would've been nice instead of painfully immersing until i grokked the concept
15:43:37 <isomorpheous> RankNTypes is like getting on train, then getting off at a certain stop, then having to get on another train, with itself makes a number of stops
15:43:53 <jle`> is Rank2Types when you don't have enough money to buy more than one ticket?
15:43:58 <isomorpheous> jle`: haha
15:44:02 <bitemyapp> chrisdone: this is partly why I take pride in my guide. I don't link dump things I don't understand. Only stuff that I understood and that I think is good pedagogy goes in.
15:44:10 <shachaf> isomorpheous: Is this one of those jokes where someone is confused and you say unhelpful things on purpose?
15:44:11 <ij> kini, fair enough, I'll read it
15:44:17 <ij> kini, Thanks anyway.
15:44:20 <isomorpheous> shachaf: no, it makes sense to me :/
15:44:31 <bitemyapp> isomorpheous: you made it sound like continuation passing or something
15:44:35 <chrisdone> bitemyapp: sensible
15:44:37 <shachaf> I'm unable to tell.
15:44:41 <isomorpheous> shachaf: The point is, you can get on any number of trains at the beginnint
15:44:41 <bitemyapp> but I'm sure there's a way to make RankNTypes relevant to CPS.
15:44:51 <bitemyapp> quantum superposition of types?
15:44:56 <kini> fwiw I don't get isomorpheous's explanation
15:44:57 <bitemyapp> chrisdone: well, it is, but nobody else does that.
15:44:58 <isomorpheous> shachaf: then, there's another point, where you have to once again choose a number of trains
15:44:59 <Sonarpulse> shachaf so maybe monad already has fail _ = nothing
15:45:05 <Sonarpulse> so my trick works out of the box
15:45:09 <bitemyapp> chrisdone: everybody else seems to dump links, no curation, no first-hand experience, no grokking, no testing with pedagogy.
15:45:16 <bitemyapp> chrisdone: I've refined it based on what's worked for teaching other people.
15:45:17 <jle`> is that really fail for Maybe?
15:45:23 <jle`> :|
15:45:30 <shachaf> Sonarpulse: Correct, it works for Maybe via fail.
15:45:32 <jle`> > do { Just x <- Nothing; return x }
15:45:33 <lambdabot>  Nothing
15:45:39 <jle`> huh.
15:45:42 <jle`> i guess so
15:45:50 <Sonarpulse> this is not good
15:45:59 <jle`> i mean i guess if there were any monads that made sense for fail, it'd be Maybe/[], but...
15:46:02 <shachaf> @src catMaybes
15:46:02 <lambdabot> catMaybes ls = [x | Just x <- ls]
15:46:08 <shachaf> That's how tricks like that work.
15:46:15 <bitemyapp> catMaybes is awesome.
15:46:16 <jle`> i think that's the [] monad fail
15:46:25 <bitemyapp> more people should use catMaybes.
15:46:37 <jle`> guess i should stop using mapMaybe id
15:46:38 <glguy> cat
15:46:42 <chrisdone> if i were teaching haskell i'd probably teach with rank-n types enabled from the start and then it wouldn't be a "thing" to get
15:46:59 <chrisdone> (i mean, in a bubble. like uni teachers do)
15:47:00 <isomorpheous> chrisdone: that's horribly inefficient though
15:47:06 <bitemyapp> chrisdone: feh. I probably wouldn't, but I understand why you say so.
15:47:31 <shachaf> What is inefficient?
15:47:31 <isomorpheous> chrisdone: that's like not teaching preschoolers group theory so they can appropriately understand arithmetic
15:47:32 <Sonarpulse> It would be better for teaching if haskell had explicit (capital) Lambda
15:47:45 <kini> btw, is this "ranking" of types haskell-specific, or is it used in a more general setting?
15:47:54 <shachaf> Having explicit quantification when learning Haskell wouldn't be an unreasonable thing.
15:47:57 <chrisdone> it seems natural to me that type variables can have a certain scope
15:48:02 <isomorpheous> shachaf: it's a logic thing
15:48:07 <Sonarpulse> on the other hand
15:48:26 <josephle> kini: a logic thing, as isomorpheous said
15:48:30 <Sonarpulse> it is nice to do :t in repl and have it do it's HN thing
15:48:45 <bitemyapp> yeah I wouldn't give up inference when teaching.
15:48:47 <bitemyapp> No way in Hell.
15:48:57 <chrisdone> shachaf: right -- starting with explicit and then afterwards saying "but this kind we can leave off as implicit" would leave an understanding but introduce a convenience
15:49:01 <isomorpheous> kini: which is probably why you don't use it in other languages :p
15:49:02 <jle`> implicit foralls trip people up when you have 'demand'-driven polymorphism, esp with typeclasses
15:49:03 <bitemyapp> not without getting something a lot more compelling than RankNTypes in exchange.
15:49:17 <shachaf> It's a natural way to explain it: I can write idInt :: Int -> Int; idInt x = x, and idBool :: Bool -> Bool; idBool x = x. I want something that works "for all" types t, so I write id :: forall t. t -> t; id x = x
15:49:21 <jle`> they write something like foo :: Bar b => Int -> b
15:49:27 <jle`> and then they return a specific Bar instance
15:49:28 <Sonarpulse> agda without {} or {{}} might be interesting eaching language
15:49:29 <isomorpheous> I wouldn't even mention strings
15:49:31 <kini> ah, here it is - http://en.wikipedia.org/wiki/Quantifier_rank
15:49:40 <isomorpheous> Do everything with ByteString and Text, like you would in an actual app
15:49:42 <shachaf> Now it's clear where t comes from.
15:49:43 <chrisdone> shachaf: nod
15:49:44 <jle`> and they're like "yo what's up, i returned a Bar instance, and the return asks for a Bar instnace...what's wrong with that?"
15:49:45 <Sonarpulse> also have people do induction with Nats in first week
15:49:48 <isomorpheous> Too many people use String in their libraries
15:49:54 * isomorpheous glares at pandoc
15:50:25 <Sonarpulse> no number sugar until later
15:50:28 <shachaf> isomorpheous: Oh, you're l0cust.
15:50:33 <kini> just teach everyone coq and let them learn haskell later ;)
15:50:33 <isomorpheous> shachaf: yes, I am
15:50:53 <Sonarpulse> if only inria could syntax....
15:50:54 <jle`> like foo :: Num a => Int -> a; foo x = x.  i mean, x is a Num.  so why doesn't this work
15:51:01 * kini waits for someone to protest that agda is so much closer to haskell syntax and would thus be a better choice
15:51:03 <jle`> - people
15:51:11 <chrisdone> bitemyapp: i think a lot of it is about trying it rather than speculating, like your approach
15:51:12 <kini> oops, I guess Sonarpulse already did, rofl
15:51:15 <josephle> kini: but all that unicode!
15:51:18 <bitemyapp> kini: nah, Coq is a better choice.
15:51:23 <Sonarpulse> ;D
15:51:29 <kini> bitemyapp: mainly because there are a couple textbooks about it
15:51:35 <merijn> @quote roconnor merijn
15:51:36 <lambdabot> roconnor says: <roconnor> merijn: I got into Haskell from Coq. <xplat> that's like getting into drinking through heroin.
15:51:38 <chrisdone> i know some places have taught lobotomized haskell, sans type classes and things like that, and incrementally introduced features one by one
15:51:57 <jle`> isn't that the hugsy approach?
15:51:59 * isomorpheous doesn't understand the need to learn another language before learning Haskell
15:52:03 <spopejoy> Is there a better, simple example of RankNTypes that isn’t about existential types/ST Monad?
15:52:05 <isomorpheous> shachaf: why do you mention it
15:52:12 <chrisdone> i can't remember what it was called... hmm
15:52:26 <merijn> isomorpheous: Sure, one sec
15:52:32 <Sonarpulse> that is a great quote
15:52:36 <bitemyapp> chrisdone: I wouldn't really want to teach a lobotomized Haskell either.
15:52:37 <chrisdone> jle`: there was an actual compiler that restricts haskell to a subset
15:52:38 <jle`> spopejoy: onTuple :: (a -> Bool) -> (b, c) -> (Bool, Bool)
15:52:54 <isomorpheous> spopejoy: Probably. This channel is filled with experts, though, who don't like simple explanations
15:52:54 <jle`> spopejoy: can you see why you can't use the (a -> Bool) to apply on both the b and the c
15:52:55 <bitemyapp> chrisdone: it's called Core-Haskell
15:53:05 <shachaf> isomorpheous: Sigh.
15:53:15 <bitemyapp> chrisdone: maybe Helium?
15:53:23 <chrisdone> bitemyapp: i'm exploring the territory in both directions. enabling too many features, versus disabling features. who's to say Haskell 2010's default extension configuration is ideal for teaching?
15:53:28 <isomorpheous> shachaf: did I do something to offend you?
15:53:31 <bitemyapp> chrisdone: there's also gofer.
15:53:32 <Sonarpulse> racket and it's langauge levels is probably a good model
15:53:38 <chrisdone> bitemyapp: righht, helium, that rings a bell
15:53:46 <bitemyapp> http://en.wikipedia.org/wiki/Gofer_(programming_language)
15:53:50 <bitemyapp> you probably meant Helium.
15:53:53 <kini> gofer is mega ancient
15:53:56 <spopejoy> jle`: but why would you want to, if you’ve bothered to give (b,c) separate types
15:54:02 <chrisdone> yeah, never heard of gofer
15:54:02 <bitemyapp> kini: that's why it has Miranda syntax.
15:54:10 <kini> but it's also mentioned in the comments in the Happy parser source code
15:54:13 <kini> so it must still be current!
15:54:16 <jle`> spopejoy: well, it's a contrived example
15:54:26 <jle`> but can you see why you can't apply your (a -> Bool) to both b and c?
15:54:30 <ReinH> Bird used Gofer for Algebra of Programming :)
15:54:32 <ReinH> it's annoying.
15:54:35 <spopejoy> I can’t apply it to either.
15:54:36 <bitemyapp> chrisdone: I stay pretty conservative/practically minded. Part of what I'm doing in some cases is undoing the damage of dysfunctional university courses.
15:54:43 <chrisdone> i've been asked to provide alternate ways to use my library without OverloadedStrings
15:54:45 <jle`> spopejoy: well, you can apply it to the b if you set a ~ b
15:54:52 <jle`> spopejoy: and you can apply it to the c if you set a ~ c
15:54:53 <isomorpheous> chrisdone: which library?
15:54:59 <kini> https://github.com/simonmar/happy/blob/master/tests/Test.ly#L133
15:55:01 <bitemyapp> chrisdone: I'd much rather fix pedagogy for stuff that's part of my current progression than change things drastically.
15:55:02 <chrisdone> and yet we have OverloadedIntegrals (pretty much) and for fractionals
15:55:06 <spopejoy> hmm. what is ~ here?
15:55:28 <kini> spopejoy: a type coercion, iiuc
15:55:29 <chrisdone> isomorpheous: formatting =)
15:55:50 <bitemyapp> chrisdone: I don't spend much time talking about numbers when I teach Haskell.
15:55:55 <ReinH> spopejoy: maybe http://blog.mno2.org/blog/2012/04/06/what-is-rank-n-types-in-haskell/ ?
15:55:55 <chrisdone> bitemyapp: fair enough. my long term goal is my interactive datalog-based teaching book and haskell will be my first experiment =p
15:56:00 <jle`> but yeah, you're right, if they are a and b in the type signature you can't in general apply them to either
15:56:03 <zzbacon> "11 years ago" damn happy is o.g.
15:56:19 <bitemyapp> chrisdone: gotcha. I mean that when I say undoing the damage universities did.
15:56:30 <bitemyapp> chrisdone: the "hard" parts are usually stuff in the typeclassopedia, thinking abstractly
15:56:36 <jle`> but you can make it able to apply to both, if you do onTuple :: (forall a. a -> Bool) -> (b, c) -> (Bool, Bool)
15:56:39 <spopejoy> I think I saw something (still looking) saying it could get you sub-type like behavior.
15:56:45 <bitemyapp> chrisdone: I don't really feel the need to reduce the progression down to things they could understand on their own
15:56:47 <merijn> isomorpheous: My example still requires GADTs, but no existentials/ST (and it's a bit artificial)
15:56:55 <jle`> where the first argument must be a function that can take *any* a and turn it into a Bool
15:57:03 <bitemyapp> chrisdone: I want to confront the pedagogically problematic parts and get them over the hump so they understand the seduction of thinking and working like a Haskeller.
15:57:16 <merijn> isomorpheous: http://lpaste.net/108159
15:57:17 <chrisdone> bitemyapp: sure
15:57:25 <bitemyapp> chrisdone: this is how my in person tutorials go. It's usually 1-2 hours and designed to go from sum, product, (->) to the typeclassopedia.
15:57:28 <jle`> one of my favorite applications of RankN types though is for natural transformations
15:57:38 <kini> <jle`> spopejoy: well, it's a contrived example
15:57:38 <kini> that's almost the same example I started writing for ij, until I realized that it's kind of pointless to write a function that accepts arguments of type "forall a. a -> Bool"
15:57:50 <kini> bitemyapp: you do in person tutorials?
15:57:52 <bitemyapp> chrisdone: stuff like this: http://codereview.stackexchange.com/questions/57843/update-map-in-haskell/57850#57850
15:57:53 <chrisdone> i mostly use rank-n types with typeable and data
15:57:56 <bitemyapp> kini: lots, yes.
15:57:56 <jle`> kini: it's contrived ;)
15:58:06 <bitemyapp> kini: I've given one-off classes and the like as well.
15:58:15 <bitemyapp> I was going to a course series here in Austin but it fell apart and I gave up.
15:58:20 <jle`> :t (\_ -> False)
15:58:21 <lambdabot> t -> Bool
15:58:21 <bitemyapp> I couldn't get a venue.
15:58:51 <bitemyapp> we're going to take the secondary Haskell meetup here (primary is more for intermediate stuff) and see if we can turn it into the structure Haskell classes that I had in mind.
15:59:02 <shachaf> merijn: A lot of cases where people use GADTs involve existentials, of course.
15:59:07 <bitemyapp> so we have roughly ~2 monthly Haskell meetups running along the beginner and intermediate tracks.
15:59:19 <bitemyapp> kini: I like teaching a lot. It invigorates me.
15:59:35 <jle`> is there a good guide to writing haddock documentation somewhere?
15:59:38 * hackagebot acme-lolcat 0.1 - LOLSPEAK translator  http://hackage.haskell.org/package/acme-lolcat-0.1 (AntonNikishaev)
15:59:42 <jle`> instead of just looking at the source of a bunch of libraries?
15:59:56 <chrisdone> jle`: besides the manual? hmm, not that i know of
16:00:02 <bitemyapp> jle`: I just used lens and pipes as examples.
16:00:07 <bitemyapp> jle`: I think that's easiest - mimicking them.
16:00:08 <jle`> thank you AntonNikishaev for giving us a LOLSPEAK translator
16:00:14 <merijn> shachaf: Sure
16:00:15 <jle`> yeah i've been doing that too
16:00:19 <isomorpheous> jle`: what's wrong with the documentation http://www.haskell.org/haddock/doc/html/index.html
16:00:34 <chrisdone> what's that 300 quote? "this will not be over quickly. you will not enjoy this"
16:00:34 <merijn> shachaf: I'm pretty sure I could come up with a non-GADT example, but it started taking too much time and I got bored
16:00:39 <zzbacon> are there any haskell jobs?
16:00:40 <chrisdone> that's what it's like with writing haddock docs
16:00:46 <jle`> zzbacon: yes
16:00:49 <merijn> shachaf: Incidentally, this time next week I should be in the valley :)
16:00:56 <jle`> chrisdone: :P
16:01:22 <bitemyapp> chrisdone: why datalog?
16:01:29 <bitemyapp> chrisdone: I'm still kinda mad about datalog after Clojure and Datomic.
16:01:35 <zzbacon> vast majority of job postings are like "Skilled in other languages such as C/C++, Java, Ruby, Haskell, Javascript"
16:01:37 <bitemyapp> s/kinda mad/caremad/g
16:01:42 <zzbacon> meaning they aren't doing haskell
16:01:54 <bitemyapp> zzbacon: no Haskell jobs exist. they are a myth.
16:02:02 <kini> zzbacon: there's this... http://www.haskellers.com/jobs
16:02:06 <bitemyapp> damn
16:02:11 <zzbacon> i think every pro haskeller works for galois or well-typed
16:02:19 <bitemyapp> zzbacon: most of 'em I see are through: http://functionaljobs.com/
16:02:24 <jle`> zzbacon: well...then that means there is at least one haskell job :)
16:02:28 <spopejoy> what about Soostone?
16:02:31 <jle`> question answered!
16:02:32 <djahandarie> zzbacon, that's definitely not true.
16:02:34 <bitemyapp> spopejoy: they exist.
16:02:38 <chrisdone> bitemyapp: well, it'll be implemented in haskell. it's just a logic language. but when you say logic language people don't get it, if you say prolog people think you're doing programming. a database of facts and rules which i can query and from which i can generate novel statements and exercises answers to which can be confirmed by the engine
16:02:55 <bitemyapp> chrisdone: a typed datalog would be nifty.
16:03:06 <bitemyapp> chrisdone: I actually want a Haskell library that replaces what I was using Datomic for.
16:03:19 <spopejoy> Datomic, that’s Rich Hickey’s thing?
16:03:19 <bitemyapp> chrisdone: the event sourcing / immutable database part.
16:03:29 <kini> btw chrisdone, what exactly is the status of ghc-server? Is it too experimental for me to play with?
16:03:31 <spopejoy> Just use git :)
16:03:55 <bitemyapp> spopejoy: you joke, but I've done that before.
16:04:04 <bitemyapp> pathspec as key, blob as value
16:04:08 <spopejoy> not really joking
16:04:11 <chrisdone> fwiw i think edwardk's analytics is (or was) the closest thing to an efficient datalog implementation, but you'd have to ask him for the link to the right commit
16:04:13 <bitemyapp> spopejoy: easier to just hack up PostgreSQL
16:04:19 <bitemyapp> and make an index tree
16:04:29 <bitemyapp> tracking data as it changes is the annoying part.
16:04:31 <spopejoy> but … that’s a dreaded RDBMS! Not hip!
16:04:45 <bitemyapp> PG is NAF.
16:05:12 <chrisdone> kini: umm, i think you can play with it, sure. without a repl or more editor integration it won't be that interesting yet. but M-x ghc-eval/ghc-load/ghc-type/ghc-kind etc work
16:05:45 <kini> chrisdone: nice. I guess I mostly just want to read the code.
16:05:57 <chrisdone> kini: but ja, i'm presently (at this minute) implementing something to pick up stdout/stderr from REPL evaluations as separate things from the result. i got sidetracked by irc this evening D:
16:06:26 <kini> since you're supporting old-ish versions of GHC via the GHC.Compat wrapper, does that mean you're not going to use the newish typed holes stuff?
16:06:38 <bitemyapp> chrisdone: sorry :)
16:06:45 <spopejoy> bitemyapp: NAF?
16:07:34 <chrisdone> kini: i'll support type holes (if i do special support for it), it just won't be available in old ghc versions
16:07:40 <zq> have there been any attempts to make an improved repl to ghc?
16:07:44 <kini> that makes sense
16:07:49 <chrisdone> zq: i'm doing it =p
16:07:52 <kini> zq: there's IHaskell, which I've been looking at a bit recently
16:08:05 <kini> and yeah, chrisdone's ghc-server thing, which sounds (from the README) like it's going to be pretty awesome :)
16:08:06 <chrisdone> zq: there's also.. ja, ihaskell, as kini said
16:08:19 <bitemyapp> spopejoy: nice-as-fuck
16:08:25 <spopejoy> :)
16:08:34 <chrisdone> bitemyapp: heh, NAF is pretty close to naff
16:08:40 <bitemyapp> kini: iHaskell died and ate my computer alive when I tried it.
16:08:51 <bitemyapp> chrisdone: hum. good point.
16:09:06 <chrisdone> i managed to get ghc-server to load itself inside itself, inside ghci
16:09:11 <chrisdone> yo dawg etc
16:09:14 <kini> lol
16:09:57 <kini> bitemyapp: I have been unable to get it to build on ghc 7.8
16:10:05 <kini> and I don't care enough to try on older versions of GHC, lol
16:10:26 <kini> however I have ripped some code out of it and written my own ipython kernel which just echoes back text
16:10:35 <spopejoy> Is Datomic another BTree thingie?
16:10:53 <spopejoy> And … isn’t git better?
16:12:04 <chrisdone> zq: but ja, my whole thing with ghc-server is that ghci is awesome but the communication with it is lame and i've reached its limits with the awesome that can be implemented, and contributing to ghci itself would have a slow development cycle and exclude everyone not on the latest ghc
16:12:07 <bitemyapp> spopejoy: lets not go there :)
16:12:46 <zq> chrisdone: i agree about ghci, but going for a client-server model is a bit extreme
16:13:05 <bitemyapp> zq: I dunno. I think it's sensible.
16:13:09 <bitemyapp> zq: it's what Clojure does with nrepl.
16:13:15 <kini> there's a large-ish portion of the IHaskell ipython interface code which is a internals-dependent hack to force ghci to read stdin from a network socket
16:13:19 <kini> yuck
16:13:24 <kini> IHaskell should just use ghc-server :)
16:13:27 <bitemyapp> kini: right.
16:13:43 <kini> right?
16:13:55 <chrisdone> zq: what's the alternative approach?
16:13:56 <bitemyapp> kini: right - should just use ghc-server (when it's ready)
16:14:02 <kini> yup, lol
16:14:06 <bitemyapp> kini: Clojure got the REPL thing right.
16:14:12 <bitemyapp> sorta. except for debugging.
16:14:21 <chrisdone> SLIME is the shit
16:14:21 <bitemyapp> you need debugging for Clojure. You don't really for Haskell.
16:14:22 <kini> afaik lisps have generally had good repl support
16:14:26 <chrisdone> if you'll pardon my germanic
16:14:29 <bitemyapp> kini: yep.
16:14:36 <bitemyapp> kini: Common Lisp is still King there.
16:14:42 <bitemyapp> kini: Clojure faintly behind…
16:14:59 <chrisdone> i know clojure supported SLIME when i first tried it… did they continue with it?
16:15:03 <bitemyapp> ghci can do a lot much more nicely than Clojure's REPL, but there are some gaps and it'd be nicer if it was client-server.
16:15:10 <bitemyapp> chrisdone: no, they abandoned all that when they went to client-server.
16:15:17 <bitemyapp> chrisdone: it's all custom Emacs mode wrapped around the server API now.
16:15:25 <chrisdone> huh
16:15:27 <bitemyapp> chrisdone: they actually lost a fair bit of functionality in the process. it was tragic.
16:15:36 <chrisdone> you mean a different server than a swank backend? some custom one?
16:15:36 <bitemyapp> I'm still kinda mad about that.
16:15:39 <bitemyapp> chrisdone: yes.
16:15:51 * chrisdone frowns
16:15:54 <bitemyapp> chrisdone: it's nrepl-mode/cider -> nrepl server now.
16:16:04 <bitemyapp> and nrepl is strictly less capable than swank was and after years, still hasn't caught up.
16:16:08 <bitemyapp> I was so pissed.
16:16:20 <chrisdone> yeah that's a pity
16:16:21 <spopejoy> bitemyapp: seriously wondering if git+timestamps (and maybe acid-state) would get you there?
16:16:44 <bitemyapp> spopejoy: no
16:16:51 <bitemyapp> spopejoy: mostly for operational/performance reasons
16:16:56 <chrisdone> i've already used ghc-server remotely in testing. like, my laptop is a good machine, but i have a beast dedicated server that i could do all my compiling on
16:17:00 <bitemyapp> spopejoy: easier to build a current-state index around PostgreSQL.
16:17:13 <bitemyapp> chrisdone: that sounds…really nice.
16:17:46 <chrisdone> :D
16:18:10 <bitemyapp> I know some people that would love to be able to shove compiles onto a queue and get results with identifiers dumped into a buffer.
16:18:18 <bitemyapp> "three compiles ago - this happened"
16:18:22 <bitemyapp> "two compiles ago - …"
16:23:57 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
16:23:57 --- topic: set by Cale on [Sat May 31 02:09:44 2014]
16:23:57 --- names: list (clog_ hylian|surface dxld_ mattp__ jrm2 bbastian- kardboardb_ nclarke thetallguy1 MrGwen1 joefiorini_ aseidl_ Krakarn-- kyb3r_ ssedov GeraldCode fold init _JokerDoom DT`` kludgy heudebeu Luke_ colluphid S11001001 bvck _flow_ kvanb mithsv halvorg plucas drjeats lelf SoupEvil lcfrs limepod William__ path[l] pgiarrusso_ Sauvin ldbrandy psychicist_ stephenjudkins Mon_Ouie calumet scottj ajyasgar kfish fionnan tertl3-laptop nick_named lpvb bmuk q66_ nemesit|znc)
16:23:57 --- names: list (Sgeo Swizec Sonarpulse asmyers paperManu doomlord_1 jfischoff mjs2600 danclien-afk drbean mitchty agjacome meiji11 intrados Plazma andyt jtcwang sepp2k desophos zygentoma netj jle` codeburg j2j tac-tics jaimef Beetny c-rog ddrone frerich2 Feuerbach iXeno elfenlaid MP2E coltfred rasfar meandi SmileyKeith triliyn steamboat viszu _ikke_ waterlaz btubbs spopejoy Ethix ArneL Apocalisp sprang sclv_ Guest35 PragCypher EvilPenguin nexx milessabin dsirenko_)
16:23:57 --- names: list (Rastus_Vernon prophile vervic edon godel kazimir42 latro`a manuel_ yfeldblum negatratoron Athiwat Jesin jml normalhum madariaga frankle sagittarian amesha_ peste frerich hebz0rl ChristianS gamegoblin edwardk yogurt_truck mawuli danofsatx-work aartamonau djfoote fiatjaf vendethiel _ashbreeze_ assia_t systemfault StolenToast troydm danl-ndi u_ Kron kjanosz ozgura randen cjenkin2 zachmassia cgag genisage arancia Noldorin ropav purefn OlegYch darthdeus)
16:23:57 --- names: list (MitchellSalad niklasb shergill joneshf-laptop marchelzo_ jordanl dysinger sbyl joehillen merijn nakal_ vanrysss_ jrib jonaias_ MindfulMonk MuffinMan` Sixmsj jeffwise pheaver Ralith nisstyre kazagistar WraithM pamojarpan rp__ ttll tromp___ rahul vanila akurilin amiri stevej JeroldHaas_ manfoo7 Talryn SCHAAP137 josephle seschwar apaku refold trism StoneCypher glguy urn byte48 LeoTal orion thirsteh pmylund plutoniix NemesisD xcthulhu raichoo d3m1g0d- paluh_)
16:23:57 --- names: list (gbarboza nuttycom martinalex zzbacon hiptobecubic vili tb01110100 Lubbadubdub croyd otulp Luonnon djoyner zwer Sculptor whaletechno Exio ixti bergey Corey michaelt albel727 cmears nullbyte copumpkin justinleitgeb Sorella sigma914 plhk artyomkazak Betal BMeph_ fread2282 oleo mceier ajf asjo geal thunderrd yorick aergus arun CaptainLex inuoppai rbocquet zxq9 jin_jin A1kmm rblackwe mindos_cloud__ strmpnk c9sould lep-delete lemao_ gienah phadej AleksejsHome vlads1)
16:23:57 --- names: list (joash friden jrm statusbot sx ephemeron DT` juhp tv eeezkil ClumsyDove [mth] predator117 chatsiri_ gfixler sjoerd_visscher osa1 gidogeek dsantiago xinming sw1nn aloiscochard lenstr fling Turboknot13 erikd lokydor Youri silver danvet shmookey DarkCthulhu magicman hackagebot elsimio2 wlhlm uberwach eevar MindlessDrone wagle ixian koi goldkatze johnw dolio sakiriou1 ruuns bjorkintosh EvanR_ deavid pgokeeffe PotatoGim tnks davidfetter ruzu ousado_ otto_s milky)
16:23:57 --- names: list (Shin-LaC Gilfoyle dwcook petercommand tessier shanse armyriad ronbrz dsturnbull lostman metaqix Igloo blicero lazyhaskeller bbee deevus neptunepink ivanm eyck Tesseraction cognominal jophish pfurla SegFaultAX ormaaj chrisdone oakwhiz Jyppe OscarZ StoneToad Peaker tommd aupiff coeus Rakkin AncientPC killy9999 jonsmock sclv Brando753 tomboy64 isomorphic kini brycelane neektza mikecaruso lamilami Plasmastar bjz shelf Lacriatch cerchio Excureo c_wraith jorj vsayer)
16:23:57 --- names: list (Gertm ccasin luzie Luke- MagneticDuck jrslepak LordBrain bitraten raschwell lykathea Philonous batz andyo andares yacks averell andrewsw charlie erickedji em hamishmack tismith Dashkal mkrtem seliopou joelteon benzrf simcity2000 cschneid c74d3 Magnus_Vortex Zekka ethercrow drlemon shachaf martingale ndeine wollw mgaare omefire cjheath gridaphobe cpa LysergicDreams cdk schlumpi obcode bgamari wtw rejuvyesh kipras`away Burton cehteh Natch aford gdaws biscarch)
16:23:57 --- names: list (r444 paddymahoney fikusz npcomp|away kloeri_ relrod stack sarlalian SparkySparkyBoom DrCode reggie1 Wamanuz canta ninzine suOya_ lithiumdeuteride JHaas theorbtwo bchar centrinia koz Boney kgadek pjdelport gnomnain Vorpal zyx DarkLinkXXXX__ T_X kalz skchrko ski haroldwu Internet13 gws maoe pkmx homam Bwild anborn jacobw metaf5 Sornaensis ReinH dreixel eazar001 phaskell Edoxile chas s_e serjeem emlow xnyhps dixie tristero Revenrof quaestor1 petterw dxld defanor)
16:23:57 --- names: list (pdxleif BlastHardcheese AntiSpamMeta staffehn zoink mmaruseacph2|umb m_george heyj slobo_ noam hyPiRion Xack JokerDoom `^_^v vpm dgvncsz0f mephx rudi_s dmead chirpsalot atota eamelink franckverrot studybot shigosei coconnor Kruppe tsani ninegrid cobakobodob foret mangaba_1eitosa mirsal mortberg macron notdan stiell abh zerokarmaleft afleck Hardolaf ktosiek Draggor LeaChim mixi kqr obiwahn marienz everett bens jameseb sajith lusory identity FliPPeh Paks Baughn)
16:23:57 --- names: list (asterblaster felixn nicoo barrucadu AshyIsMe hiredman knyon ernst tumdedum SaBer pfoetchen mikkom qz SwashBuckla tomku tero- ChewieBeardy ggreg Jonno_FTW xaimus comboy cryon Spark danking Bootvis noidi stbuehler Svedrin alang mornfall idoru dottedmag onielfa zarul tgeeky mjrosenb RayNbow`TU joneshf mickk DreamLinuxer araujo mechairoi splintax damncabbage TDJACR drone| transfuturist ezrios ecr dino- yan_ zz_anildigital arrdem stew claudiyoh aprescott kaiza)
16:23:57 --- names: list (owlglass kennyp FreeFull earldouglas rufs brisbin epta indiv0 wormphlegm stvc brackets joefiorini mrkishi sleepynate DigitalKiwi ivoscc vladan wting mathu bbastian yeltzooo sviterok jaysonsantos alloyed parallel21 happy0 JPuff kuyatzu kjnilsson Nshag chaoyi vmeson ikkebr bbloom periodic efm go|dfish subleq ens kmicu inr pieter_ tippenein horlicks_ Kobata fxr majoh osfameron jungnam hipsterslapfight rxc monochrom adrienneleigh catsup _d3f opqdonut squimmy)
16:23:57 --- names: list (Martty CindyLinz jennmoneydollars Soft Belgarion0 bryan11 Blkt MK_FG srcerer IanKelling adlan Tiktalik ienh meretrix Cale ValicekB Guest63619 alexsdut1on ninedotnine LordDeath Dtgr yusukesuzuki rio Pad^ mgomezch jasu0 `bps ahihi kav jakutis _5kg levi yrashk hng tools Draconx mountaingoat zymurgy bd_ thetallguy dmilith jlamothe hpc sokoll mavam jcurbo Someguy123 cdidd \q japesina- td123 hpd zling_ pp^ noteventime jchee augur dju u-ou kloplop321 krakrjak)
16:23:57 --- names: list (Eagle_Er1in cjenkin1 seagreen cyphase so ivan\ hegge simon Vq betawaffle lahwran FragByte Or1 shepheb kloeri Licenser saep jix jlewis_ M-ou-se dcoutts HugoDaniel sordina2 solarus aristid_ wto Profpatsch sveit aji otterdam bjornars helgikrs1 fall_ hbar pranz ZsoL Fuuzetsu rtl gandr pii runde poucet Sagi carlasema Shogun aoh elij Khisanth Krakarn bounb Wayneoween moop NinjaPenguin ClaudiusMaximus Rylee Harbinger agolsme_ stass blast_hardcheese Cronecker)
16:23:57 --- names: list (frontendloader Kabaka g0dmoney- MitchW lambdabot Guest8119 dutchie eyem sshine byorgey Imdsm^ ahf zz_LoRdToLsToI algoriddle himikov dh amontez tekacs j0ni pi8028 JPohlmann eagleflo dabradley Iceland_jack raek_ Eliel_ mayski isomorphismes mankyKitty phaazon nick1234abcd kirjs ekroon Taneb integral drdo julmac joe_k honza joachifm Tordek oldmanstanley nwf McManiaC redtricycle kaol xplat Fubar^ pcapriotti sellout XMunkki spacebug RevJohnnyHealey joeyh Cryovat)
16:23:57 --- names: list (davean1 anachron Erstarrung jlyndon_ jtobin dlundy b_jonas Lindrian mrowe_away Cheery EvanR tg rwbarton ibid mxf Gothmog_ stelleg R2ZER0 greymalkin finnrobi Nanar grantsmith evax BeLeKy dan64 _faern mendez peltchu Jello_Raptor Adios jackhill teeteewhy mr- Iloiny tridactyla xahry_ Dodek ft karls monsieurp Okasu radix pyrtsa cynick Ke peddie heikkih humppa thirsteh_ raid pnielsen_ fergusnoble Reiser koninkje_away ciaranm mnemon ion wchun gregburd mbrcknl wjt)
16:23:57 --- names: list (harski opto thomassgn Ezku adnap Gracenotes_ bwe jrp6 xrz srbaker saiam tobyp amiller qtplatypus keko_ qwandor|quassel etrepum bartavelle Jei mokus dagle bjobjo Adeon javawizard cross MiracleBlue dp_wiz nexion Xorlev zomg Liskni_si Chousuke Bane^ cursork Phlogistique __main__ Phillemann Zariel Tene ryanakca andreypopp mlen itsmonktastic joshc maurer mike2 chasecaleb dario rola lulf supki electrogeek kakos notori0us heaumer_ michaelpj kandinski Kinnison)
16:23:57 --- names: list (Na6hu7Ud_ gseitz mrd ClarusCogitatio_ hamarukusa clog mattp_ sunnavy_ lispy cmn cods bcoppens arch_ dv- TheMoonMaster asm89 Rutger` mbrock iota_ MrGwen robbert KitC hc `micro aseidl irssi eyenx andyland kardboardb janne ps-auxw dropdrive Razz haasn Nickeeh sea-gull slasktask popx Drezil MasseR_ bitemyapp devn BeardedCoder JZTech101 Desoxy zeroskillor pingu mrshoe twopoint718 flori CosmicRay Nivim Paprikachu liszt DustyDingo jdiez nispaur Watcher7 s4msung)
16:23:57 --- names: list (rhodesd Twey zebr honkfestival frms edk kshannon helgar eL_Bart0- paz jj2baile_ mietek theDon luite mp asfp`` WarzoneCommand Polarina abc56889_ flux Ornedan taruti shlevy Boreeas effy peterhil misetes bsmt BrianHV ipuustin savanni lpaste mimi_vx ab9rf khyperia snowp_ heath aninhume1 eikonos Kazurik_ noddy statusfailed mcsmash uzo Axman6 wei2912 xpika DarkFox flebron zugz Nik05 felipe_ dogmaT pfn somenick- jlewis SHODAN ckw cjay _jrp_ banyan farn noplamodo)
16:23:57 --- names: list (AtnNn tsou ParahSailin_ stepcut mgomes_ cyrusdavid knyppeldynan Arnar__ nesqi tomejaguar_away fabjan_ Yawgmoth davorak_ scopedTV_ companion_cube therealklanni sdx23 ChongLi n-dolio Transfusion NobbZ diginet GGMethos sodaplayer spion vikraman liuw kittenso1p ij andreasrx wjlroe gsilvis alinab pikhq lucca machrider bgyss yac seanparsons l3kn aljosa hongminhee Pythonfant k00mi earthy alcabrera|afk Maxdamantus b2coutts Hafydd Clint mandu sipa Klumben ByronJohnson)
16:23:57 --- names: list (oubiwann zalami fryguybob dyreshark Cr8 Walther charliekilo idnar gereedy ajcoppa joshsz agrif cjwelborn Bigcheese cin si14 jmcc ircbrowse dkua alphonse23_ skarn myme nkpart steshaw ortmage jlouis SethTisue_______ vera PatrickRobotham superjudge_ leifw Karethoth_ jzelinskie jmct ocharles Vbitz mrb_bk acfoltzer zpconn_________ blindscreen AlainODea raphie__ akahn werdna george2 caasih_ wizonesolutions mno2 puzza007 cstrahan nsaje teehemkay elgot sohum jnott)
16:23:57 --- names: list (FireFly shennyg__ lfp nifty jabbslad__ rschulman d3lxa Nimatek koala_man [swift] zq saurik feltnerm_ Derander callumacrae termos djapo Spockz clementd nikola mjo cepheus pygospa sm mitu Th0mas ab500-work ggherdov marsbot danneu lacrosse_ Jaak ido katis blenny PHO_ kosmikus indigo liyang iron_houzi kmapped dlackty_ MMuse kragniz_ korpse_______ `0660 TakSuyu coppro fyolnish bra KaneTW zeiris anders^^ thorkilnaur Raynos SLi fnordbert herrwolfe45 milli jodaro_)
16:23:57 --- names: list (petantik zph iteratee Preyer _1126 GaveUp uncleBlazer thoughtpolice kwmiebach_ posco yumike emmanueloga cloudhead jroesch_ billyiii avdi aristid lymmz Starfire tdammers airloom aupo mikeplus64 linduxed gdsx_ lyxia yeshuah ehamberg demolithion natte hsc tromp__ metadave elfangor geekosaur Cathy osnr phaer sgronblo gx^ carter wjm mikeizbicki CARAM_ nik_89 thorstadt Kneiva benmachine lieven_ noctux iulian Raynes mak` yano tomaw @ChanServ Ulrar z0d Laney mero burp)
16:23:57 --- names: list (shapr DasIch cmsd2 hvr ivan` waynr Enigmagic d-q-d gargawel ziman qrada tomprince Tehnix ilmig helge_ jnoah vhz lpsmith ephess kongo2002 iross pure bergmark pharaun Saizan Hodapp bxc_ mike4 enk0 zenzike jrw empyreal machineslearn oconnore bstrie jayne spaceships bvad deni Freundlich tlevine numberten yrjolam brixen rieper klugez mami_ benbangert qr42 dustinswan Eridius jaspervdj OrangeDuck int-e mrmonday peder zso Rembane Athas unsymbol solirc fractalcat)
16:23:57 --- names: list (bernalex cwc liori KitD hmax dilinger_ rs0 jimki annulus xenocons froztbyte Deewiant antoniy znutar adimit yam stevely sofancy terlar jonathanj tazjin srhb mononofu djahandarie)
16:24:07 <chrisdone> i'm using postgresql-simple on lpaste, ircbrowse and haskellnews, but only because they predate the newer, nicer db projects
16:24:44 <chrisdone> ircbrowse has very custom SQL queries because it's tens of millions of rows, so esqueleto would be a good thing to try
16:25:08 <bitemyapp> chrisdone: could make for a nice tutorial/experience report no?
16:25:15 <chrisdone> bitemyapp: i agree!
16:25:28 <bitemyapp> chrisdone: I'm sure more esqueleto resources would be welcome. There aren't a ton.
16:27:24 <spopejoy> I’m surprised the answer is so DBMS-specific, other than esqueleto.
16:27:42 <chrisdone> spopejoy: actually i was responding to the specific topic of postgres
16:28:05 <spopejoy> Which was the question
16:28:10 <chrisdone> but what other db would you want to use (without paying IBM a lot of moula)? =)
16:28:12 <spopejoy> I’m just surprised at the answer.
16:28:25 <spopejoy> I love postgreSQL, have no problem committing to it
16:28:29 <systemfault> Applicative question… am I wrong to expect that Just (*2) <*> Just (*3) should be the same as Just ((*2) . (*3)) ?
16:28:34 <chrisdone> sure
16:28:39 <kazagistar> if you write code for any database, then your code is kinda constrained to only use the places of overlap, unless you add a bunch of special cases
16:28:48 <benzrf> systemfault:
16:28:53 <benzrf> :t (<*>)
16:28:54 <bitemyapp> chrisdone: pah. OracleDB doesn't even have Serializable transactions last I heard.
16:29:06 <glguy> systemfault: That'd be:   Just ((*2) (*3))
16:29:12 <spopejoy> my Java and MS* days lead me to expect something like JDBC to exist and be the “default"
16:29:16 <chrisdone> bitemyapp: i was more thinking of IBM's DB2 =p
16:29:18 <benzrf> @ping
16:29:24 <bitemyapp> benzrf: ?
16:29:37 <benzrf> lambdabot isnt responding ;-;
16:29:41 <chrisdone> i think the HDBC and Hsql libs glory years are over after disappointment with the concessions made at supporting multiple backends and generally not-so-awesome implementations
16:29:42 <Sonarpulse> chrisdone: I was just trying to use structured haskell mode, and some call to bail is failing I think because bail is undefined
16:30:02 <chrisdone> Sonarpulse: bail? hmm
16:30:09 <bitemyapp> chrisdone: http://publib.boulder.ibm.com/infocenter/db2e/v9r1/index.jsp?topic=%2Fcom.ibm.db2e.doc%2Fdb2e_iso_levels.html
16:30:15 <Sonarpulse> shm-ast
16:31:12 <bitemyapp> chrisdone: this header is confusing: SERIALIZABLE (DB2 Version 9.1: Repeatable Read)
16:31:16 <bitemyapp> but it seems to mean they have serializable transactions. So that's good.
16:31:22 <spopejoy> Agree on HDBC etc, but JDBC/ODBC are different, generally allowing for high-performance drivers (for basic SQL)
16:31:32 <chrisdone> bitemyapp: yeah, not sure what that means. perhaps many connections can read until one does an update at which point y'all other guys gotta try again
16:31:34 <bitemyapp> they used weird terminology and eventually fixed it I guess.
16:31:47 <bitemyapp> chrisdone: I know what UCR, RC, RR, L, S mean
16:31:57 <bitemyapp> chrisdone: IBM's terminology was out of step with everyone else's, I found the explanation
16:32:04 <bitemyapp> chrisdone: they were using RS for RR, RR for S.
16:32:50 <chrisdone> Sonarpulse: hmm, i'm not sure why that is happening
16:33:07 <chrisdone> Sonarpulse: the bail function is totally flet'd and in scope
16:33:11 <halvorg> I like the akka(message passing library) and spray(http library built on akka) in scala, but the i'm not too fond of scala.
16:33:16 <halvorg> Is there something similar in haskell=
16:33:17 <halvorg> ?
16:33:25 <chrisdone> Sonarpulse: what do you get with M-: (set debug-on-error t)?
16:34:30 <Sonarpulse> one sec
16:34:31 <Sonarpulse> I'll try
16:34:46 <chrisdone> bitemyapp: it's nice that full isolation can be implemented properly in haskell a la STM
16:34:59 <chrisdone> (with retrying)
16:36:05 <josephle> halvorg: haskell has Control.Concurrent.Chan for message passing
16:36:13 <bitemyapp> chrisdone: aye.
16:36:20 <bitemyapp> halvorg: you probably want TChan and Async.
16:36:28 <bitemyapp> halvorg: there are faster alternatives like TQueue as well.
16:36:53 <Sonarpulse> werid it semed to fix tiself
16:36:58 <Sonarpulse> let me restart emacs
16:37:08 <halvorg> I'll check that out
16:38:55 <chrisdone> sonarpulse: RMS hasn't restarted Emacs since 1979
16:39:22 <spopejoy> I was waiting for an emacs-restart joke. Something about a LISP machine taking 30 minutes to reboot.
16:39:28 <chrisdone> :p
16:40:02 <bitemyapp> halvorg: http://hackage.haskell.org/package/unagi-chan
16:40:31 <kini> that's a strange name for a package lol
16:41:06 <bitemyapp> kini: makes Chan look silly :P
16:41:24 <halvorg> Well this one has graphs
16:41:26 <halvorg> so it won
16:42:05 <bitemyapp> halvorg: lol
16:42:12 <chrisdone> was it written by jinjing wang?
16:42:29 <chrisdone> ah, nope
16:42:34 <bitemyapp> "Author  Brandon Simmons"
16:42:45 <chrisdone> jinjing, first author to officially name a package "loli"
16:43:07 <bitemyapp> chrisdone: oh my god you aren't kidding
16:43:26 <chrisdone> hahaha
16:44:02 <Sonarpulse2> restarted and it's broken again
16:44:05 <bitemyapp> http://i.imgur.com/HoRNUKH.png   ಠ_ಠ
16:44:33 <kini> A minimum web dev DSL.
16:44:33 <kini> Note: loli is deprecated by miku.
16:44:35 <kini> good to know
16:44:43 <chrisdone> lol
16:44:50 <bitemyapp> I wasn't really convinced miku was a good idea either
16:44:57 <bitemyapp> Scotty seems to be okay for people that want that sort of thing.
16:45:06 <bitemyapp> and is a bit more relatable to normal Haskell (monad transformers)
16:45:09 <kini>  Moe: html with style
16:45:10 <kini> okay
16:45:15 <chrisdone> sonarpulse2: so what does debug-on-error yield?
16:45:17 <bitemyapp> "You do need to understand monad transformers to reach the full power of loli."
16:45:17 <Sonarpulse2> chrisdone: pastee.org/d6fa5
16:45:22 <bitemyapp> …this…is a plus?
16:45:39 * bitemyapp backs away slowly
16:45:51 <chrisdone> bitemyapp: did i reach full loli power yet?
16:46:09 <chrisdone> Sonarpulse2: interesting
16:46:13 <bitemyapp> do not google image search unagi chan -- nsfw
16:46:33 <benzrf> bitemyapp: >Unagi is the Japanese word for freshwater eel, especially the Japanese eel, Anguilla japonica
16:46:36 <bitemyapp> chrisdone: your power level is showing
16:46:48 <bitemyapp> benzrf: chans that are slippery and fast?
16:46:57 <bitemyapp> ./nick bitemyapp-chan
16:47:11 <benzrf> ./nick benzrf-san
16:47:37 <chrisdone> Sonarpulse2: what does M-h f cl-flet RET say?
16:47:48 <chrisdone> vim users look away now, we're about to get surgical
16:47:55 * benzrf covers his eyes
16:48:09 <chrisdone> (＾▽＾)
16:48:30 <bitemyapp> that face
16:49:00 <kini> chrisdone: you mean C-h?
16:49:09 <chrisdone> oops, yeah, C-h
16:49:24 * chrisdone adds kini to his secret list of emacs users
16:49:33 <kini> lol
16:49:36 <Sonarpulse2> ha
16:49:39 <kini> I'm an evil emacs user fwiw
16:49:39 <chrisdone> ┬─┬ノ( º _ ºノ) i'll be watching you
16:49:41 * hackagebot kd-tree 0.1.0 - A simple k-d tree implementation  http://hackage.haskell.org/package/kd-tree-0.1.0 (BenGamari)
16:49:42 <StoneToad> it's not so secret now eh?
16:49:52 <chrisdone> stonetoad: blast!
16:49:59 <Sonarpulse2> it's loaded
16:50:03 <kini> chrisdone: also, you accepted a haskell-mode pull request from me yesterday, why wasn't I already on your secret list? :)
16:50:11 <Sonarpulse2> autoloaded Lisp macro in `cl-macs.el`
16:50:13 <StoneToad> hahahahhahaaha
16:50:32 <chrisdone> Sonarpulse2: hmm… how about M-: (cl-flet ((bail () "OK!")) (bail)) RET
16:50:47 <chrisdone> kini: orly?
16:51:01 <kini> chrisdone: yeah -- https://github.com/haskell/haskell-mode/pull/291
16:51:25 <Sonarpulse2> echos "OK!"
16:51:26 <kini> it was strangely satisfying to write this email http://thread.gmane.org/gmane.emacs.vim-emulation/1667
16:51:50 <chrisdone> Sonarpulse2: curiouser and curiouser
16:52:15 <chrisdone> kini: ≖‿≖
16:52:40 <chrisdone> Sonarpulse2: what's your emacs version?
16:54:31 <Sonarpulse2> 24
16:54:34 <chrisdone> Sonarpulse2: i'll rewrite this bit of code and you can try it
16:54:41 <Sonarpulse2> ok cool
16:55:58 <chrisdone> Sonarpulse2: http://lpaste.net/9194684266657611776
16:56:24 <chrisdone> Sonarpulse2: try that. paste it into *scratch* or shm-ast.el and C-M-x it
16:56:58 <chrisdone> we can take this to #haskell-emacs if people start talking about haskell
16:58:01 <Sonarpulse2> I'm fine moving there
17:01:13 <Sornaensis> ç
17:01:22 <Sornaensis> Î
17:02:17 <joelteon> is there a package for globbing filepaths?
17:02:49 <chrisdone> yes, umm
17:02:52 <joelteon> oh
17:02:54 <chrisdone> johnw knows
17:02:54 <joelteon> it's called Glob
17:02:56 <simcity2000> joelteon: Glob
17:03:00 <joelteon> is that the one to use
17:03:01 <simcity2000> I just checked
17:03:20 <simcity2000> joelteon: hopefully, since I'll need a similar thing soon
17:04:04 <Clint> seems like something unix should do
17:04:14 <chrisdone> if you kow conduit, johnw wrote a find conduit
17:04:15 <chrisdone> http://hackage.haskell.org/package/find-conduit-0.4.1/docs/Data-Conduit-Find.html
17:04:38 <zzbacon> down with do? -> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
17:04:43 * hackagebot wkt 0.2.1 - Parsec parsers and types for geographic data in well-known text (WKT) format.  http://hackage.haskell.org/package/wkt-0.2.1 (BenGamari)
17:04:49 <joelteon> i don't want to pull in conduit too, this thing already depends on haskell-src-exts and lens
17:04:55 <joelteon> my users will die
17:06:09 <kini> Lemming sure has written a lot of haskellwiki articles
17:06:50 <kazagistar> joelteon: should the reasoning be "I already included haskell-src-exts and lens, so anything more is whatever"
17:07:00 <joelteon> I'm trying to get rid of lens
17:07:01 <benzrf> joelteon: how about pipes then
17:07:04 <benzrf> ( ͡° ͜ʖ ͡°)
17:07:32 <benzrf> Dependenciesbase (==4.*), mmorph (>=1.0.0 && <1.1), mtl (>=2.0.1.0 && <2.3), transformers (>=0.2.0.0 && <0.5)
17:07:34 <zzbacon> i |> like |> these |> things |> lots
17:07:37 <chrisdone> ψ(｀∇´)ψ
17:07:51 <benzrf> ^for pipes
17:09:38 <bms1> So I have been writing some visualization software and I'm using the vector package. I was getting some hiccups, and I assumed it was because I was allocating and garbage-collecting memory really rapidly
17:10:10 <bms1> So I switched my computations from working on immutable vectors to mutable ones, and used the same mutable vectors to avoid allocating and garbage collecting so much
17:10:24 <fread2282> is arr the only thing I need to get a Arrow from a Strong Profunctor?
17:10:28 <bms1> But now everything is much slower! Does anyone have any idea what that is?
17:11:27 <benmachine> benzrf: that face thing remind me of the moon from majora's mask, that is my contribution for the evening
17:11:31 <fread2282> or is there some way to derive arr from a Strong Profunctor?
17:11:43 <benzrf> :t evalState
17:11:44 <lambdabot> State s a -> s -> a
17:11:47 <benzrf> hmm
17:11:54 <benzrf> :t evalStateT
17:11:55 <lambdabot> Monad m => StateT s m a -> s -> m a
17:12:00 <shachaf> fread2282: You need composition, at least.
17:15:37 <rasfar> bms1: do you do heap profiling?
17:16:12 <zzbacon> i think Strong Profunctor is my favorite name right now
17:16:15 <zzbacon> so good
17:16:31 <bms1> rasfar: I did the "hp" profiling option. I didn't have any memory leaks, but I know from my code that I have to be allocating and collecting a lot
17:17:02 <bms1> And turning on -prof seems to mess with the vector code so much that it's kind of worthless
17:18:55 <rasfar> okay there is no -hp, I guess you meant -hT (the one you can do without -prof)
17:19:18 <bms1> I guess so! The one that you can just say -h
17:19:22 <rasfar> i've never had profiling really mess up anything, just slow it down, so you may be in deeper waters than I've plumbed
17:19:22 <bms1> :)
17:19:28 <simcity2000> you know, maybe I'm doing something "wrong" but after doing a few reasonable projects in Haskell I'm not seeing or needing all of the super high-level stuff as much as I'd expect
17:19:33 <benzrf> ooooooooh coyoneda is the free functor
17:19:36 <benzrf> i think i get the type now
17:20:07 <bms1> rasfar: My code slows down by like, more than a factor of 10, so I'm not convinced it reflects the same code path. I think some optimizations don't fire
17:20:08 <rasfar> but from -xt or whatever, you see tonnes of allocation and GC?
17:20:18 <simcity2000> it seems like the niceness of the type system and the ability to use pattern matching to do very fast prototyping/designing of software is talked about less than the subtleties of Applicative vs. Monad
17:20:18 <rasfar> i see
17:20:44 <rasfar> i worry about that too, but so far in my experience profiling hasn't played such tricks on me
17:20:47 <bms1> You know, I should check if it was actually GC causing the issue. I did kind of assume
17:21:00 <benzrf> :t Coyoneda
17:21:00 <lambdabot> Not in scope: data constructor ‘Coyoneda’
17:21:06 <benzrf> mm
17:21:37 <rasfar> does anyone know if -prof can interfere with rules firing, or anything like that?
17:21:56 <Cale> simcity2000: Well, that stuff has been around for much longer still, so we take it for granted.
17:22:41 <fread2282> shachaf: but is Category and Strong Profunctor enough to define arr?
17:22:56 <bms1> rasfar: I read that here http://stackoverflow.com/questions/9409634/is-indexing-of-data-vector-unboxed-mutable-mvector-really-this-slow and, well, took it at face value
17:22:58 <simcity2000> Cale: right, the really high-level stuff is certainly useful, but after using the language in practice what really resonates with me is the ability to just Do Things Quickly©
17:23:05 <shachaf> fread2282: Sure.
17:23:15 <bms1> Turning on -prof certainly makes it impossible for me to read the "simpl" output!
17:23:24 <fread2282> nice
17:23:35 <simcity2000> speaking of which, does anybody have the URL to the new haskell.org?
17:23:44 <shachaf> :t \f -> lmap f Control.Category.id
17:23:45 <lambdabot> (Profunctor p, Category p) => (a -> c) -> p a c
17:24:07 <simcity2000> nevermind, got it
17:24:49 <rasfar> bms1, well it sounds like you're a bit more experienced than me, so probably it's not appropriate for me to tell you "don't shy away from -prof, you really will need it in some cases"
17:24:59 <Cale> http://new-www.haskell.org/ god I hope this doesn't become our new front page :P
17:25:05 <joelteon> Me too
17:25:27 <simcity2000> Cale: you don't like its sleek web 9.0.3a design?
17:25:37 <bms1> rasfar: Well, I'm not very experienced with profiling! Your help is appreciated
17:25:41 <Cale> and the marketing BS
17:25:47 <Cale> please no
17:25:59 <rasfar> but switching to mutable, the first thing that suggests to me is the possibility of heap use that might need tuning
17:26:24 <bms1> rasfar: Any idea if there's some gotcha with doing things the mutable way?
17:26:26 <benmachine> Cale: I sympathise but also writing about stuff in a way that is concise and exciting and not BS is… choose two
17:26:32 <rasfar> i wouldn't be able to rest until i'd looked carefully at -hc and -hd (which one shows the stack? i forget)
17:26:53 <djahandarie> Cale, I hope it does!
17:27:00 <Cale> I choose concise and not BS please
17:27:01 <bms1> rasfar: Just to confirm, the code is much *slower* doing things mutably!
17:27:05 <fread2282> benmachine: see the rust homepage
17:27:07 <simcity2000> benmachine: I think you could probably take the first third and the last third and omit the middle
17:27:16 <Cale> fuck exciting, it doesn't need to be exciting
17:27:18 <benmachine> and anyway, our current homepage describes Haskell as "advanced" and "an open-source product of more than twenty years of cutting-edge research2"
17:27:28 <rasfar> bms1: only that elements are wrapped; my understanding is the ... oh, i'm thinking of "unboxed" which is not the same as "immutable" (haven't used Vector much, and not for a while)
17:27:39 <simcity2000> Cale: ideally you only look at the homepage once
17:27:41 <Cale> I would rather have the deduction rules for the Hindley Milner type system
17:27:43 <benmachine> Cale: I like it when people are excited about things :(
17:27:57 <Cale> than a bunch of marketing speak
17:28:18 <bms1> rasfar: I'm actually using unboxed vectors for both; yep, that's different
17:28:23 <djahandarie> Cale, is the audience of haskell.org to recruit new Cales?
17:28:23 <Cale> (obviously we could do better than either, but if that was the choice...)
17:28:33 <rasfar> bms1: are able to share the code? / i see, that clarifies a bit
17:28:39 <bms1> rasfar: immutable makes a copy when I perform operations, while mutable is, well... mutable. I edit the same array
17:28:41 <Cale> djahandarie: Ideally, yes
17:28:41 <benmachine> Cale: well, submit a pull request :P
17:28:43 <DeadChannel> Hi, I just dropped in
17:28:45 <DeadChannel> again
17:28:45 <simcity2000> Cale: I think the problem is that there's a perception of the language as being too academic, and this is an attempt to really shove everything in the other direction
17:28:50 <benzrf> hello DeadChannel
17:28:52 <DeadChannel> to tell you all that you people are awesome.
17:28:55 <simcity2000> DeadChannel: whatup
17:28:56 <DeadChannel> Have a nice day.
17:28:59 <Cale> simcity2000: Yeah, we don't need to be doing that imo.
17:29:07 <simcity2000> we're cool
17:29:09 <rasfar> so you naturally expect mutable to give better performance, where copying would otherwise be necessary
17:29:12 <fread2282> the rust homepage is awesome and IMO we should just copy it
17:29:14 <djahandarie> Cale, unless you have a cloning machine you haven't told me about, I'm not sure that will recruit very many people... :-)
17:29:26 <simcity2000> fread2282: it looks like the Go homepage except not uh, ugly
17:29:33 <simcity2000> http://golang.org/
17:29:46 * hackagebot vector-algorithms 0.6.0.3 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.6.0.3 (DanDoel)
17:29:47 <bms1> rasfar: My code is too strung out for anyone to read it; it's a mess. I'm using java-bridge to call the JNI - that's where the visualization code is. Then the array code is spread throughout several packages
17:30:07 <rasfar> bms1: if you're willing to share your code with me, I'd certainly give it some attention; i'm sorry these kinds of questions don't get the attention they deserve; these are the issues that concern the working programmer.
17:30:15 <bms1> rasfar: Right, that's what's perplexing me - performance can be so finicky!
17:30:18 <shachaf> Who looks at the home page for a programming language anyway?
17:30:22 <fread2282> simcity2000: but it has more useful links that are catagorized better and also more convincing text
17:30:34 <simcity2000> shachaf: people who are looking to download the language compiler/interpreter
17:30:44 <benmachine> shachaf: I suspect part of the problem is that the people who look at these pages and the people who write them are not the same people :P
17:30:52 <shachaf> OK, so the download link at the top is good.
17:31:00 <simcity2000> fread2282: yeah, that wasn't a value judgment, just pointing out that the style is similar
17:31:02 <shachaf> Code samples and links to documentation are good.
17:31:10 <simcity2000> the home page should just get you to download the thing as fast as possible
17:31:13 <shachaf> An exponential-time fibonacci example is kind of awful. :-(
17:31:24 <fread2282> simcity2000: maybe
17:31:43 <bms1> rasfar: I appreciate your willingess to help! I can put up some of the workhorses for my mutable code
17:31:58 <simcity2000> looks like the haskell folks decided to take a page from Python: https://www.python.org/
17:32:15 <fread2282> also rust's API docs are awesome. realtime search
17:32:16 <shachaf> Link to the wiki and such would probably be good.
17:32:16 <rasfar> sure; i've reread what you first asked, and i can't think of what to suggest based on that and our discussion so far.
17:32:16 <benmachine> shachaf: yeah I thought that was silly
17:32:29 <simcity2000> fread2282: I'm skeptical of Rust getting mainstream adoption
17:32:53 <rasfar> (except to profile!)
17:32:54 <Cale> "No More Null Errors" -- this is only half-true. I mean, you and I know why it's true, but there's a pretty good argument that bottoms can amount to the same thing.
17:33:09 <bms1> rasfar: http://lpaste.net/3335960274862604288
17:33:12 <fread2282> simcity2000: why?
17:33:18 <shachaf> The marketing nonsense isn't relevant to people like me, though I wish it didn't actually go so far as to tell lies.
17:33:33 <shachaf> Then again, does Haskell really need more people like me?
17:33:37 <fread2282> my gut feeling is that rust is doing WAY better than haskell in that
17:33:42 <bms1> That's the code that's behind a lot of the mutable code. I've replaced "map" operations with mMap, zipWith with mZipWith...
17:33:44 <Cale> "Scaling Just Works" -- wtf does this even mean? We have concurrency and parallelism primitives?
17:33:45 <simcity2000> fread2282: I usually see it as compared to Go, not Haskell
17:33:51 <benmachine> shachaf: yes please :>
17:33:58 <benzrf> Cale: since when are bottoms a practical concern
17:34:01 <benmachine> well, benmachine does
17:34:07 <simcity2000> Cale: I think the idea is that purely functional code is really, really easy to scale
17:34:12 <simcity2000> compared to C and pthreads...
17:34:18 <benzrf> how often do you really use partial functions?
17:34:24 <shachaf> benmachine: In particular I meant grouches.
17:34:32 <benmachine> shachaf: aww but you're a friendly grouch
17:34:33 <Cale> benzrf: ever since *** Exception: Prelude.head: empty list
17:34:33 <benzrf> and when you do, how often are they not immediately preceded by a check?
17:34:33 <rasfar> mbs1: of course the time profile is also nice to see, which you get only with -prof
17:34:36 <bitemyapp> Cale: I get type errors, including from nulls, 9001x more often in languages that aren't Haskell than I do in languages that are Haskell.
17:34:39 <benzrf> Cale: who uses head
17:34:42 <djahandarie> Better than grinches.
17:34:44 <bitemyapp> Cale: I've only seen noobies get that.
17:34:48 <benzrf> bitemyapp++
17:34:48 <Cale> benzrf: You and I know this
17:34:52 <benmachine> Cale: "scaling just works" in the sense that purity makes parallelism much easier to manage
17:34:58 <Cale> But newbies are the ones who get hit with it
17:34:59 <benmachine> parallellism/concurrency
17:35:02 <bms1> benzrf: Most code uses tail/head a lot, and I personally don't use them, but I do the equivalent thing by pattern matching
17:35:04 <benzrf> Cale: bleh
17:35:06 <Cale> That's what I mean by half-true
17:35:10 <shachaf> whoa, http://blog.ezyang.com/2011/04/how-the-grinch-stole-the-haskell-heap/
17:35:19 <Cale> It is kinda true, but only once you start programming more carefully
17:35:25 <djahandarie> shachaf, see!
17:35:27 <benzrf> bms1: yes, but how often do you pattern match without alternatives
17:35:34 <Cale> and that doesn't really have a whole lot to do with the language so much as its culture
17:35:49 <bms1> benzrf: That's what I'm saying - quite often! Oh, I know this list won't be empty...
17:35:53 <simcity2000> Cale: most people aren't going to look for a proof of each item in the list
17:35:59 <shachaf> People have been selling Haskell as great for parallelism since well before GHC had multicore support.
17:35:59 <bitemyapp> Cale: have you seen how many values/errors other than the value of the type you're expecting you could get in a language like Scala?
17:36:00 <benmachine> Cale: I disagree, to some extent at least
17:36:10 <benmachine> Cale: I think the language itself makes that sort of carefulness easier
17:36:15 <bitemyapp> Cale: it gets chopped down from a list 10-20 things that could ruin your day and that you must defend against to just bottom/partial functions.
17:36:17 <Cale> Now, there is the fact that you can't check for a bottom so easily, which dissuades people pretty quickly from that style of programming
17:36:23 <bitemyapp> Cale: there is positively no comparison to be made here.
17:36:44 <Cale> bitemyapp: I know that, my problem is that the marketing speak is overstated.
17:36:49 <simcity2000> Cale: my beef with the language on the site is that it's just too peppy
17:36:56 <Cale> It should be way more qualified.
17:37:04 <zzbacon> :t head
17:37:05 <lambdabot> [a] -> a
17:37:06 <Cale> and yeah
17:37:17 <rasfar> bms1: at top of miZipWith you have a comment saying it reads only from the first vector, but it reads from both ... right? (just a sanity check on my part)
17:37:20 <bitemyapp> Are we talking about http://new-www.haskell.org/ ?
17:37:21 <bms1> rasfar: Idea! I used that "zipFuncs" function for one of my things. That could potentially be a nightmare if it doesn't optimize well, right?
17:37:22 <benzrf> simcity2000: sort of same
17:37:25 <Cale> bitemyapp: yes
17:37:28 <benzrf> its a bit eh
17:37:28 <bitemyapp> sigh.
17:37:30 <simcity2000> Cale: I think if the "Haskell problems never do!" thing got axed I'd be cool with the text
17:37:33 <benzrf> how to say
17:37:38 <bitemyapp> Cale: just PR it if you don't like the language.
17:37:48 <Cale> PR?
17:37:48 <bms1> rasfar: Yep! "Only reads" is supposed to mean "doesn't write" :)
17:37:52 <benmachine> Cale: pull request
17:37:57 <bitemyapp> Cale: it's on Github, you can submit a patch.
17:37:59 <simcity2000> I think it's a solid site though, except it's a bit big
17:38:00 <benzrf> it reminds me of the kind of language used to advertise rails extensions, or something
17:38:01 <rasfar> oh of course
17:38:02 <bitemyapp> and get it re-deployed.
17:38:03 <benzrf> >.>
17:38:13 <Cale> I don't have an account there. Why isn't it a wiki?
17:38:35 <simcity2000> Cale: because it's on github
17:38:40 <Cale> :P
17:38:43 <bitemyapp> Cale: harder to do a good job design-wise with the markup the wiki uses.
17:38:45 <simcity2000> potato potahto (for most), haha
17:38:48 <benmachine> Cale: to be fair, you need an account to edit haskellwiki, you just happen to have one
17:38:57 <bitemyapp> Cale: and many people would rather use their own text editor and git to submit changes.
17:39:01 <Cale> benmachine: Yes, I'm also a bit unhappy about that
17:39:10 <rasfar> bms1: i would seriously suggest profiling, and look at the .prof as well as the .hp. or you can keep tinkering at whim...
17:39:35 <Cale> benmachine: It happened because of spam bots, but it was supposed to remain easy to get accounts if you can prove you're human.
17:39:59 <simcity2000> Cale: github accounts are pretty standard issue these days for developer types
17:40:02 <bms1> rasfar: Thanks for all your help! I think the first thing I will actually do is look at my use of zipFuncs and see if that optimized away the list of functions. If not, that would explain the bad performance
17:40:21 <Cale> simcity2000: Yeah, maybe. I just prefer other revision control systems.
17:40:29 <simcity2000> that's fair
17:40:49 <rasfar> bms1: wow! so you prefer to look at core than to use profiling?
17:41:08 <rasfar> same with others here or what?
17:41:22 <simcity2000> at the end of the day I'm just happy that new-www advertises the things that someone like me cares about
17:41:27 <bms1> rasfar: I don't think I have ever successfully learned anything from profiling
17:41:31 <benmachine> Cale: ever since github grew an "edit" button it's increasingly possible to use github without using git
17:41:52 <Cale> I just wish we could keep the marketing-speak entirely out of our presentation to beginners.
17:41:57 <benmachine> bms1: I've had both successes and failures, profilingwise, I think some problems are more amenable to it than others
17:42:02 <bms1> rasfar: Looking at core, I can at least know if performance improves (theoretically), even if I had no idea what effect it actually has!
17:42:07 <Cale> It's unnecessary, and doesn't help anyone involved.
17:42:07 <rasfar> well i certainly have improved code performance by looking at profiles, but maybe i didn't learn as much as I would reading core
17:42:09 <benmachine> Cale: I wish that too, but finding a good alternative is hard
17:42:22 <shachaf> I agree with Cale, for what it's worth.
17:42:45 <simcity2000> Cale: and I wish that newbies weren't beaten over the head with monad tutorials
17:42:53 <Cale> benmachine: Just state facts only, as dryly as possible. Either the language should stand on its own two legs, or it doesn't deserve success.
17:43:10 <simcity2000> Cale: like it or not, that's rarely how people operate
17:43:10 <shachaf> Cale: That's going a bit far.
17:43:37 <benmachine> Cale: but which facts, and how?
17:43:40 <bitemyapp> Cale: holding ourselves to that means terrible tools made by people willing to lie reign.
17:43:51 <simcity2000> people respond based on emotions, and some people's emotional responses are guided by facts
17:43:57 <rasfar> bms1: i don't really understand that -- it seems like you'd have to be very experienced to judge by /reading/ core, what profiling would normally be used to tell you
17:44:00 <bitemyapp> I'm not saying we should lie, but we can tell the truth with some flair and a sense of marketing.
17:44:14 <Cale> bitemyapp: I don't really care what reigns.
17:44:21 <benzrf> bitemyapp++
17:44:25 <benzrf> Cale: oh really
17:44:27 <Cale> Haskell isn't about to die
17:44:27 <bitemyapp> Cale: I do, I do CRUD for a living!
17:44:31 <bitemyapp> Cale: this shit affects me.
17:44:33 <benzrf> Cale: how do you feel about the preponderance of php
17:44:40 <bitemyapp> Cale: Haskell not being popular makes my job miserable.
17:44:42 <kvanb> my company still uses cobol
17:44:47 <Cale> It's going to continue existing, and therefore it will continue to be available for our use.
17:44:50 <kvanb> maybe if haskell gets popular now we'll touch it in 120 years
17:44:53 <bitemyapp> Cale: not everybody gets to do interesting stuff where they can choose everything they're going to use.
17:44:54 <benzrf> kvanb: i choose not to believe you
17:44:55 <rasfar> nobody else seems to be interested, unfortunately
17:45:04 <benzrf> w.r.t. cobol
17:45:08 <bms1> rasfar: If I look at profiling results, I will see that the expensive functions I have are... expensive! But it's hard to know if they are too expensive, etc. Or if the cost is really coming from some module that just doesn't have profiling enabled
17:45:12 <Cale> I dunno, just be more picky about employers?
17:45:20 <kvanb> I can't lie to you ...
17:45:21 <bitemyapp> were it that simple.
17:45:23 <benmachine> Cale: that's not an option everyone has
17:45:25 <kvanb> ;_;
17:45:30 <bitemyapp> this is too depressing for me, I'm out.
17:45:42 <Cale> I guess that's true
17:46:03 <Cale> I still don't 100% consider myself a programmer, despite the fact that my last few jobs have been programming (mostly in Haskell)
17:46:16 <rasfar> bms1: well, I have profiling versions of all my deps handy -- i think with -fauto-all (or whatever) it would give you pretty reliable info
17:46:21 <simcity2000> Cale: what do you consider yourself?
17:46:32 <SCHAAP137> reading the tutorial now about infinite data structures, rly cool
17:46:38 <benzrf> @remember Cale I dunno, just be more picky about employers?
17:46:38 <lambdabot> Done.
17:46:44 <zzbacon> a hardy cabbage of a variety that produces erect stems with large leaves and no compact head
17:46:48 <Cale> My degree is in mathematics, so if it became impossible for me to get a programming job on the terms I like, I'd go looking for work in other mathematical areas.
17:47:05 <benzrf> zzbacon: what prompted that
17:47:08 <simcity2000> Haskell could be a programming language for professional use, or it could be another academic research project shoved in a filing cabinet somewhere
17:47:10 <bms1> rasfar: -auto-all works for dependencies? I thought you have to make sure that your dependencies were compiled with ghc-prof-options = -auto-all?
17:47:29 <Cale> simcity2000: But it's both of those things, and neither.
17:47:31 <zzbacon> benzrf: cale/kale ... joke didn't go well :p
17:47:37 <benzrf> oh
17:47:39 <simcity2000> zzbacon: missed that bit
17:47:41 <rasfar> that may be; perf problems are normally in /my/ code, not the libs i'm using :)
17:47:42 <zq> why can't cabal just fill in my dependencies for me
17:47:43 <benmachine> zzbacon: I got it
17:47:45 <zq> ugh
17:47:46 <benzrf> lol
17:47:48 <simcity2000> I like it
17:47:51 <benmachine> zzbacon: just didn't comment, sorry :P
17:48:17 <simcity2000> Cale: all programming languages have some theoretical backing (except for perl/bash/php maybe)
17:48:31 <Cale> simcity2000: so?
17:48:42 <bms1> rasfar: Ah yes! Same here :) But I can be misled if dependencies are actually taking 90% of the compute time - then nothing I can do will really help
17:48:43 <rasfar> bms1: if the perf changed when you changed /your/ code, you could reasonably expect to see effects in the .prof/.hp for your code
17:48:49 <simcity2000> but adoption by lots of people brings the potential for newer and cooler things
17:49:08 <bms1> rasfar: Very true! I can give it a try!
17:49:08 <simcity2000> and being concerned about only theory and logical clarity don't bring in people
17:49:09 <dibblego> adoption by lots of people can stunt progress
17:49:15 <benmachine> bms1: get better dependencies :)
17:49:17 <simcity2000> dibblego: true, look at python 3
17:49:20 <dibblego> and scala
17:49:37 <dibblego> "lots of people" is a goal that I not only care for, but I truly hope does not happen
17:49:41 <dibblego> I prefer, "lots of ideas"
17:49:50 <dibblego> +not care for
17:49:52 <benmachine> adoption by lots of people may stunt progress of haskell, but it will probably help the progress of people
17:49:57 <bms1> benmachine: I think the vector package is at the same time the best package and the worst package
17:50:01 <simcity2000> dibblego: you at least need a population that's not falling
17:50:03 <dibblego> benmachine: disagree
17:50:03 <rasfar> helping address practical difficulties of people trying to do real programming will help bring in people :)
17:50:05 <simcity2000> not that I think the haskell population is
17:50:27 <dibblego> *I* need a population committed to ideas above all other things
17:50:31 <simcity2000> dibblego: C became the standard low-level language, and people saw the problems in C
17:50:35 <bms1> Performance is amazing when the optimizations fire, but it can be bad in some cases where you might not expect
17:50:41 <dibblego> fancy dress parties ala scala, are in direct contention with my goals
17:51:08 <simcity2000> dibblego: I prefer good execution of good ideas
17:51:10 <kazagistar> simcity2000: haskell has managed to avoid the academic filing cabinet for, what, more then 20 years? and it certainly isn't dying now, if anything, it is booming. So no rush.
17:51:11 <rasfar> bms1: you're talking mainly about GHC RULES in the vector lib?
17:51:30 <Cale> I also think the rate at which the Haskell user base is growing is already large enough that it's a struggle to give all the beginners the attention we'd like.
17:51:45 <benzrf> rasfar: ghc rules!
17:51:51 <bms1> rasfar: Partially! And sometimes other things I wouldn't expect
17:51:52 <Cale> kazagistar: Yeah!
17:52:01 <simcity2000> kazagistar: yeah, I'm excited about the potential for Haskell as concurrency/related become bigger
17:52:09 <zzbacon> is this list of haskell swag comprehensive? -> http://www.haskell.org/haskellwiki/Merchandise
17:52:15 <rasfar> does -ddumpsimpl (or whatever) show you which rules fire? or do you use
17:52:15 <Cale> Haskell is big enough to never die at this point, which in some ways is happy, and in others is kind of sad.
17:52:21 <rasfar> -fenable-rewrite-rules -O -ddump-rules -ddump-simpl-stats -ddump-rule-firings (or whatever!)
17:52:25 <bms1> foldr1 (zipWith (+)) goes much much slower than foldl1' (zipWith (+)), even with unboxed vectors...
17:52:55 <rasfar> bms1: yeah, the heap profile would help see why too
17:52:56 <simcity2000> Cale: I like it because it doesn't really feel like it gets stale
17:53:02 <bms1> I had no idea about the rule-firing options! That might be really helpful (for the immutable code at least)
17:53:10 <rasfar> ok
17:53:22 <Cale> simcity2000: I dunno. The development of the language has been slow enough in recent years to make me look for another ship to jump to.
17:53:44 <dibblego> in what other language are good ideas so heavily exploited?
17:53:59 <simcity2000> Cale: development towards what? the big new languages out there atm as I see it are Go and Rust
17:54:05 <Cale> If someone puts the work in to have a lazy-by-default dependently typed language with a usable IO system, that might become my main language pretty quickly.
17:54:33 <zq> cough idris cough
17:54:34 <bjz> Cale: why do you want lazy-by-default?
17:54:45 <zq> just annotate everything with Lazy _
17:54:47 <benmachine> zq: idris is strict by default
17:54:48 * hackagebot language-openscad 0.1.4 - A simple parser for OpenSCAD  http://hackage.haskell.org/package/language-openscad-0.1.4 (BenGamari)
17:54:48 <Cale> bjz: Laziness is pretty important to the way that I think about programming
17:54:52 <zq> just annotate everything with Lazy _
17:54:53 <dibblego> zq: idris is not lazy-by-default and is not usable in any way in that respect
17:54:54 <zq> benmachine:
17:54:55 <benmachine> zq: that doesn't work as well as you'd hope
17:55:00 <dwcook_> Cale, why lazy-by-default, as opposed to just laziness available?
17:55:04 <dibblego> what benmachine said
17:55:06 <bjz> zq: that's what I would have thought
17:55:17 <simcity2000> Cale: I think most programmers work on a strict model of evaluation
17:55:33 <dwcook_> benmachine, please explain.
17:55:35 <dibblego> s/most/wrong
17:55:35 <Cale> dwcook_: Because lazy evaluation has no opportunity to provide most of its benefits in an eager-by-default setting
17:55:36 <Geraldus> Hi friends! I'm having troubles installing `prce-light`, because it can't find `pcre.h` file on my mac. I have PCRE installed via Homebrew, so how to specify in cabal.config an external library directory?
17:55:37 <benmachine> simcity2000: I think that's directly because most programming languages do
17:55:45 <simcity2000> benmachine: well yeah
17:55:51 <Cale> The benefits of laziness come from compositionality
17:55:55 <dwcook_> Cale, eager-by-default and lazy-by-default are not all the options.
17:55:57 <benmachine> simcity2000: if you spend enough time with lazy evaluation, it becomes natural
17:56:01 <bms1> rasfar: benmachine: Another "gotcha" I had was when I defined a polymorphic "zip-like" function on 2 vectors, and it didn't get inlined (and most importantly, specialized), and so performance was awful
17:56:14 <simcity2000> benmachine: it does, and I agree. I'm just saying that most people's initial impressions are not to look at something as lazy
17:56:14 <OscarZ> functional programming is getting more popular all the time.. maybe Haskell should advertise itself as a pure functional programming language which you should learn to know whats its really about.. to learn the about FP and related concepts
17:56:15 <Cale> and if someone wrote the piece that you need, but it's strict for no good reason other than that was the default, then you lose that compositionality
17:56:23 <dwcook_> Cale, hmm, that is a good point.
17:56:29 <Geraldus> I tried add `libdir: <path to prce include dir>` but cabal can't recognize this
17:56:34 <simcity2000> OscarZ: it's a bit depressing to aspire to be a teaching tool
17:56:48 <dwcook_> I do like Haskell's laziness. I just haven't thought before about how it might be better than merely having laziness as an option.
17:56:53 <OscarZ> and when people get into it, they begin to appreciate it
17:56:54 <dibblego> a good teaching tool inspires good ideas, which is my goal
17:57:04 <rasfar> bnzrf: i used to prefer hbc really; from now on it's "ghc rules" in miniscule only.
17:57:11 <rasfar> ^benzrf oops
17:57:15 <dibblego> I will wait for other languages to e.g. stop writing macros and catch up to lens, maybe take 10 years or so — by then, they'll still be in the dust
17:57:16 <benmachine> dwcook_: OCaml has laziness as an option, but no-one uses it and you can't really add it after-the-fact
17:57:25 <benmachine> dwcook_: so it goes basically unused
17:57:46 <simcity2000> I still haven't touched lens, actually
17:57:52 <simcity2000> (surprisingly)
17:57:58 <benmachine> simcity2000: it's fun
17:58:10 <Cale> Yeah, I don't mind that approach to selling the language to beginners. If we're going to tell people "Hey, maybe there are some cool ideas to learn here that you might be interested in", that's fine by me.
17:58:16 <benmachine> I don't really understand lens, but I think about it in terms of "could this possibly work?" and if the answer is yes then it probably does
17:58:21 <izaak> benmachine: I find laziness in ocaml a bit hard to do. one gets so used to pervasive laziness in haskell that it's sometimes tricky to know what exactly to make lazy when doing it manually!
17:58:27 <rasfar> @remember benmachine adoption by lots of people may stunt progress of haskell, but it will probably help the progress of people
17:58:27 <lambdabot> It is forever etched in my memory.
17:58:33 <dibblego> I can point to countless examples of progressive thinking, made possible because of haskell as a tool — again, ideas, not tools — tools are just the vehicle
17:58:59 <benmachine> izaak: yeah, that's also true
17:59:12 <simcity2000> benmachine: it looks spiffy, though I'm not sure where I'd need to use it just yet
18:00:10 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
18:00:10 --- topic: set by Cale on [Sat May 31 02:09:44 2014]
18:00:10 --- names: list (clog eacameron JobV archmonk calumet ddellacosta talios Geraldus acharles coaupiff falafel asmyers GeraldCode Guest79553 plucas dibblego jophish__ tnks dysinger saml_ pmylund thirsteh _flow_ spott Darien banister ab9rf urn kmels Enigmagic NikolajK BrianHV dutchie ixian sea-gull c74d3 khyperia flux nullbyte spopejoy genericpersona izaak sw17ch croyd mister_integer gabriel oleo__ weems|mac johann_ n0n3such bms1 zematis thunderrd Kabaka dgpratt TheMoonMaster)
18:00:10 --- names: list (erickedji asm89 eyenx ps-auxw godel bjorkintosh everett sveit Draggor eazar001 sviterok heyj noteventime purefn1 epta scott lambdabot sleepynate edwardk_ ivoscc andyland netj_ mwhit dju- robbert` Philonous efm` cmn_ lemao ndrr yeltzooo4 zachmass- tippenei1 `micro_ sunnavy wormphle1m elij_ dwcook_ trism cods_ mbrock_ hiredman hc jaysonsantos_ dropdriv1 asterbla1ter Rutger`_ irssi_ dv-_ lispy_ SoupE hng kav_ dottedma1 FreeFull_ KitC_ iota__ AshyIsMe_ kennyp_)
18:00:10 --- names: list (Razz_ arch__ wting_ tero-_ ChewieBe1rdy predator217 dxld_ mattp__ jrm bbastian- kardboardb thetallguy1 MrGwen1 joefiorini aseidl_ Krakarn-- kyb3r_ ssedov fold Exio4 _JokerDoom DT`` kludgy colluphid S11001001 bvck kvanb drjeats lelf William__ path[l] pgiarrusso_ Sauvin ldbrandy psychicist_ scottj ajyasgar kfish fionnan nick_named lpvb q66_ nemesit|znc Swizec paperManu danclien-afk drbean mitchty agjacome meiji11 intrados Plazma andyt jtcwang desophos jle` j2j)
18:00:10 --- names: list (tac-tics jaimef Beetny c-rog ddrone frerich2 iXeno MP2E rasfar meandi triliyn steamboat viszu _ikke_ waterlaz btubbs Ethix ArneL Apocalisp sprang sclv_ Guest35 milessabin dsirenko_ Rastus_Vernon latro`a manuel_ yfeldblum negatratoron jml filename frankle sagittarian amesha_ peste hebz0rl ChristianS gamegoblin yogurt_truck mawuli danofsatx-work aartamonau djfoote fiatjaf vendethiel _ashbreeze_ systemfault StolenToast troydm danl-ndi u_ Kron ozgura randen)
18:00:10 --- names: list (cjenkin2 cgag arancia Noldorin ropav purefn OlegYch darthdeus MitchellSalad joneshf-laptop marchelzo_ sbyl merijn nakal_ jrib jonaias_ MindfulMonk MuffinMan` jeffwise Ralith nisstyre kazagistar WraithM pamojarpan ttll tromp___ rahul akurilin amiri stevej JeroldHaas_ manfoo7 Talryn SCHAAP137 apaku refold StoneCypher byte48 LeoTal orion plutoniix xcthulhu raichoo d3m1g0d- paluh_ gbarboza martinalex zzbacon hiptobecubic tb01110100 Lubbadubdub otulp djoyner)
18:00:10 --- names: list (Sculptor whaletechno ixti bergey Corey michaelt albel727 cmears copumpkin justinleitgeb Sorella sigma914 plhk artyomkazak Betal BMeph_ fread2282 mceier ajf asjo geal aergus arun CaptainLex inuoppai rbocquet zxq9 jin_jin A1kmm rblackwe mindos_cloud__ strmpnk c9sould lep-delete gienah phadej AleksejsHome joash friden sx ephemeron juhp tv ClumsyDove [mth] chatsiri_ gfixler osa1 gidogeek dsantiago xinming sw1nn aloiscochard lenstr fling Turboknot13 erikd lokydor)
18:00:10 --- names: list (Youri silver shmookey DarkCthulhu magicman hackagebot elsimio2 wlhlm wagle goldkatze johnw dolio sakiriou1 ruuns EvanR_ deavid pgokeeffe PotatoGim davidfetter ruzu ousado_ otto_s milky Shin-LaC Gilfoyle petercommand tessier shanse armyriad dsturnbull lostman metaqix Igloo blicero lazyhaskeller bbee deevus neptunepink ivanm eyck Tesseraction cognominal jophish pfurla SegFaultAX ormaaj chrisdone oakwhiz Jyppe OscarZ StoneToad Peaker tommd aupiff coeus AncientPC)
18:00:10 --- names: list (killy9999 jonsmock sclv Brando753 kini brycelane neektza mikecaruso lamilami Plasmastar bjz shelf Lacriatch cerchio Excureo c_wraith jorj vsayer Gertm ccasin luzie Luke- MagneticDuck jrslepak LordBrain bitraten raschwell batz andyo andares yacks averell andrewsw charlie em hamishmack tismith Dashkal mkrtem seliopou joelteon benzrf simcity2000 cschneid Magnus_Vortex Zekka ethercrow drlemon shachaf martingale ndeine mgaare omefire cjheath gridaphobe cpa)
18:00:10 --- names: list (LysergicDreams cdk schlumpi obcode bgamari wtw rejuvyesh[away] kipras`away Burton cehteh Natch aford gdaws biscarch r444 paddymahoney fikusz npcomp|away kloeri_ relrod stack sarlalian reggie1 Wamanuz canta ninzine suOya_ lithiumdeuteride JHaas theorbtwo bchar centrinia koz Boney kgadek pjdelport gnomnain Vorpal zyx DarkLinkXXXX__ T_X kalz skchrko ski haroldwu Internet13 gws maoe pkmx homam Bwild anborn jacobw metaf5 Sornaensis ReinH dreixel phaskell Edoxile)
18:00:10 --- names: list (chas s_e serjeem emlow xnyhps dixie tristero Revenrof quaestor1 petterw defanor pdxleif BlastHardcheese AntiSpamMeta staffehn zoink mmaruseacph2|umb m_george slobo_ noam hyPiRion Xack `^_^v vpm dgvncsz0f mephx rudi_s dmead chirpsalot atota eamelink franckverrot shigosei coconnor Kruppe tsani ninegrid cobakobodob foret mangaba_1eitosa mirsal mortberg macron notdan stiell abh zerokarmaleft afleck Hardolaf ktosiek LeaChim mixi kqr obiwahn marienz bens jameseb)
18:00:10 --- names: list (sajith lusory identity Paks FliPPeh Baughn felixn nicoo barrucadu knyon tumdedum ernst SaBer pfoetchen qz mikkom SwashBuckla tomku ggreg comboy Jonno_FTW xaimus cryon Spark Bootvis noidi stbuehler danking Svedrin alang mornfall idoru onielfa zarul tgeeky mjrosenb RayNbow`TU joneshf mickk DreamLinuxer araujo mechairoi splintax damncabbage TDJACR drone| transfuturist ezrios ecr dino- yan_ zz_anildigital arrdem stew claudiyoh aprescott kaiza owlglass earldouglas)
18:00:10 --- names: list (rufs brisbin indiv0 stvc brackets mrkishi DigitalKiwi vladan mathu alloyed parallel21 happy0 JPuff kuyatzu kjnilsson Nshag chaoyi vmeson ikkebr bbloom periodic go|dfish subleq ens kmicu inr pieter_ horlicks_ Kobata fxr majoh osfameron jungnam hipsterslapfight rxc monochrom adrienneleigh catsup _d3f opqdonut squimmy Martty CindyLinz jennmoneydollars Soft Belgarion0 bryan11 Blkt MK_FG srcerer IanKelling adlan Tiktalik ienh meretrix Cale ValicekB Guest63619)
18:00:10 --- names: list (alexsdut1on ninedotnine LordDeath Dtgr yusukesuzuki rio Pad^ mgomezch jasu0 `bps ahihi _5kg levi yrashk tools Draconx mountaingoat zymurgy bd_ dmilith jlamothe hpc sokoll mavam jcurbo Someguy123 cdidd \q japesina- td123 hpd zling_ pp^ jchee augur u-ou kloplop321 krakrjak Eagle_Er1in cjenkin1 seagreen cyphase so ivan\ hegge simon Vq betawaffle lahwran FragByte shepheb kloeri Licenser saep jix jlewis_ M-ou-se dcoutts HugoDaniel sordina2 solarus aristid_ wto)
18:00:10 --- names: list (Profpatsch aji otterdam bjornars helgikrs1 fall_ hbar pranz ZsoL Fuuzetsu rtl gandr pii runde poucet Sagi carlasema Shogun aoh Khisanth bounb Wayneoween moop NinjaPenguin ClaudiusMaximus Rylee Harbinger agolsme_ blast_hardcheese Cronecker frontendloader g0dmoney- MitchW Guest8119 eyem sshine byorgey Imdsm^ ahf zz_LoRdToLsToI algoriddle himikov dh amontez tekacs j0ni pi8028 JPohlmann eagleflo dabradley Iceland_jack raek_ Eliel_ mayski isomorphismes mankyKitty)
18:00:10 --- names: list (phaazon nick1234abcd kirjs ekroon Taneb integral drdo julmac joe_k honza joachifm Tordek oldmanstanley nwf McManiaC redtricycle kaol xplat Fubar^ pcapriotti sellout XMunkki spacebug RevJohnnyHealey joeyh Cryovat davean1 anachron Erstarrung jlyndon jtobin dlundy b_jonas Lindrian mrowe_away Cheery EvanR tg rwbarton ibid mxf Gothmog_ stelleg R2ZER0 greymalkin finnrobi Nanar grantsmith evax BeLeKy dan64 _faern mendez peltchu Jello_Raptor Adios jackhill teeteewhy)
18:00:10 --- names: list (mr- Iloiny tridactyla xahry_ Dodek ft karls monsieurp Okasu radix pyrtsa cynick Ke peddie heikkih humppa thirsteh_ raid pnielsen_ fergusnoble Reiser koninkje_away ciaranm mnemon ion wchun gregburd mbrcknl wjt harski opto thomassgn Ezku adnap Gracenotes_ bwe jrp6 xrz srbaker saiam tobyp amiller qtplatypus keko_ qwandor|quassel etrepum bartavelle Jei mokus dagle bjobjo Adeon javawizard cross MiracleBlue dp_wiz nexion Xorlev zomg Liskni_si Chousuke Bane^ cursork)
18:00:10 --- names: list (Phlogistique __main__ Phillemann Zariel Tene ryanakca andreypopp mlen itsmonktastic joshc maurer mike2 chasecaleb dario rola lulf supki electrogeek kakos notori0us heaumer_ michaelpj kandinski Kinnison Na6hu7Ud_ gseitz mrd ClarusCogitatio_ hamarukusa haasn Nickeeh slasktask popx Drezil MasseR_ bitemyapp devn BeardedCoder JZTech101 Desoxy zeroskillor pingu mrshoe twopoint718 flori CosmicRay Nivim Paprikachu liszt DustyDingo jdiez nispaur Watcher7 s4msung)
18:00:10 --- names: list (rhodesd Twey zebr honkfestival frms edk kshannon helgar eL_Bart0- paz jj2baile_ mietek theDon luite mp asfp`` WarzoneCommand Polarina abc56889_ Ornedan taruti shlevy Boreeas effy peterhil misetes bsmt ipuustin savanni lpaste mimi_vx snowp_ heath aninhume1 eikonos Kazurik_ noddy statusfailed mcsmash uzo Axman6 wei2912 xpika DarkFox flebron zugz Nik05 felipe_ dogmaT pfn somenick- jlewis SHODAN hvr cmsd2 DasIch shapr burp mero Laney z0d Ulrar @ChanServ tomaw)
18:00:10 --- names: list (yano mak` Raynes iulian noctux lieven_ benmachine Kneiva thorstadt nik_89 CARAM_ mikeizbicki wjm carter gx^ sgronblo phaer osnr Cathy geekosaur elfangor metadave tromp__ hsc natte demolithion ehamberg yeshuah lyxia gdsx_ linduxed mikeplus64 aupo airloom tdammers Starfire lymmz aristid avdi billyiii jroesch_ cloudhead emmanueloga yumike posco kwmiebach_ thoughtpolice uncleBlazer GaveUp _1126 Preyer iteratee zph petantik jodaro_ milli herrwolfe45 fnordbert SLi)
18:00:10 --- names: list (Raynos thorkilnaur anders^^ zeiris KaneTW bra fyolnish coppro TakSuyu `0660 korpse_______ kragniz_ MMuse dlackty_ kmapped iron_houzi liyang indigo kosmikus PHO_ blenny katis ido Jaak lacrosse_ danneu marsbot ggherdov ab500-work Th0mas mitu sm pygospa cepheus mjo nikola clementd Spockz djapo termos callumacrae Derander feltnerm_ saurik zq [swift] koala_man Nimatek d3lxa rschulman jabbslad__ nifty lfp shennyg__ FireFly jnott sohum elgot teehemkay nsaje cstrahan)
18:00:10 --- names: list (puzza007 mno2 wizonesolutions caasih_ george2 werdna akahn raphie__ AlainODea blindscreen zpconn_________ acfoltzer mrb_bk Vbitz ocharles jmct jzelinskie Karethoth_ leifw superjudge_ PatrickRobotham vera SethTisue_______ jlouis ortmage steshaw nkpart myme skarn alphonse23_ dkua ircbrowse jmcc si14 cin Bigcheese cjwelborn agrif joshsz ajcoppa gereedy idnar charliekilo Walther Cr8 dyreshark fryguybob ivan` waynr d-q-d gargawel ziman qrada tomprince Tehnix ilmig)
18:00:10 --- names: list (helge_ jnoah vhz lpsmith ephess kongo2002 iross pure bergmark pharaun Saizan Hodapp bxc_ mike4 enk0 zenzike jrw empyreal machineslearn oconnore bstrie jayne spaceships bvad deni Freundlich tlevine numberten yrjolam brixen rieper klugez mami_ benbangert qr42 dustinswan Eridius jaspervdj OrangeDuck int-e mrmonday peder zso Rembane Athas unsymbol solirc fractalcat bernalex cwc liori KitD hmax dilinger_ rs0 jimki annulus xenocons froztbyte zalami Deewiant antoniy)
18:00:10 --- names: list (znutar adimit yam stevely sofancy terlar jonathanj tazjin srhb mononofu djahandarie oubiwann ByronJohnson Klumben sipa mandu Clint Hafydd b2coutts Maxdamantus alcabrera|afk earthy k00mi Pythonfant hongminhee aljosa l3kn seanparsons yac bgyss machrider lucca pikhq alinab gsilvis wjlroe andreasrx ij kittenso1p liuw vikraman spion sodaplayer GGMethos diginet NobbZ Transfusion n-dolio ChongLi sdx23 therealklanni companion_cube scopedTV_ davorak_ Yawgmoth fabjan_)
18:00:10 --- names: list (tomejaguar_away nesqi Arnar__ knyppeldynan cyrusdavid mgomes_ stepcut ParahSailin_ tsou AtnNn noplamodo farn banyan _jrp_ cjay ckw)
18:00:13 <dwcook_> OCaml's laziness, that is
18:00:20 <benmachine> dwcook_: I can't comment on "anyone ever" but I've basically not seen that
18:00:28 <dibblego> dwcook_: you cannot express monad with ocaml
18:00:31 <dwcook_> Yeah, I suppose that's what I was asking.
18:00:38 <benzrf> dibblego: whyn't
18:00:40 <benmachine> ocaml may not be a great example next to idris though, because ocaml has unrestricted side effects
18:00:50 <dibblego> benzrf: no type constructor polymorphism
18:00:55 <benmachine> unrestricted side effects and laziness really don't mix
18:01:05 <dibblego> benmachine: don't tell the scala people
18:01:10 <izaak> dibblego: sure you can't have typeclasses, but monads are used a fair bit in caml
18:01:10 <benmachine> dibblego: they use functors instead
18:01:16 <benmachine> dibblego: ocaml monads, I mean
18:01:30 <dibblego> izaak: yes you can have type-classes, yes you can use specific monads — you cannot exploit the practical benefits of monads
18:01:31 <izaak> dibblego: see the core library for many examples of this style using modules (option, list, async, etc.,)
18:01:41 <dibblego> izaak: please show me sequence
18:02:16 <benmachine> dibblego: sure, it's called "all"
18:02:18 <izaak> dibblego: do you mean :: Monad m => [m a] -> m [a]? I can write it in ocaml, gimme a sec
18:02:26 <izaak> (using first class modules)
18:02:36 <dibblego> ok never mind, I understand on that point
18:03:52 <izaak> dibblego: while it is possible to do it using first class modules (which is a bit mad) the usual approach is to have a Monad functor which given an implementation of return and bind will produce the usual monad functions (e.g., sequence)
18:04:03 <dibblego> right
18:04:06 <benmachine> https://ocaml.janestreet.com/ocaml-core/111.21.00/doc/core_kernel/#Monad ← izaak's functor is Monad.Make
18:04:26 <dibblego> then, back to the question — why don't we see guard?
18:04:27 <izaak> sorry for the confusing use of functor! (blame the sml people)
18:06:07 <benmachine> dibblego: I can't offhand think of a good reason why not guard
18:06:23 <OscarZ> there are a lot of programmers who are used to imperative programming and are hearing from all directions to learn FP, promote immutability etc.. maybe aim that site and the tutorials to provide these people some elegant solutions to problems they are having in daily work
18:06:42 <companion_cube> apparently HKT are hard to do in OCaml because of type aliases
18:06:44 <benmachine> I guess it's partially just that functors are capable in this regard but basically more awkward than type classes, so the amount of benefit associated with any given abstraction needs to be higher
18:06:47 <dibblego> OscarZ: http://github.com/nicta/course
18:07:11 <dibblego> nicta/course is a result of constant revision after much failure trying to teach FP to existing industry programmers
18:07:22 <dibblego> there is a method to teaching it though, which is not documented
18:07:29 <simcity2000> OscarZ: right
18:09:44 <benzrf> dibblego: and what is this method
18:09:54 <dibblego> benzrf: well that's a long story that is not documented
18:10:07 <benzrf> also, this is fp, not oop
18:10:15 <benzrf> shouldnt it be a function for teaching it
18:10:24 <mwhit> *rimshot*
18:10:29 <dibblego> No, you must do different things per individual
18:10:52 <dibblego> how you respond to individual concerns changes things a lot
18:11:16 <dibblego> nicta/course is closing in on this with simply being code, and lots of people do it independently, but there is unnecessary struggle
18:12:12 <rasfar> dibblego: i'm surprised there's no module on lens in that course?
18:12:14 <jtcwang> with haskell heap profiling, what does the * represent when looking at the constrcutor charts (along with other constructors such as [] and Word8)
18:12:19 <dibblego> rasfar: that's next :)
18:12:34 <dibblego> rasfar: I was just discussing it with edwardk_ a couple of days ago
18:12:36 <nick_named> Are arguments in where clauses calculated if they aren't needed, such as when the guard that needs them isn't reached?
18:13:02 <Cale> nick_named: nope!
18:13:13 <nick_named> Cale: Thanks, thats what I thought, just needed to make sure.
18:13:18 <rasfar> ah. but it will be introduced earlier on in the course presumably? seeing as it's rigorously founded, yet maybe one of the most familiar techniques (not that i've used it yet....)
18:13:41 <dibblego> rasfar: that too, is a challenge in teaching — I regularly skip parts in response to concerns when person-person
18:13:52 <Cale> nick_named: At some level, things are only computed if they get pattern matched on somewhere.
18:14:06 <dibblego> the goal is to invest as minimal effort as possible, while obtaining maximum gain of insights into new concepts
18:14:25 <dibblego> achieving this goal is not a formula that can be written down to apply to all people
18:14:31 <rasfar> ah, into /new/ concepts
18:14:48 <dibblego> someone started a #nicta-course channel for people doing it on their own
18:17:47 <benzrf> whats nicta/course
18:18:22 <dibblego> http://github.com/nicta/course
18:20:19 <rasfar> jtcwang: i gues you mean with -hy?
18:21:10 <rasfar> i can't find a document either (although https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects can be helpful)
18:21:19 <jtcwang> rasfar, yes
18:21:42 <rasfar> is it a kind? some heap object, the type of which can't be reported for some reason, but is at least known to be kind *? that's my best guess
18:21:59 <jtcwang> that makes sense
18:22:00 <rasfar> or just that -hy deliberately abbreviates things so you can focus more
18:22:20 <rasfar> just a guess...
18:22:42 <jtcwang> guess it's stack overflow time
18:23:39 <rasfar> you see other weird stuff like ->>> * (is that short for * -> * -> * -> *?) -- would be great to have a single page which defined anything you'd ever be likely to see in a heap profile (although the above link comes close)
18:24:59 <jtcwang> rasfar, nope, just *
18:26:31 <rasfar> according to the GHC Users Guide, "For closures which have function type or unknown/polymorphic type, the string will represent an approximation to the actual type."
18:26:37 <rasfar> (for -hy profiling)
18:31:12 <ij> Is [] monad nondeterministic?
18:32:05 <hpc> it's deterministic
18:32:17 <hpc> but can be used to /represent/ a non-deterministic operation
18:32:31 <hpc> (where the representation is "here's a list of everything it could be")
18:32:53 <systemfault> If a monad is an applicative and is a functor, is the reverse true?
18:32:58 <benzrf> systemfault: no
18:33:21 <benzrf> there are functors that are not appls and appls that are not monads
18:33:25 <ij> hpc, that makes very little sense to me
18:33:38 <systemfault> benzrf: Any example of something in the standard lib or anywhere else that is a functor but not a monad?
18:33:46 <dibblego> Const
18:33:51 <dibblego> ZipList
18:33:54 <benzrf> systemfault: reactive banana
18:34:00 <benzrf> Event t is a functor but not appl or monad
18:34:08 <hpc> ij: so, pretend you want to represent some operation that is non-deterministically valued as 3, 4, or 5
18:34:09 <benzrf> and Behavior is a functor an and appl
18:34:17 <hpc> ij: but drats, you want to use it in a pure context
18:34:18 <benzrf> but i do not think that it is a monad
18:34:27 <hpc> ij: the list representation would be just [3,4,5]
18:34:31 <benzrf> no wait i think it could be
18:34:34 <systemfault> benzrf, dibblego: Awesome, I’ll look at those examples
18:34:36 <benzrf> but itd be impractical
18:34:45 <t4nk320> @pl \x acc -> f x : acc
18:34:45 <lambdabot> (:) . f
18:34:55 <ij> hpc, Oh, I see.
18:34:58 <ij> Thanks!
18:35:30 <hpc> the Monad instance (also Functor and Applicative) tell you how to conveniently operate on a list of numbers in a way that you can squint and imagine it being just one of those numbers
18:35:34 <hpc> (but who cares which)
18:37:36 <benzrf> hmm
18:37:51 <mwhit> > filterM (const [True,False]) [1,2,3]
18:37:53 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
18:38:14 <benzrf> @src filterM
18:38:15 <lambdabot> Source not found. stty: unknown mode: doofus
18:38:18 <benzrf> bwah
18:38:21 <mwhit> so there, elements are filtered by *choosing* arbitrarily from the list [True, False].
18:38:26 <mwhit> for each elemetn
18:38:32 <benzrf> :t filterM
18:38:33 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
18:38:39 <benzrf> hm
18:38:41 <mwhit> the result is the results for *all* possible combinatinons of true, false
18:39:19 <benzrf> > filterM (\n | n == 0 -> Nothing | n < 5 -> Just False | otherwise -> Just True) [0..10]
18:39:20 <lambdabot>  <hint>:1:13: parse error on input ‘|’
18:39:23 <benzrf> u wot
18:39:39 <benzrf> > let f n | n == 0 -> Nothing | n < 5 -> Just False | otherwise -> Just True in filterM f [0..10]
18:39:41 <lambdabot>  <hint>:1:18: parse error on input ‘->’
18:39:52 * hackagebot Allure 0.4.14 - Near-future roguelike game in early development  http://hackage.haskell.org/package/Allure-0.4.14 (MikolajKonarski)
18:39:52 <mwhit> can you put guards on a single line like that?
18:39:53 <benzrf> > let f n | n == 0 = Nothing | n < 5 = Just False | otherwise = Just True in filterM f [0..10]
18:39:55 <lambdabot>  Nothing
18:39:57 <benzrf> there
18:39:58 <mwhit> oh
18:40:00 <mwhit> guess you can
18:40:00 <benzrf> oic
18:40:10 <dolio> Yes. It's unambiguous.
18:40:28 <dolio> Well, probably not completely.
18:41:16 <dolio> But situations where it is ambiguous can be resolved.
18:42:04 <benzrf> > sequence (map (const [True, False])) [1, 2, 3]
18:42:05 <lambdabot>  Couldn't match expected type ‘[[t0] -> a]’
18:42:05 <lambdabot>              with actual type ‘[a0] -> [[GHC.Types.Bool]]’
18:42:12 <benzrf> > sequence (map (const [True, False]) [1, 2, 3])
18:42:13 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
18:43:15 <rasfar> > mapM (const [True, False]) [1, 2, 3]
18:43:17 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
18:43:24 <benzrf> i think we could have an applicative comp syntax where draw-from doesnt bind in subsequent draw-froms
18:43:53 <dolio> Someone was working on that.
18:44:24 <dolio> I think the idea was to change desugaring to automatically make that happen.
18:44:37 <benzrf> mhm
18:44:49 <dolio> Instead of having a new syntax.
18:44:49 <carter> yeah
18:44:53 <carter> i think simon marlow is working on that
18:45:05 <carter> 'cause he's the one who has "customers" for haxl
18:45:16 <carter> and applicative do would be easier to train folks in
18:46:16 <dolio> The only issue with changing the desugaring is that it won't tell you if you accidentally write something monadic.
18:46:29 <carter> i think that could be a wall
18:46:33 <carter> dolio: ooo
18:46:33 <dolio> Unless there is no Monad instance.
18:46:42 <carter> newtype the applicative instances?
18:47:01 <carter> huh
18:47:02 <dolio> I guess that would be one reason for WrappedMonad to not have a Monad instance. :)
18:47:23 <dolio> Of course we should just get rid of that entirely now.
18:47:24 <carter> or was he doing to add an "ADo" notation
18:47:32 <carter> 'cause honestly that'd be easy to add too
18:47:38 <dolio> I don't know.
18:47:46 <carter> well, it'd be easy to add that
18:47:54 <dolio> People get uptight about stealing syntax.
18:47:56 <carter> comparatively
18:47:58 <carter> well
18:48:32 <carter> ok, fine, {-#  OnlyApplicativeDo  functionName #-}
18:48:33 <carter> :)
18:48:34 <carter> DONE
18:48:50 <carter> or something
18:48:51 <dolio> {-# APPLICATIVE #-} do ...
18:48:54 <dolio> Great.
18:49:08 <carter> huh
18:49:10 <carter> that would work
18:49:12 <carter> fugly
18:49:15 <carter> but would work
18:50:10 <carter> while we're talkiing about crazy things: what would it take to get slightly evil but awesome Maybe / Either instances Storable / Unboxed
18:50:22 <carter> 'cause at least in vector, theres uninitialized values woes anyways
18:50:37 <carter> *instances for Storable / Unboxed
18:51:00 <dolio> Storable doesn't have those?
18:51:05 <dolio> Oh, they're not fixed size, right?
18:51:12 <carter> no, they can be
18:51:17 <carter> Storable a => Maybe a
18:51:24 <carter> pay a 2x
18:51:24 <carter> or something
18:51:29 <carter> or a +1 word
18:51:30 <dolio> And you just waste space on the null?
18:51:34 <carter> sure
18:51:36 <dolio> Okay.
18:51:42 <dolio> And Either is the lub.
18:51:48 <carter> lub?
18:51:52 <carter> (Bool,A,B)
18:51:53 <dolio> max
18:51:54 <carter> encoding
18:52:03 <dolio> Max size of the parameters.
18:52:04 <carter> max == that triple?
18:52:08 <carter> ohh
18:52:13 <dolio> Like a union.
18:52:14 <carter> yeah that  would work too
18:52:22 <carter> oh, for Storable
18:52:23 <carter> yeah
18:52:25 <carter> something like that
18:52:43 <dolio> Yeah. For unboxed it's trickier.
18:52:49 <carter> is it?
18:52:56 <dolio> Well, more wasteful.
18:52:58 <carter> yeah
18:53:09 <dolio> Immutable you can not waste space.
18:53:11 <dolio> But mutable you have to.
18:53:20 <carter> eh?
18:53:43 <carter> i'm being slow (long day)
18:53:45 <dolio> For an immutable vector,  you can have an array of booleans, and then an array of just enough to hold all your elements of each type.
18:53:45 <carter> could you explain
18:53:50 <solidus-river> i think maybe i have a case that fits a comonad!
18:53:55 <carter> yeah
18:53:58 <carter> oh
18:54:04 <dolio> Then you do rank to find the index in the other arrays.
18:54:05 <carter> you mean for storable or unboxeD?
18:54:07 <carter> ahhh
18:54:09 <dolio> Unboxed.
18:54:30 <carter> dolio: that rep is hosed for unsafe freeze / thaw's currently semantics in eg Vector though
18:54:37 <carter> right?
18:54:43 <carter> it becomes unthawable
18:54:43 <dolio> Right.
18:55:03 <carter> which breaks all of Vector's invariants!
18:55:05 <carter> :)
18:55:12 <carter> BUT, i can actually support that in my Array lib
18:55:21 <carter> because I don't assume every pure array format has a mutable analogue
18:55:27 <carter> Vector does make that assumption though
18:55:34 <dolio> Maybe is even easier, because () arrays are trivial. :)
18:55:49 <dolio> You only store the justs and an array of which elements are just.
18:55:57 <carter> yeah
18:55:58 <joelteon> Hi, does anyone know of a filepath globbing library that supports escaping special characters?
18:56:16 <carter> dolio: ok, so theres two reps: unthawable and thawable
18:56:24 <dolio> Yeah.
18:56:52 <carter> and i guess you can't the unthawable one in vector
18:56:55 <dolio> I guess the one is slightly tricky, because you need a rank structure.
18:57:27 <carter> now theres another wee problem: current vector fusion design depends in an essential way on thawability and freezability rihgt?
18:57:28 <dolio> No, I don't think you can in vector. Unless there's something I don't know about in there.
18:57:47 <carter> ok, so you'd only be able to do the "dumb" styles in vector
18:57:51 <metaqix> silly question: how would I join a list with a newline character separator?
18:57:53 <carter> (which i think is fine)
18:58:02 <carter> :t intercalate
18:58:02 <lambdabot> [a] -> [[a]] -> [a]
18:58:08 <carter> erm...  nvm
18:58:20 <bob____> :t unwords
18:58:20 <lambdabot> [String] -> String
18:58:34 <carter> :t unlines
18:58:34 <lambdabot> [String] -> String
18:58:48 <carter> words uses \ , lines is \n
18:59:00 <metaqix> thanks much!
18:59:05 <joelteon> ok so with glob I have to use [*] instead of \*
18:59:08 <joelteon> makes sense I guess
18:59:27 <carter> dolio: now the thign i've been struggling with is "how does one implement fusion on arrays that don't have a mutable version"
18:59:31 <dolio> carter: Actually, maybe you could.
18:59:33 <carter> hrm
18:59:38 <carter> oh?
18:59:44 <dolio> You could just make unsafeFreeze not realy be unsafe.
18:59:48 <carter> yeah
18:59:52 <carter> true
19:00:03 <dolio> But that violates the specification, because it's not O(1).
19:00:07 <carter> yeah
19:00:11 <dolio> "Assumed complexity"
19:00:20 <carter> otoh, who said it has to be in vector proper to start with? :)
19:01:01 <carter> maybe at hac_bos I can pick your brain for some fo these things
19:01:09 <dolio> Okay.
19:01:50 <carter> hrmm
19:01:54 <dolio> Ed's probably good to talk to, as well. I think he reminded me about that Either vector representation more recently.
19:02:02 <carter> yeah, he know that better
19:02:04 <dolio> Although I think I originally saw it in the DPH stuff.
19:02:10 <carter> but you've got vector loaded in the brain more now :)
19:02:21 * carter thanks for making vector head -wall happy
19:02:26 <carter> :)
19:02:32 <ReinH> yay hac bos
19:02:34 <carter> that must have taken an afternoon or so
19:02:36 <carter> ReinH: you're there right?
19:02:42 <ReinH> I will be
19:02:43 <dolio> It took a while.
19:02:52 <dolio> But, mostly tedium.
19:02:55 <carter> yeah
19:03:00 <carter> but thats the hard part!
19:03:00 <carter> :)
19:04:28 <dolio> Also, luckily it looked worse than it was, becuase there were lots of warnings that were generated in multiple places via #include.
19:04:37 <carter> AH
19:04:42 <dolio> So, you fix the #included file, and the warnings go away in multiple places.
19:05:38 <carter> ahh
19:06:12 <carter> yeah, ed was kinda meh / against adding maybe / either support, on the grounds of uniitialized values, but vector has unitialized values anyways as is
19:16:46 <ruuns> hi :]
19:17:38 <dolio> Well, that's going to get fixed, I think.
19:17:56 <carter> oh?
19:18:14 <dolio> Someone filed a bug that you can see uninitialized memory with new.
19:18:28 <dolio> So, we should initialize it to something.
19:18:43 <dolio> Which you can do per-Unbox, so I don't think it's a problem.
19:18:59 <carter> dolio: can you really?
19:19:09 <dolio> Yeah, why not?
19:19:34 <carter> brb phone, but good question
19:21:29 <carter> hrmm
19:21:52 <carter> oh, you mean specifically with unbxoed?
19:21:57 <bms1> Is this vector discussion? I've been struggling with vector performance lately... Does this code look reasonable?
19:22:02 <bms1> http://lpaste.net/3335960274862604288
19:22:18 <carter> bms1: so mutable vectors don't get fusion
19:22:27 <carter> (at least in vector)
19:22:31 <dolio> I think it's Unboxed specific.
19:22:50 <dolio> Can you see raw memory from others? Maybe Storable.
19:22:51 <bms1> I had a bunch of immutable code that did a lot of allocation and garbage collection , and so I decided to just use mutable buffers and just fill the same ones over and over
19:23:01 <bms1> And that made performance much worse!
19:23:10 <carter> bms1: whats the problem you wanna solve
19:23:42 <bms1> I'm doing visualization stuff, and I essentially have a lot of spectrograms that need to update whenever the mouse moves
19:24:10 <glguy> alloca $ \p -> peek (p :: Ptr Int)
19:24:10 <carter> why when the mouse moves?
19:24:21 <bms1> I have to take the spectrograms, scale and delay them, and then add them - very simple, but potentially a lot of allocation, and so I think I was getting hiccups from garbage collection
19:24:40 <carter> bms1: did you try tuning RTS stuff?
19:24:51 <carter> or forcing gcs when you're not doing work?
19:25:00 <bms1> carter: The mouse's position determines the delays and the scaling factors. It's sonar beamforming
19:25:01 <carter> RTS tuning can make a HUGE difference
19:25:06 <glguy> dolio: The issue is that it returns different valued vectors purely?
19:25:17 <carter> @google sonar beam forming
19:25:18 <lambdabot> http://en.wikipedia.org/wiki/Beamforming
19:25:18 <lambdabot> Title: Beamforming - Wikipedia, the free encyclopedia
19:25:18 <bms1> carter: I have -A30M and -H30G, but I haven't played with the GC timing parameters
19:25:20 <carter> :t new
19:25:21 <lambdabot> Not in scope: ‘new’
19:25:27 <carter> glguy: i htink new is mutable
19:25:47 <bms1> Nor have I tried forcing garbage collection! Sounds like a good idea
19:25:50 <carter> http://hackage.haskell.org/package/vector-0.10.11.0/docs/Data-Vector-Generic-Mutable.html
19:26:12 <carter> glguy: dolio  per se, mutable memory is a thing
19:26:20 <dolio> glguy: Yeah. You can get different vectors from something like (runST (new n >>= freeze)).
19:26:50 <dolio> Because your vector will just have whatever was in memory.
19:26:50 <carter> dolio: but are they allways valid values?
19:27:55 <dolio> Probably not, for some types. But that doesn't really matter. The above means that you can get different results depending on whether you inline and such.
19:28:16 <dolio> let v = runST (new n >>= freeze) in v == v
19:28:19 <carter> dolio: maybe new should take a value
19:28:37 <glguy> You can get uninitialized arrays from array's "newArray_" by design, too
19:28:38 <carter> and the unsafeNew is on your head?
19:28:43 <glguy> but I don't think there is a pure way to freeze them
19:29:03 <glguy> actually, I hsould be able to do the same with STUArrays
19:29:09 <dolio> glguy: That's still bad. You can just read the array.
19:29:19 <bms1> carter: Let's say I'm making unboxed vectors which are roughly 8 MB in size, and allocating them at a rate of perhaps up to 20*20 = 400 vectors per second. Should that be roughly manageable? (The machine I'm doing this on has 64 GB of ram...)
19:29:21 <dolio> But newArray_ is the 'unsafe' call, as I understand it.
19:29:24 <dolio> So it's on you.
19:29:42 <rwbarton> newArray_ in ST will zero the array
19:29:58 <bms1> By switching to immutable vectors, I can do no allocation and keep it to using only around 20 vectors of 8 MB in size
19:29:58 <carter> is 0 always a legal value for every unboxed format?
19:30:38 <carter> i'd be down with zeroing subject to the invariant that 0 is always legal
19:30:50 <dolio> I think it is.
19:31:34 <carter> http://hackage.haskell.org/package/vector-0.10.11.0/docs/Data-Vector-Primitive.html
19:31:41 <carter> erp
19:31:42 <carter> not Addr
19:31:44 <carter> wat
19:31:48 <carter> we have Prim Addr?
19:31:59 <carter> hah
19:32:02 <dolio> 0 isn't a valid address?
19:32:06 <carter> well
19:32:06 <carter> idk
19:32:13 <carter> i guess thats as good a defualt as any :)
19:32:22 <carter> still on your head if you read from it
19:32:30 <carter> but that at least gives a consistent semantics
19:32:50 <carter> for that otherwise bad st examples
19:33:09 <carter> bms1: soo, is it single threaded
19:33:11 <carter> or many threaded?
19:33:26 <carter> bms1: one thing that made a huge for some haskell code 've got
19:33:28 <rwbarton> bms1: do you mean "by switching to mutable vectors"?
19:33:31 <carter> was the rts option -qa
19:33:44 <carter> (which means on a many core box having the working thread not hop cores)
19:34:07 <bms1> Ooph.. I think I've been running it multi-threaded, but I got rid of all the parallelism haha
19:34:22 <carter> bms1: sooo one HUGE issue on mega core boxes
19:34:33 <carter> is independent threads triggering GCs
19:34:40 <carter> and then everyon is forced to pause
19:35:03 <carter> bms1: also for sequential codes, the not threaded RTS WILL be faster
19:35:06 <bms1> carter: Yes! I originally had Vectors of vectors, and it was spending like 90% of time garbage collecting!
19:35:19 <carter> bms1: such lack of data locality
19:35:20 <carter> so wow
19:35:22 <carter> :)
19:35:24 <dolio> Anyhow, zeroing is better even if 0 isn't a valid Addr.
19:35:38 <carter> i'm down with new zeroing
19:35:47 <carter> still on your head if you read it
19:35:57 <carter> but solves the inconsistency issue consistently
19:36:02 <dolio> Yeah.
19:36:21 <carter> and doesn't touch anyone writing userland instances
19:36:56 <bms1> rwbarton: I am doing what amounts to the same operation many times per second for doing visualization stuff. I originally was using immutable code which implicitly does a lot of allocation. I switched to starting out by allocating a bunch of mutable buffers, and repeatedly using those instead
19:37:37 <carter> bms1: are you building wiht O1 or O2?
19:37:41 <bms1> rwbarton: I replaced some of my code with some of these possibly suspect operations: http://lpaste.net/3335960274862604288
19:37:43 <carter>  and with or without -fllvm
19:37:56 <rwbarton> if you are copying 8 MB * 400 = 3.2 GB worth of vectors per second, I imagine that doesn't leave time to do much else...
19:37:56 <carter> for array heavy codes O2 + -fllvm can be a big win
19:38:03 <bms1> carter: with -O2, some of my code is llvm but some isn't!
19:38:17 <carter> huh, 3.3gbs would saturate ram
19:38:38 <carter> bms1: how big are your boxes l1 l2 l3 caches
19:38:41 <bms1> rwbarton: Thanks! I was worried about that. The funny thing I'm having is that the mutable code, with way less memory usage, is much slower
19:38:59 <bms1> carter: I actually have no idea about the caches
19:39:51 <carter> bms1: so whenever you use mutable vectors, you have to do fusion yourself by hand
19:40:30 <carter> bms1: have you used any profiling / benchmarking / tools?
19:40:45 <carter> @hackage criterion is powerful stuff
19:40:45 <lambdabot> http://hackage.haskell.org/package/criterion is powerful stuff
19:40:47 <bms1> carter: Yeah, I realized that. Though I had to do it myself in the immutable version in some places too!
19:41:24 <carter> bms1: phase 0 ; write some benchmarks using criterion
19:41:26 <carter> to isolate whats slow
19:41:28 <bms1> carter: Not as much as I should! I should probably do that. I used criterion for some small pieces, but not for testing my new stuff
19:41:39 <carter> isolate WHATs slow
19:41:44 <carter> then we can help you destroy the slows
19:42:24 <bms1> carter: Thanks for all these really useful suggestions!
19:42:43 <carter> :)
19:42:49 <carter> i'm not really doin gmuch
19:42:53 <carter> you'll be doing the hard part
19:44:10 <ddrake> I'm working through the upenn cis 194, stuck on hw 5 exercise 4.  Can anyone help?
19:44:21 <carter> what question is that
19:44:30 <carter> ddrake: i think bitemyapp  knows by heart by now
19:45:03 <ddrake> http://www.seas.upenn.edu/~cis194/hw/05-type-classes.pdf
19:45:35 <ddrake> basically i'm not sure if I need a multi-parameter type class...
19:46:44 <Cale> ddrake: It looks like they're only asking for a one-parameter type class
19:47:22 <ddrake> ok, so the parameter would be the result type, then -- right?
19:47:47 <ddrake> not the expression?
19:49:41 <GeraldCode> Haskell is taught at 100 level these days?
19:49:43 <GeraldCode> cool
19:50:10 <GeraldCode> I keep forgetting Upenn is ivy league
19:51:32 <ddrake> I believe Haskell Curry was a prof there...
19:52:04 <GeraldCode> oh thats pretty cool..so there is probably a lineage there too..you might have some serious masters there
19:52:28 <ddrake> Cale: thanks!
19:53:50 <carter> but not for that reason
19:53:57 <carter> theres a whole PL research group at upen
19:54:02 <GeraldCode> oh
19:54:03 <carter> @google upenn plclub
19:54:03 <lambdabot> http://www.cis.upenn.edu/~plclub/
19:54:04 <lambdabot> Title: Programming Languages @ Penn
19:54:09 <carter> awesome folks
19:54:21 <benzrf> man i dont know which uni to go for now
19:54:38 <GeraldCode> benzrf, look Ill put it like this
19:54:49 <GeraldCode> unless you got a full scholarship,. just go to community college for the first 2 years
19:54:52 <GeraldCode> get straight As
19:54:55 <GeraldCode> then get a scholarship
19:55:01 <GeraldCode> save yourself a lot of heartache later
19:55:10 <benzrf> b-but my resume
19:55:14 <benzrf> and what about actual learning
19:55:21 <bms1> I disagree with GeraldCode
19:55:26 <GeraldCode> You wont learn anything much if it isnt MIT etc
19:55:30 <GeraldCode> you can learn more on your own
19:55:40 <simcity2000> you won't learn much even if it is MIT
19:55:47 <GeraldCode> im just speaking from my own experience I wish I had done what I said
19:55:55 <GeraldCode> but if other peopel's milage varies, that's fine
19:55:56 <bms1> You want to go to a school where other people are as interested in learning as you are!
19:55:56 <simcity2000> the first two years of undergrad is pretty much a money pit
19:56:05 <simcity2000> are pretty much*
19:57:02 <GeraldCode> simcity, I agree
19:57:18 <GeraldCode> there is no way you will become smarter in those first two years than you can on your own
19:57:22 <benzrf> ive been thinking maybe i should go for a math major since i have more preexisting CS knowledge than math knowledge
19:57:25 <benzrf> ^probably hubris
19:57:26 <GeraldCode> there are other beneefits to colllege though..mostly social
19:57:46 <nick_named> Does anyone know how the solution to Project Euler problem 27 on the haskell website works? (http://www.haskell.org/haskellwiki/Euler_problems/21_to_30)
19:57:48 <simcity2000> benzrf: do CS and crush everyone else
19:57:51 <rasfar> if you allow yourself to get really into it, those elective courses will give you experiences to remember for life; not only the social, but the subjects themselves...
19:57:55 <benzrf> simcity2000: that was my other thought
19:57:56 <benzrf> ( ͡° ͜ʖ ͡°)
19:58:25 <simcity2000> GeraldCode: that's true, but you can make friends without paying an average American family's salary to do it
19:58:26 <bms1> benzrf: I was a math major. I loved it, but now that I'm a year out of college, I'm realizing that the jobs are in CS, not math
19:58:27 * benzrf is pulled between the twin forces of laziness and wanting to learn stuff
19:58:45 <benzrf> bms1: well, i'd definitely go for a programming job over a math one
19:58:45 <simcity2000> as a side note, I finally found a use case for the Reader monad in my code
19:58:48 <simcity2000> that was nice
19:58:51 <simcity2000> benzrf: do CS then
19:58:51 <GeraldCode> simcity2000 yeah thats true too
19:59:01 <simcity2000> if you want a CS job, get a CS degree
19:59:06 <bms1> benzrf: Not that that at all means you shouldn't major in math! Just know you'll be doing programming, or CS, after :)
19:59:44 <GeraldCode> you might still pull a good programming job from a math degree
19:59:48 <simcity2000> benzrf: to be honest if you already have pre-existing knowledge of CS then you'd be just fine going to a cheap school and transferring up later
19:59:53 <GeraldCode> entry level positions dont really need a cs degree
20:00:00 <GeraldCode> Ive worked at places where people had NO degree at all
20:00:07 <simcity2000> benzrf: GeraldCode just made my other point
20:00:10 <bms1> benzrf: In constrast to simcity2000 and GeraldCode, I found undergrad very helpful. I'll agree that I didn't learn much useful in classes. But the culture made me the person interested in learning stuff that I am today
20:00:31 <simcity2000> bms1: it can be very helpful for some people
20:00:55 <simcity2000> but it's really, really expensive. that's all.
20:00:57 <GeraldCode> I am still paying off student debt is my whole point though :)
20:01:02 <GeraldCode> many years later
20:01:08 <GeraldCode> and I feel like it was a waste
20:01:21 <GeraldCode> I deferred my debt though
20:01:23 <GeraldCode> really bad idea
20:01:28 <simcity2000> bms1: I thought undergrad was great for me too, but I don't think it is for everyone
20:01:39 <bms1> And I will echo what simcity2000 and GeraldCode say: If you're on #haskell, you're probably already a self-starter, which is the most important thing. There are so many great learning resouces in the internet!
20:01:42 <simcity2000> I know far, far more people who scraped by or failed out
20:02:01 <benzrf> <3 head starts
20:02:03 <simcity2000> benzrf: if you're feeling lazy do community college and see how it works for you
20:02:12 <benzrf> im never not feeling lazy
20:02:16 <benzrf> why do you think i use haskell
20:02:17 <benzrf> *rimshot*
20:02:23 <simcity2000> you do not want to plunk down $20k or $40k and find out that school is not for you
20:02:31 <simcity2000> har har :P
20:02:52 <GeraldCode> benzrf, you should do what you want..but I feel really strong about this
20:02:57 <GeraldCode> :)
20:02:58 <nick_named> Does anyone know how the solution to Project Euler problem 27 on the haskell website works? (http://www.haskell.org/haskellwiki/Euler_problems/21_to_30)
20:03:07 <GeraldCode> college won't make you smarter..not undergrad anyway
20:03:24 <bms1> I don't think at all that community college is a good idea. That's generally not a good culture (at least the community colleges I know)
20:03:25 <nick_named> GeraldCode: I think it does
20:03:39 <GeraldCode> nick_named, college helped me become more social..and more adult
20:03:48 <GeraldCode> but with the internet..im not sure why I need college?
20:03:55 <GeraldCode> I mean not for undergrad anyway
20:03:59 <nick_named> I guess it depends on what classes you take.
20:04:08 <simcity2000> bms1: that all depends. I've seen CCs that basically teach you how to be an HVAC technician and others that teach sophomore-level thermodynamics.
20:04:29 <nick_named> And the CS program at that particular college
20:04:36 <GeraldCode> bmsl, my idea was that you go to community college and get straigfht As
20:04:41 <simcity2000> nick_named: doesn't necessarily have to be CS
20:04:46 <GeraldCode> and build up people who will give references
20:04:56 <GeraldCode> then you get a scholarship to a better institution
20:04:57 <simcity2000> you can bang out all the gen eds so you can focus more heavily on what you really want to do
20:05:08 <nick_named> simcity2000: I agree, but it still depends on what classes you take, if you don't take interesting/challenging classes you won't learn much
20:05:13 <simcity2000> nick_named: def
20:05:18 <carter> i think there point is theres many ways to do school
20:05:26 <simcity2000> I suppose it's all moot, since the young person isn't here at the moment...
20:05:27 <bms1> GeraldCode: What's the point? As you mention, you may as well learning independently and not bother at all
20:05:29 <carter> figure out what will leave you happy DURING school, and after
20:05:35 <carter> i was Misserable at uni
20:05:37 <GeraldCode> bmsl, I think college IS useful
20:05:42 <GeraldCode> but I dont think its worth the money
20:05:46 <GeraldCode> I guess that is my main point
20:05:49 <carter> its important to be in an environment that helps you be happy
20:05:55 <simcity2000> GeraldCode: the upper levels probably are worth money
20:06:13 <GeraldCode> simcity, yeah maybe
20:06:16 <GeraldCode> I dont have a graduate degree
20:06:22 <GeraldCode> my experience trumps a masters
20:06:29 <GeraldCode> I sound like a tool
20:06:30 <GeraldCode> sorry
20:06:34 <GeraldCode> but yeah I hear you
20:06:36 <simcity2000> nah, that's a valid point
20:06:44 <simcity2000> at my school we had professors of practice
20:06:56 <simcity2000> people who didn't have a fancy PhD, but did have 20 years experience as the heads of some pretty nuts projects
20:07:04 <simcity2000> or 30, or more
20:07:19 <GeraldCode> yeah, I have worked with some masters and a few phds
20:07:25 <GeraldCode> they often dont really "get it"
20:07:28 <simcity2000> right
20:07:52 <carter> but the key point is getting it is perpendicular to your degree
20:07:55 <simcity2000> it's a different kind of training, and it's exactly why I didn't bother with grad school
20:08:05 <carter> there ARE  really cool jobs where its tricky to get the slot sans phd
20:08:12 <simcity2000> carter: yes
20:08:31 <GeraldCode> yeah thats true carter
20:08:35 <simcity2000> I think that's less true in CS than in other fields though
20:08:38 <carter> ehhh
20:08:39 <carter> depends
20:08:44 <carter> certain really cool jobs in government
20:08:50 <simcity2000> well, think psych or bio
20:08:53 <Cale> I kind of feel like if the only reason you're getting a Ph.D. is because of jobs, probably you shouldn't be.
20:08:58 <carter> that too
20:09:01 <carter> :)
20:09:05 <nick_named> Cale: Agreed
20:09:17 <simcity2000> Cale: the salary compounding effect means you don't earn any more anyway
20:09:32 <simcity2000> but if "job" is a proxy for "really cool stuff 5+ days a week" it's a little different
20:09:33 <GeraldCode> cale, yeah I agree
20:09:46 <simcity2000> so basically I agree with an asterisk
20:10:27 <simcity2000> carter: I've definitely been shut out of some work for only having a bachelor's, but I never hear the horror stories I hear from a lowly psych bach
20:10:31 <zq> how do you set ImpredicativeTypes in lambdabot?
20:10:31 <GeraldCode> maybe if you go to China or India
20:10:37 <GeraldCode> your undergrad degree in CS will mean more
20:10:43 <GeraldCode> they have intensive programs I am told
20:10:43 <shachaf> zq: You don't.
20:10:53 <rwbarton> zq, ... unless you mean a lambdabot instance you are running
20:10:58 <simcity2000> GeraldCode: really now
20:11:00 <shachaf> And most of the time you shouldn't be setting it in anything.
20:11:08 <GeraldCode> thats what I am told..dont know if it is true
20:11:12 <shachaf> Oh, well, yes, there's that. You can put it in L.hs or Pristine.hs or something.
20:11:20 <nick_named> Is anyone good with primes? / has any idea what the haskell.org solution to project euler problem 27 does.
20:11:31 <simcity2000> nick_named: no and definitely no, sorry
20:11:32 <zq> i really want to play with impredicative instantiation here
20:11:48 <zq> :t repeat id :: [forall a. a -> a]
20:11:49 <lambdabot>     Illegal polymorphic or qualified type: forall a. a -> a
20:11:49 <lambdabot>     Perhaps you intended to use ImpredicativeTypes
20:11:49 <lambdabot>     In an expression type signature: [forall a. a -> a]
20:11:54 <zq> :set -XImpredicativeTypes
20:11:56 <simcity2000> nick_named: I could never really get in to Project Euler
20:12:02 <nick_named> lol, I've solved it, but they do some black magic in their solution
20:12:06 <benzrf> :t repeat id
20:12:07 <lambdabot> [a -> a]
20:12:11 <zq> lambdabot: such a prude
20:12:12 <GeraldCode> simcity, maybe try the python problems
20:12:17 <GeraldCode> but do them in haskell :)
20:12:22 <shachaf> zq: Huh?
20:12:26 <GeraldCode> python challenges*
20:12:43 <nick_named> simcity2000: I'm addicted to it... I solve every problem, then optimize my algorithms.
20:12:44 <simcity2000> GeraldCode: I do enough cool stuff to fill three full time jobs right now, thankfully
20:12:51 <GeraldCode> oh cool
20:12:59 <kazagistar> nick_named: there are a lot of ways to find primes, but for 27, I am pretty sure you can still use trial division, though I dont remember
20:13:14 <GeraldCode> The sieves on wikipedia are helkpful
20:13:22 <GeraldCode> but no matter what I cant make them go fast
20:13:28 <simcity2000> pulling down 20mil data points and consolidating them into profiles of people using haskell has been an interesting experience
20:13:42 <nick_named> kazagistar: I've solved it, then improved my solution from 5 seconds to 0.085 seconds... but the solution on http://www.haskell.org/haskellwiki/Euler_problems/21_to_30 runs in 0.001
20:13:52 <simcity2000> er, profiles of people through using haskell, not people who are using haskell
20:14:28 <zq> shachaf: huh huh?
20:14:51 <ruuns> :D
20:16:36 <kazagistar> the fastest program in the world http://primesieve.org/ uses a blocksieve (sieve of Eratosthenes cut up into smaller chunks) sized to fit in L1 cache with a wheel factorization of 30 or 210, and some fancy cache friendly buckets (which I haven't gotten to)
20:16:49 <kazagistar> *fastest program for finding all prime numbers
20:16:54 <GeraldCode> thats cheating :)
20:16:58 <GeraldCode> knowledge of the hardware :)
20:17:37 <kazagistar> GeraldCode: its just a single number, which determines the size of your array, you could conservatively set it a bit low and still get most of the same speed
20:17:45 <GeraldCode> ah
20:17:53 <shachaf> zq: That usually means something like "what do you mean by the last thing you said?".
20:18:03 <nick_named> kazagistar: Yeah, but this problem only requires primality testing, so you can just use the probabilistic primality test that is deterministic up to 2^64
20:18:25 <nick_named> kazagistar: Somehow the person writing the solutions on haskell.org solves it without primality testing...
20:18:56 <simcity2000> nick_named: have you thought about contacting them?
20:19:01 <simcity2000> might be worth a shot
20:19:06 <kazagistar> nick_named: if you need to do primality testing for EVERY number, I think it is still faster to sieve them...?
20:19:58 <GeraldCode> yeah
20:20:01 <ruuns> vty is a cool library in haskell :3
20:20:06 <GeraldCode> you cant do primality testing for every number, right?
20:20:34 <GeraldCode> thats what a sieve is meant to avoid I thought
20:20:41 <simcity2000> quick aside: is there anything similar to pylint for haskell?
20:20:49 <simcity2000> I know the haskell syntax rules are a little more...flexible
20:21:07 <kazagistar> GeraldCode: wait, you are looking at 27 from that page? yeah, I think that is sieve of atkin, I would have to double check though
20:21:11 <simcity2000> but there are some nice things I'd like to have, like finding excess parens and whatnot
20:21:17 <bms1> simcity2000: hlint?
20:21:19 <nick_named> kazagistar: You don't need to do it on every number, you just need to do it for numbers generated by the quadratic expressions, and since you can rule most of them out analytically, primality testing is probably faster, you could memoize it as well or sieve low primes.
20:21:31 <`nik`> does cabal not follow symlinks? i'm getting `/usr/bin/ghc does not exist` when it's a symlink
20:21:38 <GeraldCode> kazagistar,  oh I was responsding to you, but I HAVE seen that problem before
20:21:40 <GeraldCode> and solved it
20:21:42 <kazagistar> no, nevermind, its not even close
20:21:43 <GeraldCode> in python
20:21:45 <simcity2000> bms1: looks like it!
20:22:11 <GeraldCode> from what I have studied, and tried
20:22:18 <GeraldCode> you gotta do wheel facotrization on top of it
20:22:20 <GeraldCode> to get the best?
20:22:26 <GeraldCode> Seems logical
20:22:26 <bms1> yep! It's pretty nice, though sometimes I find it too dogmatic (for example, it wants me to replace "fmap f $ blah..." with "f <$> blah...."
20:22:29 <nick_named> kazagistar: Anyways, I just don't know how problem 27 is solved *without* primality testing
20:22:57 <GeraldCode> let me take another look
20:23:01 <GeraldCode> maybe I forgot what problem 27 is..
20:23:25 <simcity2000> bms1: I can deal with that
20:23:35 <GeraldCode> ah this one
20:23:40 <simcity2000> I'm pretty impressed with how much easier haskell is for prototyping things than python
20:23:51 <kazagistar> nick_named: maybe they cheated?
20:24:04 <GeraldCode> sorry, I did NOT do this one
20:24:08 <GeraldCode> so irgnore what I said
20:24:28 <nick_named> kazagistar: Maybe... but I can't tell, and the rest of them they haven't (http://www.haskell.org/haskellwiki/Euler_problems/21_to_30)
20:26:03 <kazagistar> nick_named: I might actually try to transcribe it into english+math and ask #math, it might use some number theory properties?
20:26:50 <nick_named> kazagistar: I'll do that
20:28:26 <jeffo> exit
20:29:45 <kvanb> http://llvm.org/releases/download.html#svn
20:29:49 <kvanb> woops, wrong window
20:29:51 <kvanb> sorry!
20:30:25 <GeraldCode>  kvanb just be happy that isnt your nude selfies
20:30:46 <kvanb> I would not be pasting those into any windows
20:30:50 <GeraldCode> lol
20:31:27 <kazagistar> nick_named: he is multiplying the equation to find the first 40 primes by another one, so that seems like a hint?
20:32:38 <kazagistar> GeraldCode: a sieve is basically useless in any practical situtation, afaik, but it is an interesting algorithm :P
20:32:58 <GeraldCode> oh, hmm
20:33:07 <GeraldCode> it is true I have never needed primes in my career
20:33:15 <GeraldCode> But I dont do much interesting
20:33:19 <GeraldCode> I mostly do DB related things
20:33:58 <GeraldCode> And even when younger, trying to play with game programming, I never needed primes
20:34:06 <GeraldCode> I am not sure when you need primes, to be honest
20:34:17 <bms1> planning FFTs!
20:34:18 <kazagistar> you cannot practically get past very small primes (a hundred or so bits) with a sieve in a sane amount of time, and if you could, they would be useless for most uses that primes are good for (crypto)
20:34:21 <bms1> cryptography!
20:34:27 <GeraldCode> oh
20:34:32 <GeraldCode> cryptography
20:34:58 <kazagistar> crypto needs primes, but it needs big primes, so it uses primality checking only, not sieves, afaik
20:35:04 <GeraldCode> I see
20:35:09 <GeraldCode> thats interesting
20:36:56 <kazagistar> bms1: do you use a lot of primes for planning FFTs? I havent done any work with FFTs, they are still a mystery to me :P
20:36:58 <BenedictEggers> preudo-random number generators need primes too (related but distinct from crypto)
20:37:11 <BenedictEggers> or at least, they're made much better by using primes
20:37:55 <bms1> kazagistar: I'm not super familiar with it actually. But in general, if you want to do an FFT of size n, you compute the prime factorization. And generally larger primes are more of a pain
20:38:17 <bms1> 2^n can be broken down recursively in a binary fashion with Cooley-Tukey
20:38:56 <bms1> But a prime can never be broken down! So if you have, like, 19 as a prime factor, you get a big base case, and there are special methods for dealing with those
20:41:11 <nick_named> kazagistar: Crypto just tries big numbers until a prime is found generally
20:42:59 <kazagistar> in any case, I just started doing http://rosalind.info/about/ instead Euler, cause it is all computational biology algorithms, which are actually somewhat useful :P
20:44:05 <GeraldCode> those people are smart :)
20:44:10 <kazagistar> string alignment and tree distances
20:44:26 <GeraldCode> I wish I could be in academia or research
20:44:42 <GeraldCode> sold my soul for a paycheck
20:45:04 <kazagistar> problem 1: count the number of As, Ts, Gs, and Cs in a string... I am pretty sure you can handle it, and it builds up slowly
20:45:17 <kazagistar> just like euler
20:45:20 <GeraldCode> ah ok
20:45:24 <GeraldCode> cool
20:45:34 <nick_named> kazagistar: That looks really interesting, I'll have to do that too... more problems for me.  I really like the math in Euler though
20:45:36 <kazagistar> and teaches you a bit about biology as you go
20:46:27 <kazagistar> oh, the really cool thing is that it has a concept dependancy DAG
20:46:34 <kazagistar> http://rosalind.info/problems/tree-view/
20:47:59 <GeraldCode>  lmao
20:48:06 <GeraldCode> thats cool they do that
20:48:10 <GeraldCode> but its hard to follow?
20:48:30 <kazagistar> they also have lists, and "suggested next questions" and so on
20:48:30 <GeraldCode> oh wait, I zoomed in a bit
20:48:33 <GeraldCode> I see whats going on
20:49:21 <GeraldCode> thanks
20:50:52 <bms1> Does anyone know why arb-fft uses what seems to be the unusual convention for their FFT?
21:03:52 <BenedictEggers> where does the word "functor" come from?
21:04:45 <nick_named> Category Theory
21:05:56 <jle`> are you sure it's not from C++, where a Functor is a class with an overloaded ()?
21:06:24 <jle`> (sorry)
21:06:30 <jle`> (>_>)
21:06:32 <jle`> (also, it's not)
21:07:10 <ruzu> so you wake up one day and find that you're chained to the jvm.  scala or clojure?
21:07:49 <jle`> i haven't used both seriously, but i heard that scala has some sort of type system
21:08:12 <BenedictEggers> i dont know, people are pretty fanatic about clojure
21:08:14 <BenedictEggers> smart people
21:08:39 <jle`> i am smart people
21:08:57 <benzrf> @let (>_>) = ">_>"
21:08:57 <lambdabot>  Parse failed: Parse error: )
21:09:05 <nick_named> jle`: Thats what I thought too, the C++ "functor" should really be called a function object
21:09:31 <jle`> benzrf: _ is for normal function names
21:09:37 <jle`> unfortunately ;_;
21:09:48 <jle`> @let (>.>) = ">.>"
21:09:50 <lambdabot>  Defined.
21:09:51 <jle`> > (>.>)
21:09:52 <lambdabot>  ">.>"
21:10:09 <jle`> nick_named: yeah, it's rather unfortunate, but what can you do
21:10:24 <bms1> ruzu: Not sure if you're leading this way, but I have been using the java-bridge package lately with Haskell to use the JNI!
21:10:36 <ruzu> o_o
21:10:50 <jle`> can't i just program in jvm bytecode
21:10:59 <lfairy> ruzu: ermine ;)
21:13:03 <ruzu> this ermine looks fabulous
21:15:12 <jle`> that'd edwardk_'s language, isn't it
21:20:53 <GeraldCode> jle, intercal is better
21:24:46 <isomorpheous> Hm.
21:25:01 <isomorpheous> I'm trying to brainstorm for new project ideas
21:25:11 <GeraldCode> ok let's go
21:25:21 <GeraldCode> throw them out
21:25:23 <kristof> Are closures usually implemented by lambda lifting?
21:25:24 <isomorpheous> My main interest is math
21:25:33 <ruzu> parallel basketweaving simulation
21:25:37 <GeraldCode> ok, how about something like mathematica?
21:25:43 <GeraldCode> but done in haskell
21:26:04 <octopuscabbage> if you are a math phd then sure go ahead
21:26:12 <isomorpheous> Too much work, and there's no way I could replicate it
21:26:17 <GeraldCode> ok
21:26:22 <ruzu> call it haskematica
21:26:32 <octopuscabbage> call is asthmatica
21:26:42 <GeraldCode> how about an interactive website that teaches math
21:26:44 <GeraldCode> written in haskell
21:26:46 <Darien> Haz-matica?
21:26:52 <isomorpheous> Darien: I like that
21:27:08 <octopuscabbage> writing websites in haskell won't give you that much haskell experience and a lot of html+css experience
21:27:11 <kristof> Write a program which parses mathematica programming, uses Template Haskell to generate the appropriate haskell code, and compile that.
21:27:14 <GeraldCode> ok
21:27:18 <isomorpheous> hm
21:27:35 <isomorpheous> Ideally, it would be something I would actually use myself
21:27:46 <GeraldCode> what kind of math?
21:27:51 <GeraldCode> do you have a specialty?
21:27:58 <isomorpheous> GeraldCode: algebraic geometry
21:27:59 <octopuscabbage> if you have an interest in math you probably have a type of equuation you don't like, make a solver for that
21:28:10 <GeraldCode> what he said
21:28:23 <Darien> theorem prover?
21:28:41 <octopuscabbage> try re writing quickcheck?
21:28:54 <octopuscabbage> that's mathmatical and really haskally
21:29:03 <octopuscabbage> that'll make you a haskell rascall in no time
21:29:11 <jle`> isomorpheous: how about something in machine learning
21:29:22 <jle`> isomorpheous: if you want a small project
21:29:24 <octopuscabbage> plus you get to see how cool randomness is in haskell
21:29:24 <GeraldCode> isomorpheous,  I asked here a while back about a generalized library to give the algorithmic complexity of a given function
21:29:27 <jle`> isomorpheous: some bayesian inference or something
21:29:28 <GeraldCode> how about that
21:29:34 <jle`> or an ANN
21:29:39 <octopuscabbage> GeraldCode: I'm not sure that's possible
21:29:43 <octopuscabbage> GeraldCode,
21:29:43 <GeraldCode> yeah me neither
21:29:47 <octopuscabbage> in a strict sense of the term
21:29:48 <isomorpheous> I'm thinking, it would either be something that would automate a task of mine, or would be a research interest
21:29:48 <kvanb> Yeah that doesn't sound possible
21:29:56 <octopuscabbage> you could make it kind of work sometimes
21:29:58 <kvanb> unless it could construct a best/worst case type thing
21:30:05 <octopuscabbage> if it took a list of any length and also produced a list
21:30:07 <GeraldCode> yar..
21:30:18 <octopuscabbage> then you can just take some data points and solve for that
21:30:33 <GeraldCode> isomorpheous,  what do you do, exactly
21:30:37 <kvanb> octopuscabbage: you could always spit out everything in terms of n
21:30:38 <GeraldCode> that you want to automate
21:30:42 <kvanb> for each input of every function
21:30:48 <octopuscabbage> kvanb: what do you mean by that?
21:30:59 <kvanb> just forget about O(1) then if the user knows that n for some list input is 1, they solve it themselves
21:31:02 <isomorpheous> GeraldCode: that's the problem, my workflow is already so streamlined that I can't think of any sore points
21:31:07 <Darien> I'm pretty sure you'd have halting problem problems if you tried to automate complexity determination
21:31:11 <GeraldCode> well you are already in nirvana
21:31:12 <joelteon> what's the best way to convert a trie into a tree?
21:31:18 <GeraldCode> I am still trying to automate crap at work
21:31:21 <octopuscabbage> joelteon: why
21:31:22 <benzrf> joelteon: s/i/e
21:31:27 <GeraldCode> but I get held back by other mundane duties
21:31:31 <kvanb> gulp/grunt
21:31:32 <joelteon> oh, wait
21:31:36 <kvanb> is honestly the worst thing
21:31:39 <joelteon> never mind, I got it now
21:31:49 <joelteon> I already had a directory tree lying around
21:31:55 <octopuscabbage> joelteon: why do you need to? if you need to you probably have a trie implemented wrong
21:31:57 <kvanb> in a perfect world they would be incredible
21:32:00 <kvanb> in reality it's unusable.
21:32:22 <isomorpheous> GeraldCode: I use a XMonad on Arch Linux with Emacs. I'm basically in the definition of the customized environment
21:32:23 <joelteon> octopuscabbage: I just want to pretty-print it
21:32:24 <GeraldCode> isomorpheous,  the holy grail to me has always been meta-code
21:32:26 <joelteon> I don't *need* to
21:32:38 <GeraldCode> so make something that is smart enough to know what work needs to be done
21:32:46 <isomorpheous> GeraldCode: I have been contemplating a "buffer revision system" in emacs
21:32:51 <GeraldCode> oh
21:32:53 <octopuscabbage> isomorpheous: make a plugin for vim
21:33:13 <isomorpheous> GeraldCode: something that generalizes edits in an abstract way, and allows you to quickly apply them to multiple files
21:33:26 <Darien> has someone written a Haskell interpreter in emacs-lisp?
21:33:28 <GeraldCode> that soubds very useful
21:33:40 <octopuscabbage> isomorpheous: it's really hard to do that in a way the linux command line can't already
21:33:55 <isomorpheous> octopuscabbage: give me some examples
21:34:06 <kvanb> what about a tool to generate haskell project structures
21:34:18 <isomorpheous> GeraldCode: You seem to be thinking of a referentially transparent IDE
21:34:20 <kvanb> not regular ones, but with the functions and types already defined
21:34:22 <octopuscabbage> isomorpheous: the only way i can see that /really/ being useful is enforcing some sort of style guide
21:34:27 <isomorpheous> kvanb: like an edit scaffolder?
21:34:36 <kvanb> so you go into a buffer and you do like
21:34:43 <kvanb> MyModule.Something
21:34:44 <GeraldCode> isomorpheous,  yeah I guess..
21:34:45 <kvanb>   add :: ..
21:34:47 <kvanb>   remove :: ...
21:34:50 <octopuscabbage> you could also make something that automatically generates a makefile from a haskell source file
21:34:50 <kvanb> MyModule.Other
21:34:52 <kvanb>   blah :: ...
21:34:58 <isomorpheous> octopuscabbage: what's wrong with Cabal?
21:35:02 <kristof> Darien: Have you ever used emacs lisp? Interpreted, dynamically typed, doesn't enforce immutability, no notion of parametric polymorphism... what exactly about that screams "we should rewrite ghc in elisp"?
21:35:10 <kvanb> and it generates the cabal, haskell and everything else automatically
21:35:18 <kvanb> with everything = undefined so you can build it
21:35:25 <isomorpheous> Darien: there's structured Haskell mode, which is pretty close
21:35:35 <octopuscabbage> you could figure out a way to write a UML type thing but for functional code and then have it output it
21:35:49 <GeraldCode> Id very much like something that could do UML
21:35:55 <octopuscabbage> well not even uml
21:35:55 <GeraldCode> from my code..rather than the other way around
21:35:58 <octopuscabbage> just module specifications
21:36:02 <GeraldCode> because, frankly, I dont have time for UML
21:36:15 <GeraldCode> but I still want good docs
21:36:39 <octopuscabbage> yeah but the problem with generating uml diagrams from code assumes that all the code you've written is good code
21:36:54 <octopuscabbage> and that all connections between all parts are meaningful enough to be recognized
21:36:55 <trap_exit> yo
21:36:56 <trap_exit> so I need to parse a bianry file
21:36:58 <trap_exit> http://yann.lecun.com/exdb/mnist/ in particular
21:37:03 <trap_exit> any suggestion what library I use ?
21:37:17 <GeraldCode> octopuscabbage, I agree
21:37:20 <isomorpheous> trap_exit: What's wrong with ByteString?
21:37:21 <GeraldCode> it probably isnt feasible
21:37:36 <octopuscabbage> GeraldCode: it's easily feasible, it's just not possible to determine what's useful and what's not automatically
21:37:37 <trap_exit> isomorpheous: I don't know; what is wrong with ByteString?
21:37:37 <GeraldCode> which is why we still need humans to make code I guess
21:37:48 <kvanb> trap_exit: binary
21:37:48 <GeraldCode> ah ok agreed
21:37:54 <kvanb> @where binary
21:37:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
21:37:55 <octopuscabbage> you could make something that makes my chai lattees
21:38:09 <kvanb> @hackage binary
21:38:10 <lambdabot> http://hackage.haskell.org/package/binary
21:38:15 <kvanb> that one is more helpful.
21:38:38 <isomorpheous> trap_exit: well there's my point, binary uses bytestrings
21:38:55 <carter> kvanb: do you know when dcoutts  is gonna release his new binary?
21:38:56 <trap_exit> kvanb: lambdabot's url is "access forbidden"
21:39:01 <GeraldCode> octopuscabbage,  now that I think about it....
21:39:11 <kvanb> carter: #ghc told me it was soon yesterday
21:39:14 <kvanb> I'm looking forward to it
21:39:16 <GeraldCode> since the idea is to make most of your code outside of IO monad...and ref transparent
21:39:24 <GeraldCode> why arent there more code generators for haskell?
21:39:31 <GeraldCode> seems like it should be doable?
21:39:45 <kvanb> more code generators?
21:39:46 <octopuscabbage> because haskell is a new language and not commerically used, and only commercial people have the need for code generators
21:39:46 <trap_exit> okay
21:39:47 <kvanb> like .. .?
21:39:48 <kristof> wtf is a code generator
21:39:49 <trap_exit> is thre a tutorial for this?
21:40:00 <octopuscabbage> code generators like those things that will generate skeletons from uml diagrams
21:40:00 <kvanb> you mean like javascript etc?
21:40:01 <GeraldCode> kristof, just some silly thing I read about once
21:40:02 <octopuscabbage> really REALLY useful
21:40:05 <kvanb> oh
21:40:11 <octopuscabbage> if you have a very complex program
21:40:15 <octopuscabbage> oh actually
21:40:21 <octopuscabbage> i have a good haskell project for someone
21:40:21 <carter> ghc is 20 years odl
21:40:22 <carter> old
21:40:29 <kvanb> carter: older
21:40:30 <isomorpheous> octopuscabbage: shoot
21:40:32 <ruzu> anyone use core.typed for clojure?  i wonder how well it works.
21:40:32 <kvanb> oldest ticket is 37 years old
21:40:33 <carter> yes
21:40:34 <octopuscabbage> make haskell work on arduino
21:40:40 <carter> kvanb: wat
21:40:44 <carter> now you trollin
21:40:48 <kvanb> carter: might be a trac glitch
21:40:50 <kvanb> but im not shitting you
21:40:52 <carter> probs
21:41:01 <carter> first ghc release was in 91 or so
21:41:02 <kristof> octopuscabbage: UML diagrams associate methods to datatypes.
21:41:03 <carter> or something
21:41:21 <GeraldCode> isomorpheous,  you could write a paper demonstrating why haskell ideas make code safer
21:41:24 <GeraldCode> publish it
21:41:29 <GeraldCode> get a $200k job
21:41:32 <GeraldCode> and call it a day
21:41:33 <wei2912> ???
21:41:34 <wei2912> profit
21:41:39 <octopuscabbage> GeraldCode: >implying people get jobs in haskell
21:41:45 <GeraldCode> heheh
21:41:52 <octopuscabbage> octopuscabbage: >implying my job isn't sometimes in haskell
21:41:54 <isomorpheous> I have a job in Haskell :)
21:42:06 <simcity2000> a job in a programming language?
21:42:16 <mwhit> no no, you use haskell to prove you know your shit, then get a job using another, inferior language
21:42:19 <isomorpheous> simcity2000: a job where most of my work is done using a Haskell
21:42:21 <simcity2000> that's like having a job with wrenches
21:42:26 <simcity2000> isomorpheous: better
21:42:28 <isomorpheous> simcity2000: one haskell, not two
21:42:44 <octopuscabbage> simcity2000: no it's more like having a job in a certain type of electrical station
21:42:58 <kvanb> mwhit: so my resume was full of haskell and c++ stuff
21:42:59 <octopuscabbage> simcity2000: or administering a certain type of server (windows, linux)
21:43:01 <GeraldCode> isomorpheous,  Id like to have such a job
21:43:04 <kvanb> my job is in cobol and javascript right now
21:43:04 <kvanb> ;_;
21:43:13 <GeraldCode> I am on the opposite end of the spectrum
21:43:14 <Darien> isomorpheous: otherwise they'll mulitiply?
21:43:19 <kristof> kvanb: I didn't know those two domains could ever exist simultaneously.
21:43:21 <GeraldCode> I spit out fast code in PHP at the moment
21:43:33 <kvanb> kristof: theres a javascript frontend I'm writing to run cobol apps
21:43:34 <isomorpheous> GeraldCode: I'm so sorry
21:43:37 <kvanb> surprisingly it's very sexy.
21:43:38 <GeraldCode> Very little design, no type safety, and no compiler to protect me
21:43:53 <isomorpheous> Darien: exactly
21:43:54 <GeraldCode> but im not just doing simple websites
21:43:58 <kristof> kvanb: Neat-o. What does the COBOL code do?
21:44:01 <GeraldCode> I am doing intricate mnipulations of data
21:44:06 <kvanb> rest is kind of nda
21:44:09 <joneshf-laptop> what's it called when you have a type synonym inside a typeclass?
21:44:12 <GeraldCode> and i already am scared my big project has bugs
21:44:12 <kristof> kvanb: Gotcha.
21:44:22 <shachaf> joneshf-laptop: Associated types.
21:44:27 <isomorpheous> GeraldCode: this is why you write your web apps in Haskell
21:44:31 <GeraldCode> yes
21:44:33 <joneshf-laptop> shachaf, thanks
21:44:39 <shachaf> I feel like this conversation is pretty off-topic for #haskell at this point.
21:44:44 <octopuscabbage> isomorpheous: not really, it's much worse than doing it in django
21:44:48 <isomorpheous> shachaf: it started as on topic
21:44:48 <octopuscabbage> imho
21:44:56 <kvanb> #haskell is never on topic
21:45:00 <shachaf> Or at least it's drowning out everything else and should go in #-overflow.
21:45:06 <GeraldCode> oh
21:45:09 <kvanb> on topic is for #haskell-beginners
21:45:10 <kvanb> ;)
21:45:13 <simcity2000> shachaf: as long as I see haskell in my buffer it's #haskell
21:45:27 <GeraldCode> I should not have brought up PHP
21:45:29 <isomorpheous> octopuscabbage: I haven't used django, I have used Rails though. Rails >> PHP
21:45:33 <GeraldCode> I know it makes people want to puke
21:45:36 <shachaf> Really?
21:45:42 <isomorpheous> GeraldCode: I think that's a good rule for any situation
21:45:52 <octopuscabbage> isomorpheous: it's basically the same thing, i've used rails, django, and php
21:46:01 <octopuscabbage> i mean django and rails are basically the same thing
21:46:06 <isomorpheous> octopuscabbage: ah, yeah
21:46:17 <octopuscabbage> php is a silly beast
21:46:22 <spott> other than hmatrix-static, is there a static vector library?
21:46:34 <mwhit> spott: not to my knowledge
21:46:43 <spott> :(
21:46:44 <spott> thanks
21:46:44 <mwhit> not that that's a sure thing
21:46:49 <kristof> spott: #numerical-haskell might know.
21:46:53 <GeraldCode> lol isomorpheous
21:46:56 <GeraldCode> yeah...
21:47:09 <spott> kristof, mwhit thanks
21:47:10 <GeraldCode> isomorpheous,  you see I got into php simply because I wanted an easy job
21:47:13 <mwhit> spott: can I ask your issues with hmatrix-static? I'm just interested in hearing others' experiences with it
21:47:18 <benzrf> GeraldCode: >php
21:47:19 <benzrf> >easy
21:47:21 <GeraldCode> now my job is not so easy
21:47:26 <octopuscabbage> i saw a proposition to add a strict pragma to the language, does anyone know if that's been further considered?
21:47:28 <GeraldCode> and I need to improve my game
21:47:36 <benzrf> php is easy the same way that drugs make you feel good
21:47:36 <spott> mwhit it doesn't build with GHC 7.8
21:47:45 <benzrf> it is at first but you start paying later on
21:47:48 <GeraldCode> benzrf,  good analogy
21:47:50 <isomorpheous> octopuscabbage: I feel like we should have something opposite to lisp's '
21:47:52 <benzrf> :^)
21:48:08 <isomorpheous> octopuscabbage: instead of "evaluate this lazily", we have "evaluate this next part strictly
21:48:15 <isomorpheous> octopuscabbage: you know newbies would abuse it though
21:48:25 <octopuscabbage> isomorpheous: i agree. that's why we don't teach them about pragma for a while
21:48:42 <octopuscabbage> isomorpheous: we tell them they need to learn monads first to buy us a bit of time
21:48:42 <mwhit> spott: which 7.8?
21:48:46 <isomorpheous> octopuscabbage: haha
21:48:53 <simcity2000> octopuscabbage: nice
21:48:55 <kristof> isomorpheous: I'm sorry, what's opposite to quoting?
21:49:02 <spott> 7.8.2
21:49:04 <spott> I believe
21:49:22 <mwhit> spott: I've built it on 7.8.2, what's not working for you?
21:49:30 <benzrf> isomorpheous: bang patterns
21:49:32 <octopuscabbage> laziness also occasionally gets in the way of parallel computing
21:49:35 <benzrf> :t (!$)
21:49:36 <lambdabot>     Not in scope: ‘!$’
21:49:36 <lambdabot>     Perhaps you meant one of these:
21:49:36 <lambdabot>       ‘$!’ (imported from Prelude), ‘!!’ (imported from Data.List),
21:49:39 <benzrf> :t ($)
21:49:39 <lambdabot> (a -> b) -> a -> b
21:49:40 <benzrf> :t ($!)
21:49:41 <lambdabot> (a -> b) -> a -> b
21:50:00 <octopuscabbage> yes, i understand bang is a thing, but it's annoying to add bang a bunch of times if you know your code is better eager
21:50:02 <benzrf> > head ((:) 1 $ undefined)
21:50:03 <lambdabot>  1
21:50:06 <benzrf> > head ((:) 1 $! undefined)
21:50:07 <lambdabot>  *Exception: Prelude.undefined
21:50:08 <benzrf> octopuscabbage: kk
21:50:09 <mwhit> spott: oh wait, are you talking about the old hmatri-static *addon* package?
21:50:13 <kristof> isomorpheous: http://www.haskell.org/haskellwiki/Performance/Strictness#Evaluating_expressions_strictly what benzrf is saying.
21:50:15 <isomorpheous> kristof: in lisp, you can say (format t "hello") , which prints "hello". or you can do '(format t hello) , which is the expression (format t hello)
21:50:21 <mwhit> that's long-dead
21:50:27 <spott> mwhit yea
21:50:34 <mwhit> regular old hmatrix just added static vectors like a month or two ago
21:50:37 <spott> ah!
21:50:39 <spott> ok
21:50:39 <isomorpheous> @src ($!)
21:50:39 <lambdabot> f $! x = x `seq` f x
21:50:43 <benzrf> isomorpheous: i dont think thats exactly 'evaluate this lazily'
21:50:47 <benzrf> lisp quoting is a whole other thing
21:50:50 <kristof> isomorpheous: That's not creating a thunk, though. That's simply creating a literal list, which just happens to also be a program's format.
21:50:53 <isomorpheous> benzrf: not exactly, but that's the idea
21:51:02 <octopuscabbage> yeah that's more similar to passing a curried function
21:51:08 <benzrf> isomorpheous: template haskell has similar quoting
21:51:19 <spott> thanks
21:51:22 <isomorpheous> benzrf: I hate template haskell.
21:51:24 <mwhit> np
21:51:24 <kristof> isomorpheous: You wouldn't use quoting to implement thunks in a lisp. You'd wrap them in no-argument lambda objects.
21:51:30 <benzrf> octopuscabbage: really it's more like pulling an AST from a form instead of a value
21:51:32 <octopuscabbage> isomorpheous: not /really/ most lisp alsso have a (lazy ) and (force ) macro
21:51:34 <isomorpheous> kristof: yeah
21:51:48 <GeraldCode> arent thunks a lazy idea? and isnt haskell strict?
21:51:57 <benzrf> GeraldCode: wha
21:51:58 <octopuscabbage> GeraldCode: no haskell is super lazy
21:51:58 <GeraldCode> I mean lisp
21:52:02 <GeraldCode> sorry
21:52:12 <octopuscabbage> GeraldCode: it's not in the specification to be lazy or strict
21:52:17 <kristof> GeraldCode: First thunks were investigated with Scheme
21:52:17 <octopuscabbage> GeraldCode: most lisps are strict
21:52:18 <benzrf> GeraldCode: you can implement thunks manually in a lot of languages
21:52:26 <GeraldCode> oh variants of lisp can be lazy?
21:52:29 <GeraldCode> okkkk
21:52:33 <benzrf> GeraldCode: haskell is nice and does it for you
21:52:38 <octopuscabbage> GeraldCode: but because of lisps amazing macro system you can have a lazy and force macro
21:52:45 <BenedictEggers> GeraldCode: clojure is lazy, i believe
21:52:45 <octopuscabbage> so if i wanted to add 1 lazily
21:52:46 <GeraldCode> interesting
21:52:55 <octopuscabbage> BenedictEggers: it's not, it has a lazy and force macro
21:53:02 <BenedictEggers> ah, thanks
21:53:03 <octopuscabbage> (lazy add 1)
21:53:13 <octopuscabbage> and that would return a function that you could call (force x ) on
21:53:22 <isomorpheous> I wish quasiquoting was more popular
21:53:31 <benzrf> GeraldCode: basically the thing in lisp is that the AST is all lists and literals so there's almost no brainspace necessary for dealing with program-structure manipulation
21:53:37 <octopuscabbage> isomorpheous: i don't, it's super annoying to deal with and can be handled with first class functions
21:53:42 <kristof> octopuscabbage: "lazy" and "force" are just (lambda () (body-to-execute) and (thunk) respectively. You hardly need anything more than syntax case for such a construct.
21:53:52 <benzrf> GeraldCode: you can write a function from lists to lists, and then change which form you use to define it and suddenly it transforms programs instead
21:53:54 <GeraldCode> benzrf, hmmm
21:53:54 <carter> not quite, theres the caching trick
21:54:04 <octopuscabbage> kristof: i know, i'm just trying to explain it to someone who's not familiar with lisps macro system
21:54:07 <kristof> This discussion needs to go back to Haskell related subjects.
21:54:27 <GeraldCode> benzrf, that is interesting
21:54:33 <benzrf> very much so :o
21:54:38 <octopuscabbage> kristof: laziness vs strictness in other languages is fairly haskell related IMO, as it's useful to explaining why haskell is lazy
21:54:40 <GeraldCode> in that it shows how much power come ceomfrom simple foundations something is built on
21:54:50 <benzrf> for example
21:54:54 <benzrf> in lisp you write:
21:55:05 <benzrf> (lambda (a b) (+ a b))
21:55:10 <benzrf> vs \a b -> a + b
21:55:19 <benzrf> note that the former is just a rose tree
21:55:25 <benzrf> the latter doesnt map quite as cleanly
21:55:27 <GeraldCode> right
21:55:31 <kristof> carter: If you can statically prove that a body of code is purely functional, then yes, but I was talking about Scheme
21:55:39 <trap_exit> I have a question
21:55:39 <GeraldCode> in lisp you really cant seperate data from code
21:55:42 <trap_exit> are macros a special case of DSLs ?
21:55:43 <GeraldCode> but in haskell, its no so clean
21:55:49 <benzrf> trap_exit: macros may be used to make DSLs
21:55:55 <trap_exit> should I be thinking "how od I build macros in ahskell" or "how do I build DSLs in haskell" ?
21:55:59 <octopuscabbage> but they're trying to evoke differnet ideas. lisp is trying to evoke a code is data, haskell is trying to evoke code is math
21:56:05 <benzrf> trap_exit: macros are a tool that are often used to make dsls
21:56:07 <trap_exit> it seems like macros is not the end goal
21:56:11 <GeraldCode> octopuscabbage,  ah
21:56:11 <trap_exit> but DSLS are the end goal
21:56:17 <trap_exit> and macros are merely a means to get there
21:56:18 <benzrf> trap_exit: but you can use macros for things besides dsls, and dsls made without macros
21:56:21 <octopuscabbage> GeraldCode: just differing philosiphies
21:56:22 <kristof> GeraldCode: There is such a thing as Template Haskell, you know.
21:56:42 <trap_exit> benzrf: when is it useful to use a macro that is not a DSL ?
21:56:45 <octopuscabbage> you can make dsls in c++, it's just harder and not as useful
21:56:56 <GeraldCode> kristof, yeah I am a bit wary to get into it...I am learning yesod
21:57:00 <benzrf> trap_exit: any kind of abstraction
21:57:03 <GeraldCode> but havent bothered to learn how TH work
21:57:03 <isomorpheous> GeraldCode: ick
21:57:09 <benzrf> just like you can use functions to make a dsl, or not
21:57:16 <benzrf> i need to sleep now
21:57:20 <benzrf> bye
21:57:25 <GeraldCode> isomorpheous,  there seems to be no viable alternative
21:57:34 <isomorpheous> GeraldCode: happstack isn't bad
21:57:34 <GeraldCode> snap isnt ready for prime-time, so to speak
21:57:39 <isomorpheous> GeraldCode: I built my own from scratch
21:57:44 <GeraldCode> Happas doesnt seem like a good fit either
21:57:45 <isomorpheous> GeraldCode: or, am building
21:57:52 <ReinH> Really? People seem to be using it in "prime time".
21:57:58 <GeraldCode> I could use haskell with FCGI and roll my own, but that would be painful
21:58:09 <octopuscabbage> GeraldCode: use haskell + mustachetemplates
21:58:13 <GeraldCode> hmmm
21:58:14 <GeraldCode> ok
21:58:19 <isomorpheous> GeraldCode: yesod is just a shitstorm of bad practice
21:58:20 <octopuscabbage> GeraldCode: if you have an interest in making your own
21:58:20 <GeraldCode> i have tried mustache
21:58:38 <isomorpheous> octopuscabbage: I have no interest in making my own, I did so out of necessity
21:58:59 <octopuscabbage> isomorpheous: what sort of emergency warranted a haskell web app
21:59:23 <joelteon> Yesod is a pretty good framework
21:59:36 <isomorpheous> octopuscabbage: not an emergency, so to speak. I needed to make a site, and I wanted to use Haskell, and the frameworks out there suck
21:59:36 <joelteon> It wants to do a lot in Template Haskell, but it's surprising how much it *can* do with Template Haskell
22:00:04 <GeraldCode> hmm
22:00:07 * hackagebot language-openscad 0.1.5 - A simple parser for OpenSCAD  http://hackage.haskell.org/package/language-openscad-0.1.5 (BenGamari)
22:00:24 <isomorpheous> joelteon: I said this before. Yesod's documentation is virtually nonexistent, it's types are insane, and it's riddled with poor practices
22:00:30 <octopuscabbage> but back to what i was saying, someone make haskell work on arduino
22:00:31 <GeraldCode> joelteon,  hav you done happstack also?
22:00:45 <octopuscabbage> i would be sooooooo happy. all the electrical engineers i do robotics with would be sooooooooo upset.
22:00:47 <isomorpheous> octopuscabbage: i wouldn't know how to do that
22:00:50 <kristof> isomorpheous: *its.
22:00:59 <octopuscabbage> isomorpheous: neither would i, that's why i want other people to do it.
22:01:06 <kristof> isomorpheous: Patches welcome.
22:01:09 <joelteon> I've always found the documentation helpful
22:01:19 <joelteon> GeraldCode, no
22:01:23 <octopuscabbage> there's a few papers on haskell for robotics
22:01:25 <GeraldCode> wait a  sec :)
22:01:35 <GeraldCode> nevermind
22:01:42 <GeraldCode> joelteon,  ok, no prob
22:01:51 <GeraldCode> I am trying to figure out best way forward
22:01:58 <GeraldCode> do you do web stuff in haskell?
22:02:01 <joelteon> I've tried Yesod and Snap. I like Yesod better.
22:02:07 <GeraldCode> k
22:02:51 <carter> snap is nice too
22:02:55 <carter> try things
22:02:58 <carter> and see what sticks
22:03:02 <carter> i just get angry at buildhell
22:03:05 <GeraldCode> I kind of liked what I saw from snap...
22:03:14 <GeraldCode> But I got turned off by it still being essentially a beta?
22:03:20 <carter> GeraldCode: nah,
22:03:22 <carter> its stable
22:03:22 <glguy> My default is to just use snap-core
22:03:27 <GeraldCode> and really not having tight bindings to templating or DBs
22:03:35 <carter> GeraldCode: .... it has those
22:03:35 <GeraldCode> ok
22:03:46 <carter> haskell web stacks are libraries not frameworks
22:03:51 <carter> easy to mix and match
22:04:00 <GeraldCode> ok
22:04:02 <joelteon> unless it's yesod
22:04:05 <carter> my anti yesod bias is the scars of many a build hell
22:04:10 <GeraldCode> frankly it seemed easier to understanbd than yesod
22:04:14 <GeraldCode> but I have done very little in either
22:04:19 <GeraldCode> I want easy :)
22:04:19 <carter> GeraldCode: try things
22:04:21 <carter> :)
22:04:27 <carter> GeraldCode: well, whats the end goal?
22:04:30 <joelteon> I've never had build problems with yesod, but I guess I'm in the minority
22:04:34 <GeraldCode> carter, oh yes..I cant get mongo to work with yesod
22:04:38 <GeraldCode> and mongo is my main db
22:04:45 <carter> GeraldCode: why mongo?
22:04:54 <isomorpheous> kristof: ah thank you, i make that mistake a lot
22:04:56 <carter> bitemyapp: should he be using mongo or postgres? :)
22:04:57 <GeraldCode> well this particular project lended itself to a document structure
22:05:00 <kwos> hello!
22:05:09 <GeraldCode> um how do I explain..
22:05:11 <carter> :)
22:05:19 <levi> octopuscabbage: It's highly unlikely that anyone will write a Haskell compiler that could usefully target an Atmega8; you might be able to run some JHC-compiled programs on the ARM-based Arduinos, though.
22:05:22 <GeraldCode> We wanted to be able to easily change the structure
22:05:22 <kristof> ...Doesn't that depend on what you need?
22:05:30 <kristof> Also, I didn't know bitemyapp still frequents this channel
22:05:31 <GeraldCode> so we define the schema essentially in CSVs
22:05:41 <Darien> > map(chr.foldl1((+).(*2)).map digitToInt)$words "1001000 1100101 1101100 1101100 1101111 100000 1010111 1101111 1110010 1101100 1100100"
22:05:42 <lambdabot>  "Hello World"
22:05:50 <GeraldCode> then most of the PHP code, HTML, and Javascript automatically gets generated
22:05:50 <carter> GeraldCode: its called "build a new table with the new schema"
22:05:56 <GeraldCode> We liked it for the schemaless nature
22:06:07 <carter> .... for funsies or work?
22:06:21 <GeraldCode> carter, maybe for funsies..I dunno..maybe I am a shitty computer scientists, but its working
22:06:22 <carter> every time i've worked with folks who have data in a nosql no schema, i'ts been impossible to onboard into their schma
22:06:31 <carter> if its for funsies
22:06:36 <carter> and only you, go crazy
22:06:41 <GeraldCode> so I can edit this CSV file...and everything else "just works"
22:06:50 <carter> GeraldCode: NB, postgres has a nice document store now
22:06:58 <GeraldCode> well its not just for me, but I hope everything foes well
22:07:03 <GeraldCode> this is the biggest project of my career
22:07:05 <GeraldCode> by far
22:07:12 <GeraldCode> oh really?
22:07:28 <bitemyapp> carter: buhhhh
22:07:58 <bitemyapp> GeraldCode: you really want to get away from MongoDB, but you could possibly make it work just like you could make an untyped lang "work"
22:08:01 <GeraldCode> carter, you see, I dont know if you do web..but usually in a web proiject you have to make sure your naming is consistent in 4 places
22:08:09 <GeraldCode> html, DB, ,web server lang> and JS
22:08:16 <octopuscabbage> levi: I understand that it's unlikely, i just want it to happen
22:08:22 <GeraldCode> my goal here was to make it so I only needed it to be in one place (and sometimes 2 )
22:08:26 <simcity2000> carter: postgres is doing document store now?
22:08:32 <trap_exit> is there a way to do conditional compiles in haskell
22:08:33 <simcity2000> that's interesting
22:08:36 <trap_exit> i.e. like C's #ifdef ... #endif
22:08:47 <GeraldCode> bitemyapp, hmmm
22:08:49 <joelteon> trap_exit: yeah, just use LANGUAGE CPP
22:08:54 <GeraldCode> bitemyapp, yeah I see your point
22:08:56 <joelteon> and you can use C preprocessor directives
22:09:04 <GeraldCode> I am really being antithetical to haskell by doing whatI am doing
22:09:08 <carter> @ghttp://www.postgresql.org/docs/9.3/static/hstore.html
22:09:08 <lambdabot> Unknown command, try @list
22:09:10 <trap_exit> I want a single piece of haskell code
22:09:14 <trap_exit> to generate both client and server side code
22:09:15 <carter> http://www.postgresql.org/docs/9.3/static/hstore.html
22:09:20 <trap_exit> via Client monad and Server monad
22:09:21 <carter> GeraldCode: dyanmic things are ok
22:09:23 <trap_exit> and conditonal compiles
22:09:29 <carter> its just.... every webscale thing i've helped folkswith
22:09:35 <trap_exit> joelteon: why would I use cpp ?
22:09:36 <isomorpheous> trap_exit: see cabal flags and the CPP extension
22:09:37 <stepcut> octopuscabbage: I got Idris working on the arduino... https://github.com/stepcut/idris-blink
22:09:39 <carter> docuemnt stores have hindered the scaling
22:09:45 <carter> stepcut: i heard!
22:09:45 <carter> props
22:09:48 <joelteon> trap_exit: you asked about ifdef
22:09:54 <trap_exit> isomorpheous: CPP extension = haskell thing, not a lame response to "use C++ " ?
22:10:12 <stepcut> carter: the real props go to edwinb -- it mostly just worked :)
22:10:13 <joelteon> wait, what?
22:10:23 <isomorpheous> trap_exit: Yes, CPP = "C preproccesor" . see http://projects.haskell.org/cpphs/
22:10:31 <joelteon> oh, you thought I meant c++?
22:10:39 <carter> {-# LANGUAGE CPP#-}
22:10:40 <isomorpheous> trap_exit: we aren't insane
22:11:24 <trap_exit> hmm
22:11:26 <carter> GeraldCode: that you can do postgres SQL queries with HSTORE is epic
22:11:26 <trap_exit> I don't need _literal_ cpp pre processors
22:11:35 <trap_exit> just a way to do conditional compilations
22:11:42 <rwbarton> that is the way it is done
22:11:47 <joelteon> that's what CPP is for
22:11:49 <GeraldCode> carter I might have to look into that actually
22:11:50 <carter> and i think bitemyapp  will agree, never undersestimate the value of being able to do server side joints
22:12:01 <GeraldCode> my first job where I learned how to really code was with postgres
22:12:04 <carter> client side joins === the slows
22:12:06 <isomorpheous> trap_exit: http://www.haskell.org/cabal/users-guide/developing-packages.html#configurations
22:12:12 <trap_exit> rwbarton: cpp = standard haskell way to do conditional compilation?
22:12:16 <joelteon> yes
22:12:22 <GeraldCode> carter, yeah,  you see I dont think I would use mongo normally
22:12:28 <carter> GeraldCode: otoh, i'm an evil person planning to try to write a DB next year :)
22:12:29 <GeraldCode> this one project lends itself to that
22:12:31 <rwbarton> trap_exit, yes
22:12:41 <trap_exit> rwbarton: noted, thanks
22:12:41 <GeraldCode> but normally I dont really see why one  would use documents
22:12:47 <carter> fair
22:12:51 <GeraldCode> carter, oh? what type of db??
22:13:02 <carter> nb: i'm not sure if you can do nested kv structure with hstore
22:13:12 <carter> GeraldCode: i've a crazy way to maybe support ALL the things
22:13:20 <carter> DB as a library
22:13:36 <carter> your db app is "monomorphic" over its schema
22:13:57 <GeraldCode> oh wow
22:14:05 <GeraldCode> can you explain that a bit?
22:14:05 <carter> a "migration" is an application that talks with one life server at one schema, and builds up / updates the storage set for the new schema
22:14:17 <carter> which bit?
22:14:27 <carter> theres quite a few
22:14:27 <GeraldCode> you just did
22:14:28 <GeraldCode> :)
22:14:57 <GeraldCode> you really are talking kind of above me though I must say
22:15:09 <carter> which part do you want me to sketch?
22:15:12 <GeraldCode> I don't really do much on theory, just practice
22:15:17 <carter> who saidtheory?
22:15:20 <carter> this is all applied
22:15:23 <GeraldCode> ok
22:15:30 <carter> codes not theory
22:15:32 <GeraldCode> I dont even know what a "life server" is
22:15:34 <simcity2000> GeraldCode: the cynical answer is laziness re: why people use documens
22:15:36 <carter> *live server
22:15:36 <GeraldCode> is that a live server?
22:15:38 <carter> typo
22:15:41 <GeraldCode> ok
22:15:44 <carter> assume typoes
22:15:47 <carter> not made up words :)
22:15:51 <carter> well,  i do that too
22:15:52 <simcity2000> documents*
22:15:52 <carter> eg
22:15:53 <GeraldCode> simcity, maybe you are right
22:15:57 <GeraldCode> I was under pressure
22:15:59 <carter> @google innercontiguous
22:16:00 <lambdabot> http://www.wellposed.com/examples-cached/Numerical-Array-Layout-Base.html
22:16:00 <lambdabot> Title: Numerical.Array.Layout.Base
22:16:02 <carter> and you'll find my lib
22:16:03 <GeraldCode> and I wanted to not think about my DB
22:16:08 <carter> sorry
22:16:09 <carter> :)
22:16:16 <simcity2000> the less cynical answer is that sometimes you really do just have a massive collection of, well, documents
22:16:19 <GeraldCode> so I chose Mongo and built a lib that will generate the proper HTML, JS, and DB code in MOST cases
22:16:25 <carter> @google compressedsparesrowContiguous
22:16:26 <lambdabot> No Result Found.
22:16:30 <GeraldCode> ah ok carter
22:16:37 <carter> @google compressedsparserow
22:16:38 <lambdabot> http://en.wikipedia.org/wiki/Sparse_matrix
22:16:38 <lambdabot> Title: Sparse matrix - Wikipedia, the free encyclopedia
22:16:41 <carter> @google compressedsparserowcontiguous
22:16:42 <lambdabot> No Result Found.
22:16:53 <carter> @google compressed sparse row contiguous
22:17:00 <GeraldCode> simcity, /I dont work for a software house
22:17:08 <lambdabot> Plugin `search' failed with: <<timeout>>
22:17:10 <GeraldCode> I work for a company that does something else..I am support
22:17:17 <GeraldCode> so I dont get proper time to do things right
22:17:19 <carter> ooo, also aws has nice hosted postgres now
22:17:32 <carter> http://aws.amazon.com/rds/
22:17:45 <GeraldCode> But, that being said
22:17:51 <GeraldCode> I am kind of proud of what I did
22:17:57 <GeraldCode> because it DOES work
22:18:00 <carter> yay
22:18:12 <simcity2000> GeraldCode: I mean, I use mongo myself and was tuned out for what you're using it for
22:18:13 <vamega1> Working things are pretty important.
22:18:22 <vamega1> More than I can say about my Snap app right now....
22:18:33 <simcity2000> and it works, and I got it running quickly, and it's worked without issue since
22:19:01 <carter> simcity2000: whats your workload?
22:19:02 <GeraldCode> ah right
22:19:07 <carter> honestly i should be asknig about that ;)
22:19:28 <simcity2000> carter: workload in hours or workload for the server?
22:19:33 <simcity2000> well, servers
22:19:48 <carter> db workload
22:19:55 <carter> whats the query / read / write etc
22:20:15 <simcity2000> fairly low right now since it's just in pilot
22:20:18 <simcity2000> 0 write, all read
22:21:00 <GeraldCode> vamega1, I am researching frameworks/libs..whats wrong with yorur app?
22:21:24 <simcity2000> carter: if you're about to say mongo sucks for read-heavy work I'm all ears
22:21:40 <carter> what types of queries?
22:22:02 <isomorpheous> What's everyone's favorite database library
22:22:16 <simcity2000> carter: simple lookups--db.coll.find({"some_id": [1,2,3]})
22:22:20 <carter> hrm
22:22:40 <carter> lookup by primary key or secondary index?
22:23:08 <simcity2000> the former in general, sometimes the latter when I feel like pulling the docs down to run various tasks on them
22:23:20 <vamega1> GeraldCode: well it's hard to say somethings wrong if nothings working.
22:23:30 <vamega1> I just started trying to learn snap.
22:23:37 <vamega1> And it seemed to be going pretty well.
22:23:50 <vamega1> I thought I was getting the hang of Heist.
22:23:52 <carter> simcity2000: what dataset size?
22:24:02 <simcity2000> carter: ~30mil docs
22:24:11 <vamega1> And then once I moved from the barebones template to the default template.
22:24:12 <carter> how big is each doc?
22:24:21 <carter> like, how big would it be in memory?
22:24:21 <simcity2000> multiple paragraphs of text in the worst case
22:24:22 <vamega1> And started dealing with snaplets, things got a little more confusing.
22:24:26 <GeraldCode> vamega1,  I see
22:24:32 <GeraldCode> did you have cabal hell?
22:24:32 <simcity2000> hmm
22:24:35 <GeraldCode> or some other issue
22:24:42 <vamega1> GeraldCode: No cabal hell.
22:24:46 <GeraldCode> k
22:24:50 <vamega1> Sandboxes solved that a while ago for me.
22:24:55 <GeraldCode> kk
22:25:09 <vamega1> I just don't know the framework, and just started learning it.
22:25:44 <GeraldCode> ah ok
22:25:47 <simcity2000> carter: what're you pointing towards?
22:25:58 <GeraldCode> vamega1,  I am where you are ..but you are bit farther maybe
22:26:17 <carter> simcity2000: depending on the work load, a DB can just be a persistence store
22:26:21 <GeraldCode> vamega1, I keep going back and forth between learning yesod - snap - or trying to roll my own thing and using fcgiu
22:26:24 <GeraldCode> fcgi*
22:26:49 <GeraldCode> the last will be hardest
22:26:52 <vamega1> I'm not sure why you'd use FCGI.
22:26:57 <GeraldCode> but I will learn so much, but I dont have time
22:27:02 <simcity2000> carter: right, like a relational DB?
22:27:04 <vamega1> I mean if you're rolling your own start with WAI, or something else.
22:27:11 <carter> and when you start the application, you can load it into memory for fast lookups
22:27:16 <vamega1> Really no need to use something behind FCGI here.
22:27:19 <GeraldCode> vamega1, well, if I want to roll my own, I dont have enough knowledge to make my own web server
22:27:20 <trap_exit> oh osx
22:27:22 <trap_exit> on osx
22:27:23 <GeraldCode> so what else would I do?
22:27:26 <trap_exit> how do I do gui stuff in haskell ?
22:27:40 <vamega1> GeraldCode: I just figured out my issue.
22:27:44 <carter> @hackage threepenny-gui
22:27:44 <lambdabot> http://hackage.haskell.org/package/threepenny-gui
22:27:50 <vamega1> It was part of the boilerplate code that was generated for me.
22:27:50 <GeraldCode> what was the issue
22:27:59 <GeraldCode> I am logging my chats for future reference :)
22:28:03 <GeraldCode> oh
22:28:09 <GeraldCode> can you tell me details please
22:28:12 <vamega1>     h <- nestSnaplet "" heist $ heistInit "templates"
22:28:20 <vamega1> That line of code was part of the app function.
22:28:40 <vamega1> I was trying to bind the / route to "Bar"
22:28:48 <GeraldCode> ok
22:28:55 <GeraldCode> you know what man...
22:29:07 <GeraldCode> sometimes just talking about your problem frees your mind and your subconscious solves it
22:29:09 <vamega1> but since the nestSnaplet function was binding it first, it was loading the template instead of my static string.
22:29:11 <GeraldCode> happens to me all the time
22:29:21 <vamega1> Stackoverflow did that for me.
22:29:25 <GeraldCode> oh :)
22:29:33 <vamega1> Was writing up a question, and halfway through figured it out.
22:29:39 <GeraldCode> same thing though
22:30:55 <GeraldCode> vamega1,  what kind of app areyou making?
22:31:01 <GeraldCode> and why did you choose haskell to make it?
22:32:30 <trap_exit> threepenny gui is awesome
22:32:32 <kwos> is it possible to enable compilation of my own executables when --enable-tests is given to cabal configure?
22:32:55 <kwos> I have a bunch of "test" apps, that I'd love to enable together with other proper test suites... is that possible?
22:33:14 <vamega1> I'm making a web app to track chores between me and my roomates.
22:33:23 <GeraldCode> lmao I love it
22:33:27 <vamega1> And I'm just reimplementing something I already have in haskell.
22:33:44 <vamega1> Simplest app ever.
22:33:52 <GeraldCode> cool
22:34:03 <GeraldCode> but why haskell?
22:34:10 <kwos> LOL!?
22:34:11 <vamega1> Currently written in python, and runs on a raspberry pi taped under our couch.
22:34:13 <GeraldCode> you do that with less pain I aimagine in PHP
22:34:16 <kwos> because it's the best language there is!
22:34:29 <GeraldCode> oh
22:34:30 <carter> vamega1: compiled == less cpu on the rpi
22:34:32 <carter> ?
22:34:38 <vamega1> carter: nope.
22:34:44 <carter> funsis?
22:34:46 <carter> *funsies?
22:34:46 <vamega1> I just wanted to learn how to do Haskell Web dev.
22:34:49 <carter> cool
22:34:51 <GeraldCode> cool!
22:34:52 <vamega1> cater: +1
22:35:03 <isomorpheous> vamega1: that's still up for debate
22:35:19 <vamega1> isomorpheous: what's still up for debate?
22:35:23 <kwos> I quite like yesod for heavy lifting... I can't imagine implementing a lot of the scaffolding it give you by hand
22:35:30 <carter> like what
22:35:33 <kwos> it makes web dev suck less than it used to
22:35:41 <isomorpheous> vamega1: how to do web dev in Haskell
22:35:41 <vamega1> kwos: I'm looking to implement this in Haskell next.
22:36:10 <vamega1> isomorpheous: I doubt there will ever be "one true way" for doign web dev.
22:36:26 <kwos> carter: things like i18n, configuratio, nice integration with templating engines, etc
22:36:27 <marchelzo_> kwos: have you tried rails?
22:36:38 <kwos> marchelzo_: I don't want to get anywhere near Ruby ;)
22:36:41 <vamega1> I think a range approaches that make different tradeoffs will exist.
22:36:49 <marchelzo_> kwos: fair enough :)
22:36:51 <octopuscabbage> what does ||| mean in a function declaration?
22:37:02 <kwos> vamega1: agree... there is like 1000 ways to do anything in web apps
22:37:09 <octopuscabbage> oh i guess it's just a function istself, i should ask what does it mean in terms of xmonad
22:37:35 <kwos> vamega1: you could for intance build an entirely RESTful interface and stick a GUI written in something like clojurescript on top of it
22:37:48 <kwos> vamega1: or python for that matter
22:37:53 <vamega1> octopuscabbage: It's a function used to compose layouts
22:37:57 <vamega1> If you open up ghci
22:38:01 <vamega1> And do :t (|||)
22:38:12 <vamega1> You'll see that the function takes two layouts, and returns a choice of the two
22:38:31 <kwos> vamega1: but most of the time you just want simple forms and some static content LOL
22:38:36 <kwos> vamega1: so it's important to mix and match
22:39:07 <vamega1> Yeah, I do web dev for a living unfortunately.
22:39:15 <GeraldCode> me too vamega1
22:39:20 <GeraldCode> Whats your language?
22:39:25 <vamega1> Ahh a mash of things.
22:39:29 <GeraldCode> I am doing PHP...great job actually..good salary
22:39:29 <vamega1> A lot of Java.
22:39:31 <GeraldCode> and I am the boss
22:39:40 <GeraldCode> but, I am under pressure from the real boss
22:39:40 <vamega1> I'm mostly doing Java.
22:39:44 <GeraldCode> I want a better language
22:39:50 <GeraldCode> ok cool
22:39:53 <vamega1> Which I much prefer to python which is what I used to write in.
22:40:00 <GeraldCode> I did Java early on
22:40:02 <vamega1> I like types.
22:40:04 <GeraldCode> but not for web dev
22:40:11 <GeraldCode> PHP is the wosrt
22:40:19 <GeraldCode> dont ever take a PHP job unless you are making beaucoup $$$
22:40:34 <GeraldCode> otherwise you can be replaced very easily
22:41:05 <GeraldCode> I came into this place taking over for the people who did the previous work
22:41:08 <GeraldCode> it is pure crap
22:41:16 <GeraldCode> and I had to explain to management how much crap it is
22:41:18 <GeraldCode> they had no idea
22:41:27 <GeraldCode> anyone can do crap PHP and it "kind of " works
22:41:53 <GeraldCode> But to be fair, in my java days, I saw a  lot of crap there too
22:41:57 <GeraldCode> but nothing on this level
22:42:16 <prinsen> Is there any way to reinterpret values in haskell? Like some intermediary data type that can be casted to Int, Strings etc?
22:42:51 <vamega1> Anyone know if snap by default loads a file named index.tpl or something?
22:43:09 <kazagistar> prinsen: where did that data type come from? what is it going to be used for? your answers come from that
22:43:21 <GeraldCode> sorry I ranted there
22:43:43 <carter> prinsen: Data.Dynamic
22:43:59 <prinsen> carter: no that cant do reinterpretation
22:44:11 <prinsen> carter: I want to be able to cast String "1" to Int 1
22:44:11 <rwbarton> try acme-php
22:44:15 <GeraldCode> vamega1,  snap is template agnostic, so the answer is no right?
22:44:18 <kazagistar> prinsen: but I dont think you really want "casting". In haskell, we just convert, and don't try to have the compiler magically transform things into each other
22:44:22 <prinsen> ofc there is gonna be a Maybe there somewhere
22:44:41 <prinsen> kazagistar: Ill describe my case short
22:44:48 <vamega1> prinsen.
22:45:09 <vamega1> prinsen: is read what you're looking for.
22:45:22 <mwhit> prinsen: the function read (or better, readMaybe) is what you want
22:45:26 <mwhit> you convert, you don't "cast"
22:45:28 <vamega1> It'll take a string and convert it to a any instance of show.
22:45:30 <mwhit> :t readMaybe
22:45:31 <lambdabot> Not in scope: ‘readMaybe’
22:45:34 <mwhit> :t maybeRead
22:45:34 <lambdabot> Not in scope: ‘maybeRead’
22:45:36 <mwhit> err
22:45:49 <prinsen> let me describe the case
22:45:52 <vamega1> whit: I've never heard of readMaybe
22:45:58 <mwhit> definitely exists
22:46:04 <glguy> Text.Read
22:46:29 <mwhit> oh well
22:46:32 <jhon> visit this website www.SoccerTips4Sure.com i won nice money , they are very good
22:46:48 <kwos> vamega1: so it's important to mix and match
22:46:50 <swgillespie> wow, I've always wanted nice money
22:46:59 <kwos> oh unintended
22:47:11 <vamega1> GeralfCode: In theory I believe so.
22:47:25 <vamega1> But Heist is what snap seems to use in all the examples.
22:47:36 <trap_exit> anyone run into this problem when installing threepenny ? https://gist.github.com/anonymous/872f9e7be782540e490a
22:47:42 <GeraldCode> yeah I read the docs, its the preferred template engine
22:47:53 <GeraldCode> but I dont have enough experience to say if it defaults to that
22:48:00 <GeraldCode> I would like to think they would tell me if it did
22:48:02 <vamega1> I actually have come to sort of like it.
22:48:06 <vamega1> Doesn't default to anything.
22:48:09 <rwbarton> trap_exit: i'm guessing you are on a mac and using clang as your c preprocessor
22:48:23 <trap_exit> rwbarton: yes
22:48:24 <vamega1> In the end it seems to just write out bytestrings.
22:48:27 <trap_exit> rwbarton: how do I fix this?
22:48:34 <trap_exit> rwbarton: and how did you guess that?
22:48:37 <vamega1> So you could just do string concatenation if you really wanted to.
22:48:53 <vamega1> Or use hastache, or jinja2 templates if you wanted
22:48:58 <GeraldCode> yar
22:49:07 <vamega1> Or whatever rails uses if there is a haskell engine for it.
22:49:14 <trap_exit> rwbarton: ping ping ping :-)
22:49:24 <rwbarton> 99% of all c preprocessor issues are this issue
22:49:27 <vamega1> I like the logiclessness of Heist so far.
22:49:29 <GeraldCode> I keep hearing rails
22:49:35 <GeraldCode> is there some kind of haskell rails?
22:49:35 <rwbarton> I think ghc 7.8.3 fixes this maybe, I don't have a mac so I don't know first-hand
22:49:39 <GeraldCode> or am I imagining things
22:49:53 <trap_exit> I intalled haskell platform, whihc is 7.6.x
22:49:56 <trap_exit> how do I upgrade to 7.8.3
22:50:01 <trap_exit> is there a "cabal install latest ghc for me" ?
22:50:08 <GeraldCode> vamega1, I would like something like CodeIginiter maybe in Haskell
22:50:12 * hackagebot pandoc-lens 0.2.0 - Lenses for Pandoc documents  http://hackage.haskell.org/package/pandoc-lens-0.2.0 (BenGamari)
22:50:14 <dwcook> trap_exit, download binaries from here http://www.haskell.org/ghc/
22:50:24 <prinsen> I want the user to write transformations a -> b. To do this they have a Map String (a -> String) and for each field of b they would provide the key to use
22:50:28 <dwcook> trap_exit, no, cabal cannot upgrade GHC
22:50:28 <kazagistar> GeraldCode: no, that was a reference to the Ruby one, there are web frameworks in haskell though
22:50:31 <GeraldCode> or maybe Yii...which seems to abstract away alot of the tedium of between PHP -> JS/AJAX
22:50:51 <GeraldCode> kazagistar, yeah I am trying to find the one for me :)
22:50:56 <dwcook> trap_exit, it can upgrade itself, on the other hand. `cabal install cabal-install`, make sure $HOME/.cabal/bin is in your $PATH
22:51:00 <prinsen> This works great for String, but I want a solution that handles more types
22:51:17 <mwhit> prinsen: then every field of b needs an instance of Read
22:51:23 <GeraldCode> kazagistar,  I must say though, this is more involved than learning a web framework in any other language
22:52:03 <prinsen> mwhit: would you require every field of a to have and instance of Show and every field of be to have an instance of Read?
22:52:07 <GeraldCode> with Haskell's inate ability to make DSLs, this should be easier ..
22:52:12 <trap_exit> bah, someone need to release a haskell platform with 7.8.x
22:52:14 <prinsen> mwhit: And have String to be the intermediate representation?
22:52:15 <trap_exit> would simplify my life greatly
22:52:21 <rwbarton> it's due soon
22:52:37 <rwbarton> anyways I'm sure there is some other workaround, I just don't know what it is off-hand, search around
22:52:45 <mwhit> prinsen: if you want String as an intermediate representation, then yes. there's probably a better way to do it, though, depending on your exact use case
22:52:47 <prinsen> mwhit: Might be a good solution, was wondering if there was any specialized library
22:52:48 <GeraldCode> maybe thats what I should do!
22:53:02 <GeraldCode> I should learn haskell by trying to create an actually easy to use web framework
22:53:15 <mwhit> GeraldCode: i for one would love you for it
22:53:22 <GeraldCode> :)
22:53:27 <prinsen> mwhit: well the case above but that manages reinterpretation between String, Int, Double basically
22:53:55 <prinsen> GeraldCode: Yesod?
22:53:57 <mwhit> and lucky for you, all those already have read instances
22:54:05 <mwhit> Yesod is arguably terrible
22:54:19 <prinsen> why? :)
22:54:26 <GeraldCode> prinsen, I am not saying yesod is hard..Im saying you can learn enough PHP to make production in 2 days
22:54:31 <GeraldCode> enough c# to do it in a week
22:54:36 <GeraldCode> you need more time for yesod
22:54:44 <kazagistar> prinsen: while there is a somewhat nice way to do it, but it sounds like a really bad idea
22:55:00 <prinsen> GeraldCode: yes but with PHP you will have bugs for 1 month
22:55:07 <GeraldCode> How about a DSL for haskell that makes web development easier in 90% of cases?
22:55:14 <GeraldCode> prinsen yes lol
22:56:49 <kazagistar> prinsen: you could use "convertable" from hackage, but I also suspect that you are making a design mistake
22:57:31 <mwhit> yeah if you're trying to move through some intermediate string representation between types you're defining yourself, you're probably Doing Types Wrong
22:57:37 <prinsen> kazagistar: Surly, I will notice sooner or later
22:58:12 <kazagistar> prinsen: no, you might not, and you might end up reimplementing the worst ideas of PHP and Javascript and whatnot in haskell for no reason
22:58:19 <prinsen> mwhit: But how would you solve letting users define a -> b transformations at runtime?
22:58:42 <mwhit> what are a and b? why are these transformations defined at runtime?
22:58:52 <prinsen> mwhit: have you used IFTTT?
22:59:16 <kazagistar> prinsen: why do you think users need to do a -> b transformations at runtime? what is the purpose of that?
22:59:17 <prinsen> its a web site that lets you say: Whenever i get an email, post its content on my facebook wall
22:59:26 <prinsen> kazagistar: ^
22:59:50 <prinsen> I have written a framework in were I can define these "connections" in code
23:00:01 <prinsen> but I want to be able to create them at runtime
23:00:23 <prinsen> Or I have to use something like Hint
23:00:58 <kazagistar> that sounds like you have a bunch of connection objects and are composing them, I still dont see where haskell type conversions come in to play
23:01:12 <kazagistar> ill leave this to you guys, gotta go
23:06:42 <vamega1> Yep, I'm off to bed now.
23:14:01 <sjouke> where would you find more information on the formulae-as-types correspondence in lambda calculus?
23:14:23 <sjouke> in particular, i'm curious how polymorphic types are formed
23:14:45 <trap_exit> on osx
23:14:48 <sjouke> ..within typed lambda calculus, i'm not sure if i'm talking about simply typed lambda calculus
23:14:49 <trap_exit> how do I remove haskell platform?
23:14:56 <trap_exit> I installed 7.8.3, but ghc still points to 7.6.3
23:15:00 <trap_exit> I'd like to remove the entireity of my haskell platform
23:15:36 <prooftechnique> trap_exit: sudo /Library/Haskell/uninstall_hs or something like that. Hang on, I'll look up the actual incantation
23:15:38 <sjouke> trap_exit: http://www.haskell.org/haskellwiki/Mac_OS_X#Mac_OS_X_10.6_.28Snow_Leopard.29_and_10.7_.28Lion.29
23:15:39 <GeraldCode> trap_exit, you installed them under different users?
23:15:40 <GeraldCode> linux?
23:15:52 <trap_exit> same user
23:15:52 <trap_exit> osx
23:16:02 <GeraldCode> oh
23:16:08 <sjouke> trap_exit: look at that wiki pages, it should have an answer for you
23:16:50 <prooftechnique> trap_exit: Also, make sure to update your path to point to where you installed ghc-7.8.3
23:17:42 <sjouke> how do yoThis helps
23:17:53 <sjouke> This helps: "Whereas simply typed lambda calculus has variables ranging over functions, and binders for them, System F additionally has variables ranging over types, and binders for them. "
23:18:14 <trap_exit> prooftechnique, sjouke, GeraldCode: it worked, thanks!
23:18:29 <sjouke> trap_exit: congrat
23:18:33 <GeraldCode> good
23:18:40 <GeraldCode> Godo outcomes make everyone happy
23:18:53 <trap_exit> virtual round of beer for everyone!
23:19:11 <trap_exit> except you can't drink, since haskell is pure and drinking changes state
23:19:14 * sjouke needs to figure out what types are in system f
23:19:18 <GeraldCode> lol
23:19:20 <GeraldCode> I like that
23:19:32 <trap_exit> or: the beer isn't created until you try to drink it, since haskell is lazy
23:19:58 <trap_exit> okay, so I have ghc 7.8.3, but not cabal
23:20:05 <trap_exit> how do I install cabal manually?
23:20:07 <sjouke> \x -> x + x -- i'm not sure what type this would be
23:20:15 <GeraldCode> no idea
23:20:20 <sjouke> :t \x -> x + x
23:20:20 <trap_exit> Num a => a -> a ?
23:20:21 <lambdabot> Num a => a -> a
23:20:24 <trap_exit> woot
23:20:31 <GeraldCode> does max have something like apt-get in debian?
23:20:35 <GeraldCode> mac*
23:20:38 <randen> trap_exit: it should be there in the 7.8.3 install tree somewhere
23:20:43 <sjouke> GeraldCode: brew
23:20:51 <GeraldCode> oh
23:21:03 <GeraldCode> propbably should use "brew" hen yes?
23:21:11 <prooftechnique> trap_exit: Use this: http://ghcformacosx.github.io
23:21:13 <sjouke> sure
23:21:22 <prooftechnique> Definitely the best way to get a minimal stack set up
23:21:31 <sjouke> GeraldCode: "homebrew osx" is what you want to google for
23:21:41 <GeraldCode> ah
23:21:43 <prooftechnique> ghc should not be installed through homebrew, though
23:21:45 <swgillespie> system f is undecidable without explicit type annotations, right?
23:21:54 <prooftechnique> There's no maintainer for the package, really
23:21:55 <GeraldCode> sjouke,  I did some dev on mac at my last job...fortunately I dont do that anymore
23:22:08 <GeraldCode> but I was trying, in my lamest attempt, to help this fellow out
23:22:09 <sjouke> GeraldCode: oh, you are trying to install haskell, i'm sorry for not understanding what you were doing first :P
23:22:11 <GeraldCode> if at all possible
23:22:30 <GeraldCode> I no longer deal with mac
23:22:37 <GeraldCode> frankly I dont see the point..sorry to be off topic
23:22:52 <GeraldCode> but if you want to go that way, why not get a windows machine..and put linux as a VM guest on it
23:22:53 <trap_exit> bah, I'm badass
23:22:55 <randen> trap_exit: I'm Windows; he's osx but see if cabal is here: /usr/local/haskell-platform/2014.2.0.0/lib/cabal-install-1.18.0.5/bin/cabal
23:22:55 <randen>  
23:22:56 <trap_exit> I'm goign to run cabal/bootstrap.sh
23:23:04 <GeraldCode> tr you be da boss mang
23:23:10 <GeraldCode> trap_exit,  you be da boss mang
23:23:20 <prooftechnique> trap_exit: I really recommend http://ghcformacosx.github.io
23:23:25 <prooftechnique> It's much easier to upgrade and maintain
23:23:30 <trap_exit> GeraldCode: you are wise
23:23:47 <trap_exit> prooftechnique: it's alright, only 2 packages
23:24:37 <prooftechnique> Easier than dropping a .app in Applications and pointing your path at it?
23:25:41 <sjouke> for all a.a -> a -> a -- a boolean type (a being a type variable)
23:25:46 <sjouke> thank you internets
23:26:06 <trap_exit> blah
23:26:16 <trap_exit> Setup: Unrecognised flags: /Applications/Xcode6-Beta2.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld
23:26:51 <trap_exit> prooftechnique: "I told you so." :-)
23:26:58 <prooftechnique> Yeesh, I'm gonna have to go and muck around with that bootstrap.sh code again
23:27:38 <trap_exit> prooftechnique: you contribute to cabal-install ?
23:28:02 <GeraldCode> arent things generally easier by just installing a linux vm?
23:28:05 <prooftechnique> I ran into a similar issue last year and ended up submitting a fix because it wasn't catching ld on OSX due to naming conventions in /tmp and a regex in bootstrap.sh
23:28:34 <prooftechnique> It eventually got fixed, but Xcode 6 must have introduced more wonkiness :/
23:28:47 <prooftechnique> GeraldCode: No, they are not.
23:29:01 <GeraldCode> prooftechnique,  ok
23:29:17 <sjouke> (a -> (a -> a)), strange ,i would have read that as ((a -> a) -> a)
23:29:20 <prooftechnique> Now, NixOS, on the other hand...
23:29:46 <mzero> anyone doing ICFP contest?
23:29:51 <GeraldCode> prooftechnique,  even with the latest haskell platform, I had many issues on windows
23:29:51 <trap_exit> well this is clear
23:30:00 <trap_exit> I can download pre-built ghc
23:30:03 <tac> It's a little unfortunate the arrows don't read a <- a <- a instead :)
23:30:06 <prooftechnique> GeraldCode: Windows is a tricky platform
23:30:07 <trap_exit> or I can downgrade to xcode5
23:30:11 <GeraldCode> I didnt really try doing it in cygwin, but I would bet Id still have problems
23:30:15 <mzero> GeraldCode: you tried the Release Candidate?
23:30:18 <trap_exit> I'm goign to choose to downgrade to xcode5
23:30:23 <GeraldCode> I know mac is posix and and close to linux
23:30:24 <GeraldCode> but still
23:30:31 <prooftechnique> The devs are working on it, there just aren't enough people who know the Windows internals working on it.
23:30:45 <prooftechnique> trap_exit: http://ghcformacosx.github.io
23:30:47 <GeraldCode> mzero, I am not sure, I got the latest a few months back
23:30:49 <mzero> trap_exit: what was the Xcode issue? Xcode 6 beta isn't working?
23:30:50 <GeraldCode> then quickly gave up
23:30:55 <GeraldCode> installed LUBUNTU
23:30:55 <prooftechnique> Should be totally transparent, and won't care about your Xcode (maybe)
23:30:59 <sjouke> umkay, no feedback on the lambda stuff, i'll mozy my way out of here :)
23:31:04 <sjouke> gn everyone
23:31:18 <mzero> GeraldCode: ah, k' ther was a release candate 2 days ago - final release expected next week
23:31:40 <trap_exit> prooftechinque: I'm goign to figure out how to build this
23:31:41 <mzero> trap_exit: are you having clang issues?
23:31:42 <trap_exit> even if it'st he last thign I do
23:31:48 <trap_exit> mzero: yes
23:32:23 <mzero> okay - with 7.6.3, the ghc-clang-wrapper should solve 'em... with 7.8.x, itf the problem is haddock....
23:32:35 <mzero> ... the RC candidate from two days ago should solve it
23:32:40 <prooftechnique> trap_exit: It's really not hard, it's just time-consuming and not great for maintenance
23:32:59 <prooftechnique> I used to do it, myself, but then someone automated it :)
23:33:19 <prooftechnique> mzero: Oh, is that fixed now? Neat
23:33:38 <mzero> which "it" are we talking about? THe haddock / clang issue?
23:34:29 <prooftechnique> Yeah
23:35:13 <prooftechnique> The first bug I ever reported (though I reported it to the Haddock trac, then it got shuffled around rather a lot :D )
23:35:16 * hackagebot messagepack-rpc 0.1.0.0 - Message Pack RPC over TCP  http://hackage.haskell.org/package/messagepack-rpc-0.1.0.0 (rodrigosetti)
23:35:29 <mzero> yes - it was a bug in Cabal, which was causing CPP pre-processing to happen twice. I back-ported the fix which was already in mainline to 1.18, and it was pushed as 1.18.1.4 -- which will be in HP for Mac OS X...
23:35:35 <mzero> (and is in the RC put up)
23:35:50 <lispy> mzero: thanks
23:36:09 <mzero> tracking that down was a bear!
23:36:14 <lispy> I bet
23:36:17 <lispy> mzero++
23:36:19 <prooftechnique> Sweet. Just caught up with the github issues
23:36:21 <prooftechnique> mzero++
23:36:37 <mzero> :-)
23:37:06 <mzero> yeah - that bug would eventually bite us all on other platforms, I'm sure
23:39:10 <prooftechnique> Glad you figured it out, though. Motivates me to get more familiar with the internals of Cabal. That minimal case is pretty neat, too. I had zero idea how to reduce the problem, at all.
23:51:43 <trap_exit> well
23:51:45 <trap_exit> I haven't installed cabal-install
23:51:50 <trap_exit> but I've throughoutly broken my xcode too
23:54:44 <GeraldCode> see I dont understand how you do anything without cabal-install
23:54:48 <GeraldCode> I am naive :)
