00:00:03 <jle`> anyways, if we generalize that to something that takes into account both the timestep and the input, we can do the integral wire
00:00:07 <zq> meh
00:00:10 <zq> :t Wire
00:00:11 <lambdabot> Not in scope: data constructor ‘Wire’
00:00:24 <jle`> integral x0 = mkSF (\dt v -> (x0, integral (x0 + dt * v)))
00:00:31 <systemfault> Iceland_jack: Ah ok :) higher-order type operators seem “advanced” :)
00:00:35 <solidus-river> i'm working at a game studio, and i've been talking about the frp / haskell stuff i've been doing with our engine developer and he's excited / helped me flesh it out way more
00:00:40 <Iceland_jack> A bit yes
00:00:45 <solidus-river> so i hope i can finish this up soon and show it
00:00:51 <zq> do people actually use frp?
00:00:51 <jle`> in netwire, the first parameter isn't actually the straight up dt/Double; it's actually a type that contains the timestep
00:00:57 <jle`> zq: yes :)
00:01:05 <Iceland_jack> systemfault: but Haskell effectively only has three 'levels': terms, types and kinds
00:01:21 <jle`> what is next?
00:01:30 <solidus-river> jle`: but within a wire we can use it as a dt/Double safely?
00:01:34 <jle`> what contrasts * from the "kind-level" (->) ?
00:01:41 <jle`> solidus-river: no, you have to extract it out
00:01:50 <jle`> it's just a weird layer of abstraction
00:01:56 <solidus-river> aren't there kinds of kinds though and an extension that adds families / classes of kinds
00:02:01 <jle`> it's a simple function
00:02:17 <jle`> solidus-river: the function is dtime
00:02:22 <solidus-river> so given a dt how do i actually extract the dt and the next state of the dt generator to give to my wired
00:02:24 <Iceland_jack> solidus-river: yes, GHC is nudging towards a much richer hierarchy
00:02:25 <solidus-river> *wire
00:02:42 <alpounet> we can promote data types to kinds
00:02:43 <jle`> so integral x0 = mkSF (\ds -> v -> (x0, integral (x0 + (dtime ds) * v)))
00:02:59 <Iceland_jack> 7.10 aims to allow you to promote GADTs as well
00:03:01 <jle`> dtime :: s -> dt
00:03:11 <Iceland_jack> and there are also kinds such as # and Constraint
00:03:13 <solidus-river> other places i see them do something like
00:03:27 <Iceland_jack> so there is more to it than meets the eye
00:03:29 <solidus-river> (s', dt) <- dtime s
00:03:37 <solidus-river> or something similar, is that a relic, or what are they doing there
00:03:45 <solidus-river> i only seem to see it in netwire < 5
00:03:46 <jle`> more explicitly, dtime :: HasTiime t s => s -> t     <--- t is your actual timestep type (like, Double), and s is your "timestep container"
00:04:09 <solidus-river> right, i keep forgetting i'm not passing the timestep to my next wire
00:04:15 <solidus-river> tahts the s monads job
00:04:21 <jle`> it's a weird level of abstraction and it's going away in the next iterations of netwire/wires
00:04:22 <solidus-river> er monoid
00:04:32 <jle`> solidus-river: actually, it's your job, when you "step"/"run" the wire
00:04:49 <solidus-river> jle`: so do i just pass it back s
00:04:56 <jle`> remember runWire is something like runWire :: Wire m a b -> dt -> a -> m b
00:05:00 <jle`> solidus-river: you don't need to pass back anything
00:05:00 <solidus-river> or do i have to somehow modify s to imply that a delta has been observed
00:05:11 <jle`> no, s is just the timestep, wrapped in a container
00:05:18 <jle`> you can pretend it's the timestep, it's for you to use in your function
00:05:24 <solidus-river> thats really wierd
00:05:29 <solidus-river> lol
00:05:38 <solidus-river> i guess so they didn't have to choose a concrete type for time
00:06:08 <jle`> yeah, it's going away :)  it's acknowledged as a mistake
00:06:33 <jle`> anyways, are you sure you know what everything in mkSF :: (s -> a -> (b, Wire s e m a b)) represents?
00:06:38 <jle`> what the (b, Wire s e m a b) is?
00:06:47 <jle`> b is just that "output" that you get when you run that wire
00:06:49 <jle`> it can be anything
00:06:51 <solidus-river> yeah, so s is the session, which takes care of dt's?
00:06:55 <jle`> it doesn't have to depend on the timestep at all
00:07:02 <solidus-river> so i guess i dont really understand s or e
00:07:03 <jle`> it can be anything arbitrary; the timestep is there for you
00:07:04 <solidus-river> i know e can inhibit
00:07:13 <solidus-river> but i've heard talk of spaceleaks on inhibiting wires
00:07:20 <solidus-river> does an inhibited wire never fire again?
00:07:20 <jle`> brb
00:07:29 <solidus-river> kk
00:08:55 * hackagebot cake3 0.5.1.0 - Third cake the Makefile EDSL  http://hackage.haskell.org/package/cake3-0.5.1.0 (SergeyMironov)
00:08:55 * hackagebot authoring 0.3.4 - A library for writing papers  http://hackage.haskell.org/package/authoring-0.3.4 (TakayukiMuranushi)
00:09:20 <solidus-river> also, i'm definitely not qualified to have an opinion on this, but it seems wierd that conduit is more heavily used than pipes (or seems to be)
00:09:27 <solidus-river> pipes looks like a more general library with the same functionality
00:10:10 <jle`> so in (b, Wire s e m a b), b is the "outpuot" of the wire, and the Wire s e m a b is the "next wire" you get.
00:10:30 <jle`> solidus-river: you read my stream/auto post right?
00:10:40 <solidus-river> jle`: neg i havent seen it
00:10:59 <echo-area> Hello, I was reading Real World Haskell chapter 2, which explains a self recursive invocation of a function.  The chapter explains it as a recursive manner.  Does Haskell have tail recursive optimization?
00:11:12 <jle`> oh, i was sort of talking assuming that you had.  i mean the machines/arrows post?
00:11:13 <solidus-river> is conduit better at managing / freeing up scarce resources?
00:11:22 <solidus-river> thats the only thing i'm thinking
00:11:34 <systemfault> jle`: Thanks for the article… Fun to understand that  fmap f functor = f <$> functor :)
00:11:36 <jle`> echo-area: actually, "tail recursive optimization" doesn't really have much meaning in haskell's evaluation module
00:11:38 <solidus-river> jle`: oh! yes, i have, i thought this was in reference to my pipes / conduit question
00:11:45 <jle`> solidus-river: ah yes :)
00:11:52 <jle`> er
00:11:56 <jle`> s/module/model
00:12:15 <echo-area> jle`: Is there no concept of stack at all?
00:12:30 <jle`> echo-area: have you had any experience wiht haskell's evaluation model?
00:12:39 <jle`> you can think of it like evaluation by substitution
00:12:52 <jle`> for example, map negate [1,2]
00:12:53 <jle`> @src map
00:12:54 <lambdabot> map _ []     = []
00:12:54 <lambdabot> map f (x:xs) = f x : map f xs
00:12:55 <solidus-river> which is how the rec magic works
00:13:35 <jle`> map negate [1,2] = map negate (1:2:[]) = negate 1 : map negate (2:[]) = -1 : negate 2 : map negate [] = -1 : -2 : [] = [-1,-2]
00:14:03 <jle`> echo-area: ^^, where is the "call stack" there?
00:14:28 <jle`> or how about take 2 [1..]
00:14:30 <jle`> @src take
00:14:30 <lambdabot> take n _      | n <= 0 =  []
00:14:30 <lambdabot> take _ []              =  []
00:14:30 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
00:15:13 <echo-area> I see
00:15:17 <jle`> take 2 [1..] = take 2 (1:[2..]) = 1 : take 1 (2:[3..]) = 1 : 2 : take 0 [3..] = 1 : 2 : [] = [1,2]
00:15:39 <jle`> solidus-river: in my post i describe a data Auto a b = ACons (a -> (b, Auto a b)), right?
00:16:03 <jle`> in the hypothetical part 2 i would have demonstrated "chaining" Autos
00:16:16 <jle`> that is, given an Auto a b and an Auto b c, create an Auto a c
00:16:31 <solidus-river> aye
00:16:39 <jle`> where the semantics are, feed the input into the first Auto, grab the output, feed that into the second Auto, grab that output, that's the final output
00:16:47 <jle`> and the final "new Auto" is the updated versions of both
00:17:03 <solidus-river> Auto's are a really cool idea, they feel a bit on the same level as a monad for monads that no one else has to care about but the function dealing with them
00:17:25 <jle`> it's subtle :)
00:17:37 <jle`> um
00:17:40 <jle`> ok
00:17:47 <jle`> so why don't you try implementing that (>>>) function
00:17:57 <jle`> (>>>) :: Auto a b -> Auto b c -> Auto a c
00:18:00 <jle`> and get back to me :)
00:18:05 <jle`> the i will explain the `e`
00:18:07 <jle`> and inhibition.
00:18:25 <jle`> it won't be hard, i promise :)
00:18:49 * hackagebot libmpd 0.8.0.5 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.8.0.5 (JoachimFasting)
00:20:55 <solidus-river> jle`: well, auto's compose safe, so isn't just . valid?
00:21:12 <jle`> i'm basically asking you to write flip (.)
00:21:22 <jle`> if you want you can go ahead and write the entire Category instance
00:21:31 <jle`> class Category c where
00:21:36 <jle`>     id :: c a a
00:21:54 <jle`>     (.) :: c b d -> c a b -> c a d
00:22:05 <solidus-river> so i understand what a monad gives you, what does a category give you on top of or aside from a monad
00:22:12 <jle`> they are different things
00:22:19 <solidus-river> i'm running into more places where people talk about instancing Category
00:22:55 <jle`> a Category instance for Auto will give you an "identity Auto", which pops out whatever is put in, unchanged
00:23:04 <matematikaadit> :t (Data.Composition..:.)
00:23:05 <lambdabot> Not in scope: ‘Data.Composition..:.’
00:23:14 <matematikaadit> @let import Data.Composition
00:23:14 <lambdabot>  .L.hs:69:1:
00:23:14 <lambdabot>      Failed to load interface for ‘Data.Composition’
00:23:14 <lambdabot>      Use -v to see a list of the files searched for.
00:23:16 <jle`> and it will also give you the ability to compose Auto's --- give an Auto a b and an Auto b c and turn it into an Auto a c
00:23:32 <jle`> there are three very familiar laws
00:23:47 <jle`> f . id = f
00:23:54 <jle`> id . g = g
00:24:04 <jle`> (f . g) . h = f . (g . h)
00:24:21 <jle`> they should evoke deeply buried memories
00:24:25 <jle`> but nevermind that for now :)
00:24:31 <jle`> just write the Auto instance
00:24:33 <jle`> :)
00:25:06 <solidus-river> heh, kk
00:25:27 <jle`> i'll start it for you, instance Category Auto where id = ACons (\x -> (?, ??) )
00:26:23 <jle`> solidus-river: this might help: data Auto a b = ACons { runAuto :: a -> (b, Auto a b) }
00:27:44 <solidus-river> id = ACons (\x -> (x, id))?
00:29:31 <codygman> I'm trying to use structured-haskell-mode and it is working fine, but autocomplete doesn't seem to be working. Auto-complete works with my .emacs file however.
00:31:57 <jle`> solidus-river: yup
00:32:02 <jle`> :)
00:33:14 <maybefbi> is using an IORef cheating? i've always felt guilty when i use it. is it like goto in imperative languages?
00:33:38 <chrisdotcode> anyone know how to use gitlib? I'm having trouble even opening a repository with `openRepository`...
00:33:39 <Iceland_jack> maybefbi: It can be used for a quick and dirty solution, but often times there is a nicer solution :)
00:33:48 <maybefbi> Iceland_jack, ok
00:34:01 <Iceland_jack> The author of QuickCheck talked about how using IORefs got him into trouble when trying to parallelize the testing
00:34:23 <Iceland_jack> and ended up founding a much better ‘pure’ solution later on
00:34:27 <Iceland_jack> *finding
00:34:51 <chrisdotcode> wait, I think the gitlib documentation is out of date
00:35:11 <chrisdotcode> the tutorial, at least
00:36:10 <solidus-river> jle`: http://lpaste.net/107039
00:36:12 <chrisdotcode> oh, guess I was right; there's a pull request about it.
00:36:16 <solidus-river> not sure if where would be better than a let there
00:36:22 <maybefbi> Iceland_jack, im tempted use IORef inside the function 'next' here: http://lpaste.net/107038 so as to save the max and min that need to passed to autoScale
00:36:24 <solidus-river> where might be more readable
00:37:13 <jle`> solidus-river: you can use runAuto
00:37:20 <Iceland_jack> ah maybefbi, maybe 'reflection' may be interesting to you?
00:37:21 <jle`> where would make it worse
00:37:36 <Iceland_jack> sounds like the configuration problem
00:37:37 <jle`> you need (.) for the instance, btw
00:37:41 <Iceland_jack> @hackage reflection
00:37:42 <lambdabot> http://hackage.haskell.org/package/reflection
00:38:05 <solidus-river> heh, wouldn't . just be (>>>)
00:38:13 <maybefbi> Iceland_jack, checking it out
00:38:23 <jle`> solidus-river: oh you did use runAuto
00:38:23 <solidus-river> er (.) be (>>>)
00:38:32 <jle`> yeah, `let` is the best way to do it :)
00:39:14 <jle`> (.) is (<<<)
00:39:19 <jle`> (>>>) is flip (.)
00:39:31 <jle`> @src (>>>)
00:39:31 <lambdabot> Source not found. My mind is going. I can feel it.
00:39:34 <jle`> poo
00:40:01 <maybefbi> Iceland_jack, max and min in my case aren't configuration constants. they are the max/min of the current init being processed inside the list of inits of a list
00:41:00 <Iceland_jack> maybefbi: reflection isn't just for constants, maybe I'm misunderstanding your problem
00:41:19 <maybefbi> Iceland_jack, ok i will read it fully then
00:41:22 <Iceland_jack> Why do you need to save the min/max values for?
00:41:25 <Iceland_jack> *What
00:41:48 <Iceland_jack> I also wonder why 'next' returns an IO Picture
00:42:06 <jle`> solidus-river: okay, now
00:42:10 <jle`> imagine an "inhibiting Auto"
00:42:11 <Iceland_jack> since it's pure save for the 'return' at the end
00:42:35 <jle`> solidus-river: data IAuto a b = IACons (a -> (Maybe b, IACons a b))
00:43:00 <jle`> solidus-river: er, data IAuto a b = IACons { runIAuto :: a -> (Maybe b, IACons a b) }
00:43:01 <maybefbi> Iceland_jack, there are pure versions of animateIO called animate
00:43:20 <maybefbi> Iceland_jack, i will switch to pure once im sure i can do it without IOref inside next
00:43:24 <jle`> solidus-river: basically, instead of your Auto always producing a `b`, it produces a `Maybe b` --- it might make a Nothing instead :)
00:43:34 <Iceland_jack> maybefbi: (btw if you have many 'let's in a do-notation you only need one)
00:43:34 <Iceland_jack>     let a, b:: Int
00:43:34 <Iceland_jack>         a = 5
00:43:34 <Iceland_jack>         b = 10	
00:43:39 <jle`> solidus-river: try writing the Category instance for this new type
00:43:43 <solidus-river> ah, so if its nothing it the Auto returned by runIAuto is the same
00:43:50 <maybefbi> Iceland_jack, will change that didnt know that
00:44:06 <solidus-river> so its still there but never does any real evaluation beyond the checking for nothing
00:44:14 <solidus-river> that would still hold a thunk around in the stack though, right?
00:44:15 <jle`> solidus-river: whatever intuition you have will be refined by actually writing the instance :)
00:44:38 <solidus-river> oh, thtas not the way it's actually done then?
00:45:13 <Iceland_jack> maybefbi: (in 'local definition'-heavy code I would be partial to writing it like this: not using do-notation):
00:45:14 <Iceland_jack>     next prices t = let
00:45:14 <Iceland_jack>       index = round (t * 1000.0)
00:45:14 <Iceland_jack>       _init = inits prices !! index
00:45:17 <Iceland_jack>       ...
00:45:20 <Iceland_jack>       in return ...
00:45:25 <Iceland_jack> I'm not sure why you write everything pointfree
00:45:56 <maybefbi> Iceland_jack, not exactly point free because the variable hasnt been eliminated
00:46:11 <Iceland_jack> That's right but you write the local bindings pointfree is what I meant
00:46:39 <maybefbi> okk i will change that
00:46:55 <solidus-river> jle`: if (.) isnt just (>>>) that seems counter intuitive so the type of (.) would actually be
00:47:15 <solidus-river> (.) :: Auto a b -> Auto b c -> Auto c a
00:47:22 <solidus-river> oh, no that makes sense
00:47:26 <jle`> no, it's backwards
00:47:29 <jle`> like for functions
00:47:30 <jle`> :t (.)
00:47:31 <lambdabot> (b -> c) -> (a -> b) -> a -> c
00:47:37 <maybefbi> Iceland_jack, my problem right now is that lines 62 to 65 takes longer and longer to run as the program keeps running
00:47:44 <jle`> (f . g) x = f (g x)
00:48:01 <Iceland_jack> It's fine if you prefer the current style, I just don't see much benefit in
00:48:01 <Iceland_jack>              ((!! index) . inits) prices
00:48:01 <Iceland_jack> rather than: inits prices !! index
00:48:05 <jle`> solidus-river: try writing the Category instance for IAuto; there is really only one lawful implementation, I think
00:48:11 <Iceland_jack> maybefbi: I see
00:48:13 <maybefbi> Iceland_jack, ok
00:48:20 <jle`> let me think about it...
00:48:26 <jle`> yes
00:48:30 <jle`> there is only one lawful implementation
00:48:40 <jle`> (i say with some fair degree of certainty)
00:49:01 <maybefbi> Iceland_jack, im thinking of passing the maxs and mins as an argument. and calculate it inside the next like a monoid
00:49:18 <Iceland_jack> that would work
00:49:20 <maybefbi> using only the last of the init
00:49:36 <maybefbi> to update the monoid
00:50:05 <solidus-river> jle`: http://lpaste.net/107039 :P
00:50:17 <solidus-river> except the instance would have to be after >>>
00:50:29 <maybefbi> Iceland_jack, but i want a place to store the latest monoid. i was thinking of keeping it inside an IORef
00:50:37 <Iceland_jack> another issue is that 'minimum xs/maximum xs' need to traverse the list twice, retaining it in memory
00:50:56 <jle`> solidus-river: the order doesn't matter actually :)
00:50:59 <maybefbi> Iceland_jack, yeah so imagine a maxmin monoid that can calculate both
00:51:12 <maybefbi> Iceland_jack, inside the next function
00:51:19 <jle`> solidus-river: that doesn't typecheck though
00:51:27 <jle`> runAuto :: Auto a b -> a -> (b, Auto a b)
00:51:39 <maybefbi> but without an IORef that stores the monoids, when the next gets called another time, the monoids will be forgotten
00:52:04 <maybefbi> Iceland_jack, next gets called every time a new frame needs to be drawn
00:52:46 <Iceland_jack> Yes, if animateIO is in the IO monad already it's not such a huge deal to use IORefs
00:53:27 <solidus-river> jle`: wait, i dont get what part is wrong, the flip wouldn't work?
00:53:28 <maybefbi> Iceland_jack, yeah but my love of purity drives me to wonder if there is way to not use IORefs
00:53:56 <solidus-river> oh, is it becaue i'm not returning an Acons
00:53:56 <jle`> solidus-river: let (ab, autoa') = runAuto a
00:53:57 <Iceland_jack> so it depends a bit on how animateIO is implemented, since that's the function that keeps calling 'next'
00:54:03 <solidus-river> er Auto
00:54:09 <jle`> solidus-river: runAuto's first argument is an Auto a b, not an a
00:54:22 <jle`> also i recommend you use variable names for your data that don't match with your types :) \x -> ...
00:54:39 <Iceland_jack> If you say, returned the next state as the state monad does 'animate{,IO}' would have to pass it to the next ‘next’ invocation
00:55:24 <maybefbi> Iceland_jack, hmm i dont know. i guess i should use gloss-game
00:55:42 <maybefbi> @hackage gloss-game
00:55:42 <lambdabot> http://hackage.haskell.org/package/gloss-game
00:55:54 <alpounet> gloss also has a Game module
00:55:57 <alpounet> with play/playIO
00:56:07 <jle`> solidus-river: 9also instance is lowercase)
00:56:17 <solidus-river> why doesnt it type check, does it not like the match of (x', autoa' to (b, Auto a b)
00:56:33 <maybefbi> alpounet, hmm should use that then
00:56:39 <jle`> solidus-river: you write runAuto a
00:56:45 <jle`> or i guess runAuto x
00:56:49 <jle`> but runAuto takes an auto and an input
00:57:13 <solidus-river> oh, so i have it defined wrong in the paste
00:57:42 <jle`> ah, yeah.
00:57:42 <gamegoblin> Is there any way to make IO a little less general? That is, define a function like “this function outputs an IO action, but that action can only involve stdin and stdout”
00:57:58 <gamegoblin> Sounds a bit like dependant typing, though
00:57:59 <jle`> gamegoblin: you can make your own "IO monad"...which is an approach some people take
00:58:23 <Iceland_jack> gamegoblin: yes it is!
00:58:37 <Iceland_jack> I wrote a proof of concept library for that
00:58:37 <Iceland_jack> @hackage capabilities
00:58:37 <lambdabot> http://hackage.haskell.org/package/capabilities
00:58:37 <solidus-river> http://lpaste.net/107039
00:58:52 <Iceland_jack> but apart from that you can quite easily make a restricted monad like jle` suggested
00:59:03 <Iceland_jack> @hackage Capabilities
00:59:03 <lambdabot> http://hackage.haskell.org/package/Capabilities
00:59:18 <maybefbi> Iceland_jack, im going to use Graphics.Gloss.Interface.IO.Game which is better than Graphics.Gloss.Interface.IO.Animate. It has a way to keep track of an abstract model of the world, which can store these maxes and mins
01:00:19 <Iceland_jack> gamegoblin: You define
01:00:19 <Iceland_jack>     newtype StdoutIO a = Stdout { runStdoutIO :: IO a } deriving Monad
01:00:19 <Iceland_jack>     myPutChar :: Char -> StdoutIO ()
01:00:19 <Iceland_jack>     myPutChar c = Stdout (putChar c)
01:00:27 <Iceland_jack> and then don't export the 'Stdout' constructor
01:00:42 <knapper_tech> http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/
01:00:49 <gamegoblin> huh. Gotcha.
01:00:50 <Iceland_jack> now you can define
01:00:50 <Iceland_jack>     myPutStr :: Char -> StdoutIO ()
01:00:50 <Iceland_jack>     myPuStr = mapM_ myPutChar
01:00:51 <knapper_tech> I'm down here at the type declaration for BinTree
01:01:02 <knapper_tech> I don't get the guard looking syntax.  What was this?
01:01:07 <Iceland_jack> *myPutStr
01:01:31 <Iceland_jack> knapper_tech: Do you mean
01:01:31 <Iceland_jack>     guard $ 4*x + 2*y < z
01:01:32 <pjdelport> knapper_tech: That's not actually a guard, it's just an alternative.
01:02:09 <pjdelport> knapper_tech: It's just: data BinTree a =  Empty | Node a (BinTree a) (BinTree a)
01:02:09 <Iceland_jack> gamegoblin: Then you can use the usual do-notation to combine actions and run them with runStdoutIO :: StdoutIO a -> IO a
01:02:21 <pjdelport> knapper_tech: You can read the | as "or"
01:02:48 <knapper_tech> pjdelport: what is actually declared?  A type?
01:02:50 <Iceland_jack> ah
01:02:59 <Iceland_jack> knapper_tech: A type and constructors
01:03:05 <Iceland_jack> (and destructors)
01:03:08 <knapper_tech> a is the type variable?
01:03:18 <Iceland_jack> Yes
01:03:43 <knapper_tech> got it
01:03:44 <Iceland_jack> A BinTree of Integers would have type
01:03:44 <Iceland_jack>     BinTree Integer
01:03:57 <pjdelport> knapper_tech: Yes. The above reads as "A value of type BinTree of 'a' is either Empty, or a Node of an 'a' and two BinTrees of 'a'."
01:04:02 <knapper_tech> there we go
01:04:27 <Iceland_jack>     Node 42  Empty Empty :: BinTree Integer
01:04:27 <Iceland_jack>     Node 'a' Empty Empty :: BinTree Char
01:04:36 <petercommand> does the recursive call of !! from Data.List get optimized to non-recursive calls?
01:05:07 <Iceland_jack> @let data BinTree a = Empty | Node a (BinTree a) (BinTree a) deriving Show
01:05:08 <lambdabot>  Defined.
01:05:14 <pjdelport> knapper_tech: So in particular, BinTree alone a higher-order type, or "type constructor": you instantiate it with a type parameter like Integer or Char to get a concrete BinTree of that element type.
01:05:27 <pjdelport> "is a higher-order type", even
01:05:29 <Iceland_jack> > L.Node 'a' Empty Empty :: BinTree Char
01:05:31 <lambdabot>  Node 'a' Empty Empty
01:05:36 <knapper_tech> Thanks people, I got it
01:06:37 <pjdelport> petercommand: Not in general, no. (Generally, recursion is equivalent to looping.)
01:07:30 <Iceland_jack> gamegoblin: (note that that solution is not composable without doing it manually)
01:07:32 <pjdelport> petercommand: It *might* get unrolled or optimized away in certain expressions, though, but no different than any other function.
01:07:45 <johnw> chrisdotcode: I know
01:07:46 <petercommand> pjdelport: I think a list in haskell is just like a single-linked list, is this correct?
01:07:48 <Iceland_jack> that's what I attempted to solve with Capabilities, there are some other solutions
01:07:54 <pjdelport> petercommand: Right.
01:07:56 <Iceland_jack> petercommand: that's right
01:07:57 <pjdelport> @src []
01:07:57 <lambdabot> data [] a = [] | a : [a]
01:07:58 <chrisdotcode> johnw: I just commented on the pull request someone there left :)
01:08:07 <johnw> chrisdotcode: sorry, the docs are at least a year out of date
01:08:18 <chrisdotcode> I'm totally willing to help with that
01:08:41 <pjdelport> (petercommand: You can read that as "data List a = Nil | Cons a (List a)")
01:08:42 <johnw> oh, that would be awesome!
01:08:46 <johnw> let me know how I can help you help :)
01:08:52 <Iceland_jack> petercommand: http://www.reddit.com/r/haskell/comments/1q0jsj/why_lists/ maybe this will interest you
01:09:31 <chrisdotcode> johnw: well, I commented on the PR that you could show us how to *properly* open a repo with `openRepository`, because nothing I tried, and even  jpaugh's example was incorrect
01:09:39 <petercommand> Iceland_jack: ok, gonna look into that, thx :)
01:10:09 <johnw> check out git-monitor
01:10:15 <johnw> it's a fully working example app
01:12:20 <chrisdotcode> johnw: there's no `openRepository` usage in there, though :(
01:12:43 <solidus-river> jle`: its bed time for me, thanks for you help understanding netwire, as always, hopefully it sticks long enough for me to write some code tomorrow after work :)
01:12:47 <solidus-river> 'night all
01:12:56 <chrisdotcode> from 3,000 feet, it seems to be loading the repo with shelly, not gitlib itself
01:13:02 <jle`> solidus-river: no problem :)  try writing the IAuto instance and a lot will make sense
01:13:20 <johnw> ah, it uses withRepository
01:13:36 <johnw> which is defined in Repository.hs
01:13:45 <johnw>     repo <- openRepository factory opts
01:13:46 <johnw>     runRepository factory repo $ action `finally` closeRepository
01:14:57 <chrisdotcode> I was so lost on what exactly a repository factory was, and why it as needed to open a repo in the first place.
01:15:29 <gamegoblin> @pl (a,b) = [a,1,b]
01:15:29 <lambdabot> (line 1, column 8):
01:15:29 <lambdabot> unexpected " "
01:15:29 <lambdabot> expecting operator
01:15:37 <gamegoblin> @pl \(a,b) -> [a,1,b]
01:15:38 <lambdabot> uncurry ((. ((1 :) . return)) . (:))
01:15:42 <johnw> chrisdotcode: join me in #gitlib?
01:20:17 <solidus-river> jle`: started thinking about it, the (.) in an IAuto could return  \_ -> (Nothing, \_ ->  Nothing)
01:20:24 <solidus-river> or something like that
01:20:44 <jle`> that's not a lawful instance
01:21:03 <jle`> hm
01:21:20 <jle`> yeah, it's not
01:21:25 <jle`> beucase f . id  has to equal f
01:23:53 <jle`> solidus-river: if you sit down and try to write it, there will only be one obvious implementation :)
01:28:24 <solidus-river> hmm, might be to far into bed time for me to write this
01:28:34 <solidus-river> is this right so far for my non IAuto stuff?
01:28:44 <solidus-river> http://lpaste.net/107039
01:29:47 <merijn> solidus-river: Looks ok, yeah
01:30:13 <merijn> solidus-river: As you probably already know line 13's datatype definition can't possible be right, though
01:31:12 <merijn> Having Maybe on the left-hand side of a data declaration like "data Foo (Maybe a) = ..." is non-sensical
01:31:15 <solidus-river> merijn: aye but i'm not familiar enough with GADT's to throw them up on pastie
01:31:29 <solidus-river> and i'd need that for a correct IAuto data type, right?
01:31:35 <merijn> Do you?
01:32:06 <merijn> solidus-river: I'm assuming IAuto is supposed to be like Auto, but returning a "Maybe b" instead of "b"?
01:32:14 <solidus-river> merijn: yeah
01:32:37 <merijn> solidus-river: What's wrong with "newtype IAuto a b = IAuto { runIAuto :: Auto a (Maybe b) }"?
01:34:11 <solidus-river> merijn: nothing nad thats a lot nicer to look at
01:34:15 <solidus-river> :)
01:34:22 <jle`> it should be
01:34:40 <merijn> solidus-river: newtype's like that are the usual way to provide "specialised" instances for things like Auto
01:34:44 <jle`> newtype IAuto a b = IAuto { runIAuto :: a -> (Maybe b, IAuto a b) }
01:34:51 <jle`> oh yeah
01:35:08 <jle`> i guess there's no reason why not
01:35:57 <solidus-river> jle`: newtype IAuto a b = IAuto { runIAuto :: IAuto a b -> a -> (Maybe b, IAuto a b) }
01:36:07 <solidus-river> doesn't it need the IAuto a b in there at the beginign?
01:36:11 <jle`> no
01:36:28 <jle`> remember records?
01:36:30 <solidus-river> how come Auto needed it?
01:36:34 <merijn> solidus-river: It isn't
01:36:36 <jle`> it didn't
01:36:54 <jle`> data Auto a b = Auto { runAuto :: a -> (b, Auto a b) }
01:36:57 <jle`> do you remember record syntax?
01:37:02 <merijn> solidus-river: Your current type is "runAuto :: Auto a b -> Auto a b -> a -> (b, Auto a b)"
01:37:08 <jle`> data Foo = { getFoo :: Int }
01:37:15 <jle`> gives you a function getFoo :: Foo -> Int
01:37:53 <jle`> er there should be a constructor there
01:39:31 <solidus-river> wait then my Category Auto id is wrong then
01:39:52 <solidus-river> i need a \x ->
01:40:03 <solidus-river> right?
01:41:47 * solidus-river falls asleep at the computer, dreams of Auto's
02:00:04 <Qfwfq> Where's if' defined?
02:00:38 <Qfwfq> @info if'
02:00:39 <lambdabot> if'
02:01:07 <Qfwfq> @src if'
02:01:07 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
02:01:25 <Qfwfq> > if' "True" "False" $ False
02:01:27 <lambdabot>  Not in scope: ‘if'’
02:01:27 <lambdabot>  Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
02:01:39 <Qfwfq> I guess I just imagined it. I can define it easily enough.
02:01:59 <Qfwfq> > bool "True" "False" $ False
02:02:00 <k00mi> Qfwfq: there is Data.Bool.bool, since GHC 7.8 I believe
02:02:00 <lambdabot>  "True"
02:02:08 <Qfwfq> Yeah, that was it.
02:02:32 <Qfwfq> We use 7.6.3 in production, so I'm going to end up defining it anyway.
02:03:27 <zq> :t bool
02:03:27 <lambdabot> a -> a -> Bool -> a
02:03:33 <zq> @src bool
02:03:34 <lambdabot> Source not found. My pet ferret can type better than you!
02:03:45 <zq> eh
02:03:56 <zq> what's the point? if else than not hipster enough?
02:04:05 <pjdelport> Qfwfq: There are a bunch of them:
02:04:14 <pjdelport> http://hackage.haskell.org/package/cond-0.4.1/docs/Control-Conditional.html#v:if-39-  http://hackage.haskell.org/package/utility-ht-0.0.10/docs/Data-Bool-HT.html#v:if-39-  http://hackage.haskell.org/package/general-prelude-0.1.2/docs/Prelude-General.html#v:if-39-
02:05:56 <pjdelport> And yeah, it's the same as bool in Data.Bool.
02:06:13 <k00mi> zq: you can use it in pointfree expressions
02:06:30 <zq> k00mi: example?
02:07:10 <k00mi> f = bool a b
02:07:15 <k00mi> is the same as:
02:07:26 <Qfwfq> > bool "Non-empty!" "Empty!" . not . null $ [1..5]
02:07:27 <lambdabot>  "Empty!"
02:07:27 <k00mi> f cond = if cond then a else b
02:07:32 <zq> i'm aware of that
02:07:37 <Qfwfq> > bool "Empty!" "Non-empty!" . not . null $ [1..5]
02:07:38 <lambdabot>  "Non-empty!"
02:07:40 <Qfwfq> Oops.
02:08:20 <zq> how is if-then-else hindering to point-free?
02:08:49 <zq> > if not $ null [1..5] then "non" else "emp"
02:08:50 <lambdabot>  "non"
02:08:59 * hackagebot peyotls 0.0.0.21 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.21 (YoshikuniJujo)
02:09:01 <zq> bool 1 2 True
02:09:02 <k00mi> it's not a function, you can't pass it around
02:09:04 <zq> > bool 1 2 True
02:09:05 <lambdabot>  2
02:09:15 <pjdelport> > "yay" `bool` "nay" <$> even <$> [0..9]
02:09:16 <lambdabot>  ["nay","yay","nay","yay","nay","yay","nay","yay","nay","yay"]
02:09:59 <pjdelport> except that's the wrong way around, oops
02:10:39 <pjdelport> > "odd" `bool` "even" <$> even <$> [0..9]
02:10:41 <lambdabot>  ["even","odd","even","odd","even","odd","even","odd","even","odd"]
02:15:41 <augur> \o/
02:15:42 <augur> my algorithm works!
02:20:04 <maybefbi> does anyone remember a performance cheatsheet that was being passed around recently on haskell forums and chatrooms? it was on github if i rmember correctly
02:22:50 <jkarni> maybefbi: could it be Johan Tibell's performance slides?
02:24:21 <maybefbi> jkarni, wait checking
02:24:22 <lfairy> :t (ContT . ReaderT, ReaderT . ContT)
02:24:23 <lambdabot>     Couldn't match type ‘ReaderT r1 m1 a1’ with ‘(a -> m r) -> m r’
02:24:24 <lambdabot>     Expected type: (r1 -> m1 a1) -> (a -> m r) -> m r
02:24:24 <lambdabot>       Actual type: (r1 -> m1 a1) -> ReaderT r1 m1 a1
02:24:43 <lfairy> :t ReaderT . ContT
02:24:44 <lambdabot>     Couldn't match type ‘ContT r1 m1 a1’ with ‘r -> m a’
02:24:45 <lambdabot>     Expected type: ((a1 -> m1 r1) -> m1 r1) -> r -> m a
02:24:45 <lambdabot>       Actual type: ((a1 -> m1 r1) -> m1 r1) -> ContT r1 m1 a1
02:25:03 <maybefbi> jkarni, yeah that was the one i was looking for thanks!
02:25:28 <pjdelport> http://johantibell.com/files/haskell-performance-patterns.html ?
02:32:57 <magicman> @hoogle (a -> Set b) -> [a] -> Set b
02:32:57 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
02:32:57 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
02:32:57 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
02:42:32 <quchen> :t \f xs -> S.unions (map f xs) -- magicman
02:42:33 <lambdabot> Ord a => (a1 -> S.Set a) -> [a1] -> S.Set a
02:42:51 <magicman> Aye, already had that. Just wondered if that was in the library already.
02:43:16 <magicman> For some reason I define a version of that in just about every bit of code that somehow uses Set.
02:45:22 <supki> :t foldMap :: Ord b => (a -> S.Set b) -> [a] -> S.Set b
02:45:23 <lambdabot> Ord b => (a -> S.Set b) -> [a] -> S.Set b
02:45:49 <quchen> Oh, right!
02:45:52 <quchen> Good call
02:45:55 <wz1000> How would a undirected graph be represented via text?
02:45:55 <augur> :(
02:45:58 <matematikaadit> :t bool
02:45:58 <lambdabot> a -> a -> Bool -> a
02:46:11 <augur> my parser is a tiny little source file but a bit executable :(
02:46:34 <quchen> wz1000: Using a proper datatype that you then serialize to JSON, for example?
02:47:18 <RchrdBrrll> wz1000, graphviz renders graphs from text files that you supply it and has a pretty reasonable input format.
02:47:47 <wz1000> RchrdBrrll: Thanks, I'll look into that
02:48:38 <RchrdBrrll> http://en.wikipedia.org/wiki/DOT_(graph_description_language) ← you'd need a full-blown parser to parse it (shouldn't be hard to implement in Parsec).
02:48:40 <magicman> Oh, nice one!
02:49:19 <RchrdBrrll> otoh, if you have a function that *emits* graphs in DOT format then you can take advantage of graphviz to draw them. :)
02:50:12 <osfameron> though writing DOT format that produces *pretty* graphs is "fun"
02:51:12 <osfameron> every couple of years I decide I want to use DOT to visualize call graphs or DB tables, and give up after several hours of failing to get very wide, flat, tiny graphs to become readable
02:51:22 <RchrdBrrll> wz1000, if you want to write as little code as possible, the Read and Show instances for whatever type you're using to represent the graph would be the easiest thing to use. =)
02:51:23 <augur> is there any convenient way to test the performance of a function to see what the average time for execution is?
02:51:28 <wz1000> I just want a simple representation that would serve for debugging purposes. My data type is something like 'Graph a = Node a [Link a]', where 'Link a = (Int, Graph a)'
02:51:35 <quchen> augur: Criterion?
02:51:43 <RchrdBrrll> augur, there's a REALLY good library for benchmarking called Criterion
02:51:50 <augur> oh i see
02:51:59 <ninja_code> is there a way in Haskell to define Range Int Int, where the first element is also <= second element ?
02:52:01 <quchen> augur: "Evaluate to NF or WHNF 1000 times, put into statistics"
02:52:29 <wz1000> RchrdBrrll:  Read and show just get stuck on infinite loops due to the undirected nature of the graphs.
02:53:06 <RchrdBrrll> wz1000, I think that your problem there is that your graph representation is difficult to work with without going into infinite loops.
02:53:27 <ninja_code> infinite loops
02:53:28 <ninja_code> yay
02:53:34 <RchrdBrrll> You might want to look at the 'fgl' library which implements a nice inductive interface for graphs.
02:53:47 <jle`> ninja_code: there's an edwardk library for that
02:53:53 <wz1000> Here is the little amount of code I've written:- http://lpaste.net/107046
02:54:02 * hackagebot keystore 0.2.0.1 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.2.0.1 (ChrisDornan)
02:54:06 <jle`> ninja_code: http://hackage.haskell.org/package/intervals
02:54:11 <frerich> ninja_code: I think you'd need dependent (dependant?) types for that. Alternatively, you could use a "smart constructor" (http://www.haskell.org/haskellwiki/Smart_constructors) or you could redefine the meaning of the second int so that it doesn't define an absolute value but rather a delta to the first. You could then use an unsigned int for that.
02:54:34 <augur> quchen, RchrdBrrll: any tutorials for using this thing?
02:54:35 <jle`> 2...4 :: Interval Int
02:54:38 <ninja_code> jle`, frerich: will go off and study these links. thanks!
02:54:48 <ninja_code> quchen: are you a math phd student?
02:54:56 <quchen> No.
02:55:03 <quchen> I studied physics though.
02:55:23 <ninja_code> quchen: ah, a different quchen ... probably a good thing; otherwise, it'd be sorta creepy
02:55:37 <RchrdBrrll> wz1000, your Graph type can't represent an *empty* graph, too, which is :(
02:55:53 <wz1000> RchrdBrrll: I'm just learning right now, so using a library kind of defeats the purpose.
02:56:05 <quchen> augur: It's very simple to use, actually. This is a bit old, but should still be helpful: http://www.serpentine.com/blog/2009/09/29/criterion-a-new-benchmarking-library-for-haskell/
02:56:27 <augur> quchen: thank you :)
02:56:39 <quchen> augur: The HTML output ("./bench -oFOO.html") is *much* nicer now though.
02:56:59 <ccapndave> Hey everyone - I am trying to use Aeson to do some custom JSON mapping of my data (using https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/episode-1-json for help) but when I print my generated JSON to the console it is coming out as Chunk "...my json here...".  What is a Chunk and how do I get rid of it?
02:57:02 <wz1000> RchrdBrrll:  Are empty graphs useful?
02:57:21 <RchrdBrrll> Yes.
02:58:13 <Javran> @hoogle (Monad m) => m Bool -> m a -> m a -> m a
02:58:13 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
02:58:13 <lambdabot> Control.Exception.Base bracket_ :: IO a -> IO b -> IO c -> IO c
02:58:13 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
02:58:40 <Javran> @hoogle Bool -> a -> a -> a
02:58:41 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
02:58:41 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex3 :: a -> a -> a -> Vertex3 a
02:58:41 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector3 :: a -> a -> a -> Vector3 a
02:58:58 <RchrdBrrll> Well, the mathematical definition of a graph that everyone uses is G={V,E}, where V is a set of node labels and E is a set of edges, and that definition permits either V or E to be the empty set. So if you define a Graph type that doesn't permit V or E to be an empty set then you may get weird edge cases in all the algorithms that you try to write.
02:59:03 <Javran> :t ifThenElse
02:59:04 <lambdabot> Not in scope: ‘ifThenElse’
02:59:14 <quchen> augur: An outline would be that you group benchmarks using `bgroup`, and benchmarks are created using `bench name (evaluator f value)`, which creates a benchmark "name" that evaluates "f value" to "evaluator=(nf|whnf)".
02:59:50 <RchrdBrrll> wz1000, even if you don't use the fgl library, you may want to read the paper which the authors wrote about it, at http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP01
02:59:53 <quchen> Put that into `defaultMain` and run the executable with -oOUTPUT.html to get a pretty summary.
03:00:43 <wz1000> RchrdBrrll: Well, adding an '| Empty' would be ugly, since then there would be Links that lead to nowhere, so what should I do?
03:01:10 <quchen> augur: Example: http://bos.github.io/criterion/
03:01:54 <RchrdBrrll> wz1000, the simplest, mirroring the definition, model would be: data Graph nodeLabel edgeLabel = G [nodeLabel] [(nodeLabel, edgeLabel, nodeLabel])
03:02:49 <wz1000> RchrdBrrll: Why is there a list of nodeLabels
03:03:35 <wz1000> Wouldn't a Maybe nodeLabel be better?
03:03:42 <RchrdBrrll> because the definition of a graph permits an arbitrary number of nodes, including nodes with no edges.
03:05:02 <RchrdBrrll> you can improve the runtime performance of that a lot by using Data.Map and Data.Set, so you end up with something like: data Graph node edge = G (Set node) (Map node [edge]).
03:06:10 <wz1000> So in a Graph ["a","b","c"] <Edges>, "a", "b" and "c" will have the same Edges?
03:07:17 <RchrdBrrll> If it's undirected.
03:07:22 <RchrdBrrll> or reflexive.
03:07:25 <Javran> is there a function version of if expression?
03:07:51 <frerich> Javran: Maybe you'll appreciate http://www.haskell.org/haskellwiki/If-then-else
03:08:51 <Javran> frerich: thanks!
03:09:55 <arossouw> is Data.Text faster than String, for when using attoparsec ?
03:11:13 <intrados> What am I not understanding about attoparsec's sepBy? `parseOnly (takeText `sepBy` char 'x') "axb"` produces `Right ["axb"]` instead of the expected `Right ["a", "b"]`
03:11:17 <quchen> Attoparsec can't even parse String, can it?
03:11:42 <wz1000> RchrdBrrll: Wouldn't this allow a Graph with no nodes, but a nonzero number of edges, which makes no sense?
03:12:43 <RchrdBrrll> wz1000, yes. It also permits a graph with edges that don't match any nodes. I'd suggest avoiding those issues by filtering on the node set when querying the edge set.
03:13:06 <RchrdBrrll> wz1000, I'd also suggest reading the fgl paper that I linked earlier because they have a really very nice graph representation.
03:13:29 <wz1000> RchrdBrrll: Yeah, I'm working through it.
03:13:50 <killy9999> is there an efficient function for computing average of a list of Num a somewhere in the libraries, or do I have to reinvent the wheel?
03:15:29 <wz1000> Is there any nice way to have an undirected edge?
03:15:35 <intrados> killy9999: Statistics.Sample.mean
03:18:42 <quchen> intrados: takeText parses the entire rest of the input, your `sepBy` fails because there's nothing left to be separated?
03:19:05 <gilligan_> hi
03:20:51 <quchen> intrados: "sepBy p sep" applies p. If p fails, it tries to apply sep and then p again, until one of them fails.
03:21:13 <quchen> Your example consumes the entire input in one go, sepBy does nothing because the input is empty at that point.
03:21:14 <intrados> quchen: Oh, hm. I expected sepBy to break it into sepped chunks first then takeText. Thanks
03:21:21 <gilligan_> Has anyone else here had a look at the "haskell data analysis cookbook" ? I gave it a rather bad review on amazon and the author tracked me down offering me another copy if I improve the rating to 3 or 4 stars ...
03:23:30 <jtakacs> hi!
03:24:26 <chandru_in> Is it possible to implement arena allocation for specific parts of the program in haskell?
03:27:28 <deni> does anyone have a good tutorial/article/paper on free monads and where and what for are they useful?
03:27:59 <quchen> deni: This talk is excellent: https://skillsmatter.com/skillscasts/4430-monads-for-free
03:28:06 <quchen> (Requires dummy registration)
03:30:29 <kvanb> chandru_in: only using ptr magic
03:30:53 <chandru_in> kvanb, is there some example in the wild I can look at?
03:31:44 <kvanb> chandru_in: no, but take a fast one in C
03:31:53 <kvanb> and you could easily translate it to very very verbose Haskell
03:32:20 <kvanb> and get prettymuch similar performance
03:32:28 <frerich> gilligan_: Packt publishing is a good indicator of a low-quality book. The litlerally let *anyone* write a book and then start contacting people so that the book gets a positive review on amazon.
03:32:31 <kvanb> I just don't know how you construct in-place in Haskell
03:32:48 <kvanb> ie, if  you want to make Just 3 I have no idea how to construct it at a Ptr location cheaply
03:33:13 * osfameron wonders why getting a second copy of a book you didn't like would encourage you to be more positive
03:33:56 <frerich> gilligan_: I don't know that particular book, and of course the quality of the book is up to the author - but my experience is that they ask about anybody to write about anything even so the quality of the books they publish (and they publish a lot) is rather low.
03:34:15 <deni> quchen: tnx. i'll check it out...I've read a few articles on the net including this one: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
03:34:22 <deni> quchen: but nothing is making sense so far
03:34:57 <intrados> deni: Learning about free monoids too made things a bit clearer for me
03:35:26 <gilligan_> frerich: yeah that's rather lame
03:36:21 <gilligan_> frerich: also when you think about it it's almost funny that he offers me /another/ copy of the book that I rated with 1 star if I improve my rating .. Why the hell would I want another copy of a book that I thin sucks?! :-)
03:36:45 <shanse> you could sell it for the big bucks!
03:37:44 <gilligan_> shanse ;-)
03:38:19 <deni> intrados: the problem is that most of the articles that try and explain this stuff are to abstract...i'd benefit much from a concrete real world example and how this helped solve a problem or simplify the codebase or something
03:38:30 <kvanb> I have a design problem, but I dont think its solvable. Would someone like to try and solve it.
03:41:26 <frerich> kvanb: You could post what you tried to far to lpaste.net
03:41:50 <donri> don't bait, just ask ;)
03:43:48 <kvanb> okay, here's the problem. Ready your various body parts. http://lpaste.net/107049
03:45:28 <kvanb> API design is hard.
03:47:48 <intrados> deni: I think it might be a little difficult to come with an examples like that (though I think free monads can, in fact, simplify your code). As far as I understand it, you never /need/ a free x. It's just, in a sense, the free monad is the most general monad. Consequently, knowing free x helps you recognized and deduplicate patterns and take advantage of existing libraries
03:49:03 <ccapndave> Haskell is hard :(
03:49:40 <ccapndave> If I have a data type 'data Symbol  = WildSymbol Int | NormalSymbol Int' is there a way to get the Int out of a symbol without having to explicitly pattern match WildSymbol or NormalSymbol
03:49:55 <k00mi> no
03:49:58 <yogurt_truck> ccapndave: hard for what?
03:50:10 <ccapndave> yogurt_truck Everything
03:50:12 <nclarke> ccnapdave: Let's go shopping?
03:50:28 <ccapndave> The idea is that I want a function that doesn't need to change if I later add other types to Symbol
03:50:30 <yogurt_truck> ccapndave: yeah that's massively false
03:50:51 <kvanb> ccapndave: you could give it a functor instance
03:50:52 <ccapndave> Right now its hard for serializing and unserializing json
03:51:09 <ccapndave> kvanb Ok
03:51:15 <IvoryTower> I was wondering if anyone could help me clear up some terminology? mainly the difference between a **function** and **operator**. I seen (+) referred to as a function, an operator, an infix operator, and an infix function. It seems that some people are using function and operator interchangeably when they shouldn't be.
03:51:17 <nclarke> ccnapdave: The problem is, you might later add '| StringSymbol String' - and then what's your int-getting function goign to do?
03:51:19 <k00mi> ccapndave: other constructors might not have an Int field
03:51:25 <ccapndave> Ah
03:51:27 <k00mi> kvanb: no, he can't, that'd be a kind error
03:51:28 <kvanb> another thing you can do
03:51:30 <ccapndave> Right, well they definitely will
03:51:38 <ccapndave> Should I maybe represent this a different way then?
03:51:43 <ccapndave> Its always a type and an int
03:51:55 <k00mi> hard to say without knowing what you want to do
03:52:00 <kvanb> data Symbol  = WildSymbol { innerInt :: Int } | NormalSymbol { innerInt :: Int }
03:52:02 <ccapndave> But in other places I *do* want to pattern match which is why I did it like this
03:52:14 <yogurt_truck> IvoryTower: they are all functions
03:52:25 <ccapndave> kvanb Ah - and I can now use the top level innerInt to get it out?
03:52:31 <kvanb> yeah
03:52:33 <ccapndave> cool
03:52:38 <ccapndave> That looks like the kind of thing
03:52:39 <kvanb> but if you add one without int later, it'll throw a runtime error
03:52:39 <ccapndave> Thanks :)
03:52:47 <ccapndave> I won't
03:52:48 <intrados> ccapndave: You could just make the datatype an instance of Enum
03:53:08 <ClaudiusMaximus> you could use record syntax:  data Symbol = WildSymbol{ getInt :: Int } | NormalSymbol{ getInt :: Int }  or refactor to  data Symbol = Symbol SymbolType Int ; data SymbolType = Wild | Normal
03:53:17 <ccapndave> intrados How would enum help?
03:53:19 <merijn> IvoryTower: There is no difference between operator and function
03:53:34 <donri> IvoryTower: an operator is a function that returns a function (ie it is binary) and whose name is all non-alphanumeric which means it defaults to infix application
03:53:45 <merijn> IvoryTower: Operator is used to describe functions whose name consists of sumbols and can thus be written infix
03:53:55 <merijn> donri: You can have non-binary operators
03:54:10 <intrados> ccapndave: enum provides fromEnum :: Enum a => a -> Int
03:54:11 <donri> merijn: but you need an extension for unary operators
03:54:22 <IvoryTower> http://www.haskell.org/onlinereport/lexemes.html section 2.4 lists the difference between an identifier and operator, but then this just applys to names then
03:54:24 <donri> and all >2-ary functions are also binary ;)
03:54:33 <ccapndave> intrados But then I will have to pattern match in the enum definition anyway
03:54:40 <nclarke> intrados: But you would still have to extend the fromEnum definition if you added a new constructor
03:54:47 <IvoryTower> in the end, they're both functions if I understand you all correctly
03:54:50 <intrados> ccapndave: Yes, but then you're changing one location rather than many
03:55:01 <merijn> IvoryTower: Correct
03:55:04 <kvanb> the Enum instance isn't for that though
03:55:14 <kvanb> sorry, class
03:55:20 <nclarke> intrados: Better in that case to write a function, rather than abusing Enum
03:55:20 <kvanb> that would be extremely misleading
03:55:42 <ccapndave> Right
03:55:45 <merijn> IvoryTower: The report defines operators which applies to names. The only "difference" is that operators are parsed as being infix by default
03:55:52 <kvanb> Nobody want to have a shot at my API design problem? :\
03:56:02 <ccapndave> I am trying abstracting the symbol type as ClaudiusMaximus suggested
03:56:09 <merijn> IvoryTower: Surrounding an operator by parenthesis will make it behave like a prefix function, i.e. "(+) 1 2"
03:56:12 <donri> IvoryTower: an operator can be applied prefix with a section: (+) 1 2; a function can be applied infix like so: Sum 1 `mappend` Sum 2
03:56:15 <kvanb> here it is again http://lpaste.net/107049
03:56:20 <ccapndave> ah, but then of course I can't pattern match anywhere else
03:56:54 <merijn> > let (+) = elem in 1 + [1,2,3,4,5]
03:56:55 <lambdabot>  True
03:57:20 <merijn> Here I define a "new" function whose name is the + operator and define it to just be "elem"
03:57:33 <IvoryTower> merijn: that made things clearer. An operator is a special case of a function; it returns only one function (ie: works with two inputs) and defaults to infix
03:57:34 <ccapndave> kvanb Your innerInt record solution seems the best
03:57:36 <IvoryTower> thanks all
03:57:49 <ccapndave> That still works with the existing code, plus lets me get out the value.  Thanks!
03:58:02 <killy9999> intrados: thanks, but this works on Vector not list
03:58:09 <merijn> IvoryTower: well, as I said they don't even have to be binary, but having one that isn't is usually really inconvenient, so they usually are binary
03:59:30 <donri> trinary operators aren't that uncommon though; usually combined with something like ($) for a kind of distfix DSL
03:59:35 <IvoryTower> merijn: ok, I read in another reply that they're binary,
03:59:36 <pjdelport> IvoryTower: It's not actually limited by arity: you can use operator syntax for arguments of any arity.
03:59:46 <pjdelport> (above 2, i mean)
03:59:54 <ccapndave> And it works!  Thanks everyone.
04:00:00 * ccapndave maintains that Haskell is hard, though
04:00:21 <IvoryTower> pjdelport: and in that case it would have to be called using prefix notation I imagine, correct?
04:00:30 <donri> > id +~ 2 $ 1
04:00:32 <lambdabot>  3
04:00:38 <merijn> IvoryTower: Well that or appropriate parenthesis
04:00:44 <intrados> killy9999: "Efficient" often implies Vector rather than lists. You can convert back and forth via V.toList/V.fromList
04:00:46 <kvanb> > let (-->) = \x y z -> x + y + z in 1 --> 2 $ 4
04:00:48 <lambdabot>  7
04:01:15 <killy9999> intrados: yes, I know about converting from/to Vectors
04:01:30 <merijn> > let (*) x y z = z {- kinda like const, throw away first two arguments -} in (1 * 2) 'c'
04:01:31 <lambdabot>  can't find file: L.hs
04:01:37 <killy9999> by "efficient" I meant avoiding the nonsense with thunks
04:01:41 <donri> IvoryTower: ^ in that example +~ is trinary so we need $ to separate the third argument
04:01:42 <pjdelport> > let (x # y) z = x+y+z in (1 # 2) 3
04:01:44 <lambdabot>  6
04:01:57 <donri> or parenthesis
04:02:01 <killy9999> well, I've reinvented the wheel in ythe meantime, so I'm good
04:02:32 <pjdelport> > (+) `zipWith` [1..] $ [1..]
04:02:34 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
04:02:58 <frerich> Using functions with arity > 2 infix doesn't look very pretty IMHO.
04:03:04 <pjdelport> :t zipWith
04:03:05 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
04:03:08 <IvoryTower> ok, I see how that would work with parenthesis
04:03:29 <IvoryTower> I have some father stuff to do, thanks a bunch for clearing that up everyone
04:04:49 <donri> child `IvoryTower` fatherStuff  -- operator of offspring
04:06:41 <deni> intrados: yeah nevertheless....concrete examples help most
04:07:07 <deni> intrados: a refactoring some specific code for instance. oh well...googling :)
04:09:59 <intrados> deni: There are a couple posts on free monads in that style on "Haskell for all"
04:14:10 * hackagebot happy 1.19.4 - Happy is a parser generator for Haskell  http://hackage.haskell.org/package/happy-1.19.4 (SimonMarlow)
04:18:14 <jtakacs> how can I use 3 different global counters in my program?
04:18:41 <k00mi> what do you want to do?
04:20:40 <jtakacs> first of all: learning haskell :) , and by doing that, i'd like to try to write an mpegts streamer. And in mpegts, every PID has a different continuity counter
04:21:14 <jtakacs> I want to stream the video in a loop, so after the first run, I need to rewrite the continuity counters in the streams
04:22:35 <donri> it's easy to make global counters, but usually better to make them local
04:23:37 <jtakacs> I don't mean 'global' like global variables in C. but I can't think of a better name
04:25:05 <k00mi> do you know the State monad?
04:27:53 <jtakacs> no, how do I use it?
04:28:03 <pjdelport> jtakacs: How are the counters defined?
04:28:45 <jtakacs> they are 4 bit integers in range [0..15]
04:28:54 <pjdelport> jtakacs: If you don't need to update them in response to some state, it might be easier to do the equivalent of something like:
04:28:54 <pjdelport> > zipWith (,) [1..] (cycle "fnord")
04:28:55 <lambdabot>  [(1,'f'),(2,'n'),(3,'o'),(4,'r'),(5,'d'),(6,'f'),(7,'n'),(8,'o'),(9,'r'),(10...
04:29:33 <ion> > zip [1..] (cycle "fnord")
04:29:34 <lambdabot>  [(1,'f'),(2,'n'),(3,'o'),(4,'r'),(5,'d'),(6,'f'),(7,'n'),(8,'o'),(9,'r'),(10...
04:29:38 <pjdelport> jtakacs: Well, I mean, how are they defined semantically? If they're just incrementing streams, you can use an approach like the above.
04:30:07 <pjdelport> Right; (,) above is just a placeholder for whatever would be combining the counters and the frames :)
04:33:15 <Javran> @pl \(x:y:_) -> (x,y)
04:33:15 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
04:36:29 <jtakacs> ok, here is what I did so far: http://lpaste.net/107053
04:37:08 <jtakacs> please point out every mistake I made
04:39:27 <jtakacs> right now I have no idea how to extend this to process the binary mpegts packets, and do stuff based on their header values, like using a variable threadDelay
04:41:29 <pjdelport> jtakacs: Without looking deeply, you might want to consider lazy bytestrings, if you're going to do something like mpegts <- B.readFile "test.ts"
04:41:57 <jtakacs> I should read the stream until I hit two packets whith the PCR set, caltulate the nanosecond difference of the PCRs, and use it for sleep after the current block is streamed out
04:42:17 <pjdelport> Strict ByteStrings will read the whole file into memory without proceeding further. Lazy ByteStrings will let you process it incrementally.
04:42:28 <pjdelport> (chunk-based, internally)
04:42:28 <jtakacs> lazy bytestrings did not work, there was some error with the sendAll function
04:43:21 <pjdelport> jtakacs: It looks like sendAllTo expects a strict bytestring; you just have to explicitly convert the lazy chunk to one.
04:44:13 * hackagebot postgresql-simple-migration 0.1.2.0 - PostgreSQL Schema Migrations  http://hackage.haskell.org/package/postgresql-simple-migration-0.1.2.0 (ameingast)
04:44:44 <pjdelport> jtakacs: Text.ByteString.Lazy has a toStrict function for that.
04:45:30 <pjdelport> There's also toChunks and a few other ways to do it, which might be more efficient, depending on the program structure.
04:45:47 <jtakacs> pjdelport: currently, lazy or strict bytestrings are not my issue. the file is small enough to fit in the memory. My problem is: how to keep state, so after the first loop I can update some bits in the stream
04:49:13 <donri> > do { modify (+3); modify (*3) } `runState` 0
04:49:15 <lambdabot>  ((),9)
04:49:38 <donri> @unmtl State s a
04:49:39 <lambdabot> s -> (a, s)
04:50:15 <pjdelport> jtakacs: How are the counters defined, semantically?
04:50:42 <jtakacs> what do you mean by 'semantically'?
04:50:43 <pjdelport> jtakacs: If they're just incrementing, you can just use something like zipping, rather than manually updating a parameter.
04:51:00 <pjdelport> jtakacs: As in, how are the values determined?
04:51:32 <pjdelport> jtakacs: Is there a reason you can't consume them from a linear stream, like the zipping example?
04:51:32 <donri> looping in haskell typically means recursing on a function and you can keep state by passing along an updated argument.  the state monad encapsulates this conveniently
04:51:49 <jtakacs> for every stream, there is a separate counter, which is incremented by 1 monotonically, modulo 16
04:52:06 <pjdelport> jtakacs: Ah, then you don't need State at all; plain zipping should do.
04:52:38 <donri> > cycle [0..15]
04:52:40 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15...
04:54:44 <pjdelport> jtakacs: Does the zipWith (,) [1..] (cycle "fnord") example make sense?
04:56:25 <pjdelport> Basically, [1..] is your stream of counter values. To take it modulo 16, you could say either "map (`mod` 16) [1..]", or a bit more efficiently "cycle [0..15]"
04:56:43 <pjdelport> And (cycle "fnord") is a placeholder for your stream of frames.
04:57:05 <pjdelport> (,) is a placeholder for whatever combines the two.
04:58:50 <deni> intrados: yeah most of the posts are in that style....didn't quite click with me
04:59:06 <deni> intrados: so i'm still looking
04:59:40 <mietek> Has anyone ran into issues trying to call symbols in Objective-C frameworks (OS X) from within GHCi?
04:59:42 <mietek> I can't get it to work in neither 7.8.2 (https://ghc.haskell.org/trac/ghc/ticket/9277) nor 7.6.3 (https://ghc.haskell.org/trac/ghc/ticket/9278)
05:06:35 <bitonic> let's say that I have `data Nat = Zero | Suc Nat', and I use the promoted version of it; if I have a `f :: Nat -> *' then `f n' should always be Typeable, given Typeable instances for `f', `Zero', and `Suc'.  Is there an easy way to generate such constraints?
05:07:10 <merijn> bitonic: Unrelated: Is there a reason not to use the built-in Nat kind?
05:07:35 <bitonic> merijn: I didn't know it existed
05:08:04 <bitonic> merijn: do I have to import something?
05:08:41 <merijn> bitonic: DataKinds enables both Nat (type level nats) and Symbol (type level strings)
05:08:53 <merijn> bitonic: Lemme check, although you can't do much useful with them pre-7.8
05:09:23 <bitonic> merijn: 7.8 is fine, but I don't get a Nat kind in scope if I just enable DataKinds
05:10:55 <merijn> bitonic: Ah, there in GHC.TypeLits
05:10:59 <merijn> s/there/they're
05:11:37 <merijn> bitonic: Which also has type families for equality comparison, etc.
05:12:34 <bitonic> merijn: right.  and maybe Typeable stuff involving them will just work?
05:12:39 <bitonic> that'd be brilliant
05:13:33 <merijn> No clue, I haven't used Typeable with that, but it might
05:13:43 <bitonic> let's see
05:13:50 <bitonic> that'd save me a lot of constraints in type sigs
05:13:52 <merijn> You get to use normal numerical literals this way, though, so that's pretty neat
05:14:11 <merijn> bitonic: FYI, with ConstraintKinds you can simplify constraints by rolling them up into a single big one
05:14:24 <merijn> You can even write your own TypeFamilies for generating custom Constraints
05:14:47 <bitonic> merijn: yeah, that's what I was thinking of doing if I had to do the above manually
05:17:18 <asker> hey guys
05:27:51 <bitonic> merijn: mhm.  those built in nats seem a bit hard to work with
05:28:10 <bitonic> the coercions seem to work differently with them
05:30:45 <bitonic> (differently compared to a promoted `Zero | Suc n'
05:30:46 <bitonic> )
05:32:21 <bitonic> for example, I have
05:32:22 <bitonic> Could not deduce (n1 ~ n)
05:32:22 <bitonic> from the context ((1 + n) ~ (1 + n1))
05:32:49 <bitonic> it doesn't deduce the fact that (1 +) is injective, which is fair enough
05:33:08 <bitonic> but if I use `Suc' that coercion can be used
05:38:31 <bitonic> for the same reason I can't define or derive Eq
05:38:37 <bitonic> so it's pretty useless
05:39:25 <bitonic> I could probably coerce them manually but it starts to look like too much work...
05:48:14 <pjdelport> jtakacs: Still there?
05:51:01 <pjdelport> jtakacs: I annotated your paste with a zip-based version of flood: http://lpaste.net/107055
05:51:28 <jtakacs> sorry, I had a random meeting
05:53:25 <pjdelport> jtakacs: You can apply the hlint suggestions at the bottom, too, but that should capture the gist of it.
05:53:33 <jtakacs> thank you
05:54:18 <pjdelport> jtakacs: The idea is that instead of recursing at the top level, you push all the IO down into the sendPacket helper.
05:55:17 <pjdelport> And then you just use a plain old zipWith to combine it with the two lists of counters and video chunks.
05:56:02 <pjdelport> (Plus sequence_ to sequence the resulting list of actions, which you can also do in one go using zipWithM_ instead of zipWith.)
05:56:42 <jtakacs> this threadDelay 17520 is just a made up delay, in reality, I need to read the stream in advance, and extract timestamps from it (for that, I need to identify the PCR packets whit some bit hacking), and use the calculated delay after sending all packets in the current chunk
05:57:24 <pjdelport> Ah, okay.
05:58:37 <Eduard_Munteanu> bitonic: what GHC version?
05:58:55 <pjdelport> jtakacs: You could elaborate splitChunks into a smarter function which parses the video data into a list of (duration, chunk)
05:59:49 <pjdelport> jtakacs: And then you'd just have "sendPacket counter (duration, videoChunk)" or equivalent as your helper.
06:00:10 <bitonic> Eduard_Munteanu: 7.8.2
06:00:37 <merijn> bitonic: oh, it might be the solver is still "in progress"
06:00:41 <Eduard_Munteanu> bitonic: ok, I was going to mention pre-7.8 GHC doesn't reduce type-level nat arithmetic
06:02:06 <jtakacs> pjdelport: that counter in my code is named a bit misleading, this is not the counter that is incremented modulo16, this is in the RTP layer, the other one is in the mpegTS layer
06:03:24 <pjdelport> jtakacs: Oh, right, that one should be modulo 0x10000 instead, right?
06:03:26 <jtakacs> but the rtp counter is calculated also as modulo 0xFFFF
06:03:34 <pjdelport> Yeah.
06:04:02 <jtakacs> not modulo, .&. 0xFFFF
06:04:43 <jtakacs> but the rest of the code and your other suggestions looks interesting, I will try it
06:04:47 <pjdelport> (counter + 1) .&. 0xffff should be the same as as modulo 0x10000, though?
06:05:38 <bitonic> merijn, Eduard_Munteanu: well to be fair I think asking that to the solver would be too much... but if they exposed constructors that coercion would be easy to simplify
06:05:41 <jtakacs> yes, i was correcting myself
06:05:56 <pjdelport> Ah, okay.
06:13:35 <k_bx> Hi everyone! Simple lens question: how do I set hashmap-field to mempty if it's absent on some key? Here's the minimal example code to play with http://lpaste.net/107056
06:15:31 <donri> k_bx: perhaps Just mempty?
06:15:43 <donri> i think those take maybes and mempty is Nothing for Maybe
06:15:51 <donri> which would mean "delete"
06:16:26 <merijn> bitonic: The plan is to ship a full blown numeric solver with GHC for constraints like that
06:17:27 <donri> i thought the plan was to support external solvers but that they're all proprietary or something
06:20:52 <k_bx> donri: didn't get what you mean by "perhaps Just mempty". Where exactly do you think I should use that?
06:21:09 <donri> :t at
06:21:10 <lambdabot> (At m, Functor f) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
06:21:35 <donri> k_bx: at 10 .~ Just mempty
06:22:08 <k_bx> donri: ah, got it. Unofrtunately it sets to mempty even if key is present
06:22:33 <k_bx> http://lpaste.net/5472858804162920448
06:22:37 <donri> I think at .~ mempty will delete the element and ?~ mempty will set it to mempty but only if it already exists
06:22:44 <donri> but i'm rusty
06:23:19 <donri> oh i see, that's what you want
06:23:21 <donri> hm
06:24:00 <donri> are you sure you need to do that though? much of lens will give you mempty for missing keys anyway
06:27:59 <donri> > M.fromList [(5, Sum 5)] ^. ix 10
06:28:01 <lambdabot>  Sum {getSum = 0}
06:28:23 <donri> if you use ix, and your value is a monoid, you get mempty if the key is missing
06:31:31 <u-ou> :t intercalate
06:31:32 <lambdabot> [a] -> [[a]] -> [a]
06:31:43 <u-ou> :t intersperse
06:31:44 <lambdabot> a -> [a] -> [a]
06:34:16 <danilo2> Hello! Is there in haskell anything standard with such functionality (generalized Applicatives): class GenApplicative m1 m2 m3 | m1 m2 -> m3 where  (<*>~) :: m1 (a -> b) -> m2 a -> m3 b ? If not - could you suggest a proper name for something like that - if something better than GenApplicative exists?
06:35:41 <c_wraith> danilo2: it's unlikely something like that exists - it's just too wide open to have meaningful laws
06:39:25 <danilo2> c_wraith: of course you are right. There are no general laws. I was just wondering if is it possible to code it with arrows or other standard functionality, but I assume no (I do not see any way to do it, but maybe I'm blind today :) )
06:40:01 <rwbarton> it's the Applicative-y version of class BinaryFunction t1 t2 t3 | t1 t2 -> t3 where f :: t1 -> t2 -> t3
06:40:21 <rwbarton> which of course isn't a class
06:40:37 <rwbarton> it might make more sense to define it as a type
06:41:09 <rwbarton> newtype X m1 m2 m3 = X (forall a b. m1 (a -> b) -> m2 a -> m3 b)
06:41:28 <danilo2> In my use case I need class there. I just love to write as pure as possible nad I'm alwys loking If I can use something standard instead of custom one. :)
06:41:58 <danilo2> rwbarton: I need class here, because I've got different implementations for different m-Monads
06:42:52 <rwbarton> well, you can have different values of a type
06:42:54 <rwbarton> that's what they're for
06:43:03 <_Vi> How to use Codec.Wav? Where to find a full example? In HCodecs github repository I don't see any "test/" directory with sample app... For example, how to read a wav file, amplify it and write output wav file?
06:43:24 <rwbarton> just like we have different values of type t1 -> t2 -> t3 (for specific t1, t2, t3)
06:44:03 <danilo2> rwbarton: hmm, ok, but I need to chose implementation based on the types of m1 and m2, so I cannot do this with newtype anyway, am I right?
06:44:11 <danilo2> *choose
06:45:25 <Tjr> danilo2: out of curiosity, what usage scenario led you to such a generalization?
06:46:11 <rwbarton> danilo2: I'm just saying it is a bit odd what you are trying to do. you wouldn't choose a function t1 -> t2 -> t3 based on the types t1 and t2, you'd choose it based on what you want it to do
06:46:34 <rwbarton> danilo2: hence, you must have some specific meaning that your class is trying to capture: (<*>~) is supposed to do some specific thing
06:46:57 <danilo2> Tjr: That is a funny stuff. I've created an funny error handling library. You can "raise" errors on values (think of packing into Either monad). But you can raise as many errors as you want and these errors can be of any type. Then you can "catch them" (like pattern match on the eithers) - not looking at their order etc
06:47:45 <mietek> Given a Haskell source file `foo.hs`, compiled using `ghc -c -o foo.o foo.hs` into an object file, how do I call a function in this object file within GHCi?
06:48:56 <mietek> When I run `ghci foo.o` the object file loads, but the function doesn't seem to be available.
06:49:01 <mietek> When I run `ghci foo.o foo.hs` the object file loads, and the source file loads as `interpreted`, so GHCi is still not using the object file.
06:49:52 <rwbarton> there is some funny syntax I think, like ghci '*foo.o'
06:49:53 <aloiscochard> is there a way to install all packages of the haskell-plattform (a specific version ideally) in a given cabal sandbox?
06:50:06 <rwbarton> or at least ':l *foo.o' inside ghci
06:51:24 <danilo2> rwbarton: I understand your point of view, but assuming, that in this special case I really want to choose my function based on t1 and t2, type classes are the way to go, I hope I am right :)
06:52:07 <mietek> rwbarton: are you sure?  This doesn't seem to work.  Do you have a reference?
06:52:41 <rwbarton> no
06:52:45 <rwbarton> just my recollection
06:52:56 <mietek> Loading object (static) *build/pthread/threadful.o ... not found
06:53:01 <mietek> > :l *build/pthread/threadful.o
06:53:02 <mietek> target ‘build/pthread/threadful.o’ is not a module name or a source file
06:53:02 <lambdabot>  <hint>:1:1: parse error on input ‘:’
06:53:11 <mietek> Neither on the cmd-line nor within GHCi.
06:53:38 <rwbarton> yeah it's somehow not quite like this
06:54:12 <rwbarton> what version of ghci are you using?
06:54:21 <mietek> Ah, I see there is a * flag for :load
06:54:27 <mietek> But I don't think it's used for this
06:56:20 <Tjr> danilo2: If all you have is "m1 (a -> b) -> m2 a -> m3 b", then I fanthom you'd  exploit some relationship between m1 and m2 in order to apply the m1-function to m2-a. If that's true, then there's some information missing, i.e. your type signature might be too general.
06:56:49 <rwbarton> mietek: which version?
06:57:01 <mietek> rwbarton: both 7.6.3 and 7.8.2
06:57:06 <rwbarton> pick one at a time :)
06:57:09 <mietek> "When the * is used, GHCi ignores any pre-compiled object code and interprets the module."
06:57:15 <rwbarton> ah ok
06:57:17 <mietek> https://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-compiled.html
06:57:29 <danilo2> Tjr: Hmm, I've got a working implementation and it works good. I'm very interested If I can write it other way around. But to be honest, I do not see such way right now
06:58:43 <rwbarton> mietek: with 7.6.3 and :l F it doesn't seem to rebuild the module if there is already F.o
06:59:04 <mietek> Yeah, it looks in the same directory, though.
06:59:08 <Tjr> danilo2: is that an indirect way to say please look at my code?
06:59:15 <mietek> Do you know if there is a way to specify a directory for the object code?
06:59:25 <rwbarton> ah
07:00:57 <danilo2> Tjr: heh :D I was asking myself If you would ask this question. To be honest, yes - I would love to ask you about it - but I have to clean the code before sending it to you - and If you agree, I would love to consult it with you :)
07:01:53 <shlevy> Is there any way to fork()/clone() a multithreaded haskell process? I plan to exec shortly after the fork so only need the main thread active, but http://www.haskell.org/ghc/docs/7.0.3/html/libraries/unix-2.4.2.0/System-Posix-Process.html#v:forkProcess says it doesn't work if threaded
07:02:06 <shlevy> s/the main thread/the calling thread
07:02:30 <danilo2> Tjr: Would you mind sharing an email with me? I will send you the minimum working example today (max. tommorow, because I have to leave today in 15 minutes :( )
07:14:59 <QF-MichaelK> I want to practice denotational semantics, any tips?
07:16:04 <monochrom> write a blog :)
07:17:30 <QF-MichaelK> monochrom: I suppose that helps one make continual progress, but I'm not quite sure how to get started on using it and I haven't found any decent sources.
07:17:48 <monochrom> I will write one eventually
07:17:51 <rwbarton> mietek: if I do "ghc-7.6.3 -odir hidden -hidir hidden F", and then "ghci-7.6.3 -odir hidden -hidir hidden" and then ":l F", it works
07:19:20 <rwbarton> where 'hidden' is just some directory I created ahead of time
07:19:30 * hackagebot htsn-import 0.0.6 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.0.6 (MichaelOrlitzky)
07:20:30 <monochrom> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics may be a good source for now
07:22:08 <QF-MichaelK> monochrom: Perfect, that'll be a great start, thanks!
07:25:10 <mietek> rwbarton: thanks, I'll play around with that
07:27:44 <johnw> bitemyapp: hmm
07:27:56 <johnw> Tekmo may be right about the MonadTrans thing
07:33:03 <aloiscochard> I have a cabal project which have a lib and an exe, I have added lower/upper bounds on the lib, but do I need to repeat them for the executable config?
07:33:09 <aloiscochard> or is it enough like this: http://pastie.org/9364259
07:33:25 <aloiscochard> I thought putting a constrain on the lib with a specific version should be fine, innit?
07:40:04 <av> Hi there, I've got a Haskell module that uses non-Haskell code via FFI.  Every time I build a program (Haskell) using this module, I have to supply the "-L" and "-l" parameters to ghc.  Is there a way of compiling the module such that I can omit these?
07:45:44 <donri> aloiscochard: lib constraints are accounted for when building executable
07:45:59 <donri> aloiscochard: only need constraints if they need to be more constrained than lib
07:47:16 <aloiscochard> donri: awesome, ty!
07:48:46 <kgadek> hi. Is there any good info on building large Haskell projects? By large I mean >300k LOC
07:49:24 <kgadek> currently we're having a in-house solution for that but… well, it could be improved
07:49:33 * hackagebot htsn-import 0.0.7 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.0.7 (MichaelOrlitzky)
07:50:02 <tdammers> building as in compile, or building as in managing the collaborative development effort?
07:53:05 <k_bx> kgadek: what are the problems you're having? I have quite a big project(s), but it's mostly good (+ can't wait to try ghc 7.8's "-j" flag)
07:57:08 <kgadek> building as in "managing collaborative effort". I'm trying to find an example on how to manage that well. Our solution is probably good enough, but I believe it's a good idea to search for improvements.
08:01:46 <jtakacs> I'd like to write this function:  getPCR :: ByteString ->  Maybe Word64     where the ByteString is exactly 188 byte long, and most importantly, I'd like to do pattern matching on the 3rd byte
08:02:07 <jtakacs> how should it look like?
08:03:03 <jtakacs> I would write something like this in C:   if(data[3] & 0x30){} else{}
08:03:18 <kgadek> k_bx: no particular problem actually but it's… quite "heavy"
08:04:34 * hackagebot streaming-commons 0.1.3.1 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.3.1 (MichaelSnoyman)
08:05:06 <k_bx> kgadek: maybe one thing that would help is using ghc-mod(i) in your emacs, My big project with TemplateHaskell builds single executable (with cabal build Foo) about 2 minutes, but ghc-mod is able to show you errors in about 5 seconds after you save your .hs file. I think this was a huge win for me.
08:05:06 <k_bx> Also using --ghc-options="-fno-code" if you want to quickly type-check in your terminal ("cabal build Foo --ghc-options="-fno-code"")
08:06:02 <anbaric> jtakacs: Data.ByteString.index and Data.Bits?
08:07:06 <kgadek> k_bx: we don't have a single executable, rather multiple libraries that'll end in a couple of executables communicating with each others (10,000 ft view)
08:08:46 <k_bx> kgadek: I also have a lot of executables, but while you develop you usually just want to type-check only one (at least I do, not sure on your use-case).
08:09:04 <k_bx> Maybe that executable would just import everything to type-check/run-tests.
08:10:18 <k_bx> kgadek: btw, when you said it's "heavy", did you mean it compiles for too long, or something else?
08:11:47 <kgadek> that's one thing: 10-15 secs for cabal to tell that only one .hs needs to be recompiled. Second thing: custom solution = little toolset support. That's why I'm searching for alternatives
08:12:14 <kgadek> eg. I'd love to hear how it's made in Galois :P
08:12:25 <kgadek> they do have an experience in this
08:14:54 <sm> kgadek: have you seen shake ?
08:17:47 <kgadek> sm: seen, yes, but not used. I'll have a detailed look at it if you feel it's worth it
08:19:36 * hackagebot htsn-import 0.0.8 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.0.8 (MichaelOrlitzky)
08:21:15 <sm> shake is reputedly good. It can also be useful to just use ghc and a makefile instead of cabal eg to build multiple packages at once
08:22:09 <quchen> jtakacs: There's also a Lens solution for this. It looks quite long, but the important part is the content of the "masky" function.
08:22:13 <quchen> > let masky :: BSL.ByteString -> Maybe Word8; masky bs = bs ^? ix 3 . to (Data.Bits..&. 0x30) in masky (BSL.pack [0,1,2,127,4])
08:22:15 <lambdabot>  Just 48
08:22:17 <sm> there are a couple of not-too-well supported options for rebuilding when files change
08:22:41 <quchen> "ix n" accesses the n-th element, ^? makes access safe by wrapping it in Maybe.
08:22:47 <quchen> "to" then applies your bitmask.
08:23:20 <sm> also if you're not already, definitely get ghci working, so you can avoid relinking during quick iteration
08:23:21 <quchen> And if there's not enough input, ix makes the entire thing fail.
08:23:21 <quchen> > let masky :: BSL.ByteString -> Maybe Word8; masky bs = bs ^? ix 3 . to (Data.Bits..&. 0x30) in masky (BSL.pack [0,1,2])
08:23:22 <lambdabot>  Nothing
08:23:33 <quchen> Wait, ^? makes it fail.
08:26:40 <anbaric> Any categorists here who've read the "Effecte Handlers in Scope" paper? I'm wondering if there's a more principled definition of their `Syntax` class -- ideally one that makes deriving the `weave` operation more mechanical.
08:27:52 <rwbarton> I thought ^? uses a Maybe
08:27:55 <rwbarton> ^?! makes it fail
08:28:27 <jtakacs> Data.Bits..&.    is this a typo?
08:28:52 <jtakacs> :t  Data.Bits..&.
08:28:52 <lambdabot> parse error on input ‘Data.Bits..&.’
08:29:00 <rwbarton> jtakacs, no :)
08:29:02 <Iceland_jack> :t (Data.Bits..&.)
08:29:03 <lambdabot> Bits a => a -> a -> a
08:29:12 <Iceland_jack> > 10 Data.Bits..&. 15
08:29:13 <lambdabot>  10
08:29:41 <quchen> rwbarton: I meant "fail" as in "fail gracefully with Maybe"
08:30:05 <rwbarton> oh I see
08:30:27 <quchen> I usually say "blow up" when I mean ⊥ ;-)
08:30:35 <rwbarton> I read all the lines except the one you were correcting :/
08:31:16 <quchen> The lines weren't really clear anyway. I should probably have lpasted it.
08:41:46 <shlevy> Why does cabal init create a file with no EOL?
08:45:43 <ParahSailin> shlevy: it does?
08:46:00 <shlevy> Did just now for me
08:46:36 <ParahSailin> oh yeah, i guess it does, vim says [noeol]
08:47:43 <kazagistar> just curious, why is that something people find important?
08:50:22 <dfeuer> kazagistar, I don't know, but my guess is that some people may be concerned that it breaks the simple rule that every line ends with "\n".
08:51:10 <Fuuzetsu> yes, it's a long-standing convention to end a file with \n
08:51:15 <kazagistar> ah, I guess that could make the logic for parsing require an extra "or" in the conditional or whatever
08:51:25 <glguy> It's part of the POSIX definition of a text file
08:51:35 <Fuuzetsu> oh, cool
08:51:46 <donri> does that meaen an empty file is never a text file
08:52:00 <glguy> No, a line in a text file ends with a newline
08:52:02 <Fuuzetsu> empty file is an empty file
08:52:07 <glguy> so an empty file is 0 lines
08:52:29 <kazagistar> I guess the POSIX definiton answers my question of "why people care", because people care about standards irrelevant of the actual meaningfulness of the standard
08:52:42 <shlevy> kazagistar: I care because my tools care :D
08:52:42 <quchen> donri: It's kind of similar to how 0 is a speed, a voltage, and a force. An empty file could be many things.
08:52:49 <donri> ;)
08:52:53 <tolt> shlevy: what tools?
08:52:58 <glguy> kazagistar: Because it's part of the standard, tools expect it
08:53:05 <shlevy> tolt: vim, cat
08:53:08 <donri> quchen: everything is nothing, nothing is everything
08:53:22 <tolt> Ahh. I thought you had some tool for cabal.
08:53:24 <shlevy> I expect a line at the end if I cat a file
08:53:24 <Pythonfant> kazagistar: if you want to get all lines in a file and it isn't terminated by a newline the last line will be cut off by many “lines” functions in different languages if it's empty requiring an extra check
08:53:30 <dfeuer> shlevy, what does cat do with lines?
08:53:30 <shlevy> ah no
08:53:37 <quchen> Because so many tools ignore it, so many tools are built to work even if there's no LF at the end.
08:54:23 <kazagistar> hmm, I assume it messes up the prompt on the line after cat if you dont have a newline at the end of the file?
08:54:27 <kazagistar> or something?
08:54:33 <donri> one thing it makes more difficult is appending lines
08:54:34 <shlevy> Yeah
08:54:39 <shlevy> It's not exactly messed up
08:54:42 <dfeuer> shlevy, ah, cat can number lines for you, or mark their ends... interesting.
08:54:42 <shlevy> just unexpected
08:54:47 <quchen> It doesn't mess it up, it just does not print the LF because there is no LF ;-)
08:55:08 <relrod> what's weird is that looking at the source, it just uses writeFile, but if I (writeFile "foo" ""), vim doesn't complain about foo.
08:55:17 <kazagistar> and what messes up about vim? just that it complains about the newline?
08:55:25 <shlevy> kazagistar: Yup
08:55:35 <shlevy> Not worth opening a bug report for, say
08:55:41 <shlevy> But worth firing off a question in IRC :D
08:55:49 <kazagistar> but does it complain cause the standard says it should or why?
08:55:58 <shlevy> Not sure
08:56:16 <donri> > let str = "hi\nthere" in str == (unlines . lines) str
08:56:17 <lambdabot>  False
08:56:36 <kazagistar> perpetuating standards without knowing the reason other then "cause that is how we decided at some point I guess" leaves a bad taste in my mouth
08:57:00 <donri> it's more warm and fuzzy when unlines is the inverse function of lines
08:57:07 <shlevy> kazagistar: OTOH, not having investigated personally I think the default should be to follow the standard
08:57:19 <shlevy> Standards can be broken, but I see no reason to here
08:57:22 <quchen> Send a one-byte patch, it will probably be merged
08:57:25 <shlevy> I see no strong reason not too :D
08:57:33 <shlevy> but no reason at all to break it
08:57:37 <quchen> Cheapest way to become a Cabal contributor by far! :-D
08:58:36 <kazagistar> > let str = "hi\n\nthere\n" in str == (unlines . lines) str
08:58:38 <lambdabot>  True
09:00:02 <shlevy> :D
09:00:03 <shlevy> Turns out
09:00:08 <shlevy> I have a cabal clone on my laptop
09:00:13 <donri> > let str = "hi  there " in str == (unwords . words) str  -- i weep at how words and lines are assymetrical
09:00:14 <lambdabot>  False
09:00:16 <shlevy> checked out to branch "cabal-init-trailing-newline"
09:00:18 <alar> Greetings! Can anybody help me with Language.C.Quote ?
09:00:26 <kazagistar> hmm, I guess the standard makes sense... it makes parsing a touch easier at the cost of 1 byte per file, and makes empty files be 0 lines long, instead of 1, which also makes sense
09:00:39 <Rastus_Vernon> Is there any reason (&&) is right-associative rather than left-associative?
09:01:04 <rwbarton> if you have a simple line-based format, you can cat together files provided there are newlines at the end
09:01:05 <glguy> Rastus_Vernon: Because it checks its left argument first
09:01:11 <ion> If you have zero lines, you don’t need a newline. A character will start a line.
09:01:27 <Rastus_Vernon> gidogeek: Yes, but what's the point of that? Won't the result be the same in all cases?
09:01:42 <kazagistar> donri: probably because the symetrical version is in Data.List.Split, and is much less useful then the asymetrical versions
09:01:42 <Rastus_Vernon> Uh... tab completion completed to the wrong nick.
09:02:02 <ion> The file "\n" represents a single empty line, the file "" represents zero lines.
09:02:20 <dfeuer> I speculated on Stack Overflow that {from0 :: Enum a => a -> [a]; from0 n = [(toEnum 0)..n]} might sometimes be more efficient than {from0' :: (Enum a, Num a) => a -> [a]; from0' n = [0..n]} because in sufficiently polymorphic contexts the latter may necessitate passing two dictionaries (Enum for enumFromTo and Num for fromInteger) whereas the former would need only one (Enum for both enumFromTo and toEnum). Is this reasoning co
09:02:20 <dfeuer> rrect?
09:03:24 <glguy> Rastus_Vernon: It's just a minor efficiency gain in the case that it was possible to short circuit evaluation. I can't think of another reason
09:03:41 <gregnwosu> anyone know of a good setup for hacking haskell on emacs?
09:04:09 <Rastus_Vernon> gidogeek: I suppose that might explain it.
09:05:28 <ajcoppa> gidogeek is going to be quite confused when s/he next checks the IRC client :)
09:05:40 <dfeuer> Rastus_Vernon, let me think about that for a minute.
09:13:04 <dfeuer> Rastus_Vernon, it's much less important than that.
09:13:06 <dfeuer> a && (b && c) = case a of
09:13:06 <dfeuer>                      True -> case b of
09:13:06 <dfeuer>                                   True  -> c
09:13:06 <dfeuer>                                   False -> False
09:13:06 <dfeuer>                      False -> False
09:13:06 <dfeuer>                      
09:13:10 <dfeuer> (a && b) && c = case (case a of
09:13:12 <dfeuer>                            True  -> b
09:13:14 <dfeuer>                            False -> False) of
09:13:16 <ion> Please use a pastebin.
09:13:16 <dfeuer>                      True -> c
09:13:18 <dfeuer>                      False -> False
09:13:22 <dfeuer> Sorry, ion.
09:13:54 <dfeuer> The latter expansion will subsequently be transformed by the case-of-case transformation into the former.
09:14:48 <dfeuer> Since the compiler will generate the same code in any case, and needs a second step to get there if && is made left-associative, it might as well be right-associative.
09:15:24 <dfeuer> s/second/extra
09:16:42 <dfeuer> Make sense, Rastus_Vernon?
09:17:14 <shlevy> If I don't care about the order and the element type is hashable, how do I evaluate HashSet vs Set?
09:19:52 <dfeuer> shlevy, what sort of element type? How fast is hashing it?
09:20:05 <shlevy> dfeuer: string (FilePath) in this case
09:20:30 <pjdelport> You'll probably want HashSet, then.
09:20:54 <pjdelport> The more expensive comparison is (strings are the typical example), the more hashing is a win.
09:21:01 <dfeuer> Yes.
09:21:03 <shlevy> OK
09:21:08 <dfeuer> File paths, however,
09:21:14 <dfeuer> are not any old strings.
09:21:31 <dfeuer> You might be better off with some sort of prefix tree/trie.
09:21:37 <pjdelport> dfeuer: If they tend to share prefixes, you might want to look at a Trie instead.
09:21:41 <pjdelport> Yeah.
09:21:58 <shlevy> The vast majority of the paths will have the same prefix
09:22:26 <nosdk> If I have a type [a] then the a is universally quantified
09:22:37 <nosdk> but apparently it is not free...
09:22:51 <nosdk> im not sure what the difference is here
09:23:04 <pjdelport> shlevy: http://hackage.haskell.org/package/TrieMap-4.0.1/docs/Data-TrieSet.html
09:23:15 <shlevy> pjdelport: Thanks
09:23:31 <Desheng> @src (.*.)
09:23:32 <lambdabot> Source not found. You speak an infinite deal of nothing.
09:23:57 <Desheng> what does (.*.) mean in the definition of "on"?
09:24:15 <anbaric> nosdk: `x` is free in `f x` but not in `(\x -> f x)`; same deal with `[a]` vs. `forall a. [a]`
09:24:22 <Desheng> is that real Haskell or just a shorthand
09:24:25 <rwbarton> @src on
09:24:25 <lambdabot> (*) `on` f = \x y -> f x * f y
09:24:52 <geekosaur> Desheng: it's an arbitrary operator
09:24:55 <Desheng> this is where I'm getting that other notation from https://hackage.haskell.org/package/base-4.7.0.0/docs/src/Data-Function.html
09:25:00 <dfeuer> nosdk, I'm not sure of the context you're referring to.  Suppose you have  foo :: a -> [a].  This *actually* means  foo :: forall a . a -> [a].  In the type expression   forall a . a -> [a],   a is bound.  in the subexpression  [a], it is free.
09:25:01 <rwbarton> Desheng: it's just a name for the function that is passed as the first argument
09:25:55 <nosdk> anbaric: dfeuer : wouldnt it also make sense to say that a constructor for [] takes a type a that is unbound, and then gets bound in some context
09:26:12 <Desheng> could I define my own functions that way or is it internal to GHC in some way
09:26:20 <geekosaur> arbitrary operator
09:26:21 <pjdelport> Desheng: It's plain Haskell.
09:26:40 <geekosaur> > let x .*. y = y - x + 1 in 5 .*. 3
09:26:41 <pjdelport> > let (*) = (++) in "foo" * "bar"
09:26:43 <donri> > let (+) = (-) in 3 + 2
09:26:44 <lambdabot>  -1
09:26:45 <lambdabot>  "foobar"
09:26:45 <lambdabot>  can't find file: L.hs
09:26:47 <geekosaur> heh
09:26:50 <donri> (:
09:26:59 <dfeuer> In something like   data Foo a = Bar a (forall b . [b -> a])     the type variable  a  is free on the RHS, whereas the type variable  b  is bound.
09:27:06 <bergmark> donri: :3
09:27:10 <kazagistar> Desheng: they could have made it { g `on` f = \x y -> g (f x) (f y) }, but they made g an infix instead
09:27:22 <geekosaur> you can use any Unicode "symbol" character as part of a user defined operator
09:27:39 <nosdk> dfeuer: so a is free there not universally quantified?
09:27:40 <geekosaur> (restriction on first character being :, that's for infix constructors)
09:27:53 <dfeuer> nosdk, the type constructor [] takes a type of kind *. It doesn't care whether that is "free" or "bound".
09:28:04 <nosdk> i know
09:28:12 <Desheng> ok I think I'm getting it. thanks everyone
09:28:12 <nosdk> im just trying to understand the terminology
09:28:19 <dfeuer> nosdk, the type constructor Foo can be seen as a function from types to types.
09:28:44 <dfeuer> Think about it conceptually as   Foo = [typelambda] a  ->   Bar   .....
09:28:55 <nosdk> dfeuer: " polytypes containing free variables are not represented in programming languages like Haskell"
09:29:08 <nosdk> http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Free_type_variables
09:29:13 <nosdk> thats what im trying to understand
09:29:14 <dfeuer> Yeah, I don't know what that means. Ask an expert :P
09:32:00 <abaw> hi
09:32:12 <abaw> I was playing with Snap
09:32:17 <dfeuer> nosdk, maybe the last sentence of that paragraph will help: "As a consequence, a free type variable cannot be interpreted better than stating it is a monotype without knowing the context. Turning the statement around, in general, a typing is not meaningful without a context."
09:32:18 <anbaric> nosdk: Right, so say you have an expression `\x -> let y = ([], x) in snd y`.  During type inference, what type does `y` get?
09:32:25 <abaw> But I could not make my code typechecking, could somebody help?
09:32:26 <abaw> http://paste.lisp.org/display/143112#1
09:32:34 <rwbarton> nosdk: consider an example like   test f = let c g = f . g in (c f, c id)
09:32:43 <rwbarton> or anbaric's example, same idea
09:33:12 <rwbarton> actually my example is slightly broken
09:33:32 <nosdk> anbaric: its not assigned a type until its used
09:33:52 <nosdk> the type is not fully qualified in that 'instance'
09:34:20 <nosdk> I think I got it though, thanks
09:34:24 <anbaric> No, HM checks the RHS of the definition, generalizes that type, and assigns y something like `forall a. ([a], b)`, where `b` is x's type
09:35:05 <nosdk> ok, so all type variables are implictly unversally quantified by default?
09:35:52 <rwbarton> in a type signature that you write
09:36:15 <ReinH> ocharles: ping
09:36:17 <cloudhead> abaw: maybe replace the `a` in `S.InputStream ByteString -> Enumerator ByteString IO a` with `(Step Builder IO a)`?
09:36:21 <cloudhead> not sure..
09:36:39 <anbaric> When you write out a type signature, yes, but during type inference there are types with free variables that aren't quantified
09:36:41 <cloudhead> your type is too generic
09:36:49 <abaw> cloudhead: I could not understand that mystery "This (rigid, skolem) type variable is bound by" message at all.
09:37:04 <abaw> but this typechecks: enumFile "" $= enumByteStringToBuilder
09:37:17 <abaw> enumFile "" has type Enumerator ByteString IO a
09:39:29 <cloudhead> well, you're telling it that any type `a` would work, when it is not the case
09:39:45 <cloudhead> only a `Step Builder IO a` would work
09:40:39 <cloudhead> try removing the type signature of isToEnum, see what happens
09:41:13 <rwbarton> oh, addToOutput has a higher-rank type
09:41:48 <sveit> i asked this yesterday but got disconnected. if i have some datatype and do calculations on it, does it make sense to add a field to that datatype to store the results of the calculation, or would calling the function multiple times on the same data structure not incur overhead?
09:41:53 <abaw> rwbarton: What does a higher-rank type mean? something related to forall?
09:42:31 <abaw> cloudhead: after removing type signature of isToEnum, I still got similar error messages
09:42:51 <rwbarton> yes
09:43:00 <rwbarton> addToOutput :: MonadSnap m => (forall a. Enumerator Builder IO a) -> m ()
09:43:22 <rwbarton> that means you need e $= enumByteStringToBuilder :: forall a. Enumerator Builder IO a
09:44:45 <rwbarton> which means you need e :: forall a. Enumerator ByteString IO (Step Builder IO a)
09:45:03 <pjdelport> sveit: It Depends.™
09:45:13 <rwbarton> but e cannot be polymorphic because it was bound by do notation (>>=)
09:45:17 <rwbarton> :t (>>=)
09:45:18 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:45:34 <pjdelport> sveit: Generally, you shouldn't need to manually memoize like that if lazy evaluation and sharing will do the job.
09:45:52 <sveit> pjdelport: sharing
09:45:55 <sveit> ?
09:47:13 <pjdelport> sveit: If you say anything like "let x = <expensive> in {... code that uses x ...}", then you're (more or less) guaranteed that x will only be evaluated once: every occurrence in the body will share its value.
09:47:31 <pjdelport> sveit: Same for bindings in where clauses, function arguments, and so on.
09:47:55 <sveit> pjdelport: my particular use case is the calculation of certain numbers that are used many times to calculate indices. so if i bind in a let like that it should work?
09:48:18 <sveit> pjdelport: follow-up: what if instead of using let x = ... i just call the function inline. is that considered different?
09:48:29 <abaw> rwbarton: So it means I could not get a Enumerator from an IO action? Because it seems Enumerator is always polymorphic
09:48:32 <sveit> of what if i bind in a "where"?
09:49:09 <dfeuer> sveit, let and where are basically the same, once "desugaring" is complete.
09:49:46 * hackagebot git-annex 5.20140707 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140707 (JoeyHess)
09:49:48 <rwbarton> abaw: it seems to be you could ask for an Enumerator ByteString IO (Step Builder IO Void), and then use (fmap . fmap) absurd
09:49:57 <dfeuer> You pretty much want to give something a name (using let or where or case) in the outermost scope in which you want it to be saved.
09:49:58 <rwbarton> assuming Step is a functor
09:50:18 <sveit> dfeuer: ok, so let/where are fundamentally different than calling a function inline
09:50:45 <pjdelport> sveit: If you call it inline, it's basically getting bound as the parameter of whatever you pass it to.
09:50:50 <anbaric> sveit: if you use the name more than once, yes
09:50:54 <abaw> rwbarton: let me try it, thanks for the hint
09:51:19 <pjdelport> sveit: If it only appears at one call site, there's no need to lift it higher; it will be shared inside whatever function you pass it to.
09:51:20 <shlevy> I'm wrapping a protocol that requires you to send a request and then wait for a response (for possibly very long time) before sending a new request over the same connection in a threadsafe manner. Is it better to just have a mutex for the connection socket or an internal queue with a single thread processing requests and sending back responses?
09:51:20 <rwbarton> abaw: this seems like a bit of an arcane workaround
09:51:53 <hexagoxel> _Vi: i (now) have tried out Codec.Wav, you still looking for example code?
09:52:12 <dfeuer> sveit, yes, pretty much.  If you say  let x = [expensive calculation] in [do something with x a bunch of times]   that will keep it from redoing the calculation.  If you say   [do a bunch of times] (let x = expensive calculation in dosomethingwithx)   then it will get redone a bunch of times. PRobably.
09:52:17 <rwbarton> abaw: actually if you reorganize a little and return 'is' from toByteStringEnum, you can then perform isToEnum purely, right? and not have to pass a polymorphic value through <-
09:52:28 <pjdelport> sveit: So if you have "foo bar (expensive thing) baz", there's no advantage in saying "let x = expensive thing in foo bar x baz"
09:53:12 <pjdelport> sveit: But, if you have "foo (expensive thing) + bar (expensive thing)", then there *is* an advantage in saying "let x = expensive thing in foo x + bar x"
09:53:15 <dfeuer> Sorry, my example was bad. Pay attention to pjdelport's instead.
09:53:57 <pjdelport> sveit: In the latter example, the two uses of x are shared (in implementation terms, they point to the same thunk / value at runtime)
09:54:17 <abaw> rwbarton: Thanks. You are right, it now type checks
09:55:18 <pjdelport> sveit: A sufficiently smart compiler *might* be able to automatically spot and share the "expensive thing" for you (this optimization is called CSE, or http://en.wikipedia.org/wiki/Common_subexpression_elimination ), but it's not guaranteed.
09:55:31 <pjdelport> (in the second example, i mean)
09:55:42 <sveit> dfeuer, pjdelport: ok, so i will give a specific example if that's ok with you guys? i have some function (`i`) that indexes a data structure, and i have some function "f m j = m `i` (calci m j) where calci m j = foldr (\i j -> blah) $ zipWith (*) (expensiveThing m) (cheapThing j)
09:55:57 <sveit> if i understand correctly what you have been saying just writing it like this should be fine?
09:56:25 <pjdelport> sveit: yep.
09:56:26 <ocharles> ReinH: G'day sir
09:58:03 <rwbarton> it looks like the only potential for sharing there is that 'expensiveThing m' does not depend on 'j'
09:58:18 <pjdelport> sveit: http://en.wikibooks.org/wiki/Haskell/Graph_reduction#Graph_Reduction_.28Reduction_.2B_Sharing.29 has a bit more on it, if you're interested.
09:58:45 <sveit> rwbarton: exactly, so i was hoping that expensiveThing only gets called once for each 'm'
09:58:46 <rwbarton> if you call f repeatedly with the same m and different j, expensiveThing m will be recomputed
09:58:56 <sveit> really?
09:59:11 <rwbarton> yes, because it occurs under a \m ->
09:59:22 <sveit> ah i see
09:59:24 <Desheng> if I'm writing a datatype to represent the header of a binary file, and one field is 48 Word8's long, how can I type that field to strictly be 48 of them instead of a generic [Word8] ?
09:59:41 <sveit> rwbarton: but if it occured under just a \j -> it wouldn't, right?
10:01:27 <pjdelport> sveit: in this case, it sounds like you want to share the reference to "calci m j" itself?
10:01:51 <Desheng> is there even a way to express natural numbers in the you're system without having to write them out as Church numerals in the long form
10:02:00 <Desheng> type system*
10:02:34 <rwbarton> sveit: even then it would naively be recomputed, but then GHC might lift it outside the \j -> with optimizations enabled
10:03:17 <anbaric> better not to rely on that, though
10:03:24 <sveit> rwbarton: ok, so then what if i had "f m j = m `i` val where val = foldr (\i j -> blah) $ zipWith (*) (expensiveThing m) (cheapThing j)?
10:03:43 <sveit> then expensiveThing only gets computed once for each m?
10:03:46 <rwbarton> it still appears under the "\m ->" in f
10:04:11 <dfeuer> Desheng, you can hack up various things.
10:04:14 <anbaric> (and the \j ->)
10:04:15 <rwbarton> which is unavoidable, since it's a function of m
10:04:46 <sveit> rwbarton: ok, so it will get re-computed for the same m regardless of what I do?
10:04:57 <rwbarton> the \j -> too, yes. so you could write "f m = let et = expensiveThing m in \j -> m `i` foldr (\i j -> blah) $ zipWith (*) et (cheapThing j)"
10:04:58 <sveit> aside from memoizing expensiveThing
10:05:24 <rwbarton> then you could reuse "f m", if you were careful to do so
10:05:33 <rwbarton> and call it at different j
10:05:35 <_Vi> hexagoxel. Yes. I want to split a wav file to multiple ones by silence.
10:05:37 <dfeuer> Desheng, Church numerals are certainly one option, but you can use a more general nested representation if you like. It's probably not worth the trouble for your application—just use a Vector unless you have a need to do something else.
10:06:58 <_Vi> hexagoxel, Where to find sample codes for little Haskell libraries in general? Often there are only a documentation with short phrases, not explaining the "big picture"...
10:07:17 <sveit> ok, but if in my application i have f m j being called many times for a single m that changes infrequently, it might make sense just to cache the result in the structure of m?
10:07:23 <anbaric> Desheng: are you sure you don't mean Peano rather than Church?
10:07:53 <dfeuer> anbaric, yes, that's probably what is meant. I'm too tired to catch such things.
10:08:12 <Desheng_> whichever one is like "succ succ 0" meaning 2
10:08:17 <rwbarton> sveit, yes it might well make sense to do that
10:08:36 <Desheng_> apologies for misusing terms
10:08:37 <anbaric> sveit: yes, though you may want a different type for "regular m" and "m annotated with expensiveComputation m's result"
10:12:16 <Desheng> yeah definitely meant Peano
10:13:07 <hexagoxel> _Vi: yeah, often documentation is somewhat lacking. in this case, i was able to understand the interface just by looking at the types.
10:13:33 <hexagoxel> i don't know of any repository of sample code.
10:13:39 <sveit> anbaric: or a different constructor?
10:13:51 <anbaric> Desheng: You could write some type functions and some synonyms to say e.g. `Two * Ten + Three` (or more ambitiously '[Two, Three] with a promoted list)
10:14:51 <hexagoxel> _Vi: in my code i currently only output wav; i'll post a pastebin, mom.
10:15:29 <Desheng> is that the typical way of having a list whose length is type-enforced?
10:15:43 <donri> Desheng: http://hackage.haskell.org/package/base-4.7.0.0/docs/GHC-TypeLits.html
10:16:01 <Desheng> or do people end up using generated code that essentially boils down to "List' a1, a2 ... a48"
10:16:04 <Desheng> reading
10:16:50 <donri> enable DataKinds and import GHC.TypeLits and you can have "2 * 10 + 3" in a type
10:17:00 <_Vi> hexagoxel, I look at that and have a feeling that I have all parts in hand, but can't assemble them into the whole thing.
10:17:11 <lysergide___> Hi
10:17:30 <benzrf> donri: good lord
10:17:51 <_Vi> hexagoxel, Program that just round-trips (imports and exports) the wav file is easy. I need to look into the samples and analyze them.
10:19:07 <donri> benzrf: there are limitations though, but i don't remember the particulars
10:20:18 <donri> like 2 + 3 not unifying with 3 + 2 etc, stuff like that
10:21:59 <rwbarton> 2 + 3 will unify with 3 + 2 because they will both reduce to 5, but for variables a and b, a + b won't unify with b + a
10:22:33 <donri> oh yeah
10:22:35 <jfischoff> oh
10:22:46 <donri> i thought my assertion seemed weird :))
10:24:04 <lysergide___> For what kind of programs Haskell is truly superior to imperative languages ?
10:24:36 <dwcook> lysergide___, warning: That is a hard question to answer objectively.
10:24:40 <hexagoxel> _Vi: http://ideone.com/E8qXFD
10:24:48 <Eelis> lysergide___: puzzles like projecteuler stuff
10:25:03 <jfischoff> lysergide___: persistent concurrent programs.
10:25:15 <pjdelport> lysergide___: For programs written in Haskell.
10:25:23 <Eelis> lysergide___: and stuff which doesn't have to be fast.
10:25:32 <pjdelport> lysergide___: Anything else is subjective. :)
10:25:37 <lysergide___> Because I really enjoy Haskell.
10:25:53 <lysergide___> But I don’t know if learning it to master it is worth.
10:26:10 <dwcook> Enjoying it isn't enough?
10:26:13 <jfischoff> lysergide___: depends on what it is I suppose
10:26:20 <Desheng> is there one book that covers the history and motivation behind the category-extras package in general?
10:26:22 <pjdelport> lysergide___: On the other hand, it's often said that Haskell is one of the finest imperative languages, because of its strong first-class support for effects.
10:26:45 <Eelis> one of the finest imperative languages in which you cannot get the #1 benefit of imperative languages: efficiency
10:26:47 <dwcook> Desheng, the mind of edwardk perhaps :P
10:26:51 <Desheng> or alternatively, in what sort of books would I learn about those category theory constructs
10:27:17 <pjdelport> Eelis: Haskell is plenty efficient by most standards.
10:27:23 <dwcook> Desheng, as applied to CS or just on their own?
10:27:24 <Eelis> pjdelport: nope
10:27:31 <Desheng> either
10:27:40 <kwf> Eelis: What kind of efficiency issues are you talking about?
10:27:43 <moghedrin> Eelis: Then you should definitely never use python or perl...
10:27:49 <jfischoff> Desheng: Categories Steve Awodey
10:27:54 <Desheng> thanks
10:27:54 <Eelis> moghedrin: indeed!
10:28:02 <pjdelport> Eelis: And the efficiency of buggy code is zero. :) Haskell lets you avoid more bugs than weakly-typed languages.
10:28:06 <Eelis> kwf: google Haskell efficiency
10:28:13 <moghedrin> Eelis: Or Ruby... Or Erlang... In fact, you should never use anything but C or Fortran.
10:28:19 <dwcook> Desheng, try Awodey's Category Theory perhaps? That's not specific to CS but gives you the basics
10:28:19 <Eelis> moghedrin: nonsense. i write C++
10:28:31 <dwcook> Oh I was beaten to it
10:28:33 <moghedrin> Eelis: Oh, do you use the standard library stuff?
10:28:39 <Eelis> moghedrin: sure
10:29:08 <moghedrin> Eelis: Then C++ is inefficient too, if you would name Haskell inefficient. *shrugs*
10:29:12 <Eelis> moghedrin: how so?
10:29:20 <kwf> Eelis: no, I'm asking you for your opinion and experience. What issues have you run into in Haskell where it was inefficient for your needs?
10:29:39 <jfischoff> Eelis: you can’t beat C++ in terms of micro-optimizations, but it much easier to good thread utilizations in Haskell.
10:29:40 <kwf> I'm legitimately curious.
10:29:53 <hexagoxel> _Vi: i guess the main hassle with the task you described is the transformation from Int32 to Float and back (but that may be fine with working on the Int32s) and packing/unpacking of the Arrays.
10:29:59 <levi> Someone who thinks that a google search for 'Haskell efficiency' is a reasonable argument about the efficiency of Haskell programs clearly isn't worth engaging on the subject.
10:30:00 <Eelis> kwf: my experience is that with Haskell i have very little control over memory allocation
10:30:13 <Eelis> kwf: my experience is that with Haskell i have very little control over where things are in memory
10:30:15 <moghedrin> Eelis: Because the speed becomes -pretty- comparable if you're extensively using the C++ stdlib, in my experience.
10:30:24 <Eelis> moghedrin: then you're doing it wrong.
10:30:34 <moghedrin> Eelis: Or you're doing Haskell wrong ;P
10:30:57 <Eelis> yes, i could write C-ish Haskell, which seems to be how they make Haskell fast for the language shootout
10:31:04 <Eelis> is that what you recommend?
10:31:27 <Eelis> *faster
10:31:30 <Eelis> still dog slow compared to C++.
10:31:36 <kwf> Eelis, check out the REPA package — fast parallelizable array operations with fusion.
10:31:39 <moghedrin> Eelis: If efficiency is what you're primarily concerned about.
10:32:05 <kwf> There're lots of very fast libraries which allow you to write idiomatic Haskell that goes quite quick.
10:32:10 <levi> Eelis: Enjoy writing C++ then.
10:32:15 <Eelis> "quite quick" is not good enough
10:32:25 <Eelis> levi: i do!
10:32:34 <kwf> Eelis: What is your benchmark for "good enough"?
10:32:38 <Eelis> kwf: not slower than C+
10:32:39 <Eelis> C++
10:32:45 <kwf> At what task?
10:32:48 <levi> OK! Do you have some legitimate topic for discussion here, though?
10:32:55 <Eelis> kwf: HFT, network servers
10:33:17 <_Vi> hexagoxel, "ideone" says "compilation error"; I haven't yet tried to work with arrays in Haskell. Currently stopped at that "Parser" thing...
10:33:58 <Eelis> levi: i was answering questions. was that a trap to get me to say illegitimate things? :P
10:34:49 <Eelis> also, i love writing programs in Haskell, and do so for toy stuff that doesn't have to be fast.
10:35:21 <kwf> Eelis: nobody here is trying to trap you. I was genuinely curious about your experience. :)
10:35:33 <pseudolio> Most software is toy stuff that doesn't have to be fast.
10:35:34 <Eelis> kwf: cool, then explain to levi that that's legitimate :P
10:36:01 <Eelis> pseudolio: alas, my day job is stuff that's not toy and that does have to be fast.
10:36:46 <Eelis> so for now i cannot use Haskell at work, though there is definitely interest in Haskell at work. for the slow things :P
10:36:47 <jfischoff> Eelis: I write Haskell for my day job for things that need to be fast.
10:36:50 <levi> Eelis: You don't have to justify yourself to me.
10:37:04 <Eelis> jfischoff: splendid!
10:37:55 <jfischoff> Eelis: https service handling 1000’s of requests a second in the 100 - 200 microsecond range
10:37:56 <Eelis> i also once tried to write a little game in Haskell, but after spending like a week trying to debug GC stutters, i gave up
10:38:22 <rwbarton> defining "fast" as "at least as fast as language X" is a clever trick, now language X is always fast but language X' that is equally fast on average is only fast ~50% of the time
10:39:07 <Eelis> you can pretend it's trickery if you like, but if i have to tell my coworkers "i'd like to switch to language Y", they'll ask "won't it be slower than C++?"
10:39:35 <hexagoxel> _Vi: i added the relevant imports to my paste. the code is not supposed to run as is, but you can easily incorporate it into a little example program. i think i have documented all relevant bindings.
10:40:07 <carter> Eelis: woulu agree that a custom mini language  for your application domain that directly emits LLVM IR and has custom LLVM passes would be faster than C++?
10:40:22 <Eelis> carter: nope
10:40:28 <carter> lol, why
10:40:50 <rwbarton> faster than C++ doesn't matter
10:40:51 <Eelis> because why would it be faster?
10:40:52 <rwbarton> only slower than C++
10:40:57 <squimmy> is there a map for monads? something that looks like (a -> b) -> m a -> m b
10:41:03 <Nik05> fmap
10:41:09 <ajcoppa> :t fmap
10:41:10 <carter> Eelis: do you understand how clang ocompiles c++?
10:41:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:41:13 <anbaric> squimmy: liftM, or fmap
10:41:14 <Eelis> carter: no, i use gcc.
10:41:16 <kwf> squimmy: All monads are functors. :)
10:41:18 <squimmy> ah. monads are implicitly functors?
10:41:28 <dwcook> squimmy, not *quite* yet, in practice, as it happens, but soon
10:41:33 <jfischoff> Haskell is slower then C++ in the same way C++ is slower then assembly. For small projects this true, but for large scale software the ability to quickly safely refactor is what you need to make something fast.
10:41:34 <levi> Most of them are; all of them will be soon.
10:41:34 <squimmy> kwf, Nik05: thanks
10:41:38 <kwf> squimmy: fmap = liftM
10:41:39 <dwcook> squimmy, if you want to be perfectly safe, knowing only it's Monad, use liftM, which is equivalent to fmap
10:41:53 <lysergide___> Describe what is a monad in less than five words
10:41:53 <squimmy> ok. thank you :)
10:42:03 <Eelis> jfischoff: that doesn't make any sense to me.
10:42:07 <dwcook> lysergide___, impossible, the definition has more than five words.
10:42:25 <kwf> squimmy: To clarify: all monads *should* be functors, and not all monads are functors because of historical reasons which hopefully are going to be corrected soon.
10:42:49 <anbaric> Eelis: what matters almost always is the curve of time invested / performance achieved, not the theoretical maximum performance
10:42:54 <squimmy> is this "soon" as in months or as in years?
10:42:57 <lysergide___> I can’t get what is a monad aha
10:43:06 <lysergide___> I read stuff about it
10:43:09 <dwcook> squimmy, an upcoming release of GHC. Months, I guess?
10:43:09 <lysergide___> But it is unclear
10:43:14 <squimmy> cool
10:43:25 <levi> lysergide___: Asking for a <5 word explanation isn't going to help. Do you understand what a Functor is?
10:43:25 <Adeon> a major GHC release?
10:43:28 <Eelis> anbaric: indeed! so the theoretical maximum performance of Haskell is of no interest to me if it's super hard to achieve it, when it's almost trivial to achieve fantastic performance in C++..
10:43:30 <kwf> squimmy: In GHC 7.10, Applicative will be a superclass of monad, and since Functor is already a superclass of Applicative, this will make everything nice again.
10:43:31 <moghedrin> lysergide___: Just try to use it, as well as reading. Eventually, it clicks.
10:43:46 <jfischoff> Eelis: Many time the slow downs in large systems are from one peices doing useless conversion, to fit with another piece. The fix is to refactor, but in a large like C++ this happens less then in Haskell
10:43:46 <kwf> GHC 7.10 is slated for release sometime early next year.
10:43:48 <ajcoppa> lysergide___: there are a couple good resources you can use to get basically familiar, but it probably won't "click" until you program with them a few times
10:43:56 <_Vi> hexagoxel, Tried to make something runnable from your sample: http://ideone.com/w056BA  .   Do you have a part for reading samples instead of writing? For example, just printing each sample with putStrLn ?
10:43:56 <ajcoppa> lysergide___: what are you using to learn haskell?
10:44:01 <jfischoff> Eelis: for small projects this doesn’t matter
10:45:10 <Eelis> jfischoff: yeah, refactoring in Haskell is nice if you write idiomatic Haskell. but if you write C-ish Haskell in order to be fast, will it still be nice to refactor?
10:45:13 <dwcook> lysergide___, do you understand Haskell's type system?
10:45:15 <lysergide___> ajcoppa: « Haskell Programming language » found on wikibooks
10:45:44 <ajcoppa> learn you a haskell and brent yorgey's CIS194 course are two good, free introductory resources we like to recommend
10:45:50 <ajcoppa> @where lyah
10:45:50 <lambdabot> http://www.learnyouahaskell.com/
10:45:57 <lysergide___> dwcook: Yes I thinkso.
10:46:02 <ajcoppa> http://www.seas.upenn.edu/~cis194/lectures.html for the course
10:46:05 <carter> Eelis: yup, the C ffi for haskell is REALLY easy to use
10:46:06 <carter> :)
10:46:08 <dwcook> lysergide___, how about typeclasses?
10:46:16 <hexagoxel> _Vi: meh, my code had some errors. i added a better sample at http://ideone.com/xDbUiR
10:46:32 <carter> Eelis: i have hand written simd C that i invoke in certain inner loops
10:46:32 <hexagoxel> this time, i verified that it compiles :D
10:46:51 <Eelis> carter: right, i want to avoid having to use two languages, one fast and one slow
10:46:53 <jfischoff> Eelis: I’m sure you can write hard to refactor Haskell, but I can say that having worked on project that ~30 have commited to, the code is usually straightforward to refactor.
10:46:55 <Eelis> i'd rather just use the fast one.
10:47:35 <lysergide___> dwcook: Not really.
10:48:01 <dwcook> lysergide___, okay, read one of the introductions mentioned to understand typeclasses at least on a basic level. Monad is a typeclass so that is information you'll need.
10:48:04 <hexagoxel> _Vi: no, i do not have input yet. but gimme a second :)
10:48:04 <Eelis> jfischoff: how do you do fast array updates?
10:48:15 <lysergide___> dwcook: Ok thank you !
10:48:36 <carter> Eelis: same as in any other language
10:48:37 <jfischoff> Eelis: I don’t
10:48:39 <carter> write to a memory locality
10:48:44 <carter> Eelis: i write numerical computing stuff in haskell
10:48:45 <dwcook> lysergide___, I can tell you this now, though: All the information *required* to understand Monad is present in the typeclass definition and its associated laws. That said, using it is probably the best way to actually come to understand it.
10:48:57 <Eelis> what's a "locality"?
10:48:59 <carter> *llocation
10:49:03 <benzrf> lysergide___: do you understand functors yet
10:49:04 <Eelis> so an IORef?
10:49:08 <carter> or an Array
10:49:15 <jroesch_> jfischoff: I have found that the difficulty of refactoring Haskell is low, especially compared to languages like Ruby
10:49:16 <benzrf> lysergide___: because you should absolutely not be trying to grok monads until you know functors
10:49:16 <carter> Mutable Arrays or Vectors
10:49:16 <jfischoff> Eelis: at work that is. On my own, yeah I Ptr or a ByteArray
10:49:34 <carter> @hackage vector is a good vector / 1dim array lib
10:49:34 <lambdabot> http://hackage.haskell.org/package/vector is a good vector / 1dim array lib
10:50:05 <Eelis> so what happens if i update an element with one of those array/vector packages?
10:50:05 <jfischoff> Eelis: Vector is a wrapper around ByteArray and MutableByteArray among others
10:50:08 <benzrf> jroesch_: i enjoy ruby but i gotta say its pretty unpleasant to be able to misspell a method name and have it be a rnutime error
10:50:13 <_Vi> hexagoxel, Am I expected to use functions from "Data.Audio" when working with "Codec.Wav" package?
10:50:14 <benzrf> ;=;
10:50:14 <jfischoff> Eelis: its just memory
10:50:20 <carter> Eelis: the memory location is written
10:50:22 <carter> to
10:50:24 <lysergide___> benzrf: Ok I will try to understand functors too
10:50:29 <Eelis> what happened to immutability?
10:50:30 <carter> same as in any other language
10:50:34 <carter> Eelis: you can have either
10:50:36 <carter> both are options
10:50:44 <carter> and certain codes work better one way or another
10:50:56 <jfischoff> Eelis: it is immutable from the outside if you use ST that is
10:51:00 <Eelis> also, if Haskell is easy to make fast, why is it so much slower than C++ in the shootout?
10:51:11 <carter> Eelis: because the shootout isn't a representative sample of code
10:51:15 <jfischoff> Eelis: small programs
10:51:17 <carter> and no one bothers to tune it
10:51:19 <jroesch_> benzrf: writing and refactoring are different things, having spent a bunch of time refactoring 300kloc+ recently I can definitely see how a typechecker and compiler would of prevented pretty much all the issues I've run into
10:51:20 <levi> Wheee.
10:51:21 <carter> at least not recently
10:51:21 <hexagoxel> _Vi: well it is the same package. (modules Data.Audio and Codec.Wav are both in the package "HCodecs")
10:51:31 <_Vi> hexagoxel, Your sample imports Data.Audio, but I don't see functions being invoked from it. -- I usually use "import qualified" because of this...
10:51:40 <benzrf> jroesch_: i am referring to refactoring
10:51:40 <Eelis> carter: wait, what? it seems like there has been /extensive/ effort to make the Haskell shootout programs fast
10:51:47 <carter> not in the past 2 years
10:51:49 <carter> before that yes
10:52:01 <carter> but i'm not aware of anyone actually doing it more recently
10:52:02 <benzrf> jroesch_: refactoring involves moving things around
10:52:03 <carter> maybe someone has
10:52:06 <carter> idk
10:52:08 <benzrf> which requires typing new names in a lot of places
10:52:12 <hexagoxel> _Vi: i think i only use Data.Audio.Audio.
10:52:19 <Eelis> jfischoff: why would that give C++ an advantage?
10:52:21 <carter> i'm more itnerested in making it easy to write codes that compete with hand tuned fortran
10:52:42 <Eelis> in what sense is the shootout biased in favor of C++?
10:53:30 <carter> more people with freetime use c++?
10:53:35 <carter> so more yaks of polish
10:53:44 <carter> idk
10:53:53 <Eelis> i think the answer is obvious :D
10:53:57 <Nik05> who doesnt use c++?
10:53:57 <carter> Eelis: have you ever used Eigen?
10:54:02 <Eelis> carter: nope
10:54:08 <carter> Eelis: do you know what it is?
10:54:11 <jfischoff> Eelis: Because C++ is better at microoptimizations. The same reason assembly is always going to win if your program has to be 256 bytes
10:54:14 <Eelis> carter: nope
10:54:21 <jroesch_> I was more making the point that I find it tolerable to write code in Ruby, but refactoring is one of the more painful things I've ever done, especially on an active code base where you have people turning out at least a 1000 commits a month, and you need to juggle merges the whole time which makes the process even more difficult
10:54:23 <carter> ok, its an array computation library in ahskell
10:54:29 <Nik05> probably something with eigenwaardes
10:54:48 <carter> i mean C++
10:54:50 <Eelis> jfischoff: right.
10:55:02 <carter> i'm writing something that could be viewed as an analogous tool in haskell
10:55:08 <Adeon> there are c++ programs in the shootout in the same speed ballpark as the haskell implementation
10:55:11 <_Vi> hexagoxel, Is it OK to create a push request to HCodecs with a README with your samples when they will be ready? (now the project does not have a README at all)
10:55:15 <Adeon> but they also have many more program implementations
10:55:23 <carter> https://bitbucket.org/eigen/eigen/ is the c++ version
10:55:25 <carter> Adeon: oh?
10:55:35 <jfischoff> Eelis: There are some things I will be able to write faster with C++ and some with Haskell. The larger the scale the greater chance Haskell will be faster.
10:56:03 <Eelis> jfischoff: you mean by the aforementioned logic whereby you just say that ease of refactoring equals speed?
10:56:06 <hexagoxel> _Vi: sure. currently, your example was even a bit better as you had a sine instead of just zeros :D
10:56:22 <Eelis> jfischoff: (i don't buy that)
10:56:30 <jfischoff> Eelis: Yes, profile guide refactoring is the key to getting large system fast
10:56:51 <Eelis> hehe, i can't even begin to imagine the horror of using cachegrind with Haskell code
10:57:00 <Adeon> yeah when you look at the programs, they tend to have something like 10 C++ programs
10:57:44 <Adeon> but no one's code looks like it would be what you would actually write
10:57:54 <_Vi> hexagoxel, Can you make a stub of stateful WAV reader? It should 1. read more and more samples from input file; 2. be able to to IO (i.e. save other WAV files); 3. have state, like with "unfold".
10:58:02 <carter> hrm, eigen is 130k LOC
10:58:24 <Eelis> Adeon: my impression is that the C++ programs in general are *WAY* closer to idiomatic C++ than the Haskell programs are to idiomatic Haskell.
10:58:44 <_Vi> hexagoxel, (or at least tell which type signature should such function have)
10:59:59 <levi> I'm not sure either Haskell or C++ can be said to have a single idiomatic style. They're both very mature and flexible languages, with several different styles that can be used and different idioms involved.
11:00:14 <carter> levi++
11:00:51 <Eelis> feel free to deny that the Haskell programs in the shootout are hacked more out-of-paradigm than the C++ ones :D
11:00:51 <zwer> from what I've seen most C++ programs are closer to idiomatic C than modern, idiomatic C++. just count the number of programs including cstdio and cstring
11:01:06 <shapr> edwardk: Do you ever dream in category theory?
11:01:07 <kazagistar> idiomatic is a poorly defined target... average might be a better way to try to compare, and on average, people make a lot of silly performance and complexity mistakes and fail to see nice idomatic ways to do things all the time
11:01:20 <levi> If you approach C++ as a "really fast" language, you probably write code that looks like the Shootout C++ code.
11:01:29 <squimmy> is there a nice way to pattern-match inside a do block?
11:01:34 <Eelis> levi: how so?
11:01:42 <shapr> kazagistar: Is there a collection of those mistakes and how to do them correctly?
11:01:54 <dwcook> squimmy, I'd use a case expression, just like you'd do elsewhere
11:01:54 <_Vi> squimmy, "case x of"    ... -> ... ?
11:01:57 <Eelis> levi: oh, but that's okay, because such code is relatively close to idiomatic C++, which i enjoy writing
11:02:08 <Eelis> levi: by contrast, i hate writing C-ish Haskell
11:02:09 <Eelis> (i've done it)
11:02:15 <ocharles> kosmikus: bos! Good work :)
11:02:25 <ocharles> looking forward to meeting him, let alone speaking after him :)
11:02:25 <levi> Eelis: If we're just talking about your preferences... why are we talking about it again?
11:02:27 <hexagoxel> _Vi: both out and in now (i have not tested that code, only typechecked :D) http://ideone.com/xDbUiR
11:02:33 <dwcook> squimmy, for things with a single constructor and thus unlikely to fail the pattern match, sometimes people do the pattern matching in the bind syntax. E.g., (a, b) <- c
11:02:38 <Eelis> levi: i dunno why you keep asking that every now and then
11:02:48 <Eelis> levi: if you don't want to talk about this, don't press <enter>
11:03:04 <kazagistar> shapr: well, such collections exist, but they are spread out and not well categorized... there is some interesting research that remains to be done in this area, we tend to gloss over it
11:03:30 <shapr> kazagistar: Do you have links to those collections?
11:03:34 <dwcook> squimmy, you *can* use a pattern that will fail there. But then you fall back on the Monad fail method, which is widely spurned.
11:03:38 <squimmy> dwcook: cool. won't work for me in this case, but I'll keep it in mind
11:03:57 <squimmy> the Monad fail method?
11:04:04 <dwcook> @type fail
11:04:05 <lambdabot> Monad m => String -> m a
11:04:05 <pseudolio> Can you guys take this conversation to #haskell-vs-C++-pissing-contest or something?
11:04:07 <chrisdotcode> johnw: you around?
11:04:26 <dwcook> squimmy, it doesn't really belong as a Monad method. Not every instance has a sane definition.
11:05:48 <squimmy> dwcook: it looks like an attempt at a monadic "throw exception"?
11:05:53 <dwcook> A good example is Either. You'd either need to make up a Left or make up a Right.
11:06:38 <dwcook> squimmy, yeah, basically. It's used in the desugaring of the bind sugar, which is one reason I suggest not using a pattern that might fail there.
11:06:53 <dwcook> You can also use it explicitly but I wouldn't do so unless you were working with a specific instance.
11:07:01 <squimmy> ok
11:07:14 <dwcook> Thus my original suggestion, use a case expression.
11:07:47 <shlevy> Is there a mutex usable with forkIO (well, Async)?
11:08:56 <darthdeus> when is 7.8 officially coming out?
11:09:32 <levi> Isn't it already?
11:09:43 <darthdeus> I thought it was just RC?
11:09:44 <joelteon> it's been out for quite awhile
11:09:49 <darthdeus> oh sweet then :P
11:09:51 <joelteon> no, 7.8.2 is out
11:10:03 <darthdeus> I thought 7.8.3 will be the release and 7.8.2 is still RC
11:10:18 <rwbarton> RC versions have rc in the version number
11:10:45 <thoughtpolice> well, RCs will have a very long version number
11:10:56 <thoughtpolice> like '7.8.0.20140202' or whatever, where the last bit is the date the build came from
11:10:59 <rwbarton> well ok, I mean the common human name
11:11:03 <thoughtpolice> yeah
11:11:04 <rwbarton> right
11:13:02 <bitemyapp> johnw: hmm?
11:13:24 <_Vi> hexagoxel, Ready: https://github.com/giorgidze/HCodecs/pull/5
11:17:37 <hexagoxel> _Vi: do you plan to process stereo (or anything other than mono)?
11:17:46 <donri> shlevy: withMVar?
11:18:35 <_Vi> hexagoxel, Not sure... I just want to make a little program which splits one big audio file to multiple small ones, using silence (with threshold) as separator.
11:19:17 <hexagoxel> _Vi: because i noticed that stereo is encoded in an "interleaved" fashion i wav
11:19:19 <lithiumdeuteride> you'd better study up on MP3 headers
11:19:33 <lithiumdeuteride> there's a whole mess of poorly-standardized data in there
11:21:19 <_Vi> hexagoxel, How can it be non-interleaved, especially when streaming wav files over pipeline?
11:23:01 <hexagoxel> hmm yeah. what i mean is that Codec.Wav does not do the interleaving, so you might have to do it.
11:26:59 <kazagistar> shapr: I dont know of any for haskell (other then ones caught by hlint or whatnot) but there are listings for C++ and python and others... a simple strategy is to look at the top questions on stack overflow for a language, some of which are common errors
11:31:51 <DheedoRaanjha> Hi, I am new to haskell
11:32:16 <Pythonfant> DheedoRaanjha: hi, anything you need help with?
11:32:16 <DheedoRaanjha> I am stuck on something
11:32:37 <pjdelport> @where lpaste
11:32:38 <lambdabot> http://lpaste.net/new/haskell
11:32:48 <pjdelport> ^- If you want to share some code.
11:33:42 <DheedoRaanjha> ok I will look at that
11:34:06 <nschoe> Reminds me how awesome this community is : try coming saying "Hi I'm new to Archlinux" on #archlinux and you get smashed "post you question if you have one, otherwise no need to pullote the chan" o_O. I love #haskell.
11:34:35 <pjdelport> DheedoRaanjha: Welcome to Haskell, by the way. :)
11:35:01 <DheedoRaanjha> thanks, http://lpaste.net/107070
11:35:14 <DheedoRaanjha> isqrt compiles but not isqrt'
11:36:44 <DheedoRaanjha> shouldn't both isqrt and isqrt' be equivalent?
11:37:20 <ion> floor . sqrt (fromIntegral n)
11:37:21 <pjdelport> DheedoRaanjha: The first example is equivalent to: (floor . sqrt . fromIntegral) $ n
11:37:22 <ion> @src (.)
11:37:23 <lambdabot> (f . g) x = f (g x)
11:37:23 <lambdabot> NB: In lambdabot,  (.) = fmap
11:37:45 <pjdelport> while the second example is equivalent to: floor . (sqrt . fromIntegral $ n)
11:37:47 <ion> \x -> floor (sqrt (fromIntegral n) x)
11:38:35 <pjdelport> DheedoRaanjha: So in the second case, (sqrt . fromIntegral $ n) is already a number, not a function, so you can't compose it to floor with (.).
11:39:05 <DheedoRaanjha> ah, I see
11:39:25 <rwbarton> function application ("sqrt (fromIntegral n)") has higher precedence than composition ("floor . sqrt")
11:39:30 <rwbarton> or any other operator for that matter
11:39:37 <chirpsalot> What's the "NB" thing that lambdabot said mean?
11:39:53 <ion> http://dictionary.reference.com/browse/NB
11:40:12 <rwbarton> that's out of date
11:40:14 <rwbarton> @type (.)
11:40:15 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:40:21 <chirpsalot> ion: oooh, thank you :).
11:41:11 <DheedoRaanjha> Thank you guys
11:41:11 <hexagoxel> _Vi: i am not gonna write more code. it depends too much on your requirements, and the rest is rather simple glue.
11:41:26 <DheedoRaanjha> I think I understand the problem now
11:41:56 <_Vi> hexagoxel, OK.
11:43:48 <jle`> hm. in haskell there is a valid non-bottom function from any type to any other inhabited type, right?
11:44:19 <hexagoxel> _Vi: i should note one more thing: UArrays are strict, so Codec.Wav will be unsuitable to work with audio streams (i think).
11:44:26 <ion> jle: const x where x has the right type?
11:44:30 <jle`> ion: yeah
11:44:51 <_Vi> hexagoxel, So big files can also be in check?
11:46:48 <hexagoxel> _Vi: i guess the file would effectively be loaded into memory. UArray should not have much overhead though. but i haven't tested.
11:47:28 <_Vi> hexagoxel, But filtering everything though [List] reintroduces all that overhead, doesn't it?
11:48:26 <_Vi> (AFK)
11:53:04 <hexagoxel> _Vi: i'd almost say no, because the list will be lazy. depends on how you access the elements.
11:54:57 * hackagebot encoding 0.7.0.2 - A library for various character encodings  http://hackage.haskell.org/package/encoding-0.7.0.2 (DanielWagner)
11:55:18 <amalloy> is there a name for types that are "listy"? like [a] is a container for 0-N a objects, Maybe a contains 0-1; Either e a could be considered the same
11:55:48 <jfischoff> There are several
11:56:04 <jfischoff> Functor might qualify
11:56:10 <joelteon> Foldable?
11:56:14 <jfischoff> also Traversable, Foldable
11:56:17 <intrados> amalloy: Functor, Foldable, Traversable, ListLike
11:56:50 <nschoe> @where bracket
11:56:50 <lambdabot> I know nothing about bracket.
11:57:11 <amalloy> maybe. i was hoping to not include something like IO a, because it always contains exactly one, and can't be pattern-matched on. i was just thinking of a function like catMabyes that works on something more general than Maybe
11:57:34 <joelteon> :t traverse
11:57:35 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:58:09 <rwbarton> there is also "container" or "polynomial functor"
11:58:29 <rwbarton> that includes r -> a also
11:58:32 <amalloy> joelteon: right, but here the f bubbles out to the return type f (t b), whereas in catMaybes there's no Maybe in the result
11:58:40 <rwbarton> though you could easily define it not to
11:59:32 <joelteon> :t toList
11:59:33 <lambdabot>     Not in scope: ‘toList’
11:59:33 <lambdabot>     Perhaps you meant one of these:
11:59:33 <lambdabot>       ‘F.toList’ (imported from Data.Foldable),
11:59:36 <joelteon> :t F.toList
11:59:37 <lambdabot> Foldable t => t a -> [a]
11:59:45 <benzrf> @src toList
11:59:45 <lambdabot> Source not found. I feel much better now.
11:59:49 <benzrf> @src Foldable.toList
11:59:49 <lambdabot> Source not found. :(
11:59:54 <rwbarton> catMaybes requires a kind of flexibility in the shape
12:00:04 <rwbarton> is that part of what you're looking for?
12:00:05 <benzrf> :t F.foldr (:) []
12:00:06 <lambdabot> Foldable t => t a -> [a]
12:00:43 <amalloy> yeah, i guess Foldable may just be what i mean
12:00:51 <joelteon> :t concatMap F.toList
12:00:52 <lambdabot> Foldable t => [t b] -> [b]
12:00:55 <joelteon> try that
12:01:23 <amalloy> i see. thanks!
12:01:24 <tnks> copumpkin: remember when talking about versioning in Haskell (relative to the JVM). . . I just found out about cabal freezing.  is that sufficient?
12:01:55 <tnks> it's not a hash-based coordinate (like Git or Nix), but it may be enough for a deterministic build?
12:04:18 <rola> > reverse "tacocat"
12:04:19 <lambdabot>  "tacocat"
12:09:58 * hackagebot pipes-aeson 0.4.1.1 - Encode and decode JSON streams using Aeson and Pipes.  http://hackage.haskell.org/package/pipes-aeson-0.4.1.1 (RenzoCarbonara)
12:10:21 <tolt> How are you able to see the result of a derivided instance (like Ord)?
12:11:48 <thoughtpolice> tolt: -ddump-deriv
12:11:55 <thoughtpolice> pass that to the compiler
12:12:00 <tolt> Thanks. I couldn't find it!
12:14:02 <robbins> I'm making my way through high order functions in LYAH, the only bit I don't understand is function composition with multiple paramaters - eg: sum . replicate 5 . max 5.7 8.9 seems resonable to me, although it doesn't type check in ghci. LYAH mentions the correct statement should be sum . replicate 5 $ max 6.7 8.9, can anyone else this to me?
12:14:13 <robbins> I'm assuming it's to do with partial application.
12:15:05 <robbins> *explain this to me
12:15:24 <tolt> How would you dump the instances in a cabal project?
12:15:40 <geekosaur> robbins: (.) requires functions. (max 5.7 8.9) is not a function
12:15:52 <geekosaur> :t (.)
12:15:53 <tolt> :t (.)
12:15:53 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:15:54 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:16:13 <geekosaur> what is the (a -> b) in (max 5.7 8.9)?
12:17:16 <geekosaur> ($) is not composition, it is application. (foo 5) and (foo $ 5) are the same thing. (.) is composition; it requires two functions
12:17:21 <robbins> geekosaur: Well, it doesn't return a function, only an instance of Ord a. How does ($) partially apply the function?
12:17:51 <tolt> :t ($)
12:17:52 <lambdabot> (a -> b) -> a -> b
12:17:56 <geekosaur> the function that is applied by ($) is sum . replicate 5
12:18:23 <geekosaur> :t sun . replicate 5
12:18:23 <lambdabot>     Not in scope: ‘sun’
12:18:23 <lambdabot>     Perhaps you meant one of these:
12:18:23 <lambdabot>       ‘sum’ (imported from Data.List),
12:18:25 <geekosaur> oops
12:18:27 <geekosaur> :t sum . replicate 5
12:18:28 <lambdabot> Num c => c -> c
12:18:30 <hexagoxel> sum . replicate 5 $ max 6.7 8.9 === (sum . replicate 5) (max 6.7 8.9)
12:18:50 <geekosaur> :t max 5.7 8.9
12:18:51 <lambdabot> (Ord a, Fractional a) => a
12:18:53 <robbins> geekosaur: So ($) is simply an infix operator in the case I posted?
12:19:17 <geekosaur> er? (.) and ($) are both infix operators
12:19:22 <geekosaur> they do different things
12:19:34 <geekosaur> I have no idea what you're trying to get at
12:19:56 <geekosaur> ($) is application with lowest possible precedence (normal application is highest possible precedence)
12:20:03 <hexagoxel> . and $ are infix
12:20:23 <robbins> geekosaur: I didn't understand why ($) is used originally - I think I do now, to partially apply the function.
12:20:29 <geekosaur> er
12:20:40 <geekosaur> no, that is not partial application, as the result is fully applied
12:20:52 <rwbarton> it's just regular application
12:20:52 <geekosaur> unless you mean something different from partial application that Haskellers do
12:21:12 <geekosaur> *than
12:21:52 <robbins> I quote from LYAH "Well, if we want to use them in function composition, we usually must apply them so each function takes just one parameter."
12:22:29 <geekosaur> I don't think that is relevant here? (sum . replicate 5) takes a single parameter
12:22:37 <robbins> ie: curried function
12:22:41 <geekosaur> (max 5.7 8.9) takes *no* parameters
12:22:58 <geekosaur> $ here just saves you some parentheses, as hexagonel said earlier
12:23:11 <geekosaur> [07 19:16] <hexagoxel> sum . replicate 5 $ max 6.7 8.9 === (sum . replicate 5) (max 6.7 8.9)
12:23:55 <geekosaur> because $ is lowest precedence, it acts like there are parentheses around the things on both sides of it, extending as far as possible syntactically
12:26:27 <geekosaur> and you can't use (.) there instead of ($) specifically because the thing on the right doesn't take any arguments, whereas (.) requires something that takes a single argument
12:26:59 <robbins> geekosaur: I understand why syntactically (.) need ($), although not *why* - using a (.) still seems natrual to me for some reason.
12:27:19 <robbins> *with multiple paramaters
12:27:20 <geekosaur> @src (.)
12:27:21 <lambdabot> (f . g) x = f (g x)
12:27:21 <lambdabot> NB: In lambdabot,  (.) = fmap
12:27:34 <geekosaur> (that second line is no longer true)
12:27:48 <geekosaur> what is the x that you are applying (max 5.7 8.9) to?
12:28:03 <geekosaur> in order to make (.) make sense there?
12:28:44 <robbins> 5?
12:29:03 <robbins> in sum . replicate 5 $ max 6.7 8.9
12:29:17 <geekosaur> 5 is applied to replicate there
12:29:57 <geekosaur> let me rephrase that question then: why do you believe that (max 6.7 8.9) needs to be applied to 5?
12:30:02 <geekosaur> > max 6.7 8.9
12:30:03 <lambdabot>  8.9
12:30:04 <hexagoxel> hint: you can also partially apply max and use another (.)
12:30:10 <geekosaur> looks saturated to me, nothing to apply to
12:30:28 <anbaric> (err, replicate is applied to 5, not vice versa)
12:30:57 <geekosaur> yes, sorry
12:31:24 <av> Hi there, I've got a Haskell module that uses non-Haskell code via FFI.  Every time I build a program (Haskell) using this module, I have to supply the "-L" and "-l" parameters to ghc.
12:31:37 <robbins> geekosaur: (max 6.7 8.9) is evaulated first, which is 8.9, which is the paramater of replicate, which then passed the list to sum.
12:31:54 <geekosaur> yes, that is application which is ($)
12:32:02 <geekosaur> it is not *composition* which is (.)
12:32:21 <jfischoff> @src ($)
12:32:21 <lambdabot> f $ x = f x
12:32:22 <fozworth> i wrote a library for the strava api that i'd like some feedback on -> https://github.com/tfausak/strive
12:32:29 <geekosaur> again: (.) composes *functions*. (max 5.7 8.9) does not produce a function; it produces a value
12:32:39 <geekosaur> specifically, the value 8.9 which is not a function
12:32:42 <fozworth> in particular, does it make sense to use lenses for specifying options?
12:32:56 <robbins> geekosaur: Oh god. I get it.
12:33:04 <robbins> That seems so simple.
12:33:43 <tnks> can someone remind me, is "cabal update" ever sandbox-specific?
12:33:49 <jfischoff> fozworth: haddocks would help
12:34:03 <tnks> or should it always update a shared index in ~/.cabal?
12:34:11 <fozworth> i can't upload packages to hackage for some reason, but there is some haddock stuff
12:34:23 <jfischoff> fozworth: online?
12:34:45 <fozworth> no hosted haddock. the readme has examples for everything
12:34:46 <robbins> geekosaur: Explaining a concept outloud to someone is really helpful, I'm glad you were patient enough to listen to me.
12:35:05 <robbins> https://en.wikipedia.org/wiki/Rubber_duck_debugging
12:36:36 <genisage> In haskell, is it possible to write implicit type conversions. So that if you pass an Int into something expecting a Bool, it will automatically convert it for you?
12:36:53 <jfischoff> fozworth: I think `with` is interesting. I think I like it. I guess a replacement for record update syntax if you are using lenses
12:37:08 <fozworth> jfischoff: yup, that's exactly right
12:37:18 <anbaric> av: did you install the ffi-using module (in a sandbox or otherwise), or is it just sitting in your source tree?
12:37:20 <geekosaur> genisage, no. you can get something vaguely similar if the function is written to expect a typeclass member
12:37:24 <fozworth> i originally had "set foo bar $ set foo2 bar2 $ def", which i didn't like
12:37:43 <geekosaur> but if it wants a Bool, it will only accept a Bool
12:37:46 <jfischoff> I usually have def { … }
12:37:50 <fozworth> which i felt naturally turned into "with = foldr ($) def"
12:38:12 <jfischoff> but I don’t know if that is an option
12:38:24 <jfischoff> with is more general I think
12:38:36 <geekosaur> in general, implicit type conversions are not looked on positively
12:39:17 <genisage> You could probably do it with a preprocessor. Would it be really complicated to find anything that had the wrong type, and check if a conversion was defined somewhere?
12:39:18 <fozworth> jfischoff: i can't do record update because the field names are so verbose
12:39:26 * jfischoff nods
12:41:40 <jfischoff> fozworth: I would avoid Prelude names, e.g. error https://github.com/tfausak/strive/blob/master/library/Strive/Lenses/Classes.hs#L173
12:41:48 <genisage> Of course that seems like it would help me make a lot of dumb mistakes, and then make it harder to find them. So maybe that's a terrible idea.
12:42:39 <fozworth> jfischoff: i'll add that to the blacklist. currently i avoid keywords by adding a "_" suffix. is that reasonable?
12:43:01 <jfischoff> yes
12:43:26 <av> anbaric: just sitting in my source tree... what's ffi-using?
12:43:30 <jfischoff> allow underscore identitifiers are not used much in the Haskell ecosystem
12:43:52 <merijn> primes are common, though
12:43:58 <jfischoff> When I see one I think “outsider” or “GHC code”
12:44:04 <fozworth> yeah i considered using primes as well
12:44:09 <merijn> Although they have strictness connotation
12:44:33 <fozworth> are there any other options for avoiding collisions with prelude?
12:44:42 <nschoe> Can somebody explain to me when it is necessary (in Happstack) to decode the body with "decodeBody" ? I haven't had the need to until now
12:44:43 <fozworth> and/or keywords
12:44:46 <merijn> Hiding, but that won't earn you friends :)
12:45:01 * hackagebot th-desugar 1.4.2 - Functions to desugar Template Haskell  http://hackage.haskell.org/package/th-desugar-1.4.2 (RichardEisenberg)
12:45:07 <nschoe> I have just tried to use "look" after a method POST, and apparently, it needs body decoding for that. So should we always decode the body ?
12:46:15 <jfischoff> fozworth: why only derive Show: https://github.com/tfausak/strive/blob/master/library/Strive/Options.hs#L114
12:46:37 <fozworth> jfischoff: i didn't need anything else during testing. what else should it derive?
12:47:30 <anbaric> av: just an awkward phrasing.  I think GHC needs the linker options any time it's building a package using the FFI; if you want to not give them every time, you can split the FFI stuff into a separate package and build/install that once (or at least less frequently)
12:47:31 <jfischoff> I would derive everything that makes sense for the types Eq, Ord, Read, Enum, Generics, Data, Typeable, etc
12:47:49 <fozworth> so pretty much everything from Prelude that makes sense
12:47:58 <jfischoff> depending on if the compiler lets you and if the semantics make sense
12:48:00 <nschoe> So apprently only POST requests need decodeBody ?
12:48:18 <anbaric> av: in any case, though, shouldn't cabal be handling all this for you?
12:48:21 <jfischoff> yes, prelude and base
12:49:49 <jfischoff> Should that be Char or enum: https://github.com/tfausak/strive/blob/master/library/Strive/Types.hs#L61
12:50:12 <jfischoff> similarly here: https://github.com/tfausak/strive/blob/master/library/Strive/Types.hs#L280
12:50:19 <jfischoff> fozworth: ^
12:50:28 <fozworth> yeah there are quite a few things that should be enums, good catch
12:50:32 <jfischoff> ttyl lunch
12:51:01 <donri> nschoe: it's for reading POST data, but some of those functions read GET query data which doesn't need decodeBody
12:52:10 <donri> nschoe: the reason it's not done for you automatically or by default is that it needs a writeable directory and possibly has some cost, so you don't always want to do it every request or for each "look"
12:52:43 <donri> nschoe: the reason it is needed at all is because POST data can be bigger than RAM
12:53:15 <donri> (even when not, you don't want to eat RAM excessively)
12:53:49 <nschoe> donri, yeah I went back to Happstack documentation and found what you just said indeed. But there is something I don't understand : they say decodeBody is not done automatically because it may be expensive. So from what I understand we should cal i tonly when needed right ? But then they say that for GET requests it has no effect, so  I guess it is safe to use it everytwhere ?
12:56:25 <donri> nschoe: if i understand the source correctly, the problem is that decodeBody will, well, decode the body, and you might want to reject a POST request before that
12:56:51 <nschoe> donri, okay. So the right thing to do is to call decodeBody manually, when I need it, right ?
12:57:06 <nschoe> And not use it in my main function ?
12:57:48 <donri> nschoe: depends on your application :)
12:58:35 <nschoe> donri, well calling it in the main will "force" decoding of every POST request, and it will, as you said, potentially decode POST requests that I can reject, right ?
12:58:51 <donri> for example if you have no need for large file uploads, you could perhaps get away with a single call to decodeBody with a limited BodyPolicy to prevent abuse
12:59:04 <av> anbaric: I'll give it a try, package sounds good, maybe it's time to start making cabal packages.  Thanks.
13:00:13 <nschoe> donri, yeah okay. And are there any downsides calling it manually ? (I like to have fine control, but on the other hand this is not crucial so if this is slowing things down...)
13:00:41 <donri> nschoe: no downside except loss of convenience, AFAICS
13:01:13 <nschoe> by "loss of convenience", you mean "having to be careful not to forget it when it is needed", right ?
13:01:18 <donri> you might want to make a wrapper around some "look" function plus decodeBody with a predefined BodyPolicy
13:02:01 <donri> i meant the noise of having to call it everywhere, but yes it can also lead to mistakes
13:02:11 <donri> although a wrapper would work around that
13:02:37 <nschoe> donri, Yeah I was actually thinking of doing a wrapper, but I was worried that it would somehow slow Happstack down (as I'm not too familiar with it).
13:02:38 <donri> apparently it's fine to call decodeBody multiple times; only the first is effective
13:02:52 <nschoe> Yeah, I saw that, indeed.
13:03:08 <nschoe> Well, thank you, I'll write a wrapper and call it when I need it.
13:03:44 <donri> also check out happstack-lite which moves this into the ServerConf and calls it for you
13:05:14 <nschoe> donri, yeah I actually followed the happstack-lite tutorial and wrote a simple website. I wanted to have a taste of Happstack "not-lite", see if I gain some insights of what's the underlaying of all that.
13:05:37 <donri> good approach :)
13:06:19 <nschoe> Thanks ^^
13:10:03 * hackagebot units 2.1 - A domain-specific type system for dimensional analysis  http://hackage.haskell.org/package/units-2.1 (RichardEisenberg)
13:11:17 <quchen> merijn: Hey! Two months ago you told me to ask you about the partiality monad in two months.
13:11:21 <quchen> So here I am.
13:15:04 * hackagebot units-defs 1.1 - Definitions for use with the units package  http://hackage.haskell.org/package/units-defs-1.1 (RichardEisenberg)
13:26:50 <joelteon> why does it take haskell-src-exts so long to compile?
13:30:02 <gaze__> hey folks. Is it possible to use something like ekmett's bound in a way that ensures that the AST is well typed?
13:30:09 <gaze__> or is there an extention to it?
13:30:18 <edwardk> gaze__: you can do it, you just need to give up Monad
13:30:33 <edwardk> gaze__: https://gist.github.com/ekmett/3258737
13:33:06 <gaze__> what are HBound and HMonad?
13:35:58 <benzrf> whats bound
13:36:17 <gaze__> actually yeah what are all these Hxyz instances?
13:37:36 <gaze__> how is hxyz extended beyond an xyz?
13:38:28 <apples> h = higher order
13:39:03 <phaazon_> hi, I may need some help; I just bought a VPS in order to run happstack on it, but the http port is not set
13:39:11 <phaazon_> not open*
13:39:15 <phaazon_> what should I do?
13:39:20 <apples> for instance, hmap in HFunctor maps natural transformations to natural transformations
13:39:25 <phaazon_> is there some firewall I have to put down?
13:40:53 <koala_man> phaazon_: check iptables or your VPS provider's web config thingy
13:40:59 <phaazon_> yeah
13:41:02 <phaazon_> I’m doing that
13:41:12 <phaazon_> I suck so much at that kind of things :D
13:41:47 <koala_man> it's tricky because the port could be blocked in so many ways. Fortunately, VPSes rarely make it difficult to run a web server
13:43:17 <micahcowan> phaazon_, perhaps run "netstat -tlp" as root (if it's a Linux VPS?) to verify that there is in fact a service listening on port 80, and if not, what if any ports are being listened on?
13:43:49 <phaazon_> micahcowan: what is that?
13:44:03 <phaazon_> ah
13:44:04 <phaazon_> well
13:44:06 <phaazon_> nothing on 80
13:44:13 <phaazon_> and a few ports, yes
13:44:18 <micahcowan> Okay, so probably not a fire walling issue.
13:44:38 <phaazon_> where can I see the firewall config?
13:44:46 <phaazon_> /etc/resolv.conf ?
13:44:48 <phaazon_> I never know
13:44:51 <phaazon_> no, that’s the DNS
13:44:58 <micahcowan> I'm not familiar with happstack, but is it a web server itself, or does it expect to be run under e.g. apache or some such?
13:45:16 <phaazon_> it’s a webserver itself
13:45:47 <micahcowan> Is it actually running? And was it listed as any of the programs listening, by netstat?
13:46:00 <koala_man> and does it bind to the external interface?
13:46:10 <phaazon_> micahcowan: I can’t run it on port 80
13:46:21 <phaazon_> I got a bind denied permission
13:46:35 <koala_man> only root can bind to port 80
13:46:44 <micahcowan> Ah. That's not a fire walling issue, that's a permissions issue. What koala_man said.
13:46:54 <phaazon_> ?!
13:46:54 <lambdabot> Maybe you meant: v @ ? .
13:46:56 <micahcowan> Does happstack drop root after opening port 80 (anybody)?
13:47:00 <phaazon_> so I have to run my server as… root?!
13:47:10 <phaazon_> micahcowan: I never launch the server as root
13:47:12 <koala_man> phaazon_: it has to start as root. it doesn't necessarily have to run as root
13:47:20 <rwbarton> "only if you want to run it on a UNIX system"
13:47:26 <micahcowan> All servers that listen on ports 1024 or below have to be run as root (and then, typically, they change to a less-privileged user right after)
13:47:39 <phaazon_> I hope happstack does that.
13:47:39 <micahcowan> (on UNIX systems, as rwbarton said)
13:47:53 <quchen> So you should forward port 80 to your program that runs in userland, not run the webserver in god mode.
13:48:06 <phaazon_> quchen: what do you mean?
13:48:14 <phaazon_> oh
13:48:16 <phaazon_> you mean
13:48:20 <quchen> Yes.
13:48:21 <phaazon_> running it on 8080
13:48:25 <phaazon_> and forward the port
13:48:28 <phaazon_> 80 -> 8080
13:48:32 <phaazon_> with a rule in iptables?
13:49:12 <koala_man> the typical use case is to run apache with mod_proxy, and map e.g. http://host/happstack to localhost:8080
13:49:16 <micahcowan> I've seen (e.g., Java-based) services that do not do that, and require some wrapper to handle the direct connection and prig-dropping... probably a Google search on "how do I avoid running happstack as root" or some such will turn something up of value. But yeah, port-forwarding's definitely one way to do it.
13:49:35 <micahcowan> And parodying via apache
13:49:45 <micahcowan> * proxying
13:49:54 <rwbarton> or nginx can do this proxying also
13:50:05 <micahcowan> WTF, do I have autocorrect on my IRC client? >:-(
13:50:15 <phaazon_> thank you :)
13:50:41 <micahcowan> Aaaand yes. I did. :-P
13:52:36 <int3__> @pl bifst f a b = f (fst a) (fst b)
13:52:36 <lambdabot> bifst = flip flip fst . ((.) .) . (. fst)
13:52:41 <int3__> isn't there a nicer way of doing this?
13:53:56 <laster> sup
13:54:50 <donri> you can give executables a capability to use port 80
13:55:10 <laster> coolz!
13:55:56 <donri> sudo setcap cap_net_bind_service=+ep $PWD/main
13:56:38 <donri> phaazon_: ^
13:56:58 <phaazon_> wat :D
13:57:09 <phaazon_> I may have found something clean to do it:
13:57:18 <donri> this is the cleanest way to do it on linux
13:57:28 <phaazon_> http://happstack.com/docs/happstack-server-7.0.2/doc/html/happstack-server/Happstack-Server-SimpleHTTP.html#v:simpleHTTPWithSocket
13:57:55 <donri> that works too yes but then you still have to run it as root and later drop privileges
13:57:56 <phaazon_> donri: ok, your solution sounds better to me since I don’t have to alter my code
13:58:03 <phaazon_> yeah
13:58:10 <phaazon_> I’m trying to understand your line
13:58:21 <donri> just remember to rerun setcap when you rebuild your exe
13:58:22 <phaazon_> oh, I have to be in the sudoers
13:58:35 <donri> sudo or su, just need root
13:59:09 <phaazon_> so I run this command
13:59:17 <phaazon_> and
13:59:20 <phaazon_> yeah I don’t get it.
13:59:38 <phaazon_> oh I do that on the executable
13:59:39 <phaazon_> ok
13:59:40 <phaazon_> I see
13:59:46 <phaazon_> I hope cabal run will use that
13:59:55 <phaazon_> I may also not want to start via cabal anyway
14:00:01 <donri> yes you add the capability to the executable
14:01:07 <donri> to make it work with cabal run you'd probably need a build-type: Custom and add some hook in Setup.hs to run setcap post-build
14:01:18 <donri> which is probably easier than it sounds
14:01:42 <micahcowan> Thanks, donri. I know some setcap thing was vaguely tickling my brain, but sadly I'm much more familiar with the (screwed-up) old, traditional UNIX way of dealing with that. Now I'll remember it for next time. :)
14:02:40 <donri> http://hackage.haskell.org/package/Cabal-1.20.0.1/docs/Distribution-Simple-UserHooks.html
14:05:19 <phaazon_> bash: setcap: command not found
14:05:20 <donri> actually it looks like it's all in http://hackage.haskell.org/package/Cabal-1.20.0.1/docs/Distribution-Simple.html
14:05:22 <phaazon_> hm
14:05:31 <donri> phaazon_: might be in /sbin which may not be in $PATH
14:05:34 <donri> try /sbin/setcap
14:05:52 <phaazon_> bash: /sbin/setcap: No such file or directory
14:05:54 <phaazon_> dammit
14:05:55 <phaazon_> :LD
14:05:56 <phaazon_> :D
14:06:01 <phaazon_>  /bin?
14:07:11 <donri> for me it's in /usr/sbin but then /sbin is a symlink there so works too
14:07:28 <donri> are you sure you're on linux? maybe it's not a core tool...
14:09:46 <donri> for me it's provided by the libcap package
14:09:46 <donri> what OS is your VPS?
14:09:47 <nschoe> Is it okay to CTRL + C Happstack after each compilation to test the new version ?
14:09:47 <nschoe> Isn't there a "proper" way to stop the happstack server ? (besides, I use acid-state with it, so I wonder about that).
14:09:48 <Tori21>  Hi! I give you some videos. I hope you like! http://bit.ly/1zkMNn2
14:10:00 <phaazon_> libcap2-bin - basic utility programs for using capabilities
14:10:02 <phaazon_> found it
14:10:08 * hackagebot trifecta 1.4.2 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-1.4.2 (EdwardKmett)
14:10:48 <donri> nschoe: ^C should work fine, yes. although there was some issue on windows...
14:10:50 <edwardk> republished to support new transformers/mtl
14:11:39 <donri> nschoe: you could also look at happstack-plugins for on-the-fly code reloading
14:12:01 <nschoe> donri, I'm working on Linux so I guess I'm okay. But just out of curiosity : how do the Windows user do ?
14:12:05 <donri> it doesn't use cabal though so sometimes takes some setting up
14:12:15 <donri> no idea about windows
14:12:53 <nschoe> okay. Well I won't go to the trouble of setting up the plugin. I just wondered if what I was doing was fine or not. Since it is, I'll leave it like this ^^
14:13:04 <nschoe> Thanks again :-)
14:13:30 <donri> you can also use ghci or cabal repl and :main with :reload
14:22:21 <nschoe> donri, sorry missed your message. I am looking at cabal repl right now, don't know what this is.
14:22:30 <jophish__> :(
14:22:36 <jophish__> Haskell's ruined c++ for me
14:22:48 <jophish__> I used to tolerate it. Now I loathe it
14:22:52 <quchen> dcoutts: Hey, is there a reason zlib does not expose Maybe versions of decompression? I'm very hesitant depending on Internal modules.
14:23:20 <quchen> Or am I overlooking some API feature
14:23:44 <tolt> jophish__: the worst part for me is that I have to do school work in other languages but I only use Haskell at work.
14:24:11 <jophish__> tolt, we were generally allowed to do assignments in any language
14:24:13 <mzero> jophish__: just imagine what it has done to python for me!
14:24:28 <jophish__> mzero, hahaha
14:24:59 <tolt> It's mostly c++ or java. I got to use some lisp last semester. That was pretty cool.
14:25:02 <jophish__> I hope learning Idris won't ruin Haskell for me
14:25:58 <benzrf> years ago
14:26:04 <silasm> jophish__: so far learning Idris has made haskell seem a little bland at worst, definitely doesn't make it seem bad. Though that may be partly since the language is still a work in progress and still has some big issues with e.g. error messages.
14:26:08 <benzrf> i used to think that c+ came between c and c++
14:26:41 <systemfault> benzrf: Can’t wait for C++++
14:26:50 <benzrf> ( ͡° ͜ʖ ͡°)
14:27:47 <kazagistar> C++ has mutability and single letter variables and confusion about "code points" in its NAME
14:28:32 <ReinH> hahaha
14:29:10 <mzero> surely you realize that c++++ won’t parse…. but   c+++++x would be a syntatically correct language  :-)
14:29:11 <joelteon> well geez, if single letter variables are bad, I'm going to have to rewrite every package I've ever written
14:29:46 <mzero> as would  c++-++x    ….   these are the “fish bonez” languages....
14:30:00 <quchen> @quote first.26
14:30:00 <lambdabot> alexbagel says: i find that my first 26 variables are always easy to name. after that it becomes a bit harder.
14:30:08 <kazagistar> mzero: my favorite is the C arrow operator { while { x --> 0 } ... }
14:31:31 <kazagistar> it works subtly differently in either direction! awesome!
14:34:10 <moghedrin> kazagistar: My c++ experience hasn't been complete until now XD
14:35:41 <amalloy> kazagistar: more colloquially known as the "countdown-to" operator
14:40:20 <kini> is there perhaps some kind of generic AST pretty printer out there which handles parentheses automatically given some precedence info of operators?
14:40:39 <kini> seems like a waste to rewrite that stuff every time you have a new mini-language you want to pretty print
14:42:00 <nschoe> :t optional
14:42:01 <lambdabot> Alternative f => f a -> f (Maybe a)
14:48:18 <donri> kini: Show? :)
14:48:25 <donri> :t showPrec
14:48:25 <lambdabot>     Not in scope: ‘showPrec’
14:48:26 <lambdabot>     Perhaps you meant one of these:
14:48:26 <lambdabot>       ‘showsPrec’ (imported from Prelude),
14:48:30 <donri> :t showsPrec
14:48:30 <lambdabot> Show a => Int -> a -> ShowS
14:56:12 <phaazon_> ok
14:56:17 <phaazon_> my website’s up!
14:56:19 <phaazon_> thank you guys :)
14:56:28 <phaazon_> (I need a footer! ahah)
15:00:10 <nicolaum> Is the number e built into haskell, I cannot find it.
15:00:11 * hackagebot binary-typed 0.1.0.0 - Type-safe binary serialization  http://hackage.haskell.org/package/binary-typed-0.1.0.0 (quchen)
15:00:27 <quchen> > exp 1
15:00:29 <lambdabot>  2.718281828459045
15:00:38 <quchen> nicolaum: ^
15:01:29 <nicolaum> thanks
15:01:57 <joelteon> @let e = exp 1
15:02:02 <lambdabot>  Defined.
15:02:04 <joelteon> > e
15:02:06 <lambdabot>  Ambiguous occurrence ‘e’
15:02:06 <lambdabot>  It could refer to either ‘L.e’, defined at L.hs:150:1
15:02:06 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.e’,
15:02:06 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:112:1-26
15:02:06 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
15:02:09 <joelteon> oh, whoops
15:02:10 <joelteon> @unlet
15:02:11 <lambdabot>  Define what?
15:02:15 <joelteon> @undefine
15:02:15 <lambdabot> Undefined.
15:02:18 <joelteon> > e
15:02:20 <lambdabot>  can't find file: L.hs
15:03:00 <quchen> It's probably a good thing the single letter e isn't taken as an identifier.
15:03:18 <quchen> (Unless you're Lambdabot and have simple-reflect loaded by default.)
15:03:26 <joelteon> Well to be fair, the only single letter identifiers used often are f, g, x, and y
15:04:13 <amalloy> are type variables not also identifiers?
15:04:31 <joelteon> yeah but it's a different symbol table
15:04:42 <quchen> and h (handles, yet another function), z (yet another variable), i/j (loop indices), r/s/t (more variables), a/b/c (even more variables)
15:04:54 <joelteon> but no e
15:05:10 <quchen> Exceptions.
15:05:13 <Forgetaboutit> joelteon: But what if ScopedTypeVariables is set?
15:05:27 <joelteon> oh yeah, there is an e.
15:05:43 <donri> also a, b, c, d, e
15:05:46 <joelteon> Forgetaboutit: type variables and identifiers can conflict freely
15:05:52 <joelteon> well
15:05:56 <joelteon> type variables and value-level variables
15:05:59 <donri> and m, n
15:06:06 <donri> s, q, w
15:06:10 <joelteon> s t a b
15:06:24 <bulan> @quote letter.26
15:06:24 <lambdabot> No quotes match. There are some things that I just don't know.
15:06:35 <bulan> @quote 26
15:06:36 <lambdabot> SimonMarlow says: This is the largest program (in terms of memory requirements) I've ever seen anyone run using GHC.  In fact there was no machine in our building capable of running it, I had to fire up the largest Amazon EC2 instance available (68GB) to debug it - this bug cost me $26.
15:07:06 <quchen> bulan: I quoted what youI're looking for above already.
15:07:45 <bulan> :)
15:10:02 <kini> <donri> kini: Show? :)
15:10:02 <kini> haha, yikes - didn't realize that was built in
15:10:52 <kini> I guess there's the slight problem that my AST definition doesn't actually use Haskell operators so I can't declare associativity and precedence on the Haskell level...
15:11:13 <kini> also I have mixfix (if/then/else for example)
15:12:48 <Kaidelong> kini: IIRC you can declare fixity for anything function like, this probably includes GADT constructors
15:13:17 <Kaidelong> because haskell provides the `foo` syntax it makes perfect sense to have infixl, infixr declarations for arbitrary functions
15:13:42 <Kaidelong> so don't worry if you aren't using a syntactic operator
15:14:41 <monochrom> today's xkcd is a nice example of co-data! :)
15:17:27 <kazagistar> monochrom: could you ... explain for a noob?
15:19:01 <monochrom> he fooled the genie into mistaking every wish to be the first wish. so he got the infinite list type "data WishList = Cons Wish WishList"
15:19:33 <Kaidelong> oh the alt text
15:20:04 <kazagistar> gotcha
15:25:04 <kini> Kaidelong: oh, that makes sense :o
17:38:08 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
17:38:08 --- topic: set by Cale!~Cale@CPEc8d3a35c2cdd-CM78cd8ec9750d.cpe.net.cable.rogers.com on [Sat May 31 02:09:44 2014]
17:38:09 <johnw> bitemyapp: so, Tekmo suggested to me that Cont (r -> m r) a would not have a lawful MonadTrans instance, rather that you would need Cont (m r -> m r) a
17:38:10 <Kaidelong> I cannot genuinely recommend it without reading the docs again but I think it's what he wants
17:38:18 <shlevy> Kaidelong: OK I'll check
17:38:35 <shlevy> Kaidelong: Any specific docs to look at?
17:38:36 <Kaidelong> basically the way it forks is you declare
17:38:40 <johnw> bitemyapp: but now I have proof that the extra 'm' is unnecessary
17:40:09 <Kaidelong> what you want is this: data ShowContainerTypeConstructor = forall t. Show t => ShowContainerDataConstructor t
17:40:21 <Kaidelong> you can do that with -XExistentialQuantification
17:40:28 <Kaidelong> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
17:40:46 <bitemyapp> johnw: I don't understand why the MonadTrans obviates the need for the extra m
17:40:55 <bitemyapp> johnw: I do recall what you'd said previously on this topic.
17:41:11 <Kaidelong> I don't think it counts as an antipattern in this case unless you have more functionality in mind than what you described
17:41:23 <johnw> bitemyapp: it's not MonadTrans that obviates it.  It's that given Cont (r -> m r) a, I can indeed provide a lawful instance of MonadTrans
17:41:27 <shlevy> Kaidelong: Right I know that bit. But then do I pass a thing of that type around? Or I guess I can then pass the wrapped value in to a polymorphic function
17:41:36 <shlevy> So that type doesn't need to escape anywhere
17:41:43 <johnw> that's all; but since Source is based on that type, it means Source is a lawful MonadTrans
17:42:03 <shlevy> Let me play with it
17:42:14 <Kaidelong> shlevy: if you're actually worried about what type is inside of the box then it's probably getting into antipattern territory
17:42:25 <shlevy> I'm not worried about the type inside the box
17:42:35 <shlevy> I just don't want to have to unwrap the type all the time
17:42:36 <Kaidelong> but yeah you have to wrap it explicitly
17:42:43 <Kaidelong> you could look at Data.Newtype though
17:42:49 <Kaidelong> it has some wrap/unwrap helpers
17:42:58 <shlevy> nor do I want to have to create an instance that passes all the functions to the held value
17:43:43 <shlevy> Kaidelong: What is the type of those wrappers?
17:43:44 <Kaidelong> you'd have to do that too
17:44:12 <Kaidelong> shlevy: ShowContainerTypeConstructor
17:44:30 <Kaidelong> err
17:44:37 <Kaidelong> oh yes right
17:44:38 <shlevy> Kaidelong: I mean the unwrapper helpers
17:44:39 <shlevy> :D
17:44:53 <shlevy> If you can write an unwrapper helper then my problem would be solved
17:45:00 <shlevy> But I guess you just need to pattern-match
17:45:05 <shlevy> But let me test something
17:45:08 <Kaidelong> https://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html
17:45:11 <Kaidelong> it's a typeclass
17:45:32 <shlevy> So what's 'o' there?
17:45:35 <Kaidelong> you still have to provide pack and unpack
17:45:36 <shlevy> for my instance?
17:46:09 <Rastus_Vernon> It appears "" is of type [Char] while [] is of type [a]. Yet, "" == [] yields True.
17:46:15 <Kaidelong> oh that's right
17:46:22 <Rastus_Vernon> I'm not sure I get it. Of course, two values of different types can be equal, but...
17:46:24 <Kaidelong> it wouldn't work in this case because of ExistentialQuantification
17:46:35 <lfairy> Kaidelong: I think it is an antipattern. There'
17:46:46 <shlevy> Rastus_Vernon: a is a type variable. It can be unified with any type, including Char
17:46:48 <lfairy> s no difference between that and a bare String
17:46:53 <Kaidelong> Rastus_Vernon: [t] unifies with [Char]
17:47:06 <Kaidelong> the most general unifier is [Char]
17:47:14 <Rastus_Vernon> Yes, sorry. Should've thought of that. Rather, my question is why "" is not of type [a].
17:47:24 <Rastus_Vernon> That is, why you cannot do 3 : ""
17:48:07 <Kaidelong> because syntactically "" syntax only works on strings, and it's more convenient that way anyway
17:48:08 <shlevy> Rastus_Vernon: Because "" is special syntax
17:48:21 <Kaidelong> sometimes you need to help the inference engine by introducing types for it to work with
17:48:33 <shlevy> You don't want to have to write "" :: [Char] a lot
17:48:33 <Rastus_Vernon> In fact, now that I think about it, it really just makes sense. That was a pretty stupid question.
17:48:34 <Kaidelong> if you use OverloadedStrings type inference can become a pain
17:48:56 <silasm> Rastus_Vernon: even if "" was of type [a] that wouldn't work, because "" is a term, not a type.
17:49:20 <Kaidelong> anyway it is an interesting question to me
17:49:36 <Kaidelong> my intuitive answer is that the programmer probably didn't intend 3 : "" instead of 3 : []
17:49:42 <Kaidelong> so why not make it an error?
17:49:47 <ReinH> pdxleif: ping
17:50:06 <Rastus_Vernon> Kaidelong: Indeed. That's a bit more error checking, which cannot be a bad thing.
17:50:30 <Rastus_Vernon> I would probably not want 3 : "" to not give me an error if I accidentally wrote that in a program, because I hardly see how I could seriously have intended to write that.
17:50:49 <johnw> bitemyapp: there are 8 other type classes yet to go
17:51:21 <silasm> Rastus_Vernon: whoops, I'm stuck in idris mode. I thought you were saying 3 had the type ""
17:51:25 <silasm> my bad.
17:51:49 <Rastus_Vernon> Well, for sure numbers aren't lists of characters!
17:51:57 <Rastus_Vernon> (or I hope so, at least)
17:52:15 <shlevy> Hmm
17:52:20 <shlevy> Is there any way to write a function like
17:52:23 <shlevy> withSomeShow :: Show x => Bool -> (x -> a) -> a
17:52:47 <Rastus_Vernon> Numbers *are* sequences of digits... and sequences are lists, and digits are characters, so numbers are... lists of characters...? And since strings are lists of characters, numbers are... strings?
17:52:49 <Rastus_Vernon> Aaaaah!
17:52:51 <johnw> shlevy: no
17:52:58 <shlevy> johnw: Ah, hello!
17:53:02 <johnw> shlevy: hello!
17:53:25 <silasm> Rastus_Vernon: I find your dependence on a particular choice of representation of numbers disturbing ;).
17:53:28 <shlevy> johnw: Trying to figure out how to write the logic that switches based on NIX_REMOTE to give you a different impl of the store API at runtime
17:53:48 <johnw> shlevy: the problem with your type signature is that you don't know how to make an 'x'
17:53:58 <Rastus_Vernon> silasm: I wasn't being serious. The flaw in that reasoning is that numbers aren't sequences of digits in the first place: they're just represented that way. :)
17:54:07 <Kaidelong> silasm: it's correct, although maybe in a less direct way than was intended
17:54:19 <shlevy> johnw: Can't I require my (x -> a) to be polymorphic?
17:54:22 <Kaidelong> numbers are programs and the set of programs is aleph-0
17:54:36 <Kaidelong> (cardinalitY)
17:54:42 <johnw> shlevy: it's the polymorphism that's the problem
17:55:00 <Kaidelong> any set with aleph-0 cardinality can be indexed by Nat
17:55:03 <johnw> the caller is handing you a function, and want you to pass something which is not *an* x, but any showable x.  There is no such value
17:55:20 <shlevy> johnw: Hm?
17:55:30 <shlevy> johnw: 1 is a showable x for some x?
17:55:32 <lfairy> shlevy: "Show x => a" is equivalent to "(x -> String) -> a"
17:55:32 <johnw> now, this type checks:
17:55:33 <johnw> withSomeShow :: Bool -> (forall x. Show x => x -> a) -> a
17:55:34 <johnw> withSomeShow b f = f ()
17:55:39 <lfairy> all you're given is a function to convert things to Strings
17:55:42 <enthropy> @type \b f -> case undefined of x | b -> f x
17:55:43 <kazagistar> I thought it was obvious that 3 : "" should be 0, because the "" should be coersed to a 0 and the : should be coersed to a multiplication
17:55:43 <lambdabot> Bool -> (t1 -> t) -> t
17:55:44 <silasm> Kaidelong: hmmm, I don't know how I feel about "numbers are programs", the other way around makes a /bit/ more sense to me, but at this point I think I'm arguing philosophy with myself.
17:55:47 <johnw> shlevy: 1 is a showable x, it's not forall x. showable x
17:55:49 <Kaidelong> in theory there are more real numbers than natural numbers but in practice those real numbers can't be observed or used in any calculation
17:55:49 <lfairy> how do you get the thing in the first place?
17:55:54 <enthropy> @type \b f -> case undefined of x | b -> f x `const` show x
17:55:55 <lambdabot> Show a1 => Bool -> (a1 -> a) -> a
17:55:57 <shlevy> lfairy: Show is just an example here
17:56:01 <johnw> by using rank-2, we get to now pick the 'x'
17:56:03 <Kaidelong> so they may as well not be there
17:56:26 <johnw> at rank-1, however, we don't get to choose the type
17:56:36 <Kaidelong> so we can say all useful numbers can be indexed by Nat
17:56:37 <lfairy> shlevy: regardless, you need to pass in a concrete value somehow
17:56:53 <shlevy> lfairy: Sure. In my case, I'm switching based on an env var
17:56:58 <silasm> Kaidelong: never thought about things that way, neat...
17:57:28 <pjdelport> silasm: Ever seen http://en.wikipedia.org/wiki/FRACTRAN ?
17:57:31 <shlevy> lfairy: And then if the env var is set one way, I construct an instance of the class from one type, and if it's set the other I set it from the other type
17:57:37 <sveit> with Data.Vector.Generic and Data.Vector.Generic.Mutable imported, why does ghc not allow me to define the function testF v = convert <$> (unsafeFreeze v) ?
17:57:42 <sveit> there is some typechecker error
17:58:24 <silasm> pjdelport: hahaha that is so neat
17:58:26 <silasm> thanks
17:58:29 <shlevy> johnw: Ah moving the quantifier inside worked
17:58:40 <Kaidelong> I might be wrong, I came up with this reasoning on my own and there might be a proof somewhere that for some representation of numbers there will always be numbers that can't be represented with that system and thus U can't be indexed by Nat (IE there's an infinite number of different possible Goedel numberings but none of them are complete over the set of valid programs)
17:58:42 <sveit> actually one just needs import Data.Vector.Generic and testF v = convert <$> (unsafeFreeze v) to get the huge error
17:59:03 <Kaidelong> that would kind of be a variation on incompleteness, too
17:59:35 <johnw> shlevy: it's the difference between your function wanting to *use* polymorphism, instead of being require to *provide* polymorphism
17:59:47 <Kaidelong> in which case maybe there really are aleph-1 useful numbers
17:59:50 <shlevy> johnw: Right, that makes sense
17:59:52 <Kaidelong> but I haven't seen a proof of that
17:59:58 <Kaidelong> then again I have no proof against it either
18:00:33 <shlevy> So is something like http://lpaste.net/107081 a terrible idea?
18:01:16 <Kaidelong> shlevy: that looks like an elegant solution to me
18:01:18 <johnw> shlevy: terrible?  If the type checker is happy, you just have to ask whether you are :)
18:01:36 <Kaidelong> you'll need Rank2Types
18:02:07 <Kaidelong> I think ExistentialQuantification and Rank2Types have a deep relationship and Rank2Types is strictly more general, that may be what you discovered
18:02:08 <pepper_chico> I just got here, so I'm not with energy to read all the subject of discussion but regarding programs as numbers
18:02:18 <pepper_chico> I love this http://abstrusegoose.com/261
18:02:21 <johnw> Kaidelong: RankNTypes is really the preferred nowadays
18:03:22 <shlevy> I think this is the way I want to go
18:03:42 <pjdelport> silasm: There's http://en.wikipedia.org/wiki/Gödel_numbering too.
18:03:49 <shlevy> Thanks for the help
18:04:37 <johnw> shlevy: :)
18:05:00 <lfairy> pepper_chico: see also http://www.gwern.net/Copyright
18:05:03 <shlevy> johnw: As a future user of this library, do you have any thoughts? :D
18:05:36 <johnw> shlevy: not at the moment; I am in general a big fan of using CPS style to abstract implementation details though :)
18:05:37 <pepper_chico> heh thanks lfairy
18:06:09 <pjdelport> pepper_chico: That's a common but flawed line of reasoning; there's a classic essay about this: http://ansuz.sooke.bc.ca/entry/23
18:06:21 <shlevy> johnw: Can you expand on that a bit?
18:06:38 <johnw> i've found that sometimes, when you have just an adjunction and not a full isomorphism, yet you can get away with: from :: A -> B, to :: B -> (A -> r) -> r
18:07:02 <johnw> the CPS avoids the need to returns a fully transformed object
18:07:19 <johnw> you can apply your function to the intermediate form which is under the control of the 'to' function in this case
18:07:28 <shlevy> Sorry too terse for me
18:07:40 <johnw> well, I like where you're headed
18:08:03 <shlevy> Oh sorry
18:08:11 <shlevy> I was trying to see how this was an alternative to my idea :D
18:08:15 <shlevy> But you were approving of it
18:08:30 <sveit> > fmap Data.Vector.Generic.convert . Data.Vector.Generic.unsafeFreeze
18:08:31 <lambdabot>  Not in scope: ‘Data.Vector.Generic.convert’Not in scope: ‘Data.Vector.Generi...
18:08:34 <johnw> I tend to think of a CPS function as the difference between a representational value, and a "computational" value
18:08:35 <shlevy> I was like "the withSomeShow function takes a continuation doesn't it?..." :D
18:08:41 <johnw> yeah, I was confirming you :)
18:08:50 <pepper_chico> pjdelport that will be a good read when I have the time ;-)
18:09:03 <johnw> go go shlevy!
18:09:06 <shlevy> :D
18:09:08 <pjdelport> pepper_chico: It is a good read, yeah. :)
18:09:30 <silasm> pjdelport: same here, thanks. Unfortunately I shouldn't distract myself too much while at work ;).
18:10:03 <enthropy> shlevy: I think people don't use continuations all over the place because they are harder to understand
18:10:31 <johnw> yeah, poor Cont, he's such a misunderstood monad
18:10:57 <johnw> even yoneda can be used to automate CPS transformation; they are everywhere
18:11:11 <sveit> hate to bump my own question, but can someone familiar with the typesystem/how Data.Vector interacts with it do (fmap Data.Vector.Generic.convert . Data.Vector.Generic.unsafeFreeze) and give some hint on the error message?
18:11:14 <sveit> in ghci?
18:13:48 <kazagistar> whats the advantage of CPS style in haskell?
18:14:25 <kazagistar> I said style twice like a derp
18:14:25 <johnw> kazagistar: for example, (a -> r ) -> r -> r is isomorphic to a list, without having a list
18:14:59 <silasm> kazagistar: some implementations have used continuations for IO, iirc.
18:15:02 <johnw> then idea extends to arbitrary data structures, so, for example, in places where you cannot rely on fusion to guarantee constant space usage, you can turn to CPS to force it
18:15:09 <silasm> as in instead of Monads
18:15:19 <johnw> my simple-conduit library is based on CPS monadic lists
18:15:28 <johnw> http://hackage.haskell.org/package/simple-conduit
18:15:42 <rwbarton> sveit: I didn't get an error message, just a rather long type
18:15:43 <chrisdotcode> johnw: you gonna be free in about an hour or so to meet up in gitlib?
18:15:47 <johnw> (why the haddocks are broken for 0.4, I don't know)
18:15:53 <johnw> chrisdotcode: you bet!
18:16:01 <chrisdotcode> sweet
18:16:52 <sveit> rwbarton: really? I get an error. hm...
18:16:58 <sveit> rwbarton: did you import Data.Vector.Generic?
18:17:17 <enthropy> sveit: it seems like vector doesn't encode the idea that every mutable vector has only one immutable version
18:17:41 <enthropy> unsafeFreeze :: (Vector v a, PrimMonad m) => Mutable v (PrimState m) a -> m (v a)
18:17:49 <rwbarton> all I did was ghci, then :t fmap Data.Vector.Generic.convert . Data.Vector.Generic.unsafeFreeze
18:17:52 <enthropy> Mutable is a type family... there's no Unmutable
18:18:01 <akahn> johnw: typo in the description: s/donw/down/
18:18:07 <rwbarton> ah I see "let f = ..." then I get an error
18:18:10 <johnw> akahn: thanks
18:18:11 <enthropy> rwbarton: I get that too, but if you put it in a file...
18:19:02 <sveit> ah, thanks a lot guys. another way to see the error is to do ghci, :m +Data.Vector.Generic, fmap convert . unsafeFreeze
18:19:05 <akahn> I'm running `cabal install wreq`, which succeeds, but then when I import Network.Wreq, ghc says it can't find the module. why?
18:19:24 <sveit> enthropy, rwbarton: so how would i define a function that morally does the same thing?
18:19:36 <rwbarton> (ah I see, I didn't try that because obviously there wasn't going to be a Show instance)
18:20:06 <sveit> rwbarton: of course, sorry, :t fmap convert . unsafeFreeze
18:20:27 <sveit> anyway, can I give haskell some more type information but leave the code somewhat generic?
18:20:53 <sveit> also why does it work before the import but fail after?
18:21:59 <enthropy> sveit: http://lpaste.net/107082
18:22:01 <sveit> sorry again, i mean why does it fail after assignment
18:22:34 <enthropy> these are the evils of type families
18:23:02 <sveit> enthropy: could i possibly do something like (forall v. (Mutable v ~ Mutable v))?
18:23:04 <rwbarton> basically you have to decide what intermediate type you want
18:23:23 <enthropy> if people would use fundeps instead you'd have  class Thawable v mv | v -> mv, mv -> v
18:23:27 <johnw> you don't use your vm type variable
18:23:57 <johnw> fundeps sure are handy
18:24:01 <enthropy> oops, I originally meant to use it with   vm ~ Mutable v
18:24:15 <enthropy> but somehow got distracted
18:25:17 <Rastus_Vernon> I am confused. https://hackage.haskell.org/package/base shows more modules than https://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.0/index.html although both are about version 4.7.0.0 and use the same version of Haddock.
18:25:28 <rwbarton> you can express that with type families too right? type family UnMutable v; class (v ~ UnMutable (Mutable v)) => Thawable v where type family Mutable v; ...
18:25:36 <enthropy> yes you can
18:25:38 <Rastus_Vernon> For example, only Hackage shown GHC.Arr, but also many others.
18:25:48 <enthropy> but the price is that people have to come up with a new name
18:25:53 <rwbarton> true
18:25:59 <Rastus_Vernon> Only Hackage, also, shows GHC.IO.Encoding.CodePage.API.
18:26:00 <rwbarton> how about Immutable :)
18:26:13 <enthropy> and whenever you write instances you have to be sure they are actually inverses
18:26:25 <rwbarton> the compiler checks it right?
18:26:33 <enthropy> I mean it's not checked when you write the instance, but rather when it gets used
18:26:38 <rwbarton> oh
18:26:50 <rwbarton> really?
18:27:35 <enthropy> that lpaste compiles if I instead write "type instance UnMutable MS.MVector = VU.Vector"
18:28:25 <rwbarton> oh, Mutable is a standalone type family
18:29:07 <rwbarton> I thought it was part of a class, so you could put the (v ~ UnMutable (Mutable v)) constraint on the class
18:29:25 <enthropy> that case should get caught
18:30:00 <fuzzyhorns> dumb question, but are all haskell programs in a main action?
18:30:05 <shlevy> Is there any way using the bracket pattern to pass off a bracketed resource to another thread that then takes full ownership?
18:30:08 <shlevy> I'm thinking no
18:30:39 <pjdelport> fuzzyhorns: Everything you end up running as an executable, yeah.
18:30:53 <fuzzyhorns> pjdelport: ok, coool
18:32:15 <enthropy> sveit: that doesn't look like it'll work. I think the only way is to provide that inverse to Mutable (UnMutable)
18:32:53 <rwbarton> or you can do a boring "pass in a proxy for the intermediate type" thing
18:33:38 <johnw> proxies are almost always ugly
18:35:19 <rwbarton> yes, both boring and ugly
18:36:52 <shlevy> Is there an alternative/generalization of 'bracket' that doesn't assume the acquire, release, and in-between run in the same thread?
18:37:02 <shlevy> I'm not sure exactly what that might look like...
18:37:05 * shlevy misses RAII
18:37:31 <johnw> i don't get understand what the use case looks like, shlevy
18:40:40 <yellow13> http://lpaste.net/107083 -- I cant understand why ghci complains about this
18:40:53 <enthropy> rwbarton, sveit https://github.com/haskell/vector/issues/34
18:41:00 <johnw> what is the complaint?
18:41:17 <yellow13>   No instance for (Show t0) arising from a use of ‘print’
18:41:18 <yellow13>     The type variable ‘t0’ is ambiguous
18:41:18 <yellow13>     Note: there are several potential instances:
18:41:30 <johnw> there is no 'print' in what you pasted :)
18:41:41 <fuzzyhorns> also, how would you all define the difference between types and classes, in a language agnostic sense?
18:41:51 <fuzzyhorns> i find these answers unsatisfying http://stackoverflow.com/questions/468145/what-is-the-difference-between-type-and-class
18:42:04 <Cale> fuzzyhorns: classes in the Haskell sense?
18:42:20 <rwbarton> funny that my answer would have been more or less diametrically opposite to the accepted answer there
18:42:22 <Cale> fuzzyhorns: Classes restrict the types over which type variables can range
18:42:27 <pjdelport> yellow13: That message means you're printing a value of an ambiguous type: you'll need to constrain it so that Haskell knows which method to use to show it.
18:42:48 <fuzzyhorns> Cale: hmm?
18:42:54 <johnw> fuzzyhorns: you can implement type classes using ordinary types and explicit dictionary passing
18:42:55 <fuzzyhorns> rwbarton: how so?
18:43:04 <rwbarton> in that the Haskell terminology is different
18:43:12 <rwbarton> a type tells you what something is
18:43:22 <Cale> fuzzyhorns: You're asking in #haskell...
18:43:30 <kini> fuzzyhorns: "class" means something very different in haskell than in OO languages so that stack overflow answer is completely irrelevant to haskell :)
18:43:33 <rwbarton> what values it could have, what the representations of those values are
18:43:44 <pjdelport> fuzzyhorns: A type class describes the class of types that all provide implementations of a common set of methods (for that class).
18:43:46 <rwbarton> a class is an interface that can be implemented by various types
18:43:48 <fuzzyhorns> Cale: that is the most aggressive answer ive ever gotten here, lol
18:43:50 <yellow13> pjdelport: so i need to do that o the type definition? fun :: blahblah
18:44:00 <fuzzyhorns> I'm asking because I figure most haskell folks know and have an opinion on type theory
18:44:00 <Cale> fuzzyhorns: I don't mean it to be aggressive :)
18:44:05 <pjdelport> yellow13: Maybe; what were you trying to print?
18:44:17 <pjdelport> yellow13: The rest of the error message should give you a hint.
18:44:19 <fuzzyhorns> and for those that have experience in class-focused languages im curious how theyd describe the diff
18:44:24 <rwbarton> ok, so are you asking about 'type'/'class'-as-in-Haskell or as in, I guess, Java or something?
18:44:25 <Cale> fuzzyhorns: I'm just assuming you mean classes in the sense of type classes
18:44:28 <fuzzyhorns> Cale: oh i know
18:44:38 <kazagistar> fuzzyhorns: the accepted answer there is maybe correct in C++ land, but in haskell we prefer something a lot closer to the original mathematical definitions, which have very little to do with what OOP languages do
18:44:39 <Cale> Do you mean OO classes?
18:44:51 <fuzzyhorns> Cale: indeed
18:44:55 <pjdelport> fuzzyhorns: Haskell type classes are most similar to interfaces in OO languages, but still a bit different.
18:45:06 <fuzzyhorns> I am trying to explain to other folks I know in OO land why I am finding I prefer working iwth types :/
18:45:11 <pepper_chico> pjdelport you coloured my life =D
18:45:13 <Cale> fuzzyhorns: Well, different OO languages have slightly different concepts of what a class is, even then.
18:45:13 <shlevy> johnw: Say I have some daemon listening for commands in a loop. Some commands require a resource that is expensive to acquire and to keep around, so when those commands come in we want to reuse a shared instance if it exists, but if it doesn't we want to create it and then share it until some time passes without it being used and we think we can afford to release it
18:45:21 <fuzzyhorns> Cale: indeed
18:45:27 <pjdelport> pepper_chico: Good to hear. :)
18:45:29 <Cale> fuzzyhorns: So it's hard to give a language agnostic answer
18:45:35 <fuzzyhorns> pjdelport: that was my intuition too
18:45:41 <silasm> fuzzyhorns: because they don't attach behavior to type checking?
18:45:41 <johnw> shlevy: you may want to use Snoyman's resource pool library
18:45:41 <Cale> fuzzyhorns: The term means something a bit different in each language
18:45:51 <shlevy> johnw: Checking, thanks
18:45:54 <johnw> shlevy: which he uses to achieve the exact same thing in both http-client and persistent
18:46:01 <fuzzyhorns> indeed Cale, I am wondering if they correspond to anything more abstract
18:46:14 <Cale> fuzzyhorns: Pretty much no.
18:46:38 <johnw> shlevy: http://hackage.haskell.org/package/resource-pool
18:46:49 <johnw> he deprecated his library in favor of bos's
18:46:56 <silasm> fuzzyhorns: http://mumble.net/~jar/articles/oo.html
18:47:06 <pjdelport> fuzzyhorns: Type classes interact with the type system in powerful ways, though. For example, Haskell can automatically infer which implementation of a type class to use depending on how one of its methods' return values are consumed somewhere down the line.
18:47:07 <fuzzyhorns> silasm: ty
18:47:17 <silasm> though that's more OO than 'classes'
18:47:20 <shlevy> johnw: So then the underlying type shouldn't force the use of a 'withFoo' function that brackets under the hood, right?
18:47:21 <Cale> pjdelport: Yeah, he's not actually asking about classes in Haskell
18:47:25 <pjdelport> fuzzyhorns: There's no real analog of that in OOP languages.
18:47:31 <silasm> it talks about how the whole concept is pretty badly defined in general.
18:47:33 <johnw> shlevy: right, not unless you want deterministic release
18:47:43 <shlevy> johnw: OK cool
18:47:53 <fuzzyhorns> yeah, i dislike it when things are so ill defined
18:47:59 <Cale> fuzzyhorns: They tend to be some weird combination of types and method implementations, which I think actually hurts proper application of OO even in cases where it's a good idea.
18:48:25 <kazagistar> fuzzyhorns: OO classes are like a strange, glued togeather combination of typeclasses, types, state monads, and namespaces
18:48:52 <fuzzyhorns> kazagistar: yeah :/ i am finding them really annoying, especially used in inheritance
18:49:50 <rwbarton> things get really weird when you allow downcasting
18:49:59 <kazagistar> fuzzyhorns: a lot of OO people do to, which is why these days, they have been using less of the "class" features
18:50:26 <Kaidelong> pjdelport: sorry to be so pendantic. There is Scala, it's OOP and has something very much like typeclasses
18:50:29 <jmcarthur> records in haskell are actually a lot like the way i think of classes in OO languages. they are an interface, hiding implementation details. (in the case of records, the hidden data can live in thunks, closures. in the case of OO, the hidden data is explicit private fields)
18:50:31 <Kaidelong> they can even have higher kinds
18:50:32 <fuzzyhorns> kazagistar: it is odd to me though that one of the few class-less languages (javascript) is going to be taking them on too :c
18:50:35 <kazagistar> "composition over inheritence", "program to the interface, not the implementation", etc
18:50:41 <Cale> fuzzyhorns: Because these languages tie the method implementations to the types of the objects (rather than simply having the type of an object reflect which methods it can respond to), you're required to use subclasses to introduce other implementations of methods.
18:50:57 <jmcarthur> i only say records because they are syntactically closer to tuples, ADTs, etc., but honestly, anywhere you can use a closure or laziness...
18:51:00 <fuzzyhorns> kazagistar: practically my mottos there :p
18:51:00 <johnw> fuzzyhorns: awesome stealth troll, whether you intended to or not :)
18:51:05 <jmcarthur> *closer than
18:51:16 <pjdelport> Kaidelong: True, but it's explicitly a mixed-paradigm functional / OO language. :)
18:51:25 <johnw> there should be an Internet contest for "largest discussion provoked by question of the fewest words"
18:51:26 <td123> does anyone know of a function that takes in a list of Strings or rather Ord a and returns all the elements that have a duplicate in the list?
18:51:40 <fuzzyhorns> johnw: lol i do what i can
18:52:05 <Cale> td123: concatMap tail . group . sort
18:52:06 <shlevy> td123: Probably only need Eq a no?
18:52:06 <jmcarthur> kazagistar: "program to the interface, not the implementation"  <-- i take issue with that one, actually. i think you should not code to the interface either. code to the semantics, instead!
18:52:26 <td123> shlevy: you're right
18:52:59 <td123> Cale: that is beautiful
18:53:13 <td123> thanks :)
18:53:19 <Cale> td123: Note that this'll give you duplicates if there's 3 or more
18:53:35 <Cale> td123: So you may want to go with something like concatMap (take 1 . tail) . group . sort
18:53:35 <rwbarton> jmcarthur: isn't downcasting (+ the fact that you can define subclasses "after the fact", open-world style) problematic for this viewpoint, though?
18:53:42 <kazagistar> fuzzyhorns: if you want a good starting point for discussing the advantages of the haskell style, you might start with the Simple Made Easy talk, it convinced me to learn haskell, and it is not even about haskell :P
18:53:50 <kazagistar> fuzzyhorns: http://www.infoq.com/presentations/Simple-Made-Easy
18:54:02 <fuzzyhorns> kazagistar: thank you! :)
18:54:21 <td123> Cale: ya, the 2nd version seems a little better
18:54:22 <johnw> td123: crazy slow, but: \xs -> nub (xs \\ nub xs)
18:54:55 <jmcarthur> rwbarton: not problematic. my point is interface driven, but yours is type system driven. they aren't mututally exclusive.
18:54:57 <kazagistar> fuzzyhorns: I think he explains the benefits of not gluing potentially separate ideas into complex things like classes very very eloquently
18:56:01 <yellow13> pjdelport: Ive pasted the error msg with the code http://lpaste.net/107083. I think I dont know yet hot to constrain the type so print can work
18:57:18 <shlevy> Hmm
18:57:26 <chrisdotcode> johnw: I'll see you in #gitlib?
18:57:29 <jmcarthur> rwbarton: you can get something like that subtyping by using type classes instead of records.   data Object class = forall e. class e => Object e.   you can safely cast to superclasses via pattern matching and reconstruction.     (i may have gotten some detail wrong in this explanation)
18:57:35 <johnw> chrisdotcode: i'm there
18:57:38 <shlevy> Ah never mind :D
18:57:56 <jmcarthur> rwbarton: one such detail is that class is a keyword ;)
18:58:26 <kazagistar> jmcarthur: I have mixed feelings about that, I like semantics, but they tend to constrain use if overused... plus, I think the original phrase implies the semantics are encoded in the interface to an extent, either via documentation or types
18:59:09 <rwbarton> semantically you can no longer say that a value of a class is defined by its behavior, if you can also test whether it belongs to a subclass
18:59:14 <pjdelport> yellow13: Ah! that's a different problem.
18:59:18 <pjdelport> :t (/)
18:59:19 <lambdabot> Fractional a => a -> a -> a
18:59:19 <rwbarton> the interface becomes extensible also
18:59:43 <pjdelport> yellow13: (/) expects a Fractional instance, while the rest of the operations you have are all Integral.
19:00:10 <pjdelport> yellow13: You can see that from the inferred type signature: collatz :: (Fractional a, Integral a) => a -> [a]
19:00:11 <jmcarthur> rwbarton: i agree with what you just said but don't know who you said it to. if it was to me, i don't see how it's relevant.
19:01:07 <pjdelport> yellow13: GHCi is complaining because it doesn't know of a type that satisfies both Fractional and Integral constraints. (The builtin types satisfy one or the other.)
19:01:25 <jmcarthur> kazagistar: That statement is bizarre to me. How can one determine whether a program is correct at all without understanding the intended semantics?
19:01:27 <pjdelport> yellow13: To fix it, there is an integer division operator in addition to Fractional's /
19:01:29 <pjdelport> :t div
19:01:30 <lambdabot> Integral a => a -> a -> a
19:01:42 <pjdelport> yellow13: If you replace the / with `div`, it should work fine.
19:02:07 <jmcarthur> kazagistar: Sorry, it was weird of me to call that "bizarre." I just mean I don't think I understand where you are coming from.
19:02:54 <pjdelport> yellow13: For the Collatz sequence, you know that the integral `div` is safe and precise because it only gets used in the even case, of course.
19:04:30 <rwbarton> jmcarthur: I mean you can't translate a class declaration into an equivalent record type in the obvious way, in a language that permits downcasting
19:04:48 <jmcarthur> kazagistar: I was just trying to point out that an interface is no substitute for having a simple and precise goal in mind. There are too many people that take that rule of thumb to heart without thinking about where the interface should even be coming from.
19:04:54 <rwbarton> jmcarthur: I guess you only said that they are a lot [a]like, though, which I agree with
19:04:59 <kazagistar> jmcarthur: I think what I am calling semantics should be really called specific domain logic. Reuse comes from stripping out specifics... instead of sorting "MyWebsiteUsername"s, you sort anything for which an ordering is defined, that is all I was trying to say
19:05:27 <yellow13> pjdelport: Got it, Thanks! I didnt know that mixing the types would be so bad.
19:09:45 <pjdelport> yellow13: It's not usually so bad... the numeric type classes are a bit on the complicated side.
19:12:28 <rwbarton> downcasting seems to be a similar sort of thing to Typeable
19:17:25 <meretrix> How can I select the next element in a list after the element that matches a given value?
19:17:33 <meretrix> I've tried:
19:17:40 <meretrix> > let { f x (x:(y:_)) = y; f _ (_:z) = z }
19:17:41 <lambdabot>  not an expression: ‘let { f x (x:(y:_)) = y; f _ (_:z) = z }’
19:18:23 <meretrix> Hmm.. that at least gave me an error in ghci.
19:18:34 <kazagistar> you have to do @let in lambdabot
19:18:43 <kazagistar> its not the same as ghci
19:18:47 <meretrix> > @let { f x (x:(y:_)) = y; f _ (_:z) = z }
19:18:48 <lambdabot>  <hint>:1:1: parse error on input ‘@’
19:18:55 <meretrix> @let { f x (x:(y:_)) = y; f _ (_:z) = z }
19:18:55 <enthropy> > case break (== 'k') ['a' .. ] of (_, _ : z : _ ) -> z
19:18:55 <lambdabot>  .L.hs:149:3:
19:18:56 <lambdabot>      Conflicting definitions for ‘x’
19:18:56 <lambdabot>      Bound at: .L.hs:149:3
19:18:56 <lambdabot>                .L.hs:149:6
19:18:56 <lambdabot>      In an equation for ‘L.f’
19:18:57 <lambdabot>  'l'
19:18:58 <pjdelport> meretrix: Remove the {}'s, and the conflicting binding of x
19:19:22 <kazagistar> you defined x twice on the left
19:19:36 <meretrix> Yes, because I want those two values to match.
19:19:48 <enthropy> that's not allowed
19:19:50 <rwbarton> you need to use a guard
19:20:12 <meretrix> Thanks I'll try that.
19:20:14 <kazagistar> meretrix: you need to do that match check on the right, since that is where the computation happens
19:20:32 <micahcowan> Not actually using x, so could probably use _ ?
19:21:00 <micahcowan> Oh, nm, wants it to match the first arg. :)
19:21:26 <enthropy> meretrix: and the second equation should probably call f again
19:21:38 <enthropy> (or just use Prelude.break as above)
19:21:52 <micahcowan> Also need to handle when you run out of list...
19:22:04 <pavonia> Is there a special reason we don't have an extension that allows duplicate variables on the left-hand side?
19:22:53 <enthropy> probably because nobody has written it yet
19:23:00 <micahcowan> Among other things, it'd be confusing, I'd think. My mind wants to read it as "if you find a match here, call it x, and if you find a match there, call it x". It wasn't immediately obvious that a relationship between them was intended.
19:23:21 <kazagistar> pavonia: what should it do exactly? add an Eq requirement and compare, and fail to match if they arent equal?
19:23:27 <enthropy> well you get that behavior with type variables
19:23:37 <enthropy> instance C a a
19:23:38 <ReinH> meretrix: what type do you want this function to have?
19:23:52 <rwbarton> it's also unclear what order the equality checks would occur in relative to pattern matching
19:24:40 <pavonia> kazagistar: It could match on structural equality and fail otherwise
19:25:27 <kazagistar> pavonia: I am not convinced that structual equality is something that we can reasonably check either? hmm
19:25:30 <enthropy> f x x = e  could become  f x x' | x == x' = e
19:25:56 <enthropy> Eq is what gets used for literals already
19:26:01 <kazagistar> as rwbarton said, what order does the equality checks happen?
19:26:18 <vanila> unspecified
19:26:41 <pqmodn> is there an example where order of equality checks matters?
19:26:48 <rwbarton> you can also write it currently with a view pattern
19:26:56 <rwbarton> f x ((== x) -> True) = e
19:26:59 <kazagistar> the result of some compare could be bottom
19:27:13 <Desheng> @src (>>=) :: [Int]
19:27:13 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:27:48 <kazagistar> but the result of another compare might just fail, so behavior would vary by which order they are checked
19:27:59 <rwbarton> or a pattern match might fail
19:28:11 <kazagistar> indeed
19:28:35 <enthropy> so the sane thing would be to do what the view pattern does
19:28:40 <rwbarton> 'f x x True = e' -- is this 'f x x' True | x == x' = e' or is x == x' tested before attempting to match True
19:28:44 <enthropy> which is left-to-right, top to bottom
19:29:05 <rwbarton> yeah
19:29:14 <rwbarton> also how numeric literals work I think
19:29:21 <pqmodn> oh, i see
19:30:16 <kazagistar> but really, I quite like the left side being "deconstruction" and the right being "construction", in some sense
19:31:15 <pavonia> rwbarton: Why would that matter? You'd have to check if x and x', and True match anyways
19:31:35 <pqmodn> i think prolog supports this and i'm not sure if you can specify which order things are unified
19:31:39 <rwbarton> x == x' might diverge when the third argument is actually False
19:32:00 <rwbarton> or conversely x == x' might be false when the third argument is actually _|_
19:32:22 <rwbarton> in each case one pattern match will diverge while the other will fail and proceed to the next pattern
19:32:23 <vanila> pqmodn, the order doesn't matter in prolog because it's strict - this is an issue in Curry though
19:33:25 <pqmodn> neat, i hadn't heard of Curry before
19:33:56 <kazagistar> I guess an advantage of strictness is that bottom is never a parameter... but many of them jam in null just to negate the advantage entirely haha
19:35:38 <pavonia> What's the difference between diverge and fail when talking about pattern matching?
19:36:08 <kazagistar> pavonia: do you know what bottom means?
19:36:16 <pavonia> I think so
19:36:38 <kazagistar> diverge is a bottom
19:36:53 <rwbarton> from the Haskell report "Attempting to match a pattern can have one of three results: it may fail; it may succeed, returning a binding for each variable in the pattern; or it may diverge (i.e. return _|_)."
19:37:26 <pavonia> Ah
19:38:36 <kazagistar> so, for example
19:38:40 <haasn> Does Haskell per-report assume Haskell implementations have unbounded memory?
19:39:28 <Cale> haasn: The original report pre-FFI doesn't talk about memory much at all.
19:40:30 <Cale> haasn: The FFI stuff says that if one of the allocations fails, you get a nullPtr result
19:40:35 <rwbarton> would be funny to see in the "divergence from the Report" section of the manual
19:40:45 <rwbarton> "GHC only runs on machines with bounded memory."
19:40:48 <Cale> (for the stuff which is explicitly about allocating a bunch of memory)
19:41:25 <kazagistar> > let f False x = 1 in f False (last [1..])
19:41:26 <lambdabot>  1
19:41:46 <kazagistar> er, that wasnt what I wanted actually lol
19:43:22 <kazagistar> > let f 1 (x:xs) = 1 in f 1 ( last [1..] : [] )
19:43:23 <lambdabot>  1
19:43:45 <kazagistar> ugh, it is sooo lazy
19:44:14 <kazagistar> > let f 1 1 = 1 in f 1 ( last [1..] )
19:44:18 <lambdabot>  mueval-core: Time limit exceeded
19:44:32 <kazagistar> > let f 0 1 = 1 in f 1 ( last [1..] )
19:44:34 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function f
19:45:06 <kazagistar> > let f 1 0 = 1 in f ( last [1..] ) 1
19:45:10 <lambdabot>  mueval-core: Time limit exceeded
19:47:03 <kazagistar> I guess if the matching on the left added an Eq constraint, unified the types, and had a consistant way to decide when to compare, it could work
19:54:51 <haasn> Cale: It would be funnier to see “You may only run GHC on machines with unbounded memory. Failure to comply with this restriction may impact GHC's ability to correctly implement Haskell”
19:56:45 <augur> runghc ..
19:56:54 <haasn> “Tuples are currently limited to size 100. [...] This limitation is easily subvertible, so please ask if you get stuck on it.”
19:57:19 <haasn> I would rather not know what kind of code could *possibly* get stuck on GHC's tuple size limitation and provide a serious argument for extending it
19:57:28 <augur> RunGHC is the functional programmer cover group for RunDMC
19:57:55 <vanila> 3-tuples and higher shouldn't exist
19:58:01 <Cale> haasn: Presumably something which generates Haskell code
20:00:40 * hackagebot esqueleto 1.4.2 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.4.2 (FelipeLessa)
20:00:53 <trap_exit> is there a good library
20:01:01 <trap_exit> for wriintg haskell code that does not fit in memory?
20:01:08 <trap_exit> i.e. I want to do list comprehension ove ra dataset which fits only on disk
20:01:11 <trap_exit> and not in RAM
20:01:19 <trap_exit> is there some monad that allows me to do such black magic?
20:01:22 <kazagistar> vanila: indexing a 3d array seems like a reasonable use case
20:01:51 <vanila> why not use a 3-vector?
20:02:20 <kazagistar> vanila: because you might use different types for the different dimentions
20:04:26 <kazagistar> trap_exit: well, I am pretty sure that the naive version of file reading and writing is lazy (along with lists), so it would work, right?... but you might look into Conduit or Pipes
20:04:47 <pqmodn> trap_exit: conduits, pipes, etc are commonly used libraries to do streaming... yeah, kazagistar said it
20:05:19 <trap_exit> streaming
20:05:21 <trap_exit> that's what I'm looking for
20:05:40 <kazagistar> trap_exit: lazyness means streaming by default
20:05:46 <haasn> lazy IO does not give you a guarantee, though; pipes/conduit etc. do
20:05:56 <haasn> If you want a guarantee that your program will not crash, avoid lazy IO
20:06:10 <kazagistar> can't argue with that
20:06:47 <kazagistar> but it is important to understand, I think, how something like interact works
20:10:16 <kazagistar> main = interact (show . sum . map (read :: String -> Int) . lines)
20:11:02 <kazagistar> unless I made a silly mistake, that should work for arbitrary input sizes?
20:13:15 <rwbarton> only if sum is converted from foldl to foldl' by the optimizer
20:13:32 <rwbarton> a good example of how pipes/conduit/etc. doesn't really give you a guarantee
20:13:56 <rwbarton> you still have to not make certain other classes of errors
20:15:30 <kazagistar> ... sum isn't programmed with foldl'?
20:15:37 <kazagistar> @src sum
20:15:37 <lambdabot> sum = foldl (+) 0
20:15:42 <kazagistar> oh god
20:15:47 <pqmodn> haha
20:16:07 <kazagistar> ...w...why....?
20:16:20 <pqmodn> maybe it's an intentional teaching moment
20:16:37 <Desheng> @src read
20:16:37 <lambdabot> read s = either error id (readEither s)
20:16:43 <MP2E> I dunno, I'd be inclined to think it's another 'mistake of history'
20:16:46 <MP2E> ;v
20:17:15 <platz> what is #ifdef USE_REPORT_PRELUDE
20:17:20 <rwbarton> sum predates foldl' I think
20:17:38 <rwbarton> in the ancient history of Haskell
20:17:43 <systemfault> Does ghci has a @src command?
20:17:44 <platz> https://hackage.haskell.org/package/base-4.3.0.0/docs/src/Data-List.html#sum
20:17:51 * Desheng starts reading mac lane
20:18:00 <kazagistar> ah, ok, I see
20:18:33 <kazagistar> so it has a sane version it actually uses, and then if you want to use the "official haskell report version" you can build it that way too
20:18:53 <Desheng> I want to gobble up category theory knowledge until I grok it so well that every time I think of a problem my mind selects something from Kmett's category-extras
20:19:02 <platz> I don't trust lambdabot's src ever
20:19:36 <Desheng> systemfault: it's part of lambdabot, which you can also compile+use offline, and you can get it through cabal
20:20:11 <systemfault> Ah :/ But if platz is right… lambdabot is not even trustable for @src?
20:20:14 <kazagistar> not sure why they reimplement foldl' in the non-prelude version though... is there a reason standard libraries seem to always manually do recursion?
20:20:24 <rwbarton> the "sane" version is equivalent to foldl though, just inlined a bit
20:20:40 <rwbarton> there is no seq there, ' notwithstanding
20:20:46 <kazagistar> oh, right you are
20:21:04 <haasn> http://code.haskell.org/lambdabot/State/source
20:21:07 <kazagistar> sooo, I guess we pray that GHC is wise and benevolent and does not make a trillion useless thunks
20:21:09 <haasn> Here's the @src @src
20:21:16 <ReinH> both are just worker wrapper transforms
20:21:33 <rwbarton> I speculated why here http://stackoverflow.com/questions/24391077/why-two-definitions-of-reverse-in-haskells-data-list/24433592#24433592
20:22:13 <kazagistar> are there any guarentees for those foldl type optimizations?
20:22:21 <rwbarton> I wonder why foldl doesn't have a USE_REPORT_PRELUDE version
20:22:52 <benzrf> rwbarton: whats the diff
20:23:36 <benzrf> oh
20:24:05 <rwbarton> the Report one isn't manually worker-wrapper transformed
20:24:31 <kazagistar> rwbarton: it looks like all the ones that have that version split, the haskell report version uses some function instead of just implementing it from scratch
20:25:24 <haasn> foldl' was mentioned earlier; I'd like to point out that foldl (+) 0 and foldl' (+) 0 have different semantics
20:25:50 <benzrf> haasn: bottomwise?
20:25:55 <haasn> Although the difference isn't as big as with genericSum
20:26:00 <pjdelport> sum with foldl makes sense for lazy Num instances.
20:32:29 <bollu> > (-) <*> +1 $ 10
20:32:30 <lambdabot>  <hint>:1:9: parse error on input ‘+’
20:32:41 <bollu> > (-) <*> (+1) $ 10
20:32:43 <lambdabot>  -1
20:32:55 <bollu> can someone explain to me how the binding takes place on that expresison?
20:33:05 <bollu> why does that expression become 10 - (10 + 1) ?
20:33:27 <latro`a> :t (<*>)
20:33:28 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:33:30 <kazagistar> lets start from the left
20:33:40 <bollu> kazagistar: sure
20:33:45 <kazagistar> :t (-)
20:33:46 <lambdabot> Num a => a -> a -> a
20:34:17 <bollu> kazagistar: right, so as I understand it, the 'f' binds to (a ->)
20:34:17 <kazagistar> so, how does (a -> a -> a) match ( f (a - b) )
20:34:33 <bollu> f become ((->) a) right?
20:34:41 <kazagistar> k good
20:34:43 <bollu> so f a -> b become a -> a -> b
20:34:55 <latro`a> *f (a->b)
20:35:04 <kazagistar> well, they unify
20:35:06 <latro`a> err sorry, nvm
20:35:12 <bollu> kazagistar: meaning?
20:35:17 <latro`a> and no, f a -> b is (a -> a) -> b
20:35:33 <bollu> latro`a: doesn't currying make the brackets... pointless?
20:35:34 <latro`a> a -> a -> b is a -> (a -> b)
20:35:43 * hackagebot github-backup 1.20140707 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20140707 (JoeyHess)
20:35:55 <Desheng> is there a name for ((->) a)? I don't understand that concept and it's completely ungoogleable
20:35:58 <kazagistar> so all instances of a == b, and all instances of f == (a -> )
20:36:04 <pqmodn> Desheng: reader
20:36:06 <bollu> kazagistar: okay, sure :)
20:36:16 <Desheng> thank you
20:36:17 <kazagistar> I am about to explain reader, patience :P
20:36:25 <geekosaur> it's the primitive Reader monad. also, consider symbolhound
20:36:25 <kazagistar> or try at least
20:36:35 <kazagistar> if I fail there is the internet
20:36:39 <kazagistar> haha
20:36:59 <bollu> kazagistar: go on
20:37:02 <pqmodn> it's never wrong
20:37:20 <kazagistar> so, how do we write an instance of that function that matches that type signature?
20:37:38 <kazagistar> how do we create an applicative instane for (a ->)?
20:38:10 <bollu> kazagistar: lost you there. what do you mean by "how do we create an applicative instance for  (a ->)" ?
20:38:10 <kazagistar> well, what does (a -> ) mean?
20:38:19 <bollu> kazagistar: somethng that uses type a
20:38:31 <latro`a> (it's probably a little confusing to write (a ->), because f (a -> b) is (c -> a -> b))
20:38:38 <latro`a> (not necessarily (a -> a -> b))
20:38:47 <bollu> latro`a: right, but here it becomes a -> right?
20:39:05 <kazagistar> bollu: but we are trying to thing of what <*> does with it
20:39:49 <latro`a> in short, we're trying to write a function whose type is (c -> a -> b) -> (c -> a) -> (c -> b)
20:39:49 <bollu> kazagistar: hm, I don't know how <*> interacts with (a ->)
20:39:54 <kazagistar> and in <*>, it is general, so it might be different from those types
20:40:06 <kazagistar> :t (<*>)
20:40:07 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:40:18 <kazagistar> ok, so
20:40:18 <haasn> :t (<*>) `asAppliedto` (undefined :: c -> a -> b)
20:40:19 <lambdabot>     Not in scope: ‘asAppliedto’
20:40:19 <lambdabot>     Perhaps you meant ‘asAppliedTo’ (line 158)
20:40:23 <haasn> :t (<*>) `asAppliedTo` (undefined :: c -> a -> b)
20:40:24 <lambdabot> (c -> a -> b) -> (c -> a) -> c -> b
20:40:41 <bollu> haasn: why isn't there a bracket on the last c -> b?
20:40:56 <latro`a> those are the same; -> is right-associative
20:40:58 <haasn> -> is right-associative, x -> c -> b is the same as x -> (c -> b)
20:41:03 <bollu> haasn: ohh
20:41:20 <bollu> haasn: and also (x -> c) -> b right?
20:41:22 <kazagistar> "a function that if given c, returns an a to b function"... "a function that when given c, returns an a" ... "a function, that if given c returns a b"
20:41:23 <latro`a> no
20:41:38 <bollu> latro`a: why not?
20:41:38 <latro`a> (x -> c) -> b takes a function as an argument
20:41:50 <haasn> bollu: Try to compare it to (-), which is left-associative: a - b - c means (a - b) - c, which is distinct from a - (b - c) = a - b + c
20:42:02 <latro`a> x -> c -> b takes an x as an argument, and returns a function of type c->b
20:42:30 <bollu> haasn: oh, thanks. that makes it much clearer. latro`a : ty. makes. sense
20:42:36 <bollu> kazagistar: continue
20:42:38 <bollu> :)
20:42:40 <kazagistar> lets try to write an instance
20:43:21 <bollu> kazagistar: of <*> for f = c-> correct?
20:43:36 <kazagistar> or rather, lets try to write a function that does the same thing as <*> on c ->, exactly
20:43:46 <bollu> kazagistar: ah, sure
20:43:53 <kazagistar> so, it takes two parameters, so that is a start... func x y = ...
20:44:18 <kazagistar> now, what do we have to return?
20:44:54 <kazagistar> a function that takes 'c', and returns 'b'
20:45:04 <bollu> kazagistar: hm, right
20:45:35 <kazagistar> so ill get started with that... func x y = (\z -> ...)
20:45:52 <kazagistar> now, where do we get a "b" from?
20:45:54 <bollu> whoops, sorry
20:46:06 <latro`a> <kazagistar> so ill get started with that... func x y = (\z -> ...)
20:46:33 <kazagistar> (c -> a -> b) -> (c -> a) -> c -> b
20:46:34 <bollu> kazagistar: from the first application?
20:46:45 <bollu> kazagistar: from the c -> a -> b
20:47:00 <bollu> by applying the c -> a function on the c -> a -> b?
20:47:06 <kazagistar> right, we get it from the result of that function, but we need  a 'c' and an 'a' to get it
20:47:15 <bollu> kazagistar: oh, yeah
20:47:29 <kazagistar> well, we have exactly 1 c
20:47:37 <kazagistar> but where do we get the a?
20:47:48 <bollu> kazagistar: can you not also see it as "passing" (c -> a) to the (c ->a -> b)? so (c -> a -> b) becomes ((c -> a) -> b) ?
20:48:00 <kazagistar> no, that is backwards
20:48:17 <kazagistar> the associativity is backwards
20:48:17 <bollu> kazagistar: why?
20:48:19 <latro`a> c -> a -> b wants a c and an a; you need to produce an a to give to it
20:48:33 <kazagistar> c -> (a -> b)
20:48:34 <bollu> latro`a: aargh, right. sorry
20:48:38 <bollu> kazagistar: yeah, sorry :)
20:48:50 <kazagistar> so we need both of those values to pass in
20:49:01 <latro`a> put another way, we now have an a -> b
20:49:05 <latro`a> namely x z
20:49:19 <kazagistar> right
20:49:21 <bollu> kazagistar: so we can use the (c -> a) function to generate 'a' from out 'c'
20:49:28 <kazagistar> yep
20:49:42 <bollu> kazagistar: so it becomes something like g(c) c b
20:49:44 <kazagistar> there is really only one way to define it :P
20:49:49 <bollu> so now we need the b
20:50:03 <kazagistar> uh
20:50:10 <bollu> kazagistar: no, sorry
20:50:12 <kazagistar> we get the b as the result of the first function
20:50:13 <bollu> kazagistar: got it. it returns a b
20:50:14 <latro`a> I was being insistent about the signature because there are more definitions for (a->a->a)->(a->a)->(a->a), such as flip const
20:50:26 <latro`a> but there is only one {c->a->b)->(c->a)->(c->b)
20:50:42 <bollu> kazagistar: then what happens to the final c?
20:50:52 <latro`a> that was z
20:51:09 <latro`a> func x y = (\z -> x z (y z))
20:51:10 <kazagistar> bollu: thats exactly right... until we get that c, we cant actually get a value
20:51:45 <kazagistar> so we have to return a function, that if given a 'c', passes it into the two functions and generates a 'b'
20:51:50 <platz> how do haskeller's feel about Domain Driven Design.. too OO-smelly or some good ideas there?
20:52:14 <bollu> kazagistar: ahh
20:52:23 <bollu> kazagistar: okay, I think I get it now
20:52:34 <bollu> kazagistar: oh man that is /smart/
20:52:47 <bollu> kazagistar, latro`a thanks guys :) finally makes sense!
20:53:02 <kazagistar> bollu: an intuition here is something like this... a Reader takes to things that require the same "configuration file" or whatever, and composes them into a single thing
20:53:39 <systemfault> platz: DDD is more about modeling a domain than just learning a few OO patterns like factory and repository. I totally think it applies (My knowledge of Haskell is still weak though)
20:53:46 <bollu> kazagistar: care to expand on the intuition?
20:54:42 <kazagistar> bollu: hmm, how about this...
20:54:42 <platz> systemfault: thats fair - some things there seem pretty neat - aggregrate roots - bounded contexts
20:55:00 <systemfault> platz: Actually, I think that DDDD(CQRS/ES)  could be better with a functional programming than OO
20:55:01 <platz> but just the word Entity, "shudder"
20:55:46 <platz> was just about to bring up the CQRS/ES story - that is super compelling already - scala/akka folks really embraced it
20:56:02 <systemfault> What’s wrong with entities? Mutability?
20:56:10 <platz> but I think of CQRS/ES as a particular kind of DDD
20:56:19 <latro`a> bollu: it may help to show that =<< and <*> are the same for the function monad, up to ordering
20:56:48 <kazagistar> getUser :: (Config -> PersonName), getPrivalages :: (Config -> PersonName -> Privalages)
20:56:49 <latro`a> :t (>>=) `asAppliedTo` (undefined :: r -> a)
20:56:49 <platz> I don't know yet, still learning DDD, but my collective memory probably is just associating it with misuse from elsewhere
20:56:49 <lambdabot> (r -> a) -> (a -> r -> b) -> r -> b
20:56:58 <kazagistar> dunno
20:57:00 <systemfault> platz: I see it as an extension of DDD… Even Eric Evans said that he should have added Domain Events to his book
20:57:32 <latro`a> the first function produces the "a" that you need to get a new function to tell you how to continue
20:58:18 <systemfault> platz: My big problem with DDD and OO… impedence mismatch. And ORMs help but pollute your domain with things like annotations and default constructors when your entities don’t need em.
20:58:24 <latro`a> (just as with most monads: the first IO action produces the "a" that you need to know how to continue. the maybe value provides the "a" that you need to know how to continue, or if it doesn't the procedure fails)
20:58:30 <platz> systemfault: but true CQRS/ES implies eventual consistency and separating out reads and writes very strongly - i didn't know if DDD always made that distinction
20:58:48 <systemfault> platz: No, DDD itself is not a BASE architecture.
20:58:59 <StoneCypher4k> MORE ACRONYMS
20:59:02 <StoneCypher4k> I NEED MORE ACRONYMS
22:11:07 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
22:11:07 --- topic: set by Cale!~Cale@CPEc8d3a35c2cdd-CM78cd8ec9750d.cpe.net.cable.rogers.com on [Sat May 31 02:09:44 2014]
22:14:00 <benbangert> rwbarton: yea, there's ByteString's all over the place
22:15:52 <benbangert> rwbarton: heh, switching it to not use Text though, and memory is now holding steady. leak is gone. hmmm
22:16:07 <johnw> benbangert: you may want to let Snoyman know; it could be a leak in his new web sockets code
22:16:37 <benbangert> johnw: yea, his new web socket code does work great though. the websockets lib leaks horribly
22:16:43 <johnw> what a nice pasting service, I like it
22:19:59 <gamegoblin> @pl \x y -> f (map y (map x xs))
22:19:59 <lambdabot> (f .) . flip map . flip map xs
22:20:30 <johnw> that's also the same as f (map (x . y) xs)
22:20:36 <gamegoblin> @hoogle a -> b -> (a -> b -> c) -> c
22:20:37 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
22:20:37 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
22:20:37 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
22:20:52 <gamegoblin> thanks johnw
22:21:08 <johnw> oops, (y . x)
22:22:07 <gamegoblin> @pl \a b -> f $ map (b . a) xs
22:22:07 <lambdabot> (f .) . flip flip xs . (map .) . flip (.)
22:22:15 <gamegoblin> heh. Think I’ll leave it pointful.
22:23:16 <johnw> @pl \a -> f $ map (b . a) xs
22:23:16 <lambdabot> f . flip map xs . (b .)
22:23:44 <johnw> it's like a challenge to whoever reads your code: understand me and you win a prize!
22:24:12 <johnw> @pl \b -> f $ map (b . a) xs
22:24:13 <lambdabot> f . flip map xs . (. a)
22:25:16 <l0cust> Hey, how do I write my typeclass such that there is a minimally complete definition?
22:25:37 <l0cust> Or rather, how do I specify a small set of functions as a minimally complete definition?
22:26:14 <gamegoblin> l0cust: write the non-necessary functions relative to the necessary ones
22:26:22 <l0cust> gamegoblin: thanks
22:26:24 <gamegoblin> l0cust: that is, put an actual function body beneath the signature
22:26:30 <enthropy> @src Eq
22:26:30 <lambdabot> class  Eq a  where
22:26:30 <lambdabot>     (==), (/=)   :: a -> a -> Bool
22:27:05 <dwcook> You can often do that for all methods, in fact, but then you need to work out which ones can be redefined to break the cycle
22:27:11 <enthropy> that one has  a == b = not (a /= b); a /= b = not (a == b)
22:28:04 <alpounet> l0cust: there's a MINIMAL pragma since 7.8.1: https://www.haskell.org/ghc/docs/7.8.1-rc1/html/users_guide/pragmas.html, scroll down to "7.19.5. MINIMAL pragma"
22:39:11 <kazagistar> would the base library accept pull requests adding MINIMAL pragma definitions for things that are missing them?
22:40:12 <enthropy> changes to base happen through proposals to libraries@haskell.org
22:42:24 <enthropy> kazagistar: seems like they are all in there (or that was the intention at least)
22:44:07 <tnks> looking at hackage docs, and just curious. . . how are the Portability and Safe Haskell docs populated?
22:44:17 <tnks> fields, I mean.
22:44:26 <tnks> is that automatic for all builds?
22:44:51 <enthropy> Portability is just part of the comment for the module
22:45:21 <enthropy> Safe Haskell is whatever extension the module gets compiled with (-XSafe, -XTrustworthy)
22:45:42 <tnks> hmm. . . don't see it in Ed's cabal file.
22:46:33 <tnks> ah, I see it. . . it's in pragmas in the source, I guess.
22:46:57 <enthropy> kazagistar: which ones were forgotten in https://ghc.haskell.org/trac/ghc/ticket/7633#comment:35 ?
22:48:29 * enthropy sees Floating, RealFloat missing them
22:48:30 <tnks> so "Portability" is just referring to extensions that might leak out into call sites?
22:49:32 <enthropy> probably it's any extension used in the module, but I don't think there's a universal definition
22:49:47 <tnks> I see.
22:49:52 <tnks> Ed's putting stuff there.
22:50:10 <tnks> I've ignored it til now.
22:51:16 <tnks> hmm. . . according to http://www.haskell.org/haskellwiki/Programming_guidelines#File_Format
22:51:32 <tnks> it seems that "portable" might be "adheres to Haskell 98"
22:52:45 <tnks> maybe that's dated.
22:54:02 <kazagistar> enthropy: Ix is one I noticed was missing it a few weeks back
23:09:01 <kosmikus> ocharles: I'm certainly happy that bos accepted. The order of speakers is still preliminary.
23:17:56 <gamegoblin> Is there a tool that will go through my source code and add type declarations that ghc infers?
23:20:32 <enthropy> vim and emacs haskell-modes have things to add in type signatures
23:20:43 <enthropy> that might be close enough
23:39:05 <solidus-river> lol, jle`
23:39:19 <pure> Ahoy. I have this system of equations http://mathb.in/18246 Is it possible to solve and minimize for w+x+y+z over the positive integers in Haskell?
23:39:28 <solidus-river> i finally finished doing research on stuff and sat down to code this, its embarassing how little code it actually is
23:39:50 <solidus-river> does this always happen with haskell? like 90% research design, end result that couldhave been on a post-it
23:40:21 <solidus-river> i wish netwire had global events
23:40:22 <jle`> solidus-river: a lot of times, yes :)
23:48:43 <jle`> anyways the next step to a full on Wire
23:49:11 <jle`> solidus-river: would be data IAuto' e a b = IAuto' (a -> (Either e b, IAuto' e a b))
23:49:22 <jle`> which you can probably write the instance of easily if you already did the Maybe version
23:50:00 <jle`> the next step is data AutoM e m a b = AutoM (a -> m (Either e b, AutoM e m a b))
23:50:13 <jle`> where the Category instance requires Monad m
23:50:25 <jle`> ...or maybe only Functor m
23:50:32 <jle`> no, it needs Monad
23:50:55 <jle`> and then the final step is data Wire t e m a b = Wire (t -> a -> m (Either e b, Wire t e m a b))
23:51:11 <jle`> you should be able to write Category instances for all of those step-by-step...each one building from the last one
23:51:22 <jle`> et voila :)
23:51:59 <solidus-river> heh, might take a little but i'll work through em i fell asleep last night before getting the maybe instance in
23:52:02 <jle`> t can be s here
23:52:21 <solidus-river> then today i spent learning about bottom and definedness / fix
23:52:25 <jle`> feel free to jump to the end if you really want a challenge...but every step is sort of a step-by-step "upgrade" of the category instance
23:55:46 <solidus-river> stepwise sounds saner
