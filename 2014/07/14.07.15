00:02:20 <supki> Welkin: use it how?
00:02:36 <supki> Welkin: i.e., what are you trying to do?
00:02:38 * jack_rabbit whistles with MP2E
00:02:58 <Welkin> update cabal-install
00:03:11 <Welkin> it won't recognize 1.20.0.1 and still uses the old 1.14.0
00:04:14 <supki> Welkin: how did you install it?
00:04:25 <Welkin> cabal install cabal-install
00:04:43 <Welkin> 1.20.0.1 is local
00:04:47 <Welkin> 1.14.0 is global
00:04:49 <supki> ok, do you have $HOME/.cabal/bin in PATH?
00:05:17 <MP2E> $HOME/.cabal/bin also should precede everything else in your PATH, which is kinda important otherwise the global cabal could still overwrite it
00:06:10 <Welkin> there is nothing in .cabal/bin except for cabal itself
00:06:40 <Welkin> the packages are in ~/.ghc/x86_64-linux-7.4.1/package.conf.d
00:08:01 <MP2E> try 'export PATH=~/.cabal/bin:$PATH' then try cabal --version
00:09:03 <Welkin> okay, that worked
00:09:14 <Welkin> but how? if the packages aren't in .cabal/bin ?
00:09:26 * hackagebot flamethrower 0.0.4.0 - A template engine for HTML  http://hackage.haskell.org/package/flamethrower-0.0.4.0 (charmander)
00:09:26 * hackagebot apiary 0.12.4 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.12.4 (HirotomoMoriwaki)
00:09:30 <MP2E> They are in .cabal/bin the issue is is that your system doesn't automatically know to look in there
00:09:36 <MP2E> it checks $PATH to know where all the binaries are
00:09:45 <MP2E> so ~/.cabal/bin needs to be added to PATH
00:09:50 <MP2E> which is what that command did
00:10:07 <MP2E> you can actually place that in your .bashrc and you won't have to type it again, and the new cabal will overwrite the old one from now one
00:10:11 <MP2E> on*
00:10:22 <MP2E> and, better yet, when you update cabal again it'll just work
00:12:33 <Welkin> then why does it say my local installs are in a different directory under ghc-pkg list ?
00:12:46 <Welkin> thanks, by the way
00:13:32 <MP2E> np, and I'm not sure why it'd say that.. where does it say they are?
00:13:43 <Welkin> the packages are in ~/.ghc/x86_64-linux-7.4.1/package.conf.d
00:14:06 <bergmark> Welkin: that's the global package db, i'm guessing
00:14:09 <MP2E> Odd, that's usually where the package database is but not the actual packages themslves
00:14:10 <Welkin> no
00:14:35 <bergmark> it can also be configured in .cabal/config
00:14:39 <Welkin> global is in /var/lib/ghc/package.conf.d
00:16:36 <MP2E> this is just a guess, but perhaps .cabal/config from 1.14 is messing up the new one somehow? I heard something about having issues unless you force regenerate the config and redit that
00:16:43 <MP2E> with the new cabal
00:16:51 <MP2E> re-edit
00:16:55 <MP2E> heh reddit on the mind I guess
00:17:47 <Welkin> I just wanted to get sandboxes working
00:18:09 <Welkin> cabal always prints a lot of warnings and errors when installing packages
00:18:14 <Welkin> but it installs anyway
00:22:04 <trap_exit> suppose I wanted a language with Haskell's syntax, but was strict rather than lazy
00:22:12 <trap_exit> would I have to rewrite ghc's rts, or can I hack at a layer above that?
00:23:08 <bergmark> trap_exit: you could do a strictness transformation on the AST
00:23:10 <Welkin> ML is strict
00:23:22 <Boney> trap_exit: Why not use deciple?
00:23:37 <Boney> (I think it looks like Haskell).
00:23:51 <trap_exit> Boney: I have not heard about http://www.haskell.org/haskellwiki/DDC until just now
00:24:49 <trap_exit> can deciple output javasctipt ?
00:25:32 <louisjb> hi, a number of examples define a function sequence_ :: [IO a] -> IO () to execute a list of actions in sequence, this is defined in predef or Monad?
00:27:32 <MP2E> louisjb: according to hoogle, it's in Control.Monad and Prelude. So you shouldn't have to import anything to use it
00:30:00 <louisjb> MP2E it's just called sequence ?
00:30:50 <louisjb> oh, it is actually sequence_ - got it, thanks
00:31:22 <MP2E> There is a sequence it just does something different
00:31:28 <MP2E> sequence :: Monad m => [m a] -> m [a]
00:31:35 <MP2E> sequence_ :: Monad m => [m a] -> m ()
00:31:48 <Ainieco> hello, do you know any tools to visualize .prof and .hc profiling files?
00:32:13 <louisjb> ah right, so sequence is m of type unit, great - thanks
00:42:42 <peddie> Ainieco: you could try hp2ps or hp2html or http://www.haskell.org/haskellwiki/Hp2any
00:58:18 <Ainieco> peddie: thanks!
01:00:52 <Ainieco> what is fastest random implementation compatible with "random"? by compatible i mean that  all Random instances should still be valid
01:06:06 <prophile> Ainieco: https://gist.github.com/prophile/835ff415621cb42138b7
01:06:12 <Ainieco> i wonder why mwc random invents its own wheel while everyone create instances for Random it just doesn't have it...
01:08:58 <frerich> prophile: The documentation of 'next' says that "The next operation returns an Int that is uniformly distributed in the range returned by genRange (including both end points)", i.e. '1' is included. I'm not sure always yielding zero satisfies the "uniform distribution" requirement.
01:10:00 <prophile> frerich: hm, you may be right
01:11:06 <prophile> https://gist.github.com/prophile/835ff415621cb42138b7
01:11:09 <prophile> perhaps the second instance then
01:12:37 <Cale> Those instances of split are terrible
01:12:49 <Cale> but I guess that's about the best you can do with those silly types
01:13:32 <helge_> Sorry for a possibly dumb question, but what is the incentive to make your data structures a member of the Monad class? I can see how using do-notation and working inside a context might be good, but in most examples all they do is multiply some numbers together; any good resources for a more pragmatic usage of the Monad class?
01:14:50 <MP2E> helge_ : xmonad is a great example, it's a full Window manager for Linux and it is basically a giant Monad
01:15:06 <MP2E> It's also only about ~1000 lines of code which makes for easy reading
01:15:16 <helge_> cool, that's just what I wanted, thanks
01:15:21 <MP2E> np :)
01:15:44 <jb55> helge_: play around with parsec, that was a big eye opener for me
01:15:44 <helge_> reading real world source code is usually better than documentation/tutorial imo ;)
01:15:54 <helge_> jb55: noted
01:16:03 <MP2E> I completely agree, and jb55 is right. Monads really shine in the context of parsers
01:19:01 <christiaanb> Anyone here have an Idea where I could get an answer to the following question: http://www.haskell.org/pipermail/haskell-cafe/2014-July/115103.html  Just in case nobody responds to that email.
01:19:04 <frerich> helge_: I think the Monad instance for Maybe is also a compelling case, it nicely streamlines some constructions
01:19:19 <kvanb> Maybe is an awkward monad to use
01:19:32 <kvanb> I always end up raging out and using ErrorT (or ExceptT)
01:20:59 <frerich> kvanb: Whether or not it makes sense to make use of the Monad instance for Maybe probably depends on the functions you're dealing with, i.e. whether they lend themselves to exploit the "If anything yields Nothing, the whole thing yields Nothing" feature.
01:22:46 <frerich> kvanb: An 'awkward monad' to  me is the one for lists.
01:23:01 <frerich> I don't think I ever used that.
01:24:10 <frerich> Maybe I should think about problem which lends itself to exploiting this "multiple results" behaviour. Maybe a game engine exploring a tree of possible moves or something?
01:24:22 <Welkin> minimax
01:25:32 <frerich> Good idea!
01:25:44 <Welkin> with alpha-beta!
01:28:12 <MP2E> christiaanb : you may already know about this, but it looks as though Term is a Free Monad. Free Monads can have all of their fmap's accumulated into one traversal using the Yoneda Lemma, which uses the functor laws to combine the traversals together.
01:28:24 <MP2E> christiaanb: http://comonad.com/reader/2011/free-monads-for-less/ further reading on the subject by someone much more knowledgable than I
01:29:02 <christiaanb> MP2E: Thanks, I'll take a look and see if I can apply what's written there
01:29:23 <christiaanb> also happens to be by the same author as the package I'm using for my binders ;-)
01:29:30 <MP2E> hehe :P
01:30:25 <christiaanb> But perhaps I should not care too much about "additional traversals" and naively assume that lazy evaluation will amortize their costs
01:30:48 <xpika> is there a way to cabal install with a specific ghc version?
01:31:03 <christiaanb> xpika: cabal -w <path_to_ghc>
01:31:32 <christiaanb> e.g.: cabal -w /opt/ghc/ghc-7.8.1/bin/ghc
01:31:39 <zq> why does mtl encapsulate the monad transformer api into a typeclass?
01:33:17 <tdammers> zq: how else would you implement lift?
01:34:34 * hackagebot rest-gen 0.14.2 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.14.2 (mbrock)
01:35:41 <xpika> can i initialise a sandbox with a specific ghc?
01:36:25 <bergmark> you can use several ghcs in the same sandbox
01:36:38 <Welkin> who is familiar with cabal sandboxes?
01:36:38 <xpika> bergmark: ok
01:36:53 <bergmark> i think at least... i have a bit of a custom setup
01:36:55 <Welkin> do I need to add the path for every sandbox instance to my $PATH ?
01:36:57 <adimit> xpika: you could keep a shell open and alias cabal to cabal -w ghc_version.
01:37:02 <MP2E> Welkin : unfortunately yes
01:37:06 <Welkin> wow!
01:37:09 <Welkin> what a mess
01:37:10 <MP2E> if you want to use binaries from all of your sandboxes
01:37:20 <bergmark> Welkin: you can cp/symlink the binaries somewhere
01:37:23 <MP2E> I agree, which is why I switched to nix and cabal2nix only a few weeks after trying cabal sandboxes :V
01:37:37 <adimit> Welkin: you *can* install into your global ~/.cabal/bin, or symlink your sandboxes' binaries to ~/bin
01:38:59 <Welkin> if they are symlinked, doesn't that mean they are accessible by any other sandbox as well?
01:39:05 <Welkin> does that defeat the purpose?
01:39:23 <MP2E> well, the binaries are but the problem with sandboxes is generally library dependency hell
01:39:28 <adimit> Welkin: why would a sandbox want a symlinked binary?
01:39:31 <MP2E> so you're generally safe moving binaries
01:39:49 <MP2E> i can't think of an instance where an executable would break cabal actually
01:39:53 <adimit> it's just the executables you'd want to symlink.
01:40:38 <adimit> MP2E: oh yes, there is. Mostly related to happy/alex. If you happen to have different versions of that than are required (granted they are stable, but say you tinkered with one) then your builds elswhere may break if you have an experimental happy/alex running amok.
02:00:41 <jle`> is there such thing as some sort of Ord-to-Bounded promoter?
02:00:52 <jle`> data Bounder a = BMin | BIn a | BMax ?
02:01:07 <jle`> where BMin/BMax are always LT/GT
02:01:13 <jle`> and you get minBound and maxBound
02:02:35 <jle`> useful so that compare can be non-strict depending on its first argument
02:03:26 <jle`> ...or its second
02:04:48 <jle`> actually i guess it can't be totally non-strict because it ahs to check for Eq
02:04:59 <jle`> but it can be lazy on the contents of BIn if compared to BMin/BMax
02:08:00 <int3__> my scrabble AI is finally ready for a GUI frontend. how exciting
02:08:08 <int3__> i'm going to check out threepenny
02:09:40 <Tjr> @let type Lens s a = Functor f => (a -> f a) -> s -> f s
02:09:40 <Tjr> At home on ghci, I get "parse error on input `type'". What's wrong?
02:09:40 <lambdabot>  .L.hs:155:1:
02:09:40 <lambdabot>      Multiple declarations of ‘Lens’
02:09:40 <lambdabot>      Declared at: .L.hs:153:1
02:09:40 <lambdabot>                   .L.hs:155:1
02:10:42 <donri> Tjr: as the error should be telling you, you need RankNTypes
02:11:26 <Tjr> donri: I enabled that, still get "parse error on input `type'". No mention of RankNTypes.
02:11:50 <donri> Tjr: in that case your ghci is old. support for statements was added somewhat recently
02:12:00 <donri> like 7.2 or so
02:12:04 <Tjr> that explains it
02:12:19 * Tjr hasn't quite finished migrating to the new computer
02:12:27 <donri> \o/
02:13:44 * Tjr googles \o/
02:13:58 * Tjr doesn't know what \o/ means.
02:14:26 <int3__> Tjr: I throw my hands up in the air sometimes
02:15:08 <Tjr> so it's an ascii picture of a drowning guy :-)
02:15:19 <donri> Tjr: http://www.irishexaminer.com/media/images/h/HappyWomanHandsInAir_large.jpg
02:15:21 <int3__> http://www.youtube.com/watch?v=VUjdiDeJ0xg
02:18:33 <Tjr> The lens tutorial features a "type hole". I can't get it to work:
02:18:36 <Tjr> http://blog.jakubarnold.cz/2014/07/14/lens-tutorial-introduction-part-1.html
02:18:51 <Tjr> @let { over :: (Functor f => (a -> f a) -> (s -> f s)) ->        (a -> a) -> s -> s ; over ln f s = _ }
02:18:51 <lambdabot>  Parse failed: Parse error in expression: _
02:19:16 <zq> tdammers: wait what? you misunderstood, i didn't mean class MonadTrans
02:19:26 <zq> tdammers: i meant Monad{Writer,Reader,State}
02:19:31 <lfairy> Tjr: https://en.wikipedia.org/wiki/Instinctive_drowning_response
02:19:50 <donri> Tjr: need 7.8 for TypeHoles
02:20:16 <jco> Noob question> In "Learn You a Haskell for Great Good" it's recommended to use foldl instead of writing your own recursive function. But when for instance using foldl for finding an element in a dictionary, [ findKey' key = foldl (\acc (k, v) -> if k == key then Just v else acc) Nothing ], this seems to me to be not very optimal (i.e. continue "looping" over the elements after we've already found the key. Am I missing something here?
02:20:23 <Tjr> how do I find out what version lambdabot is running?
02:20:48 <quchen> donri: Type*d* Holes. Type holes are coming next release. (The formerly wrong "TypedHoles" was renamed a bit before 7.8, because they're actually value holes.)
02:20:49 <lfairy> jco: you should use foldr for that
02:21:14 <jco> lfairy: What difference will this make in this case?
02:21:15 <tdammers> zq: probably so that the various methods work across arbitrary stacks
02:21:36 <tdammers> ask works on any stack that contains a MonadReader anywhere
02:21:38 <lfairy> jco: foldr is lazy -- if you ignore the accumulator the loop exits early
02:21:55 <donri> quchen: oic it's a warning now and on by default
02:22:03 <jco> lfairy> Oh cool, thanks
02:22:10 <Welkin> jco, use lookup for dictionary searches anyway
02:22:11 <tdammers> without extra lifting, unless you have more than one MonadReader in your stack and want to ask another one but the default one
02:22:35 <donri> quchen: and the error deferral dropped in favor of -fdefer, OK
02:22:35 <jco> Welkin> OK, thanks. Just starting out with this Haskell stuff.
02:23:58 <Tjr> lfairy: [off-topic] scary.
02:24:48 <Tjr> jco: if you want it to terminate after finding the right element, then you'd want to use an appropriate data structure, such as map from Data.Map
02:26:11 <jco> Tjr> Yes, just want to get an understanding of the basics here. Didn't know the difference between foldl and foldr when it came to laziness.
02:26:52 <Tjr> The difference is more or less whether you're prone to stack overflow
02:26:55 <Welkin> Tjr, I nearly drowned in the ocean
02:27:02 <Welkin> it was pretty scary
02:27:04 <Welkin> and salty
02:27:04 <donri> why doesn't a hole like (2 + _) say anything about Num? :/
02:27:31 <Welkin> a wave swallowed me
02:28:33 <int3__> it would be nice to have a GUI for exploring data structures lazily. e.g. like a directory tree browser -- click on a directory (thunk) to evaluate it. calling `show` in ghci evaluates everything at once, which isn't so useful for large / infinite data structures
02:28:56 <int3__> just an idea, possibly for my next project :)
02:29:15 <Tjr> isn't there Debug.Trace ?
02:29:22 <adimit> int3__: easier said than done. Have you had a look at the GHCi debugger?
02:29:41 * hackagebot graph-core 0.1.0.0 - Fast, memory efficient and persistent graph implementation  http://hackage.haskell.org/package/graph-core-0.1.0.0 (AlexanderThiemann)
02:29:48 <int3__> adimit: I'm not trying to integrate it with the GHCi debugger
02:30:13 <ClaudiusMaximus> @hackage ghc-vis -- int3__ (not tried it myself)
02:30:14 <lambdabot> http://hackage.haskell.org/package/ghc-vis -- int3__ (not tried it myself)
02:30:55 <donri> int3__: well there's :force and :print etc
02:31:18 <int3__> ClaudiusMaximus: ahh, that looks almost exactly like what I was imagining
02:31:49 <int3__> donri: was not aware of :print, that does look useful for some cases, thanks!
02:32:04 <donri> they work like lazy Show except they show the actual representation independent of Show
02:32:31 <donri> int3__: also :sprint
02:32:52 <int3__> mm got it
02:33:03 <donri> int3__: one annoyance is they only work on bindings not expressions
02:33:45 <int3__> ah I see
02:34:02 <donri> which in a way makes sense since you're mutating the state of the thunks
02:36:10 <jco> Hmm, I still don't understand why foldr will stop early and foldl not (when looking for a value in a list for example). What does it have to do with laziness?
02:36:58 <jco> Trying to read docs, but they only say that foldr will work for infinite lists while foldl will not. OK, that's not the ONLY thing that they say but...
02:37:10 <jle`> > foldr (||) False (repeat True)
02:37:12 <lambdabot>  True
02:37:24 <jle`> > foldl (||) False (repeat True)
02:37:29 <lambdabot>  mueval-core: Time limit exceeded
02:37:43 <jle`> jco: do you know how evaluation in haskell works?  it's sort of like what i call pencil-and-paper evaluation
02:37:47 <jle`> @src foldr
02:37:47 <lambdabot> foldr f z []     = z
02:37:47 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:37:50 <jle`> @src (||)
02:37:50 <lambdabot> True  || _ =  True
02:37:50 <lambdabot> False || x =  x
02:37:53 <jle`> @src repeat
02:37:53 <lambdabot> repeat x = xs where xs = x : xs
02:38:06 <jle`> and one more...
02:38:08 <jle`> @src foldl
02:38:08 <lambdabot> foldl f z []     = z
02:38:08 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:38:14 <jle`> that's all you'll need to answer your question :)
02:38:34 <jle`> get down pencil and paper and manually expand out foldr (||) False (repeat True)
02:38:47 <jle`> (repeat True is, btw, [True,True,True,True..] forever)
02:38:52 <jle`> i'll start you off :)
02:39:07 <donri> 20 years later, jco is still manually expanding (repeat True)
02:39:14 <jle`> foldr (||) False (repeat True) = foldr (||) False (True : repeat True)
02:39:16 <jle`> donri: lol
02:39:44 <jle`> foldr (||) False (True : repeat True) = True || foldr (||) False (repeat True)
02:39:49 <jle`> = True
02:39:51 <jle`> ta dah!
02:39:57 <jle`> ...i accidentally did the whole thing for you, sorry :|
02:39:57 <Welkin> > foldr f acc [1..5] :: Expr
02:39:58 <lambdabot>  Not in scope: ‘acc’
02:39:58 <lambdabot>  Perhaps you meant one of these:
02:39:58 <lambdabot>    ‘act’ (imported from Control.Lens),
02:39:58 <lambdabot>    ‘bcc’ (imported from Data.Graph), ‘scc’ (imported from Data.Graph)
02:40:13 <Welkin> > foldr f a [1..5] :: Expr
02:40:14 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 a))))
02:40:22 <Welkin> > foldl f a [1..5] :: Expr
02:40:23 <lambdabot>  f (f (f (f (f a 1) 2) 3) 4) 5
02:40:27 <frerich> jco: Note how in 'f x (foldr f z xs)', 'foldr' won't be invoked if 'f' doesn't bother evaluating its second argument.
02:40:45 <Welkin> jco, look at the source for foldr ad foldl
02:41:00 <lfairy> frerich is right
02:41:01 <Welkin> they are implemented differently
02:41:19 <kqr> i always forget... what's the TH expression to generate lenses for a datatype?
02:41:46 <jco> :), OK thanks jle
02:42:01 <kqr> (and the follow-up question: what should i do to remember what it is?)
02:42:14 <jle`> kqr: isn't it in the lens haddocks? ;)
02:42:17 <donri> > foldl (flip cons) 0 [1..]
02:42:19 <lambdabot>  No instance for (GHC.Show.Show a0)
02:42:19 <lambdabot>    arising from a use of ‘M8584597543715649809066.show_M8584597543715649809066’
02:42:19 <lambdabot>  The type variable ‘a0’ is ambiguous
02:42:19 <lambdabot>  Note: there are several potential instances:
02:42:19 <lambdabot>    instance [safe] GHC.Show.Show
02:42:48 <jle`> jco: once you give a shot at evaluationg foldr (||) False (repeat True) by hand...try evaluating foldl (||) False (repeat True), and you'll see why it won't ever terminate
02:43:08 <kqr> jle`, if it is, i'll feel dumb
02:43:16 <edwardk> kqr: makeLenses ''Foo
02:43:19 <jco> OK, I will
02:43:37 <kqr> edwardk, thanks, (and yeah, it was in the haddocks lol)
02:43:40 <kqr> jle`, you're right
02:43:56 <jle`> :D edwardk saved me the trouble of pasting the url i had just copied
02:44:00 <kqr> i guess part of my problem is that i have no idea how TH works ;_;
02:44:01 <frerich> edwardk: Either it's a cosmic coincidence, or you configured your IRC client to ring a bell when the word 'lens' is mentioned. I'd love to believe it's the former.
02:44:02 <jle`> or well, you did
02:44:48 <edwardk> frerich: close. it just highlights the channel in red ;)
02:44:54 <donri> kqr: if it helps, it's really $(makeLenses ''Foo) but the $() are optional for declarations due to being unambiguous
02:45:07 <kqr> donri, that's part of what's confused me, actually
02:45:21 <kqr> is there a sort of gentle introduction to TH anywhere?
02:45:41 <donri> kqr: might be more intuitive with the $() which makes it read more like a template or placeholder-for-code
02:45:56 <Welkin> is edwardk going on a no-sleep regimen again?
02:45:58 <christiaanb> edwardk: when/if you have time, could you take a look at my question in: http://www.haskell.org/pipermail/haskell-cafe/2014-July/115103.html  it concerns the use of your 'bound' library
02:46:13 <Welkin> or is he just awake early?
02:46:24 <donri> kqr: https://github.com/leonidas/codeblog/blob/master/2011/2011-12-27-template-haskell.md maybe
02:46:33 <kqr> donri, without the $() is frighteningly neat-looking though
02:46:45 <kqr> donri, feels almost like a lisp macro at that point
02:46:56 <ciaranm> and here i was using "kdrawde kdrawde kdrawde" to summon him...
02:46:59 <donri> kqr: it is a lot like a lisp macro
02:47:15 <kqr> donri, thanks, i'll be looking at that in a few minutes when i'm done with what i'm doing
02:47:36 <Tjr> Welkin: productive people generally don't go sleep deprived or set lots of IRC bells that interrupt their concentration
02:48:43 <donri> edwardk isn't sleep deprived; he's just the next stage of human evolution requiring no sleep
02:49:14 * Tjr thinks that donri is prone to celebrity worship.
02:50:00 <donri> i don't worship celebrities; only evolved supermen.
02:51:09 <donri>  Lo, I teach you the Superman: he is that lightning, he is that frenzy!
02:52:40 <ciaranm> edwardk is no spj!
02:53:07 <sakdk1kd> Hi
02:53:19 <sakdk1kd> !monologue
02:53:19 <oBurnBoto> Hello, oBurnBoto here.
02:53:21 <oBurnBoto> Aren't trains really cool?
02:53:23 <Tjr> no wonder the guy doesn't come when people mention his nick
02:53:23 <oBurnBoto> They just go so fast...
02:59:45 * hackagebot digestive-functors-aeson 1.1.10 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.10 (OliverCharles)
03:05:06 <christiaanb> jco: It will stop at the first encounter of the key
03:05:35 <jco> christiaanb> Why?
03:05:36 <zwer> donri so $() is only required when there's also a function that shares the name with a macro?
03:08:08 <christiaanb> jco: foldr traverses a list from 'left' to 'right'. So in "\(k, v) acc -> if k == key then Just v else acc", the 'acc' represents the rest of your search. Meaning that if 'k == key', you have found the left-most occurence of 'key', and you also no longer need to evaluate 'acc'.
03:09:28 <jco> christiaanb> Doesn't foldr work right to left??
03:10:11 <christiaanb> jco: you should read 'foldr' as 'fold-to-the-right', not 'fold-from-the-right'
03:10:58 <jco> christiaanb> OK, I seem to not have understood the basics here. Back to the drawing board.
03:11:35 <christiaanb> jco: the pictures of foldr and foldl on http://en.wikipedia.org/wiki/Fold_(higher-order_function) did the trick for me
03:13:30 <jco> christiaanb> OK, I'll check that out. But in my case, you say that the acc represents the "rest of the search", but isn't acc just either the value found (Just v) or Nothing??
03:13:58 <christiaanb> jco, indeed that's what the rest of the search evaluates to
03:16:32 <christiaanb> In your code "\(k, v) acc -> if k == key then Just v else acc" you basically say: is the current key the key I'm looking for (k == key), or is in in the rest of the list (acc)?
03:16:37 <jco> christiaanb> But the docs say that foldr starts by taking the last element of the list, then the second last, etc. This seems to me to indicate that it indeed works right to left...???
03:17:54 <jco> No acc is not the rest of the list, it's just the value if it has been found, else it is Nothing.
03:18:49 <Tjr> How do people come up with things like lenses?
03:18:58 <Tjr> Who invented that?
03:18:59 <christiaanb> jco: indeed, it's the value that's possible been found in the rest of the list
03:19:06 <christiaanb> possibly
03:19:08 <edwardk> try all the things
03:19:54 <jco> OK, So I tried this in ghci, and when adding two values with the same key, it indeed seems foldr does NOT stop at the first match.
03:20:07 <kqr> Tjr, it's not something you just suddenly have
03:20:08 <jco> It goes on looking for the leftmost (in the list) match.
03:20:18 <kqr> Tjr, it's based on the hard work of many people trying to figure things out and come up with better solutions
03:20:33 * Tjr is convinced it's magic.
03:20:40 <kqr> jsthe leftmost element is the first match?
03:20:55 <christiaanb> jco: leftmost is the first match, no?
03:21:12 <jco> No, since foldr works from the right!
03:21:22 <kqr> to the right*
03:21:33 <Tjr> Given that many lenses seem to be cookie-cutter accessor functions, is there a way to derive them automatically?
03:21:37 <kqr> foldr starts from the left and goes to the right
03:21:42 <jco> Quote from zvon.org: it takes the second argument and the last item of the list and applies the function, then it takes the penultimate item from the end and the result, and so on.
03:21:53 <kqr> Tjr, $(makeLenses ''Constructor)
03:21:59 <kqr> Tjr, will generate lenses for Constructor
03:22:20 <kqr> jco, can you link that page?
03:22:29 <jco> http://zvon.org/other/haskell/Outputprelude/foldr_f.html
03:22:31 <christiaanb> kqr: the docs are confusing, take a look at http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-List.html#g:3, there it says that foldr: "reduces the list using the binary operator, from right to left"
03:22:44 <Tjr> that's two separate ' marks, right?
03:22:59 <christiaanb> Tjr: yes
03:23:03 <Tjr> how come it parses?
03:23:03 <kqr> Tjr, correct
03:23:13 <kqr> Tjr, {-# LANGUAGE TemplateHaskell #-}
03:23:19 <kqr> Tjr, in the top of the code
03:23:20 <Tjr> isn't ''Constructor simply a function name that happens to begin with '?
03:23:31 <kqr> Tjr, it's template haskell
03:24:10 <Tjr> whenever I write templates (in other languages), they turn out very brittle. What about makelenses?
03:24:52 <kqr> christiaanb, good point. i guess does apply the innermost operator on the right but throws away the intermediary results if others are found, and laziness makes it reduce from the left...
03:25:41 <kqr> jco, sure, it starts on the right, but the leftmost operators "have a higher precedence" or so to say
03:25:53 <kqr> jco, it'll prefer the results from the leftmost operators before the rightmost ones
03:26:04 <zwer> > foldr f z [a,b,c,d] :: Expr
03:26:05 <lambdabot>  f a (f b (f c (f d z)))
03:26:08 <jco> OK, but it seems the code does NOT stop at the first match then.
03:26:12 <kqr> jco, in most languages, this would mean it "does not stop at the first match" as you say
03:26:24 <zwer> > let f = (||) in f True (f undefined undefined)
03:26:25 <lambdabot>  True
03:26:26 <kqr> jco, but since haskell is lazy, it sort of does. it stops at the outermost operator (which happens to be the leftmost)
03:27:46 <jco> But there's nothing there that tells it that it's OK to stop?? I understand the reasoning when the function is (||), since that does not have to evaluate its second argument if the first is True, but in the case of my function it HAS to evaluate everything.
03:28:46 <kqr> > foldr (||) False [False, False, False, True, False]
03:28:47 <lambdabot>  can't find file: L.hs
03:28:51 <Wuyiming> why has to？
03:29:00 <kqr> am i doing something wrong?
03:29:07 <quchen> No, Lambdabot is.
03:29:09 <jco> But the terms here are confusing. When I say that it doesn't stop on the "first" match, I mean it does not work in an optimal way and it continues to look for more leftmost matches when it already found a match on the right
03:29:14 <kqr> ah
03:29:14 <quchen> > foldr (||) False [False, False, False, True, False]
03:29:16 <lambdabot>  True
03:29:22 <kqr> > foldr (||) False [False, False, False, True, False, undefined]
03:29:24 <lambdabot>  True
03:29:26 <kqr> jco, ^ does that make sense?
03:29:44 <kqr> jco, if foldr (||) wasn't short-circuiting, it would explode on the undefined
03:29:59 <jco> I know this about ||, but I'm not using || :)
03:30:01 <kqr> jco, and foldr (||) is short-cutting because (||) is short cutting – just like your key finding function
03:30:39 <edwardk> Tjr: TemplateHaskell is basically a the ability for folks to write haskell that generates haskell at compile time. it is sort of an escape hatch when you need to do something beyond what the normal vocabulary of haskell would let you do.
03:30:45 <kqr> jco, "\(k, v) acc -> if k == key then Just v else acc" behaves a lot like (||) except it returns a key instead of a boolean value
03:30:58 <edwardk> er a way to provide the ability for
03:31:03 <kqr> jco, the second argument (acc in your case) never gets evaluated if it finds the key
03:31:14 <kqr> jco, just like the second argument of (||) never gets evaluated if it finds a True
03:31:17 <Tjr> edwardk: I'm familiar with macros in lisp, so I guess it's the haskell version of htat
03:31:32 <edwardk> Tjr: yeah the main difference is they are slightly typed, etc.
03:31:44 <kqr> slightly typed – the best kind of typing
03:31:51 <edwardk> personally i'd kill for scheme-style syntax-rules
03:32:19 <kqr> edwardk, including only prefix notation?
03:32:26 <jco> I guess I have to learn something about how this lazyness business works. I'm just getting more confused. Thanks anyway!
03:32:41 <edwardk> kqr: i said, kill, not commit suicide ;)
03:33:17 <edwardk> i spent a long time trying to justify layout + syntax rules + infix notation.
03:33:19 <edwardk> =)
03:33:36 <kqr> ah
03:33:45 <kqr> i never realised they were compatible
03:34:49 <kqr> pah jco left
03:34:54 <kqr> i had worked out an example for them
03:35:13 <christiaanb> edwardk: sorry if I sound terribly impatient. but did you get to see my question about http://www.haskell.org/pipermail/haskell-cafe/2014-July/115103.html ?
03:35:27 <edwardk> christiaanb: yeah i answered above, but then you netsplit
03:35:34 <christiaanb> ah, ok...
03:35:41 <christiaanb> I didn't see the answer
03:36:14 <christiaanb> could you pm it?
03:36:22 <edwardk> christiaanb: one sec
03:36:26 <christiaanb> ty
03:36:44 <edwardk> http://lpaste.net/107526
03:37:34 <edwardk> if you want more specifics about the dependently typed case you might want to wait a couple hours for dolio to get up and look at the computer ;)
03:38:27 <jco> Hey guys, I'm back with my annoying questions about foldr :)
03:38:46 <christiaanb> edwardk: ok, thank you for the pointers. I'll take a look
03:39:01 <jco> I just realized I could try scanr, that assembles a list of all the accs being used during the foldr steps.
03:39:18 <edwardk> christiaanb: you can also look at github.com/ermine-language/ermine there is much of a typechecker in there
03:39:40 <edwardk> not dependently typed, but it does a lot of fancy stuff
03:41:47 <christiaanb> edwardk: well, my type-inference is simple, because my binders have their type, just like dolio's pure type system implementation
03:42:08 <jco> Do you guys now of a good online place for sharing Haskell code? So I can ask you to take a look?
03:42:23 <kqr> jco, lpaste.net
03:42:52 <christiaanb> it's just that as I traverse down a Scope, the Terms returned by my context, need to be succ'd
03:42:55 <sohum> okay, so, I want to sort an array of about a hundred elements. The twist is that the comparison function is a -> a -> IO Ordering - it has to actively ask me which of the two is bigger.
03:43:35 <sohum> I'd appreciate suggestions for a sort algorithm that fits this use case, minimising the number of comparisons I have to go out and make :p
03:43:39 <christiaanb> which is what I wanted to do cheaply, by lifting the term
03:44:23 <jco> OK, my point about foldr not stopping at the earliest match: http://lpaste.net/107527
03:44:38 <jco> Note that there are two "wendy":s in the list.
03:44:50 <kqr> sohum, if you know nothing about your data, i'm pretty sure O(n log n) comparisons is the best you'll get (with a quicksort or merge sort)
03:45:10 <jco> Also note that the scanr result should be read from the right.
03:45:22 <sohum> kqr: well, in particular, a low constant factor would seem to be much more important here than good asymptotic behaviour
03:46:30 <kqr> sohum, still pretty sure n log n is the number you're looking for. the "constant factors" in quicksort and merge sort aren't about the comparisons but rather general overhead... i think
03:46:35 <Saizan> edwardk: how do you deal with the F's when comparing terms though? you lazily push them down as you go?
03:46:46 <edwardk> Saizan: Scope does that for you
03:46:54 <edwardk> Saizan: the (==) for it compares for alpha-equality
03:47:17 <edwardk> it compares as if the f's were all at the leaves
03:47:43 <Saizan> edwardk: but when you do unification you don't want to just compare like that, you want to compare the root and recurse unifying
03:47:43 <augur> so im simulating a pointer-based data structure because i need mutable sharing
03:47:53 <tdammers> constant factors include both the algorithm implementation and the comparison itself
03:47:57 <asfp``> sohum: if you could have Num a => a -> a -> (Int, a)  or similar you could do better.
03:48:03 <augur> and im finding that because the simulation is untyped, all of my bugs are from this portion of the code
03:48:16 <tdammers> but the constant factor for the comparison is the same regardless of sort algorithm
03:48:36 <edwardk> Saizan: we suffer a bit there, pushing stuff out to the leaves by hand or having something manually track each side of how its doing the unification, etc.
03:48:48 <asfp``> sohum: if you are the one doing the comparisons, surely you can do better than outputing Bool
03:49:22 <augur> if anyone knows of a good way to do typed, labeled-edge graphs, let me know!
03:49:48 <adimit> augur: fgl doesn't cut it?
03:49:54 <sohum> asfp``: I'm not sure what that type signature means - why do my elements need to be Nums? do you mean outputting a rank of how much _more_ roughly one element is above the other?
03:49:56 <Saizan> edwardk: ok
03:50:16 <augur> adarq: does fgl let me do typed labeled graphs?
03:50:19 <augur> grr
03:50:21 <augur> sorry adarq
03:50:23 <augur> adimit: ^
03:51:03 <adimit> augur: yes.
03:51:12 <augur> adimit: really? that seems unlikely
03:51:16 <augur> i mean, labelled, sure, but typed?
03:51:43 <adimit> augur: sorry, I didn't read your "typed" and read it as just "labelled".
03:51:57 <adimit> Yes it's labelled, but I don't know what you mean by "typed"?
03:52:25 <augur> :)
03:52:25 <sohum> kqr, tdammers: fair enough; I guess sorting algorithms are optimised for real world speed as well as asymptotic behaviour!
03:52:35 <asfp``> sohum: yes, you should be able to say something about how much larger a is than b. or if you can implement:  class Rank a where rank :: a -> Int and use rank sort.
03:52:49 <augur> adimit: typed as in the nodes have types, and labels are type-restricted
03:53:11 <adimit> augur: node and edge labels in fgl are polymorphic.
03:53:30 <adimit> I think node is just Node a = (a,Int) or so.
03:53:44 <augur> adimit: ie you might have a node n : A, and n' : B, and an edge e : A -> B, so you could do n --e--> n', but not n --e--> n'' if n'' : C
03:54:07 <augur> adimit: whats more, i dont just want it to be enforced at run type, i want compile-time checking
03:54:15 <augur> the only way i can think to do this is with dependent types
03:54:18 <adimit> augur: that sounds like a job for DataKinds.
03:54:21 <augur> adimit: yeah
03:54:30 <adimit> and I don't know of any attempt to do that.
03:54:47 <sohum> asfp``: well, it's to recover a ranking that I'm doing this in the first place :p any pointers to a sort algorithm that takes an a -> a -> Int?
03:54:51 <adimit> but it sounds interesting (in theory. I don't know how pleasant it would be to work with in practice with the current implementations.)
03:55:03 <augur> adimit: ive never used datakinds
03:55:04 <augur> dont want to
03:55:11 <augur> ill stick to agda for that sort of beasty
03:55:23 <augur> so, im stuck using untyped stuff :(
03:55:24 <b_jonas> heh
03:55:25 <augur> oh well!
03:55:31 <adimit> DataKinds has its uses. I'm doing something quite similar to your typed graph right now with it.
03:55:48 <adimit> But I'm constructing the graph in a Monad that does the checking.
03:55:56 <adimit> And unfortunately, it's currently run-time checking.
03:56:39 <augur> adimit: my graph rep, fwiw, is currently   data Graph = Graph { sorts :: Map Node Sort, edges :: Map Node (Map Edge Node) }
03:56:39 <adimit> (which I had to do, because the entire type-signatures etc. are read in during run-time for me, and they have to be.)
03:56:52 <augur> i could probably replace the double map with a pair domain, but whatever
03:57:10 <adimit> augur: then you're better off using fgl. Same type safety, but a nicer interface.
03:57:20 <augur> adimit: fgl wont work, unfortunately
03:57:24 <adimit> and it's also using maps internally.
03:57:35 <asfp``> sohum: there's a sort using the gradient. somewhat like insertion sort but you put the element where you think it belongs.  can't remember the details though.
03:57:37 <augur> the representation is necessary because im doing graph unification
03:57:43 <augur> and i dont think i can use FGL to make that work
03:58:32 <adimit> fgl can't do graph unification? … I'm surprised.
03:58:52 <augur> well, i dont know if it can or not. i havent looked. i'd be very surprised if it had the facilities to do it already tho
03:59:02 <augur> its representations probably support it but i'd rather not muck about with that
04:01:50 <adimit> yes, I really do think its representations support it. But your choice on the implementation details :-)
04:02:04 <adimit> I didn't find fgl too accommodating to work with, but it got the job done.
04:02:23 <adimit> The easy export to graphviz was the killer deal here. I hate not being able to quickly visualize stuff.
04:02:54 <augur> adimit: by graph unification, i mean:   http://imgur.com/2cPcS1A
04:04:06 <augur> which in this case is basically just normal unification that cares about sharing
04:04:35 <adimit> augur: node labels would be a problem, since yours seem to be edge driven.
04:04:40 <augur> yeah
04:04:51 <augur> its basically like.. record unification
04:04:59 <augur> but because there's sharing, its non-trivial
04:05:06 <adimit> let me guess, typed logic feature structures?
04:05:14 <augur> adimit: :D
04:05:24 <augur> adimit: <3
04:05:29 <kqr> shit
04:05:32 <kqr> did jco really leave AGAIN
04:05:38 <augur> adimit: you're good
04:05:40 <kqr> i gotta set up a bell on them joining
04:05:41 <adimit> you'll be interested to know that I'm doing an HPSG interpreter, and the AVMs are in fgl.
04:05:54 <augur> adimit: im doing an HPSG interpreter too! :o
04:06:00 <adimit> oh goodness me.
04:06:02 <augur> adimit: how are you doing unification with sharing?
04:06:12 <augur> adimit: also why are you doing this?
04:06:12 <adimit> augur: not yet is the answer.
04:06:25 <augur> adimit: not yet is the trick :)
04:06:25 <adimit> augur: 'cause I need to get done with my thesis.
04:06:34 <augur> adimit: PhD thesis?
04:06:38 <adimit> no, M.A.
04:06:40 <augur> ah
04:06:50 <augur> adimit: come cofound a startup with me!
04:06:56 <adimit> but, yes. Unification is on the agenda.
04:07:14 <adimit> augur: :-D
04:07:18 <MP2E> cofound, as in the categorical opposite of founding? ;)
04:07:30 <augur> MP2E: yes
04:08:05 <augur> adimit: all of my parser errors are because my damn feature structures are untyped
04:08:07 <augur> its awful
04:08:23 <augur> i keep putting features on the wrong things
04:08:31 <augur> also the lack of a proper subtyping system is a pain in the but
04:08:33 <augur> t
04:09:10 <adimit> augur: yes, that is why I decided to do it run-time. I really really tried fitting typed feature logic into Haskell's type system, and I know now that it *can* be done, but it's a pain in the butt.
04:09:14 <adimit> It's really not worth it.
04:09:24 <adimit> I guess you've looked at oleg's HList stuff and OOHaskell?
04:09:38 <augur> adimit: yeah
04:09:46 <augur> adimit: actually i think with dependent types we CAN make it work
04:10:11 <adimit> augur: yes, we can. probably. But the question here is whether it's worth it.
04:10:16 <adimit> It won't look nice.
04:10:39 <adimit> And the error messages will be *so* intransparent to a user that I decided it's not worth it.
04:10:52 <augur> data HMap k el where   empty :: HMap k el   ;   insert :: (k0 :: k) -> (el0 :: el k) -> HMap k el -> HMap k el -> HMap k el
04:11:11 <adimit> Instead I write my own stuff, and give out pretty error messages. Users happy.
04:11:14 <augur> thats the core of enforcing the types. well, one option, anyway
04:11:38 <augur> adimit: i defined a whole collection of combinators that make constructing feature structures nice-ish
04:11:43 <augur> so i can write things like this:
04:11:55 <augur> sign ( SYN .= syn ...
04:12:00 <augur>       & SEM .= sem ... )
04:12:13 <sfdvev> Anyone familiar with Wreq? How do you make cookies persistent between requests or handle sessions?
04:12:44 <adimit> augur: so your feature structures look pretty much like Oleg's records…
04:12:55 <augur> adimit: thats what i was inspired by, yeah
04:13:09 <augur> i dont know if the implementation is similar, but
04:13:27 <adimit> I had the same idea, but when I came to defining the semantics of HPSG principles, I baile.
04:13:29 <adimit> *bailed.
04:14:06 <augur> adimit: you mean like   SYN | CAT | HEAD = SYN | DTRS | HEAD-DTR | SYN | CAT | HEAD
04:14:06 <augur> ?
04:14:08 <adimit> I.e. as soon as you have to compute sets of entities over given interpretations *or* check the valididty of a model, I just found it too complicated.
04:14:51 <augur> oh maybe. i dont know. i mean, im just using this to parse stuff into FSes
04:14:55 <adimit> augur: no, more like: let's construct an AVM formula from our signature, and let's check it against a given interpretation (I'm using RSRL as my base formalism.)
04:15:19 <augur> a given interpretation?
04:16:00 <adimit> augur: an interpretation is like a graph of entities (all entities are basically instances of a sign.) Think of it as the term-level, where the signature is the type-level.
04:16:12 <adimit> and the edges in the graphs are features.
04:16:18 <augur> right, yes
04:16:52 <augur> oh you mean you have a particular AVM + a formula and you want to ask if the AVM satisfies it?
04:16:56 <adimit> so, given a set of principles (themselves AVM formulae with quantification of indices, etc.) , which interpretations are possible, and can we even generate valid ones?
04:16:58 <adimit> yes.
04:17:01 <augur> like, does this AVM satisfy the head feature principle
04:17:05 <adimit> exactly.!
04:17:10 <augur> aha ok
04:17:15 <adimit> so that's my main problem.
04:17:37 <augur> in my parser, i check the principles when ID schemas are applied
04:17:41 <adimit> and representing avms on the type level got too unwieldy. I was doing some stuff with arrows and graph constructions, etc.
04:17:54 <augur> the way i enforce them is, i created a little sublanguage for unification problems
04:18:17 <adimit> augur: embedded prolog?
04:18:24 <augur> sort of, yeah
04:18:26 <Tjr> What does the acronym AST mean?
04:18:33 <adimit> Tjr: abstract syntax tree.
04:18:37 <Tjr> oh
04:18:46 <augur> adimit: so a simple problem is just an equation
04:19:05 <Tjr> how do other people find out what AST means?
04:19:14 <adimit> Tjr: they read books.
04:19:26 <augur> which just requires generation of new equations (for features) and then substitution of the entities
04:19:37 <adimit> augur: yes, that's also on my agenda. I'll be doing it this week.
04:19:47 <Tjr> adimit: I've done LYAH and half of RWH. What books do you mean?
04:20:03 <augur> adimit: i also have functional equations which are assertions, etc. n | F | F' = n'
04:20:07 <adimit> Tjr: AST is more of a compiler-thing than a Haskell-thing. You'd have to read books about compilers.
04:20:54 <adimit> augur: not usre I quite understand; other question though: how did you do the unification algorithm?
04:20:57 <augur> adimit: and what that does is follow the path (when possible) and set the value
04:21:09 <adimit> ah, ok.
04:21:10 <augur> adimit: standard unification algo
04:21:20 <adimit> ok, nothing tricky…
04:21:23 <augur> well, "standard" for the equation part
04:22:05 <augur> if you have the graph   foo(X,Y), bar(X,Z)   and the equation Y = Z then you substitute Y for Z (or vice versa, take your pick)
04:22:13 <augur> and get   foo(X,Y), bar(X,Y)
04:22:14 <adimit> I was going to go at it differently: basically have a CLP approach to AVM formulas, and enforce them as constraints on feature structures.
04:22:21 <augur> CLP?
04:22:27 <adimit> constraint logic programming.
04:22:30 <augur> ah
04:22:34 <augur> well thats what this is, right
04:22:52 <augur> i mean CLP is just a generalization of prolog
04:23:03 <adimit> I guess, yes.
04:23:16 <augur> i also have set union and subtraction as instructions
04:23:21 <augur> oh and list append
04:23:29 <augur> and node creation
04:23:43 <augur> as well as a feature-path lookup
04:23:52 <adimit> nice :-)
04:24:05 <augur> so my head feature principle looks like this:
04:24:07 <augur> headFeaturePrinciple :: Node -> Directive
04:24:07 <augur> headFeaturePrinciple n = Lookup "X" n [SYN,CAT,HEAD]
04:24:07 <augur>                        $ Lookup "Y" n [SYN,DTRS,HEAD_DTR,SYN,CAT,HEAD]
04:24:09 <augur>                        $ Eqn (DirVar "X") (DirVar "Y")
04:24:53 <augur> i figured that was better than having actual equations of paths. separate equations from path following
04:25:42 <augur> i could probably even separate it further into Let and Lookup.. hmm
04:25:51 <adimit> Yes, my principles look a bit different, but the idea is the same. Except that Lookup is more of a quantification/binding thing.
04:26:44 <augur> yeah, because im going this for a parser, i can apply the rules immediately and only to the node generated by the id schema
04:27:16 <adimit> i.e. forall x. [ syn [ cat [ head x ] ] dtrs [ head_dtr [ syn [ cat [ head x ] ] ] …
04:27:18 <augur> probably i want to do something different in the long run but
04:27:44 <adimit> dunno if I got the structure right, and in Haskell it looks entirely different because I'm using Data types to represent boxes.
04:27:50 <adimit> (boxes being avms)
04:28:16 <adimit> but I'm currently working on the exact contiditions for applying the quantification.
04:28:33 <augur> adimit: seriously tho. im doing a startup. we should cofound!
04:28:45 <adimit> augur: in the States
04:28:47 <adimit> ?
04:28:49 <augur> yes
04:28:59 <adimit> difficult. I don't really wanna live in the States :-D
04:29:11 <augur> well who says you have to? its 2014, we have the internet
04:29:18 <adimit> that's correct.
04:29:22 <augur> tho who doesnt wanna live in the bay area?
04:29:39 <paintcan> some kind of sick freak
04:29:48 * adimit is a sick freak then.
04:30:08 <adimit> hey, but it's really cool to see another person working on HPSG with Haskell :-D
04:34:33 <carlosgaldino> what's the order of application in the following expression? 10 `div` length [1, 2]
04:35:49 <notdan> > 10 `div` length [1,2]
04:35:50 <lambdabot>  5
04:36:09 <notdan> well, it typechecks, so `div` is being applied the last
04:36:19 <notdan> i.e., length binds more tightly
04:36:55 <dottedmag> Is there any functionality in lambdabot to put parentheses around or dump AST-like structure for expressions?
04:39:17 <carlosgaldino> notdan: I see that `div` has a infixl 7. what does actually mean? you said that length binds more tightly, what would be length value for the same thing? I mean, a function that's not used in infix notation always bind's tightly than any infix function? the values range from 0 to 9, so a normal function "would have" (I think it doesn't) a value of 11?
04:39:20 <haasn> carlosgaldino: Application of functions always binds the most tightly
04:39:44 <haasn> f x <> z y  parses as (f x) <> (z y) no matter what names or operator you include
04:39:52 <haasn> s/include/replace them by/
04:40:33 <carlosgaldino> haasn: and what about all these infixl and infixr values?
04:40:38 <haasn> If you want, you could claim that the “juxtaposition” operator has infixl 10
04:41:26 <haasn> eg. let's replace “f x” by f!x just for sake of demonstration; then f!x!w<>z!y parses as ((f x) w) <> (z y)
04:41:44 <Tjr> funny bad idea: allow overloading the juxtaposition operator. (Data.Map. juxtaposition) and so on ;-)
04:42:07 <danilo2> Hello! Would somebody be so nice and tell me what is the meaning of (~) in type class definition (like here: http://lpaste.net/107530) I'm just asking what is the difference between such class and the one defined below it?
04:42:31 <Tjr> danilo2: equality constraint
04:42:45 <Tjr> t shall have the same type as GetResult r f
04:43:43 <Tjr> The compiler first matches "Has" as if the constraint were not there. Then it throws an error if the constraint is violated.
04:43:44 <haasn> It's pretty redundant, too
04:43:47 <haasn> Well, not redundant
04:44:04 <carlosgaldino> haasn: where can I read more about the infixl and infixr thing?
04:44:07 <Tjr> Hence it's a trick to get ghc to apply your class to more pieces of code.
04:44:10 <SaBer> dottedmag: @pointful does something along those lines
04:44:20 <haasn> You could probably change it to getField :: proxy f -> r -> GetResult r f -- and remove the third parameter
04:44:22 <carlosgaldino> I still don't know why they are used
04:45:06 <haasn> carlosgaldino: You can read all about it in the report; but it's rather straightforward: operators in general have a notion of “precedence”, for example in 1+2*3 we by convention know that this is 1+(2*3), not (1+2)*3
04:45:11 <haasn> Since we know that we apply * before +
04:45:24 <danilo2> Tjr: Hmm I know this mechanism and I was using it but when defining instances, not classes - is there any difference between using it in instance and in the class?
04:45:56 <danilo2> haasn: exactly - what would be the idfference then ?
04:45:57 <haasn> It's the same for operators you define in Haskell; the “fixity” of an operator gives its precedence; so for example * is infixl 7 and + is infixl 6 which results in * being applied “before“ +
04:46:09 <Tjr> danilo2: the docs don't say anything eye-glaringly obvious, but it's possible I missed subtle differences
04:47:07 <danilo2> Tjr, haasn: my second example should not have the third type var - I fixed it (http://lpaste.net/107530). So if anybody would tell me what is the difference in behaviour (if any) I would be very thankfull :)
04:47:13 <haasn> danilo2: It depends on what GetResult is; if it's a type family then you could for example say Has r f Double => foo
04:47:52 <carlosgaldino> haasn: ah ok. that's good. what about infixr? it just associates with the values on the right of the infixed operator?
04:48:08 <danilo2> haasn: yes, it is type family. The code is from the OverloadedRecords proposal: https://github.com/adamgundry/records-prototype/blob/master/TrivialRecords.hs
04:48:44 <haasn> danilo2: If it's a regular data type, it's injective so if you could state GetResult r f you could also state r and f; but for the type family case that doesn't hold true in general
04:49:04 <haasn> Anyway, given my example just now; that constraint says that “I don't care what r and f are, but I care that their result ends up as Double”
04:49:15 <haasn> If you did that with the lower definition, you would have to write (Has r f, GetResult r f ~ Double)
04:49:21 <haasn> Which is.. equivalent to the above, of course
04:52:10 <haasn> danilo2: Also, things get more complicated once you add fundeps; for example | t -> r
04:52:33 <haasn> In fact, | t -> r f -- would be equivalent to giving GetResult injectivity
04:52:39 <danilo2> haasn: haasn: Hmm, I'm feeling a bit confused right now. I was using the (~) mechanism in instances a lot. Maybe another question - is there **any** difference between following use cases? http://lpaste.net/107533
04:53:09 <Yuu_chan> Can somebody give a hint how it's possible to translate this piece of Scala code — http://pastebin.com/370FRR5m — into the Haskell type system?
04:53:23 <Yuu_chan> It involves a lot of subtyping.
04:54:11 <danilo2> haasn: Hmm, where can I learn more about "injectivity" - I've never heard the term before and I really want to deeply understand whats going oin here and what are the differences
04:54:13 <haasn> danilo2: If you can write the instance Has r f t; then you can just skip the type class and write a function getField :: proxy f -> r -> GetResult r f
04:54:36 <haasn> Whereas the definition in line 1 allows you to add instances for types as needed
04:54:46 <haasn> The definition in line 12 already assumes you have an implementation that works for every possible type
04:54:46 <danilo2> haasn: Of course - I made a shortcut there - the instance should have some specific types involved (or would be used as overlapping one)
04:54:49 <haasn> Oh
04:55:03 <haasn> In that case, then you can't in general know that some “r f” or “t” has a matching instance with that constraint
04:55:10 <haasn> Instance constraints get added once you match the instance
04:55:26 <haasn> But if you're working with polymorphic variables, you can't assume you match instances where those particular constraints are in fact present
04:55:33 <haasn> But in the case 1, it's a requirement of the class itself
04:55:57 <haasn> danilo2: “injectivity” has a simple definition: f is injective if f(x) = f(y) implies x = y
04:55:58 <danilo2> haasn: I know it - If the constains are not met, than we will fail. I'm sorry, my example was a little to simplified
04:56:08 <haasn> For example, [x] ~ [y] implies x ~ y
04:56:15 <danilo2> haasn: Ah, ok!
04:56:18 <haasn> Normal ADTs are injective
04:56:33 <haasn> Because [x] is a distinct type unique to x
04:57:02 <haasn> But with type families, you don't get injective mappings; eg. you could have a type family Foo x = ()
04:57:05 <haasn> And then Foo Int ~ Foo Double
04:57:08 <haasn> But clearly Int is not ~ Double
04:57:24 <danilo2> haasn: I've fixed the example: http://lpaste.net/107533 Is there any diference now ?
04:57:35 <haasn> This is why you can't retroactively go from knowing “t ~GetResult r f” back to knowing r and f
04:57:54 <danilo2> haasn: Ok, I clearly see it
04:58:15 <haasn> danilo2: Yes, there is still the distinction I mentioned above; try to write a function like “foo :: Has r f t => proxy f -> r -> GetResult r f”
04:58:24 <haasn> This is possible with the first definition but not (try it!) with the second
04:58:33 <haasn> err
04:59:31 <haasn> Actually yeah, I think the type I quoted is the one I meant
04:59:38 * haasn is off to eat
05:01:09 <danilo2> haasn: hmm, ok , brb
05:04:05 <jedai> injective type families are coming though ? I seem to remember something about that
05:04:24 <jedai> Of course data families are naturally injective
05:07:33 <danilo2> haasn: Hmm, it seems you are right - I just faced a porblem with the second definition - could you please look at this code? http://lpaste.net/107537 The Has2 instance on the bottom raises an compilation error, while the above one compiles. I've readf couple of times what you have written and its clear to me - I still do not get why ghc fails when compiling the lower instance :(
05:08:16 <dottedmag> @pointful 10 `div` length [1, 2]
05:08:16 <lambdabot> (div 10 (length [1, 2]))
05:08:30 <dottedmag> SaBer: thank you
05:08:33 <dottedmag> carlosgaldino: ^^
05:09:33 <carlosgaldino> dottedmag: how do I achieve the same thing in ghci?
05:09:40 <carlosgaldino> dottedmag: that's cool
05:10:56 <dottedmag> carlosgaldino: It's a part of lambdabot, so you could try to use Lambdabot.Pointful and pass a string to it, but I don't know whether it works this way.
05:13:08 <hexagoxel> carlosgaldino: install pointful (it's on hackage), and add shortcut in ghci using .ghci config file
05:13:22 <carlosgaldino> just found it: http://hackage.haskell.org/package/pointful
05:13:33 <carlosgaldino> hexagoxel: dottedmag cool, thanks
05:16:12 <danilo2> haasn: bon appetit btw :)
05:20:57 <kqr> in lens there is a `l .~ f' operator that behaves sort of like `l %~ const f'. you can also do `l %%~ const f' if `f' returns `Functor f => f b'... is there something like a `l ..~ f' that works like `l %%~ const f'?
05:24:38 <haasn> danilo2: Just to make sure, you have line 15 in the bottom definition too, right?
05:24:50 <haasn> Oh, wait
05:24:59 <haasn> danilo2: You have "foo" above and "test" below
05:25:09 <haasn> GetResult is only defined for "foo"
05:25:10 <danilo2> haasn: ohh, heh :)
05:25:54 <haasn> jedai: all I know about are “closed” type families, which are not necessarily injective; not sure about injective TFs
05:25:54 <danilo2> haasn: Ahh, that was stupid, thank you - now I feel a little better - anyway - I understand that there is no difference between instance for Has and fdor has2?
05:26:12 <haasn> the instance is the same (apart from the different string), yes
05:26:23 <supki> :t (%%~)
05:26:24 <lambdabot> Optical p q f s t a b -> p a (f b) -> q s (f t)
05:26:35 <supki> kqr: l (const f)
05:26:43 <haasn> danilo2: I think if you add a constraint | r f -> t -- which is theoretically redundant
05:26:50 <haasn> then you could remove the (t ~ Int)
05:27:00 <haasn> Maybe you could remove that either way
05:27:00 <quchen> %%~ = id, isn't it?
05:27:02 <haasn> I think you could remove that either way
05:27:04 <haasn> quchen: yes
05:27:08 <supki> kqr: %%~ exists only for completeness, it's id
05:28:22 <danilo2> haasn: I think, that introducing such fundep is equivalnet to Has3 (updated: http://lpaste.net/107537) and it is not redundant - am I right?
05:29:08 <carlosgaldino> @pointful 2 + 3 * 4
05:29:08 <lambdabot> (2 + (3 * 4))
05:29:22 <darthdeus> is there a way to turn this off? https://github.com/haskell/haskell-mode/wiki/Import-management#entering-imports please :)
05:29:31 <danilo2> haasn: Anyway - thank you very, very much for your help!
05:29:57 <mmmm> Are there any good resouces to learn about using strictness to improve memory usage?
05:31:01 <kqr> supki, yeah, but %%~ makes it easier to compose things, as in `s & a . b . c %%~ f'
05:32:12 <kqr> supki, and it fits well into the picture of the pure `s & a . b . c %~ g`
05:33:01 <kqr> supki, so i'd sort of expect that if you can do the pure `s & a . b . c .~ y' you should be able to do the impure `s & a . b . c ..~ x', but maybe that's just me
05:40:02 * hackagebot apiary 0.12.5 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.12.5 (HirotomoMoriwaki)
05:45:03 * hackagebot apiary 0.12.6 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.12.6 (HirotomoMoriwaki)
05:46:56 <carlosgaldino> what's the best vim plugin for haskell?
05:47:19 <carlosgaldino> I see ghc-mode, hdevtools, haskellmode-vim and they all look similar
05:47:45 <carlosgaldino> some differences but yeah, the set of features kinda look the same
05:50:03 * hackagebot apiary 0.12.7 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.12.7 (HirotomoMoriwaki)
05:55:03 * hackagebot haddock 2.14.1 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.14.1 (SimonHengel)
06:00:04 * hackagebot haddock 2.14.2 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.14.2 (SimonHengel)
06:23:01 <breadmonster> Hello, everyone.
06:23:14 <suOya_> Hello, breadmonster.
06:23:30 <breadmonster> Okay, so I need a bit of a hand.
06:23:35 <breadmonster> I've read LYAH.
06:23:42 <breadmonster> And I'm going through parts of RWH.
06:23:54 <breadmonster> How do I start writing actual code though? I'm not a programmer.
06:24:12 <breadmonster> And my background is in economics, so I don't know anything about software engineering, or dev cycles.
06:24:33 <Okasu> breadmonster: Decide what you're trying to solve, open emacs and solve it by writing code. ;)
06:24:53 <Preyer> And Google / ask here or elsewhere when you get stuck
06:24:53 <breadmonster> Okasu: Well, can I contribute to any projects or something?
06:24:59 <suOya_> breadmonster: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
06:25:12 <breadmonster> Do all of you have CS degrees?
06:25:18 <Ankhers> Nope.
06:25:22 <ion> no
06:25:32 <suOya_> breadmonster: Also, if you've read LYAH, drop RWH and study the typeclassopedia article on haskell wiki
06:25:37 <Okasu> breadmonster: It might be hard without prior programming experiance.
06:25:47 <oakwhiz> http://www.haskell.org/haskellwiki/Typeclassopedia
06:25:55 <oakwhiz> I'm reading it right now as a matter of fact
06:25:56 <Okasu> But noone restricts you from doing it of course.
06:26:01 <breadmonster> Ankhers ion: Are your degrees in the humanities?
06:26:13 <ion> breadmonster: no
06:26:17 <Ankhers> breadmonster: no
06:26:25 <osfameron> mine is
06:26:55 <Ankhers> Could someone please take a look at this? I feel like I am going about it all wrong. http://lpaste.net/107540
06:27:21 <breadmonster> osfameron: Did you figure out how to program on your own?
06:27:50 <mmmm> there are lots of open pandoc tickets...
06:28:18 <breadmonster> Umm, also, how do I find projects I can contribute to?
06:29:17 <osfameron> breadmonster: kinda, yeah.  though I'd learnt basic & logo years before hand, so I had a vague idea about the actual coding part
06:29:38 <mmmm> what are you interested in breadmonster?
06:30:00 <breadmonster> mmmm: Umm, I'm an econ major, but I'm interested in what Jane Street does.
06:30:05 <ocharles> Here's a fun question
06:30:15 <ocharles> I'm doing some interop with some stupid JavaScript, and I need to double encode some text as utf8
06:30:19 <breadmonster> That's how I got started into CS, and now it seems pretty fun.
06:30:23 <ocharles> Any idea how I can purposely do such a stupid thing?
06:30:35 <ocharles> encodeUtf8 :: Text -> ByteString, so I can't just use that twice...
06:30:58 <breadmonster> mmmm: Is there something similar that uses Haskell?
06:31:06 <oakwhiz> ocharles: Interpret the bytes from the first encode as ascii, then feed back into another encode pass?
06:31:12 <osfameron> ocharles: hehe
06:31:13 <ocharles> oakwhiz: I could try that...
06:32:28 <ocharles> oakwhiz: decodeASCII . encodeUtf8 == id
06:32:29 <ocharles> :(
06:32:33 <Okasu> breadmonster: You can split that "that" into smaller pieces, pick simpes one and implement is by your own as exercise, ultimately you'll end up with "what Jane Street does".
06:32:58 <Okasu> simplest*
06:33:09 <breadmonster> Okasu: Algorithmic trading?
06:33:26 <mbrock> hmm, I would like to have Uniplate's `transformBiM`, but using Applicative instead of Monad...
06:33:31 <oakwhiz> ocharles: I'm not really sure what double-encoded UTF8 actually looks like.
06:33:41 <bennofs> Fuuzetsu:
06:33:52 <breadmonster> Okasu: Fine, alright.
06:33:56 <bennofs> sry for ping, accidently pressed return :|
06:33:58 <Okasu> breadmonster: Why do you asking me, it's your call what exactly atracts you in Jane Street activity. :)
06:34:08 <christiaanb> breadmonster: Standard Charted is a "bank" that uses (a strict version of) Haskell. Is that what you mean?
06:34:43 <christiaanb> s/charted/chartered
06:34:46 <oakwhiz> ocharles: In fact I can't think of a reason why ASCII to UTF8 to bytes to UTF8 shouldn't be the identity function
06:34:51 <breadmonster> christiaanb: Yup, kinda, like that.
06:36:24 <mbrock> ocharles, oakwhiz: double encoding implies that you have some other non-ASCII encoding, no?
06:36:24 <christiaanb> breadmonster: and edwardk, a well-known figure in the haskell community (in case you didn't know), works for www.capitaliq.com AFAIK
06:37:02 <breadmonster> christiaanb: Oh thanks. I've only just joined the Haskell community.
06:37:37 <oakwhiz> ocharles: UTF-8 multibyte sequences break the rule
06:41:06 <ocharles> oakwhiz: it seems that the following gives me the bytes I "want"
06:41:12 <ocharles> T.encodeUtf8 . T.pack . Char8.unpack . T.encodeUtf8 $ ("’")
06:41:21 <ocharles> That matches the bytes I see in wireshark from this stupid JavaScript library
06:42:27 <mbrock> oh, I guess `lens` provides an applicative version of Uniplate's `transformBiM`...
06:43:39 <bergmark> mbrock: are you going to add our first lens dependency??
06:44:05 <bergmark> not sure it will pass through the council unscathed
06:44:47 <mbrock> seems overkill :(
06:46:33 <Fuuzetsu> bennofs: I'm writing your name down in my ‘people who pinged me without a good reason’ book.
06:47:01 <mbrock> bergmark: I'll just write some pattern matching horror instead of using transform :(
06:49:22 <bergmark> mbrock: very good!
06:49:44 <mbrock> then I'll go home and use lens all night
06:50:01 <bergmark> rebel without a cause
06:50:57 <mbrock> rebel without a hobby project!
06:59:11 <Ankhers> Would someone be able to take a look at this and help me fix my error and or tell me if I am doing anything I should be avoiding? http://lpaste.net/107540
07:00:09 * hackagebot hailgun 0.1.0.0 - Mailgun REST api interface for Haskell.  http://hackage.haskell.org/package/hailgun-0.1.0.0 (RobertMassaioli)
07:00:11 * hackagebot engine-io 1.0.1 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.0.1 (OliverCharles)
07:02:32 <ClaudiusMaximus> Ankhers: forkIO :: IO () -> IO ThreadId, but you're trying to fork a StateT ... which is different from IO
07:03:47 <mbrock> Ankhers: it would probably be easier to write that without using StateT, by just passing down the Rabbit connection as parameters (to app, and then to bid)
07:04:34 <danilo2> hello! is there any way to use RankNTypes in type classes instances? like (type instance Test Vector "foo" = forall a. (a -> a)) ?
07:04:44 <danilo2> *type families!
07:04:50 <Ankhers> ClaudiusMaximus, mbrock: Thanks. I will look into that.
07:10:10 * hackagebot debian 3.81.3 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.81.3 (DavidFox)
07:11:43 <suOya_> Will Haskell get more industry adoption in the future or will it remain a niche?
07:13:09 <alpounet> it is powering more and more companies these days
07:13:13 <alpounet> compared to 5 years ago
07:16:01 <suOya_> Are there any other big companies that have recently partially adopted it? Like Facebook did that one library
07:19:06 <Desheng_> is there a "tutorial" for kinds
07:19:18 <suOya_> search Haskell wiki
07:23:41 <frerich> Reading through the available modules in the 'base' package is quite interesting. There are a few funky but lesser-known (at least to me) things in there! Like, Data.Version or Data.Unique :)
07:23:50 <alpounet> suOya_: there are many banks/companies in the finance industry using haskell. I thinkk google and a couple of other "giants" have a few internal tools and what not in haskell, too. the situation is really improving there, it's easier to find a haskell job these days than it was a couple of years ago.
07:24:19 <Aleksejs> Hi, maybe there is some working piece of code to fetch <title> of webpage by URL?
07:26:01 <alpounet> Aleksejs: there are many libraries to accomplish this (the fetching on one hand and the HTML inspection on the other).
07:33:36 <haasn> danilo2: re: Has3, I'm not immediately sure, but it could be the case
07:33:46 <haasn> Has3 and Has1 can be made more or less equivalent any way
07:33:49 <haasn> Has2 is the outlier
07:33:50 <michaelt> Aleksejs: here is an example http://hackage.haskell.org/package/http-conduit-2.1.3/docs/Network-HTTP-Conduit.html
07:35:25 <danilo2> haasn: thank you :) btw I found the distinction betwen Has and Has2
07:36:11 <danilo2> haasn: If you want to concatenate 2 calls to Has2, then you get type error (because type inferencer cannot deduce the first resulting type without ambiguity) - In the case of Has, we do not get this kind of errorr
07:36:28 <lesmon> Is there any memory leaks or broken infinite loop with ghci ? I just have frozen now, and this is the only program which have been killed.
07:36:57 <haasn> danilo2: Yes, that makes sense
07:37:08 <haasn> This is what I meant earlier with “in the general case”
07:37:10 <haasn> eg. for polymorphic variables
07:37:36 <danilo2> haasn: :)
07:38:01 <danilo2> haasn: Thanky you once agai for your attention and help :)
07:39:47 <michaelt> Aleksejs: oh wait, may http://www.serpentine.com/wreq/tutorial.html is more what you are looking for
07:43:42 <carlosgaldino> how to disable vim2hs folding every function definition?
07:44:42 <croyd> carlosgaldino: let g:haskell_conceal = 0 " << put that in your vimrc
07:45:01 <croyd> carlosgaldino: I think that disables all folds
07:45:49 <carlosgaldino> croyd: on the readme, conceal means unicode for colon and arrows
07:48:27 <croyd> carlosgaldino: I'm pretty sure that's what disabled folding for me -- it's the only vim2hs item in my vimrc. Maybe its meaning has changed in newer versions
07:51:04 <croyd> carlosgaldino: evidently I also added "set nofoldenable" to my vimrc at the same time. That's probably what did it.
07:51:17 <carlosgaldino> croyd: aaah, good
07:56:10 <danilo2> By the way - is there any way to use RankNTypes in type families instances? like (type instance Test Vector "foo" = forall a. (a -> a)) ?
07:57:55 <carlosgaldino> croyd: thanks
08:01:02 <tomku> I'm working through Brent Yorgey's CIS194 class on Haskell, and the lectures are provided as literate Haskell files... is there a better way to step through the chunks of code than copying each into a text file, then loading it in ghci?
08:08:20 <kqr> jco, hey
08:08:33 <kqr> jco, http://lpaste.net/9112738000046915584
08:08:35 <kqr> jco, i wrote that for you
08:08:41 <suOya_> "class (Monad m) => MonadError e m | m -> e where
08:09:00 <suOya_> Why is there a | between e m and m -> e
08:09:02 <suOya_> I haven't seen that
08:10:09 <joshc> suOya_: http://www.haskell.org/haskellwiki/Functional_dependencies
08:22:58 <croyd> carlosgaldino: np
08:23:16 <christiaanb> Is there a way I can count (potentially using unsafePerformIO) how many times an algorithm traverses my datastructure?
08:24:02 <christiaanb> That is, observe in ghci the difference in traversals between "fmap Just . fmap Just" and"  "fmap (Just . Just)" ?
08:25:07 <carlosgaldino> ghcmod-vim always requires a `main`? I'm getting a "ghcmod#command#type: Cannot guess type" when opening a file that does not have a "main" defined
08:28:22 <donri> carlosgaldino: does it have a module [not Main] where?
08:32:01 <carlosgaldino> donri: no, just a bunch of function definitions, without any module or anything
08:35:24 <pjdelport> christiaanb: Here's one hack:
08:35:24 <pjdelport> newtype TraceList [a] = TraceList { fromTracelist :: [a] } deriving Show
08:35:24 <pjdelport> instance Functor TraceList where fmap f = TraceList . fmap (f . trace "<ping!>") . fromTracelist
08:36:28 <pjdelport> christiaanb: and then count the pings
08:39:07 <pjdelport> christiaanb: That will make "fmap Just . fmap Just" show twice the number of pings that "fmap (Just . Just)" does.
08:43:23 <pjdelport> christiaanb: OTOH, that won't show traversals that ignore the value. To count those too:
08:43:23 <pjdelport> instance Functor TraceList where fmap f = TraceList . foldr (\x xs -> f x : trace "<ping!>" xs) [] . fromTracelist
08:43:39 <adimit> carlosgaldino: it (somewhat strictly) assumes that any module that does not have a module Bla where clause at the top *must* be a main module. A "Main" module must declare a function main :: IO ()
08:44:30 <pjdelport> christiaanb: Then "length . fromTracelist . fmap Just . fmap Just . TraceList $ [1..3]" will show 6 pings, but the same with "fmap (Just . Just)" will show 3.
08:45:02 <frerich> adimit: To be pedantic, it doesn't need to be 'IO ()'.
08:45:12 <carlosgaldino> adimit: ok, gotcha. thanks
08:45:33 <adimit> frerich: oh, it doesn't? But it needs to be in IO. So maybe it could be 'IO Int'?
08:45:52 <frerich> adimit: Right, I think it's "IO a".
08:46:03 <adimit> frerich: gotcha. Thanks :-)
08:46:49 <frerich> Interesting, it seems that 'runhaskell' prints the value which the main action yields.
08:47:22 <frerich> I.e. running 'main = return "Hello"' via "runhaskell Main.hs" prints '"Hello"'.
09:02:54 <Tjr> Why doesn't the rmonad package show up in the reverse dependency list?
09:02:56 <Tjr> http://packdeps.haskellers.com/reverse
09:02:59 <Tjr> https://hackage.haskell.org/package/rmonad
09:03:33 <donri> presumably nothing depends on it
09:04:18 <tinker> if using X.Y.Z ad build versions when would you increase Y? Z is for small bugfixes, X for big changes to the program and Y is for...?
09:06:56 <adimit> tinker: changes that break the API
09:07:30 <Tjr> monads with restrictions on the type classes is probably a common problem. What else do people use, if it's not RMonad?
09:07:33 <adimit> if I depend on your package, I want to be able to depend on version X.Y.*, and know it won't stop compiling.
09:07:56 <glguy_> Tjr: it doesn't come up much in practice
09:08:01 <Tjr> hmm
09:08:10 <adimit> tinker: http://www.haskell.org/haskellwiki/Package_versioning_policy
09:21:33 <Tjr> A lot of packages are duplicated, once for "tranformers", once for "mtl". What's up with that?
09:21:47 <Tjr> s/tranformers/transformers/
09:22:00 <glguy_> transformers is just the transformers
09:22:02 <edwardk> mtl sits on top of transformers
09:22:05 <glguy_> mtl is a layer of classes on top of that
09:22:18 <edwardk> MonadCatchIO-mtl vs MonadCatchIO-transformers ? that i never understood.
09:22:19 <edwardk>  ;)
09:22:20 <glguy_> You only need mtl if you want the auto-lifting operations
09:22:40 <Tjr> Where is a good tutorial to dive into these things?
09:22:41 <Qfwfq> Is there a packaging of containers:Data.Set.Set with exposed constructors?
09:22:50 <edwardk> Qfwfq: not currently
09:23:17 <Qfwfq> Curses!
09:23:54 <rwbarton> what do you need them for exactly?
09:24:55 <Tjr> education :_)
09:25:10 <Tjr> It seems these libraries are used or mentioned in lots of places.
09:25:14 * glguy_ was contemplating a package that provided a template haskell implementation to grab arbitrary definitions from behind module boundaries: $(unsafeImport "Data.Set.InternalDataThing")
09:25:26 <Tjr> Therefore, I conclude they have important concepts that I should get to know.
09:25:54 <glguy_> Tjr: I'm betting that rwbarton wants to know what Qfwfq wants access to the Set constructors for
09:26:50 <Qfwfq> Oh. Want type-level length annotations.
09:27:14 <Qfwfq> Cardinality/size.
09:27:47 <adimit> Qfwfq: DataKinds and GHC.TypeLits.
09:28:22 <Tjr> edwardk: since you're the author, what is comonad good for? The documentation says what it does, but not why somebody would want to do that.
09:28:43 <edwardk> they exist because they should exist for fundamental reasons ;)
09:29:11 <ajcoppa> Tjr: have you read gabriel's blog post on comonads? http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
09:29:16 <Tjr> To use it effectively, people need to foster some kind of intuition.
09:29:21 <edwardk> now, i give a bunch of examples in articles
09:29:24 <Tjr> ajcoppa: no, thnanks, will do
09:29:37 <edwardk> https://www.fpcomplete.com/user/edwardk/cellular-automata/part-1 uses a comonad
09:29:46 <edwardk> https://www.fpcomplete.com/user/edwardk/cellular-automata/part-2 makes another
09:30:01 <edwardk> https://www.fpcomplete.com/user/edwardk/conquering-folds makes another
09:30:08 <ajcoppa> listen to edwardk before me ;)
09:30:12 <edwardk> another: https://www.fpcomplete.com/user/edwardk/parallel-crc
09:30:34 <edwardk> https://www.fpcomplete.com/user/edwardk/recursion-schemes on the catamorphism side are parameterized by comonads
09:30:40 <albeit> I'm using hmatrix, and trying to multiply a matrix by a vector (<> or mXv), but instead of summing the products at each row, I want to mutliply them... is that possible? What would it be called?
09:31:00 <edwardk> i use them for talking about lots of little bits of state, stream processing...
09:31:08 <edwardk> they are a pattern that shows up over and over
09:31:24 <edwardk> but unlike monads they don't have the "IO killer app" that makes everyone learn them right out of the gate
09:31:45 <glguy_> edwardk: Are there anything particularly interesting combinators you like that simply use the comonad structure?
09:32:08 <glguy_> or is it simply that a lot of the types you happen to use in those blog posts also admit comonad instances?
09:32:10 <edwardk> glguy_: gcata mostly
09:32:29 <edwardk> i don't really _like_ gcata, but it forms the basis of half of recursion-schemes from comonads and comonad-transformers
09:32:48 <SrPx> Is there any tutorial or explanation on how the `unfold` works? I am trying to create an unfold for `data ConcList a = Conc (ConcList a) (ConcList a) | List a | Nil`, but I am not sure I am doing it right. I mean, it works, but it feels weird.
09:33:16 <edwardk> i do tend to use the comonadic plumbing a fair bit here and there, but its much more ancillary, in-the-course-of-doing-something-else than with monad use
09:33:20 <glguy_> recursion schemes exists as an academic exercise, though. I seem to remember you don't recommend people actually use it for things. Is that right?
09:33:26 <edwardk> correct
09:33:37 <edwardk> i use comonads more in scala where monad transformers are just awful
09:34:07 <edwardk> because i can work with a comonad inside of a monad, instead of transforming the monad for most interesting applications
09:34:07 <Tjr> ajcoppa, edwardk thanks
09:34:25 <edwardk> then i can avoid the pain and suck that are scala monad transformers ;)
09:34:57 <edwardk> e.g. work with Env/Coreader inside of my project's state monad rather than work with ReaderT on it
09:34:59 <klrr_> is it possible to summerize the purpose of recursion schemes? have i understood it correct that it assist recursion for tree-like structures?
09:35:17 <edwardk> klrr_: recursion schemes are 'fundamental ways to build up or tear down a structure'
09:35:31 <klrr_> okey
09:35:49 <klrr_> not read the paper or really used it, just seen it used in a compiler so that make me think so
09:35:50 <edwardk> they precisely capture the meaning of various forms of (co)recursion
09:36:13 <edwardk> my experience is that the _ideas_ behind recursion schemes are important
09:36:24 <edwardk> the actual use of them to do work is somewhat less so ;)
09:36:38 <edwardk> its like insisting everyone build everything that works on lists out of foldr or something
09:36:44 <edwardk> yeah its a good exercise to know you can
09:36:52 <edwardk> and you get some good fusion benefits if you do
09:37:08 <edwardk> but writing the recursion by hand is probably more straight forward
09:39:02 <Javran> can I write pattern matching with guards, just like in ml we have "match xxx with (a,b,c) when a == b -> whatever"
09:40:09 <Ainieco> hello]
09:40:12 <oakwhiz> I've been reading a little bit about Zippers. Do they only work in 1 dimension? Can some kind of space-filling curve make them work in 2 or more dimensions?
09:40:25 <Ainieco> yanone ever used "thyme"? how to construct UTCTime?
09:40:34 <joelteon> getUTCTime
09:40:36 <joelteon> no wait
09:40:38 <joelteon> getCurrentTime
09:40:40 <joelteon> there you go
09:41:03 <k00mi> Javran: case xxx of (a,b,c) | a == b -> whatever
09:41:04 <Ainieco> joelteon: i'd like to explicity specify day and time
09:41:13 <Ainieco> UTCTime (ModifiedJulianDay 100) (DiffTime 1)
09:41:21 <joelteon> oh yeah, hang on
09:41:24 <joelteon> you can use the lenses for that
09:41:27 <Ainieco> doesn't work because DiffTime doesn't exported
09:41:29 <joelteon> let me go figure it out
09:41:34 <Ainieco> joelteon: thank you!
09:41:53 <joelteon> I feel your pain Ainieco, I wish there was a diagram for how the types relate
09:41:56 <michaelt> :t let ainieco f x = case f x of (a,b,c) | a == b  -> 4 ; otherwise -> 0
09:41:57 <lambdabot> <no location info>:
09:41:57 <lambdabot>     not an expression: ‘let ainieco f x = case f x of (a,b,c) | a == b  -> 4 ; otherwise -> 0’
09:42:02 <michaelt> bah
09:42:08 <Javran> oakwhiz: http://blog.emillon.org/posts/2012-10-18-comonadic-life.html I think this post gives you some ideas about 2d list zippers
09:42:19 <Javran> k00mi: thanks!
09:42:33 <michaelt> :t let goo f x = case f x of (a,b,c) | a == b  -> 4 ; otherwise -> 0 in goo
09:42:34 <lambdabot> (Num a1, Eq a) => (t -> (a, a, t1)) -> t -> a1
09:43:04 <Javran> cool
09:43:08 <michaelt> oh, Ainieco like k00mi says...
09:43:55 <Ainieco> michaelt: excuse me?
09:44:10 <joelteon> Ainieco: You can use UTCTime (ModifiedJulianDay 100) (fromSeconds 1)
09:44:11 <oakwhiz> Javran: Wow that's actually pretty cool. And it seems to generalize to higher dimensions.
09:44:31 <michaelt> Ainieco: forget it I was demonstrating pattern matching + guards
09:45:04 <oakwhiz> data Zthree a = Zthree (ListZipper (ListZipper (ListZipper a)))
09:45:08 <Ainieco> joelteon: thanks a lot
09:45:19 <joelteon> I'm gonna draw a diagram of all the Thyme types
09:45:24 * hackagebot exposed-containers 0.5.5.1 - A distribution of the 'containers' package, with all modules exposed.  http://hackage.haskell.org/package/exposed-containers-0.5.5.1 (vi)
09:46:10 <Qfwfq> Bleep bloop.
09:47:01 <jfischoff> what is the default handle buffering option in Haskell?
09:47:31 <jfischoff> is it in the report or is it GHC specific?
09:50:25 * hackagebot reflection 1.5.1 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.5.1 (EdwardKmett)
09:50:59 <joeyh> bgamari: followed your post and script, and I have ghci working on arm. really working, not half-broken. excellent!
09:51:05 <joeyh> I hope we can get this going in Debian
09:52:13 <Ainieco> joelteon: do you kbow by chance why UTCTime have a Day -> DiffTime -> UTCView?
09:53:43 <joelteon> because UTCTime is one of the constructors of UTCView
09:53:50 <joelteon> actually it's the only constructor
09:55:36 <mpankov> hi everyone
09:55:40 <Ainieco> joelteon: hm, but http://hackage.haskell.org/package/thyme-0.3.5.2/docs/Data-Thyme-Clock.html#g:3 says that UTCView and UTCTime are different type(note two "data" keywords).
09:55:57 <joelteon> Ainieco: yeah, UTCTime is both a data constructor and a type constructor
09:56:14 <joelteon> to view the internals of a UTCTime (that is, the type) you can use the utcTime lens
09:56:18 <joelteon> then you'll get a UTCTime (that is, the value)
09:56:28 <joelteon> pretty clever naming system :)
09:56:28 <mpankov> I'm a novice and I can't figure out is there a way to embed state to a function returning IO Bool. could someone help me please?
09:56:41 <Ainieco> ah, i see
09:57:35 <Tjr> "so we extend the Monad type class with a bindWithSrcLoc method, polluting its categorical elegance with the concerns of mundane coders." (from http://pepeiborra.wordpress.com/2009/11/01/monadic-stack-traces-that-make-a-lot-of-sense/)
09:57:37 <moghedrin> mpankov: What do you mean by "embed state"? Can you give an example?
09:59:59 <mpankov> moghedrin: I'm using vty-ui and there's handleKeyPress :: Widget a -> Key -> [Modifier] -> IO Bool. I think it's not that important though. The thing is I want to, say, increment a number each time some key is pressed. but how do I store it then?
10:00:48 <Ainieco> joelteon: the main reason i'm using thyme is performance, "time" is too slow for me. i'm not quite understand if I should use UTCView or UTCTime, it looks like UTCTime is right one because UTCView is for compativility
10:02:03 <Ainieco> joelteon: but then how to contruct UTCTime if "UTCTime (ModifiedJulianDay 100) (fromSeconds 1)" gives me UTCView, should i construct UTCView first and then using lens extract UTCTime from there <-- looks kind of wrong to me
10:02:16 <mpankov> moghedrin: I mean I need to store the number I need to increment but well the only interaction point is this handler, which is pure
10:02:31 <michaelt> mpankov: the really dumb straightforward thing is do {ref <- newIORef 0; ... ; n <- readIORef ref; foo n; writeIORef ref (n+1) ...
10:03:39 <joelteon> Ainieco: yep, that's how you do it
10:03:44 <moghedrin> mpankov: Have you read the manual for vty-ui? It goes through this exact process and explains what's going on :)
10:04:01 <joelteon> Ainieco: (utcTime #) :: UTCView -> UTCTime
10:04:04 <mpankov> michaelpj: hm, I somehow always avoided the IORef thing. what are the downsides?..
10:04:21 <mpankov> moghedrin: well I read that, don't quite get what section do you mean
10:05:00 <Ainieco> joelteon: oh, i wonder why it should be so round about, what if i don't care about compativility in which case i simply don't need UTCView at all...
10:05:34 <Kron> what does it take to use numerical literals as data constructors in custom data types?
10:05:44 <Kron> data DecimalDigit = 0 | 1 | 2 | ... | 8 | 9
10:05:51 <Kron> that won't work because it'll trigger an error I think
10:06:00 <Kron> is it reserved for the pre-established Num data types?
10:06:49 <michaelt> mpankov: oh I see a Widget is an IORef anyway
10:07:31 <moghedrin> mpankov: Oh. I thought it gave explicit code for handling key event on the counter. I was wrong XD
10:08:12 <dfeuer> Kron, it would take some deep wonkiness, and then those literals won't be available for their usual purposes.
10:08:17 <Kron> gotcha
10:08:37 <mpankov> michaelpj: Widget - maybe, I just need to keep my state outside of it
10:08:38 <dfeuer> But you can do things like D1|D2|D3...
10:08:38 <phaskell> D3: [nagios-master] Use nginx instead of apache. - https://phabricator.haskell.org/D3
10:08:39 <phaskell> D2: Add .arcconfig - https://phabricator.haskell.org/D2
10:08:39 <phaskell> D1: Add LICENSE and update README.md - https://phabricator.haskell.org/D1
10:09:11 <mpankov> michaelpj: I wonder will it pay off to implement my own widget with the state I need..
10:09:56 <mpankov> oh I just mistyped the nicknames
10:10:12 <moghedrin> mpankov: If you make a function that increments a counter called incCounter (or whatever you want to call it), you could do something like - updateWidgetState counter incCounter >> return True
10:11:08 <moghedrin> so the whole thing would look like counterWidget `onKeyPressed` \this key modifiers -> updateWidgetState this incCounter >> return True
10:11:54 <mpankov> and Counter is the thing from section 3.1, right?
10:12:55 <moghedrin> mpankov: Aye, and counterWidget is just the Widget Counter you created.
10:13:35 <Ainieco> joelteon: sorry, could you please give me an example of how can i use utcTime? not quite familiar with lens
10:14:06 <mpankov> moghedrin: seems like I could make it work :) thanks, somehow forgot about that "implementing widgets" stuff from manual, only looked at existing ones
10:14:40 <moghedrin> mpankov: No prob - it was convenient that I literally already had the manual pulled up (as I'm playing with vty-ui myself XD)
10:16:34 <joelteon> Ainieco: (utcTime #) :: UTCView -> UTCTime
10:16:50 <joelteon> Ainieco: view utcTime :: UTCTime -> UTCView
10:16:55 <joelteon> those two should be all you need
10:19:22 <Ainieco> joelteon: thank you very much!
10:20:28 * hackagebot taggy-lens 0.1.2 - Lenses for the taggy html/xml parser  http://hackage.haskell.org/package/taggy-lens-0.1.2 (AlpMestanogullari)
10:21:44 <Qfwfq> alpounet: Why bump the version with no changes?
10:21:50 <Ainieco> what does # do?
10:22:01 <Ainieco> can't find it in lens
10:22:29 <jfischoff> Ainieco: what is the context
10:23:01 <supki> :t ( # )
10:23:02 <lambdabot> AReview s t a b -> b -> t
10:23:04 <supki> :t review
10:23:05 <lambdabot> MonadReader b m => AReview s t a b -> m t
10:23:23 <alpounet> Qfwfq: doctest failing with the version in nixpkg, fixed with a small recent commit of mine and Soenke asked for a release when I found some time that fixes that
10:23:53 <Qfwfq> Ah, cool.
10:24:20 <Ainieco> ah, it's in lens afterall
10:24:22 * augur s t a b's supki
10:24:56 <Qfwfq> alpounet: Yeah, I manually wrote some of the doctest responses (before we were using it), because I couldn't be bothered to test the examples in a REPL.
10:25:21 <Qfwfq> alpounet: So we ended up missing spaces to delimit lists, etc. :(
10:25:30 <alpounet> well it wasn't failing before apparently
10:25:39 <Qfwfq> alpounet: Not sure why the Travis build passed before though, maybe different version in nixpkgs.
10:25:42 <alpounet> I don't know what's going on, except that the doctest now passes
10:26:07 <Qfwfq> Or a different GHC.
10:26:17 <alpounet> yeah
10:26:51 <marchelzo_> Does anyone know of a simple library for making images? I have an 8x8 matrix of 0s and 1s, and I want to be able to output say a 64x64 png with 8x8 red blocks where I have 1s and white blocks where there are 0s/
10:27:11 <Qfwfq> marchelzo_: Gloss is popular.
10:27:21 <marchelzo_> Qfwfq: thanks. I'll check it out
10:27:57 <alpounet> juicypixels supports a bunch of formats
10:29:36 <mpankov> \leave
10:30:29 * hackagebot hakaru 0.1 - A probabilistic programming embedded DSL  http://hackage.haskell.org/package/hakaru-0.1 (z)
10:44:18 <adas> Im in a cabal sandbox. i did cabal update. Added quickcheck==2.7.5 as the only dependency in the cabal file. But I get "dependency could not be resolved error". Could someone please tell me whats going on?
10:44:44 <adas> am using ghc 7.8.3, happy 1.19.4
10:49:38 <educated_idiot> adas: is cabal case sensitive for that? i.e. QuickCheck?
10:49:44 <adas> educated_idiot: yup
10:49:56 <michaelt> adas: you might get more information about the trouble if you add --verbose==3 or something
10:49:56 <adas> changed quickcheck to QuickCheck and now works
10:50:09 <michaelt> hah
10:50:35 <adas> i did not realize that it was case sensitive
10:50:42 <adas> well .. now i know
10:53:21 <josephle> fortunately, no one has yet written a library that has obnoxious casing in its name...as far as I know
10:55:08 <carter> i wonder if hackage and cabal accept unicode names
10:55:13 <supki> educated_idiot: sometimes it's case sensitive, sometimes it's not:  cabal install quickcheck  will work, for example
10:55:15 <carter> you could really fuck with people that way
10:58:00 <int3__> I would like to have a variant of a rose tree, like so: Tree a b = Tree a [(b, Tree a b)]
10:58:18 <int3__> is there some sort of generalized library version of Data.Tree that I could use?
10:58:43 <int3__> I could certainly write it myself, I'm just curious
10:59:53 <Qfwfq> It'd be neat to have language support for arithmetic on sum types. Either - Left =~ Maybe.
11:03:00 <kazagistar> isn't (Either a b - Left = b?)
11:03:26 <joelteon> what do you mean "- Left"?
11:03:40 <kazagistar> I have no idea, Qfwfq wrote it first
11:03:41 <josephle> I'm not even sure (Either a b - Left) kind-checks
11:03:48 <joelteon> doesn't make sense
11:03:48 <alpounet> Qfwfq: you want to learn about combinatorial species maybe? http://byorgey.wordpress.com/2009/07/24/introducing-math-combinatorics-species/
11:05:21 <alpounet> Qfwfq: http://www.cis.upenn.edu/~byorgey/papers/species-pearl.pdf
11:06:49 <Qfwfq> Ah, yay!
11:08:50 <Qfwfq> kazagistar: No, you still have the type constructor. But that was a convulted example; I'm working on an implementation of the relational model, and found myself wanting to represent a universe of types as selectively permitting nulls.
11:10:00 <Qfwfq> The proposed syntax is really insensible, yeah.
11:23:09 <joelteon> Hey #haskell, how readable would you say this diagram is? http://i.imgur.com/e5oJGtk.jpg
11:23:19 <donri> type Maybe a = () `Either` Identity a
11:23:41 <jfischoff> joelteon: nice!
11:23:54 * ktosiek likes the operators on DiffTime
11:25:33 * hackagebot hakaru 0.1.1 - A probabilistic programming embedded DSL  http://hackage.haskell.org/package/hakaru-0.1.1 (z)
11:25:59 <joelteon> there are some wrong bits in there though
11:31:19 <kaih> hello, is it possible to write this a little bit more elegant?
11:31:21 <kaih> main = join $ withCString "welt" <$> withCString "hallo" (return . prt2)
11:31:23 <kaih>     where prt2 :: CString -> CString -> IO ()
11:31:56 <glguy_> main = withCString "welt" $ \ p1 -> withCString "hallo" $ \ p2 -> prt2 p1 p2
11:32:13 <glguy_> and you can put a newline after each ->
11:41:23 <donri> you could use resourcet and newCString + free
11:41:48 <kaih> ah, thats much nicer, thanks glguy
11:42:12 <educated_idiot> joelteon: the bi-directional arrows are confusing
11:42:19 <joelteon> educated_idiot: agreed
11:42:33 <joelteon> it is a pretty bad diagram
11:46:10 <donri> kaih: something like, main = runResourceT $ do (k1,p1) <- allocate (newCString "welt") free; (k2,p2) <- allocate ...  -- and you can factor out these allocations to a helper
11:47:57 <donri> kaih: completely overkill for your example, but maybe useful if the example was contrived and in reality you need to allocate a lot of CStrings
11:49:13 <joelteon> educated_idiot: <-> is an iso, -> and <- are lenses
11:49:15 <donri> especially if you need to do other types of allocations, especially if you don't know them up front
11:56:00 <educated_idiot> joelteon: ah, okay, still haven't got around to learning lenses, not a bad take on something quasi-UML, I can see that being useful as an architectural description
11:56:28 <joelteon> educated_idiot: <-> just means bidirectional conversion, and a -> b means that b is a member of a
12:00:05 <kaih> thank you donri, looks like I have still a lot to learn :-)
12:04:11 <educated_idiot> joelteon: ah, Iso is neat :) so that captures both functions in the same type? I'm guessing one would collect those in module somewhere?
12:18:35 <centrinia> What was the Evil Mangler? https://ghc.haskell.org/trac/ghc/wiki/Commentary/EvilMangler
12:19:16 <Ankhers> http://code.haskell.org/ghc-scp/ghc/docs/comm/the-beast/mangler.html ?
12:22:58 <michaelt> centrinia: it was a really complicated perl program used to compile to C, if I remember
12:23:18 <geekosaur> not exactly, it was applied after C was compiled to assembler
12:23:39 <geekosaur> and edited that assembler in various ways. except that I think the only platform it actually did anything on was SPARC
12:24:03 <michaelt> why did the assembler need to be edited?
12:24:29 <geekosaur> because gcc doesn't know how Haskell data works, and tended to produce less optimal code for it
12:24:54 <michaelt> ah
12:25:19 <geekosaur> also the usual function entry and exit code was generally unnecessary given how ghc-compiled code works, so it was removed on platforms where it was recognized
12:25:39 <geekosaur> so you could say it was a GHC-specific peephole optimizer pass
12:27:22 <michaelt> Why was it written in perl?
12:27:25 <eacameron> Is it possible to define an instance for functions that return, say, Bool? My example case: instance Alternative (-> Bool) where....
12:28:35 <geekosaur> because it's old enough that there weren't alternatives? because ghc hq doesn't care about how you're only ever supposed to use the cool language of the week?
12:29:08 <michaelt> Oh, I was thinking it might be something to do with the material.
12:29:42 <benzrf> eacameron: thats not valid syntax m8
12:29:43 <geekosaur> it's doing pattern matching on text-format assembler instructions, a language that does that well is a plus
12:29:58 <benzrf> eacameron: it's possible but you need an extension or two
12:30:05 <benzrf> and it may have unpleasant side fx
12:30:33 <Cale> benzrf: errr
12:30:34 <eacameron> benzrf: which extensions?
12:30:40 <Cale> No, it's not possible to do that
12:31:07 <Cale> You can define a new datatype like  newtype Predicate a = Pred (a -> Bool)
12:31:21 <Cale> and then write an instance of Alternative for that
12:31:21 <benzrf> Cale
12:31:30 <benzrf> instance Foo (forall a. a -> Bool)
12:31:50 <Cale> That's not what he wants
12:31:53 <benzrf> oh?
12:32:10 <Cale> also, it's a kind error here
12:32:14 <Cale> :k Alternative
12:32:16 <lambdabot> (* -> *) -> Constraint
12:32:26 <Cale> :k forall a. a -> Bool
12:32:26 <lambdabot> *
12:32:36 <Cale> (it's not * -> *)
12:32:47 <michaelt> There won't be an Alternative instance, since there won't be a Functor instance, no?
12:32:55 <benzrf> Cale: oh wow im a idiot at kinds
12:33:07 <benzrf> michaelt: there's contravariant functor
12:33:12 <michaelt> yes
12:33:39 <Cale> You can only make something into a Functor or Alternative etc. in its last type parameter.
12:33:55 <Cale> So if you want to use a different parameter, you need to define a newtype to permute them.
12:33:58 <eacameron> Cale, benzrf: I just want to lift "or" into (a -> Bool) instead of Bool
12:34:52 <Cale> eacameron: Yeah, it's probably best just to define your own operator for that. You could also use liftM2 (||) but that's not infix like you may want
12:35:27 <eacameron> Cale: i can just alias it; but I thought Alternative might be able to get me there
12:35:46 <eacameron> so there's no way to make instances on different type parameters than the last one?
12:36:40 <Cale> Yeah, because there's no type level lambdas (and even if there were, they'd make a mess of instance resolution)
12:37:09 <Cale> You want an instance of Alternative for something like /\a. a -> Bool
12:37:26 <Cale> But that's not Haskell
12:37:42 <Cale> So, the way around it is to give that thing a name using newtype
12:38:00 <eacameron> interesting, I'm guessing Agda or Idris supports that ;)
12:38:02 <Cale> (but then you have to wrap and unwrap things, which may be too inconvenient)
12:38:12 <Cale> Agda doesn't have type classes
12:38:29 <Cale> I'm not sure how Idris deals with it
12:38:37 <eacameron> Cale, in truth, I know virtually nothing about either
12:39:20 <eacameron> I think I understand; seems strange to to be able to make instances based on function result; that seems like it would be common
12:39:27 <eacameron> *to not
12:40:15 <Cale> You have lots of cases where it would lead to ambiguity
12:41:04 <Cale> For example, Either is a functor in both its type parameters, but the instance only gives you the right handed one
12:41:32 <Cale> If both instances could somehow exist, it would be ambiguous which one was meant most of the time if you wrote something like fmap show
12:43:53 <jle`> is michaelpj spj's brother
12:44:32 <jle`> (or sister)
12:46:33 <sohum> is there a way to go from Monad m => (a -> m b) -> m (a -> b)? My intuition says there should be, but then I actually tried it and couldn't
12:47:14 <sohum> alternatively, is there a different way to lift a nonmonadic function (a -> b) -> c such that I can use my (a -> m b)?
12:47:16 <Cale> sohum: not a good way
12:47:26 <eacameron> Cale, makes sense, I suppose you have to draw the line somewhere
12:48:00 <enthropy> if you have (a ~ Bool), or some other type with very few values, it's doable
12:48:08 <Cale> sohum: Is your function a -> m b polymorphic in m?
12:48:19 <Cale> sohum: You could choose m to be the identity monad
12:48:27 <sohum> Cale: no, in this case it's IO
12:48:35 <Cale> sohum: then no, you can't
12:48:35 <sohum> but I'd be interested in hearing the general solution
12:48:44 <sohum> fair enough :p
12:48:56 <johnw> sohum: there's an SO post about that very question
12:49:09 <johnw> http://stackoverflow.com/questions/14432883/how-to-make-a-io-a-b-function-from-a-io-b-in-haskell
12:49:19 <sohum> of course there is! thanks
12:50:04 <johnw> it is generally possible for any Distributive m
12:50:07 <johnw> http://hackage.haskell.org/package/distributive-0.4.4/docs/Data-Distributive.html
12:50:14 <johnw> where in your case (->) is f, and m is g
12:50:28 <Cale> sohum: An IO (a -> b) is an action which when you execute it, gives you a function of type a -> b. A function a -> IO b is a function which for each a, gives you a different action which if you execute it, gives you a value of type b
12:50:40 <johnw> but as you can see there, IO does not distribute
12:50:45 <sohum> yepyep
12:50:49 <sohum> makes sense
12:51:16 <sohum> so what's the normal way to make higher order functions monadic, then?
12:51:24 <sohum> like, mapM is not just a simple transform of map, then
12:51:36 <jle`> sohum: mapM f = sequence . map f
12:51:42 <Cale> sohum: If the type a is finite, you could write an action of type IO (a -> b) which executes all the results of applying the function a -> IO b, and then construct from those results a function a -> b
12:51:48 <Cale> But that's probably not what you want to do.
12:51:49 <jle`> by the way, in your case, you are making your monadic function un-monadic
12:51:59 <jle`> or, you are trying to.
12:52:02 <Cale> sohum: Right, it's not.
12:52:11 <Cale> sohum: mapM contains more information than map.
12:52:26 <Cale> sohum: It specifies an order in which to execute the actions
12:52:26 <sohum> mmm.
12:52:49 <sohum> jle`: well, I want my HOF (a -> b) -> c to be (a -> m b) -> m c, I guess
12:53:10 <sohum> so I, yeah, probably need to specify a sequence or somesuch
12:53:25 <johnw> :t fmap return . cofmap (fmap return)
12:53:26 <lambdabot>     Not in scope: ‘cofmap’
12:53:26 <lambdabot>     Perhaps you meant one of these:
12:53:26 <lambdabot>       ‘fmap’ (imported from Control.Monad.Writer),
12:53:35 <Cale> There is a nice relationship between them though:
12:53:43 <jle`> ...really?  that's the fmap it thinks you mean?
12:53:44 <johnw> :t fmap return . contramap (fmap return)
12:53:45 <lambdabot> (Contravariant f, Functor f1, Functor f, Monad m1, Monad m) => f (f1 (m1 a)) -> f (m (f1 a))
12:53:45 <Cale> mapM f xs = sequence (map f xs)
12:53:56 <Cale> sequence [] = return []
12:54:10 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:54:15 <Cale> :t sequence
12:54:15 <lambdabot> Monad m => [m a] -> m [a]
12:55:06 <Cale> But note that we could have written  sequence' [] = return []; sequence' (x:xs) = do vs <- sequence' xs; v <- x; return (v:vs)
12:55:25 <Cale> and then mapM' f xs = sequence' (map f xs)
12:55:26 <enthropy> @type auf (_Unwrapping Identity) mapM
12:55:27 <lambdabot> (a -> b) -> [a] -> [b]
12:55:37 <sohum> yea, and map can do that because it knows the order here really doesn't matter
12:55:42 <sohum> or at least is arbitrary
12:55:45 <Cale> mapM' is also a generalisation of map, but a different one
12:56:20 <Cale> (the effects happen in reverse order, but the results are in the same order in the end)
12:56:50 <sohum> the effect order, right
12:57:24 <pjdelport> This came up in another channel recently, and is sort of related: http://lpaste.net/107551
12:58:15 <pjdelport> That's an Applicative wrapper that reverses the underlying Applicative's sequencing order, and comes down to the same difference as mapM versus mapM' above.
12:58:44 <sohum> haha, nifty!
12:59:18 <pjdelport> so if i'm not mistaken, you'd be able to say: mapM' f = mapM (unRev . f . Rev)
12:59:21 <pjdelport> and vice versa
13:00:17 <pjdelport> err, not that
13:00:19 <benzrf> pjdelport: i think you mean
13:00:25 <benzrf> unRev . mapM f . Rev
13:01:13 <pjdelport> Actually unRev . mapM (Rev . f), isn't it?
13:05:45 * hackagebot hakaru 0.1.2 - A probabilistic programming embedded DSL  http://hackage.haskell.org/package/hakaru-0.1.2 (z)
13:31:47 <eacameron> Cale: so your suggestion of liftM2 (||) works great. So Monad already does the wrapping for me so I don't need to define my own
13:32:40 <eacameron> how then did they make (-> b) an instance of Monad? since I can't seem to do that
13:33:05 <Cale> They didn't
13:33:09 <Cale> The instance is for (->) e
13:33:16 <Cale> i.e. (e ->)
13:33:23 <Cale> (if that were valid syntax)
13:33:33 <glguy> instance Monad ((->) r) where
13:33:33 <glguy>     return = const
13:33:33 <glguy>     f >>= k = \ r -> k (f r) r
13:33:38 <glguy> http://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-Base.html#Monad ^_^
13:34:11 <eacameron> ahhh, so the RHS of the function is left for me to parameterize
13:34:34 <Cale> In this monad, "executing" a function means applying it to the parameter to which the overall function has been applied
13:34:51 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
13:34:52 <lambdabot>  ("hello","olleh","HELLO")
13:35:47 * hackagebot highlighting-kate 0.5.8.4 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.8.4 (JohnMacFarlane)
13:36:26 <Cale> So, x >>= f, when executed, first executes the function x, then applies f to the result, getting another function which it then executes, that is: (x >>= f) e = let v = x e in (f v) e
13:36:46 <Tjr> Cale: shouldn't \x -> ( (->) x e) be an instance of some kind of contramonad?
13:36:48 <Cale> Or, removing the let,  (x >>= f) e = f (x e) e
13:37:24 <Cale> Tjr: It's a contravariant functor, but I don't know about anything monad-like
13:38:20 <Cale> There's probably some appropriate abstraction you could come up with
13:38:55 <tomqq> Cale: whats the significance of the the e on the end of "(x >>= f) e = f (x e) e"
13:39:09 <Cale> tomqq: It's a function parameter
13:39:18 <Cale> or argument, in the second case
13:39:37 <tomqq> i've never quite got this b4 :(
13:39:50 <Cale> We're defining a function (>>=)
13:39:54 <tomqq> in my head i'm thinking (x e) returns a value and f (x e) applies a function f to that
13:40:02 <Cale> yes, that's correct
13:40:09 <Cale> and f (x e) is itself a function
13:40:09 <tomqq> so why the extra e on the end?
13:40:11 <tomqq> :S
13:40:12 <Cale> which we apply to e
13:40:15 <tomqq> ohh
13:40:26 <tomqq> I see
13:40:30 <tomqq> derr :p
13:40:46 <tomqq> but wait.. why isn't (x e) the parameter?
13:40:57 <Cale> Let's look at the types
13:41:11 <Cale> (>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
13:41:18 <Cale> x :: e -> a
13:41:23 <Cale> f :: a -> e -> b
13:41:29 <Cale> x >>= f :: e -> b
13:41:34 <Cale> e :: e
13:41:42 <Cale> (x >>= f) e :: b
13:41:56 <Cale> x e :: a
13:42:03 <Cale> f (x e) :: e -> b
13:42:12 <Cale> f (x e) e :: b
13:42:41 <tomqq> so f (x e) leaves us with the last part of the signature (>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
13:42:50 <tomqq> and applying the last 'e' gives us b ?
13:42:54 <Cale> yeah
13:43:03 <Cale> Yeah, we could cancel an e from both sides of the equation if we liked
13:43:06 <tomqq> ooooh that's why i was so confused ;)
13:43:20 <Cale> except that we need e as a parameter
13:43:29 <Cale> in order to apply x to it
13:43:45 <tomqq> icic
13:43:48 <tomqq> very nice
13:44:12 <tomqq> i'm still a bit confused conceptually thinking about functions as monads, like Maybe and List etc fairly intuitive
13:44:25 <tomqq> like, how do you think about (>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b) ?
13:44:30 <Cale> Functions aren't monads, the type constructor (->) e is a monad
13:45:01 <Cale> Well, I think about it exactly as I explained earlier: executing a function means applying it to the parameter of type e
13:45:01 <jfischoff> @remember Cale Functions aren't monads, the type constructor (->) e is a monad
13:45:02 <lambdabot> I will remember.
13:45:21 <Cale> jfischoff: That's not even funny! :D
13:45:47 <jfischoff> :) people will spend a while trying to figure out where the joke is … and that is funny
13:46:01 <glguy> o_O
13:46:06 <tomqq> way over my head
13:46:19 <Cale> tomqq: If you can understand the example I gave before...
13:46:19 <jowens> Working on the (well-done!) NICTA functional programming course (by Tony Morris, Mark Hibberd); one of the problems is “convert a list of Maybes to an Maybe list”. If any of the Maybes are Nothing, then return a Nothing, otherwise return a Just list of the values. I think I can do the list conversion to the Maybe-list with a fold. But returning a Nothing list doesn’t seem to fit into the fold nicely. So I think the solution is that I have to look throug
13:46:20 <jowens> the list twice, the first time to see if there’s a Nothing, then the second time to do the fold. But if I can do it with one pass through the list, I would love to hear how.
13:46:25 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
13:46:26 <lambdabot>  ("hello","olleh","HELLO")
13:46:39 <Cale> ^^ have a look at that, and see if it clarifies the meaning of >>=
13:46:42 <jfischoff> tomqq: the quotes are aggerated into the Haskell Weekly News
13:47:13 <jfischoff> tomqq: and they are usually jokes
13:47:15 <tomqq> what is <- sugar for again ?
13:47:16 <Cale> tomqq: I was just being picky about terminology, btw
13:47:29 <Cale> tomqq: In the same way, Just 5 isn't a monad, Maybe is a monad
13:47:31 <tomqq> no no it was a good distinction imho
13:47:34 <Cale> getLine isn't a monad, IO is a monad
13:48:05 <Cale> do v <- x; <stmts> = x >>= (\v -> do <stmts>)
13:48:47 <Cale> do x; <stmts> = x >> do <stmts>
13:48:55 <glguy> ?type foldr (liftM2 (:)) (return []) :: [Maybe a] -> Maybe [a]
13:48:56 <Cale> do x = x -- base case
13:48:56 <lambdabot> [Maybe a] -> Maybe [a]
13:49:25 <Cale> do let { <decls> } ; <stmts> = let { <decls> } in do <stmts>
13:49:55 <tolt> :t sequence
13:49:55 <lambdabot> Monad m => [m a] -> m [a]
13:50:09 <tolt> :t Data.Traversable.Sequence
13:50:10 <lambdabot>     Not in scope: data constructor ‘Data.Traversable.Sequence’
13:50:11 <tomqq> i must have read lyahfgg 5 times now, is this normal ? or time to say kthxbye
13:50:14 <tolt> :t Data.Traversable.sequence
13:50:15 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
13:50:18 <tomqq> lol
13:50:24 <tolt> is what I would do if I were writing code.
13:50:29 <jowens> i understand there are nice high-level functions to do this, including sequence.
13:50:36 <glguy> tolt: sequence doesn't help here. the goal is to do it with a fold
13:50:43 <jowens> the tutorial, however, is more interested in having me *write* sequence rather than *use* sequence
13:50:46 <donri> well, sequence is a fold
13:50:48 <AleksejsHome> Hi, I'm trying to cabal install html-conduit, but it shows missing library zlib.h. I added extra dir but it doesn't help
13:50:54 <Cale> tomqq: I learned Haskell before it existed, but it took me about 2 months to get to the point where I felt I could do real things with Haskell and about a year to be "comfortable"
13:50:56 <jowens> and i’m trying to figure out how I should think about writing sequence.
13:51:05 <jowens> can i do it without two passes through the list?
13:51:13 <glguy> jowens: I pasted an example
13:51:34 <tomqq> Cale: v reassuring :) tbh i do scala at work and it's helped me a lot to understand the underlying ideas
13:51:38 <jowens> glguy: foldr + liftM2?
13:51:44 <Cale> jowens: It only requires one pass
13:51:46 <glguy> You're probably supposed to do it more explicitly than that, so it should just give you a nudge towards doing it
13:52:00 <Cale> jowens: Just write it as a recursive function. Use do-notation in the (x:xs) case.
13:52:01 <glguy> jowens: yeah, that code
13:52:08 <tolt> jowens: I know. Sorry. I just thought it would be useful to think of it that way.
13:52:18 <Cale> Well, if you want, I could give away the answer and explain the thought process
13:52:48 <donri> @src Maybe (>>=)
13:52:48 <lambdabot> (Just x) >>= k      = k x
13:52:48 <lambdabot> Nothing  >>= _      = Nothing
13:53:02 <donri> @src liftM2
13:53:03 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:53:04 <jowens> cale: i think, specifically, giving me a nudge towards how a fold could short-circuit to returning Nothing once it sees a Nothing would be the piece I’m missing.
13:53:25 <Cale> jowens: Oh, is this before you've been introduced to Maybe as a monad?
13:53:25 <donri> @. undo src liftM2
13:53:25 <lambdabot> liftM2 f m1 m2 = m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2);
13:53:46 <jowens> Cale: Yes, in the tutorial it’s “Optional” with “Full” and “Empty”. we haven’t got to monads yet.
13:53:48 <Cale> jowens: If you really want to use foldr, it's possible
13:53:50 <jowens> this is the first “assignment"
13:54:08 <jowens> i’ve been writing flatMap and flatten and filter, that sort of thing.
13:54:16 <jowens> then it takes a big step up to move to sequence. :)
13:54:20 <glguy> jowens: The function given to foldr takes two arguments. If you ignore the second argument then it "short circuits"
13:54:38 <Cale> jowens: ah, in that case, you should probably just use a case expression to match
13:54:44 <jowens> glguy: that sounds like the kind of nudge i need.
13:54:53 <Cale> @src foldr
13:54:53 <lambdabot> foldr f z []     = z
13:54:53 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:55:06 <Cale> ^^ you can see here that foldr in the recursive case immediately passes control to f
13:55:25 <Cale> only if f matches on its second parameter will foldr continue with the rest of the list
13:55:49 <Cale> (thinking in terms of lazy evaluation, being outermost first)
13:55:55 <Cale> @src foldl
13:55:55 <lambdabot> foldl f z []     = z
13:55:55 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:55:57 <donri> and remember that haskell is lazy (ish) so unused arguments to a function don't get evaluated
13:56:05 <jowens> Cale: OK, that’s the short-circuit, that when f doesn’t match x, I just return.
13:56:24 <Cale> ^^ foldl greedily passes control to itself until it reaches the end of the list
13:56:35 <jowens> stupid foldl. hate foldl.
13:57:05 <Cale> (while building up a potentially large expression in its second parameter)
13:58:28 <Cale> > foldr (\x y -> if x > 6 then x else y) 0 [1..]
13:58:30 <lambdabot>  7
13:58:34 <jowens> i’m on it. thanks team. (This is a very nice tutorial, btw. https://github.com/NICTA/course )
13:58:58 <Cale> > foldr (\x xs -> x : x : xs) [] [1..]
13:58:59 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
13:59:24 <Cale> > foldr (\x xs -> if even x then x : x : xs else xs) [] [1..]
13:59:25 <lambdabot>  [2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16,18,18,20,20,22,22,24,24,26,26,28,28...
14:01:36 <Peaker> > concatMap (replicate 2) [2,4..]
14:01:38 <lambdabot>  [2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16,18,18,20,20,22,22,24,24,26,26,28,28...
14:02:46 <Cale> Yeah, there are certainly nicer ways to write what I wrote, I'm just showing off the kinds of things foldr can do
14:04:32 <Peaker> Cale: haven't followed the conversation, just playing :)
14:05:31 <Criado> what are you trying to do?
14:07:20 <Cale> Criado: I was just demonstrating foldr's ability to work on infinite lists to jowens.
14:07:24 <Tjr> What determines the "safe haskell" status in the infobox on hackage?
14:07:47 <Cale> https://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html
14:08:21 <Algebr`> Why am I getting out of scope issues with my where block? http://lpaste.net/107564
14:08:23 <Criado> Cale: oh, thanks
14:09:24 <Cale> Algebr`: because birthYear isn't in scope
14:09:28 <michaelochurch> I have a performance-related question. I'm toying around with Haskell trying to get a sense of how to write fast Haskell code.
14:10:02 <michaelochurch> and I'm finding that tail-recursive loops, even with the bang pattern, aren't fast
14:10:08 <Tjr> Cale: thanks
14:10:18 <Cale> michaelochurch: Well, they can be. It depends on what the loop is doing of course.
14:10:20 <Algebr`> Cale: yes, that's what the error message says, but how could it not be in scope? how could the where clause not see it?
14:10:25 <tomqq> Cale: could you recommend a lightweight haskell web framework that's ez to get started with?
14:10:33 <michaelochurch> Cale: so here's an example
14:10:52 <Cale> Algebr`: The where clause can see parameters bound on the left hand of the = sign for the declaration it's attached to (which is none in this case)
14:10:59 <Tjr> When do you need the forall keyword even if it has global scope?
14:10:59 <Tjr> For example, in the signature of lowerNF, I'd say it's superfluous.
14:10:59 <Tjr> http://hackage.haskell.org/package/constrained-normal-1.0.2/docs/Control-Monad-ConstrainedNormal.html#t:Unconstrained
14:11:00 <michaelochurch> Cale: this is reasonably fast: foldl' (+) 0 100000000
14:11:05 <Cale> Algebr`: it can't see inside the lambdas
14:11:15 <Tjr> What is it that I'm not getting?
14:11:29 <michaelochurch> Cale: but if I write a triangleSum as a function that calls itself
14:12:06 <Cale> Tjr: When forall occurs like that in the type of a parameter to a function, it means that the thing you pass for that parameter *must* be polymorphic
14:12:36 <Cale> Tjr: i.e. as a caller, you are not allowed to choose the type x, the function you give as an argument to lowerNF must be polymorphic in the type x
14:13:03 <michaelochurch> Cale: like this: http://pastebin.com/YGfhzRzk ... it ends up being slow.
14:13:03 <jle`> tail recursion isnt really a thing or doesnt give meaningful performance boosts, i think. it at least does not work the same way as in other languages; your function isnt evaluated on a call stack.
14:13:41 <Cale> michaelochurch: The bang parameter on n is superfluous
14:13:46 <Algebr`> Cale: But if I did a let in, then that would work?
14:13:50 <Cale> But other than that, I'm not sure why that would be slow.
14:14:00 <Cale> michaelochurch: Are you compiling with -O2?
14:14:12 <michaelochurch> Cale: both examples are at ghci
14:14:14 <Cale> michaelochurch: If you're not compiling with optimisations, performance results are pretty meaningless
14:14:22 <michaelochurch> Cale: OK, got it.
14:14:47 <Cale> (things will be randomly much slower than they would be with optimisations turned on)
14:15:05 <Tjr> Cale: ok, I think I tripped up on the quantor scope. moving the forall outside the parentheses should give a different signatur than lowerNF has right now, shouldn't it?
14:15:17 <Cale> Tjr: yes
14:15:46 <michaelochurch> Cale: OK. Yeah, it's fast with -O2
14:15:49 <Cale> Tjr: All type variables which aren't explicitly quantified in a type signature are implicitly forall'ed at the top level
14:16:00 <michaelochurch> Cale: so the lesson is... don't trust performance in ghci?
14:16:10 <Cale> Tjr: e.g.  length :: [a] -> Int  means  length :: forall a. [a] -> Int
14:16:13 <Cale> michaelochurch: yeah
14:16:14 <michaelochurch> Cale: (I'm probably spoiled by Clojure which has rather accurate REPL performance.)
14:16:19 <Cale> michaelochurch: especially for microbenchmarks
14:16:22 <michaelochurch> Cale: Great. Thanks so much! -O2 makes it fast.
14:16:48 <Tjr> regarding -O2  --- if O2 doesn't break anything, then why isn't it the default (or the only possible setting)?
14:16:52 <Cale> michaelochurch: GHCi will compile to bytecode and execute that, which makes compilation relatively cheap, but won't perform well
14:17:10 <michaelochurch> Cale: that's similar to my experience in Ocaml
14:17:12 <Cale> Tjr: because it takes longer. Also, it is the default if you have a cabal project.
14:17:32 <michaelochurch> Cale: what about higher optimization levels?
14:17:43 <michaelochurch> Cale: what is the meaning of O1 vs O2 vs O3 etc?
14:17:59 * Tjr can't help but think of oxygen and ozone
14:19:39 <dfarm> Hey all, I was looking for some advice on interacting with SQL servers with Haskell. The bad news is this is on Windows talking to SQL Server which I think pretty well limits me. I got HDBC-ODBC working, but it's kind of annoying (everything in IO) So I figured I'd just check on alternatives before I dive fully in.
14:20:12 <geekosaur> O3 and higher don't exist, for one. For details: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html#optimise-pkgs
14:20:30 <michaelochurch> geekosaur: thanks!
14:20:46 <geekosaur> although all it tells you is to use -v to see what it does
14:23:30 <AleksejsHome> how do I solve an error: "Couldn't match expected type `Data.Text.Internal.Text' with actual type `String'"
14:23:44 <Clint> use the correct type
14:23:52 <_jrp_> enable OverloadedStrings
14:24:14 <AleksejsHome> it's enabled
14:26:45 <_jrp_> use Text.pack on the string
14:30:53 * hackagebot yesod-auth-bcrypt 0.1.1 - BCrypt salted and hashed passwords in a database as auth for yesod  http://hackage.haskell.org/package/yesod-auth-bcrypt-0.1.1 (TobyGoodwin)
14:31:33 <AleksejsHome> _jrp_ I needed unpack, but thanks for the hint :)
14:49:07 <Peaker> setNumCapabilities requires an Int. What can I give it to simulate "-N" with no int argument?
14:49:38 <Peaker> oh there's getNumProcessors
14:54:04 <johnw> yeah
14:55:42 <Peaker> Requiring -threaded AND +RTS -N is almost a guarantee that people will scratch their heads plentifully about why their parallelism/threads isn't bringing any speedups :)
14:55:48 <Peaker> both should probably be the default?
14:56:55 <enthropy> there's -rtsopts I think
14:58:20 <geekosaur> -with-rtsopts actually
14:58:36 <geekosaur> -rtsopts just enables "unsafe" runtime specified options
15:01:49 <Qfwfq> Is it possible to construct promoted datatypes using TH?
15:08:57 <Qfwfq> (I have a function Int -> Q Exp ~ 3 -> "S(S(S Z))", but want a type-level version of the result ~~ "('S('S('S 'Z)))" instead.)
15:11:17 <tac-tics> Can someone give me a tl;dr of FlexibleInstances?
15:11:26 <tac-tics> (And is it an 'evil' extension?)
15:12:08 <phaazon> arf, is there a way to know how many bytes a ByteString takes?
15:12:11 <phaazon> length it?
15:13:09 <phaazon> I’m generating the bytestring with Crypto.Hash.SHA3.hash (512)
15:13:16 <phaazon> sounds to be 64b
15:15:26 <dfarm> tac-tics: FlexibleInstances makes the compiler consider more typeclass instances as legal than the Haskell 98 standard allows. FlexibleInstances is widely used and often safe. Cite: http://www.scs.stanford.edu/14sp-cs240h/slides/phantoms.html Ref: http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/type-class-extensions.html#instance-rules and
15:15:41 <tac-tics> ah thanks
15:15:57 * hackagebot network-carbon 1.0.0 - A Haskell implementation of the Carbon protocol (part of the Graphite monitoring tools)  http://hackage.haskell.org/package/network-carbon-1.0.0 (OliverCharles)
15:15:59 * hackagebot ekg-carbon 1.0.0 - An EKG backend to send statistics to Carbon (part of Graphite monitoring tools)  http://hackage.haskell.org/package/ekg-carbon-1.0.0 (OliverCharles)
15:16:24 <dfarm> (I cite it since I'm a newbie myself, so I've got to go with the Appeal to O'Sullivan rule)
15:19:09 <dspies> How can I join two modules together to avoid an orphan instance warning? (I really would like to put the instances in the same module as the class definition, but template-haskell won't allow me)
15:22:38 <Peaker> dspies: TH just requires you define everything in a bottom-up manner
15:24:19 <dspies> Peaker: Ok, but I have a whole bunch of types whose instance definitions for a particular class are identical.  I want to define the instances for all these types.  I'd think this would be a pretty common-use case for TH
15:24:41 <Peaker> what do these instances look like?
15:24:50 <dspies> Peaker: one sec
15:28:39 <dspies> Peaker: http://lpaste.net/107574
15:29:56 <Peaker> dspies: why can't you have non-TH: instance Num (Exp a) ... ?
15:30:04 <Peaker> dspies: why can't you be parametric on the "a"?
15:30:16 <dspies> Peaker: because then people won't be able to define their own types with different implementations
15:30:25 <dspies> Peaker: at least not without OverloadedInstances
15:31:01 <dspies> Peaker: Actually even with OverloadedInstances I'm not sure it's possible
15:31:05 <Peaker> dspies: why would they want to define an instance different from this one?
15:31:18 <Peaker> (why can't they newtype Exp instead?)
15:31:36 <dspies> Peaker: That's the whole reason I'm creating a wrapper for Exp, so that it's easy to create types that can be wrapped in it
15:33:19 <dspies> Peaker: Also, this implementation only works if TRepr a ~ a, so creating a general instance for Num (Exp a) requires undecidable instances
15:33:50 <tac-tics> toList for Data.Map preserves the order the elements were added, right?
15:33:52 <tac-tics> (or does it not?)
15:34:23 <dspies> tac-tics: Data.Map is ordered according to the "Ord" ordering of its keys
15:34:27 <kazagistar> tac-tics: no, it does not at all
15:34:35 <tac-tics> doops
15:34:38 <tac-tics> thanks
15:34:43 <kazagistar> tac-tics: it might, at most, be stable?
15:35:07 <tac-tics> I can do better, I'm sure, if I just replace it by a list of key-value pairs to begin with
15:35:15 <Peaker> dspies: Using TH like that seems quite hacky to me.. Not sure I understand the entire problem you're solving, so I might be wrong
15:35:29 <dspies> Peaker: How else should I do it then?
15:36:47 <Peaker> dspies: Using UndecidableInstances sounds less hacky (even if scary, it is just compile-time undecidability, so not that problematic :) )
15:37:29 <dspies> Peaker: But that still means I can't later go and define my own type WonkyInt and create a new instance for Exp WonkyInt
15:37:57 <dspies> Peaker: It would defeat the whole reason I'm creating my own Exp wrapper in the first place
15:38:13 <dspies> Peaker: I mean Num (Exp WonkyInt)
15:39:17 <rwbarton> dspies: you could make Exp, liftAccel1, liftAccel2 into function parameters of instNum and define it in a different module
15:39:54 <dspies> rwbarton: That's a good idea, but then the template instantiation code would be pretty bloated, wouldn't it?
15:40:17 <dspies> rwbarton: I'm using templates to reduce code repitition after all
15:40:59 * hackagebot QuickCheck 2.7.6 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.7.6 (NickSmallbone)
15:41:06 <rwbarton> then you respecialize once in this module
15:41:18 <dspies> rwbarton: respecialize?
15:41:24 <rwbarton> call the function
15:41:59 <willbuntu> I don't fully understand why/how the "canonical zipWith implementation" of the infinite-list Fibonacci sequence works. I get that 0 : 1 defines it initially as [0,1], but I keep going over the zipWith call in my head, and it seems to me like the zipWith ought to odd things.
15:42:00 <dspies> rwbarton: I think I need to see an example
15:42:00 <rwbarton> specifying all those parameters that never change
15:42:29 <willbuntu> (http://lpaste.net/107575)
15:43:09 <dspies> rwbarton: Oh wait, I think I get it
15:43:13 <willbuntu> My question is: when I do take 3 fibs, why doesn't the list end up being [1,2,3]?
15:43:35 <phaazon> dammit HDBC!
15:43:37 <phaazon> *** Exception: SqlError {seState = "", seNativeError = 26, seErrorMsg = "prepare 44: CREATE TABLE test (id INTEGER PRIMARY\160KEY): file is encrypted or is not a database"}
15:44:11 <mmmm> Does a foldrM make sense?
15:44:29 <dfeuer> willbuntu, what do you mean?
15:45:42 <tolt_> mmmm: Why not just use foldr where the a is some (m b) and then sequence it?
15:45:58 <tolt_> actually, I guess if you just wanted it to be foldable.
15:47:31 <mmmm> hmm yes
15:47:35 <willbuntu> dfeuer: As in, if [0,1], which is how the list is initially defined before its recursive definition, *is* fibs in the very first zipWith call (which would be precipitated upon doing take 3 fibs), why doesn't taking the third element add the tail of [0,1] (that is, 1) to all elements currently, making the list [1,2] temporarily, then... actually, I don't even know why there should be more elements generating if I do take n fibs whe
15:50:15 <dfeuer> willbyntu, the list is not ever defined to be [0,1].
15:50:22 <dfeuer> There is no temporarily.
15:50:26 <mmmm> What is the difference between seq and deepseq?
15:51:14 <Exio> i find the definition based on the "offset" gave by tails, you end doing the first plus the second, (to get a third), then the second plus the third ...
15:51:19 <Exio> tail*
15:51:40 <dspies> rwbarton: Doesn't work, it says exactly the same thing about the "respecialized" function, that I have to have it in a different module
15:52:07 <dfeuer> The equation is fibs = 0 : 1 : zipWith (+) fibs (tail fibs), right? That means "fibs is a list that starts with 0, and whose second element is 1, such that everything *after* that is zipWith (+) fibs (tail fibs) "
15:52:24 <xenocons> in haskell world, what name do you give a function that is Just (f x) where Exception = Nothing? in a generalised sense
15:52:57 <dfeuer> Fibs can't be [0,1,2] or [1,2,3] *because those lists don't satisfy the equation*.
15:53:00 <xenocons> f : (a -> b) -> a -> b option
15:53:19 <dfeuer> xenocons, you may want to look at the Error monad.
15:53:27 <mwhit> mmm: seq will only evaluate the top level of a nested data structure. deepseq will force evaluation of the entire tree
15:53:36 <xenocons> dfeuer: hmm ok
15:53:42 <enthropy> @hackage spoon
15:53:42 <lambdabot> http://hackage.haskell.org/package/spoon
15:53:45 <mmmm> mwhit: Not level meaning?
15:53:47 <mmmm> *top
15:54:46 <enthropy> xenocons: that package might be relevant (if you're actually after catching exceptions from "pure" code)
15:55:17 <xenocons> enthropy: esseentially, im rewriting stuff i feel is haskelly in another language and looking for a consistent naming convention for my abstractions ;p
15:55:20 <mwhit> mmm: meaning (Cons 1 (Cons undefined (Nil)) `seq` True evalutes just fine, but the deepseq version will not
15:55:31 <mwhit> mmm: because seq only evaluates the top-level cons constructor
15:55:35 <xenocons> also confirmation of existence of abstractions in haskell usually means im not crazy and creating pointless abstractions :P
15:55:43 <mmmm> so foldr is strict in the seq sense?
15:55:53 <xenocons> i have it named `either` at the moment
15:56:01 <mwhit> mmm: it's not strict but it uses every value of the foldable structure
15:56:05 <mwhit> mmm: which forces evaluation
15:56:33 <mwhit> mmm: basically, depends on what the function you're folding does with the values of the foldable
15:58:24 <dfeuer> Foldr is strict in the outermost (first) constructor, and in the function being folded in, and sometimes in the starting value.
15:59:00 <dfeuer> Er..
15:59:09 <dfeuer> Sorry,  not even that last.
15:59:33 <ReinH> @src foldr
15:59:33 <lambdabot> foldr f z []     = z
15:59:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:59:39 <dspies> Peaker, rwbarton: I think I'll figure out how to do this with OverloadedInstances instead
16:00:00 <mmmm> is there anything wrong with deepseq? Is using it indicative of other problems
16:00:07 <dfeuer> > foldr (\a b -> (0::Int)) undefined [undefined]
16:00:09 <lambdabot>  can't find file: L.hs
16:00:21 <mmmm> I'm using it in a strict version of foldM
16:00:22 <dfeuer> > foldr (\a b -> (0::Int)) undefined [undefined]
16:00:25 <lambdabot>  0
16:00:33 <dspies> Peaker, rwbarton: Although I don't really see the point of TemplateHaskell if it can't be used to eliminate instance-boilerplate
16:02:20 <phaazon> woh, for the very first time, I think I need something different for my Setup.hs!
16:02:37 <phaazon> I’d need to run some of my code, in order to initiate a database (Sqlite3) using HDBC
16:02:45 <phaazon> do I have to use some kind of hooks ? :)
16:02:47 <ReinH> mmmm: deepseq is a lot like cleaning a stuck drain with a stick of dynamite
16:02:50 <phaazon> like defaultMainWithHooks?
16:03:03 <ReinH> Sure, it works, but there are probably less severe alternatives.
16:03:47 <Axman6> it feels like something the compiler/rts could do for you more efficiently
16:04:45 <dfeuer> Deepseq is a bit of a big hammer. It's also expensive if the structure is large. It's also awkward. You may want to use an inherently strict structure instead.
16:05:54 <willbuntu> Then is there any resource that can walk me through what is physically happening in terms of function calls and additions to the list when I call take n on fibs? Like the diagrams of some recursive functions/definitions on Learn You a Haskell.
16:06:09 <ReinH> willbuntu: sure
16:06:11 <ReinH> how is fibs defined?
16:06:15 <dspies> Can't use OverlappingInstances when the class includes a type-family
16:06:19 <dspies> Now what
16:06:27 <willbuntu> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
16:06:33 <mmmm> thanks ReinH
16:07:14 <ReinH> @src fibs
16:07:14 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:07:16 <ReinH> er
16:07:18 <ReinH> @src zipWith
16:07:18 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
16:07:18 <lambdabot> zipWith _ _      _      = []
16:07:43 <pjdelport> willbuntu: Try visualizing an arrow that points from the second-last 'fibs' to the 0, and another one from the (tail fibs) to the 1.
16:08:24 <kazagistar> yeah, the more I learn haskell, the less using deepseq ever seems like a good idea
16:08:30 <ReinH> so...
16:08:36 <pjdelport> willbuntu: Every time that zipWith is "stepped", both it and the arrows are advanced forward in the list by one.
16:08:46 <ReinH> > let fibs = 0 : 1 : zip fibs (tail fibs) in take 10 fibs
16:08:47 <lambdabot>  Occurs check: cannot construct the infinite type: a1 ~ (a1, b1)
16:08:47 <lambdabot>  Expected type: [a1]
16:08:47 <lambdabot>    Actual type: [(a1, b1)]
16:08:47 <lambdabot>  Relevant bindings include
16:08:47 <lambdabot>    fibs :: [(a1, b1)] (bound at <interactive>:1:5)Occurs check: cannot constr...
16:08:59 <AleksejsHome> let fibs = 0 : Prelude.scanl (+) 1 fibs
16:08:59 <ReinH> woops
16:09:05 <ReinH> that too
16:09:18 <AleksejsHome> > let fibs = 0 : scanl (+) 1 fibs in take 10 fibs
16:09:19 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
16:09:44 <ReinH> So zipWith is constructing a list from two lists by zipping them with the provided function to combine elements
16:09:54 <pjdelport> willbuntu: So after the first step, you have: fibs = 0 : 1 : (0 + 1) : zipWith (+) ...
16:09:55 <pjdelport> or: fibs = 0 : 1 : 1 : zipWith (+) ...
16:09:55 <pjdelport> with zipWith now referencing the two 1 values right before it.
16:10:40 <pjdelport> Then: fibs = 0 : 1 : 1 : 2 : zipWith (+) ...
16:10:40 <pjdelport> with zipWith now referencing 1 and 2.
16:10:45 <dspies> huh, seems Templates don't work with type families either
16:10:46 <pjdelport> And so forth.
16:11:06 <dspies> well now I'm out of ideas.  The only thing left is to enumerate all the instances with copy-paste
16:12:35 <tulcod> in template haskell, if i do something like  runQ [d|fun x = 2|], then it gives me all kinds of fun_0 stuff. what if i just want it to use the literal name "fun"?
16:13:22 <ReinH> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 5 fibs :: [Expr]
16:13:23 <lambdabot>  [0,1,0 + 1,1 + (0 + 1),0 + 1 + (1 + (0 + 1))]
16:14:55 <luite_> ReinH: improve lambdabot by letting it show sharing for Expr!
16:15:06 <ReinH> luite_: ok! how?
16:16:36 <mmmm> Does annotating a field of a data structure to be strict only make it strict in the seq sense?
16:17:29 <luite_> ReinH: attaching a StableName to each Expr after forcing them should make the sharing observable, problem is still printing it nicely
16:17:40 <ReinH> luite_: hmm
16:17:41 <johnw> mmmm: I believe so
16:17:59 <johnw> mmmm: if you case analyze that constructor, it will evaluate that field to WHNF
16:18:30 <johnw> so I think it's like, foo (Foo b) = b `seq` ...
16:18:42 <johnw> where Foo { someField :: !SomeType }
16:19:01 <johnw> aka, foo (Foo !b) = ...
16:19:11 <mmmm> johnw: thanks
16:19:42 <mmmm> Is there a blog post anywhere about how to find where your space leak is?
16:20:22 <dspies> What are each of the arguments to tySynInstD : (http://hackage.haskell.org/package/template-haskell-2.5.0.0/docs/Language-Haskell-TH.html#g:20)
16:20:25 <levi> I recall having seen blog posts like that, but I'm not sure where exactly.
16:20:26 <dspies> ?
16:20:30 <luite_> johnw: hmm, I would say constructing that thing forces b. Of course it's always something forcing that construction
16:21:02 * hackagebot graph-core 0.2.0.0 - Fast, memory efficient and persistent graph implementation  http://hackage.haskell.org/package/graph-core-0.2.0.0 (AlexanderThiemann)
16:21:32 <luite_> johnw: but if you say pattern matching, then it's less clear that for foo :: Foo, foo `seq` somethingElse also forces that field
16:22:29 <levi> dspies: Sorry, I was replying to mmmm. I don't know much about TH.
16:24:29 <johnw> luite_: but it won't force it until the value return from 'foo' is forced, right?
16:24:36 <johnw> i mean, just calling foo is not enough to force anything
16:26:41 <luite_> johnw: oh sorry i was using a different foo, some thunk of the Foo type
16:28:10 <johnw> has anyone else experienced use of haskeline in a transformer stack (InputT) causing memory to be exhausted by GHC?
16:28:17 <johnw> my compilation process gets above 12GB and then the OOM killer takes it out
16:28:27 <johnw> disabling haskeline, it compiles fine
16:29:42 <luite_> hmm, haven't seen it. which part of the compilation pipeline consumes so much memory?
16:29:49 <johnw> that I don't know
16:29:55 <johnw> I just see the process 'ghc' climb toward the sky
16:30:23 <raphie__> does anyone know of a "fiddle" type website where I could edit haskell code and use a REPL side-by-side?
16:30:36 <luite_> johnw: try increasing the verbosity
16:30:36 <johnw> tryhaskell.org?
16:30:38 <raphie__> I'm going to be teaching a quick class on haskell for my coworkers, and it'd be a pain for all of them to have to install it
16:31:31 <spott> So, I have a type signature of "CSparseRow ord val -> ord -> U.Vector val" for some function (CSparseRow is my type).
16:31:59 <spott> and in the function, I'm creating a U.Vector that I want to be of type "U.Vector val".
16:32:42 <spott> currently I'm doing it with "let vec = U.replicate c 0", but I don't know how to constrain 0 to type "val"
16:32:48 <spott> how would I do that?
16:32:58 <luite_> raphie__: there's also codeworld.info, which is fun for experimenting, but it's aimed at children and tries to simplify haskell a bit
16:33:32 <raphie__> johnw: the problem with tryhaskell is that it doesn't give you an editor AND a repl
16:33:47 <johnw> fpcomplete.com gives you an editor, but no repl
16:35:03 <luite_> unfortunately i haven't written a ghcjs repl yet, since that would make it much easier to add one to a site
16:36:50 <spott> anyone have any ideas how to constrain a value to a type?
16:41:36 <willbuntu> The way lambdabot did it helped very much, thank you.
16:43:35 <mwhit> spott: what do you mean, exactly? as long as val is an instance of Num, GHC will infer that type for you.
16:44:09 <suOya_> I'm following the oft recommended Monad Transformers PDF and I'm wondering if it's a bit outdated. Not just to mention we have ExceptT instead of ErrorT nowadays, but the paper tells you that invoking a Maybe-value inside a monad will call the monad's fail-function if it returns Nothing, which doesn't seem to be the case
16:46:21 <spott> I have a complicated function of the above type.  said function has a "let vec = U.replicate c 0 in U.update_ vec (part (colIndexes m)) (part (values m))" (where c, and part are defined in a "where" statement is elsewhere defined).
16:46:47 <spott> the problem is, when I attempt to compile it, it assumes that U.replicate c 0 has type Int
16:46:53 <spott> not type val
16:49:15 <mwhit> well, if you're trying to make a vector of 0s, that must mean you believe val to be an instance of Num, correct?
16:49:20 <mwhit> so just add a num constraint to the type signature
16:50:56 <spott> yea, I think I found part of the problem.  val should be an instance of Num, while ord should be more constrained (Integers? Int? what is more general?)
16:51:07 <mwhit> if you don't have that constraint, there's no way for GHC to know that 0 is a valid value of type :: val, so it will default to Int
16:51:23 <mwhit> integer is arbitrary-sized int
16:51:35 <mwhit> so unless you need huge ords (unlikely), then int
16:52:31 <mwhit> but i don't know your use case
16:55:01 <spott> so, where should I put the constraint?  logically, it should be in the data type:  every function that deals with the data type must have this constraint... but I need an extension to add a constraint to the data type?
16:56:28 <spott> so, I should put it in every function instead?
16:56:38 <spott> that seems... off
16:57:09 <mwhit> spott: that is one option. but don't shy away from language extensions. There are many extremely useful ones that are widely used
16:57:16 <mwhit> in this case GADTs can probably do what you want
16:57:21 <mwhit> see 7.4.7 here: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt-style
17:06:25 <yorick> how do I get to an m IO x context from an m (ActionT IO) x? basically want a lift, but further down the stack
17:06:26 <a__surf__> YORICK!!!! ca va???
17:06:26 <HugoDaniel> return . return . return . return . return . return . return . return . return . return . return . return . return . return . return . return
17:06:26 <yorick> a__surf__: I don't think I know you
17:06:26 <a__surf__> je savais pas que t'etait un haskeller !!
17:06:26 <a__surf__> yorick: t'es de biarritz?
17:06:26 <yorick> non
17:06:26 <a__surf__> oh sorry..
17:06:26 <a__surf__> another yorick..
17:06:26 <a__surf__> i didn't know there was more than one yorick
17:06:27 <yorick> it's a name from Shakespeare
17:06:27 <a__surf__> Oh.. sorry pardon my ignorance :)
17:08:19 <a__surf__> I have a silly question, after reading the cabal 'user documentation'
17:09:10 <a__surf__> i see that hackage is the 'default remote repository' and so on, but how do I translate names of packags from Hackage (e.g., Data.Digest.Pure.MD5) to command line 'cabal install' names?
17:10:09 <a__surf__> if I do 'cabal install Data.Digest.Pure.MD5' it throws a cannot find module, but does the hackage page not show the command line equivalent?
17:11:32 <sshine_> only GADTs allow typeclasses in data type definitions, right?
17:11:34 <yorick> it's on the top left
17:11:38 <yorick> so pureMD5
17:12:33 <ReinH> That's the name of a module. The package name is listed at the top left and on the contents page: http://hackage.haskell.org/package/pureMD5-0.2.4
17:13:03 <mwhit> sshine_: yeah. well, they're ALLOWED without them, but it won't do what you want it to except with GADTs
17:13:47 <sshine> mwhit, what do they do without GADTs? e.g. data Set a = Eq a => [a] -> Set a
17:14:13 <sshine> err, data Set a = Eq a => Set [a]
17:14:16 <mwhit> basically it means every function that references a Set a now HAS to have an Eq a constraint, i think
17:14:21 <mwhit> rather than GIVING you one
17:14:57 <mwhit> see the doc i just linked above
17:14:59 <mwhit>   where filter' a' = views (filter . runFilter a') n
17:14:59 <mwhit>         activator' a' = n ^. activator . runActivator a'
17:15:01 <mwhit> oops
17:15:01 <a__surf__> ReinH: thanks!
17:15:04 <a__surf__> yorick: thanks!
17:15:11 <mwhit> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt-style
17:15:14 <mwhit> 7.4.7
17:15:17 <sshine> mwhit, thanks.
17:15:42 <asfp``> what is the best/simplest option for two haskell OS processes to communicate on a single host?
17:18:05 <sshine> asfp``, there's http://book.realworldhaskell.org/read/software-transactional-memory.html , but I assume your two Haskell OS processes didn't spawn one another.
17:19:37 <shlevy> What's a good library for representing files as streams?
17:19:46 <shlevy> (of bytestrings)
17:20:20 <sshine> shlevy, io-streams?
17:20:31 <bitemyapp> shlevy: conduit?
17:20:39 <shlevy> :D
17:20:59 <shlevy> also I see pipes
17:21:01 <sshine> bitemyapp, io-streams vs. conduit?
17:21:12 <johnw> also simple-conduit
17:21:16 <sshine> oh my.
17:21:19 <johnw> if what you need to do is not complex
17:21:26 <johnw> simple-conduit has the simplest type, and is fast
17:21:44 <johnw> but it doesn't support fine-grained control of exceptions, or "put backs"
17:21:50 <asfp``> sshine: I'm looking for some IPC, haskell-style between OS processes, not internal to a single process
17:21:50 <johnw> however, it supports pretty much everything else
17:21:54 <shlevy> johnw: Need to be able to stream a file in, calculate its hash, and stream it out to another file
17:22:06 <johnw> simple-conduit would do that easily, so would conduit
17:22:11 <johnw> for the latter, the hashing stuff is already there
17:22:13 <shlevy> johnw: And ideally easily wrap a fixed string in the same interface
17:22:17 <bitemyapp> sshine: I'm going to second simple-conduit.
17:22:35 <johnw> http://hackage.haskell.org/package/cryptohash-conduit-0.1.1/docs/Crypto-Hash-Conduit.html
17:22:55 <shlevy> johnw: nice :)
17:23:11 <shlevy> johnw: Is there a "tee" for conduits?
17:23:16 <johnw> yes
17:23:25 <shlevy> so I guess that's what I'm using
17:23:26 <johnw> one sec, i'll find the name
17:23:47 <johnw> use 'passthroughSink' with conduit
17:26:03 <shlevy> johnw: sinkHash is a Consumer, not a Sink...
17:26:16 <johnw> all Sinks are Consumers
17:26:21 <johnw> Consumer is just an abstraction
17:26:38 <GeraldCode> Are there any intermediate level texts in the LEarnYouAHAskell style?
17:26:48 <johnw> an abstraction happily not needed by simple-conduit :)  but I don't have as many 3rd-party libraries yet
17:26:53 <shlevy> johnw: But are all Consumers Sinks?
17:26:56 <johnw> no
17:26:59 <hpc> GeraldCode: that would be the last few chapters of LYAH :P
17:27:00 <johnw> Conduits are also Consumers
17:27:08 <shlevy> johnw: Maybe I'll check out simple-conduit
17:27:16 <GeraldCode> ah ok, hpc
17:27:17 <hpc> after that you're into learning specific topics one at a time
17:27:25 <shlevy> Writing a simple thing to stream stuff to a hash function should be easy
17:27:28 <GeraldCode> I guess im at that point then.
17:27:43 <johnw> in simple-conduit, you'd say: sinkFile "foo" $ computeHashHere $ sourceFile "bar"
17:27:44 <shlevy> And I really don't need put backs
17:27:54 <johnw> where computeHashHere would look something like:
17:28:22 <johnw> computeHashHere = conduit $ \r yield x -> compute hash combining r with x, then yield it
17:28:59 <shlevy> I'll play around, thanks :)
17:29:11 <johnw> sure, ask me questions if you have any, you might be my first real user :)
17:29:46 <shlevy> johnw: https://hackage.haskell.org/package/simple-conduit-0.4.0 no haddock?
17:29:55 <johnw> yes
17:29:58 <johnw> the haddock broke for some reason
17:30:20 <shlevy> does it work locally?
17:30:29 <johnw> haven't tried it actually
17:30:35 <shlevy> OK I'll check
17:30:42 <shlevy> (and add it to nixpkgs ;))
17:30:43 <sshine> shlevy, https://hackage.haskell.org/package/simple-conduit-0.3.0/docs/Conduit-Simple.html works, but is for 0.3.0
17:36:17 <johnw> in fact, you'll probably ignore 'r' entirely
17:36:25 <johnw> just pass it through: yield r <hash>
17:36:35 <johnw> or you may need to use it to compute the hash
17:36:59 <johnw> if you get most of the way with the code, send it to me and I'll finish it if you run into problems
17:37:07 <johnw> I'd like to have hashing support
17:37:14 <shlevy> Sure
17:37:19 <johnw> actually, I can probably just port the code in that stuff I linked to you, one sec
17:37:28 <johnw> ah, of course
17:37:34 <johnw> we wouldn't do this as a conduit, but as a sink
17:43:54 <shlevy> johnw: yup, haddock works locally
17:44:07 <johnw> odd
17:44:16 <johnw> one sec, porting that code
17:44:22 <jtakacs> hi
17:44:48 <johnw> shelvy: how do I tell Nix to ignore .hdevtools.sock files?
17:45:45 <GeraldCode> Per my earlier question about tutorials like LYAH, I did find this..if anyone cares: http://www.muitovar.com/monad/moncow.xhtml#sec4
17:45:45 <shlevy> johnw: src = builtins.filterSource (path: type: type != "unknown") ./.
17:45:49 <jtakacs> how can I declare top level constants?  I have magicNumber=0x42::Word8 at the top of my code, but I get this warning from ghc: Top-level binding with no type signature: magicNumber :: Word8
17:46:04 <johnw> shlevy: can I have that happen universally for all projects from my config.nix?
17:46:06 <GeraldCode> and this: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
17:46:10 * hackagebot iproute 1.3.0 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.3.0 (KazuYamamoto)
17:46:12 <GeraldCode> both funny, and easy to follow
17:46:12 <shlevy> johnw: filterSource builtin is documented in http://nixos.org/nix/manual/#ssec-builtins
17:46:31 <mwhit> jtakacs: that works just fine, it's only a warning. to get rid of the warning, just add the type signature it suggests
17:46:37 <shlevy> johnw: You might be able to override cabal.mkDerivation to map that over src
17:46:41 <shlevy> johnw: not sure though
17:46:47 <johnw> eww, that would rebuild the world though
17:46:49 <mwhit> jtakacs: it's just generally good practice to have explicit type signatures for all type-level definitions
17:46:53 <shlevy> johnw: nope
17:46:59 <mwhit> *top-level
17:47:00 <johnw> no?
17:47:04 <shlevy> johnw: if there is no such file it will be the same src
17:47:08 <jtakacs> I suspect, I just created a function with the name magicNumber, that always returns 0x42
17:47:10 <shlevy> johnw: if there is, it wouldn't have built before
17:47:31 <shlevy> You may need to do something like "if builtins.typeOf src == "path" then builtins.filterSource ... else src"
17:47:51 <mwhit> jtakacs: in haskell there's not really any difference between a constant and a 0-argument function
17:48:26 <mwhit> or rather there's no good definition of it
17:48:49 <jtakacs> is there a way to create a real constant, and if so, is there a difference when it's compiled to machine code?
17:51:03 <jtakacs> I'd rather omit the extra function call if possible
17:51:10 * hackagebot unix-time 0.3.2 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.3.2 (KazuYamamoto)
17:53:27 <Cale> jtakacs: Functions are values with types of the form a -> b for some types a and b
17:53:42 <shlevy> johnw: So if the hashing function takes bytestrings, I want my function to take  (MonadBaseControl IO m, MonadIO m) => Source ByteString m, right?
17:53:51 <Cale> jtakacs: If your value has type Integer, it is not a function.
17:54:04 <shlevy> johnw: erm, reverse the order
17:54:23 <Cale> jtakacs: If you want to avoid that warning, you should separate the type signature
17:54:30 <Cale> magicNumber :: Word8
17:54:33 <sshine> jtakacs, just explicate your value to any concrete type (Int, Integer, etc.)
17:54:36 <Cale> magicNumber = 0x42
17:54:47 <johnw> shlevy: I'm writing the function as we speak
17:55:00 <shlevy> johnw: Sure, I'm writing a function that will use that hashing function
17:55:11 <shlevy> johnw: What's its type?
17:55:15 <johnw> Source m ByteString
17:55:55 <sshine> jtakacs, you can expect it to get inlined at some point anyway.
17:56:04 <shlevy> The hashing is Sink ByteString m ByteString right?
17:56:13 <jtakacs> ok, so two lines for every constant. got it, thanks.
17:56:23 <johnw> sinkHash :: (Monad m, HashAlgorithm hash) => Sink B.ByteString m (Digest hash)
17:56:25 <shlevy> Just to make sure I understand the idea :)
17:56:26 <johnw> is the hasher
17:56:41 <shlevy> Ah different hashing library
17:56:45 <joelteon> jtakacs: # of lines = count(constants) + length(num(types of constants))
17:56:52 <joelteon> nub not num
17:56:53 <johnw> it's using cryptohash
17:56:56 <johnw> do you want to use another library?
17:57:21 <shlevy> Ah never mind, that's what I was using
17:57:32 <shlevy> I just didn't see the HashAlgorithm class
17:58:11 <shlevy> Cool :)
17:59:04 <shlevy> This interface looks much simpler than conduit
17:59:08 <shlevy> Which I suppose is the exact point :D
17:59:12 <johnw> :)
17:59:20 <Cale> It's hard to be much more complicated :P
18:00:04 <Cale> jtakacs: You don't *have* to give type signatures to things, it's just advised for good style
18:00:18 <Cale> jtakacs: If you're lazy, you can leave the type signatures out and they'll be inferred.
18:00:30 <Cale> -Wall will complain, but -Wall complains about lots of stuff
18:00:39 <Cale> (including a fair number of things I think it ought not to)
18:00:56 <mwhit> Cale: like which?
18:01:07 <Cale> mwhit: Unused results in do-blocks
18:01:07 <jtakacs> I always use -Wall. I like to get rid of warnings too
18:01:55 <Cale> I don't often use -Wall so I don't recall which other things off-hand, but that one is pretty obnoxious on its own, if you're writing IO actions.
18:02:52 <jtakacs> ok, next question:  x is a ByteString.  is there a better way to write this:
18:02:53 <jtakacs> (((fromIntegral (B.index x 1))::Word16) `shiftL` 8 .|. ((fromIntegral (B.index x 2))::Word16))
18:03:16 <Cale> Move the Word16 type annotation outward?
18:03:23 <Cale> You only have to give it once
18:03:46 <jtakacs> no, ghc complains that .|. does not work with word16 and word8
18:03:50 <johnw> shlevy: here's all it takes:
18:03:51 <johnw> sinkHash = liftM hashFinalize . sink hashInit ((return .) . hashUpdate)
18:04:18 <johnw> now you can: hash <- sinkHash (sourceFile "foo")
18:04:33 <jtakacs> and shiftL truncates the result to word8, if I don't convert the value to word16 before
18:04:56 <shlevy> johnw: Is there a way we can take advantage of hashUpdates smartly?
18:05:02 <johnw> how so?
18:05:06 <mwhit> :t shiftL
18:05:06 <shlevy> johnw: Also, is there a tee? :)
18:05:07 <lambdabot> Bits a => a -> Int -> a
18:05:12 <Cale> :t \x -> ((fromIntegral (BS.index x 1)) `shiftL` 8 .|. (fromIntegral (BS.index x 2))) :: Word16
18:05:14 <lambdabot> BSC.ByteString -> Word16
18:05:16 <Cale> ^^ see?
18:05:26 <johnw> i'll have to write tee
18:05:26 <shlevy> johnw: Hmm I suppose not thinking further
18:05:48 <Cale> :t (.|.)
18:05:48 <lambdabot> Bits a => a -> a -> a
18:05:54 <shlevy> johnw: Would require profiling to see the right tradeoff for how many chunks to stream into the hash function at once, if one at a time isn't ideal
18:05:55 <johnw> so, what do we want the behavior for tee to be
18:05:57 <Cale> ^^ the types of the arguments to .|. must match
18:06:04 <Cale> :t shiftL
18:06:04 <lambdabot> Bits a => a -> Int -> a
18:06:12 <jtakacs> > shiftL x 8 where x=1::Word8
18:06:13 <lambdabot>  <hint>:1:12: parse error on input ‘where’
18:06:17 <shlevy> johnw: One sec, reading types...
18:06:21 <Cale> ^^ and the result of shiftL has to have the same type as its first argument
18:06:44 <Cale> > let x = 1 in shiftL x 8 :: Word8
18:06:45 <lambdabot>  0
18:06:49 <Cale> > let x = 1 in shiftL x 8 :: Word16
18:06:50 <lambdabot>  256
18:06:58 <jtakacs> that's the problem
18:07:06 <Cale> The type of x will be determined by the type of the result here
18:07:17 <Cale> There's no problem :D
18:07:19 <codygman> Can I use blaze templates externally somehow? I don't specifically see any recommendations for this in the docs. Do people usually not use blaze-html externally?
18:07:23 <johnw> if you mean "sink into multiple places", that's quite hard, unless the sinks are all of the same kind
18:07:40 <jtakacs> if I extract x from a ByteString, then x will be the type Word8
18:07:42 <shlevy> Source m a -> Sink a m r -> (r -> m b) -> Source m a?
18:07:44 <Cale> All I'm saying is that you only need one signature somewhere in your program which tells it to use Word16, the rest will be inferred from that
18:07:50 <johnw> unless it's ok to use async and run the sinks concurrently
18:08:13 <shlevy> johnw: I want to stream to a file but calculate the hash of the input as I go
18:08:22 <jophish> How does the RTS detect <<loop>>?
18:08:23 <Cale> You *do* need to do the fromIntegral conversions, but which type fromIntegral is converting to will be inferred from context.
18:08:28 <johnw> ah, so copy a file and end up with a hash value?
18:08:35 <shlevy> Yes essentially
18:08:39 <johnw> this we can do with concurrency, one sec
18:08:42 <shlevy> And then I will rename that file based on the hash
18:08:48 <Cale> jophish: The runtime representation of expressions (thunks) are pointers to code
18:09:11 <Cale> jophish: When that code is first entered, the pointer is updated to point at a blackhole (which throws the <loop> expression if entered.
18:09:15 <Cale> )
18:09:32 <jophish> Cale, ah, of course. Thanks!
18:09:36 <mwhit> jtakacs: it will *default* to that if there is nothing proving that it must be Word16. If it knows that overall function must return Word16, then it knows that fromIntegral call must, too
18:09:36 <shlevy> johnw: Well, perhaps this is a bad interface. I'm implementing the "addToStore" operation, which in the c++ impl takes a path, reads it, hashes it, and writes to a path based on that hash. And then there's addTextToStore, which takes a string and does similar
18:09:41 <Cale> Then the expression is evaluated and before the value is returned, the pointer is updated again to point at a short piece of code which will return it immediately next time
18:09:50 <shlevy> johnw: I'm trying to combine those, in a way that doen't require reading the entire file into memory first :)
18:09:57 <johnw> sure, this will work
18:09:59 <shlevy> So I stream to a temp file then move it at the end
18:10:02 <johnw> i'd written the code in the past, just resurrecting it
18:10:05 <shlevy> Cool
18:10:12 <johnw> one sec though, still wrestling  with recent store destruction :)
18:10:20 <shlevy> Thanks for all the handholding :D
18:10:31 <johnw> n/p, I want to gain some users for this library
18:10:37 <Cale> jtakacs: You absolutely need the fromIntegrals, but you don't have to be explicit with each one about which type you need. You just need a :: Word16 at the end
18:10:52 <GeraldCode> Question about the State monad. Evidently the State monad has changed in the past few years. I got through turotials by re-implemting it. Is there a  drop in replacement import I can use instead?
18:11:08 <xplat> Cale: iirc the detection of loops is more of a beneficial side effect of the actual purpose of blackholes?
18:11:13 <Cale> GeraldCode: Control.Monad.State?
18:11:41 <GeraldCode> Tried, said consutrort State not found...wants me to use StateT
18:11:46 <GeraldCode> constructor*
18:11:54 <Cale> xplat: It's really the only purpose. You could simply fail to update the pointer the first time, and things would work.
18:12:06 <xplat> GeraldCode: use 'state' with lowercase S when you don't mean the type
18:12:19 <GeraldCode> hmm ok lemme try
18:12:29 <xplat> it's a smart constructor, allows more code sharing between the State and StateT types
18:12:40 <GeraldCode> interesting, thanks
18:13:00 <johnw> shlevy: here you go: https://gist.github.com/2e7e03bc1667e89e755b
18:13:04 <johnw> that'll be in the next release
18:13:05 <Cale> xplat: In the threaded runtime, there are grey holes, which a little different, but also don't tend to report <loop> exceptions. Instead, they block and wait for a potential other thread to finish evaluating the value. So your program will get stuck if it's really a loop, but it will use 0% CPU
18:13:18 <daniel-s_> Hi.
18:13:23 <shlevy> johnw: Thanks :)
18:13:25 <daniel-s_> I have seen this video several time: https://www.youtube.com/watch?v=ZhuHCtR3xq8
18:13:33 <xplat> Cale: heh, maybe they should be called 'green holes'
18:13:46 <daniel-s_> Are monads just wrappers between types?
18:13:50 <Cale> daniel-s_: That is the worst introduction to monads on the internet
18:13:50 <GeraldCode> cool..it seems to be working :)
18:14:00 <shlevy> johnw: Is next release imminent on the order of hours or less? OK if not, just want to know if I should patch locally first :)
18:14:09 <johnw> I can do it within 30 mins
18:14:12 <xplat> Cale: that's ... really?  that's amazing.
18:14:16 <jtakacs> Is there any magic trick to tell ghc that upcasting a word8 to word16 is always ok?
18:14:40 <Cale> He basically wastes an hour not explaining what monads are
18:14:42 <shlevy> johnw: Cool thanks :)
18:15:09 <xplat> Cale: worse than the jquery monad?
18:15:25 <Cale> Okay, if you consider that some sort of monad tutorial, then yeah, there are worse :D
18:15:25 <spott> I've built ghc-mod inside a sandbox... how do I make it available everywhere?
18:15:29 <GeraldCode> I wish there was something that went into detail about why we do things the monadic way.  I read a PDF (skimmed) that things like state, sequential order etc were done without monads at one point
18:16:05 <xplat> GeraldCode: if you used haskell back before monads, it would be obvious why we are monadic now :)
18:16:08 <Cale> The ones which try to introduce monads in javascript and stuff, they're pretty bad, but they likely won't waste a whole hour of your time either.
18:16:20 <SrPx> Quick question: you guys often advice one to use either foldr or foldl', because the lazy foldl builds a huge list on memory before reaching the first redex and is, thus, kinda slow. But so does foldr! So what I am missing here?
18:16:34 <Cale> @src foldr
18:16:34 <lambdabot> foldr f z []     = z
18:16:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:16:40 <GeraldCode> xplat, oh I didnt...I mean I guess I can guess reasons why..But I cant really conceptualize it..
18:16:48 <Cale> ^^ in the recursive case, foldr passes control to f
18:17:10 <Cale> If f doesn't look at its second parameter before producing part of its result, the foldr can stop early.
18:17:25 <Cale> This allows foldr to operate on infinite lists
18:17:33 <SrPx> So `foldr` is good for making use of laziness, while foldl is faster when laziness will not be used?
18:17:36 <Cale> and terminate early when doing search-like things
18:17:43 <Cale> foldl' is, yeah
18:17:43 <octopuscabbage> Cale: How does one fold an infinite list
18:17:52 <GeraldCode> from the left
18:17:58 <Cale> > foldr (\x xs -> x : 2*x : xs) [] [1..]
18:18:00 <lambdabot>  [1,2,2,4,3,6,4,8,5,10,6,12,7,14,8,16,9,18,10,20,11,22,12,24,13,26,14,28,15,3...
18:18:01 <jtakacs> octopuscabbage: very carefully :)
18:18:05 <Cale> > foldr (\x xs -> x : 10*x : xs) [] [1..]
18:18:07 <lambdabot>  [1,10,2,20,3,30,4,40,5,50,6,60,7,70,8,80,9,90,10,100,11,110,12,120,13,130,14...
18:18:16 <xplat> > find (> 50) [1..]
18:18:16 <Cale> > foldr (\x xs -> if even x then x : 10*x : xs else xs) [] [1..]
18:18:17 <lambdabot>  Just 51
18:18:18 <lambdabot>  [2,20,4,40,6,60,8,80,10,100,12,120,14,140,16,160,18,180,20,200,22,220,24,240...
18:18:28 <octopuscabbage> jtakacs: this is begining to sound more like a math or theoretical engineering problem than a programming problem
18:18:36 <Cale> > foldr (\x xs -> if x > 50 then x else xs) 0 [1..]
18:18:37 <lambdabot>  51
18:18:50 <Cale> > foldr (\x xs -> if x > 50 then Just x else xs) Nothing [1..]
18:18:51 <lambdabot>  Just 51
18:19:03 <SrPx> Cale: oops, that is what I mean. So, 1. foldl' is faster than both foldr and foldl. 2. foldr and foldl are about the same speed/memory usage when laziness is not used. 3. when laziness is used, foldr is better because obvious.
18:19:07 <SrPx> Cale: is that all correct?
18:19:16 <Cale> SrPx: foldr can be faster than foldl'
18:19:29 <SrPx> Cale: yes, when laziness is used! (:
18:19:30 <Cale> SrPx: It really depends on how strict the function you're passing in is.
18:19:41 <Cale> also, it's not so much about speed as memory
18:19:47 <Cale> (but memory affects speed in the end)
18:20:09 <Cale> The number of reduction steps will be about the same in any case where f is strict.
18:20:27 <SrPx> yes, I get that. the point is: foldr and foldl are pretty much equivalent when laziness is not used in any way, right? Example: sum
18:20:28 <Cale> But if f is strict, then foldr and foldl will build up large expressions
18:20:47 <Cale> SrPx: they're close
18:20:54 <shlevy> johnw: string ByteStrings right?
18:21:00 <shlevy> johnw: for the hash sink
18:21:11 <Cale> The manner in which the expressions build up is a little different, but they build up nonetheless.
18:21:18 <xplat> SrPx: actually foldl is about equivalent to reverse . foldr . reverse (modulo parameters)
18:21:42 <Cale> (and modulo constant factors)
18:21:49 <johnw> shlevy: huh?
18:21:59 <shlevy> johnw: strict* :D
18:22:03 <copumpkin> xplat: how do you have a reverse on both sides?
18:22:13 <Cale> heh, yeah
18:22:18 <xplat> copumpkin: i left off parameters
18:22:19 <Cale> you only one the latter reverse
18:22:22 <Cale> want*
18:22:22 <johnw> shlevy: I'm not sure
18:22:24 <shlevy> johnw: Does hnix use Text or ByteString for nix strings? FWIW in c++ they are 8-bit strings, not actually unicode-aware, and cannot accept nulls
18:22:31 <johnw> yeah, strict
18:22:44 <Cale> foldl f z xs = foldr (flip f) z (reverse xs)
18:22:45 <johnw> then hnix should use ByteString
18:23:16 <xplat> copumpkin: oh, hurr.  i was thinking of like mapAccumL and mapAccumR
18:23:29 <copumpkin> oh :)
18:23:49 <shlevy> johnw: I wish I could do two things at once :D I want to review hnix and also finish this at the same time
18:23:59 <johnw> i'm still working on this release, on esec
18:24:31 <Algebr`> What's the rule of thumb for when you should use monad or applicative? Is it something like, if you actually need a handle on a variable, then the former?
18:24:46 <SrPx> xplat: equivalent you mean in effect, not that you do have to reverse it twice, right?
18:24:58 <xplat> generally you should use Applicative unless you can't, and otherwise use Monad
18:25:55 <xplat> as i was recently informed, though, for advanced users there are cases where Monad can perform better even if you could have used Applicative.  but you should have a pretty good handle on this yourself by the time you can find those cases :)
18:26:03 <xplat> SrPx: right
18:29:45 <xplat> SrPx: also the right statement is more like foldl s z = foldr (flip s) z . reverse
18:29:58 <xplat> SrPx: and vice versa
18:31:11 <shlevy> johnw: Hmm I see how to do what I want with zipSinks, but technically there's no reason to wait for both to finish to rename the file :)
18:31:14 * hackagebot simple-conduit 0.5.0 - A simple streaming I/O library based on monadic folds  http://hackage.haskell.org/package/simple-conduit-0.5.0 (JohnWiegley)
18:31:18 <johnw> shlevy: ^^
18:31:27 <shlevy> johnw: thanks! Updating nixpkgs :)
18:31:38 <johnw> once you have the file descriptor, I think renaming is harmless
18:31:44 <shlevy> exactly
18:31:51 <johnw> in fact, I believe that used to be a technique for atomic file operations
18:31:52 <shlevy> but zipSinks waits for both right?
18:32:02 <johnw> zipSinks waits for both sinks to finish, yet
18:32:02 <johnw> yes
18:32:11 <xplat> johnw: 'used to be' ?
18:32:14 <johnw> if you want to rip out the code and rewrite it not to, that's fine
18:32:14 <shlevy> I guess for now that's fine
18:32:24 <johnw> xplat: well, uh, um...
18:32:54 <shlevy> If profiling shows this to be a hot path I can experiment with that
18:32:54 <xplat> doesn't work on nfs though ...
18:34:45 <SrPx> I see
18:34:49 <SrPx> thanks guys (:
18:37:45 <spott> how do you deal with global executables (those you want available across the system) when using sandboxes?  How do you export an executable and everything it needs to run from a sandbox?
18:38:05 <Cale> spott: Compile the executable
18:38:05 <xplat> build it static and link to a bindir?
18:38:10 <jtakacs> bye
18:38:16 <Cale> jtakacs: see you!
18:38:39 <xplat> if it can't be built static, shell script wrapper to run in the sandbox
18:38:54 <spott> so, cabal sandbox init, cabal install <executable> --<build-static flag>
18:39:13 <xplat> but that applies to python and such much more than haskell.  and static build is default.
18:39:37 <spott> so just move the executable out of the sandbox?
18:39:47 <xplat> most of the cases i'm talking about are things like xmonad that actually recompile themselves when the config file changes
18:40:05 <xplat> spott: i usually use a symlink
18:40:56 <spott> so I have to have a sandbox floating around on my harddrive filled with a whole bunch of library dependencies for every executable that I want to install?
18:41:44 <xplat> spott: well, if you're really that tight on space you could move-and-delete, but keeping the sandbox dir around can make it easier to do updates
18:42:02 <spott> ok
18:42:11 <spott> good to know that static is the default
18:42:14 <xplat> especially if you have custom patches and build from git, and who doesn't?  :)
18:42:56 <spott> :)
18:46:15 * hackagebot tz 0.0.0.6 - Efficient time zone handling  http://hackage.haskell.org/package/tz-0.0.0.6 (GergelyRisko)
18:48:08 <johnw> 0.0.0.0.6!
18:48:31 <johnw> the 9 0s of unreliability, is the opposite of the 9 9s of server availability
18:49:15 <xplat> start with version 0.0.0.0, go to 0.0.0.0.0.0, then 0.0.0.0.0.0.0.0
18:53:09 <shlevy> Is there anything like 'bracket' for exception handling in non-IO contexts?
18:53:45 <shlevy> Oh never mind
18:53:49 <shlevy> catch specifies IO a
18:54:00 <shlevy> I assumed it would work in MonadIO or some such
18:54:10 <shlevy> Guess I should just liftIO
18:56:31 <solidus-river> go with this! http://semver.org/
18:59:46 <johnw> shlevy: use lifted-base
18:59:53 <johnw> it gives you catch for any MonadIO m, MonadBaseControl IO m
19:00:15 <shlevy> johnw: Thanks
19:00:26 <johnw> I pretty much don't use Control.Exception anymore
19:00:30 <johnw> I use Control.Exception.Lifted everywhere
19:00:36 <johnw> Control.Concurrent.Async.Lifted too
19:00:38 <shlevy> nice bracket
19:00:39 <johnw> they are so useful
19:16:58 <Algebr> Has the idea of adding lisp/python style doc strings ever been floated?
19:17:10 <chrisdotcode> Algebr: haddock documentation
19:17:36 <chrisdotcode> Algebr: http://www.haskell.org/haddock/doc/html/
19:17:52 <carter> Algebr: we do it better
19:17:53 <carter> :)
19:17:55 <carter> well
19:17:57 <carter> not perfect
19:18:01 <carter> but our docs cant lie
19:18:04 <carter> which is MAGIC
19:18:13 <chrisdotcode> haha
19:18:22 <Algebr> ha, but I mean can I access it via ghci?
19:18:29 <Algebr> something like :haddoc when
19:20:33 <carter> :info
19:20:40 <carter> kinda
19:20:44 <carter> :info head
19:24:40 <geekosaur> there are ghci add-ins which enable haddock etc.
19:24:51 <geekosaur> although I don't know how maintained goa is at this point
19:24:59 <carter> ghci-ng?
19:25:15 <carter> https://hackage.haskell.org/package/ghci-ng
19:25:29 <Algebr> hmm, apparently there's a way to use w3m with haskell-mode.
19:26:49 * Algebr hates leaving emacs.
19:27:59 <sshine> I just themed my Emacs the same way as I theme my terminal. that way I don't notice much. :)
19:31:20 * hackagebot peyotls 0.1.0.0 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.0.0 (YoshikuniJujo)
19:33:28 <Algebr> why is ghci unhappy with getArgs?
19:34:11 <joelteon> what does that mean
19:35:14 <Algebr> joelteon: for example, this code main = getArgs >>=
19:35:14 <Algebr>        \args -> when (not $ null args)
19:35:15 <Algebr>                 (putStrLn "non empty args")
19:36:02 <Algebr> does not run when I do: main 123 in ghci via emacs. But now as I'm writing this out, I'm thinking that might be more of some kind of haskell-mode problem.
19:36:14 <joelteon> main 123 wouldn't even type-check, would it?
19:36:14 <glguy> do:   :main 123
19:36:44 <glguy>    :main [<arguments> ...]     run the main function with the given arguments
19:36:45 <solidus-river> Algebr: what args would ghci get?
19:37:06 <Algebr> 123?
19:37:35 <glguy> Also, withArgs :: [String] -> IO a -> IO a
19:37:35 <solidus-river> thtas not how getargs works i dont think
19:37:40 <Algebr> I guess the alternative is just to do runhaskell "some args"
19:37:49 <solidus-river> but i could be wrong
19:37:53 <joelteon> well, main is only IO (), it doesn't take arguments itself
19:38:00 <glguy> are my messages making it through to channel?
19:38:03 <joelteon> yes glguy
19:38:10 <joelteon> I don't know whether Algebr paid attention though
19:38:34 <Algebr> joelteon: yes, now I see my ignorance.
19:42:18 <octopuscabbage> does haskell have a form of continuations or anything like pythons yield?
19:42:27 <octopuscabbage> or would that be a state
19:42:34 <jle`> octopuscabbage: we have first class continuations :)
19:42:53 <copumpkin> not zeroth class though
19:43:01 <octopuscabbage> jle`: could you link me an example?
19:43:17 <jle`> continuations aren't a language feature, they're a library ^_^
19:43:25 <jle`> octopuscabbage: how much haskell do you know?
19:43:40 <octopuscabbage> jle`: not that much, i barely understand monads
19:43:43 <jle`> or not a library...literalyl things you could implement yourself from normal functions during a leisurely lunch
19:43:50 <jle`> or a nice weekend
19:44:15 <copumpkin> argh
19:44:18 <copumpkin> monads are not essential to haskell
19:44:30 <copumpkin> you can be great at haskell and not know much of that mathy stuff at all
19:44:56 <octopuscabbage> copumpkin: well i consider myself a competant functional programmer but i just don't know monads
19:45:05 <jle`> i think he might be saying that to indicate his position on the traditional road of haskell apprenticeship/learning
19:45:08 <glguy> octopuscabbage: What kinds of things do you want to do? For some uses of python's yield you'll only need the fact that Haskell has lazy evaluation
19:45:40 <octopuscabbage> glguy: i understand using lazy evaluation for something like an infinite sequence
19:45:43 <codygman> Why does this piece of code work in the ghci repl but not my code? http://lpaste.net/107578
19:45:59 <glguy> octopuscabbage: If you have some Python code that you want to see in Haskell we could help out. The space is pretty broad
19:46:23 <jle`> codygman: try using manual parentheses instead of ($)
19:46:51 <jle`> hm not sure if that would help
19:46:56 <octopuscabbage> glguy: let me try to write something along hte lines of what i'm thinking
19:46:57 <jle`> cause it works on ghci
19:48:05 <glguy> codygman: the type error is that you're passing a value to body that it doesn't expect
19:48:12 <glguy> not the line of code you pasted into GHCi
19:50:07 <codygman> glguy: I'm passing a string to $ somehow? It says "it's first argument is type string" which is why I used "toHtml" but that is of type ToMarkup a => a -> Html.
19:52:28 <codygman> glguy: I created the code for a link inside of a p tag based on this: https://github.com/jaspervdj/blaze-html/blob/master/doc/examples/BenchmarkServer.lhs#L80
19:56:53 <codygman> Actually, pasting the "p" example directly from the blaze html docs throws an error: http://lpaste.net/107585#line15
19:58:39 <codygman> Oh, it's because it isn't explicitly "Html" within that monad right?
19:59:17 <geekosaur> is that really from their example?
19:59:26 <geekosaur> because I think the problem is actually on line 5
20:00:42 <geekosaur> codygman, ^^
20:01:44 <Kron> hmm, haskell-mode suddenly broke for me overnight. Or at least, C-c C-l doesn't load the file into an inferior haskell anymore...
20:02:04 <Kron> haskell-mode-enable-process-minor-mode now just writes an error?
20:02:12 <Algebr> Kron: what's your error?
20:02:34 <Kron> "You tried to do an interaction command, but an interaction mode has not been enabled yet.Run M-x describe-variable haskell-mode-hook for a list of such modes."
20:02:57 <Kron> https://github.com/haskell/haskell-mode/blob/master/haskell-mode.el it seems to be the entire source code of haskell-mode-enable-process-minor-mode
20:02:59 <Algebr> Kron: yea, I had that before. inferior haskell is deprecated, so you should be using interactive-haskell. You can do customize-group
20:03:02 <Kron> ah1
20:03:03 <Algebr> then interactive-haskell
20:03:05 <Kron> *ah! thanks
20:03:18 <Algebr> then set the path for ghci or whatnot
20:03:36 <Algebr> I'm using cabal-repl
20:03:37 <Kron> do you mean haskell-interactive?
20:03:47 <Algebr> Kron: ah, yea, that's what I meant.
20:03:56 <Kron> it only has "Haskell Align Imports Pad After Name"
20:04:01 <codygman> geekosaur: You are right, removing line 5 and the function definition of it solves things. I have no idea why.
20:04:07 <Kron> how do I make C-c C-l just do what it always did?
20:04:25 <geekosaur> codygman, because you overrode Blaze's "p" with a local one containing a password
20:04:30 <Algebr> Kron: you have to set pick the haskell-process-type
20:04:35 <geekosaur> use a different variable name
20:04:40 <Kron> hmm
20:05:07 <Kron> where though?
20:05:12 <codygman> geekosaur: Oh! Wow... that makes me feel silly
20:05:29 <der|> can anybody tell me what am I doing wrong here: http://lpaste.net/107586 (thanks in advance)
20:05:49 <codygman> Isn't there a setting to warn me about shadowed variables?
20:06:10 <Kron> there is
20:06:12 <Kron> -Wall does it
20:06:13 <glguy> der|: Use "print" to print stuff
20:06:19 <geekosaur> der|, putStrLn wants a string, you gave it a number, there are NO automatic coercions in Haskell
20:06:26 <geekosaur> use `print`, or pass the number through `show`
20:06:31 <glguy> der|: Use putStrLn to send Strings in particular to the screen
20:06:41 <der|> true, changed it to print and it compiled
20:06:44 <Kron> -fwarn-name-shadowing
20:06:52 <Kron> codygman ^
20:07:22 <jle`> codygman: you should -Wall, or develop with a cycle that integrates hlint/ghc-mod :)
20:07:25 <der|> glguy, geekosaur thanks
20:07:40 <jle`> codygman: what text editor do you use?
20:09:39 <codygman> Kron: Thanks
20:09:57 <codygman> jle`: emacs. If I would have had flycheck on it would have told me wouldn't it...
20:10:24 <jle`> codygman: don't know much about emacs, sorry ;_;
20:10:42 <jle`> i can only use ms paint + ocr
20:10:56 <jle`> best syntax highlighting
20:12:04 <johnw> what data structure has the fastest Int key lookups?
20:12:13 <johnw> i'm using a mutable vector at the moment
20:13:17 <codygman> jle`: lol
20:14:57 <dolio> Immutable vector is probably just as fast for lookups.
20:15:06 <jle`> johnw: i wonder what overhead Vector has over Array
20:15:15 <jle`> ...i can't imagine it being that much
20:15:17 <johnw> Array was slower fwiw
20:15:24 <jle`> really?
20:15:28 <johnw> I upgraded the code from Array; now I'm wondering if I can do even better
20:15:36 <dolio> Array does arbitrary index stuff.
20:15:39 <jle`> isn't vector array + api ?
20:15:44 <johnw> yeah, Array uses these index ranges
20:16:30 <jle`> i always thought vector was a wrapper around array
20:18:59 <johnw> array is not a dependency of vector
20:19:24 <johnw> it does import Data.Primitive.Array
20:19:58 <johnw> whereas array imports GHC.Arr
20:20:30 <johnw> Data.PrimitiveArray is: data Array a = Array (Array# a)
20:20:41 <johnw> so i would say the two packages, vector and array, are not directly related
20:28:42 <jle`> ah i see
20:29:13 <Algebr> Why am I getting a non exhaustive pattern match here?
20:29:33 <Algebr> 5f a@(x:xs)
20:29:34 <Algebr> 6  | a == [] = []
20:29:38 <Algebr> 7  | otherwise = intToDigit x : f xs
20:29:50 <geekosaur> please don't paste directly into the channel
20:29:54 <ReinH> Algebr: (x:xs) matches a non-empty list
20:30:01 <geekosaur> and the answr, if that is complete, is youre missing []
20:30:17 <Algebr> but I'm matching it with the a
20:30:21 <ReinH> a will never be []
20:30:22 <geekosaur> no
20:30:31 <Algebr> isn't that what the @ is for?
20:30:31 <geekosaur> a is a name for the thing matched by (x:xs)
20:30:55 <geekosaur> letting you refer to that by a single binding instead of having to recreate another (x:xs)
20:32:58 <jle`> Algebr: what you are doing is equivalent to (x:xs) | (x:xs) == [] = [] | otherwise = intToDigit x : f xs
20:33:00 <geekosaur> Algebr: if your pattern is just (x:xs), then to use that in the result you have to say (x:xs) and this creates a *new* list instead of using the existing one
20:33:12 <jle`> er not equivalent because you make a new one, yeah
20:33:42 <geekosaur> so the a@(x:xs) lets you name both the things in the list (head and tail) but also the list itself --- *provided* that the list has a head and a tail (that is, matches (x:xs))
20:33:47 <geekosaur> it still does not match []
20:34:22 <Algebr> So the a is bound after the pattern is matched?
20:34:30 <geekosaur> yes
20:35:17 <Algebr> thanks jle`, geekosaur
20:48:50 <codygman> Does configurator provide a way to update a config file? I'm not seeing one.
21:03:45 <solirc> Qfwfq: Actually there were some build failures on travis https://travis-ci.org/alpmestan/taggy-lens/builds
21:19:59 <brainsturgeon> Hello. I've installed GHC 7.6.3 using homebrew and I seem unable to import the state monad. `import Control.Monad.State` and `import Control.Monad.State.Lazy`, as suggested on the haskell wiki, both result in "could not find module".
21:20:11 <brainsturgeon> Is there some package I should download to get these modules?
21:22:00 <johnw> to install those two, you need to install mtl
21:23:22 <brainsturgeon> Thank you johnw. I'll download cabal and give it a shot.
21:27:39 <bb010g> Related to the bit about view patterns from two days ago, you should make a function ``ensure p x | p x = Just x; ensure p x | otherwise = Nothing`` and then can do ``f (ensure (>0) -> Just x) = x + 1; f x = x - 1`` safely.
21:28:22 <brainsturgeon> johnw: works fine now, thanks!
21:34:56 <isomorpheous> Question, what editor do y'all use?
21:35:01 <Sornaensis> vim
21:35:11 <isomorpheous> Emacs guy here.
21:35:14 <isomorpheous> Can't stand vim
21:35:24 <isomorpheous> But can see why people like it
21:35:36 <Sornaensis> I'm just too invested at this point to switch :p
21:35:41 <isomorpheous> Emacs's support for haskell is pretty good
21:35:53 <isomorpheous> Sornaensis: I'm the same way with Emacs
21:36:03 <isomorpheous> Sornaensis: Vim
21:36:10 <isomorpheous> Sornaensis: 's configuration language is laughable
21:37:03 <isomorpheous> Sornaensis: I was a vim user for a while, then I started using emacs, just for the hell of it. I have to say that vim is much better out of the box, but it doesn't offer the control that Emacs does
21:37:14 <isomorpheous> Once you get used to the degree of control that Emacs offers you
21:37:20 <isomorpheous> You can't go back to something like Vim
21:37:41 <isomorpheous> Also, GVim sucks, and I hate working in rxvt
21:40:37 <Cale> I use vim, but I use almost none of its features
21:40:48 <bb010g> Vim man here. :)
21:40:51 <Cale> I pretty much don't care what editor I use
21:40:57 <Cale> I can get by with gedit
21:41:11 <Cale> but vim's colour scheme is nicer :P
21:41:13 <bb010g> Cale: You could probably enjoy Yi then.
21:41:38 <isomorpheous> Cale: You know you can install more color schemes, right?
21:41:59 <Cale> isomorpheous: for gedit?
21:42:19 <isomorpheous> Cale: ah, I thought we were still on VI vs Emacs
21:42:25 <isomorpheous> Sort of channel hopping at the moment
21:42:38 <Cale> yeah, for vim or emacs, obviously
21:42:50 <Cale> I think you *can* install more colour schemes for gedit as well
21:43:16 <bb010g> Yi's looking more awesome with features like pattern expansion.
21:43:26 <coaupiff> yi!
21:43:38 <isomorpheous> Yi seems like it has a lot of potential
21:43:47 <isomorpheous> but it still doesn't compare to Emacs
21:44:05 <MP2E> Yi has a different approach than emacs though
21:44:11 <bb010g> On the other hand, neovim is looking like it'll have a great plugin API.
21:44:19 <davidfetter> here i thought Yi was an ethnic group in china
21:44:24 <jle`> anyone use atom for haskell?
21:44:32 <MP2E> Yi seems to be more like an xmonad approach, minimalist with features only added as you need them. While emacs is everything and the kitchen sink
21:44:44 <MP2E> though I definitely love emacs :D
21:45:05 <coaupiff> 義's development has picked up recently, too, huh?
21:45:09 <isomorpheous> jle`: I tried it
21:45:37 <bb010g> coaupiff: :)
21:45:48 <isomorpheous> jle`: I'm already balls deep in Emacs, so I didn't give it much
21:46:20 <isomorpheous> jle`: of a try
21:46:31 * hackagebot auto-update 0.1.0.0 - Efficiently run periodic, on-demand actions  http://hackage.haskell.org/package/auto-update-0.1.0.0 (MichaelSnoyman)
21:48:50 <jle`> sometimes i am amazed at how far i get in a file before i remember to turn on scoped type variables
21:49:51 <MP2E> what, do you inevitably come to scoped type variables in most of your projects? :P
21:50:07 <MP2E> use*
21:50:10 <MP2E> that sounded odd.
21:50:11 <MP2E> but yeah
21:50:26 <isomorpheous> I've never needed it
21:50:34 <MP2E> i haven't needed it yet either
21:50:40 <isomorpheous> I've usually been able to do without it
21:50:41 <MP2E> not that I've written anything big yet
21:50:43 <MP2E> heh
21:50:55 <isomorpheous> I do always end up needing overloadedstrings
21:51:05 <isomorpheous> The only time I don't is for purely mathematical libraries
21:51:06 <glguy> You generally don't need it unless you're intentionally doing something "clever"
21:51:17 <glguy> which isn't a good place to be in big projects
21:51:26 <isomorpheous> glguy: i.e. "confusing"
21:51:32 * hackagebot process-conduit 1.2.0.0 - Conduits for processes (deprecated)  http://hackage.haskell.org/package/process-conduit-1.2.0.0 (MichaelSnoyman)
21:51:34 <enthropy> without it you can't write many type signatures
21:52:13 <jle`> MP2E: i use it all the type
21:52:19 <enthropy> then again type signatures inside "where" and "let" are pretty rare
21:52:27 <MP2E> hehehe
21:52:32 <jle`> oh i always use type signatures for all of my where functions >_>
21:52:37 <isomorpheous> enthropy: I use them
21:52:50 <isomorpheous> enthropy: You don't need an extension for that
21:52:55 <isomorpheous> You need an extension for things like
21:53:13 <isomorpheous> (x :: Int) <- someIOFunction
21:53:18 <jle`> oh...i don't use it for that
21:53:24 <jle`> i use it for something like
21:54:05 <jle`> um
21:54:14 <jle`> the function is parametric over all Monad m
21:54:26 <jle`> and the helper functions in the where clause also are over all Monad m
21:54:32 <isomorpheous> Ah
21:54:54 <jle`> so now you are saying "the m here is the same m everywhere in this declaration"
21:55:04 <jle`> also...say you have something like (a -> b -> c) parametric or something
21:55:11 <jle`> your helper functions can't *use* any of your arguments
21:55:26 <enthropy> they can use the monomorphic arguments
21:55:32 <jle`> enthropy: ah, yeah.
21:55:37 <jle`> but who has monomorphic arguments ;)
21:56:03 <enthropy> probably isomorpheous does
21:56:25 <jle`> if your type signature of your helper functions are, say, (a -> c)...but you *use* the `a` given in the top level function...then your helper functions can't be forall a b. a -> b, it has to be forall b. (a of the top level function) -> b
21:57:47 <eazar001> can someone send out a pretty character?
21:57:53 <glguy> ™
21:57:57 <gamegoblin> Is there a repeatM sort of function?
21:57:57 * glguy guesses
21:57:59 <gamegoblin> @hoogle repeatM
21:58:00 <eazar001> thank you
21:58:01 <lambdabot> No results found
21:58:06 <Sornaensis> √
21:58:20 <glguy> ?type replicateM
21:58:21 <lambdabot> Monad m => Int -> m a -> m [a]
21:58:32 <gamegoblin> :t repeat
21:58:33 <lambdabot> a -> [a]
21:58:35 <enthropy> @type sequence . repeat
21:58:36 <lambdabot> Monad m => m a -> m [a]
21:58:43 <gamegoblin> mmm that works
21:58:44 <glguy> gamegoblin: except in the most trivial circumstances a "repeatM" wouldn't be useful
21:58:57 <gamegoblin> glguy: why?
21:58:59 <glguy> ?type forever
21:59:00 <lambdabot> Monad m => m a -> m b
21:59:26 <glguy> Because for many monads it loops forever and never gives you the list
21:59:46 <gamegoblin> I don’t see how trivial circumstances follow from that
22:00:02 <gamegoblin> What if I want to takeWhile on an infinite list?
22:00:26 <glguy> for something like IO or List or Maybe or ...
22:00:29 <glguy> you wouldn't get the list back
22:00:33 <glguy> you'd just loop
22:00:46 <enthropy> IO will work if you have unsafeInterleaveIO involved somehow
22:01:10 <enthropy> rather, it can work in some situations
22:01:22 <Gurkenglas_> > Just . repeat
22:01:23 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
22:01:23 <lambdabot>    arising from a use of ‘M543022162903561425425841.show_M5430221629035614254...
22:01:23 <lambdabot>  The type variable ‘a0’ is ambiguous
22:01:23 <lambdabot>  Note: there are several potential instances:
22:01:23 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Aeson.Lens.Primitive
22:01:29 <Gurkenglas_> > (Just . repeat) 5
22:01:30 <lambdabot>  Just [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
22:01:37 <Gurkenglas_> Looks like it's working
22:01:56 <enthropy> > (sequence . repeat) (Just 5)
22:02:02 <glguy> That's not what we're talking about, Gurkenglas_
22:02:02 <lambdabot>  mueval-core: Time limit exceeded
22:02:02 <lambdabot>  mueval: ExitFailure 1
22:02:35 <glguy> gamegoblin: Just because you "takeWhile" on the result, repeatM needs to finish running the effects on the "whole" list
22:02:40 <Gurkenglas_> Got it, soz
22:03:23 <gamegoblin> I understand now
22:03:30 <glguy> > (sequence . repeat) (return ()) :: Identity [()]
22:03:31 <lambdabot>  Identity {runIdentity = [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
22:03:50 <glguy> That's one of the trivial cases
22:06:35 <Javran> is (maxBound :: Int) dependent to machine / architecture?
22:06:42 <glguy> Yes
22:07:19 <Javran> well then maybe i shoud use Int64 to be explicit..
22:07:27 <glguy> Or Integer
22:08:12 <Javran> glguy: I think Int64 will be sufficient, I know the number will never exceed 2 * 10 ^18
22:11:00 <jle`> gamegoblin: consider the State monad, and how sequence is defined.  the state at the point of the "next command" after repeatM would involve the resulting state from the last command of repeatM.
22:11:12 <jle`> which...is never
22:11:31 <jle`> you might only take 10 of the items, but it still needs to evaluate the infinitieth item to get the final state
22:11:39 <gamegoblin> gotcha
22:11:58 <gabriel> hi
22:12:02 <gabriel> last year, I took a course called "Advanced FP" and while discussing parallelism, one of the issues that came up is that laziness doesn't work well with it. Is there any good example where lazy structures are better for parallelism?
22:13:18 <gamegoblin> gabriel: first thing that comes to mind is weirdness in determining runtime performance, since something might go unevaluated for quite a while and then get evaluated by a thread, causing it to hand for a bit?
22:13:26 <gamegoblin> hang*
22:15:03 <agibiansky> Haskell defines Fractional like this: class Num a => Fractional a where ...
22:15:09 <agibiansky> How come that doesn't cause issues with UndecidableInstances?
22:15:50 <agibiansky> wait
22:15:52 <agibiansky> what am i talking about
22:15:59 <agibiansky> sigh, nevermind
22:16:04 <agibiansky> its late, ignore me
22:16:29 <gabriel> well, the  example was the lazy list, where you had to force it, because evaluating it in parallel evals only  the head
22:16:41 <gabriel> and was the same as non parallel code
22:19:30 <platz> is a zipper with (data Z = Z [a] a [a]) analgous to a doubly-linked list?  Moran suggests Snoc lists but I'm not sure how that is different from a regular Cons list http://youtu.be/sF2Ict7H6dk?t=50m36s
22:21:02 <platz> ahh, I think the idea is to just use two lists
22:21:11 <platz> he just didn't write the full impl down
22:21:16 <glguy> There are interesting ways to evaluate lazy structures in parallel http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html
22:22:33 <glguy> If you scroll down to "API History" you can find more to read
22:25:19 <platz> oh D has STM too, add another to the STM list
22:25:27 <isomorpheous> So, wondering how to write a json schema for this - http://lpaste.net/107587
22:25:52 <isomorpheous> I wrote a FromJSON instance
22:26:07 <isomorpheous> which seems a lot more flexible than a json schema
22:30:07 <gabriel> nice, thanks
22:30:22 <begriffs> OK today I got my first gibberish type error. What is hc-prim:GHC.Prim.State# ghc-prim:GHC.Prim.RealWorld -> GHC.ST.STret ghc-prim:GHC.Prim.RealWorld () ?
22:30:51 <isomorpheous> begriffs: IO (), I think
22:31:11 <MP2E> Yep that's what it looks like
22:31:41 <isomorpheous> IO isn't a normal algebraic data type
22:34:03 <begriffs> isomorpheous: Ah, it resulted from liftIO, so maybe that is some kind of generic IO type.
22:43:16 <sadfkjdsf> If I've got a list of stuff, and want to do some IO and then sleep for each item in the list, how would I do that?
22:43:45 <sadfkjdsf> mapM works fine if I don't want it to sleep, but I want it to do each individually and sleep between them
22:44:55 <jfischoff> mapM (\x -> threadDelay 100000 >> f x) is almost what you are looking for
22:45:21 <sadfkjdsf> what's the 'almost'?
22:45:35 <jfischoff> It starts with a sleep
22:45:59 <sadfkjdsf> oh, that's fine
22:46:06 <jfischoff> :)
22:46:07 <sadfkjdsf> thanks!
22:46:18 <joelteon> :t intersperse (threadDelay 100000)
22:46:19 <lambdabot> Not in scope: ‘threadDelay’
22:46:56 <joelteon> sadfkjdsf: sequence . intersperse (threadDelay 100000)?
22:47:05 <jfischoff> :t intersperse repeat (Control.Concurrent.threadDelay 100000)
22:47:06 <lambdabot>     Couldn't match expected type ‘[a -> [a]]’ with actual type ‘IO ()’
22:47:07 <lambdabot>     In the second argument of ‘intersperse’, namely
22:47:07 <lambdabot>       ‘(GHC.Conc.IO.threadDelay 100000)’
22:47:24 <jfischoff> t intersperse (Control.Concurrent.threadDelay 100000)
22:47:28 <jfischoff> :p
22:47:32 <sadfkjdsf> How do I turn the list of inputs into a list of IO actions to perform?
22:47:51 <joelteon> 'map'
22:48:01 <joelteon> :)
22:48:02 <sadfkjdsf> ah
22:51:00 <sadfkjdsf> thanks a lot, it's working :)
22:55:38 <begriffs> What is the difference between these two liftIO's? http://www.haskell.org/hoogle/?hoogle=liftIO
22:58:53 <arancia> begriffs: I don't think there's a difference
22:59:23 <MP2E> begriffs : those are both the same, one just has an explicit forall instead of an implicit one
23:00:04 <begriffs> What do you mean by an implicit one? How does that happen?
23:00:04 <johnw> looks like Network.CGI is re-exporting
23:00:24 <johnw> which you can telling by clicking through and seeing that there is no "Source" link
23:01:12 <MP2E> begriffs : say you have a function (a -> Int). if you were to type out the signature it would be 'function :: a -> Int' right? Well the compiler would actually expand that out to be : 'function :: forall a. a -> Int'
23:01:35 <MP2E> it does this because typing forall for every single polymorphic variable would get tiresome
23:02:18 <MP2E> the only time you really need to use an explicit forall is when you're dealing with Existential Types, Scoped Type Variables or Rank N Types
23:02:27 <MP2E> all compiler extensions... so yeah :P
23:03:53 <solidus-river> can i put class restrictions on variables into class methods
23:04:08 <gamegoblin> Is there an idiomatic way of returning a value that’s “either failure or everything went ok”. Right now I am using IO (Either myError () )
23:06:15 <MP2E> solidus-river : uhh you mean putting constraints on class instances?
23:06:23 <MP2E> not sure I understand the question
23:07:02 <fxr> gamegoblin: why not an `IO (Maybe myErr)`
23:07:34 <gamegoblin> fxr: I thought about that, but I felt that using a Left better expresses failure than a Just
23:07:38 <gamegoblin> even if it’s a Just Error
23:07:52 <gamegoblin> Just Error sounds like some FP band name
23:07:56 <gamegoblin> brb trademarking
23:08:28 <fxr> gamegoblin: `Either myErr ()` is isomorphic to `Maybe myErr` imho
23:08:33 <johnw> oddly, Vector.Mutable.unsafeRead/Write are slower for me than the safe variants
23:10:05 <fxr> gamegoblin: you may want to create your own datatype which looks like a Maybe but different naming.
23:10:15 <MP2E> fxr : Isn't it a little different though? Nothing <> Just '' == Nothing whereas Right () <> Right 'blah' == Right 'blah'? In other words if you had a sequence of events and Nothing represented true, only one thing would actually have to succeed
23:10:35 <MP2E> this is assuming there's a sequence of events, of course heh
23:10:55 <zorg24> I'm trying to help a friend learn programming any idea for for languages, tutorials, MOOCs, etc (he's already done a bit of Java a few years back, but didn't get to OO stuff)
23:11:00 <zorg24> any ideas?
23:11:32 <MP2E> Nothing represented success*
23:11:49 <MP2E> zorg24 : well... umm... *channel name*
23:12:08 <MP2E> I found Haskell to be pretty easy to use but honestly I learned my first language so long ago that I'm not sure how good it would be for someone completely new
23:12:49 <zorg24> MP2E I think its a bit to ummm abstract for beginners
23:13:19 <zorg24> also imagine how painful it would be if they then had to learn almost any other language
23:13:26 <MP2E> hahah fair point
23:13:34 <gamegoblin> zorg24: a lot of college intro classes these days are python… I’d recommend that I guess.
23:13:49 <gamegoblin> Lots and lots of libs and resources for it
23:14:14 <zorg24> gamegoblin: not sure how I feel about the first language someone learns being dynamically typed, that's my only hesitation
23:14:39 <dcousens> Hey all, I tried hoogle, but was wondering what you might call this function:     [(a, b, c)] -> [([a], b, c)]         where it groups all the 'a's based on overally equality
23:15:07 <begriffs> Can someone look at this short gist and see what I might be doing wrong? The last line with liftIO fails typecheck. https://gist.github.com/begriffs/b03bb778de1c42c20925
23:15:24 <gamegoblin> zorg24: I’m right there with you, but just learning basic control flow, functions, etc, you won’t really have to fool with any intense dynamic behavior
23:15:48 <d3m1g0d-> zorg24:  yea, my concerns are exactly the same. It looks to me that they're educating practitioner developers with shaky foundations
23:15:55 <MP2E> all the languages I've learned kinda suck so it's difficult to recommend them. There's Ye Olde C which is reliable but.. ancient
23:16:07 <MP2E> There's C++ which is C but with 20 years of hax and oop stuff
23:16:11 <gamegoblin> zorg24: python is nice for learning because of minimal boilerplate. With Java, when you learn it, you have to put your stuff inside this main function, which is wrapped in another class, and you don’t quite know why at first, or what a class is, etc.
23:16:17 <MP2E> and then there's the crazy languages newbies shouldn't learn
23:16:24 <MP2E> hehe
23:16:28 <gamegoblin> zorg24: With python I can just make a file containing “print ‘hello world” and it will run
23:16:33 <gamegoblin> no boilerplate at all
23:16:54 <gamegoblin> So yes, it doesn’t teach good, solid programming practices
23:16:59 <d3m1g0d-> gamegoblin: yea but imagine how a novice developer feels. He uses something which works, but he has no idea how it works
23:17:02 <gamegoblin> but it gets you in the mindest of control flow, functions, etc
23:17:18 <zorg24> gamegoblin: print("hello world") he's definitely learning python 3 if we use python
23:17:36 <gamegoblin> d3m1g0d-: I do understand, and I remember when I tried to learn Java I had no idea what all the crazy keywords meant
23:17:37 <zorg24> but yeah I wish we had a statically typed python
23:18:05 <zorg24> gamegoblin: yeah especially static that one gave me so much trouble
23:18:44 <gamegoblin> So my basic position is, for teaching basic functions, ifs, loops, python is good. No boilerplate, compiling, etc. You just download python and it works.
23:18:55 <gamegoblin> Once you get the hang of that, introduce Java or C(++)
23:19:18 <Welkin> no
23:19:21 <Welkin> avoid java and c++
23:19:24 <Welkin> go straight for haskell
23:19:58 <fxr> begriffs: choud you also share the error
23:20:00 <glguy> begriffs, you seem to be using the wrong liftIO
23:20:09 <gamegoblin> Did anyone here learn Haskell as their first language? I’ve actually never met one who did. It’d be an interesting experiment, but if it failed I’d be sad for putting someone off programming for the sake of an experiment.
23:20:19 <Welkin> there are
23:20:21 <gamegoblin> I only learned Haskell after 10 years of imperative/OO
23:20:24 <d3m1g0d-> Different views, I believe in the old-school where they just throw you into C so you get out with really solid foundations. In my opinion this python approach for novice developers is for the weak-minded
23:20:29 <Welkin> at many universities it is the first programming class
23:20:29 <glguy> ?index liftIO
23:20:29 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
23:20:53 <zorg24> Welkin: I think that they should still learn OO at some point
23:20:56 <begriffs> fxr: Here is the error https://gist.github.com/begriffs/18f3ea13416a7cd49ae4
23:20:59 <fxr> begriffs: you may want to add `import Control.Monad.IO.Class`
23:21:07 <begriffs> (thank you for looking at this!)
23:21:07 <glguy> Those are probably all the same
23:21:07 <Zekka> gamegoblin: I know someone who learned Haskell as a first language, but we don't know each other too well
23:21:14 <Welkin> I started with assembly, digital logic, and C
23:21:24 <Zekka> She started with algebra and later a friend got her into Haskell
23:21:26 <Welkin> then learned python and javascript, and then haskell
23:21:27 <d3m1g0d-> Welkin:  you've been thought the rigght way
23:21:38 <d3m1g0d-> *tought
23:21:45 <Welkin> taught*
23:21:52 <zorg24> Welkin: what school did that?
23:21:57 <gamegoblin> My route: BASIC -> ASM -> Python -> C -> Java -> Haskell (with variants of all of those languages in between, C++, etc)
23:22:00 <d3m1g0d-> *taught, not my day
23:22:08 <Welkin> oh, I learned javascript and haskell on my own
23:22:09 <jle`> oh i learned BASIC first too
23:22:17 <jle`> o/
23:22:20 <gamegoblin> BASIC wrecked me so hard
23:22:28 <zorg24> I know that UT used to teach Haskell but I think now they teach Java....
23:22:34 <gamegoblin> It was so hard to get out of the BASIC mindset
23:22:51 <d3m1g0d-> I've been successfully avoiding javascript for almost a decade now.
23:23:09 <Zekka> It's strange to me how there don't seem to be a lot of beginner-targeted languages that take the repl terribly seriously
23:23:20 <zorg24> java -> python -> ruby -> C++ -> Haskell
23:23:29 <Zekka> Python and Ruby are unusually strong there but you don't write full programs from the repl as you do in i.e. Smalltalk
23:23:29 <johnw> Zekka: LOGO
23:23:41 <Zekka> johnw: Smalltalk and LOGO were actually the langauges I had in mind
23:23:43 <zorg24> still learning Haskell though :D
23:24:58 <Zekka> I've got a young cousin that I'd like to show programming to at some point but I'm not sure how I ought to introduce him
23:25:12 <zorg24> oh everything but Java and C++ was self taught
23:25:14 <Zekka> I feel like I might end up having to write something myself
23:25:19 <d3m1g0d-> believe in the old-school. Throw him into ASM / C
23:25:26 <Zekka> d3m1g0d-: He's five!
23:25:32 <d3m1g0d-> and i was 9
23:25:34 <d3m1g0d-> he has 4 more years
23:25:46 <Zekka> I'd like to give him something that at least gives him concrete objects to manipulate (as in Logo)
23:25:52 <zorg24> Zekka: why not use scratch?
23:25:55 <Zekka> VB4 took enough of my patience when I was a kid
23:26:00 <Zekka> zorg24: That's MIT's smalltalk for kids, isn't it?
23:26:10 <gamegoblin> Zekka: something like that
23:26:14 <zorg24> yeah someyhing like that
23:26:21 <Zekka> That might not be a bad idea
23:26:50 <Zekka> I get a gut badfeeling about languages like that because they don't always express the things I think are the most important about programming languages, but I can't exactly toss him into Haskell
23:26:56 <zorg24> its nice because they can easily make pictures move on the screen and stuff
23:27:05 <Zekka> types are probably a few abstraction levels beyond what he can reasonably be expected to learn
23:27:31 <zorg24> Zekka: yeah just worry about get them interested in programming at that age
23:27:46 <zorg24> a lot of it probably won't even stick
23:27:56 <Welkin> I would avoid C
23:28:12 <Zekka> It's cute: from what his mother tells me he likes numbers but hates letters
23:28:13 <Welkin> in fact, you can skip C and just learn assembly and a higher level language
23:28:23 <d3m1g0d-> why void C ?
23:28:27 <Welkin> it is awful
23:28:39 <begriffs> fxr: omg, the Control.Monad.IO.Class made it work. How is that liftIO different from the one in GHC.IO ?
23:28:42 <Welkin> assembly represents the low-level ideas better
23:28:50 <Welkin> and something like python represents high level ideas better
23:28:58 <Zekka> Why would you teach assembly at all to a kid that age? You're manipulating things that couldn't possibly mean anything to you unless you understand computer architecture, and only then getting to manipulating things that look concrete
23:29:25 <zorg24> Zekka: I don't think that was meant for you
23:29:31 <d3m1g0d-> Welkin: do you know what it takes to make a function call in assembler ? People are actually making them in C/C++ and copy-pasting what the compiler spits out
23:30:00 <Zekka> I'll clarify: personal background is having done a few hobby projects in C and writing a bootloader in ASM
23:30:05 <Zekka> (x86, specifically)
23:30:17 <Zekka> so I'm not really experienced at all in the languages
23:30:46 <Zekka> but I feel like by teaching an assembly language or C you're introducing even more indirection between 'manipulating concrete things' and 'writing code' than Haskell does with types
23:31:06 <mayski> buy taht kid a C-64 and do 6502 asm! the *only* true way
23:31:09 <zorg24> also why write in ASM when you can use LLVM and be cross platform
23:31:11 <Zekka> you're also introducing a lot of potential for things to fail in nonobvious, undiscoverable ways
23:31:23 <Zekka> hey my code is segfaulting I have no idea why because I'm ten
23:32:13 <zorg24> Zekka: he's being facetious, I hope
23:32:17 <Welkin> Zekka, actually asm is very contrete
23:32:22 <Welkin> much more so than any other language
23:32:28 <MP2E> at least in Haskell you'd get a type error about being unable to use Haskell because you're ten
23:32:32 <MP2E> ;0
23:32:33 <MP2E> ;) *
23:32:35 <Welkin> you are manipulating the computer, which is essentially a state machine
23:32:35 <Zekka> Welkin: But not about the objects a kid that age will know how to/want to be able to manipulate
23:32:42 <Welkin> it is
23:32:45 <mayski> MP2E: :D
23:32:50 <Welkin> kindergarteners have been shown to invent binary themselves
23:32:51 <Zekka> I mean, yes, you are manipulating the hardware, but getting from there to 'perceptibly doing something' is no mean feat
23:33:03 <Welkin> a computer is very simple
23:33:11 <Welkin> well, for a simple computer
23:33:26 <Welkin> a child could build one out of logic gates on a breadboard
23:33:28 <Zekka> Welkin: Yes, but doing anything useful or interesting with a computer is comparatively difficult
23:33:39 <Welkin> they can build a calculator
23:33:42 <Zekka> If the computer itself is the object of interest then maybe I can understand
23:33:55 <Zekka> but I think that's a difficult assumption to make
23:34:34 <d3m1g0d-> dude .... what the hell are you talking about ... do you understand the concept between analog and digital circuits ? ... a child building a computer on the breadboard
23:35:15 <zorg24> if they ask how a computer works then by all means have them make a calculator with logic gates, but otherwhise stick to something like scratch
23:35:18 <Zekka> d3m1g0d-: "Hi, I'm ten and I like pac-man and minecraft. Why are you telling me about registers and memory?"
23:35:19 <d3m1g0d-> he can build an ALU at best
23:35:35 <begriffs> Does anyone know how the liftIO in base is different from that in transformers?
23:35:42 <d3m1g0d-> because instead on a limited breadboard, you can build one in minecraft
23:35:47 <d3m1g0d-> it is a game that he loves ...
23:35:58 <Zekka> Why would he want to build a breadboard in minecraft?
23:36:05 <Zekka> er, rather, a processor in minecraft?
23:36:07 <d3m1g0d-> build a computer in minecraft
23:36:09 <MP2E> Zekka: I did
23:36:10 <MP2E> I was bored
23:36:16 <MP2E> not a full PC, but an ALU
23:36:25 <zorg24> d3m1g0d-: yeah that's why I said calculator since they'll know what that is instead of ALU
23:36:26 <MP2E> 8bit only, I tried 16 but things started getting irritatingly big
23:36:31 <d3m1g0d-> Zekka: cuz you can get him interested in computers in an environment that he loves
23:37:17 <Welkin> d3m1g0d-, all computers are analog
23:37:24 <Welkin> they are only digital by abstraction
23:37:28 <MP2E> i think that would be effective. Really it's all about just capturing their attention. I kinda wish people didn't all know about emulators
23:37:30 <Welkin> what is your point?
23:37:35 <MP2E> I was first shown a PC emulator when I was 11 and it blew my freakin mind
23:37:37 <zorg24> d3m1g0d-: meh don't have him make a computer just teach him some basic redstone that way he'll actually make something on his own in the game
23:37:39 <MP2E> it's why I started programming in fact
23:37:48 <MP2E> 'computers are the same as other computers... they just run at different speeds?!?'
23:37:54 <MP2E> it was like magic :P
23:38:13 <Zekka> To me it just seems like this approach is analogous to saying "you like to draw? Let's do some graph theory!"
23:38:35 <Zekka> just involving things he likes without somehow engaging his interest in them doesn't seem to me like it would necessarily be enough to hold his attention
23:39:05 <Welkin> learning how a computer works feels like learning the secrets of the universe
23:39:10 <zorg24> Zekka: you can teach graph theory to kids, (actually probably would be better than making them memorize times tables...)
23:39:14 <d3m1g0d-> dude he is comfortable in minecraft, show him some basic gates, then introduce the clock
23:39:18 <Welkin> why would kids *not* love it?
23:39:26 <MP2E> ^ :>
23:39:44 <Zekka> zorg24: I actually started from there beause I was considering drawing some mazes and asking him questions about distance using them
23:40:08 <Zekka> things like 'if you have to pass six corners to get here, how many corners do you have to pass to get to this further one' and otherwise having him think about graph traversal
23:40:32 <Zekka> but I don't necessarily think he'd find questions like that particularly interesting
23:40:41 <zorg24> d3m1g0d-: exactly and show him how it can intereact with the world that way he's motivated to make something on his own (or ask for help)
23:40:48 <Zekka> Welkin: I think we're talking about a different hypothetical kid
23:40:56 <Welkin> however you think a school teacher would "teach", do the exact opposite
23:41:04 <Zekka> you seem to be talking about a hypothetical kid who's interested in computers for the sake of they're computers
23:41:13 <Welkin> use socratic questioning
23:41:20 <Welkin> it works to teach binary to kindergarteners
23:41:37 <Zekka> while I'm talking about one who's interested in the sorts of things he already knows how to manipulate
23:42:15 <Zekka> I don't know which kind he is, although I think the second is a safer assumption
23:42:32 <zorg24> Zekka: he's right socratic questioning is a great way to get interested in things, b/c they love to understand how stuff works
23:43:04 <zorg24> that said I'd still start with something like scratch
23:43:25 <Zekka> I think scratch appeals more strongly to the second kind than the first kind
23:43:48 <Zekka> because it's very abstract, but involves accessible manipulables
23:43:57 <Zekka> I was more like the second kind of kid than the first kind when I learned
23:44:18 <Welkin> here is a secret
23:44:20 <Zekka> and I don't think computers would have held my interest very long if I'd been told to start with architectural concepts
23:44:23 <Welkin> children are abstract thinkers
23:44:39 <Welkin> they are far more creative than most adults
23:44:52 <MP2E> kids are RankN polymorphic *shot*
23:45:26 <zorg24> its mainly b/c adults tend to have far more biases about the way things work or should work
23:46:13 <zorg24> you'll find that some of the smartest people historically are those who seem to ignore those or even actively go against them
23:46:32 <d3m1g0d-> despite everything I believe that you should trust the old school
23:46:48 <Welkin> what is "the old school"?
23:47:05 <Zekka> I think he's referring to 'start with an assembly language and an easily-explainable processor architecture'
23:47:28 <ReinH> There are a couple good books that do that
23:50:01 <zorg24> that is one approach, you can also make the case that something like scratch is better b/c its more engaging and more likely that'll make something on their own (and hopefully continue to pursue programming)
23:50:14 <Zekka> zorg24: Which is sort of what I'm getting at
23:50:30 <zorg24> I think either could work
23:50:30 <Zekka> He already knows how to manipulate things similarly to how he would be manipulating things in Scratch
23:50:39 <Zekka> there's an obvious spatial analogue right there
23:50:53 <Zekka> I could possibly try exposing him to both and seeing if he picks up on anything in particular
23:51:16 <Zekka> that is, something like Scratch and something like an assembly language
23:51:21 <zorg24> I suspect the scratch route will be easier
23:51:30 <d3m1g0d-> I don't think you should expose yourself in front of kids
23:51:40 <Zekka> although I still feel like it would be possible to convey some of the positive features of an assembly language in something that's not actually an assembly language
23:52:00 <Zekka> i.e. a lisp machine or something else that fails gracefully and tells you how you're screwing up
23:52:36 <zorg24> that would be nice
23:53:09 <Zekka> Although the disadvantage is that a lisp machine is harder to explain than a processor
23:53:22 <Zekka> you can build a simple adder in Minecraft, but you probably can't build anything that looks like a Lisp machine
23:53:50 <zorg24> yeah a Lisp machine would be really hard
23:54:25 <zorg24> frankly I don't think you should have him make circuits in minecraft
23:55:03 <Zekka> Personally I think Minecraft is a bad environment for that kind of thing, mostly because I still find redstone really confusing and hard to work in even if I understand conceptually what I'm trying to build
23:55:07 <zorg24> if you want to teach him digital logic just get a breadboard, some switches, LEDs, and logic gates
23:55:17 <Welkin> breadboards with logic gates and LEDs is much more fun
23:55:34 <Zekka> I remember when my grandparents bought me a breadboard with some ICs I somehow fried it
23:55:35 <d3m1g0d-> Zekka:  you're just bad at the game
23:55:55 <zorg24> then you can show him redstone and how it can interact with the game
23:56:03 <Zekka> d3m1g0d-: I'm not very good at computer games in general.
23:56:10 <d3m1g0d-> I had a fully operational 8 bit processor in less than a week
23:56:26 <Zekka> d3m1g0d-: I'll often find I've literally boxed myself in.
23:56:39 <Zekka> and I can't figure out where I'm supposed to run a wire
23:57:03 <Zekka> maybe I should find a repeating pattern that doesn't have that problem and hack out an FPGA
23:57:08 <d3m1g0d-> than thank god that ECEE was not ur major in college ?
23:57:14 <d3m1g0d-> (trololol, just kidding )
23:57:22 <zorg24> routing can be really hard in minecraft
23:57:26 <Zekka> I'm actually a sophomore, undergrad
23:57:41 <Zekka> for all I know it may end up being, although it probably won't
23:57:59 <d3m1g0d-> zorg24:  it's so hard, that it's actually NP-Hard in real life too
23:58:00 <d3m1g0d-> :D
23:58:35 <zorg24> yeah, and honestly its worst in minecraft then real life...
23:59:42 <zorg24> I hate the way redstone connects
