00:04:11 <kvanb> joelteon: I keep getting told by well respected people that helm is bad
00:04:20 <joelteon> huh
00:04:21 <joelteon> I don't
00:04:27 <joelteon> but I haven't asked
00:04:40 <joelteon> did they say anything more specific?
00:04:46 <kvanb> because it's not "real FRP"
00:04:52 <kvanb> and netwire is more performant + better abstractions
00:05:05 <joelteon> oh, ok
00:05:09 <joelteon> makes sense
00:05:17 <jle`> not frp is not bad
00:05:26 <jle`> elm isn't frp, and it's pretty awesome
00:05:34 <joelteon> bad performance is bad, I assume
00:05:48 <jle`> FRP has its domain of usage, and non-FRP stuff does as well :)
00:05:51 <jle`> bad performant is bad though
00:05:54 <joelteon> no idea what helm vs. netwire is actually like
00:05:58 <joelteon> I have no numbers
00:06:15 <joelteon> did the guy write his own netwire-like backend instead of using an existing one?
00:07:28 <kvanb> I believe so
00:07:34 <joelteon> well, that seems silly
00:07:36 <kvanb> sucks to be the guy with the nick so
00:08:02 <joelteon> did you write it?
00:08:21 <kvanb> did I?
00:08:23 <kvanb> no.
00:08:27 * hackagebot machinecell 1.2.0 - Arrow based stream transducers  http://hackage.haskell.org/package/machinecell-1.2.0 (HidenoriAzuma)
00:08:27 * hackagebot simple-pipe 0.0.0.0 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.0 (YoshikuniJujo)
00:09:18 <jle`> i just realized that i don't know anything about helm
00:10:03 <kvanb> I cant figure fuse out
00:10:15 <kvanb> the types are just confusing as hell.
00:11:48 <kvanb> ( http://hub.darcs.net/ertes/fuse )
00:12:42 <jle`> kvanb: if it helps, the author hangs out at #haskell-game :)
00:12:51 <jle`> he goes by mm_freak
00:13:03 <kvanb> hes afk I think
00:13:20 <jle`> ah
00:13:32 <d3m1g0d-> > []:3
00:13:33 <lambdabot>  No instance for (GHC.Show.Show t0)
00:13:33 <jle`> he is usually really good about answering any questions in a great deal of depth
00:13:33 <lambdabot>    arising from a use of ‘M599780442645323682230766.show_M5997804426453236822...
00:13:33 <lambdabot>  The type variable ‘t0’ is ambiguous
00:13:33 <lambdabot>  Note: there are several potential instances:
00:13:33 <lambdabot>    instance [safe] GHC.Show.Show
00:13:40 <d3m1g0d-> that happens cuz of the right-associativity ?
00:13:56 <jle`> d3m1g0d-: it happens because it's the wrong type
00:13:59 <jle`> :t (:)
00:14:00 <lambdabot> a -> [a] -> [a]
00:14:05 <joelteon> I should probably tell bos that criterion builds fine without the parsec dependency
00:14:18 <jle`> (:) takes an element on the left side and a list of that element on the right side
00:14:31 <jle`> so in this case, [] is your element...but 3 is not a list of lists
00:14:49 <jle`> or well, not by default :)
00:15:42 <jle`> (any Applicative can be made a "lawful" instance of Num, but there is no list instance of Num in most normal haskell code)
00:16:00 <d3m1g0d-> jle`: thanks.
00:20:57 <jle`> is there a typeclass with just extract, w a -> a ?
00:21:28 <jle`> ...and is comonad stronger than just extract and fmap ?
00:21:55 <jle`> oh yeah you need duplicate
00:26:24 <Tjr> Hi, I'm checking the comonad laws as the exercise in Gabriel's tutorial. My solution needs to apply the definition of lambdas and "extend" to the arguments of other functions. Why is that allowed? http://lpaste.net/107739
00:28:02 <Tjr> s/to the arguments/inside the arguments/
00:33:59 <Tjr> Picture the case that "s1" or "s2" concats its argument function with "reverse".
00:37:10 <rio> Tjr: why would applying definitions be not allowed?
00:38:02 <Tjr> rio: It's only allowed if we can be sure the outermost function doesn't mangle the way its arguments are processed.
00:39:01 <Tjr> rio: So the question is, how is that excluded?
00:40:17 <Tjr> rio: I put a candidate for a counterexample in the lpaste, but I'm not sure if it really is one
00:50:54 <rio> Tjr: what do you mean by mangling things? i don't think that's a thing
00:52:48 <Tjr> If I could provide an example, then I'd have already proved that it's now allowed
00:53:01 <Tjr> however, this should capture the spirit:
00:53:53 <Tjr> s1 func = if (funt takes longer than 10 milliseconds to evaluate) DefaultOptions  else []
00:54:00 <Tjr> s1 func = if (func takes longer than 10 milliseconds to evaluate) DefaultOptions  else []
00:54:46 <Tjr> Of course, a pure function cannot time its argument. The challenge is to prove that this kind of problem (and not only my example) is impossible in general
00:56:15 <dfeuer> @tell rasfar I did some Criterion benchmarking and the results are very clear. The version of inits using reverse is a little faster than the one that builds up functions, and both of them are much, much, *much* faster than the version in Data.List. I sent an email to the libraries list:  http://www.haskell.org/pipermail/libraries/2014-July/023291.html
00:56:15 <lambdabot> Consider it noted.
01:01:30 <rio> Tjr: what's the type of that s1 supposed to be? you already said it, purity tells you that the result is always the same when the input is the same
01:01:51 <Tjr> rio: did you take a look at the lpaste?
01:02:19 <rio> a quick look, but it's too much to go through it all right now
01:02:40 <rio> if you can come up with a minimal example of what your question boils down to, i might be able to help
01:03:53 <transfuturist> I'm getting the "Unknown PEi386 section name `.idata$4'" error, even though I've fixed the ldscripts in ghc's mingw
01:04:03 <transfuturist> I don't know what else I can do, exactly.
01:06:19 <dfeuer> Who was telling me yesterday about why  map f . head  is faster than  head . map f ?
01:07:09 <jle`> ...is it?
01:07:37 <Tjr> rio: the question is how to prove that there exists no such minimal example
01:08:45 <rio> Tjr: whenever <expression1> is equivalent to <expression2>, you can conclude "f (<expression1>)" is equivalent to "f (<expression2>)"
01:09:01 <Tjr> rio: I doubt that
01:09:08 <rio> why?
01:09:32 <kvanb> yeah, you can
01:09:50 <Tjr> because equivalent really means that the compiler reduces expression1 and expression 2 to the the same thing
01:10:01 <Tjr> howver, the compiler doesn't reduce them. It instead starts with f
01:10:05 <Tjr> And f could do anything
01:10:23 <rio> the compiler is not involved in the discussion of equivalent statements
01:10:27 <kvanb> no side effects because I see no >>=
01:10:31 <rio> it's about the language definition
01:10:38 <Tjr> in particular, f could transform expression1 to something that  get a different value assidned
01:10:53 <rio> no, it can't
01:10:59 <Tjr> sure it can
01:10:59 <kvanb> expression1 = expression2
01:11:01 <kvanb> how is that possible
01:12:34 <Tjr> kvanb: expression1 = expression2 >> that already evaluates expression2 , which eliminates the problem. But we don't have that in the lpaste: expression2  is unevaluated.
01:13:24 * hackagebot simple-pipe 0.0.0.1 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.1 (YoshikuniJujo)
01:13:49 <Tjr> @undefine
01:13:49 <lambdabot> Undefined.
01:13:56 <Tjr> @let x = x:x
01:13:57 <lambdabot>  .L.hs:146:5:
01:13:57 <lambdabot>      Ambiguous occurrence ‘x’
01:13:57 <lambdabot>      It could refer to either ‘L.x’, defined at .L.hs:146:1
01:13:57 <lambdabot>                            or ‘Debug.SimpleReflect.x’,
01:13:57 <lambdabot>                               imported from ‘Debug.SimpleReflect’ at .L.hs:11...
01:14:24 <tdammers> dfeuer: idk, but I would assume that it's not
01:14:27 <Tjr> @undefine
01:14:27 <lambdabot> Undefined.
01:14:46 <kvanb> what you describe only matters if there is unsafePerformIO or other stuff involved
01:14:47 <Tjr> @let f x = f x:x
01:14:48 <lambdabot>  .L.hs:149:7:
01:14:48 <lambdabot>      Ambiguous occurrence ‘f’
01:14:48 <lambdabot>      It could refer to either ‘L.f’, defined at .L.hs:149:1
01:14:48 <lambdabot>                            or ‘Debug.SimpleReflect.f’,
01:14:48 <lambdabot>                               imported from ‘Debug.SimpleReflect’ at .L.hs:11...
01:15:01 <Tjr> @undefine
01:15:02 <lambdabot> Undefined.
01:15:10 <dfeuer> Whoever it was knows a lot more than me and made a good argument. I think it may even have been edwardk, but I don't remember.
01:15:30 <dfeuer> It could also have been Cale.
01:15:30 <rio> kvanb: well then <expression1> and <expression2> would not be equivalent, would they?
01:15:40 <edwardk> dfeuer: it was me
01:15:48 <kvanb> > let y = 1 : y in y
01:15:49 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
01:15:54 <kvanb> > let y = y : y in y
01:15:55 <lambdabot>  Occurs check: cannot construct the infinite type: a1 ~ [a1]
01:15:55 <lambdabot>  Relevant bindings include y :: [a1] (bound at <interactive>:1:5)
01:16:10 <dfeuer> Ah! Well, edwardk, I don't remember the details, but it inspired http://www.haskell.org/pipermail/libraries/2014-July/023291.html
01:16:21 <kvanb> But I do want an infinitely nested lazy infinite list!
01:16:23 <kvanb> q_q
01:16:27 <edwardk> yeah was just reading that
01:16:30 <dfeuer> *nod*
01:16:37 <edwardk> and loaded up the code to see if i could find strictness differences
01:16:45 <asterblaster> > let p  = 2 : p in p
01:16:46 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
01:16:48 <edwardk> how much of a benchmark difference is it?
01:16:51 <edwardk> you allude to benchmarks
01:16:59 <edwardk> but i don't see the results in your post
01:17:03 <asterblaster> I'm speachless
01:17:06 <edwardk> and i'm too lazy to run criterion myself ;)
01:17:09 <dfeuer> Between the base version and either? Huge.
01:17:19 <edwardk> numbers? =)
01:17:25 <dfeuer> Hahaha.
01:17:27 <dfeuer> One sec....
01:20:02 <Tjr> kvanb, rio: Upon further thinking, I believe you're right about the end result of the computation and wrong about the benchmarked time.
01:20:36 <rio> i never said anything about times, so i don't think i can be wrong about that
01:20:36 <Tjr> kvanb, rio: But this is just intuition. A proof would be much better.
01:21:11 <rio> Tjr: the functions are pure. same inputs, same outputs.
01:21:22 <jle`> asterblaster: :)
01:21:31 <Tjr> rio: no, it's not the same input
01:21:35 <Tjr> rio: that's the entire point
01:21:59 <Tjr> where same is taken in terms of the abstract syntax tree
01:22:04 <asterblaster> jle`: ;]
01:22:04 <rio> (\x -> f x) is the same input as f
01:22:40 <rio> because (\x -> f x) y = f y, for all y
01:23:16 <Tjr> Newtype Wrapper x = Wrapper x
01:23:26 <Tjr> Then Newtype undefined is the same as undefined
01:24:02 <Tjr> but "const 3 (Newtype undefined)" is different from "const 3 undefined"
01:24:25 <Tjr> errr, "const 3 (Wrapper undefined)"
01:24:38 <rio> well Wrapper k is not the same as k
01:24:51 <Tjr> different types, same value
01:25:27 <Tjr> "same value" makes sense because undefined is a legal value for any type
01:27:18 <rio> well if x and y have different types, they are not the same thing
01:27:58 <rio> and in fact, you can't apply the same function on them
01:28:33 <rio> fix the type of const 3 and your example doesn't work anymore, because on of the calls has the wrong type
01:30:36 <edwardk> ok, 7x is pretty good
01:30:52 <edwardk> the key will be seeing whether henning's objection has teeth
01:31:02 <johnw> hey edwardk!
01:31:07 <edwardk> heya
01:31:22 <edwardk> what has you awake at this godforsaken hour? =)
01:31:34 <johnw> heh, this is early for me
01:32:40 <jle`> edwardk aren't you in boston!
01:32:49 <jle`> it's like 4:30 for you?
01:32:51 <edwardk> i am
01:32:58 <jle`> i guess it's a friday night
01:34:48 <Tjr> rio: I'm trying to showcase the kind of corner case that might give rise to a counterexample. Did you look at the lpaste, or at least try to prove Gabriel's challenge exercise yourself?
01:35:47 <Tjr> s/at least/alternatively/
01:36:18 <jle`> is x <- y considered a definition?
01:36:25 <jle`> in a do block?
01:36:28 <jle`> no, right?
01:36:42 <johnw> x becomes an argument to a lambda abstraction
01:36:57 <johnw> so it binds the result of y to a value, if you think of that as a definition
01:37:01 <johnw> to a name*
01:37:19 <jle`> definition has a meaning though, in the report
01:37:39 <jle`> i was wondering because -Wall calls it a definition --- 'defined but not used'
01:38:57 <rio> Tjr: let me read the relevant part of the blog post first, then i'll go do the exercise and come back to you, might take some time :>
01:44:17 <Tjr> rio: I think part of my confusion was mixing up constructor functions with ordinary functions, and mixing up "f func value /= f result;  where  result = func value" with "f (func value)"
01:44:32 <Tjr> brb
02:24:25 <joshkirklin> does anyone know of a package that can show numbers in words? e.g. 4 goes to "four", 19 goes to "nineteen", 202 goes to "two hundred and two"
02:25:49 <Maxdamantus> might be worth noting that the last number is usually "two hundred two" in AmE dialects, I think.
02:28:29 * hackagebot pipes-shell 0.1.2 - Create proper Pipes from System.Process  http://hackage.haskell.org/package/pipes-shell-0.1.2 (kbrei)
02:32:48 <benmachine> Maxdamantus: but it is not in certainly at least the UK
02:33:07 <Maxdamantus> Yes. They say what he said in the UK.
02:33:29 <Maxdamantus> Just pointing out localisation problems with trying to spell numbers.
02:34:00 <joshkirklin> kind of interesting actually, I never knew that
02:34:55 <rio> Tjr: okay, are you still around?
02:35:17 <Maxdamantus> It's not something you'd normally notice, since people don't usually write large numbers like that, and when you hear them in media, it could just be a case of reducing the /ənənd/.
02:36:30 <wabisabi> Maxdamantus: what's /ənənd/
02:36:31 <jle`> i really didn't expect (any . any) to work like it does
02:36:38 <jle`> i mean it makes sense but
02:36:43 <jle`> it's kind of too cool
02:36:54 <Maxdamantus> wabisabi: ‹-and and›
02:37:19 <Maxdamantus> wabisabi: two thous‹and and› four
02:37:30 <dv-> :t any . any
02:37:31 <lambdabot> (a -> Bool) -> [[a]] -> Bool
02:37:50 <jle`> any . any works "like" map . map
02:37:59 <jle`> it's weird :|
02:38:30 <jle`> you can pile as many anys as you want to go arbitrary deep
02:38:34 <jle`> :t any . any . any
02:38:35 <lambdabot> (a -> Bool) -> [[[a]]] -> Bool
02:38:40 <benmachine> it's not that weird if you think of 'any' as a way to transform functions
02:38:49 <jle`> ah
02:38:50 <jle`> ooh
02:38:51 <wabisabi> Maxdamantus: i must be jumping right into the middle of a whole world of conversation i am unfamiliar with.
02:38:55 <benmachine> any is a unary function that takes an (a -> Bool) and turns it into an [a] -> Nool
02:38:59 <benmachine> er Bool
02:39:01 <jle`> (a -> Bool) -> ([a] -> Bool)
02:39:02 <jle`> i see
02:39:12 <jle`> the parentheses add a lot of clarity
02:39:26 <jle`> so you just continually transform functions, adding on a layer
02:39:41 <jle`> @free any
02:39:41 <lambdabot> any . (.) f = (.) (any f) . $map
02:40:02 <jle`> @unpl any . (.) f
02:40:02 <lambdabot> (\ g -> any (\ c -> f (g c)))
02:40:16 <jle`> @unpl (.) (any f) . map
02:40:17 <lambdabot> (\ g c -> any f (map g c))
02:40:59 <jle`> \g -> any (\c -> f (g c))   =    \g -> (\c -> any f (map g c))
02:41:08 <lunamystry> hi, I would like a better way to write this: isTodoLine x = or $ map (\y -> isInfixOf y x) todoKeyWords
02:41:23 <jle`> lunamystry: you can use `any`, incidentally
02:41:32 <jle`> any f = or . map f
02:42:19 <lispy> (\y -> isInfixOf y x) = (`isInfixOf` x)
02:42:22 <jle`> isTodoLine x = or . map (`isInfixOf` x) $ todoKeyWords
02:42:34 <jle`> isTodoLine = any (`isInfixOf` x) todoKeyWords
02:42:39 <jle`> er, missing an x
02:43:23 <lunamystry> I am working my way through my first haskell program, thank you very much :-)
02:43:32 <jle`> no problem :)
02:43:53 <jle`> you might have been able to stumble upon any with a hoogle search, perhaps
02:44:03 <jle`> @hoogle (a -> Bool) -> [a] -> Bool
02:44:04 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
02:44:04 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
02:44:04 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
02:44:15 <jle`> boolean blindness, so sad
02:44:39 <lispy> What type could we give it instead of bool?
02:44:51 <jle`> i don't know
02:44:53 <lispy> any :: (a -> b) -> [a] -> [b] ?
02:44:59 <lispy> (that would be map...)
02:45:07 <lunamystry> I saw any but I was tripped by the order so I used the lambda to correct the order
02:45:21 <jle`> i don't know what could be better than boolean there, but
02:45:32 <jle`> that doesn't make booleans a satisfactory solution, i think
02:45:41 <lispy> any :: Monoid b => (a -> b) -> [a] -> b, but then you'd have to pick your monoid instance to reflect conjuction or disjuction
02:45:43 <jle`> i consider just a sad fact of life
02:46:14 <jle`> lispy: and how would you write the type signature of all?
02:46:39 <jle`> oh, i might not have been clear
02:46:45 <jle`> my point was that the type signature of all and any are the same
02:47:18 <lispy> In the monoid version of any they differ by the definition of mappend
02:47:19 <jle`> so searching for one will give you the other
02:47:30 <lispy> ah right
02:47:32 <jle`> lispy: yeah, but they would still have the same type signature
02:47:36 <jle`> hm
02:47:53 <jle`> any :: (a -> Bool) -> [a] -> Any
02:48:03 <jle`> all :: (a -> Bool) -> [a] -> All
02:48:11 <jle`> ...would that be helpful at all?
02:48:21 <jle`> well, the compiler wouldn't be able to enforce it
02:48:44 <MP2E> It sounds to me like you want dependent types :P
02:48:48 <jle`> so...i don't think it serves as anything more than an annotation
02:48:55 <jle`> MP2E: haha.  maybe >_____>
02:49:44 <jle`> oh i could have said any :: (a -> Any) -> [a] -> Any, all :: (a -> All) -> [a] -> All.  but i don't think it makes any difference
02:49:56 <jle`> MP2E: do the current dependently typed languages offer anything like this?
02:50:32 <jle`> that is...if you swapped the definition of `any` with `all`, you'd get a compile error?
02:50:45 <jle`> oh
02:50:52 <jle`> maybe you can do
02:50:54 <MP2E> not sure, I'm going to look actually
02:50:56 * relrod looks at https://github.com/idris-lang/Idris-dev/blob/e803aea54773241451081f82e3799480b22130de/libs/base/Data/Vect/Quantifiers.idr
02:50:59 <jle`> any = foldMap Any
02:51:06 <jle`> no
02:51:23 <MP2E> ooh from the looks of Idris, yes
02:51:25 <jle`> any f = foldMap (Any . f)
02:51:36 <jle`> all f = foldMap (All . f)
02:51:47 <jle`> that way, if you swapped the type signatures, it would not compile
02:51:53 <jle`> er, swapped the implementations
02:52:03 <Maxdamantus> You can specify instances in Idris.
02:52:11 <jle`> or you could even do any = foldMap...and take an (a -> Any)
02:52:12 <Maxdamantus> and define nominal instances.
02:52:31 <Maxdamantus> the (Monad IO) %instance
02:52:33 <jle`> would the idris version be any different than this?
02:52:41 <Tjr> rio: I'm back
02:52:49 <jle`> would it offer more?
02:52:56 <MP2E> jle`: relrod posted a link with any vs all in Idris :P
02:53:12 <jle`> MP2E:  i mean...would tis offer more than the haskell version that i'm proposing
02:53:22 <jle`> any :: (a -> Any) -> [a] -> Any; any = foldMap
02:53:23 <Maxdamantus> It's not really a case of dependent typing though.
02:53:28 <MP2E> Hmm no probably not
02:53:37 <jle`> all :: (a -> All) -> [a] -> All; all = foldMap
02:53:47 <MP2E> This is about as lightweight as a dependently typed problem comes, which means it is very easily simulatable
02:53:52 <jle`> the type signature sort of "determines" the implementation
02:54:01 <rio> Tjr: http://lpaste.net/107744
02:54:25 <jle`> if you swapped the two type signatures...the behavior would swap too.
02:54:35 <jle`> who should i contact to put this into Prelude
02:54:37 <jle`> :P
02:55:54 <MP2E> I guess whoever is on the commitee designing Haskell 2014 :P
02:56:02 <jle`> hm
02:56:02 <Tjr> rio: you did the same thing as I did, except in a different order.
02:56:13 <rio> Tjr: and it all works out fine
02:56:30 <rio> Tjr: and every step is perfectly valid
02:56:32 <Tjr> rio: What I was/am suspicious about, is the transformation from line 1 to line 3
02:56:49 <jle`> if you look at any :: (a -> Any) -> [a] -> Any...and assume that the implementation isn't allowed to "extract" the Any...then can you say that it is impossible for it to act like all ?
02:56:52 <rio> Tjr: you are just applying a definition, it can't go wrong
02:57:14 <Maxdamantus> using named instances and explicit instance arguments, you should be able to write something like: instance [any] Monad Bool where ..; mconcat @{any} [True, True, True]
02:57:18 <Tjr> rio: because the compiler always applies the definition to the first spot
02:57:24 <jle`> hm. you might also have to assume that you aren't allowed to "create" an Any
02:57:30 <Maxdamantus> er, Monoid Bool*
02:58:00 <Tjr> s/spot/slot/
02:58:18 <rio> Tjr: it doesn't matter which definition is applied first
02:58:22 <jle`> Maxdamantus: hm.  sorry, i don't think i know enough about idris to understand :/
02:59:00 <Maxdamantus> in the instance, [any] says that you can refer to that particular instance using the identifier `any`
02:59:23 <jle`> ah
02:59:25 <Tjr> rio: Is there a formal proof that your line1 to line 3 is legal, despite the fact that the compiler doen't work with those slots? We've already had the counterexample of unsafeIO.
02:59:30 <jle`> hm.
02:59:33 <Maxdamantus> and @{any} specifies an otherwise implicit argument (Monoid a) for the polymorphic function.
02:59:45 <jle`> what is the functional difference between that, and the haskell version using newtyped instances?
02:59:57 <lispy> jle`: Any/All are monoids so mempty could be used so I don't think you can assume they don't create it without looking at their internals.
03:00:00 <rio> Tjr: you want a proof for "a = b" implies "f a = f b"?
03:00:34 <Maxdamantus> jle`: probably fewer things to declare.
03:00:46 <Maxdamantus> (don't need to create more types, only instances)
03:00:53 <jle`> Maxdamantus: hm. but would it carry any more compile-time guaruntees?
03:01:43 <Maxdamantus> Dunno.
03:01:44 <Tjr> rio: in the f-example, a and b could be constructors that always return the same result. Therefore, a=b but f a /= f b (the /= is due to  pattern matching).
03:02:10 <Maxdamantus> It means classes become type constructors.
03:02:18 <Tjr> rio: admittedly, "a = b" isn't very true
03:02:20 <jle`> lispy: their mempty could only be used in the context of mappend, so i think the behavior is still guarunteed-ish
03:02:21 <Maxdamantus> so `Monoid Bool` is a type.
03:02:39 <rio> Tjr: if a /= b you can have f a /= f b, of course
03:02:48 <lispy> > mempty :: Any
03:02:49 <lambdabot>  Any {getAny = False}
03:02:59 <lispy> jle`: Any/All provide a context for mempty
03:03:09 <jle`> but if you can't extract the getAny, the only thing you can do with an Any is mappend
03:03:17 <jle`> so you can't get an Any to "behave like" an All
03:03:39 <benmachine> Tjr: when you say "constructors that always return the same result", unless I've misunderstood you that's impossible
03:03:52 <rio> Tjr: but since "extend s b" is DEFINED to be the same as "\opts2 -> s (\opts1 -> b (opts 1 ++ opts2))", you never have /=
03:04:04 <benmachine> Tjr: constructors sort of automatically return different results
03:04:12 <jle`> as in...if i saw any :: (a -> Any) -> [a] -> Any; and all :: (a -> All) -> [a] -> All....i would "know" that any does what it promises, and it can't actually be doing an 'all'
03:04:24 <jle`> ...but only if you assume that the implementations can't access the getAny/getAll
03:04:27 <Tjr> constructors sort of automatically return different results ... yes, that's the crucial point
03:04:50 <Tjr> Thank you for teasing that out.
03:05:01 <jle`> but i guess it can be any _ _ = mempty
03:05:08 <lispy> constructors are injective
03:05:16 <benmachine> right
03:05:16 <lispy> (that's another way to phrase it)
03:05:28 <jle`> but still...the behavior of any and all would have to be 'opposite'
03:06:07 <jle`> you can't get any implementation of `any` to behave like an implementation of `all`.
03:06:38 <lispy> you can't get any implementation of `any` to behave like all implmentations of `all`? ;)
03:06:57 <jle`> haha i wrote that at first but i realized it and added the ``'s >_>
03:07:39 <Tjr> rio: just as an aside, that exampleHistory is pretty funny :-)
03:08:19 <jle`> i was just trying to find a way to formulate any & all in such a way that their type signatures are different, and different enough that you can say possibly meaningful statements about their behavior
03:08:24 <Tjr> (something similar may or may not have happened in vi)
03:08:43 <jle`> ...but only if you assume the implementations don't extract or construct arbitrary Any/All's
03:09:28 <lispy> jle`: right, but I think that being able to introduce/eliminate Any/All arbitrarily via mempty and getAny/getAll that you can't have that guarantee
03:09:29 <jle`> indeed you can say "the result of `any` can *only* be the result of applying the predicate to a possibly empty subset of the list, and seeing if any of the items satisfy the predicate"
03:09:33 <rio> Tjr: what exampleHistory?
03:09:49 <Tjr> from http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
03:10:02 <jle`> lispy: i think you can include mempty
03:10:13 <jle`> you can allow the implementation to use mempty
03:10:39 <lispy> jle`: You could probably use a forall to make this work
03:10:56 <rio> Tjr: i didn't read it all, but yeah, could have been me before knowing how to exit pdflatex
03:11:02 <jle`> and in analoge you can say "the result of `all` can *only* be the result of applying the predicate to a possibly empty subset of the list, and returning true if none of the items in that subset fail"
03:11:18 <lispy> I haven't thought enough about it, but it would have a form like flatten :: (forall b. Monoid b => a -> b) -> [a] -> {- There is where I get stuck -}
03:11:42 <jle`> lispy: that's foldMap
03:11:44 <jle`> isn't it?
03:11:46 <jle`> oh
03:11:48 <lispy> :t foldMap
03:11:49 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
03:12:49 <lispy> what you'd want to do is make it so that flatten has to be polymorphic over the monoid
03:13:07 <lispy> then you know it doesn't introduce or eliminate any specific monoid (I think)
03:13:09 <jle`> isn't foldMap already polymorphic over the monoid?
03:14:01 <lispy> yes it is. It's differently polymorphic over it and it may work for this.
03:14:08 <jle`> hm
03:14:25 <jle`> oh you mean (forall m. Monoid m => a -> m)
03:14:53 <jle`> well... the versions of any and all here *are* just specialized versions of foldMap
03:15:05 <jle`> so if you only ever called foldMap, you'd know that they can't construct or destruct
03:15:05 <lispy> my flatten lets flatten pick the monoid instance, so that's wrong for what we want
03:15:28 <lispy> right
03:15:30 <jle`> if you scrap any/all at all and use foldMap, then you know that the guaruntees must be true
03:15:37 <jle`> just from the type signature of foldMap
03:15:48 <jle`> but foldMap can still only apply the map to a subset of the list
03:16:13 <lispy> Right, but that violates Foldable, right?
03:16:15 <jle`> er i mean.  the implementation of a Monoid m => (a -> m) -> [a] -> m
03:16:18 <jle`> oh
03:16:21 <jle`> yeah, it does
03:16:22 <lispy> Actually, maybe not. I'm not sure about that
03:16:26 <jle`> oh
03:16:29 <jle`> hm.
03:16:34 <lispy> I'd have to check :)
03:17:02 <jle`> well, if we keep it at Monoid m => (a -> m) -> [a] -> m, we could still not guaruntee that the function doesn't drop a part of the list before doing the foldmapping
03:17:25 <jle`> but i think of we keep it at (Monoid m, Foldable t) => (a -> m) -> t a -> m....
03:18:44 <lispy> I believe foldMap is supposed to look at the whole structure
03:18:44 <lispy>     -- | Map each element of the structure to a monoid,
03:18:45 <jle`> ...trying to look up Foldable laws
03:18:45 <lispy>     -- and combine the results.
03:18:48 <jle`> ah
03:19:09 <benmachine> jle`: Foldable support toList, so...
03:19:24 <benmachine> *supports
03:19:51 <jle`> yeah, i was thinking that toList can only reasonably be id for [a], but i couldn't make that into a guaruntee for all foldabls
03:20:08 <benmachine> well but I mean using Foldable doesn't save you
03:20:17 <benmachine> because I can just call toList and then drop some elements anyway
03:20:30 <jle`> but if we never go thorugh list
03:20:36 <jle`> if we keep it as generic as possible
03:20:39 <jle`> :t foldMap
03:20:40 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
03:20:45 <benmachine> but you can't stop me from going through list using only that type signature
03:21:00 <jle`> there is no fromList
03:21:15 <benmachine> that's fine, I'm never called upon to make a 't a'
03:21:50 <jle`> but the function is supposed to be polymorphic over any Foldable you can request
03:22:05 <lispy> jle`: heh, did you see this: all :: Foldable t => (a -> Bool) -> t a -> Bool
03:22:06 <lispy> all p = getAll . foldMap (All . p)
03:22:14 <lispy> jle`: it's defined in there
03:22:43 <benmachine> jle`: right, but any Foldable can be turned into a list, so if I can do naughty things with lists, I can do them with Foldables
03:22:55 <jle`> haha i've been using all/any from Data.Foldable and i didn't noticed it was defined that way
03:23:11 <jle`> benmachine: i don't see what you mean.  you can't do anything over only a selective portion of the Foldable
03:23:21 <jle`> you can't "drop" from a generic Foldable
03:23:37 <lispy> :t \p xs -> all p (toList xs) :: (Monoid m, Foldable t) => (a -> m) -> t a -> m
03:23:38 <lambdabot>     Not in scope: ‘toList’
03:23:38 <lambdabot>     Perhaps you meant one of these:
03:23:38 <lambdabot>       ‘F.toList’ (imported from Data.Foldable),
03:23:45 <lispy> :t \p xs -> all p (F.toList xs) :: (Monoid m, Foldable t) => (a -> m) -> t a -> m
03:23:46 <lambdabot>     Couldn't match expected type ‘(a2 -> m1) -> t2 a2 -> m1’
03:23:46 <lambdabot>                 with actual type ‘Bool’
03:23:46 <lambdabot>     Possible cause: ‘all’ is applied to too many arguments
03:23:58 <benmachine> jle`: it's true that I can't implement drop :: Int -> t a -> t a
03:24:37 <benmachine> jle`: but if all I'm going to do is fold over the result, I *can* choose not to fold over some of it
03:24:51 <jle`> oh
03:24:54 <jle`> i see
03:25:00 <jle`> as in the "end result" is just a single value
03:25:02 <benmachine> yes
03:25:23 <jle`> foldMap f = foldMap f . toList
03:25:26 <jle`> boo
03:25:56 <lispy> benmachine: so, given that type signature I see how you can get to a list and that you could then drop elements or use Prelude.any instead of Prelude.all, but how do you give a value of the right monoid (other than just always giving mempty)?
03:26:28 <benmachine> lispy: foldr mappend mempty (someSubListOf (toList inp))
03:26:39 <benmachine> even somePermutedSubListOf
03:26:50 <lispy> ah right, duh
03:27:08 <jle`> hm i guess the "most guaruntees" we can go is that any/all are any/all over some sublist of the given list
03:27:13 * lispy blames the late hour :)
03:29:15 <lispy> jle`: yes and it would be a pretty simple check to make sure that it is using the whole list
03:29:41 <jle`> but not at the type level, though, right?
03:29:51 <lispy> AFAIK, correct
03:30:36 <lispy> if this were in Agda, you'd probably define another function whose type asserts those other properties
03:32:00 <lispy> all_elements :: all (const True) xs == xs
03:32:51 <jle`> ah that's neat
03:34:20 <lispy> (I'm mixing Haskell and agda and eliding details. In agda having that underscore would be bad because it creates a mixfix operator)
03:34:52 <lispy> anyway, I should go to bed
03:35:08 <jle`> good night lispy , thanks for all
03:35:13 <lispy> thank you!
03:35:17 <lispy> (and good night)
03:36:14 <benmachine> all (const True) xs == xs does not type check
03:37:06 <benmachine> but there are other sensible things you could do
04:07:24 <Wanda21>  Hi! I give you some videos. I hope you like! http://bit.ly/1p3UZCP
04:14:04 <Tjr> Hi, where does the source say that the constructor :% should not exported? http://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-Real.html
04:14:29 <Tjr> it's "module GHC.Real where", no further details what should be exported
04:26:05 <Tjr> > let  { a::Rational; a=1:%3; b = 3:%9 ; f :: Rational -> Integer ; f (n :% d) = n } in ( a == b , f a == f b )
04:26:07 <lambdabot>  Not in scope: data constructor ‘:%’
04:26:07 <lambdabot>  Perhaps you meant one of these:
04:26:07 <lambdabot>    ‘:+’ (imported from Data.Complex),
04:26:07 <lambdabot>    ‘Seq.:<’ (imported from Data.Sequence),
04:26:07 <lambdabot>    ‘Seq.:>’ (imported from Data.Sequence)Not in scope: data constructor ‘:%’
04:26:37 <arancia> :t (%)
04:26:38 <lambdabot> Integral a => a -> a -> Ratio a
04:31:34 <Tjr> arancia: I know, I'm trying to construct an example of a == b and f a /= f b, which thankfully doesn't work with %
04:33:35 <arancia> Tjr: Ah, I didn't see your question. If no export list is given all types are exported without constructors, I think
04:33:46 <Tjr> ok, thanks
04:35:07 <dbbddbdb> Hi!  I have a rather silly question on keeping state in a Hipmunk-based game monad through a StateT transformer.
04:35:19 <dbbddbdb> My game monad type is newtype HA a = HA (ReaderT GameConf (StateT GameState IO) a)
04:35:53 <dbbddbdb> However, whenever I do { st <- get ; step (psSpace $ fromJust $ gsPhysState st) 0.1 ; put st }, my st does not actually change
04:36:22 <dbbddbdb> And my ball (which was supposed to start falling down) hangs at coords [0; 0]
04:37:04 <dbbddbdb> actually no, I do liftIO $ step space 0.1
04:37:29 <rola> is this where lambdabot's @src is from? http://hackage.haskell.org/package/lambdabot-4.3.0.1/src/State/source
04:37:39 <rola> @src sequence
04:37:39 <lambdabot> sequence []     = return []
04:37:39 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
04:37:39 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
04:37:55 <rola> it looks like it!
04:41:50 <Saizan> dbbddbdb: your "put st" at the end restores the old state
04:43:37 * hackagebot codex 0.1.0.3 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.1.0.3 (aloiscochard)
04:43:49 <dbbddbdb> Saizan: but even without it, I still do not get expected changes
04:44:23 <dbbddbdb> Can replacing my Maybe PhysState with IORef PhysState help?
04:45:16 <Saizan> dbbddbdb: shouldn't be needed, and it won't help by itself
04:45:41 <Saizan> dbbddbdb: but you mentioned GameState in your type, how is that related to PhysState?
04:45:55 <Saizan> dbbddbdb: and is setp doing the necessary put?
04:46:01 <Saizan> dbbddbdb: *step
04:47:20 <urhajos> Hi. I just started learning Haskell and I have a pretty basic question. I have some background in set theory so I understand comprehension, but what happens when I do this : [x | x <- [1,2,3,4], x <- [10,20,30,40]] ? I get a list of 16 elements which is a repetition of 10,20,30,40,10,20 etc.
04:49:07 <Saizan> urhajos: shadowing
04:49:11 <mmmm> what do you expect?
04:49:18 <mmmm> the second binding shadows the first
04:50:24 <urhajos> hmm ok. but how come I get 16 elements ?
04:50:35 <mmmm> It can be useful to turn on -Wall to see things like that
04:50:57 <lecoeus> forall i in (1,2,3,4), output (10,20,30,40)
04:53:34 <mmmm> urhajos: What were you expecting?
04:54:22 <urhajos> I don't know what I was expecting. I just wanted to know what haskell does behind the scene and how it came to this result
04:56:20 <mmmm> urhajos: Do a search for "list comprehension desugaring"
04:56:26 <mmmm> there are lots of links
04:56:38 <Saizan> urhajos: list comprehensions are desugared to calls to concatMap, @undo performs the translation for you in lambdabot
04:57:26 <Saizan> most questions on #haskell can be answered by links, but it's also nice to just answer them :)
04:58:01 <bennofs> @undo [x | x <- [1,2,3,4,5]]
04:58:02 <lambdabot> concatMap (\ x -> [x]) [1, 2, 3, 4, 5]
04:58:11 <Saizan> ?src concatMap
04:58:11 <lambdabot> concatMap f = foldr ((++) . f) []
04:58:37 <Saizan> also, concatMap f xs = concat (map f xs)
04:59:06 <urhajos> thanks to you both, this is very much appreciated!
05:05:12 <Javran> hi, could you spot some performance issues with the following code? http://lpaste.net/1507393165659734016 I have no idea how can I optimize a Haskell program.
05:06:26 <jtcwang> what is ur program trying to do?
05:07:28 <jtcwang> Javran, a bit of context might help us here :)
05:07:46 <Javran> jtcwang: I wrote it for an online competition
05:07:55 <Javran> here is the source: https://www.hackerrank.com/contests/lambda-calculi-jul14/challenges/john-and-fences
05:13:33 <jtcwang> so are you having performance issues? what are the score based on?
05:14:54 <Javran> jtcwang: there are 11 testcases, I can only answer 5 of them, others exceeded the time limit (5 sec)
05:15:04 <jtcwang> right
05:16:03 <jtcwang> unfortunately i haven't dealt with the state monad before, but you can always do some profiling
05:16:33 <jtcwang> Javran, ghc -prof -auto-all -o Main Main.hs
05:16:40 <Javran> http://lpaste.net/7135756260116267008 I did some profiling, but I have no idea about how can I read and use it.
05:17:15 <jtcwang> ok so solveM has the majority of your program time
05:17:32 <jtcwang> what you wanna do is split your programme into multiple let blocks
05:18:08 <jtcwang> so that ghc can insert cost-center marks on those let statements
05:18:14 <jtcwang> and see which one is taking the longest time
05:18:40 * hackagebot bustle 0.4.7 - Draw pretty sequence diagrams of D-Bus traffic  http://hackage.haskell.org/package/bustle-0.4.7 (WillThompson)
05:18:40 <Javran> jtcwang: sounds good, I'll try to do so
05:18:54 <jtcwang> Javran, also, run your program with +RTS -s and see how much % of your time is spent on garbage collection
05:19:51 <Javran> so that will be +RTS -s -p right?
05:21:42 <jtcwang> Javran, just -s
05:21:59 <jtcwang> (you can have them both, but they're not required to be used together)
05:23:55 <jtcwang> if you have a high % of GC time, then it's very likely that you have some space leaks in there
05:25:11 <jtcwang> if you suspect a space leak, you can use +RTS -hy to see what's being excessively allocated, then you can try to put some strictness on those
05:25:31 <jtcwang> Javran, good luck
05:27:55 <Javran> jtcwang: should I profile on some large inputs or a small one is fine?
05:29:39 <Javran> jtcwang: here is the -s output: http://lpaste.net/4286156836312186880
05:30:01 <Javran> and this one the profile: http://lpaste.net/4286156836312186880
05:30:18 <Javran> ops wrong one http://lpaste.net/3802241427962855424
05:31:54 <Javran> does 43.5% of GC time considered high?
05:52:17 <trap_exit> I have https://gist.github.com/anonymous/9bc19a2332b68043b107 . I believe ghc.generics will make my life easier. How can I simplify this bioler plate code with ghc generics?
05:59:51 <merijn> trap_exit: I'm not sure about generics, but it looks like pattern guards and view patterns might help (then you can eliminate the "case after match")
06:01:06 <merijn> trap_exit: Additionally, what is the point of the YesSimple/NoSimple constructors?
06:01:17 <merijn> Wouldn't all of the redundancy disappear if you eliminate that?
06:03:15 <rudi_s> Hi. What is the simplest way to load a file with a specific encoding, e.g. iso-latin or utf-8?
06:03:21 <rudi_s> For utf-8 it seems like readFile works, but I'm not sure if that is by accident.
06:04:55 <mmmm> checkout text-icu?
06:05:05 <mmmm> or Data.Text.Encoding
06:06:56 <Ch0c0late> Trying to solve a problem but got stuck. I want to get median of various lists. http://hastebin.com/itihuwefok.coffee
06:07:05 <merijn> rudi_s: readFile guesses from locale, if you know what you want, there are better ways
06:07:09 <slomo> rudi_s: or bytestring and utf8-string if you want to work with normal String
06:07:31 <merijn> rudi_s: Specifically, use ByteString operations to reads bytes from the file and then use Data.Text.Encoding to decode ByteString to Text
06:09:19 <Ch0c0late> There is a sample input and output. http://hastebin.com/lotalemudo
06:10:04 <rudi_s> Thanks, will have a look at text-icu, Data.Text.Encoding only supports latin and utf8 and I might need different encodings in the future.
06:10:20 <trap_exit> I have https://gist.github.com/anonymous/9bc19a2332b68043b107 . I believe ghc.generics will make my life easier. How can I simplify this bioler plate code with ghc generics?
06:10:36 <trap_exit> try_simp mahy return either YesSimp or NoSimp
06:10:48 <trap_exit> I have an expression tree, I want to see if It can be simplified, but I only swant to make one simplificatin per step
06:12:48 <merijn> trap_exit: You might wanna refactor simp_expr into a function + helper
06:13:10 <merijn> trap_exit: This exposes the generic pattern much more clearly, I think: https://gist.github.com/merijn/fe2b87190b9bd88074e4
06:13:12 <trap_exit> merijn: there is this pattern, which goes like this:
06:13:24 <trap_exit> if the data constructor has no Expr child, it's not simpifibalbe
06:13:36 <trap_exit> if it does have an Expr child ... see if any of the childs can be simplified, if so, return the simplified expression
06:13:48 <trap_exit> if all sub Exprs are not simplifiable, try to simplify root expression
06:13:58 <trap_exit> I want ghc generics to capture this logic
06:14:07 <trap_exit> so I don't have these gigantic case statements for each cosntructor that uses Expr
06:15:05 <rudi_s> Hm, either I can't find it or text-icu doesn't support loading from different encodings.
06:16:01 <rudi_s> What do I do if I want to load a file in a non-standard encoding?
06:16:36 <bergmark> rudi_s: text-icu does support it
06:16:46 <merijn> How non-standard are we talking?
06:17:11 <rudi_s> bergmark: Where can I find it?
06:17:17 <rudi_s> merijn: iconv-like
06:17:20 <merijn> bergmark: Where? I don't see it...
06:17:34 <merijn> rudi_s: Actually, take a look at the encoding package? No clue about it's stability, though
06:17:37 <merijn> @hackage encoding
06:17:38 <lambdabot> http://hackage.haskell.org/package/encoding
06:18:06 <bergmark> you need to find the list on http://userguide.icu-project.org/ somewhere
06:18:20 <bergmark> and then you do e.g ICU.open "macintosh"
06:19:55 <rudi_s> bergmark: Ah, thanks. And then I call that on the ByteString I loaded before? (Just making sure I got it right.)
06:20:07 <bergmark> yep
06:20:27 <rudi_s> Perfect, thanks.
06:21:31 <bergmark> text-icu likes so throw runtime errors though so beware :-o
06:21:55 <rudi_s> Thanks.
06:22:00 <rudi_s> Good to know.
06:39:50 <Saizan> just a bit thoughn
06:40:20 <Saizan> misclick there
06:46:12 <kqr> what are the alternatives if you want to make a few http requests (get/post mainly)? i've found http-streams, but is there something better/more convenient?
06:48:40 <Pythonfant> kqr: there's http-conduit and wreq
06:48:55 <Pythonfant> also the http lib (which doesn't support https)
06:49:15 <kqr> and how do i know which one i want?
06:49:16 <Pythonfant> kqr: wreq looks like it might be the easiest to use but I haven't tried it myself
06:49:17 <kqr> haha
06:49:27 <kqr> i always have this problem with haskell libraries for common tasks
06:49:41 <Pythonfant> I tried http-streams and http-conduit and decided I was too stupid for http-streams so I used http-conduit
06:50:10 <kqr> i might have used http-conduit before actually
06:51:00 <kqr> but only the simpleHttp function
06:51:18 <merijn> http-conduit + html-conduit worked well for me in the past
06:53:14 <kqr> hayoo is down :(
06:54:01 <CaptainK> with map's type, I want to read it as, take a function, apply it over a list to get a new list.
06:54:12 <kvanb> hey is it valid
06:54:19 <kvanb> for me to make an instance like this
06:54:36 <kvanb> instance Encoder (p -> Put) where
06:54:45 <kvanb> and then for a function I want to take an encoder
06:54:50 <Pythonfant> kqr: hayoo2 too seems to be up http://hayoo2.fh-wedel.de/
06:54:50 <CaptainK> so map :: (a) -> [a] -> [a]
06:55:04 <CaptainK> but of course that is incorrect
06:55:06 <kqr> CaptainK, (a -> b) -> [a] -> [b], don't you mean?
06:55:27 <kqr> CaptainK, the function takes a value of type a and returns a value of type b
06:55:29 <CaptainK> yes, so what is the -> b part?
06:55:44 <kqr> CaptainK, when you run it on a list you go from a list of only values of type a to a list of only values of type b
06:56:19 <kqr> CaptainK, the function type is (a -> b), for example show :: Int -> String
06:56:23 <kqr> > map show [1, 2, 3]
06:56:24 <trap_exit> merjin: ping
06:56:25 <lambdabot>  ["1","2","3"]
06:56:30 <kqr> :t map show [1, 2, 3]
06:56:31 <lambdabot> [String]
06:56:33 <CaptainK> ok, so map :: (a) -> [a] -> [b] is wrong
06:56:33 <kqr> whoops
06:56:37 <kqr> :t map show
06:56:38 <lambdabot> Show a => [a] -> [String]
06:56:42 <trap_exit> merjin: I'm convinced you're right
06:56:47 <kqr> CaptainK, (a) is not a function
06:56:48 <trap_exit> merjin: thanks for the sugestion of separating out the helper
06:56:49 <CaptainK> because I need to tell the type system what the function applies to?
06:56:50 <kqr> CaptainK, it's just a value
06:57:04 <kqr> CaptainK, you need a -> in the signature for it to be a function
06:57:11 <kvanb> :t (3 :: Int)
06:57:11 <merijn> trap_exit: No problem, it's not obvious until you see solutions like that a couple of times :)
06:57:12 <lambdabot> Int
06:57:16 <kqr> CaptainK, arg1 -> arg2 -> returnvalue
06:57:16 <kvanb> :t (+3)
06:57:17 <lambdabot> Num a => a -> a
06:57:25 <kqr> CaptainK, for example
06:57:30 <CaptainK> but (a ->b) is a function
06:57:33 <kqr> yes correct
06:57:39 <kqr> first argument of type a, return value of type b
06:58:34 <kqr> CaptainK, so for example show :: Int -> String, then the map in map show [1, 2, 3] has type "(Int -> String) -> [Int] -> [String]"
06:58:37 <kqr> CaptainK, makes sense?
06:58:48 <CaptainK> ok so in something else (a) can be a partially appllied function?
06:58:58 <kqr> no, (a) is just a value
06:59:13 <kqr> if you have "partially" applied a function to have just (a) left, then you've fully applied the function
07:00:25 <snyp> Does the module Text.Regex.Posix come with ghc?
07:00:33 <kvanb> CaptainK: the brackets are transparent
07:00:35 <snyp> seems no..
07:00:46 <kvanb> if you have (a) then you have a
07:00:46 <snyp> ah regex-base it is..
07:01:15 <CaptainK> ok, so the b is also a value
07:01:27 <kvanb> ah shit
07:01:29 <kvanb> cabal hell
07:01:36 <kqr> CaptainK, it doesn't *have* to be
07:01:43 <kqr> CaptainK, it's a type variable, really
07:01:49 <kqr> CaptainK, it can contain almost any type
07:01:55 <CaptainK> ah yes
07:02:09 <kqr> so you can imagine something like
07:02:24 <kqr> map :: (a -> b -> c) -> [a] -> [b -> c]
07:02:33 <kqr> where you get a list of functions instead
07:02:46 <kqr> that's still within the type signature of map because if
07:02:53 <kqr> map :: (x -> y) -> [x] -> [y]
07:03:00 <kqr> then x ~ a
07:03:03 <kqr> and y ~ b -> c
07:03:22 <kqr> snyp, i'd recommend regex-tdfa i think
07:03:46 <snyp> kqr, are the functions same?
07:03:55 <snyp> coz i am following real world haskell
07:04:08 <kqr> does real world haskell use ~=?
07:04:33 <snyp> it uses =~ it seems
07:04:48 <kqr> oh yeah, that's what i meant
07:04:52 <kqr> yeah, regex-tdfa supports that too
07:04:56 <kqr> it's the main interface
07:05:05 <kqr> http://swtch.com/~rsc/regexp/regexp1.html <-- interesting reading on why it's faster
07:05:16 <snyp> ok
07:05:29 <snyp> (will read after i am done with this chapter)
07:05:44 <snyp> ahmm.. oh i have read that page.
07:06:00 <snyp> and converted russ cox's example to python.
07:06:29 <predator217> can i pattern match on ghc's typelits? there don't seem to be a Suc or Zero to match on
07:07:11 <snyp> kqr, is tdfa more restrictive, like it doesn't support backtracking, etc.?
07:07:40 <snyp> (i.e just plain academic regex)
07:08:28 <CaptainK> kqr: so for example the (+3) is a function with a value shown generically as (a -> b) in the type for map
07:08:38 <kqr> snyp, i haven't run into any problems
07:08:44 <kqr> snyp, it doesn't support backreferences inside of regexes though
07:09:03 <kqr> snyp, because when you add those you leave the realm of regular languages
07:09:05 <kqr> CaptainK, correct
07:09:12 <snyp> yea..
07:09:43 <snyp> ok i will check tdfa, after i learn using the usual regex-base package.
07:09:46 <snyp> thanks
07:10:16 <kqr> sure!
07:10:24 <kqr> i just felt like mentioning it so you know it exists
07:11:15 <CaptainK> ok, thx, was just getting caught on the semantics
07:13:04 <CaptainK> guess I'll read later why the need for so many "->" arrows
07:13:55 <CaptainK> in real world haskell, they say the give a reason down the road after you have more fundamentals
07:14:26 <Javran> Hi, I'm wondering is there something equivalent to min-heap / max-heap in purely functional world?
07:14:26 <trap_exit> is there a way, using GHC.Generics, to simplify https://gist.github.com/anonymous/59ad6f11a90410961151 ? the idea is: if a constructor does not have an Expr, it can'be simplified; if it does -- if any of the Exprs can be simplfied, then it can be simplfied; otherwise, it can'be be simplified
07:14:37 <trap_exit> in particular, I want to simplify expr_simp_childs'
07:16:03 <bergmark> trap_exit: sounds like a job for uniplate
07:16:35 <trap_exit> bergmark: https://hackage.haskell.org/package/uniplate look slike an lternative to ghc.generics ?
07:16:45 <kqr> CaptainK, do you have experience with other programming languages?
07:17:09 <kqr> CaptainK, in those, it's common to have functions that have the signature "(a, b, c) -> d"
07:17:24 <kqr> CaptainK, in haskell, we write that as "a -> b -> c -> d" because that's actually more convenient to work with
07:17:37 <CaptainK> yes, fortran and pascal 25 years ago and basic, perl and other imperative styles
07:18:10 <kqr> CaptainK, what "a -> b -> c -> d" really means is "a -> (b -> (c -> d))"
07:18:23 <kqr> CaptainK, so when you give the function its first argument, it returns the function "b -> (c -> d)"
07:18:31 <kqr> CaptainK, when you give it another argument, it returns "c -> d"
07:18:37 <kqr> CaptainK, then you give it the final argument and it returns just d
07:18:54 <CaptainK> thats currying
07:18:57 <kqr> yeah
07:19:02 <kqr> and the reason there are so many -> arrows
07:19:07 <CaptainK> ah ok\
07:19:15 <bergmark> trap_exit: it's a generics library
07:20:30 <kqr> Javran, sure
07:21:34 <Javran> kqr: can you point me to some links?
07:22:18 <enthropy> predator217: kind of: http://lpaste.net/107745
07:22:38 <enthropy> so that x has type Proxy '[(), (), ()]
07:22:48 <kqr> Javran, http://www.haskell.org/hoogle/?hoogle=heap
07:22:54 <kqr> Javran, the two topmost hits look promising
07:23:23 <CaptainK> ok so map' :: ((->) a b) -> [a] -> [b] works for those non infix types
07:23:28 <Javran> kqr: thanks!
07:24:08 <kqr> CaptainK, looks correct
07:24:14 <CaptainK> thx
07:24:25 <kqr> CaptainK, that's the same signature as the previous one, only written with the arrow prefix
07:26:56 <CaptainK> just takes some getting use to looking at it that way
07:32:44 <TieSoul_> Hi
07:33:13 <kqr> CaptainK, i always change prefix to infix whenever i read functions. i find it really difficult to read them prefix-style
07:35:18 <CaptainK> I don't know why, but I prefer RPN
07:35:45 <CaptainK> TieSoul_: High
07:36:15 <TieSoul_> 'lo
07:49:32 <CaptainK> was looking to try erlang but the syntax looks not as elegant as haskell's, is that a fair observation?
08:03:49 * hackagebot xxhash 0.0.1 - A Haskell implementation of the xxHash algorithm  http://hackage.haskell.org/package/xxhash-0.0.1 (ChristianMarie)
08:03:51 * hackagebot flippers 1.0.1 - Variations on flip for multiple arguments  http://hackage.haskell.org/package/flippers-1.0.1 (ChristianMarie)
08:04:09 <jmcarthur> CaptainK: i think syntax is not a very important factor in whether to learn a language
08:28:50 * hackagebot vinyl 0.4.3 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.4.3 (JonSterling)
08:44:35 <bernalex> how would you easily explain a newbie why you can't pass
08:44:36 <bernalex> f 1 2 3
08:44:38 <bernalex> to a function
08:44:41 <bernalex> f :: (a -> a) -> a
08:44:47 <bernalex> ?
08:46:00 <listofoptions> bernalex: f has one argument, a function of type (a -> a)
08:46:26 <bernalex> listofoptions: yeah but to make them understand that the type (a -> a) is not the same as a -> a
08:46:31 <bernalex> i.e. it's not just for precedence's sake
08:46:56 <listofoptions> hmm
08:48:23 <listofoptions> @type \(x::a) -> \(f:: a -> a) -> f x
08:48:24 <lambdabot> a -> (a -> a) -> a
08:48:49 <listofoptions> bernalex: you could try to get them to type something like that
08:51:50 <mwhit> i mean there's nothing really to explain beyond "that's what parentheses means" as far as I can tell
08:53:18 <bernalex> listofoptions: it's a bit confusing that (a -> a) -> a -> a can be written (a -> a) -> (a -> a)
08:54:01 <dysinger> because lazy
08:54:03 <mwhit> well, (->) is right-associative
08:54:17 <mwhit> so a->a->a is equivalent to (a -> (a -> a))
08:54:24 <mwhit> but not to ((a->a) -> a)
08:54:25 <ocharles> bernalex: do they know how "map" works?
08:54:36 <bernalex> ocharles: no
08:54:39 <ocharles> hm
08:54:47 <bernalex> ocharles: I've explained higher-order functions
08:55:19 <bernalex> ocharles: it's just explaining why e.g. (a -> a) -> (a -> a) doesn't mean two functions, or why you can't pass 1 2 3 to a function (a -> a) -> a -> a.
08:55:56 <ocharles> right, i was hoping to appeal to familarity of map so you could say "clearly map doesn't take two arguments and then a list - it takes a function and then a list"
08:55:59 <mwhit> just have them write out parentheses explicitly
08:56:00 <Luke> ocharles: is socket.io a library that always hits their central servers?
08:56:15 <ocharles> Luke: who is the "they" you are referring to?
08:56:25 <bernalex> ocharles: yeah I can't think of anything much more smart than "try it in ghci"
08:56:34 <ocharles> socket-io is a library for building services that speak the socket-io protocol. you host the service
08:56:35 <bernalex> but ghci/ghc error messages are not optimal for newbies :-P
08:56:36 <mwhit> so (a->a) -> a -> a is really ((a->a) -> (a -> a))
08:56:53 <mwhit> and a->a->a->a is really (a->(a->(a->a)))
08:57:02 <mwhit> pretend i put spaces in there so it's readable
08:57:07 <bernalex> I appealed to -> being a "special type"
08:57:47 <mwhit> do they understand currying? i.e. that every function "really" takes just one argument?
08:57:47 <bernalex> and that we denote values with *, so Int, String, etc. are all *s, whereas the -> is "special" and * -> *.
08:57:48 <Luke> ocharles: not sure. someone else's servers I suppose
08:57:54 <mwhit> that would be a good place to start if no
08:58:04 <Luke> ocharles: library calls don't hit socket.io servers right?
08:58:07 <bernalex> mwhit: nope. I've been dropping hints about it though. :-P
08:58:12 <ocharles> Luke: there is no socket.io server
08:58:18 <bernalex> mwhit: I think I kind of explained it yesterday, actually.
08:58:31 <bernalex> mwhit: to explain a bit about partial application.
08:58:36 <ocharles> Luke: so no, I guess not :)
08:58:41 <bernalex> oh well, he's a smart cookie. he'll figure it out.
09:01:49 <bernalex> he did. phew.
09:01:55 <bernalex> "that's sort of obvious I guess" was his response :-P
09:12:48 <Javran> can I use ":m" command in ghci to import qualified modules?
09:13:29 <ClaudiusMaximus> no, but you can use "import qualified ..." in recent ghci versions
09:17:05 <Javran> ClaudiusMaximus: too bad we don't have a shorthand for qualified import in ghci :(
09:23:39 <joash> .
09:23:54 <mwhit> !
09:33:53 * hackagebot masakazu-bot 0.3.0.0 - @minamiyama1994_bot on haskell  http://hackage.haskell.org/package/masakazu-bot-0.3.0.0 (minamiyama1994)
09:35:21 <predator217> enthropy: thanks for the suggestion
09:35:28 <donkey_boy> burn all jews in oven
09:35:30 <donkey_boy> allahu akhbar
09:35:31 <donkey_boy> death to infidels
09:35:33 <donkey_boy> god bless allah
09:35:38 <donkey_boy> only muslims have a right to live
09:35:55 <systemfault> donkey_boy: Really motivated, right? Why don’t you go read a few surat instead?
09:36:01 <joash> fuck
09:36:06 <joash> how do i become muslim
09:36:13 <donkey_boy> i throw stones to jews
09:36:19 <donkey_boy> my stones crush israeli tanks
09:36:23 <cods> don't feed the trolls
09:36:24 <Clint> @where ops
09:36:24 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
09:36:32 <donkey_boy> allahu akhbar
09:36:38 --- mode: ChanServ set +o geekosaur
09:36:39 <donkey_boy> death to infidels! death to infidels! death to infidels! death to infidels! death to infidels! death to infidels! death to infidels! death to infidels! death to infidels! death to infidels! death to infidels! death to infidels! death to infidels! death to infidels! death to infidels! death to infidels! death to infidels! death to infidels!
09:36:42 --- mode: geekosaur set +b *!*sdfg@*.elisa-mobile.fi
09:36:42 --- kick: donkey_boy was kicked by geekosaur (donkey_boy)
09:36:52 --- mode: geekosaur set -o geekosaur
09:37:03 <joash> wow
09:37:05 <joash> so power
09:37:08 <joash> ful
09:37:18 <systemfault> cods:  he was spamming #clojure earlier… I even went to #freenode to get help from a staffer.
09:37:30 <systemfault> No help :/
09:38:14 <joash> Y IS HASKELL SO hard??  T_T
09:39:29 <mwhit> think of it less like learning a new language and more like learning programming over from the beginning
09:39:30 <dagano> i've not found the Data.UnionFind.* library very friendly to me ... is there alternative?
09:41:16 <mwhit> never used it, but there's https://hackage.haskell.org/package/union-find-array
09:41:25 <lispy> dagano: what didn't you like about it?
09:42:02 <nadir_> joash: I don't know about your experience but AFAIAC it's all the new concepts I met in Haskell (see typeclassopedia for a list of those) that made the language seem hard in the beginning
09:42:03 <mwhit> also https://hackage.haskell.org/package/disjoint-set-0.2/docs/Data-IntDisjointSet.html
09:42:09 <lispy> I've never used it and I don't know the alternatives either, but if you could be more specific then maybe others will have suggestions
09:42:27 <nadir_> well, that and my total inability to get anything to compile in my first week with Haskell :P
09:43:01 <joash> i never felt so stupid in my life :(
09:43:46 <Cale> joash: Is there something in particular that I could help you with?
09:43:47 <systemfault> After a week or two, you’ll be able to write basic stuff..
09:43:49 <systemfault> I can now
09:43:50 <lispy> joash: don't hesitate to ask us questions :)
09:44:00 <mwhit> joash: the Yorgey course is probably the best from-zeor intro out there right now also:
09:44:00 <Cale> Yeah, beginner questions are always welcome here :D
09:44:03 <mwhit> http://www.seas.upenn.edu/~cis194/lectures.html
09:44:14 <mwhit> from-zero*
09:44:25 <joash> WOW
09:44:26 <nadir_> joash: why? That's not the reason: we just lack some knowledge, but the time will help. And, as you see, lots of nice people here :)
09:44:31 <joash> you guys r so nice
09:44:53 <lispy> ...or maybe we're wolves in sheep's clothing....
09:44:55 <joash> are haskell ppl nice? or do nice ppl use HASKELL?
09:44:56 <lispy> :)
09:45:15 <ReinH> joash: yes.
09:45:19 <lispy> ?faq Does Haskell make you nicer?
09:45:19 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
09:45:23 <lispy> doh
09:45:23 <nadir_> ReinH: haha
09:45:33 <joash> logical OR
09:45:45 <lispy> the faq command used to just answer back, "Yes! Haskell can do that."
09:45:54 <ReinH> @faq test
09:45:54 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
09:45:55 <nadir_> @faq Does Haskell make you nicer?
09:45:55 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
09:45:57 <ReinH> huh
09:46:00 <nadir_> uff
09:46:00 <Cale> joash: I think a lot of it comes from the fact that we all remember what it's like starting out :)
09:46:30 <joash> how long does it take to rebuild your shattered ego?
09:46:44 <lispy> today's beginners are tomorrow's experts
09:46:47 <mwhit> 1-3 months, depending on the time put in
09:47:02 <mwhit> depending on your definition of "rebuild" also
09:47:03 <Tjr> joash: I think hobbyists use haskell, that's why people are nice
09:47:10 <joash> i SEE
09:47:17 <joash> i've never met a hobbyist
09:47:18 <mwhit> i still run into things I don't remotely understand
09:47:26 <lispy> Tjr: fortunately, I get paid for my hobbies :)
09:47:40 * Tjr is proved wrong.
09:47:42 <Cale> I started learning Haskell around 2001, and it took me about 2 months to feel like I could do useful things with Haskell, and about a year to really be comfortable (whatever that means).
09:47:59 <joash> is it like
09:48:02 <joash> coming out of the closet
09:48:27 <mwhit> another important tip when starting out: You're going to run into a lot of very esoteric theoretical discussion when reading about haskell. for the most part, this stuff is purely *optional*
09:48:43 <mwhit> anything involving category theory for example
09:48:52 <joash> optional but fun? or optional but will help?
09:48:54 * hackagebot ChasingBottoms 1.3.0.8 - For testing partial and infinite values.  http://hackage.haskell.org/package/ChasingBottoms-1.3.0.8 (NilsAndersDanielsson)
09:48:56 <lispy> mwhit: yeah true, although I regret putting off basic study of CT for so long
09:48:57 <Tjr> in case you like abstracts maths, feel free to enjoy those discussions :-)
09:49:03 <Cale> Back then, there were fewer resources for learning the language, but really the hard part is unlearning all the bad habits from programming in imperative languages.
09:49:49 <lispy> joash: Do you have a favorite book or tutorial you're using?
09:50:10 <joash> I am trying a little project
09:50:21 <Andrew> I've found this really helpful: https://www.fpcomplete.com/school/starting-with-haskell/introduction-to-haskell
09:50:35 * dwcook does Haskell purely as a hobby but may make a job of it later
09:50:36 <joash> implement DIFFIE HELLMAN
09:50:44 <mwhit> a guy in my meetup group decided his head-first newbie learning project would be "writing an orm"
09:50:47 <mwhit> i dissuaded him
09:50:56 <joash> dining cryptographers network
09:51:03 <lispy> mwhit: yeah, you should get him to write an ESB instead ;)
09:51:05 <Andrew> There's also this if you're looking for some real things to practice: http://www.cis.upenn.edu/~cis194/lectures.html
09:51:13 <nadirs> dwcook: do you mean you have that as a choice?
09:51:37 <joash> it was fun until i tried to talk to other computers ;(
09:51:50 <Cale> joash: Category theory is optional but fun if you like mathematics, and might help to understand where certain abstractions that we use in Haskell came from, or help to influence the way you think about design on a large scale. But it's not really central to understanding how to program in Haskell.
09:52:00 <dwcook> nadirs, … yes? I'm not sure I understand your question correctly
09:52:38 <nadirs> dwcook: my bas english as usual :P I meant you can choose whether to use Haskell at work or you hope to find a job where they let you use Haskell?
09:52:41 <joash> oh ok
09:52:42 <Tjr> mwhit: what's an orm? what's ESB?
09:52:45 <nadirs> *bad english
09:52:50 <dwcook> nadirs, ah, the latter
09:53:03 <Cale> Tjr: Object-Relational mapping
09:53:16 <Tjr> Cale: what's that?
09:53:21 <dwcook> nadirs, strictly speaking the former as well but I'm about to quit when I can
09:53:21 <nadirs> dwcook: ah ok, order in the universe is restored :)
09:53:24 <lispy> Tjr: ESB = Enterprise Services Bus. It's usually part of an architecture for applications that want to share data in a large institution.
09:53:29 <ReinH> joash: you'll eventually get an intuition for category theory by using Haskell anyway
09:53:32 <ReinH> it's kind of hard to avoid
09:53:46 <mwhit> Tjr: ORM is about interacting with a database in terms of programming objects/types, abstracting away the actual writing of queries and such
09:53:57 <ReinH> joash: the more important thing is to enjoy learning Haskell
09:54:04 <joash> is that the TYPE system thing?
09:54:09 <Cale> Tjr: It's a system for storing the state of your objects (in an OO setting) in a database in an automatic or semi-automatic way.
09:54:29 <ReinH> joash: you can look at the type system that way, but you don't need to
09:55:01 <ReinH> joash: there is more than one path to tao^H^H^H Haskell
09:55:21 <lispy> Tjr: I don't actually think ESBs are a good idea, but they seem popular in some of the programming communities (Java?)
09:55:28 <joash> so one day, i will wake up and be ENLIGHTENED?
09:55:31 <ReinH> joash: I'd recommend starting with some introductory reading and by trying to write some programs that interest you in Haskell.
09:55:33 <ReinH> @where lyah
09:55:33 <lambdabot> http://www.learnyouahaskell.com/
09:55:44 <ReinH> ^ is a good place to start, and this is a good place to ask questions as you go
09:55:46 <joash> lispy: why are ESB bad?
09:56:07 <joash> thank YOU
09:56:17 <lispy> joash: They seem like an excessive abstraction.
09:56:19 <joash> i will learn my self a haskell
09:56:26 <ReinH> joash: have fun!
09:56:39 <joash> can you be more specific?
09:56:43 <BenedictEggers> lyah is great
09:56:52 <joash> the benefits do not justify the overhead?
09:56:58 <ReinH> joash: I will say that reading alone won't be as effective as reading *and practicing*, so please do the exercises and work on your own programs :)
09:57:01 <dwcook> nadirs, in case you're wondering why I'd be crazy enough to quit a job where I *could* use Haskell: I work by myself maintaining a website. My boss doesn't care what tools I use so long as the requirements are met. But it's a disaster I inherited and would be unpleasant to tackle into shape.
09:57:30 <lispy> "Let's wrap this packet up in SOAP, broadcast it on the bus, and then let the consumers unpack it."
09:57:44 <ReinH> lispy: let's put this envelope in an envelope.
09:57:50 <lispy> yeah
09:58:28 * glguy tries to think of which project lispy was on in the last few years that involved an ESB
09:58:36 <lispy> heh
09:58:52 <lispy> glguy: does grid ring a bell?
09:59:22 <pharaun> isn't that an ibm thing?
09:59:30 <glguy> Yeah, I guess it does.
10:00:13 <lispy> pharaun: it was a DoE thing. I don't think IBM was involved.
10:00:30 <pharaun> oh?
10:00:42 <pharaun> cos while i was at ibm i kept on hearing about this grid thing but *shrugs*
10:00:50 <pharaun> smart grid, and computer grid, and etc
10:01:02 <lispy> yeah, there are probably a ton of projects with "grid" in the name :)
10:01:43 <ReinH> lispy: there are dozens of us! dozens!
10:05:23 <nadirs> dwcook: I see. I'm getting sick of websites too :)
10:07:23 <ph88> what should i have for spaces/tabs settings in haskell ?
10:07:37 <mwhit> tab = 2 spaces is the usual
10:07:47 <glguy> err,
10:07:53 <glguy> Haskell tab stops are 8 spaces
10:08:16 <ph88> does it both work the same ?
10:08:23 <ph88> for the compiled code
10:08:51 <glguy> Generally people recommend you avoid putting tabs in your Haskell source files, but if you can't help yourself make sure your editor is set to 8-space tabs
10:08:51 <mwhit> buh?
10:09:12 <glguy> otherwise you'll run into parsing issue with layout
10:09:30 <ph88> so 2space tabs lead to parsing issues ?
10:09:52 <mwhit> oh i just misspoke
10:09:56 <glguy> If you render a Haskell file with 2-space tab stops then it will just render the file incorrectly
10:10:07 <mwhit> the usual indent is 2 spaces, not using tabs
10:10:10 <Cale> ph88: You should not have any tab characters in your file
10:10:22 <Cale> Make your editor convert them to spaces automatically
10:10:52 <ph88> ok so no real tabs, but tab = 2space will lead to problems ? i have to use tab = 8space ?
10:10:53 <Cale> It doesn't matter to anyone how deeply you indent things, so long as things line up vertically
10:11:07 <mwhit> just have your editor convert tabs to spaces
10:11:09 <mwhit> not tabstops
10:11:16 <mwhit> then use whatever you want
10:11:20 <Cale> If there are tab characters in your file, the compiler will treat them as aligning to the next multiple of 8 spaces
10:11:24 <glguy> All that matters is that your *tab stop* is set to 8 spaces. It doesn't matter how much you indent as long as its indented
10:11:49 <ph88> ok i will put tab = 2 spaces then and not put real tabs in if i press the tab key
10:11:53 <vanila> ph88, configure emacs so that when you press tab it will insert spaces for you
10:11:54 <Cale> But there shouldn't be tab characters in your file. I use the tab key as a way to quickly insert 2 spaces at a time
10:12:01 <ph88> vanila: sublime here
10:12:19 <mwhit> ph88: Right. that's what most people use (and what i meant when i said tab=2 spaces. confusion over tab key vs tabstop)
10:12:21 <glguy> In vim the setting for expanding tabs is ":set expandtab"
10:12:34 <ph88> glguy: sublime here
10:12:38 <BenedictEggers> ph88: in settings->default there's a "set tabs to spaces" thing (set it to True)
10:12:51 <max3> in a cartesian closed category with objects W,X,Y,Z what does (W)^(XxYxZ) mean?
10:12:53 <BenedictEggers> right below it there's a "tab width" option, which you can set to whatever you want
10:13:34 <vanila> max3, you can think of a^b as b -> a
10:13:36 <Cale> max3: B^A is the exponential object
10:13:44 <benbangert> does anyone have a http2 implementation for haskell? I saw there's hpack, but not the rest of it...
10:13:49 <Cale> max3: http://en.wikipedia.org/wiki/Exponential_object
10:14:00 <max3> yes my problem is i don't know how to interpret the object X x Y x Z
10:14:04 <ph88> BenedictEggers: i opened that configuration file but i dont seem able to change it
10:14:06 <Cale> and X x Y x Z would be the product of those three objects
10:14:26 <Cale> http://en.wikipedia.org/wiki/Product_(category_theory)
10:14:30 <BenedictEggers> ph88: okay. in that case copy the relevant lines to settings->user and change them there. it'll override default settings
10:15:41 <ph88> works like a charm :)
10:16:08 <BenedictEggers> good good
10:16:09 <Cale> max3: So, for instance, in the category of sets, this is the set of functions whose domain is the set of triples with components in X, Y, and Z respectively, and whose codomain is the set W.
10:16:32 <max3> Cale: is that really the correct interpretation ?
10:16:37 <Cale> max3: yes
10:16:48 <Tjr> joash: this is a good example of a strictly optional discussion
10:16:48 <glguy> lol, is that your final answer?
10:17:02 <ph88> how can i make a block comment ?
10:17:08 <Cale> {- comment -}
10:17:09 <glguy> {- .... -}
10:17:10 <Tjr> ph88: {- stuff -}
10:17:13 <joash> WOW
10:17:22 <joash> so smart :')
10:17:22 <ph88> ok thx :P
10:17:41 <joash> hey
10:18:22 <joash> SAY, I am a webserver and I want to give some stateful responses. Is the HASKELLY way to do this: have the requests TRANSFORM the request handling function itself?
10:18:39 * Clint squints.
10:19:05 <vanila> joash, what do you mean by stateful responses?
10:19:10 <Cale> joash: It's hard to understand exactly what you mean by that. There are a lot of approaches to that kind of thing which make sense in Haskell.
10:19:11 <vanila> HTTP is stateless
10:19:20 <joash> as in.
10:19:32 <ph88> are there tools for haskell to generate documentation out of block comments ?
10:19:45 <mwhit> @where haddock
10:19:45 <lambdabot> http://www.haskell.org/haddock/
10:19:53 <joash> the CLIENT calls me and updates me somehow
10:19:54 <mwhit> ph88: ^^^
10:20:01 <Cale> But yeah, you have the issue that HTTP is a stateless protocol, so if you want to be stateful, you really have to put something in the document you send back that will let you recover whatever state you wanted to maintain.
10:20:02 <joash> causing my responses to change in the future
10:20:13 <Cale> (when the client makes another request based on it)
10:20:42 <joash> oh...
10:21:00 <joash> so I shouldn't use HTTP?
10:21:22 <Cale> joash: Well, it depends on what you're doing. If your goal is to have a webserver, you must use HTTP.
10:21:32 <CaptainK> <jmcarthur> CaptainK: i think syntax is not a very important factor in whether to learn a language
10:21:39 <Cale> joash: This is the problem that all web servers face.
10:21:46 <joash> i see
10:21:52 <vanila> joash, have you used state monad before?
10:21:58 <Cale> (regardless of which language they're written in)
10:22:01 <CaptainK> I'd like to debate that, but #programming is probably a better ch for that
10:22:06 <Cale> The State monad really has nothing to do with this issue
10:22:09 <joash> Yes I have
10:22:15 <joash> but it didn't help me
10:22:28 <vanila> joash, well you could use a monad like state, so that clients can change the state of the web server
10:22:34 <joash> I don't really NEED to use HTTP
10:22:36 <vanila> joash, and that way future HTTP responses can change
10:22:44 <joash> i'm trying to build a P2P app.
10:22:57 <vanila> Cale: I just wanted to know if he understood this prereq.
10:23:15 <Cale> vanila: Well, the web server is doing I/O anyway, so you might as well just use an IORef
10:23:32 <joash> right, so the STATE monad can contain arbitrary state type
10:23:36 <CaptainK> joash: was going to say that you learn a lot of Haskell while sleeping...if that makes sense
10:23:44 <Cale> But you still have to deal with the fact that the connection is going to close each time.
10:24:19 <Cale> and you don't know if you're talking to the same client or not, unless that client includes some uniquely-identifying ID in their request
10:24:45 <joash> ok
10:25:09 <joash> so say i ask a node for its peers
10:25:25 <joash> that can change?
10:25:33 <joash> even if you know the unique ID
10:25:37 <joash> of the caller?
10:26:24 <Cale> I'm not sure what we're talking about any more
10:26:42 <Cale> P2P clients are usually very different from web servers
10:26:43 <joash> SORRY
10:26:48 <joash> yes
10:27:07 <joash> i mean, i am trying to build a p2p client
10:27:17 <Cale> For which protocol?
10:27:29 <joash> TCP?
10:28:04 <Cale> I mean like Bittorrent? ed2k?
10:28:18 <joash> OH
10:28:32 <Cale> Or just some custom application?
10:28:35 <joash> dining cryptographers network ??
10:28:38 <joash> yeah
10:29:16 <joash> i just need them to talk to each other :/
10:30:01 <Cale> Have you written much network code in any other language?
10:30:30 <joash> java c# and a bit of go
10:30:35 <Cale> http://hackage.haskell.org/package/network-2.5.0.0/docs/Network.html is the simple network interface
10:30:50 <joash> oh thanks :)
10:31:55 <joash> oh
10:32:01 <joash> this makes so much more sense.
10:32:21 <Javran> @hoogle WriterT w m a -> WriterT w m w
10:32:23 <lambdabot> Control.Monad.Trans.Writer.Lazy liftCatch :: (m (a, w) -> (e -> m (a, w)) -> m (a, w)) -> WriterT w m a -> (e -> WriterT w m a) -> WriterT w m a
10:32:23 <lambdabot> Control.Monad.Trans.Writer.Strict liftCatch :: (m (a, w) -> (e -> m (a, w)) -> m (a, w)) -> WriterT w m a -> (e -> WriterT w m a) -> WriterT w m a
10:32:23 <lambdabot> Control.Monad.Trans.Writer.Lazy mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
10:32:44 <merijn> joash: Note: Haskell's lightweight threads use select/epoll/kqueue "under the hood", so you'll mostly only see blocking socket operations
10:32:48 <benzrf> hmmmm
10:32:55 <merijn> joash: In haskell you'd generally just have 1 thread per socket
10:33:15 <joash> what is select/epoll/kqueue?
10:33:19 <Javran> how can I see what's been written to the monoid in a Writer?
10:33:42 <Cale> Yeah, the usual thing to do with a server is write a loop which executes accept to wait for a connection and uses forkIO to handle the client before immediately looping.
10:33:56 <joash> right
10:33:58 <merijn> joash: If you don't know, don't worry and just write naive code using 1 thread per socket and it'll "Just Work"
10:34:21 <joash> so spawn a new thread for every client
10:34:24 <Cale> joash: low-level OS primitives for waiting for input from multiple sources
10:35:20 <glguy> Javran: run it with runWriterT or runWriter depending on your circumstance
10:35:30 <Ch0c0late> Struggling to solve a problem but have gotten stuck. Incomplete source code and sample are here http://hastebin.com/itihuwefok.coffee http://hastebin.com/lotalemudo
10:35:37 <Ch0c0late> Any suggestion?
10:36:24 <Javran> glguy: but can I see it from inside? just like `get` for State
10:36:41 <mwhit> Javran, no, that's the whole difference between writer and state basically
10:36:53 <Cale> Ch0c0late: I'm not sure I completely understand the problem description
10:36:57 <Javran> mwhit: I see, thanks!
10:37:01 <joash> writer can only write??
10:37:16 <mwhit> joash: while you're inside the monad, yes
10:37:26 <joash> cool name!
10:43:35 <__sebastian___> What's the difference between Conduit.=$= and Conduit.$=        ?
10:44:07 <__sebastian___> ($=) :: Monad m => Conduit a m b -> ConduitM b c m r -> ConduitM a c m r
10:44:14 <__sebastian___> (=$=) :: Monad m => Conduit a m b -> ConduitM b c m r -> ConduitM a c m r
10:44:24 <mwhit> first arg to ($=) must be a Source and gives a Source, (=$=) takes any Conduit and gives a Conduit
10:44:27 <mwhit> i think
10:44:28 <mwhit> i haven't used it that much
10:44:32 <mwhit> :T ($=)
10:44:34 <mwhit> :t ($=)
10:44:35 <lambdabot>     Not in scope: ‘$=’
10:44:36 <lambdabot>     Perhaps you meant one of these:
10:44:36 <lambdabot>       ‘$!’ (imported from Prelude), ‘/=’ (imported from Data.Eq),
10:44:39 <mwhit> eh
10:45:13 <mwhit> the lack of = is supposed to indicate a terminus
10:45:25 <mwhit> so (=$) is the same thing but for consumers
10:45:44 <__sebastian___> thei'r implementation is the same
10:45:50 <__sebastian___> their implementation is the same
10:46:33 <__sebastian___> there used to be a difference, but it vanished somewhere between conduit 1.0.0 and 1.1.7
10:46:50 <mwhit> entirely possible
10:46:55 <mwhit> i'm nothing like an expert in conduit
10:47:24 <mwhit> oh yep
10:47:25 <mwhit> http://hackage.haskell.org/package/conduit-1.1.7/docs/Data-Conduit.html
10:47:29 <mwhit> says since 1.0.18
10:49:09 <int3__> I currently have a lambda that does this: `\(MovePair m t) -> consState m t`. is there some way to make it point-free? sort of a generalized 'uncurry', I suppose...
10:49:31 <int3__> pointfree appears to choke on the data constructor
10:49:59 <mwhit> yeah you're not going to be able to make it pointfree if you're pattern matching on the argument
10:50:01 <__sebastian___> @pl \(MovePair m t) -> consState m t
10:50:02 <lambdabot> (line 1, column 12):
10:50:02 <lambdabot> unexpected "m"
10:50:02 <lambdabot> expecting operator or ")"
10:50:06 <mwhit> unless you have a helper that does that pattern matching for you
10:50:41 <int3__> hm okay
10:52:46 <glguy> Ch0c0late: What's your question?
10:53:14 <glguy> Which part of that are you struggling with?
10:55:27 <Ch0c0late> glguy: Thanks for your help. Give me some minutes. Cale is mentoring me on it.
11:03:28 <Andrew> Are there any style guidelines regarding function composition? Is it considered bad practice to compose more than a couple functions together in one line?
11:05:11 <Cale> Andrew: no, it's generally considered a good idea
11:05:22 <mwhit> usually considered good practice, it's very readable that way
11:05:56 <glguy> Andrew: It completely depends on context
11:05:57 <Cale> Andrew: Chaining ($) is something I personally consider bad style, as you can essentially always replace all but the last ($) with (.)
11:06:14 <glguy> some people go overboard with it and you get a mix of ., $, and ()s
11:06:22 <Andrew> Cool thanks
11:06:38 <mwhit> which is usually a sign you want to factor it out into multiple functions
11:06:38 <Cale> (.) is a nicer operator than ($) is, as it's associative
11:06:47 <Andrew> So having func1 . func2 . func3 . func4 is good (supposing the names are descritpive)
11:06:50 <Andrew> ?
11:06:53 <Cale> f . g . h can be read as (f . g) . h or as f . (g . h)
11:06:57 <mwhit> yeah, it's easy to read
11:07:06 <mwhit> it's "do this, then do that, then do that, then done"
11:07:26 <glguy> Andrew: Your goal is to make the intent of the code as clear as possible, sometimes you can acheive that with: someCompoundOperations = f . g .h . k
11:07:33 <Cale> So, if you have something like  f . g . h $ x  it's possible to, say, cut out g . h and put that in its own definition if you like
11:07:49 <Cale> whereas if it's f $ g $ h $ x, then g $ h is meaningless on its own
11:07:57 <Andrew> right
11:08:06 <Andrew> thanks everyone
11:08:09 <glguy> if you find yourself writing a mix of f . g $ x, either use f (g x) or name the f . g part
11:08:39 <Andrew> yeah breaking it up into names seems like a good idea depending on context / reuse
11:08:58 <dwcook> I mostly only use ($) now to avoid having to parenthesize a multi-line expression, such as a do expression. I used to use (.) and ($) almost everywhere permitted but kept having trouble figuring out how far to go with it.
11:10:09 <dwcook> Though often I'll define a function simply as the composition of various others
11:10:45 <Andrew> I seem to prefer using composition wherever i can but i haven't seen too many examples of it while learning yet, so i was curious on how it is generally regarded
11:11:56 <dwcook> "f x = i (h (g x))" I would say looks nicer as "f = i . h . g"
11:12:21 <Andrew> agreed
11:13:22 <Andrew> out of curiousity do lisp languages support composition? i'm not familiar, but i always see a mess of brackets
11:13:32 <Andrew> when i see lisp code
11:14:06 <hpc> Andrew: it usually ends up being just as many parens anyway
11:14:29 <mwhit> sure, pretty much any language with first-class functions supports composition
11:14:49 <dwcook> I think at least Racket supports something like (compose i h g)
11:14:51 <glguy> Check out http://rosettacode.org/wiki/Function_composition
11:17:09 <Andrew> oh sorry, yeah I just meant with the kind of syntactic shortcut haskell has where you don't need to specify parameters
11:17:52 <dwcook> It's not actually a syntactic shortcut, it's just that g . f is a function
11:18:09 <dwcook> So sure, you can define a variable in Lisp whose value is a function.
11:19:35 <Andrew> Right, but can you define functions by composing other functions without having to do (f (g x))
11:19:47 <mwhit> Andrew: it's not syntactic support, (.) is a function just like any other
11:19:50 <mwhit> :t (.)
11:19:51 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:20:16 <Andrew> Yeah, my bad. Just being imprecise with terminology :)
11:20:22 <mwhit> ah
11:20:35 <mwhit> well in that case, you can write (.) in any language with first-class functions, so yeah :)
11:21:38 <Andrew> oh right, okay
11:21:53 <Andrew> so in lisp after defining that, you would just be able to do (. f g), right?
11:22:25 <mzero> A way I think about this stuff:    f = h . g   imparts to the reader what there is to know about f: it is the composition of h and g, that is, it applies g, then h to the result
11:22:27 <mzero> whereas
11:22:40 <mzero> f x = h (g x)  has this extra thing... x...
11:22:53 <mzero> and x... could be anything    f horses = h (g horses)
11:23:08 <mzero> but see there, the emphasis in the source is on... horses! and horses doesn't actually impart info.
11:23:10 <Andrew> yeah
11:23:20 <Andrew> the x is a distraction
11:23:22 <Andrew> from the intent
11:23:33 <mzero> if it *does* impart info (like cueing the user that it needs to be a list of horses), then I'd argue f, g, and h are misnamed
11:23:44 <mzero> exactly
11:24:07 <mzero> this is the same reason I actually like single letter, generic names when I do need to name things:
11:25:01 <dwcook> Often you can get what you want just from the type, though there are certainly cases where a type has more than one obvious interpretation, in which case the name must be helpful
11:25:08 <zomg> single letters works in short functions
11:25:16 <dwcook> f :: Int -> [a] -> [a] doesn't tell you much
11:25:19 <zomg> single letters = massive hate in most non-haskell langs
11:25:19 <zomg> :p
11:25:21 <mzero> it is much harder to see the inent in    flubber (firstGizmo : otherGizmos) | fishy firstGizmo = flubber otherGizmos
11:25:22 <dwcook> drop :: Int -> [a] -> [a] is more descriptive
11:25:35 <mzero> thank in    flubber (a:as) | fishy a = flubber as
11:25:37 <dwcook> take :: Int -> [a] -> [a] being another interpretation
11:26:31 <mzero> dwcook: but   f :: Int -> [a] -> [a]    tells me EVERYTHING   -- any name for a would be misleading, because a here has no restriction!
11:26:48 <mzero> well, yes, the function name always matters
11:26:52 <Andrew> f doesn't tell you everything
11:26:56 <mzero> (tough not when as an argument)
11:26:57 <Andrew>  you could be doubling all the values
11:27:04 <dwcook> mzero, it doesn't. Lists in particular have the problem where you can do several things to them and still fit the type. Say, you drop 12 before you do whatever else you were going to do.
11:27:05 <mzero> I thought you were talking about the 'a' s
11:27:19 <mzero> no the f
11:27:19 <Andrew> you could be doing anything
11:27:20 <dwcook> Andrew, you couldn't, that'd require Num a as well. You can only mess with the list structure, really.
11:27:30 <mzero> I agree you should name the function better than f in that case
11:27:42 <Andrew> oh yeah, okay
11:27:57 <dwcook> mzero, ah, no, there a is named fine. It could be *literally any type*, after all, and it's obvious already that it's a type variable.
11:28:04 <Andrew> but yeah the point stands that type signatures can only tell you so much
11:28:09 <mzero> I'm talking about names for arguments --- I only give them longer names when there are several and of the same type
11:28:14 <Andrew> i'd rather look at a function and know exactly what it does by reading its name
11:28:19 <Andrew> than having to read the implementation
11:28:35 <dwcook> (any concrete type, to be more specific, of course)
11:28:57 <dwcook> mzero, that makes sense.
11:29:09 <mzero> like      reflogTree :: FilePath -> FilePath -> FilePath -> IO ()        I'll use    reflogTree baseDir skipName flogPath = do ...
11:29:26 <ph88> how can i use this package ?  https://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Complex.html
11:30:02 <mzero> ph88:   import Data.Complex
11:30:09 <mzero> or if in ghci     :m + Data.Complex
11:30:15 <dwcook> ph88, you can make complex numbers like so: 1 :+ 1 means 1 + i, for example
11:30:30 <dwcook> ph88, then you can use all the RealFloat operations on them, including any Num operations like (+) and such
11:30:30 <mzero> ph88: it is part of base, so you are already using that package!
11:30:40 <dwcook> As well as various others
11:30:43 <dwcook> The instance list is helpful to look at
11:31:20 <ph88> thx guys .. didnt know this package was enable by default
11:31:36 <ph88> how can i write i ?    0 :+ 1   ?
11:31:42 <dwcook> Yep
11:31:59 <ph88> maybe i should make something for it so  0 :+ 1   is called j
11:32:25 <dwcook> Why j?
11:32:35 <hiptobecubic> python uses j
11:32:45 <ph88> because i is j in electrical engineering
11:32:47 <dwcook> Ah
11:32:53 <ph88> i is current
11:33:06 <bennofs> but isn't it î and ĵ ?
11:34:50 <ph88> data j = 0 :+ 1     Illegal literal in type (use -XDataKinds to enable): 0   what am i doing wrong here ?
11:35:08 <mwhit> you're trying to declare a type
11:35:15 <mwhit> when you should be declaring a value
11:35:21 <mwhit> it's just j = 0 :+ 1
11:35:28 <ph88> d0h :P
11:35:30 <Andrew> bennofs: those are unit vectors when talking about real coordinates
11:36:40 <ph88> is there haskell pastebin that runs code ?
11:36:58 <bennofs> ph88: fpcomplete can run code
11:37:31 <bennofs> ph88: you can use it as kind of a paste bin (altough you have to create an "article" (or however that's called))
11:37:56 <ph88> http://lpaste.net/6774771268274094080
11:39:20 <ph88> what does that mean,  No instance for (RealFloat Integer) arising from a use of `*'
11:41:19 <arancia> :t 0 :+ 1
11:41:20 <lambdabot> Num a => Complex a
11:41:37 <arancia> GHCI defaults that 'a' to Integer, I think
11:41:50 <ph88> wasnt num both int and float ?
11:42:13 <arancia> Oh wait, RealFloat
11:42:40 <ph88> Num includes all numbers, including real numbers and integral numbers, Integral includes only integral (whole) numbers
11:43:06 <ph88> http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
11:43:20 <arancia> I don't know why I thinks it needs a RealFloat instance here
11:43:23 <ph88> what's the difference between a float and realfloat ?
11:43:40 <arancia> Different class functions
11:43:44 <mwhit> as in non-comple
11:43:44 <mwhit> x
11:44:08 <ph88> so what can i do about this ?
11:44:45 <ph88> The RealFloat subclass of Floating and RealFrac provides some specialized functions for efficient access to the components of a floating-point number, the exponent and significand. The standard types Float and Double fall in class RealFloat.
11:44:54 <ph88> http://www.haskell.org/tutorial/numbers.html
11:46:06 <phi__> In http://lpaste.net/3411186103066034176 I have two ways of checking if a type level nat is prime. For IsPrime type checker terminates for sufficinetly small nats. But for IsPrime' does not for any nat greater then 3. Can anybody explain why?
11:46:17 <Tjr> gabriel proposed "method" notation for comonads, in the same sense as "do" notation for monads. http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
11:46:18 <Tjr> Does this "method" syntactic sugar exist already?
11:46:42 <noteventime> ph88 do "let j = 0 :+ 1 :: Complex Double or Complex Float
11:47:01 <ph88> oki
11:47:02 <mwhit> ph88: when I run your code i don't get that type error. for some reason your ghci is defaulting j to Complex Integer when mine is not
11:47:13 <mwhit> but probably you want fromIntegral j
11:47:16 <noteventime> (alt. "let { j :: Complex Double ; j = 0 := 1 }")
11:47:34 <ph88> noteventime: *high five*
11:48:17 <Tjr> phi__:  line 18, you probably want the the square root of m, not m/2
11:48:47 <phi__> Tjr : yes, but that is not a trivial function to represent at type level
11:49:37 <noteventime> ph88: Not sure what is going on either, something must have redefined your (*) or something
11:49:37 <phi__> actually I need to put Div and Mod in that file too
11:51:13 <phi__> Oh just a thought: Is type function application strict?
11:52:31 <Tjr> phi__: line 22: (If (n == 1) True (PrimeHelper m (n-2)))  >> 2 changes
11:54:58 <phi__> Tjr them Mod m n == 0 will always be True so that would not work
11:55:02 <jg_> hi all, i'm having trouble writing a type signature for one of my functions that uses readerT : https://gist.github.com/jg/bf0dd9c8023cdb2dfd20 . Could someone explain what's this "Data.Functor.Identity.Identity (IO c)" ghci outputs for the type there?
11:56:01 <Tjr> phi__: still, n == 2 looks like a bug to me
11:56:07 <mwhit> phi__: I would imagine type family application would probably be strict, if i were to guess
11:56:32 <mwhit> phi__: which would be your problem. Good luck working with TypeLits, I had a hell of a time trying
11:56:42 <mwhit> phi__: the arithmetic contraint solver is terrible right now
11:57:27 <phi__> mwhit : That is most likely the problem and also when I need the PrimeHelper m 0 equation. I thought I would never reach it.
11:57:31 <Tjr> phi__: the IsPrime' algorithm looks good to me.
11:58:08 <phi__> mwhit : Typelits don't seem bad to me only very slow
11:58:42 <mwhit> Tjr: IsPrime is the one that works. IsPrime' is the one that doesn't.
11:58:43 <jg_> and by the way, what's that haskell naming convention function' , does it have a set meaning?
11:58:58 <Tjr> mwhit: I know, that#s why I checked whether the algo is correct
11:59:13 <phi__> Tjr: Algorithm is goodm if the If short circuits. Apparently GHC is not lazy at type level
11:59:14 <mwhit> jg_: it's just a "prime", comes from mathematical notation. Just means "like this other thing, but altered"
11:59:22 <mwhit> usually
11:59:51 <jg_> is it a good practice? i think i saw someone complaining that it's easy to miss the prime when reading code
12:00:49 <Tjr> jg_: it's a bad idea, even in mathematics
12:00:55 <Tjr> bad but popular
12:01:10 <trap_exit> then yoyu can name the variables x and xPRIME
12:01:13 <trap_exit> it's hard to miss "PRIME"
12:02:16 <Tjr> phi__: from a maths point of view, negative numbers are just as prime as positive ones. I.e. 7 and  -7 are both prime in \Z.
12:03:56 <phi__> <Tjr> But these are no negative numbers here. We are working with naturals
12:05:59 <Ch0c0late> I get Prelude.(!!): index too large when running this code http://hastebin.com/biduxolaja.hs
12:08:49 <Tjr> phi__: at risk of stating the obvious: my point is that the concept of primes lives naturally within a ring (\Z), and any attempt to define it in a semi-ring (\N) ends up invoking the natural embedding operator all over the place. Define, not code.
12:09:29 <glguy> Ch0c0late's problem implemented in machines http://lpaste.net/107757 can run purely or stream answers as inputs are read from stdin
12:09:31 <c_wraith> Ch0c0late: what happens when you pass that function an empty list?
12:10:07 <c_wraith> Ch0c0late: as a hint, the length is 0, which is even.
12:11:03 <c_wraith> Ch0c0late: the median function, specifically.
12:11:32 <Ch0c0late> c_wraith: Yes, the problem is in median function and !!
12:11:51 <c_wraith> Ch0c0late: and what happens when you pass that function an empty list?  trace it!  work it out!  find the problem.
12:11:54 <phi__> Tjr If I remember correctly the most general setting for primes is a Euclidean Domain. But if I am not defining that general a function, I see no point in introducing negative numbers
12:12:05 <c_wraith> Ch0c0late: I already reduced the problem space hugely by telling you that it's caused by an empty list.
12:12:39 <Ch0c0late> c_wraith: length is 0 and it returns 0 - 1 which results -1 but it the error should be Prelude.(!!): negative index
12:12:42 <phi__> anyways this was just an attempt to experiment with TypeNats
12:12:42 <Tjr> phi__: [off-topic] a Euclidean Domain is a convenient setting where every irreducible element is automatically prime.
12:12:59 <Ch0c0late> c_wraith: Shouldn't it?
12:14:00 * hackagebot amazon-emailer-client-snap 0.1.1.0 - Client library for amazon-emailer daemon  http://hackage.haskell.org/package/amazon-emailer-client-snap-0.1.1.0 (DanielPatterson)
12:14:05 <c_wraith> Ch0c0late: I have no idea.  Fix the bug and see if it actually works.
12:15:05 <phi__> Tjr  you are right probably, my Abstract Algebra is a bit hazy right now
12:15:19 <Tjr> phi__: :-)
12:16:40 <mwhit> Ch0c0late: is the fixity of (!!) higher than (-)? (I don't know offhand). If it is, then your code is ((xs !! len) - 1), not (xs !! (len - 1))
12:17:00 <mwhit> which would give the error you're seeing on an empty list
12:17:10 <mwhit> and make your code incorrect for all even lists
12:17:24 <Fuuzetsu> fixity of - is higher
12:17:28 <mwhit> oh
12:17:30 <mwhit> well nevermind then
12:17:35 <Fuuzetsu> or all my code before today is wrong ;)
12:17:47 <c_wraith> maybe all your code is wrong!
12:17:59 <glguy> fixity of !! is not defined while - is defined to 6
12:18:02 <glguy> so !! is higher
12:18:14 <glguy> :t :t \x y z -> x !! y - z
12:18:15 <lambdabot> parse error on input ‘:’
12:18:16 <glguy> :t \x y z -> x !! y - z
12:18:17 <lambdabot> Num a => [a] -> Int -> a -> a
12:18:40 <mwhit> > [1,1,1] !! 2 - 1
12:18:41 <lambdabot>  0
12:18:46 <mwhit> yep
12:21:14 <phi__> Tjr  With IsPrime it is possible to define Finite fields, though it would be excrutiatingly slow to compile the code for  a prime even a few thousand large , that is why I wanted it.
12:24:21 <Geoff__> Hey guys, quick question for you.  I am working on expanding my Haskell skills by doing some challenges at https://www.hackerrank.com, and I am having issues with one thing that I think has got to be much easier than I am making it
12:24:26 <Geoff__> reading and parsing STDIN
12:25:07 <Cale> phi__: Prime elements can be defined for any commutative ring as nonzero nonunits p such that whenever p divides the product a*b, then p divides a or p divides b.
12:25:08 <cin> do you want to avoid direct spoilers?
12:25:11 <mwhit> Geoff__: sure, can you give a specific example of something you'd like to do?
12:25:24 <Geoff__> So say I am expecting a string of "2 3", how would I convert that to a [Int]?
12:25:45 <mwhit> map read . lines
12:25:54 <mwhit> err
12:25:54 <Fuuzetsu> map read . words <$> readLine
12:25:55 <Cale> you mean words
12:25:57 <mwhit> s/words/lines
12:25:59 <mwhit> haha
12:26:01 <Tjr> phi__: wow, finite fields. Do you have an application in mind?
12:26:01 <mwhit> reverse that
12:26:06 <Cale> and getLine, not readLine
12:26:07 <phi__> thanks Cale, I remember it now.
12:26:18 <cin> Geoff__, scratch that question about direct spoilers. the answer's been given verbatim
12:26:21 <Geoff__> what is the . in there for
12:26:30 <phi__> Tjr no, just wasting my time
12:26:30 <Cale> Geoff__: function composition
12:26:31 <Fuuzetsu> :t (.)
12:26:32 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:27:12 <cin> hmm, newbie handling in here isn't as awesome as back in 2008. rather clumsy ;)
12:27:29 <cin> Geoff__, how much haskell do you know already?
12:27:35 <Tjr> phi__: which typeclass would you use for finite fields (more generally, rings with characteristic /= 0)? If Num, how do you handle "signature" and absolute value?
12:27:39 <Fuuzetsu> cin: what exactly is not satisfactory to you?
12:27:43 <Cale> cin: I doubt this is actually the puzzle Geoff is trying to solve :P
12:28:18 <Geoff__> I have ran through a lot of sample projects, involving list manipulation
12:28:35 <Geoff__> so, I would still consider myself a noob
12:28:41 <Cale> Geoff__: Another way is to write something like   main = do xs <- getLine; let ns = map read (words xs); ... use ns here ...
12:28:50 <cin> Fuuzetsu, the part where you give a complete newbie some spoiler code that mixes function composition with applicative operators? ;)
12:29:05 <phi__> Tjr: define new typeclasses Group , Ring , Field, I would have liked to use Edward Kmett's algebra, but it no longer compiles
12:29:17 <Cale> Yeah, if I was going to use fmap, I'd just write fmap here
12:29:17 <Geoff__> but I can work with the language.  Just anything with reading input or output just feels unnatural in the lnguage
12:29:29 <Cale> I only ever use <$> if I'm also using <*>
12:29:35 <Geoff__> but thats likely because it is unnatural for funcational programming languages
12:29:44 <Fuuzetsu> cin: they are free to ask for more help, I don't like starting off assuming no knowledge, it's too much work for me
12:29:49 <Cale> Geoff__: eh, it's not so bad, you just need to get used to it
12:29:59 <Fuuzetsu> also is it spoiler code? is the actual task to parse in some numbers?
12:30:04 <Cale> Geoff__: Have a look at the code that I wrote
12:30:14 <cin> Fuuzetsu, you make it sound like an occupation :)
12:30:19 <mwhit> Geoff__: it's only "unnatural" in the sense that it's a different approach than imperative languages, and that's the approach you already know
12:30:39 <cin> Geoff__, are you just going off the reading material on that challenge site so far?
12:30:42 <Fuuzetsu> cin: 0k starting
12:30:47 <felixn> blah, anyone know how to return an error in parsec?  having trouble calling `newErrorMessage`
12:31:18 <Fuuzetsu> felixn: What trouble exactly?
12:31:22 <Geoff__> No, its unnatural in the sense that functional prgramming languages have this sense of no outside state... reading from STDIN kind of "breaks" that whole ideaology
12:31:27 <phi__> Tjr Now that I remember Numeric Prelude is another good option. But I don't like wrting Ring.C instead of Ring
12:31:30 <Tjr> Geoff__: FWIW, parsing numbers from strings is explained on page 400 in Real World Haskell. http://book.realworldhaskell.org/read/
12:31:30 <Geoff__> no, I was using learnhaskell sites
12:31:36 <Cale> Geoff__: A do-block can be used to glue a bunch of IO actions together into a larger one. Inside a do-block, v <- x means "execute the action x, and call its result v". If x has type IO t, then v will have type t.
12:31:58 <mwhit> Geoff__: the whole "no sense of outside state" thing is basically a myth
12:32:08 <Cale> Geoff__: In the end, main will be one of these IO actions, and will be executed in a compiled Haskell program.
12:32:29 <Geoff__> yea, I was trying to use read, i just kept getting errors
12:32:53 <Cale> getLine :: IO String  is an IO action which when executed, will request a line of text from stdin, and produce that as its result
12:33:05 <felixn> Fuuzetsu: https://gist.github.com/munro/0e719e1792df00de073e I'm poking at `newErrorMessage` in the reply but it's hard to invoke it
12:33:14 <cin> Geoff__, what was your use of read like? you can type small haskell expressions in here by prefixing it with "> "
12:33:21 <cin> > 1 + 2
12:33:22 <lambdabot>  3
12:33:42 <felixn> s/reply/repl/
12:33:44 <Cale> Geoff__: It's important to distinguish execution (of IO actions) from evaluation, which is the process of reducing expressions to values in order to be able to match them against patterns
12:34:07 <Cale> When people say that Haskell is pure or referentially transparent or stateless or whatever, they're talking about evaluation.
12:34:25 <Cale> Execution is none of those things, but it's separate from evaluation.
12:34:40 <Geoff__> looks like the main issue I was having is that I was using splitOn ' '
12:34:42 <Geoff__> instead of words
12:34:49 <Tjr> phi__: an interface modeled upon Edward Kmett's algebra would have the advantage that a lot of client code Just Works TM :-) I'm interested in polynomials rings and matrix rings, that's why I tuned in.
12:34:55 <cin> Cale, does your approach of throwing stuff at people and seeing what sticks without any feedback normally work? it seems strange to me
12:34:58 <Geoff__> splitOn must have a different output type
12:35:11 <cin> Geoff__, what's the type of splitOn? is that from Data.List.Split?
12:35:40 <Geoff__> yea
12:35:40 <Cale> cin: I am hoping for feedback here
12:35:51 <Fuuzetsu> felixn: I can only assume that the intended way to use ParseError type is by changing parser output type from String to Either ParseError String
12:35:52 <cin> :t splitOn -- does lambdabot have it in scope?
12:35:54 <lambdabot> Eq a => [a] -> [a] -> [[a]]
12:35:58 <cin> aha!
12:35:59 <Cale> cin: But I figure I might as well put everything on the table even if I get none
12:36:10 <Fuuzetsu> http://www.vex.net/~trebla/haskell/parsec-generally.xhtml seems to agree with my guess
12:36:36 <phi__> Tjr I would like that but algebra does not compile with ghc-7.8. Or maybe it does not compile with my GHC-7.8
12:36:36 <Cale> Geoff__: does that stuff make sense?
12:36:47 <cin> Geoff__, you can still use splitOn for this problem (even though words might be more convenient), can you see the change to make in your call?
12:37:18 <Geoff__> :t words
12:37:18 <lambdabot> String -> [String]
12:37:42 <felixn> Fuuzetsu: well, I'm trying to make it work for things like "sepBy operatorStr whiteSpace" or "optionMaybe operatorStr" ... which currently works if it's not matching operatorChar, I dunno what they're taping into to make it work >_<
12:37:59 <cin> Geoff__, check this out
12:38:02 <cin> :t ' '
12:38:03 <lambdabot> Char
12:38:04 <cin> :t " "
12:38:05 <lambdabot> [Char]
12:38:05 <Geoff__> so basically I end up with an output of [[Char]] with words, and [[a]] with splitOn
12:38:18 <Geoff__> right?
12:38:20 <felixn> Fuuzetsu: my assumption is I have to push the str back on the parser stack, and return some type of error >_<
12:39:10 <Geoff__> but since the input to splitOn is from the getLine, does it not consider itself a [Char] type?
12:39:30 <Tjr> phi__:  and, as usual, the algebra package does not have any documentation. I bet somebody is going to tell me to fix that myself.
12:39:32 <cin> Geoff__, that's right, splitOn returns a list of lists of anything [a], words returns a list of lists of characters [Char]
12:39:49 <orzo> Geoff__: splitOn would give [[Char]] if it was fed [Char]
12:40:31 <cin> Geoff__, it does -- i think the *first* argument to splitOn is your problem here, right? is this the error message you got?
12:40:36 <cin> > splitOn ' ' "hello world"
12:40:38 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char]’
12:40:38 <lambdabot>              with actual type ‘GHC.Types.Char’
12:40:52 <cin> okay, ignore the funny "GHC.Types." redundancy
12:41:04 <Cale> > splitOn " " "hello world"
12:41:06 <lambdabot>  ["hello","world"]
12:41:23 <phi__> Tjr I think the problem is if you have an understanding of Abstract Algebra you don't need documentation. If you don't have it you need a text book, documentation less than that won't do.
12:41:45 <Geoff__> ohhhhhh
12:41:52 <cin> :)
12:41:56 * Tjr thinks that lack of documentation and examples is a disease.
12:42:01 <Geoff__> I feel silly
12:42:16 <Fuuzetsu> Tjr: be the doctor that cures it
12:42:28 <Tjr> Fuuzetsu: bazinga
12:42:32 <Geoff__> splitOn "o w" "hello world"
12:42:34 <Fuuzetsu> ;^)
12:42:50 <Geoff__> that didnt work
12:42:51 <cin> Geoff__, need the >
12:42:56 <Tjr> Fuuzetsu: just 2 lines ago, I predicted somebody would echo that trite rationalization.
12:43:00 <Geoff__> > splitOn "o w" "hello world"
12:43:02 <lambdabot>  ["hell","orld"]
12:43:04 <cin> \o/
12:43:10 <Fuuzetsu> Tjr: I was going to post something 2 lines ago just for that reason
12:43:29 <Geoff__> ok, so I am splitting the list whereever it finds the sequence in that list
12:43:45 <cin> yup
12:43:49 <Geoff__> > splitOn [2,3] [1,2,3,4,5,6]
12:43:51 <lambdabot>  [[1],[4,5,6]]
12:43:59 <Geoff__> perfect  thanks guys
12:44:04 <cin> welcome!
12:45:38 <phi__> Tjr : I am willing to bet that if someone sits down to write good documentation for algebra, he would end with a book 'Teaching Abstract Algebra with Haskell'
12:46:16 <Tjr> phi__: it would be enough to provide examples familiar from introductory algebra.
12:47:47 <orzo> missing documentation, even when the types make meanings self evident, or if you can rationalize the lack, promotes bad practice when other people emulate it and the threshold for acceptable lacks erodes to the point where people aren't documenting because they can't be bothered
12:49:00 <orzo> therefore, some bit of haddock commentary, even if its useless, should be socially demanded
12:50:01 <glguy> No one owes you documentation. If a library doesn't have enough documentation for you you should decide not to use it or contribute some
12:50:16 <glguy> if people want more adoption they candocument them more
12:50:28 <dfeuer> Agreed, orzo. And such commentary should preferably make sense to people who aren't familiar with weird words like "hylomorphism" and "anamorphism".
12:50:29 <phi__> Tjr , rozo : there was this same debate on /r/haskell a few days back. I agree with people says that writing the code and documentation should not fall on the same person
12:50:35 <Tjr> orzo: if I were a dictator, I'd make it an upload requirement that the documentation is at least 10% as long as the code and that it passes an automated check for the English language.
12:50:37 <glguy> but I'd rather the code was available than have people hold it back for fear of constant complaint
12:50:50 <phi__> Some people are good at one some at other
12:51:22 <mwhit> glguy: that strikes me as a bad approach. Of course nobody "owes" you documentation, but I'd argue it's the responsibility of the library maintainer to supply it if he expects any kind of adoption
12:51:34 <mwhit> not the responsibility of the user to read the source code and document it for him
12:51:40 <glguy> if the library author is emailing you and asking you to adopt it, sure
12:51:45 <kazagistar> so the "documentation person" has to figure out the library, without documentation, in order to write documentation? that is silly
12:51:57 <Tjr> code without documentation is usually pretty close to useless.
12:52:17 <glguy> if you're looking at someone else's code and you can't figure it out, just don't use it
12:52:41 <mwhit> i do think in general the haskell community needs a pretty big sea change w.r.t. documentation, although the abstract algebra stuff under discussion probably isn't the best example for it
12:52:50 <dfeuer> Tjr, any length requirement should be relative to the total number of tokens in all the type signatures, not the size of the code. Complicated code can often be used easily. That said, internal documentation is also very nice to have.
12:52:55 <orzo> glguy: we should also wikify haddock and let library users make contributoins the author can simply pull in.  the "complaint" is not with the author, is that the product is unfinished, and that sort of complaint should be addressed, not dismissed
12:52:56 <mwhit> glguy: so why does anyone document anything? That's a ridiculous thing to say
12:52:57 <Tjr> glguy: in that case, undocumented code is actively harmful because it will discourage others from duplicating it, in a well-documented manner
12:53:08 <mwhit> of course you *can* understand it, but that takes an investment of time and effort
12:53:10 <kazagistar> I think people need to be willing to at least add shitty but *existing* documentation to start the process? "Please help me document better, but here are 10 random test cases and some unordered ideas I scrapped down"
12:53:15 <vanila> sometimes code doesn't need documentation
12:53:18 <kazagistar> that would still be more helpful then nothing
12:53:24 <Tjr> kazagistar: good suggestion.
12:53:25 <glguy> tjr: the community has traditionally had very little problem with reinventing things that already existing in a way they liked
12:53:39 <vanila> like if the source is well written and simple
12:53:42 <glguy> mwhit: They documented it because they wanted to produce a documented library and foster adoption
12:54:07 <glguy> orzo: Yes, it'd be neat if the bar to contributing documentation was lower
12:54:19 <Tjr> glguy: I can't speak for all of the community, but what I see, is that there is a problem.
12:54:45 <glguy> Tjr: OK
12:56:43 <orzo> vanila: i addressed that case.  even if it doesn't need documentation, having zero natural language explanation will promote badness when the practice is emulated
12:56:47 <dfeuer> I'd like it to be possible to add to/modify the documentation on, say, Hackage, without needing a version bump.
12:56:59 <bergmark> a lot of packages change a lot, maintaining documentation for that is a lot of work
12:57:56 <dfeuer> *Every* function should ideally be documented with both usage and efficiency information.
12:58:12 <kazagistar> bergmark: you can just add a note to the top of the documentation saying it is out of date... having a starting point at least means that people who want to help document have a place to start from
12:58:31 <dfeuer> I like the idea of users being able to propose documentation changes, although I think authors should be able to veto them.
12:58:41 <bergmark> kazagistar: usually i just forget to update the docs, and that might be worse than having no docs
12:59:04 * hackagebot heist 0.13.1.2 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.13.1.2 (DougBeardsley)
12:59:06 <orzo> dfeuer: yes, i was thikning the users would use a wiki interface on hackage, and the authros would pull from a repo representing the wiki
12:59:29 <mwhit> bergmark: sure, but that's your problem, not a problem with the concept of documentation
13:00:23 <bergmark> mwhit: it's a problem with how documentation is written
13:00:29 <mwhit> honestly with most libraries just a top-level description of the important parts of the api, and a handful of examples would be enough
13:00:39 <mwhit> that shouldn't change fast enough with most packages to be much of an issue
13:00:46 <mwhit> certainly other language communities seem to have no problem with it
13:00:54 <bergmark> mwhit: agreed
13:02:08 <kazagistar> I would rather have a slightly wrong example, and then fix it with type errors etc (and be able to fix the example) then have no example, ymmv
13:03:56 <mwhit> some kind of facility for adding type-checked examples would be neat. probably way beyond what haddock can do though
13:04:21 <glguy> That's what doctest does
13:07:08 <Fuuzetsu> yes, use doctest
13:10:01 <mwhit> ah
13:10:13 <mwhit> well, see, i didn't even know haskell *had* a doctest implementation
13:10:35 <mwhit> awesome, though
13:10:52 <Fuuzetsu> you can even put qc properties in haddock comments now
13:20:47 <jtakacs> hi
13:21:44 <jtakacs> could someone please look at my code and tell me why is it a thousand times slower than it's C counterpart?
13:21:47 <jtakacs> http://lpaste.net/107755
13:22:19 <jtakacs> something similar in C: https://github.com/nexgenta/opencaster/blob/master/tools/tspcrmeasure/tspcrmeasure.c
13:24:34 <mwhit> jtakacs: that's a lot to look through, but first thing i notice is both tloop and ploop are concatenating lists in an inner loop
13:24:38 <MP2E> jtakacs : Lists are very slow for collections of data. I'd use an Unboxed Vector from the vector library
13:24:46 <mwhit> concat is O(n) in the first argument
13:25:04 <MP2E> concat is still slow even with vectors though isn't it ?
13:25:30 <mwhit> oh yeah
13:25:34 <mwhit> in fact both of these
13:25:38 <mwhit> are just adding one element to the end of the list
13:25:41 <mwhit> you should be adding to the front
13:25:46 <Tjr> jtakacs:  (post-LYAH newbie here) line 54 is appending to a list. Note that operation has quadratic run-time in the list length when you build up a list.
13:26:09 <peddie> jtakacs: you could try Data.Sequence.Seq instead of a list
13:26:13 <Tjr> quadratic in the final list length
13:26:22 * Tjr seconds Seq
13:26:26 <mwhit> a : xs is O(1). xs ++ [a] is O(n)
13:26:27 <jtakacs> mwhit: I need to keep the order of the packets
13:26:28 <mwhit> also use seq
13:26:36 <peddie> or Data.DList.DList
13:26:39 <mwhit> jtakacs: keep the order, just reverse it
13:27:58 <peddie> jtakacs: use a : packets on line 54 and change line 53 to read "Nothing -> reverse packets"
13:28:30 <jtakacs> ok, so which one do I need: Unboxed Vector, Data.Sequence.Seq, or   Data.DList.DList ?
13:29:17 <peddie> jtakacs: I'd either try the list-prepending thing that mwhit is suggesting and I explained above or investigate one of Data.Sequence.Seq or Data.DList.DList
13:29:44 <peddie> jtakacs: if you really care about speed, you could try all of them and see which is fastest
13:29:50 <ihamsa> Hi, everyone, any GHC API gurus willing to help?
13:30:00 <Tjr> I'd favor Seq over DList because you loose much (all?) of the savings once you convert the dlist to an ordinary list, for traverals etc.
13:30:13 * Tjr can't say much about unboxed vector
13:30:30 <mwhit> and the only reason to use DList is for efficient concatenation, which you shouldn't be using unless you have a really good reason to
13:30:53 <MP2E> unboxed vector is crazy fast but maybe you should look into DList first
13:31:13 <MP2E> But yeah, when I switched a prime number summer from lists to unboxed vectors I say a speedup of 12x
13:31:20 <MP2E> saw*
13:31:21 <jtakacs> peddie: I really care about speed. This is a part of an mpegts streamer, so timing is important
13:31:48 <MP2E> I also wasn't using concat though and was careful to make the library fuse away the intermediate structure
13:31:51 <MP2E> ;)
13:32:49 <orzo>    jtakacs: why is ploop written tail recursive?
13:34:08 <jtakacs> holy sh##, reverse made it 500x faster
13:34:45 <MP2E> haha wow :P
13:35:00 <jtakacs> orzo: because I don't know anything about haskell?
13:35:04 <mwhit> you could probably also get rid of the single reverse by just rewriting tloop to expect its argument in the other order
13:35:12 <mwhit> probably not that big  deal though
13:35:56 <jtakacs> orzo: how would you write it?
13:36:37 <Tjr> jtakacs: the benefit of tail-recursing are a bit hazy. Sometimes it's better, sometimes it's slower. The reason is that tail-recursing assumes that you have a traditional call stack frame, whereas haskell does something else, intransparent.
13:38:28 <MP2E> tail recursion is rarely good unless you are evaluating to WHNF every call, guarded recursion is typically what you want
13:38:49 <MP2E> in other words, don't tail recurse unless you are forcing an answer for every call using seq or Bang Patterns
13:39:07 <Tjr> what is guarded recursion?
13:39:07 * hackagebot simple-pipe 0.0.0.2 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.2 (YoshikuniJujo)
13:41:16 <MP2E> Tjr: foldr is a good example, it means that the recursive calls occur inside a data constructor
13:41:31 <MP2E> vs outside the constructor like foldl does
13:41:33 <mwhit> @src foldr
13:41:33 <lambdabot> foldr f z []     = z
13:41:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:41:51 <RyanGlScott> I'm confused about the use of tildes (~) in type signatues, e.g., https://github.com/snoyberg/conduit/blob/master/conduit-extra/Data/Conduit/Process.hs#L30
13:42:03 <RyanGlScott> What exactly does r ~ () do?
13:42:06 <Tjr> RyanGlScott: equality constraint
13:42:29 <RyanGlScott> Tjr: Is there any advantage to doing this as opposed to putting () directly in the type signature?
13:43:01 <Tjr> f :: (a ~ b) => a -> b --- will trigger upon f :: Int -> Bool and complain
13:43:02 <cin> https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/equality-constraints.html
13:43:33 <orzo> jtakacs: maybe something like this, http://lpaste.net/107763
13:43:40 <Tjr> f :: a -> a --- compiler will not try to match Int -> Bool, simply not finding the correct f
13:43:48 <jtakacs> is there a way, to get rid of any of my recursive functions?
13:43:50 <glguy> instance (r ~ (), MonadIO m, i ~ ByteString) => InputSource (ConduitM i o m r) -- says that  this instance should be chosen as soon as "ConduitM" matches and than it automatically adds the equality constraints
13:44:12 <luite> MP2E: hmm, i wouldn't say that. that's just something to watch out for with accumulators in general
13:44:27 <glguy> If it was written as InputSource (MonadIO m => ConduitM ByteString o m ()) then it would only match if you had fixed the types to ByteString and ()
13:44:29 <glguy> it helps inference
13:44:30 <RyanGlScott> So is there a reason to use equality constraints besides with type families? I'm not seeing a practical use for this
13:44:52 <glguy> It's taking advantage of the way GHC resolves instances
13:44:53 <luite> MP2E: since foldr and lots of common functions like dropWhile are tail recursive it's not exactly rare
13:45:14 <glguy> ?src foldr
13:45:15 <lambdabot> foldr f z []     = z
13:45:15 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:45:21 <glguy> That doesn't look tail recursive
13:45:32 <orzo> maybe he meant foldl
13:45:40 <luite> uck
13:45:42 <MP2E> foldl is very rarely useful
13:46:35 <luite> glguy: perhaps my definition is different from yours, but it's tailcalling f, instead of in the base case
13:46:44 <RyanGlScott> Can you explain a little more how InputSource (MonadIO m => ConduitM ByteString o m ()) and instance (r ~ (), MonadIO m, i ~ ByteString) => InputSource (ConduitM i o m r) differ?
13:46:51 <orzo> what
13:46:54 <luite> err, i mean except in the base case
13:47:15 <orzo> luite: it is not tail calling, its passin ghte results of the recursion to f before returning
13:47:17 <MP2E> tail calling f? I'm confused... f isn't recursing here though
13:47:23 <MP2E> it's not tail call recursion
13:47:25 <peddie> luite: wouldn't tail-recursive mean it's calling foldr (itself) in tail position?
13:47:28 <glguy> luite: That's not what tail calls are
13:47:39 <jtakacs> orzo: I admit, it does look better (meaning: fewer characters), but it did not gave a significant improvement in speed
13:47:43 <luite> orzo: it is tail calling f, it applies f and returns the result, without doing anything with it
13:47:59 <RyanGlScott> Is the latter more "lenient" in what it accepts as an instance?
13:48:05 <Gurkenglas> @src foldr
13:48:05 <lambdabot> foldr f z []     = z
13:48:05 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:48:17 <Gurkenglas> Oops, someone already queried that.
13:48:20 <mwhit> luite: f is not what's recursing
13:48:33 <MP2E> Yeah f is being applied to each element of the structure, there is no recursion in f
13:48:34 <mwhit> @src foldl
13:48:34 <lambdabot> foldl f z []     = z
13:48:34 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:48:46 <mwhit> ^^ is tail recursive, because foldl is what's recursing
13:48:47 <MP2E> only in foldr, and it's not tail recursion because the recursion isn't the last thing that happens
13:48:59 <glguy> RyanGlScott: the InputSource (ConduitM i o m r) matches as soon as ConduitM matches.   ConduitM ByteString o m ()) only matches if it can be determined that i is a ByteString and r is ()
13:49:04 <luite> glguy: it is what tail calls are. although if you only want to allow self-calls in tail recursion then it doesn't fit the stricter definition
13:49:18 <orzo> when jtakacs used my version, he didnt get a speed improvment, that surprises me, any guru care to analyze now for my own benifit?
13:49:34 <peddie> luite: it may be a tail call, but it has to be a self-call for it to be a tail _recursion_, right?
13:49:48 <RyanGlScott> glguy: So if I used a ConduitM Foo o m Bar, what would happen?
13:50:02 <Gurkenglas> tail recursive means that the last operation done by an imperative function is the recursive call. The last operation done here is that of executing the definition of the first function named (or the lowest-priority infix operator)
13:50:06 <mwhit> RyanGlScott: ~ is basically saying "trust me GHC, this is what it is, don't bother checking", is what i've been told
13:50:14 <glguy> RyanGlScott: Type error when Foo ~ ByteString and () ~ Bar failed
13:50:33 <RyanGlScott> This is a compile-time check?
13:50:42 <jtakacs> orzo: please don't feel bad, I'm sure there are more errors lurking in my code which could be responsible for the slowness
13:51:07 <dfeuer> Data.Int says all arithmetic is modulo 2^n. That can't be right, can it? That makes sense for Data.Word, but not so much for Int.
13:52:12 <glguy> luite: Does your definition of tail call conflict with this one? http://www.haskell.org/haskellwiki/Tail_recursion
13:52:28 <glguy> Not that the wiki is the authority, just asking if it conflicts
13:52:34 <luite> glguy: no
13:52:56 <orzo> dfeuer: i'm not following? Int is fixed size, Integer is a bignum, are you confusing them?
13:53:25 <MP2E> dfeuer : Yeah... Data.Int is definitely sized by powers of 2. how else would they be sized?
13:53:31 <silasm> > max + 1 :: Int
13:53:32 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
13:53:33 <lambdabot>              with actual type ‘a0 -> a0 -> a0’
13:53:34 <glguy> luite: this case matches what's happening in the foldr example: t is "t0 t1" and f occurs tail recursively in t0 and does not occur in t1;
13:53:35 <luite> glguy: the result of applying f is the final result, which means no stack frame needs to be pushed
13:53:47 <silasm> > maxBound + 1 :: Int
13:53:49 <lambdabot>  -9223372036854775808
13:54:01 <mwhit> luite: tail call recursion means a function is tail calling itself. foldr is not tail calling itself. it is not a tail-recursive function
13:54:07 <MP2E> ^
13:54:22 <dfeuer> MP2E, sign!
13:55:18 <vanila> tail call isn't relevant to haskell
13:55:23 <vanila> as it's a lazy language
13:55:36 <vanila> in scheme tail call elimination is performed whether or not you're doing recursion
13:55:48 <vanila> this lets you make use of TCO to do things like state machines
13:55:49 <MP2E> does laziness force a lack of a stack frame?
13:56:23 <dfeuer> In Haskell you work with something more similar to tail recursion modulo cons.
13:56:30 <luite> vanila: it is relevant to some extent, but you have to keep in mind what's being evaluated in what order
13:56:47 <vanila> MP2E, in a strict language like scheme you basically create a stack frame for each procedure call - and TCO lets you eliminate it. The execution of a lazy language is completely different though, so the notion isn't relevant/doesn't apply
13:57:16 <vanila> MP2E, generally you would have your haskell functions/combinators/thunks on the heap join together in a graph - and the stack would be used to traverse that graph and rewrite it
13:57:17 <levi> GHC's execution model makes heavy use of tail calls and continuations, but "proper tail calls" a la Scheme and ML imply a different space cost semantics than Haskell has.
13:57:54 <vanila> When you use strictnes (with !) in haskell or inspect Core then you will be taking tail calls and things into account
13:58:00 <MP2E> ahh interesting
13:58:13 <vanila> in normal lazy programming such as foldr you wont
13:58:32 <dolio> It's very important.
13:58:43 <levi> So I think it's a bit misleading to say "tail call isn't relevant to haskell", but the relevance is very different than it is to Scheme or ML.
13:58:45 <dolio> foldr f z (x:xs) = f x (foldr f z xs)
13:58:49 <dolio> That tail calls f.
13:58:55 <dolio> It's important that it doesn't use stack.
13:59:21 <vanila> I agree that f is in the tail position but that doesn't mean there will be any 'tail call elimination' performed here
13:59:34 <dolio> The call to f doesn't use stack.
13:59:37 <jtakacs> could it improve my code if I made some variables strict?
13:59:41 <dolio> So it has been 'eliminated'.
13:59:42 <luite> yeah it looks like foldr doesn't quite fit the listed tail recursion cases
13:59:46 <dolio> If it did use stack, it'd be terrible.
14:00:19 <vanila> dolio, Oh I see what you mean, but I don't think that's anything to do with f being in tail position
14:00:30 <dolio> Why not?
14:00:44 <vanila> consider foldr' f z (x:xs) = C (f x (foldr' f z xs)) where C is some constructr
14:00:54 <luite> vanila: that has everything to do with that :)
14:00:59 <dolio> That's a tail call to C.
14:00:59 <peddie> jtakacs: best way to know if it makes it faster is to try it :)
14:01:10 <vanila> now f isn't in the tail position but the same happens
14:01:44 <RyanGlScott> Why was ErrorT deprecated in favor of ExceptT?
14:02:11 <mwhit> RyanGIScott: ErrorT requires the error type to be an instance of Exception, ExceptT doesn't, IIRC
14:02:13 <levi> The important thing for non-strict evaluation in constant space is the combination of a producing function with a consuming function mediated by data constructors.
14:02:13 <dolio> No, the same thing doesn't happen. That builds a closure that when entered evaluates 'f x (foldr' f z xs)'.
14:02:17 <dolio> And tail calls C with it.
14:03:07 <orzo> if C is a newtype constructor, we certainly would hope the same thing happens as ideally its application would be costless
14:03:54 <dolio> If it's a newtype that's a different story.
14:03:55 <luite> orzo: but then it's different, since the field would be strict
14:04:23 <luite> and it's still different from a data with a strict field
14:04:27 <luite> since that wouldn't be a tail call anymore
14:04:30 <dolio> Although if all optimizations are off, it might still be different.
14:04:58 <RyanGlScott> Curiously, mtl still uses MonadError in Control.Monad.Except. Is there a reason it isn't called MonadExcept?
14:05:01 <dolio> It might be the same as: foldr' f z (x:xs) = (\x -> x) (f x (foldr' f z xs))
14:05:53 <vanila> Well take that foldr' example, a call to foldr would be replaced with that application: (\x -> x) (f x (foldr' f z xs)), and then overwritten with f x (foldr' f z xs)
14:05:59 <orzo> maybe there should be some minihaskell compiler that demonstrates the execution model to build intuition
14:06:12 <vanila> you have the same behavior in terms of memory as with foldr' but 'f' wasn't in the tail position here
14:06:52 <dolio> You will use slightly more memory.
14:07:12 <dolio> Because you build a closure for (f x (foldr' f z xs)) and call (\x -> x) with it.
14:07:28 <levi> orzo: Haskell itself doesn't have an execution model, but GHC's execution model is explained pretty clearly in the Spineless Tagless G-Machine paper. And you can instruct GHC to give you the STG code for your program.
14:07:54 <dolio> But (\x -> x) tail calls x.
14:07:55 <luite> you use some stack here (unless the optimizer kicks in) to evaluate (\x -> x)
14:08:09 <vanila> dolio, yes - that's just temporary. Unlike in a strict language that doesn't optimize tail calls, the stack frame stays around doing nothing until the entire thing returns - this is why TCO is needed
14:08:13 <dolio> So you probably won't use more stack.
14:08:17 <vanila> and this is why its not needed in haskell
14:08:21 <orzo> vanila: was the STG paper important to building your intuition?
14:08:45 <luite> but that's not recursive so that's only one frame (some stg_ap frame in GHC)
14:08:50 <dolio> vanila: No. it's very important that tail calls, _all tail calls_ don't use stack in a lazy language.
14:09:05 <dolio> Because tail calls are happening everywhere.
14:09:08 <hansoso> http://lpaste.net/7626607031331323904 playing with the state monad what is wrong with my deduction? Why don't i get the state as the result?
14:09:12 <vanila> I think you're mixing up two different execution models
14:09:33 <levi> vanila: Which execution model are you describing?
14:09:45 <dolio> I'm describing the execution model of GHC.
14:10:31 <orzo> dolio: did you read the STG paper?
14:10:36 <dolio> Of course.
14:10:44 <dolio> I've implemented an interpreter based on it at work.
14:11:13 <dolio> It's a good paper.
14:11:43 <johnw> hansoso: I think variable naming is messing you up here
14:11:46 <dolio> GHC's somewhat different these days. But the core ideas are similar, I think.
14:11:50 <johnw> hansoso: the 'a' in your final step is the state
14:11:51 <Eliott21>  Here some videos. I hope you like them! http://bitly.com/1qRDdSK
14:12:16 <johnw> you got the state with get, you put it back in (a no-op), and put returns () as its value
14:13:25 <levi> There are a couple of other papers that explain what has changed; GHC is no longer fully tagless, and non-saturated applications are now evaluated with eval/apply rather than push/enter.
14:13:42 <luite> vanila: the thing to keep in mind is that all evaluation happens because the outermost result is being reduced to WHNF. if that happens to be the result of a tail call to f you can always apply the function immediately without using stack (as long as f itself is in whnf)
14:14:05 <Tjr> What's whnf?
14:14:09 <hansoso> johnw: but put is something like a -> State so i give it te result of the first computation, not?
14:14:25 <johnw> hansoso: sure you can; I'm saying that I don't see anything wrong with your reasoning
14:14:30 <johnw> what were you expecting the final value to be?
14:14:52 <luite> vanila: if it's not a tail call, but say, a pattern match on the result of applying f, you have to push something to the stack to do that match
14:15:17 <levi> WHNF is a fancy lambda calculus term "Weak Head Normal Form" to describe something that can't be immediately evaluated further.
14:15:35 <hansoso> johnw: some s' or so, but i think i start to see what you mean
14:15:44 <Tjr> thanks
14:16:40 <luite> Tjr: it's either a data constructor or a fully reduced function
14:16:59 <hansoso> johnw: oh yeah, thank you very much i see it now
14:17:20 <johnw> hansoso: I like seeing people use equational reasoning to figure these things out :)
14:17:33 <levi> In plain lambda calculus, 'Normal Form' is what you use for terms that can't be evaluated further. But in lambda calculus models of most programming languages, the order of evaluation is defined so that you can't evaluate terms *inside* the body of things like lambda abstractions or data constructors.
14:18:02 <dolio> The point of WHNF is to describe what actual implementations do.
14:18:16 <dolio> Not what you could do if you were doing symbolic evaluation.
14:18:39 <levi> Right; the differences boil down to evaluation order.
14:18:49 <dolio> And most implementations don't go generate new code at runtime to 'evaluate under lambdas'.
14:19:52 <hansoso> johnw: works better then my brain :)
14:21:38 <trap_exit> what is wrong with my defitnion of expr_rec0 ? https://gist.github.com/anonymous/43b01e434d52e67e7488
14:22:15 <trap_exit> fixed
14:22:20 <trap_exit> how do I rewrite https://gist.github.com/anonymous/50ea96be90b72dcd4af8 using GHC.Generics ?
14:26:56 <jtakacs> orzo: sorry, I was wrong. between my original implementation and your code, there is a 500x speed improvement. I was comparing it to mwhit's solution using reverse.
14:27:03 <asfp``> What is the command to figure out why cabal chooses a given version for a dependency?
14:27:34 <orzo> jtakacs: \o/
14:28:01 <trap_exit> please help me finish using ghc.generics: https://gist.github.com/anonymous/6a576931bf179747e9c5
14:29:59 <hansoso> Is there a technical reason, why State is s -> (a,s) instead of s -> (s,a)?
14:30:43 <glguy_> Trap_exit you need two classes to do it the normal way
14:31:05 <glguy_> One for generic cases and one for not generic cases
14:31:42 <glguy_> I'll show you when I'm back at my computer if no one else does, or search my name on lpaste for some example code
14:33:17 <glguy_> Unfortunately it probably won't be much shorter to use ghc generics to do this
14:34:09 * hackagebot base 4.7.0.1 - Basic libraries  http://hackage.haskell.org/package/base-4.7.0.1 (HerbertValerioRiedel)
14:36:36 <trap_exit> how do I get GHC>gnerics to work? in https://gist.github.com/anonymous/a891e3f26265cc7e1213 all I want to say is: for each constructor, clal recurse on it's argument
14:36:46 <trap_exit> this seems like a trivial thing to do in GHC.GENERICS
14:41:29 <luite> does cabal only pass the -j flag to ghc when running cabal build, or for cabal install too in some cases?
14:44:10 * hackagebot simple-pipe 0.0.0.3 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.3 (YoshikuniJujo)
14:48:11 <ihamsa> Hi all, any ghc api gurus out there?
14:49:49 <bergey> asfp: cabal install -v3, then read the (long) output.
14:50:26 <jtakacs> if I have a [Maybe] list, how can I make it into a list of tuples, where the first element is the index, the second is the original value. Then how do I drop the tuples from the list, where the second value is Nothing?
14:51:23 <jtakacs> (I'm trying to get rid of my tloop function)
14:51:59 <sipa> > zip [0..] [Just 5, Nothimg, Just 3]
14:52:00 <lambdabot>  Not in scope: data constructor ‘Nothimg’
14:52:01 <lambdabot>  Perhaps you meant ‘Nothing’ (imported from Data.Maybe)
14:52:15 <sipa> > zip [0..] [Just 5, Nothing, Just 3]
14:52:17 <lambdabot>  [(0,Just 5),(1,Nothing),(2,Just 3)]
14:52:43 <bergey> > filter (isJust . snd) $ zip [0..] [Nothing, Just True, Just False]
14:52:45 <lambdabot>  [(1,Just True),(2,Just False)]
14:55:53 <jtakacs> thanks. almost there, I still need to get rid of the Justs, but let me figure that out.
14:56:17 <MP2E> @hoogle Maybe a -> a
14:56:19 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
14:56:20 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
14:56:20 <lambdabot> Data.Monoid First :: Maybe a -> First a
14:56:22 <MP2E> ;)
14:57:24 <levi> @hoogle [Maybe a] -> [a]
14:57:24 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
14:57:24 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
14:57:24 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:57:53 <bergey> :t second
14:57:54 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
14:58:59 <jtakacs> @hoogle [(Int,Maybe Int)] -> [(Int,Int)]
14:59:00 <lambdabot> No results found
14:59:09 <jtakacs> @hoogle (Int,Maybe Int) -> (Int,Int)
14:59:09 <lambdabot> No results found
14:59:54 <glguy> @tell trap_exit This is how your expr_rec0 turns out with ghc.generics http://lpaste.net/107765
14:59:54 <lambdabot> Consider it noted.
15:00:39 <mwhit> @hoogle [Maybe a] -> Maybe [a]
15:00:39 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
15:00:39 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
15:00:39 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
15:01:27 <mwhit> @hoogle (a->b) -> [f a] -> [f b]
15:01:27 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
15:01:27 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
15:01:27 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
15:01:45 <mwhit> i'm trying to come up with a solution that doesn't involve using fromJust
15:02:17 <mwhit> @hoogle (a, Maybe b) -> Maybe (a, b)
15:02:18 <lambdabot> No results found
15:02:38 <mwhit> hm
15:04:31 <TheKing444> Hello
15:04:35 <glguy> :t mapMaybe sequenceA . zip [0..]
15:04:35 <lambdabot>     Not in scope: ‘sequenceA’
15:04:36 <lambdabot>     Perhaps you meant one of these:
15:04:36 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
15:04:37 <levi> If you have pairs where the first element is the int index, you have something very much like an IntMap.
15:04:41 <TheKing444> How do I get haskell to use /dev/random.
15:04:43 <glguy> :t mapMaybe T.sequenceA . zip [0..]
15:04:44 <lambdabot> (Num a1, Enum a1) => [Maybe a] -> [(a1, a)]
15:05:03 <glguy> > (mapMaybe T.sequenceA . zip [0..]) [Just 'a', Nothing, Just 'b', Just 'c', Nothing]
15:05:05 <lambdabot>  [(0,'a'),(2,'b'),(3,'c')]
15:05:06 <TheKing444> Perefrably for MonadRandom
15:05:17 <TheKing444> Preferably
15:05:56 <glguy> > itoListOf (folded <. folded) [Just 'a', Nothing, Just 'b', Just 'c', Nothing]
15:05:58 <lambdabot>  [(0,'a'),(2,'b'),(3,'c')]
15:06:11 <levi> Well, to use /dev/random, you just have to open and read from it. I am not sure if there's a way to hook that up to MonadRandom.
15:06:25 <TheKing444> Well, I know I could just open it.
15:06:47 <TheKing444> I was wondering if there was an api though.
15:07:28 <mwhit> lens folds still bend my brain. sometimes traversals too
15:07:45 <mwhit> :t (<.)
15:07:46 <lambdabot> Indexable i p => (Indexed i s t -> r) -> ((a -> b) -> s -> t) -> p a b -> r
15:07:59 <glguy> <. keeps the indexes from the left side
15:08:09 <mwhit> i don't know why i thought a type signature would be helpful for a lens function
15:10:39 <mwhit> :t iToListOf
15:10:40 <lambdabot>     Not in scope: ‘iToListOf’
15:10:40 <lambdabot>     Perhaps you meant one of these:
15:10:40 <lambdabot>       ‘itoListOf’ (imported from Control.Lens),
15:10:46 <mwhit> :t itoListOf
15:10:48 <lambdabot> IndexedGetting i (Endo [(i, a)]) s a -> s -> [(i, a)]
15:11:23 <levi> TheKing444: You might find this thread helpful if you haven't seen it already: https://groups.google.com/forum/#!topic/haskell-cafe/sf1R7-DfFc8
15:11:39 <jtakacs> getPCRlist :: [MpegTSPacket] -> [(Int,Int)]
15:11:40 <jtakacs> getPCRlist mpegts = fmap (\(a,Just b)->(a,b)) $ filter (isJust.snd) $ zip [0..] $ fmap getPCR mpegts
15:11:51 <glguy> itoListOf :: Given a way to get 'a's out of 's's, each of which is indexed by an 'i', and an 's', return a list of pairs of indexes and 'a's
15:12:24 <TheKing444> found crytpo-api package
15:12:25 <jtakacs> ok, this made my code 3x faster, but I'm not sure I wrote it the right way
15:12:44 <jtakacs> can somebody spot any errors?
15:13:07 <mwhit> jtakacs: at the very least that should throw you a warning about incomplete pattern matching, i think
15:13:17 <mwhit> but the correct match is guaranteed by the use of isJust
15:14:35 <jtakacs> mwhit: first time it did give me a warning, but the first time that lambda was a separate function
15:15:10 <jtakacs> that's why I'm asking for review
15:17:16 <mwhit> huh it appears GHC doesn't warn about non-exhaustive pattern matching in lambdas. seems weird
15:18:01 <mwhit> anyway, your lambda is a partial function, which is usually bad. it's guaranteed to work b/c of isJust; some people might see that as "bad form" but it will work
15:19:05 <levi> You might need to turn your warning level up.
15:19:28 <jtakacs> is there a warning level above -Wall
15:19:30 <jtakacs> ?
15:20:50 <Pythonfant> jtakacs: I don't think so
15:20:56 <Pythonfant> after all the all stands for all warnings
15:21:00 <mwhit> yeah i just tried with -Wall, no warning
15:21:20 <levi> Usually "all" is not quite *all* warnings, though it depends on the compiler.
15:21:29 <Pythonfant> levi: imho that's kinda stupid
15:21:40 <felixn> mwhit: I've gotten that too, it's a real heartbreaker
15:21:48 <Fuuzetsu> does anyone know if https://medium.com/cool-code-pal/the-hassle-of-haskell-a74862541dfb is a bait and I'm taking it?
15:22:54 <levi> Fuuzetsu: It's complicated; I'd avoid involvement at this point.
15:23:11 <mwhit> Fuuzetsu: i'd say that's a pretty obvious troll; if not, jfc
15:23:34 <felixn> yea.... "it’s not portable like vanilla JavaScript and also takes up space unlike vanilla JavaScript" ... JS doesn't take up space? @_@
15:23:42 <Fuuzetsu> no, because JS is in the cloud
15:23:46 <Fuuzetsu> everyone knows that
15:24:02 <glguy> Fuuzetsu: I believe that post is satire in response to some recent uninformed "I'm changing languages" posts
15:24:04 <mwhit> looking at the writer and publisher descriptions... definitely troll
15:24:13 * hackagebot simple-pipe 0.0.0.4 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.4 (YoshikuniJujo)
15:24:16 <Fuuzetsu> ok, good
15:24:23 <Fuuzetsu> I'm prepared to take anything seriously nowadays
15:24:31 <Pythonfant> “… as vanilla JavaScript, unfortunately, is not backwards compatible from Node.”…
15:24:35 <Pythonfant> that makes no sense
15:24:46 <levi> It's mostly satirical.
15:24:56 <felixn> I will concur that Haskell is not the perfect language that all the imperative programmers think it is
15:25:16 <mwhit> haha the css perverts page is pretty great actually
15:25:23 <hiptobecubic> this is a great post :D
15:25:34 <hiptobecubic> haskell has to be installed, therefore it's not portable
15:25:37 <levi> But not entirely. She did apparently have a bad experience with some Haskell developer a while back related to that quirk of haskell's parser.
15:25:43 <jtakacs> omg, i hate javascript with a passion. why is it even mentioned on the #haskell channel?
15:25:47 <vanila> > [-10..5]
15:25:49 <lambdabot>  [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5]
15:25:56 <hiptobecubic> unlike javascript, which apparently does not have to be installed. All machines come with node by default and always have
15:25:58 <Pythonfant> jtakacs: gotta know your enemy
15:26:03 <vanila> > [-10..-5]
15:26:05 <lambdabot>  Not in scope: ‘..-’
15:26:05 <lambdabot>  Perhaps you meant ‘...’ (imported from Control.Lens)
15:26:17 <Pythonfant> hiptobecubic: node: command not found
15:26:25 <Fuuzetsu> …
15:26:29 <hiptobecubic> Pythonfant, you must have a broken environment
15:26:30 <Fuuzetsu> :t Control.Lens....
15:26:31 <lambdabot> parse error on input ‘Control.Lens....’
15:26:34 <Fuuzetsu> :t Control.Lens.(...)
15:26:34 <lambdabot> Not in scope: data constructor ‘Control.Lens’
15:26:39 <Pythonfant> hiptobecubic: I'm sure of it
15:26:41 <Fuuzetsu> oh uh
15:26:43 <Fuuzetsu> :t (...)
15:26:43 <lambdabot> (Plated c, Applicative f) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
15:26:46 <Fuuzetsu> why
15:27:09 <glguy> I actually don't know that one :)
15:27:44 <Fuuzetsu> I wish that wasn't allowed
15:29:18 <hiptobecubic> Given the rest of this blog, i'd say there isn't anything here that's meant to be taken seriously whatsoever
15:30:43 <felixn> "Overall this is and improvement
15:30:51 <hiptobecubic> this is a great blog
15:30:57 <Pythonfant> looks like some good entertainment :)
15:31:05 <jtakacs> what does vanilla javascript even mean? vanilla is a flavour, just like any other flavours
15:31:10 <felixn> lol ok I got nerd sniped by how ridiculous these articles are lol
15:31:27 <Gurkenglas> "vanilla" usually means "without any addons/modifications"
15:31:44 <Pythonfant> jtakacs: well it's obvious isn't it? It's javascript that doesn't taste like chocolate
15:31:55 <Fuuzetsu> what taste is Node?
15:32:04 <Fuuzetsu> crap?
15:32:05 <Pythonfant> shit?
15:32:39 * Fuuzetsu scuttles off before language police wakes up
15:32:51 <jtakacs> I would like a javascript variant that doesn't have a shitty aftertaste. That would be good enough for starters.
15:33:29 <hiptobecubic> jtakacs, surely there's one out there
15:33:34 <hiptobecubic> purescript? typescript?
15:33:44 <hiptobecubic> INTERCALSCRIPT
15:33:55 <mwhit> ghc2js?
15:35:06 <jtakacs> I plan to try fay, purejs, and/or other haskell to js compilers
15:35:17 <jtakacs> but first I just want to learn haskell
15:35:19 <augur> aristid: categorial grammars ahoy!
15:35:31 <glguy> Talking about how shitty other languages taste is off topic for #haskell. I shouldn't have to say that :)
15:36:00 <jtakacs> glguy: ok, i'm finished.
15:53:51 <aristid> hey augur
15:54:29 <aristid> augur: how so?
15:54:38 <dfeuer> unlambdascript.
15:55:57 <augur> aristid: i wrote a parser that uses CG instead of HPSG
15:56:08 <aristid> what is HPSG?
15:56:17 <augur> aristid: managed to do that in a few hours, and it makes everything simpler
15:56:27 <dfeuer> What is CG?
15:56:54 <aristid> dfeuer: one at a time!
15:57:32 <augur> pahaha aristid
15:57:55 <aristid> do explain.
15:57:55 <augur> i meant to ping adimit and got my a*i*i* names mixed up
15:57:56 <augur> <3
15:58:07 <augur> damn you all to hell
15:58:11 <aristid> ah
15:58:21 <aristid> augur: still a bit curious what HPSG is.
15:58:24 <augur> awful
15:58:32 <augur> aristid: HPSG is a grammar formalism based on graph unification!
15:59:45 <aristid> augur: all this is still related to your linguistic work?
15:59:56 <augur> well, this is for my startup
16:00:23 <aristid> how does this help finding product-market fit?
16:01:56 <augur> aristid: well, switching to a categorial parser makes things simpler, and easier to modify, so it lets me write grammars faster (because there are fewer bugs) and make relevant changes more quickly in response to future user/developer feedback
16:02:35 <aristid> augur: what does your startup do?
16:02:58 <augur> aristid: natural language user interfaces
16:03:06 <augur> aristid: halfway between Siri and Her, thats the goal
16:03:28 <aristid> ah
16:03:57 <aristid> do you hand-write the parsers for each language?
16:04:49 <augur> aristid: the new parser is for a lexicalized grammar formalism -- Categorial Grammar -- so the only thing that needs to be written is the common core for the language (the things that are non-task-specific)
16:05:14 <augur> plugins will then supply task-specific words
16:05:17 <aristid> augur: and how do you go from natural language to the formalism?
16:05:27 <augur> aristid: quite well, thanks for asking!
16:05:30 <augur> ;)
16:05:41 <aristid> augur: secret sauce?:P
16:05:50 <augur> right now its just a text-based parser, if thats what you mean
16:07:17 <aristid> augur: everybody knows(tm) that you have to use machine learning techniques! :)
16:07:19 <kazagistar> um text you know is um kinda     um a bit different changed maybe altered from um you know    how you um   say things
16:07:34 <augur> aristid: machine learning is for generating grammars, not for parsing them
16:07:59 <Luonnon> Basic ADT question.  Assuming I have something like: "data Fruit = Peach | Pear | Apple" is there any way I can constrain a function to only take apples? "exampleFn :: Apple -> String" spits out "Not in scope: type constructor or class `Apple'"
16:08:00 <augur> kazagistar: yes thanks for that stunning insight >_>
16:09:02 <vanila> Luonnon, you cannot
16:09:05 <aristid> kazagistar: one thing i like in spoken language is these resets where you begin the sentence with one grammatical structure and end with another... now to make an example
16:09:08 <kazagistar> Luonnon: not directly, just like you cannot take a function to only take the number 3
16:09:21 <Luonnon> Is there conceptually a better way to do what I'm trying to do?
16:09:38 <Exio> maybe phantom types?
16:09:56 <vanila> no
16:10:12 <vanila> Luonnon, you can do it like this:
16:10:13 <vanila> data Fruit = Peach | Pear | AppleFruit Apple
16:10:16 <vanila> data Apple = Apple
16:10:24 <hiptobecubic> ugh
16:10:24 <vanila> this embeds Apple in Fruit
16:10:28 <kazagistar> aristid: its grammatically correct to use a reset, but that is more indicative that grammar rules dont fully reflect the restrictions on how people communicate
16:10:48 <aristid> "I never... you never gonna see Filipe"
16:11:04 <aristid> ok that's more of a backtracking
16:11:16 <Luonnon> That seems like a better idea thatn what I was going to do.  Thanks, vanila!
16:11:19 <Luonnon> vanila++
16:11:38 <dfeuer> I'm still messing around with reimplementing Data.List.inits. Based on an idea from edwardk, I came up with an implementation using banker's deques. The only queue operations I need are createEmpty, snoc and toList, so I stripped down the banker's queues from two sized lists to two lists and a total size (plus 1), so I can use popCount to decide when to rotate the queue. I'm wondering if anyone knows an even simpler/faster way to implement those.
16:11:54 <hiptobecubic> Luonnon, the problem is that Apple is value, like 5. You're basically asking "how can i restrict my function to only operate on 5"
16:12:03 <augur> aristid: people are surprisingly well behaved in their grammatical structures. studies have shown that people produce far fewer ungrammatical sentences that previously thought
16:12:04 <hiptobecubic> Luonnon, the embedding is a snarky way around it
16:12:26 <aristid> augur: not saying it's not grammatical, just that there's a difference between written and spoken language
16:12:42 <augur> aristid: well, sometimes you see people doing that in written language too :P
16:12:59 <jtakacs> Luonnon: maybe you need something like this: http://stackoverflow.com/questions/10457538/how-to-create-type-which-contains-string-with-limited-length-in-haskell
16:13:03 <vanila> hiptobecubic,  "snarky"?
16:13:23 <aristid> augur: i would usually rewrite my sentence instead
16:13:39 <augur> aristid: true, tho sometimes its used for effect
16:13:43 <hiptobecubic> vanila, i personify my code a little too much :)
16:13:50 <kazagistar> auger: but if you generate grammatical sentences, that does not mean that humans will ever speak or be able to parse them. the normal grammars are at best a bound on human speach patterns
16:13:58 <vanila> it's just the way to embed one data type in another
16:13:58 <augur> aristid: i .. uh.. what do you.. er.. mean..?
16:14:04 <augur> aristid: for example.
16:14:17 <augur> kazagistar: i dont know what that means
16:14:56 <aristid> augur: and the text people write here is not representative of the majority of written text today anyways
16:15:49 <kazagistar> if you are trying to parse or generate human text, then it should be clear that "Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo" is not a sentence that humans can use in communication
16:16:27 <augur> kazagistar: i can parse that adequately, tho its highly unlikely that i, or anyone else, would use it. i dont get your point tho
16:17:06 <kazagistar> well if you are only parsing, it has a slightly lower implication
16:17:49 <kazagistar> but if you are generating text, you have to be careful not to just generate sentences that "look" like that, where their structure is beyond the bounds of observed language
16:17:57 <aristid> augur: another thing i find kinda cool is the role rhythm seems to play... i kind of like those old (e.g. Goethe) texts that follow a strict meter, but i think any language probably follows some kind of rhythm, amiwrong?
16:18:09 <augur> kazagistar: of course you want to generate sentences that are reasonable, yes
16:18:33 <augur> aristid: there is such a thing as prosody, yes
16:18:47 <kazagistar> and if you are resolving ambiguities (for example in punctuation) you need some model beyond grammar to help you decide which sentences are silly... not just semantics, but structure, not all structures are equal
16:19:00 <kazagistar> well, need is too strong a word
16:19:11 <augur> kazagistar: yes, thats what statistical information provides
16:20:31 <kazagistar> hmm, thats probably sufficient for a reasonably working product
16:22:27 <solidus-river> hmm, i need to decide how to do hit checks for a point lying inside an arbitrary set of connected line segments in a plane
16:22:36 <solidus-river> so i gues a check for a point lying within an NGon
16:22:54 <solidus-river> and it seems like its not so easy to come up wtih an algorithm for that
16:22:58 <kazagistar> in my mind "statistics" hint at a place where there is potential for an actual model
16:23:04 <Luonnon> How is something similar to OOP's inheritance implemented in Haskell?  For example, in a game a monster and a player character would both be entities which should share quite a few functions.  However, they're going to have their own specific functions, too.
16:23:10 <Luonnon> Do I need to read more about typeclasses?
16:23:21 <solidus-river> Luonnon: you'd use a class to describe their shared functionality
16:23:25 <solidus-river> and each would instance that class
16:23:49 <solidus-river> functions that need that behavior from their inputs would constrain them to beign instances of that class
16:23:55 <solidus-river> *being
16:23:58 <augur> kazagistar: stats over syntax + stats over semantics is almost certainly how humans do it
16:24:06 <augur> kazagistar: so it seems like a reasonable thing to use in code
16:24:11 <Luonnon> Ok.  That makes more sense.  Thanks for pointing me in the right direction.
16:25:19 <solidus-river> np, glad to help :)
16:26:58 <kazagistar> augur: right, that is reasonable, though for parsing its probably enough, but if you generate speech, understanding the limitations of the human brain in parsing might be important
16:27:18 <augur> im not sure what you're intended with that, kazagistar
16:27:47 <jtakacs> augur: Time flies like an arrow. Fruit flies like a banana.
16:28:29 <jtakacs> I think that's an example of what kazagistar means
16:28:49 <Preyer> Is this the correct way of getting a random float?:
16:28:51 <Preyer>   let (rand, gen) =  random gen :: (Float, StdGen)
16:28:54 <augur> well, thats just an issue with ambiguity and strong statistical biases
16:29:03 <Preyer> gen is gotten by <- newStdGen
16:29:38 <rasfar> Preyer: I believe so, but usually the constraint isn't nec so I wondered at first
16:30:08 <Preyer> rasfar: nec?
16:30:24 <rasfar> * nec. sorry
16:30:47 <Preyer> Didn't get the abbreviation
16:31:24 <rasfar> guess it's not so common; i use it a lot when writing longhand
16:31:58 <kazagistar> right, in the classic example jtakacs brought up, realizing that the second sentence will likely be parsed according to the same pattern as the second in close succession would require some ideas beyond "syntax and statistics"
16:32:31 <Preyer> rasfar: I mean I still don't understand what nec. stand for :D
16:32:38 <rasfar> ahaha
16:32:57 <rasfar> "necessary" -- PITB to write in cursive
16:33:05 <Preyer> Ah, okay
16:33:10 <rasfar> (please don't ask me what PITB means...)
16:33:22 <codygman> Can you use gtk2hs and netwire together? Parts of what I'm working on would be suited to a gui with gtk2hs but others would be much more suited to netwire.
16:33:22 <hpc> it's easier if you type in a print font ;)
16:33:47 <jtakacs> PITB == Punjab Information Technology Board
16:34:11 <Preyer> Wouldn't be surprised if they wrote everything in cursive
16:34:16 * hackagebot pandoc-types 1.12.4 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.12.4 (JohnMacFarlane)
16:34:18 * hackagebot metrics 0.2.1.0 - High-performance application metric tracking  http://hackage.haskell.org/package/metrics-0.2.1.0 (IanDuncan)
16:34:28 <rasfar> perfect / heehee I have an Indian pen or two...
16:35:17 <rasfar> @tell dfeuer that's awsome; i'm happy to have witnessed that!
16:35:17 <lambdabot> Consider it noted.
16:45:38 <dfeuer> Hi rasfar. The only question left is whether it's possible to do better/simpler. The nice thing about the stripped-down banker's queues is that the lazy rebuilding (if I understand things correctly) ensures that the work to make the beginning of each list available is shared. So if you want to traverse the nth, n+1th, n+2th lists to a depth of k each, the total work will be O(n)+O(k). Traversing a produced list is slowed by the delayed ++, but that's i
16:46:15 <hpc> your line is cut off - "delayed ++, but that's i"
16:46:23 <rasfar> yeah, when I looked at the standard definition, i wondered about the sharing
16:46:39 <rasfar> ^ what hpc said
16:46:56 <dfeuer> but that's incremental. The monolithic reversal cost seems to be sufficiently shared.
16:47:41 <rasfar> the  map reverse  is somehow using sharing you think?
16:48:20 <rasfar> i wouldn't have expected that, but then no real basis for expectations as i never benchmark really
16:49:01 <rasfar> have you generated Core and had a peek at that? normally i don't go there, but it's such a small intricate function and there's 3 versions to compare
16:49:13 <dfeuer> rasfar, it does not, which makes it expensive to access, say, the heads of the nth, n+1th, ... n+100th lists in inits [1..n+1001] for large n.
16:49:57 <rasfar> because doing so forces reversal of all the predecessor inits?
16:50:32 <rasfar> there is scanr as well; have you considered trying to leverage that and maybe even get rid of reverse?
16:51:07 <dfeuer> The map reverse implementation ends up doing essentially what you'd do using non-persistent banker's queues. Okasaki's persistently amortized banker's queues rotate more often to share more work.
16:51:59 <rasfar> oh yeah, you mentioned banker's queues but i'm not familiar and glossed over that ... will read a definition
17:02:35 <orzo> I played with FRP a long time ago, and basically walked away disatisfied.  But things have surely progressed since then, and I'm looking for opinions from people with more recent experience.	My current problem domain involves downloading objects via http where the objects themselves have built-in expirations before which a cached value should be used, but often the expirations are fairly short
17:02:41 <orzo> lived.	
17:02:56 <orzo> Is FRP an approrpriate design for this, and if so, what FRP framework/library should i look at
17:06:36 <carter> orzo: you want to work in a discrete event setting?
17:06:39 <codygman> orzo: From my research everything has pointed to netwire.
17:07:04 <carter> i'm told reactive banna is nice for discrete asychronous events
17:07:41 <Cale> orzo: That sounds somewhat of an appropriate task for FRP, but maybe too simple to bother with it?
17:08:30 <orzo> hm
17:08:41 <jle`> i don't think netwire is too great for this situation...it looks like things are driven by events and timeouts
17:09:07 <orzo> it seems very discrete to me, ya, is FRP more for continuious events?
17:09:48 <jle`> sodium and reactive-banana are for event-driven stuff
17:09:57 <jle`> but netwire is sort of built from the ground up for continuous processes
17:10:02 <jle`> "frame-driven"
17:10:12 <jle`> so...different implementations of FRP for different situations
17:11:02 <orzo> time-outs dont really trigger handling, just when a cached value is demanded, its expiration date is checked first so that it could be updated
17:11:47 <jle`> it still looks like it's not a situation where you wouldn't benefit from having a constant clock recomputing all of your values at every tick
17:11:59 <orzo> yeah probably not
17:12:11 <jle`> sodium/reactive-banana is probably the frp approach you are looking for here
17:13:00 <orzo> Cale's comment seems to imply its probably a waste of time to bother with FRP, do you agree, jle` ?
17:13:19 <carter> dpeends
17:13:27 <carter> its stiill a research problem
17:13:31 <carter> and even when its right
17:13:34 <carter> its not a magic serum
17:13:42 <carter> you still hve to write code thats not crap :)
17:13:51 <orzo> i only considered FRP because my old approach seemed not-quite-right to me, from an elegance stand point
17:14:43 <jle`> i haven't used sodium etc. in practice.  this seems like something they could easily handle.  if you're looking for something more elegant, perhaps it's worth looking at them if only for a learning experience
17:15:03 <rudi_s> Hi. Is there a library function to pad a list to a certain length with a custom padding character? I can write it myself but maybe I just missed it when looking for it.
17:16:43 <dwcook> rudi_s, something like \n x xs -> take n (xs ++ repeat x) -- ?
17:17:01 <orzo> i have an algorithm that makes use of url-located inputs, and i think of that algorithm in a pure sort of fashion, but its complicated by the fact that the downloaded objects can and do change
17:17:12 <dwcook> (That will also cut the list down if it's too long)
17:17:48 <rudi_s> dwcook: Yeah, something like that, thanks.
17:17:49 <hansoso> ifZero : M A × M A → M A ifZero = λk.get () >>= λs.if s = 0 then f st k else snd k How would this look like with app from ArrowApply?
17:18:09 <orzo> my old approach was to actually make a monad which is IO under the hood, but is restricted to downloading/caching IO
17:19:12 <orzo> Cale: does that monad approach sound bad or overkill to you?
17:19:19 * hackagebot highlighting-kate 0.5.8.5 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.8.5 (JohnMacFarlane)
17:19:55 <orzo> i mean, it is probably more straight-forward to simply expose IO in my interface
17:20:38 <orzo> this url/caching problem has surely been solved before, anybody know any other libraries i should look at?
17:27:18 <rasfar> maybe https://hackage.haskell.org/package/TCache ?  uses STM  not sure how fast your entities expire
17:27:28 <rasfar> there's also lrucache
17:27:50 <rasfar> (i've no experience with either)
17:28:47 <codygman> So I saw the recent medium article by Jenn Schiffer about [0..-5] or w/e and started plaing around with examples. This is odd:
17:28:52 <codygman> > [5.. -1]
17:28:53 <lambdabot>  []
17:29:18 <roboguy_> > [5, 4 .. -1]
17:29:20 <lambdabot>  [5,4,3,2,1,0,-1]
17:29:28 <benzrf> codygman: (..-) parses as an operator
17:29:38 <codygman> > [5 .. -1]
17:29:40 <lambdabot>  []
17:29:40 <hiptobecubic> codygman, it doesn't count down by default
17:29:56 <hiptobecubic> you have to tell it by giving it a second element to compute the step size with
17:29:59 <codygman> hiptobecubic: Oh, okay. I was just wondering hwo it evaluated to empty.
17:30:08 <hiptobecubic> > [10..5]
17:30:09 <lambdabot>  []
17:30:10 <orzo> thanks, rasfar
17:30:14 <hiptobecubic> > [10,9..5]
17:30:16 <lambdabot>  [10,9,8,7,6,5]
17:30:19 <rasfar> > [0,0,-1..]
17:30:20 <lambdabot>  <hint>:1:8: parse error on input ‘..’
17:30:33 <rasfar> > [0,0..(-1)]
17:30:34 <lambdabot>  []
17:30:39 <hiptobecubic> > [0, 1, 1, 2, 3, 5..]
17:30:41 <lambdabot>  <hint>:1:18: parse error on input ‘..’
17:31:00 <roboguy_> > [1,2,3..]
17:31:02 <lambdabot>  <hint>:1:7: parse error on input ‘..’
17:31:03 <hiptobecubic> it should ping OEIS :)
17:31:21 <codygman> lol
17:31:22 <roboguy_> I guess you can only have one or two numbers before the .., that makes sense
17:31:29 <roboguy_> considering how it desugars
17:31:42 <benzrf> hiptobecubic: 1 sec
17:32:47 <dwcook> > [5, 4 .. -1]
17:32:49 <lambdabot>  [5,4,3,2,1,0,-1]
17:32:55 <dwcook> Woops I'm late, was scrolled up
17:33:47 <dwcook> codygman, [5.. -1] desugars to enumFromTo 5 (-1), so check out how that's implemented for... I think it'd default to Integer in this case, so for Integer
17:34:29 <benzrf> hmmm
17:34:30 <codygman> dwcook: Thanks
17:34:47 <rasfar> > [1,1..0]
17:34:48 <lambdabot>  []
17:34:48 <dwcook> http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Enum.html#instance%20Enum%20Integer
17:35:09 <rasfar> (oh right, nm)
17:35:54 <dwcook> > [1, 1 .. 1] -- ;)
17:35:55 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:36:58 <pyro-> good morning! can anyone teach me about ghc unfolding? I am using blaze-html to construct a toplevel declaration of type Html, and I'm trying to experiment with convincing ghc to unfold it to a string at compile time
17:39:50 <rasfar> dwcook: that's a good'n
17:44:21 * hackagebot music-dynamics-literal 1.7.1 - Overloaded dynamics literals.  http://hackage.haskell.org/package/music-dynamics-literal-1.7.1 (HansHoglund)
17:44:23 * hackagebot music-pitch-literal 1.7.1 - Overloaded pitch literals.  http://hackage.haskell.org/package/music-pitch-literal-1.7.1 (HansHoglund)
17:44:25 * hackagebot abcnotation 1.7.1 - Haskell representation and parser for ABC notation.  http://hackage.haskell.org/package/abcnotation-1.7.1 (HansHoglund)
17:44:27 * hackagebot musicxml2 1.7.1 - A representation of the MusicXML format.  http://hackage.haskell.org/package/musicxml2-1.7.1 (HansHoglund)
17:44:29 * hackagebot lilypond 1.7.1 - Bindings to Lilypond  http://hackage.haskell.org/package/lilypond-1.7.1 (HansHoglund)
17:44:35 <pnpuff> Hi all. I'm looking for any good learning material concerning the Haskell programming language. Thanks for any help.
17:44:47 <mzero> @where LYAH
17:44:47 <lambdabot> http://www.learnyouahaskell.com/
17:44:52 <mzero> pnpuff: start with that
17:45:01 <Cale> pnpuff: also feel free to ask lots of questions here
17:45:58 <hiptobecubic> yes
17:49:31 * hackagebot music-score 1.7.1 - Musical score and part representation.  http://hackage.haskell.org/package/music-score-1.7.1 (HansHoglund)
17:49:33 * hackagebot music-pitch 1.7.1 - Abstract representation of musical pitch.  http://hackage.haskell.org/package/music-pitch-1.7.1 (HansHoglund)
17:49:35 * hackagebot music-dynamics 1.7.1 - Abstract representation of musical dynamics.  http://hackage.haskell.org/package/music-dynamics-1.7.1 (HansHoglund)
17:49:37 * hackagebot music-articulation 1.7.1 - Abstract representation of musical articulation.  http://hackage.haskell.org/package/music-articulation-1.7.1 (HansHoglund)
17:49:39 * hackagebot music-parts 1.7.1 - To be written.  http://hackage.haskell.org/package/music-parts-1.7.1 (HansHoglund)
17:53:05 <hansoso> ifZero : M A × M A → M A ifZero = λk.get () >>= λs.if s = 0 then f st k else snd k How would this look like with app from ArrowApply?
17:54:40 * hackagebot music-preludes 1.7.1 - Some useful preludes for the Music Suite.  http://hackage.haskell.org/package/music-preludes-1.7.1 (HansHoglund)
17:54:42 * hackagebot music-graphics 1.7.1 - Diagrams-based visualization of musical data structures.  http://hackage.haskell.org/package/music-graphics-1.7.1 (HansHoglund)
17:54:44 * hackagebot music-sibelius 1.7.1 - To be written.  http://hackage.haskell.org/package/music-sibelius-1.7.1 (HansHoglund)
17:54:46 * hackagebot music-suite 1.7.1 - A set of libraries for composition, analysis and manipulation of music.  http://hackage.haskell.org/package/music-suite-1.7.1 (HansHoglund)
17:55:53 <hansoso> my idea was someting like (\k -> getA >>> arr (\x -> if x == 0 then (fst k,()) else (snd k,())) >>> app) but i cannot get this to work
17:57:28 <Cale> What's the type of getA?
17:58:11 <hansoso> getA :: StateArrow s a s -- the arrow equivilant of get from the state monad
18:00:21 <Cale> It type checks doesn't it?
18:00:36 <hansoso> Cale: yes
18:00:56 <Cale> So, when you say it doesn't work, what do you mean by that?
18:01:37 <Cale> It does have an unusual type
18:01:43 <Cale> But that's because of k
18:01:50 <Cale> k must be a pair
18:01:58 <Cale> (of arrows)
18:02:20 <hansoso>  runStateArrow ((\k -> getA >>> arr (\x -> if x == 0 then (fst k,()) else (snd k,())) >>> app) (getA, getA)) (0,0)
18:02:31 <hansoso>  No instance for (ArrowApply (StateArrow b0))       arising from a use of ‘it’
18:02:42 <Cale> Well, there you go
18:02:54 <Cale> No instance of ArrowApply
18:02:55 <benzrf> hiptobecubic: http://lpaste.net/5968372256299024384
18:03:02 <benzrf> yo'ur welcome
18:03:08 <benzrf> 1. dont look at the code
18:03:14 <benzrf> 2. extend :: [Int] -> [Int]
18:03:29 <hansoso> Cale: oh :D
18:03:36 <benzrf> @letlpaste 5968372256299024384
18:03:36 <lambdabot>  Parse failed: Ambiguous infix expression
18:03:39 <benzrf> u wut
18:04:08 <benzrf> oh man i didnt know intercalate was a thing -.-
18:04:43 <Cale> Yeah, it's intersperse and concat stuck together.
18:05:36 <benzrf> @src intercalate
18:05:36 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
18:05:41 <benzrf> wpfft
18:05:52 <benzrf> why not use concat . intersperse
18:05:59 <benzrf> damn kids get off my lawn
18:06:04 <Cale> It'd be (concat .) . intersperse
18:06:17 <benzrf> o wait yeah
18:06:18 <joelteon> benzrf: because the code in Data.List typechecks
18:06:30 <benzrf> why not concat .: intersperse fft
18:06:51 * Cale still considers intercalate to be newish and somewhat decadent.
18:07:12 <Cale> I wonder when exactly it was introduced
18:07:34 <mzero> and the way to remember which is which (for someone like me who learned of them at the same time) is that inter*c*alate has a *c* in it 'cause it is the one that *c*oncats!
18:08:05 <benzrf> mzero: gross
18:08:32 <Cale> whatever works :)
18:08:33 <mzero> and yet - I use intercalate all the time, and never seem to need intersperse
18:09:11 <joelteon> I remember "intercalate" because I never see the word used in any other context
18:09:46 <Luonnon> Is there any single, comprehensive style guide for Haskell which is most popular?
18:09:48 <joelteon> it's like remembering what a "monoid" is
18:10:34 <benzrf> Luonnon: use 2 space indents NEVER TABS, put spaces around binary operators, use newlines appropriately
18:10:43 <mzero> Luonnon: https://github.com/tibbe/haskell-style-guide
18:11:10 <mzero> or rather, directly: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
18:12:04 <Luonnon> Looks like my Scala .vimrc already gets me part of the way there. :)  Thanks for the link.
18:13:53 <benzrf> i dont know scala
18:14:00 <benzrf> but i do know that haskellers loooooooove to make fun of it!
18:14:07 * benzrf points at Luonnon and laughs
18:14:27 <Luonnon> No way to ensure functional purity in Scala methods.  At all.
18:14:41 <Luonnon> The type system isn't as good either.  But you do have access to JVM.
18:15:19 <rasfar> how do you use @djinn again?
18:15:51 <MP2E> @djinn (a -> b) -> (b -> c) -> a -> c
18:15:51 <lambdabot> f a b c = b (a c)
18:16:21 <rasfar> @djinn [a] -> [a] -> [a]
18:16:22 <lambdabot> Error: Undefined type []
18:16:30 <MP2E> list doesn't work because it's a recursive type
18:16:40 <MP2E> you can use Maybe to simulate a list that only has 1 or 0 elements
18:16:51 <rasfar> okay. is there a tool to guess a function from examples?
18:17:12 <hansoso> Cale: http://lpaste.net/8131112620271861760 can you give me a hint for the implementation of app?
18:17:15 <dfeuer> rasfar, we call that a "business analyst".
18:17:19 <MP2E> I'm not sure what you mean. Djinn will give you a function if possible, given you follow its rules
18:17:23 <rasfar> i'm trying to find a "multiplex" function in the standard lib (pursuant of the above intercalate discussion)
18:17:51 <rasfar> like @infer [1,2,3] [4,5,6] -> [1,4,2,5,3,6]
18:18:13 <rasfar> what's a nice way to write that for the general case?
18:18:40 <dfeuer> Like I said. That's not a tool, it's a job description :-P
18:19:17 <rasfar> heh! no doubt. put most of us out of business
18:19:53 <rasfar> > transpose [[1,2,3],[4,5,6]]
18:19:54 <lambdabot>  [[1,4],[2,5],[3,6]]
18:20:01 <rasfar> @src transpose
18:20:01 <lambdabot> transpose []             = []
18:20:01 <lambdabot> transpose ([]   : xss)   = transpose xss
18:20:01 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
18:20:17 <benzrf> personally i prefer
18:20:30 <MP2E> > let test (x:xs) (y:ys) = x : y : test xs ys
18:20:31 <lambdabot>  not an expression: ‘let test (x:xs) (y:ys) = x : y : test xs ys’
18:20:35 <benzrf> transpose = getZipList . sequence . ZipList
18:20:38 <MP2E> oh yes whoop
18:20:43 <benzrf> @let transpose' = getZipList . sequence . ZipList
18:20:44 <lambdabot>  .L.hs:151:38:
18:20:44 <lambdabot>      Couldn't match type ‘ZipList a1’ with ‘[ZipList a]’
18:20:44 <lambdabot>      Expected type: [a1] -> [ZipList a]
18:20:44 <lambdabot>        Actual type: [a1] -> ZipList a1
18:20:44 <lambdabot>      Relevant bindings include
18:20:48 <dfeuer> One answer is that if you have a big library of functions hoogly indexed by type, you can try applying all the ones that apply and see which ones, if any, give the desired results.
18:20:50 <benzrf> oh
18:20:53 <benzrf> @let transpose' = map getZipList . sequence . ZipList
18:20:54 <lambdabot>  .L.hs:151:31:
18:20:54 <lambdabot>      Couldn't match type ‘[a0]’ with ‘ZipList a’
18:20:54 <lambdabot>      Expected type: [[a0]] -> [ZipList a]
18:20:54 <lambdabot>        Actual type: [[a0]] -> [[a0]]
18:20:54 <lambdabot>      Relevant bindings include
18:20:59 <rasfar> oh of course! i was trying to use zipWith (or a fold)
18:20:59 <magicman> map ZipList
18:20:59 <benzrf> derrppp
18:21:03 <hiptobecubic> right
18:21:04 <benzrf> @let transpose' = getZipList . sequence . map ZipList
18:21:04 <lambdabot>  .L.hs:151:27:
18:21:05 <lambdabot>      No instance for (Monad ZipList) arising from a use of ‘sequence’
18:21:05 <lambdabot>      In the first argument of ‘(.)’, namely ‘sequence’
18:21:05 <lambdabot>      In the second argument of ‘(.)’, namely ‘sequence . map ZipList’
18:21:05 <lambdabot>      In the expression: getZipList . sequence . map ZipList
18:21:07 <hiptobecubic> :D
18:21:09 <benzrf> geez what
18:21:10 <dfeuer> :source getZipList
18:21:16 <dfeuer> @source getZipList
18:21:16 <lambdabot> Unknown command, try @list
18:21:16 <benzrf> oh mother fucker
18:21:18 <magicman> sequenceA?
18:21:19 <hiptobecubic> > ZipList [1,2,3]
18:21:20 <benzrf> @let transpose' = getZipList . T.sequenceA . map ZipList
18:21:20 <lambdabot>  ZipList {getZipList = [1,2,3]}
18:21:22 <lambdabot>  Defined.
18:21:39 <benzrf> @check \l -> transpose l == transpose' l
18:21:41 <lambdabot>  *** Failed! Falsifiable (after 1 test):
18:21:41 <lambdabot>  []
18:21:41 <dfeuer> @src getZipList
18:21:41 <lambdabot> Source not found. I've seen penguins that can type better than that.
18:21:43 <benzrf> butt
18:21:50 <benzrf> > tranpose []
18:21:51 <lambdabot>  Not in scope: ‘tranpose’
18:21:52 <lambdabot>  Perhaps you meant one of these:
18:21:52 <lambdabot>    ‘BSC.transpose’ (imported from Data.ByteString.Char8),
18:21:52 <lambdabot>    ‘BSLC.transpose’ (imported from Data.ByteString.Lazy.Char8),
18:21:52 <lambdabot>    ‘transpose’ (imported from Data.List)
18:22:00 <benzrf> > transpose []
18:22:00 <dfeuer> @list getZipList
18:22:01 <lambdabot> No module "getZipList" loaded
18:22:01 <lambdabot>  []
18:22:04 <benzrf> > transpose' []
18:22:05 <lambdabot>  [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
18:22:08 <benzrf> goodness
18:22:09 <hiptobecubic> perfect
18:22:10 <rasfar> dfeuer: after all the trouble, lol
18:22:15 <hiptobecubic> :t transpose'
18:22:15 <benzrf> > transpose' [[]]
18:22:16 <lambdabot> [[a]] -> [[a]]
18:22:17 <lambdabot>  []
18:22:23 <benzrf> > transpose [[]]
18:22:24 <lambdabot>  []
18:22:28 <benzrf> o_o
18:22:59 <magicman> > transpose' [[1,2,3],[4,5],[6,7,8]]
18:23:01 <lambdabot>  [[1,4,6],[2,5,7]]
18:23:13 <magicman> > transpose [[1,2,3],[4,5],[6,7,8]]
18:23:14 <lambdabot>  [[1,4,6],[2,5,7],[3,8]]
18:30:02 <mwhit> @src transpose'
18:30:02 <lambdabot> Source not found.
18:30:13 <mwhit> @src transpose
18:30:13 <lambdabot> transpose []             = []
18:30:13 <lambdabot> transpose ([]   : xss)   = transpose xss
18:30:13 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
18:30:30 <mwhit> sometimes i forget haskell even has list comprehensions
18:30:32 <mwhit> don't know why
18:35:03 <dolio> Because no one uses them.
18:35:09 <rasfar> we're not supposed to list recursive dependencies in a project .cabal file, right? only the "front" deps?
18:35:28 <rasfar> for example, generics-sop depends on tagged
18:35:30 <dolio> Correct.
18:35:36 <rasfar> ok, thanks
18:35:47 <dolio> You only list things you use in your code.
18:36:44 <rasfar> monad do-notation is related to list comprehension if I recall correctly
18:47:08 <otis> Hey all, when I bevel a bezier curve, how can I have the bevel be flat?
18:48:10 <dfeuer> Otis, how are you trying to draw one? Are you calculating it yourself? Using some library function?
18:48:31 <ReinH> rasfar: There is a mechanical translation of list comprehensions into do notation for the list monad.
18:48:47 <dwcook> rasfar, https://ghc.haskell.org/trac/ghc/wiki/MonadComprehensions
18:49:04 <otis> oh damn sorry, wrong channel. : )
18:49:39 <ReinH> For example: [x * x | x <- [1..10]] ==> do { x <- [1..10]; return (x * x) }
18:50:09 <dwcook> Which is pretty much reflected in how you're able to "re-sugar" the monad comprehension translation
18:50:39 <ReinH> Yep.
18:51:15 <rasfar> how like #haskell to tackle the problem rather than deflect the question
18:51:39 <rasfar> "monad comprehensions", right
18:52:14 <dfeuer> It's interesting to me how much it resembles set-builder notation.
18:55:29 <rasfar> i guess <- in comprehensions is similar to ∈ (element of in case that doesn't show up right) in set-builder?
18:56:18 <roboguy_> yeah
18:56:37 <rola> never noticed that until now
18:56:38 <rasfar> wonder how used parallel list comprehensions are ... they're pretty elegant-looking
18:57:55 <roboguy_> rasfar: I've almost never seen them used personally, outside of telling someone they exist. You can still do all that stuff with regular comprehensions, but it probably wouldn't look as nice
18:59:46 <rasfar> took a graph theory course once, fell in love with set-builder in that.  went off on this huge tangent, brought my ideas to the prof in said notation ... she said "mathematicians don't communicate like this" ... i think i went over the deep end with the notation ...
18:59:58 <joelteon> All comprehensions used to be monad comprehensions right?
19:00:03 <roboguy_> joelteon: yeah
19:00:22 <joelteon> then, like many other things, we ruined it ;(
19:00:32 <roboguy_> I don't think there's a monad comprehension equivalent of parallel comprehensions though
19:00:57 <roboguy_> well, maybe you could use zipWithM or something like that
19:02:15 <ReinH> dfeuer: the resemblance is not coincidental
19:02:52 <ReinH> joelteon: this is why we can't have nice things?
19:03:31 <joelteon> is that the origin of that phrase?
19:03:43 <joelteon> makes sense
19:06:22 <rasfar> i'd expect to find PLCs (parallel list comprehensions) in HPC given the affiliation ... for some reason I think of PLC's as an SPJ contrib but not sure
19:06:56 <rasfar> there's https://www.google.ca/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0CB4QFjAA&url=https%3A%2F%2Fwww.haskell.org%2Fghc%2Fdocs%2F5.00%2Fset%2Fparallel-list-comprehensions.html&ei=kyPLU67uKJWzyATa3oLYCA&usg=AFQjCNEdvwy0cxH0XOJAv7EyPPVzybs6xw&sig2=smMBZOGJUPIxYl3vURBlxg
19:07:48 <rasfar> sorry, that is https://www.google.ca/url?sa=t&rct=j&q=&esrc=s&source=web&cd=6&ved=0CDwQFjAF&url=http%3A%2F%2Fwww.cse.unsw.edu.au%2F~keller%2FPapers%2Ffsttcs2008.pdf&ei=kyPLU67uKJWzyATa3oLYCA&usg=AFQjCNEjmY59NlByIiz_oAVGxyB3anAA4w&sig2=mom34oHe_eBEd6MSzsNlFA
19:08:22 <stolaruk> I'm writing a concurrent (threaded) program. I've noticed what appears to be a big difference in the way threads are scheduled between 1) my code compiled with "ghc -O -threaded --make", and 2) the same code compiled with "cabal build". How can I get "cabal build" to use the same ghc command line options?
19:08:31 <rasfar> oh fudge: Nested Data Parallelism paper (SPJ) -- uses similar syntax for ARRAY comprehensions
19:09:24 * hackagebot librato 0.2.0.1 - Bindings to the Librato API  http://hackage.haskell.org/package/librato-0.2.0.1 (IanDuncan)
19:10:53 <rasfar> storaluk, all I can think of is running cabal with -v and see if any options it's using look suspect
19:11:31 <rasfar> you are specifying ghc-options: in your .cabal file?
19:11:53 <stolaruk> rasfar: Yes tho I don't know if I'm doing it the right way: "ghc-options:         -O -threaded"
19:12:10 <stolaruk> ^^ this appears under "executable" and again under "library"
19:12:28 <rasfar> that's what I'd do ... have you got it (haha, was about to ask if it was in the test-suite, same difference)
19:13:32 <rasfar> is there anything odd in your ~/.cabal/config or ./cabal.config ?
19:14:22 <rasfar> also if you have multiple versions of GHC installed, it is possible that ghc from the shell is running a different version than cabal does [? longshot]
19:14:24 * hackagebot mongoDB 2.0.1 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-2.0.1 (GregWeber)
19:15:13 <rasfar> or indeed, linking different versions of libs...
19:15:57 <stolaruk> I haven't done anything by hand with those config files
19:16:17 <stolaruk> My project is in a sandbox
19:16:31 <stolaruk> hm not sure
19:17:01 <rasfar> okay. but if you're not running "cabal exec -- ghc --make" (or whatever), then the environments are not guaranteed to be the same
19:17:26 <rasfar> I'd try ghc -v --make and compare to cabal build -v
19:18:13 <stolaruk> ok
19:18:26 <rasfar> i have problems like that pretty frequently, so just dumping all the advice I can think of
19:18:33 <stolaruk> thx
19:20:48 <zq> omfg does anyone know what mkSave in persistent-template does?
19:25:37 <DheedoRaanjha> hey guys, what's the difference between max and maximum?
19:25:44 <hiptobecubic> :t max
19:25:45 <lambdabot> Ord a => a -> a -> a
19:25:51 <hiptobecubic> :t maximum
19:25:52 <lambdabot> Ord a => [a] -> a
19:25:59 <hiptobecubic> > max 3 5
19:26:00 <lambdabot>  5
19:26:03 <hiptobecubic> > maximum [3, 5]
19:26:05 <lambdabot>  5
19:26:16 <DheedoRaanjha> http://www.haskell.org/haskellwiki/Euler_problems/11_to_20
19:26:26 <DheedoRaanjha> in problem 18, max is used
19:26:44 <DheedoRaanjha> but it's used on nested lists?
19:27:39 <DheedoRaanjha> i.e. max tri (tail tri) is valid
19:27:50 <DheedoRaanjha> should that not be invalid?
19:28:08 <hiptobecubic> > [1,2,3] > [5,6,7]
19:28:08 <glguy> Look at the second line
19:28:09 <lambdabot>  can't find file: L.hs
19:28:25 <glguy> It's used in the context of zipWith3
19:28:57 <glguy> which is used with foldr1
19:30:41 <DheedoRaanjha> max [10,2,3] [5,6,7] gives [10,2,3]
19:30:50 <DheedoRaanjha> so does it just compare the first element?
19:30:55 <hiptobecubic> > max [1,2] [3,5]
19:30:56 <lambdabot>  [3,5]
19:31:05 <hiptobecubic> > max [3,2] [3,5]
19:31:07 <lambdabot>  [3,5]
19:31:24 <hiptobecubic> lexicographic it seems
19:31:26 <hiptobecubic> @src max
19:31:26 <lambdabot> max x y = if x <= y then y else x
19:31:35 <lfairy> hiptobecubic: yep
19:31:39 <lfairy> just like python
19:31:54 <trap_exit> this is my attempt at using GHC.Generics: https://gist.github.com/anonymous/c813e2275664488e85f4 ... how do I make this work? I want to define a way to "recurse" on Exprs. Thanks!
19:32:03 <DheedoRaanjha> yep got it. Thanks
19:32:06 <glguy> DheedoRaanjha: Consider these type signatures http://lpaste.net/107770
19:32:34 <glguy> DheedoRaanjha: I don't think you're understanding how "max" is being used here
19:32:36 <trap_exit> glguy: I just got your message
19:32:42 <trap_exit> glguy: thanks for taking the time to write the gist!
19:32:59 <glguy> trap_exit: The Data.Data version is just:   expr_rec0 f = gmapT (mkT f)
19:33:03 <glguy> fwiw :)
19:33:03 <roboguy_> DheedoRaanjha: actually, max isn't being used on a list
19:33:20 <roboguy_> DheedoRaanjha: note the type of f
19:33:29 <roboguy_> (which they probably should have written out)
19:33:30 <trap_exit> glguy: why am I using GHC.Generics ?
19:33:37 <glguy> You asked to
19:34:06 <rasfar> if you need to use a class method in your SYB recursion you'll be out of luck
19:34:27 * hackagebot mongoDB 2.0.2 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-2.0.2 (GregWeber)
19:34:28 <trap_exit> I thought SYB is deprecated
19:34:32 <trap_exit> what is the state of GHC.Generics vs Data.Data ?
19:35:01 <DheedoRaanjha> @roboguy_ I am confused. Doesn't max just work lexicographically?
19:35:01 <lambdabot> Unknown command, try @list
19:35:11 <rasfar> i've just started looking at SOP, which has a foundation similar to GHC.Generics, but respects shape
19:35:18 <roboguy_> DheedoRaanjha: on lists it does. Your example (problem18) doesn't apply max to a list though
19:35:20 * trap_exit goes off to read http://stackoverflow.com/questions/17502603/ghc-generics-or-data-data
19:35:40 <roboguy_> so that isn't really relevant
19:35:42 <lfairy> DheedoRaanjha: it does, but the solution doesn't compare lists. It compares each element individually
19:36:05 <DheedoRaanjha> ah! i will try the algorithm on paper
19:36:11 <roboguy_> DheedoRaanjha: the type of f is "f :: (Num a, Ord a) => a -> a -> a -> a"
19:36:14 <DheedoRaanjha> explicitly*
19:36:16 <roboguy_> (no lists)
19:36:16 <rasfar> i've only had a chance to look briefly at it so far (copumpkin recommended yesterday to me), but trap_exit i'd definitely check out generics-sop
19:36:47 <trap_exit> well I;m goign to master GHC.Generics first
19:36:52 <trap_exit> msut not let the efforst of glguy go to waste
19:37:02 <roboguy_> DheedoRaanjha: or, if you want to make it more specific, "f :: Int -> Int -> Int -> Int"
19:37:21 <rasfar> you need a GHC.Generics instance to use SOP anyhow, although there's a TH module to help you auto-derive
19:38:25 <rasfar> (maybe it's more than you need in this case, dunno, good luck! i'm in similar territory at the moment)
19:39:47 <glguy> trap_exit: To do that with "lens" you'd need "instance Plated Expr" (it auto-derives using Data) and then expr_rec0 = over plate
19:40:02 <trap_exit> glguy: wait
19:40:06 <trap_exit> let me learn GHC.Generics first
19:40:15 <trap_exit> we can talk about more tomorrow :-)
19:40:28 <glguy> trap_exit: Sure, I'm just giving you a list of fun things to investigate ;-)
19:41:13 <glguy> trap_exit: If you're learning GHC.Generics I've got some examples for you to look at http://lpaste.net/107355
19:41:24 <trap_exit> glguy: I see to/from in http://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/GHC-Generics.html ... however, I don't understand why they are needed (besides to make the types correct)
19:41:28 <glguy> you can see some of the different ways to use it
19:41:41 <glguy> ?type GHC.Generics.to
19:41:42 <lambdabot> GHC.Generics.Generic a => GHC.Generics.Rep a x -> a
19:41:45 <glguy> ?type GHC.Generics.from
19:41:46 <lambdabot> GHC.Generics.Generic a => a -> GHC.Generics.Rep a x
19:42:00 <glguy> It turns something into its generic representation and then goes back
19:44:36 <glguy> trap_exit: It goes into this type: http://lpaste.net/107771
19:44:39 <glguy> (for the Expr you defined)
19:45:03 <glguy> and you use the GMapExpr typeclasses to consume that
19:45:12 <trap_exit> glguy: ah, it takes complicated types, and converts it to binary sums / binary products
19:45:30 <glguy> yeah, then you operate on those and put it back when you're done :)
19:47:58 <DheedoRaanjha> @roboguy_ Thanks , I misunderstood how zipWith3 was being used with that problem.
19:47:59 <lambdabot> Unknown command, try @list
19:48:29 <trap_exit> glguy: why is line 26 of http://lpaste.net/107765#line26 using "MapExpr" rather than "GMapExpr" ? Why is the K1 instructor from http://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/GHC-Generics.html special ?
19:53:38 <glguy> trap_exit: After a K1 constructor you're back in normal types
19:53:52 <glguy> for example: .... M1 C Main.C1_13Expr (M1 S NoSelector (K1 R [Expr]))))))
19:53:53 <phaskell> M1: Datadog metrics on Monitor.h.o - https://phabricator.haskell.org/M1
19:54:17 <carter> lol
20:02:27 <Total_1mmersion> How do you run a Haskell file from a different directory? "runhaskell a/b.hs" errors out because it can't find a module which is also in the "a" directory.
20:02:51 <Total_1mmersion> Specifying -idirs=a doesn't seem to help.
20:02:53 <rasfar> -i./a i think
20:03:25 <trap_exit> glguy: okay, I think I understand what each line of your code does now
20:03:36 <trap_exit> glguy: thanks again for your time / efforst, I found this very instructive
20:03:39 <Total_1mmersion> rasfar, ah thanks, simply -i
20:03:57 <glguy> glad it helped!
20:04:15 <rasfar> if that works ... i'm not sure (may depend on your module names are qualified too)
20:06:41 <Nancy21>  Hi! I give you some videos. I hope you like! http://bit.ly/1rdSPCg
20:08:00 <hiptobecubic> THANKS NANCY!
20:09:03 <lfairy> who do we report this crap to?
20:09:23 <trap_exit> #trap_exit_for_ops
20:09:27 <trap_exit> I promise to kick such people without mercy
20:09:30 <roboguy_> @where ops
20:09:30 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
20:09:45 <trap_exit> I'll even kick people before they post anoying links, if I suspect them that they may be annoying in future.
20:10:06 <rasfar> verrry funny
20:10:18 <l0cust> trap_exit: aww
20:11:04 <rasfar> that @where ops list always gives me nostalgia
20:11:30 --- mode: ChanServ set +o glguy
20:11:40 <l0cust> Would one of you fine gentlemen mind looking at my Haskell program before I push it? https://github.com/pharpend/eros-http
20:11:43 --- mode: glguy set +b-o *!*@93.115.95.* glguy
20:12:14 <trap_exit> hmm, are none of the authors of RWH, LYSH ops here?
20:12:23 <trap_exit> well maybe that's why they're so productive :-)
20:12:28 <l0cust> trap_exit: haha
20:13:34 <trap_exit> glguy: when writing GHC.Generics code, do you actually write those long, > 80 char lines, to ensure things line up?
20:14:02 <lfairy> trap_exit: what do you mean? bos and dons are ops
20:14:03 <solidus-river> i have a list of type [Just a] and i want to do a filter over it that is a -> Bool
20:14:25 <trap_exit> lfairy: ah, I didnt recognize the nicks
20:14:28 <l0cust> solidus-river: use a list comprehension
20:15:03 <glguy> I do. I haven't really seen anyone else do it, so I won't say it it's normal, but I Think it's a really good idea :)
20:15:04 <l0cust> solidus-river: [some_function x | x <- xs]
20:15:17 <l0cust> in fact
20:15:25 <l0cust> I think Maybe is a monad
20:15:30 <l0cust> so you could use mapM
20:15:34 <l0cust> @info Maybe
20:15:34 <lambdabot> Maybe
20:15:42 <l0cust> well that's helpful
20:15:43 <rola> @src Maybe
20:15:43 <lambdabot> data Maybe a = Nothing | Just a
20:16:04 <l0cust> solidus-river: Maybe is a monad, so use mapM
20:16:10 <l0cust> @type mapM
20:16:10 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
20:16:19 <l0cust> :i Maybe
20:16:22 <roboguy_> you might want filterM
20:17:22 <lfairy> trap_exit: as for the alignment thing, it sounds cute in theory but it's a royal pita to maintain
20:17:54 <roboguy_> :t filterM
20:17:55 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
20:18:07 <roboguy_> actually, that's the opposite of what you need isn't it
20:18:09 <l0cust> yeah
20:18:15 <rola> http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-Maybe.html#Maybe
20:18:28 <rasfar> l0cust: the results on GPL come out pretty funny. no question whether to censor that...
20:18:47 <trap_exit> lfairy: but how often is the code written, and how often is the code read ?
20:18:51 <roboguy_> catMaybes is always an option
20:19:01 <l0cust> rasfar: 20 is actually pretty low
20:19:05 <Total_1mmersion> Is there any better way to debug the head of empty list error than to grep for head and judge which one is the culprit?
20:19:06 <rasfar> i'm surprised it scored zero on "conspiracy" but that's hush hush
20:19:28 * hackagebot eros-http 0.5.0.0 - JSON HTTP interface to Eros.  http://hackage.haskell.org/package/eros-http-0.5.0.0 (pharpend)
20:19:39 <glguy> lfairy: It's easy to keep things lined up. That code doesn't change, and vim makes it easy to indent blocks at a time, and the vim-lion plugin in particular makes it easy to line stuff up after you type it
20:19:41 <rasfar> oh, alright then ;) ... and there it is
20:19:44 <Cale> Total_1mmersion: occasionally it'll work to build with profiling turned on and to run the program with +RTS -xc
20:19:45 <roboguy_> Total_1mmersion: -xc would help
20:19:45 <lfairy> trap_exit: the argument against it is diffs. changing one line often changes requires changing every other one
20:19:54 <Cale> Total_1mmersion: but really, you shouldn't be using head very much
20:20:01 <trap_exit> lfairy: ah, I buy the diff argument
20:20:03 <trap_exit> lfairy: thanks!
20:20:05 <l0cust> rasfar: lol. If I send the text "Fuck you you fucking fuck!", this is the result - http://lpaste.net/107772
20:20:13 <Total_1mmersion> I'll give -xc a try
20:20:16 <glguy> lfairy: For frequently changing code you just indent it further to a tab-stop or so to you have room
20:20:24 <rasfar> Total-1mmersion: check out the -xt optio
20:20:42 <glguy> lfairy: like this http://lpaste.net/107757
20:20:59 <Cale> Total_1mmersion: If you use (\(x:xs) -> x) instead, you'll get a line number as part of the error message
20:21:04 <rasfar> oh it came up already (thought it was -xt, just keep copying the same files)
20:21:28 <lfairy> glguy: that's horrifying and awesome. I still prefer a style that doesn't require tools to maintain, though
20:21:33 <Cale> But really, you should be using case most of the time
20:21:41 <l0cust> Anyway, I'm done working for the rest of the month
20:21:42 <Cale> Or something which uniformly handles empty lists
20:21:45 <glguy> lfairy: that style requires a tab key
20:21:46 <l0cust> bye
20:21:57 <lfairy> glguy: I don't use tabs D:
20:22:02 <glguy> just the key
20:22:09 <glguy> it inserts spaces
20:22:39 <Total_1mmersion> Oh no, I haven't installed the profiling libraries for 'base'
20:23:06 <carter> Total_1mmersion: cabal --enable-executable-profiling
20:23:15 <carter> not --ghc-options="-profile"
20:23:15 <Cale> That's a lot more whitespace than I'd usually be willing to go for. Usually it's enough just to line things up in each definition on its own
20:23:27 <carter> Total_1mmersion: unless i'm guessing wrong
20:23:28 <Total_1mmersion> unrecognized command?
20:23:39 <carter> well, add it to the cabal configure
20:23:41 <carter> or cabal install
20:23:46 <carter> of the build
20:23:54 <Cale> carter: If he doesn't have profiling libraries for base somehow, that'll fail
20:23:58 <lfairy> glguy: I probably wasn't clear. The alignment takes non-zero effort to create and maintain, and I can't be bothered putting in that effort.
20:24:07 <carter> Cale: i'm guesing dyn_prof on accident
20:24:10 <Cale> Those should have come when you installed ghc
20:24:15 <carter> Total_1mmersion: what GHC are you using?
20:24:18 <carter> nop, no dynprof
20:24:23 <carter> only static prof
20:24:24 <Total_1mmersion> 7.6.3
20:24:29 <carter> what OS?
20:24:34 <Total_1mmersion> mint
20:24:34 <glguy> lfairy: Sure, do whatever you want.
20:24:42 <carter> oh, not a mac
20:24:47 * carter looks around for the linux experts
20:25:01 <Cale> Total_1mmersion: Did you install from mint's repo?
20:25:20 <Cale> Total_1mmersion: look for a ghc-prof package if so
20:25:36 <Cale> If you installed the generic linux binary (like I do), then I'm not sure why you'd be seeing that
20:25:38 <Total_1mmersion> Cale, yes
20:25:59 <Total_1mmersion> installing now
20:26:06 <lfairy> What Cale said. Install libghc-*-prof for every other package too
20:26:31 <Cale> Debian does this annoying thing where they split up the GHC distribution into tiny pieces, and all its children inherit this.
20:26:37 <lfairy> I personally think it's quite silly, given that everyone ends up installing them anyway
20:26:59 <Cale> I just stopped using my system's packages for ghc altogether a long time ago
20:27:48 <Cale> I can understand chopping up Haskell platform, but cutting up the stuff that comes when you build GHC is a bit extreme
20:29:07 <lfairy> It does seem strange, doesn't it? By that reasoning the Java standard library should be split into 10+ packages as well
20:30:20 <rasfar> well, the GHC prof libs probably weigh in pretty heavy, but yeah the -prof thing seems quite entrenched in those package managers
20:32:34 <mzero> does anyone know of a package affected by the haddock/clang compiler issue?
20:36:38 <carter> try vector or primitive?
20:36:44 <mzero> both work fine
20:36:55 <carter> huh,
20:37:09 <carter> something that uses hsc2hs?
20:37:31 <carter> mabye one of the opengl bindings?
20:37:47 <carter> i seem to recall they did a huge refactor to make the CPP play nice with both clang and gcc
20:38:06 <mzero> also, my clang doesn't seem to insert those line markers with extra spaces
20:38:37 <carter> i don't think the line markers are from clang...
20:38:41 <mzero> all the haskell platform packages, including the four OpenGL/GLUT ones gen haddock
20:38:48 <carter> i think they come fok
20:38:50 <carter> *ok
20:38:51 <carter> hrm
20:39:00 <carter> email bos and ask him what was busted ƒro him?
20:39:04 <mzero> they come from clang, and the whole point of the -P is to remove them
20:39:16 <carter> i know nothing
20:39:16 <mzero> I did and he answered glibly "any of them"
20:39:21 <mzero> which didn't help
20:39:49 <mzero> hrm. I can't get primitive to haddock
20:40:06 <mzero> but the error is module 'primitive-0.5.3.0:Main' is defined in multiple files
20:40:12 <carter> weird
20:40:24 <carter> and glad i'm right :)
20:40:34 <carter> sounds like the bug
20:41:46 <mzero> only that doesn't match the description of the issue in https://github.com/haskell/cabal/issues/1740
20:42:19 <rasfar> http://trac.haskell.org/haddock/ticket/284 has some nice summaries of affected libs/versions
20:43:00 <carter> mzero: that ticket is OLD, dates ot the original CPP issue, not the haddock stuff
20:43:04 <mzero> okay - but the ---ghc-options=-optP-P fixes it
20:43:09 <mzero> now to see how I can get cabal to do that
20:43:12 <mzero> in the cabal config
20:43:36 <carter> cabal configure?
20:43:43 <carter> ohh
20:43:47 <mzero> fie - this'll never work for sandboxes
20:43:50 <mzero> FIE!
20:44:01 <carter> :)
20:44:16 <mzero> cabal really needs a configuration overhaul
20:44:22 * carter is glad i've done my share of helping already
20:44:25 <mzero> it needs to be a heirarchy of configs
20:44:27 <mzero> thanks
20:44:33 <carter> the IR is kinda like that
20:44:38 <carter> but it doesn't expose it yeah
20:48:00 <johnw> who is coming to LambdaJam?
20:48:09 <carter> not me
20:48:14 <bitemyapp> johnw: I am
20:48:15 <johnw> aww
20:48:19 <johnw> bitemyapp: yay!
20:48:24 <hiptobecubic> wasn't there just one? how often are they?
20:48:27 <platz> I have to go, it's in my area
20:48:30 <johnw> there are two
20:48:34 <johnw> one in Australia, one in Chicago
20:48:39 <hiptobecubic> ah
20:48:39 <platz> ah, Chi
20:48:40 <mzero> carter - do you know if cabal does the ghc preprocessing for haddock - or does haddock do it?
20:48:40 <bitemyapp> johnw: I know Edward and Runar will be there.
20:48:44 <bitemyapp> johnw: Tony as well.
20:48:46 <johnw> and Gershom will be too
20:48:55 <carter> mzero: ask Fuuzetsu  :)?
20:52:47 <mzero> what's really odd is... haddock for primitive built find when I built the platform!
20:52:52 <mzero> don't know why!
20:53:51 <carter> mzero: ohh... check you~/.cabal/config
20:53:53 <carter> did you set that flag?
20:54:25 <solidus-river> this looks fugly, is there a cleaner way of writing it? http://lpaste.net/107774
20:54:48 <solidus-river> i feel like there is but thats the clearest i can get it withotu writing other functions that are one use
20:55:11 <Total_1mmersion> even after apt-get install libghc-safe-prof, GHC says that I haven't installed the profiling library for safe... why is this so difficult? I have put up with a lot of cabal hell, and I hear sandboxes are the way to go but I don't understand what they are.
20:55:40 <mzero> it doesn't work if you set it in haddock-options:
20:55:40 <carter> Total_1mmersion: let cale or someone guide you
20:55:45 <mzero> only if you set it on ghc-options
20:56:04 <solidus-river> Total_1mmersion: cabal sandbox's are wonderful
20:56:11 <mzero> which is sad, because if we set it on ghc-options, then, line numbers will be wrong in tempalted haskell
20:56:13 <mzero> sigh
20:56:30 <solidus-river> Total_1mmersion: imo just get a version of cabal with them and do that
20:57:15 <rasfar> that won't actually solve the problem
20:57:18 <ReinH> mzero: o/
20:57:23 <rasfar> with base libs
20:57:42 <carter> mzero: solution: bundle gcc with GHC for the cpp?
20:57:44 <carter> or cpphs?
20:57:45 <mzero> ReinH: \o
20:57:51 * carter mumbles yak shaviings
20:58:00 <carter> ReinH: o/
20:58:07 <mzero> no - this is gating HP RC
20:59:08 <rasfar> well, maybe it will. Total-1mmersion, I second getting a Cabal version recent enough to have sandboxes and trying that. it will save you from much future cabal-hell.
20:59:57 <levi> Total_1mmersion: Are you familiar with using ghc-pkg? It's a lower-level tool that lets you directly examine the available package versions.
21:00:39 <ReinH> carter: \/
21:00:44 <ReinH> carter: also \o
21:00:58 <ReinH> Speaking of which: can we all agree to never use \/ to mean forall please?
21:01:03 <carter> why
21:01:14 <carter>  /\ is type lambda in core
21:01:21 <carter> \forall is forall
21:01:23 <ReinH> f :: \/a . a -> a \ x -> x is fucking hard to read
21:01:28 <dfeuer> Remind me: does GHC let you make a data declaration local to a function declaration? Like f x = blah where {data Foo = ...}
21:01:33 <Total_1mmersion> levi, I have only used ghc-pkg to list installed packages
21:01:45 <ReinH> or /\, whatever
21:01:49 <carter> dfeuer: nope
21:01:55 <carter> ReinH: :P
21:02:02 <levi> Total_1mmersion: Also, this page describes in detail how cabal and ghc interact at the package level: http://www.vex.net/~trebla/haskell/sicp.xhtml
21:02:14 * ReinH writes a script to replace /\ with ∀ in core dumps
21:02:27 <carter> no
21:02:31 <carter> its not fall
21:02:39 <carter> its term level type lambda
21:02:54 <carter> forall
21:05:09 <ReinH> carter: forall is a term level type lambda...
21:05:19 <carter> i'm tired
21:05:22 <ReinH> it introduces a new scope and binding :p
21:05:34 <carter> ReinH: dude,my patience today is thin :)
21:05:39 <ReinH> carter: ok
21:05:51 <carter> :p
21:05:55 <carter> point taken
21:07:09 <ReinH> carter: Ok, it's a type level type lambda. You win. :p
21:07:24 <xrl_> I'm building cabal 1.20 on ARM debian/wheezy and it fails at linkage because of `getNumberOfProcesses` multidef
21:07:27 <xrl_> https://gist.github.com/xrl/88e4008bc121f764be80
21:07:27 <carter>  /\  is ther term level type lembda
21:07:37 <ReinH> carter: ok
21:07:38 <xrl_> any idea how to get around that build issue for cabal?
21:07:45 <carter> i think
21:07:48 <carter> wellllll
21:07:51 <carter> idk
21:07:53 <carter> erasure
21:09:39 <stolaruk> How can I keep a thread from dying when the main thread ends?
21:09:42 <roboguy_> hey, speaking of foralls, would I be wrong in thinking that a pi type is a lot like a forall (with an extra constraint, if that makes sense)?
21:09:58 <Cale> stolaruk: don't let the main thread end
21:10:14 <Cale> roboguy_: no, in fact forall is often used as the syntax for pi types
21:10:31 <Cale> (Coq uses it, for instance)
21:10:51 <roboguy_> Cale: ahh, nice. I'm starting to read HoTT and I was hoping that I could mentally simplify some things and get some intuition by thinking of it that way
21:11:07 <carter> stolaruk: you coul dhave a bunch of mvars
21:11:09 <carter> and do blocking reads
21:12:10 <pharaun> I suggest control.async
21:12:31 <ReinH> roboguy_: when in doubt ask Cale
21:12:37 <ReinH> unfortunately Cale does not scale.
21:12:41 <ReinH> Double unfortunately, that rhymes.
21:12:45 <MP2E> hah :P
21:12:47 <pharaun> Cale isn't webscale :(
21:12:48 <roboguy_> haha
21:13:53 <stolaruk> pharaun: Yeah Async is probably what I need
21:14:00 <stolaruk> Or at least a good solution
21:15:06 <dfeuer> Remind me: will an UNPACK pragma work in a context like data Foo a = Foo {-# UNPACK #-} !Int [a] or is even that too polymorphic?
21:15:27 <pharaun> stolaruk: i like async, it takes care of bunch of "gotchas" in various cases and wrap up into a neat solution
21:15:34 <pharaun> it was also discussed in the concurrency/parallel book
21:15:35 <johnw> is there a name for rewriting (λy → f (g (h y))) as f ((λy → g (h y)))?
21:15:40 <roboguy_> Cale: is there an equivalent of sigma types that would be familiar to me from haskell?
21:16:02 <Cale> roboguy_: Not really, they're dependent pair types
21:16:16 <johnw> Cale: aren't they dependent sums?
21:16:21 <Cale> yes
21:16:22 <roboguy_> Cale: hmm, ok. thanks!
21:16:58 <Cale> roboguy_: i.e. where the type of the second component depends in some way on the value of the first
21:16:59 <roboguy_> they make some sense, but I was hoping I could get some more intuition
21:17:06 <stolaruk> pharaun: I'm reading that book now :)
21:17:26 <roboguy_> they introduced both pi and sigma types pretty close together and that threw me a bit
21:17:27 <Cale> As an example, you could have pairs of a natural number together with a vector having that many components
21:17:38 <zwer> @pl (\(x,y) -> (x,[y]))
21:17:38 <lambdabot> second return
21:17:51 <mwhit> Cale: that can be faked in haskell though
21:17:52 <zwer> huh
21:17:54 <roboguy_> hmm, that makes sense
21:18:16 <roboguy_> mwhit: I have a feeling general sigma types couldn't be
21:18:17 <pharaun> stolaruk: its a good book
21:18:27 <Cale> mwhit: yeah, but it's tricky and unlikely to be familiar unless you already know what sigma types are
21:18:27 <pharaun> i've been doing haskell for a while but i still learned some stuff out of that book, i like it
21:18:30 <mwhit> oh probably not in general, no
21:18:52 <stolaruk> pharaun: every pg is full of ifno
21:19:05 <mwhit> i tried making a neural network with static types, which involves a list of vectors/matrices where the dimensions have to match
21:19:11 <mwhit> so it involved a type-level list of type-level nats
21:19:14 <mwhit> it got... messy
21:19:23 <mwhit> static dimensions*
21:19:45 <roboguy_> mwhit: actually, I think there are libraries that can help with that
21:20:17 <MP2E> haha oh god, I typed in "Haskell HoTT" to see what you guys were talking about and it brought me to a funeral home :V
21:20:29 <roboguy_> MP2E: wow, huh
21:20:35 <roboguy_> try Homotopy type theory
21:20:37 <Cale> MP2E: http://homotopytypetheory.org/
21:20:38 <MP2E> thanks :P
21:20:51 <Cale> It actually has not a whole lot to do with Haskell specifically
21:20:56 <roboguy_> I'm a long ways off, but I'm really looking forward to reading about the connection to homotopy
21:21:23 <Cale> MP2E: but being a particular flavour of dependent type theory, is sort of off in the direction where the Haskell type system is gradually headed
21:21:44 <Cale> roboguy_: Do you know some homotopy theory?
21:21:53 <roboguy_> Cale: nope! that's part of the reason I'm interested, haha
21:21:57 <Cale> ah, okay
21:22:25 <mwhit> roboguy_: yeah? which? I gave up after the typelits solver was too terrible to make some pretty basic inferences
21:22:27 <roboguy_> I'm slightly familiar with type theory though (not totally comfortable with dependent types yet), so I'm hoping that will help me understand some about homotopy
21:23:10 <Cale> I'm not sure how people who don't start out knowing a bit of homotopy theory usually fare with that stuff, but it certainly is an interesting approach :)
21:23:31 <Cale> (It should be teachable that way in theory, I don't know how accessible the book is in that regard though)
21:24:28 <roboguy_> Cale: the only thing I know about it is very general stuff about how a homotopy is a continuous map from one space to another parameterized over the closed unit interval, where it equals one space at 0 and the other at 1 (or something like that)
21:24:52 <rasfar> dfeuer, my 2 cents as no other takers: reading http://www.haskell.org/haskellwiki/Performance/Data_types , seems like unless you're pattern-matching, the UNBOX pragma is a good idea there.
21:25:41 <Cale> roboguy_: Or one function at 0 and the other one at 1
21:25:42 <roboguy_> mwhit: hmm, maybe it's hmatrix-static
21:26:08 <roboguy_> Cale: hmm, you mean on the type theory side?
21:26:38 <mwhit> roboguy_: oh, yeah, that's what I was working with. Helped me get a good ways, but it fell apart trying to link layers together
21:26:41 <mwhit> ah well
21:26:49 <roboguy_> hh
21:26:51 <roboguy_> *ahh
21:26:58 <Cale> roboguy_: A homotopy of continuous functions f,g: X -> Y is a continuous map H: X x [0,1] -> Y such that for all x, you have H(x,0) = f(x), and H(x,1) = g(x)
21:27:17 <roboguy_> mwhit: I want to say hblas does that stuff too, but I'm not sure. and it also says it's not for end users. have to ask carter to be sure though
21:27:29 <carter> ?
21:27:30 <roboguy_> Cale: oh, right
21:27:33 <carter> whats teh quesins?
21:27:54 <carter> i don't recommend using static dimensions
21:28:03 <carter> makes stuff messier than it helps
21:28:23 <Cale> roboguy_: Two functions are called homotopic, written f ~ g if such an H exists. Two spaces X and Y are called homotopy equivalent if there are maps f: X -> Y and g: Y -> X such that f . g ~ id_Y and g . f ~ id_X
21:28:49 <roboguy_> Cale: I mostly know about that from a catsters video and it's been a while. for homotopy, I'm at that point in learning something where the definition makes sense but I don't really have any intuition or much of an idea of the implications of it
21:29:02 <roboguy_> hmm
21:31:02 <rasfar> dfeuer: if you're worried whether the [a] will prevent the unboxing of the !Int, I think you're okay as I've plugged space leaks this way in a constructor with all manner of other field types
21:31:21 <Cale> roboguy_: However, HoTT sidesteps the need for the real unit interval by dealing with paths in an abstract fashion
21:31:29 <roboguy_> I've actually taken several (sorta) high-level math classes, but they've all been calculus related so that doesn't help me too much with any of this (as far as I can see)
21:31:58 <rasfar> calculus -> real analysis -> topology
21:32:13 <roboguy_> true, but I haven't gotten to any real analysis so far
21:32:26 <roboguy_> I guess the continuity stuff from calculus helps
21:32:26 <dfeuer> Topology is lots of fun.
21:32:26 <rasfar> complex?
21:32:37 <roboguy_> isn't complex analysis usually after real?
21:32:45 <rasfar> i so love general topology ... more than programming even
21:32:52 <hiptobecubic> roboguy_, yeah
21:32:53 <Cale> You can start either first
21:32:53 <rasfar> more than music almost!
21:33:08 <dfeuer> I love it a lot, but it's hard to compare to music.
21:33:10 <Cale> Well...
21:33:19 <rasfar> roboguy_: it was for me; but i didn't feel the overlap much
21:33:20 <Cale> depending on what counts as "real analysis"
21:33:21 <Cale> :D
21:33:34 <Cale> My "Calculus" courses were mostly proper real analysis
21:33:46 <roboguy_> there's a topology book I keep coming back to every once in a while, but I don't usually get too far
21:33:56 <rasfar> well, not a direct comparison, just an expression of magnitude :)
21:33:56 <Cale> Half of Calc 1 for me was spent on properties of sequences of reals
21:35:18 <Cale> (I actually really appreciate that approach now -- it's much easier to grasp the idea of a limit of a sequence before the limit of a function at a point.)
21:35:41 <roboguy_> in topology, I know that bit about homotopy, that coffee <-> donut isotopy thing (and how it extends to more holes), and the definition of a topology on a set (although it doesn't fully make sense why it is the way it is) and that's about it
21:35:50 <roboguy_> *coffee cup
21:35:51 <dfeuer> roboguy_: try Kelley's General Topology. It's old and weird (he uses bizarre definitions for various ordering concepts), but I really like his style and exercises.
21:36:16 <rasfar> that's a classic for sure (often cited)
21:36:33 <roboguy_> dfeuer: I'll look into it, thanks!
21:36:35 <rasfar> we used Engleking, which is unfortunately hard to get (and $$)
21:36:40 <Cale> roboguy_: Yeah, if you don't know a lot of real analysis to begin with, just characterising spaces by what their open sets are will seem rather abstract
21:37:40 <rasfar> the theorems and proofs are just so appealing
21:37:52 <roboguy_> the subset structure of a topology, intuitively speaking, describes the "nearness" of the objects, right?
21:37:54 <Cale> roboguy_: But an important thing you can do with that information is to consider all the open sets containing a given point
21:38:17 <dfeuer> The two main ways to approach topology are through metric spaces and through order topologies.
21:38:54 <roboguy_> Cale: that has to do with the "continuity structure" around that point doesn't it?
21:38:58 <Cale> If, for instance, you have some subset of the space S, and you know that every open set containing x also contains a point of S, it kind of tells you something about how S is "close" to x.
21:38:59 <dfeuer> It's best to go both ways. Some texts focus excessively on metric spaces.
21:39:01 <roboguy_> (not sure what phrase to use)
21:40:54 <roboguy_> rasfar: from what I've seen of it, I can definitely see how it would be nice aesthetically
21:41:30 <Cale> roboguy_: Yeah, and you can define continuous functions X -> Y as being those for which the preimage of every open set in Y is an open set in X
21:42:19 <roboguy_> hm
21:42:38 <rasfar> there's a chance that general topology and computer science will get together more. I know of one researcher (Paul Taylor) who has done a lot towards this.
21:42:43 <Cale> yes
21:43:17 <roboguy_> rasfar: well, here is homotopy type theory too
21:43:32 <rasfar> yeah! i just downloaded that book...
21:43:33 <Cale> You can also, if you're careful, look at types as being topological spaces in a way different from HoTT, where the open sets are the decidable ones.
21:44:01 <Cale> and continuous maps are the computable ones :)
21:44:08 <roboguy_> Cale: it seems like there's a never ending supply of cool type theory stuff
21:44:11 <rasfar> but this could be a serious rabbit-hole. i'm an application developer? should i put that time in? i'm afraid...
21:44:24 <Cale> Oh, it's definitely a rabbit hole :)
21:44:49 <Cale> You're not going to get much use out of this directly as a practical application developer
21:45:03 <Cale> But it'll help you learn to think in particular ways which might be useful
21:45:48 <rasfar> yeah. i'm just afraid i'll get pulled in, that my interests will turn towards that (encompassing) microcosm
21:45:56 <Cale> Sorry, I should have said semidecidable
21:46:31 <rasfar> and i have a low aptitude for theory ... if my life expectancy were 300 years, i would consider tryng to be a theoretician!
21:47:00 <rasfar> not so much low aptitude, as slooow as molasses
21:47:18 <roboguy_> rasfar: I found a video taped lecture series on HoTT too, but so far they actually don't seem that connected haha
21:47:19 <Cale> I don't know about aptitude, it's just like most things, how much time you've put in.
21:47:23 <MP2E> I <3 all the theoretical stuff I can get
21:47:48 <Cale> Yeah, it's more about whether you're interested enough to spend a lot of time on it
21:48:29 <rasfar> Cale: you're probably right. i think there's an immediate gratification with application-oriented that needs to be replaced with discipline to make progress in theory.
21:49:10 <rasfar> Haskell is beautiful in allowing a person to do both at once
21:49:52 <rasfar> roboguy_: heh, well i'll start with a peek at HoTT
21:54:34 * hackagebot hsnsq 0.1.0.0 - Haskell NSQ client.  http://hackage.haskell.org/package/hsnsq-0.1.0.0 (PaulBerens)
21:59:04 <pharaun> oh hah forgot that hackagebot would post it in here
21:59:33 <pharaun> first ever package, kinda alpha quality, but i wanted to figure out hackage
22:01:30 <isd> I'm sure this exists but am just not finding it: does parsec have a function of type (Parser a -> Parser ()), that just returns a parser that's the same as the argument, but that throws out the result?
22:02:50 <Maxdamantus> :t void
22:02:51 <lambdabot> Functor f => f a -> f ()
22:02:55 <Maxdamantus> ^ isd
22:03:40 <isd> ah, that would explain
22:03:50 <isd> thanks.
22:15:32 <bitemyapp> luite: do you have a twitter account?
22:15:44 <bitemyapp> luite: I'd like to lend you credit and point at your work in a tweet, but don't know where to point.
22:33:23 <educated_idiot> is there a rigorous way of deciding the order of a monad transformer stack? E.g. EitherT String (Reader a) r vs ReaderT a (Either String) r? In this case I might choose the first if I was composing this if alot of functions that might fail, but I really don't have any other intuition yet
22:44:57 <johnw> reader can go anywhere
22:45:10 <johnw> but if you had used StateT in your example, they would have very different meanings
22:46:14 <ReinH> johnw: o/
22:46:31 <johnw> hey ReinH!
22:57:04 <gsingh93> this might be a dumb question, but is it possible to have a free variable in haskell (where free variable is in the lambda calculus sense; a variable not bound to an abstraction)?
22:57:22 <gsingh93> just out of curiousity
23:03:29 <mzero> I'm not sure if the question makes sense in the contect of a running program
23:04:01 <mzero> sure...       \x = noodle x       in this expression, considered on its own, noodle is a free variable
23:04:22 <mzero> but you can't run that code - or even compile it - unless that expression is in a context where it is bound in some outer scope
23:05:53 <gabriel> I was trying silly things in the REPL, and there's an error message that's puzzling me :)
23:06:23 <gabriel> Prelude> putStrLn 1234
23:06:23 <Pythonfant> gabriel: could you give us a little more detail?
23:06:32 <gabriel> No instance for (Num String) arising from the literal `1234'
23:06:49 <Pythonfant> gabriel: can you tell me the type of putStrLn?
23:06:58 <gabriel> is kind of backwards, is n't it?
23:07:05 <gabriel> String ->IO () IIRC
23:07:13 <Pythonfant> :t putStrLn
23:07:14 <lambdabot> String -> IO ()
23:07:16 <Pythonfant> exactly
23:07:25 <Pythonfant> now what are you passing to putStrLn?
23:07:36 <gabriel> Int
23:07:43 <mzero> guess again... :-)
23:07:49 <Pythonfant> do you already see the problem?
23:07:51 <mzero> (hint   try   :t 1234 )
23:08:26 <mzero> wait - are you puzzled that there *is* an error message, or you expected one, but just not that one?
23:09:49 <Pythonfant> gabriel: try running putStrLn (1234 :: Int), that will fix 1234 to be an Int and the error message will probably be clearer to you
23:10:04 <gabriel> what's puzzling for me is that is asking for an instance of Num for String
23:10:14 <gabriel> clearly providing one won't solve anything
23:10:36 <Pythonfant> try running :t 1234 as mzero suggested
23:11:04 <carter> bitemyapp: have fun with lambdajam!
23:11:30 <gabriel> putStrLn (1234::Int) is the obvious one
23:11:41 <gabriel> is what one would normaly expect
23:12:04 <Pythonfant> gabriel: did you run :t 1234?
23:12:18 <LordBrain> :t 1234
23:12:19 <lambdabot> Num a => a
23:12:28 <Pythonfant> exactly
23:12:33 <gabriel> yes  Num a => a
23:12:33 <LordBrain> there. I did it for him.
23:12:54 <Pythonfant> so your not passing and Int to putStrLn, but a Num a
23:13:03 <Pythonfant> and as you already saw putStrLn expects a String
23:13:18 <gabriel> yes
23:13:26 <Pythonfant> so it tries to match it and searches if String is an instance of Num
23:13:38 <Pythonfant> which it isn't so you get the error
23:19:32 <isd> gabriel: One of the functions needed for the Num typeclass is fromInteger, which (unless I'm mistaken, which I might be) is passed the numeric literal to construct the value, so this would be equivalent to putStrLn $ (fromInteger 1234) :: String
23:26:13 <jle`> gabriel: 1234 is a polymorphic literal
23:26:25 <jle`> gabriel: 1234 can be read as "any type" you want, if you write a Num instnace for it
23:26:30 <jle`> gabriel: 1234 :: Double works
23:26:33 <jle`> 1234 :: Float works
23:26:36 <jle`> 1234 :: Rational works
23:26:37 <gabriel> yes
23:26:49 <jle`> gabriel: but there is no magic here
23:27:14 <jle`> there is no built-in haskell database that says "okay...an int literal can be...one of these five types and that's it."
23:27:18 <gsingh93> mzero: i didn't see your response. yea, that's exactly what i was thinking
23:27:20 <jle`> the behavior is user-definable
23:27:32 <jle`> if you can writ ea Num instnace for something, then you can create it with an int literal
23:28:19 <gabriel> can you define other things of the form "Someclass  a => a" ?
23:28:26 <jle`> gabriel: yeah, there is syntax for it
23:28:38 <jle`> if you are new to haskell, you'll be exposed to it later.
23:28:47 <Pythonfant> hm I wonder how haskell decides  what type to use for 1234 if you run “print 1234”
23:29:03 <roboguy_> Pythonfant: type defaulting
23:29:04 <jle`> @let instance Num () where _ + _ = (); _ * _ = (); _ - _ = (); negate _ = (); abs _ = (); signum _ = (); fromInteger _ = ()
23:29:06 <lambdabot>  Defined.
23:29:12 <jle`> > show (123 :: ())
23:29:14 <lambdabot>  "()"
23:29:23 <Pythonfant> roboguy_: ah k, do you know where this is defined?
23:29:43 <jle`> Pythonfant: there is syntax for it, actually, i think
23:29:47 <roboguy_> Pythonfant: hmm, not off the top of my head... you can use the "default" keyword to change it though
23:29:59 <roboguy_> Pythonfant: also, if you use -Wall, it will warn you when it defaults a type
23:30:10 <roboguy_> for print 1234 it defaults 1234 :: Integer
23:30:39 <jle`> gabriel: so when you say "putStrLn 1234", it knows that putStrLn demands a String....so it tries to read the literal 1234 as a String
23:30:45 <jle`> gabriel: it does that by using the Num instance for String
23:30:51 <jle`> gabriel: but...there is no defined Num instance for string
23:31:00 <jle`> actually, if you wanted to be evil, you could write your own, and it would work
23:31:06 <jle`> (but don't do that :P)
23:31:24 <Pythonfant> roboguy_: hm here http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Num.html#Num default is empty
23:31:55 <dfeuer> I'm looking over this Core and I'm trying to figure out what this $wscanl function is that it turned my scanl into (along with sticking in an (unboxed) pair that I don't understand.
23:32:08 <roboguy_> Pythonfant: I don't think defaults are exported. I think that's just internal to that module
23:32:30 <_0xAX> Hello all
23:32:35 <jle`> hello _0xAX
23:33:01 <_0xAX> i'm little confused, why is the `network` package has no ssl support :(
23:33:08 <jle`> gabriel: admittedly, the error message is not so helpful
23:33:15 <jle`> gabriel: to someone new to haskell, that is
23:33:31 <_0xAX> is anybody knows package like network but for both modes, i mean tcp and tcp over ssl
23:33:40 <gabriel> that's my point :)
23:33:44 <roboguy_> Pythonfant: aha, here it is: http://www.haskell.org/onlinereport/decls.html#default-decls
23:33:53 <jle`> gabriel: people often run into it here
23:33:57 <jle`> > 5 && True
23:33:58 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
23:33:58 <lambdabot>    arising from the literal ‘5’
23:34:08 <gabriel> and I'm not totally new to haskell :) (still I consider myself a noob tho)
23:34:10 <roboguy_> the "default" default is default (Integer, Double)
23:34:22 <jle`> if you come from a language like C where bool is just an int, this would throw you in for a loop
23:34:22 <Pythonfant> roboguy_: yeah I found that but I wanted to try where it's actually in the suorce. (currently downloading the ghc sources)
23:35:11 <Total_1mmersion> main doesn't have to be IO ()?
23:35:25 <roboguy_> Total_1mmersion: no, it can be IO A for any type A
23:35:36 <roboguy_> but I *strongly* recommend explicitly giving it the type IO ()
23:35:42 <Total_1mmersion> I did not know that, heh
23:35:50 <roboguy_> you can run into subtle problems if you leave off the type of main
23:35:56 <roboguy_> subtle *runtime* problems
23:36:05 <dfeuer> The only thing I'm seeing about wscanl is some paper about a circuit simulator or something.
23:36:33 <dfeuer> Like what, roboguy_?
23:36:42 <roboguy_> dfeuer: consider main = putStrLn <$> getContents
23:37:00 <roboguy_> that looks misleading
23:37:18 <jle`> oh nice
23:37:42 <roboguy_> that was a fun one, haha
23:37:59 <dfeuer> Wait, what?
23:38:12 <jle`> it'll compile, but not do what you think it does
23:38:14 <roboguy_> dfeuer: it type checks, but it's behavior is likely not what you'd expect
23:38:18 <roboguy_> (it does nothing)
23:38:19 <jle`> hm
23:38:21 <jle`> wait
23:38:32 <jle`> nvm
23:38:37 <roboguy_> it won't type check if you explicitly give main :: IO ()
23:38:42 <Pythonfant> roboguy_: hm can't find anything using ack to search for "default (" I guess I just need to accept that it's defined somewhere :)
23:38:53 <roboguy_> Pythonfant: what are you looking for?
23:39:13 <roboguy_> it's a keyword, so it won't be defined in the standard library
23:39:17 <Pythonfant> the line where default (Integer, Double) is defined
23:39:26 <Pythonfant> doesn't it need to be in the ghc source?
23:39:34 <roboguy_> oh, well like I said, defaults only apply to one module
23:39:43 <isomorpheous> I'm thinking my censor's data isn't very good
23:39:43 <roboguy_> they don't get applied to things that import that module
23:39:55 <isomorpheous> I gave my censor Ted Kaczynski's manifesto
23:40:00 <isomorpheous> and it scored 0 on conspiracy
23:40:07 <roboguy_> Pythonfant: it's somewhere in the compiler itself that the default is default (Integer, Double)
23:41:25 <ReinH> roboguy_: void (putStrLn <$> getContents) typechecks! ;)
23:41:41 <Pythonfant> ah k, thx roboguy_
23:42:15 <roboguy_> ReinH: haha, true
23:43:32 <roboguy_> after my "putStrLn <$> getContents" debacle, I always write an explicit main :: IO ()
23:43:44 <jle`> i do it becuase hlint complains
23:43:49 <jle`>  / ghc-mod
23:44:03 <dfeuer> roboguy_, when I tried evaluating that in GHCi, it crashed GHCi with <stdin>: hGetChar: illegal operation (handle is closed), and dumped me out into the shell. :-(
23:44:21 <roboguy_> dfeuer: interesting... well, if you compile it and run it, it does nothing
23:44:34 <jle`> dfeuer: my ghci does it fine too
23:44:47 <jle`> oh wait it's bad on 7.8
23:45:39 <roboguy_> I wonder if GHCi doesn't like IO (IO (...)) things
23:45:49 <dfeuer> roboguy_, if I instead do (putStrLn <$> getContents) >>= id, then it takes lines of input and spits out empty lines.
23:46:13 <jle`> dfeuer: well... yeah
23:46:19 <jle`> because (>>= id) = join
23:46:31 <jle`> so that's equivalent to getContents >>= putStrLn
23:46:32 <roboguy_> yeah, that's a fixed version
23:46:33 <dfeuer> roboguy_, it looks more like something hairy with lazy IO. I guess it's not catching some exception?
23:46:43 <jle`> on ghci, or on main?
23:46:52 <jle`> on main, the behavior is expected
23:47:11 <dfeuer> jle`, I mean in ghci. I don't like when the interpreter crashes just because my program does.
23:47:11 <jle`> you're returning IO (IO ())
23:47:14 <jle`> ah i see
23:47:52 <ReinH> dfeuer: you've just rediscovered join! :D
23:47:54 <jle`> in ghci it crashes on ctrl+c when i just do getContents
23:47:56 <dfeuer> But why is it that when I join it, it doesn't echo but rather just outputs blank lines? The handle should be open, right?
23:48:29 <dfeuer> That too, jle`.
23:48:52 <dfeuer> But I just typed putStrLn <$> getContents  on the ghci prompt and it crashed.
23:49:13 <jle`> putStrLn =<< getContents doesn't take lines of input and spit out empty lines for me
23:50:03 <jle`> the behavior is weird on ctrl+c though
23:50:03 <roboguy_> yeah, that's echoing stuff as I type it for me
23:50:18 <roboguy_> haha, I can get it to do terminal tricks with Esc
23:50:54 <dfeuer> Oh, it does echo, character by character.
23:50:56 <dfeuer> I see.
23:50:57 <roboguy_> I wonder if it's echoing the ^C
23:51:10 <jle`> it's weird if i ^C out of it and run it again
23:51:12 <dfeuer> But then ^D doesn't end it, which is strange.
23:51:29 <jle`> everything is weird, what is life
23:51:47 <dfeuer> But then why does it crash on ^C?
23:51:50 <roboguy_> dfeuer: I noticed that too, hmm. I guess it's ok echoing an EOF and continuing
23:52:47 <dfeuer> roboguy_, that doesn't seem to make sense, I don't think.
23:52:59 <roboguy_> yeah... hmm
23:53:25 <jle`> it shows up as ^D for me, so maybe it's just literally ^D and not EOF
23:53:29 <dfeuer> But I get the impression the big Haskell experts have pretty much written off lazy IO as a bad idea, and don't necessarily want to spend much time cleaning up its messes.
23:53:59 <dfeuer> The ^D thing they might be willing to do something about if it affects non-lazy IO.
23:54:27 <roboguy_> that's interesting that it echoes it as ^D, but it clears the terminal's screen if you type Esc-c
23:56:39 <achernyak> Hi, I have what I hope is a quick question. While going through Real World Haskell, I saw a function used to convert list functions into safe list functions. The function itself makes sense, but when I looked at the type of the function there was a new type [t].
23:57:30 <roboguy_> achernyak: hmm, what types are you familiar with?
23:57:31 <achernyak> would someone be able to explain to me what [t] means? the type was safeListFunc :: ([t] -> a) -> [t] -> Maybe a
23:57:47 <roboguy_> the fact that it is "t" doesn't matter. type variables can be given any name
23:57:57 <roboguy_> as long as it's consistent
23:58:16 <jle`> achernyak: have you seen lists in haskell yet?
23:58:20 <achernyak> ah ok
23:58:22 <jle`> as in, [1,2,3]
23:58:25 <jle`> or [True, False]
23:58:25 <roboguy_> so another way to write that is safeListFunc :: ([a] -> b) -> [a] -> Maybe b
23:58:39 <achernyak> I just tried changing it and it came out the same hmm
23:58:48 <jle`> yeah, it's just a variable name
23:58:50 <jle`> try out these two functions:
23:58:55 <jle`> add2 x y = x + y
23:58:59 <jle`> add2 a b = a + b
23:59:03 <jle`> they should both work the same
23:59:22 <achernyak> I might not be understanding a different part in that case. I assumed it was something special.
23:59:26 <jle`> this also works the same:
23:59:30 <jle`> add2 q r = q + r
23:59:50 <achernyak> how does this function work on functions that out both a and [a]?
