00:05:50 * hackagebot peyotls 0.0.0.17 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.17 (YoshikuniJujo)
00:57:36 <centrinia> @botsnack
00:57:36 <lambdabot> :)
01:06:58 <jle`> @pl \x y -> (y, x)
01:06:58 <lambdabot> flip (,)
01:07:06 <jle`> oh yeah
01:19:37 <johnw> also: curry swap
01:21:35 <johnw> what's a good pretty printing library for rendering ASTs of a programming language into something both well formed and parsable?
01:33:04 <Qfwfq> the derived show instance
01:33:43 <johnw> wow, that's pretty much the opposite of understanding my question :)
01:34:12 <Qfwfq> :D
01:41:00 * hackagebot peyotls 0.0.0.18 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.18 (YoshikuniJujo)
01:42:45 <quchen> johnw: Maybe boomerang is worth having a look?
01:43:51 <johnw> huh, interesting
01:44:09 <johnw> i'm using Parsec right now; I was using Trifecta, but couldn't figure out how specify a custom tokenizer
01:44:42 <quchen> Parsec with careful (read: error-prone) design would have been my first attempt too
01:44:56 <johnw> it's actually working out really nicely for my use case
01:48:44 <johnw> edwardk: how does one define a custom lexer to use with Trifecta?
01:54:46 <jle`> quchen: did you ping?
01:56:14 <quchen> jle`: I @messaged you instead
01:56:42 <ByteEater> hi, all! any ideas for a good replacement for if without else (by which I mean somenthing along these lines: if c then Just x else Nothing)?
01:56:49 <ByteEater> recently I came up with do {guard c; return x} but I'm wondering whether there are appealing alternatives and what their pros and cons might be
01:58:07 <kazagistar> ByteEater: what are you using it for? more context is needed... that question feels like it implies a very imperative mindset
01:58:21 <jle`> you can use bool i guess
01:58:23 <jle`> :t bool
01:58:24 <lambdabot> a -> a -> Bool -> a
01:58:34 <merijn> ByteEater: It really kinda depends on the context
01:58:40 <jle`> > bool (Just x) Nothing True
01:58:41 <lambdabot>  Nothing
01:58:43 <merijn> ByteEater: for monadic actions probably when?
01:58:46 <jle`> oops
01:58:48 <merijn> :t when
01:58:48 <lambdabot> Monad m => Bool -> m () -> m ()
01:59:01 <jle`> quchen: on twitter?
01:59:41 <ByteEater> I use it in a function I pass to unfoldr, so no, not imperative at all, worry not :-)
01:59:54 <merijn> jle`: Presumably he's referring to lambdabot? In which case you should have a private message from lambdabot telling you you have unread messages
02:00:18 <jle`> merijn: oh hey, i did not tnoice :)
02:00:22 <jle`> that's neat
02:00:34 <quchen> jle`: On lambdabot, /q lambdabot, then @messages
02:01:01 * hackagebot peyotls 0.0.0.19 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.19 (YoshikuniJujo)
02:01:01 <quchen> jle`: Hold on I'll just paste it
02:01:03 <merijn> jle`: Lambdabot lets you do "@tell name message" or "@ask name message" and lambdabot will private message that person the next time they talk in a channel with lambdabot in it
02:01:16 <ion> /query lambdabot @messages may or may not work in your client.
02:01:31 <jle`> it's cool, i got the message :)
02:05:04 <ByteEater> jle`, thx, for reminding me the of function for Bool elimination, that's cool, but for different purposes (basically if as a function and different order of arguments)
02:05:32 <ByteEater> merijn, I tried with when but without success (possibly not hard enough)
02:06:27 <ByteEater> how would you translate "if c then Just x else Nothing" or "do {guard c; return x}" using when?
02:06:44 <jle`> ByteEater: x <$ guard c
02:06:55 <jle`> > 5 <$ guard (5 > 3)
02:06:55 <merijn> ByteEater: You can't, like I said the question of how to replace if there depends on what you're actually doing
02:06:56 <lambdabot>  No instance for (GHC.Show.Show (f0 a0))
02:06:56 <lambdabot>    arising from a use of ‘M34292193448111447204144.show_M34292193448111447204...
02:06:56 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
02:06:56 <lambdabot>  Note: there are several potential instances:
02:06:56 <lambdabot>    instance [safe] GHC.Show.Show a =>
02:06:57 <jle`> oh
02:07:03 <ByteEater> :t (<$)
02:07:04 <lambdabot> Functor f => a -> f b -> f a
02:07:08 <jle`> yeah
02:07:10 <jle`> sorry
02:07:21 <jle`> it really depends on the context
02:07:28 <jle`> the higher level of what you want to do
02:07:38 <jle`> > 5 <$ guard (5 > 3) :: Maybe Int
02:07:39 <lambdabot>  can't find file: L.hs
02:07:43 <jle`> > 5 <$ guard (5 > 3) :: Maybe Int
02:07:44 <lambdabot>  Just 5
02:07:53 <jle`> > 5 <$ guard (5 > 10) :: Maybe Int
02:07:55 <lambdabot>  Nothing
02:08:24 <ByteEater> cool, thx again, jle`
02:08:48 <kazagistar> ByteEater: I think you are doing something strange... what purpose does this construction serve?
02:08:57 <ByteEater> actually my version with do also doesn't typecheck standalone, it needs an expected type in the context
02:09:34 <ByteEater> merijn, kazagistar, as I said, I'm writing a function to be passed to unfoldr
02:10:42 <kazagistar> right, so the goal of the function is to map an input to a Maybe tuple. what "choice" are you making? could you post code?
02:11:18 <jle`> quchen: ah well.  this is not a situation i am familiar with, to be honest.  on one hand i am sure not many people used tagged-binary in production; i wrote it to split off functionality from a larger library i was writing for ghcjs but never finished because of issues i ran into with ghcjs.  so i likely won't be doing too much development on it myself either.  i trust your ability as haskeller probably more
02:11:20 <jle`> aware of how GHC works than I, too.
02:11:35 <jle`> quchen: however, because i guess of my cross-compilation goals, i might have at times different goals than you if i continue to develop
02:11:56 <jle`> but i also wouldn't really be happy with two libraries providing he same functinality on hackage
02:11:59 <jle`> such dilemma.
02:12:47 <quchen> The main problem with your lib was that it gave me type mismatches without telling me what the mismatch is, actually.
02:13:07 <jle`> ByteEater: you might also like mfilter :: (a -> Bool) -> Maybe a -> Maybe a, which turns a Just x into a Nothing if the x doesn't satisfy the predicate...comes up in similar circumstances
02:13:17 <quchen> But if you expand a bit on your cross-compilation goals we might want to add that to the package description so both packages have their own niches.
02:13:46 <jle`> quchen: ah.  yeah, that is the result of the slight half bakedness of it; i sort of rushed it out because i was planning on releashing the ghcjs library a day or two later
02:13:50 <jle`> hm
02:13:56 <jle`> yes, i think i will attempt to specialize
02:14:18 <jle`> on the other hand, if you want, i could contribute to yours, and take mine off of hackage
02:14:45 <jle`> if you think you can also integrate cross compilation without compromising your goals
02:15:05 <quchen> I've never done cross-compilation, I'm not even sure what it means in the context of the lib
02:15:06 <johnw> I just used mfilter in my Nix parser today
02:15:10 <johnw> nixPath = try $ fmap mkPath $ mfilter ('/' `elem`) $ some (oneOf "A-Za-z_0-9.:/")
02:15:26 <kazagistar> ByteEater: another option, depending on what you are doing, might be something like { (if x < max then (+step) else id) val }
02:15:54 <jle`> quchen: both a ghcjs front-end application and a haskell backend/server application use the same data types and everything, and communicate via websockets
02:16:13 <jle`> and so i wrote an interface that sort of was inspired by distributed/cloud haskell
02:16:15 <quchen> Ah, so by cross-compilation you mean "GHC and GHCJS compatible"
02:16:27 <jle`> where you would go x <- await :: Process Int
02:16:36 <jle`> and it would block until an Int was received across the websocket
02:17:05 <jle`> yeah, ghc and ghcjs compatible...but also the final products communicationg too
02:17:05 <quchen> Ah, I see. In that case it's probably an unnecessary overhead to include the full TypeRep, and hashing is enough
02:17:28 <ByteEater> jle`, I also looked into mfilter, it's useful, but probably not in this case; you can see when I paste the code, as kazagistar asked
02:18:15 <jle`> quchen: indeed, probably...at least for that specific goal, with a networking mindnset
02:18:29 <jle`> i think i might specialize the package to this purpose then
02:18:39 <jle`> in fact i might just absorb it into my messaging platform
02:18:57 <jle`> if people want to use some sort of typed binary outside of the platform, they can just use your library
02:19:49 <jle`> which is probably more useful in contexts outside of that specific one
02:20:13 <quchen> The main reason I wrote it is for the wordy error messages to be honest :-D
02:20:20 <jle`> ByteEater: you can do the same thing with mfilter though -- mfilter (const c)  ;)
02:21:01 <jle`> (don't actually do that :) )
02:21:01 <ByteEater> :t mfilter.const
02:21:02 <lambdabot> MonadPlus m => Bool -> m a -> m a
02:21:08 <Yuu_chan> Haskellers and categoricians! How do you react when someone defines a functor as a class with overloaded ()?
02:21:36 <quchen> Overloaded ()?
02:22:17 <Yuu_chan> quchen: I mean like in C++
02:22:36 <jle`> quchen: that's probably useful....and, well, at least it's an actual step up from Data.Dynamic
02:22:55 <quchen> Yuu_chan: C++ functors have nothing to do with mathematical functors.
02:23:14 <ByteEater> here's my code (in which I also did some pointless ;-) exercises): http://lpaste.net/106907
02:23:15 <jle`> yeah, it's a rather unfortunate historical name choice
02:23:17 <quchen> C++ functors are literally "objects with overloaded operator()".
02:23:25 <Yuu_chan> quchen: I know, that's why the question is
02:23:36 <quchen> The answer is "it's a different namespace".
02:24:05 <quchen> Like every discipline likes to define its own thing called "matrix" :-)
02:24:21 <ByteEater> btw, for anybody who read that: don't you think unfoldr and mapAccumL are somewhat similat and should have been made more compatible in terms of arguments order?
02:24:22 <jle`> ByteEater: in that case i would probably rather pattern match or guard
02:24:32 <Yuu_chan> So you just deal with it? :)
02:24:33 <merijn> quchen: To be fair, you could implement mathematical functors in C++ with templates easily
02:24:39 <supki> -XOverloadedUnit would be a great addition to -XNullaryTypeClasses
02:24:47 <Welkin> @karma c
02:24:47 <lambdabot> c has a karma of 2
02:24:53 <Welkin> @karma C
02:24:53 <lambdabot> C has a karma of 2
02:24:54 <jle`> ByteEater: i think mapAccumL's function order is meant to be more parallel to foldl
02:24:59 <merijn> supki: ಠ_ಠ
02:25:01 <jle`> :t mapAccum:
02:25:02 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
02:25:06 <jle`> :t mapAccumL
02:25:06 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
02:25:09 <jle`> :t foldl
02:25:10 <lambdabot> (b -> a -> b) -> b -> [a] -> b
02:25:18 <Welkin> merijn, you look tired
02:25:23 <jle`> subsitute acc ~ b
02:25:27 <ByteEater> so that "second (,ps)" would suffice instead of "(snd &&& (,ps) . fst)"
02:26:18 <jle`> i would have done processPrime 0 _ = Nothing; processPrime n (p:ps) = Just (...); and ran it with uncurry processPrime
02:26:24 <jle`> but...i'm weird
02:26:40 <jle`> guard isn't meant to be used this way
02:27:01 <jle`> er.  well, who am i to say
02:27:02 <Yuu_chan> When my friends or coworkers say something like "blah blah pass a functor blah call a functor", I can't help myself but to overreact like "THAT's not a functor, man!"
02:27:08 <jle`> it's 2:30 am :)
02:27:32 <jle`> Yuu_chan: well, you just have to get used to the fact that some words in english have multiple definitions :)
02:27:53 <quchen> Yuu_chan: C++ functors are what's called "function" in Haskell.
02:28:01 <ByteEater> jle`, yeah, actually it's nice that Haskell has a convinient and consistent arguments order for folds, unlike Oz, which follows a different logic
02:28:01 <Welkin> @karma c
02:28:02 <lambdabot> c has a karma of 2
02:28:06 <senft> Hey, why can't I don something like: data FAE = NumE Num
02:28:08 <senft> ?
02:28:15 <jle`> you don't go to a tennis match...and when they say "set", you say "hey, that's NOT a set!"
02:28:15 <quchen> Num is a typeclass, not a type.
02:28:16 <Welkin> someone must have fixed that
02:28:52 <Welkin> jle`, you and your pacific time zone
02:28:52 <Yuu_chan> jle`: I'd prefer even for different language schools to use a common vocabulary and not to reinvent their own terms v_v
02:28:55 <jle`> or when your teacher assigns groups for a project
02:28:59 <int3__> jle`: I'm sure we all know of some people who do, and annoy everyone in the process ;)
02:29:08 <jle`> you don't go, "hey, teacher...that's NOT a group..."
02:29:13 <senft> quchen: I see
02:29:21 <senft> thanks
02:29:25 <jle`> "...i refuse to do this assignment."
02:29:37 <Welkin> jle`, I would let them know that I don't do stupid projects assigned to groups
02:29:37 <Kinnison> jle`: meep
02:30:02 <Welkin> it never ends well
02:30:09 <int3__> "class, please form yourself into posets, with one leader each"
02:30:37 <jle`> your objection would probably then not come from the fact that the teacher used the word "group" to not refer to a monoid with an inverse
02:31:30 <Yuu_chan> jle`: during the first year, we had jokes like "What's a semigroup? — That's what remains of our group after the first end-of-term exams"
02:31:40 <jle`> haha
02:31:47 <kazagistar> "sorry teacher, I can't, I deny the axiom of choice" <_<
02:32:07 <ByteEater> Yuu_chan++
02:32:13 <quchen> jle`: I guess the problem with "functor" is different because it's a made up word from (exactly) mathematics that C++ just took out of context. But I guess that's how languages evolve.
02:32:52 <Welkin> c++ doesn't evolve
02:32:54 <m_m> Hi. What is the most popular web framework for haskell? Do you know any real world use of them ?
02:33:05 <Welkin> it is maimed and tortured and made to carry more and more on its back
02:33:14 <pharaun> ha
02:33:16 <jle`> i guess i can't speak for the history of common C++ terminology; if it really came from the misunderstanding of a mathematical functor then that would be kind of silly
02:33:19 <Welkin> m_m,  yesod
02:33:31 <Yuu_chan> quchen: you clearly described what I wanted to say in my clumsy English, thanks.
02:33:34 <jle`> my folk etymology was always that it was like "some function object... a function-er....a...functor!"
02:33:48 <jle`> m_m: yesod is popular, but so is snap, scotty...
02:34:16 <quchen> jle`: fobject would be my choosing! :-D
02:34:24 <ByteEater> Welkin, yet it does evolve, and I think they're doing quite a god job with its contemporary versions, given the pre-existing mess
02:34:34 <johnw> I think C++ functor came from "function operator", which is what you use it to define
02:35:20 <Yuu_chan> Welkin: C++ "evolves" via the horizontal feature transfer
02:35:57 <jle`> quchen: anyways feel free to push yours to hackage; i'll look at my library and consider specializing into a niche or just absorbing it into the larger platform
02:36:29 <quchen> jle`: Alright, will do!
02:36:37 <jle`> pleasure doing business
02:36:42 * jle` handshake
02:36:49 <haasn> scotty++
02:37:32 <jle`> i use scotty for my blog with fay for frontend and i've had a lot of fun with it.  haskellers.com uses yesod i think
02:37:52 <jle`> i am sure that their respective webpages list usages of the framework in the wild
02:37:55 <haasn> jle`: got a link to this blog?
02:38:02 <jle`> jle.im
02:38:04 <jle`> it's not much
02:38:31 <Yuu_chan> http://commons.apache.org/proper/commons-functor/apidocs/src-html/org/apache/commons/functor/Functor.html#line.35 ouch
02:38:33 <jle`> er, http://jle.im if your client complains
02:38:54 <Yuu_chan> „In Java, a functor is an object which can do nothing“
02:39:54 <haasn> jle`: Is all of the blog backend is homegrown? Source code anywhere?
02:40:28 <jle`> haasn: "framework" is https://github.com/mstksg/blog and the actual instance is https://github.com/mstksg/inCode
02:40:55 <jle`> if you poke around in the source code it's a little messy because it was literally my second ever haskell project heh.  and i've only been adding/modifying it chunk by chunk over the past year or so
02:41:08 <jle`> but one thing i love about haskell is that i can be away for the code for months at a time
02:41:15 <jle`> and when i come back, the type system will assure me that i don't break anything
02:41:17 <jle`> :)
02:41:29 <jle`> so i have...a pleasantly maintainable frankenstein
02:41:39 <jle`> it's all home grown on top of scotty
02:42:06 <haasn> Thanks, I'm just curious to see examples of scotty in action running something nontrivial like a blog
02:42:18 <jle`> i would hardly call a blog nontrivial ;)
02:43:28 <jle`> i used to do all of queries on persistent and postgresql, but realized that i don't actualyl do any modifications, so i just load the entire database at the beginning and make the proper changes by looking at the files in the entries directory, and the rest just access the database using a Reader.  so i actually took "out" some of my original fancy stuff
02:43:37 <Welkin> why not blog using hakyll?
02:43:48 <jle`> Welkin: hakyll is the static site engine, right?
02:43:51 <Welkin> yes
02:43:54 <jle`> i wanted to be able to queue and schedule posts
02:43:59 <Welkin> static blogs are all the rage
02:44:34 <jle`> the posts themselves can be static, but the rss feed, home page, archives, etc. have to reflect the scheduling and timing of posts
02:44:54 <jle`> besides i thought it would be more fun to learn how to use persistent :)
02:45:52 <merijn> jle`: hakyll generates rss when you generate the site
02:46:01 <merijn> There's zero reason RSS can't be static
02:46:05 <jle`> merijn: but the rss doesn't update dynamically?
02:46:14 <jle`> like i want to schedule a post for five hours after a push
02:46:19 <jle`> or generating
02:46:26 <merijn> jle`: You can't do that anyway with hakyll
02:46:32 <jle`> and i want it to not show up on the rss..then five hours later, have it show up
02:46:37 <jle`> yeah, that's why i didn't use hakyll
02:46:47 <danilo2> Hello! I want to write some tests for my library - I've got a lot of special cases and I want to cover all of them. I want a simple and powerfull testing library -should I choose HUnit, QuickCheck, HSpec or something other? :)
02:46:48 <jle`> Welkin was asking why i didn't go for hakyll/a static site
02:48:04 <nclarke> danilo2: They do slightly different things. QuickCheck is basically a fuzzer - it checks that your invariants hold over a bunch of random instances
02:48:38 <nclarke> HUnit is more of a standard unit testing library
02:48:41 <nclarke> Never used HSpec
02:49:13 <danilo2> nclarke: I see, so I have to choose between HUnit and HSpec If I want to check for some special cases
02:49:23 <danilo2> I would love to hear any opinions about hspec
02:49:33 <nclarke> Do you know the special cases in advance?
02:49:41 <nclarke> quickcheck is very good at finding special cases
02:49:50 <danilo2> nclarke: ahh! "Hspec is just a framework for running HUnit and QuickCheck tests. "
02:50:35 <danilo2> nclarke: Yes I know them. It would be very hard to write a rule providing "the right result" - It would be a lot easier to provide these special cases by hand :)
02:50:41 <danilo2> Ok, I'll stay with hspec :)
02:50:43 <nclarke> I've also used tasty with some success
02:51:05 * hackagebot haste-compiler 0.3 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.3 (AntonEkblad)
02:51:07 * hackagebot websockets 0.8.2.6 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.8.2.6 (JasperVanDerJeugt)
02:51:12 <danilo2> nclarke: Oh nice! thank you! :)
02:54:42 <senft> Is it somehow possible to use a type class in an ADT, like: data FAE = NumE Num? Or what would be the best way to achieve such thing?
02:55:03 <merijn> senft: What would you expect that to do?
02:55:31 <merijn> (Which is a way of saying "no, because that doesn't even make any sense")
02:56:06 <senft> So FAE will have more cases, like:
02:56:08 <senft> data FAE  = NumE Int
02:56:10 <senft>           | AddE FAE FAE
02:56:12 <senft> ...
02:56:21 <senft> but I want the NumE to be of any numerical type
02:56:41 <lieven_> something like Num a => data FAE a = NumE a?
02:56:58 <merijn> lieven_: ಠ_ಠ ಠ_ಠ ಠ_ಠ
02:57:10 <merijn> lieven_: Why the constraint there?
02:57:31 <lieven_> merijn: what where the unicode chars? my client doesn't do unicode?
02:57:34 <merijn> senft: I'd just do "data FAE a = NumE a | AddE (FAE a) (FAE a)" or similar
02:57:40 <merijn> lieven_: Look of disapproval :p
02:57:44 <lieven_> lol
02:58:01 <Welkin> ಠಠ
02:58:02 <senft> merijn: but then it is not restricted to numerical types, right?
02:58:09 <jle`> and then when you want to write a function that operates on FAE a, have the constraint there.  reduceFAE :: Num a => FAE a -> a
02:58:15 <merijn> senft: No, but why bother? Just restrict your functions
02:58:20 <jle`> senft: usually, restricting data types is a bad idea
02:58:26 <merijn> senft: "evalFAE :: Num a => FAE a -> a" <- done
02:59:22 <senft> "usually, restricting data types is a bad idea" I can see that. But it somehow seems to be the right thing here ;)
02:59:28 <senft> but ok. I will restrict the functions then. Thanks guys
02:59:34 <insejn> what’s the correct syntax to self reference a variable inside a do block? x <- f x doesn’t work.
02:59:37 <jle`> senft: and what makes you feel that?  some deep seated intuition? :)
02:59:47 <quchen> lieven_: Another case for the FBUT! https://github.com/quchen/articles/blob/master/fbut.md#imposing-constraints-on-data-types
03:00:02 <Welkin> insejn, <- unpacks a value
03:00:04 <insejn> by doesn’t work I mean that the RHS x is undefined
03:00:30 <senft> jle`: Beacuse I would then only have to write the restriction in one place and not at every new function that works with FAE
03:01:14 <jle`> senft: the functions are restricted anyway; wouldn't you want someone to be able to look at a function and see what it can/can't do or needs, from the type of the function?
03:01:19 <insejn> Welkin: so how to write a self-recursive definition inside a do block?
03:01:42 <jle`> insejn: can you give an example of what you would use this for?
03:02:24 <senft> jle`: Sure I would want that. But if someone sees that type FAE in the function definition he/she would lookup the type definition anyways ;)
03:03:30 <insejn> jle`: trying to get rid of unsafePerformIO in line 34 in http://lpaste.net/106908
03:04:19 <int3__> how do I write an instance declaration that says "(Foo a) is an instance of Bar iff a is an instance of Baz"?
03:04:29 <senft> jle`: but... nvm. Because of a lack of alternatives I will just go with it... ;)
03:04:38 <int3__> I'm not sure what the syntax for the type constraint is, basically
03:05:07 <jle`> senft: i think one has just been decided to be less harmful/more idiomatic :)
03:05:28 <jle`> there is one way to do sort of what you want, but it is probably almost certainly not actually what you want.
03:05:46 <insejn> jle`: This code is trying for trying to understand how IO worked in Haskell before introducing monads
03:06:12 <{AS}> insejn: why not try mapM and then <- responses?
03:08:00 <int3__> I have `instance Monoid a => Comonad Board where ...` and GHC complains and suggests -XUndecidableInstances
03:08:14 <jle`> or some form of iterateM
03:08:28 <jle`> int3__: where is a in the type?
03:08:38 <int3__> it should be (Board a)
03:08:40 <int3__> but that doesn't compile either
03:09:14 <int3__> jle`: GHC complains of Comonad getting the wrong kind (* instead of * -> *)
03:09:32 <int3__> I understand the error, but I don't know how to write it correctly
03:10:03 <jle`> are you saying that you want Board to only be be a comonad when it holds a monoid?
03:10:11 <int3__> jle`: yes
03:10:38 <jle`> not possible as of the way comonad works in haskell at the moment
03:10:47 <{AS}> insejn: so using mdo, mapM and binding responses
03:10:50 <jle`> do you understand why you can't have a type that is only a Functor if it has, say a Monoid?
03:10:53 <{AS}> you can avoid unsafePerformIO
03:11:01 <int3__> jle`: nope
03:11:12 <jle`> because what's the type of fmap?
03:11:26 <jle`> fmap :: Functor f => (a -> b) -> f a -> f b
03:11:30 <{AS}> insejn: http://lpaste.net/4344149365938454528
03:11:34 <jle`> you can't change the type signature
03:11:37 <jle`> to be
03:11:44 <jle`> fmap :: (Functor f, Monoid a, Monoid b) => (a -> b) -> f a -> f b
03:11:49 <int3__> ah
03:12:09 <jle`> a haskell Functor has to be parametric over all possible types
03:12:21 <jle`> because you have to be able to map *any* arbitrary function...that goes to any arbitrary type
03:12:26 <insejn> thanks {AS}, looking now
03:12:27 <int3__> got it
03:12:33 <nclarke> Anyone know of/can suggest a library for generic description of options which can be compiled into, say, independent parsers for command-line options, config file parsers etc
03:12:35 <jle`> (there are ways to implement Functor that would allow constraints like this, but that's not how it's implemented in Haskell at the moment)
03:12:48 <int3__> I see
03:12:54 <nclarke> Something like `optparse-applicative`'s 'Option', but more general
03:13:08 <jle`> int3__: basically the idea is that Functor is not supposed to be able to "care" about what it is applied to
03:13:19 <jle`> it is supposed to be applied indiscriminately
03:13:39 <{AS}> insejn: requires RecursiveDo btw
03:13:47 <insejn> yep
03:14:05 <int3__> I guess I could force Board only accept Monoids using the GADT constructor syntax
03:14:13 <int3__> or declare a MonoidBoard type
03:14:13 <jle`> int3__: but why
03:14:25 <jle`> just restrict your helper functions
03:14:29 <jle`> or your functions
03:14:42 <jle`> if you want the Comonad method functions to be able to take advantage of monoidness, then...that won't help you
03:15:13 <jle`> the comonad methods have types that are paramterized for all types that you can apply w to
03:15:18 <jle`> :t (=>>)
03:15:19 <lambdabot>     Not in scope: ‘=>>’
03:15:19 <lambdabot>     Perhaps you meant one of these:
03:15:19 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
03:15:19 <bluebelle> > let moveToFront n xs = (xs !! n) : let (ys, zs) = splitAt n xs in ys ++ tail zs
03:15:21 <lambdabot>  not an expression: ‘let moveToFront n xs = (xs !! n) : let (ys, zs) = splitA...
03:15:33 <bluebelle> > moveToFront n xs = (xs !! n) : let (ys, zs) = splitAt n xs in ys ++ tail zs
03:15:34 <lambdabot>  <hint>:1:18: parse error on input ‘=’
03:15:46 <jle`> insejn: is all you are doing running a loop? of responses and requests?
03:15:54 <int3__> jle`: yeah... I wanted 'extract' to be able to return 'default values', i.e. mempty
03:16:46 <bluebelle> >let moveToFront n xs = (xs !! n) : let (ys, zs) = splitAt n xs in ys ++ tail zs
03:17:02 <jle`> insejn: you should be able to do this without recursive do
03:17:17 <bluebelle> any suggestion to change this to O(1)?
03:17:48 <bluebelle> I need to get [[a,b,c],[b,a,c],[c,a,b]] and this helper function seems to be too slow.
03:17:58 <bluebelle> *from [a,b,c]
03:18:24 <jle`> bluebelle: if you want O(1), use Vector :)  list isn't meant for this kind of stuff.
03:18:52 <jle`> xs !! n is inherently O(n) because of the way lists work...they're linked lists with nodes scattered all around the heap
03:19:10 <jle`> so if you do any sort of random indexing ever, you can't do O(1)
03:19:40 <bluebelle> jle` : ok I'll try it, thanks
03:28:08 <insejn> jle`: yes all I do is running a loop of resp and reqs
03:33:20 <insejn> {AS}: I’m getting “Enter a number: UnsafeIO: thread blocked indefinitely in an MVar operation” when running your code
03:35:32 <matheus23> I get a compile time error using Data.Vec... http://lpaste.net/106911 I have "extensions: DataKinds" in my .cabal...
03:35:55 <{AS}> insejn: Hmm, I am unsure then. Sorry
03:36:05 <insejn> ok, thanks!
03:37:38 <ClaudiusMaximus> matheus23: line 58 of your paste you have :: instead of :.
03:37:49 <matheus23> ClaudiusMaximus: oh thank you for finding that!
03:38:14 <matheus23> It's hard to see somthing like that with such an operator :/
03:38:23 <matheus23> But of course... Now that error makes sense :D
03:47:09 <jle`> insejn: why don't you just do a normal recursive function?
03:48:05 <Nik05> hello what is the difference between Alternative and MonadPlus?
03:48:24 <jle`> insejn: your thing might not work because what would the first response be; an empty list?  but at would error on line 48
03:49:00 <jle`> Nik05: Alternative and MonadPlus represent similar concepts (a monoid over applicative/monad objects with certain laws), but one is for Applicative and one is for Monad
03:49:12 <jle`> ...do you know about Applicative?
03:49:31 <ski> Nik05 : `Alternative' is for `Applicative', `MonadPlus' for `Monad' -- the short version
03:49:34 <Nik05> yes, but arent they going to make a Monad Applicative in the new ghc?
03:49:49 <jle`> Nik05: they're going to make Applicative a superclass of Monad
03:49:58 <jle`> but...not sure what this has to do with your question, directly
03:50:17 <jle`> things might be different in 7.10, but we live in a 7.8 reality :)
03:50:17 <ski> probably that would enable making `MonadPlus' a superclass of `Alternative', then
03:50:18 <Nik05> yes sorry thats what i meant. So then what is the difference between Alternative and MonadPlus if Applicative is a superclass of Monad?
03:50:27 <jle`> what's the difference between pure and return?
03:50:35 <jle`> liftM and fmap?
03:50:39 <jle`> and liftA
03:50:42 <ski> (perhaps modulo some alternate `MonadPlus' proposal fuzziness)
03:50:53 <{AS}> Nik05: http://stackoverflow.com/questions/10167879/distinction-between-typeclasses-monadplus-alternative-and-monoid
03:51:00 <ski> `liftA' is the same as `fmap' (and `(<$>)')
03:51:18 <Nik05> yes so we can remove all that stuff in ghc 7.10?
03:51:34 <jle`> but you understand why we can't now, right?
03:51:35 <Nik05> MonadPlus can be removed, return, liftA those can all be made deprecated
03:51:44 <ski> for a monad, `liftM' ought to be equal to `fmap'
03:52:07 <Nik05> oke you cant remove those, but can the be made deprecated?
03:52:29 <jle`> it looks like you understand the difference, then
03:52:35 <jle`> in practical terms
03:52:36 <ski> well, `fmap' has the same type as `(<$>)', but `liftA' is only for applicatives. but for them, they should be the same thing
03:52:42 <jle`> or did you mean semantic terms?
03:52:54 <jle`> like what does alternative "represent", and what does monadplus "represent"?
03:53:13 <{AS}> essentially the Alternative law empty <*> m = empty isn't strong enough to satisfy the MonadPlus law empty >>= f = empty
03:53:37 <{AS}> according to StackOverflow/ekmett
03:53:42 <ski> (so `instance Functor Blah where fmap = liftA' is a valid functor instance for `Blah', given an `Applicative' instance that doesn't use `fmap' -- similarly for functor instances of monads)
03:53:44 <quchen> There is no law like that for Alternative in the first place
03:53:52 <Nik05> jle` they represent the same?
03:54:38 <{AS}> quchen: I am just referring to the post
03:54:52 <jle`> Nik05: they occupy a similar space...though MonadPlus can represent/embody more concepts because it's a Monad, instead of Applicative
03:55:12 <Nik05> oh
03:55:23 <quchen> FWIW MonadPlus will be a subclass of Alternative with the AMP
03:55:31 <quchen> But I don't think the laws are going to be changed.
03:55:43 <jle`> the "practical" difference now is that if you want Alternative like behavior, but all you have is (Monad m) => ..., then you can't use (<|>), you can only use the ("equivalent") function mplus
03:55:50 <jle`> and you can't use empty, you can only use mzero
03:56:25 <jle`> and if your thinkg is only Applicative, you can only use (<|>) and empty; not the "equivalent" mplus and mzero
03:57:03 <jle`> for types that are both MonadPlus and Applicative, (<|>) "should" do the same as mplus and empty "should" do the same as mzero
03:57:13 <Nik05> oke
03:57:17 <jle`> except now there are more concepts associated with it
03:57:36 <jle`> for example, mzero >>= f = mzero is a commonly accepted MonadPlus law
03:57:42 <jle`> which can't really make sense for Alternative
03:58:20 <ski> @wiki MonadPlus reform proposal
03:58:20 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
03:58:23 <jle`> Alternative doesn't know anything about (>>=), so it can't even conceptualize a meaning behind what happens when you do (empty >>= f)...Alternative can't really "say anyhting" about how empty should behave under bind, because it doens't really know about bind
03:58:44 <jle`> so the "idea" of `empty` is a bit more "general" than the idea of mzero
03:59:01 <jle`> mzero embodies the concepts of empty, but also ideas about how it should behave when (>>=)'d to and stuff
03:59:41 <Nik05> right, so how will they implement this with making applicative a superclass of monad?
04:00:08 <ski> i think, with `Monad' and `Alternative' as subclasses of `Applicative', one could have `MonadPlus' as a common subclass of `Monad' and `Alternative', having zero new operations (but new laws)
04:00:30 <quchen> ski: That's the current status, yes
04:00:51 <quchen> MonadPlus will keep its functions though for compatibility
04:01:12 <quchen> But you will be able to write "instance Alternative a => MonadPlus a where" and be done with it
04:01:32 <quchen> Eh, and Monad of course
04:01:48 <Nik05> oke thank you
04:02:34 <ski> quchen : actually, you can skip the `where' in this case
04:03:54 <quchen> Good to know!
04:06:12 * hackagebot cgrep 6.4.4 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.4 (NicolaBonelli)
04:23:16 <bluebelle> Why are most Data.Vector function achieve different laziness with Data.List? Like V.zipWith (+) (V.fromList [0..]) vs give you infinite loop
04:24:10 <ski> vectors can't be infinite ?
04:25:28 <bluebelle> ski: it seems eagerly evaluate [0..]
04:26:17 <ski> yes
04:32:09 <ski> @type Data.List.mapAccumL
04:32:09 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
04:32:10 <ski> @type (runState .) . Data.Traversable.mapM . (state .)
04:32:11 <lambdabot> Traversable t => (a -> s -> (b, s)) -> t a -> s -> (t b, s)
04:32:38 <ski> bluebelle : i believe you could use something like the latter to keep a counter
04:33:01 <ski> @type (runState .) . (Data.Traversable.mapM :: (a -> State s b) -> (Data.Vector.Vector a -> State s (Data.Vector.Vector b))) . (state .)
04:33:01 <lambdabot> (a -> s -> (b, s)) -> Data.Vector.Vector a -> s -> (Data.Vector.Vector b, s)
04:38:47 <l0cust> So, has it become standard practice to just ignore the terms of the GPL?
04:38:48 <l0cust> I see so many BSD-licensed libraries using GPL-licensed libraries
04:39:29 <tuttlem> hi all
04:39:35 <l0cust> tuttlem: hi
04:40:03 <tuttlem> I've just been trying to link some haskell code with an assembly module that I've written and am really struggling.
04:40:41 <l0cust> tuttlem: I seem to be the only active person here, and that's not in my skill set. I suggest coming back in 5 hours, when the rest of the Americans wake up
04:40:54 <tuttlem> Admittedly, I thought I could write an operating system using Haskell, but it seems that jumping from assembly land into haskell land is a bit more indepth than what I thought!
04:41:02 <tuttlem> Ahh...
04:41:04 <tuttlem> cool
04:41:23 <tuttlem> Thanks anyway! I'll be back later . . . this stuff is really killing me!! :)
04:42:05 <Hodapp> l0cust: today is also July 4th, which means that in America-land, we're busy blowing shit up, drinking, barbecuing things, proclaiming America's superiority, and blowing shit up.
04:42:25 <l0cust> Hodapp: Oh, yeah, I forgot about that
04:42:44 <tuttlem> haha... "blowing shit up"
04:42:46 <tuttlem> love it
04:42:55 <l0cust> I love how "blowing shit up" is on the list twice
04:43:19 <Hodapp> with fireworks probably made in China.
04:43:19 <dv-> once for afganistan and once for iraq
04:43:20 <l0cust> Oh fuck, there's going to be a fucking parade in my neighborhood
04:43:28 <l0cust> dv-: jesus fuck
04:56:26 <kvanb> l0cust: there is no reason to talk like that in here
04:56:41 <l0cust> kvanb: There's always a good reason to curse
04:56:50 <l0cust> kvanb: What are you, some sort of commie?
04:57:19 <kvanb> do you go to work and swear like that?
04:57:25 <l0cust> kvanb: I do
04:57:29 <l0cust> kvanb: I own a company, thoug
04:57:33 <l0cust> kvanb: *though
04:57:34 <Hodapp> If I *don't* swear like that at work, people start to wonder if I'm ill or something.
04:57:39 <l0cust> kvanb: So I can get away with it
04:57:47 <l0cust> kvanb: What Hodapp said
04:57:54 <kvanb> unbelievable.
04:58:08 <Hodapp> I don't swear in front of new customers, of course.
04:58:10 <l0cust> kvanb: You mean un-fucking-believable
04:58:12 <Hodapp> or investors.
04:58:18 <quchen> This is not the place for random hillbilly 4th-of-July swearings, and neither for discussing whether this is alright. I suggest you take it elsewhere.
04:58:20 <Hodapp> until I've gotten to know them a bit better.
04:58:30 <l0cust> Hodapp: I'm not allowed to talk to investors for this reason exactly
04:58:31 <kvanb> Regardless, some people run this IRC at work even where people do see it.
04:58:39 <kvanb> You make everyone uncomfortable by using language like that.
04:58:45 <Hodapp> quchen: This is also really not the place for ethnic slurs like "random hillbilly".
04:58:54 <l0cust> quchen: what Hodapp said
04:59:16 <l0cust> Is this grade school? Are we seriously getting scolded for cursing?
04:59:35 <quchen> Tu quoque. This is offtopic. Stop it.
04:59:50 <l0cust> Hodapp: take our patriotism to #haskell-blah?
04:59:56 <Hodapp> l0cust: good luck with that one.
05:00:04 * ski isn't being made uncomfortable, but agrees that some other people are more sensitive. please do try to be a bit considerate
05:01:10 <nclarke> Concur. This isn't 'scolding', it's asking politely if this conversation could be brought to a stop, for the sake of people who might be running this in a more restrictive work environment or who find that sort of thing uncomfortable
05:01:57 <l0cust> nclarke: I would concur, but  calling people "random hillbilies" is a bit short of "asking politely"
05:02:05 <nclarke> I was asking politely :-)
05:02:09 <Hodapp> Next time, just call it off-topic, and leave out the ethnic slurs. They are a good deal more offensive than the f-bomb ever was.
05:02:47 <l0cust> Curious, in what sort of work environment is cursing frowned upon?
05:03:07 <Hodapp> this should probably just be taken to #haskell-blah.
05:03:09 <alpounet> strict ones.
05:03:22 <merijn> Cursing isn't banned in here, but off-topic long conversations like this one are frowned upon
05:03:26 <alpounet> but yeah, please take this to -blah guys
05:03:41 <quchen_> #haskell-blah is not a trash can either. I suggest a new channel.
05:04:53 <tuttlem> I tried before guys with not much luck - but do any of you guys have experiencing linking assmbly & haskell?
05:05:10 <tuttlem> Even a link on the topic would be great - not picky here! :)
05:12:59 <nclarke> tuttlem: I guess you could go via C in the middle, but apart from that I have no idea...
05:13:51 <tuttlem> nclarke: yeah, I've been trying my hardest with FFI - but there's just so many binary dependencies that GHC gives.
05:19:32 <merijn> tuttlem: Do you know how to link the same ASM into C code?
05:20:04 <merijn> tuttlem: Or, if you only have a handful of pieces you could just wrap the asm in C code and link that?
05:20:06 <tuttlem> merijn: yep, done it plenty before . . .
05:20:57 <merijn> tuttlem: GHC will link C shared libraries and object files just fine, so if you manage to turn the asm into a shared library or object file it should be "trivial"
05:21:11 <tuttlem> I'm trying to get a OS kernel up and running using Haskell, but the compilation requires a lot of dependencis that I don't have.
05:21:34 <tuttlem> When you're in context of an OS kernel, you don't have libraries.
05:21:41 <tuttlem> You either write them - or go without :)
05:21:48 <RchrdBrrll> tuttlem, I'd suggest looking at HaLVM as a starting point.
05:21:53 <merijn> tuttlem: I have some bad news for that
05:22:10 <merijn> tuttlem: You will most likely have to reimplement (most of) the GHC runtime system yourself
05:22:19 <tuttlem> Thank RchrdBrrll. I'll cehck it out.
05:22:39 <RchrdBrrll> tuttlem, https://github.com/GaloisInc/HaLVM or http://corp.galois.com/halvm
05:22:47 <tuttlem> merijn: yep. totally ready to wear that (or at least, re-implementing the parts I need) . . .
05:22:52 <merijn> tuttlem: The RTS uses all sorts of libraries and system calls
05:23:16 <merijn> tuttlem: You may wanna investigate: http://programatica.cs.pdx.edu/House/
05:23:20 <RchrdBrrll> IIRC, HaLVM is a project that lets you compile a Haskell program to a kernel that runs in ring 0 atop Xen.
05:23:26 <merijn> tuttlem: That's baremetal haskell
05:23:45 <rudi_s> Hi. I'm trying to compile a regex and catch the error. I'm using makeRegexM "*" :: Either String Regex, but that fails with *** Exception: (0,"nothing to repeat"). The reason seems to be the fail definition of the Either monad. Is there a way to overwrite/catch this exception?
05:23:50 <merijn> RchrdBrrll: I he wants to write an OS, House is probably better suited than HaLVM
05:23:57 <rudi_s> I'd prefer not to use Maybe, because I want to catch the error message.
05:23:58 <RchrdBrrll> I assume that the only reason they require Xen is that it was easier to implement against Xen's interfaces directly than to write device drivers for every physical piece of hardware on the planet?
05:24:09 <tuttlem> Awesome. Thanks for the suggestions guys. I'll check 'em out now.
05:26:15 <RchrdBrrll> Good luck and have fun!
05:26:38 <RchrdBrrll> merijn, depends on what kind of O
05:27:30 <RchrdBrrll> I mean yes, House is much more like a general purpose OS while HaLVM is more or less just a way to write programs in Haskell that run directly on Xen.
05:37:34 <l0cust> Hey, so question about warp
05:37:39 <l0cust> ack not warp
05:37:42 <l0cust> cabal
05:37:53 <l0cust> I want to specify a build flag for a dependency of my package
05:37:57 <l0cust> in the build-depends field
05:38:01 <l0cust> How do I go about doing so?
05:39:01 <l0cust> My current scheme doesn't work - http://lpaste.net/106919
05:41:30 <bergmark> l0cust: i don't think flags are meant to be used that way, what if two packages depend on the opposite flag value?
05:41:38 <l0cust> hm
05:42:41 <zaquest> @pl \s -> drop (div (length s) 2) s
05:42:41 <lambdabot> drop =<< flip div 2 . length
05:46:08 <senft> I this code http://lpaste.net/2623131480527732736 how can I match the case where the interp call returns Nothing?
05:46:13 <senft> *in this code
05:46:51 <l0cust> senft: use a case statement
05:51:55 <bjornars> senft: or use do-syntax (in the maybe monad). requires some more understanding tho
05:52:24 <senft> bjornars: alright thanks. I'll have a look at the two
06:01:32 <Arnob> Hi all... I have an architecture question for you
06:02:03 <Arnob> I am trying to build an app, that scrapes a web page and saves the data as "structured data" into a database/datastore
06:02:54 <Arnob> for example, let's say this app scans medical journals, and extracts the nam, title, author, journal, abstract and contents, and saves it to a database
06:03:42 <Arnob> now I need to do complicated entity disambiguation, so J. Smith and Jon Smith resolves to the same author, if they usually publish to the same journal
06:04:21 <Arnob> I am not sure if 1. The scraper should talk to the data store directly and do the disambiguation
06:04:48 <Arnob> 2. or of there should be a middle layer that talks to the database and performs disambiguation
06:14:09 <arj> does it make sense to impose type restrictions on member functions of a new type class definition, e.g. class Sizeable a where size :: (Num b) => a -> b  ?
06:14:18 <arj> or is this bad style somehow?
06:34:39 <Arnob> Hi arj I am a haskell beginner but... I believe that to out restrictions on the class definition itself can cause problems in the future
06:36:37 <Arnob> so for example if you make a class class called "fooable" which implements a member function "bar a->b", you wouldn't want to put a restriction of the type "bar a::Num a =>  a->b"
06:37:05 <Lutin`> That's not what he's doing
06:37:17 <Arnob> because then every data type a that implements foo will also have to be an instance of Num a
06:37:29 <Lutin`> He's imposing a restriction on the b
06:37:49 <Arnob> I thought it is better practice to put the restrictions on the instance defintions?
06:37:59 <Arnob> rather than when defining the class?
06:38:02 <Lutin`> It wouldn't be possible in this case
06:38:10 <Arnob> I am very new to this :-)
06:38:37 <arj> Lutin`: so my restricition should be fine?
06:39:17 <Lutin`> arj: Should be fine, but remember you're saying size must be able to provide any b such that b is an instance of Num
06:39:33 <Lutin`> So you'd probably use the fromInteger function of the Num typeclass to get that
06:39:48 <arj> Anything wrong with that I can'
06:39:52 <arj> 't see at the moment?
06:40:13 <Lutin`> Eh it just means some repetition in the instance definitions
06:41:08 <Lutin`> Since size would typically be something along the lines of size = fromInteger . f where f :: a -> Integer
06:42:15 <Lutin`> It might be better to just go ahead and make size :: a -> Integer
06:42:30 <Lutin`> depends on how you expect someone to use the class
06:44:34 <Lutin`> You might even want to restrict it to an unsigned type
06:44:42 <Lutin`> since negative sizes don't really make sense
06:45:40 <Lutin`> You could use something like Word
06:46:01 <donri> > 255 + 1 :: Word8
06:46:02 <lambdabot>  0
06:46:40 <Lutin`> I didn't say Word8 :)
06:47:03 <donri> > maxBound + 1 :: Word
06:47:04 <lambdabot>  0
06:47:55 <Lutin`> I guess a type UInteger would be nice
06:48:21 <c_wraith> how would that differ from Word?
06:48:37 <Lutin`> You could have 2^64
06:48:52 <c_wraith> > maxBound :: Word64
06:48:53 <lambdabot>  18446744073709551615
06:49:03 <bennofs> > 2^64-1
06:49:04 <lambdabot>  18446744073709551615
06:49:04 <c_wraith> Oh, I see.  You mean unbounded
06:49:31 <Lutin`> anYeah
06:49:34 <c_wraith> Integer, not Int.  Got it.
06:49:56 <c_wraith> clearly, it should be called Wordeger
06:49:57 <Lutin`> Or maybe Natural
06:51:28 * hackagebot twitter-conduit 0.0.5.1 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.5.1 (TakahiroHimura)
07:09:41 <_0xAX> Hello All,
07:10:00 <_0xAX> How to upgrade cabal from 1.16.0.2 to 1.18.x.x?
07:10:17 <_0xAX> I tried cabal install cabal-install but after installing caba --version returns 1.16.0.2 anyway
07:13:15 <rwbarton> find where the new 'cabal' executable got installed (probably ~/.cabal/bin) and make sure it is in a directory on your path before the old one
07:14:06 <rwbarton> and if it is you might need 'hash -r' (assuming bash) to get bash to look for it
07:18:14 <donri> doesn't recent cabal-install warn about this issue
07:19:45 <danilo2> Hello! Is there in haskell something like set on types - for example - a type TS would be set over types T1, T2 and would be equal to type constructed as set of T2, T1 but distinct from type constructred on T1, T2, T3 ?
07:19:46 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
07:19:46 <phaskell> T3: Move wiki mysql to mysql01 - https://phabricator.haskell.org/T3
07:19:46 <phaskell> T2: Move wiki to rackspace vm - https://phabricator.haskell.org/T2
07:20:20 <donri> structural typing?
07:20:58 <edwardk_> johnw: you don't. that was part of the trade-off of making the types comprehensible while i made everything else more complex
07:22:42 <_0xAX> rwbarton: thank you, it hlped
07:22:46 <nclarke> danilo2: One can build a list of types, and construct code which works independently of ordering, I think
07:24:20 <danilo2> nclarke: I know, i just did it - I just started to asking myself if can we go better :)
07:24:26 <danilo2> *ask
07:38:10 <linman> hi, i'm having difficulties installing a package. "Missing dependencies on foreign libraries"
07:38:24 <linman> does anyone know what that means?
07:39:46 <phi__> linman: it means there is some library (not written in haskell) which is required by the package but is not installed on your system
07:40:15 <Lutin`> It should say the exact library that's missing
07:40:18 <Lutin`> what are you installing/
07:40:35 <linman> Missing C libraries: blas, lapack
07:40:37 <senft> Hey, I have this simple interpreter http://lpaste.net/5181791670831677440. In the one testcase at the bottom, that is not commented out, the interpeter fails with the Exception given at the end of the paste. I don't really understand what I am doing wrong here. Can anyone give me a hint?
07:40:49 <Lutin`> linman: What OS are you on?
07:40:53 <linman> ubuntu
07:40:58 <linman> 14.04
07:41:45 <Lutin`> You can install them through apt-get
07:41:49 <Lutin`> Find them through apt-cache
07:42:03 <Lutin`> Or use Synaptic
07:42:30 <rwbarton> usually they have names resembling libblas-dev etc.
07:43:14 <linman> libblas-dev worked
07:43:19 <linman> in apt-get
07:43:59 <Lutin`> should be liblapack-dev too
07:44:06 <linman> yup, it is
07:44:14 <linman> thanks
07:44:53 <Lutin`> np
07:45:22 <RchrdBrrll> linman, incidentally, there are about 3 or 4 different implementations of BLAS and 2 or 3 different implementations of LAPACK in ubuntu's repos.
07:46:21 <_0xAX> Is asn1-encoding compatible with ghc-7.8.2? I tried to cabal install asn1-encoding and got:https://gist.github.com/0xAX/8c0d032944a2ecd99ff1
07:46:23 <linman> that seems odd. is  that typical w/ libraries?
07:46:33 * hackagebot uuagc 0.9.51 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.51 (JeroenBransen)
07:48:59 <rwbarton> _0xAX: I would guess that these other libraries (text mtl transformers) are broken because you used old cabal to install them on ghc 7.8
07:49:15 <rwbarton> _0xAX: it's a bit of an annoying chicken-and-egg problem because they were probably installed as dependencies of newer cabal
07:49:39 <rwbarton> _0xAX: however now that you have new cabal, you can remove these libraries and then everything should go fine
07:49:56 <_0xAX> rwbarton: thanks again, will try now
07:50:03 <rwbarton> in fact maybe you can just "cabal install --reinstall" them
07:52:45 <_0xAX> rwbarton: the same with cabal install --reinstall
07:53:28 <_0xAX> rwbarton: where to remove this packages? In ~/.cabal/... or somewhere in sandbox?
07:56:19 <linman> what is this? "Could not find module ... It is a member of the hidden package..."
07:58:14 <bergmark> linman: you need to add a package to build-depends
07:58:26 <bergmark> (if this is a cabal error)
07:58:39 <extraplanetary> linman: or, if you've previously run 'ghc-pkg hide', 'ghc-pkg unhide'
07:58:47 <linman> "Perhaps ... add ... in your .cabal file"
07:58:56 <rwbarton> _0xAX: well, it looks like you are installing things as root, so wherever that installs them... "ghc-pkg list" will tell you
07:59:23 <linman> have not run hide/unhide
07:59:27 <rwbarton> I guess you can "sudo ghc-pkg unregister" them
07:59:43 <linman> add package to build dependency?
08:00:32 <rwbarton> linman, what were you trying to do when you got this error?
08:00:46 <linman> trying to reload module
08:01:16 <linman> *reload Main.hs
08:01:42 <rwbarton> can you just paste the whole session here: http://lpaste.net/new/
08:01:56 <rwbarton> otherwise we are just guessing
08:04:08 <linman> http://pastebin.com/z4DbNy0v
08:04:27 <_wai_o_wai_> Hello I have a question about preprocessor commmands when building and installing cabal packages!
08:05:38 <rwbarton> linman, are you using sandboxes? how did you invoke ghci? what does "ghc-pkg list vector" say?
08:05:40 <ffxx> Hi guys ... have a few questions. What are the features you'd wish in a IDE for haskell ?
08:05:45 <_wai_o_wai_> does anyone have any experience with this sort of thing (cpp and cabal)?
08:05:46 <extraplanetary> _wai_o_wai_: please do ask it
08:05:47 <ffxx> top 5
08:06:24 <ffxx> or your just happy with emacs ?
08:06:35 * hackagebot snaplet-fay 0.3.3.7 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.3.7 (AdamBergmark)
08:06:51 <Lutin`> I think most people use emacs
08:07:07 <arossouw> any hints on how to operate with parser , parsec data with io?
08:07:07 <linman> yes using sandboxes. invoked with C-c C-l.
08:07:20 <arossouw> http://lpaste.net/106923
08:07:24 <linman> /var/lib/ghc/package.conf.d:
08:07:24 <linman>     vector-0.10.0.1
08:07:34 <ffxx> yea me too ... just wondering what whoud be the top 5 IF you'd change to an IDE
08:07:49 <linman> then: /home/name/.ghc/linux/package.conf.d
08:07:55 <rwbarton> ok
08:07:58 <Lutin`> emacs is my IDE
08:08:11 <Lutin`> I would've said Leksah but it looks like it's died
08:08:13 <rwbarton> well I don't know what you have C-c C-l configured to do exactly :)
08:08:13 <_wai_o_wai_> So I;m trying to install wai-session, but cabal does not seem to recognize the #if MIN_VERSION_wai(2,0,0) in the wai-session package. My .cabal file specifies that the min version of wai > 3.0, but when I try to install wai-session the build fails because it tries an import statement inside an #if MIN_VERSION_wai(2,0,0)
08:08:21 <rwbarton> it looks like vector isn't hidden
08:08:29 <ffxx> I tried Leksah didn't like it
08:08:29 <rwbarton> or it would be in parentheses
08:08:31 <ffxx> emacs better
08:08:37 <rwbarton> but, if you are actually running "cabal repl", maybe that hides the package
08:08:40 <Lutin`> linman: What's the actual error
08:08:49 <rwbarton> it's in the paste
08:08:54 <Lutin`> ah
08:08:55 <arossouw> i tried leksah, but for me its not user friendly , hehe
08:09:02 <linman> Failed, modules loaded: Main.
08:09:23 <linman> let me see what C-c C-l does..
08:09:30 <rwbarton> actually I really should have asked whether you're using cabal repl
08:09:38 <ffxx> linman .. hehe
08:09:41 <rwbarton> if so then you need to add vector as a build-depends in your .cabal file like it says
08:09:46 <rwbarton> otherwise I have no idea what's going on!
08:09:50 <extraplanetary> _wai_o_wai_: oh, that sounds familiar. I saw a package breaking because MIN_VERSION_bytestring wasn't defined the other day, let me see if I can find that bug
08:11:35 <linman> so it must be using cabal repl?  this is how i setup my emacs
08:11:35 <rwbarton> "#if MIN_VERSION_wai(2,0,0)" means "if we are building against a version of wai that's >= 2.0.0"
08:11:36 <linman> http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html
08:11:58 <extraplanetary> oh. Never mind. rwbarton has it
08:12:15 <linman> it talks about using CTRL-c CTRL-l . probably cabal repl.
08:12:16 <rwbarton> so it should be true
08:12:27 <linman> so i'll try adding it to .cabal..
08:12:35 <rwbarton> linman, by default it is ghci, but there is a lot of stuff on that page, who knows :)
08:13:58 <_wai_o_wai_> oh, whoops. Thank you! rwbarton++
08:14:28 <linman> what should be .cabal name in sandbox?
08:14:33 <_wai_o_wai_> i mean preflex: rwbarton++
08:14:43 <linman> <project>.cabal?
08:15:17 <_wai_o_wai_> preflex: rwbarton++
08:15:21 <rwbarton> linman: hmm, now I'm confused
08:15:23 <extraplanetary> linman: in your project's directory, run 'cabal init' and it'll generate one for you
08:15:28 <rwbarton> you don't have a .cabal file already?
08:15:42 <rwbarton> can you just try from the console? run ghci or cabal repl and see what gives the answer
08:15:45 <rwbarton> *error
08:16:28 <maybefbi> how can i plot inside a csv-conduit which changes as new rows are read?
08:16:29 <linman> wait, yeah there is one. i overlooked it haha
08:16:44 <rwbarton> ok
08:16:50 <linman> i also just tried taht. but there was different error.
08:16:58 <linman> no package found providing ...
08:17:13 <rwbarton> with ghci?
08:17:20 <rwbarton> I guess because ghci doesn't know about your sandbox by default
08:18:35 <mzero> Doesn't.  Cabal repl   start ghci with the right stuff ?
08:18:58 <_0xAX> rwbarton: all problem solved, thank you very much
08:19:02 <rwbarton> yes, except the .cabal file was wrong
08:20:13 <linman> rwbarton: i think i got past it, but need  more packages
08:20:42 <linman> rwbarton: i'm not sure if there was .cabal. i did a cabal init, which put it there before i checked
08:21:34 <peterhil> Hi! I'm trying to get the code from http://cs-www.cs.yale.edu/c2/images/uploads/AudioProc-TR.pdf to work. So far I got this code http://lpaste.net/106925 and the problem is about ambiguous types resulting from the functional dependency in the type of Clock.
08:21:44 <peterhil> What I'm doing wrong?
08:23:09 <peterhil> Is the FlexibleContexts language extension needed?
08:23:51 <rwbarton> can you include the error message?
08:24:54 <jg_> hi all, i don't understand why i can transform the following line to point free style "updates a d = (sumCountUpdates (rollsToArmyUpdates (matchRolls a d)))" into "updates = sumCountUpdates . rollsToArmyUpdates . matchRolls"
08:25:02 <jg_> *can't
08:25:31 <peterhil> rwbarton: Added the errors as an annotation on the paste at http://lpaste.net/106925
08:25:48 <arossouw> do you have to create impure functions for parsec parsers when doing io?
08:26:45 <jkarni> jg: the rightmost function takes two arguments - would work if it took only one
08:26:47 <extraplanetary> jg_: because (f . g) :: a -> c, where f :: b -> c and g :: a -> b. If g :: a1 -> a2 -> b, then f :: (a2 -> b) -> c, which is not the type you wanted
08:26:49 <rwbarton> peterhil, oh. the 'p' on line 78 is not the same as the 'p' on line 73
08:26:54 <jkarni> @type (.)
08:26:55 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:27:18 <jkarni> @type (.) .
08:27:18 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
08:27:41 <jkarni> @type ((.) .)
08:27:42 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
08:28:07 <rwbarton> peterhil: I wonder why the book thinks it is. in GHC, in order to write this, use {-# LANGUAGE ScopedTypeVariables #-} and change the type signature to sine :: forall p. (Clock p Int) => Double -> SF p a Sample
08:30:13 <peterhil> rwbarton: Ok, thanks. Now I get "audioproc.hs:74:52: Not in scope: type variable `a'"
08:30:24 <jg_> extraplanetary: thanks!
08:31:18 <peterhil> rwbarton: There were small mistake in the type for the Arrow instance SF also, in the return type I had to change the b to c.
08:31:42 <MP2E> don't you just love incorrect examples in books :V
08:32:00 <MP2E> at least they make for a fun practical excercise, fixing them I mean
08:32:06 <peterhil> Yep... And LaTeX making code "typographically correct" :-)
08:39:12 <int3___> so I have a design problem... I am writing a Scrabble AI, and I am calculating a bunch of values per square in the game grid, which is stored as a Map with (Int, Int) keys. I'm trying to write it comonad-style so I can chain these grid computations together. For the most part this works, but since the game grid is sparse, I would like to have a 'default' value that is never stored. E.g. if there are no possible moves originating from a squar
08:39:13 <int3___> e, we should not need to store `[]` in that position. As long as we are storing Monoids in the grid, we can return `mempty` for the default value. However, Comonads are supposed to be able to contain any type, not just Monoids... is there some other structure that encompasses what I'm doing, or should I just not try and shoehorn my problem into the Comonad typeclass?
08:39:21 <hexagoxel_> peterhil: forall p a . [...]
08:41:18 <jmcarthur> int3___: you could instead change your data structure so that those "empty" nodes simply don't exist
08:41:32 <int3___> jmcarthur: then the grid wouldn't be sparse any more, right
08:41:46 <jmcarthur> well, i don't exactly understand the data structure
08:41:55 <jmcarthur> is the the game board or the game tree?
08:41:59 <jmcarthur> *is this
08:42:01 <int3___> game board
08:42:03 <jmcarthur> ah
08:42:21 <jmcarthur> i suppose i would just decompose the optionality from the board itself
08:42:37 <jmcarthur> the board contains 'a's and you might sometimes instantiate that with a Maybe
08:43:12 <jmcarthur> i actually don't think the comonadic interface sounds that useful here
08:43:30 <jmcarthur> it would make more sense if this was a simulation where each cell will be updated on every turn
08:43:38 <jmcarthur> but actually each turn only updates a subset of cells
08:47:22 <peterhil> hexagoxel: Thanks, I was about to try that... :-)
08:48:41 <hexagoxel> peterhil: btw you are aware that you can download the source of the euterpea project? it contains some of the signal definitions you have there
08:49:18 <hexagoxel> only annoyance is that it is only ghc 7.6.3, not 7.8.2 (yet)
08:49:46 <peterhil> hexagoxel: Yes, I took a quick glance of the source of Euterpea, and noticed some functions seemed very familiar
08:49:58 <peterhil> Maybe I have to take closer look at that.
08:50:03 <int3___> jmcarthur: I think I'm doing something similar to that... e.g. each Scrabble tile 'constrains' the squares around it because only certain tiles can be placed there to form a valid word. These constraints are technically updated every turn, but in practice only those around the squares of the last played move really need to be recomputed
08:52:01 <int3___> jmcarthur: I was thinking of instantiating the Board with a Maybe type as well, but then I wouldn't be able to tell `extend f` to not store the output of f if it matches some default, since it would not be aware that the output type of `f` has a default
08:52:58 <jmcarthur> int3___: indeed. however, i can't even think of a case that one would use extend for this anyway
08:54:09 <jmcarthur> int3___: and it sounds like this is just fundamentally not comonadic, if you want that optimization, since it means there is a possibility that extract can't return a value to you at all
08:54:17 <int3___> jmcarthur: when calculating constraints for a given square, I look at the surrounding squares, then produce a 'Constraint' result for the given square. `extend` would replicate this for every square in the board
08:54:33 <int3___> yeah... I guess Comonad might just not be the right thing here
08:54:43 <int3___> unless I was working with an infinite board or something
08:55:05 <jmcarthur> even then
08:55:20 <jmcarthur> if all values could be Nothing, extract would need some way to return Nothing
08:55:37 <int3___> mm yeah
08:55:38 <jmcarthur> not even all value. if *any* values could be Nothing
09:31:09 <dspies> hi, what are Incoherent Instances?
09:31:10 <Javran> I have a weird problem: "cabal install network" says I've installed the requested package, but I cannot import Network from neither ghci nor ghc. any idea?
09:31:15 <dspies> This page isn't much use: https://ghc.haskell.org/trac/haskell-prime/wiki/IncoherentInstances
09:31:50 <coppro> https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/type-class-extensions.html#instance-overlap
09:32:48 <EvanR> reading some ghc documentation, what do you think/know "overloaded type" is referring to
09:32:58 <geekosaur> Javran, I'd guess you have multiple ghc versions installed
09:34:37 <dspies> Is there something like OverlappingInstances that still compiles with an error if more than one "context-dependent" instance matches
09:34:42 <EvanR> a -> a is a "non overloaded type" and Ord a => a -> a is an "overloaded type" ?
09:35:02 <EvanR> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html
09:36:17 <c_wraith> :t mapMaybe
09:36:18 <lambdabot> (a -> Maybe b) -> [a] -> [b]
09:36:18 <Javran> geekosaur: I just nuked ~/.cabal and then everything goes fine :)
09:36:48 <c_wraith> Hmm.  I want more of a zipMaybe.
09:37:43 <c_wraith> zipMaybe :: (a -> b -> Maybe c) -> [a] -> [b] -> [c]...  I guess that could be done with zip, mapMaybe and curry/uncurry
09:38:10 <c_wraith> ...  Or zipWith and catMaybes
09:46:16 <dspies> How can I add a context to a type instance
09:46:19 <dspies> ?
09:48:02 <dspies> ,ping
09:50:06 <mmmm> What's the package called which defines functions like (.::) (:::.) and so on
09:50:12 <dspies> It seems either I can add a context (by putting it in a class) or put a restriction (by leaving it outside the class), but I can't do both
09:51:56 <dspies> mmmm: http://hackage.haskell.org/package/composition-1.0.1.0/docs/Data-Composition.html
09:55:51 <haasn> mmmm: pointless-fun maybe
10:00:31 <mmmm> dspies: The first one was it thanks
10:06:19 <dspies> mmmm: I usually also like to add (.-.) = flip . ((.) .) (infixr 8) and (.--.) = flip . ((.-.) .) (infixr 7)
10:06:34 <dspies> f .-. g means apply g to the second argument of f
10:06:49 <dspies> and f.--. g means apply g to the third argument of f
10:06:53 <dspies> so I could say
10:08:25 <dspies> mmmm: So I could say something like composed = (fun1 .: fun2 . f .-. g)
10:08:42 <dspies> and then composed x y = fun1 (fun2 (f x) (g y))
10:08:57 <ion> cringe
10:18:24 <dspies> > take 5 [1..]
10:18:25 <lambdabot>  [1,2,3,4,5]
10:18:31 <dspies> > [1..]
10:18:33 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
10:22:43 <rudi_s> Hi. I'm trying to compile a regex and catch the error. I'm using makeRegexM "*" :: Either String Regex, but that fails with *** Exception: (0,"nothing to repeat"). The reason seems to be the fail definition of the Either monad. Is there a way to overwrite/catch this exception? I'd prefer not to use Maybe, because I want to catch the error message.
10:25:01 <rwbarton> I think there is an (Either String)-like monad with fail = Left somewhere in standard libraries
10:25:05 <rwbarton> if not, you can always write one yourself
10:25:41 <EvanR> the errors package
10:33:46 <rudi_s> rwbarton: Where should I start looking for this monad? I didn't find anything similar.
10:36:28 <Guest51763> Hey all. I'm trying to use a random number generator, and I keep reading that one can set a "global generator" for IO. How does that work? If you have multiple IO functions, do they all use the same generator? How in God's name does that fit in with the rest of Haskell?
10:38:02 <geekosaur> :t getStdGen
10:38:03 <lambdabot> IO StdGen
10:38:24 <geekosaur> ^ then you use a state monad or etc. to propagate through pure code
10:38:59 <rwbarton> rudi_s: hmm, well transformer's Control.Monad.Trans.Error ErrorT is one, but it is deprecated
10:39:01 <jmcarthur> Guest51763: all IO actions that are actually executed must have been connected to each other in some way. there are no secrets :)
10:39:03 <rwbarton> with no replacement
10:39:27 <Guest51763> geekosaur: Can you give me a link to read a bigger explanation of what you just said?
10:39:49 <jmcarthur> oh i thought you were talking about randomIO or something
10:42:24 <Guest51763> jmcarthur: Does that mean that if you call an IO function from, say, main, the generator you made in main is passed to the function you call?
10:43:15 <rudi_s> rwbarton: Hm, is there a non deprecated way (if possible understandable by a haskell-newbie)?
10:43:27 <rwbarton> well, you can just write it yourself
10:44:11 <geekosaur> Guest51763, I don't know if there's a good simple description of how the random stuff in base works. http://hackage.haskell.org/package/MonadRandom is often used in practice since System.Random doesn't help you with passing random state around
10:44:13 <rudi_s> rwbarton: Ok. I guess I have to copy the rest of the instance definition?
10:44:41 <rwbarton> yep, good monad exercise :)
10:44:45 <Guest51763> geekosaur: That's what I'm looking for. Thanks a lot!
10:44:51 <rwbarton> it seems to be trendy to make 'fail' useless nowadays
10:45:20 <rudi_s> rwbarton: ;-) Thanks.
10:45:26 <geekosaur> http://lambda.haskell.org/platform/doc/current/packages/random-1.0.1.1/doc/html/System-Random.html is the equivalent page for the base random stuff
10:58:29 <jtakacs> how can I print out all of the command line arguments?
10:59:08 <ion> print =<< getArgs
10:59:17 <jtakacs> getArgs >>= putStrLn or something like this?
10:59:45 <ion> Can you figure out why getArgs >>= putStrLn does not work? Hint: look at the types
11:02:01 <jtakacs> because i have to unpack the [String]  from the IO action?
11:02:43 <haasn> That's not it
11:02:51 <haasn> Also, you can't “unpack” something from an IO action
11:02:55 <haasn> IO is not a container, etc.
11:03:09 <ion> You’ll have to iterate over the [String] because putStrLn wants a String.
11:03:21 <ion> @type mapM_
11:03:22 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
11:03:36 <haasn> :t unlines
11:03:37 <lambdabot> [String] -> String
11:03:41 <ion> or that
11:03:51 <ion> which also iterates over the [String]
11:03:54 <haasn> mapM_ with I/O is something I consider an anti-pattern
11:04:28 <haasn> in particular mapM_ putStrLn is orders of magnitude slower than putStrLn . unlines
11:04:28 <rwbarton> what?!
11:04:58 <haasn> Okay, maybe not in general; but in these kinds of situations
11:05:27 <Lutin`> Or just use print
11:05:32 <Lutin`> :t print
11:05:33 <lambdabot> Show a => a -> IO ()
11:06:05 <chrisdone> sup homies
11:06:20 <chrisdone> homomorphismies
11:06:26 <jtakacs> ok, what if I want to iterate over the arguments, and display a counter before every line?
11:06:42 <ion> @type zipWith
11:06:43 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
11:07:06 <chrisdone> forM_  (zip [0..] xs) (\(i,x) -> do print i; putStrLn x)
11:08:00 <jtakacs> thanks
11:08:07 <haasn> putStr $ zipWith (\i s -> show i ++ ": " ++ s) [0..] strings -- how I'd do it
11:08:12 <chrisdone> mapM_ with IO makes sense for performance
11:08:39 <chrisdone> if you have a million lines to print, concating them all together is a waste of time just to have the appearance of 'functionaly'
11:09:07 <ion> chrisdone: Please see: laziness
11:09:21 <ion> also potentially: list fusion
11:10:15 <chrisdone> ion: laziness doesn't reduce the number of appending operations
11:10:43 <ion> chrisdone: But may reduce the number of IO actions
11:10:45 <chrisdone> although a Builder would
11:10:49 <haasn> I just tried it on 10 million lines; mapM_ print [0..10000000] takes about twice as long as putStr . unlines $ map show [0..10000000] on my machine
11:10:59 <rwbarton> same here
11:11:10 <haasn> I/O syscalls are slow
11:11:13 <haasn> very slow
11:11:39 <haasn> avoiding them as much as possible is the key to performance, see: all the work that went into making warp faster than nginx
11:11:50 * hackagebot purescript 0.5.2.6 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.2.6 (PhilFreeman)
11:12:00 <jtakacs> why are there so many ways to do something which could be done wit a for(..) loop in C?
11:12:02 <rwbarton> it does exactly the same number of syscalls
11:12:09 <haasn> (You can probably make things a lot faster than this, too; but it's still better to use the unlines . map show than mapM_ print)
11:12:16 <rwbarton> but, I guess that there is overhead in taking a mutex for the Handle etc.
11:12:23 <haasn> Hmm that might be possible
11:12:25 <chrisdone> haasn: what if the strings you're printing aren't less than 8 characters? e.g. something real
11:12:41 <rwbarton> they both write in 8096-size chunks
11:12:48 <rwbarton> at the syscall level
11:13:02 <chrisdone> rwbarton: due to buffering on the handle presumably?
11:13:12 <rwbarton> yeah
11:13:12 <ion> jtakacs: C has many ways to do something which could be done with a for loop.
11:13:23 <rwbarton> maybe there's room to improve how that buffering handles small writes
11:14:23 <hiptobecubic> jtakacs, why use for loops when you can just jmp or GOTO?
11:15:09 <jtakacs> for loops provide a better structure
11:15:17 <hiptobecubic> jtakacs, precisely
11:15:25 <napping> jtakacs: one goal of a lot of this stuff is modularity - it's a bit hard to switch a for loop doing direct writes over to managing blocking with epoll or such
11:15:38 <hiptobecubic> jtakacs, it just so happens that for loops are nowhere near the end of the road
11:16:10 <Nik05> jtakacs you can use do notation :P
11:16:39 <napping> jtakacs: also there probably is a bit of redundancy, some of these libraries and approaches are kind of newish and still working out the best interfaces/tradeoffs
11:16:44 <chrisdone> import Control.Monad
11:16:45 <chrisdone> strings = replicate 100000 (replicate 8096 'x')
11:16:45 <chrisdone> main = forM_ strings putStrLn
11:16:45 <chrisdone> main = (putStr . unlines) strings
11:16:57 <chrisdone> forM = 0m3.951s, unlines = 0m9.689s
11:16:59 <haasn> chrisdone: Good point; I changed it to (show n ++ replicate 1000 'a'), now the difference gets less small - about 10% faster for the putStr version
11:17:09 <haasn> (1 million iterations)
11:17:21 <chrisdone> @src unlines
11:17:21 <lambdabot> unlines = concatMap (++ "\n")
11:17:27 <napping> chrisdone: so isn't 8 characters kind of reasonable?
11:18:17 <napping> If you contemplate switching from putStrLn $ "strbit "++show x++" strbit"++show y to something like putSTr "strbit";print x;putStr "strbit";print y
11:18:19 <chrisdone> napping: i don't know. 8 characters just hides the overhead of concatenating a bunch of strings
11:18:37 <chrisdone> it's negligible in this case, but it exists. "laziness" doesn't just solve it
11:18:59 <jtakacs> what if I need to process a large binary file in 4096 byte chunks, what do I use?  recursion comes to my mind, but is there a better way?
11:19:00 <chrisdone> i think a Text builder would be much more efficient. let me try
11:19:24 <napping> I'm not advocating any individaul approach, just saying that 8 bytes sounds plausible for the fixed bits of output messages
11:19:25 <chrisdone> jtakacs: attoparsec would be good for that, it supports incremental parsing
11:19:44 <haasn> chrisdone: this makes me really curious about what it's like for mapM_ Text.putStrLn vs Text.Lazy.putStr . fromChunks -- or similar
11:19:57 <chrisdone> napping: sure. but when you talk about performance you tend to consider the general case, i.e. "how does this scale?", i think
11:20:11 <chrisdone> haasn: yeah, let me try a builder, sec
11:20:36 <napping> chrisdone: yeah, but I think there's a decent class of things, like log output or whatever, where "scaling" is printing more lines assembles from the equivalent of format strings with only modestly long fixed parts
11:21:12 <jtakacs> chrisdone: Deprecated: This module will be removed in the next major release.
11:21:25 <EvanR> for loops are a pretty bad way to structure a lot of things
11:21:30 <EvanR> just like goto
11:21:36 <chrisdone> text's replicate doesn't take a Char =(
11:21:43 <chrisdone> jtakacs: what module?
11:21:51 <jtakacs> Data.Attoparsec
11:22:36 <asrv> what is a universally qualified type?
11:23:13 <napping> asrv: something with a forall at the start (or free type variables, which are implicitly quantified)
11:23:18 <napping> forall a . (a -> a) from id, for example
11:23:26 <asrv> ah
11:23:28 <napping> or forall a b . (a -> b) -> [a] -> [b] from map
11:23:35 <EvanR> qualified or quantified?
11:23:36 <klugez> jtakacs: If you read the rest of the description: "This module is deprecated. Use Data.Attoparsec.ByteString instead."
11:23:52 <asrv> what the difference between qualified and quantified?
11:24:12 <EvanR> forall a . (a -> a) is a universally quaNTified type
11:24:15 <napping> well, forall and exists are called quantifiers
11:24:16 <jtakacs> yes, but are Data.Attoparsec and Data.Attoparsec.ByteString independent modules?
11:24:32 <napping> a few logics have rarer things
11:24:50 <napping> I'm not sure there's any fixed meaning of "qualified" from logic
11:25:00 <jtakacs> I mean, Data.Attoparsec.ByteString suggests it's inside the Data.Attoparsec module
11:25:07 <napping> but in Haskell that's probably like an eqxplicitly qualified
11:25:14 <chrisdone> hm, the builder beat unlines by only 500ms, however here's my implementation
11:25:24 <napping> like putting an explicit module or prefix on a type like Data.Map.Map
11:25:29 <chrisdone> http://lpaste.net/3889134844063514624
11:26:48 <haasn> chrisdone: Why not T.pack $ replicate 8096 'x' ?
11:26:55 <haasn> oh, it's lazy text
11:27:12 <haasn> s/T.pack/fromChunks . ST.pack/
11:27:26 <klugez> jtakacs: I think attoparsec used to work only with ByteStrings and it was located in Data.Attoparsec , but then it was extended to work with Text also and now there's both Data.Attoparsec.ByteString and Data.Attoparsec.Text.
11:27:27 <napping> jtakacs: related module names are usually from similar or related packages, but it's not that strict. You don't need to have a Data.Attoparsec to have a Data.Attoparsec.ByteString, and even if you have both importng one doesn't automatically import the other
11:27:59 <napping> jtakacs: Here's I would guess both are still/will be provided by the same attoparsec package, they just decided it would be better to rename the module to a more explicit name
11:28:49 <klugez> jtakacs: The old Data.Attoparsec just re-exports the Data.Attoparsec.ByteString for now, but will be removed soon and you should use the more explicit module depending on whether you are parsing ByteString or Text.
11:29:10 <chrisdone> haasn: i will add, though, that the forM approach is more often an optimization. i'll second that doing things purely and then printing at the end is better. i've had codebases ruined by the forM imperative style
11:29:40 <chrisdone> e.g. the haskell-docs program was written as a series of loops and prints and recursions
11:29:40 <napping> so the builder was at least as fast as forM? (that's what I would expect)
11:29:57 <chrisdone> napping: no, it was about as fast as the string concating
11:30:07 <chrisdone> oh wait, sorry
11:30:09 <chrisdone> yes
11:30:11 <chrisdone> real	0m3.319s
11:30:21 <napping> oh, that was what you specifically reported.
11:30:23 <chrisdone> i was confusing the two
11:30:50 <chrisdone> time ./forM_ > /dev/null
11:30:51 <chrisdone> real	0m0.410s
11:30:51 <chrisdone> time ./unlines > /dev/null
11:30:51 <chrisdone> real	0m9.689s
11:30:54 <chrisdone> time ./builder-flush > /dev/null
11:30:57 <chrisdone> real	0m3.319s
11:31:04 <chrisdone> \o/ go builder
11:31:28 <napping> 3.3s vs 0.4 for forM_?
11:31:57 <chrisdone> yeah, beats forM_. sweet
11:32:06 <chrisdone> http://lpaste.net/5858105052647915520
11:32:07 <chrisdone> and http://lpaste.net/3889134844063514624
11:32:09 <chrisdone> if you want to try yourself
11:32:11 <napping> uh, the order you pasted that forM takes 0.4s
11:32:18 <napping> and builder-flush takes 3.32s
11:32:24 <napping> about 10x as long
11:32:25 <chrisdone> oh damn. i'm blind
11:32:31 * chrisdone changes colour themes
11:32:56 <chrisdone> i gotta go pickup mgsloan, bbl =p
11:41:28 <dmwit> Quick straw poll: if I move an orphan instance next to the data declaration it's associated with (but stay within the same package), what would you expect to happen to the version number of the package?
11:45:16 <benzrf> dmwit: imo follow pvp literally
11:45:23 <benzrf> is this a backwards incompatible change?
11:45:26 <benzrf> theoreticall
11:45:27 <benzrf> y?
11:45:42 <benzrf> could somebody upgrade and have sudden errors?
11:45:50 <benzrf> if so, bump the secondary major numberten
11:45:54 <benzrf> *number
11:46:19 <dmwit> okay
11:46:25 <dmwit> well
11:46:31 <dmwit> That's not *quite* what the PVP says.
11:46:34 <dmwit> But it's probably prudent anyway.
11:46:34 <benzrf> oh?
11:46:36 <benzrf> ok mb
11:46:52 <benzrf> hmmmm i suppose just adding a name to a module could theoretically be backwards incompat
11:46:53 * hackagebot aur 0.2.0 - Access metadata from the Arch Linux User Repository.  http://hackage.haskell.org/package/aur-0.2.0 (fosskers)
11:46:57 <benzrf> if it ends up causing a clash
11:46:59 <dmwit> exactly
11:47:02 <benzrf> :L
11:47:15 <benzrf> what is the precise nature of pvp, then?
11:47:22 <dmwit> Every change is backwards incompatible for some suitably strict definition of backwards incompatible. ;-)
11:47:42 <dmwit> I think PVP is about "if you import everything with explicit import lists, it will still work" for minor version bumps.
11:47:57 <rwbarton> http://xkcd.com/1172/
11:48:03 <dmwit> and "only behavior changes" for patch-level bumps
11:48:03 <benzrf> dmwit: a
11:48:04 <benzrf> *ah
11:48:22 <benzrf> dmwit: adding a new module is not backwards incompatible in any scenario i can think of
11:48:32 <benzrf> maybe if you are traversing the package contents
11:48:38 <benzrf> but that's not the use case that the number covers
11:48:54 <benzrf> dmwit: still major then
11:48:56 <dmwit> benzrf: You add a module that another package also defines. BAM
11:49:02 <benzrf> dmwit: what?
11:49:05 <benzrf> oh
11:49:09 <benzrf> :P
11:49:14 <dmwit> yeah =)
11:51:29 <l0cust> Opinion question
11:51:35 <l0cust> I'm writing a web app
11:51:42 <l0cust> What CSS framework should I use
11:51:54 <l0cust> (As for Haskell frameworks, I'm already decided on Warp)
11:51:55 <benzrf> l0cust: which ever one looks nice
11:52:03 <l0cust> benzrf: That's the thing
11:52:09 <benzrf> or none at all, yknow
11:52:17 <l0cust> benzrf: I've used Bootstrap forever
11:52:26 <l0cust> benzrf: Foundation benchmarks a little bit better
11:52:31 <l0cust> benzrf: and looks nicer imho
11:52:41 <l0cust> benzrf: however, I'd have to spend a weekend learning it
11:53:01 <l0cust> benzrf: skeleton is probably the fastest
11:53:07 <l0cust> benzrf: but it isn't as well supported
11:53:15 <l0cust> benzrf: last release was June 2012
11:53:24 <l0cust> benzrf: Was html5 even around in 2012?
11:53:39 <l0cust> okay, sort of answered my own question
11:53:41 <l0cust> foundation it is
11:53:51 <monochrom> I handwrite my own CSS. it is also minimal. for example, it does not inflict fonts on you apart from occasional "sans-serif" and "monospace".
11:54:04 <l0cust> monochrom: I don't have time to write my own CSS :(
11:54:10 <l0cust> monochrom: Also, I suck at CSS
11:54:31 <monochrom> minimal takes little time
11:54:48 <l0cust> monochrom: This has to look nice, though, and I have no taste.
11:54:49 <benzrf> css is ez
11:54:59 <benzrf> l0cust: then make somebody else design it
11:55:01 <monochrom> minimal looks the nicest.
11:55:32 <dmwit> monochrom: I have to say I don't think a company would hire you as a web-dev based on what I remember of your CSS. =P
11:56:05 <l0cust> monochrom: I personally agree. However, I would need to develop a responsive grid system
11:56:06 <benzrf> >tfw the machines talk wasnt recorded
11:56:09 <benzrf> curse you runar
11:56:11 <monochrom> I agree. Yet, their commercial designs are both bloat and nasty, my designs are thrift and nice.
11:56:21 <Apocalisp> benzrf: Whaaa?
11:57:08 <benzrf> Apocalisp: https://dl.dropbox.com/u/4588997/Machines.pdf <- the talk that went with this is lost to time
11:57:29 <Apocalisp> benzrf: Have you seen Paul's talk on scalaz-stream?
11:57:53 <monochrom> I optimize efficiency for actual readers such as you. commercial designs optimize kissing up bosses, not even real customers.
11:58:08 <hiptobecubic> :)
11:58:21 <benzrf> Apocalisp: i aint no scala user
12:00:10 <dspies> If I'm importing only some parts of a module, how can I  import both the type and the data constructor when they have the same name?
12:00:25 <dspies> import M (T) only seems to import the type T
12:00:27 <dspies> not the constructor
12:00:56 <rwbarton> import M (T(T))
12:01:04 <rwbarton> or import M(T(..)) to get all the data constructors
12:01:05 <benzrf> T(T)
12:01:22 <dspies> thanks
12:01:35 <monochrom> import System.IO( IOMode(ReadMode), withFile ) is an example
12:01:51 <monochrom> import Prelude( Maybe(Nothing) )
12:02:01 <dspies> What if the type is an operator?
12:02:05 <dspies> (using TypeOperators)
12:02:17 <Apocalisp> benzrf: Be that as it may, the principles are pretty much the same
12:02:38 <dspies> rwbarton: How can I do it if the type is an operator?
12:02:57 <monochrom> then it may involve more parentheses, but I haven't really tried.
12:03:03 <benzrf> Apocalisp: http://www.zazzle.com/scala_haha_t_shirt-235179021004718021
12:03:07 <rwbarton> import M(type +)
12:03:14 <rwbarton> and then... I don't know
12:03:22 <rwbarton> maybe import M(type +(:+))?
12:03:37 <monochrom> that is funny :)
12:03:50 <dspies> oh I got it, it's import Data.Array.Accelerate((:.)((:.)))
12:03:55 <rwbarton> oh yes
12:04:08 <monochrom> haha, moar parentheses
12:04:13 <rwbarton> I thought you meant the funny new infix-type-constructor-that-doesn't-start-with-a-colon
12:04:19 <benzrf> i will bbl
12:06:55 * hackagebot uri-templater 0.2.0.0 - Parsing & Quasiquoting for RFC 6570 URI Templates  http://hackage.haskell.org/package/uri-templater-0.2.0.0 (IanDuncan)
12:15:43 <Tjr> Reddit is discussing the flaws of the standard prelude.
12:16:05 <Tjr> Is there some well-maintained alternative preludes that fixes those flaws?
12:16:19 <Tjr> something I can plug in and move on?
12:17:34 <k00mi> there is classy-prelude
12:17:52 <k00mi> but you probably want to stick to the standard prelude despite its flaws
12:18:23 <Tjr> why?
12:19:27 <k00mi> for one, it's the standard, the vast majority of haskellers will not know other preludes
12:20:13 <k00mi> and classy-prelude in particular will result in much less understandable error messages due to its use of typeclasses
12:20:36 <Cale> There are issues with the standard Prelude, but the classy prelude doesn't solve any of the things which I consider problems.
12:20:38 <Tjr> Can I use classy-prelude and still import a library that uses the standard prelude?
12:20:52 <rwbarton> many of the so-called flaws are vastly overstated
12:20:55 <k00mi> yes, you can
12:20:59 <Cale> (and introduces a lot of potential issues of its own)
12:21:15 <Tjr> Cale: can you elaborate on the respective problems, please?
12:21:20 <Cale> Yeah, and most of the things are really just minor annoyances rather than anything serious
12:21:38 <rwbarton> if you don't like 'head', hide it, if you don't like typing 'fmap', get over it
12:22:06 <k00mi> what's the alternative to typing fmap?
12:22:06 <Sculptor>  /join #python
12:22:10 <Sculptor> ah, sowwy
12:22:28 <rwbarton> some people would prefer map
12:22:42 <Cale> The way in which the numeric hierarchy is split up is a bit off. The abs function doesn't really belong in Num. Enum should probably not have succ and pred in it, and should just be reserved for the functions into which the list ".." syntaxes get translated into.
12:22:42 <k00mi> ah
12:23:55 <Cale> fail probably shouldn't be in the Monad class
12:24:10 <Tjr> those are all flaws of the standard prelude, right?
12:24:14 <Cale> yes
12:24:17 <Tjr> Do they get addresses in classy-prelude?
12:24:25 <Cale> Some of the things which used to bother me have been fixed already, or are on their way to being fixed: Num used to have Eq and Show as superclasses
12:24:39 <Cale> I don't think any of these are addressed in classy-prelude
12:24:44 <Cale> all it does is generalise stuff
12:24:52 <Tjr> hmm
12:24:54 <Cale> By making lots of typeclasses
12:25:11 <kazagistar> Well, most of the typeclasses for the generalizations exist already, right?
12:26:29 <Tjr> Is there some well-maintained plug-and-play fix for: num hierarchy / enum succ / fail / String = [Char]
12:26:29 <l0cust> Is there anything intrinsically wrong with using RankNTypes?
12:27:06 <kazagistar> a good example { concat :: (MonoFoldable c, Monoid (Element c)) => c -> Element c }
12:27:10 <triliyn> For String = [Char] there is an extension
12:27:27 <Cale> Tjr: These are really minor complaints, and for the most part don't really matter
12:27:50 <triliyn> OverloadedStrings
12:28:01 <Cale> Tjr: The pain caused by using something which isn't the default will cause more trouble than these issues will
12:28:15 <triliyn> Though I think that's just about string literals
12:28:27 <Cale> Tjr: These are things which it would be nice to fix, but they have to be handled in a once-and-for-all fashion or not at all.
12:28:27 <Tjr> ok
12:28:50 <kazagistar> Cale: the question is how do we make the defaults less painful? do we just give up on that goal?
12:29:02 <Cale> kazagistar: Well, steps are being taken
12:29:16 <Cale> We're soon going to have Functor > Applicative > Monad
12:29:51 <Tjr> if those steps result in something neat, well-maintained, that just works ... I'm just saying I'd be willing to test-drive it.
12:29:52 <Cale> and who knows, maybe Monad itself will change a bit. I'd love to see fail moved into its own type class.
12:29:56 <kazagistar> Cale: this might be a tragedy of the commons issue in some sense... if every takes the easy route of sticking to defaults, then we are stuck with the defaults, even if no one likes em
12:30:21 <Cale> kazagistar: Well, the thing is, everything depends on base
12:30:35 <Cale> kazagistar: So the changes have to happen in base, and then we need to update everything to work with that.
12:31:03 <Cale> Depending on something other than base will put your library on a tiny island where it can't really be used with anything else
12:31:35 <Tjr> "can't really be used with anything else" That sounds worrysome
12:31:55 <Cale> If the Monad class that your code uses is different from the one everyone else is using, then your instances don't count as instances of Monad from base, and can't be used as such.
12:31:56 <kazagistar> Cale: so then we are doomed to be trapped on base?
12:32:01 <Tjr> Why can a custom prelude use a standard-prelude-library, but not vice versa?
12:32:06 <Cale> kazagistar: Well, it's easy, we just fix base.
12:32:39 <Cale> kazagistar: This is being done, but somewhat cautiously, as it affects lots of people, and requires a bunch of maintenance already.
12:32:55 <kazagistar> Tjr: it can work vis versa, as long as you are careful and leave some connection points
12:32:58 <Cale> Even the change to Num's superclasses required changes to lots of packages.
12:33:49 <Cale> If we separate fail into its own type class, then lots of things will end up with MonadFail constraints, and library and program authors will have to change their code.
12:34:02 <Tjr> So this boils down to "don't use prelude functions at all if they have known design flaws".
12:34:15 <Cale> Tjr: Or just be cautious about it
12:34:25 <Cale> Tjr: I tend to pretend that fail doesn't exist
12:34:35 <Cale> Tjr: Things like abs and signum are harder to avoid
12:34:44 * Tjr is too new to have used fail
12:34:45 <kazagistar> which is why languages go obsolete... at some point, people are unwilling to make breaking changes, and the only way to get a fixed language is to get a new one
12:34:49 <Cale> But presumably they won't ever go away, just be moved into their own class.
12:34:56 <kazagistar> but haskell is still moving, just slowly
12:35:06 <Cale> Yes, eventually we'll jump ship to something new anyway
12:35:11 <Cale> (or at least I will)
12:35:22 <jmcarthur> just waiting for a nice looking ship...
12:35:24 <Cale> Whatever it is doesn't quite exist yet
12:35:25 <Cale> yeah
12:35:40 <Cale> I want a dependently typed language with lazy-by-default evaluation.
12:35:44 <Cale> at minimum
12:35:58 <jmcarthur> i think the flavor of dependent types is also important to me
12:36:24 <jmcarthur> and the standard library must not be too awkward, as a lot of libraries for dependently typed languages of today are
12:36:27 <Cale> There are some language features that I'd like to see, but which nobody completely knows how to implement yet, like higher inductive types.
12:36:49 <jmcarthur> idris might be okay on the library front, actually. i haven't given it a fair chance
12:37:03 <Tjr> Commercial users will try to avoid sinking lots of development effort into some language that will be superseded, anyway.
12:37:21 <jmcarthur> but that eager evaluation...
12:37:28 <kazagistar> does classy prelude fix indexing and the other collection operations?
12:37:48 <jmcarthur> Tjr: if that was actually true, commercial users would never sink lots of development effort into any language
12:38:53 <Tjr> What are dependent types?
12:39:03 <Cale> Tjr: Types which can depend on values
12:39:14 <Tjr> what would that look  like?
12:39:19 <jmcarthur> on *runtime* values, to be clear
12:39:28 <kazagistar> x :: Array of length 5
12:39:50 <Tjr> isn't the entire point to make the compiler check all those things?
12:39:57 <jmcarthur> replicate :: (n :: Int) -> a -> Vector n a
12:39:59 <Cale> Tjr: Yes, the compiler still checks everything
12:40:11 <Tjr> the compiler checks runtime values?
12:40:16 <jmcarthur> hah, terrible use of Int
12:40:16 * Tjr is confused.
12:40:22 <jmcarthur> Nat, that should really be
12:40:47 <jmcarthur> Tjr: the compiler checks that no matter what the runtime value is your program is still typesafe
12:41:19 <kazagistar> Tjr: types are proofs, proofs are types
12:41:22 <jmcarthur> Tjr: that may, sometimes, mean you have to provide some sort of proof to the compiler. it may mean that you have to prove to the compiler that you have performed whatever dynamic checks are necessary.
12:41:36 <Cale> Tjr: Types are statements, programs are proofs
12:41:46 <Cale> ^^ kazagistar
12:42:00 <hiptobecubic> Tjr, this is a confusing road you are wandering down, just so you know
12:42:10 <jmcarthur> it doesn't have to be!
12:42:17 <Cale> But yeah, let's look at actual examples
12:42:22 <Tjr> does any existing, convenient language provide dependent types?
12:42:29 <hiptobecubic> "convenient"
12:42:31 <Cale> Tjr: Agda, Coq, Idris
12:42:51 <Cale> Whether any of those are called convenient is subjective
12:43:01 <Cale> But fairly major things have been done in them
12:43:08 <jmcarthur> i actually doubt many people would call them convenient at all
12:43:13 <jmcarthur> they are "nice"
12:43:19 <Cale> There's a whole C compiler written in Coq with a proof of correctness.
12:43:43 <Tjr> By convenient I mean it's possible to write production code reasonably fast, and not run into package manager hell, lack of libraries, etc.
12:43:49 <Trollinator> C to what?
12:43:57 <Cale> i.e. The types express the fact that the output of the compiler will have the same semantics of the input program
12:44:01 <jmcarthur> nope, not convenient right now by that definition
12:44:04 <hiptobecubic> Trollinator, C
12:44:14 <Cale> http://compcert.inria.fr/
12:44:20 <Cale> PPC Assembly
12:44:32 <Trollinator> thanks Cale
12:44:48 <Trollinator> hiptobecubic: hardly a feat.
12:45:03 <hiptobecubic> Trollinator, I write them all the time
12:45:22 <Cale> oh, also ARM and x86 apparently
12:45:31 <Trollinator> the complete source code for a verified correct C to C compiler is `interact id`
12:45:35 <kazagistar> Tjr: just think of a type as an assurance that something will follow some properties... Int -> Int -> Int means that if you can prove that the two things coming in to the function are integers, then I can prove the result is an integer
12:45:48 <hiptobecubic> Trollinator, I just use cat
12:46:14 <jmcarthur> Trollinator: but sadly if you feed it an invalid C program it will not tell you
12:46:23 <jmcarthur> Trollinator: it will instead just produce an invalid C program
12:46:24 <hiptobecubic> jmcarthur, but the semantics will stay the same
12:46:29 <kazagistar> Tjr: the program typechecks when the typesystem builds a proof that all the operations pass around what is expected... our proof is valid because every time we ask for an Int, we get one
12:47:52 <Tjr> Dependent type compilers sound like quite a feat, given how difficult automatic proof checkers have turned out to be, let alone automatic theorem provers.
12:48:31 <Cale> Tjr: They're essentially the same thing as proof checkers
12:48:45 <kazagistar> Tjr: this idea could be extended a little, to things like "I can show constructively that this number must be within range, and thus I can skip safety checks" for example
12:48:58 <Trollinator> I think it's not that hard in principle… afaiu, the tricky bit is to build a compiler that doesn't require crazy amounts of type annotations.
12:49:36 <Tjr> crazy amounts of human-provided detail is also why mathematicians do not use proof checkers.
12:49:40 <kazagistar> Tjr: it isn't automatic, it requires guidance, but from what I see idris does an impressive job at automating as much as it can, for example
12:49:42 <Tjr> research mathematicians
12:50:35 <Trollinator> Tjr: I know, I've messed around with ATS a bit, and the amount of work required to prove even simple theorems is mindboggling.
12:51:13 <Tjr> Trollinator: what area of maths, and which proof checkers?
12:51:17 <Trollinator> That was with ATS1 though, ATS2 may be easier to work with.
12:51:40 <Trollinator> just basic arithmetic
12:51:41 <kazagistar> Tjr: watch this 15 min video where they prove (in the type system) a monoid instance for a Maybe https://www.youtube.com/watch?v=P82dqVrS8ik
12:52:04 <Tjr> is there non-video documentation for that?
12:52:11 * Tjr doesn't like to precommit lots of time.
12:52:53 <kazagistar> the amount of circuits required to compute arithmetic is mind boggling
12:53:07 <kazagistar> but once you have it, you can abstract it
12:53:46 <kazagistar> proofs <-> computation duality holds the same promise
12:55:16 <kazagistar> Tjr: there probably is but I dont know where, sorry
12:56:10 * Tjr can read/skip faster than listen/watch
12:56:14 <Trollinator> let { f 0 _ = 1; f _ 0 = 1; f x y = f (pred x) y + f x (pred y) }     The proof stated that f x y = sum $ map (f $ pred x) [0..y]
12:57:04 <Trollinator> or something along those lines, I don't remember exactly. Anyway, it's basically trivial to write this down, yet convincing the proof checker in ATS of that required dozens of lines.
12:59:32 <Trollinator> And what's worse, ATS' builtin int type doesn't give you arbitrary precision arithmetic, so you can get wrong results even though you “verified“ the program.
12:59:32 <Tjr> ok, thanks. I take it ATS isn't quite ready for commercial use.
13:00:34 <Trollinator> that was years ago, and to be fair, it does come with arbitrary-precision integers.
13:00:44 <kazagistar> while you cannot automate the full proof, you can do something like @djinn to automate the "obvious variable fiddling"
13:01:25 <Tjr> Once dependent type compilers are easy to use, it would be fun to see what happens if somebody imports all those automated proofs from maths, and turned their respective input/output into data types.
13:01:50 <Trollinator> and AIUI, the language is flexible enough for one to provide the proper types for arithmetic operations.
13:01:50 * joeyh is a bit surprised to see that getDirectoryContents does not stream its results.. It'll OOM in a big enough directory
13:02:14 <puritypunisher> joeyh: using a lazy IO-performing list?
13:02:23 <joeyh> yes
13:02:42 <joeyh> _ <- getDirectoryContents "bigdir" -- OOM
13:03:05 <Trollinator> the problem is that it's really, really, inconvenient. Basically the addition function needs to specify that the sum of the integers you're trying to add can't be greater than 2^31-1.
13:04:00 <kazagistar> yeah, weaving that "cap" through your code cound be inconvenient
13:04:16 <Trollinator> or it's going to be inefficient and require memory allocation. Since ATS is meant to be used as a replacement for C among others, requiring memory allocation for int addition is not really an option.
13:05:28 <triliyn> Trollinator: to be fair, just trying to prove to YOURSELF that a particular arithmetic operation will never overflow can take a fair bit of effort
13:06:16 <kazagistar> the cases where it is easy to prove to yourself "should" be easy to prove to the computer, in theory
13:06:16 <triliyn> (But you're right, probably not quite as much as it would take to satisfy the compiler)
13:06:35 <triliyn> There is that too
13:07:02 <Tjr> Trollinator: regarding int <= 2^31-1 ---- those integers form a commutative ring with a unity element (but you cannot divide). What goes wrong if you try to rewrite your application to use those numbers?
13:07:42 <kazagistar> triliyn: and in those cases where you cannot prove it, you can at least thread a "assuming we dont overflow" to the guarentees of the functions correctness so that your failure to verify is apparent :P
13:07:56 <Trollinator> triliyn: well, in many cases you just don't care. So many programs are throwaway things that you run once to do some little job and then toss away.
13:07:58 <triliyn> hehe
13:08:34 <kazagistar> Trollinator: thats the logic used for dynamically typed languages
13:08:52 <triliyn> Trollinator: yeah, modern deptype languages are probably too much of a hassle for most throwaway programs, at least if you want to try to make use of the dependent typing
13:09:33 <kazagistar> Trollinator: which leads (me at least) to some idea like optional dependant typing, where you can dependantly type when you want, type when you want, and just wing it where you want
13:10:11 <kazagistar> for the full scale of "giving a shit about correctness"
13:10:12 <Trollinator> kazagistar: which is why those languages were once known as scripting languages: something that isn't suitable for serious programming, just for little one-off stuff. And then somebody has the “glorious” idea of writing web apps in perl.
13:10:31 <triliyn> kazagistar: well, dependently-typed systems can already support non-dependent programming
13:10:56 <Trollinator> I think it's a matter of libraries more than a matter of languages.
13:11:22 <kazagistar> triliyn: and non-dependant type systems can already support unityped code, but not as *conveniently*
13:11:27 <kazagistar> yeah, libraries and such
13:11:57 <Trollinator> For example ATS comes with a list and a list0 type. list is indexed by the list's length, list0 isn't, so you get as much checking as you would in an ordinary ML-style language.
13:12:23 <triliyn> Idris has library support for non-dependent programming approximately comparable (or even superior) to its library support for dependent typing
13:12:59 <triliyn> Not as good as Haskell's support for non-dependent typing, but only because haskell is a much more mature language
13:13:30 <jmcarthur> it may be possible for something like ornaments to make this tradeoff nicer.
13:14:01 <dolio> I don't believe people when they say that sometimes you want dynamic typing, any more.
13:14:22 <jmcarthur> i believe they believe it
13:14:28 <dolio> Sure.
13:14:32 <kazagistar> triliyn: does it provide good support for interweaving them? for example, if you cannot prove something, jam a runtime check in to ensure the state required?
13:15:10 <triliyn> kazagistar: hmmm, good question. I would say there's... at least a bit
13:15:33 <jmcarthur> but i agree. a decent static type system with decent libraries allows you to choose how much type safety you really want anyway, and in a way that you are responsible for writing out the dynamic checks in the way you want, even if you end up making a dumb library to hide it all.
13:15:34 <triliyn> Whether it's ENOUGH support... I'm not sure
13:16:15 <kazagistar> triliyn: that is what makes interweaving dynamic and static types possible, you just put a check at the end of the dynamic bit that verifies that it is the right static type, and then your guarentee is perserved in the statically typed sections
13:17:18 <Trollinator> I don't really understand how code re-use is supposed to work with dependent types. Take the filter function. Say, I have an array of length 10 called x, and a [Int], and I filter (<10) the list. Now I map (x !) the list, that ought to be fine, right? But that would require the return type of filter to somehow encode the invariant that all the list elements are now less than 10, that seems difficult to me.
13:18:22 <triliyn> Trollinator: jmcarthur mentioned ornamental data types a while ago; I think that's actually something that would help with the problem you're pointing out
13:18:32 <kazagistar> Trollinator: I imagine inequality can be recorded as a type the same way equality can
13:19:02 <kazagistar> equality, at least in idris, is a type constructor that takes two of the same value
13:19:05 <triliyn> The problem isn't how to encode it, it's that you need to use a version of filter that records the information
13:19:34 <triliyn> A fully-general filter function won't know what proofs about its result to build up
13:19:48 <dolio> If you just take Haskell examples, which throw away information, and write them in a dependently typed language, and expect it to check more properties, you're expecting too much.
13:20:05 <triliyn> So if you want to keep track of the fact that all of your elements are now less than 10, you basically have to write your own filter function
13:20:14 <Trollinator> I watched a talk about Idris once; I don't remember much, but the guy said that in Idris, Booleans are a code smell precisely because of this: They only say “yes” or “no”, but they don't know to what question.
13:20:39 <triliyn> Booleans themselves have a pretty general replacement, actually
13:21:01 <Trollinator> dolio: sure. I'm just saying I'm having trouble imagining that the alternative would look like. I'm probably just undereducated.
13:21:28 <dolio> Make filter : Dec P -> List A -> List (Σ A P)
13:21:55 * Nik05 just found out something new after Applicative, Monad, etc... Arrows wtf
13:21:57 <Trollinator> triliyn: yes, that's what I was saying: I have to write my own filter function, I can't reuse one somebody else wrote.
13:22:09 <kazagistar> dolio: Dec is decider, right?
13:22:10 <Trollinator> dolio: what does that mean?
13:22:33 <Nik05> Are Arrows used a lot?
13:22:44 <dolio> It means, take a decision procedure for P, which is a predicate on A, and a list of As, and return a list of As together with proofs that they satisfy P.
13:22:55 <Trollinator> The only library I'm aware of that uses them is HXT.
13:23:06 <triliyn> dolio: huh, that is actually a pretty general replacement
13:23:20 <Trollinator> but that doesn't mean much, I haven't done much Haskell in practice.
13:23:24 <kazagistar> Nik05: I havent really seen em much, other then as a sugar for dealing with tuples or something
13:23:27 <Trollinator> dolio: I see. Seems interesting.
13:23:31 <Nik05> oh oke
13:23:40 <pharaun> i don't know what to think about hxt+arrows
13:23:48 <pharaun> it... works for some of my parsing, some of it it becomes a pain
13:24:42 <joeyh> huh, getDirectoryContents is written with an accumulator on windows, but not unix, avoiding the problem on Windows. Time to file another ghc bug! :)
13:24:43 <Trollinator> Well, XML is stupid. I don't think it's possible to make it pleasant to parse.
13:25:25 <dolio> joeyh: Oh, I didn't even notice that.
13:25:35 <dolio> I noticed that the unix one didn't use an accumulator.
13:26:02 <pharaun> Trollinator: html in my case :)
13:26:09 <pharaun> hxt was one of the better html parser i could find
13:26:34 <joeyh> dolio: my haskell is slightly rusty (just back from vacation), that does make sense that the lack of accumulator blows the stack, doesn't it?
13:26:45 <dolio> Yes.
13:26:50 <dolio> It should be using an accumulator.
13:26:53 <joeyh> just not tail recursive essentially
13:27:17 <dolio> That's not a GHC bug, though.
13:27:26 <dolio> Looks like directory is owned by libraries.
13:27:51 <joeyh> blah, library bugs are much less fun ;)
13:27:58 <joeyh> ok, I'll file it
13:28:03 <dolio> I think, at least.
13:28:47 <Trollinator> anyway, one of the things I found awesome about ATS is linear types.
13:29:06 <dolio> Oh, I guess it's still tracked on trac, though.
13:29:23 <dolio> joeyh: So go ahead.
13:29:50 <Trollinator> They're great for avoiding resource leaks and managing mutable state.
13:30:35 <Trollinator> I don't know of any other approach to make dependent types work with mutable state.
13:31:35 <kazagistar> linear types are probably my personal biggest known "hole" in theoretical understanding... they seem simple, but I have no idea how they interact with everything else
13:32:11 <Trollinator> aren't they pretty much orthogonal?
13:33:50 <kazagistar> not exactly... I am slowing slogging through some homotopy type theory lectures online, and linear types seems like what was called a "Substructural property" that really can mess with logic systems
13:34:29 <kazagistar> but I might be overthinking or misunderstanding it
13:35:16 <kazagistar> Trollinator: http://en.wikipedia.org/wiki/Substructural_logic
13:35:47 <Trollinator> I don't really understand much of the theory, but my understanding is that a value of linear type is just a value that you can only use once.
13:37:04 <Trollinator> yeah, when you have linear types you essentially have a non-monotone logic.
13:37:06 <kazagistar> right... presumably, it would also then have to come with an explicit function that lets you take 1 linear type, and copy it into multiple linear types, for some types?
13:38:27 <kazagistar> in other words, you would only reintroduce copying selectively or explicitly
13:39:09 <Trollinator> Well, it depends on what you're dealing with. If you have, say, a linear type representing a malloced pointer, having a function that duplicates it would allow you to free it twice.
13:39:37 <Trollinator> If you have some refcounted resource otoh, duplicating a reference to it is fine.
13:40:12 <joeyh> dolio: https://ghc.haskell.org/trac/ghc/ticket/9266
13:40:31 <kazagistar> and, potentially, you could have things that should not be duplicated at all?
13:41:08 <Trollinator> the malloced pointer example was one such thing. If you duplicate that, you can free it twice
13:41:25 <kazagistar> right
13:41:28 <Trollinator> though there are tricks to make that possible anyway.
13:42:19 <kazagistar> so are there no interactions or conflicts with lazyness or purity? it is really that clean and simple?
13:43:19 <Trollinator> I'd rather not give a definitive answer. I don't understand the theory enough.
13:44:00 <kazagistar> fair enough
13:44:09 <danilo2> Hello! Is it possible in haskell to "track" undefined value? I use undefined values in some unimplemented places in the code and I want to know which of these appers in the outpu - It would be perfectly fine if there would exist something like Prelude.undefined2, because I would just replace with it some undefined values and see when output changes - is there any mechanism which would help me ?
13:44:54 <kazagistar> danilo2: a simple idea would be to use errors instead?
13:45:11 <Trollinator> doesn't undefined simply explode when you try to evaluate it?
13:46:42 <danilo2> kazagistar: ah! you are right! thanks, it works! :)
13:46:42 <geekosaur> danilo2: you want error. replace undefined with error "some identifying message"
13:46:51 <kazagistar> right, but as I understood it, he wants to know which specific undefined made it explode
13:46:53 <danilo2> geekosaur: thank you! :)
13:48:37 <kazagistar> hah! as I expected!
13:48:41 <kazagistar> from prelude:
13:48:43 <kazagistar> undefined =  error "Prelude.undefined"
13:48:52 <danilo2> kazagistar: oh!
13:49:33 <danilo2> By the way - are we able to write in haskell mechanisms simmilar to error? I mean - error is inmplemened inside of the GHC logic, or are we able to crete such behaviour using just haskell ?
13:50:16 <johnw> it relies on exceptions, which are provided by the runtime
13:50:47 <kazagistar> danilo2: not exactly, but there are better mechanisms for error handling more explicitly anyways
13:51:11 <Trollinator> exceptions are rather ugly though.
13:51:34 <Trollinator> I used to be a fan of exceptions, because in C++ and Java there's not really a better way to do it.
13:51:41 <danilo2> johnw, kazagistar: Ok :) I know - I'm using only Eithers - I do not remember when I was using errors (If I was using them ever). Anyway I was curious :)
13:51:48 <johnw> exceptions still have a place in Haskell
13:52:37 <kazagistar> my first big haskell program I tried using exceptions as a part of regular processing, and got eaten alive by its ugly interactions with lazyness and whatnot
13:52:54 <johnw> exceptions should be reserved for things that are genuinely exceptional and which you have really no control over
13:52:55 <kazagistar> well, not ugly, but not what I expected at the time at least
13:53:05 <johnw> in every other case, try to model your problem domain using richer types
13:53:33 <benzrf> ur types are working class!
13:53:35 <benzrf> make them richer!
13:54:49 <johnw> and having too much information, and then removing it later, is a much easier refactoring generally than omitting information and needing to add it back in
13:55:06 <johnw> this week I changed an app that used Integer everywhere to one using size-appropriate Inst
13:55:25 <johnw> only to discover that there were many _kinds_ of Integer being used; effectively, within the numerical domain it was a dynamically typed program
13:55:27 <benzrf> Inst?
13:55:29 <johnw> Ints
13:55:33 <benzrf> oh
13:55:34 <kazagistar> right, so the proper amount of information is to include types at runtime, and then to refactor them into static typing later, right? :P
13:55:42 <johnw> haha
13:55:46 <kazagistar> more info -> less info
13:55:54 <johnw> I start out by newtype wrapping pretty much everything
13:56:04 <johnw> I don't really like Ints or Strings anymore
13:56:07 <benzrf> nootype schmootype
13:56:15 <benzrf> :t ala
13:56:17 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
13:56:19 <benzrf> heuh
13:56:57 <benzrf> whats a good Iso again
13:57:03 <benzrf> :t enum
13:57:04 <lambdabot> (Profunctor p, Functor f, Enum a) => p a (f a) -> p Int (f Int)
13:57:24 <benzrf> wots a function on chars
13:57:29 <benzrf> :t upper
13:57:30 <lambdabot> Not in scope: ‘upper’
13:57:32 <benzrf> :t toUpper
13:57:33 <lambdabot> Char -> Char
13:57:35 <quinso> Is there a nice library for subprocesses in haskell, like python's sh? https://amoffat.github.io/sh/
13:57:43 <benzrf> > enum toUpper 3
13:57:44 <lambdabot>  Couldn't match type ‘f GHC.Types.Char’ with ‘GHC.Types.Char’
13:57:44 <lambdabot>  Expected type: GHC.Types.Char -> f GHC.Types.Char
13:57:44 <lambdabot>    Actual type: GHC.Types.Char -> GHC.Types.Char
13:57:47 <benzrf> wait wot
13:57:52 <benzrf> :t enum toUpper
13:57:53 <lambdabot>     Couldn't match type ‘f Char’ with ‘Char’
13:57:53 <lambdabot>     Expected type: Char -> f Char
13:57:53 <lambdabot>       Actual type: Char -> Char
13:57:55 <benzrf> o.o
13:57:57 <benzrf> oh.
13:58:00 <benzrf> :t under
13:58:01 <lambdabot> AnIso s t a b -> (t -> s) -> b -> a
13:58:31 <benzrf> @hoogle AnIso s t a b -> (b -> a) -> (t -> s)
13:58:33 <lambdabot> Warning: Unknown type AnIso
13:58:33 <lambdabot> No results found
13:58:36 <benzrf> wait this seems wrong
13:58:37 <benzrf> nvm
14:00:05 <Trollinator> Did it ever occur to you that we live in some kind of gold rush time? Fascinating papers about type systems are being published basically weekly, there's linear types, dependent types, “ornaments“ that i learned about today, type families, on and on it goes!
14:00:31 <Trollinator> and Scala's dependent object calculus.
14:00:40 <Trollinator> and so much more!
14:00:48 <Trollinator> region types, effect types
14:01:34 <kazagistar> its hard to tell. I am reading "The Structure of Scientific Revolutions" which has interesting ideas about this sort of thing
14:01:43 <Trollinator> it really makes one wonder what software development will look like in 20 or 30 years.
14:02:15 <kazagistar> the software development world is strange because there seems to be two leading paradigms, instead of one
14:02:47 <kazagistar> because the same sort of gold rush is still happening in the OOP world, though it is cooling off a bit
14:03:24 <Trollinator> So far, the track record of “crazy academic research” stuff in the industry is good. Industry languages have lambdas and generics now, and some people even use Haskell and OCaml in the industry!
14:03:26 <quinso> kazagistar: do you mean as in programming paradigms or scientific paradigms? Because those are definitely not the same.
14:04:47 <Trollinator> kazagistar: I'm not so sure… I haven't seen all that much innovation in the OOP world.
14:04:49 <kazagistar> quinso: I meant scientific paradigms in the way described by the essay/book, which is to say, a set of guiding truths and principles which define and guide the direction of research
14:06:35 <otjura> there's a reason why programming is multiparadigm and huge languages like C++ and Lisp have capability to get job done in multiple ways. nothinbg exciting, really. programming languages are tools.
14:06:52 <kazagistar> Trollinator: thats the thing, a paradigm defines what it means for research to be meaningful, and since OOP research is and functional-typed research are different in that regard, they tend to not see each other as terribly meaningful
14:08:55 <deni> does cabal install compile using all cores? it doesn't seem so
14:09:05 <deni> can i make it go faster by giving it all cores?
14:10:59 <k00mi> deni: 'cabal install -jN' compiles independent modules using N threads
14:11:06 <Trollinator> otjura: A programming language is *not* a tool. It's a means for expression oneself. You wouldn't call German or Mandarin a tool, would you?
14:11:24 <k00mi> deni: or rather packages, not modules
14:11:49 <otjura> as person speaking both of those, yes I would. language is tool for communicating for me, Trollinator
14:12:21 <mzero> silly: "langauge" in "programming langauge" is quite a different sense of the word than in "German language"
14:13:11 <deni> k00mi: tnx
14:14:05 <Trollinator> that's a stretch. If you define “tool” that way, anything that has some kind of purpose can be defined as a tool
14:15:37 <Trollinator> 我也说德语,还我学习汉语 :-)
14:15:46 <codygman> I just got a "ghc: out of memory (requirested 2097152 bytes)" error on my server while trying to upgrade cabal. Am I going to have to upgrade my servers 490MB of memory?
14:16:40 <otjura> “还是“，你不可以写”还“
14:16:59 <kazagistar> Trollinator: right... a stick is a tool, even if it was not designed, and a Programming Pattern is a tool, even if it has no physical artifact
14:17:23 <luite> codygman: you could try adding some swap, but 490MB is a bit low to comfortable run ghc yeah
14:17:59 <codygman> luite: Thanks for the help.
14:18:04 <Trollinator> 为什么？？
14:18:38 <Trollinator> ok, let's stop with that silliness :-)
14:18:46 <otjura> 还 alone doesn't really mean anything. always use 还是 to say "but"
14:20:25 <Trollinator> I thought but was 但是
14:21:38 <johnw> codygman: or increase your swap space
14:22:09 <Trollinator> and 还 is something like also
14:22:22 <Trollinator> anyway, this is definitely off-topic.
14:23:26 <otjura> oops, you are right, I mixed the two (you still should use 还是). also right about it being offtopic so let's drop this.
14:30:12 <Nik05> wow i have done all the cis194 exercises and when i now do exercise 2 it can be done in a few lines with the Parser created in later exercises, cool
14:30:27 <Nik05> Applicative and Alternative are really nice
14:34:19 <johnw> they sure are
14:36:51 <athan> Hey guys, I've got a weird idea for a data type and wanted to make sure that it hasn't been already made
14:37:06 * hackagebot pipes-binary 0.4.0.2 - Encode and decode binary streams using the pipes and binary libraries.  http://hackage.haskell.org/package/pipes-binary-0.4.0.2 (RenzoCarbonara)
14:37:09 <johnw> athan: shoot!
14:37:50 <athan> it's like an acyclic graph, but you have a number of "terminating nodes" in the graph, and the internal nodes _must_ be connected, S.T. there is a composable path between the terminating nodes through any/every internal node
14:38:03 <athan> ...does that make sense? I call it a Net...
14:38:20 <athan> And I was thinking a 2-Net would be something like a Vine (if the edges were directed, I mean)
14:38:28 <athan> it's _kinda_ like a tree
14:38:29 <johnw> so, every node in the graph has a connection to every other node, and there are some terminal nodes?
14:38:39 <athan> ...kinda
14:38:44 <athan> here I'll draw something up
14:39:25 <johnw> i forget what kind of category that's called
14:41:04 <ski> kazagistar,Trollinator : one way to compare and constrast linearity with uniqueness is : a linear value is a value you may only use once in the future (but whose reference could have been duplicated in the past); a unique value is one which (/ whose reference) hasn't been duplicated yet, so an implementation can use CTGC (Compile-Time GC), or even reuse it in-place when constructing a new value (possibly differing only in some parts from the old one)
14:41:26 <ski> (erm, cut off near ".., or even reuse it in-place when constructing a new value (possibly differing only in some parts from the old one)")
14:41:34 <ski> @where boolean-blindness
14:41:35 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
14:41:44 <ski> Trollinator : seen that ^ one yet ?
14:42:52 <johnw> athan: but in general, what you're describing is a kind of category, so there will be lots you can draw from in that parallel when designing your data structure
14:42:57 <Trollinator> the boolean blindness thing?
14:43:01 <ski> yep
14:43:20 * ski . o O ( "my rust is slightly haskelly" )
14:43:27 <athan> johnw: That's what I was thinking :) too cool
14:44:24 <athan> johnw: I just need it so that there is always a clear composition from each terminating node to the other
14:44:30 <athan> even if it's through a bottleneck
14:44:36 <Trollinator> I'm not sure… now that you mention it I have read an article arguing that booleans are horrible a few years back. I'm not sure it's this one.
14:44:38 <kgadek> anyone here using guard-haskell for hspec?
14:44:41 <ski> athan : undirected graph ?
14:45:14 <athan> ski: It may have to be directed, actually :/
14:45:43 <johnw> athan: if there are categorically terminal nodes in your graph, they must have morphisms one to each other
14:45:49 <johnw> that's what it means to be terminal
14:45:55 <ski> athan : i didn't quite understand the condition imposed on it
14:46:18 <ski> are you saying that for every internal node, there must be a path between terminating nodes, passing through that internal node ?
14:46:18 <Trollinator> I'll read that article another time.
14:46:22 <athan> johnw: That's perfect
14:46:26 <johnw> but if every node has a morphism to every other node, then every node in your category is terminal by definition
14:46:34 <Trollinator> Rust is interesting, I hope they'll manage to add higher-order kinds.
14:46:44 <tkon> does anyone know how to build universal binaries with ghc on OSX?
14:46:45 <Trollinator> not having proper monads would be a shame.
14:46:47 <johnw> terminal = there is a morphism from every node to the terminal node
14:46:48 <athan> ski: it must be able to leave, I suppose
14:47:01 <mzero> tkon - funny - I was JUST writing a survey question about that
14:47:02 <ski> johnw : athan seemed to want acyclicity
14:47:09 <mzero> so, basically, today you cannot easily
14:47:15 <athan> I'm not sure how I'm going to make this have n number of terminating nodes with the edges being directional
14:47:31 <Trollinator> tkon: I think the last Mac OS X release supporting PowerPC Macs is EOL. Given that, I don't see the point.
14:47:37 <tkon> mzero: I was thinking of having two ghc installs and using lipo to glue the executables together
14:47:42 <mzero> you need two GHC compilers, one 32-bit and one 64-bit, you need to compiler your executable twice, and use lipo to stitch them together
14:47:46 <johnw> ski: what do you call a category where there are morphisms between every two objects?
14:48:17 <mzero> BTW - did you mean powerpc & intel... or   intel 32 & intel 64 ?
14:48:27 <tkon> mzero: is there a good way to have two side by side installs?
14:48:27 <johnw> http://en.wikipedia.org/wiki/Connected_category
14:48:41 <mzero> tkon: prior to the release I'm about to put out, no
14:48:43 <ski> johnw : in both directions ?
14:48:57 <johnw> hmm
14:48:59 <tkon> mzero: i386 and x86_64
14:49:15 <tkon> mzero: eta on that?
14:49:30 <athan> I just don't want internal leaf-like nodes, ski/johnw
14:49:30 <mzero> okay - in the next platform release, you'll be able to install them both and there's a new script for switching between them
14:49:42 <athan> so there aren't any internal nubs
14:49:44 <mzero> eta - I'll be putting out alpha within a day or two of 7.8.3 going final
14:49:50 <ski> athan : i see
14:49:52 <athan> johnw, ski: https://github.com/athanclark/vine.git
14:49:58 <ski> ("nubs" ?)
14:50:02 <athan> hmm
14:50:04 <athan> actually nevermind
14:50:14 <mzero> tkon- but oddly, I wasn't planning on producing a 32-bit GHC & HP this time 'round
14:50:26 <athan> I feel like that may be an additional fragment of the directional property with directed graphs
14:50:29 <mzero> how far back are you trying to support (OS version?)
14:50:30 <athan> idk, this is a fun one
14:51:07 <athan> I have a feeling the Vine/2-Net datastructure would be awesome for user groups and permissions inheritance :)
14:51:21 <tkon> mzero: just Mavericks. I'm hooking into Dropbox which is still i386
14:51:40 <mzero> oh man - that's brutal
14:51:50 <athan> I just have a feeling >2-Nets will have a different notion of edges
14:51:53 <athan> I'm not sure..
14:51:57 <mzero> 'cause every Mavricks machine is 64bit capable
14:53:12 <tkon> mzero: it is interesting to say the least
14:55:11 <mzero> well, I admit that it may be a few days after to get the 32-bit ones done... if I can...
14:58:25 <twelve_elephant> so, the definition of the ap function is:
14:58:33 <twelve_elephant> ap =  liftM2 id
14:58:52 <twelve_elephant> but liftM2 has signature liftM2  :: (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:59:11 <twelve_elephant> but id is not (a1 -> a2 -> r), so how does this work?
14:59:54 <geekosaur> id is a -> a
14:59:58 <geekosaur> a is unspecified
15:00:11 <geekosaur> so, a can unify with a1 -> a2 -> r
15:02:57 <dwcook> twelve_elephant, notice that in a1 -> a2 -> r, you actually have one input type and one output type. The input is a1 and the output is a2 -> r. So you have a ~ a1 (a unifies with a1) and a ~ a2 -> r (a unifies with a2 -> r). Make more sense?
15:03:26 <dwcook> This is one of the cases where thinking of a1 -> a2 -> r as a two-parameter function can easily spoil your reasoning.
15:03:50 <twelve_elephant> when you say unifies, I'm not sure I understand what you mean
15:03:57 <dwcook> Ah, then that's a good place to start
15:04:18 <dwcook> So, say you wrote: id "hey"
15:04:27 <dwcook> You know that "hey" :: String
15:04:37 <dwcook> and that id :: a -> a
15:04:58 <dwcook> a, being a type variable, can stand for any type, as long as all the equations involving it are consistent
15:05:14 <dwcook> So in this simple cases you chose a ~ String because String is the only possible type for "hey"
15:05:18 <dwcook> Does that make sense?
15:05:21 <twelve_elephant> yes
15:05:55 <dwcook> Okay, so then when the same type variable appears more than once, as it does in id, it must stand for the same type every time in any given type signature
15:06:05 <dwcook> so that you specialized id to have type String -> String
15:06:20 <dwcook> Oops, I'm sorry, I have to go for a bit. Maybe someone else can pick up where I left off
15:06:50 <twelve_elephant> okay, I hope someone can, I'm rather confused
15:07:47 <mzero> sure
15:07:49 <mzero> I can pick up
15:08:47 <twelve_elephant> :D
15:08:56 <mzero> so, to recap:     id "hey"      the compiler says, "huh, id is  a -> a , and the argument to id is "hey", which is of type String, so.... I can 'unify' a with String
15:09:02 <l0cust> So, getting this error, can't seem to decipher it - http://lpaste.net/106942
15:09:40 <mzero> ... Now that means I replace all the a's with it's unification, String, so in this case  id is String -> String .... hence, the result of this application of id to "hey" ... is of type String"
15:09:50 <l0cust> Here is the code - http://lpaste.net/106943
15:09:50 <mzero> whew! follow so far, twelve_elephant?
15:10:10 <l0cust> There are separate files, I just concatenated them for these purposes
15:10:34 <radix> mzero: so unification is just replacement of a type variable with a type? (in a sound manner)
15:10:45 <twelve_elephant> mzero: yeah, so far so good
15:10:54 <kazagistar> radix: its about to get a bit more complex
15:10:57 <radix> ok :)
15:11:38 <mzero> radix: if you are thinking "imperatively" then yes, replacement... .but is more like in math when we say     x = 3     we are not replacing x with 3 .... we are saying x /is/ 3    and is /unified/ with 3
15:11:40 <mzero> but sure
15:11:43 <mzero> okay, now
15:11:51 <mzero> consider this        id map
15:12:12 <kazagistar> :t map
15:12:12 <lambdabot> (a -> b) -> [a] -> [b]
15:12:16 <kazagistar> (reminder
15:12:34 <mzero> the compiler says     okay, id is type a -> a     and it is being applied to map, which is  (a -> b) -> [a] -> [b]
15:12:52 <mzero> [but don't get confused ... thsoe are different a's there]
15:13:00 <mzero> [the a from id is not the a from map]
15:13:10 <mzero> [to make it clear, I'll restate]
15:13:25 <mzero> the compiler says     okay, id is type a -> a     and it is being applied to map, which is  (x -> y) -> [x] -> [y]
15:13:49 <mzero> SO, says the compiler, I'll unify   a (from id) with (x -> y) -> [x] -> [y]
15:14:21 <mzero> which makes id, in this case have type        ((x -> y) -> [x] -> [y]) ->  ((x -> y) -> [x] -> [y])
15:14:46 <mzero> but remember how -> groups, so equivalently        ((x -> y) -> [x] -> [y]) ->  (x -> y) -> [x] -> [y]
15:15:08 <mzero> and hence, the result type of this expression is     (x -> y) -> [x] -> [y]
15:15:11 <mzero> good so far?
15:15:26 <twelve_elephant> mzero: I think so
15:15:34 <kazagistar> > (id map) (+1) [1..5]
15:15:35 <lambdabot>  [2,3,4,5,6]
15:16:22 <mzero> so, now,    in your expression      liftM2 id       we have     liftM2 is of type    liftM2  :: (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:16:31 <mzero> and we are applying it to       id :: a -> a
15:16:48 <mzero> so.... we need to unify        (a1 -> a2 -> r)    with   (a -> a)
15:17:16 <mzero> so, remember how -> groups.....         (a1 -> (a2 -> r) )      with   (a -> a)
15:18:28 <twelve_elephant> oh, so we say that a1 = (a2 -> r)?
15:18:30 <mzero> so we have        a1 must unify with a        and   (a2 -> r) must unify with a     to
15:18:43 <mzero> and yes     a1 must unify with (a2 -> r)
15:19:02 <twelve_elephant> thats quite clever
15:20:03 <mzero> so...... we ge....    in this case     id will be of type      (a2 -> r) -> (a2 -> r)      or equivalently        (a2 -> r) -> a2 -> r
15:20:49 <mzero> AND, in the lifM2 in that expression will have     (Monad m) => ((a2 -> r) -> a2 -> r) -> m (a2 -> r) -> m a2 -> m r
15:21:42 <twelve_elephant> thats fantastic
15:21:55 <mzero> you may, btw way, recognize that signature for id in this case (a2 -> r) -> a2 -> r  as .... wait for it ....
15:21:55 <twelve_elephant> I'd never have thought of this
15:21:58 <mzero> :t ($)
15:21:59 <lambdabot> (a -> b) -> a -> b
15:22:15 <twelve_elephant> ohh!
15:22:23 <mzero> yes, $ is just a specialization of id
15:22:44 <mzero> witih a particular operator precedence
15:22:45 <twelve_elephant> Haskell is such a pretty language
15:23:04 <mzero> :-)
15:23:40 <twelve_elephant> thanks a bunch for the explanation mzero
15:23:44 <twelve_elephant> much appreciated
15:23:44 <codygman> twelve_elephant: Funny enough, I had someone tell me they hate Haskell because the syntax is so ugly a few days ago.
15:23:51 <mzero> welcome
15:23:57 <kazagistar> wait til you get to the reader monad, thats a fun one :P
15:24:01 <twelve_elephant> codygman: they are objectively wrong! heh
15:24:08 <ckaukis> I’m new to Haskell and trying Yesod. Can anyone help me with how to use renderBootstrap3? I don’t exactly understand the documentation on how to use it. There is no full example. The yesod channel is dead.
15:25:11 <twelve_elephant> kazagistar: Monad.Trans is proving to be a great read too
15:25:45 <kazagistar> twelve_elephant: fair enough, thats probably more advanced actually :P
15:26:14 <kazagistar> twelve_elephant: when I say reader monad, I mean the (a ->) monad instance
15:28:25 <twelve_elephant> kazagistar: I suppose I'll read that one next, sounds pretty neat
15:28:40 <mzero> My suggestion, BTW, is that you work out how to implement Reader monad, Writer monad, and State monad
15:28:59 <mzero> and a Parsing monad .... all on your own, working from just the desired effects are
15:29:35 <mzero> When you make it through those instance implemenations it'll really quick
15:31:17 <mzero> er, really click
15:31:18 <mzero> click!
15:31:27 <kazagistar> twelve_elephant: well, { >>= :: m a -> (a -> m b) -> m b }, so what happens when I do something like... um... { (+3) >>= (*) } ?
15:32:13 <kazagistar> well, +3 (Int -> Int) , so how does that unify with (m a)?
15:32:52 <mzero> it will be easier to remember that,     Int -> Int       is best read as    (->) Int Int     in this case
15:33:26 <mzero> (or did I just give too much away?  :-O   )
15:33:46 <kazagistar> mzero: no, I dont think so
15:34:58 <benzrf> also try Maybe or Either monad
15:35:02 <kazagistar> mzero: thinking about "functions at the type level" is not easy until you figure it out
15:35:16 <benzrf> ckaukis: why are you trying yesod when youre new to haskell
15:35:33 <kazagistar> (that is kinda a silly statement, but whatever)
15:42:18 <twelve_elephant> kazagistar: hmm
15:42:23 <kazagistar> ckaukis: type tetris can be too much if you are not used to the type system and common typeclasses
15:42:27 <twelve_elephant> is it (*3)?
15:42:36 <mzero> no
15:42:46 <mzero> don't look at the values --- work through the types first
15:44:28 <dwcook> twelve_elephant, are you still working to understand the type of ap?
15:44:52 <dwcook> Or rather, how the implementation works out to that type
15:45:21 <kazagistar> dwcook: we got there on that one I think
15:45:43 <dwcook> I'll await their response
15:50:08 <twelve_elephant> dwcook: yup I understand now
15:52:05 <dwcook> Okay cool
15:52:06 <twelve_elephant> kazagistar: is the result going to be something resembling the function: fn x y = (3 + x) * y  ?
15:52:43 <kazagistar> twelve_elephant: closer, but you missed a part of the unification
15:53:05 <twelve_elephant> hmm, I've gotta go grab some dinner, but I'll be pondering this one
15:53:14 <kazagistar> the three m's are the same m
16:04:02 <qwebirc97943> is there a way to simplify this async code so that i can get somehow merge the outer withAsync into the code?
16:04:08 <qwebirc97943> here is the paste http://lpaste.net/106944
16:07:18 <qwebirc97943> ist irgendjemand da?
16:08:24 <mzero> alas, I don't know anything about Async
16:09:13 <dwcook> qwebirc97943, how about using wait instead of withAsync?
16:09:31 <dwcook> async and wait that is
16:09:39 <dwcook> That way it's more sequential less nested
16:11:01 <qwebirc97943> that could work but would i lose autocancel when one of them failed?
16:11:24 <snyp> Based on what does Haskell evaluate a thunk (of the full expression) and leave another thunk unevaluated?
16:12:05 <mzero> when it needs to evaluated value: either because it wants to inspect it for a case expression ("Is this a Just or a Nothing?")
16:12:40 <mzero> or because a primitive needs the value ("putStrLn /really/ needs the characters)
16:12:49 <ski> the latter can be thought of as a special case of the former
16:13:17 <mzero> indeed, but generally isn't obviously so
16:13:25 * ski nods
16:13:44 <ski> (and the mystery of how I/O-actions are executed is still left here)
16:15:31 <snyp> Does this behavior only apply to value constructor expressions like "case Tree of Node data _ -> ...", or does it apply to functions too like x + y ?
16:15:33 <mzero> snyp: one thing that you should notice is that evaluating a thunk many not mean evaluating it "all the way down" ... if it is just looking at a case expression, and needing to know if it is, say Left x or Right y.... x and y will be left "thunk'd" - those values aren't demanded, just which constructor is needed
16:15:50 <mzero> x + y is just normal function application
16:16:00 <mzero> so, no, that is just a thunk for (+) x y
16:16:27 <mzero> but anything "case like":  if and patterns   are essentially case, and require looking
16:16:32 <mzero> at least one level in
16:16:46 <ski> forcing `x + y', you could think of that conceptually (in case of `Int', say) as doing a huge `case' on `x' and on `y'
16:16:57 <snyp> "case lst of x:xs -> x"         How does haskell know not to evaluate xs's thunk?
16:17:23 <benzrf> snyp: it doesnt eval in general
16:17:24 <mzero> well, it isn't evaluating the thunk for x or the thunk for xs
16:17:25 <ski> because variables are just bound to thunks, without forcing them
16:17:39 <mzero> only the thunk that results in either     (:) x xs     or  the     []   case
16:17:40 <ski> well, it *is* evaluating the thunk for `x'
16:17:43 <benzrf> > case (1:undefined) of x:xs -> x
16:17:44 <lambdabot>  1
16:17:51 <ski> because `x' is what is returned by that `case' expression
16:18:01 <mzero> no no - it just returns that thunk
16:18:01 <mzero> !
16:18:11 <mzero> only the thunk for lst gets forced
16:18:17 <mzero> and only one "level" deep
16:18:23 <snyp> mzero, i see
16:18:35 <ski> and the `case' expression itself wouldn't have started evaluating (being forced), unless its return value was demanded, so we already know `x' is going to be forced also here
16:18:55 <snyp> mzero, then when is x's thunk forced?
16:19:09 <mzero> later
16:19:23 <ski> snyp : directly after the `case' expression has forced `lst', and successfully matched it to `x:xs'
16:19:25 <mzero> though, as ski points out.... in this case, we can reason that that will be "soon ish"
16:19:52 <mzero> but I think you can understand this in isolation --- and hence, x being evaluated or no, is immaterial
16:20:31 <snyp> hmm
16:20:40 <mzero> consider      case lst of x:xs -> "z" ++ x ;  []  - "y"
16:20:46 <mzero> consider      case lst of x:xs -> "z" ++ x ;  []  -> "y"
16:20:50 <ski> (note that we're talking here about the obvious graph rewriting model -- an actual implementation may reorder the forcing of thunks, in case it can prove the observed result will still be the same (it can even do more improvements, rearranging code even more with fusion and so on))
16:21:07 <mzero> if this value is demanded (the value of the case), lst will be forced so we can see if it is (:) or []
16:21:17 <mzero> and then.... another thunk will be returned   (++) "z"  x
16:21:22 <mzero> where x will NOT have been forced
16:21:31 <donri> qwebirc97943: what about using Concurrently?
16:21:43 <snyp> mzero, ah
16:22:18 <mzero> yes - we are talking about understanding the simple execution model --- not the one that GHC, with all it's analysis, might do
16:22:30 <donri> qwebirc97943: or ResourceT/SafeT to handle cleanup
16:22:52 <mzero> but - if you understand the simple model - and you understand why your code works under it --- then GHC's improvelments are only a bonus
16:23:59 <ski> snyp : monochrom's "Lazy Evaluation of Haskell" at <http://www.vex.net/~trebla/haskell/lazy.xhtml> may be helpful, if you can handle it yet
16:24:58 <aprescott> hi, i'm learning haskell and i'm wondering why let factorial n = product [1..n] will give factorial a type of (Num a, Enum a) => a -> a and what the typeclass tuple means exactly. in what sense can a type be in the Num typeclass and the Enum typeclass?
16:25:22 <aprescott> (the type converts to Integer -> Integer if you of course specify that factorial :: Integer -> Integer first :))
16:25:24 <ski> @type let fromOne n = [1 ... n] in fromOne
16:25:25 <lambdabot> (Plated c, Applicative f, Num (LensLike f s t c c)) => Over p f c c a b -> [Over p f s t a b]
16:25:31 <ski> err
16:25:33 <ski> @type let fromOne n = [1 .. n]
16:25:34 <lambdabot> <no location info>: not an expression: ‘let fromOne n = [1 .. n]’
16:25:43 <ski> @type let fromOne n = [1 .. n] in fromOne
16:25:43 <lambdabot> (Num t, Enum t) => t -> [t]
16:25:45 <ski> i meant
16:25:46 <donri> aprescott: type classes are more like interfaces than object classes
16:25:55 <ski> @type \n -> [1 .. n]
16:25:56 <lambdabot> (Num t, Enum t) => t -> [t]
16:26:10 <ski> @pl \n -> [1 .. n]
16:26:10 <lambdabot> enumFromTo 1
16:26:24 <ski> @type enumFromTo
16:26:24 <lambdabot> Enum a => a -> a -> [a]
16:26:46 <donri> @undo [1..n]
16:26:46 <lambdabot> [1 .. n]
16:26:52 <donri> guess it's no @desugar
16:26:56 <ski> donri : already tried that :)
16:27:10 <ski> aprescott : `Num' because of `1' and `product'
16:27:13 <ski> @type 1
16:27:14 <lambdabot> Num a => a
16:27:15 <ski> @type product
16:27:16 <lambdabot> Num a => [a] -> a
16:27:38 <aprescott> the Num a part makes sense, i just don't quite understand what the tuple in the constraint means
16:27:54 <aprescott> is it just the combination of both constraints on a?
16:27:55 <ski> aprescott : and `Enum' because of the `[lo .. hi]' syntax, which is sugar for `enumFromTo lo hi'
16:28:15 <ski> aprescott : yes, it means the conjunction (the "and") of the two individual constraints
16:28:56 <ski> for any type `a', if `Enum a' and `Num a' are both true, then `factorial' may have type `a -> a'
16:29:01 <ski> that's what the type is saying
16:29:59 <aprescott> hm, still don't quite see it
16:30:25 <aprescott> is it wrong to view the 'Enum a' constraint as applying to the argument to 'factorial' ?
16:30:30 <ski> yes
16:30:44 <ski> `Enum' is applying to the type variable `a'
16:31:01 <aprescott> uh, heh, yeah that's what i meant :)
16:31:04 <ski> then that type variable happens to be mentioned both amongst the argument type and the return type of the function
16:31:20 <ski> however, consider
16:31:21 <aprescott> in my head, that's suggesting that, say, Integer a must be enumerable?
16:31:21 <kazagistar> :t read
16:31:22 <lambdabot> Read a => String -> a
16:31:23 <ski> @type sort
16:31:23 <lambdabot> Ord a => [a] -> [a]
16:31:59 <ski> here `Ord' in `Ord a' is definitely not applying to the argument to the function (which is of type `[a]', which *mentions* `a', but isn't `a')
16:32:07 <mzero> aprescott: Integer is enumerable!
16:32:28 <ski> yes, if we set the type variable `a' to `Integer'
16:32:33 <aprescott> is a value that is an Integer also enumerable?
16:32:36 <ski> i.e. we specialize from
16:32:45 <ski>   factorial :: (Num a,Enum a) => a -> a
16:32:46 <ski> to
16:32:58 <ski>   factorial :: (Num Integer,Enum Integer) => Integer -> Integer
16:33:37 <ski> then since we know `Num Integer' and also `Enum Integer' holds (since `Integer' is an instance of both `Num' and `Enum', we can then simplify this specialization (this particular *use* of `factorial') to
16:33:42 <ski>   factorial :: Integer -> Integer
16:33:53 <aprescott> in what sense is Integer an instance of Enum? that doesn't quite make sense to me?
16:34:07 <ski> someone has written code somewhere somewhat like
16:34:11 <mzero> aprescott: we say "Integer has an instnace of Enum", meaning that the functions mentioned in the typeclass Enum can be applied to values of the type Integer   ---   loosely, you can use enumerable functions on values of type Integer
16:34:14 <ski>   instance Enum Integer
16:34:16 <ski>     where
16:34:21 <ski>     succ n = ..n..
16:34:23 <ski>     ...
16:34:33 <donri> > succ 99 :: Integer
16:34:34 <lambdabot>  100
16:34:39 <ski> implementing the methods of the typeclass `Enum' for the specific case of `Integer'
16:34:44 <ski> @src Enum
16:34:44 <lambdabot> class  Enum a   where
16:34:44 <lambdabot>     succ                     :: a -> a
16:34:44 <lambdabot>     pred                     :: a -> a
16:34:44 <lambdabot>     toEnum                   :: Int -> a
16:34:44 <lambdabot>     fromEnum                 :: a -> Int
16:34:46 <lambdabot> [3 @more lines]
16:34:54 <mzero> In the sense that "there is an implementation of Enum's interface (methods) for the class Integer"
16:34:54 <ski> @more
16:34:54 <lambdabot>     enumFrom                 :: a -> [a]
16:34:54 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
16:34:54 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
16:35:01 <aprescott> ohh, i see
16:35:13 <aprescott> it must be enumerable because otherwise you can't [1..n] it?
16:35:18 <mzero> correct
16:35:50 <aprescott> and [1..n] is just sugar for one of those Enumerable methods
16:35:52 <ski> <ski> aprescott : and `Enum' because of the `[lo .. hi]' syntax, which is sugar for `enumFromTo lo hi'
16:35:58 <mzero>  [1..n]   is jsut     enumFromTo 1 n
16:36:04 <aprescott> haha that makes sense
16:36:14 <mzero> :t enumFromTo
16:36:14 <lambdabot> Enum a => a -> a -> [a]
16:36:36 <mzero> and you need to know that
16:36:38 <aprescott> and once you specify that factorial :: Integer -> Integer then all of this is obvious, since Integer is an instance of Enum?
16:36:40 <mzero> :t 1
16:36:41 <lambdabot> Num a => a
16:36:54 <mzero> so.....
16:36:57 <aprescott> "obvious" meaning that it's part of the definition of Integer
16:37:02 <ski> no
16:37:14 <ski> it's an additional piece of code
16:37:36 <mzero> Integers are just data
16:37:57 <ski> if you want, you could consider it to "belong" to the integer operations, just like other basic operations on them
16:38:11 <aprescott> what i mean is that saying that a is an Integer implicitly says that it's (Num a, Enum a)
16:38:16 <geekosaur> aprescott, the Enum instance for Integer is one of the things that is in the standard Prelude, so you can assume it's always "around".
16:38:26 <mzero> :info Integer
16:38:44 <geekosaur> but it's not some kind of built-in magic; you could in theory replace the standard Prelude with one which didn't have such an instance. or even one which doesn't define Integer
16:38:45 <kazagistar> aprescott: it made more sense to me once I learned how the language actually compiles it... something like { (Eq a) => [a] -> [a] }  compiles to something like { Eq a -> [a] -> [a] } where data Eq = Eq { (==) :: a -> a -> Bool; (\=) :: a -> a -> Bool }
16:38:51 <geekosaur> no :info in lambdabot
16:38:58 <ski> but if you have defined a new type `Foo', then assuming you haven't made `Foo' an instance of some typeclass `C', it is possible for someone else (in another module) to make it an instance of `C', assuming they can make a sensible definition of the typeclass methods for it
16:39:00 <kazagistar> as an intermediate step, before it usually gets inlined
16:39:35 <mzero> well, aprescott, it isn't implicit - it is because of what code you have in scope....      I could define a new typeclass   Foo    and define an instance of Foo for Integer .... all without any help or consent from the Integer type itself
16:39:58 <aprescott> i think i follow
16:40:25 <mzero> The standard Prelude, has, for Integer, instances of Enum, Eq, Integral, Num, Ord, Read, Real, and Show
16:40:49 <aprescott> i was working on the assumption that we were in Prelude, but what you're all basically saying is that this isn't how things Must Be
16:41:04 <geekosaur> funny, that's how I'm understanding what *you* said
16:41:19 <mzero> or, more to the point, they aren't "special"
16:41:23 <aprescott> right
16:41:26 <geekosaur> whereas the reality is that the compiler has seen somewhere (Prelude) the necessary declarations
16:41:36 <aprescott> makes sense
16:42:01 <aprescott> thanks! i'm sure i'll be back eventually with more questions :)
16:42:40 <donri> @check take 99 (iterate succ 0) == [0..99]
16:42:42 <lambdabot>  *** Failed! Falsifiable (after 1 test):
16:42:45 <donri> :(
16:43:07 <dmwit> off by one
16:43:15 <dmwit> ?check take 100 (iterate succ 0) == [0..99]
16:43:16 <lambdabot>  +++ OK, passed 1 tests.
16:43:36 <donri> :)
16:43:46 <kazagistar> length [0..99]
16:43:50 <kazagistar> er
16:43:54 <ski> @check \n -> take (succ n) (iterate succ 0) == [0 .. n]
16:43:55 <lambdabot>  +++ OK, passed 100 tests.
16:43:56 <kazagistar> > length [0..99]
16:43:58 <lambdabot>  100
16:44:30 <kazagistar> no silly stuff like in python where we exclude the last element :D
16:44:42 <kazagistar> or something
16:44:43 <donri> what i wanted to demonstrate anyway is what Enum has to do with the [..] syntax, without involving the lesser-known enum* functions
16:44:51 <ski> kazagistar : well, that can also be useful
16:46:02 <kazagistar> usually because you insist on starting lists from 0
16:46:11 <dmwit> > [..] :: [Int]
16:46:12 <lambdabot>  <hint>:1:2: parse error on input ‘..’
16:46:19 <ski> nice try
16:46:20 <dmwit> that wasn't a very good hint
16:46:46 <donri> odd, that should be a valid lens
16:46:50 * donri smirk
16:46:59 <geekosaur> heh
16:47:00 <kazagistar> ha.. ha...
16:49:31 * ski . o O ( "Why numbering should start at zero" (EWD 831) by Edsger Wybe Dijkstra in 1982-08-11 at <http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html> )
16:51:01 <pleax> ski: may i ask about defining instances in another module then type itself?
16:51:17 * ski . o O ( "foof-loop: A Simple, Extensible Scheme Looping Facility" (section "Iterating over Numbers") by Riastradh in 2009-07-22 at <https://mumble.net/~campbell/scheme/foof-loop.txt> : "Lower bounds are inclusive.  Upper bounds are exclusive" )
16:51:28 <ski> pleax : go ahead ?
16:51:47 <pleax> ski: isn't it is so called "orphan" instance?
16:51:55 <ski> yes
16:52:21 <pleax> ski: as i know it is not recommended technique
16:52:22 <ski> at least if it's neither defined in the module defining the type, nor the module defining the typeclass
16:52:39 <ski> (or i suppose some related module in the same package could also work)
16:52:46 <ski> pleax : yes
16:53:14 <dmwit> pleax: It is not recommended because it makes it very easy to define clashing instances.
16:53:39 <dmwit> pleax: If the instance is next to the class, or next to the type, then by the time you have everything in scope to define an instance you have the instance too. So the compiler can tell you you screwed up.
16:54:14 <dmwit> pleax: If the instance is not next to the class or next to the type, two different modules could easily define an instance and never mention each other, making it much more difficult for the compiler to notice the problem until it is too late.
16:54:26 <ski> this is also related to the fact that instances are contagious in Haskell
16:54:54 <ski> you can't not export an instance (and it continues transitively from imported modules)
16:58:22 <pleax> they looks kind of similar to implicits in scala
16:58:30 <pleax> which is very useful sometimes
17:00:09 <ski> yeah, but iirc, implicits don't guarantee coherence
17:01:01 <ski> so that you could possibly have more than one instance of `Ord' for some type, though not both active in the same pieces of code
17:01:28 <pleax> yep
17:01:33 <ski> still, that can cause trouble. consider a `Set' or a `Map' which is internally represented in some sorted fashion, using the ordering on the keys
17:01:58 <pleax> like plus and product groups are both valid
17:02:33 <ski> you don't want to be able to pass such a set or map into a different context, where another `Ord' instance is in force, and there call some function accepting it, that requires an `Ord' instance, that will in this case pick up the wrong instance, ensuing confusion
17:02:52 <ski> with the design in Haskell, such can't happen
17:09:11 <pleax> ski: not sure it's good example actually :)
17:09:28 <neroghutyun> can I ask a general programming question in here? It's a bit long and drawn out, so I'm asking to ask so I dont waste my and the channels time in the wrong place :)
17:10:03 <pharaun> somewhat related with haskell ?
17:10:40 <neroghutyun> not in any way realted to haskell, other than haskell=programminglanguage=whatmyquestionisabout
17:10:55 <pleax> ski: when you passing +group in context where *group is expected looks more like a implementation problem
17:12:31 <pleax> ski: or i just did't get a point :)
17:12:38 <ski> that's different
17:13:03 <ski> the point of `Ord' for `Set' and `Map' is just for performance, it just needs some total ordering, it doesn't matter which one
17:13:32 <ski> but the operations need to consistently use the *same* one still, on every data structure instance manipulated by them
17:13:55 <ski> it's possible to fake something ML-functor like with existentials
17:14:04 <ski> s/ like/-like/
17:14:46 <ski> neroghutyun : seems pretty quiet atm. go ahead and we'll see ?
17:15:34 <neroghutyun> I can't program. I've tried to learn several diffeent languages several different times using tutorials like codeacademy, but they never make me feel confident enough to go and write my own *real* program.
17:15:48 <neroghutyun> I'm already a very techy guy. I maintain AUR packages
17:15:50 <pleax> ski: which one Ord is used (if multiple instances exist) shoul be kind of incapsulated inside data structure manipulation functions
17:16:03 <neroghutyun> but I'm wondering if there's a better resource I've missed
17:16:16 <byorgey> neroghutyun: confidence is not a prerequisite to writing your own programs.
17:16:36 <neroghutyun> byorgey: the reason my confidence is low is because my skill is low
17:16:40 <pleax> ski: and which one is actually used should be irrelevant for external code
17:16:58 <ski> neroghutyun : perhaps you need to scratch an inch, by writing some small program that's at least remotely useful to you
17:17:38 * ski is assuming neroghutyun has already tried writing various exercise and toy programs suggested in various places
17:18:18 <ski> pleax : "shoul be kind of incapsulated inside data structure manipulation functions" -- yes, but how to make that work with `merge'/`union' -like operations ?
17:18:21 <neroghutyun> excercise and toy programs?
17:19:34 <pleax> ski: you mean if there are two implementations of Map for example with different Ord instances?
17:19:52 <ski> neroghutyun : i meant like Project Euler, e.g.
17:20:48 <neroghutyun> I feel like the various tutorials on the web seem to teach me a superficial understanding of the language, and make it very accessible to the point where my grandma could learn it. I'm not my grandma however, and I'm just craving a deeper understanding
17:20:54 <ski> pleax : no, i was talking about a single implementation, but where you've (somehow) managed to build two map data structures with the same key type, but still using different `Ord' instances for them
17:21:40 <ski> neroghutyun : well, i suppose you need to practice more
17:21:58 <ski> listening and helping out in a learning community can also help
17:23:47 <ski> pleax : if you go the existential route, you can actually solve that `merge'/`union' problem
17:25:08 <ski> neroghutyun : if you want to learn more about type system stuff, ior data structures and algorithms, you could also attempt reading relevant papers
17:25:20 <ski> (not quite the same thing, perhaps, but can also be useful)
17:26:13 <pleax> ski: i'm trying to imagine how it may look in scala's implicits
17:26:16 <neroghutyun> alright, I'll take that into account. I'd never seen project euler before, and I'm liking it alot
17:26:22 <pharaun> its a great site
17:26:42 <pleax> ski: and the problem is implicit isn't tied to original class
17:26:54 <ski> pleax : not sure whether you can do existentials in Scala
17:27:11 <pleax> ski: it's more like boxing over original object
17:27:20 * hackagebot machinecell 1.1.0 - Arrow based stream transducers  http://hackage.haskell.org/package/machinecell-1.1.0 (HidenoriAzuma)
17:28:12 <ski> ("it" being ? existentials ?)
17:29:02 <pleax> ski: probably i should learn more about haskell internals to do such conversations :)
17:29:19 <pleax> ski: very hard to argue :)
17:29:56 * ski thinks it's good to understand existentials, for programming in general
17:30:33 <ski> (seeing how they're also related to closures and objects, and abstract data types)
17:31:04 <pleax> ski: could you suggest something to read?
17:35:15 <benzrf> > http://foo.bar/baz
17:35:17 <lambdabot>  Not in scope: ‘http’Not in scope: ‘foo’
17:35:17 <lambdabot>  Perhaps you meant ‘T.for’ (imported from Data.Traversable)Not in scope: data...
17:35:17 <lambdabot>  Perhaps you meant one of these:
17:35:17 <lambdabot>    ‘Sym.var’ (imported from Data.Number.Symbolic),
17:35:17 <lambdabot>    ‘var’ (imported from Debug.SimpleReflect)Not in scope: ‘baz’
17:35:20 <benzrf> hmmmmmm
17:35:48 <meretrix> Is there any fundamental difference between writing (== LT) and pattern matching on LT?
17:35:53 <benzrf> @let data Protocol = Protocol String
17:35:55 <lambdabot>  Defined.
17:36:01 <benzrf> @let http = Protocol "http"
17:36:02 <lambdabot>  Defined.
17:36:27 <benzrf> @let data URL = Protocol :// String -> String
17:36:27 <lambdabot>  Parse failed: Parse error: ->
17:36:31 <benzrf> @let data URL = Protocol :// (String -> String)
17:36:33 <lambdabot>  Defined.
17:37:05 <benzrf> @let com = (".com"++)
17:37:06 <lambdabot>  Defined.
17:37:17 <benzrf> @let google = ("google"++)
17:37:18 <lambdabot>  Defined.
17:37:22 <benzrf> @let www = ("www."++)
17:37:23 <lambdabot>  Defined.
17:37:36 <jasonjckn> @www
17:37:36 <lambdabot> Maybe you meant: yow wn
17:38:08 <benzrf> @let instance Show URL where show ((Protocol p)://body) = p ++ body ""
17:38:09 <lambdabot>  Defined.
17:38:16 <benzrf> > http://www.google.com
17:38:17 <lambdabot>  Precedence parsing error
17:38:17 <lambdabot>      cannot mix ‘L.://’ [infixl 9] and ‘GHC.Base..’ [infixr 9] in the same in...
17:38:19 <benzrf> :[
17:38:30 <benzrf> @let infix :// 1
17:38:30 <lambdabot>  Parse failed: Parse error: 1
17:38:34 <benzrf> @let infix 1 ://
17:38:35 <lambdabot>  Defined.
17:38:37 <benzrf> > http://www.google.com
17:38:39 <lambdabot>  httpwww.google.com
17:38:40 <benzrf> :3
17:38:47 <benzrf> oh crud i messed that up
17:38:51 <pleax> ski: and in general, is using language extensions "ok"? or it is experimental features, which may never be a part of language?
17:38:52 <jasonjckn> @help
17:38:52 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:39:04 <jasonjckn> @help list
17:39:04 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
17:39:16 <dwcook> pleax, some extensions are quite well used, like TemplateHaskell or MultiParameterTypeClasses
17:39:40 <dwcook> pleax, since GHC is the de facto standard, it's often seen as okay to tailor code to it, but if you don't want to then that's fine too
17:40:55 <pleax> dwcook: is there list of "stable" extensions? which are most widely used?
17:41:01 <dwcook> Good question
17:41:03 <camlorn> Do the <- and -> symbols have any special meaning outside the do notation and case of expressions?
17:41:19 <benzrf> camlorn: you cant use them
17:41:25 <benzrf> they're special tokens
17:41:31 <dwcook> pleax, found this https://stackoverflow.com/questions/801785/should-i-use-ghc-haskell-extensions-or-not
17:41:31 <benzrf> @let (->) = (.)
17:41:31 <lambdabot>  Parse failed: Parse error: ->
17:41:34 <benzrf> ^se
17:41:34 <benzrf> e
17:42:16 <camlorn> So -> only appears in types and <- only appears in do/case?
17:42:26 <pleax> dwcook: oh, SO. i should try it myself :)
17:42:36 <pleax> dwcook: thanks a lot
17:42:37 <triliyn> -> also appears in lambda expressions
17:42:38 <geekosaur> -> also occurs in lambda expressions (anonymous functions)
17:42:46 <dwcook> I was almost a third echo
17:42:47 <triliyn> And <- occurs in the syntax used by a few extensions
17:43:12 <camlorn> I get that I can't go start using them as variables, heh.  I'm just surprised that I'm not finding some sort of higher meaning (yes, I know that -> is the type constructor for a function type)
17:43:52 <dwcook> camlorn, there isn't exactly a semantic common thread between their usages, it's mostly a matter of what draws the right picture
17:44:11 <dwcook> a -> b as a function makes sense because it goes from an a to a b
17:44:16 <dwcook> and so on
17:44:25 <camlorn> dwcook:  Hey, if it's one of the things that is really as simple as it looks, I'll take it.
17:45:25 <benzrf> camlorn: <- is not used in case
17:45:34 <benzrf> it *is* used in pattern gaurds
17:45:43 <camlorn> Erg. you're right.
17:46:01 <camlorn> I consistently get the case syntax wrong, I must confess.  I like to use = there.
17:46:23 <Lutin`> Well case does use =
17:46:27 <dwcook> camlorn, = tends to be used for things that actually could be substituted one for the other
17:46:29 <Lutin`> for normal guards
17:46:41 <camlorn> O, no, I conceptually get it.  i sstill type the wrong thing.
17:46:41 <Lutin`> where before the = is a boolean expression
17:46:44 <dwcook> camlorn, whereas case is more of a mapping
17:46:48 <lfairy> yeah, = is for declarations, -> is for expressions
17:47:00 <Lutin`> sorry not case
17:47:04 <Lutin`> meant guards
17:48:06 <benzrf> it's all very arbitrary tsk
17:48:28 <dwcook> It is, but it seems to basically make sense on the whole, I think
17:48:36 <camlorn> There is a gap between my intellectual understanding of Haskell, such that it is, and my ability to clearly recall Haskell syntax without looking at my learning code from yesterday.
17:48:54 <dwcook> camlorn, fortunately that's the sort of thing that closes quickly as you use the language more :)
17:49:00 <aprescott> what's the reason for this behaviour? https://gist.github.com/anonymous/7859670d36f6b993a943
17:49:15 <benzrf> aprescott: not enough discipline
17:49:47 <aprescott> i would expect maybe slowMaximum to be twice as slow as fastMaximum, but...
17:50:23 <dwcook> aprescott, one problem I see with slowMaximum is that you can't complete the first step without doing all the others
17:50:27 <camlorn> dwcook:  True. And I intend to use the language more.  I'm seeing an odd sort of thing wherein it looks like Haskell is a superset of imperative programming, and want to at least get far enough to satisfy myself as to if it's true or not.
17:50:53 <dwcook> aprescott, namely, you need slowMaximum on the next structurally smaller piece in order to compute the current step
17:51:04 <benzrf> camlorn: its not
17:51:29 <aprescott> dwcook: isn't this true of fastMaximum too?
17:51:35 <dwcook> camlorn, there are times when you can think of something you're doing in Haskell as imperative, but really it's all manipulating types and expressions, for the most part
17:51:58 <dwcook> aprescott, oh I see, slowMaximum computes the same thing twice
17:52:12 <dwcook> aprescott, but yes, they both seem to have that problem
17:52:35 <aprescott> dwcook: slowMaximum hangs for so long that i have to just ^C it
17:52:46 <camlorn> benzrf:  Really?  it kind of looks like I can make loops into Monads, introduce the necessary dependencies to get stuff running in a defined order with monads, and have side effects.  Not that I fully understand monads.  I'm not saying that I can invent C++ in haskell, but that I can express C++ ideas in Haskell in addition to Haskell ideas
17:52:58 <benzrf> well, duh
17:53:01 <benzrf> you can also do the reverse
17:53:03 <dwcook> aprescott, are you sure it doesn't ever complete? I haven't run it, just eyeballing it so far, but it looks basically workable if inefficient
17:53:07 <benzrf> that doesnt make one a superset of the other
17:53:19 <benzrf> if anything, imperative langs are supersets of functional langs
17:53:25 <aprescott> dwcook: it completes fairly quickly for [1..10]
17:53:26 <benzrf> since they have expressions and also statements
17:53:48 <aprescott> dwcook: well, instantly in human terms :) i haven't measured it (because i don't know how yet)
17:53:56 <dwcook> aprescott, understood
17:54:09 <dwcook> aprescott, I think I basically figured out the problem - at *each step* you compute the next step twice
17:54:17 <dwcook> aprescott, that's an exponential increase
17:54:34 <camlorn> benzrf:  the funny thing is that it doesn't feel that way to me.  I'm not going to go try to use Haskell as an imperative language-I believe that is a mistake.  But I'm not immediately thinking of ideas from imperative languages that I can't express if needed, especially if I allow for using IORefs or some other form of faked mutability.
17:55:06 <aprescott> dwcook: oh, yeah, d'uh.
17:55:37 <camlorn> benzrf:  But in all honesty, my understanding of Haskell is still shaky.  Ask me again in a week or two. heh.
17:55:40 <aprescott> dwcook: so is the fast version not optimised as a tail-call thing?
17:56:07 <dwcook> aprescott, tail calls (take on a new / lose their) meaning in a non-strict language like Haskell
17:56:55 <dwcook> aprescott, the only difference I can see between them is what I already said. The problem is you wrote out the expression "slowMaximum xs" twice in the first function, as opposed to binding it to a variable and using that variable twice. The compiler may not be smart enough to know to reuse the value.
17:57:01 <ski> pleax : Wadler papers are fairly easy. or did you mean for existentials ?
17:57:31 <ski> pleax : well, both GHC and Hugs supports existentials, at least
17:57:58 <dwcook> aprescott, I'm not very familiar with the optimizations GHC does, but it's conceivable that if you compiled with -O2 or something they'd behave more similarly
17:58:08 <dwcook> (Someone else can opine here)
17:58:14 * ideasman-42_ waves, I was curious what haskell has over C/C++ for graphics --- raytracing for eg
17:58:51 <ideasman-42_> or if GC and being higher levevl makes haskell not a good choice
17:58:52 <aprescott> dwcook: yeah, i was a little confused as to why it couldn't remember that it already computed this value for the same input, but i'm just in ghci here
17:59:14 <dwcook> aprescott, there's a thing called common sub-expression elimination that might be relevant. Again, I know little about it.
18:00:28 <ideasman-42_> Id really like to experement with haskell for graphics programming, but I only saw toy projects mostly
18:00:29 <dwcook> ideasman-42_, I'll cite the standard advantages over C++ - abstraction and composability.
18:00:38 <ski> camlorn : `<-' is also in list comprehensions (and pattern guards)
18:00:44 <benzrf> camlorn: iorefs arent fake
18:00:50 <benzrf> theyre legitimately mutable
18:00:51 <ideasman-42_> yep, as a language its got amazingadvanteges
18:01:13 <ideasman-42_> yet - I assume GC slows down
18:01:17 <benzrf> they work on memory
18:01:26 <dwcook> ideasman-42_, Haskell libraries tend to work across a wider range of data and make it easier to combine things than C++
18:01:35 <camlorn> benzrf:  Maybe that was a bad word choice.  I mean that it's starting to escape the good parts of functional languages, or at least what others have said the good parts of functional languages are.
18:01:37 <ideasman-42_> ic
18:01:40 <ski> benzrf : they *reference* mutable things
18:01:50 <ideasman-42_> so you could do pathtracer in C
18:01:55 <benzrf> ski: bah
18:01:58 <ideasman-42_> but everything esle in haskell
18:02:12 <dwcook> ideasman-42_, that would indeed be possible, given Haskell's FFI
18:02:33 <dwcook> (Foreign Function Interface)
18:02:35 <ideasman-42_> I never wrote a serious raytracer
18:02:42 <ideasman-42_> but I help maintain one
18:02:52 <ideasman-42_> (blender 3d software)
18:03:04 <ski> (saying an `IORef a' itself is mutable is a bit like saying an `Int' used to index an `IntMap' is mutable .. in both cases, the store of the value is conceptually separate from the index/key / `IORef')
18:03:27 <camlorn> ideasman-42_:  Don't worry about the gc, in almost any language.  The gc is more worth it than it's not, given that we have basically 100 to 1000 times the cpu than the people who originally invented half the algorithms for that kind of thing.
18:03:28 <ski> (s/`IntMap'/`IntMap a'/)
18:03:58 <ideasman-42_> callumacrae: eeh, well - java apps stop the world for gc
18:04:06 <camlorn> ideasman-42_:  And getting memory allocation/deallocation right yourself is not worth the extra development time, until the gc really prooves to legitimately be a problem.
18:04:06 <ideasman-42_> and even go - allows disabling
18:04:16 <ideasman-42_> I would argue it is
18:04:31 <ideasman-42_> We do it - and its managable
18:04:43 <ideasman-42_> but we also embed python
18:05:03 <ideasman-42_> so for tasks not speed intesive - we use a GC I suppose
18:05:42 <ideasman-42_> we also wrap malloc and track allocs by name, without that leaks would be harder to track
18:06:28 <camlorn> ideasman-42_:  I'm not saying it can't be done, nor that it's not necessary in some cases.  And you can't get it out of old software once it's written.  But we've got oodles and oodles of CPU, and it's only growing.  Focus on things like parallel algorithms, not "time for malloc/free for performance."  You can go therre when you have to. I do not advocate going there before that point.
18:07:03 <ideasman-42_> for graphics software CPU is not oodles :0
18:07:22 <ideasman-42_> People expect multi million polygon scenes raytraced
18:07:34 <ideasman-42_> but point taken
18:07:44 <ideasman-42_> in many cases CPU isnt bottlneck
18:07:57 <ideasman-42_> just for graphics code it often is
18:08:04 <ideasman-42_> you want everything to be realtime
18:08:13 <ideasman-42_> but many computations are slow
18:08:29 <Lutin`> You can use the GPU
18:08:33 <ideasman-42_> hehe
18:08:35 <ideasman-42_> we do
18:08:45 <Lutin`> But yeah still not realtime with path tracing
18:08:48 <ideasman-42_> and its not blanket solution either
18:08:56 <Lutin`> at least not without noise
18:09:02 <ideasman-42_> yeah
18:09:18 <ideasman-42_> we have realtime - but noisy - as many others do
18:09:27 <ideasman-42_> refines to get better
18:09:34 <Lutin`> yep, I think I've used it
18:09:47 <ideasman-42_> Cycles raytracer?
18:10:19 <Lutin`> Ah, no
18:10:34 <camlorn> Actually, it's an interesting question.  Haskell's laziness and raytracing.
18:10:55 <camlorn> I wonder if there's some way to take advantage of that somehow, but I'm not familiar enough with the algorithms.
18:11:24 <ideasman-42_> I expect a lot of modern optimizations are quite hardware spesific
18:11:25 <snyp> (->) is the type constructor for functions.. is there a value constructor for functions(or is it conceptual?)
18:11:47 <ideasman-42_> using SSE and casting arrays in batches
18:12:13 <ideasman-42_> but still, a haskell raytracer could have own advantages
18:12:26 <ideasman-42_> even if raww performance isnt 100% of others
18:12:55 <dwcook> snyp, not really. You can use lambdas to create arbitrary functions though.
18:12:58 <ski> snyp : no value constructor
18:13:14 <kqr> i really like the new stream API in java 8
18:13:24 <kqr> but man do i sometimes ask myself "why didn't they do it like in haskell"
18:13:27 <ski> (conceptually, functions are a bit more like codata than data. but not quite that either)
18:13:32 <snyp> dwcook, i see.
18:14:18 <camlorn> how doe sgc work in haskell anyway?
18:14:39 <camlorn> I'm kinda conceptualizing it as some sort of refcounting, but Haskell breaks all the other rules so...
18:15:26 <ideasman-42_> heading off o/
18:15:39 <camlorn> ideasman-42_:  Also, there is at least one haskell library for accellerating on the GPU. cna't remember the name though.
18:15:49 <dwcook> Is it called accelerate?
18:16:00 <camlorn> Ah, yeah. Think so.
18:17:03 <camlorn> Not sure if it's any good. I've not used it, it's just something I saw.
18:20:08 <phaazon> http://devskypers.blogspot.fr/2014/07/lost-in-space.html if you have an idea, please be my guest!
18:22:42 <carlosgaldino> what's the best cabal tutorial?
18:23:06 <mzero> I'm not sure I've ever seen one
18:23:24 <phaazon> carlosgaldino: cabal init
18:23:27 <zereraz> Hi everyone, I am new to haskell and have a small doubt. I was learning how in haskell if more than 1 arguments,then first the function accepts 1 argument and then returns another function that takes the other argument and so on. I saw this example multi x y z, so first multi takes x and returns multi x, this is where I don't understand what multi x is? is it like function(x,new argument) ?
18:23:30 <phaazon> it’s a really nice tutorial
18:23:48 <phaazon> zereraz: that’s called curifying, yep
18:24:01 <benzrf> *currying
18:24:05 <sipa> zereraz: (+) 5 is the function that adds 5 to a number
18:24:07 <phaazon> yeah
18:24:09 <phaazon> currying
18:24:10 <sipa> > ((+) 5) 3
18:24:11 <carlosgaldino> I was looking at this one: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
18:24:12 <lambdabot>  8
18:24:20 <carlosgaldino> not sure if it's updated
18:24:37 <phaazon> zereraz: multi x is the partially applied multi function
18:24:39 <zereraz> so I should understand currying
18:24:51 <mzero> zereraz:  yes, but it isn't that hard
18:24:52 <phaazon> it’s “another” function with x placed as first argument
18:24:58 <zereraz> phaazon: what would it look like in imperative terms
18:25:14 <Tekmo> `f x y z` is the same thing as `((f x) y) z`
18:25:16 <zereraz> phaazon: so its what I wrote with x as first argument
18:25:19 <mzero> it really isn't an imperative / functional thing
18:25:24 <Tekmo> In imperative form it would look like `f(x)(y)(z)`
18:25:36 <phaazon> it’s a lazy stuff I guess
18:25:36 <snyp> ski, the book i am reading, the author says haskell evaluates until it sees a constructor, then it just leaves the fields of the constructor are left as thunks until further computation requires the data enclosed by them. http://ideone.com/786i90 in line 4, the application of " sumForce' rst s " , is that evaluated, or just sent to the caller as a thunk? sumForce' rst s does not seem like a constructor, rather a function application.(ignore `seq` for now)
18:25:41 <mzero> consider this        add3 x y z = x + y + z
18:25:50 <sipa> zereraz: it's an object that knows to perform addition, and one of the arguments, and it's passed around unevaluated further until it gets a second argument to apply to it
18:25:50 <zereraz> but it remembers x then y and finally uses them with z?
18:25:55 <mzero> zereraz: so this is a function that adds 3 numbers, yes?
18:25:58 <snyp> s/leaves//
18:26:03 <Tekmo> zereraz: Yes
18:26:03 <phaazon> zereraz: imagine that doing multi x is like writing a lambda
18:26:11 <phaazon> \y z -> multi x y z
18:26:14 <phaazon> sorry
18:26:15 <snyp> s/it just leaves//
18:26:20 <phaazon> multi x == \y z -> multi x y z
18:26:25 <Tekmo> \x -> \y -> \z -> multi x y z
18:26:37 <mzero> you can think of     add3 7    as a function that is now waiting for two more arguments, and when filled in, will finish the add3 code
18:26:56 <ski> phaazon : not lazy
18:27:05 <mzero> and     add3 7 3    as a function that takes one argument, the reminaing one, and applies add3
18:27:27 <zereraz> ok so basically a function with 3 arguments is like 3 functions
18:27:32 <Tekmo> zereraz: Yes
18:27:41 <dwcook> zereraz, in fact that's reflected in the type
18:27:44 <zereraz> what happens in the end
18:27:53 <dwcook> A -> B -> C -> D is a function taking an A and giving a B -> C -> D
18:28:07 <Tekmo> zereraz: When you write something like: `f x y = x + y` it gets desugared to `f = \x -> \y -> x + y`
18:28:30 <zereraz> how does it remember x and y
18:28:33 <ski>   sumForce' (x:rst) acc = sumForce' rst $! x + acc  -- snyp
18:28:36 <zereraz> the final function
18:28:50 <zereraz> is there function scope?
18:28:52 <dwcook> zereraz, are you asking for implementation details?
18:28:52 <ski> @src ($!)
18:28:52 <lambdabot> f $! x = x `seq` f x
18:29:01 <Tekmo> zereraz: `f 1 = (\x -> \y -> x + y) 1 = \y -> 1 + y`
18:29:14 <dwcook> zereraz, ah, well, basically
18:29:15 <zereraz> I am trying to understand how 2 separate functions ultimately share that data
18:29:35 <Tekmo> zereraz: `f 1 2 = (\x -> \y -> x + y) 1 2 = (\y -> 1 + y) 2 = 1 + 2
18:29:43 <dwcook> zereraz, so in what Tekmo just wrote (Woah, Tekmo's on!) x is in scope in the lambda \y -> x + y, for example
18:30:12 <yogurt_truck> zereraz: what other languages do you know? Depending on your background, the following might ring a bell `function (a) { return function (b) { return function (c) { return a + b + c } } }`
18:30:15 <zereraz> I don't understand f`
18:30:19 <zereraz> `f*
18:30:29 <zereraz> I know javascript
18:30:36 <zereraz> so is it like closure?
18:30:49 <snyp> ski, yeah i just read that. what i wanna know is: why is the author doing this? is this because x + y would be left as a thunk and sent to sumForce?
18:30:51 <Cale> zereraz: closures are one possible implementation mechanism for functions
18:30:59 <dwcook> Tekmo, on another topic altogether, I found your responses to my emails extremely helpful, as well as your mmorph package from which I'm using hoist lift and such. I say this a bunch, but thanks again
18:31:12 <Tekmo> dwcook: You're welcome!
18:31:15 <ski> snyp : the original `sumForce xs' is only evaluated (forced) because someone demanded the result. so they demand the result of your initial helper call as well
18:31:22 <zereraz> Tekmo: I am not good at the basic syntax aswell, so not sure what `f means
18:31:37 <Tekmo> zereraz: Oh, sorry, I should have clarified that
18:31:44 <benzrf> zereraz: look
18:31:45 <Cale> zereraz: You can also just do graph reduction, where the occurrences of the parameters in the body of the function end up with arcs pointing to the argument.
18:31:45 <Tekmo> dwcook: Don't be afraid to ask for help any time
18:31:48 <benzrf> f a b c = ...
18:31:50 <Tekmo> dwcook: I enjoy answering questions like those
18:31:53 <benzrf> in javascript this would be
18:31:54 <dwcook> Tekmo, okay :)
18:31:55 <ski> snyp : and in the recursive case, they further demand the body of the `let', i.e. the tail-call, and so on, until the base case where `acc' is finally demanded
18:32:15 <benzrf> function(a){return function(b){return function(c){...}}}
18:32:20 <yogurt_truck> benzrf: I already showed the JS example :)
18:32:23 <benzrf> ah
18:32:41 <ski> snyp : the author is using `seq' here to make sure that a large computation isn't built up in `acc', only to be forced when the base case is reached
18:32:48 <Cale> zereraz: But that's all low-level nonsense which doesn't really matter to understanding the meaning. (\x -> (\y -> x + y)) 5 = (\y -> 5 + y)
18:32:53 <Tekmo> zereraz: When you write `f x y = x + y`, the javascript equivalent is `f = function(x) { return (function(y) { return x + y }) }`
18:33:04 <zereraz> Thank you everyone, I think I understand it is some sense .
18:33:05 <ski> snyp : instead, just before the recursive call, we explicitly ensure `s' is forced before passing it on
18:33:25 <Cale> zereraz: Just thinking of it in terms of substituting the function argument into the body of the function where the parameter occurs is sufficient to understand what's going on.
18:33:28 <yogurt_truck> (the problem with the JS example is that it carries connotations about things such as "closures" and other implementation-specific stuff, which is irrelevant)
18:33:50 <zereraz> 1 last thing is there function scope?
18:34:27 <Cale> zereraz: One important thing about lazy evaluation though is that if the function parameter (or any variable) occurs multiple times in the body of the function (or its scope), then any work done evaluating the argument it's bound to will be shared between the copies.
18:34:41 <Cale> i.e. you don't duplicate work
18:34:43 <ski> snyp : "is this because x + y would be left as a thunk and sent to sumForce?" -- yes, and without a Sufficiently Smart Compiler (SSC) [tm], that potentially big computation will then be left until the end (which might in some cases perhaps also smash the stack), as opposed to the better choice of doing this computation incrementally, by doing a little bit of it at each recursive step of the helper/worker
18:35:25 <zereraz> Cale: like referencing
18:35:42 <zereraz> Tekmo: what is y` mean?
18:35:52 <Cale> zereraz: If we have a program like  double x = x + x, and we write something like double (6 * 7), then even though lazy evaluation is outermost first, so we expand the definition of double before doing the multiplication, writing (6 * 7) + (6 * 7) might be a bit misleading about the operational behaviour
18:36:00 <ski> zereraz : probably just a closing quote
18:36:05 <snyp> ski, why would (x + y) be left as a thunk? (+) is a function application, not a constructor..
18:36:09 <Cale> It's more like it evaluates to  let x = 6 * 7 in x + x
18:36:10 <Tekmo> zereraz: I use backticks to surround code
18:36:24 <ski> snyp : i don't understand the question
18:36:26 <ski> consider
18:36:34 <ski>   sumForce' (x:rst) acc = sumForce' rst (x + acc)
18:36:41 <zereraz> Tekmo: ok thanks allot
18:36:50 <snyp> ok
18:36:50 <ski> in this case `x + acc' is not forced before the recursive call
18:37:16 <ski> `x + acc' will become the new `acc', and then a new `x' will be put in front of it, with addition
18:37:24 <zereraz> Cale: ok got that
18:37:40 <snyp> but the author says, haskell _evaluates_ until it reaches a constructor(or something like that)
18:37:49 <snyp> (+) is not a constructor..
18:37:58 <zereraz> Thanks everyone, this is my second time asking doubt here and both times people were very helpful. It encourages me to learn haskell! thanks again
18:38:07 <ski> when you reach the base case, your `acc' will essentially contain an unperformed computation/thunk `x0 + (x1 + (x2 + (..(x_{n-1} + 0)..)))'
18:38:30 <ski> snyp : it evaluates "from the outside, inwards"
18:38:46 <ski> snyp : function arguments are not evaluated before the function in a function call is called
18:38:52 <Tekmo> zereraz: You're welcome!
18:39:28 <snyp> aaaah
18:39:54 <ski> snyp : to be able to call the function, it must know which function to call, so it has to force the function expression in the application. but the argument is just passed on (in general), without being evaluated, unless it needs to be
18:41:18 <ski> (if the function is defined by pattern-matching on that formal parameter, at that point would the actual parameter need to be forced to the extent to determine whether it matched the pattern or not)
18:42:09 <ski>   sum xs = sumPlus xs 0
18:42:10 <ski>     where
18:42:25 <ski>     sumPlus [    ] acc = acc
18:42:58 <snyp> ski, in the second recursion, i would have acc + x, and this acc is the 0 + x_prev. And this is sent to sumForce' again. so now it's 0 + x_prev + x ... OK i get it. it does not evaluate the arguments, but what about the constructor rule, i can't seem to understand in terms of that rule.
18:43:06 <ski>     sumPlus (x:xs) acc = sumPlus xs (x + acc)
18:43:09 <ski> now consider
18:43:33 <ski>      sum (2:3:5:7:[])
18:43:43 <ski>   =  sumPlus (2:3:5:7:[]) 0
18:43:50 <ski>   =  sumPlus (3:5:7:[]) (2 + 0)
18:43:57 <ski>   =  sumPlus (5:7:[]) (3 + (2 + 0))
18:44:00 <snyp> ski, this i can understand in terms of that rule. coz (:) is a constructor.
18:44:04 <ski>   =  sumPlus (7:[]) (5 + (3 + (2 + 0)))
18:44:17 <ski>   =  sumPlus [] (7 + (5 + (3 + (2 + 0))))
18:44:21 <ski>   =  7 + (5 + (3 + (2 + 0)))
18:44:27 <ski>   =  7 + (5 + (3 + 2))
18:44:30 <ski>   =  7 + (5 + 5)
18:44:33 <ski>   =  7 + 10
18:44:35 <ski>   =  17
18:44:57 <snyp> yeah
18:45:01 <ski> note how the addition expression is first built up, and only after reaching the base case is it reduced
18:45:11 <ski> that's what we wanted to avoid
18:45:48 <ski> basically interleaving each addition with the recursion steps, so that we don't need to use space for the whole addition expression at the same time
18:46:51 <ski> snyp : in this case, "constuctor" means a final integer result like `17'
18:47:43 <ski> it kept evaluating (the "outside" of) the whole expression, until it reached a constructor (at the "outside")
18:48:54 <camlorn> value constructors are functions.  Given that, can I somehow pattern match on functions that aren't value constructors?
18:49:21 <dwcook> camlorn, not exactly. But, see the view patterns extension.
18:49:36 <dwcook> https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns
18:49:42 <ski> because `sumPlus' didn't match the second parameter with some pattern involving a constructor, instead just a variable `acc', that actual parameter didn't get forced when pattern-matching to select the appropriate defining equation clause to use (either the base case or the recursive case)
18:49:59 <ski> camlorn : `False' is a value constructor, it's not a function
18:50:21 <ski> camlorn : you can't match on functions at all
18:50:42 <ski> saying
18:51:02 <ski>   isSin sin = True
18:51:09 <ski>   isSin _   = False
18:51:11 <ski> doesn't work
18:51:22 <ski> if you meant something like
18:51:37 <ski>   last (_ ++ [x]) = x
18:51:49 <camlorn> ski:  But the type of Just is a->Maybe a, which is a function, right?
18:51:59 <ski> then you can do something like that with view patterns (or pattern guards), like dwcook said
18:52:12 <dwcook> camlorn, data constructors can be functions. Not every data constructor is a function. False is a counterexample.
18:52:14 <Welkin> Just is a constructor
18:52:39 <ski> camlorn : yes. you can't match on `Just'. you can match on `Just <pat>', where `<pat>' is some pattern (of the appropriate type)
18:52:48 <Welkin> functions start with a lowercase letter, constructors start with an uppercase
18:52:56 <Welkin> that is an easy way for beginners to tell
18:53:17 <ski> infix constructors start with `:'
18:53:26 <ski> other infix values doesn't
18:53:54 <camlorn> Welkin:  Yes, and until I got to the part of learn you a haskell for great good about functors, I left it at that.  I thought they were a special case, something akin to structs and c initializers.  And then I did :type Just.
18:53:56 <dwcook> Welkin, that seems a confusing way to state something else. Maybe s/functions/variables/? Although I'm not sure that's quite right either.
18:54:16 <dwcook> camlorn, do you agree that both False and Just are data constructors?
18:54:36 <camlorn> dwcook:  yes. And I take the point.
18:54:41 <dwcook> Okay. Just checking.
18:55:27 <ski> often we casually say that we match on `Just', when we really mean we match on `Just <pat>', for some pattern `<pat>'
18:55:46 <ski> as long as you're clear about what you (or someone else mean), it's ok
18:55:55 <Welkin> :t Just
18:55:56 <lambdabot> a -> Maybe a
18:56:06 <ski> (and similarly for other data constructors, of course)
18:57:15 <ski>   isJust :: (a -> Maybe a) -> True
18:57:19 <ski>   isJust Just = True
18:57:22 <camlorn> ski:  yeah. I'm not asking how to match on Just.  But it occurred to me that if a type constructor can be a function, maybe there's something going on with functions and patterns that I don't know about.  Thinking about it more though, I'm not sure how the compiler could roe a function backward unless it could also prove that it is one-to-one, so...nevermind.
18:57:23 <snyp> ski, i get it now. 17 is a value constructor right?
18:57:24 <ski>   isJust _    = False
18:57:29 <dwcook> ski, XD
18:57:30 <ski> that `isJust' ^ isn't possible
18:57:43 <snyp> as are 1, 2, 3 .. etc.
18:57:46 <ski> dwcook :D
18:57:48 <snyp> hmm
18:58:05 <ski> @type isJust
18:58:06 <lambdabot> Maybe a -> Bool
18:58:08 <dwcook> snyp, not quite. Numeric literals are special
18:58:08 <ski> is another thing
18:58:19 <snyp> dammit
18:58:44 <dwcook> http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1360006.4.1
18:58:52 <ski> camlorn : are you talking about type constructors or data constructors now ?
18:58:57 <snyp> i will just pretend everything is lazy and not evaluated. not gonna think about any rules and stuff anymore.
18:59:07 <camlorn> ski:  You know, I am not actually 100% sure.
18:59:14 <ski> camlorn : `Just' and `False' are data constructors. `Maybe' and `Bool' are type constructors
18:59:26 <dwcook> camlorn, in a data equation, the type constructor is on the left, the data constructors on the right.
18:59:48 <ski> `Just' also happens to be a (value) function. `Maybe' also happens to be a type function
19:00:14 <ski> `Either' and `Either String' are also type functions, but only the former is a type constructor
19:01:45 <ski> camlorn : data constructors are automatically injective (and pairwise disjoint, for a given data type), by definition
19:02:11 <ski> (where "injective" is just a different word for "one-to-one", in case you didn't know)
19:03:24 <camlorn> ski:  had to go look up pairwise disjoint.  I had injective from discrete math, fortunately
19:04:25 <ski> pairwise disjoint means that `False' can't match `True', and that `Nothing' can't match `Just x' (for any `x'), and that `Left x' can't match `Right y' (for any `x',`y'), &c.
19:05:15 <camlorn> Are the 99 haskell problems any good, and do we have answers to check against floating around?  I think I need to write something beyond binary trees before I can continue generating useful questions/understanding things beyond basics
19:05:22 <ski> normally, "pairwise disjoint" is used for a family or set of subsets of some given "universe set"/"domain of discourse"/type
19:05:53 <ski> here, i used it as applying to data constructors belong to some data type
19:06:01 <ski> s/eblong/belonging/
19:06:03 <Tekmo> camlorn: Yeah, they're okay if you're beginning Haskell.  The solutions are linked below each problem
19:06:36 <camlorn> ski:  I'm thinking of type constructors in terms of maps on sets at the moment. Is this wrong?
19:06:46 <Tekmo> camlorn: However, I think once you understand basic Haskell syntax and idioms you will progress more rapidly by working on a fun project (like a game or whatever)
19:06:49 <ski> camlorn : that's a good start
19:07:17 <camlorn> ski:  Like Just a maps from the set of everything posible to a set of eveything possible but wrapped in a maybe.  It's hard to articulate how I'm dealing with it into English.
19:07:17 <LuxuryMode> How does deriving type class instances work? If I define some data type, e.g.  data Foo = F Int String | G String Int deriving(Eq), how is Haskell defining Eq?
19:07:22 <LuxuryMode> Is it just looking at == on String and Int?
19:07:26 <LuxuryMode> in other words, deriving will only work if there are Eq type class instances for the consittuent parts?
19:08:04 <Tekmo> camlorn: Another way to put it is that the number of types that inhabit `Maybe a` is one more than the number of types that inhabit `a`
19:08:15 <camlorn> Tekmo:  heheh. I'm considering wrapping my custom C++ audio mixer to haskell when it's a bit more stable/ready and doing space invaders.
19:08:33 <Tekmo> camlorn: Neat! :)
19:10:14 <camlorn> Tekmo:  My immediate modivation is that, 2 days ago, I reaalized that (1) I know how to write a compiler at a macro level, (2) this is a major part of many CS curriculums, (3) I want to get into a good grad school and (4) my current university is failing to teach me this because they find it--like much else in computer science--irrelevant to their employment statistics.
19:10:35 <Tekmo> camlorn: Haha, I know what you mean
19:10:54 <ski> camlorn : `Just' is a polymorphic function
19:11:11 <ski> camlorn : for any given type `a', `Just' can map from that type to the type `Maybe a'
19:11:16 <camlorn> Tekmo:  Also it's something I've always wanted to do.  And I've known about haskell for a good while and that it's really good at manipulating complex tree-like things.
19:11:38 <Tekmo> camlorn: Yes, Haskell really excels for writing compilers
19:11:55 <camlorn> ski:  The part I'm having trouble with is that I can't exclude maybe from the universe.
19:12:09 <dwcook> camlorn, Maybe (Maybe String) is a valid type after all
19:12:28 <ski> camlorn : just saying "Just a maps from the set of everything posible to a set of eveything possible but wrapped in a maybe" is a bit inaccurate, or at least somewhat unclear or vague, since it doesn't make it that clear that it's the *same* type `a' in the input type `a' and the output type `Maybe a'
19:12:37 <camlorn> dwcook:  I know. But my brain is still deadlocking on considering that case.
19:12:40 <Gilfoyle>  camlorn, writing a compiler in haskell?
19:12:45 <ski> LuxuryMode : yes
19:12:56 <ski> LuxuryMode : structural equality
19:13:15 <Welkin> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
19:13:30 <LuxuryMode> so it wouldnt compile if there's some part for which there doesnt exists an Eq type class instance?
19:13:33 <ski> Tekmo : s/number of types/number of values/ ;)
19:13:40 <LuxuryMode> would* complain
19:13:44 <LuxuryMode> ski ^
19:13:45 <camlorn> Gilfoyle:  If you're coming up with the same joke my friend did--the camlorn compiler--I follow you.  Otherwise, not sure why that's unusual or something.
19:13:52 <Tekmo> ski: Oops!  My mistake
19:14:00 <LuxuryMode> shit, sorry. wouldnt
19:14:04 <LuxuryMode> wtf is wrong with me
19:14:31 <lfairy> camlorn: camlorn compiler? Is there something I'm missing? :p
19:14:31 <Gilfoyle> camlorn: Not sure what the joke is. Just curious, missed part of the convo.
19:15:18 <camlorn> Gilfoyle:  Idk. That it's alliterative I guess.  I have no sense of humor, so when someone else finds something funny I don't particularly question it.
19:15:28 <Gilfoyle> Ah
19:15:35 <ski> camlorn : exclude it from which universe, and why ? are you talking about `Just' as a (polymorphic) map from some collection of values (some type) to some other collection of values (some type) here ?
19:15:59 <ski> camlorn : or are you talking about `Maybe' as a map from some collection of types (some kind) to some other collection of types (some kind)
19:16:10 <ski> (where "other" should really be "possibly other")
19:16:22 <camlorn> Welkin:  Yeah, I'm probably going to use that for getting started.  i don't like scheme, mostly because I'm blind and mentally dealing with parentheses nested greater than 4 or 5 becomes very difficult-and scheme does that all the time everywhere.
19:16:25 <codygman> Does anyone use Haskell on redhat 6.5? Can it work on a vanilla 6.5 server? Will I have to use an old version?
19:16:30 <ski> LuxuryMode : yes, though it depends on how you mean
19:17:28 <camlorn> ski:  I'm not sure.  I'm still learning to be abstract enough to talk on this channel successfully.  Couple that with the fact that I started learning Haskell--as in wrote my first line of code--yesterday morning.
19:17:38 <Welkin> camlorn, it is really simple to write the parsers for scheme
19:17:42 <Welkin> I just used that tutorial
19:17:43 <ski> LuxuryMode : if you said `data Foo = MkFoo (IORef (Int -> Int)) [Int] deriving Eq', then that'd work since `IORef a' is in `Eq', regardless of whether `a' is in `Eq' or not
19:18:10 <LuxuryMode> ah i see, gotcha ski
19:18:38 <LuxuryMode> you don't necessarily continue to the lowest order type
19:19:00 <LuxuryMode> bc IORef has Eq for any a
19:19:21 * ski idly wonders whether they have met camlorn before
19:19:30 <camlorn> Welkin:  yes, but it can point me at the appropriate modules/techniques.  And give an overview.  It's scheme itself I have a problem with, and only for personal reasons.  I recognize the value of scheme in the general scheme of things--no pun intended--but my interest is writing a compiler for a more imperative/traditional language, primarily as a steppingstone to possibly contributing to Pypy and llvm and also as a learning tool.
19:20:05 <ski> LuxuryMode : right
19:20:10 <camlorn> ski:  only if you know a blind computer science majro with a guide dog...I'm kinda memorable.
19:20:17 <camlorn> ski: *major
19:21:00 <Lutin`> and live in Florida lol
19:21:02 <ski> camlorn : hm, seeing as you very recently started with Haskell, i suppose it probably wasn't you
19:21:17 <Welkin> camlorn, so do you use text-to-speech or a high-contrast GUI?
19:21:22 <ski> (i was thinking about someone i helped a bit in this channel, years ago, who was blind)
19:21:29 <camlorn> Welkin:  Text-to-speech.
19:21:55 <camlorn> Welkin:  Specifically NVDA and windows, because Linux accessibility sucks unfortunately.
19:22:41 <camlorn> Welkin:  And haskell is a bit intresting-the only programming language I have to put punctuation in all for.  I can get away with most for most of them.
19:23:34 <ckaukis> benzrf: because I wanted to work on a real project instead of continuously going through LYAH and RWH and doing Euler or other problems.
19:31:43 <ski> camlorn : anyway, you can think of `Maybe' as mapping from the collection of concrete types to the collection of concrete types
19:31:51 <ski> @kind Maybe
19:31:52 <lambdabot> * -> *
19:32:05 <ski> @kind Integer
19:32:06 <lambdabot> *
19:32:08 <ski> @kind Maybe Integer
19:32:09 <lambdabot> *
19:32:44 <camlorn> ski:  But that means it's a map from a set to itself?  Or are we allowed to say there's to sets that contain all possible types?
19:33:06 <ski> `*' is the kind of concrete types, the types that could possibly have values (one could perhaps say : "the inhabitable types")
19:33:22 <camlorn> ski: Or is it a map from the universe to (the universe minus the set off all types which re one maybe-level below us), where maybe-level is the number of maybes in front of it?
19:33:39 <ski> it's a map/function from the collection of concrete types to itself, yes
19:34:11 <ski> the collection of integer values, we call : the type `Integer'
19:34:28 <ski> the collection of concrete types, we call : the kind `*'
19:34:38 <ski> kinds are sortof the "types of types"
19:35:16 <ski> (whereas as "type" is ordinarily used here, each type describes a collection of values, that "go together")
19:35:36 <ski> now, `Maybe' itself is also a type
19:35:49 <ski> but it's not a concrete type, you can't have a value of type `Maybe'
19:36:03 <ski> you can have a value of type `Maybe Integer' or `Maybe Bool', though
19:36:11 <ski> `Maybe' is "incomplete"
19:36:33 <ski> also notice that the notation `[Integer]' for the type of lists of integers is syntactic sugar for `[] Integer'
19:36:37 <ski> @kind [] Integer
19:36:38 <lambdabot> *
19:36:39 <ski> @kind []
19:36:40 <lambdabot> * -> *
19:36:59 <ski> `[]' again is an "incomplete type", one could read it aloud as "list of"
19:37:29 <ski> one needs to specify *what* one is supposed to have lists *of*, before having a concrete type
19:37:50 <meretrix> @hoogle (Monad m, Monad n) => m a -> (a -> n (m b)) -> n (m b)
19:37:51 <lambdabot> Language.Haskell.TH.Quote dataToExpQ :: Data a => (forall b. Data b => b -> Maybe (Q Exp)) -> a -> Q Exp
19:37:52 <lambdabot> Language.Haskell.TH.Quote dataToPatQ :: Data a => (forall b. Data b => b -> Maybe (Q Pat)) -> a -> Q Pat
19:37:55 <ski> e.g. `[] Integer', lists of *integers*; or `[] Bool', lists of *booleans*
19:38:20 <ski> meretrix : looks like you need a distributive law
19:38:54 <ski> camlorn : there is no "*the* universe" ;)
19:39:11 <camlorn> ski: I follow your explanation.
19:39:23 <meretrix> ski: Thanks, I never heard of that in the context of haskell. I'll take a look.
19:40:12 <ski> given kinds `k0' and `k1', `k0 -> k1' is the kind of types which are functions that accept some specification of a type of kind `k0', before together with that specifying a type of kind `k1'
19:40:16 <ski> e.g.
19:40:18 <ski> @kind Either
19:40:19 <lambdabot> * -> * -> *
19:40:23 <ski> we could write this as
19:40:34 <ski>   Either :: * -> * -> *
19:40:49 <ski> or, with brackets around the latter `* -> *' part :
19:40:53 <ski>   Either :: * -> (* -> *)
19:41:20 <camlorn> Ski: because -> is right-associative.
19:41:28 <ski> so `Either' is a type (function) that accepts a concrete type, and then yeilds a type function that accepts a concrete type and then yields a concrete type
19:41:32 <ski> camlorn : yep
19:41:46 <ski> and because function application is left-associative we can say
19:41:52 <ski> @kind Either
19:41:53 <lambdabot> * -> * -> *
19:42:00 <ski> @kind Either String
19:42:01 <lambdabot> * -> *
19:42:08 <ski> @kind (Either String) Integer
19:42:09 <lambdabot> *
19:42:16 <ski> which is then the same thing as
19:42:17 <ski> @kind Either String Integer
19:42:18 <lambdabot> *
19:42:35 <camlorn> ski: What is the associativity of space?
19:42:45 <camlorn> ski: Not sure what to call that. Function application, I think.
19:43:05 <Lutin`> left associative
19:43:30 <ski> camlorn : the associaticity of function application, which is written as juxtaposition (usually space, but e.g. `(f)(x)' or `f(x)' is also valid) is to the left (and the precedence is `10')
19:43:46 <ski> and the same holds for application of a type function to a type
19:44:46 <ski> so there above we have specified two (concrete) types that `Either' needs, to make the description of a (concrete) type that `Either' "wants" to describe complete. specifying first `String', and then `Integer' after that
19:46:00 <ski> camlorn : one can think of values as occupying the lowest "level", and then types occupy the level above them, being used to classify values (either with a complete/concrete specification of an appropriate collection of values, or an incomplete one, like `[]',`Maybe',`Either',`Either String')
19:46:50 <ski> camlorn : and then kinds occupy the level above types, the kinds being used to classify the types in basically an analogous way the types are being used to classify the values
19:47:19 <ski> it would be possible to continue the ladder upwards, but Haskell doesn't do this
19:48:22 <camlorn> ski: So a *->* maps some type to the set of all types, a *->*->* maps some type to the set of all *->*, etc?  And all of these mappings are one-to-one?
19:48:35 <camlorn> Er, that's not right.
19:48:46 <ski> camlorn : note that `Maybe' is not a "polymorphic type". it's a type function, sometimes called a "generic type" -- above i also used the informal term "incomplete type"
19:49:35 <ski> camlorn : a type (function) of kind `* -> *' maps some type of kind `*' (iow a *concrete* type) into some type of kind `*' (so also a concrete type)
19:50:38 <dwcook> If by "polymorphic" you meant "whose type contains a type variable", and by "type" you meant "something inhabiting a kind", you could say it's a polymorphic type. That's the sense in which I tend to use those words
19:50:40 <ski> camlorn : a type (function) of kind `* -> * -> *' maps a concrete type to a type of kind `* -> *' (i.e. to a type function from concrete types to concrete types)
19:51:02 <ski> camlorn : and no, i haven't said anything about these type mappings being injectice
19:51:44 <ski> camlorn : previously, i said *data* constructors (which are values) are injective (or rather, they are, if they are functions, i.e. if they take any argument)
19:51:47 <camlorn> ski: I'm trying to figure out what patterns are, and am operating under the assumption that the compiler must be able to run the pattern backward, so to speak.
19:52:17 <ski> camlorn : but, *type* constructors actually are also injective in Haskell, yes
19:53:27 <dwcook> Woops I misspoke slightly. "containing a type variable", since we're already discussing a type
19:53:28 <ski> dwcook : yes. but i think it mostly obscures and confuses things up (unless perhaps when both of the conversants know what was meant ;)
19:53:36 <dwcook> ski, fair enough.
19:54:25 <ski> type functions / generic types are closely *related* to polymorphism (i.e. polymorphic values, for the most part polymorphic functions) -- but these two are still distinct concepts
19:54:42 <ski> the former enables the latter
19:55:24 <ski> camlorn : re patterns, yep
19:55:32 <camlorn> dwcook:  I do not qualify as a conversant who knows what was meant, heh.  I barely qualify as a conversant at the moment--it is abundantly clear I didn't know as much as I thought
19:56:29 <camlorn> We have a gentel introduction to haskell, learn you a haskell for great good, scheme in 48 hours...we need a formal introduction to haskell, haskell for the mathematically inclined, learning to converse on the haskell IRC...
19:56:32 <ski> camlorn : patterns are built up from distinct variables, the wildcard/joker/match-anything `_', fully saturated applications of data constructors to patterns, and a few more cases
19:57:34 <kwos> hello!
19:57:36 <camlorn> What is a fully saturated data constructor to a pattern?
19:57:57 <camlorn> Also I'm getting out theb haskell 98 report.
19:58:00 <ski> camlorn : since data constructors are guaranteed to be injective, and since the variables are checked to only occur once in the pattern(s) to match, there is at most one set of bindings for the variables in the patterns that would make the patterns be equal to (the same as) the value(s) being matched
19:58:34 <ski> camlorn : consider `False :: Bool', this isn't a function so `False' is already a saturated pattern
20:00:00 <Welkin> camlorn, you mean learning category theory?
20:00:01 <ski> camlorn : then consider the definition `data IntTree = Leaf Int | Branch IntTree IntTree' -- here `Leaf :: Int -> IntTree', so we need to apply `Leaf' to one pattern, like `Leaf <pat>', where `<pat>' is a pattern of type `Int', before getting something that is not a function (and so is a saturated application of the data constructor `Leaf')
20:00:11 <Welkin> there are many books and the haskell wiki is helpful in that regard
20:00:17 <camlorn> ski: I sort of see the saturation point.  You're saying that, in order for the pattern to be saturated, the variables (allowing for _) must be sufficient to completely reconstruct the value using the constructor involved?
20:01:06 <ski> camlorn : then, consider `Branch :: IntTree -> IntTree -> IntTree' there. if we say `Branch <pat 0>', then this still has functional type (i.e., is a function) (assuming `<pat 0> :: IntTree', as required to make this make any sense)
20:01:49 <ski> camlorn : we need to say `Branch <pat 0> <pat 1>' (where obviously also `<pat 1> :: IntTree') to make this application of `Branch' saturated
20:03:02 <ski> camlorn : well, given a value `Branch (Leaf 3)' (which is a function value), we can't match this on a "pattern" `Branch leftTree', since this pattern isn't a saturated application of `Branch'
20:03:13 <ski> camlorn : we can't match on functions
20:03:57 <camlorn> ski: How accurate or inaccurate is it to think of saturated as filling all the slots of a data constructor?
20:04:13 <camlorn> ski: perhaps more importantly, how destructive to my future understanding is this analogy?
20:04:53 <ski> camlorn : given the value `Branch (Leaf 3) (Branch (Leaf 2) (Leaf 1))' however (which is *not* a function), we could match this on the pattern `Branch leftTree (Branch (Leaf n) rightTree)', and this matching would in fact also succeed, binding `leftTree',`n',`rightTree' respectively to `Leaf 3',`2',`Leaf 1'
20:04:56 <edeastBambam> haskell-platform eta?
20:05:59 <ski> camlorn : note how the patterns `<pat 0>' and `<pat 1>' in the generic schema `Branch <pat 0> <pat 1>' needn't be variable names or the wildcard `_' -- they could themselves be complicated patterns, involving more (fully saturated) applications of data constructors
20:07:00 <ski> camlorn : in the above case, `<pat 0>' corresponded to the variable pattern `leftTree', while `<pat 1>' corresponded to the compound pattern (here constructor pattern) `Branch (Leaf n) rightTree'
20:07:32 <ski> camlorn : "How accurate or inaccurate is it to think of saturated as filling all the slots of a data constructor?" -- sounds accurate
20:07:44 <ski> camlorn : and also gainful, afaicd
20:08:58 <ski> camlorn : the main point is that you have to apply data constructors in patterns to (sub-)patterns corresponding to *all* the specified slots/components/arguments (of which there may be zero or more) of the corresponding data constructor
20:09:58 <ski> camlorn : you can't merely apply `Branch' to a single pattern above, getting a pattern of function type, and expect to be able to match on functions of the shape `Branch blah' for some value/expression `blah'
20:10:39 <ski> camlorn : this is because you could think of `Branch' as not creating the "package" containing the two subtrees before actually being handed both of them (sounds sensible when you think about it, yeah :)
20:10:43 <camlorn> ski: This question is probably inevitable and expected.  can I pattern match on function types?  not sure if such is useful or not yet.
20:11:31 <ski> camlorn : if you only provide `Branch' a single subtree (the left one), it's still waiting for the right one (though remembering / keeping track of the left one, for when the other one arrives)
20:11:57 <ski> camlorn : only when it has gotten both does it actually create the "box" which you can inspect by pattern-matching
20:12:34 <ski> camlorn : you can't "essentially" match on values of function type (using patterns of function type, of course)
20:13:08 <ski> camlorn : i say "essentially" because strictly speaking, variables like `x' and the wildcard `_' are also patterns, and you *can* use those to "match" on functions
20:14:05 <ski> camlorn : however, doing so will never check whether the function in question has some particular property, it will just *name* the function, for later use (or refrain from naming it, in the case of `_')
20:15:13 <camlorn> ski:  All right.  I think I actually followed this.
20:15:43 <ski> camlorn : btw, i hope you followed my definition of the data type `IntTree' -- if in doubt, i could elaborate on the syntax i used, and the result
20:15:59 <ski> (seeing as you recently started learning Haskell, i mean)
20:16:18 <camlorn> Ski: I can't regurgitate it yet for lack of vocabulary familiarity--as I said in my blog post about my first 8 hours with haskell, the ideas do not translatewell to English.  But I followed you.
20:16:33 <camlorn> ski: I did binary trees as my learning project.
20:16:43 <ski> ok, good
20:16:48 <camlorn> ski: I'd have to scroll up to find the syntax in question again, but I don't recall finding it strange when you first did it.
20:17:13 <ski> part of learning a new programming language is commonly to learn the particular jargon and sense of the words as used in that community
20:17:39 <camlorn> ski: I think I'm going faster than most, which is why I was surprised to hit this wall.  I'm as far as basic typeclass definitions, i.e. my trees support trees of trees of... and equality.
20:17:48 <ski> camlorn : the syntax for defining new data types is a bit similar to the BNF notation, if you know that
20:20:21 <camlorn> ski: I'm not super comfortable with bnf.  I ccan kinda read it, but never found a reason to learn it thourougly.
20:20:59 <camlorn> ski: But I get how to define them, at least basic ones.  I'm sure that I'll find out this statement isn't actually true shortly, however.
20:21:21 <ski> camlorn : anyway, because one could think of a data constructor as not creating an inspectable value until after it has been provided all the slots/components/arguments required by it, it then stands to reason that to be able to inspect such a "box" / value, you need to provide patterns corresponding to all the data constructor arguments, when matching on values constructed by this data constructor, like in the `Branch <pat 0> <pat 1>' (schematic) ex
20:21:48 <ski> (oops, probable cut off near ".., when matching on values constructed by this data constructor, like in the `Branch <pat 0> <pat 1>' (schematic) example")
20:22:24 <ski> camlorn : it's a start, at least, in the right direction :)
20:27:33 * hackagebot intricacy 0.3.1 - A game of competitive puzzle-design  http://hackage.haskell.org/package/intricacy-0.3.1 (mbays)
20:29:48 <athan> So is Data.Graph already a directed graph?
20:31:23 <camlorn> ski: thanks.  I have to ask, are you a teacher/professor or similar?  because you're beating most of the online resources.
20:31:49 <camlorn> ski: In fact, let's go with...all of them.
20:33:05 <ski> camlorn : i'm a student
20:34:29 <ski> though i have been here (and in a dew other channels as well) for several years, attempting to help people, and getting some experience with doing so
20:34:54 <ski> (of course many other people in here also do that, according to their ability)
20:35:51 <ski> (s/their/their respective/)
20:35:55 <camlorn> ski: not saying they don't.
20:36:20 <ski> i've been a regular (more or less) in this channel since 2001
20:36:52 <camlorn> ski: But I've only been here at all since yesterday and this is the longest single conversation I've had yet.
20:37:34 * hackagebot yesod-auth-zendesk 1.2.1 - Zendesk remote authentication support for Yesod apps.  http://hackage.haskell.org/package/yesod-auth-zendesk-1.2.1 (FelipeLessa)
20:38:25 <camlorn> In fact, this whole channel's been great-I'm a newbie, but there's just this missing component to the dynamic that all newbies are stupid that I kinda expected to see for some reason.  I'm done being sappy or whatever now.
20:38:29 <ski> (this being my first IRC channel, and it being quite friendly and "teachful" then as well, even though we weren't as many here then)
20:39:47 <ski> @wn sappy
20:39:49 <lambdabot> *** "sappy" wn "WordNet (r) 3.0 (2006)"
20:39:49 <lambdabot> sappy
20:39:49 <lambdabot>     adj 1: ludicrous, foolish; "gave me a cockamamie reason for not
20:39:49 <lambdabot>            going"; "wore a goofy hat"; "a silly idea"; "some wacky
20:39:49 <lambdabot>            plan for selling more books" [syn: {cockamamie},
20:39:51 <lambdabot> [3 @more lines]
20:39:56 <ski> @more
20:39:56 <lambdabot>            {cockamamy}, {goofy}, {sappy}, {silly}, {wacky},
20:39:56 <lambdabot>            {whacky}, {zany}]
20:39:57 <lambdabot>     2: abounding in sap; "sappy maple trees"; "sappy kindling wood"
20:40:16 <camlorn> Here's a completely random thing I'm going to throw out there.  Does haskell have anything like erlang processes?
20:41:08 <Lutin`> There's Cloud Haskell
20:41:20 <Lutin`> But the documentation on it is fairly sparse at the moment
20:41:29 <ski> afaiui, you can't that easily communicate beween different threads on different machines
20:41:43 <camlorn> Then maybe i'll stick to my plan to use akka.
20:41:48 <ski> perhaps cloud haskell provide some kind of primitives for such things, haven't tried
20:41:49 <Lutin`> And last I checked hackage didn't have the most recently up to date version of the haddock
20:42:27 <camlorn> Erlang rubbed me the wrong way.  I was able to follow it, moreso even than haskell.  But come on, tuples for everything, with no real overarching structure, in 2014?  And then I just sorta shrugged.
20:42:34 * hackagebot yesod-auth-deskcom 1.2.1 - Desk.com remote authentication support for Yesod apps.  http://hackage.haskell.org/package/yesod-auth-deskcom-1.2.1 (FelipeLessa)
20:42:34 <ski> Haskell has light-weight threads, where you can communicate between them using `MVar's,`SampleVar's,`Chan's, e.g.
20:42:36 * hackagebot hissmetrics 0.5.1 - Unofficial API bindings to KISSmetrics.  http://hackage.haskell.org/package/hissmetrics-0.5.1 (FelipeLessa)
20:43:24 <ski> camlorn : Haskell also has the interesting STM (Software Transactional Memory) approach for concurrency (not distribution)
20:44:27 <camlorn> ski: It's going to be an MMO, and I was considering how you might generalize the framework, and I came up with this message tree structure that I really like.  But I don't want to write what is basically an actor framework so...
20:45:00 <ski> (STM composes better than typical lockbased stuff like `MVar' (even though the lock is hidden there, so you don't see it explicitly))
20:45:42 <camlorn> ski: that's not as crazy as it sounds.  We've got a blind-accessible online zombie fps, but no one has tried to do something like WoW or Eve online, and the guy doing it chose vb6, flat files, and a custom engine that can't really transcend zombie fps (also he cheats and doesn't actually synchronize completely, and everyone can tell).  Since the target is only 50 players online and i'm intereested in distributed computing, well...
20:46:21 <camlorn> ski: I'm familiar with stm enough to know what it can do for me.  Is that implemented in pure haskell?
20:46:43 <camlorn> ski: I'm kinda curious if Haskell provides enough to do some sort of stateful journal and have the monad stick commit code between the functions or what...
20:47:35 * hackagebot esqueleto 1.4.1.3 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.4.1.3 (FelipeLessa)
20:47:47 <ski> camlorn : no, the implementation is partly in the RTS of GHC
20:48:04 <camlorn> ski: Could we do so in theory?
20:48:21 <ski> (btw, if you have tried STM, have you then used any Clojure or .. ?)
20:48:52 <camlorn> ski: I invision stm kinda like git branching.  You've got a log of diffs, and if two diffs clash, you roll both back and say try again.  Seems you could do this with some sort of log or alist-like thing.
20:49:13 <camlorn> ski: I haven't tried stm, but UI know what it is.
20:49:28 <camlorn> ski: My interest in it was sparked by pypy's experimental implementation.
20:49:56 <camlorn> ski: Don't know if you know about python and it's global interpreter lock, but pypy has killed it, or will have when it becoes not experimental anymore. should b
20:50:11 <ski> camlorn : not completely. maybe in terms of `MVar' or `IORef' and such other primitive, not sure
20:50:57 <ski> camlorn : ok
20:51:16 <ski> ("should b" ?)
20:52:14 <camlorn> Ah, yeah. Not sure what happened ther.
20:52:33 <camlorn> My typing seems to be degrading temporarily.
20:52:48 * ski was suspecting accidental cut off
20:52:55 <camlorn> But I think that's a case of select-delete went wrong, and I can't see the text unless I explicitly ask.
20:53:13 <camlorn> O, I don't get that.  My client auto-splits.
20:53:49 <edeastBambam> yb
20:53:49 <ski> (yeah, but i mean perhaps you accidentally mispressed some button, which cut to the end of the message or something like that)
20:54:10 <camlorn> ski: Nope, think I misused select-delete.  It happens.
20:54:14 * ski peers curiously at edeastBambam
20:55:38 <camlorn> But I'm not ready for stm in haskell yet.  I've not yet grasped monads.  It's going to take a little while for me to do so, and all the references refer back to functors, which I've not been through yet.  I'm excited about having it though.
20:55:52 * ski nods
20:56:29 <ski> just so you're aware. there's many more or less bad monad tutorials floating around
20:56:40 <ski> @where burrito
20:56:41 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
20:56:49 <ski> see that, in case you're interested
20:57:31 <camlorn> What in the world is that command to lambdabot?
20:57:42 <ski> @help where
20:57:43 <lambdabot> where <key>. Return element associated with key
20:57:51 <camlorn> Heh.
20:58:03 <camlorn> And you just happen to know it's burrito.  Heh.
20:58:14 <ski> yep, "long story" :)
20:59:57 <camlorn> Well, okay. Now that I'm reading it, that's not so cryptic.
21:01:58 <camlorn> As for what I need to get monads, it's mostly that I need to be better at immediately extracting information from a type specification--and possibly understanding the idiomatic way to say things in my own so that others can use their Haskell type specification intuition and get it right too.
21:02:51 * ski learned functors before, as well
21:03:53 <camlorn> Ski: O, not saying that I don't need functors too.  But either the tutorial is too philosophical, relies too heavily on the "this type spec says something", or refers to its two previous chapters about functors and how amazing they are.
21:04:35 <camlorn> In fact, what did I do the last time I almost-got it before I was looking at it in the inside the context of haskell...hmm.
21:04:47 <dwcook> camlorn, FYI, for typeclasses the types of methods are important but also the laws, which the language does not enforce.
21:05:41 <camlorn> dwcook:  yeah. I think it was the laws, stated in a programming language neutral fashion, that provided the ah-hah moment when I looked at this two uyears ago.  But I never used the knowledge at all, let alone enough to cement it, so I get to rework my reasoning.
21:06:01 <camlorn> dwcook:  I have ben looking at pure functional programming from the outside off and on for a while.
21:06:06 <ski> i suspect that "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>, possibly the first monad tutorial, can be useful to newbies (after they have learned the basics about types and type classes, and possibly also learned about functors), even though it's slightly dated in using old names for some library things
21:06:29 <ski> (hrm, possible cut off near ".., even though it's slightly dated in using old names for some library things")
21:06:36 <camlorn> 500 internal server.
21:06:47 <camlorn> O nevermind.
21:06:54 <camlorn> Stupid client decided the > was part of the link.
21:07:01 <dwcook> Freenode web chat?
21:07:13 <dwcook> Ah, apparently not
21:07:25 <camlorn> No, instantbird.
21:08:01 <camlorn> The web ones are usually inaccessible, and instantbird actually turns accessibility up to 11-even if it is a bit short on features.
21:08:37 <camlorn> The XUL framework lets authors use aria, which is basically magic accessibility sauce if you know  what you're doing or I will hate you forever if you don't.
21:09:13 <camlorn> Someone at instantbird does know, so there's a lot of nice stuff here-most notably that chat automatically reads without having to fiddle with reviewing it manually.
21:10:38 <maybefbi> while reading a 16GB CSV file i want to draw on screen. How can I do this? I know how to read a csv file using a LBS.readFile or a conduit inside an IO monad, but not sure which hackage package to use to interleave such reads from the CSV file with IO actions that draw things on screen
21:11:00 <Welkin> Just FBI? or Nothing?
21:11:05 <dwcook> That sounds nice. I can't begin to imagine the hassle it must be to use the sites that automatically decide you must have JS enabled and no warning otherwise.
21:11:09 <maybefbi> Nothing
21:11:18 <dwcook> camlorn, or, are you able to have JavaScript enabled?
21:11:40 <Welkin> I use noscript
21:11:51 <Welkin> I usually leave a site if it requires js to function
21:12:11 <camlorn> dwcook:  Everyone always underestimates.  I've got Javascript, CSS, and HTML5.
21:12:12 <Welkin> some sites don't even load with js...
21:12:35 <dwcook> Welkin, I do too, and I often do that as well, but the option is available to enable if I really want to.
21:12:49 <camlorn> dwcook:  If I want, I can query for color/positional info, collapsible menus work for the most part, and well-written web applications are more accessible and easier to make accessible than desktop applications.
21:13:05 <ski> camlorn : apparently it's not following the recommendation in RFC 3986 "Uniform Resource Identifier (URI)" in 2005-01 at <https://tools.ietf.org/html/rfc3986#appendix-C>, appendix C "Delimiting a URI in Context"
21:15:12 <ski> camlorn : anyway, "You Could Have Invented Monads! (And Maybe You Already Have.)" by dpiponi/sigfpe in 2006-08-07 at <http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html> is considered one of the better tutorials
21:15:19 <camlorn> dwcook:  case and point github which, with some recent improvements on the part of my screen reader and possibly on their end, now works amazingly.  Basically, all the keys on the keyboard get linked to certain types of html elements, the arrow keys move, and the screen reader get snotifications from the browser on DOM changes.  Coupled with the fact that most blind people read upwards of 400 words a minute, no big deal.  But cha
21:15:19 <camlorn> apps, at least unless someone puts an aria live region on them the right way, suck.
21:15:30 <ski> there are some other of good quality as well
21:15:56 <dwcook> camlorn, I have some objections to Github's design but it's good it works well for you.
21:16:08 <ski> camlorn : but i recommend getting grounded in types and type classes at least, first
21:16:21 <camlorn> ski:  How do I know when I'm grounded?
21:16:25 <ski> (it'll help)
21:17:04 <dwcook> camlorn, this isn't a sure sign, but knowing how to do type unification in your head can be handy.
21:17:38 <ski> camlorn : well, when you understand basic polymorphism, parametric types (aka type functions, "generic types"), and also what type classes and instances of them are (and what they're basically for)
21:18:31 <camlorn> ski: yeah. Unfortunately those aren't objective measures.  I like objective measures. There probably isn't one. Ah well.
21:19:14 <ski> camlorn : the type classes stuff isn't strictly necesssary, since you can do monads without them. however monads in Haskell traditionally use the type class `Monad' (except from the early tutorial link i gave, which only mentiones it at the end), so knowing something about type classes therefore helps with understanding information about monads that use the `Monad' type class
21:19:47 <camlorn> ski: I have implemented custom Eq and Ord instances.
21:20:08 <ski> camlorn : as dwcook said, being able to do some simple type checking and type inference in your head (or with scribbling notes down, at first), will also probably help
21:20:09 <camlorn> ski: Let's start with type unification. Do we have good reading on it?
21:21:10 <ski> camlorn : not because that has specifically to do with monads, but because monads are already type functions, so the types are necessarily a little bit complicated, so you need to understand how to match/unify types
21:21:27 <Lutin`> camlorn: Something that converts wikipedia source to something that's TTSable would be nice
21:21:43 <ski> (well, you can probably get by for a while without knowing that well. but in the end, it will help in practice)
21:22:00 <camlorn> lutin`: Heh. Not sure what you mean.  I read the article as-is, including the TeX alt-text.
21:22:18 <Lutin`> Oh it has TeX alt-text
21:22:21 <camlorn> lutin`: if you actually manage that, you're halfway to solving the matha ccessibility problem, and could probably get a research grant.
21:22:29 <Lutin`> Can you start at a specific section?
21:22:37 <Lutin`> ooh there's a Haskell project in that :D
21:22:50 <ski> camlorn : another reason for learning functors first is that `Functor' is a simpler example of a type class whose instances aren't concrete types (but rather type functions, specifically of kind `* -> *')
21:22:53 <Lutin`> actually
21:23:00 <Lutin`> If they did HTML5 properly
21:23:05 <Lutin`> you should be able to read in browser
21:23:44 <ski> camlorn : can you figure out the type of `concat . concat' in your head ?
21:24:02 <camlorn> Lutin`: You, too, are underestimating the accessibility of the interet. I read wikipedia in the browser and stackoverflow and the haskell 98 report, and tvtropes is lots and lots of fun.
21:24:13 <camlorn> lutin`: *internet
21:24:22 <Lutin`> Hmm maybe I should install a reader
21:25:55 * ski also sees TeX on WP when browsed in W3m
21:26:34 <ski> camlorn : or, if not, how about by writing stuff on paper^W^Win a text buffer ?
21:26:52 <Welkin> camlorn, do you know of any open-source TTS voices for foreign languages?
21:27:11 <ski> it's not so much that `concat . concat' is itself that interesting example, though
21:27:38 <Welkin> :t concat . conact
21:27:39 <lambdabot>     Not in scope: ‘conact’
21:27:39 <lambdabot>     Perhaps you meant one of these:
21:27:39 <lambdabot>       ‘concat’ (imported from Data.List),
21:27:44 <Welkin> :t concat . concat
21:27:45 <lambdabot> [[[a]]] -> [a]
21:27:55 <cehteh> Welkin: espeak with mbrola works somewhat
21:27:56 <ski> Welkin : spoiler :)
21:28:27 <camlorn> Welkin:  If you don't mind gpl, you can use espeak.  I have heard the quality is very low for things that are not english.
21:28:30 <Welkin> I'm looking into writing a program to read books in foreign languages
21:28:47 <Welkin> I'm not familiar with TTS voices though
21:28:47 <ski> but the systematc method of determining the type of such things can be useful to have had some practice at, especially when you run into a type error you're having trouble deciphering the cause of
21:29:01 <camlorn> Welkin:  Other than that, flite or festival might or might not have something.  The problem is that making a tts voice is actually a data problem, and someone has to collect/assemble the rule databases.
21:29:36 <Welkin> camlorn, do you know what licensing/pricing is like for commercial voices?
21:29:45 <cehteh> http://tcts.fpms.ac.be/synthesis/mbrola.html
21:30:06 <cehteh> its really not the best, but good enough for many things and open source
21:30:29 <dwcook> Reminds me of when I used the Spanish translation of Mumble's TTS (which makes sense even for sighted people since you might not have the window in front of you). It used a British English voice to read Spanish, which did not sound right. :P
21:30:46 <ski> camlorn : would you like to see a derivation of the type for it ?
21:32:06 <camlorn> ski: Sorry, I think I missed something.
21:32:19 <Welkin> @src concat
21:32:19 <lambdabot> concat = foldr (++) []
21:32:22 <camlorn> ski: I got drawn into a second conversation here and, simultaneously, two more in different windows.
21:32:31 <ski> camlorn : ok, np
21:35:22 <Welkin> fireworks have been going off for hours
22:02:49 <maybefbi> how do interleave different types of IO actions, one of which if evaluated strictly will consume the entire system memory?
22:03:39 <dwcook> maybefbi, what do you mean by "interleave"?
22:04:51 <maybefbi> do { input <- readFile ""; plot $ (head . split '\n') input; }
22:05:09 <maybefbi> dwcook, thats what i mean
22:05:26 <maybefbi> if i let the first action evaluation strictly it will fill up the entire system memory
22:06:44 <maybefbi> do { input <- readFile ""; map plot (split '\n' input); }
22:06:51 <maybefbi> to be more precise
22:07:01 <maybefbi> i want to read one line and then plot it
22:07:07 <dwcook> maybefbi, so is the problem that map plot . split '\n' is too strict?
22:07:47 <dwcook> (or one of the functions making it up)
22:08:16 <dwcook> maybefbi, hmm, which split is that?
22:08:29 <matematikaadit> :t lines
22:08:29 <lambdabot> String -> [String]
22:08:42 <matematikaadit> > lines "hello\nworld"
22:08:43 <lambdabot>  ["hello","world"]
22:09:15 <dwcook> > take 2 (lines ("hello\nworld\n" ++ undefined))
22:09:16 <lambdabot>  ["hello","world"]
22:10:42 <maybefbi> do { input <- readFile ""; mapM_ print (lines input); }
22:10:55 <maybefbi> i wish that ran without reading the entire file
22:11:05 <dwcook> mapM_ is well known to have… interesting properties
22:11:26 <dwcook> Perhaps you want some sort of streaming abstraction, like (the properly implemented) ListT
22:11:46 <maybefbi> how does one use it?
22:12:15 <dwcook> I've only ever used the one in the pipes package, which also has other streaming goodies, but there may be one around that doesn't require you to pull it all in
22:12:42 * hackagebot postgresql-simple-migration 0.1.0.0 - PostgreSQL Schema Migrations  http://hackage.haskell.org/package/postgresql-simple-migration-0.1.0.0 (ameingast)
22:12:42 <dwcook> In the docs for that package you can see some examples, if I recall
22:12:46 <matematikaadit> @hackage pipes
22:12:46 <lambdabot> http://hackage.haskell.org/package/pipes
22:12:49 <dwcook> I'd give an example but don't trust myself to give a good one
22:13:31 <maybefbi> ok
22:13:54 <dwcook> http://hackage.haskell.org/package/pipes-4.1.2/docs/Pipes-Tutorial.html#g:6
22:14:37 <dwcook> If there's something you don't get, you may find it earlier in the tutorial and you can also ask in here
22:14:57 <maybefbi> ok
22:22:51 <dmwit> um
22:23:05 <matematikaadit> oke, so what is this "ListT done wrong thing"?
22:23:06 <dmwit> readFile "foo" >>= mapM_ print . lines -- will not read the entire file before printing
22:23:24 <dwcook> Oops, I didn't bother to check the assertion
22:23:54 <dwcook> matematikaadit, there is a ListT that is not actually a monad transformer in one of the popular packages, transformers if I recall.
22:24:12 <dwcook> matematikaadit, i.e., it fails at least one of the laws.
22:24:42 <dwcook> Yeah, here it is. Note the note. http://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-Trans-List.html
22:25:53 <dmwit> maybefbi: Why do you say it reads the whole file before starting?
22:26:10 <dmwit> maybefbi: Actually, I notice you don't say that. What do you want it to do, if not operate on the whole file?
22:28:25 <dmwit> (Somehow I find myself defending lazy IO more now that I know what's wrong with it than I ever did before I even knew it was controversial.)
22:29:08 <dwcook> I used to think lazy I/O was pretty neat but once I learned the truth it horrified me.
22:34:04 <maybefbi> dmwit, i just used mapM_ print to print a lazy bytestring containing a the output of a readFile
22:34:25 <maybefbi> and it could print everything line by line as it read from the file
22:34:48 <maybefbi> so i was wrong to complain it couldnt, that was a bug i had made
22:35:04 <Tjr> Why is lazy IO bad?
22:36:49 <dwcook> Tjr, it can be hard to predict when an expression will be evaluated. Lazy I/O means that an I/O operation may be performed when a thunk is forced rather than immediately.
22:37:32 <lfairy> Tjr: it's unpredictable
22:37:45 <Tjr> speaking as somebody who has never dealt with large amounts of IO, that doesn't sound too bad on the surface. Probably there's something I'm not getting?
22:37:50 <lfairy> whether I/O happens or not depends on evaluation order
22:38:11 <Tjr> lfairy: shouldn't everything be evaluated eventually?
22:38:32 <dwcook> Tjr, no. Take const x y for example. y will never get evaluated.
22:38:40 <lfairy> here's an example on StackOverflow - http://stackoverflow.com/q/9406463/617159
22:39:49 <lfairy> so the behavior of your program ends up depending on an implementation detail, in pure code
22:40:17 <Tjr> lfairy: that's enlightening
22:40:46 <dwcook> Monadic streams (such as ListT) give you more control over what to couple with what
22:41:30 <dwcook> The pipes package touts itself as giving you three very desireable features: effects, streaming, and composability
22:42:11 <dwcook> Which you don't get with lazy I/O because it lacks proper streaming
22:44:25 <Tjr> lfairy: arguably, I'd think it#s a bug that reading from a file is lazy, but closing the file handle is not.
22:44:50 <dwcook> Tjr, how would you expect it to behave?
22:45:01 <lfairy> well, Handles already close themselves on GC
22:45:16 <dwcook> So then remove the manual close operation altogether?
22:45:17 <Tjr> good point with the GC
22:45:26 <lfairy> the only reason you'd close manually is to ensure prompt finalization
22:45:57 <lfairy> which leads back to the unpredictability argument
22:46:12 <dwcook> That could be nice… I still think it feels icky to have I/O done as a result of evaluation, even though that's not a concrete complaint.
22:46:21 <Tjr> I'd expect the close handle operation to trigger evaluation of the reads to the file, but on second thought that probably invites race conditions
22:47:45 * hackagebot ghc-imported-from 0.2.0.6 - Find the Haddock documentation for a symbol.  http://hackage.haskell.org/package/ghc-imported-from-0.2.0.6 (CarloHamalainen)
23:02:46 * hackagebot bloomfilter 2.0.0.0 - Pure and impure Bloom Filter implementations.  http://hackage.haskell.org/package/bloomfilter-2.0.0.0 (BryanOSullivan)
23:37:00 <codygman> I have a syntax error for some reason. I just pasted an example from the cron haddock on hackage: http://lpaste.net/106953
23:40:09 <codygman> hmm, that should be main = forever $ do
