00:00:32 <dwcook> In fact I'd venture to say *all* monadic operations are pure
00:00:51 <dwcook> It's execution, not evaluation, that performs I/O
00:00:53 <vanila> that's a good point, all functions in haskell are pure
00:01:20 <vanila> but conceptually you use them to write effectful code
00:01:22 <dwcook> orion, in short, no, I would say that model could be either accurate or meaningful but not both
00:01:44 <vanila> maybe this paradox natural is why they're hard to learn?
00:01:45 <orion> dwcook: If there's nothing fundamental about Monads, why is my application useless if the type of main isn't IO ()?
00:01:46 <vanila> nature*
00:01:57 <dwcook> orion, that type contains no mention of Monad.
00:02:05 <vanila> IO is a monad
00:02:14 <Enigmagic> Maybe is a monad too
00:02:20 <tac> orion: what does that question mean?
00:02:26 <dwcook> Sure, and you perform arithmetic addition all the time but that doesn't mean you need to know what monoids are
00:02:29 <tac> Are you asking why your program won't run without a main method? >__>
00:02:32 <c_wraith> you can use IO without ever touching a monad.
00:02:37 <Enigmagic> IO is also a Functor
00:02:40 <c_wraith> It just requires a few extra imports.
00:03:16 <c_wraith> IO is special.  Monads are not.
00:03:33 <c_wraith> Well, Monads get syntactic sugar that nothing else does - but that's not fundamentally special.
00:03:47 <roboguy_> orion: that is unrelated to it being a monad though
00:03:50 <aarvar> And they only get it because of IO in the first place
00:06:52 <dwcook> orion, incidentally, there's a pattern to the three things you said. Well, almost. IO, Monads in general, and values in general form of hierarchy of features. If you just know something is a value, you can do hardly anything with it. Knowing it's a Monad, you can use return and join and such. Knowing it's IO, you can perform a whole host of IO-specific operations.
00:07:14 <dwcook> orion, and you can do anything with a Monad you could with a general value and anything with IO you could with a Monad.
00:08:10 <dwcook> But this is just one particular path in the hierarchy, and it's not quite a hierarchy actually. A lattice?
00:08:26 * hackagebot async-extras 0.1.2.0 - Extra Utilities for the Async Library  http://hackage.haskell.org/package/async-extras-0.1.2.0 (JonathanFischoff)
00:08:26 * hackagebot vty 5.1.4 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.1.4 (CoreyOConnor)
00:08:42 <aarvar> I think you may be making things more complicated
00:08:52 <dwcook> That's entirely possible
00:09:04 <dwcook> It's mostly unrelated to the original question, I will grant
00:09:05 <orion> dwcook: All non-monadic functions are merely expressions eagerly awating to be converted to values, right?
00:09:28 <dwcook> orion, you have multiple frivolous qualifiers in there
00:09:33 <aarvar> What he means is that "IO a" is more specific than "Monad a => a" which is more specific than "a"
00:09:41 <aarvar> woops
00:09:44 <dwcook> orion, any expression at all can be evaluated to a "final" value
00:09:47 <aarvar> "Monad m => m a"
00:09:57 <orion> dwcook: Learn you a Haskell is the king of frivolous qualifiers.
00:10:09 <tac> books can't be kings
00:10:19 <vanila> Learn you a Haskell can!
00:11:27 <orion> And, Monads impose a structure on *how* those expressions get evaluated, right?
00:11:39 <c_wraith> Not really.
00:11:40 <vanila> not exactly
00:12:04 <tac> sorta kinda, but yeah, not exactly
00:12:06 <vanila> a monad m lets you write functions a -> m b instead of a -> b
00:12:10 <jle`> Monads are monads
00:12:18 <jle`> they are useful for certain things
00:12:19 <vanila> and the 'm' part changes 'b' depending on what the monad is
00:12:21 <jle`> but that is not what they are
00:12:41 <vanila> for example it can change it into a list of b's, or replace b with an error message in some cases
00:12:51 <jle`> fmap is useful on [] because it lets you map.  but fmap isn't a list mapping function
00:15:15 <roboguy_> when you get right down to it, a Monad is just something with >>= and return that have certain types and obey certain laws (or fmap and join if you prefer). when you use them enough, you get some idea of what they are
00:16:36 <orion> So, it's wrong to say that Monads sequence the evaluation of expressions?
00:16:52 <vanila> it's not wrong
00:16:57 <dwcook> It's sorta wrong
00:17:03 <roboguy_> orion: it's hard to make general statements like that about when things get evaluated in haskell for one
00:17:07 <dwcook> http://www.haskell.org/haskellwiki/What_a_Monad_is_not#Monads_are_not_about_ordering.2Fsequencing
00:17:26 <aarvar> Monad is just an algebraic structure that a lot of types happen to fit
00:17:48 <roboguy_> orion: the function monad doesn't really fit the sequencing thing so much
00:17:50 <aarvar> It's easier to understand through specific examples
00:18:22 <splintax> @hoogle (:/)
00:18:24 <lambdabot> No results found
00:19:15 <Ainieco> hello
00:19:32 <Ainieco> what's purpose of Identity monad?
00:19:38 <orion> Ok, I accept that Monads can't be generalized in to some easy to digest soundbyte.
00:19:48 <tac> Ainieco: it's theoretically useful
00:19:59 <tac> Ainieco: But you never really need it. Save maybe using lens?
00:20:02 <roboguy_> Ainieco: one use is that it helps with monad transformers
00:20:05 <aarvar> It's more that the identity type constructor is a monad
00:20:11 <yukko> you can think of monads as burritos in spacesuits
00:20:13 <dwcook> I was going to say basically what roboguy_ said
00:20:17 <dwcook> yukko, :(
00:20:21 <roboguy_> and things like lens use it internally
00:20:31 <merijn> orion: The general rule is: Forget about learning "monads", learn type signatures, learn typeclasses, study different *instances* of monad (rather than the general concept) and then things will seem easy, because they are
00:20:37 <roboguy_> well, not the monad part of Identity, but the functor part
00:20:40 <aarvar> Monads can't be generalized into anything other than their definition
00:21:00 <edwardk> Ainieco: we have monad transformers, they are build off of other monads. what is the base case?
00:21:06 <aarvar> there are multiple ways to define them though
00:21:10 <edwardk> er built
00:21:11 <merijn> i.e., study what the "Either e", Maybe, [], State s and other monad instances do
00:21:12 <orion> merijn: I read Typeclassopedia. I had a mental regression it seems.
00:21:15 <dwcook> Ainieco, here's an example. Are you familiar with State and/or StateT?
00:21:38 <dwcook> There are other examples that'd work, that one just occurred to me first
00:21:40 <Ainieco> dwcook: yep, familiar with State monad
00:21:53 <Cale> Ainieco: Well, the identity function on types happens to be a monad. While in the case of Haskell we can't write a monad instance for the *actual* identity function on types, we can define a newtype Identity a = I a, and make that an instance of Monad. Things which work with an arbitrary monad will "flatten out" in a particular way when you plug in the Identity instance.
00:21:54 <aarvar> State is defined using StateT and the identity monad
00:21:57 <dwcook> Ainieco, okay cool. Well State is just StateT but with m ~ Identity
00:21:59 <edwardk> Identity gives you a starting monad to play with, and its the thing all the monad transformers can use as the bottom step in the tower
00:22:50 <orion> aarvar: Monads may not be able to be generalized, but some ridiculously intelligent mathematician discovered them.
00:23:02 <Cale> Ainieco: For example, mapM :: (Monad m) => (a -> m b) -> [a] -> m [b] becomes (a -> Identity b) -> [a] -> Identity [b], and since we know that Identity b is essentially the same type as b, and Identity [b] is essentially the same type as [b], this is more or less the same thing as map.
00:23:03 <Ainieco> edwardk: ah, got it, when you don't know what mnonad stack you'll need behorehand - stick with identity and it'll be easy to add more monads on top of it, tight?
00:23:09 <aarvar> he wouldnt have to be ridiculously intelligent
00:23:17 <Ainieco> right*
00:23:26 <tac> orion: Intelligence has nothing to do with it.
00:23:35 <Cale> And yeah, monad transformers are another thing which work based on an arbitrary choice of monad
00:23:50 <Cale> So it can be interesting to look at what we get when that monad is the identity monad.
00:23:51 <roboguy_> isn't a monad essentially like a "higher order" monoid?
00:24:16 <Cale> roboguy_: Only in an abstract way which is hard to explain without a lot of set up
00:24:26 <mayski> heard in this channel "A monad is just a monoid in the class of endofunctors"
00:24:26 <c_wraith> roboguy_: in that categories are kind of like a generalization of monoids, and all monads are Kleisli categories...
00:24:34 <tac> roboguy_: If you use a categorical definition for monoid and swap "Sets" for a category of functors, you get a monad
00:24:37 <Cale> Well, I can point in the general direction of it...
00:24:40 <roboguy_> Cale: yeah. I have had some of that set up, and I *think* I sort of see it
00:24:55 <roboguy_> the "monoid in the category of endofunctors" makes more sense to me these days
00:24:59 <gsingh93> so it looks like ghci/haskell memoizes let bindings as long as the function containing the let binding has no arguments
00:25:02 <gsingh93> is that true?
00:25:25 <aarvar> what
00:25:27 <roboguy_> tac: so you can think of it as enriched?
00:25:30 <dwcook> mayski, that's basically correct if omitting a few details that would be useful if you didn't already know what it was
00:25:40 <tac> enriched has a distinct meaning as a technical term
00:25:46 <roboguy_> tac: I know
00:25:47 <tac> but fancy ass monoid works for me
00:25:54 <edwardk> roboguy_: there is a way to talk about monoids in category theory with respect to an arbitrary tensor-like structure, in that setting there is a way to talk about how functor composition gives you that structure, and that monads are the monoids with respect to it
00:26:02 <roboguy_> tac: you aren't talking about hom sets?
00:26:21 <Cale> roboguy_: A monoid (in the category of sets) consists of a set M together with an operation mu: M x M -> M for multiplication having an identity element. In order to express this in terms of arrows in a category, we can use the one-element set and demand a function eta: 1 -> M, picking out the identity element.
00:26:45 <orion> hmm
00:26:51 <edwardk> if you squint and replace (,) with Compose  and () with Identity with then you can get the monad types out of the monoid laws, and 'monoidal categories' is the way to talk about this similarity rigorously
00:27:09 <edwardk> there is another notion (day convolution) that if you look for the monoids for that you get applicatives
00:27:21 <dwcook> gsingh93, not exactly. It will evaluate any given variable once barring certain circumstances. That's not the same as memoization. Also, there's no such thing as a function with no parameters, perhaps you just mean a binding.
00:27:39 <roboguy_> Cale: right. is it one of those things where it obeys the monoid laws up to isomorphism?
00:27:43 <merijn> dwcook: I think he meant a non-eta expanded function?
00:27:44 <roboguy_> or is it not one of those things?
00:27:46 <mayski> dwcook: ok, I have that pasted in a file I keep open in my editor always with the intention of understanding what it says some day in far in the future :)
00:27:47 <sw17ch> I have a cabal sandbox setup. I’m using the `add-source` command to reference another repository. This all works great *except* that it appears to want to install the external repository every time I build the local repo. Anyone know why this might be?
00:27:49 <edwardk> and another notion where if you look for the monoids for that you get categories, and another notion to get arrows.. its all the same thing really
00:28:00 <merijn> dwcook: i.e. "f = const 1" as opposed to "f x = const 1 x"?
00:28:30 <Cale> and yeah, in the category of endofunctors, we can ask for an endofunctor M together with a natural transformation mu: M . M -> M, where now instead of Cartesian product, we have composition of functors, and then eta: 1 -> M where now 1 means the identity functor.
00:29:03 <orion> After reading this: http://www.haskell.org/pipermail/haskell-cafe/2007-August/029851.html I have come to the conclusion that Monads shouldn't be looked at as one whole unit, but rather a plurality of little units chained together with >>=.
00:29:04 <Cale> In Haskell, we use polymorphism to indicate natural transformations, so these become functions of types M (M a) -> M a, and a -> M a respectively
00:29:14 <Cale> :t join
00:29:15 <lambdabot> Monad m => m (m a) -> m a
00:29:17 <Cale> :t return
00:29:18 <lambdabot> Monad m => a -> m a
00:29:19 <tac> All this stuff, of course, becomes obvious if you spend your career studying functors ;)
00:29:28 <dwcook> mayski, it's not helpful on its own, but it may help you get the intuition once you read up on them.
00:29:46 <mayski> dwcook: I'll keep that in mind :)
00:29:50 <roboguy_> Cale: I've never fully understood the difference between parametric polymorphism and naturality. the descriptions of naturality seem to me to essentially just be a form of parametric polymorphism
00:30:00 <roboguy_> (which I'm sure is the backwards way to look at it, haha)
00:30:03 <dwcook> mayski, actually what Cale just said is more like it
00:30:09 <Cale> roboguy_: It's kind of similar, but polymorphism is stronger
00:30:17 <Cale> (in a way which is hard to capture)
00:30:18 <tac> roboguy_: Yeah. They aren't exactly the same thing.
00:30:22 <roboguy_> Cale: I've heard that, but I've always wondered what that means
00:30:30 <Cale> Well, what's a natural transformation?
00:30:34 <tac> Just consider a function with multiple type variables
00:30:39 <tac> already it doesn't quite work
00:30:49 <Cale> Given two functors F,G: C -> D
00:30:51 <roboguy_> Cale: a morphism between functors that has naturality
00:31:28 <Cale> A natural transformation eta: F -> G consists of, for each object x in C, a choice of arrow eta_x: Fx -> Gx in D
00:31:40 <gsingh93> dwcook: this is the specific example I'm looking at: http://pastebin.com/WKe8eCTW
00:31:40 <roboguy_> yeah
00:32:04 <Cale> such that for each arrow a: x -> y in C, we have that the square formed from eta_x, eta_y, Fa, and Ga will commute
00:32:06 <gsingh93> f will only print trace once, g will print it every time, even though it doesn't use the argument
00:32:07 <roboguy_> I remember that looking weird the first time I saw it, but it makes more sense
00:32:38 <gsingh93> so can i assume that whenever you call a function (where a function has at least one argument), if a let binding is used, it will always be re-evaluated?
00:32:47 <gsingh93> or where binding in this case
00:33:14 <splintax> ok, i am now constructing a DirTree during my build process, and i want to "save" that DirTree so that i can use it in my compiled program
00:33:24 <splintax> apparently the output of "show" is valid haskell source code
00:33:25 <Cale> So, because we get to control which arrow we choose on an object-by-object basis, that's a bit more like writing a polymorphic function by specifying it at each type individually. But there's a condition on how we do it for each function.
00:33:29 <dwcook> gsingh93, put one way, it would not be safe to assume that a let binding is shared across different scopes.
00:33:43 <splintax> how can i turn the output of "show" into a module that i can import
00:33:44 <gsingh93> ah, i see
00:34:23 <dwcook> gsingh93, do you recognize how there is just one b scoped to the binding of f, but a b for every invocation of g?
00:34:44 <dwcook> They just all happen to have the same identifier
00:34:57 <dwcook> (Well, more than "happen to")
00:35:04 <roboguy_> Cale: hmm, so the difference is in the fact that you don't need to make those squares commute?
00:35:11 <roboguy_> (in polymorphism)
00:35:41 <Cale> roboguy_: Parametric polymorphism gets us something which has to be natural, but it does it in a way which involves using the same definition at every choice of type
00:35:46 <gsingh93> dwcook: I think i get it now
00:36:32 <roboguy_> Cale: oh, I think I see. you aren't restricted to one definition for each object with naturality in general?
00:36:32 <tac> I think it makes more sense if you look at the categorical semantics of polymorphic type theory
00:36:32 <Cale> roboguy_: The definition of a natural transformation doesn't require us to define eta_x in the "same way" in any sense as eta_y, it just has to work out that all the squares commute, but that's something which can just work out after the fact perhaps.
00:37:02 <trap_exit> is there any notion of meta data in haskell?
00:37:08 <tac> from what I know, whenever you have a term t with type T, defined in terms of a context of variables G, you get a typing judgment: G |- t : T
00:37:10 <trap_exit> I want somethign which is a Map, but nas ah extra Int associated (with the entire map)
00:37:14 <dwcook> gsingh93, okay, good. A note on terminology: f and g are both bindings. g is bound to a function. f is not, so calling f a function would be erroneous. See "Mixing up functions and definitions" here: http://conal.net/blog/posts/everything-is-a-function-in-haskell
00:37:15 <trap_exit> and I want all map operations to work on my new type
00:37:31 <Cale> trap_exit: Use (Int, Map a b) ?
00:37:31 <tac> and that typing judgment is really the arrow in your category. Not the ->'s in the function type
00:37:32 <roboguy_> trap_exit: something like (Int, Map ...)?
00:37:48 <trap_exit> Cale, roboguy_ : well, the functions that work on Map do not work on (Int, Map ...)
00:37:52 <dwcook> gsingh93, conal uses the word "definition", which may be more accurate than "binding", I'm not sure. I'd accept either.
00:37:53 <roboguy_> trap_exit: they do with fmap
00:37:55 <trap_exit> I have to destruct the tuple first
00:37:58 <Cale> trap_exit: well, sure
00:38:11 <roboguy_> trap_exit: fmap (in the context of pairs) applies a function to the second argument of a tuple
00:38:16 <trap_exit> I want an object that for all necessary purposes behaves like a map, but has this meta data (of an Int) tagbged with it
00:38:23 <Cale> trap_exit: But neither do they all make sense
00:38:37 <Cale> trap_exit: What is union meant to do with the Ints?
00:39:11 <Cale> union :: Ord k => Map k a -> Map k a -> Map k a
00:39:19 <trap_exit> on shit
00:39:21 <trap_exit> yeah
00:39:23 <trap_exit> this doesn't work
00:39:27 <trap_exit> thanks :-)
00:40:20 <roboguy_> trap_exit: well, depending on what you're doing, you might be able to use one of the Monoid or Semigroup newtype wrappers for stuff like Int
00:41:15 <trap_exit> no, I should just manually define this, it'll make life easier
00:41:58 <roboguy_> if you want to use the max Int every time you union it (for example), a Semigroup thing might be nicer I think
00:43:05 <roboguy_> > (Max 1, M.fromList []) Data.Semigroup.<> (Max 50, M.fromList [])
00:43:07 <lambdabot>  Not in scope: data constructor ‘Max’Not in scope: data constructor ‘Max’Not ...
00:43:18 <roboguy_> > (Data.Semigroup.Max 1, M.fromList []) Data.Semigroup.<> (Data.Semigroup.Max 50, M.fromList [])
00:43:20 <lambdabot>  Not in scope: data constructor ‘Data.Semigroup.Max’Not in scope: data constr...
00:43:23 <roboguy_> oh well
00:58:56 <tlevine> pl
00:59:06 <tlevine> pl 3
00:59:12 <tlevine> @pl 3
00:59:12 <lambdabot> 3
00:59:20 <tlevine> @pl f 3
00:59:21 <lambdabot> f 3
00:59:27 <tlevine> @pl f x && f y
00:59:28 <lambdabot> f x && f y
01:01:23 <trap_exit> can the haskelll type system capture the following, where K = type, diff = func, update_with = func; and :: forall (v1 v2: K), update_with v1 (diff v1 v2) = v2
01:02:12 <dv-> @pl \x y -> f x && f y
01:02:13 <lambdabot> (. f) . (&&) . f
01:04:37 <qnikst> dv_ (&&) `on` f ?
01:06:33 <BartAdv> oh my, why it is always the same: 'let's check that lib', cabal install, ExitFailure :(
01:06:42 <trap_exit> is there a queue built entirely out of MVar without having to use STM ?
01:07:39 <NikolajK> do people creat smartphone programs with Haskell? Is that possible?
01:08:27 * hackagebot optparse-applicative 0.9.1 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.9.1 (PaoloCapriotti)
01:13:28 * hackagebot simple-pipe 0.0.0.7 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.7 (YoshikuniJujo)
01:13:38 <tac> NikolajK: I don't know if anyone has tried it yet, but there are lots of issues associated with that, I think
01:13:48 <tac> I think*
01:14:43 <tac> Not that it's impossible, but it's weird in a compiled language, since you need to have the right lib files for everything. And you're targeting ARM. And ARM support was iffy last time I checked.
01:14:54 <tac> With android, you have to use the NDK, too.
01:18:28 * hackagebot xml-pipe 0.0.0.6 - XML parser which uses simple-pipe  http://hackage.haskell.org/package/xml-pipe-0.0.0.6 (YoshikuniJujo)
01:21:09 <NikolajK> ARM? NDK?
01:21:36 <tac> ARM is the processor most phones run
01:21:51 <tac> I think I have the NDK acronym right... the native development kit
01:22:22 <c_wraith> It'd be more accurate to call ARM a family of processors.  It's approximately like x86, in breadth of family memberss.
01:22:22 <tac> android will only work with dalvik bytecode by default
01:22:46 <dv-> someone made a demo program for android with haskell. i've run it
01:22:53 <dv-> it's even on the play store iirc
01:23:40 <NikolajK> why do people comment with "-- | foo" and not just "-- foo"
01:24:08 <Enigmagic> NikolajK: http://www.haskell.org/haskellwiki/IPhone
01:24:21 <tac> NikolajK: -- | is for Haddock comments
01:24:22 <SaBer> tac: NDK is specifically an Android thing, and allows you to run native code (C, C++ etc)
01:24:32 <tac> SaBer: yes
01:24:48 <Enigmagic> and: https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling/iOS
01:24:51 <NikolajK> Enigmagic: k thx
01:25:23 <NikolajK> The haddock (Melanogrammus aeglefinus) is a marine http://en.wikipedia.org/wiki/Fish distributed on both sides of the http://en.wikipedia.org/wiki/Atlantic_Ocean.
01:25:53 <NikolajK> This is Haddock, a tool for automatically generating documentation from annotated Haskell source code.
01:25:55 <NikolajK> k
01:33:52 <trap_exit> is it posible to exspress the folllwing in Haskell: "for every time K, there is a type "diff K" which reprensetns a differentialy between two valuers v1 :: K and v2:: K"
01:34:40 <Kinnison> You can have a typeclass which means that, but you'll need to instance it yourself
01:34:46 <Kinnison> unless I've misunderstood you
01:35:50 <trap_exit> I need to define an object of the following type:
01:36:00 <trap_exit> StateDiff = StateInit a | StateDiff b
01:36:10 <trap_exit> but I want to say "b" is uniquely dependent on a
01:36:14 <trap_exit> so imagine I have a bunch of listeners on a MVar
01:36:26 <trap_exit> I want to send listeners one of two types "StateInit full_value"
01:36:31 <trap_exit> or "StateDiff _diff_erential_value"
01:36:48 <trap_exit> but I say to say "a / b" ;are not to arbitrary values ... b is dependent on a, ...
01:36:52 <trap_exit> I'm not sure a typeclass can do this
01:36:55 <trap_exit> however, I may be wrong
01:37:11 <trap_exit> Kinnison: how do yoyu do this with a typeclass? ()imagine I want to diff an Int, a List, and a Map)
01:37:19 <trap_exit> where for Map, diff = list of state add/dels
01:37:31 <trap_exit> Int diff = just the (new_value - old_value)
01:37:34 <trap_exit> and forget about List
01:38:53 * Kinnison is not an expert, but imagines something (untested) like:
01:39:09 <Kinnison> class Diff a where
01:39:42 <Kinnison>   diff :: a -> a -> SomethingIDontKnowWhat
01:39:43 <trap_exit> how do I get the "b" ?
01:39:55 <trap_exit> SomethignIDontKnowWhat depends on a though
01:39:58 <trap_exit> for Int, it's an Int
01:40:03 <trap_exit> for Map k v, it's [(k, v)]
01:40:05 <Kinnison> Mmmm
01:40:12 <Kinnison> Good point
01:40:16 <trap_exit> well, for Map k v, it
01:40:19 * Kinnison is a tad lost :-)
01:40:21 <trap_exit> Add k v | Del k
01:40:37 <trap_exit> [ (Add k v) | (Del k) ]
01:40:42 <trap_exit> I bet there's some haskell extension for this
01:41:00 <supki> class Diff a b | a -> b where diff :: a -> a -> b
01:41:02 <supki> ?
01:41:15 <supki> I confess I have a hard time understanding the problem :)
01:41:39 <trap_exit> I confess I did not explain it very well.
01:41:40 <Kinnison> supki: because you know the syntax (| a -> b) which I was missing from my head
01:41:54 <Kinnison> supki: I knew it was possible, but google was failing me and I'm not well
01:41:54 <trap_exit> or rather, it's not very clear in my mind
01:42:00 <Kinnison> supki: s'my excuse and I'm sticking to it
01:42:06 <trap_exit> because if I understood it well, I would have written the types
01:42:14 <trap_exit> and had I written the types, I woul hav e no ned to ask the question :-)
01:51:05 <trap_exit> https://gist.github.com/anonymous/ed2227177c00d5e0d865 <-- why can't I comple this code?
01:51:13 <trap_exit> "Too many parameters for class 'Diffable'"
01:51:43 <merijn> trap_exit: Did you enable MultiParameterTypeclasses?
01:51:57 <trap_exit> merijn: http://www.haskell.org/haskellwiki/Multi-parameter_type_class ... not yet
01:52:29 <merijn> trap_exit: Haskell2010 only allows typeclasses with 1 parameter, so your class requires the multiparam GHC extension :)
01:52:42 <trap_exit> merijn: ah, it now compiles; thanks!
01:52:46 <SaBer> I also remember being surprised when I discovered this...
01:53:22 <merijn> yeah, in my opinion the report is overly conservative when it comes to multiparameter typeclasses and FlexibleInstances
01:53:35 <trap_exit> no no, this is badass
01:53:41 <trap_exit> I feel that every langauge extension I use is like a badge
01:53:49 <trap_exit> it's like "oh, you have no wearned the OverloadedStrings badge"
01:53:50 <trap_exit> yay!
01:53:57 <trap_exit> "you have now earned the BangPatterns badge"
01:53:59 <trap_exit> yay yay!
01:54:01 <trap_exit> etc ...
01:54:11 <trap_exit> the haskell guys are gamifying compiler options
01:54:35 <merijn> @quote cutting.edge
01:54:35 <lambdabot> edwardk says: {-# LANGUAGE time to pay the cutting edge typing features tax #-}
01:54:39 <merijn> :)
01:55:44 <merijn> trap_exit: Well, it's more that GHC is taking the opposite approach of gcc, gcc is lenient and allows all sort of non-standard C unless you enable a specific standard, pedantic mode, etc. GHC defaults to only allowing standard haskell and requiring pragma's for any extensions
01:56:08 <merijn> (Well, GHC defaults to only allowing *almost* standard haskell, it deviates in a few minor ways)
01:56:10 <trap_exit> merijn: I like my gamification theory better :-)
01:56:41 <trap_exit> let's just pretend the ghc developers sat around thinking "hmm, what badges can we create for people"
02:01:53 <mayski> trap_exit: heh I was thinking exactly the same thing
02:02:03 <AshyIsMe> is there a trick to figuring out which versions of packages you depend on you should allow in the cabal file?
02:11:54 <quchen> You mean so your boundaries are as large as possible? I don't know any
02:12:04 <quchen> Trial and error mostly :-X
02:12:28 <Cale> Especially when it comes to upper bounds, which are silly
02:12:30 <AshyIsMe> yeah, damn
02:12:53 <AshyIsMe> i'll just go greater than or equal too what i have currently
02:14:46 <quchen> That usually works. If you have the time, you can also specify the lower bound only and build that in a sandbox.
02:15:04 <quchen> (By specify I mean "require the version you'd like to test")
02:16:05 <trap_exit> consider https://gist.github.com/anonymous/cbae4d9cbbebce1c745c ... how can I create a Statemonad where the only things I can do are (1) read state and (2) modify the state through diffable__apply
02:16:10 <AshyIsMe> is there a way to list which packages i currently have installed in the sandbox?
02:16:36 <merijn> Or just randomly lower and push to github and see whether travisCI completes your tests succesfully ;)
02:16:57 <quchen> AshyIsMe: cabal exec ghc-pkg list
02:17:12 <quchen> It'll show you all accessible packages, and includes the sandbox if you're in one
02:17:24 <Twey> Why does GHC.TypeLits not provide a succ constructor for Nat?  I can use (n - 1) but then I have to enable UndecidableInstances
02:17:59 <merijn> trap_exit: "newtype MyDiffState s a = MyDiffState (State s a)" and then don't export the constructor and write manual wrappers that use State to implement those two functions? :)
02:18:21 <AshyIsMe> quchen: cheers
02:18:44 <trap_exit> merijn: damn that's elegant, I was going to write a monad myself ... but I like your solution more
02:18:45 <Hafydd> I don't think you can really prevent the user from arbitrarily modifying the state.
02:19:07 <merijn> trap_exit: It's the lazy people solution ;) That's (one of the reasons) why we have newtype :)
02:19:22 <merijn> Hafydd: Sure you can, in my example how does the user arbitrarily modify the state?
02:19:52 <merijn> If you don't export the newtype constructor they have no way to get to the "State s a" and thus no way to modify the state, except through your custom functions
02:20:35 <merijn> trap_exit: My want to look into GeneralizedNewtypeDeriving extension to let GHC automatically derive Functor,Applicative, Monad, etc. instances for MyDiffState
02:20:45 <Hafydd> merijn: won't there be a function to get the state out at the end of a computation, though?
02:21:00 <Hafydd> And one to put it in at the beginning.
02:21:30 <merijn> Hafydd: Sure, but if for example you have a library that only takes a "MyDiffState" and runs it internally, then you know that whatever the user gave your function can only modify state in a limited way
02:21:54 <merijn> So it depends on how you plan to use it
02:21:59 <Hafydd> Hmm...
02:23:44 <Hafydd> I suppose so!
02:23:47 <trap_exit> merijn: definitely not
02:23:53 <trap_exit> merijn: I learn lazily
02:23:59 <trap_exit> merijn: not before I need it :-)
02:24:18 <dfeuer> This is mostly untested, so it could be wrong and/or bad, but the Core I've looked at so far looks promising: http://lpaste.net/108482
02:24:53 <merijn> trap_exit: Basically that just says "automatically implement a Monad instance for MyDiffState that is identical to the one of the underlying (in this case State) type"
02:25:55 <merijn> trap_exit: Because otherwise you will have to manually write "instance Functor (MyDiffState s) where fmap f (MyDiffState x) = MyDiffState (fmap f x)", etc.
02:26:25 <zq> is backpack coming to 7.10?
02:27:18 <adas> has the snap web framework ceased development? Because, I see that it's been on version 0.6 for a long time
02:27:57 <trap_exit> merijn: I see what you nmean now
02:28:00 <trap_exit> merijn: thanks!
02:33:24 <adas> anyone?
02:36:36 <Cale> adas: 0.6?
02:37:01 <Cale> adas: The latest version of snap to be uploaded to Hackage was 0.13.2.8, and that was on Jul 24
02:37:26 <zq> adas: http://hackage.haskell.org/package/snap-0.13.2.8 http://hackage.haskell.org/package/snap-core-0.9.6.3
02:38:01 <merijn> This is the second time I see someone ask about some hackage package supposedly ceasing when the last update was less than two months ago. I wonder where you found that 0.6 version?
02:40:04 <adas> Cale: but the main website still highlights version 0.6
02:40:25 <adas> http://snapframework.com/
02:40:37 <adas> the last news update on that page talks about 0.6
02:40:48 <Cale> I guess it's not technically news
02:41:11 <Cale> Though it isn't untrue that they did that in 0.6 :)
02:42:11 <Cale> If you follow the commandline steps they give though, you'll still get the latest version
02:42:49 <Cale> Also, if you click on the "Blog" section, they have announcements and stuff for the newer versions
02:43:54 <adas> yup. just noticed the blog announcements
03:00:36 <arianvp_> morning
03:22:38 <bernalex> benmachine: LOL'd at your HWN quote
03:23:10 <quchen> HWN? It still exists?!
03:23:32 <bernalex> quchen: yeah it made a comeback earlier this year
03:23:42 <quchen> bernalex: And then it went away again, no?
03:23:57 <bernalex> no
03:24:00 <quchen> Oh boy, it seems they stopped posting it to Reddit
03:24:02 <bernalex> @quote stunt
03:24:02 <lambdabot> benmachine says: adoption by lots of people may stunt progress of haskell, but it will probably help the progress of people
03:24:07 <bernalex> that was the quote btw
03:24:28 <quchen> I have a lot of reading to do
03:28:57 <gfixler> is there a way to navigate older HWN posts easily?
03:29:10 <gfixler> the URL's unfortunately have month, year, and issue number in them
03:30:03 <quchen> gfixler: http://contemplatecode.blogspot.de/
03:31:01 <gfixler> quchen: right, that makes me click "Older Posts" over and over again
03:31:07 <gfixler> it would be nice to see an index of all issues
03:31:52 <quchen> I don't think there's a way to do it without clicking.
03:32:36 <gfixler> quchen: okay - maybe I'll script it
03:33:58 <zq> ugh
03:34:09 <zq> why is snap forcing me to install heist? what if i don't want to to use heist
03:35:19 <bennofs> zq: it's because snap includes a Heist snaplet
03:39:15 * hackagebot optparse-applicative 0.9.1.1 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.9.1.1 (PaoloCapriotti)
04:17:12 <Tjr> After some googling, I'm still missing a reliable checklist to know when unsafePerformIO is safe.
04:18:03 <Tjr> For example, in RWH, the FFI chapter calls a perl regexp library via unsafePerformIO.
04:18:16 <Tjr> In that example, I'm wondering why unsafePerformIO is thread-safe.
04:21:00 <ChristianS> Tjr: i'd guess it's only thread-safe if it doesn't hurt doing the same I/O action twice
04:21:01 <bernalex> Tjr: it's safe-ish if the IO computation does not permit side-effects & is independent of its environment
04:21:33 <bernalex> it's never type safe
04:21:44 <Tjr> Say your C library uses a global ERROR variable.
04:22:27 <Tjr> Assume your Haskell code stores the old ERROR away, clears it, runs the actual C code, then restores ERROR.
04:22:56 <Tjr> In that scenario, I'd want to make sure nobody interrupts (and overwrites ERROR).
04:23:03 <arianvp_> hmm
04:24:28 <Tjr> (For the sake of argument, let's assume you can be sure there are no other global variables in use.)
04:27:35 <Twey> Tjr: http://stackoverflow.com/questions/1694164/is-errno-thread-safe
04:29:21 * hackagebot snaplet-redis 0.1.3.3 - Redis support for Snap Framework  http://hackage.haskell.org/package/snaplet-redis-0.1.3.3 (DmitryDzhus)
04:30:01 <Tjr> Twey: specializing to ERRNO: I've been told that GHC makes haskell code run in more than one thread internally. Therefore, haskell would presumably execute in more threads than the C it calls. So you still get ERRNO shared along (haskell) threads.
04:30:39 <Twey> Tjr: Yes, but FFI calls are guaranteed to not be called more than once from the same thread
04:31:03 <Tjr> Twey: interesting. I didn't see anything to that effect in RWH.
04:31:56 <arianvp_> hmm
04:32:13 <Twey> Tjr: If marked with ‘unsafe’ I think
04:32:16 <arianvp_> does anybody here use Docker to maintain multiple haskell dev environments?
04:32:57 <Tjr> Twey: what do you mean by "marked with unsafe"?
04:34:06 <arianvp_> Tjr:    foreign import ccall unsafe
04:34:12 <arianvp_> instead of  foreign import ccall
04:34:23 <Tjr> ah, I remember.
04:34:33 <Twey> Tjr: http://www.haskell.org/ghc/docs/7.8.3/html/users_guide/ffi-ghc.html#ffi-threads
04:36:08 <Tjr> That deals with whether ffi calls from different threads run in parallel. In the ERROR scenario above, I'd want to serialize not just the ffi call, but the entire "block" of ERROR, ffi, ERROR.
04:36:44 <Twey> Tjr: Well, reading and setting ERROR would also be in FFI.
04:36:49 <Twey> (I'd hope)
04:37:02 <Tjr> it probably is, but it's a separate ffi call
04:37:32 <Twey> Hm, yes, I don't think that's safe
04:38:01 <Twey> The documentation explicitly states that operations in the same Haskell thread can operate in multiple OS threads.
04:38:14 <Tjr> it probably is when you're talking about C's ERRNO, but the more general point still stands -- what do I have to do to make sure a (general) ffi usage is threadsafe.
04:39:01 <Twey> Oh, but you can use a bound thread to make sure that's not the case
04:43:33 <merijn> Tjr: I think the most reasonable way is to use an "MVar ()" shared between all threads as a mutex before calling FFI code
04:44:59 <Twey> merijn: Doesn't marking it unsafe effectively already do that?
04:45:02 <Tjr> That's basically locking, right?
04:47:11 <merijn> No
04:47:28 <Twey> Oh, right, shared between OS threads as well.
04:47:37 <merijn> 1) unsafe means "call in an unsafe way", not "this is unsafe"
04:48:07 <merijn> 2) that is about whether the C call is done on another OS thread from the haskell thread
04:48:13 * Twey blinks.
04:48:48 <merijn> Calling an unsafe FFI function calls the function right in the current capability thread that is executing haskell code
04:49:04 <merijn> Locking up that capability and stopping it from running haskell until the FFI call returns
04:49:26 <merijn> It also prevents GC, and doesn't allow calling back into haskell
04:49:32 <Twey> Right
04:49:54 <merijn> "safe" FFI calls are run in a seperate OS thread, allowing the capability to keep executing different haskell threads and perform GC
04:50:32 <merijn> If you have multiple capabilities running (i.e. multithreaded execution) then unsafe C calls can happen in parallel in each of them
04:51:04 <tejing> I'm slightly lost with monad transformers here: what value of type StateT (_,Char,_) IO a writes the char to ouput and what stores an input char?
04:51:07 <merijn> And if you perform safe C calls will happen in separate OS threads (plural!), so they can still happen in parallel
04:51:33 <merijn> Tjr: Yes, you need to do locking if you C calls are not threadsafe
04:51:44 <Twey> merijn: Right.  So ‘unsafe’ calls block the current OS thread from calling other FFI functions (amongst other things).
04:51:58 <merijn> Twey: They block it from doing *anything*
04:52:03 <Twey> Exactly
04:52:07 <merijn> Twey: Because it'll be running the C code
04:52:19 <merijn> (This also means no thread preemption)
04:53:43 <Twey> So for errno, which is thread-local, that's all you need — to make sure that nothing else that uses errno is called on the same OS thread
04:54:04 <merijn> Is errno thread-local?
04:54:06 <k00mi> tejing: do (_,c,_) <- get; liftIO $ putChar c
04:54:09 <Twey> Yep — see above
04:54:14 <Twey> By POSIX
04:54:42 <merijn> Then you may want to use forkOS instead of forkIO
04:54:57 <k00mi> tejing: do c <- liftIO $ getChar; modify ((a, _, b) -> (a,c,b))
04:55:02 <merijn> Else you're boned anyway if you want to access errno
04:55:27 <bartavelle> yes you need forkOS
04:56:23 <Twey> Right, forkOS if it's three separate FFI calls rather than one
04:56:34 <bartavelle> well, with forkIO it will probably seem to work properly until you put it in production :)
04:56:36 <Twey> So that they all happen in the same OS thread
05:01:39 <Tjr> bartavelle: that's the general impression I've got after googling around a bit regarding unsafeperformio and ffi
05:04:43 <gp5st1> I'm sorry I'm not getting this:-\ https://dpaste.de/fu1c/raw doesn't compile bcause what I'm returning in factors isn't correct.  Through some playing it looks like I'm returning [[Int]] but that's not the return type of compl_factors, so I'm not sure what's going on :(
05:07:33 <merijn> gp5st1: What's the point of the return in factors?
05:07:40 <tejing> k00mi, thanks :-)
05:07:49 <merijn> gp5st1: factors already returns a list
05:08:22 <Tjr> gp5st1: takeWhile should be >= , else 9 doesn't have 3 as a factor
05:08:38 <merijn> gp5st1: Try "factors n = compl_factors n (base_factors n)"?
05:08:39 <k00mi> tejing: glad to help, feel free to ask if you have more questions
05:08:46 <gp5st1> merijn: factors is suppose to have other lines, but this messed up return type seems to be causing me issues
05:08:57 <merijn> gp5st1: Well, that's my point
05:09:06 <gp5st1> Tjr: good catch! thanks!
05:09:11 <merijn> gp5st1: With your current type that line can't possible type check
05:09:29 <merijn> gp5st1: factors returns [Int], compl_factors returns [Int]
05:09:37 <gp5st1> merijn: ? It is being type-checked, though? it's erroring @ compile time
05:09:47 <merijn> "return (compl_factors ??)" <- this definitely doesn't type check
05:10:12 <merijn> gp5st1: Well, you're not pasting the entire code, nor the error
05:10:23 <merijn> gp5st1: I'm just telling you the code you pasted cannot possibly be correct
05:10:50 <merijn> If your actual code is different I can't tell you anything about it, as I'm not telepathic :)
05:10:59 <gp5st1> merijn: it's not :-p that's why I'm here. maybe return isn't what I thought it was
05:11:21 <gp5st1> merijn: no, that's what I tried compiling and got a type error
05:12:18 <gp5st1> anyway, thank you. I think return isn't what I originally though
05:12:19 <merijn> :t return
05:12:21 <lambdabot> Monad m => a -> m a
05:12:35 <merijn> :t return [1] :: [Int]
05:12:37 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘[t0]’
05:12:37 <lambdabot>     In the first argument of ‘return’, namely ‘[1]’
05:12:37 <lambdabot>     In the expression: return [1] :: [Int]
05:12:48 <Tjr> gp5st1: can you describe in words what compl_factors is supposed to do?
05:14:24 <asmyers> :t return 1 :: [Int]
05:14:25 <lambdabot> [Int]
05:14:30 <gp5st1> Tjr: base_factors returns all factors less than the sqrt of the number. compl_factors is returning the complementry factors for those (so base_factors 33 returns 3, but not 11)
05:14:49 <Tjr>  o i c
05:15:19 <gp5st1> merijn: thanks yeah I think I got confused looking at some examples I found about something else
05:15:50 <Tjr> gp5st1: factors n =  compl_factors n $ base_factors n
05:16:02 * Tjr thinks that should work
05:16:13 <merijn> Tjr: That's what I proposed earlier :)
05:16:23 * Tjr scrolls back
05:16:35 <gp5st1> Tjr: well, I wanted to run the ouput of compl_factors back through factors to get it down to all prime factors
05:16:54 <gp5st1> and was trying to assign things to a name and then do things, hence the do
05:17:50 <gp5st1> but then I used return, which didn't do what I thought because , well, because I didn't know any better :-(
05:18:18 <Tjr> so you're really trying to find a list of all prime factors?
05:19:15 <gp5st1> Tjr:
05:19:18 <gp5st1> yes
05:19:29 <Tjr> Then I'd use a different algorithm
05:19:37 <Tjr> however, let's get back to what you have right now
05:19:47 <gp5st1> blach, can't type. yeah I though it'd be a "nice" first program
05:20:10 <mmmm> is there a reason you can't use functions defined in a where clause in view patterns?
05:20:44 <merijn> mmmm: Because functions in where clauses have the  arguments in scope, I'm guessing?
05:20:53 <Tjr> @define { foo :: Int -> [Int] ; foo n = do return n }
05:20:56 <lambdabot>  Defined.
05:21:01 <Tjr> > foo 3
05:21:03 <lambdabot>  [3]
05:21:24 <Tjr> gp5st1: does that clarify what "return" means in the context of lists?
05:22:17 <gp5st1> Tjr: not really. it's simply wrapping the argument in a list.
05:22:25 <Twey> gp5st1: Yep, that's what it means.  ;)
05:22:33 <merijn> :t return
05:22:33 <mmmm> makes sense
05:22:33 <Tjr> indeed, that's what  return does
05:22:34 <lambdabot> Monad m => a -> m a
05:22:51 <Tjr> here, the monad involved is simply []
05:22:55 <Tjr> i.e. a list
05:23:59 <Tjr> gp5st1: return is probably misnamed. It just wraps its argument up in whatever monad it's called with.
05:24:26 <gp5st1> Tjr: I thought monads were functions. What function is being represented by [] in that case? ([] 3 won't compile in ghci)
05:24:34 <gp5st1> Tjr: thanks for taking the time to explain this
05:25:04 <gp5st1> Tjr: I do appreciate it
05:25:21 <byorgey> gp5st1: monads are not functions.
05:25:39 <gp5st1> byorgey: well there's my first mistak
05:25:48 <Tjr> well, [] is kind of an exception in that the symbol [a,b,c] is decoded to a:b:c:[] (and so on)
05:26:04 <Tjr> so the really basic thing in this case is ":"
05:26:11 <Tjr> @type …
05:26:13 <lambdabot> parse error on input ‘…’
05:26:13 <Tjr> @type :
05:26:15 <lambdabot> parse error on input ‘:’
05:26:20 <Tjr> @type (:)
05:26:21 <lambdabot> a -> [a] -> [a]
05:26:37 <byorgey> [] has two different meanings in Haskell.  One is the empty list.  The other is the list type constructor.
05:27:02 <Tjr> Taken together, (:) and []  are constructors for the datatype of a list.
05:27:11 <byorgey> It does not make any sense (i.e. it is a type error) to say that the empty list is a monad
05:27:27 <adimit> (one [] is term-level, and one [] is type level. And, in fact, there's '[], which is kind-level.)
05:27:37 <byorgey> but it does make sense to say that the list type constructor is a monad (and it is true).
05:27:49 <Tjr> adimit: I can't understand that.
05:28:07 <merijn> adimit: Kind level is also [], the ' is only needed for disambiguation in some places :p
05:28:11 * Tjr suspects gp5st1  is confused by all that.
05:28:18 <gp5st1> byorgey: yes, which I didn't know how the constructor was represented
05:29:39 <adimit> Tjr: there are three levels in the Haskell type system. The empty list is a term []. But ([]) Int is a type! (Equivalent to [Int]) And kinds are a level higher than types still (but it's not necessary to understand that when learning Haskell initially.)
05:29:59 <adimit> (but it is nice to know that there are three levels, and [] makes sense in all three of them, but means something different.)
05:30:02 <adimit> merijn: true!
05:30:58 <bernalex> you can think about [] on the type level like Maybe. they both need something to make sense.
05:31:02 * Tjr knows what types, kinds, constructurs, etc are
05:31:08 <bernalex> a Maybe does not make sense. you need a Maybe Int, for instance.
05:31:16 <bernalex> so [] does not make sense. you need a [Int].
05:31:36 <bernalex> Tjr: types are things like Int, String, Char
05:32:30 <bernalex> Tjr: Maybe and [] are type constructors used for making a type.  they are not types by themselves.
05:32:44 <bernalex> Tjr: you can't make a value Maybe. but you can have a Maybe Int, or a [Int].
05:32:54 <bernalex> Tjr: a value is like 3, "something", 'A'.
05:33:15 <byorgey> bernalex: Tjr just said they already know all this stuff
05:33:15 <bernalex> Tjr: 3 is a value, of e.g. type Int
05:33:26 <bernalex> byorgey: that's why I'm explaining what a value & type is.
05:33:58 <gp5st1> I'm the one not "in the know" I get types (to some level) I was just confusd as to what monad [] was representing (what the list constructor is) in the case of return
05:34:08 <Sonderblade> i want to apply a foldl using an operation which has no easily expressable "zero value", like a set intersection
05:34:22 <bernalex> Tjr: a type *constructor* is used to construct a type. Maybe or [] takes a type argument, like Int or String. so you can have a Maybe String, with the value Just 5.
05:34:30 <bernalex> erm Just "5"
05:34:35 <Sonderblade> how do you express that in haskell? the pattern differs from the standard sum example, because there is no 0 to start with
05:34:37 <byorgey> Sonderblade: use foldl1
05:35:12 <Tjr> bernalex: I know all that. All I wanted to say is, I suspect that these explanations aren't as easy on  newbies as we#d like.
05:35:40 <bernalex> byorgey: erm
05:35:45 <merijn> Sonderblade: Isn't the zero value for Set intersection trivial? It's the empty set...
05:35:47 <bernalex> Tjr: byorgey: right. IDK how I misread that twice lol.
05:35:56 <merijn> oh, wait
05:35:59 <merijn> No, I'm dumb
05:35:59 <Sonderblade> byorgey: that was easy :)
05:36:00 <Tjr> Sorry, I should have been initially.
05:36:21 <adimit> gp5st1: ([]) (as a type) on its own *does* make sense. It's a type function of kind (* -> *) "Monad" on its own is a type function of kind ((* -> *) -> *) (well sort of. It's actually ((* -> *) -> Constraint)) Kinds are to types much like types are to terms. So in essence, Monad needs an "argument" of type (* -> *) to produce a *type*. Things of kind '*' are called "type."
05:36:28 <rio> merijn: that would be unions :>
05:36:37 <Sonderblade> merijn: it's the set that contains everything, but i dont know how to write that in haskell
05:36:45 <merijn> Sonderblade: Note that foldl1 crashes on empty lists
05:37:21 <adimit> So (Monad []) is of kind "Constraint". I.e. it's a type constraint.
05:37:33 <adimit> > :k Monad [] -- I hope this works.
05:37:34 <lambdabot>  <hint>:1:1: parse error on input ‘:’
05:37:42 <adimit> eh. ok. You can try that out in GHCi.
05:37:45 <bernalex> it's just
05:37:47 <bernalex> :k Monad []
05:37:49 <lambdabot> Constraint
05:37:59 <adimit> bernalex: duh. Thanks for catching my derp.
05:38:02 <arianvp_> Sonderblade: yes
05:38:41 <arianvp_> Sonnderblade: you're looking for sconcat :: NonEmpty a -> a  from the semigroup package
05:38:45 <bernalex> Monad [] is just the same as
05:38:48 <bernalex> :k Num Int
05:38:49 <lambdabot> Constraint
05:38:59 <bernalex> so nothing magical.
05:39:13 <arianvp_> semigroups*
05:39:57 <adimit> I've never succeeded in teaching people parametric polymorphism without introducing kinds. While it initially complicates things to a three-level picture, I think it's kind of necessary to fully (and more easily) grasp the concept. Or maybe I can't teach. That might also be the case :-P
05:40:13 <merijn> adimit: I have the same experience
05:40:53 <bernalex> adimit: don't they understand how length works?
05:40:58 <bernalex> oh right
05:41:01 <bernalex> misread again
05:41:06 <bernalex> that kind of needs the list :-P
05:41:28 <bernalex> oh! I misread again! I need to calibrate my monitor
05:41:37 <bernalex> or my eyes. :-]
05:41:46 <arianvp_> Sonderblade: you could make  Set an instance of Semigroup by using intersect as the definition for <>
05:41:48 <bernalex> why do you need kinds to explain parametric polymorphism?
05:42:08 <adimit> bernalex: it's all interdependent, that's the problem. The notion of parametric polymorphism *depends* on the notion of distinction of the type level into differend, well *kind*s of type-level constructs.
05:42:29 <adimit> And being able to explicitly name them (*, * -> *, (* -> *) -> *, etc) is useful.
05:42:37 <bernalex> the way I explain it is just "when a function is defined to have the same behaviour for different types". consider: length [1, 2, 3] or length "test".
05:42:38 <merijn> bernalex: Bigger font :p
05:42:48 <bernalex> merijn: yep just upped the font
05:42:58 <bernalex> merijn: I'm sitting in a very relaxed position, far away from the monitor :-P
05:43:18 <Sonderblade> arianvp_: i see no advantage of that over foldl1
05:43:31 <arianvp_> Sonderblade: They're equivalent
05:43:59 <arianvp_> Except semigroup doesnt accept empty lists. so it cant crash
05:44:08 <adimit> bernalex: this will maybe work for simple type functions, like [], or even (,), but once you introduce stuff like Monad, people stop understanding it. In fact, I think people stop understanding it at (,).
05:44:23 <bernalex> & then ad-hoc polymorphism is just when a function has different behaviour for different types. (1 :: Int) + (1 :: Int) is different to (1 :: Float) + (1 :: Float), or you might have a collide a b that takes a Body, which might be a ball or a wall, and it might be different depending on types.
05:44:37 <bernalex> adimit: well I thought you just meant the concept of parametric polymorphism
05:44:41 <bernalex> which I think is simple.
05:44:49 <adimit> It's like Java-Land thinks generics are the wierdest most difficult to understand thing in the world. But they're not.
05:45:16 <pjdelport> Well, they're weird and difficult because they're so verbose and limited.
05:45:19 <adimit> But you have no way of really telling different generics apart except from, well it's this wierd notation or that wierd notation. You need systematicity.
05:45:48 <bernalex> I think haskell really nailed ad-hoc polymorphism. I love it.
05:45:52 <bernalex> it sucks so hard in most languages.
05:45:55 <adimit> bernalex: well the concept is one thing. Being able to use it and solve exercises with it is another. And start thinking in it.
05:46:04 <pjdelport> I have fresh memories of writing a binding mini-framework for Android last year, and you could tell it's Java because the generic type names would line-wrap. :P
05:46:09 <bernalex> adimit: to me, and the ones I've taught, it comes with intuition & practice.
05:46:45 <bernalex> adimit: just like all functional concepts. when you grok it, you go "oh wow that's so neat!", and before long you'll have it in your toolbox naturally by doing exercises or writing toy projects.
05:47:00 <bernalex> at least this is my experience :-]
05:47:15 <Tjr> pjdelport: that's when I'd dream about a preprocessor that lets me substitute short names for these generic monsters
05:47:22 <adimit> bernalex: I was teaching it on a theoretical level — exercises on paper, with no compiler to tell you you're a numbnut. So people need to know the calculus.
05:47:46 <adimit> And I think it's the safest way to really grok the concept. These people have an easier time understanding Haskell type classes.
05:47:48 <bernalex> adimit: I prefer ghci fun when teaching
05:48:07 <bernalex> adimit: and then eventually people end up reading papers and byorgey stuff, heh.
05:48:21 <bernalex> haskell is a nice gateway drug to lambda calculus
05:48:25 <adimit> bernalex: well, but there are people who want to learn System F and friends and have no interest in learning Haskell (linguists, for example.)
05:48:44 <pjdelport> Tjr: You can shorten them to some extent with subclasses that capture more specific types: I had a bunch of classes that essentially just instantiated more generic types to more specific ones. (It would have been even more unreadable without that.)
05:48:55 <adimit> and telling them "go learn Haskell" would be a huge waste of their time, since they're no programmers.
05:49:05 <bernalex> adimit: yeah I see. I "teach" programmers, and I am one myself. so Haskell kind of sparks an interest in Girard-Reynolds and so on.
05:49:29 <Cale> adimit: Not to mention that System F is pretty simple compared to Haskell
05:49:34 <adimit> bernalex: I can see that :-) But there's more to typed λ-calculus than Haskell.
05:50:00 <bernalex> Cale: definitely.
05:50:24 <bernalex> but this is #haskell, so I just automatically assumed we were talking about teaching haskell. :-] with the new context, adimit is making sense though.
05:50:26 <adimit> Cale: yes. No need to go for all the weird stuff in Haskell when all you need is System F. And actually, in one case I needed to teach F-sub, and Haskell's an ill fit for that (better go to OCaml.)
05:50:56 <adimit> bernalex: eh, yeah. Well. I'm the odd linguist in #haskell. Though there are two or three others.
05:50:57 <bernalex> at first I thought it sounded absurd to teach kinds before teaching people how length works :-P
05:51:15 <bernalex> adimit: yeah there's augur at least
05:52:31 <adimit> yup.
05:52:39 <adimit> there was another whose name I forgot.
05:53:03 <zmbmartin> Having trouble with types and monads. If I have a Just list say Just ["a", "b", "c"]. How can check if an element in in the list.
05:53:31 <zmbmartin> I have tried filter, find, etc but I get Couldn't match expected type errors.
05:53:33 <bernalex> zmbmartin: well you need a function (a -> b) -> m a -> m b, right? :-]
05:53:50 <adimit> zmbmartin: you could use fmap, or you could pattern match, or you could use monadic bind.
05:54:05 <frerich> zmbmartin: Do you know how you would check if an element in the list if yuo had a plain list, i.e. without the "Just"?
05:54:19 <adimit> > length `fmap` Just [1..10]
05:54:21 <lambdabot>  Just 10
05:54:30 <pjdelport> zmbmartin: You can use lifting:
05:54:30 <pjdelport> > elem "b" $ ["a", "b", "c"]
05:54:32 <lambdabot>  True
05:54:39 <pjdelport> > elem "b" <$> Just ["a", "b", "c"]
05:54:40 <lambdabot>  Just True
05:54:48 <bernalex> :t (<$>)
05:54:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:54:56 <pjdelport> > elem "b" <$> Nothing
05:54:56 <adimit> (note fmap == (<$>)
05:54:57 <lambdabot>  Nothing
05:55:11 <bernalex> zmbmartin: trust the types & don't fear the monad. :-]
05:55:22 <zmbmartin> Thanks guys
05:55:27 <bernalex> zmbmartin: can you see how <$> works? note that <$> is just an infix operator that is the same as fmap.
05:55:39 <adimit> also note:
05:55:45 <bernalex> zmbmartin: it lets you use a function a -> b, on an m a, and get an m b back.
05:55:46 <adimit> > length <$> Nothing
05:55:47 <lambdabot>  Nothing
05:55:49 <zmbmartin> bernalex: I am having a hard time with all this strict typing coming from ruby and javascript.
05:55:55 <kuribas> Why do I need Eq for Ord?  You could define Eq as "(a == b) = compare a b == EQ"
05:55:59 <bernalex> zmbmartin: have you heard of hoogle?
05:56:06 <bernalex> @hoogle (a -> b) -> f a -> f b
05:56:08 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
05:56:09 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
05:56:09 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
05:56:16 <zmbmartin> I have seem it when I google stuff.
05:56:24 <bernalex> zmbmartin: it lets you search for types! which is really cool
05:56:30 <bernalex> zmbmartin: because you have a function like this
05:56:35 <bernalex> :t elem "4"
05:56:36 <lambdabot> [[Char]] -> Bool
05:56:38 <bernalex> or whatever
05:56:41 <bernalex> so that's a -> b
05:56:51 <kuribas> zmbmartin: Types make you think more about your design, but thats a good thing IMO.
05:56:55 <bernalex> then you have something like a list, which is f a. and you need to get the f b out of it.
05:57:08 <bernalex> so you can search for (a -> b) -> f a -> f b in hoogle, and get suggestions. :-]
05:57:28 <bernalex> zmbmartin: and <$> is very cool because of course, it is not limited to lists. do you know what a Maybe is?
05:57:47 <zmbmartin> kuribas: I agree just frustrating at this point. I like the idea of the end result and when I understand them better.
05:57:50 <adimit> kuribas: Ord is strictly more informative than Eq. You can also define "comapre a b | a == b = EQ
05:58:10 <zmbmartin> bernalex: Not fully yet. is Learn you a haskell a good starting book.
05:58:18 <adimit> zmbmartin: yes.
05:58:30 <zmbmartin> I am on chapter 6 so haven't got to all the meat yet.
05:59:01 <bernalex> zmbmartin: OK. Just is a Maybe. Just 5 is of type Maybe Int. so Just 5 is a value for Maybe Int.
05:59:06 <kuribas> zmbmartin: When I started to get better in correctly typing my haskell programs, I usually had a better understanding about the problem space too.
05:59:20 <kuribas> zmbmartin: But yeah, it can be frustrating at first :)
05:59:37 <bernalex> zmbmartin: so here's one last example I want to make for you.
05:59:40 <bernalex> > 5 + 3
05:59:41 <lambdabot>  8
05:59:44 <bernalex> > 5 + Just 3
05:59:45 <lambdabot>  No instance for (GHC.Show.Show a0)
05:59:45 <lambdabot>    arising from a use of ‘M78962373357984155215592.show_M78962373357984155215...
05:59:45 <lambdabot>  The type variable ‘a0’ is ambiguous
05:59:45 <lambdabot>  Note: there are several potential instances:
05:59:45 <lambdabot>    instance [safe] GHC.Show.Show
05:59:51 <bernalex> see that won't work, because you have a Just 3
05:59:57 <bernalex> <$> to the rescue!
06:00:04 <bernalex> > (+5) <$> Just 3
06:00:05 <lambdabot>  Just 8
06:00:22 <bernalex> zmbmartin: so it works on other things than lists too. :-]
06:00:51 <bernalex> zmbmartin: and again, note that <$> is the same as fmap. you might want to stick to writing fmap now, so you don't get confused by having too many operators
06:01:00 <bernalex> > fmap (+5) (Just 3)
06:01:01 <lambdabot>  Just 8
06:01:11 <Twey> kuribas: Eq is smaller (more inhabited) than Ord, is all
06:01:11 <zmbmartin> bernalex: Awesome thanks!
06:01:32 <zmbmartin> I appreciate everyones insight and help.
06:01:32 <kuribas> Twey: yes, true...
06:01:37 <Twey> kuribas: If we had class defaults then we'd use those, instead, so you only had to define Ord and you'd get Eq for free
06:01:44 <bernalex> zmbmartin: NP! keep coming here with questions. there are some really knowledgeable people in here. :-]
06:01:47 <Twey> kuribas: But we don't, so it's a prerequisite
06:01:53 <pjdelport> zmbmartin: The mnemonic way to understand <$> is that it's supposed to be analogous to $ (or plain application), just to make that explicit.
06:01:54 <cin> just use fmap forever
06:02:10 <zmbmartin> I am sure I will have pleanty.
06:02:13 <bennofs> :t forever fmap
06:02:15 <lambdabot>     No instance for (Functor f0) arising from a use of ‘fmap’
06:02:15 <lambdabot>     The type variable ‘f0’ is ambiguous
06:02:15 <lambdabot>     Note: there are several potential instances:
06:02:21 <zmbmartin> pjdelport: OK cool.
06:02:22 <cin> :t  fmap fmap fmap fmap fmap fmap fmap fmap fmap
06:02:23 <lambdabot> (Functor f3, Functor f2, Functor f1, Functor f) => f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
06:02:23 <pjdelport> zmbmartin: So anywhere you have f $ x, you can treat the right side as a functor by saying f <$> xx
06:02:25 <bernalex> pjdelport: yeah but '$' is pretty bad mnemonics
06:02:36 <bernalex> pjdelport: I like F#'s <| and |> a lot. SPJ likes them too.
06:02:49 <bennofs> :t forever id
06:02:50 <bernalex> haskell's '$' and '&' are really dumb in comparison IMO.
06:02:51 <lambdabot> a -> b
06:02:59 <cin> bernalex, SPJ also likes do { x ; y } notation
06:03:05 <pjdelport> bernalex: Well, I have it as $· in my .ghci, so i'm probably not one to talk :)
06:03:08 <kstt> Do you think we will have something simple and standardized soon to improve the haskell records ? The fact that updates need the litteral is often annoying.
06:03:14 <bernalex> cin: yes, and I can very much see why. especially in GHC. though I disagree. :-]
06:03:24 <bernalex> pjdelport: you have whtat?
06:03:26 <cin> kstt, ghc 6.10 should have overloaded record fields
06:03:29 <bernalex> pjdelport: I'm confused lol
06:03:30 <Twey> kstt: Check out Lens and Vinyl
06:03:37 <Twey> cin: We're on 7.8.3 now ;)
06:03:39 <adimit> kstt: lens. Lens. lenses solve *all* yor problems.
06:03:43 <cin> er, 7.10
06:04:03 <kstt> Twey: lens is the cause and the solution to most 2014' haskell problems.
06:04:16 <bernalex> adimit: I used to have a problem then I used lens now I have an abstraction problem?
06:04:24 <kstt> In any case, it is not simple nor standardized
06:04:29 <cin> https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Design
06:04:33 <pjdelport> bernalex: For playing with Applicative, I've been experimenting with: let (·) = (<*>); (·>) = (*>); (<·) = (<*); ($·) = (<$>)
06:04:46 <bernalex> pjdelport: ewww
06:04:48 <bennofs> :t forever (fmap :: (a -> b) -> Maybe a -> Maybe b)
06:04:50 <lambdabot> (a -> b1) -> b
06:04:52 <pjdelport> f $· x ·
06:04:53 <cin> a newbie had a problem, "i know, i'll use lens!" everyone else now had a problem
06:05:11 <bernalex> cin: lol
06:05:14 <pjdelport> err, so you can say "f $· x · y · z" and so on
06:05:19 <adimit> you're all just trying to get into Haskell News..
06:05:30 <bernalex> pjdelport: yeah I see
06:05:55 <bennofs> @remember bernalex I used to have a problem then I used lens now I have an abstraction problem?
06:05:56 <lambdabot> Done.
06:05:56 <bernalex> pjdelport: have you played with the lens applicatives?
06:05:56 <cin> adimit, i could never get into haskell news. i prefer pokemon
06:06:08 <kstt> cin: thank you, this is indeed useful, though a bit voodoo under the cover.
06:06:12 <pjdelport> bernalex: No, not yet.
06:06:26 <bernalex> pjdelport: http://izbicki.me/blog/lens-you-an-applicative-for-great-haskell it is pretty insane
06:07:28 <kstt> cin: but what annoys me most is the fact that updating records require the field litteral. This is not parametric at all. Lens hides this by generating the plumbing, but still the plumbing is made of filed litterals for updates.
06:08:54 <pjdelport> bernalex: zany!
06:09:06 <bennofs> bernalex: you think you know what is insane? https://github.com/ekmett/hask/blob/master/src/Hask/Core.hs  -- also read the commit messages
06:09:11 <kstt> Five minutes ago, I wrote a function to "toggle the on/off state" of a record. How verbose.
06:09:39 <Tjr> adimit: What's Haskell News?
06:10:04 <bennofs> Tjr: Haskell Weekly News http://contemplatecode.blogspot.de/search/label/HWN
06:10:12 <kstt> looks like : toggle r = r { state = not $ state r }
06:10:21 <bernalex> Tjr: Haskell Weekly News. presently it's a weekly digest of most voted reddit + stackoverflow links.
06:10:32 <bernalex> bennofs: oh, hask
06:10:41 <bennofs> bernalex: plus quotes from this channel
06:11:06 <Tjr> interesting, thank you
06:11:07 <Twey> kstt: Maybe so, but it replaces them with much more interesting problems.  :þ
06:11:13 <bernalex> bennofs: using edwardk code as an example of abstraction insanity is kind of cheating
06:11:40 <Twey> kstt: toggle = state %~ not
06:12:48 <bennofs> toggle = do not & over state -- lens
06:12:50 <hexagoxel> can i create a constraint that restricts the elements of a HList to be lists?
06:13:00 <kstt> But this requires the lens hammer. It is just huge and involves so much trouble with dependencies on large projects.
06:13:01 <bernalex> bennofs: I mean we're talking about a guy who said that he doesn't sleep because he feels he functions better when sleep deprived, because half his brain is shut off so he stops second-guessing himself all the time
06:13:01 <Twey> bennofs: Mine was Lens :þ
06:13:17 <bennofs> Twey: that is lens too
06:13:26 <Twey> bennofs: But longer and with a redundant do :þ
06:13:35 <{AS}> @pl \f g x y -> g (f x) y
06:13:35 <lambdabot> flip (.)
06:13:40 <bernalex> bennofs: I think this might mean that ordinary people need to be *completely braindead* to understand edwardk's code. I have yet to verify this.
06:13:59 <Twey> bennofs: do not & over state = not & over state = over state not = state %~ not
06:14:20 <cin> bernalex, if you were completely braindead you probably wouldn't be able to articulate your understanding to someone, therefore it seems hard to verify
06:14:38 <bennofs> Twey: i know ... it just reads nicer as "do not overstate lens"
06:14:55 <Twey> Oh, I see.  Hahah, cute.
06:15:09 <Twey> Pardon me for missing your pun :þ  I've only just had my coffee.
06:15:14 <bernalex> cin: yes, I admit my theory has some issues with regards to testing it.
06:15:29 <kstt> cin: but your mates would admit that you understood, in the benefit of the doubt.
06:15:32 <cin> why do people drink coffee?
06:15:39 <bernalex> cin: I think I will leave it as a prediction, and have some grad student test it.
06:15:40 <cin> i only ever hear people explaining how lack of it makes them stupid
06:18:34 <Twey> cin: Consumption of it makes me smarter (or at least improves my memory).  I don't actually like it that much, I just drink it for that reason.
06:19:36 <bernalex> I'm an energy drink kind of guy myself
06:20:13 <bernalex> it's the caffeine drug that's good for memory stuff. no need for the actual coffee. :-]
06:20:58 <bernalex> caffeine also postpones sleepyness. add sugar, and you get an initial energy boost as well. caffeine by itself doesn't work for quite a few hourse. and again, it only postpones sleep. it doesn't give you energy.
06:20:59 * Tjr is a sleep, water, exercise kind of druggie.
06:21:12 <bernalex> the best thing is of course getting enough sleep
06:21:35 <bernalex> Tjr: yeah I drink only a few energy drinks a week at most. typically Mondays for not being in bed early enough on Sundays. I drink a lot of water. :-]
06:21:56 <cin> Tjr, me too
06:22:02 <bernalex> exercising is also good. but I find it infuriatingly boring so I don't do it. even if it's apparently extremely popular now, and everyone looks down on you for not doing it. :-]
06:22:26 <cin> bernalex, that's a myopic way of looking at an age old activity
06:22:28 <gregnwos`> single geek gsoh, n/s seeks ghc 7.8 armhf binaries for nsa fun
06:22:33 <Tjr> bernalex: the trick is to read a paper right before, and to think up a counterexample while you're running through the woods
06:22:39 <bernalex> cin: it is certainly trendy now
06:23:13 <cin> bernalex, by "now" you mean "since forever"?
06:23:16 <bernalex> Tjr: when we're moving offices my plan is to buy exercise bikes and watch anime
06:23:42 <Tjr> bernalex: uh oh ...
06:24:00 <cin> you know, an alternative is to just go outside
06:24:00 * Tjr predicts bernalex will not need a shower afterward.
06:24:06 <cin> there's loads of space out there
06:24:15 <cin> things to look at, etc
06:24:22 <kuribas> bernalex: Exercise doesn't have to be boring, you could do a martial art or Tai Chi or something...
06:24:22 <bernalex> Tjr: thinking of hooking it up to an arduino board & make it slow down/stop playing if I'm not cycling. :-]
06:24:25 <bernalex> cin: I find that boring.
06:24:28 <bernalex> kuribas: I think that's boring.
06:24:36 * hackagebot bindings-friso 0.1.0.0 - Low level bindings for friso  http://hackage.haskell.org/package/bindings-friso-0.1.0.0 (cosmo0920)
06:24:37 <Twey> bernalex: *nod* I find coffee works better, though.  I don't know why.  I always used to drink energy drinks, too.  Might be placebo.
06:24:40 <bernalex> people always give me these long speeches when I say that I don't exercise. :-]
06:24:44 <cin> lazy people always call things boring
06:25:02 <bernalex> and then I get attitude like that, yes. all too predictable. :-]
06:25:28 <Tjr> cin: lazy people have a very important ability: to assess whether something is important.
06:25:30 <cin> bernalex, well, imagine someone tells you that they don't read books or do any intellectual pursuits
06:25:44 <kuribas> bernalex:  If you mean by boring that you don't have to use your brain, then I disagree...
06:25:48 <bernalex> cin: that's fine by me. I know many who don't. :-]
06:25:59 <bernalex> kuribas: I mean boring as in it is not interesting to me, and I'd rather do something else. :_]
06:26:08 <Twey> But exercise isn't an intellectual pursuit.  It doesn't involve much thinking at all.
06:26:20 <kuribas> Twey: depends on the exercise...
06:26:24 * Twey also finds exercise boring, so does high-intensity exercises that don't take very long
06:26:25 <cin> Twey, intellectual pursuit is exercise for the mind
06:26:28 <Tjr> exercise is basically an emotional pursuit.
06:26:47 <TheKing444> @def isBoring = (<=(5::Int)) . unSafeCoerce
06:26:48 <Tjr> since you get rewarded with runner's high
06:26:49 <lambdabot>  .L.hs:151:30: Not in scope: ‘unSafeCoerce’
06:27:23 <TheKing444> @def isBoring = (<=(5::Int)) . unSafeCoerce
06:27:24 <lambdabot>  Defined.
06:27:33 <TheKing444> > isBoring "Exercise"
06:27:35 <lambdabot>  *Exception: Prelude.undefined
06:27:37 <kuribas> Twey: For exercise to be really beneficial, you should be aware what you are doing.
06:27:58 <TheKing444> > isBoring "Knowledge"
06:28:00 <lambdabot>  *Exception: Prelude.undefined
06:28:10 <kuribas> Twey: Just running your body into exhaustion isn't necessarily beneficial.
06:28:16 <jedai42> Tjr: But a sane body is important to a sane mind and in our society that means some exercise. So you could say that in certain bounds it's an intellectual pursuit.
06:28:34 <cin> it's just what is natural for human beings
06:28:44 * Tjr disagrees with the sane mind / sane body saying.
06:28:50 <merijn> I propose continuing in -blah
06:28:56 <cin> we're not evolved to be sedentary blobs like orangutans
06:29:14 <TheKing444> We should make a haskell exercise program.
06:29:20 <TheKing444> Would that make everyone happy?
06:29:48 <jedai> Tjr: seriously ?
06:30:58 <TheKing444> :t putStr "Did you exercise?" >> getLine >>= (\x -> case head x of; 'y' -> putStrLn "Gooooooood"; 'n' -> putStrLn "Exercise")
06:30:59 <lambdabot> IO ()
06:31:10 <TheKing444> There, intellectual.
06:31:19 <TheKing444> Is there anything the IO monad can't do?
06:31:39 <Hafydd> Solve the halting problem.
06:31:49 <frerich> TheKing444: It cannot guarantee having no sideeffects.
06:32:09 <{AS}> safeperformIO
06:32:17 <Hafydd> Nor can pure code.
06:32:20 <Tjr> TheKing444: it can't get paid for me
06:32:43 <Hafydd> Er, well, I mean code outside of IO.
06:32:53 <merijn> {AS}: "safePerformIO :: IO a -> IO a; safePerformIO = id" :D
06:32:54 <Hafydd> "pure code" doesn't have side effects by definition.
06:33:04 <{AS}> merijn: :)
06:33:15 <TheKing444> @def safePerfromIO = id :: IO a -> IO a
06:33:17 <lambdabot>  Defined.
06:33:38 <Tjr> now apply safePerformIO to a continuation.
06:33:57 <TheKing444> @def doesItHalt x = True --It always halts!
06:33:58 <lambdabot>  Defined.
06:34:46 <TheKing444> doesItHalt $ return ()
06:35:02 <TheKing444> > doesItHalt $ return ()
06:35:04 <lambdabot>  No instance for (GHC.Base.Monad m0)
06:35:04 <lambdabot>    arising from a use of ‘GHC.Base.return’
06:35:04 <lambdabot>  The type variable ‘m0’ is ambiguous
06:35:04 <lambdabot>  Note: there are several potential instances:
06:35:04 <lambdabot>    instance GHC.Base.Monad ((->) r) -- Defined in ‘base:GHC.Base’
06:35:10 <TheKing444> ugh
06:35:15 <Marquis> hello haskellers. i need to work with a Hashmap in Haskell. I installed the hashmap module with cabal. now i strugle to add a key value pair to an empty hash map. How is that done?
06:36:02 <jedai> Marquis: You realize that HashMap is immutable right ?
06:36:15 <TheKing444> https://hackage.haskell.org/package/hashmap-1.0.0.2/docs/Data-HashMap.html#insert
06:36:20 <TheKing444> the insert function
06:36:23 <Trollinator> doesn't it work in the ST monad??
06:36:30 <jedai> So you can insert a value into the empty hashmap but it creates a new hashmap
06:36:34 <TheKing444> (Like jedai said, you are actually making a new one.)
06:36:42 <Trollinator> ah, never mind. That was HashTable
06:37:19 <Marquis> yeah thats okay to get a new hashmap
06:37:50 <Marquis> i want something like insert 5 "hello" empty
06:38:05 <TheKing444> Can lambdabot import stuff?
06:38:05 <Marquis> so i get the hashmap with 5 -> "hello"
06:38:11 <TheKing444> > import Data.HaskMap
06:38:13 <lambdabot>  <hint>:1:1: parse error on input ‘import’
06:38:23 <TheKing444> > +m Data.HashMap
06:38:25 <lambdabot>  <hint>:1:1: parse error on input ‘+’
06:38:38 <k00mi> Marquis: use the package unordered-containers instead of hashmap
06:39:11 <Trollinator> you can use fromList [(5, "hello")]
06:39:21 <jedai> Marquis: So do it ?
06:39:36 <jedai> Marquis: or use singleton eventually but that's equivalent
06:40:35 <Marquis> if i do the insert think like i mentioned i get type errors
06:41:04 <k00mi> Marquis: you should import the module qualified, because there is a 'insert' function on lists
06:41:14 <Marquis> i did that
06:41:42 <Marquis> okay, now i got it thank you
06:44:38 * hackagebot hackage-db 1.8 - provide access to the Hackage database via Data.Map  http://hackage.haskell.org/package/hackage-db-1.8 (PeterSimons)
06:49:39 * hackagebot cabal2nix 1.67 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.67 (PeterSimons)
06:54:20 <raichoo> Anyone knows how to display type roles in GHCi. I recall that I did that once in a while without knowing how.
06:54:45 <frerich> raichoo: type "roles"? Do you mean kinds?
06:54:58 <frerich> (You can do that with ':k')
06:55:50 <MP2E> :k Maybe
06:55:52 <lambdabot> * -> *
06:56:00 <k00mi> raichoo: :i also gives the role of a type
06:56:05 <merijn> frerich: No, roles are new
06:56:18 <merijn> frerich: They're related to type-safe coercion
06:56:46 <raichoo> k00mi: Weird. does not seem to work here.
06:57:22 <merijn> frerich: For example if you have "newtype Age = Age Int" then it's safe to coerce "Age" to "Int" (same representation), coercing "Maybe Age" to "Maybe Int" is also safe
06:57:37 <raichoo> frerich: http://www.haskell.org/ghc/docs/latest/html/users_guide/roles.html
06:57:56 <merijn> frerich: However, "Set Age" can't safely be coerced to "Set Int", since Age and Int may use different Ord typeclasses and "Set" depends on that typeclass
06:58:24 <TheKing444> Here is something that is better than unSafeCoerce:http://www.haskell.org/haskellwiki/GHC/Coercible
06:58:38 <frerich> Interesting!
06:58:45 <TheKing444> Works just like it except instead of segfaults you get type errors, or so I hear.
06:58:54 <frerich> merijn: I suppose that won't work for Word8 to Word16 though or similiar?
06:59:14 <k00mi> raichoo: what are you trying it on?
06:59:25 <frerich> merin: I.e. it's really about the representation of the type, not the inhabitants?
07:01:10 <raichoo> k00mi: I'm probably doing it wrong. defined "data Foo a = Foo a". and :i Foo
07:03:30 <raichoo> k00mi: Ah!Works when I make 'a' a Phantom type
07:03:57 <merijn> frerich: No, because those don't have the same representation
07:04:01 <raichoo> I guess it's not displaying representational roles then.
07:04:13 <merijn> frerich: Yes, it's for typesafe coercion based on representation
07:04:26 <k00mi> raichoo: yup, seems like. It also works if you annotate it as nominal
07:04:32 <frerich> merijn: What does 'representation' mean in this context?
07:04:53 <merijn> frerich: The actual code generated by GHC
07:05:01 <merijn> frerich: Basically, it's cast
07:05:14 <merijn> frerich: unsafeCoerce can segfault for that reason
07:05:27 <merijn> frerich: The idea is to have a coerce that can't segfault
07:05:52 <merijn> By statically guaranteeing the source and destination type have identical runtime representations
07:06:09 <raichoo> k00mi: Jup, tried it with a type family. It only seems to display phantom and nominal. Seems reasonable.
07:10:52 <kuribas> Is it possible to introduce variables in guards?  For example comparing on a Maybe type?
07:11:46 <kuribas> Nevermind, a simple case will do in this case...
07:21:10 <edwardk> kuribas: foo | Just a <- ...., keep guarding in here <- .., using a all over = ... works just fine these are "pattern guards"
07:23:29 <kuribas> edwardk: oh nice!  So if put "a | Nothing <- ... " it can be total?
07:24:12 <kuribas> (or otherwise)
07:24:23 <edwardk> yep
07:24:24 <angerman> Great, cabal hates me; is this fixable? if so, how would I go about it? http://lpaste.net/6149021518526414848
07:24:43 * hackagebot http-media 0.2.0 - Processing HTTP Content-Type and Accept headers  http://hackage.haskell.org/package/http-media-0.2.0 (TimothyJones)
07:27:39 <supki> angerman: the easiest way out of this would be to install hakyll in the fresh sandbox
07:28:00 <angerman> supki, how?
07:28:07 <mmmm> cabal sandbox init
07:28:18 <mmmm> cabal install Hakyll
07:28:33 <stolaruk> I'm fairly new to concurrent programming and am learning how to use STM. I have a number of IntMaps inside TVars. When I get a value from such an IntMap, change something in the value, and put it back in the IntMap, should all of this be part of a single transaction? (Presently my "get from map" and "put in map" are two separate transactions, but I wonder if they should be composed into a single transaction.)
07:30:01 <angerman> mmmm, supki thanks!
07:30:45 <merijn> stolaruk: "It depends"
07:31:11 <merijn> stolaruk: It should be part of a single transaction if it's an error for someone else to change the value between you reading it and storing it
07:31:29 <stolaruk> merijn: Yeah, that's what I'm afraid of
07:32:13 <merijn> stolaruk: Suppose we have thread 1 and 2, "1 reads value X, 2 overwrites value X, 1 writes new value X, overwriting 2's value"
07:32:16 <jesyspa> Hullo, I'm writing an interpreter and ran into the issue that I'd like to take a runtime value and choose functions of various types based on it.  I came up with this solution http://lpaste.net/108492 , but I end up with a lot of code duplication this way for the various dispatch functions.
07:32:18 <stolaruk> I'm trying to learn how to think about concurrency better.
07:32:21 <merijn> stolaruk: If that's a bug, then a single transaction
07:32:42 <jesyspa> Is there any type I can use that will cover all functions like this?
07:32:58 <stolaruk> merijn: Yeah, that makes sense. Thanks!
07:34:32 <jesyspa> (Or some other way that would allow me to choose a type based on a value.)
07:35:17 <yukko> you could write it in coq and export it to haskell (not a serious suggestion but that's what dependant typing is for)
07:36:35 <jesyspa> I'm not sure this is really full-blown dependent typing, though.  I guess it's not so much choosing a type, as choosing a specific instantiation of a polymorphic function.
07:40:59 <m3taa> hi?
07:41:09 <angerman> m3taa: hi?
07:41:09 <Ankhers> hi!
07:41:44 <m3taa> can anyone install aesonbson without a problem?
07:46:00 <allsystemsarego> m3taa, I'm trying it in a sandbox as we speak
07:48:58 <kqr> how much work would it take to get record syntax replaced with some sort of lensy solution in newer versions of haskell? record syntax just doesn't compose
07:49:12 <m3taa> I get this weird error and have no idea what to do :(
07:49:24 <edwardk> kqr: there is a weak form of that in the works through the overloaded record fields proposal in 7.10
07:49:45 <edwardk> kqr: with that you'll be able to use a combinator to take any field name and get a lens
07:49:57 <edwardk> just need to figure out what to call that combinator! =)
07:50:20 <m3taa> http://pastebin.com/36qNwmPe
07:50:21 <kqr> edwardk, what combinator are you talking about? is there anywhere i can read about this aspect of the proposal?
07:50:28 <allsystemsarego> m3taa, yup, I was able to reproduce the type mismatch, contact the library maintainer or file a big
07:50:40 <allsystemsarego> *bug
07:50:42 <bergey>           m3taa: It looks like you'll need to add an upper bound on aeson, maybe on other things.
07:50:55 <edwardk> kqr: the ORF machinery makes accessors overloaded in a slightly fancy way, so then we can make an appropriate instance for some newtype that we unwrap to get a lens
07:51:10 <edwardk> kqr: there is a talk adam hgundry gave at skillsmatter online somewhere
07:51:13 <edwardk> er gundry
07:53:14 <m3taa> thanks for the help
07:53:57 <beaky> hello
07:54:04 <kqr> edwardk, hm
07:54:14 <kqr> edwardk, i found the talk, i'll take a look at it
07:54:54 <bergey> m3taa: cabal install --constraint='aeson<0.7' --constraint='aeson>=0.6' works for me
07:56:20 <stelleg> anyone know what version of GHC FP complete is running?
07:56:47 <stelleg> ah nevermind
07:56:49 <stelleg> you can choose
07:56:51 <stelleg> very cool
07:57:59 <beaky> how do i update all my haskell libs
07:59:05 <quchen> cabal install <package> probably installs a newer version when there is one.
07:59:48 <allsystemsarego> beaky, check out "--upgrade-dependencies"
08:00:06 <beaky> ok
08:00:11 <beaky> btw what is a cabal sandbox
08:00:34 <beaky> i love cabal it makes installing stuff easy
08:00:41 <dhrosa_> hi beaky
08:01:09 <kqr> beaky, with sandboxes, you can install a package just for a project without it affecting the rest of your system
08:01:20 <dhrosa> beaky: ever used virtualenv with python?
08:01:51 <kqr> beaky, for example, if your IRC bot project needs some network library, you can install that in the sandbox and it will only be accessible from that sandbox
08:01:59 <kqr> beaky, it makes it easier to deal with clashing versions and such
08:01:59 <beaky> dhrosa: yeah it makes like a self-contained python installation with all the dependencies and stuff for the project
08:02:09 <dhrosa> beaky: that's what cabal sandbox does basically
08:02:16 <beaky> how do i know im in a cabal sandbox
08:03:40 <kqr> if you have a file that says .cabal-sandbox you probably are
08:03:45 <kqr> a directory, rather
08:03:56 <beaky> how do i build a cabal project
08:04:01 <beaky> 'cabal install'?
08:04:04 <kqr> cabal build
08:04:07 <beaky> oops
08:04:12 <kqr> cabal install will build and install the project
08:04:26 <kqr> cabal install --only-dependencies installs all dependencies
08:04:47 * hackagebot pipes-aeson 0.4.1.2 - Encode and decode JSON streams using Aeson and Pipes.  http://hackage.haskell.org/package/pipes-aeson-0.4.1.2 (RenzoCarbonara)
08:04:49 * hackagebot data-variant 0.28.0.0 - A variant data type, useful for modeling dynamically-typed programming languages  http://hackage.haskell.org/package/data-variant-0.28.0.0 (TobiasDammers)
08:04:51 * hackagebot hpaco-lib 0.28.0.0 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.28.0.0 (TobiasDammers)
08:04:53 * hackagebot hpaco 0.28.0.0 - Modular template compiler  http://hackage.haskell.org/package/hpaco-0.28.0.0 (TobiasDammers)
08:06:09 <zmbmartin> How do you I set the Type for this -> here is the error: Couldn't match expected type `IO [Database.RethinkDB.NoClash.JSON]' with actual type `Bool'
08:06:46 <jesyspa> Hm, after some playing around with type families, it looks like http://lpaste.net/108492 works, although I have to modify the runWith functions.  Is what I'm doing a bad idea?  It feels like I want type-level lambdas, but I bet those aren't available for a reason.
08:07:13 <beaky> btw what is a higher order function
08:08:01 <TheKing444> I did "cabal install hat -v" and got ExitFailure 1 because terminfo-0.4.0.0's config step failed. What do I do?
08:08:02 <dhrosa> beaky: a function that takes other functions as arguments
08:08:04 <dhrosa> beaky: like map
08:08:15 <beaky> so its like a first class function?
08:08:42 <dhrosa> well, all functions in haskell are first class
08:09:51 <beaky> so even a function like Int -> Int is first class?
08:10:01 <kqr> beaky, "first class functions" means the language supports passing functions as arguments and returning them and all that
08:10:16 <kqr> beaky, haskell supports that, meaning functions are first class in haskell
08:10:33 <gp5st> beaky: first class means that you can pass the function around like a variable (pass them, return them, assign them) in addition to just calling them
08:10:52 <kqr> beaky, as they are in python and a lot of other modern languages (even Java, with Java 1.8!)
08:11:08 <Ankhers> Java lets you do that now?
08:11:20 <beaky> Ankhers: yes java has lambadas
08:12:00 <kqr> Ankhers, it's still no haskell, but java 8 is a bliss to work with compared to older versions
08:13:27 <TheKing444> @def thisIsAFunction x = x^2-2*x+1
08:13:30 <lambdabot>  Defined.
08:13:35 <beaky> what is a function
08:13:42 <TheKing444> > map thisIsAFunction [1,2,3]
08:13:44 <lambdabot>  [0,1,4]
08:13:58 <TheKing444> thisIsAFunction is a function
08:14:00 <TheKing444> beaky
08:14:04 <beaky> kqr: now if only android will support java 8 :(
08:14:18 <MP2E> I'm sure they don't want to get sued again :P
08:14:25 <MP2E> Oracle doesn't seem to take too kindly to that
08:14:33 <Ankhers> > map (*2) [1..3]
08:14:35 <lambdabot>  [2,4,6]
08:14:39 <kqr> beaky, a function is a mapping from domain to codomain
08:14:48 * hackagebot data-variant 0.28.0.1 - A variant data type, useful for modeling dynamically-typed programming languages  http://hackage.haskell.org/package/data-variant-0.28.0.1 (TobiasDammers)
08:14:50 <kqr> i bet someone else can get even more mathy about it
08:14:50 * hackagebot hpaco-lib 0.28.0.1 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.28.0.1 (TobiasDammers)
08:14:52 * hackagebot hpaco 0.28.0.1 - Modular template compiler  http://hackage.haskell.org/package/hpaco-0.28.0.1 (TobiasDammers)
08:14:54 <snickle> lambdabot is da bess <3
08:16:17 <beaky> i finally understand fucntional programing
08:16:44 <TheKing444> > repeat 1
08:16:45 <ReinH> beaky: Really? great! I'm still working on that after 5 years or so :)
08:16:46 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:16:46 <beaky> all it is about is writing mappings from domains to codomains
08:16:57 <snickle> the click part of haskell is a great feelings
08:17:05 <snickle> feeling*
08:17:13 <beaky> now if only i can figure out lenses and monads
08:17:21 <ReinH> The best part is that there are a lot of those.
08:19:16 <snickle> mannn i wanna be smart someday :)
08:19:49 * hackagebot dockercook 0.1.2.0 - A build tool for multiple docker image layers  http://hackage.haskell.org/package/dockercook-0.1.2.0 (AlexanderThiemann)
08:20:21 <kqr> snickle, practise1
08:21:04 <mbrock> beaky: also defining your domains and codomains, i.e., working with types :)
08:22:23 <beaky> right i still need to nail down defining domains and codomains
08:22:49 <TheKing444> use the types beaky
08:22:55 <TheKing444> :t thisIsAFunction
08:22:56 <lambdabot> Num a => a -> a
08:23:06 <TheKing444> :t (+4)
08:23:07 <lambdabot> Num a => a -> a
08:23:09 <TheKing444> :t show
08:23:10 <lambdabot> Show a => a -> String
08:23:14 <TheKing444> :t read
08:23:15 <lambdabot> Read a => String -> a
08:23:19 <TheKing444> :t compare
08:23:20 <lambdabot> Ord a => a -> a -> Ordering
08:23:33 <TheKing444> :t map
08:23:34 <lambdabot> (a -> b) -> [a] -> [b]
08:24:57 <TheOn> Which OpenGL hackage package do you recommend?
08:25:01 <mbrock> thinking about domains and codomains is nice, especially because Haskell encourages "total" functions, i.e., functions that properly handle all possible values in the domain
08:26:05 <TheKing444> mbrock, not really
08:26:07 <TheKing444> > head []
08:26:09 <lambdabot>  *Exception: Prelude.head: empty list
08:26:20 <eikke__> TheKing444: 'encourages', not 'enforces'
08:26:30 <TheKing444> That was a prelude function.
08:27:19 <mbrock> if you use head, you're mostly gonna have a bad time, which is admittedly an unfriendly way to encourage totality
08:27:47 <TheKing444> or tail, or init, or last, or fromJust, or fromRight
08:27:58 <kqr> TheKing444, tail is total?
08:28:03 <TheKing444> fromLeft, fix, etc
08:28:05 <kqr> oh never mind
08:28:07 <TheKing444> > tail []
08:28:09 <lambdabot>  *Exception: Prelude.tail: empty list
08:28:09 <kqr> i was thinking of drop 1
08:28:12 <TheKing444> apparently not
08:28:17 <mbrock> sure, there are lots of partial functions
08:28:22 <eikke__> why is fix not total?
08:28:24 <TheKing444> In the prelude.
08:28:27 <TheKing444> > fix id
08:28:32 <lambdabot>  mueval-core: Time limit exceeded
08:28:51 <TheKing444> A different kind of bottom, but still a _|_
08:28:58 <eikke__> right
08:29:07 <TheKing444> I wish haskell had fully dependent types.
08:29:20 <companion_cube> use Idris ;)
08:29:33 <TheKing444> I would think a cool experiment would be something fully haskell complient, but with a dependent types extension.
08:30:18 <kqr> didn't someone recently summarise ghc extensions as "seeing how close Haskell can get to dependent typing without breaking something"
08:30:33 <MP2E> kqr sounds about right to me :P
08:30:34 <TheKing444> XD
08:31:06 <eikke__> kqr: the Hasochism thing?
08:31:11 <TheKing444> Like seriously, couldn't they make one extension called "DepentTypes" and get rid of half of the others.
08:31:36 <kqr> TheKing444, i guess that breaks too much
08:31:37 <MP2E> Well they don't allow for full Dependent Types
08:31:40 <companion_cube> you'd probably need a proof language and type-level computations to do anything serious with it
08:31:42 <bounb> /cl/cl
08:31:42 <kqr> TheKing444, at that point you might very well use idris instead
08:31:56 <eikke__> kqr: laziness! libraries!
08:32:02 <TheKing444> exactly
08:32:13 <vanila> I think that you need strong normalization for dependent types to work
08:32:19 <MP2E> well sure, but implementing dependent types wholesale in GHC would break all of these libraries, anyway
08:32:22 <MP2E> you would have laziness I guess
08:32:24 <kqr> eikke__, add laziness and libraries to idris instead of breaking my haskell!
08:32:25 <vanila> so you can't really just add it to haskell, without ti being somewhat terrible and broken
08:32:30 <TheKing444> If you build in dependent types on top of haskell, the masses will have them.
08:33:17 <vanila> and anyway, aren't dependent types a million times too hard to do real programming with?
08:34:53 <companion_cube> why would you need lazyness in Idris ?
08:35:28 <companion_cube> if you deal with total functions, strictness is as composable, and more efficient
08:35:39 <beaky> is laziness bad
08:35:41 <companion_cube> (if you can have optional lazyness, that is)
08:37:35 <kqr> vanila, on one hand, people have said that haskell gives them the perfect mix of safe and loose reasoning wrt the type system
08:37:35 <Ankhers> beaky: It depends on what you are doing.
08:37:54 <kqr> vanila, on the other hand, a lot of people would readily say that the haskell type system is "a million times too hard to do real programming with"
08:38:11 <kqr> vanila, gather of that what you will
08:38:54 <Ankhers> > map (*2) $ take 5 [1..]
08:38:56 <lambdabot>  [2,4,6,8,10]
08:39:07 <Ankhers> That is only possible with laziness
08:39:11 <Ankhers> beaky: ^^
08:39:21 <companion_cube> it's possible in a strict language with lazy lists
08:39:34 <companion_cube> i.e., any derivative of ML, for instance
08:39:42 <Ankhers> still needs to be lazy.
08:39:53 <companion_cube> but the language would be strict
08:39:59 <companion_cube> I said "optional lazyness"
08:40:03 <gp5st> Ankhers: but that's not lazy function evaluation. That's just a generator ?
08:40:03 <companion_cube> strictness by default
08:40:22 <kqr> is there a function `[a -> a] -> a -> a' somewhere?
08:40:55 <glguy> ?type foldr (.) id
08:40:57 <lambdabot> [b -> b] -> b -> b
08:41:10 <Fuuzetsu> @hoogle [a -> a] -> a -> a
08:41:12 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
08:41:12 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
08:41:13 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
08:41:16 <Ankhers> I was just trying to answer beaky's question about lazy being bad.
08:41:29 <kqr> glguy, that's what i have currently, but i was wondering if there was an alias anywhere
08:41:54 <Fuuzetsu> :t mconcat [id]
08:41:55 <lambdabot> Monoid a => a -> a
08:42:23 <companion_cube> Ankhers: but I'm still not convinced that lazyness by default is better
08:42:27 <glguy> ?type ala Endo foldMap
08:42:28 <lambdabot> Foldable t => t (a -> a) -> Unwrapped (Endo a)
08:42:35 <glguy> kqr: There isn't as far as I know
08:42:48 <snickle> i like laziness by default because it lets you define something rather than describe behavior
08:42:48 <Fuuzetsu> what's wrong with mconcat here?
08:42:55 <TheKing444> :t ala
08:42:56 <glguy> > ala Endo foldMap [(*2), (+1), (*3)] 1
08:42:57 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
08:42:58 <lambdabot>  8
08:43:09 <glguy> Fuuzetsu: mconcat will only help if you wrap your functions in Endo
08:43:19 <Ankhers> companion_cube: I'm not saying the default is better one way or another. It really depends on what you are doing.
08:43:37 <Ankhers> If you are changing most of your values to strict, then you probably want a strict by default language.
08:43:43 <kludgy> TheKing44: ala? what's this?
08:43:54 <kludgy> TheKing444: <--rather
08:44:13 <TheKing444> I have no idea what ala is.
08:44:17 <TheKing444> Look at the type:
08:44:19 <TheKing444> :t ala
08:44:20 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
08:44:33 <glguy> ala is au but using type classes to find the Iso for you
08:44:34 <TheKing444> Ain't that weird?
08:44:35 <glguy> ?type au
08:44:36 <lambdabot> AnIso s t a b -> ((s -> a) -> e -> b) -> e -> t
08:44:40 <kludgy> TheKing444: lol.. where did you get the idea to type the name? :)
08:44:52 <moofy> Do any of you use sublimehaskell to write code in? I’m having a terrible trouble trying to get it / sublime text to work
08:45:13 <kludgy> moofy: I've used it a bit, but found it pretty unstable and slow.
08:45:20 <TheKing444> I usually have a name of TheKing, but that was taken so I did TheKing444.
08:45:34 <moofy> kludgy: it just errors on me trying to get it to run
08:45:50 <kludgy> moofy: What's the error?
08:46:37 <moofy> kludgy: I’m not even sure, it’s giving me some python errors that pasting in chat would be anti-social
08:46:59 <solidus-river> how would one use arrow syntax with timed wires in netwire
08:47:08 <kludgy> moofy: Can you codepad.org them (or whatever the equivalent is here)?
08:47:08 <solidus-river> all examples i see of using it uses pure wires not timed
08:47:13 <moofy> sure
08:47:14 <Fuuzetsu> @where lpaste
08:47:15 <lambdabot> http://lpaste.net/new/haskell
08:47:16 <solidus-river> or i'm misunderstanding the stepwire function
08:47:18 <kludgy> cheers
08:47:44 <moofy> http://codepad.org/XYKToc9C
08:47:47 <glguy> kludgy: he got the idea from the code I sent to lambdabot
08:48:25 <kludgy> glguy: aha
08:48:46 <TheKing444> iterate (\x->"f("++x++")") "x"
08:49:00 <TheKing444> > iterate (\x->"f("++x++")") "x"
08:49:02 <lambdabot>  ["x","f(x)","f(f(x))","f(f(f(x)))","f(f(f(f(x))))","f(f(f(f(f(x)))))","f(f(f...
08:49:04 <moofy> So i’m sort of scratching my head about what’s up there
08:50:25 <kludgy> moofy: google-fu: https://github.com/SublimeHaskell/SublimeHaskell/issues/95
08:50:46 <moofy> kludgy: yeah, I saw that too but it seems to have changed nothing
08:51:40 <kludgy> moofy: Unfortunately I've not encountered that one myself. :( Last time I installed sublimehaskell from scratch was a few months ago on ST3
08:52:05 <moofy> maybe i should just try out st3
08:52:09 <moofy> if it’s stable enough
08:52:51 <kludgy> moofy: It's been fine for me in win, although I don't use plugins heavily. Can't speak to other versions
08:52:57 <glguy> TheKing444: Check this out:
08:53:01 <glguy> > take 10 (iterate f x)
08:53:03 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
08:53:15 <TheKing444> :t f
08:53:16 <lambdabot> FromExpr a => a
08:53:20 <TheKing444> x
08:53:24 <TheKing444> > x
08:53:25 <lambdabot>  x
08:53:27 <TheKing444> > f
08:53:29 <lambdabot>  No instance for (GHC.Show.Show a0)
08:53:29 <lambdabot>    arising from a use of ‘M632297780837542086617955.show_M6322977808375420866...
08:53:29 <lambdabot>  The type variable ‘a0’ is ambiguous
08:53:29 <lambdabot>  Note: there are several potential instances:
08:53:29 <lambdabot>    instance [safe] GHC.Show.Show
08:53:33 <TheKing444> coo
08:53:34 <TheKing444> l
08:53:42 <TheKing444> I think I say that arcticle.
08:53:43 <kludgy> glguy: nice trick!
08:53:50 <TheKing444> So it did get into lambdabot then.
08:54:05 <kludgy> TheKing444: Can you link the article in question?
08:54:17 <moofy> kludgy: cool thanks, i’ll try it out
08:54:37 <TheKing444> package: https://hackage.haskell.org/package/simple-reflect-0.3.2
08:54:44 <kludgy> TheKing444: thank you
08:54:45 <TheKing444> blog post: http://twanvl.nl/blog/haskell/simple-reflection-of-expressions
08:56:00 <kludgy> moofy: Sorry I couldn't help more there.. good luck!
08:58:27 <WraithM> > (foldr f x [a,b,c,d], foldl f x [a,b,c,d])
08:58:29 <lambdabot>  (f a (f b (f c (f d x))),f (f (f (f x a) b) c) d)
08:58:47 <WraithM> Neat
08:58:58 <fread2282> yea
08:59:20 <fread2282> > [a,b,c,d] & traverse .~ e
08:59:21 <lambdabot>  [e,e,e,e]
08:59:28 <TheKing444> > mfix f
08:59:29 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
08:59:30 <lambdabot>    arising from a use of ‘M451983395538522335518082.show_M4519833955385223355...
08:59:30 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
08:59:30 <lambdabot>  Note: there are several potential instances:
08:59:30 <lambdabot>    instance [safe] GHC.Show.Show a =>
08:59:40 <fread2282> > :t [a,b,c,d] & traverse .~ e
08:59:42 <TheKing444> > mfix f :: [Int]
08:59:42 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:59:43 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr [GHC.Types.Int])
08:59:43 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
08:59:51 <fread2282> > :t [a,b,c,d]
08:59:52 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:59:55 <kludgy> TheKing444: heh.. I was thinking the same thing with fix
09:00:07 <TheKing444> > fix f :: Int
09:00:09 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr GHC.Types.Int)
09:00:09 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
09:00:15 <fread2282> :t ar
09:00:17 <lambdabot>     Not in scope: ‘ar’
09:00:17 <fread2282> :t a
09:00:17 <lambdabot>     Perhaps you meant one of these:
09:00:17 <lambdabot>       ‘a’ (imported from Debug.SimpleReflect),
09:00:18 <lambdabot> Expr
09:00:19 <TheKing444> > fix f :: Expr
09:00:21 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
09:00:25 <TheKing444> YEAH
09:00:27 <kludgy> Wow cool!
09:00:28 <WraithM> lolololoololo
09:00:32 <WraithM> That's awesome
09:00:35 <TheKing444> > mfix f :: [Expr]
09:00:36 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr
09:00:36 <lambdabot>                     [Debug.SimpleReflect.Expr.Expr])
09:00:37 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
09:00:40 <TheKing444> > fix f
09:00:42 <lambdabot>  No instance for (GHC.Show.Show a0)
09:00:42 <lambdabot>    arising from a use of ‘M234226659997708621418208.show_M2342266599977086214...
09:00:42 <lambdabot>  The type variable ‘a0’ is ambiguous
09:00:42 <lambdabot>  Note: there are several potential instances:
09:00:42 <lambdabot>    instance [safe] GHC.Show.Show
09:01:10 <fread2282> > mfix (f :: Expr)
09:01:12 <WraithM> > foldl (\x y -> "f (" ++ x ++ ") (" ++ y ++ ")") "z" ["a","b","c","d","e"]
09:01:13 <lambdabot>  Couldn't match expected type ‘a -> m a’
09:01:13 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
09:01:15 <lambdabot>  "f (f (f (f (f (z) (a)) (b)) (c)) (d)) (e)"
09:03:48 <solidus-river> bah, theres still something fundamental about netwire i'm not understanding
09:04:04 <solidus-river> someone here a netwirer?
09:04:16 <solidus-river> it doesnt seem like theres a way to use arrow syntax with wires that are dependent on a session
09:04:54 * hackagebot gsl-random 0.4.6 - Bindings the the GSL random number generation facilities.  http://hackage.haskell.org/package/gsl-random-0.4.6 (PatrickPerry)
09:04:56 * hackagebot monte-carlo 0.5 - A monad and transformer for Monte Carlo calculations.  http://hackage.haskell.org/package/monte-carlo-0.5 (PatrickPerry)
09:04:56 <solidus-river> because in order to step them you need to supply a session and use stepwire but arrow syntax expects solely an a
09:05:49 <jfeltz> for working on hackage targeted haskell projects, is it possible in theory/practice to do so without cabal? I.e. is it possible to install project dependencies, and create one's own project dependencies, without cabal? I don't know enough about ghc packages yet, but I'm curious as to whether or not this is viable
09:06:12 <jfeltz> gah, for working on NON-hackage targeted haskell projects
09:09:15 <jfeltz> it looks like I would have to custom roll my own ghc package descriptions, and that doesn't sound like fun, but otherwise it looks possible, is anyone doing this?
09:11:49 <mietek> Is it possible to declare a GADT-style operator constructor for a newtype, using another constructor underneath?
09:12:25 <kludgy> jfeltz: Nix is doing this, but if you're planning on distributing the package I don't know of any popular alternative to cabal. I know of devs who use makefiles instead of cabal for build management though.. particularly for haskell compilers other than ghc.
09:13:39 <egnim> hy guys, there was some website at some point that would display your diagrams code, or some other vis library ?
09:13:49 <egnim> what whas the name of that ?
09:14:57 <egnim> someting like lpast, but it would display your drawings
09:15:04 <egnim> *lpaste
09:15:15 <alpounet> egnim: yes there is one
09:15:23 <supki> egnim: http://paste.hskll.org/ ?
09:15:27 <alpounet> yes
09:15:34 <jfeltz> klodgy: ahh, I just discovered Shake, so I'm wondering why on earth am I strangling myself with cabal's dependency management/format, I was thinking about either making my own, or templatizing something that maps to a cabal config
09:15:41 <egnim> oh, that's it, thank you guys
09:15:56 <alpounet> egnim: it'si n the topic of the #diagrams channel btw, if you happen to forget about it again
09:15:57 <jfeltz> kludgy*
09:16:11 <Fuuzetsu> jfeltz: nix
09:16:23 <Fuuzetsu> I should get paid for this
09:16:24 <jfeltz> kludgy: this is just for internal projects, not intending on releasing any of this
09:16:29 <egnim> alpounet, i will surely forget that url, thank you for the info
09:16:40 <jfeltz> kludgy: thanks
09:19:43 <kludgy> jfeltz: np.. it is perfectly valid to integrate the compiler into an existing build process. With ghc tools at least the compiler options are all very well exposed through command line options.
09:19:55 <finlandssvensk> So Nothing is haskell's nil/null?
09:20:25 <koala_man> finlandssvensk: they're frequently used for the same thing, yes.
09:20:36 <finlandssvensk> Okay
09:21:05 <koala_man> they don't work the same way though
09:21:17 <allsystemsarego> finlandssvensk, but you'll never see a NothingPointerException
09:21:39 <Fuuzetsu> :t fromJust
09:21:40 <finlandssvensk> I hope not
09:21:40 <lambdabot> Maybe a -> a
09:22:10 <Fuuzetsu> allsystemsarego: I'm sure this could be arranged
09:22:23 <allsystemsarego> > fromJust Nothing
09:22:23 <kludgy> > fromJust (Nothing :: Maybe Int)
09:22:24 <lambdabot>  *Exception: Maybe.fromJust: Nothing
09:22:25 <lambdabot>  *Exception: Maybe.fromJust: Nothing
09:22:28 <allsystemsarego> hehe
09:22:37 <kludgy> jinx
09:23:11 <finlandssvensk> > fix error
09:23:12 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
09:23:18 <MP2E> :t maybe
09:23:19 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:23:20 <finlandssvensk> classic
09:23:32 <Adium_> ﻿Chris was laying on her bed, eyes closed, hungrily licking cum off his own cockhead. From the smears of jizz around his mouth, and his slightly protruding belly, Jen could guess that he had already swallowed one of his own massive loads. However, his thirty inch long dick was still rock hard, and his hands were massaging it sensually. Chris stretched to plant his mouth over his huge cockslit, and slurped greedily, sucking down even ...
09:23:37 <MP2E> rofl wtf
09:23:39 <Adium_> ... more sperm. “Mmmmm. So good.” He smiled dreamily, while continuing to stroke his shaft. He licked around the rim of his enormous, engorged cockhead. “Kimber. Tasha. So much bigger.” His strokes began to quicken again, and his hips bucked on the bed as another eruption of jizz seemed imminent. “So much bigger for me.” Not even registering Jen’s presence, Chris planted his mouth over the tip of his glans, and his cheeks ...
09:23:40 <Fuuzetsu> ?ops
09:23:40 <lambdabot> Maybe you meant: pl oeis docs
09:23:43 <Fuuzetsu> @where ops
09:23:43 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
09:23:45 <Adium_> ... bulged hugely as a gigantic load of semen erupted from his dick into his mouth. Chris gulped and gulped as pulse after pulse of thick spunk blasted down his throat. After quite a while, Chris finally released his lip-lock on his own dick and gasped for air. “Whew!” He licked the thick rivulets of cum from his lips and smiled. “So much bigger…”. His normallly flat tummy was now bulging with two huge loads of jizz, but this ...
09:23:51 <Adium_> ... didn’t seem to satisfy him at all. Chris, never opening his eyes, resumed slurping on his gargantuan wang as his hands began stroking his massive meat once again. “More…want more…”
09:23:52 --- mode: ChanServ set +o dcoutts
09:23:53 * MP2E clears
09:23:54 --- mode: ChanServ set +o geekosaur
09:23:55 <Adium_> Jen shut the door and quickly turned away. She quickly blinked her eyes and exhaled softly. They haven’t even gotten any bigger and he’s already fantasizing about them? I’m already not big enough? Jen exhaled forcefully. Snap out of it, girl. It’s Chris. He’s probably fantasizing about every girl he’s ever seen, at once. He’s so horny he’d probably fantasize about the pizza if he looked at it for too long. She smiled ...
09:23:56 <kludgy> finlandssvensk: lol. Looks like error can't be fixed :)
09:23:58 --- mode: geekosaur set +b *!*irc@*.dsl.static.sonic.net
09:23:58 --- kick: Adium_ was kicked by geekosaur (Adium_)
09:24:08 --- mode: geekosaur set -o geekosaur
09:24:08 <finlandssvensk> kludgy: fix show
09:24:11 --- mode: ChanServ set -o dcoutts
09:24:17 <finlandssvensk> it's kind of insane
09:24:19 <TheKing444> > fix show
09:24:20 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
09:24:34 <TheKing444> > fix read
09:24:37 <bernalex> geekosaur: aww now we'll never know how it ends
09:24:38 <lambdabot>  mueval-core: Time limit exceeded
09:24:53 <geekosaur> sure you'll find it in another channel :p
09:24:56 <Fuuzetsu> we should really add a @ops
09:25:59 <geekosaur> when I was running a lambdabot, I kept thinking about a mode where unknown commands woulld be checked against @where (well, @fact but that seems to have been deprecated)
09:26:18 <WraithM> How many possible total functions are there from a type with n-inhabitants to a type of m-inhabitants? m^n?
09:26:29 <MP2E> yes, exactly
09:26:36 <kludgy> TheKing444: with fix show are the escape characters themselves being escaped as it evaluates?
09:26:45 <finlandssvensk> kludgy: yes
09:26:46 <TheKing444> exactly
09:26:56 <kludgy> mind blown
09:27:12 <TheKing444> it works because show is lazy
09:27:18 <TheKing444> > show undefined :: STring
09:27:20 <lambdabot>  Not in scope: type constructor or class ‘STring’
09:27:20 <lambdabot>  Perhaps you meant ‘String’ (imported from Prelude)
09:27:24 <haasn> extra points: define a function to give the number of \s in the nth chain, as separate by " characters
09:27:31 <TheKing444> > show undefined :: String
09:27:33 <lambdabot>  "*Exception: Prelude.undefined
09:27:53 <Fuuzetsu> > fix . fix $ error ""
09:27:55 <lambdabot>  *Exception:
09:28:04 <Fuuzetsu> I don't know what I expected.
09:28:19 <kludgy> TheKing444: I understand the recurrence, but not why the escape characters are being propagated. I guess it's sanitizing the output for read..?
09:28:50 <TheKing444> show "\\"
09:28:57 <Fuuzetsu> > "\\"
09:28:57 <TheKing444> > show "\\"
09:28:58 <kludgy> > show "\\"
09:28:59 <lambdabot>  "\\"
09:28:59 <lambdabot>  "\"\\\\\""
09:29:00 <lambdabot>  can't find file: L.hs
09:29:16 <Fuuzetsu> hue
09:29:39 <haasn> > map length . filter ("\\" `isPrefixOf`) . group $ fix show
09:29:41 <Cale> It's kind of sad that lambdabot bug exists
09:29:44 <lambdabot>  mueval: ExitFailure 1
09:29:48 <haasn> > take 10 . map length . filter ("\\" `isPrefixOf`) . group $ fix show
09:29:50 <lambdabot>  [1,3,7,15,31,63,127,255,511,1023]
09:29:54 <kludgy> Cle: Race condition dealing with multiple requests?
09:30:09 <kludgy> Cale: rather
09:30:11 <haasn> lambdabot has many sad things
09:30:25 <haasn> But so far nobody has offered or managed to fix them
09:30:34 <Cale> kludgy: yeah
09:31:00 <oakwhiz> This is a pretty interesting contest: https://github.com/pdtournament/pdtournament
09:31:00 <kludgy> haasn: How does one contribute to lambdabot?
09:31:25 <haasn> kludgy: http://www.haskell.org/haskellwiki/Lambdabot#Contributing probably
09:31:40 <kludgy> haasn: tx
09:32:39 <geekosaur> @version
09:32:39 <lambdabot> lambdabot 5.0-int-e
09:32:39 <lambdabot> git clone git://github.com/int-e/lambdabot.git
09:32:48 <geekosaur> presunably pull requests...
09:32:57 <mietek> Is it possible to use (=>)?
09:32:57 <haasn> https://github.com/mokus0/lambdabot is the one listed on the lambdabot hackage
09:33:07 <haasn> mietek: (=>) is a syntax error
09:33:35 <mietek> It's used to indicate instance contexts, so not quite
09:33:41 <haasn> But not with the () surrounding it
09:34:00 <haasn> Or: that's =>, not (=>)
09:34:08 <mietek> Yes.  I mean -- is it possible to use (=>) as an operator in the code world, not the type world
09:34:11 <mietek> ?
09:34:44 <mietek> Perhaps some LANGUAGE pragma I don't know.
09:35:03 <haasn> No such pragma exists to my knowledge
09:35:16 <finlandssvensk> So wait
09:35:31 <Fuuzetsu> :k (=>)
09:35:33 <lambdabot> parse error on input ‘=>’
09:35:36 <Fuuzetsu> boo
09:35:41 <Fuuzetsu> http://ghc.haskell.org/trac/ghc/ticket/9115
09:35:49 <finlandssvensk> can you really overload something like '>' just by doing (>) x = .... ?
09:36:01 <Fuuzetsu> not overload, shadow
09:36:02 <haasn> finlandssvensk: That will redefine (shadow) it
09:36:02 <geekosaur> "no"
09:36:06 <mietek> Right, it is still a reservedop in Haskell2010
09:36:17 <mietek> Fuuzetsu: bummer
09:36:28 <finlandssvensk> okay
09:36:36 <haasn> Unless you're defining it in the same scope as (>), in which case it will just cause an ambiguity error unless you explicitly qualify usages
09:36:38 <geekosaur> haskell doesn't do overloading in the sense you are thinking of. it does have typeclasses, which give you a more principled (theoretically at least) mechanism
09:37:06 <Fuuzetsu> mietek: on the upside we all know about => so there's no wondering whether comparisons use >= or =>
09:37:10 <haasn> finlandssvensk: However, you can overload > for a particular type by defining your own Ord instance (which includes >)
09:37:13 <geekosaur> in this case, (>) is part of Ord and you can define an Ord instance
09:37:15 <geekosaur> heh
09:37:20 <monochrom> type classes lead to more tractable error messages
09:37:23 <Fuuzetsu> @quote echo
09:37:23 <lambdabot> No quotes match. You speak an infinite deal of nothing.
09:37:25 <Fuuzetsu> pfft
09:37:53 <haasn> the type class mechanism also provides a meaningful distinction between orphan and non-orphan instances
09:37:54 <geekosaur> @quote -part
09:37:54 <lambdabot> No quotes match. The more you drive -- the dumber you get.
09:38:04 <geekosaur> @quote antiphony
09:38:05 <lambdabot> No quotes match. My mind is going. I can feel it.
09:38:07 <geekosaur> bah
09:38:18 <haasn> The latter of which can change behavior in unexpected ways
09:38:24 <haasn> former*
09:38:25 <mietek> Fuuzetsu: yeah, always tripped me up in Erlang
09:38:49 <finlandssvensk> haasn: *car
09:38:54 <haasn> Fuuzetsu: Fortunately, in prolog, it's >= and =<, both of which are legal in Haskell >:(
09:39:12 <Fuuzetsu> the simple solution is to not use Prolog
09:39:18 <monochrom> :)
09:39:19 <mietek> Right, Prolog and Erlang.
09:39:41 <mietek> haasn: >=, bah!
09:39:47 * haasn wrote an exam on haskell *and* prolog today
09:39:53 <josephle> the MLs reserve => as well, iirc
09:40:08 <Fuuzetsu> it's beginning of August, why did you write an exam?
09:40:09 <mietek> Actually I think it was =< which I always got wrong.
09:40:50 <monochrom> Microsft Certified Functional Programmer exam :)
09:41:04 <Fuuzetsu> is Microsft a new company ;)
09:41:20 <monochrom> that was a type error
09:41:25 <mietek> Fuuzetsu: fortunately, with Haskell, you can just use the type system, and pretend it's Prolog!
09:41:34 <Fuuzetsu> typorror
09:41:36 <haasn> must be using lisp
09:41:54 <finlandssvensk> (you (wouldn't 'say))
09:42:04 <finlandssvensk> fortunately in haskell, that becomes
09:42:11 <Fuuzetsu> mietek: I prefer to not pretend anything is Prolog
09:42:13 <finlandssvensk> you $ wouldn't $ say
09:42:14 <Fuuzetsu> even Prolog
09:42:20 <companion_cube> mietek: the typed equivalent of prolog would be mercury, not haskell
09:42:23 <Cale> you . wouldn't $ say
09:42:25 <Fuuzetsu> finlandssvensk: you . wouldn't $ say
09:42:35 <adimit> it wouldn't be Prolog without liberal use of cuts *everywhere*. So Haskell's type system is nothing like Prolog.
09:42:56 <monochrom> (not (would you say))
09:43:18 <monochrom> no, actually, ((not (would say)) you)
09:43:19 <Fuuzetsu> ‘Prolog is great, it can find many solutions’; ‘Put cuts everywhere to only get the solution you actually want!’
09:43:20 <haasn> https://github.com/int-e/lambdabot/blob/master/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Eval.hs#L84 what a horrible function
09:43:56 <haasn> Why is that not just case (munge out, munge err) of ([],[]) -> ...; ([],e) -> ...; (o,_) -> ...
09:44:19 <adimit> monochrom: it's (you (not (would say)))
09:44:29 <mietek> adimit: cuts are merely an optimisation
09:45:07 <mietek> companion_cube: I did mean programming _in_ the type system
09:45:10 <adimit> mietek: nuh uh. They're not. They change the result set.
09:45:11 <kludgy> Question: If I wanted to build a program to do exploration (as unguided as possible) of a custom service through REST queries (there are dependencies involved, as the exploration needs to adapt to results), what approaches/packages would folks recommend?
09:45:21 <kludgy> * addendum - emphasis on exposing regressions and pathological performance behavior under load
09:45:37 <josephle> haasn: because you're not really pattern matching on munge out or munge err, but rather predicates on those values?
09:46:03 <haasn> @@josephle @src null
09:46:04 <adimit> seq and par are much closer to being an "optimization" of sorts; at least they only change the result in edge cases.
09:46:10 <haasn> bah
09:46:12 <haasn> @src null
09:46:12 <lambdabot> null []     = True
09:46:13 <lambdabot> null (_:_)  = False
09:46:14 <sm> why does ghc -package-db .cabal-sandbox/i386-linux-ghc-7.8.2-packages.conf.d/ ... complain about missing files in all the packages ? (and ghci doesn't ?)
09:46:17 <companion_cube> mietek: well haskell's type system isn't as powerful as prolog
09:46:25 <mietek> adimit: you're right, I didn't mean a transparent optimisation
09:46:37 <mietek> companion_cube: in terms of Turing completeness?
09:46:47 <companion_cube> I think so
09:46:50 <josephle> haasn: that's true, we may never know the real reason for this coding style
09:46:55 <companion_cube> unless you enable really weird extensions...
09:47:04 <mietek> companion_cube: that's exactly what you do
09:47:11 <companion_cube> also in terms of actual expressiveness
09:47:20 <Fuuzetsu> I love non-terminating type-checkers
09:47:32 <mietek> companion_cube: sure, I am being slightly facetious, but note Oleg
09:47:54 <josephle> Fuuzetsu: how do you feel about undecidable type-systems?
09:48:04 <Fuuzetsu> I haven't decided yet
09:48:09 <ij> I'm looking at CPS article in wikibooks. It somehow feels that haskell is already using continuations just because of lazy evaluation. Are there any similarities between the two or have I got it completely wrong.
09:48:13 <ij> s/.$/?
09:48:14 <josephle> heh
09:48:45 <meretrix> Is there any way to start an IO function in the current thread, but after a few seconds fork it?  (I want to be able to see whether any exceptions were thrown at startup)
09:48:47 <vanila> ij, continuations are in the background in every programming language - it's not related ot lazy evaluation
09:48:55 <kludgy> companion_cube: I think the patchwork design can be accounted for by the fact that Haskell is a pioneer for purely functional, typed, lazy languages. (are there others?)  Definitely not an end point.
09:49:23 <adimit> mietek: my point is, they make stuff difficult to reason about, but at the same time, they're very, very necessary in Prolog. And don't even get me started on assert/1 asserta/1 assertz/1, and retract/1. *shudder*
09:50:30 <dfeuer> Hahahaha. mietek wrote "but note Oleg".
09:51:12 <dfeuer> Is there any way to deal with warnings that a rule may never fire because ':' might inline first?
09:51:36 <pseudolio> : is a construtor.
09:52:05 <dfeuer> So it never inlines, right, pseudolio?
09:55:19 <Fuuzetsu> are there any BitTorrent trackers written in Haskell?
09:55:34 <Fuuzetsu> I want to write a client but I need something to test against…
09:55:49 <adimit> Fuuzetsu: none to my knowledge. But I wanted to write one for the longest time.
09:56:18 <Fuuzetsu> Are you going to do it within the next couple of days or will I have to?
09:56:19 <adimit> Fuuzetsu: oh wait. HaskellTorrent ← it seems there is one.
09:56:51 <adimit> There is also Combinatorrent. (both on hackage)
09:56:51 <Fuuzetsu> that's a client
09:56:55 <Fuuzetsu> that's also a client
09:57:11 <adimit> you were asking for trackers.
09:57:12 <adimit> derp.
09:57:18 <sivteck> .
09:57:20 <adimit> sorry. probably not.
09:57:24 <zmbmartin> So I am having troubles wrapping my head around this. I want to check each item in tables to see if it is in justTables if it is apply a func otherwise return Nothing
09:57:24 <haasn> I found the L.hs bug
09:57:24 <zmbmartin> https://gist.github.com/codedmart/c35b77c281b2ab398555
09:57:26 <haasn> https://github.com/gwern/mueval/blob/master/Mueval/Interpreter.hs#L96
09:57:28 <Fuuzetsu> yes; those both clients are abandoned anyway and rather old
09:57:37 <haasn> This just copies the file to interpret into /tmp/filename
09:57:38 <zmbmartin> Anyone that can point me in the write direction?
09:57:40 <haasn> Instead of making a new random file
09:57:47 <haasn> With a guaranteed-fresh name
09:57:53 <haasn> And then they collide because it's removed again after execution
09:58:09 <adimit> Fuuzetsu: very interesting though. I'm pretty sure, given the results of, say wai, that Haskell a well-writenn Haskell tracker might even outperform the likes of Ozelot.
09:58:59 <Fuuzetsu> adimit: well, I'll probably write one in the following days but I'm not exactly going to be aiming for top performance
09:59:15 <thoughtpolice> Fuuzetsu: I don't know of any trackers I'm afraid. (although if you want to write a client, I'd suggest looking at improving the 'bittorrent' client library, which is new, but maintained and seems to be progressing rather steadily to focus your efforts)
09:59:50 <thoughtpolice> (the development version on GitHub is far, far more complete than the very rudimentary version on Hackage.)
09:59:56 <danilo2> Hello! Could anybody please explain to me why this 10-line code does not compile? Why GHC things the types are ambigous here? http://lpaste.net/108500 I would be very thankful for any help here!
10:00:05 <danilo2> *thinks
10:00:07 <Fuuzetsu> thoughtpolice: interesting
10:00:18 <Fuuzetsu> perhaps some of my work is done already which is nice
10:00:54 <thoughtpolice> Fuuzetsu: https://github.com/cobit/bittorrent <- it still has a ways to go, but has seen active development, and is probably more recent and easier to get going with.
10:01:19 <Fuuzetsu> I'm looking at that now; is the IRC client mentioned dead, I see noone there
10:02:01 <vanila> danilo2, not sure but what about pipe :: m a -> b -> c, if a will always be a monad?
10:02:51 <danilo2> vanila: It will not always be a monad - I just want to understand why GHC fails here. What are the rules it rejects the code.
10:03:07 <adimit> pipe :: m a -> b -> c doesn't really strike me as a reasonable type signature…
10:03:18 <glguy> danilo2: You don't use 'm' in your type
10:03:29 <glguy> danilo2: so there's no way to disambiguation which 'm' you meant
10:03:42 <vanila> doesn't the return make use of m?
10:03:52 <vanila> I think it's because m isn't instantiated, if you try Maybe instead of m does it work?
10:04:00 <monochrom> glguy is referring to "a -> out"
10:04:02 <glguy> No, it's also polymorphic in the 'm', so it doesn't help
10:05:02 * hackagebot data-variant 0.28.0.2 - A variant data type, useful for modeling dynamically-typed programming languages  http://hackage.haskell.org/package/data-variant-0.28.0.2 (TobiasDammers)
10:05:04 * hackagebot hpaco-lib 0.28.0.2 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.28.0.2 (TobiasDammers)
10:05:05 <glguy> disambiguate*
10:05:06 * hackagebot hpaco 0.28.0.2 - Modular template compiler  http://hackage.haskell.org/package/hpaco-0.28.0.2 (TobiasDammers)
10:05:19 <danilo2> glguy: But what if pipe could resolve it? I mean - I provide the first argument to pipe and I'm able to use pipe with "return 0" as the first argument if the second is provided as well. So pipe instances could use such polymorphic type, Is there any way to curry the function in such way?
10:06:10 <glguy> danilo2: GHC needs to know which instance to pick, but it won't guess
10:06:24 <glguy> without specifying which 'm' you meant it won't be able to pick an instance
10:06:35 <danilo2> glguy: But cannot it choose the instance based on the usage of the function?
10:06:50 <haasn> I've reported the L.hs bug to mueval, let's see if we can get it fixed
10:06:58 <glguy> right, it can't pick based on the uses in your definition because your definition doesn't specify  an 'm'
10:07:03 <glguy> ?type return
10:07:05 <lambdabot> Monad m => a -> m a
10:07:26 <glguy> If you fixed 'return' to a particular 'm' you'd be OK (and you'd have to change the type signature on testme
10:07:58 <frerich_> Does anybody know of some active Haskell projects to contribute to, something which is actively developed and hosted e.g. on github?
10:08:18 <kqr> zmbmartin, the problem as you have stated it makes little sense
10:08:19 <merijn> frerich: Plenty, pandoc?
10:08:38 <monochrom> since you have ScopedTypeVariables, testme :: forall m a out. (Monad m, Pipe (m Int) a out) => a -> out; testme a = pipe (return 0 :: m Int) a
10:08:42 <silasm> frerich: Idris is active, if that counts.
10:08:42 <kqr> zmbmartin, could you elaborate on what your input data is and what you want the return value to be?
10:08:52 <dfeuer> Is there a package/module providing named numbers? Just a bunch of zeroI=0::Int, oneI=1::Int, etc., to make Core involving them a little less unreadable?
10:08:58 <monochrom> well, maybe that doesn't make a difference
10:09:04 <silasm> (the compiler is written in Haskell)
10:09:20 <merijn> silasm: By that logic: GHC :p
10:09:40 <glguy> monochrom: I'd guess that would (at best) lead to a new type error at the use-site
10:09:47 <dfeuer> [because otherwise the numbers will be given names by the compiler, and they will not be names that suggest that they are numbers]
10:09:56 <kqr> dfeuer, sounds like a good exercise for learning TH, but I don't know of one, unfortunately
10:10:10 <monochrom> hmm, where is your MultiParamTypeClasses? :)
10:10:22 <MP2E> GHC is a nice codebase :) it's one of the few production compilers I feel like I can jump into and modify without breaking everything to all hell
10:10:33 <felixn> frerich: frerich2: help with core on making cabal sandboxes better!  http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
10:10:36 <dfeuer> kqr, there are many things I need to learn, and TH is on the list somewhere, but I think there are other things that I need to learn first.
10:11:00 <monochrom> and FlexibleContext?
10:11:27 <glguy> It seems like LANGUAGE FunctionalDependencies is dragging on all sorts of extensions for you
10:11:54 <Trollinator> MP2E: try that with the scala compiler
10:12:10 <monochrom> "FunctionalDependencies has a lot of dependencies" :)
10:12:14 <danilo2> monochrom: Hmm your code does not compile either. I do not know why I do not need FlexibleContext nor the second one - the code compiles . Maybe GHC 7.8 has some linked flags ?
10:12:23 <silasm> MP2E: really? For some reason I always just assumed it'd be complex implementation / simple interface. I really need to look at source code more often without being forced to.
10:12:40 <merijn> silasm: Well, the fact that it's written in haskell helps
10:12:52 <danilo2> monochrom: exactly - fundeps are putting these two there. Anyway, your code does nto compile either
10:13:08 <merijn> silasm: After my recent attempts at diving into big haskell code bases (pandoc and GHC) I could reasonably find my bearings using the types
10:13:12 <silasm> merijn: not when you're compiling it from source :S. It took like 12 hours on one of my computers XD
10:13:31 <monochrom> we're basically looking at: i :: (Show x, Read x) => String -> String; i cs = show (read cs)
10:13:33 <glguy> http://lpaste.net/108500
10:13:37 <merijn> silasm: When a few weeks later I started looking into some medium sized python projects, I had no clue what was going on
10:13:40 <glguy> re: the ambigous types
10:13:46 <merijn> silasm: No types to help you anywhere...
10:13:54 <MP2E> unitype madness
10:14:05 <danilo2> glguy: You explained it to me, thank you - a good explanation is "right, it can't pick based on the uses in your definition because your definition doesn't specify  an 'm'" - hmm, this is really interesting, thank you :)
10:15:05 <Trollinator> merijn: i actually applied for a python job a few weeks ago. They didn't take me, I'm not sure if I should be happy or sad.
10:15:09 <glguy> danilo2: if you really want that function, you can always add a proxy argument for 'm'
10:15:30 <danilo2> glguy: hmm, what do you mean by a proxy argument for m ?
10:15:31 <josephle> Trollinator: doesn't the Scala compiler use some sort of "Cake design pattern" so it can be "modular"?
10:16:31 <glguy> danilo2: http://lpaste.net/108500
10:16:46 <Trollinator> josephle: I haven't actually looked at it. Paul Phillip's talks were enough to scare me off.
10:16:48 <silasm> josephle: aren't monad transformers like cakes?
10:17:01 <zmbmartin> kqr: I want to loop through a list of strings (list = ["a", "b", "c"]) check to see if each of those elements is in another list (listTwo = ["a", "b"]) if the elem does exist do Nothing else call a func.
10:17:03 <Trollinator> it's said to be insanely complex and fragile.
10:17:14 <Trollinator> what I can tell is that it's bloody slow
10:17:21 <danilo2> glguy: ahhh, of course - you're just putting m to the signature, so it could be deduced later :)
10:17:31 <zmbmartin> kqr: Does that make more sense?
10:17:49 <josephle> silasm: you can sure layer them like cakes :)
10:18:01 <Mkster> >let f (x+1) = x
10:18:04 <MP2E> mm CakeT
10:18:08 <Mkster> Why is this not working?
10:18:08 <silasm> josephle: delicious burrito cakes
10:18:12 <MP2E> rofl
10:18:59 <pavonia> > let f (x+1) = x in f 3  -- Mkster
10:19:01 <lambdabot>  <hint>:1:8: Parse error in pattern: x + 1
10:19:16 <pavonia> Needs an extension
10:19:30 <MP2E> > let f x = (x+1) in f 3
10:19:32 <lambdabot>  4
10:19:55 <kqr> zmbmartin, a lot more! i'll show you
10:20:07 <Mkster> But can't I do that with the arguments?
10:20:29 <MP2E> Well if you think about it, it doesn't really make sense. The left side is strictly for pattern matching
10:20:37 <MP2E> so what are you saying? match (x+1)?
10:20:45 <Trollinator> zmbmartin: map fun $ filter (`elem` listTwo) list
10:20:45 <MP2E> should that return the parameter minus 1?
10:20:51 <Mkster> Yes
10:21:05 <Mkster> I think I saw that before
10:21:19 <Mkster> maybe with succ or soemthing?
10:22:11 <pavonia> Mkster: This syntax is discouraged in modern Haskell versions, but there should be an extenstion to enable it (I don't know its name, though)
10:22:14 <MP2E> Mkster: it's an N + K pattern I believe
10:22:26 <Cale> Yeah, this used to be standard
10:22:40 <Cale> but it's been moved to an extension and somewhat deprecated
10:22:51 <Mkster> Ok thanks
10:23:24 <pavonia> Err yes, *deprecated :)
10:23:29 <Cale> I think at some point there was an implementation with c*n + k patterns as well :)
10:23:34 <kqr> zmbmartin, or now that i think about it
10:23:54 <kqr> zmbmartin, never mind i was reading it wrong
10:24:21 <Cale> For those cases where your recursion breaks down into cases based on what the argument is modulo 16 or something :D
10:26:14 <dfeuer> Ugh.
10:26:37 <kqr> zmbmartin, the most obvious solution is "map (\x -> if x `elem` listTwo then x else f x) list"
10:27:28 <dwcook> You could throw Left and Right in there if you need to distinguish cases: map (\x -> if x `elem` listTwo then Left x else Right (f x)) list
10:27:35 <zmbmartin> kqr: Thanks
10:27:43 <zmbmartin> Trollinator: Thanks
10:29:41 <TheKing444> When I run "cabal install hat -v" I get an ExitFailure 1. What can I do to fix it?
10:31:50 <pavonia> TheKing444: Paste the cabal output please
10:31:52 <pavonia> ,lpaste
10:31:56 <pavonia> @lpaste
10:31:57 <lambdabot> Haskell pastebin: http://lpaste.net/
10:32:33 <Fuuzetsu> silasm: I think I have some monads in the oven right now ;)
10:33:38 <solidus-river> jle`: i have a question for ya about the s type in netwire and how it gets passed around during composition
10:34:00 <solidus-river> jle`: if you've got the time :) I think your the best bet at an answer
10:34:53 <solidus-river> jle`: i guess i could probably see by looking at the kleisli arrow definition for Wire
10:38:24 <Trollinator> zmbmartin: the way you phrased the question makes me think that you want to cause side effects in the function call: forM_ list $ \x -> when (elem x listTwo) (fun x)
10:38:37 <Trollinator> where you need to import Control.Monad(when, forM_)
10:39:40 <Trollinator> loops are ugly in Haskell…
10:39:53 <TheKing444> not that ugly
10:40:01 <TheKing444> :t forM
10:40:03 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
10:40:10 <Trollinator> forM_, not forM
10:40:22 <TheKing444> > forM_ [1..10] print
10:40:24 <lambdabot>  <IO ()>
10:40:37 <TheKing444> That is actually smaller than equivalent python code I bet.
10:40:45 <TheKing444> since you don't got variables
10:41:23 <TheKing444> you know what lambda bot needs
10:41:27 <TheKing444> limited IO support
10:41:40 <TheKing444> like print. How can we break lambdabot with print!
10:41:51 <Trollinator> sure. But all that _ $ \ -> stuff isn't nice. It's a purely aesthetic thing.
10:42:10 <TheKing444> It is just assigning a variable for the loop.
10:42:14 <haasn> > unlines $ map show [1..10]
10:42:16 <lambdabot>  "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n"
10:42:22 <TheKing444> And if you can do pointfree, it can be avoided entirely
10:42:38 <TheKing444> > forM_ [1..10] $
10:42:39 <lambdabot>  <hint>:1:16:
10:42:40 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:42:51 <TheKing444> > forM_ [1..10] $ \x -> print x
10:42:52 <lambdabot>  <IO ()>
10:42:56 <TheKing444> if you prefer
10:43:05 <Trollinator> but pointfree isn't always reasonably possible.
10:43:14 <TheKing444> @pl \x -> print x
10:43:15 <lambdabot> print
10:43:25 <TheKing444> @pl \x -> print x >> print x
10:43:25 <lambdabot> liftM2 (>>) print print
10:43:55 <Trollinator> you need some funny combinators in order to be able to use the loop variable twice.
10:44:28 <Trollinator> and I don't think they make the code more maintainable.
10:44:29 <TheKing444> @pl \x -> replicateM x (print x)
10:44:29 <lambdabot> ap replicateM print
10:44:52 <haasn> pointfree is always *possible*
10:44:57 <haasn> It's just rarely reasonable
10:45:09 <Trollinator> haasn: no.
10:45:13 <TheKing444> well forM_ [1..10] $ \x -> stuff x is lighter than a for loop in C++ or python, thats for sure
10:45:31 <haasn> Oh, I missed the word “reasonably” in your original statement
10:45:41 <haasn> Then I am not contradicting you, rather agreeing with you. I don't understand the reply “no.”
10:45:41 <Trollinator> you can't extract stuff from a datatype without writing a pointful function.
10:46:09 <TheKing444> @pl \(x:xs) -> xs
10:46:10 <lambdabot> tail
10:46:18 <TheKing444> OOOOOOHHHHHHHH
10:46:30 <thebnq> @src tail
10:46:30 <lambdabot> tail (_:xs) = xs
10:46:30 <lambdabot> tail []     = undefined
10:46:39 <Trollinator> data Foo = Foo Int. Write a point-free function that gives me the Int given a Foo
10:46:47 <haasn> I guess so; you can always modify the data-type to use field names to extract though
10:46:59 <TheKing444> unSafeCoerce
10:47:01 <allsystemsarego> @pl f (Foo i) = i
10:47:01 <lambdabot> (line 1, column 12):
10:47:02 <lambdabot> unexpected " "
10:47:02 <lambdabot> expecting operator
10:47:04 <haasn> I guess my “possible” was really based on “you can express any sort of program logic point-free”
10:47:05 <TheKing444> OOOOOOOOOHHHH
10:47:16 <TheKing444> @pl \(Foo i) -> i
10:47:16 <lambdabot> (line 1, column 7):
10:47:17 <lambdabot> unexpected "i"
10:47:17 <lambdabot> expecting operator or ")"
10:47:17 <allsystemsarego> @pl "f (Foo i) = i"
10:47:18 <lambdabot> "f (Foo i) = i"
10:47:25 <haasn> But my implied proof is based on the lambda calculus, which doesn't have data types
10:47:31 <merijn> Trollinator: Eh, yes you can, if you modify the datatype
10:47:34 <TheKing444> unSafeCoerce can do anything
10:47:42 <TheKing444> or generics
10:47:44 <merijn> Trollinator: "data Foo = Foo { getFoo :: Int }"
10:47:49 <TheKing444> GENERICS CAN DO ANYTHING
10:47:55 <cdosborn> I need to look through a file, that "expands" certain parts based on a simple syntax
10:47:57 <amar> how many times in real world we need to create monad?
10:47:57 <amar> amarp'
10:47:57 <amar> Is there any sign/pattern where I can sense creating a monad?
10:48:18 <Trollinator> I think we're in violent agreement.
10:48:30 <TheKing444> amar, whenever you are in something that is pure, but you want extra features
10:48:31 <cdosborn> here is a paste, that describes my problem, I would appreciate some help with file processing
10:48:35 <cdosborn> http://lpaste.net/108505
10:48:55 <TheKing444> amar, think "it would be cool if I could do this in do-notation"
10:48:56 <moghedrin> amar: 7 times. After that, it's optional.
10:49:05 <josephle> TheKing444, but even then you should resort to Functor or Applicative first
10:49:11 <TheKing444> For good examples, look at the monad transformers.
10:49:22 <vlatkoB> Can "traverse" be used instead of "mapM" in every case?
10:49:28 <TheKing444> josephle, yeah, but then they are less features and more containers
10:49:51 <haasn> vlatkoB: Theoretically yes; in GHC 7.10 yes; right now - not always
10:50:00 <Trollinator> luckily, we'll probably get Applicative do notation soon :-)
10:50:07 <haasn> vlatkoB: Monad doesn't imply Applicative
10:50:18 <josephle> not yet, at least
10:50:23 <Trollinator> it will soon.
10:50:53 <Trollinator> I really like Idris' syntax for Monads and Applicatives.
10:50:55 <TheKing444> amar, Look at https://hackage.haskell.org/package/mtl. If these things can solve your problems, you can use monads (them in fact.)
10:51:06 <TheKing444> :t traverse
10:51:08 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:51:08 <vlatkoB> haasn, I know, but when Applicative becomes super for Monad, than yes? mapM would be a specific case for traverse?
10:51:22 <MP2E> yes
10:51:33 <TheKing444> Unless someone breaks the Monad-Applicative laws
10:51:46 <TheKing444> Some people make Applicative concurrent in some way, and Monad sequential
10:52:03 <TheKing444> (traverse would be more efficient then)
10:52:12 <TheKing444> (also you would need to call the Haskell police)
10:52:41 <Trollinator> In Idris, you can write [| f x |] instead of f <*> x, and you can do f !x instead of do { x' <- x; f x' }
10:52:44 <MP2E> Oh I didn't think about Applicative being concurrent breaking the Applicative-Monad laws. Food for thought :V
10:53:00 <Trollinator> it's really rather neat :-)
10:53:09 <TheKing444> Unless the concurrency is encoded in the data-type.
10:53:10 <kludgy> Trollinator: That's really pleasant
10:53:30 <TheKing444> And bottoms edge-cases break it.
10:53:45 <johnw> yeah, the f !x stuff is pretty awesome
10:53:49 <Guest8434> thank you guys
10:53:49 <haasn> vlatkoB: Well, in the general case, moving to a more-polymorphic equivalent version of a function *can* introduce ambiguous type errors
10:53:58 <glguy> Anyone know danilo2's email and want to /msg it to me?
10:54:01 <haasn> vlatkoB: The same could happen with mapM and traverse, in theory
10:54:08 <Guest8434> -amar bnow Guest8434 :(
10:54:14 <Trollinator> kludgy: yes… Haskell is nice, but there still are other languages to learn from.
10:54:32 <haasn> vlatkoB: So it's still not possible to claim that you can *always* use traverse instead of mapM
10:54:36 <TheKing444> We should add more Machine Code features to haskell.
10:54:49 <haasn> But that seems highly unlikely here
10:54:52 <enthropy> @hackage harpy
10:54:52 <lambdabot> http://hackage.haskell.org/package/harpy
10:54:53 <kludgy> Trollinator: Stepping stone.. I can't wait for the next generation to stabilize.. really appreciate the second generation work
10:55:05 <TheKing444> vlatkoB and haasn, only when people play nice
10:55:18 <bb010g> haasn: You could with WrappedMonad
10:55:22 <TheKing444> What is harpy?
10:55:39 <enthropy> well assembly is "machine code"
10:55:46 <haasn> bb010g: The issue here is the ‘t’ in traverse no longer being fixed to []
10:55:48 <haasn> :t traverse
10:55:49 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:55:57 <Trollinator> kludgy: I miss a nicer way to define pattern matching functions. In Haskell you have to do \x -> case x of …. Both Scala and Ocaml have nicer ways to do that.
10:55:58 <TheKing444> that isn't really a problem
10:56:01 <dfeuer> I thought that cmachine code thing must've been a joke. Joke's on me.
10:56:09 <Trollinator> i. e. the function keyword in Ocaml
10:56:10 <enthropy> TheKing444: so I think it's related to your comment about "We should add more Machine Code features to haskell"
10:56:27 <vlatkoB> haasn: But traverse is more general, so mapM and company could go away?
10:56:27 <Trollinator> TheKing444: what do you mean by that?
10:56:42 <haasn> Trollinator: there's a LambdaCase language extension; permits \case [] -> ...; (x:xs) -> ...
10:56:46 <TheKing444> For traversable.
10:56:57 <bb010g> haasn: Just make a traverseL :: (Traversable t) => (a -> [b]) -> t a -> [t b]; traverseL = traverse
10:57:01 <bb010g> :t mapM
10:57:03 <dfeuer> Trollinator, look up lambda-case.
10:57:03 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
10:57:20 <TheKing444> > traverse (\x -> [x,x]) Nothing
10:57:22 <lambdabot>  [Nothing]
10:57:26 <Trollinator> oh, cool.
10:57:27 <haasn> bb010g: if you mean traverseL :: Applicative f => (a -> f b) -> [a] -> f [b] yes
10:57:27 <TheKing444> Hurray!
10:57:48 <bb010g> haasn: Yeah, sorry
10:58:05 <haasn> It's true to say that you can always replace less-general function by a more-general one if you attach a type signature constraining it it to the less-general one; assuming again that they have identical functionality
10:58:22 <haasn> But in general, this *can* lead to ambiguity errors
10:58:24 <dfeuer> Unfortunately, lambdabot doesn't support lambda-case.
10:58:25 <TheKing444> :t {\case; [x]->x; _ -> 42}
10:58:27 <lambdabot> parse error on input ‘{’
10:59:30 <TheKing444> The thing with traverse is the type can be completely inferred from the arguments. It isn't like randomly throwing in randomIO and seeing what type comes out.
10:59:38 <TheKing444> :t randomIO
10:59:39 <lambdabot> Random a => IO a
10:59:53 <dfeuer> The Schemer in me things the lambda-case syntax is wrong, because that should bind case. But Haskell is not Scheme.
11:00:49 <cdosborn> I need help with recursive file process, any help would be appreciated, http://lpaste.net/108505
11:01:21 <TheKing444> Taking a look now cdosborn.
11:01:46 <TheKing444> It appears that your code is down for maintenance.
11:01:53 <TheKing444> Down for maintenance!The backend didn’t respond, so it’s probably being updated or undergoing maintenance. It’ll be back in a minute.
11:02:07 <MP2E> TheKing444: I see it
11:02:08 <cdosborn> okay thanks, TheKing444
11:02:09 <orion> Is it possible to write one type signature for many functions?
11:02:31 <TheKing444> orion, yes
11:02:40 <MitchellSalad> foo, bar :: a
11:02:43 <orion> awesome, thanks
11:02:45 <dfeuer> cdosborn, it doesn't look like you've figured out exactly what your program is supposed to do.
11:02:53 <haasn> :t show $ mapM (\_ -> pure 3) (return ())
11:02:54 <orion> My syntax hilighter doesn't support that I guess.
11:02:54 <lambdabot>     No instance for (Show (m0 [b0])) arising from a use of ‘show’
11:02:54 <dfeuer> But you probably want some sort of parser.
11:02:54 <lambdabot>     The type variables ‘m0’, ‘b0’ are ambiguous
11:02:55 <lambdabot>     Note: there are several potential instances:
11:02:55 <TheKing444> bla, bleep, bloop, boil :: Yolo -> Set [ Set b ]
11:03:05 <MitchellSalad> many don't
11:03:18 <orion> :<
11:03:21 <TheKing444> haasn, that will work with any monadic applicative
11:03:22 <haasn> :t show $ mapM (\_ -> Identity ()) (return ())
11:03:23 <lambdabot> String
11:03:28 <haasn> :t show $ traverse (\_ -> Identity ()) (return ())
11:03:29 <lambdabot>     No instance for (Show (t0 ())) arising from a use of ‘show’
11:03:29 <lambdabot>     The type variable ‘t0’ is ambiguous
11:03:29 <lambdabot>     Note: there are several potential instances:
11:03:34 <haasn> Ambiguous type error
11:03:55 <TheKing444> That is because you wrote ambigous code.
11:04:14 <TheKing444> > random 0
11:04:16 <lambdabot>  No instance for (GHC.Show.Show g0)
11:04:17 <lambdabot>    arising from a use of ‘M421680765657617439919979.show_M4216807656576174399...
11:04:17 <lambdabot>  The type variable ‘g0’ is ambiguous
11:04:17 <lambdabot>  Note: there are several potential instances:
11:04:17 <lambdabot>    instance [safe] GHC.Show.Show
11:04:37 <TheKing444> Oh oh, ambigous type error. Why couldn't it figure out I wanted a random Bool.
11:04:42 <cdosborn> dfeuer, can you elaborate, Am i not being specific enough in the paste?
11:07:49 <cdosborn> dfeuer, I added some more explanation to the paste
11:09:13 <cdosborn> TheKing444, is the paste, http://lpaste.net/108505, still down
11:14:59 <dalt> Hi can somebody explain to me why with the following, input is read before the string is printed to the screen ("prompt" is only printed after input is read but with putStrLn, it is printed before input is read): do putStrLn "prompt: "; input <- getLine; print (evaluate input)
11:16:33 <Guest52574> Buffering probably
11:16:36 <josephle> dalt: you need to flush the stdout buffer
11:16:49 <Guest52574> @dalt look up Haskell buffering
11:16:49 <lambdabot> Not enough privileges
11:17:23 <fuzzyhorns> idk if any of you are polyglot in ruby, but i am curious if this is a legit implementation of a monad: http://goo.gl/63d8ri
11:17:24 <josephle> this problem isn't exclusive to Haskell
11:19:27 <orion> z | z >  6 -> 0x80 `B.cons` zbs `B.snoc` paddingTerminator'
11:19:38 <orion> I am trying to compile blakesum-0.5 and cabal fails on that line.
11:19:49 <orion> cannot mix \u2018B.cons\u2019 [infixr 5] and \u2018B.snoc\u2019 [infixl 5] in the same infix expression
11:19:53 <orion> Anyone know how to reslve it?
11:19:56 <orion> resolve*
11:27:31 <Fuuzetsu> does Gabriel Wicke come on IRC?
11:27:51 <Mkster> Why is S the successor here: data Nat = Zero | S Nat
11:28:13 <Fuuzetsu> Mkster: why not?
11:28:24 <Mkster> I don't get it
11:28:31 <Mkster> I never defined it
11:28:32 <Fuuzetsu> what do you not get? I don't understand the question
11:28:47 <n152> what's the question?
11:28:52 <Fuuzetsu> <Mkster> Why is S the successor here: data Nat = Zero | S Nat
11:29:12 <supki> orion: you'd have to patch the source to disambiguate the precedence with parens
11:29:51 <xyh> hi firends, I have designed a new functional programming language called cicada ::    https://bitbucket.org/cicada-language/cicada
11:29:54 <Pythonfant> Mkster: how would you represent two?
11:30:10 <Mkster> S(S Zero)
11:30:17 <Pythonfant> and how three
11:30:26 <Mkster> S(S(S Zero))
11:30:47 <Pythonfant> now let's say you have some number a and want to represent a+1, how would you do this?
11:31:17 <Mkster> You mean a function to do +1 ?
11:31:43 <Pythonfant> yep
11:31:52 <Mkster> Or this: S(n) ?
11:32:00 <Fuuzetsu> S
11:32:02 <Pythonfant> exactly S(n) is n+1
11:32:13 <Pythonfant> so do you see why S is the successor?
11:32:13 <Mkster> I know but why
11:32:38 <Fuuzetsu> ‘why’ what?
11:32:52 <Mkster> Why is S the successor
11:33:07 <Pythonfant> because S(n) is n+1
11:33:12 <Fuuzetsu> because it builds the successive number
11:33:14 <Mkster> but I never defined it
11:33:19 <Pythonfant> so S is the function that returns the sucessor
11:33:22 <Pythonfant> ofc you defined it
11:33:31 <MP2E> look at the definition again
11:33:35 <MP2E> data Nat = Zero | S Nat
11:33:56 <MP2E> S takes Nat as an argument, so S Zero is a natural successor to Zero
11:34:31 <Mkster> Shouldn't it be data Zero | S Zero then?
11:34:47 <Fuuzetsu> Zero is not a data type
11:35:07 <Fuuzetsu> and you want a successor to any number, not just Zero or otherwise we'd have Zero | One ;)
11:35:18 <MP2E> exactly
11:35:38 <MP2E> This allows you to represent arbitrary numbers (as long as they are >=0)
11:35:43 <MP2E> and integers of course
11:36:05 <Fuuzetsu> well, that's untrue, what about 1.5
11:36:08 <Fuuzetsu> that's a number >=0
11:36:10 <Exio> integers
11:36:13 <MP2E> I said integers.
11:36:26 <Fuuzetsu> just say it represents natural numbers…
11:36:40 <MP2E> Depending on your definition of Natural number, it might not include 0
11:36:44 <MP2E> but anyway
11:36:44 <genisage> But then you start a flame war about whether zero is a natural number
11:36:48 <MP2E> exactly
11:36:50 <Exio> hah
11:37:03 <Fuuzetsu> genisage: no flamewars, it's obviously a natural number
11:37:10 <Fuuzetsu> starting from 1? That's just silly!
11:37:24 <Exio> some people say it is, some say it isn't
11:37:54 <tdammers> some people even go so far as to say it's not a number at all
11:37:57 <Fuuzetsu> I wonder when this argument started
11:38:21 <zmbmartin> What is the preferred file naming method? Capital or lowercase to start?
11:39:00 <Fuuzetsu> LikeThis.hs
11:39:14 <Fuuzetsu> file names (bar extension) should be what your module names are
11:41:53 <meretrix> If I start a haskell executable with createProcess, the child's process' stdout defaults to block buffering.  Is this to be expected?  It seems like a bad default.
11:42:15 <dfeuer> Who wants to play RULES with me? Come on. Someone must!
11:42:16 <latk> If I have a sum type like data Test = TestA | TestB, how could I define to/fromrow instances for postgres simple ?
11:42:28 <genisage> Can anybody help me improve my solution here? http://lpaste.net/108471 I'd like to simplify or eliminate the calls to 'best'
11:42:35 <genisage> dfeuer: What is RULES?
11:43:10 <geekosaur> meretrix, on which end?
11:43:20 <dfeuer> genisage, RULES is a GHC pragma for defining simplifier rules. It's used to add optimizations to the compiler without having to actually change the compiler.
11:43:33 <dfeuer> rewrite rules, that is.
11:43:44 <geekosaur> you cannot control how the child process chooses buffering, except via hacks like gnu stdbuf with glibc (which will fail for anything not using glibc's stdio, such as haskell)
11:44:02 <meretrix> geekosaur: The stdout of the child process is block buffering even if I set the parent's handles to no buffering.
11:44:10 <geekosaur> yes
11:44:16 <geekosaur> that would be what I just said
11:44:20 <dfeuer> It's reminiscent of macro programming, but, on the one hand, it's typed, and on the other hand, there's no distinction between what is and what is not a macro.
11:44:25 <genisage> dfeuer: how does one play RULES?
11:44:30 <geekosaur> createProcess has no control over this. *the child* decides
11:44:33 <geekosaur> and it sees a pipe
11:44:37 <geekosaur> and uses block buffering
11:44:49 <Fuuzetsu> genisage: you put RULES in your code then play with GHC until they fire
11:44:50 <dfeuer> genisage, one takes a look at the RULES I wrote and tries to find bugs in them.
11:45:05 <dfeuer> (either semantic or performance bugs)
11:45:06 <meretrix> geekosaur: But doesn't the child look at the parent?  Like if you run the child on the terminal, it won't use block buffering.
11:45:13 * hackagebot data-variant 0.28.0.3 - A variant data type, useful for modeling dynamically-typed programming languages  http://hackage.haskell.org/package/data-variant-0.28.0.3 (TobiasDammers)
11:45:15 * hackagebot hpaco-lib 0.28.0.3 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.28.0.3 (TobiasDammers)
11:45:17 * hackagebot hpaco 0.28.0.3 - Modular template compiler  http://hackage.haskell.org/package/hpaco-0.28.0.3 (TobiasDammers)
11:45:22 <geekosaur> the child sees its stdout is a tty device and chooses line buffering
11:45:30 <geekosaur> the parent has zero say
11:45:33 <gp5st> http://dpaste.com/1T6V9YB.txt am I doing anything terribly non-haskelly that I should stop doing as I learn the language?
11:45:51 <genisage> I'd like to look at them, but I'm probably not the most competent opponent
11:46:28 <dfeuer> genisage, they're at http://lpaste.net/108508
11:46:30 <Fuuzetsu> gp5st: single-line do ;)
11:46:45 <Fuuzetsu> concatMap (prime_factors) $ possible_factors n
11:46:48 <Fuuzetsu> suprious parens
11:46:48 <monochrom> the futility of trying to control a program you didn't write
11:46:51 <Fuuzetsu> suprious*
11:46:57 <gp5st> Fuuzetsu: ah:) hold over from when I was printing more; point taken
11:46:59 <Twey> If I have a Cabal package foo-bar with module Foo.Bar in foo-bar/Foo/Bar.hs, how can I ‘cabal repl’ from emacs whilst editing Foo/Bar.hs?  It tells me ‘No cabal file found’, presumably because it's executing the command from foo-bar/Foo/ instead of foo-bar/
11:47:07 <geekosaur> meretrix, if you want to change that, you need to provision a pty and pass it to createProcess. just as with any other situation like this in any languge on any unixlike (windows will differ, in part because it doesn't have the concept of tty devices)
11:47:08 <johnw> concatMap prime_factors (possible_factors n) is really clearer
11:47:16 <Fuuzetsu> god damn it, twice the same typo
11:47:32 <johnw> using $ when it saves nothing is usually not worth it
11:47:34 <Fuuzetsu> Twey: M-x cd
11:47:59 <Twey> Fuuzetsu: Already tried it; didn't help
11:48:04 <monochrom> too many foobars
11:48:06 <Fuuzetsu> you tried it wrong
11:48:22 <gp5st> Thanks Fuuzetsu and johnw
11:48:38 <Fuuzetsu> M-x cd to foo-bar, run cabal repl and switch to *haskell* to see what it's complaining about
11:48:51 <Fuuzetsu> it might be that you just think you failed the first time because it wasn't configured at which point emacs doesn't switch
11:49:10 <Twey> Fuuzetsu: It just says http://lpaste.net/9110422986904567808
11:49:32 <Twey> Ah, I guess I had to kill the buffer
11:49:58 <Twey> It sees it after killing the buffer then cd'ing and doing C-c C-l again
11:50:31 <Fuuzetsu> is anyone using bits-extras either directly or as a dependency?
11:51:07 <mmmm_> Does anyone remember the name of that library which replaces undefined with a similar thing but with better error messages?
11:51:19 <johnw> mmmm_: do you mean typed holes in GHC 7.8.3?
11:51:27 <johnw> or just the function error?
11:51:55 <Twey> gp5st: Some minor cosmetic things: you don't need brackets around function applications surrounded by operators, e.g. (mod n f) == 0 is the same as mod n f == 0
11:52:02 <Fuuzetsu> I think there's a lib which puts in line numbers &c
11:52:08 <mmmm_> no, it had some functions like "todo" which gave you additional information if you ever tried to run them
11:52:09 <Twey> gp5st: And concatMap f xs can be written xs >>= f
11:52:25 <gp5st> Twey: oh nice:) thanks:)
11:52:35 <Twey> gp5st: So e.g. base_factors n = possible_factors n >>= prime_factors
11:52:49 <Twey> gp5st: The usual convention is camelCase rather than with_underscores
11:53:16 <Twey> (we know, but it's stuck now)
11:53:48 <Fuuzetsu> (for the better)
11:54:13 <Twey> gp5st: Actually, with (>=>) from Control.Monad you can write baseFactors = possibleFactors >=> primeFactors.  But you don't need to.
11:54:31 <monochrom> I still like underscores
11:54:42 <Twey> I'm a hyphens-sort-of-guy
11:55:12 <Twey> IME there are all types and the only thing they agree on is that nobody likes camelCase
11:56:05 <schell> Twey: wait a sec, i like camel case
11:56:06 <nschoe> Hey, I'm trying to add session capability to my web site, I am using scotty. I saw that scotty-session was deprecated in favor of Spock
11:56:09 <schell> less chars
11:56:11 <monochrom> my ideal is space (generally every character can be used in identifiers). failing that, the next best thing is hyphen like in lisp and scheme. failing that, underscore.
11:56:16 <Twey> There's always one ;þ
11:56:17 <nschoe> but I did not find how to integrate Spock with Scotty ?
11:56:22 <Twey> monochrom: *nod* Right there with you
11:56:30 <nschoe> Is it straightforward ?
11:56:47 <johnw> i've grown quite used to camel case
11:56:51 <schell> Twey: thought i could get down with hyphen
11:57:13 <monochrom> camel case is too crowded
11:57:16 <johnw> dromedaryCCaseSSyntax
11:57:25 <Twey> schell: If my name is long enough that it consists of multiple words, it's already too long for me to care about making it short
11:57:29 <schell> but - wouldn’t that be a syntax error? ghc would think (thing(-)thing2)
11:57:32 <Twey> johnw: Haha
11:57:36 <Twey> schell: Yep.
11:57:53 <Twey> schell: Haskell doesn't support hyphens in (non-operator) identifiers.
11:58:08 <Twey> You need operators surrounded by whitespace for that.
11:58:08 <mmmm_> there's not even a ghc extension for it??
11:58:13 <Twey> Not yet… :þ
11:58:21 <dfeuer> No, thankfully.
11:58:24 <mmmm_> gsoc 2015
11:58:38 <schell> Twey: i come from objc where you depend on long descriptive names
11:58:40 <johnw> let's make an extension so that every Unicode variant on whitespace is an identifier character
11:58:58 <dfeuer> mmmm_, why don't you just use an n-dash or something?
11:59:03 <dfeuer> en-dash
11:59:06 <chrisdone> shodan: awesome nickname
11:59:08 <Twey> It's a symbol character
11:59:14 <Fuuzetsu> because that upsets all the unicode haters
11:59:16 <schell> - (void)aFunctionThatTakes:(Type*)aThing andDoesThisStuff:(Block)f;
11:59:44 <Twey> schell: *shudder* Yes, Obj-C is an argument against descriptive names :þ
12:00:07 <schell> Twey: sometimes it’s nice - interleaved params can be nice
12:00:12 <dfeuer> Oh yeah, that's a problem, Twey.
12:00:30 <chrisdone> fuuzetsu: hātèrş ǵōņńä hãtė
12:00:33 <dfeuer> en-dashes have to be operators.
12:00:34 <mmmm_> I liked writing scala for programming assignments because you can use unicode in function names
12:01:01 <dfeuer> Oh, that would be funny.
12:01:05 <chrisdone> twey: call-with-current-continuation
12:01:07 <Twey> schell: I don't dislike the naming, I just dislike that you can't opt out
12:01:12 <monochrom> > let x – y = x*(2+y) in 5 – 3
12:01:15 <lambdabot>  25
12:01:34 <johnw> chrisdone: call/cc!
12:01:37 <chrisdone> twey: otoh lisp has the awesome / convention
12:01:39 <chrisdone> johnw ♥
12:01:40 <Twey> call/cc, indeed :þ
12:01:43 <dfeuer> @let m–n = [m..n]
12:01:47 <lambdabot>  Defined.
12:01:48 <Fuuzetsu> chrisdone: is there en emacs mode to zalgo your programs yet
12:02:02 <chrisdone> fuuzetsu: feed me beer and there will be
12:02:13 <dfeuer> > 1–(5-2)
12:02:16 <lambdabot>  [1,2,3]
12:02:33 <dfeuer> The en-dash should totally be a range operator.
12:02:40 <Twey> @let infixl 5 –
12:02:41 <lambdabot>  Defined.
12:02:53 <chrisdone> > 1–5-2
12:02:53 <Twey> > 5-2–10-4
12:02:55 <lambdabot>  can't find file: L.hs
12:02:55 <lambdabot>  [1,2,3]
12:02:57 <chrisdone> oh lawd
12:03:01 <Twey> :þ
12:03:04 <dfeuer> Twey, I don't think it can associate sensibly.
12:03:12 <Twey> Oops, you're right.  I meant infix.
12:03:12 <monochrom> > [x+1 | x <- 3–10]
12:03:14 <cristian__> Hi there, first time here. I'm pretty new to functional programming in general. Just have a question, is there any exact real arithmetic haskell library I could use? Tried googling a bit, or reading the haskell.org entry, but still feel a bit lost. Should I be looking into dynamic precision?
12:03:15 <lambdabot>  [4,5,6,7,8,9,10,11]
12:03:20 <dfeuer> But yes, that's very nice.
12:03:21 <Twey> cristian__: CReal
12:03:27 <Twey> cristian__: But, er, be careful.
12:03:47 <Fuuzetsu> chrisdone: I agree that booze and ELisp are two things that must come together
12:03:50 <Twey> cristian__: Exact reals are very slow, and mean that arithmetic operations may fail to terminate.
12:03:58 <schell> Twey: i hear that
12:04:00 <monochrom> what do you want out of exact real arithmetic?
12:04:25 <dfeuer> Fuuzetsu, are you referring to Emacs Lisp, or the other one?
12:04:25 <monochrom> I ask because you must give up one thing or another. there are a lot of trade-offs.
12:04:34 <Fuuzetsu> dfeuer: …the other one?
12:04:43 <Twey> Fuuzetsu: There's another language called ELisp
12:04:56 <chrisdone> “Thank you for applying for our Haskell position. First question: What is the value of 5-2–10-4?"
12:04:57 <chrisdone> “Ehm,” tugs collar, “-11?”
12:04:57 <chrisdone> “IT'S A LIST OF 1, 2, and 3. GET OUT! (°¬°)_/”
12:05:00 <Fuuzetsu> I bet it's not half as as fucking terrible
12:05:14 <monochrom> haha chrisdone
12:05:23 <Twey> chrisdone: Heheheh.
12:05:23 <dfeuer> Fuuzetsu, I wouldn't necessarily bet that. I think it's similarly ancient.
12:05:31 <Twey> Yes, it's quite dead nowadays.
12:05:39 <Fuuzetsu> Unlike Emacs Lisp.
12:05:45 <Twey> *Yet*.
12:06:03 <monochrom> I heard of an interview C question about 4["abcdefg"]. in fact I read of it in Dr. Dobb's Journal a long time ago, like 2 decades.
12:06:05 <Twey> Another SoC, another Guilemacs milestone…
12:06:10 <cristian___> Sorry, seems me connection went down for a bit. Read CReal and that I should be careful, didn't get why haha
12:06:16 <Twey> monochrom: It's a pretty good interview question.
12:06:20 <Twey> 200245 <Twey> cristian__: Exact reals are very slow, and mean that arithmetic operations may fail to terminate.
12:06:27 <Twey> cristian___: 200255 <monochrom> what do you want out of exact real arithmetic?
12:06:32 <Fuuzetsu> I had someone claiming that Guile was fast as C the other day
12:07:22 <chrisdone> monochrom: oo, that's interesting. what's the question?
12:07:24 <cristian___> I'm trying to implement a css minifier as a way to learn Haskell, and one of the minifications I want to do is changing between absolute units when one representation is shorter than another
12:07:33 <dfeuer> Emacs Lisp will last until the end of time. Or at least until someone comes up with another system that blind users can use for programming, mathematics, etc.
12:07:55 <Twey> cristian___: You really do not want exact reals
12:08:03 <monochrom> chrisdone: the interview C question? it was simply: what does 4["abcdefg"] evaluate to
12:08:07 <hiptobecubic> chrisdone, probably just "how does this work"
12:08:18 <Twey> cristian___: You might want Rationals, but you'll probably be fine with Doubles.
12:08:50 <tdammers> monochrom: that's a shitty interview question
12:08:56 <geekosaur> yeh, one of those infamous ancient C wtfs
12:09:05 <hiptobecubic> depends on what you're trying to figure out i think
12:09:18 <tdammers> monochrom: it basically tests if you have ever read about this particular edge case that has no practical use, and that you will never encounter in the wild
12:09:18 <Twey> I like it — it requires an understanding of pointers, pointer arithmetic, indexing, and string representation
12:09:26 <hiptobecubic> it's one of those "interesting if you know this, not interesting if you don't"
12:09:26 <jedai> It's pretty random though...
12:09:31 <cristian___> I thought about it because for instance, if I do in ghci 0.1 * 96 (if I were to change from 0.1 inches to pixels), the result is something like 9.60000001
12:09:31 <chrisdone> monochrom: ah, what's the answer?
12:09:37 <Twey> And if you've used C for long enough you've probably seen it
12:09:41 <Twey> chrisdone: (char) 'e'
12:09:42 <monochrom> same answer as "abcdefg"[4]
12:10:06 <chrisdone> ohh
12:10:11 <johnw> monochrom: now what does sizeof(4)["abcdefg"] evaluate to
12:10:20 <geekosaur> cristian___, the correct way to do this is pick some arbitrary cutoff and round the result to it. for CSS I doubt you'd ever want more than 1 digit after the decimal, *maybe* 2
12:10:21 <jedai> Twey: It first require you to know about the reversability of [] which nobody uses
12:10:23 <geekosaur> errprs wpm
12:10:24 <monochrom> both can be legitimately called syntax sugar for *("abcdefg" + 4) aka *(4 + "abcdefg")
12:10:32 <chrisdone> so the syntax <int literal>[whatever] is sugar for whatever[<int literal>]?
12:10:37 <johnw> monochrom: what job wanted to know this?
12:10:39 <Twey> jedai: Ah, but it doesn't.  It requires you to know that + is associative and a[b] is *(a + b)
12:10:43 <hiptobecubic> ptr[idx] -> *(ptr + idx) == *(idx + ptr)
12:10:45 <lep-delete> not sugar but equivalent
12:10:51 <monochrom> I don't know. I saw it in Dr. Dobb's Journal 2 decades ago
12:10:58 <Twey> jedai: The former I would expect everyone to know, and the latter I would hope a C programmer would know
12:11:05 <geekosaur> errors won't get that large normally althoygh that may depend on what your'e doing, in which case I suggest you learn proper IEEE FP hygiene like you would have to for FP ops in any language
12:11:47 <chrisdone> twey: why does it index on the char* value? is it syntactical or a strange pointer subtlety?
12:11:49 <jedai> Twey: frankly I think this traduction is unnecessary to know for most
12:11:59 <hiptobecubic> johnw, "it depends"
12:12:17 <chrisdone> i don't mind this question -- i think it's one of those that people ask to see how people deal with not knowing something
12:12:23 <Twey> chrisdone: a[b] = *(a + b)
12:12:23 <hiptobecubic> but probably undefined behavior
12:12:30 <monochrom> cristian___: it seems that either Rational or careful use of Double will do
12:12:35 <chrisdone> twey: ohh =)
12:12:44 <Andrey__> hi, could someone please help me out with postgres-simple, scotty and monads? I have a database function get with return IO (Maybe Int), and I also retrieve value from header that has type of Maybe. How would I apply that header value to the function using monad syntax? So value is (Maybe Int) and function takes Int and retruns IO (Maybe Int)
12:12:55 <TheKing4444> :t \f -> foldr ($) undefined (repeat f)
12:12:56 <lambdabot> (b -> b) -> b
12:13:11 <cristian___> Yeah I guess you are right, I'll probably go that way. Just wanted that the output version wouldn't differ from the original (other than the size / chars used of course), but I think that might be the most logical option. Thanks for the help!
12:13:22 <johnw> hiptobecubic: the key is that sizeof has lower precedence
12:13:30 <johnw> so its sizeof ((4)["abcdef"])
12:14:15 <hiptobecubic> johnw, oh, so then instead of undefined behaviour it's just "implementation dependent" or something
12:14:25 <johnw> it's 1
12:14:28 <johnw> the size of a character
12:14:35 <hiptobecubic> johnw, on all platforms?
12:14:41 <johnw> merijn would know
12:14:56 <frerich> hiptobecubic: sizeof(char) is defined to be 1 by the standard. What’s not defined is the number of bits (CHAR_BIT) per byte.
12:15:07 <dfeuer> johnw, any way we could continue that effectful stream discussion from a few days ago?
12:15:08 <jedai> Andrey__: you need to handle the case where you have a nothing
12:15:18 * hackagebot web-plugins 0.2.6.1 - dynamic plugin system for web applications  http://hackage.haskell.org/package/web-plugins-0.2.6.1 (JeremyShaw)
12:15:21 <hiptobecubic> frerich, ah
12:15:23 <lep-delete> yes, sizeof(char) == 1 is defined
12:15:24 <johnw> dfeuer: I'm afraid I'm out of time until next weekend
12:15:45 <TheKing44> :t sizeOf
12:15:46 <lambdabot>     Not in scope: ‘sizeOf’
12:15:46 <lambdabot>     Perhaps you meant one of these:
12:15:47 <lambdabot>       ‘IM.size’ (imported from Data.IntMap),
12:16:57 <jedai> Andrey__: use pattern matching
12:16:58 <Andrey__> jedai: So, I need to do cases and I can't do it with monad syntax?
12:17:14 <djahandarie> Optimizing  (x1 : x2 : x3 : []) ++ ys  into  x1 : x2 : x3 : ys  almost seems like something that should be able to happen without a rewrite rule. Or at least it would be nice.
12:17:15 <jedai> Andrey__: oh you can, this is just the simplest and most explicit
12:17:23 <dfeuer> Ah well. Perhaps then, johnw. Thanks.
12:17:57 <Andrey__> jedai: i'm trying to do it with cases, and it looks pretty crazy :)
12:17:58 <merijn> hiptobecubic: sizeof char is 1
12:18:00 <johnw> dfeuer: are you coming to Hac Boston?
12:18:04 <jedai> Andrey__: for instance you could do "maybe (error "this fail") dbFunction) headerValue"
12:18:10 <chrisdone> monochrom: the reliable c question i tend to ask is: char foo[3]; what is the type of foo?
12:18:12 <merijn> hiptobecubic: Because the fundamental unit of adressing in C is the "char"
12:18:15 <jedai> Andrey__: Why ?
12:18:32 <merijn> hiptobecubic: You can have 32 bit char's, for example (I have colleagues that have machines with such an architecture)
12:18:54 <jedai> Andrey__: it's just "case headerValue of Nothing -> error "fail"; Just n -> dbFunction n
12:19:11 <dfeuer> johnw, I don't know anything about it, but it's unlikely. My schedule is nuts and unpredictable.
12:20:10 <jedai> Andrey__: or if you want to provide a default value "return Nothing" instead of the error
12:20:10 <Andrey__> jedai: because it's inside Scotty's ActionM monad, I have to do all those LiftIOs
12:20:26 <hiptobecubic> merijn, seems like a strange way to arrange things, but what do I know :)
12:20:43 <jedai> Andrey__: Well you can just do one liftIO for the whole thing, it doesn't change much
12:21:09 <Andrey__> jedai: ok, I'll give it a try, I was just wondering if there is a simpler way :)
12:21:11 <TheKing44> :t liftIO
12:21:13 <lambdabot> MonadIO m => IO a -> m a
12:21:23 <chrisdone> monochrom: invariably someone says char*, but the answer is char[3]
12:21:38 <jedai> so : liftIO (case headerVal of Nothing -> return Nothing; Just n -> dbFunction n)
12:21:54 <mister_integer> so in cabal, let's say I want to include some examples with my package, using an examples/ folder at top level
12:22:06 <dmwit> :t traverse
12:22:07 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:22:10 <chrisdone> jedai: may be ickier:
12:22:11 <mister_integer> how can I get GHC to include *this package* in the build path?
12:22:16 <mister_integer> within a sandbox, etc
12:22:19 <chrisdone> liftIO (join (fmap dbFunction headerVal))
12:22:36 <jedai> chrisdone: right :)
12:22:40 <chrisdone> hm, not sure that type checks actually, i'll think about it
12:22:51 <dmwit> I doubt join is the right thing.
12:22:55 <chrisdone> no, more like
12:22:59 <dmwit> I suspect something from traversable is more right.
12:23:04 <TheKing44> Who needs help haskellin?
12:23:14 <chrisdone> a forM should do it
12:23:23 <Twey> :t let value = undefined :: Maybe Int; function = undefined :: Int -> IO (Maybe Int) in maybe (return Nothing) function value
12:23:25 <lambdabot> IO (Maybe Int)
12:23:27 <chrisdone> hmm, no, traverse, like you write, seems good
12:23:29 <Twey> Andrey__: ^
12:23:37 <jedai> I think except if he encounters it several time (which might be, I don't know the framework) the simple solution is good enough
12:23:48 <jedai> :t traverse
12:23:48 <dmwit> traverse isn't quite it because dbFunction adds an extra layer of Maybe.
12:23:48 <chrisdone> :t traverse :: (a -> IO b) -> Maybe a -> IO (Maybe b)
12:23:49 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:23:50 <lambdabot> (a -> IO b) -> Maybe a -> IO (Maybe b)
12:24:07 <chrisdone> doesn't seem to
12:24:15 <Twey> You've got Maybe (IO (Maybe Int)) from fmap.  You just want maybe, to get rid of the outer layer altogether
12:24:18 <chrisdone> :t traverse :: (a -> IO b) -> Maybe a -> IO (Maybe b) -- seems the right type
12:24:20 <lambdabot> (a -> IO b) -> Maybe a -> IO (Maybe b)
12:24:23 <dmwit> If the original code is correct, dbFunction doesn't have type (a -> IO b).
12:24:28 <dmwit> It has type (a -> IO (Maybe b)).
12:24:30 <jedai> fmap join ?
12:24:31 <chrisdone> oh, oic
12:25:14 <Twey> maybe (return Nothing) id $ fmap function value
12:25:16 <jedai> :t fmap join :: IO (Maybe (Maybe a)) -> IO (Maybe a)
12:25:17 <lambdabot> IO (Maybe (Maybe a)) -> IO (Maybe a)
12:25:18 <chrisdone> i tend to use the `maybe' solution
12:25:20 * hackagebot happstack-authenticate 0.10.14 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.10.14 (JeremyShaw)
12:25:24 <Twey> Which is of course: maybe (return nothing) function value
12:25:28 <chrisdone> more verbose but easier for me to generate
12:25:28 <Twey> Er, Nothing
12:25:29 <TheKing44> @type id
12:25:31 <lambdabot> a -> a
12:25:52 <Twey> chrisdone: You have to use maybe
12:25:56 <Twey> You need an eliminator
12:26:06 <chrisdone> twey: seems like jedai's fmap join does that
12:26:08 <Twey> (or a case or something)
12:26:13 <jedai> Twey: right, I proposed that first
12:26:29 <Twey> Oh, you mean traverse it first and then join the Maybe away
12:26:31 <Twey> Yeah
12:26:36 <Twey> :t fmap join . traverse
12:26:37 <lambdabot> (Traversable m, Applicative m, Monad m) => (a1 -> m a) -> m a1 -> m a
12:26:48 <chrisdone> but yeah, i think the `maybe' call is easier to grok
12:26:53 <TheKing44> @type traverse
12:26:54 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:27:23 <Twey> Yeah, the fact that traverse works is… not rooted in nice semantics :þ
12:27:29 <chrisdone> :t fmap join . traverse :: (Maybe a -> IO a) -> m (Maybe a) -> IO a
12:27:30 <lambdabot>     Couldn't match type ‘m1’ with ‘IO’
12:27:31 <lambdabot>       ‘m1’ is a rigid type variable bound by
12:27:31 <lambdabot>            an expression type signature:
12:27:34 <chrisdone> oops
12:27:36 <chrisdone> :t fmap join . traverse :: (Maybe a -> IO a) -> IO (Maybe a) -> IO a
12:27:37 <lambdabot>     No instance for (Traversable IO) arising from a use of ‘traverse’
12:27:38 <lambdabot>     In the second argument of ‘(.)’, namely ‘traverse’
12:27:38 <lambdabot>     In the expression:
12:27:47 <chrisdone> oh, duh
12:27:48 <dmwit> :t \f -> fmap join . traverse f
12:27:49 <lambdabot> (Traversable m, Applicative f, Monad m) => (a1 -> f (m a)) -> m a1 -> f (m a)
12:27:51 <Twey> Or is it?  Maybe they want the IO action to be run anyway
12:27:54 <Twey> Andrey__?
12:27:58 <chrisdone> :t fmap join . traverse :: (Maybe a -> IO a) -> Maybe a -> IO a
12:28:00 <lambdabot>     Couldn't match type ‘Maybe a1’ with ‘IO a1’
12:28:00 <lambdabot>     Expected type: (Maybe a1 -> IO a1) -> Maybe a1 -> IO (IO a1)
12:28:00 <lambdabot>       Actual type: (Maybe a1 -> IO a1)
12:28:03 <chrisdone> okay, i give up
12:28:12 <TheKing44> > traverse (a->modify (+a)) [1,2,3,4]
12:28:14 <lambdabot>  Pattern syntax in expression context: a -> modify (+ a)
12:28:19 <jedai> :t fmap join . traverse :: (a -> IO (Maybe a)) -> (Maybe a) -> IO a
12:28:20 <lambdabot>     Couldn't match type ‘Maybe (Maybe a1)’ with ‘IO a1’
12:28:20 <lambdabot>     Expected type: (a1 -> IO (Maybe a1)) -> Maybe a1 -> IO (IO a1)
12:28:20 <lambdabot>       Actual type: (a1 -> IO (Maybe a1))
12:28:24 <chrisdone> lol
12:28:33 <chrisdone> ヽ (＾▽＾) ﾉ all aboard the fail train
12:28:40 <dmwit> :t (\f -> fmap join . traverse f) :: (a -> IO (Maybe b)) -> Maybe a -> IO (Maybe b)
12:28:41 <lambdabot> (a -> IO (Maybe b)) -> Maybe a -> IO (Maybe b)
12:28:46 * dmwit never fails
12:28:50 <dmwit> ...except when I do.
12:28:56 <jedai> dmwit: wow :)
12:29:09 <chrisdone> dmwit: it's easier if you test in ghci first ;)
12:29:19 <monochrom> always test
12:29:21 <Andrey__> I like the maybe solution, but I found out another thing, I probably want to fail if there is no value because if first request to database fails, I want to do another one that adds header value to database
12:29:30 <chrisdone> monochrom: where's the excitement in that? :p
12:29:32 <jedai> chrisdone: or in chat with lambdabot
12:29:45 <monochrom> testing is exciting
12:29:54 <chrisdone> jedai: that makes me feel like Joaquin Phoenix in Her
12:29:56 <TheKing44> > traverse (\a->modify (+a)) [1,2,3,4]
12:29:58 <lambdabot>  No instance for (GHC.Show.Show (f0 [()]))
12:29:58 <lambdabot>    arising from a use of ‘M778285733539932324521150.show_M7782857335399323245...
12:29:58 <lambdabot>  The type variable ‘f0’ is ambiguous
12:29:58 <lambdabot>  Note: there are several potential instances:
12:29:58 <lambdabot>    instance [safe] GHC.Show.Show a =>
12:30:01 <jedai> Andrey__: which is where you come back to the case statement
12:30:34 <chrisdone> monochrom: with ircbrowse data i could generate scores for people based on lambdabot fails =p
12:30:36 <jedai> Andrey__: it's easier to read if your nothing case is complex
12:30:50 <dmwit> You can see all the testing I did in-channel. Though I will admit I observed others' failure carefully before succeeding.
12:30:53 <Twey> :t fmap (fmap join) . traverse :: (Int -> IO (Maybe Int)) -> Maybe Int -> IO (Maybe Int)
12:30:54 <lambdabot> (Int -> IO (Maybe Int)) -> Maybe Int -> IO (Maybe Int)
12:31:02 <Andrey__> so there will be two nested case of statements
12:31:06 <monochrom> "maybe" and "case" are pretty close. "maybe x (\y -> z) m" = "case m of {Nothing -> x; y -> z}"
12:31:13 <chrisdone> dmwit: https://www.youtube.com/watch?v=sTHHjTV5PL0
12:31:28 * dmwit preens
12:32:07 <chrisdone> :3
12:32:17 <bitemyapp> chrisdone: that's becoming a dialogue.
12:32:35 <bitemyapp> I'm including the humorous aside you made too :)
12:32:52 <jedai> Andrey__: or you could extract the code in case of failure
12:32:55 <chrisdone> bitemyapp: what's a dialogue in this case?
12:33:01 <enthropy> @type \f x -> auf (_Unwrapping MaybeT) (=<<) f (MaybeT (return x))
12:33:02 <lambdabot> Not in scope: data constructor ‘MaybeT’
12:33:02 <lambdabot> Not in scope: data constructor ‘MaybeT’
12:33:09 <jedai> Andrey__: factor it out
12:33:24 <bitemyapp> chrisdone: from https://github.com/bitemyapp/learnhaskell in https://github.com/bitemyapp/learnhaskell/blob/master/dialogues.md
12:33:55 <Andrey__> jedai: like create a separate function?
12:33:55 <chrisdone> bitemyapp: oh, fun =)
12:33:57 <bitemyapp> chrisdone: I got tired of knowledge getting blown away by the wind in IRC.
12:34:09 <bitemyapp> chrisdone: please save and PR things like this so I don't miss anything.
12:34:16 <bitemyapp> even goofy situations like getting the types wrong.
12:34:36 <Andrey__> jedai: that's actually a great idea - a db function getOrCreate
12:34:42 <jedai> Andrey__: right, if it is sufficiently complicated and doesn't have much to do with the main goal of the function you're currently writing
12:35:03 <jedai> Andrey__: if it is such a pattern then go for it :)
12:36:19 <bitemyapp> chrisdone: can you imagine how much information that isn't discoverable has been passed around in this channel?
12:37:38 <Twey> bitemyapp: Well, we have public logs.
12:38:24 <chrisdone> bitemyapp: indeed. i often use ircbrowse as a means to get at old conversations. at one point i considered supporting a kind of "link" url syntax for linking to a specific conversation with only select messages displayed
12:38:36 <bitemyapp> Twey: it needs curation, tagging.
12:38:37 <Andrey__> btw, do you guys know how to create Scotty or Wai middleware? I want to extract that header value and in case it matches my criteria, I want it to be set somewhere for all routes to access, otherwise, just respond with bad request. Something simillar to authorization
12:39:29 <chrisdone> bitemyapp: e.g. i can link to the start of this http://ircbrowse.net/browse/haskell?id=18712056&timestamp=1406834428#t1406834428
12:39:43 <bitemyapp> chrisdone: so much noise.
12:39:48 <bitemyapp> chrisdone: I strip all the noise out of the dialogues.
12:39:54 <chrisdone> bitemyapp: but it's full of joins, parts, separate convos. if i could include only the messages pertaining, i could have a "bookmarks" section on the site
12:39:58 <bitemyapp> I give them a title as well to tag what keywords they're relevant to.
12:40:07 <bitemyapp> I also filter out other peoples' conversations.
12:40:11 <bitemyapp> It really doesn't take much time.
12:40:15 <bitemyapp> but I need other people to be doing it too.
12:40:20 <bitemyapp> I can't be everywhere, all the time.
12:40:24 <TheKing44> filter isLame
12:40:36 <chrisdone> (゜。゜)
12:40:42 <bitemyapp> Just a handful of people keeping an eye out could substantially increase the amount of learning material out there.
12:40:58 <bitemyapp> it could also help us build a body of material that can be refined, to point new people to, any number of benefits.
12:41:01 <chrisdone> twey: i think someone prefers his own stuff ;)
12:41:15 <Twey> Heh.
12:41:20 <bitemyapp> I like ircbrowse but this isn't the same thing.
12:41:22 <Twey> Dialogues aren't a bad idea
12:41:38 <Twey> But conversations aren't always cleanly divided into topics
12:41:50 <bitemyapp> I'm not really interested in nitpicking
12:41:55 <bitemyapp> I just want material to stop being lost.
12:41:59 <enthropy> isn't there enough learning material already?
12:42:03 <bitemyapp> enthropy: gods no.
12:42:18 <bitemyapp> enthropy: plurality is needed because not everybody learns the same way, for one thing.
12:42:23 <Enigmagic> we need more monad tutorials
12:42:32 <bitemyapp> enthropy: for another, if there were enough good learning material, people wouldn't find lenses mysterious.
12:43:00 <chrisdone> on /prog/ you can do this: http://dis.4chan.org/read/prog/1396674904/1,5,10-11,13
12:43:12 <bitemyapp> that's convenient, but oh my god 4chan
12:43:13 <chrisdone> i.e. display only parts of a conversation
12:43:23 <bitemyapp> seems harder than the copy-pasta I do.
12:43:25 <chrisdone> something like that would be sweet on ircbrowse
12:43:29 <bitemyapp> good idea though.
12:44:14 <chrisdone> i could have a "bookmark mode" where you can click every line you want included and it updates the url!
12:44:15 <chrisdone> =o
12:44:29 <bitemyapp> chrisdone: need tagging and retention into a list
12:45:18 <bitemyapp> the inlining of content in dialogues.md is intentional - I want grepping/search to work
12:47:42 <MitchellSalad> bitemyapp: perhaps i could add a "IRC dialog" type to www.dohaskell.com, would that be an appropriate place for you to collect snippes a la dialogues.md?
12:49:55 <bitemyapp> MitchellSalad: oh yes I remember this. Didn't you get some brutal feedback on Reddit? :P
12:50:05 <bitemyapp> MitchellSalad: you were a good sport about it, IIRC
12:50:25 * hackagebot data-variant 0.28.0.4 - A variant data type, useful for modeling dynamically-typed programming languages  http://hackage.haskell.org/package/data-variant-0.28.0.4 (TobiasDammers)
12:50:27 * hackagebot hpaco-lib 0.28.0.4 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.28.0.4 (TobiasDammers)
12:50:28 <MitchellSalad> i got brutal feedback from you, :P
12:50:29 * hackagebot hpaco 0.28.0.4 - Modular template compiler  http://hackage.haskell.org/package/hpaco-0.28.0.4 (TobiasDammers)
12:50:31 * hackagebot clckwrks-plugin-page 0.3.5 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.3.5 (JeremyShaw)
12:50:45 <bitemyapp> MitchellSalad: that could work, but I'm going to keep maintaining the dialogues.md archive. Would links from your thing to dialogues.md sections work?
12:50:46 <chrisdone> reddit doesn't give feedback, they feed upon people's backs
12:50:56 <bitemyapp> chrisdone: fishing knife and a bag of salt.
12:51:18 * bitemyapp scribbles note to steal from dohaskell
12:52:16 <MitchellSalad> lol, go for it. i think linking to dialogues.md might be okay i guess... you would have to include the # anchor in the URL so you don't get duplicates. i think overall a better solution would be to support uploading snippets directly, but i'm not sure
12:52:27 <bitemyapp> MitchellSalad: that's the intent, yes. Using the # anchor.
12:52:39 <bitemyapp> MitchellSalad: the dialogues could use a little more visibility. I'm considering inlining the specific dialogues into the sections of the learnhaskell guide with anchored links.
12:55:25 * hackagebot hsimport 0.5 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.5 (DanielTrstenjak)
12:55:27 * hackagebot configuration-tools 0.2.3 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.2.3 (larsk)
13:05:27 * hackagebot seacat 1.0.0.2 - Small web framework using Warp and WAI  http://hackage.haskell.org/package/seacat-1.0.0.2 (barrucadu)
13:05:29 * hackagebot clckwrks 0.22.3 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.22.3 (JeremyShaw)
13:06:09 <beaky> how do i analyze a haskell project
13:06:47 <nisstyre> beaky: in what way do you want to analyze it?
13:07:03 <nisstyre> lines of code? use of certain constructs?
13:07:30 <nisstyre> GHC does quite a bit of analysis already, you can even make it spit out the minimal set of imports which I didn't know until recently
13:08:55 <allsystemsarego> nisstyre, how?
13:09:18 <allsystemsarego> the minimal set of imports I mean
13:09:47 <nisstyre> allsystemsarego: -ddump-minimal-imports
13:09:58 <nisstyre> it will write them all out to files for each module
13:10:03 <allsystemsarego> I'll try it
13:10:28 * hackagebot seacat 1.0.0.3 - Small web framework using Warp and WAI  http://hackage.haskell.org/package/seacat-1.0.0.3 (barrucadu)
13:10:35 <dfeuer> nisstyre, so that gets you nice  import Foo (bar,baz,quux)  when you just give it  import Foo?
13:10:40 <nisstyre> yeah
13:10:42 <dfeuer> Nice.
13:15:29 * hackagebot aur 2.0.1 - Access metadata from the Arch Linux User Repository.  http://hackage.haskell.org/package/aur-2.0.1 (fosskers)
13:16:00 <trap_exit> what is so bad about "nick change on away" ? (see topic of #haskell-blah)
13:16:17 <sclv> ask on haskell-blah
13:18:30 <brisbin> trap_exit: in general people don't need or want to see your comings and goings
13:19:01 <tdammers> besides, there's already /AWAY for that
13:19:29 <trap_exit|unders> damn it, topo short for |understood
13:19:41 <kuyatzu> trap_exit: http://bisqwit.iki.fi/jutut/away.html
13:21:00 <trap_exit> ah, /away and /whois were builtin to solve this problem
13:21:12 <trap_exit> and dumbasses (people) come up with all these crazy other ways to over-share
13:21:20 * tdammers nods
13:21:23 <kuyatzu> yes
13:21:27 <beaky> hello
13:21:31 <trap_exit> away nicks = facebook selfies of the past
13:21:33 <trap_exit> okay, back to haskell :-)
13:22:05 <rien> I need to transform some Json structure into another Json structure of different shape. I'm looking for pointers on how to do that functionally.
13:22:11 <trap_exit> so is writing my own monad transformer O(n) work ... since I now have to be able to lift it to all other transformers ?
13:22:29 <beaky> how do i implement global shared mutable state in haskell
13:22:40 <beaky> e.g. in a Globals module
13:22:56 <beaky> maybe an IORef? :D
13:23:00 <rien> Basically I want to build a function transform that takes inputJson and transformerJson (that holds a map of origin paths to destination paths, or something like that) and does the transformation accordingly
13:23:08 <dmj`> beaky: IORef, MVar, TVar, etc. Create it in main, then pass it
13:23:49 <stolaruk> beaky: State monad with lenses is nice
13:23:53 <beaky> ah passing it
13:23:57 <dmj`> trap_exit: if you look at the source of mtl, there are typeclasses that do some of the lifting for you
13:23:59 <beaky> what is a lenses
13:24:02 <rien> In other words, what is the functional way to transform a tree into another tree?
13:24:16 <dmj`> trap_exit: https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-State-Class.html#get
13:24:21 <josephle> beaky: you could also use State monad without lenses
13:24:22 <beaky> rien: fmap i think
13:24:24 <stolaruk> beaky: magical getters and setters
13:24:52 <trap_exit> dmj`: noted, thanks!
13:24:54 <beaky> json is a functor
13:25:22 <edwardk> rien: you can look into tree transducers, hylopmorphisms, etc. there are several ways
13:25:31 <edwardk> er hylomorphisms
13:25:37 <dreams> Can someone help, this is the problem: http://lpaste.net/108521
13:26:28 <dmj`> dreams: what is the error
13:26:35 <rien> edwardk: yes I'm looking for a function that is a hylomorphism, precisely. a tree rewriter.
13:27:00 <mietek> @pl flip evalStateT
13:27:01 <lambdabot> flip evalStateT
13:27:11 <mietek> @type evalStateT
13:27:12 <lambdabot> Monad m => StateT s m a -> s -> m a
13:27:27 <mietek> @hoogle Monad m => s -> StateT s m a -> m a
13:27:28 <lambdabot> Control.Monad.Trans.State.Lazy evalStateT :: Monad m => StateT s m a -> s -> m a
13:27:29 <lambdabot> Control.Monad.Trans.State.Strict evalStateT :: Monad m => StateT s m a -> s -> m a
13:27:29 <lambdabot> Control.Monad.State.Lazy evalStateT :: Monad m => StateT s m a -> s -> m a
13:27:58 <rien> edwardk: tree transducers seem to be a new thing only available in papers right now?
13:28:07 <dreams> dmj`: I just updated it with the error: http://lpaste.net/108521
13:28:09 <edwardk> rien: pretty much
13:28:25 <edwardk> the recursion-schemes package provides hylo, cata, ana, etc. which can be used depending on what you want to do
13:28:40 <dreams> dmj`: the whole file has just one line which is in the pastebin.
13:28:41 <rien> edwardk: do you know of anything currently being used to transform Json? my problem is that I don't know how to handle the fact that Json has arrays, and it's very tricky to correctly transform nested arrays of hashes of arrays of hashes...
13:29:10 <rien> edwardk: or maybe a "dumber" way than transducers? (and hopefully easier to grasp)
13:29:33 <rien> I have 0 intuition for how to do tree rewrites in a functional way, and the fact that Json also has arrays makes it one level more difficult for me
13:29:46 <edwardk> rien: for that i usually just use Data.Aeson.Lens
13:30:07 <edwardk> and walk down with prisms and traversals to the right parts and do the swapping and rewrites i want
13:30:54 <edwardk> e.g. there is a Plated instance for Aeson's Value type
13:31:09 <rien> edwardk: can you clarify what the metaphor is that Data.Aeson.Lens uses? is the metaphor changing the nodes in place, or an actual anamorphism outside the original structure?
13:32:15 <edwardk> its a different metaphor entirely. lens is about composable combinators for getting into and other composable combinators for manipulating parts of a structure, there are combinators to make the other combinators with with Aeson
13:32:32 <gsingh93> is there a better way to write the part of this code that tries to insert two elements into a set: http://pastebin.com/kArTdivr
13:32:36 <gsingh93> it's kind of ugly
13:33:22 <rien> edwardk: Ok. I'm very curious to learn it. Can I show you an input and an output I want and you tell me if Data.Aeson.Lens can help me with it?
13:33:47 <jle`> solidus-river: you can just ask it :) i can scroll back
13:33:49 <Yuu-chan> Hello guys! I'm trying to express a particular problem and feel I need some type system extension, but unsure what to choose.
13:33:55 <mmmm_> gsingh93: foldr insert set [items]
13:34:02 <jle`> did you see the gist i posted to you earlier?
13:34:16 <deaddork> Quick question about GHC: if there’s a let expression in a recursive function, will it be evaluated every recursion, or is the compiler smart enough to only evaluate it once? Here’s an example: http://lpaste.net/108524
13:34:23 <int-e> gsingh93: using `Set.insert` may help a bit, but not much: (n `div` factor) `Set.insert` factor `Set.insert` set
13:35:21 <zmbmartin> I am not sure I understand how to work with JSON in haskell yet. I am using rethinkDB and they have there own JSON type I believe. https://gist.github.com/codedmart/c35b77c281b2ab398555
13:35:43 <mietek> uh
13:35:45 <Yuu-chan> I'm writing an imperative monadic eDSL. I have simple variables like "x", and want to use them in arithmetic expressions: "x + 5". I also want assignments: "x .= y + 5"... and then get confused with types.
13:35:53 <mietek> Since when does the order of definitions in a Haskell file matter?!
13:36:02 <benzrf> Yuu-chan: why are you doing this?
13:36:16 <int-e> mietek: it does when using template haskell.
13:36:17 <zmbmartin> I would like to change the rethinkdb JSON to aeson JSON as that seems more widely used.
13:36:20 <mietek> ohhh.
13:36:22 <int-e> mietek: otherwise it should not
13:36:24 <zmbmartin> Or do I have this all wrong?
13:36:33 <mietek> That's really silly.
13:36:35 <jle`> declaration syntax has some weird implied ordering to the lines
13:36:37 <solidus-river> jle`: neg, i didn't it might have been while i was traveling from work to home
13:36:43 <rien> edwardk: https://gist.github.com/canpeter/854f5a14bfd770324acd
13:36:43 <mietek> Yeah, it's TH
13:36:47 <Yuu-chan> benzrf: inspired by http://wall.org/~lewis/2013/10/15/asm-monad.html and the last ICFPC
13:36:56 <rien> edwardk: the input is pathological
13:37:01 <mietek> Is this a fundamental requirement?
13:37:10 <benzrf> deaddork: i wouldnt count on it optimizing that
13:37:15 <dfeuer> deaddork, it depends.
13:37:19 <benzrf> deaddork: but why are you passing it along anyway?
13:37:55 <solidus-river> jle`: do you still have the paste around?
13:38:16 <jle`> solidus-river: https://gist.github.com/mstksg/278c43f4a825af9523a0
13:38:24 <jle`> doesn't have anything to do with composition though
13:38:35 <deaddork> @benzrf is there a better way? I’m just starting out…
13:38:36 <lambdabot> Unknown command, try @list
13:38:37 <jle`> in the actual composition process, the dt is hidden away and you can't access it
13:39:14 <edwardk> rien: let me give an example
13:39:21 <spott> deaddork: you should be able to refactor that code to only be recursive in n and gen with a "where" clause...
13:39:22 <edwardk> > "[1,2,3,{\"foo\":[4,5]}]" & _Value..._Integer +~ 1
13:39:23 <lambdabot>  "[2,3,4,{\"foo\":[4,5]}]"
13:39:33 <solidus-river> jle`: my question is about arrow notation and netwire 5 and the s parameter, it looks like your post might solve this though
13:39:45 <Yuu-chan> Well, then! I tried several options. The first one was to have a simple ADT for expressions, and Num instance for it, but I lose the compile-time checking if the assignment is valid (there must be only a plain variable in lvalue)
13:39:46 <jle`> ah ok :)
13:39:55 <solidus-river> jle`: i didn't get how to do arrow notation with wires taht had to be stepped, alll the examples use pure wires
13:39:58 <edwardk> interesting, i'd have expected that to work under the foo
13:40:02 <deaddork> spott: I don’t follow…
13:40:14 <jle`> the examples in my paste are pure wires too
13:40:23 <jle`> wlel, they have internal state
13:40:30 <rien> edwardk: I don't see how that example helps me since you seem to know what value you're looking for. I'm only looking to transpose values from certain leaf-places onto other leaf-places with possibly different names.
13:40:32 <dfeuer> deaddork, I think you could likely make it optimize that using -fstatic-args, but that's probably not the way. More importantly, perhaps, xs shouldn't be a list.
13:40:36 <jle`> i guess i'm not totally sure what you mean
13:40:41 <solidus-river> jle`: so my question is what if one of the wires sho is using also needs to be stepped?
13:40:59 <int-e> mietek: it's pretty much a functional requirement, because template haskell splices can look up identifiers from the current module.
13:41:16 <edwardk> rien: i was giving a "baby's first lens-aeson" intro statement =)    the fact that it is plated letsyou use all the uniplate combinators on it, but that gets hairy
13:41:21 <solidus-river> jle`: i guess i dont understand how the s parameter in sho is getting passed around to integral etc
13:41:29 <dfeuer> deaddork, almost any time you find yourself writing !! with a Haskell list (aside from testing), you should think again.
13:41:31 <edwardk> e.g. in general you can use them to walk through syntax trees and swap out parts you don't like for others
13:41:37 <solidus-river> jle`: it looks like they are only getting the a parameter not s
13:41:53 <edwardk> rewrite (\case Neg (Lit a) -> Just $ Lit (-a); _ -> Nothing)
13:41:53 <mietek> int-e: to my mind, there would be a TH pass, then a separate Haskell pass
13:41:54 <jle`> during composition?
13:41:57 <jle`> yeah, that's the point
13:42:07 <edwardk> but for aeson the syntax tree is a bit uglier
13:42:09 <jle`> the s parameter is not accessible during composition
13:42:14 <Yuu-chan> Second was to have a separate type for variables, use MultiParamTypeClasses, and have class Expr a b where applyOp :: Operator -> a -> b -> Expr, and instances for all possible pairs of variables and compound expressions. Then the type inference breaks and cannot deduce Num instances.
13:42:16 <edwardk> > "[1,2,3,{\"foo\":[4,5]}]"^?_Value
13:42:17 <lambdabot>  Just (Array (fromList [Number 1.0,Number 2.0,Number 3.0,Object fromList [("f...
13:42:24 <mietek> int-e: then the second case is just regular Haskell
13:42:25 <solidus-river> jle`: interesting, so you cant compose two wires that need to be stepped?
13:42:33 <solidus-river> jle`: or by composition you turn them into one wire that needs to be stepped
13:42:33 <int-e> mietek: but then the TH pass won't know the haskell identifiers that are in scope.
13:42:40 <jle`> you compose wires to get wires
13:42:41 <edwardk> the combinators from lens let you get in there and manipulate the parts of that tree as you need to
13:42:59 <jle`> what do you mean by a wire that needs to be stepped?
13:43:14 <dfeuer> :type (^?)
13:43:15 <edwardk> you can use the plated machinery to rewrite whole trees, zippers to walk down with a current focus, stuff from the top level when you know the full path, Data.Data to do other fancy stuff, etc.
13:43:18 <mietek> int-e: OK, so first, a Haskell pass, leaving some identifiers type-holed, and populating a scope...
13:43:28 <mietek> int-e: then TH, with access to the scope, and then a final Haskell pass?
13:43:29 <mietek> :)
13:43:30 <dfeuer> @type (^?)
13:43:30 <jle`> solidus-river: wires compose to make wires, which compose to make wires.  you step the final composed wire
13:43:31 <lambdabot> s -> Getting (First a) s a -> Maybe a
13:43:32 <rien> edwardk: I understand and I appreciate that. :) It's practically impossible to find examples of Aeson usage specifically for changing the shape of a Json (so a Json -> Json function)
13:43:42 <int-e> mietek: note that once you have more than one has TH splice, this cannot be resolved, because you have to run the splices to find out what identifiers are being defined
13:43:43 <jle`> solidus-river: it's a bit kind of like a monoid kinda pattern, if that makes sense
13:43:53 <solidus-river> jle`: gettin an example, if orgot that i could just show you because my code is now on github
13:44:01 <mietek> Darn.
13:44:04 <int-e> mietek: you can get the effect you describe by putting the TH splices last in a module.
13:44:05 <jle`> wire + wire = wire
13:44:09 <Yuu-chan> The third was to use GADTs, and have a parameteric ADT for Expr, and it seems to be the most profound, but there are troubles with Num instances again... (if not to use the rebindable syntax)
13:44:12 <solidus-river> https://github.com/fuag15/functioninvaders/blob/master/src/NFInvaders/Simulation/Game.hs
13:44:36 <mietek> int-e: well, I actually have to put them first, before the stuff which references them
13:44:37 <solidus-river> jle`: ^ that wire will need to use subwires that are also statefull, but that second parameter to the wire is the s parameter, correct?
13:44:38 <mmmm_> Yuu-chan: Do you need the num instance?
13:44:44 <spott> deaddork: I'm actually with dfeuer here... selecting elements with !! of a list is really expensive
13:44:52 <rien> edwardk: do you see what I'm trying to do, from my gist link, though? I want to write a function that takes some input json and a dictionary from input-json-paths to output-json-paths (or the other way around, who cares) and gives me some output json in the new shape as per the dictionary
13:44:52 <solidus-river> jle`: i mean the first paramter, so what would that look like during composition
13:45:09 <jle`> all of the composed wires are given the same dt during composition
13:45:30 <solidus-river> jle`: so what would it look like if i wanted to compose more wires within that gameWire
13:45:31 <int-e> mietek: oh right. sorry. anyway, I'm sure there's room for improvement, but it's not easy.
13:45:37 <edwardk> rien: sure
13:45:47 <jle`> solidus-river: you can't compose wires inside a stepping function like that
13:45:51 <jle`> solidus-river: you can only compose wires with wires
13:45:51 <mmmm_> Yuu-chan: Try and do it first without overloading +
13:45:54 <rien> edwardk: "stuff from the top level when you know the full path" this is all I need frankly :) I have all the full paths for both sides.
13:46:03 <acowley> Has anyone here played around with the constraints package much?
13:46:11 <solidus-river> so the gameWire if defined this way cannot contain other wires?
13:46:14 <Yuu-chan> mmmm_: I'd deal with custom operators for arithmetics, but integer literals are must-have
13:46:20 <jle`> yeah
13:46:22 <rien> edwardk: could you point me in the right direction for that? maybe a link? I can barely find anything meaningful on Plates for instance.
13:46:39 <solidus-river> welllllll time to go back to the drawing board then
13:46:42 <jle`> without manually stepping them, which is sort of defeating the purpose of the arrow abstraction in the first place
13:46:56 <edwardk> rien: the main resource i can offer is the #haskell-lens channel, which is full of helpful people
13:47:05 <jle`> if you're making an application (and not the backend/framework) you probably don't need mkSF/mk functions
13:47:08 <solidus-river> jle`: if thats the case i dont see how to make this game loop without a stateT monad at the wire level
13:47:12 <spott> deaddork:  I'm sorry I don't understand the code enough to refactor it...
13:47:16 <spott> I'm still learning as well
13:47:30 <solidus-river> edwardk: that code base is the start of a framework type game engine
13:47:30 <jle`> solidus-river: do you see the example in the gist?
13:47:41 <jle`> solidus-river: it has state
13:47:42 <edwardk> anyways, storing paths as structures is something lens is kinda bad at. so there is a whole continuum of solutions here
13:47:45 <jle`> and it composes wires with state
13:47:56 <jle`> but it has an underlying Identity
13:47:57 <edwardk> solidus-river: which one?
13:48:07 <Yuu-chan> mmmm_: my very first variant of eDSL had custom converting functions (Var -> Expr, Int -> Expr would be an alternative), and that was a pain in the ass
13:48:17 <acowley> I have a type-level list of types that I use to pick out constraints which are applied somewhere else
13:48:18 <edwardk> oh, the link above
13:48:21 <rien> edwardk: I figured as much (re the continuum of solutions). that's why I question if that dictionary of paths as a parameter is even the right way to frame the problem.
13:48:29 <acowley> So for Ord, you might have data OrdToken
13:48:32 <solidus-river> edwardk: aye, its my attempt / exploration
13:48:34 <rien> edwardk: thanks for the channel recommendation, that's invaluable to me right now.
13:48:51 <edwardk> rien: 'd think of lens as a way to execute given the paths the queries you wanted
13:48:51 <jle`> solidus-river: did you see ocharles's examples?  they have game loops with state w/out ever writing explicit wires at the construction level
13:48:52 <acowley> then there's a type family with an instance for OrdToken such that it creates an Ord constraint for its second argument
13:48:53 <edwardk> that can be done
13:49:00 <solidus-river> jle`: aye, it uses the integral wire, interesting so i guess i need to reform my problem
13:49:08 <edwardk> and to be able to write back and graft into some output tree
13:49:10 <jle`> what components of state do you have?
13:49:27 <solidus-river> well the origonal idea was to have a wire that represents each actor int he game world
13:49:28 <mmmm_> Yuu-chan: I am interested in this problem
13:49:40 <solidus-river> that gets stepped with input and outputs a snapshot of that actor in a frame
13:49:44 <mmmm_> Yuu-chan: Which ICFP paper are you referring to?
13:49:45 <solidus-river> and thats statefull
13:49:46 <dfeuer> Does lambdabot know about Data.Vector?
13:50:00 <solidus-river> but i guess if i broke its state down into other composed wires i could make that not statefull
13:50:01 <jle`> solidus-river: you shouldn't think about the stepping process inside FRP
13:50:06 <rien> edwardk: that sounds *exactly* like what I need, and the anamorphism of building an output thing is more natural to me than thinking of it in terms of changes-in-place (because then I'd have to worry about the order of things)
13:50:06 <Yuu-chan> mmmm_: not the paper, but the contest that was in the last week
13:50:10 <jle`> your composed wires are all stateful
13:50:11 <dhj> Greetings from an early struggling Haskell user……trying to install mysql-simple or odbc to play around with databases from Haskell, failing miserably to get either of them installed.. Would appreciate some help if this is the right place.
13:50:28 <jle`> solidus-river: you should be thinking of how things are, not how they behave after they are stepped
13:50:31 <jle`> solidus-river: high-level views
13:50:37 <dfeuer> Yeah, I wish I knew what an anamorphism was, or a wire.
13:50:39 <jle`> "this value is the time integral of this value"
13:50:42 <dfeuer> Or a lens.
13:50:44 <int-e> dfeuer: nope.
13:50:49 <dfeuer> Hmph.
13:50:56 <jle`> not "at every step, add the value of this value to this value"
13:51:04 <jle`> the "idea" of a step disappears in FRP
13:51:06 <MitchellSalad> dhj: have you tried installing them in a cabal sandbox?
13:51:07 <solidus-river> jle`: well, ok, so what about values that need to be composed, i ultimately need a wire that produces a Invader actor
13:51:09 <jle`> it's not even supposed to make sense
13:51:37 <jle`> solidus-river: what are the parts of our invader actor?
13:51:38 <conal> jle`: thx! :) amen. down with abstraction leaks.
13:51:51 <solidus-river> jle`: it has health and position
13:51:52 <jle`> conal: :)
13:51:59 <jle`> solidus-river: what are its health and position determined by?
13:52:02 <rien> dfeuer: anamorphism is building a structure up from a seed structure. catamorphism is the opposite, takind down a structure and accumulating some other structure in the process. this is a very rough explanation from a non-Phd :)
13:52:05 <jle`> what are the inputs to the wire?
13:52:20 <jle`> health is probably the accumulated value of all the damage events
13:52:27 <solidus-river> jle`: hmm, i guess i see whhat your getting at but ultimately these things will have to be put into an actual instance of Invader so that things can be done like hit / collision checks
13:52:35 <edwardk> dfeuer: you know unfoldr?
13:52:43 <jle`> solidus-river: what is the input of your invader wire
13:52:45 <solidus-river> jle`: it doesnt make sense to do a collision check against a position and health, you need to do it against an invader
13:52:47 <edwardk> dfeuer: then you know one example of an anamorphism.
13:52:48 <jle`> what does it need to know about the outside world?
13:53:01 <edwardk> dfeuer: you know foldr? then you know one exaple of a catamorphism
13:53:01 <jle`> in order to produce the health and position?
13:53:03 <int-e> dfeuer: anamorphism = unfold; catamorphism = fold, for general free algebras.
13:53:09 <jle`> actually i'm not even sure that it needs to return a position
13:53:18 <solidus-river> jle`: ultimately i want the input to the invader wire to be (Set Key, Bullets, Player)
13:53:21 <rien> dfeuer: and ana + cata = hylo :)
13:53:21 <Yuu-chan> mmmm_: I wrote a very simple eDSL which generated an assembler code from a monadic action, but it was too inferior, and now I'd want to completely improve it (and to abuse the Haskell syntax over the top)
13:53:26 <edwardk> replace list with some other structure and you get the general concept
13:53:29 <jle`> solidus-river: why does the invader need to know about the input keys?
13:53:39 <solidus-river> oh, sorry, i'm thinking of the player wire
13:53:49 <solidus-river> so it needs (Bullets) as input
13:54:00 <jle`> does it?
13:54:01 <solidus-river> so that it knows if there were any hits
13:54:05 <solidus-river> aye
13:54:10 <jle`> how about it just knows (Event Hit)
13:54:11 <solidus-river> otherwise health cant be determined
13:54:12 <jle`> if it was hit
13:54:36 <jle`> invader :: Wire s e m (Event Hit) (Maybe Position)
13:54:38 <dfeuer> edwardk, yeah, I know those.
13:54:46 <rien> conal: I am almost comfortable with Elm's "frp". I want to learn proper FRP. Should I learn Yampa? What's the go-to FRP library for Haskell that does things the way you defined them?
13:54:50 <dfeuer> But I don't know what an algebra is, let alone a free algebra.
13:54:59 <solidus-river> well it would also need
13:55:03 <jle`> or maybe invader :: Wire s e m (Event Hit) Position
13:55:06 <jle`> because netwire wires inhibit
13:55:14 <solidus-river> invader :: Wire s e m (Event Hit) (Maybe Position, Maybe Bullet)
13:55:18 <solidus-river> so it can shoot
13:55:19 <mietek> Is there a lens operator for "Use"?
13:55:22 <mietek> er
13:55:25 <mietek> "use"
13:55:28 <mmmm_> Yuu-chan: I understand, can you paste what you have already? Not sure I'll be able to help much but I'm interested
13:55:31 <jle`> sounds like a shooting event
13:55:37 <jle`> why Maybe Bullet?
13:55:38 <conal> rien: i don't know of a go-to FRP library consistent with the fundamentals (denotative & continuous time). sorry. :/
13:55:44 <jle`> is Bullet a continuous time-varying thing?
13:55:51 <solidus-river> invader :: Wire s e m (Event Hit) (Maybe Position, Maybe Event ShotFired)
13:55:56 <solidus-river> jle`: like that?
13:55:58 <jle`> why Maybe?
13:56:00 <edwardk> mietek: its unary, how would it work?
13:56:05 <solidus-river> jle`: because it doesnt always shoot
13:56:09 <rien> conal: any best-so-far or personal favorites or recommendation in general? :)
13:56:13 <l0cust> jle`: Nice to see you again
13:56:43 <mietek> edwardk: Deep Magic to make <- unnecessary? I don't know. You're the magician :)
13:56:44 <jle`> it doesn't make sense to have (Maybe a) in this context, because behaviors are supposed to be continuous time-varying things, and you seem to be using it as a "blip"/discrete time thing
13:56:51 <jle`> rien: i might look into netwire :)
13:56:56 <jle`> solidus-river: how about this:
13:57:06 <solidus-river> jle`: so how do i represent somethign where part of its behavior is it might shoot
13:57:08 <jle`> inader :: Wire s e m (Event Hit) (Position, Event Shot)
13:57:15 <conal> rien: i wish, but i've not been paying enough attention to the various libraries to even recommend one. not helpful, i realize. hm.
13:57:25 <edwardk> mietek: there is <~ -- which kinda does that =)
13:57:27 <solidus-river> jle`: but what about if it doesnt shoot during the dt?
13:57:42 <edwardk> mietek: foo <~ bar  -- takes the lens foo and the lens bar and feeds the contents of bar into foo
13:57:43 <jle`> an Event is an event stream, containing discrete points
13:57:47 <jle`> discrete shots
13:57:55 <jle`> it doesn't have a shot at all times
13:58:03 <edwardk> mietek: that is kinda like what you asked for. but you need to tell it where to send it, so that is the first arg
13:58:06 <jle`> it's an event *stream*
13:58:21 <rien> conal: no problem. trust me you've been very helpful (papers, keynotes, ideas) :)
13:58:25 <mietek> @type (<~)
13:58:26 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
13:58:26 <jle`> so it's a time-dependent value that is either not occuring, or occuring (at a discrete time)
13:58:35 <mietek> @type set
13:58:35 <solidus-river> jle`: hmm, so how would i hook that event stream into another wire then?
13:58:36 <lambdabot> ASetter s t a b -> b -> s -> t
13:58:40 <conal> rien: :) .  thanks.
13:58:44 <jle`> solidus-river: the same way you would any value
13:58:48 <solidus-river> jle`: i guess i havent seen any examples taht use netwires event system
13:58:50 <jle`> (Event Shot) is the strea
13:58:53 <jle`> is the stream
13:58:54 <mietek> Oh, I meant to say, I do enjoy how the type vars spell out "stab"
13:59:01 <jle`> you can feed it into anything else, like any other value
13:59:03 <mietek> Subtle, but effective
13:59:10 <solidus-river> jle`: and it will only do something if that event is new then?
13:59:11 <jle`> invader takes in an event stream, btw, if you didn't notice
13:59:17 <jle`> yeah
13:59:22 <solidus-river> jle`: how does it create a new bullet on an event if it will get that event every iteration
13:59:36 <jle`> invader takes an event stream, and outputs a continually varying position and another vent stream
13:59:42 <saraissima> !addd
13:59:44 <jle`> you can think of it as an event stream transformer, in that sense
13:59:52 <jle`> solidus-river: it doens't get the event every iteration
13:59:57 <jle`> you're thinkign about steps again
13:59:58 <jle`> let go of the steps
14:00:00 <solidus-river> well so how do things know when events change vs when they are the same, do they keep internal state?
14:00:01 <jle`> steps don't exist
14:00:03 <saraissima> !lista
14:00:04 <monochrom> saraissima: http://okmij.org/ftp
14:00:18 <jle`> you work with Events using Event combinators
14:00:25 <jle`> http://hackage.haskell.org/package/netwire-5.0.0/docs/Control-Wire-Event.html
14:00:32 * hackagebot data-variant 0.28.0.5 - A variant data type, useful for modeling dynamically-typed programming languages  http://hackage.haskell.org/package/data-variant-0.28.0.5 (TobiasDammers)
14:00:34 <jle`> here are wires that transform even tstreams
14:00:34 * hackagebot hpaco-lib 0.28.0.5 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.28.0.5 (TobiasDammers)
14:00:36 * hackagebot hpaco 0.28.0.5 - Modular template compiler  http://hackage.haskell.org/package/hpaco-0.28.0.5 (TobiasDammers)
14:00:37 <jle`> or generate event streams
14:00:55 <jle`> l0cust: hi!
14:01:19 <jle`> solidus-river: so your invader wire takes in a Hit event stream, and transforms it and outputs a position behavior and a Shoot even stream
14:01:44 <jle`> the first thing you're going to do is use the Event's Functor instance
14:01:53 <Yuu-chan> mmmm_: sure, give me few minutes to organize all my drafts
14:01:54 <jle`> to turn an Event Hit into an Event Double
14:02:07 <l0cust> jle`: how have you been?
14:02:13 <jle`> for example, if every Hit does 10 damage, i'd do (10 <$ hitEvent)
14:02:23 <jle`> or (10 <$ hitEventStream)
14:02:33 <solidus-river> jle`: ooooh, ok, i thought events were kinda not used in netwire for some reason
14:02:49 <jle`> if you had a function (f :: Hit -> Double), you'd do (f <$> hitEventStream), or (fmap f hitEventStream)
14:02:53 <jle`> solidus-river: no, events are a big deal in FRP :)
14:02:54 <solidus-river> so when it comes time to take all these event streams and things and turn them into an invader to render do i just instantiate a new instance of invader
14:03:00 <solidus-river> or is there a way to keep an instance of it to mutate
14:03:19 <jle`> l0cust: i've been okay :) heading on vacation in a few days so doing a lot of packing
14:03:42 <jle`> solidus-river: you compose these things and you eventually have one invader, then you run your final composed wire
14:04:02 <jle`> solidus-river: so once you have an Event Double, an event stream of incoming damage events, how do you make a health value?
14:04:25 <zmbmartin> Anyone that can shed some light on how I can get this json working properly. https://gist.github.com/codedmart/c35b77c281b2ab398555 I am not sure what to do with a type of [Database.RethinkDB.NoClash.JSON]
14:04:26 <jle`> you need to transform your Event Double stream into a Double behavior
14:04:58 <jle`> that's what accumE is for
14:05:17 <jle`> accumE :: (b -> a -> b) -> b -> Wire s e m (Event a) (Event b)
14:05:30 <jle`> accumE (+) 0 will give you an event stream transformer
14:06:04 <jle`> you give it a stream of Event a's, and you get a stream of Event b's
14:06:26 <jle`> accumE (+) 0 will take a stream of Event Double's and output Event Double's...but each event will be the sum of all previously encountered events
14:06:29 <l0cust> jle`: Going anywhere interesting?
14:06:36 <jle`> l0cust: just around asia
14:06:49 <dfeuer> What happens when Data.Vector.unfoldr doesn't fuse?
14:06:56 <jle`> solidus-river: you can then use hold :: Wire s e m (Event a) a
14:07:06 <jle`> solidus-river: hold takes an Event a stream and turns it into an `a` behavior
14:07:29 <acowley> I'm going to try my question again, but I'll try to make it shorter
14:07:29 <jle`> where the `a` is the item contained by the last event that has been received
14:08:21 <jle`> so you can get a health by doing: (hold <|> 0) . (accumE (-) initialHealth) :: Wire s e m (Event Double) Double
14:08:34 <jle`> err that should be (hold <|> initialHealth)
14:08:38 <l0cust> jle`: I've never been east of Aleppo
14:09:13 <jle`> l0cust: anything coming up soon for you?
14:09:17 <l0cust> jle`: I should travel to asia one of these days
14:09:51 <jle`> solidus-river: that's after you turn your (Event Hit) into an (Event Double) of course
14:10:10 <dfeuer> I'm going to try my question again, but this time make it longer:  Data.Vector.unfoldr produces a vector whose length is not immediately known. If it fuses away, that's not a problem. If it doesn't fuse, and it has to actually make the vector, how does it do so?
14:10:18 <monochrom> w00t haskell platform rc3
14:10:30 <l0cust> jle`: Not really.
14:10:33 * hackagebot lens 3.10.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.10.3 (JohnWiegley)
14:10:42 <monochrom> and for the first time, linux bindist!
14:10:55 <jle`> solidus-river: (under the scenes, data Event a = NoEvent | Event a, so it's like a Maybe.  but.  this isn't supposed to be accessible from the event api, and it's an implementation detail that you sbouldn't interac wt with directly)
14:11:52 <jle`> the reason it's not an alias for Maybe is that its typeclass instances were carefully chosen to preserve FRP semantics
14:11:55 <jle`> Event semantics
14:12:13 <jle`> and also, being an opaque type without exported constructors, it forces you to use the combinators in Control.Wire.Event and Control.Wire.Interval etc.
14:12:29 <jle`> all of which are designed to preserve FRP event semantics
14:14:04 <jle`> when working with netwire there are two sort of worlds...the FRP world, and the implementation detail-mealy-machine world.  when you actually design your program/game/logic, you should always think in the FRP world
14:14:29 <jle`> the only time you are in the mealy world is at the interface between the game and the real world
14:15:02 <jle`> (real world as in, your backend or renderer or clock or something)
14:17:00 <acowley> Okay I can't write my question succinctly
14:24:43 <latk> How would you write ToRow / FromRow instances, in postgres-simple, for data Test = TestA | TestB ?
14:26:35 <octopuscabbage> hello, so i'm trying to do map read $ fmap words $ getLine
14:26:39 <octopuscabbage> what am i missing
14:26:57 <jle`> octopuscabbage: what do you expec it to do?
14:27:06 <ion> fmap words getLine :: IO …
14:27:09 <Exio> i'd guess the problem is at "getLine"
14:27:11 <ion> map read :: […] -> …
14:27:36 <octopuscabbage> I'm trying to get in a String, call words on it, and them read each of those strings
14:27:38 <Exio> uh, true :)
14:27:41 <jle`> 1. what is the type of getLine?
14:27:44 <jle`> 2. what is the type of fmap words?
14:27:48 <jle`> 3. what is the type of map read?
14:27:53 <octopuscabbage> 1. IO String
14:27:57 <Exio> map read is [a] -> [a]? not [a] -> a?
14:28:34 <octopuscabbage> 2. IO String -> IO [String]
14:28:36 <jle`> i suppose 2.5 should be "what is the type of fmap words getLine"
14:29:00 <octopuscabbage> IO [String] ?
14:29:09 <octopuscabbage> ahh i see now
14:29:12 <jle`> mhm
14:29:25 <octopuscabbage> and do i need to fmap map read too then?
14:29:33 <jle`> parentheses
14:29:46 <jle`> i also suggest you write it in compositional style to see something cool
14:29:58 <jle`> fmap (map read) . fmap words $ getLine
14:30:00 <ion> One of the fmap laws will be useful.
14:30:04 <ion> Functor laws
14:30:26 <jle`> look over the functor laws and see where you can make a very nice simplification :)
14:31:09 <octopuscabbage> oh i can just fmap the entire thing because associativity?
14:31:18 <ion> You’ll want to use readIO instead of read whenever in IO though. mapM readIO =<< fmap words getLine
14:33:23 <Yuu-chan> http://lpaste.net/108527
14:34:22 <octopuscabbage> it's giving me a no instance for Read b0
14:34:33 <octopuscabbage> i think it wants some sort of type annotation, how do i do that?
14:34:39 <solidus-river> jle`: sorry was pulled into helping debug somethin, we've got javascript calling into c++ calling back to javascript here.. tons of fun. reading the backscroll
14:34:48 <TheKing444> octo whoever, example
14:34:50 <Yuu-chan> mmmm_: if you are still here, please have a look
14:34:53 <TheKing444> > read "4"
14:34:55 <lambdabot>  *Exception: Prelude.read: no parse
14:35:02 <TheKing444> > read "4" :: Int
14:35:04 <lambdabot>  4
14:35:12 <mmmm_> yep
14:35:14 <mmmm_> Yuu-chan:
14:35:18 <TheKing444> You just put :: and then whatever the type should be.
14:35:31 <TheKing444> read works on a great many things, more than the fingers can count
14:35:35 * hackagebot monad-extras 0.5.9 - Extra utility functions for working with monads  http://hackage.haskell.org/package/monad-extras-0.5.9 (JohnWiegley)
14:35:37 * hackagebot github 0.9 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.9 (JohnWiegley)
14:36:04 <TheKing444> Haskell likes to know at compile time what type is choosen so it knows how to parse it.
14:36:23 <TheKing444> Usually it figures it out itself, but your code must have been ambigous.
14:37:20 <octopuscabbage> yeah well i already have two datatypes deriving read
14:37:39 <TheKing444> Then you must tell haskell which one you want to read.
14:37:44 <octopuscabbage> that's what i did
14:37:50 <octopuscabbage> and now it works
14:37:50 <octopuscabbage> yay
14:38:21 <solidus-river> jle`: cool, that makes a lot of sense actually so the only time i woudl ever actually want to create a new statefull wire is if i found some stateful wire behavior that was not already capable of being produced by composition of other wires
14:38:22 <TheKing444> Oh octopuscabbage
14:38:35 <solidus-river> jle`: and what your saying by saying i shouldn't be making statefull wires is that that is very unlikely to happen
14:38:36 <TheKing444> It looks like you may benefit from reading up on "Free Monads."
14:38:58 <TheKing444> It looks like your code could be simplified with them.
14:39:10 <jle`> remember that read is actually abstracting over a bunch of completely different "String -> X" functions; there's a String -> Int, a String -> Bool, a String -> Double...they're all separate functions, separately defined
14:39:29 <jle`> and so when haskell is compiled...it has to know which one to compile
14:39:36 <TheKing444> And it would be quite inefficient and buggy to try them one after the other.
14:39:41 <jle`> it can't just compile one funciton that works for everything
14:39:47 <TheKing444> That is for sure.
14:39:50 <jle`> solidus-river: yeah, it's actually pretty rare to make one from scratch
14:40:16 <jle`> solidus-river: and that's good, because making one from scratch opens you up to leaking the abstraction
14:40:31 <jle`> solidus-river: all of the combinators and wires provided by the library are designed to never leak the abstraction
14:40:36 * hackagebot simple-conduit 0.5.1 - A simple streaming I/O library based on monadic folds  http://hackage.haskell.org/package/simple-conduit-0.5.1 (JohnWiegley)
14:40:38 * hackagebot taskpool 0.0.4 - Manage pools of possibly interdependent tasks using STM and async  http://hackage.haskell.org/package/taskpool-0.0.4 (JohnWiegley)
14:40:58 <jle`> i've made a couple in the past, but i've had to be very careful
14:40:58 <mmmm_> Yuu-chan: Where is compiler defined?
14:41:13 <dzhus> do you think it's a good idea to make fromString instance non-total?
14:41:43 <jle`> :/
14:41:52 <josephle> > read "4" :: Maybe Int
14:41:54 <lambdabot>  *Exception: Prelude.read: no parse
14:41:59 <dfeuer> dzhus, you're talking about IsString?
14:42:06 <dzhus> dfeuer: yep
14:42:11 <TheKing444> read "Just 4" :: Maybe Int
14:42:13 <nisstyre> > read "Just 4" :: Maybe Int
14:42:15 <lambdabot>  Just 4
14:42:23 <jle`> aw you defined it before i could.
14:42:27 <jle`> > Just 4 + Just 10
14:42:29 <lambdabot>  No instance for (GHC.Show.Show a0)
14:42:29 <lambdabot>    arising from a use of ‘M408978845009174949823295.show_M4089788450091749498...
14:42:29 <lambdabot>  The type variable ‘a0’ is ambiguous
14:42:29 <lambdabot>  Note: there are several potential instances:
14:42:29 <lambdabot>    instance [safe] GHC.Show.Show
14:42:37 <josephle> just wanted to know what happens if you do an improper read
14:42:38 <nisstyre> > just 4 `mappend` Just 5
14:42:39 <jle`> oh wait
14:42:40 <lambdabot>  Not in scope: ‘just’
14:42:46 <nisstyre> > Just 4 `mappend` Just 5
14:42:46 <josephle> > Just 4 <> Just 5
14:42:47 <lambdabot>  No instance for (GHC.Show.Show a0)
14:42:48 <lambdabot>    arising from a use of ‘M499925754902857867223329.show_M4999257549028578672...
14:42:48 <lambdabot>  The type variable ‘a0’ is ambiguous
14:42:48 <lambdabot>  Note: there are several potential instances:
14:42:48 <lambdabot>    instance [safe] GHC.Show.Show
14:42:49 <lambdabot>  No instance for (GHC.Show.Show a0)
14:42:50 <Yuu-chan> mmmm_: I omitted the implementation, I can provide the full code if needed
14:42:51 <lambdabot>    arising from a use of ‘M605718753401823676423341.show_M6057187534018236764...
14:42:53 <lambdabot>  The type variable ‘a0’ is ambiguous
14:42:55 <lambdabot>  Note: there are several potential instances:
14:42:56 <nisstyre> oh right
14:42:57 <lambdabot>    instance [safe] GHC.Show.Show
14:42:59 <nisstyre> no Monoid instance
14:43:06 <josephle> huh
14:43:08 <nisstyre> > Just $ Sum 4 `mappend` Just $ Sum 5
14:43:09 <lambdabot>  Couldn't match expected type ‘Data.Monoid.Sum a2 -> s’
14:43:09 <lambdabot>              with actual type ‘Data.Monoid.Sum a0’Couldn't match expected typ...
14:43:10 <lambdabot>              with actual type ‘a1 -> Data.Maybe.Maybe a1’
14:43:13 <nisstyre> bah
14:43:38 <pavonia> > Just 4 <> Just 5 :: Maybe Int
14:43:39 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Int)
14:43:40 <lambdabot>    arising from a use of ‘Data.Monoid.<>’
14:43:49 <jle`> @let instance Num a => Maybe a where (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*); negate = liftA negate; abs = liftA abs; signum = liftA signum; fromInteger = pure . fromInteger
14:43:50 <lambdabot>  .L.hs:151:9: ‘+’ is not a (visible) method of class ‘Maybe’
14:43:51 <lambdabot>  
14:43:51 <lambdabot>  .L.hs:152:9: ‘-’ is not a (visible) method of class ‘Maybe’
14:43:51 <lambdabot>  
14:43:51 <lambdabot>  .L.hs:153:9: ‘*’ is not a (visible) method of class ‘Maybe’
14:43:58 <nisstyre> > (Just $ Sum 4) `mappend` (Just $ Sum 5)
14:44:00 <lambdabot>  Just (Sum {getSum = 9})
14:44:00 <jle`> @let instance Num a => Num (Maybe a) where (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*); negate = liftA negate; abs = liftA abs; signum = liftA signum; fromInteger = pure . fromInteger
14:44:03 <lambdabot>  Defined.
14:44:04 <josephle> > (Just $ Sum 4) <> (Just $ Sum 5)
14:44:06 <lambdabot>  Just (Sum {getSum = 9})
14:44:07 <jle`> > Just 4 + Just 9
14:44:09 <lambdabot>  Just 13
14:44:20 <jle`> 4 * Just 6
14:44:24 <jle`> > 4 * Just 6
14:44:26 <lambdabot>  Just 24
14:44:43 <josephle> > 4 * Nothing
14:44:43 <jle`> Just (Just 5) - Just 2 + 10
14:44:44 <lambdabot>  Nothing
14:44:46 <jle`> > Just (Just 5) - Just 2 + 10
14:44:49 <lambdabot>  Just (Just 13)
14:45:15 <lpsmith> latk, are you sure you want ToRow/FromRow instances for your sum type,  or ToField/FromField?   The latter seems more plausible to me...
14:45:26 <dfeuer> I'm still trying to figure out how Data.Vector.unstream behaves when it doesn't fuse.
14:45:33 <TheKing444> New question on stack overflow: http://stackoverflow.com/q/25069434/1172541
14:46:40 <dzhus> I'm sorry but that nickname is just trolling in this context
14:47:03 <mmmm_> Yuu-chan: Can you send me compiler so I can have a play with it :P
14:47:26 <MP2E> dzhus : The PyRulez guy on stackoverflow?
14:47:30 <dzhus> yup
14:47:31 <MP2E> I got a bit of a chuckle :P
14:48:11 <solidus-river> jle`: thanks again for your help with netwire :)
14:48:27 <geekosaur> on the other hand that question does get asked a lot, because people do not understand that cabal cannot install C bits
14:48:44 <jle`> solidus-river: np! thanks for reminding me again to do a netwire writeup
14:50:15 <solidus-river> jle`: heh
14:50:18 <chirpsalot> I wish it was a little more obvious when cabal failed due to missing external dependencies.
14:50:34 <chirpsalot> I guess this "configure: error: curses headers could not be found, so this package cannot be built
14:50:39 <chirpsalot> Is pretty obvious.
14:50:46 <johnw> chrisdotcode: hiya
14:51:56 <Twey> jle`: Please do a Netwire write-up =(
14:55:37 * hackagebot luthor 0.0.0 - Tools for lexing and utilizing lexemes that integrate with Parsec.  http://hackage.haskell.org/package/luthor-0.0.0 (ZankokuOkuno)
14:57:21 <Yuu-chan> mmmm_: https://bitbucket.org/fpclub/fp-ghc/src/5973953aab05dc64e6e5ec9b53b0b039561fc96d/Compiler.hs?at=new , but it's currently a mess
14:57:50 <Yuu-chan> At the master branch you can find the old and ugly working implementation
14:58:31 <mmmm_> How did you find the competition?
14:58:44 <ion> tommd: Alright, thanks for information!
14:58:45 <chrisdotcode> johnw: hey there! I'll be around later, but I've got to go right now
14:59:04 <ion> tommd++
14:59:29 <tommd> ion: np
14:59:46 <octopuscabbage> how do i converet a Num to it's Char representation
14:59:55 <octopuscabbage> I want a function that turns 1 into "1"
15:00:00 <enthropy> > show 1
15:00:01 <lambdabot>  "1"
15:00:04 <octopuscabbage> err sorry
15:00:07 <octopuscabbage> 1 to '1'
15:00:18 <octopuscabbage> >:t take 1 show 1
15:00:24 <octopuscabbage> > :t take 1 show 1
15:00:25 <lambdabot>  <hint>:1:1: parse error on input ‘:’
15:00:26 <enthropy> @hoogle intToDigit
15:00:28 <lambdabot> Data.Char intToDigit :: Int -> Char
15:00:31 <augur> > take 1 (show 1)
15:00:33 <lambdabot>  "1"
15:00:38 <octopuscabbage> intToDigit 1
15:00:41 <augur> octopuscabbage: :t asks for a type
15:00:43 <octopuscabbage> > intToDigit 1
15:00:44 <lambdabot>  '1'
15:00:51 <Yuu-chan> mmmm_: from amazing reports of Adept (Dmitry Astapov) :)
15:01:59 <merijn> augur: Don't you mean "head (show 1)"?
15:02:19 <augur> merijn: yes, i was about to type that but then octopuscabbage found intToDigit :P
15:02:46 <merijn> > intToDigit 500
15:02:48 <lambdabot>  *Exception: Char.intToDigit: not a digit 500
15:03:00 <merijn> > intToDigit 0xA
15:03:02 <lambdabot>  'a'
15:03:05 <zmbmartin> does aeson Value mean the data constructor that I made like data User <- is that a aeson Value?
15:03:06 <octopuscabbage> why is 500 not a digit
15:03:28 <dmwit> 500 has three digits
15:04:04 <dmwit> Or, if you prefer the snarky answer: why is this question not a word?
15:05:21 <enthropy> > toEnum (500 + fromEnum '0') :: Char
15:05:23 <lambdabot>  '\548'
15:07:30 <enthropy> if I'm ffi'ing to some c++ code, it's safe to cast a c++ object to a pointer so I can pass it around haskell-land as Ptr ()?
15:08:10 <merijn> enthropy: As safe as it'd be to do the same in C
15:08:44 <spott> is the ffi for haskell able to handle c++? (including templates, classes, inheritance, etc...)
15:08:45 <enthropy> so it's better to pass a pointer to that object around instead?
15:08:53 <enthropy> spott: no
15:09:09 <spott> I didn't think so...
15:09:23 <Yuu-chan> spott: all of that disappears after compiling
15:09:33 <merijn> spott: The usual approach (as always) is to go via C
15:09:43 <Yuu-chan> spott: the real problem is name mangling, but there is extern "C"
15:09:49 <spott> Yuu-chan: the ABI for C++ is different from C
15:10:02 <merijn> spott: There's nothing conceptually stopping anyone from implementing a C++ FFI, but why bother if you already have C
15:10:45 <spott> merijn: conceptually, no... but it essentially requires being able to parse C++ which noone does
15:11:27 <merijn> spott: Exactly :p
15:11:53 <spott> you got me all excited that haskell had done that...
15:11:55 <spott> :(
15:11:59 <spott> :P
15:12:25 <enthropy> there are tools like say http://hackage.haskell.org/package/fficxx
15:12:42 <Tekmo> merijn: I'm back.  Were you able to make progress with moving `ReaderT` outside of the `Proxy` type?
15:13:57 <Yuu-chan> Could anyone provide an advice to my typing problem? http://lpaste.net/108527
15:15:18 <merijn> Tekmo: I had a busy day, so I just started with that
15:15:29 <Tekmo> merijn: Alright
15:15:56 <luite> enthropy: yeah that approach makes it quite convenient, i stoled it for ghcjs with https://github.com/ghcjs/ghcjs-ffiqq
15:16:47 <schell> do you guys have any ideas about what’s driving the current spick in haskell on google trends? http://www.google.com/trends/explore#q=%2Fm%2F03j_q&cmpt=q
15:16:56 <schell> spike!***
15:17:02 <MP2E> lol]
15:17:17 <schell> haha
15:17:52 <Tekmo> schell: Haskell's awesomeness, obviously :)
15:18:04 <luite> oh i never released that the trend was mosly downwards :(
15:18:16 <schell> :) - there was a convention last weekend, right?
15:18:26 <kini> it's particularly strong in the US, apparently
15:18:37 <schell> luite: yes, it’s interesting - almost all langs are declining since 2005
15:18:45 <schell> checkout Lisp, Java, C
15:19:30 <schell> i suspect there’s some bias though
15:19:48 <schell> maybe to do with the way google measures these things - i’m guessing google trends started around 2005
15:20:09 <luite> ah java is much worse indeed, but then it deserves some of that for not making progress for years :)
15:20:11 <schell> no real clue though
15:21:52 <moghedrin> Newer languages are trending up though, so it could merely be that the market is more saturated now. More choices mean less people feel like they have to stick with Java, Lisp, C, etc.
15:21:53 <merijn> Tekmo: Looks like I can in fact move the ReaderT out, but at the cost of lifting everything everywhere, so I may just decide to manually thread SockConfig as function argument instead of using ReaderT...I'll finish this rewriting to see how the rest of the handshake works out
15:22:05 <Yuu-chan> luite: how could you say that! Now it even has lambdas!
15:22:39 <rudi_s> Hi. Is there a shorter/cleaner way to set file permissions than setFileMode from System.Posix.Files? setFileMode p (ownerReadMode `unionFileModes` ownerWriteMode) is quite long compared to chmod 0600.
15:22:48 <Tekmo> merijn: You can also use `distribute` to lift the `ReaderT` out
15:22:56 <orion> In a large Haskell library, if you have a top level interface, should you re-export the carefully chosen imports, or should you write an intermediate function which passes data, as seen here?: https://github.com/thoughtpolice/hs-nacl/blob/master/src/Crypto/NaCl.hs
15:23:04 <Tekmo> merijn: distribute :: Proxy ... (ReaderT i m) r -> ReaderT i (Proxy ... m) r
15:23:16 <Tekmo> merijn: It's in Pipes.Lift
15:23:29 <Tekmo> merijn: It's less efficient, but if you don't care about efficiency then it's easy to use
15:24:08 <Tekmo> merijn: There's also Pipes.Lift.runReaderP, too
15:24:14 <merijn> Tekmo: Efficiency is kind of an issue here, but I dunno how much other than "faster is better"
15:24:14 <luite> Yuu-chan: yeah they're moving again now, but i took them very long
15:24:21 <luite> it
15:24:33 <merijn> Tekmo: Yeah, but the problem is that having it in the inner forces the "rest" Producer to also have it
15:25:02 <schell> moghedrin: that makes sense
15:25:16 <moghedrin> schell: I thought so, too XD
15:26:01 <schell> but what about the increase in people interested in programming in general? Are there more or less minds to share?
15:27:15 <schell> moghedrin: seems that is down as well - http://www.google.com/trends/explore#q=programming%2C%20%2Fm%2F01mf_&cmpt=q
15:27:37 <schell> okay i’ll stop, i feel like i’m off topicking
15:28:02 <josephle> you can always continue in #haskell-blah if you want
15:28:19 <schell> josephle: good call :)
15:28:26 <moghedrin> Sorry XD
15:29:53 <merijn> Tekmo: Right, so right now I have "type M = Producer ByteString (SafeT IO)" and "StateT (Producer ByteString M r) M a", but I guess I wanna change that to be parametric in ByteString so my authentiction can use Frame for both? Although I don't think it's possible to modify the underlying M?
15:30:29 <enthropy> luite: might be interesting to compare with http://hackage.haskell.org/package/Rlang-QQ
15:32:06 <merijn> Tekmo: But that still leaves the issue that after the handshake I'll get a rest of the form "Producer ByteString M r", which I can't do anything with if I want to compose with "Consumer ByteString (SafeT IO) r", right?
15:33:45 <luite> enthropy: ah interesting. Rlang-QQ has a lot more features, mine is just an experiment so far and needs a proper implementation
15:34:26 <merijn> Tekmo: And the inner Producer can't yield anything anyway, but there is no way to get rid of it, I think
15:34:37 <Tekmo> merijn: Is `M` still `ReaderT SockConfig (SafeT IO)`?
15:34:56 <Tekmo> merijn: You shouldn't need an inner producer
15:35:20 <merijn> Tekmo: No, M is "Producer ByteString (SafeT IO)
15:36:41 <MitchellSalad> is there some clean way to apply <>'s between applicatives, like: pure (\a b c d -> a <> b <> c <> d) <*> fa <*> fb <*> fc <*> fd
15:36:59 <Tekmo> merijn: Why do you have a `Producer` layer inside the base monad of another `Producer`?
15:37:29 <Tekmo> merijn: I don't see anything like that in the code you e-mailed to the mailing list
15:37:32 <merijn> Tekmo: So, my handshake takes a Producer to consume input from, right? But during this parsing process I need to "yield" output to write back to the socket
15:38:00 <merijn> If you have a better suggestion than having a Producer base, I'm open
15:38:17 <merijn> Tekmo: I was just mimicing the original non-pipes-parse design
15:38:43 <enthropy> luite: plus2 x   = [js_| `x + $1 |] -- is a nice idea, I'll add it to my todo for Rlang-QQ
15:39:19 <Tekmo> merijn: The type you should get after `runStateT` is: Producer ByteString M r -> Producer ByteString M (a, Producer ByteString M r), where M is not a `Producer`
15:39:39 <Tekmo> merijn: What is the type you have before you call `runStateT`?
15:39:43 <merijn> :t runStateT
15:39:46 <lambdabot> StateT s m a -> s -> m (a, s)
15:40:01 <eikke__> there should be a 'pipes patterns' 'book' (covering basic pipes, pipes-parse, pipes-groups, pipes-binary and the lot, pipes-network, whatnot)
15:40:10 <Tekmo> eikke__: I'm working on this
15:40:15 <merijn> Tekmo: oh, wait, I think I made a booboo by mimicing your Parser synonym to directly
15:40:15 <eikke__> cool
15:40:38 <Tekmo> merijn: Yeah, the `Parser` synonym won't work for this
15:40:48 <Tekmo> merijn: You have to explicitly bypass it and define your own `StateT`
15:41:04 <merijn> Tekmo: Oh, I remember why
15:41:20 <luite> enthropy: i have some unpushed changes that change some of the types, js returns JSRef a => IO a, js' returns JSRef a -> a, js_ returns IO ()
15:41:22 <Tekmo> merijn: It should be: StateT (Producer ByteString M r) (Producer ByteString M) a
15:41:25 <eikke__> Tekmo: any stuff to proof-read or something alike already?
15:41:33 <merijn> Tekmo: All the pipes-binary and rest of the ecosystem all wants to return Parsers...
15:41:51 <merijn> Tekmo: So doing it that way means not being able to use any pipes-parse based libraries like that :\
15:41:52 <Tekmo> eikke__: The first step is I'm writing up a blog post cookbook for `pipes-group` and `foldl` idioms
15:41:59 <luite> enthropy: since i think a quasiquote cannot determine by itself what kind of return type is expected, is that right?
15:42:06 <Tekmo> eikke__: Let me see if I have it on this computer
15:42:38 <Tekmo> merijn: You can still use `pipes-parse` libraries
15:42:43 <enthropy> luite: well when the quasiquote gets run you could parse the file and typecheck it yourself...
15:42:45 <Tekmo> merijn: ... especially if you make it a lens like I suggested
15:43:01 <merijn> Tekmo: I mean for example: "decodeGet :: Monad m => Get a -> Parser ByteString m (Either DecodingError a)"
15:43:32 <enthropy> but realistically you don't know what type the quasiquote should have
15:43:41 <merijn> Which means rolling my own parsing versions of everything to work with my "non-Parser" StateT
15:43:45 <Tekmo> merijn: You can still use it
15:43:48 <Tekmo> merijn: Here's how
15:44:05 <Tekmo> merijn: Any time you `runStateT` a parser, wrap the call to `runStateT` in a `lift`
15:44:08 <Tekmo> merijn: Like this:
15:44:19 <Tekmo> merijn: (a, p') <- lift $ runStateT $ decodeGet someGet
15:44:25 <Tekmo> merijn: Oops
15:44:32 <Tekmo> merijn: There should be a `p` argument in there to `runStateT`
15:44:44 <Tekmo> merijn: (a, p') <- lift $ runStateT (decodeGet someGet) p
15:44:57 <luite> enthropy: a somewhat bigger example that i'm working on at the moment: http://hdiff.luite.com/tmp/try-purescript.jsexe/Main.hs.txt
15:45:34 <merijn> Tekmo: Right, but that means runStateT-ing every intermediate value, although I guess I can write a wrapper that does that + get/put's the state
15:46:04 <Tekmo> eikke__: Is there some light-weight way I can throw up a "repository" and check in chapters as markdown and accept pull requests?
15:46:14 <Tekmo> eikke__: I think Github might support something like this, but I'm still new to this
15:46:40 <merijn> "decodeGet' = do { prod <- get; (a, prod') <- lift $ runStateT (decodeGet someGet) prod; put prod'; return a }"
15:46:42 <eikke__> Tekmo: I guess a git repo on github might work nicely :)
15:46:57 <merijn> And then cross my fingers and hope GHC optimises that to not suck in terms of performance...
15:46:57 <Tekmo> eikke__: Is there any way to render the markdown checked in as a nice book format?
15:47:12 <eikke__> Tekmo: could look into Jekyll?
15:47:52 <eikke__> or hakyll to stay in haskell land
15:48:13 <Tekmo> merijn: You need to `runStateT` every time you want to yield a value
15:48:29 <Tekmo> merijn: However, it will still be efficient
15:48:40 <eikke__> Tekmo: I tend to use ReST + Sphinx myself for such things, since both it's html as well as pdf output is fairly nice
15:48:53 <hiptobecubic> Tekmo, github pages will do this pretty much automagically
15:49:14 <hiptobecubic> GithubPages that is.
15:49:25 <eikke__> hiptobecubic: only when it's a Jekyll repo, no?
15:49:43 <hiptobecubic> eikke__, i think they have some kind of turnkey thing that will do it all
15:50:02 <merijn> Tekmo: ok, yeah, I think I get it. I'll just write some convenient helpers and it should be ok. If not I'll come bug the mailing list again :)
15:50:05 <Tekmo> hiptobecubic: That was what I was looking for
15:50:07 <Tekmo> hiptobecubic: Thanks!
15:50:13 <merijn> Tekmo: Thanks for your help :)
15:50:17 <hiptobecubic> Tekmo, https://github.com/blog/272-github-pages
15:50:18 <Tekmo> merijn: You're welcome! :)
15:50:23 <Tekmo> merijn: It's always my pleasure
15:54:22 <merijn> Right, bedtime and then back to the academic paper grindstone :p
15:58:59 <Tekmo> merijn: Actually, I think I may be able to provide a solution for you
15:59:12 <Tekmo> merijn: I'm writing up what we've talked about so far and proposing a possible solution on the mailing list
16:00:43 * hackagebot hsqml 0.3.1.1 - Haskell binding for Qt Quick  http://hackage.haskell.org/package/hsqml-0.3.1.1 (RobinKay)
16:00:45 <Tekmo> merijn: Long story short, I think you just need to provide a function of type:
16:00:46 <mmmm_> How do you page someone here?
16:01:05 <Tekmo> merijn: foo :: StateT (Producer a m x) m r -> StateT (Producer a m x) (Producer b m) r
16:01:29 <Tekmo> merijn: Then you would use `foo` to upgrade any parser to work within your `StateT` without having to escape out of it using `runStateT`
16:02:58 <merijn> Tekmo: That's just "hoist lift", no?
16:03:12 <dwcook> mmmm_, depends on your client. Often, this will open a new window to talk to them: /query PersonsNick
16:03:43 <Tekmo> merijn: Yes, it is
16:03:50 <Tekmo> merijn: So try that out and see if it works
16:04:02 <Tekmo> merijn: Then you don't have to escape out using `runStateT`
16:04:16 <jle`> oh hey tekm
16:04:21 <jle`> tekmo is here
16:04:23 <jle`> sup
16:04:29 <Tekmo> jle`: Hey!
16:04:32 <Tekmo> jle`: Nothing much
16:04:48 <mmmm_> sorry dwcook, I thought there was a @tell function or something like that?
16:04:58 <mmmm_> with lambdabot
16:05:03 <jle`> i am on my phone so i cannot engage in any meaningful dialogue
16:05:16 <jle`> just wanted to say hi :)
16:05:40 <Tekmo> jle`: Haha
16:05:45 <Tekmo> jle`: Hi :)
16:06:10 <Tekmo> jle`: Right now I'm experimenting to see if I can write a Python backend to purescript
16:06:23 <jle`> that'd be pretty nice actually
16:06:31 <levi> You should finish up the lua backend.
16:06:34 <Tekmo> jle`: I have coworkers at Twitter who are interested in working with a statically typed language that compiles to Python
16:06:43 <Tekmo> levi: I didn't write the lua backend
16:07:03 <levi> I know, but you could still finish it up. :)
16:07:10 <merijn> Tekmo: oh, hah, that seems to work :)
16:07:17 <Tekmo> merijn: Neat!
16:07:25 <Tekmo> merijn: Then maybe I should add this to the docs for `pipes-parse`
16:07:42 <merijn> I'll have to test it "for real" on the entire thing tomorrow, but so far so good
16:07:45 <Tekmo> merijn: I'll open an issue to remind myself to do this
16:08:21 <merijn> Tekmo: Actually, I had one more question that I keep forgetting
16:08:43 <Tekmo> merijn: I'm all ears
16:08:46 <levi> Tekmo: But really, a python backend would be cool.
16:09:34 <Fuuzetsu> why would you ever want to compile to Python
16:09:37 <Fuuzetsu> I don't understand
16:09:42 <Fuuzetsu> JS, sure, we're stuck with it
16:09:44 <Fuuzetsu> but Python
16:09:45 <Fuuzetsu> ???
16:09:47 <hpc> Fuuzetsu: gotta do whatever it takes to beat php benchmarks
16:10:07 <Fuuzetsu> compile to C and use Python's FFI to use that ;^)
16:11:23 <merijn> So I can probably define a Lens between ByteString and Frame, but given such a lens, how do I hook up a "StateT (Producer Frame M r) (Producer Frame M) a" into my "StateT (Producer ByteString M r) (Producer ByteString M) a", zoom would just impact the StateT, not the base monad, no?
16:11:52 <l0cust> #yesod seems to be dark. Is there a guide somewhere on implementing your own authentication system?
16:12:15 <Tekmo> levi: Yeah, I'm pretty excited about this project idea
16:12:54 <merijn> I guess ">->" with a "Pipe Frame ByteString" should work, but that only works if I explicitly runStateT, no?
16:13:17 <l0cust> It seems like a really common thing people would want to do
16:13:46 <mmmm_> What is the relationship between phantom types and gadts?
16:13:46 <levi> Fuuzetsu: Some people are "stuck with" Python as effectively as browser-users are "stuck with" JS.
16:14:06 <Fuuzetsu> levi: if you can run Python then you can run everything else
16:14:09 <Tekmo> levi: Yeah
16:14:24 <Tekmo> levi: THey depend on Python libraries, so any solution has to interoperate with Python
16:14:26 <Fuuzetsu> I just don't understand
16:15:05 <vozz> Couldn't you use C as a middleman between Python and Haskell?
16:15:17 <Tekmo> Alright, I have to head out
16:15:17 <levi> Fuuzetsu: You probably will understand at some point, unless your entire career consists of creating things entirely from scratch.
16:15:21 <Tekmo> Nice talking to all of you
16:15:27 <levi> Tekmo: Bye!
16:15:27 <Tekmo> merijn: Also, I opened an issue for this: https://github.com/Gabriel439/Haskell-Pipes-Parse-Library/issues/31
16:15:31 <Tekmo> levi: Bye!
16:16:17 <Fuuzetsu> levi: wow, as opposed to writing a bloody Python backend which is totally efficient use of someone's time and not writing a thing from scratch at all, right? If it's about talking between libraries then there are other ways then making everything the same language
16:17:11 <vozz> aren't most important python libraries just C or C++ libraries wrapped anyway?
16:18:02 <vozz> haskell to python compiler definitely sounds insane
16:18:07 <levi> Fuuzetsu: I think you may be vastly overestimating the amount of work it would take to write a python back-end to purescript.
16:18:25 <Fuuzetsu> I was under an impression we were going from Haskell
16:18:48 <osa1> levi: it's not that hard. I did that for Lua.
16:19:07 <levi> osa1: Ah, are you still working on that, or do you consider it fairly complete?
16:19:16 <osa1> levi: https://github.com/osa1/psc-lua
16:19:40 <osa1> levi: I stopped developing it a while ago because I lost my interest. standard tests were all passing when I left.
16:19:52 <benzrf> merijn: Pipes.Lift
16:20:17 <benzrf> merijn: might be what youre looking for, i dunno
16:20:50 <levi> osa1: Cool, I may check it out again sometime.
16:22:21 <benzrf> hmm
16:22:31 <osa1> levi: doing same thing to current psc may be harder though. I think it's bootstrapped now (so you need codegen parts etc. written in purescript, haskell libs won't work)
16:22:39 <benzrf> if we have purescript for javascript, when will pure come out?
16:23:12 <osa1> benzrf: http://purelang.bitbucket.org/ :)
16:23:37 <levi> osa1: I got the impression that the purescript-in-purescript was back-burnered due to poor performance, but I could be mistaken.
16:24:06 <benzrf> osa1: but that doesnt compile to java
16:24:08 <osa1> levi: well they didn't try Lua version ;-)
16:25:03 <osa1> levi: bootstrapped version using Lua backend may run a bit faster on LuaJIT.
16:26:13 <dwcook> mmmm_, yeah, lambdabot lets you leave a message for someone and will alert them next time they show activity. It's indeed @tell.
16:26:55 <dwcook>  @tell whoever your message
16:27:17 <vozz> dwcook: Does that work for people who are offline? Someone just left who I could have helped
16:27:29 <mmmm_> yep I got it now thanks
16:27:34 <mmmm_> vozz: That's the idea
16:27:35 <dwcook> vozz, it does
16:27:43 <mmmm_> when they speak in the channel, lambda bot will message them
16:27:44 <vozz> cool
16:33:13 <vozz> @tell l0cust I implemented my own auth here: https://github.com/ollieh/yesodaccounts Hope it's useful
16:33:14 <lambdabot> Consider it noted.
16:34:27 <rufs> someone with experience with postgres simple and its notifications?
16:34:50 <orion> In a large Haskell library, if you have a top level interface, should you re-export the carefully chosen imports, or should you write an intermediate function which passes data, as seen here?: https://github.com/thoughtpolice/hs-nacl/blob/master/src/Crypto/NaCl.hs
16:36:07 <dwcook> orion, that's up to your choice of interface, really.
16:38:22 <orion> dwcook: What are the benefits and drawbacks of each?
16:38:45 <iteratee> looking for some users to test the bittorrent tracker I wrote in haskell.
16:39:09 <iteratee> tracker4.iteratee.net:6969 and tracker6.iteratee.net:6970
16:39:30 <Fuuzetsu> iteratee: I was just looking for a tracker few hours ago!
16:39:41 <Fuuzetsu> you are great
16:40:05 <vozz> Would also be v interested in seeing that
16:40:07 <Fuuzetsu> iteratee: do you have some registered torrent files we can use?
16:40:55 <Fuuzetsu> now I just need to catch the author of ‘bittorrent’ and get bits-extras to build and I'll be pretty well set
16:41:04 <dwcook> orion, it doesn't seem to be like you would explicitly make that choice. Just think about what API you want to expose, and if you have to define some part of that verbatim in some module, then you can export it either by exporting that module or re-exporting it from another.
16:41:26 <dwcook> orion, s/have to define/have defined/
16:43:07 <iteratee> https://github.com/iteratee/haskell-tracker
16:43:43 <Fuuzetsu> cabal file please ;)
16:44:11 <dwcook> orion, an example of when you might want to re-export: You have YourPackage.Internals module that includes constructors for your type that you don't want to expose. You decide to export them anyway so the rest of your package can do internals-y stuff but want to expose a clean interface so you expose a YourPackage module that doesn't expose the constructors.
16:44:51 <dwcook> orion, if I recall, Pipes does this
16:45:00 <dwcook> s/P/p/
16:45:30 <Fuuzetsu> iteratee: does it implement all the commonly used BEPs?
16:48:00 <AndChat|600084> > (maxBound,succ maxBound)::(Int,Int)
16:48:02 <lambdabot>  (9223372036854775807,*Exception: Prelude.Enum.succ{Int}: tried to take `succ...
16:48:02 <iteratee> Fuuzetsu: It has udp and ipv6 support
16:48:18 <iteratee> No DHT support.
16:49:02 <AndChat|600084> > succ maxBound :: Int
16:49:03 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
16:49:08 <iteratee> Fuuzetsu: Are there bep's that you're looking for?
16:49:30 <iteratee> Fuuzetsu: it also implements http://opentracker.blog.h3q.com/2007/12/28/the-ipv6-situation/
16:49:37 <iteratee> which is not a bep at all, but should be.
16:51:12 <Fuuzetsu> iteratee: every BEP
16:52:36 <Fuuzetsu> basically everything on here http://www.bittorrent.org/beps/bep_0000.html
16:52:38 <Fuuzetsu> maybe not 8
16:53:15 <iteratee> Fuuzetsu: Many don't apply to trackers. Bep 23 is implemented. Bep 9 is peer only.
16:53:17 <AndChat|600084> What's a BEP?
16:53:35 <iteratee> AndChat|600084: Bittorrent Extension Proposal
16:53:38 <orion> dwcook: I see. I am refactoring the code I linked to in my previous message. I think reexporting might be the way to go.
16:53:53 <orion> iteratee: Do you have a torrent I can test?
16:55:38 <iteratee> orion: No, not at the moment.
16:55:47 <orion> I See.
16:56:01 <Fuuzetsu> iteratee: well, my use case would be to use it to test against when writing a client with support for all the (client) BEPs which is why I'm asking
16:57:51 <Fuuzetsu> so I'll probably be swinging around by your repository a bit
16:58:44 <benzrf> iteratee: why iteratee? y not pipe
16:59:06 <Fuuzetsu> benzrf: you shouldn't step into the IO-libraries territory
16:59:18 <benzrf> Fuuzetsu: pipes isnt even an IO library
16:59:31 <Fuuzetsu> it can certainly be used as such
16:59:33 <benzrf> it's a coroutine library where the coroutines are monad transformers
16:59:44 <benzrf> or possibly generator, not coroutine
16:59:47 <benzrf> the line is a bit fuzzy
17:00:17 <iteratee> benzrf: when I picked the nickname, pipes hadn't been written.
17:00:39 <l0cust> Hey, I'm having an issue creating my own auth plugin in Yesod. I think it's just a type-tetris issue. Here's my code http://lpaste.net/108531 , and here's the error http://lpaste.net/108533 .
17:01:01 <Fuuzetsu> vozz: ^
17:01:11 <ode> Hi, Can someone please explain how http://lpaste.net/108532 is pattern matching in list comprehensions?
17:01:18 <benzrf> 'type tetris'
17:01:21 <iteratee> Fuuzetsu: bep 24 isn't implemented, but it would be simple enough to do.
17:01:26 <vozz> l0cust: Yo, I sent you something earlier through lambdabot as you logged off
17:01:31 <benzrf> ode: what do u mean 'how'?
17:01:32 <l0cust> vozz: just got that
17:01:47 <vozz> What kind of auth system were you hoping to implement?
17:01:47 <Fuuzetsu> iteratee: right, right, I'm not in a rush just yet and can probably write the stuff myself if I have to, just wondering in general
17:01:53 <Iceland_jack> ode: '(a, b)' matches individual elements of the list 'xs'
17:02:09 <ode> I mean what part is the pattern matching?
17:02:09 <Iceland_jack> > [ x | Left x <- [Left 1, Right 2] ]
17:02:11 <lambdabot>  [1]
17:02:17 <Iceland_jack> ode: (a, b) is the pattern
17:02:40 <l0cust> vozz: oh, nice. It doesn't even look like you messed with yesod-auth
17:03:05 <vozz> I made one that used yesod-auth initially but I don't like it
17:03:25 <vozz> If you roll your own you can set your own routes, do your own login pages etc
17:04:25 <ode> Since all elements of a list have to be the same type I guess I don't get why pattern matching is used...Could you give an example of a pattern which would fail? Thanks
17:04:40 <Iceland_jack> ode: I just did :)
17:04:40 <Iceland_jack> <Iceland_jack> > [ x | Left x <- [Left 1, Right 2] ]
17:04:40 <Iceland_jack> <lambdabot>  [1]
17:04:51 <Iceland_jack> 'Right 2' doesn't match the pattern 'Left x'
17:05:06 <geekosaur> ode: you can match on length, or on constructors for a type inside the list
17:05:15 <l0cust> Solution, with some type tetris - http://lpaste.net/108534
17:05:17 <geekosaur> [] will not match (x:xs)
17:05:33 <Iceland_jack> > let x:xs = [] in x
17:05:35 <lambdabot>  *Exception: <interactive>:3:5-13: Irrefutable pattern failed for pattern x : xs
17:07:01 <geekosaur> > let [Left a] = [Right 5] in a
17:07:03 <lambdabot>  *Exception: <interactive>:3:5-24: Irrefutable pattern failed for pattern [Da...
17:10:02 <CaptainK> > let (x:xs) = []
17:10:04 <lambdabot>  not an expression: ‘let (x:xs) = []’
17:10:33 <CaptainK> works in GHCi
17:10:52 <Iceland_jack> You need to use '@let' if you want to define
17:10:58 <Iceland_jack> @let (x:xs) = []
17:11:01 <lambdabot>  Defined.
17:11:18 <Iceland_jack> '>' works with expressions and 'let ... = ...' is not an expression
17:11:24 <CaptainK> ah, yhx
17:11:47 <Iceland_jack> > xs
17:11:50 <lambdabot>  *Exception: L.hs:158:1-13: Irrefutable pattern failed for pattern (x : xs)
17:11:50 <Iceland_jack> > x
17:11:52 <lambdabot>  Ambiguous occurrence ‘x’
17:11:52 <lambdabot>  It could refer to either ‘L.x’, defined at L.hs:158:2
17:11:52 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.x’,
17:11:52 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:113:1-26
17:11:52 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
17:12:01 <Rarrikins> > data Zomg = Zomg | Kthx
17:12:03 <lambdabot>  <hint>:1:1: parse error on input ‘data’
17:12:23 <Iceland_jack> @let data Zomg = Zomg | Kthx
17:12:25 <lambdabot>  Defined.
17:12:34 <Rarrikins> > Kthx
17:12:36 <lambdabot>  No instance for (GHC.Show.Show L.Zomg)
17:12:36 <lambdabot>    arising from a use of ‘M45365059592091484025465.show_M45365059592091484025...
17:13:21 <zwer> ode without pattern matching it would look like this, not quite as nice: [fst x + snd x | x <- xs]
17:14:01 <Fuuzetsu> please stop, it's triggering me to think about languages without pattern matching
17:19:59 <dfeuer> ARRRRGH. Why oh WHY isn't Enum a subclass of Eq and probably also Ord?
17:20:35 <Fuuzetsu> instance (Eq a, Ord a) => Enum a where …
17:20:58 <dfeuer> UGH UGGGGHHHHH. The whole Enum class is BROKEN.
17:21:02 <Fuuzetsu> yes
17:21:03 <dfeuer> What do you mean, Fuuzetsu?
17:21:11 <Fuuzetsu> I'm saying you could define that yourself
17:21:20 <Fuuzetsu> but it in MyProject.Never.Ever.Import
17:21:27 <dfeuer> I do not understand what you mean by that.
17:21:50 <dfeuer> I guess not Ord. Forget I said that.
17:21:56 <Fuuzetsu> you can make Enum a subclass of Eq and probably also Ord if you want to
17:22:01 <Fuuzetsu> …right?
17:22:31 <dfeuer> I guess. But that would be a different Enum.
17:23:12 <dfeuer> What I'm saying is that the standard one is trying to be two or three different things, and not doing any of them very well.
17:23:12 <Fuuzetsu> actually, I think you can only go Enum => Eq/Ord either way
17:23:20 <Fuuzetsu> ah, yes
17:23:39 <dfeuer> class Eq a => Enum a    makes a lot of sense.
17:23:43 <Fuuzetsu> don't remember the last time I used enum
17:24:48 <dfeuer> It's trying to be:  1. Things that can be converted to and from Int quickly, 2. Things where succ and pred make sense, and 3. Things where stepped ranges make sense.
17:25:12 <dfeuer> There is very little about these three things to make a sensible typeclass.
17:26:07 <dfeuer> It is possible to get Eq using fromEnum and toEnum, but why?
17:26:58 <dfeuer> > fromEnum (2.5::Double)
17:27:00 <lambdabot>  2
17:27:07 <dfeuer> See, that's just SILLY.
17:27:16 <contiver> quick question, why is it that 192 / 960 = 0.2 , but 19.2 / 96 = 0.19999999999998 (in ghci). I imagine that it has to do with how integer and double division is implemented?
17:27:21 * dfeuer hits Fuuzetsu on the head with the standard Enum class.
17:27:32 <Fuuzetsu> hey, don't blame me!
17:27:44 <Fuuzetsu> the Enum class is probably half my age
17:27:46 <hpc> contiver: https://en.wikipedia.org/wiki/Ieee_float
17:27:52 <dfeuer> contiver, that's all Double division, and it has to do with the fact that your computer doesn't calculate in base 10.
17:27:54 <hpc> contiver: unfortunately the answer to that is quite subtle
17:28:50 <dfeuer> 19.2 can't be represented exactly as a Double.
17:30:02 <contiver> I'm aware of the limitations with fixed point representations, but what is haskell doing that manages to print the exact solution when dividing Ints ?
17:30:31 <Rarrikins> 20:22 < randomA> oh wow, portforwarding works
17:30:31 <Rarrikins> 20:22 -!- randomA_ [~androirc@38.105.236.163] has quit [Quit: AndroIRC - Android IRC Client ( http://www.androirc.com )]
17:30:34 <Rarrikins> 20:22 < BenLand100> while this second passes I'm going to gaze out at the golden gate bridge and enjoy the view
17:30:37 <Rarrikins> 20:22 < BenLand100> jk clouds over the bay
17:30:40 <Rarrikins> 20:22 -!- mceier [~mceier@89-69-201-93.dynamic.chello.pl] has quit [Ping timeout: 255 seconds]
17:30:42 <dfeuer> contiver, Prelude> (192/1024)/(960/1024)
17:30:42 <dfeuer> 0.2
17:30:43 <Rarrikins> Bah. Sorry
17:30:56 <hpc> [sudo] password for Rarrikins:
17:31:18 <dfeuer> contiver, it's nothing special about things that happen to be integers. It's that 192 is an integer small enough to be represented exactly as a double.
17:31:51 <dfeuer> If you were to use sufficiently large integers, you would get a problem too.
17:31:53 <johnw> I think you get 53-bits of integerness out of a double
17:32:11 <hpc> 52 bits mantissa, 11 exponent, 1 sign
17:32:17 <contiver> dfeuer, oh, that makes sense. Thanks !
17:33:05 <hpc> the mantissa has normal and denormal forms, so it can be a bit weird
17:33:15 <hpc> er, subnormal
17:33:55 <dfeuer> hpc, I don't know that much, hpc.
17:34:32 <hpc> my uni was a C school, so i learned floats in 4 different classes
17:34:36 <hpc> it was worse than scientific notation
17:34:46 <dfeuer> hpc, so floatDigits counts the sign bit?
17:35:03 <dfeuer> What does C have to do with floats?
17:35:21 <dfeuer> My high school had a big focus on "significant figures". UGH.
17:35:24 <hpc> it's a part of the place's obsession with binary
17:35:50 <hpc> and things like dijkstra's algorithm for shortest path in a graph
17:36:07 <hpc> linear procedural logic
17:36:10 <dfeuer> Would you prefer a school that focused on base 131?
17:36:10 <hpc> C things
17:36:26 <dfeuer> What makes Dijkstra's algorithm a C thing?
17:37:10 <hpc> dfeuer: i am being very metaphorical about the style and focus of education :P
17:38:25 <hpc> MIT for instance is a lisp school, so the type of education you get is differently focused
17:38:54 <hpc> this is off topic
17:39:00 <l0cust> @offtopic
17:39:01 <lambdabot> Unknown command, try @list
17:39:04 <l0cust> damn
17:39:11 <l0cust> hpc: anyway, go to #haskell-blah
17:39:19 <Fuuzetsu> hpc: you mean MIT is a Python school, right? ;^)
17:39:22 <Iceland_jack> > offtopic
17:39:23 <lambdabot>  offtopic!
17:39:27 <l0cust> Why can't lambdabot have all of phrik's commands?
17:39:28 <Iceland_jack> (joking) :)
17:39:37 <Fuuzetsu> :t offtopic
17:39:38 <lambdabot> Not in scope: ‘offtopic’
17:39:47 <Iceland_jack> @let offtopic = text "offtopic!"
17:39:49 <lambdabot>  Defined.
17:40:01 <Fuuzetsu> text for that blazing fast offtopic
17:40:12 <Iceland_jack> No for the display
17:40:18 <Iceland_jack> It's not Data.Text
17:40:22 <Iceland_jack> :t offtopic
17:40:23 <lambdabot> Doc
17:40:25 <Fuuzetsu> ah
17:41:04 <Iceland_jack> > ("hello", text "hello")
17:41:05 <lambdabot>  ("hello",hello)
17:41:33 <bb010g> :t text
17:41:34 <lambdabot> String -> Doc
17:44:50 <benzrf> :t vacuum
17:44:51 <lambdabot>     Not in scope: ‘vacuum’
17:44:52 <lambdabot>     Perhaps you meant ‘accum’ (imported from Data.Array)
17:56:02 <thoughtpolice> orion: the reason I did this in Crypto.NaCl is so that the top level API reflects the actual NaCl API, in terms of naming convention
17:57:12 <thoughtpolice> orion: the other modules export specifically named versions of their primitives, and the top-level module (Crypto.NaCl) merely re-exports them under new names to match the actual nacl library. the names should not be changed. if you want something outside of the top-level module (like a more specific primitive), you should import that module manually.
18:00:08 <thoughtpolice> orion: I am of course willing to change this, but in the previous version of the library, it became clear a top-level module to re-export the same 'nacl selected' primitives was necessary. otherwise you had to import 10 separate modules. i decided to re-export them under new names to match the nomenclature used in the actual upstream library
18:07:01 <l0cust> Hey guys, having a Yesod type-tetris problem. I've got this https://github.com/pharpend/lambdatube/blob/master/Account.hs that works. I'm trying to get a form that works in both the Widget and Handler monads, essentially.
18:07:15 <l0cust> Can't firgure out how to do that
18:07:31 <l0cust> *figure
18:10:08 <stalintrotsky> :t startsWith
18:10:09 <lambdabot> Eq a => [a] -> Splitter a
18:10:09 <johnw> is there an operation to union two vectors?
18:10:51 <bitemyapp> johnw: union? They're not sets.
18:11:06 <johnw> hmm
18:11:37 <l0cust> bitemyapp: I think he's looking for the vector equivalent of (<|>) from Matrix
18:11:46 <bitemyapp> I don't know what that is :(
18:11:50 <johnw> well, I would need to define when I want the rhs over the lhs
18:12:05 <bitemyapp> johnw: so it's about union of index?
18:12:13 <johnw> no
18:12:19 <bitemyapp> buhhh.
18:12:36 <johnw> given V1 and V2, generate a vector that selects every entry from V2 wherever V1 doesn't have anything set for that slot.  So I need to define "doesn't have anything set"
18:12:37 <bitemyapp> I don't know where rhs/lhs would come in unless you were doing index-wise merge.
18:12:50 <bitemyapp> mempty?
18:12:59 <johnw> if I'm storing monoids
18:13:23 <bitemyapp> I don't think I'm helping because I don't understand what's wanted.
18:13:25 * bitemyapp toddles off
18:15:45 <aspidites> at the risk of getting a "when it's done" reply, has anyone heard about when the next version of happstack will be released?
18:15:52 <aspidites> or at least if there has been anyy recent development
18:17:20 <Fuuzetsu> http://hub.darcs.net/stepcut/happstack/changes
18:19:37 <levi> If you mean the next version that's supposed to be based on pipes and such, I think that one is moving slowly at the moment.
18:26:12 <benzrf> what is -XGADTSyntax
18:26:29 <Enigmagic> the old -XGADTs
18:29:38 <dolio> I don't think that's right.
18:29:58 <dolio> I think GADT syntax turns on 'data Foo where' without enabling actual GADTs.
18:30:28 <HeladoDeBrownie> That it does
18:31:19 <HeladoDeBrownie> www.haskell.org/ghc/docs/7.8.3/html/users_guide/data-type-extensions.html#gadt-style
18:35:01 <ryantrinkle> is there any object that can be safely used with mkWeak that *isn't* mutable? i need to wrap something (actually, another Weak ref) in a reference, to add a finalizer to it, but it isn't mutable or anything, so i'd rather not pay that cost
18:36:25 <johnw> which cost is that exactly?
18:36:46 <ryantrinkle> johnw: don't mutable heap objects have larger gc overhead?
18:37:34 <johnw> what is a mutable heap object?  you mean like a MutVar?
18:37:42 <ryantrinkle> like an IORef
18:37:44 <ryantrinkle> or MVar
18:37:51 <ryantrinkle> https://hackage.haskell.org/package/base-4.7.0.0/docs/System-Mem-Weak.html
18:38:10 <luite> MutVar# is the primitive used inside IORef
18:38:12 <ryantrinkle> according to that page, weak references to regular haskell objects may be finalized early, due to optimization
18:38:34 <ryantrinkle> the situation i've actually got is an IORef with two "handles" to it
18:38:43 <luite> ryantrinkle: they're not particularly expensive, when you modify an IORef it gets added to the mutable list
18:38:52 <ryantrinkle> ah, ok
18:39:02 <ryantrinkle> so, perhaps if i never modify it, it's not so bad
18:39:07 <luite> right
18:39:12 <ryantrinkle> ok, that'll do for now
18:39:30 <ryantrinkle> i'd still like to have a construct that basically says "you can't optimize away this structure's existence"
18:39:33 <ryantrinkle> but nothing more
18:40:07 <luite> mutable arrays are more expensive i think, at least i recall something about that the card table is always scanned
18:40:17 <ryantrinkle> ah
18:40:19 <luite> not too sure though
18:40:53 <luite> weak refs themselves are relatively expensive since they're on a separate list
18:41:47 <ryantrinkle> yeah
18:41:52 <ryantrinkle> that makes sense
18:43:14 <slack1256> Is there a standard place for the "reverse function application"?
18:43:31 <slack1256> I usually see it blog post as "x # f = f x"
18:43:45 <slack1256> *it in
18:44:07 <Fuuzetsu> :t (&)
18:44:08 <lambdabot> a -> (a -> b) -> b
18:44:21 <slack1256> :info (&)
18:44:26 <slack1256> :i (&)
18:44:33 <Fuuzetsu> lambdabot doesn't do :i
18:44:43 <slack1256> Oh, Ok
18:46:15 <slack1256> Oh Control.Lens.Operators is there something you don't do?
18:46:27 <jle`> slack1256: it'll be in base in 7.10, though i still think normal function application is preferred stylistically
18:46:55 <jle`> (&) works well in lens because it fits really well into lens idioms
18:46:55 <dibblego> why is there no Monoid instance for Int32?
18:47:06 <slack1256> Really? That is great
18:47:10 <jle`> dibblego: which one?
18:47:19 <jle`> slack1256: i have the opposite reaction, but ;)
18:47:25 <jle`> dibblego: which monoid would it be?
18:47:31 <dibblego> 0/(+)
18:47:34 <slack1256> dibblego: there are at least 2 monoid instances possible for Int32
18:47:41 <dibblego> ok fair enough, just checking
18:47:45 <jle`> how about under bitwise xor
18:47:48 <dolio> Way more than two.
18:47:51 <dibblego> right, got it
18:47:51 <jle`> bitwise and and or
18:47:53 <dibblego> yes way more than two
18:47:58 <slack1256> at least two :-)
18:50:15 <johnw> is there a faster alternative to StateT s IO a?
18:50:29 <johnw> or does GHC optimize the functional nature of StateT pretty well?
18:50:38 <slack1256> StateT is pretty fast on my experience.
18:50:40 <jle`> StateT is just a newtype
18:50:48 <jle`> so it's as fast as it gets i think
18:50:58 <johnw> I guess I also mean using the type s -> m (a ,s) everywhere
18:51:05 <johnw> m ~ IO
18:51:16 <jle`> you mean, is there anything faster than (s -> m (a, s))?
18:51:34 <johnw> yeah
18:51:46 <johnw> like, would an IORef + m a be faster
18:51:50 <jle`> ah
18:51:55 <benzrf> johnw: sounds like you want ST
18:52:00 <ryantrinkle> johnw: i believe it is faster to use an IORef
18:52:03 <johnw> ST is not in IO
18:52:08 <benzrf> johnw: yes it is
18:52:12 <ryantrinkle> even if you use ReaderT to delivr it
18:52:13 <johnw> :t runST
18:52:14 <lambdabot> (forall s. ST s a) -> a
18:52:20 <benzrf> @src runST
18:52:21 <lambdabot> runST st = runSTRep (case st of { ST st_rep -> st_rep })
18:52:25 <benzrf> @src runSTRep
18:52:25 <lambdabot> runSTRep st_rep = case st_rep realWorld# of (# _, r #) -> r
18:52:28 <johnw> ryantrinkle: I'll try that
18:52:38 <benzrf> johnw: does that look like anything but IO to you
18:52:45 <benzrf> @wiki ST
18:52:46 <lambdabot> http://www.haskell.org/haskellwiki/ST
18:52:53 <benzrf> oh wait
18:52:53 <glguy_> benzrf: He probably wants to *do* IO in addition to the state question
18:53:03 <glguy_> which isn't what ST is for
18:53:04 <benzrf> ah
18:53:07 <johnw> exactly
18:53:10 <benzrf> mb >.>
18:53:13 <johnw> there is an STT on Hackage, but I'm not interested
18:53:19 <johnw> i'd try ReaderT+IORef first
18:53:38 <Fuuzetsu> what are you writing?
18:53:47 <johnw> it's a machine simulator
18:53:55 <johnw> it's already written, I'm trying to make it faster
18:54:08 <Fuuzetsu> what machineV
18:54:10 <Fuuzetsu> ?*
18:54:10 <slack1256> Is that the kind of problem that screams for a free-monad?
18:54:11 <lambdabot> Maybe you meant: v @ ? .
18:54:17 <johnw> the top functions in the profile does 10s of millions of access to/from the given state
18:54:27 <johnw> Fuuzetsu: it's a machine model we've developed
18:54:45 <johnw> so, "memory" for me is an IOVector
18:54:55 <johnw> and the step function of the machine is always reading and writing to it
18:55:08 <benzrf> johnw: doesnt sound very functional
18:55:11 <benzrf> why are you using haskell
18:55:13 <Fuuzetsu> mhm
18:55:21 <johnw> benzrf: I really don't know what you're talking about
18:55:22 <Fuuzetsu> benzrf: Haskell is great imperative language
18:55:30 <benzrf> Fuuzetsu: ( ͡° ͜ʖ ͡°)
18:55:40 <Fuuzetsu> I'm not joking
18:55:49 <benzrf> johnw: wait, what is this used for
18:56:03 <benzrf> and is the iovector part a subpart of the program thats abstracted over
18:56:08 <benzrf> ok i probably shouldve assumed that
18:56:13 * Fuuzetsu is going to be writing some emulators himself
18:56:15 <benzrf> instead of doubting competence at each opportunity
18:56:16 <benzrf> >.>
18:56:22 <johnw> it's for making sure progams will run without need to have a custom hardware box delivered to you
18:56:45 <benzrf> johnw: arent VMs usually not written in functional langs
18:56:47 * glguy_ wouldn't mind if johnw sent over some custom hardware
18:57:00 <benzrf> ...if you know what i mean
18:57:02 <johnw> functional languages work very well here
18:57:06 <benzrf> johnw: really?
18:57:06 <dolio> Almost everything is usually not written in functional languages.
18:57:13 <HeladoDeBrownie> benzrf, s/VMs/programs/
18:57:15 <benzrf> dolio: bleh
18:57:22 <benzrf> i mean, by people who know about FP
18:57:33 <johnw> really the only mutable detail is the memory image, the registers and the breakpoint and watchpoint list; but even those can be seen as mutation within a pure model
18:58:44 <johnw> ryantrinkle: even if the majority of the time I'm simply reading from the data?
18:59:42 <augur> johnw: someone (Enigmagic i think?) suggested i use Foreign.StablePtr to store haskell types across IO without having to encode the data
18:59:45 <benzrf> HeladoDeBrownie: brownie ice cream?
18:59:52 <HeladoDeBrownie> benzrf, yep
18:59:58 <augur> johnw: fwiw
18:59:58 <benzrf> mmm
19:00:06 <johnw> augur: I thought StablePtr just allows you to prevent something from being GC'd
19:00:27 <johnw> so you're not sending the data across, just a pointer to a value?
19:00:27 <Enigmagic> johnw: nope, it creates a GC root
19:00:27 <augur> johnw: yeah, but you can then transfer it out of haskell then back in, it seems
19:00:37 <johnw> Enigmagic: ah
19:00:53 <Enigmagic> johnw: a StablePtr is an index into a global hash table
19:03:07 <slack1256> sounds neat
19:03:08 <slack1256> The IOVectors are mutated in place right?
19:03:22 <johnw> yes
19:04:10 <johnw> laziness is really skewing my profiling results though
19:04:33 <johnw> all the costs accrue where the thunks gets forced
19:04:58 <johnw> it makes some really trivial tiny functions appear huge in profile
19:05:28 <johnw> and yet, laziness is definitely helping me; I can make the runtime 20% slower with done single bang pattern
19:05:34 <johnw> s/done/one
19:06:02 <joneshf-laptop> is there a thing like OverloadedStrings for type synonyms?
19:07:33 <slack1256> joneshf-laptop: Could you elaborate? You want something like 'type MyString = Text' and then do ' "oh snap" :: MyString ' ?
19:07:51 <joneshf-laptop> sure, but for types in general
19:08:19 <glguy_> joneshf-laptop: You might have to give an example of what you want
19:08:32 <slack1256> For data/newtypes or just type sinonyms?
19:08:47 <joneshf-laptop> type Foo = Int; instance Num Foo where ...; add :: Foo -> Foo -> Foo; add 3 4 = 3 + 4
19:09:00 <joneshf-laptop> or soemthing like that
19:09:06 <joneshf-laptop> maybe you don't need the isntance?
19:09:33 <slack1256> That works out of the box
19:09:41 <slack1256> try in in ghci to see :-)
19:09:44 <joneshf-laptop> ugh
19:09:48 <joneshf-laptop> then remove the instance :)
19:09:57 <joneshf-laptop> type Foo = Int; add :: Foo -> Foo -> Foo; add 3 4 = 3 + 4
19:10:00 <slack1256> > type MyInt = Int
19:10:01 <lambdabot>  <hint>:1:1: parse error on input ‘type’
19:10:03 <joneshf-laptop> or something
19:10:15 <slack1256> That works on ghci
19:10:20 <joneshf-laptop> i know
19:10:26 <joneshf-laptop> hmm
19:10:30 <joneshf-laptop> let me try to expalin
19:10:40 <joneshf-laptop> because i'm doing a terrible job at the moment
19:10:46 <slack1256> please do :-)
19:10:48 <slack1256> take your time
19:13:27 <joneshf-laptop> so like, `Text` you can write with `String` syntax. and the compile will complain if you try to pass use a `Text` as though it is a `String` or vice versa. But with newtypes you have to explicitly wrap the type up, then unwrap it. So `Text` is kind of like a newtype w/o the explicit wrapping. Could there be something like that for other types in general, or is this some intractable problem?
19:13:45 <joneshf-laptop> like, the compile time safety of newtypes, without the explicit wrapping
19:14:35 <vanila> joneshf-laptop: i think those two things are at odds - but maybe something with typeclasses could fill in the unwrapping
19:14:53 <slack1256> Well there is the newtype library
19:18:18 <slack1256> joneshf-laptop: I kind of get what you're saying. Just as a side note newtype packing and unpacking is maybe annoying on the programmer but is cost free on the compiler and program.
19:18:57 <joneshf-laptop> slack1256, right, i'm not actually concerned with performance, or with the amount of extra stuff to type
19:19:02 <joneshf-laptop> slack1256, just curious is all :)
19:19:19 <slack1256> About Text and String both solve some overlapping domain but are different internally, not really newtypes. The syntax is just there because is convenient
19:19:53 <slack1256> Now if you want to avoid packing and unpacking all the time, you can use the newtype library. The 'ala' combinator is maybe what you are looking for.
19:20:44 <slack1256> ala Sum foldMap [1,2,3,4] == 10
19:21:03 <slack1256> ala Product foldMap [1,2,3,4] == 24
19:23:44 <joneshf-laptop> hmm, that's pretty neat
19:24:00 <c_wraith> doesn't lens have support for that with Iso, too?
19:24:17 <joneshf-laptop> yeah, i think so
19:24:24 <c_wraith> :t ala
19:24:26 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
19:24:32 <c_wraith> that sure looks like a lens.
19:24:43 <c_wraith> err, a lens type, that is
19:24:54 <trap_exit> so this is a genuine question ... not meant to be trolling
19:25:05 <trap_exit> for concurrency, why did Haskell adopt the STM approach rather than Erlang's separate heap appraoch ?
19:25:06 <joneshf-laptop> http://hackage.haskell.org/package/lens-4.3.3/docs/Control-Lens-Wrapped.html#v:ala
19:25:45 <c_wraith> trap_exit: haskell didn't adopt the STM approach.
19:25:50 <c_wraith> trap_exit: STM is just a library.
19:25:57 <trap_exit> Control.Concurrent.STM
19:25:58 <trap_exit> oh
19:26:02 <trap_exit> right
19:26:15 <slack1256> What is more Erlang style concurrency will also be avaiable soon on a store next to your home (tm)
19:26:16 <trap_exit> damn it
19:26:17 <trap_exit> STM's just a specialized monad of some sort?
19:26:48 <glguy_> c_wraith: The ala on lambdabot is the lens version
19:26:51 <c_wraith> STM is a type that holds a transaction record, more or less.
19:26:55 <trap_exit> slackl256: ?
19:27:36 <benzrf> > ala Sum (mappend (Sum 34)) 10
19:27:39 <lambdabot>  Couldn't match expected type ‘b -> Data.Monoid.Sum b’
19:27:39 <lambdabot>              with actual type ‘Data.Monoid.Sum a0’
19:27:57 <benzrf> o wait
19:28:01 <benzrf> :t foldMap
19:28:03 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
19:28:04 <benzrf> dur
19:28:17 <slack1256> trap_exit: http://hackage.haskell.org/package/distributed-process-platform could be considered tha haskell analog of Erlang style concurrency.
19:28:28 <slack1256> Aparently it need more time though
19:31:20 * genericpersona has lambda pride ... do you?!
19:31:39 <trap_exit> it does not need more itme
19:31:41 <trap_exit> it needs more developers
19:31:50 <trap_exit> everyone, drop what you're doing and go hack on distributed haskell
19:35:10 <slack1256> cool, you going?
19:38:47 <lispy> c_wraith: GHC's STM implementation is more than 'just a library' https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/STM
19:42:44 <trap_exit> lispy: where do your allegiances lie? static types or dyanmic types?
19:43:28 <slack1256> lol
19:43:30 <CaptainK> the blue pill or the red?
19:43:52 <augur> statically checked dynamic typing!
19:43:56 <augur> wrap everything in an existential!
19:44:48 <augur> DynType :: Set  ;  DynType = Σ Code El
19:44:50 <augur> hooray!
19:45:17 <slack1256> Haskell is a republic, he can have a dissident opinion
19:45:20 <slack1256> http://www.lisperati.com/landoflisp/panel57.html
19:46:10 <carter> trap_exit: i'm working on a better design that distributed-process
19:46:14 <carter> its too untyped for my taste
19:46:26 <carter> cant reason about the transports in a way i'd be ok with
19:46:36 <carter> to wit: it pretends all the transports are teh same
19:46:56 <carter> well, i'm starting with an indexed analogue of network-transport
19:47:08 <Iceland_jack> carter: Do you have a link to a repo? :)
19:47:16 <carter> nope, not yet
19:47:20 <carter> letting that one bake
19:47:33 <carter> not putting it online or whatever till after alpha of my main thing this month
19:48:08 <carter> the distributed-process / network-transport stuff has some good ideas, but a lot of details need to be rejiggered heavily
19:48:15 <lispy> trap_exit: statically. definitely static.
19:48:34 <carter> Iceland_jack: trap_exit  for a simpler version of the D-P stuff, courier on hackage is pretty nice
19:48:50 <carter> only one repo/issue tracker than than 20 github repos and 40 jiras
19:48:57 <Iceland_jack> I'll check it out
19:49:29 <carter> @hackage courier
19:49:30 <lambdabot> http://hackage.haskell.org/package/courier
19:49:34 <carter> its got its own flavor
19:49:39 <carter> but the rough design is very similar
19:49:49 <carter> to the "cloud haskell"
19:49:49 <carter> bits
19:51:44 <carter> my critiques of CH apply to courier, but its a much simpler packaging of equiv functionality
19:51:49 <johnw> why does compiling the code for a package inside my package improve performance?
19:52:21 <johnw> if I compile my assember library separate from my simular, I run at 93kops/sec.  If I compile all the code together in one module, I run at 105kops/sec.
19:52:30 <carter> johnw: because you have -O2  ? or
19:52:33 <carter> same modules
19:52:36 <carter> or different modules
19:52:39 <johnw> I have -O2 -funbox-strict-fields on everywhere
19:52:41 <carter> maybe better inter module stuff?
19:52:49 <johnw> yeah, that's what I'm wondering
19:52:59 <johnw> since I'm not explicitly using INLINEABLE in the assembler module
19:53:01 <carter> johnw: look at the core to check whats marked inline/inlineable
19:53:08 <johnw> I'm wondering if it defeats GHC's ability to inline the assembler functions
19:53:14 <carter> hah
19:53:18 <carter> idk
19:53:23 <carter> or mebe thats a bug
19:53:26 <johnw> i.e., it's not exporting definitions in the interface files
19:53:35 <johnw> just types
19:53:35 <carter> huh
19:53:40 <carter> have you looked at the .hi?
19:53:45 <johnw> that's what I understood INLINEABLE to do
19:53:56 <carter> ?
19:53:58 <carter> what
19:54:15 <johnw> "exporting definitions in the interface files"
19:54:15 <carter> say that last bit again with different words plz
19:54:17 <carter> yes
19:54:25 <carter> and giving you the option of inlining in the use site
19:54:37 <luite> it works! http://hdiff.luite.com/tmp/try-purescript.jsexe/
19:56:44 <thoughtpolice> johnw: just try marking it INLINEABLE i guess. INLINEABLE has a very specific set of semantics - not just the 'choice' of inlining, which is left to GHC (whereas INLINE is basically forcing it), but also it has an impact on exactly how the defn is elaborated before being put into the header file
19:56:59 <johnw> I'm not sure which functinos to inline though
19:57:01 <johnw> it's a huge library
19:57:24 <thoughtpolice> s/header/interface/
19:58:43 <carter> johnw: inlinable!= inline
19:58:46 <carter> :)
19:59:00 <thoughtpolice> johnw: well, it's hard to say either way if the library is huge (since the resulting code will be gigantic as hell, so just verifying it can be tedious). i suppose one 'thing' you could do for example is try only moving parts of the assembler out into the separate module to see if it has an impact
19:59:51 <thoughtpolice> e.g. if A depends on B, try taking a set of functions (not all of them) from B and sticking them in A, and see if you can reproduce your performace improvements.
20:00:45 <thoughtpolice> or just move all of B into A, and then take parts out slowly. with a gigantic module testing this kind of stuff is tedious. this also isn't guaranteed to work I suppose; it's sort of like a shitty approach to bisecting the optimizer to seeing what it's doing.
20:02:00 <dolio> Is the issue separate modules or separate packages?
20:02:09 <dolio> He said separate packages.
20:02:54 <thoughtpolice> dolio: well, I read 'If I compile all the code together in one module, I run at 105kops/sec.
20:03:01 <thoughtpolice> keyword being 'module'.
20:03:12 <dolio> Oh. Yes, that would be different.
20:03:49 <thoughtpolice> so /me isn't sure. I'd have to look at the code anyway to have any idea of what's going on. (and currently I'm getting grey hair from the AMP changes I'm trying to finish.)
20:04:20 <HeladoDeBrownie> thoughtpolice, you mean in your own package or are you involved in GHC or something?
20:04:33 <carter> HeladoDeBrownie: thoughtpolice works on ghc
20:04:36 <HeladoDeBrownie> Ah, neat
20:04:46 <carter> he's the patron saint of ghc for the year
20:04:48 <carter> ish
20:04:50 <carter> :)
20:04:51 <HeladoDeBrownie> \o/
20:05:47 <carter> HeladoDeBrownie: 7.10 has some awesomer abstractions wrt functor/applicative/monad, and austin's doing the heavy lifting to shake out the implications of that for all of ghc base
20:05:59 * carter thanks the thoughtpolice 
20:06:20 <HeladoDeBrownie> carter, when you say "awesomer abstractions" are you referring to something besides implementing the AMP?
20:06:28 <carter> well yeah
20:06:32 <carter> thats the heavy lifting :)
20:07:24 <thoughtpolice> HeladoDeBrownie: yes, about half of my job (or more) is working on GHC. including wonderful things like implementing library proposals, maintaining lots of platforms, merging patches, and herding cats. occasionally I will actually fix bugs, and more rarely I will actually add features (not like GHC doesn't have enough features already :)
20:07:59 <HeladoDeBrownie> thoughtpolice, though I'm not personally aware of your contributions, I'm sure I appreciate the work you've done
20:08:09 <HeladoDeBrownie> and the other GHC developers
20:08:42 <Exio4> sounds like an awesome job!
20:09:23 <HeladoDeBrownie> Hmm, what's the process by which it's decided that new things go into GHC?
20:10:48 <carter> HeladoDeBrownie: commmunication and engineering
20:11:17 <carter> if you really want something, and you do the leg work to get folks to be on board with it, and do some of the lifting,
20:14:52 <thoughtpolice> HeladoDeBrownie: pretty much what carter said, people propose things, feedback loop, it gets merged. now, *how* that happens, I still don't know actually :) considering there are only two people who actually work on GHC in any paid capacity (me and Simon), I'm rather surprised at how often people seem to just randomly pop up and implement cool new stuff with such regularity.
20:15:29 <thoughtpolice> and me and simon only add up, roughly, to one full-time person, so it's even more impressive considering that :)
20:16:19 <carter> yeah, and its important to remember that ghc is just a big ole haskell code base
20:16:25 <carter> its just haskell code
20:16:27 <HeladoDeBrownie> thoughtpolice, a lot of people seem to care about GHC :)
20:16:41 <HeladoDeBrownie> Though I've heard horror stories about how long it takes to compile
20:16:44 <shachaf> thoughtpolice: whoa
20:16:59 <shachaf> maybe i should do my part
20:17:14 <HeladoDeBrownie> thoughtpolice, do you know of any low-hanging fruit?
20:17:15 <carter> HeladoDeBrownie: not really
20:17:22 <carter> it takes a while to do a full build
20:17:29 <thoughtpolice> HeladoDeBrownie: there's a lot in the bug tracker, actually
20:17:29 <carter> but any large code base does
20:17:41 <carter> HeladoDeBrownie: whats your backgroudn?
20:17:55 <carter> it helps to focus on one area  / piece to get started
20:17:57 <thoughtpolice> shachaf: you definitely should, you already submitted some patches on Phabricator!
20:18:06 <HeladoDeBrownie> carter, semi-good with Haskell I guess? I'm just dwcook with a new nick, you've probably seen me in here
20:18:35 <Fuuzetsu> you should use your old nick
20:18:39 <HeladoDeBrownie> Fuuzetsu, why's that?
20:18:45 <thoughtpolice> shachaf: for example, I would like -XDependentTypes already. you should definitely work with Richard on that :P
20:18:51 <HeladoDeBrownie> I do have a reason for changing it but I'd be interested to hear why to keep it
20:19:00 <Fuuzetsu> however heard of HeladoDeBrownie before? dwcook is basically e-famous
20:19:33 <HeladoDeBrownie> Fuuzetsu, I wouldn't go as far as saying that
20:19:36 <Fuuzetsu> s/however/whoever/*
20:19:43 <thoughtpolice> HeladoDeBrownie: https://ghc.haskell.org/trac/ghc/wiki/Newcomers
20:19:47 <HeladoDeBrownie> thoughtpolice, thanks
20:20:18 <HeladoDeBrownie> Fuuzetsu, I've dealt with a nick change before with relatively little hassle, I think I'll manage again. Thanks for your opinion though.
20:20:20 <thoughtpolice> HeladoDeBrownie: in particular, ticket #2258 and #4114 would both be quite easy to implement I imagine.
20:20:30 <thoughtpolice> (they're basically the same thing)
20:20:40 <HeladoDeBrownie> thoughtpolice, I'll have a look and see if it's something within my ability and that I'll have the focus for
20:21:49 <Fuuzetsu> RIP dwcook
20:24:00 <mietek> Is there a better way to write this?
20:24:23 <mietek> fooM >>= \case { True -> barM ; False -> return () }
20:24:51 <mietek> I thought this should work:
20:25:00 <copumpkin> :t when
20:25:01 <lambdabot> Monad m => Bool -> m () -> m ()
20:25:04 <mietek> Yeah...
20:25:42 <copumpkin> fooM >>= flip when barM
20:26:03 <thoughtpolice> on that note, I think 'whenM' has been proposed several times too, hasn't it?
20:26:26 <dfeuer> thoughtpolice, as a newcomer, I think that newcomers guide leaves much to be desired, both in completeness and in organization of existing material.
20:26:39 <thoughtpolice> i imagine it didn't make it due to Fairbairne thresholds or whatever, although recently edwardk established the co-Fairbairne threshold  :P
20:26:43 <dfeuer> No offense intended to whoever wrote it, of course. It's a good start.
20:26:54 <mietek> copumpkin: huh.
20:26:59 <mietek> So I did try that first
20:27:05 <mietek> But I couldn't get the syntax to work out, apparently
20:27:16 <mietek> http://pastie.org/private/oqcgumha1srp7fvbbq0y7w
20:27:19 <mietek> This works
20:27:54 <thoughtpolice> dfeuer: it could probably be improved a lot, yes
20:28:00 <thoughtpolice> the wiki needs some cleanup in this area
20:28:18 -bb010g(uid21050@gateway/web/irccloud.com/x-dvjrywwgesnlboxs)- Notice
20:28:27 <bb010g> Sorry, wrong channel
20:28:29 <dfeuer> As I still have no clue how to manage the process of working on GHC stuff, I am not the one to attempt to fix that.
20:28:39 <dfeuer> WHOOOOPS.
20:29:07 <mietek> copumpkin: http://pastie.org/private/o4dapqgmwpivjvyayzx4tq -- this doesn't, and I have no idea how to place parens in it to make it work
20:29:29 <mietek> As in, I tried a few combinations ;)
20:29:59 <mietek> thoughtpolice: what should be the type of whenM?
20:31:02 <thoughtpolice> whenM :: Monad m => m Bool -> m () -> m ()
20:32:14 <dfeuer> mietek, did you try any permutations?
20:32:24 * dfeuer is in a weird mood.
20:32:38 <mietek> ha!
20:33:09 <mietek> thoughtpolice: right. Makes perfect sense.
20:34:38 <slack1256> Did lens subdume Uniplate effectibly?
20:35:11 <carter> yes/no
20:35:22 <carter> depends on if you want lens
20:35:36 <shachaf> lens has replacements for some parts of uniplate
20:36:16 <shachaf> Not everything but a fair amount. And in many cases lens's implementation can be more efficient.
20:37:24 <slack1256> So I could just learn lens and get more bang for buck.
20:38:22 <slack1256> But uniplate was also seen as an alternative to syb. The same could be said then that Lens subdumed syb too.
20:39:15 <shachaf> uniplate certainly doesn't replace all of syb, and it has a different API
20:39:48 <shachaf> lens has almost the same API as uniplate for most things
20:40:10 <shachaf> Look at the .Plated documentation and see.
20:41:21 <Abathurr> infuriating
20:42:02 <slack1256> Ok
20:46:22 <carter>  i've beeen very happy when i've used .Plated
21:06:43 <octopuscabbage> why am i getting the error "Trying to get the (8,0) element from a 10x10 matrix." using hte matrix from Data.Matrix
21:06:51 <octopuscabbage> shouldn't that be a valid usage?
21:06:56 <octopuscabbage> or do i not understand matricies or something
21:07:35 <HeladoDeBrownie> octopuscabbage, it's 1-indexed
21:07:42 <octopuscabbage> well i see now
21:11:26 <benzrf> bye
21:13:06 <octopuscabbage> in matrix is y up or y down
21:13:20 <octopuscabbage> +y up i should say
21:14:41 <mkrtem> (1,1) is the top left corner of a matrix. (I've never used that library, but it would be weird if it was anything else)
21:15:31 <octopuscabbage> is the indexing [1,size] or [1,size)
21:15:54 <spott> so, I can pattern match on an empty list... can I pattern match on an empy Vector?
21:16:29 <enthropy> spott: you could    f (V.null -> True) = whateverYouDoWhenIt'sEmpty
21:16:45 <mkrtem> Again, I'm not sure about that library, but in mathematics an NxN matrix is indexible from 1 up to and including N
21:17:23 <glguy_> spott: No, Vector is abstract
21:17:46 <enthropy> spott: if you use ghc-7.8 you could use -XPatternSynonyms to make that view pattern look like a normal pattern match
21:17:48 <glguy_> The normal way is to use a guard: f v | Vector.null v = ...
21:18:19 <enthropy> glguy is more normal than what I'm suggesting
21:18:41 <spott> ah
21:18:43 <spott> ok
21:18:54 <glguy_> PatternSynonyms are neat, but only usable in 7.8.3 and don't worry well with explicit imports
21:19:07 <glguy_> work well*
21:19:14 <bb010g> Is there a way to use a qualified name in a "binding position" (instance definition here)? I'm trying to define Control.Monad.>>=, but I already have >>= defined as something else.
21:20:05 <enthropy> bb010g: instance Monad T where (>>=) = f -- actually picks the right >>=
21:20:09 <HeladoDeBrownie> bb010g, not sure I follow, but you can't choose an arbitrary qualifier, it must correspond to the module it comes from.
21:20:26 <HeladoDeBrownie> Oh, I misunderstood.
21:21:07 <bb010g> enthropy: Cool.
21:21:50 <bb010g> glguy_: I'm really excited for [pattern families](https://ghc.haskell.org/trac/ghc/wiki/PatternFamilies). It'll bring view patterns to a new level of awesomeness.
21:22:29 <SrPx> Where is the definition of the "instance Monad ((->) e) "?
21:22:45 <glguy_> Type:   :i Monad
21:22:45 <glguy_> instance Monad ((->) r) -- Defined in ‘GHC.Base’
21:23:07 <bb010g> @src Monad (->)
21:23:08 <lambdabot> Source not found. My mind is going. I can feel it.
21:23:17 <SrPx> interesting, thanks! glguy_
21:25:33 <bb010g> enthropy: Ok, I tried that but GHC complained about those functions not being visible methods of Monad. I was trying the qualification to elude qualified importing.
21:27:28 <enthropy> bb010g: oh I guess it has to be in scope then? In any case you don't have to qualify it: http://lpaste.net/108542
21:29:50 <bb010g> enthropy: It strikes me as odd, as you normally don't have to have something in scope at all as long as you use it qualified.
21:31:24 <bb010g> You can't do something like ``instance Data.Functor.Functor Foo where`` either. Hmm.
21:31:45 <enthropy> yeah you need to import stuff to have the qualified name in scope
21:31:58 <enthropy> ghci is a bit different in that respect
21:32:52 <bb010g> enthropy: That's why a ``ghci -XRebindableSyntax`` ``let fromInteger = Prelude.fromInteger in Data.Functor.fmap Prelude.id [1]`` works?
21:34:16 <bb010g> Weird. It seems useful to me to be able to use a qualified name to access something from anywhere, but that's just me.
21:34:34 <enthropy> I don't think RebindableSyntax is related to this ghci-only language feature
21:34:43 <bb010g> I guess for types like Data.Set though, it makes sense.
21:34:47 <jle`> btw has anybody tried using rebindable syntax to have a do block that constnatly shifts/changes its definition of (>>) and (>>=) so that every line is of a completely diferent type
21:34:55 <enthropy> you can ":type Data.Function.on", without adding that import
21:35:17 <jle`> i have been playing around with the idea and it sounds kinda fun
21:35:19 <bb010g> I just used RebindableSyntax instead of NoImplicitPrelude; I had it up
21:35:53 <enthropy> I guess some committee decided that files should list all the imports they actually use at the top
21:36:06 <bb010g> I'm a bit disappointed it doesn't carry over to monad comprehensions.
21:39:43 <bb010g> O.O RebindableSyntax carries over into deriving.
21:58:56 <SrPx> Is there any way to read a function from IO?
22:01:56 <enthropy> @hackage hint
22:01:56 <lambdabot> http://hackage.haskell.org/package/hint
22:03:19 <enthropy> SrPx: or maybe the "functions" you are reading are simple enough that you can have a data type (with a derived Read instance) that has an interpreter
22:03:54 <luite> i updated http://hdiff.luite.com/tmp/try-purescript.jsexe/ with some fixes and highlighting, code now available at https://github.com/ghcjs/ghcjs-examples/tree/master/try-purescript
22:04:46 <mietek> Is there a replacement for old-locale?
22:11:33 <lispy> mietek: last time I checked no, but it's been a year or more
22:12:50 <SrPx> enthropy: ty
22:20:31 <solidus-river> jj/ws
22:20:43 <solidus-river> ger, once per day at least, vim dribble makes its way into irc
22:21:21 <HeladoDeBrownie> :!nethack
22:22:12 <jle`> rogue forever
22:22:35 <HeladoDeBrownie> Actually I doubt you could play either from within vim
22:23:20 <jle`> HeladoDeBrownie: scientific method just told me i could
22:23:23 <jle`> :)
22:23:39 <HeladoDeBrownie> Yeah, same here. I said I doubted it, now I no longer do :)
22:24:01 <HeladoDeBrownie> I'm 90% sure you can't do it from within GVim though, which is probably what I was thinking of
22:26:14 <l0cust> I feel like we should take all the vim users and kill all of them
22:26:19 * hackagebot fast-logger 2.2.0 - A fast logging system  http://hackage.haskell.org/package/fast-logger-2.2.0 (KazuYamamoto)
22:26:21 * hackagebot wai-logger 2.2.0 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-2.2.0 (KazuYamamoto)
22:27:04 <HeladoDeBrownie> l0cust, that's an awfully strong reaction. What provoked it?
22:27:18 <l0cust> HeladoDeBrownie: years of dealing with Vim assholes
22:27:31 <l0cust> HeladoDeBrownie: and lectures from rms
22:28:15 <HeladoDeBrownie> I somehow doubt that being rude and using vim correlate. Perhaps you noticed them *because* they were rude?
22:28:36 <Enigmagic> indeed, we're not Eclipse users ;-)
22:28:46 <l0cust> HeladoDeBrownie: Oh, it has nothing to do with the fact that they are rude. It's that vim users are simply genetically inferior to us Emacs users
22:29:02 <HeladoDeBrownie> l0cust, that's an even bigger statement and will require even more evidence to corroborate :P
22:29:12 <l0cust> Also, we all know that the only reason anyone uses Vim is because they can't figure out how to exit out of it
22:29:22 <swgillespie> lol
22:29:32 <Enigmagic> our computers are too slow to wait for Emacs to load
22:29:34 <HeladoDeBrownie> I can exit Vim just fine, thank you, it's called the power button
22:29:48 <jle`> will there be a day where hlint etc. can detect redundant specialization of typeclasses
22:29:53 <l0cust> With Emacs, it's as easy as C-c M-apple C-q C-m M-f C-z
22:30:03 <jle`> for example, if you parameterize over Applicative f, but all you do is (<$>)
22:30:04 <jle`> or fmap
22:30:14 <jle`> it can say: "Applicative used, but you could have just used Functor"
22:30:42 <jle`> or MonadState but all you do is (>>=)/return, "MonadState used, but you could have just used Monad"
22:31:04 <swgillespie> emacs - eleven megs and constantly swapping
22:31:27 <c_wraith> eleven megs swaps these days?
22:31:31 <HeladoDeBrownie> jle`, so, the idea would be detect if some arbitrary expression is equivalent to fmap?
22:31:39 <HeladoDeBrownie> (for example)
22:31:48 <jle`> HeladoDeBrownie: no, it's if you do Applicative f => f a something blah, but all you do is use fmap
22:31:55 <jle`> you never use pure or (<*>)
22:31:57 <swgillespie> c_wraith: that's an old acronym :p
22:32:13 <jle`> or if you parameterize on MonadState s m => .., but all you ever do is (>>=)/return and you never use get/put/modify/gets/etc.
22:32:15 <HeladoDeBrownie> jle`, that does sound easier. So to clarify, you don't also mean things like saying that you could use fmap instead of liftA?
22:32:22 <jle`> oh yeah no, i do'nt mean that
22:32:31 <jle`> it's if you literally use fmap and all you use is fmap
22:33:07 <HeladoDeBrownie> Sounds like it could be handy. I'd also be interested in a tool that tells you when you use a Monad when you didn't need anything more than a Monoid. :P
22:33:22 <HeladoDeBrownie> Would be more complicated, naturally
22:33:33 <HeladoDeBrownie> s/icated/ex/
22:40:05 <Welkin> or you just just use lambda functions!
22:40:11 <Exio4> would you use a hashtable (like this code) for storing the per-user "buffer"? or how would you do this in HS? https://github.com/EXio4/IPoIRC/blob/master/src/irc_events.c#L52
22:40:18 <Welkin> everywhere
22:40:20 <Welkin> for everything
22:41:20 * hackagebot monad-logger 0.3.7.1 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.7.1 (MichaelSnoyman)
22:41:22 * hackagebot wai-extra 3.0.1.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.1.2 (MichaelSnoyman)
22:42:44 <Exio4> (the per-user stores a partial (or "unfinished line") base64, or if it is a "full string", it parses it, does something with the data, and then "cleans" the buffer)
22:43:08 <HeladoDeBrownie> Exio4, wouldn't have to be a hash table, but a map in general would work, yeah
22:43:44 <HeladoDeBrownie> What's this buffer store?
22:44:02 <Exio4> uhm?
22:44:09 <HeladoDeBrownie> What's being buffered?
22:44:50 <Exio4> it is a raw IP packet, because you can't just send the whole IP packet, it sends it in parts (and base64'd)
22:45:18 <HeladoDeBrownie> Hmm, seems like something that'd be handled by the API of the network package
22:45:28 <HeladoDeBrownie> s/API/implementation/
22:45:43 <Exio4> i don't think any network package has a "get_ip_packet_from_irc_channel" :P
22:45:45 <HeladoDeBrownie> Unless I misunderstood
22:45:56 <HeladoDeBrownie> Oh I did then. It's an IRC-specific thing?
22:46:27 <Exio4> HeladoDeBrownie, it is some kind of peer-to-peer "vpn" that uses IRC, just some weird toy
22:46:33 <iteratee> Fuuzetsu: I cabalized it for you.
22:47:43 <Exio4> will port it "re-writing" the C app behavior then, then i'll rewrite parts of the code, as needed :P
22:49:23 <HeladoDeBrownie> Exio4, I think a Map YourUserType (Chan YourPacketType) would work. Either Chan or TChan, depending on whether you wanted to use STM
22:50:02 <HeladoDeBrownie> Map is in containers, TChan is in stm, Chan is in base
22:50:15 <Exio4> HeladoDeBrownie, the data i get is a string til i can decode the base64
22:50:28 <HeladoDeBrownie> A ByteString, then
22:50:28 <Exio4> the packet type would be just a wrapper around a string
22:50:32 <HeladoDeBrownie> Or, er
22:50:34 <Exio4> well, yeah, bytestring
22:50:58 <HeladoDeBrownie> Well at least at some point you'll probably be working with a ByteString
22:51:21 * hackagebot iproute 1.3.1 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.3.1 (KazuYamamoto)
22:56:21 * hackagebot wai 3.0.1.1 - Web Application Interface.  http://hackage.haskell.org/package/wai-3.0.1.1 (MichaelSnoyman)
22:56:23 * hackagebot wai-websockets 3.0.0.1 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-3.0.0.1 (MichaelSnoyman)
22:56:25 * hackagebot warp 3.0.0.5 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.0.5 (MichaelSnoyman)
23:02:32 <orion> Are there any types out there with a kind that ends in -> (* -> *) ?
23:04:34 <tac> orion: you mean something like * -> (* -> *)?
23:05:12 <Enigmagic> wouldn't that be the same as `* -> * -> *`?
23:05:16 <tac> yes
23:05:18 <tac> @kind Either
23:05:20 <lambdabot> * -> * -> *
23:05:51 <Iceland_jack> @kind (Either :: * -> (* -> *))
23:05:53 <lambdabot> * -> * -> *
23:06:41 <orion> a ha, thank you
23:12:59 <d3m1g0d-> guys, why can't I use operators in type constructors ?
23:13:00 <d3m1g0d-> http://pastebin.com/CUXaRGRB
23:14:05 <shachaf> That's a method, not a type constructor.
23:14:12 <shachaf> (And please note that not all the people here are "guys".)
23:14:55 <shachaf> In particular it's being defined as a method, since it's in a class definition. But its name starts with :, which makes it look like a data constructor.
23:16:24 * hackagebot mighttpd2 3.1.3 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.1.3 (KazuYamamoto)
23:16:46 <d3m1g0d-> shachaf: none of that made any sense.
23:17:06 <shachaf> Not even the bit in parentheses?
23:17:29 <d3m1g0d-> no ... you can refer as a group of girls as "guys, bla bla bla .."
23:18:42 <Iceland_jack> d3m1g0d-: Try using (.+) instead of (:-:) to answer your question of whether class methods can be operators
23:19:51 <d3m1g0d-> ok, now I'm concerned, OOP terminology in a place where a class doesn't make any sense.
23:20:05 <d3m1g0d-> a second person saying that ..
23:21:12 <Iceland_jack> @src Eq
23:21:12 <lambdabot> class Eq a where
23:21:13 <lambdabot>     (==), (/=) :: a -> a -> Bool
23:21:18 <Iceland_jack> (==) and (/=) are class methods
23:21:51 <d3m1g0d-> so why can't I define my own with special characters ?
23:22:07 <Iceland_jack> You can, like I mentioned with (.+)
23:22:37 <Iceland_jack> Operators starting with a colon (':') are special like shachaf said
23:23:10 <d3m1g0d-> oh ok, it worked, thank you.
23:24:24 <trap_exit> alright, this is what we're going to do: I'm going to paste a link to a a new monad I wrote from scratch. Then, each person who's here must either (1) tell me how it can be improved or (2) say "trap_exit is awesome"
23:24:31 <trap_exit> ready? here we go: https://gist.github.com/anonymous/1d842cb01017127bc293
23:24:46 <trap_exit> it's like the state monad, but you can only change it via apply_diff, and it keeps a lot of changes applied to it
23:26:26 * hackagebot tinylog 0.10.2 - Simplistic logging using fast-logger.  http://hackage.haskell.org/package/tinylog-0.10.2 (ToralfWittner)
23:26:26 <Iceland_jack> trap_exit is awesome!
23:26:45 <trap_exit> damn it, I was hoping there's a way to make the ++ more efficient
23:27:10 <trap_exit> I think the list concat might be O(n^23)
23:27:11 <trap_exit> I'm not sure
23:27:13 <trap_exit> s/23/2
23:27:13 <Iceland_jack> Well you could use difference lists if you want to use []
23:27:33 <Iceland_jack> or switch to a different data type, or do what the Writer monad does and abstract over the actual representation
23:27:55 <trap_exit> hmm, what are difference lists ?
23:28:03 <Iceland_jack> using 'mappend' ((<>)) instead of (++)
23:28:34 <Iceland_jack> @hackage dlist
23:28:35 <lambdabot> http://hackage.haskell.org/package/dlist
23:28:53 <Iceland_jack> trap_exit: Lists with O(1) append
23:29:04 <trap_exit> but my >>= needs concat
23:29:07 <trap_exit> not just append ...
23:29:11 <trap_exit> unless I',m misunderstanding something
23:29:23 <Iceland_jack> You can also use concat with them
23:30:05 <d3m1g0d-> @src Eq
23:30:05 <lambdabot> class Eq a where
23:30:05 <lambdabot>     (==), (/=) :: a -> a -> Bool
23:34:36 <d3m1g0d-> @src (==)
23:34:37 <lambdabot> x == y = not (x /= y)
23:34:58 <d3m1g0d-> @src (/=)
23:34:58 <lambdabot> x /= y = not (x == y)
23:35:05 <d3m1g0d-> wait ... there is some black magic here ...
23:35:53 <d3m1g0d-> is the real implementation of == and /= hidden ?
23:36:06 <Iceland_jack> d3m1g0d-: those are the real default implementations of (==) and (/=) :)
23:36:07 <mkrtem> I think those are the default implementations
23:36:28 * hackagebot swagger 0.2 - Implementation of swagger data model  http://hackage.haskell.org/package/swagger-0.2 (ToralfWittner)
23:36:28 <flux> btw, how does it know if you're not defining either of them?
23:36:31 <flux> <loop>?
23:36:40 <d3m1g0d-> So if one is defined by the other and vice versa, at what point does this recursion stop ?
23:36:44 <Iceland_jack> flux: since 7.8 there is a MINIMAL pragma
23:36:54 <HeladoDeBrownie> d3m1g0d-, there is no recursion. The instance of Eq defines one or the other.
23:37:00 <HeladoDeBrownie> Or both.
23:37:19 <Iceland_jack> d3m1g0d-: This means that if you define your own Eq instance, you only have to define *one* of those two methods
23:38:25 <HeladoDeBrownie> d3m1g0d-, basically, for a given instance of Eq, that definition of (==) will only be used if the instance does not define (==) itself, and same for (/=).
23:38:43 <d3m1g0d-> oh cool I broke it
23:38:46 <d3m1g0d-> data MyEnum = Op1 | Op2
23:38:46 <d3m1g0d-> instance Eq MyEnum
23:39:08 <d3m1g0d-> no overriding of either of then and "Interrupted"
23:39:11 <HeladoDeBrownie> Yep, *then* you get an infinite and unproductive loop :P
23:39:19 <d3m1g0d-> yea yea, I get it now
23:39:19 <d3m1g0d-> <3
23:39:24 <d3m1g0d-> Thnx
23:39:32 <Iceland_jack> d3m1g0d-: It's defined like this so you can pick which one you actually define
23:39:50 <Iceland_jack> but you could also define the other one trivially exactly like the default definition
23:39:54 <Iceland_jack> but why bother :)
23:40:29 <d3m1g0d-> yes, sir.
23:42:36 <d3m1g0d-> That's weird, LYAH compares Haskell classes to OOP Interfaces, yet still you can implement behavior in them.
23:43:13 <HeladoDeBrownie> d3m1g0d-, it's a far from perfect analogy
23:44:01 <HeladoDeBrownie> typeclasses also let you abstract over things not of kind *, which if I recall Java interfaces don't allow
23:44:08 <HeladoDeBrownie> Someone feel free to correct me
23:44:23 <dmwit> d3m1g0d-: Sufficiently advanced versions of GHC will warn you about incomplete Eq instances.
23:44:28 <dmwit> (and other things)
23:44:42 <tac> the biggest difference I noticed between typeclasses and interfaces is that interfaces "span" the type
23:44:43 <dmwit> There's a pragma to add warnings to classes you author, as well.
23:44:53 <tac> So you can have Num a => a -> a -> a... while that kind of thing is impossible in Java
23:45:08 <dmwit> Heck, even Bounded is impossible in Java.
23:45:13 <dmwit> maxBound :: Bounded a => a
23:45:25 <HeladoDeBrownie> Hmm, static member maybe?
23:45:27 <Iceland_jack> > maxBound :: Word32
23:45:29 <lambdabot>  4294967295
23:45:34 <HeladoDeBrownie> Can Java interfaces specify static?
23:45:37 <Iceland_jack> The return-type polymorphism is the tricky part
23:46:28 <dmwit> d3m1g0d-: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#minimal-pragma
23:46:34 <d3m1g0d-> they look a lot more like abstract classes rather than interfaes.
23:46:36 <HeladoDeBrownie> Haskell is just plain better at polymorphism than the majority of OO languages
23:46:41 <HeladoDeBrownie> as far as I can tell
23:47:00 <dmwit> Haskell is not so good at bounded polymorphism.
23:47:06 <dmwit> But most other kinds, yeah.
23:47:36 <HeladoDeBrownie> Ah, probably a given since Haskell lacks subtyping
23:47:54 <d3m1g0d-> dmwit: oh that's cool !
23:48:15 <trap_exit> do f; g; h <-- is htis (f >>= (g >>= h)) or (f >>= g) >>= h --- this matters when I care about running time, i..e (ls1 ++ (ls2 ++ ls3)) or (ls1 ++ ls2) ++ ls3
23:48:31 <Zekka> trap_exit: Neither
23:48:42 <Zekka> It's (f >> g) >> h (pretty sure it's grouped that way)
23:48:46 <Zekka> let me check though
23:48:54 <HeladoDeBrownie> Probably f >> (g >> h) I'd think
23:49:01 <HeladoDeBrownie> Given the translation of do expressions in the report
23:49:24 <HeladoDeBrownie> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
23:49:37 <trap_exit> Zekka ... HeladoDeBrownie: ... ... round 1 ... ... fight! ... ...
23:49:47 <dmwit> no need to fight
23:49:47 <Zekka> I'm checking the source code
23:49:52 <dmwit> ?undo do f; g; h
23:49:53 <lambdabot> f >> g >> h
23:49:56 <Zekka> It's left-associative
23:49:59 <HeladoDeBrownie> Ah
23:50:15 <HeladoDeBrownie> Well then, I admit I'm wrong and that's that
23:50:17 <Zekka> https://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Base.html#%3E%3E <- infixl 1  >>, >>=
23:50:21 <dmwit> I'm not sure associativity gets involved.
23:50:32 <dmwit> It's not like the desugaring is lexical.
23:50:33 <HeladoDeBrownie> Oh, I don't think that's a correct test, Zekka
23:50:41 <Zekka> Oh, really?
23:50:56 <Zekka> My rationale was that if it desugared directl to f >> g >> h, then the associativity rule would apply
23:50:57 <trap_exit> Zekka wins .... or ... not quite yet ?
23:51:07 <HeladoDeBrownie> Zekka, yes, I would agree with that
23:51:11 <Zekka> You'reright that if it desugars differently then it might not though
23:51:20 <vanila> desugarig will be syntax based, not text based
23:51:49 <HeladoDeBrownie> I'm kind of stumped on how to test this, actually
23:51:57 <Zekka> Write an invalid monad instance and see?
23:52:01 <Zekka> er, unlawful?
23:52:02 <HeladoDeBrownie> Because (>>) is *supposed* to be associative
23:52:05 <HeladoDeBrownie> Zekka, ah, yes
23:52:13 <HeladoDeBrownie> That became obvious to me right after I said that XD
23:52:24 <dmwit> -ddump-simpl is the canonical test
23:52:45 <dmwit> But you really shouldn't need to test.
23:52:50 <dmwit> The Report is quite clear.
23:52:59 <Zekka> What does it say?
23:53:07 <Enigmagic> monads are burritos
23:53:08 <HeladoDeBrownie> dmwit, you mean the part I linked above?
23:53:09 <Enigmagic> :(
23:53:21 <dmwit> Yes, the part you linked.
23:53:38 <Zekka> Oh, you're right. That's fairly unambiguous
23:53:52 <HeladoDeBrownie> dmwit, if it's clear, then it suggests to me that do { f ; g ; h } = f >> do { g ; h } = f >> (g >> do { h }) etc. Right?
23:53:59 <dmwit> right
23:54:16 <HeladoDeBrownie> Okay, I just wasn't sure if I was interpreting that correctly.
23:54:53 <Zekka> Technically my translation would preserve meaning given that a lawful >> is associative, but it's not the one in the spec
23:55:04 <HeladoDeBrownie> Zekka, given that (>>) is associative, we'd *both* be right :)
23:55:51 <vanila> even if they're equal, some times one way is mor efficient
23:56:01 <HeladoDeBrownie> Ah, good point
23:56:05 <vanila> e.g. fmap (f . g) vs fmap f . fmap g
23:56:14 <HeladoDeBrownie> Which is it there? The former?
23:56:27 <vanila> or (x ++ y) ++ z vs x ++ (y ++ z)
23:57:38 <trap_exit> at this point, looking back; I can't imagine why anyone was ever confused with monads
23:58:21 <HeladoDeBrownie> trap_exit, why's that? (I'm not agreeing or disagreeing yet)
23:58:54 <glguy_> You can use this to determine how do-notation works: http://lpaste.net/108550
23:59:10 <glguy_> But maybe I'm too late, i haven't read the full backlog
23:59:15 <c_wraith> Monads are very easy once you thoroughly understand haskell's type system.  Before that...  Well, you're trying to understand the wrong thing.
23:59:51 <jonathanj> how does one go about understanding haskell's type system?
