00:00:24 <alpounet> gamegoblin: https://www.fpcomplete.com/user/thoughtpolice/using-reflection the end of this article might be helpful to you
00:01:24 <alpounet> this lets you make up dictionnaries using the 'reflection' package
00:01:30 <alpounet> and ConstraintKinds
00:02:20 <Abathurr> Tech startups are getting out of control. Hundreds of millions of dollars spent on companies that generate no revenue. It can't last
00:09:36 * hackagebot aeson-utils 0.2.2.1 - Utilities for working with Aeson.  http://hackage.haskell.org/package/aeson-utils-0.2.2.1 (AdamBergmark)
00:09:36 * hackagebot generic-aeson 0.1.0.3 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.1.0.3 (AdamBergmark)
00:19:31 * hackagebot goatee 0.1.0 - A monadic take on a 2,500-year-old board game - library.  http://hackage.haskell.org/package/goatee-0.1.0 (khumba)
00:19:33 * hackagebot goatee-gtk 0.1.0 - A monadic take on a 2,500-year-old board game - GTK+ UI.  http://hackage.haskell.org/package/goatee-gtk-0.1.0 (khumba)
00:19:35 * hackagebot json-schema 0.6.1 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.6.1 (AdamBergmark)
00:24:32 * hackagebot rest-types 1.10.1 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.10.1 (AdamBergmark)
00:24:34 * hackagebot rest-core 0.31.1 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.31.1 (AdamBergmark)
00:24:36 * hackagebot rest-stringmap 0.2.0.2 - Maps with stringy keys that can be transcoded to JSON and XML.  http://hackage.haskell.org/package/rest-stringmap-0.2.0.2 (AdamBergmark)
00:24:38 * hackagebot rest-gen 0.14.2 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.14.2 (AdamBergmark)
00:29:32 * hackagebot bustle 0.4.6 - Draw pretty sequence diagrams of D-Bus traffic  http://hackage.haskell.org/package/bustle-0.4.6 (WillThompson)
00:37:10 <stobix> yo. I'm going through parconc-examples, and it would seem that I don't have Control.Monads.Par.Sheds.Trace installed. Cabal gives me nothing useful. What am I doing wrong? (ghc version 7.6.3)
00:39:10 <stobix> haha, nevermind. Apparently "cabal configure" inside the directory tells me which deps I need to install. Heh. Haskell ftw. :)
00:44:34 * hackagebot fay 0.20.1.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.1.1 (AdamBergmark)
00:46:42 <solidus-river> is there already a bounded function to check if a number is <= x and >= y
00:46:55 <solidus-river> i feel lik ei'm being redundant writing that
00:48:12 <bergmark> solidus-river: i think that would lead to function explosion
00:48:26 <solidus-river> bergmark how?
00:48:36 <solidus-river> i mean its fine i can write it
00:48:42 <solidus-river> just thoguht maybe there was already one in prelude
00:48:59 <solidus-river> \x min max -> x <= max && x >= min
00:49:20 <bergmark> you'd end up with insideInclusive, insideExclusive, maybe you want to use < and >= together in this way too
00:49:45 <solidus-river> ah, i see
00:49:48 <bergmark> also it'd be hard to remember which argument is which
00:49:56 <bergmark> insideInclusive 10 13 15
00:50:36 <bergmark> 13 >= 10 && 13 <= 15 is much clearer
00:50:40 <supki> :t inRange
00:50:41 <lambdabot> Ix a => (a, a) -> a -> Bool
00:50:47 <LordBrain> :t and
00:50:48 <lambdabot> [Bool] -> Bool
00:50:55 <LordBrain> :t all
00:50:56 <lambdabot> (a -> Bool) -> [a] -> Bool
00:51:03 <LordBrain> hmm
00:52:15 <LordBrain> :hoogle inRange
00:52:32 <bergmark> yeah if you tuple up the bounds like inRange the possibility of confusion goes away
00:52:33 <LordBrain> i guess that's not a lbamdabot xommand
00:54:20 <jle`> :hoogle inRange
00:54:25 <jle`> @hoogle inRange
00:54:27 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
01:11:47 <adimit> dumb question: haddock says it's got (n-1)/n coverage on all my source files, so I guess I'm doing something wrong in all of them. How can I find out what's the missing item?
01:12:24 <kvanb> adimit: did you do module coverage?
01:12:28 <kvanb> coverage on data types
01:12:30 <kvanb> constructor, etc
01:12:37 <adimit> kvanb: as far as I know, yes.
01:12:53 <kvanb> I hit 100% easily, so I don't really know what you could be doing wrong
01:13:26 <adimit> kvanb: ideally, I think I'd like haddock to tell me *what* is undocumented, instead of reporting a number.
01:14:51 <jle`> that would be nice
01:15:11 <adimit> kvanb: ah, I was missing a comment over the module declaratation. Thanks for reminding me.
01:15:25 <adimit> (again, would've been nice if haddock just told me that it expects something there.)
01:15:34 <Kinnison_> adimit: According to http://trac.haskell.org/haddock/ticket/258 haddock's HEAD of 10 months ago supports telling you what is undocumented as part of the coverage report
01:16:01 <adimit> Kinnison_: I found that ticket, but I don't exactly know whether haddock's HEAD of 10 months ago is what I'm using
01:16:03 <kvanb> anyhow, we need time in other places
01:16:05 <kvanb> like cabal.
01:16:15 <adimit> (and I'm kinda too lazy to find out.)
01:17:36 <Kinnison_> adimit: The commit containing the code to do it is 9db420f74a0fd4d1abc0d8cee91b2e7877e5a2e7
01:19:05 <Kinnison_> 2.14.0 I think
01:19:47 <adimit> Kinnison_: Thanks. I do have 2.14.0 here. But it still doesn't tell me :-(
01:20:13 <adimit> Maybe I need a newer cabal as well. I'll cabal install cabal-install
01:21:01 <Kinnison_> adimit: It's probably a command line flag
01:21:36 <Kinnison_> adimit: specifically --print-missing-docs
01:24:32 <adimit> Kinnison_: ah, thanks. It looks ugly: cabal haddock --haddock-options=--print-missing-docs.
01:24:35 <adimit> But it works! Thanks.
01:29:39 * hackagebot snaplet-fay 0.3.3.7 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.3.7 (AdamBergmark)
01:31:04 <Spark> hi, tell me about the precedence and associativity of let and ^ in 2 ^ let x = 0 in 3 ^ 4
01:32:18 <jle`> Spark: let and in are keywords defining a syntactic construct
01:32:21 <jle`> let ... in ...
01:32:34 <jle`> where the first part has declarations, and the second part is an expression
01:32:48 <jle`> x = 0 is a declaration
01:32:52 <jle`> x ^ 4 is an expression
01:32:58 <jle`> er, 3 ^ 4
01:33:30 <Spark> why does it parse as  2 ^ (let x = 0 in ((3 ^ 4))
01:33:39 <jle`> oh
01:33:45 <jle`> i didn't see the 2 ^
01:33:46 <Spark> and not 2 ^ (let x = 0 in 3) ^ 4
01:33:49 <jle`> ah
01:33:58 <Spark> or some other thing
01:33:58 <jle`> let ... in ... is implied to go to the end of the line
01:34:19 <Spark> is there a name for that
01:34:29 <Spark> in terms of parsing
01:34:40 <Spark> clearly ^ has greater precedence
01:34:52 <quchen> Let is built-in syntax, it's parsed "before" anything that involves fixities.
01:35:00 <Spark> and if it is left associative, that imples that (2 ^ (let x = 0 in 3)) ^ 4
01:35:07 <quchen> Type annotations and lambdas are similar in that respect.
01:36:08 <Spark> ok so what is the greater theory that encompasses associativity and precedence as i know it from infix operators
01:36:18 <Spark> i mean
01:36:37 <Spark> i can write a recursive descent praser that makes let dominate all the way to the end of the line
01:36:50 <Spark> but is there a principled way of describing that
01:37:26 <Spark> what if there was a unary operator * whose precedence was less than ^
01:37:34 <Spark> a ^ *b ^ c
01:37:48 <Spark> why a ^ *(b ^ c)
01:37:58 <Spark> and not (a ^ *b) ^ c
01:38:04 <quchen> That wouldn't parse.
01:38:17 <quchen> You can't have two infix operators next to each other.
01:38:42 <Spark> * and + are infix operators, yet I can say 1 * 2 + 3
01:39:05 <quchen> Yes, but you cannot say 1 + * 2, which is what you asked above.
01:39:14 <Spark> * is unary
01:39:16 <Spark> as in C
01:39:44 <quchen> The only unary operator in Haskell is "-" for negative literals.
01:39:53 <quchen> And it typically requires parentheses.
01:40:08 <Spark> ehat's the precedence for unary -
01:40:22 <hyPiRion> > -1 - -2
01:40:23 <lambdabot>  Precedence parsing error
01:40:23 <lambdabot>      cannot mix ‘GHC.Num.-’ [infixl 6] and prefix `-' [infixl 6] in the same ...
01:40:27 <quchen> > -1 ^ 2
01:40:29 <lambdabot>  -1
01:40:34 <raveline> hello !
01:40:51 <Spark> 2 ^ -3 ^ 4
01:40:58 <Spark> >2 ^ -3 ^ 4
01:40:59 <quchen> Unary "-" is a special case in the syntax. I don't know how exactly it parses so I always parenthesize it.
01:41:06 <Spark> > 2 ^ -3 ^ 4
01:41:07 <lambdabot>  Precedence parsing error
01:41:07 <lambdabot>      cannot mix ‘GHC.Real.^’ [infixr 8] and prefix `-' [infixl 6] in the same...
01:41:08 <Kinnison> adimit: You're very welcome
01:41:09 <jle`> it's not really an associativity thing; that's like comparing the associativity with { } in C, compared with +/-
01:41:22 <jle`> you can't do while + { 4; } -
01:41:34 <jle`> while, {, and } are syntax constructs
01:41:51 <jle`> it's not that while { has a "stronger precedence"
01:42:15 <jle`> ...i'm not sure if i am making any sense
01:42:17 <jle`> i should sleep :)
01:42:35 <Spark> nah because while has other tokens
01:42:54 <Spark> in particular it involves either { } for the body, or a terminating ; for the body
01:43:04 <Spark> which means this situation does not arise
01:43:25 <Spark> if you see a { after the while (cond), you know to look for the corresponding }
01:43:29 <jle`> you can think of \n as the "}" for let ... in ... <newline>
01:43:33 <raveline> I have a question about monad transformers... I'm trying to learn how to use them but I have a very hard time defining types while using them.
01:43:36 <Spark> if you don't, you look for the first ;
01:43:52 <Spark> jle`: \n is meaningful?
01:43:54 <quchen> Spark: If you really want the precise rules for parsing, you'll have to look in the Report. I haven't heard of an easier way.
01:43:59 <raveline> Can someone give me pointers ?
01:44:10 <Spark> quchen: i'm actually looking for a general understanding, beyond haskell
01:44:12 <jle`> the report isn't too detailed on this, i think :/ flipping through it now
01:44:18 <Spark> they didn't teach us this in boot camp
01:44:28 <jle`> Spark: yes, in let ... in ..., the second ... is assumed to go to the end of the line
01:44:36 <jle`> same for lambdas and type signatures, too
01:44:40 <quchen> jle`: Well it defines the grammar Haskell is parsed with
01:44:53 <Spark> so this is like a "special" precedence
01:45:20 <jle`> which don't have a "closing" bracket-thingy
01:45:24 <Spark> or rather, the system in which precedence plays a role, also has this concept of "dominating constructs" that reset the precedence to MAX_PRECEDENCE
01:45:49 <jle`> quchen: yeah, i expect it to be there
01:45:53 <jle`> i must not be looking in the right places
01:47:29 <Spark> abstract or concrete grammar?
01:47:47 <Spark> does ghc use a recursive descent parser?
01:51:13 <jle`> kjjjjjkkkkkkkkkkkkkjjkklllll
01:51:18 <jle`> oh sorry
01:51:21 <jle`> >_> ssh lag
01:51:24 <Spark> zerg rush?
01:51:37 <nomeata> jle`: that’s a low-entropy password you are using there
01:52:07 <jle`> nomeata: that's how i throw them off
01:52:43 <Spark> I just found out what happens if you google "ezrg rush"
01:52:47 <Spark> don't google zerg rush
01:52:56 <Tjr> jle`: looks like (nethack or vi) movement commands
01:53:15 <jle`> Tjr: you're right :)
01:53:28 <jle`> was wondering why vim wasn't working...and decided to check out my other tmux windows
01:53:38 <jle`> then it all came at once
01:54:07 <hvr> is it possible to define a #-kinded identity function in GHC? e.g. something like
01:54:17 <hvr> id# :: forall (x :: #) . x -> x
01:54:38 <hvr> (or even a polykinded identity)
01:55:39 <tdammers> nomeata: what are you talking about? my go-to password for everything is 1111, and I haven't been hacked... I think...
01:55:41 <ddrone> raveline: Can you elaborate on what problems do you experience while defining types? And what sort of information do you want to get pointers to
01:57:03 <hyPiRion> tdammers: nobody expects the fourth `1`
01:58:18 <tdammers> hyPiRion: indeed. I'm getting some weird e-mail replies lately though
01:58:45 <tdammers> and I see all those reddit posts I can't remember ever writing
01:58:52 <tdammers> and sometimes my mouse cursor moves by itself
01:59:08 <tdammers> there's also some weird activity on my credit card
01:59:19 <tdammers> but I'm sure none of that is related in any way
01:59:21 <tdammers> ;)
01:59:48 <hyPiRion> tdammers: I hate when that happens, but you get used to it
02:02:40 <quchen> Why is there no Lift instance for Double in TH?
02:02:52 <quchen> [| 1.234 |] should be well-defined, no?
02:08:08 <raveline> ddrone : Yes ! I'm trying to have a monad transformer to give any monad the Reader abiity
02:08:33 <raveline> The idea is to carry inside the reader information about a HDBC IConnection
02:08:52 <raveline> I'd like to be able to define a type just to do that, let's call it "WithDB" for instance
02:09:52 <raveline> But if I try this line :
02:09:58 <raveline> type WithDbT m = (IConnection c) => ReaderT c m
02:10:24 <raveline> The compiler yells at me : "Illegal polymorphic or qualified type"
02:10:34 <therp> hvr: oh hi!
02:10:37 <raveline> I'm not sure I understand exactly what this means, I have to admit !
02:11:55 <jle`> raveline: what's wrong with type WithDbT m = ReaderT c m ?
02:12:59 <raveline> jle` : Well, "c" will not be in scope, no ?
02:13:24 <jle`> oh yeah
02:13:35 <jle`> i mean, type WithDbT c m = ReaterT c m
02:13:43 <raveline> haaaaa
02:13:50 <jle`> unless you really want it to be existentially qualified
02:14:05 <raveline> no I don't really need to, I'll just have to qualify it in the function signature using it I guess
02:14:05 <jle`> er, quantified
02:14:23 <jle`> raveline: well...i mean...you probably need access to it
02:14:29 <jle`> in any functions you use it on
02:14:53 <jle`> are you in mtl or transformers?
02:14:57 <raveline> mtl
02:16:09 <jle`> you can just use make your functions parametric over the MonadReader typeclass
02:16:15 <jle`> which ReaderT c implements
02:16:20 <jle`> ...in practice, that is
02:16:51 <jle`> if you want, there are ways so that you don't have to put the `c` into your function type signatures, and assume it is qualified over all c
02:17:01 <jle`> but this sort of not really encouraged style
02:17:34 <raveline> hmmm no I'd like to stay in encouraged style :)
02:17:54 <jle`> the reasons for doing this would usually be stronger than just to conveniently leave it off
02:18:10 <jle`> ok then :)
02:18:19 <raveline> I'm going to try with the signature you suggest - it's not very expressive (if "c" is anything, it's not really "withDB", is it ?), but it should save me a bit of typing :)
02:18:30 <bennofs> Would it be possible to implement a tool that rebuilds all libraries with profiling, but only builds the profiling version of the library, because it can reuse the non-profiling version?
02:18:36 <ddrone> raveline: I think you don't even need to define your type synonym
02:18:55 <jle`> well in its current state, type WithDbT = ReaderT
02:19:03 <ddrone> You will have to write type signatures like :: (IConnection c, MonadReader c m) => blah
02:19:44 <raveline> jle` : yes... that's not ideal...
02:19:47 <jle`> raveline: yeah; i can see why it would make sense.  but haskell types really aren't "meant" i guess to be used that way
02:19:49 <ddrone> IMO these will give enough context that you are working with database connection
02:20:09 <raveline> ddrone : My issue is that if I do a long monad stack, it's going to be a painful signature to read
02:20:25 <jle`> if that's the case, you might want to try aliasing your instance constraints
02:20:46 <jle`> type MonadDbt c m = (IConnection c, MonadReacer c m)
02:20:49 <jle`> ...i think that works
02:21:11 <jle`> you need to turn on ConstraintKinds
02:21:11 <ddrone> raveline: OK, so let's say that you want to have several transformers
02:21:28 <raveline> jle` didn't know you could do that, I'm going to see how ghci handle this...
02:21:38 <ddrone> You can define type synonym like so: type DbContext = ReaderT (StateT (MaybeT ...
02:21:44 <jle`> so you can add a bunch of MonadState, MonadRader, etc. constraints
02:21:47 <jle`> and then your final function would be
02:21:50 <ddrone> And then use concrete type in type signatures
02:21:56 <jle`> :: MonadDbConstraints c m => ...
02:22:33 <jle`> basically you are defining an alias for a group of constraints
02:22:48 <jle`> constraints form a monoid too, so you can add on arbitrary constraints too if your function needs it
02:22:50 <raveline> ddrone : In your ReaderT (StateT (MaybeT ...), where do I define the "r" of ReaderT ?
02:23:03 <raveline> jle` : Wow, that's pretty cool, I didn't know constraints could be aliased !
02:23:18 <ddrone> raveline: I've meant ReaderT r (StateT s (MaybeT ...))
02:24:05 <jle`> raveline: i'm not sure the consensus has been formed about whether or not it's a good idea
02:24:13 <jle`> i've been seeing it pop up in various codebases and blog posts
02:24:24 <ddrone> raveline: You can have "r" as a parameter of DbContext or specify concrete type if you don't need it to be parametric
02:24:27 <jle`> but i still think that it's a fairly new thing
02:24:42 <jle`> as in, a fairly new "thing" to do, trend-wise
02:24:47 <raveline> jle` : OK, I'll remember that. But I think it's a pretty good idea for long constraints.
02:24:54 <jle`> no doubt
02:25:22 <jle`> i can see why it might be difficult to read if you keep on having to reference the alias definition
02:25:23 <raveline> ddrone : OK ! I think I got it now !
02:25:42 <jle`> but in general haskell data types aren't meant to realy "hold constrained things"
02:25:48 <raveline> jle` : I guess it only makes sense for long and frequently used constraint
02:26:40 <jle`> you can existentially quantify your `c` in your first type synonym, but you wouldn't be able to ever access it in your functions
02:27:07 <jle`> at least directly
02:27:09 <jle`> it's a weird world
02:27:25 <int3__> could anyone shed some light on this comment? http://www.reddit.com/r/haskell/comments/185k0s/what_makes_comonads_important/c8c1smr "comonads that cache their results" sounds like it could be useful for what I'm doing, but I have no idea what it means to 'happen to live in a Kleisi category.' some basic examples of caching comonads would be great.
02:27:26 <jle`> and it behaves very differently than how people might initially expect
02:27:34 <raveline> jle` It takes some getting used to :)
02:28:01 <jle`> yeah.  and existential quantification is in general discouraged as an anti-pattern
02:28:10 <jle`> there are cases where it is useful
02:28:53 <MP2E> int3__ : a Kleisli category is a Monad, there is no difference. As for caching comonads, I haven't heard that term used per se but perhaps they mean memoized comonads?
02:29:21 <raveline> jle` and ddrone : Ok, thanks to you I think I have a much clearer picture of how to handle this !
02:29:26 <raveline> Thank you very very much !
02:29:30 <jle`> np!
02:30:08 <MP2E> wait wtf
02:30:19 <Tjr> monads are a pretty natural thing from a software point of view, but how do you describe them in terms of category?
02:30:19 <MP2E> I read the comment int3__ and now *I'm* confused :P
02:30:45 <int3__> MP2E: hahah okay. well at least now I know what Kleisi categories are.
02:31:29 <MP2E> ohhh okay distributive law to combine them is bad, a comonad that also happens to be a monad is good
02:31:32 <MP2E> interesting
02:32:32 <quchen> Tjr: It's a Functor that has two additional operations, return and join, that satisfy the monad laws.
02:32:59 <quchen> return is often called η, and join μ.
02:33:52 <MP2E> int3__ : btw a good reference on memoized comonads, and really comonads in general : https://www.fpcomplete.com/user/edwardk/cellular-automata
02:34:14 <teakay> hey guys.  Really simple aeson lens question ...  how would I go about changing the value of eg a in "{\"a\": "a", \"b\": 2}" ?
02:34:15 <MP2E> same person wrote this that wrote your comment actually hehe
02:34:36 <teakay> was trying to see if i could figure out how to use them without digging into the types at first
02:34:54 <teakay> which has failed so far
02:35:09 <int3__> MP2E: ah, thanks! I've read sigfpe's cellular automata blogposts, but this looks way more detailed
02:35:15 <lfairy> teakay: there should be something named "key" or similar
02:40:04 <teakay> yea found key but still couldnt get it to work
02:40:12 <teakay> let me have another crack at it
02:43:31 <jle`> teakay: you're using over/(%=), right?
02:43:40 <jle`> unless you wanted to set it
02:45:44 <teakay> no i just want to set it
02:46:12 <jollygood> what immutable array module is generally recommended, array or vector?
02:46:13 <teakay> really simple ie go from {a: "a", b: 1 } to eg {a: "aa", b: 1}
02:46:30 <jle`> teakay: how do you do that?
02:46:44 <jle`> you can use set with whatever lens you used
02:47:02 <quchen> jollygood: Vector has a much nicer API. Not sure about performance, but Vector has a great fusion framework that I imagine is hard to beat.
02:47:41 <lfairy> teakay: try .~
02:47:44 <lfairy> :t (.~)
02:47:46 <lambdabot> ASetter s t a b -> b -> s -> t
02:48:38 <jollygood> I will be using it to represent a chess board by the way. I am not sure if I should go with a flat or nested vector
02:49:06 <quchen> jollygood: You can also use Ix manually with Vector to get 2D vectors.
02:50:58 <jollygood> I am not quite sure what you mean by that?
02:51:08 <jle`> vectors that you access with tuples
02:51:15 <jle`> v ! (0, 3)
02:51:28 <jle`> instead of (v ! 0) ! 3
02:51:40 <jle`> or whatever the vector indexing operator is
02:52:00 <teakay> jle`: thats what im trying to figure out... i was trying something like this json ^. key ("a") .~ Just "aa"
02:52:20 <jle`> teakay: oh i thought you said 'it was really simple to go from' ... heh.
02:52:27 <jle`> misread, sorry.
02:52:44 <jle`> you should have an & there
02:52:46 <jle`> instead of ^.
02:52:48 <jle`> i think
02:53:15 <supki> :t key
02:53:17 <lambdabot> (AsValue t, Applicative f) => Data.Text.Internal.Text -> (aeson-0.7.0.3:Data.Aeson.Types.Internal.Value -> f aeson-0.7.0.3:Data.Aeson.Types.Internal.Value) -> t -> f t
02:53:33 <supki> json & key "a" .~ "aa"
02:54:00 <jle`> > "ae5f" & hex *~ 2
02:54:02 <lambdabot>  "15cbe"
02:55:09 <jle`> remember you are really doing set (key "a") "aa" json
02:55:19 <jle`> (.~) = set
02:55:22 <jle`> so
02:55:27 <jle`> (key "a" .~ "aa") json
02:55:32 <jle`> flip with &
02:55:40 <jle`> json & key "a" .~ "aa"
02:58:47 <pamojarpan> Hi, I have a problem with JuicyPixels:
02:58:57 <pamojarpan> fn :: (P.Pixel pixel) => (Double, Double, Double) -> Int -> Int -> pixel -> (Double, Double, Double)
02:58:57 <pamojarpan> fn (a', b', c') _ _ ((P.PixelYCbCr8 a b c)) = (aa, bb, cc)
02:58:57 <pamojarpan>     where
02:58:57 <pamojarpan>         f a b = (fromIntegral a :: Double) +(fromIntegral b :: Double)
02:58:57 <pamojarpan>         aa = f a a'
02:58:57 <pamojarpan>         bb = f b b'
02:58:59 <pamojarpan>         cc = f c c'
02:59:11 <pamojarpan> fn :: (P.Pixel pixel) => (Double, Double, Double) -> Int -> Int -> pixel -> (Double, Double, Double)
02:59:11 <pamojarpan> fn (a', b', c') _ _ ((P.PixelYCbCr8 a b c)) = (aa, bb, cc)
02:59:11 <pamojarpan>     where
02:59:12 <pamojarpan>         f a b = (fromIntegral a :: Double) +(fromIntegral b :: Double)
02:59:14 <pamojarpan>         aa = f a a'
02:59:17 <pamojarpan>         bb = f b b'
02:59:19 <pamojarpan>         cc = f c c'
02:59:30 <pamojarpan> uch, sorry, re-pasted by mistake
02:59:50 <matematikaadit> @where paste
02:59:50 <lambdabot> Haskell pastebin: http://lpaste.net/
02:59:52 <teakay> thanks jle`, still getting 'No instance for (AsValue (Maybe Value)) arising from a use of ‘key’ ' but at least I'm on the right track now
02:59:54 <jollygood> it seems that neither array nor vector support fixed size arrays, known at compile time. could one even express that in the haskell type system?
03:00:02 <pamojarpan> the problem is Could not deduce (pixel ~ P.PixelYCbCr8)
03:00:05 <pamojarpan> any help?
03:04:06 <jle`> jollygood: yes, i think there is some of that in the linear package
03:04:33 <jle`> it's done using type nats i believe
03:07:07 <alpounet> pamojarpan: you should paste this on http://lpaste.net instead of on IRC directly
03:07:30 <alpounet> much more readable, and doesn't fill our screens :)
03:08:25 <ClaudiusMaximus> pamojarpan: you're pattern matching against a constructor, which forces the type to be less general than your annotation
03:09:14 <pamojarpan> alpounet: sorry
03:10:13 <teakay> are the examples on http://hackage.haskell.org/package/aeson-lens-0.5.0.0/docs/Data-Aeson-Lens.html supposed to work? I keep getting type errors for even the simplest of those.  not sure what I'm missing
03:10:50 <pamojarpan> ClaudiusMaximus: isn't that the expected behaviour? I mean, specify a "general type" and pattern matching on its contructors
03:11:18 <jle`> pamojarpan: do you understand why this doesn't work:
03:11:21 <jle`> foo :: a -> b
03:11:26 <jle`> foo 5 = True
03:11:31 <supki> teakay: no, aeson-lens is long deprecated
03:12:14 <Eva_> hello, any idea about this http://pastebin.com/M9knhcp6 ?
03:12:24 <Eva_> I got an error I can't understand
03:12:30 <Eva_> the code is small
03:12:46 <supki> teakay: up-to-date Data.Lens.Aeson module is in lens package
03:12:49 <tdammers> it says that you need to add Show a as a constraint
03:12:55 <k00mi> teakay: https://www.fpcomplete.com/user/tel/lens-aeson-traversals-prisms
03:13:17 <jle`> Eva_: on line 5, you say "show a"
03:13:28 <jle`> however, you never have any proof that `a` is showable
03:13:34 <tdammers> X a can only implement Show this way for a that also implement Show
03:13:43 <teakay> lol! no wonder I can't get anything to work. thanks supki
03:13:57 <teakay> and jle`. got it now
03:14:25 <tdammers> the way it's written, you are saying that your instance must be valid for every a, including those that are not instances of Show
03:14:48 <Eva_> jle`, isnt it wat gadts are for ?
03:15:05 <Eva_> I mean, in the definition of the ctor X :: (Show a, Num a)=>a->X a
03:15:06 <jle`> Eva_: gadts?
03:15:09 <Eva_> we have Show a
03:15:34 <jle`> i'm not sure if i understand
03:15:40 <jle`> oh sorry
03:15:54 <jle`> yeah, no, this is not what they are for
03:16:58 <jle`> you are limiting the constructors, but that doesn't mean that you have any constraint on the destructor/pattern match
03:17:19 <k00mi> Eva_: there could be other constructors with no Show constraint. The type checker only knows about the constraint on 'a' after matching on X, which is too late
03:19:48 * hackagebot imagesize-conduit 1.0.0.4 - Determine the size of some common image formats.  http://hackage.haskell.org/package/imagesize-conduit-1.0.0.4 (mbrock)
03:24:35 <mbrock> I think the Show instance is fine, right?
03:24:58 <mbrock> given any `X a`, you can indeed do "X" ++ show a
03:25:52 <mbrock> but the Num instance doesn't work, because you're claiming to be able to have an `Integer -> X a` for any a
03:26:22 <k00mi> oh, you're right
03:56:53 <prophile> bees
04:04:37 <mbrock> bees! bzz! we'll see who brings in more honey!
04:13:47 <nomeata> hvr or thoughtpolice: did you see http://www.haskell.org/pipermail/ghc-devs/2014-July/005600.html?
04:13:59 <nomeata> ECHAN
04:27:50 <Robly18> morning
04:28:23 <Robly18> so, uh, small thing
04:28:30 <Robly18> i've been trying to learn haskell lately
04:28:51 <Robly18> and to figure out how much i knew about it, i embarked on a quest to make a monte carlo simulation to find pi
04:29:11 <Robly18> i managed something, but it feels awfully slow and i was wondering if anyone could help me optimize it
04:30:03 <Robly18> here's the code
04:30:05 <Robly18> http://lpaste.net/107653
04:30:07 <Robly18> thanks in advance
04:31:27 <ClaudiusMaximus> Robly18: System.Random is slow, maybe use one of the mersenne twister libraries
04:31:41 <Robly18> never heard of it, let me google it
04:32:58 <Robly18> hm, i'll need to figure out how to do this
04:33:09 <Robly18> up until now i've had guides holding my hand
04:33:27 <Robly18> oh well, how difficult could it be
04:33:34 <Robly18> thanks, by the way
04:33:50 <alpounet> Robly18: you may want to generate your random numbers with the 'mwc-random' package
04:33:52 <alpounet> @hackage mwc-random
04:33:53 <lambdabot> http://hackage.haskell.org/package/mwc-random
04:34:15 <alpounet> it's one of the fastest we have as far as i know
04:34:25 <Robly18> when they said the people at haskell irc were helpful, i didn't think i'd get feedback this fast
04:35:33 <alpounet> Robly18: not mentionning there are libraries for the kind of computations you're doing (monte carlo & what not) too, on hackage, but I suppose your goal is to write the meat of the algorithm yourself :)
04:35:43 <Robly18> heh, yeah
04:36:01 <Robly18> mostly trying to figure out good practice and such
04:36:10 <Robly18> i'm used to imperative languages
04:37:01 <alpounet> yeah, that's a reasonable problem to tackle when learning, I think I actually did the same exercise back when I started learning haskell
04:37:18 <Robly18> it was all going along fine
04:37:21 <Robly18> then i hit IO
04:37:43 <Robly18> i figured, might as well learn by doing
04:39:14 * k00mi wonders if `length . filter inCircle` is fused
04:39:58 * hackagebot rail-compiler-editor 0.3.0.0 - Compiler and editor for the esolang rail.  http://hackage.haskell.org/package/rail-compiler-editor-0.3.0.0 (bubuiic)
04:40:36 <aloiscochard> how does cool kids do `(a -> b) -> (a -> (a, b))`? I found I want to that quite often in my code
04:40:42 <alpounet> Robly18: yeah. but what you've learned so far isn't lost! a common practice is to have a clean separation between the bits that require IO (random number generation or file system access for example) and those that don't (computing the mean of a list of numbers, for example). Then you can tie both by running your IO action that generates numbers and feed the result to your 'mean' function.
04:40:47 <aloiscochard> I'm sure there is a neat way of doing that with haskell
04:41:13 <Robly18> i see, thanks
04:41:17 <alpounet> :t id &&& f
04:41:18 <Robly18> i'll keep it in mind
04:41:18 <lambdabot> (FromExpr c', Show a) => a -> (a, c')
04:41:25 <alpounet> :t \f -> id &&& f
04:41:26 <lambdabot> (a -> c') -> a -> (a, c')
04:41:37 <alpounet> aloiscochard: ^^^
04:41:42 <PatrickRobotham> Does anyone know a good resource for learning functional reactive programming?
04:41:59 <alpounet> &&& is from Control.Arrow
04:42:14 <aloiscochard> alpounet: neat! I thought that should be with Arrow
04:42:35 <aloiscochard> alpounet: that seriously blow my mind, it's still a bit hard to workout why `id` give that behavior, but it's definitely facinating :)
04:43:10 <bernalex> PatrickRobotham: I like elm. it's quick to get started with.
04:43:10 <PatrickRobotham> aloiscochard: You mean something which takes f:a->b, and returns g where g x = (x,f x)/
04:43:30 <Qfwfq> "Type constructor `Universe' cannot be used here (it is defined and used in the same recursive group)" What is a recursive group, in this context?
04:43:34 <PatrickRobotham> Oh, alpounet beat me to the punch
04:44:11 <Qfwfq> :t \f -> ap (,) f
04:44:12 <lambdabot> (a -> b) -> a -> (a, b)
04:44:13 <bernalex> PatrickRobotham: for haskell, consider http://www.haskell.org/haskellwiki/FRP_explanation_using_reactive-banana
04:44:29 <PatrickRobotham> bernalex: Thank you :)
04:44:46 <alpounet> aloiscochard: the best way I know to grasp that kind of thing is to forget that Arrows can be something else than our usual functions (->). Just imagine every "arr" you see as being (->) and write down the types of things explicitly. Then enjoy your "Aha!" moment :p
04:45:33 <alpounet> once you've understood what's going on with (->), feel free to explore arrows in general, but I really strongly advise to do that after you've had the first "Aha!" moment I mentionned.
04:45:37 <aloiscochard> alpounet: nothing can be that "Aha!" feeling, thanks for the help :-)
04:45:44 <aloiscochard> beat*
04:45:53 <Qfwfq> :t ap (,) -- aloiscochard
04:45:54 <lambdabot> (a -> b) -> a -> (a, b)
04:46:00 <aloiscochard> ha!
04:46:09 <alpounet> yeah, that too :)
04:46:17 <aloiscochard> with Applicative then, right?
04:46:30 <aloiscochard> ohhh.. that's the one I saw in dibblego code
04:46:33 <Qfwfq> I think ap required Monad but you can use <*>.
04:46:35 <aloiscochard> ty as well Qfwfq
04:47:35 <Qfwfq> I meant 'requires', but well required prior to Applicative => Monad ;-).
04:47:55 <aloiscochard> I see
04:50:52 <Pythonfant> @where typeclassopedia
04:50:52 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
04:52:13 <aloiscochard> a shame hoogle don't find `ap (,)` or (id &&&)
04:54:35 <int3__> @pl \f a -> (a, f a)
04:54:35 <lambdabot> ap (,)
04:54:44 <int3__> aloiscochard: ^ we have pointless for that
04:56:23 <peterhil> Anybody interested in GUI programming on Mac OS X 10.9 (Mavericks)? I have tried out different solutions, and I just finally got wxHaskell and reactive-banana-wx examples working: https://sourceforge.net/p/wxhaskell/bugs/93/
04:56:54 <alpounet> there's hsqml that looks nice too, if you like Qt
04:58:00 <peterhil> HsQML works great, but Qt Quick and QML has some limitations if you don't know how to extend them with C++. I wan't to make a simple spectrogram application, and getting a scrolling bitmap view requires some custom Widgets or other hackery.
04:58:09 <peterhil> alpounet: I like QT.
04:58:33 <alpounet> peterhil: can't those be defined in qml?
04:58:39 <peterhil> And will probably also try and use HsQML for simpler apps - like wrappers for command line apps.
04:59:16 <peterhil> alpounet: Yeas, you could write these with QML and Javascript, but I would guess handling arrays with JS is cumbersome and slow.
04:59:38 <peterhil> On the other hand, you could make custom QML elements with C++, but I don't want to learn more C++.
04:59:59 <alpounet> if it's processed by V8  I think it should be okay but this claim has yet to be verified
04:59:59 * hackagebot Spock 0.6.1.1 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.6.1.1 (AlexanderThiemann)
05:00:17 <peterhil> Also, I got HTk working, but only about 40% of the examples work, and the code seems really old.
05:01:30 <peterhil> alpounet: Yes, Javascript can be quite fast also, but I'd rather use Haskell or some other compiled language for this spectrogram app.
05:02:27 <peterhil> I want to underline that getting wxHaskell to work on the latest OS X requires wxWidgets 3.0 and not 2.9.5
05:03:02 <peterhil> After trying that almost all of the examples I could find work great - AND I get to use FRP insstead of IO monad and imperative programming!
05:08:19 <peterhil> alpounet: In the version 1 of Qt Quick, there wasn't even a menubar or action widgets (for menu items and toolbar buttons) as everything is so flat and metro nowadays! Now in version 2, those are supported, but it still seems like QML is a work in progress (that I hope Digia will continue, despite of Nokia having been sold to Microsoft).
05:10:38 <alpounet> peterhil: yeah. but to be honest, i've left C++ & Qt a few years ago and haven't looked back, although I actually was at the Qt conference where QML has been announced, I was a happy Qt user in these days. I may take a look though, through hsqml
05:17:18 <aloiscochard> integral: ho! I  forgot that one, cheers
05:35:59 <Qfwfq> "Type constructor `Universe' cannot be used here (it is defined and used in the same recursive group)" What is a recursive group, in this context?
05:37:31 <Eduard_Munteanu> Qfwfq: a group of declarations which are mutually recursive
05:38:07 <Eduard_Munteanu> e.g. type Foo = Bar; type Bar = Foo
05:38:49 <Qfwfq> Hmm, I don't know how that's the case here, but maybe my understanding of type families is broken.
05:39:37 <Eduard_Munteanu> Qfwfq: they're subject to many restrictions you have on simple type synonyms
05:40:14 <Eduard_Munteanu> Qfwfq: can you paste the code?
05:41:09 <Qfwfq> I think this is the relevant declaration. http://sprunge.us/cBGA
05:42:29 <Eduard_Munteanu> Qfwfq: what does natural there splice to?
05:43:34 <Qfwfq> 'Unit (Unit (Unit Void)))
05:43:38 <Qfwfq> Sorry:
05:43:53 <Qfwfq> Like 'Unit ('Unit ('Unit 'Void))) but bigger, I think.
05:44:41 <Qfwfq> Nah, without the promotion.
05:46:08 <Qfwfq> http://sprunge.us/TeMH
05:46:08 <Qfwfq> (data Unit a = Unit a; data Void;)
05:46:13 <Eduard_Munteanu> Qfwfq: and have you defined any instances for that type family? I suspect that's where the recursion is from.
05:47:57 <Qfwfq> No instances yet.
05:48:04 <alpounet> Qfwfq: GHC.TypeLits has the "Nat" kind, whose values can be literals. e.g, 256 :: Nat. You may want to use them
05:49:09 <Qfwfq> alpounet: From what I here, the GHC 7.6 implementation is too weak to permit most type-level arithmetic. But I should test that belief.
05:49:50 <Qfwfq> *hear
05:50:36 <alpounet> yeah the solver can't unify things we would like it to, for arithmetic operations. but are you going to do a lot of these? It somehow looks like the sizes in your case are somehow descriptive
05:50:50 <Qfwfq> alpounet: Have you had much success with them?
05:52:30 <Eduard_Munteanu> Qfwfq: GHC 7.6 simply does not reduce type-level nat arithmetic operations at all, e.g. it can't even deduce n + 0 ~ 0
05:52:39 <Eduard_Munteanu> Er.
05:52:44 <Eduard_Munteanu> n + 0 ~ n :)
05:53:06 <alpounet> when adding up or multiplicating them for a strongly typed linear algebra-ish library, you can be disappointed quickly yeah, but maybe in your case they're enough, or you can at least borrow them but then reify the numbers in "peano form" for arithmetic. not sure what you're giong to do with these numbers
05:55:11 <Qfwfq> You mean 0 + 0 ~ 0?
05:55:49 <Qfwfq> alpounet: Useful in a few other places, yeah.
05:57:04 <Flonk> On the Haskell wikibook, there is an example that demonstrates a space leak
05:57:10 <Flonk> (\xs -> head xs + last xs) [1..n]; (\xs -> last xs + head xs) [1..n]
05:57:18 <Flonk> "The first version runs on O(1) space. The second in O(n)."
05:57:19 <Flonk> How come?
05:57:34 <dsturnbull> hi. is it possible to fold a list of values as arguments for a function? let's say i have f a b c = a * b + c and i want something like foldl f [a, b, c].. any way to do that?
05:58:48 <Eduard_Munteanu> dsturnbull: not easily
05:58:51 <lieven_> it can be done with a tuple instead of a list. see curry and uncurry and curry2, curry3 etc
05:59:03 <Eduard_Munteanu> I can only think of heterogenous lists and such.
05:59:10 <Pythonfant> Flonk: not quite sure, but would say that in the first version it can evaluate head xs and then it doesn't need the rest of the list while going through the list so it can be directly garbage collected
05:59:28 <Pythonfant> if you evaluate last first you need the whole list because your later processing it further
06:00:10 <Flonk> Pythonfant: Okay yeah, that makes sense!
06:00:24 <dsturnbull> Eduard_Munteanu: in my case, the args are all the same type
06:00:42 <bergmark> do you really consider the gc when you talk about space leaks?
06:01:10 <bergmark> ehm, i phrased that poorly
06:01:22 <Pythonfant> bergmark: how would you express it?
06:02:32 <Flonk> @src last
06:02:32 <lambdabot> last [x]    = x
06:02:33 <lambdabot> last (_:xs) = last xs
06:02:33 <lambdabot> last []     = undefined
06:02:40 <bergmark> Pythonfant: n/m
06:04:07 <dsturnbull> lieven_: looks promising, thanks.
06:10:36 <Qfwfq> Eduard_Munteanu: http://sprunge.us/LLIP works; so possibly an incompatability with TH. Will try TypeLits.
06:11:01 <Qfwfq> (Sorry about the timeouts, out my control.)
06:11:25 <carlosgaldino> how to avoid having different cabal versions when doing "cabal install cabal-install" ?
06:12:02 <monochrom> delete other versions
06:12:33 <monochrom> actually, build it in a sandbox. then copy out the executable, throw out the sandbox
06:13:33 <monochrom> do your own simple sandboxing (so you understand what it does): http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox
06:17:09 <mbrock> conduit question: how do I combine two sinks acting on the same input? e.g., Sink i m a -> Sink i m b -> Sink i m (a, b)
06:17:20 <suOya__> what's a Sink?
06:17:25 <suOya__> @src Sink
06:17:25 <lambdabot> Source not found. Where did you learn to type?
06:18:03 <mbrock> (this would be (&&&) if `Sink i m` were an Arrow)
06:18:11 <ajcoppa> suOya__: part of the conduit library. good tutorial here: https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview
06:19:16 <notdan> @ty liftA (,)
06:19:17 <lambdabot> Applicative f => f a -> f (b -> (a, b))
06:19:23 <notdan> @ty liftA2 (,)
06:19:24 <lambdabot> Applicative f => f a -> f b -> f (a, b)
06:19:33 <notdan> mbrock: would that ^ work?
06:19:48 <mbrock> it would typecheck :) but I think the applicative instance doesn't do the right thing
06:20:34 <notdan> hm what would it do than? I am not familiar with conduit specific ,but i used streaming libraries before
06:21:14 <mbrock> it would first feed the `f a` until it finishes, then feed the rest of the upstream to the `f b`
06:21:40 <mbrock> but there is a newtype wrapper called ZipSink whose Applicative has the "fanout" behavior
06:22:05 <mbrock> so I guess that's it
06:23:12 <xpika> does anyoneknow how to pass a ghc flag to cabal?
06:23:34 <supki> xpika: --ghc-options
06:23:36 <xpika>  cabal install -ghcflag?
06:23:42 <mbrock> as an aside, it's pretty tricky to figure out what type class instances actually do... I guess Haddock doesn't let you give documentation for instances?
06:24:13 <mbrock> like, it'd be nice if ConduitM's instance for Applicative was a documented entity, because it provides important and non-obvious functionality
06:24:59 <supki> it's possible to document instances
06:25:03 <supki> nobody does that though
06:25:46 <mbrock> oh, I see
06:26:00 <xpika> supki: crosses finges
06:27:19 <pjdelport> I saw a documented instance just yesterday
06:27:53 <a___> hola amigos
06:28:19 <a___> why would filter (`elem` ['a'..'z'] "some string" take elem as infix function?
06:28:34 <a___> no other function seems to require that treatment
06:28:39 <a___> or am i crazy
06:28:43 <mbrock> > filter (`elem` ['a'..'z']) "some string"
06:28:45 <lambdabot>  "somestring"
06:28:52 <mbrock> > filter (flip elem ['a'..'z']) "some string"
06:28:53 <lambdabot>  "somestring"
06:28:58 <mbrock> > filter (elem ['a'..'z']) "some string"
06:28:59 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[[GHC.Types.Char]]’
06:28:59 <lambdabot>  Expected type: [[[GHC.Types.Char]]]
06:28:59 <lambdabot>    Actual type: [GHC.Types.Char]
06:29:24 <a___> for example you can call elem 2 [1..3] without infix
06:29:37 <mbrock> yeah, it's just a tradition to use elem as an infix thing
06:30:06 <mbrock> some people set up their editor to show `elem` as the unicode set membership operator :)
06:30:21 <a___> mbrock: lol
06:30:45 <a___> but why won't the last iteration compile, if it's only tradition
06:31:02 <a___> filter (elem ...) doesn't compile :(
06:31:43 <carlosgaldino> how can I load pointful on ghci? is that even possible?
06:32:08 <notdan> a___: because elem takse two arguments, 'a' first, '[a]' second
06:32:40 <notdan> 'filter f list' compiles if f : a -> Bool
06:33:11 <notdan> So,elem : a -> [a] -> Bool, flip elem [1,2,3] = `elem` [1,2,3] :: a -> Bool
06:33:19 <notdan> so we can plug that in place of `f'
06:34:07 <mathk> Hi I need an advise with binary-bits. When parsing my structure I need to parse the bit (n+6) in other to correctly parse the [n..n+5] bits. Is there a way to do a lookahead?
06:34:35 <xpika> supki: --ghc-options=-fhpc did not work for me :/
06:34:45 <a___> notdan: interesting, thanks for the explanation
06:35:02 <mathk> or should I use an other library then binary-bits?
06:35:45 <supki> xpika: what's the full command?
06:36:11 <pjdelport> > let (∈) = elem in filter (∈ ['c'..]) "abracadabra"
06:36:13 <lambdabot>  "rcdr"
06:36:55 <xpika> supki: sudo cabal install -w/usr/bin/ghc-7.6.3 --extra-lib-dirs=/usr/lib --ghc-options=-fhpc
06:37:51 <a___> > print "hola pana!"
06:37:52 <lambdabot>  <IO ()>
06:38:17 <a___> > show "hola"
06:38:18 <lambdabot>  "\"hola\""
06:38:22 <a___> hehehe
06:39:20 <supki> xpika: ok, that should pass -fhpc to ghc
06:39:28 <supki> xpika: why do you think it does not work for you?
06:39:32 <bernalex> hm
06:39:52 <bernalex> vim used to tell me about eta reducing. now it suddenly doesn't. anyone care to guess what plugin has borked itself?
06:40:03 <supki> xpika: you can try to pass a non-existent flag to ghc to see if it errors for you (it should)
06:40:04 <bernalex> i.e. it would see that f a b = a + b is the same as f = (+), but no more.
06:40:40 <Tjr> @seen quchen
06:40:40 <lambdabot> qUc|-|eN
06:40:48 <bernalex> oh it still does. it just doesn't understand that specific example
06:40:52 <a___> pjdelport: interesting...
06:41:07 * Eduard_Munteanu wonders where preflex is
06:41:45 <Robly18> hi
06:41:52 <Robly18> i need some help
06:41:57 <Robly18> i'm trying to install a module
06:42:20 <Robly18> but i'm not very well versed in this kinda stuff
06:42:55 <Robly18> how would i go on about doing this?
06:43:11 <xpika> supki: the fake flag did not pass
06:43:20 <xpika> supki: im trying cabal clean this time
06:43:23 <int3__> Robly18: you gotta be more specific
06:43:35 <Robly18> so earlier today
06:43:37 <Tjr> Robly18: the best strategy is to sidestep cabal dll hell altogether.
06:43:50 <Robly18> i came here and long story short i was recommended this random number generator thing
06:44:00 <Robly18> which i've been trying to install to no avail
06:44:03 <Robly18> it's uh.. let me get the name
06:44:05 <Tjr> Robly18: use something like haskell platform or what the fpcomplete people offer for download.
06:44:18 <a___> Robly18: if you have cabal installed (`sudo apt-get install haskellplatform`), you can `cabal install <moduleename>`
06:44:35 <Robly18> i don't have cabal
06:44:44 <Robly18> and also, i'm in windows; might be a bit helpful
06:45:05 <Robly18> the library i'm trying to install is this one:
06:45:07 <Robly18> http://hackage.haskell.org/package/mwc-random
06:45:17 <Robly18> i've downloaded a zip but have no clue on what to do with it
06:46:33 <tdammers> Robly18: get cabal
06:46:46 <Robly18> looking it up
06:47:08 <tdammers> Robly18: ideally, install haskell-platform, which should include everything you need to get started
06:47:12 <int3__> Robly18: if you use haskell-platform (https://www.haskell.org/platform/windows.html) it gets automatically installed
06:47:27 <tdammers> Robly18: then something like cabal update; cabal install whatever-package-you-need
06:47:31 <Robly18> let me check
06:47:40 <Robly18> i'm not sure where i got haskell from now that i come to think of it
06:48:08 <Robly18> aight yeah
06:48:13 <Robly18> i did get it from the haskell platform
06:48:19 <Robly18> what now?
06:48:24 <Robly18> where do i type cabal update?
06:48:30 <Robly18> into cmd? ghci?
06:48:45 <bernalex> maybe there should be a pointfree+poinful plugin for vim. maybe I should write it.
06:48:47 <Robly18> oop, cmd did it i think
06:49:21 <Robly18> and now what?
06:49:41 <Robly18> i do cabal install.. and then do i need to give it the path to the .zip file, the name?
06:49:47 <int3__> `cabal install mwc-random`
06:49:58 <int3__> Robly18: it downloads the package for you
06:49:59 <Robly18> ah
06:50:00 <Robly18> thanks
06:50:02 <tdammers> Robly18: just the name of the package. No need to download the zip; cabal does that for you
06:50:06 <Robly18> thank you so much
06:50:30 <Robly18> is this all then?
06:50:46 <Robly18> is it already installed and all and i can just go on about my buisness?
06:50:53 <int3__> yes, `import System.Random.MWC` should now work in ghci / ghc etc
06:51:01 <Robly18> wow, that was way easier than i expected
06:51:14 <Robly18> thanks
06:51:31 <int3__> np
06:52:31 <Robly18> i was scared it wasn't working for a second; then i realize i should probably restart GHCi
06:53:08 <int3__> bernalex: I would use that; haskellmode-vim purports to have pointless integration but i haven't been able to get it to work
06:55:09 <bernalex> int3__: ghc-mod will see that f a b c = g a b c is f = g, but it won't try to make a pointless zipWith7 or whatever (thankfully).
06:55:10 <darnoc> How does remove the ghc 7.8.3 using the generated Makefile?  I have tried 'make clean' without success?
06:55:42 <popx> darnoc: remove the installed binaries and libraries
06:57:48 <int3__> bernalex: yeah, I do use ghc-mod
06:58:42 <Maxdamantus> darnoc: the rule is usually called "uninstall", but I wouldn't depend on it.
06:59:00 <CapitanK> Is there a config option in GHC to brieviate error messages?
06:59:02 <bernalex> int3__: it would be nice to be able to hit a hotkey on a function to run pointless on it
06:59:14 <bernalex> and pointful for that matter
06:59:46 <int3__> bernalex: yes of course. actually it would be nice for most of the haskellmode-vim features to actually work :P
07:00:07 <int3__> 'insert type signature' works like 20% of the time for me
07:00:13 * hackagebot cabal-rpm 0.9 - RPM packaging tool for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.9 (JensPetersen)
07:02:00 <kvanb> LOL, not haskell related but this guy has shrooms on his github profile. https://github.com/icodeforlove
07:02:42 <systemfault> Haha
07:04:23 <tertl3-laptop> you haskell guys are cray cray
07:04:31 <tertl3-laptop> not really
07:04:34 <tertl3-laptop> but its a learning curve
07:05:23 <bernalex> tertl3-laptop: not more so than imperative languages
07:05:48 <bernalex> tertl3-laptop: unless you learned an imperative language *first*. I suspect vice versa would be equally difficult.
07:06:18 <kvanb> I code both equally well now
07:06:22 <suOya__> haskell was my first serious language
07:06:32 <kvanb> at first it was really hard to functional, and then it was really hard to imperative (you kind of unlearn imperative to learn haskell)
07:06:35 <tdammers> I write code faster in imperative languages
07:06:41 <tdammers> but it's also more buggy
07:06:49 <tdammers> and less maintainable
07:06:49 <bernalex> kvanb: I think vice versa sholud be less difficult because most people write a lot of imperative in haskell
07:07:20 <bernalex> kvanb: but of course you try to use denotative programming for everything you can
07:07:22 <tdammers> haskell is like a toolbox for constructing domain-specific imperative languages :D
07:07:37 <tdammers> (or declarative ones, yeah)
07:07:41 <kvanb> I don't really trust my imperative code
07:07:49 <kvanb> don't stare at it, might autorot.
07:08:05 <tdammers> imperative is a much smaller problem than unityped
07:08:28 <tdammers> especially when you have explicit and restricted side effects
07:22:59 <ironChicken> is there something available which does something like: take a list of IO actions and execute them in chunks (perhaps of some given size) and then do something (probably some other function) between each chunk?
07:24:08 <ironChicken> and why can't i search for [IO a] on hoogle? http://www.haskell.org/hoogle/?q=%5BIO%20a%5D :-(
07:25:10 <saml> how do you define chunks?
07:25:22 <saml> a chunk  is n IO actions?
07:25:23 <ironChicken> sub-lists?
07:25:30 <ironChicken> saml: yeah
07:25:56 <saml> [a, b, c, d] ==> [[a,b], [c], [d]] ==>  and execute them?
07:26:11 <saml> [IO a] -> [[IO a]]
07:26:23 <saml> :t groupBy
07:26:24 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
07:26:25 <augur> does GHC have the ability to do a strictness analysis and optimize things to be strict when possible?
07:26:41 <saml> i think there's a way to execute [IO a]  .. maybe sequence
07:26:46 <augur> @hoogle [IO a]
07:26:48 <lambdabot> System.Exit exitFailure :: IO a
07:26:48 <lambdabot> System.Exit exitSuccess :: IO a
07:26:48 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
07:26:57 <augur> ironChicken: looks like you can search it fine
07:27:01 <ion> @type sequence . intercalate [?a] . chunksOf 5
07:27:03 <lambdabot> (?a::m a, Monad m) => [m a] -> m [a]
07:27:25 <ironChicken> saml, ion: cool. thanks. these look promising
07:27:26 <opqdonut> augur: yes. try e.g. compiling "sum [0..bigNumber]" with -O2 and without
07:27:51 <augur> opqdonut: ah, ok, -O2 will try to strictify? interesting and good
07:28:18 <opqdonut> augur: you can run the compiled programs with +RTS -s and get memory statistics
07:28:27 <opqdonut> augur: and see that the optimized version doesn't accumulate thunks
07:28:36 <opqdonut> augur: or you can look at the core with -ddump-simpl
07:28:36 <ironChicken> augur: that's not [IO a], it's just IO a
07:29:40 <augur> ironChicken: yes. and?
07:29:53 <augur> ironChicken: that just means that hoogle doesnt have anything that is specific to [IO a]
07:30:21 <augur> hoogle tries to find similar types, so it finds types with IO a as well as whatever it fines for [IO a] (which happens to be nothing)
07:31:39 <ironChicken> augur: i can see that. i'm just surprised that there's *nothing* hoogle knows about that includes [IO a] which led me to be suspicious about whether it was searching for it correctly
07:32:05 <augur> hoogle doesnt search deeply into packages
07:32:23 <augur> so there might be stuff out there, but hoogle's shallow and wont necessarily find it
07:32:35 <ironChicken> augur: understood
07:32:38 <ironChicken> thanks
07:32:41 <augur> but thats also generally a signal that you dont need the thing you're looking for :)
07:32:52 <augur> ie you think you want [IO a] -> IO [a], lets say
07:33:03 <augur> but it turns out that what you really need is Monad m => [m a] -> m [a]
07:33:13 <augur> or whatever
07:33:17 <augur> @hoogle [IO a] -> IO [a]
07:33:18 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:33:18 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
07:33:18 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
07:33:46 <ironChicken> augur: yes, makes sense
07:34:03 <augur> @hoogle [m a]
07:34:05 <lambdabot> Data.Functor.Compose getCompose :: Compose f g a -> f (g a)
07:34:05 <lambdabot> Data.List inits :: [a] -> [[a]]
07:34:05 <lambdabot> Data.List permutations :: [a] -> [[a]]
07:41:28 <int3__> @hayoo [IO a]
07:41:29 <lambdabot> Unknown command, try @list
07:45:57 <sm> morning all. Did any of you get eclipse luna and eclipsefp installed on a recent osx ?
08:05:52 <Profpatsch> I’m going crazy here. How do I chain newUnique and hashUnique?!
08:06:06 <Profpatsch> On the ghci command line, that is.
08:06:35 <Profpatsch> I have I hunch that I can use Applicatives for that, but I don’t see how.
08:06:59 <ion> @type fmap
08:06:59 <Flonk> What do "maximum residency" and "maximum slop" mean when I do profiling with -sstderr ?
08:07:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:07:13 <ion> Let f = IO, a = Unique, b = Int
08:07:54 <Profpatsch> ion: Oh, hashUnique `fmap` newUnique
08:08:35 <Profpatsch> ion: Is there a way to make this more “pipe-like”?
08:08:36 * hackagebot csound-expression-typed 0.0.5.2 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.5.2 (AntonKholomiov)
08:08:36 * hackagebot csound-expression 3.3.2 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-3.3.2 (AntonKholomiov)
08:08:51 <ion> profpatsch: pipe-like?
08:09:11 <Profpatsch> hashUnique <$> newUnique is turned around.
08:09:38 <Profpatsch> Oh, but <$> is the same as $ for Functors, so it makes sense.
08:10:04 <ion> It matches the direction of normal function composition and application. You can use a flipped fmap, though. There’s (<&>) in lens for instance.
08:10:30 <ion> or: do { u <- newUnique; return (hashUnique u) }
08:10:30 <Profpatsch> It’s something like hashUnique ( makeAFunctor ( newUnique ))
08:11:30 <Profpatsch> I see. I guess the more I work with it, the more natural it’s going to be.
08:11:37 <ion> No, it’s like (makeFunctoricOrWhatever hashUnique) newUnique. Actually, not even like, it *is*.
08:15:11 <ion> fmap makes an (F a -> F b) out of an (a -> b)
08:18:33 * hackagebot apiary 0.13.0 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.13.0 (HirotomoMoriwaki)
08:18:35 * hackagebot apiary-logger 0.11.2 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-0.11.2 (HirotomoMoriwaki)
08:18:37 * hackagebot apiary-persistent 0.13.0 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-0.13.0 (HirotomoMoriwaki)
08:18:39 * hackagebot apiary-websockets 0.11.3 - websockets support for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.11.3 (HirotomoMoriwaki)
08:18:41 * hackagebot apiary-cookie 0.13.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.13.0 (HirotomoMoriwaki)
08:23:01 <Cheery> hi ppl
08:23:28 <Cheery> could I get some help in figuring out how to generate LR parser tables?
08:23:33 * hackagebot apiary-clientsession 0.13.0 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-0.13.0 (HirotomoMoriwaki)
08:23:35 * hackagebot apiary-authenticate 0.12.1 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-0.12.1 (HirotomoMoriwaki)
08:23:37 * hackagebot apiary-eventsource 0.11.5 - eventsource support for apiary web framework.  http://hackage.haskell.org/package/apiary-eventsource-0.11.5 (HirotomoMoriwaki)
08:23:39 * hackagebot csound-catalog 0.1.3 - a gallery of Csound instruments.  http://hackage.haskell.org/package/csound-catalog-0.1.3 (AntonKholomiov)
08:23:41 * hackagebot prednote 0.24.2.0 -   http://hackage.haskell.org/package/prednote-0.24.2.0 (OmariNorman)
08:31:34 <radix> I'm a bit confused by why I don't see all class functions for a particular data type on hackage
08:31:50 <radix> is it just becaues hackage only shows what the author decided to explicitly document?
08:33:47 <Qfwfq> Why is the type hierarchy finite :( :( :(
08:35:45 <monochrom> hackage only shows what is visible during doc-build time, with minimal doc-build environment
08:36:28 <Profpatsch> Indentation: Two or Four spaces?
08:36:46 <monochrom> the average programmer indents by 4.72 spaces
08:37:04 <Profpatsch> Is the haskell-mode indentation function sane?
08:37:09 <Profpatsch> It indents by two spaces.
08:37:20 <pjdelport> radix: What are you looking at?
08:37:22 <monochrom> it is sane. it can be configured.
08:37:31 <radix> pjdelport: lemme check my history...
08:37:37 <radix> pjdelport: http://hackage.haskell.org/package/persistent-vector-0.1.0.1/docs/Data-Vector-Persistent.html
08:38:02 <pjdelport> Hmm, "class functions"?
08:38:36 * hackagebot prednote-test 0.24.2.0 - Tests and QuickCheck generators to accompany prednote.  http://hackage.haskell.org/package/prednote-test-0.24.2.0 (OmariNorman)
08:38:37 <radix> pjdelport: like, the implementations of the functions in the classes that this type is an instance of.
08:38:52 <radix> like, it doesn't show fmap
08:39:39 <pjdelport> Oh. Yeah, instances will just be listed by class: you can click on the class to go to its definition, though, along with its methods.
08:39:46 <radix> not that that's a big problem, it's obvious what fmap would do, I was just curious what determines whether hackage will show a function for a type.
08:40:11 <radix> some functions that are implementations of a typeclass function are listed, like foldr
08:40:43 <pjdelport> Nah, foldr isn't part of a type class.
08:40:54 <radix> o.O
08:41:01 <radix> http://hackage.haskell.org/package/base-4.5.0.0/docs/Data-Foldable.html#t:Foldable ?
08:42:04 <pjdelport> I was about to say, except for foldable, but that's a different foldr: it's not listed directly for Vector, but implied by the Foldable Vector instance.
08:43:15 <pjdelport> So the foldr actually listed on the Vector page is the Vector-specific foldr, just like the Prelude and Data.List have a list-specific foldr.
08:44:02 <radix> pjdelport: oh, so then fmap wasn't actually explicitly defined for this vector, and so that's why it doesn't show up?
08:44:04 <pjdelport> The foldr and other methods of Foldable are the more generic versions of it, that work with *any* Foldable type
08:44:08 <pjdelport> Right.
08:44:27 <pjdelport> Well, actually, you'll see there's a map :: (a -> b) -> Vector a -> Vector b
08:44:36 <pjdelport> And that's fmap for Vector
08:45:23 <pjdelport> So if you click through to the source, you'll see:
08:45:24 <pjdelport> instance Foldable Vector where foldr = foldr
08:45:24 <pjdelport> instance Functor Vector where fmap = map
08:45:26 <pjdelport> and so on
08:46:12 <radix> ok, I think I follow now :)
08:47:03 <pjdelport> So the despite the unqualified names being similar, they're really just separate functions / methods:
08:47:04 <pjdelport> :t Data.Vector.foldr
08:47:05 <lambdabot> (a -> b -> b) -> b -> Data.Vector.Vector a -> b
08:47:10 <pjdelport> :t Data.Foldable.foldr
08:47:11 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
08:48:23 <pjdelport> And for Vector, the implementation of the Data.Foldable.Foldable class's foldr happens to be Data.Vector.foldr
08:48:38 <radix> it seems like it would be nice for the doc page to show that
08:49:05 <radix> though of course it's pretty obvious for this vector type :)
08:49:53 <pjdelport> I think it's usually supposed to be pretty obvious in general: the data type itself will generally explain how it is supposed to behave with various instances, if it's not standard.
08:51:04 <pjdelport> For example, you have newtype wrappers like http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Monoid.html#t:All and the ones below.
08:51:23 <pjdelport> which each have alternative instances for a class of interest
08:52:12 <pjdelport> And the type itself will explain it: All is booleans under "and", Sum is numbers under addition, Product is numbers under multiplication, etc.
08:52:45 <pjdelport> rather than that being explained at the Monoid instance level for each
08:52:54 <radix> I see. so they just put that information in the top-level documentation for that type.
08:53:29 <pjdelport> You *can* have a Haddock comment that shows up next to a particular instance of that list, but it's unusual.
08:54:57 <pjdelport> Right. The idea of type classes is to capture a general interface, so in general, it should be very rare to need to expand on on the type class's documentation at the level of instance method implementations.
08:56:23 <pjdelport> So if you have a Num instance, you should already know what (+) and (*) and all the rest do, from their general contract.
08:57:35 <pjdelport> If you have a specific type that requires fancier documentation, then the type itself will generally have it; so e.g. an implementation of symbolic polynomials might say "This type implements mathematical operators with the following provisions / deviations / exceptions: [...]"
08:58:38 * hackagebot process-conduit 1.2.0.1 - Conduits for processes (deprecated)  http://hackage.haskell.org/package/process-conduit-1.2.0.1 (MichaelSnoyman)
08:58:40 * hackagebot git-annex 5.20140717 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140717 (JoeyHess)
08:59:08 <pjdelport> radix: Here's an example of an instance note: http://hackage.haskell.org/package/free-4.9/docs/Control-Comonad-Cofree.html
08:59:19 <pjdelport> for "ComonadTrans Cofree"
08:59:51 <pjdelport> http://hackage.haskell.org/package/free-4.9/docs/Control-Monad-Free.html#t:Free has some more examples
09:00:09 <radix> thanks :)
09:07:30 <bernalex> is there a (a, b, c) -> d -> a -> b -> c -> d
09:07:36 <bernalex> so curry but for tuples of three
09:07:42 <bernalex> whoops
09:07:51 <bernalex> ((a, b, c) -> d) -> a -> b -> c -> d
09:08:39 * hackagebot masakazu-bot 0.1.0.0 - @minamiyama1994_bot on haskell  http://hackage.haskell.org/package/masakazu-bot-0.1.0.0 (minamiyama1994)
09:08:44 <phaazon> is there a way to generate several executables within a single .cabal?
09:08:50 <phaazon> İ’d like to share some modules
09:10:06 <supki> phaazon: you can have many "executable" sections, yes
09:10:07 <glguy> phaazon: Your .cabal file can have one library section and zero-to-many executable sections
09:10:16 <Fuuzetsu> phaazon: I think the vty package does this if you want to look at an example
09:10:24 <glguy> (well, zero-to-one library sections, I suppose)
09:11:57 <phaazon> ok
09:11:58 <phaazon> thank you
09:12:01 <phaazon> that sounds great :)
09:25:34 <fred2> I want to test an update to a package that hasn't been updated yet on hackage.  I'm working in a sandbox.  How can I redirect that particular cabal dependency to a local directory where I have the cloned updated repo?
09:26:32 <sm> cabal sandbox add-source ... ?
09:28:12 <fred2> great, thanks
09:31:15 <phaazon> hm
09:31:26 <phaazon> the run function from HDBC takes a String as SQL query
09:31:43 <phaazon> I need to insert values in a field which has the SQL type “Bit”
09:31:52 <phaazon> how am I supposed to deal with that?
09:31:56 <phaazon> ByteString -> String?
09:32:08 <eacameron1> can GHC warn on usage of "error" and "undefined"?
09:32:20 <phaazon> creating a placeholder in the string, and use execute?
09:32:51 <phaazon> hm, maybe SqlByteString
09:36:21 <enthropy> eacameron: you could import some module that defines error and undefined as deprecated
09:37:12 <eacameron> for all the safety of haskell, I would have imagined that such a thing existed already ! ;)
09:37:52 <eacameron> essentially I am hoping for warnings on use of error, which would include uses of "head", "tail", etc
09:38:18 <enthropy> maybe hlint has warnings for those
09:38:31 <eacameron> enthropy: not a bad idea, forgot to look there
09:39:48 <distransient> clear
09:41:22 <eacameron> I have at times forgotten to tack -threaded at the end of a build, does that mean my program is not multithreaded at all?
09:41:58 <quchen> eacameron: It will only use one OS thread in that case I think.
09:42:14 <eacameron> quchen: wow, interesting
09:42:16 <quchen> You can still do concurrency and parallelism in your program though, it's just all multiplexed onto the same capability.
09:43:20 <quchen> " The threaded runtime system is so-called because it manages multiple OS threads, as opposed to the default runtime system which is purely single-threaded."
09:43:24 <quchen> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#options-linker
09:49:09 <c_wraith> It's accurate to describe GHC's use of concurrenccy as cooperative - but you don't need to manually insert calls to yield.  The runtime takes care of it.
09:49:26 <c_wraith> Except in the cases where it doesn't.  *sigh*
09:49:44 <tromp__> it's not pre-emptive then?
09:49:50 <c_wraith> No.
09:50:21 <c_wraith> 99% of the time, you can pretend it is.
09:50:43 <c_wraith> But if you get performance issues with concurrent code, it's time to wonder if you're in the other 1%
09:52:56 <jfischoff> if you have a loop that doesn’t allocate any memory, you might need an explicit yield
09:53:08 <eacameron> how do you yield explicitly?
09:53:19 <jfischoff> Control.Concurrent.yield
09:53:24 <eacameron> easy enough
09:53:26 <eacameron> ;)
09:53:30 <jfischoff> :)
09:54:36 <c_wraith> FFI calls improperly made unsafe is a bigger cause of failing to yield, in my experience.
09:54:48 <eacameron> :t Control.Concurrent.yield
09:54:49 <lambdabot> IO ()
09:54:58 <eacameron> hmm, so it doesn't work in pure setting
09:55:23 <c_wraith> Because so many people just think "unsafe is faster!" and never bother understanding what makes it unsafe.
09:56:09 <dwcook> c_wraith: Generally, when should something be made unsafe and when not?
09:56:19 <c_wraith> dwcook: in general, things should always be marked safe.
09:56:31 <jfischoff> well not like sin
09:56:50 <c_wraith> fortunately, that one's already taken care of by someone who knows what they're doing. :)
09:57:02 <jfischoff> you have to make it safe if pass a Haskell callback, so definitely in that case
09:57:27 <c_wraith> dwcook: anything that can take more than about 1 ms to complete should be marked safe.  Especially if it can block on user input.
09:57:59 <eacameron> *unsafe you mean?
09:58:02 <c_wraith> Anything that can block at all must be made safe.
09:58:02 <jfischoff> yeah
09:58:08 * jfischoff nods
09:58:13 <eacameron> oh interesting
09:58:19 <dwcook> I'm beginning to realize I don't actually know what safe and unsafe means when it comes to FFI
09:58:26 <dwcook> s/means/mean/
09:58:32 <quchen> Seconded
09:59:09 <c_wraith> safe means that the ffi call is performed by a seperate thread, while the HEC remains in clean state waiting for the result.
09:59:22 <c_wraith> unsafe means that the ffi call is more or less made directly from the HEC
09:59:46 <c_wraith> Which means that for the duration of the call, it doesn't do anything the RTS expects HECs to do.
10:01:31 <c_wraith> Notably, this means that GC can't run during an unsafe call, but it can during a safe call.
10:01:45 <c_wraith> So an unsafe call that doesn't return immediately can be a severe performance bottleneck
10:01:49 <c_wraith> as it can destroy concurrency
10:02:23 <carter> rule of thumb is chunks of unsafe ffi work should be < 10-100µs
10:02:41 <carter> you *can* do batch work via unsafe style ffi
10:02:41 <carter> but
10:02:46 <carter> it needs to be chunked up
10:02:52 <carter> so it can yield back to the scheduler
10:03:55 <jfischoff> I find even safe FFI calls can take several milliseconds to yeild to a garbage collection request :(
10:04:10 <c_wraith> that's better than not yielding!
10:04:15 <c_wraith> But not great.
10:04:16 <jfischoff> hah yeah
10:04:20 <dwcook> Does that imply that almost all unsafe calls should take constant time?
10:04:30 <c_wraith> I would say so
10:04:37 <c_wraith> Or at least nearly-constant time.
10:04:43 <c_wraith> a log factor is ok, a linear factor isn't
10:05:31 <c_wraith> I mean, checking the result of a call to epoll isn't constant time, technically.
10:05:39 <c_wraith> err, the call to epoll itself isn't constant time, I mean
10:06:06 <c_wraith> Heck, select is linear time.  But at least it's bounded above by other system limitations!
10:10:22 <carter> jfischoff: you can change what the context switching rate is as an RTS flag
10:10:43 <jfischoff> hmm
10:10:51 <jfischoff> Ill try that
10:11:14 <carter> http://www.haskell.org/ghc/docs/latest/html/users_guide/using-concurrent.html
10:11:31 <carter> if you want min latency (at the cost of throughput)
10:11:44 <carter> you might wanna build with -fno-omit-yields + RTS option -C0
10:12:11 <carter> that WILL cost you throughput
10:12:25 <carter> but wil give aggressive yielding
10:12:56 <carter> you might wanna do something more like -C0.0002
10:13:12 <carter> hrm, i wonder if it supports scientific notation
10:13:13 <carter> :)
10:13:36 <carter> jfischoff: but yeah, default context switching rate is every 20ms
10:13:40 <jfischoff> it would neat if there was app for tuning RTS parameters
10:14:01 <carter> there was a few years ago
10:14:05 <carter> probably needs some love
10:14:12 <carter> Dons has one for tuning heap params
10:14:16 <carter> *had
10:14:38 <carter> http://donsbot.wordpress.com/2009/03/09/evolving-faster-haskell-programs/
10:14:40 <carter> or somewhere there abouts
10:14:44 <jfischoff> cool
10:18:52 <bennofs> carter: it still works, I used ~1 month ago :)
10:27:12 <hc> hi, i'm writing a network server that you connect to via telnet/netcat
10:27:18 <hc> it accepts one command per line
10:27:30 <hc> is it bad style to return IO actions from the individual subparsers?
10:27:34 <hc> (using parsec3)
10:28:17 <pepper_chico> hi, I'm studying haskell and recently I've learned about the <> alias to mappend, now, I've just stumbled upon the ap function, which works like <*> for monads instead of applicatives. is there a infix operator alias for ap?
10:29:24 <dwcook> pepper_chico: Well, any non-operator can be made one by surrounding it in backticks. So, `ap`
10:29:25 <Iceland_jack> pepper_chico: no, ap isn't used much and they should become the same function in the next GHC release
10:30:18 <pepper_chico> dwcook, ok, I know about that, was asking about one without ticks and text ;-)
10:30:37 <dwcook> I would just use <*> unless you have a specific reason not to
10:30:45 <pepper_chico> Iceland_jack, ah ok then
10:31:24 <pepper_chico> dwcook, ok thanks, I'm just learning about liftM/fmap, <*> vs `ap`
10:32:26 <dwcook> Yeah, it's a bit of a wart, but hopefully less so soon
10:33:27 <pepper_chico> do you have a reference for the rationale behind these recent changes you're both talking about?
10:33:50 <Iceland_jack> you can search for the AMP (Applicative–Monad proposal)
10:34:10 <quchen> Iceland_jack: I don't think monadic functions will be defined in terms of Applicative ones. The monadic counterparts will be useful as default definitions.
10:34:34 <quchen> If you have a monad and want to make it an applicative using "<*> = ap" you'll run into a cycle otherwise.
10:35:07 <Iceland_jack> Yeah
10:35:26 <pepper_chico> ok, thanks, I'll look into that proposal
10:38:34 <dwcook> instance Functor Foo where { fmap = liftA {- or liftM -} } ; instance Applicative Foo where { pure = return ; (<*>) = ap } ; instance Monad Foo where …
10:41:49 <Robly18> evening
10:42:10 <Robly18> i've been trying to figure out this MWC module,
10:42:20 <Robly18> but i'm having some issues
10:42:38 <Robly18> this might just be my own ignorance and lack of knowledge of haskell, but
10:43:04 <Robly18> actually, hold on
10:43:05 <c_wraith> from the mwc-random package?
10:43:09 <Robly18> never mind, ugh
10:43:20 <Robly18> i'm going to need to ask this later, something happened and i gotta go >.<
10:43:41 <dwcook> Some people lead exciting lives.
10:46:45 <blipped> I parachute into the office every morning.
10:47:11 <dwcook> blipped: Is your office an open field by any chance?
10:47:39 <blipped> I usually come through the skylight and land directly in my chair.
10:47:55 <blipped> After awhile it doesn't seem so exciting :(
10:50:07 <hc> what do you do on a foggy day?
10:52:33 <c_wraith> do it carefully
11:04:09 <joneshf-laptop> why is it the Alternative instance for Parsec doesn't `try` the first operand?
11:05:06 <Fuuzetsu> see attoparsec
11:07:05 <dwcook> joneshf-laptop: Supposedly, backtracking makes error messages worse.
11:07:41 <dwcook> And not every time you use (<|>) will you possibly need to backtrack
11:18:25 <mdmkolbe> How do I check which of my cabal installed package are already built with a profiling version?
11:28:20 <oyster> Would this be a good way to generate random numbers within a state monad? This snippet works as expected, but I have something similar in a larger program that seems to simply replicate the points rather than offsetting them. Could laziness play a part here?
11:28:22 <oyster> http://lpaste.net/107667
11:29:13 <suOya__> Why doesn't Data.Sequence have an operation to test whether an element is in the sequence? Or am I supposed to just wrap around elemIndex* ?
11:30:14 <oyster> To clarify, what I am seeing is instead of getting back a list of "n" points that have been randomly scaled, I am getting my original point simply copied "n" times
11:30:41 <oyster> could laziness be a culprit here?
11:33:41 <ClaudiusMaximus> oyster: line 10 uses g instead of gen
11:34:43 <supki> suOya__: you can use Data.Foldable.elem
11:35:08 <supki> that's probably why
11:36:12 <suOya__> ah, right
11:39:25 <oyster> ClaudiusMaximus: oh yeah, I fixed that
11:40:23 <oyster> I think I actually figured out the problem was a math error... : ) Still though, would that be a good approach for generating the random numbers I need?
11:40:54 <ClaudiusMaximus> looks ok i think, you could see how MonadRandom does it
11:42:33 <_sebastian_> wtf of the day: why a in C++11 higher order function :: (IO ()) -> IO () also accepts arguments like: (return 42) and how you can fix it: http://stackoverflow.com/a/24810703/3185053
11:43:06 <joneshf-laptop> is there some better way to do this: http://lpaste.net/107669 ? the repeated `M.lookup ... qs`?
11:46:08 <_sebastian_> or: why C++ is broken
11:47:05 <jfischoff> joneshf-laptop: you could use mapM (flip M.lookup qs) [“serverLocation”, “serverPort”] but I would say that is better necessarily
11:47:16 <jfischoff> s/I would/I wouldn’t
11:48:21 <dwcook> joneshf-laptop: I'd say it's fine as it is. Not all repetitions need be factored out.
11:49:21 <dwcook> If you went the mapM route, for that matter, you'd lose the information that you have a 2-tuple rather than a list
11:50:31 <TheJhonny> Haskell people, I've got a question for you? Haskell isn't OOP, right?
11:50:50 <Jefffrey> no
11:51:11 <dwcook> TheJhonny: No, but I suspect your question could be made more specific than that.
11:51:19 <{AS}> well, http://lambda-the-ultimate.org/node/319 :)
11:51:20 <TheJhonny> It is
11:51:26 <joneshf-laptop> jfischoff, ah, of course Traversable
11:51:30 <joneshf-laptop> dwcook, makes sense
11:51:34 <joneshf-laptop> jfischoff, dwcook thanks
11:52:03 <TheJhonny> What would be haskell's way of data objects?
11:52:20 <dwcook> TheJhonny: Are you asking how to do OOP in Haskell, or how Haskell handles data?
11:52:21 <Jefffrey> There are data objects in haskell.
11:52:29 <TheJhonny> OOP in Haskell
11:52:38 <Jefffrey> OOP in Haskell makes no sense.
11:52:39 <Iceland_jack> TheJhonny: OOP isn't well defined anyway so this may end up as a long discussion on what OOP really is :)
11:52:41 <dwcook> Well, one obvious question is: Why do you want that?
11:53:02 <TheJhonny> I'm not sure I want it.
11:53:02 <Jefffrey> OOP is also a terrible choice for most tasks.
11:53:12 <TheJhonny> I'm a java guy and I'm trying to learn haskell
11:53:21 <TheJhonny> for fun
11:53:29 <bennofs> TheJhonny: it won't help if you try to learn how to do OOP or java in haskell
11:53:33 <Iceland_jack> TheJhonny: sounds good! check out Learn You a Haskell
11:53:33 <bennofs> TheJhonny: start from scratch
11:53:34 <Jefffrey> TheJhonny: Forget everything about Java and read a book on Haskell.
11:53:35 <Iceland_jack> @where lyah
11:53:35 <lambdabot> http://www.learnyouahaskell.com/
11:53:41 <dwcook> TheJhonny: My suggestion: Learn the Haskell way first, then, if you still want OO, find out how to do it.
11:53:45 <Iceland_jack> and yes, start from scratch is the best solution
11:54:02 <dwcook> TheJhonny: I can tell you how but at this point in your Haskell journey I think it wouldn't help.
11:54:21 <TheJhonny> I'll trust you guys that all will be explained.
11:55:15 <Iceland_jack> Best of luck TheJhonny, you can use lambdabot to evaluate Haskell expressions and get the type of Haskell terms
11:55:18 <Iceland_jack> > 1 + 10
11:55:20 <lambdabot>  11
11:55:22 <TheJhonny> I'm started reading that book.  I'm like one or two chapters in.
11:55:32 <Iceland_jack> @ty 'a'
11:55:33 <lambdabot> Char
11:55:36 <TheJhonny> lamdabot?
11:55:40 <Iceland_jack> Yes
11:55:53 <TheJhonny> I see him
11:55:58 <khyperia> Speaking of... I've always wondered how a forall inside of data works. I may be misremembering, but iirc, say, [forall a. a] compiles, what'd be the use of that? Why would you do something like that? (maybe not that exact example, but generally a forall not at top level)
11:55:59 <TheJhonny> there is like a million people here.
11:56:36 <TheJhonny> > 8*8
11:56:37 <lambdabot>  64
11:56:46 <Iceland_jack> @google what is Haskell?
11:56:47 <enthropy> [forall a. a] may compile, but you probably won't get very far with -XImpredicativeTypes
11:56:48 <lambdabot> http://www.haskell.org/haskellwiki/Introduction
11:56:48 <lambdabot> Title: Introduction - HaskellWiki
11:56:48 <TheJhonny> that's awesome
11:56:59 <dwcook> khyperia: That, by itself, is almost useless. The only information you can get out of that list is its length, so it might as well be an Integer. Combined with a typeclass constraint, you get something more useful.
11:57:17 <khyperia> yeah, dwcook, that's what I was meaning by "not that exact exmaple"
11:57:28 <khyperia> typeclass constraints, something more than just a single term type, etc.
11:57:51 <TheJhonny> I was getting my feet wet with functional programming with Scala, but haskell seems alittle more straight forward.
11:58:17 <khyperia> is it possible to do, say, "map show xs" where xs :: [forall a. (Show a) => a]?
11:58:33 <khyperia> I don't have a compiler at the moment to test :)
11:58:59 <dwcook> khyperia: in principle that's fine, though I forget the exact situations where the syntax is allowed
11:59:40 <dwcook> Here's another example: You can turn an arbitrary typeclass into data
11:59:46 <bennofs> khyperia: I just tested that, doesn't work (although I think it should in principle)
11:59:53 <bennofs> khyperia: No instance for (Show (forall a. Show a => a))
12:00:05 <Abathurr> what in the great gatsby is a confusion matrix
12:00:14 <triliyn> khyperia: there are extensions that make that possible, but it's probably easier to just have a list of strings
12:00:27 <dwcook> data MonadData m = MonadData { applicative :: ApplicativeData m ; return :: forall a. a -> m a ; join :: forall a. m (m a) -> m a }
12:00:46 <abc56889_> getTypeInfo conn@Connection{..} oid =
12:00:50 <bennofs> dwcook: that isn't ImpredicativeTypes though
12:00:56 <bennofs> dwcook: just RankNTypes
12:01:04 <abc56889_> ^^ what does this syntax do? getTypeInfo conn@Connection{..} oid =
12:01:18 <dwcook> bennofs: Did it have to be? The original question didn't ask about ImpredicativeTypes
12:01:21 <abc56889_> then @TypeConstructor{..}
12:02:10 <dwcook> Oh, I didn't have to include return in the example above, and it may have other errors, but hopefully I got the idea across :P
12:02:11 <bennofs> abc56889_: Connection{..} is a wild card pattern
12:02:12 <khyperia> so... oh, dwcook, I vaugely recall reading this time time ago.
12:02:32 <triliyn> khyperia: if you really want the list of showable things, I think what you need to do is make a GADT or something
12:02:35 <joof> TheJhonny: I feel like if you can program in haskell, you understand functional paradigms pretty well. I always heard if you can program in C++ most other languages are easy to pick up so in that sense haskell is like the c++ of functional languages... And that's how I just compared C++ to haskell :P
12:03:14 <abc56889_> bennofs: I cant see what its matching though
12:03:16 <triliyn> data Showable :: Type where MkShowable :: Show a => a -> Showable
12:03:19 <khyperia> dwcook, "something something GHC turns `(Num a) => a -> a` into `(Num a) -> a -> a`"
12:03:29 <TheJhonny> joof: That's a interesting way of looking at it.
12:03:47 <triliyn> But the only thing you can do with something of this type is apply show to it, so you might as well just apply show before adding it to the list
12:04:23 <khyperia> true, triliyn, I'm just blindly grabbing for some example of where something of the like would be useful
12:04:27 <triliyn> Show a => a is isomorphic to String
12:04:49 <bennofs> abc56889_: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards
12:05:02 <dwcook> triliyn: I don't think there's an arrow back from String to that, is there?
12:05:20 <triliyn> oh, hmm
12:05:33 <triliyn> I guess not
12:05:57 <dwcook> (I mean, there is *an* arrow, but not one that forms an isomorphism)
12:06:24 <khyperia> I hope we're not scaring TheJhonny by wacky theory talk :)
12:06:26 <Iceland_jack> Not to mention the other two methods of Show
12:06:44 <triliyn> oh, right, I always forget about those
12:07:09 <abc56889_> bennofs: Thanks muchly
12:07:10 <Iceland_jack> Yeah they are forgettable :) especially the slightly hacky showList
12:07:32 <triliyn> For typeclasses with more methods, you ultimately need a record  of partially-applied methods
12:08:11 <TheJhonny> khyperia, not a all.  I don't understand it, but I'm not like a cave man seeing fire for the first time, lol.
12:08:16 <triliyn> Which is a bit more effort than just calling show on everything
12:11:13 <khyperia> Related question, is it possible to have a type `(forall a. (Show a) => a) -> String`?
12:12:52 <dwcook> khyperia: Yeah, you could do that
12:12:53 <khyperia> ah, never mind, reading http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types apparently you need to wrap it in a `data`
12:13:18 <dwcook> The exact type signature you gave compiles when I have RankNTypes enabled
12:13:30 <khyperia> wait, what?
12:14:06 <bennofs> khyperia: I think you only need a wrapper if you put it inside another data type, so (forall a. Show a => Maybe a) -> String probably won't compile
12:14:07 <dwcook> Oh, woops
12:14:47 <josephle> it's well-kinded, but I think khyperia wants to know if it is inhabited
12:14:55 <khyperia> I'm getting: No instance for (Show (forall a. Show a => a)) arising from a use of `show'
12:14:59 <khyperia> yeah, josephle
12:15:41 <dwcook> It's definitely inhabited if you omit the forall
12:15:55 <dwcook> (Meaning a is scoped to the whole type)
12:15:55 <Nik_> Is it possible to do “negative” pattern matching.  i.e. with an algebraic data type T = A | B | C could you somehow match on “not A” meaning B or C
12:16:18 <dwcook> Nik_: match A first, then use a catch-all for the rest
12:16:23 <Iceland_jack> Nik_: what dwcook said
12:16:30 <dwcook> Such a pattern might be like "foo" or "_"
12:16:50 <dwcook> or more appropriately named, "rest", if you were going to use it
12:16:52 <khyperia> yeah, that much is obvious, dwcook, but I'm looking on how to call show on my previous list-Show-thingy
12:16:56 <Iceland_jack> If A has arguments you can also use an empty record update to ignore the arguments
12:16:56 <Iceland_jack>     foo A{} = ... A     ...
12:16:56 <Iceland_jack>     foo _   = ... not A ...
12:17:39 <josephle> khyperia: f x = case x of y -> y :: (forall a. (Show a) => a) -> String
12:17:50 <josephle> it typechecked in ghci
12:17:57 <josephle> surely it works :)
12:18:14 <raschwell> Mmkey, I think I like the elephant book
12:18:57 <Nik_> I don’t care about the case when A is matched, so I was trying to make it cleaner than matching it and the just returning it
12:19:46 <khyperia> that it does, josephle, but *why*
12:19:48 <dwcook> Nik_: Were you going to just let it error out? Then the only real difference is you'd have to explicitly write the error. A -> error "…"
12:20:00 <jomg> josephle: though that doesn't mean you can apply it to anything
12:20:01 <dwcook> Nik_: If not, you were going to have to match it anyway
12:20:02 <khyperia> why the heck does a case block do witchcraft-magic?
12:20:24 <josephle> jomg: the type is inhabited by a useless inhabitant :P
12:20:32 <josephle> khyperia: because existential types are funny
12:20:53 <latk> How have people setup up stylish-haskell in haskell-mode in emacs, with cabal sandboxes ?
12:21:00 <jomg> true, you can always just apply it to undefined if you're bored... :P
12:21:45 <khyperia> I'm very confused right now and I'm questioning my reasoning for asking this question, heh.
12:22:22 <dwcook> Explicit foralls can be hard to wrap your head around at first. Think about what's confusing you and ask any questions necessary
12:22:22 <Nik_> I’m looking at a tuple, so I have a catch all for both parts of a tuple.  But two of my other pattern matching rules will create an infinite recusion if I don’t ignore the one first argument that will make that happen
12:23:06 <dwcook> Nik_: You might have to illustrate.
12:23:17 <Nik_> Alright, give me a sec
12:23:54 <khyperia> I mean, josephle, apparently your case block works with (forall a. a) -> b
12:24:29 <khyperia> although I'm unsure of how possible it is to actually create a variable of that type
12:24:40 <khyperia> that is, x :: (forall a. a)
12:24:44 <jomg> i don't thing the case block is even necessary
12:25:09 <jomg> f x = x :: (forall a. Show a => a) -> String works for me
12:25:17 <dwcook> khyperia: The only value inhabiting forall a. a is bottom, because that inhabits every type.
12:25:44 <khyperia> aha, thought so
12:26:11 <khyperia> so is (forall a. (Show a) => a) also only bottom, or does something exist there?
12:26:23 <dwcook> Likewise, forall b. (forall a. a) -> b is inhabited by only bottom and… const bottom?
12:27:06 <khyperia> err, tag a `-> String` to the end of mine... or... something, I don't know
12:27:28 <dwcook> Well any function can either be itself bottom or const bottom, at least.
12:27:31 <Nik_> dwcook: http://lpaste.net/107671
12:27:38 <dwcook> And those two are different because they can be distinguished by seq.
12:28:31 <khyperia> something like the function itself is bottom, or trying to pump a value through it is bottom?
12:28:49 <dwcook> Yeah
12:29:24 <jomg> right, seq'ing const bottom won't error i guess
12:29:50 <dwcook> Nik_: Could you rephrase your original question in terms of this code?
12:30:46 <dwcook> Ach, gotta go for a bit. Hopefully someone else can help.
12:30:49 <Nik_> It is possible to make the fourth rule match on (“not” (Number _), MultExpr _ _)
12:32:56 <khyperia> Nik_, are you sure that'd infinitely recurse?
12:33:24 <khyperia> it looks like if you repeatedly matched on the fourth one, eventually all your terms would go to the left side of the top-level mult equasion
12:34:47 <khyperia> well, to be honest, I'm not too sure what that code is doing.
12:35:15 <Nik_> khyperia: I think you’re right, if may have been confusing my problem
12:35:39 <khyperia> if you still have issues, Nik_, try explaining what the code is generally doing first
12:36:07 <khyperia> looks like some sort of constant folding?
12:38:35 <Nik_> khyperia: Basically ya, canonicalizing an expression parse tree.  I think it will recurse, infinitely, but in a different way.  Rule 3 will cause the two numbers not to be folded.  So if I pick that to fold the numbers, I should be fine
12:38:52 <Nik_> s/pick/change
12:41:11 <Nik_> So basically I don’t think my negative pattern matching solution was necessary.  Thanks khyperia for looking at it
12:44:30 <aloiscochard> I'm looking to do a groupbyy like (a -> b) -> [a] -> [(b, [a])], any pointer?
12:46:37 <vanila> is that grouping all 'a' which has the same 'b'?
12:46:45 <aloiscochard> vanila: right
12:46:56 <mgaogw> I'm having some difficulty importing repa. I ran cabal install repa-devil and cabal install repa, and cabal install repa-devil. import Data.Array.Repa works fine, but import Data.Array.Repa.IO fails. This is definitely part of the library. Any ideas?
12:47:27 <vanila> you might want to go through map to create that
12:47:43 <aloiscochard> vanila: okay, I thought that might be the answer :-)
12:47:45 <enthropy> @type map (_1 %~ head) . groupBy ((==) `on` fst)
12:47:46 <lambdabot> (Field1 [(b2, b3)] b [b1] b1, Eq b2) => [(b2, b3)] -> [b]
12:48:16 <aloiscochard> I don't feel like having to rely on lense to do that feel right
12:48:27 <enthropy> that one isn't right either
12:48:35 <aloiscochard> all right :)
12:48:41 <aloiscochard> I'll try with Map, thanks folks
12:48:43 <enthropy> @type map ((_1 %~ head) . unzip) . groupBy ((==) `on` fst)
12:48:45 <lambdabot> Eq b1 => [(b1, b)] -> [(b1, [b])]
12:49:04 <aloiscochard> that is sweet
12:55:31 <vanila> > let f = (`mod`3) in M.fromListWith (++) . map (f &&& return . id) $ [1,2,3,4,5,6,7]
12:55:33 <lambdabot>  fromList [(0,[6,3]),(1,[7,4,1]),(2,[5,2])]
12:55:41 <vanila> aloiscochard, there's a way to do it
12:57:12 <oconnore> If I'm defining a type class like Show, how can I define a function that returns (show x) when it's a member of Show, and a default value, like "unrenderable" if it's a different value not in the class?
12:57:27 <vanila> no
12:57:36 <aloiscochard> vanila: that is just what I was trying to achive, nice! with combinators from base
12:57:41 <aloiscochard> vanila: thanks a lot
12:57:41 <oconnore> no?
12:57:45 <vanila> noprob
12:57:58 <vanila> oconnore, it''s not possible because of the way typeclasses work
13:00:12 <dwcook> oconnore: You could, on the other hand, create a newtype that has this "default" instance, and wrap anything in it that you want to do that with.
13:00:43 <oconnore> vanila: so how is it possible that the compiler can derive Show from an unrestrained type constructor?
13:00:58 <dwcook> newtype MakeRenderable a = MakeRenderable a ; instance Renderable (MakeRenderable a) where ...
13:02:10 <dwcook> oconnore: Deriving only works for certain typeclasses and must be explicitly requested.
13:03:33 <abc56889_> Does anyone know if it is possible to pass output from a test to subsequent tests using Test Framework?
13:03:35 <oconnore> ok, thanks
13:05:05 <nschoe> Is there a function in blaze-html that allows me to convert newlines to <br> tag ?
13:08:19 <michaelt> mgaogw: there are "Data.Array.Repa.IO.x" modules for various purposes in repa-io etc., but not "Data.Array.Repa.IO"?
13:09:49 <dfeuer> @type 0True
13:09:50 <lambdabot> Num (Bool -> t) => t
13:09:54 <dfeuer> Can someone explain that?
13:10:24 <dfeuer> The same thing happens in GHCi.
13:10:39 <dwcook> dfeuer: That seems to parse as 0 True
13:10:57 <dwcook> I.e., the application of 0 to True
13:11:19 * dwcook checks the syntax in the report
13:11:26 <jle`> that's pretty neat
13:11:30 <jle`> by neat i mean horrible
13:11:49 <dfeuer> dwcook, that's ... weird.
13:11:59 <dwcook> dfeuer: Which part?
13:12:05 <michaelt> > replicate 0True
13:12:07 <lambdabot>  []
13:12:20 <jle`> > replicate 5True
13:12:22 <lambdabot>  [True,True,True,True,True]
13:12:23 <jle`> w0w
13:12:31 <c_wraith> > replicate 10Nothing
13:12:32 <nschoe> Well, this is weird ^^
13:12:33 <lambdabot>  [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Not...
13:12:40 <jle`> learn something new every day
13:12:45 <dfeuer> That it would be parsed so is pretty strange.
13:12:59 <jle`> > 5x
13:13:00 <michaelt> and they say Haskell is too sensitive to white space...
13:13:01 <lambdabot>  No instance for (GHC.Show.Show a0)
13:13:01 <lambdabot>    arising from a use of ‘M575919227370482833230276.show_M5759192273704828332...
13:13:01 <lambdabot>  The type variable ‘a0’ is ambiguous
13:13:01 <lambdabot>  Note: there are several potential instances:
13:13:01 <lambdabot>    instance [safe] GHC.Show.Show
13:13:11 <dwcook> Okay, just checking, depending on the person the strange thing could've been that functions could theoretically be numbers
13:13:32 <dfeuer> No, that part makes more sense.
13:13:39 <ystael> > replicate (0True)
13:13:39 <hae> Not sure if this should be considered a parse error or a feature.
13:13:41 <lambdabot>  No instance for (GHC.Num.Num (GHC.Types.Bool -> GHC.Types.Int))
13:13:41 <lambdabot>    arising from the literal ‘0’
13:13:46 <jle`> :t 0Just 4
13:13:47 <lambdabot> (Num ((a -> Maybe a) -> a1 -> t), Num a1) => t
13:13:59 <jle`> lmao it is parsed as (0 Just) 4
13:14:03 <dfeuer> Although I'm not sure if such instances are possible without extensions.
13:14:03 <dwcook> Well I certainly wouldn't encourage anyone to write code like that, but I can see how it'd be handy for golfers
13:14:06 <jle`> instead of 0 (Just 4)
13:14:17 <jle`> ...which makes sense
13:14:21 <dwcook> jle`: Well sure, it's as if you wrote 0 Just 4
13:14:34 <jle`> yeah
13:14:37 <jle`> :|
13:14:50 <jle`> hm
13:14:56 <jle`> this is too weird
13:15:01 <jle`> but i guess it's an unambiguous parse
13:15:08 <jle`> :t let x = True in 0x
13:15:09 <lambdabot> Num (Bool -> t) => t
13:15:12 <dwcook> My guess is it's something like numeric literals must end when something not a digit or a . is encountered, or whatnot, so a new token can begin there
13:15:12 <jle`> heh
13:15:37 <dfeuer> It leads to intense weirdness if you use X or O instead.
13:15:41 <dwcook> … You know this is a priceless opportunity for obfuscation, come to think of it
13:15:49 <dfeuer> But.
13:15:51 <dfeuer> maybe that's okay.
13:16:01 <jle`> fsvo okay
13:16:03 <dwcook> You could create a Num instance for functions that does multiplication when you write something like 10x
13:16:04 <dfeuer> Sorry, here's weird.
13:16:20 <dfeuer> What if you make a datatype with a constructor X5?
13:16:29 <Iceland_jack> dwcook: You go too far :)
13:16:35 <dwcook> dfeuer: what'd be wrong with that?
13:16:40 <jle`> i think people have written that
13:16:46 <jle`> actually...
13:16:49 <jle`> i've written that >_>
13:16:52 <dwcook> XD
13:16:57 <hae> > 5* 3
13:16:59 <lambdabot>  15
13:17:06 <hae> > 5*3
13:17:07 <jle`> so i could write something like 10 6 == 60
13:17:07 <dfeuer> dwcook, then 0X5 looks like 0 X5 and also like hexadecimal 5.
13:17:07 <lambdabot>  15
13:17:16 <dwcook> > 0X5
13:17:20 <lambdabot>  5
13:17:23 <dfeuer> But I imagine the hex will win.
13:17:26 <dwcook> It does
13:17:33 <jle`> interesting
13:17:39 <jle`> is 0X5 even allowed, then ... ?
13:17:43 <jle`> i guess it should be
13:17:46 <dwcook> Yes, I just showed it is
13:17:53 <jle`> oh i thought you meant to use that as hex
13:18:02 <jle`> i mean, is 0(X5) allowed
13:18:06 <nschoe> So can anybody tell me how I can display some text that comes from a textarea and has newlines into <br> tags ? I feel kinda stupid
13:18:08 <dwcook> Well if you wanted to *actually* apply 0 to X5, it'd have to be written 0 X5
13:18:26 <jle`> so it's like a [False..True] situation
13:18:32 <dfeuer> As it should, but that makes 0X be a whole different beast from 0X5, and 0X5 a whole different beast from 0M5 or whatever.
13:18:36 <hae> Actually I think this must be a feature, for just general aesthetic mathematical notation.
13:18:36 <jle`> where you'd ahve to write [False .. True] to do what you want
13:18:37 <aloiscochard> vanila: actually that does not work, because what you show me with arrow give "(a -> a) -> [a] -> Map a a" but I want "(a -> b) -> [a] -> Map a b"
13:18:38 <joshc> oconnore: the derived Show instance will have the Show constraints on the type variables; for example: newtype Foo a = Foo a deriving Show; would derive an: instance Show a => Show (Foo a) where ...
13:18:46 <hae> For example, (-4).
13:18:47 <aloiscochard> vanila: as in your example both type were Int it worked
13:20:04 <dwcook> nschoe: Depending on what you're doing, you might not need to do that
13:20:27 <dfeuer> dwcook, from one perspective, the confusion factor is a downside. From another perspective, the big downside is that it's impossible to add extra magic number letters without potentially breaking (sufficiently weird) code.
13:20:45 <dwcook> nschoe: I'm not familiar with whatever Haskell library you might be using but I can tell you that it is possible in HTML to get line breaks to act as line breaks under certain circumstances
13:21:12 <nschoe> dwcook, how so ? I have some contents written in a textarea, then stored with acid-state (I'm following Happstack tutorial). But then when I display the content, I've got everything on one line.
13:21:21 <nschoe> But it does appear on several when I right click > view page source
13:21:24 <dwcook> dfeuer: Oh I still think that syntax should be burned with fire, it's just interesting if your goal is to obfuscate :P
13:22:21 <dwcook> nschoe: Sure, and the solution to that is to display in such a manner that the line breaks count. I think you can get that with white-space:pre
13:22:25 <pseudolio> dfeuer: I believe the point of the specification is for comments and operators.
13:22:30 <spott> Is there a way to have one class imply another class.  For example: I have a class "Matrix", and using the functions available in this class, I create a "showMatrix" function.  I want this function to be used whenever someone attempts to "show" a Matrix.  (I want every class that implements Matrix to also be implementing Show)
13:22:31 <vanila> :t \(f :: a -> b) -> M.toList . M.fromListWith (++) . map (f &&& return . id)
13:22:32 <lambdabot> Ord b => (a -> b) -> [a] -> [(b, [a])]
13:22:33 <spott> is this possible?
13:22:35 <vanila> aloiscochard ^
13:22:40 <pseudolio> -- is a comment, --- is a comment, but --| is an operator.
13:22:54 <dwcook> nschoe: strictly speaking that's CSS, not HTML, I misspoke. But either way you can just add that to the display element
13:23:12 <pseudolio> But, the way the spec is written, it applies to other things, like 0True.
13:23:14 <nschoe> dwcook, well it doesn't seem semantically correct, right ?
13:23:15 <jle`> spott: it is possible; in many cases it is not recommended
13:23:22 <dwcook> nschoe: Why not?
13:23:24 <jle`> spott: but this is what the Show instance for list looks like
13:23:31 <hae> spott, try Matrix deriving Show?
13:23:32 <jle`> spott: instance Show a => Show [a] where ...
13:23:45 <jle`> oh
13:23:47 <jle`> no, it'd be
13:24:02 <jle`> Matrix is a typeclass
13:24:05 <pseudolio> And Foo.default
13:24:06 <nschoe> dwcook, so it is CSS that is in charge od displaying a "\n" with a new line ?
13:24:12 <jle`> yeah, this is in general not recommended, but it is possible
13:24:22 <jle`> i think you need UndecidableInstances or OverlappingInstances
13:24:22 <pseudolio> Although I don't think GHC handles Foo.default the way the spec is written.
13:24:27 <dwcook> nschoe: I wouldn't phrase it that way, but you can use CSS to say "Please display \n as actual newlines"
13:24:27 <jle`> or IncoherentInstances
13:24:35 <jle`> ...pick two
13:24:51 <jle`> spott: the syntax would be instance Matrix a => Show a where...
13:24:59 <jle`> plus any other constraints you need on a
13:25:10 <spott> jle`: thanks
13:25:16 <jle`> but i don't think this is useful in its current form
13:25:36 <jle`> because you need to define a generic Show that is generic for *all* Matrix instances
13:25:38 <nschoe> dwcook, I understand. Still seems weird. But if this is the accepted solution, I'll do that. Thanks !
13:25:38 <dwcook> nschoe: I wasn't being dismissive when I said "Why not?", by the way, I was actually curious if you had a reason. If the reason you didn't answer is because you don't, well, that's fine then
13:25:40 <jle`> and i'm not sure how that would be a useful Show
13:25:50 <dwcook> nschoe: I don't know if it's "the" accepted solution, but it seems okay to me.
13:25:51 <jle`> or a "meaningful" Show, matching normal Show semantics/purposes
13:26:03 <nschoe> dwcook, no no sorry, actually I'm very passionate about that answer, I did not want to bother you.
13:26:05 <jle`> the recommended path would be to just write every Matrix Show instance on its own
13:26:21 <dwcook> nschoe: I can't imagine how you would be bothering me
13:26:42 <aloiscochard> vanila: that is wonderful, ty :) ... I wish I was able to work it out myself... but I'll be able to study your example
13:26:52 <vanila> glad to help :)
13:27:04 <michaelt> nschoe: if you want <br> not newlines in the text area, shouldn't you just put it in the Markup with br
13:27:11 <jle`> spott: yeah, it's in general very discouraged to do something like that
13:27:16 <jle`> after thinking about it more
13:27:21 <nschoe> dwcook, ho nice, then. So actually I really think HTML and CSS *do* have different roles. HTML is for semantics. It means (for me) that a program should be able to "undertand" a web page by parsing the HTML and ignoring the CSS
13:27:33 <vanila> aloiscochard, one thing is that (f &&& return . id) is just a fancy way to write (\e -> (f e, [e]))
13:27:38 <jle`> because you'll have trouble defining any specific Show instances for specific Matrix types
13:27:40 <dwcook> nschoe: Okay, sure.
13:27:46 <nschoe> michaelt, how ?
13:27:47 <jle`> which one would GHC choose...?
13:27:51 <vanila> and then you make use of Data.Map to merge the snd-lists by the fst element
13:28:15 <nschoe> dwcook, it's the same debate with either <strong> and <span style="font-weight: bold"></span> is the same. It is not.
13:28:17 <spott> jle`: I can define a general matrix show using only functions which are defined in "Matrix".
13:28:43 <aloiscochard> vanila: that was just what I was missing (the fancy Arrow thing)!
13:28:45 <jle`> ah, ok.  if you are confident that no Matrix types will ever need their own Show instance, then..
13:28:50 <aloiscochard> that is impressive how powerful it is
13:28:55 <nschoe> michaelt, what do you mean by "put it in the Markup with br" ? This is some text that the user writes.
13:28:56 <dwcook> nschoe: The question in this circumstance is whether the line breaks are a semantic or presentational feature. I don't have strong arguments for either but my guess was the latter.
13:28:57 <aloiscochard> and abstract
13:29:02 <michaelt> nschoe: you are already using 'textArea :: Html -> Html" I guess; but you want to break it up
13:29:20 <spott> jle`: at the moment, it is a debugging thing... I don't know if I will ever export it
13:29:34 <jle`> instances are always exported :)
13:29:51 <jle`> that's a..."feature" >_>
13:29:58 <michaelt> nschoe: ah, I'm finally getting it, yes. This is a little complicated
13:30:10 <nschoe> dwcook, indeed this is the question. I guess it depends. But when you want to separate ideas, or parts of an article, what other choice do you have than using newlines ?
13:30:21 <dfeuer> pseudolio, how does that relate to numbers?
13:30:27 <dwcook> nschoe: Actually, there's a perfectly workable solution if it is semantic: Use a pre element.
13:30:41 <nschoe> michaelt, yeah I thought so. Because the argument in "textarea" is empty (I don't want any placeholder).
13:31:13 <nschoe> dwcook, hum... so instead of merely displaying the contents into a <div> I should use a <pre> ? That's interesting
13:31:27 <dwcook> nschoe: It could also be inside a div but the actual user content should be in a pre, I'd say.
13:31:40 <stephenmac7> Any way I can make catMaybes operate on a functor? Like catMaybes [IO (Just 5), IO (Nothing), IO (Just 29)]
13:31:40 <jle`> divs are a last-resort kind of thing for semantic html
13:31:46 <dwcook> nschoe: Now that I think about it I think you're right, that it is semantic, and in that case I'd peg that as a good solution.
13:31:56 <jle`> stephenmac7: what do you want to turn it into?
13:32:09 <stephenmac7> jle`: [IO 5, IO 29]
13:32:10 <spott> jle`: I should rephrase that: I might remove it from the code
13:32:16 <jle`> spott: :)
13:32:22 <jle`> then go ahead
13:32:37 <nschoe> dwcook, using a pre ?
13:32:43 <dwcook> nschoe: because semantically, a pre element says "The text within should be taken verbatim"
13:32:45 <pseudolio> dfeuer: The rule in question goes like: lexing may have to break up strings of non-whitespace characters based on whether a token would be a parse error.
13:32:46 <jle`> stephenmac7: you can use sequence to turn it into a list of IO
13:32:46 <dwcook> nschoe: yes
13:32:55 <hae> spott, the technical term for that is "decoding" it.
13:32:58 <nschoe> jle`, so you say ideally one should "never" use <div> for placing content directly ?
13:33:11 <nschoe> dwcook, yeah, the more I talk about it with you, the more I'm convinced you're right.
13:33:20 <jle`> nschoe: in an ideal world there would be no div, and every content container would have a semantic tag
13:33:35 <pseudolio> So, default is an invalid name for a definition, because it is a keyword, so 'Foo.default' is not a valid qualified name.
13:33:41 <jle`> but not every semantic situation is worth making a whole tag about, so div is for stuff that falls trhough the cracks
13:33:47 <dwcook> Yeah, divs and spans are semanticless elements in a semanticful world
13:33:53 <pseudolio> So the lexer should generate tokens: Foo . defaul t
13:33:59 <nschoe> jle`, HTML5 improved this a bit, didn't it ? <article>, <section>, <aside>, etc, right ?
13:34:00 <stephenmac7> jle`: Think that would work.
13:34:01 <pseudolio> And it becomes the application: Foo.defaul t
13:34:24 <jle`> stephenmac7: that's...the best thing i can think of, i think.  sequence, then fmap catMaybes
13:34:30 <pseudolio> The rule for breaking it up is that you take as many characters as would be valid before breaking.
13:34:45 <pseudolio> So you break between the l and t.
13:34:46 <jle`> there might be a more "concise" way, but i think everyone would understand that
13:35:08 <jle`> sequence :: [IO (Maybe a)] -> IO [Maybe a]
13:35:15 <jle`> fmap catMaybes :: IO [Maybe a] -> IO [a]
13:35:29 <nschoe> jle`, but then in what do you present your contents of, say, an article about cooking, or haskell, or the news on the Times website ?
13:35:32 <dfeuer> pseudolio, that rule sounds like a disgusting hack.
13:35:49 <jle`> nschoe: well the article would be in an <article> tag
13:36:10 <nschoe> dwcook, jle`, thanks for the talk, btw. Never imagined I'd actually talk HTML / CSS / semantics on the #haskell chan
13:36:16 <stephenmac7> jle`: Yeah. That works perfectly. Thanks.
13:36:19 <dwcook> nschoe: You may have misread jle`'s "more 'concise' way" message as being directed at you
13:36:34 <jle`> oops
13:36:41 <jle`> yeah the concise thing was directed at stephenmac7
13:36:52 <nschoe> jle`, yeah, that's the wrapper, but what about the texts ? All in severals <p> ?
13:36:57 <stephenmac7> Actually, it gives me the chance to use <- in do notation
13:37:05 <augur_> dwcook: did i mention that we're basically done? :x
13:37:08 <jle`> nschoe: paragraphs should be in <p> :)
13:37:12 <nschoe> dwcook, yeah I know I didn't react to the "concise" comment ^^
13:37:14 <jle`> that's <p> means, semantically
13:37:20 <jle`> paragraphs for copy text
13:37:28 <dfeuer> pseudolio, it also doesn't work quite like that.
13:37:31 <nschoe> jle`, obvisouly, but should all texts form paragraph ?
13:37:33 <dfeuer> @Prelude.default
13:37:34 <dwcook> augur_: Maybe? I know you made some breakthroughs
13:37:34 <lambdabot> Unknown command, try @list
13:37:39 <dfeuer> > Prelude.default
13:37:40 <pseudolio> GHC doesn't work that way for default, as I said.
13:37:41 <nschoe> jle`, well forget about it, I'm being stupid here. You're right.
13:37:42 <lambdabot>  Not in scope: ‘Prelude.default’
13:37:42 <lambdabot>  Perhaps you meant ‘Prelude.fail’ (imported from Prelude)
13:37:45 <nschoe> It solved my problem ^^
13:37:55 <pseudolio> It is broken with respect to the specification.
13:37:59 <pseudolio> Or was, at some point.
13:38:07 <augur_> dwcook: i might have mentioned the other day, but
13:38:24 <pseudolio> I don't know if the spec has been amended to not be so crazy.
13:38:40 <dfeuer> Oh, I see.
13:38:53 <dfeuer> I don't see where you said that, but it doesn't matter.
13:38:55 <augur_> dwcook: semToExp (parse "John saw Susan yesterday") == \e -> See e * Seer e John * Seen e Susan * Yesterday e
13:39:04 <augur_> dwcook: thats what it does, basically. =x
13:39:05 <spott_> I have a simple function:
13:39:08 <spott_> showMatrix :: (Matrix m val) => m val -> String
13:39:08 <spott_> showMatrix m = concatMap (\x -> show (m !! x) ++ "\n") [0..(fst $ dim m)]
13:39:13 <dwcook> augur_: aw yeah, sweet!
13:39:17 <pseudolio> It does 'correctly' break up 0True, though.
13:39:21 <pseudolio> As you noticed.
13:39:27 <eacameron1> is haskell.org down?
13:39:33 <spott_> but the compiler is complaining that !! is ambiguous...
13:39:48 <spott_> I'm confused as to why
13:39:57 <stephenmac7> eacameron: No, http://isup.me/haskell.org
13:40:00 <spott_> m is confined to be a Matrix
13:40:03 <dwcook> augur_: Hmm, though why is it a lambda? What is e?
13:40:18 <enthropy> spott_: you hid the Prelude.!!?
13:40:27 <spott_> enthropy: no
13:40:37 <eacameron> stephenjudkins: hah, that is down for me too
13:40:44 <bitemyapp> eacameron: no
13:40:50 <stephenjudkins> eacameron: say what
13:40:51 <carter> Q: is there an xml version of aeson?
13:40:59 <eacameron> stephenjudkins: just me I guess
13:41:01 <dwcook> augur_: Oh, it's an event that you're making judgments about?
13:41:06 <spott_> but !! can't possibly be Prelude.!!, because Prelude.!! operates on lists
13:41:07 <monochrom> carter: tagsoup may count
13:41:08 <enthropy> spott_: well do that (or refer to !! by it's full name)
13:41:12 <eacameron> maybe somethings up with my network then, sorry to bother
13:41:13 <carter> monochrom: nope
13:41:13 <stephenjudkins> eacameron: i think you meant to send that message to someone else
13:41:18 <spott_> not Matrices
13:41:20 <carter> tagsoup isn't XML
13:41:28 <eacameron> stephenjudkins: you're right
13:41:29 <augur_> dwcook: actually yeah it should be existentially closed, but i didnt implement that yet :)
13:41:38 <augur_> dwcook: thats just a grammatical rule tho
13:41:39 <stephenmac7> eacameron: That website tends to be quite nice for that type of thing.
13:41:52 <eacameron> stephenmac7: I'll keep it, thank!
13:41:53 <eacameron> s
13:42:03 <enthropy> spott_: ghc doesn't do that
13:42:04 <spott_> so, why doesn't the compiler realize that Prelude.!! doesn't apply
13:42:08 <monochrom> carter: does http://hackage.haskell.org/package/xml count?
13:42:10 <dfeuer> spott_, !! is just a function, not a typeclass member.
13:42:21 <dfeuer> There can only be one thing named !! at a time.
13:42:29 <carter> monochrom: mebe
13:42:29 <monochrom> oh wait, what does aeson do? :)
13:42:32 <carter> lol
13:42:33 <jle`> spott_: haskell doesn't have type directed name resolution
13:42:34 <enthropy> also, it might get a bit crazy if you had instance Matrix [] a
13:42:43 <spott_> jle`: oh.
13:42:46 <carter> i've an XML api i want to query
13:42:48 <jle`> i think it was chosen to not be a feature
13:42:52 <jle`> by some conscious choice
13:43:02 <carter> jle`: its because its no parametric
13:43:09 <carter> and also its tricky
13:43:14 <carter> to do correctly
13:43:15 * monochrom misread as "is there a trifecta for xml?" and simply recalled efficient xml parsers
13:43:22 <johan_> hey has anybody an idea. I'm searching for a solution that removes me every element of a list which do not start with the number 8. e.g [10, 28, 81, 302, 832, 488, 4378, 23, 34, 87]. after removing the elements the list should be like this. [81, 832, 87]. The signature: select_8 :: [Int] -> [Int]
13:43:27 <spott_> enthropy: that shouldn't be possible:  val is constrained to be U.Unbox and Num
13:43:36 <jle`> that is, if you have two functions named foo, but with different type signatures, you still have to manually specify which foo you want in a specific situation
13:43:42 <jle`> i think...
13:43:45 <carter> monochrom: pretend im doing some work where I need to query something like AWS XML api
13:43:47 <carter> but not AWS
13:43:53 <jle`> yeah, it'd also basically give you pretty ad-hoc polymorphism
13:43:53 <dfeuer> So if you want to import a module that defines !!, you have to either import that module hiding ((!!)), or import Prelude hiding ((!!)). Commonly,  import qualified Foo as F. Then you can use F.!!.
13:43:54 <carter> and want to have pretty haskell types
13:44:02 <jle`> and it'd be hard to really reason about anything
13:44:04 <carter> but also good to/from XML
13:44:08 <jle`> if (+) can be literally (+) from anywhere
13:44:11 <enthropy> spott_: instance (U.Unbox a, Num a) => Matrix [] a -- should be accepted then
13:44:15 <dfeuer> Alternatively, if you don't need the Prelude !!, you can explicitly  import Prelude hiding ((!!)).
13:44:18 <jle`> also type errors would be pretty bad
13:44:19 <monochrom> yeah, something Applicative and lets you pick out "field values"
13:44:35 <monochrom> I don't know of one then
13:44:42 <jle`> this was the solution that typeclasses were invented to circumvent
13:44:56 <spott_> enthropy: ah
13:44:59 <spott_> I see
13:45:59 <dwcook> johan_: filter (\x -> case show x of '8':_ -> True ; _ -> False)
13:46:18 <dwcook> (Feel free to spread that across lines and/or give it a name)
13:46:29 <johan_> the filter function is not bad i thougth about that
13:47:15 <hellen_haskeller> dwcook: the case show x of should be case (show x) of ?
13:47:23 <dwcook> Pretty much every time you want to select elements of a list based on just the individual element, think filter
13:47:33 <jle`> i think case show x of ... should work
13:47:39 <jle`> case and of are keywords
13:47:43 <dwcook> hellen_haskeller: No, it's unambiguous enough that any expression can go there.
13:48:03 <hellen_haskeller> ah ok
13:48:09 <jle`> so haskell won't try to think of case show x of as ((case show) x) of
13:48:19 <dwcook> No, because case is reserved
13:48:21 <jle`> case/show aren't functions but keywords
13:48:33 <dwcook> s/No ,/
13:48:35 <dwcook> s/No ,//
13:49:12 <johan_> ok
13:49:25 <joshc> if you feel like your code could use more GHC extensions, you can use -XLambdaCase and shorten it to: filter (\case '8':_ -> True; _ -> False)
13:49:48 <dwcook> joshc: Remember to compose with show
13:50:02 <joshc> ah, yes
13:50:04 <jle`> case/of
13:50:04 <johan_> is it possbile to pick out the first number of an integer like 487  the 4?
13:50:20 <jle`> johan_: how do you want it to behave in the case of 0, or negative numbers?
13:50:45 <johan_> you mean of the list is empty?
13:50:47 <vanila> > head . show $
13:50:48 <dwcook> That's true, the function I gave doesn't work on negative numbers whose first digit is 8
13:50:48 <lambdabot>  <hint>:1:14:
13:50:48 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:50:49 <vanila> > head . show $ 487
13:50:51 <lambdabot>  '4'
13:51:17 <jle`> > digitToInt . hard . show $ 487
13:51:19 <lambdabot>  Not in scope: ‘hard’
13:51:21 <dwcook> Hmm, you could compose with abs I suppose
13:51:23 <jle`> > digitToInt . haed . show $ 487
13:51:24 <lambdabot>  Not in scope: ‘haed’
13:51:25 <lambdabot>  Perhaps you meant one of these:
13:51:25 <lambdabot>    ‘head’ (imported from Data.List),
13:51:25 <lambdabot>    ‘BS.head’ (imported from Data.ByteString),
13:51:25 <lambdabot>    ‘BSL.head’ (imported from Data.ByteString.Lazy)
13:51:29 <jle`> >______>
13:51:33 <jle`> > digitToInt . head . show $ 487
13:51:35 <lambdabot>  4
13:51:53 <dwcook> digitToInt . head . show . abs $ -487
13:51:54 <stephenmac7> How would I go about checking the width of a character?
13:51:57 <dwcook> > digitToInt . head . show . abs $ -487
13:51:59 <lambdabot>  4
13:52:12 <jle`> stephenmac7: width?
13:52:18 <jle`> character?
13:52:51 <stephenmac7> jle`: For example, a takes up one space while 今 takes up two
13:53:21 <jle`> on my screen both are the same width, i think
13:53:32 <jle`> do you mean the size of the unicode representation?
13:53:33 <stephenmac7> So, if you're printing out to the terminal, it makes it hard to make an aligned table
13:53:46 <stephenmac7> No, I mean the literal size on the screen
13:53:51 <dwcook> So this has to do specifically with monotype fonts
13:53:59 <c_wraith> jle`: most fixed-width fonts respect double-width and single-width
13:54:15 <jle`> 今_
13:54:17 <jle`> ___
13:54:19 <jle`> oh
13:54:21 <jle`> it does take up two spaces
13:54:23 <jle`> what do ya know
13:54:53 <stephenmac7> It's translated meaning takes up much more space, but that's besides the point.
13:55:07 <c_wraith> what is that..  Money?
13:55:12 <stephenmac7> Clock
13:55:14 <stephenmac7> Or now
13:55:18 <c_wraith> wow, I'm way off.
13:55:20 <jle`> time is money
13:55:23 <jle`> so you're not that far off
13:55:42 <c_wraith> Anyway.  I don't think there's a database for that as part of unicode.
13:56:01 <stephenmac7> In Python it's in the unicodedata library
13:56:16 <c_wraith> I meant as part of the unicode spec, to be precise.
13:56:28 <stephenmac7> Oh, I see.
13:57:48 <c_wraith> There are conventions about what width characters should have, but I don't think it's enforced.
13:58:11 <johan_> so thanks a lot
13:58:20 <dwcook> I wonder if you could find differences between terminals, say, xterm versus gnome-terminal versus… whatever else is out there
13:58:23 <johan_> this does work
13:58:27 <jedai> It must be somewhere though for font rendering libraries to work
13:59:03 <dwcook> Windows console would be an interesting one to check :P
13:59:09 <dwcook> s/interesting/probably horrible/
13:59:43 <stephenmac7> Seems there's something on it http://www.unicode.org/reports/tr11/
13:59:45 <c_wraith> does windows console even support real unicode, or only code pages?
14:00:04 <c_wraith> stephenmac7: heh.  Did you see the date on that?
14:00:22 <stephenmac7> It's new...
14:00:27 <c_wraith> Looks like it does say that the situation has moved forward, though.  Widths are standardized now!
14:00:28 <stephenmac7> Never expected that.
14:01:08 <stephenmac7> Better than it used to be... there were half-width characters and other stange things
14:01:48 <c_wraith> stephenmac7: anyway, if the functions you need aren't in either Data.Char or the text-icu package, it probably hasn't been implemented
14:02:47 <stephenmac7> https://hackage.haskell.org/package/text-icu-0.6.3.7/docs/Data-Text-ICU-Char.html#t:EastAsianWidth_ looks promising
14:03:01 <c_wraith> ah, nice
14:03:22 <c_wraith> just beware that text-icu is sometimes finicky about compiling
14:03:25 <dwcook> More particularly https://hackage.haskell.org/package/text-icu-0.6.3.7/docs/Data-Text-ICU-Char.html#t:EastAsianWidth
14:03:51 <dwcook> "Ambiguous" sounds sketchy
14:04:20 <stephenmac7> dwcook: Yes, very sketchy. However, I have never seen a character with that one.
14:05:01 <dwcook> So, your goal is to align things on a terminal, right?
14:05:11 <stephenmac7> The ones I'm interested in have so far, not been like that... chinese characters like 七 and phonetics like ぷ　and a.
14:05:14 <stephenmac7> dwcook: Exactly
14:05:18 <dwcook> I bet you could possibly more accurately do that with a library that tells you what's written where on a terminal, maybe ncurses can do it
14:05:19 <carter> pretty printing is a whole domain
14:05:33 <carter> theres lots of fancy tooling for nice pretty printing
14:06:18 <stephenmac7> The "fancy tooling" happens to come with "unfancy docs"
14:06:25 <jle`> lol
14:07:12 <stephenmac7> http://hackage.haskell.org/package/boxes for example has 0 documentation
14:07:47 <stephenmac7> Or, a short description for each individual function, but no overall "big-picture" view.
14:08:15 <stephenmac7> It also doesn't handle unicode correctly
14:08:39 <dwcook> The first hint at that was that it uses String and not, say, Text
14:09:25 <stephenmac7> Even the standard https://hackage.haskell.org/package/pretty doesn't even come with a code example
14:10:02 <stephenmac7> dwcook: Quick question: why does String use UTF-32?
14:10:31 <dwcook> stephenmac7: I don't think it respects any encoding, it's more or less a list of code points
14:10:43 <stephenmac7> It doesn't?
14:11:01 <dwcook> Well Char are more or less code points
14:11:09 <dwcook> So I should say, it's a list of more-or-less code points
14:11:15 <jle`> String is just a list linked of code points
14:11:19 <jle`> er
14:11:21 <jle`> linked list
14:11:33 <jle`> so it's actually a pretty bad way of working with text
14:11:50 <dwcook> It will work in some trivial cases like ASCII
14:11:58 <dwcook> But in general you should use Text
14:11:58 <jle`> like...literally one of the worst ways you can think about working with text
14:12:12 <stephenmac7> Seems that it's not too bad... most functions like reverse and length work with unicode
14:12:25 <dwcook> String reverse and length are not unicode-aware
14:12:52 <stephenmac7> No, they aren't. They just reverse the list.
14:12:57 <jle`> it's a linked list of code points, so reverse and length literally just reverse the linked list, and count the numbre of nodes
14:13:16 <stephenmac7> But if try something like that in a language that uses c-like chars, you're toast.
14:13:20 <jle`> ah
14:13:26 <jle`> i guess that's one advantage
14:13:42 <dwcook> Aren't C chars literally bytes?
14:13:51 <stephenmac7> Yes
14:13:56 <stephenmac7> 1-255
14:14:00 <jle`> yeah, C's string is literally an array of bytes
14:14:05 <jle`> weakly typed as char
14:14:08 <jle`> char *
14:14:30 <levi> C has string literals, but not a string *type*.
14:14:37 <stephenmac7> For example, in lua if you try:
14:14:38 <stephenmac7> > return string.reverse("あべせ")
14:14:39 <lambdabot>  Not in scope: ‘string’
14:14:39 <lambdabot>  Perhaps you meant one of these:
14:14:39 <lambdabot>    ‘storing’ (imported from Control.Lens),
14:14:39 <lambdabot>    ‘trying’ (imported from Control.Exception.Lens),
14:14:39 <lambdabot>    ‘trying’ (imported from Control.Monad.Error.Lens)
14:14:53 <stephenmac7> You'll get ��㹁め� as output
14:14:55 <jle`> levi: ah yeah.  i was just referring to the conventions
14:15:53 <stephenmac7> jle`: So, a linked list of code points is much better than an array of bytes
14:16:09 <stephenmac7> But how does Text work?
14:16:17 <levi> And a string literal has type char[], but char * isn't always used for string parameters because of its signendness ambiguity.
14:16:44 <jle`> i would not say much better in general; just better/worse in different situations
14:16:55 <levi> But C has had for a long time now a wchar_t type for "wide characters" along with standard library functions to work with them.
14:18:02 <stephenmac7> levi: The only C I know is ANSI C, so I don't anything about that :P
14:19:44 <stephenmac7> levi: Looks like it was in C89 but not in Ritchie's book... guess I never learned it.
14:22:04 <AmroPlay>  How would you go about implementing a doubly linked list in haskell?
14:22:11 <int3___> hm, is there some law that determines whether applicatives commute? that is, i'd like to have some function that does `f (g a) -> g (f a)`
14:22:40 <levi> I think a lot of people are unaware of wchar_t. I'm not even sure whether using it is advisable or not.
14:23:07 <stephenmac7> levi: Seems it's used for Python's string in the C implementation of Python
14:23:40 <kazagistar> AmroPlay: the real question is why are you implementing a doubly linked list?
14:23:58 <int3___> AmroPlay: search for 'tying the knot' and 'zippers'
14:25:14 <int3___> AmroPlay: http://stackoverflow.com/questions/1844195/doubly-linked-list-in-a-purely-functional-programming-language
14:25:42 <int3___> the zipper solution is probably more useful
14:27:21 <AmroPlay> kazagistar: I am working through a C book impletementing all the tasks in haskell and then the question of a doubly linked list came up. Translating is good training BTW. Especially if you compare your results to the long and messy c code
14:27:28 <kazagistar> the only really good use of doubly linked lists I have seen "teaching pointers to undergraduates"
14:28:03 <jle`> many C data structures do not translate well into haskell data structures, and vice-versa
14:28:24 <jle`> along the same lines many data structures useful in C are not very useful in haskell, and vice-versa
14:28:39 <kazagistar> AmroPlay: you can implement it the same way as C, with mutation, but in practice, a good C programmer would probably also advise you against using a doubly linked list in practice
14:29:26 <jle`> i think you'd ahve to do some sort of knot typing to make an immutable doubly linked list analogous to haskell's [] linked list
14:29:30 <jle`> ...it'd be interesting to see it done
14:29:39 <jle`> but i'm not sure how much insight it would provide for you, for learning purposes
14:29:45 <kazagistar> AmroPlay: it is in the book for the purpose of teaching "pointer mutation", which is something haskell kinda goes out of its way to discourage
14:29:49 <jle`> knot tying
14:32:56 <dwcook> A doubly linked list? I guess that'd be kind of like a list zipper
14:38:58 <kazagistar> because I am a bad person: { data Node s a = Node {value :: a, prev :: STRef s (Node s a), next :: STRef s (Node s a) }; data DLL s a = DLL {first :: STRef s (Node s a), last :: STRef s (Node s a)} }
14:44:01 <enthropy> are there some reliable benchmarks showing at which point Prelude.!! is slower than Data.Array.! ?
14:46:59 <pjdelport> enthropy: It would depend entirely on what you use them for.
14:47:34 <pjdelport> Though generally speaking, !! will always be O(n), while ! will be O(1)
14:48:01 <kazagistar> enthropy: I would imagine pretty quickly, if not in every case, but is seems like a good idea to check
14:48:28 <dwcook> Wanting to use (!!) on lists is a good sign you might benefit from another structure anyway
14:51:09 <kazagistar> ! is potentially just a bounds check (with good branch prediction properties) and a single dereference, while !! requires a dereference for every single item, right?
14:51:28 <enthropy> yes that's the theory. I'm not sure why my benchmark isn't reproducing this
14:52:28 <kazagistar> link the benchmark I guess?
14:55:28 <jle`> O(1) isn't necessarily faster than O(n).  only above a certain threshold.
14:55:54 <jle`> um
14:55:58 <jle`> i should phrase that more properly
14:56:18 <athan> Is there any way to get a type signature of a subexpression in the presence of a context? Or to... recursively... gain sub- type signatures, of some sort?
14:56:25 <jle`> an algorithm with complexity O(1) isn't necessarily faster than one with complexity O(n) in absolute running time
14:56:27 <carter> jle`: constant factors and the choice in n metter :)
14:56:31 <carter> *matter
14:56:35 <jle`> yeah, that's what i was trying to say
14:56:38 <carter> physics and hardware are a thing
14:56:39 <enthropy> kazagistar: http://code.haskell.org/~aavogt/HList-benchmark/Runtime.hs
14:56:48 <jle`> and it seems that enthropy was asking about that exact issue, in particular
14:56:57 <carter> i choose n = 1/K(10,10)
14:57:02 <carter> so its like instance
14:57:44 <jle`> i think a common example is matrix multiplcation
14:58:04 <jle`> the naive algorithm is O(n^2) for the matrix dimensions
14:58:20 <jle`> there are algorithms with better complexities
14:58:34 <jle`> but the constant factor is huge enough that it doesn't become useful except for very very high n
14:58:39 * enthropy thinks the naive one wins on 1x1 times 1x1
14:58:49 <Pythonfant> jle`: sure about that? don't you need O(n) calculations for each entry so O(n^3) for a nxn square matrix
14:58:54 <jle`> oh yeah, i mean n^3
14:58:58 <carter> Pythonfant: theres cleverer algs
14:59:04 <carter> yean n^3
14:59:24 <Pythonfant> carter: I know but jle` was talking about the naive algorithm
14:59:27 <carter> oh yeah
14:59:29 <carter> ignore jle`
14:59:32 <carter> he's still learning :)
14:59:37 <jle`> :'(
14:59:55 <carter> jle`: you are
15:00:00 <carter> you just finsihed undergrad
15:00:05 <jle`> i know :)
15:00:05 <carter> and wasn't your focus physics?
15:00:16 <jle`> yeah but i had a decent emphasis on numerical analysis
15:00:21 <jle`> but i didn't do any of that this past year
15:00:27 <carter> whats decent
15:00:28 <carter> define terms
15:00:31 <Pythonfant> I haven't even finished undergrad
15:00:32 <carter> or be more explicity :)
15:00:48 <jle`> ok so...the naive implementation is O(n^3); there are impelemtnations that are O(n^2.4), but with a huge constant factor
15:01:01 <jle`> thatwas the 'textbook example' they gave me
15:01:03 <carter> jle`: ehhh
15:01:09 <carter> strassens alg is ok per se
15:01:18 <carter> but only really correct for finite fields I think
15:01:25 <carter> because precision issues don't happen there
15:01:26 <jle`> carter: i like to leave my terms vague enough so that i can redefine them later so i can always be right
15:01:38 <carter> jle`: that means you're wrong and not comfy with embracing itmight hapepn :)
15:01:41 <jle`> i'm talking about Coppersmith–Winograd
15:01:47 <carter> lol
15:01:51 <carter> thats never going to be used
15:02:04 <jle`> yeah, that's the point of the example :)
15:02:10 <carter> but its a bad example
15:02:14 <jle`> an algorithm with a 'lower complexity', but impractical because of the constant factor
15:02:17 <carter> because people could trot out strassen
15:02:27 <carter> and then the reason why strassen is bad (in general)
15:02:44 <carter> is because it doesn't provide the same generic stability guarantees
15:03:08 <carter> also honestly, the modern blas style general matrix mult will be faster than strassen probs :)
15:03:19 <kazagistar> ... man, I gotta learn numerical analysis
15:03:31 <carter> kazagistar: nah
15:03:40 <carter> start with real / complex analysis
15:03:41 <carter> and combinatorics
15:04:02 <carter> numerical analysis needs to be buttressed by you doing lots of experiments
15:04:08 <carter> and realzing that its rally tricky
15:04:41 <kazagistar> I took a Numerical Methods class, and it was interesting, but I dropped the class for other reasons
15:07:08 <kazagistar> as far as I understand it, numerical analysis is how to get approximations, how to get them quickly, how to analyze how close you are, and how to make sure you are actually converging on something... ish?
15:08:09 <jle`> i think for me it was just mathematics involving the nature of numerical computation
15:08:31 <jle`> so using mathematical tools to analyze the process
15:08:38 <levi> My numerical methods class was the last class I took, after not having any math classes for years.  Painful.
15:09:21 <carter> its a HUGE HUGE range of sub fields
15:10:00 <kazagistar> yeah, I took it like 3 years of having used zero calc or diffeq, and it had quite a bit of that, which was a shock to the system
15:10:12 <kazagistar> the class I was in at least
15:14:48 <timemage> anyone else have the experience of failing to learn a useful amount of haskell and repeating this process for years?  wondering if it's just me.
15:16:21 <chreekat> timemage: Only every self-taught Haskeller ever
15:16:54 <timemage> chreekat, have you produce anything you consider to be useful yet?
15:17:37 <paintcan> that's a familiar experience, i think the only way around it is sustained immersion
15:18:09 <chreekat> tibell: (or anyone else): Any good pointers for a custom cabal build that would link a (Windows) resource file into an executable? I'm trying to get an icon file linked in
15:18:35 <chreekat> timemage: I've made a couple useful contributions, and now I'm successfully introducing it at work
15:19:02 <timemage> chreekat, how long since starting?
15:19:15 <chreekat> 2010 was when i first cracked open Learn You a Haskell
15:20:02 <timemage> chreekat, my first usage was probably around 2002.
15:20:54 <darthdeus> what's the difference between ST and State?
15:21:04 <darthdeus> seems very similar from looking at it
15:21:07 <chreekat> timemage: I dove pretty deep trying to write a web app with Yesod. It kinda failed, but Yesod was written with so much "modern" Haskell ideas that I really learned a lot
15:21:19 <darthdeus> except that ST kinda stores like a map of mutable references?
15:22:41 <quchen> ST is like IO with a safe "unsafePerformIO". State is for having state.
15:22:57 <carter> quchen: ST IS IO
15:23:05 <quchen> carter: For same values of "is".
15:23:05 <chreekat> "This library provides support for strict state threads"
15:23:22 <darthdeus> none of those really help :D
15:23:27 <darthdeus> what is a strict state thread?
15:23:38 <chreekat> Dunno :D
15:23:50 <darthdeus> seems STRef is like IORef only in ST and not IO
15:23:54 <chreekat> well i can kind of guess
15:24:01 <carter> just the yup
15:25:04 <darthdeus> quchen: can you elaborate on that?
15:25:49 <timemage> paintcan, i'm not able to do that.
15:26:09 <quchen> darthdeus: You can really picture (ST s) as a version of IO that you can "run", i.e. there is a function (simplified as) "ST s a -> a", but no function "IO a -> a".
15:26:21 <quchen> ST is when you want to have a block within which you can have mutability.
15:26:40 <quchen> You can use IO to get mutability (e.g. using IORefs), but the problem is that once you're in IO you're trapped in IO.
15:26:42 <darthdeus> hmm, so it's kinda like STM, except that it's not a transaction and doesn't have retry
15:26:49 <darthdeus> ah
15:26:51 <darthdeus> i understand
15:27:05 <quchen> For ST, there's
15:27:07 <quchen> :t runST
15:27:08 <darthdeus> I mean I don't understand the "strict state thread" part
15:27:08 <lambdabot> (forall s. ST s a) -> a
15:27:14 <quchen> Ignore that part ;-)
15:27:48 <chreekat> darthdeus: I was just quoting the haddocks for the package; I agree it's not exactly enlightening :)
15:28:14 <quchen> darthdeus: ST gives you local mutability, but the type system guarantees you that if you "runST" an arbitrary ST block you'll get a pure result.
15:28:35 <quchen> It's kind of like a mutable sandbox that doesn't break Haskell's laws of immutability.
15:29:18 <chreekat> Perhaps you could say it's a sandbox where you can mutate things that doesn't infect the whole program, like IO would
15:30:42 <quchen> Imagine writing Quicksort for Vector. When you're immutable, in order to swap two elements, you'll have to copy the entire vector, but switch the two elements in the process.
15:30:50 <quchen> That's very inefficient of course.
15:31:04 <athan> kazagistar: Check out Donald Knuth's work - Concrete mathematics and asymptotics - usually supplied in discrete math books. It can actually be pretty simple - Big O, Big Theta & Big Omega _describe_ functions via other, more simple functions. It's almost like describing the subsets and supersets of equations based on systems of equations... sorta. I've still got a lot of learning :)
15:31:24 <quchen> Using ST, you can make a "local mutable copy" of the vector, swap all you want in the mutable vector, and then eject out of ST again -- giving you an immutable vector with all the swaps done.
15:31:25 <darthdeus> hmmm,binteresting
15:32:27 <darthdeus> probably dumb question, but how fast is ST compared to IORef, MVar and STM?
15:32:37 <athan> kazagistar: From what I can tell, strictness analysis is the key to gaining asymptotic insights - it feels like haskell's recursive types and passive laziness / strictness create forms of "geometric" explosions of size, opposed to the manual reduction & applications like lisp. But again, I don't know that well :)
15:32:56 <chreekat> timemage: It's tough because there's so many paradigms to "get" that all come together in Haskell but are rarely seen together elsewhere
15:33:29 <kazagistar> asymptotics is a bit different I think, the numerical stuff I was studying was more like "I have a differential equasion that has some random real number solution, how much do I need to iterate what program to get a good enough approximation of the solution"
15:34:00 <quchen> darthdeus: ST is for local mutability, MVars are for concurrent communication, STM is for guaranteed atomic concurrent communication. IORefs and STRefs are very similar actually.
15:34:43 <Robly18> evening
15:34:55 <Robly18> so, uh, i've been learning haskell
15:35:03 <quchen> ST example:
15:35:04 <quchen> > runST (do { x <- newSTRef 3; modifySTRef x (*2); readSTRef x }) -- This actually modifies "x" along the way.
15:35:06 <lambdabot>  6
15:35:13 <Robly18> and to test out my knowledge i tried making a monte carlo approximation of pi
15:35:26 <quchen> Note that although mutation happens, the type in the end is just a number, not "ST number" or something like that.
15:35:36 <quchen> :t runST (do { x <- newSTRef 3; modifySTRef x (*2); readSTRef })
15:35:37 <lambdabot>     Couldn't match expected type ‘ST s a’
15:35:37 <lambdabot>                 with actual type ‘STRef s0 a1 -> ST s0 a1’
15:35:37 <lambdabot>     Relevant bindings include
15:35:38 <athan> kazagistar: I think you're right, but I'm fairly sure what you're thinking like is the same principal
15:35:45 <quchen> :t runST (do { x <- newSTRef 3; modifySTRef x (*2); readSTRef x })
15:35:46 <lambdabot> Num a => a
15:36:18 <quchen> On the other hand, if you do the same with IO, you can have mutation as well:
15:36:34 <quchen> :t do { x <- newIORef 3; modifyIORef x (*2); readIORef x })
15:36:35 <lambdabot> parse error on input ‘)’
15:36:39 <quchen> Goddammit
15:36:39 <athan> So if `(fmap (+ 1) (* 2)) 3 = 7`, would `(contramap (+ 1) (* 2)) 3 == 8`?
15:37:23 <darthdeus> but it is actually doing references under the hood unlike the state monad, right?
15:38:02 <quchen> IO and ST are different from State, yes.
15:38:13 <quchen> State is literally just "chaining functions of type `a -> (s,a)`.
15:38:15 <quchen> "
15:39:01 * quchen always switches up "s" and "a" there for some reason. The result is still correct but a bit misleading. `state -> (a, state)` is probably better.
15:39:09 * hackagebot hakaru 0.1.2 - A probabilistic programming embedded DSL  http://hackage.haskell.org/package/hakaru-0.1.2 (z)
15:39:55 <gridaphobe> is it possible to time individual tests in tasty and record how long they each took?
15:44:24 <Fuuzetsu> quchen: because functor
15:44:27 <Fuuzetsu> newtype it
15:46:41 <quchen> Fuuzetsu: ?
15:49:26 <timemage> chreekat, my problem with it seem to stem from ridiculously complicated type signatures.  in same cases, i really can't tell what i'm looking at.   it may just be a limit of my brain.  no matter the reason, i've pretty well decided to stop investing time in it.  my one reasonably large project i'll eventually rewrite.
15:50:54 <quchen> What's a "ridiculously complicated type signature"?
15:51:15 <quchen> That threshold varies wildly between people.
15:51:16 <cgag> something from yesod
15:51:45 <athan> cgag++
15:51:47 <chreekat> sad but true
15:51:59 <chreekat> timemage: 'it' being yesod? Because yes
15:52:01 <quchen> I've never seen a Yesod type sig.
15:52:04 <quchen> BRB.
15:52:25 <timemage> chreekat, no, the language itself.
15:52:32 <chreekat> ah
15:55:59 --- mode: cameron.freenode.net set +o ChanServ
15:58:58 <quchen> cgag: http://hackage.haskell.org/package/sessions-2008.7.18/docs/Control-Concurrent-Session.html
15:58:59 <quchen> ;-)
15:59:10 * hackagebot yaml-light-lens 0.3.1.2 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.3.1.2 (AnthonyCowley)
16:00:25 <chreekat> haha wat
16:01:00 <quchen> "Which part don't you understand"
16:02:39 <chreekat> This raises the point that if you don't understand a type yet, take a deep breath and go find a type you DO understand :)
16:04:41 <cgag> quchen: bravo
16:05:27 <quchen> Credits to thoughtpolice who showed me that first.
16:07:22 <stephenmac7> Can State be an Applicative Functor?
16:07:23 <devn> bitemyapp: i've avoided saying anything for awhile, but you should be ashamed of the way you're treating people on twitter.
16:08:22 <michaelt> stephenmac7: if it can be a Monad it can be
16:09:13 <devn> i obviously don't speak for the haskell community, but as someone who likes clojure, haskell, ocaml, ml, typed racket, whatever -- it is disappointing to see you putting such a terrible face on such a great community
16:09:41 <stephenmac7> michaelt: Thanks
16:09:59 <quchen> All Monads are also Applicatives.
16:10:09 <quchen> Or at least, can be made Applicatives (and should be).
16:11:58 <bitemyapp> devn: there's always PM you know.
16:12:00 <quchen> It's a good exercise to write the Applicative instance yourself.
16:12:26 <devn> bitemyapp: you do this in public all the time, trashing people. it's really not okay.
16:12:40 <devn> and that's all i have to say about it
16:13:17 * bitemyapp squints
16:15:06 <stephenmac7> quchen: Okay, thanks.
16:15:16 <stephenmac7> Though State probably isn't the best one to do that with :)
16:15:27 <bitemyapp> stephenmac7: but not all applicatives are monads though.
16:15:38 <bitemyapp> stephenmac7: and you can have more than one valid applicative or monad for the same type.
16:16:02 <stephenmac7> Yes, that's why we have newtype
16:16:35 <quchen> I haven't seen a type with multiple Monads yet actually.
16:16:39 <quchen> Or didn't realize it anyway.
16:17:15 <stephenmac7> quchen: I've only ever seen a type with multiple Monoids
16:17:18 <chreekat> State's a newtype'd function. Specialized, I suppose, but still
16:17:20 <stephenmac7> Which are completely different
16:17:29 <stephenmac7> chreekat: That's try
16:17:31 <stephenmac7> *True
16:18:38 <bitemyapp> quchen: http://ezyang.tumblr.com/post/77440676415/when-are-two-monads-isomorphic - " But since there may be multiple valid monads for a single functor"
16:18:51 <bitemyapp> quchen: am I reading that correctly? It seemed true just based on the nature of it to me anyway.
16:21:07 <jfischoff> that doesn’t mean that a type has multiple valid monad instances
16:21:47 <quchen> jfischoff: So Monads are unique?
16:22:14 <levi> I'm pretty sure I've had this question before, too. I can't remember finding a definitive answer.
16:22:14 <jfischoff> I don’t know, I doubt it.
16:22:15 <quchen> It's what I always assumed (without further thought)
16:22:41 <jfischoff> oh I mean I think they are unique per type
16:22:49 <mwhit> I can definitely write an OtherEither that just switches how Left and Right are treated
16:22:58 <quchen> mwhit: Nope
16:23:01 <mwhit> no?
16:23:15 <quchen> Try writing a Functor for "Either" that "fmaps over Left" :-)
16:23:29 <jfischoff> mwhit: you made a different type
16:24:01 <quchen> Oh, you meant "OtherEither" as a new type you define yourself. Well that's just going to be the same as Either with different names.
16:24:01 <mwhit> oh i see what you mean quchen
16:24:02 <mwhit> hmm
16:24:41 <stephenmac7> Does lambdabot have a function for checking the type of something?
16:24:47 <quchen> :t id
16:24:48 <lambdabot> a -> a
16:24:49 <michaelt> @type mempty
16:24:49 <Jefffrey> Hello
16:24:49 <Jefffrey> Can someone explain why this compiles, but the code in comment doesn't? http://coliru.stacked-crooked.com/a/0305f546c8566683
16:24:49 <lambdabot> Monoid a => a
16:24:51 <stephenmac7> Lovely.
16:24:54 <stephenmac7> :t state
16:24:55 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
16:25:19 <stephenmac7> Why does the s-> (a,s) have parenthesis?
16:25:21 <kini> Jefffrey:  lines 24 through 26 should be indented further right
16:25:26 <dfeuer> I'm trying to figure out what the deal is with http://stackoverflow.com/questions/24690406/haskell-list-comprehension-speed-inconsistencies#24690406  but -ddump-simpl produces a huge amount of core, and using diff doesn't seem to help (even with suppress-all and suppress-unique). Any ideas?
16:25:36 <mwhit> stephenmac: because it takes a function with that type signature, not two arguments of those types
16:25:55 <stephenmac7> Oh, that makes sense.
16:26:12 <kini> or to put it another way, "->" is right-associative
16:26:56 <Jefffrey> kini: In 10-11-12 it's not, but it still works
16:27:17 <stephenmac7> kini: Yeah. It's just a little confusing to have a function that doesn't look like a function...
16:27:32 <kini> Jefffrey: err... hmm. Good point, lol
16:28:05 <quchen> Jefffrey: "if True" in line 6 seems odd regardless :-þ
16:28:33 <Jefffrey> quchen: It's just an example. I'm trying to reproduce the problem, but apparently I'm not able to.
16:29:34 <michaelt> Is it wrong that lines 24 - 6 should be indented more?
16:29:47 <kini> probably, just ignore me :)
16:30:05 <levi> It seems like if there's a way to write multiple monad instances per functor, the differences will have to lie in how the 'join' of the monads work.
16:30:08 <quchen> They should. I'm still surprised the code parses.
16:30:16 <quchen> levi: Functors are unique.
16:30:30 <quchen> Eh.
16:30:31 <levi> quchen: I'm aware of that.
16:30:31 <quchen> Ignore me.
16:30:40 * quchen goes sit in a corner
16:30:41 <timemage> chreekat, any idea what Const / getConst are, or are for?
16:30:43 <michaelt> on line 24 'let' is at the same indentation level as fn, so it looks like you're defining 'let x' , though that 's presumably not the error message
16:32:09 <levi> So if a functor admits multiple ways to write f (f a) -> f a, then you can write a monad instance for each, assuming you can make the monad laws hold, etc.
16:32:50 <michaelt> man is that confusing, Jefffrey
16:33:25 <levi> quchen: I am guilty of misreading things all the time too, especially in irc. No harm done!
16:34:06 <michaelt> levi: isn't a typical case data Double a = Double a a ; join (Double (Double x y) (Double s t)) = ...
16:34:28 <Jefffrey> michaelt: Why should it be indented more?
16:35:46 <Jefffrey> "so it looks like you're defining 'let x'" -- wat
16:35:50 <michaelt> Jefffrey: it seems obvious, intuitively, but that the earlier lines pass is kind of baffling me.  after let fn x = 3 you could have a line: gn y = 17  where gn is lined up with fn
16:36:34 <quchen> Jefffrey: I can't reproduce your error. http://lpaste.net/107679 parses for some reason, it's your code littered with undefineds.
16:36:35 <michaelt> Jefffrey: I was just describing the way it looked to me, after one let you can define several expressions, lining them up with each other
16:36:51 <benzrf> levi: naturally
16:37:11 <benzrf> levi: wait
16:37:17 <benzrf> levi: no, return can differ to
16:37:18 <benzrf> *too
16:37:33 <Jefffrey> michaelt: It's a "let ... = do". (see the "do" at the end)
16:38:08 <quchen> benzrf: Can it?
16:38:30 <quchen> We need an example MultiMonad.
16:38:45 <benzrf> quchen: i know that Applicative pure can vary
16:38:54 <benzrf> i suppose i dont know for sure that if it's a monad it can have diff pure
16:39:02 <quchen> benzrf: True, but none of the alternative Applicatives I know are Monads.
16:39:05 <Jefffrey> By the way, if you want to test the real code, just head here: https://github.com/Jefffrey/Kopia/tree/robot-help and `cabal build` should reproduce the error
16:39:07 <benzrf> hmmm
16:39:09 <dfeuer> How do you dump the unsimplified core?
16:39:28 <quchen> dfeuer: Don't compile with -O?
16:39:36 <dfeuer> Ah.
16:39:37 <quchen> Or what do you mean with unsimplified?
16:40:23 <levi> dfeuer: I think the simplification of '-ddump-simpl' is the Haskell -> Core simplification.
16:41:29 <quchen> There's also "-ddump-simpl-phases" which dumps core on every simplification phase
16:41:52 <quchen> And if you're feeling like reading a lot there's also -ddump-simpl-iterations, which dumps after each iteration
16:42:16 <levi> quchen: Those are all Core->Core simplifications, right?
16:42:53 <quchen> Simplification is done exclusively in Core as far as I know.
16:43:37 <erisco> is HaskellDB up to snuff or is there something newer?
16:43:38 <levi> Well, unless you consider the initial de-sugaring to Core to be a simplification.
16:44:27 <dfeuer> I was looking at  http://stackoverflow.com/questions/24690406/haskell-list-comprehension-speed-inconsistencies#24690406 and ended up filing  https://ghc.haskell.org/trac/ghc/ticket/9326 (still with no clue what the problem is).
16:44:50 <quchen> levi: That's a bit far-fetched. It's not a simplification, it's a transoformation.
16:44:54 <chreekat> timemage: Off the top of my head, I have no use for it. I can see from the docs that it has a phantom type (paradigm #1), and it provides a functor instance (paradigm #2) that ignores whatever function you attempt to map over it (paradigm #2.5)
16:45:02 <quchen> Parsing is also not a simplification of source to AST.
16:45:08 <chreekat> timemage: In other words, I also don't know what it does
16:45:30 <dfeuer> I was wondering about the initial desugaring/de-typeclassing phase.
16:45:47 <dfeuer> But I guess probably -O0 gives a peek at that.
16:45:52 <michaelt> Jefffrey: it seems to be building, but maybe i didn't get the branch right
16:46:11 <Jefffrey> robot-help should be the branch
16:46:53 <chreekat> timemage: I think a good starting point for understanding why someone might want it is to see what MaybeT does
16:47:00 <quchen> dfeuer: I'm not sure -O0 is "don't optimize", maybe double-check that
16:47:12 <johnw> chreekat: what type are you guys talking about?
16:47:21 <quchen> It may be "do only the most basic optimizations". I've had that case somewhere, I don't remember whether it was GHC.
16:47:23 <chreekat> johnw: timemage asked about the Const newtype
16:48:29 <johnw> it's a functor that maps every object in the source category, to a single object in the destination category
16:48:41 <johnw> and it maps every morphism from the source to the identity morphism in the target
16:48:57 <johnw> (for the target object)
16:49:04 * timemage facepalms
16:49:35 <johnw> in Haskell terms, it lets you pass around a value masquerading as a functor over a different type
16:49:41 <johnw> lens uses it to great effect
16:50:46 <Jefffrey> michaelt: try `cabal test`, please
16:51:12 <chreekat> johnw: doh, ya did timemage in
16:51:13 <johnw> > getConst $ fmap (+1) $ (Const 10 :: Const Int Float)
16:51:15 <lambdabot>  10
16:51:32 <johnw> my Const 10 can behave like a Functor f => f Float
16:52:01 <popx> johnw: how does lens use it?
16:52:14 <chreekat> I've been enlightened though
16:52:16 <johnw> are you familiar with the functor representation of lenses?  (a -> f b) -> (s -> f t)?
16:52:51 <benzrf> johnw: van laarhoven lens
16:52:54 <johnw> right
16:53:00 <johnw> by choosing f to be Identity or Const, we get getters and setters, respectively
16:53:20 <michaelt> Jefffrey: Ok, I have the error
16:54:14 <johnw> (actually, the reverse of that; Const is for getters, Identity for setters)
16:54:27 <johnw> see http://www.twanvl.nl/blog/haskell/cps-functional-references for more info
16:54:48 <Jefffrey> michaelt: This is getting weirder and weirder.
16:54:54 <Jefffrey> Thanks by the way.
16:55:55 <michaelt> Jefffrey: But it goes away with the further indentation, as people said. There is some odd mixture of layout rules for 'let' and 'do'
16:56:18 <Jefffrey> I'm still convinced there shouldn't be extra indentation
16:56:28 <Hodapp> hmm, finally reading about HM is making certain terminology and notation make a lot more sense
16:56:50 <Jefffrey> it's: `let a b = do { ... }`
16:58:15 <michaelt> Jefffrey: yes, but the 'a' in the line you just wrote is what determines the layout, no? The current 'left margin' so to speak.
16:59:57 <levi> quchen: Simplification *is* a transformation. I guess you could argue that Core is a different language than Haskell rather than a simplified subset, but it's very close to being a simplified subset anyway.
17:00:10 <Jefffrey> michaelt: yes, and at the same line, below, `let t = readUTC p` starts
17:00:22 <levi> Gotta go anyway. Later.
17:01:08 <michaelt> Jefffrey: yes, but if you were defining fn at the top level, you wouldn't want the lines after do to be at the left margin?
17:01:46 <dfeuer> It looks like -ddump-ds dumps the desugarer output.
17:02:46 <Jefffrey> michaelt: I see what you mean
17:03:17 <Jefffrey> I've always thought `let` defines the left margin in a `let` declaration
17:03:46 <isomorpheous> @help let
17:03:46 <lambdabot> let <x> = <e>. Add a binding
17:06:07 <michaelt> Jefffrey: by the way, you can line up if / then / else in a do block now, if you like
17:09:59 <Jefffrey> michaelt: yeah, you mean with -XDoIfThenElse (or something along those lines)?
17:10:17 <michaelt> Jefffrey: ghc accepts it as a matter of course for some reason now.
17:10:32 <michaelt> Jefffrey: or anyway, it's working for me...
17:10:42 <Jefffrey> What GHC version are you running on?
17:10:51 <Jefffrey> I'm 6.3
17:11:48 <michaelt> Oh, can you be using one that old? I'm using  7.8
17:14:43 <Jefffrey> I know, I should upgrade. I'm super lazy :P
17:15:06 <ruuns> eval on demand :P
17:19:16 * hackagebot haddock 2.14.3 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.14.3 (MateuszKowalczyk)
17:25:35 <intrados`> Is there any general way to do `h ∷ (Monad m1, Monad m2) ⇒ (b → m1 (m2 c)) → (a → m1 (m2 b)) → a → m1 (m2 c)`?
17:27:28 <erisco> intrados`, are you asking if there is an implementation for that function?
17:28:15 <dwcook> Hmm, at a glance, wouldn't that require commutativity of m1 and m2?
17:28:25 <intrados`> erisco: Yeah. An implementation for a sort of double Kliesli composition
17:28:27 <dwcook> Wait, no
17:29:00 <johnw> intrados`: you need an additional law to be able to do that
17:29:01 <dwcook> I think you can do that with a couple of joins and liftM. Lemme try
17:29:03 <dwcook> Oh
17:29:05 <dwcook> Never mind
17:29:15 <johnw> mind you, most Haskell monads fulfill this law
17:29:26 <dwcook> johnw: What law?
17:29:43 <johnw> it's the "compatible monads" law
17:29:56 <johnw> join . fmap f = f . join
17:30:08 <johnw> with it, you can prove that m1 `o` m2 is also a monad
17:30:32 <johnw> see this excellent paper: http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.pdf
17:30:46 <arancia> How would you get b out of m2?
17:30:53 <erisco> hm, yeah by the time you get the 'b' out you are buried in m2
17:31:07 * dwcook reads "Gofer script", doubles back to look at the date
17:31:07 <johnw> you should end up with m1 (m2 (m1 (m2 b)))
17:31:11 <erisco> and you cannot join it with m1 obviously, so that is a problem
17:31:23 <johnw> which the new law will let you turn into m1 (m1 (m2 (m2 b)))
17:31:33 <dwcook> Ah, I think I did do that correctly in my head then, I just assumed commutativity would be the way to go about that
17:31:33 <johnw> and that is easily reduced by fmap join . join
17:32:07 <johnw> you could make a new typeclass, MonadTranspose
17:32:22 <intrados`> Ah, that makes sense. Thanks
17:32:30 <johnw> with a single function: transpose :: m2 (m1 a) -> m1 (m2 a)
17:32:37 <johnw> and with that constraint satisified, your function becomes possible
17:32:54 <johnw> this is just a special case of Distributive, though
17:36:57 <carlosgaldino> sectioning and negative numbers, what's the best resource explaining their relationship?
17:37:40 <gamegoblin> So I have a type that is basically ` data T = X a | Y a `. Can I define a function like ` f (_ a) = g a ` rather than two pattern matches for each constructor?
17:37:51 <gamegoblin> or is there an extension that will let me do that?
17:37:59 <dwcook> carlosgaldino: This one particular section in the report I guess? It's easy just to explain. Negation is special-cased and takes the place of the right section of -, so instead you can just use subtract when you would've wanted that.
17:39:02 <johnw> dwcook: h f g = liftM join . join . liftM (distribute . liftM f) . g
17:39:07 <erisco> gamegoblin, yes, sort of
17:39:10 <johnw> with constraints (Distributive m1, Monad m1, Functor m2, Monad m2)
17:39:19 <gamegoblin> erisco: elaborate?
17:39:27 <CaptainK> its not so much to know is there?
17:39:30 <erisco> gamegoblin, data T = X { myField :: a } | Y { myField:: a }
17:40:04 <erisco> gamegoblin, not exactly what you are asking but myField is :: T -> a
17:40:14 <dwcook> johnw: I'm not the original asker.
17:40:17 <gamegoblin> erisco: Yeah, I figured that was my only option
17:40:22 <dwcook> I was just also curious. :)
17:40:26 <erisco> gamegoblin, you can of course write this function yourself too
17:40:27 <CaptainK> lyah explains it...
17:40:27 <CaptainK> ...bottom of page 62
17:40:37 <johnw> dwcook: then, original asker ^^
17:40:44 <carlosgaldino> dwcook: just looked at the report, thanks. btw, is it still relevant or should I take it with a grain of salt?
17:40:49 <dwcook> It was intrados`
17:40:51 <johnw> ah, intrados`
17:41:01 <carlosgaldino> by relevant, I mean, is it up to date?
17:41:08 <dwcook> carlosgaldino: The Haskell 2010 Report is current, although it doesn't cover GHC Haskell, which is documented separately.
17:41:26 <dwcook> carlosgaldino: I mention GHC Haskell because it has many extensions widely considered useful.
17:41:46 <carlosgaldino> dwcook: where would I find this docs for GHC?
17:41:58 <dwcook> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
17:42:22 <dwcook> You can also follow the Home link at the bottom to access the rest of the GHC docs
17:46:01 <dwcook> carlosgaldino: If you're using GHC and don't activate any extensions in your module/program, you're effectively using Haskell 2010.
17:46:30 <carlosgaldino> dwcook: ah ok. thanks
17:54:16 <isomorpheous> Anyone here a json ninja?
17:54:38 <isomorpheous> I need to make a schema for this json thing - http://lpaste.net/107681
17:55:20 <benzrf> 'ninja'
17:55:40 <Algebr> how about json boors?
18:11:37 <Welkin2> > :t maybe
18:11:38 <lambdabot>  <hint>:1:1: parse error on input ‘:’
18:11:42 <kazagistar> "I need an object, dumbass." excellent choice of error message <_<
18:11:46 <Welkin2> :t maybe
18:11:47 <lambdabot> b -> (a -> b) -> Maybe a -> b
18:12:28 <Welkin2> check the source, I bet the comments are filled with such intelligent insults
18:14:40 <johnw> if I were a true json ninja, you'd never know it
18:17:00 <kazagistar> that source does not provide enough information to write a full schema anyways I think, and it is easier to write a schema given examples. what do you have so far, isomorpheous?
18:21:48 <roconnor> Yoneda++ Thank you for turning my thing that isn't a functor into a functor.
18:22:01 <benzrf> yoneda lemma? i got one right here
18:22:12 <benzrf> ( ͡° ͜ʖ ͡°)
18:22:27 <roconnor> *gong*
18:23:02 <benzrf> actually 'i have a few extras' might work better
18:23:53 <Welkin2> benzrf: you sure have a strange face
18:24:18 <Welkin2> is that an arabic character?
18:24:34 <benzrf> Welkin2: try pasting it out of the terminal
18:24:37 <benzrf> it may look more appropriate
18:24:44 <benzrf> err, whatever youre viewing it in
18:26:21 <acowley> Are all the failures at building docs on hackage a tracked issue somewhere?
18:38:00 * dfeuer wonders why Rylee has username rylai.
18:38:26 <Rylee> it used to be my internet pseudonym
18:38:27 <Rylee> but now i just use my real name
18:39:03 <dfeuer> You're no longer an AI?
18:39:09 <Rylee> lol
18:39:19 <isomorpheous> so, question
18:39:27 <isomorpheous> I'm a fan of YAML
18:39:32 <dfeuer> isomorpheous, that's not a question.
18:39:40 <isomorpheous> dfeuer: yes it is
18:39:47 <acowley> ?hackage yaml-light-lens
18:39:47 <lambdabot> http://hackage.haskell.org/package/yaml-light-lens
18:40:15 <isomorpheous> I've been using JSON in my apps, because Aeson seems to benchmark well. Is there any reason for me to switch over to YAML
18:40:38 <isomorpheous> Oh, it's snoyman who makes yaml
18:40:39 <Rylee> the primary reason would be that YAML is more easily human-editable than JSON
18:40:56 <isomorpheous> I don't like Snoyman very much, but he makes really nice libraries
18:42:00 <acowley> isomorpheous: I linked you a non-Snoyman library, but, admittedly, I don't know how you feel about me :/
18:42:25 <acowley> I also don't think liking the author should be a requirement
18:42:30 <isomorpheous> acowley: didn't see your link
18:42:39 <isomorpheous> acowley: Oh, I have nothing personally against snoyman
18:42:51 <isomorpheous> acowley: I just don't like him
18:42:52 <acowley> An annoyance is that the docs on hackage are broken
18:43:06 <acowley> I'll rebuild my sandbox with docs tonight and upload tomorrow
18:43:15 <isomorpheous> acowley: that seems to be a recurring problem
18:43:19 <acowley> isomorpheous: That's a complex personal stance
18:43:26 <isomorpheous> acowley: I can't get the documentation to work on any of my projects
18:43:45 <acowley> isomorpheous: Yes, hackage's value has sunk to basically an FTP with .tar.gz files.
18:46:24 <isomorpheous> acowley: exactly
18:49:23 * hackagebot goatee 0.1.1 - A monadic take on a 2,500-year-old board game - library.  http://hackage.haskell.org/package/goatee-0.1.1 (khumba)
18:55:35 <zq> acowley: how do you think could it be improved?
18:56:12 <acowley> zq: Glib answer: by building haddocks
18:56:28 <acowley> zq: Something seems to have gone wrong with regard to haddock building
18:56:42 <acowley> zq: Perhaps just surfacing build reports will let people help figure out what's going wrong
18:57:32 <acowley> zq: Perhaps it's an issue of what versions of GHC are used to attempt to build, in which case we'll want build reports for multiple GHCs, but the haddocks of any build environment that succeeds in building the docs.
18:57:55 <dfeuer> Why does http://hackage.haskell.org/package/AC-Boolean-1.0.0/docs/Data-Boolean.html limit itself to Boolean logic? Aside from the `xor` method, doesn't everything there make sense in intuitionistic logic as well?
18:58:46 <dfeuer> [Well, maybe even xor makes some sort of sense, but it's hard to imagine using it in an intuitionistic context.]
18:59:01 <acowley> zq: The docs are a big issue as that is probably the most important way to get people using the many wonderful libraries we have! If hackage can't be relied on for doc building, then "documentation: True" needs to be a default flag for cabal.config, and "cabal upload" needs to upload the locally-built docs.
19:00:06 <Algebr> +1 on documentation True, why is it False??
19:00:52 <dfeuer> Probably because it's not free, and isn't necessary for most of the development cycle?
19:00:55 <acowley> Algebr: Having it False meant that the performance of haddock was less critical as not everyone built docs every time
19:01:27 <acowley> Algebr: Which was okay since you could rely on on hackage for docs as long as you could rely on a net connection
19:07:01 <GeraldCode> Hello..anyone else find it impossible to compile a yesod mongo app from scaffold, but the other DB types work fine?
19:07:18 <GeraldCode> Tried #yesod..
19:10:41 <kazagistar> dfeuer: does Data.Boolean impose such a limitation somehow? If you wanted to build an intuitionistic logic datatype somehow, I am pretty sure you could implement Boolean, right? or are you just bothered by the name?
19:11:48 <dfeuer> kazagistar, I think you're right.
19:12:03 <GeraldCode> Intutionistic ? I don't even know what that means... is that the same as intutitve? kazagistar
19:12:29 <dfeuer> No, GeraldCode, it's not, unless you're a peculiar sort of philosopher.
19:12:36 <GeraldCode> I see
19:12:45 <isomorpheous> ظضهمب
19:12:55 <isomorpheous> god dammit, switched to arabic
19:13:15 <dfeuer> Intuitionistic logic rejects the law of the excluded middle. That is, it does not include the rule forall a . a || not a
19:13:44 <GeraldCode> Damn..I knew I should have finished that ebook that taught logic using haskell
19:13:52 <dfeuer> It also does not include equivalents like  forall a . not (not a) == a
19:13:52 <GeraldCode> srsly
19:13:54 <GeraldCode> I have one.
19:14:06 <GeraldCode> ok thanks, interesting
19:14:11 <acowley> It is characterized by demanding positive evidence of a proposition rather than an absence of negative evidence
19:14:13 <dfeuer> GeraldCode, I want that. Can you mail it to me? Please?
19:14:22 <GeraldCode> defuer, I can find the link I think
19:14:37 <acowley> Which is useful for programming since when someone asks you for a value of type "a" you can't very well respond with an absence of not having such a value
19:14:38 <GeraldCode> acowley, ohh, ok now I get it
19:14:49 <dfeuer> a -> b  no longer implies   not a || b.
19:14:52 <GeraldCode> let me find that book
19:14:59 <acowley> dfeuer: There's the Haskell Road to Logic
19:15:27 <acowley> dfeuer: I've not read it though, but I don't think I've ever heard anything bad about it
19:15:44 <dfeuer> I will take a look.
19:17:07 <GeraldCode> yes, thats the one : http://fldit-www.cs.uni-dortmund.de/~peter/PS07/HR.pdf
19:17:11 <GeraldCode> haskell road to logic
19:17:31 <GeraldCode> Might be basic for a veteran haskell programmer I guess
19:17:50 <dfeuer> You can look at intuitionism also as a logic of certainty:  "I am not certain that I am not certain that apes are intelligent" does not imply "I am certain that apes are intelligent".
19:18:07 <GeraldCode> yes that makes sense
19:18:19 <GeraldCode> a double negative doesnt imply a positive
19:18:22 <GeraldCode> as it does in math
19:18:24 <GeraldCode> essentially
19:18:26 <GeraldCode> ?
19:18:38 <dfeuer> Well, a double negative implies a positive in classical logic.
19:18:59 <GeraldCode> ah yes, I mis-applied that
19:19:19 <dfeuer> Most math is done with classical logic.
19:19:27 <dfeuer> Some of it is not.
19:19:31 <GeraldCode> ah
19:19:59 <dfeuer> The part that is not generally falls into the vast realm of "mathematics I haven't a clue about".
19:20:21 <GeraldCode> yeah...you could spend your whole life studying math and not have much clue
19:20:46 <dfeuer> But apparently intuitionistic logic shows up in some natural way in category theory.
19:20:57 <GeraldCode> cool
19:21:30 <acowley> You don't have to reach that far.
19:22:04 <acowley> Just thinking about falsity in programming runs you into the wall of classical logic
19:22:12 * dfeuer reaches for acowley's brain, frees it from their head, and installs it in his own.
19:22:34 <dfeuer> You talking about constructive logic now, with all its Turingness?
19:23:18 <acowley> I'm just appealing the intractability of working with (not (not a)) == a
19:24:19 <acowley> Fortunately, there are many good sources to read on the topic
19:24:40 <acowley> e.g. http://www.cis.upenn.edu/~bcpierce/sf/current/index.html
19:27:20 <glguy> carter: HaLVM doesn't do DMA as far as I know. It doesn't do drivers, It talks to the world over ring buffers. Drivers are the realm of the "dom0"
19:27:33 <carter> glguy: i'm not the one who cares :)
19:27:35 <carter> but good to know1
19:27:38 <carter> acowley: HELLO :)
19:27:44 <acowley> Hey carter!
19:28:08 <glguy> carter: OK, you were just in the conversation in the backlog of this computer :)
19:28:22 <GeraldCode> So...I am having cabal problems..like many people do, evidently..
19:28:23 <carter> glguy: tis j fischoff who's yak huntin
19:28:37 <GeraldCode> is there no way to make this easy? or am I back to 2000 dealing with compiling linux code
19:28:37 <carter> GeraldCode: i bet if you do rm ~/.ghc ; cabal gupdate
19:28:39 <carter> you'll be better
19:28:42 <carter> *update
19:28:43 <GeraldCode> oh??
19:28:47 <carter> well
19:28:48 <carter> idk
19:28:51 <carter> depends on the error message
19:28:55 <acowley> GeraldCode: I are you using sandboxes?
19:28:56 <carter> @lpaste paste it here
19:28:57 <lambdabot> Haskell pastebin: http://lpaste.net/
19:29:15 <acowley> That was a spurious "I"
19:29:22 <GeraldCode> acowly, yes, I am following a tutorial on the yesod website...which uses sandboxes
19:29:22 <acowley> afaik, I are not you
19:29:30 <GeraldCode> it refuses to compile mongo correctlyh
19:29:34 <acowley> ah
19:29:35 <carter> GeraldCode: yesod is the leading cause of cabal hell
19:29:38 <GeraldCode> oh
19:29:40 <carter> :)
19:29:54 <carter> 50+% of the time i hear new folks saying "i have cabal hell"
19:29:56 <carter> tis yesod
19:29:57 <carter> :)
19:30:03 <carter> how did you try to install yesod?
19:30:04 <glguy> Yeah, you aren't having cabal problems, you're experiencing yesod
19:30:06 <GeraldCode> hahahah
19:30:15 <carter> snoymans a very very nice guy
19:30:25 <GeraldCode> carter, it works fine..in terms of installing yesod...its just building the scaffold app..
19:30:32 <carter> no
19:30:33 <GeraldCode> If you select mongo for the DB..the dependencies never resolve
19:30:38 <carter> i mean literally how did you cabal install
19:30:40 <carter> whats the commands you used
19:30:45 <carter> i'm in literal mode
19:30:47 <carter> not feelings mode
19:30:48 <GeraldCode> for yesod, or for my app?
19:31:00 <carter> was i general or specific
19:31:02 <carter> i'm being literal
19:31:05 <carter> what did you do wh
19:31:10 <carter> when you typed things into the ocmputer
19:31:16 <carter> to try to do the cabal install things
19:31:18 <GeraldCode> lol
19:31:29 <glguy> You should keep typing to see if you can finish the bookbefore he responds :)
19:31:32 <acowley> carter is spear fishing for passwords in an intriguing way
19:31:41 * carter rofls
19:31:52 <GeraldCode> anyway...it works with any other DB
19:31:54 <GeraldCode> just not mongo
19:31:59 <carter> what does?
19:32:09 <GeraldCode> Installing a scaffold yesod site.
19:32:16 <acowley> GeraldCode: We really do need to see the error at some point
19:32:44 <GeraldCode> I dont get an error.  It just says "resolving dependencies" and it will stay all night..forever...backtracking is set to -1 of course
19:32:53 <carter> GeraldCode: how did you install yesod
19:32:59 <carter> first cabal install yesod-platform
19:33:01 <carter> then add other stuff
19:33:12 <GeraldCode> I just did what they told me on the website..quick start
19:33:17 <GeraldCode> works with sqlite, mysql, etc
19:33:26 <carter> GeraldCode: then email snoyman
19:33:29 <carter> or ask on #yesod
19:33:33 <carter> or his mailing list
19:33:40 <carter> because we don't know what you're referring to
19:33:41 <GeraldCode> ok..
19:33:52 <GeraldCode> I figured I wouldnt have luck here..but I tried in #yesod
19:34:00 <acowley> Yeah, unfortunately you probably do need to contact the yesod devs
19:34:16 <GeraldCode> ok, will do, thanks guys
19:34:18 <carter> np
19:34:23 <GeraldCode> I will let you resume your ivory tower discussion :)
19:34:24 <acowley> Sorry we couldn't help
19:34:27 <GeraldCode> Which I enjoy, btw
19:34:40 <tertl3-laptop> i tried yesod once
19:34:59 <carter> i ran screaming from the build hell / 5 hour build
19:35:07 <carter> well, not 5 hours on a modern cabal install / machine
19:35:08 <carter> but still
19:35:10 <carter> long ass builds
19:35:24 <tertl3-laptop> it wokred for while until i broke it somehow
19:35:25 <dfeuer> GHC is not exactly a quick build itself.
19:35:42 <tertl3-laptop> iw as gonna make a blog or something
19:36:00 <GeraldCode> tertl3, have you evaluated other haskell web frameworks?
19:36:01 <carter> dfeuer: actually i think i can build ghc faster than i can build git-annex with the webapp flags enabled
19:36:08 <GeraldCode> I am trying to figure out whcih one is worth my time
19:36:09 <carter> GeraldCode: snap and happstack and scotty and mflow and others
19:36:11 <Abathurr> philosophy is hard for me to understand not because of the content but because there are so many confusing words
19:36:12 <carter> they're all good
19:36:22 <GeraldCode> carter, ok cool..which ones will survive, if you had to guess
19:36:26 <GeraldCode> for more than 5 years
19:36:26 <carter> all of them
19:36:27 <tertl3-laptop> i heard snap was nice and small
19:36:33 <GeraldCode> ok cool
19:36:35 <GeraldCode> thanks :)
19:36:40 <carter> snap and happstack have long histories
19:36:52 <carter> and teams of >=3 core devs
19:37:08 <tertl3-laptop> did you look at fpcomplete?
19:37:08 <GeraldCode> tertl3-laptop,  I heard snap was relatively lightweight and simple in comparison
19:37:13 <GeraldCode> I might go that route
19:37:19 <carter> tertl3-laptop: fpco aint a webstack
19:37:32 <carter> and they're moving away from the web editor stuff i'm told
19:37:33 <GeraldCode> tertl3-laptop, , yes I have an accoujnt, thanks to someone here suggesting :)..But the base web server is $100/month
19:37:38 <tertl3-laptop> i know but there is stuff on there
19:37:45 <GeraldCode> I am not good enought o make production code yet...but when I am I dont want to pay that
19:37:49 <carter> GeraldCode: i respects the snap devs
19:37:53 <tertl3-laptop> ahh gotcha
19:37:54 <carter> and they use snap in production
19:38:18 <GeraldCode> oh nice...carter, ok
19:38:24 <GeraldCode> I think I will detour into snap
19:38:33 <GeraldCode> maybe come back to yesod later :)
19:38:34 <carter> (i respect all the devs of the variou stacks)
19:38:37 <tertl3-laptop> take the scenic route
19:38:41 <GeraldCode> ayer
19:38:43 <carter> but nibble on them all
19:38:48 <carter> they're libraries more than frameworks
19:38:57 <carter> you can mix and match if you REALLY wanted to
19:39:10 <GeraldCode> ah
19:39:16 <GeraldCode> i read a bit abot that
19:39:17 <carter> they've different flavors
19:39:20 <carter> and styles
19:39:22 <GeraldCode> haskell seems good that way
19:39:25 <carter> yeah
19:39:32 <carter> its a bit novel the first time you see it
19:39:38 <carter> but .... being able to combine ANY libs
19:39:48 <carter> and have it clear what the duct tape needs to be
19:39:49 <carter> is quite niceee
19:39:51 <tertl3-laptop> just use node -- waits tob e kicked
19:39:54 <GeraldCode> :)
19:40:08 <tertl3-laptop> kidding ofc
19:40:26 * tertl3-laptop sees himself out
19:40:45 <carter> didnt you hear, node can run haskell code now :)
19:40:54 <carter> they have this new plugin called ghcjs
19:41:02 <carter> that lets you run haskell on node.js
19:41:05 <tertl3-laptop> no kidding
19:41:07 <carter> and in various web browsers
19:41:08 <GeraldCode> I considerd node :)
19:41:09 <carter> @google ghcjs
19:41:09 <lambdabot> https://github.com/ghcjs/ghcjs
19:41:12 <dfeuer> Abathurr, I believe that to a significant extent philosophers make things confusing because their arguments don't hold together when stated simply, and therefore they must find ways to confuse matters first.
19:41:16 <GeraldCode> I was looking for a functional language
19:41:17 <carter> still pre release
19:41:20 <carter> but pretty fancy
19:41:24 <GeraldCode> But node seemed too immature
19:41:39 <acowley> carter: How do you deal with GHC's build complexity? It drives me bonkers.
19:41:45 <carter> acowley: what complexity?
19:41:51 <acowley> carter: Well, time mostly.
19:41:54 <carter> oh
19:41:59 <carter> i cry
19:42:03 <carter> and do it overnight
19:42:04 <tertl3-laptop> me too acowley  me too
19:42:15 <acowley> And then all the non-github stuff makes me wary, too actually
19:42:18 <carter> GeraldCode: if my compiler isn't old enough to drink, the compiler is too young
19:42:20 <carter> acowley: ohhhh
19:42:28 <carter> the new arc patch work flow is NICE
19:42:35 <GeraldCode> hah
19:42:40 <acowley> It's infinitely easier to write a pre-processor than actually work on GHC
19:42:49 <carter> acowley: its better now
19:43:04 <carter> you can submit a patch to phabricator and it autoruns validate!
19:43:25 <carter> and makes it easy to have public code review
19:43:35 <acowley> Do I need to create an account somewhere?
19:43:36 <carter> https://phabricator.haskell.org/differential/query/joDm45Rcgb1t/
19:43:40 <carter> sure
19:43:55 <carter> its easy though
19:44:07 <acowley> Anyway, the thing I want to add is the (:: T) sugar for (Proxy::Proxy T)
19:44:20 <carter> hrmm
19:44:21 <acowley> But I'd need to guard everything behind a language pragma
19:44:28 <acowley> and then touch the parser and the desugar stage
19:44:33 <carter> Language SweetProxy
19:44:35 <acowley> and create a phab account
19:44:36 <acowley> yes
19:44:38 <acowley> exactly
19:44:39 <dfeuer> So carter, how's the matrix benchmarking going?
19:44:47 <carter> dfeuer: which matrices?
19:44:48 <acowley> But there are too many steps between me and that goal
19:45:00 <dfeuer> The ones you said you were working on. Or is that not yet?
19:45:03 <enthropy> and you have to touch the typechecker too :p
19:45:17 <carter> enthropy: i don't think he needs to touch the type checker
19:45:42 <acowley> enthropy: No!
19:45:46 <acowley> enthropy: at least I'd hope not
19:45:50 <carter> i don't think so
19:46:28 <carter> acowley: would that language flag imply rebindable syntax?
19:46:37 <carter> i think it'd have to
19:46:38 <acowley> It wouldn't have to
19:46:40 <acowley> why?
19:46:42 <enthropy> acowley: I think it might make more sense if it was just a section with ::
19:46:48 <carter> which Proxy constructor is in scope
19:47:01 <carter> unless Proxy was in base
19:47:04 <acowley> It is
19:47:09 <carter> i mean prelude
19:47:36 <carter> 'cause I don't think any language flag implicitly imports anything
19:47:47 <enthropy> I mean it would be less convenient, but I think it's easier to see (:: T) as being (\x -> x :: T)
19:47:47 <carter> except NoImplicitPrelude
19:47:59 <acowley> carter: I wish ConstraintKinds imported GHC.Prim (Constraint)
19:48:08 <acowley> seems like a bug that it doesn't
19:48:11 <dfeuer> What are you folks talking about?
19:48:22 <acowley> enthropy: Would that work with DataKinds?
19:48:22 <carter> enthropy: i dont' think that works
19:48:32 <carter> one of the problems with that proposal
19:48:50 <carter> is that the Proxy# stuff actually gets special treatment by ghc to be 0-arity arg
19:48:58 <carter> so that once you erase types, its gone
19:48:59 <acowley> Something I'm writing a lot at the moment is e.g. (:: [1,2,1]) which I can do a lot of work with at compile time
19:49:49 <dfeuer> Is this Proxy you're talking about related to the one in pipes, or is that a different Proxy?
19:49:57 <carter> dfeuer: the one in base
19:50:06 <dmwit> data Proxy a = Proxy
19:50:15 <dmwit> + kind polymorphism
19:50:23 <carter> dmwit: its now special in ghc
19:50:40 <carter> the builtin one has better erasure properties
19:50:46 <dmwit> That's an implementation detail that I don't care about.
19:50:52 <carter> dfeuer: you'll hear aobut my benchmarks when anyone else does
19:51:16 <dmwit> ...at the moment.
19:51:39 <dfeuer> carter, I was hoping to get a sense of the benchmark-making process; I don't care how fast your code runs.
19:51:46 <carter> dfeuer: use criterion
19:51:55 <dfeuer> We discussed this a day or two ago.
19:51:58 <carter> theres a good book on perf engineering
19:51:59 <carter> ohhh
19:52:00 <carter> hangong
19:52:03 <carter> lemme link you the book
19:52:26 <dfeuer> Sparse matrices are above my current pay grade.
19:52:48 <carter> they're above everyones
19:52:56 <carter> apparently even the folks at netflix don't have their own libs for it
19:53:09 <dfeuer> Why would they need their own libs for it/
19:53:10 <dfeuer> ?
19:53:17 <carter> bilion dollar companies which have recommendation systems as core product tooling
19:53:24 <carter> don't have their own inhouse sparse matrix tooling
19:53:30 <carter> thats fucking bonkers to me
19:53:59 <dfeuer> Why would you make your own if you can take one of the shelf?
19:54:09 <carter> dfeuer:because the off the shelf stuff ... aint that good
19:54:14 <carter> hello shelf
19:54:20 <carter> i think i know you from twitter
19:54:44 <dfeuer> That's an odd thing for someone to say while in the process of putting some on the shelf.
19:54:54 <carter> dfeuer: http://www.amazon.com/Guide-Experimental-Algorithmics-Catherine-McGeoch/dp/0521173019
19:55:07 <carter> dfeuer: mine are insanely generic
19:55:19 <carter> (good book)
19:55:54 <dfeuer> That book isn't even insanely expensive.
19:56:03 <carter> its a fun book
19:56:09 <carter> not all the ideas are relevant for you
19:56:17 <carter> but read through the case studies
19:56:19 <dfeuer> What's wrong with generic? Too slow?
19:56:20 <carter> and mess with criterion
19:56:22 <carter> dfeuer: no
19:56:25 <kazagistar> dang, that book looks pretty interesting
19:56:30 <carter> its a good book
19:56:35 <carter> i need to read it more :)
19:56:51 <carter> dfeuer: i'm saying that no one has even tried to design good generic array libs before
19:56:51 <carter> ever
19:56:55 <carter> in the history of humanity
19:56:55 * dfeuer wants to apprentice himself to carter for a few years.
19:57:08 <carter> dfeuer: sorry, can't afford apprentices
19:57:14 <carter> flattered though
19:57:36 <dfeuer> Ah well.
19:57:50 <dfeuer> What do you mean by "generic array libs"?
19:58:16 <carter> things you index by k-arity tuples of ints
19:58:27 <carter> @where ops
19:58:27 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
19:58:36 <johnw> yes?
19:58:38 <dibblego> ?
19:58:51 <carter> is there a nanaima pm spamming anyone else?
19:58:59 <johnw> not me
19:59:00 <dfeuer> Not me.
19:59:01 <carter> (got pm spam)
19:59:05 <dmwit> not me
19:59:10 <carter> ok
19:59:12 <dfeuer> (not yet, anyway)
19:59:13 <dibblego> carter: please pm me the spam message
19:59:40 <carter> k
19:59:42 <carter> done1
19:59:43 --- mode: ChanServ set +o dibblego
19:59:46 --- kick: nanaima was kicked by dibblego (nanaima)
19:59:52 --- mode: dibblego set -o dibblego
20:00:07 <dfeuer> It looks like something stronger may be needed.
20:00:21 <carter> dibblego:?
20:00:23 <carter> i mean dfeuer
20:00:27 <carter> dfeuer: what do you mean
20:00:38 <dfeuer> I was talking to dibblego.
20:01:03 <dibblego> if it happens again, please let me know and then we will work that out — I have it recorded
20:01:44 <carter> spam or abuse pms all merit an ops hail right?
20:01:46 <carter> :)
20:02:00 <johnw> sure
20:02:03 <carter> yay
20:02:21 <carter> back to math
20:02:28 <abc56889_> ~.
20:02:29 <dfeuer> Show math?
20:02:39 <carter> > show "math"
20:02:40 <lambdabot>  "\"math\""
20:02:47 <carter> quotable!
20:03:16 --- mode: ChanServ set +o dibblego
20:03:18 --- mode: dibblego set +b *!*@248.Red-2-138-165.dynamicIP.rima-tde.net
20:03:21 <dfeuer> carter, is that generic array thing a class of implementations of things sort of like Array?
20:03:23 --- kick: nanaima was kicked by dibblego (nanaima)
20:03:26 <carter> yes
20:03:40 <dfeuer> Or is that *too* generic?
20:03:48 <carter> its like N dim arrays
20:03:53 <carter> but where you can make up new memory orders
20:04:03 <carter> its on your head if the new rank n array format is slow or wrong
20:04:05 <dfeuer> For Great Caching.
20:04:08 <carter> YES
20:04:13 <carter> memory locality is king
20:04:20 <carter> or at least, royalty
20:04:25 <dfeuer> :D
20:04:26 --- mode: dibblego set -o dibblego
20:05:54 <dfeuer> carter, how *should* things be arranged for good locality?
20:06:05 <carter> hiearchical sequential scans
20:06:07 <dreams> hai, is if in Haskell strict? if you have i.e. in: insert x (y:ys) = if x > y then y : insert x ys else x : y : ys
20:06:19 <carter> dreams: it can be strict when you ask it to
20:06:37 <carter> default haskell is lazy
20:06:38 <dfeuer> Hierarchical sequential scans?
20:06:40 <carter> yees
20:06:45 <carter> for all the levels of cache
20:06:52 <dreams> carter: well is it in that example?
20:07:17 <dreams> carter: or is it going to return the whole expression to the caller.
20:07:18 <dfeuer> What does that "hierarchical sequential scans" term mean?
20:07:25 <carter> dreams: thats lazy
20:07:37 <dfeuer> Also, if is always strict in its condition. What are you saying?
20:07:51 <carter> dfeuer: the sub computations are lazy
20:08:28 <lfairy> dreams: x > y will be evaluated when you examine its result
20:09:30 <lfairy> the resulting list, I mean
20:11:42 <dfeuer> true x _ = x; false = const;  myIf :: (forall a . a -> a -> a) -> b -> b -> b; myIf c b b = c b b
20:11:45 <dreams> so head (insert 3 [1,2,3]) returns if x > y then y : insert x ys else x : y : ys to the head? so we would have head (if x > y then y : insert x ys else x : y : ys
20:12:50 <dfeuer> er ... I meant    true=const;  false _ x = x
20:14:24 <dreams> and then from head (if x > y then y : insert x ys else x : y : ys) we get: head (y : insert x ys) that is if if x > y
20:17:31 <dreams> lfairy: the resulting list? there is no resulting list before if is evaluated.
20:18:19 <GeraldCode> Question :)  How many of you took what you learned in Haskell and created a framework in your other language to emulate it? Even doing explicit monads?
20:18:29 <GeraldCode> I mean in your other language that you do for ap aycheck
20:18:48 <lfairy> dreams: exactly. since the list itself depends on the comparison, the comparison is performed exactly when the list is used
20:19:20 <GeraldCode> I even did a minor project at work in PHP using explicit monad recently
20:19:29 <GeraldCode> I am trying to to determine how much is too much
20:19:41 <jle`> GeraldCode: maybe your coworkers can tell you that ;)
20:19:50 <GeraldCode> I am the only developer :)
20:19:58 <jle`> ah
20:20:07 <GeraldCode> I am sure if I was in a real software house again, they would think I was nuts
20:20:37 <lfairy> GeraldCode: what was the monad? :D
20:20:45 <GeraldCode> Let me link you, lfairy
20:20:46 <GeraldCode> one sec
20:21:11 <GeraldCode> http://blog.ircmaxell.com/2013/07/taking-monads-to-oop-php.html
20:21:15 <GeraldCode> I used maybe mostly
20:22:09 <GeraldCode> So the impression I get is that we use monads in haskell to emulate imperative stuff mostly
20:22:23 <GeraldCode> so we shouldnt really bother when in an imperative language,...is that a correct statement?
20:22:37 <jle`> that's not why i use monads
20:22:39 <Cale> Uh, no, the reason why we shouldn't bother is different
20:22:48 <GeraldCode> ok, Cale, enlighten me please
20:22:57 <lfairy> GeraldCode: left-associated binds? bleh
20:23:17 <GeraldCode> hmm
20:23:38 <Cale> First of all, many monads are not simply "for imperative code" -- certainly there's an imperative flavour to do-notation, but that's ignoring a lot.
20:23:46 <Cale> Consider for instance this:
20:23:49 <GeraldCode> kk:)
20:23:58 <Cale> > do x <- [1,2,3]; y <- [40,50,60]; return (x + y)
20:23:59 <lambdabot>  [41,51,61,42,52,62,43,53,63]
20:24:12 <GeraldCode> non determinism
20:24:13 <GeraldCode> ?
20:24:15 <Cale> yes
20:24:30 <GeraldCode> ok
20:24:46 <Cale> There are monadic parsing libraries which have a sort of mixture of nondeterminism and state (the remaining part of the string to be parsed)
20:25:09 <Cale> But let's think for a moment why we care that anything is a monad
20:25:14 <GeraldCode> yes :)
20:25:16 <stolaruk> STM is in its own monad
20:25:26 <Cale> Well, it's because there are things which will work with any monad at all:
20:25:28 <Cale> :t sequence
20:25:29 <lambdabot> Monad m => [m a] -> m [a]
20:25:32 <Cale> :t mapM
20:25:32 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
20:25:38 <Cale> :t liftM2
20:25:38 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:25:40 <GeraldCode> type classes
20:25:47 <GeraldCode> But that isnt unique to moans
20:25:49 <GeraldCode> monads
20:25:50 <jle`> generic functions
20:26:07 <Cale> If we can't write things like sequence, which will work with an arbitrary monad, there is no point at all in mentioning that anything happens to be a monad.
20:26:11 <GeraldCode> what is the special quality of monads
20:26:30 <GeraldCode> Cant we right things in a sequence using functions that tdo not act like monads?
20:26:40 <Cale> The problem with this translation into PHP is that you won't be able to write a generic sequence that works
20:26:48 <benzrf> ughhhhhhh, php
20:26:53 <benzrf> gross
20:27:00 <GeraldCode> yes I hate PHP too, but it pays the bills benzrf
20:27:04 <benzrf> =[
20:27:09 <GeraldCode> I am embarressed to even say I do this
20:27:11 <Cale> It doesn't matter that it's PHP specifically, all dynamically typed OO programming languages have roughly the same issue.
20:27:16 <GeraldCode> but it paid for my car, and student loan
20:27:20 <benzrf> Cale: pls
20:27:25 <benzrf> i know they have some issues
20:27:26 <benzrf> but pls
20:27:29 <Cale> :t return
20:27:29 <lambdabot> Monad m => a -> m a
20:27:32 <benzrf> pls dont lump in python and ruby with php
20:27:39 <GeraldCode> cale, see here is my issue...
20:27:47 <Cale> ^^ return is polymorphic in the type of its result in a way which can't be determined by its argument
20:27:55 <GeraldCode> Why do we have to wrap it? cant you get sequential execution witout wrappign anything?
20:27:58 <rola> Is there a way to do multi-line stuff in ghci by binding alt-enter to make a new line without evaluation?
20:28:01 <benzrf> GeraldCode: how?
20:28:01 <Cale> and thus relies on typing context in order to determine its implementation
20:28:09 <benzrf> GeraldCode: do you understand what sequence does/
20:28:22 <benzrf> GeraldCode: the key point of sequence is that it works on any monad
20:28:29 <GeraldCode> a->(a->b)->(b->c)
20:28:35 <benzrf> GeraldCode: no
20:28:40 <GeraldCode> k :)
20:28:41 <benzrf> that's composition with application
20:28:42 <benzrf> :t sequence
20:28:43 <lambdabot> Monad m => [m a] -> m [a]
20:28:45 <bms1> rola: you can use {} and semicolons...
20:29:03 <benzrf> > sequence [Just 1, Just 5, Just 0]
20:29:03 <Cale> Without that type class machinery, if you want a faithful translation which will actually get you any of the abstraction benefit of monads, you need to add an additional parameter to return and bind and all the other things like sequence, mapM, liftM2, etc. which work over an arbitrary monad
20:29:05 <lambdabot>  Just [1,5,0]
20:29:07 <benzrf> > sequence [Just 1, Nothing, Just 0]
20:29:07 <GeraldCode> benzrf,  I do not understand muich of anyhing
20:29:09 <lambdabot>  Nothing
20:29:13 <GeraldCode> I know how to use intgemediate haskell
20:29:17 <GeraldCode> do I know whyI do it, no
20:29:20 <benzrf> GeraldCode: do you know fungtors?
20:29:22 <benzrf> *functors
20:29:24 <Cale> i.e. you need to pass in a dictionary consisting of the implementations of return and (>>=)
20:29:33 <GeraldCode> benzrf, I know how to use them, thanks to Functors in pictures
20:29:34 <Cale> GeraldCode: Does that make sense?
20:29:48 <benzrf> GeraldCode: a monad is like a functor
20:29:49 <rola> bms1, yes, i'm familiar with :{ … :}
20:29:57 <benzrf> but with return and bind
20:29:59 <Cale> benzrf: Every monad is a functor
20:30:01 <GeraldCode> im sotty cale, Im just not at that level yet
20:30:07 <GeraldCode> I know how to work the code
20:30:08 <benzrf> Cale: yes, of course
20:30:12 <Cale> GeraldCode: Well, could you explain why it's unclear?
20:30:17 <Welkin2> wow
20:30:20 <Welkin2> are you all drunk?
20:30:21 <Cale> GeraldCode: I'm happy to go into more detail :)
20:30:29 <Welkin2> or have tour fingers turned into bananas?
20:30:32 <GeraldCode> cale, because if we are talking about sequential execution..I can do that without a monad
20:30:33 <Welkin2> your*
20:30:35 <enthropy> rola: :set +m -- is another option
20:30:37 <Welkin2> oh the irony
20:30:39 <enthropy> which
20:30:47 <enthropy> makes you add an extra newline to say you're done
20:30:57 <benzrf> GeraldCode: not really execution
20:31:11 <benzrf> GeraldCode: it's only execution in the sense that a mobit is something that can be executed
20:31:20 <Cale> Oh great, now that services are down, the trolls are in full force
20:31:27 <benzrf> oh nooooooooooooooooooooooooooooo
20:31:28 <Cale> can we...
20:31:30 <GeraldCode> Im not trolling
20:31:35 <Cale> GeraldCode: I know you're not
20:31:48 <Cale> Okay, so anyway
20:32:05 <GeraldCode> ok...see I am sure monads have a purpose..men smarter than me (and probably a lot of women too) figured it out
20:32:09 <GeraldCode> I just dont get it yet
20:32:21 <benzrf> GeraldCode: the purpose of monads is twofold
20:32:23 <GeraldCode> because I think I can do most monad things without monads
20:32:34 <Cale> GeraldCode: The point of talking about monads is that we can write code which will work with any monad (e.g. most of the stuff in Control.Monad)
20:32:39 <benzrf> the first purpose is so that functions can be written in terms of bind and return and they will work for any monad
20:32:42 <benzrf> so you can reuse code
20:32:51 <Cale> GeraldCode: and this saves us from repeating that code for every monad we happen to stumble upon
20:32:55 <rola> http://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-Base.html#instance%20Monad%20%5b%5d
20:32:55 <Cale> GeraldCode: ok?
20:32:59 <benzrf> the second is that once you grok monads, you gain to ability to understand any new interface defined as a monad
20:33:02 <Cale> GeraldCode: same as with any abstraction
20:33:08 <dfeuer> Can't someone write a PHP backend for GHC? I don't know PHP, but from what I've heard, it wouldn't be much harder to read machine-produced PHP than human-produced.
20:33:14 <GeraldCode> you talk about re-use
20:33:18 <Cale> GeraldCode: yes
20:33:19 <GeraldCode> but that ignoreds the monad laws
20:33:20 <benzrf> dfeuer: why the heck would you want that
20:33:24 <Cale> GeraldCode: It's just for code reuse
20:33:25 <benzrf> GeraldCode: no it doesnt
20:33:40 <benzrf> GeraldCode: anyway
20:33:44 <Cale> GeraldCode: The monad laws are important for refactoring and simplifying code that works with an arbitrary monad
20:33:48 <benzrf> once you understand how monads work and how to use them
20:33:49 <kazagistar> GeraldCode: they are an abstraction, and they help with composing different things that fit the pattern. You could do (+) as "addFloats" and "addInts" functions, but writing code that is generic over any thing that can be added is useful
20:33:59 <benzrf> GeraldCode: i can say 'Maybe is a monad' and show you how the instance works
20:34:13 <benzrf> and now you have an easier understanding of a useful way of using Maybe
20:34:22 <benzrf> it unifies concepts
20:34:25 <dfeuer> benzrf, so that when you need PHP code (to work with some framework or whatever) you can manufacture it, without having to do it by hand.
20:34:25 <GeraldCode> benzrf, I get that
20:34:28 <benzrf> kk
20:34:32 <GeraldCode> that is abstraction
20:34:35 <GeraldCode> and I appreciate that
20:34:37 <benzrf> right :-)
20:34:52 <benzrf> GeraldCode: monads are an abstraction for functors that can be flattened
20:35:06 <dwcook> @type join
20:35:06 <GeraldCode> ok, now you just blew my mind
20:35:07 <lambdabot> Monad m => m (m a) -> m a
20:35:10 <bms1> dfeuer: Well, there's Hack, which was written partially by the guy who wrote attoparsec
20:35:12 <Cale> :(
20:35:14 <GeraldCode> I havent heard the word "flattened" in any tutorial
20:35:22 <GeraldCode> I swear im not stupid
20:35:27 <benzrf> GeraldCode: you can write bind in terms of fmap and join
20:35:34 <benzrf> or you can write join in terms of bding
20:35:35 <benzrf> *bind
20:35:38 <dfeuer> What's that, bms1? A C-- to PHP compiler?
20:35:40 <benzrf> they're equivalently powerful
20:35:43 <GeraldCode> oh is that what that means?
20:35:46 <benzrf> GeraldCode: yes
20:35:51 <GeraldCode> ok
20:35:53 <benzrf> 11:33 < lambdabot> Monad m => m (m a) -> m a
20:35:55 <benzrf> for example
20:35:58 <Cale> "flattened" only in a very abstract way
20:36:01 <bms1> No, it's an extension of PHP that's got, well, a type system and such things http://hacklang.org
20:36:02 <kazagistar> GeraldCode: you wont find the reason for the Monad abstraction in the Monads themselves, but in the libraries that work with them, in the same way you dont find the reason for Num or Functor or Ix in the library itself, but in the code that uses it
20:36:03 <benzrf> > join (Just (Just 3))
20:36:04 <lambdabot>  Just 3
20:36:09 <benzrf> > join (Just Nothing)
20:36:10 <lambdabot>  Nothing
20:36:12 <benzrf> > join Nothing
20:36:13 <lambdabot>  Nothing
20:36:17 <benzrf> join for Maybe
20:36:23 <benzrf> > join [[1, 2, 3], [4, 5, 6]
20:36:24 <lambdabot>  <hint>:1:27:
20:36:25 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
20:36:25 <benzrf> > join [[1, 2, 3], [4, 5, 6]]
20:36:27 <lambdabot>  [1,2,3,4,5,6]
20:36:30 <benzrf> join for []
20:36:41 <johnw> > join (+) 2
20:36:42 <GeraldCode> kazagistar,  ok hmm
20:36:42 <lambdabot>  4
20:36:43 <benzrf> > (join replicate) 5
20:36:44 <lambdabot>  [5,5,5,5,5]
20:36:46 <johnw> that doesn't really fit the flattening concept well
20:36:46 <Cale> GeraldCode: anyway, there's a lot of noise here which I feel is preventing me from explaining this coherently
20:36:51 <benzrf> johnw: it does
20:36:57 <benzrf> you have to think in terms of currying
20:37:00 <GeraldCode> Cale, its ok, I just appreciate you taking the time
20:37:05 <GeraldCode> I will get it eventually
20:37:08 <johnw> yeah, you have to change your thinking to make it fit the concept
20:37:34 <Cale> GeraldCode: So, okay, the point of talking about monads is that we have all these various libraries which define operations which are the same shape as return and (>>=)
20:37:43 <Cale> GeraldCode: and we'd like to be able to share some code between them
20:37:54 <GeraldCode> That is clearly a solid reason
20:38:02 <Cale> GeraldCode: in particular, all the useful control-structure-like code such as mapM and sequence
20:38:07 <hae> Haskell isn't the only language that requires you to change your thinking about code, but it's the only one that requires you to change your thinking about thinking about code.
20:38:20 <GeraldCode> hae , damn
20:38:26 <GeraldCode> you just blew my mind
20:38:36 <Cale> GeraldCode: If we couldn't write a sequence function that would work with any monad, there would be no point in talking about monads.
20:38:54 <GeraldCode> Cale, here is the thing
20:38:57 <Cale> GeraldCode: The problem with the translation into PHP in that code is that it doesn't admit that kind of polymorphism
20:39:04 <GeraldCode> Cale, most people like me get confused about monads and give up
20:39:11 <dfeuer> I opened a channel to get less noise for this discussion, GeraldCode and Cale. You're both invited.
20:39:13 <GeraldCode> then we give it a second go..and kind of understand them
20:39:14 <benzrf> GeraldCode: the problem is that monads are not an easy concept
20:39:17 <GeraldCode> then we ask why
20:39:18 <benzrf> GeraldCode: they just arent
20:39:20 <johnw> also, join is equally able to create structure rather than eliminate it (consider the free monad); so I think of it as a functorial multiply, rather than a flattening; flattening implies some kind of evaluation or reduction to me
20:39:23 <GeraldCode> and get confused all over again
20:39:29 <Cale> GeraldCode: The right thing to do is not to try to understand monads, just learn how to use various libraries which happen to define monads.
20:39:32 <benzrf> GeraldCode: you use them for a while only half-grokking them, until it starts to make sense
20:39:48 <Cale> GeraldCode: Once you've seen a bunch of examples, there's really not a whole lot to it
20:39:53 <GeraldCode> kk
20:40:04 <GeraldCode> I kind of get it..
20:40:05 <Cale> I mean, it's two functions.
20:40:09 <GeraldCode> in the sense that ther is nothing to get
20:40:12 <GeraldCode> they are all so different
20:40:17 <Cale> from which a handful of stuff can be derived
20:40:19 <GeraldCode> monads is a really abstract concept
20:40:28 <benzrf> GeraldCode: but in the meantime it may help (or maybe not) to think of monadic values as 'computations'
20:40:31 <Cale> and that stuff is useful in many cases
20:40:36 <benzrf> GeraldCode: or 'deferred computations'
20:40:51 <benzrf> GeraldCode: it's sort of a misleading analogy, though
20:40:51 <dfeuer> Or "recipes".
20:40:55 <GeraldCode> yeah you confused me with the last one
20:40:57 <GeraldCode> but thats ok
20:41:03 <Cale> benzrf: I disagree, it's not misleading.
20:41:10 <benzrf> Cale: eeehhhh
20:41:34 <Welkin2> @quote benzrf2
20:41:34 <lambdabot> benzrf2 says: <benzrf> i dont know whats happening <benzrf> am i being trolled
20:41:37 <kazagistar> I am not sure that a list is a "defered computation"
20:41:41 <benzrf> Welkin2: y
20:41:44 <Cale> Every monad which can be defined in Haskell can be thought of as a type constructor for types of computations having results of the given type.
20:41:52 <kazagistar> though, I guess I can see it in that sense
20:42:03 <Cale> i.e. x :: M t means that x is an M-computation whose result has type t
20:42:12 <benzrf> kazagistar: well, the idea is that you can generally treat functions in terms of monads as ways of messing around with computations without ever running them
20:42:13 <Cale> kazagistar: sure!
20:42:18 <hae> Just think of monads like burritos.
20:42:23 <benzrf> kazagistar: compose, not apply
20:42:33 <Cale> A list is a computation for a nondeterministic machine which has the elements of the list as its results
20:42:40 <GeraldCode> lol burritos...sint that what people say when they want to troll?
20:42:44 <Cale> i.e. in parallel
20:42:47 <hae> >_>
20:42:47 <benzrf> Cale: yeah, but that's a
20:42:52 <benzrf> that's a lie-to-children
20:42:58 <Cale> There's always such an interpretation
20:43:00 <Cale> It's not a lie!
20:43:12 <Cale> It's a completely valid interpretation of the list monad.
20:43:14 <johnw> Cale: you're lucky Const isn't a Monad ;)
20:43:14 <benzrf> i said it was a lie-to-children, which is not quite a lieven_
20:43:17 <glguy> GeraldCode: The community went through a phase of making up inane analogies for explaining monads, it kind of maxed out at burritos
20:43:26 <bms1> I'm starting to think Haskell has a "monad" problem. Beginners want to do IO, see the word "monad" littered around, and get the impression that to program Haskell they must first become category theorists
20:43:36 <hae> ^ glguy
20:43:43 <Cale> bms1: Yeah, it's a common XY problem
20:43:48 <benzrf> i find that category theory is to haskell as unix is to perl
20:43:59 <GeraldCode> lol glguy
20:44:01 <benzrf> you dont need to know ct/unix to learn hs/perl
20:44:08 <benzrf> but you usually already know it or end up picking it up
20:44:14 <benzrf> just because of the tie-ins and community
20:44:27 <kazagistar> and it helps you to grok where the heck some of the stuff came from
20:44:31 <carter> i don't know any category theory
20:44:35 <carter> it'd probably help when i'm doing math
20:44:41 <carter> and exotic codes
20:44:42 <carter> :)
20:44:42 <Cale> GeraldCode: So, let's have a look at some examples of monads, actually, for this, let's go to #haskell-overflow because there's a fair amount of code, and #haskell scrolls too quickly
20:44:45 <carter> but not most codse
20:44:51 <benzrf> i know what a natural transformation is
20:44:56 <benzrf> thats about as far as ive got
20:45:45 <hae> Sometimes monads are the right thing to do.
20:45:58 <Athas> Is it possible to import only a data constructor, but not the type?
20:46:02 <Cale> GeraldCode: (whenever you'd like)
20:46:07 <Welkin2> didn't the community also go through a phase of "let's use arrows everywhere for everything!"?
20:46:15 <Cale> Welkin2: no
20:46:27 <Cale> Welkin2: Arrows were never all that popular
20:46:32 <Welkin2> I thought hackage used arrows for a short period
20:46:35 <Cale> and for pretty good reasons
20:46:41 <johnw> I remember the brief arrow euphoria
20:46:42 <GeraldCode> ok cale
20:46:47 <Welkin2> and hakyll was written using arrows
20:46:50 <Welkin2> but now uses monads
20:47:26 <benzrf> Athas: how would that even work
20:47:36 * benzrf tries
20:47:43 <Athas> benzrf: I would use a qualified name for the type.
20:47:50 <benzrf> Athas: oic
20:47:53 <benzrf> yeah i misunderstood
20:47:56 <benzrf> do:
20:48:06 <benzrf> import qualified Some.Module
20:48:11 <benzrf> import Some.Module (Constructor)
20:48:30 <benzrf> i was thinking of exports :v
20:48:36 <Athas> ...that only works if the name of the constructor is not the same as the name of the type, right?
20:48:48 <benzrf> Athas: hmm
20:48:55 <benzrf> now that i think about it, im not sure how importing types works
20:49:10 <glguy> You can't import data constructors on their own
20:49:14 <benzrf> glguy: orly
20:49:19 <glguy> you have to do it TypeCon(DataCon)
20:49:27 <benzrf> Athas: worst case scenario, you can do this:
20:49:30 <benzrf> import qualified Some.Module
20:49:39 <benzrf> constructor = Some.Module.Constructor
20:49:57 <Athas> That loses the destructor, so I can't pattern match anymore.
20:50:22 <Athas> Or use record syntax, I believe.
20:53:28 <Athas> If I make sure the type does not have the same name as the constructor, I can make it work.
20:53:34 <Athas> Quite a hack, though, but I will live.
20:53:42 <Athas> (Again I wish for the SML module system!)
20:54:33 <bms1> I have been doing some signal processing lately... using the vector package
20:54:54 <bms1> I am starting to have major garbage collection issues. My program spends most of its time cleaning up garbage
20:55:08 <benzrf> Athas: why nt just
20:55:18 <benzrf> import qualified Some.Package as S
20:55:22 <benzrf> then you can destruct with
20:55:29 <benzrf> f (s.Constructor 1 2 3) = 4
20:55:35 <benzrf> oops i mean S.Constructor
20:56:02 <dfeuer> There is no good reason to want to import a constructor and not its type.
20:56:05 <Athas> benzrf: because that would require all the users of my module to do that.
20:56:16 <bms1> I think it somewhat has to do with the fact that fusion isn't working as well as I'd hope, and so there's a lot of intermediate arrays that are allocated and collected
20:56:46 <hae> bms1, maybe you should stop producing so much garbage to begin with.
20:57:07 <dfeuer> @type pure
20:57:07 <lambdabot> Applicative f => a -> f a
20:57:15 <Athas> dfeuer: yes, there is.  I have a parametric type 'Original.T a = C', and I want to create a "specialised" variant, where "a" is fixed, i.e., "type T = Original.T V".
20:57:27 <Athas> Yet, I want to use the same constructor, because it's really just a type alias for convenience.
20:57:33 <bms1> hae: Well, I think it's garbage that I'd hoped wouldn't be made, because intermediate things would be fused
20:57:59 <bms1> But I'm facing the fact that perhaps I need to either (A) work less modular-ly to make sure intermediate vectors aren't produced
20:58:01 <Athas> And in the end, I want to package this as a single module, that can then be exported to get the specialised types and the original constructors.
20:58:03 <benzrf> Athas: why does it got to be the same name
20:58:04 <dfeuer> Athas, why not just give your Original.T a different name?
20:58:15 <bms1> or (B) write my code in terms of mutable operations and compose those instead
20:58:22 <Athas> dfeuer: that is also what I ended up with, but that's just a workaround.
20:58:52 <Athas> It makes the Hackage docs harder to read, for example, because there are some general functions that work on Original.Ts.
20:59:00 <Athas> Errr, Haddock docs.
20:59:20 <Athas> Although... I can just define my own type alias within those modules that do that, I suppose.
21:02:24 <Athas> Ooooh wait, I can just define 'Original.T' as some 'Original.TGen' (i.e. different type name), then have a type alias 'Original.T = Original.Tgen' just below.
21:02:41 <Athas> That means the type name 'T' is now decoupled from the constructor name 'T'.
21:02:48 <Athas> Wow, this is horrible, but it should work nicely.
21:04:07 <rola> is "[a]" sort of (but not quite) an alias for "[] a"
21:04:48 <Athas> rola: I am pretty sure it is an exact alias.
21:04:50 <bms1> rola: Yes, it's pretty much syntactic sugar, like tuple constructors and -> too
21:04:51 <dwcook> rola: Those two mean the same thing as types.
21:05:04 <rola> cool!
21:05:13 <dwcook> rola: As values, they're not at all the same.
21:05:33 <stephenmac7> Quick question: I am trying to use StateT to keep a global-like state for my application, but it's a little hard to deconstruct a huge piece of data like that. Any way I could easily access/mondify/operate on specific values?
21:06:32 <rola> so it's correct in the context of type signatures to think of it as syntactic sugar ?
21:07:59 <kazagistar> rola: yes
21:08:32 <benzrf> Cale just said (in another channel) that 'mobit' is a joke name and people laugh if you use it
21:08:38 <glguy> stephenmac7: You can write a function that runs a computation with a subset of the state and then puts that back when it's done into the larger state
21:08:40 <benzrf> y-you guys dont laugh at me when i say mobit, do you?
21:08:44 <kazagistar> rola: in the same way, { a -> b } == { (->) a b }
21:08:48 <glguy> In the lens library this is called "zoom" but you can do it on your own, too
21:08:52 <Exio> @src foldl
21:08:52 <lambdabot> foldl f z []     = z
21:08:52 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:09:00 <glguy> (Not advocating for writing whole programs in StateT)
21:09:02 <benzrf> :t zoom
21:09:03 <lambdabot> (Zoom m n s t, Control.Lens.Internal.Zoom.Zoomed n ~ Control.Lens.Internal.Zoom.Zoomed m) => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
21:09:10 <stephenmac7> glguy: What is lens?
21:09:26 <johnw> glguy: so zoom is like a focused modify?
21:09:27 <benzrf> stephenmac7: a crazynuts library
21:09:42 <benzrf> edwardk: lens is the only library I've ever written that generates hate mail and invites to give talks in almost equal measure
21:09:43 <stephenmac7> Oh, and why wouldn't you suggest writing whole programs in StateT?
21:09:43 <glguy> johnw: Kind of except that modify only works with pure functions
21:09:48 <benzrf> ^quote, not addressed at him
21:09:49 <johnw> ah, ok
21:09:59 <johnw> glguy: how does the new state get back in, you return it?
21:10:07 <johnw> or does it just make the state look like the narrowed version?
21:10:18 <johnw> so that you would put/modify it
21:10:22 <edwardk> benzrf: pretty much
21:10:23 <glguy> narrowed
21:10:26 <johnw> cool
21:10:58 <glguy> it's just a wrapper for runStateT'ing your subcomputation and putting in the sub-state and then setting that sub-state back into the "larger" one
21:11:13 <glguy> stephenmac7: it's a data manipulation library
21:11:38 <stephenmac7> glguy: In what way does it manipulate data?
21:11:42 <benzrf> stephenmac7: every way
21:11:47 <benzrf> stephenmac7: seriously
21:11:48 <stephenmac7> benzrf: You wrote it?
21:11:51 <benzrf> no
21:11:52 <benzrf> that was a quote
21:11:56 <benzrf> 12:07 < benzrf> ^quote, not addressed at him
21:11:59 <stephenmac7> Oh, I see.
21:12:23 <stephenmac7> benzrf: So, what's wrong with it?
21:12:31 <bms1> It's a combinator library; it's mainly a lot of of highly overloaded general operators
21:12:38 <benzrf> i like it, more or less
21:12:46 <glguy> stephenmac7: There's just a lot to learn if you want to learn the whole thing
21:12:57 <johnw> yeah, lens is like another language within Haskell sometimes
21:13:00 <benzrf> it... goes a little overboard in some ways. here is a sample type signature:
21:13:04 <stephenmac7> Oh, I see. But it's useful for writing things with lots of state?
21:13:12 <benzrf> :t review
21:13:13 <lambdabot> MonadReader b m => AReview s t a b -> m t
21:13:14 <johnw> it's *super* useful for manipulating state
21:13:22 <johnw> and also at manipulating maps
21:13:24 <benzrf> ok bad example
21:13:27 <benzrf> that's almost readable
21:13:29 <johnw> there are things at which it is by far the best option
21:13:38 <benzrf> edwardk: what's a function whose type signature includes `Optic'
21:13:41 <stephenmac7> benzrf: It's readable if you know what AReview is
21:13:42 <rola> kazagistar, is there a name for this which i can google and read more examples?
21:14:02 <stephenmac7> johnw: Maybe I'll take a look
21:14:03 <benzrf> stephenmac7: wanna know what AReview' is?!
21:14:06 <edwardk> benzrf: optics cover pretty much the whole family of different lens-likes
21:14:13 <johnw> stephenmac7: it's definitely worth a look
21:14:18 <stephenmac7> benzrf: I probably don't want to know... yet.
21:14:21 <johnw> and there are a number of good intro tutorials around now
21:14:24 <benzrf> type AReview' t b = AReview t t b b
21:14:28 <benzrf> type AReview s t a b = Optic (Data.Tagged.Tagged *) Identity s t a b
21:14:36 <benzrf> type Optic p f s t a b = p a (f b) -> p s (f t)
21:14:52 <stephenmac7> One thing I don't like about haskell is using letters instead of full names
21:15:08 <benzrf> stephenmac7: if you intend to learn lens, you may have to get over that +_+
21:15:25 <kazagistar> rola: lists, tuples, and functions are the only ones you will probably see, but you might want to look into "haskell kinds" for some insight into how it works?
21:15:27 <glguy> "Optic" is basically the overall pattern of things in the library for defining ways to interact with specific data
21:15:30 <johnw> stephenmac7: sometimes a single letter is equally as meaningful as any other name you might choose
21:15:36 <glguy> and then there are a bunch of combinators that take those
21:15:39 <johnw> since the arguments are entirely abstract
21:16:08 <stephenmac7> So, I'm guessing normal haskell functionality doesn't work with this lens stuff.
21:16:14 <johnw> sure it does
21:16:14 <benzrf> stephenmac7: well
21:16:19 <benzrf> lenses are, in fact, functions
21:16:32 <benzrf> although various kinds of optics generalize to any kind of profunctor
21:16:39 <benzrf> :t _1
21:16:40 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
21:16:46 <benzrf> ^that's the lens that focuses on the first element in a tuple
21:17:01 <benzrf> > view _1 (3, 4)
21:17:04 <lambdabot>  3
21:17:11 <stephenmac7> Why use that over fst?
21:17:12 <benzrf> > over _1 show (3, 4)
21:17:14 <lambdabot>  ("3",4)
21:17:20 <benzrf> stephenmac7: it composes
21:17:29 <glguy> stephenmac7: and it works on things that aren't pairs
21:17:36 <Taneb> benzrf, so does fst :P
21:17:36 <glguy> > view _1 ('a','b','c')
21:17:38 <lambdabot>  'a'
21:17:39 <benzrf> > view (_1 . _2) ((3, 7), 4, 5)
21:17:41 <lambdabot>  7
21:17:51 <stephenmac7> Ah. Very snazzy :P
21:17:58 <benzrf> > over (_1 . _2) show ((3, 7), 4, 5)
21:17:59 <lambdabot>  ((3,"7"),4,5)
21:18:04 <benzrf> !!!
21:18:14 <stephenmac7> Anyway, I still would like to know what's wrong with using StateT for a whole program.
21:18:17 <jle`> you can think of `_1` as an object that contains instructions to both access and modify the first item, too.  so it's like fst, with (\z (x, y) -> (z, y)), wrapped up in a nice package
21:18:20 <jle`> also, it composes.
21:18:28 <Taneb> stephenmac7, mostly, you don't need to
21:18:40 <jle`> stephenmac7: also, you are basically suggesting having your whole program run with global state
21:18:42 <Taneb> And it can make your program more complicated
21:18:49 <jle`> which hasn't been a good idea since the early 1900's
21:18:50 <kazagistar> stephenmac7: you can say something like "decrement the health of every character in an active party in this XML file" really easily with lenses
21:20:09 <stephenmac7> jle`: Well, kind of. The full state would only stay inside a function or two
21:20:45 <stephenmac7> Then those would call other functions with only the required information, like normal.
21:20:52 <jle`> ah
21:20:58 <jle`> well that sort of defeats the whole purpose of StateT, doesn't it?
21:21:03 <benzrf> stephenmac7: that's not 'in StateT'
21:21:50 <stephenmac7> jle`: It seems to be a good solution if you need your program to loop with it's own state
21:22:13 <jle`> stephenmac7: why not just explicit state passing?
21:22:29 <jle`> StateT s m a is just a wrapper around a function
21:22:32 <jle`> s -> m (a, s)
21:22:51 <jle`> i guess..it's nto that bad if you want to be able to use Monad combinators with it
21:22:57 <jle`> then sure :) go ahead
21:23:00 <jle`> if you are only using it for a few things
21:23:12 <jle`> i still don't think it's worth the complication
21:23:42 <stephenmac7> Actually, only reason I'm not passing it explicitly is because I'm using the value (the a part of (a, s)) to tell it when to stop
21:24:06 <stephenmac7> But it would be just as good just to return (Bool, ApplicationState)
21:25:05 <stephenmac7> jle`: That makes you wonder though: what _is_ a good use for StateT?
21:25:24 <jle`> if you want to take advantage of Monad combinators
21:25:36 <jle`> hm.
21:26:01 <jle`> well, StateT s IO is pretty dangerous
21:26:12 <jle`> StateT s Reader can sometimes be useful
21:26:19 <stephenmac7> jle`: That doesn't help if you don't know what Monad combinators are
21:26:20 <jle`> StateT s [] ?
21:26:35 <jle`> stephenmac7: monad combinators like forM, untilM (in monad-loops), etc.
21:26:42 <stephenmac7> Oh, I see.
21:26:43 <jle`> basically functions :: Monad m => useful -> stuff -> with -> monads
21:26:50 <jle`> that are parametric over all Monads
21:26:51 <stephenmac7> StateT s []... I wonder what that would be like.
21:27:13 <jle`> StateT s IO can be useful if you do it with discipline
21:27:20 <jle`> using zoom and monad morphisms like from mmorph
21:27:26 <glguy> ?unmtl StateT s [] a
21:27:26 <lambdabot> s -> [] (a, s)
21:27:29 <glguy> It would look like that
21:27:39 <glguy> aka.   s -> [(a,s)]
21:27:57 <jle`> that is...your computation all "comes together" in StateT s IO
21:28:01 <jle`> but nothing you actually write is StateT s IO
21:28:10 <jle`> you might have some parts Reader s Identity
21:28:17 <jle`> --- access the state, but can't change it
21:28:24 <jle`> you might have some parts StateT s Identity
21:28:28 <jle`> --- modify the state, but not do IO
21:28:37 <jle`> you might have some parts StateT (smaller component of the state) Identity
21:28:48 <jle`> --- only be able to access and modify small parts of the state, not the entire one
21:29:01 <jle`> and then write your morphisms to "glue them all together" in a "lowest common denominator"
21:29:14 <stephenmac7> Yes, that last one would be useful
21:29:20 <stephenmac7> Just plain State
21:29:36 <jle`> ie, readOnly :: Reader s a -> State s a
21:29:41 <stephenmac7> Though, at that point, Reader might just wor
21:29:43 <stephenmac7> *work
21:29:51 <jle`> noIO :: StateT s Identity a -> StateT s IO a
21:30:17 <stephenmac7> I'll keep that in mind.
21:30:19 <jle`> so basically, you write all your functions...giving them only the "power" they need... and then combine them all together in the end
21:30:23 <jle`> actually...hm
21:30:26 <jle`> you might not even need noIO
21:30:28 <benzrf> all free type vars are automatically universally quantified, right
21:30:35 <jle`> you can write functions MonadState s m => ...
21:30:45 <jle`> and then in that entire function, you can't access IO -- you can only get and put and modify
21:30:56 <jle`> and then...you don't need any explicit lifting
21:30:59 <jle`> hmmm
21:31:01 <jle`> that's nice.
21:31:02 <benzrf> dyel
21:31:22 <jle`> anyways the part where you only modify parts of the state is a real pain to work with without lens
21:31:25 <stephenmac7> Yes, change the state without doing anything else.
21:31:40 <jle`> lens makes the "be able to write functions that only modify parts of the global state" a lot more streamlined
21:32:33 <stephenmac7> Ah, so I should just take a look at lens.
21:34:10 <jle`> if you want to be able to write those state parts that only modify parts of the state...then, lens would help
21:34:34 * hackagebot persistent-mongoDB 1.4.3 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.4.3 (GregWeber)
21:35:16 <stephenmac7> jle`: I just looked at the hackage page and lens is... huge
21:35:37 <jle`> .______.
21:36:10 <ReinH> edwardk: ping
21:36:19 <dfeuer> The ongoing lecture in #haskell-overflow just went to  (->) t, which reminded me of a question I had: is there some sort of type-level flip that would allow (->t) to be expressed?
21:36:55 <jle`> type Flip b a = a b ?
21:37:10 <jle`> ...does that work? >_>
21:37:11 <glguy> newtype ThatThing a b = FlippedFunction (b -> a)
21:37:26 <jle`> Flip (->) t
21:37:29 <stephenmac7> Well, thanks jle`. You've been very helpful today.
21:37:31 <edwardk> dfeuer: you can write newtype Op b a = Op (a -> b)
21:37:33 <stephenmac7> Multiple times
21:37:39 <Exio> what high order functions are the most important in Prelude? (i've written a small "toy language" and i'm coding its "base library"), so far i have map/filter/fold[lr]
21:38:08 <joelteon> Exio, are you using map :: ... -> [a] -> [b] or Functor f => f a -> f b
21:38:10 <kristof> LiftM
21:38:16 <edwardk> dfeuer: hask also lets you make the co/contravariant functor for different arguments of a thing but its not for the faint of heart ;)
21:38:16 <enthropy> dfeuer: unfortunately it's only practical when you have a constructor involved
21:38:37 <dfeuer> edwardk, you just flew over my head, as usual :-/
21:38:41 <jle`> stephenmac7: np :)
21:38:41 <kristof> joelteon: >>=
21:38:51 <joelteon> kristof: sorry?
21:39:03 <Exio> joelteon, [a] -> [b]! the toy language isn't that powerful!
21:39:08 <glguy> edwardk: The answer to "is there some sort of type-level flip that would allow (->t) to be expressed?" certainly is never "hask" :-p
21:39:16 <joelteon> Exio: oh sorry, a toy language
21:39:17 <edwardk> glguy: not yet ;)
21:39:20 <joelteon> I thought you were writing a prelude replacement
21:39:30 <edwardk> glguy: muahahahaha
21:39:40 <edwardk> glguy: gave a talk on it at boston haskell last night
21:39:56 <dfeuer> No, not yet. I would very much like to understand all that stuff edwardk talks about some day, but I'm not really even sure how to get started on that road.
21:40:11 <edwardk> dfeuer: well, lets try something real quick
21:40:18 <edwardk> we can write a baby version of hask in a few lines =)
21:40:23 <ReinH> edwardk: so I've been reading this http://www.cs.ox.ac.uk/people/ralf.hinze/publications/MPC12.pdf
21:40:38 <dfeuer> I'm up for that!
21:40:40 <edwardk> ReinH: good writeup
21:40:50 <ReinH> edwardk: anything else I should be reading along those lines?
21:40:52 <edwardk> dfeuer: you'll need a pile of extensions as we go
21:40:55 <glguy> edwardk: Very cool about the talk
21:41:11 <edwardk> type family (~>) :: i -> i -> *; type instance (~>) = (->)
21:41:13 <dfeuer> I don't know what an extension is yet. I hope that will be covered in the next lecture.
21:41:18 <dfeuer> Oh, a GHC extension.
21:41:18 <edwardk> that line needs type families, and polykinds
21:41:35 <ReinH> Oh you'll need the other type of extension too, surely. ;)
21:41:43 <ReinH> Since they're everywhere.
21:41:53 <dfeuer> Yes, I attempted to understand what type families are! It didn't quite work, but I'll try to follow along anyway.
21:41:54 <edwardk> (~>) here is a type family, used to indicate the arrows in some category, where i cheat and make categoried named by their kinds.
21:42:05 <edwardk> now we can define a fancy Functor
21:42:16 <edwardk> class Functor f where fmap :: (a ~> b) -> f a ~> f b
21:42:32 <ReinH> you can tell it's fancy because the arrows are fancy
21:42:41 <edwardk> looks like normal, but notice if you ask the kind of Functor in ghci you get Functor :: (i -> j) -> Constraint -- it works for any kinds
21:43:05 <edwardk> instance Functor (Either a) where fmap = Prelude.fmap -- works just fine
21:43:13 <edwardk> but we can make up new categories for other kinds
21:43:14 <dfeuer> Whoa, go back.
21:43:23 <dfeuer> I'm still trying to understand what that type family declaration means.
21:43:35 <edwardk> the type family line there uses something most people don't know we can do
21:43:42 <edwardk> which is we can make a type family that is determined by its kinds
21:43:45 <Welkin2> you can mix types and kinds?
21:43:54 <edwardk> Welkin2: in limited ways
21:44:23 <kristof> :t >>=
21:44:24 <lambdabot> parse error on input ‘>>=’
21:44:31 <edwardk> type family (~>) :: i -> i -> * -- is saying we have a type family (~>) which is entirely determined by the kind of its arguments
21:44:38 <kristof> :t (>>=)
21:44:38 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:44:43 <dfeuer> I don't know what that means.
21:44:50 <edwardk> type instance (~>) = (->) -- is saying when i = *, we get (~>) = (->)
21:44:53 <kristof> joelteon: Extremely important higher order function ^
21:45:00 <edwardk> we can make up another instance
21:45:15 <edwardk> newtype Nat f g = Nat { runNat :: forall a. f a ~> g a }
21:45:19 <edwardk> type instance (~>) = Nat
21:45:24 <edwardk> Nat :: (i -> j) -> (i -> j) -> *
21:45:37 <edwardk> so we now have a base case (->), and a way to do induction Nat
21:45:47 <edwardk> so (~>) can work for kind * -> * -> *
21:45:54 <edwardk> it can work for (i -> *) -> (i -> *) -> *
21:46:05 <edwardk> it can work for (i -> j -> *) -> (i -> j -> *) -> *
21:46:17 <dfeuer> If you want me to understand, you will have to go back.
21:46:38 <edwardk> i'm iterating out, trying to give a little intution each time
21:46:43 <edwardk> happy to go back at any point
21:46:44 <dfeuer> Perhaps try to explain what a type family is, because when I read a tiny bit about them, I couldn't understand.
21:46:45 <edwardk> =)
21:46:54 <edwardk> ok
21:47:12 <rola> kazagistar, alright, thanks
21:47:17 <dfeuer> In fact, if I walk out of this discussion with a good sense of what a type family is, I will count it as a success.
21:47:36 <edwardk> a type family is like a a type level function that can have multiple statements to it. like when you want to write a function definition and you write it out as several lines all of which match on the different arguments
21:48:11 <dfeuer> OK, so it's a function that takes some types and gives a type?
21:48:12 <edwardk> type family Foo a :: *; type instance Foo Int = Double; type instance Foo Bool = ()
21:48:23 <edwardk> Foo Int = Double
21:48:25 <edwardk> and Foo Bool = ()
21:48:33 <edwardk> given a ~ b, then f a ~ f b
21:48:57 <edwardk> that is what a type family is
21:48:59 <dfeuer> What if it's ambiguous?
21:49:24 <edwardk> overlapping things that would be ambiguous are verboten by the typechecker
21:49:26 <dfeuer> Or is that impossible?
21:49:54 <edwardk> so the rules have to be written in a way that the order of them is completely arbitrary and doesn't matter to the result
21:50:11 <edwardk> there is a notion of a fancy 'closed type family' we can ignore that writes down all of the rules in order, but its irrelevant today
21:50:34 <edwardk> when type families were introduced we were given two things, type families and data families at the same time
21:50:38 <dfeuer> You write   type family Foo a :: *.  I assume that means that Foo a has kind *.  What would it mean to have some other kind?
21:50:53 <edwardk> type family Foo a :: * -> *
21:50:58 <edwardk> type instance Foo Int = Maybe
21:51:02 <edwardk> type instance Foo Double = []
21:51:18 <edwardk> type instance Bar a :: * -> Constraint
21:51:21 <edwardk> type instance Bar Int = Eq
21:51:28 <edwardk> type instance Bar Int = Hashable
21:51:32 <dfeuer> We will not talk about constraints yet.
21:51:34 <benzrf> how d'you use type families again x.x
21:51:35 <edwardk> hah
21:51:44 <dfeuer> But dang that is crazy.
21:51:56 <dfeuer> SHEESH.
21:52:16 <dfeuer> Can you give an example where they overlap and are therefore prohibited?
21:52:26 <edwardk> type instance Foo a = a; type instance Foo Int = Double
21:52:26 <Welkin2> no idea what constraint is either
21:52:38 <dfeuer> *nod*
21:52:38 <enthropy> :k Eq
21:52:38 <edwardk> Welkin2: Eq :: * -> Constraint
21:52:39 <lambdabot> * -> Constraint
21:52:43 <edwardk> :k Ord
21:52:44 <lambdabot> * -> Constraint
21:52:46 <edwardk> :k Monad
21:52:47 <lambdabot> (* -> *) -> Constraint
21:52:58 <Welkin2> oh
21:53:01 <Welkin2> type constraints
21:53:19 <dfeuer> And I know (because someone said it somewhere) that type families are not injective, while data families are.
21:53:24 <edwardk> if you think of the (=>) we know and love you can almostthink of it as having kind (=>) :: Constraint -> * -> *
21:53:37 <edwardk> dfeuer: yep. we said before a ~ b   implies f a ~ f b
21:53:43 <edwardk> for a data family f a ~ f b  implies a ~ b
21:53:55 <edwardk> data family Foo a :: *
21:54:08 <edwardk> data instance Foo Int = MyFooInt Double Double
21:54:17 <dfeuer> [said person was complaining about Vector being a type family instead of a data family, I think.]
21:54:24 <Welkin2> what does ~ means in this context? "relates to"?
21:54:27 <dfeuer> [Or something]
21:54:29 <edwardk> data instance Foo Double = MyFooDoubleA Bool | MyFooDoubleB
21:54:47 <dfeuer> Slow down.
21:54:47 <edwardk> Welkin2: is the same type as. so if a ~ b  then a is the same type as b
21:55:01 <enthropy> :k (~)
21:55:02 <lambdabot> k -> k -> Constraint
21:55:20 <edwardk> :t id :: (a ~ b) => a -> b
21:55:20 <lambdabot> b -> b
21:55:46 <dfeuer> OK, so the data families are injective because no two instances will share a data constructor?
21:55:55 <edwardk> dfeuer: exactly
21:56:17 <edwardk> you wind up with the knowing that if Foo a ~ Foo b  then the only way that can happen is if a and b are also the same type
21:56:39 <edwardk> but only for data families
21:56:43 <edwardk> with type families nothing stops
21:56:47 <edwardk> type family Foo a :: *
21:56:50 <edwardk> type instance Foo Int = Bool
21:56:56 <edwardk> type instance Foo Double = Bool
21:57:06 <edwardk> now Foo Int ~ Foo Double     but Int ~ Double doesn't hold
21:57:49 <edwardk> an injective type family F would give you F a ~ F b implies a ~ b when we get them
21:57:53 <edwardk> but they don't exist right now
21:58:42 <dfeuer> OK, so could you *slowly* give me a bit of a sense of what these things might be good for, before going back to what you were saying about the weird type family you created to talk about flip?
21:59:09 <edwardk> dfeuer: sure, they are useful when you need to change the representation of something when the types involved change
21:59:21 <edwardk> we use this in vector to make it so that vectors of Ints can be stored differently from vectors of pairs
21:59:49 <edwardk> basically it chooses to store Vector Int  -- all together in contiguous storage
22:00:07 <dfeuer> type family Vector potato :: *
22:00:08 <edwardk> but Vector (a,b)  gets stored as a Vector a   and a Vector b   and it uses some logic to pair up entries from each vector
22:01:01 <dfeuer> type instance Vector Int = SomeUnboxedThingOfInts?
22:01:01 <edwardk> data family Vector a :: *; data instance Vector () = V_Unit Int -- there is no information to store
22:01:18 <edwardk> the only thing you need to know about a vector of units is how many of them you have
22:01:33 <edwardk> data instance Vector (a,b) = V_Pair (Vector a) (Vector b)
22:01:46 <edwardk> data instance Vector Int = V_Int some fancy way to store a bunch of unboxed ints
22:02:16 <dfeuer> A strict vector of units. And a strict one of Ints. I assume? Because lazily they are not so nice.
22:02:18 <edwardk> now Vector (Int, ())   -- will be a vector of unboxed ints paired with a number of how many units, which is kinda redundant
22:02:21 <edwardk> yeah
22:02:31 <edwardk> this is the kind of model used on Data.Vector.Unboxed
22:02:41 <edwardk> Data.Vector is boring as everything is lazy
22:02:48 <edwardk> and its only got one representation
22:03:22 <edwardk> but this is the sort of thing that motivated _why_ we got type and data families in the first place
22:03:34 <edwardk> they decided at GHC HQ that they wanted to do a bunch of work on 'data parallel haskell'
22:03:45 <edwardk> and in the process they split off a bunch of cool type system features to support it
22:03:47 <edwardk> this was one of them
22:03:55 <dfeuer> Vector of pairs as pair of vectors seems a bit odd, but I suppose that's fine. You wouldn't want a vector of k-tuples to be stored as a k-tuple of vectors if k were too large, though!
22:03:59 <edwardk> because they needed to  talk about very different representations for DPH arrays of different types of things
22:04:10 <edwardk> dfeuer: well, its a common trick on GPUs
22:04:25 <edwardk> we often work with structures full of arrays rather than arrays of structures
22:04:26 <edwardk> why?
22:04:50 <edwardk> because the arrays can be unboxed, may fit nicely into texture formats, if you don't use something you don't get it cluttering your caches, etc.
22:05:37 <edwardk> when working in javascript an "SoA" approach can also be a win. using typed arrays can work very nicely for zero-copy work in web workers copied into the main thread
22:05:40 <dfeuer> If k is too big, then you'll have lots of "in a while" stuff in the cache as the "really soon" stuff falls out.
22:06:02 <platz> I guessing the idea of Reducers isn't powerful enough for our data parallel needs
22:07:14 <platz> perhaps  because that is fixed into a tree-like structure
22:07:15 <edwardk> dfeuer: sure. you need to pick the right structure for the job
22:07:47 <edwardk> but in general array-of-structures is suboptimal for many many workloads. it is necessarily pessimal if you aren't accessing all fields in all traversals
22:08:07 <edwardk> statistically we access roughly 15% of fields in a table during any sort of access.
22:08:17 <edwardk> so AoS has to pay for an extra factor of 6 in overhead
22:08:22 <dfeuer> AoS?
22:08:27 <edwardk> array of structures
22:08:34 <dfeuer> Huh. OK....
22:08:40 <edwardk> also an array of structures has to work in the pointer model rather than the oblivious model
22:08:52 <edwardk> but that is another very very tangential concern
22:09:11 <edwardk> its just 'in practice, AoS will almost always lose'
22:09:28 <edwardk> and it further complicates unboxing, etc.
22:09:32 <edwardk> hence the design of vector
22:09:32 <dfeuer> Got it.
22:10:00 <dfeuer> I guess you could make your own magic non-tearable pairs if you need to stuff those in?
22:10:00 <edwardk> anyways vector/dph/etc were the original motivation for the feature
22:10:08 <dfeuer> OK, go on.
22:10:08 <edwardk> yeah
22:11:38 <dfeuer> So I mentioned flipping, and you wrote a type family declaration that made people gasp ....
22:11:48 <dfeuer> And then you gave a little deep background.
22:12:16 <dfeuer> And now I'm not sure if I need more background, or if we can go back to where we started.
22:12:23 <edwardk> well, if we go back to where we started
22:12:32 <edwardk> we can write a type family that abuses another newish language feature, polykinds
22:12:42 <edwardk> type family (~>) :: i -> i -> *
22:12:48 <edwardk> notice we have variables in our kinds now
22:12:51 <dfeuer> OK, so that's more background.
22:12:59 <dfeuer> What are polykinds?
22:13:02 <edwardk> you need TypeFamilies, TypeOperators and PolyKinds turned on for that
22:13:14 <edwardk> dfeuer: http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
22:13:19 <edwardk> that was the paper where they were introduced
22:13:26 <edwardk> but the idea is to allow variables in kinds
22:13:37 <edwardk> there are some times when the kind of something is underdetermined
22:13:37 <spott> is there a function that takes a list like [1,2,3,4,5,6] and gives [[1,2],[2,3],[3,4],[4,5],[5,6]]?
22:13:43 <edwardk> newtype Const a b = Const a
22:13:48 <edwardk> what is the kind of the second argument and why?
22:14:01 <edwardk> @let newtype Konst a b = Konst a
22:14:02 <lambdabot>  Defined.
22:14:03 <edwardk> :k Konst
22:14:04 <lambdabot> * -> * -> *
22:14:08 <edwardk> why did it pick * ?
22:14:11 <edwardk> it didn't have to
22:14:19 <edwardk> what if i had wanted Konst Int Maybe to work?
22:14:25 <edwardk> @undefine
22:14:25 <lambdabot> Undefined.
22:14:35 <edwardk> @let newtype Konst a (b :: * -> *) = Konst a
22:14:35 <lambdabot>  Defined.
22:14:40 <edwardk> :k Konst
22:14:41 <lambdabot> * -> (* -> *) -> *
22:14:44 <edwardk> that works just as well
22:14:48 <edwardk> why should i have to pick?
22:14:53 <edwardk> with PolyKinds turned on
22:15:02 <edwardk> the kind of Konst becomes :: * -> k -> *
22:15:08 <edwardk> the kind of the second argument is unselected
22:15:16 <edwardk> and can be picked at each use-site
22:15:17 <dfeuer> OK, so that makes sense internally,
22:15:46 <dfeuer> but what's a simple situation where you would use such a thing (external sense)?
22:15:57 <edwardk> basically GHC was picking too-specific of a kind and making you do work to ask for a different kind, and more annoyingly making you write separate types for every kind you want
22:16:01 <benzrf> :k (~)
22:16:02 <lambdabot> k -> k -> Constraint
22:16:14 <benzrf> (~) already has a polykind...?
22:16:17 <edwardk> yep
22:16:28 <edwardk> (~) was polykinded before we had them elsewhere basically
22:16:56 <platz> that example looks like it gives you a phantom type "on steroids"
22:16:56 <spott> what is (~)?
22:17:02 <spott> :t (k)
22:17:02 <edwardk> usecases are things like
22:17:03 <lambdabot> Expr
22:17:34 <edwardk> newtype a == b = Eq { subst :: forall f. f a -> f b }
22:17:59 <edwardk> you can use (==) there at any kind for a and b as long as they both agree.
22:18:27 <edwardk> since you know nothing about f the only inhabitants that aren't hinky look like Eq id :: a == a
22:18:36 <edwardk> id :: f a -> f a -- works fine
22:18:45 <edwardk> now you can write a Category instance for (==), etc.
22:18:50 <dfeuer> Wait, hold a second.
22:18:56 <edwardk> that is a fun exercise. (==) is 'leibnizian equality'
22:18:57 <dfeuer> I'm still trying to figure out that ==.
22:19:30 <edwardk> dfeuer: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.193.1552&rep=rep1&type=pdf introduced me to the topic
22:19:31 <platz> spott: https://www.haskell.org/ghc/docs/latest/html/users_guide/equality-constraints.html
22:20:18 <spott> platz: thanks!
22:20:19 <edwardk> dfeuer: you can have Maybe == Maybe  -- or [] == f,     or Int == a,   etc.
22:20:25 <dfeuer> Oh, I was wondering how you could make an inhabitant, and then I got to your third sentence.
22:20:59 <edwardk> @let newtype a == b = Eq { subst :: forall f. f a -> f b }
22:21:00 <lambdabot>  Defined.
22:21:04 <edwardk> :k (==)
22:21:05 <lambdabot> * -> * -> *
22:21:13 <edwardk> damnit lambdabot, turn on polykinds ;)
22:21:20 <edwardk> that should be k -> k -> *
22:22:02 <edwardk> @let instance Category (==) where id = Eq id; (.) = subst
22:22:03 <lambdabot>  .L.hs:153:15:
22:22:03 <lambdabot>      Ambiguous occurrence ‘subst’
22:22:03 <lambdabot>      It could refer to either ‘L.subst’, defined at .L.hs:149:23
22:22:03 <lambdabot>                            or ‘Sym.subst’,
22:22:03 <lambdabot>                               imported from ‘Data.Number.Symbolic’ at .L.hs:9...
22:22:10 <edwardk> @let instance Category (==) where id = Eq id; (.) = L.subst
22:22:11 <lambdabot>  Defined.
22:22:33 <edwardk> the use of subst there is subtle ;)
22:22:43 <dfeuer> What is L?
22:22:55 <edwardk> (.) :: (b == c) -> (a == b) -> a == c
22:23:06 <edwardk> L is the module lambdabot puts local definitions in
22:23:34 <dfeuer> @type (.)
22:23:35 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:23:48 <edwardk> @type (Control.Category..)
22:23:49 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
22:24:37 * hackagebot influxdb 0.5.0 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.5.0 (MitsutoshiAoe)
22:25:40 <dfeuer> I wonder how lambdabot figured out which (.) you meant, but I will try to just keep paying attention. The == type only has sensible (non- const undefined) inhabitants where subst = id.
22:26:04 <dfeuer> And Eq id  will only typecheck if a is the same type as b?
22:26:32 <dfeuer> Or if a can be unified with b?
22:26:35 <edwardk> well, if we know that a == b   and that b == c, then if we use subst from the latter, it can turn f b into f c
22:26:40 <edwardk> so we choose f = (a ==)
22:26:48 <edwardk> and now (a ==) b   becomes (a ==) c
22:26:52 <edwardk> hence why (.) worked there
22:27:09 <edwardk> writing code to do leibnizian equality is a fun exercise
22:27:27 <edwardk> its a bit boring because we can work better with type equalities directly
22:27:47 <edwardk> data (==) :: k -> k -> * where Refl :: a == a; instance Category (==) where id = Refl; Refl . Refl = Refl
22:27:58 <edwardk> that doesn't require you to be clever
22:28:22 <dfeuer> I'm not sure what Leibnizian equality *is*, but ... you're looking at it at another kind. OK.
22:28:48 <dfeuer> So you're saying that id will work and that (.) will work too? OR am I confused again?
22:29:37 <edwardk> i was just showing two different notions of equality you can use
22:29:37 * hackagebot masakazu-bot 0.2.0.0 - @minamiyama1994_bot on haskell  http://hackage.haskell.org/package/masakazu-bot-0.2.0.0 (minamiyama1994)
22:29:43 <edwardk> both of which work fine with polykinds
22:30:04 <edwardk> Maybe == a  -- works perfectly fine, as does Int == a;   and there should be no sane inhabitants of Int == Double, etc.
22:31:06 <edwardk> ok, so we can have kind variables
22:31:33 <edwardk> type family (~>) :: i -> i -> *  -- has a kind variable in the result, the only way that can work is if this is secretly also a function of some type variable
22:31:50 <edwardk> that way the right hand side is selected by the _kind_ of i.
22:31:59 <dfeuer> Hold on and let me read that.
22:32:06 <edwardk> type instance (~>) = (->)    -- we know (->) :: * -> * -> *
22:32:13 <edwardk> so when i = *, that picks the right hand side
22:32:20 <edwardk> we can have other type instances for that
22:32:22 <edwardk> k
22:32:43 <edwardk> er "secretly also a function of some kind variable"
22:32:51 <edwardk> the kind variable i in that declaration
22:32:57 <dfeuer> Wait.
22:33:24 <enthropy> is ~> in a library?
22:34:03 <edwardk> enthropy: github.com/ekmett/hask  look in Hask/Core
22:34:18 <enthropy> thanks
22:34:35 <edwardk> https://github.com/ekmett/hask/blob/master/src/Hask/Core.hs#L238
22:34:47 <edwardk> the 'real' definition is Hom a few lines up, but i'm doing the simplified form
22:34:51 <dfeuer> What do you mean by "secretly also a function of some type variable"?   (~>) is a type function from something of kind i and another thing of kind i to a concrete type, right?
22:35:20 <edwardk> [01:30]  edwardk:	 er "secretly also a function of some kind variable"
22:35:27 <edwardk> i was correcting it when you shushed me ;)
22:35:39 <edwardk> [01:30]  edwardk:	 the kind variable i in that declaration
22:35:52 <dfeuer> Yeah, your brain is very fast....
22:36:24 <edwardk> nah, mostly just spent a lot of time playing with this stuff, familiarity, etc.
22:36:38 <edwardk> so (~>)  is basically a function from the kind i  to a type of that kind
22:36:44 <edwardk> er to a type of kind i -> i -> *
22:37:13 <dfeuer> So   type instance (~>) = (->)   really means   type instance (~>) a b = a -> b
22:37:17 <dfeuer> ?
22:37:24 <edwardk> no
22:37:27 <dfeuer> OK.
22:37:53 <edwardk> type instance (~>) = (->)      is really saying that type instance (~>) { i } = ( (->) :: i -> i -> *) -- but there is no syntax to show that i is a parameter on the left
22:37:56 <edwardk> it just gets implied
22:38:24 <edwardk> and why i keep rushing ahead is i keep trying to give you some other instance you can see
22:38:27 <enthropy> I think you can put a kind signature in there
22:38:38 <edwardk> enthropy: there isn't an argument to put it _on_
22:38:52 <edwardk> enthropy: you can put type family (~>) :: i -> i -> *
22:39:05 <edwardk> i'm just saying what that means
22:39:53 <edwardk> type instance (~>) = (->)    -- is "like" we're saying type instance (~>) { * } = (->) :: * -> * -> *  -- but the { } nonsense is made up syntax
22:40:01 <dfeuer> I'm just struggling to see how this definition relates to things like  type instance NotReallyAn Int = Char
22:40:17 <edwardk> pretend i can pass kinds like regular type arguments
22:40:23 <edwardk> type instance (~>) i :: i -> i -> *
22:40:30 <edwardk> type instance (->) * = (->)
22:40:48 <edwardk> but kind arguments aren't explicit, they are handled for you
22:40:57 <edwardk> we can make another instance
22:41:02 <dfeuer> OK .....
22:41:22 <edwardk> newtype Nat f g = Nat { runNat :: forall a. f a ~> f b };  Nat :: (i -> j) -> (i -> j) -> *
22:41:35 <edwardk> type instance (~>) (i -> j) = Nat
22:41:40 <edwardk> but the (i -> j) there is implied
22:41:46 <edwardk> type instance (~>) = Nat
22:42:10 <dfeuer> WTF is b?
22:42:22 <edwardk> b is a typo because i went fast
22:42:29 <dfeuer> Oh.
22:42:39 <edwardk> newtype Nat f g = Nat { runNat :: forall a. f a ~> g a }
22:42:44 <dfeuer> I was hoping so, but figured it was probably another concept I didn't understand.
22:43:03 <edwardk> i was conflating Nat and Leibnizian equality becuase i'd just done the other
22:43:44 <edwardk> @let newtype Nat f g = Nat { runNat :: forall a. f a -> g a }
22:43:45 <lambdabot>  Defined.
22:43:54 <edwardk> -- lambdabot doesn't have polykinds so i can't use (~?)
22:43:56 <edwardk> er (~>)
22:44:00 <edwardk> :k Nat
22:44:01 <lambdabot> (* -> *) -> (* -> *) -> *
22:44:15 <edwardk> with polykinds and using (~>) that becomes (i -> j) -> (i -> j) -> *
22:44:39 * hackagebot influxdb 0.5.1 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.5.1 (MitsutoshiAoe)
22:45:01 <edwardk> so (~>) is basically 'an arrow type that is entirely determined by its kind'
22:45:17 <edwardk> (->) is what (~>) means when its arguments have kind *
22:45:43 <edwardk> Nat is what (~>) means when its arguments have kind (i -> j)
22:45:47 <dfeuer> I'm still trying to understand what the kind signature for polykinded Nat means.
22:46:19 <edwardk> Nat lets us sort of inductively work with (i -> *) -> (i -> *) -> *   or (i -> j -> *) -> (i -> j -> *) -> *
22:46:20 <dfeuer> Is Nat supposed to represent a natural transformation or some such category-theoretic thing?
22:46:21 <edwardk> etc.
22:46:23 <edwardk> yeah
22:46:32 <edwardk> :t listToMaybe
22:46:33 <lambdabot> [a] -> Maybe a
22:46:37 <edwardk> :t Nat listToMaybe
22:46:38 <lambdabot> Nat [] Maybe
22:46:51 <dfeuer> I don't quite know what those are yet. I think I *almost* understand what a functor is, on a good day.
22:46:57 <edwardk> with the stuff above you can write that as [] ~> Maybe
22:48:06 <dfeuer> Go on?
22:48:10 <dfeuer> I guess?
22:48:31 <jle`> :t Nat id
22:48:32 <lambdabot> Nat f f
22:48:53 <jle`> :t Nat (return . runIdentity)
22:48:54 <lambdabot> Monad g => Nat Identity g
22:49:08 <jle`> :t Nat (return . extract)
22:49:09 <lambdabot> Not in scope: ‘extract’
22:49:11 <dfeuer> :t runIdentity
22:49:12 <jle`> boo
22:49:12 <lambdabot> Identity a -> a
22:49:29 <edwardk> :t Nat (Identity . Control.Comonad.extract)
22:49:30 <lambdabot> Control.Comonad.Comonad f => Nat f Identity
22:49:42 <jle`> :t Nat (return . Control.Comonad.extract)
22:49:44 <lambdabot> (Control.Comonad.Comonad f, Monad g) => Nat f g
22:49:49 <dfeuer> Y'all are just  making fun of me now.
22:50:25 <edwardk> :t Nat (join . Data.Functor.Compose.getCompose)
22:50:26 <lambdabot> Monad g => Nat (Data.Functor.Compose.Compose g g) g
22:50:30 <edwardk> dfeuer: no
22:50:41 <dfeuer> Oh good.
22:50:44 <edwardk> these are just functions that take f a    to g a   for some f and g
22:50:48 <jle`> no :) just wanted to try things out
22:50:57 <dfeuer> Yeah, but I have no idea what any of those are.
22:51:00 <edwardk> jle tried a few so i figured i'd show him a couple others
22:51:03 <edwardk> :t listToMaybe
22:51:05 <lambdabot> [a] -> Maybe a
22:51:05 <dfeuer> Aside from return.
22:51:09 <edwardk> > listToMaybe [1,2,3]
22:51:13 <lambdabot>  Just 1
22:51:14 <edwardk> > listToMaybe []
22:51:16 <lambdabot>  Nothing
22:51:19 <edwardk> -- that is 'safeHead' basically
22:51:24 <jle`> dfeuer: they are just various functions (f a -> a) and (a -> f a) and (f a -> g a)
22:51:43 <edwardk> Nat listToMaybe -- is that function 'bottled up with the fact that it doesn't care about the type of the argument'
22:51:43 <jle`> extract is Comonad w => w a -> a
22:51:53 <dfeuer> OK.
22:52:17 <edwardk> since Nat needs both arguments to have kind * -> * here by putting a in Identity then those have the right 'shape' to fit in Nat
22:52:28 <edwardk> :t return . runIdentity
22:52:29 <lambdabot> Monad m => Identity b -> m b
22:52:30 <dfeuer> I'm sure a comonad is dual to a monad, but what that means I don't have a clue. NEXT.
22:52:36 <edwardk> :t Nat (return . runIdentity)
22:52:37 <lambdabot> Monad g => Nat Identity g
22:52:47 <jle`> dfeuer: don't worry...that part isn't important
22:52:51 <jle`> the ony thing that it's a w a -> a
22:53:00 <dfeuer> OK.
22:53:00 <jle`> that it 'doesn't care' about the a
22:53:09 <edwardk> :t Nat (Identity . snd)
22:53:10 <jle`> i could make a random type and a random function MyType a -> a
22:53:11 <lambdabot> Nat ((,) a) Identity
22:53:19 <dfeuer> What is a natural transformation (roughly)?
22:53:29 <dfeuer> That one might be helpful....
22:53:54 <jle`> (Functor f, Functor g) => f a -> g a, that works for all a's...that preserves id and composition
22:53:55 <edwardk> dfeuer: a natural transformation foo :: takes f a -> g a   for all a. in such a way that the answer doesn't change based on a and in general foo . fmap f = fmap f . foo
22:54:23 <edwardk> foo . fmap f = fmap f . foo   is the key part
22:54:38 <jle`> > listToMaybe . fmap (*2) $ [1,2,3]
22:54:40 <lambdabot>  Just 2
22:54:47 <jle`> > fmap (*2) . listToMaybe $ [1,2,3]
22:54:49 <lambdabot>  Just 2
22:54:50 <edwardk> @free foo :: [a] -> Maybe a
22:54:50 <lambdabot> $map_Maybe f . foo = foo . $map f
22:55:09 <edwardk> that is saying that holds just given the type '[a] -> Maybe a'
22:55:19 <edwardk> @free foo :: [a] -> [a]
22:55:19 <lambdabot> $map f . foo = foo . $map f
22:55:31 <jle`> 'for any function of type [a] -> Maybe a, this fact has to hold.'
22:55:45 <jle`> 'you can't implement any function of type [a] -> Maybe a that this isn't true for.'
22:55:52 <jle`> 'i dare you to try.'
22:55:54 <jle`> -- free
22:56:54 <dfeuer> o.O
22:57:11 <jle`> except for bottom of course
22:57:20 <dfeuer> :(
22:57:25 <jle`> go ahead...try to implement something of type [a] -> Maybe a
22:57:35 <jle`> where fmap (*2) . foo =/= foo . fmap (*2)
22:58:26 <edwardk> jle`: and both terminate ;)
22:58:38 <jle`> heh. yeah >_>
22:58:42 <jle`> an important condition
22:58:57 <jle`> although of both do not terminate then i guess they are still equal...?
22:59:00 <jle`> *if
22:59:01 <dfeuer> I'm trying to see how to break it by not terminating.
22:59:09 <dfeuer> I know some things can break that way.
22:59:15 <begriffs> What's the best way to grab the version (2) out of an accept header in Haskell (application/json+me.com; version=2)? A regex or parsec or something?
22:59:24 <jle`> usually when we talk about free theorems we exclude non-terminating implementations
23:00:29 <dfeuer> Something like   foo l = if even (length l) then undefined else head l   ?
23:01:01 <dfeuer> No, that doesn't work.
23:01:07 <johnw> free theorems (with a catch)
23:01:50 <dfeuer> Anyway ....
23:02:46 <dfeuer> So roughly speaking these natural transformations pay attention to structure and not contents, or something.
23:03:02 <dfeuer> So now I've lost track of where we were.
23:03:39 <dfeuer> <edwardk> so (~>) is basically 'an arrow type that is entirely determined by its kind'
23:03:39 <dfeuer> <edwardk> (->) is what (~>) means when its arguments have kind *
23:03:39 <dfeuer> <edwardk> Nat is what (~>) means when its arguments have kind (i -> j)
23:03:39 <dfeuer> <dfeuer> I'm still trying to understand what the kind signature for polykinded Nat means.
23:03:39 <dfeuer> * spott (~spott@c-76-120-73-233.hsd1.co.comcast.net) has joined #haskell
23:03:39 <dfeuer> <edwardk> Nat lets us sort of inductively work with (i -> *) -> (i -> *) -> *   or (i -> j -> *) -> (i -> j -> *) -> *
23:04:47 <edwardk> dfeuer: there is a notion that 'fast and loose reasoning is morally correct'
23:05:08 <dfeuer> Oh?
23:05:19 <edwardk> dfeuer: the not terminating thing is something you can basically forget while working, because you can show that in a wold where everything terminates and error / bottom don't exist you can reason very easily, right?
23:05:27 <ReinH> @google fast and loose reasoning
23:05:27 <lambdabot> http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html
23:05:28 <lambdabot> Title: Fast and Loose Reasoning is Morally Correct
23:05:39 <edwardk> but if you take code written for that world and run it in a world where they do, _and both terminate_ you get the same result.
23:05:47 <edwardk> so just reason as if these bad things aren't there
23:05:54 <edwardk> because it buys you nothing
23:06:06 <edwardk> pretend nobody would bother to spin forever
23:06:12 <edwardk> and you can reason about your code in this nice world
23:06:18 <edwardk> and it still does the right thing in the real world
23:06:23 <dfeuer> Yes, edwardk.
23:06:28 <ReinH> at the very least it won't do any worse
23:06:55 <dfeuer> That's an interesting way to put it.
23:07:21 <edwardk> parametricity + fast and loose reasoning are a remarkably fast and effective way to reason about code
23:08:29 <dfeuer> Once one has a formal, as well as informal, understanding of parametricity....  I think I understand some informal stuff, but I'd never have come up with anything like fmap f . foo = foo . fmap f
23:10:15 <edwardk> dfeuer: think of it for listToMaybe
23:10:22 <edwardk> it doesn't matter if you fmap first or after.
23:10:31 <dfeuer> Right.
23:10:35 <edwardk> @free head :: [a] -> a
23:10:36 <lambdabot> f . head = head . $map f
23:10:45 <edwardk> here we don't care if you apply the function after or if you fmap first
23:11:00 <edwardk> free theorems are powerful tools
23:11:01 <dfeuer> Oh, I understand the concept, I think, but the details I don't know.
23:11:10 <dfeuer> I understand why that theorem comes about,
23:11:19 <dfeuer> but not how free theorems in general are derived.
23:11:29 <edwardk> free theorems are one of those things that wadler wrote up that changed the world ;)
23:11:57 <edwardk> I believe he phrased it 'tell me a type and i will tell you a theorem that holds for all functions of that type'
23:12:09 <dfeuer> If you have a list of things and you don't know what kind they are and you need to return one, you have to pick one and you can only do it by the position in the list.
23:12:24 <edwardk> exactly
23:13:18 <dfeuer> That's an informal understanding, I know. I'd never have thought to phrase it as f . head = head . map f
23:13:19 <poseidons-minion> is there any kind of load balacer done in haskell?
23:14:05 <solidus-river> hmm, i want to map a function over a list of elements and get the element for which the function returns the minimum value
23:14:23 <solidus-river> is there a slick way to do that with list comprehensions or a map
23:14:28 <edwardk> dfeuer: the main nice thing about having it in equational form is you can use it to rewrite your code
23:14:28 <solidus-river> wait, i think thats just a list comprehension
23:14:29 <dfeuer> Yes, poseidons-minion. Haskell doesn't really have much of a sense of *time*, so whether there *was* a load balancer, *is* a load balancer, or *will be* a load balancer is immaterial.
23:14:46 <edwardk> obviously f . head will be cheaper, so its probably best to rewrite the latter into the former, etc.
23:15:21 <dfeuer> Obviously? Why is that obvious?
23:15:47 <dfeuer> (Well, it's obvious that it's cheaper in ML or something, but why in Haskell?)
23:16:07 <poseidons-minion> hm
23:16:12 <redtricycle> How do I do I get a String to a rounded float?
23:16:32 <redtricycle> For example, I have "0.96650000000000" and I want 0.97
23:16:36 <redtricycle> Actually, String->String is find
23:16:42 <edwardk> dfeuer: well, ok, for an ML like language, for haskell it may not matter
23:16:45 <redtricycle> "0.966500000" to "0.97"
23:17:05 <edwardk> but given just the type you don't know that head doesn't look 1000 elements down the list
23:17:14 <ReinH> :t minimumBy
23:17:15 <lambdabot> (a -> a -> Ordering) -> [a] -> a
23:17:19 <edwardk> but you know f . head  -- will do only one bit of work for f
23:17:20 <dfeuer> redtricycle, you've reduced your problem to string processing! Great! What's the next step?
23:17:20 <ReinH> solidus-river: ^
23:17:54 <redtricycle> dfeuer: I'm cleaning up entries for ledger-cli
23:18:07 <redtricycle> so getting hat into an account, i.e. Expenses:Apples  0.97
23:18:11 <redtricycle> that*
23:18:20 <redtricycle> and then appending it to a text file
23:18:22 <redtricycle> is that what you mean?
23:18:32 <ReinH> read it as a double, do your rounding, show it as a string?
23:18:44 <jle`> solidus-river: more specifically, minimumBy (comparing f)
23:18:50 <poseidons-minion> is there anything like hadoop done in haskell for like a bigtable multi node db with unified query space?
23:19:10 <edwardk> dfeuer: the trick is that by saying (~>) can be one of these different things picked entirely by the kinds involved, i can write a weird Functor. class Functor f where fmap :: (a ~> b) -> f a ~> f b;; so now if f :: * -> *  that is (a -> b) -> f a -> f b like you're used to
23:19:11 <dfeuer> head . fmap f   can't either, edwardk, because  fmap (const 1) . fmap (const undefined) = fmap (const 1 . const undefined) = fmap (const 1)
23:19:22 <begriffs> How is maybeRead defined only in Network.CGI.Protocol? Seems like a marginal place for a seemingly generic and useful function.
23:19:36 <edwardk> but if f :: * -> * -> *   then fmap :: (a -> b) -> Nat (f a) (f b)
23:19:45 <joelteon> :t reads -- begriffs
23:19:46 <lambdabot> Read a => ReadS a
23:19:52 <joelteon> oh, that's not helpful is it
23:20:03 <redtricycle> ReinH: which of these reads it as a double? http://www.haskell.org/hoogle/?hoogle=String->Double
23:20:05 <dv-> :t Text.Read.readMaybe
23:20:06 <lambdabot> Read a => String -> Maybe a
23:20:24 <ReinH> > read "0.9550" :: Double
23:20:25 <dfeuer> Oh, this is not the normal Functor, but your own Functor. Reparsing.
23:20:25 <lambdabot>  0.955
23:20:25 <joelteon> type ReadS a = String -> [(a, String)]
23:20:26 <kazagistar> solidus-river: foldl1' min? why do you want map?
23:20:32 <redtricycle> ah
23:20:32 <ReinH> readMaybe is more safe
23:20:35 <edwardk> dfeuer: you have to pay for 'pushing the f down' as you walk through the list, if you go 1000 entries deep you have to push the 'this is a list resulting from fmap f' fact down deeper and deeper.
23:20:38 <joelteon> > Text.Read.readMaybe "0.9550" :: Maybe Double
23:20:39 <lambdabot>  Not in scope: ‘Text.Read.readMaybe’
23:20:42 <joelteon> oops
23:20:51 <edwardk> dfeuer: for head it doesn't matter. for last you can probably benchmark a difference
23:21:07 <edwardk> just because walkin down the list pays a couple of thunks worth of work each step now
23:21:11 <jle`> wait, is Text.Read in base?
23:21:15 <jle`> o
23:21:20 <jle`> i've been using reads this whole time
23:21:23 <solidus-river> hmm, is it better to use minimum by or foldl' min
23:21:31 <dfeuer> edwardk, I don't know the implementation details. I just meant that it can't touch anything but the one it needs.
23:21:39 <dfeuer> I believe you though.
23:21:52 <begriffs> dv-: how did hoogle overlook the result in Text.Read? http://www.haskell.org/hoogle/?hoogle=Read+a+%3D%3E+String+-%3E+Maybe+a
23:22:01 <solidus-river> * minimumBy
23:22:30 <solidus-river> oh minimumBy isn't a standard function from prelude, that makes that decision easy
23:22:43 <begriffs> I feel like I'm using hoogle wrong.
23:23:18 <dfeuer> edwardk, what was the definition of ~> again?
23:23:26 <jle`> :t Nat (flip runReaderT mempty)
23:23:27 <lambdabot> Monoid b => Nat (ReaderT b g) g
23:23:27 <ReinH> solidus-river: doing it yourself will involve a schwartzian transform worker/wrapper thing
23:23:39 <edwardk> dfeuer: fmap f (x:xs) = f x : fmap f xs; fmap f [] = []  -- notice how fmap is recursive?  so if i call last [x] = x; last (x:xs) = last xs; last [] = error "last: empty list"     on last (fmap f [1,2,3,4]) that is going to first compute last (f 1:fmap f [2,3,4]) -- pushing an unresolved f 1 in as the first arg, which we _then_ ignore, and go to the next step
23:23:46 <jle`> solidus-river: minimumBy is in base
23:23:52 <edwardk> so every step is 'get through one step of the fmap then one step of 'last'
23:24:06 <edwardk> over and over until last finally gives you 'f 4'
23:24:09 <edwardk> and you do the work for f once.
23:24:18 <dfeuer> *nod*
23:24:19 <edwardk> you still did twice as much work while walking to the last element
23:24:39 <edwardk> if you fmap n times over a list of n elements, you pay O(n^2) to access the last element
23:24:46 <edwardk> so be careful ;)
23:25:54 <dfeuer> Ew.
23:25:55 <edwardk> dfeuer: type family (~>) :: i -> i -> *; type instance (~>) = (->); type instance (~>) = Nat
23:26:34 <dfeuer> Oh yes, with those insane hidden arguments...
23:26:40 <edwardk> dfeuer: yeah
23:27:08 <edwardk> now give me a kind made out of (i -> j) that terminates with a * on the right hand side and that type family can make an arrow for it
23:27:36 <edwardk> (i -> j -> *)    uses Nat to get (i -> x)   and then another Nat for x = j -> *
23:28:06 <edwardk> Nat $ Nat $ ...   can be used to work under 2 arguments
23:28:25 <jle`> :t Nat (return . ($ mempty))
23:28:25 <lambdabot> (Monoid a, Monad g) => Nat ((->) a) g
23:28:31 <jle`> sorry i'm just having too much fun with this
23:28:31 <edwardk> anyways the punchline of this to make it relevant to your original question
23:28:48 <edwardk> instance Functor Either -- notice its not Functor (Either a)
23:28:50 <edwardk> we can have both
23:29:17 <edwardk> instance Functor Either where fmap f = Nat $ \case Left a -> Left (f a); Right b -> Right b
23:29:49 <edwardk> instance Functor (Either a) where fmap f = \case Left a -> Left a; Right b -> Right (f b)
23:29:54 <dfeuer> So your funky Functor represents, I'm guessing, not only functors in Hask but also in some derived category?
23:29:58 <dfeuer> Or something?
23:30:00 <edwardk> yeah
23:30:11 <jle`> :t \x -> Nat (const . ($ x))
23:30:12 <lambdabot> a -> Nat ((->) a) ((->) b)
23:30:19 <edwardk> now runNat . fmap :: (a ~> b) -> f a c ~> f b c
23:30:26 <edwardk> can work over the first argument of a bifunctor, etc.
23:30:39 <dfeuer> Whatever a bifunctor may be.
23:30:49 <edwardk> i can work over other arguments than the last one
23:30:56 <edwardk> thats all i'm getting at
23:31:18 <edwardk> runNat . runNat . fmap :: (a ~> b) -> f a c d -> f b c d
23:31:45 <edwardk> (er all of those assume "Functor f"
23:32:21 <edwardk> so you asked is it possible to write an instance that works 'flipped' on (->)     we can. we can write that (->) is contravariant and that (->) a  is a Functor by using the crazy machinery above
23:32:25 <dfeuer> I'm still looking at that Either thing.
23:33:07 <dfeuer> And wondering if that f is supposed to be missing on the far right end of instance Functor Either where
23:34:40 <dfeuer> I don't know what "contravariant" means either. Is that a functor f that takes a morphism a->b to a morphism f b -> f a  or something? I'm babbling now....
23:34:40 <edwardk> dfeuer: the f is being applied on Left not Right there
23:34:52 <edwardk> dfeuer: that is exactly what it is
23:34:56 <edwardk> :t contramap
23:34:57 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
23:35:02 <edwardk> :t fmap
23:35:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:35:14 <ReinH> dfeuer: boom
23:36:25 <edwardk> instance Functor Either where fmap f = Nat $ \case Left a -> Left (f a); Right b -> Right b -- lets you peel off the Nat with runNat and get that definition, picked by the kinds involved. vs. 	 instance Functor (Either a) where fmap f = \case Left a -> Left a; Right b -> Right (f b)
23:36:27 <edwardk> so
23:36:34 <edwardk> runNat . fmap  works over the left arg of Either
23:36:41 <edwardk> fmap works over the right arg as usual
23:37:20 <edwardk> and with that i declaw the arguments that somehow scala is more flexible because you can be functorial in any argument you want
23:37:30 <dfeuer> I think my eyes have taken in more than my brain can process today.
23:37:31 <edwardk> because we can do it in haskell and still reason about the code
23:37:44 <dfeuer> I will have to try to re-read a lot of this tomorrow in logs.
23:38:03 <edwardk> dfeuer: np. i realized after i started that i was going to have to rewind a lot, and that perhaps i was being ambitious, but you've held up remarkably well =)
23:38:14 <dfeuer> Well, I've picked up some bits and pieces.
23:38:19 <dfeuer> Reading back over and over.
23:38:20 <edwardk> and i hope other folks have gotten something out of this as well
23:38:36 <dfeuer> Still very confused about most of it, but it seems pretty cool, for the most part.
23:38:50 <edwardk> i gave a talk on this last night at boston haskell, so there will be video up soon, but i went way way faster there
23:38:59 <kazagistar> I got "logs to reread when I am more awake" out of it, so that is something
23:39:18 <edwardk> my goal was mostly to say 'yes the crazy thing you asked for is possible' if not exactly the way you imagined it
23:39:43 <edwardk> normally i'd just say 'type level flip can't work', but it _almost_ does here ;)
23:39:44 <dfeuer> It's interesting how Haskell's type system seems to grow in large part by someone adding a little extension for some purpose and then someone else like you or Oleg realizing that the little extension is way more powerful than it looks.
23:40:15 <dfeuer> I still have no clue what Either has to do with flipping (->)
23:40:27 <edwardk> well, Either is easier than dealing with contravariance =P
23:40:30 <edwardk> but we can define
23:40:47 <edwardk> class Contravariant f where contramap :: (a ~> b) -> f b ~> f a -- the same way
23:40:51 <edwardk> and now we can define
23:41:08 <edwardk> instance Contravariant (->) where fmap = flip (.)
23:41:10 <edwardk> er
23:41:46 <edwardk> instance Contravariant (->) where contramap f = Nat (. f)
23:42:02 <dfeuer> Whaaaaat?
23:42:11 <edwardk> instance Functor ((->) e) where
23:42:11 <edwardk>   fmap = (.)
23:42:32 <edwardk> and now (->) is noted as contravariant in its first argument and covariant in its second argument
23:43:04 <edwardk> runNat . contramap :: (a -> b) -> (b -> c) -> (a -> c)
23:43:39 <edwardk> and runNat let us get up there and contramap over the first arg rather than the second
23:44:00 <kazagistar> edwardk: is this the same  or similar covariance/contravariance I am vaugely familar with from "problems when doing OOP"?
23:44:00 <ReinH> And for anyone else, mark the timestamp and you can find the logs in the /topic
23:44:02 <edwardk> we can go very very far down this rabbit hole
23:44:06 <ReinH> s/mark/make note of
23:44:06 <edwardk> kazagistar: yes
23:44:10 <dfeuer> Uh .... good night, edwardk. And thank you.
23:44:20 <dfeuer> And yes, I'll have to reread later.
23:45:07 <zRecursive> What's the diff bwtween GADT and ordinary ADT ?
23:45:22 * relrod has to re-read a bunch of this too. There are occasional moments when I realize that I know nothing. Trying to follow this conversation has led me to one of those times.
23:45:50 <ReinH> zRecursive: one is more G!
23:46:00 <zRecursive> ?
23:46:03 <edwardk> relrod: to be fair this is something i only realized we could do a few weeks ago ;)
23:46:11 <edwardk> relrod: so i'm still dealing with all the implications myself
23:46:24 <ReinH> zRecursive: GADTs let you specify the types of the constructors.
23:46:33 <ReinH> zRecursive: http://en.wikibooks.org/wiki/Haskell/GADT
23:46:49 <relrod> edwardk: (I am scared to ask, but) how did you come to realize it?
23:46:58 <zRecursive> ReinH: thanks
23:47:07 <edwardk> relrod: i started building a small library to work with generalized lenses
23:47:14 <edwardk> i wanted lenses that worked on other categories
23:47:15 <kazagistar> knowing nothing is a silly term, it takes quite a lot of knowlege to realize that haskell is not just another vxjunkies
23:47:17 <ReinH> relrod: probably reading Mac Lane repeatedly until it sunk in ;)
23:47:33 <edwardk> but it turned out verbose. i showed it to sjoerd_visscher at zurihac and he got excited about it
23:47:42 <edwardk> then i realized i was only ever really using one category per kind
23:47:47 <ReinH> edwardk: so I found out that the Codensity trick was an exercise in CftWM
23:47:49 <ReinH> hilarious
23:47:55 <dfeuer> CftWM?
23:47:56 <edwardk> so i decided to try to make it feel a lot simpler by limiting myself in that way
23:48:03 <edwardk> ReinH: Yep!
23:48:08 <ReinH> dfeuer: Categories for the Working Mathematician by Saunders Mac Lane
23:48:12 <dfeuer> Ah.
23:48:13 <edwardk> ReinH: that is where i conjured the name from ;)
23:48:44 <edwardk> ReinH: you've made it far if you found that
23:48:52 <ReinH> "as an exercise, improve the asymptotic complexity of the free monad by accident"
23:48:58 <ReinH> edwardk: I've been skipping around
23:49:17 <ReinH> edwardk: I wanted to learn more about Kan extensions so
23:49:44 <edwardk> kan extensions in hask terms are really nice
23:50:20 <edwardk> class Curried p e | p -> e, e -> p where curried :: Iso' (p a b ~> c) (a ~> e b c)
23:50:39 <edwardk> instance Curried (,) (->) where curried = dimap curry uncurry
23:50:45 <edwardk> instance Curried Compose Ran where ...
23:50:47 <relrod> edwardk: I am in an interesting position because this stuff is so .. cool to me. Being able to come up with neat abstractions like that, and so on. But I am nowhere near being able to do that yet. I've been reading Lawvere but I am not even half way through yet (though I started skimming the first few pages of Awodey tonight and might switch over, it seems to cover things in much more detail.)
23:51:03 <relrod> I really want to learn to be able to do that though.
23:51:13 <ReinH> relrod: Lawvere is a good start, Awodey is definitely more thorough
23:51:31 <edwardk> being able to just 'curry' to go to the right kan extension is pretty sweet to me
23:51:40 <ReinH> relrod: if you're working through Awodey you might try Mac Lane but be prepared to run up against it a few times before it starts to stick
23:52:15 <relrod> ReinH: Yeah I think I'm not anywhere near being ready for that yet ;)
23:52:31 <ReinH> Awodey is good preparation for Mac Lane, I've found. Also so is... Mac Lane (his Algebra with Birkhoff is very approachable).
23:52:49 <edwardk> Reading Mac Lane is like bashing your head into the wall. Eventually it stops hurting but the whole time you are wondering why you are doing it and noting that you seem to be bleeding from the eyes.
23:53:03 <edwardk> If you make it through the other side there are all sorts of new vistas to explore.
23:53:08 <dfeuer> Which book by Awodey?
23:53:10 <ReinH> relrod: Mac Lane's Algebra gets you used to style and to thinking about algebraic things in a categorical way (more diagram chasing, less calculational, etc)
23:53:18 <ReinH> dfeuer: Category Theory
23:53:22 <dfeuer> And which one by Mac Lane?
23:53:31 <edwardk> Categories for the Working Mathematician
23:53:42 <ReinH> *to his style
23:53:47 <latk> I'm trying to use haskell-mode in emacs, with interactive-mode. Whenever I try to load an interactive session, I get a message "Searching for program: no such file or directory, cabal". I"m using cabal sanboxes.. any ideas ?
23:53:59 <edwardk> dfeuer: http://www.quora.com/Category-Theory/What-is-the-best-textbook-for-Category-theory?share=1
23:54:20 <ReinH> latk: check your exec-path and/or $PATH and try in #haskell-emacs because chrisdone is often in there :)
23:54:22 <dfeuer> OK.
23:54:39 <relrod> ReinH: hm, maybe that is what I need. I have no formal background in abstract algebra, everything I know has come from, well watching edwardk explain things, watching Tony Morris presentations, and reading random wikipedia/ncatlab articles and googling the heck out of anything I don't understand.
23:54:52 <ReinH> relrod: I'd definitely recommend Mac Lane's Algebra
23:55:28 <ReinH> relrod: also TheCatsters on youtube is a great channel
23:55:41 <relrod> yeah I've watched some of them
23:55:53 <ReinH> In fact I think I'm going to listen to her talk about ends while I fall asleep.
23:56:08 <latk> ReinH: Will checkout #haskell-emacs, cheers!
23:56:47 <relrod> edwardk: thank you for explaining stuff like this publicly btw. I very often find myself going through logs and learning things from your explainations. I owe you lunch at LJ next week. :)
23:56:50 <ReinH> latk: he's in Italy so it will be very early morning for him
23:57:06 <ReinH> relrod: oh hey, see you there :)
23:57:13 <relrod> ReinH: sweet!
23:57:53 <edwardk> relrod: np. i figured out a long time ago that if i just sit down and walk through things with someone who is interested the 'network effect' of it is pretty huge, so i'm generally happy to go through more or less anything with anyone who wants to learn it, especially in a broadcast medium where others can benefit
23:58:17 <edwardk> ReinH: the ends justify your means
23:58:30 <latk> ReinH: Ah,  ok. Will try in a few hours, then.
23:58:31 <ReinH> heh
23:59:11 <edwardk> And TheCatsters are awesome. Eugenia Cheng gives by far the clearest exposition on category theory I know and it is all in bite-sized 10 minute chunks
23:59:58 <edwardk> I recommend just jumping in somewhere in the series and when she says something you don't know just search for the video on that topic instead and keep going back until it makes sense
