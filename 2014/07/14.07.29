00:04:16 * hackagebot profunctors 4.2 - Profunctors  http://hackage.haskell.org/package/profunctors-4.2 (EdwardKmett)
00:06:43 <tommah>  im using Data.Complex and Math.Gamma............ how come when i try to compute
00:06:47 <tommah> gamma(1.0:+2.0)
00:06:49 <tommah> i get an error
00:06:52 <tommah> but when
00:06:53 <tommah> i do
00:06:58 <tommah> let a = 1.0:+2.0
00:07:00 <__jim__> does anyone have any experience capturing audio with haskell? I'm looking for a platform - independent library that comes with a recommendation
00:07:11 <tommah> i can compute
00:07:12 <tommah> Prelude Data.Complex Math.Gamma> gamma a
00:07:12 <tommah> 0.15190400267003626 :+ 1.980488016185506e-2
00:08:20 * hackagebot xml-pipe 0.0.0.5 - XML parser which uses simple-pipe  http://hackage.haskell.org/package/xml-pipe-0.0.0.5 (YoshikuniJujo)
00:08:20 * hackagebot profunctors 4.2 - Profunctors  http://hackage.haskell.org/package/profunctors-4.2 (EdwardKmett)
00:15:32 <int3__> estimating clock resolution...
00:15:32 <int3__> mean is 1.028802 us (640001 iterations)
00:15:32 <int3__> found 1120835 outliers among 639999 samples (175.1%)
00:15:40 <int3__> how is this even possible -_-
00:16:07 <pharaun> impressive
00:16:11 <solidus-river> is there a way to enforce a property of a type in haskell
00:16:45 <solidus-river> i want a LineSegment (V2 Double, V2 Double) where the V2's in the tuple are never equal
00:16:54 <solidus-river> is there a way to assure that through types
00:17:19 <int3__> solidus-river: I doubt it, that seems like a runtime assertion to me
00:17:32 <pyon> solidus-river: No, but you can enforce it using modules.
00:18:32 <pyon> solidus-river: Namely, (1) you hide the data constructor(s) for your LineSegment type, (2) you expose regular functions that serve as "pseudo-constructors", and these functions are guaranteed to enforce anything you want.
00:18:56 <solidus-river> pyon: int3__ thanks :)
00:19:01 <solidus-river> pyon: that sounds like a good idea
00:19:09 <jle`> kini: thanks! :)
00:19:52 <pyon> solidus-river: The downside is that you cannot pattern match on those pseudo-constructors. :-(
00:24:07 <int3__> pyon: solidus-river: but there are view patterns for that
00:24:51 <pyon> int3__: Ah, true!
00:24:52 <kini> jle`: I think your portrayal is a great way to motivate IO as a good thing rather than a bad thing to people who aren't "in on" haskell yet
00:32:09 <frerich> Does anybody know of examples which show how type algebra is useful for everyday Haskell programs (say: a web crawler)? mm_freak gave some nice examples recently about how symbol manipulations on equations allowed not only showing up that two types are equivalent but most interestingly, that an equivalent type had a more efficient representation in Haskell. I'm really curious whether there are more such examples.
00:32:59 <ion> Where are those examples? I’d like to take a look.
00:33:16 <frerich> mm_freak showed that a common type for lenses 'Lens (a -> b) (b -> a -> a)' is isomorph to 'Lens (a -> (b, b -> a))' but the latter allows more sharing.
00:34:09 <frerich> He did this by first doing a mechanical translation to type algebra ('Lens a b = b^a * (a^a)^b') and then just tinkering with distributivity and exponential laws and what else you learn at school to arrive at a new equation which mapped to the more efficient type.
00:34:26 <ion> ok
00:34:42 <frerich> It was the first time where I saw somebody actually showing a *benefit* of knowing about sum/product/exponentation types when writing Haskell programs.
00:34:58 <edwardk> that is pretty much the reason i switched to that style for data-lens back in the day
00:34:58 <lithiumdeuteride> it helps with algebra, too
00:35:20 <edwardk> using the lens style rather than the data-lens style lets the compiler have more freedom of how to manipulate the stuff out in closure land
00:35:35 <edwardk> we deliberately don't make it explicit and wham, magic happens, we hope
00:36:20 <edwardk> frerich: i've been using algebraic reasoning to transform a ton of code that worked with syntax trees to code that is just faster, period.
00:37:36 <edwardk> frerich: oleg's zseq trick from the reflection without remorse paper can be seen as a way of acknowledging that monoids admit a difference list notion, and so do applicatives, monads, arrows, but the notion of a difference list is inefficient if you have to mix priduction and consumption, so the same techniques that make an efficient queue can make efficient monoids
00:37:57 <frerich> edwardk: How did you know that the code would be faster? Do you try to reach a certain 'form' in the algebraic expression (e.g. prefer 'ab+ac' over 'a*(b+c)' or vice versa) or something?
00:38:58 <frerich> I don't assume one just tinkers with the expression, yielding an infinite numbre of isomorph types, and then just translates back from expressions to types to see what you got. :-}
00:39:11 <edwardk> frerich: lets look at a monoid, its easier. you have (m, m) -> m  and () -> m   -- basically, if you curry the mappend (which we do by default, you can see that mappend takes m to (m -> m) basically the action of m on itself. describing how one m changes another m
00:39:32 <edwardk> frerich now, we can go through and compute with this, this is what a different list does
00:39:50 <edwardk> but the problem with different lists is say you want to alternate between producing and consuming monoidal values
00:39:55 <edwardk> now you pay an asymptotic tax
00:40:21 <edwardk> but the difference list encoding was nice -- it gave you O(1) append even if your monoid was biased and only worked in one direction
00:40:35 <edwardk> e.g. (++) on lists kinda sucks but difference list appends are fast
00:41:45 <edwardk> we took a list or whatever monoid and replaced it implicitly with a queue-like construction in the continuation, so we can equationall convert that back into a data structure and look for faster queues that are explicitly a queue, that gives you O(1) access like the difference list to append, but also O(1) access to the head.... without forcing you to start over.
00:41:57 <edwardk> we used this recently to speed up inits on the libraries@ mailing list for instance
00:42:08 <edwardk> 'its just better'
00:42:28 <edwardk> i tend to look for things that just win across a large array of fitness functions and focus on making those improvements
00:42:59 <edwardk> here we have a solution that only ever loses because of constant factors, but which is a win asymptotically across a large array of scenarios
00:43:58 <nezt> Can anyone give me a link to some Haskell code that they think is particularly elegant in how it's written
00:44:44 <augur> johnw: so the thing with making Storables for lists is, the elements my not be fixed sizes
00:45:37 <augur> johnw: i guess maybe you'd use pointers, which would be fixed sizes? like, to store [[Int]] you'd need pointers, i guess, to the inner lists, rather than the lists themselves
00:45:57 <Hafydd> nezt: main = return ()
00:46:30 <nezt> wat
00:46:41 <Hafydd> Or perhaps "main = main" is more elegant.
00:53:54 <splintax> nezt: what are you looking for? a big project that's being actively used? pandoc and xmonad are probably good examples
00:56:19 <nezt> splintax : yes, thanks.
00:58:26 <jle`> kini: yeah, that was a part of the hope :)
01:02:12 <int3__> if I am trying to profile my program, do I have to install profiling builds of all the libraries it depends on as well?
01:02:58 <int3__> ah ok I guess so: http://stackoverflow.com/questions/12207698/profile-haskell-without-installing-installing-profiling-libraries-for-all-depend
01:04:09 <nezt> As kids in grammar school we rewrote "the cat jumped over the fence" over and over, subvocalizing it and improving our handwriting every time
01:04:10 <nezt> In fact
01:04:19 <nezt> Why not even etch out code with pen and paper
01:04:25 <nezt> Hell, do it with your off hand
01:05:24 <nezt> just 30 mins a day of regurgitating existing code bases combined with creating your own code and reading literature /tutorials/APIs
01:05:26 <nezt> try it
01:08:07 <Maxdamantus> cat, or quick brown fox?
01:08:15 <Maxdamantus> fence, or lazy dog?
01:08:24 <Maxdamantus> jumped, or jumps?
01:09:09 <lithiumdeuteride> lazy dog, for a lazy programming language
01:09:30 <sivteck> :t (||)
01:09:31 <lambdabot> Bool -> Bool -> Bool
01:10:20 <nezt> What if you listened to a voice read haskell code all night as you slept
01:11:19 <frerich> Not at the speed at which SPJ talks though, please.
01:17:12 <nezt> If Our iq is not higher than 140 should we quit learning haskell
01:17:28 <jle`> nezt: no :)
01:17:36 <Kinnison> nezt: Fortunately mine is not, so I should keep learning \o/
01:17:47 <jle`> haskell is not inherently hard/for only smart people
01:18:01 <jle`> it's only hard if your mind has been tainted by imperative intuition ;)
01:18:13 <jle`> which is proabably 85-95% of programmers
01:18:16 <jle`> and 100% of non-programmers :)
01:18:18 <jle`> er
01:18:21 <jle`> 0% of non-programmers
01:18:24 <jle`> :)
01:23:12 <dzhus> has all singleton stuff from GHC.TypeLits (fromSing, sing) been moved to singletons package for GHC 7.8?
01:25:47 <angerman> is there a difference between the shape and the type of data? How would one articulate that properly?
01:29:18 <nezt> Alright I'm going to listen to Haskell code in my sleep i'll report back in 7 hours
01:34:45 <tdammers> nezt: are you putting it on repeatM?
01:37:39 <kvanb> can somebody please explain why sel4 can claim that because it has haskell+isabelle proofs
01:37:45 <kvanb> that the accompanying C source is also secure?
01:42:14 <zereraz> hello people, how to find the common letters between 2 strings
01:42:44 <zereraz> input "aabbse" "ssed" output ['s','e']
01:44:02 <jle`> > intersect "aabbse" "ssed"
01:44:03 <lambdabot>  "se"
01:44:26 <jle`> @hoogle Eq a => [a] -> [a] -> [a]
01:44:28 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
01:44:29 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
01:44:29 <lambdabot> Data.List union :: Eq a => [a] -> [a] -> [a]
01:44:36 <jle`> only #2 :)
01:44:55 <zereraz> jle`, incase I had to implement it on my own
01:45:14 <zereraz> or I'll just see the implementation of it on hoogle
01:45:32 <zereraz> I tried to make this function but failed
01:45:41 <zereraz> thanks jle`
01:48:07 <jle`> zereraz: np!
01:49:26 <mbrock> hey, does anyone know of any clever/nice uses of implicit parameters in "real" Haskell code?
01:51:03 <zereraz> jle`, also can I apply intersect to a list of strings. like find the intersection of all the strings in list?
01:51:37 <jle`> zereraz: can you give an example input and output?
01:52:33 <zereraz> input ["asd","asdawd","weqwed"] output "d"
01:52:50 <zereraz> as d is the only thing common in all the elements
01:54:02 <zereraz> like mapping foldr?
01:54:07 <jle`> i don't think there is one in Data.List, but that looks like something you can implement with an fold(1)
01:54:21 <mmmm> > foldr1 intersect ["asd", "asdawd", "weqwed"]
01:54:23 <lambdabot>  "d"
01:54:45 <zereraz> what is the diff between foldr and foldr1?
01:54:53 <jle`> zereraz: check the types :)
01:55:03 <jle`> the answer is often times in the types
01:55:04 <zereraz> ok thanks
01:55:08 <jle`> :t foldr
01:55:09 <lambdabot> (a -> b -> b) -> b -> [a] -> b
01:55:10 <jle`> :t foldr1
01:55:12 <lambdabot> (a -> a -> a) -> [a] -> a
01:55:23 <jle`> notice the difference?
01:55:54 <tac> zereraz: the -1 versions must be given an additional value and they don't work on empty lists.
01:56:07 <tac> err
01:56:08 <tac> wait
01:56:11 <tac> other way around
01:56:13 <xpika> how can i load a script in ghci compiled?
01:56:30 <zereraz> I think so
01:56:34 <tac> they don't require the second parameter. They just assume the list is nonempty and make the first element the starting value
01:57:26 <zereraz> ok, I'll read its source to understand the implementation, I can see the difference of types
01:58:02 <mmmm> the implementation is foldr1 f xs = foldr f (head xs) (tail xs) :P
01:59:03 <zereraz> so its a must that f should give a []
01:59:07 <zereraz> a list
01:59:10 <frerich> mmmm: I would think that 'foldr' uses the last element.
01:59:16 <frerich> mmmm: 'foldr1', that is.
01:59:37 <jle`> > foldr1 f [x,y,z]
01:59:39 <lambdabot>  Ambiguous occurrence ‘f’
01:59:39 <lambdabot>  It could refer to either ‘L.f’, defined at L.hs:208:1
01:59:39 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.f’,
01:59:39 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:112:1-26
01:59:39 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
01:59:40 <zereraz> foldr1 _ [x]            =  x
01:59:41 <zereraz> foldr1 f (x:xs)         =  f x (foldr1 f xs)
01:59:41 <zereraz> foldr1 _ []             =  errorEmptyList "foldr1"
01:59:42 <jle`> @undefine
01:59:43 <lambdabot> Undefined.
01:59:44 <jle`> > foldr1 f [x,y,z]
01:59:46 <lambdabot>  f x (f y z)
01:59:51 <jle`> who defines x, seriously
01:59:56 <jle`> er, who defines f
01:59:56 <zereraz> only head
02:00:08 <zereraz> we give f right
02:00:10 <jle`> > foldr1 f [a,b,c,d,e]
02:00:12 <lambdabot>  f a (f b (f c (f d e)))
02:00:19 <zereraz> yeah
02:02:21 <zereraz> how to print a number as stdout
02:02:34 <zereraz> not as string?
02:02:36 <zereraz> read?
02:03:01 <jle`> print a number?
02:03:09 <jle`> does print 5 not work?
02:03:17 <zereraz> won
02:03:24 <zereraz> won't it give "5"
02:03:32 <zereraz> :t print
02:03:33 <lambdabot> Show a => a -> IO ()
02:03:38 <zereraz> ok got it
02:05:01 <xpika> can someone tell me what im doing wrong in ghci to load this module compiled? http://lpaste.net/108345
02:05:45 <zereraz> isn't it compiled
02:07:59 <xpika> zereraz: it clearly says : interpreted
02:08:35 <zereraz> xpika, yes
02:09:19 <xpika> zereraz: interpreted /= compiled
02:09:56 <zereraz> xpika, got it
02:13:01 <kvanb> xpika: afaik ghci compiles
02:13:27 <kvanb> the last interpreted haskell stuff was out of the hugs era?
02:14:13 <levi> ghci can compile, but it's primarily an interpreter.
02:14:29 <merijn> GHCi compiles to bytecode and interprets that
02:14:41 <merijn> GHCi can *also* just load compiled machine code, but I forget how
02:14:47 <levi> That is true of most interpreters.
02:15:09 <merijn> And when you need to interact with modules that use FFI you occasionally can't use ghci's bytecode
02:15:32 <merijn> xpika: I remember seeing how to do it in the GHC manual, but honestly I forget the details
02:15:49 <levi> ghci can interact badly with code using ghc-api code as well, IIRC.
02:21:39 <splintax> someone in this channel mentioned making Monad a superclass of Functor in an upcoming version of ghc (and hence deprecating liftM etc in favour of fmap). what version is that? any idea when it is likely to be released?
02:22:04 <jle`> splintax: 7.10 ... i think some time in the next year?
02:22:38 <tac> curious issue...
02:22:49 <tac> I can go to a certain URL in my browser and get a JSON file
02:23:02 <tac> but when I have my bot do it in Haskell, I get an "unable to connect" error...
02:23:35 <tac> I can ping them from the server he's running on... but can't telnet onto port 80 from there
02:24:30 <splintax> jle`: cool. just wanted to make sure there wasn't a "duke nukem forever" type joke going over my head :P
02:25:22 <splintax> tac: if you can't telnet to 80 from the box that your bot runs on, your network is broken
02:26:06 <tac> maybe they have my IP blocked or something?
02:26:12 <tac> but... there's no reason why that should be the case
02:26:18 <merijn> splintax: No, it's been a sore spot for a couple years now, but the proposal to do it got accepted. 7.8 should be producing warnings for missing instances and the plan is to (before 7.10) do a scan of hackage and notify/patch any broken packages before forcing the superclass in 7.10
02:28:12 <MagicShrub> This problem isn't specific to Haskell, but I want to know if this would be considered an NP problem:
02:28:13 <MagicShrub> f xs = [(x, y) | x <- xs, y <- xs, x + y == 10 && x /= y]
02:31:00 <quchen> Why would it be?
02:31:42 <splintax> it seems to be a textbook example of an O(n^2) problem
02:33:31 * hackagebot plailude 0.2.1 - plaimi's prelude  http://hackage.haskell.org/package/plailude-0.2.1 (alexander)
02:35:15 <arj> what the heck is plaimi?
02:36:02 <dottedmag> arj: probably "who the heck"
02:36:23 <mmmm> Are there any good blog posts about maintaining data type invariants?
02:36:23 <arj> dottedmag: from a grammar's perspective, I aggree ;-)
02:36:28 <mmmm> (using GADTs or otherwise)
02:36:32 <frerich> "plaimi's literally an infinitely mutating initialism"
02:36:51 <arj> frerich: and the website is down
02:36:54 <arj> (for me)
02:36:58 <frerich> arj: https://secure.plaimi.net/about.html works for me
02:37:07 <arj> ah!
02:38:07 <zereraz> hello I am getting an output "\"d\"" (of an intersect function) so I just want 'd' , what do I do?
02:38:27 <arj> zereraz: maybe you should use intersperse?
02:38:34 <merijn> zereraz: Looks like you're first showing and then printing?
02:38:39 <merijn> zereraz: Also, is this in ghci?
02:38:58 <zereraz> arj, intersperse adds stuff right?
02:39:08 <bernalex> I've changed a dependency from >=0.2 to >=0.2.1, and now my dependency tree gets exhausted whenever I try to cabal install --only-dependencies. help?
02:39:11 <arj> merijn: had the better point...
02:39:12 <zereraz> merijn, yes
02:39:33 <merijn> zereraz: ghci runs "show" before showing the resulting output
02:39:34 <arj> ehm sorry, zereraz: merijn had the better point...
02:39:36 <bernalex> I can post the cabal file & entire error msg if that's helpful
02:39:43 <merijn> So if you return a String you get wonky results
02:39:54 <zereraz> merijn, so what do I do?
02:39:59 <zereraz> its not just printing
02:40:06 <zereraz> I print the length
02:40:09 <zereraz> and I got wrong answer
02:40:21 <zereraz> the \ comes when there is no intersection
02:40:23 <arj> > show "Hello"
02:40:25 <lambdabot>  "\"Hello\""
02:40:31 <arj> ?
02:40:45 <arj> zereraz: this is what (s)he meant
02:41:18 <zereraz> arj, ok but I think my \ comes because when it got nothing from intersection
02:41:50 <zereraz> function is , foldr1 intersect xs
02:41:53 <augur> johnw: so it seems like storable isnt actually going to let me reuse the same object in memory repeatedly, right? itll instead have to be re-loaded from the stored version every time it gets used?
02:42:14 <zereraz> input is "asd" "def" "edf"
02:42:19 <zereraz> so it got the d righrt
02:42:22 <zereraz> right*
02:42:33 <_d3f> I should deactivate def as highlight
02:42:36 <jle`> > foldr1 intersect ["asd", "def", "edf"]
02:42:37 <lambdabot>  "d"
02:42:48 <jle`> _d3f: :P
02:42:51 <zereraz> huh
02:42:53 <jle`> no we just miss you
02:42:54 <zereraz> lol
02:42:58 <arj> looks good.
02:43:06 <arj> so? you use a show somewhere?
02:43:08 <zereraz> then this is ghci?
02:43:10 <jle`> if you show a string, you'll get a string representation of the string representation
02:43:12 <zereraz> but its counting wrong too
02:43:26 <jle`> > show (foldr1 intersect ["asd", "def", "edf"])
02:43:27 <lambdabot>  "\"d\""
02:43:34 <zereraz> I am not using show
02:43:38 <zereraz> I do length
02:43:39 <jle`> are you using print?
02:43:41 <arj> print?
02:43:44 <zereraz> print
02:43:48 <jle`> print = putStrLn . show
02:43:49 <arj> print uses show
02:43:51 <zereraz> but I print the lenght
02:43:55 <jle`> hm
02:44:05 <jle`> can you paste the actual thing you are doing?
02:44:10 <zereraz> yeah
02:44:14 <frerich> :t intersect
02:44:16 <lambdabot> Eq a => [a] -> [a] -> [a]
02:44:17 <arj> then how come you see "\"d\"" when it should be a number?!
02:44:43 <frerich> Hm intersect with just an 'Eq' requirement smells like some O(n^2) algorithm
02:44:45 <arj> > length (foldr1 intersect ["asd", "def", "edf"])
02:44:46 <lambdabot>  1
02:44:52 <arj> looks good.
02:45:32 <zereraz> http://lpaste.net/108346
02:45:37 <jle`> @src intersect
02:45:38 <lambdabot> intersect = intersectBy (==)
02:45:42 <jle`> @src intersectBy
02:45:42 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
02:45:50 <jle`> frerich: good call :)
02:46:52 <zereraz> 1 more thing
02:46:59 <zereraz> my strings come from user
02:47:01 <frerich> jle`: Weren't you the guy who already object to a similiar issue with 'nub'? Maybe a version of intersect with an Ord requirement would be nice for similar reasons.
02:47:22 <jle`> i'm not sure if i was the guy
02:47:27 <frerich> jle`: s/who already object to/who already raised/
02:47:53 <frerich> Maybe I'm mixing this up, there was somebody on some haskell mailinglist pointing out how evil 'nub' is.
02:47:57 <jle`> nub being O(n^2) is a pretty widespread gripe
02:48:10 <jle`> actually you know what i just realized today
02:48:15 <jle`> you don't even need to require an Ord constraint
02:48:34 <frerich> Ah no, I'm thinking of Niklas Hambüchen
02:48:36 <jle`> you just need to ask for an explicitly passed typeclass dictionary
02:48:37 <frerich> And Ig uess that's not you.
02:48:43 <jle`> probably not :)
02:49:07 <jle`> a functin that's Eq a => c is actually really a function that's (a -> a -> Bool) -> c
02:49:07 <zereraz> arj, for debugging i was printing the result
02:49:09 <frerich> "Explicitely passed typeclass dictionary" is a fancy name for passing an "a -> a -> Ordering"?
02:49:20 <jle`> yeah
02:49:27 <frerich> jle`: Sure.
02:49:31 <jle`> as it turns out, that's how intersectBy already works
02:49:38 <jle`> so you don't lose anything! :O
02:49:41 <jle`> :t intersect
02:49:42 <lambdabot> Eq a => [a] -> [a] -> [a]
02:49:43 <jle`> :t intersectBy
02:49:44 <lambdabot> (a -> a -> Bool) -> [a] -> [a] -> [a]
02:49:54 <jle`> you just move the (Eq a =>) into an (a -> a -> Bool)
02:50:01 <zereraz> my code http://lpaste.net/108346
02:50:09 <jle`> intersectBy is a version of intersect where you explicitly pass in the typeclass dictioanry for Eq
02:50:10 <frerich> jle`: Ok but I don't really care about 'Eq' vs. an explicit function argment. I care about 'Ord' :-)
02:50:12 <jle`> same for sort vs sortBy
02:50:24 <jle`> :t sort
02:50:25 <lambdabot> Ord a => [a] -> [a]
02:50:25 <jle`> :t sortBy
02:50:26 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
02:50:40 <jle`> so you could do an intersectByComp :: (a -> a -> Ordering) -> [a] -> [a]
02:50:49 <frerich> Sure.
02:50:57 <tac> I wonder if Bitcoin services are blocking Linode IP addresses or something...
02:51:06 <jle`> and it fits in with the established conventions
02:51:14 <jle`> hm
02:51:18 <jle`> i'm just rambling at this point >____>
02:51:36 <Tjr> what does "linear" mean in haskell? http://ro-che.info/articles/2014-06-14-extensible-effects-failed.html
02:51:36 <orbital_fox> tac:  Linode, the Linux distro?
02:52:13 <zereraz> ?
02:52:16 <gws> linode is a cloud hosting company
02:52:27 <tac> orbital_fox: https://www.linode.com/
02:52:36 <quchen> Tjr: I don'g see "linear" in that article
02:53:02 <Tjr> quchen: in the bar diagram. search for "relatively to the State from transformers"
02:53:04 <quchen> There are linear patterns, which means that each pattern variable appears at most once in a pattern
02:53:14 <orbital_fox> tac:  hm.. there used to be a Linux distro with that name.. maybe i am confusing it
02:53:22 <tac> no... this is something I'm doing wrong with wreq, I think
02:53:35 <tac> but not just wreq... with telnet <addr> 80 as well
02:54:02 <Tjr> quchen: how come linear is the opposite of tree? And what does haskell-linear have to do with linear-algebra-linear?
02:54:03 <trap_exit> what problem does FRP (functional reactive programming)_ solve? the problem if GUI state or the problem of continuous time?
02:54:30 <xpika> is there an option to get more detail than :set +s ? like the other time values when running the unix command time?
02:54:35 <arj> zereraz: commonLength works as expected for me?
02:54:44 <Tjr> I'd assume the tree contains the contents only once, too. In the respective leaf.
02:54:47 <quchen> Tjr: There are also linear types, but I'm not familiar with that.
02:54:59 <zereraz> arj, I am sorry I just realized my mistake
02:55:09 <tac> trap_exit: it's more of a matter of dependency-based state, I think
02:55:10 <arj> which is?
02:55:16 <quchen> Tjr: I don't really understand the diagram in isolation, so I have no idea what "linear" means there
02:55:19 <zereraz> arj, I was giving in strings in ""
02:55:23 <trap_exit> tac: side-effect-free talks; yay!
02:55:32 <trap_exit> tac: wtf is dependency-based state?
02:55:33 <arj> ah!
02:55:39 <Tjr> quchen: ok, thanks.
02:55:42 <tac> trap_exit: the state of each thingy is time-varying... but it's always a function of whatever data sources connect into it
02:56:21 <zereraz> arj, how did you give input?
02:56:36 <zereraz> arj, did you give in double quotes
02:56:45 <arj> zereraz: I only checked the commonLength function
02:57:07 <zereraz> arj, It works now, I was giving ""
02:57:11 <zereraz> sorry guys
02:58:00 <arj> zereraz: don't use quotes when you enter a string except within the programming language's source code
02:58:07 <arj> (that includes ghci!)
02:58:26 <zereraz> arj, I know!! I have no idea what I was thinking
02:59:36 <trap_exit> tac: yeah, what if I don't give a fuck about time-varying
02:59:47 <trap_exit> tac: as in all I want is discrete animations, not continuous animations
02:59:49 <trap_exit> i.e. stuf in response to mouse / key strokes
03:00:09 <tac> trap_exit: then you work with discrete time?
03:01:56 <tac> the continuous time thing is always going to be a lie anyway
03:02:12 <tac> but it affects how you implement things and how you model things
03:04:28 <bernalex> arj: hi. I'm plaimi. why?
03:04:50 <arj> bernalex: hehe, just wondered, because the website appears to be down for me
03:04:51 <bernalex> arj: ah. you saw hackagebot probably
03:04:56 <arj> exactly.
03:05:11 <arj> ah now it works again...
03:05:15 <bernalex> arj: one of our servers died just now. so the website *was* down.
03:05:36 <arj> ah, so I was unlucky ;-)
03:11:09 <bernalex> how does cabal sandbox add source really work wrt figuring out the deps of the source? I have a source that used to depend on an old package version. so I bumped it in cabal. it builds and works. now if I try to build the package I really want to build, in a sandbox, I get dependency exhaustion because it tries to build an old version of the source's dependency.
03:12:19 <bernalex> so my package Foo depends on Bar. both depend of Quix. Foo depends on Quix >=0.2.1. Bar used to depend on Quix >=0.1 && <0.2, but I bumped this to 0.2.1 and 0.3. but when building Foo, with Bar as a source, in a cabal sandbox, cabal fails trying to build Quix 0.1.0.
03:16:48 <Tjr> What does MPTC mean?
03:16:50 <Tjr> http://ro-che.info/articles/2014-07-15-type-based-lift.html
03:17:17 <Tjr> multie parameter type class
03:17:24 <Tjr> sorry for the inconvenience
03:20:43 <mmmm> bernalex: which package are you add-sourcing?
03:21:12 <bernalex> mmmm: one of our internally used packages, which is in a git repo.
03:21:39 <bernalex> I also made a git commit for the dependency bump in that package.
03:21:51 <mmmm> quix foo or bar
03:22:23 <bernalex> Bar is the add-sourced package. Quix is the common dep between Foo & Bar that I had to bump in Bar.
03:22:51 <mmmm> are you sure no other packages depend on quix?
03:23:08 <bernalex> mmmm: yes, Quix is also an internally used package.
03:24:00 <jle`> is there any way to get haddock to add explicit forall's everywhere?
03:24:07 <jle`> i use a lot of explicit foralls for scoped type variables only
03:24:15 <jle`> and it's kind of weird that half of the functions have them and half of them don't
03:24:29 <mmmm> I mean if another package depends on quix with bound < 0.2 that you depend on
03:24:40 <jle`> alternatively, can it hide the ones that arent necessary?
03:25:04 <bernalex> mmmm: Quix is an internally used package. no packages depend on it except for Foo and Bar. both Foo and Bar have >=0.2.1 && <0.3.
03:26:55 <mmmm> and you are in a fresh sandbox?
03:27:12 <bernalex> mmmm: yep
03:27:23 <mmmm> cabal sandbox init, cabal sandbox add-source /path/to/quix/, cabal sandbox install --only-dependencies ?
03:27:41 <bernalex> mmmm: yep
03:27:54 <bernalex> mmmm: well, actually cabal sandbox install --only-dependencies --enable-tests
03:28:06 <bernalex> erm
03:28:13 <bernalex> not cabal sandbox install -- just cabal install. rite?
03:28:33 <mmmm> yes sorry
03:32:08 <mmmm> and you're 100% sure that the bounds all match in the cabal files?
03:34:34 <bernalex> mmmm: they are identical -- >=0.2.1 && <0.3
03:37:09 <mmmm> do you have the package listed in the test part of your cabal file?
03:38:21 <bernalex> mmmm: in Foo, it's under test-suite spec.
03:38:35 <bernalex> mmmm: in Bar, it's under library.
03:38:38 * hackagebot ghc-server 1.0 - A server interface to GHC.  http://hackage.haskell.org/package/ghc-server-1.0 (ChrisDone)
03:39:01 <mmmm> ok I have no idea sorry
03:44:04 <ddfffd> Is it a bad idea to use Show for pretty-printing?
03:44:13 <jle`> ddfffd: it's discouraged
03:45:39 <ddfffd> jle`: Some say it is, but I've encountered this in the libraries.  On the other hand, I've never seen someone using, say, the prettyclass package.
03:49:07 <merijn> I would either use a custom "prettyPrint :: Foo -> String" function or one of the pretty print libraries, tbh
03:50:02 <bernalex> mmmm: http://lpaste.net/6646631236825513984 here's the error msg at least
03:50:03 <frerich> Reminds me, is there a pretty-printer for file sizes somewhere on hackage which takes care of translating e.g. 2*1024*1024 into "2 MB"?
03:50:23 <ddfffd> merijn: Does the haskell-report document the proper usage of Show?
03:51:57 <mmmm> yes I have no idea sorry
03:52:18 <mmmm> Is there a way to recover generics from GADTs or another approach which lets you do so
03:53:13 <ddfffd> Answering my own question: I don't think so.  I think I'll go with the pretty-printing function.  Thanks all.
03:53:27 <supki> bernalex: unregister plailude-0.1.0 and retry
03:53:55 <bernalex> supki: why would I need to do that, when it's a fresh sandbox? why would it ever care about plailude-0.1.0? it's not mentioned anywhere afaik
03:55:30 <supki> bernalex: "installed" hints it's not fresh, I think
03:55:40 <bernalex> supki: also how do I unregister it?
03:55:55 <supki> bernalex: anyway, cabal avoids reinstalling packages because that breaks their revdeps
03:56:03 <bernalex> supki: it's fresh. I even made a clean clone of the repo with a new sandbox.
03:56:14 <mbrock> frerich: http://hackage.haskell.org/package/prefix-units-0.1.0.1/docs/Data-Prefix-Units.html looks pretty good
03:56:17 <bernalex> supki: oooooh, can it be that I have that package installed system-wide?
03:56:20 <supki> bernalex: do you have it installed in --global?
03:56:26 <supki> yes
03:56:29 <bernalex> supki: I have it installed using my package manager
03:56:37 <supki> yeah, that's a bad idea
03:56:40 <bernalex> supki: so how do I unregister it?
03:56:59 <frerich> mbrock: Indede, that seems perfect! Thanks a lot!
03:57:56 <supki> bernalex: ghc-pkg unregister plaimi-0.1.0
03:58:11 <bernalex> errr you mean plailude, I assume
03:58:20 <supki> oh, yeah, that
03:58:25 <bernalex> right I see
03:58:28 <bernalex> that's really dumb
03:58:32 <supki> I guess uninstalling it using package manager may be simpler
03:58:37 <bernalex> I mean, that's inconceivably stupid
03:58:42 <bernalex> what's the point of a sandbox then?
03:59:21 <bernalex> supki: thanks for the help!
04:00:04 <bernalex> supki: also same problem arises
04:00:23 <bernalex> supki: so it didn't help :-P
04:00:29 <supki> sandboxes do not work very well if you install stuff in --global
04:01:58 <dzhus> sandbox isolation is unidirectional
04:02:28 <milos_cohagen> > take 5 [1..]
04:02:30 <lambdabot>  [1,2,3,4,5]
04:02:35 <supki> bernalex: does ghc-pkg list plailude list anything?
04:03:05 <bernalex> supki: nope
04:03:23 <supki> and the error message didn't change?
04:03:47 <bernalex> supki: nope
04:04:07 <bernalex> I just now tried clean clones of both packages with a new sandbox. same problem still.
04:04:58 <supki> do you have other packages that depend on plailude-0.1.0 in --global?
04:05:08 <bernalex> supki: no.
04:06:18 <milos_cohagen> if i use the lambdabot, is my command and the bot's response visible to everyone? if so, can you command the bot privately?
04:06:30 <bernalex> also, remember that the Bar builds happily with the correct version of Quix.
04:06:35 <mmmm> private message it
04:06:59 <milos_cohagen> thx, newb to irc, how would i pm the bot?
04:07:21 <arancia> /query lambdabot
04:07:44 <arancia> or /msg lambdabot
04:08:38 <supki> bernalex: could you paste tempuhs-server.cabal?
04:09:35 <bernalex> supki: https://github.com/plaimi/tempuhs-server/blob/master/tempuhs-server.cabal
04:09:37 <supki> bernalex: also adding -v3 to cabal install command can be helpful
04:09:37 <bernalex> -                       plailude >=0.1 && <0.2,
04:09:39 <bernalex> +                       plailude >=0.2.1 && <0.3.0
04:10:13 <bernalex> supki: I'll pastebin -v3 with a fresh sandbox.
04:10:45 <bernalex> supki: http://bpaste.net/show/521034/
04:10:48 <milos_cohagen> thx arancia
04:11:04 <milos_cohagen> and mmmm.
04:12:53 <supki> bernalex: well, at least now it does not think it's "installed"
04:13:38 <supki> so apparently it just does not lookup the new version for some reason
04:14:55 <bernalex> supki: strange it works in the other package by itself
04:15:53 <supki> bernalex: have you run cabal sandbox add-source in the fresh sandbox too?
04:16:23 <bernalex> supki: yes.
04:29:24 <supki> bernalex: hmm, weird, that should be enough for cabal to pick it up
04:29:46 <supki> bernalex: do you have .cabal-sandbox/add-source-timestamps file?
04:30:05 <bernalex> yes
04:30:11 <bernalex> [("x86_64-linux-ghc-7.6.3",[("/home/alexander/git/tempuhs",0)])
04:30:11 <supki> I'm not sure if there's a better place to check cabal have understood the add-source command
04:30:19 <supki> oh
04:30:51 <supki> I think there should be a path to plailude sources too
04:31:03 <bernalex> supki: no. that's on hackage.
04:32:21 <supki> oh
04:32:33 <supki> bernalex: have you run cabal update after uploading the new version?
04:33:00 <bernalex> supki: hmmm. I don't actually remember. but given that Bar works, and it depends on the new version, I assumed that Foo would work too
04:33:12 <bernalex> i.e. that I have run it. let me do it once more to be sure though.
04:34:29 <bernalex> supki: ...........
04:34:33 <bernalex> supki: thanks........
04:34:45 * bernalex facedesks for a while
04:35:39 <supki> :)
04:36:31 <supki> I would ask that earlier if I didn't thought we are installing a locally modified plailude all that time
04:36:39 <bernalex> supki: I'm glad I have been doing other work simultaneously, and not just completely wasted about 90 mins at least. very strange that it worked for Bar though.
04:37:13 <supki> probably Bar has it add-sourced or something?
04:37:23 <bernalex> supki: nope
04:37:35 <bernalex> completely clean Bar clone /w new sandbox
04:38:44 * hackagebot formatting 5.2 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-5.2 (ChrisDone)
05:29:54 <augur> is there a way to get TH code that generates other source files to compile together with its other files?
05:31:01 <augur> eg, TacticalGrace's Objective C inline code generates some auxiliary Objective C files (automatically generated bridging files) that need to be compiled together with the residual haskell file
05:31:16 <augur> is there a way to get this to all happen with a single GHC command or is that asking too much?
05:32:45 <ddrone> Hi everyone. In this post about attoparsec function "match" is described: http://www.serpentine.com/blog/2014/05/31/attoparsec/. Is there an analogue for "match" in parsec?
05:40:23 <arianvp> does anybody know how to get lens working with GHCJS? I run into this error when  I have it as a dependency: http://lpaste.net/1397023007347572736
05:41:00 <augur> arianvp: might want to ask in #haskell-lens as well
05:56:52 <xinming> In case, I've stopped the contract with my ISP, so, when I asked question, My network may down. if this happen, parden me.
05:56:57 <xinming> Ok, questions here.
05:57:21 <xinming> Is there a way to setup a hackage mirror locally? So that I don't need my network when try to install package
05:57:53 <xinming> I have cpan already (A central package repository)
05:57:57 <xinming> So, what about hackage please?
06:00:19 <mbrock> xinming: https://github.com/haskell/hackage-server/wiki here is some info about that
06:00:34 <xinming> mbrock: thanks
06:06:10 <joinmetaleerpedo> you guys wanna join #metaleerpedo ? :]
06:06:23 <joinmetaleerpedo> hey
06:13:45 <augur> @where ops
06:13:45 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
06:14:06 --- mode: ChanServ set +o geekosaur
06:14:20 --- mode: geekosaur set +b *!*7dd4d13d@*.125.212.209.61
06:14:20 --- kick: joinmetaleerpedo was kicked by geekosaur (joinmetaleerpedo)
06:14:32 --- mode: geekosaur set -o geekosaur
06:14:51 <augur> modify (+1) geekosaur
06:28:30 <allsystemsarego> Hi all, I'm completely baffled, how can QuickCheck do less than one shrink? Why does it sometimes report "Assertion failed (after 5 tests and 0.16 shrinks)..."
06:29:46 <bitemyapp> allsystemsarego: are you shrinking a RealFrac?
06:31:57 <allsystemsarego> bitemyapp, no, it's a newtype wrapper for a list
06:32:37 <allsystemsarego> newtype ActionList = MkActionList [Action]
06:33:29 <quchen> allsystemsarego: I'm just looking at the code, and it seems the "." there is not a decimal point.
06:33:42 <allsystemsarego> oh
06:34:07 <allsystemsarego> that is confusing then
06:34:22 <quchen> allsystemsarego: http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/src/Test-QuickCheck-Test.html#line-342
06:34:39 <quchen> It seems "X.Y" represents X successful shrinks and Y failed ones
06:34:59 <Hafydd> @unpl f = flip ((.) (flip (>>=)) (flip g))
06:35:00 <lambdabot> f b c = b >>= \ m -> g m c;
06:35:36 <allsystemsarego> quchen, that makes sense, thanks
06:35:50 <allsystemsarego> it mean I need to redesign the shrink function
06:36:24 <quchen> Isn't there a generic way to implement shrinking?
06:36:30 <allsystemsarego> currently it's shrink (MkActionList actionList) = map MkActionList $ subsequences actionList \\ [actionList]
06:36:32 <quchen> I thought I had seen one.
06:36:50 <allsystemsarego> quchen, by using the derive package, presumably
06:37:52 <quchen> I don't remember where it was :-(
06:49:38 <Aesop> hey guys, I got some weird behavior in my code any reason why this function wouldnt work as expected http://lpaste.net/2295051702019031040 An exception which non exhaustive pattern exception isn't catched
06:52:12 <Aesop> sry i messed up the last sentence I get a non exhaustive pattern exception which origin must be within one of the mapped functions but then it should be catched and and the element skipped
06:53:18 <bergmark> Aesop: i think non exhaustive match is an error, not an exception
06:53:36 <Aesop> does that mean it cant be catched?
06:54:02 * hackagebot fay-base 0.19.2 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.19.2 (AdamBergmark)
06:54:30 <rwbarton> "(return . f $ x)" is never going to raise an exception
06:55:14 <Aesop> ok why and how could i possibly realize that function then?
06:55:22 <bergmark> Aesop: i don't know, it seems weird to catch this :-)
06:55:53 <rwbarton> because it is an IO action that does nothing but return the value (f x)
06:55:58 <rwbarton> it doesn't attempt to evaluate (f x)
06:57:04 <RedNifre> Hey there!
06:59:19 <Aesop> well basically im parsing a bunch of stuff and sometimes its malformed in various ways which isn't if I could skip that particular data point it would be very tedious to wrap anything that could possibly fail into maybes so i hoped, to just catch any error and skip that element, this is possible isn't it?
07:01:50 <Hafydd> Aesop: you might want to look up the proper use of punctuation marks in English.
07:03:22 <Hafydd> You can't "catch" errors of the form "undefined", if that's what you're asking.
07:04:03 * hackagebot cgrep 6.4.5 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.5 (NicolaBonelli)
07:05:46 <Aesop> Sorry if you feel offended by my grammar, I will work on at some point in the future. I don't understand your remark about undefined, can undefined occur if didn't use it in my code?
07:06:57 <supki> Aesop: catching pattern match failure exceptions isn't going to be easier or prettier than using Maybe
07:07:29 <Hafydd> Aesop: I mean errors produced by undefined, error :: String -> a, pattern match failures, nontermination, etc.
07:07:40 <Hafydd> Collectively referred to as "bottom".
07:08:21 <Hafydd> Although there are facilities to bind a different kind of failure to pattern match failures within do notation.
07:13:41 <Aesop> Ok I think I have some lack of knowledge regarding this area, I going to read some background stuff about it. But I think my intention isn't that abstruse. Basically I want a map function that excludes any elements where an error/exception occured. This won't be possible for all kinds of errors, I guess, but I was under the impression that I can catch PatternMatchFail through SomeException.
07:14:18 <Hafydd> Are you computing within IO?
07:14:53 <Aesop> At the top level sure, but some functions are pure I'm using from there.
07:16:00 <Hafydd> If you were processing the list in IO, you could catch exceptions for individual elements.
07:16:01 <int3__> Aesop: generally what you should be doing is passing Maybe values around, and have a `_` pattern that returns Nothing
07:16:31 <Hafydd> (But I don't recommend that.)
07:17:43 <int3__> or Error instead of Maybe, if you want more informative errors.
07:18:19 <int3__> Aesop: http://book.realworldhaskell.org/read/error-handling.html
07:20:08 <Aesop> The problem is my parsing code is scattered with partial function, I know if one of them fails the whole data set is unusable. So I thought instead of doing fine grained error handling, I'm going to discard that element on failure, that's reasonable, isn't it?
07:21:01 <mmmm> no, you have to use Maybe
07:21:06 <int3__> Aesop: you shouldn't be writing partial functions in general
07:22:59 <Aesop> Well, ok thanks for your help guys!
07:23:04 <rwbarton> you should only use partial functions when you don't expect them to ever fail, clearly that isn't the case here
07:32:31 <PurpleTense> I have heard rumors that haskell is a religion
07:32:34 <PurpleTense> ;P
07:32:59 <frerich> Stone him to death! He claimed it was just rumors!
07:33:04 <MP2E> haha
07:33:36 <edwardk> PurpleTense: i converted. i go around from city to city and try to gather converts even.
07:35:01 <MP2E> yeah, I do too. I always bug my friends in other channels on IRC about it whenever I can
07:35:11 <MP2E> 'hey look at this parser written with Applicative, this sure is nice isn't it? ;)' etc
07:35:17 <MP2E> hehe
07:35:24 <merijn> edwardk: Which city holds the secret lens cult headquarters?
07:35:42 <merijn> PurpleTense: Don't listen to edwardk, he's from a radical splinter faction of lens users :p
07:35:59 <edwardk> Boston. Used to be right across the street from the christian science monitor
07:36:07 <merijn> Aww
07:36:28 <PurpleTense> lol
07:36:38 <edwardk> But really we all know the motherland is cambridge, you can make a pilgrimage to the old site at glasgow though
07:38:08 <frerich> Or "glaskee" as the people there like to say :-}
07:38:50 <tdammers> frerich: they can talk?
07:38:52 <merijn> PurpleTense: To be honest, when you finally understand things this whole "pure functional programming" thing can feel like finding religion :)
07:39:55 <frerich> tdammers: I think so, I was told it's english but when I was walking around Glasgow because I accidentally left the bus two stops early I had to ask my way around - and I barely understood anything...
07:40:51 <tdammers> frerich: I tried ordering train tickets from a Glaswegian suburb to Oban once, over the phone
07:41:13 <merijn> Except religion never reduced the number of bugs I had to fix...
07:41:14 <tdammers> frerich: it took quite a while before we had established a working communication channel
07:41:35 <tdammers> merijn: I find your lack of faith disturbing!
07:41:50 <merijn> tdammers: I meant as opposed to FP :)
07:42:07 <tdammers> merijn: me too
07:42:39 <PurpleTense> I actually know nothing about haskall
07:42:46 <PurpleTense> except that a friend of mine is religious about it
07:42:51 <MP2E> PurpleTense : I highly recommend it :)
07:42:55 <MP2E> :P
07:42:57 <merijn> PurpleTense: The usual starting point is
07:43:00 <merijn> @where LYAH
07:43:00 <MP2E> But this is #haskell so what do you expect hehe
07:43:01 <lambdabot> http://www.learnyouahaskell.com/
07:43:07 <PurpleTense> Is it multiplatform (i.e. linux)?
07:43:08 <tdammers> FBD - Faith Based Development ("I believe this should work" is faster than "let's write a few quick tests" or "let's sit down and think long and hard about the kind of constraints we need")
07:43:13 <rio> all glory to the hypnohaskell
07:43:19 <tdammers> PurpleTense: yes
07:43:26 <MP2E> PurpleTense: Windows, Mac OS X, Linux, and iOS and Android are being worked on
07:43:31 <merijn> I've heard good things about Bird's (was it Bird?) haskell book too
07:43:59 <tdammers> PurpleTense: ghc (the de-facto standard compiler) tends to work best on linux, even
07:44:32 <merijn> tdammers: It works just fine on OSX too, except for this little clang SNAFU with Apple :p
07:44:37 <merijn> But the new platform is due \o/
07:44:56 <Ankhers> When exactly is the new platform due?
07:45:00 <tdammers> merijn: yes, I know. And apparently it's not shabby on Windows either, if you're willing to adapt to a few unixisms
07:45:14 <PurpleTense> Is haskall low-level or high-level?
07:45:18 <bergmark> Ankhers: end of this week i think
07:45:20 <PurpleTense> like, how does it compare to python/java
07:45:23 <Ankhers> :o
07:45:27 <tdammers> PurpleTense: hask*e*ll
07:45:32 <Ankhers> bergmark: You have just made my day.
07:45:40 <PurpleTense> haskell* lol
07:45:43 <tdammers> PurpleTense: and it's pretty high-level
07:45:52 <merijn> PurpleTense: I would say that haskell would be equal or higher level than python
07:46:04 <Ankhers> but significantly faster.
07:46:14 <Ankhers> Than said Python
07:46:19 <merijn> PurpleTense: But with native code generation, so usually an order of magnitude faster than python, plus you can write pretty low-level code if you want
07:46:31 <merijn> With the usual risks/ugliness of low-level code, obviously
07:46:40 <tdammers> PurpleTense: it's higher-level in some regard (more powerful abstractions), lower-level in others (compiles to native binaries instead of running on a VM/interpreter)
07:47:37 <merijn> PurpleTense: Haskell is very different from most existing languages, though. It's not uncommon to need to unlearn a lot of things and be very confused when you just start. On the other hand, I personally (and presumably a lot of people here), will argue that in the end it was totally worth it
07:48:23 <lf94> ugh, day 3 of getting charts to work on debian.
07:48:48 <merijn> PurpleTense: I would say that when compared to haskell, Java/python/ruby/C# are all "essentially the same", you learn a bunch of new syntax and one or 2 special features and you're done.
07:51:03 <rufs> I have a bunch of poor orphan instances in a module where I collect data using postgres-simple and convert them to my types (FromRow-instances). It feels a bit weird to put these instances in the modules where I define the types since they are so tightly related to the database. Is it fine stylewise to have it this way or should orphans be avoided?
07:51:44 <Pythonfant> Even if you don't program haskell afterwards and get back to another language you will definitly have gained new insights and you will think differently about problems
07:52:08 <darthdeus> it will make you hate every other language at least :P
07:52:10 <merijn> rufs: There's some reasons to avoid orphan's, but it's not a big issue
07:53:15 <merijn> rufs: In the presence of some of the (evil) typeclass extensions like OverlappingInstances orphan's can make instance selection non-deterministic, additionally, orphans make it easier to accidentally define colliding typeclasses
07:53:34 <Exio4> darthdeus, any haskeller could confirm!
07:53:39 <merijn> rufs: i.e. if you define an instance for a type from package X and package X later adds an instance, now your code won't compile
07:53:57 <Exio4> you start thinking "if i used a datatype here..." "a map over this..."
07:54:00 <merijn> rufs: If your typeclass (or datatype) and it's orphan are in the same package it's kinda ok
07:54:33 <merijn> rufs: FYI, why not define your functions with the database and have the instance declaration use those same functions? (Although, I guess that might result in a recursive import)
07:55:17 <Pythonfant> Exio4: and then you realize: Oh crap it's java
07:55:27 <Exio4> hah
07:56:06 <merijn> Java is not even *that* bad (it's still pretty bad), it's the culture/ecosystem
07:56:11 <Exio4> if you're coding in java it is because you were forced to! sane people doesn't code in java if they have the choice :P
07:56:43 <Pythonfant> Exio4: sadly most of the time I have no choice for university stuff
07:56:54 <ohulloh_> that's unfortunate :(
07:56:55 <Exio4> imo "OOP patterns" tend to add boilerplate to simple things
07:57:04 <merijn> Pythonfant: Write a compiler in haskell that compiles your special DSL to Java :D
07:57:09 <Exio4> haha
07:57:11 <Pythonfant> merijn: hehe
07:57:14 <merijn> Hell
07:57:21 <kstt> I can do "cabal install --flags=debug". Can I do "cabal run --flags=debug" ?
07:57:23 <merijn> You can skip the compiler
07:57:31 <merijn> write a DSL in haskell that generates java when executed
07:57:36 <merijn> Should be easy
07:57:51 <frerich> Exio4: I guess you could say that 'Design Patterns' are just a testament to the lack of expressiveness in the language. If the language could express the pattern directly, then it wouldn't be a pattern. It would be a plain library function.
07:57:59 <kstt> cabal run is handy when developping
07:58:22 <merijn> kstt: I think if you just do "cabal configure --flags=debug" then you can use run
07:58:30 <kstt> thank you merijn
07:58:48 <merijn> kstt: (There's an annoying misfeature where install will ignore your config and start from scratch, thus ignoring any flags you specified during configure)
07:58:57 <Exio4> frerich, you're right, it is just "a workaround"
07:59:08 <merijn> kstt: but if you just use build/run then they should preserve your configure arguments
07:59:26 <kstt> got that merijn, thank you for the advice
08:00:06 <merijn> cabal test should also use your configuration
08:04:13 <allsystemsarego> hi all, what's the fix for : "This binding for `sequence' shadows the existing binding"
08:04:36 <merijn> allsystemsarego: Using a different name or disabling the warning :p
08:04:38 <allsystemsarego> import Prelude hiding sequence?
08:04:46 <allsystemsarego> oh I see
08:05:00 <tdammers> allsystemsarego: disable the warning, import hiding (sequence), or rename your variable, yes
08:05:07 <merijn> allsystemsarego: "shadows" just means "that name already exist", personally I don't mind shadowing as long as you don't do it very confusingly (as sometimes happens)
08:05:21 <tdammers> or import and use qualified
08:05:39 * merijn is not yet sold on the usefulness about the shadowing warning
08:06:07 <tdammers> shadowing can produce some subtle bugs though
08:06:16 <tdammers> subtle bugs are the worst kind
08:06:24 <merijn> Sure, it depends on the kind of shadowing
08:06:39 <merijn> There's a difference between shadowing, say, (+) and some rarely used symbol
08:06:49 <tdammers> yup
08:06:57 <tdammers> also, smaller scope -> less confusing
08:07:54 <merijn> I tend to shadow in small scopes with rare symbols (because common ones are too confusing), so if you already avoid shadowing yourself the warning mostly produces annoying issues where you need to think up really confusing name for a function you forgot even existed in Prelude
08:08:00 <oatsadn> hi, i’m trying to comprehend http://www.haskell.org/haskellwiki/State_Monad#Complete_and_Concrete_Example_1 — how do i got about understanding where “get” gets a value from? to me it just look like a free variable
08:08:51 <Pythonfant> :t State
08:08:53 <lambdabot>     Not in scope: data constructor ‘State’
08:08:53 <lambdabot>     Perhaps you meant ‘StateT’ (imported from Control.Monad.State)
08:09:21 <tdammers> merijn: in that case, I rather opt to import Prelude hiding
08:09:26 <Pythonfant> oatsadn: State is only a function from an initial state to a tuple of a value and another state
08:09:26 <michaelt> oatsadn: It gets a value when you apply runState to the whole thing. -- That gives you a function, which you then apply to the 'initial value'
08:09:51 <Pythonfant> while your in the state monad your creating such a function
08:10:06 <Pythonfant> so get just gets the input parameter of that function
08:10:19 <merijn> oatsadn: My usual advice to udnerstanding state is implementing the monad instance yourself, it's very educational and it's hard to implement something that typechecks but is wrong
08:11:41 <merijn> oatsadn: Homework: implement the following functions and Monad instance: "data MyState s a = MyState (s -> (a, s))", "get :: MyState s s", "put :: s -> MyState s ()", "modify :: (s -> s) -> MyState s ()" and "instance Monad (MyState s) where"
08:12:45 <oatsadn> ok thanks. i’ll try and implemnet it
08:12:46 <kgadek> hi. any ideas how to fix this? https://gist.github.com/c2393a0b1c6505b65dfb this is inside of docker, Fedora 20
08:12:59 <Ankhers> What does !Text mean exactly?
08:13:03 <merijn> oatsadn: Don't hesitate to ask hints here when you get stuck, but the further you get on your own, the clearer things will be. If you don't understand what a function's supposed to do, grab a piece of paper, write out the type and manually expand things, for example my replacing "MyState s a" with "(s -> (a, s))" in your types
08:13:09 <merijn> Ankhers: Strict field
08:13:18 <Ankhers> merijn: Thanks.
08:13:36 <kgadek> (GHC 7.8.3, cabal 1.20.0.3)
08:13:50 <michaelt> kgadek: this looks like a new vs. old Typeable thing?
08:14:05 <oatsadn> merijn: ok thanks for the advice
08:14:36 <rufs> merijn: I don't think I understand your last advice. The FromRow typeclass is defined in the postgres-simple package and I need to make my types an instance of this to have the database-data "automatically" converted to my types when executing the queries. Since the implementation of these instances depends on the order of the data, that is decied by my queries, it feels safer and easier to have them all in the same module (The queries are also d
08:14:36 <rufs> efined here) in case something has to change.
08:15:08 <rufs> but if orphans is not a big issue, i think I will keep it this way
08:15:35 <merijn> rufs: I meant that when you write "instance Foo Bar where foo x = y" you don't have to write the actual implementation code inside that instance block
08:15:55 <merijn> rufs: i.e. "instance Foo Bar where foo = myFooImplementationInAnotherModule" is perfectly legal
08:16:02 <kgadek> michaelt: oh yeah, that changed… so… yeah, thanks :)
08:16:24 <michaelt> kgadek: yeah, the package needs to be updated to take account of the new typeable.
08:16:38 <merijn> Although, tbh I have no clue what the FromRow typeclass looks like, so I dunno how relevant that is for you :)
08:18:30 <rufs> merijn: oh I didn't think about that, that could be something useful. I'm going to try that and see if it feels better or worse, thx
08:19:57 <merijn> rufs: That way you keep the actual instance with the datatype, but the code in the location you think makes sense. Although, as I said, that may lead to recursive imports, which might be a problem?
08:20:28 <Ankhers> I know why this doesn't work (width/height aren't keys in the json). How would I go about 'extracting' it to put in the proper place? http://lpaste.net/108365
08:21:22 <Ankhers> Assuming I currently only care about the first element in the list.
08:23:26 <rufs> merijn: yeah I think that might lead to a recursive import problem
08:23:44 <rufs> hm or maybe not
08:25:11 <rufs> btw the FromRow typeclass is implemented something like this, instance FromRow MyType where fromRow = MyType <$> field <*> field. so its just a mapping from each column of a row in the database to match the type constructor
08:25:14 <michaelt> kgadek: https://github.com/korrix/protocol-buffers
08:25:20 <sivteck>  /join #fp
08:25:31 <sivteck> sorry, ignore.
08:25:31 <rufs> where field is one column
08:26:06 <rufs> well, I got my answer, I just have to try it out to see what's best
08:27:41 <michaelt> kgadek: actually, that isn't really done properly
08:28:50 <rufs> I meant data constructor
08:30:57 <amar> Guys, is there any good showcase of Haskell example codes/best practices?
08:34:32 <lf94> amar: There's basically only one way to write Haskell
08:36:23 <tac> lf94: that is an utter lie
08:36:37 <tac> Haskell supports a ton of exotic coding styles
08:36:53 <tac> and no serious attempts have been made to establish a notion of "best practices"
08:37:32 <edwardk> tibbe has a style guide
08:37:35 <lf94> tac: I meant basic haskell
08:37:37 <edwardk> i just tend to ignore it though
08:37:44 <edwardk> so i'm not sure what that says
08:37:46 <tibbe> edwardk: cause I code in style! ;)
08:38:03 <xyh> hehe
08:38:07 <tac> with basic haskell, there are a lot of design choices that simply don't exist in imperative languages
08:38:14 <tac> more with more extensions
08:38:27 <tac> but you have the option of "Do I put this in IO? or do I put it in State s?"
08:38:37 <tac> or "pointfree? or pointful?"
08:38:54 <tibbe> there are some patterns if you look at code written by prolific contributors, such as bos, dcoutts, don stewart, etc
08:39:04 <tac> And the issue of "how do I report failure" is a total wildcard
08:39:07 <EvilMachine> Which type do I pick to store floating-point audio sample streams? (Data.Vector.Unboxed.Vector Float) or ByteString or something else?
08:39:13 <tibbe> we have patterns for parsing libraries and some other common tasks
08:39:21 <edwardk> anyways, if having some reasonable set of guidelines motivates you then by all means skim tibbe's guide. almost every stance it takes is reasonable ;)
08:39:25 <tibbe> EvilMachine: vector
08:39:27 <tac> tibbe: yeah. I'm not saying some people are setting good examples :)
08:39:37 <tac> Just there is not a lot of writing or explicit mention on the matter in FP
08:39:38 <tibbe> :)
08:39:39 <unsymbol> during a code review today a colleague suggested i removed all my qualified imports. what's the preferred import style?
08:39:48 <EvilMachine> tibbe: is Vector as efficient as Map in terms of modifying the streams?
08:39:49 <tibbe> we should write down some of these patterns
08:39:57 <levi> I think there are a couple of highly-disagreeing haskell style guides. ;)
08:40:25 <levi> It's a sign of a mature language; see C style guides. ;)
08:40:33 <EvilMachine> unsymbol: Why would he suggest such a thing? Did he back that up or just state it like it’s a dogma? ^^
08:41:11 <EvilMachine> levi: Does “mature” include 100-year-old ladies? :D
08:41:43 <unsymbol> EvilMachine: he told me it was the preferred style. i settled on explicitly saying which fns i was using with parenthesis but i prefered import qualified X.
08:42:38 <unsymbol> also... i am newb.
08:43:45 <EvilMachine> unsymbol: Clearly he doesn’t even know why “it is the preferred style”. I generally don’t listen to statements that aren’t backed up by the advantages and disadvantages of that choice.
08:44:32 <tibbe> my style guide is mostly extracted from the style of don, bryan, duncan, etc (e.g. the style used in real world haskell)
08:46:16 * c_wraith makes a note to import qualified every module as Imported
08:46:28 <EvilMachine> unsymbol: I’d import unqualified unless there are name conflicts for the simple reason that it’s just less stuff to write and to read, and serves no purpose if it doesn’t resolve ambiguity.
08:46:37 <tibbe> EvilMachine: vector are efficient to change in bulk (but for single element edits)
08:46:42 <unsymbol> EvilMachine: the suggestions was to only use qualified when there's a conflict. i still prefer qualified because there's no ambiguity -- which might be because i'm still a beginner.
08:46:59 <ciaranm> unsymbol: i bet you like java too!
08:47:17 <unsymbol> ciaranm: no, i just suffered ruby for too long.
08:47:21 <EvilMachine> tibbe: Perfect. That’s exactly my most common usage scenario.
08:47:38 <tibbe> EvilMachine: but immutable unboxed vectors are good for floating point data
08:47:42 <int3__> tibbe: just curious, which editor do you use?
08:47:48 <tibbe> int3__: emacs
08:48:25 <unsymbol> ciaranm: it's obviously jarring to the eye with the explicit imports (if you'll pardon the pun).
08:48:26 <int3__> tibbe: ah. I have a mostly-working vim indentation script that does the half-indented `where`, but it was kind of tricky to get right
08:48:28 <EvilMachine> unsymbol: GHC doesn’t let you use identifiers that are ambiguous. It won’t compile and complain.
08:48:35 <c_wraith> unsymbol: The reason unqualified is prefered is that qualified imports *greatly* reduce code readability.
08:48:46 <tibbe> int3__: tricky in emacs too, but someone else did it for me
08:48:49 <c_wraith> unsymbol: especially with operators.
08:48:52 <glguy> unqualified imports are OK if you're using a few well known modules
08:48:57 <Guest24309> I liked your-style-way of the community
08:49:01 <int3__> tibbe: ha that's convenient :)
08:49:06 <unsymbol> c_wraith: that is very true. it does become incredibly noisy.
08:49:09 <glguy> qualified imports are useful when there are a lot of modules and you don't want people to have to memorize which modules export which names
08:49:15 <EvilMachine> unsymbol: So it’s never ambiguous. (Try it with ByteString.)
08:49:31 <dzhus> can the TypeLits solver expand parens like ((n + m) - m) ~ n?
08:49:38 <unsymbol> EvilMachine: oh sure, perhaps i used the incorrect term. i know ghc will complain.
08:49:46 <levi> I like tibbe's style guide, but if you want to see an alternative, there's another one here: https://github.com/chrisdone/haskell-style-guide
08:50:16 <Exio4> if you use just one or two (or a few) i'd import just the functions that you need :P
08:50:38 <EvilMachine> tibbe: hmm, I need random access. (Think: A tree of audio streams that are used similar to how files in a directory structure are.)
08:51:14 <tibbe> levi: most important is to be consistent and respect the style of the project you’re contributing to
08:51:26 <tibbe> EvilMachine: random reads or also writes?
08:51:33 * tibbe has a fever so he’s not very clever right now
08:51:55 <levi> tibbe: I agree
08:52:38 <EvilMachine> unsymbol: Hey, do whatever you like the most. You’re a newbie and if that makes it easier for you for now, then go with it. It’s likely to change when you get more experience, but that’s not where you are right now. :)
08:53:06 <EvilMachine> unsymbol: Unless of course you have a team and it would be tedious for everyone else.
08:53:42 <unsymbol> EvilMachine: ha! :)
08:53:48 <EvilMachine> tibbe: Well, it’s part of a media editor. (Streams of samples, in a tree.)
08:54:24 <tibbe> EvilMachine: if you really need random mutation and the arrays are large, use unboxed mutable vectors
08:54:42 <tibbe> if they’re not so big, an intmap might work but it’s likely not memory efficient enough for audio samples
08:54:44 <levi> unsymbol: Personally, I mix all sorts of import styles together depending on what I'm importing. I figure the flexibility in the module import language is there for a reason.
08:54:53 <EvilMachine> unsymbol: But don’t forget that you have a right to have a nice life too. So if you just can’t work with unqualified imports for now, people have to accept that too. :)
08:55:58 <EvilMachine> tibbe: Yes, the arrays go from a few megabytes to gigabytes, in total it will have to be prepared for at least terabytes.
08:56:36 <tibbe> EvilMachine: terrabytes? will you have everything in memory?
08:56:41 <tibbe> how much do you hold in memory at once?
08:56:43 <levi> I mostly only use qualified imports when I need them to resolve ambiguity, such as with packages that shadow Prelude names.
08:57:03 <unsymbol> EvilMachine: i think i just needed a bit of negative pressure to perturb the homeostasis of my newbness. it worked, i think!
08:57:22 <joe9> Is there a better way of writing this code: http://codepad.org/E6786ljt . I feel that I am not using the OverloadedStrings functionality. Do I need the B.toString . L.toStrict in line 29?
08:57:35 <EvilMachine> tibbe: Hmm, I have to rethink the thing a bit.
08:57:50 <levi> When I am using less-common functions from some module, I'll tend to import those explicitly so I can see at the top of the file where they came from.
08:58:08 <joe9> It does not compile without them. But, just wanted to check why the OverloadedStrings functionality lets me write it as "return . responseBody"
08:58:21 <joe9> s/lets/does not let/
08:58:48 <EvilMachine> unsymbol: Nobody needs negative pressure. It can always be replaced by positive attraction due to the whole thing being relative. (I know my psychology.)
08:58:51 <EvilMachine> :)
08:59:34 <levi> Also note that you can import a few things explicitly unqualified and then import the rest qualified. I do this sometimes to avoid qualifying all my 'ByteString' references and imported operators and such.
08:59:37 <joe9> there is a tool to generate qualified imports.
08:59:44 <joe9> I found it very useful.
09:00:54 <levi> There are a number of useful formatting and stylistic hint/help tools. There stylish-haskell and hlint, among others.
09:00:56 <EvilMachine> tibbe: In a perfect world, I’d want it to be “transparently persistent”. (Think non-volatile RAM and no need for hard disks.) I have to ponder how to do it in the real world though.
09:01:00 <levi> s/there/there's/
09:01:01 <joe9> ghc  -ddump-minimal-imports  ..
09:01:13 <EvilMachine> tibbe: (Remember core memory? :)
09:01:26 <levi> EvilMachine: Memristors! :P
09:01:49 <EvilMachine> levi: Memristors FTW! :D
09:03:22 * EvilMachine hates the need for serialization and the like.
09:03:51 <Exio4> Data.Binary to the rescue?
09:04:49 <EvilMachine> (Also, if functions are first-class values, and they are obviously part of the RAM of a program, then they can be swapped to hard disk, ergo they must be serializable. (Chunks of executabe machine code?)
09:04:52 <EvilMachine> )
09:05:47 <athan> EvilMachine: GHC-server...?
09:06:15 <EvilMachine> Anyone up for implementing <instance Serialize (a -> b)>? ^^
09:06:48 <athan> EvilMachine: `curry`?
09:06:49 <levi> EvilMachine: Persistence is also an integral part of capability security OS models.
09:07:13 <pseudolio> Dumping part of memory to disk is different than serializing.
09:08:02 <EvilMachine> pseudolio: I know. Hence me disliking serialization. It already has a structure in memory. Just dump that sh*t! ;)
09:08:03 <athan> pseudolio: Where serializing is an isomorphism?
09:08:35 <EvilMachine> athan: The websites I found are very vague on what GHC-server is…
09:08:47 <pseudolio> Have fun with every garbage collection crawling your hard drive looking for references it needs to keep around because you 'serialized' it.
09:09:00 <EvilMachine> pseudolio: lol
09:09:40 <carter> EvilMachine: you might wanna use storable arrays
09:09:42 <carter> and mem mapping
09:09:46 <carter> even that will be wonky
09:09:56 <EvilMachine> pseudolio: I implemented a garbage collector in bash for a map implemented as files in a directory and softlinks, so I think I am crazy enought to handle that. ;))
09:10:20 <EvilMachine> carter: Sounds nice.
09:10:38 <carter> i started work on a "pure mem mapped storable array" thing
09:10:47 <carter> but haven't had time to make it usable
09:10:49 <athan> EvilMachine: https://github.com/chrisdone/ghc-server
09:11:01 <athan> EvilMachine: It's like a multi-client ghci (ie: lambdabot)
09:11:12 <carter> https://hackage.haskell.org/package/vector-mmap
09:11:16 <carter> is by copumpkin
09:11:18 <EvilMachine> I think I will just offer a random access interface and keep the whole actual memory and storage management internal. That way I never have to expose the whole shebang and don’t need the insanity. :)
09:12:26 <EvilMachine> athan: I am unclear about what it actually does. I send it code, it sends me compiled code back?
09:12:38 <EvilMachine> athan: ah, now I understand.
09:13:25 <EvilMachine> carter: But nice that something like that exists at all.
09:13:38 <carter> EvilMachine: i've a way of giving something like that a nicer ST interface
09:13:50 <carter> haven't had the time to finish it
09:14:11 <EvilMachine> carter: How does it handle e.g. random access to a terabyte-size vector? By streaming chunks from the disk and back?
09:14:37 <carter> EvilMachine: random access is a fiction at that scale
09:14:52 <carter> or you rent a big ass server
09:15:15 <carter> though i think the biggest servers you can sanely get only have ~ 1/2 TB of ram
09:15:18 <EvilMachine> carter: I meant raaaaaaaandoooooooooomm… *waits* … *waits some more* aaaaacceeeeeeessssss…ssssss…sss *snore*. :)
09:15:33 <joe9> can anyone please help with this? Could not deduce (b ~ Data.ByteString.Lazy.Internal.ByteString)  is the message, full message: http://codepad.org/qu2paMld , code: http://codepad.org/0oXRBdox . Isn't Data.BS.Lazy.Internal.ByteString not belong to the IsString typeclass?
09:16:10 <tac> joe9: Are you using Data.ByteString in your code?
09:16:14 <carter> EvilMachine: you'll still wanna chunk your work to make user of cacheline  / l1 / l2 / l3 cache siszes
09:16:22 <EvilMachine> carter: I don’t need anybody to serve me big ass. I already got plenty. :D
09:16:30 <tac> joe9: You probably need to import Data.ByteString.Lazy instead of the strict version, if I understand that right
09:16:46 <glguy> joe9: Your type signature says that the caller can pick which IsString instance he wants, but your code always returns a lazy bytestring
09:16:52 <EvilMachine> carter: Indeed.
09:17:00 <carter> EvilMachine: whats the work load again?
09:17:25 <joe9> glguy: oh, ok. let me check the code again (probably the httpLbs)
09:17:35 <carter> g2g for a while
09:18:13 <EvilMachine> carter: Think of a “file system” kinda tree, with different media streams as the leaves, and a editor interface, to cut, record, mix, process in arbitrary ways.
09:18:18 <glguy> joe9: The "right" solution would be to fix your type signature
09:19:02 <joe9> glguy: I can do that as in the commented line 17. But, in line 30, I am using B.toString . L.toStrict.
09:19:04 <maxiepoo> is there some kind of "avoid cabal hell" tutorial for library writers as opposed to users? Besides the pvp
09:19:08 <EvilMachine> carter: One that fills the entire hard disk.
09:19:16 <athan> maxiepoo: Sandboxes!!
09:19:24 <joe9> glguy: I was hoping that the OverloadedStrings functionality will take care of that conversion.
09:19:26 <c_wraith> athan: for library authors. :P
09:19:26 <maxiepoo> not for me avoiding cabal hell
09:19:35 <maxiepoo> for making sure my library doesn't cause cabal hell
09:19:45 <glguy> joe9: OverloadedStrings is different, it has to do with *string literals*
09:19:58 <c_wraith> Honestly, following the PVP is about as good as you can do, as a library author.
09:20:06 <athan> c_wraith, maxiepoo: Oh, derp. Um... I think michael snoyman made a dependency analyzing tool
09:20:14 <joe9> glguy: oh, not for just generic BS to String?
09:20:18 <EvilMachine> carter: (I don’t use a normal file system for reasons I don’t want to reveal as it would unnecessarily complicate my need to explain things a lot.
09:20:19 <EvilMachine> )
09:20:35 <c_wraith> Oh, and putting upper bounds on your dependencies.  A lack of upper bounds on your dependencies is pretty much guaranteed to cause cabal hell.
09:20:35 <glguy> joe9: No, it's not an automatic cast, just lets you use "this syntax" for things other than String
09:21:00 <joe9> glguy: ok, thanks. I misunderstood it to be an automatic cast.
09:21:25 <c_wraith> joe9: simple way to tell: haskell has no type-converting casts at all.  Ever.
09:21:43 <athan> c_wraith: I've been thinking about a simple api-breakage checker for versioning consistency :/
09:21:47 <joe9> glguy: this works fine: http://codepad.org/vwPxxyJK . but, not sure if that is the best way to do that.
09:21:51 <rwbarton> then be sure to update those bounds the moment they go out of date, otherwise you are the source of cabal hell
09:21:59 <maxiepoo> c_wraith, yeah I think lack of upper bounds is the culprit
09:22:05 <joe9> c_wraith: thanks.
09:22:57 <c_wraith> joe9: (though if you want to be really picky, the FFI has functions that do the same thing as pointer casting in C, when dealing with explicit pointers as used in C)
09:23:58 <joe9> c_wraith: ok, thanks.
09:24:31 <joe9> glguy: btw, just wanted to get your opinion on the code, please?
09:24:53 <joe9> glguy: this works fine: http://codepad.org/vwPxxyJK . Do you think that is a good way of writing it.
09:26:58 <rwbarton> also, please don't depend on 'base < 4.8' unless you hate your users
09:27:14 <bergmark> that's open for debate :-)
09:27:48 <rwbarton> yes, which is why I take special care to request it
09:28:06 <glguy> joe9: Seems fine. I might have done a few minor things differently, but nothing really to fuss about http://codepad.org/AocwSpCR
09:28:26 <glguy> I don't know the Conduit family of libraries
09:28:39 <joe9> glguy: cool, thanks for your comments. well appreciated.
09:34:25 <rwbarton> personally I would extend the list from base to any package which is a dependency of a non-upgradeable package (base, template-haskell, ghc)
09:35:11 <rwbarton> maybe ezyang's work on multiple instances of packages in a single program will make that obsolete some day, though
09:40:13 <maxiepoo> when using a cabal sandbox is there a way to install exe's globally ?
09:40:30 <hakujin> hslua on hackage has a flag -fsystem-lua that uses the user's system lua instead of the bundled copy. on Ubuntu, lua 5.1 is called lua5.1 and not just lua. Is there some way to pass a parameter to the cabal flag specifying the name of the system lua package?
09:40:36 <maxiepoo> right now I install exe packages in their own sandbox and then add the .cabal-sandbox/bin to my path
09:40:43 <maxiepoo> but I want to know if there's an easier way
09:41:03 <Kinnison> hakujin: If at all possible, see ifyou can make it use pkg-config since that'll widen its ability to be used in multiple places
09:41:23 <Kinnison> hakujin: of course, it'll need to be able to use different pkg-config names too (debian/ubuntu is lua5.1, fedora is lua)
09:42:03 <nschoe> maxiepoo: from what I understand, cabal sandboxes' goal is precisely not to install globally, so it looks like a conflit to me, no ?
09:42:23 <maxiepoo> nschoe, but I just want the executable to be available globally
09:44:28 <int3__> maxiepoo: I usually install to my user dir unless it will create a conflict
09:44:33 <nschoe> maxiepoo: maybe you can create ~/bin directory, permanently add it in you $PATH and when you want such an executable to be available globally, either cabal build it and then manually copy it to that ~/bin or I'm sure this is possible to so smth like cabal configure --prefix=~/bin and then cabal install
09:45:04 <maxiepoo> couldn't there just be a cabal switch to make it install the exe into ~/.cabal/bin
09:45:05 <maxiepoo> ?
09:45:19 <nschoe> maxiepoo: I think this is the role of cabal configure
09:45:25 <nschoe> (but I'm not entirely sure)
09:46:01 <nschoe> maxiepoo: http://www.haskell.org/cabal/users-guide/installing-packages.html#setup-install does this help ?
09:46:18 <nschoe> Maybe try cabal install --global
09:46:33 <nschoe> I don't now if that works form inside a sandbox, but that's worth the try ?
09:47:18 <nschoe> maxiepoo: ah ! http://www.haskell.org/cabal/users-guide/installing-packages.html#installation-paths Maybe that's better
09:48:06 <nschoe> From what I understand (2-minute read only), you can do cabal configure --prefix=/my/custom/exec/path ; cabal install
09:49:25 <maxiepoo> I think --bindir is what I need
09:49:43 <maxiepoo> but I'm hoping there's just a single flag you can do to make it do --bindir=~/.cabal/bin
09:50:08 <maxiepoo> just because I want to tell users to do this so I want to make it work without changing anything if possible
09:50:33 <nschoe> maxiepoo: Sorry to ask, but why? Is it so hard to type that command ? Or maybe make a alias in your .bashrc ?
09:51:08 <maxiepoo> it's not hard for me, but it wouldn't work in Windows for example
09:51:09 <nschoe> maxiepoo: I would not put it in ~/.cabal/bin, though. Here are GHC-registered packages, it could be a mess if some bins were in this folder but not registered
09:51:44 <maxiepoo> nschoe, but it's just the executables, so it won't mess anything up, would it?
09:52:33 <nschoe> maxiepoo: not I don't think it would mess anything. But it still feels odd. If you need to inspect the registered packages someday, and compare the folder, it would not match.
09:52:38 <nschoe> But again, it's your choice here :-)
09:57:32 <hakujin> Kinnison: thanks, again. It currently uses pkg-config but I don't see a way to pass a parameter to a cabal flag. http://www.haskell.org/cabal/users-guide/developing-packages.html#configurations looks like flags are boolean. how can I pass the parameter? (lua name)
09:59:25 * hackagebot snaplet-postgresql-simple 0.5 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-0.5 (DougBeardsley)
10:04:08 <halogenandtoast> Is it possible to define Just as a data constructor? I tried data MyJust a = MyJust a, but when I do MyJust 1 I get No instance for (Num a0) arising from the literal `1'
10:05:16 <dfeuer> Hmm... #ghc is not responding, so I'll ask here. Anyone know the difference between BuildFlavour=prof and BuildFlavour=bench? I'm looking to profile code I compile using the stage2 compiler; I'm not particularly interested in profiling the compiler itself.
10:05:20 <dfeuer> halogenandtoast, yes, it is.
10:06:04 <Cale> halogenandtoast: Your error message there is unrelated to your definition of MyJust
10:06:31 <dfeuer> halogenandtoast, your problem is that in context, the compiler doesn't know how to decide what *type* of number you intend 1 to be.
10:06:36 <Cale> halogenandtoast: The definition of the Maybe datatype in the Prelude looks like:  data Maybe a = Nothing | Just a
10:07:32 <dfeuer> But actually, this error message suggests something worse may be wrong with the context. Can you show us a little more code, halogenandtoast?
10:07:44 <David> Good morning!
10:07:52 <David> I'm wondering what's the neatest way to do this in haskell:
10:08:11 <Cale> yeah, it looks like halogenandtoast did something like  x :: MyJust a; x = MyJust 1  or something
10:08:14 <David> I have a list of the form [[Int], Data]
10:08:33 <Cale> In which case the solution is to replace a with Integer, or add a type class constraint
10:08:47 <halogenandtoast> dfeuer: Sure, but (Just 1) returns (Just 1) I don’t have to tell it what type.
10:08:55 <Cale> David: I'm assuming you mean [([Int], Data)]
10:09:13 <Cale> halogenandtoast: Are you doing this in ghci?
10:09:14 <David> and I'd like to turn it into a tree, such that the [int] of each element points to the location of the node containing the Data in the tree, e.g. [1,4,5,2] is the second child of the fifth child of the fourth child of the first child of the root
10:09:16 <David> Cale: right
10:09:18 <Cale> ghci> data MyJust a = MyJust a deriving Show
10:09:18 <Cale> ghci> MyJust 1
10:09:18 <Cale> MyJust 1
10:09:19 <halogenandtoast> Cale: yes.
10:09:23 <dfeuer> halogenandtoast, yes, it does, and MyJust will do the same thing, in general, but you seem to have done something that mucks it up, and we'd like to see what.
10:09:41 <halogenandtoast> Cale: ah
10:09:50 <David> (the tree is a Node = Leaf Data | Node Data [Node] type)
10:10:01 <halogenandtoast> dfeuer: it’s the deriving Show that was the proble,/
10:10:05 <halogenandtoast> *problem.
10:10:25 <Cale> halogenandtoast: That's interesting, if it were just that, you should have gotten an error like "No instance for (Show (MyJust a0)) arising from a use of ‘print’"
10:10:46 <dfeuer> No, I don't think the Show was the problem.
10:10:56 <Cale> (but it could be partly that)
10:11:05 <David> Is there a neat, clean way to do it?
10:11:23 <Cale> David: hmm, what happens if there are missing nodes in the list?
10:11:36 <halogenandtoast> Cale: I copied the 2nd error message it seems
10:11:40 <halogenandtoast> Didn’t scroll up far enough
10:11:45 <rwbarton> my guess: halogenandtoast wrote an "instance Show (MyJust a)"
10:11:53 <dfeuer> Indeed. That representation seems difficult, David.
10:11:59 <Cale> David: Or are we simply guaranteed that there aren't? :)
10:12:25 <dfeuer> Or what if there are duplicates, David?
10:12:47 <dfeuer> (Two data things with one location?)
10:12:59 <David> Cale: I can guarantee there aren't duplicates or missing nodes
10:13:02 <Cale> okay
10:13:15 <David> this is the output of a CSV that I'm generating using some other code that I'm writing
10:13:19 <David> so I control the input
10:13:35 <David> a parsed CSV*
10:14:10 <Cale> Do you need that Leaf case in your tree type?
10:14:24 <Cale> Node Data [] also works as a leaf
10:14:34 <dfeuer> David, I would speculate that there are two reasonable ways to approach this: 1. First sort the list into depth-first order and then build the tree. 2. Use a "zipper" to build the tree iteratively.
10:14:58 <David> Cale: doesn't matter, I can change from Leaf to Data [] with one traversal
10:15:22 <David> dfeuer: I'm interested in (2) since (1) is n log n time and (2) seems to be linear time
10:15:37 <dfeuer> It's not linear time.
10:15:39 <lf94> How can I use Chart on debian wheezy?
10:15:42 <Cale> (2) will probably be much more expensive
10:16:05 <Cale> It's probably O(n^2) worst case, I think?
10:16:26 <David> oh, because you have to repeatedly traverse the saem nodes several times?
10:16:30 <Cale> yes
10:16:45 <tbmcmullen> Hello! I have a question about how to combine generic recursion schemes and the state monad. Is this a reasonable place to ask?
10:16:46 <Cale> You might have to bounce back and forth between the leftmost and rightmost nodes
10:17:01 <dfeuer> Cale is right. Forget that idea.
10:17:44 <David> So let's say I have a sorted list. What's the nicest way to do build the tree using a DF traversal?
10:18:06 * dfeuer wakes up and points David to "trie".
10:18:35 <David> oh, cool, thanks dfeuer
10:18:59 <David> thanks Cale as well :)
10:19:12 <Cale> Wait, where is that package?
10:19:35 <Cale> It probably would make sense to use an existing trie implementation, if that's what you're after
10:19:41 <David> unfortunately not possible
10:19:52 <David> the data structure I need is a bit more complex than that
10:20:27 <David> (the general idea being that all nodes have a single "main child")
10:21:02 <Cale> I'd probably just do something just a bit inefficient but easier to program than the optimal thing, which is to first construct a Data.Map from the list, and then use lookups into that to recursively generate the tree
10:21:12 <Cale> I can hack that up in a sec if you want.
10:21:30 <David> data Dag = Dag {
10:21:30 <David>                 dfsMemSize :: Int,
10:21:30 <David>                 bfsMemSize :: Int,
10:21:30 <David>                 stepType   :: Step,
10:21:31 <David>                 children   :: [Dag],
10:21:35 <David>                 nextStrand :: Dag,
10:21:37 <David>                 location   :: String
10:21:39 <David>                }
10:21:41 <David>             | Leaf Int
10:21:48 <David> is the data structure I'm dealing with
10:21:50 <David> whoops, sorry about that... thought I joined the lines
10:22:24 <David> I think I can extend the trie idea a bit
10:22:30 <David> in order to accomodate nextStrand
10:22:45 <dfeuer> Cale, I didn't mean a package called "trie", but a data structure by that name that surely appears various places in Hackage.
10:23:05 <lf94> How can I use Chart on debian wheezy?
10:23:28 <Cale> lf94: The same way you'd use it on any other linux system?
10:23:38 <Cale> lf94: I'm not sure what your question means :)
10:23:50 <dwcook> lf94, are you still having that same compile error?
10:24:02 <lf94> It means the examples of using Chart on the internet do not work on debian wheezy
10:24:18 <Cale> lf94: Define "do not work"
10:24:27 <dwcook> It's probably related to your GHC version or something similar rather than your distro
10:24:29 <lf94> Can't compile
10:24:40 <lf94> dwcook: I know, I tried getting ghc 7.6.3
10:24:44 <Cale> lf94: I can't do much for you if I don't have an error message
10:24:53 <lf94> But what do you know, debian doesn't have libgmp.3.so
10:24:54 <Cale> lpaste.net :)
10:24:57 <dfeuer> lf94, one thing that can happen is that the API may have changed, and you could be looking at old documentation/examples.
10:25:07 <dwcook> lf94, it does, sort of
10:25:17 <dfeuer> lf94, what version are you using, then?
10:25:20 <dwcook> Hmm, let me check what package I used
10:25:25 <lf94> I have installed libgmp3-dev, but that does nothign
10:25:38 <dwcook> lf94, do you have a package named libgmp-dev?
10:25:41 <dwcook> I think that should suffice
10:25:53 <Cale> lf94: Oh, that's easy to fix. If you can't get a build which uses that version, you can even symlink libgmp.10.so to it and it's compatible enough that I've never run into an actual problem with that.
10:25:53 <lf94> dwcook: I can't even find libgmp on my system even though I installed every libgmp* package lol
10:26:11 <Clint> lf94: dpkg -L libgmp10
10:26:30 <orion> I was reading an article about Warp, and I came across this statement: "Unlike an MVar, an IORef is simply a mutable variable without any locking. However, it provides an atomic modify operation, which takes advantage of Haskell's referential transparency to avoid race conditions without locking." -- how does referential transparency remove the need for locking?
10:26:46 <lf94> Ah, there it is
10:26:54 <lf94> ok symlink here I go
10:27:39 <Cale> orion: Well... the first thing to know is that values are pointers to code
10:28:14 <Cale> orion: effectively, the runtime representation of expressions (thunks) are pointers to code, which when entered for the first time, will:
10:28:18 <orion> Cale: You're saying that "5" is a pointer to code?
10:28:21 <lf94> ok worked, make installing ghc 7.6.3
10:28:33 <Cale> 1) Set the pointer to point at a "grey hole" (which I'll talk about in a moment)
10:28:37 <Cale> 2) Compute the value
10:28:39 <lf94> Man so much work just to get Chart working
10:28:59 <Cale> 3) Reset the pointer to point at a short piece of code which will immediately return the computed value (for next time it's needed)
10:29:04 <sjouke> what are the arguments against SOLID design? i remember hearing a guy from the functional programming community shuttering when he heard Kiskov substitution mentioned
10:29:54 <Cale> 4) Return the computed result
10:30:19 <int3__> ./dist/build/bench/bench +RTS -p
10:30:22 <int3__> bench: unexpected RTS argument: "-p"
10:30:25 <int3__> ... why?
10:30:49 <sm> int3__: need to build the executable with profiling enabled
10:30:54 <Cale> Now, in the unthreaded runtime, the grey hole is instead a black hole: if in order to compute x, you need to compute x, then you're in an infinite loop, and an exception gets thrown (which is what that <<loop>> exception is, if you've ever seen one of those)
10:30:57 <int3__> sm: I'm pretty sure I did that
10:31:16 <Cale> But in the threaded runtime, it might be the case that two different threads both want the value of x at nearly the same time
10:31:31 <michaelt> tbmcmullen: This is a reasonable place to ask, though at different times different people are around; some may be more helpful...
10:31:39 <Cale> So, instead, the grey hole will block and wait for the value of x to be computed.
10:32:00 <int3__> yup, I did 'cabal configure --enable-executable-profiling' and still get the same error from `bench`
10:32:20 <lf94> ITS WORKING I THINK
10:32:26 <rwbarton> and 'cabal build'?
10:32:28 <Cale> So, instead of an exception, you get a 0% CPU hang if it's actually an infinite loop, or if it's just that two threads are trying to get the value at once, then one will wait for the other
10:32:34 <sm> int3__: if bench +RTS --help doesn't list -p, it didn't work
10:32:53 <Cale> Okay, but anyway, this means that an IORef can just be a simple pointer
10:33:00 <sm> I'd add --enable-library-profiling (-p) as well
10:33:00 <rwbarton> or perhaps you did 'cabal clean' in between, that resets your configuration (surprise!)
10:33:06 <michaelt> int3__: oh wait, is it because you need -rtsopts too? Or does cabal take care of it
10:33:13 <Cale> which gets updated to point at a different thunk
10:33:35 <rwbarton> or if you did 'cabal install' instead of 'cabal build', that will reconfigure also
10:33:39 <tbmcmullen> michaelt: thanks.
10:33:58 <Cale> or sorry, the pointer simply *is* the thunk
10:34:04 <michaelt> int3__: oh wait that would be a different error
10:35:19 <Cale> So, when you update an IORef, you can write that memory atomically with a new pointer
10:35:22 <tbmcmullen> So I'm doing something very similar to what is described in http://patrickthomson.ghost.io/an-introduction-to-recursion-schemes/. Which seems great... I can write tiny functions to modify my AST and it works well. However, now I would like to recurse through my AST and collect information about it (e.g. with the Writer monad)... but I have no idea how to layer that onto generic recursion functions.
10:35:59 <quchen> Cale: Even the threaded runtime can detect <<loop>> now. Maybe less often so than the non-threaded one, but still it's quite a useful thing to have.
10:36:07 <Cale> quchen: Ah, good point
10:36:24 <Cale> Yeah, if there are no references to the thing elsewhere, it can detect that
10:36:27 <int3__> tbmcmullen: are you using the recursion-schemes library?
10:36:50 <quchen> Cale: I haven't tried complicated programs with loops yet, but in my experience if you have a loop in a single-threaded exe then it'll occur as well when you link with -threaded.
10:37:11 <tbmcmullen> int3__: I'm not. Just the topDown and bottomUp functions as described in the article.
10:37:15 <Cale> *anyway*
10:37:28 <quchen> Sorry, didn't mean to interrupt your valid point there :-)
10:37:34 <Cale> No, it's fine
10:37:45 <Cale> It's just my whole original description was already a bit of a sidetrack
10:38:23 <int3__> sm: michaelt: sort of solved, I initially configured cabal to compile with the flag -with-rtsopts="-p", and GHC didn't seem to like that for some reason. then after I removed the flag I didn't reconfigure / rebuild. 'cabal clean' fixed things :)
10:38:44 <Cale> So, because expression evaluation works like this, rewriting an IORef to be a new expression is something which can be done atomically -- you're just rewriting a single pointer.
10:39:16 <dwcook> sjouke, I didn't know what SOLID was before you mentioned it, but as far as I can tell it simply doesn't apply to Haskell, at least as-is. Precious little OOP is done in Haskell.
10:39:25 <Cale> Now, if things weren't pure, well, hmm, how might that affect this...
10:39:45 <dwcook> sjouke, Haskell's type system doesn't allow for subtyping, for example.
10:39:53 <michaelt> tbmcmullen: what functor are you using in Term f?  You might get what you want by some general morphism f x -> g r or something
10:40:14 <dfeuer> Cale, I don't understand that aspect either. In fact, I think you're mixing up parallel with concurrent here.....
10:40:23 <Cale> It would at least be a bit weird, but I guess not much weirder than the BS that programmers working in impure settings already put up with?
10:40:33 <dfeuer> That mechanism you described makes a lot of sense for par and such.
10:40:40 <rwbarton> really it depends on support for laziness I think
10:40:47 <Cale> dfeuer: I'm not the one mixing it up, if so
10:41:18 <Cale> dfeuer: We're talking about how IORefs work in the face of a threaded runtime
10:41:32 <tbmcmullen> michaelt: sorry, I don't totally follow that question. What do you mean by "what functor"? I'm using DeriveFunctor.
10:41:37 <dfeuer> I think concurrent Haskell stuff needs locking or CAS or STM or whatever just as much as any other language.
10:41:49 <Cale> Yeah, it's the support for laziness and polymorphism which is being used to provide that operation
10:42:08 <michaelt> tbmcmullen: I mean in the position of Expr , you cant use bottom up without a functor like Expr
10:42:46 <tbmcmullen> Oh. Yes. I'm using Node. Which is fairly similar to Expr.
10:43:27 <Cale> Well, okay, supposing that you could put some kind of large unboxed complicated data structure in an IORef, and then mutably update that, then you could have real problems with atomic update, because it would be an arbitrarily large amount of memory you're updating, so that would require locking.
10:43:54 <Cale> But because things are boxed, that doesn't happen.
10:43:59 <quchen> Cale: So what's the difference between modifyIORef and atomicallyModifyIORef?
10:44:26 <quchen> (I avoided IORefs in non-thread-local functions so far because they scare me.)
10:44:30 * hackagebot network-simple 0.4.0.1 - Simple network sockets usage patterns.  http://hackage.haskell.org/package/network-simple-0.4.0.1 (RenzoCarbonara)
10:45:20 <Cale> Well, the difference is that atomicModifyIORef does both the read and write in an atomic way
10:45:21 <c_wraith> quchen: the atomic version inserts proper memory barriers such that it actually has coherence guarantees.  It also guarantees that the operation it performs as a read/write pair is atomic.
10:45:33 <tbmcmullen> michaelt: would it be useful for me to post some example code?
10:45:37 <dwcook> sjouke, although I can tell you one point where I think it would be insane to follow O in Haskell: Datatypes are closed for a reason. If I accept a Maybe String, I expect to be able to pattern match on it to check for Nothing or Just someString. If someone could give me something besides those two things it'd muck things up.
10:46:02 <quchen> c_wraith: What's the difference compared to modifyMVar then?
10:46:03 <Cale> If you're *just* doing a read or just doing a write, those are already atomic operations.
10:46:19 <c_wraith> quchen: modifyMVar blocks.  atomicModifyIORef does not
10:46:21 <Cale> quchen: The difference is that MVars are totally different :D
10:46:23 <dwcook> sjouke, we do have open classes, however, such as typeclasses.
10:46:42 <michaelt> tbmcmullen: yes, of course; there is lpaste.net for example
10:46:50 <Cale> Yeah, none of the operations on IORefs can block
10:46:51 <quchen> Cale: I see quite the similarity here.
10:46:52 <c_wraith> quchen: in particular, atomicModifyIORef doesn't stop any other writes to the same IORef.  It just restarts if it was modified.
10:47:05 <Cale> Whereas pretty much any operation on an MVar can block
10:47:30 <c_wraith> I mean, atomicModifyIORef *can* block indefinitely, but it doesn't stop other operations on the same IORef
10:47:39 <quchen> c_wraith: "restarts". Now that makes me think of STM. I have a good mental model of MVars and STM, but IORefs take this weird intermediate spot at times.
10:47:56 <dfeuer> You have to be careful, though. If you have a long-running modification, it may start over and over without ever completing if something else is diddling the IORef rapid-fire.
10:47:58 <Cale> c_wraith: Wait, how?
10:48:48 <c_wraith> quchen, Cale: operationally..  It reads from the IORef.  It creates a thunk representing the function applied to the IORef. It uses an atomic compare and swap operation to update the IORef if it still is pointing to the same thing it did when it read.  Otherwise, it loops.
10:48:57 <dfeuer> Cale, because it's ... evail.
10:49:00 <dfeuer> evil.
10:49:18 <sjouke> thanks dwcook
10:49:23 <Cale> c_wraith: aha, okay
10:49:26 <Cale> Right
10:49:32 <dfeuer> It's actually blocking, but using non-blocking operations, so it busy-waits.
10:49:39 <c_wraith> quchen: the difference is STM gives you those semantics across an entire transaction, whereas atomicModifyIORef only applies to that single read/write operation.
10:50:06 <int3__> tbmcmullen: maybe you could make your Functor a Traversable, then have bottomUp fn = out >>> fmap (bottomUp fn) >>> sequence >>> In >>> fn, then fn can return a Writer monad. (I just started learning this recursion stuff a couple of days ago so I'm fairly new at this too... but that seems like it'd work)
10:50:15 <quchen> c_wraith: Ah, that makes sense. So I can see "atomicallyModifyIORef" as quite similar to what STM would do, but not in a compositional manner.
10:50:16 <dfeuer> What's that called? A spinlock, right?
10:50:40 <c_wraith> Well, it's not a lock.  It's just spinning. :)
10:50:51 <c_wraith> quchen: that's accurate
10:51:07 <quchen> That's very handy to know, thanks.
10:51:19 <dfeuer> Still, it doesn't look like a primitive you could use for lock-free or wait-free algorithms.
10:51:29 <c_wraith> dfeuer: it's not
10:51:46 <dfeuer> [although if you're writing a wait-free algorithm, you're probably insane and need prompt psychiatric attention]
10:51:47 <quchen> c_wraith: So if I have a lot of `atomically (modifyTVar ...)`, i.e. STM blocks that simply update a single variable, is the IORef version preferrable?
10:52:10 <quchen> So far I put everything that needs some level of atomicity in TVars, as long as performance allowed it.
10:52:15 <tbmcmullen> michaelt: http://lpaste.net/9092137747757400064
10:52:23 <c_wraith> quchen: it's probably a bit simpler, but both are very susceptible to cascading overloads.
10:52:41 <tbmcmullen> stripGroups works well... collectWarnings doesn't, for obvious reasons, but I'm not sure how to modify things to make it work.
10:52:46 <c_wraith> quchen: in many ways, an MVar's blocking prevents a lot of worst-case bad behavior.
10:53:19 <int3__> tbmcmullen: I think sequence is what you want, yes
10:53:20 <tbmcmullen> int3__: Interesting... I started down that path, but hit the limit of knowledge pretty rapidly.
10:53:28 <tbmcmullen> of my*
10:53:36 <bennofs> tbmcmullen: what type do you expect collectWarnings to have?
10:53:45 <dfeuer> @tell michaelt What about  X.foldr Y.cons Y.nil  as opposed to  Y.unfoldr X.uncons ?
10:53:46 <lambdabot> Consider it noted.
10:53:47 <c_wraith> quchen: if you have a bunch of threads trying to atomically modify the same IORef or TVar constantly, you're likely to end up in the situation where lots of things start, and all but one of them retry, and then keeping doing that.
10:54:03 <bennofs> tbmcmullen: Term Node -> [String]  ?
10:54:16 <c_wraith> quchen: But each one uses CPU time when it restarts, resulting in throughput nosediving.
10:54:25 <quchen> c_wraith: Sure, but modifying a single TVar takes almost no time as long as you're not forcing the contents, no?
10:54:26 <tbmcmullen> bennofs: I'd assume Term Node -> Writer (Term Node) String or something of the sort
10:54:54 <c_wraith> quchen: an MVar has a lower max throughput, but it sustains that max throughput under overload conditions, instead of nosediving.
10:55:17 <bennofs> tbmcmullen: would the type Term Node -> [String] also work?
10:55:54 <michaelt> dfeuer: you want both. Different ones will be optimific for different libraries.  In vector V.unfoldr X.uncons is likely to fuse.
10:56:38 <tbmcmullen> bennofs: would be fine for me, but not sure how to make that work
10:56:45 <c_wraith> quchen: I'd only use an IORef for something accessed concurrently if the access pattern is many reads, few writes.
10:57:13 <quchen> c_wraith: Oh right, because you can't just read an MVar, you have to take and put it.
10:57:14 <tac> Has anyone used Wreq for Oauth2?
10:57:16 <michaelt> dfeuer: but if we have as a policy that they are both available, then there can be optimific back and forth without millions of fromX toX functions
10:57:30 <bennofs> tbmcmullen: well, it's possible to write a function   cata :: Functor => (f a -> a) -> Term f -> a
10:57:30 <tac> I'm trying to figure out how to call into Google's APIs with my Oauth credentials
10:57:40 <c_wraith> quchen: actually, I think base 4.7 made read an atomic operation - but it still locks the MVar
10:58:17 <tbmcmullen> bennofs: right right. The trouble is how to make that work with bottomUp/topDown, which are expecting a Term f -> Term f
10:58:22 <c_wraith> quchen: because the semantics of MVar require that all access to them be serial.
10:58:39 <bennofs> tbmcmullen: using that function, you can then write collectWarnings :: Term Node -> [String]. But I'm AFK for a short time now, so maybe just try to find the implementation of cata / collectWarnings yourself?
10:58:56 <bennofs> tbmcmullen: you cannot implement cata using bottomUp / topDown. You need to pattern match on Term
10:59:16 <tbmcmullen> ahh... interesting.
10:59:23 <tbmcmullen> bennofs: thanks for the help.
11:02:27 <deaddork> Hello! I just started learning Haskell, and I’m having a hard time googling ‘{-#…#-}’. What does that mean? E.G. “{-# LANGUAGE DeriveDataTypeable #-}”? (From <http://neilmitchell.blogspot.com/2010/08/cmdargs-example.html>)
11:02:37 <lpsmith> rufs, if your instances are part of a library you intend on distributing on hackage or otherwise be fairly widely used,   orphaned instances are a definitely a problem.
11:02:37 <lpsmith> rufs, as part of an application or an internal library,  you can get away with them.
11:02:38 <lpsmith> it's not that big of a deal
11:02:52 <Cale> deaddork: It's a compiler pragma
11:03:07 <deaddork> Gonna Google that. Thanks!
11:03:41 <Cale> deaddork: Basically, options which affect how the compiler builds the code. LANGUAGE is a required one for any modern compiler, and it selects which extensions to the language are enabled.
11:03:47 <mmachenry> Anyone know where I can find a good tutorial on ensuring that I have been strict where I should be in a large Haskell application?
11:04:09 <dfeuer> michaelt, will you end up deciding whether to fuse on the left or the right?
11:04:36 <Cale> deaddork: (Even if the compiler may not support every extension, though if you're using GHC, you pretty much don't have to worry about that :)
11:04:45 <mmachenry> I am currently writing a high-performance daemon that will run forever and I want to ensure I am free of space leaks. Particularly where they might creep up due to laziness.
11:05:49 <Cale> deaddork: In this case, the DeriveDataTypeable extension allows the Data and Typeable type classes in the deriving clause of a data declaration, which will automatically generate code for them based on the structure of the type.
11:06:05 <dfeuer> mmachenry, your best bet is probably to use the profiler.
11:06:05 <lpsmith> rufs, basically the main issue with orphaned instances is if there are multiple instances floating around,  which would almost certainly cause problems eventually.   There's no way of controlling the visibility of instances,  they are visible whenever an instance is within a transitive closure of module imports.
11:06:08 <michaelt> dfeuer: right, the user needs to be able to decide.  In the case of 'stream fusion' libraries  'unfold ' is basically the stream constructor so V.unfoldr f ~ unstream . Stream f
11:06:31 <Cale> deaddork: In newer versions of GHC, this is the required way to define instances of Typeable (as it's unsafe to write instances of that type class by hand)
11:07:29 <deaddork> Cale: Do you have any recommendations for reading up on this?
11:07:50 <lpsmith> Thus, requiring the instances are defined in the module that defines the type or the class,  guarantees a single unique instance as any other module declaring such an instance would have to import both those modules,  which would turn into an error.
11:08:05 <Cale> deaddork: https://www.haskell.org/ghc/docs/latest/html/users_guide/
11:08:06 <dfeuer> Cale, does that restriction take care of http://existentialtype.wordpress.com/2012/08/14/haskell-is-exceptionally-unsafe/ ?
11:08:17 <Cale> https://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#language-pragma
11:08:27 <Cale> deaddork: ^^ more specifically
11:08:29 <lispy> mmachenry: How does your daemon handle requests?
11:08:33 <Cale> dfeuer: yes
11:08:42 <Cale> dfeuer: That post is such a troll post :P
11:08:43 <lispy> mmachenry: Do you use threads for each? Do they share state?
11:08:50 <lispy> (well, share data)
11:08:52 <michaelt> dfeuer: so if I am going to use tons of vector operations on the vector thus introduced I will want unfoldr, not eg. ByteString.foldr V.cons V.empty
11:09:01 <dfeuer> Cale, I don't know enough about the issues involved to tell.
11:09:09 <Cale> dfeuer: He doesn't even appear to understand that the unsafety has nothing to do with exceptions at all
11:09:23 <joe9> Is there a way to derive default values to haskell records? I have a record with a bunch of String fields and am wondering if I could derive the default record using generics, or ..
11:09:32 <Cale> dfeuer: It's just with Typeable, which the exception library happens to use.
11:09:41 <mmachenry> lispy: Yes. There are several threads (about 12) and I'm using STM heavily.
11:09:59 <mmachenry> lispy: It is currently a TCP server
11:10:02 <dfeuer> michaelt, because the V.conses will be so expensive when they don't fuse?
11:10:17 <Cale> dfeuer: If you intentionally write bad instances of Typeable, you can make its otherwise-safe cast operation into an unsafe one, and cause segfaults.
11:10:39 <michaelt> dfeuer: yes, thats what Im thinking.
11:10:41 <shachaf> If you can make a certain sort of MD5 collision, you can do the same with the automatically generated instances!
11:10:44 <heyj> anyone use digestive-functors-blaze? I'm wondering if this is still the best method for making a list of checkboxes http://stackoverflow.com/questions/6436238/list-of-checkboxes-with-digestive-functors
11:10:47 <lispy> mmachenry: The big thing to avoid (and this isn't Haskell specific) is that values you use are not referenced at the end of the request. That way the GC can collect them. The thing that is Haskell specific is that thunks can point to values causing the GC to not collect them.
11:11:15 <Cale> shachaf: That's interesting. I wonder how hard it would be to pull that off :)
11:11:25 <dfeuer> michaelt, that does make a lot of sense, I think. Is there a typeclass for general sequence types?
11:11:52 <michaelt> dfeuer: I think a few too many, but none with general standing
11:11:52 <dfeuer> Hmm... Maybe that's not quite the answer.
11:11:55 <shachaf> Cale: I looked into it a bit and it's pretty tricky: https://ghc.haskell.org/trac/ghc/ticket/7634
11:12:12 <mmachenry> lispy: I have 10 clients rapidly communicating over TCP connection bidirectionally updating the same state.
11:12:14 <shachaf> Cale: But I'm not going to bet on the side of MD5 being collision-resistant.
11:12:41 <mmachenry> lispy: The connects will live on for days.
11:13:00 <Cale> shachaf: Yeah, the fact that it involves so many things which are just names is worrying.
11:13:03 <quchen> shachaf: Interesting that you mention this, I stumbled upon that as well a couple of weeks ago. Glad it's really an issue and not just me overlooking something.
11:14:23 <Cale> shachaf: It should at least include something of the structure of the type, even if we used a stronger hash function.
11:14:32 * hackagebot binary-typed 0.2.2 - Type-safe binary serialization  http://hackage.haskell.org/package/binary-typed-0.2.2 (quchen)
11:14:34 * hackagebot taskpool 0.0.2 - Manage pools of possibly interdependent tasks using STM and async  http://hackage.haskell.org/package/taskpool-0.0.2 (JohnWiegley)
11:15:35 <shachaf> Cale: What's a situation where that helps?
11:15:42 <bitemyapp> acfoltzer: could I speak to you privately?
11:16:28 <Cale> shachaf: I suppose if you were looking for a collision, you'd just not worry about those bits
11:16:53 <dfeuer> shachaf, could you make a "collision" by just giving two things the same name in modules with the same name?
11:17:04 <carter> acfoltzer: ping?
11:17:19 <dfeuer> I don't know nearly enough about Typable to ask intelligently. Forget it.
11:18:05 <shachaf> dfeuer: No. My bug describes the scheme it uses.
11:18:21 <Cale> dfeuer: There's some worry about something like that happening if the packagename doesn't include the package hash, and a package gets updated.
11:18:28 <quchen> dfeuer: The hash involves package, module, and a name.
11:18:32 <lispy> mmachenry: I'm not sure I can be of more help at the moment. If we were reviewing the code together I could probably say more. (And I don't really have time for that now, sorry)
11:18:42 <michaelt> dfeuer: there's a pleasant discussion of fold vs. unfold ghc's fusion vs. vectors fusion and so on in http://unlines.wordpress.com/2009/09/29/squinting-at-fusion/
11:19:35 <mmachenry> lispy: Yeah I wouldn't really expect such a thing. :)
11:19:42 <Cale> shachaf: Do you know if the package name includes the hash?
11:19:54 <Cale> Well, I suppose it couldn't.
11:19:54 <mmachenry> lispy: But if anyone knows of good tutorials on when to be strict and when not to, I'd love to read it.
11:19:57 <Cale> hmm
11:20:09 <shachaf> Cale: Package name includes the hash of what?
11:20:13 <lispy> mmachenry: Have you looked at the benchmarking chapter of real-world Haskell?
11:20:23 <Cale> shachaf: I'm thinking of those hashes that get added to the package version
11:20:24 <lispy> mmachenry: I think the Haskell wiki has some generic articles
11:20:28 <mmachenry> lispy: Yep, I have read that book and I'm reviewing it.
11:20:46 <mmachenry> I also have Simon Marlow's book.
11:20:55 <Cale> shachaf: (helping distinguish differences between the same version of the package compiled against different deps)
11:21:09 <shachaf> Oh, whether the package name it uses for Typeable is the "full" package name with the hash. No, I don't think so.
11:21:47 <Cale> shachaf: It's presumably compiling that package when it finds the instance, so it would have to be remarkably circular to know what that hash was :D
11:21:53 <lispy> mmachenry: I read this article when I was learning, but it may contain some inaccuracies now as libraries have improved: http://users.aber.ac.uk/afc/stricthaskell.html
11:22:45 <shachaf> Cale: Yes, that would be an achievement that would make me trust the hash even less.
11:22:54 <Cale> shachaf: I suppose the usual machinery which prevents multiple versions of the same package getting used to build something will already prevent the thing I'm worrying about
11:23:06 <lispy> mmachenry: at a high level you need to understand sharing, how/when values get demanded, and GC.
11:23:47 <shachaf> Cale: I wanted to find a collision and then make two "Safe" Hackage packages which define types with the same fingerprint.
11:24:08 <shachaf> Unfortunately you get very limited control over the bits that are actually MD5ed in the end.
11:24:22 <Cale> shachaf: i.e. what happens if we abusively install two different versions of the same package, but with the same version number and everything, but different definitions of the same type
11:24:28 <c_wraith> shachaf: what about using dynamic loading to make them collide?
11:24:52 <shachaf> Cale: Ah. I don't think that would happen in any normal case.
11:25:10 <Cale> shachaf: Well, yes, but can we get away with it? :)
11:25:18 <c_wraith> shachaf: that's why you use dynamic loading, instead of installing the same package twice
11:25:46 <lispy> monochrom: don't you have a nice article about laziness?
11:26:01 <mmachenry> Great thanks for the article, lispy
11:26:34 <aranea> Hi. I'm experiencing problems with building ghc-7.8.3. ghc-stage2 crashes on compiling old-time. It must have something to do with the compiler flags I pass, because everything builds fine with the "quick" preset from mk/build.mk.sample. Now, I'm searching for a way to quickly test different compiler flag variations. I really can't wrap my head around the GHC build system - which make targets do I have to invoke to let ghc-stage1 alone, but recompile ghc
11:26:46 <lispy> mmachenry: monochrom has a nice article about controlling laziness but I can't recall the URL.
11:27:14 <Hodapp>  /me . o O ( was that a lazy evaluation joke or not? )
11:27:17 <Hodapp> ACK
11:27:19 <shachaf> c_wraith: I'm not sure I can think of a scenario where that'd be a SafeHaskell violation.
11:27:19 * Hodapp runs away
11:27:42 <c_wraith> shachaf: oh.  Right, the GHC api probably isn't safe.
11:29:25 <rwbarton> in principle shouldn't you be able to find two types of a form like Either (Either String ()) (Either ... ...) with the same fingerprint
11:29:48 <rwbarton> or does it store a tree of fingerprints in that case?
11:30:11 <acowley> transformers deprecated the entire Control.Monad.Trans.Error module, but is the Error class going away?
11:30:35 <c_wraith> I hope so.  The Error class is terrible.
11:31:07 <acowley> My one use of it is to collapse IO exceptions and Either String
11:31:19 <tac> what's the lens for picking out an index from a list?
11:31:44 <c_wraith> tac: isn't that ix?
11:31:52 <tac> yes thnx!
11:31:56 <tac> @type ix
11:31:57 <lambdabot> (Ixed m, Applicative f) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
11:32:11 <vova> Hi, all. I wrote a module and would like to import it. But I do not understand where it should be placed to make it "visible" for ghc. Please help me with this issue
11:33:13 <tac> @hoogle ix
11:33:15 <lambdabot> package ix-shapable
11:33:15 <lambdabot> package ixdopp
11:33:15 <lambdabot> Data.Array.IArray ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
11:33:46 <c_wraith> does lambdabot's hoogle even index lens?
11:33:58 <shachaf> No.
11:34:45 <c_wraith> vova: In general, module names should match file names (and paths, if the module name is hierarchical), and.. that's all you need to do.
11:34:55 <c_wraith> vova: so what's the module named, and what's the name of the file it's in?
11:35:43 <tac> @type _String
11:35:44 <lambdabot>     Found hole ‘_String’ with type: t
11:35:44 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
11:35:44 <lambdabot>                the inferred type of it :: t at Top level
11:35:55 <c_wraith> tac: that'd be from Data.Aeson.Lens
11:36:34 * tac fights conversion between Text and ByteString
11:36:46 <vova> module name is Data.CBound. I created the dir Data/CBound/Main.hs .
11:37:07 <c_wraith> vova: with that module name, it needs to be in a dir named Data, in a file named CBound
11:37:16 <c_wraith> vova: this isn't python, where imports implicitly have an extra layer.
11:37:32 <michaelt> Data/CBound.hs
11:37:59 <c_wraith> err, yes.  CBound.hs
11:38:50 <joe9> any maintainers of template-default around? Could you please remove the dependency on template-haskell 2.9?
11:39:30 <quchen> Eek. I'm trying to build a package with GHC 7.6.3, while my latest compiler is GHC 7.8.2. What I did was `cabal sandbox init; cabal configure $COMPILER; cabal install --only-dependencies $COMPILER; cabal build $COMPILER`, where $COMPILER=--with-compiler=<path to ghc 7.6.3>. However, I'm running into errors ("some dependency not installed"). Long story short, how do I use Cabal with an older GHC version?
11:40:23 <quchen> Oddly enough, the above creates (empty) entries for a GHC 7.8.2 package DB in the sandbox folder.
11:40:51 <michaelt> wouldn't cabal sandbox init need reference to a compiler already?
11:41:03 <pavonia> c_wraith: Doesn't it matter if the module is named Data.CBound or just CBound?
11:41:15 <c_wraith> pavonia: yes.
11:41:27 <quchen> michaelt: Oh, that's a good point.
11:41:36 <c_wraith> joe9: do you mean it needs to be updated to work with GHC 7.8??
11:42:01 <c_wraith> joe9: because that's what supporting TH 2.9 means - supporting GHC 7.8
11:42:01 <michaelt> quchen: now I'm wondering, it should be able to manage two at once.
11:42:15 <michaelt> I mean two compilers
11:42:19 <vova> I do not know what python is. Anyway, thank you very much. I've created the dirs as you suggested and it works.
11:43:00 <rwbarton> good thing we have upper bounds on non-upgradeable packages right
11:43:06 <codh> Hello: I'm getting the following error while use cabal install , elm-get-0.1.2: dependency "http-types-0.8.5-2912f8440e787eefe7280bbb48d6ca47" doesn't exist (use --force to override) , any help?
11:43:50 <pavonia> I'm wondering if the compiler expects a module (literally) named "Foo.Bar" in a directory Foo to be in Foo/Bar.hs or in Foo/Foo/Bar.hs
11:44:14 <joe9> c_wraith: I installed the template-haskell from the git repo. cabal install from the git repo of template-default: http://codepad.org/1vMk3iKt , messages: http://codepad.org/Bp44hGva . with this change to template-default.cabal:  http://codepad.org/Fr06EvuI
11:44:20 <michaelt> codh: what does ghc-pkg check say?
11:44:21 <joe9> c_wraith: does that make sense?
11:44:31 <c_wraith> joe9: no.  *never* reinstall template haskell.
11:44:43 <aranea> Can't anyone give me an hint for my ghc build issue? (In case you missed it, look for my bulky 4-lines-long question 18 minutes ago)
11:44:45 <Fuuzetsu> or bytestring or ghc
11:45:04 <c_wraith> joe9: it comes with GHC, and only the version that comes with GHC works properly with that GHC.
11:45:08 <codh> michaelt: Warning: haddock-interfaces: /home/hdeng/.cabal/share/doc/x86_64-linux-ghc-7.8.3/optparse-applicative-0.9.0/html/optparse-applicative.haddock doesn't exist or isn't a file
11:45:11 <michaelt> codh: It looks like it is deleted or overwritten but still registered, or the like
11:45:25 <joe9> c_wraith: oh, ok. can I remove it with ghc-pkg unregister now?
11:45:28 <michaelt> codh, oh the haddock errors are nothing. let me think
11:45:48 <c_wraith> joe9: yeah, that should work
11:46:00 <codh> I'm using cabal and ghc 7.8.3 from nix, and running ubuntu.
11:46:41 <michaelt> does ghc-pkg list http-types say anything interesting?
11:46:42 <joe9> c_wraith: that helped. thanks.
11:46:52 <codh> also I use cabal installed elm, instead of the one on nix, because the one on nix depends a bad version cmdargs
11:47:41 <michaelt> codh: yeah, i'm worried about the mixture of the package manager and cabal-install
11:48:41 <codh> michaelt : what's recommended way?
11:49:22 <michaelt> codh: there used to be the idea that you use the package manager up to a point, and then never again, only cabal-install locally.  So the package manager gives you, so to speak, your version of 'haskell platform'
11:50:00 <int3__> tbmcmullen: I wrote the monadic version of bottomUp: http://lpaste.net/108375
11:50:15 <johnw> given this function for testBit: https://gist.github.com/98aa31f2c38a619dc8c4, can anyone tell me why the profiler tells me that it's allocating 80% of my program's memory?
11:50:37 <tbmcmullen> int3__: oh! wow. thank you, that is really helpful.
11:50:41 <codh> michaelt : thanks.
11:50:54 <int3__> tbmcmullen: np, it was a learning exercise for me too :P
11:51:02 <tbmcmullen> :)
11:51:05 <shachaf> johnw: Perhaps looking at the Core will help.
11:51:24 <johnw> I should have a shachafbot on my machine that tells me that, thanks :)
11:52:11 <rwbarton> johnw: surely it's the rest of the program we need to be able to answer that
11:52:12 <shachaf> johnw: One thing might be that it's allocated boxes for the unboxed Word64 values.
11:52:47 <johnw> I was wondering that, let me check Core to see
11:52:48 <michaelt> codh: but nix I don't understand.  Maybe these remarks will be useful about the general picture; I'm not sure they apply to the present case, of course http://www.vex.net/~trebla/haskell/sicp.xhtml
11:52:59 <shachaf> But yes, also what rwbarton said.
11:54:18 <johnw> if the result is not being forced, i.e., if I'm storing zillions of testBit thunks, would that count as a testBit allocation?
11:55:03 <rwbarton> it shouldn't
11:56:06 <rwbarton> it should count as an allocation in whatever function constructs the thunk
11:56:21 <shachaf> whoa, GHC pragmas aren't case-sensitive?
11:56:37 <shachaf> {-# language GeneralizedNewtypeDeriving #-}
11:58:07 <pavonia> Yeah, people use GHC for years before they find out :p
11:58:11 <johnw> the core looks unboxy: https://gist.github.com/61e6f71d1dbd332bd5f5
11:58:33 <pseudolio> shachaf: Whoa.
11:58:59 <johnw> but what are these functions that come right after it: https://gist.github.com/801a2e8cc97ba0f5794e
11:59:53 <johnw> ah, fixed it
12:00:10 <shachaf> That's the worker-wrapper transform thing.
12:00:21 <johnw> this change removed all of the allocation: https://gist.github.com/92fb93adf685cc3ea76d
12:00:30 <shachaf> @where cpr
12:00:30 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm
12:01:07 <quchen> If my package requires Base 4.7 (i.e. GHC 7.8), is there a way I can have docs built on Hackage? It seems there's only a 7.6 doc build bot
12:01:51 <carter> quchen: you can upload the docs
12:01:55 <alpounet> well... you can upload them yourself, but i'm pretty sure you already know that
12:03:04 <quchen> carter: That would be the manual method. But the interlinking isn't as good in that case, I found that many links leading to other modules don't work properly.
12:03:14 <carter> thers ways to fix that
12:03:18 <carter> i forget how
12:03:25 <carter> i know Fuuzetsu  has a script he's used
12:03:50 <carter> the altenrative is to figure out helping add a 7.8 doc builder
12:03:59 <carter> ask dcoutts  or others on #hackage  like lfairy
12:04:08 <edwardk>  shachaf : case insenstive pragma breaks my brain
12:04:33 <quchen> Wait, only the "language" part is insensitive, not the pragma name itself, right?
12:04:38 <shachaf> Right.
12:04:42 <carter> {-# lAnGuage cASEinsensitive#-}
12:04:45 <pseudolio> Language extensions are case sensitive.
12:04:47 <edwardk> inline also works?
12:05:30 <shachaf> Yep.
12:05:50 <pseudolio> Amazing.
12:06:07 <edwardk> shachaf: sweet
12:06:07 <shachaf> I feel like pseudolio is making fun of me.
12:06:21 <edwardk> he expressed honest appreciation here in person
12:06:54 <pseudolio> I hope this isn't like versions prior to 7.8 accepting {- NOINLINE foo -}
12:07:14 <edwardk> how far back does this work? has it always been this way?
12:09:11 <carter> there is no spoon
12:11:06 <shachaf> I don't know.
12:11:56 <noteventime> How does one disable typed holes (they don't get along with Control.Lens' naming)?
12:12:19 <carter> noteventime: -f-no-type-holes?
12:12:44 <carter> -fno-warn-typed-holes ?
12:13:00 <MP2E> yeah it's the second one
12:13:05 <MP2E> -fno-warn-typed-holes
12:13:12 <noteventime> Oh, I would have thought that just disabled the warning
12:13:18 <carter> noteventime: its just a warning
12:13:23 <carter> you clearly didn't define the things
12:13:25 <carter> :)
12:13:35 <carter> or theres a bug in type holes
12:13:48 <noteventime> Oh, perhaps I'm looking at old docs then
12:14:35 <pseudolio> Holes don't take over _foo syntax, if that's what you're worried about.
12:14:50 <pseudolio> Like, if there's actually something defined named _foo.
12:14:55 <noteventime> Turns out it's me who's an idiot, as usual, didn't capitalise the name properly
12:15:37 <noteventime> pseudolio: good to know, then it's behaving the way I'd have expected it too, I was a bit confused
12:16:22 <noteventime> thanks!
12:17:20 <carter> typed holes only fires on code that wouldn't type check anyways
12:17:38 <carter> its a cute example of "it'd only run on invalid programs, so lets enable it by default!"
12:19:41 <mister_integer> I'm trying to profile a test suite by running the executable with +RTS -p, but I'm not seeing any functions listed beyond the test harnesses and Main and the like
12:21:33 <mister_integer> Here's the profiling script I'm running: https://gist.github.com/johnbcoughlin/9a22b54e5991c831ebed
12:23:37 <michaelt> mister_integer: have you annotated the file, or do you want something like "-prof auto-all" or one of those options
12:24:12 <mister_integer> oh, no, I haven't, I'd just like to see cost centers for all the functions, basically
12:24:21 <mister_integer> i'll try auto-all
12:24:58 <michaelt> mister_integer:  http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/prof-compiler-options.html
12:26:46 <mister_integer> michaelt: that worked! Thanks!
12:31:18 <CARAM_> is there a shortcut for take x $ repeat y
12:31:51 <dwcook> @type replicate
12:31:52 <lambdabot> Int -> a -> [a]
12:31:58 <dwcook> > replicate 10 'a'
12:31:59 <CARAM_> cheers!
12:31:59 <lambdabot>  "aaaaaaaaaa"
12:32:18 <solidus-river> > replicate 2 'abc'
12:32:19 <lambdabot>  Syntax error on 'abc'
12:32:19 <lambdabot>  Perhaps you intended to use TemplateHaskell
12:32:45 <solidus-river> > replicate 2 ['abc']
12:32:47 <lambdabot>  Syntax error on 'abc'
12:32:47 <lambdabot>  Perhaps you intended to use TemplateHaskell
12:32:52 <solidus-river> welp
12:33:01 <bergmark> ' is for characters only, " for strings
12:33:09 <tommd> > replicate 2 ["abc"]
12:33:10 <lambdabot>  [["abc"],["abc"]]
12:33:12 <solidus-river> > replicate 2 "abc"
12:33:14 <octopuscabbage> >replicate 2 "abc"
12:33:14 <lambdabot>  ["abc","abc"]
12:33:26 <octopuscabbage> > replicate 2 "abc"
12:33:28 <lambdabot>  ["abc","abc"]
12:33:35 <solidus-river> ah, so 'abc' is nonesense to haskell or is it a literal sequence of bytes
12:33:41 <octopuscabbage> > replicate 2 ['a','b','c'
12:33:43 <lambdabot>  <hint>:1:25:
12:33:43 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:33:47 <octopuscabbage> > replicate 2 ['a','b','c']
12:33:48 <lambdabot>  ["abc","abc"]
12:33:57 <bergmark> 'abc' is not valid
12:34:14 <octopuscabbage> ' ' = Char, " " = [Char]
12:34:39 * hackagebot Agda 2.4.0.2 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.4.0.2 (AndreasAbel)
12:34:41 * hackagebot cblrepo 0.11.3 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.11.3 (MagnusTherning)
12:35:07 <vektor> refactoring. Got a kinda complex, pure function. This function calls another function, which I just now have to make a IO function. So now, how do I make the first function work again with minimal effort?
12:35:37 <rufs> lpsmith: this particular case was only for my internal use, but good to know for the future
12:35:40 <dfeuer> Yech. GHC doesn't implement general foldr/cons (for good reasons). I also haven't encountered special rules for foldr(x:build g) or foldr(x:y:build g) or the like. Are they somewhere I haven't looked, or should we add them, or is there something else that takes care of this?
12:35:44 <rufs> re orphans
12:35:59 <octopuscabbage> vektor: create a third function that binds the IO result to a value, and then passes that value to the function and then returnst hat
12:36:02 <solidus-river> vektor: you cant take the io into a different action?
12:36:10 <octopuscabbage> if you don't mind propogating IO
12:36:40 <carter> dfeuer: what was teh blowup thing yesterday?
12:36:57 <vektor> I don't think I can, no. The problem is that the IO action is highly dependant on an interim result in the first function.
12:37:15 <solidus-river> vektor: can you lpaste the example?
12:37:36 <dfeuer> Carter, the question of inlining unfoldr.
12:38:10 <solidus-river> > :t unfoldr
12:38:11 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:38:16 <vektor> http://lpaste.net/108377
12:38:22 <solidus-river> @type unfoldr
12:38:23 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:38:26 <carter> dfeuer: ... and
12:38:32 <carter> i knew that part
12:38:35 <carter> i want the new infors
12:38:36 <carter> :)
12:38:41 <carter> g2g lunch though
12:38:43 <tommd> @where paste
12:38:43 <lambdabot> Haskell pastebin: http://lpaste.net/
12:38:46 <solidus-river> so is unfoldr a generator?
12:39:07 <vektor> The function I had to change is isUnique. I know it doesn't compile and stuff, that's what I'm working on. The change would have to propagate  into reprogram.
12:39:28 <dfeuer> carter, it's not new info. Just new thinking. Unfoldr is really a basic control structure. You would never consider making a "while" loop in C a non-inlined function of its body...
12:39:42 <carter> hrmm
12:39:51 <carter> depends on the size of the body
12:39:58 <vektor> I'm aware that isUnique atm does not need to be a IO function. That's for later.
12:40:13 <dfeuer> The question of whether the function passed to unfoldr is inlined is somewhat separate.
12:40:23 <carter> ah
12:40:27 <solidus-river> vektor: why does isUnique return an IO action?
12:40:50 <solidus-river> oh
12:40:50 <solidus-river> lol
12:40:52 <dfeuer> The actual unfoldr code adds very little, even when that function is not inlined.
12:40:54 <solidus-river> sorry just read
12:41:01 <vektor> 's ok.
12:41:27 <codh_> hello, I get following error while cabal install zlib-0.5.4.1 : Missing (or bad) header file: zlib.h, but I do have /usr/include/zlib.h, any help?
12:41:38 <dfeuer> But in many (most?) cases, that function will be defined locally, as in unfoldr go blah where go c = ...
12:42:05 <solidus-river> vektor: hard to say with just this part of the program for me. as the program is theres no reason for the IO
12:42:35 <vektor> Sure, but I'm pretty sure I'll need it. I'm gonna have to refactor reprogram. Is there a nice way of doing that?
12:43:10 <codh_> figure it out myself. my zlib under system is too old.
12:43:36 <solidus-river> you could reprogram it with a monad transformer wtih StatT
12:43:40 <solidus-river> *StateT
12:43:46 <solidus-river> vektor: ^
12:44:04 <vektor> @hoogle StateT
12:44:06 <lambdabot> Control.Monad.State.Lazy StateT :: (s -> m (a, s)) -> StateT s a
12:44:06 <lambdabot> Control.Monad.State.Strict StateT :: (s -> m (a, s)) -> StateT s a
12:44:06 <lambdabot> Control.Monad.Trans.State.Lazy StateT :: (s -> m (a, s)) -> StateT s m a
12:44:17 <solidus-river> so
12:44:20 <solidus-river> it woudl become
12:44:27 <solidus-river> [StdGen] -> [String] -
12:45:09 <solidus-river> [StdGen] -> [String] -> Int -> StateT [Uniques] IO (Maybe String)
12:47:23 <vektor> Not sure if I understand that from over the top of my head. I'll do it the way I'd have done it before. Classic IO function. Thanks for your help though, I hope I'll wrap my head around it someday :)
12:47:27 <solidus-river> thats a very imperative way of forming the problem though, you might have a better time making a list of imports then filtering that to remove dupes
12:47:45 <dfeuer> carter: when the body is defined locally, the unfoldr inlining may either add or remove code, but not much either way, and can avoid a lot of allocation in cases I believe are common.
12:48:48 <vektor> solidus-river: you mean the hasImports function?
12:48:50 <solidus-river> vektor: yeah its kinda a mess, if you want to read on it its monad transformers
12:49:20 <solidus-river> vektor: if i'm interpreting this right your pasring a file and removing duplicate importes
12:49:23 <solidus-river> *imports
12:49:32 <solidus-river> you can parse the file sa a step into a list of the import name and module its requesting
12:49:35 <vektor> I'm disallowing any and all imports.
12:49:38 <solidus-river> then filter that list for only unique values
12:49:44 <solidus-river> then import the unique values
12:49:46 <aranea> (I already posted this one and a half hours ago, but perhaps now there's somebody around how can help me...) Hi. I'm experiencing problems with building ghc-7.8.3. ghc-stage2 crashes on compiling old-time. It must have something to do with the compiler flags I pass, because everything builds fine with the "quick" preset from mk/build.mk.sample. Now, I'm searching for a way to quickly test different compiler flag variations. I really can't wrap my head ar
12:49:57 <solidus-river> ins'tead of trying to do it in one pass
12:50:02 <solidus-river> get the IO out of the way first
12:50:27 <vektor> the only reason I would change the implementation is to allow identifiers with import in them. Currently unneeded though.
12:50:47 <vektor> I'll definitely need the IO in isUnique.
12:51:08 <vektor> Or I'll have to burden myself A *ton more with all kinds of state.
12:51:10 <zzbacon> "Demand for jobs is far higher than supply, therefore we have a steady stream of highly competent developers applying for a job and also we can keep salaries to more reasonable"
12:51:22 <zzbacon> :|
12:51:57 <vektor> zzbacon: In short, too many workers, therefore low wages and we're picky ****s.
12:52:35 <int3__> the amount of automatic graph-producing profile tools for haskell is pretty amazing. I'm so glad I don't have to struggle with valgrind and friends.
12:52:50 <carter> int3__: you'll still have to once you get to exotic stuff
12:52:56 <carter> but the amount of HL tooling is niceee
12:53:03 <int3__> ah okay
12:53:08 <octopuscabbage> does anyone know of any good haskell live codes?
12:53:15 <carter> octopuscabbage: for what use case?
12:53:19 <zzbacon> so java pays better than haskell? :'(
12:53:24 <carter> z?
12:53:26 <octopuscabbage> carter: just general use case
12:53:41 <trap_exit> (1) is there any relation between FRP and callback hell? (2) why has FRP have both people who claim it's the best thing ever, and yet most people rarely use it
12:53:48 <artymis> haskell pays intellectual returns
12:53:54 <carter> trap_exit: frp != callbacks
12:54:01 <carter> callbacks are byhand CPS
12:54:10 <carter> so its just monads
12:54:14 <carter> but without help
12:54:21 <carter> do notation lets you express those patterns
12:54:34 <trap_exit> carter: so what problem _does_ frps solve ?
12:54:39 <octopuscabbage> carter: i suppose learning
12:54:43 * hackagebot ghc-server 1.1 - A server interface to GHC.  http://hackage.haskell.org/package/ghc-server-1.1 (ChrisDone)
12:54:59 <carter> octopuscabbage: you can write code "live" in any lib :)
12:55:12 <carter> trap_exit: you want to build a 60fps game, and have composable engineering
12:55:16 <carter> is one goal
12:55:20 <octopuscabbage> carter: no sorry, i meant like youtube examples. people programming in haskell and recording it
12:55:24 <carter> oh
12:55:35 <zzbacon> octopuscabbage: jekor
12:55:45 <vektor> return if x then a else a' .... doesn't compile, parse error on if. what?
12:56:00 <shachaf> vektor: return (if ...)
12:56:00 <benmachine> trap_exit: my impression is that FRP is not the best thing ever *yet*, it's promising but people are still arguing about the best way to do it
12:56:01 <octopuscabbage> zzbacon: i tried him, he was a bit slow, i'll try again though.
12:56:08 <shachaf> Or return $ if ..., if you prefer $
12:56:21 <benmachine> trap_exit: but I'm not an expert as such
12:56:22 <vektor> shachaf: thanks
12:56:22 <trap_exit> hmm
12:56:24 <trap_exit> what does frp even do?
12:56:25 <benmachine> or, at all
12:56:39 <solidus-river> vektor:
12:56:40 <trap_exit> when is it that I look at my problem, and go "hmm, I should invest in frp"
12:56:43 <solidus-river> return $ if x then a else a
12:57:05 <carter> frp is a research problem
12:57:10 <carter> right now
12:57:16 <carter> if you wanna do research engineering, yay
12:57:24 <carter> ifnot, try doing something dummber first
12:57:33 <ReinH> fsvo "FRP"
12:57:39 <solidus-river> who's asking about frp?
12:57:40 <jtakacs> what does FRP stand for?
12:57:47 <carter> ReinH: the interesting values of FRP are still research hard
12:57:48 <solidus-river> functional reactive programming
12:57:58 <benmachine> I think people do at least use FRP-inspired techniques in "real" programs
12:58:01 <zzbacon> functional rp... playing dungeons and dragons with haskell
12:58:15 <carter> o/ ReinH
12:58:25 <solidus-river> oh god
12:58:26 <jtakacs> what do you mean by 'reactive'?
12:58:34 <carter> there in lies the trouble
12:58:39 <zzbacon> http://en.wikipedia.org/wiki/Reactive_programming
12:58:46 <benmachine> at work we have a library that tries to model values that update over time
12:58:54 <carter> you start with this grand vision of dynamically rewriting event processing graphs
12:59:05 <carter> and then you lose track of where your shoes are
12:59:08 <carter> or what day it is
12:59:16 <carter> *rewiring
12:59:31 <conal> FRP overviews with links: http://stackoverflow.com/a/1030631/127335 and http://stackoverflow.com/a/5878525/127335
12:59:32 <bernalex> FRP is cool for games & GUI programs
12:59:43 * hackagebot pipes-network 0.6.4 - Use network sockets together with the pipes library.  http://hackage.haskell.org/package/pipes-network-0.6.4 (RenzoCarbonara)
12:59:48 <solidus-river> and i think a big fault of the frp code i've seen is that they go full frp
13:00:02 <solidus-river> like you don't need a whole program in frp, and probably theres very few programs that makes sense for
13:00:05 <zzbacon> "full frp, you never go full frp"
13:00:11 <solidus-river> right!
13:00:16 <carter> and conal  is literally the expert
13:00:18 <solidus-river> like use frp where it makes sense like a control structure
13:00:27 <solidus-river> you dont write a whole program using while statements or fors
13:00:30 <solidus-river> although you could
13:01:55 <trap_exit> you know what this community needs?
13:02:04 <trap_exit> something like "Americna Ninja Warrior" for haskell
13:02:06 <carter> more lambdas?
13:02:09 <trap_exit> you have a gunch of contestants
13:02:14 <bernalex> we should have a conalbot for whenever someone asks what FRP is
13:02:18 <trap_exit> they've given weird function type definitions
13:02:26 <trap_exit> and people have ot fill in the definitions in real time
13:02:33 <octopuscabbage> a reasonable debugger
13:02:35 <octopuscabbage> ?
13:02:46 <carter> eh, @djinn would hanswer most of the really odd ones pretty fast
13:02:51 <solidus-river> does haskell have an equivalent to gdb?
13:02:52 <trap_exit> the only bug myhaskell code ever has
13:02:59 <trap_exit> the only bug my haskell ever code has is ... too slow
13:03:02 <trap_exit> so we just need a decent profiler
13:03:05 <bernalex> solidus-river: gdb does not make sense for haskell. haskell is not imperative.
13:03:17 <solidus-river> bernalex: the assembly it generates sure is
13:04:12 <bernalex> solidus-river: oh, if you want to be handwavy about it then sure. write a gdb-equivalent program & see how far you get. :-P
13:04:38 <octopuscabbage> shhh we're supposed to pretend it doesn't generate assembly and is just a long string of functions that the processor processes all at once
13:04:59 <bernalex> ghci has dynamic breakpoints at least
13:05:16 <bernalex> & then you can :sprint terms
13:05:24 <octopuscabbage> yeah but we really need a graphical debugger
13:05:27 <octopuscabbage> that makes sense for FP
13:05:38 <solidus-river> bernalex: oo, thats cool, what does a break point look like in ghci
13:05:49 <bernalex> solidus-river: http://www.haskell.org/haskellwiki/Debugging#Dynamic_breakpoints_in_GHCi
13:05:59 <ReinH> carter: o/
13:07:41 <carter> 7.10 will have some dwarf meta data i think
13:13:50 <Fuuzetsu> jlouis: ping
13:14:01 <arianvp> How would I run multiple versions of cabal / ghc on a pc?
13:14:15 <arianvp> I've got one project that depends on 7.6 and another on 7.8
13:14:18 <arianvp> vagrant?
13:14:22 <octopuscabbage> docker?
13:14:24 <Fuuzetsu> nix ;)
13:14:30 <lf94> Ok guys I'm so close to getting this to work. What's wrong? error: http://paste.debian.net/112512/, code: http://paste.debian.net/112513
13:14:33 <Fuuzetsu> or a hell of symlinks
13:14:34 <carter> or just switchup your path
13:14:37 <arianvp> yeh nix is hot... but will I be forced to use nix to build packages?
13:14:47 <arianvp> or can i still use cabal?
13:14:56 <Fuuzetsu> nix uses cabal
13:15:18 <arianvp> usually when I see people use Nix. they do cabal2nix and let nix-shell handle their builds
13:15:18 <carter> cabal -w $pathtoGHC
13:15:25 <rwbarton> I wonder if you can just specify with-compiler: in the cabal file
13:15:36 <arianvp> rwbarton: let me try
13:15:39 <carter> huh
13:15:40 <carter> that'd be evil and neat both
13:15:43 <rwbarton> yes
13:15:56 <Fuuzetsu> arianvp: I know there are some people who (once they have cabal2nix'd) then use cabal-install like the would on other setups
13:15:57 <beaky> hello
13:16:00 <carter> i feellike that would break the duncan rule of "authors can't tell users how to build"
13:16:05 <beaky> how do i learn haskell
13:16:11 <arianvp> dont think so. it needs to be listed in the cabal compiler list.
13:16:43 <carter> beaky: whats your computer science/ programming backgorund?
13:16:55 <rwbarton> maybe cabal.config then
13:16:55 <arianvp> lol I think --with-compiler might work
13:17:41 <beaky> carter: novice
13:17:47 <carter> hrm
13:17:56 <arianvp> rwbarton: --with-compiler will work I think. just gotta install ghc 7.6.2 now
13:18:03 <rwbarton> --with-compiler certainly works
13:18:17 <carter> well, https://github.com/bitemyapp/learnhaskell/blob/master/README.md is pretty good
13:18:19 <rwbarton> you just have to remember to use the flag every time you want to configure or install
13:18:30 <carter> for helping you naviage all the various learning options
13:18:51 <beaky> i want to use haskell to write a finance app
13:19:07 <carter> neat
13:19:10 <benmachine> what kind of finance app?
13:19:11 <carter> for fun or work?
13:19:15 <beaky> personal finance
13:19:17 <lf94> beaky: send me the money
13:19:25 <carter> beaky: i do all sorts of reporting tooling using haaskell
13:19:41 <carter> semigroups / monoids === thigns I can add
13:19:57 <beaky> i dont want to write it in c because segfaults will lose me money ^^
13:20:11 <carter> accounting or personal trading?
13:21:07 <rwbarton> it works with cabal.config
13:21:15 <rwbarton> "with-compiler:            ghc-7.6.3"
13:21:34 <beaky> acounting
13:21:37 <rwbarton> but not in the .cabal file
13:21:43 <rwbarton> very sensible
13:21:55 <sm> beaky: come hack on hledger
13:22:04 <arianvp> rwbarton: awesome
13:22:06 <sm> in #ledger
13:22:31 <arianvp> I'm in this dillemma.    Haste doesn't compile the FRP library that  I wanna use and  I find GHCJS to be overkill :(
13:22:34 <beaky> http://hledger.org/ wow
13:22:37 <arianvp> conclusion: role own FRP lib
13:22:42 <arianvp> roll*
13:23:02 <hiptobecubic> arianvp why is considered ghcjs overkill if nothing else can handle it
13:24:22 <carter> arianvp: or use GHCJS
13:24:56 <arianvp> carter: Yeh but I dont like its FFI.  Haste's FFI is a bit easier. for callbacks you dont need to set retention behaviour etc
13:25:18 <carter> arianvp: talk with luite  about your needs and if they fit with work he's got planned
13:25:49 <carter> if he doesn't get feedback, he can't make nice things
13:25:51 <lf94> Ok guys I'm so close to getting this to work. What's wrong? error: http://paste.debian.net/112512/, code: http://paste.debian.net/112513
13:26:14 <rola> @pl (==) (map test1 xs) (map test2 xs)
13:26:14 <lambdabot> map test1 xs == map test2 xs
13:26:47 <rola> how do i not repeat writing map and xs twice in that expression
13:27:03 <trap_exit> Text.Printf.printf -- is there a Data.Text version of this, which uses TeXt, rather than String ?
13:27:36 <benzrf> rola: theres not really anything i can think of thats much shorter and still clear
13:27:39 <benzrf> it's not THAT bad
13:28:18 <rola> alrighty
13:28:53 <mmmm> I think I'm definitely in the lens infix operators are unreadable camp
13:29:43 <trap_exit> is there a tutorial on how ot use http://hackage.haskell.org/package/text-format-0.3.1.1/docs/Data-Text-Format.html ?
13:30:44 <supki> :t liftA2 (==) `on` map
13:30:46 <lambdabot> Eq b => (a -> b) -> (a -> b) -> [a] -> Bool
13:31:32 <arianvp> rola:
13:31:41 <arianvp> ((==) `on` flip map xs)
13:31:48 <arianvp> though I doubt that'd be more clear
13:31:54 <rwbarton> I think it would be clearer to write "all (liftA2 (==) test1 test2) xs" or something, but the original is fine
13:32:11 <rola> i see
13:32:20 <zzbacon> \omg my life is complete -> http://hackage.haskell.org/package/LambdaHack
13:32:40 <arianvp> yeh    ((==) `on` flip map xs) test1 test2 should work
13:33:19 <arianvp> zzbaconn: cool :)
13:33:29 <rola> @src on
13:33:30 <lambdabot> (*) `on` f = \x y -> f x * f y
13:33:38 <rola> that's neat
13:33:54 <benzrf> :t \omg my life is complete -> http://hackage.haskell.org/package/LambdaHack
13:33:56 <lambdabot> Not in scope: ‘http’
13:33:56 <lambdabot> Not in scope: data constructor ‘://’
13:33:56 <lambdabot> Not in scope: ‘hackage’
13:33:58 <benzrf> lame!
13:34:07 <arianvp> rola: you can do cool stuf with it like:   sortBy (compare `on` fst)
13:36:05 <arianvp> okay this whole 2 haskell versions thing def doesnt work xD cabal: Version mismatch between ghc and ghc-pkg: /home/arian/.cabal/bin/hastec is version 7.6.3 /home/arian/.cabal/bin/haste-pkg is version 7.8.2
13:37:26 <arianvp> Fine. I'm gonna give Nix a shot. this stuff is giving me headaches. Any good sources on Nix haskell development?
13:37:38 <zzbacon> why doesn't cabal install stuff to pkg-name/semver/ ?
13:38:00 <rwbarton> arianvp: that sounds like haste's fault
13:38:22 <zzbacon> so haste-pkg/7.8.2/
13:38:50 <rola> where can i find more neat combinators on like the ones in Data.Function
13:38:53 <zzbacon> or tasty-bacon/8.00.85/
13:39:17 <arianvp> rwbarton: yeh haste installer is probably just taking the first GHC it finds in $PATH which happens to be 7.8.2
13:39:25 <rwbarton> it does install libraries in a per-version directory, but executables have to go on your path
13:39:27 <arianvp> or something weird like that
13:40:11 <arianvp> rola:  check out the lens package ;)
13:40:17 <arianvp> hehe
13:40:30 <arianvp> it's got some really cool ones
13:40:36 <Fuuzetsu> arianvp: NixOS wiki, nix mailing list, #nixos
13:40:52 <arianvp>  /join #nixos
13:40:59 <Fuuzetsu> when I needed multiple versions on Gentoo, I compiled the versions I wanted into prefixes in ~ and then switched symlinks
13:41:00 <spopejoy> Sigh … trying to run GHC ‘make TAGS’ …. which requires a full build (really???), dying (OS X) with “error: iconv is required on non-Windows platforms”, despite installing libiconv successfully
13:41:14 <Fuuzetsu> spopejoy: #ghc
13:41:16 <rola> i checked out lens a while ago, but they are still a little too sophisticated for me right now
13:41:18 <zzbacon> is nixos a whole linux distro?
13:41:29 <Fuuzetsu> zzbacon: There is NixOS which is a distro built on top of nix.
13:41:33 <arianvp> zzbacon: yes. nixos is a distro based o top of nix
13:41:36 <joneshf-laptop> is there some thing between a type synonym and a newtype that allows the compiler to distinguish between two types at compile time, not incurr runtime penalties, but doesn't require an explicit wrapper
13:41:39 <bennofs> zzbacon: yes, but you can use nix (which is just a package manager) on any linux distro (and mac)
13:41:45 <arianvp> zzbacon: but nix ca be used standalone :)
13:41:48 <joneshf-laptop> ala String/Text with OverloadedStrings
13:41:53 <spopejoy> happy to go to #ghc but is nobody else generating TAGS for normal dev? I’m not becoming a GHC dev anytime soon
13:42:03 <zzbacon> oic, quite intriguing
13:42:11 <arianvp> But I'm really considering throwing away Ubuntu after  6!!! years and switch to NixOS
13:42:12 <spopejoy> how are people referring to haskell source while developing? hoogle only?
13:42:12 <bennofs> spopejoy: what do you need TAGS for?
13:42:32 <spopejoy> I’d like to go to the definition of a library function, etc
13:42:32 <bennofs> spopejoy: you can hoogle for ghc functions too
13:42:43 <spopejoy> of course, would like to do this within emacs
13:42:48 <Fuuzetsu> spopejoy: one normally does not need to look up things in GHC source when developing
13:42:53 <bennofs> spopejoy: most library definitions are not in GHC source anyway
13:43:07 <zzbacon> emacs is like hotel california
13:43:22 <bennofs> spopejoy: I often use hayoo if I want to jump to the documentation of a function (and then use the source link), but this requires a browser
13:43:44 <bennofs> http://hayoo.fh-wedel.de
13:44:26 <spopejoy> a lot of source is in GHC, like most of mtl
13:45:07 <bennofs> spopejoy: I think (haven't tried myself) that you can use codex to generate tags for mtl and other packages separately
13:45:09 <bennofs> @hackage codex
13:45:10 <lambdabot> http://hackage.haskell.org/package/codex
13:45:37 <bennofs> no need to generate TAGS for the whole GHC source
13:46:18 <spopejoy> bennofs: thanks, i’ll look into codex
13:49:46 <johnw> can I use Intel's PCLMULQDQ instruction in Haskell?
13:49:48 * hackagebot taskpool 0.0.3 - Manage pools of possibly interdependent tasks using STM and async  http://hackage.haskell.org/package/taskpool-0.0.3 (JohnWiegley)
13:50:00 <johnw> (multiplying two 64-bit integer pairs)
13:50:27 <benzrf> hackskell
13:50:40 <dcoutts> johnw: check what state the simd primitives are in, see the simd pages on the ghc wiki
13:50:45 <johnw> thx
13:50:52 <Fuuzetsu> which GHC release used <base-4.4?
13:52:21 <Fuuzetsu> nevermind, it seems that it was just the case of overeager version bounds
13:52:41 <johnw> dcoutts: I'm willing to do this with the FFI too
13:52:50 <dcoutts> johnw: then it's easy
13:53:04 <dcoutts> but the overhead of a C call may be higher than the saving
13:53:18 <johnw> even if I mark it unsafe?
13:53:27 <dcoutts> benchmark it
13:53:44 <johnw> well, the algorithm I have now is positively wretched
13:54:06 <johnw> it would be neat sometimes if Haskell has an "asm STR" keyword :)
13:54:13 <johnw> not in any way portable, but...
13:54:28 <benzrf> asm STR?
13:54:52 <johnw> inject arbitrary assembly code, with the ability to load surrounding unboxed values straight from memory/registers
13:54:53 <zzbacon> inline assembly code i assume
13:55:55 <zzbacon> there's probably an assembly dsl somewhere
13:57:26 <benzrf> oic
13:59:45 <vektor> Can someone point me to a functiona that will tell me whether a String is a correct haskell program?
14:01:03 <c_wraith> vektor: how do you define "program"?
14:01:07 <carter> johnw: :)
14:01:41 <vektor> c_wraith: well, I have a string. I want to know whether it can be compiled and run.
14:01:47 <c_wraith> vektor: and for that matter, how do you define "correct"?
14:02:09 <vektor> c_wraith: Uhhm, the compiler won't moan at me, I guess?
14:02:40 <vektor> What the program does, I don't care. I only care whether it does something or nothing.
14:02:52 <c_wraith> vektor: so you really mean something with a main entry point that can be compiled?
14:03:02 <jle`> or just a valid expression...?
14:03:07 <Ch0c0late> vektor: You may try https://hackage.haskell.org/package/mueval
14:03:16 <vektor> c_wraith: it does have a main function, indeed.
14:03:26 <c_wraith> vektor: main isn't a function, thanks. :P
14:03:28 <Fuuzetsu> what is it about haskell-src-exts that makes it take so long to compile?
14:03:47 <vektor> c_wraith: procedure? method? nitpickerings :D
14:03:59 <c_wraith> vektor: "definition" is the best term
14:05:02 <vektor> jle`: well, a expression might not quite be enough. I want an implementation of my given function header.
14:05:02 <c_wraith> vektor: You can certainly use the GHC api to see if something compiles.  It's a little file-oriented, though.
14:05:08 <carter> johnw: assuming i get oked for my static values type extension, twill be doable
14:05:39 <rwbarton> note that whether something compiles will depend on what packages you have installed, or on anything at all if you use Template Haskell
14:06:39 <vektor> rwbarton: I don't allow imports, so that makes it a lot easier.
14:06:49 <vektor> or rather, I only allow very few imports.
14:07:11 <vektor> and those are static, i.e. they never change.
14:07:18 <zzbacon> no import Launch.The.Missiles
14:07:40 <vektor> in short, I want to check if this: http://lpaste.net/108386 will work depending on which string I insert as the implementation of code.
14:07:48 <vektor> zzbacon: that's the idea.
14:07:49 <Feuerbach> Fuuzetsu: see https://github.com/haskell-suite/haskell-src-exts/issues/148
14:08:43 <c_wraith> vektor: It might be much easier to do what you want in a slightly different way.
14:08:48 <Feuerbach> Fuuzetsu: you can build with -O0, it'll be faster
14:08:59 <Fuuzetsu> I suffered through it now
14:09:07 <vektor> c_wraith: shoot.
14:09:39 <c_wraith> vektor: the hint library makes it easy to interpret a string as an expression of a specific type, with a specific set of imports.
14:10:07 <c_wraith> vektor: if you can express your interface as a type, you can use that
14:10:19 <Fuuzetsu> hm, derived instances
14:10:19 <vektor> my interface being the header of code?
14:11:14 <vektor> Come to think of it, I just wrapped my head around the fact that I'll have to compile it sooner or later anyways.
14:11:28 <vektor> So I might as well do that in one step.
14:11:36 <c_wraith> vektor: though if you're worried about hostile code, you really should be using mueval.  There are lots of ways to write code that loops infinitely in a way that hangs the runtime.
14:11:51 <vektor> c_wraith: I am indeed.
14:11:52 <c_wraith> vektor: so you can't expect to handle hostile code in-process safely.
14:12:23 <vektor> Oh, shoot. I kinda lost sight of infinite loops and the like. Dammit.
14:12:26 <c_wraith> vektor: mueval handles spawning a new process so that OS limits can be enforced - and if it times out, the whole process can be killed.
14:12:32 <vektor> Reflective programming is a mess.
14:12:43 <c_wraith> vektor: mueval is what lambdabot uses, so it's been battle-tested. :)
14:13:11 <vektor> c_wraith: are you getting what my code is abotu?
14:13:13 <vektor> *about
14:13:38 <pseudolio> > let f0 x = (x,x); f1 = f0.f0; f2 = f1.f1; f3 = f2.f2; f4 = f3.f3 in (f4.f4) 'c'
14:13:43 <lambdabot>  mueval-core: Time limit exceeded
14:13:47 <nezt> So i should be able to cabal install any_hackage_package right?
14:13:52 <trap_exit> ARGH, is there a single example of how to use https://hackage.haskell.org/package/text-format-0.3.1.1/docs/Data-Text-Format.html .... ?
14:13:54 <trap_exit> much thanks
14:13:56 <trap_exit> so helpful
14:14:02 <c_wraith> vektor: eh.  Only sorta.  I'm just worried about the consequences of allowing code execution from hostile users. :)
14:14:02 <trap_exit> wow examples!
14:14:35 <spopejoy> \msg lambdabot
14:14:37 <vektor> c_wraith: well, code will be implemented by an AI hopefully. It's dangerous as it is, but I think by not allowing IO, I have at least a bit of security.
14:15:09 <Fuuzetsu> :t unsafePerformIO
14:15:10 <lambdabot> Not in scope: ‘unsafePerformIO’
14:15:47 <Fuuzetsu> nezt: yes, run cabal update first
14:16:06 <c_wraith> vektor: well, if you run in-process, I (as a hostile user) can hang the runtime.  If you run in an independent process without timeouts, I can DoS your machine by creating thousands of infinite loops.
14:16:11 <nezt> I'm trying to get a particular package and it's telling me that OpenGLRaw-1.3.0.0 failed, so i try to cabal install it and it fails
14:16:23 <vektor> so mueval will let me evaluate a implementation of code without causing any harm to the whole process if it doesn't work?
14:16:34 <Fuuzetsu> nezt: what's the actual error?
14:16:47 <c_wraith> vektor: yeah, mueval actually starts a new process to run the code.
14:16:58 <vektor> c_wraith: keep in mind, this is not a webservice or anything.
14:17:14 <nezt> it just says exit failure 1 and that i might need the -dev version
14:17:34 <c_wraith> nezt: that means it couldn't find the headers for the C openGL library
14:17:50 <nezt> hmm.. thanks
14:21:05 <eacameron> is there a better way to "debug" things in my "where" clauses, I find myself copy and pasting into ghci a lot
14:22:12 <mmmm> you can use Debug.Trace ?
14:23:59 <eacameron> mmmm: seems like overkill for a few simple pure functions; there isn't a way to "enter" the scope of a function and mess around with its available bindings?
14:25:05 <joneshf-laptop> eacameron, can't you debug in ghci?
14:25:23 <hiptobecubic> Hmmm: "git gets easier once you get the basic idea that branches are homeomorphic endofunctors mapping submanifolds of a Hilbert space."
14:25:24 <joneshf-laptop> or does the where preclude that?
14:25:26 <eacameron> joneshf-laptop: ha, I suppose you can, but I've never done it
14:25:45 <Pythonfant> hiptobecubic: suddenly it all seems obvious
14:26:04 <hiptobecubic> Clearly i should read some more wikipedia. I don't see it.
14:27:27 <hiptobecubic> What are the submanifolds here? Surfaces in the space of all possible source codes?
14:28:01 <hiptobecubic> Then I guess kind of, if you squint and don't really understand anything. Assuming that's a hilbert space, which i dont know.
14:29:46 <benmachine> hiptobecubic: pretty sure nothing anywhere near involved is a hilbert space
14:29:52 <benmachine> hiptobecubic: pretty sure it's a joke :P
14:29:56 <Fuuzetsu> @tell eacameron you can set breakpoints inside the function and once ghci stops there, you'll be able to use the stuff inside the where block
14:29:57 <lambdabot> Consider it noted.
14:30:08 <hiptobecubic> benmachine, sure. but the question is *could* you argue it
14:30:32 <hiptobecubic> for one, i think it's pretty clear that we're in a discrete space and not continuous
14:30:36 <benmachine> hiptobecubic: oh. my intuition is that infinite-dimensional vector spaces don't have much of a home in computer science
14:30:57 <benmachine> obviously this is the kind of statement that can often be surprisingly wrong (cf. homotopy type theory)
14:31:05 <zzbacon> ...unless they're lazy infinite dimensional vector spaces!
14:31:18 <benmachine> well, sure, but even then, they're kinda weird things
14:31:52 <benmachine> and git branches are relatively concrete and finite and combinatorial
14:32:07 <hiptobecubic> well let's see. branches, viewed as a delta from commit to some other commit, are clearly invertible
14:32:18 <hiptobecubic> i still argue not continuous whatsoever
14:32:29 <hiptobecubic> bijective though
14:32:39 <benmachine> well, first, what does "homeomorphic endofunctor" even *mean*
14:32:55 <benmachine> and how do you make submanifolds of a Hilbert space into categories such that endofunctors can map them
14:32:58 <hiptobecubic> an... endofunctor that is also a homeomorphism? fuck i don'tknow.
14:33:16 <zzbacon> i KNEW haskell was a trick to get people into crazymaths
14:33:44 <Pythonfant> zzbacon: pssst, don't tell it anyone!
14:33:49 <benmachine> Hilbert spaces are also groups which are categories
14:33:54 <benmachine> if you forget almost everything about them :P
14:34:25 <ystael> zzbacon: The first half, that they tell everybody, is "You don't have to learn category theory to program in Haskell." The second half, that you only find out later is "But you're probably going to." :)
14:35:01 <benmachine> it's fun!
14:35:05 <Exio4> but you at least learn it the fun way? no? :D
14:35:18 <josephle> is haskell a gateway drug to category theory then?
14:35:25 <benmachine> josephle: oh, absolutely
14:35:32 <hiptobecubic> benmachine, but submanifolds thereof?
14:35:42 <Exio4> i know it is like a drug, until you start, you want more, and more, and don't know when it is too much
14:35:44 <benmachine> hiptobecubic: good point. I guess they could also be subspaces
14:35:48 <nezt> Has anyone compared the performance of Warp to Nginx? Is that a relevant comparison?
14:37:22 <zzbacon> every programming job is java or python it seems like :(
14:37:36 <c_wraith> @version
14:37:36 <lambdabot> lambdabot 5.0-int-e
14:37:36 <lambdabot> git clone git://github.com/int-e/lambdabot.git
14:38:13 <arianvp> what is more idiomatic? : transfer f i  = fmap (`f` i)  or  transfer f i  = fmap (flip f i)
14:38:31 <dwcook> arianvp, don't know, but the first looks nicer to me.
14:38:45 <Pythonfant> I would also prefer the first one
14:39:19 <dwcook> Though I might've written transfer = (fmap .)
14:39:26 <dwcook> Wait, that's wrong, ignore me
14:39:50 <hiptobecubic> zzbacon, as if those were comparable
14:40:02 <zzbacon> :t (.)(.)
14:40:03 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
14:40:09 <zzbacon> uh... well.
14:40:22 <arianvp> :t (.).(.)
14:40:23 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:40:33 <hiptobecubic> or should i say "implement comparable"
14:40:33 <arianvp> boob operator is actually useful sometimes
14:40:55 <Fuuzetsu> anyone know why the network package exports sClose from Network and Network.Socket? Is only Network intended to be imported?
14:41:23 <hiptobecubic> boob looks like higher order function composition
14:41:26 <levi> hiptobecubic: When you get into the denotational semantics, there's an order-theoretic sense in which all Haskell functions are continuous.
14:42:49 <arianvp> Fuuzetsu: then they would've probably hidden Network.Socket right?
14:42:56 <artymis> levi, ordered by what?
14:43:28 <Fuuzetsu> arianvp: maybe, I don't know
14:43:31 <benmachine> the (very) partial ordering of information content/definedness
14:43:47 <artymis> oh cool
14:43:47 <Fuuzetsu> tibbe: can you clear this up, it's your package I believe (why network exports sClose in Network and Network.Socket)
14:43:55 <benmachine> where, e.g. bottom <= Just bottom <= Just 5
14:44:00 <levi> Yeah, what benmachine said.
14:44:14 <benmachine> (but Just 5 and Just 7 are not comparable)
14:44:38 <levi> That's where _|_ comes from in Haskell. It's the least-defined element.
14:44:43 <dwcook> benmachine, why isn't it true that Just 5 <= Just 7?
14:44:51 <benmachine> dwcook: depends which <= you're talking about
14:44:56 <artymis> benmachine, so like, the 0 element would be a garbage element
14:45:03 <artymis> noise.
14:45:42 <benmachine> dwcook: the ordering I'm talking about is roughly x <= y if y is x with more information
14:46:01 <benmachine> but Just 5 isn't Just 7 with more information, they're different
14:47:04 <benmachine> and yeah, like levi said, "bottom" means bottom of this ordering, below every other element"
14:47:28 <artymis> :)
14:48:03 <hiptobecubic> benmachine, but you're describing data structures, not functions
14:48:10 <zzbacon> i always feel like discussions of bottom are somehow inappropriate
14:48:31 <arianvp> Oh man. elm-html is neat
14:48:39 <artymis> I know programs in haskell constitute a scott domain. i was just wondering what the least element would look like
14:48:41 <ReinH> benmachine: needs more denotational semantics
14:48:56 <arianvp> Time to port it to GHCJS. because haskell ftw
14:48:59 <benmachine> hiptobecubic: yes, I am, basically I'm commenting on the bits I know and being vague about the bits I don't :P
14:49:00 <int3__> can cabal switch between profiling and non-profiling builds without reconfiguring the whole thing?
14:49:34 <benmachine> hiptobecubic: I know that haskell functions are monotonic with respect to the ordering I just defined: this means basically that if you add more information to the input, you can only add more information to the output
14:49:48 <arianvp> Would be interesting to do virtual DOM diffing in haskell... does anybody know how performant this library is? https://hackage.haskell.org/package/gdiff
14:50:13 <benmachine> in particular you can't change your mind about any output you already generated... like, if f (Just bottom) = 7, then f (Just x) has to be 7 for all x, too
14:50:55 <arianvp> because as far as I know. tree diffing is O(n^3)
14:51:07 <ReinH> > fix (const 7)
14:51:09 <lambdabot>  7
14:51:10 <benmachine> hiptobecubic: I think continuous here means "preserves least upper bounds", but I'm not sure what property of haskell programs that corresponds to
14:51:26 <ReinH> benmachine: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
14:51:31 <artymis> o
14:51:55 <artymis> continuous = preserves structure ok that makes tons more sense
14:52:00 <Jazzy^Werkin> Hello, I'm trying to learn some esqueleto, still kind of new to Haskell and can get confused easily enough, I was wondering if someone could assist to make sure I understand something correctly before moving on in my reading?
14:52:19 <arianvp> Jazzy^Werkin: sure. what's up?
14:52:29 <benmachine> ReinH: oh right, yeah, that makes sense
14:52:50 <benmachine> it tells you how to compute functions on infinite data by considering partial prefixes, I guess
14:53:06 <Jazzy^Werkin> I'm looking at https://www.fpcomplete.com/project/54215/6J2cvOGSed lines #29 - 32, and I'm noticing a is used a couple of times, but accessing different fields.  Is the type of a intended to be an Entity of the table it's referencing and not the field itself?
14:53:17 <Jazzy^Werkin> s/table/table row
14:53:32 <benmachine> (I guess that's why defining isInfinite :: [a] -> Bool is impossible...)
14:54:32 <hiptobecubic> no isn't
14:54:54 <benmachine> well, one of the reasons :P
14:55:22 <zzbacon> isInfinite [a] = True
14:55:25 <arianvp> let me read. one sec
14:55:26 <zzbacon> big bang boom
14:55:33 <faryon> #haskell
14:55:34 <hiptobecubic> zzbacon, righto :)
14:55:50 <Jazzy^Werkin> Thanks, arianvp.  I just am trying to understand why a can be used multiple times in different contexts like that.
14:56:02 <hiptobecubic> @let isInfinite :: [a] -> Bool; isInfinite = const True
14:56:03 <lambdabot>  .L.hs:153:1:
14:56:03 <lambdabot>      Duplicate type signatures for ‘isInfinite’
14:56:03 <lambdabot>      at .L.hs:150:1-10
14:56:03 <lambdabot>         .L.hs:153:1-10
14:56:03 <lambdabot>  
14:56:13 <hiptobecubic> @unlet isInfinit
14:56:14 <lambdabot>  Parse failed: TemplateHaskell is not enabled
14:56:15 <hiptobecubic> @unlet isInfinite
14:56:15 <lambdabot>  Parse failed: TemplateHaskell is not enabled
14:56:19 <benmachine> hiptobecubic: see, I was right
14:56:22 <benmachine> you can't do it
14:56:23 <benmachine> it is impossible
14:56:29 <hiptobecubic> > isInfinite [1..]
14:56:30 <lambdabot>  Ambiguous occurrence ‘isInfinite’
14:56:30 <lambdabot>  It could refer to either ‘L.isInfinite’, defined at L.hs:151:1
14:56:31 <lambdabot>                        or ‘GHC.Float.isInfinite’,
14:56:31 <lambdabot>                           imported from ‘Prelude’ at L.hs:34:8
14:56:31 <lambdabot>                           (and originally defined in ‘base:GHC.Float’)
14:57:58 <benzrf> @undef
14:57:58 <lambdabot> Undefined.
14:58:02 <noteventime> Jazzy^Werkin: Do you understand the corresponding SQL-query?
14:58:08 <hiptobecubic> let and undef... who decided that
14:58:13 <benzrf> @unlet
14:58:14 <lambdabot>  Define what?
14:58:26 <benzrf> hiptobecubic: @define is the real command
14:58:33 <benzrf> @define v = 3
14:58:35 <lambdabot>  Defined.
14:58:36 <hiptobecubic> @define isInfiniteList :: [a] -> Bool; isInfinite = const True
14:58:37 <lambdabot>  .L.hs:148:1:
14:58:38 <lambdabot>      The type signature for ‘isInfiniteList’
14:58:38 <lambdabot>        lacks an accompanying binding
14:58:41 <hiptobecubic> @define isInfiniteList :: [a] -> Bool; isInfiniteList = const True
14:58:42 <lambdabot>  Defined.
14:58:44 <benzrf> @let is for syntax
14:58:44 <lambdabot>  Parse failed: TemplateHaskell is not enabled
14:58:50 <benmachine> hah
14:58:50 <benzrf> err, i mean it looks like a ghci let
14:58:56 <hiptobecubic> There we go at last.
14:59:06 <hiptobecubic> > isInfiniteList [1..]
14:59:06 <bennofs> benzrf: @define is only so that @def doesn't "autofix" to @undef
14:59:08 <lambdabot>  True
14:59:11 <benzrf> bennofs: oh
14:59:19 <bennofs> benzrf: at least that's what the comments in lambdabot code say :)
14:59:50 <bennofs> benzrf: https://github.com/int-e/lambdabot/blob/master/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Eval.hs#L32
14:59:51 <benzrf> oh right >.>
15:01:47 <Jazzy^Werkin> noteventime: I don't have the SQL Language translation in front of me, but essentially select all rows from author and tutorial tables where the author matches the id entered, sorts it, and returns a tuple of (author e-mail, tutorial title)
15:02:21 <Jazzy^Werkin> I'm not seeing where the author id is ever submitted to it, though.
15:02:52 <zzbacon> would you rather endure python, ruby or clojure?
15:04:53 <noteventime> Jazzy^Werkin: Submitted to it? 't' and 'a' here aren't the actual values in the database (I think, I haven't seen Esqueleto before, just quickly checked the docks)
15:04:54 * hackagebot ffmpeg-light 0.8 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.8 (AnthonyCowley)
15:04:56 * hackagebot GLUtil 0.8 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.8 (AnthonyCowley)
15:05:19 <Jazzy^Werkin> No, in this case, they're not.  They're placeholders for the returned tuples.
15:05:25 <noteventime> I think it would be more constructive to think of them as "handles" the library uses to figure out what table to look in
15:06:07 <noteventime> Jazzy^Werkin: exactly
15:06:17 <Jazzy^Werkin> Oh, I get it now.  :)
15:07:05 <noteventime> Jazzy^Werkin: None of the "==.", "^." e.t.c. operations are operations on the actual values either
15:08:00 <noteventime> It's probably easier to think of it as you just writing the SQL-string, but by concatenating pieces, with the library tagging along making sure they match up
15:08:52 <noteventime> In that light having the "a" and "p" in multiple places is no stranger than mentioning the able name in multiple places
15:09:18 <Jazzy^Werkin> I just didn't correlate the two variables to the tables.  I was thinking of them as what was used to return the values.
15:09:47 <Jazzy^Werkin> I understand now, and moreso by looking at the return value, that those are the table handlers.
15:10:06 <Jazzy^Werkin> I'm not sure why I didn't see that before, but thank you very much for your time in helping me to understand!!
15:12:06 <noteventime> No problem
15:12:29 <mister_integer> open question: I have a data constructor `Or Formula Formula`, and a generator `Gen Formula`.
15:12:43 <mister_integer> What's the best way to extend that generator to include the binary `Or` operator?
15:12:44 <noteventime> Thanks for bringing Esqueleto to my attention, looks like a pretty neat library
15:12:47 <mister_integer> using quickcheck
15:14:06 <Jazzy^Werkin> noteventime: You're very welcome.  :)
15:14:17 <Fuuzetsu> does anyone know if David Himmelstrup (lemmih) ever appears on IRC?
15:14:21 <mister_integer> I can't see how to do it with just the Functor class, and using a Monad seems like overkill
15:14:32 <noteventime> mister_integer: Use Applicative
15:15:23 <noteventime> mister_integer: "liftA2 Or" or "Or <$> formgen <*> formgen"
15:15:53 <noteventime> err "liftA2 Or formgen formgen", where formgen is your "Gen Formula"
15:17:09 <mister_integer> whoa, that's awesome!
15:17:10 <mister_integer> Thanks!
15:17:24 <mister_integer> noteventime: ^^ :D
15:17:41 <zzbacon> quick emacs q -> when you are at the open file prompt, is there a hotkey to empty the prefilled directory?
15:19:10 <noteventime> mister_integer: Applicative is, kind of, the "friendly" part of Monads tucked onto Functor :)
15:20:21 <noteventime> zzbacon: C-a C-k?
15:21:07 <noteventime> Unless you're using something like ido
15:21:28 <zzbacon> gracias, sensei
15:23:47 <tommah> I import Data.Complex and Math.Gamma and I want to perform a calulation like gamma(1+2i) which would be expressed in Data.Complex's syntax, using complex floats,gamma(1.0:+2.0). If I type `gamma(1.0:+2.0)` into ghci I get an error:
15:23:47 <tommah> <interactive>:5:1:
15:23:47 <tommah>     No instance for (Gamma (Complex a0))
15:23:47 <tommah>       arising from a use of `gamma'
15:23:47 <tommah> BUT if I first do `let a = 1.0:+2` and then write `gamma a` I get
15:23:49 <tommah> Prelude Math.Gamma Data.Complex> gamma a
15:23:51 <tommah> 0.15190400267003626 :+ 1.980488016185506e-2
15:23:53 <tommah> I gotta be making some kind of fundamental type error, but what is it?
15:23:57 <noteventime> zzbacon: That's just move-beginning-of-line combined with kill-line
15:25:44 <noteventime> tommah: does 'gamma (1.0 :+ 2.0 :: Complex Double)' work?
15:26:03 <acfoltzer> hi, I see that someone pinged me, but it must've gone past my scrollback. pong to whomever :X
15:26:09 <tommah> noteventime: amazing, it does!
15:26:31 <tommah> noteventime: did it interpret the 1.0:+2.0 inside the parentheses as Complex Float instead of Complex Double for some reason??
15:26:37 <tommah> why did this happen?
15:27:33 <jomg> tommah: it interpreted it as an unspecified instance of Fractional
15:27:57 <tommah> oh i see, because if i type `:t 1:+2` i see that
15:28:06 <tommah> but why did it work when i defined it with `let a...`?
15:28:13 <tommah> wouldn't a get inherited the Fractional?
15:28:37 <jomg> that's interesting, not really sure about that
15:29:37 <tommah> when i do it `:t a` gives me Complex Double
15:30:01 <tommah> so `:t 1:+2` is Fractional while `let a = 1:+2` and `:t a` is Complex Double
15:30:12 <jomg> hmm, it doesn't do that for me
15:30:25 <jomg> i still get a Fractional a => Complex a
15:30:57 <tommah> i'm running this on debian, tho that shouldn't make a difference
15:31:11 <noteventime> tommah: What GHC version?
15:31:20 <tommah> how do i check version?
15:31:25 <noteventime> ghc --version
15:31:28 <noteventime> or check with apt-cache show
15:31:29 <tommah> 7.4.1
15:31:40 <tommah> The Glorious Glasgow Haskell Compilation System, version 7.4.1
15:31:54 <noteventime> I think the behaviour might have changed
15:32:05 <tommah> ahh... debian's packages are older aren't they?
15:32:10 <noteventime> 7.4.1 is quite a... stable (read old) version
15:32:26 <tommah> lol
15:32:42 <arianvp> Okay I might be doing somethig dumb here
15:32:45 <arianvp> I got this line:
15:33:07 <arianvp> onclick (const $ setText "Hello" counterDiv >> return ()) def button
15:33:09 <arianvp> which doesnt work
15:33:12 <arianvp> but if I cahnge it to
15:33:29 <arianvp> onclick (\_ -> setText "Hello" counterDiv >> return ()) def button it does work
15:33:36 <noteventime> tommah: I think the behaviour might have changed, but I have to admit I'm not quite sure, I've never managed to understand type defaulting behaviour and stuff like that :), but when problems like the one you had arise it usually helps to add an explicit type
15:33:44 <arianvp> @def const
15:33:44 <lambdabot>  Parse failed: TemplateHaskell is not enabled
15:33:53 <arianvp> @src const
15:33:53 <lambdabot> const x _ = x
15:33:59 <arianvp> ohhh
15:34:19 <arianvp> wtf
15:34:27 <arianvp> why dont they result in the same thing?
15:34:51 <jomg> what exactly doesn't work in the first version?
15:34:57 <arianvp> it doesnt bind the event
15:35:01 <arianvp> say I have
15:35:02 <tommah> noteventime: yea i tried to do that with Complex Float but it didn't work, i didn't think of complex double -- when I write `:t gamma` it tells me `gamma :: Gamma a => a -> a
15:35:02 <tommah> ` which didn't tell me type.........but i guess the point is i can read the source code on hackage and see what the type it explicitly eh??
15:35:10 <arianvp> onclick (const $ putStrLn "hai") button
15:35:13 <arianvp> it doesnt print
15:35:15 <arianvp> but if  I do
15:35:22 <arianvp> onclick (\_ -> putStrLn "hai") button
15:35:23 <arianvp> it does
15:35:27 <noteventime> tommah: You can do :info Gamma
15:35:32 <arianvp> but in my head those two defs are the same
15:35:34 <jomg> tommah: it seems that it should work with Complex Float though
15:35:35 <noteventime> to see which types have instances of Gamma
15:35:55 <tommah> ohh interesting but then that gives me class (Eq a, Floating a, Factorial a) => Gamma a
15:36:19 <noteventime> tommah: Doens't it end with a list of instances?
15:36:50 <tommah> complex float does indeed work actually...so i must have did it wrong before: Loading package gamma-0.9.0.2 ... linking ... done.
15:36:50 <tommah> 0.15190400267003626 :+ 1.980488016185506e-2
15:36:50 <tommah> Prelude Math.Gamma Data.Complex> gamma(1:+2::Complex Float)
15:36:50 <tommah> 0.151904 :+ 1.980488e-2
15:37:03 <tommah> heres the info: gamma
15:37:04 <tommah> Prelude Math.Gamma Data.Complex> :info gamma
15:37:05 <tommah> class (Eq a, Floating a, Factorial a) => Gamma a where
15:37:05 <tommah>   gamma :: a -> a
15:37:05 <tommah>   ...
15:37:05 <tommah>         -- Defined in `Math.Gamma'
15:37:06 <tommah> Prelude Math.Gamma Data.Complex>
15:37:28 <noteventime> tommah: Use something lpaste.net if you want to paste things :)
15:37:40 <tommah> sorry
15:37:44 <noteventime> no worries
15:38:27 <noteventime> tommah: Might be another 7.4 -> 7.6/7.8 change then, http://hackage.haskell.org/package/gamma-0.9.0.2/docs/Math-Gamma.html <- you can see a list of instances here
15:38:57 <tommah> gotcha
15:39:04 <tommah> perfect
15:39:07 <tommah> ok that makes sense
15:39:23 <tommah> i love this language.....once i figure out what the issue is, the solution cascades into all the other stuff ive written
15:41:21 <zzbacon> sometimes the noun-soup appearance of some code bugs me
15:55:10 <mizu_no_oto> I have some code that boils down to something like "runST . Vector.thaw", and I'm getting a type error "Couldn't match type ‘ST s0 (V.MVector ... ))’ with ‘forall s. ST s c’".  How do I fix this?
15:56:42 <shachaf> What is it supposed to do?
15:56:42 <glguy> mizu_no_oto:    runST (Vector.thaw x)
15:57:05 <shachaf> Isn't Vector.thaw specifically supposed to give you something that you can't runST?
15:57:21 <glguy> fixing the first error should give him the second one
15:57:53 <mizu_no_oto> Is there a nice way to move between mutable and immutable vectors?
15:58:29 <shachaf> You can get a mutable vector for use in ST if you want, but then you have to use it within that instance of ST.
15:58:32 <glguy> yeah, ST. But you only get it to be a mutable vector within the context of the runST
15:58:37 <lf94> Ok guys I'm so close to getting this to work. What's wrong? error: http://paste.debian.net/112512/, code: http://paste.debian.net/112513
15:58:39 <mizu_no_oto> rather, is there a nice way to turn a vector into an MVector, run a calc in ST, then turn it back into a Vector and run the ST?
15:58:40 <shachaf> You can't just "have a mutable vector".
15:58:56 <mizu_no_oto> >_<
15:59:04 <kini> point-free style can be so satisfying to write but so painful to read :/
15:59:07 <shachaf> runST (do { m <- thaw v; ...; return (freeze m) })
15:59:28 <ReinH> kini: if it's painful to read then it probably shouldn't be done point-free
15:59:28 <shachaf> There's a wrapper for doing that particular operation more efficiently.
15:59:34 <kini> ReinH: exactly
15:59:43 <kini> well, pain of reading depends on the person, obviously
16:00:14 <glguy> mizu_no_oto: Here's an example: http://lpaste.net/108391
16:00:54 <genericpersona> some point free can be horrendous
16:01:02 <mizu_no_oto> >_<  I inverted the placement of freeze and thaw.  No wonder it didn't work
16:01:23 <aphury> hello! Has anyone problems with installing the GLFW lib? I’ve tried „cabal install glfw“ but it does not work. Last lines in log are something like: glfw/lib/enable.s:502:0:
16:01:23 <aphury>     Rest of line ignored. 1st junk character valued 37 (%).
16:01:24 <aphury> glfw/lib/enable.s:507:0: Unknown pseudo-op: .cfi_endproc
16:01:26 <shachaf> Ah. That's what you were trying to do.
16:01:55 <shachaf> Perhaps "What is it supposed to do?" was the right question after all.
16:02:38 <kini> finally decided on the third one of these: http://lpaste.net/108392
16:02:55 <genericpersona> check out this lovely point free reduction
16:02:56 <genericpersona> @pl \f g x y -> f (x ++ g x) (g y)
16:02:57 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
16:03:21 <kini> oh, as soon as (.) starts getting parenthesized I go get my jetpack, lol
16:03:31 <genericpersona> lol
16:03:36 <genericpersona> good call
16:03:42 <genericpersona> that's my new rule of thumb
16:04:38 <SrPx> From Typeclassopedia, "(Tricky) One might imagine a variant of the interchange law that says something about applying a pure function to an effectful argument. Using the above laws, prove that pure f <*> x = pure (flip ($)) <*> x <*> pure f"
16:05:00 * hackagebot rocksdb-haskell 0.1.0 - Haskell bindings to RocksDB  http://hackage.haskell.org/package/rocksdb-haskell-0.1.0 (AlexanderThiemann)
16:05:15 <SrPx> If I understand correctly, am I supposed to consider that this holds? pure f <*> x = ($ x) <*> pure f
16:06:30 <mizu_no_oto> it seems unfortunate and surprising, though, that "\v -> runST $ (V.freeze <=< V.thaw) v" typechecks but "runST . V.freeze <=< V.thaw"
16:06:35 <mizu_no_oto> doesn't
16:06:47 <shachaf> Yes. Such are rank-2 types.
16:06:50 <genericpersona> i think pure f <*> x = (flip ($ x)) <*> pure f
16:06:56 <shachaf> But you should know about Vector.modify
16:08:16 <augur> genericpersona: i dont think thats quite true
16:08:31 <genericpersona> probably not :)
16:08:33 <augur> oh, sorry, pure f, so no effects
16:08:40 <augur> then it should be true
16:08:45 <genericpersona> okay, good :)
16:08:55 <augur> as long as there's only one effect, there's no ordering
16:08:57 <genericpersona> not sure, i was just going off of SrPx's comment
16:09:16 <augur> so the same should be true if you had   f <*> pure x   vs   whatever its analog is
16:09:40 <augur> also i dont think you need flip there
16:09:52 <genericpersona> ah, actually not
16:09:57 <augur> in fact, i dont think you CAN have flip there
16:10:04 <augur> :r ($ 0)
16:10:09 <augur> whoops
16:10:14 <augur> :t ($ 'x')
16:10:16 <lambdabot> (Char -> b) -> b
16:10:20 <augur> :t flip ($ 'x')
16:10:21 <lambdabot> b -> (Char -> b -> c) -> c
16:10:40 <genericpersona> right right, i always get messed up with infix operators
16:10:47 <augur> so, flip will only work when f takes at least two args, and wont be right anyway!
16:10:48 <arianvp> ugh
16:11:00 <arianvp> anyone here ever worked with ghcjs-jquery ?
16:11:10 <genericpersona> i forget you can partially apply an infix operator so that the next argument gets applied on the left hand side of the operator
16:11:11 <augur> ($ x) <*> pure f   and   ($ pure x) <*> f
16:11:18 <augur> :$ ($ pure 'x')
16:11:23 <augur> :|
16:11:25 <augur> :t ($ pure 'x')
16:11:27 <lambdabot> Applicative f => (f Char -> b) -> b
16:11:29 <arianvp> http://lpaste.net/2560601494046900224 <- for some reason this isnt setting the text on click :/
16:11:36 <augur> oops no
16:11:45 <augur> :t (<*> pure 'x')
16:11:46 <lambdabot> Applicative f => f (Char -> b) -> f b
16:12:05 <fast_mutation> hi, i'm curious to learn the most efficient way for mutation in haskell. is stref my best bet?
16:12:15 <augur> :t (<*>) (<*> pure 'x')
16:12:17 <lambdabot> ((a -> Char -> b) -> a) -> (a -> Char -> b) -> b
16:12:29 <augur> hm
16:12:32 <augur> whatever. anyway
16:14:13 <lf94> I need your haskell genius to help me out here. error: http://paste.debian.net/112512/, code: http://paste.debian.net/112513
16:14:25 <arianvp> OKay WTF. sometimes when I compile the code DOES work and sometimes it DOESNT
16:14:29 <arianvp> i'm totally clueless
16:14:48 <arianvp> so basically. the behaviour of my app changed while I didnt change any code
16:14:51 <augur> the H in GHC stands for Heisenberg
16:15:45 <arianvp> augur: guess those quantum physics lectures can finally be put to use
16:16:40 <josephle> the true goal of haskell is to statically find heisenbugs
16:16:53 <lf94> Someone please please please help me out, it's been like 4 days since I've been trying to get Charts working
16:17:24 <arianvp> so yeh. my GHCJS webapp is 4 lines of code.  sometimes it handles button clicks. sometimes it doesnt
16:17:30 <arianvp> depends on how many times you refresh the page
16:17:38 <arianvp> ... time for a bug report! but I have no idea where the bug would be lol
16:18:46 <l0cust> You know, I'm been reading the Yesod book for the third time now
16:19:20 <l0cust> I think their motto should be "abusing Haskell's type system to the fullest extent."
16:19:33 <benzrf> poor type system :'(
16:19:41 <athan> l0cust: :D
16:20:02 <arianvp> Ok I give up
16:20:06 <arianvp> :(
16:20:13 <hiptobecubic> arianvp, that's the spirit
16:20:21 <hiptobecubic> let it wash over you
16:20:25 <l0cust> arianvp: you should be a perl programmer
16:20:33 <arianvp> Someone spot the bug please? : http://lpaste.net/2560601494046900224
16:20:34 <arianvp> :(
16:20:50 <arianvp> The events only fire once ... and they fire sometimes... if I refresh like 20 times
16:21:37 <l0cust> arianvp: sounds like a caching problem in your browser
16:22:11 <arianvp> how would caching affect clientside-executed code?
16:22:17 <arianvp> (I compile haskell to js)
16:22:26 <l0cust> arianvp: that seems like that question answers itself
16:23:28 <arianvp> l0cust: javascript DOM manipulations don't get cached as far as I know
16:24:08 <athan> avarianvp: Are you on chrom[ium,e]?
16:24:14 <arianvp> athan: yes
16:24:35 <l0cust> athan: You mean Chrom(ium|e)
16:24:42 <athan> arianvp: Hmm, gumme a sec
16:24:48 <arianvp> athan: but it also happens on firefox
16:25:06 <athan> l0cust: Neverrr! (I'm actually trying to make a converter lol)
16:25:10 <l0cust> arianvp: I don't think you should accept help from people who use incorrect regexes
16:25:32 <Cale> l0cust: who said it was a regular expression?
16:25:53 <athan> BNF fo lieeeeff
16:25:57 <arianvp> l0cust: especially considering I was adviced to become a perl programmer
16:26:00 <l0cust> Cale: I used to be a ruby program. Everything is a regex
16:26:14 <l0cust> Cale: s/program/programmer
16:26:14 <Cale> l0cust: You've come a long way for an AI
16:27:11 <athan> arianvp: Is there any way to select via an #id tag? Maybe you can debug a little better if you throw in some alternative selection
16:27:21 <athan> I haven't messed with ghcjs very much yet :/
16:27:29 <arianvp> yeh:   select "#yo"
16:27:42 <arianvp> I already tried that athan :)
16:27:45 <athan> arianvp: Is it more successful?
16:27:51 <athan> :)
16:27:56 <arianvp> not really no :/
16:28:11 <amalloy> is there a good way to convert "abcd" into [('a','b'),('c','d')]? in clojure i would just write (partition 2 "abcd"); it seems a bit weirder in haskell because tuples and lists aren't the same thing
16:28:20 <arianvp> maybe I should nudge luite once he's here.
16:28:25 <dfeuer> GHCJS sounds like a really cool project.
16:28:43 <arianvp> dfeuer: indeed. I'm writing bindings for virtual-dom at the moment
16:28:54 <athan> amalloy: _how_ did you want to split it? as if a, b, c, and d were functions?
16:29:00 <athan> or parameters to a function?
16:29:10 <amalloy> athan: just tuples of two
16:29:17 <arianvp> luite: are you here? :-)
16:29:24 <amalloy> that is, i assume the input has an even number of items, and i want 2-tuples out
16:29:39 <athan> arianvp: Give me a little while and I'll see what I can do, sorry that I can't solve immediately :(
16:29:51 <arianvp> athan: no problem heh.
16:30:03 <Cale> > [(x,y) | (x:y:_) <- takeWhile (not . null) . iterate (drop 2) $ "abcd"]
16:30:05 <lambdabot>  [('a','b'),('c','d')]
16:30:14 <arianvp> athan: I fear it's a problem with ghcjs-jquery
16:30:18 <dmwit> > [(x, y) | [x,y] <- chunksOf 2 "abcd"`
16:30:18 <luite> arianvp: yes
16:30:19 <lambdabot>  <hint>:1:38:
16:30:19 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
16:30:24 <dmwit> > [(x, y) | [x,y] <- chunksOf 2 "abcd"]
16:30:25 <athan> amalloy: okay, so you want a (even(n))-ary function
16:30:25 <lambdabot>  [('a','b'),('c','d')]
16:30:40 <dmwit> That way is much cleaner, I think. =P
16:30:54 <athan> wow
16:31:16 <arianvp> luite: I'm a bit stuck with a little GHCJS project. basically I got this code: http://lpaste.net/2560601494046900224 .  sometimes when I click the button the event gets handled. and sometimes it doesnt
16:31:16 <Cale> Well, yes, but you'll need to get chunksOf from somewhere
16:31:26 <Cale> (specifically, the split package)
16:31:31 <arianvp> depend on how many times I recompile and/or refresh.
16:31:53 <dmwit> Possibly even cleaner still (though not guaranteed) is to not need tuples in the first place.
16:31:54 <amalloy> aha, Data.List.Split - i looked for something like chunksOf in Data.List but couldn't find it
16:32:06 <dmwit> > split 2 "abcd"
16:32:08 <lambdabot>  No instance for (GHC.Num.Num
16:32:08 <lambdabot>                     (Data.List.Split.Internals.Splitter GHC.Types.Char))
16:32:08 <lambdabot>    arising from the literal ‘2’
16:32:11 <Cale> Of course, you could also write  chunksOf n = takeWhile (not . null) . map (take 2) . iterate (drop 2)
16:32:14 <dmwit> > chunksOf 2 "abcd" -- I mean
16:32:16 <lambdabot>  ["ab","cd"]
16:32:17 <luite> arianvp: does it get handled for a short period of time and then it stops?
16:32:36 <arianvp> luite: it either doesn't handle it at all. or it handles it once
16:33:11 <luite> arianvp: and if you click quickly after loading (as qcuikly as possible?)
16:33:14 <Cale> arianvp: perhaps you could put the page somewhere that we could test it as well?
16:33:41 <arianvp> Cale: sure. let me quickly make a github repo
16:33:47 <luite> arianvp: i think i know what it is
16:33:55 <luite> and i really should update ghcjs-jquery
16:34:17 <arianvp> luite: really quickly refreshinng + click seems to work
16:34:54 <Fuuzetsu> arianvp: document it and call it a feature
16:35:01 <Fuuzetsu> spam protection
16:35:15 <luite> arianvp: k, the problem is that this is a fairly old lib, and it handles events by passing an MVar to JS
16:36:03 <luite> arianvp: then later ghcjs got more clever and it now sees that the MVar that the handler users internally is not reachable by any other haskell thread (it knows nothing about things hidden in the event handler)
16:36:07 <athan> So does anyone here have much experience with various languages? Haskell is call-by-need, which makes it's access calls to various syntax elements memoized, therefore making it's abstract syntax a graph, not a tree. Are there any other languages that have built-in memoization like this? How easy is it to reason about syntax graphs, semanticly-speaking? (:])
16:36:30 <luite> arianvp: so it throws an exception "Thread blocked indefinitely in an MVar operation" to that thandler thread
16:36:46 <dwcook> athan, it's not exactly memoization per se. But a single variable's value will be reused as necessary.
16:37:00 <arianvp> luite: the exception doesn't show up in the console though
16:37:01 <Cale> there's http://www.cas.mcmaster.ca/~kahl/HOPS/
16:37:32 <Cale> (though you can't get that)
16:37:36 <athan> dwcook: Hmm, what's the difference? Is it not memoization because function results aren't cached or something?
16:37:57 <Cale> athan: right
16:38:01 <athan> Cale: :(
16:38:15 <Cale> athan: If the results of functions were memoised, then nothing would ever be garbage collected
16:38:20 <athan> Cale: Do I need to drink some kool-aide or something?
16:38:37 <athan> Cale: Hmm!
16:39:50 <dwcook> athan, memoization can be done by storing data in a structure. E.g., instead of Integer -> Foo, use [Foo] (list of Foo)
16:40:04 <dwcook> Or Array Foo
16:40:27 <luite> arianvp: hmm, it could be something else then, or perhaps it has some unflushed buffer, but it's fairly likely that this is it
16:40:30 <athan> dwcook: Okay, so it's an encoding of additional information into the access to other information
16:40:38 <athan> for instance
16:40:39 <athan> at least
16:40:43 <dwcook> athan, I didn't understand that.
16:41:10 <arianvp> luite: I could try rewrite some parts of jquery (the parts I use) with the new  GHCJS.Foreign API. see if it fixes it
16:41:10 <athan> dwcook: an implicit form of usually explicit information?
16:41:35 <athan> like how accessing the list implicitly includes the Integer?
16:41:47 <arianvp> luite: so I should just basically use the asyncCallback* functions?
16:41:50 <dwcook> Well, you can index into a list or array with an Integer
16:41:51 <luite> arianvp: if you recompile with -DGHCJS_GC_INTERVAL=10000000 , and it works ok then, then this is the problem
16:42:08 <dwcook> athan, the important part is that it's a data structure rather than a function
16:42:33 <athan> dwcook: Okay, got it! Thank you!
16:42:47 <arianvp> luite: that fixed it.
16:43:04 <dwcook> > let fibs = zipWith (+) fibs (tail fibs) in fibs
16:43:08 <lambdabot>  mueval-core: Time limit exceeded
16:43:10 <dwcook> Woops
16:43:30 <dwcook> Oh I'm silly
16:43:30 <luite> arianvp: k i should really fix ghcjs-jquery then
16:43:37 <dwcook> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
16:43:39 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
16:44:01 <dwcook> So you could say fibs !! x to get the x'th number in the Fibonacci sequence
16:44:08 <dwcook> and the previous results will have already been computed
16:44:10 <arianvp> luite: I could probably help while I'm at it. seems like a tedious boring process
16:44:20 <dwcook> or rather
16:44:25 <dwcook> they will be computed once
16:44:59 <AndChat|600084> > [(fromIntegral((maxBound::Int) - 10))..]
16:45:00 <lambdabot>  [9223372036854775797,9223372036854775798,9223372036854775799,922337203685477...
16:45:13 <AndChat|600084> > [(fromIntegral((maxBound::Int) - 10)::Double)..]
16:45:14 <lambdabot>  [9.223372036854776e18,9.223372036854776e18,9.223372036854776e18,9.2233720368...
16:45:20 <Andrey> Hello, could someone please help out with FromJson in Aeson?
16:45:33 <athan> dwcook: So the list would be a memoized version of the recursive version of fib?
16:45:43 <athan> recursive function, I mean
16:45:44 <dwcook> athan, more or less
16:46:02 <athan> dwcook: Thank you! :)
16:46:06 <dwcook> Though note that getting the nth element of a list is still O(n)
16:46:35 <athan> dwcook: That's what I was wondering about
16:46:53 <athan> Bird's "enumerating the naturals" would be memoized, right?
16:46:53 <dwcook> That's why I also mentioned Array, which if I recall has O(1) random access
16:47:02 <dwcook> I'm not familiar with what you're referencing
16:47:12 <luite> arianvp: i added a ticket
16:47:13 <l0cust> dwcook: are you talking about Vector? or something I don't know of?
16:47:31 <dwcook> l0cust, http://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array.html#t:Array
16:47:50 <dwcook> But yeah, other sequence types would work as well
16:47:53 <luite> arianvp: the problem is that it's rather tricky to do this in a fully general way without leaks
16:47:57 <athan> dwcook: You can imagine the natural numbers as being a recursive function, here let me find a good example
16:48:22 <l0cust> dwcook: vector has o(1) lookup I think
16:48:31 <athan> dwcook: s/naturals/rationals/g (sorry!)
16:48:37 <lf94> error: http://paste.debian.net/112512/, code: http://paste.debian.net/112513 <- how do I stop this error
16:48:44 <athan> dwcook: http://en.wikipedia.org/wiki/Calkin%E2%80%93Wilf_tree
16:49:11 <dwcook> lf94, sounds like you're handing something the wrong type
16:49:13 <luite> arianvp: is there a reliable way to get notified when an event handler has been removed from the DOM completely?
16:49:22 <athan> Bird turned it into a 2d matrix
16:50:57 <Andrey> in Aeson, if I have a data type that is of this form: data Paper = ISO | ANSI. And I wanted to parse a field in json to this data type, how would I do it?
16:51:06 <octopuscabbage> can anyone reccomend a gui library for haskell?
16:51:15 <dwcook> athan, it's sort of like how you can define the naturals inductively: data Nat = Zero | Succ Nat
16:51:16 <octopuscabbage> i'm trying to write a graphical debugger
16:51:30 <l0cust> octopuscabbage: anything wrong with gtk2hs?
16:51:53 <athan> dwcook: Exactly, where [0..] would be a memoized version?
16:51:55 <octopuscabbage> No, is it decent?
16:51:59 <athan> (could)
16:52:05 <dwcook> athan, not sure what you mean
16:52:10 <arianvp> luite: I don't think so.  I usually totally avoid that problem by only attaching an event listener to the root dom element (<body>) and use event delegation instead
16:52:13 <l0cust> octopuscabbage: I don't know, it seems to be what everyone uses
16:52:20 <octopuscabbage> sounds good, i'll use that
16:52:45 <dwcook> athan, ah, I think I see. Well, it'd be about how you defined the list of the naturals, I guess
16:52:46 <dmj`> Andrey: instance FromJSON Paper = parseJSON (Object o) = do { String fld <- o .: "paper"; case fld of { "ISO" -> ISO; "ANSI" -> ANSI } }
16:52:54 <dmj`> forgot the where
16:53:12 <danl-ndi> is there a good reference for reading about the unboxed numeric types?
16:53:15 <athan> dwcook: I'll have to think about this more :)
16:53:33 <dmj`> given a json object of { paper : 'ISO' }
16:53:40 <Andrey> dmj`: would it be possible to somehow use Read, Show instead of doing by hand?
16:53:54 <dwcook> athan, oh I've got it
16:54:03 <dwcook> let nats = Zero:map Succ nats in nats
16:54:05 <dmj`> Andrey: You really don't want to, parseJSON is really a parser
16:54:34 <athan> dwcook: :O!
16:54:53 <Andrey> dmj`: ok, thanks! but what if I don't have an object, but just want to parse value?
16:55:31 <Andrey> dmj`: I have a larger object and paperType is one of the fields like this paperType :: Paper
16:55:37 <dmj`> >>> decode "{\"name\":\"Joe\",\"age\":12}" :: Maybe Person --> Just (Person {name = "Joe", age = 12})
16:55:39 <dwcook> athan, although in Haskell that datatype would also contain some values that aren't really natural numbers, such as let x = Succ x in x
16:55:40 <dmj`> from the docs
16:55:47 <arianvp> luite: why would you need that? to notify that the callback can be garbage-collected?
16:55:52 <dwcook> athan, but that value wouldn't be in the list I just defined
16:56:51 <dmj`> Andrey: then make a FromJSON for both the larger object and Paper
16:57:32 <Andrey> something like this? instance FromJSON Paper where     parseJSON v = v :: Maybe Paper     parseJSON _ = mzero
16:57:37 <joehillen> My coworker made a joke "sum $ (9%) . (10^) <$> [1..] doesn't evaluate to 1, I'd better file a bug report!"
16:58:04 <l0cust> Andrey: haven't really been paying attention, but why don't you use optional query operators?
16:58:38 <benzrf> joehillen: lol
16:58:57 <benzrf> :k Real
16:58:58 <lambdabot> * -> Constraint
16:59:21 <benzrf> @let limit :: Real a => [a] -> Maybe Real; limit = error "implying i know"
16:59:22 <lambdabot>  .L.hs:155:35:
16:59:22 <lambdabot>      Expecting one more argument to ‘Real’
16:59:22 <lambdabot>      The first argument of ‘Maybe’ should have kind ‘*’,
16:59:22 <lambdabot>        but ‘Real’ has kind ‘* -> Constraint’
16:59:22 <lambdabot>      In the type signature for ‘limit’:
16:59:30 <benzrf> @let limit :: Real a => [a] -> Maybe a; limit = error "implying i know"
16:59:31 <lambdabot>  Defined.
16:59:39 <benzrf> > limit $ (9%) . (10^) <$> [1..]
16:59:41 <lambdabot>  *Exception: implying i know
17:00:21 <luite> arianvp: something like that yeah. there should be a refernce stored to the event handler so that the haskell runtime knows where it is, but it shouldn't leak indefinitely
17:00:42 <luite> arianvp: not storing it is an option, but has some other downsides
17:02:14 <dmj`> Andrey: { B : { someNum : Int, A : { vala : 'a', valb : 'b' } }, then represent them by data B = B Int A... and data A = A Text Text, then make instances like instance FromJSON A where parseJSON (Object o) = A <$> o .: "vala" <*> o .: "valb" ... and instance FromJSON B where parseJSON (Object o) = do { someNum <- o .: "someNum"; a <- o .: "A"; return B someNum a }
17:02:48 <lf94> dwcook: yeah but I have no idea where to start to fix it
17:02:48 <arianvp> luite: so does GHCJS.DOM cope with the same problems?
17:04:05 <luite> arianvp: i'm not completely sure, but i think it gives you an IO action back that unregisters the handler, and you have to call that yourself to free it
17:05:13 <athan> Anyone know of any good `intersperse ",
17:05:15 <athan> crud
17:05:19 <athan> let me try that again
17:06:06 <Andrey>  dmj`: that's what I already have, except in that data there is another data field (paperType :: Paper) which also requires FromJson instance
17:06:47 <dmj`> Andrey: ok
17:06:51 <Andrey> dmj`: and it's not Object o, just a string incoming, and should be parsed as data Paper = ISO | ANSI
17:07:10 <dmj`> Andrey: sure
17:07:18 <Andrey> dmj`: is that even possible? :)
17:07:19 <orion> thoughtpolice: What's the difference between thoughtpolice/salt and thoughtpolice/hs-nacl?
17:07:42 <athan> Anyone know of any good `concat $ intersperse ", " ["books", "communities", "articles", "websites"]` on [Constructive ]Algorithmics?
17:08:10 <benzrf> athan: perhaps you mean intercalate
17:08:45 <athan> benzrf: intersperse from Data.List worked for me!
17:08:57 <athan> er wait
17:09:16 <athan> yeah you're right
17:09:19 <athan> (sorry)
17:09:44 <benzrf> :t intercalate
17:09:45 <lambdabot> [a] -> [[a]] -> [a]
17:10:43 <athan> benzrf: *tattoos in brain* thanks haha
17:11:06 <dmj`> Andrey: yes
17:11:20 <luite> arianvp: i think returning an IO action is probably the best low-level way we have right now. higher level libs, like react-like things can probably deal with it reasonably well, the jquery approach just appears to be a particlarly bad fit
17:12:02 <arianvp> luite: but the jquery lib does return into IO right?
17:12:51 <Andrey> dmj`: parseJSON (String s) = case T.unpack s of  and then do cases?
17:13:03 <luite> arianvp: yeah, but the IO JQuery result would need to change to something like IO (JQuery, IO ())
17:13:27 <luite> arianvp: where you call the second thing to unregister the listener
17:14:04 <arianvp> yes, I see
17:15:24 <Andrey> dmj`: It seemed to work, thank you for navigation! :)
17:15:54 <luite> arianvp: for react and similar libs, you'd probably have only one or a few listenrs on the whole page and they just stay there, but with jquery managing those IO things could get somewhat messy
17:16:33 <jmcarthur> if anybody feels like working through a difficult question of asymptotics, i have such a puzzle for you! what are the running times of cons, snoc, and uncons in this module? (this is pretty much an attempt to get an interested party to do the dirty work for me, no attempt to hide that here) http://hub.darcs.net/jmcarthur/catenable-queue/browse/Queue.hs
17:16:50 <arianvp> luite: react only uses 1 listener for the entire app :D
17:17:04 <jmcarthur> Purely Functional Data Structures is probably a prerequisite for this
17:17:06 <arianvp> luite: I'm building a React clone in GHCJS using virtual-dom. :)
17:18:07 <jmcarthur> the catMaybes makes me feel funny, in particular, although this information may be too early for anybody trying to understand it right now
17:19:04 <luite> arianvp: yeah then it should be perfectly fine :)
17:19:25 <arianvp> luite: I can't seem to build lens :(
17:19:40 <luite> arianvp: oh what goes wrong? it used to work
17:19:49 <arianvp> http://lpaste.net/1534055979035918336
17:19:50 <luite> but i havent built it for some time
17:19:53 <dmj`> Andrey: np
17:20:04 <arianvp> that is lens-4.3.2
17:20:43 <luite> arianvp: hmm, might actually be a sandbox issue. does building outside a sandbox work?
17:21:44 <arianvp> luite: let me try.
17:25:11 * arianvp gets a cup of tea whilst lens is compiling
17:26:06 <luite> :)
17:26:29 <arianvp> should've probably enabled parallel building. (that exists these days, right?)
17:26:48 <luite> brb, i need to get something to eat, spent too much time trying to figure out why recent firefox is 5000x slowr than older versions on some time-critical ghcjs rts bits
17:26:52 <dwcook> I keep forgetting to do that myself. Is there a way to put that in the cabal config?
17:27:18 <dmj`> think parallel installs are automatic now, unsure about builds
17:27:30 <arianvp> dmj`: it's an install.
17:27:33 <luite> arianvp: yes and if you have the latest Cabal/cabal-install version from the ghcjs repo, it should know that ghcjs supports parallel
17:27:41 <acowley> installs are automatically parallel
17:27:45 <dwcook> Neat
17:28:03 <arianvp> Configuring lens-4.3.2... Building lens-4.3.2..,
17:28:12 <pingu> this is totally an excuse to get more cores
17:28:50 <arianvp> luite: it  still failed
17:29:12 <arianvp> http://lpaste.net/7414546139237580800
17:30:29 <dfeuer> > length $ take 5 $ iterate undefined undefined
17:30:31 <lambdabot>  5
17:31:08 <dfeuer> head $ iterate (+3) 4
17:31:13 <dfeuer> > head $ iterate (+3) 4
17:31:15 <lambdabot>  4
17:38:23 <luite> arianvp: oh i get that one too, i thought i fixed that a few days ago
17:38:50 <luite> arianvp: the problem is that the javascript file is not run trough the preprocessor
17:39:48 <lf94> What does .~ do in haskell
17:39:55 <lf94> Example: https://github.com/timbod7/haskell-chart/wiki/example-9
17:39:58 <aphury> Is there any chance to force cabal to use /usr/local/bin/gcc-4.9 and NOT /usr/bin/gcc (which is actually clang).
17:40:07 <hpc> :t (.~)
17:40:08 <lambdabot> ASetter s t a b -> b -> s -> t
17:40:10 <luite> arianvp: i'll have a look in a few minutes
17:40:21 <hpc> it does lens things
17:40:40 <hpc> apparently related to setting a thing
17:41:28 <arianvp> hpc: good description how I feel about using lenses half of the time
17:42:08 <lf94> I've never seen "myfunc :: a b c d -> e -> f" notation before
17:42:23 <lf94> How is that supposed to work
17:42:28 <hpc> it's a type signature
17:42:30 <hpc> for instance
17:42:32 <dmj`> just multi parameter type classes
17:42:32 <hpc> :t (+)
17:42:33 <lambdabot> Num a => a -> a -> a
17:42:55 <hpc> oh, and it's a type that takes other types as parameters
17:43:02 <hpc> (not a class, there's no "=>")
17:43:13 <hpc> so like Either
17:43:16 <luite> arianvp: or actually it looks like it does call cpp but with the wrong settings
17:43:18 <hpc> but with even more muchness
17:43:28 <bb010g> :t (=<<) . const
17:43:29 <lambdabot> Monad m => m b -> m a -> m b
17:43:34 <dmj`> oh, nvm ASetter isn't a typeclass :)
17:43:46 <bb010g> :t flip $ (=<<) . const
17:43:48 <lambdabot> Monad m => m a -> m b -> m b
17:43:57 <bb010g> :t (>>)
17:43:58 <lambdabot> Monad m => m a -> m b -> m b
17:45:06 <orion> keys1@(p1,_s2) <- createKeypair -- What is this '@' notation in haskell?
17:45:32 <arianvp> orion: it means    the non-pattern-matched value
17:45:48 <hpc> orion: keys1 is treated as (p1,_s2)
17:45:56 <hpc> it's a way to refer to the whole thing without so much noise
17:46:02 <orion> Interesting
17:46:06 <arianvp> so it basically does:     keys1 <- createKeypair;  let (p1,_s2) - keys1;
17:46:08 <bb010g> orion: In whole@(part1,part2) = (1,2), whole == (1,2), part1 == 1, & part2 == 2
17:46:08 <arianvp> in one step
17:46:18 <arianvp> let (p1,_s2) = keys1;*
17:46:49 <orion> Why not just do: (p1,_s2) <- createKeypair; ?
17:47:43 <hpc> if you have to refer to the whole tuple, it's annoying to write it out each time
17:47:56 <orion> ah
17:49:00 <hpc> > let list@(x:y:z:zs) = "1234567" in (list, length list, list ++ (y:z:[]), x:list)
17:49:02 <lambdabot>  ("1234567",7,"123456723","11234567")
17:49:39 <arianvp> luite: I'm off to bed. thanks for the help! hope we can figure out the lens thing out as well later.
17:49:43 <arianvp> bye everyone :-)
17:50:16 <lf94> :t (.~)
17:50:17 <lambdabot> ASetter s t a b -> b -> s -> t
17:50:34 <lf94> If only I could understand this
17:50:51 <lf94> something about stabbing
17:51:15 <glguy> The name for that is "set"
17:51:22 <luite> arianvp: i know the problem, it's using -traditional for cpp, which dos not support the extended syntax
17:51:26 <glguy> > set _1 'c' ('a','b')
17:51:27 <lambdabot>  ('c','b')
17:52:34 <lf94> glguy: ah ok
17:52:39 <lf94> that makes more sense
17:52:49 <lf94> but I still dont understand the definition
17:52:52 <arianvp> > talking about lenses
17:52:54 <lambdabot>  Not in scope: ‘talking’
17:52:54 <lambdabot>  Perhaps you meant ‘taking’ (imported from Control.Lens)Not in scope: ‘about’...
17:52:54 <lambdabot>  Perhaps you meant one of these:
17:52:54 <lambdabot>    ‘lines’ (imported from Data.List),
17:52:54 <lambdabot>    ‘BSLC.lines’ (imported from Data.ByteString.Lazy.Char8),
17:52:57 <arianvp> > a wild edwardk appears
17:52:58 <lambdabot>  Not in scope: ‘wild’Not in scope: ‘edwardk’Not in scope: ‘appears’
17:53:12 <edwardk> :p
17:53:18 <arianvp> oh. that is a lambdabot command apparently
17:53:28 <dwcook> EDWARDK used EXPLAINS LENS! It's super effective! LF94 fainted!
17:53:38 * edwardk dodges the pokeball
17:55:03 <augur> lf94: having trouble grokking lenses?
17:55:12 <arianvp> been there...
17:55:16 <arianvp> still am there ...
17:55:18 <arianvp> :D
17:55:21 <augur> might i suggest my little tutorial
17:55:22 <augur> https://www.fpcomplete.com/user/psygnisfive/from-zipper-to-lens
17:55:49 <augur> it requires knowledge of zippers, but they're easy
17:56:32 <lf94> lol
17:56:36 <lf94> reading...
17:56:54 <lf94> I'm mainly trying to get this code to work: http://paste.debian.net/112551/
17:57:09 <lf94> I keep getting an error about the def keyword
17:57:13 <lf94> or variable*
18:00:37 <pavonia> What error?
18:01:04 <lf94> When you compile it you get no errors?!
18:01:33 <dwcook> "What error?" wasn't rhetorical
18:01:41 <dwcook> It's actually helpful to see the error message
18:01:56 <lf94> http://paste.debian.net/112553/
18:02:01 <geekosaur> not everyone has every dependency needed to compile random code installed; nor do they necesarily have whatever version(s) you have
18:02:14 <lf94> I know this, just the way he said it
18:02:14 <geekosaur> and errors can be caused by things like having multiple versions installed too
18:08:36 <lf94> so no ideas eh
18:09:53 <arianvp> luite: I patched the lens library. but the build still fails. both in  sandbox mode and global mode:  http://lpaste.net/2234547136215646208
18:10:20 <pavonia> lf94: Seems you can't use Rational values as plot data
18:10:45 <arianvp> luite: just the CPP error is gone. but the build still fails
18:11:25 <lf94> Mmmmm, ok
18:12:21 <arianvp> Ohwell. off to bed. I shall investigate further after some well deserved sleepy time.
18:13:21 <luite> that ILLEGAL means that the file wasn't preprocessed and that template haskell couldn't complete
18:28:46 <trap_exit> so I just setup my triple monitor setup
18:28:48 <trap_exit> I feel powerful
18:29:19 <trap_exit> left = application, center = emacs + ghc compile errors, right = ghci + #haskell
18:29:25 <trap_exit> this is fucking awesome
18:29:58 <dmj`> trap_exit: pics
18:30:00 <heatsink> You're not the kind of person who's bothered by non power of two sizes, I take it.
18:31:00 <trap_exit> number of monitors should always be of the form 2n+1
18:31:09 <trap_exit> where 1 = center monitor, and n = # on left = # on right
18:31:20 <trap_exit> trherefore, if you want power of 2, you're limited to 1 monitor
18:31:44 <trap_exit> djm` : I can't capture all 3 monitors at once
18:32:07 <c74d> why 2n+1?
18:32:11 <lf94> Ok so I'm doing floor() but it still thinks I have a ratio for plotting
18:32:20 <trap_exit> because you have a center monitor
18:32:23 <trap_exit> then n on left, and n on right
18:32:26 <c74d> not necessarily
18:34:40 <c74d> my chair can rotate
18:34:40 <c74d> any monitor I choose could be the center
18:34:41 <trap_exit> my chair rotates too
18:34:41 <trap_exit> but my desk is not circular
18:34:41 <c74d> oh
18:34:41 <dolio> @type floor
18:34:41 <c74d> I suppose most aren’t
18:34:41 <lambdabot> (RealFrac a, Integral b) => a -> b
18:34:41 <c74d> my apologies :s
18:35:08 <trap_exit> c74d: is this your work desk? http://office-turn.com/wp-content/uploads/2012/01/Italian-round-wood-lobby-desk-furniture-in-curved-panels.jpg
18:36:02 <hpc> that's a neat desk
18:36:08 <hpc> loads of computer space
18:37:00 <c74d> I’m afraid not, I don’t really have much of a desk
18:37:16 <pavonia> lf94: try [[ (x, bjbj (toRational x)) | x <- [0..3000]]]
18:37:58 <SrPx> Is there any way to write `test2` in that style? http://lpaste.net/108394
18:38:51 <pavonia> add <$> add 1 2 <*> add 3 4
18:39:24 <pavonia> Err, no
18:40:15 <stalintrotsky> hi
18:40:25 <stalintrotsky> How do I make cabal copy assets when it builds?
18:40:46 <lf94> pavonia: no luck
18:40:57 <dmj`> stalintrotsky: what do you mean assets?
18:41:05 <lf94> pavonia: my bjbj function takes a ratio
18:41:10 <dmj`> stalin has trotsky killed btw
18:41:13 <lf94> it's complaining about what bjbj is returning
18:41:13 <dmj`> had*
18:41:18 <pavonia> lf94: What error do you get?
18:41:34 <stalintrotsky> I have a default configuration file I want to copy into the build directory
18:41:37 <lf94>  Couldn't match type `a0 -> Rational' with `GHC.Real.Ratio Integer'
18:41:42 <lf94> Expected type: Rational
18:41:53 <lf94>  Actual type: a0 -> Rational
18:42:13 <pavonia> Paste the complete error please (but no here)
18:42:16 <pavonia> *not
18:43:06 <pavonia> :t (>=>)
18:43:06 <dwcook> lf94, make sure you're passing the right number of arguments to the relevant function
18:43:07 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:43:21 <dwcook> lf94, that error indicates you're probably not
18:43:44 <dwcook> lf94, by the way, Rational is just another name for Ratio Integer
18:44:44 <lf94> Ah, right
18:44:53 <lf94> I'll paste my code again and the error
18:49:07 <SrPx> Nobody knows? Maybe I didn't respect some monad law? Because I guess test1 and test2 should be equal here... :(
18:49:19 <octopuscabbage> guys i have great name for a haskell debugger
18:49:22 <octopuscabbage> backstroke
18:49:28 <lf94> code: http://paste.debian.net/112559/
18:49:48 <octopuscabbage> "there's a fly in my curry and it appears to be doing the backstroke"
18:49:59 <dmj`> stalintrotsky: I'm confused, you mean a cabal.config file?
18:50:25 <lf94> error http://paste.debian.net/112560/
18:50:37 <pavonia> lf94: Please try what I pasted, literally
18:51:29 <pavonia> "bjbj toRational(x)" is the same as "bjbj toRational x" but different from "bjbj (toRational x)"
18:51:52 <lf94> Oh whoops
18:51:57 <lf94> Ok, tons of errors now
18:52:07 <pavonia> :(
18:52:49 <lf94> http://paste.debian.net/112562/
18:53:09 <pavonia> @@ @pl @undo do x <- add 1 2; y <- add 3 4; z <- add x y; return z
18:53:09 <lambdabot>  (add 3 4 >>=) . flip flip return . ((>>=) .) . add =<< add 1 2
18:53:35 <pavonia> @@ @pl @undo do x <- add 1 2; y <- add 3 4; add x y
18:53:35 <lambdabot>  (add 3 4 >>=) . add =<< add 1 2
18:54:43 <stalintrotsky> I mean in the .cabal file
18:55:03 <stalintrotsky> There are some files that are supposed to be in the build directory, but are not source files
18:55:12 <stalintrotsky> How can I make these copy over when I build with cabal?
18:55:15 <trap_exit> is there a way, in the context of smart consturctors, to be able to PATTERN match on a DUMB CONSTURCTOR, without being able to _CREATE_ via a DUMB constructor ?
18:56:29 <roconnor> trap_exit: you can simulate it with views and/or prisms.
18:57:34 <svercer> pavonia: join $ add <$> add 1 2 <*> add 3 4
18:57:34 <roconnor> @go view pattern haskell
18:57:35 <lambdabot> Maybe you meant: google googleit do
18:57:39 <roconnor> @google view pattern haskell
18:57:40 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns
18:57:53 <svercer> but I'm not sure how to get rid of the join; obviously there ought to be a more idiomatic way to do it
18:59:30 <pavonia> SrPx: Would svercer's suggestion be okay?
19:00:43 <SrPx> pavonia: didn't see it, thanks. It still doesn't produce the same result, sadly ): I guess I broke some monad laws there, so Log isn't really a monad. But I don't understand some things
19:01:27 <dwcook> SrPx, if I'm not mistaken, liftM2 add (add 1 2) (add 3 4) = do { x <- add 1 2 ; y <- add 3 4 ; return (add x y) }
19:01:38 <dwcook> SrPx, use that as a starting point for seeing how that's not the same as the previous
19:02:18 <SrPx> ie, I don't understand how `m >>= return == m` makes sense... say "m" is the number 1 boxed with some state. "return 1" is just 1 with an empty state. That law says that "1 boxed with some state" is equal to "1 boxed with no state" which is not true!!
19:02:48 <benzrf> SrPx: no!
19:03:07 <benzrf> SrPx: i had the same mental issue
19:03:08 <SrPx> dwcook: I've looked that definition some time ago, I get what is wrong with the code now... I just don't get what is wrong with what I said ):
19:03:13 <benzrf> then i realized the problem
19:03:21 <benzrf> SrPx: think of a *concrete example*
19:03:27 <benzrf> SrPx: what kind of state?
19:03:32 <benzrf> do you mean Writer? State?
19:03:39 <SrPx> benzrf: In this case, a log of events...
19:03:40 <benzrf> *State as in the monad
19:03:52 <SrPx> (http://lpaste.net/108394)
19:04:02 <benzrf> SrPx: is the data type pairs of log and result
19:04:12 <SrPx> yes
19:04:28 <benzrf> ok that's basically similar to Writer except that Writer allows arbitrary monoids
19:04:33 <benzrf> SrPx: think for a sec
19:04:35 <benzrf> let's say i have:
19:04:42 <benzrf> Log 3 "foo bar baz"
19:04:45 <svercer> SrPx: but the result of (m >>= return) isn't like the result of just (return); it's got extra "stuff" [depends on the monad] added in by (>>=), if that makes sense
19:04:55 <benzrf> what happens when i do `Log 3 "foo bar baz" >>= return'?
19:05:00 <benzrf> SrPx: also what svercer said :p
19:05:11 <SrPx> benzrf: it becomes (Log 3 "") :(
19:05:15 <benzrf> SrPx: it does?
19:05:21 <benzrf> the log *overwrites*?
19:05:26 <benzrf> SrPx: shouldnt it append?
19:05:43 <SrPx> benzrf: wait... well okay you are right
19:05:54 <benzrf> SrPx: :p
19:06:04 <benzrf> also i recommend just appending, not appending with a newline in the middle
19:06:10 <benzrf> adding the newline probably breaks some kind of law
19:06:24 <lf94> Why is printing a simple graph super complicated
19:06:30 * SrPx brain bleeds
19:07:01 <benzrf> SrPx: the key is to remember that `m >>= f' is not necessarily 'f <some value pulled out of m>'
19:07:14 <benzrf> SrPx: that's how it works for, say, Maybe.
19:07:38 <benzrf> SrPx: but in this case, `m >>= f' applies f to the value in m, BUT THEN IT CONCATS THE LOG FROM m ONTO THE RESULT
19:07:53 <dhrosa> and it does it in capital letters too
19:07:58 <benzrf> dhrosa: :p
19:08:03 <benzrf> SrPx: so the final result is not 'return <value from m>', it's 'return <value from m>, plus any logs from m'
19:08:12 <SrPx> okay listen, now I do get how the monad laws make sense but I'm back to not understanding what is wrong with my code ):
19:08:13 <benzrf> SrPx: so it's an identity, because return adds no new logs and just results in the same value
19:08:30 <SrPx> benzrf: I see I see
19:08:38 <dwcook> SrPx, the equation you're assuming is true is not given anywhere
19:09:01 <dwcook> test1 and test2 are not equal because there's nothing to say that they should be equal
19:09:25 <pavonia> Do they even have the same type?
19:09:33 <SrPx> dwcook: I mean, I understand test1 and test2 are different because liftM2 is defined a little differently than I expected, as it returns z without binding. But intuitively it doesn't make sense that they are different...
19:09:47 <svercer> SrPx: the reason it's not the same is because it needs (join)
19:09:48 <dwcook> SrPx, then your intuition needs to be retrained
19:09:57 <dwcook> s/re//
19:10:02 <SrPx> why would `do { x <- add 1 2; return add x x }` be different than `do { x <- add 1 2; y <- add x x; return y }` ??
19:10:21 <benzrf> SrPx: add x x is not a number
19:10:27 <benzrf> it's Log
19:10:41 <yogurt_truck> SrPx: what is the argument type for `return` there?
19:10:51 <augur> benzrf: i hate to do this but
19:10:53 <augur> thats not what reftrans is
19:11:02 <benzrf> augur: when did i mention reftrans
19:11:04 <Rarrikins> SrPx: return add x x is not the same as return (add x x).
19:11:08 <augur> benzrf: earlier!
19:11:18 <benzrf> augur: in which context
19:11:22 <benzrf> was it a referentially transparent context?
19:11:26 <augur> :X
19:11:35 <benzrf> he he he
19:11:39 <augur> also, regarding the   function (x) { return x + x; }   thing that newsham mentioned, it depends entirely on what "f(x)" means
19:11:46 <augur> benzrf: lemme find the context
19:11:49 <SrPx> Okay, nevermind that. I see. But would it make sense to define a function like that? `usefulLift f m0 m1 = do { x <- m0; y <- m1; z <- f m0 m1; return z }` ?
19:12:04 <SrPx> pardon, `f x y`
19:12:11 <benzrf> SrPx: that's just liftM2
19:12:34 <benzrf> remember, action >>= \z -> return z is same as action >>= return
19:12:36 <benzrf> eta reduction
19:12:42 <benzrf> and action >>= return is the same as action
19:12:43 <benzrf> monad laws
19:12:53 <benzrf> so you can drop the `z <-' and the ';return z '
19:12:57 <SrPx> benzrf: nah that is the point, liftM2 is actually `usefulLift f m0 m1 = do { x <- m0; y <- m1; return (f x y) }`
19:12:58 <benzrf> and you have an identical function
19:13:04 <augur> grr, my locks didnt transfer after the crash
19:13:06 <augur> stupid computer
19:13:07 <benzrf> SrPx: oooooh i see the difference
19:13:11 <SrPx> s/usefulLift/liftM2/
19:13:36 <benzrf> SrPx: see what i mean about me misreading minor things in the code that lead to significant changes
19:13:39 <benzrf> x.x
19:13:43 <augur> oh, the convo was in blah
19:13:51 <benzrf> augur: ah yeah i mentioned it there
19:13:52 <SrPx> which is what caused the confusion, I expected it was like `usefulLift`. I guess my question is actually: why is liftM2 the way it is? Is the version I expected worse/less useful?
19:14:02 <benzrf> SrPx: liftM2 is just liftA2
19:14:03 <SrPx> benzrf: :P
19:14:07 <benzrf> but in Monad instead of Applicative
19:14:19 <benzrf> similar to how liftM is fmap in Monad instead of Functor
19:14:30 <SrPx> hmmm...
19:15:42 <pavonia> :t \add -> add `ap` ad 1 2 `ap` add 3 4
19:15:44 <lambdabot>     Not in scope: ‘ad’
19:15:44 <lambdabot>     Perhaps you meant one of these:
19:15:44 <lambdabot>       ‘add’ (line 1), ‘id’ (imported from Data.Function),
19:15:51 <pavonia> :t \add -> add `ap` add 1 2 `ap` add 3 4
19:15:52 <lambdabot> Num a => (a -> a -> a -> a) -> a -> a
19:16:03 <pavonia> bah
19:16:33 <benzrf> @letlpaste 108394
19:16:36 <lambdabot>  Defined.
19:17:07 <benzrf> > add 2 3 *> add 4 5
19:17:09 <lambdabot>  add 2 3
19:17:09 <lambdabot>  add 4 5Result: 9
19:17:28 <benzrf> ^use case for (*>) btw
19:17:56 <pavonia> :t add `ap` add 1 2 `ap` add 3 4
19:17:57 <lambdabot>     Couldn't match expected type ‘Log (a1 -> a0 -> b)’
19:17:57 <lambdabot>                 with actual type ‘a2 -> a2 -> Log a2’
19:17:57 <lambdabot>     Probable cause: ‘add’ is applied to too few arguments
19:18:04 <spopejoy> :t add
19:18:05 <lambdabot> (Show a, Num a) => a -> a -> Log a
19:18:18 <pavonia> Why doesn't this work?
19:18:27 <lf94> haskell is too advanced for my mind
19:18:27 <spopejoy> :t Log
19:18:29 <lambdabot> a -> String -> Log a
19:18:40 <benzrf> :t return add `ap` add 1 2 `ap` add 3 4
19:18:41 <lambdabot> (Show a, Num a) => Log (Log a)
19:18:56 <benzrf> :t ap
19:18:57 <lambdabot> Monad m => m (a -> b) -> m a -> m b
19:19:04 <pavonia> Ah, I see
19:19:12 <spopejoy> :t (*>)
19:19:13 <lambdabot> Applicative f => f a -> f b -> f b
19:19:17 <SrPx> "[23:15] <benzrf> @letlpaste 108394" -- cool trick...
19:19:39 <Clint> when did that come from
19:19:48 <pavonia> @hoogle Monad m => (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
19:19:50 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
19:19:50 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
19:19:50 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
19:20:36 <benzrf> Clint: a while back, i PR'd it in
19:20:38 <benzrf> youre welcome :-)
19:20:48 <Clint> heh
19:21:00 <SrPx> Well, I've added a SO question regarding my intuitive problem with liftM2 http://stackoverflow.com/questions/25027767/why-is-liftm2-defined-the-way-it-is
19:21:05 <svercer> here's the thing: when you've got (add :: a -> a -> m a) and, say, (add 1 2 :: m a), the only way to apply (add) to (add 1 2) is to get some output with the monadic state of the latter, i.e. (_ :: m (a -> m a)). and that type is just awkward, because it's not like the first argument to (ap)/(<*>), (_ :: m (a -> b)), nor to (>>=), (_ :: a -> m b)
19:21:17 <benzrf> SrPx: because it's liftA2
19:21:51 <svercer> er, first argument to (=<<), which I always end up using instead =)
19:22:48 <SrPx> benzrf: no, I see that, I mean... why it is `liftA2` in the first place. Why `liftA2` is useful for monads. Why there is no `usefulLift` like the one I wrote? Is it not useful? That is what I mean...
19:23:13 <SrPx> things you probably know from experience
19:23:42 <benzrf> add <*> add 1 2 <*> add 3 4
19:23:46 <benzrf> SrPx: it just doesnt come up as much, is all
19:23:54 <benzrf> no wait thats wrong bleh
19:23:58 <SrPx> :p
19:23:59 <benzrf> *my above example
19:24:00 <svercer> meh, if there's a good reason for liftA2 I sure don't know it; (<$>) (<*>) and friends seem so much nicer
19:24:15 <benzrf> svercer: i prefer liftA2 if only because it partially applies better
19:24:25 <benzrf> and if you cover the liftA2 call with your finger, it looks like normal appl!
19:24:38 <SrPx> svercer: but there isn't something like <$> / <*> that works for monads on my case
19:24:48 <svercer> benzrf: the reason that's not right is because (<*>) is useful in the applicative world, but in the applicative world we don't have the (:: a -> m b) type
19:25:01 <benzrf> svercer: yeah
19:25:01 <svercer> SrPx: if there is I'd like to know! =D
19:25:03 <benzrf> i had a brain fart
19:25:29 <monochrom> SrPx: you have a type error in your suggestion
19:25:37 <benzrf> @hoogle (a -> b -> m c) -> m a -> m b -> m c
19:25:38 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
19:25:38 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
19:25:39 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
19:25:42 <benzrf> no wait der
19:25:46 <benzrf> no wait yes
19:25:48 <benzrf> bleh
19:25:54 <benzrf> SrPx: you could just join the result
19:26:05 <benzrf> :t liftM2 add (add 1 2) (add 3 4)
19:26:07 <lambdabot> (Show a2, Num a2) => Log (Log a2)
19:26:08 <benzrf> :t join $ liftM2 add (add 1 2) (add 3 4)
19:26:10 <lambdabot> (Show a, Num a) => Log a
19:26:38 <SrPx> but it still produces wrong result
19:26:44 <benzrf> SrPx: does it?
19:26:47 <svercer> benzrf: pavonia just hoogled that, and I suggested (join $ add <$> add 1 2 <*> add 3 4) a while back. but great minds think alike =D
19:26:50 <SrPx> > print $ liftM2 add (add 1 2) (add 3 4)
19:26:52 <monochrom> @type \f m1 m2 -> do { x1 <- m1; x2 <- m2; x3 <- (f x1 x2); return x3 }
19:26:52 <lambdabot>  <IO ()>
19:26:53 <lambdabot> Monad m => (t -> t1 -> m b) -> m t -> m t1 -> m b
19:27:11 <monochrom> you also have a type error in your example usage
19:27:14 <SrPx> benzrf: hm I don't know how to use the lambdabot, but yes, it doesn't add the last \n
19:27:51 <benzrf> SrPx: >.>
19:28:02 <benzrf> SrPx: you dont want the IO
19:28:13 <monochrom> no, no type error in your example usage
19:28:15 <benzrf> print makes an IO action, you dont need to print
19:28:21 <benzrf> > liftM2 add (add 1 2) (add 3 4)
19:28:23 <lambdabot>  add 1 2
19:28:23 <lambdabot>  add 3 4
19:28:24 <lambdabot>  Result: add 3 7Result: 10
19:28:27 <SrPx> woops I meant join
19:28:27 <benzrf> > join liftM2 add (add 1 2) (add 3 4)
19:28:29 <lambdabot>  Couldn't match type ‘L.Log a’ with ‘L.Log a -> L.Log (L.Log a)’
19:28:29 <lambdabot>  Expected type: (L.Log a -> L.Log a -> L.Log (L.Log a))
19:28:29 <lambdabot>                 -> (L.Log a -> L.Log a -> L.Log (L.Log a))
19:28:30 <lambdabot>                 -> L.Log a0
19:28:30 <benzrf> > join $ liftM2 add (add 1 2) (add 3 4)
19:28:32 <lambdabot>                 -> L.Log a
19:28:34 <lambdabot>  add 1 2
19:28:36 <lambdabot>  add 3 4
19:28:38 <lambdabot>  
19:28:42 <svercer> SrPx: I'm not expert on the monad laws but I think it's because your (>>=) isn't idempotent; i.e., it actually modifies the "state" by adding that extra character. you could write a Monoid which only added the character when something had actually been logged, and you've just got Writer
19:28:42 <lambdabot>  add 3 7Result: 10
19:28:49 <benzrf> SrPx: looks right to me =)
19:28:56 <SrPx> benzrf: yes that was what I meant... see how it is weird? [23:27] <lambdabot>  add 3 7Result: 10
19:28:56 <benzrf> svercer++
19:29:03 <SrPx> that was what he was supposed to print:
19:29:20 <benzrf> SrPx: you're only putting newlines in between
19:29:20 <SrPx> > do { x <- add 1 2; y <- add 3 4; z <- add x y; return z }
19:29:21 <benzrf> not after
19:29:22 <lambdabot>  add 1 2
19:29:22 <lambdabot>  add 3 4
19:29:22 <lambdabot>  add 3 7
19:29:22 <lambdabot>  Result: 10
19:29:30 <benzrf> SrPx: ah
19:29:31 <monochrom> @type foldM
19:29:32 <SrPx> see, this way it works
19:29:33 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
19:29:36 <benzrf> it's because the return adds a newline
19:29:40 <benzrf> your instance breaks the laws!
19:29:46 <SrPx> svercer: hmmm......
19:29:49 <benzrf> svercer said that just earlier
19:29:50 <benzrf> :
19:29:52 <benzrf> * :P
19:30:10 <benzrf> SrPx: to be precise, moving the final step out to an extra return means 1 more call to (>>=), which adds another newline
19:30:24 <benzrf> SrPx: monad criminal
19:30:27 <SrPx> benzrf: svercer I see guys, insightful ! I will never forget that !
19:30:58 <svercer> SrPx: move "\n" to (add) and (mul)
19:31:08 <svercer> if that makes sense
19:31:24 <SrPx> so, listen... when monad is correct, is `do { x <- add 1 2; y <- add 3 4; z <- add x y; return z }` always equal to `join $ liftM2 add (add 1 2) (add 3 4)` ?
19:31:41 <benzrf> SrPx: yes
19:31:45 <SrPx> yay!
19:31:52 <benzrf> SrPx: try reading the src code and rewriting according to the laws
19:31:54 <benzrf> you can make them equal
19:31:57 <benzrf> SrPx: like doing algebra
19:32:19 <benzrf> SrPx: thats what people mean when they talk about how functional purity allows 'equational reasoning'
19:32:32 <benzrf> and how obeying the monad laws allows it
19:32:50 <SrPx> benzrf: you mean going from the 'do version to the 'liftM2 version?
19:32:58 <benzrf> SrPx: what i mean is
19:33:16 <benzrf> SrPx: if you rewrite the code for liftM2 and for your do version into using (>>=)
19:33:29 <benzrf> actually hold on 1 sec
19:33:31 <benzrf> let me show you
19:33:50 <benzrf> @src liftM2
19:33:50 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:34:02 <svercer> @letlpaste 108396
19:34:03 <lambdabot>  .L.hs:185:1:
19:34:03 <lambdabot>      Multiple declarations of ‘Log’
19:34:03 <lambdabot>      Declared at: .L.hs:162:1
19:34:03 <lambdabot>                   .L.hs:185:1
19:34:03 <lambdabot>  
19:34:07 <benzrf> @undef
19:34:07 <lambdabot> Undefined.
19:34:11 <svercer> ah
19:34:14 <svercer> @letlpaste 108396
19:34:16 <lambdabot>  Defined.
19:34:19 <svercer> > main
19:34:21 <lambdabot>  <IO ()>
19:34:30 <svercer> oh, right, he wouldn't...
19:34:37 <svercer> > test1
19:34:39 <lambdabot>  add 1 2
19:34:39 <lambdabot>  add 3 4
19:34:39 <lambdabot>  add 3 7
19:34:39 <lambdabot>  Result: 10
19:34:42 <svercer> > test2
19:34:44 <lambdabot>  add 1 2
19:34:44 <lambdabot>  add 3 4
19:34:44 <lambdabot>  add 3 7
19:34:45 <lambdabot>  Result: 10
19:34:53 <svercer> http://lpaste.net/108396
19:35:07 <SrPx> svercer: uh huh I just did that here (:
19:35:30 <SrPx> very, very insightful. I think I'm starting to grasp monads
19:36:18 <svercer> actually I just started trying to write my own novel instances the other day, so I'm definitely going to go back and check them all for legality now =D
19:36:36 <benzrf> @src join
19:36:36 <lambdabot> join x = x >>= id
19:36:37 <carter> adrienneleigh: ping?
19:37:27 <adrienneleigh> carter: i'm not really very here right at the moment, can i get back to you later?
19:37:33 <carter> sure
19:37:34 <adrienneleigh> (deadline)
19:37:40 <carter> werd
19:38:35 <SrPx> btw, what would be a good name for `something = join . liftM2` ? Which, as I see now, is just `liftM2` for when you have a monadic binary function instead of a pure one, right (:
19:38:38 <benzrf> bleh, im writing this poorly
19:38:47 <benzrf> SrPx: you cannot use (.) that way
19:38:54 <benzrf> :t join . liftM2
19:38:55 <lambdabot> Monad m => (a1 -> a1 -> r) -> m a1 -> m r
19:39:00 <benzrf> :t liftM2
19:39:01 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:39:11 <benzrf> note that liftM2 takes 3 args before returning the thing you want to put through join
19:39:24 <benzrf> join . liftM2 will put the result of 'liftM2 somefunc' through join
19:39:29 <SrPx> woops! you get the idea... `something f m0 m1 = join $ liftM2 f m0 m1`
19:40:00 <pavonia> :t (join .) . liftM2
19:40:02 <lambdabot>     Occurs check: cannot construct the infinite type: m ~ (->) (m a2)
19:40:02 <lambdabot>     Expected type: (a1 -> a2 -> r) -> m a1 -> m a2 -> m a2 -> r
19:40:02 <lambdabot>       Actual type: (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:40:08 <benzrf> SrPx: ok this is a little long winded
19:40:14 <benzrf> my point is this.
19:40:20 <benzrf> let's say you're doing a math problem
19:40:26 <benzrf> you have something like
19:40:30 <benzrf> f(x) = x * 3
19:40:32 <SrPx> benzrf: heh no problems
19:40:37 <SrPx> hmm,...
19:40:39 <benzrf> then you have an equation, like
19:40:44 <benzrf> y = f(5)
19:40:54 <benzrf> you are allowed to then move the applied result to the equation
19:40:57 <benzrf> y = x * 5
19:40:58 <benzrf> err
19:41:03 <benzrf> y = 5 * 3
19:41:04 <benzrf> >.>
19:41:28 <benzrf> SrPx: furthermore, there are certain rules you are allowed to use to manipulate sides of your equation without affecting their meaning
19:41:31 <benzrf> like
19:41:34 <benzrf> y = 3 * 5
19:42:01 <benzrf> SrPx: the key point is:
19:42:13 <benzrf> 1. since haskell is functoinally pure, you can manipulate and substitute haskell expression equatoins like this
19:42:34 <benzrf> you cannot do that in C, because a function call might have side effects, and you cannot represent those easily in the equation
19:42:54 <benzrf> 2. things like the monad laws are things like the 'law' that multiplication is commutative
19:43:02 <benzrf> they allow you to transform expressions without altering their meaning
19:43:07 <svercer> (math major chiming in: and this is all and only because, you know, we have an "instance Abelian Integer" or something like that. so the parallel is pretty deep, in a way)
19:43:10 <benzrf> so you could write out:
19:43:10 <benzrf> do {x <- add 1 2; y <- add 3 4; z <- add x y; return z}
19:43:16 <benzrf> oops, i mean
19:43:30 <benzrf> do {x <- add 1 2; y <- add 3 4; z <- add x y; return z} = join $ liftM2 add (add 1 2) (add 3 4)
19:44:07 <benzrf> ^then you can simplify by applying functions and manipulate sides by moving things around according to what the monad laws say will leave it the same
19:44:21 <benzrf> and so you can actually *prove* that those two expressions will do the same thing!
19:44:30 <benzrf> that is, if you can make both sides equal
19:44:34 <benzrf> not quite the same as in algebra
19:44:49 <benzrf> im misusing the equals sign there, probably
19:44:51 <benzrf> but i think you get the point
19:45:06 <SrPx> uh huh I see, that is one of the reasons I love Haskell and think it is so powerful. But doesn't that not hold in some cases due to unrestricted recursion?
19:45:34 <benzrf> SrPx: that's a separate issue iirc
19:46:18 <benzrf> SrPx: i am not sure though
19:46:33 <benzrf> anybody care to tlel mmm
19:46:39 <benzrf> oops crap keymashing
19:47:33 <heatsink> It's still true in recursive functions, due to laziness
19:48:06 <heatsink> > let ones = 1 : ones
19:48:07 <lambdabot>  not an expression: ‘let ones = 1 : ones’
19:48:11 <heatsink> @let ones = 1 : ones
19:48:13 <lambdabot>  Defined.
19:48:23 <benzrf> ok yeah i severely misused the equals sign in that example >_>'
19:48:29 <hiptobecubic> > let ones = 1:ones in ones
19:48:30 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:48:54 <silasm> is there a channel specifically for parsec help?
19:49:20 <heatsink> I can substitute 'ones' to get 1 : (1 : ones).  Algebraic transformations still work.
19:49:25 <heatsink> I don't think so, silasm
19:49:38 <dwcook> silasm, this is about as close to that as there is
19:49:53 <SrPx> hmmm...
19:50:58 <dwcook> SrPx, unrestricted recursion makes it so we add an extra inhabitant to every type. bottom :: forall a. a
19:51:11 <silasm> heh, well I need a parser for a nonescaped newline (e.g. one that's not prefixed by backslash). Is there an easy way to do that that I'm missing? Right now I'm just trying to make sure I parse an escaped newline in every case before I try to parse a newline, but that's troublesome.
19:51:14 <dwcook> SrPx, you can still do equational reasoning in its presence, in varying degrees depending on whether you neglect it or not.
19:51:21 <silasm> let me know if that got cut off :S
19:51:43 <dwcook> silasm, why's it troublesome?
19:51:43 <benzrf> silasm: it ended at troublesome
19:52:25 <silasm> nah, that's right. good. It's troublesome because it leaves a lot of room for accidental failure somewhere. If I could get some guarantee in the newline parser itself I'd prefer it.
19:52:46 <heatsink> silasm: If you have a parser for "\n", it will never accept "\\\n"
19:52:55 <heatsink> because "\n" is not equal to "\\"
19:53:25 <heatsink> so you won't accidentally treat an escaped newline as a nonescaped newline.
19:54:04 <silasm> yeah, but if I have "many something <* eol", I could run into problems if I don't define `something' correctly.
19:54:16 <monochrom> silasm: do you know that writing "\n" in source code does not equal receiving "\n" in input?
19:54:46 <silasm> monochrom: yeah, I know that.
19:55:20 <monochrom> what is a non-escaped newline? what is its sequence of unicode codepoints?
19:55:39 <monochrom> or bytes, if you prefer bytes?
19:55:59 <silasm> monochrom: I mean any newline (real newline) not escaped by a backslash before it. I'm trying to write a makefile parser :S
19:56:14 <monochrom> alright, 0x0d then
19:56:23 <monochrom> err no, 0x0a
19:56:34 <monochrom> > Data.Char.ord '\n'
19:56:36 <lambdabot>  10
19:57:23 <monochrom> unlines splits your string based on 0x0a's
19:58:55 <heatsink> silasm: It looks like a job for a lexical analyzer
19:59:00 <silasm> suppose however I wanted to split my input on all 0x0a's such that the character previous that 0x0a was not '\\'. That's what I'm having difficulty expressing. It's looking back at input which has already been parsed.
19:59:32 <silasm> maybe I could just go over the whole input beforehand and translate all "\\\n"s into some marker character.
20:00:00 <heatsink> silasm: That looks like a job for a lexical analyzer
20:00:20 <silasm> heatsink: I'll look it up, thanks.
20:02:22 <silasm> so I guess this is kind of turning into multiple-pass parsing, which is okay for my purposes.
20:02:37 <monochrom> oh wait, you sometimes see the sequence 92,10 and you want to skip processing it, and sometimes you see 10 without 92 and you want to process it.
20:02:45 <jle`> anyone have problems with curl when installing codex?
20:02:50 <silasm> in fact that should simplify things pretty significantly.
20:02:55 <silasm> monochrom: exactly.
20:03:33 <jle`> > replicateM 8 "01"
20:03:34 <monochrom> I seldom use that feature of makefiles and shell scripts, but it's coming back to haunt me now
20:03:35 <lambdabot>  ["00000000","00000001","00000010","00000011","00000100","00000101","00000110...
20:03:52 <jle`> > replicateM 3 "01"
20:03:54 <lambdabot>  ["000","001","010","011","100","101","110","111"]
20:04:25 <monochrom> multi-pass is a tidy way I can think of now
20:04:44 <silasm> monochrom: my whole job is maintaining makefiles. I've gotten fed up with editing them directly, so I'm writing a parser to do the tedious work for me. Hopefully it'll work.
20:05:05 <silasm> At least it's a good excuse to write some haskell :P
20:05:13 <monochrom> and usually just two passes. the first pass uses merely regexes which can distinguish 92,10 from lone 10 very easily
20:05:18 <platz> so codex basically allows vim/emacs to jump to the source file of a dependancy
20:06:05 <monochrom> my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#token may help with the 2nd pass
20:06:12 <silasm> monochrom: yeah, prior to this I was writing sed scripts so my regex isn't rusty. That got old fast though since refactoring sed is... impossible.
20:06:56 <monochrom> there may be a tidy 1-pass way, actually.
20:08:22 <monochrom> whitespace = char ' ' <|> string "\\\n"
20:08:41 <monochrom> make sure you prioritize that over your newline detector
20:09:08 <monochrom> and I have a type error. you have to insert more code to say "return ()" or something
20:13:23 <orion> When a haskell programmer says, "documentation pass", what does he mean?
20:13:28 <orion> "Before releasing anything, there should really be a documentation pass."
20:13:34 <d10genes> is there a way to query lambdabot with a multiline string?
20:13:56 <d10genes> trying to get pointless version of func w/ where statement
20:14:14 <d10genes> don't know how to keep where statement on same line
20:14:18 <silasm> monochrom: sorry about the dc, lost connection at "there may be a tidy 1-pass way, actually." I think I'll just go with the 2-pass way though, should be simple enough.
20:14:53 <d10genes> nvm, 'let' works
20:16:44 <dfeuer> Will GHC eta-convert (\c n -> refold go m c n) to (refold go m) ?
20:17:51 <silasm> although now that I think about it, eol = EscapedNewline <$ string "\\\n" <|> Newline <$ string "\n" would /kind/ of work for single pass.
20:19:18 <silasm> (forgot the try, s/string "\\\n"/try (string "\\\n")/)
20:20:02 <hiptobecubic> so apparently guile scheme doesn't follow r5rs for numerical constants using different bases.
20:20:19 <hiptobecubic> pretty disappointing
20:20:31 <monochrom> all your base belong to...
20:21:21 <monochrom> time flies like an arrow. you can now call it an old saying.
20:21:25 <hiptobecubic> and chicken scheme's 'csi' repl doesn't support readline -_-
20:23:07 <monochrom> time flies like an arrow. glue binds like a monad.
20:24:06 <jle`> monads are like glue sticks
20:24:19 <silasm> I thought they were like burritos
20:24:21 <jle`> move aside, burrito
20:28:52 <carter> @tell adrienneleigh  anyways, lets chat sometime in a few days (prob next week), i'm hosed the next few days with work  / life things. I'm done some leg work that i hope will make a lot of things better, or I"ll be sad
20:28:52 <lambdabot> Consider it noted.
20:37:48 <hiptobecubic> it's pretty difficult to understand why parsec does what it does
20:40:11 <silasm> hiptobecubic: It's not much weirder than regex, mainly. My main frustrations with it are disappearing as I realize it's not sed :S.
20:40:22 <silasm> It's finally forcing me to wrap my head around applicatives too, which is good.
20:40:27 <hiptobecubic> When does it decide "this failed so I should move on" vs "this failed so I should explode" ?
20:40:30 <silasm> s/mainly/really/
20:41:09 <silasm> yeah that's the weird thing, it seems like "try x <|> y" should be the default vs. "x <|> y"
20:41:19 <svercer> hiptobecubic: whether it's consumed input. this prevents unbounded backtracking: once i've consumed input, I'm definitely not going down any of the old branches
20:41:32 <hiptobecubic> i'm working through write yourself a scheme
20:41:36 <hiptobecubic> and we haven't discussed 'try' yet
20:41:43 <hiptobecubic> but i guess it's needed for this exercise?
20:41:46 <hiptobecubic> seems odd that it would do that
20:41:51 <svercer> (unless there's a try there, but I'm sure that try does something fancy to severely limit the amount of possible backtracking)
20:42:23 <silasm> also if you have "try (x *> y) <|> z" and it parses x but not y, afaik you're basically screwed, which is frustrating.
20:42:35 <silasm> hiptobecubic: sometimes you can just reorder your alternatives to make it work.
20:42:39 <hiptobecubic> I want to parse integers in other bases like "#b01101"
20:42:55 <hiptobecubic> but it should also parse Atoms like "#t"
20:43:10 <hiptobecubic> but once it eats the '#' it apparently refuses to do anything else
20:44:06 <silasm> move your alternative to after the '#' parser if you can, and you shouldn't need try.
20:44:08 <tac> If I want to use sqlite, is sqlite-simple my best option?
20:44:29 <hiptobecubic> silasm, well i have a parser for octal numbers alone
20:44:46 <hiptobecubic> and a parser for decimal numbers, and my parse number currently combines them with <|>
20:44:57 <hiptobecubic> and parseExpr then combines parseNumber with others
20:45:04 <svercer> silasm: your statement about "try (x *> y) <|> z" doesn't seem right...
20:45:43 <hiptobecubic> http://lpaste.net/108398
20:45:53 <glguy_> It would backtrack to z, but maybe that's not what he wanted it to do?
20:45:57 <silasm> svercer: I may have not had the try in the right place for what I was doing, but I tried (no pun intended) putting it almost everywhere and couldn't get it to lookahead properly.
20:46:09 <hiptobecubic> So ideally, if parsing an octal failed it could parse a bool instead
20:46:18 <hiptobecubic> but right now it just dies
20:46:22 <silasm> glguy_: in my case it would parse x, move ahead, fail to parse y.
20:47:16 <svercer> silasm: http://lpaste.net/108399 works
20:53:28 <hiptobecubic> using 'try' fixed it
20:53:40 <hiptobecubic> but i'm wondering if that's legit since it hasn't been introduced yet :)
20:56:22 <silasm> hiptobecubic: you can probably do it without try, e.g. `char '#' *> (char 'b' *> binary <|> string "0x" *> hex <|> atom)'. You just need to not have the '#' as part of the (<|>), since it's shared between them.
20:57:43 <SrPx> Is there something like Ocaml's modules in Haskell?
20:58:15 <hiptobecubic> SrPx, there's research around it but no
20:58:20 <hiptobecubic> SrPx, checkout backpack
20:59:18 <jle`> sometimes i wouldn't mind a built in alias for return ()
20:59:20 <jle`> noop maybe
20:59:25 <dfeuer> SrPx: https://www.google.com/url?q=http://plv.mpi-sws.org/backpack/&sa=U&ei=MW3YU-6oGITgsASCsIGoCQ&ved=0CAsQFjAA&sig2=VRmhcbM-HnwRtwUu_9RHsA&usg=AFQjCNHF9eoN9ei7eC-tWxgGlq3VpMrXxQ
20:59:31 <jle`> void undefined?
20:59:35 <jle`> :t void undefined
20:59:36 <lambdabot> Functor f => f ()
20:59:53 <hiptobecubic> jle`, yuck
21:00:05 <jle`> i wouldn't mind noop
21:00:06 <dfeuer> jle`: why built in? If you want to confuse people, just write the damn thing yourself.
21:00:21 <jle`> built in so it's a common idiom
21:00:23 <vanila> how about making return shorter like η ()
21:00:39 <jle`> i wouldn't mind η = return
21:00:47 <johnw> nothing stopping you from defining that locally
21:00:51 <dfeuer> jle`:  what do you mean by "built in"?
21:00:57 <jle`> dfeuer: in prelude or something
21:01:02 <jle`> so it's a common idiom
21:01:04 <svercer> why do you need "return ()" instead of just passing whatever computation was going to end with that to void instad?
21:01:06 <jle`> that i can use in code w/o confusing people
21:01:07 <svercer> *instead
21:01:11 <dfeuer> Yeah, that's not gonna happen.
21:01:24 <jle`> svercer: for things like `when`
21:01:48 <jle`> or guard
21:02:22 <svercer> hmm... (when test . void)? =D
21:03:20 <jle`> i mean, for writing things like when
21:03:31 <svercer> oh... but that's just one thing?
21:03:46 <jle`> it comes up a lot actually i think
21:03:53 <jle`> functions like when, where you need to use return () explicitly
21:04:38 <svercer> return () is pretty short already... I guess I just don't see the major usefulness of it
21:04:39 <fluffynukeit> hello all.  Is there a haskell library for user authentication that is not tied to web framework?
21:06:26 <Javran> Hi, I'm using gtk2hs, any idea why ghc is complaining "`onClicked` is not in scope" while I've imported Graphics.UI.Gtk ?
21:07:18 <enthropy> you're looking at documentation that's too old
21:08:05 <enthropy> I think the newer way is to write stuff like  "on buttonClicked"
21:09:39 <Javran> I'm reading document of gtk-0.12.5.7, and my haskell gtk version is 0.12.5.7.3 .. but I don't expect the API to change a lot ..
21:09:46 <SrPx> I see, thanks
21:10:36 <enthropy> where's the onClicked there?
21:11:50 <Javran> http://hackage.haskell.org/package/gtk-0.12.5.7/docs/Graphics-UI-Gtk-Buttons-Button.html#v:onClicked should be exported by Graphics.UI.Gtk according to the doc
21:12:04 <SrPx> just one question, how is a typeclass different from a module? As I see, a typeclass is pretty much an interface
21:12:35 <Zekka> :t join bimap (+)
21:12:35 <silasm> SrPx: module in the haskell sense?
21:12:37 <lambdabot> (Bifunctor p, Num a) => p a a -> p (a -> a) (a -> a)
21:13:04 <hamishmack> Javran: There is a cabal flag that enables/disables depricated funcitons like onClicked.  You probably want “on buttonActivated”.
21:13:19 <Zekka> :t join bimap (***)
21:13:21 <lambdabot> (Bifunctor p, Arrow a) => p (a b c) (a b c) -> p (a b' c' -> a (b, b') (c, c')) (a b' c' -> a (b, b') (c, c'))
21:13:27 <Zekka> er, that's not what I meant. I'll query
21:13:29 <yogurt_truck> SrPx: http://okmij.org/ftp/Computation/typeclass.html
21:13:40 <SrPx> silasm: module in ocaml sense vs typeclass in haskell
21:14:38 <yogurt_truck> that is exactly what oleg thoroughly explains in that article
21:14:53 <silasm> SrPx: ah, can't help you there. I've never touched ocaml. A type class is a lot like a java interface though, yeah. One of the main differences is when you can attach it (Java only lets you attach interfaces in the class declaration, which is kind of a stupid limitation imo)
21:15:39 * hackagebot haskmon 0.1.1.0 - A haskell wrapper for PokeAPI.co (www.pokeapi.co)  http://hackage.haskell.org/package/haskmon-0.1.1.0 (pjrt)
21:15:43 <silasm> (attach may be the wrong word to use here, "declare an instance" is more correct).
21:15:51 <yogurt_truck> don't take the similarities with Java interfaces too seriously
21:15:56 <yogurt_truck> (or seriously at all)
21:16:08 <SrPx> silasm: hmm I see
21:16:11 <yogurt_truck> SrPx: http://tonymorris.github.io/blog/posts/type-classes-are-nothing-like-interfaces/
21:16:50 <SrPx> yogurt_truck: wow seems like I'm not the first one with that doubt
21:17:27 <yogurt_truck> between tony's post and oleg's article, I doubt you'll remain with any uncleared doubts!
21:17:43 <Javran> hamishmack: thanks! that does work. looks like the tutorial I'm reading is a little outdated. BTW what's the equivalent to the old `onDestroy`? I can't find it either
21:17:45 <hiptobecubic> what a great library
21:18:27 <tac> yogurt_truck: as a first approximation, "type classes are interfaces" is fine
21:18:57 <hamishmack> Javran: objectDestroy IIRC
21:19:01 <SrPx> yogurt_truck: ah from reading the beginning of that article I guess that is not what I meant, I have no idea what are Java interfaces. I really meant Ocaml modules. Let me finish reading the other link
21:21:01 <NemesisD> anyone use haskell-mode in vim? i'm getting an error that the program ghc is required but it could not be found. i have no idea what its on about, ghc is obviouly installed and is findable via executable-find
21:21:04 <hiptobecubic> SrPx, i believe in the Backpack paper, they explicitly mention ML's modules as an inspiration
21:21:30 <hiptobecubic> NemesisD, yes and that doesn't make sense
21:21:37 <hiptobecubic> also what is 'executable-find'
21:21:50 <hiptobecubic> is that some osx thing?
21:22:07 <hiptobecubic> what does `command -V ghc` say?
21:22:15 <NemesisD> argh im scatter brained tonight. i meant emacs not vim
21:22:30 <NemesisD> executable-find being the function in emacs
21:22:33 * Rarrikins hisses at the infidel.
21:22:58 <NemesisD> "ghc is /opt/ghc/7.8.2/bin/ghc"
21:24:20 <silasm> yogurt_truck: I hate defending java, but I feel like that article is deliberately ignoring Compara/ble/. How are interfaces like Comparable (not Comparator, which is different) unlike typeclasses?
21:24:51 <Javran> hamishmack: that works! thank you!
21:28:00 <kazagistar> silasm: that example was a bad one. typeclasses do a lot more then interfaces, and more flexibly, but when a typeclass is defined uniquely, only depends on one type, and can be in the same file as the data definition, then an interface can fill the same role
21:28:01 <silasm> in terms of what they enable, because the difference in how they're declared and such is obvious. But e.g. Ord and Comparable offer pretty similar benefits as far as e.g. writing a generic sorting function.
21:28:21 <NemesisD> maybe the issue is that cabal can't find the program ghc. uhh
21:28:38 <silasm> ah, yeah, depending on multiple types is a good point.
21:29:22 <hiptobecubic> is there a lookahead in parsec?
21:29:22 <yogurt_truck> silasm: the article explains that clearly
21:29:42 <hiptobecubic> I need to require whitespace if there will be something else afterwards, otherwise not
21:30:01 <hiptobecubic> trying to parse this http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.3.4
21:32:32 <kazagistar> hiptobecubic: "try" does backtracking
21:32:46 <hiptobecubic> kazagistar, yes. I'm using try
21:32:50 <jle`> is there a better way to write (return . g) <=< f
21:33:16 <vanila> :t \f g -> (return . g) <=< f
21:33:17 <lambdabot> Monad m => (a -> m b) -> (b -> c) -> a -> m c
21:34:13 <svercer> :t \f g -> flip fmap g (f:: a -> m b)
21:34:15 <lambdabot>     Couldn't match expected type ‘a1 -> m1 b1’ with actual type ‘t’
21:34:15 <lambdabot>       because type variables ‘a1’, ‘m1’, ‘b1’ would escape their scope
21:34:15 <lambdabot>     These (rigid, skolem) type variables are bound by
21:34:16 <dwcook> jle`, looks okay to me, although an alternative would be to (return .) the non-Kleisli-arrows when necessary.
21:34:16 <hiptobecubic> so if I want to accept everything that isn't whitespace...
21:34:19 <svercer> oops, don't mind me
21:34:30 <hiptobecubic> satisfy (not . isSpace) ?
21:34:31 <jle`> dwcook: how do you figure?
21:34:34 <vanila> :t \f g -> liftM g . f
21:34:36 <lambdabot> Monad m => (a -> m a1) -> (a1 -> r) -> a -> m r
21:34:37 <silasm> yogurt_truck: I hadn't finished reading it, yeah, but I'd hardly call that "clearly". The point is I don't think he gave a very good example of showing something that's not expressible using interfaces, because Comparable is pretty much a straight counterexample to half of what he says. He implies that all java typeclasses need to be passed explicitly when that's not the case.
21:35:15 <dwcook> jle`, well say your composition pipeline looks like f, a Kleisli arrow, g, a non-arrow, and h, another arrow. Then you might write: h <=< return . g <=< f
21:35:23 <jle`> ah yeah.
21:35:50 <dwcook> Or, I forget the relative precedence of (.) and (<=<) but you probably get my meaning
21:35:50 <johnw> or h <=< fmap g . f
21:36:10 <silasm> that's why I try to emphasize decoupling personally, since it allows you to make an instance after-the-fact instead of having to extend the class to implement an interface (god forbid the class is final, in which case you need a wrapper).
21:36:23 <c_wraith> dwcook: . is 9, so that should be right
21:36:24 <silasm> I feel like that's a tangible benefit that's easier to understand.
21:36:47 <silasm> assuming the person is coming from java, which is pretty much the only time they understand the analogy in the first place.
21:37:47 <yogurt_truck> silasm: emphasizing decoupling is also what the article does
21:38:12 <yogurt_truck> "Also, the type-class instance is decoupled from the data type. These are essential properties of type-classes. Indeed, it is its single-most defining property and since Java/C# have nothing like this, then it has nothing like type-classes."
21:38:53 <yogurt_truck> if you'd "hardly call that 'clearly'", then, whatever. Approach it as you will.
21:39:46 <yogurt_truck> I know *I* was misled by the "they are like interfaces" analogies by someone, when I first tried to learn them, coming from c++/java/etc
21:40:00 <yogurt_truck> but then again I'm almost always misled by analogies.
21:40:44 * yogurt_truck is a slowly recovering victim of "just like interfaces", "just like burritos", etc.
21:41:29 <tac> really, typeclasses are more like proof-relevant properties of types
21:41:31 <btubbs_> in the haskell/rabbitmq guide at http://videlalvaro.github.io/2010/09/haskell-and-rabbitmq.html, there's a "getLine" in main with the comment "wait for keypress".  I can't think why that would be necessary though, as the value isn't captured.  Do you have to do that to make Ctrl-C behave correctly, or something?
21:41:32 <johnw> next comes "everything's a function"
21:42:16 <benzrf> btubbs: its waiting for you to manuallystart it
21:42:23 <benzrf> *manually start
21:42:40 <btubbs> interesting.  OK
21:44:22 <vanila> tac: what does that mean?
21:45:17 <tac> vanila: a typeclass is a predicate. Like "is even" for integers. You can say "2 is even".
21:45:28 <tac> vanila: something like "Monoid" in Haskell means "is a monoid"
21:45:46 <tac> having declared a Monoid instance for Int means "Int is a monoid"
21:45:58 <codygman> It just occurred to me that I could use replicateM and >>= with functions. This is fun: replicateM 2 (>>= replicate 3) ["bunny"]
21:46:02 <tac> multi-parameter typeclasses are just multi-parameter predicates
21:46:16 <vanila> > replicateM 2 (>>= replicate 3) ["bunny"]
21:46:18 <lambdabot>  [["bunny","bunny","bunny"],["bunny","bunny","bunny"]]
21:48:09 <tac> vanila: it makes sense if you know dependent types ^^;;
21:48:17 <vanila> what's "proof relevant"?
21:48:52 <tac> it means that it's not just enough to know that Int is a Monoid
21:48:56 <tac> you also need to know HOW it's a monoid
21:49:28 <tac> there are in fact many ways to make Int a Monoid. Which proof (instance) you choose matters.
21:49:37 <vanila> oh okay
21:50:45 <tac> In Idris, for instance, typeclasses are nothing more than functions Type -> Type
21:51:58 <tac> so Monoid Int is a Type (the record type with all the methods). And an instance is just a particular object of that record type.
21:51:59 <vanila> How does that work?
21:52:23 <tac> I'm not sure on the details.
21:52:30 <tac> I don't actually _code_ a lot of Idris
21:52:36 <vanila> does the compiler insert the dictionaries for you after type inference
21:52:48 <tac> most likely, that's how it works
21:53:01 <tac> you could ask in #idris and get a more technical answer
22:04:52 <trap_exit> are there any successful startups
22:04:55 <trap_exit> that use mostly haskell ?
22:05:07 <johnw> fpcomplete.com does, skedgeme.com does
22:05:13 <johnw> alephcloud.com
22:05:27 <trap_exit> fpcomplete.com goes to godaddy
22:05:41 <johnw> what?
22:05:49 <augur> trap_exit: well, im trying to start one :X
22:05:50 <johnw> not for me
22:06:01 <trap_exit> johnw: hmm, I typoed
22:06:25 <orion> hmm
22:06:35 <trap_exit> augur: tell me more
22:07:27 <augur> trap_exit: im working on some natural language UI stuff in haskell
22:07:43 <trap_exit> augur: NLP ?
22:07:47 <trap_exit> augur: are you using recurring neural networks?
22:08:12 <augur> no no
22:08:16 <augur> not NLP really
22:08:20 <augur> computational linguistics
22:08:42 <orion> What's the quickest and most elegant way to generate a 512 bytestring in a pure way?
22:08:51 <orion> I don't care what's in it.
22:09:19 <trap_exit> take 512 $ repeat 0
22:09:25 <orion> thank you
22:09:25 <trap_exit> show $ take 512 $ repeat 0
22:09:41 <trap_exit> orion: you're welcome :-)
22:10:03 <trap_exit> orion, we can actually optimize this
22:10:26 <trap_exit> "[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
22:11:42 <luite> orion: replicate 500
22:11:50 <luite> err 512
22:13:46 <orion> thanks
22:13:46 <trap_exit> > replicate 512
22:13:48 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
22:13:48 <lambdabot>    arising from a use of ‘M893109295309296316423977.show_M8931092953092963164...
22:13:48 <lambdabot>  The type variable ‘a0’ is ambiguous
22:13:48 <lambdabot>  Note: there are several potential instances:
22:13:48 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
22:14:15 <orion> I am writing tests. Is there any way to prevent `cabal test' from recompiling my cbits every single time it runs?
22:16:14 <benzrf> g2g
22:16:18 <benzrf> bye
22:18:03 <trap_exit> is there a library for doing erlang style mailboxes in haskell?
22:18:17 <trap_exit> is there a library, based upon concurrent haskell, for erlang style mailboxes in haskell?
22:18:33 <trap_exit> i'd like to be able to (1) p[ut messsages in a mailbox, and (2) selective receive + remove messages that match a certain pattern
22:19:24 <jfischoff> trap_exit: there are concurrent queues for same machine concurrency and distribute process for well distributed multimachine programming
22:19:58 <jfischoff> so yes Haskell can do that, although I don’t really know what a erlang mailbox is :p
22:20:19 <trap_exit> http://hackage.haskell.org/package/lockfree-queue-0.2/docs/Data-Concurrent-Queue-MichaelScott.html ?
22:20:44 <trap_exit> jfischoff: it's like a regular mailbox, but it's made of gold and instead of being mounted on a stake, it's mounted on concurent unicorn horns
22:21:11 <jfischoff> trap_exit: okay cool that’s what I was thinking
22:21:23 <jfischoff> @hoogle TBQueue
22:21:23 <lambdabot> Control.Concurrent.STM.TBQueue module Control.Concurrent.STM.TBQueue
22:21:23 <lambdabot> Control.Concurrent.STM.TBQueue data TBQueue a
22:21:23 <lambdabot> Control.Concurrent.STM.TBQueue isEmptyTBQueue :: TBQueue a -> STM Bool
22:21:42 <tnks> jfischoff: I'd thought of Haskell has having good single-machine concurrency, but hwat libraries should I look at for distributed programming?
22:21:42 <jfischoff> something like that ^. That is a bounded queue
22:21:53 <trap_exit> I don't think I wnat to use STM
22:21:56 <trap_exit> lock free queue sounds better
22:22:11 <jfischoff> tnks: distributed-process and its relatives I think (never used them)
22:22:12 <trap_exit> tnks: there's a good book: concurrent + parallel haskell by simon
22:22:25 <jfischoff> trap_exit: what is wrong with STM?
22:22:33 <trap_exit> STM might rollback
22:22:33 <tnks> trap_exit: I've only cracked the front matter of that book, but yeah. . . soon.
22:22:38 <trap_exit> and retry things
22:22:46 <trap_exit> tnks: I found the concurrent part more easier to understand then the parallel part
22:22:48 <jfischoff> trap_exit: and?
22:22:56 <orclev> that's a feature
22:23:06 <trap_exit> jfischoff: and it makes performance hard to understand, and it might redo lots of works, and retry lots of times
22:23:14 <jfischoff> no no no
22:23:33 <trap_exit> is it STM w/ guaranteed progress?
22:23:40 <jfischoff> both the lockfree and STM require retrying
22:23:53 <jfischoff> STM is able to only retry when something changes
22:24:11 <tnks> STM doesn't solve algorithm design.
22:24:32 <jfischoff> The waitfree queues that guarentee progress are not practical as far as I know …
22:25:03 <jfischoff> the STM queues are pretty fast
22:25:33 <jfischoff> and you can make complex logic around them that is very difficult with the lock free stuff
22:25:35 <orclev> I've had good luck with STM in the past
22:26:13 <jfischoff> I think the right approach is to start with STM and profile.
22:26:13 <trap_exit> I'm using Haskell for safety + guarntees
22:26:16 <trap_exit> I don't like the word luck
22:26:24 <orclev> on a related note, anyone know if GHC is going to be taking advantage of the HTM support in the Haswell and newer Intel CPUs?
22:26:34 <trap_exit> jfischoff: alright, which package are you suggesting I look into?
22:26:47 <jfischoff> stm
22:26:50 <jfischoff> start there
22:26:57 <trap_exit> http://hackage.haskell.org/package/stm-2.4.2/docs/Control-Concurrent-STM-TBQueue.html ?
22:26:59 <orclev> ok, so I've had good results with STM in the past, that better?
22:27:01 <jfischoff> yeah
22:27:26 <jfischoff> brb
22:27:55 <trap_exit> jfischoff: Your persistent has convinced me to study stm
22:28:05 <trap_exit> jfischoff: what should I read up to understand the theory behind haskell stm ?
22:28:29 <Enigmagic> orclev: at least one person i've talked to is working on using HTM for GHC's STM.
22:29:13 <orclev> trap_exit: from the stm module, there's this link: http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/index.htm
22:29:17 <jfischoff> trap_exit: good question. Interestly enough I learned much about the STM from the “one person” Enigmagic mentioned
22:29:32 <Enigmagic> orclev: however the HTM implementation is very restricted compared to the STM, so HTM support will have to fall back to a non-HTM solution in many cases
22:29:43 <orclev> hmm, interesting
22:30:04 <Enigmagic> hardware is complicated :^)
22:30:16 <orclev> kind of disapointing, I was hopeing HTM would be a nice performance boost for implementing STM
22:30:23 <jfischoff> trap_exit: I don’t have a perfect understanding myself. I think the story is something like this
22:30:45 <trap_exit> concurrency is hard, stm is easy, le't suse stm
22:30:47 * hackagebot simple-stacked-vm 0.1.1 - Simple stacked virtual machine: assembler, disassembler, bytecode interpreter  http://hackage.haskell.org/package/simple-stacked-vm-0.1.1 (IlyaPortnov)
22:30:50 <flebron> Hi. Is there a way to warn the user that she should not compile my program without -threaded?
22:31:54 <Enigmagic> jfischoff: i think waitfree queues with guaranteed progress (using interlocks) were possible on x86 but not on x86_64 :\
22:31:58 <orion> How can I get cabal to generate a dependency tree?
22:32:32 <jfischoff> when you make a STM transaction it creates log of reads and writes to TVars. If during the time of creating the log one of the “reads” is written two by another thread, the transaction is not commited and is retried.
22:33:31 <jfischoff> so one take away is to make your transactions short, the longer they are the more possible contention
22:33:46 <Enigmagic> jfischoff: also.. i don't think the current stm impl differentiates between reads and writes, so a concurrent read within an atomically block can cause a retry. laziness helps reduce the number of retries.
22:34:16 <Enigmagic> the main thing to consider is transaction length in terms of forced values, not in terms of scope
22:34:55 <Enigmagic> it's perfectly fine (and fast) to build up thunks within a transaction
22:36:05 <Enigmagic> and why haskell's STM doesn't need to retry as often as other (strict language) STMs..
22:45:50 * hackagebot hs-java 0.3.4 - Java .class files assembler/disassembler  http://hackage.haskell.org/package/hs-java-0.3.4 (IlyaPortnov)
22:54:13 <trap_exit>  anyone feel that haskell makes them think clearer?
22:54:25 <trap_exit> it's as if all my days before haskell, I was walking around in a fog
22:54:38 <trap_exit> then I come across haskell, and, whoosh, the fog lifts
22:56:44 <Dacto> exit
22:56:49 <Dacto> wc..
22:59:17 <dv-> up the stairs, third door to the left
23:00:12 <me> hello?
23:00:33 <me> did you people have dolfing advice for haskell?
23:01:45 <Guest39534> does anybody has golfing advise?
23:05:46 <silasm> Guest39534: what are you trying to golf, and why?
23:06:20 <Guest39534> nothing in particular, just as a potential hobby
23:07:06 <silasm> haskell's pretty good for hobbyist golfing. APL might be better for that though, depending on how insane you're feeling :P
23:07:26 <Guest39534> i have posted a few things on stack exchange programming puzzles and code golf
23:07:40 <Guest39534> but i want to golf in haskell specifically
23:07:51 <Guest39534> i just like haskell too much
23:09:22 <Guest39534> also, golfing in a language like APL feels like cheeting
23:12:39 <bb010g> Guest39534: But you have to write in APL, so it compensates.
23:12:51 <Guest39534> lol
23:16:15 <Guest39534> how come so many people are quitting and joining but no one talks???
23:16:53 <gfixler> Guest39534: no worries, they talk *a lot* in here
23:18:21 <gfixler> join #haskell-blah
23:18:27 <gfixler> and #haskell-overload
23:18:34 <gfixler> sorry, #haskell-overflow
23:21:05 <jle`> i wouldn't mind a haskell-overload ;)
23:21:38 <gfixler> jle`: I bet :)
23:21:55 <gfixler> jle`: how long have you been using Haskell? You're pretty active in here.
23:22:26 <jle`> not that long, i am just addicted to irc :/
23:22:28 <jle`> it's pretty bad actually
23:22:32 <jle`> i have been considering quitting
23:22:40 <gfixler> oh my
23:22:51 <sivteck> jle`: don't!
23:22:54 <jle`> yeah i lose like hours at a time >___>
23:23:25 <gfixler> jle`: just get irssi going on Google Glass
23:23:27 <jle`> i think i have been literally the #1 particpant by words and by messages for like half a year now, after lambdabot
23:23:30 <gfixler> then you can at least wander around
23:24:30 <jle`> i don't have problems wandering around, it's when i'm at my computer doing work v.v
23:24:46 <gfixler> jle`: you just need to figure out how to monetize your bad habit
23:25:10 <jle`> hm that sounds promising
23:25:19 <gfixler> Guiness Book of World Records: Longest Sustained Discussion on Freenode
23:25:27 <gfixler> you could have sponsors, and a book deal
23:26:21 <gfixler> I'm a bit into the LYAH chapter on IO, and I'm not yet feeling the magic
23:26:31 <gfixler> I don't know what I was expecting, but I don't think it was this
23:26:37 <jle`> i feel like i can do more productive things with my time then make money
23:26:50 <jle`> gfixler: aw
23:27:03 <gfixler> jle`: I only just started, though - I'm holding out hope
23:27:19 <jle`> gfixler: i don't remember how i felt reading lyah, but the magic of haskell only grows over time
23:27:30 <gfixler> well that's exciting
23:27:58 <gfixler> I'm getting older; I don't like flash-in-the-pan as much as slowly growing depth and power
23:28:15 <pjdelport> gfixler: Have you felt the magic of Functors and Applicative yet?
23:28:35 <jle`> i really think haskell's greatest advantages are best felt after using it for real projects
23:28:39 <gfixler> pjdelport: functors seem a nice, useful abstraction, but not yet magic
23:28:41 <jle`> a lot of people get fixated on the functional style of haskell
23:28:47 <gfixler> applicatives I have not yet experienced
23:28:48 <jle`> like from lisp or ruby etc.
23:28:55 <silasm> Guest39534: this is more obfuscation than anything, and I had it better before, but here's a classic
23:28:59 <jle`> useful for code golfing and stuff
23:29:10 <silasm> > (++ "Batman!") $ replicate 16 (1/0 - 1/0) >>= take 2 <$> show
23:29:12 <lambdabot>  "NaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaBatman!"
23:29:17 <gfixler> haha
23:29:25 <jle`> but i think the emphasis on functional style is really a misdirection
23:29:37 <pjdelport> gfixler: Applicative is what lets you turn (++) "foo" "bar" into (++) <$> getLine <*> getLine
23:29:53 <jle`> i mean yeah, mergesort in two lines? that's ok i guess.  cute, but it wouldn't change my life
23:30:01 <aarvar> how do you even define "functional style"
23:30:12 <gfixler> aarvar: point-free?
23:30:17 <jle`> reliance on higher-order functions, and immutability
23:30:26 <jle`> first-class functions, functions as data
23:30:37 <jle`> emphasis on immutable data structures and non-mutating algorithms
23:30:55 <aarvar> how is emphasis on that a  misdirection
23:30:55 * hackagebot egison 3.3.10 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.10 (SatoshiEgi)
23:31:08 <jle`> because that's not the true value of haskell
23:31:15 <gfixler> jle`: one of the things I'm contending with is coming from playing a bit in Common Lisp and Clojure
23:31:20 <jle`> any ol functional language has all of that
23:31:32 <jle`> even ruby, python have that, if you go in the right circles
23:31:34 <jle`> javascript, even
23:31:35 <gfixler> I really enjoyed the dead-simple syntax, where everything is the same thing, and code literally as data
23:31:44 * solidus-river is interested in seeing what jle` claims the true power of haskell is
23:31:49 <gfixler> and no order-of-operations
23:32:08 <gfixler> I believe Haskell is amazing, because enough clearly brilliant people have said so, enthusiastically
23:32:18 <aarvar> what
23:32:31 <gfixler> but it did feel right away a bit less clean than Clojure, because of all the different syntax
23:32:36 * solidus-river just pulled a 14 hour day fixing up a horrible javascript codebase
23:32:39 <jle`> heh.  the true power of haskell because of its expressive type system providing safety, maintainability, equational reasoning, new abstractions otherwise impossible...
23:32:49 <jle`> *real* maintainability, and *real* code reuse, and *real* scalability
23:32:50 * solidus-river will not acknowledge javascripts existence anymore
23:32:57 <gfixler> `infix`, fixity stuff, having to think about when to group, associativity orderings
23:33:06 <jle`> none of that really come directly from the functional style
23:33:10 <jle`> *none of those
23:33:15 <coppro> jle`: and *real* dependency hell
23:33:15 <gfixler> I had this underlying feeling of "We've solved this" over in the lisps
23:33:19 <jungnam> 호옹이
23:33:41 <jle`> coppro: we're talking about advantages ;)
23:33:47 <ddellacosta> I've been doing Clojure for 2+ years now, and while it has all the non-type-system related stuff jle` listed above, right away it's obvious to me the type system brings something to the table that is completely different and brings new abstractions into it.
23:33:56 <ddellacosta> new power
23:34:00 <jle`> although i don't think that cabal hell is a necessary tradeoff of an expressive type system
23:34:15 <aarvar> how is cabal related to the type system
23:34:20 <MP2E> you don't need to tolerate cabal hell today, you can use nix
23:34:23 <MP2E> :P
23:34:28 <jle`> aarvar: coppro brought it up
23:34:32 <jle`> but i do agree
23:34:33 <jle`> with you
23:34:40 <aarvar> oh didnt see that
23:34:41 <gfixler> ddellacosta: agreed
23:34:55 <glguy_> It's unfair that cabal gets blamed when people have libraries that aren't compatible
23:35:19 <coppro> I didn't say it was cabal's fault
23:35:44 <glguy_> It's just the phrase that bothers me in general. Not picking on anyone in particular
23:35:53 <jle`> anyways yeah, given this, i do think that the emphasis on "functional style" (as defined above) is sort of a misdirection.  i don't think clever syntax and short code snippets realaly do anything to demonstrate haskell's real power
23:35:55 <gfixler> MP2E: I'm super interested in nix and nixOS, but, baby steps
23:39:22 <aarvar> haskell's type system is related to the short code snippets though isnt it
23:40:54 <ddellacosta> aarvar: you can do pretty similar stuff in a lot of lisps (for example)
23:42:00 <aarvar> Can't haskell's type system potentially make code shorter than in other languages though because of typeclasses?
23:44:27 <jle`> i mean, something like (Ord a =>) saves a *lot* of lines of null checks and implements checks compared to a dynamic language.  but usually when people show them, the emphasis isn't on the type system
23:44:41 <jle`> you'll have to show me a specific example, i'm not quite imaginative enough :)  sorry
23:45:04 <aarvar> I don't know, I was more thinking of things such as Monoid
23:45:24 <aarvar> in another language you'd have to explicitly pass the monoid instance around
23:46:15 <aarvar> same with any typeclass that cant be reproduced in an OO style
23:46:23 <silasm> I don't know if monoid is a good example given how often newtypes are involved :P
23:46:40 <aarvar> ok, then how about Read
23:46:45 <jle`> actually i've seen a good usage of monoid for code reuse and accessible abstractions
23:46:51 <jle`> ther'es that neat foobar implementation using monoids
23:47:20 <kazagistar> read saves a a word, but "how terse your make your code" is not really the best metric, it is at best a proxy for complexity
23:47:29 <jle`> yeah, it's not meant for code terseness
23:48:08 <aarvar> My point was that the types can actually make code shorter; code length and types aren't completely unrelated
23:48:10 <jle`> typeclasses do offer a lot though, and it's not hard to think of a demonstration to show a subset of the usefulness of typeclasses
23:48:35 <jle`> those sorts of demonstrations i am all for
23:49:07 <aarvar> I think the problem is that a demonstration of the type system is less accessible to most people
23:50:45 <jle`> i think it's in general harder to show in a cute code snippet, yeah; some exceptions come to mind though, so i think we should keep on trying :)  instead of deferring to just cute codegolfy stuff
23:51:24 <jle`> like this
23:51:26 <jle`> http://new-www.haskell.org/
23:51:47 <jle`> would be what i would consider a bad example
23:52:07 <jle`> i think earlier, they had a one-liner prime seive
23:52:09 <jle`> sieve
23:52:11 <aarvar> you can do that in most languages anyway after all
23:52:21 <jle`> yeah :/
23:52:28 <aarvar> and its not even the best way to define it
23:52:36 <jle`> it's actually an awful way to define it heh.
23:52:41 <aarvar> exactly
23:52:57 <aarvar> then you show them what you have to do to make it performant, and they ask what the point of recursion is in the first place
23:53:14 <jle`> i mean...there are a decent amount of people who come from a heavily imperative language without first class functions and who never use recursion, and that might 'blow their minds'
23:53:22 <jle`> but it's sort of an empty sort of tactic
23:53:27 <aarvar> like Java
23:53:41 <aarvar> oh wait, not anymore
23:54:27 <jle`> and it tells them that this is what haskell has to offer
23:54:42 <jle`> but :/
23:55:14 <Adeon> at least it's not the list quicksort
23:56:16 <gfixler> jle`: maybe it's just really hard for the *really* cool, life-changing stuff to ever be very evident
23:56:30 <aarvar> maybe something using foldMap would be a good example
23:56:42 <gfixler> like eating right and getting proper sleep - you have to do it for awhile and watch yourself slowly improve
23:56:43 <jle`> yeah, using foldMap on different structures
23:56:49 <jle`> different Monoid instances
23:57:02 <aarvar> foldMap shows off short code, function values, and types
23:57:04 <jle`> although it sorta feels interfacey
23:57:31 <jle`> gfixler: maybe.  but i think it might be more productive to believe that it isn't :)
23:57:43 <gfixler> jle`: probably, but that's what I'm doing right now
23:57:44 <aarvar> well, you cant write a polymorphic foldmap in an OO language
23:57:54 <gfixler> I'm trusting smart people
23:57:55 <aarvar> without passing an extra argument at least
23:58:30 <gfixler> I've made small inroads into the power and changed world-view, but nothing life-altering yet
23:58:48 <jle`> hm.  yeah.
23:58:58 <jle`> it's not possible, but it might give a similar feel
23:59:09 <jle`> you'd have to tell someone 'think about how you'd do this with interfaces and then you'll go nuts'
23:59:23 <aarvar> maybe thats a good idea
23:59:31 <aarvar> give someone a programming problem they cant solve without haskell
23:59:55 <aarvar> na
