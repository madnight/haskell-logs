00:00:17 <suOya_> > error
00:00:18 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
00:00:18 <lambdabot>    arising from a use of ‘M327491671797533633618399.show_M3274916717975336336...
00:00:18 <lambdabot>  The type variable ‘a0’ is ambiguous
00:00:18 <lambdabot>  Note: there are several potential instances:
00:00:18 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
00:00:18 <Cale> dwcook: It's not quite as bad
00:00:40 <codygman> @undo domainFormElems <- findElems $ ByTag "p"; domainFormTxt <- mapM getText domainFormElems
00:00:40 <lambdabot> <unknown>.hs: 1: 17:Parse error: <-
00:00:51 <codygman> @undo do {domainFormElems <- findElems $ ByTag "p"; domainFormTxt <- mapM getText domainFormElems }
00:00:51 <lambdabot> <unknown>.hs: 1: 94:Parse error: Last statement in a do-block must be an expression
00:00:59 <Cale> dwcook: It's just, if you're explicitly using, say, ReaderT over IO, all that does for you is save you from explicitly passing around a function parameter. But in exchange, you have to apply lift to all your IO actions.
00:01:11 <Cale> dwcook: So, you typically don't actually save much.
00:01:32 <codygman> @undo do {domainFormElems <- findElems $ ByTag "p"; domainFormTxt <- mapM getText domainFormElems; print 1 }
00:01:32 <lambdabot> findElems $ ByTag "p" >>= \ domainFormElems -> mapM getText domainFormElems >>= \ domainFormTxt -> print 1
00:01:50 <Cale> dwcook: Unless you're prepared to build up a proper abstraction around it to the point where you rarely if ever need to use lift explicitly, I don't think monad transformers actually do much good.
00:01:59 <dwcook> Cale, I think that sort of thing tends to be more useful when only part of your composition pipeline depends on the parameter and you don't want to make the rest rely on it
00:02:30 <jle`> i like using transformers when i want to selectively interleave/allow different effects in different parts of my program
00:02:32 <Cale> dwcook: Well, you can always have functions which do or don't accept a given parameter
00:02:32 <dwcook> Cale, though in the specific case of ReaderT I can definitely see other ways to avoid it
00:02:50 <jle`> that is, i like using transformers with monad morphisms on the underlying monad
00:02:57 <dwcook> I think jle` is basically saying what I want to say
00:02:58 <Cale> StateT is a little more interesting, but I would almost never use StateT with IO
00:03:03 <Cale> StateT with [] is interesting
00:03:18 <Cale> ContT over IO is sometimes useful
00:04:02 <Cale> The thing is, if you're transforming IO, well, IO already has so many facilities in it that adding more is usually sort of redundant.
00:04:20 <dwcook> In a program I'm currently writing, I have two Proxy … IO () and a ListT (StateT IO) Foo that I want to compose. I need to add features to every part of the pipeline and I think the tools for working with transformers make that nice.
00:04:50 <Cale> The ListT in mtl is somewhat evil :)
00:04:57 <dwcook> Not that one, the pipes one.
00:05:03 <Cale> ah
00:05:07 <dwcook> Also Proxy from pipes.
00:05:26 <dwcook> (More specifically a Producer and a Consumer.)
00:07:22 <lfairy> :o ContT r IO is the bee's knees
00:07:48 <dwcook> Though, notably, I can extricate IO from that pipeline easily and substitute any monad of my chosing.
00:07:51 <dwcook> choosing*
00:09:08 * hackagebot thyme 0.3.5.2 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.5.2 (LiyangHu)
00:09:08 * hackagebot cublas 0.2.0.1 - FFI bindings to the CUDA CUBLAS and CUSPARSE libraries  http://hackage.haskell.org/package/cublas-0.2.0.1 (bmsherman)
00:19:20 <systemfault> I’m trying to understand Functor on (->) e , someone can help me?
00:20:00 <johnw> go ahead and ask
00:20:47 <systemfault> johnw: What would be an example of fmap on (->) e ?
00:21:02 <johnw> think of it like applying your function to the result of the function
00:21:12 <johnw> writing fmap for (->) e yourself is instructive
00:21:19 <suOya_> fmap = (.)
00:21:23 <mzero> > let q = fmap show (*3) in q 10
00:21:55 <johnw> fmap f g = \x -> f (g x)
00:21:58 <johnw> that might be a little clearer
00:25:26 <frerich> systemfault: You can also think about it on the type level. The type of fmap is '(a -> b) -> f a -> f b'. In your case, 'f' is '(->) e', substituting that you get '(a -> b) -> ((->) e) a -> ((->) e) b'. If you write (->) infix you get (a -> b) -> (e -> a) -> (e -> b) which starts to look useful already I think. It looks like function composition (the first argment is applied to the result of the second).
00:25:50 <pjdelport> (f `fmap` g) x = f (g x)
00:25:55 <systemfault> Ah… I had it, I wasn’t reading the error properly.. Was doing fmap (*3) (\x -> x + 1) and it wasn’t working because it couldn’t deduce the type of x
00:26:01 <codygman> Is there a function that retries a monad over and over given certain execptions? tryJust maybe?
00:26:14 <suOya_> so fmap = (.)
00:26:18 <systemfault> right
00:27:33 <pjdelport> systemfault: It may help to mentally read "(->) e" as "(e ->)" too
00:28:54 <knapper_tech> I need an example mapping from a bunch of function composition (non-monadic) and the monadic counterpart.
00:28:59 <jle`> codygman: it might be in monad-loops
00:29:04 <knapper_tech> So that I can map from a to b
00:29:12 <jle`> knapper_tech: hm, what do you mean?
00:29:29 <jle`> ($) :: (a -> b) -> a -> b
00:29:30 <knapper_tech> jle`: I'm reading up on monad transformers.
00:29:43 <jle`> (=<<) :: (a -> m b) -> m a -> m b
00:29:44 <Zekka> knapper_tech: What, like a chart that starts with the types for (.) and (<=<) and asks you to compare them?
00:29:52 <jle`> so those go together/correspond
00:29:56 <Zekka> :t (.)
00:29:57 <lambdabot> (b -> c) -> (a -> b) -> a -> c
00:29:59 <Zekka> :t (<=<)
00:29:59 <codygman> jle`: Thanks. Do you think that is an acceptable way to busywait for an sqlite database to become ublocked?
00:29:59 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
00:30:11 <jle`> codygman: ah.  no
00:30:15 <jle`> codygman: perhaps
00:30:23 <jle`> codygman: look through and see if that's what you want :)
00:30:35 <codygman> jle`: I have a feeling I'll figure out why not :D
00:31:00 <jle`> systemfault: one way to think of Functor is that f a is a "producer" of a, somehow.  IO a generates an a when executed; Reader r a generates an a when given an r
00:31:25 <jle`> systemfault: fmap is where you give an (a -> b), and a "producer of a"'s, and it returns a "producer of b's"
00:31:30 <jle`> codygman: i might be wrong, it might work :)
00:31:35 * frerich thinks the definition of fmap for (->) r is a nice case where it's actually prettier to write 'fmap f g = \x -> ...' instead of 'fmap f g x' to emphasize that you yield a new function.
00:31:38 <johnw> but Maybe a does not always generate an a, so that analogy isn't quite right (no analogy is)
00:31:46 <systemfault> jle`: It just wasn’t as obvious to me for -> (Now it is)
00:31:51 <jle`> johnw: Maybe a generates an a when forced with fromMaybe d
00:31:55 <jle`> :)
00:32:11 <systemfault> Thank you :)
00:32:27 <KorriX> Hello! Why Float and Double are not instances of Prelude.Bounded?
00:32:29 <jle`> systemfault: so you take an (a -> b) and a function producing an a, and turn it into a function producing a b
00:33:25 <knapper_tech> I could use an example that shows global state being used in some threads.
00:33:39 <knapper_tech> I read this is a classic MonadT use case.
00:34:06 <johnw> jle`: that's a bit like saying that "const a ()" generates an a from ()
00:34:20 <pjdelport> KorriX: NaN
00:35:45 <knapper_tech> Actually, global state is exactly the use case I'm after.  Both DB and Heist initialization need to be done and available in all threads.
00:36:32 <knapper_tech> How I define a monadt function thing and the resulting data structures become available in all my warp routes is somewhat of a mystery
00:37:35 <jle`> knapper_tech: if the data structure is in scope in your do block, it'll be there
00:37:54 <jle`> as in if you do x <- getData, then in the rest of the do block, x will be available
00:38:05 <knapper_tech> jle`: what about nested do blocks?
00:38:36 <jle`> knapper_tech: nested do blocks work the same way
00:38:43 <knapper_tech> jle`:   when I look at scotty routs, all examples use inner do blocks to declare what the routes do.
00:38:58 <knapper_tech> jle`: is outer scope of a do block available inside the nested block?
00:39:02 <jle`> knapper_tech: yes
00:40:11 <knapper_tech> jle`:  why would HeistInit return a bunch of complicated types if in the end it's just an input to renderTemplate etc?
00:40:17 <KorriX> pjdelport: I don't understand your answer. There are functions floatRadix and floatRange allowing to approximately calculate minBound and maxBound
00:40:33 <jle`> KorriX: is NaN within maxbound and minbound?
00:40:38 <johnw> what is the most efficient way to mask out a bit-range from within some Bits a, say bits 17-33, as an Int?
00:40:39 <jle`> if not, then it's not bounded
00:41:01 <knapper_tech> Will Heist have some internal state that each renderTemplate is going to modify?  No idea what's going on here.
00:41:16 <KorriX> jle`: Thanks. Now I got it
00:43:05 <knapper_tech> maybe it's not as complicated as it seemed at first.  looking at docs some more.
00:44:30 <jle`> johnw: i think it's a little more meaningful than that; like in state, if you have an `s`, a State s a gives you an a.  if you have e computer and a runtime system, IO a represents producing an a.  if you have fromMaybe a, Maybe a gets you an a.  the a you get might in some cases be the a that you put in...but that's a part of the semantics of Maybe?
00:44:38 <jle`> but
00:44:41 <jle`> i guess it is a stretch
00:44:47 <jle`> i shouldn't say "Functor is"
00:44:52 <jle`> thas bad
00:45:12 <pjdelport> KorriX: If IEEE floats had a minBound / maxBound, it would probably have to be positive and negative infinity. But NaN is incomparable to both, so you can't really say that the infinities are the minimum or maximum of the type.
00:46:23 <Cale> pjdelport: But then, that doesn't stop it from being an instance of Ord
00:46:38 <Cale> > compare (0/0) 0
00:46:40 <lambdabot>  GT
00:46:58 <Cale> > compare 0 (0/0)
00:47:00 <lambdabot>  GT
00:48:01 <levi> knapper_tech: Heist has some slightly complex type machinery to it that allows it to be very general.
00:48:19 <dfeuer> I've attempted to understand monad transformers before, but I always got completely mixed up at some point.
00:48:53 <dfeuer> And then someone will go and bring up notions like monad morphisms and I'll be left utterly in the dark.
00:49:24 <knapper_tech> levi:  can you elaborate a bit?  my grey matter is finding traction.
00:49:42 * dfeuer should really go to sleep an hour ago. Bye, y'all.
00:50:00 <levi> dfeuer: Bye!
00:52:17 <pjdelport> Cale: Hmm, so correction, minBound should be -Infinity and maxBound should be NaN ? :)
00:52:24 <pjdelport> zany
00:52:32 <levi> knapper_tech: Well, the idea is that you want to be able to take advantage of the functions provided by Heist, but Heist is in charge of a lot of the control flow; you need to provide implementations of some functions that need to know both about Heist and your own application's state.
00:53:06 <pjdelport> http://www.haskell.org/pipermail/haskell-cafe/2007-November/035393.html -- "Basically, it's not Bounded, not for a particular reason, but just because it's rather broken from a Haskell point of view anyway, IMHO."
00:53:18 <johnw> jle`: yeah, Functor itself never generates anything at all, it just gives you a way to lift functions; take the Const functor as a key example, since in that case the 'a' is just a phantom
00:53:19 <knapper_tech> Alright.
00:53:34 <jle`> johnw: ah yeah.  it's not the functor itself that imbues any genearting powers
00:53:45 <jle`> the idea of functor doesn't have anything to do with generating
00:53:53 <levi> So Heist has to be able to evaluate these functions you write, and these functions you write need to know about your application's state, but how is *it* to know anything about your application's state?
00:54:08 * hackagebot snaplet-haxl 0.0.0.1 - Snaplet for Facebook's Haxl  http://hackage.haskell.org/package/snaplet-haxl-0.0.0.1 (biscarch)
00:54:18 <knapper_tech> levi: it?
00:54:22 <levi> Heist
00:55:58 <knapper_tech> levi: The idea that monads are structures of operations makes sense to me.  Could I restate Heist needing to know about the state to Heist needing to know the order of things and be able to send errors back up the stack?
00:56:50 <levi> The guys who wrote Heist can't know anything about your application's types, so they parameterize their Heist types with a type parameter that you get to supply.  You, in turn, have to make that type an instance of a Heist-specific type class, which provides implementations of the functions Heist needs from you.
00:57:12 <knapper_tech> got it
00:57:16 <knapper_tech> I think
00:58:04 <knapper_tech> But it's still batshit crazy.  I need to find a good warmup library.  Still learning a lot of basic Haskell.
00:58:05 <levi> This bit isn't actually about monads, it's more about providing a way for Heist to make callbacks that involve a type that's unknown to it.
01:01:29 <levi> It's sort of like Heist is a wrapper around your application data type; normally wrapper/container/etc. sort of things (which generally fall in the Functor type class) have a single type parameter for the sort of type they hold/wrap/etc. But they can't *do* anything to the values of that type, because they don't know anything about it; it could literally be *any* type.
01:02:46 <levi> Heist says that the type it wraps has to be an instance of the HasHeist class; it *knows* about HasHeist, so it can call *just* the HasHeist methods on any type it wraps.  It's the only way it can interact with what it's wrapping.
01:02:54 <int3__> hm, why doesn't `foldr (<|>) [Just 1, Just 2, Nothing]` compile?
01:03:06 <int3__> should it be the same as Just 1 <|> Just 2 <|> Nothing
01:03:09 <int3__> *shouldn't
01:03:45 <int3__> oh actually I mean it compiles, just with a type of [[Maybe a0]] -> [Maybe a0]
01:03:50 <int3__> instead of Maybe a0
01:04:21 <pjdelport> int3__: You need "foldr (<|>) Nothing [Just 1, Just 2, Nothing]", or "foldr1 (<|>) [Just 1, Just 2, Nothing]"
01:04:41 <int3__> pjdelport: oh, right. sorry. I must be getting tired.
01:04:46 <pjdelport> (The former would be better in general.0
01:06:24 <levi> int3__: You forgot a parameter to foldr, I think.
01:06:39 <levi> Or you want foldr1
01:06:55 <int3__> yeah, I forgot about the init parameter
01:07:26 <levi> Oh, sorry, I'm slow; didn't see pjdelport already pointed it out to you.
01:19:11 * hackagebot taggy-lens 0.1.1 - Lenses for the taggy html/xml parser  http://hackage.haskell.org/package/taggy-lens-0.1.1 (AlpMestanogullari)
01:19:19 <trap_exit> [ func x | x <- list ] ... is there  way I can write this as "for x <- list; func x" ? the issue being: sometimes, "func" ends up being a multi-line anonymous function
01:19:38 <trap_exit> hmm
01:19:41 <trap_exit> I guess this is called "flip map"
01:19:46 <trap_exit> fucking point free style
01:20:29 <johnw> we like to keep a somewhat professional tone here, if you would
01:20:44 <trap_exit> I apolgoize
01:20:59 <johnw> thanks, trap_exit!
01:22:37 <jle`> trap_exit: sounds like you can do flip map
01:22:45 <jle`> flip map list $ \x -> ...
01:22:51 <jle`> but who does that these days :)
01:22:58 <trap_exit> jle`: yes, I think that's what I said ....
01:23:51 <supki> list <&> \x -> ...
01:24:19 <jle`> trap_exit: ah i missed that :)  sorry
01:24:34 <trap_exit> supki: is that haskell code, or is that a joke?
01:24:45 <joelteon> (<&>) is defined by lens
01:24:47 <joelteon> :t (<&>)
01:24:48 <lambdabot> Functor f => f a -> (a -> b) -> f b
01:24:51 <trap_exit> wtf is <&> and how am I supposed to google for it? :-)
01:24:54 <joelteon> flip fmap
01:24:56 <joelteon> hoogle it
01:24:57 <joelteon> or hayoo it
01:25:04 <joelteon> googling haskell operators is a silly idea
01:25:49 <Krenium> That is something that I learned all too well tonight, on my second day of learning
01:25:52 <edwardk> lens defines (<&>) because it writes a _lot_ of definitions that basically just fmap a large operation over a very small thing.
01:26:22 <edwardk> so since it had already adopted & as flipped $,  adopting <&> as flipped <$> seemed like a reasonable idea
01:29:00 <Mysterious_Light> @hoogle <&>
01:29:01 <lambdabot> No results found
01:29:49 <Mysterious_Light> \msg lambdabot @hoogle <&>
01:39:50 <ion> https://www.fpcomplete.com/hoogle?q=%28%3C%26%3E%29&env=ghc-7.4.2-stable-13.09
01:41:18 <trap_exit> what's a good example of how to type define a let varaible
01:41:28 <trap_exit> i.e. let f = .... :: <-- now, I wnat to label the type of f
01:41:28 <jle`> type define?
01:41:29 <trap_exit> how do I do this?
01:41:38 <jle`> that works fine, right?
01:41:51 <jle`> let x = mempty :: [Int] in x
01:41:58 <jle`> > let x = mempty :: [Int] in x
01:41:59 <lambdabot>  []
01:42:10 <trap_exit> why can I not write hte following:
01:42:11 <trap_exit>   let func = \(id, bdoc) -> (id, bdoc) :: (a, b) -> (a, b)
01:42:15 <jle`> > let x = read "4" :: Int in x
01:42:17 <lambdabot>  4
01:42:33 <jle`> trap_exit: where are you writing it?
01:42:55 <ion> let func = (\(id, bdoc) -> (id, bdoc)) :: (a, b) -> (a, b)
01:43:09 <ion> let func :: (a, b) -> (a, b); func (id, bdoc) = (id, bdoc))
01:43:10 <trap_exit> jle`: https://gist.github.com/anonymous/6377d7cc5a5d0f82b982
01:43:20 <trap_exit> ion: that fixed it
01:43:25 <jle`> ah, yeah. you need the parentheses
01:43:26 <trap_exit> ion: care to enlighten me on what I was gdoing wrong?
01:43:37 <trap_exit> :: bindings more tightly than -> ?
01:43:37 <ion> Your expression parsed as let func = \(id, bdoc) -> ((id, bdoc) :: (a, b) -> (a, b))
01:44:09 <jle`> also, why not func (id, bdoc) = (id, bdoc) ?
01:44:13 <jle`> or just func = id
01:44:19 <jle`> Prelude.id
01:44:34 <jle`> you can also type type annotations like normal inside a let
01:44:56 <jle`> let f :: (a, b) -> (a, b); f = \(id, bdoc) -> (id, bdoc) in ...
01:45:10 <jle`> ...i think
01:45:12 <jle`> hm.
01:45:20 <jle`> > let x :: Int; x = read "4" in x
01:45:21 <lambdabot>  4
01:45:23 <jle`> yea
01:45:50 <jle`> useful if you have a definition that is more than one line
01:48:54 <jle`> um so can we make dimap take in rmap first and lmap second
01:48:58 <jle`> plz
01:49:03 <jle`> thx
01:50:28 <ion> Why?
01:51:16 <trap_exit> is code like https://gist.github.com/anonymous/d8c779f6fe9756774095 ... considered idiomatic or intellectual showoff?
01:51:50 <ion> obfuscation
01:52:11 <trap_exit> so if we were working on a team
01:52:12 <trap_exit> and I wrote code like that
01:52:15 <trap_exit> you'd be pissed ?
01:52:18 <trap_exit> rather than impressed?
01:53:05 <ion> If you were doing maintenance on that piece of code a year later, would you be pissed or impressed?
01:54:32 <pavonia> What's the purpose of f there?
01:54:35 <trap_exit> i would probably build a time machine so I could go back in time to punch that idiot in the face
01:54:49 <ion> @type evalState (sequence (map ?f ?xs)) ?init
01:54:49 <trap_exit> pavonia: good call, I forgot to use the f
01:54:50 <lambdabot> (?xs::[a1], ?init::s, ?f::a1 -> StateT s Identity a) => [a]
01:54:53 <dmj`> trap_exit: using init as a function parameter might get confusing as well
01:54:55 <jle`> ion: for (->), dimap l r f is r . f . l
01:54:56 <ion> @type evalState (traverse ?f ?xs) ?init
01:54:57 <lambdabot> (?xs::t a, ?init::s, ?f::a -> StateT s Identity b, Traversable t) => t b
01:55:14 <jle`> trap_exit: not to mention using id as a variable ;)
01:55:35 <ion> … = bdoc__group (evalState (traverse go lst)) init where { go (id, bdoc) = … }
01:55:57 <ion> jle: Or more generally, not forgetting -Wall
01:55:57 <jle`> trap_exit: by the way, a dev cycle that integrates hlint and/or ghc-mod, like vim + syntastic, will warn you about the unused variable :)
01:56:08 <jle`> ion: ah yeah, that address it all :)
01:56:21 <jle`> anyways dimap l r f is weird o k
01:56:30 <jle`> it forces you to switch the order of composition in your head
01:56:36 <jle`> like using & instead of $
01:56:38 <jle`> or >>> instead of (.)
01:57:12 <Ainieco> hello
01:57:15 <jle`> hello Ainieco
01:57:15 <ion> Whoops, screwed up the parentheses in the example using traverse.
01:57:37 <trap_exit> dmj` , ion: noted, thanks!
01:58:05 <Ainieco> i want to implement UTCDate random instance , where can i look at sufficiently complex randomR definition?
01:59:25 <Ainieco> just want to see how they handle returning from randomR and gen passing around
02:01:50 <jle`> Ainieco: if you do it by hand, you can just use lots of let bindings
02:02:14 <trap_exit> man, haskell code is so beautiful
02:02:14 <jle`> Ainieco: there is a way to abstract out the let bindings by using State
02:02:29 <jle`> in particular the Applicative instance might be useful for you here
02:02:36 <Ainieco> jle`: okay, but how to return from randomR?
02:02:44 <jle`> randomR is just a function
02:02:45 <ivanm> @hoogle randomR
02:02:46 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
02:02:46 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
02:02:46 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
02:03:04 <ivanm> @hoogle Random
02:03:04 <lambdabot> System.Random class Random a
02:03:04 <lambdabot> System.Random module System.Random
02:03:04 <lambdabot> package Random123
02:03:08 <Ainieco> ah, okay, thank you!
02:03:14 <ivanm> @info Random
02:03:15 <lambdabot> Random
02:03:21 * ivanm glares at lambdabot 
02:08:52 <jle`> lol
02:13:05 <merijn> ivanm: There is no info command
02:13:25 <merijn> There is, however an autocorrect that autocorrects @info to @echo
02:13:30 <jtcwang> z
02:13:30 <merijn> @info Hilarious, no?
02:13:30 <lambdabot> <unknown>.hs: 1: 10:Parse error: ,
02:13:50 <merijn> Really, lambdabot >.<
02:16:51 <supki>  @undo, not @echo
02:17:04 <jle`> @undo Random
02:17:04 <lambdabot> Random
02:17:05 <jle`> oh i see
02:17:08 <jle`> everything makes sense now
02:17:48 <jle`> @echo hello
02:17:48 <lambdabot> echo; msg:IrcMessage {ircMsgServer = "freenode", ircMsgLBName = "lambdabot", ircMsgPrefix = "jle`!~mstksg@68.5.181.190", ircMsgCommand = "PRIVMSG", ircMsgParams = ["#haskell",":@echo hello"]} target:#haskell rest:"hello"
02:18:01 <jle`> yo what happened to my cloak
02:18:04 <jle`> must have been the netsplit
02:18:29 <snyp> Do you like lens?
02:20:32 <jle`> snyp: a lot of it, yes
02:21:40 <snyp> i see. since i am new to haskell, i find the lens syntax a bit cryptic. and i am reading an article called "Lens is unidiomatic Haskell".
02:22:12 <edwardk> snyp: i'd personally recommend avoiding lens until later on.
02:22:45 <snyp> edwardk: ah. i was thinking that too.
02:23:01 <systemfault> Hey, I just started to read the http://www.haskell.org/haskellwiki/Typeclassopedia page, where are the solutions for it?
02:23:23 <systemfault> I’m doing the exercises… would be nice to know if I’m right :/
02:23:24 <edwardk> when and if you do decide to learn lens, there is a #haskell-lens channel with about 130 folks in it who would be happy to help you get started, but its not a good place to start haskell -- it is very much written to have a high top end, not to have an easy starting point =)
02:23:56 <snyp> hmm.. all right.
02:24:12 <snyp> thanks for the advice.
02:26:12 <jle`> systemfault: the thing about Haskell is that if your solutions compile, they are often correct :)
02:26:16 <jle`> your compiler is your grader ;)
02:26:59 <jle`> for example, there is only one way to use Either in a Functor instance that will compile
02:27:02 <systemfault> jle`: For example, I would have love to see the solution to this question: Give an example of a type of kind * -> * which cannot be made an instance of Functor (without using undefined).
02:30:40 <merijn> systemfault: Easy :)
02:30:46 <lfairy> systemfault: something contravariant, I guess?
02:30:50 <merijn> systemfault: "data Foo a b = Foo (b -> a)"
02:30:52 <systemfault> merijn: Not for me.
02:30:58 <lfairy> merijn: :D
02:31:07 <merijn> systemfault: Actually, even simpler
02:31:21 <merijn> systemfault: "data Foo a = Foo (a -> Int)"
02:31:37 <lfairy> to explain merijin's solution: fmap only works on outputs. by making the parameter an input, it becomes unmappable
02:31:40 <merijn> systemfault: Try and write a Functor instance for that which type checks, you can't :)
02:32:01 <lfairy> *merijn
02:32:07 <systemfault> lfairy: It will still have the kind * -> * ?
02:32:24 <merijn> systemfault: "fmap :: (a -> b) -> Foo a -> Foo b" this becomes: "(a -> b) -> (a -> Int) -> (b -> Int)", which you can hopefully see, doesn't work
02:32:36 <merijn> systemfault: Yes, my "Foo" datatype has * -> *
02:32:47 <merijn> @let data Foo a = Foo (a -> Int)
02:32:49 <lambdabot>  Defined.
02:32:51 <merijn> @kind Foo
02:32:52 <lambdabot> * -> *
02:33:32 <systemfault> I understand :) Thank you
02:33:50 <merijn> FYI, this is called a Contravariant Functor and there is a typeclass for that with "contramap :: Contravariant f => (b -> a) -> f a -> f b" which whould work for my example
02:34:35 <merijn> See: http://hackage.haskell.org/package/contravariant-0.6/docs/Data-Functor-Contravariant.html
02:35:37 <systemfault> I’m at a point where I wouldn’t be able to find a use-case for that :/
02:36:03 <merijn> systemfault: Well, my example just now is a usecase, are you familiar with things like Conduit?
02:36:40 <systemfault> merijn: No, I’m a beginner… I’m still learning the core language.
02:36:45 <merijn> systemfault: "event sinks", i.e. things that consume events tend to be contravariant, because a "Sink a" usually "consumes" as (like my "a -> Int" example)
02:37:27 <merijn> systemfault: So you can think of "contramap" as a function that transforms "a consumers" into "b consumers" using a function "b -> a" (i.e. it applies the function to every incoming element before feeding it to the sink)
02:38:04 <levi> Another exercise: can you think of a type of kind * -> * that can be both an instance of Functor and Contravariant?
02:38:55 <systemfault> I can’t :/
02:39:04 <merijn> Functors on the other hand can be used (not just, but it's a nice contrast to the "functors are containers" view) as "event sources", i.e. "Source a" is something that "produces" as ("IO a" is an obvious example), and "fmap" transforms "a producers" into "b producers" using a function "a -> b" (i.e. it applies the function to every element produced by the source) :)
02:41:36 <merijn> systemfault: (You can safely ignore all this if you feel lost) Well, if Functors are event sources, and Contravariant functors are event sinks, then something which is BOTH would be something that is *both* a sink and a source
02:42:20 <merijn> Does such a thing exist? Yes! It's a pipe, for example "a -> a" is both a functor (source of a's) and contravariant functor (sink for a's)
02:42:34 <systemfault> merijn: I understand the notion of contravariance in OOP… :/ It’s probably different though.
02:42:57 <lfairy> it is a bit different, since haskell has no notion of subtyping
02:43:23 <lfairy> pretty much all the co/contravariance in haskell relates to functions
02:43:56 <lfairy> "co = output, contra = input" is the limits of what you need to know
02:44:00 <merijn> systemfault: Anyway, all of this is just a bit of enthousiastic rambling, if you're just starting I wouldn't worry too much. It might be worth writing down and rereading in a few months, to see if you go "ooooooh!"
02:44:58 <merijn> systemfault: I would spend like 15-30 mins trying to implement a Functor instance for my Foo datatype (if it's not obvious why you can't), because some healthy struggling tends to help see what's going on :)
02:46:50 <systemfault> data Foo a = Foo (a -> Int) is a contravariance function,  would data Foo a = Foo (Int -> a) be a functor?
02:47:04 <systemfault> s/function/functor
02:47:22 <frerich> In conduit-0.2.2 there was a 'sourceFile' function which has been removed somewhen later. Does anybody know how to do this using the current conduit version? I'd need to treat a file as a source.
02:48:26 <merijn> systemfault: Yes
02:48:41 <merijn> systemfault: The latter is a functor indeed, try implementing the instance :)
02:48:55 <systemfault> Ok :D
02:59:22 <levi> BTW, `data Bar a = Bar` is one example of a type of kind * -> * that can be an instance of both Functor and Contravariant.
03:02:09 <levi> If you ever see a type like (Functor a, Contravariant a) => X a b -> ... , you know the a type is not used in the implementation.
03:02:58 <xpika> what is an example of the use of stackage?
03:07:24 <systemfault> merijn: I can’t even do it for the simple case.. :(
03:07:35 <systemfault> merijn: This one: data Bar a = Bar (Int -> a)
03:11:31 <jle`> systemfault: if i have a function (Int -> a), and a function (a -> b), how can I make a new function (Int -> b) ?
03:12:09 <systemfault> Just compose them?
03:12:09 <jle`> another way to approach it is
03:12:28 <jle`> fmap f (Bar g) = Bar $ \i -> ...?
03:12:31 <jle`> where i is your input Int
03:12:37 <jle`> and ... is some way to get a `b`
03:12:44 <jle`> knowing that g :: Int -> a
03:12:47 <jle`> and f :: a -> b
03:12:59 <systemfault> instance Functor Bar where
03:13:00 <systemfault>   fmap g (Bar a) = Bar (fmap g a) ?
03:13:30 <systemfault> I guess if that works… I can replace the second fmap with g . a ?
03:13:38 <jle`> well i was going for either fmap g (Bar a) = Bar (g . a), composition
03:13:39 <jle`> or
03:13:51 <jle`> fmap g (Bar a) = Bar $ \i -> g (a i)
03:13:58 <jle`> with some better names...
03:14:07 <jle`> fmap f (Bar g) = Bar $ \i -> f (g i)
03:14:10 <donri> fmap = (.) for (->)
03:14:28 <FPtje> I've got a question about uu-parsinglib. Is it possible to create parser combinators that return position info? I want to do Lexical (and later parse tree) analysis on code, but I need to know the positions of the tokens to be able to generate meaningful errors.
03:15:04 <donri> FPtje: have you considered trifecta?
03:15:22 <systemfault> jle`: Love the fact that if the code compiles… there’s a great chance you “got it” :)
03:16:19 <jle`> systemfault: welcome to Haskell ;D
03:16:37 <FPtje> donri: I already tried alex, which crashed and burned when I wanted to correctly tokenize /* */ tokens (it failed on "/***/ 'asdf*/'")
03:17:38 <donri> trifecta is a parser combinator library with a focus on useful error messages
03:20:10 <FPtje> donri: I'll switch to yet another way of parsing if I know definitively that uu-parsinglib is practically useless for real life purposes
03:20:31 <donri> oh it probably isn't :)
03:20:57 <donri> and if you're already invested in uu take my suggestion with a grain of salt etc :)
03:21:09 <FPtje> I don't see anyone writing a compiler with uu-parsinglib if it's impossible to get position information from it.
03:21:20 <xpika> most packages on stackage have there version number set to any. how is this any more stable than hackage?
03:21:21 <donri> isn't it used for uhc?
03:22:35 <FPtje> Say you have a linter that complains when you have two semicolons next to each other in C#, first it lexes the file, analyses the tokens, but when it wants to complain it can't because it doesn't know where the two semicolons are in the file
03:24:24 * hackagebot ghc-mod 4.1.5 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-4.1.5 (KazuYamamoto)
03:28:17 <donri> xpika: perhaps 'stable' here means "everything builds together without conflicts"
03:28:20 <levi> FPtje: It's used extensively in the UHC haskell implementation, as far as I know.
03:28:49 <donri> xpika: while leaving it up to cabal to find a build plan
03:29:03 <levi> uu-parsinglib has some pretty cool stuff in it, but it's occasionally a bit tricky to use.
03:29:46 <FPtje> levi: surely they must record the position info in the syntax tree?
03:32:38 <levi> I looked into doing the position info stuff with it, but there didn't seem to be an obvious way of doing it. There's some questions regarding that on StackOverflow, I think.
03:33:42 <FPtje> I found one regarding parsec, yeah. I've got an idea: tokenize whitespace too and use that to count positions and line numbers in a pass AFTER the parsing
03:34:46 <FPtje> That way I'll have a list of tokens (where whitespace is also a token), then I loop over the tokens to create a datastructure which counts the line numbers and characters from the tokens
03:39:26 * hackagebot scientific 0.3.2.2 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.2.2 (BasVanDijk)
03:43:15 <xpika> donri: is there an easy way to browse the successfuly built packages?
03:45:39 <Profpatsch> How would I shorten this?
03:45:45 <Profpatsch>     args <- getArgs
03:45:47 <Profpatsch>     if (length args) /= 3
03:45:49 <Profpatsch>        then error "Args: start step end of 10^x"
03:45:51 <Profpatsch>        else return ()
03:46:11 <ivanm> Profpatsch: well, using error looks bad...
03:46:43 <ivanm> I would think that returning a Bool or a Maybe would be better.
03:46:55 <Profpatsch> ivanm: That’s just a quick one-off script. But how would I avoid the return ()?
03:46:59 <ivanm> in which case, you could do: getArgs >>= (/=3) . length
03:47:10 <ivanm> @type guard
03:47:11 <lambdabot> MonadPlus m => Bool -> m ()
03:47:26 <ivanm> > guard True :: Maybe ()
03:47:28 <lambdabot>  Just ()
03:47:37 <ivanm> @src guard
03:47:37 <lambdabot> guard True  =  return ()
03:47:37 <lambdabot> guard False =  mzero
03:48:14 <adas> im trying to install quickcheck and I get the error "tf-random-0.5 failed during the final install step. The exception was:
03:48:16 <adas> /tmp/pkgConf-tf-random-034.5: hGetContents: invalid argument (invalid byte
03:48:18 <adas> sequence)
03:50:42 <kqr> how can i get the number of seconds in a difftime?
03:50:46 <kqr> or rather
03:50:50 <kqr> picoseconds probably
03:52:10 <kqr> maybe toRational is good enough
03:53:22 <danilo2> Hello! Is there any standard method in Haskell of signature "m a -> t m a", where t is monad transformer?
03:53:35 <jle`> danilo2: lift?
03:53:38 <jle`> :t lift
03:53:39 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
03:53:40 <kqr> danilo2, lift
03:54:22 <danilo2> jle`, kqr: oh, I'm sorry! I'm feeling right now stupid - to much work, to luittle sleep :D
03:54:33 <jle`> danilo2: no worries :)
03:55:13 <danilo2> jle`: I'm feelign strange because I'm using it all the time, sometimes you are just "overworked" :P
03:55:29 <adas> nm. got it working thanks.
03:56:23 <kqr> danilo2, don't be sorry! i love when we get easy questions here – that means even I get something to do!
03:58:00 <danilo2> kqr, jle`: Heh, btw - I've got a little more advanced one - from yesterday - If you are interested and would like to look into it - I would be very thankfull for telling me why following code does not compile and why GHC does not allow such instances: http://lpaste.net/107264
03:58:19 <kqr> now it's not easy anymore :(
03:59:04 <danilo2> kqr: heh :)
03:59:31 <jkarni> danilo2: your instance head (RHS of =>) are the same
04:00:21 <Profpatsch> ivanm: Well, getArgs >>= (/=3) . length doesn’t work because the second part doesn’t produce a Monad.
04:00:24 <danilo2> jkarni: not exactly - If you comment out line 26 it compiles. they are nto the same, while using OverlappingIsntances we can use something like that - ghc can match the first one if the varialbes are the same, othercasde it matches the second one
04:00:40 <danilo2> jkarni: I'm using this mechanism a lot recently and is working in some examples well
04:01:20 <danilo2> jkarni: and the liberage coverage condition (ghc-7.8.x) is met there, becasue the second instance is a recursive one - which filfulls also the fundeps there :)
04:01:28 <Profpatsch> But liftM doesn’t work either, because it lifts the function to Monad m => (a -> b) -> m a -> m b
04:01:53 <Profpatsch> I’m lost. oO
04:02:50 <pavonia> Profpatsch: What are you trying to do?
04:03:22 <kqr> Profpatsch, fmap ((/=3) . length) getArgs :: IO Bool
04:03:39 <kqr> Profpatsch, equivalent to
04:03:42 <jkarni> danilo2: ah yeah, missed the matching 'a's
04:03:53 <kqr> Profpatsch, getArgs >>= return . (/=3) . length
04:03:56 <donri> xpika: duno
04:03:57 <kqr> Profpatsch, if you prefer the monadic style
04:04:05 <danilo2> jkarni: :) Still the problem is, why GHC does nto work there :(
04:04:13 <jle`> x >>= return . f ?
04:04:16 <jle`> why not fmap f x ?
04:04:22 <kqr> jle`, i did suggest that just above
04:04:25 <jle`> oh
04:04:26 <jle`> sorry :)
04:04:30 <donri> xpika: there's a stackage ml i think
04:04:37 <kqr> Profpatsch, "return" takes any non-monadic thing and makes it monadic, which solves your problem of the second part not being monadic
04:08:49 <danilo2> Ok, another funny, simple question - is there any standard method "m a -> t a", where m and t are monads?
04:09:56 <kqr> there can't be
04:10:08 <kqr> imagine "IO a -> [a]"
04:10:15 <kqr> that would allow you to escape the IO monad
04:11:35 <dagle> The closest thing I can think of is an tranformer.
04:11:42 <dagle> a*
04:11:45 <alpounet> or to always return []
04:11:45 <donri> danilo2: mmorph for specific mondas
04:11:47 <jkarni> danilo2: IncoherentInstances seems to help, though then you get an ambiguous type
04:13:04 <jkarni> danilo2: there's some dicussion that seems to explain what might be happening in the user guide
04:13:07 <jkarni> danilo2: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap
04:14:21 <jle`> donri: yeah, that's called a monad morphism
04:14:29 <jle`> forall a. m a -> m' a
04:14:48 <jle`> you can't do it in general for all monads
04:14:55 <jle`> but there are certain pairs where it is useful/meaningful
04:15:06 <jle`> *for all monad pairs
04:15:07 <jkarni> Identity and anything else, for instance
04:16:02 <jkarni> @type return . runIdentity
04:16:03 <lambdabot> Monad m => Identity b -> m b
04:16:16 <alpy> does anyone know a good tutorial on quasi quatations?
04:17:19 <jle`> Reader r to State r
04:17:31 <jle`> is a useful one
04:17:53 <jle`> you can designate parts of your State computation that are read-only
04:17:58 <alpounet> IO to any MonadIO instance, with liftIO
04:18:00 <jle`> and then lift them "back into state"
04:19:07 <ivanm> Profpatsch: oh, right.... liftM ((/=3) . length) getArgs
04:20:36 <donri> :t maybeToList
04:20:37 <lambdabot> Maybe a -> [a]
04:20:52 <kqr> ivanm, liftM = liftA = fmap
04:21:03 <kqr> ivanm, any particular reason to use liftM?
04:22:14 <jle`> :t \rdr -> liftM (runReader rdr) get
04:22:15 <lambdabot> MonadState a1 m => Reader a1 r -> m r
04:22:45 <jkarni> jle`: nice
04:22:45 <jle`> :t \rdr -> liftM (runReader rdr) (get :: State s s)
04:22:46 <lambdabot> Reader a1 r -> StateT a1 Identity r
04:22:54 <jle`> darn type synonyms
04:22:56 <augur> is there a nice library for doing simple prolog-y constraint solving?
04:23:17 <ivanm> kqr: well, until 7.10 they're not actually equivalent, since it's possible to have a Monad that isn't a Functor or APplicative
04:23:25 <ivanm> and Profpatsch mentioned liftM :)
04:23:49 <kqr> ivanm, the IO monad which the question was about is an applicative!
04:24:14 <ivanm> sure, but he said he couldn't get liftM to use
04:24:20 <ivanm> so I demonstrated how to use it
04:24:26 <kqr> yeah i understand
04:24:57 <jle`> :t listToMaybe
04:24:58 <lambdabot> [a] -> Maybe a
04:25:08 <jle`> tonight is monad morphism night
04:25:29 <donri> that's not a monad morphism though
04:25:48 <augur> basically, i have a set of simple binary function-like predicates like { p(X) = Y, q(X) = Z, p(W) = R, q(W) = R } and i want to enforce an equation X = Z in such a way that the set reduces to { p(X) = Y, q(X) = Y }
04:25:53 <augur> or some such like that
04:25:57 <jle`> donri: it's not? :'(
04:26:05 <donri> unless i've misunderstood
04:26:12 <jle`> hm
04:26:23 <donri> but it throws away list elements beyond the first
04:26:32 <donri> > listToMaybe [1,2,3]
04:26:33 <lambdabot>  Just 1
04:26:36 <augur> along with maybe some other things like appending lists, unioning sets, etc.
04:26:48 <jle`> it's not an isomorphism
04:26:50 <donri> but maybeToList should be fine
04:27:00 <jle`> hm
04:27:17 <donri> hm but then anything is a monad morphism? :P
04:28:12 <jle`> anything (Monad m, Monad m') => forall a. m a -> m' a ?  with some laws i think hm.
04:28:36 <donri> ioToList = const []
04:29:15 <jle`> mm (x >>= f)    == (mm x >>= mm . f)
04:29:47 <jle`> or in (=<<)-speak, mm (f =<< x)   ==   mm . f =<< mm x
04:29:58 <jle`> basically it "distributes" over (>>=)
04:30:28 <jle`> > listToMaybe ([1,2,3] >>= replicate 2)
04:30:29 <lambdabot>  Just 1
04:30:50 <donri> does that hold for listToMaybe
04:30:53 <jle`> > listToMaybe [1,2,3] >>= (listToMaybe . replicate 2)
04:30:54 <quchen> I think it should distribute over >=>, not >>=.
04:30:55 <lambdabot>  Just 1
04:31:03 <jle`> quchen: ah that sounds more reasonable
04:31:04 <quchen> Oh, I overlooked the "." ther.e
04:31:45 <jle`> (mm .) (f >=> g) ==== (mm .) f >=> (mm .) g
04:32:01 <danilo2> jkarni: incoherent instances are destroing the logic and they simply cannot work here
04:32:27 <jle`> listToMaybe makes sense because...throwing out all but the first element at every step is the same as doing the whole thing and throwing out all but the first element at the end
04:32:43 <danilo2> donri: ahh mmorph! great, thank you :)
04:40:54 <donri> jle`: so... const [] and Nothing are valid morphisms for any monad?
04:41:12 <danilo2> donri: Do you know about a method whuich would allow me to do something like that: "(m1 a -> m2 a) -> t m1 a -> t m2 a" ?
04:41:15 <jle`> oh yeah, the return law
04:41:35 <jle`> mm (return x) = return x
04:41:41 <jle`> that should fix that i think
04:41:53 <Profpatsch> kqr ivanm : Thanks!
04:41:59 <danilo2> donri: I know its strange, but I remember you have told somebody before about mmorph and maybe you are fammiliar with such strange functionality, like in my example :)
04:41:59 <quchen> danilo2: http://hackage.haskell.org/package/mmorph-1.0.3/docs/Control-Monad-Morph.html#v:hoist
04:42:01 <donri> jle`: oh of course
04:42:06 <jle`> sorry :)
04:42:10 <donri> but still permits listToMaybe
04:42:11 <donri> nice
04:42:20 <danilo2> quchen: Ah, I'm blind, thanks! :)
04:42:31 <donri> danilo2: not really familiar
04:42:54 <quchen> danilo2: I recommend reading the tutorial at the bottom, it's pretty useful
04:43:00 <danilo2> donri: quchen showed above the "hoist" method - doing exactly this kind of stuff :)
04:43:08 <danilo2> quchen: ok, thank you! :)
04:47:49 <hexagoxel> gtk question: is there a way to access the "newer" gui element classes (such as gtkbox and gtkgrid)? the interface in both gtk/gtk3 packages seems to be at a gtk2 level (or something, i am new to gtk). or is there yet another package with an up-to-date interface?
04:51:35 <danilo2> quchen: Oh, the hoist signature is "(forall a. m a -> n a) -> t m b -> t n b" - but I need in reality "(m a -> n b) -> t m a -> t n b" :( Sorry for asking another question - but maybe you know about something like that, or it is easly to achive but I'm still somehow blind?
04:51:58 <jle`> donri: the monad morphism laws look really similar to the natural transformation laws, actually
04:52:33 <jle`> nat trans being (Functor f, Functor f') => forall a. f a -> f' a
04:52:37 <jle`> which i guess makes sense
04:52:40 <donri> they're the functor laws according to mmorph
04:52:58 <jle`> oh really?
04:53:03 <jle`> i should probably rtfm :)
04:53:38 <quchen> danilo2: I'm not sure it exists without the forall.
04:54:31 * hackagebot base-prelude 0.1.0 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.0 (NikitaVolkov)
04:55:56 <danilo2> quchen: I just relized that it does not exist in the mmorph package, but I was able to define such typeclass by myself and make isntances for StateT. But we cannot make a general rule for all types using mmorph one. hoist for StateT is implemented as "hoist nat m = S.StateT (\s -> nat (S.runStateT m s))", which applies the "forall a" to the tuple inside of StateT, and using my sgnature we would have to know that there is a tuple a
05:02:56 <deni> some light summer reading: http://pixbin.us/ql8nu7
05:02:59 <deni> :D
05:04:16 <systemfault> What is the use of ZipLists? A more general ZipWith?
05:04:29 <Hodapp> deni: that lower left book has been on my wishlist awhile...
05:05:43 <donri> systemfault: are you talking about zippers?
05:06:24 <systemfault> donri: I’m reading about Applicative
05:07:04 <donri> oh right
05:07:18 <systemfault> getZipList $ (+) <$> (ZipList [1,2,3]) <*> (ZipList [4,5,6]) is pretty much zipWith, no?
05:07:47 <systemfault> Looks to me like Applicative has the advantage of making it more generic
05:08:07 <systemfault> So you don’t need zipWith3/4/1000000
05:08:12 <donri> yeah
05:08:19 <frerich> More generality at the expense of pretty much everything else in this particular case :]
05:08:28 <systemfault> Ah, really? :/
05:08:49 <deni> Hodapp: as on mine :)
05:08:58 <Hodapp> deni: let me know how it is
05:09:18 <deni> Hodapp: will do....it's going to take me a while to read all this though :)
05:11:32 <frerich> systemfault: You could also implement a 'zipWithN' yourself by just using 'zipWithN f = foldl1 (zipWith f)'
05:12:23 <systemfault> Hmm, true
05:12:49 <donri> frerich: but then the lists must have the same type no?
05:13:48 <frerich> donri: Yes, that requirement stems from the function used for zipping (e.g. (+)), no? I.e. the same as with applicative-style ZipList stuff posted earlier?
05:14:08 <donri> :t zipWith
05:14:09 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
05:14:38 <donri> in the case of (+), sure, but then you may as well just use zipWith (+)  :P
05:15:16 <donri> :t \f -> foldl1 (zipWith f)
05:15:17 <lambdabot> (a -> a -> a) -> [[a]] -> [a]
05:15:18 <frerich> Well except that zipWith just takes two arguments.
05:15:49 <frerich> I was referring to the "Looks to me like Applicative has the advantage of making it more generic. So you don't nede zipWith3/4/1000000".
05:15:50 <donri> also not sure this does the same as ZipList
05:16:03 <donri> :t zipWith3
05:16:04 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
05:16:21 <frerich> Ah, true.
05:16:47 <frerich> So zipWithN is not the same as zipWith3, but it *is* the same as the applicative version.
05:16:54 <donri> no
05:17:26 <frerich> Disclaimer: I'm not sure what ZipList does.
05:17:27 <donri> zipWithN zips N lists with a binary function
05:17:38 <donri> ZipList zips N lists with an N-ary function
05:17:49 <donri> of arbitrary types
05:17:52 <frerich> Ah
05:18:26 <k00mi> how is (a -> b -> c -> d) a binary function?
05:18:27 <eevar> suggestions on a less awkward way to write the function starting on line 26? -- http://pastebin.com/FuAMFhwj
05:18:34 <frerich> donri: Well that was stupid, d'oh... now that I look at it: getZipList $ (+)  (ZipList [1,2,3]) <*> (ZipList [4,5,6]) <*> (ZipList [9,9,9]) wouldn't even typecheck
05:18:35 <donri> k00mi: that's zipWith3
05:19:12 <donri> frerich: :)
05:19:30 <k00mi> donri: yes, it zips 3 lists with a 3-ary function, doesn't it?
05:19:55 <donri> k00mi: yes, zipWith3 is for a trinary function. frerich's zipWithN is something else
05:20:04 * frerich always has a mental image of a zipper, which is always binary AFAIK
05:20:14 <k00mi> oh, now I see
05:20:20 <frerich> Makes me wonder whether there are three-way zippers.
05:20:29 <systemfault> donri: Is there a cool way to do \x y z -> x * y * z ?
05:20:32 <Hafydd> ternary
05:21:03 <donri> frerich: not sure your zipWithN even zips, in the usual sense?
05:21:25 <donri> wait no, hm
05:22:43 <ion> systemfault: Yes, \x y z -> x * y * z
05:22:48 <systemfault> Haha :)
05:23:58 <joshc> @pl \x y z -> x * y * z
05:23:58 <lambdabot> ((*) .) . (*)
05:24:08 <joshc> not that I'd recommend it :)
05:24:44 <donri> :t uncurry3 (*)
05:24:45 <lambdabot>     Not in scope: ‘uncurry3’
05:24:46 <lambdabot>     Perhaps you meant ‘uncurry’ (imported from Data.Tuple)
05:24:47 <donri> :(
05:24:52 <donri> @hoogle uncurry3
05:24:54 <lambdabot> No results found
05:24:54 <ion> @pl \a b c d e f g -> c * a * b * b * a * g * e
05:24:54 <lambdabot> (((const . (const .) . flip . ((*) .) . (*)) .) .) . (flip =<< ((flip . ((*) .)) .) . join . ((flip . ((*) .)) .) . flip . ((*) .) . (*))
05:25:29 <donri> not that uncurry3 does the right thing here anyway
05:25:59 <systemfault> Haha, ((*) .) . (*) is insane
05:26:37 <joshc> > product [a, b, c, d, e, f, g]
05:26:38 <lambdabot>  1 * a * b * c * d * e * f * g
05:26:43 <donri> Hafydd: interesting http://www.perlmonks.org/?node_id=312569
05:30:19 <Eduard_Munteanu> How do you run a Parser on a Value in aeson? Not involving making a new datatype and FromJSON instance, that is.
05:32:04 <donri> Eduard_Munteanu: do you want to parse bytestrings to Value?
05:32:35 <Eduard_Munteanu> donri: no, ByteString to some other type
05:33:10 <Eduard_Munteanu> ByteString to Value works via decode and the likes.
05:33:51 <donri> Eduard_Munteanu: not sure i follow
05:34:12 <donri> decode parses to Value and then to FromJSON a => a, you don't see the Value
05:34:33 <Eduard_Munteanu> donri: there's a FromJSON Value instance
05:34:58 <donri> Eduard_Munteanu: i don't understand what you're asking for
05:35:33 <Eduard_Munteanu> donri: what I actually want is ByteString -> Parser a -> Result a   or similar
05:35:43 <eevar> Eduard_Munteanu: Data.Attoparsec.ByteString.parseOnly WhateverParser someBytestring
05:35:58 <eevar> or something like that
05:36:01 <Eduard_Munteanu> Oh? Is it an actual attoparsec parser?
05:36:08 <Eduard_Munteanu> Haven't thought of that, thanks.
05:36:37 <donri> not the value parsers no
05:36:45 <donri> it uses attoparsec for the json -> value parsers
05:37:21 <Eduard_Munteanu> Yeah, but can I go from ByteString straight to the result type?
05:37:36 <donri> what result type?
05:37:45 <donri> oh Result
05:38:13 <Eduard_Munteanu> donri: no, an arbitrary type, e.g. if ByteString -> Parser [Bool] -> Result [Bool]
05:38:23 <Eduard_Munteanu> s/if//
05:39:22 <donri> parse :: (a -> Parser b) -> a -> Result b is that what you're looking for?
05:39:46 <Eduard_Munteanu> donri: possibly, I see such a 'parse' in the source of fromJSON
05:39:57 <Eduard_Munteanu> Not sure it's exposed anywhere though.
05:40:17 <donri> Eduard_Munteanu: i'm still not sure what you're trying to do. do you want to parse a bytestring into a Value and then the Value into your type, side-stepping FromJSON?
05:40:23 <donri> Eduard_Munteanu: it's in .Types
05:40:44 <Eduard_Munteanu> donri: I simply want to avoid writing a FromJSON instance and use an "inline" parser, yes
05:41:14 <Eduard_Munteanu> Avoid writing a FromJSON instance and making up a type just for that parser.
05:41:29 <donri> Eduard_Munteanu: well you first need to use the 'json' attoparsec Parser to get a Value, then you can either convert that Value yourself or use the aeson Parser
05:42:40 <Eduard_Munteanu> Ah, 'parse' is exposed, hm.
05:43:18 <donri> http://hackage.haskell.org/package/aeson-0.7.0.6/docs/Data-Aeson.html#g:15 at bottom here are the attoparsec parsers
05:44:58 <Eduard_Munteanu> Oh, hm, confusing, so those are the only attoparsec parsers.
05:45:52 <donri> yes, attoparsec for parsing bytestrings, aeson for Value
05:46:32 <donri> there is no way to avoid Value in the chain with aeson, afaik
05:47:14 <donri> it's a bit different from e.g. Binary
05:47:22 <Eduard_Munteanu> That's ok, I guess. Thanks.
05:52:00 <donri> Eduard_Munteanu: problem with not using FromJSON is you'll have to write parsers for any contained types as well (or use FromJSON for those but not the container, i guess)
06:13:43 <systemfault> Anyone can show me how ** (Monoidal) works?
06:15:12 <ion> What’s monoidal (**)?
06:16:11 <systemfault> I don’t know… I was reading http://www.haskell.org/haskellwiki/Typeclassopedia then I saw
06:16:11 <systemfault> class Functor f => Monoidal f where
06:16:12 <systemfault>   unit :: f ()
06:16:13 <systemfault>   (**) :: f a -> f b -> f (a,b)
06:16:29 <ion> Ah
06:17:15 <ion> Given the Applicative in base, (**) = liftA2 (,)
06:17:17 <Iceland_jack> systemfault: it's just an alternative formulation of Applicative
06:17:45 <Iceland_jack> :t pure ()
06:17:45 <Iceland_jack> is unit
06:17:45 <lambdabot> Applicative f => f ()
06:18:28 <ion> and given Monoidal, pure x = x <$ unit; fs <*> xs = fmap (\(f,x) -> f x) (fs ** xs) or so
06:18:36 <mbrock> :t fmap (const a) (pure ())
06:18:37 <lambdabot> Applicative f => f Expr
06:18:59 <mbrock> :t (<$)
06:19:00 <lambdabot> Functor f => a -> f b -> f a
06:20:05 <systemfault> Ah ok :)
06:23:36 <ion> @type let unit = pure (); (**) = liftA2 (,); pure' x = x <$ unit; ap' fs xs = uncurry id <$> (fs ** xs) in (pure', ap')
06:23:37 <lambdabot> (Applicative f1, Applicative f) => (a -> f a, f1 (b1 -> b) -> f1 b1 -> f1 b)
06:24:42 * hackagebot buildwrapper 0.8.7 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.8.7 (JeanPhilippeMoresmau)
06:25:26 <veg4n> Does anyone have the time to (hopefully) quickly explain a type error (?) to me that I am unable to solve?
06:25:47 <bennofs> veg4n: paste code + error
06:25:49 <bennofs> @where lpaste
06:25:50 <lambdabot> http://lpaste.net/new/haskell
06:27:27 <veg4n> http://lpaste.net/107337
06:28:26 <veg4n> I'm going to be honest here, this is for an assignment, but I've read everything I found and worked on it for several hours but can't seem to get this to work
06:29:05 <veg4n> I just need a hint how to get this work, if that's okay. We're given the Tree data type as well as the signature of the runLabel function
06:29:51 <veg4n> The task is to construct the tape Label a which supports a stateful computation which might possibly fail, as well as get the input via command line from a user
06:30:07 <veg4n> ' No instance for (MonadState
06:30:07 <veg4n>                      (IO (ErrorT LabelExc IO a)) ((->) (Label a)))
06:30:07 <veg4n>     arising from a use of `get''
06:33:08 <ion> Using “get” on the “l” needs Label to have a MonadState instance.
06:33:49 <Saizan> not even that
06:34:23 <Saizan> ?type get
06:34:24 <lambdabot> MonadState s m => m s
06:34:54 <Saizan> the result needs to be a MonadState, you don't give an argument to get (most of the time)
06:35:11 <ion> Ah, right
06:36:30 <veg4n> I'm sorry, but I still don't really get it. I was assuming StateT implies the resulting monad to be an instance of MonadState
06:37:00 <Saizan> veg4n: not when wrapped in Tree like that
06:37:17 <veg4n> If that's wrong, is there any resource which explains that? The Haskell wiki and Hackage aren't of much help here..
06:37:29 <veg4n> Saizan: Okay, thanks for that information
06:37:53 <Saizan> veg4n: and even if it were get still wouldn't work there, because the monad is IO (Either LabelExc a) in that expression, get doesn't take a monadic value as argument
06:38:05 <Saizan> veg4n: btw, what's the point of Tree in Label?
06:38:27 <Saizan> veg4n: you might want to read about monad transformers, or just look at the MonadState instances in mtl
06:38:48 <secguy> Free OpenVPN for 5 days - http://vpn.scay.net/
06:39:12 <ion> Is that a typo for “scam”?
06:39:40 <veg4n> Saizan: The goal is to build up a Tree from user input, check if the input is valid and label the tree with it's pre-order position and the user input
06:40:15 <veg4n> The author of the exercise admits that 'This is example is a little contrived'
06:40:19 <veg4n> :)
06:40:37 <Saizan> veg4n: then you don't want Tree like that in Label
06:41:05 <veg4n> I've already read the chapter in real world haskell, the hackage documetation of mtl and the wiki article
06:41:18 <veg4n> But for some reason I can't figure it out
06:41:42 <Saizan> the way you've defined it Label a is a pure tree containing these stateful I/O possibly erroring computations in the nodes
06:42:38 <Saizan> is Monad Tree part of the exercise or something you came up with?
06:42:57 <veg4n> That's what i came up with, which means it might very well be wrong
06:43:02 <ion> Nice, BasePrelude from base-prelude-0.1.0 exports unsafeCoerce. Just the thing i’d want my code to have without an explicit import.
06:43:21 <TheKing444> XD
06:43:28 <ion> and unsafePerformIO
06:43:54 <TheKing444> I thought of making a package to trick noobs that renamed unsafePreformIO "unIO" and unsafeCoerce "changeType".
06:44:10 <Saizan> veg4n: yeah, it doesn't seem helpful here, nor a valid monad instance
06:44:27 <TheKing444> also I would have changeToTypeOf a b=unSafeCoerce a `asTypeOf` b
06:45:03 <TheKing444> Then tell them that #haskell was lying to them the whole time, and they just wanted to make sure you understood functional stuff before you got into the practical stuff.
06:45:08 <TheKing444> Maybe for April 1.
06:46:16 <veg4n> Saizan: So do you have any advice on how to structure this transformer stack? I've basically tried every permutation bc I couldn't come up with any solution and nothing seems to work or even make sense..
06:46:30 <TheKing444> what transformer stack?
06:46:32 <Saizan> veg4n: the tree is just going to be a result of the particular Label action you write
06:47:35 <Saizan> veg4n: Label itself needs only to keep track of the state etc..
06:47:58 <veg4n> Saizan: so something like 'Tree (IO a)' ?
06:48:36 <Saizan> no, in general if you have a monad M and want to produce a tree with it your action will have type M (Tree a)
06:49:16 <Saizan> Tree (IO a) is instead a tree with IO actions as labels
06:49:32 <Saizan> which is probably not what you want
06:49:51 <veg4n> You're right, that doesn't sound correct
06:50:36 <ion> Given the proper Traversable instance for Tree, you have traverse :: (a -> M b) -> Tree a -> M (Tree b) which you can use to apply an M action into each element.
06:51:08 <ion> veg4n1: Given the proper Traversable instance for Tree, you have traverse :: (a -> M b) -> Tree a -> M (Tree b) which you can use to apply an M action into each element.
06:54:17 <veg4n> ion: Thanks. But first, I need to figure out the correct type declaration for Label a, which I can't seem to figure out
06:55:45 <ezyang> I expect this to typecheck; why doesn't it on 7.6? http://lpaste.net/1300038011534180352
06:57:04 <donri> wasn't incoherent changed in .8
06:58:04 <ezyang> oh you're right, this does typecheck in 7.8
06:58:24 <joshc> veg4n: I'd focus at one part of your problem at a time.  for example, if you're working with the "label it with pre-order position and user input", assume you have an existing validated tree; then you can implement a function of type Tree a -> Tree (Int, a)
06:58:41 <jfischoff> Is there a Haskell package for reading mp3’s anywhere?
06:58:56 <ezyang> "The IncoherentInstances extension has seen a behavioral change, and is now 'liberated' and less conservative during instance resolution. This allows more programs to compile than before. " OK, thanks.
06:59:04 <TheKing444> You will probably need the base package for one.
07:03:36 <donri> ezyang: IIUC it now just picks an arbitrary matching instance. not sure exactly what it did before
07:04:35 <ezyang> it errored
07:04:55 <donri> i mean in general, not in your code :)
07:07:20 <donri> i wonder, does overlap alone permit incoherence without orphans?
07:08:06 <rwbarton> my guess is yes
07:08:25 <donri> example?
07:09:46 * hackagebot unagi-chan 0.1.0.2 - Fast and scalable concurrent queues for x86, with a Chan-like API  http://hackage.haskell.org/package/unagi-chan-0.1.0.2 (BrandonSimmons)
07:09:55 <donri> i guess orphan status doesn't necessarily make sense under overlap, because you can have wildcard instances
07:10:07 <ezyang> Yes
07:10:18 <ezyang> http://www.haskell.org/pipermail/glasgow-haskell-users/2010-February/018417.html
07:11:56 <geekosaur> woo, 7.8.3 finally
07:12:29 <c_wraith> wow.  Why is xz so much better than bz2 again?  Is it designed for x86 object code?
07:12:30 <rwbarton> donri: if I had an example, it wouldn't be a guess :)
07:13:11 <donri> rwbarton: sure, but i was hoping your guess was based on some theoretical scenario :)
07:13:52 <albeit> If I have an attoparsec function  f :: Parser a, and I'm calling it with "many f", is there a way to have f short-circuit and end the call to many, and not return an a?
07:14:06 <albeit> (But still succeed)
07:14:15 <c_wraith> albeit: no.  also, f isn't a function with that type. :P
07:14:35 <sebastian> anyone wanna try Hayoo 2? http://hayoo2.fh-wedel.de/
07:14:45 <ezyang> donri: But maybe this example doesn't count, because it's only incoherent under case-elimination
07:15:03 <c_wraith> albeit: You can't have f communicate "upward" in that way, with that type, because it'd break compositionality.
07:15:08 <frerich> sebastian: Nice!
07:15:21 <sebastian> frerich: ty :)
07:15:22 <donri> ezyang: aka it requires further extensions?
07:15:35 <frerich> sebastian: I'm a bit surprised by the results, e.g. http://hayoo2.fh-wedel.de/?query=%28a+-%3E+b%29+-%3E+%5Ba%5D+-%3E+%5Bb%5D finds something called 'simulateSeq' in a library (or application?) I never heard of before.
07:15:42 <c_wraith> albeit: if you want f to communicate results in that way, you would need to have them visible in the type.  And then you'd need to use something other than many to parse multiples
07:15:46 <ezyang> donri: No, as in, it really is unambiguous, but sensitive to what should be semantics preserving program transformations
07:16:22 <albeit> c_wraith: Okay, I think I'll write a modified many to check if the parsed result is valid
07:16:48 <rwbarton> donri: I think your "orphan status doesn't necessarily make sense" is on the mark
07:16:50 <sebastian> frerich: the score for packages seem to need some more tweaks
07:17:01 <rwbarton> imagine taking an example of incoherent instances with orphan instances
07:17:03 <c_wraith> albeit: I'd write it as f :: Parser (Maybe a) and manyJust :: Parser (Maybe a) -> Parser [a]
07:17:21 <frerich> sebastian: Maybe I'm just unclear about what Yahoo indexed. 'Maybe String -> String' doesn't have "fromJust" in the first page of hits, but "Maybe a -> a" is just fine.
07:17:24 <rwbarton> and now add one new parameter to the type class for each instance
07:17:33 <albeit> c_wraith: Sounds good! Thanks!
07:17:44 <rwbarton> or even each module in which you define instances
07:18:03 <frerich> sebastian: It's quite nice how fast the page is, but it may be related to me being in Altona. ;-)
07:18:13 <donri> also this line of thought was based on my misreading the user guide; it doesn't use orphan instances in the example of overlap incoherence
07:18:13 <rwbarton> in module X, define a type X and use type X in the slot for that module and leave the others free
07:18:32 <rwbarton> now every instance head mentions a type defined in that module
07:18:54 <rwbarton> I should just try this
07:19:00 <albeit> c_wraith: Actually wouldn't it be fine to just do "results <- catMaybes <$> many f"? (Assuming f :: Parser (Maybe a)
07:19:04 <sebastian> frerich: the signature search isn't as good as the one from hoogle,
07:19:19 <sebastian> frerich: we'not normalizing String to a
07:19:24 <c_wraith> albeit: Not if you want to stop parsing with f when it results in a Nothing
07:19:45 <c_wraith> albeit: using many would cause it to keep trying after it resulted in a Nothing
07:19:48 * hackagebot bus-pirate 0.6 - Haskell interface to the Bus Pirate binary interface  http://hackage.haskell.org/package/bus-pirate-0.6 (BenGamari)
07:19:56 <albeit> c_wraith: Ah yeah. In my case the only error happens only once at the last iteration, so thats fine
07:20:10 <c_wraith> albeit: oh.  Then you'd be fine
07:20:20 <frerich> sebastian: Pity. I always toggle between Hoogle and Hayoo because the latter has a nice signature search but the latter has a bigger search index (at least that's my impression)
07:20:48 <sebastian> frerich: yep. the index contains all hackage packages
07:20:54 <frerich> sebastian: Hm, just searcing for 'map' doesn't show the map function from the Prelude?
07:21:47 <sebastian> frerich: you've found another problem with the ranking ty
07:23:01 <shlevy> How can I insert a list of arbitrary size into a sql 'IN' clause with sqlite-simple?
07:27:40 <Ankhers> Could someone please explain to me how to go about using this IO ByteString in place of an expected ByteString? http://lpaste.net/107339
07:28:02 <kqr> is there a show-like function for Text?
07:28:13 <kqr> (or is the convention doing Text.pack . show?)
07:29:23 <donri> @hackage text-format
07:29:24 <lambdabot> http://hackage.haskell.org/package/text-format
07:29:26 <frerich> Ankhers: Since 'response' performs IO according to the type signature, so would 'bid' need to. However,  does 'response' really need to do IO? 'encode' doesn't seem like something which does IO.
07:29:49 * hackagebot bus-pirate 0.6.1 - Haskell interface to the Bus Pirate binary interface  http://hackage.haskell.org/package/bus-pirate-0.6.1 (BenGamari)
07:30:52 <Ankhers> frerich: I could be looking at the problem incorrectly. I need to log the encoded json, and some additional things.
07:31:08 <donri> kqr: text-format if all you want is an efficient generic way to render things like numbers, and don't need things like rendering haskell records with haskell syntax
07:31:19 <frerich> Ankhers: What's the signature of "encode"?
07:31:46 <donri> kqr: it also does strings and text without quotes or escapes etc
07:31:52 <frerich> Ankhers: I'd say it ends in "-> ByteString", right?
07:31:54 <kqr> donri, sounds great!
07:32:12 <Ankhers> encode is from Aeson.
07:32:22 <frerich> Ankhers: If so, there's no need why 'response' returns an IO ByteString when it can be just 'ByteString'.
07:32:35 <donri> kqr: wl-pprint-text if you want a more powerful pretty printer, but it too doesn't produce haskell-like output for you automatically
07:32:58 <kqr> donri, nah, i'm just interested in basic display of integers and such, so text-format looks like exactly what i want
07:32:59 <frerich> Ankhers: Right. So the 'IO ByteString' value of 'response' is unneded.
07:33:24 <Ankhers> frerich: But how could I go about logging this data than?
07:35:11 <frerich> Ankhers: Not in 'response' at least, that function doesn't need to do IO :)
07:35:30 <frerich> ...which probably also fixes the type issue (IO ByteString vs. ByteString) you initially mentioned.
07:35:45 <Ankhers> Yes, it will.
07:36:00 <Ankhers> I'm still just trying to wrap my head around doing proper IO in Haskell.
07:37:10 <frerich> Ankhers: In general, try to factor it out i.e. so that you do IO on the "outermost level". To be more specific, it would help if you could paste code and ask more precise questions :)
07:38:39 <henk> hi, how can I force ghci to evaluate getCurrentTime (from Data.Time.Clock) immediately in "let time_now = getCurrentTime"? AFAIU it is evaluated lazily, i.e. only when I do "diffUTCTime <$> time_before <*> getCurrentTime" which then returns "0" …
07:39:26 <c_wraith> henk: that just makes time_now an alias for getCurrentTime.
07:39:35 <c_wraith> henk: you want to *execute* getCurrentTime, instead
07:40:22 <kqr> henk, time_now <- getCurrentTime
07:40:23 <c_wraith> henk: is there some particular reason you're only using the Applicative interface?
07:40:36 <kqr> henk, will put the current time in time_now
07:42:42 <Ankhers> frerich: Thanks for the help. I will try and collect my thoughts and do that.
07:43:29 <henk> kqr: ah, thank you
07:43:33 <henk> c_wraith: no, why?
07:44:03 <c_wraith> henk: because what you want to do is much easier with the monadic interface, as kqr's example uses.
07:44:32 <c_wraith> henk: though if you're benchmarking code, I really suggest looking into the criterion library
07:44:36 <c_wraith> @hackage criterion
07:44:36 <lambdabot> http://hackage.haskell.org/package/criterion
07:45:23 <henk> c_wraith: oh, that is just for testing in ghci while trying to write code in parallel. I only needed to test how I can use diffUTCTime or rather NominalDiffTime …
07:48:00 <henk> c_wraith: I use "diffUTCTime time_before <$> getCurrentTime" now. Can that be simplified using the monadic interface instead of the Applicative interface?
07:48:42 <c_wraith> henk: actually, that's just the Functor interface.  And no, that's about as nice as it gets.
07:49:06 <henk> c_wraith: ok, thank you
07:53:26 <bergmark> henk: for monads: a <$> b = b >>= return . a = do { x <- a; return (a x) }
07:57:20 <rwbarton> donri: something like what I was planning did work   https://gist.github.com/rwbarton/dd8e51dce2a262d17a80
08:07:44 <RyanGlScott> I like seeing the build output when running cabal install, but in GHC 7.8, that doesn't show by default unless you use the -j1 flag (which restricts building to one core).
08:07:54 <RyanGlScott> Is there a way to have both build output and parallel building?
08:09:18 <Erwan21>  Here some videos. I hope you like them! http://j.mp/1qQLmJ3
08:09:49 <rwbarton> RyanGlScott: maybe instead of cabal install -j, try cabal install --ghc-option=-j
08:13:23 <donri> rwbarton: fun
08:19:52 <deni> what would be a good way to make myFn :: Int -> Int -> Int where the types make sure that the second int is less then the first int?
08:21:00 <donri> deni: dependent types. would need singleton types to do it in haskell I think
08:21:27 <deni> dependent types seems to be the answer for every question i ask lately :D
08:21:43 <donri> you might also want to look at liquid haskell
08:21:44 <deni> donri: how would you go about designing this?
08:22:10 <RyanGlScott> rwbarton: That didn't seem to do the trick, at least when installing in a sandbox.
08:24:05 <RyanGlScott> rwbarton: That is, parallel building still worked, but no build output.
08:24:23 <rwbarton> hmm, it's supposed to make ghc build modules in parallel, rather than have cabal run ghc in parallel on different packages
08:24:25 <JCI> join #clojure
08:24:30 <JCI> sorry
08:27:49 <RyanGlScott> I've tried various verbosity settings as well, but none of them only show the output à la cabal build.
08:34:21 <donri> deni: http://lpaste.net/107344
08:39:56 <donri> deni: might be possible to make it somewhat more convenient using http://hackage.haskell.org/package/singletons-1.0/docs/Data-Singletons-TypeLits.html
08:45:24 <grache28> Hi - sorry for newb question, just need to hack something together real quick - I'm getting " Not in scope: data constructor `Int'" - I just need to 'cast' a number to integer
08:45:56 <tremon> try toInteger
08:47:21 <rwbarton> there are no casts in Haskell
08:48:52 <grache28> rwbarton: yea, that's why i said 'cast', I want to explicitly define it as an Int instead of letting the type system infer: "foo = 5" vs. "Int foo = 5"
08:49:21 <rwbarton> foo = 5 :: Int
08:49:24 <rwbarton> or foo :: Int; foo = 5
08:49:28 <grache28> rwbarton: thanks :)
08:51:26 <moghedrin> Is there a function for the if then else construct that I just can't find?
08:51:36 <geekosaur> not standard
08:51:55 <geekosaur> a number of projects define something like if' locally
08:52:05 <moghedrin> geekosaur: Kk :) It's a little one-liner anyhow. Thank you very much! ^^
08:57:26 <shlevy> Data.Text has portability marked GHC, but Database.SQLite.Simple has portability marked portable, even though the latter requires the former.
08:57:31 <shlevy> Is that standard?
08:57:48 <shlevy> Should you only mark a package as non-portable when you use non-portable extensions directly?
09:02:44 <shadowofq> hello all, I have to run (saying) 1024 processes from a list of arguments to pass. I would like to run the code on several processes (but with a bound number of them). Basically, a bit like make -j16 for example. Would you know a link or a resource where I can look at it?
09:02:45 <donri> moghedrin: Data.Bool.bool
09:04:09 <shadowofq> To simplify, I have a list of string and I would like to "echo" them in parallel creating one echo process per list element
09:10:16 <Forgetaboutit> Is there a way to ensure compile-time uniqueness of values?  Only constraint: the values should have `Show' instances or something for printing.
09:15:22 <dario> how would you imagine that to work?
09:16:03 <Forgetaboutit> dario: I have no idea tbh :)
09:16:35 <Forgetaboutit> It's just something I've been thinking about for a while
09:23:28 <Forgetaboutit> dario: I don't know a lot about this, but would it be possible to create instances of a typeclass with a type-level function that takes a value as an argument?
09:26:05 <gilligan-> out of curiosity: is anyone here actually using stackage instead of hackage ?
09:31:13 <_2_kryspao06> hola
09:31:21 <_2_kryspao06> hola
09:32:59 <_2_kryspao06> nobmrcru ross Brawn se q me txt con el me dijo por favor no le digo que te txt ms q me voy al carajito recin
09:35:52 <btcNeverSleeps> > (42 + 0)
09:35:54 <lambdabot>  42
09:36:41 <btcNeverSleeps> The following (not very useful to say the least) works:
09:36:43 <btcNeverSleeps> > foldr (\ a b -> a b) 4 [(\z -> z * 17), (\n -> n + 1)]
09:36:44 <lambdabot>  85
09:37:46 <btcNeverSleeps> as I understand it (\z -> z * 17) and (\n -> n + 1) must have the same type, which they do:  Num a => a -> a
09:38:09 <btcNeverSleeps> However the following works too:
09:38:10 <btcNeverSleeps> > foldr (\ a b -> a b) 4 [(\z -> z * 17), (\n -> n + 1), (\n -> n)]
09:38:11 <lambdabot>  85
09:38:28 <btcNeverSleeps> Yet (\n -> n) does not have the same type
09:38:47 <btcNeverSleeps> What is going on under the hood? How is that mechanism called?
09:38:53 <glguy_> "unification"
09:39:16 <glguy_> The types of the elements of the list must be able to unify to the same type
09:39:24 <btcNeverSleeps> great
09:39:43 <btcNeverSleeps> thanks a lot (it's hard to Google when you have no idea what term you need to Google for :)
09:41:31 <TheKing444> yolo, who needs help haskelling?
09:41:42 <grache28> TheKing444: me
09:41:49 <TheKing444> What are you tryin to haskell?
09:42:54 <danilo2> Hello! Could somebody help me and explain a magic I encountered when writing a simple Haskell program? Here is 6-line code - if I use the first instance declaration, my program compiles and works, if I use the second one instead, the instance is not matched - why could something like that happen? http://lpaste.net/107346
09:43:08 <grache28> "foo = 1/2" makes haskell (or GHCI) happy, it gives us 0.5 ; But "foo :: Integer; foo = 1; bar = foo / 2" makes GHCI through a Fractional integer error
09:43:26 <TheKing444> I know what is going on!
09:43:30 <TheKing444> :t 1
09:43:31 <lambdabot> Num a => a
09:43:36 <TheKing444> :t 1 :: Integer
09:43:37 <lambdabot> Integer
09:43:54 <TheKing444> :t 1 :: Float
09:43:54 <grache28> My question is... Why? 1/2 is ok - but it seems since foo is of type Integer it wants to make the expression foo / 2 an integer as well
09:43:54 <lambdabot> Float
09:44:05 <TheKing444> exactly
09:44:26 <TheKing444> you can't divide things of type Integer
09:44:32 <TheKing444> but in 1/2, 1 is a Float
09:45:01 <TheKing444> when you type in 1, it automatically determines from context whether it should store it as an Integer or Float
09:45:10 <trap_exit> guys ... I fscked up ... and need some help. So I'm using haste (Haskell -> JS) compiler. I'm drawing 10 rectangles in svg to the screen, at 100 fps. For some retarded reason, when I use chrome to benchmark my haskell -> *.js app, it pegs 100% of my CPU and consumes 100 MB of RAM. This is just to draw 10 svg rectangles at 100fps. What retarded thing am I doing? How do I begin to debug this?
09:45:27 <TheKing444> but when you do "foo :: Integer", it has to store it as an Integer, which makes it sad when you do foo/2
09:45:40 <TheKing444> because it can force foo into a float, it is already forced into Integer
09:45:41 <zwer> haskell has generic numerical literals
09:45:45 <zwer> :t 1
09:45:46 <lambdabot> Num a => a
09:45:57 <TheKing444> Does lambda bot have type holes?
09:46:41 <TheKing444> That would help explain stuff.
09:46:45 <TheKing444> Ah well
09:46:49 <grache28> TheKing444: thanks
09:46:52 <zwer> I don't think it does
09:46:59 <TheKing444> let foo=1 in (foo/2, typeOf foo)
09:47:07 <TheKing444> > let foo=1 in (foo/2, typeOf foo)
09:47:08 <lambdabot>  (0.5,Integer)
09:47:20 <TheKing444> > let foo=1::Integer in (foo/2, typeOf foo)
09:47:21 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
09:47:21 <lambdabot>    arising from a use of ‘GHC.Real./’
09:47:29 <corgifex> :t ?foo / 2
09:47:30 <lambdabot> (?foo::a, Fractional a) => a
09:47:31 <TheKing444> wait, disregard that
09:48:07 <corgifex> > (\foo -> (foo / 2, typeOf foo)) 1
09:48:08 <lambdabot>  (0.5,Double)
09:48:08 <TheKing444> :t ?1/2
09:48:09 <lambdabot> parse error on input ‘?’
09:48:30 <trap_exit> i'm thinking of switching from haste to ghcjs
09:48:32 <trap_exit> how is ghcjs's gc ?
09:49:01 <TheKing444> does haste support profilling?
09:49:08 <TheKing444> or maybe there is a space leak
09:49:10 <trap_exit> no
09:49:12 <trap_exit> well, not afaik
09:49:16 <trap_exit> i'm just using chrome developer tools
09:49:31 <trap_exit> how would I detect the existence of a space leak?
09:49:41 <TheKing444> ah
09:49:42 <trap_exit> also, I don't think ther eis a space leak
09:49:45 <trap_exit> the chrome memory usage shows a zigsaw pattern
09:49:50 <TheKing444> oh
09:50:00 <TheKing444> I am wondering if haskell is calculating ahead.
09:50:01 <trap_exit> it goes from 18 MB up, to around 80MB, then suddenly drops to 18MB
09:50:19 <trap_exit> it appears as if haste is screwing up the javascript gc
09:50:20 <TheKing444> hmm
09:50:29 <TheKing444> 100 fps is pretty fast
09:50:35 <TheKing444> does it do the same at 1 fps?
09:51:32 <trap_exit> let me test at 1fps
09:51:55 <trap_exit> at 1fps, chrome takes up 20% of the cpu
09:52:15 <trap_exit> the memory usage goes from around 5MB to 60 MB in a zigsaw
09:52:15 <trap_exit> then drops
09:52:17 <trap_exit> then zigsaws up
09:53:47 <nibbledops> Hi, I have a test module and some CSV data I want to read from disk. I know the path to the data relative to the path to the module, how can I load it?
09:54:08 <nibbledops> Sorry, I mean, how do I compute the absolute path to the CSV file?
09:54:25 <danilo2> Hello! Would somebody be so nice and tell me why the following minimal example does not compile? Why the instance is not matched? http://lpaste.net/107348
09:54:30 <nibbledops> (i.e. how do I get the path to the current module?)
09:54:47 <corgifex> nibbledops: is it a cabal thingy or just a random source file?
09:55:14 <nibbledops> corgifex: just a random source file in my repo
09:55:51 <corgifex> best I can do is http://hackage.haskell.org/package/pseudomacros-0.0.1/docs/PseudoMacros.html
09:55:54 <TheKing444> wait, why a2?
09:56:01 <TheKing444> in PIPE, change a2 to a
09:56:19 <nibbledops> corgifex: cool, thanks!
09:56:26 <nibbledops> corgifex: exactly what I wanted :)
09:56:28 <danilo2> TheKing444: no, it should be a2
09:56:48 <nibbledops> corgifex: there's no better way to setting this up? How is this handled in a cabal installation?
09:56:49 <TheKing444> what is a2?
09:56:52 <danilo2> TheKing444: the first instance works (look, there is a2 too)
09:57:07 <TheKing444> oh it works
09:57:08 <TheKing444> okay
09:57:40 <danilo2> TheKing444: In the final example I would use GADTs (a~a2) , but it does nto matter for now
09:57:40 <geekosaur> danilo2: you want `c` to be inferred as `StateT Int`? I don't think that works
09:57:41 <corgifex> nibbledops: cabal knows where you're going to install and can bake the paths into a utility module
09:57:42 <TheKing444> perhaps add a monad constranit to c
09:57:50 <danilo2> geekosaur: why not? :(
09:57:55 <geekosaur> unless you tell it it has a kind other than *
09:58:05 <nibbledops> corgifex: ah I see, what is a keyword I can search for to read up on that?
09:58:12 <trap_exit> yo
09:58:13 <trap_exit> who here is using ghcjs?
09:58:18 <geekosaur> I suspect inferring kinds other than * is difficult
09:58:19 <trap_exit> what can you tell me about ghcjs's gc perormance
09:58:53 <TheKing444> FOUND ABSOLUTE PATH FUNCTION https://hackage.haskell.org/package/system-filepath-0.4.12/docs/Filesystem-Path.html
09:59:05 <TheKing444> wait, never mind
09:59:41 <danilo2> geekosaur, TheKing444, oh, adding constrain "MonadTrans c" solves the problem, but why? ghc can really easly infer this ...
09:59:59 <TheKing444> it can infer the kind than
10:00:04 <danilo2> geekosaur: I really do not understand it
10:00:16 <TheKing444> the problem is, it can't figure out that it is (*->*)
10:00:27 <TheKing444> it thinks it is 3 thingers
10:00:36 <TheKing444> or better yet
10:00:42 <danilo2> TheKing444: It can .... look, c m2 a2 is *, so c is * -> * -> *
10:00:51 <geekosaur> danilo2: might be best to think of it as a structural pattern match
10:00:52 <TheKing444> change (c m2 a2) to ((c m2) a2)
10:01:11 <geekosaur> a kind other than * changes the structure
10:01:41 <danilo2> geekosaur: TheKing444: ahhh! I know! look, GHC infers the tkind in wriong way, because it things that c is *->*->* and in reality c is (*-> (*->*)->*) !
10:01:43 <TheKing444> FOUND ABSOLUTE PATH FUNCTION https://www.fpcomplete.com/user/dshevchenko/cookbook/transform-relative-path-to-an-absolute-path
10:01:59 <danilo2> geekosaur: am I right?
10:02:03 <corgifex> nibbledops: http://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
10:03:02 <rwbarton> danilo2, yes
10:03:10 <danilo2> geekosaur, TheKing444: It seems it is the case, because adding premise (Monad m2) solves the problem as well :)
10:03:22 <danilo2> rwbarton: great, thank you! :)
10:03:22 <geekosaur> approximately, yes
10:03:26 <TheKing444> try kind signatures extension
10:03:35 <TheKing444> that way you don't need to restrict to monad
10:04:18 <danilo2> TheKing444: Of course - Now I know what is happening, I'm happy now! :D
10:04:41 <TheKing444> @lambdabot remember danilo I'm happy.
10:04:41 <lambdabot> Unknown command, try @list
10:04:47 <TheKing444> ah well
10:06:26 <nibbledops> corgifex: thanks a bunch!
10:06:43 <trap_exit_> does haskell have a builtin to check if two objects are _identical_ (i.e. ;oints to the same place) rather than if they're equal? here, identical implies equal; but equal does not necessairly imply identical
10:06:44 <shlevy> What's a good type for handling epoch time?
10:06:59 <shlevy> In seconds
10:07:09 <TheKing444> Integer
10:07:12 <TheKing444> I think
10:08:06 <ReinH> trap_exit: not afaik.
10:08:12 <corgifex> trap_exit_: haskell doesn't really have the concept of two objects
10:08:25 <corgifex> or one object
10:08:26 <TheKing444> wait no
10:08:36 <geekosaur> trap_exit_, "haskell" doesn't, ghc "does" but it's really unsafe (and named as such). what you are asking for violates haskell's rules
10:09:11 <TheKing444> shlevvy, look at https://hackage.haskell.org/package/time/docs/Data-Time-Clock-POSIX.html
10:09:56 <shlevy> TheKing444: thanks
10:10:08 <Julie21>  Here some videos. I hope you like them! http://bit.ly/U6GPFP
10:10:09 <shadowofq> Is there any prelude function transforming some of type a into () -> a?
10:10:18 <trap_exit_> geekosaur: because now I can pass haskell func two "objets" that "have the same value" ... but then get different results?
10:10:23 <corgifex> shadowofq: const?
10:10:30 <TheKing444> const
10:10:35 <TheKing444> shaowofq
10:10:40 <TheKing444> const does that
10:10:50 <TheKing444> :t const (a->(()->a))
10:10:51 <lambdabot>     Pattern syntax in expression context: a -> (() -> a)
10:11:01 <TheKing444> :t const ::(a->(()->a))
10:11:01 <lambdabot> a -> () -> a
10:11:05 <TheKing444> ta da
10:11:14 <geekosaur> trap_exit_, referential transparency. there is no visible difference between passing an "object" and an expression which evaluates to the same "object". iow there are no "objects" in the sense you think you mean
10:11:26 <trap_exit_> damn it
10:11:30 <geekosaur> haskell evaluation relies on this
10:11:35 <trap_exit_> is there no O(1) test forequality?
10:11:47 <TheKing444> for what type?
10:11:48 <josephle> geekosaur: can you not compare IORefs/STRefs for equality? Not that it's a good idea...
10:11:57 <trap_exit_> a complicated tree
10:12:00 <trap_exit_> I'm rewriitng facebok's react in haskell
10:12:04 <TheKing444> use IDs
10:12:07 <corgifex> trap_exit_: "objects" move around in memory
10:12:08 <trap_exit_> I want to have a O(1) time check of two trees are "identical"
10:12:09 <shlevy> trap_exit_: use identifiers
10:12:13 <trap_exit_> hmmm
10:12:13 <TheKing444> or hashes
10:12:18 <corgifex> trap_exit_: give them a unique ID
10:12:24 <TheKing444> yeah, hashes sounds good
10:12:26 <corgifex> oops, sorry
10:12:27 <TheKing444> O(1)
10:12:32 <trap_exit_> as in a shasum of the tree ?
10:12:42 <trap_exit_> err, subtree rooted at given node
10:13:01 <geekosaur> josephle, that's not really the same question. I can compare them but I can also compare with an expresson that produces an IORef or STRef --- trap_exit_ wants *that* comparison to *fail*
10:13:05 <shlevy> trap_exit_: haskell can (ghc does I think) use a compacting gc, so for unpinned memory addresses aren't appropriate
10:13:33 <trap_exit_> maybe I should do more profiling first
10:13:38 <trap_exit_> so I'm lookinag at chrome, web dev tools, and a cpu profile
10:13:43 <trap_exit_> 45% of my prog's time is spent in gc
10:13:53 <trap_exit_> and according to top, google chrome is consuming 99% on two cores
10:14:02 <trap_exit_> so something is screwed up with my haste -> js program right?
10:14:15 <josephle> geekosaur: that clears things up :)
10:14:34 <TheKing444> trap_exit_ can we see the program?
10:14:57 <trap_exit_> hmm
10:14:58 <trap_exit_> I need to check with higher ups
10:15:04 <trap_exit_> but I can see how that could be helpful
10:15:23 <TheKing444> all cool, comercial haste
10:15:28 <TheKing444> you will have to tell us how it goes
10:16:06 <mightybyte> Which does GHC do first, Template Haskell or CPP?
10:16:33 <trap_exit_> TheKing444: may quickly be ghcjs if this does not work well
10:16:51 <TheKing444> ah
10:18:01 <TheKing444> haste has its own web server ya know
10:18:40 <mightybyte> TheKing444: It does?  Where?
10:18:42 <bennofs> mightybyte: CPP I think, as that is like a "separate" stage
10:18:49 <TheKing444> Haste.App
10:18:53 <TheKing444> sort of web server
10:18:57 <TheKing444> only for a single page
10:19:10 <TheKing444> but it does allow javascript to communicate with a server
10:19:15 <TheKing444> so it says
10:19:22 <kludgy> Hi all, does anyone know if there is an idiomatic way to truncate one word type to another? (I'm looking for a trunc application like Word32 -> Maybe Word16)
10:19:34 <k_bx> Is there a lens facebook fan-page or something? Because whenever I do something like this https://gist.github.com/k-bx/37a0936937daae62d55b -- it's just fascinating.
10:19:38 <bennofs> kludgy: fromIntegral?
10:19:54 <TheKing444> mightybyte The server makes functions, that are passed to the javascript. Server and client are the same program.
10:19:56 <mightybyte> bennofs: Hmmm, that's what I thought.  But I have a TH function (kind of like makeLenses) surrounded with a #ifdef and it's causing problems.
10:20:04 <kludgy> bennofs: That is what I'm using, just seems to be a common pattern
10:20:08 <mightybyte> TheKing444: Ahh, I see.
10:20:39 <bennofs> k_bx: you could star the project on github (http://github.com/ekmett/lens) :)
10:22:42 <k_bx> bennofs: something more social and contemporary, more of this direction http://bodil.org/hipster/#/
10:25:47 <kludgy> bennofs: mayTruncWord32toWord16 :: Word32 -> Maybe Word16 mayTruncWord32toWord16 x = if y < y0 || y > y1 then Nothing else Just $ fromInteger y where (y,y0,y1) = (toInteger x, toInteger (minBound :: Word16), toInteger (maxBound :: Word16))
10:26:38 <trap_exit> is it possible in ahskell, to define a data type that is eeager by default?
10:26:47 <trap_exit> i.e. the wnf of the data type would also auto wnf all the args of the type
10:26:52 <corgifex> yes, with !
10:27:04 <trap_exit> corgifex: hmm, can you point me at documentation?
10:27:07 <trap_exit> I would like to read about this
10:27:08 <corgifex> data StrictPair a b = SP !a !b
10:27:21 <trap_exit> hmm, I like 1 line documentation
10:27:22 <trap_exit> you should write man pages
10:27:32 <biscarch> Is there anything like Persistent that supports Postgres json field types?
10:33:13 <Kron> cabal is telling me it can't find the module Control.Monad.Trans.Except
10:33:23 <Kron> I'm trying to upgrade lens
10:33:33 <Kron> I'm not sure how to fix this
10:36:17 <trap_exit> luite: yo
10:38:54 <carter> Kron: OH
10:39:00 <carter> what ghc version
10:39:16 <Kron> 7.8.2
10:39:26 <carter> cabal install transformers -fthree ; cabal install mtl-2.1.3.1
10:39:29 <carter> then it'll wokr
10:39:35 <Kron> -fthree?
10:39:38 <zereraz> hello everyone, quick question, if the ':' key is broken can we do pattern matching without :
10:39:40 <carter> literally the words I say
10:40:06 <donri> zereraz: viewpatterns and uncons? :P
10:40:07 <corgifex> zereraz: yes, you can copy/paste a : with the mouse
10:40:23 <Kron> carter: still doesn't work
10:40:24 <zereraz> corgifex: nice, but without that character
10:40:32 <Kron> those packages were already installed too
10:40:37 <zereraz> donri: what is that
10:40:44 <carter> @lpaste the error messages or i can't help you
10:40:44 <lambdabot> Haskell pastebin: http://lpaste.net/
10:40:49 <donri> @hoogle uncons
10:40:50 <lambdabot> Data.ByteString.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
10:40:51 <lambdabot> Data.ByteString.Lazy.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
10:40:51 <lambdabot> Data.ByteString uncons :: ByteString -> Maybe (Word8, ByteString)
10:41:00 <donri> well ok find one for lists :P
10:41:05 <Kron> http://lpaste.net/107354
10:41:16 <Kron> was already on the way to lpasting it
10:41:18 <carter> Kron: rm ~/.ghc
10:41:23 <Kron> oh dear
10:41:23 <carter> and then do my above directions
10:41:24 <Kron> hah
10:41:25 <Kron> okay
10:41:27 <carter> then cabal install lens
10:42:01 <Kron> can you explain what your steps are though?
10:42:06 <carter> yes
10:42:37 <carter> rm ~/.ghc ; cabal update  ; cabal install transformers-compat -fthree ; cabal install mtl-2.1.3.1 ; cabal install lens
10:42:42 <carter> that will wokr
10:42:44 <Kron> no I mean
10:42:46 <Kron> what do they /do/
10:42:51 <Kron> what does "-fthree" do?
10:42:59 <carter> transfomers 3 man
10:43:03 <int-e> @type liftM2 (>>) (guard . not . null) (return . (head &&& tail))
10:43:03 <lambdabot> MonadPlus m => [c] -> m (c, [c])
10:43:08 <Kron> why must I manually install transformers and mtl
10:43:12 <carter> no
10:43:19 <Kron> I was assuming it would handle it itself
10:44:11 <carter> GHC comes with transformers 3
10:44:15 <maybefbi> any libraries that can generate Haskell AST? im thinking of writing a refactoring tool if it doesn't exist already.
10:44:23 <carter> but cabal trys to install 4
10:44:25 <carter> and then things get weird
10:44:29 <carter> because breaking changes and stuff
10:44:38 <Kron> alright
10:44:46 <carter> Kron: try my directions, feel free to write up an explantion i can use
10:44:57 <carter> ive enough stuff i'm juggling that thats not a priority
10:45:10 <dp_wiz_> Is there a something like kickstarter where people can to put a bounty on some stuff to be written and opensourced?
10:45:11 <Kron> thanks for your assistance
10:45:35 <carter> dp_wiz_: its called paying people :)
10:46:08 <geekosaur> maybefbi: might want to look at HaRe, which was moribund for a while but seems to be returning to life
10:46:22 <maybefbi> geekosaur, thanks
10:46:31 <dp_wiz_> carter: yep. that's what i want to do. Just can't find a place appropriate to post such bounties.
10:46:46 <carter> theres 2-3 things
10:46:53 <carter> but i've not seen any have serious usage
10:47:43 <Ankhers> Could someone offer suggestions to a very fast XML parser?
10:47:44 <donri> bountysource
10:48:08 <donri> Ankhers: hexpat
10:48:09 <carter> Ankhers: how fast?
10:49:01 <Ankhers> Preferably as fast as possible.
10:49:15 <Ankhers> Is hexpat still the fastest?
10:49:20 <donri> xml-conduit isn't much slower and uses xml-types though
10:49:50 <Ankhers> Is it any easier to convert XML to / from native types?
10:50:02 <donri> dp_wiz_: https://www.bountysource.com/
10:50:31 <donri> Ankhers: i like xml-picklers for that
10:51:00 <dp_wiz_> donri: thanks!
10:51:06 <Ankhers> Is it still fast?
10:51:24 <Ankhers> comparable to hexpat and xml-conduit?
10:52:30 <donri> xml-picklers uses xml-types so it works with xml-conduit
10:53:21 <donri> when i tried them xml-picklers with conduit was comparable to hexpat-pickle, but i didn't do any serious benchmarks
10:53:49 <donri> hexpat was a bit faster though
10:54:39 <Ankhers> donri: Thanks. I will take a look at both and see which works better for me.
10:55:20 <Qfwfq> Ankhers: We just released 'taggy' and 'taggy-lens', they beat everything but but in our benchmarks, speed-wise.
10:55:29 <Qfwfq> Everything but hexpat.
10:56:21 <Ankhers> Qfwfq: I will look into that as well. Thanks.
10:56:26 <Qfwfq> <3
10:56:33 <shadowofq> I am getting warning with literal string and print using -Wall. Is there anyway to get rid of it?
10:56:37 <shadowofq> Like print "foo"
10:56:57 <donri> shadowofq: sure you want print for that?
10:57:08 <donri> it will run show on the string
10:57:17 <donri> @src print
10:57:17 <lambdabot> print x = putStrLn (show x)
10:57:30 <donri> > show "foo"
10:57:31 <lambdabot>  "\"foo\""
10:57:33 <shadowofq> ah yes
10:57:34 <shadowofq> ok
10:57:36 <zwer> it will print the string with quotes.
10:57:37 <shadowofq> it makes sense
10:57:51 <zwer> which may or may not be what you want.. i am surprised that is a warning
10:58:19 <donri> only warning with string literal, i imagine
10:58:26 <rwbarton_> the warning is because you have OverloadedStrings on
10:58:42 <rwbarton_> at least I can't imagine any other reason
10:58:45 <shadowofq> yes
10:58:49 <shadowofq> you are right
10:58:56 <donri> what was the warning anyway
10:59:08 <shadowofq> I have another warning related question
10:59:11 <shadowofq> I am using aeson
10:59:15 <shadowofq> with GHC generic
10:59:37 <shadowofq> and I got warning with unused field from records I declare and use with aeson unparsing functions
10:59:45 <shadowofq> -Wall
11:00:13 <shadowofq> data Test = Test { name :: String, result :: String, options :: String } deriving (Show, Generic)
11:00:15 <shadowofq> for example
11:01:02 <shadowofq> I am a newb but I guess generic machinery uses field name to generate the FromJson / ToJson
11:01:11 <shadowofq> But I do not use this field in my program
11:01:14 <shadowofq> any of them
11:01:39 <shadowofq> Am I doing anything wrong here?
11:02:06 <shadowofq> Or can I pragma push/pop warning if it is possible?
11:02:28 <shadowofq> (the way we can do it with clang or msvc)
11:02:37 <bennofs1> shadowofq: you can disable warnings on a per-file basis only
11:03:16 <shadowofq> bennofs1: damn. Do you think it is a bug?
11:03:55 <bennofs1> shadowofq: You can disable a specfic warning for a module by putting {-# OPTIONS_GHC -fno-warn-unused-binds #-} at the very top of the file
11:04:21 <trap_exit> https://gist.github.com/anonymous/cb1a7725218e0ae7a546 <- what does this mean? trying to install ghcjs, using ghc-7.8.3
11:04:25 <trap_exit> luite: ^^
11:04:39 <bennofs1> shadowofq: yeah, it would be nice if you could disable / enable warnings for just some part of a file
11:05:25 <shadowofq> bennofs1: ok! I am wondering if this is a compiler bug this warning (I mean this may be a spurious warning) due to uses of the fields not considered when used in generics machinery
11:05:47 <rwbarton_> does ghcjs depend on transformers-0.4.1.0 specifically?
11:06:22 <trap_exit> rwbarton_ : I have no idea
11:06:39 <trap_exit> rwbarton_ : can you recommend a list of commands to type into a console ?
11:06:51 <trap_exit> perferably comands that do not involve rm, -rf, /, or dd
11:06:51 <shadowofq> bennofs: I am running 7.6.3. I will try on latest at home. Maybe it is different
11:07:03 <rwbarton_> well, rm -rf ~/.ghc is one approach
11:07:08 <rwbarton_> or try a sandbox
11:07:28 <rwbarton_> you need to build against transformers-0.3.0.0
11:07:35 <trap_exit> rm -rf ~/.ghc .... hmm
11:07:36 <trap_exit> retrying
11:08:01 <bennofs> shadowofq: hmm, right, I don't think GHC currently considers fields used in Generics. It would be very hard to detect such an usage for GHC
11:08:31 <trap_exit> rwbarton_ : hmm, I'm getting further along ; this might have fixed it for some weird reason
11:09:08 <shadowofq> bennofs: ok. I will go with the per-file solution
11:09:14 <rwbarton> what's weird is that it seems to not try transformers-0.3.0.0 at all
11:09:22 <rwbarton> in your paste
11:09:43 <rwbarton> in general upgrading packages that come with ghc (like transformers) is a bad idea
11:10:00 <trap_exit> rwbarton: i hvae a weird setup
11:10:03 <trap_exit> i'm on ubuntu 14
11:10:09 <trap_exit> had to remove ghc 7.6.3
11:10:12 <trap_exit> then installed 7.8.3 via a binary
11:10:14 * hackagebot pipes-zlib 0.4.0.1 - Zlib compression and decompression for Pipes streams  http://hackage.haskell.org/package/pipes-zlib-0.4.0.1 (RenzoCarbonara)
11:12:03 <luite> trap_exit: yeah more people get bitten by that unfortunately :(
11:12:35 <rwbarton> trap_exit: it's probably because of something unrelated you installed that made cabal decide to upgrade transformers
11:12:39 <luite> trap_exit: i'm not sure why it doesn't try 0.3.0.0, even with max-backjumps=-1 it can't always solve the deps
11:13:04 <luite> trap_exit: perhaps it's because packages would be reinstalled with a 0.3.0.0 dep, breaking others
11:13:05 <trap_exit> asd
11:13:21 <kqr1> i want to perform a bunch of I/O actions in turn. however, depending on the result of those, i might want to throw an error and not continue with the rest of the I/O actions. how do i best do this in Haskell? i was looking at EitherT String IO a, but i'm not sure if i'm looking in the right place
11:13:47 <luite> trap_exit: anyway adding --constraint=transformers==0.3.0.0 should fix it
11:13:55 <mmachenry> Hello. I am running a simple program on my ghc 7.6.3 and I get "/usr/hs/ghc/7.6.3/bin/runhaskell failure (return code=2)" on my company's Linux machine but a clean exit from control-C on my Mac.
11:14:08 <mmachenry> Does anyone else know what causes this error. I am having trouble googling for it.
11:14:11 <rwbarton> unless the unrelated package was also related to a dependency of ghcjs
11:14:27 <luite> trap_exit: i'm thinking of adding an if impl(ghc == 7.8.3) build-dependencies: transformers == 0.3.0.0
11:14:35 <mmachenry> The programming I'm running is: main = forever $ putStrLn "Hello, World!"
11:14:37 <trap_exit> luite , rwbarton : hmm, it's allready appearing to install fine after rm -rf ~/.ghc
11:14:42 <trap_exit> is there any danger in letting it finish ?
11:14:53 <rwbarton> no
11:14:57 <rwbarton> the only danger was in rm -rf ~/.ghc :)
11:15:16 <ZioCrocifisso> is it possible to use an argument (that is an ADT) of a function in the type signature of another argument, that accepts a type of the same ADT promoted to a kind?
11:15:37 <ZioCrocifisso> (f :: a -> t a)
11:15:40 <luite> trap_exit: but i'm not sure if that's a right thing to do, i'd like to avoid having version-specific assumptions like this. someone might have a custom 7.8.3 setup with a different transformers lib for example
11:15:53 <luite> trap_exit: should be fine
11:17:20 <RyanGlScott> If you run autoconf from cabal install, is there a way to control autoconf's verbosity?
11:17:22 <trap_exit> luite: at the moment, I'm selfish
11:17:31 <trap_exit> luite: we can worry about everyone else, after ghcjs installs for me :-)
11:17:39 <luite> trap_exit: hehe fine :p
11:17:57 <luite> trap_exit: but i'm trying to get the issues sorted out for everyone before i upload it to github
11:18:06 <trap_exit> luite: since you're here ... what is your take on how haste / ghcjs differ? I've found suprisingly little documentation on it
11:18:09 <trap_exit> luite: oh, I do have a suggestion for github
11:18:17 <luite> so ghcjs doesn't get blamed for being horrible to install and causing cabal hell etc
11:18:39 <luite> it already was two days ago on reddit, and it's not even released yet :(
11:18:40 <rwbarton> the right thing to do is for people to not be in this situation in the first place
11:18:51 <trap_exit> luite: in https://github.com/ghcjs/ghcjs/blob/master/README.markdown ... I recommend a header after the "window" section, that says "Both"
11:19:12 <trap_exit> luite: the first time I read https://github.com/ghcjs/ghcjs/blob/master/README.markdown ... I wasn't sure where the "Window" section ended and where the "for both Windows and Linux" starrted
11:19:29 <trap_exit> luite: I thikn a single header between the end of the Windows section and the start of "run the folowing script" ... would be enlightening
11:20:26 <luite> trap_exit: hmm, 'Both' sounds like the wrong title, i guess it should be a new paragraph
11:20:46 <luite> so it should have a proper paragraph title
11:20:55 <trap_exit> luite: yes, agreed "Both" is not accurate, though tsomething to indicate "the windows specific part ends, you should type in these commands" would be nice
11:21:05 <trap_exit> even a "<hr>" would ahve made it easier to figure out :-)
11:21:22 <trap_exit> anyway, that's minor
11:21:34 <trap_exit> major question is: how do you view how haste / ghcjs differs ?
11:21:45 <trap_exit> besides ghcjs supporting extensions like template haskell
11:22:31 <Kron> is there a word for functions that return the original input when used twice on the input?
11:22:40 <Kron> f . f = id
11:22:40 <luite> trap_exit: the main difference is in how closures are compiled to javascript
11:22:58 <rwbarton> Kron, involution
11:23:02 <Kron> thanks!
11:23:08 <trap_exit> luite: hmm, I was having gc problems with haste. this sounds like it's important since thunks -> closures; and laziness -> thunks
11:23:13 <trap_exit> luite: where can I read up more on this?
11:23:13 <luite> trap_exit: haste and fay compile haskell closures to javascript closures, using the javascript engine to handle the contexts
11:23:36 <trap_exit> this basically means lots of closures right?
11:23:37 <luite> trap_exit: ghcjs uses its own flat closures to avoid memory leaks, there are several things that are very hard to handle with the fay/haste compilation model
11:23:42 <trap_exit> since a haskell lazy list -> n closures
11:25:58 <luite> trap_exit: unfortunately that means that managing closures requires more code. GHCJS needs to do much more work to make the code smaller because of that. also haste/fay use their own version of libs, which makes it easier for them to shed dependencies
11:26:50 <trap_exit> luite: yes, Haste.Concurrent vs haskells's standard Concurernt.MVar
11:27:03 <trap_exit> ghcjs still compiling
11:28:07 <luite> trap_exit: GHCJS still has lots of closures, it does strain memory management on JS engines (Firefox is doing poorly since they have non-generational gc, in version 32 or so their new gc should be activated)
11:28:31 <luite> since it's hard to get around high allocation rates with immutable data
11:28:47 <luite> unless you find a completely new way to translate the code
11:29:22 <trap_exit> like stream fusion?
11:30:07 <luite> trap_exit: well that avoids some intermediate allocation but only in specific places
11:31:22 <kqr> okay never mind, i think i figured out how EitherT works... wonderfully!
11:31:44 <trap_exit> it's amazing the pain people will tolerate
11:31:47 <trap_exit> to avoid writing JS
11:32:09 <trap_exit> luite: will ghcjs output asm.js / native client some day?
11:32:18 <luite> trap_exit: I mean something more general where instead of allocation lots of immutables on a global nursery you have lots of little regions that can be dropped independently, or a way to statically determine when objects become unused, so newly allocated objects can overwrite them
11:33:01 <luite> trap_exit: but that would require a whole new front end or at least analysis pass
11:33:42 <luite> trap_exit: currently the only optimization that GHC does is LetNoEscape, which avoids allocating closures for a particular call pattern
11:34:20 <luite> (other than the front end optimizations like worker/wrapper that unbox parts of computations of course)
11:37:26 <luite> trap_exit: NaCl / PNaCl is probably outside the scope of the project currently, since it would use a different part of the GHC pipeline. It would basically need to use StgCmm and LLVM for some particular platform, plus some glue to make `foreign import javascript' work
11:37:53 <trap_exit> luite: understood ... still compiling :-)
11:38:09 <trap_exit> luite: you know what would really help ghcjs adoption? "apt-get install ghcjs" or a docker image :-)
11:38:12 <luite> trap_exit: asm.js is somewhat tricky
11:38:17 <mzero> NaCl / PNaCl would require a re-write of GHC’s event system: They don’t provide any form of epoll/kpoll or even select!
11:38:32 <trap_exit> luite: yeah, I looked at asm.js
11:38:39 <trap_exit> luite: generating those code looks intense
11:39:12 <luite> trap_exit: since you can't do any dynamic allocation it would either porting the GHC GC to JS or only running parts of the code with bounded allocation in asm.js
11:39:33 <luite> trap_exit: I'll be looking into the latter at some point
11:40:04 <luite> if you have a recursive binding group that's completely unboxed, only using the stack, then that can be converted to asm.js, using a fixed length stack in there
11:40:28 <luite> and bailing out to normal code when it uses up its stack
11:40:51 <luite> that should make some numerical work very much faster on JS
11:40:51 <rwbarton> I was just wondering if managing, say, the nursery explicitly inside a js byte array would be feasible
11:42:29 <rwbarton> I guess you need Haskell heap -> JS heap references though?
11:43:48 <luite> rwbarton: yep can be done, would make heap access a bit more complicated though. you'd need to do a reachability test when you run out of nursery, so update frames, mutable arrays, mvars and iorefs needs to be one a mutable list when written to
11:44:02 <isomorph1ous> Hey, y'all
11:44:21 <isomorph1ous> Would one of you mind taking a look at my library before I publish it?
11:44:24 <isomorph1ous> https://github.com/pharpend/tropical
11:44:46 <int3__> suppose I had a `Tree a = Leaf a | Node (Tree a) Int (Tree a)` and I wanted to replace each Int by the sum of the Ints from the root to the current node... how might I express this as a fold?
11:44:51 <luite> rwbarton: another option is a bunch of preallocated heap objects of various sizes, just writing to those instead of allocating a new one
11:45:00 <trap_exit> luite: Loading package network-2.5.0.0 ... linking ... done. Loading package HTTP-4000.2.17 ... linking ... done.
11:45:05 <trap_exit> appears to be frozen here
11:45:08 <trap_exit> should I ctrl-C i t?
11:45:22 <trap_exit> oh n/m, it made progress
11:45:24 <int3__> I know I'd use foldl if I were doing the same thing for a list, but I'm not sure how to generalize foldl to a Tree
11:45:28 <trap_exit> Linking dist/build/ghcjs-boot/ghcjs-boot ... Preprocessing executable 'ghcjs-run' for ghcjs-0.1.0...
11:45:30 <trap_exit> damn, more waiting :-)
11:46:01 <luite> ghcjs-run is small, it's a runner wrapper that makes it possible to run Setup.hs through node.js
11:46:04 <luite> :)
11:46:33 <int3__> ah... I suppose the type should really be `Tree a = Leaf a | Node (Tree a) a (Tree a)`
11:46:39 <luite> cabal compiles Setup.hs to JS, but then it needs to run the script in some way :)
11:46:54 <trap_exit> omg "cabal istall ./ghcjs" succeeded
11:46:58 <trap_exit> I should go sacrifice some chickens
11:47:00 <trap_exit> brb
11:47:25 <dcoutts> luite: fyi, I had no trouble installing ghcjs. Your instructions are good :-)
11:47:43 <trap_exit> x@server:~/build$ ghcjs-boot --dev fatal: program node is required but could not be found at node
11:47:45 <trap_exit> what does this mean ?
11:47:55 <trap_exit> dcoutts: what linux distro did you use?
11:48:02 <dcoutts> trap_exit: you need node.js installed
11:48:04 <benzrf> why use ghcjs when PS exists
11:48:05 <benzrf> :-)
11:48:15 <dcoutts> trap_exit: fedora
11:48:30 <dcoutts> trap_exit: but I don't think there's anything special there
11:48:46 <luite> dcoutts: great, I probably have broken lots of stuff last week though, since i changed the whole default setup, and there were still some issues compiling the Cabal lib to JS
11:49:02 <dcoutts> luite: I did it a couple days ago
11:49:11 <dcoutts> from the git version
11:49:39 <luite> dcoutts: ok, i did fix some issues yesterday
11:50:03 <thoughtpolice> dcoutts: I thought you were using Debian?
11:50:32 <dcoutts> thoughtpolice: my laptop is running a very old version of ubuntu, and my desktop is running latest fedora
11:50:37 <luite> dcoutts: one cool thing is that with the small change i made to the filepath package, it's possible to compile cabal-install to js, and it handles windows paths on windows, posix paths elsewhere
11:50:43 * dcoutts stopped running gentoo some years ago
11:50:54 <dcoutts> luite: :-)
11:51:18 <trap_exit> fatal: minimum required version for node.js is 0.10.28, found: v0.10.25
11:51:21 <trap_exit> damn it, ubuntu sucks
11:51:23 <int3__> oh, I figured out my own question. I'll write it as an unfold.
11:51:30 <dcoutts> luite: btw, it'd be useful if the ghcjs site linked to your old blog post which explains how to get JS to call Haskell functions.
11:52:06 <dcoutts> luite: I didn't find that documented anywhere else. The other things one is pointed to is the webkit thing, which wasn't what I was after.
11:52:21 <thoughtpolice> dcoutts: luite - i'd honestly show an example of that straight up after the installation instructions, easy as possible
11:52:35 <thoughtpolice> move the hacking/debugging stuff to a HACKING.md, link prominently in BOLD TEXT from main README
11:52:50 <luite> rwbarton: anyway my plan is to talk about memory management issues when compiling to JS at the haskell implementors workshop, and hopefully get some good discussion there
11:54:09 <shlevy> What library should I use for cryptographic hashing?
11:54:21 <shlevy> Specifically md5, sha1, sha256
11:54:51 <luite> rwbarton: since there are more issues (let floating and CAF reachability, weak refs, selector thunks), that are all somewhat tricky to get right. GHCJS scans the whole heap currently for some of the functionality, but since there's already the JS memory manager it should be possible to reduce the amount of manual work
11:55:23 * hackagebot tropical 0.0.0.0 - A library for tropical mathematics.  http://hackage.haskell.org/package/tropical-0.0.0.0 (pharpend)
11:55:32 <luite> rwbarton: and fay and haste make no attempt to solve this
11:55:51 <luite> dcoutts: ah it's mostly because i don't really have a good official story for that
11:56:13 <dcoutts> luite: you've got those sync and async run functions, what's wrong?
11:56:54 <luite> dcoutts: do you mean the h$run method or the syncCallback way?
11:57:06 <dcoutts> h$run
11:58:42 <luite> dcoutts: ah well, the problem there is how do you get the required symbol to be linked? making main depend on it works, but is not really ideal if you compile a library to JS
11:59:18 <dcoutts> luite: oh, can't I use it to call library functions?
11:59:36 * dcoutts needs to call a few Haskell functions from a html page
11:59:48 <thoughtpolice> shlevy: the SHA library is what you want for SHA1/256
12:00:12 <shlevy> thoughtpolice: I found cryptohash
12:00:17 <shlevy> checking out SHA now
12:00:23 <thoughtpolice> oh, that works too, probably faster even :)
12:00:26 <thoughtpolice> since it binds out to C instead
12:00:41 <luite> dcoutts: and a secondary issue is that if you h$run something that references CAFs that were not referenced by anything else in the runtime, then those CAFs might have been deallocated, causing some recomputation, and that breaks a toplevel unsafePerformIO hack
12:01:01 <shlevy> thoughtpolice: Yeah and I need md5 too
12:01:17 <thoughtpolice> there's also pureMD5, but yes, cryptohash is probably better
12:01:29 <luite> dcoutts: could be handled by adding some logic to the nodup primop, but it's probably better to generate proper wrappers for the haskell lib functions
12:01:34 <dcoutts> luite: ok, no probs with that one.
12:01:41 <dcoutts> luite: foreign export :-)
12:01:45 <rwbarton> also cryptohash probably doesn't take 15 minutes to build
12:02:03 <dcoutts> luite: maybe we should take this to #ghc, I've got a couple Qs
12:02:05 <luite> dcoutts: yes foreign export is partially implemented
12:02:21 <thoughtpolice> rwbarton: yes that too
12:02:24 <thoughtpolice> i forgot about that bug :)
12:02:33 <luite> dcoutts: but the linker doesn't quite know what to do with them yet
12:02:34 <luite> dcoutts: ok
12:03:36 <luite> trap_exit: anyway, my priority is getting things released and working correctly first (next few weeks), then before ICFP i hope to have a new optimizer ready with a typed intermediate representation, and a two-stage codegen that defers cps transformation
12:03:59 <luite> trap_exit: when that's done we have some good tools to attack code size
12:04:00 <trap_exit> luite: hmm, I approve of your plan, you have my permission to go ahead :-)
12:04:26 <luite> so i'm letting the code be big for now, hoping that it won't scare away too many potential users
12:07:43 <kludgy> IS this a thing? (foldr mappend mempty)
12:08:30 <ReinH> kludgy: fold
12:08:39 <ReinH> or mconcat
12:09:09 <shlevy> Is there a Read/Show equivalent for Text?
12:09:46 <Clint> shlevy: Data.Text.Read may or may not be half of what you mean
12:09:52 <shlevy> Thanks
12:15:52 <kludgy> ReinH: thanks!
12:19:04 <luite> thoughtpolice: good point, i'll add an example when there is a userfriendly way to do it :)
12:21:31 <shlevy> Is there a ByteString -> Maybe ByteString that converts hex to binary?
12:22:17 <shlevy> Ah found Data.ByteString.Base16
12:30:45 <luite> trap_exit: oh btw, profiling support is also being added soon, you should be able to investigate memory leaks based on their cost centres / modules within ~2 months
12:30:57 <trap_exit> luite: btw, ghcboot --dev just finished
12:31:04 <trap_exit> about to test the minimal examples
12:32:23 <trap_exit> fuck
12:32:29 <trap_exit> s/f.ck/fsck/
12:32:37 <trap_exit> cannot find `/home/x/.ghcjs/x86_64-linux-0.1.0-7.8.3/ghcjs/ghcjs_boot.completed'  please install the GHCJS boot libraries or edit the `ghcjs' wrapper script to point to the correct library location
12:32:41 <trap_exit> I scewd up some installation apaprently hmm
12:33:02 <trap_exit> oh, I did not install alex
12:33:06 <luite> trap_exit: it should've printed an installation summary at the end
12:34:14 <luite> trap_exit: ah yeah you need alex for a development boot. it's listed as an optional program in ghcjs-boot since it's only required for a --dev boot if the parser for genprimopcode has not been generated yet
12:34:38 <luite> trap_exit: so it fails when the program is run, instead of during the early check
12:34:56 <trap_exit> luite: if it's this hard to install, it must have been insane to develop
12:35:04 <trap_exit> you should write blog posts about the black magic you had to pull to make ghcjs work
12:35:29 * hackagebot haste-perch 0.1.0.1 - Create dynamic HTML in the browser using declarative notation  http://hackage.haskell.org/package/haste-perch-0.1.0.1 (AlbertoCorona)
12:36:09 <luite> trap_exit: not much black magic, but unfortunatly i've had to spend lots of time on installation issues
12:36:21 <luite> and i like working on the code generator/optimizer much better :)
12:36:53 <trap_exit> someone needs to start a service, say docker-harbor
12:37:04 <trap_exit> where there's auto builds on popular linux distros
12:37:15 <trap_exit> otherwise, it's impossible trying to write a single system that builds on a varitety of platforms
12:37:27 <luite> trap_exit: but the upshot is that when all is done, it should have proper Cabal integration and work with the existing libraries ecosystem
12:38:41 <luite> trap_exit: a non-dev version should just install with `cabal install ghcjs && ghcjs-boot`, as long as you have happy and node.js installed
12:39:10 <luite> trap_exit: oh and the updated Cabal
12:40:19 <trap_exit> luite: gtg (real life calling)
12:40:22 <trap_exit> luite: thanks for all your help today!
12:40:34 <luite> trap_exit: k, join #ghcjs if you run into more trouble
13:03:44 * sinformer Free OpenVPN service - http://vpn.scay.net/ - Protect your WIFI
13:08:49 <ReinH> such netsplits wow
13:09:01 <stolaruk> Does MVar stand for Mutable Variable?
13:14:39 <ReinH> stolaruk: they come from m-structures in the Id language...
13:14:42 <ReinH> iirc
13:17:26 <solidus-river> holy crap.. how does javascript this is ok
13:17:29 <ReinH> I think I and M do stand for immutable and mutable but I can't find a source.
13:17:34 <solidus-river> function (args, cb)
13:17:44 <solidus-river> all that tells me is that the function takes arguments, and a callback
13:18:02 <ReinH> stolaruk: I-structures and M-structures were introduced in http://www.cse.chalmers.se/edu/course/pfp/Papers/IStructures.pdf but afaik the I and A weren't explained :/
13:18:26 <stolaruk> ok np thx
13:26:54 <sclv> yes, I stands for immutable, and M stand for mutable afaik
13:27:03 <sclv> there were prior papers on the language that spelled that out i believe
13:31:34 <ReinH> sclv: It's amazing that hypermedia documents exist and we still use PDFs without hyperlinks for papers.
13:31:48 <ReinH> I have an intense dislike for the academic publishing industry :/
13:32:15 <companion_cube> who writes papers without hyperlinks?!
13:32:15 <sclv> the problem is with tex and the lack of good shared knowledge about how to do tex write
13:32:19 <sclv> right even
13:32:25 <ReinH> companion_cube: in the bibliography? Everyone?
13:32:40 <ReinH> sclv: that and actual access to the papers they would want to link to
13:32:47 <sclv> haha true
13:33:08 <sclv> with old papers its worse tho, because they were done before internet/preprint culture were widespread
13:33:32 <ReinH> Right, finding a canonical URL is problematic as well, even for newer papers
13:33:52 <ReinH> but these aren't unsolvable problems, we just have a publishing industry incentivized that is against solving them.
13:34:09 <ReinH> swapped a word there, woops
13:34:23 <ReinH> Yoda I talk like.
13:35:59 <yorick> .seen jekor
13:36:35 <companion_cube> ah, bibliography
13:37:06 <companion_cube> yes of course, easy access (with a public url) to papers isn't what springer and Elsevier wish
13:38:53 <yorick> @seen jekor
13:38:53 <lambdabot> jEK0R
13:38:55 <ReinH> companion_cube: yep
13:38:57 <yorick> thx lambdabot
13:39:12 <yorick> not helpful, how do I do that?
13:39:17 <ReinH> yorick: lambdabot doesn't have a seen, and I don't think he's in here very often at all
13:39:29 <ReinH> yorick: I can pass along a message for you though
13:39:32 <yorick> bah
13:39:50 <yorick> ReinH: no, I've emailed him, just wondered if he was on irc
13:39:54 <ReinH> He's @jekor on twitter if you twitter. Ah ok cool.
13:43:55 <Trubydoor> I've started to get a weird error running certain haskell binaries on Arch Linux, does anyone have any idea why? Error is: <command line>: can't load .so/.DLL for: /usr/lib/libcurses.so (-lncursesw: cannot open shared object file: No such file or directory)
13:44:12 <yorick> Trubydoor: sudo pacman -S ncurses
13:44:30 <Trubydoor> yeah ncurses is installed and that file is there
13:45:25 <yorick> weird. are you sure?
13:45:36 <Trubydoor> ls -l /usr/lib/libncurses.so
13:45:36 <Trubydoor> -rw-r--r-- 1 root root 18 Oct 20  2013 /usr/lib/libncurses.so
13:46:00 <yorick> do you have libncursesw.so in that same dir?
13:46:06 <Trubydoor> yep
13:46:20 <yorick> I give up, no idea
13:46:56 <Trubydoor> yeah, it's been bugging me for a while. I'm trying to work on something with the llvm-general module but I can't import it because I get that error
13:47:03 <Trubydoor> and also ghc-mod won't run either
13:47:12 <yorick> maybe try #archlinux too
13:47:28 <Trubydoor> yeah might do
13:47:29 <Trubydoor> http://hastebin.com/meyetuwifi.txt
13:47:39 <Trubydoor> all the files are there... why can't it find it?! grr
13:48:06 <yorick> maybe your filesystem is not mounted?
13:48:20 <yorick> (yeah, no.)
13:48:25 <Trubydoor> well I can run mc and other programs that use curses so I assume it is actually available..
13:49:29 <ski> stolaruk,ReinH,sclv : <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.2945>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.4920>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.59.5638>,<http://www.lcs.mit.edu/publications/pubs/ps/MIT-LCS-TM-284-2.ps.gz>,<http://www.lcs.mit.edu/publications/pubs/ps/MIT-LCS-TM-294.ps.gz>,<http://csg.csail.mit.edu/pubs/memos/Memo-284/memo-284-2.pdf>
13:50:03 <sclv> ski++
13:50:34 <ReinH> ski: <3
13:50:38 <ReinH> dem sources
13:53:06 <stolaruk> much link
13:57:41 <parc> is there something wrong with this code (using type families)?: type family Map (f :: * -> *) (xs :: *); type instance Map f (x,y) = (f x, Map f y); type instance Map () = (). i get a ghc panic error message
14:01:19 <glguy> parc: Did you mean " type instance Map f (x,y) = (Map f x, Map f y) ?
14:01:56 <glguy> parc: Also, Your last instance doesn't have the right number of arguments
14:02:13 <glguy> Oh, nevermind, I see, I was thinking of the wrong map :)
14:02:20 <glguy> Not the data structure :)
14:02:21 <parc> glguy: err: i meant: type instance Map f () = ()
14:02:48 <hexagoxel> @tell Trubydoor well what about /usr/lib/libcurses.so ? you only listed ncurses stuff.
14:02:48 <lambdabot> Consider it noted.
14:02:55 <parc> glguy: and yeah, i'm basically using a tuple as a type-level linked list, so the recursion is only in the tail
14:03:36 <parc> glguy: i want to map another type family over the list, so i end up with a new list of types, of equal length to the previous list
14:08:40 <Meg21>  You can find funny videos here. http://j.mp/1y56Kga
14:09:08 <hexagoxel> parc: just those definitions compile fine here.
14:09:08 --- mode: ChanServ set +o glguy
14:09:17 --- mode: glguy set +b *!*@37.221.169.150
14:09:24 --- kick: Meg21 was kicked by glguy (Your behavior is not conducive to the desired environment.)
14:09:43 <parc> hmm. good to know it's on just on my side then. what version of ghc are you using?
14:09:54 <parc> hexagoxel: ^
14:10:35 <hexagoxel> parc: 7.8.2
14:10:55 <glguy> Oh, old GHC ;-)
14:10:59 <hexagoxel> :D
14:11:13 <parc> hexagoxel: i'm on 7.6.3, so that's probably it :(
14:15:00 <hexagoxel> parc: hmm i just tried 7.6.3, and it works (?)
14:16:31 <parc> hexagoxel: blah. well i've been meaning to reformat lately, so i guess i'll see if there's any difference after doing that
14:16:41 <rwbarton> dtruby: see https://ghc.haskell.org/trac/ghc/ticket/9237
14:21:27 <kini> it's really annoying that whenever I google a module name, more often than not the top hit is to the documentation from some *old* version of a package on hackage, rather than the latest version
14:21:35 <kini> or some *old* version of the GHC manual, as opposed to the latest version
14:21:41 <kini> what can we do about this?
14:22:03 <dtruby> rwbarton: if I do that then the programs start segfaulting :-\
14:22:32 <glguy> redirect requests with google as the referrer to the current version? ;-)
14:22:41 <silasm> kini: hoogle it instead?
14:22:56 <rwbarton> dtruby: how odd! what did you do exactly?
14:23:44 <kini> glguy: that might be unexpected for the user, since the summary they see on google will differ from what they see on the page
14:23:44 <kini> plus, what if the google query included something version-specific?
14:23:58 <kini> silasm: I guess, but that only solves the problem for me, not for anyone else
14:24:08 <silasm> true.
14:24:16 <glguy> kini: My experience with google is that the summary they show is often outdated, so that wouldn't be so far off
14:24:20 <dtruby> rwbarton: I've tried changing the INPUT line to (libncursesw.so) and /usr/lib/libncursesw.so. Just about to try symlinking
14:24:24 <kini> also, it's a lot easier for me to google something than to hoogle it, since I can just type text into my address bar in my browser and it will get googled
14:24:34 <kini> furthermore google is a general purpose text search engine whereas hoogle is not, afaik
14:24:55 <kini> glguy: not *that* outdated
14:25:00 <silasm> kini: set duckduckgo as your default search engine and use !h for hoogle searches and !g for google searches.
14:25:09 <silasm> you won't regret it :)
14:25:35 <dtruby> rwbarton: yep, symlink also causes it to segfault :-\
14:25:38 <avocado> i concur. ddg is awesome when you get used to all the ! shortcuts
14:25:42 <kqr> why is there an ExceptT and an EitherT and which one are you supposed to use?
14:25:58 <kini> glguy: like, I just searched for "system.console.cmdargs.explicit hackage" and the first hit is in cmdargs 0.9.5, from 2012
14:25:58 <kini> the second hit is from 0.7, from 2011
14:26:07 <kini> the text summaries in google hits are definitely not 2-3 years out of date
14:26:28 <glguy> kini: I always type: hackage.haskell.org/package/<thepackage> when I need docs
14:26:29 <kini> avocado, silasm: ddg isn't as good of a search engine for my needs as google is, so I'm not going to be doing that, I'm afraid
14:26:35 <glguy> (most of that autocompletes for me)
14:26:37 <kini> furthermore, that again would only solve the problem for me, not for anyone else
14:26:41 <rwbarton> dtruby: are these Haskell executables you built yourself on this system?
14:27:03 <kini> glguy: in this case I didn't even know what package provided the module, which is why I googled the name of the module
14:27:05 <dtruby> yeah, and libraries... do I need to rebuild them after doing the symlink?
14:27:09 <glguy> cmdargs :-p
14:27:12 <rwbarton> I wouldn't think so
14:27:19 <glguy> kini: The only thing that I think the community could actually do is block old versions with the robots.txt
14:27:33 <dtruby> yeah neither... I'm sure these were working a couple of weeks ago
14:27:42 <kini> that's a possible solution, but one might want to have those show up in search results *sometimes*.
14:27:52 <dtruby> I haven't done any haskell programming in a while but last I did I was definitely using ghc-mod, and that's just totally not working now
14:28:00 <kini> I wonder if google provides any way to tweak their results within one domain, as directed by the owner of the domain, or something
14:28:13 <ReinH> kqr: iirc, ExceptT is an attempt to improve ErrorT in a backwards-compatible way
14:28:20 <kini> I know that many many years ago they used to at least provide a text box where you could put a URL to manually ask their spider to look at it
14:28:21 <hexagoxel> kini: have you tried hayoo?
14:28:30 <kini> hexagoxel: yes
14:28:48 <kini> my question is not about how to find documentation, it's about how to improve google search results for haskell-related queries
14:28:56 <kini> and if such a thing is possible
14:29:01 <kini> I wonder how other language communities handle this
14:29:09 <rwbarton> dtruby: is something like the following possible: you had libcurses installed originally when you built these Haskell executables, and since then you installed libncursesw and it overwrote libcurses.so with this linker script
14:29:15 <kini> I don't seem to have had similar problems searching for, say, python docs in the past
14:29:36 <hexagoxel> last i checked, opengl documentation had the same problem
14:29:38 <ReinH> kqr: meanwhile, EitherT comes from the either package and is just a transformer version of Either.
14:29:39 <rwbarton> dtruby: and maybe libncursesw.so isn't totally binary compatible with the old libcurses.o
14:29:47 <avocado> kini: it's very likely that older versions have more pages linking to them than the newer versions. and so, their page ranks are higher
14:29:48 <dtruby> rwbarton: I built them today so I doubt it. I don't think my ncurses packages have updated since october anyway
14:29:55 <rwbarton> oh
14:29:56 <ReinH> kqr: Tekmo uses it in his errors package because he dislikes ErrorT and ExceptT, iirc
14:30:11 <dtruby> the main ones in question are llvm-general and ghc-mod
14:30:17 <dtruby> both of which I built from hackage today
14:30:35 <avocado> but i don't mess around with SEO, so i have no idea
14:30:38 <kini> avocado: I'm sure google doesn't have a set-in-stone policy about their rankings where something with more pages linking to it *must* be ranked higher - they do all kinds of tweaking for better user experience, don't they?
14:30:50 <kqr> ReinH, interesting
14:31:08 <kini> hexagoxel: interesting...
14:31:09 <avocado> kini: i don't work for google nor would i know, sorry :(
14:31:11 <glguy> kqr: The EitherT predates ExceptT being added to transformers
14:31:23 --- mode: glguy set -o glguy
14:31:26 <ReinH> Also that.
14:31:40 <glguy> now that it's in transformers you might as well use it (since that comes with GHC)
14:31:43 <kini> avocado: well, nor do I :P it just usually seems that way
14:31:52 <kqr> glguy, wait, which one predates which??
14:31:58 <ReinH> glguy: unless you share Tekmo's dislike of ExceptT ;)
14:32:02 <kqr> whoops, with fewer question marks
14:32:32 <glguy> Yeah, unless you have to use some of tekmos packages and you want compatibility with what he's doing, then use whatever he's using
14:32:35 <avocado> kini: you can read all about most of their pagerank algorithm. afaik, there isn't a way to modify it, even for just your domain. otherwise, i'd imagine it would lead to a lot of abuse
14:32:44 <kini> I wonder if it would help to have on every hackage docs page a link directly to the latest version of the same page
14:32:57 <glguy> exceptT is new in transformers 0.4 and you can use it in transformers 0.3 with the transformers-compat package
14:33:18 <avocado> kini: ##seo might be able to help
14:33:31 <avocado> unless it's not an SEO topic channel
14:33:50 <kini> er, sorry if all this was off-topic...
14:34:19 <avocado> it's not, but i feel like they would know better than myself
14:34:27 <kqr> glguy, but is exceptT actually better than eitherT or what's the deal there? from what i can see, they're basically the same thing, no?
14:34:47 <glguy> Yeah, same thing, different package
14:35:10 <Clint> what's Tekmo's objection then?
14:36:21 <kqr> glguy, ah right, one is in transformers and the other in either
14:36:25 <kqr> glguy, i almost missed that entirely
14:36:57 <rwbarton> dtruby: I don't have any particular idea why that might be then, sorry
14:39:57 <dtruby> rwbarton: no worries, thanks for trying :-). I'll try some more stuff tomorow to see if I can fix it
14:41:16 <ybit3> i'm wanting to build a haskell web app
14:41:29 <ybit3> i like scotty, because it's simple
14:42:56 <kqr> i'm just learning scotty
14:42:58 <kqr> seems very nice so far
14:43:09 <kqr> leaves a lot up to the developer though
14:43:18 <ybit3> think i'll just roll my own auth
14:45:42 * hackagebot linear-opengl 0.1.0.1 - Isomorphisms between linear and OpenGL types  http://hackage.haskell.org/package/linear-opengl-0.1.0.1 (BenGamari)
14:54:19 <ReinH> Clint: it might just be the name
14:54:29 <ReinH> Clint: or he might be rationalizing his use of EitherT now ;)
14:54:38 <ReinH> well, it's at least the name, I'm not sure if it's deeper than that
14:55:03 <Clint> hmm
14:55:43 * hackagebot linear-opengl 0.1.0.2 - Isomorphisms between linear and OpenGL types  http://hackage.haskell.org/package/linear-opengl-0.1.0.2 (BenGamari)
14:57:36 <ReinH> Clint: EitherT was preferable to ErrorT
14:57:47 <Clint> ReinH: yeah, i use EitherT and errors
14:57:54 <Clint> so i guess i'll keep doing that
14:58:21 <ReinH> Clint: seems fine
14:58:44 <ReinH> Clint: mostly because ErrorT privileged String errors
14:58:57 <Clint> you don't need to sell me on not-ErrorT
14:58:58 <ReinH> with the strMsg function on the Error class
14:59:01 <ReinH> ok sorry
15:00:27 <rwbarton> has anyone used criterion to generate reports from data that was collected externally?
15:01:40 <henk> bergmark: I see, thank you
15:04:31 <suOya_> .
15:04:55 <schell> do you guys know of any algorithms or general strategies for finding duplicate text in a list of files?
15:05:22 <moghedrin> schell: I believe rsync uses rolling hashes.
15:05:33 <moghedrin> schell: Might look into something like that.
15:06:33 <schell> moghedrin: rolling hashes - cool, thanks!
15:13:33 <altern_> Does anybody use EclipseFP? Why do I get this weird error? "configuring because setup_config not present; dynamic-cabal: runQuery: Result expression has wrong type"
15:14:05 <pjdelport> schell: In certain sense, what you're describing is data compression. :)
15:14:34 <pjdelport> schell: If it's very long range duplications, you might want to look at rzip (which is the rsync rolling hash algorithm applied to compression of very large files).
15:16:02 <pjdelport> schell: The most general approach for finding duplicate strings is using prefix/suffix trees/arrays.
15:16:12 <SrPx> Is there any library that allows me to create Trees, except that it automatically detects duplicated branches and instead of allocating more memory, just returns the existing tree?
15:19:09 <jfischoff> are there any bindings for tune the socket buffers on linux?
15:19:48 <schell> pjdelport: re: compression - yeah that makes sense - like run length encoding
15:20:33 <schell> i’m guessing this is a much bigger problem to takle than an evening project
15:23:23 <schell> i was going to try to write a smallish program that found duplicate files, methods, etc in src files throughout a project hierarchy
15:23:24 <altern_> Hi all
15:23:27 <altern_> Does anybody use EclipseFP? Why do I get this weird error? "configuring because setup_config not present; dynamic-cabal: runQuery: Result expression has wrong type"
15:23:39 <schell> does anyone know of something that accomplishes this?
15:24:05 <schell> i looked into a java program called PMD but it’s a bit overkill for what i need
15:24:23 <schell> altern_: hi :)
15:26:08 <kqr> is there any "flip fmap"?
15:26:58 <geekosaur> probably not predefined, since it's so easy to write it yourself just like that?
15:27:01 <Iceland_jack> @google "flip fmap"
15:27:02 <lambdabot> http://stackoverflow.com/questions/1678104/anyone-ever-flip
15:27:02 <lambdabot> Title: haskell - Anyone ever flip (<$>) - Stack Overflow
15:27:41 <kqr> right, thanks
15:27:48 <bos> dolio: ping
15:29:02 <pjdelport> schell: There are a host of tools like that. Finding code duplication is usually a bit more complicated, because a lot of duplication isn't identical at the byte level. Something like http://clonedigger.sourceforge.net/ is an example of an algorithm that tackles that.
15:30:09 <dolio> bos: Yo.
15:30:16 <Iceland_jack> kqr: http://ekmett.github.io/lens/Control-Lens-Lens.html (<&>)
15:30:36 <Iceland_jack> I found it using :)
15:30:37 <Iceland_jack> @google "Functor f => f a -> (a -> b) -> f b"
15:30:37 <lambdabot> https://hackage.haskell.org/package/semigroupoids-4.0.1/docs/Data-Functor-Bind.html
15:30:47 <bos> dolio: i've run into a massive regression in vector-algorithms performance under ghc 7.8
15:30:58 <dolio> Yeah? Where at?
15:31:00 <kqr> Iceland_jack, yeah, so there is an idiom, but i don't think it's worth introducing a new binding in this case
15:31:06 <bos> dolio: the introsort function
15:31:13 <dolio> Hmm.
15:31:13 <kqr> Iceland_jack, i tried doing that on hoogle but i should have tried hayoo too!
15:31:18 <dolio> I'll look into it.
15:31:38 <Iceland_jack> Yeah hoogle's domain can be a bit limited
15:31:38 <SrPx> nobody? ): well if anyone knows the answer, I've posted it on reddit: http://www.reddit.com/r/haskell/comments/2agq2c/is_there_any_library_that_deals_with_the_creation/
15:31:41 <bos> dolio: let me see if i can get you a test case
15:31:41 <SrPx> brb
15:31:49 <dolio> That'd be good.
15:33:15 <schell> pjdelport: thanks - that’s pretty close to what i need
15:37:49 <bos> dolio: http://lpaste.net/107363
15:38:06 <bos> dolio: the above example is 20x slower under GHC 7.8 as under 7.6
15:38:35 <dolio> Hmm.
15:39:22 <bos> it took me most of the night to narrow down the slowdown in my code to this :-(
15:39:32 <dolio> bos: Is this the only one that's significantly slower?
15:39:52 <bos> dolio: it's the only one i've tested.
15:39:58 <dolio> Okay.
15:40:17 <bos> dolio: i also use sortBy and partialSort, haven't checked those to see if they are also slower.
15:40:25 <dolio> :q
15:40:28 <dolio> Whoops.
15:41:29 <SrPx> Is there any simple, straightforward tutorial to generic types & generic programming?
15:41:41 <bos> dolio: there is *way* less inlining happening with ghc 7.8
15:41:51 <dolio> Yeah, that's probably it.
15:42:19 <dolio> Although vector-algorithms is pretty INLINEd.
15:42:20 <bos> dolio: -ddump-simpl with 7.6 == 4600 lines, with 7.8 == 600 lines
15:42:44 <bos> dolio: the call to Data.Vector.Algorithms.Intro.sort is not inlined at all
15:43:06 <dolio> sort is actually not marked INLINE. It's only INLINABLE.
15:43:26 <bos> dolio: i see at least two dictionaries being passed to sort
15:43:27 <dolio> Because a ways back, that was supposed to do something better.
15:43:39 <bos> Data.Vector.Unboxed.Base.$fMVectorMVectorInt and GHC.Classes.$fOrdInt
15:43:40 <dolio> Get the specialization to the dictionary without inlining the actual code.
15:43:44 <dolio> But maybe that's changed.
15:43:57 <bos> sounds like an unintentional regression, maybe
15:45:40 <bos> i'm rebuilding vector-algorithms with that function INLINE to see if it helps
15:45:47 * hackagebot hoq 0.1.0.0 - A language based on homotopy type theory with an interval object  http://hackage.haskell.org/package/hoq-0.1.0.0 (valis)
15:45:52 <dolio> Okay.
15:47:18 <bos> dolio: that fixed it.
15:47:32 <dolio> bos: One other thing you can tryis 'inline sort' on 7.8.
15:47:37 <dolio> But I expect that will have the same effect.
15:47:52 <dolio> Is it actually getting inlined in 7.6, even though it's merely INLINABLE?
15:47:58 <bos> yes it is.
15:48:03 <dolio> Interesting.
15:48:04 <bos> at least in part.
15:48:12 <AshyIsMe> when is the haskell platform with 7.8 coming out?
15:48:18 <bos> there's a bunch of calls to vector-algorithms internals still visible in the CORE
15:48:23 <bos> so not everything is being inlined
15:49:55 <bos> dolio: the functions in Data.Vector.Algorithms.Optimal need to be marked INLINE instead of INLINEABLE too
15:49:59 <bos> dolio: even under GHC 7.6
15:53:09 <quchen> AshyIsMe: "The status is: *Good-to-Go!*" -- email about the new HP a couple of days ago
15:53:38 <quchen> AshyIsMe: I think it will include 7.8.3, so the builds are going to be tested and it should be ready for release.
15:53:40 <bos> dolio: uh oh
15:53:42 <dolio> bos: Okay.
15:53:43 <quchen> In other words, "still soon" ;-)
15:53:51 <bos> dolio: this causes a new problem.
15:54:08 <bos> dolio: with all that code marked INLINE, ghc panics due to running out of simplifier ticks.
15:54:16 <dolio> Yeah, that's not surprising.
15:54:30 <dolio> bos: What if you SPECIALIZE a bunch of this stuff?
15:54:32 <dolio> Like sort?
15:55:00 <dolio> (Stuff with a comparison parameter is probably hosed, but sort should be specializable.)
15:55:01 <bos> dolio: i can no longer even build vector-algorithms
15:55:13 <dolio> I mean instead of INLINE.
15:55:18 <bos> yeah, i know.
15:55:43 <bos> i could SPECIALIZE on lots and lots of types.
15:55:50 <bos> that wouldn't actually be completely insane.
15:55:59 <bos> (well, it would but...)
15:56:06 <dolio> bos: The problem is it only works for things like sort.
15:56:11 <bos> right.
15:56:34 <bos> that's what we get for twisting ghc's arm into supercompilation mode.
15:56:41 <dolio> :)
15:58:30 <dolio> This still might not work.
15:58:33 <AshyIsMe> quchen: ah awesome :)
15:59:14 <moghedrin> > let k = 10 :: Word
15:59:15 <lambdabot>  not an expression: ‘let k = 10 :: Word’
16:00:39 <bos> dolio: RULE left-hand side too complicated to desugar
16:01:01 <dolio> bos: If INLINE on the optimal stuff causes blow-ups, that's a problem. Because none of them are like sort. I'd need to write separate versions that are.
16:01:33 <dolio> I'm not sure why I made them INLINABLE, but it's kind of useless for them.
16:01:43 <bos> they need dictionaries or functions passed in
16:01:55 <bos> so yeah, SPECIALIZE ain't workin'.
16:02:03 <dolio> Right.
16:02:38 <dolio> This could bifurcate the codebase.
16:02:49 <bos> bifurcate how do you mean?
16:02:55 <dolio> One that works with specialization, and one that doesn't.
16:03:25 <dolio> sort needs to call a special version of the optimal sorts that can be specialized.
16:03:45 <dolio> Instead of being sortBy compare.
16:03:55 <bos> the optimal sorts are parameterised on the PrimMonad and the MVector dictionaries
16:04:04 <bos> *and* a comparison function
16:04:31 <dolio> Specializing on the comparison function is key to speed.
16:04:31 <bos> ok, well.
16:04:50 <bos> if we just mark sort as INLINE, the GHC 7.8 slowdown goes away.
16:05:04 <bos> we're still doing too much dictionary passing, but yay, code that's 20x faster.
16:05:08 <dolio> And the only way to specialize is via dictionary or via inlining.
16:05:17 <dolio> Okay. I'll go back to inline on sort.
16:05:17 <bos> so you could simply ship a point release with that, and i'd be very happy.
16:05:22 <dolio> And see what else I can do.
16:05:39 <bos> the remainder feels scarily like boiling the ocean with a magnifying glass.
16:06:38 <dolio> If you were introsorting millions of size 4 arrays, you might see a similar 20x slowdown.
16:06:48 <dolio> From when I went from INLINE to INLINABLE.
16:08:31 <Nadia21>  Here some videos. I hope you like them! http://bitly.com/1q4qIaC
16:08:56 <bos> dolio: shall i assume that a bumped release will be numbered 0.6.0.2?
16:09:28 <dolio> Yeah.
16:09:35 <bos> thanks!
16:09:45 <dolio> No problem. Thanks for the report.
16:09:58 <bos> thanks for issuing a fix!
16:51:05 <hughfdjackson> hey all
16:51:13 <hughfdjackson> i'm sure you've seen this before from the scala crowd: http://parleys.com/play/53a7d2c3e4b0543940d9e538/chapter1/about
16:51:37 <hughfdjackson> (Composable application architecture with reasonably priced monads, the talk's called, by runar bjarnason)
16:52:37 <hughfdjackson> is the same basic approach applicable to haskell? Has anyone done any serious work with it?
16:52:57 <hughfdjackson> (or else any other extensible effects work in haskell)
16:53:35 <Welkin> reasonably priced monads?
16:53:35 <yogurt_truck> hughfdjackson: did you read oleg's paper?
16:53:43 <Welkin> what does that even mean?
16:53:55 <hughfdjackson> Welkin: it's a play on the fact that he's using the free monad :p
16:54:01 <cjenkin2> cute
16:54:07 <sclv> runar does stupid stuff in scala
16:54:11 <sclv> to work around lack of tail recursion
16:54:14 <sclv> in haskell it all just works
16:54:22 <hughfdjackson> yogurt_truck: yes, but it went in one ear and out of the other
16:54:26 <hughfdjackson> re-reading now :|
16:54:41 <yogurt_truck> hughfdjackson: check out the idris effects tutorial
16:54:42 <hughfdjackson> sclv: with regards to this particular problem, or just generally?
16:54:53 <sclv> if i recall, that’s part of this talk
16:55:09 <sclv> he’s just trying to get haskell style stuff to work without terrible efficiency and without blowing the stack
16:55:33 <yogurt_truck> hughfdjackson: just generally. he has an entire talk devoted to how to get around Scala being a pain
16:55:37 <hughfdjackson> hrm, perhaps i missed it, but i don't remember anything in this particular talk resembling that
16:55:42 <yogurt_truck> two talks, actually
16:56:07 <hughfdjackson> :p an uncharitable observer would say that was a sign of the state of things
16:56:11 <yogurt_truck> hughfdjackson: see the "FP is terrible" one here https://www.youtube.com/watch?v=hzf3hTUKk8U
16:56:28 <hughfdjackson> but then my day job involves javascript when it doesn't involve scala, so maybe i should hold my peace :|
16:56:43 <sclv> oh i see this talk is just free monads for effects
16:56:44 <sclv> yeah
16:56:46 <yogurt_truck> your day job sounds like my day job
16:56:54 <sclv> in that talk he’s just translating haskell ideas :-)
16:57:06 <sclv> the free and operational packages on hackage both have versions of that
16:57:24 <petantik> Under Mac OSX Mavericks, I installed ghc 7.8.2 using the binary package, since I wish to upgrade to 7.8.3 do I need to remove the older version first? If so, how do I uninstall it.
16:57:34 <hughfdjackson> sclv: awesome :) i'll have a rummage through those
16:57:41 <hughfdjackson> yogurt_truck: mind if i ask where you work at the moment?
16:57:45 <yogurt_truck> hughfdjackson: anyway, make sure to check out the idris effects tutorial
16:58:01 <yogurt_truck> hughfdjackson: lol, nowhere that matters.
16:58:19 <hughfdjackson> will do - then scan through oleg again and see if anything makes a bit more sense ;D
16:58:28 <yogurt_truck> great
16:58:51 <yogurt_truck> hughfdjackson: oh, Koka also does extensible effects, and there's both a paper and a try-online thing
16:58:58 <hughfdjackson> awesomesauce
16:59:40 <yogurt_truck> bbl
16:59:51 <geekosaur> petantik, there should be an uninstall-hs script with it; if not, the new one should have it
17:02:28 <glguy> petantik: While it's probably a good idea to uninstall the old version, you can have both installed at the same time without breaking either
17:04:22 <montagy> {-# LANGUAGE RebindableSyntax, OverloadedStrings #-},say hello to everyone,i`m a newbie ,i want to read the code ,but the first line stuck me ,can someone explain it or give me some resource,thank you
17:05:17 <glguy> Any module with rebindable syntax probably isn't a good starting point for reading code, but those are language extensions that make it so you can replace the meaning of do-notation, if-then-else, and string literals
17:05:30 <silasm> montagy: that's loading language extensions; things that may be useful to have but aren't in the language spec.
17:05:51 <petantik> geekosaur: Thanks, I'll try that.
17:06:04 <glguy> in Haskell files you can enable experimental/non-standard features with "LANGUAGE" pragmas
17:06:12 <glguy> stuff inside {-# #-} is a pragma
17:06:21 <montagy> glguy:thank you
17:06:34 <montagy> silasm:thank you
17:07:28 <montagy> so i can ignore it ?
17:07:54 <ski> you can try
17:08:18 <silasm> montagy: you should be trying to read a different source file, probably. There's going to be some things in that file that don't work elsewhere (files that haven't loaded that extension).
17:08:26 <joelteon> montagy, RebindableSyntax isn't good to read
17:08:54 <joelteon> basically means that things you read will (invisibly) behave differently from what normal Haskell code does
17:09:04 <joelteon> s/what/how/
17:10:29 <montagy> thank all of you,so it means haskell has diffrent standards?
17:10:32 <ski> hm, it basically mean unhygiene, yes ?
17:10:40 <joelteon> montagy, different compilers have different features
17:11:14 <joelteon> ski: how do you mean?
17:11:42 <cjenkin2> montagy, it just means that there is a "vanilla" Haskell, and there are optional extensions that can be added to it that require compiler support
17:11:42 <ski> joelteon : as in unhygienic macros
17:12:27 <joelteon> ski: not sure
17:12:58 <montagy> thank you ,i use ghc,where i can find the compiler supports?
17:14:11 <silasm> montagy: you should already have them; they come with ghc.
17:14:41 <silasm> They just aren't standard in the language spec itself; the main thing you potentially have to worry about is if you want code that you write to work with other ones, e.g. hugs.
17:15:39 <silasm> but, once again, if you're new to the language, you shouldn't really be worrying about this right now.
17:16:05 <geekosaur> alsom, language extensions not expected by some piece of code can break it in odd ways, either by turning a variable name into a keyword or by changing the types it expects, so extensions have to be explicitly enabled
17:16:20 <montagy> if i write code for private so i not have to write the pragma ,yes?
17:16:38 <geekosaur> only if you are using that extension
17:17:14 <geekosaur> if you're just starting out with Haskell, you probably shouldn't be playing with extensions
17:19:51 <petantik> geekosaur: I cannot locate the uninstall-hs script. It doesn't seem to exist in the 7.8.3 package either.
17:20:42 <geekosaur> oh, it may be part of haskell platform installs, not ghc bindists
17:21:21 <montagy> thank you,i think  read some code maybe helpfull,so i ignore them first.i have read the book lean you a haskell
17:21:26 <glguy> If you are like me you install your GHC bindists into $HOME/ghc-$VERSION and you can uninstall them by deleting that directory ^_^
17:21:31 <petantik> geekosaur: Ahh, am I stuck then?
17:21:56 <petantik> Or I need to manually clean up.
17:22:25 <petantik> /usr/local ... never again
17:22:41 <geekosaur> probably manual cleanup. I don't recall if the bindist provides an uninstall target, in which case you could re-download the bindist you currently have installed and use its uninstall target
17:22:44 <geekosaur> it's been a while
17:23:33 <petantik> It doesn't have an uninstall target as far as I can tell.
17:24:40 <glguy> You just need to get rid of (from memory) the old version number files in /usr/local/bin, /usr/local/lib/ghc-7.8.2 and if you're dedicated /usr/local/share/doc/ghc
17:25:09 <geekosaur> I generally install via macports so I use its mechanisms to clean up. (and I seem to recall encountering this with the bindists before; annoying)
17:25:18 <petantik> I'll probably use the ghcformacosx package next time.
17:25:55 <glguy> Just install the bindist into your home directory and it's easy cleanup
17:27:04 <petantik> Agreed.
17:27:26 <petantik> I think I just assumed there was an uninstall target/script
17:34:30 <SrPx> Is there any library for expressing Haskell AST, as well as compiling it during execution?
17:35:35 <lebek> how is a map from one complex data structure to another related to a lens?
17:40:18 <pavonia> SrPx: There's the haskell-src-exts package for the AST
17:40:33 <pavonia> I don't know what you mean by the second part of your question
17:41:45 <edwardk> lebek: you can have a lens from one to the other if second is basically a description of 'part' of a first, that is able to be fully injectively embedded and described by the first
17:43:13 <sclv> SrPx: also the template haskell api provides an AST
17:43:21 <sclv> and you can go between the two reps with haskell-src-meta
17:46:03 <goit790> http://2014-the-best-hd-movies-adults-only.blogspot.com/2014/07/2014-best-hd-movies-adults-only.html
17:46:04 <bms1> Is there there any real use case for Data.Dynamic?
17:47:59 <lebek> edwardk: thank you. if the structure changes such that a nested level is collapsed, would it no longer count as an injective embedding?
17:48:10 <Adeon> I use a map of TypeReps to Dynamics to implement a context-local storage in a certain way in one of my applications
17:49:18 <Adeon> in one context, only one value of given type should be created and then it is stored in the map and the map itself has no knowledge what these values are
17:50:26 <edwardk> lebek: well, if you lose information you're generally not going to get a lens
17:50:28 <bms1> Adeon: Oh, and so then in your code, you can demand a value of a specific type from the map?
17:50:34 <Adeon> yes
17:50:41 <Adeon> I guess I use it to improve decoupling
17:51:03 <edwardk> lebek: you might be able to 'traverse' the parts of a structure in a flat manner, but lenses in general must preserve everything
17:51:32 <ARCADIVS> I saw a language recently that was supposed to be essentialy Haskell with Lisp syntax and maybe some other features. What was that called?
17:51:45 <Adeon> clojure?
17:51:48 <Welkin> something you don't want to use
17:51:51 <MP2E> haha
17:51:52 <ARCADIVS> No, not clojure.
17:55:40 <ARCADIVS> Welkin: that's probably right, but when I saw it I didn't have enough time to read about it. I lost the link and I'm failing to google it.
17:55:44 <cursork> ARCADIVS: shen?
17:55:51 <lebek> edwardk: very helpful, thanks. I was thinking about my problem in the wrong way, lenses might be the solution :)
17:56:15 <ARCADIVS> I vaguely recall the name or something else having to do with "lambda".
17:56:21 <ARCADIVS> cursork: no, not shen either.
17:57:01 <Welkin> hisp?
17:57:07 <MP2E> ARCADIVS: maybe unlambda?
17:57:47 <cursork> MP2E: From wikipedia "It is based on combinatory logic, a version of the lambda calculus that omits the lambda operator" !
17:58:07 <ARCADIVS> MP2E: that's from 1999, so no.
17:58:08 <MP2E> I honestly just said that because he said something to do with lambda :P
17:58:16 * MP2E is not familiar with unlambda at all heh
17:58:29 <matematikaadit> @help unlambda
17:58:29 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
17:58:29 <ARCADIVS> This language I'm searching for is very recent.
17:59:07 <Welkin> ARCADIVS, there are possibly thousands of programming languages
17:59:14 <Welkin> new ones are created every day
17:59:29 <Welkin> most have a userbase of 0
17:59:51 <ski> ARCADIVS : Liskell ?
17:59:54 <ARCADIVS> Welkin: maybe if I could google hacker news haskell links in the past 6 months.
18:00:05 <cursork> Welkin: 1 surely. At least the creator has used it?
18:00:12 <Welkin> cursork, nope
18:00:43 <ARCADIVS> I'm pretty sure it's not Liskell
18:00:46 <ski> well, Liskell is not that recent, i think
18:01:20 <Enigmagic> ARCADIVS: https://news.ycombinator.com/item?id=7924168 ?
18:01:26 <Enigmagic> oh
18:01:29 <Enigmagic> not that one
18:03:55 <mcjohnalds> Does anyone know of a proper tutorial or something for LambdaCube 3D (the lambdacube-core package)?
18:04:51 <mcjohnalds> It looks awesome, but other than the "Getting Started" blog post, which just gives an overview of the pipeline, there isn't really any documentation
18:05:41 <elifrey> can someone help me to understand this output from cabal-install
18:05:47 <elifrey> next goal: bin-package-db (dependency of ghc-7.6.3/installed-494...)
18:05:48 <elifrey> rejecting: bin-package-db-0.0.0.0/installed-608... (conflict: binary==0.7.2.1,
18:05:48 <elifrey> bin-package-db => binary==0.5.1.1/installed-72e...)
18:06:02 <gamegoblin> So I need a datstructure that supports 2 levels of indexing, e.g. first index returns a bucket, second index returns an object in that bucket, is mutable, and thread safe. Currently I am using ` MVar (Map ByteString (MVar (Map ByteString ByteString)) `. Do you think using Data.HashTable would be better? Or is there another lib I should look at?
18:06:18 <elifrey> it seems to be saying that the bin-package-db that shipped with ghc does not like the binary that was shipped with ghc?
18:06:21 <gamegoblin> The goal is primarily read/write speed, memory is not an issue at all
18:06:23 <elifrey> I am confuzed
18:06:51 <gamegoblin> Is Data.HashTable thread safe? I don’t see if it says on its hackage page.
18:07:29 <danbst> gamegoblin, there is a recent library stm-containers, worth looking at
18:07:53 <joelteon> all haskell containers are threadsafe because they're immutable
18:08:00 <joelteon> not sure I understand the question
18:08:30 <gamegoblin> joelteon: What about mutable IO containers?
18:08:48 <gamegoblin> By thread safe I mean data don’t be lost in a race condition
18:08:52 <joelteon> ok, maybe I meant data structures
18:08:57 <joelteon> if you want to avoid race conditions, use STM
18:09:23 <gamegoblin> thanks for the reference dnbst
18:09:26 <gamegoblin> danbst *
18:11:29 <Cale> gamegoblin: In actual testing, often just keeping an MVar with a Data.Map in it beats out finer-grained locking like that
18:11:57 <gamegoblin> Cale: thanks for the tip.
18:12:15 <gamegoblin> I figure I’ll make an API with a few backends and test them all
18:12:48 <Cale> Also, last I checked Data.HashTable is awful and only present for historical reasons (some code in GHC uses it). If you're going to use hash-based structures, use unordered-containers.
18:13:20 <Cale> Data.HashMap vs. Data.Map is a bit of a toss-up for performance though
18:13:36 <Cale> (I've seen cases where either one beats the other)
18:22:36 <gamegoblin> I thought I saw some stackoverflow post that said HashTable was better now
18:24:05 <danbst> > let res = Right [1,2,3] in do {  (mapM_ print) res }
18:24:07 <lambdabot>  Couldn't match expected type ‘[a0]’
18:24:07 <lambdabot>              with actual type ‘Data.Either.Either a1 [t0]’
18:24:54 <danbst> how can I print list element wise uner Either/EitherT?
18:25:03 <danbst> *under
18:26:37 <ski> danbst : maybe you want `mapM_ (liftIO . print)' ?
18:27:47 <danbst> > let res = Right [1,2,3] in do {  mapM_ (liftIO . print) res }
18:27:49 <lambdabot>  Couldn't match expected type ‘[a0]’
18:27:49 <lambdabot>              with actual type ‘Data.Either.Either a1 [t0]’
18:28:58 <danbst> ski, yes, but that doesn't work
18:29:24 <ski> well, it'd only work for `EitherT', naturally
18:31:44 <danbst> ski, I can't wrap my mind where to put `runEitherT`
18:31:55 <lfairy> :t T.sequence
18:31:56 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
18:32:18 <lfairy> > T.sequence $ Right [1,2,3]
18:32:19 <lambdabot>  [Right 1,Right 2,Right 3]
18:32:24 <Iceland_jack> danbst: when you want to get the final value, or when you want to run your ErrorT computation
18:32:24 <ski> danbst : at the outside
18:32:26 <lfairy> huzzah
18:33:28 <danbst> > let res = Right [1,2,3] in runEitherT $ do {  mapM_ (liftIO . print) res }
18:33:29 <lambdabot>  Not in scope: ‘runEitherT’
18:33:29 <lambdabot>  Perhaps you meant ‘runWriterT’ (imported from Control.Monad.Writer)
18:34:03 <lfairy> EitherT isn't in transformers -- try ErrorT instead
18:34:11 <Iceland_jack> danbst: Check this out http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
18:34:51 <Iceland_jack> You need to have a solid foundation in using monads before you tackle monad transformers
18:35:23 <danbst> lfairy, it's a pity
18:43:00 <jle`> indeed
18:43:28 <danbst> > let res = Right [1,2,3] in case res of { Right l -> mapM_ putStrLn l; Left _ -> error "Left" }
18:43:30 <lambdabot>  No instance for (GHC.Num.Num GHC.Base.String)
18:43:30 <lambdabot>    arising from a use of ‘res’
18:43:37 <danbst> > let res = Right [1,2,3] in case res of { Right l -> mapM_ print l; Left _ -> error "Left" }
18:43:39 <lambdabot>  <IO ()>
18:48:03 <danbst> Iceland_jack, how can I do the above with transformers?
18:51:41 <ski> > let act = ErrorT (return (Right [1,2,3])) in runErrorT $ do {  res <- act; mapM_ (liftIO . print) res } :: IO (Either String ())
18:51:42 <jle`> sometimes i wish there was a mini-lens with just the types and combinators and stuff, but no built-in lenses/prisms
18:51:42 <lambdabot>  <IO (Either [Char] ())>
18:51:47 <jle`> and no generators
18:51:49 <ski> danbst : perhaps something like that
18:51:56 <Iceland_jack> :t mapM_ (liftIO . print) =<< (return [1,2,3] :: ErrorT String IO [Int])
18:51:57 <lambdabot> ErrorT String IO ()
18:51:59 <jle`> because i wouldn't mind writing my own lenses for random stuff at all
18:52:17 <jle`> in fact most of the lenses/prisms i think of are ones that aren't acessors and modifiers for data structures and stuff
18:52:48 <jle`> ...is that what lens-family is?
18:56:37 <danbst> ski, Iceland_jack, thanks. Now I unerstanm that this is not what I would like to write :)
18:56:38 <glguy`> Jle' , you don't need any package at all to write your own lenses
18:56:57 <jle`> glguy`: yeah but i would like over, from, view, preview, review, etc.
18:57:06 <glguy`> And you only need to depend on "profunctors" to write your own prisms
18:57:11 <jle`> instead of rewriting it all the time
18:57:21 <jle`> i don't miss the operators
18:57:46 <jle`> also lens, prism, iso --- those are handy
18:57:54 <jle`> and the Lens/Prism/Iso type synonyms
18:58:04 <jle`> over profunctors
18:58:09 <platz> what about lens-family-core/lens-family ?
18:58:15 <jle`> is that what those are for?
18:58:28 <platz> supposedly they're stripped down versions of lens
18:58:35 <platz> without all the extras
18:58:48 <jle`> i should take a look at them
18:58:53 <edwardk> platz: i use prisms too much to ever use them frankly
18:59:05 <edwardk> platz: its basically cutting off half my usecases for lens
18:59:09 <jle`> by lens/prism/iso, i mean the functions
18:59:20 <Algebr> Why does ghc increment in 0.2s?
18:59:36 <platz> ahh, I need to spend some time learning prisms
18:59:56 <jle`> a lot of times in my short one-off scripts i literally just re-implement lens/prism/iso and over/view/preview
18:59:58 <ski> danbst : why not ?
19:00:26 <jle`> but if there was just like a one-module package that had those basic things i would be pretty happy i think
19:00:48 * jle` dreams
19:01:53 <glguy`> Quit dreaming and write it if it'd be useful to you :p
19:02:14 <jle`> oh yeah i have considered that.  but i wouldn't want to enter into the domain of lens peoeple
19:02:24 <jle`> i am intimidated :|
19:02:49 <danbst> ski, I don't know how you guys got the transformers intuition, but
19:02:50 <danbst> let res = Right [1,2,3] in case res of { Right l -> mapM_ print l }
19:02:54 <glguy`> The lens people already have their packages. You don't have to worry about them
19:03:15 <jle`> hm  o k
19:03:22 <danbst> is simpler than `let res = right [1,2,3] in runEitherT $ do { mapM_ (lift . print) =<< res }`
19:03:22 <jle`> do you hear that, world
19:03:23 <jle`> here i come
19:03:37 <platz> That's what they said about the germans
19:03:51 <jle`> lol
19:03:57 <danbst> *simpler to rea
19:04:05 <danbst> *simpler to read
19:04:46 <ski> danbst : if that's the only code you've got, then sure
19:04:46 <glguy`> Danbst: you shouldn't use a transformer in limited cases like that, anyway
19:05:17 <fread2282> https://gist.github.com/fread2281/f3714c88b3df0c10814f someone help me
19:05:31 <fread2282> (cabal problems on windows)
19:06:36 <pavonia> Algebr: see http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/version-numbering.html
19:06:45 <danbst> ski, anyway this little examples are always helpful
19:06:54 <danbst> *these
19:07:00 <ski> danbst : do you know the `Maybe' monad ?
19:07:13 <danbst> ski, yes
19:07:45 <ski> then you know that you can use it instead of nested `case's on `Maybe'-results, that (mostly) short-circuit on `Nothing'
19:08:20 <pavonia> fread2282: What does "ghc-pkg check" tell you?
19:08:25 <jle`> danbst: i think you can just use the Traversable instance of Either to do your example
19:08:44 <ski> you use `EitherT' is similar circumstances, when the method above with explicit `case res of { Right l -> ...; Left e -> ...}' gets annoying enough
19:08:54 <jle`> let res = Right [1,2,3] in mapM_ (mapM_ print) res
19:09:00 <glguy> jle`: fwiw you only need Foldable for traverse_
19:09:03 <jle`> oh yeah
19:09:09 <jle`> mapM_ isn't even in Traversable
19:09:12 <jle`> my bad
19:09:30 <ski> @type F.mapM_
19:09:30 <johnw> Foldable
19:09:30 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
19:10:56 <jle`> let res = Right [1,2,3] in (mapM_ . mapM_) print res
19:11:16 <jle`> although ghc 7.6.3 doesn't seem to have a foldable instance for Either
19:11:20 <jle`> but 7.8.3 does
19:11:26 <jle`> how weird
19:12:17 <danbst> ski, thanks
19:12:53 <noah> I'm confused about dependancies in cabal files. I'm trying to add a benchmark section, and it seems to want me to add all my build dependancies again
19:13:21 <jle`> :t let res = Right [1,2,3] in (F.mapM_ . F.mapM_) print res
19:13:21 <lambdabot> IO ()
19:13:49 <danbst> jle`, that is cool, unfortunately I'm stuck with Haskell Platform
19:13:55 <glguy> noah: make sure you add your library as a build-depend of your benchmark and that they don't share source directories
19:14:00 <jle`> danbst: Foldable is in base
19:14:02 <jle`> isn't it?
19:14:10 <jle`> so you don't even need the Platform
19:14:23 <noah> glguy: thanks, I'll try that
19:14:24 <danbst> jle`, No instance for (Foldable (Either a0))
19:14:38 <jle`> hm
19:14:51 <jle`> well you could write your own instance by hand, but yeah that's rather annoying
19:16:07 <jle`> instance Foldable (Either e) where foldr f x = foldr f x . either [] id
19:16:09 <jle`> ta dah
19:16:10 <ski> danbst : i'd just manually add the instance if i didn't get it
19:16:40 <noah> glguy: that works! I didn't have them in different source directory, which I now realize is a bad idea.
19:16:49 <danbst> ha
19:17:07 <danbst> StandaloneDerive && DeriveFoldable
19:17:24 <jle`> instance Foldable (Either e) where foldr f x = foldr f x . either (const []) id
19:17:33 <jle`> oh yeah, you can do that too, I think
19:18:28 <jle`> instance Foldable (Either e) where foldr f x = foldr f x . either (const []) return  --- fixed it, but you should probably just use DeriveFoldable :)
19:36:23 <augur_> so
19:36:34 <pdxleif> :( http://news.yahoo.com/haskell-collapses-texas-court-details-texas-murder-read-145858094.html
19:36:41 <augur_> ive been abusing unsafePerformIO to do debugging output. its quite nice. *cough*
19:36:46 <pdxleif> they said this language was supposed to be *safe*
19:37:01 <pdxleif> augur_: Debug.Trace?
19:37:20 <augur_> no clue how to use it
19:37:33 <benzrf> :t
19:37:36 <benzrf> oop
19:37:40 <benzrf> :t absurd
19:37:41 <lambdabot> Not in scope: ‘absurd’
19:37:44 <benzrf> hmm
19:37:56 <augur_> why would absurd be defined?
19:38:01 <glguy> ?type Data.Void.absurd
19:38:02 <pdxleif> :t trace
19:38:02 <lambdabot> Data.Void.Void -> a
19:38:03 <lambdabot> Not in scope: ‘trace’
19:38:07 <benzrf> perf
19:38:09 <jle`> augur_: i think trace = unsafePerformIO . putStrLn
19:38:11 <pdxleif> :t Debug.Trace.trace
19:38:12 <lambdabot> String -> a -> a
19:38:18 <benzrf> how do you define
19:38:19 <jle`> oh
19:38:21 <jle`> with the const
19:38:21 <augur_> pdxleif: hm
19:38:23 <benzrf> absurd for `data Void'
19:38:25 <augur_> well, i just defined that, so
19:38:25 <augur_> :D
19:38:32 <glguy> benzrf: Why not go look?
19:38:34 <augur_> as debug
19:38:41 <augur_> actually mine uses print not putStrLn
19:38:44 <pdxleif> > (Debug.Trace.trace "I'm making a number" 5) + 10
19:38:45 <lambdabot>  Not in scope: ‘Debug.Trace.trace’
19:38:46 <benzrf> glguy: Data.Void seems to use `newtype Void = Void !Void'
19:38:49 <benzrf> @let absurd v = absurd v
19:38:50 <lambdabot>  Defined.
19:38:52 <benzrf> :t absurd
19:38:53 <lambdabot> t -> t1
19:38:58 <benzrf> that works for all types, not just Void...
19:39:07 <glguy> OK, so : absurd (Void v) = absurd v
19:39:23 <benzrf> glguy: yes, i said:
19:39:25 <benzrf> 10:36 < benzrf> absurd for `data Void'
19:39:29 <benzrf> 10:36 < benzrf> absurd for `data Void'
19:39:32 <benzrf> oops
19:40:24 <triliyn> pdxleif, augur_: Debug.Trace was basically a simple wrapper over unsafePerformIO, last time I looked at the source
19:40:55 <triliyn> oh, jle` already said that
19:41:05 <benzrf> why does haskell even have botom
19:41:08 <benzrf> *bottom
19:41:23 <glguy> Because it allows arbitrary recursion
19:41:24 <MP2E> benzrf : because non-strict evaluation requires the definition of bottom
19:41:32 <benzrf> MP2E: oh really
19:41:32 <MP2E> well that + recursion, rather
19:41:50 <benzrf> why isnt arbitrary recursion possible without it?
19:42:11 <triliyn> It's more the other way around
19:42:22 <benzrf> are you referring to non-terminating recursion?
19:42:27 <pdxleif> It's not quite the impl jle` said, though; it prints the string, and then returns the value of the second arg - https://hackage.haskell.org/package/base-4.7.0.0/docs/src/Debug-Trace.html#trace
19:42:33 <triliyn> Arbitrary recursion allows you to define things like f a = f a
19:42:38 <benzrf> triliyn: ok...
19:42:43 <benzrf> what does that have to do with bottom
19:42:43 <pdxleif> That other def wouldn't be particularly useful - purity, lazy eval and all that.
19:42:48 <triliyn> And this value, among many others, is theoretically referred to as bottom
19:42:55 <Iceland_jack> benzrf: then 'f a' is bottom
19:42:57 <triliyn> (or well, not f itself, but f a)
19:43:17 <benzrf> Iceland_jack: ah, do you mean denotationally?
19:43:20 <Iceland_jack> in so far as Haskell having bottom, it rather has the interpretation of bottom
19:43:27 <benzrf> i dont really know denotational semantis
19:43:30 <benzrf> *semantics
19:43:32 <platz> are there some functions which cannot be made complete (and then must be partial?)
19:43:35 <Iceland_jack> You don't really need to
19:43:35 <pdxleif> that is, unsafePerformIO $ putStrLn "foo" wouldn't get executed unless the value of that unit was used, somehow?
19:43:49 <benzrf> pdxleif: yeah
19:43:56 <Iceland_jack> You can think of bottom being a non-terminating value, an error, etc. ...
19:43:57 <benzrf> pdxleif: you probably want seq
19:44:13 <benzrf> i guess i was asking about `undefined' in particular
19:44:14 <Iceland_jack> It's a least-defined element
19:44:17 <benzrf> @src throw
19:44:17 <lambdabot> throw exception = raise# exception
19:44:17 <pdxleif> which is kind of like Debut.Trace
19:45:05 <Iceland_jack> If you're asking why Haskell has undefined
19:45:12 <Iceland_jack> @src undefined
19:45:13 <lambdabot> undefined =  error "Prelude.undefined"
19:45:13 <augur_> \o/
19:45:16 <pdxleif> guess you could also define Debug.Trace as seq . unsafePerformIO . putStrLn or something
19:45:17 <Iceland_jack> Are you asking why Haskell has 'error'?
19:45:19 <augur_> i think im done with my fake prolog!
19:45:38 <Iceland_jack> Because if Haskell didn't have undefined but had error, you could define it yourself
19:45:52 <Iceland_jack> Haskell isn't a total language
19:45:54 <triliyn> There's no way to force the printing of things that are never used
19:45:55 <augur_> haskell _doesnt_ have undefined :x
19:46:00 <augur_> undefined = error "undefined"
19:46:07 <augur_> @src undefined
19:46:07 <lambdabot> undefined =  error "Prelude.undefined"
19:46:12 <benzrf> > raise# "ur mom"
19:46:14 <lambdabot>  Not in scope: ‘raise#’
19:46:18 <triliyn> seq . unsafePerformIO . putStrLn is the same as unsafePerformIO . putStrLn I think
19:46:35 <augur_> triliyn: cant be
19:46:37 <augur_> they have different types
19:46:43 <augur_> :t unsafePerformIO.putStrLn
19:46:43 <benzrf> :t seq . unsafeperformIO . putStrLn
19:46:44 <lambdabot> Not in scope: ‘unsafePerformIO’
19:46:44 <lambdabot> Not in scope: ‘unsafeperformIO’
19:46:47 <augur_> ughhh
19:46:51 <benzrf> lame!
19:46:54 <augur_> well anyway its String -> IO ()
19:46:59 <augur_> er
19:47:01 <augur_> well anyway its String -> a
19:47:15 <TheKing444> What is?
19:47:28 <augur_> unsafePerformIO . putStrLn
19:47:28 <TheKing444> undefined?
19:47:36 <TheKing444> :t putStrLn
19:47:37 <lambdabot> String -> IO ()
19:47:39 <augur_> unsafePerformIO is, iinm, IO () -> a
19:47:47 <Iceland_jack> :t unsafePerformIO . putStrLn
19:47:47 <lambdabot> Not in scope: ‘unsafePerformIO’
19:47:48 <triliyn> IO a -> a
19:47:58 <TheKing444> Yeah, it is IO a -> a
19:48:01 <augur_> triliyn: oh thats it
19:48:05 <TheKing444> so it would be String -> ()
19:48:09 <TheKing444> and would be a bad idea
19:48:22 <Iceland_jack> :t System.IO.Unsafe.unsafePerformIO . putStrLn
19:48:22 <benzrf> @let unsafePerformIO = error "Nice try." :: IO a -> a
19:48:22 <lambdabot> String -> ()
19:48:23 <lambdabot>  Defined.
19:48:31 <benzrf> :t seq . unsafeperformIO . putStrLn
19:48:32 <lambdabot>     Not in scope: ‘unsafeperformIO’
19:48:32 <lambdabot>     Perhaps you meant ‘unsafePerformIO’ (line 150)
19:48:39 <benzrf> :t seq . unsafePerformIO . putStrLn
19:48:40 <lambdabot> String -> b -> b
19:48:48 <TheKing444> why the seq?
19:48:51 <benzrf> > unsafePerformIO (putStrLn "foo")
19:48:52 <lambdabot>  *Exception: Nice try.
19:48:54 <TheKing444> that just makes it more nots
19:49:15 <pdxleif> triliyn: trace msg value = seq (unsafePerformIO $ putStrLn msg) value
19:49:15 <augur_> > putStrLn "foo"
19:49:17 <lambdabot>  <IO ()>
19:49:17 <lfairy> it talks back!
19:49:18 <benzrf> calling raise# for me segfaults :'(
19:49:20 <augur_> :(
19:49:20 <elninja> > 5+5
19:49:21 <lambdabot>  10
19:49:22 <benzrf> @src error
19:49:22 <lambdabot> error s = throw (ErrorCall s)
19:49:28 <benzrf> @src throw
19:49:28 <lambdabot> throw exception = raise# exception
19:49:29 <benzrf> oic
19:49:38 <TheKing444> @let unsafePerformIO = error "Oh no, you magically crashed lambdabot. Not the haskell police are after you."
19:49:38 <lambdabot>  .L.hs:151:1:
19:49:39 <lambdabot>      Multiple declarations of ‘unsafePerformIO’
19:49:39 <lambdabot>      Declared at: .L.hs:150:1
19:49:39 <lambdabot>                   .L.hs:151:1
19:49:44 <TheKing444> > unsafePerformIO a
19:49:45 <lambdabot>  Couldn't match expected type ‘GHC.Types.IO a’
19:49:45 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
19:49:55 <TheKing444> > unsafePerformIO "yo/o"
19:49:56 <triliyn> pdxleif: oh, yeah, I guess that's right
19:49:56 <lambdabot>  Couldn't match expected type ‘GHC.Types.IO a’
19:49:57 <lambdabot>              with actual type ‘[GHC.Types.Char]’
19:50:00 <triliyn> I thought you meant something else
19:50:04 <Iceland_jack> TheKing444: Your definition failed
19:50:15 <TheKing444> > unsafePerformIO "yo/o" :: Char
19:50:16 <lambdabot>  Couldn't match expected type ‘GHC.Types.IO GHC.Types.Char’
19:50:16 <lambdabot>              with actual type ‘[GHC.Types.Char]’
19:50:32 <TheKing444> > (unsafePerformIO "yo/o") :: Char
19:50:33 <lambdabot>  Couldn't match expected type ‘GHC.Types.IO GHC.Types.Char’
19:50:33 <lambdabot>              with actual type ‘[GHC.Types.Char]’
19:50:39 <TheKing444> > unsafePerformIO "yo/o" :: [Char]
19:50:40 <lambdabot>  Couldn't match expected type ‘GHC.Types.IO [GHC.Types.Char]’
19:50:40 <lambdabot>              with actual type ‘[GHC.Types.Char]’
19:50:47 <TheKing444> ugh
19:50:52 <Iceland_jack> You can play around with lambdabot in PM
19:51:03 <TheKing444> @let unsafePerformIO = error "Oh no, you magically crashed lambdabot. Not the haskell police are after you." :: IO a -> a
19:51:04 <lambdabot>  .L.hs:151:1:
19:51:04 <lambdabot>      Multiple declarations of ‘unsafePerformIO’
19:51:04 <lambdabot>      Declared at: .L.hs:150:1
19:51:04 <lambdabot>                   .L.hs:151:1
19:51:20 <TheKing444> @help
19:51:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:51:22 <TheKing444> @list
19:51:22 <lambdabot> What module?  Try @listmodules for some ideas.
19:51:26 <TheKing444> @listmodules
19:51:26 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
19:51:29 <joelteon> TheKing444: take it to PM
19:51:30 <glguy> Please learn about lambdabot in /msg
19:51:36 <glguy> ?undefine
19:51:36 <lambdabot> Undefined.
19:51:59 <pdxleif> TheKing444: the seq is so you can actually insert another value in the expression, and have it be executed
19:52:56 <ReinH> pdxleif: is there an upcoming pdxfunc meeting?
19:53:19 <pdxleif> Yeah - this Monday - Urban Airship
19:53:39 <pdxleif> Were thinking about talking effects systems - like Oleg's recent paper, and Idris's Eff DSL, etc
19:53:46 <ReinH> pdxleif: Oh cool!
19:53:51 <pdxleif> I'll put it up on calagator
19:53:59 <ReinH> seems good
19:54:23 <TheKing444> how do get rid of definitions in lambda bot?
19:54:26 <pdxleif> we have a #pdxfunc channel and stuff
19:54:31 <ReinH> cool!
19:58:42 <TheKing444> > unsafePerformIO $ putStrLn "Test"
19:58:43 <lambdabot>  *Exception: Oh snap, you broke lambdabot. The haskell police are on ya know!
19:59:13 <TheKing444> > unsafePerformIO $ putStrLn "Test"
19:59:15 <lambdabot>  *Exception: Oh snap, you broke lambdabot. The haskell police are on ya now!
19:59:56 <TheKing444> Who needs help haskellin'?
20:07:06 <benzrf> therealklanni: you mean 'now'
20:08:20 <Jaidan21>  Hi! I give you some videos. I hope you like! http://bit.ly/1oNh1YO
20:08:25 <joelteon> no, thank you
20:10:30 <squimmy> where can I learn about "rank-n types"? I want to know about the implications of using -XRankNTypes, but the wikipedia page for parametric polymorphism just says "This section requires expansion." under "Rank-n ("higher-rank") polymorphism"
20:11:46 <platz> squimmy: oh god.. let me know if you figure it out.  the best I can think of is that they are nested forall's but I'm sure thats wrong
20:13:03 <platz> there are sevel stackoverflow articles that will turn up if you search for it, but good luck with that
20:13:25 <MP2E> I remember reading a good reference, let me look
20:13:41 <platz> theres also one on haskell wikibooks
20:13:56 <benzrf> squimmy: yeah theyre basically just nested foralls
20:14:20 <benzrf> foralls here. Constructor <- rank-1
20:14:37 <benzrf> Constructor (foralls here. something) <- rank-more-than-1
20:15:03 <benzrf> i'm told that they're undecidable in general or some such nonsense
20:15:45 <squimmy> i don't even really understand what a forall is! except insofar as it just seems to be an explicit type constraint?
20:16:14 <lfairy> squimmy: every polymorphic function has a forall in front of it!
20:16:29 <lfairy> it's just in haskell98, the compiler adds them implicitly
20:16:35 <squimmy> ah
20:16:43 <lfairy> they're used to introduce type variables, btw
20:16:54 <squimmy> that's just the `=>`, right?
20:16:56 <jle`> squimmy: there was a nice article on it a couple months ago... hm.
20:17:16 <lfairy> squimmy: no, => introduces constraints, which are a different thing altogether
20:17:32 <squimmy> ah
20:17:43 <MP2E> jle` : this? http://sleepomeno.github.io/blog/2014/02/12/Explaining-Haskell-RankNTypes-for-all/
20:18:06 <MP2E> hopefully I typed that in right, I don't have X up right now heh
20:18:15 <jle`> MP2E: yeah that's it, i think
20:18:45 <squimmy> thanks
20:19:55 <squimmy> i suppose one main question i have is: if I'm getting a compile error when i don't use -XRankNTypes, is it a sign that I'm doing something wrong?
20:20:18 <glguy> ?type let example f x y = (f x, f y) in example
20:20:19 <lambdabot> (t1 -> t) -> t1 -> t1 -> (t, t)
20:20:23 <glguy> ?type let example :: (forall t. t -> t) -> a -> b -> (a,b); example f x y = (f x, f y) in example
20:20:23 <lambdabot> (forall t. t -> t) -> a -> b -> (a, b)
20:20:46 <jle`> squimmy: it depends on what you want to do
20:22:29 <squimmy> well, the line causing the error is: type DoRandomStuff = RandomGen a => a -> Int -> Int -> ([Int], a)
20:22:41 <MP2E> ah okay
20:22:45 <MP2E> in that case, I think RankNTypes is fine
20:22:53 <lfairy> eeyup
20:22:57 <jle`> um
20:23:03 <squimmy> yeah, i mean, it seems pretty innocuous to me?
20:23:21 <jle`> why can't you just do type DoRandomStuff = a -> Int -> Int -> ([Int], a)
20:23:28 <lfairy> you need to introduce the a somehow, so yeah
20:23:32 <jle`> or
20:23:37 <jle`> oh yeah
20:23:41 <jle`> why can't you just do type DoRandomStuff a = a -> Int -> Int -> ([Int], a)
20:23:59 <jle`> and have the forall in your function type signatures?
20:24:05 <jle`> ...if you even needed it
20:24:10 <glguy`> Squimmy: when you do that you create a type synonym that surprise people with hidden variables
20:24:20 <lfairy> I can't really tell without more context
20:24:28 <lfairy> whether that's a good idea or not
20:24:28 <glguy`> And which can't be stored easily in other types
20:25:08 <glguy`> And doesn't behave as well as a function argument
20:25:27 <squimmy> glguy`: I'm not sure I understand what you mean by "hidden variables"
20:26:04 <jle`> squimmy: if you use DoRandomStuff in a type signature, whatever you do with it ahs to be polymorphic over all RandomGen's
20:26:13 <glguy`> You didn't mention the 'a' on the left side of the= when defining the type synonym
20:26:36 <squimmy> ah
20:26:51 <glguy`> I'm hoping someone can jump in, typing on phone ducks ;)
20:26:51 <jle`> i recommend just type DoRandomStuff a = a -> Int -> Int -> ([Int], a)
20:27:04 <jle`> and having the RandomGen constraint on your functions that use DoRandomStuff
20:27:21 <squimmy> jle`: that works, but then how do i specify the type of functions using DoRandomStuff?
20:27:33 <jle`> squimmy: can you show an example?
20:27:40 <jle`> DoRandomStuff a is just a type synonym
20:27:55 <jle`> so where you would put (a -> Int -> Int -> ([Int], a)), you can type DoRandomStuff a instead
20:28:16 <jle`> they are interchangeable, lexically, more or less
20:28:48 <jle`> then in that function you can put a RandomGen a => ... constraint on the entire type signature
20:29:57 <squimmy> jle`: ok
20:30:27 <jle`> there are situations where moving the a "inside" would be useful, but...I doubt that this is one.
20:31:12 * hackagebot esqueleto 1.4.3 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.4.3 (FelipeLessa)
20:32:50 <squimmy> jle`: i don't currently have an example that isn't just a hundred lines of garbage. I'll go with your idea of "type DoRandomStuff a = ..." and read that "Explaining Haskell RankNTypes for All" link
20:32:59 <squimmy> thanks all :)
20:33:36 <jle`> squimmy: from what i can gather, this isn't a case where rank n types is the best solution.  i could be wrong, but just a hunch :)  if you run into problems with this method then come back and ask :)
20:48:37 <squimmy> jle`: will do. tghanks
20:49:44 <trap_exit> is http://weblog.luite.com/wordpress/?p=14 mirrored somehwere? I need to read luite's ghcjs examples, but the weblog seems down
20:50:56 <lfairy> trap_exit: it's up for me
20:51:22 <geekosaur> web.archive.org has it as well
20:51:35 <trap_exit> lfairy: can you wget the site and send me a .tar.gz? :-)
20:51:50 <lfairy> trap_exit: woah, no need to get so complicated
20:51:55 <lfairy> there are plenty of proxies on the web
20:52:06 <lfairy> try one of 'em
20:52:34 <trap_exit> http://web.archive.org/web/20140701023405/http://weblog.luite.com/wordpress/?p=14 <-- renders unicode garbage for me
20:53:15 <trap_exit> https://webproxy.vpnbook.com/browse.php?u=Wzgh65buIbm92IP0vZO90B1b7GpFnf3cYQ9FvU4hzme3hAs%3D&b=0&f=norefer worked
20:53:26 <trap_exit> lfairy: your services are no longer required :-)
20:53:36 <lfairy> trap_exit: :P
21:01:14 * hackagebot linear-opengl 0.2.0.0 - Isomorphisms between linear and OpenGL types  http://hackage.haskell.org/package/linear-opengl-0.2.0.0 (BenGamari)
21:14:04 <trap_exit> luite: Hello World works!
21:14:29 <trap_exit> luite: pm me if you want to hear complaints about the ghcjs installation instructions (I found out what was tripping me up this whole time)
21:22:02 <luite> trap_exit: sure message me
21:31:16 * hackagebot tropical 0.0.0.1 - A library for tropical mathematics.  http://hackage.haskell.org/package/tropical-0.0.0.1 (pharpend)
21:56:19 * hackagebot vector-algorithms 0.6.0.2 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.6.0.2 (DanDoel)
22:08:45 <Alanis21>  You can find funny videos here. http://bit.ly/1q4TRm1
22:12:47 --- mode: ChanServ set +o johnw
22:12:53 --- mode: ChanServ set +o johnw
22:13:34 <leroux> t/quit
22:13:57 <johnw> /kickban Alanis21
22:13:57 <johnw> 00:11 <leroux> t/quit
22:13:57 <johnw>  
22:14:00 <johnw> sorry
22:14:10 <johnw> my macro doesn't let me know that the person has left already
22:28:30 <solidus-river> hlint is complaining about my use of otherwise in a case statement
22:28:36 <solidus-river> whats the preferred way to provide a catchall case?
22:29:14 <levi> That seems odd. What's the exact note it gives?
22:29:49 <solidus-river> levi: This binding for `otherwise' shadows the existing binding imported from `Prelude'
22:30:41 <solidus-river> does it want me to explicitly import prelude (otherwise
22:30:42 <solidus-river> )
22:30:43 <solidus-river> lol
22:31:14 <levi> It must think you're creating a new binding for it; maybe you've got a syntax problem?
22:31:43 <lfairy> solidus-river: otherwise only works in guards
22:31:52 <kvanb> solidus-river: you should use _
22:31:55 <lfairy> solidus-river: for a catch-all in case, use a single underscore _
22:31:59 <solidus-river> ah
22:32:00 <kvanb> otherwise is incorrect in case statements!
22:32:02 <kvanb> :t otherwise
22:32:03 <lambdabot> Bool
22:32:03 <kvanb> > otherwise
22:32:04 <solidus-river> well then, good catch hlint
22:32:05 <lambdabot>  True
22:32:06 <kvanb> @src otherwise
22:32:06 <lambdabot> otherwise = True
22:32:19 <kvanb> It's for guards
22:32:24 <lfairy> solidus-river: ghc -Wall catches it as well
22:32:37 <solidus-river> can you use guards in case statements?
22:33:25 <kvanb> I wonder if LYAH mentions that otherwise is not syntax, just True
22:33:33 <kvanb> if not, any book teaching haskell really should
22:33:35 <solidus-river> i dont think it does
22:33:37 <Krenium> Nope
22:33:42 <Krenium> I just went over that chapter
22:33:52 <kvanb> it's a pretty fundamental important thing to know
22:33:53 <kvanb> imo
22:34:01 <SamB> indeed
22:34:17 <solidus-river> well, glad the compiler caught it
22:34:22 <chenwl> when using parsec to parse input string, how do I know if the parser have consumed all the input?
22:34:24 <solidus-river> er, i guess glad mod-ghc caught it
22:34:29 <kvanb> I'm surprised it was not a syntax error
22:34:38 <solidus-river> it was just a warning
22:34:43 <solidus-river> and didn't show up in a normal compile
22:34:44 <SamB> kvanb: it's not syntax, just a variable
22:34:44 <levi> kvanb: Why would it be a syntax error?
22:34:50 <chenwl> for example, runParserT (try (string "mod") <|> string "mouse") () "mouse" "mouse234324" is valid, return Right "mouse"
22:34:59 <kvanb> > let x = 2 in case (x :: Int) of { 1 -> undefined; otherwise -> 3 }
22:35:01 <lambdabot>  3
22:35:02 <SamB> which HAPPENS to be highly idiomatic
22:35:05 <kvanb> Oh
22:35:06 <kvanb> haha
22:35:07 <chenwl> but I want some warning or error from it
22:35:23 <trap_exit> johnw: whoa, was not aware yo're an op
22:35:41 <AshyIsMe> > let x = 2 in case (x :: Int) of { 1 -> undefined; blahblah -> 3 }
22:35:43 <lambdabot>  3
22:35:57 <levi> chenwl: Hmm. I know Attoparsec is good about giving you the leftovers back; not sure about whether you can get Parsec to do it.
22:37:05 <chenwl> levi: how does Attoparsec tell the leftovers?
22:37:38 <levi> Part of the result.
22:37:49 <levi> As far as I remember, anyway.
22:38:29 <lfairy> eeyup
22:40:39 <solidus-river> syntastic / mod-ghc is the best
22:44:00 <maybefbi> in a picture showing a category with its objects, its arrows, and identity arrows, are the objects all of the same type?
22:44:35 <chenwl> how do you debug Parsec?
22:44:44 <Iceland_jack> maybefbi: In a category of programs like Hask the objects are the types, so no
22:45:12 <Iceland_jack> The arrows between objects of the same type (like the identity arrows) are called endoarrows
22:45:19 <lfairy> chenwl: as you debug any haskell program
22:45:48 <maybefbi> Iceland_jack, wow so objects in category theory are more abstract than haskell types
22:46:01 <levi> chenwl: So, Attoparsec only gives you leftovers if it's been successful so far, but is waiting for more input.
22:46:11 <maybefbi> Iceland_jack, haskell types are merely one type of objects
22:46:22 <Iceland_jack> That's right
22:46:31 <trap_exit> is there a trivial example of how to use https://webproxy.vpnbook.com/browse.php?u=WVX6WEMC%2FfkkOFpx3UfEd%2BHjDdrDWe5hJ9iRmAjFdrwwcmVItLqhKZvbMoEx&b=0
22:46:45 <maybefbi> Iceland_jack, can all categories be the objects in another meta category?
22:46:52 <trap_exit> err, https://hackage.haskell.org/package/wai-app-static
22:47:08 <levi> maybefbi: Just about anything you can imagine can be an object in some category. ;)
22:47:11 <trap_exit> is there a trivial example of how to use https://hackage.haskell.org/package/wai-app-static ... I basically want a single directory mirrored on localhost:3000
22:47:19 <Iceland_jack> maybefbi: all small categories can be, you start running into size limitations otherwise
22:47:50 <Iceland_jack> But levi is right, you can form uninteresting categories for just about anything as objects
22:47:58 <Iceland_jack> *with just about
22:48:15 <maybefbi> this is deep
22:48:46 <Iceland_jack> I wouldn't call this particularly deep
22:49:13 <levi> It's not really any deeper at that level than sets.
22:49:32 <levi> You can form uninteresting sets of just about anything, too.
22:49:41 <maybefbi> why is a partially ordered set a category? thats what they say in this video: https://www.youtube.com/watch?v=BF6kHD1DAeU&list=PLGCr8P_YncjVjwAxrifKgcQYtbZ3zuPlb
22:50:06 <maybefbi> what are the arrows in a category of partially ordered sets?
22:50:09 <Iceland_jack> maybefbi: Do you know what partially ordered sets are and what categories are?
22:50:13 <levi> Because it's got objects and arrows that obey the laws.
22:51:16 <maybefbi> Iceland_jack, categories are a collection of objects and arrows and the id arrows and the composition function which follow the lows of associativity
22:51:19 <maybefbi> *laws
22:51:34 <Iceland_jack> maybefbi: right, and if you have a poset you have an identity relation
22:51:34 <Iceland_jack>     5 <= 5
22:51:56 <maybefbi> and <= is the arrow?
22:51:59 <Iceland_jack> and you have composition of relations
22:52:00 <Iceland_jack>     5 <= 6, 6 <= 10
22:52:00 <Iceland_jack>     means
22:52:00 <Iceland_jack>     5 <= 10
22:52:03 <Iceland_jack>     
22:52:06 <Iceland_jack> yes
22:52:19 <Iceland_jack> well, in my examples <= is just less-than-or-equal
22:52:29 <maybefbi> yes
22:52:52 <maybefbi> but <= has a return type which is a Bool which isnt part of the set
22:53:00 <Iceland_jack> maybefbi: you're misunderstanding
22:53:05 <Iceland_jack> there is no 'Bool' involved
22:53:15 <Iceland_jack> it's a relation, not a predicate function
22:53:30 <levi> category arrows don't have to be functions in the Set sense.
22:53:37 <maybefbi> oh so arrows arent necessarily functions
22:53:42 <Iceland_jack> exactly
22:53:56 <Iceland_jack> Functions are just one example of arrows
22:54:05 <maybefbi> i see
22:54:24 <Iceland_jack> Category of relations is a nice example of non-function arrows
22:55:10 <maybefbi> can you give me one more example of a non-function non-relation arrow?
22:55:18 <Iceland_jack> Sure, graphs
22:55:31 <Iceland_jack> or matrices
22:55:49 <Iceland_jack> any monoid forms a category
22:56:22 <Iceland_jack> and the arrows in that category consist of the elements of that monoid
22:56:33 <maybefbi> so the edges in a graph are an arrow that shows the proximity between the vertices which are the objects in the graph category
22:56:52 <maybefbi> or are graphs objects in the graph category
22:57:06 <maybefbi> and the arrows can take you from one graph to another
22:57:08 <Iceland_jack> I don't know what you mean by 'show the proximity', the nodes are the objects and the arrows are paths between those objects
22:57:58 <Iceland_jack> so if you have two cities (NY, LA) with an edge between them, that edge is an arrow
22:57:58 <Iceland_jack>     f : NY -> LA
22:58:22 <maybefbi> and the NY and LA are the objects
22:58:35 <Iceland_jack> Yes, in that example
22:59:14 <maybefbi> Iceland_jack, and matrices are categories because you can multiply them with each other?
22:59:23 <maybefbi> and the multiplication operation is that arrow?
23:00:41 <maybefbi> but it doesnt satisfy associativity
23:00:42 <Iceland_jack> If you think of objects as being natural numbers, the arrows in Hom(n, m) are m x n matrices
23:00:42 <Iceland_jack>     
23:01:06 <Iceland_jack> Beg your pardon?
23:01:27 <Iceland_jack> What does satisfy associativity
23:02:04 <Iceland_jack> The arrows here are not multiplication, they are matrices
23:02:06 <maybefbi> i think i was thinking of commutativity
23:02:10 <maybefbi> ah ok
23:02:11 <Iceland_jack> Yes you may have been
23:02:23 <Iceland_jack> Matrix multiplication is very much associative
23:02:31 <Iceland_jack> And composition is the multiplication
23:03:15 <maybefbi> hmm i guess i go back to the lecture then
23:03:22 <maybefbi> thanks for this
23:03:35 <Iceland_jack> No problem
23:03:53 <levi> So, you can view monoids as single-element categories.
23:04:12 <Iceland_jack> maybefbi: levi is making an important point
23:04:27 <Iceland_jack> Categories generalize monoids in this sense
23:04:39 <levi> And the arrows are the elements of the monoid
23:05:03 <maybefbi> and the object in the monoid category is the type of the monoid e.g. integers
23:05:07 <levi> category composition is then the monoid's binary operator.
23:05:10 <Iceland_jack> maybefbi: no
23:05:21 <Iceland_jack> there is only a single object, unrelated to the monoid itself
23:06:26 <maybefbi> why cant the object in the monoid category be related to the monoid?
23:06:36 <Iceland_jack> It can be, but it would be a different category
23:06:59 <Iceland_jack> levi was explaining how monoids are categories
23:07:26 <maybefbi> it would be a category of integer monoids if the object in the monoid category was of type integer?
23:07:48 <Iceland_jack> The object has no type
23:08:27 <Iceland_jack> If the category formed by the monoid is M then the objects of M are
23:08:27 <Iceland_jack>     obj(M) = {*}
23:08:27 <Iceland_jack> where * is the sole object of M
23:08:58 <Iceland_jack> Just like unit () in Haskell
23:09:29 <maybefbi> what about the mempty object in the monoid? shouldnt that be in obj(M)
23:09:42 <Iceland_jack> mempty is the identity arrow
23:09:52 <Iceland_jack> and is in arr(M)
23:09:55 <levi> Type Theory and Category Theory are different ways of mathematizing things. Don't get them mixed up in wrong ways. :)
23:10:08 <Iceland_jack> mempty would have type * -> *
23:10:43 <trap_exit> luite: does ghcjs have plans for something like Haste.app ?
23:10:56 <trap_exit> ghcjs: wehre a single 'codebase' generates server and client side components
23:11:01 <maybefbi> Iceland_jack, hmm ok. i need lose that type theory mindset
23:11:23 <Iceland_jack> There is also a category of monoids
23:11:34 <Iceland_jack> whose objects are what you'd expect
23:11:35 <levi> When we talk about Haskell types with relation to category theory, we're engaging in a bit of mostly reasonable fiction in which Haskell types form sets of things.
23:13:07 <maybefbi> levi, ok
23:13:09 <luite> trap_exit: you can already compile the same code on client and server and with ghcjs-dom you can build a gui app that works both as native code and in the browser
23:13:37 <trap_exit> luite: is there a way to do "typed" communication over websockets ?
23:13:40 <levi> And in which Haskell functions are functions between sets.
23:13:51 <trap_exit> luite: oh, and I figured out which step of the git hub installation instructions tripped me up
23:14:01 <luite> trap_exit: but there is no framework to automatically do calls to the other side, it should be easy to build as a library, but i'm not sure it's the right approach
23:14:12 <levi> This is also a convenient fiction that doesn't break things too often.
23:14:15 <trap_exit> luite: noted
23:14:37 <trap_exit> luite: in the ghcjs installation instructions, you have a line that says "cabal install ./Cabal ./cabal-install"
23:14:53 <trap_exit> luite: this required taht I have an existing cabal -- which on ubuntu 14, unfortunately, is out of date -- and caused all types of problem
23:15:09 <trap_exit> luite: the way I got aroudn this, was "cd Cabal; ./configure; make; sudo make insatll" and "cd cabal-install; ./bootstrap.sh"
23:15:22 <luite> trap_exit: if you want typed messages you can use Typeable and match on the TypeRep signature, use that to deserialize the right thing, for example
23:15:22 <trap_exit> luite: this avoided me from having to have an old cabal lying around, and prevented lots of problems
23:15:40 <trap_exit> luite: I suspect that this did not happen on your system since you probably have an up to date cabal
23:16:55 <luite> trap_exit: hmm, the instructions assume a working ghc 7.8 installation
23:17:10 <trap_exit> luite: yes. but I installed ghc-7.8.3 from binary
23:17:13 <trap_exit> luite: which afaik, does not include cabal
23:17:19 <luite> i implicitly assumed a suitable cabal-install there yeah
23:17:49 <jle`> all of life is a convenient fiction
23:17:51 <trap_exit> luite: http://www.haskell.org/ghc/download_ghc_7_8_3#distros , afaik, does not include cabal
23:17:53 <levi> So, all the arrows in a monoid category form what's called a hom-set. The hom-set of the 'Sum' monoid is the set of integers.
23:18:52 <luite> trap_exit: right, only the haskell platform includes it
23:19:00 <luite> i can see how this can trip up beginners :)
23:19:06 <trap_exit> luite: yes, but all haskell platform is 7.6.x
23:20:07 <levi> New haskell platform was released today, wasn't it?
23:20:20 <trap_exit> it better not be
23:20:23 <MP2E> not yet afaik
23:20:24 <trap_exit> after all the trouble i've gone through to install ghcjs
23:20:24 <augur_> i think i had an idea for how to implement type-safe pointer-y state earlier :D
23:20:27 <MP2E> an alpha release was made
23:20:36 <trap_exit> to let thers instll it without spilling blood woudl be annoying
23:20:38 <jle`> woo hoo
23:21:41 <luite> trap_exit: as an example of typed communication, this is how GHCJS communicates with a Template Haskell server running on node.js: https://github.com/ghcjs/ghcjs-prim/blob/master/GHCJS/Prim/TH/Types.hs#L54
23:21:50 <luite> trap_exit: https://github.com/ghcjs/ghcjs-prim/blob/master/GHCJS/Prim/TH/Eval.hs#L157
23:22:11 <luite> trap_exit: the basic type is just a big ADT, where GHC.Generics is used to derive the serializer
23:22:38 <trap_exit> luite: hmm, I need to learn more haskell to understand how this works
23:23:05 <trap_exit> GHC.generics looks badass (I was looking into auto serializing earlier)
23:23:07 <trap_exit> and I need to study it
23:24:17 <luite> trap_exit: but for ReifyAnnotations' the type is dynamic, see the type sig on convertAnnPayloads, you give it some Data a => a, and it matches the correct typs in the binary data ( [ByteString] ) and deserializes them using a Data.Data (also generics stuff but older than GHC.Generics) deserializer (because GHC uses that to serialize annotations)
23:25:27 <luite> trap_exit: now for real communication between a web server and client you'd probably dispatch on a type fingerprint instead of throwing out everything that doesn't match what you expected
23:25:54 <systemfault> I was looking at Network.Socket.. is it a bad joke? A super cool language like haskell having a ugly port of the C socket library as its main socket lib? Did I miss something?
23:26:13 <Iceland_jack> systemfault: Look at Network?
23:26:35 <levi> maybefbi: Anyway, you *can* bring type theory and category theory together, they just don't work together the way you were trying to make them work.
23:26:54 <systemfault> Iceland_jack: Ah, higher level functions, didn’t see them
23:26:56 <Iceland_jack> If you want to deal with sockets you can use Network.Socket
23:27:42 <maybefbi> levi, ok
23:27:54 <levi> The C socket library is more or less what sockets *are*. Anything above that is some other sort of network abstraction.
23:29:07 <levi> augur_: What do you mean by "type-safe pointer-y state"?
23:29:08 <luite> trap_exit: i just merged stack trace support in GHCJS by the way :)
23:29:20 <systemfault> levi: I get it now, thanks :)
23:29:33 <trap_exit> luite: damn it, the recompile time's going to be 2 hours on this vm I'm playing with :-)
23:29:45 <trap_exit> luite: so stack trace support = ... when exception is thrown, I can see what haskell functions casued it?
23:30:12 <Hrumph> hi
23:30:16 <luite> trap_exit: yes, but you have to compile with profiling
23:30:17 <augur_> levi: a simulation of pointers, in a way where the pointers are typed
23:30:18 <levi> There's an embarrassment of things available to layer on top of the sockets.
23:30:25 <luite> trap_exit: just like with native GHC
23:30:32 <Iceland_jack> Hrumph: hey
23:30:43 <augur_> levi: you can simulate untyped pointers over a specific type easily
23:30:54 <Hrumph> anyone want to check out my website made in yesod (still a work in progress, needs ajax and stuff)
23:31:05 <luite> trap_exit: since stack traces depend on cost centres in the generated code, which can add quite a bit of overhead
23:31:36 <luite> trap_exit: profiling support in ghcjs should follow soon now
23:31:45 <levi> luite: Awesome!
23:31:46 <augur_> levi: eg, suppose T is your value-with-pointers type, then   Map Int T   can suffice for an address space, and `Int` is your pointer type. but what if you want multiple sorts of things not just T?
23:32:05 <trap_exit> luite: do you have a real job, or do you work full time on ghcjs?
23:32:19 <augur_> levi: well one option is to wrap your types T0 T1 ... into a wrapper W   data W = WrapT0 T0 | WrapT1 T1 | ...
23:32:20 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
23:32:22 <Hrumph> what's ghcjs?
23:32:23 <trap_exit> not to imply "work on ghcjs" != "real job"
23:32:23 <joelteon> haha, a real job
23:32:29 <luite> i only have an unreal job at the moment :'(
23:32:38 <augur_> levi: but now your pointers cant tell you what type they point to. they just point to "some type wrapped by W"
23:32:42 <joelteon> luite, do you have a real job or are you just fucking around translating haskell to javascript :|
23:32:53 <trap_exit> yes, what joelteon said
23:33:15 <levi> That's a bit of a personal question to be insisting that someone answer on IRC.
23:33:27 <joelteon> you'd think the job market for people able to translate Haskell to Javascript would be *huge*
23:33:45 <luite> Hrumph: this is GHCJS https://github.com/ghcjs/ghcjs
23:34:07 <trap_exit> yes, as big as (# of haskell devs) intersect (# of javascript devs)
23:34:19 <MP2E> heh
23:34:27 <trap_exit> however, the market for people with the _talent_ to write a haskell -> js compiler should be huge
23:34:27 <levi> luite: You're using STG as your source language for the translation, right?
23:34:39 <luite> levi: yeah
23:34:55 <joelteon> i bet Hrumph can figure out what GHCJS does in only three guesses
23:34:57 <Hrumph> it would be nice if browsers had built in haskell just like they have built in javascript. has anyone been working on that?
23:35:15 <joelteon> absolutely no way in hell
23:35:41 <levi> Cool. I've been digging through the spineless-tagless G-machine paper.
23:35:43 <MP2E> heh I mean it'd be neat but you would be restricted to that one browser, whatever it was
23:36:20 <levi> Make a hugs-based plugin. :)
23:36:50 <Hrumph> MP2E you'd be restricted to whatever browsers it was built in to....same as javascript except that all the browsers did implement javascript for some reason
23:36:58 <Iceland_jack> The next version of IE is going to include a HEP (Haskell Execution Platform)
23:37:11 <cariveri> Hi. can anyone guide me through publishing a selfmade cabal package, or who is to ask?
23:37:50 <jle`> cariveri: cabal init should get you up and running pretty much :)
23:37:59 <jle`> oh, publishing
23:38:02 <jle`> there are instructions on hackage
23:38:05 <Hrumph> is there some reason why javascript is better suited to the DOM than other languages? why was javascript chosen in the first place as the language of browsers?
23:38:07 <luite> levi: cool then you should be all set to become the next contributor. stack traces are already in, profiling coming soon. i'm working on packaging and cabal myself, and on a new intermediate rep and better optimizer, so what other feature would you like write?
23:38:11 <jle`> but you can just distribute on github as well
23:38:17 <luite> levi: we don't have ghcjsi yet, want to do that?
23:38:24 <jle`> Hrumph: asking as if it was a conscious decision ;)
23:38:33 <systemfault> Hrumph: An accident…
23:38:34 <cariveri> jle`: well the point is that it is availeable on hackage afterall
23:38:54 <jle`> Hrumph: they just wanted some scripting language, and they wrote one for the specific situation
23:39:06 <jle`> they didn't think people would be writing applications on javascript
23:39:19 <Hrumph> weren't things like tcl and perl already in existance?
23:39:19 <MP2E> Yep, then it was standardized under EMCA because netscape
23:39:32 <jle`> they just thought it would be like..."on click, hide this box."
23:39:33 <MP2E> Hrumph : the big thing here is Netscape adopted JavaScript and not other langauges
23:39:36 <MP2E> in a time when that actually amttered
23:39:39 <MP2E> mattered*
23:39:50 <MP2E> it's more an accident of history now, but a deeply embedded one.
23:40:15 <luite> i wonder if ghcjsi should run in the browser or in the terminal
23:40:54 <jle`> luite: ghcjsi on the terminal would imply that you have a haskell compiler/interpreter available on the runtime?
23:40:56 <luite> i guess a terminal version is required is cabal repl is expected to work
23:41:08 <Hrumph> anyway how well does ghcjsi work? does it always create the correct javascript?
23:41:23 <luite> Hrumph: ghcjsi does not exist yet, only ghcjs
23:42:08 <luite> jle`: it would probably run the code in node.js and communicate with a native ghcjs process to compile the code
23:42:25 <jle`> luite: ah so it is a network thing
23:42:35 <luite> jle`: it would be similar to how template haskell is now set up with GHCJS
23:43:08 <jle`> ah
23:43:39 <luite> jle`: when GHCJS encounters a module with Template Haskell code, it starts a node.js process with a small runner script, then sends the RTS and compiled code for a Template Haskell evaluator to node.js
23:44:15 <jle`> luite: oh, because it requires a runtime to evaluate TH?
23:44:18 <luite> jle`: and then for each splice it first compiles the splice to JS, then sends the code, including dependencies that haven't been sent earlier yeat, to the node.js process
23:44:32 <Hrumph> luite: wouldn't users have to have to start a node js application themselves to use this?
23:44:48 <Hrumph> i thought that extensions were sandboxed so they couldn't do it
23:44:51 <luite> jle`: and node.js sends the result back, in the meantime GHCJS is available to answer queries about names, types, instances for Template Haskell
23:45:13 <jle`> luite: this is all done locally, though, on compiletime; no network involved, right?
23:45:36 <luite> jle`: this is locally, they just communicate over the standard io pipes
23:45:47 <luite> so ghcjsi could work the same way
23:45:51 <Hrumph> the one time i know i'm using node.js i have to start the app on the command line
23:46:15 <luite> jle`: template haskell requires you to run some haskell code yeah, the haskell code can depend on other packages in the package db
23:46:47 <luite> jle`: befoer this change, GHCJS always generated native code too, so it could load native libs using the GHCi linker for TH
23:47:02 <luite> jle`: but that made the setup rather inflexible, and the compiler had to do everything twice
23:47:11 <luite> plus you could have inconsistencies between the native and JS code
23:47:40 <luite> (ifdef mingw_HOST_OS, ghcjs_HOST_OS, differences in Int size)
23:48:42 <luite> so this is a major improvement, took some time to write since GHC really assumes that TH is run from within the same process
23:48:56 <luite> and other hacks to get around TH don't support many of the features
23:52:23 <jle`> int-e: does mueval impose timeout limits on :t ?  because i seem to be able to get indefinitely long :t's to execute and clog things up
23:56:18 <trap_exit> woot woot woot
23:56:22 <trap_exit> haskell happstack-lite works now
23:56:29 * trap_exit waves goodbye to erlang
