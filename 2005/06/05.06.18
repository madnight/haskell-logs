00:37:36 <xerox> 'morning
00:50:14 <dons> @code
00:50:15 <lambdabot> Monad.hs: replicateM        :: (Monad m) => Int -> m a -> m [a]
00:50:40 <dons> @code
00:50:42 <lambdabot> Instances.hs: toConstr = mkFloatConstr floatType
00:50:56 <dons> @code
00:50:58 <lambdabot> PrettyPrint.hs: -----------------------------------------------------------------------------
00:51:15 <dons> bad lambdabot
01:01:40 <xerox> @seen shapr
01:01:41 <lambdabot> shapr is in #haskell. I last heard shapr speak 20 hours, 40 minutes
01:01:41 <lambdabot> and 57 seconds ago, but I have missed 11 seconds since then.
02:16:23 <shapr> xerox: you screamt?
02:17:06 <xerox> Yeah, I have a news about the TMR problem.
02:17:58 <xerox> I discovered that moinmoin does select a nice print css when one tries to print a wikipage.
02:19:59 <shapr> oh tell me more!
02:20:15 <shapr> Have you tried to print a MoinMoin page?
02:20:52 <xerox> Still not.
02:21:04 <xerox> Let me try.
02:24:43 <xerox> Yeah, it indeed does.
02:25:16 <xerox> No wiki-specific things appear in the printed pages.
02:28:15 <TheHunter> doesn't really look pretty.
02:28:25 <shapr> Does it cut the pages decently?
02:28:45 <TheHunter> of course, not.
02:29:02 <Lemmih> Yay. HSQL-1.6 is out!
02:29:08 <xerox> Some css hackery would do it, tough.
02:29:33 <tuomov> doesn't have the tex algorithm for paragraph adjustment...
02:30:38 <Sandworm> whats MoinMoin?
02:30:49 <xerox> Sandworm, a wiki engine written in python.
02:30:54 <Sandworm> ah
02:31:14 <xerox> http://www.haskell.org/hawiki http://www.haskell.org/tmrwiki
02:31:51 <shapr> Oleg suggested a plugin for lhs2tex
02:40:14 <boegel> @y0w
02:40:16 <lambdabot> YOU PICKED KARL MALDEN'S NOSE!!
02:40:31 <shapr> @y0
02:40:32 <lambdabot> Maybe you meant: pl wn yow
02:41:01 * boegel has a headache
02:41:36 <shapr> me too
02:43:18 <boegel> and I think I'll create an even bigger one this afternoon :)
02:43:28 <shapr> How so?
02:43:28 * Heffalump dis-PLDIs
02:43:54 <boegel> shapr: party in town, all kinds of stuff going on
02:44:03 <boegel> seeing people again you haven't seen in ags
02:44:08 <boegel> s/ags/ages
02:44:30 <shapr> That sounds like fun.
02:44:45 <boegel> it is
02:44:55 <boegel> I was up until 6am last night :)
02:45:14 <shapr> If it's light again already, I call it the next day.
02:45:22 <shapr> That gets confusing here though.
02:45:56 <Heffalump> I think I just had a 4 hour night. Or maybe less.
02:46:04 <boegel> we'll yeah, I kept saying 'tomorrow I have to ...' but it was only like 10 hours away :)
02:46:13 <boegel> Heffalump: same here
02:46:21 <boegel> well, 4 hour morning actually :p
02:46:23 <Heffalump> I meant 4 hours of darkness. I got less sleep than that.
02:46:31 <boegel> Heffalump: ow :|
02:47:05 <Heffalump> (plane took off at 5:30pm from BST-6, landed at 7am BST)
02:47:21 <boegel> that's gotta hurt :)
02:47:35 <Heffalump> and my seat was broken so it wouldn't recline.
02:48:10 <Heffalump> on the way out the seat in front was broken so it kept reclining itself even when the person sitting in it didn't want it reclined.
02:48:59 * Heffalump is now somewhat miffed.
02:50:33 * boegel jumps in the shower
03:09:13 <tuomov> darkness? what's that?
03:09:49 <shapr> Synonymous with winter in this part of the world.
03:48:54 <shapr> hiya Purice
03:49:10 <Purice> hello world
03:49:20 <xerox> Howdy, World!
03:49:41 <shapr> @seen world
03:49:42 <lambdabot> world is in #haskell. Last spoke 30 seconds ago.
03:49:50 <World> oh leave me alone
03:49:58 <shapr> But you never talk to me!
03:50:05 <shapr> I always say hello, and you never respond!
03:50:13 <shapr> This is just like all those times I ask out women...
03:50:22 <shapr> But now I've realized, the whole world is against me!
03:50:34 <World> cuz i don't know haskell, dude ... i talk only assembler
03:50:42 <shapr> Oh, I guess that explains it.
03:50:51 <shapr> So, what language do women speak?
03:50:51 <kzm> shapr, what have we done?
03:51:02 <shapr> Who?
03:51:27 <kzm> (Sorry to barge in in the middle of a conversation)  We, the World at Large.
03:51:43 <shapr> Ah, the world has told me to leave it alone.
03:52:02 <shapr> And I have claimed that I always say hello, world, but I never get a response.
03:52:23 <kzm> Ah, *that* world.
03:52:28 * shapr grins
03:52:34 * kzm no longer looks confused.
03:53:01 <kzm> I have a deck of tarot cards, if you wait, I can perhaps look up what the World signifies?
03:53:58 <shapr> heh, good idea
03:54:03 * Tower is a badder card.
03:55:01 <kzm> Anyway, putStr "hello world" has type IO (), so you shouldn't expect any interesting response.
03:55:08 * kzm shrugs.
03:55:33 * kzm has to plan a birthday party for his son.
03:56:02 <kzm> Later.
03:56:08 <shapr> cya!
03:56:11 <xerox> Bye!  Enjoy :-)
04:04:17 * shapr boings
04:04:50 * xerox eats
04:04:57 * shapr chews on a lambda
04:06:39 * Lemmih will go out and enjoy the beautiful weather.
04:07:48 <shapr> My hub has finally shipped! Now I want it to get here!
04:08:19 <shapr> Lemmih: how's unicycling?
04:14:55 <Lemmih> It's OK. Been trying to juggle while idling, lately.
04:16:05 <shapr> Wow, nifty
04:16:15 <shapr> I can't even idle very well.
04:16:17 <Lemmih> It's pretty difficult to move your arms asynchronous with the motion of the uni.
04:16:46 <shapr> Hm, I'd like to try that.
04:17:56 <Lemmih> The sun is shining from a clear sky and I'm out. See ya later.
05:53:18 <nothingmuch> i need a bit of data structure advice
05:53:37 <nothingmuch> i
05:53:39 <nothingmuch> bah
05:54:05 <xerox> What?
05:54:07 <nothingmuch> i would like something like a list, but with slightly different semantics
05:54:28 <nothingmuch> it contains a data type that can refer to a list of that data type
05:54:47 <xerox> A powerlist?
05:54:50 <nothingmuch> so you can have something like [ Foo [ ... ], ... ]
05:55:00 <nothingmuch> where ... is the same thing
05:55:07 <Heffalump> [exists a . [a]] ?
05:55:11 <nothingmuch> because it's \x -> Foo x : x
05:55:16 <Heffalump> (not sure if that's valid syntax
05:55:16 <musasabi> so you want data NestedList a = Simple a (NestedList a) | Nest (NestedList a) (NestedList a) ?
05:55:18 <nothingmuch> one second
05:55:35 <nothingmuch> now the catch - i'd like to append to this thing, let's say "let list = Foo list
05:55:40 <nothingmuch> Foo list
05:55:44 <nothingmuch> damnit, fucking enter key
05:55:50 <nothingmuch> let list = Foo list' : list'
05:56:32 <nothingmuch> let blah = list ++ other
05:57:00 <nothingmuch> but let the change reflect both the list inside Foo, and the "outer" list
05:57:20 <nothingmuch> data Thing = Bar Int | Foo Thing
05:57:31 <nothingmuch> err Foo [Thing]
05:57:53 <nothingmuch> one = [ Bar 1, Bar 2 ]
05:58:04 <nothingmuch> two = (Foo one):one
05:58:15 <nothingmuch> three = two ++ [Bar 3]
05:58:39 <nothingmuch> show one => "[Foo [ Bar 1, Bar 2, Bar 3 ], Bar 1, Bar 2, Bar 3]"
05:58:56 <nothingmuch> is that making any sense?
06:01:05 <Lemmih> data Thing = Bar Int | Foo [Thing]?
06:01:35 <nothingmuch> Lemmih: yes, but that's not the point
06:02:12 <nothingmuch> show one currently yields "[Foo [ Bar 1, Bar 2 ], Bar 1, Bar 2, Bar 3 ]"
06:03:10 <Lemmih> um, lists are immutable in Haskell...
06:03:16 <nothingmuch> right
06:03:41 <nothingmuch> how would I get a similar effect
06:04:06 <Lemmih> Use IO or ST refs.
06:04:51 <nothingmuch> by making Foo contain an IORef?
06:05:00 <nothingmuch> wait, no, that doesn't cut it
06:05:48 <Lemmih> Why doesn't it?
06:06:07 <xerox> Why do you want to do so?
06:06:36 <nothingmuch> Lemmih: not as I described, I think. I'm reading a bit on IORefs, one second
06:07:13 <nothingmuch> xerox: because i need to use the structure and append it at the same time, and self references need to be more symbolic, referring to a point in the structure's current status, not an old one
06:07:20 <Lemmih> You can't break referential transparency without using the IO or ST monad.
06:07:40 <Heffalump> you can't break it even with using them
06:07:45 <Heffalump> unless you use unsafe functions
06:08:31 <Lemmih> Heffalump: An IO function will not return the same result even if you parse the same RealWorld to it twice.
06:08:36 <nothingmuch> unsafe functions also don't break it, afaik
06:08:56 <TheHunter> or getContents, for that matter.
06:09:45 <nothingmuch> can anyone point me to an IORef document that's been prechewed for impatient idiots?
06:09:57 <Lemmih> @docs Data.IORef
06:09:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.IORef.html
06:10:08 <Lemmih> @docs Data.STRef
06:10:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.STRef.html
06:10:35 <nothingmuch> Lemmih: a reference is good if you know what to look for, but I don't think I understand the metaphor of how IORef works yet
06:11:18 <michaelw> nothingmuch: think of it like a variable
06:11:36 <xerox> y0 ski
06:11:39 <nothingmuch> so to make my example work, i have a "top level" ioref
06:11:40 <Lemmih> nothingmuch: It's not very complicated. Use 'newIORef' to create a new IOref, 'readIORef' to read from an IORef and 'writeIORef' for writting to an IORef.
06:11:51 <nothingmuch> Foo points at that IORef
06:12:00 <ski> xerox : hiya
06:12:17 <Heffalump> lemmih: I wish you luck passing the same RealWorld to an IO function twice.
06:12:19 <nothingmuch> err, how do i refer to a sublist of the list inside the IORef from a Foo?
06:12:28 <xerox> ski, any news about the coalg. dt? :)
06:12:55 <Heffalump> and unsafe clearly does break it, unsafePerformIO getTime won't return the same result twice (I'm making up the name getTime)
06:14:08 <nothingmuch> sometime = unsafePerformIO getTime - is sometime the same each time?
06:14:16 <michaelw> yes
06:14:46 <nothingmuch> afaik, unsafePerformIO just extracts the value out of IO, throwing away the real world instead of preserving it for the next step in the composite action it was supposed to be a part of
06:15:05 <ski> xerox : dt ?
06:15:11 <xerox> ski, data types.
06:15:31 <Heffalump> depends if you inline sometime or not
06:15:40 <ski> xerox : dunno
06:15:52 <ski> xerox : waiting for feedback from lispy ..
06:16:18 <xerox> They sound neat.
06:16:22 <Heffalump> and yes, that's what unsafePerformIO does at the implementation level, but at the conceptual level the RealWorld parameter is a proxy for the actual real world, so what unsafePerformIO does is conceptually invalid.
06:16:39 <Heffalump> so it's only reasonable to do if the computation really is independent of the real world
06:19:33 <Lemmih> Heffalump: test = IO $ \s -> let IO fn = getLine
06:19:33 <Lemmih>                   in case fn s of (# newS,line #) -> case fn s of (# newS',line' #) -> (# newS',(line,line') #)
06:20:10 <Heffalump> you're using the internal implementation of IO there..
06:20:13 <Lemmih> Same RealWorld to an IO action gives different results.
06:20:21 <Lemmih> Yes, of course.
06:20:27 <Heffalump> which comes down to the same thing as using unsafePerformIO
06:20:37 <Heffalump> you can't possible find two identical *conceptual* real worlds.
06:21:28 <Heffalump> you can't actually fork the world like your code above does, which is why the IO monad doesn't expose any operation that lets you
06:22:05 <Heffalump> you could just as well call a C function that does arbitrary pointer writes if you want to start playing that game :-)
06:22:24 <Lemmih> My point is still valid. Referential transparency is an illusion.
06:22:38 <Heffalump> no, the IO monad is an illusion.
06:22:50 <Heffalump> but no more of one than any other library with hidden implementation details
06:23:22 <Lemmih> It still breaks referential transparency.
06:24:09 <Lemmih> (which isn't really relevant since it passes a state around without us noticing)
06:24:36 <Heffalump> yes, precisely. If you don't cheat and look at that (fake) state directly, it doesn't break referential transparency.
06:27:01 <nothingmuch> okay, i got half way to what I want
06:28:18 <ski> or, if one would use uniqueness types for the RealWorld (like Clean does), there would not be a problem even if the impl. of IO was exposed
06:28:32 <nothingmuch> okay, top of paste page
06:28:44 <nothingmuch> i'd like the list inside the Foo to not contain itself
06:29:09 <nothingmuch> e.g.
06:29:22 <nothingmuch> [ Foo [ Bar 1, Bar 2, Bar 3 ],  Bar 1, Bar 2, Bar 3 ]
06:29:29 <nothingmuch> not [ Foo [ Foo [ Foo ....
07:03:27 <dons> @code
07:03:28 <lambdabot> Random.hs: <http://random.mat.sbg.ac.at/~peter/pads98.ps>, 1998.
07:03:35 <dons> heh
07:04:06 <dons> link's still valid
07:05:21 <dons> "Don't Trust Parallel Monte Carlo!", Peter Hellekalek
07:14:00 <basti_> hi all
07:14:07 <xerox> Hiya basti_.
07:15:08 * basti_ ponders if he should work on yi-emacs, or if he should tinker around with arrows
07:15:38 * xerox votes for "yi-emacs".
07:15:51 <basti_> did you load the latest patches already?
07:16:04 <xerox> Let me see.
07:16:22 <xerox> Yeah!
07:16:41 <basti_> getting better huh
07:17:52 <basti_> i think i will need bottom line dialogs first
07:35:01 * basti_ doesnt know if he isn't overengineering that, but you can't overengineer an editor UI can you?
07:43:52 <basti_> dons: ping?
07:50:33 <basti_> dons: in case you're back, i'm off again, but bbl
09:05:05 <autrijus> instance (Typeable a, Typeable b) => Show (a -> b) where
09:05:08 <autrijus>     show _ = "(" ++ typA ++ " -> " ++ typB ++ ")"
09:05:10 <autrijus>         typA = show $ typeOf (undefined :: a)
09:05:12 <autrijus> has ambiguity issues -- can't delay unification until runtime
09:05:27 <autrijus> anyone know how to remedy it? I wonder if explicit scoping of typevars can help
09:08:55 <musasabi> autrijus: try adding -fglasgow-exts
09:09:33 <autrijus> {-# OPTIONS_GHC -fglasgow-exts -fno-warn-orphans -fallow-undecidable-instances -fallow-incoherent-instances -fallow-overlapping-instances #-}
09:09:38 <autrijus> none of those help :/
09:09:46 <musasabi> it works for me with 6.4...
09:09:56 <autrijus> musasabi: have you tried showing anything?
09:10:03 <autrijus> the error did not manifest until you do that
09:10:33 <musasabi> http://youzen.b2.fi/~musasabi/a.hs
09:10:34 <autrijus> e.g. try showing (:)
09:10:40 <musasabi> *Main> show (readFile)
09:10:40 <musasabi> "([Char] -> IO [Char])"
09:10:50 <autrijus> er, sure, for fully inhabitated type it's of course fine
09:10:53 <musasabi> autrijus: that is polymorphic.
09:10:53 <kosmikus> can't really work for polymorphic functions
09:11:19 <autrijus> because typeOf doesn't capture the head
09:11:20 <autrijus> ?
09:11:31 * autrijus ponders an even more generic typeOf.
09:11:34 <musasabi> autrijus: This is for the same reason that 'typeOf undefined' does not make very much sense.
09:11:46 <autrijus> musasabi: I'd like it to yield (forall a. a).
09:11:53 <musasabi> autrijus: typeOf needs a monomorphic argument.
09:12:02 <autrijus> like, what :i tells me
09:12:07 <autrijus> I mean :t
09:12:15 <autrijus> how is :t implemented anyway
09:12:17 <autrijus> ?
09:12:25 <Lunar^> autrijus: primop :D
09:12:38 <Lunar^> autrijus: mh.. maybe you should look in the recent CVS commits
09:12:39 <autrijus> ok, then I want the name of that primop in GHC.Exts :)
09:12:47 <Lemmih> It reads hi files, iirc.
09:12:49 <Lunar^> autrijus: I think what you want got exposed
09:12:55 <musasabi> autrijus: one can do something similar with template haskell.
09:12:55 <autrijus> oooh.
09:13:58 <musasabi> but that is limited to haskell98 datatypes :-(
09:15:23 * autrijus mumbles something about the monomorphic plot conspiracy
09:17:12 <Lunar^> autrijus: http://haskell.org/pipermail/cvs-ghc/2005-June/025519.html
09:20:07 <shapr> jiihaa
09:20:31 <Lemmih> Hello shapr.
09:20:35 <shapr> hey Lemmih
09:20:40 <Lunar^> shapr: Hi!
09:20:46 <shapr> salut!
09:21:12 <Lunar^> shapr: « salut ! » (there is a space in french typography)
09:21:40 * Lemmih found 62.5 DKK in his wallet just a moment ago.
09:21:58 <Lemmih> I wonder what I should spent the fortune on.
09:22:08 <autrijus> Lunar^: wow it handles GADTs even
09:22:10 <autrijus> nice
09:22:23 <Lunar^> autrijus: it seems so
10:12:56 <musasabi> How did one define a isFoo typeclass with the following semantics:
10:13:34 <musasabi> class IsFoo a where isFoo :: a->Bool, instance IsFoo Foo where isFoo _ = True, instance IsFoo a where isFoo_ = False.
10:14:21 <musasabi> Ghc seems to want -fallow-incoherent-instances and make the wrong choice.
10:16:00 <Lemmih> Works for me with -fallow-overlapping-instances.
10:16:14 <Lemmih> (and -fallow-undecidable-instances)
10:16:38 <Lemmih> (and, of course, -fglasgow-exts)
10:17:13 <Lemmih> *Main> isFoo (undefined::Foo)
10:17:14 <Lemmih> True
10:17:14 <Lemmih> *Main> isFoo (undefined::Char)
10:17:14 <Lemmih> False
10:17:14 <Lemmih> *Main>
10:21:03 <basti_> back-o!
10:23:00 <basti_> why are you guys discarding haskell's treasure of static typing?
10:23:04 <musasabi> Lemmih: try this:
10:23:05 <musasabi> foo :: forall a b c. a b c -> Bool
10:23:05 <musasabi> foo _ = isFoo (undefined :: c)
10:23:17 <musasabi> and suddendly it does not work :-(
10:23:53 <ski> (which is not surprising)
10:24:06 <musasabi> basti_: I am trying to use introspection of types in polymorphic code.
10:24:48 <xerox> basti_, did you need enlightenment about Yi's sources?
10:25:14 <basti_> musasabi: uhm, i'm tempted now and then, too. ;)
10:25:36 <basti_> xerox: yes, i wanted to know if there are other facilities for the bottom line than "focuscommandlineE" or whatsitsname
10:25:54 <musasabi> ski: is there any solution to this?
10:26:24 <ski> solution ?
10:26:36 * basti_ thinks, existentials would offer a solution, but its not the easy way out
10:26:43 <xerox> basti_, bottom like of the window, or of the buffer?
10:27:03 <basti_> xerox: uhm that last line of the terminal output, where msgE's are put etc.
10:27:30 <xerox> Okay, I don't currently know :-\
10:27:31 <ski> musasabi : basically you want forall a b c. Typable (a b c) => a b c -> Bool  to be equivalent to forall a b c. Typable a b c -> Bool  it seems ..
10:27:59 <basti_> xerox: afaics you can put stuff there with msgE, put the cursor there with focusCmdLineE, and put it back with unfocus...
10:28:37 <musasabi> ski: hmm. point.
10:29:09 <ski> musasabi : (i.e. all (monomorphic, at least) types per definition an instance of Typable)
10:29:31 <Lemmih> *Main> foo (undefined :: Int -> Foo)
10:29:31 <Lemmih> True
10:29:31 <Lemmih> *Main> foo (undefined :: Int -> Int)
10:29:31 <Lemmih> False
10:30:11 <basti_> what is a monomorphic type?
10:30:12 <Lemmih> Works for me.
10:30:30 <xerox> basti_, Foo ?
10:30:50 <basti_> hmm, obviously, but besides? =)
10:31:05 <ski> musabi : iirc mercury has the equivalent of  toUniv :: forall a. a -> Univ  and fromUniv :: forall a. Univ -> Maybe a    (though they have considered adding an explicit Typable-alike constraint on that, to make parametricity work)
10:31:23 <xerox> I think ski means a situation where the default ones plus every types defined has that instance.
10:31:59 <ski> yea, every normal type (i.e with no forall in it)
10:32:18 <ski> "a b c" would be monomorphic, but "forall a. a" wouldn't
10:32:19 <basti_> i stumbled over monomorphism types before. For example, i get that error (...use -fnomonomorphismrestriction) lots when i try to use arrows
10:32:25 <basti_> ahh.
10:32:47 <ski> whether Foo, defined by newtype Foo = MkFoo (forall a.a) would be monomorphic in this sense, i don't know ;)
10:33:06 <ski> monomorphism restriction is another thing
10:33:11 <basti_> oh.
10:33:12 <basti_> okay.
10:33:54 <ski> basically, with functions it is expected that the body will be reevaluated many times, i.e. not shared between several calls
10:33:56 <xerox> id! ?
10:34:18 <ski> but with variable bindings it is expected to be shared computation
10:34:38 <ski> x = "apa" ++ "bepa"  -- this is expected to be shared
10:35:36 * basti_ idly waits for the aha effect
10:35:48 <ski> but, if the code bound to the var is overloaded, and the overloading can't be locally resolved (meaning the var will get a "(FooClass ..., ...) => ..." type
10:36:28 <ski> then the impl. will under-the-hood pass around a dictionary of methods for a class instance, at runtime
10:36:42 <ski> so, the body works like a function body, anyways
10:36:49 <basti_> wow.
10:36:53 <ski> which was regarded as unintiutive
10:37:09 <xerox> Why I was thinking about id ?
10:37:14 * xerox mumbles.
10:37:29 <ski> so, you don't get to define such overloaded variables, *unless* you explicitely state the overloaded/constrained type yourself
10:37:53 * xerox praises ski for a pratical example.
10:38:00 <ski> :)
10:38:04 <basti_> lol
10:38:07 <musasabi> ski: thanks, that helped me to understand why it didn't work.
10:38:27 <basti_> ski: it scares me how good some people are in understanding this sort of stuff
10:38:28 <ski> so, iirc   bar = return . return would not be ok, without a type signature
10:38:44 <ski> bar x = return (return x)   would be ok, though
10:39:06 <ski> (because it's a function definition)
10:39:15 <ski> though
10:39:21 <basti_> :-o
10:39:32 <ski> in some common cases, it was deemed bad for beginners to have this kick in
10:39:44 <ski> lo "default" was created
10:39:46 <xerox> @type return . return
10:39:48 <ski> so
10:39:53 <lambdabot> return . return :: forall (m :: * -> *) (m1 :: * -> *) a.
10:39:53 <lambdabot>        (Monad m, Monad m1) =>
10:39:53 <lambdabot>        a -> m (m1 a)
10:39:54 <xerox> @type \x -> return $ return x
10:39:56 <lambdabot> \x -> return $ return x :: forall (m :: * -> *) (m1 :: * -> *) a.
10:39:56 <lambdabot>          (Monad m, Monad m1) =>
10:39:56 <lambdabot>          a -> m (m1 a)
10:40:04 <ski> x = 1 + 2 -- is still allowed
10:40:09 <ski> because it defaults
10:41:39 <ski> @type let x = return . return in ()
10:41:41 <lambdabot> bzzt
10:41:45 <ski> @type let x :: Monad m => a -> m (m a); x = return . return in ()
10:41:46 <lambdabot> let x :: Monad m => a -> m (m a); x = return . return in () :: ()
10:43:44 <ski> basti_ : heh (it's interesting, thus i try to learn it :)
10:43:49 <basti_> -g-
10:44:01 <ski> btw
10:44:31 <ski> some person actually came up with an example where he *couldn't* write an explicit type signature
10:44:43 <basti_> uh
10:45:13 <ski> (because he was using existential types, so to write a correct type-signature required hmm can't recall the name ..
10:45:18 <ski> anyway :
10:45:36 <ski> data Showable = forall a. Show a => MkS a
10:45:45 <ski> foo :: Showable -> ...
10:46:03 <ski> foo (MkS (x :: a)) = ...
10:46:05 <ski>   where
10:46:11 <ski>   bar :: ...a...
10:46:14 <ski>   bar = ...
10:46:32 <mflux_> so what would ghc say its type signature would be?
10:46:35 <ski> i.e. you bind a local tyvar in the pattern, and use it in local body
10:46:41 <ski> )
10:46:51 <ski> mflux_ : type sig of what ?
10:47:08 <mflux_> of the function for which the guy couldn't write the explicit type signature for
10:47:19 <ski> (anyway, writing a correct typ sig, required this feature just displayed above)
10:47:59 <ski> well, it was a local function (though, not a function binding, but value binding. possibly not even a function)
10:48:56 <ski> anyway, with an existential type like Showable, you are *forbidden* to return something from foo that has the type a somewhere inside it (except as hidden by a Showable or similar type)
10:49:24 <ski> you can't i.e. write a function like
10:49:46 <ski> data Tralala = forall a. MkT a (a -> String)
10:49:57 <ski> unTralala :: Tralala -> (a,a -> String)
10:50:02 <ski> because that would mean
10:50:09 <ski> unTralala :: forall a. Tralala -> (a,a -> String)
10:50:12 <ski> which is worng
10:50:24 <ski> what would be correct, but cannot be written is
10:50:32 <ski> unTralala :: exists a. Tralala -> (a,a -> String)
10:51:23 * ski is possibly talking too fast, explaining to little .. :/
10:52:27 <autrijus> unTralala :: Tranala -> (forall a. (a, a -> String))
10:52:33 <autrijus> surely you can write that?
10:52:35 <ski> yes
10:52:40 <ski> but thats also worng
10:52:46 <ski> it's equivalent to
10:52:50 <ski> unTralala :: forall a. Tralala -> (a,a -> String)
10:53:24 <autrijus> MkT :: a -> (a -> String) -> Tralala
10:53:24 <MarcWeber> Do you know wether the os house is just for demonstration or will it be developped to compete with the others?
10:53:48 <ski> the "forall" here means "I, the caller of this function, decide which type a should be", while the "exists" means "I, the function that returns this, will decide which type a is"
10:54:04 <ski> autrijus : yes, that is correct
10:54:22 <ski> MkT :: forall a. a -> (a -> String) -> Tralala
10:54:35 <ski> which is the reason of the use of "forall" in the "existential type"
10:54:41 <ski> data Tralala = forall a. MkT a (a -> String)
10:55:20 <ski> autrijus : when you call MkT, you get to decide which type a you want it to work for, in the particular call
10:55:28 <autrijus> ski: I already understood fully :)
10:55:39 <ski> autrijus : but when you unpack it, the choice has already been made
10:55:42 <ski> good :)
10:55:42 <autrijus> yup.
10:55:59 <autrijus> my first introduction to types is GADT :)
10:56:11 <autrijus> like, it's when I really started using haskell's type support
10:56:21 <ski> it would be nice if haskell had real "exists" in types, but it hasn't :(
10:56:27 <ski> mm
10:56:35 <autrijus> so MkT-like constructors are more familiar to me
10:57:09 <ski> ("existential datatypes+constructors" gives some of the functionality, but not all of it)
10:57:23 <ski> mm
10:57:34 <autrijus> right. you already have an escaping a.
10:57:43 <autrijus> and can't really capture it at the unpacker end
10:57:55 <ski> (iirc mercury has real exists types, btw)
10:58:09 * autrijus raises the scepter of unsafeCoerce
10:58:21 <ski> hehe, that's unsafe
10:58:29 <autrijus> not saying it is :)
10:58:41 <ski> (more like saying it is)
10:59:12 <autrijus> right.
10:59:15 <autrijus> not saying it is not.
10:59:26 * autrijus banishes moebiusive thoughts
10:59:42 <ski> (in mercury one can write the equivalent of  unS :: Showable -> exists a. Show a. a  , too)
10:59:51 <ski> moebius ?
11:00:10 <autrijus> ski: self-referentially paradoxical
11:00:16 <ski> aha
11:00:29 <ski> analogy to moebius strip ?
11:02:01 <autrijus> yeah.
11:05:47 <ski> (hm, hope i didn't scare any of you away. i sometimes gets a bit carried away ;)
11:20:00 <basti_> lol
11:23:18 <xerox> mapM_ (putStr . showW . (flip frame $ world)) [1..]
11:23:21 <xerox> oops, sorry.
11:23:39 <basti_> way to go :)
11:24:05 <xerox> I need a way to sleep for 1 sec :-)
11:24:15 <xerox> err, make the program do so :)
11:24:21 <basti_> -g-
11:24:28 <basti_> i think there is a sleep in IO?
11:25:06 <xerox> @index sleep
11:25:06 <lambdabot> System.Posix.Unistd, System.Posix
11:25:14 <xerox> :-)  Pizza time, anyway.
11:26:46 <ski> http://pizzacompiler.sourceforge.net/
11:38:54 <MarcWeber> ski: Wow.. You can learn and learn.. and you can bet someone will point you to s.th. new.. When will there be some guys inventing a virtual machine for C++ ;) ?
11:39:23 <ski> dunno
11:39:39 <ski> (possibly there exists such already)
11:39:59 <ski> (or maybe it would be too large and unwieldy)
11:40:27 <MarcWeber> Is this the same compared to operating systems? You have to wait long enough and every os will have every function (like kernels.. ;)
11:40:45 <ski> hopefully not
11:41:21 * ski would perhaps not want to use a system that had every feature i wanted ..
11:41:42 <Speck> oh boo I missed the SYB discussion
11:41:56 <MarcWeber> ski: Why not extend pizza to also support functional programming .. Da n.. I really don't know anymore which language to learn/use..
11:41:58 <zamez> I think there's a lot of pressure on some languages to get closer to C++
11:42:07 <zamez> eg. PHP's OO stuff
11:42:20 <zamez> everyone was whinging how it lacked public / private
11:42:25 <zamez> and now they've added it
11:42:34 <ski> that's not good
11:42:49 <ski> should not add something just because "X has it"
11:43:06 <Speck> well.. that isn't c++ in particular. That's so imbued in OO in general I think.
11:43:18 <ski> should be useful. and hopefully also fit into the language nicely. orthogonality and such ..
11:44:12 * ski recalls some prolog impl. (was it TurboProlog ? VisualProlog ?) that added "OO support" because "custumers wanted it"
11:45:19 <ski> (changing state of instance variables by calling assert(someVar(NewValue)) .. the horror .. no thanks)
11:47:21 <maihem> sorry to be off topic but I have just *got* to tell somebody: "Oh ... My ... God ... Dr. Who rocks!"
11:48:16 <ski> who "Dr. Who" ?
11:48:46 <Heffalump> UK TV series
11:48:48 <Heffalump> is it over now?
11:49:10 <Heffalump> (/me has no TV)
11:49:42 <maihem> yep. And the last episode is *sooo* cool. Rose Tyler (the assistant) rocks my world.
11:52:54 * ski goes back to more productive work .. figuring out how to get past these pesky worms, without getting killed ;)
11:58:08 <jlouis> ski: computer gaming?
11:58:24 <ski> yeah
11:58:30 <ski> and old but good game
11:58:34 <ski> a/and/an/
11:59:03 <jlouis> which one? I might happen to know the game
11:59:10 <ski> Dungeon Master
11:59:17 <jlouis> ;)
11:59:19 <ski> (or rather, the sequel to it)
11:59:20 <jlouis> Good game
11:59:32 <ski> yessir
12:12:42 <autrijus>         paramToArgs prm = combine
12:12:43 <autrijus>             [ if isSlurpy prm then (MkArgSlurpyArray:) else id
12:12:43 <autrijus>             , if isOptional prm then (MkArgOptional:) else id
12:12:43 <autrijus>             ] []
12:12:48 <autrijus> gawd this is ugly.
12:12:54 * autrijus wonders if there is a better way.
12:19:07 <musasabi> maybe:
12:20:08 <musasabi> paramToArgs prm = combine [ ifid isSlurpy MkArgSlurpyArray, ifid isOptional MkArgOptional] where ifid p q = if p prm then q: else id
12:20:18 <musasabi> + line breaks.
12:21:59 <autrijus> hrmph.
12:22:42 <autrijus> maybe I'll call ifid (~~).
12:33:42 <Heffalump> paramToArgs prm = combine (map (uncurry ifid) [(isSlurpy, MkArgSlurpyArray), ...]) []
13:04:39 <autrijus> @pl uncurry( \p q -> if p prm then q: else id)
13:04:40 <lambdabot> (line 1, column 35):
13:04:40 <lambdabot> unexpected reserved word "else"
13:04:40 <lambdabot> expecting space or simple term
13:04:45 <autrijus> @pl uncurry (\p q -> if p prm then q else id)
13:04:46 <lambdabot> uncurry (flip flip id . if' . flip id prm)
13:05:02 <autrijus> too pointless
13:05:20 <putter> :)
13:13:20 <Heffalump> @pl uncurry (\p q -> if p prm then q: else id
13:13:21 <lambdabot> (line 1, column 35):
13:13:21 <lambdabot> unexpected reserved word "else"
13:13:21 <lambdabot> expecting space or simple term
13:13:26 <Heffalump> @pl uncurry (\p q -> if p prm then (q:) else id
13:13:27 <lambdabot> (line 1, column 44):
13:13:27 <lambdabot> unexpected end of input
13:13:27 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
13:13:30 <Heffalump> @pl uncurry (\p q -> if p prm then (q:) else id)
13:13:32 <lambdabot> uncurry (flip flip id . (. (:)) . if' . flip id prm)
13:13:38 <Heffalump> that better? ;-)
13:14:58 <norpan> @define if'
13:14:59 <lambdabot> (line 1, column 1):
13:14:59 <lambdabot> unexpected end of input
13:14:59 <lambdabot> expecting white space or simple term
13:21:11 <xerox> @index if'
13:21:12 <lambdabot> bzzt
13:21:41 <xerox> @type if'
13:21:49 <lambdabot> bzzt
13:41:28 <Frederick> does anyone here programs in ml? like mosml
13:43:08 <jlouis> Frederick: of course ;)
13:43:20 <jlouis> this is #haskell. We dwell in odd languages ;)
13:43:33 <Frederick> jlouis may I bug you a bit?
13:43:39 <jlouis> sure
13:45:05 <jlouis> just bug me all you want ;)
13:45:17 <Frederick> jlouis I have a homework, I think im the right path justneed to clear stuff, I have 3 files: input, dictionary, output, I need to read a text from input (what I do),  read words from dic (I also do), compare them (not done yet), store into output file (not done yet)
13:46:30 <Frederick> so I need somethig like a strcmp
13:46:37 <jlouis> String.compare
13:47:01 <jlouis> load "String"; at the top of your file in mosml, then abuse the compare function ;)
13:47:36 <jlouis> it has type string * string -> order, so you will need something like case String.compare(x,y) of LESS => ... | GREATER => ... | EQUAL => ...
13:47:49 <jlouis> does that suffice to fix your problem?
13:47:51 <Frederick> http://rafb.net/paste/results/uljyyC47.html
13:49:17 <xerox> jlouis, is * our (,) ?
13:50:23 <jlouis> xerox: yes, it signifies a type (cartesian) product
13:50:55 * xerox mumbles.
13:51:29 <jlouis> compare :: (String, String) -> Ordering would be the equivalent Haskell type
13:52:34 <xerox> Why do you call a tuple a cartesian product of types?
13:52:42 <xerox> A tuple-type, even.
13:53:41 <xerox> cartesianProduct xs ys = [(x,y) | x <- xs, y <- ys] -- right?
13:54:29 <jlouis> Frederick: seems a little imperative
13:54:50 <keverets> "compare" will work on any type in the Ord class in Haskell
13:54:57 <Heffalump> isn't SML an imperative language? ;-)
13:54:58 <jlouis> xerox: yes.
13:55:12 <keverets> So, the reall haskell type would be: compare :: Ord a => a -> a -> Ordering
13:55:27 <Frederick> jlouis what do you meant?
13:55:38 <jlouis> keverets: yes, of course. I was talking about the SML String.compare function
13:55:54 <xerox> hmm.
13:55:57 <keverets> jlouis: ah, yup.
13:55:57 <jlouis> Frederick: use of ref "" and while...
13:56:15 <lightstep> what should i use instead of (map Char.toUpper) to translate a word?
13:56:19 <jlouis> Heffalump: true. SML is a little imperative language
13:57:03 <jlouis> it is often advocated as a functional language, or algorithmic functional language
13:57:26 <xerox> This cartesian product of types sounds really interesting.
13:57:49 <jlouis> xerox: it is nothing more than (,) in haskell
13:58:14 <xerox> Does it permint to make something more than tuples?
13:58:19 <jlouis> no
13:58:20 <xerox> permit, even
13:58:29 <lightstep> it permits less
13:58:43 <xerox> Oh, you can't for example (int * int) * int, or whaever else.. ?
13:58:56 <jlouis> that is possible
13:59:05 <xerox> But that's still a tuple.
13:59:10 <xerox> Hmm, okay.
13:59:21 <jlouis> if t1, t2, ... are types, the syntax grammar is: t1 * t2
13:59:30 <lightstep> type List = Nil | Cons of int * List
13:59:31 <jlouis> so t1 and t2 can itself be of tuple type
13:59:37 <xerox> lightstep, what do you mean by "it permits less" ?
13:59:47 <lightstep> you can't match Cons pair -> ..., only Cons (hd, tl) -> ...
14:00:14 <lightstep> i might be a little off on the syntax, though
14:02:04 <Frederick> I cant get it why is that? -> http://rafb.net/paste/results/I2XIc520.html
14:02:12 <mauke> yeah, but type list = Nil | Cons of (int * list);; works, at least in OCaml
14:02:55 <lightstep> still, the pattern in case expressions mush be Cons (_, _), not Cons _
14:03:21 <mflux_> lightstep, match (1, 2) with a -> 42 works fine?
14:03:30 <jlouis> lightstep: you are wrong. SML permits such pattern match constructs
14:03:50 <mauke> let foo (Cons pair) = pair;; compiles
14:04:15 <lightstep> sorry. i must have misremembered
14:04:19 <jlouis> the unification algorithm of hindley & milner handles this fine.
14:04:47 <jlouis> however, the SML type system is not as expressive as the Haskell type system. Especially with Haskelss extensions
14:04:49 <Philippa_> the _ just represents the entire pattern value
14:05:03 <Philippa_> (_,_) is a compound pattern
14:05:14 <Philippa_> no kidding
14:05:24 <Philippa_> I'm writing an article on a few semi-creative abuses for TMR atm
14:05:24 <Frederick> I cant get it why is that? -> http://rafb.net/paste/results/I2XIc520.html
14:05:48 <Philippa_> though I'm going to have to sit down and hack up some examples in a minute, at which point I'm going to have to learn the actual syntax for some of it
14:05:57 <lightstep> Frederick, are you sure the name is not used/reserved? or is there some more code?
14:06:53 <jlouis> Frederick: my mosml reports: > val getentry = fn : string -> unit
14:07:38 <Frederick> lightstep seems something with capslock
14:07:47 <xerox> Philippa_, what's special about (_,_) ?
14:08:19 <jlouis> xerox: it tells more about the structure of the type than _
14:08:35 <xerox> Indeed.
14:09:41 <Philippa_> it's a composite value
14:09:49 <Philippa_> (much as Foo 1 2 is in Haskell)
14:10:00 <Philippa_> you can match on the whole value or its parts
14:12:10 <xerox> I supposed you could actually do (_,_) pattern matching in Haskell, is it right?
14:12:39 <Philippa_> yes
14:12:52 <Philippa_> tuples're tuples
14:26:47 <Frederick> guys how do I take the words im reading here and store them on a list? http://rafb.net/paste/results/EAQtTX80.html
14:27:16 <Frederick> I found this -> http://sml.sourceforge.net/Basis/list.html#LIST:SIG:SPEC but can get how do use it
14:27:39 * TFK quietly points at hbin.dyndns.org
14:29:48 <xerox> TFK, he's doing ML, tough :)
14:30:00 <michaelw> who's running hbin?
14:30:07 <TFK> Oh, sorry
14:30:14 * TFK raises hand
14:30:33 <TFK> Stupid exams...
14:31:29 <Frederick> guys what is wrong with my list definition here -> http://rafb.net/paste/results/gKYlvh35.html?
14:31:40 <michaelw> TFK: ah, dialup, eh?  i could've offered hbin.foldr.org otherwise
14:31:59 <TFK> Well, actually a cable broadband o_O
14:32:27 <TFK> michaelw, well, it's somewhat raw now. I was going to tweak it further, but I again seem to be short on time.
14:32:44 <TFK> But I'll remember your words ;-)
14:32:50 <TFK> MUHAHAHA!
14:33:04 * TFK fades into the darkness, dramatically
14:33:06 <michaelw> okay, ask me when you think it's ready enough :)
14:34:03 * TFK nods from within the darkness
14:34:24 <Frederick> any help?
14:35:48 <jlouis> Frederick: it has wrong SML syntax
14:36:52 <Frederick> jlouis this crap has no good docs look here -> http://sml.sourceforge.net/Basis/list.html#LIST:SIG:SPEC
14:37:04 <jlouis> try: help "List";
14:37:11 <jlouis> in a mosml prompt
14:40:23 <Frederick>  help List;
14:40:23 <Frederick>       ^^^^
14:40:23 <Frederick>  Unbound value identifier: List
14:43:36 <jlouis> help "List";
14:45:57 <Frederick> didnt help much still doesnt show a good example of list usage and definition =/
14:47:36 <jlouis> tell me... how much SML have you programmed? None at all?
14:48:05 <Frederick> I had 3 classes about it 1 hour each one of them :D so im almost an expert :p
14:48:49 <Frederick> well for solving a problem I need to: 1 understand it (what I done), 2 find a possible solution (I think I have it), code (I dont know the language so it is beeing hard)
14:48:50 <jlouis> did the classes cover lists?
14:48:58 <Frederick> obviusly not
14:49:28 <jlouis> that could pose a little problem
14:49:29 <Frederick> but the teacher showed how to open mosml
14:49:39 <Frederick> jlouis yup
14:50:34 <jlouis> Lists are central in SML (and Haskell)
14:51:08 <Frederick> look, I have to compare files and store tham as ive said, so my plan is read a file (what I already do), find out how to store the read words into a list, use find into my dictionary list to see if my word is there, them prompt the user about what he wants to do
14:51:12 <Frederick> this is my plan :p
14:52:36 <jlouis> it is a good plan. However I feel I cannot teach you how to do everything and right now you look like a blind being asked what he sees
14:54:01 <jlouis> However a word of advice: don't read byte-by-byte. Read in the whole file (readAll IIRC), split it into words (see the List library). Figure out how to handle punctuation. The rest i would do like you said
14:54:26 <Frederick> jlouis I already read line per line
14:54:28 <jlouis> and... familiarize yourself with lists. They are builtin like in haskell
14:55:23 <jlouis> Frederick: no, you do not read per line. inputN reads n characters
14:56:49 <Frederick> what a heck am I missing here? -> http://rafb.net/paste/results/HUl6s984.html
14:57:44 <jlouis> let .. in .. end
14:57:58 <Frederick> ?
14:58:31 <jlouis> fun storeentry s = let val entrylist = [1,2,3] in (* if s find f l *) end
14:58:49 <jlouis> like your getentry function, right?
14:59:40 <Frederick> jlouis more or less Im trying to store the return of getentry into a list, but I will have to modify getentry to handle the file word by word
15:00:45 <Frederick> but im not sure about how to do it yet
15:01:44 <jlouis> read in the whole file instead of some bytes only. It is ineffective, but suits
15:02:24 <Frederick> jlouis I already read the whole file but it is returning me all the contents of a line and I cant handlen then
15:02:25 <Frederick> them
15:02:35 <Frederick> I want to store word by word into a list
15:03:16 <jlouis> read the whole file into a string and then split it to a list
15:03:45 <Frederick> I dont know how to split I belive Im already storing the whole file into a string
15:03:55 <jlouis> TextIO.inputAll is your first friend instead of inputN
15:04:24 <jlouis> String.tokens is your next handmaiden ;)
15:04:30 <Frederick> hold
15:04:46 <Frederick> c := TextIO.inputALL (f); !c <> "" is it right?
15:05:00 <Frederick> cause I dont have more to specify n since im readng the ehole stream
15:05:30 <jlouis> you don't even have to test if c <> "" and why even have c a ref?
15:06:01 <jlouis> besides you should soon move to #sml ;)
15:07:18 <Frederick> sml seems dead
15:07:45 <Frederick> what do you mean with c ref?
15:22:35 * Philippa_ is encoding something that looks a bit like regions in terms of the ST monad. Scary.
15:22:47 <Philippa_> (you don't get guaranteed release, though you could with the same API implemented in the compiler)
15:23:41 <jlouis> Philippa_: cool. What should they handle?
15:23:59 <Philippa_> you get to do the equivalent of running a subheap in the ST monad
15:24:17 <Philippa_> refs still tied to the heap they come from, outer refs can be dereferenced from inside a runSubHeap call
15:24:51 <jlouis> ah, ok
15:24:58 <Frederick> jlouis I think you pointed me something wrong
15:25:11 <Philippa_> so it's not massively impressive, but then again that's pretty much what regions do IYSWIM
15:25:25 <Philippa_> you don't get any whacky inference inserting new regions for you or anything
15:26:18 <Frederick> jlouis http://rafb.net/paste/results/AQredf70.html this is broken but follows yout structure in facty ive found no decent tutorials for this crap
15:30:55 <jlouis> Philippa_: the apache project uses something they call ''pools'' which are actually manually managed regions
15:31:21 <jlouis> the inference can be wacky
15:32:28 <Philippa_> yeah, I'm aware the idea's in general use
15:32:44 <Philippa_> that's precisely why I'm playing around with putting it in haskell with the appropriate typing
15:33:47 <Philippa_> the fun part's going to be adding a func that lifts a reference out a 'scope'
15:33:55 <Philippa_> ("this bit wants to live longer")
15:34:09 <jlouis> yup
15:34:26 <jlouis> you could say that you want the ref to escape
15:34:50 <Philippa_> yep. A good use for generic folds if I ever saw one
15:35:49 <jlouis> ;)
15:36:50 <Philippa_> I think one of the reasons I'm writing this particular article is to consider which of the techniques I'm mucking about with would be good in the context of a slightly different language
15:37:06 <Philippa_> a slightly different Haskell could make a wonderful system-level lang
15:37:23 <jlouis> a bit like pre-scheme?
15:37:28 <jlouis> (tiny bit)
15:37:41 <Philippa_> was thinking of going in a somewhat different direction to that
15:38:16 <Philippa_> you could have a lot of fun with a haskell with a regioned IO monad where using return evaluates a pure function in its own region before dropping the result in whichever region you asked for
15:38:21 <jlouis> me and a friend had a wacky idea about building an operating system on top of an SML runtime
15:39:23 <jlouis> scheduling handled by the compiler, inserting jumps for every x instructions
15:39:30 <jlouis> Philippa_: yeah, that could be a good idea
15:41:16 <Philippa_> it'd make for a pretty safe lang too, which is something I like
15:42:04 <Philippa_> I'd probably want to take a serious typeclasses+monad transformers approach to the standard IO libs as well
15:42:05 <jlouis> safety is definitely important. The amount of bugs sneaking in in C irritates
15:42:36 <Philippa_> though you'd need a good optimiser to make that really work, it makes it a lot easier to ensure you've done things like initialise stuff before use
15:43:22 <jlouis> yup
15:43:51 <Philippa_> another thing I'm throwing in the TMR article :-)
15:44:32 <jlouis> haha
15:44:41 <Philippa_> I might even drop the bit about GADTs and structure invariants that I've planned-but-not-written, though I'm leaving in the part about using type classes to yield a rich-man's dynamic typing
15:45:00 <Philippa_> (er, is that bitchy? ;-) A response to the dyntyping advocates' "all I care about is the object supporting the operations")
16:00:15 <jlouis> Philippa_: not at all. Having coded Python for a couple of days was enough to get me on track again.
16:03:32 <Philippa_> heh
16:04:02 <Philippa_> I've not coded in a 'good' dynamically-typed language, but the idea of /having/ to use tests really bugs me
16:04:15 <jlouis> about 9/10 of the bugs you make in python is either indentation or... more often... type
16:04:35 <Philippa_> yeah, funny that
16:05:32 <Philippa_> then again, it probably says a lot about me that I've sat down and done (not completely original or impressive) research on type systems born out of a desire to use the result
16:28:28 * Philippa_ just had another *click* moment re extensions to Haskell's type system
16:41:36 * Philippa_ thinks a mo longer
16:41:44 <Philippa_> geez that doesn't half make the kind system complicated, but hey
16:54:39 <Speck> type classes > duck typing
16:54:57 <Speck> I'm completely converted :-)
16:55:06 <autrijus> well, being able to toggle between the two is a win
16:55:08 * autrijus likes Boo
16:55:18 <Speck> I was reading about boo
16:55:33 <Speck> I didn't get into it enough, but I should definitely revisit it
16:55:50 <Philippa_> autrijus: have I ranted about ADTs and subtyping at you before?
16:56:24 <Philippa_> (A=Algebraic here)
16:56:40 <autrijus> Philippa_: no. you think subtyping is da cool?
16:57:09 <autrijus> recently I have discovered with GADTs I can get all the subtyping semantics I want
16:57:18 * Philippa_ blinks
16:57:27 <Philippa_> what's the trick?
16:57:45 <autrijus> basically covering all your types in a GADT ;)
16:57:54 <autrijus> and rely on type classes to signify subtyping relationship
16:57:54 <Philippa_> ah, so it's closed-world
16:57:57 <autrijus> right.
16:58:03 <autrijus> definitely
16:58:15 <Philippa_> then again, that's the right thing in this particular case
16:58:19 <Speck> btw autrijus, I enjoyed your paper on metaclasses
16:58:30 <Philippa_> given that, you can encode n-tuples as a single datatype
16:58:57 <Philippa_> complete with means of typing first, second, third et al once and for all
16:59:26 <Philippa_> (you just build a type-level list, essentially)
17:00:30 <Philippa_> anyway, I'd spent a while playing around with the idea of subtyping on ADTs as a language extension - it pretty much works, you typically want them to be closed-world to get the right pattern-matching semantics, and the result has an... interesting relationship to type classes
17:00:39 <Philippa_> none of this overly surprising, right?
17:01:34 <Philippa_> well, I just realised that while less common, open-world algebraic datatypes and closed-world type classes both make sense in certain situations. Not that big a deal really, except it does coincidentally give you sufficient grunt to properly type a fully dynamic system
17:03:08 <Lunar^> Philippa_: would that finally get us extansible exceptions?
17:03:39 <Philippa_> yeah
17:03:51 <Philippa_> they'd just be another open-world algebraic datatype
17:04:51 <Lunar^> Philippa_: mhh.. I'm looking forward to read your next paper then :)
17:04:57 <Philippa_> heh. Papers, me?
17:05:11 <Philippa_> I'll see if I can post a general kick-around-the-idea thing in TMR
17:05:17 <Philippa_> but don't hold your breath
17:12:44 <Speck> Do Haskell coders use HUnit for testing? It seems like since Haskell is so declarative, test would be mostly redundant.
17:13:09 <Speck> The same question applies to testing in general.
17:15:25 <Philippa_> testing is a good idea if you're writing anything IO-heavy
17:15:39 <Philippa_> hell, if you're writing anything that does more IO than calling interact
17:16:52 <arjanb> i guess QuickCheck (http://www.cs.chalmers.se/~rjmh/QuickCheck/) is most used for testing in haskell
17:17:18 <Speck> I haven't seen that. I'll look into it.
18:34:00 <machack666> I'm struggling with what seems like should be a straight-forward problem.  I'm wanting to generate a list of n random Ints where e_i is in the range [0,n-i).  I want the PRNG to be seeded with a provided value, so a function signature for this is myRandDesc :: Int -> Int -> [Int].
18:35:02 <machack666> I have been using randomR as the range-generation function, and 'iterate (next . snd) (0,mkStdGen)' to give me a list of PRNGs.
18:35:38 <Igloo> Isn't there a randomRs function or similar to make a list like you want?
18:36:00 <machack666> Does randomRs let you specify a new range each time?
18:36:20 <Igloo> Ah, sorry, misread what you wrote
18:38:43 <machack666> I'm new to haskell and FP in general.  My approach right now is to use `map myRandProcess $ zip [1..n]'  to tie the index with the corresponding PRNG and try to apply a helper function to handle the actual generation.
18:39:21 <machack666> I seem stuck in a type issue where it is showing `no instance of (RandomGen Int)'
18:39:58 <machack666> I have tried to use pattern matching to extract the Int from the value, but it wants to see the RandomGen as a data constructor and not a type.
18:40:40 <Speck> mm... eggplant parmesan
18:42:09 <Igloo> Do you mean "No instance for (RandomGen Int)"?
18:42:25 <machack666> yes
18:42:33 <Igloo> "RandomGen Int" isn't a type there. It's saying there isn't an instance of the class RandomGen for the type Int
18:42:49 <Igloo> Probably you aren't using mkStdGen somewhere you should be
18:43:41 <machack666> so is it saying that I am trying to provide an Int where I should be supplying a type in the RandomGen class?  I could have reverse the tuples from zip...
18:43:59 <Igloo> It is
18:44:18 <machack666> let me see if I can spot it...
19:26:42 <shapr> hoi myss
19:26:50 <shapr> Hoe gaat het?
19:26:54 <myss> goed
19:27:12 <shapr> Apprenez vous Haskell?
19:27:19 <myss> u peu
19:27:33 <shapr> tycker du om den? :-)
19:27:55 <myss> ik had appreandre verward met comprendre :)
19:28:06 <myss> lang geleden
19:28:11 <shapr> Well, close enough
19:28:24 <shapr> Actually, I think I should have used tÃ¤nker instead of tycker, oops.
19:28:30 <shapr> Trivs du med Haskell?
19:28:40 <myss> !Ã§Ã¨"rÃ§! ?
19:28:56 <shapr> No swedish? :-)
19:29:01 <myss> neen
19:29:07 <shapr> Aw, too bad.
19:29:18 <shapr> It's okay, I don't really speak Dutch.
19:29:37 <myss> are you swedish?
19:29:37 <shapr> It's 4am! Did you just wake up?
19:29:47 <shapr> No, I'm from Alabama, but I happen to live in Sweden.
19:29:50 <myss> no, i didn't sleeop
19:30:08 <shapr> I used to live in Finland.
19:30:33 <shapr> Finnish is a difficult but fun language.
19:30:42 <shapr> minÃ¤ haluan suklaata!
19:30:51 <shapr> (I want chocolate!)
19:30:52 <myss> I don't understand
19:31:05 <myss> I am Turkish, they say
19:31:12 <shapr> So how did you find your way to #haskell? Are you a student?
19:31:19 <myss> that finnish looks like turkish in some aspects
19:31:34 <myss> yes, i am a tudent
19:31:35 <shapr> I've heard that both languages are agglutinative.
19:31:42 <myss> yes
19:32:03 <shapr> So, do you like Haskell? Do you have any questions?
19:32:10 * xerox looks at the clock
19:32:19 <shapr> Good morning xerox!
19:32:24 <shapr> Actually, I'm about to go to sleep.
19:32:28 <xerox> Me too!
19:32:29 <myss> I fact not (for the question)
19:32:45 <myss> I an bored, and wanted to see some chats :)
19:33:05 <xerox> I asked a question to a person 5 hours ago.  He finished answering more or less... now.
19:33:05 <shapr> There are some excellent chats here on #haskell, but most people are asleep now.
19:33:16 <shapr> xerox: Wow, what was the question?
19:33:18 <myss> I see
19:33:28 <xerox> shapr, that's the secret!
19:33:32 <shapr> Oh, ok
19:33:50 <shapr> myss: The best chats happen in the evening European time.
19:33:51 <xerox> Let's say it's always a pleasure to talk about math with my big cousin :)
19:33:57 <shapr> Ah, I see
19:34:41 <myss> But I am not bored in the evening while sleeping.
19:35:15 <xerox> OK, I probably need sleep.  'night shapr, & you sleeping lambdafolks.
19:35:15 <shapr> The chats here on #haskell might be more fun than whatever else you were doing.
19:35:19 <shapr> g'night xerox
19:35:23 <shapr> I should sleep now also
19:35:40 <shapr> g'night myss, you should come back when we're all awake!
19:35:44 <xerox> myss, and you, so-called Turkish boy! ;)  zZzZ
19:36:02 * shapr goes off to sleep
19:36:06 <myss> good  night
19:36:17 <myss> or better good morning
20:01:13 <Speck> Eastern Standard Time gets no love in #haskell :-(
20:02:54 * Lemmih hands some love to Eastern Standard Time.
20:03:25 <dons> @timein Sydney
20:03:27 <lambdabot>  Sunday, June 19, 2005 at 1:04:29 PM EST
20:03:32 <dons> *that's* EST
20:16:39 <kaol> @timein Helsinki
20:16:41 <lambdabot>  Sunday, June 19, 2005 at 6:17:42 AM EEST
21:03:49 <machack666> is there a "unzipn" function if I want to distribute the elements of a list into an arbitrary number of partitions ?
21:04:59 <machack666> i.e., cases where the number of partitions is unknown at compile-time?
21:05:35 <dons> unknown at compile time... hmm
21:05:59 <machack666> so I can't just use unzip3 and friends
21:06:32 <machack666> the type signature would have return a list of lists, rather than a tuple of lists.
21:06:34 <dons> you can't use anything that returns a tuple -- becaues the size is encoded in the type -- which must be known statically
21:07:21 <dons> so you want a: split :: Integer -> [a] -> [[a]] ?
21:07:56 <dons> @hoogle [a] -> [[a]]
21:07:58 <lambdabot> List.tails :: ([a] -> [[a]])
21:08:06 <dons> sort of, hoogle.
21:08:12 <machack666> yes, but preferrably it would distribute the items piecemeal -- rather than in a block, as I assume split would do
21:09:28 <dons> sounds like you'll have to implement it ;)
21:10:19 <machack666> just wanted to check before I did.  I'm not really familiar with the base libraries.
21:10:28 <dons> unzip3   =  foldr (\(a,b,c) ~(as,bs,cs) -> (a:as,b:bs,c:cs))
21:10:28 <dons>                   ([],[],[])
21:10:38 <dons> unzip    =  foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
21:11:50 <dons> so you  instead need to parameterise your unzipLN on the size of the chunk to distribut
21:12:06 <dons> L=List, N=n-ary-sort-of
21:12:12 <dons> :}
21:12:29 <machack666> sounds good :D
21:13:53 <machack666> so, unzipLN :: Int -> [a] -> [[a]]
21:14:14 <dons> it's really unrelated to unzip, maybe it should be called a split?
21:14:23 <dons> a la perl's split
21:14:41 <dons> s/unrelated/not the same as/
21:14:43 <machack666> splitDist for distributed?
21:14:59 <dons> splitN?
21:15:52 <machack666> splitN is too suggestive of split1, split2, etc, which does not make sense to me.  Something which connotates rotation, perhaps?
21:16:08 <dons> sure. your function, you get to name it :)
21:16:34 <dons> oh, I see. it's not splitting , as you say. it's distributing each chunk.
21:16:58 <dons> hmm.  it could use a splitN, then distribute the resulting chunks, couldn't it?
21:18:09 <machack666> we'd have to split on length(list) div N, which could give problems with infinite lists
21:18:47 <machack666> I guess we could just do a take n
21:19:08 <machack666> and append each corresponding element to the corresponding list
21:20:21 <machack666> (I was thinking we'd do a split and then transpose above)
21:20:53 <dons> let splitN _ [] = [] ; splitN n s = let (t,ts) = splitAt n s ; ts' = splitN n ts in (t:ts')
21:22:22 <dons> @plugs let splitN _ [] = [] ; splitN n s = let (t,ts) = splitAt n s ; ts' = splitN n ts in (t:ts') ; in splitN 2 "abcdefghijkl"
21:22:24 <lambdabot> ["ab","cd","ef","gh","ij","kl"]
21:23:31 <dons> oh, but you want only n lists at the end, after the distribution
21:23:46 <dons> not m lists of length n :/
21:23:52 <machack666> right, that suffers from the same transposition problem
21:27:20 <machack666> I was trying to do something funky with mapAccumL, but was not having much luck
21:28:17 <machack666> heh, how about the list function transpose? ;)
21:28:22 <dons> hmm, but it seems like a fold to me, not a map
21:29:03 <machack666> @type transpose
21:29:09 <lambdabot> bzzt
21:29:09 <dons> but this is hard to do without the nice pattern matching in unzip*
21:29:30 <dons> oh, I guess mapAccum is a map and a fold
21:29:53 <machack666> use your splitN and transpose the resulting matrix.
21:30:15 <dons> @type Data.List.transpose
21:30:16 <machack666> not sure what it would do on a generator, but fortunately all my cases are finite.
21:30:17 <lambdabot> Data.List.transpose :: forall a. [[a]] -> [[a]]
21:30:36 <dons> @plugs Data.List.transpose [[1,2,3],[4,5,6]]
21:30:38 <lambdabot> [[1,4],[2,5],[3,6]]
21:31:07 <dons> @plugs let splitN _ [] = [] ; splitN n s = let (t,ts) = splitAt n s ; ts' = splitN n ts in (t:ts') ; in transpose (splitN 2 "abcdefghijkl")
21:31:09 <lambdabot> ["acegik","bdfhjl"]
21:31:15 <dons> hehe
21:32:14 <machack666> cool.
21:32:36 <machack666> thanks for the help
21:32:44 <dons> sure :)
21:33:25 <Speck> oo.. hacking
21:33:54 <dons> on a generator... hmm...
21:33:57 <dons> @plugs let splitN _ [] = [] ; splitN n s = let (t,ts) = splitAt n s ; ts' = splitN n ts in (t:ts') ; in transpose (splitN 2 [1..])
21:33:59 <lambdabot> [[1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,
21:33:59 <lambdabot> 49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,
21:33:59 <lambdabot> 95,97,99,101,103,105,107,109,111,113,115,117,119,121,123,125,127,129,
21:33:59 <lambdabot> 131,133,135,137,139,141,143,145,147,149,151,153,155,157,159,161,163,
21:33:59 <lambdabot> 165,167,169,171,173,175,177,179,181,183,185,187,189,191,193,195,197,
21:34:00 <lambdabot> 199,201,203,205,207,209,211,213,215,217,219,221,223,225,227,229,231,
21:34:02 <lambdabot> 233,235,237,239,241,243,245,247,249,251,253,255,257,259,261,263,265,
21:34:04 <lambdabot> [24 @more lines]
21:34:05 <dons> yay for laziness.
21:34:44 <machack666> too bad you never get any evens...:)
21:34:47 <hyrax42> is a construction like (t, ts) meaning first and rest?
21:35:14 <dons> you get evens, they're the 2nd elem of the list.
21:35:26 <machack666> hyrax42: t:ts would be first and rest
21:35:45 <machack666> hyrax42: (t,ts) is a two-element tuple that is being bound to.
21:35:46 <hyrax42> is the s suffix a syntax construct?
21:35:54 <hyrax42> or an identifier
21:36:01 <machack666> hyrax42: convention.  The names are arbitrary
21:36:04 <hyrax42> ok
21:36:11 <hyrax42> cos I've seen it elsewhere is all
21:36:15 <machack666> is a 2-tuple a twople?
21:36:15 <hyrax42> but know no haskell
21:36:18 <machack666> ;)
21:36:20 <dons> tuple
21:36:31 <dons> hehe
21:36:43 <dons> but what's a (n) then?
21:36:51 <dons> and uple?
21:37:05 <dons> unapple?
21:37:16 <Speck> monupple
21:37:31 <Speck> eigenupple
21:37:32 <dons> and that leaves us ()
21:37:40 <hyrax42> niltuple?
21:37:46 <machack666> I suppose (x,y) where x = y would be a duple
21:37:47 <Speck> nupple
21:37:51 <hyrax42> haha
21:37:52 <dons> uniple?
21:38:48 <Speck> now, what's a tuple that goes thump in the night?
21:39:29 <Speck> that also discos
21:39:29 <machack666> since n is arbitrarily large, it is assumed that at some point to get to an n that noone has reached before; thus it is a newple.
21:40:26 <machack666> hmm... too bad there's not a dictionary ordered by phonemes...
21:40:36 * machack666 fully expects to be corrected
21:41:48 <machack666> hoople?  i give up.
21:56:32 <machack666> is a function name unique for a particular type signature or globally?
21:57:26 <machack666> i.e., can I have a `myFunc :: Int -> Bool' and a `myFunc :: Int -> Int -> Bool' both named `myFunc' and rely on the type system to dispatch to the correct function?
21:57:53 <machack666> or once myFunc is defined for a particular type, it's off limits for use in other places in the module?
22:00:55 <machack666> n/m ghc complains about multiple definitions for myFunc
22:06:38 <Cale> machack666: Have a look at typeclasses
23:11:53 <dons> @y0w
23:11:55 <lambdabot> Let's send the Russians defective lifestyle accessories!
23:11:58 <dons> @code
23:12:00 <lambdabot> MVar.hs: (\e -> do putMVar m a; throw e)
23:12:06 <dons> @code
23:12:07 <lambdabot> Locale.hs: , ("min","mins")
23:12:52 <dons> @code
23:12:54 <lambdabot> Directory.hs: On Windows, the function checks for the existence of environment variables in
23:15:45 <dons> @code
23:15:46 <lambdabot> Info.hs: compilerVersionRaw = __GLASGOW_HASKELL__
23:15:52 <dons> heh
23:15:57 <machack666> Couldn't match the rigid variable `a' against `[a]'
23:15:57 <machack666>       `a' is bound by the type signature for `replaceElem'
23:16:06 <machack666> anyone seen this error before?
23:18:42 <dons> when I screw up existentials, sometimes
23:18:57 <dons> but it's probably simpler than that
23:19:36 <ski> what is the type of replaceElem ?
23:19:46 <dons> @code
23:19:47 <lambdabot> Num.lhs: integer2Int (J# s d) = case (integer2Int# s d) of { n# -> I# n# }
23:19:51 <ski> what is the code that is exhibiting the said error ?
23:20:01 <machack666> [a] -> Int -> a -> [a]
23:20:27 <machack666> basically, I'm trying to take a list and replace a single element identified by the Int index with a new element
23:20:41 <machack666> I'm writing a bf interpreter FWIW
23:20:49 <ski> possibly you can paste the code at
23:20:51 <ski> @paste
23:20:52 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
23:23:05 <machack666> I've got pasted.  I know that replaceElem is broken ATM, but this should give you some context.
23:23:22 <ski> mm, looking
23:24:05 <ski> @type replicate
23:24:06 <lambdabot> replicate :: forall a. Int -> a -> [a]
23:24:23 <ski> possibly you want  replicate 30000 0 instead
23:24:36 <ski> though that isn't causing this type error
23:24:52 <machack666> ski: yes.  Going from memory, if you can call it that with something so new.
23:25:36 <ski> Bf is a type synonym for some list type ?
23:26:21 <machack666> yes, Bf is the list of expressions to be evaluated
23:26:37 <ski> ok  type Bf = [Exp]  it seems
23:26:48 <machack666> yes
23:27:23 <machack666> Exp is which of the 8 operation to perform
23:27:58 <ski> mm
23:29:03 <ski> (looking at replaceElem, now)
23:29:42 <ski> replaceElem does not use elem at all
23:29:56 <ski> also, it prolly shouldn't be using the list monad
23:30:11 <machack666> it's supposed to do something like h ++ [elem] ++ (drop 1 hs)
23:30:18 <ski> prolly shouldn't be using a monad at all (i.e. no do-expression at all)
23:30:22 <ski> yeah
23:30:48 <ski> try putting the splitAt call in a let or where clause
23:31:19 <ski> like ... where (front,oldElem:back) = splitAt ...   -- e.g.
23:31:36 <ski> and skip the do
23:31:53 <ski> got an idea how to fix it now ?
23:32:49 <machack666> I think so... I will need to review the exact syntax for let.
23:33:37 <ski> let ..definitions.. in ..expression..
23:34:02 <ski> like,   let x = 2*3 in x + x
23:34:08 <machack666> ok
23:34:13 <dons> @plugs let x = 2*3 in x + x
23:34:14 <lambdabot> 12
23:34:27 <ski> or  let (a,b) = divMod 15 7 in a*b - b
23:34:46 <ski> a where clause is like
23:34:48 <Speck> In 'return' for the monadic instance of Maybe, what about Haskell lets you write "return = Just"? Why doesn't it need to be "return x = Just x"?
23:34:51 <machack666> replaceElem isn't causing problems anymore.  Now I'm getting ptr being returned as Interp->Int rather than Int
23:34:53 <ski> function args ... = body
23:34:54 <ski>   where
23:34:57 <ski>   ..definitions..
23:35:19 <ski> Speck : it's the same things
23:35:29 <Speck> I realize it's the same thing :-)
23:35:42 <Speck> But just isn't nullary
23:35:44 <ski> Speck : return x = Just x   means the same as  return = \x -> Just x
23:35:54 <machack666> Speck: it's returning a function with a partial application
23:36:08 <ski> more or less, yes
23:36:21 <ski> (except, there aren't any applications at all there)
23:36:58 <ski> but, a similar example would be   allSquare = map (\x -> x*x)   instead of  allSquare xs = map (\x -> x*x) xs
23:37:16 <ski> (which is a partial application of 'map')
23:37:30 <Speck> one sec while I digest
23:37:41 <machack666> never mind about my problem with the Interp -> Int
23:37:46 <Speck> ok I get it
23:38:02 <Speck> thanks
23:38:19 <machack666> I neglected to have a (local alias?) in the i@Interp{...} structure for doExp for ptr
23:38:26 <machack666> not sure of the terminology
23:38:36 <Speck> eta reduction
23:38:50 <Speck> err, that wasn't for machack
23:39:05 <Speck> just thinking out loud
23:39:44 <machack666> got it. :)
23:40:07 <ski> 'i' is an alias for the Interp structure/reecord, yes
23:42:03 <machack666> so when I define an alias like that with the i@Interp{ptr=ptr,region=region}, is the terminology for the interior a=a's `local accessors?'
23:43:20 <ski> the 'ptr' etc to the right of the '=' in the record patter are just sub-patterns that happen to be variables
23:43:38 <machack666> ok.
23:43:46 <ski> i guess you could call them 'local accessors' if you want to
23:43:46 <machack666> haskell's pattern matching is pretty cool
23:44:08 <ski> you can write like
23:44:15 <machack666> I'll just be pragmatic and use them until I understand them.  :D
23:45:07 <ski> foo (Interp {ptr = 42,region=[1,2,x,3]} = ..x.. --if you want
23:45:28 <Speck> Here's another one, in the first informative note (the blue i) on this page(http://www.nomaware.com/monads/html/class.html), it says it's better to type a function such that it works with all monads instead of specific ones. That makes sense, but is there an example illustrating the utility of that generalization?
23:45:38 <ski> not that this would be particulary useful in this current example
23:49:42 <machack666> ok, well thanks for the info.  I'm sure I'll be back later.
23:53:18 <ski> Speck : e.g. sequence, mapM
23:53:23 <ski> @type mapM
23:53:24 <lambdabot> mapM :: forall b (m :: * -> *) a.
23:53:24 <lambdabot>    (Monad m) =>
23:53:24 <lambdabot>    (a -> m b) -> [a] -> m [b]
23:53:29 <ski> @type sequence
23:53:30 <lambdabot> sequence :: forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
23:54:08 <Speck> I'll look more closely at sequence and mapM, thanks.
23:54:22 <ski> also, sequence_ and mapM_
23:54:31 <ski> @type liftM
23:54:33 <lambdabot> bzzt
23:54:39 <ski> @type Control.Monad.liftM
23:54:41 <lambdabot> Control.Monad.liftM :: forall r (m :: * -> *) a1.
23:54:41 <lambdabot>         (Monad m) =>
23:54:41 <lambdabot>         (a1 -> r) -> m a1 -> m r
23:54:43 <ski> @type Control.Monad.liftM2
23:54:45 <lambdabot> Control.Monad.liftM2 :: forall r (m :: * -> *) a2 a1.
23:54:45 <lambdabot>         (Monad m) =>
23:54:45 <lambdabot>         (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:54:49 <ski> etc
23:54:52 <Speck> gotcha
23:55:00 <ski> m
