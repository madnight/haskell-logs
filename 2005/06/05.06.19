01:12:46 * Lemmih ponders why his FastCGI app is so slow.
01:29:24 * Speck advises Lemmih to look at memory usage, as fcgi seems to always be leaking memory
01:31:04 <Lemmih> I was testing one of Bringert's FastCGI examples without looking too closely at the source.
01:31:37 <Lemmih> He has a 'threadDelay 40000000' in there for some reason.
01:32:29 <Lemmih> It became a lot faster after I commented that line out. (:
01:33:15 <Speck> interesting
01:34:41 <Speck> I wonder why there is a tendency in Haskell code to write variables (I know not the right word for it) with just one letter.
01:35:08 <Speck> I think readability could be vastly improved if people used more meaningful identifiers...
01:35:24 <Lemmih> Agreed.
01:35:40 <Lemmih> But then we would have to type a lot more (:
01:35:47 <mflux_> lemmih, emacs' dynamic completion ;)
01:36:00 <mflux_> of course, doesn't yet work with only one letter though..
01:36:10 <Lemmih> Does it work at all?
01:36:18 <mflux_> work at all?
01:36:30 <mflux_> I use it all the time
01:36:44 <Lemmih> I've been using emacs for a while and haven't noticed such feature.
01:36:48 <mflux_> M-/
01:37:09 <mflux_> after you've written a few characters of the word
01:37:15 <mflux_> (or atleast one ;))
01:37:26 <Lemmih> COOL!
01:37:38 <Speck> hehe
01:37:47 <mflux_> after getting used to using it it reduces typing and typoing
01:38:01 <Lemmih> Why didn't anyone tell me before now?! (:
01:38:05 <mflux_> sorry ;)
01:38:21 <mflux_> I do infact think I've mentioned this feature to someone on the channel before..
01:38:30 <mflux_> the response was about the same ;)
01:39:07 <mflux_> dynamic completion is more useful if you're using module X and you have the module's source code opened in a buffer
01:39:18 <mflux_> as it grabs the dynamic completion stuff from all the open buffers
01:39:49 <mflux_> though I guess it prefers the current buffer and even then the more near the word is the higher priority it gets
02:24:22 <dons> @code
02:24:24 <lambdabot> Alloc.hs: mallocBytes      :: Int -> IO (Ptr a)
02:24:31 <dons> @code
02:24:32 <lambdabot> Eq.hs: {-# OPTIONS_GHC -fno-implicit-prelude #-}
02:24:41 <dons> @code
02:24:42 <lambdabot> STRef.hs: modifySTRef :: STRef s a -> (a -> a) -> ST s ()
02:29:58 <Lemmih> Hurrah. haskell-fastcgi is three times faster now.
02:30:30 <Lemmih> @hoogle Int -> Ptr a -> IO ([a] -> [a])
02:30:31 <lambdabot> Prelude.flip :: ((a -> b -> c) -> b -> a -> c)
02:31:30 <Lemmih> Eh?
02:32:01 <TheHunter> @type flip `asTypeOf` (undefined :: Int -> Maybe a -> IO ([a] -> [a]))
02:32:08 <lambdabot> bzzt
03:44:51 <xerox> 'morning
03:45:02 <Lemmih> Yo, xerox.
03:45:07 <seidan> evenin'
03:48:35 <_JusSx_> hi can u suggest me a good console ncurses cd ripper?
03:50:27 * TheHunter uses abcde. it's not exactly good, but does the job.
03:54:04 <Philippa_> I try to use letters that're initials for a role - i for identifier, r for return, things like that
03:54:23 <Philippa_> if it's just-a-parameter, I tend to use x
03:57:19 <xerox> @karma+ mflux_
03:57:20 <lambdabot> mflux_'s karma raised to 2.
04:01:12 <TheHunter> hehe, that's what i do, too. "abcde" is a cd ripper :)
04:01:35 <Philippa_> ah
04:01:39 <Philippa_> d'oh, missed the context
04:01:44 <Philippa_> it's way, waaaaay too damn hot around here
04:02:31 <TheHunter> yah, same here, though most people falsly describe that as "nice wheather".
04:03:07 <Philippa_> folks're mostly too busy trying to string two coherant thoughts together while their brain overheats to do that here right now
04:03:16 <Philippa_> I got a load done on a TMR article yesterday...
04:03:23 <Philippa_> after dark, funnily enough
04:03:42 <Heffalump> my perl binding has stopped compiling.
04:04:47 <xerox> It's indeed way too damn hot.
04:49:12 <shapr> It's not too hot here.
04:53:34 * jewel ownz the hotness debate
04:54:35 <shapr> y0 jewel, did you want your user page deleted from the HaskellWiki?
04:54:43 <jewel> yes
04:54:47 <shapr> awright
04:54:47 <jewel> what was going on there?
04:55:00 <shapr> What do you mean?
04:55:34 <jewel> I wasn't allowed to delete it
04:55:46 <shapr> Deleting a page isn't undoable, so that feature isn't enabled by default.
04:55:58 <shapr> I'm the admin, so I can do it for you.
04:57:18 <shapr> How hot is it where you are?
04:57:19 <jewel> ok
04:58:15 <jewel> I don't have a thermometer, but I've never worn a sweater in the last 3 months
05:09:47 <xerox> shapr, check this out: http://www.w3schools.com/css/css_ref_print.asp
05:13:16 <xerox> I was thinking that maybe it would be enough to put a "p { page-break-inside: avoid }" in the print css of MoinMoin.
05:47:40 <shapr> Oh, that's interesting
05:52:05 <astrolabe> Too hot and humid here too.  I don't sleep till the early hours.
05:55:35 <MarcWeber> Is there an existing library for linear interpolation?
05:58:11 * shapr snips AngryClip 
05:58:22 <shapr> Avast ye procedural lubber!
05:58:29 <shapr> @arr
05:58:30 <lambdabot> Well me hearties, let's see what crawled out of the bung hole...
05:58:41 <shapr> AngryClip: So, are you learning Haskell?
05:59:18 <shapr> Speck: hey, there's a really good reason for one letter identifiers.
06:00:04 <shapr> Speck: When you're talking about higher order functions that encapsulate basic behaviours, then the most significant part is not the variables, but instead the pattern of the computation.
06:00:28 <shapr> In that case, you want the values themselves to fade into the background, but you want the 'shape' of the code to stand out like a spotlight.
06:01:07 <shapr> Admittedly, single letter variables do get overused in Haskell. I see a lot of cases where the variables need a good significant name and don't have one.
06:03:05 <shapr> Are hs-plugins and yi cabalized?
06:03:13 <shapr> Should lambdabot be cabalized?
06:05:19 <reffie> cabalized?
06:06:16 <shapr> http://www.haskell.org/cabal/
06:08:20 <reffie> ah
06:09:05 <michaelw> shapr: haskellers seem to prefer types as documentation over variable names
06:09:19 <shapr> Hm, not always.
06:09:28 <shapr> But you do have a good point there.
06:12:23 <shapr> coi djul
06:12:55 <astrolabe> Is there a good way in haskell to represent a 2d array? Ugh this expressions-have-constant-values thing is doing my head in.
06:13:58 <xerox> ...a Set?
06:14:18 <astrolabe> I'll check it out xerox.  Thanks.
06:16:48 <Philippa_> anyone know where I can find an unsafe coerce func? I have need of it
06:17:23 <Lemmih> There's unsafeCoerce# from GHC.Exts
06:18:39 <Philippa_> guess that'll do for now
06:19:24 * Philippa_ thinks a moment
06:19:32 <Philippa_> no, I shouldn't need it, I've goofed more subtly than that
06:19:43 <xerox> @type GHC.Exts.unsafeCoerce#
06:19:49 <lambdabot> GHC.Exts.unsafeCoerce# :: forall b a. a -> b
06:21:00 <zugzwang> Hello. Sorry if this is an FAQ, but google isn't helping much. What does it mean when ghc spouts alot of error messages (presumably from ld) along the lines of
06:21:03 <zugzwang> ./codify.o(.text+0xec5): In function `r2Hk_info':
06:21:05 <zugzwang> : undefined reference to `ControlziMonadziState_zdfMonadTransStateT_closure'
06:22:13 <Lemmih> Compile with --make or '-package mtl'
06:24:11 <zugzwang> Lemmih: ah cheers
06:26:19 <Philippa_> grr. Bloody monomorphism restriction
06:39:25 <TheHunter> @plugs let foo = 1 in (foo,foo) :: (Int,Integer)
06:39:38 <lambdabot> Couldn't match `Integer' against `Int'
08:25:28 <tony2> I'm just learning aobut monads, would anyone have a minute to answer a quick question?
08:25:37 <Lemmih> Sure.
08:26:40 <tony2> well, inside a do loop I'd like to perform an IO action n times. I figure I need some kind of loop, but haven't a clue.
08:26:56 <Lemmih> There are no loops in Haskell.
08:27:15 <tony2> I realise that,
08:27:35 <Lemmih> You can do it with recursion.
08:27:36 <tony2> is there some way to perform an IO action n times
08:27:45 <tony2> oh crap its easy isn't it
08:27:49 <tony2> lol
08:28:00 <tony2> yes I see.
08:28:39 <astrolabe> Let me guess?  You just have to know how to do it n-1 times?
08:28:53 <tony2> :)
08:30:48 <Lemmih> @type (foldr (>>) return .) . replicate
08:31:11 <lambdabot> (foldr (>>) return .) . replicate :: forall a (m :: * -> *) a1.
08:31:11 <lambdabot>              (Monad ((->) a1), Monad m) =>
08:31:11 <lambdabot>              Int -> (a1 -> a) -> a1 -> m a1
08:31:53 <Lemmih> hrm..
08:32:57 <xerox> @type let f n a | n <= 0 = error "?!" | n == 1 = a | otherwise = a >> f (n-1) a in f
08:33:10 <xerox> zZzZ
08:33:22 <Lemmih> Why is lambdabot so slow today?
08:33:25 <lambdabot> let f n a | n <= 0 = error "?!" | n == 1 = a | otherwise = a >> f (n-
08:33:25 <lambdabot> 1) a in f :: forall a
08:33:26 <lambdabot>                               (m :: *
08:33:28 <lambdabot>                                 -> *)
08:33:30 <lambdabot>                               a1.
08:33:32 <lambdabot>                             (Ord a,
08:33:34 <lambdabot>                             Monad m,
08:33:36 <lambdabot>                             Num a) =>
08:33:38 <lambdabot>                             a -> m a1 -> m a1
08:33:44 <Lemmih> @type (foldr (>>) (return()) .) . replicate
08:34:09 <lambdabot> (foldr (>>) (return()) .) . replicate :: forall a (m :: * -> *).
08:34:09 <lambdabot>               (Monad m) =>
08:34:09 <lambdabot>               Int -> m a -> m ()
08:34:16 <xerox> OK :)
08:34:31 <Lemmih> @pl return ()
08:34:32 <lambdabot> return
08:34:35 <Lemmih> ...
08:35:32 <Lemmih> TheHunter: It's buggy (:
08:53:39 <autrijus> wow. I saw that weirdly shaped (m::*)... type from lambdabot
08:53:47 <autrijus> and I thought: "what a weird cow picture"
08:54:30 <xerox> ahahah!
08:54:49 <xerox> * Cow replicating IO actions *
08:55:24 <autrijus> :D
09:02:13 <TheHunter> @pl foo ()
09:02:14 <lambdabot> foo
09:02:16 <TheHunter> @pl ()
09:02:18 <lambdabot> ()
09:02:28 <autrijus> @pl () ()
09:02:30 <lambdabot> ()
09:02:43 <TheHunter> not sure what @pl thinks () is.
09:02:44 <autrijus> @pl () () ()
09:02:45 <lambdabot> ()
09:02:51 <autrijus> something transient.
09:07:49 <TheHunter> ok, () gets parsed as a variable with an empty string as name
09:09:13 <TheHunter> same for "() ()".
09:09:35 <TheHunter> @pl () f x
09:09:37 <lambdabot> (f) x
09:09:42 <TheHunter> @pl () f x y
09:09:44 <lambdabot> (f) x y
09:13:05 <TheHunter> Lemmih, it's on the todo-list :)
09:14:24 <TheHunter> ooh, already 10 failing tests...
10:00:10 <hyrax42> where does one turn to learn about monads
10:00:14 <hyrax42> in the abstract, not in haskell
10:00:24 <hyrax42> do they fall under category theory?
10:02:13 <ibid> the math does
10:02:42 <ibid> in cs, also denotational semantics theory
10:03:06 <hyrax42> that is stuff in PLT right?
10:03:19 <ibid> PLT?
10:03:37 <hyrax42> isnt' that short for porgramming languge theory?
10:03:38 <hyrax42> :(
10:03:49 <ibid> possibly :)
10:04:03 <hyrax42> hmm
10:04:14 <ibid> i usually write it theory of programming languages, which makes it TPL or ToPL :)
10:04:20 <hyrax42> possible denotational semantics in sin prog lang theory or posslibly p
10:04:21 <hyrax42> ah
10:04:23 <ibid> but, to answer yous question, yes
10:04:30 <hyrax42> I guess avoids confusion with the scheme
10:04:43 <hyrax42> but TPL is Types and Programming Languages
10:04:52 <hyrax42> not enough 3 letter abbreviations
10:04:56 <ibid> i don't usually abbreviate it
10:05:08 <ibid> if i abbreviate something, i use POPL
10:05:17 <ibid> which is fairly well known
10:05:25 <hyrax42> POPL?
10:05:34 <ibid> principles of programming languages
10:05:52 <hyrax42> arr
10:05:52 <ibid> there's a conference series of that name, and a semi-standard cs course
10:06:00 <ibid> arr?
10:06:14 <hyrax42> pirate agreement?
10:06:16 <hyrax42> ;)
10:06:32 <ibid> sounded to me like a local variable of an array type :)
10:06:59 <hyrax42> arr
10:07:01 <hyrax42> :p
10:07:40 <hyrax42> what is the "best" editor for haskell code?
10:07:46 <hyrax42> some emacs mode?
10:07:59 <ibid> yi, i suppose, never having tried :)
10:08:09 <ibid> i use the emacs mode that's packaged in debian
10:08:14 <hyrax42> yi?
10:08:17 <ibid> it's not perfect but it does work
10:08:38 <xerox> @google dons yi
10:08:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
10:08:54 <hyrax42> yeah I beat you lambdabot
10:08:56 <xerox> @google haskell-mode-2.00
10:08:58 <lambdabot> No result found.
10:09:13 <xerox> You'd better use that until Yi raises to the point of being useful ;)
10:09:19 <xerox> @google haskell mode 2.00
10:09:20 <lambdabot> http://list-archive.xemacs.org/xemacs-beta/200408/msg00105.html
10:09:25 <hyrax42> heh
10:09:26 <xerox> @google haskell-mode 2.00
10:09:27 <lambdabot> http://ftp.is.xemacs.org/pub/xemacs/Attic/packages/oldpkg/package-index.2003-04-10
10:09:30 <xerox> HMPF.
10:09:32 <hyrax42> but Yi has a paper
10:09:39 <ibid> @google haskell-mode
10:09:39 <hyrax42> !
10:09:40 <lambdabot> http://haskell.org/haskell-mode/
10:09:41 <xerox> Yi has a describing paper.
10:09:50 <xerox> ibid, that page is out-to-date I think
10:09:55 <ibid> xerox: whatever :)
10:10:01 <ibid> @google haskell-mode debian
10:10:02 <lambdabot> http://www.haskell.org/hawiki/HaskellMode
10:10:06 <ibid> no...
10:10:18 <xerox> http://www.iro.umontreal.ca/~monnier/elisp/
10:10:29 <xerox> http://www.iro.umontreal.ca/~monnier/elisp/haskell-mode-2.0.tar.gz
10:10:32 <ibid> http://packages.debian.org/unstable/devel/haskell-mode
10:10:33 <xerox> This works pretty well.
10:11:09 <TheHunter> code written using that haskell-mode is often annoyingly indented.
10:11:11 <autrijus> hm, anyone know if there's existing code for emitting IL from haskell?
10:11:25 <xerox> TheHunter, what do you suggest?
10:11:53 <autrijus> maybe I should just write to ask emeijer.
10:11:56 <TheHunter> i use vim. But I think (hope) you can indent sensibly using emacs, too.
10:12:19 <bourbaki> moin
10:12:23 <TheHunter> moin
10:12:57 <bourbaki> TheHunter: feeling better today?
10:13:07 <TheHunter> yeah, thanks.
10:13:30 <bourbaki> did you reread the log?
10:13:46 <TheHunter> one should always indent at fixed levels, i.e start a new line after a do/let etc.
10:13:50 <TheHunter> not yet.
10:14:09 <musasabi> @seen shapr
10:14:10 <lambdabot> shapr is in #haskell. Last spoke 4 hours, 1 minute and 45 seconds
10:14:10 <lambdabot> ago.
10:15:09 <TheHunter> that way, the code doesn't tend infinitely to the right, in changes in a previous line don't mess up the whole layout.
10:15:41 <bourbaki> and that away anything in one scope is on the same level
10:45:46 <basti_> hi
10:45:59 <xerox> yo.
10:46:26 <bourbaki> moin basti_
10:46:38 <basti_> its very warm today.
10:46:46 <basti_> in germany
10:47:10 <bourbaki> :)
10:47:21 <ski> very warm in southern sweden, too :(
10:47:43 <bourbaki> in my flat its quite cold
10:47:59 <basti_> "very warm" in southern sweden = 20Â°
10:47:59 <basti_> ?
10:48:05 <bourbaki> :)
10:48:11 <bourbaki> -20 ;)
10:49:08 <ski> a termometre in the sun here shows 31 degrees
10:49:26 <basti_> in the sun it doesnt count.
10:49:35 <ski> of course
10:49:46 <ski> so, maybe it's 20 (celcius) ..
10:49:50 <basti_> no because a black thermometre would show lots more than a white one
10:50:03 <ski> it's metal
10:50:05 <bourbaki> basti_: its about 30 degs here isnt it?
10:50:16 <basti_> we had 30 today yes
10:50:25 <basti_> i dont think its anywhere near still
10:50:36 <basti_> but still something like 23
10:51:47 <bourbaki> an hour ago i went outside to get me a chilli cheese gyros baguette and nearly changed my agregation state :)
10:51:59 <tuomov> about 22C in central finland..
10:52:17 <tuomov> but windy so it isn't that warm
10:52:19 <basti_> -g-
10:52:47 <bourbaki> 22 isnt warm anyway :)
10:52:55 <tuomov> quite ok weather really.. I don't care for too much heat
10:53:02 <bourbaki> and if its really warm wind isnt a cure eiter
10:53:18 <bourbaki> its ok as long as you dont have to move :)
10:53:24 <basti_> i *like* warm weather if i'm lazy and outside
10:53:32 <basti_> it sucks if you're inside though
10:53:42 <bourbaki> basti_: depends on where you are
10:53:55 <basti_> thats what i said :)
10:54:01 <bourbaki> the room i am sitting in has a balkony to a garden in the shades
10:54:12 <bourbaki> its quite cold here
10:54:34 <basti_> ah.
10:54:37 <tuomov> sucks trying to get sleep after a hot day
10:54:51 <basti_> well we're on the sunny side. but i dont mind that much. really.
10:54:57 <basti_> its worse to be on the shadow side.
10:55:47 <bourbaki> basti_: er pardon :)? why?
10:56:26 <basti_> because in the winter you freeze your butt off.
10:56:39 <basti_> and it sucks to have it dark all the day
10:56:44 <tuomov> learn to built warm houses..
10:56:53 <nothingmuch> is there anything like a diff array but with mutable bounds? or do i have to reconstruct one manually and keep track of how much data i've used?
10:56:53 <tuomov> dark's nice inside
10:57:05 <basti_> tuomov: youre so right
10:57:13 <bourbaki> basti_: but i have the other side too that is on the sun site :)
10:57:14 <basti_> about the warm houses
10:57:34 <basti_> bourbaki: well then you must be at least a groÃŸkapitalist.
10:57:43 <basti_> :=
10:57:44 <basti_> ;)
10:57:54 <bourbaki> i wish
10:58:20 <basti_> i can only afford to share 48 mÂ² with my gf, and thats expensive already :/
10:58:31 <nothingmuch> someone must have created an IArray instance which is a triple and a diffarray
10:59:02 <bourbaki> basti_: where you you live?
10:59:33 <xerox> AMD warms my house more than the sun, anyway, if I close every windows and so.
10:59:40 <basti_> marburg.
11:00:12 <bourbaki> basti_: ah heh :) i have been studying in fulda once thats not too far away if i am not mistaken
11:00:33 <basti_> half an hour or something
11:01:23 <bourbaki> and you study cs?
11:01:46 <basti_> yes
11:02:35 <bourbaki> im hopefully able to quit at the end of this semester and go working again
11:02:57 <basti_> :)
11:03:38 <bourbaki> and in a couple of years ill go for my next study :)
11:04:10 <basti_> uhm, quit successfully, or without a grade?
11:04:14 <basti_> and, what will you study then?
11:04:37 <bourbaki> this is the 4th study im most likely not finishing
11:04:56 <bourbaki> the next study could be math or meteorolgy
11:05:07 <basti_> ah.
11:05:22 <basti_> as long as it's not history of the arts or something
11:05:50 <bourbaki> heh
11:06:01 <bourbaki> history is quite interesting though
11:06:26 <basti_> depends.
11:06:30 <tuomov> some of it
11:06:33 <basti_> it doesn't work, thats the problem.
11:06:42 <tuomov> but the stuff that is thought in primary and secondary schools is b00000ring
11:06:49 <tuomov> s/thought/taught/
11:07:04 <basti_> how many genocides have there been in the world? substract 1 and you got the number that history studies could have avoided.
11:07:07 <bourbaki> im not talking about the history you learn in school
11:07:39 <bourbaki> i just have finished baudolino an umberto eco book
11:08:10 <basti_> eco is great
11:08:15 <bourbaki> yep
11:08:42 <bourbaki> and also the history of the kelts and germans is quite interesting
11:08:49 <basti_> one of the few sane people who have something to say.
11:09:03 <bourbaki> afaik there also is a lot of stuff to find there still
11:09:28 <tuomov> movements of peoples stuff is rather interesting indeed.. and quite a lot of waving hands
11:09:44 <basti_> huh?
11:09:53 <bourbaki> ie ive seen a report some days ago that the germans also produced mumies
11:10:20 <tuomov> so little is known of that old things
11:10:46 <bourbaki> yep
11:10:52 <bourbaki> as i said especially here
11:11:07 <bourbaki> you can still achive a lot in this field
11:11:22 <bourbaki> a friend of mine is a maya archeologist
11:11:36 <basti_> oh they dug up quite a lot down there recently
11:11:41 <basti_> lots of work
11:11:49 <bourbaki> yep
11:11:55 <bourbaki> thats the beauty
11:12:23 <bourbaki> the history of the old ppl here is harder since there are so much cities and so around here
11:12:33 <bourbaki> and the romans have been here and such
11:12:42 <basti_> yes.
11:12:54 <bourbaki> and napoleon
11:12:59 <basti_> and the farmers
11:13:25 <basti_> and woods grow and are harvested
11:13:26 <bourbaki> my granddad found some coins of some napoleon soldiers in our garden
11:14:16 <bourbaki> the historians thought that the ppl here in germany where quite dumb at the time the aegyptians where ruleing and such
11:14:34 <bourbaki> but with these mumies that they found they are debateing over that again
11:14:53 <bourbaki> its really thrilling and its also really interesting what ppl like eco then make out of that
11:15:01 <bourbaki> basti_: have you read baudolino?
11:15:03 <basti_> its not a matter of dumbness. they just didnt develop any writing
11:15:05 <basti_> nope
11:15:27 <basti_> i just read some of his non fiction texts on the web
11:15:28 <bourbaki> oh i think they had writeings
11:15:38 <bourbaki> keilschrift
11:15:45 <basti_> uhm.
11:15:47 <bourbaki> but the romans destroyed alot
11:15:51 <basti_> "cueniform" btw.
11:16:01 <bourbaki> you know with all that duirds and so
11:16:49 <bourbaki> basti_: oh i see i read the name of the rose in school and baudolino now its just a bit disturbing to read those books cause you are sure that he wants to tell you something but you are never sure what it is
11:16:50 <basti_> well afaik theres not a single document thats not runes (which were rather rare and used ritually)
11:17:01 <basti_> heheh
11:17:17 <bourbaki> ah right runes
11:17:31 <bourbaki> but i am quite sure that they wrote something down
11:18:03 <bourbaki> since these runes are an alphabet its also likely that they didnt use them as hyroglyphs
11:18:09 <basti_> not to the extent of other old cultures...
11:18:26 <basti_> afaik theres not a single continues text in runes.
11:18:34 <basti_> continuous
11:18:35 <bourbaki> none that we know o
11:18:36 <bourbaki> f
11:18:57 <bourbaki> as i said they thought that the ppl here where quite dumb at that time here
11:19:03 <bourbaki> running around in the woods with clubs
11:19:05 <basti_> that doesnt mean they're dumb
11:19:27 <basti_> there are a few places where they found quite elaborate houses
11:19:58 <bourbaki> what epoch are you talking about?
11:20:15 <bourbaki> these mumies they found are like 3000 BC
11:20:15 <basti_> BC, some are thousands BC iirc
11:20:21 <bourbaki> oh
11:20:38 <bourbaki> i have heared some days ago that they depate the cradle of men again
11:20:54 <bourbaki> they think that asia might be the cradle
11:21:17 <basti_> probably depends where you start to talk of humans
11:21:57 <bourbaki> i think they just found some older skeletons in china or so
11:22:44 <basti_> i mean... if i hear those things then i always think about that someone should go and teach the people what we already know first...
11:23:17 <bourbaki> :) youd just need to buy a magazine like national geographics or so
11:23:17 <basti_> i know this guy who thinks the earth is 6000 years old
11:23:35 <bourbaki> i wish these docu channels would be free on tc
11:23:37 <bourbaki> er tv
11:23:48 <bourbaki> hehehe who is that :)?
11:23:58 <basti_> i wish people could think
11:24:05 <basti_> he doesnt show up on IRC
11:24:13 <bourbaki> the mayans had a way to calculate the birth of the world also
11:24:17 <astrolabe> I am tc.
11:24:49 <bourbaki> and they thought that there were more then one world and so
11:24:58 <bourbaki> astrolabe: tc?
11:25:12 <bourbaki> basti_: you wouldnt believe what ppl think the world is like
11:25:23 <basti_> i think you dont understand. he doesnt believe as in "yea sure thats true". he thinks its a "first order fact"
11:25:23 <basti_> as in "your foot hurts if you drop a stone on it"
11:25:23 <astrolabe> believe it or not, astrolabe is not my given name
11:25:39 <bourbaki> there are a lot of strange sects like these tower guys and so
11:25:45 <bourbaki> and cristians
11:25:55 <basti_> its not a matter of belief
11:26:10 <basti_> if someone believes he can only pray to his deity with a fish in his hand, i wont stop him
11:26:24 <bourbaki> basti_: :) as i said you wont believe what ppl think is fact :)
11:26:43 <basti_> but if he believes the world is 6000 years old, thats plain stupid. thats beyond normal religious stupidity.
11:26:46 <bourbaki> there are ppl who think that small men live in their head that tell them what they have to do and so
11:27:03 <basti_> yes and these are locked up now and then
11:27:10 <basti_> if they're too obnoxious
11:27:13 <bourbaki> to me thats not more or less stupid then believeing in god or so
11:27:35 <basti_> yes thats why i think everyone who thinks a voice controls their life should be locked up
11:27:49 <basti_> but thats just justice, best would be if NOONE would be locked up for what happens in his head
11:27:58 <bourbaki> doesnt that include all religious ppl then?
11:28:09 <basti_> well there are sane religious people
11:28:26 <basti_> i would even go as far as to claim most are pretty sane
11:28:28 <bourbaki> since i am studying cog sci its not too flabbergasting to me that ppl think that they have a voice in their head
11:28:50 <basti_> actually we all have, kinda
11:28:53 <bourbaki> i think that a lot of ppl have that voice its just that ppl inerpret it differently
11:28:57 <bourbaki> right
11:29:16 <basti_> but some think this voice is annoying, or that it would tell them things they dont want to do
11:29:24 <basti_> or that it would control their lives.
11:29:27 <bourbaki> the problem with them is that this "feedback" loop is ... selbstaendiger i nthem
11:29:27 <basti_> or something
11:29:30 <bourbaki> er in them
11:29:44 <basti_> ah.
11:29:51 <bourbaki> do you know what sensory deprivation is?
11:29:55 <basti_> yes.
11:30:06 <bourbaki> everyone starts to hallucinate then
11:30:12 * basti_ did intentional deprivation with or without ketamine a few times.
11:30:14 <basti_> =)
11:30:31 <bourbaki> imho thats quite the same effect its just that they cant suppress that recursive feedback from their thoughts
11:30:47 <bourbaki> basti_: ?
11:30:54 <basti_> never heard about ketamine?
11:31:06 <bourbaki> sure animal tranquilzier
11:31:19 <basti_> well its used for humans too
11:31:31 <basti_> its not a tranquilizer, its a "dissociative narcotic".
11:31:37 <bourbaki> and you used a floating tank then or what?
11:31:47 <basti_> it stops some funny nerves
11:31:59 <bourbaki> heh funny nerves :)?
11:32:00 <basti_> no, blankets and ping pong balls for the eyes
11:32:07 <basti_> and white noise for the ears
11:32:16 <bourbaki> ah i see
11:32:29 <basti_> uhm well its hard to descripe what it feels like. "out of body"
12:40:02 <lightstep> @index foldl'
12:40:03 <lambdabot> Data.List
12:40:16 <lightstep> @type Data.List.foldl'
12:40:21 <lambdabot> Data.List.foldl' :: forall a b. (a -> b -> a) -> a -> [b] ->
12:40:21 <lambdabot> a
12:40:23 <xerox> @hoogle foldl'
12:40:25 <lambdabot> Prelude.undefined :: a
12:41:13 <lightstep> oh my, Data.List isn't the same as List
12:42:09 <Heffalump> it isn't?
12:42:19 <lightstep> @type List.foldl'
12:42:26 <lambdabot> bzzt
12:42:52 <lightstep> surprisingly, the prelude doesn't specify it
12:53:10 <mflux_> I think there was a discussion some time ago if there could be instructions in cpus for, or could cpus be designed in some other way to accommodate, functional programming
12:53:30 <mflux_> of course, there are some examples of this, there is the symbolics lisp machine
12:54:13 <mflux_> but I wonder if there could be some features in the cpu to accommodate writing micro kernels. that is, some fast way to pass messages between processes/threads, with memory protection etc..
12:54:46 <basti_> yes.
12:54:48 <basti_> definitely
12:55:04 <basti_> current cpu's are adapted to monolthic kernels because of coevolution
12:55:04 <mflux_> or does validity checking bog the things down? although monolithic kernels need to do the checking too, so maybe not
12:55:22 <mflux_> but if so, would proof carrying code be able to solve that problem
12:55:50 <basti_> i dont see any relation between the kernel architecture and checking the code
12:56:45 <mflux_> I'm thinking there is a lot of message passing and at all points the messages are checked.. and with a microkernel propably the internal messages would be checked too?
12:57:02 <mflux_> whereas with macrokernels only messages between the userspace and the priviledged state would be checked. propably.
12:57:23 <mflux_> of course, nothing prevents one from not checking the messages even with a microkernel, or maybe having a hack to not check messages from trusted peers
12:58:09 <basti_> uhm
12:58:22 <michaelw> mflux_: micro/exo kernels were debated in the TUNES project (http://cliki.tunes.org/Microkernel%20Debate)
12:59:06 <basti_> i believe microkernels make more sense than monolithic, generally.
12:59:18 <basti_> i do not see why this would force us to do any more checking than there though
13:04:13 * autrijus praises type system innovations
13:04:26 <autrijus> multiple screenful of code is reduced to two lines:
13:04:26 <ski> ;)
13:04:27 <autrijus> instance (Show (m a), FunctorM m, Typeable1 m, Compile a b) => Compile (m a) (m b) where
13:04:31 <autrijus>     compile = fmapM compile
13:04:33 <autrijus> :)
13:08:47 <jlouis> autrijus: hah, nice
13:09:05 * Heffalump tries to work out if he wants to spend >£800 on going to ICFP
13:09:17 <xerox> Impressive.
13:11:42 <autrijus> granted, it currently only simplifies the [a] and Maybe a code
13:11:52 * autrijus wonders if there's a way to derive functorM using Trans and lift
13:12:25 <autrijus> probably not, as it will only apply to some underlying monad types, and FunctorM only accepts one type
13:12:30 * autrijus ponders FunctorTrans
13:12:57 <Heffalump> what is functorM?
13:17:06 <autrijus> Heffalump: fmap to map is what fmapM is to mapM
13:19:07 <jlouis> map this monad structure with function f
13:19:12 <jlouis> rather nice
13:19:15 <lightstep> @type mapM
13:19:23 <lambdabot> mapM :: forall b (m :: * -> *) a.
13:19:23 <lambdabot>    (Monad m) =>
13:19:23 <lambdabot>    (a -> m b) -> [a] -> m [b]
13:19:24 <Heffalump> autrijus: so functorM is fmapM?
13:19:29 * Heffalump is confused ;-)
13:19:37 <autrijus> class FunctorM f where
13:19:39 <autrijus>     fmapM :: Monad m => (a -> m b) -> f a -> m (f b)
13:19:42 <autrijus>     fmapM_ :: Monad m => (a -> m b) -> f a -> m ()
13:19:43 <autrijus> there :)
13:19:46 <lightstep> so fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)?
13:19:55 <Heffalump> ah, so FunctorM is a class
13:20:09 <autrijus> right. it was my typo of typing it as functorM
13:20:36 <autrijus> I was thinking along the lines of
13:20:58 <autrijus> instance (MonadTrans f) => FunctorM f where
13:21:02 <autrijus>     fmapM = ...lift...
13:21:09 <autrijus> but it needs cooperation from the lower monad
13:21:25 <autrijus> which can't be expressed via FunctorM alone
13:21:38 <Heffalump> that doesn't sound correctly kinded to me
13:21:48 <autrijus> and you'd be right.
13:21:51 <autrijus> that was just an intuition :)
13:22:30 <Heffalump> should every Functor also be a FunctorM?
13:23:06 <jlouis> should every data-structure being an mapable also be a Monad?
13:23:26 <hyraxforytwo> hmm
13:24:05 <jlouis> I have a hunch it is possible to monadify many data structures
13:24:15 <Heffalump> Functor doesn't imply Monad
13:24:40 <lightstep> can you give an example?
13:25:41 <Heffalump> not easily, because I'd have to prove that you couldn't possibly make up a >>= that satisfied the laws
13:26:04 <autrijus> Heffalump: you mean  instance (Functor f) => FunctorM f where fmapM = ... ?
13:26:10 <Heffalump> I have a suspicion that a binary tree isn't one, though
13:26:11 <autrijus> I don't see an obvious way of deriving that.
13:26:24 <Heffalump> autrijus: no, I mean should it be possible to write fmapM for anything that has an fmap?
13:26:29 <arjanb> FunctorM seems related to the IFunctor in http://www.haskell.org/pipermail/haskell/2004-July/014315.html
13:27:06 <autrijus> Heffalump: hm, I'm confused; if it's possible forall fmap, then surely my instance above captures the automation?
13:28:01 <autrijus> fwiw, in the standard library of GHC, Queue is a Functor but not a Monad.
13:28:23 * autrijus tries to think how =<< will look like for Queues and fails
13:28:33 <Heffalump> autrijus: sorry, I didn't mean necessarily automatable, but intuitively possible
13:28:43 <autrijus> ah.
13:28:59 <autrijus> my intuition-fu is weak on this. I can see maybe some functors doesn't match well with some underlying monads.
13:29:02 <Heffalump> though I guess any decently convincing argument would also lead to an automatable version.
13:29:24 <autrijus> *nod*
13:30:19 <jlouis> binary trees for one, yes
13:30:21 <ski> lightstep : i think e.g. Stream do not make a Monad, but a Functor
13:31:11 <ski> data Stream a = Cons a (Stream a)
13:32:38 <autrijus> right, as it has no nil
13:32:59 <Heffalump> nil isn't essential, per se
13:33:12 <Heffalump> but I think a valid >>= is impossible
13:33:19 <autrijus> how do you define >>= then?
13:33:21 <autrijus> ah.
13:33:34 <Heffalump> you can define an invalid one by diagonalising
13:33:35 <lightstep> (Cons x xs) >>= f = interleave (f x) xs
13:33:54 <Heffalump> that looks non-associative to me
13:34:07 <autrijus> er, what is this interleave?
13:34:24 <lightstep> i didn't diagonalize correctly, but why would that be invalud?
13:34:44 <ski> interleave :: Stream a -> Stream a -> Stream a
13:34:54 <Heffalump> don't forget the monad laws
13:35:12 <Heffalump> actually, I think it does obey them. Just not in a useful way.
13:35:27 <ski> Stream makes a Comonad, though
13:36:01 <Heffalump> (m >>= f) >>= g = m >>= (\x -> f x >>= g)
13:37:12 <Heffalump> ok, it does satisfy the laws (with return x = let res = Cons x res in res)
13:37:14 * autrijus reads "monad laws" and thinks "A monad may not injure a function, or, through inaction, allow a function to come to harm"
13:37:16 <ski> join . return = id
13:37:21 <ski> join . fmap return = id
13:37:45 <Speck> Does microsoft's monads shell (MSH) have anything to do with monads as we know them?
13:37:50 <Heffalump> no
13:37:54 <ski> (if one wants the other formulation)
13:37:55 <Heffalump> (afaik)
13:39:02 <ski> join :: Stream a -> Stream (Stream a)
13:39:08 <ski> um
13:39:14 <ski> join :: Stream (Stream a) -> Stream a
13:39:18 <ski> of course :)
13:39:41 <ski> that would use some kind of diagonalization, to not throw away data
13:41:36 <Heffalump> yes, and that would fail to satisfy the laws
13:41:44 <ski> yes, i think so
13:42:18 * ski ponders what use the Stream Comonad may be of .. :)
13:42:26 <Heffalump> autrijus: "A monad may not affect pureness, or, through inaction, allow pureness to be violated"
13:42:35 <Heffalump> s/pureness/purity/g
13:43:15 <autrijus> good
13:44:39 <autrijus> A monad must obey the sequences defined on it with bindings, except where such orders would conflict with the First Law.
13:44:54 <autrijus> A monad must protect its own identity, as long as such protection does not conflict with the First or Second Law.
13:45:06 <ski> identity ?
13:45:31 <autrijus> the return/bind left and right identities
13:45:40 <ski> aha
13:45:56 * ski was thinking along object identity ..
14:32:13 * boegel y0ws
14:37:49 * boegel leaves to begin a sweaty night in bed ('cause it's so damn hot in here)
14:58:37 <autrijus> @pl (ExpLV .) . KEYED
14:58:39 <lambdabot> (ExpLV .) . KEYED
15:02:47 * autrijus decides today "Perl" should stand for Polymorphic Existential Recursive Lambdas 
15:05:26 <Heffalump> :-)
15:06:31 <Heffalump> sorry I haven't produced the perl thing yet, btw, I'm having some trouble making it build 'properly' thanks to the FFI includes breaking the perl includes. I think it was working before purely by blind luck..
15:06:56 <autrijus> blind luck is an essential ingredient when working with dynamic languages...
15:08:10 <Heffalump> well, yes, but you hope only to invoke it at runtime.
15:41:27 * Speck still needs more haskell blogs
15:49:05 <stepcut> ??
15:49:33 <stepcut> and what will you do with all them blogs ?
15:50:38 <autrijus> aggregate them?
15:50:48 <yain> print them all, and then ......
15:50:50 <zamez> isn't it essential with other languages too?
15:50:56 <zamez> just in different places
15:51:30 <Heffalump> naah, if you use Haskell your programs work because of innate skill.
15:51:54 <zamez> :>
15:52:06 <Heffalump> (and in recognition of your good taste)
15:52:30 <autrijus> s/innate/inmate/; # as in mental hospital
16:01:14 <Speck> yes I want to aggregate them... in my mind?
16:01:18 <zamez> heh
16:02:10 <Speck> I just need a source of every-day haskell literature that isn't constantly scrolling up :)
16:11:36 * Igloo wonders why Buddha renamed
16:11:43 <Heffalump> I was wondering that.
16:11:48 <Heffalump> I suspect someone threatened to sue it.
16:12:03 <Heffalump> given the rather abrupt message and the global application of sed.
16:13:07 <autrijus> Plargleflarp?
16:13:23 <dcoutts> perhaps an upset buddhist?
16:13:57 <Heffalump> lol
16:14:08 <Heffalump> (or are you serious about the upset buddhist?)
16:14:30 <autrijus> mm Melbourne Uni Buddhist Society.
16:14:37 <Muad_Dibber> maybe Buddha himself reincarnated and told them to rename the thing?
16:14:41 <autrijus> # http://mail.lug.lk/lurker/message/20050603.062756.fa89e814.en.html
16:14:45 <dcoutts> well after autrijus said Plargleflarp, I thougt it was proably quite apt for that too!
16:14:49 * Heffalump pokes dcoutts with a channel invite
16:15:13 <dcoutts> Heffalump, what channel?
16:15:39 <Heffalump> rotfl at the email
16:16:08 <Heffalump> dcoutts: in theory your IRC client should tell you this :-)
16:16:22 <dcoutts> Heffalump, it didn't :-(
16:17:05 <autrijus> does a dog have Plargleflarp nature?
16:18:03 <wagle> if it's self flea (bug) removing?
16:18:21 <wagle> Plargleflarp?
16:18:32 <autrijus> Plargleflarp is the new name for Buddha
16:19:42 <Muad_Dibber> the way i read it at the website it would be more like an interactive quickcheck or something
16:20:57 <Muad_Dibber> well, thats not what i mean
16:20:59 <Muad_Dibber> but anyway :P
16:21:30 * wagle bans shiny surfaces on parked cars
16:21:49 <wagle> ... on sunny days
16:23:29 <autrijus> banning sunny days may be more fruitful
16:23:31 <Speck> Could, as an example,  max and maximum be reconsiled using fundeps? (I'm struggling to see the significance of fundeps)
16:24:14 <autrijus> isn't maximum just a fold on max?
16:24:25 <Speck> not sure
16:24:36 <wagle> waugh
16:24:36 <wagle> You don't have permission to access /~bjpop/plargleflarp/onlinedocs/UserGuide/UserGuide.html on this server.
16:25:00 <autrijus> maybe that's because you had not yet attained plargleflarp nature
16:25:05 <Speck> autrijus, yeah it is
16:25:17 <autrijus> Speck: so, how does fundep affect this?
16:25:38 <Speck> I dunno. but it appeared to allow a kind of ad-hoc overloading-like capability
16:25:46 <Speck> I'm still trying to figure out fundeps, you se
16:25:48 <Speck> *see
16:26:12 <Speck> I'm a haskell newbie, I should mention
16:26:40 * Heffalump wonders if Bernie is serious about the renaming, given the tone of that email.
16:26:49 <autrijus> fundeps is simply a way to say two (or more) types have some kind of relation
16:26:56 <wagle> i always keep the prelude.hs in an edit buffer so i can search on it
16:27:01 <autrijus> and you can deduce one type from another
16:27:16 <autrijus> (not neccessarily vice versa)
16:27:19 <Speck> ah... I see
16:27:39 <wagle> Heffalump: i suspect he's having a grand old time with the renaming
16:27:52 <autrijus> because without fundeps, there can be n*m combinations of relations
16:28:11 <autrijus> and the inferencer cannot generall help you; you need to explicitly annotate each side
16:28:27 <autrijus> it's all solved with fundeps; it's so much fun, you'll grow depending on it
16:28:53 <Heffalump> I think I should release something called Buddha just to add to the confusion.
16:28:59 <Igloo> :-)
16:29:11 <Speck> I don't know if I'm good enough with haskell to conquer fundeps now, I guess. I'll just stick with arrows
16:29:11 <autrijus> Heffalump: call your perl binding buddha?
16:29:27 <autrijus> since it has the plargleflarp nature
16:29:48 <Heffalump> autrijus: I was thinking that.
16:29:55 <Igloo> It should be something that inserts bugs into Haskell programs, to complement plargleflarp's function. So a perl binding seems reasonable.
16:30:02 <autrijus> right.
16:30:16 <Heffalump> Actually, I could call it anti-Buddha.
16:30:19 <autrijus> "you get runtime bugs, random segfaults, memory leaks for free"
16:30:41 <Heffalump> That'd (a) cause offence to the people who were offended by Buddha and (b) not cause confusion with the original Buddha, whether or not it renames back
16:33:02 <wagle> buddha the debugger is hit #25 if you google for "buddha"
16:33:33 <wagle> hmm..  http://www.rudebuddha.com/
19:20:15 <blackdog> re
19:26:35 <dons> ///win 13
19:28:30 <blackdog> hi don. i can't quite make out your strange monkeyscript...
19:28:45 <dons> :}
19:29:56 <dons> check your other msg windows, I'm trying to talk to you, blackdog...
19:35:35 <blackdog> gah. yeah, ok. i'm there. (need a better irc client, i never notice messages.)
19:58:38 <dons> @code
19:58:40 <lambdabot> Regex.hs: in
19:58:54 <dons> bah. that's not supposed  to happen
19:59:22 <dons> @code
19:59:23 <lambdabot> GetOpt.hs: short (OptArg f _:_) [] rest     = (Opt (f Nothing),rest)
21:23:23 <seafood> blackdog: How you doing?
21:59:07 <Speck> what is "env" in the mapA function described here(http://www.haskell.org/arrows/examples/ListOps.as )
22:08:26 <musasabi> Speck: a second parameter passed to the arrow.
22:09:45 <Speck> actually, I have a better question, now that someone's listening
22:09:50 <Speck> how do you call mapA
22:09:58 <musasabi> Speck: imagine mapM f (env,[]) = return []; mapM f (env,x:xs) = do n <- f (env,x); ns <- mapM f (env,xs); return (n:ns)
22:10:49 <musasabi> "mapA someArrow" which produces an arrow which can then be used like other arrow values.
22:12:34 <Speck> mapM and mapA are analagous to map, but they're used so differently
22:12:54 <Speck> I should get a grasp on it soon enough though!
22:13:05 <Speck> thanks for your explanations :-)
22:15:29 <Speck> btw, I like how you used monads to explain the behavior of arrows, it reminded me of how my 8th grade math teacher described cross-dimensional representations, i.e., we represent the 3rd dimension on a 2 dimensional plane, and we can represent a 4th dimensional object similarly on a 3rd dimensional plane
22:16:00 <musasabi> Nice if it helped :-)
22:16:02 <Speck> not a 3rd dimensional plane :P
22:16:05 <Speck> that doesn't make sense
22:20:25 <mugwump> hey I've got a function ...
22:20:29 <mugwump>     split' [] xs n = VList $ map (VStr . (:[])) (take (n-1) xs)
22:20:42 <mugwump> (from Pugs/Prim.hs)
22:21:09 <mugwump> and I want to add (drop (n-1) xs) to the end of this
22:22:54 <mugwump> but the $ confuses me a little.  I certainly didn't come across that in the tutorials :)
22:23:16 <Lemmih> f $ x = f x
22:23:21 <dons> @type ($)
22:23:27 <lambdabot> ($) :: forall b a. (a -> b) -> a -> b
22:23:45 <dons> @type id 1
22:23:47 <lambdabot> id 1 :: forall a. (Num a) => a
22:23:49 <dons> @type id $ 1
22:23:50 <lambdabot> id $ 1 :: forall a. (Num a) => a
22:24:16 <mugwump> so it's a delimiter?  or a forall?
22:24:38 <Heffalump> f ($) x = f x
22:24:38 * mugwump hmms and realises he might not be able to crack this one
22:24:41 <Heffalump> sorry
22:24:42 <Heffalump> f $ x = f x
22:24:58 <Heffalump> but $ has different precedence to standard function application
22:25:27 <Heffalump> it has the lowest precedence possible, while standard function applicatin has the highest precedence possible
22:25:36 <mugwump> oh, so it is a bit like a delimiter then, I think I get it
22:25:42 <Heffalump> so the expression f g x is bracketed as (f g) x
22:25:48 <Heffalump> whereas f $ g x becomes f (g x)
22:29:28 <Speck> I think of $ as replacing invisible parentheses
22:30:51 <Speck> the first paren is where the $ is, and the ending paren is at the end of the expression (which has, arguably, a lower precedence depending on how you look at things)
22:32:08 <Speck> hmm... I wonder if lisp would benefit from a $-like operator :-)
22:34:10 <mugwump> ok I think I have reduced my problem to a simple matter of concatenating two lists... is there an operator for that?  or just , ?
22:34:34 <Lemmih> @type (++)
22:34:35 <lambdabot> (++) :: forall a. [a] -> [a] -> [a]
22:34:49 <mugwump> of course, I've used that on strings before
22:35:05 <Speck> strings are lists with a different show instance
22:43:27 <Khisanth> Speck: that would be lisp with all the )'s removed and ('s changed to $? :)
22:43:49 <Speck> I was imagining it as being optional
22:44:20 <Khisanth> Speck: the lisp would probably end up looking like Perl ;)
22:44:48 <Speck> I haven't coded in perl since perl 4
22:45:00 <Speck> which is to say, I don't remember
22:46:52 <Heffalump> it's hard to replace all ()s with $ signs
22:47:27 <Speck> yeah
22:47:51 <Heffalump> strings are lists full stop, they don't have any different show instance
22:47:52 <Speck> you would have to do needless extract methods
22:47:59 <Heffalump> type String = [Char]
22:48:12 <Speck> oh, I assumed they had a different show instance
22:48:20 <Heffalump> it's just that the Show class has been specifically designed to make it possible to have special-case behaviour
22:48:21 <Speck> because a string appears as "/the chars/"
22:48:34 <Heffalump> class Show a where { show :: ..., showList :: ... }
22:48:46 <Heffalump> (that's not strictly true, but it'll do for this explanation)
22:48:56 <Heffalump> and showList has a default method
22:49:01 <Heffalump> but Show Char overrides it
22:49:17 <Speck> I take it back then :-) Thanks for the clarification.
22:50:09 <Heffalump> it's a bit of an ugly hack, really, but it's forced by the rules on type class instances to make them decidable
22:50:43 <Heffalump> either you have String be a newtype and have more hassle pattern-matching on it, or you play this game with Show
22:53:58 <Speck> it always depresses me to see ugly hacks in haskell
22:54:46 <Speck> of course, I'm sure much worse ones exist. I just don't know enough haskell to know them
22:55:15 * musasabi votes for unsafeCoerce#
22:56:03 <Lemmih> How is unsafeCoerce# an ugly hack?
22:56:24 <dons> but there's an understated, ruthless efficiency in providing unsafeCoerce#
22:56:33 <musasabi> well it is a big hammer to break the typesystem.
22:56:35 <dons> it's not so much a hack itself.
22:56:42 <dons> but it can be used to make some great hacks!
22:57:55 <dons> paprika$ pwd
22:57:59 <dons> /home/dons/tmp/ghc-6.4.20050506/ghc/compiler
22:58:01 <dons> paprika$ find . -name '*.hs' -o -name '*.lhs' -exec grep unsafeCoerce {} \; | wc -l
22:58:04 <dons>       22
22:58:51 <Speck> is all of ghc written in literate haskell?
22:59:13 <Speck> err, nm I didn't quite grep that find statement correctly :-P
23:01:05 <dons> another good one is:
23:01:11 <dons> @type "bytes"#
23:01:12 <lambdabot> "bytes"# :: GHC.Prim.Addr#
23:11:50 <Itkovian> meuning
23:28:57 <musasabi> Has allowing typelambdas more adverse effects than general metaprogramming?
