01:12:20 <Itkovian> meuning
01:15:39 <TFK> g'day
01:21:08 <FrederikEaton> burp
01:56:53 * boegel checks out the #haskell-crowd
01:57:43 * Itkovian waves at boegel
01:58:09 * genneth threaten boegel with a url-dearmer
01:59:00 * xerox returns
02:11:55 <ski> hi TheHunter
02:13:04 <shapr> hi ski
02:13:13 <ski> TheHunter : i read in TaPL another view of the polymorphic reference problem
02:13:15 <Itkovian> seems quiet in here
02:13:23 <ski> hejhej shapr :)
02:17:14 <TheHunter> hi ski
02:17:39 <TheHunter> what's that view?
02:18:42 <ski> more or less, if one see polyRef :: forall a. IORef (Maybe a)   as a *function* that given a type 'a' gives a value of type 'IORef (Maybe a)'
02:18:46 <TheHunter> i'm thinking it's mainly a parametrizity issue
02:19:37 <TheHunter> right.
02:19:56 <ski> then the first instantiation of 'a' to, say 'Bool' to be able to assign Just True to it, will assign to a new fresh reference cell, while the next dereference of the cell with 'a' instantiated to 'Int' will read from another cell
02:21:01 <poetix> How does this work in Haskell at the moment (haven't played with IORefs yet)?
02:21:01 <ski> hm, maybe that view indeed has to do with parametricity  .. *thinking*
02:22:15 <TheHunter> @docs Data.IORef
02:22:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.IORef.html
02:22:41 <ski> if you manage to create such a polyRef (by evil unsafePerfomIO hackery, e.g.) then you can construct an 'unsafeCoerce' from it, which i think current implementations will give the usual semantics (i.e. coerce)
02:24:17 <ski> TheHunter : i guess i see how this (TaPL) view handles it. but i'm still not sure there isn't something in the other views, too ..
02:25:59 * xerox bounces happily
02:26:39 <ski> (or, better .. proto-views, i guess)
02:26:58 <musasabi> polyRefs seem to be more or less equal to segmentation faults
02:28:56 <ski> maybe
02:29:49 <TheHunter> i don't see the relationship to variance, since the IORef constructor is neither covariant nor contravariant.
02:30:03 <ski> TheHunter : well, it is both
02:30:28 <ski> (also called 'invariant')
02:30:50 <ski> at least so far i can see ..
02:30:55 <TheHunter> yeah i tried to avoid the word 'invariant'.
02:30:59 <ski> :)
02:33:52 <TheHunter> if a <= b then it doesn't follow IORef a <= IORef b, so I would think it is neither.
02:35:21 <ski> iirc data AVariant a = AV  data CoVariant a = CoV a  data ContraVariant a = ContraV (a -> Bool)  data InVariant a = InV (a -> a)
02:38:14 <ski> hm, the o'haskell tut calls the first one 'nonvariant'
02:40:50 <TheHunter> so AVariant is both covariant and contravariant and InV neither?
02:41:25 <ski> covariant F <=> (forall a b. F a <: F b => a <: b)      contravariant F <=> (forall a b. F a <: F b => b <: a)     invariant a <=> covariant a /\ contravariant <=> (forall a b. F a <: F b => a <:b /\ b <: a) <=> (forall a b. F a <: F b => a ~= b)
02:41:34 <ski> is how iv'e understood it ..
02:42:34 <ski> (where a-/non-variant being neither (and 'invariant' being both))
02:42:59 <TheHunter> that's quite different from what I had thought.
02:44:27 <swiert> does anyone here have any experience with citeulike?
02:44:30 <swiert> http://www.citeulike.org/
02:45:19 <ski> "...As an example of invariant subtyping, consider the record type   struct Box a = in :: a -> Box a; out :: a   As an example of invariant subtyping, consider the record type and T are identical types. .."
02:45:32 <ski> i can only interpret that as what i wrote above
02:46:00 <ski> possibly there are others using the words in slightly different ways, i'm not sure
02:46:01 <TheHunter> google brings up this definition: "A generic class C<X> is said to be covariant in the type parameter X when the subtype relation C<R> <: C<S> holds if R <: S."
02:46:18 <TheHunter> this means: covariant F <=> (forall a b. F a <: F b <= a <: b)
02:46:30 <ski> hm
02:46:36 <ski> lemme reread again
02:46:49 <boegel> what's <: ?
02:47:04 <ski> subtype  (and it's reflexive and transitive)
02:47:11 <boegel> (besides a smily)
02:47:20 <TheHunter> subtype relationship: like Int <: (forall a. a)
02:47:44 <boegel> I see
02:47:46 <ski> no
02:47:52 <boegel> no?
02:47:55 <ski> Int <: (exists a. a)
02:48:06 * boegel scrathces his head
02:48:14 <TheHunter> d'oh
02:48:15 <boegel> there's a lot left to learn for me :)
02:48:24 <boegel> including spelling (doh)
02:48:36 <ski> better to say e.g.  ColoredPoint <: Point
02:48:53 <ski> or  BlackOrWhite <: Color
02:49:18 <boegel> yeah, I get that, but I don't see the relationship between Int and exists
02:49:36 <TheHunter> the spelling is correct! http://en.wikipedia.org/wiki/Homer_Simpson
02:50:03 <TheHunter> http://en.wikipedia.org/wiki/D%27oh%21
02:50:06 <ski> if  a <: b  then we should have a canonical coerce function :: a -> b
02:50:12 <boegel> TheHunter: I meant my 'scratches' typo =)
02:50:21 <TheHunter> oh, sorry.
02:50:42 <ski> TheHunter : and you can't write a function  Int -> forall a. a   (except by cheating and returning _|_)
02:51:07 <boegel> i see
02:51:23 <xerox> What is "<:" ?
02:51:28 <xerox> OK, found :-D
02:51:30 <TheHunter> ski, i mix that stuff up regularly. I recall a thread on haskell-libs where I confused everybody by mixing up sub- and superclass.
02:51:54 * boegel leaves to prepare spaghetti
02:51:59 <ski> TheHunter : but, you may be right about the co/contra/in issue, .. trying to think it through now ..
02:52:11 <ski> TheHunter : hehe
02:52:25 <shrimpx_> what's the standard way to generate a pdf from the haskell source tree? (code + literate docs)
02:52:55 <dons> there's a standard way?
02:53:00 <shrimpx_> shrug
02:53:23 <dons> what src tree are you referring to, btw? ghc's?
02:53:29 <shrimpx_> oh yea
02:53:31 <shrimpx_> sorry
02:53:48 <dons> well, the .lhs files should be renderable with lhs2tex
02:53:49 <shrimpx_> i'm actually interested in just a subdir of ghc/compiler
02:54:19 <shrimpx_> ah k
02:54:39 <dons> the .hs files aren't in haddock or anything else, so you might have to write your own little script.
02:54:53 <dons> I think someone did this as a project a year or two ago.
02:55:01 <dons> maybe check the mailing list
02:55:43 <shrimpx_> ok thanks
02:55:55 <shrimpx_> looks like the stuff i want is all .lhs
02:59:37 <ski> TheHunter : well, hm, it looks like i was misled by ".. invariant ..so both the co- and contravariant rules apply at the same time .." and thus reconstructed the defs 'the other way around', upon careful reading of the tut, the implications actually go in the same direction as in the class-covariant-subtyping quote you provided
02:59:38 <TheHunter> is spj aware that ext-core is broken?
03:00:31 <ski> TheHunter : so, with that def, it's a-/non-variant that is both co- and contra- variant, yes (and 'invariant' being neither)
03:01:05 <Itkovian> TheHunter: people will prolly inform him very soon when responding to his cafe post
03:01:17 <TheHunter> that sounds more logical to me.
03:01:25 <ski> TheHunter : still, do you think IORef is 'invariant' ?
03:01:41 <TheHunter> sure.
03:02:27 <ski> heh, here i've gone around constructing a backwards intuition about this. now i have to remodel that somewhat .. :/
03:03:12 <basti_> hi
03:03:22 <TheHunter> there are no two types a and b in Haskell with a <: b such that IORef a and IORef b are allowed, are there?
03:03:26 <TheHunter> hi
03:03:38 <ski> hi basti_
03:04:08 * TheHunter is looking forward to boxy types.
03:04:27 <ski> (like "'invariant' is co- and contra- variant means sortof that both variances apply which means that it can't vary at all .. well now that i express it in this way i guess it sounds weird .. :)
03:05:21 <ski> anyway, my idea is that 'IORef a' is a little like 'a -> a' because you can both input 'a' and get 'a' output from them both
03:05:37 <ski> boxy types ?
03:05:49 <TheHunter> http://research.microsoft.com/Users/simonpj/papers/boxy/
03:06:07 <ski> ty
03:06:09 <TheHunter> the hc&ar states that this will be in the next version of ghc.
03:06:24 <TheHunter> didn't read it, it seems very technical.
03:06:41 <ski> hm, impredicative too ..
03:06:45 <ski> ok
03:07:10 <TheHunter> so we could test IORef Int against IORef (forall a. a) then.
03:07:24 <ski> uh 'test' ?
03:07:42 <ski> whaddya mean ?
03:07:59 <TheHunter> if one is a subtype of the other.
03:08:12 <ski> ah
03:08:25 <TheHunter> which will almost definitely not be the case.
03:08:32 <boegel> who was working on the ICFP contest in here ?
03:08:40 <ski> think so, too (i.e. neither direction)
03:08:55 <Itkovian> boegel: earthy iirc
03:10:03 <ski> TheHunter : but we can define types IORRef,IOWRef which i think will be covariant resp. contravariant
03:10:08 <boegel> I'm wondering how's it going ... it would be cool if Haskell is first again :)
03:10:26 <ski> (but i could be worng)
03:10:39 <TheHunter> i'm thinking that can be done, too.
03:11:44 <TheHunter> Writer monads are covariant in w, Reader monads contravariant in r.
03:12:14 <ski> something like first define ADTs BasicIORRef a,BasicIOWRef a ,  and only allow reads on first, and writes on second, implement both with IORef, and make a conversion from IORef to each of them  (or possibly we could have IORef as subtype to both of them .. ?)
03:13:11 <ski> then define  data IORRef a = forall x. MkIORRef (BasicIORRef x) (x -> a)   data IOWRef a = forall x. MkIORRef (BasicIOWRef x) (a -> x)
03:14:07 <ski> TheHunter : what do you think, will these be covariant resp. contravariant ?
03:14:33 <ski> at least i think the first is a (covariant) functor, and the second a contravariant functor
03:14:59 <poetix> Wasn't dcoutts in ICFP?
03:15:46 <xerox> He was doing it yea :)
03:15:59 <TheHunter> i think they will be. Maybe I should try to enhance my java skills by trying to implement them in java.
03:16:29 <ski> heh
03:19:59 <ski> TheHunter : hm  IORef (Maybe (forall a. a)) ~= IORef (forall a. Maybe a) {-because Maybe is covariant-}     /~= forall a. IORef (Maybe a)
03:22:04 <ski> (TheHunter : and the first and second type there seems, in some sense, like reasonable typings for the polyRef .. methinks)
03:28:42 <TheHunter> i'm confused. maybe ghc really treats IORef as covariant.
03:28:56 <ski> hm ?
03:29:01 <ski> how do you mean ?
03:30:16 <basti_> re
03:30:35 <ski> hm .., ghc at least infers  newIORef Nothing :: forall a. IO (IORef (Maybe a))
03:30:37 <TheHunter> forall a. IORef (Maybe a) is implemented as if it were IORef (forall a. Maybe a), but this sloppiness doesn't matter since in the IO monad, newIORef can only produce a monomorphic type.
03:31:07 <ski> (or does it .. ?)
03:31:08 <ski> hm
03:31:48 <ski> @type Data.IORef.newIORef Nothing
03:31:50 <lambdabot> Data.IORef.newIORef Nothing :: forall a.
03:31:50 <lambdabot>            IO (GHC.IOBase.IORef (Maybe a))
03:33:34 <TheHunter> hmm, in the subtyping sense, IO is invariant, but we can make it covariant using unsafePerformIO.
03:33:53 <ski> maybe another idea would be to compare with STRef s (Maybe a) .. in some way, possibly 'a' could be said to be 'hidden' in 's' ..
03:34:06 <TheHunter> IORef is of course not covariant, sorry.
03:34:07 <basti_> http://haskell.org/hawiki/TypesOnShellLevel?action=show -- added afterthoughts
03:34:20 <ski> IO is invariant ?
03:34:25 <basti_> what is ST?
03:34:53 <ski> ST is a monad for localized state, similar to IORef you have STRef s
03:35:02 <ski> and you can get out of the ST monad !
03:35:05 <ski> (safely)
03:35:07 <basti_> ah.
03:35:13 <basti_> i liked STM
03:35:27 * ski has not looked at STM
03:35:56 <basti_> its a monad that implements shared memory in a safe and reasonably effective way
03:36:13 * poetix softly and silently vanishes away
03:36:17 <basti_> you can convert it to an IO value, and this conversion implements the safe access
03:36:32 <TheHunter> well i'm not even sure there's a procedure through which we can decide if IO is covariant.
03:36:50 * basti_ has not the slightest cue what TheHunter is talking about
03:37:07 <ski> basti_ : shared, how ?  distributed ?  just multiple processes ?  maybe multiple processors (i.e. parallelism) with shared mem ?
03:37:27 <basti_> ski: afaics, also multiple processors
03:37:37 <basti_> you could feed in safe network stuff in the transition
03:37:42 <ski> TheHunter : hm, anyway IO is a covariant functor ..
03:37:57 <TheHunter> yeah, that's for sure.
03:37:59 <basti_> anything... but i think best would be using a known PVM system
03:38:18 <ski> which i think suggests covariant subtyping, but possibly not forcing it  (can't think up reasons atm ..)
03:38:44 <ski> basti_ : ok
03:39:35 <musasabi> How did one create a polymorphic tree structure with non-fixed types (that is types may be of the form forall a Foo a...) ?
03:39:39 <basti_> http://research.microsoft.com/Users/simonpj/papers/stm/stm.pdf < ski
03:40:26 <ski> basti_ : ty
03:40:54 <ski> musabi : Foo being a typeclass ?
03:40:54 <basti_> note the name...
03:42:17 <basti_> any heretic here to convince about the worth of haskell?
03:42:40 <ski> TheHunter : covariant IO   <=>   forall a b.  IO a <: IO b  <=  a <: b   <=>   (RealWorld -o (RealWorld,a)) <: (RealWorld -o (RealWorld,b))  <=  a <: b   .. hmm
03:42:45 * TFK raises his hand
03:42:49 * TFK snickers
03:42:51 <musasabi> ski: yes.
03:42:56 * ski chuckles ..
03:43:33 <TFK> http://lambda-the-ultimate.org/node/view/808 <--- speaking of heresy, here's an anit-Joel rant.
03:43:41 <ski> musasabi : with a fixed (but unknown) type 'a' in the whole tree ?  or with possibly different types at different elements ?
03:43:42 * basti_ 's head explodes
03:44:00 <musasabi> ski: all the elements have different types.
03:44:44 <TheHunter> ski, yeah, covariance of IO is no problem.
03:45:08 * boegel boots his aunt old computer and is amazed to see winXP on it
03:45:09 <TheHunter> but this is a problem: forall a b.  IO a <: IO b  =>  a <: b
03:45:27 <boegel> I'm guessing that machine has only 64mb of ram orso, and she wonders why the machine is slow :)
03:47:08 <ski> musasabi : data SomeFoo = forall a. Foo a => HideFoo a    and use SomeFoo as element type  (you can even make SomeFoo an instance of Foo ..)
03:47:43 <TheHunter> i should shut up.
03:48:05 <TFK> <: looks like a bird.
03:48:21 <TheHunter> most of my comments made few sense.
03:49:38 <swiert> shapr: ping
03:49:53 <musasabi> ski: does that scale up to more complex cases?
03:50:01 <ski> like what ?
03:50:41 * musasabi has "class Select r f t | r f -> t where (!) :: r -> f -> t" which is what I am trying to wrap.
03:51:12 <ski> TheHunter : hm, my hunch would be that your latter 'problem' would be true, too, but i'm not sure
03:51:31 <musasabi> Basically I am trying to lift the set of constraints to the top-level of the tree.
03:52:35 <ski> are you trying to wrap pairs of values of types 'r' and 'f' ?
03:52:41 <ski> hm
03:53:21 <ski> TFK : it does ?
03:53:34 <ski> ah
03:54:01 <TFK> ski, aye. A kind of bird-facing-backwards. :> faces forward, so to speak.
03:54:10 <basti_> http://haskell.org/hawiki/TypesOnShellLevel?action=show < expanded
03:54:19 <ski> m, but i think the smiley is more evident ..
03:54:39 <TFK> It's a smiling bird o_O
03:54:43 <TFK> @moo
03:54:48 <boegel> @moo
03:55:06 * boegel shakes lambdabot "Wake up bitch !"
03:55:15 <xerox> @botsnack :-(
03:55:16 <lambdabot> :)
03:55:19 <xerox> ^___^
03:55:21 <boegel> heh ? :)
03:55:26 <boegel> @moo
03:55:37 <xerox> Disabled!
03:55:48 <xerox> Heffalump asked for that :-)
03:55:49 <boegel> why's that ?
03:55:58 <xerox> It was annoying.
03:56:08 <boegel> no it wasn't, it was fun :)
03:56:10 <boegel> @yow
03:56:12 <lambdabot> I am having FUN...  I wonder if it's NET FUN or GROSS FUN?
03:56:24 <ski> basti_ : Stream is a coinductive / coalgebraic datatype, yes
03:56:25 * basti_ thinks he has an inkling about a prenex normal form for IO stuff
03:56:31 <xerox> @vixen was @moo fun?
03:56:33 <lambdabot> I define fun
03:56:39 <basti_> ski: would you have a look at the afterthoughts?
03:56:41 <boegel> mwoeha :) genious
03:57:00 <ski> basti_ : only just looked at the beginning, so far .. :)
03:58:37 <ski> musasabi : i'm not sure what you have in mind, saying that you want to 'lift the set of constraints to the top-level of the tree' ..
03:59:38 <ski> basti_ : you want to have just Files and Streams at 'top level' so to speak ?
03:59:45 <ski> basti_ : and just what is File ?
03:59:50 <basti_> ski: at user top level.
04:00:21 <basti_> it unfolds to an atomic operation where you read that file
04:00:49 <ski> maybe you want  Stream :: * -> Some_kind_of_filesystem_kind  File :: * -> Some_kind_of_filesystem_kind  ?  (pun not intended)
04:00:56 <basti_> or where you get a handle to a memory map interface
04:01:12 <basti_> im just toying around =)
04:01:31 <basti_> on the top level your shell would hang at an incomplete read parse from your terminal
04:01:37 <ski> so it wouldn't be better to just say e.g.  important-event-log :: [Event]   ?
04:02:01 <basti_> maybe file is some id yes.
04:02:33 <musasabi> ski: if I have e.g. "a x = x ! Field1", "b x = x ! Field2" then I can have "comb x y v = (x v, y v)" which propagates the constraints. Now I want to do other things than just apply it to an argument - that is suspend it as a tree that can be both walked (without the argument) or applied to the argument.
04:02:51 <ski> you want to handle file updating on typelevel (e.g. similar to IORef), or outside ?
04:03:36 <basti_> it is in typelevel in the way that IO calls are on typelevel. It would (hopefully) be "unfolded" to something sane, sequence wise
04:03:47 <basti_> sane as in, order is preserved.
04:03:53 <basti_> additional semantics on request
04:04:10 <basti_> its just a differentation of: call tree (might never end) and data (has some end)
04:04:20 <ski> dataflow should require sequentializing for when it's required ;)
04:04:28 <ski> musasabi : hm
04:04:32 <basti_> there could be semantically well defined interfaces
04:04:36 <basti_> STM does this afaics
04:05:26 <musasabi> Did I explain it in an understandable way?
04:05:33 <ski> musasabi : how does 'comb' relate to 'a' and 'b' ?
04:05:43 <ski> musasabi : i failed to understand it, yes :)
04:06:29 <musasabi> ski: well "comb a b" produces a function which combines the constraints of a and b.
04:06:52 <ski> (it's mpar for environment/reader monad, yes)
04:06:58 <musasabi> ski: but I want to have a datastructure rather than a function but still want to keep the combined constraint.
04:07:20 <ski> how does 'a' and 'b' correlate to that ?
04:07:44 <ski> is 'Field1','Field2' the "constraints" there ?
04:08:09 <ski> would a possible call be  'comb a b (...)' ?
04:09:38 <musasabi> a :: forall t r. (Select r Field1 t) => r -> t,   b :: forall t r. (Select r Field2 t) => r -> t    and comb :: forall t t1 t2. (Select t Field1 t1, Select t Field2 t2) => t -> (t1,t2)
04:10:09 <ski> basti_ : hm, i first read '.. all things that might happen in a Stream (kind of one by one) ..' as '.. all things that might happen *to* a Stream (kind of one by one) ..' .. did you mean the first or second one ?
04:11:12 <musasabi> What I want is something similar to comb - but rather than create the function create a datastructure which just carries the information (so it can be both traversed or use a value to fill holes like a and b)
04:11:18 <basti_> ski: hmm. well. i was thinking like: there's our rts, that hobbles along an IO call"tree" (graph, whatever)...
04:11:25 <basti_> thats the natural way of stream processing
04:11:33 <basti_> a thing comes in, its processed, goes out
04:11:38 <basti_> maybe some things are kept in a state
04:11:55 <ski> musasabi : um, didn't 'comb' have 3 args, not one .. ?
04:12:08 <ski> hm
04:12:25 <basti_> but when we're talking about "[Adresses]" we're talking about a FINITE object (usually, except for lazy semantics)
04:12:29 <basti_> an inductive thing
04:12:57 <musasabi> ski: comb takes two args (child nodes) and produces a function from a record to the filled tree.
04:13:06 <ski> basti_ : yes
04:13:22 <basti_> ski: now we have a thing that describes Streams
04:13:57 <basti_> and we put our types in some form, so that all the IO is in the right place.
04:14:17 <basti_> but keeping notion of "Streams" inside for the user
04:14:24 <basti_> so that he might spawn new IO actions
04:14:28 <basti_> (a shell!)
04:14:52 <basti_> (with the type stuff being judged upon when the user fires an action)
04:14:59 <ski> musasabi : "comb x y v = (x v, y v)" .. surely you don't want this 'comb' to have your 'comb' type ?
04:15:04 * basti_ is tempted to mutter "an eternal golden braid"
04:15:14 * basti_ ducks and runs
04:15:15 <ski> musasabi : trying to understand what you are after ..
04:16:26 <basti_> i could type a line that handles my loggable events so that it accumulates lists of Events, which are Converted to a human readable format every hour and are messaged to me.
04:16:30 <ski> basti_ : data IOStreamCell a = Cons a (IOStream a)   type IOStream a = IO (IOStreamCell a)  ??
04:16:46 <basti_> ski: :-o
04:16:52 <basti_> ski: could you put that on the page?
04:16:52 <basti_> =)
04:17:00 <basti_> or shall I?
04:17:19 <ski> you can put it, if it's what you want to say ..
04:17:32 <basti_> http://www.news.cornell.edu/stories/June05/new.mind.model.ssl.html < candy! ;)
04:17:33 <ski> (which i'm not sure it was ..)
04:17:57 <ski> musasabi : alive ?
04:18:33 <basti_> ski: is on there.
04:19:03 <ski> basti_ : "in'tresting"
04:19:31 <basti_> ski: my stuff or the brain stuff?
04:19:45 <ski> um
04:20:07 <ski> basti_ : it's *your* stuff ?
04:20:19 * ski looks a little shocked :)
04:20:23 <basti_> ski: -?-
04:20:33 <basti_> my page?
04:20:57 <basti_> that was what came across my mind recently
04:21:02 <ski> basti_ : you have collaborated in that research, yes or no ?
04:21:46 * ski discovers he read 'my stuff or the' as 'my stuff on the' ..
04:22:04 <ski> s..soorry :-P
04:22:09 <musasabi> yes.\
04:22:37 <ski> hello lstna
04:22:50 <basti_> ...?....
04:22:52 <lstna> Hi
04:22:53 <basti_> lol
04:22:54 <musasabi> Maybe I should try to reformulate my question.
04:22:56 <basti_> ski: No.
04:23:22 <ski> musasabi : from what i gathered, you wanted to distribute some 'context'/'constraints' ..
04:23:55 <ski> basti_ : ahh ..
04:24:10 <basti_> ski: lol.
04:24:15 <ski> lstna : new to haskell ?
04:24:19 <basti_> ski: i didnt do any brain studies.
04:24:23 <ski> ;)
04:24:28 <basti_> ski: the haskell wiki page is my stuff though.
04:24:42 <ski> yea, that i actually got ..
04:24:54 <lstna> Yes ski.
04:25:18 <musasabi> I want to have a tree type with holes. The holes are represented as functions with a type like "Select r FieldN t => r -> t" (for various Field types and ts. Now I want to both traverse the trees and have a way to fill them (replacing the functions with their results) and thus need to carry all the constraints of the functions to the top-level of the datastructure.
04:25:21 * basti_ was kinda surprised that it's such a shocker =)
04:25:26 <ski> lstna : want to try it out ? looking for info/tutorials ? got any questions ?
04:26:15 <ski> basti_ : for some reason, i found it hard to imagine that you were into that kind of research .. (i wonder why that would be ..)                                  ;)
04:26:34 <basti_> musasabi: how about annotating the holes on the type level? data Tree a = Hole | Leaf | Branch [a] or something?
04:26:44 <basti_> ski: lol
04:27:09 <ski> musasabi : not holes as in missing pieces of the tree, then ?
04:27:44 <basti_> what else?
04:28:03 <musasabi> ski: no, holes as in leafs wich have a function from a record to the filled node.
04:28:26 <musasabi> basti_: doesn't that fail to carry the typeinformation of the holes upwards?
04:28:52 <basti_> musasabi: well what type information would be there? and then, you could maybe carry it boilerplate wise?
04:28:58 <ski> lstna : if you're looking for a tutorial to haskell, they say this one is quite good :  http://www.isi.edu/~hdaume/htut/
04:29:30 <basti_> musasabi: as in Data ... = ... | Hole a (Holism b) | ...
04:29:37 <ski> :)
04:30:05 <lstna> If you know of something that explains kinds and their relationship to types and type classes, prefereably self contained?
04:31:04 <basti_> kinds are types on a higher level i think
04:31:16 <basti_> metatypes so to say.
04:31:27 <ski> lstna : well, possibly the wiki ..  (otherwise some people here know  (including myself))
04:31:28 <basti_> (Coq would say Type_1 i think?)
04:32:00 <basti_> @type IO
04:32:08 <lambdabot> bzzt
04:32:08 <ski> musasabi : you want to pass down one record to give to all those "holes" ?  or many records ?
04:32:14 <ski> IO :: * -> *
04:32:58 <lstna> That says: Star points to a star; but nothing more!
04:33:05 <musasabi> ski: one record.
04:33:23 <ski> lstna : if you know about arrays in e.g. Java, then array type ("[]") is actually a type constructor, that given any type (e.g. Integer) will give the type of arrays of integers
04:33:35 <basti_> lstna: thats the information that this needs to be applied to one parameter
04:33:47 <basti_> and delivers some result then (obviously)
04:33:56 <ski> lstna : "*" is the "type" (actually 'kind') of normal types
04:34:11 <musasabi> ski: so a tree should carry information what fields (and their types) are required from a record so it can be used to fill all the holes.
04:34:21 <ski> lstna : like  Int :: *   Bool :: *   (Double,[Char]) :: *
04:35:08 <ski> musasabi : what parts of "Select r FieldN t => r -> t" do you want to hide in the "holes" ?
04:35:28 <ski> musasabi : both 'r' and 't' ?  or maybe only some ?
04:36:01 <ski> lstna : ok, so far ?
04:36:17 <lstna> Nope.
04:36:28 <basti_> musasabi: r and t of course have to be parameters to the Tree type
04:36:59 <basti_> lstna: kinds are important on a phenomenological level, but you will probably not have to deal with them on a semantic level.
04:37:11 <ski> lstna : ok   someValue :: SomeType  means that someValue is a valid expression of type SomeType   ok ?
04:37:11 <musasabi> r is unified to the whole tree (it is the type of the record), but each whole has it's own t (which depends on r).
04:37:15 <basti_> i.e.: "if you see one, you will know what it is"
04:37:29 <basti_> musasabi: you need a fundep!
04:37:37 <basti_> =)
04:38:01 <musasabi> basti_: I already have for the Select-class (r f -> t)
04:38:09 <basti_> musasabi: hmm.
04:38:22 <musasabi> basti_: the problem is carrying are those select dependencies to the top level of the tree.
04:38:43 <basti_> "all"
04:38:52 <basti_> hmmm.
04:39:03 <lstna> 'scuse me while i look up phenomenological...
04:39:13 <basti_> lstna: thats how a biologist works
04:39:16 <ski> lstna : e.g.  1 :: Int    True :: Bool   [1,2,3] :: [Int]   length [1,2,3] :: Int   etc ..      ok ?
04:39:33 <basti_> lstna: imagine being in the jungle and seeing an elephant
04:39:35 <basti_> =)
04:40:10 <basti_> you see a big gray thing that you know will silently pass you in any case... ;)
04:41:21 <basti_> i've never come to a situation like "oh i need a kind here"...
04:41:22 <ski> musasabi : how am i supposed to respond when you quit on me ?
04:41:43 <ski> basti_ : please, continue your parable :)
04:41:49 <basti_> -g-
04:42:15 <basti_> or maybe... you look at the floor and you see thin roots that are all intertwining
04:42:21 <basti_> and thicker roots
04:42:30 <basti_> and then you stumble over one of the thicker roots
04:42:34 <basti_> and fall on the floor
04:42:50 <basti_> and you think "ah... a mangrovia brugmanensis."
04:43:11 <ski> @type floor
04:43:13 <lambdabot> floor :: forall a b. (RealFrac a, Integral b) => a -> b
04:43:22 <basti_> its not like you want to cut it down, or that it would attack you.
04:43:52 <ski> (basti_ : sorry, just felt that that would be appropriate :)
04:44:02 <basti_> ski: *g*
04:45:38 <lstna> @type fmap
04:45:41 <lambdabot> fmap :: forall (f :: * -> *) b a.
04:45:41 <lambdabot>    (Functor f) =>
04:45:41 <lambdabot>    (a -> b) -> f a -> f b
04:45:44 <ski> basti_ : well .. ?
04:45:54 <basti_> ski: ...yes?
04:45:54 <ski> lstna : that is a good example
04:45:56 <lstna> Damn roots.
04:46:02 <ski> basti_ : finito ?
04:46:22 <basti_> ski: -grunt-
04:46:34 <ski> one instance of fmap is  fmap :: (a -> b) -> Maybe a -> Maybe b
04:46:38 <ski> wb musasabi
04:46:45 <basti_> lstna: this just says, f is a function on the typelevel
04:46:45 <musasabi> sorry - the university server died :-(
04:47:55 <basti_> lstna: and haskell just supports very primitive functions there as first class citizens
04:47:55 <lstna> I don't suppose that http://www.isi.edu/~hdaume/htut/ is available in html form anywhere?
04:47:59 <ski> musasabi : so the record you want to pass to all the "holes" in the tree is the whole tree ??  (also, if so, the whole tree before or after you "fill the holes" ?)
04:48:35 * boegel dances around in #haskell
04:48:55 <ski> lstna : you could try some of the other tutorials at http://www.haskell.org/learning.html
04:49:33 <lstna> I have ski
04:49:38 <ski> (lstna : though, beware, people say the "gentle" introduction isn't, at least for FP many newbies ..)
04:50:23 <ski> lstna : you have no ps/pdf viewer ?  or it's to clunky to read those formats ?
04:50:23 <musasabi> ski: hmm no. The record is just some value which happens to satisfy all the constraints of the holes.
04:51:24 <ski> "<musasabi> r is unified to the whole tree (it is the type of the record), .." this seemed to imply the record was the whole toplevel tree ..
04:51:32 <ski> good day Grimace
04:52:05 <lstna> I have acrobat and ghostview. pdf's are okay (tolorable) if they are properly indexed but that tutorial has no index. I see section in the contents, but there is no good way to move directly to it.
04:52:16 <ski> mhm
04:52:41 <ski> that could be annoying, yes
04:53:52 <ski> musasabi : hm, these "holes", they are always in same argument of same constructor, yes/no ?
04:53:59 <musasabi> ski: the whole tree should have a type like: "Tree ((Select r Field1 t1, Select r Field2 t2, ...) => r -> FilledTree)" (thus I want to both traverse it and create filled versions of it)
04:54:38 <lstna> open doc, scroll 10 pages  to find the contents. see something that loks related, scroll 30 pages to check it out no go to top scroll 10 pages to find contents, see something that looks related....<recurse>
04:54:58 <ski> m
04:55:14 * boegel slips while dancing and hits his head
04:55:25 <ski> and you currently want to understand kinds and their relation to typeclasses, yes ?
04:56:29 <SM_ax> can I somehow see patch-tag graph in darcs?
04:58:02 <lstna> ...which wouldn't be so bad if the 'page no' in the pages tab vaguel related to the 'page no' in the contents, but contents page 40 is page tab 51
04:58:21 <ski> musasabi : and the "filled" tree sometype like Tree FilledTree ??
04:58:39 <ski> lstna : sounds bad :(
04:59:06 <ski> hm
05:00:05 <musasabi> ski: yes.
05:00:18 <ski> hm
05:00:43 <ski> musasabi : but i don't see 't1','t2',... occur in the type you gave ?
05:01:25 <ski> lstna : you undertand  notation like    length [(1,"hej"),(3,"hello")] :: Int   ?
05:02:50 <ski> musasabi : and how's the type FilledTree defined ?  or maybe you were trying to define it ?
05:03:37 <lstna> I understand that the length of a list containing two tuples is an int.
05:03:41 <musasabi> ski: holes contain also a (t1 -> String) function (they are in my real code quite complex structures) so the FilledTree is monomorphic.
05:04:00 <ski> aha
05:04:23 <musasabi> I try to keep the problem description as simple as possible.
05:04:41 <ski> lstna : and you understand   [(1,"hej"),(3,"hello")] :: [(Int,String)]  ?
05:04:59 <ski> musasabi : as simple as possibly, but no simpler ! :)
05:05:46 <ski> (lstna : just checking what you understand ..)
05:06:02 <lstna> that a list of tuples of an int,string has a type of list of tuples of int, string.
05:06:10 <ski> lstna : you still wanna understand kinds and typeclasses, right ?
05:06:19 <ski> yes
05:06:23 <lstna> Yes.
05:06:26 <ski> that last can also be written like
05:06:33 <ski> [(1,"hej"),(3,"hello")] :: [] (Int,String)
05:06:49 <ski> where "[]" on the right-hand-side of "::" is a type constructor
05:07:16 <lstna> So, read that line in english?
05:07:34 <ski> here taking the type "(Int,String)" and resulting in the type "[(Int,String)]"  (which is the same as "[] (Int,String)")
05:07:37 <ski> ok
05:08:24 <ski> a list of two pairs of some integers and strings is of type list of pair of Int and String
05:09:42 <ski> (more specifically :  a list, whose first element is a pair of the integer 1 and the string "hej", and second element is a pair of the integer 3 and the string "hello" and no more elements is of type ...(same as above)... )
05:10:07 <ski> compare with
05:10:22 <ski> Just "something" :: Maybe String
05:10:41 <lstna> @type Just
05:10:44 <lambdabot> Just :: forall a. a -> Maybe a
05:10:52 <lstna> @type Maybe
05:10:54 <lambdabot> bzzt
05:11:09 <ski> the constructor Just applied to the string "something" is of type Maybe of (or applied to the type) String
05:11:36 <ski> well, @type only works for values/expressions  not types themselves
05:11:43 <ski> anyway
05:11:51 <ski> Int :: *   -- Int is a type
05:12:00 <ski> String :: *   -- String is a type
05:12:15 <ski> Maybe String :: *   -- Maybe String is a type
05:12:30 <ski> Maybe :: * -> *   -- Maybe is a type-function, taking types to types
05:12:51 <lstna> Maybe String is a /different/ type to String?
05:12:56 <ski> yes !
05:13:31 <ski> "Maybe :: * -> *"  doesn't say that, but it gives back a different type, yes
05:13:47 <ski> compare "->" above with
05:14:07 <ski> show :: Int -> String    -- show is a function, taking integers to strings
05:14:22 <Philippa> lstna: think about it - Nothing isn't a String
05:14:34 <ski> @type Nothing
05:14:36 <lambdabot> Nothing :: forall a. Maybe a
05:14:38 <ski> @type Nothing :: Maybe String
05:14:40 <lambdabot> Nothing :: Maybe String :: Maybe String
05:14:43 <ski> @type Nothing :: Maybe Int
05:14:45 <lambdabot> Nothing :: Maybe Int :: Maybe Int
05:15:02 <ski> (hm, that looks a little ugly ..)
05:15:08 <ski> @type (Nothing :: Maybe String)
05:15:10 <lambdabot> (Nothing :: Maybe String) :: Maybe String
05:15:24 <mflux_> @type Nothing :: Maybe Int :: Maybe Int
05:15:26 <lambdabot> bzzt
05:15:29 <mflux_> ;(
05:15:56 * basti_ checks out hOp
05:16:16 <ski> a value of type "Maybe ..some type here--" can be of two forms, either it is of the "Nothing" form, or it is of the "Just ..some value here.." form
05:16:27 <ski> @type (Nothing :: Maybe Int) :: Maybe Int
05:16:29 <lambdabot> (Nothing :: Maybe Int) :: Maybe Int :: Maybe Int
05:16:34 <ski> basti_: :-P
05:16:37 <ski> um
05:16:46 <ski> s/basti_/mflux_/
05:17:00 <ski> lstna : following at all ?  going to fast ?
05:17:05 <lstna> Hmmm. Now it looks like @type ~== 'echo'
05:17:13 <ski> well
05:17:25 <ski> if you have an expression "..some expression.."
05:17:53 <ski> you can wrap it in an explicit typing "..some expression.. :: ..some type.." and you get a new expression
05:17:59 <ski> e.g.
05:18:08 <ski> Nothing has type  Maybe Int
05:18:15 <ski> but it also has type Maybe Bool
05:18:34 <ski> in fact, for all types 'a', it has type 'Maybe a'
05:18:38 <ski> @type Nothing
05:18:40 <lambdabot> Nothing :: forall a. Maybe a
05:19:11 <ski> but, if you for some reason want to specifically restrict to "Nothing" of type "Maybe Int", say
05:19:35 <ski> you can type the expression "Nothing :: Maybe Int" and it will have type "Maybe Int"
05:20:18 <ski> this is in *no* way a 'cast' to the "Maybe Int" type, because the typesystem *checks* that the expression actually can have the type one "ascribes" to it
05:20:24 <ski> lstna : what do you say ?
05:20:48 <lstna> casts are easier
05:20:54 <basti_> lol
05:21:48 <lstna> I'm re-reading all that you have typed...
05:21:53 <basti_> ski: building hOp fails with lots of errors in the C-code
05:21:59 <lstna> (sic) :)
05:22:00 <basti_> parsing errors
05:22:16 <basti_> looks like C version problems
05:22:25 <ski> anyway, this "type ascription" only *constrains* the type of the thing ..
05:22:35 <ski> basti_ : ok, ..
05:23:19 * ski becomes a little sad
05:24:01 <ski> lstna : please shout stop if you feel i'm talking too much/fast :)
05:25:45 <lstna> Watching it scroll by and understanding it are two different things ski. I just need a few minutes to try and extract your stuff from the noise and digest it.
05:26:04 <ski> sure
05:28:36 <ski> good day tomdavie
05:28:50 <tomdavie> mornin
05:29:50 <ski> musasabi : so, when "filling in" the tree, you also convert the 't's to String (or your equivalent thereof) ?
05:30:33 <lstna> I think the answer I came looking for is right there in the line "ski Maybe :: * -> * -- Maybe is a type-function, taking types to types"
05:31:01 <ski> yes, that's a part of it
05:31:13 <lstna> And the concept that I am missing is the distinction between 'functions' and 'type-functions'
05:31:32 <ski> class Functor (f :: * -> *) where fmap :: forall a b :: *. (a -> b) -> f a -> f b
05:31:51 <ski> lstna : yeah, they are operating on different levels, so to speak
05:32:02 <ski> hiya hellish
05:33:40 <ski> lstna : you were interested also in how kinds relates to typeclasses ?
05:33:51 <ski> hellish : is it cold where you are ?
05:34:26 <lstna> and the confusion sets in because like -> has several interpretations depending upon context; so :: has more than one interpretation. Hence @type Maybe => bzzt.
05:34:36 <ski> yes
05:34:50 <lstna> @type 1::int
05:34:53 <lambdabot> bzzt
05:35:00 <ski> some people seem to write  Maybe ::: * -> *  instead
05:35:02 <lstna> @type 1::Int
05:35:03 <lambdabot> 1::Int :: Int
05:35:19 <lstna> @kind Maybe
05:35:21 <lambdabot> Maybe :: * -> *
05:35:46 <xerox> @kind Arrow
05:35:48 <lambdabot> bzzt
05:35:53 <xerox> @kind Control.Arrow.Arrow
05:35:55 <lambdabot> bzzt
05:36:02 <dons> @kind 1
05:36:03 <lstna> And people complain about apl overloading symbols
05:36:04 <lambdabot> 1 :: *
05:36:14 <boegel> is 'scalar product' a well known English term ? for the function which multiplies two vector term-wise and then adds the products ?
05:36:23 <ski> but, yes, "->" has one meaning on 'type-level' (namely 'function' type-constructor) and another on 'kind-level' (namely 'type-function' kind-constructor)
05:36:26 <dons> sorry, just to be *really* confusing
05:37:01 <ski> "@kind 1"  1 :: *  ???
05:37:29 * ski hasn't seen @kind before ..
05:37:53 <ski> xerox : i guess it doesn't work for typeclasses
05:37:58 <ski> @kind []
05:38:00 <lambdabot> [] :: * -> *
05:38:02 <ski> @kind IO
05:38:04 <lambdabot> IO :: * -> *
05:38:14 <ski> @kind Data.Array.Array
05:38:16 <lambdabot> Data.Array.Array :: * -> * -> *
05:38:19 <xerox> forall a. Arrow a :: * -> * -> *
05:38:20 * tomdavie wonders what kinds are
05:38:31 <xerox> tomdavie, types of types :)
05:38:41 <dons> values have types, types have kinds, (and kinds have sorts)
05:38:41 <ski> tomdavie : kinds is to types what types is to values/expressions
05:39:06 <hellish> ski: are you conducting a survey? It's about 50 degrees fahr. here.
05:39:07 <tomdavie> m'kay, so function type is a kind?
05:39:07 <lstna> Don't ask tomdavie...unless you have some tylonol
05:39:11 <lstna> :)
05:39:39 <tomdavie> lol... I'm in the mood for being nocked out... it's this or write my mini thesis, so this sounds better
05:39:43 <xerox> tomdavie, types have kind, functions have types.
05:39:57 <ski> hellish : no, just trying to be funny .. (i.e. regarding being cold in hell)
05:40:21 <tomdavie> uhhuh... so, give me an example... I've seen a few scroll up, but haven't figured out what they meant
05:40:24 <hellish> ski: Oh. Lost on me then.
05:40:30 <ski> (hellish : i assume you know many hells are freezing cold, right ?)
05:40:35 <tomdavie> @kind a -> b
05:40:36 <lambdabot> bzzt
05:40:43 <tomdavie> bwuh?
05:40:48 <ski> @kind Int -> Bool
05:40:50 <lambdabot> Int -> Bool :: *
05:40:56 <xerox> tomdavie, which function is a -> b? :-)
05:40:58 <ski> @kind (->) Int
05:41:00 <lambdabot> (->) Int :: ? -> *
05:41:04 <ski> hm ?
05:41:08 <ski> @kind (->)
05:41:08 <xerox> :-)))
05:41:09 <lambdabot> (->) :: ?? -> ? -> *
05:41:14 <ski> wtf
05:41:20 <tomdavie> xerox: it isn't, it's a type... that's why I expected it to have a kind
05:41:22 <xerox> It's explained somewhere in GHC's docs.
05:41:24 <ski> (->) :: * -> * -> *  surely
05:41:59 <Grimace> a is not a Haskell data type, nor is b
05:42:21 <xerox> @kind forall a b. a -> b
05:42:22 <lambdabot> forall a b. a -> b :: *
05:42:32 <tomdavie> ahh... okay
05:42:49 <TheHunter> @kind (->) Int#
05:42:51 <lambdabot> bzzt
05:42:54 <TheHunter> @kind (->) GHC.Base.Int#
05:42:56 <lambdabot> (->) GHC.Base.Int# :: ? -> *
05:42:57 <tomdavie> so... Int -> Bool :: * says what?
05:43:00 <ski> tomdavie : well,  Just 1 :: Maybe Int  (Just 1 has type Maybe Int)   Maybe Int :: *  (Maybe Int has kind *, i.e. is a type)    Maybe :: * -> *  (Maybe has kind * -> *, i.e type-function taking types to types)
05:43:00 <lstna> @type fmap
05:43:02 <lambdabot> fmap :: forall (f :: * -> *) b a.
05:43:02 <lambdabot>    (Functor f) =>
05:43:02 <lambdabot>    (a -> b) -> f a -> f b
05:43:07 <TheHunter> @kind GHC.Base.Int# -> GHC.Base.Int#
05:43:09 <lambdabot> GHC.Base.Int# -> GHC.Base.Int# :: *
05:43:26 <TheHunter> @kind (# GHC.Base.Int#, GHC.Base.Int# #) -> GHC.Base.Int#
05:43:28 <lambdabot> bzzt
05:43:34 <tomdavie> ah... okay, now I get you
05:43:36 <Grimace> so... (->) takes a type (??) and another type (?) and returns a type (*)
05:43:38 <TheHunter> @kind GHC.Base.Int# -> (# GHC.Base.Int#, GHC.Base.Int# #)
05:43:40 <lambdabot> GHC.Base.Int# -> (# GHC.Base.Int#, GHC.Base.Int# #) :: *
05:43:47 <Grimace> am I reading that right?
05:44:09 <tomdavie> so... why does -> have kind ? -> *, not * -> *
05:44:18 <TheHunter> no, ?? is boxed or unboxed, ? additionally allows unboxed tuples.
05:44:19 <ski> TheHunter : ah, yes, forgot about unboxed mes^H^H^Htypes ..
05:44:37 <musasabi> ski: yes, I first do the (r -> FieldN -> tN) and then (tN -> String) so the endresult is monomorphic. (and select enforces r FieldN -> tN)
05:44:57 <Grimace> oho, right, now it just flies further above my head than it was already, so I'll stop trying to follow along ;)
05:45:15 <ski> lstna : in typing of fmap, "b :: *,a :: *" is implied in the 'forall'
05:45:28 <ski> lstna : rather, it's the default, if nothing else is said
05:45:55 <tomdavie> so... I'm assuming that there's such a thing as a meta-kind (i.e. all kinds have meta-kinds), and so on for ever, right?
05:46:25 * lstna needs a better irc client.
05:46:30 <tomdavie> or is there some upper limit to this where it all just reduces to *?
05:46:31 <TheHunter> ski, btw, in java, i think you can't get variance, and i could only get the explicit cast into one direction to work, since you appearantly can't restrict a type variable to a supertype of a given type.
05:46:36 <ski> Grimace : 'tseems "*" is for boxed types "?" is for unboxed types, and "??" is for either of them ..
05:47:00 <tomdavie> @google boxed types
05:47:02 <lambdabot> http://msdn.microsoft.com/library/en-us/vcmxspec/html/vcManagedExtensionsSpec_5_2_2.asp
05:47:12 <tomdavie> that's gonna be useless isn't it
05:47:32 <ski> TheHunter : you mean Java has no depth subtyping ? (except the broken one for arrays) (well, i haven't looked at the new generics so can't speak of that ..)
05:47:34 <Grimace> @google "boxed types" "unboxed types"
05:47:36 <lambdabot> http://lambda-the-ultimate.org/classic/message12542.html
05:47:41 <TheHunter> <pedantic> # is boxed, ? is * or #
05:49:13 <ski> aha
05:49:24 <TheHunter> ski, right, only the broken array subtyping as far as i see it.
05:49:26 <ski> (didn't know that detail)
05:49:34 <ski> TheHunter : then what is "??" ?
05:49:52 <lstna> ski: I just got what you mean by "ski	lstna : in typing of fmap, "b :: *,a :: *" is implied in the 'forall'"
05:50:00 <ski> TheHunter : OCaml ?
05:50:10 <ski> lstna : yay! nice
05:50:36 <TheHunter> ski, ?? is # or an unboxed tuple.
05:50:53 * TheHunter has never touch ocaml before.
05:51:08 <TheHunter> *touched
05:51:29 <ski> tomdavie : i think one can go on endlessy. another side would be how far one actually needs to go, in practical programs (well, more or less practical, at least :)
05:51:32 <TheHunter> scala looks interesting...
05:51:53 <tomdavie> hehe... practicalities have never bothered me ;)
05:51:55 <xerox> needle!
05:52:00 <ski> TheHunter : iirc it has depth-subtyping. and an interresting OO system
05:52:55 <ski> TheHunter : hm, (above) which direction ?
05:52:56 <lstna> @type map
05:52:58 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
05:53:02 <lstna> @type fmap
05:53:04 <lambdabot> fmap :: forall (f :: * -> *) b a.
05:53:04 <lambdabot>    (Functor f) =>
05:53:04 <lambdabot>    (a -> b) -> f a -> f b
05:53:52 <TheHunter> ski, ReadRefs don't work; this gives a parse error: public <U super T> ReadRef<U> cast()
05:54:18 * tomdavie wonders how clever lambdabot is
05:54:18 <tomdavie> @kind (@type map)
05:54:19 <lambdabot> bzzt
05:54:24 <ski> TheHunter : so we have a small subkinding system with # <: ?, * <: ?, then ? :)
05:54:32 <tomdavie> apparently not that clever ;)
05:54:55 <ski> tomdavie : the kind of the type any value (which is well-typed) must be *
05:55:17 <ski> * is the kind of real types (i.e. such that have values)
05:55:29 <tomdavie> yeh... I just wondered if it would do it
05:55:30 <ski> there are no values of "type" Maybe
05:55:39 <tomdavie> uhhuh
05:56:08 <ski> just values of type Maybe Int, e.g.  or Maybe ([String],Maybe Int)
05:56:20 <tomdavie> uhhuh
05:56:25 <boegel> anyone would like to comment on my HRay article ? I'm not sure I'll be able to finish it for the next issue of TMR though
05:56:55 <tomdavie> what I'm trying to figure out is what makes a type boxed or unboxed... google is having a lot of trouble explaining
05:57:36 <ski> @type (map :: forall a b. (a -> b) -> [] a -> [] b)
05:57:38 <lambdabot> (map :: forall a b. (a -> b) -> [] a -> [] b) :: forall a b.
05:57:38 <lambdabot>                  (a -> b) -> [a] -> [b]
05:58:01 <tomdavie> heh... interesting
05:58:02 <ski> tomdavie : unboxed types is a ghc-extension, it's not in Haskell98
05:58:07 <TheHunter> @kind GHC.Base.Int#
05:58:08 <lambdabot> GHC.Base.Int# :: #
05:58:21 <tomdavie> ski: m'kay, so, what do they do?
05:58:25 <ski> @type GHC.Base.I#
05:58:27 <lambdabot> GHC.Base.I# :: GHC.Prim.Int# -> Int
05:59:03 <TheHunter> this is unboxed, i.e. ghc's low-level representation of an Int. For efficiency, this can be accessed if you know what you're doing.
05:59:08 <ski> tomdavie : well, an Int# is strict (i.e. not lazy)
05:59:21 <lstna> @type Functor
05:59:23 <lambdabot> bzzt
05:59:27 <tomdavie> ohhh... interesting :/
05:59:40 * tomdavie wonders what that gets you
05:59:48 <ski> class Functor (f :: * -> *) where fmap :: forall a b :: *. (a -> b) -> f a -> f b
06:00:22 * ski would maybe say   Functor :: (* -> *) -> instance
06:01:03 <tomdavie> okay... so functor takes a type of kind *->* (e.g. Maybe) and creates an instance of fmap?
06:01:11 <lstna> So Functor is a /type-class/? Which is different from a type and a kind?
06:01:34 * basti_ builds a brand new ghc
06:01:35 <ski> tomdavie : so if you do  "case someInt of I# unboxedInt -> ..."   then this will force "someInt" right when this expr gets evaluated
06:02:01 <tomdavie> oh... okay
06:02:13 <ski> lstna : yes, Functor is a type-class, and yes that's different from a type and a kind
06:02:15 <tomdavie> but... why?
06:02:23 <TheHunter> ski, i finally got it; we can have Read/Write-Refs with appropriate supertyping in haskell, but we can't abstract that behavior in a class. A ReadRef is just Ref<? extends B> rr.
06:02:31 <tomdavie> is there some reason that lazy-evaluation buggers you sometimes?
06:02:48 <xs> efficiency?
06:03:01 <ski> TheHunter : "... A ReadRef is just Ref<? extends B> rr." ??
06:03:09 <tomdavie> but... usually strict evaluation is less efficient isn't it?
06:03:24 <tomdavie> i.e. you do more evaluation because you evaluate *everything(
06:03:26 <tomdavie> *
06:03:42 <TheHunter> @paste
06:03:43 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:03:44 <CosmicRay> coool, lambdabot can report darcs changes to an irc channel
06:03:46 <CosmicRay> that is awesome
06:04:00 <ski> tomdavie : no, functor takes a type of kind "* -> *" (e.g. "Maybe") and creates the kind (imo) of instances (i.e. a class)
06:04:14 <tomdavie> ah... okay
06:04:25 <ski> maybe it would be better to say   Functor :: (* -> *) -> class
06:04:29 <ski> i haven't decided
06:04:40 <ski> (read : haven't thought it through properly :)
06:04:58 <TheHunter> ski, Foo<? extends B> would be |exists X. X extends B => Foo<X>| in a more conventional notation.
06:05:20 <ski> what strange beast is "Foo<?" and "B>" ?
06:05:33 <ski> hm
06:05:37 <lstna> Ski: was 'functor' in that last sentence different from 'Functor' above?
06:05:39 * ski reparses
06:05:54 <ski> lstna : no, don't think so
06:06:28 <lstna> Phew. That's a relief.
06:06:28 <ski> TheHunter : ah, "Foo<? extends B>" is java syntax, with type parameter, right ?
06:07:01 <ski> TheHunter : if so, then yes to last
06:07:04 <TheHunter> yes, it's java syntax.
06:07:27 <bourbaki> sabah al-chair
06:07:37 * ski parsed that as "Foo<?" extending "B>" .. :(
06:08:07 <TheHunter> hehe.
06:08:08 <ski> bourbaki : salaam
06:08:27 <ski> (bourbaki : that was arabic (farsi ?), right ?)
06:09:24 <bourbaki> ski: yes
06:09:38 <yoshi> hi all
06:09:45 <bourbaki> though you shouldnt answer with salam if you arent a muslim :)
06:09:50 <bourbaki> hi single
06:09:55 <yoshi> am I in #haskell? im newbie
06:09:58 <ski> tomdavie : lazy can be both sometimes more efficient and sometimes less efficient. though there's an overhead with creating a thunk if the thunk will be forced exactly once, yes
06:10:10 <bourbaki> yoshi: yes :)
06:10:13 <yoshi> hehe
06:10:15 <yoshi> thanks
06:10:21 <ski> yoshi : you are in #haskell, yes.  feel welcome ! :)
06:10:25 <yoshi> it's the first time I use X-chat
06:10:30 <basti_> how do i give command line parameters via the source file? {--# -blah #--} ?
06:11:15 <ski> bourbaki : ok :)
06:11:33 <yoshi> I need some help to pass my haskell subject this evening
06:11:44 <bourbaki> ski: because some say that peace is only possible between muslims :)
06:11:53 <ski> basti_ : something like {-# OPTIONS ... #-} iirc (which i may not)
06:12:07 <ski> bourbaki : aha !
06:12:11 <TheHunter> ski, it put my code on the paste page.
06:12:15 <yoshi> I have a program in HUGS and I have to trasform it in haskell98
06:12:30 <bourbaki> ski: a propper aswer would have been sadah al-ward
06:12:31 <yoshi> and i don't know how to change /= t haskell98
06:12:33 <ski> TheHunter : what's this 'it' you speak of ?
06:12:40 <bourbaki> a rosy morning
06:12:42 <yoshi> the program
06:12:42 <bourbaki> hi TheHunter
06:12:44 <yoshi> :P
06:12:46 <TheHunter> hi bourbaki
06:12:49 <yoshi> hi
06:13:01 <TheHunter> ski, that's me (spelling error...)
06:13:54 <yoshi> could anyone see the program and try to compile with helium?
06:14:22 <basti_> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#options-pragma
06:15:05 <ndm> yoshi: helium is not Haskell 98
06:15:15 <yoshi> sorry
06:15:24 <ski> basti_ : ok, OPTIONS_GHC 'tseems, now
06:15:26 <ndm> its a subset of Haskell, designed for introductory uses
06:15:31 <yoshi> yeah
06:15:46 <yoshi> I was wrong
06:15:47 <yoshi> :D
06:16:03 <ndm> (/=) is valid Haskell, and Hugs is mostly Haskell 98 compliant
06:16:05 <ski> bourbaki : ok, 'll try to remember that ..
06:16:10 <yoshi> hummm
06:16:27 <ski> (bourbaki : and maybe you would be so kind as to tell what it means, as well ?)
06:16:38 <bourbaki> ski: ok sabah al-ischta :) a creamy morning ;)
06:16:46 <yoshi> it's valid if I compare two integers, but no for strings
06:16:56 <bourbaki> ski: i did sabah al-ward means a rosy morning
06:17:01 <yoshi> it's ok with hugs but not with helium
06:17:04 <ski> "sabah al-chair" = "a chairy morning" ??
06:17:22 <bourbaki> ski: no thats just a good morning :)
06:17:24 <ski> bourbaki : ok
06:17:35 <ski> :)
06:17:38 <bourbaki> and masa al-chair is good evening
06:17:48 <wilx> Arabic?
06:17:55 <bourbaki> yep
06:17:55 <ndm> yoshi: yes, it would be
06:18:15 <ndm> in Haskell the type of /= is: Eq a => a -> a -> Bool
06:18:25 <ndm> in Helium its: Int -> Int -> Bool
06:18:30 <yoshi> yes, but I have
06:18:32 <ski> @type (/=)
06:18:34 <lambdabot> (/=) :: forall a. (Eq a) => a -> a -> Bool
06:18:38 <ndm> Haskell has a feature called type classes, such as Eq
06:18:41 <ndm> helium doesn't
06:19:04 <ndm> so haskell will allow *any* type for which their is an equality, helium only allows integers to use ==
06:19:44 <ndm> i guess in helium there will be some "strEq" function, but no idea what its called
06:19:48 <yoshi> I have [Int]->[a] and /= doesn't work with this
06:19:49 <ski> yoshi : where is said code located, pertell ?
06:19:51 <ndm> and if not, you can define your own
06:20:15 <ski> you can't compare functions with (/=) (or (==) )
06:20:15 <yoshi> the problem it's that all eq* are form same types
06:20:21 <ski> wb lstna
06:20:27 <yoshi> yes, but works with hugs
06:20:45 <yoshi> humm
06:20:52 <lstna> Thanks ski
06:21:03 <ski> tomdavie : and you too, of course :)
06:21:07 <musasabi> ski: I solved my problem :-)
06:21:29 <ski> musasabi : oh :(  (so will i get to understand what your problem was ?)
06:21:59 <yoshi> ok, see this
06:22:09 <yoshi> buscaDiccionario :: [String] -> [String] -> [String]
06:22:23 <yoshi> buscaDiccionario sopa dic =   [p | l<- lecturas sopa, p <- dic, busca p l /= []]
06:22:34 <yoshi> see /=?
06:22:39 <musasabi> http://youzen.b2.fi/~musasabi/f.hs - was trying too hard solutions.
06:22:54 <tomdavie> thanks guys... I *think* I've got it sorted in my head now
06:23:09 <ski> TheHunter : you mean if one uncomments the commented code, it will give compile-time error ?
06:23:09 <ndm> yoshi: helium is strictly less powerful than hugs
06:23:17 <ndm> any particular reason you want to use helium?
06:23:32 <yoshi> yes, it's the program we use in class
06:23:39 <ski> yoshi : what's the type of busca ?
06:24:00 <yoshi> busca :: String -> String -> [Int]
06:24:31 <yoshi> maybe if I send u the program, it's a program to search words in a letter's soup
06:24:45 <yoshi> maybe u have a similar program :D
06:26:44 <TheHunter> ski, right. And the //  WriteRef<B> wr = new WriteRef<B>(ref) stuff shouldn't be there...
06:26:48 <ski> musasabi : ok, mhm
06:27:17 <yoshi> I could put the program here, but i think it's not a nice way
06:27:27 <yoshi> for u to see my problem
06:27:55 <ski> yoshi : you only want an "(/=) :: [Int] -> [Int] -> Bool", there
06:27:59 <ski> it seems
06:28:01 <genneth> yoshi: try the pastebin in the haskell wiki
06:28:12 <ski> @paste
06:28:41 <yoshi> I only need the program to work with helium
06:28:50 <ski> @wiki HaskellIrcPastePage
06:28:53 <yoshi> but I need it today
06:29:13 <yoshi> that's the problem, it's hurry or I can't pass the subject
06:29:14 <yoshi> hehe
06:29:15 <genneth> has lambdabot died?
06:29:17 <ski> yoshi : is the problem that you want to compare "busca p l" to "[]" ?
06:29:33 <yoshi> yes
06:29:39 <bourbaki> is there any 2d lib for haskell that is easy to use without installing alot and such? or maybe someone of you would be interested in helping me to build a 2d renderer with ogl and textures (window manager like)
06:29:43 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:29:43 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:29:50 <ski> generally, you'd have to use some general list-equality function, for that
06:29:52 <ski> like
06:30:08 <ski> eqList :: (a -> a -> Bool) -> [a] -> [a] -> Bool
06:30:10 <ski> and then write
06:30:11 <lstna> genneth: I think so. it isn't responding in private either
06:30:28 <ski> not (eqList (==) (busca p l) [])
06:30:36 <ski> but, in this case it's easier
06:30:39 <ski> @type null
06:30:41 <lambdabot> null :: forall a. [a] -> Bool
06:30:52 <ski> that tests if a list is empty
06:30:59 <ski> yoshi : use that
06:31:09 <lstna> or maybe not.
06:31:44 <ski> lambdabot: are you slow, today ?
06:32:03 <ski> bah
06:32:04 <Lemmih> bourbaki: I got a binding for SDL.
06:32:06 <genneth> @type and
06:32:08 <lambdabot> and :: [Bool] -> Bool
06:32:26 <bourbaki> Lemmih: ah how hard is it to use that?
06:32:29 <ski> yoshi : whaddya say ?
06:32:32 <yoshi> ski, Can I send u the program? Use HUGS, just load and type buscaDiccionario ["asdasdsoupasdasdas","ofdasdasdasdasd","lettersasdasdasd"] ["soup","of","letters"] and the program will search soup at letter's soup (first [])
06:32:53 <Lemmih> bourbaki: It only depends on hsc2hs which is distributed with GHC.
06:32:59 <ski> yoshi : have you tried using 'null' yet ?
06:33:11 <bourbaki> Lemmih: oh cool hsc2hs is what?
06:33:13 <yoshi> no, I think I am too newbiy
06:33:16 <yoshi> no, I think I am too newbie
06:33:27 * ski btw doesn't think he has hugs installed at this machine ..
06:33:27 <yoshi> i don't know null command mean
06:33:33 <yoshi> ou
06:33:39 <ski> null is a function
06:33:41 <yoshi> ouch (homer simpson)
06:33:49 <ski> null []  evaluates to True
06:33:56 <ski> null [1,2,3] evaluates to False
06:34:20 <Lemmih> bourbaki: It's a small FFI tool. Very handy when making bindings.
06:34:29 <yoshi> I am lost... Do have Hugs install?
06:34:34 <bourbaki> ah ok
06:34:41 <yoshi> sorry
06:34:48 <yoshi> helium installed. someone?
06:35:00 <ski> yoshi : if you type "null (busca p l)" that will check if the list is *empty*, and you want to check if it is *not* empty, so use the function "not" also
06:35:02 <ski> @type not
06:35:04 <lambdabot> not :: Bool -> Bool
06:35:11 <yoshi> ok
06:35:17 <yoshi> i am going to try now
06:35:23 <ski> good
06:36:54 <lstna> @type Num
06:36:55 <yoshi> humm no errors
06:36:56 <lambdabot> bzzt
06:37:02 <yoshi> ski u are the boss
06:37:04 <lstna> @kind Num
06:37:06 <lambdabot> bzzt
06:37:17 <ski> (yoshi : i could of course have a look at your program, but i think you learn better by trying to change the prog yourself. i hope you understand me.  if you really can't fix it i will look at it, ok ?)
06:37:27 <ski> yoshi : it works yet ?
06:38:21 <yoshi> yes i now
06:38:21 <ski> class (Show a,Ord a) => Num a where ...
06:38:24 <yoshi> thanks
06:38:29 <yoshi> humm
06:38:33 <ski> yoshi : great ! :)
06:38:38 <yoshi> the program runs but not properly
06:38:41 <ski> ok
06:38:48 <yoshi> :(
06:38:49 <yoshi> hehe
06:40:18 <genneth> @type \l -> (\a b -> and $ zipWith (==) a b) []
06:40:20 <lambdabot> \l -> (\a b -> and $ zipWith (==) a b) [] :: forall a t.
06:40:20 <lambdabot>                (Eq a) =>
06:40:20 <lambdabot>                t -> [a] -> Bool
06:41:03 <genneth> @type \l -> (\a b -> and $ zipWith (==) a b) [] l
06:41:05 <lambdabot> \l -> (\a b -> and $ zipWith (==) a b) [] l :: forall a.
06:41:05 <lambdabot>                 (Eq a) =>
06:41:05 <lambdabot>                 [a] -> Bool
06:41:06 <ski> why the nonused 'l' ?
06:41:13 <ski> m
06:41:19 <genneth> just so i can get the point free version now... :p
06:41:28 <genneth> @pl \l -> (\a b -> and $ zipWith (==) a b) [] l
06:41:30 <lambdabot> and . zipWith (==) []
06:41:39 <genneth> so much neater, no?
06:41:44 <genneth> :-D
06:41:58 <ski> const True
06:42:06 <ski> is even more neat
06:42:13 <genneth> i still suck at creating point-free forms
06:42:16 <yoshi> humm
06:42:19 <genneth> i can just about read them
06:43:04 <yoshi> ski
06:43:09 <ski> you rang ?
06:43:09 <yoshi> i'll put the not
06:43:14 <yoshi> and now runs!
06:43:18 <yoshi> thanks a lot
06:43:25 <ski> and .. runs correctly ?
06:43:36 <yoshi> yes
06:43:46 <genneth> ski: i wonder if you could use QuickCheck to do some testing?
06:43:46 <ski> @yay
06:43:48 <lambdabot> Yow!  Am I having fun yet?
06:43:56 <genneth> @moo
06:44:09 <ski> genneth : that was disabled, methinks
06:44:17 <genneth> waaahh!?
06:44:19 <genneth> that's terrible
06:44:24 <yoshi> ski, u are the god of haskel
06:44:38 <ski> genneth : QuickCheck could be used for testing, to say the least, yes :)
06:44:53 <ski> yoshi : no, i amn't
06:45:18 <ski> we are all learning ..
06:45:25 <genneth> ski: you can claim the title for the moment, whilst shapr's out ;)
06:46:18 <TheHunter> @moo
06:46:47 * ski takes the title, puts some butter on it, and tries chewing it .. hmm tastes weird .. mm .. all-power come-to-me !! .. um, better take that out before i'm crazed with power .. muahaha 
06:47:15 <yoshi> ski, imagine you have a list of strings, and do u want to search a word in all strings, and u want to put a '-' where the word it isn't, and put only the word, if it appears. For example: you have this "dsdhelloasdasd" and the word it's hello, so i want to take this  "---hello----"
06:47:17 <ski> good day to you, rhat
06:47:30 <ski> everything is normal here, yes :)
06:47:42 <rhat> ski: hello to you to...?
06:47:48 * rhat is confused
06:47:48 <yoshi> hello rhat
06:48:21 <rhat> my entry normally doesn't generate so many welcome messages
06:48:27 <rhat> hi though!
06:48:49 <ski> yoshi : "dsdhelloasdasd" is a string, now a list of strings ..
06:49:06 <yoshi> yeah, this was only an example to see easily
06:49:34 <ski> you want to search for word as a whole string-element in the list ?  or search inside the string-elements ?
06:50:22 <yoshi> a list of strings could be ["dsddcsfsdasd","dsdhelloasdasd","dsdsdfdsfdasd","dsdsdfsdfsdasd"] and I want to take this ["-----------","---hello------","-----------","-------"]
06:50:34 <yoshi> each string element
06:51:02 <ski> replaceAllBut "hello" ["dsd","hello","asd","asd"] = ["-","hello","-","-"]  ?
06:51:17 <genneth> @pl \b s ->
06:51:19 <lambdabot> (line 1, column 8):
06:51:19 <lambdabot> unexpected end of input
06:51:19 <lambdabot> expecting lambda abstraction or expression
06:51:21 <genneth> oops
06:51:33 <genneth> ski: i think he wants one '-' per letter
06:51:34 <ski> yoshi, ok
06:51:43 <yoshi> yeah, but with the same number of elements for each string element, think each is a row of a letter's soup
06:51:53 <ski> hm
06:51:54 <yoshi> yes it was on e '-' per letter
06:52:03 <yoshi> i though one think
06:52:10 <ski> well
06:52:13 <rhat> ski: couldn't you just write a padding function?
06:52:23 <ski> the outer structure is just a map
06:52:48 <yoshi> to compare each letter with head of word, but if I have this dasdasdhasdasdhello will put ----h----hello and this is wrong
06:53:16 <boegel> Lemmih, bourbaki: any of you guys up for proof-reading the first part of my HRay article ?
06:53:17 <ski> how about the word being "abca" and the string-list being ["xyzabcabca123"] ?
06:53:57 <ski> ["---abca------"] or ["------abca---"] or ["---abcabca---"]  ?
06:53:57 <yoshi> will put "---abcabca---"
06:54:04 <Lemmih> boegel: Yep.
06:54:23 <ski> (KMP-like, then ..)
06:54:43 <yoshi> I don't know what a KMP is
06:55:02 <ski> KMP = Knuth-Morris-Pratt
06:55:11 <ski> and is an algorithm for string-matching
06:55:25 <yoshi> ok
06:55:36 <ski> here i just mean that you possibly want to check for start of one string *inside* another matching string
06:55:53 <ski> (which KMP also does)
06:56:13 <yoshi> yes
06:56:27 <genneth> i'm thinking one way is to decompose the string into a list of substrings, each of length of the string that we're looking for
06:56:38 <Lemmih> boegel: URL?
06:56:39 <ski> this seems like an interesting problem ..
06:56:42 <genneth> then *somehow* get them back together
06:56:51 <ski> ;)
06:56:57 <genneth> :-p
06:57:33 <rhat> ski: I think it's one of those common problems when dealing with strings, as I remember solving a similar porblem in Lisp about a week ago
06:57:36 <yoshi> if I have ["dsddhellollehasd"] -> "----hellolleh" because I have 'hello' and 'olleh' (that it's hello in other way
06:57:52 <yoshi> remember this is a letter's soup
06:57:58 <yoshi> hehe
06:58:03 <ski> you want to do this with multiple 'words' at the same time ?
06:58:08 <yoshi> yes
06:58:12 <ski> ok
06:58:15 <ski> hm
06:58:21 <yoshi> but I will be happy with only one word
06:58:30 <yoshi> searching from left to right
06:58:38 <yoshi> not all directions
06:58:45 <ski> maybe one way would be to generate a list of booleans corresponding to whether we should "black out" a character or not
06:58:54 <yoshi> ok
06:58:56 <yoshi> and then
06:59:02 <ski> and then zipWith (&&)
06:59:10 <ski> or something like that
07:00:05 <yoshi> .
07:00:12 <yoshi> ok, thinking mode
07:00:39 <ski> hmm  let n = length word in map (\t -> take n t == word) (tails str)
07:01:09 <ski> hm
07:01:12 <ski> not quite
07:01:15 <yoshi> maybe
07:01:19 <yoshi> but no '-'
07:01:31 <ski> that can be the final touch, methinks
07:02:13 <yoshi> one thing, what is bs@(b:bs') in buscaPrefijosDesde :: Int -> String -> String -> [Int]busca :: String -> String -> [Int]
07:02:13 <yoshi> buscaPrefijosDesde _   _  []         = []     buscaPrefijosDesde pos as bs@(b:bs') =   [ pos | prefijo as bs ] ++  buscaPrefijosDesde (pos+1) as bs'
07:02:24 <yoshi> grrr, newlines!
07:02:49 <yoshi> bs@(b:bs') is bs==(b:bs')
07:03:14 <yoshi> could I change bs with (b:bs')
07:03:16 <yoshi> ?
07:04:15 <ski> @type \word str -> let n = length word in foldr1(zipWith (||)) (map (\(i,t) -> replicate i False ++ replicate n (take n t == word) ++ repeat False) (zip [0..] (tails str)))
07:04:16 <lambdabot> bzzt
07:04:20 <ski> bah! :)
07:04:42 <yoshi> hehe
07:04:43 <ski> hm ..
07:04:50 <yoshi> master!
07:05:11 <ski> journeyman, mayhaps
07:05:19 <yoshi> @type \word str -> ????
07:05:19 <genneth> my hugs complains about the tails
07:05:20 <lambdabot> bzzt
07:05:25 <genneth> @index tails
07:05:27 <lambdabot> Data.List
07:05:27 <yoshi> it's just code or a comment
07:05:48 <ski> @type \word str -> (word ++ "","apa" ++ str)
07:05:50 <lambdabot> \word str -> (word ++ "","apa" ++ str) :: [Char]
07:05:50 <lambdabot>               -> [Char]
07:05:50 <lambdabot>               -> ([Char], [Char])
07:06:02 <ski> type String = [Char]
07:06:14 <yoshi> sorry I don't understand!
07:07:29 <genneth> @type \word str -> let n = length word in foldr1(zipWith (||)) (map (\(i,t) -> replicate i False ++ replicate n (take n t == word) ++ repeat False) (zip [0..] (tails str)))
07:07:29 <poetix> @seen shapr
07:07:30 <lambdabot> shapr is in #haskell. I don't know when shapr last spoke.
07:07:30 <lambdabot> bzzt
07:07:33 <ski>  bs@(b:bs')  is a pattern, thatm will check if a list is nonempty, and in that case call the head/first element  b  and the tail/rest of elements  bs'  , also calling the whole list  bs
07:07:43 <genneth> why does that fail? hugs likes it
07:07:57 <yoshi> yeah, it's helium
07:08:01 <ski> possibly some module not loaded ..
07:08:15 <yoshi> no no
07:08:40 <ski> ah
07:08:41 <yoshi> is there a way to change the pattern for someting more 'simple'
07:08:42 <yoshi> ?
07:09:01 <ski> @type \word str -> let n = length word in foldr1(zipWith (||)) (map (\(i,t) -> replicate i False ++ replicate n (take n t == word) ++ repeat False) (zip [0..] (Data.List.tails str)))
07:09:03 <lambdabot> \word str -> let n = length word in foldr1(zipWith (||)) (map (\(i,t)
07:09:03 <lambdabot> -> replicate i False ++ replicate n (take n t == word) ++ repeat
07:09:03 <lambdabot> False) (zip [0..] (Data.List.tails str))) :: forall a.
07:09:03 <lambdabot>                                                             (Eq [a])
07:09:03 <lambdabot> =>
07:09:03 <lambdabot>                                                             [a]
07:09:06 <lambdabot>                                                             -> [a]
07:09:07 <lambdabot>                                                             -> [Bool]
07:09:26 <ski> yoshi : depends on what you want
07:09:44 <genneth> @pl \word str -> let n = length word in foldr1(zipWith (||)) (map (\(i,t) -> replicate i False ++ replicate n (take n t == word) ++ repeat False) (zip [0..] (Data.List.tails str)))
07:09:47 <lambdabot> liftM2 flip (((foldr1 (zipWith (||)) .) .) . (. (zip [0..] . ((Data .
07:09:47 <lambdabot> List) .) . tails)) . flip . (map .) . flip flip snd . (ap .) . flip
07:09:47 <lambdabot> flip fst . (((.) . flip ((.) . (++) . flip replicate False)) .) .
07:09:47 <lambdabot> flip flip (repeat False) . ((flip . ((++) .)) .) . liftM2 (.)
07:09:47 <lambdabot> replicate . flip (flip . ((==) .) . take)) (fix . const . length)
07:09:52 <ski> genneth : baad boy !
07:09:55 <genneth> :-D
07:09:57 <yoshi> ok, the @ is not a problem, just a doubt
07:09:58 <yoshi> :D
07:10:47 <yoshi> maybe if u put the program in a file and send me to see and test, I understand
07:10:56 <ski> a patten of form  var@pat  means that the argument value will be matched against the pattern  pat  and, if that succeeds (and possibly binds some variables) will also bind the variable  var  to the whole argument value
07:11:19 <yoshi> Please send files to goobling@hotmail.com
07:11:32 <ski> @plugs (\word str -> let n = length word in foldr1(zipWith (||)) (map (\(i,t) -> replicate i False ++ replicate n (take n t == word) ++ repeat False) (zip [0..] (Data.List.tails str)))) "abca" "123abcabca123"
07:11:35 <lambdabot> [False,False,False,True,True,True,True,True,True,True,False,False,
07:11:35 <lambdabot> False,False,False,False,False,False,False,False,False,False,False,
07:11:35 <lambdabot> False,False,False,False,False,False,False,False,False,False,False,
07:11:35 <lambdabot> False,False,False,False,False,False,False,False,False,False,False,
07:11:35 <lambdabot> False,False,False,False,False,False,False,False,False,False,False,
07:11:35 <lambdabot> False,False,False,False,False,False,False,False,False,False,False,
07:11:37 <lambdabot> False,False,False,False,False,False,False,False,False,False,False,
07:11:39 <basti_> False.
07:11:39 <lambdabot> [25 @more lines]
07:11:41 <ski> @stop
07:11:42 <lambdabot> Unknown command, try @listcommands.
07:11:44 <ski> hm
07:11:53 <ski> ah
07:12:09 <ski> @plugs (\word str -> let n = length word in foldr (zipWith (||)) (replicate n False) (map (\(i,t) -> replicate i False ++ replicate n (take n t == word) ++ repeat False) (zip [0..] (Data.List.tails str)))) "abca" "123abcabca123"
07:12:12 <lambdabot> [False,False,False,True]
07:12:15 <ski> :)
07:12:18 <ski> :(
07:12:19 <ski> i meant
07:12:24 <yoshi> herhe
07:13:24 <ski> @plugs (\word str -> let n = length word; m = length str in foldr (zipWith (||)) (replicate m False) (map (\(i,t) -> replicate i False ++ replicate n (take n t == word) ++ repeat False) (zip [0..] (Data.List.tails str)))) "abca" "123abcabca123"
07:13:26 <lambdabot> [False,False,False,True,True,True,True,True,True,True,False,False,
07:13:26 <lambdabot> False]
07:13:35 <genneth> oh very nice
07:13:36 <ski> @yay
07:13:37 <lambdabot> Am I in GRADUATE SCHOOL yet?
07:13:44 <genneth> lol
07:13:52 <ski> now, for understanding ..
07:14:12 <poetix> @t replicate
07:14:13 <lambdabot> Maybe you meant: timein todo todo-add todo-delete topic-cons topic-
07:14:13 <lambdabot> init topic-null topic-snoc topic-tail topic-tell type pl wn
07:14:17 <ski> yoshi : i guess you prolly don't understand much of what i wrote, yes ?
07:14:26 <ski> @type replicate
07:14:28 <lambdabot> replicate :: forall a. Int -> a -> [a]
07:14:34 <ski> @plugs replicate 4 'a'
07:14:36 <lambdabot> "aaaa"
07:14:49 <poetix> Another library function I've rewritten pointlessly
07:14:54 <poetix> (and I don't mean in a points-free style)
07:15:00 <ski> yoshi : i just had to try and see if my idea worked
07:15:22 <ski> that doesn't mean that it's necessarily very lucid, or efficient, or something ..
07:15:33 <genneth> i think it's about as good as you could get
07:15:38 <boegel> Lemmih: haskell.org/tmrwiki/HRay
07:16:13 <yoshi> yes, i don't
07:16:24 <ski> anyway
07:16:25 <yoshi> ski: thanks a lot
07:16:38 <ski> i think in any case that you should start with a map
07:16:48 <yoshi> put it in a file that I can compile to test it
07:16:50 <ski> because you want to handle a list of strings, all in the same way
07:17:02 <ski> yoshi : understand what i mean ?
07:17:03 <yoshi> send to goobling@hotmail.com please
07:17:05 <yoshi> yes
07:17:16 <poetix> boegel: TMR article Looking good
07:17:24 <ski> yoshi : sorry, no mail account at this box, either :(
07:17:44 <yoshi> oh
07:17:57 <genneth> you could just hand in the point-free version that plugs give *evil grin*
07:18:05 <ski> yoshi : i guess if you want to play with my idea, you'll have to do it the good old way .. copy&paste
07:18:10 <yoshi> hehe
07:18:11 <yoshi> ok
07:18:14 <boegel> poetix: thanks :)
07:18:25 <boegel> poetix: any comments on language-issues
07:18:33 <yoshi> but with a lot of people wrinting will be aproblem
07:18:40 <poetix> boegel: Yes, it does want proof-reading
07:18:56 <ski> yoshi : and if you plan to turn in something that's based on it, i suggest you go understand it, first ;)  (otherwise your ta or something might get mad ..)
07:18:57 <poetix> boegel: polymorfic
07:19:04 <boegel> poetix: I know, but I think I'm rushing things a bit, I probably won't make the deadline
07:19:14 <boegel> poetix: woops :)
07:19:21 <yoshi> ski: yes, if I test I'll understand
07:19:28 <ski> yoshi : but as i said, it's prolly not very efficient ..
07:20:29 <poetix> boegel: Maybe shorten it a bit? You're trying to get a lot in there...
07:21:07 <boegel> poetix: well yeah, but the last things won't be that long really :) I won't discuss the whole GUI code, just mention it's there
07:21:19 <boegel> the core (math and engine) is the most important part
07:21:56 <boegel> I'm guessing part 6,7,8 and 9 will only be 10 lines each orso
07:22:36 <boegel> and the Perlin noise stuff shouldn't take too long either, I won't go on and explain the whole thing, just mention it's there (the code of that part needs some improvement too, so I won't add it)
07:24:17 <rhat> boegel: what's your paper about?
07:24:20 * boegel is getting ready for some ET'ing
07:24:37 <boegel> rhat: I've built a ray tracer in Haskell, for my Master's thesis
07:24:48 <rhat> neat
07:24:52 <boegel> rhat: more info on http://scannedinavian.org/~boegel/HRay
07:24:57 <genneth> @pl (\word str -> let n = length word; m = length str in zipWith (\t l -> if t then l else '-') (foldr (zipWith (||)) (replicate m False) (map (\(i,t) -> replicate i False ++ replicate n (take n t == word) ++ repeat False) (zip [0..] (Data.List.tails str)))) str) "abca" "123abcabca123"
07:24:58 <boegel> with out  :p
07:25:02 <lambdabot> zipWith (flip (flip . if') '-') (foldr (zipWith (||)) (replicate (
07:25:02 <lambdabot> fix (const (length "123abcabca123"))) False) (map (ap (flip ((.) . (+
07:25:02 <lambdabot> +) . flip replicate False) (flip ((++) . ((`fmap` flip (flip . ((==)
07:25:02 <lambdabot> .) . take) "abca") =<< (.) . replicate) (fix (const (length "abca")))
07:25:02 <lambdabot> ) (repeat False)) . fst) snd) (zip [0..] (Data . List . tails "
07:25:02 <lambdabot> 123abcabca123")))) "123abcabca123"
07:25:04 <lambdabot> optimization suspended, use @pl-resume to continue.
07:25:11 <genneth> @pl-resume
07:25:18 <lambdabot> zipWith (flip (flip . if') '-') (foldr (zipWith (||)) (replicate (
07:25:18 <lambdabot> length "123abcabca123") False) (map (ap (flip ((.) . (++) . flip
07:25:18 <lambdabot> replicate False) (flip ((++) . ((`fmap` flip (flip . ((==) .) . take)
07:25:18 <lambdabot> "abca") =<< (.) . replicate) (fix (const 4))) (repeat False)) . fst)
07:25:18 <lambdabot> snd) (zip [0..] (Data . List . tails "123abcabca123")))) "123abcabca12
07:25:18 <lambdabot> 3"
07:25:20 <boegel> genneth: having fun with lambdabot ? :)
07:25:20 <lambdabot> optimization suspended, use @pl-resume to continue.
07:25:31 <boegel> heh :)
07:25:31 <genneth> i'm trying out ski's insanity
07:25:37 <genneth> i think i'll take it somewhere else... :p
07:25:39 <ski> huh ? :)
07:25:41 <boegel> ;)
07:26:38 <ski> they said i was insane ..
07:26:44 <ski> but i will show them ..
07:26:49 <ski> muahahahahaa !
07:27:19 <genneth> if only nnunley came in two seconds earlier....
07:27:31 * ski snickers evilly
07:27:58 <tomdavie> buh... I wish people would stop asking for my source... I keep having to do a make realclean, and then spending half an hour buinding again :(
07:28:16 * earthy grinz
07:28:23 <tomdavie> I suppose I could just back up the work... but hey... that would be inteligent
07:28:33 <earthy> why not manage the stuff with darcs and have a clean tree and a build tree? :)
07:28:41 <genneth> ski: i think your little function above has a problem if you word == str
07:28:50 <earthy> oh right, we don't want to think, we're lazy functional programmers. :P
07:29:06 <tomdavie> because it's already under cvs... I just don't want to check in... It's all experimental stuff
07:29:10 <boegel> earthy: are you joining the ICFP contest ?
07:29:11 <xs> mm darcs dist
07:29:15 <tomdavie> hehe... precicely earthy
07:29:18 <earthy> boegel: in fact I am not.
07:29:29 <tomdavie> ICFP contest?
07:29:35 <boegel> earthy: oh, Itkovian said you where :) who's joining then ?
07:29:38 <boegel> tomdavie: check the topic
07:29:47 <earthy> the fight with the gf last weekend totally killed my joy and focus
07:29:50 <boegel> tomdavie: http://icfpc.plt-scheme.org
07:30:01 <earthy> otherwise I might've tried my hand at it
07:30:04 <boegel> earthy: fight ? about what ? you being online too much ?
07:30:06 <CosmicRay> ahh.
07:30:07 <ski> genneth : you say ?
07:30:10 <earthy> the problem is fun enough
07:30:13 <CosmicRay> I percieve that lilo's rent is due.
07:30:29 <genneth> ski: i think it infinitely loops if word == str
07:30:58 <boegel> earthy: you're still together with your gf are you ?
07:31:03 <earthy> boegel: curtains. and me doing as we had agreed: applying the final layer of paint to some things. and therefore only having slightly less than an hour left to go shopping for curtains.
07:31:12 <rhat> boegel: thanks for the link, nice program!
07:31:18 <earthy> yeah, we're still together.
07:31:37 <yoshi> I think it's enough for me, thanks all!
07:31:47 <yoshi> now I am going to test
07:31:53 <yoshi> bye all!
07:31:57 <earthy> but big fights over trivialities like that really take the oomph out of you
07:32:11 <boegel> earthy: seems like more was behind that ?
07:32:20 <boegel> rhat: have fun with it :)
07:32:45 <boegel> earthy: I know what you're talking about, it sucks really
07:32:58 <boegel> I tried to avoid those fights
07:33:08 * poetix mutters darkly about women and curtains
07:33:52 <poetix> the pelmets! the pelmets!
07:35:46 <ski> genneth : just tried it with "abca" and it seems to work ..
07:38:32 * earthy is *glad* we won't do pelmets at all... 
07:38:34 <earthy> man... :)
07:40:12 <[BAF64]> do you guys appreciate freenode?
07:41:02 <boegel> [BAF64]: eh ?
07:41:04 <earthy> um... ?
07:41:13 <[BAF64]> you guys should donate
07:41:14 <ski> is this a quiz ?
07:41:15 <boegel> is this about the fundraiser ? 'cause I'm out of money :p
07:41:26 <ski> wb lstna_
07:42:01 <lstna_> Thanks again Ski. What does this output from lamdabot mean?
07:42:04 <lstna_> @eval head . tail [1,2,3,4,5]
07:42:05 <lambdabot> <<EM Dynamic -> EM Dynamic>>
07:42:09 <ski> oh
07:42:12 <ski> use @plugs
07:42:26 <lstna_> @plugs head . tail [1,2,3,4,5]
07:42:27 <ski> the @eval command is not for haskell
07:42:28 <[BAF64]> hmm
07:42:28 <lambdabot> Couldn't match `a1 -> [a]' against `[a2]'
07:42:41 <earthy> hm. I'm not going to donate if it's going to tsunami disaster relieft
07:42:48 <ski> try (head . tail) [...]
07:42:58 <ski> or head . tail $ [...]
07:43:01 <CosmicRay> boegel: yes
07:43:08 <CosmicRay> earthy: it goes to buy lilo paper and pay his rent
07:43:11 <lstna_> Okay.
07:43:58 <ski> or head $ tail $ [...]
07:44:18 <yoshi> hi again :D
07:44:21 <ski> wb
07:44:45 <lstna_> @plugs ((head . tail ) [1,2,3,4,5] )
07:44:49 <[BAF64]> we are between 1/3 and 1/2 through the last $2000
07:44:51 <lambdabot> 2
07:45:47 <musasabi> [BAF64]: I think the global notices make people see the message - there are many worthy causes of donations and a finite amount of money - and this is off-topic.
07:46:11 <[BAF64]> earthy, you can opt out of unicef and donate 100% to PDPC
07:46:12 <boegel> [BAF64]: you should ask lambdabot, she seems to be willing to donate
07:46:36 <Igloo> [BAF64]: Are you here purely to beg for donations?
07:46:36 <mauke> @vixen are you willing to donate?
07:46:53 <[BAF64]> I'm not begging for donations.
07:47:05 <xs_> oh, lilo needs rent?
07:47:10 <lambdabot> yes, i am
07:47:12 <[BAF64]> I just simply said you can opt out of unicef, I am trying to help out freenode
07:47:27 <Igloo> [BAF64]: If you're not here to talk about Haskell, please can you leave?
07:47:31 <[BAF64]> Igloo, sure
07:47:38 <[BAF64]> lambdabot, if you want more info, join #freenode
07:47:47 <Igloo> lol!
07:47:51 <aheller> :)
07:48:55 <boegel> I succeeded
07:49:01 <boegel> @karma boegel
07:49:02 <lambdabot> You have a karma of 0
07:49:19 <yoshi> @karma yoshi
07:49:20 <boegel> somebody should make lambdabot join freenode :)
07:49:21 <lambdabot> You have a karma of 0
07:50:16 <poetix> @karma+ lambdabot
07:50:17 <lambdabot> lambdabot's karma raised to 2.
07:50:24 <xs_> or join freenode and ask about haskell
07:50:50 <Grimace> donations for haskell projects
07:51:32 <musasabi> [BAF64] seems to just have been a person with too much enthusiasm and no connection to the freenode staff.
07:53:36 <earthy> okay, paypal is making me go through way too many hoops to pay
07:53:43 * Grimace has noticed a number of haskell libs & projects which have different approaches to representing Haskell types in Haskell
07:54:23 <Grimace> not least HaXmL and Data.Dynamics
07:56:47 <Grimace> I wonder if is this a phenomenon which has been noticed elsewhere?
07:57:51 <kosmikus> what exactly is the phenomenon, Grimace?
07:57:56 <earthy> Grimace: reifying types is not that easy
07:58:15 <musasabi> Grimace: many haskell developers want to make things perfect which can mean ditching previous "imperfect" solutions and creating yet an another way.
07:58:52 <kosmikus> different projects have different needs, and there's no clear optimal solution to this problem, so it's not really surprising that there are competing approaches
07:59:07 <genneth> i think not having any driving market forces, etc. makes this actually possible
07:59:49 <ski> "avoid success at any cost !"
07:59:51 <ski> :)
07:59:56 * earthy grins
08:00:48 * genneth nods
08:01:16 <ski> (e.g. at http://www.haskell.org/pipermail/haskell-cafe/2004-September/006919.html)
08:01:59 <genneth> funny that may be, the quality of C++ libraries, etc. has risen considerably since java came out; all the "i just want to make money and be a l33t ha><0r" types left for java; so people like http://boost.org/ could actually produce something
08:04:32 <earthy> ski: but then there's the comment by Tony Hoare: "I fear that Haskell is doomed to succeed."
08:05:43 <tomdavie> heh... strange, but true
08:05:50 <ski> earthy : yes, *sniff*
08:06:28 <tomdavie> it's success, means that everyone is sitting there using every glasgow extension under the sun... and in the process, making hat a bastard to write
08:07:16 <genneth> i for one would like to see more of STM everywhere :-D
08:08:34 <earthy> well, at least I have fundamental reasons to use some glasgow extensions
08:08:45 <earthy> my code desperately needs them
08:09:21 <tomdavie> heh... what ones do you need, and why? (just out of interest)
08:11:31 <Grimace> so.. what's the leading approach to type reification at present?
08:12:01 <Grimace> ("...none"?)
08:13:12 <ski> earthy : existentials ? GADT ?
08:14:48 <earthy> ski: Much *much* more down-to-earth than that. :)
08:15:26 <earthy> overlapping instances
08:15:30 <earthy> undecidable instances
08:15:47 <wilx> Is that more down-to-earth? :)
08:15:57 * ski would consider existentials more down-to-earth than that ..
08:16:03 <wilx> For me it is exactly the opposite :)
08:16:03 <earthy> ;)
08:16:45 <earthy> well. :)
08:17:14 <earthy> existentials and GADT's are at a different level of extending the type system as overlapping and undecidable instances are
08:17:26 <ski> right
08:17:37 <earthy> the latter are the removal of constraints
08:17:49 <earthy> the former are the addition of new types, basically
08:18:05 <kosmikus> overlapping and undecidable instances are black magic :)
08:18:07 <ski> type formers
08:18:12 <ski> indeed
08:18:30 <earthy> I never said I didn't dabble in magic! :P
08:18:42 <CosmicRay> kosmikus: my favorite kind :-)
08:18:45 <earthy> b'sides, dark magic is very earth-grounded. :P
08:19:12 * ski remembers to continue watching abelsson and sussman lectures :)
08:19:15 <earthy> (wait, lemmecheck the ars magica book on that :P)
08:19:53 <kosmikus> is that sill in the office? ;)
08:20:18 <kosmikus> s/sill/still/
08:20:26 <ski> earthy : what magic system is that ?
08:20:37 <earthy> kosmikus: no, but it is on my laptop
08:20:39 <xerox> ski, great lectures.
08:20:57 <aheller> wasn't ars white wolf's unrelated high fantasy game?
08:20:59 <poetix> ski: Taplomancy?
08:21:10 <kosmikus> aheller: it used to be, a long time ago
08:21:18 <aheller> never got around to it...
08:21:24 <kosmikus> aheller: it was wizards of the coast in between, now atlas games
08:21:52 <earthy> plus, 4th edition is *free*
08:21:53 <kosmikus> aheller: not so high fantasy, anyway
08:22:12 <aheller> really?  never played; this is my vague recollection based on what the cover looked like.
08:22:50 * tomdavie wonders why showing a finite data structure is looping infinitely
08:22:51 <ski> xerox : yeah :)  (just recently started watching them ..)
08:23:01 <kosmikus> plays in "mything europe", which is medieval europe plus some added supernatural things
08:23:35 * poetix feigns surprise at the number of rpg-ers on #haskell
08:24:10 <CosmicRay> poetix: I take it you don't meen Report Program Generator programmers? :-)
08:24:30 <poetix> So has anyone written a Haskell version of Angband?
08:24:59 <lstna> @type (>>)
08:25:01 <lambdabot> (>>) :: forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m
08:25:01 <lambdabot> b
08:25:02 <kosmikus> I got a link to something roguelike from shapr a while ago, but I can't find it back right now
08:25:12 <lstna> @type (>>=)
08:25:12 <kosmikus> it was not very playable, though
08:25:14 <lambdabot> (>>=) :: forall (m :: * -> *) b a.
08:25:14 <lambdabot>    (Monad m) =>
08:25:14 <lambdabot>    m a -> (a -> m b) -> m b
08:25:25 <poetix> @google haskell roguelike
08:25:26 <lambdabot> http://www.gentoo-portage.com/games-roguelike
08:26:07 <lstna> @type (m:: *->*)
08:26:09 <lambdabot> bzzt
08:26:18 <lstna> @kind (m:: *->*)
08:26:20 <lambdabot> bzzt
08:26:32 <basti_> lstna: m is a variable there
08:26:38 <lstna> @type m:: *->*
08:26:40 <lambdabot> bzzt
08:26:47 <aheller> Yi could be considered a rogue-variant, a la Tom Christiansen.
08:26:49 <basti_> and :: *->* means "is of kind *->*"
08:27:00 <basti_> aheller: rogue like nethack?
08:27:17 <kosmikus> basti_: yes
08:27:24 <basti_> =)
08:27:28 <aheller> There's a quote in my fortune file to that end.
08:28:19 <lstna> @type (Monad m)
08:28:20 <lambdabot> bzzt
08:28:31 * kosmikus has to go
08:28:33 <lstna> @kind (Monad m)
08:28:34 <lambdabot> bzzt
08:28:49 <ski> @type ((>>=) :: IO a -> (a -> IO b) -> IO b)
08:29:05 <lstna> @anyinformationatall (Monad m)
08:29:10 <lambdabot> ((>>=) :: IO a -> (a -> IO b) -> IO b) :: forall a b.
08:29:10 <lambdabot>               IO a -> (a -> IO b) -> IO b
08:29:10 <lambdabot> Unknown command, try @listcommands.
08:29:52 <poetix> http://www.oreilly.com/news/zenclavier_1299.html
08:30:12 <poetix> Christiansen on vi and nethack
08:30:47 <ski> lstna : ok ?
08:30:49 <poetix> He's right - I spent way too many hours beating ZAngband, a few years ago, and the key-bindings for the various spells are still etched into my muscle-memory
08:31:04 <aheller> 10th paragraph was the thing I was thinking of.
08:31:09 <lstna> No, but I best not tell you what I'm thinking
08:31:30 <ski> (lstna : hehe, why's that ?)
08:31:37 <poetix> "Yes, I know you probably think of vi as an editor, but I've always found people more receptive when I explain that it's actually a video game that happens to get a job done, too"
08:31:54 <lstna> cos people get upset and threaten banishment
08:32:09 * ski is puzzled
08:32:17 <ski> banishment of what ?
08:32:31 <lstna> as in kick
08:32:38 <ski> ah
08:32:52 * Grimace has a haskell roguelike on the backburner
08:32:59 <poetix> Don't we all?
08:33:48 <Grimace> it's not going bad but it's stuck at the map generation stage
08:34:01 <Grimace> my test maps work ok though *shrug*
08:34:39 <poetix> I think map generation's probably some sort of graph problem
08:36:26 <poetix> Line-of-sight is quite a fun problem, too
08:36:43 * tomdavie wants `no instance of such-an-such' errors to be warnings if the compiler can derive an instance
08:41:38 <tomdavie> interesting... my program runs forever... even though the failure is a patern match failure
08:46:34 <ski> playing around with Show ?
08:46:57 <tomdavie> indeed... Just discovered the stupidity
08:57:46 <tomdavie> anyone have any idea how to force LaTeX to put two figures either on the same page, or on facing pages?
08:58:23 <lispy> tomdavie: there is an environment for that
08:58:31 <lispy> trying to remember the name....
08:58:35 <lispy> look at minipages
08:58:54 <lispy> ah, iirc subfigure
09:00:36 <tomdavie> cool, ty
09:04:40 <tomdavie> hmm, can't get it to do a facing pages thang :/
09:08:09 <lispy> facing pages i don't know much about, i was thinking of two on one page ;(
09:13:07 <tomdavie> yeh... it's worked really nicely for one of them
09:13:22 <tomdavie> unfortunately, the other pair I have, it ends up being a mess
09:13:50 <lispy> you'd have to google for that one, i've never needed facing page figures before
09:14:46 <tomdavie> I could hack it... and add an A3 page to the document
09:17:35 <wagle> figure placement is the great wart on TeX
09:17:55 <boegel> wagle: I second that
09:18:42 <basti_> figures are floaters, if you don't want that, you have to dig into the source
09:21:38 <xerox_> test.
09:22:49 <basti_> test.
09:23:07 <lstna> Is the somewhere to send anomolies in Haskell docs/papers/pdfs?
09:24:10 <basti_> the maling list comes to mind
09:24:15 <shapr> and the author
09:24:41 <lispy> i like /dev/null
09:24:43 <lispy> ;)
09:24:45 <basti_> xerox_: baking your own irc client?
09:24:54 <basti_> ah no
09:25:07 <xerox_> No, I'm going on vacation and I need to log :-)
09:25:14 <basti_> lol
09:25:17 <lispy> heh
09:25:21 <lispy> xerox_: what about meme?
09:25:38 <xerox_> uhm, #google-summer and #google-summer-it aren't "memed" :-(
09:26:13 <lstna> Which ma[i]ling list basti?
09:26:50 <xerox> lispy, do you know how to add them to meme?
09:26:57 <basti_> http://www.haskell.org/ghc/docs/latest/html/users_guide/introduction-GHC.html < in the very beginning of the documentation =)
09:30:13 <lstna> Hmm. None of those seem particularly relevant do docu bugs.
09:30:21 <lstna> s/do/to/
09:30:43 <lstna> but thanks.
09:31:21 <basti_> i think doc bugs are pretty normal bugs
09:31:41 <shapr> lstna: libraries list is perfect for docs bugs.
09:34:08 <shapr> y0
09:34:23 <lstna> Sorry shapr? I do not see a "libraries list" address on the linked page?
09:34:30 <shapr> I wish this cold would go away, I haven't had the energy to unicycle for THREE DAYS.
09:34:50 <shapr> That's a real tragedy.
09:35:09 <shapr> lstna: Libraries list is here - http://haskell.org/mailman/listinfo
09:36:18 <lstna> Hmm
09:36:20 <lstna> (a) discuss an extension to haskell to provide a richer module namespace.
09:36:21 <lstna> (b) discuss how to partition this namespace and populate it with libraries.
09:36:21 <lstna> (c) discuss how to provide a consistent set of libraries for all compilers, and the setting up of a common library repository.
09:36:37 <lstna> I don't think so
09:37:01 <shapr> I think it's the most fitting forum, but if you find something better, tell me about it :-)
09:37:07 <shapr> hiya sladegen
09:37:27 * shapr throws redexes
09:37:30 <shapr> redices?
09:37:43 <boegel> shapr: care to proof-read the bit of my HRay article I already have ?
09:37:54 <boegel> shapr: the latter probably
09:37:54 <shapr> I'll look at it now.
09:38:29 <SyntaxNinja> I see you shapr.
09:38:32 <boegel> shapr: okay, cool, thanks
09:38:49 * boegel wonders if SyntaxNinja is playing hide-and-seek with shapr 
09:39:04 <shapr> The traveling carnival has setup outside my window. I can hear kids screaming as they hurtle through the air on the end of a long metal stick. My proofreading may not be of the best quality today.
09:39:18 <SyntaxNinja> shapr: if you can't beat them, join them.
09:39:27 * SyntaxNinja hides again
09:39:30 <shapr> I could hack the rides I guess.
09:39:34 <boegel> shapr: just tell me what you think
09:39:48 <shapr> Though these look old enough that they probably don't have ethernet, much less wifi.
09:40:12 * SyntaxNinja taps on shapr's window and runs away
09:40:40 <lstna> OKay. Ask a dumb question...#
09:40:44 <boegel> SyntaxNinja: throws a waterballoon at SyntaxNinja
09:40:50 <shapr> I'm on the second (european) floor, so you'd have to climb past two other windows first.
09:41:07 <shapr> lstna: What was the question?
09:41:38 <basti_> theres no stupid questions, just stupid answers, btw.
09:41:40 <SyntaxNinja> shapr: I could do it.
09:41:50 <SyntaxNinja> won't even use a rope!
09:41:55 <shapr> SyntaxNinja: I know you can, where's your latest action shots? Why don't they ever show up in your blog?
09:42:05 <SyntaxNinja> shapr: but what are you doing on the 2nd floor, I thought you had a basement office
09:42:12 <shapr> Nah, we moved about a year ago.
09:42:36 <SyntaxNinja> shapr: don't usually take photos; it's hard while climbing, since either someone has to be climbing with you to get a good shot, or all the photos are of your butt
09:42:45 <shapr> haha
09:42:55 <SyntaxNinja> shapr: that's disturbing to me. I have been incorrectly picturing you in your old place for a year!
09:43:18 <SyntaxNinja> I'll just keep pretending.  anyway, i knocked on the wrong window, I guess ;)
09:46:24 <boegel> shapr: could you mail me your feedback, 'cause I have to run
09:47:08 <shapr> sure, no worries
09:47:15 <boegel> ok thanks :)
09:47:16 <shapr> boegel at scanned?
09:47:25 <boegel> err, no
09:47:32 <boegel> do I have a mailbox there ? :)
09:47:43 <shapr> I think so
09:47:59 <boegel> we'll, I'm sure as hell ain't using it :)
09:48:04 <shapr> ok
09:48:08 <boegel> just mail it to my ugent address
09:48:12 <shapr> I can stop your mail there if you want, it's probably just spam anyway.
09:48:28 <boegel> can I access it with pine ?
09:48:51 <boegel> apparently not
09:49:17 <boegel> well, nevermind, maybe I'll use it someday ;)
09:49:22 <shapr> Nah, no pine on snowblind.
09:49:29 <shapr> Pine isn't DFSG
09:49:32 <boegel> you know where to mail ?
09:49:36 <shapr> yup
09:49:39 * boegel looks up DFSG
09:49:56 <boegel> Diabetic Food Study Group ? :p
09:50:16 <shapr> Debian Free Software Guidelines
09:50:20 <boegel> nvm, found it ;)
09:50:21 <boegel> thanks
09:50:22 <boegel> bye!
09:50:26 <shapr> ok, cya!
10:36:54 <Speck> Is anyone here competing in the ICFP?
10:37:19 <xerox_> Speck: dcoutts_ is.
10:37:46 <Speck> By himself?!
10:38:02 <xerox_> Nope, with a team.
10:38:08 * CosmicRay returns
10:38:22 <CosmicRay> wow, I missed all the fun
10:38:27 <CosmicRay> a dfsg mention even :-)
10:39:08 <Igloo> There's a reasonable number of solo entries
10:39:39 <Speck> There're a lot of random walkers, too ;-)
10:40:31 * hellish would've had an entry if he had remembered to mark a nearby calendar.
10:43:50 <xerox_> Must provide a fully completed Form W-8BEN, which must include a U.S. tax
10:43:59 <xerox_> sorry, misclick.
11:01:46 <metaperl_vc> CosmicRay: do you run testing or stable Debian?
11:14:59 <CosmicRay> metaperl_vc: some stable, some unstable at the moment
11:25:58 <Itkovian> evening
11:30:26 <swiert> shapr: ping
11:36:25 <basti_> @pl x++"\n"
11:36:26 <lambdabot> x ++ "\n"
11:37:53 <lispy> @pl x -> x++"\n"
11:37:54 <lambdabot> (line 1, column 3):
11:37:54 <lambdabot> unexpected ">" or "-"
11:37:54 <lambdabot> expecting variable, "(", operator or end of input
11:38:03 <lispy> @pl x -> (x++"\n")
11:38:03 <basti_> got it already
11:38:04 <lambdabot> (line 1, column 3):
11:38:04 <lambdabot> unexpected ">" or "-"
11:38:04 <lambdabot> expecting variable, "(", operator or end of input
11:38:09 <basti_> wasnt worth the effort
11:38:11 <lispy> ah, that's okay i can't type it :)
11:38:18 <basti_> @pl \x->(x++"\n")
11:38:19 <lambdabot> (++ "\n")
11:38:22 <basti_> :)
11:38:31 <lispy> @type x >>= "\n"
11:38:36 <lambdabot> bzzt
11:38:54 <lispy> hmm...what am i thinking off
11:43:08 <xerox> dcoutts_, ping?
13:04:50 <Itkovian> wow
13:04:57 <Itkovian> too good not to share
13:05:16 <lispy> say what?
13:05:23 <lispy> what is too good?
13:05:39 <Itkovian> http://apb347.zattevrienden.be/f14model.wmv
13:05:56 <Itkovian> if that's for real, well, chapeau
13:06:24 <lispy> safe for work?
13:06:33 <Itkovian> yes
13:06:37 <Itkovian> certainly :-)
13:07:13 <Itkovian> it's an f14, no nudity, no WoMD :-)
13:09:57 <lispy> wow, that's amazing
13:10:06 * lispy takes his hat off
13:11:00 * Speck tears
13:11:04 <kaol> I hope my mplayer can handle that .wmv, I don't feel like hunting for codecs or anything like that
13:11:17 <lispy> kaol: probably can
13:12:03 <Itkovian> well, mplayer on my mac can play it ...
13:12:11 <Itkovian> no sound though
13:12:42 * lispy doesn't have speakers
13:12:47 <Itkovian> anybody knows a good player for macosx besides VLC and mplayer? VLC seems to get stuck on most wmv's
13:12:49 <lispy> i didn't notice the lack of sound
13:13:11 <lispy> does totem work on the mac?
13:13:19 <lispy> it may require ghk
13:13:21 <lispy> er gtk
13:13:54 <lispy> Itkovian: can you watch "The daily show" from comedy central on your mac?
13:14:09 <lispy> i'v been thinking about getting an ibook, but i don't want to lose my daily show access
13:14:35 <lispy> i think they require IE and explicitely check for it
13:15:14 <TFK> What's wrong with mplayer?
13:15:55 <kaol> ok, it played just fine, with sound too
13:16:02 <lispy> TFK: if you're asking me, it's a matter of getting to the content
13:16:07 <Itkovian> lispy: erm, url?
13:16:12 <lispy> Itkovian: just a sec
13:16:20 <Itkovian> TFK: well, on my mac (Panther) it has no sound :-(
13:16:40 <TFK> Eeek :-(
13:16:48 <Itkovian> yeah, bummer ...
13:16:49 <TFK> I would despare.
13:17:01 <Itkovian> well, ... I don;t watch prOn all day, eh
13:17:03 <Itkovian> ;-)
13:17:10 <lispy> Itkovian: IE won't show me the url, go here http://www.comedycentral.com/ and click on "HOT DOCKET" under the "VIDEOS" section
13:17:38 <lispy> Itkovian: if it's a pain don't worry abou ti
13:17:47 <lispy> i should make the guys at the mac store try it
13:17:57 <Itkovian> seems I have a popup blocker interfering
13:18:08 <Itkovian> lispy: yeah, just do that
13:18:34 <lispy> their site is terrible
13:18:44 <lispy> and it's all so they can force tv ads on you
13:18:52 <TFK> Itkovian, ah, just on Tuesdays? :-P
13:19:03 <lispy> heh
13:19:08 <lispy> pr0n-o-Tuesdays
13:19:12 <Itkovian> nah, fridays mostly :-)
13:19:14 <Itkovian> lol
13:19:54 <Itkovian> I am trying to wrap boegels HaskLS in a nice haddock format ...
13:24:42 <metaperl_vc> shapr: ping?
13:29:47 <lament> mplayer works great here
13:30:02 <lament> os x 10.3.9
13:37:00 <basti_> i did a wave machine in haskell. the interface sucks though.
13:37:16 <Itkovian> lament: grrr
13:39:21 <lispy> wave machine?
13:39:26 <lispy> sound or visual?
13:40:14 <metaperl_vc> I still need to go through that music article in TMR-2
13:41:23 <basti_> semivisual
13:41:25 <basti_> metaperl_vc: :)
13:43:54 <Itkovian> lament: what version of mplayer?
14:14:58 <alexj> igloo: do you happen to know what sort of constraints there are on the values you can pass to des?
14:15:11 <Igloo> no
14:15:25 <alexj> igloo: a key is a Zord64 but I'm not sure what that actually means
14:15:35 <Igloo> Zord64 = Word64
14:15:46 <alexj> I am getting a  *** Exception: ../HAppS/Protocols/DES.lhs:73:1: No instance nor default method for class operation GHC.Num.signum
14:21:13 <alexj> are word64s always positive?
14:25:41 <Igloo> Yes
14:25:59 <alexj> hmm.  then I am doing something to cause a stack overflow.
14:26:08 <alexj> (I added signum=1 to the num instance)
14:27:58 <alexj> any ideas what might cause a stack overflow in the DES code?
14:29:00 <ski> hm, Word64 can be 0, too,yes ?
14:29:53 <Igloo> Yes, sorry
14:31:36 <alexj> ski, that worked no longer have stack overflow.  now I need to add quotRem to instance Zord64 Integral
14:32:07 <alexj> I am concerned that I am doing something wrong because my simple small integer tests did not require these methods.
14:38:23 <ski> hiya lstna
14:38:45 <lstna> Evening ski
14:38:56 <lament> Itkovian: 2.0
14:41:17 <Itkovian> ok, thx
14:41:52 <thedward> what does it mean if a type has a ! in front of it?
14:42:11 <alexj> anyone know what this error means:  *** Exception: ../HAppS/Protocols/DES.lhs:75:1: No instance nor default method for class operation GHC.Num.*
14:42:13 <Igloo> It's strict
14:43:38 <xs> does the gc have to clear memory when it is deallocated? otherwise, won't crypto key data be left lying around?
14:45:24 <Igloo> xs: Nothing is guaranteed. But if you want security you'll first have to audit GHC's RTS...
14:46:19 <ski> alexj : that multiplication isn't defined ?
14:46:36 <xs> Igloo: ahhh.. ok! that's kinda scary :)
14:47:04 <alexj> ski: ah I was interepreting * as a wildcard.  that makes much more sense.
14:47:31 <Igloo> "won't be left lying around" doesn't have quite the same meaning in a lazy language where the decrypted data may be being lazily consumed, anyway
14:48:52 <alexj> hrmm now the DES code is stack overflowing again.
14:49:10 <xs> yeah. key data is more important though, and is more likely to be better contained
14:49:44 <Igloo> But if the output is being lazily read (and thus lazily produced) then key data /needs/ to be kept around
14:50:38 <xs> oh, of course, but if i $!, then it'd be a nice guarantee to get that the key data is gone
14:52:57 <jlouis> wasn't it Philippa who talked about memory regions? I believe with some simple semantics, key data could be destroyed from a region easily. (Free-zero-region x)
14:54:29 <xs> is that like State with a Map or something?
14:55:43 <lstna> How can I find out what types are members of a given type-class?
14:56:49 <xs> in ghci, :i Typeclass
14:58:05 <jlouis> xs: explicitly region managed memory. Look up region-inference eventually
14:58:24 <xs> thanks, will do
14:58:44 <jlouis> you have a region which can be extended, destroyed or reset. Regions can be nested. It would be easy to add a feature like destroy-zero
14:58:46 <ski> basti_ : interesting, though maybe readStream would return a Maybe ? (and be in some monad ?)
14:59:00 <jlouis> but no Haskell compiler has explicit region support
15:00:13 <jlouis> maybe it is possible to wrap up inside a monad, however
15:00:45 <Igloo> jlouis: What happens if you destroy a region but there is a thunk in another region that points to some data in teh region you destroy?
15:00:45 <ski> basti_ : iirc there has been some work on functional OSes (e.g. with Clean)
15:00:45 <basti_> ski: it should block.
15:01:20 <basti_> clean rocks the house.
15:01:20 <ski> until such a file exists ?
15:01:39 <basti_> no until someone feeds something into a stream
15:01:39 <lstna> Thanks xs
15:01:39 <basti_> the
15:01:46 <ski> basti_ : ?
15:02:03 <basti_> ski: a stream would have two ends. just like a pipe.
15:02:14 <jlouis> Igloo: you don't. In true region inference, static analysis has ruled this out. In the APR utils of apache fame, your program now has a dangling pointer
15:02:18 <ski> one defining end, and one reading end
15:02:26 <basti_> ski: yes.
15:02:57 <Igloo> jlouis: Are there decent static analyses for that for lazy languages?
15:03:06 <jlouis> Doubt it.
15:03:18 <Igloo> Heh, OK  :-)
15:03:23 <ski> jlouis : well, iirc there can actually be such a thunk, as long as the system can prove that it will not be accessed
15:03:39 <jlouis> ski: true
15:04:11 <ski> basti_ : hm, this reminds be of dataflow variables ..
15:04:18 <ski> s/be/me/
15:04:32 <basti_> ski: yes and STM can emulate such variables i think.
15:04:38 <ski> you think ?
15:04:44 <basti_> yes.
15:04:48 <basti_> i read something about that in the paper
15:04:50 <ski> that would be really nice, if so
15:04:59 * basti_ nods
15:05:10 <ski> dataflow variables enable a kind of declarative concurrency
15:05:19 <basti_> thats what i was thinking :)
15:05:40 <ski> (and i'm not talking about just wrapping and sequentializing effects in a monad)
15:06:17 <basti_> yes dataflow is a very important notion
15:06:28 <jlouis> Igloo: but is it that hard to do? Usually you add reset and destroy calls at convenient spots in the program when it is guaranteed the region will not be accessed anymore. A thunk in a region will then prevent that region from being reclaimed
15:07:02 <ski> so one can define a dataflow var without binding it to a thunk .. later letting some other part of system provide thunk/value
15:07:12 <jlouis> I guess the graph you reduce will have to be annotated with extra information about garbage reclaiming
15:07:18 <ski> basti_ : have you tried out some Oz ?
15:07:33 <basti_> ski: yes.
15:07:37 <ski> ok
15:07:40 <jlouis> but it is open research. I am quite sure there are some evil problem with it hidden somewhere
15:11:23 <ski> basti_ : a stream is not merely a list of io-actions ..
15:11:32 <basti_> hm.
15:11:53 <basti_> but, handling a stream would be.
15:12:11 <ski> (also you have free typevar 'a' in those type synonym declarations)
15:12:18 <ski> ?
15:13:00 <basti_> uhm
15:13:00 <basti_> yes
15:13:11 <basti_> not anymore that is.
15:14:31 <arjanoosting> Igloo: I have uploaded a new version of the haxml debian package with libnhc98-haxml-dev and libhugs-haxml disabled
15:16:13 <ski> basti_ : i don't understand last point of Logic for Calls. and is not sure about second to last point
15:16:31 <alexj> is there any reason why defining a new function should change the type of an existing one?
15:16:49 <basti_> ski: maybe i should elaborate that a bit. I'm thinking about an example
15:17:07 <ski> basti_ : "a IO value can always spawn a new value" ?
15:17:28 <basti_> uhm
15:17:29 <alexj> or worse,  its value? I am getting a divide by zero error or not depending on whether I have another function defined.
15:17:44 <ski> class method ?
15:18:15 <alexj> ski: if that was addresed to me, nope just regulare functions.
15:18:23 <ski> ok
15:18:32 <alexj> hexToW64 = fromInteger . hexToInt . take 16
15:18:33 <alexj> stringToKey = hexToW64 . sha1
15:18:33 <alexj> des_encrypt key = map (flip des_enc $ stringToKey key) . stringToW64s
15:19:01 <ski> and they are both toplevel functions ?
15:19:10 <alexj> (stringToKey "a") `mod` (2^64) causes a divide by zero error only if des_encrypt is defined.
15:19:12 <alexj> ski: yes
15:22:10 <ski> seems weird
15:22:10 <alexj> ski: yes.  thats why I am asking.
15:22:11 <ski> i'm not sure
15:22:11 <ski> hm
15:22:11 <basti_> ski: restructured that paragraph
15:22:11 <ski> maybe try putting explicit type signatures for some of the functions ?
15:22:12 <ski> (or, ask hugs/ghci what types it thinks the functions has, and see if it is what you expect ..)
15:23:08 <ski> basti_ : hm
15:23:08 <alexj> the types change too: with des_encrypt I get hexToW64 :: [Char] -> HAppS.Protocols.DES.Key  and without I get  hexToW64 :: [Char] -> Integer
15:23:19 <ski> ah
15:23:31 <ski> monomorphism restriction, then
15:23:49 <alexj> ?? really
15:24:05 <ski> it defaults to Integer, if not used by something that demands DES.Key, methinks
15:24:19 <ski> hm
15:24:19 <alexj> argh!  ok.
15:24:55 <ski> you got divide by 0 if you had des_encrypt defined ? (or the other way around ?)
15:25:05 <alexj> if des_encrypt was defined.
15:25:26 <ski> ok
15:25:46 <alexj> putting arguments in worked! you were right.  how obscure!
15:25:51 <ski> then i guess there are more probs lurking somewhere
15:26:04 <ski> mono. restr. is a bit evil
15:26:12 <alexj> very
15:26:53 <ski> it can only apply if you have   variable = ...
15:27:01 <ski> not if you have  function args ... = ...
15:27:36 <alexj> yup.  I know how to seolve it.  that was just the first time I got a runtime rather than compile time error from it.
15:27:41 <ski> it's meant to make caching behaviour more "intuitive"
15:29:32 <ski> basti_ : "the >>= are lazily evaluated, and potentially describe an infinite sequence of actions" you just mean that >>= will not call right function arg, until it has value to pass to it (which is more or less selfevident) or that one can create cyclic/(possibly) infinite io-actions ?
15:31:01 <basti_> ski: the latter
15:31:17 <ski> ok
15:31:59 <basti_> ski: monads kind enforce the sane ordering of IO calls, and still may be infinite. Thats somewhat dual to data, which is finite.
15:32:21 <basti_> "sane ordering" meaning all kinds of candy - STM etc.
15:32:29 <xerox_> mdo?
15:32:48 <basti_> for example
15:32:51 <ski> hm
15:32:54 <alexj> ski: thank you!
15:33:15 <ski> mdo's yet another level of cyclicity
15:33:22 <ski> alexj : yw
15:33:52 <basti_> i was thinking like infinite recursion
15:34:33 <ski> sequence_ . repeat $ putStrLn "Hello World !"
15:34:44 <basti_> @type sequence_
15:34:46 <lambdabot> sequence_ :: forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
15:34:53 <basti_> ah
15:54:45 <Igloo> arjanoosting: Cool  :-)   You're probably better off trying to find SyntaxNinja than me to get it uploaded, BTW
16:12:19 <alexj> ski: an reason why ghci might allow you to evaluate things individually and then compose results but give a stack overflow when you ask it to compose results?
16:12:20 <alexj> *Cofro> w64ToQuadChar $ (flip des_dec $ key) 4879704278717562409
16:12:20 <alexj> *** Exception: stack overflow
16:12:20 <alexj> *Cofro>  (flip des_dec $ key) 4879704278717562409
16:12:20 <alexj> 23159395
16:12:20 <alexj> *Cofro> w64ToQuadChar $ 23159395
16:12:22 <alexj> [1,97,98,99]
16:12:24 <alexj> *Cofro> w64ToQuadChar $ (flip des_dec $ key) 4879704278717562409
16:12:26 <alexj> *** Exception: stack overflow
16:13:00 <alexj> I've gotten rid of MR everywhere relevant (I think) so it can't be that.
16:13:59 <Lemmih> Try more strictness.
16:15:45 <alexj> ?not sure where to do that.
16:16:02 <alexj> does unfoldr cause stack overflows?
16:16:17 <alexj> (like foldl?)
16:18:13 <Cale> maybe try: w64ToQuadChar $! (flip des_dec $ key) 4879704278717562409
16:18:39 <alexj> Cale: nope.
16:24:42 <alexj> here is a worse version: x1 = ((flip des_dec $ key) 4879704278717562409)
16:24:42 <alexj> x1' = x1 == 23159395
16:24:42 <alexj> x2 =  w64ToQuadChar x1::String
16:24:42 <alexj> x2' = w64ToQuadChar 23159395::String
16:24:48 <reffie> From: Claus Assmann <ca+OpenBSD_tech@zardoc.endmail.org>
16:24:56 <alexj> x2 causes a stack overflow but x1 doesn't!
16:25:29 <alexj> so does seq x1 x2
17:00:01 <xerox> OK
17:00:20 <xerox> Goodnight people, time to go on vacation.  Talk to you in some days ! .-D
17:00:32 <Pseudonym> Oooh, where you going?
17:00:41 <xerox> Tuscany, seaside :-)
17:00:50 <Pseudonym> Lovely.  Enjoy the humidity!
17:00:53 <xerox> For the entire month, yay.
17:01:28 <xerox> Indeed, I also got a GPRS phone, it's not that fast but I hope I could connect through.. to keep in touch :)
17:01:48 <Pseudonym> Can you IRC over GPRS?
17:01:54 <xerox> I hope so!
17:01:56 <Pseudonym> :-)
17:02:23 <xerox> 02:03 now, 04:00 we'll go.  YAWN.
17:03:00 <Pseudonym> Go sleep.
17:03:24 <xerox> I have to mail the Google mentor too :-(
17:03:50 <xerox> Blech, I think he's going to wait until tomorrow or such.
17:04:07 <xerox> Bye now :O
17:14:24 <yosemite> does anyone have any pointers to how I could create an instance of Eq for a binary tree with parent links?
17:15:39 <monochrom> Is it alright to ignore the parent links?
17:15:52 <yosemite> I have some ideas but they are either poor or hard. poor: placing a serial number attached to the tree.  hard: doing some sort of marking of each node.
17:16:44 <yosemite> monochrom: actually, now that I think of it I could just ignore the children and parent pointers and just compare the values attached
17:16:53 <yosemite> I think
17:18:05 <yosemite> the reason I want to include comparing the pointers though is so I can verify that my program isn't dropping nodes
17:21:14 <monochrom> serial number is an ok idea.  if == is used many times more often than create/update, serial number is much faster.
17:22:31 <yosemite> true.
17:23:13 <yosemite> I think I may just go the value way and work out proof to myself that it's not referencing dead wood
17:24:57 <dcoutts> xerox, you around?
17:36:31 <Pseudonym> xerox is asleep
17:36:51 <dcoutts> ok ta. I'll catch him tomorrow
17:43:09 <Pseudonym> According to him, no you won't.
17:43:20 <Pseudonym> <xerox:#haskell> Goodnight people, time to go on vacation.  Talk to you in some
17:43:20 <Pseudonym>            days ! .-D
17:43:39 <dcoutts> ah yes, today's the 1st now so he's on vacation
17:44:25 <dcoutts> you heard that he got the google soc project? we're very pleased!
19:30:35 <Speck> My gf wants to learn programming but she's never done it before. She isn't even know what a programming language is... I think she should learn a functional language, but she wants to learn C++
19:30:37 <Speck> any thoughts
19:31:30 <Pseudonym> Well.
19:31:45 <Pseudonym> Learning C++ as a first language is possible, but there are very few if any resources for it.
19:32:00 <Speck> stroustrup
19:32:08 <Pseudonym> Stroustrup is a reference book.
19:32:11 <Speck> is what I'm recommending
19:32:28 <Pseudonym> You could try "Thinking in C++".
19:32:28 <Speck> oh ok
19:32:28 <dons> but C++ is pretty horrible :/
19:32:40 <Speck> I know
19:32:41 <Pseudonym> There's a PDF of it online.
19:33:21 <dons> my gf learnt TeX :)
19:33:21 <Pseudonym> But it's going to be an uphill battle at any rate.
19:33:27 <Speck> she's open to functional languages
19:33:41 <Pseudonym> What does she want to do?
19:33:51 <Speck> widen her horizons
19:33:52 <Pseudonym> My wife (formerly gf) administers my server.
19:34:05 <Pseudonym> Does that beat everyone else?
19:34:21 <dons> I think maybe yes :)
19:34:35 <Pseudonym> :-)
19:35:03 <Pseudonym> Well if she wants to widen her horizons, then yes, she should try a functional language. :-)
19:35:30 <Speck> I think that a functional programming language would be better for her, as she has more experience in math than computers
19:35:32 <Pseudonym> Start with the GHCi command line and list comprehensions, and work from there.
19:35:36 <Pseudonym> Right.
19:35:38 <Pseudonym> Definitely, then.
19:35:40 <Speck> she won't let me teach her
19:35:50 <Pseudonym> We do have many fine tutorials.
19:35:59 <Pseudonym> Well, a couple of fine tutorials and many not-so-fine ones.
19:36:05 <Speck> heh
19:36:20 <Speck> I want her to learn haskell, but it get's intimidating pretty quickly
19:36:33 <Speck> that's great for me and for people who already know they like programming
19:36:33 <Pseudonym> How do you figure?
19:37:00 <Pseudonym> IME, people tend to find Haskell intimidating only if they already know another non-functional language.
19:37:07 <Pseudonym> Or if it's taught badly.
19:37:11 <Pseudonym> Which does happen.
19:37:15 <dons> Speck, maybe check out some of the first year courses taught in Haskell
19:37:21 * Pseudonym used to be a lab assistant for first years
19:37:23 <Speck> that's true
19:37:40 <Speck> I think that if she starts funcitonal, she'll be a better programmer even if she codes in c++ or java
19:37:52 <dons> i.e. http://mahler.cse.unsw.edu.au/webcms/course/index.phtml?cid=840
19:37:54 <Pseudonym> The most "this is intimidating" comment I got was along the lines of: "This isn't programming!  There are no loops!"
19:38:10 <Speck> I don't want to scare her with a strict type system just yet I think
19:38:10 <dons> yeah. I remember that kind of comment :)
19:39:31 <Pseudonym> "But what if I WANT to put a value in a variable and then access it later?  How can I do that?"
19:39:48 <Speck> is there a haskell as-your-first-language kind of tutorial?
19:42:17 <Speck> I wonder if it would be beneficial to get her started on something more simple, like a "scripting" language (ruby maybe for it's clean syntax)
19:43:36 <dons> Speck, why not grab the lecture slides from the unsw link I pointed to?
19:44:06 <Speck> oh good idea; I missed the link, incidentally
19:44:14 <Pseudonym> That's possible.
19:44:26 <Pseudonym> Logo was the choice of many in the 80s. :-)
19:45:53 <dons> yes, I was taught logo in primary school.
19:49:30 <dons> Speck, if she's a little mathy, there's: The Haskell Road to Logic, Maths and Programming
19:49:43 <dons> http://homepages.cwi.nl/~jve/HR/
19:50:00 <dons> but maybe that assumes too much.
19:50:04 <Speck> I read the example chapter from that, it might be too mathy
19:55:15 <Speck> these slides look good
19:55:20 <Speck> I might walk her through them with ghci
19:58:06 <Speck> the pdfs have so many repeated pages though...
20:26:53 <Frederick> hi folks
20:31:28 <Speck> howdy Frederick
20:36:53 <Frederick> Speck do you know ml?
20:37:31 <Speck> only so much as one can learn browsing a few tutorials
20:39:13 <Frederick> Im having a hard time parsing a file, I need to remove some tokens from with
21:06:57 <Frederick> guys can I ask a little of ml here? Ive done a function mosml doesnt complains about it vut it doesnt seems to work
22:08:05 <dons> @code
22:08:05 <lambdabot> SizedTypes.hs: ; foreign import ccall nhc_prim/**/T/**/Lsh         :: T -> Int -> T        \
22:08:22 <dons> ooh. nhc_prim. hmm.
22:27:34 <Trevion> Does anyone else's IRC client get all confused by the lack of spacing between urls in the topic?
22:30:22 <dons> not irssi.
23:00:53 * boegel waves
23:59:17 <Itkovian> meuning
23:59:38 <Itkovian> (leaving it to your discretion whether it's a good one)
