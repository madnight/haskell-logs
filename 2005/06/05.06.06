00:06:33 <Itkovian> meuning
00:08:25 * boegel waves
00:08:35 * basti_ flips
00:08:40 <basti_> :)
00:08:57 * basti_ is reading "the yampa arcade"
00:09:57 * boegel wonders what that is
00:10:20 <basti_> yampa is some programming environment involving lots of arrows
00:10:29 <basti_> and arcade games are arcade games
00:10:35 * boegel also wonders which questions he'll get on his RTS exam this afternoon
00:10:43 <basti_> -g-
00:18:08 <foxy_> @pl (\(a,b) -> putStrLn $ a ++ "=" ++ b)
00:18:09 <lambdabot> uncurry ((putStrLn .) . (. ('=' :)) . (++))
00:28:54 * boegel shakes the Haskell tree
00:31:13 <dons> @code
00:31:14 <lambdabot> Eq.hs: #endif
00:31:18 <dons> @code
00:31:19 <lambdabot> Version.hs: data Version =
00:31:22 <dons> @code
00:31:24 <lambdabot> Types.hs: LinkCount,
00:33:03 <boegel> dons: bored ?
00:39:11 <dons> waiting for a long running process to terminate
00:40:13 <boegel> oh I see
00:40:44 <boegel> I'm bored :(
00:40:57 * basti_ hates solving his gf's homework problems
00:41:10 <boegel> basti_: :D
00:41:19 <boegel> did you get punished for playing twister ? ;)
00:41:45 <basti_> no
00:43:47 <boegel> what are you solving ?
00:44:10 <basti_> me? SHE is possibly doing some "psychology" now
00:44:34 <basti_> (stupid formulas for things that are obvious anyway, explained so that noone understands)
00:45:28 <boegel> you said you were solving her homework problems ?
00:45:59 <basti_> well it is some sort of a problem
00:46:13 <basti_> its formulated mathematically
00:46:21 <basti_> so that the teachers can confuse the students
00:46:26 <basti_> no need to do any actual work then
00:46:33 <boegel> heh
00:47:11 <basti_> no i mean get that, they have a formula for telling that a stimulus that isn't there can't be associated to anything ;)
00:48:43 <boegel> heh
00:54:13 <boegel> hi araujo , nothingmuch
00:54:25 <araujo> Hello boegel
00:55:27 <nothingmuch> hi ho
01:00:54 <bibi> if i have this little program
01:01:23 <bibi> do e<-getInt;f<-getInt;return (e-f)
01:01:49 <bibi> how can i be guaranteed that e gets it's value before f?
01:02:02 <musasabi> bibi: because of the do-notation.
01:02:08 <boegel> why shouldn't it ?
01:02:41 <boegel> e comes first in the return statement, so it will be evaluated first, right ?
01:02:45 <musasabi> bibi: that is equal to (getInt >>= (\e -> getInt >>= (\f -> return (e-f)))
01:03:11 <bibi> boegel: in functional programs there is no guarantee of the order of evaluation i thougt?
01:03:27 <musasabi> and >>= (and >>) define sequentation in the IO monad.
01:04:09 <boegel> bibi: you can't be sure when it evaluates, but the order will be respected
01:04:12 <bibi> musasabi: but these are not language features. They are just normal functions, i'm i right?
01:04:19 <musasabi> bibi: yes.
01:05:00 <autrijus> bibi: well, think of it this way; in "f (g x)"
01:05:13 <autrijus> there is no way to fully evaluate "f (g x)" without evaluting "g x" first.
01:05:18 <bibi> boegel: i'm not sure about that.
01:05:27 <musasabi> bibi: one could define an IO-like monad with partially non-deterministic order of evaluation, but that would not be very productive.
01:05:41 <autrijus> (in the IO monad, that is.)
01:06:12 <bibi> autark: so i should think of monads in term of function composition?
01:06:27 <bibi> autrijus: sorry that was meant for you
01:06:37 <autrijus> bibi: that is one fruitful way to think of it.
01:07:08 <bibi> autrijus: because then i am guaranteed an order of evaluation?
01:07:19 <autrijus> bibi: in the IO monad's case, yes.
01:07:43 <bibi> autrijus: i will contemplate about this for a while. this i a bit new to me.
01:08:11 <basti_> hmmm
01:08:16 <Heffalump> one does have an IO-monad with a partially non-deterministic evaluation, cos of unsafeInterleaveIO
01:08:51 <basti_> i think f (g x) might be partially evaluated in some cases no? (deforesting?)
01:08:56 <autrijus> because ultimately the (IO a) type is a function with sequential evaluation order.
01:10:26 <nothingmuch> autrijus: as for DUP vs OVER - i was an idiot to check them in
01:10:34 <autrijus> of the form (RealWorld -> (RealWorld, a))
01:11:01 <autrijus> nothingmuch: ooh ok. have you got my
01:11:01 <autrijus> type Eval a = (MonadReader Interp m, MonadWriter Stack m) => m a
01:11:02 <autrijus> patch?
01:11:11 <autrijus> or are you still staying away from spoilers?
01:11:29 <bibi> so it's only in the io monad that i can sequence opratiions?
01:11:53 <autrijus> bibi: other monads can also sequence operations. however, such sequences not neccessarily means full determinisitic evaluation
01:12:34 <nothingmuch> did you darcs send? or just apply?
01:12:36 <Heffalump> ST will be just as sequenced as IO
01:12:50 <bibi> autrijus: is this sequencing done 'under the hood' so to speak or can it be achieved with normal haskell funtions?
01:12:53 <Heffalump> (note that not everything you do in IO will be sequenced, even ignoring unsafeInterleaveIO)
01:12:59 <Heffalump> for example
01:12:59 <autrijus> nothingmuch: http://autrijus.org/tmp/readerT-spoiler2.txt
01:13:08 <basti_> monads are implicitely sequenced arent they? because of the hidden lambdas
01:13:08 <Heffalump> do let y = f x
01:13:12 <Heffalump>    let z = g w
01:13:16 <nothingmuch> ah
01:13:18 <Heffalump> will not be sequenced at all
01:13:22 <nothingmuch> i had to cook so i didn't get that stuff done yet
01:13:24 <Heffalump> basti_: no, cos of laziness
01:13:27 <autrijus> Heffalump: right, but those are not IO actions.
01:13:33 <nothingmuch> but i will apply it soon
01:13:33 <basti_> hmm
01:14:04 <Heffalump> autrijus: yeah, but with a bit more indirection it can be slightly unclear what is actually an IO action and what isn't
01:14:13 <Heffalump> so you have to be careful
01:14:14 * autrijus praises the type system.
01:14:14 <basti_> i mean, to bind (lambdawise) a variable further down the stream, you might need to have a result from further up
01:14:22 <nothingmuch> oh boy, i have a marker
01:14:29 <Heffalump> well, you don't really, cos order of evaluation shouldn't matter for non-IO actions
01:14:43 <autrijus> nothingmuch: a magic marker? write a recharging scroll!
01:14:44 <basti_> like in: do x<-getLine; ... ;y<-blah x
01:14:56 <basti_> hmm right again
01:14:57 <Heffalump> basti_: it's not when you bind it that matters, it's when you actually demand the results by pattern matching on the value
01:15:02 <basti_> thats right
01:15:06 <basti_> because of laziness
01:15:09 <nothingmuch> i can highlight stuff with it
01:15:11 * basti_ nods
01:15:12 * nothingmuch didn't know he was that organized
01:15:26 <Heffalump> though in the case you give getLine is presumably an IO action
01:16:00 <basti_> yes and thats why it would expected to be evaluated early.
01:16:07 <bibi> i would like to refer to my little program: do e<-getInt;f<-getInt;return (e-f)    the order of evaluation is absolutely crucial for the result.
01:16:14 <basti_> and thats why we force it to by the monad, dont we?
01:16:55 <basti_> i mean the joke is, without the monad, the eval order would be arbitary
01:16:55 <autrijus> bibi: IO monad guarantee that order, because its treatment of RealWorld. do read the "tackling the awkward squad" article for further enlightenment :)
01:17:10 <basti_> but in the monad we might have a hidden state
01:17:15 <autrijus> basti_: it's possible to force the order with seq and friends
01:17:17 <basti_> so the compiler arranges everything in order
01:17:22 <basti_> yes.
01:18:03 <basti_> but you shouldn't be able to get "do" statements out of order with that
01:18:24 <basti_> hm
01:18:34 * basti_ p0nders
01:18:40 <bibi> autrijus: but that's hardcoded into the IO monad. i cannot replicate it myself can i?
01:19:17 <autrijus> bibi: not from the language level in Haskell 98, no.
01:19:35 <bibi> autrijus: ok. that's what i needed to know. thanks!
01:19:42 <basti_> so how does IO do that, then?
01:19:46 <autrijus> you can leverage the IO monad by defining your monad on top of IO.
01:19:56 <autrijus> then it will inherit IO's execution order.
01:20:02 <bibi> autrijus: yes, but that is kind of cheating.
01:20:14 <basti_> how about making a monad with seq?
01:20:26 <bibi> autrijus: i thought monads could do this kind of thing.
01:20:42 <bibi> i mean monads in general
01:20:45 <basti_> though it would be non-trivial for various datatypes
01:21:04 <autrijus> basti_: Seq monad: http://www.haskell.org/pipermail/libraries/2004-February/001732.html
01:21:07 <basti_> ohh
01:21:10 <Heffalump> bibi: how do you intend to implement getInt without using IO?
01:21:28 * basti_ knows he's in the right zoo when he gets ideas other people get too
01:22:08 <bibi> Heffalump: good question. i haven't thought about what contexts sequencing would be useful for. maybe it's only applicable to IO
01:23:19 <Heffalump> any monad with genuine side-effects should enforce sequencing
01:23:29 <Heffalump> you can only implement such a monad in C
01:23:34 <Heffalump> well, outside Haskell
01:23:58 <basti_> so basically, the fact that IO uses FFI calls makes it that eager?
01:24:11 <basti_> *is what
01:25:58 <Heffalump> no, the fact that it is explicitly written to enforce sequencing by using a dummy RealWorld parameter is what makes it eager
01:26:16 <basti_> okay.
01:26:21 <Heffalump> but it's only when doing FFI or the equivalent that you need to worry about that kind of thing
01:26:29 <basti_> yes that's clear
01:26:50 <basti_> so why cant you use the same parameter and make any other construction just as eager?
01:27:43 * boegel yawns
01:27:57 <Heffalump> oh, sorry, it's the fact that the RealWorld parameter is actually passed to the external calls that matters.
01:28:04 <basti_> boegel: youre not eager huh
01:28:07 <basti_> ahhh.
01:28:11 <basti_> okay now THIS makes sense :)
01:28:15 <Heffalump> oh, actually, that's not true.
01:28:18 <basti_> no?
01:28:23 <Heffalump> You can do some dummy case analysis on it to simulate the effect
01:28:27 <Heffalump> (in haskell)
01:28:40 <basti_> i see
01:28:41 <Heffalump> if your monad is type (RealWorld  -> (a,RealWorld))
01:28:50 <Heffalump> and data Realworld = RealWorld
01:28:56 <Heffalump> then writing functions in the style
01:29:10 <boegel> eager ? eager for what ?
01:29:12 <Heffalump> f rw = case rw of RealWorld -> (compute a, RealWorld)
01:29:16 <basti_> boegel: evaluation
01:29:28 <Heffalump> oh, no, that still won't work, cos the computation of a will end up lazy
01:29:47 <basti_> Heffalump: so we need both at least a dummy value in haskell, and then its dependancy on FFI?
01:29:55 <Heffalump> or seq
01:30:08 <basti_> ok.
01:30:15 * Heffalump is speculating a bit here
01:30:26 <boegel> basti_: I have an exam this afternoon, but don't feel like attending it
01:30:49 <Heffalump> but FFI basically allows you to hide from the Haskell system the fact that two calculations are independent - like the tuple I produce above
01:30:59 <basti_> boegel: as i said, you're not eager for evaluation!?
01:31:10 <boegel> basti_: oh sorry
01:31:12 <boegel> no I'm not :)
01:31:18 <basti_> -g-
01:31:22 * basti_ retrofits his puns
01:31:29 <boegel> I'm sick and tired of RTS
01:32:17 <basti_> Heffalump: thats the line i was thinking along too.
01:32:37 <boegel> does anyone know which nick Stefan Holdermands uses in #haskell ?
01:33:36 <nothingmuch> autrijus: why is Reader called Reader, actually?
01:39:07 <autrijus> nothingmuch: I need to go offline to write hw2005.txt
01:39:22 <autrijus> nothingmuch: Reader is called Reader because you can only read from the state, not write to it.
01:39:28 <nothingmuch> have fun
01:39:32 <autrijus> (you can make a local change, but it's not "write")
01:40:05 <autrijus> conversely, Writer is called Writer because you can only write out things (in your case the Literals), not read from them.
01:40:11 <nothingmuch> oh, i see
01:40:19 <autrijus> (you can perform a local listen, but it's not "read")
01:40:55 <nothingmuch> nono, don't start
01:40:58 <nothingmuch> my brain might explode
01:41:07 <autrijus> oh ok. take one step at a time.
01:41:16 <autrijus> it took me ~7 days to understand them all :)
01:41:22 <nothingmuch> yes, that's the whole point of the excercise
01:41:41 * nothingmuch hasn't time luxuries or extra grey matter
01:41:52 <nothingmuch> so i doubt it'll be a week
01:42:12 <autrijus> (and I confess I still not fully grok how monadfix plays with transformed monads)
01:42:25 <autrijus> but i'll stop and go offline now, lest your brain explodes. have fun :)
01:42:30 <autrijus> &
01:44:05 <nothingmuch> @t const
01:44:06 <lambdabot> Maybe you meant: timein todo todo-add todo-delete topic-cons topic-
01:44:06 <lambdabot> init topic-snoc topic-tail topic-tell type pl wn
01:45:11 <nothingmuch> @type const
01:45:12 <lambdabot> const :: forall a b. a -> b -> a
01:47:42 * boegel yawns once again
01:49:11 <nothingmuch> const 1 returns a function that when applied will return 1?
01:51:34 <basti_> yes
01:53:12 <boegel> @plugs const 1 a
01:53:13 <lambdabot> Variable not in scope: `a'
01:53:16 <boegel> @plugs const 1 'a'
01:53:17 <lambdabot> 1
01:53:21 <boegel> @plugs const 1 2
01:53:23 <lambdabot> 1
01:54:14 <basti_> @plugs const 1 [(a,b)|a<-[2,3,4],b<-[2,3,5]]
01:54:15 <lambdabot> 1
01:54:17 <basti_> =)
01:54:32 <boegel> basti_: lol
01:57:35 * boegel eats a banana to fuel his brain
02:03:15 <Itkovian> @type const
02:03:21 <lambdabot> const :: forall a b. a -> b -> a
02:03:35 <Itkovian> ah. K
02:03:39 <basti_> :)
02:03:45 <boegel> heh
02:05:54 <boegel> reffie: were you the one who knows a lot of C ?
02:06:33 <boegel> or was it r3tex ?
02:06:36 * basti_ isn't that bad in C too
02:06:42 * basti_ just doesn't like C anymore.
02:07:23 <boegel> basti_: oh, 'cause I rewrote HRay in C, too check the diff in performance
02:07:30 <boegel> but it's full of memory leaks
02:07:50 <boegel> I uses like 700mb of ram when trying a 800x600 scene
02:07:59 <basti_> and that would be unusual?
02:08:00 <basti_> =)
02:08:07 <basti_> or somehow surprising? -g-
02:08:14 <boegel> I could use some help with removing those leaks
02:08:18 <basti_> do you know valgrind?
02:08:22 <boegel> I do
02:08:25 <boegel> I've used it
02:08:30 <basti_> no help though
02:08:32 <boegel> it used to use 2gb of ram :D
02:08:35 <basti_> ah.
02:08:39 <boegel> yes, a little bit ;)
02:08:49 <basti_> hmm
02:08:56 <basti_> is it really leaks?
02:09:03 <basti_> as in, memory allocated but not freed?
02:09:12 <boegel> but I don't free most of my memory space because I don't kow how really :)
02:09:17 <boegel> I guess so
02:09:17 <basti_> or is it just the un-Cish construction?
02:09:26 <basti_> uhm
02:09:26 <boegel> don't know really
02:09:28 <basti_> free()?
02:09:42 <boegel> but, you have to give it pointers, don't you ?
02:09:45 <basti_> yes.
02:09:56 <basti_> where do your get your mem from?
02:09:57 <Philippa_> which have to be to stuff allocated with malloc
02:10:00 <boegel> malloc
02:10:02 <basti_> see
02:10:08 <basti_> you get a pointer back there
02:10:13 <boegel> yeah
02:10:18 <boegel> doesn't seem to work though :s
02:10:21 <basti_> if you stuff that into free, then the space is freed again
02:10:22 <Philippa_> if you're working with C++ you can use new/delete and destructors too, which can make life easier
02:10:40 <boegel> I'm not using C++ :)
02:11:01 <boegel> basti_: maybe you could give me some pointers tonight, I'll show you the code then ,
02:11:12 <boegel> beats the hell out of playing twister with some chick ;)
02:11:26 <basti_> especially if she smells nice. Yes.
02:11:38 <boegel> and your gf doesn't ? :D
02:12:32 <basti_> oh she does
02:12:32 <basti_> i just don't have the opportunity to check all that often.
02:13:11 <boegel> lolz
02:24:28 <Itkovian> boegel: you do use free, no?
02:24:37 <boegel> Itkovian: err, nah :)
02:24:42 <Itkovian> you could use DIOTA too, instead of valgrind
02:24:46 <boegel> I know I should, but I'm not used to using it
02:24:50 <boegel> DIOTA ?
02:25:00 <Itkovian> it will pinpoint the exact location of the lost memory
02:25:13 <Itkovian> boegel: didn't they teach you anything? lol
02:25:25 <boegel> Itkovian: yeah they did :) but not the free part :p
02:25:26 <Itkovian> http://www.elis.ugent.be/diota
02:25:40 <Itkovian> eh? I'm sure they did mention it!
02:25:54 <Itkovian> anyway Elias is awake, brb
02:26:32 <boegel> yeah, but the stuff we had to write for Compilers, always had stuff already written in it... all the stuff where we had to use free, was already written, so we didn't have to worry about it all too much
02:26:55 <boegel> anyways, when you're used to coding in Java you just don't give a shit about memory, it's just there for you
02:28:24 <boegel> anyway, I should be getting ready to leave soon
02:28:36 <Lor> Well, I'm right now coding in Java and C and all the time I have to consider what happens if memory runs out.
02:30:51 <Philippa_> you'd have to for the same task in Haskell too though, right?
02:31:05 <xerox> Goood mooorning iiiirc.
02:32:41 <boegel> good byeeeeeeeeee iiiiiiiiiirc :)
02:41:30 <Lor> Is this a common concept: newtype Stream m a = Stream (m (a, Stream m a)) ? What's it called?
02:41:58 <neologism> recursive type?
02:42:00 <Enveigler1> Could someone explain/point me at the docs for the use of '$', as in "alloca $ \ pDummy  -> do" ?
02:42:33 <basti_> thats simple
02:42:33 <xerox> cons-stream ?
02:42:42 <basti_> a $ b c    ==     a (b c)
02:42:56 <basti_> its just like braces to the right. application, right associative
02:43:07 <basti_> Enveigler1.
02:44:48 <Enveigler1> Oh? That explains it does it? :) (I've still a ways to go yet in learning to read Haskell!)
02:46:00 <basti_> @plugs (+) 1 2
02:46:02 <lambdabot> 3
02:46:06 <basti_> @plugs (+) 1 (+) 2 3
02:46:08 <lambdabot> <Plugins.Eval>:1:
02:46:08 <lambdabot>   No instance for (Num (a -> a -> a))
02:46:08 <lambdabot>   arising from the literal `1'
02:46:11 <basti_> @plugs (+) 1 $ (+) 2 3
02:46:13 <lambdabot> 6
02:46:16 <basti_> see?
02:46:24 <basti_> @plugs (+) 1 ((+) 2 3)
02:46:26 <lambdabot> 6
02:47:16 <xerox> @plugs (+) 1 . (+) 2 $ 3
02:47:18 <lambdabot> 6
02:47:36 <basti_> -g-
02:49:20 <Enveigler1> So, $ means "Evaluate what's on the right before supplying the result to the (nearest) operator to the left"?
02:49:37 <basti_> ($)            :: (a -> b) -> a -> b
02:49:38 <basti_> f $ x           = f x
02:49:50 <basti_> infixr 0  $
02:49:53 <basti_> thats all that is to it
02:50:19 <basti_> f $ x is the same as f x, just that $ binds very loose and associates right
02:50:51 <Enveigler1> Sorry. I need to go back to the "Haskell for Dummies", if only I could find such a thing :(
02:50:54 <xerox> I supposed it was very hard, binding to end of the line in most cases o_O
02:50:58 <Muad_Dibber> and that seemingly $ can cause efficiency loss :P
02:51:23 <autrijus> right. we're more efficient when not working for $
02:51:40 * basti_ sighs
02:51:43 <Enveigler1> The explainations raise more questions than answers at the moment.. eg. what's that darn '.' doing in "@plugs (+) 1 . (+) 2 $ 3"?
02:51:46 <basti_> yes, these $ associate right too.
02:51:50 * xerox hides
02:51:52 <basti_> Enveigler1: function composition
02:51:59 <basti_> @plugs (+1) 1
02:52:00 <lambdabot> 2
02:52:03 <basti_> @plugs (+1).(+1) 1
02:52:05 <lambdabot> <Plugins.Eval>:1:
02:52:05 <lambdabot>   No instance for (Num (a -> b))
02:52:05 <lambdabot>   arising from the literal `1'
02:52:07 <basti_> oh
02:52:08 <basti_> @plugs (+1).(+1) $ 1
02:52:09 * xerox grins
02:52:10 <lambdabot> 3
02:52:19 <xerox> @type (.)
02:52:21 <lambdabot> (.) :: forall c a b. (b -> c) -> (a -> b) -> a -> c
02:52:49 <xerox> It gets a function from b to c, and a function from a to b, and returns a function from a to c.
02:53:12 <neologism> its the same as in discrete math
02:53:28 <basti_> yes or in any other context where mathematicans compose functions
02:53:41 <basti_> just that mathematicans usually use a little circle in the middle of a line
02:53:45 <basti_> not a dot at the bottom
02:53:49 <neologism> knowing math helps a lot with haskell
02:53:54 <basti_> but the similarity is intended and obvious
02:54:25 <basti_> and knowing the rule of thumb: "application binds tightest"
02:54:29 <basti_> helps a lot too
02:54:47 <autrijus> @plugs undefined :: ((a -> b) -> a) -> a
02:54:48 <lambdabot> <Plugins.Eval>:1:
02:54:48 <lambdabot>   No instance for (Show (((a -> b) -> a) -> a))
02:54:48 <lambdabot>   arising from use of `show'
02:55:19 * autrijus thinks haskell is just executable math
02:55:35 <xerox> (f . g) x = f (g x)
02:55:43 * basti_ thinks mathematicans wave their hands a lot when what they're trying to do is haskell
02:55:58 <xerox> (f . g) x = f $ g x
02:56:00 <Enveigler1> Mathem,aticians surely do have a knack of making simple, intuative things very complicated!
02:56:17 <basti_> ahh.
02:56:17 <basti_> ;)
02:56:19 <xerox> Enveigler1, and vice-versa ^__^
02:57:43 <Enveigler1> I'll reserve judgement on that one xerox. I guess you have to be able to do the simple things (in the complicated way) before attempting to the complicated things (simply) :)
02:58:52 <dons> maths doesn't have a type checker -- so you can wave your hands.. haskell is more disciplined
02:58:55 <neologism> you can do simple things very complicated in haskell if you are not skilled enough
02:59:05 <neologism> dons: you can have type system in math
02:59:31 <dons> i'm sure you can -- it's called SystemF ;)
02:59:33 <Philippa_> well yeah. Otherwise Haskell couldn't have one. Your point? :-)
02:59:48 <Philippa_> dons: er, that's the one the mathmos really don't like :-)
03:00:20 <xerox> What does "mathemos" mean? :-)
03:00:24 <neologism> what exactly is systemF$MASTERS_FILE="/etc/namedb/masters.conf";
03:00:24 <neologism> $SLAVES_FILE="/etc/namedb/slaves.conf";
03:00:24 <neologism> $MASTER_CONF_FILE="/etc/namedb/conf/dom-master.conf";
03:00:27 <neologism> sorry
03:01:16 <xerox> Missed the '?' key, hit the '>>= configuration' one :P
03:01:21 <Philippa_> xerox: short for mathematicians
03:01:38 <Philippa_> might be oxbridge-specific slang, the friends I picked it up from are there
03:01:58 <Enveigler1> Yeah! But skill is acquired, and it's acquisition is cummulative. The problem with all the Haskell docs I've found so far is that they assume a mathematical grounding.
03:02:21 <Philippa_> how much so?
03:02:35 <Philippa_> certainly a lot of the papers do, they weren't really meant as end-user documentation
03:03:11 <Philippa_> I suspect some of them assume you'll STFW if you don't understand a term like "right-associative", though that's just as relevant to programming languages (and possibly parsing) as it is to maths
03:03:33 <basti_> i found haskell more intutive on the first glance than all the other languages
03:03:43 <Enveigler1> My grounding in (imperative) programming rather than being an asset seems to give me expectations that Haskell doesn't satisfy in it syntax. I think I get (and like) the semantics--but Oh, the syntax is tortuous.
03:03:52 <Philippa_> it took me a short while to get used to doing everything in terms of recursion
03:03:54 <basti_> i remember wondering "why can't i use functions as values" when i was 12 years old or something, programming in BASIC
03:03:56 <dons> haskell was more first language, so everything else seems wacked ;)
03:04:06 <Philippa_> the syntax is wonderful. But yeah, you'll have to let go of a few things
03:04:07 <dons> s/was my first/
03:04:16 <basti_> dons: it was? how cool.
03:04:27 <Philippa_> You stopped expecting f(g) for application yet?
03:07:56 <Enveigler1> Philippa: STFW?
03:08:44 <nothingmuch> autrijus: why is Stack a MonadWriter, and not Eval?
03:10:05 <basti_> "search the fine web"
03:11:43 <Enveigler1> Ah! I've done nothing but for the past 4 days :(
03:12:02 <basti_> dont worry that will pass
03:12:05 <basti_> in a year or two
03:12:06 <basti_> =)
03:12:50 <nothingmuch> you guys are like the Idiot Repression Squad
03:13:07 <Enveigler1> Oh well. Seeya'll in a couple o'years.
03:13:13 <basti_> why?
03:13:13 <nothingmuch> idiots like me come marching in here, saying "Oh, I'm going to know haskell soon! It will make me übermanly!"
03:13:23 <basti_> nothingmuch: i was j/k
03:14:04 <nothingmuch> and then instead of saying "the secret to haskell in 2 sentances is ...", you say "monads! here, take a mirror, you are an idiot"
03:14:07 <nothingmuch> bwahahahaha
03:14:17 <nothingmuch> (that was crying, not laughter)
03:14:23 <basti_> ahh.
03:14:29 <basti_> monad is just a stupid word.
03:14:38 <basti_> people should have called it "cute pink fuzzy warm thing"
03:14:46 <basti_> then it wouldnt be as scary
03:15:04 <basti_> its just an abstraction of computation.
03:15:15 <nothingmuch> =P
03:15:49 <nothingmuch> basti_: don't take me too seriously ;-)
03:15:53 <Enveigler1> S'funny, but monads (besides the name) don't bother me. That's the bit of Haskell I get.
03:16:06 <basti_> hehe
03:16:12 <basti_> you havent written one yet have you
03:16:12 <basti_> ;)
03:16:46 <lispy> i can write a monad, watch.  "a monad" see, no problem at all ;)
03:17:09 <earthy> basti: not 'just' an abstraction of computation
03:17:10 * lispy has obviously been working on his report for too many hours running...
03:17:26 <earthy> you definitely have, lispy
03:17:36 <basti_> @plugs do {x<-"abc";return $ x:"xy"}
03:17:38 <lambdabot> ["axy","bxy","cxy"]
03:17:40 <basti_> ^ monads
03:17:40 <basti_> =)
03:18:35 <lispy> basti_: next time it needs to spell "monad" as the result ;)
03:18:58 <basti_> right.
03:19:03 <Enveigler1> @plugs do {x<-"abc";return ( x:"xy" ) }
03:19:04 <lambdabot> ["axy","bxy","cxy"]
03:19:15 <Enveigler1> Why use the $?
03:19:20 <basti_> to save braces.
03:19:36 <Muad_Dibber> sometimes $ makes it a lot more clear than braces :)
03:19:38 <basti_> to save space in the head, since you don't have to type ) anymore.
03:20:07 <basti_> and to avoid programs that look like lisp)))))))))))))
03:20:43 <Enveigler1> @plugs do {x<-"abc";return x:"xy"}
03:20:44 <lambdabot> Couldn't match `m Char' against `Char'
03:21:35 <Enveigler1> Where the heck does 'm' come from?
03:21:43 <basti_> its a type variable
03:21:56 <basti_> thats what hugs calls a thing that is supposed to be a monad
03:22:13 <Muad_Dibber> @type return
03:22:14 <lambdabot> return :: forall (m :: * -> *) a. (Monad m) => a -> m a
03:22:28 <Muad_Dibber> thats where it comes from
03:22:40 <basti_> k
03:22:45 <Muad_Dibber> what you wrote down is actually (return x) : "xy"
03:24:45 <lispy> @plugs do { x <- ("abc"); (return ((:) (x) ("xy"))) }
03:24:47 <lambdabot> ["axy","bxy","cxy"]
03:24:53 <lispy> yay for parens!
03:25:14 <Muad_Dibber> indeed lispy , this is really way more clear than what basti_  wrote :P
03:25:27 <basti_> we could pointless it.
03:26:23 <lispy> lambdabot doesn't do pointless with the do nation tho
03:26:29 <lispy> you'd have to convert it
03:26:56 <Enveigler1> Okay. Well thanks guys.
03:26:58 <basti_> -g-
03:27:05 <basti_> scared enough?
03:27:20 <basti_> we could talk about arrows if you think monads are boring
03:27:34 <lispy> what was that one that turns into (.).(.) ?
03:27:38 <lispy> @type (.).(.)
03:27:40 <basti_> lol
03:27:57 <lispy> @vixen are you awake?
03:28:25 <Enveigler1> Enjoy your audience.
03:28:25 <lispy> er... lambdabot ?
03:28:38 <lispy> hmm...
03:28:46 <Lor> Bah. Why isn't ReadP:s input token type parameterized?
03:28:53 <basti_> split away
03:29:04 <lispy> @type (.).(.)
03:29:40 <basti_> okay guys, bbl, hF
03:29:44 <lispy> (.).(.) :: (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
03:30:08 <lispy> (.).(.) (id) (+) 1 -2 3
03:30:12 <lispy> @plugs (.).(.) (id) (+) 1 -2 3
03:32:29 <lispy> @pl \x y -> ((.).(.)) id (+) x y
03:34:06 <lispy> i guess lambdabot can't hear me...
03:34:17 <lispy> @vixen hello?
03:34:46 <neologism> split
03:34:49 <Muad_Dibber> no
03:34:49 <lambdabot> hi
03:34:49 <Enveigler1> @pl \x y -> ((.).(.)) id (+) x y
03:34:49 <lambdabot> (+)
03:34:49 <Muad_Dibber> freenode is opviously having problems :P
03:35:09 <lispy> oh, i had no clue
03:35:15 <lispy> i can't see net splits
03:35:35 <tic> lispy, didn't you see a lot of quit/joins?
03:35:37 <neologism> reffie: hi ;)
03:35:38 <lispy> @pl \x y -> ((.).(.)) (-) (+) x y
03:35:39 <lambdabot> ((-) .) . (+)
03:35:55 <lispy> tic: not really
03:36:31 <lispy> @pl \x y -> ((.).(.)) (^) (\) x y
03:36:32 <lambdabot> (line 1, column 25):
03:36:32 <lambdabot> unexpected ")"
03:36:32 <lambdabot> expecting pattern
03:36:38 <lispy> @pl \x y -> ((.).(.)) (^) (-) x y
03:36:38 <lambdabot> ((^) .) . (-)
03:36:47 <lispy> heh, that's just silly...
03:36:53 <xerox> Why?
03:36:58 <seidan> @pl \foo bar -> foo >>= \x -> return $ x:bar
03:36:59 <lambdabot> flip (fmap . flip (:))
03:37:18 <lispy> xerox: i dunno, it's just like line noise or something
03:37:28 <lispy> xerox: i'd never want to use that ;)
03:38:23 <SM_ax> is this a FlashMob or something?
03:38:33 <lispy> flip (fmap . flip (:)) "monad" []
03:38:40 <lispy> @plugs flip (fmap . flip (:)) "monad" []
03:38:43 <lambdabot> ["m","o","n","a","d"]
03:39:27 <lispy> @pl \x -> concat (flip (fmap . flip (:))) x []
03:39:27 <lambdabot> flip (join (flip (fmap . flip (:)))) []
03:39:43 <lispy> flip (join (flip (fmap . flip (:)))) [] "monad"
03:39:50 <lispy> @plugs flip (join (flip (fmap . flip (:)))) [] "monad"
03:39:50 <lambdabot> Couldn't match `(->) b' against `[]'
03:39:54 <lispy> oops
03:40:09 <lispy> @plugs flip (join (flip (fmap . flip (:)))) [] "monad"
03:40:10 <lambdabot> Couldn't match `(->) b' against `[]'
03:40:12 <lispy> hm...
03:40:24 <lispy> @plugs (flip (join (flip (fmap . flip (:)))) []) "monad"
03:40:25 <lambdabot> Couldn't match `(->) b' against `[]'
03:41:05 <lispy> (\x -> concat (flip (fmap . flip (:))) x []) "monad"
03:41:09 <lispy> @plugs (\x -> concat (flip (fmap . flip (:))) x []) "monad"
03:41:11 <lambdabot> Couldn't match `[a]' against `t -> t1'
03:41:31 <Enveigler1> Says it all.
03:42:33 <earthy> what the bleep?
03:44:42 <Lemmih> @plugs (\x -> concat (flip (fmap . flip (:)) x [])) "monad"
03:44:42 <seidan> @plugs flip (fmap . flip (:)) "1 "monad"
03:44:43 <lambdabot> "monad"
03:44:43 <lambdabot> lexical error in string/character literal
03:44:49 <Muad_Dibber> @type flip $ join $ flip $ fmap . flip (:)
03:44:49 <seidan> @plugs flip (fmap . flip (:)) "123" "monad"
03:44:49 <lambdabot> bzzt
03:44:51 <lambdabot> ["1monad","2monad","3monad"]
03:44:59 <dons> this is why I love #haskell
03:45:05 <lispy> fmap (: []) "monad"
03:45:08 <Muad_Dibber> dons : is it?
03:45:11 <lispy> @plugs fmap (: []) "monad"
03:45:13 <lambdabot> ["m","o","n","a","d"]
03:47:49 <lispy> @plugs ((: []) =<<) "monad"
03:47:51 <lambdabot> "monad"
03:47:55 <lispy> now that rocks
03:48:07 <xerox> :-)
03:48:19 <lispy> @plugs ((: []) =<<) (Just 1)
03:48:20 <lambdabot> Couldn't match `[]' against `Maybe'
03:48:27 <lispy> @plugs ((: Nothing) =<<) (Just 1)
03:48:29 <lambdabot> Couldn't match `[a]' against `Maybe a1'
03:48:32 <lispy> er...
03:48:32 <xerox> O_o
03:48:39 <dons> too many monads!
03:48:40 <lispy> who knows what i was trying to do
03:48:50 <lispy> @plugs ((: []) =<<) "yes, i agree!"
03:48:51 <lambdabot> "yes, i agree!"
03:49:42 <lispy> they should have obsfuscated Haskell contests
03:49:52 <xerox> They do have them :-)
03:49:57 <lispy> heh, figures ;)
03:50:22 <xerox> listId = (: []) =<<
03:51:06 <SM_ax> cool pic, btw :)
03:51:56 <lispy> @plugs ((: "a little surprise.") =<<) "Oh, look! "
03:51:57 <lambdabot> "Oa little surprise.ha little surprise.,a little surprise. a little
03:51:57 <lambdabot> surprise.la little surprise.oa little surprise.oa little surprise.ka
03:51:57 <lambdabot> little surprise.!a little surprise. a little surprise."
03:52:02 <lispy> heh
03:52:04 <lispy> nice
03:52:06 <SM_ax> how about "ascii art Haskell" contest? :)
03:52:39 * lispy goes to put that on his wiki
03:56:03 <shapr> mikael: hej!
03:56:10 <xerox> Hiya shapr!!
03:56:16 <shapr> y0! wassup?
03:56:39 <xerox> Mostly playing Go :-)
03:57:04 <shapr> Ah, I've been avoiding Go, since I think I'll be horribly addicted.
03:57:20 <xerox> You will be assim1l4t3d.
03:57:36 <shapr> w3 4r3 th3 b0rg, w3 pl4y g0
03:58:14 <Muad_Dibber> the b0rg cannot play go
03:58:19 <Philippa_> 'lo shapr
03:58:25 <shapr> hiya Philippa_
03:58:47 * xerox tenuki on Muad_Dibber's sentence
03:58:51 <lispy> Muad_Dibber: do you have proof?
03:59:06 <Muad_Dibber> well, its pointless
03:59:11 <Muad_Dibber> the borg have one mind, right?
03:59:40 <lispy> nah, that's just what they want you to think
03:59:46 <xerox> ahah.
04:00:25 <Muad_Dibber> aah
04:01:16 <shapr> aahh
04:01:24 * shapr stubs his toe on a lambda
04:01:32 <shapr> So, how's code going? You guys written anything nifty?
04:01:49 <lispy> shapr: http://www.codersbase.com/Autproc
04:01:54 <lispy> shapr: http://www.codersbase.com/Autoproc
04:02:07 <lispy> (sorry, typo!)
04:02:33 <lispy> oh and this thing:
04:02:37 <lispy> @plugs ((: "a little surprise.") =<<) "Oh, look! "
04:02:39 <lambdabot> "Oa little surprise.ha little surprise.,a little surprise. a little
04:02:39 <lambdabot> surprise.la little surprise.oa little surprise.oa little surprise.ka
04:02:39 <lambdabot> little surprise.!a little surprise. a little surprise."
04:02:53 <shapr> lispy: hey, that's pretty cool.
04:03:30 <lispy> it's a bit demented tho ;)
04:03:46 <lispy> @plugs ((: []) =<<) "This version is just identity."
04:03:48 <lambdabot> "This version is just identity."
04:04:33 <lispy> bleh, why is Hamiltonian path a worth while problem to study?
04:04:46 <lispy> because it comes up all over the place right?
04:05:00 <lispy> scheduling, networks, dna research and so on right?
04:06:04 <scalopus> Hi
04:09:42 <xerox> @type (flip >>=) return
04:09:43 <lambdabot> (flip >>=) return :: forall a b c.
04:09:43 <lambdabot>        (Monad ((->) (a -> b -> c))) =>
04:09:43 <lambdabot>        (a -> b -> c) -> b -> a -> c
04:26:51 <shapr> What time is it on the west coast of the USA?
04:27:53 <lispy> 4:30am
04:28:00 <lispy> not that'd i would know or anything...
04:28:03 <dons> @timein seattle
04:28:06 <lambdabot>  Monday, June 6, 2005 at 4:29:06 AM PDT
04:28:31 <lispy> shapr: why?
04:28:50 <shapr> dons: oh, too easy
04:29:01 <shapr> lispy: I'm trying to order unicycle parts.
04:29:17 <lispy> umm...cool...
04:29:52 <xerox> shapr, how much are you going yo pay for shipment?
04:30:49 <shapr> Looks like $400 :-(
04:31:07 <xerox> COUGH.
04:32:14 <shapr> And that's only for two pieces of my new unicycle.
04:34:05 <shapr> xerox: how's code?
04:39:17 <earthy> um
04:39:26 <earthy> shae, aren't there any local dealers?
04:40:02 <shapr> Yes, and they have to order from the same people, so shipping will be cheaper and slower, but the parts will be more expensive.
04:40:43 <earthy> hm. right.
04:41:28 <seidan> @pl \n -> n*(n+1) `div` 2
04:41:29 <lambdabot> ap (*) ((`div` 2) . (1 +))
04:41:46 <shapr> Hey, any ideas for improving the look of The Monad.Reader?  Someone on lambda-the-ultimate.org said that he may not read TMR because he finds web pages and wikis too difficult to read.
04:42:08 <shapr> I still don't want to switch back to LaTeX, but I wonder if there are other alternatives. Maybe a better stylesheet?
04:42:14 <shapr> Can print stylesheets paginate?
04:42:30 <seidan> @index ap
04:42:31 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
04:42:31 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
04:42:31 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
04:42:31 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.
04:42:31 <lambdabot> Inductive
04:46:17 <seidan> @plugs (ap (*) ((`div` 2) . (1 +))) 4
04:46:19 <lambdabot> <Plugins.Eval>:1:
04:46:19 <lambdabot>   No instance for (Monad ((->) a))
04:46:19 <lambdabot>   arising from use of `ap'
04:47:24 <seidan> odd.. what was @pl thinking?
04:49:12 <Muad_Dibber> @pl ap (*) ((`div` 2) . (1 +)) 4
04:49:13 <lambdabot> 8
04:50:01 <Muad_Dibber> @type ap
04:50:02 <lambdabot> bzzt
04:50:30 <seidan> and that's wrong anyway. the lambda does the mult before the div.
04:50:49 <seidan> @plugs (\n -> n*(n+1) `div` 2) 4
04:50:51 <lambdabot> 10
04:51:55 <seidan> @type Control.monad.ap
04:51:57 <lambdabot> bzzt
04:51:59 <seidan> @type Control.Monad.ap
04:52:01 <lambdabot> Control.Monad.ap :: forall b (m :: * -> *) a.
04:52:01 <lambdabot>        (Monad m) =>
04:52:01 <lambdabot>        m (a -> b) -> m a -> m b
04:52:19 <seidan> @pl Control.Monad.ap (*) ((`div` 2) . (1 +)) 4
04:52:20 <lambdabot> Control . Monad . 8
04:53:02 <Muad_Dibber> @pl (\n -> n*(n+1) `div` 2) 4
04:53:03 <lambdabot> 8
04:53:04 <dons> hehe
04:53:25 <seidan> neat. I'm confused.
04:54:00 <Muad_Dibber> @pl (\n -> (n*(n+1)) `div` 2) 4
04:54:01 <lambdabot> 10
04:54:03 <Muad_Dibber> :)
04:54:29 <shapr> dons: Hey, think you'll have time for a TMR article for this month? Have I already asked you that? :-)
04:54:55 <shapr> mikael: Want to write for the The Monad.Reader?
04:55:32 <dons> sigh, so busy. too many papers due, shapr :/
04:55:37 <shapr> Ah, too bad
04:55:51 <shapr> Ok, I'll put on my list of people to ask for the month after.
04:55:56 <dons> ok :)
04:59:12 <seidan> @pl ap ((`div` 2).(*)) (1+) 4
04:59:13 <lambdabot> ((4 *) `div` 2) 5
05:01:33 <seidan> hehe
05:18:53 <autrijus> nothingmuch: er, Eval _is_ MonadWriter
05:19:00 <autrijus> nothingmuch: the "Stack" means the type that it writes.
05:19:01 <autrijus> type Eval a = (MonadReader Interp m, MonadWriter Stack m) => m a
05:19:46 <autrijus> you see, MonadWriter is a class that takes two type parameters, where you can determine the first type using the second type; the second type is the monad, and the first type is the thing that it writes.
05:20:56 <autrijus> the "determine one type from another" thing is called "fundep"
05:21:26 <nothingmuch> err, sorry
05:21:28 <autrijus> "fundep" means that it's so much fun, you'll be dependend on it
05:21:36 <autrijus> dependent, even
05:21:38 <Itkovian> lol
05:22:21 <nothingmuch> i meant why is Interp not the one containing the MonadWriter?
05:22:27 <Itkovian> shapr, can't we have a simple script that transforms the wiki code to latex automagically?
05:22:34 <autrijus> (seriously, it means that the class can act as a function that takes the second type and calculate the first for you)
05:22:46 <autrijus> nothingmuch: because you don't print the interp at any point
05:22:59 <autrijus> nothingmuch: both "." and ".S" prints the stack.
05:23:11 <autrijus> "." prints one element and ".S" prints all.
05:23:16 <nothingmuch> right
05:23:24 <autrijus> so it's a writer that writes stacks
05:23:25 <autrijus> not interpreters
05:23:28 <nothingmuch> but it seems like it doesn't make too much sense
05:23:35 <nothingmuch> to leave the stack out of the itnerp
05:23:48 <autrijus> hm? the Interp still contains a stack
05:23:51 <nothingmuch> oh wait
05:23:53 <nothingmuch> ah
05:23:58 <nothingmuch> now i'm completely confused
05:24:29 <autrijus> basically I'm just replacing your "print" with "tell".
05:24:31 <autrijus> that's all.
05:24:45 <nothingmuch> right
05:24:47 <autrijus> although you can print anything that's showable with print
05:24:52 <autrijus> you really only print one thing
05:24:54 <autrijus> namely the stack
05:25:13 <autrijus> so we can refactor out your dependency on the IO monad
05:25:15 <nothingmuch> ohohoh, i get it
05:25:18 <autrijus> by replacing "print" with "tell"
05:25:23 <autrijus> that way you don't rely on IO at all.
05:25:25 <nothingmuch> eval contains an interpreter reader, and a stack writer
05:25:26 <autrijus> which is a Good Thing (tm)
05:25:44 <nothingmuch> there, that works in english
05:26:06 <autrijus> nice
05:26:20 <autrijus> so, by using "tell" instead of "print"
05:26:30 <autrijus> you can implement the compiler as a MonadWriter monad
05:26:37 <nothingmuch> btw, i've read through irc logs, and the meet the monads about reader, and I still don't get how it pulls it off
05:26:40 <autrijus> and when it sees "tell", it emits some PIR code that prints something
05:26:55 <autrijus> instead of actually printing it during compilation.
05:27:04 <autrijus> that's the main point in this abstract-everything exercise.
05:27:22 <nothingmuch> yup
05:28:43 <autrijus> the reader monad (Reader Interp a) is really just a thin disguise of functions of the form (Interp -> a)
05:29:02 <autrijus> this:
05:29:03 <autrijus> (Foo -> Reader Interp a)
05:29:07 <autrijus> is just a thin disguise of:
05:29:10 <autrijus> Interp -> Foo -> a
05:29:24 <autrijus> er
05:29:29 <Heffalump> why do you have the params that way round?
05:29:29 <autrijus> right.
05:29:37 <nothingmuch> yes
05:29:44 <nothingmuch> i can see the bits
05:29:56 <nothingmuch> but i'm still not able to put the big picture together
05:29:59 <Heffalump> autrijus: can you remind me of the URL for your perl embedding again?
05:30:03 <autrijus> Heffalump: it's easier to explain "local" that way by composing (Interp -> Interp)
05:30:31 <autrijus> Heffalump: http://svn.openfoundry.org/pugs/src/perl5/
05:30:31 <autrijus> http://svn.openfoundry.org/pugs/src/Pugs/Embed/Perl5.hs
05:30:34 <autrijus> http://svn.openfoundry.org/pugs/src/Pugs/Run/Perl5.hs
05:31:39 <Heffalump> do you have a way to handle integrating the GCs?
05:32:22 <autrijus> Heffalump: yes. each pugs obj has
05:32:23 <autrijus> liftIO $ addFinalizer obj (objectFinalizer env obj)
05:32:25 <autrijus> around them
05:32:50 <autrijus> and if it is a Sv, you can call the underlying
05:32:51 <autrijus> SvREFCNT_dec(sv)
05:33:03 * earthy just learned a perl5-ism that is extremely, utterly gallingly ugly
05:33:05 <Heffalump> how do you handle giving that a PerlInterpreter?
05:33:19 <autrijus> Heffalump: I assume a single global PerlInterpreter.
05:33:22 <Heffalump> also, how do you handle the issue of the sometimes-implicit my_perl parameter?
05:33:23 <Heffalump> ah, ok.
05:33:32 <autrijus> because MULTIPLICITY is not default on *nix anyway.
05:33:41 <Heffalump> it seems to be in Debian
05:33:50 <autrijus> oh. not in fbsd.
05:34:06 <autrijus> with multiplicity you need to curry the finaliser
05:34:09 <autrijus> with the interp
05:34:12 <Heffalump> it's worse than that
05:34:13 <autrijus> on creation
05:34:20 <Heffalump> cos you're not supposed to have finalizers be Haskell-implemented
05:34:52 <Heffalump> (I'm still a little confused about what precisely the restriction the standard imposes is)
05:36:05 <Heffalump> where do you free the return array allocated by perl5_apply?
05:37:13 <autrijus> you mean Safefree the Newz?
05:37:17 <autrijus> it currently leaks.
05:37:19 <Heffalump> yes
05:37:20 <Heffalump> ah.
05:37:25 <autrijus> I havn't thunk of how to deal with that.
05:37:29 <autrijus> couldn't see an obvious way
05:37:36 <Heffalump> I ended up exporting the Haskell malloc back to a C function
05:37:44 <autrijus> that is a way.
05:37:52 <Heffalump> but I guess Haskell could equally free the Perl array.
05:38:20 <autrijus> indeed.
05:38:29 <autrijus> earthy: what's that p5ism?
05:38:41 <Heffalump> hmm, so without MULTIPLICITY, the signatures of the functions will actually be different, right?
05:38:58 * Heffalump wonders how pugs builds on Debian, if so.
05:40:20 <autrijus> pugs does build on debian.
05:41:02 <Heffalump> does that embedding get built by default?
05:41:10 <autrijus> not unless you pass PUGS_EMBED=perl5 to it.
05:41:53 <autrijus> ("it" being the "perl Makefile.PL")
05:42:03 <Heffalump> oh, actually, you're not using pTHX_ in the functions that get foreign imported
05:42:15 <autrijus> indeed
05:42:20 <Heffalump> and since you have a single global my_perl, it ought to work in either case.
05:42:39 <autrijus> because under multiplicitity, it's just still using the single my_perl.
05:42:59 <Heffalump> grmph. I'm trying to make my embedding general, but it seems I can't do both that and make it work with and without MULTIPLICITY.
05:43:17 <autrijus> you can do that by maintaining the equiv of what xs does
05:43:18 <Heffalump> I guess I could play some game if MULTIPLICITY isn't defined.
05:43:29 <Heffalump> how?
05:43:37 <autrijus> namely having a dummy perlinterp
05:43:44 <autrijus> that always points to my_perl
05:43:52 <autrijus> in the non-multiplicity case.
05:43:53 <Heffalump> as a global?
05:43:56 <autrijus> right
05:44:12 <Heffalump> yeah, but function prototypes defined with pTHX or pTHX_ will be wrong
05:45:22 <autrijus> indeed, but you don't need to use them in your FFI funs.
05:45:30 <autrijus> you need to do your own #ifdef layer
05:46:05 <Heffalump> is a potential extra parameter of type PerlInterpreter and name my_perl part of the published API?
05:46:17 * Heffalump has been trying to stick to things I can find in man perlapi or perlcall or perlxs
05:46:38 <autrijus> yes. sort of.
05:46:43 <autrijus> read perlembed instead
05:46:48 <Heffalump> oh, and that
05:47:25 <Heffalump> that never explicitly states that my_perl is a distinguished name
05:47:29 <CosmicRay> Heffalump: why are you trying to embed perl with haskell?
05:47:33 <Heffalump> it just uses it for all its examples.
05:47:37 <Heffalump> CosmicRay: masochism
05:47:46 <CosmicRay> Heffalump: at least you're honest about it :-)
05:47:55 <Heffalump> (and I want to move some CGI/mod_perl code I have over to Haskell, and this offers a migration route)
05:48:00 <CosmicRay> Heffalump: fwiw, python is already embedded with haskell, so if what you need can be done that way, it may be easier.
05:48:01 <Heffalump> and it's quite fun, in a twisted sort of way
05:48:02 <autrijus> Heffalump: ok. read perl.h
05:48:03 <CosmicRay> scary.
05:48:27 <autrijus> Heffalump: namely PERL_IMPLICIT_CONTEXT
05:48:42 <autrijus> my_perl is used throughout
05:48:47 <Heffalump> I know about that, but is it supposed to be a stable API?
05:49:02 <Heffalump> or is it just one of these things that I can reasonably assume is, even though it's not published as such.
05:49:32 <autrijus> I think it's a doc bug that it's not published as such.
05:49:44 <autrijus> all perl embedding modules on CPAN relies on that
05:49:52 <autrijus> so chance of that changing during 5.x is effectively zero
05:49:59 <autrijus> (as far as I know)
05:50:03 <Heffalump> 'k
05:50:30 <autrijus> perl5 culture is not big on this spec thing. sigh.
05:51:40 <Heffalump> and the whole stack manipulation/ref counts/mortality thing is terribly documented
05:52:05 <Heffalump> (I think I got a bit of sense on that subject out of someone else I know who understands this stuff)
05:52:23 <autrijus> to be fair there's a book
05:52:30 <autrijus> both online and in dead tree
05:52:38 <autrijus> called EaEP (Embedding and Extending Perl)
05:52:42 <autrijus> that documents this very thoroughly
05:52:52 <autrijus> it's not free and not Free though.
05:53:28 <autrijus> I'd send you my copy but I lost the .pdf file
05:53:31 <Heffalump> I was concluding I'd need to get it.
05:53:40 <Heffalump> Is that Simon Cozens + Tim Jenness (sp?) ?
05:53:43 <autrijus> yes.
05:53:50 <autrijus> sadly I think your conclusion is correct.
05:54:06 * Heffalump doesn't have a lot of faith in Simon, either :-)
05:54:14 <autrijus> the book is fine :)
05:54:28 <autrijus> you can trust it more than you trust simon :)
05:55:00 <nothingmuch> what's wrong with simon?
05:56:31 <Heffalump> nothingmuch: take a look at Mail::Audit some time :-)
05:57:07 <nothingmuch> sure, but he has a million other modules too
05:57:09 <autrijus> nothingmuch: he like to start modules more than completing them.
05:57:18 <autrijus> in this sense he is like me :)
05:57:51 <autrijus> also, he was reputed to be mean to people when he consider said people to be idiots.
05:57:58 <autrijus> that's the extent of what I know about.
05:58:15 <nothingmuch> i have been warnocked by him once, but that's all I really know
05:58:31 <Rearden> he kicks his dog
05:59:29 <Rearden> and he drives 55 in the passing lane
06:01:22 <nothingmuch> now that is pure evil
06:02:00 <nothingmuch> slow drivers in fast lanes ought to have their car stolen, it's meters rewired, and the car returned unnoticed to it's garage
06:02:10 <Rearden> bwahaha
06:03:23 <nothingmuch> how much is 55 in kmh?
06:03:29 <Rearden> around 88
06:03:33 <Rearden> I think
06:03:36 <nothingmuch> oi
06:03:36 <neologism> *1.6
06:03:51 <reffie> yo neologism :P
06:04:00 <neologism> reffie: you're everywhere ;)
06:04:15 <reffie> yeah :(
06:04:19 <earthy> um
06:04:27 <xerox> :-)
06:04:27 <reffie> neologism did you read my newest blog entry?
06:04:28 <nothingmuch> @plugs 55 * 1.6
06:04:29 <lambdabot> 88.0
06:04:30 <earthy> isn't there something, like, a speed limit? :)
06:04:39 <neologism> reffie: I dont read your blog
06:04:39 <reffie> neologism http://kernelplanet.org/
06:04:43 <reffie> neologism wtf
06:04:47 <reffie> neologism you should.
06:04:50 <neologism> why?
06:04:55 <reffie> neologism because it's great.
06:04:59 <nothingmuch> @plugs 130 / 1.6
06:05:00 <lambdabot> 81.25
06:05:09 <reffie> http://segfaulted.com/blog/
06:05:12 <nothingmuch> i think that's my minimum passing speed
06:05:12 <earthy> nothingmuch: that's germany
06:05:17 <neologism> reffie: you are soooo humle
06:05:22 <nothingmuch> no, most of europe is that way
06:05:26 <reffie> neologism muhahahah
06:05:41 <reffie> neologism i'm a narcissist :(
06:05:43 <Rearden> @plugs 130 * 1.6
06:05:45 <lambdabot> 208.0
06:05:45 <earthy> um. most of europe apart from those areas that are too-well stocked on speedtraps. ;)
06:05:47 <Rearden> That's mine :)
06:05:54 <nothingmuch> oh my =)
06:06:13 <earthy> 130mph. that's like... fast.
06:06:19 <Rearden> kidding of course
06:06:22 <Rearden> my tires would explode
06:06:34 <earthy> well, I did that a couple of times
06:06:41 <neologism> reffie: it really is ;)
06:06:45 <earthy> driving to Hannover with the express orders to 'make good time'
06:06:58 <reffie> neologism what is?
06:06:59 <xerox> neologism, you really think? ;-)
06:07:01 <earthy> 'if you're doing below 180kph, you're going to slow'
06:07:04 <nothingmuch> earthy: in austria italy and germany i think it's pretty standard to drive 140-150
06:07:11 <Rearden> 130 mph can make pretty good time
06:07:17 <earthy> and I was like 'yes boss'
06:07:21 * neologism shrugs and smiles the strange way ;)
06:07:52 * nothingmuch tries to keep below 120 even though it doesn't feel "natural" due to fuel efficiency
06:08:07 <nothingmuch> (kph)
06:09:57 <Itkovian> I think I comsume least when driving about 120 kph
06:10:06 <Itkovian> more isn't allowed anyway in Belgium
06:11:00 <earthy> most cars on the road these days do optimum fuel economy at 90kph IIRC
06:11:31 <Itkovian> that'sslow on the highway ... even rtrucks will passyou by
06:12:05 * earthy knows
06:12:17 * earthy does 120 and No Slower. unless the speed limit says so. :)
06:12:54 <earthy> ofcourse, with our current car, there's some drift towards higher speeds... going downhill with 1400kg of steel you *do* notice gravity at work... :)
06:15:08 * Itkovian never crosses the speedlimit ... if I need to be somewhere fast, I leave early or have my wife drive :-)
06:16:59 <TheHunter> seriously?
06:17:38 <TheHunter> the speed limits already assume that you're driving 10 or 20 km/h faster.
06:18:16 <earthy> um. not in .nl they don't
06:18:38 <Itkovian> TheHunter: not here they don't (anymore). The only error allowed is the tech error, so they really will flash at speeds higher than say 123 kph
06:18:51 <Itkovian> and its bloody costly
06:18:57 <earthy> they are enforced with about 4 or 5 km/h 'measuring inaccuracy' granted
06:19:31 <TheHunter> plus something like 5-10% your speedo shows too much.
06:19:52 <Itkovian> nah, mine is pretty accurate last time I checked
06:20:38 <tromp> there are no speed limits where i bike:)
06:20:45 <Itkovian> besides, 120 is fast enough
06:21:06 <earthy> thehunter; even that depends on the car. I've been in cars where the spedometer actually showed a speed *lower* than the one we were travelling at
06:21:17 <Itkovian> I really enjoy passing two trucks on the left side, at 120, and slowing down the dude who's at 180 behind me.
06:21:21 <earthy> tromp: there are though.
06:21:27 <earthy> they're not enforced for cyclists. :)
06:21:47 <earthy> itkovian: the bmw, you mean. :)
06:22:05 <TheHunter> i'm not really sure, but i always assumed there was a law here that required speedos to show too much.
06:22:07 <Itkovian> last time cyclists came through my home city, they forgot to remove the camera, and it put the entire race on picture :-)
06:22:34 <TheHunter> 120 on the highway?
06:22:40 <mflux_> thehunter, I think it's because you can have different kinds of wheels
06:22:48 <mflux_> thehunter, and they are tuned to never show too little
06:22:52 <Itkovian> TheHunter: perhaps, but mine is definitely as accurate as the boards where they show yr speed when you drive by. unless they also count an extra 10% to keep foiols like me ignorant
06:23:06 <TheHunter> mflux_, yeah, that sounds reasonable.
06:23:18 <Itkovian> TheHunter: no 50 in the city
06:23:30 <mflux_> get a gps, that'll tell the speed ;)
06:23:46 <Itkovian> hmm
06:23:57 <Itkovian> unless the americans decide to fiddle with the sats again
06:24:01 <TheHunter> these boards show almost 10km/h more than the speedo on average city speed.
06:24:25 <mflux_> well speed would be very difficult to fake without giving really wrong results otherwise (and you would propably not be anymore on the road bper the map anymore ;))
06:24:28 <Itkovian> then i would be off by more like 20-25 %, which seems too much
06:27:20 <mflux_> btw, does the expression in the parenthesis make sense (with bper->per)? I've picked it from somewhere and I keep on using it ;)
06:37:31 <lispy> heh, i should fix my daily cron job so that it stops sending me email...
06:38:05 <lispy> "Hi, it's just me cron again.  Want'd to let you know, that I ran again and same results as yesterady.  Well. Have fun..."
06:42:10 * lispy wishes it was 7 hours ago
06:42:34 * lispy with the same amount of work done that he has done now
06:42:43 <lispy> then i could be sleeping!
07:05:04 <CosmicRay> if someone that understand the ghc package system better than I, I'd appreciate some help getting wash going with ghc 6.4
07:16:24 <Lemmih> CosmicRay: Wash is currectly using a Makefile based build system, right?
08:30:18 <xerox> @pl \f x y -> x >>= \x' -> y >>= \y' -> f x y
08:30:19 <lambdabot> liftM2 (.) (>>=) . (((const .) . ap (>>=) . (const .)) .)
08:30:25 <xerox> @pl \f x y -> x >>= \x' -> y >>= \y' -> f x' y'
08:30:26 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=))
08:30:37 <lispy> oh god
08:30:42 <lispy> that's terrible ;)
08:30:45 <xerox> Is this kind of computation defined somewhere?
08:31:10 <lispy> @type flip ((.) . (>>=)) . flip ((.) . (>>=))
08:31:15 <xerox> @plugs [True,False] >>= \x -> [True,False] >>= \y -> return [x,y]
08:31:26 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=)) :: forall a
08:31:26 <lambdabot>                  (m :: * -> *)
08:31:26 <lambdabot>                  a1
08:31:26 <lambdabot>                  b.
08:31:26 <lambdabot>                (Monad m) =>
08:31:27 <lambdabot>                (a -> a1 -> m b) -> m a -> m a1 -> m b
08:31:41 <lambdabot> [[True,True],[True,False],[False,True],[False,False]]
08:32:03 <lispy> so it does permutations?
08:32:13 <lispy> er combinations maybe
08:32:58 <lispy> @plugs [1..3] >>= \x -> [1..3] >>= \y ->return [x,y]
08:33:04 <lambdabot> [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
08:34:39 <dcoutts> dons, I think I've fixed part of the build problem we were looking at the other day. The -L/usr/local/lib emitted by pkg-config should make it's way into the .cabal file. So that still leaves the -pthread issue and the version string munging problem. If you've had any progress with either of those I'm eager to commit fixes before releasing the first release candiate.
08:37:09 <xerox> @pl \x y -> [x,y]
08:37:09 <xerox> zZzZ
08:37:09 <lambdabot> (. (: [])) . (:)
08:37:50 <Igloo> I don't know what your pthread issue is, but if it's the normal then if you work out what exactly is the right and portable way to adopt the solution in http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=294481 then that might fix it
08:38:35 <dcoutts> Igloo, actually we already work around that one on Linux, this was something else on OpenBSD
08:38:45 <Igloo> Ah, OK
08:39:07 <xerox> lispy, what do you think about f g x = { do x' <- x; y' <- x; return $ g x' y'} ?
08:39:42 <dcoutts> something to do with the order on the sommand line of the -pthread from extra-ld-opts and the other -l flags in the ghc/gcc link phase
08:39:52 <lispy> xerox: i wouldn't take it on a date
08:40:05 <dcoutts> we've still not quite narrowed it down
08:40:09 <lispy> xerox: what does it do?
08:40:59 <xerox> @plugs let f g x = {do x' <- x; y' <- x; return $ g x' y'} in f (\x y -> [x,y]) [1..3]
08:41:00 <lambdabot> parse error on input `{'
08:41:08 <xerox> @plugs let f g x = do {x' <- x; y' <- x; return $ g x' y'} in f (\x y -> [x,y]) [1..3]
08:41:09 <lambdabot> [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
08:44:38 <AtnNn> how does that work?
08:44:53 <lispy> magic
08:46:39 <arjanb> it's not magic if you read it as if it's a list comprehension
08:47:17 <lispy> NO!!!!!!1111, MAGIC! i say, MAGIC! ;)
08:47:26 <xerox> Oh, that was the sugar I was searching for!!  Silly me :-)
08:47:48 <xerox> "HRM.. I think I *saw* that kind of computations before... SOMEWHERE... HRM" :-)
08:48:21 <lispy> i still likes my little surprise example
08:48:35 <lispy> @plugs ((: "a little surprise.") =<<) "Oh, look! "
08:48:36 <lambdabot> "Oa little surprise.ha little surprise.,a little surprise. a little
08:48:36 <lambdabot> surprise.la little surprise.oa little surprise.oa little surprise.ka
08:48:36 <lambdabot> little surprise.!a little surprise. a little surprise."
08:50:14 <AtnNn> how is that list comprehension?
08:51:12 <xerox> AtnNn, indeed.
08:51:29 <lispy> the list monad is a funny thing
08:51:57 <lispy> try implementing it with out using any of the built in stuff
08:52:07 <lispy> then it makes a lot more sense
08:52:23 <lispy> and heed the monad laws
08:57:09 <AtnNn> oh, so (x:xs) >>= f = (f x):(xs>>=f) -- ?
08:58:36 <xerox> @index >>=
08:58:37 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
08:58:37 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
08:58:37 <lambdabot> Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:58:53 <xerox> @libsrc Control.Monad.List
08:58:53 <lambdabot> http://darcs.complete.org/fptools/libraries/mtl/Control/Monad/List.hs
08:59:19 <lispy> darcs.complete.org?
08:59:39 <xerox> AtnNn, you can find its definition at that url.
09:00:24 <AtnNn> yes, thanks, i have
09:04:34 <lispy> Biker: he
09:04:36 <lispy> er hey
09:04:43 <Biker> lispy:hi
09:04:59 <lispy> Biker: is A runnig around the lab asknig you for papers?
09:05:12 <lispy> Biker: our thingy is due today...
09:05:17 <Biker> lispy: He did send out a broadcast to the grad list :-)
09:05:26 <Biker> no wonder he's working on it
09:05:34 <lispy> i still haven't finished mine...waiting on my program to terminate so i can get the runtime stuf
09:05:37 <Biker> how's your stuff going?
09:05:44 <Biker> ok
09:05:51 <lispy> i mostly have the paper finished
09:05:54 <lispy> it's been a nightmare
09:06:03 <lispy> i've worked on it non-stop since friday
09:06:08 <Biker> well atleast you have a nice paper.
09:06:22 <Biker> I think you'll be fine...
09:06:52 <Biker> I ran into A in the corridor on my way in and he seemed a little "hassled" - maybe hoping I'll do his stuff for him ;)
09:07:01 <lispy> heh
09:07:27 <lispy> i wish i had more references, but there really isn't that much to work off of
09:07:32 <lispy> mostly ham. path stuff in my refs
09:08:04 <Biker> C just wants to see you have put in honest effort.
09:08:13 <lispy> what do you alphabetize by in your biblo?
09:08:26 <Biker> last name, first author...
09:08:29 <lispy> Biker: heh, with how crappy my paper is he may not be able too ;)
09:08:36 <lispy> thanks
09:08:46 <Biker> I think that is default in bibtex?
09:08:57 <lispy> i'm not using it this time tho
09:09:04 <Biker> ok...
09:09:06 <lispy> i'm using \begin{thebiblio...}
09:09:17 <Biker> yep... more work :)
09:09:22 * SyntaxNinja curses bibtex
09:09:32 <lispy> i'll never use these refs again tho
09:09:39 <lispy> Biker: oh, check this out
09:09:41 <Biker> why SyntaxNinja?
09:10:02 <lispy> @plugs ((: []) =<<) "it's the identity on lists "
09:10:04 <lambdabot> "it's the identity on lists "
09:10:10 <Biker> true... but you can have a bib file for stuff you read... or one for your courses and this stuff could be in that one
09:10:23 <lispy> @plugs ((: "not anymore") =<<) "123"
09:10:25 <lambdabot> "1not anymore2not anymore3not anymore"
09:14:55 <Muad_Dibber> @type intersect
09:15:01 <lambdabot> bzzt
09:15:09 <xerox> @plugs (>>= (: [])) "borrow us some new code please"
09:15:11 <lambdabot> "borrow us some new code please"
09:15:11 <Muad_Dibber> @type Data.List.intersect
09:15:12 <lambdabot> Data.List.intersect :: forall a. (Eq a) => [a] -> [a] -> [a]
09:15:18 <SyntaxNinja> Biker: how many times do I have to call latex;bibtex;latex for things to settle down? :)
09:15:29 <xerox> @type Data.List.intersperse
09:15:31 <lambdabot> Data.List.intersperse :: forall a. a -> [a] -> [a]
09:15:43 <lispy> SyntaxNinja: till they stop changing ;)
09:15:46 <SyntaxNinja> btw, is there a way to make latex give errors instead of warnings for missing citations or anything?
09:16:00 <xerox> @pl \xs -> (>>= (: xs))
09:16:01 <lambdabot> (=<<) . flip (:)
09:16:05 <Biker> SyntaxNinja: You could have a small script does all the multiple calls for you. But I see your point :-) What alternative do you recommend?
09:16:28 <xerox> @type (=<<) . flip (:)
09:16:29 <lambdabot> (=<<) . flip (:) :: forall a. [a] -> [a] -> [a]
09:16:34 <SyntaxNinja> Biker: no idea, really.  I use docbook sometimes, but latex formatting ends up looking better, IMO.
09:16:49 <SyntaxNinja> I wonder if latex is so crufty because it's distributed under an inconvinient license?
09:16:50 <wagle> @pl flip flop
09:16:50 <Igloo> rubber will show you just the warnings you want without all the gunk, I think
09:16:51 <lambdabot> flip flop
09:17:03 <SyntaxNinja> Igloo: hm. i'll have to check that out.
09:17:06 <Muad_Dibber> @plugs  concat $ Data.List.intersperse " NO! " $ words "Do you like C++?"
09:17:07 <lambdabot> "Do NO! you NO! like NO! C++?"
09:17:20 <Biker> SyntaxNinja: Exactly why I use Latex. If I had to do the formatting myself in something like Word (God forbid) I would never get anything done :-)
09:17:32 * SyntaxNinja nods
09:19:34 <xerox> http://stevenf.com/mt/archives/2005/06/apple_to_switch.php # Apple To Switch To Sun Chips
09:20:48 <wagle> i hearwd they were swiching to corn chips
09:21:36 <wagle> ugh..
09:22:02 * wagle writes note to self, read url first, followup second
09:22:39 <wagle> its just that i've waded through a half dozen urls from everyone talking about apples switch
09:23:00 <lispy> wagle: yeah
09:23:05 <lispy> true dat.
10:07:31 * boegel waves
10:07:53 * genneth waves back and hurries off to watch smallville
10:08:24 * boegel thinks smallville is crap
10:08:40 <genneth> genneth agrees, but it's easier on the brain and eyes than type inference
10:09:15 <boegel> @seen shapr
10:09:16 <lambdabot> I saw shapr leaving #haskell 5 hours, 3 minutes and 38 seconds ago.
10:10:20 <Muad_Dibber> anyone knows a graphical version for "diff" ?
10:10:59 <SyntaxNinja> Muad_Dibber: emacs does OK
10:11:55 * Muad_Dibber doesnt do ok with emacs though
10:12:53 <ndm> Muad_Dibber: http://www.prestosoft.com/ps.asp?page=edp_examdiff
10:13:17 <ndm> Muad_Dibber: Windows only, but very good - especially the Pro version
10:14:00 <lispy> Muad_Dibber: diff foo bar | less ;)
10:14:15 <lispy> actually i find diff -u more readable than just plain diff
10:14:57 <SyntaxNinja> M-x diff!!
10:15:11 <Muad_Dibber> lispy : diff | less is quite okay, untill it's about file wiht length 1000 where a "single blcok" that differs is about 100 lines
10:15:20 <Muad_Dibber> it the ndoenst fit on your terminal screen, and i'd like to scroll around :)
10:16:54 <lispy> ah, less can move around
10:16:57 <lispy> with the arrow keys
10:17:16 <lispy> but maybe not the way you need/want
10:18:45 <SyntaxNinja> tkdiff - graphical side by side "diff" utility
10:18:45 <SyntaxNinja> meld - graphical tool to diff and merge files
10:18:45 <SyntaxNinja> xxdiff - a graphical file and directories comparison and merge tool
10:18:45 <SyntaxNinja> kompare - a KDE GUI for viewing differences between files
10:18:45 <SyntaxNinja> easydiff.app - Graphical diff for GNUstep
10:21:10 <raver> hi everyone
10:27:19 <_JusSx_> hi
10:48:11 <CosmicRay> Could -O2 cause ghc to use lots more memory than when run without -O at all?
10:51:57 <Philippa> um, at a guess I'd say possibly
10:52:14 <Philippa> why?
10:53:00 <CosmicRay> because GHC runs out of memory compiling WASH with my cabalization, and the only reason I can see is -O2
10:53:44 <Philippa> does it work okay with -O?
10:53:54 <CosmicRay> I'll try that next
10:53:57 <Philippa> intermodule optimisation can produce a lot of data
10:54:03 <CosmicRay> wash's generic make doesn't use and -O at all
10:54:05 <Philippa> ISTR jhc using silly amounts of heap
10:55:23 * mikael takes the opportunity to notify #haskell that Apple is in fact moving to x86
10:55:41 <xerox> Yeah.
10:55:51 * CosmicRay is tired of that topic, and I hadn't even heard the announcement for sure
10:56:11 <CosmicRay> but thanks anyway, mikael :-)
10:56:17 <mikael> there's an unwritten WWDC rule that states every irc channel must be about it
10:56:42 <CosmicRay> personally, I think that Apple machines are nice, but Apple itself is just as evil as M$
10:56:54 <CosmicRay> they don't get the chance to pull off much evilness though because they're smaller
11:01:56 <jlouis> They have to move. CPU architectures are being killed every day
11:02:12 <jlouis> PPC, UltraSparc are next in line
11:03:21 <xerox> What's fun is that they were compiling OS X for intels from years, eheh.
11:03:24 <wilx> Hmm.
11:03:34 <reffie> xerox how is that surprising?
11:03:40 <reffie> xerox darwin works fine on x86
11:03:47 <xerox> You're right.
11:03:54 <wilx> Power architecture seems to me like the most viable after Intel.
11:04:11 <xs> less ideals, more economics. lovely.
11:04:56 <tuomov> hmm.. no more reason to buy a mac.
11:05:44 <wilx> Did they explain why do they do it?
11:06:17 <jlouis> I've heard: Lack of G5 with effective power consumption in laptops, too few chips produced
11:06:19 <tuomov> not using x86 was the only thing that might have persuaded me to bue one... I don't fancy the looks and they're expensive
11:07:12 <xerox> More common processors... less high prices?
11:07:15 <tuomov> (runnin linux or *bsd of course)
11:08:29 <SyntaxNinja> whoa... slashdot is slashdotted
11:09:08 <CosmicRay> y0 syntax.
11:09:19 <wilx> Hmm, see. Sounds like reasonable reasons :)
11:09:19 <CosmicRay> SyntaxNinja: I am just now testing my cabalization of wash.
11:09:28 <CosmicRay> SyntaxNinja: I have had to combine it all into one big package named "WASH"
11:09:41 <CosmicRay> SyntaxNinja: wishlist: cabal to support multiple libraries from a single source tree, and deps between them :-)
11:10:25 <CosmicRay> SyntaxNinja: also there seems to be no way to specify args for GHC to use in its packaging system, as distinct frmo args to use a build time
11:10:39 <Igloo> As long as the deps only go one way there shouldn't be a problem in making it multiple cabal packages, surely?
11:10:52 <CosmicRay> Igloo: there are several
11:11:10 <CosmicRay> Igloo: first, the existing Cabal system only supports one library per .cabal file, and one .cabal file at a time
11:11:36 <CosmicRay> Igloo: so the routine would have to be "build lib 1, install lib 1, build lib 2, install lib 2, build lib n..."
11:11:42 <CosmicRay> problem is, install often requires root
11:11:54 <CosmicRay> and cabal provides no easy way to use packages that are not yet installed
11:12:25 <Lemmih> What about installing the packages locally?
11:12:38 <CosmicRay> requires root
11:12:43 <Lemmih> No.
11:12:50 <Igloo> Hmm, putting the files in their final place does, though
11:12:59 <Igloo> So for building Debian packages, say, that wouldn't work
11:13:20 <CosmicRay> Igloo: or for any situation where people don't want to build as root
11:13:44 <Igloo> If you just want a local install then there is no problem
11:13:53 <Igloo> You just do everything with --user and it'll work out fine
11:13:57 <CosmicRay> even then there is, ghc-pkg screws with files in ~
11:14:17 <Igloo> But it has to do that anyway
11:14:29 <CosmicRay> I consider it evil for a command akin to "make" to mess with any file outside $PWD
11:14:39 <CosmicRay> not with cabal as it is today
11:14:53 <CosmicRay> it's a RC bug in debian if it screws with files in ~ as part of the build process
11:15:31 <Igloo> If you can't specify where the user package.conf is then I'd say that's a cabal bug
11:18:30 <dcoutts> It's similar in Gentoo, you'll get sandbox error if you write to any file outside of the build tree.
11:35:48 <genneth> @help
11:35:49 <lambdabot>  @help <command> - ask for help for <command>
11:35:55 <genneth> @list
11:35:57 <lambdabot> Maybe you meant: listchans listcommands listmodules dict
11:36:01 <genneth> @listcommands
11:36:02 <lambdabot> all-dicts arr babel define definitions devils dice dict dict-help
11:36:02 <lambdabot> docs dummy easton echo elements eurohaskell eval fact fact-cons fact-
11:36:02 <lambdabot> delete fact-set fact-snoc fact-update foldoc fortune gazetteer get-
11:36:02 <lambdabot> definition ghc google help hitchcock index jargon karma karma+ karma-
11:36:02 <lambdabot> kind learn libsrc listchans listcommands listmodules lojban moo more
11:36:03 <lambdabot> paste pl pl-resume plugs pointless prelude quote remember resume
11:36:05 <lambdabot> seen source spell state timein todo todo-add topic-cons topic-init
11:36:08 <lambdabot> topic-snoc topic-tail topic-tell type uptime vera version vixen
11:36:09 <lambdabot> web1913 wiki wikipedia wn world02 yow
11:49:30 <turok> hello
11:50:08 <turok> is there a  way to define a function that takes a n-tupel and returns the nth element?
11:50:40 <jynxzero> Tricky... what would the type be?
11:50:51 <jynxzero> Could probably do something with a typeclass though.
11:51:18 <turok> hm
11:51:26 <ndm> i doubt you could type class it
11:51:28 <genneth> turok: maybe a tuple isn't the data type you want?
11:51:33 <ndm> if n is an integer
11:52:02 <turok> we're working on a task where we got an 3-tuple and have to extract data from it
11:52:04 <jynxzero> ndm: your right I was being stupid.
11:52:04 <ndm> you could define tuple1, tuple2, tuple3 etc.
11:52:19 <ndm> i have a general.hs library
11:52:33 <araujo> Hello.
11:52:38 <ndm> and various of the functions are fst3, snd3 and thd3 - which do that
11:52:45 <turok> and it sounds like work i dont really want to do to write a fst/snd /thrd func for all types of tupels :)
11:52:52 <wilx> Hm.
11:53:16 <wilx> This is imho possible with Template Haskell.
11:53:27 * genneth runs away gibbering
11:53:48 <genneth> turok: but if you're allowed to stray off haskell 98, I guess that would be a perfectly good solution
11:54:03 <turok> oh, think we're forced to use h98 ;)
11:54:25 <wilx> Then imho the only way is to use type classes.
11:54:58 <turok> hm, sounds like its just soo much easier to just write an explicit function for 3-tuples that we'll just do that
11:55:29 <genneth> if you only have to deal w/ a certain 3-tuple
11:55:33 <genneth> that would be the way to go
11:55:48 <genneth> or in fact a parameterized 3-tuple would be just as easy
11:56:01 <ndm> fst3 (a,_,_) = a
11:56:55 <SyntaxNinja> CosmicRay: I agree that we need that. it shouldn't be too hard, just use .ghc-pkgs instead of ~/.ghc-pkgs.
11:57:00 <SyntaxNinja> CosmicRay: it's high oh the todo list
11:57:13 <turok> yeah, guess we'll do just that.. thanks anyways :)
11:59:01 * SyntaxNinja lunch &
12:07:52 <CosmicRay> SyntaxNinja: nice
12:09:21 <basti_> re
12:14:18 * CosmicRay announces his cabalized WASH
12:14:50 <cptchaos> is someone here familar with template haskell?
12:15:34 <basti_> a little
12:16:20 <cptchaos> the doc of ghc-6.4 says that a splice $(..) may occur in place of a type
12:16:31 <cptchaos> and I want something like:
12:16:44 <cptchaos> test :: ($(d 1))
12:17:16 <cptchaos> but that does give a parse error
12:17:25 <cptchaos> d computes a type
12:53:26 * CosmicRay builds wash for debian
12:53:38 * basti_ washes builds for debian
12:53:49 <CosmicRay> heh
12:55:34 * ibid debians washes for builds
12:55:49 <ibid> sorry, the correct form should be:
12:55:51 * ibid debians washes for build
12:56:29 <ibid> too high from waiting for sarge, sorry :)
12:56:33 <CosmicRay> heh
12:57:58 <Itkovian> omfg ... damn apple to hell!
12:58:04 <Muad_Dibber> ?
12:58:06 <Itkovian> well, not that far, but still.
12:58:15 <Khisanth> didn't they damn themself to hell already? :)
12:58:17 <Itkovian> now that I've bought my shiny powerPC powerbook .
12:58:27 <Muad_Dibber> what did i miss?
12:58:31 <Itkovian> they decide to move to intel ... intel, can you believe it?
12:58:42 <Itkovian> x86 hell all over the place
12:58:46 <Muad_Dibber> bah
12:58:57 <Muad_Dibber> not even amd
12:59:11 <Itkovian> yeah ... that might've been less bad at least
12:59:23 <Muad_Dibber> the couldve put only amd64 in all their stuff :P
13:00:56 <Itkovian> it just sucks big time
13:01:16 <Itkovian> I'm certain the powerPC can deliver more ... if only big blue would do a better job
13:01:54 <stepcut> if apple could do a better job selling them, maybe IBM would be more interested in doing a better job :)
13:06:05 <Khisanth> you can get one of the new game consoles and figure out how to get it to run OSX :)
13:07:33 <cpage> Apple's PowerPC orders are probably going to be dwarfed by Sony's and Microsoft's, so IBM isn't going to be incented to deliver faster or lower-power CPUs for Apple.
13:08:07 <SyntaxNinja> Itkovian: writing a lot of assembly code?
13:09:03 <cpage> Intel, on the other hand, has lost the consoles and Apple is an attractive partner because of their success with iTunes and the certainty of a future where movies are also delivered digitally.
13:09:37 <cpage> Or maybe Apple is just insane. :-)
13:10:58 <cpage> It'll be a couple years before you can get a new machine, anyway, so enjoy your PowerBook.
13:13:00 * boegel doesn't give a damn about Apple switching to x86
13:13:34 <kzm> Good evening!  Does anybody know how to decipher STG code?
13:13:59 <boegel> what's STG code ? :)
13:14:19 <kzm> (It's the efficiency of Int64 issue I've been stumbling into on comp.lang.functional and glasgow-haskell.users@haskell.org)
13:14:28 <Itkovian> SyntaxNinja: no, I just think PowerPC is a way nicer architecture than x86, and certainly has a much nicer ISA
13:15:01 <SyntaxNinja> Itkovian: but at least GHC support for MacOS won't be a 2nd class citizen anymore :)
13:15:09 <kzm> A small benchmark shows Int to be really, really fast, Integer to be a lot slower, and Int64 to be quite a bit slower than that again.
13:15:36 <kzm> Surprised me a bit, and I tried to look at STG output, but found it just gives me a headache.
13:15:44 * kzm grins foolishly.
13:17:11 <kzm> (And if anybody know their way about the Linux kernel and ACPI in particular, I have another question over in #kernel :-)
13:17:57 <cpage> True, but if you're programming in Haskell, the ISA doesn't matter. :)
13:18:42 <kzm> cpage, it does if you ISA happens to be unsupported, doesn't it?
13:18:54 <Lunar^> Sarge is out!
13:18:56 <cpage> kzm: I don't follow you.
13:19:01 <Lunar^> SyntaxNinja: cheers!
13:19:54 <cpage> kzm: I'm saying that I'm a big fan of the PowerPC design, but if you're not programming in assembler, what does the ISA matter, really?
13:20:56 * boegel yawns
13:21:47 <kzm> cpage, just that you may have problems getting GHC to compile to ISAs like POWER4.
13:21:52 <SyntaxNinja> sarge?!
13:22:23 <kzm> cpage, I agree of course that any high-level language abstracts away the gory detail.
13:22:34 <cpage> kzm: Ah. Well, in this case the issue is going the other way, so I don't think that'll be a problem. :)
13:22:58 <SyntaxNinja> lrwxrwxrwx    1 1176     1176            5 Jun 06 18:33 stable -> sarge
13:22:58 <SyntaxNinja> lrwxrwxrwx    1 1176     1176            4 Jun 06 18:33 testing -> etch
13:22:59 <SyntaxNinja> heh
13:23:04 <kzm> I take it it's Jobs' announcement that is the topic of the day, eh.
13:23:24 <SyntaxNinja> kzm: it was, now it's not.
13:23:40 <cpage> In every conversation I'm having today, yes. But then, I've been a Mac programmer for eighteen years.
13:23:52 <ozone> cpage: it's all over most of the irc channels i'm on
13:23:56 <cpage> And I spend too much time hanging out with other Mac engineers.
13:24:13 <ozone> and i wouldn't call myself a huge mac groupie, even though i'm at WWDC :)
13:24:18 <kzm> Well - gotta run.  If anybody has any suggestions for STG primers, drop me a mail, or something.
13:24:29 <SyntaxNinja> kzm: you should post to a mailing list
13:25:09 <mikael> was Data.Map added to ghc very recently?
13:25:46 <Lunar^> GHC 6.4 yes
13:26:08 * SyntaxNinja high-fives debian folks
13:26:20 <SyntaxNinja> yo CosmicRay, Igloo, stepcut, Lunar^, Heffalump!
13:26:23 <SyntaxNinja> hwo else?
13:26:47 * boegel uses Fedora and also wants a high five from SyntaxNinja 
13:26:49 <basti_> ^5
13:26:56 * mikael _uses_ debian.  does that count?
13:26:57 <basti_> :P
13:27:23 <CosmicRay> :-)
13:27:26 <boegel> yo basti_
13:27:27 * basti_ wonders why his system always looks like HIS system, whatever distribution is installed.
13:27:27 <mikael> ah, ghc-cvs qualifies as ``very recent''
13:27:32 <boegel> told your gf yet ? :p
13:27:39 <lightstep> is sarge the new stable release?
13:27:42 <basti_> uhm no.
13:27:46 <basti_> is that going to be the running gag?
13:28:02 <mikael> lightstep: it will be soon, supposedly
13:28:39 * basti_ is on testing anyway.
13:28:39 * SyntaxNinja high-fives mikael
13:28:43 <mikael> yay!
13:28:56 <Lunar^> hi5! yay!
13:29:05 * basti_ though discovered that having no loopback interface is way more unstable than testing.
13:29:21 <SyntaxNinja> today is the day when a lot of people run "apt-get update" and everything breaks
13:29:23 <SyntaxNinja> hehe
13:29:34 <basti_> now do NOT ask how i lost my loopback network interface (temporarely), for i do not know the slightest.
13:29:51 <lightstep> why would it break on update?
13:30:03 <basti_> cos all packet management sucks.
13:30:07 <basti_> apt included.
13:30:15 <lightstep> let me try
13:30:20 <basti_> uh oh
13:30:30 <lightstep> actually, i can't: i'm on unstable
13:30:49 <basti_> it won't let you update?
13:30:54 <basti_> bizarre.
13:31:09 <lightstep> it won't let me update from stable 3.0 to stable 3.1
13:31:40 <basti_> oh
13:32:39 <SyntaxNinja> eh, it's not that package management sucks, it's that you always end up havng unexpected dependnecies on behavior in a system you've been using for years.
13:32:52 <SyntaxNinja> like, idono, a new apache might change stuff
13:33:00 <basti_> yes thats true.
13:33:17 <basti_> but that tells me that there's something fundamentally wrong with the way we handle this sort of information
13:33:30 <basti_> i'm not saying i have a better solution.
13:33:43 <Heffalump> CosmicRay: you there?
13:33:48 <lightstep> ect'll solve this (in theory)
13:34:02 <Heffalump> cosmicray: what namespace did you put your python embedding in?
13:34:25 <mikael> how do I decide whether to use a `type', a `data' or a `newtype'?  I can think of one deciding factor: whether one wants to define new class instances...
13:34:33 <basti_> whats ect?
13:34:48 <Heffalump> mikael: newtype is usually appropriate when you'd otherwise use type but want new class instances
13:34:53 <basti_> mikael: a "type" is like a macro on types
13:35:00 <Heffalump> data is appropriate when you want something more complicated than type
13:35:15 <SyntaxNinja> Heffalump: I also use newtype where I would want type, but for an abstract datatype
13:35:16 <basti_> its just one way of resolution, and this is done before anything happens
13:35:22 <Heffalump> SyntaxNinja: yes, fair enough.
13:35:40 <SyntaxNinja> mikael: between newtype and data, the question is if you have multiple constructors, I believe
13:35:47 <mikael> given newtype and type, is data technically ``necessary''?
13:36:02 <tuomov> data is necessary, the others are not
13:36:03 <basti_> yes, as a "data" type can have more than one constructor
13:36:07 <mikael> oh, duh, that completely escaped me
13:36:08 <wagle> data lets you have more than one constructor, newtype doesnt
13:36:24 * wagle loses typing speed contest
13:36:30 <Heffalump> and more than one argument to each constructor :-)
13:36:31 <basti_> -g-
13:36:39 <Heffalump> (with newtype, you have to use tuples, which are subtly different)
13:36:44 <basti_> yes right
13:37:09 <wagle> newtype constructors are tagless, data constructors are tagged
13:37:12 <mikael> is there a difference in `power' between multi-argument constructors and tuples?
13:37:28 <wagle> partial-application
13:37:49 <lightstep> basti_, http://www.haskell.org/tmrwiki/EternalCompatibilityInTheory
13:37:56 <mikael> good point
13:38:25 <lightstep> also, newtype doesn't have a bottom value
13:40:20 <pipe> here's an interesting quote: "A good long pee leaves me exhausted." -- Jason Mulgrew
13:40:22 <wagle> newtype doesnt exist at run-time
13:41:26 <boegel> @type fst
13:41:34 <lambdabot> fst :: forall a b. (a, b) -> a
13:41:48 <boegel> is there such a function for triples too ?
13:45:17 <lightstep> no, but i think it's definable with Data.Generics
13:45:31 <wagle> i think i heard that someone was generating them with template haskell
13:47:52 <basti_> lightstep: ah
13:52:06 <wagle> neato
13:54:14 <wagle> lightstep: i'm not seeing tuple manipulation yet
13:55:21 <lightstep> i can't do it; oleg can
13:57:17 <wagle> http://haskell.org/hawiki/FrequentlyAskedQuestions
13:57:27 <wagle> --> Is there a way to generalize over tuples of different arity?
13:57:36 <Itkovian> heh
13:57:39 <Itkovian> good question
13:57:54 <wagle> there's an answer there, sorta
13:57:57 <mikael> ``Qualified variable in pattern'' seems like a weird error
13:58:15 <mikael> I understand what it means, but...  why is it an error?
13:59:26 <Itkovian> night all
13:59:41 <boegel> night Itkovian
13:59:50 <wagle> cant you do something like type Foo = (fst5::Int, snd5::b, trd5::Char, frh5::Lemon, fth5::Tree a)?,
14:00:29 * wagle never uses record like things yet..  but hears about them
14:00:43 <lightstep> records use {} instead of ()
14:02:13 <boegel> wagle: you can, but then you have to redefine functions for each arity
14:03:19 <wagle> why anonymous tuples?
14:04:04 <wagle> lightstep: i said record _like_, though
14:04:13 <lightstep> why functional paradigm? why type classes? why turing machines? it's a matter of paradigm
14:04:21 <wagle> in the sense of "labeled fields"
14:04:37 <wagle> what functional paradigm?
14:04:40 <wagle> why
14:05:01 <wagle> i was asking for example
14:05:06 * basti_ objects anything thats called a paradigma ;)
14:05:24 <kzm> wagle: isn't it better (than the record) to simply define:  fst3 (x,_,_) = x; snd3 (_,y,_) = y; etc?
14:05:42 <wagle> kzm: less lines of program
14:05:51 <xerox> kzm, depends on what you call "better".
14:06:13 <kzm> wagle, but perhaps better yet to define a class Tuple t where fst t, snd t etc and instantiate for (,), (,,), ...
14:06:37 <kzm> xerox, better as in equally short and more general?
14:06:53 <wilx> *cough*TH*cough*
14:06:54 <xerox> ...or better as more tasty :-)
14:07:11 <kzm> wagle, well - fewer characters since you don't need to specify the types.
14:07:16 <wagle> i guess i'm leary of anonymous tuples and anonymous deconstructors..  (ala car, cadr, caadar, cdaadr, ...)
14:07:17 <jlouis> When considering such functions, readability should be in focus
14:07:33 <kzm> wilx, never got around to learn TH.
14:07:49 <wilx> Neither have I :)
14:07:56 <wilx> But still it sounds like the best thing for this.
14:07:57 <wagle> i look at code i didnt write (or wrote 5 years ago), and have no idea what it means
14:08:07 <jlouis> Whenever I hear the word ``macro'' I get red spots all over
14:08:27 <kzm> wilx, and generally I'm skeptical to use new and shiny features when the problem can be addressed using more standard stuff.
14:08:56 <wagle> even the generic stuff mentions template haskell
14:09:17 <kzm> what generic stuff?
14:09:35 <wilx> kzm. imho there is no other way to do this thing without limiting it to tupples of max. N elements.
14:09:42 <wagle> i'm see packages like generics using template haskell, but maybe i'm uneasy about programs using it directly
14:09:57 <kzm> wilx, that's true, of course.
14:10:07 <wagle> kzm: scrap your boilerplate!
14:10:07 <wagle> http://www.cs.vu.nl/boilerplate/
14:10:08 <wagle> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Generics.html
14:10:35 <kzm> Hmm...I could have sworn the boilerplate predated TH.
14:10:56 <wagle> "coevolution"
14:11:15 <wagle> rewriting
14:11:29 <kzm> I could be wrong, but I suspect the boilerplate has been upgraded.
14:11:51 <kzm> Is TH properly supported by NHC and Hugs?
14:11:58 <wagle> in the real world, nothing freezes for all eternity upon creation
14:12:15 <wagle> read the boilerplate faq
14:12:17 <wilx> kzm, nope. I don't think so.
14:12:19 <xerox> Except god=
14:12:23 <xerox> :P
14:12:27 <wilx> God is dead.
14:12:40 <kzm> Or, if not dead, then probably not created.
14:12:41 <xerox> For now, Nietzche is dead. (God says)
14:12:47 <wagle> the faq says no reason in principle that hugs cant support it, since it has rank-2
14:13:20 <basti_> :-o
14:13:44 <kzm> In the functional world, everything is frozen for all eternity upon creation.
14:13:59 <wagle> prezactly
14:14:06 <xerox> Even in a lazy functional world?
14:14:08 <genneth> StateT?
14:14:18 * genneth promises to stop nitpicking
14:14:21 <kzm> I take that to mean that Hugs doesn't support it, then?
14:14:22 <wagle> xerox: partial creation
14:14:35 <xerox> wagle, but deterministic, I see.
14:14:49 <kzm> In a lazy functional world, creation is delayed, that's all.
14:15:08 <wagle> kzm: ENOCLUE
14:15:25 <kzm> Well - it's late, time to hit the pillow.
14:15:54 <wilx> Btw, is there a guide to use of unsafe* functions?
14:16:03 <kzm> For homework, I promise to look at the mutable web page in question.
14:16:10 <wilx> Like, when it is safe to call unsafe* function etc.
14:16:11 <kzm> wilx, yes: don't
14:16:41 <wagle> "but daaaad!  everyone is doing it!"
14:17:16 <lightstep> are arrow operations properly rearranged (for speed) now that we have special syntax and rules?
14:17:30 <kzm> wilx, I'm not sure you get any real guarantees.  But as long as you don't depend on the sequence of execution or number of invocations, it should be relatively safe.
14:17:43 <kzm> Good night!
14:18:54 <xerox> Arrow (~>) => ... ?
14:19:05 <basti_> :-o
14:19:25 <basti_> yes?
14:19:26 <basti_> =)
14:19:39 <xerox> @type Control.Arrow.arr (+2)
14:19:44 <lambdabot> Control.Arrow.arr (+2) :: forall (a :: * -> * -> *) b.
14:19:44 <lambdabot>          (Control.Arrow.Arrow a, Num b) =>
14:19:44 <lambdabot>          a b b
14:19:54 <lightstep> Wobbly.~> or Kinds.~> ?
14:20:10 <xerox> @type Control.Arrow.arr (+2) :: (Control.Arrow.Arrow (~>), Num b) => b ~> b
14:20:11 <lambdabot> bzzt
14:20:15 <xerox> Hmm.
14:20:17 <basti_> you guys are using the wrong kind of crack.
14:20:25 <lightstep> @info (~>)
14:20:26 <lambdabot> Unknown command, try @listcommands.
14:20:35 <lightstep> @kind (~>)
14:20:36 <lambdabot> bzzt
14:20:39 <lightstep> @type (~>)
14:20:40 <lambdabot> bzzt
14:21:22 <xerox> That's probably due to some ext.
14:21:31 <basti_> what is ~>?
14:24:19 <xerox> Let me search for it.
14:24:32 <boegel> hmm
14:24:51 <boegel> I'll give L-systems in Haskell a try, possibly in combination with HOpenGL
14:24:57 <boegel> but I need a name for my app
14:25:09 <boegel> something like 'HRay', but then for Haskell and L-systems
14:25:36 <basti_> HL?
14:25:58 <boegel> doesn't say enough... and HL-systems is too long if you ask me :)
14:26:03 <lightstep> Hask L Systems
14:26:05 <boegel> HL sounds like Half-Life
14:26:09 <boegel> lightstep: yaay !
14:26:29 <boegel> Hask-L-Sys
14:26:32 <basti_> lsugs.
14:26:51 <boegel> HaskLS
14:26:51 <xerox> http://tunes.org/~nef/logs/haskell/05.04.07
14:26:51 <xerox> 12:56:46 <shapr> Have you seen the new ~> syntax for arrows?
14:26:51 <xerox> 12:58:13 <shapr> So it's "b ~> c"
14:27:39 <boegel> is that to punish azerty people ? we have to type ~ using AltGr, argh
14:27:51 <basti_> The ~> is an infix replacement for a in the a b c part of arrows.
14:27:52 <boegel> lightstep: what about HaskLS
14:28:17 <basti_> then Arrow (~>) is an identity?
14:28:37 <xerox> Yes
14:28:41 <xerox> Hmm..
14:28:48 <lightstep> a constraint, like Arrow a or Monad m
14:29:08 <basti_> oh yes.
14:29:27 <basti_> of course.
14:30:18 <basti_> @type mcomp
14:30:20 <lambdabot> bzzt
14:30:48 <lightstep> boegel, sounds cool
14:31:20 <basti_> does anyone care about the evolution of yi-emacs?
14:32:54 <xerox> Hmm, I can't find it, umpf.
14:33:10 <basti_> Unfortunately, the intuitionist logic of
14:33:11 <basti_> class instances makes it impossible to say directly "forall x. (NOT
14:33:12 <basti_> Constraint x)".
14:33:18 <basti_> ^ "unfortunately"
14:33:31 <basti_> for relative values of fortune
14:35:01 <basti_> what the heck is the "unlambda fuse in GHC"?
14:35:04 <stepcut> basti_: i do!
14:35:04 <basti_> http://okmij.org/ftp/Haskell/categorical-maxn.lhs <
14:35:20 <basti_> stepcut: it's going on.
14:35:26 <basti_> key binding lookup is working now
14:35:36 <basti_> rebind will be trivial now
14:35:45 <stepcut> nice
14:35:46 <basti_> repetition is in reach too
14:35:49 <stepcut> nice
14:35:59 <basti_> this is in dons' repo
14:36:16 <stepcut> tab completion ?
14:36:17 <basti_> afaik
14:36:21 <basti_> uhm. no.
14:36:21 <basti_> ;)
14:36:24 <basti_> not yet.
14:36:41 <basti_> but I think it shouldnt be all that hard
14:36:53 <basti_> there's no provisions for any user interface besides keybindings so far
14:37:03 <basti_> (like, bottom-line dialogs)
14:37:08 <stepcut> mm
14:37:16 <basti_> just some displays
14:37:35 <basti_> but i wanted to put in another abstraction that will hopefully include this sort of thing
14:37:47 <stepcut> cool!
14:38:00 <basti_> i just need so spend some more brain cycles on it
14:38:03 <basti_> to
14:38:23 <stepcut> heh
14:38:32 <xerox> I'm *sure* it is somewhere in the docs, GRUMBLE.
14:39:53 <basti_> xerox: did you notice we found what ~> is? Or did you mean the bizarre other ~> thats rumored to exist?
14:40:18 <xerox> I know what is it, I just don't find it in the docs, darn.
14:40:23 <basti_> okay.
14:50:18 <xerox> We do need a @leave-message.  At least do I :-)
14:50:44 <basti_> uhm
14:51:32 <xerox> Something like @later-tell <nick> Do you recall where is the GHC doc about ~> ? :-)
14:51:44 <basti_> ah
14:51:50 <basti_> yes that would be really nice
14:52:05 <basti_> but needs competent people.
14:52:11 <basti_> nick changes and all
14:52:12 <xerox> In fact that service is provided by NickServ, but...
14:52:15 <boegel> @wiki HaskLS
14:52:16 <basti_> oh
14:52:16 <lambdabot> http://www.haskell.org/hawiki/HaskLS
14:52:16 <boegel> yaay !
14:52:29 <lispy> minion (the lisp bot) has a messaging thing
14:52:40 <lispy> but it's not popular.  A lot of people have grown to hate it
14:52:53 <basti_> ...but what
15:04:56 <basti_> 'night
15:09:03 <boegel> @index replace
15:09:04 <lambdabot> bzzt
15:12:16 <boegel> is there a Haskell function to replace a char in a string with some substring ?
15:12:29 <boegel> or an element of a list with some list ?
15:12:40 <wagle> subst?
15:12:48 <wagle> @type subst
15:12:50 <lambdabot> bzzt
15:12:54 <wagle> wha?
15:12:58 <wagle> @index subst
15:13:00 <lambdabot> bzzt
15:13:14 * wagle bzzt's lambdabot
15:13:30 <boegel> wagle: :)
15:14:56 <boegel> wagle: is it String specific ? or List ?
15:14:59 <wagle> @type insertBy
15:15:01 <lambdabot> bzzt
15:15:21 <wagle> @type List.insertBy
15:15:22 <lambdabot> List.insertBy :: forall a. (a -> a -> Ordering) -> a -> [a] -> [a]
15:16:06 <wagle> sorted list?  ugh
15:16:20 <boegel> yo shapr !
15:16:23 <xerox> y0 shapr!
15:16:24 <shapr> y0 y0!
15:16:33 <boegel> Hugs doesn't know List ? :|
15:16:48 <boegel> oh, nvm :)
15:16:54 <wagle> gotta import hugs' List
15:17:18 <boegel> yeah, forgot that part ;)
15:17:57 <wagle> i know because i'm looking at ./hugs/lib/List.hs
15:18:37 <boegel> wagle: I'm not sure insertBy is what I want...wtf is the first argument ?
15:18:39 <wagle> but i coulda sworn i saw subst
15:18:57 <wagle> compare two values of type a
15:19:29 <wagle> get thee to the documentation, go!
15:20:40 <boegel> shapr: why aren't we seeing you that much anymore around here ?
15:20:59 <shapr> I'm trying to focus on producing code rather than only talking about it.
15:21:16 <Heffalump> produced anything good?
15:21:24 <mikael> hi shapr :-)
15:21:33 <xerox> Heffalump, ssssh, he's trying to focus!
15:21:41 <shapr> Various flippi extensions so far, just work code other than that.
15:21:47 <xerox> j/k.
15:21:48 <pipe> shapr!!!!!!!
15:21:52 <Heffalump> is flippi usable?
15:21:55 <shapr> y0 pipe, wassup?
15:22:21 <pipe> things are shit, but it's ok. how are you man?
15:22:22 <boegel> wagle: the problem is I have to subtitute something, not just insert something...
15:22:46 <boegel> pipe: wassup dude :)
15:23:04 <shapr> pipe: practicing focus, writing code, reading code, getting The Monad.Reader online
15:23:31 <pipe> cool
15:24:00 <pipe> through the power of some kind of miracle, i am home now... but tomorrow morning it's back to the shit hole :\
15:24:08 <boegel> @plugs zipWith (\x -> [x,x]) [1,2,3]
15:24:14 <lambdabot> Couldn't match `b -> c' against `[t]'
15:24:23 <boegel> @type zipWith
15:24:25 <lambdabot> zipWith :: forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
15:24:35 <boegel> @plugs map (\x -> [x,x]) [1,2,3]
15:24:38 <lambdabot> [[1,1],[2,2],[3,3]]
15:24:57 <shapr> Heffalump: yeah, Flippi is usable, and very extensible.
15:25:03 <boegel> @plugs map ('a' -> "aa") "bab"
15:25:04 <lambdabot> parse error on input `->'
15:25:10 <boegel> @plugs map (\'a' -> "aa") "bab"
15:25:12 <lambdabot> Fail: Non-exhaustive patterns in lambda
15:25:12 <lambdabot>  
15:25:17 <boegel> hmm, yeah :s
15:25:26 <boegel> @plugs map (\x -> x+x) "bab"
15:25:27 <lambdabot> <Plugins.Eval>:1:
15:25:27 <lambdabot>   No instance for (Num Char)
15:25:27 <lambdabot>   arising from use of `+'
15:25:30 <boegel> @plugs map (\x -> x++x) "bab"
15:25:31 <lambdabot> Couldn't match `[a]' against `Char'
15:25:38 <boegel> @plugs map (\x -> [x,x]) "bab"
15:25:39 <lambdabot> ["bb","aa","bb"]
15:25:47 <boegel> no ! goddamned :)
15:25:58 <wagle> @plugs join . map (\x -> if x == 'a' then "bab" else x) "cac"
15:25:58 <xerox> boegel, what do you want to do?
15:26:00 <lambdabot> Couldn't match `a1 -> m (m a)' against `[b]'
15:26:02 <boegel> @plugs (concat . map (\x -> [x,x])) "bab"
15:26:03 <lambdabot> "bbaabb"
15:26:14 <boegel> xerox, just testing some stuff
15:26:15 <wagle> @plugs join . map (\x -> if x == 'a' then "bab" else [x]) "cac"
15:26:17 <lambdabot> Couldn't match `a1 -> m (m a)' against `[b]'
15:26:20 <xerox> fmap (\x -> [x,x]) "bab"
15:26:24 <xerox> @plugs fmap (\x -> [x,x]) "bab"
15:26:26 <lambdabot> ["bb","aa","bb"]
15:26:32 <xerox> ok.
15:26:41 <boegel> I want a function which will replace a character with some string in a string
15:26:42 <boegel> like
15:26:54 <xerox> @plugs "bab" >>= (\x -> [x,x])
15:26:55 <lambdabot> "bbaabb"
15:27:02 <boegel> replaceCharWith 'a' "aa" "bab" = "baab"
15:27:06 <wagle> @plugs join (map (\x -> if x == 'a' then "bab" else [x]) "cac")
15:27:07 <lambdabot> "cbabc"
15:27:42 <xerox> @plugs "bab" >>= (\x -> if x == 'a' then "bab" else [x])
15:27:43 <lambdabot> "bbabb"
15:27:44 <boegel> @plugs "bab" >>= (\x -> if x=='a' then "aa" else x)
15:27:46 <lambdabot> Couldn't match `[Char]' against `Char'
15:27:52 <boegel> @plugs "bab" >>= (\x -> if x=='a' then "aa" else [x])
15:27:54 <lambdabot> "baab"
15:28:00 <boegel> this is what I want...
15:28:05 <wagle> @plugs join . (map (\x -> if x == 'a' then "bab" else [x])
15:28:07 <lambdabot> parse error on input `;'
15:28:20 <boegel> but then for arbitraty 'a' and "aa"
15:28:38 <xerox> @pl \xs ys -> xs >>= (\x -> if x == 'a' then ys else [x])
15:28:40 <lambdabot> (. flip (ap . flip (if' . ('a' ==))) (: [])) . (>>=)
15:28:53 <lispy> omg
15:28:58 <lispy> what does that one o?
15:29:01 <wagle> hahah
15:29:04 <lispy> @type ap
15:29:05 <lambdabot> bzzt
15:29:12 <xerox> @type Control.Monad.ap
15:29:14 <lambdabot> Control.Monad.ap :: forall b (m :: * -> *) a.
15:29:14 <lambdabot>        (Monad m) =>
15:29:14 <lambdabot>        m (a -> b) -> m a -> m b
15:29:27 <boegel> (\x y z -> x >>= (\e -> if e == y then z else [e])) "bab" 'a' "aa"
15:29:28 <mikael> I seem to recall a function of type (a -> b) -> (a, c) -> (b, c)...  am I hallucinating?
15:29:35 <lispy> @get-definition Control.Monad.ap
15:29:35 <boegel> @plugs (\x y z -> x >>= (\e -> if e == y then z else [e])) "bab" 'a' "aa"
15:29:37 <lambdabot> "baab"
15:29:37 <lambdabot> Control.Monad.ap not defined
15:29:42 <boegel> yaay !
15:29:49 <boegel> @pl (\x y z -> x >>= (\e -> if e == y then z else [e])) "bab" 'a' "aa"
15:29:50 <lightstep> @pl \from to list -> list >>= (\x -> if x == from then to else [x])
15:29:51 <lambdabot> liftM2 (flip if' "aa") ('a' ==) (: []) =<< "bab"
15:29:51 <lambdabot> ((=<<) .) . flip flip (: []) . (ap .) . flip . (if' .) . (==)
15:30:04 <lispy> ya'll are sick in the head ;)
15:30:05 <xerox> ahahah.
15:30:20 <xerox> flip flip ! (: []) (ap flap...
15:30:21 <boegel> @pl (\x y z -> x >>= (\e -> if e == y then z else [e]))
15:30:22 <lambdabot> (. flip (flip . (ap .) . flip . (if' .) . (==)) (: [])) . (.) . (>>=)
15:30:24 <mikael> ...what's @pl?
15:30:25 <boegel> wow :)
15:30:29 <boegel> point-less
15:30:30 <shapr> mikael: pointless
15:30:32 <xerox> @help pl
15:30:32 <lambdabot>  @pointless <expr> - play with pointfree code
15:30:33 <mikael> wow!
15:30:36 <wagle> @pl flop flip
15:30:38 <lambdabot> flop flip
15:30:40 <shapr> mikael: you been gone for years man!
15:30:43 <mikael> shapr: I have!
15:31:04 <shapr> mikael: So, you back for a short vacation or a longer sabbatical?
15:31:06 <mikael> school has been sort of annoying lately
15:31:18 <boegel> is think the (\x y z ... ) version is quite nice though... but strange this stuff just doesn't exist yet
15:31:18 <lightstep> boegel, you really want x as the last parameter
15:31:20 <shapr> mikael: How so? Hey, you want to write for The Monad.Reader?
15:31:26 <boegel> okay
15:31:29 <mikael> 10 weeks, or so, I imagine :-P
15:31:49 <boegel> @plugs (\y z -> (\e -> if e == y then z else [e]) <<=) "bab" 'a' "aa"
15:31:50 <lambdabot> parse error on input `)'
15:32:01 <xerox> <<= ?
15:32:10 <boegel> @plugs (\y z -> (\e -> if e == y then z else [e]) =<<) "bab" 'a' "aa"
15:32:12 <lambdabot> parse error on input `)'
15:32:23 <mikael> maybe I do...  writing is fun.  do you have any positions that need to be filled, or can I do anything?  :-)
15:32:26 <boegel> I'm not used to this monad related sutff :)
15:32:37 <boegel> @H3D
15:32:38 <lambdabot> Unknown command, try @listcommands.
15:32:42 <boegel> mikael: ^
15:32:42 <shapr> mikael: Some of both, do you already have something in mind?
15:32:47 <boegel> @wiki H3D
15:32:48 <lambdabot> http://www.haskell.org/hawiki/H3D
15:32:52 <wagle> ))
15:32:57 <boegel> mikael: maybe write something for TMR :)
15:33:03 <wagle> boegel: ))
15:33:13 <boegel> @plugs (\y z -> (\e -> if e == y then z else [e]) =<<)) "bab" 'a' "aa"
15:33:14 <lambdabot> parse error on input `)'
15:33:17 <boegel> wagle: :)
15:33:25 <wagle> nm
15:33:35 <boegel> @plugs (\y z -> (\e -> if e == y then z else [e]) =<< "bab") 'a' "aa"
15:33:37 <lambdabot> "baab"
15:33:41 * wagle puts on his glasses
15:33:50 <boegel> =<< doesn't allow partial evaluation ?
15:33:59 * lispy puts on wagles' glasses
15:34:14 <mikael> shapr: I don't really have anything in mind -- except if this little toy project I just started pans out, it might be worth writing about
15:34:15 <lispy> maybe you need (=<<)
15:34:15 <shapr> mikael: Do you have any particular subjects that interest you?
15:34:26 <shapr> mikael: What's the project?
15:34:28 <mikael> it's a window manager :-)
15:34:30 <boegel> @plugs (\y z -> (=<<) (\e -> if e == y then z else [e])) "bab" 'a' "aa"
15:34:31 <lambdabot> Couldn't match `[[Char]]' against `Char'
15:34:33 <shapr> mikael: oh cool!
15:35:06 <boegel> lispy: now what ? :)
15:35:13 <wagle> plugs ((\y z -> (\e -> if e == y then z else [e])) =<<) "bab" 'a' "aa"
15:35:13 <lispy> @type ([] >>=)
15:35:15 <lambdabot> ([] >>=) :: forall a b. (a -> [b]) -> [b]
15:35:19 <boegel> @type (<<=)
15:35:20 <lambdabot> bzzt
15:35:28 <lispy> =<<
15:35:33 <boegel> grr :)
15:35:36 <boegel> @type (=<<)
15:35:38 <lambdabot> (=<<) :: forall b (m :: * -> *) a.
15:35:38 <lambdabot>    (Monad m) =>
15:35:38 <lambdabot>    (a -> m b) -> m a -> m b
15:35:43 <wagle> notice mine worked
15:35:43 <boegel> eh ? :s
15:35:45 <mikael> @pl (\x -> fix (x >>=))
15:35:46 <lambdabot> fix . (>>=)
15:35:54 <wagle> plugs ((\y z -> (\e -> if e == y then z else [e])) =<<) "bab" 'a' "aa"
15:35:55 <boegel> wagle: oh, yeah, it did :)
15:36:01 <boegel> yo dcoutts
15:36:04 <shapr> This is becoming Haskell Golf, how to do the coolest trix with point-less.
15:36:19 * lispy nods at shapr
15:36:25 <boegel> @plugs ((\y z -> (\e -> if e == y then z else [e]) =<<) "bab" 'a' "aa"
15:36:26 <lambdabot> parse error on input `)'
15:36:30 <lispy> shapr: did you checkout my procmail program?
15:36:34 <boegel> @plugs ((\y z -> (\e -> if e == y then z else [e])) =<<) "bab" 'a' "aa"
15:36:34 <lispy> shapr: was it any good?
15:36:35 <wagle> binding
15:36:35 <lambdabot> Couldn't match `(->) [a]' against `[]'
15:36:36 <lightstep> adding a `kind' declaration (similar to `data') is like introducing a new typeclass, whose all members are predeclared, right?
15:36:44 <mikael> can one talk to lambdabot in private?
15:36:47 <lispy> shapr: or did it make you cry?
15:36:51 <shapr> lispy: I grabbed the darcs repo, but I haven't had time to do anything but work.
15:36:56 <mikael> ah, one can :-)
15:37:01 <lispy> shapr: ah, i hear ya
15:37:15 <lispy> shapr: if you add features send me a patch ;)
15:37:18 <boegel> wagle: ?
15:37:26 <shapr> lispy: will do
15:37:58 <wagle> boegel: i didnt actually put on my glasses..  8(
15:38:10 <lispy> shapr: i want to change it so that it it gives you a warning if you define a rule, but never use it
15:38:12 <boegel> @plugs ( (=<<) (\y z -> (\e -> if e == y then z else [e])) "bab" 'a' "aa"
15:38:13 <lambdabot> parse error on input `;'
15:38:16 * wagle is having a bad eyes day
15:38:26 <lispy> shapr: current version just uses a list to store all your rules
15:38:27 <boegel> there's no ; in there, stupid :p
15:38:34 <wagle> flip
15:38:40 <lispy> and all the examples form my current procmailrc ;)
15:38:41 <boegel> @type flip
15:38:43 <lambdabot> flip :: forall c a b. (a -> b -> c) -> b -> a -> c
15:38:46 <lispy> which is maybe bad
15:38:57 <boegel> @plugs flip . ( (=<<) (\y z -> (\e -> if e == y then z else [e])) "bab" 'a' "aa"
15:38:58 <lambdabot> parse error on input `;'
15:39:05 <shapr> lispy: Hm, I could use this to bail out of gnus, yeah!
15:39:07 <boegel> @plugs ( flip . (=<<) (\y z -> (\e -> if e == y then z else [e])) "bab" 'a' "aa"
15:39:08 <lambdabot> parse error on input `;'
15:39:13 <boegel> grrr :)
15:39:15 <boegel> wagle: help ?
15:39:19 <lispy> shapr: er?
15:39:24 <lispy> shapr: you want to stop using gnus?
15:39:31 <lispy> but why?
15:39:32 <wagle> @plugs ( (=<<) (\y z -> (\e -> if e == y then z else [e]))) "bab" 'a' "aa"
15:39:33 <shapr> Yeah, I want out of emacs.
15:39:34 <lambdabot> Couldn't match `(->) [a]' against `[]'
15:39:36 <mikael> :O
15:39:44 <lispy> shapr: huh, i'm headed in the other direction ;)
15:39:46 <boegel> wagle: tried that :)
15:39:52 <wagle> @plugs ( flip (=<<) (\y z -> (\e -> if e == y then z else [e]))) "bab" 'a' "aa"
15:39:54 <lambdabot> Couldn't match `([a] -> a -> [a]) -> a -> t -> a1' against `[Char]'
15:39:54 <shapr> As much as I love emacs, it has some flaws that I do not think will be fixed in my lifetime.
15:39:59 <lispy> shapr: i just got gnus set up so it caches my email for offline viewing
15:40:04 <lispy> shapr: true
15:40:08 <lispy> shapr: very, very true
15:40:10 <dcoutts> hi boegel
15:40:17 <lispy> shapr: have you seen climacs?
15:40:24 <lispy> shapr: common lisp emacs?
15:40:25 <shapr> lispy: have you seen Yi? =)
15:40:30 <wagle> @plugs ( (>>=) (\y z -> (\e -> if e == y then z else [e]))) "bab" 'a' "aa"
15:40:32 <lambdabot> Couldn't match `([a] -> a -> [a]) -> a -> t -> a1' against `[Char]'
15:40:35 <lispy> shapr: not really, but i hear things about it ;)
15:41:09 <ski> lightstep : what kind of 'kind' declaration were you thinking of ?
15:41:44 * ski says hi to shapr
15:41:52 <wagle> plugs ((>>=)(\y z -> (\e -> if e == y then z else [e]))) "bab" 'a' "aa"
15:42:05 <boegel> come on, it _must_ be possible to get this pointless stuff working
15:42:07 <wagle> @plugs ((>>=)(\y z -> (\e -> if e == y then z else [e]))) "bab" 'a' "aa"
15:42:09 <lambdabot> Couldn't match `([a] -> a -> [a]) -> a -> t -> a1' against `[Char]'
15:42:31 <boegel> @plugs (\y z -> (\e -> if e == y then z else [e]) =<< "bab") 'a' "aa"
15:42:33 <lambdabot> "baab"
15:42:34 <wagle> @plugs ((=<<)(\y z -> (\e -> if e == y then z else [e]))) "bab" 'a' "aa"
15:42:35 <lambdabot> Couldn't match `(->) [a]' against `[]'
15:42:41 <boegel> back to basics... this work
15:42:43 <boegel> +s
15:43:15 <wagle> eeet no make sense
15:44:24 <boegel> wagle: yeah, it doesn't :s
15:44:34 <boegel> it should be working fine
15:44:44 * lispy wonders how hard it would be to make Yi support elisp
15:44:50 <wagle> plugs ((\y z -> (\e -> if e == y then z else [e])) =<<) "bab" 'a' "aa"
15:44:56 <shapr> lispy: not hard actually
15:45:09 <shapr> lispy: HScheme and Mr Preprocessor's automatic elisp -> scheme converter code.
15:45:09 <ski> @pl (\xs y ys -> (\x -> if x == y then ys else [x]) =<< xs)
15:45:11 <lambdabot> flip (flip . ((=<<) .) . flip flip (: []) . (ap .) . flip . (if' .) .
15:45:11 <lambdabot> (==))
15:45:14 <lispy> shapr: if you did that it would ease the transition
15:45:27 <shapr> True, but I think the existing elisp culture is part of the problem.
15:45:29 <wagle> @plugs ((\y z -> (\e -> if e == y then z else [e])) =<<) "bab" 'a' "aa"
15:45:31 <lambdabot> Couldn't match `(->) [a]' against `[]'
15:45:36 <ski> @plugs (\xs y ys -> (\x -> if x == y then ys else [x]) =<< xs) "bab" 'a' "aa"
15:45:38 <lambdabot> "baab"
15:46:00 <boegel> sky, well yeah, but isn't it possible without the xs?
15:46:00 <lispy> shapr: i'm thinking of ways to still use gnus, until Yi has a gnus replacement ;)
15:46:01 <wagle> now it makes sense..  i thought that works
15:46:04 <wagle> worked
15:46:44 <ski> boegel : @pl gives one way ..
15:47:05 <boegel> ski: but that's just sick :)
15:47:25 <ski> boegel : i think one could maybe do something with curry,uncurry,fst,snd ..
15:47:29 <boegel> nobody knows about such a function existing ? replacing some item in a list with a certain list ?
15:49:10 <wagle> @pl join [if c == 'a' then "cdc" else [c] | c <- "bab"]
15:49:12 <lambdabot> join [if' (c == 'a') "cdc" ([c] | c <- "bab")]
15:49:15 <boegel> @plugs (\x y z -> (\e -> if e == y then z else [e]) =<< x) "bab 'a' "aa"
15:49:16 <lambdabot> lexical error in string/character literal
15:49:27 <boegel> @plugs (\x y z -> (\e -> if e == y then z else [e]) =<< x) "bab" 'a' "aa"
15:49:27 <wagle> @eval join [if c == 'a' then "cdc" else [c] | c <- "bab"]
15:49:29 <lambdabot> "baab"
15:49:29 <lambdabot> (line 1, column 39):
15:49:29 <lambdabot> unexpected "|"
15:49:29 <lambdabot> expecting operator, simple term, "," or "]"
15:49:42 <wagle> lambdabot: 8-p
15:50:23 <boegel> okay, I think I'll use this for now...
15:50:40 <ski> @plugs (\y ys -> ((\x -> if x == y then ys else [x]) =<<)) 'a' "aa" "bab"
15:50:42 <lambdabot> "baab"
15:50:51 <boegel> ski !
15:50:59 <ski> @plugs (\y ys -> (=<<) (\x -> if x == y then ys else [x])) 'a' "aa" "bab"
15:51:01 <boegel> oh, you switched the terms...
15:51:01 <lambdabot> "baab"
15:51:06 <ski> yes
15:51:16 <wagle> @eval concat [if c == 'a' then "cdc" else [c] | c <- "bab"]
15:51:17 <ski> was that not allowed ?
15:51:18 <lambdabot> (line 1, column 41):
15:51:18 <lambdabot> unexpected "|"
15:51:18 <lambdabot> expecting operator, simple term, "," or "]"
15:51:18 <boegel> that was the problem all the time :) damned :)
15:51:23 <boegel> ski: yeah sure
15:51:33 <wagle> @pl concat [if c == 'a' then "cdc" else [c] | c <- "bab"]
15:51:34 <lambdabot> join [if' (c == 'a') "cdc" ([c] | c <- "bab")]
15:51:41 <wagle> hahaha
15:52:19 <ski> the @pl command doesn't understand list comprehensions, 'twould seem
15:52:29 <wagle> rilly
15:52:49 <wagle> i thought it could compute with them, just not transform them
15:53:13 <xerox> @pl \f xs -> [f x | x <- xs]
15:53:14 <lambdabot> flip flip [] . ((:) .) . (<-) . (| x) . flip id x
15:53:16 <ski> the @eval command doesn't evaluate haskell, iirc
15:53:19 <xerox> yay.
15:53:38 <ski> wagle : it's @plugs that evals haskell
15:53:51 <wagle> ski: i tried that
15:54:01 <wagle> @plugs concat [if c == 'a' then "cdc" else [c] | c <- "bab"]
15:54:03 <lambdabot> "bcdcb"
15:54:06 <wagle> duhhhhh
15:54:32 <ski> :)
16:10:04 <boegel> nifty, I just implemented L-systems using only 3 functions and 2 types *yaay
16:10:05 <shapr> mikael: Do you have a darcs repo for your wm online?
16:10:18 <mikael> shapr: not yet -- I _really_ just started it
16:10:23 <mikael> shapr: as in, a couple of hours ago :-)
16:11:14 <mikael> it should be able to capture key chords (e.g., C-x C-c) on the root window soon
16:15:26 <xerox> Goodnight folks.
16:15:33 <shapr> g'night xerox
16:17:04 <boegel> bye xerox
16:30:01 <SamB> how are you supposed to use ContT?
16:30:16 <SamB> that is, how do you run a computation in it?
16:30:50 <shapr> SamB: Want to write a TMR article about it? ;-)
16:31:26 <SamB> shapr: err, I dunno.
16:32:28 <SamB> I want something like "run :: Monad m => ContT m a -> m a"
16:33:19 <SamB> oh, wait, I didn't notice the (..) after ContT in the export list...
16:33:33 <boegel> shapr: hehehe
16:33:44 <SamB> I wish they wouldn't use record newtypes so much!
16:33:55 <SamB> they may be concise, but they are confusing!
16:35:07 <Trevion> I've come to love them.
16:35:34 <Trevion> But I definitely spent a couple of weeks staring at the Control.Monad documentation with completely glazed eyes.
16:36:38 <Trevion> Is GHC - or any other of the open source Haskell projects - getting involved in Google's Summer of Code?
16:36:59 <SamB> well, it would be different if they weren't run functions, I guess.
16:37:02 <Igloo> It's too late for new mentoring orgs
16:38:31 <SamB> I think that such key interface functions as runContT should be defined the normal way, so that they are easier to find
16:38:54 <SamB> its not like it results in less efficient code or anything
16:40:10 <SamB> this is less important in code that is commented, though
16:43:09 * SamB is writing an unlambda interpreter
16:43:40 <rt> mmm.  combinators.
16:43:52 * rt flashes back twenty years, and relives his glory days.
16:44:48 <SamB> later I might try to figure out how to do it by RunTimeCompilation...
16:45:04 <SamB> actually I think it should be dead easy that way, with monads...
16:53:46 * mikael digs TH
16:57:26 <autrijus> shapr: hey. TMR submission is due in how many days?
16:57:44 <shapr> 23 days for the next release
16:57:48 <autrijus> shapr: have you read my hw2005.txt?
16:57:58 <autrijus> good. then I have time to merge that with PA02 and submit PA02 to TMR
16:57:59 <shapr> No, but I want to.
16:58:06 <autrijus> shapr: http://svn.openfoundry.org/pugs/docs/talks/hw2005.txt
16:58:22 <autrijus> shapr: my first academic paper -- style and content will be no doubt many lacking
16:58:45 <autrijus> as well as sentences no verb
16:58:50 <autrijus> and grammar invalid
16:59:01 <shapr> Do you want grammar/spell checking feedback?
16:59:12 <autrijus> sure. style too. content too.
16:59:19 <autrijus> heck, anything. but preferably in the next 12 hours or so
16:59:26 <autrijus> because I'll fly to vienna after than
17:01:22 <shapr> Oh
17:02:33 <shapr> In completely unrelated news, I'm reviewing a new book published by the Pragmatic Programmers, "Behind Closed Doors: Revealing The Secrets of Great Management". So far, it's an excellent book.
17:08:32 <boegel> what's it about ?
17:09:10 <autrijus> it's about the fact that great manager don't stand right behind closed doors
17:09:23 <autrijus> otherwise they get hurt with someone open and push that door
17:09:33 <boegel> it is ? great ! :p
17:12:17 <mikael> is defining instances of TH.Syntax.Lift (for, say, Word32) something best left to wizards?
17:12:54 <dcoutts> mikael, I don't think so, I doubt it'd be very hard
17:13:38 <dcoutts> take a look at the instance for Int
17:14:32 <mikael> okay, thanks :-)
17:15:07 * boegel goes to bed
17:23:38 <mikael> it seems like just stealing the Int instance works fine:
17:23:39 <mikael> instance Lift Word32 where
17:23:39 <mikael>     lift w = return $ LitE (IntegerL (toInteger w))
17:24:27 <autrijus> if you are willing for instances to overlap, you can add Lift to all Integral types
17:24:28 <Igloo> Hmm, that's a slightly dubious instance (for both types)
17:24:59 <autrijus> Igloo: maybe it's because TH expression is not typed?
17:25:05 <mikael> wait, sorry, that isn't theft.  the Int instances uses fromIntegral, not toInteger
17:25:25 <SyntaxNinja> Igloo: YGM
17:25:26 <mikael> what about lift = lift . toInteger, for the Word32 case?
17:25:45 <mikael> there I go with the toInteger again!  I have too much caffeine in me
17:25:49 <Igloo> autrijus: That's not quite the issue
17:26:12 <Igloo> It's taking the number as an Int/Word32 and creating the abstract syntax tree for the overloaded numeric literal
17:26:36 <autrijus> by treating it as a Integer literal
17:27:07 <Igloo> IntegerL is the constructor for overloaded integer literals
17:27:51 <Igloo> Ta Syn
17:27:57 * Igloo waits for it to actually arrive  :-)
17:28:37 <mikael> here's an url to ghc's Lift instances, for reference: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/template-haskell/Language/Haskell/TH/Syntax.hs?rev=1.7.2.1;content-type=text%2Fplain
17:29:10 <dcoutts> Igloo, I don't recall, does the TH abstract syntax support the (value :: Type) syntax?
17:29:17 <SyntaxNinja> Igloo: let me know if you want to talk abut that here..
17:29:43 <mikael> dcoutts: would that be the (SigE Exp Type) constructor of Exp?
17:29:55 <dcoutts> Igloo, if so the lift for the numeric types can build the ast for (42 :: Word32)
17:30:06 <dcoutts> mikael, I guess so
17:30:36 <dcoutts> so that would resolve the overloading of just using a numeric literal
17:31:19 <dcoutts> it's as simple as that isn't it? or am I overlooking something?
17:32:31 <Igloo> Yeah, that should be fine
17:33:08 <Igloo> (you need to get the name of the right Word32, though. Should be able to do it with quasiquotes and have the current instance inside a splice I think)
17:33:38 <dcoutts> ``Word32
17:33:53 <dcoutts> or rather ''Word32 isn't it
17:34:48 <Igloo> I think [| $( ... ) :: Word32 |] would be nicer
17:35:03 <dcoutts> true
17:38:51 * Igloo starts to doubt I really do have mail
17:49:44 <mikael> a ``deriving Lift'' clause would be cool :-)
18:38:08 * mikael finds himself annoyed at GHC's stage restriction for TH
18:39:51 <dcoutts> mikael, you mean you want to write a 3 stage program rather than just 2 stage?
18:40:19 <dcoutts> or you want runtime values to be available at compile time :-)
18:41:04 <mikael> maybe I'm trying to do the latter :-)  TH is very fuzzy to me.  let me try some stuff...  I may have spoken too soon
18:59:46 <autrijus> mikael: you can use runIO to call System.Eval!
19:00:06 <mikael> haha
19:00:16 <mikael> I think I solved it, but I'll keep that in mind :-)
19:02:32 <autrijus> there is an entire language building upon that notion :)
19:03:02 <mikael> what's that?
19:03:24 <autrijus> perl.
19:03:30 <mikael> :-)
19:03:36 <reffie> ;)
19:03:39 <autrijus> section 4.2 and 2.2 of http://svn.openfoundry.org/pugs/docs/talks/hw2005.txt deals with this :)
19:04:41 <autrijus> it's quite advanced...
19:04:51 <autrijus> ..."advanced" as in "an advanced case of insanity"
19:05:02 <mikael> that's the perl we all love!
19:05:59 * mikael wonders why the function with type `IO XEventPtr' seems to have vanished from the X11 binding.
19:06:08 <mikael> how am I now to obtain an XEventPtr? :-/
19:08:38 <autrijus> mikael: castPtr
19:08:40 <autrijus> :)
19:12:05 <MachinShin> hey +
19:17:34 <mikael> ah, Foreign.Marshall.Alloc.malloc
21:47:43 <Pseudonym> http://www.willamette.edu/~fruehr/haskell/seuss.html
22:01:05 <mikael> that is a wonderful rhyme
22:01:08 <mikael> morning, Pseudonym!
22:09:14 <Pseudonym> G'day.
22:57:25 <seidan> @pl \n -> n*(n+1) `div` 2
22:57:26 <lambdabot> ap (*) ((`div` 2) . (1 +))
22:58:25 <seidan> @pl \n -> (n*(n+1)) `div` 2
22:58:26 <lambdabot> (`div` 2) . ap (*) (1 +)
22:58:50 <seidan> @pl (`div` 2) . ap (*) (1 +) 4
22:58:51 <lambdabot> (`div` 2) . 20
22:58:58 <seidan> hehe
22:59:02 <mflux_> @pl \n -> div (n*(n+1)) 2
22:59:02 <lambdabot> flip div 2 . ap (*) (1 +)
22:59:19 <seidan> that ap isn't right is it?
22:59:28 <mflux_> what IS that ap?-)
22:59:37 <seidan> @index ap
22:59:39 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
22:59:39 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
22:59:39 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
22:59:39 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.
22:59:39 <lambdabot> Inductive
23:00:10 <seidan> @plugs flip div 2 . ap (*) (1 +) 4
23:00:11 <lambdabot> <Plugins.Eval>:1:
23:00:11 <lambdabot>   No instances for (Monad ((->) (a -> b)), Num (a -> b))
23:00:11 <lambdabot>   arising from use of `ap'
23:00:38 <seidan> That's why I say it "ain't right"
23:01:03 <mflux_> it is propably defined somewhere
23:01:06 <mflux_> but..
23:02:27 <seidan> from hugs lib: ap = liftM2 id
23:03:49 <seidan> @pl flip div 2 . ap (*) (1 +) 4
23:03:50 <lambdabot> flip div 2 . 20
23:06:09 <mflux_> @plugs let ap = liftM2 id in flip div 2 . ap (*) (1 +) 4
23:06:10 <lambdabot> <Plugins.Eval>:1:
23:06:10 <lambdabot>   No instances for (Monad ((->) (a -> b)), Num (a -> b))
23:06:10 <lambdabot>   arising from the literal `4'
23:07:06 <mflux_> @plugs let ap = liftM2 id in (flip div 2 . ap (*) (1 +)) 4
23:07:08 <lambdabot> <Plugins.Eval>:1:
23:07:08 <lambdabot>   No instance for (Monad ((->) a))
23:07:08 <lambdabot>   arising from use of `liftM2'
23:08:10 <seidan> @plugs liftM2 id (*)
23:08:12 <lambdabot> <Plugins.Eval>:1:
23:08:12 <lambdabot>   No instances for (Show ((a -> a) -> a -> a), Monad ((->) a))
23:08:12 <lambdabot>   arising from use of `show'
23:10:41 <genneth> @see shapr
23:10:43 <lambdabot> I saw shapr leaving #haskell 4 hours, 48 minutes and 57 seconds ago.
23:12:24 <seidan> @type liftM2
23:12:26 <lambdabot> bzzt
23:12:37 <seidan> @type Control.Monad.liftM2
23:12:38 <lambdabot> Control.Monad.liftM2 :: forall r (m :: * -> *) a2 a1.
23:12:38 <lambdabot>         (Monad m) =>
23:12:38 <lambdabot>         (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:12:43 <seidan> @type id
23:12:45 <lambdabot> id :: forall a. a -> a
23:20:21 <seidan> @plugs ap [id, \n->n*n, (flip div) 2] [1..5]
23:20:23 <lambdabot> [1,2,3,4,5,1,4,9,16,25,0,1,1,2,2]
