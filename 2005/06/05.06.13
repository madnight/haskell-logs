00:01:24 <Itkovian> omg
00:01:31 <Itkovian> that is sick
00:02:52 <andersca> haha
00:03:32 <kaol> @vixen do you like cats?
00:03:34 <lambdabot> yah, i like
00:29:08 * ski laughs at a 'crash course in swedish'
00:45:19 <ski> "May I buy a married snake?" :)
00:46:22 <kaol> @vixen do you like snakes?
00:46:23 <lambdabot> yah, i like
00:46:40 <ski> "Deep-frozen chicken is alive"
00:46:57 * ski giggles to the mp3
00:50:04 <ski> @vixen May I buy married snake?
00:50:06 <lambdabot> )
00:50:18 <ski> eh ?
01:09:03 <xerox> 'morning
01:13:05 <dons> ~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~/win 2
01:13:23 <dons> grr
01:13:26 <autrijus> greetings.
01:14:08 <dons> how'd the paper go autrijus?
01:15:08 <autrijus> dons: I did my best...
01:15:21 <autrijus> turned in it last night
01:15:29 <dons> @timein apia
01:15:32 <lambdabot>  Sunday, June 12, 2005 at 9:16:32 PM
01:15:38 <dons> not too late at all :)
01:15:45 <boegel> yo xerox
01:15:55 <autrijus> apia?
01:16:02 <autrijus> still not happy, but I see there's a chance for a final version if it got accepted
01:16:02 <dons> samoa
01:16:05 <autrijus> so that's fine
01:16:05 <autrijus> lol
01:16:21 <dons> yeah, you get to revise, plus you get all the reviewer feedback
01:17:48 <autrijus> that'd make me much happier
01:35:29 <Itkovian> hi boegel
01:37:33 <boegel> yo Itkovian
02:00:52 <dcoutts_> boegel, ave you got a darcs repo for the memory game too?
02:01:07 <boegel> dcoutts_: err, no
02:01:08 <boegel> why ?
02:01:20 <boegel> I could set one up if you'd like me to
02:01:23 <dcoutts_> was thinking of sending you a patch...
02:01:35 <boegel> lemme set one up
02:01:45 <dcoutts_> cool
02:03:06 <boegel> fuck
02:03:16 <boegel> I just trashed my glade file :(
02:03:30 * boegel hits himself in the head
02:04:27 * xerox dances
02:08:04 <boegel> dcoutts_: http://scannedinavian.org/~boegel/Memory/darcs
02:08:30 <boegel> tell me if it works, it's only like the 3rd time I've done this :)
02:11:04 <dcoutts_> ok
02:13:02 <dcoutts_> boegel, you've got one too many "darcs"s in there: http://scannedinavian.org/~boegel/Memory/darcs/darcs
02:13:31 <dcoutts_> the checkout dir ends up being called darcs too :-)
02:16:54 <boegel> dcoutts_: woops :)
02:17:13 <boegel> dcoutts_: fixed
02:18:21 * boegel jumps in the shower
02:23:01 <dcoutts_> boegel, the checkout dir still ends up being called "darcs" which is proably not what you intended
02:30:01 <boegel> dcoutts_: checkout dir ? err...
02:30:44 <boegel> I mean for you to do this: 'darcs get http://.../Memory/darcs'
02:30:50 <boegel> oh wait
02:30:54 <boegel> I know what you mean :)
02:30:55 <boegel> sorry
02:31:23 <boegel> dcoutts_: http://scannedinavian.org/~boegel/Memory/darcs/memory
02:31:24 <boegel> :)
02:34:46 <dcoutts_> boegel, that's better. thanks.
02:34:51 <lightstep> gtk2hs doesn't have g_signal_connect_swapped, does it? every signal is handled with the parallels of g_signal_connect?
02:43:13 <dcoutts_> lightstep, g_signal_connect_swapped makes n oparticular sense in Gtk2Hs since you don't get or need an extra 'data' parameter to your signal handlers. We've got propper closures instead. :-)
02:44:23 <dcoutts_> lightstep, is there something you think you need g_signal_connect_swapped for?
02:50:10 * boegel leaves
02:50:21 <boegel> dcoutts_: just mail me the patch when you have it, okay ?
02:50:28 <dcoutts_> yep
02:50:44 <boegel> bye
03:31:36 <JaffaCake> dcoutts:ping?
03:32:00 <dcoutts_> hello
03:32:28 <JaffaCake> hi - your report of strange behaviour with -H750m -M750m, was that on Win32 only?
03:32:35 <dcoutts_> yes
03:32:47 <JaffaCake> ah.  then I think I know what the problem is
03:32:54 <dcoutts_> on linux it's perfectly well behaved
03:33:10 <dcoutts_> so what was going wrong?
03:33:41 <JaffaCake> on Win32, the -M flag gives a hard limit, whereas on Linux we can exceed the limit (but we try to stay within it)
03:34:13 <JaffaCake> the problem is that the -H heuristics have gone slightly wrong and we needed slightly more than 750M
03:34:20 <dcoutts_> ah, I see
03:34:42 <dcoutts_> JaffaCake, actually I had a Q, if you've got just a sec...
03:34:51 <JaffaCake> sure
03:35:13 <dcoutts_> I'm wondering if it's kosher to do the following with ForeignPtrs...
03:35:58 <dcoutts_> I have a constructor: data PixbufData i e = PixbufData Pixbuf (Ptr e)
03:36:13 <dcoutts_> the Pixbuf is actually just a ForeignPtr
03:36:27 <JaffaCake> ok
03:37:00 <dcoutts_> so we're keeping the unwrapped ptr with the wrapped one
03:37:08 <JaffaCake> right, I see
03:37:32 <JaffaCake> actually I think this is safe - there was a discussion some time ago on the ghc-users list about implementing ForeignPtrs this way
03:37:33 <dcoutts_> and we can avoid the unwrapping on each pointer access
03:38:06 <JaffaCake> if you're always using withForeignPtr to access it, then you should be fine
03:38:35 <dcoutts_> so in the unsafeRead/unsafeWrite functions (for the MArray class instance) we access the raw Ptr and then touchForeignPtr
03:38:51 <dcoutts_> (on the ForeignPtr component obviously)
03:38:55 <JaffaCake> right
03:39:18 <dcoutts_> so that's safe? and the touchForeignPtr bit is necessary?
03:39:31 <dcoutts_> unsafeWrite (PixbufData (Pixbuf pb) pixPtr _) idx elem = do
03:39:32 <dcoutts_>       pokeElemOff pixPtr idx elem
03:39:32 <dcoutts_>       touchForeignPtr pb
03:39:41 <JaffaCake> the touch is definitely necessary, otherwise GHC might optimise away the ForeignPtr component
03:40:05 <JaffaCake> let me see if I can dig up that discussion
03:40:35 <dcoutts_> ok, and am I right in thinking that the touchForeignPtr has no runtime overhead (apart from inhibiting optimisations like removing the  ForeignPtr component entriely)
03:41:05 <dcoutts_> it just ensures lifetime from a GC perspecitve
03:41:12 <JaffaCake> http://www.haskell.org/pipermail/glasgow-haskell-users/2004-July/006925.html
03:41:57 <JaffaCake> unfortunately touchForeignPtr isn't free, it does deconstruct the ForeignPtr
03:42:12 <dcoutts_> oh
03:44:17 <JaffaCake> now that I think about it, I'm not sure that touchForeignPtr really needs to pattern match on the ForeignPtr
03:45:22 <dcoutts_> so I guess the question then is, is this "data PixbufData i e = PixbufData (ForiegnPtr Pixbuf) (Ptr e)" trick really of any benefit or would it be just as fast/slow to use just the ForeignPtr
03:45:43 <dcoutts_> and withForeignPtr on each array access
03:47:22 <JaffaCake> I think it might be slightly faster, but you should measure it
03:47:31 <dcoutts_> right
03:47:47 <JaffaCake> instead of touchForeignPtr, I'm thinking that you might be able to get away with touch#
03:48:18 <dcoutts_> and I should benchmark that too I suppose :-)
03:48:58 <JaffaCake> of course :)
03:49:41 <JaffaCake> if I get a chance sometime, I'd like to make the change from that message on ghc-users, it should improve ForeignPtr performance quite a bit
03:49:55 <dcoutts_> that'd be nice
03:50:11 <JaffaCake> is ForeignPtr a bottleneck for you?
03:50:21 <dcoutts_> would that bring StorableArray up to MArray performance?
03:50:36 <JaffaCake> ah that's another good question
03:50:36 <dcoutts_> er IOUArray I mean
03:51:02 <dcoutts_> because it does essentially the same thing right? withForiegnPtr on each array access
03:51:22 <JaffaCake> I did a bit of work on StorableArray but didn't finish it - there's some tricky design issues
03:51:27 <JaffaCake> yes
03:51:51 <dcoutts_> when doing lots of pixel buffer array operations the looping, indexing and ForiegnPtr bits all feel rather slow
03:52:22 <dcoutts_> we had that thread on g-h-bugs some months ago about making loops go faster
03:53:03 <JaffaCake> yes, improving StorableArray perf would be a nice side effect
03:53:27 <JaffaCake> I'm slightly more tempted to dive in now :)
03:53:48 <dcoutts_> people write code like sequence_ [ | x <- [0..255], y <- [0..255] ] and it runs very slowly
03:53:54 <JaffaCake> but I'm currently trying to clear my inbox after a furious two weeks writing Haskell workshop papers
03:54:06 <JaffaCake> right
03:54:07 <dcoutts_> :-)
03:55:15 <JaffaCake> I don't suppose you have any handy benchmarks lying around?
03:55:49 <dcoutts_> I'm just working on our Pixbuf demos for Gtk2Hs 0.9.8 which should make reasonably good demos.
03:56:01 <dcoutts_> demos/benchmarks I mean
03:56:22 <JaffaCake> ok, I might just knock up a little StorableArray benchmark then
03:56:40 <dcoutts_> yes, we're not using StorableArray at the moment
03:56:50 <JaffaCake> because of the performance?
03:57:05 <dcoutts_> Actualy, I'm not sure that we can becasue of the API (I may be misremembering)
03:57:49 <dcoutts_> we have a pixel buffer allocated by the C side, but StorableArray wants to be allocated by the Haskell side for use on the C side if I recall correctly.
03:58:18 <dcoutts_> We'd need a function to "adopt" an existing C array as a StorableArray
03:58:19 <JaffaCake> don't think so - if you have a Ptr you can make a ForeignPtr, and then get a StorableArray
03:58:35 <dcoutts_> oh, ok, I'm remembering wrong
03:58:51 <dcoutts_> in that case we probably could use StorableArray
03:59:01 <JaffaCake> ah no, I just checked - there's no way to convert a ForeignPtr into a StorableArray
03:59:07 <JaffaCake> but there should be
03:59:13 <dcoutts_> right :-)
03:59:22 <JaffaCake> urk, rewind... there *is*
03:59:35 <JaffaCake> unsafeForeignPtrToStorableArray
03:59:50 <dcoutts_> oh, ok then I should benchmark our version and the standard StorableArray
04:01:28 <JaffaCake> unsafeForeignPtrToStorableArray isn't in 6.4, it was added subsequently
04:01:45 <dcoutts_> ok, I was just looking in the docs and not finding it
04:03:22 <JaffaCake> it's possible that to really get good performance from StorableArray it needs some specialisation for common element types too
04:04:12 <dcoutts_> for the PixBuf MArray interface we typically use Word8 and Word32
04:04:33 <JaffaCake> ok
04:04:56 <dcoutts_> I guess we should add specilisation pragmas too
04:05:06 <JaffaCake> yep
04:05:23 <JaffaCake> I've gotta go, thanks for the suggestions anyway
04:05:33 <dcoutts_> thanks
04:49:07 <bourbaki> min
04:49:09 <bourbaki> moin
04:58:35 <bourbaki> does anyone happen to know if there is a numerical and statistical lib for haskell?
05:02:29 <shelarcy> How about HBlas? This is Haskell binding for BLAS and CLAPACK.
05:02:40 <shelarcy> http://www.isi.edu/~hdaume/HBlas/index.html
05:04:06 <bourbaki> ill check it out
05:19:52 <Itkovian> bourbaki: what will you try to do with it? I am looking for the same stuff ...
05:21:54 <bourbaki> i want to write a tool in haskell that takes a set of greyscale vectors and calculates its covarinace matrix and then its eigenvectors
05:22:04 <bourbaki> of the covariance matrix that is
05:23:16 <bourbaki> these library documentation is quite cryptic :)
05:29:18 <Itkovian> well, if you have that, let me know, i'll use it for PCA :-)
05:30:27 <Itkovian> anybody has a Haskell app to solve sodoku puzzles? http://www.websudoku.com/
05:30:55 <bourbaki> thats basically what that is
05:31:41 <bourbaki> isnt the covariance of two vectors just its dot product?
05:32:05 <Heffalump> Itkovian: no, but it might be fun to write
05:32:14 <Heffalump> s/no/I don't know of one/
05:33:35 <Itkovian> bourbaki: erm ...
05:34:16 <bourbaki> devided by the cardinality of course but that wouldnt matter if you do not do that in all places
05:34:43 <bourbaki> since i want to take the eigenvalue its just a scaleing which is unimportant for the eigenvalue
05:38:45 <chris2> Itkovian: solving is compariably easy, but generating good ones seems a lot more harder
05:42:28 <bourbaki> Itkovian it is very simple to write a program that will solve that have a look at contraint programming
05:59:01 <ndm> Itkovian: Haskell might not be the most appropriate language for Sudoko
05:59:05 <ndm> I may be wrong though
05:59:14 <Heffalump> I think it'd be quite good.
05:59:20 <ndm> If you use a constraint solver like Eclipse, its about 10 lines of code
05:59:27 <Itkovian> ndm: perhaps prolog would be easier ...
05:59:32 <Itkovian> what's eclipse?
05:59:38 <ndm> Eclipse is Prolog + Constraints
05:59:43 <Itkovian> ok.
05:59:52 <ndm> http://www.icparc.ic.ac.uk/eclipse/
06:02:16 <bourbaki> you can easily write your own solver i am sure
06:02:34 <bourbaki> waltz algorithm is something you should have a look at
06:02:46 <bourbaki> thats barely more then 10 lines in haskell also i bet
06:03:03 <ndm> Itkovian: http://www-users.cs.york.ac.uk/~shackell/sudoku/Sudoku.html
06:03:12 <ndm> thats a C Solver
06:03:35 <ndm> for this problem, the main thing to do is arc-consistency
06:08:50 <bourbaki> Itkovian http://kti.ms.mff.cuni.cz/~bartak/constraints/constrsat.html
06:09:25 <Itkovian> thx
06:09:45 <bourbaki> http://kti.ms.mff.cuni.cz/~bartak/constraints/propagation.html
06:10:07 <bourbaki> i think that for this puzzle the propagation of the constraints is enough so thats what you want to look at essentially i would say
06:14:05 <Itkovian> ok
06:14:38 <dons> didn't blackdog write a solver for sudoko?
06:14:40 <dons> in haskell?
06:15:13 <dons> yes!
06:15:19 <dons> http://www.shimweasel.com/code/sudoku.tgz
06:15:39 <dons> http://www.shimweasel.com/code/
06:16:49 <dons> paprika$ wc -l Sudoku.hs
06:16:49 <dons>       70 Sudoku.hs
06:17:15 <ikegami--> cool
06:17:38 <ikegami--> do you know Sudoku comes from Japan? :)
06:17:53 <dons> of course :)
06:31:22 <ikegami--> The original sudoku has been appeared a Japanese puzzle magazine in 1984
06:32:07 <ikegami--> The puzzle magazine is "Nikori" (popular magazine in Japan)
06:32:32 <ikegami--> Unfortunately, they are not translated in English, but they have a web page
06:32:48 <ikegami--> http://www.nikoli.co.jp/puzzles/1/
06:38:34 <ikegami--> I guess there are many interesting puzzles that are not imported to foreign countries
06:38:51 <ikegami--> in Nikoli, I mean
06:39:11 <ikegami--> and not imported but exported
06:39:17 <Itkovian> hmm, I can't read japanese ...
06:39:18 <wilx> Hm.
06:40:28 <ikegami--> here is 12 puzzles as Macromedia flash http://www.nikoli.co.jp/puzzles/
06:43:00 <SamB> hmm, I wonder how far along non-macromedia flash interps have come...
06:44:23 <wilx> Hmm, interesting puzzle.
06:50:24 <p21870> how can i prevent lhs2tex from indenting my code blocks?
06:52:24 <michaelw> SamB: http://www.xach.com/img/flash/square.html (watch for 20secs or so)
06:54:16 <SamB> michaelw: eh, I actually have macromedia's player installed, so I won't learn much about progress on free implementations from that... or did you mean something else?
07:03:07 <michaelw> SamB: er, thinko, sorry
07:04:17 <musasabi> Has anyone hacked Haddock to support GADT definitions?
07:04:35 <p21870> how can i prevent lhs2tex from indenting my code blocks?
07:06:04 <pesco> p21870: Have you considered shortening your lines instead?
07:06:48 <dcoutts_> SamB, there is gplflash which is stalled in development and then there is http://www.schleef.org/swfdec/ which is in active development
07:07:39 <dcoutts_> p21870, you can try asking kosmikus (the lhs2tex author) but he's rather busy at the moment so probably won't get back to you for several days
07:10:46 <p21870> several days :O
07:11:02 <p21870> pesco, i really cant make my code shorter without seriously screwing up the layout
07:11:32 <p21870> of the code that is
07:11:42 * pesco shrugs.
07:11:55 <p21870> 80 chars just doesnt cut it sometimes :)
07:29:15 <musasabi> I put out some haddock documentation for parrows.
08:03:17 <TFK> http://www.jelovic.com/articles/why_people_arent_using_haskell.htm <--- what do you think of this, guys?
08:05:47 <dcoutts_> There's a fsir bit of truth to what he's saying.
08:06:16 <xerox> `fsir' ?
08:06:24 <dcoutts_> fsir/fair
08:06:51 <dcoutts_> "Haskell" of course has been defined as the language spec rather than by an implementation like with perl/python/ruby
08:07:17 <michaelw> and since when are frequent updates a good thing?
08:07:32 <TFK> michaelw, "release early, release often" ;-)
08:07:34 <musasabi> Python,perl or ruby do not ship popular GUI libraries with them.
08:07:43 <dcoutts_> michaelw, it can give an impression of being alive
08:07:50 <TFK> Python ships with Tk. (not popular, but working)
08:07:52 <michaelw> TFK: umh, i like stable environments
08:07:56 <wilx> Well, I must say that some things have really high entry barrier because there is too much of math/set theory involved.
08:08:07 <Igloo> The things he says should be done are largely in the process of being done, though
08:08:24 <TFK> michaelw, that's another school of thought, I suppose.
08:08:27 <musasabi> Some things still lack good presentations - like fundeps.
08:08:30 <dcoutts_> in some ways having a language spec and several implementations is good, but as he points out, it makes it harder for us to market the "one true platform"
08:08:38 <michaelw> dcoutts: fine, let them use ghc HEAD then
08:08:43 <xerox> I think it's crap.
08:08:50 <Igloo> ghc is the one true platform, in practice
08:08:54 <TFK> Well, there are a number of implementations of Python.
08:09:15 <TFK> And now Perl6, which appears to have a few, too.
08:09:19 <dcoutts_> Igloo, that's true of course but people don't say it very loudly
08:09:48 <TFK> musasabi, besides, it is trivial to get wx/GTK bindings, among others.
08:09:53 <Igloo> Maybe that's because it's a bad thing  :-)
08:10:02 <musasabi> I think the largest problem with haskell from the library standpoints is Strings and the IO system (basically one can either use Strings or have good performance there).
08:10:07 <Igloo> I certainly don't think it's kept a secret, though
08:10:21 <musasabi> TFK: yes, the same with Haskell.
08:10:44 <dcoutts_> Igloo, like I said, its a good thing in may ways (having multiple implementations) but marketing is probably not one of them
08:10:57 <TFK> musasabi, I compiled my Gtk2Hs.
08:11:02 <michaelw> somehow he seems to imply that the world revolves around web stuff/text manipulation.
08:11:23 <TFK> musasabi, "trivial" is when you have binaries+docs+demos packaged in a nice cudly way for all platforms.
08:11:35 <michaelw> well, looking at the army of PHP coders, he might be right even
08:11:41 <TFK> heh
08:11:41 * michaelw cries
08:11:51 * xerox joins michaelw in the crying
08:12:06 <musasabi> TFK: there are precompiled packages for many distros...
08:12:20 <dcoutts_> Well we're getting better at packaging Haskell implementations and libs for several distros, Gentoo, Debian, Fedora
08:13:14 <TFK> musasabi, the lucrative user-space is on Windows, actually.
08:13:25 <dcoutts_> and once we've got cabal + hackage going, that should expand significantly (so long as we make sure cabal+hackage are easily automatable by the distro packagers)
08:13:38 <TFK> Anyway, I don't really want to argue, just wondering what you guys think.
08:14:18 <dcoutts_> TFK, I believe there is some code hanging about for turning cabal packages into .msi windows installers that could do with getting integrated with cabal
08:14:57 <musasabi> TFK: that is partly true - but then again I am more interested in language research most of the days.
08:15:40 <TFK> dcoutts, that would be great!
08:16:12 <TFK> musasabi, sure, but the page talks about practical programming (for some definition of "practical")
08:16:15 <dcoutts_> though dependency tracking is not one of msi's strong points...
08:16:21 <TFK> Erm, that came out wrong :-/
08:17:16 <musasabi> TFK: having a way to test things on windows would help too.
08:17:38 <musasabi> Currently I have access to ~10 flavors of *nix, but no windows machine...
08:17:54 * TFK has a WinXP box
08:18:03 * TFK ducks
08:18:18 * boegel greets everyone
08:18:27 <dcoutts_> TFK, have I asked you to test the win32 installer for Gtk2Hs yet?
08:18:28 <musasabi> hello boegel
08:18:29 <boegel> TFK: so have I, but I barely use it
08:18:44 * boegel puts an his spy hat
08:18:52 <TFK> dcoutts, not *yet*... so I gather that you finished it?
08:18:54 <boegel> Itkovian: you weren't on your desk today !
08:19:02 <boegel> s/an/on
08:19:04 <musasabi> a/c
08:19:16 <dcoutts_> TFK, I have, oh good. It'll probably be ready for testing later today...
08:19:39 <TFK> All I need to do is run the unittests, right?
08:19:56 <dcoutts_> boegel, I'm about to send you patches for HRay with Gtk2Hs 0.9.8
08:20:13 <dcoutts_> TFK, was that directed at me?
08:20:27 <boegel> dcoutts_: okay, but I won't be able to test 'em nw
08:20:36 <boegel> I'm on my gf's machine, she's studying :D
08:20:39 <dcoutts_> boegel, np
08:22:22 <TFK> dcoutts, yes
08:23:06 <dcoutts_> TFK, we don't have unit test as such, but compiling and running the demos it usually a good indication of a sucessful installation.
08:23:24 <TFK> Sounds easy enough.
08:23:49 <TFK> (On my part ;-)
08:24:01 <dcoutts_> :-)
08:24:28 <boegel> yo FPBiker
08:27:53 <boegel> still no activity from genneth ?
08:29:15 <boegel> apparently not
08:29:53 * boegel leaves to study his the last chapter of Apple's 'Modern compiler implementation in C'
08:30:02 <boegel> s/his//
08:30:20 <dcoutts_> there goes my adsl...
08:30:25 <boegel> bye adsl
08:31:02 <dcoutts_> boegel, I'll have to wait to send you those patches until my home machine comes back :-(
08:55:29 <sylvan> how does GHC schedule threads? round-robin?
08:56:51 <reffie> it doesn't use pthreads?
08:57:36 <dcoutts_> the threaded GHC RTS uses pthreads to schedule any number of light weight Haskell threads
08:58:00 <dcoutts_> the non-threaded GHC RTS uses just a single OS thread to schedule any number of light weight Haskell threads
08:58:15 <michaelw> is it unb0rken again?
08:58:30 <dcoutts_> I believe the Haskell threads are scheduled round-robin. There is certainly no thread priorities.
08:58:59 <dcoutts_> michaelw, what was broken?
09:01:27 <michaelw> dcoutts_: last time i asked my colleague about threaded RTS he said it's broken, that's all i know (earlier this year)
09:02:53 <dcoutts_> michaelw, you can check the SourceForge GHC bug tracker to see if there are any outstanding threaded RTS bugs. Of course GHC 6.4 has been released since earlier this year so any bug may well have been fixed.
09:03:23 <musasabi> threaded rts has worked fine when I have used it with 6.4
09:04:03 <sylvan> Is there any research going on regarding automatic parallellism in Haskell? With massively multi-core CPU's around the corner any such language will be able to claim they're "64 times faster than C!" etc.
09:04:41 <michaelw> sylvan: ask the GUM/Parallel/Distributed/Mobile Haskell guys :)
09:05:10 <sylvan> where can I find them? =)
09:05:28 <sylvan> Is pH going in the direction of automatic parallellism now?
09:05:48 <michaelw> sylvan: http://www.tcs.informatik.uni-muenchen.de/~hwloidl/ <- there
09:06:03 <sylvan> thanks.. I'll read up on their stuff
09:07:16 <autrijus> hm
09:07:23 <autrijus> anyone used Packrat in place of Parsec?
09:07:31 <autrijus> I'm wondering if it can significantly speed up parsing for Pugs.
09:07:44 <autrijus> (currently in Pugs, parsetime dominates runtime for small scripts)
09:08:35 <michaelw> oh, simonm was here :)
09:10:23 <sylvan> autrijus: why not use Happy?
09:12:33 <dcoutts_> autrijus, is it possible use to use a seperate lexer for pugs, or does the perl lan spec mean that perl programs can change their lexical syntax as well as their grammar while you're parsing them? The lexing can often be the slow bit.
09:13:22 <dcoutts_> For example, GHC has a fast lexer using various low level tricks to minimise copying of strings etc.
09:13:43 <autrijus> dcoutts_: sadly there's
09:13:53 <autrijus> sub infix:<(((> { ... }
09:14:00 <autrijus> and from that point on, ((( is a token that is a infix function.
09:14:10 <autrijus> so no, lexing and parsing can't be separated.
09:14:23 <autrijus> sylvan: because of this rather sick dynamic restriction
09:14:34 <basti_> is that the fish operator?
09:14:44 <dcoutts_> hmm, how much does the lexer change? can one just add a bit of state to the lexer?
09:15:32 <dcoutts_> Eg for parsing C the lexer must maintain a set of identifiers and return different tokens depending on set membership.
09:16:29 <dcoutts_> In your example, could the lexer by told that ((( is a {whatever} token and then return it as such rather than what ever it might have been before?
09:16:50 <dcoutts_> how much does the lexer really change?
09:17:07 <wilx> Hehe, overloading ((( sounds very evil :)
09:17:11 <dcoutts_> (I'm going to make a cup of tea, back in a sec...)
09:18:07 <michaelw> can you seriously do stuff like sub infix:<(((>{...} sub infix:<((((>{...} or are there restrictions to this madness?
09:18:26 <xerox> ...as much as overloading <!-- and --> as "circumfix" ignoring the content, so implementing HTML comments in p6 sources, eheh.
09:19:38 <autrijus> dcoutts_: well, but the diff. thing is that ((( is only a token in infix function position
09:19:42 <autrijus> 1 ((( 3
09:19:48 <autrijus> but in prefix it's still taken to mean three parens
09:19:51 <autrijus> (((1)))
09:19:59 <dcoutts_> ouch
09:20:35 <dcoutts_> so in prefix form it's three ordinary '(' tokens
09:20:39 <autrijus> yup
09:20:51 <autrijus> so a separate lexer pass loses its appeal
09:21:54 <dcoutts_> still, you could probably have a seperate lexer pass using a more dynamic lexer (ie like parsec but optimised for lexing rather than parsing)
09:22:10 <basti_> dons: ping?
09:22:28 <dcoutts_> and use the same monad so you can communicate information back from the parser to the lexer
09:22:42 <Igloo> autrijus: But you could have the parser and lexer in a monad, where the parser updates a table of infix ops and then asks the lexer for the next token
09:22:58 <musasabi> autrijus: I am not sure whether parrows could help you - adding an optimizer pass there is possible, but it is very much beta code.
09:23:24 <Igloo> Oh, but the lexer needs to know context, right
09:23:29 <autrijus> parrows?
09:23:33 <autrijus> Igloo: right.
09:23:42 <autrijus> is that a new name for packrat?
09:23:42 <basti_> parrots?
09:24:00 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/PArrows/
09:24:13 <musasabi> Currently it is very simple.
09:24:20 <autrijus> dcoutts_: which is... actually what Pugs sort of already does
09:24:38 <autrijus> dcoutts_: but the "dynamic lexer" is actually cached ExpressionParser
09:24:45 <autrijus> so it's still parsec
09:24:47 <dcoutts_> autrijus, right
09:24:48 <musasabi> but that is by no means a ready solution.
09:26:41 <autrijus> musasabi: it looks kind of primitive
09:26:49 <autrijus> oh well. I'll fallback to parsec for now.
09:26:50 <dcoutts_> autrijus, perhaps it can still be done with a seperate lexer using "start codes". Basically it adds extra states to the lexer. The parser can update the start code depending on it's parsing context, like "expecting an infix operator" would allow the lexer to return the '(((' token rather than three '(' tokens
09:26:55 <autrijus> it's industrial strength and all
09:27:16 <dcoutts_> See the alex manual for more info on start codes, and the ghc lexer for an example of using start codes.
09:27:28 <autrijus> right, I've seen the ghc lexer.
09:27:52 <autrijus> thanks for the help :)
09:28:00 <autrijus> I'll keep that in mind
09:28:04 <dcoutts_> so if you've got not too many of these parsing modes/contexts it might be doable! :-)
09:28:17 <autrijus> I have finite ones.
09:28:20 <autrijus> problem is it's like 12 or so.
09:28:37 <autrijus> so it will take lots of time to write them down and stuff.
09:28:41 <autrijus> still it may prove fruitful
09:28:43 <dcoutts_> that's not so many. That was about the order of magnitude I was thinking is managable.
09:28:48 <autrijus> so I'll do it when I have next batch of tuits
09:28:58 <autrijus> right. not saying it's not unmanagable
09:29:01 <autrijus> just need tuits :)
09:29:05 <dcoutts_> sure :-)
09:29:26 <autrijus> i.e. out of the "trivial, let's do it now" range :)
09:29:26 <dcoutts_> and you're already using the ghc FastString tricks? or similar
09:29:36 <dcoutts_> I guess so. :-(
09:30:23 <autrijus> oh wow. no.
09:30:26 <autrijus> it looks neat.
09:30:31 <autrijus> how should I use them in parsec?
09:31:08 <xerox> "tuits" ?
09:31:27 <autrijus> cycles.
09:31:28 <dcoutts_> autrijus, I'm not quite sure, but look at ghc ghc lexer monad & StringBuffer bits of code for inspiration
09:31:28 <autrijus> free time.
09:31:33 <autrijus> 'k
09:33:25 * boegel y0ws
09:33:43 * basti_ y0ws boegel 
09:34:42 <xerox> @y0w
09:34:45 <lambdabot> Here I am in 53 B.C. and all I want is a dill pickle!!
09:40:59 <Itkovian> hi boegel
09:41:42 <Itkovian> I was working at home ... well, working is a big work as I wasn't feeling too well today, due to lack of sleep.
09:41:59 <boegel> Elias threw a fit last night ?
09:44:46 <Itkovian> his legs itch
09:44:48 <Itkovian> a lot
09:46:31 <boegel> how come ? some allergy or something ?
09:46:39 <Itkovian> eczema
09:46:45 <Itkovian> gettign worse again
09:46:49 <Itkovian> grr
09:47:04 <boegel> damn :(
09:59:30 <basti_> ia function
09:59:32 <basti_> bah
09:59:33 <basti_> i wanted to type:
10:00:07 <basti_> if i apply several functions that replace one of the elements of a "Data Example Int Int Char String Mytype" in a row
10:00:16 <basti_> will that be optimized in a sane way?
10:00:38 <xerox> What about records?
10:00:49 <basti_> yes what about them =)
10:00:54 <Igloo> Best to look at the -ddump-simpl output and check
10:01:06 <basti_> hmm
10:01:11 <basti_> oh yes that might make sense
10:01:30 * basti_ writes todo
10:01:35 <basti_> :)
10:01:46 <dcoutts_> Igloo, btw do you know when Oege is back from conferences?
10:04:50 <basti_> uhm... records?
10:04:57 <basti_> are records in some standard?
10:06:06 <basti_> i've seen them but are they real? =)
10:07:50 <Igloo> I think this week is the second of 2, but I'm not sure
10:08:15 <basti_> Igloo: survey: how real are records in haskell?
10:08:32 <dcoutts_> Igloo, right, I didn't realise it was for 2 weeks.
10:09:16 <dcoutts_> basti_, they exist, they're vaugely useful. I use them in some programs.
10:09:22 <basti_> ah
10:11:04 <xerox> Yea
10:11:08 <xerox> I can't find the doc O_o
10:13:17 <xerox> http://research.microsoft.com/~simonpj/Haskell/records.html
10:14:03 <basti_> i found that yes
10:15:09 <xerox> By the way, I was probably thiking of GATDs.
10:15:22 <Lemmih> Greetings, SyntaxNinja.
10:15:49 <basti_> uhm
10:16:38 <xerox> data Foo = Foo { a :: Data, b :: Example, c :: Int, d :: Int, e :: Char, f :: String, g :: Mytype }  -- If I understand what you meant.
10:16:57 <basti_> yes thats kinda what i thought
10:17:17 <xerox> Ooh-kay.
10:17:32 * boegel leaves again
10:17:44 <wilx> Hmm, Are the records described in that paper implemented in 6.4?
10:18:14 <basti_> thats what i doubted =)
10:19:53 <xerox> I think not.
10:19:59 <xerox> But I can't find them in GHC's doc!
10:23:05 <xerox> wilx, did you find any doc?
10:33:54 <wilx> Nope.
10:34:18 <SyntaxNinja> hi all
10:35:39 * Lemmih will soon be able to release secure versions of HackageDB, cabal-get and cabal-put.
10:36:18 * basti_ will soon have a Emacs frontend to yi that meets stepcuts demands
10:38:02 * xerox dances around basti_ 
10:38:22 <xerox> ...and Lemmih ^_^
10:38:33 <bourbaki> did i miss anything or why are you all danceing?
10:39:12 <xerox> HackageDB, cabal-get, cabal-put, yi's Emacs frontend... should I continue?? ;)
10:39:18 <dcoutts_> just new  software releases, and while we're at it... dcoutts will soon be able to release Gtk2Hs 0.9.8
10:39:28 <SyntaxNinja> Lemmih: yay
10:40:11 <dcoutts_> Igloo, BTW did my email to the debian haskell list ever get through?
10:41:42 <dcoutts_> it'd be great to have an up to date gtk2hs .deb, and now's the moment to get any build issues fixed upstream... :-)
10:42:32 <xerox> dcoutts_, how difficult would it be to have Cairo bindings?
10:43:00 <dcoutts_> xerox, we're looking into updating and integrating the existing hscairo bindings
10:43:10 <xerox> Great.
10:43:33 <xerox> I would love to use those to make the UI for my Conway's Life ^_^
10:43:53 <dcoutts_> xerox, ah, I was just about to ask if you had particular applications in mind
10:44:24 <dcoutts_> since it'd make it nicely antialisaed and easily zoomable
10:44:47 <xerox> Eeeeeexactly.
10:45:23 <dcoutts_> it's on our list of new features for the 0.9.9 release (along with OpenGL)
10:45:40 <Speck> Hello, funky functors!
10:45:50 <xerox> y0 Speck!
10:46:21 <dcoutts_> xerox, of course it'll be done sooner with more developers' spare time...
10:46:54 <xerox> dcoutts_, is there a roadmap/TODO/timeline somewhere?
10:47:20 <Speck> I'm trying to learn me some Haskell. Pardon my continued ignorance as I hang out here trying to pick up useful gems.
10:47:35 <basti_> hi Speck
10:47:45 <xerox> Speck, you're welcome :)  Do you have any specific question?
10:47:47 <dcoutts_> xerox, there is a list here: http://haskell.org/gtk2hs/development/
10:48:24 <Speck> xerox, not at the moment, no, but I am reading through the Parsec docs (eventually I'd like to parse IIS log files for my work).
10:49:09 <xerox> Speck, IMHO Parsec docs are _really_ nice.
10:49:15 <basti_> whats IIS?
10:49:25 <dcoutts_> basti_, the MS web server
10:49:46 * basti_ coughs
10:49:51 <Speck> Yeah. My work is a MS-only house. I've used some Ruby and Python though, and they basically give me free range over languages if I'm productive.
10:49:54 <bourbaki> hm if you want to make a class that models a ring
10:49:59 <basti_> well let's hope haskell makes it better =)
10:50:12 <Speck> s/range/reign
10:50:15 <bourbaki> how would you do that with respect to another class named Group?
10:50:29 <basti_> :-o
10:50:38 <bourbaki> i mean how do i make the class require that its a group for two different functions?
10:50:45 <basti_> group implies ring?
10:50:55 <basti_> ohh
10:51:11 <basti_> hmmm
10:51:23 <bourbaki> a ring consists of groups
10:51:30 <basti_> yes i remember vaguely
10:51:37 <basti_> it has a + ring and a . ring
10:51:43 <basti_> uhm
10:51:45 <basti_> group
10:51:53 <xerox> Functional dependicies?
10:52:20 <basti_> so you'd need to say: there is a ring of things, that has two different "instances" of group.
10:52:28 <bourbaki> well the add should be a ring and mul also
10:52:42 <bourbaki> but i want to get it on the left side of the =>
10:52:51 <bourbaki> but all i can do is something like
10:53:04 <bourbaki> class Group a => Ring a
10:53:24 <basti_> whats the opposite of "home" called on english keyboards?
10:54:02 <bourbaki> oh wait cant i do something like class (Group a, Group b) => Ring a b ? and then something that relats a and b?
10:54:02 <arjanb> "end"
10:54:13 <basti_> ah thanks.
10:54:26 <xerox> bourbaki, http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#functional-dependencies
10:54:35 <xerox> Does it help?
10:54:45 <basti_> bourbaki: i see a problem in that the ring well be erected over ONE type not over two
10:55:24 <basti_> will
10:55:49 <bourbaki> yes
10:55:59 <bourbaki> but if i also require that a and b are the same
10:56:09 <Speck> Does anyone know of an example of a context-sensitive grammar defined using Parsec?
10:56:19 <bourbaki> then the first of second ring will ensure that there is a multiplication for them
10:56:23 <basti_> hmm okay
10:56:40 <bourbaki> how can i require equality for types in there?
10:56:48 <bourbaki> or do i have to wrap it in a data ?
10:57:10 <basti_> in a fundep? somehow?
10:57:15 <bourbaki> data DRing = CRing a a
10:57:17 * xerox boings
10:57:22 <bourbaki> er
10:57:25 <bourbaki> data DRing a = CRing a a
10:57:46 <bourbaki> so i instanciate the ring with just one time and the class is not beeing used really
10:57:53 <bourbaki> or isnt that a valid construction?
10:58:49 <dcoutts_> Speck, can you find an XML parser is parsec? that requires the ending tag to be the same as the opening which is a context dependency
10:59:18 <Speck> dcoutts_, thanks, I'll do a search :-)
10:59:52 <dcoutts_> it's quite easy to write in parsec with it being monaic and all, just do {tagName <- openTag; body <- elemBody; endTag tagName}
11:00:02 <dcoutts_> monaic/monadic
11:00:31 <dcoutts_> where the extra parameter to endTag is used to check that the end tag matches the opening tag.
11:00:49 <reffie> http://news.bbc.co.uk/1/hi/world/europe/4087370.stm
11:01:05 <astrolabe> bourbaki: A ring is not a group under multiplication.
11:01:21 <Speck> do is monadic syntax sugar though, right?
11:01:31 <bourbaki> astrolabe no not necessarily
11:01:42 <astrolabe> A field without the zero element is a group under multiplication
11:01:57 <reffie> ops
11:02:00 <dcoutts_> Spark, yes, and parsec is monadic so you can use that syntax
11:02:04 <Speck> yes I read that it is basically the state monad
11:02:13 <bourbaki> astrolabe but if i would like to model the other stuff as well i think that haskell wont get me any further would it?
11:02:37 <astrolabe> I know little about haskell :(
11:03:41 <reffie> err
11:03:41 <reffie> http://news.bbc.co.uk/1/hi/world/europe/4087370.stm
11:07:26 <xerox> dons, ping
11:09:41 <xkb> hi
11:09:53 <xkb> Does hugs support list comprehensions?
11:10:47 <basti_> yes
11:10:49 <dcoutts_> xkb, hugs supports all of the Haskell98 language spec (and some extensions) and list comprehsnsions are part of the Haskell98 language spec. (ie yes)
11:11:04 <xkb> ok.. hmm than im typing something wrong :D
11:11:12 <basti_> @plugs [(x,y)|x<-[1..3],y<-[1..3]]
11:11:19 <lambdabot> [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
11:11:49 <dcoutts_> xkb, if it's short (ie one line or so) you can paste it here
11:12:21 <xkb> iputStrLn map fib [ x | x <- [0..92]]$
11:12:31 <xkb> ignore the $
11:13:11 <dcoutts_> well syntactically that's ok, you're getting a type error perhaps?
11:13:30 <dcoutts_> you're probably missing brackets
11:13:32 <xkb> checking now
11:14:00 <dcoutts_> you're applying iputStrLn to three arguments which might not be what you're intending
11:14:42 <dcoutts_> you probably mean: putStrLn (map fib [ x | x <- [0..92]])
11:14:52 <xerox> @plugs let fib = 1 : 1 : [x+y | x <- fib | y <- tail fib] in take 20 fib
11:14:53 <lambdabot> Illegal parallel list comprehension: use -fglagow-exts
11:14:55 <xerox> heh.
11:15:11 <xkb> That returns a type error due to [Int] not being a Char
11:15:32 <Lemmih> Use 'print' instead of 'putStrLn'.
11:16:17 <xkb> ah, thats fine
11:16:26 <xkb> what exactly is the difference?
11:16:34 <Lemmih> print = putStrLn.show
11:16:35 <dcoutts_> xkb, Lemmih's right. And the reason it gave that type error was that we were missing show (which is what print does)
11:16:48 <xkb> ok..
11:16:58 <xkb> good.. this should be a very simple example
11:17:14 <xkb> just to contrast declarative programming vs imperative
11:17:42 <Speck> I like the quicksort example :-)
11:18:02 <xkb> that might be a bit to long
11:18:04 <dcoutts_> xkb, ie the other fix would have been: putStrLn (show (map fib [ x | x <- [0..92]]))
11:18:11 <xkb> should be explainable in about 2 minutes
11:18:46 <dcoutts_> xkb, and you can cut it down to: print [ fib x | x < [0..92] ]
11:19:03 <xkb> ah
11:19:06 <xkb> good idea
11:19:34 <dcoutts_> because: map f xs = [ f x | x <- xs ]
11:19:53 <xkb> and still easy to explain :D
11:20:02 <dcoutts_> and there is a similar rule for filter that you might come across
11:20:34 <Speck> what is the definition of fib in those pieces of code?
11:20:44 <xkb> the non-effective one :D
11:21:22 <xkb> as in fib 0 = 0, fib 1 = 1, fib n = fib (n-1) + fib (n-2)
11:22:36 <Speck> so for each element in the list [0..92] the above algorithm is applied?
11:25:37 <kowey> Hi haskellers.  Is there a standard strict list library I can use?
11:25:53 <Heffalump> no
11:25:58 <Heffalump> (that I know of)
11:26:15 <kowey> ok... so i make my own one-off thing?
11:26:20 <Lemmih> kowey: Why would you want a strict list?
11:26:25 <kowey> well...
11:26:33 <kowey> i've got this piece of really slow code
11:26:43 <dcoutts_> I know that story!
11:26:43 <kowey> and i use trees a whole lot... so i thought maybe with strict trees
11:26:56 <kowey> (actually, not so much slow code, but very memory-hungry code)
11:26:59 <Lemmih> kowey: Profile!
11:27:04 <kowey> huge swaths of lag and void
11:27:05 <dcoutts_> I know that sotry too!
11:27:30 <kowey> Lemmih: well... that *is* us profiling
11:27:57 <kowey> anyway, strict trees don't do any good... but then i realised that to have strict trees, you need strict lists, no?
11:28:18 <dcoutts_> yes, I found that profiling isn't very helpful for pinpointing the cause of space leaks etc
11:28:38 <Speck> I thought that lazy lists consumed less memory (all at once)
11:28:54 <dcoutts_> kowey, you're using trees with lists of elements at each node (ie a rose tree)?
11:29:03 <kowey> yep
11:29:10 <kowey> uh.. wait
11:29:19 <kowey> maybe... we were using Data.List
11:29:28 <kowey> and we first tried to build a drop in replacement
11:29:32 <dcoutts_> which is the standard list
11:29:40 <kowey> oops. Data.Tree, i meant
11:30:08 <dcoutts_> right, so for the tree itself to be strict then the list would need to be strict too, or used strictly each time
11:30:17 <kowey> oof...
11:30:25 * kowey writes flatten and map for his strict lists
11:30:54 <dcoutts_> or just use listSeq in one or two places
11:31:07 <kowey> also, if anyone knows how to profile intelligently: http://www.haskell.org/hawiki/Profiling please help flesh this page out
11:31:25 <kowey> dcoutts_: can you point me to some doc?
11:31:32 <dcoutts_> about?
11:31:32 * basti_ darcs sends a patch for yi-emacs to dons
11:31:38 <kowey> listSeq
11:31:42 * kowey googles
11:31:44 <xkb> Speck: yes (late answer to your question_
11:31:59 <Speck> thanks
11:32:11 <dcoutts_> listSeq is just seq on the structure of the list
11:33:08 <basti_> somewhat like map seq?
11:33:15 <basti_> (if you could do that)
11:33:19 <Speck> Before I spend any more time pulling my hair out, can someone with Parsec experience tell me if it is possible to take the log format described here(http://www.w3.org/TR/WD-logfile.html) and turn it into a sanely typed, lazy list of tuples? (each tuple representing one http request).
11:34:17 <Speck> I don't want to spend so much time wrapping my head around a non-yacc-like parser generator just to find out it's impossible
11:34:35 <Philippa_> if yacc can do it, parsec can
11:34:37 <basti_> oh i'd take any bet it is
11:34:45 <Speck> the thing is, I don't think yacc can do it
11:34:50 <basti_> hah!
11:34:51 <basti_> =)
11:35:00 <basti_> thats the problem
11:35:01 <Philippa_> if in doubt you can grab the entire input string and alter it, so Parsec's effectively turing complete
11:35:19 <Philippa_> it's probably pretty close to it even without that ability
11:36:21 * boegel greets again
11:36:29 * basti_ regreets boegel
11:36:42 <bourbaki> hey boegel
11:36:57 <bourbaki> is there some secret haskellian handshake or so?
11:37:23 <basti_> maybe the HSU guys know
11:37:56 <boegel> bourbaki: err, not that I know of
11:38:09 <boegel> bourbaki: have you seen my HaskLS progress ?
11:38:33 <bourbaki> no where is it?
11:38:36 <basti_> yes where?
11:39:06 <bourbaki> :)
11:39:08 <Speck> ooh, L-systems. pretty!
11:39:14 <bourbaki> where is the progress of the haskls
11:39:20 <bourbaki> is there something seealbe?
11:39:21 <boegel> http://scannedinavian.org/~boegel/HaskLS
11:39:31 <boegel> bourbaki: yep :)
11:39:35 <bourbaki> is that yours?
11:39:36 <boegel> screenshots
11:39:44 <boegel> bourbaki: it is, yeah
11:39:57 <bourbaki> you could to a rotation effect with the sirpinsky triange thingy:)
11:40:30 <boegel> bourbaki: try the darcs repo, it _is_ rotating
11:40:36 <bourbaki> ok if you want to do all that in 3d now you need to make at mest a dynamicaly difinable turtle
11:40:43 <bourbaki> oh heh :)
11:40:58 <bourbaki> so you can do textures and shape with the turtle in the 3d case
11:41:02 <boegel> bourbaki: it is 3D :)
11:41:15 <boegel> bourbaki: the trees are in 3D
11:41:16 <bourbaki> ah ok well its not voluminous
11:41:17 <bourbaki> yet
11:41:33 <bourbaki> if you get shapes in the positions of the joints of you lines now
11:41:58 <bourbaki> then you can connect the points of these "equipotential" lines at the joints
11:42:20 <bourbaki> where the joints have that shape that is orthogonal to the line itself and a texture
11:42:27 <boegel> bourbaki: it is voluminous, the tree is real 3D, not just a 2D rotating
11:42:37 <bourbaki> so every connection between two joints form a cylinder
11:42:53 <basti_> boegel: impressive
11:42:54 <bourbaki> no i mean its all lines not cylinders with a volume
11:43:07 <basti_> boegel: so did you do it monadic?
11:43:18 <boegel> bourbaki: ah no, you're rigt there
11:43:29 <boegel> basti_: no, not really
11:43:34 <bourbaki> boegel and that where my splines come into play
11:43:48 <basti_> -g-
11:43:57 <boegel> because I don't know how really :) maybe tht would be an interesting exercise for me
11:44:12 <boegel> I'm not that familiar with monadic stuff
11:44:15 <bourbaki> a cylinder that has as caps two cloesd splines can easily be done with a homotopy
11:44:38 <bourbaki> a state monad should to the job
11:45:53 <dcoutts_> kowey, try this...
11:45:54 <dcoutts_> listSeq :: [a] -> ()
11:45:54 <dcoutts_> listSeq [] = ()
11:45:54 <dcoutts_> listSeq (x:xs) = x `seq` listSeq xs
11:46:03 <boegel> bourbaki: hmm, so using your spline stuff would easily generate cylinders instead of lines ?
11:46:11 <bourbaki> boegel did you make it make use of parameterized symbols?
11:46:32 <kowey> dcoutts_: hmm... to be honest (should have spoken up sooner)
11:46:33 <bourbaki> boegel the idea is that ... ie think of the first think of the tree the root
11:46:40 <kowey> i'm still not used to the idea of seq
11:46:57 <kowey> ok, so x `seq` y, evaluates x, then evaluates y
11:46:58 <bourbaki> it starts in one point and that is on the ground on the ground you have a circle as a shape
11:47:09 <dcoutts_> kowey, and you can use it like "listSeq listToEnsureIsFullyEvaluated `seq` TheValueToReturn"
11:47:12 <bourbaki> and then in the next position you have lets say an ellipse
11:47:18 <bourbaki> then you want to have something like
11:47:44 <bourbaki> spline1( lambda ) = pos_on_spline_1
11:47:44 <kowey> so strictMap would be something like
11:47:52 <bourbaki> spline2( mu ) = pos_on_spline_2
11:48:01 <bourbaki> and now the homotopy comes into play
11:48:05 <kowey> strictMap fn xs = listSeq xs `seq` map fn xs
11:48:21 <boegel> bourbaki: I did use parameterized symbols, yes (as in F meaning forward, < meaning left rotation along the Z axis, and so on...)
11:48:41 <dcoutts_> kowey, no that ensures the list is fully evalueated and then maps over it, you want the other way around
11:49:08 <dcoutts_> strictMap fn xs = let result = map fn xs in listSeq result `seq` result
11:49:11 <bourbaki> hom( spline1, spline2, t1, t2 ) = spline( spline1( t1 ), spline2( t1 ), t2 )
11:49:38 <bourbaki> boegel i mean that along the < and turn symbols you also have a variable along that tells you the amount
11:49:55 <kowey> and the whole thunk thingy makes it so we're not actually doing the same thing twice
11:50:05 <kowey> (sorta swimming here)
11:50:06 <bourbaki> that way you can do animations of the thickness of branches of changeing textures like makeing the bark darker where the tree is older or so
11:50:46 <dcoutts_> kowey, well, probably, or it could be deforested at compile time, but then again it might not
11:50:46 <bourbaki> there also are growth models with lsystems that make use of the nutrition of the plant propageteing stuff throught the lsystem string and so
11:51:10 <kowey> hmm... well, let's run this through the testing apparatus and see what pops out
11:52:37 <boegel> bourbaki: yeah, the angle of rotation is also parameterized (but only 1 angle for all rotations though)
11:52:43 <dcoutts_> kowey, if you're only using map etc over the lists in a couple places it might make sence to define custom strictMap strictFold, but it's not a style that is generally encouraged
11:53:08 <kowey> really? isn't it good to refactor?
11:53:15 <boegel> bourbaki: interesting stuff, L-systems
11:53:18 <bourbaki> boegel what you want to have is a string like
11:53:18 <boegel> and very powerfull
11:53:20 <kowey> well... actually, i guess it's only used in flatten
11:53:26 <bourbaki> rot(100) or so
11:53:38 <bourbaki> not just rot_left and rot_right with fixed angles
11:54:07 <boegel> oh, no, don't have that (yet), but that shouldn't be too hard
11:54:13 <bourbaki> i also thought about building neural nets with lsystems once :)
11:54:27 <bourbaki> right but itll be really helpfull and such
11:54:40 <boegel> bourbaki: I kinda stuck to the basics
11:55:00 <bourbaki> what we need to think really hard about is a mesh class
11:55:32 <bourbaki> so you bulid up the string and then linearizize the plant and push that into the string
11:55:36 <bourbaki> er mesh class
11:55:54 <bourbaki> do you know what i mean?
11:56:46 <boegel> yeah, you mean describing the L-systems using polygons or so ? or creating a different type especially for L-system output ?
11:57:01 <bourbaki> no just to render it in the end
11:57:14 <bourbaki> i want to model the plant with these cylinders
11:57:23 <boegel> I have to go though, my gf is complaining my typing is interfering with her studying
11:57:25 <bourbaki> in a realvalued 3d space
11:57:30 <bourbaki> :)
11:57:32 <bourbaki> heh
11:57:38 <bourbaki> the power of love ;)
11:57:44 <boegel> bourbaki: oh, I see, describing the L-system some way ?
11:57:56 <bourbaki> right and you cant render that
11:58:05 * boegel ducks as his gf throws some stuff at there
11:58:10 <boegel> "in a minute dear !"
11:58:11 <bourbaki> but there are easy techniqutes to get triangles of that space then
11:58:28 <boegel> bourbaki: I see
11:58:38 <bourbaki> but thats quite easy and i can explain that to you later
11:58:45 <bourbaki> you also can optimize it that way
11:58:45 <boegel> well, you might mention some of your idea's on th HaskLS wiki
11:58:52 <boegel> @wiki HaskLS
11:58:53 <lambdabot> http://www.haskell.org/hawiki/HaskLS
11:58:56 <bourbaki> sure :)
11:59:11 <boegel> I really have to go now
11:59:14 <bourbaki> bye
11:59:19 <bourbaki> and good day to your gf ;)
11:59:22 * boegel ducks for an incoming chair
11:59:24 <boegel> bye
11:59:28 <boegel> ;)
11:59:43 <boegel> (be back within 2 hours orso)
12:06:54 <tic> meep sond.
12:09:22 <ndm> does anyone know anything about GHC's .hi files
12:09:38 <dcoutts_> ndm, a bit what's the question
12:09:38 <ndm> particularly if you can "pretty print" them, or convert them into text in some way
12:09:52 <ndm> its for hoogle
12:09:57 <Lemmih> ndm: ghc --show-iface
12:09:58 <dcoutts_> yes you can get ghc to dump a text representation
12:09:59 <ndm> i'd like to extract types etc
12:10:08 <dcoutts_> Lemmih, beat me to it :-)
12:10:10 <sond> tic, yo
12:10:11 <ndm> thanks very much!
12:10:15 <Lemmih> ndm: There's also a .hi parse in hs-plugins.
12:10:20 <Lemmih> parse/parser
12:10:40 <ndm> oh, that would be very handy :)
12:10:41 <xerox> dons, ping
12:10:51 <xerox> ndm, hi! How is hoogle going? :)
12:11:13 <dcoutts_> ndm, if it's just for types, you can probably get away with grep + sed on the text output
12:11:15 <ndm> i have got a spec for version 3's search files
12:11:26 <Igloo> dcoutts_: Yes
12:11:27 <ndm> it includes lots of extra info - classes, instances, modules, type = etc
12:11:34 <xerox> Great!
12:11:41 <xerox> ndm, is there a repository now?
12:11:47 <tic> sond, 'sup?
12:11:50 <ndm> nope, still no repository
12:11:51 <dcoutts_> Igloo, you're talking about the mail to debian haskell I presume?
12:12:08 <ndm> i have heard i can do cvs -> darcs, and then shove darcs on my web space
12:12:33 <ndm> if anyone has any details i'd be interested, but i can probably figure it out given time
12:12:44 <ndm> the other problem is i need more web space
12:12:48 <ndm> my uni gives 5mb
12:13:04 <ndm> 3 hoogle binaries (mac, linux, win) is about 3mb, and the docs are about 1.5mb
12:13:12 <kowey> ndm: http://darcs.net/DarcsWiki/Tailor
12:13:13 <Igloo> yup
12:13:15 <ndm> so i'll ask for more space
12:13:20 <dcoutts_> Igloo, great. How do you estimate our chances? :-)
12:13:34 <xerox> ndm, I think you can mail shapr for some space on scannedinavian if needed.
12:13:54 <ndm> xerox, thanks - but it should be easy enough to get more space
12:13:55 <Igloo> I'm sure someone will package it eventually  :-)
12:14:08 <dcoutts_> :-)
12:14:09 <ndm> i have another 200mb account around the place that is empty - its just less convenient
12:14:27 <ndm> kowey: thanks, will read that tomorrow - looks perfect
12:14:31 <xerox> ndm, I'm looking forward to the darcs repo && new sources to lookup :-)
12:15:47 <ndm> i have various plans
12:15:55 <ndm> a ghc -> new interface format project
12:15:59 <ndm> massive refactoring
12:16:04 <ndm> then adding class/instance support
12:16:11 <ndm> then GUI's for various platforms
12:16:27 <ndm> by the end it should search the whole of GHC's libraries, in a lot more depth than currently
12:17:14 <xerox> Sounds nifty.
12:21:48 <dcoutts_> ndm, yes the reference docs for Gtk2Hs and wxHaskell are very large and although I think they are organised reasonably well, some search feature would be really nice.
12:22:05 <ndm> well, i'm hoping after its all done together properly
12:22:20 <ndm> i'll be able to have a wget service - projects put up their interface files, hoogle pulls them in
12:22:30 <ndm> and then it searches all the different projects from one place
12:22:41 <sond> tic, nothing much..
12:22:49 <xerox> ndm, it could be useful to have to possibility to search only in some hierarchyes of libs, don't you think?
12:23:02 <ndm> yes, definately
12:23:04 <tic> sond, okay. planning on doing something? :)
12:23:05 <dcoutts_> ndm, and you can probably get most of that information automatically from the cabal files for any library in hackage
12:23:13 <sond> tic, hmm.. i should :)
12:23:25 <ndm> i am going to supply one way (.hi -> .hoo) convertor
12:23:38 <ndm> i know someone who is working on a documentation tool, which will spit out .hoo files
12:23:50 <dcoutts_> ndm, would the .haddock files provide enough info?
12:23:52 <ndm> and i have talked to someone about nhc's .hi files, and think i can do them
12:23:59 <ndm> not that i can see
12:24:00 <dcoutts_> many projects already generate these
12:24:12 <ndm> i think it strips the types, and .haddock is mainly for linking
12:24:25 <ndm> (but i may well be wrong, i only examined the binary .haddock)
12:24:37 <dcoutts_> oh, if it strips the types then that's no good.
12:24:38 <ndm> i have a convertor from haddock's HTML -> .hoo
12:24:50 <ndm> and i have hacked haddock, and have that generating .hoo files
12:25:08 <Lemmih> Neat.
12:25:08 <dcoutts_> I was just about to say that you could add another haddock backend
12:25:21 <ndm> but .hi -> .hoo would be the best, as its total information (if it lists it all)
12:25:50 <ndm> i have done, but its not fun - its basically walking GHC's abstract syntax tree
12:26:10 <dcoutts_> ndm, it certainly lists exported function names and their types
12:26:16 <ndm> i'm not convinced their is a lot of gain by tying it in to haddock - most of the code is the same as if I just imported GHC's parser
12:26:28 <ndm> yes, but so does the syntax tree
12:26:43 <ndm> and most of the code for doing types and function names is very tied to the HTML output
12:28:01 <kowey> hmm... before strict tree: 3.8G, after strict tree: 4.0G
12:28:08 <kowey> (dcoutts_)
12:28:20 <kowey> 4.1, to be precise
12:28:37 <dcoutts_> ho hum.
12:28:50 <kowey> relevant code here, if interested: http://www.loria.fr/~kow/darcs/UnstableGeni/src/geni/General.lhs
12:29:16 <kowey> my strictConcat feels a little silly
12:29:33 <dcoutts_> yes, I see what you mean
12:30:55 <dcoutts_> kowey, so what makes you suspect that it's the trees that are the problem? how big are these trees? do you expect their fully evaluated form to take less space?
12:31:16 <kowey> well... the first clue is that the whole software is based on trees
12:31:22 <kowey> (it's a natural language generator)
12:31:24 <dcoutts_> it may be that the fully evalueated trees take more space
12:31:49 <kowey> uhm... we had profiling evidence, but i don't remember where i put it :-(
12:33:00 <kowey> as for their fully evaluated forms... maybe?
12:33:07 <kowey> you know about this biological profiling stuff, right?
12:33:30 <kowey> we don't really know how to use it... but we seem to be carrying around huge amounts of drag and void
12:33:54 <kowey> and since the bulk of the data we're pushing around is trees... we figured it might be something related to them
12:34:31 <dcoutts_> I'd try this as an experiment: calculate the result, do a GC, pause for keyboard input (so you can check the memory useage) then do a deepSeq over the result (see NFData class in Control.Parallel.Strategies) and GC and pause for keyboard input again and check if the memory usage has gone up or stayed the same.
12:34:36 <xerox> Is there anything like ctags for Haskell?  I'd really love to use it with Emacs' M-. !
12:34:59 <kowey> xerox: how about http://www.cl.cam.ac.uk/users/rje33/software.html?
12:35:07 <dcoutts_> kowey, that is part of the procedure I followed when debugging c2hs's extreem memory requirements
12:36:07 <xerox> kowey, it looks like exactly what I searching for, thanks much!
12:36:27 <kowey> hmm... ok, i don't think i understand
12:36:44 <kowey> wait...
12:36:53 <dcoutts_> kowey, I have to say I was always rather sketchy when it acme to interpreting the heap profiling results
12:37:03 <dcoutts_> acme/came
12:37:21 <kowey> when you say results, you're talking about the final output of my program?
12:37:40 <dcoutts_> or whatever is the large intermediate tree value you end up with
12:37:51 <dcoutts_> tree(s)
12:37:55 <kowey> hmm...
12:38:03 <kowey> i guess the thing is i'm producing not one very large tree
12:38:09 <kowey> but a whole lot of them
12:38:21 <kowey> (which makes me thing that i'd not only need strict trees,
12:38:25 <kowey> but strict lists of strict trees
12:38:28 <kowey> arrrrrrgh!
12:38:47 <dcoutts_> actually, you may be able to use the lazyness to your advantage
12:38:54 * kowey would love to
12:39:12 <kowey> hmm... what could we do?
12:39:32 <xerox> @karma+ kowey -- it works like a charm
12:39:33 <lambdabot> kowey's karma has been incremented
12:39:55 <kowey> thanks! today is the first time i've actually managed to help people
12:39:58 <dcoutts_> if the elements are reasonably independant you can produce and consume the lists lazily and so they whole list of large trees never needs to be fully evaluated and kept in memory
12:40:53 <kowey> uhm... ok. before we run through this train of thought
12:41:03 <kowey> would you agree with me (perhaps sketchily)
12:41:13 <kowey> that (a) if i believe that strict trees would help
12:41:24 <kowey> but (b) i know that i am manipulating lists of trees
12:41:40 <kowey> then in all likelihood, my strict trees are of no use unless i have strict lists of strict trees
12:41:55 <Speck> Oh... I must be tired. I didn't notice that the `do' notation the Parsec docs use is different from what I'm familiar with. What's with the brackets and all those semicolons?
12:42:06 <kowey> but my assesment is that : this is getting too complicated... and not worth it, so therefor i should abandon the strict tree idea
12:42:14 <dcoutts_> kowey, yes, since your "strict" trees contain lazy lists of strict trees
12:42:25 <kowey> well, not inside the tree itself
12:42:27 <kowey> but outside of it
12:42:36 <kowey> as in, my program produces a list of trees
12:42:41 <kowey> (each tree is a sentence)
12:42:48 <dcoutts_> that's fine
12:42:54 <kowey> it's not that i have one huge tree which is eating memory, but a ton of medium sized oens
12:43:00 <dcoutts_> right
12:43:01 <xerox> kowey - What is your program, if I could ask?
12:43:05 <kowey> so, i should *not* feel guilty about giving up on strict trees?
12:43:16 <dcoutts_> kowey, no :-)
12:43:19 <kowey> it is a natural language generator
12:43:24 <kowey> you give it a logical form like
12:43:27 <kowey> "loves(j,m)"
12:43:36 <kowey> and a natural language grammar
12:43:40 <kowey> and it gives you sentences like
12:43:44 <kowey> "John loves Mary"
12:44:01 <xerox> prolog? :)
12:44:01 <kowey> http://www.loria.fr/~kow/
12:44:03 <Lemmih> Speck: "do { x; y; x}" == "do x\n   y\n   z\n"
12:44:11 <kowey> :-) classroom
12:44:18 <xerox> ah-ha!
12:44:32 <kowey> actually, maybe, but the guy who wrote the generator wrote it in haskell
12:44:39 <kowey> i just took over last year
12:44:49 <Speck> Lemmih, ah, I see. So it's explicit instead of using layout?
12:45:00 <Lemmih> Speck: Exactly.
12:45:02 <kowey> ok! thanks dcoutts_! i'll sleep on all this and talk with the original author
12:45:10 <goron> Anyone in here that can recommenend a good OpenGL book(phiysical book)? I have had an undergraduate course in Graphics.
12:45:13 <kowey> maybe he'll have some other ideas to explore
12:45:18 <kowey> night all
12:45:31 <Speck> Lemmih, if I were to use layout, does the indentation on <|> and such matter?
12:45:33 <xerox> 'night kowey
12:45:43 <Lemmih> Speck: Yes.
12:45:58 <Speck> What should it align with?
12:46:33 <ndm> ok, my success getting cvs -> darcs was none
12:46:38 <Lemmih> Speck: The 'do'.
12:46:40 <ndm> i'm off home now, but i'll have another go tomorrow
12:46:48 <Speck> ah, I see. thanks much Lemmih
12:47:15 <xerox> @index modifyMVar
12:47:17 <lambdabot> Control.Concurrent.MVar, Control.Concurrent
12:50:14 <xerox> basti_, do you have completed the Emacs frontend to Yi? :-)
12:50:24 <basti_> no
12:50:36 <basti_> but its getting more useful every incarnation
12:51:15 <nmoore> hi, is there an environment like hugs that is compiler rather than interpreted? it's a drag to have to write main methods and then use ghc all the time
12:51:35 <basti_> ghci?
12:51:38 <sjanssen> nmoore: ghci?
12:52:01 <nmoore> when i load it up it says "interpreted"
12:52:42 <basti_> it basically is ghc with an interaction frontend
12:52:51 <basti_> nearer to compilation than hugs in any case
12:53:07 <Lemmih> It compiles to bytecode or something like that.
12:53:52 <sjanssen> nmoore: you can use GHC to compile to .o's, and then ghci will use those
12:54:14 <xerox> basti_, if you care you could put in the patch you're sending this correction: "instructoins" in place of "instructions" (oi -> io) in Editor.hs :)
12:54:37 <nmoore> basti_, Lemmih, sjanssen: thanks to all
12:55:42 <basti_> xerox: fixed it. Will get to dons with the next patch sent
12:56:07 <basti_> you can do so too btw, if you darcs got it
12:56:13 <xerox> nmoore, in GHCi you also have the possibility to create persistent let bindings like "let <name> = <expr>" without the "in <expr>" part.
12:57:01 <xerox> basti_, I know, but that was soooooo little, dons will kill me some time for keep getting the smallest patches ever from me :-)
12:57:08 <basti_> lol
12:57:09 <basti_> ok
12:57:15 <xerox> i.e.
12:57:18 <xerox> @botsnack
12:57:18 <lambdabot> :)
12:57:22 * xerox hides
12:58:07 <basti_> hmm
12:58:09 <basti_> @botsnack
12:58:10 <lambdabot> :)
12:58:19 <basti_> whats the fun?
12:58:40 <xerox> aiskiii does have a smiley-randomizer, but it's secret developing code for now.
12:59:07 <xerox> basti_, it's not fun, it's for feed lambdabot after its hard work!
12:59:32 <basti_> ah i see.
13:01:04 <nmoore> xerox: good tip
13:02:56 <nmoore> so what is hugs good for? ;-)
13:03:16 * xerox hugs nmoore
13:04:31 <basti_> @plugs [1..5]
13:04:39 <lambdabot> [1,2,3,4,5]
13:05:11 <Lemmih> hugs is fast and very portable.
13:05:33 <xerox> ...and has a nice win32 GUI?
13:06:21 <basti_> yes, the compilation trade off...
13:06:34 <basti_> interpreters are faster for quick development
13:06:42 <nmoore> i suppose that's a good enough reason, but the GUI is no great shakes IMO
13:07:00 <michaelw> basti_: faster than what?
13:07:21 <basti_> starting hugs and trying a little program is faster than compiling it and running it then
13:07:23 <TFK> The win32 gui is very nice.
13:07:32 <TFK> It is much nicer than the black-and-white dosbox.
13:10:53 <SamB> basti_: it depends! which is why ghci is so cool!
13:11:03 <Speck> hmm... I have problems with ghci
13:11:27 * Lemmih grabs his uni and juggle balls, and leaves.
13:11:28 <SamB> Speck: is it not ported to your platform?
13:12:24 <Speck> It might be a problem with my setup, but I basically can't use the directional keys without invisibly corrupting my line.
13:13:07 <Speck> up/down aren't like readline (as I expected)
13:13:27 <Speck> and left/right aren't bounded by the current expression (they go before the first char and after the last)
13:13:42 <Speck> of course other than that it's awesome :-)
13:17:18 <Speck> does ghci use the readline library?
13:17:18 <SamB> Speck: what OS are you on?
13:17:24 <Speck> windows/cygwin
13:17:27 <SamB> ah
13:18:06 <SamB> you can't expect the win32 terminal emulator to work very well :-(
13:18:16 <Speck> I'm using rxvt
13:18:24 <SamB> hmm
13:18:46 <SamB> maybe it works better with the win32 one, then...
13:19:00 <Speck> it's the same behavior with either one
13:19:20 <SamB> that is odd.
13:19:41 <SamB> it works *quite* nicely on my Unix box...
13:19:46 <Speck> yeah it's basically acting like it wants readline
13:20:09 <Speck> I wish I could run *nix on the computer -- but it's from my work and I'm forced to use XP
13:21:29 <SamB> hmm, mine is linked to libncurses.so.5
13:21:51 <SamB> oh, actually readline too
13:22:11 <SamB> but for some reason ldd printed that line with more indentation so I missed it...
13:23:22 <Speck> I had ncurses, but not readline
13:24:02 <SamB> % ldd /usr/lib/ghc-6.4/ghc-6.4
13:24:02 <SamB>                 libreadline.so.5 => /lib/libreadline.so.5 (0x40033000)
13:24:02 <SamB>         libncurses.so.5 => /lib/libncurses.so.5 (0x40060000)
13:24:58 <Speck> installing readline doesn't fix it, but no matter
13:25:35 <SamB> well yeah. if it doesn't link readline, nothing will help much. except maybe a native Cygwin port of ghc, I guess...
13:26:06 <Speck> I just need to type carefully
13:26:30 <SamB> I have history and everything.
13:26:37 <Speck> *jealous*
13:26:55 <SamB> the best solution is probably to use *nix ;-)
13:29:55 <xerox> dcoutts_, ping
13:30:05 <dcoutts_> xerox, hello
13:30:20 <xerox> dcoutts_, do you know how difficult would be to do FreeType bindings?
13:31:08 <dcoutts_> xerox, I'm afraid I don't, it's not a GObject based lib so the Gtk2Hs code gen tools won't help.
13:31:21 <dcoutts_> what do you need it for?
13:31:41 <xerox> dcoutts_, it's in the TODO list of hscairo, so I was wondering about helping that way.
13:32:09 <xerox> dcoutts_, in fact I would love if you can tell me what do you mean by "improving hscairo".
13:32:27 <dcoutts_> Oh, I'm not sure it's that important, it's a fairly low level library that's wrapped pretty well by the higher level stuff (eg pango, cairo)
13:32:54 <xerox> "* Implement undone functions
13:32:54 <xerox>   - cairo_ft_* (will require Freetype binding to do properly... ugh)"
13:33:02 <dcoutts_> xerox, ok let me explain the hscairo TODO list slightly better...
13:33:10 <xerox> Great.
13:33:42 <dcoutts_> so hscairo needs updating to the latest cairo API (there has been a bit of API churn in cairo 0.4 and 0.5)
13:34:23 <dcoutts_> then there are probably miscelanious other little bits that need doing in hscairo and then there is Gtk2Hs integration...
13:34:54 <dcoutts_> One problem is that hscairo uses a properties API and Gtk2Hs uses a properties API, and they're not the same :-(
13:35:15 <dcoutts_> they can probaly be made compatible, just by picking one version or the other.
13:36:13 <dcoutts_> We're not quite sure yet if we should just absorb hscairo (and make it use c2hs) or depend on it externally (which makes things like sharing the properties API more tricky)
13:36:58 <xerox> I think I understand.
13:37:19 <dcoutts_> one of the first things to do is just start talking more with the hscairo author to get a good picture of how what he thinks needs doing, and how much time he thinks he can devote to the issues.
13:38:16 <xerox> Hmm
13:38:19 <dcoutts_> So if you want to help, a good place to start would be by sending some emails hither and thither to establish just what needs to be done and who might be able to do it
13:38:37 <xerox> I have just some hours left :-)
13:38:53 <dcoutts_> you don't need to understand the gtk2hs code base to help with this one which is nice
13:39:30 <xerox> OK, I'll try to make the point in the proposal I want to sent do Google Summer of Code project.
13:39:54 <dcoutts_> oh, cool.
13:39:56 <boegel> yo everyone
13:40:01 <dcoutts_> hia boegel
13:40:02 <boegel> dcoutts_: how about that patch ?
13:40:11 <boegel> @seen bourbaki
13:40:12 <lambdabot> I saw bourbaki leaving #haskell 47 minutes and 10 seconds ago.
13:40:15 <boegel> damn
13:40:17 <dcoutts_> let me see if my home machine is back online...
13:40:47 <dcoutts_> boegel, or I can send you the patch file by IRC can't I? (not quite sure how...)
13:41:26 <boegel> dcoutts_: maybe it's better by mail...
13:41:40 <dcoutts_> boegel, no home machine with my email is offline (and a good 10 min walk away!)
13:41:46 <boegel> it probably won't work by IRC, since I'm behind a router that has no ports mapped
13:42:05 <dcoutts_> oh, it needs direct connection does it?
13:42:20 <dcoutts_> I can post it to a bit of web space...
13:42:22 <boegel> dcoutts_: I don't get it... there's _no_ way you can email me the patch ? even not with hotmail or that kinda crap ?
13:42:29 * Speck grumbles about many1 not being called oneOrMany, etc.
13:42:57 * boegel waves at Itkovian
13:43:22 <dcoutts_> boegel, http://haskell.org/~duncan/gtk2hs/hray-gtk2hs-0.9.8.darcs.patch
13:43:50 <Speck> haskell has something to learn from ruby's readability pseudo-standards
13:44:11 <boegel> dcoutts_: okay, I'm kinda new to darcs
13:44:23 <boegel> where do I put this patch, and how do I use it ?
13:44:30 <dcoutts_> boegel, it looks like darcs can't apply straight from a url
13:44:43 <dcoutts_> you need to wget and then darcs apply
13:44:54 <dcoutts_> wget http://haskell.org/~duncan/gtk2hs/hray-gtk2hs-0.9.8.darcs.patch
13:44:59 <dcoutts_> darcs apply hray-gtk2hs-0.9.8.darcs.patch
13:45:07 <boegel> dcoutts_: okay, thank
13:45:08 <boegel> +s
13:45:32 <dcoutts_> and then review the patches (I've tried to do them in little bits to make it comprehensable)
13:45:44 <boegel> okay
13:46:28 <boegel> err, should apply show some output ?
13:47:37 <dcoutts_> dunno really :-)
13:47:46 <boegel> it doesn't
13:48:06 <dcoutts_> I guess it has already recorded the patches
13:48:15 <dcoutts_> you can unrecord them
13:49:16 <boegel> nah, I'll just look at them in the patch itself, it's ok :)
13:49:47 <dcoutts_> perhaps darcs apply --interactive would be what you want here
13:50:10 <boegel> oh, well, that's a reminder for the next time...
13:50:26 <boegel> I'll make the patch available on the HRay website too, thanks dcoutts_ !
13:50:29 <dcoutts_> I'm a darcs newbie too :-)
13:52:13 <dcoutts_> boegel, and the fix for the memory game just involves swapping the args of toggleButtonSetActive
13:52:25 <boegel> fix ? which fix ?
13:52:57 <boegel> oh, to make it 0.9.8 compatible ?
13:53:23 <dcoutts_> the args for toggleButtonSetActive were the wrong way round and we fixed that in Gtk2Hs 0.9.8, so the memory game would need to be updated too.
13:53:37 <boegel> dcoutts_: okay, no problemo :)
13:53:51 <dcoutts_> We mane a bunch of minor API fixes in 0.9.8 (which will be detailed in the release notes)
13:54:29 <boegel> okay
14:05:39 <megaman> hi
14:05:48 <boegel> dcoutts_: darcs repo and website updated for HRay :)
14:05:49 <SyntaxNinja> hi
14:06:05 <boegel> hi megaman
14:06:11 <dcoutts_> boegel, great
14:07:04 <Biker> hey boegel... sorry about the morning. I didn't see your message since I was replying to a few mails and by the time I got back, you'd already left.
14:08:13 <boegel> Biker: which message? :)
14:08:20 <megaman> hm, question: i have "data Expr = Const Int | Add Expr Expr | Sub Expr Expr | Mul Expr Expr | Div Expr Expr" - what id like to do is distuingish between 'add/sub' and 'mul/div'
14:08:34 <megaman> to save a few case declarations
14:08:47 <Biker> boegel, nothing much... you said hi :-)
14:09:14 <SyntaxNinja> megaman: you can break it into more types, but you'll probably end up writing more code in the long run, IMO.
14:09:20 <boegel> Biker: oh, no biggy :) I experience it all the time
14:09:22 <resiak> dcoutts_: Any hints for tomorrow? :)
14:09:43 <dcoutts_> resiak, which paper are you doing tomorrow?
14:09:56 <Biker> boegel: cool then. I felt bad since that would have been pretty rude if it had been intentional :)
14:10:03 <megaman> hm, isnt ther an easy way like declaring an additional type thats either add or sub and using that in my cases ?
14:10:27 <resiak> dcoutts_: fp and dsa
14:10:31 <boegel> Biker: I say hi to a lot off people, and don't get any reply lot's of time, I didn't even notice :)
14:10:48 <SyntaxNinja> it's pretty easy to add types like AddSub and MultDiv and then make data Expr = AddSub | MultDiv
14:11:00 <Biker> boegel: ok then :)
14:11:17 <SyntaxNinja> megaman: you mgiht google for a question I asked similarly when I learned Haskell..
14:11:27 <SyntaxNinja> @google representation getting verbose haskell
14:11:29 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2002-October/003472.
14:11:29 <lambdabot> html
14:11:31 * boegel finishes up on his Compilers book
14:11:45 <dcoutts_> resiak, hmm, remember the definitions of foldl/foldr perhaps, and just hope the questions are nice :-)
14:11:47 <megaman> syntaxN: 404 ;)
14:12:14 <SyntaxNinja> megaman: lambdabot broke the url.
14:12:29 <megaman> oh, i see
14:13:21 <resiak> dcoutts_: Yeah, I'm proving the foldr fusion theorem to myself at the moment.
14:15:55 <dcoutts_> resiak, that's a good one to know
14:16:42 <Speck> s/foldr/cold plz
14:17:38 <resiak> dcoutts_: Figures. Anyway, back to it :)
14:21:27 <Itkovian> evening
14:27:29 <xerox> dons, ping
14:27:32 * boegel just finished his first read of his Compilers book
14:27:50 <xerox> boegel, the Dragon Book? :)
14:27:52 <boegel> omg, they just freed Michael Jackson from all charges :|
14:27:59 <basti_> i cant believe it too
14:28:03 <boegel> xerox: no, the book by A.W.Appel
14:28:13 <boegel> I mean, damn, how obvious can it get
14:28:20 <boegel> stupid american jury
14:28:29 <boegel> I say lock him up
14:30:12 * Itkovian really doesn't care about Wacko Jacko.
14:30:32 <Itkovian> I just hope those children in fact lied and weren't touched at all.
14:31:48 <SyntaxNinja> boegel: but which version of the appel book? :)
14:32:24 <Itkovian> the grooviest code I saw the last days: (it's not Haskell, be warned)
14:32:31 <Itkovian> function isNegative( n ) {
14:32:32 <Itkovian>   return n != 0 && n / Math.abs( n ) == -1
14:32:32 <Itkovian> }
14:32:38 <Itkovian> eh????
14:33:00 <boegel> SyntaxNinja: the C version
14:33:17 <boegel> Itkovian: heh, where did you see that ?
14:33:34 <Itkovian> www.thedailywtf.com
14:34:06 <boegel> Itkovian: that's really a wtf one
14:34:13 <boegel> what's wrong with n < 0 :)
14:34:46 <SyntaxNinja> boegel: boooo
14:35:09 <boegel> SyntaxNinja: it's for uni, I didn't chose
14:35:18 <boegel> SyntaxNinja: which one do you suggest ? the ML one ?
14:35:23 <Speck> is there a good prettyprint lib included in ghc6.4?
14:35:28 <SyntaxNinja> boegel: I took that course, it was taught in java, but I talked the teacher into letting me do it in ML :)
14:35:29 <Itkovian> wel, obviously for relly small values of n, the values might pop above 0 once in a while, I guess, just random quantuym effects, you know
14:35:40 <boegel> SyntaxNinja: heh :)
14:35:43 <Itkovian> SyntaxNinja: you lucky bastard
14:36:10 <dcoutts_> Spark, Text.PrettyPrint.HughesPJ
14:36:37 <xerox> n / Math.abs( n ) == -1  ahah!
14:37:08 <boegel> xerox: :)
14:37:24 <Speck> thanks dc
14:37:35 <Itkovian> mind, he did check that n /= 0 ...
14:38:08 <xerox> ...also note that n == 0 && doesn't make the second part not being considered, resulting in a DivByZero error.
14:38:31 <xerox> err, n != 0
14:38:40 <SyntaxNinja> Itkovian: :)
14:38:59 <SyntaxNinja> I even got to work with a friend on it.
14:39:25 <Itkovian> xerox: eh? if n!= 0, then the second part will not be evaluated in C ... or are you referring to another PL?
14:39:35 <xerox> Itkovian, really?
14:39:44 <Speck> I can use Text.PrettyPrint to print lists prettily, no?
14:39:48 <xerox> Isn't it strict?
14:40:09 <Igloo> It is strict but has short-circuiting operators
14:40:24 <xerox> ...fortunately :-)
14:40:42 <Igloo> Like the vast majority of languages. I think pascal or something originally didn't
14:40:50 <Itkovian> xerox: nope, in C the && and || are short-cicuited, which does allow one to write unreadable code at times :-)
14:41:07 * Itkovian thought xerox was kidding ,,.
14:41:30 <xerox> Too much Haskell? :-P
14:41:46 <Itkovian> is that possible?
14:42:12 <xerox> boegel could agree with my version of what Haskell can do to me if taken in _big_ doses.
14:44:11 <boegel> xerox: I can :)
14:44:20 <boegel> he ust goes nuts ! totally !
14:44:24 <boegel> check the logs :p
14:44:35 * xerox ducks
14:44:37 <Itkovian> hmm, will my sanity be affected?
14:45:18 <boegel> probably
14:45:32 <basti_> only in positive ways
14:45:44 <basti_> from a certain standpoint
14:49:40 <Speck> rawr... after... many hours, my parsec parser creates a list separating input by newline characters!
14:49:57 <basti_> Speck: !!! :D
14:50:11 <Speck> logLines =  (many (noneOf ['\n'])) `endBy` newline
14:50:24 <basti_> is this terseness disappointing?
14:50:28 <Speck> horribly
14:50:49 <xerox> ...and it sounds like spoken english :-)
14:50:50 <basti_> whatttt.
14:51:35 <megaman> noob question: how do i negate a bool ? ;]
14:51:41 <xerox> @type not
14:51:48 <lambdabot> not :: Bool -> Bool
14:51:58 <megaman> ta :)
14:52:06 <xerox> yw :)
14:52:38 <Speck> is there any collection of beginners example problems for haskell?
14:52:55 <Speck> it took so long to write that one line... I think I should start with something more basic
14:52:59 <basti_> build your own monadic parser.
14:53:07 <Speck> hehe
14:53:07 <basti_> j/k
14:53:17 <aheller> I was doing the Python Challenge for a bit.
14:53:21 <basti_> how about, try to reverse a list, in as many different ways as possible?
14:53:24 <Speck> I did the python challenge in ruby
14:53:30 <MachinShin> compete in the icfp? :P
14:53:36 <MachinShin> python challenge?
14:53:43 <aheller> pythonchallenge.org
14:53:46 <aheller> I think.
14:54:09 <xerox> What about the wiki Haskell intro...
14:54:23 <xerox> basti_, good one!
14:54:47 <Speck> hmm... I'll do the list reversing one
14:54:55 <xerox> @type foldr1
14:54:56 <lambdabot> foldr1 :: forall a. (a -> a -> a) -> [a] -> a
14:55:00 <xerox> @type foldl1
14:55:01 <lambdabot> foldl1 :: forall a. (a -> a -> a) -> [a] -> a
14:55:01 <Speck> yeah I was going to use foldr
14:55:11 <basti_> really? -g-
14:55:12 <xerox> Oh sorry.
14:55:22 <Speck> I've read a lot of haskell docs
14:55:28 <Speck> I just haven't sat down and actually coded anything
14:55:31 <basti_> i see.
14:55:40 <Speck> it isn't really solidified in my mind
14:55:40 <basti_> the scans could be useful too
14:55:46 <Speck> ah yes
14:56:06 <basti_> it's possible with a really terse fold, but this solution sucks since noone understands it ;)
14:56:22 <xerox> @plugs foldl (flip (:)) "" "now em/"
14:56:22 <Speck> yeah, I think the explicit recursion is more readable
14:56:22 <Itkovian> megaman: in the light of the wtf earlier ... negate x = if x == True then False else True
14:56:24 <lambdabot> "/me won"
14:56:33 <Speck> aah... I was on the man page for flip
14:56:46 <megaman> what?
14:56:51 * xerox always spoil the fun
14:57:27 <Speck> I was close to that solution
14:57:34 <Speck> but I think I read it before
14:57:59 <xerox> @pl \x y -> y:x
14:58:00 <lambdabot> flip (:)
14:58:07 <xerox> That's all
14:58:25 <basti_> i think theres even a solution with foldr
14:58:33 <basti_> without flip
14:58:48 <xerox> 1) implement foldl in terms of foldr
14:58:55 <xerox> 2) foldl (flip (:)) ""
14:59:00 <basti_> yes.
14:59:00 <basti_> ;)
14:59:15 <Speck> oh darn, look at the time. I actually have to leave work now...
14:59:17 <xerox> AFK for a while; BBIAB &
14:59:32 <basti_> Speck: youre always welcome
14:59:53 <Speck> I'll be back soon. quite possibly once I get home ;-)
15:02:14 * basti_ ate too much
15:05:02 * boegel is hungry
15:06:35 * Lemmih plans an expedition to the bakery in 6 hours.
15:07:07 <basti_> going to buy pretzel lambdas?
15:07:29 <boegel> Lemmih: going outside ? don't dude ! just don't !
15:08:02 <basti_> its not the outside
15:08:03 <basti_> its the sun
15:08:10 <Lemmih> basti_: Nah, people always confuse them with Half-Life pretzels.
15:32:06 <dlk> greetings, I have a somewhat heretic question - apologies in advance for any hurt feelings. I am reserching the possibilities to either port a haskell framework to python or to build some glue between the haskell framework and python.
15:32:18 <dlk> has anything like this been attempted before?
15:32:25 <basti_> uhm
15:32:31 <basti_> thats not heretic
15:32:43 <Lemmih> dlk: CosmicRay has written a Haskell binding to Python.
15:32:44 <basti_> i think there exists such a framework, i can't dig up a reference right now though
15:32:49 <Lemmih> dlk: Google for missingPy
15:33:09 <basti_> see
15:33:11 <basti_> =)
15:33:19 <basti_> and, there is lots of interfacing in haskell
15:33:41 <basti_> we feel that even though we have so good a language there is no need not to discriminate others
15:33:56 <dlk> Lemmih, basti_: thanks, that looks like what I should start with :)
15:34:00 <dlk> basti_: hehe...
15:34:03 * TFK grabs missingPy
15:34:57 <dlk> ouch - from the README - "Lydia wrote:
15:34:57 <dlk> > Dear Dario,
15:34:57 <dlk> >
15:34:57 <dlk> > I'm glad to receive your letter again!
15:34:57 <dlk> > I have checked that the cheapest freight cost from here to Goteborg is
15:35:11 <basti_> excess flood
15:35:14 <basti_> =)
15:35:19 <wagle> how completely lame
15:35:46 <basti_> good night though, and greet him when he's back
15:35:49 <basti_> if he ever is
15:35:51 <basti_> lol
15:35:53 <basti_> bye
15:36:24 <Lemmih> Welcome back, dlk.
15:36:24 <kaol> @yow
15:36:26 <lambdabot> Bo Derek ruined my life!
15:36:37 <wagle> 15:36 < basti_> excess flood
15:36:37 <wagle> 15:36 < basti_> =)
15:36:37 <wagle> 15:36 < wagle> how completely lame
15:36:37 <wagle> 15:36 < basti_> good night though, and greet him when he's back
15:36:37 <wagle> 15:36 < basti_> if he ever is
15:36:39 <wagle> 15:36 < basti_> lol
15:36:42 <wagle> 15:36 < basti_> bye
15:36:44 <wagle> 15:36 -!- basti_ [~basti@p54AE3195.dip0.t-ipconnect.de] has quit ["leaving"]
15:36:45 * dlk apologises t the channel for hte horrendous spam previously
15:37:05 <dlk> I can only blame my studpid windwos irc client and it's studpid policies on copyin text...
15:37:25 <wagle> dlk: nothing much showed up here
15:37:28 * dlk checks that the copied text is correct this time
15:38:12 <dlk> anyway, the readme says that missingpy is used only for callin python from haskell, not hte other way around.
15:38:22 <Lemmih> Yep.
15:38:26 <dlk> I need to call haskell from python.
15:38:49 <Lemmih> Can you call C from Python?
15:38:59 <dlk> yeah, sure
15:39:04 * boegel leaves for bed
15:39:18 <Lemmih> It's very easy to call Haskell functions from C.
15:39:50 <jlouis> double marshalling. heh
15:40:05 <dlk> oki, that sounds like a plausible way. I'll have to learn C, of course, but that's what co-workers are for :-)
15:40:41 <dlk> btw, does shapr hang aroudn here?
15:40:47 <Lemmih> @seen shapr
15:40:48 <lambdabot> I saw shapr leaving #haskell 1 day, 22 hours, 29 minutes and 22
15:40:48 <lambdabot> seconds ago.
15:41:13 <kaol> not long enough to have everybody wonder where he's gone yet
15:44:30 <dlk> k, thanks for the pointers. And, once more, apologies for the inexcusable and horrible, *horrible* spam previously... But, hey, now y'all know I own a motorcycle that I can't afford to buy the service manual for :-)
15:44:32 <Lemmih> dlk: Is you interest in a Python <-> Haskell binding academic or work related?
15:44:41 <dlk> well, both sort of.
15:45:59 <dlk> I have and idea for a thesis (not masters, but one degree before that) that I want to use GF for (GF: http://www.cs.chalmers.se/~aarne/GF/)
15:46:31 <dlk> and the prototype I want to build with it will be based on zope, which is python.
15:46:50 <dlk> GF is haskell
15:46:59 <Lemmih> Yeah, I've heard of it.
15:48:46 <dlk> The results of this would be very usefull for my work, but even though I work for a university, since I work building websites for administrative, not academic needs, I am not really sure how some highly academioc work would be accepted.
15:49:16 <dlk> so I may not be allowed to work on this on work time.
15:56:57 <smoofra> sup haskellers.  any of you funky cats know how a monoid can be considerd a special case of a monad?
15:57:11 <dlk> hm... there is actually an entry on this on the python.org wiki: at the end of http://wiki.python.org/moin/PythonVsHaskell
18:37:35 <dons> @code
18:37:37 <lambdabot> List.lhs: foldr2_left _k  z _x _r []     = z
18:39:50 <Pseudonym> @code
18:39:51 <lambdabot> Bool.hs: {-# OPTIONS_GHC -fno-implicit-prelude #-}
18:40:01 <Pseudonym> That's not code, it's a pragma.
18:40:38 <Pseudonym> For the ultimate tease... @code
18:40:55 <lambdabot> Magic.hs: -- This is the really cool bit:
18:45:57 <ozone> @code
18:45:58 <lambdabot> Unboxed.hs: -----------------------------------------------------------------------------
18:48:30 <heatsink> @code
18:48:31 <lambdabot> Typeable.hs: (TyCon t1 _) == (TyCon t2 _) = t1 == t2
18:57:28 <foxy_> @index sort
18:57:30 <lambdabot> Data.List
19:01:10 <MachinShin> hey +
19:23:57 <Lemmih> Why is the Evil Mangler written in perl?
19:24:29 <yain> i thought perl *is* evil mangler...
19:25:59 <dcoutts_> I think because it's a reasonable tool for an unpleasent job, it's basically a text processing task, there'd be no advantage to doing it in Haskell
19:26:43 <Pseudonym> Which is, I think, a pure admission that Haskell's strings are crap.
19:26:49 <Pseudonym> :-)
19:27:20 <dcoutts_> and the evil mangler makes use of the perl regexps stuff
19:28:00 <dcoutts_> which you could do with the Haskell regexp library but it's not obvious that it'd be better
19:31:18 <dcoutts_> TFK, the windows installer for the Gtk2Hs 0.9.8 release candidate is available: http://haskell.org/gtk2hs/gtk2hs-0.9.7.92.exe
19:32:27 <dcoutts_> It should work with ghc 6.2.2 and 6.4, and Gtk+ 2.4.x and 2.6.7+
19:33:06 <Lemmih> It uses +11 minutes (CPU time) to mangle the assembler from a 1400 lines Haskell module on my 1.8Ghz Athlon. How could a Haskell version possibly be any slower?!
19:34:13 <Lemmih> 12 minutes and counting...
19:34:30 <dcoutts_> Lemmih, the mangler should die when the C backend is no longer the default, the C-- backend should be much faster in terms of compile time since it doesn't need gcc or the perl mangler
19:35:08 <dcoutts_> mind you, I've never seen it take that long.
19:36:27 <foxy_> dcoutts_, I just tried the windows installer, and it said I needed GHC 6.2.2, I am using 6.4, is there an installer for 6.4?
19:36:48 <Lemmih> When will the C-- backend be up for the task?
19:37:16 <dcoutts_> foxy_, you're using the windows installer I just posted or an older version?
19:37:29 <foxy_> dcoutts_, the one you just posted
19:37:34 <dcoutts_> hmm...
19:38:19 <dcoutts_> could you run it from a command line like: gtk2hs-0.9.7.92.exe /LOG=gtk2hs.log
19:38:29 <dcoutts_> and email me the log file
19:38:29 <foxy_> ok
19:38:49 <dcoutts_> duncan.coutts@worc.ox.ac.uk
19:38:52 <dcoutts_> ta.
19:40:06 <dcoutts_> oh, wait a sec...
19:40:34 <dcoutts_> I might have found the bug... (it never occured on my machine because I have ghc on the path and it check there first)
19:40:45 <foxy_> it didn't generate a log file??
19:41:03 <foxy_> btw, GHC is on my path
19:41:21 <foxy_> ah, and I'm using 6.4.1, would that make a difference?
19:42:11 <dcoutts_> foxy_, it will make a difference since ghc versions are not guaranteed to be compatible between versions
19:42:27 <foxy_> true
19:42:27 <dcoutts_> so the installer looks for exactly ghc 6.4 or 6.2.2
19:44:17 <dcoutts_> I'll fix the thing I just noticed and update the error messages to ask for 6.2.2 or 6.4 and post it again...
19:44:51 <dcoutts_> foxy_, so you've got just the 6.4.1 cvs / prerelease / snapshot ghc version installed then?
19:45:00 <foxy_> yup
19:45:28 <dcoutts_> so the installer will still complain, but should give you a more accurate error message :-)
19:45:44 <foxy_> heh, yeah
19:45:45 <dcoutts_> you can install more than one version of ghc at time...
19:47:21 <foxy_> There is a bug in 6.4 on Win98 and I'm using hs-plugins reliant on 6.4 not 6.2.2 (waiting to develop the UI :)
19:47:49 <dcoutts_> well 6.4 is ok, just not 6.4.1_pre
19:49:22 <foxy_> I'll try from source
19:50:30 <dcoutts_> you'll probably want to try from the latest cvs as there's a build bug I fixed for win32 since the last release candidate tarball
19:50:42 <foxy_> ok
19:50:45 <dcoutts_> or I can tell you the patch, it's one liner
19:51:00 <dcoutts_> or you can build without optimisations
19:51:37 <dcoutts_> the latter is the easiest, just add --with-hcflags=-H50m which overrides the default of "-O"
19:51:50 <dcoutts_> to the ./configure line
19:53:54 <dcoutts_> and you need to use something like ./configure --prefix=c:\gtk2hs since ghc-pkg doesn't like mingw style paths
19:54:12 <dcoutts_> I should really update the building from source on win32 FAQ
19:58:49 <foxy_> I have to reboot, I'll let you know if there were any problems building
19:58:57 <dcoutts_> ta
20:17:41 <foxy_> dcoutts_, running autoconf  to generate a configure script failed with:
20:17:43 <foxy_> 'configure.ac:25: error: possibly undefined macro: AM_INIT_AUTOMAKE
20:17:45 <foxy_> '     If this token and others are legitimate, please use m4_pattern_allow.
20:18:06 <dcoutts_> what autoconf version?
20:18:26 <foxy_> 2.59 on MSYS
20:19:11 <dcoutts_> oh, try autoreconf
20:19:47 <dcoutts_> autoreconf runs automake and a couple other tools all in the right order
20:22:05 <foxy_> '/usr/share/aclocal/autoopts.m4:22: warning: underquoted definition of AG_PATH_AUTOOPTS
20:22:07 <foxy_> '  run info '(automake)Extending aclocal'
20:22:09 <foxy_> '  or see http://sources.redhat.com/automake/automake.html#Extending%20aclocal
20:22:11 <foxy_> 'configure.ac: required file `./missing' not found
20:22:13 <foxy_> 'C:\APPS\MSYS\1.0\BIN\automake: am_libHSgconf_a_OBJECTS was already defined in condition ENABLE_GCONF, which is included in condition TRUE ...
20:22:14 <foxy_> 'Makefile.am:37:   while processing library `libHSgconf.a'
20:22:16 <foxy_> 'Makefile.am:784: ... `am_libHSgconf_a_OBJECTS' previously defined here
20:23:10 <dcoutts_> run autoreconf -i to get past the './blah' not found errors, as for the other...
20:24:56 <dcoutts_> so what automake version is it using?
20:25:12 <foxy_> $ autoreconf -i
20:25:13 <foxy_> usr/share/aclocal/autoopts.m4:22: warning: underquoted definition of AG_PATH_AUTOOPTS
20:25:15 <foxy_>   run info '(automake)Extending aclocal'
20:25:17 <foxy_>   or see http://sources.redhat.com/automake/automake.html#Extending%20aclocal
20:25:18 <foxy_> configure.ac:121: error: possibly undefined macro: AC_MSG_ERROR
20:25:20 <foxy_>       If this token and others are legitimate, please use m4_pattern_allow.
20:25:22 <foxy_>       See the Autoconf documentation.
20:25:24 <foxy_> autoreconf: /usr/bin/autoconf failed with exit status: 1
20:25:38 <foxy_> GNU automake 1.8.2
20:26:13 <dcoutts_> I don't know why it complains about AC_MSG_ERROR, it's a perfectly standard macro
20:28:24 <dcoutts_> I'd suggest using the 0.9.7.92.tar.gz file and just compiling without optimisations
20:28:50 <foxy_> I'll try that, where do I get the tarball?
20:29:12 <dcoutts_> ./configure --with-hcflags=-H50m --prefix=c:\gtk2hs-0.9.7.92
20:29:41 <dcoutts_> haskell.org/gtk2hs/gtk2hs-0.9.7.92.tar.gz
20:29:59 <dcoutts_> or rather http://haskell.org/gtk2hs/gtk2hs-0.9.7.92.tar.gz
20:31:44 <dcoutts_> ./configure --with-hcflags=-H50m --prefix=c:/gtk2hs-0.9.7.92
20:32:12 <dcoutts_> configure wants it to be "c:/" with a forward slash rather than "c:\"
20:32:40 <foxy_> ok
20:35:52 <dcoutts_> foxy_, gotta go, if you have any more problems leave a message for me
20:36:01 <foxy_> ok, thanks
20:36:51 <foxy_> dcoutts_: Are these a problem?
20:36:52 <foxy_> No package 'gconf-2.0' found
20:36:54 <foxy_> No package 'gtksourceview-1.0' found
20:36:56 <foxy_> No package 'mozilla-gtkmozembed' found
20:37:26 <dcoutts_> foxy_, no that's not a problem, it's just the autodetection working
20:38:05 <dcoutts_> you only get those packages on linux/unix (or if you compile them yourself on windows)
20:38:11 <foxy_> ah, ok
23:32:09 <lispy> i was wondering if anyone tried out http://www.codersbase.com/Autoproc and had feed back (I'm looking for ways to improve it)
23:32:51 <lispy> it's the thingy i made this term to generate procmail recipes, you use some custom haskell functions and then your program outputs procmail ;)
23:34:11 <lispy> well, shoot it's late
23:34:22 <lispy> i guess if anyone has feed back i'll have to check for it later
23:58:30 <Itkovian> meuning
