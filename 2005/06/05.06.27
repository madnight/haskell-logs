00:00:23 <TFK> lispy, no no, there is a name collision...
00:01:28 <yain> it's sorta nice collision
00:01:56 <yain> software which solves same problems and have similar names :P
00:48:25 <Itkovian> @seen metaperl
00:48:26 <lambdabot> I saw metaperl leaving #haskell 1 day, 10 hours, 45 minutes and 35
00:48:26 <lambdabot> seconds ago.
00:48:37 <Itkovian> @seen boegel
00:48:38 <lambdabot> I saw boegel leaving #haskell 9 hours, 57 minutes and 22 seconds ago.
01:24:03 * boegel scratches
01:24:34 <Itkovian> erm?
01:24:39 <Itkovian> exams?
01:24:40 <Itkovian> cava?
01:27:57 <boegel> Itkovian: I think the last one (Friday), was probably the best exam of my whole carreer :)
01:30:57 <Itkovian> that sounds promising
01:33:14 <boegel> it does :) I'm coming to Ghent again tomorrow, apparently kdb wants me to sign some stuff
01:37:45 <Itkovian> nice.
01:37:50 <Itkovian> handing over yr soul, eh
01:39:20 <xerox> Did you see the LL2 conference talks?
01:39:30 <xerox> They're one better than the other.
01:39:56 <xerox> http://ll2.ai.mit.edu/ -- the first one of the second video is _great_
02:51:28 <shapr> Man, I hate summer colds.
02:55:45 <shapr> @seen alexj
02:55:46 <lambdabot> I saw alexj leaving #haskell 1 month, 4 days, 9 hours, 57 minutes
02:55:46 <lambdabot> and 14 seconds ago, and I have missed 11 days, 22 hours, 33 minutes
02:55:46 <lambdabot> and 57 seconds since then.
02:58:11 <shapr> Hey Zhivago, long time no see.
02:58:18 <Zhivago> hey, you people think that lisp is procedural, don't you?
02:58:23 <Zhivago> hello shapr :)
02:58:28 <shapr> I'd say yes.
02:58:30 <yain> sure it is.
02:58:41 <TFK> @seen Oejet
02:58:42 <lambdabot> I saw Oejet leaving #haskell 11 days, 13 hours, 3 minutes and 55
02:58:42 <lambdabot> seconds ago, and I have missed 4 minutes and 34 seconds since then.
02:58:46 <Zhivago> thank goodness for that :)
02:58:56 <Zhivago> shapr: how's darius doing?
02:59:22 <shapr> Haven't heard much from him lately. I do know he's working on some neat stuff.
02:59:29 <Zhivago> shapr: cool
02:59:39 <Zhivago> shapr: as long as he isn't starving or something.
02:59:46 <shapr> I hope not.
03:00:00 <Zhivago> shapr: let me know if he is -- I can probably get him a job
03:00:11 <shapr> Send him an email.
03:00:20 <shapr> It's possible he's interested.
03:00:33 <shapr> He has no lack of clue, that's for sure.
03:00:37 <shapr> hiya poetix
03:00:40 <poetix> Howay
03:00:42 <Zhivago> well, it would be a nuisance to do it, but it could probably be arranged if it became necessary
03:00:56 <shapr> Hey, you think your Sudoku solver article could be ready for the next TMR?
03:01:05 <Zhivago> anyhow, bbl
03:01:08 * poetix knew he was going to be asked that
03:01:13 <shapr> surprise :-)
03:01:32 <shapr> I really would like to get five articles so I can publish another issue of TMR.
03:01:33 <poetix> I want to rewrite the algorithm
03:01:53 <poetix> and get it to used monad transformers to blend State with Maybe
03:01:54 <shapr> Can you have it ready for a July 1st publication date?
03:02:19 * poetix thinks
03:02:40 <poetix> I'm not confident about that
03:02:55 <poetix> Maybe if I just use what I have, and write up how I got there
03:03:03 <shapr> That would be cool.
03:03:22 <poetix> I will have a look this evening, and see how far I get - might be able to just knock it out
03:03:39 <shapr> I would appreciate it :-)
03:03:50 <poetix> OK, I'll have a go.
03:03:54 <shapr> The readers would appreciate it even more!
03:04:06 <poetix> I'll be on #haskell later, so you can chase me up then
03:04:10 <shapr> Sounds good.
03:04:26 <poetix> Been reading all about subcontinuations recently
03:04:30 <shapr> My ArrowsIntroduction still needs work, but I think it'll turn out fine.
03:04:47 <shapr> Yeah, subcontinuations are fascinating. Have you read Oleg's articles about the Zipper as tree of subcontinuations?
03:04:56 <poetix> Not yet
03:05:09 <shapr> I see a lot of applications for that isomorphism.
03:05:39 <poetix> Such as?
03:07:19 * poetix reads Oleg's post on the Zipper
03:07:51 <poetix> "an updateable and yet pure functional cursor into a data structure"...
03:07:55 <poetix> Every home should have one!
03:09:30 <poetix> What I'm finding really fascinating at the moment is the way that multiple "notions of computation" can be layered into a program using monads.
03:10:22 <ski> hm, where's that (re zipper) ?
03:10:31 <poetix> http://www.haskell.org//pipermail/haskell/2005-April/015769.html
03:10:41 <ski> ty
03:34:49 <poetix> shapr: The Zipper looks a little like another way of tackling a problem Oleg looked at ages ago, which is how to "back up" when you're traversing a tree. The delimited subcontinuations are acting a little like pointers to parent nodes - specifically, they're jumps to a portion of the computation where the parent node *was* the current node. Is that right?
04:12:38 <bourbaki> moin
05:03:47 * poetix fizzles out into a little coruscating cloud of Quantum. A faint 'ping' is heard, and a whiff of elderflower floats on the virtual breeze.
05:14:49 <xerox> ski, piiiing.  Someone implemented your coalg. datatypes ;-)
05:15:23 <Philippa_> URL?
05:15:35 <xerox> http://savannah.nongnu.org/projects/needle
05:15:50 <xerox> There's a talk of the author, at LL2:
05:16:12 <xerox> <http://ll2.ai.mit.edu/> The Needle Programming Language - Neel Krishnaswami.
05:16:26 <xerox> (It's in the second .ram file)
05:18:54 <xerox> Those talks are one better than the other.  The first ones of both .rams are _great_.
05:28:56 <Mon14266> can i define type operators?
05:40:14 <xerox> Mon14266, what do you mean with Type Operators?
05:40:17 <jlouis> xerox: bastard. I am reading up on teh exam and then you give me reasons not to ;)
05:41:31 <xerox> jlouis, they're so great! *grin*
05:50:38 <jlouis> xerox: shut up!
05:50:40 <jlouis> ;)
05:51:25 <xs> there's ll1 and ll3 too.
05:51:47 <xerox> 3!  I'll check it out, thanks.
05:52:42 <Mon14266> xerox, in my case it would be nice to not have a type contructor but an operator (like ->)
05:52:43 <jlouis> 3! = 6
05:53:38 <xerox> (->) is a type constructor
05:53:49 <xerox> (an infix one, but still a type constructor)
05:55:51 <Mon14266> ok so i need to define an infix type constructor...is that possible
06:00:06 <xs> i think ghc allows this as an extension.
06:00:19 <jlouis> true
06:00:41 <xerox> @google ghc extension liberalized infix
06:00:43 <lambdabot> http://www.haskell.org/pipermail/haskell/2005-April.txt
06:00:47 <xerox> nope..
06:00:50 <xerox> @google ghc extension liberalized infix site:haskell.org
06:00:52 <lambdabot> http://www.haskell.org/pipermail/haskell/2005-April.txt
06:00:57 <xerox> Gee, sorry :-P
06:01:25 <xerox> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#infix-tycons
06:01:28 <xerox> There you go.
06:01:58 <xerox> Do you know where's the doc about ":=" as Data Constructor?
06:05:00 <musasabi> xerox: it is afaik used in various libraries in different ways.
06:05:46 <musasabi> e.g. in hs-fltk "data Prop c = forall a. Attr c a := a"
06:06:20 <xerox> I'm playing with Gtk2Hs.  It does things like: set window [containerBorderWidth := 10]
06:07:03 <xerox> That is indeed really nice :-)  If I'm understanding this well, := is defined in the code somewhere, right?
06:09:19 <xerox> OK, I found it, thanks much musasabi.
06:11:27 <xerox> Goin' offline for a while, see you soon :-)
06:21:37 <Mon14266> ok thanks (although my ty is a bit late :P)
06:44:13 <dons> hey #haskell
06:44:15 <dons> @y0w
06:44:17 <lambdabot> Where does it go when you flush?
06:44:18 <dons> @ghc
06:44:19 <lambdabot>  Try -fglasgow-exts for GHC's newtype-deriving extension
06:44:23 <dons> @code
06:44:24 <lambdabot> Real.lhs: %*********************************************************
06:44:27 <dons> yay!
06:44:59 <TFK> @moo
06:45:00 <lambdabot>         (__)
06:45:00 <lambdabot>         (xx)
06:45:00 <lambdabot>  __------\/
06:45:00 <lambdabot> * ||____||
06:45:00 <lambdabot>  / |    |\
06:45:01 <lambdabot>  
06:45:03 <lambdabot>  Hamburger
06:45:23 <dons> I don't get that one
06:46:15 <Lemmih> Submitted your icfpc entry, dons?
06:46:38 <dons> yup, bout 30 mins ago
06:47:05 <dons> TOTAL:                 3118   1743
06:47:09 <dons> code /comments
06:47:12 <Lunar^> dons: Haskell with hs-plugins ? :D
06:47:29 <TFK> How difficult was it?
06:47:31 <dons> nah, no plugins ;) but all haskell :D
06:47:45 <dons> TFK, pretty tough to do some good AI, without knowing AI
06:48:00 <dons> otherwise, a lot of it was straightforward
06:48:05 <dons> i.e. just getting something running
06:48:15 <TFK> Did you do it alone or in a group?
06:48:21 <dons> group of 3
06:48:46 <TFK> So you've been all hacking non-stop for 48 hours? ;-)
06:48:58 <dons> 72!!??
06:49:19 <TFK> Was it 72?... ^_^;;
06:49:35 <dons> 3 days straight %)
06:50:00 <TFK> Best of luck. I think that dcoutts_ also participated. Or was he on your team?
06:51:06 <dons> another team.
06:51:09 <cognominal> is it possible to define function in ghci?
06:51:25 <TFK> cognominal, let func x y = x + Y
06:51:30 <TFK> x+y, that is
06:51:35 <TFK> (without an 'in')
06:51:55 <cognominal> thx. why the let is necessary?
06:52:42 <Philippa> because it makes it easier to parse
06:52:56 <TFK> Beats me. It would be wicked-cool if Haskell had a shell like Python (for example) does.
06:53:44 <cognominal> so what I do if I do a function defined as a pattern matchin like fac?
06:54:17 <TFK> cognominal, you'll have to write it in a file and import it.
06:54:48 <TFK> Are you on windows or windows?
06:54:50 <TFK> err
06:54:54 <TFK> linux or windows :-/
06:55:05 <cognominal> on window :)
06:55:13 <cognominal> meaning unix...
06:55:18 <cognominal> well linux
06:55:48 <cognominal> err, emacs :)
06:56:08 <cognominal> I suppose the haskell mode can help
06:56:10 <TFK> Well, it shouldn't matter much anyway. You can have a "scratchpad" file in an editor, load it once, and just keep reloading it as necessary. Annoying, but works.
06:56:41 <Philippa> cognominal: I think there's an escape character you can use
06:56:46 <Philippa> read the Haskell 98 Report
06:56:52 <Philippa> and possibly the ghci docs
06:57:09 <Philippa> I tend to use a file and bang :r regularly instead though
06:57:22 <TFK> What, the entire report just for a working shell? :-P
06:57:50 <xs_> hm, why not..
06:57:53 <xs_> Prelude> let {fac 0 = 1; fac n = n*fac (n-1)}
06:57:53 <xs_> Prelude> fac 10
06:57:53 <xs_> 3628800
06:57:54 <Philippa> the bit on the top-level declaration syntax coupled with the bit on the layout rule should do
06:58:03 <Philippa> xs_: thought that might be the case :-)
06:58:10 <cognominal> I hate languages that cannot be learnt dabbling with a shell
06:58:36 <cognominal> xs_, thx
06:58:48 <Philippa> the repeated-:r option's an effective poor man's attempt at one, FWIW
06:59:09 <TFK> funky syntax.
06:59:12 <Philippa> and it's much easier to work with when you realise you've declared something inconsistent, because you can alter definitions you've already given it
06:59:24 <Philippa> not as funky as you might think - read the syntactic bit of the report
06:59:34 <TFK> Why can't GHCi wait one line when it encounters a 'let', like Python does?
06:59:44 <Philippa> why should it bother?
06:59:49 <Philippa> why should it have to?
06:59:58 <TFK> Let's see... easier on the users?
07:00:10 <cognominal> so, in ghci,  each line must be a complete expression?
07:00:25 <TFK> Python got it right. I don't think it would be difficult - same old layout, a bit more intelligent GHCi.
07:00:40 <Philippa> FFTSAP
07:00:53 <TFK> Although there's still the question of pattern matching or somesuch. Hmm.
07:00:55 <TFK> FFTSAP?
07:01:00 <Philippa> Feel Free To Submit A Patch
07:01:09 <dons> oh, I like that one.
07:01:11 <TFK> I see.
07:01:34 <cognominal> bbl, thx for your insight. I will read the backlog if you purse the converstation
07:06:31 * boegel summons shapr
07:07:05 <ndm> i was thinking of doing this anyway
07:07:12 <ndm> in something like WinHugs
07:07:23 <TFK> ndm, that would rock :-)
07:07:27 <ndm> have a multiline textbox, and enter gets you onto the next line
07:07:30 * TFK roots for WinHugs
07:07:37 <ndm> Ctrl+Enter submits
07:07:45 <ndm> TFK, I have a new build of WinHugs on my machine
07:07:55 <ndm> new graphics, new interface, and up to date with the CVS
07:08:11 <ndm> I'm slowly getting WinHugs to a beautiful tool
07:08:14 <Philippa> ndm: that would be cool
07:08:20 <TFK> hehe
07:08:34 <ndm> i'm also thinking of building WinNhc
07:08:40 <Philippa> you could probably write a wrapper around ghci that did much the same too - you'd just de-layout stuff
07:09:04 <TheHunter> cognominal, the ghci prompt tries to emulate a do-block, so you can bind stuff with let and <-, and execute IO actions. Plus it shows expressions.
07:09:06 <ndm> its much easier if you put it all in a GUI, which is why something like GHCI is harder
07:09:32 <Philippa> run it seperately and communicate over pipes?
07:09:49 <ndm> yeah, but GHCI is already very complex
07:10:08 <ndm> WinHugs is currently compiled in, WinNhc will be going over pipes
07:10:13 <Philippa> right, that's why to do it that way - you only care about the interface complexity that way
07:10:22 <ndm> yeah
07:10:25 <TheHunter> cognominal, furthermore, you often don't need braces, let fac 0 = 1; fac n = n*fac (n-1) will work fine.
07:10:37 <Philippa> have to admit, I'd love it if I could run ghci as another window in Textpad
07:10:54 <ndm> TextPad doesn't let you run windows with that much power does it?
07:11:17 <TFK> Textpad, ugh.
07:11:18 <Philippa> no
07:11:27 <ndm> i have considered it
07:11:33 <Philippa> TFK: given that I don't get on well with emacs or vi, any suggestions?
07:11:41 <Philippa> free-or-cheap suggestions, that is?
07:11:47 <ndm> i also considered forcefully docking a window inside TextPad
07:11:47 <Philippa> I like my MDI, MDI matters
07:11:56 <TFK> A custom Haskell IDE? ;-)
07:12:05 <Philippa> suggestions that exist?
07:12:08 <TFK> Speaking of which, is Haste discontinued?
07:12:24 <TFK> Hmmm. Leo?
07:12:30 <Philippa> once there's a sufficiently-good wxYi I might play with that
07:12:42 <TFK> I don't know, really. There isn't a cross-platform text  editor I use consistently.
07:12:57 <ndm> I will never move from TextPad, so I will definately try to get some more Haskell integration for it
07:12:58 <Philippa> I don't care about cross-platform
07:13:09 <TFK> Other people do, though.
07:13:17 <TFK> (Right, people? ;-)
07:13:31 <Philippa> sure, but it was my taste in editors you were commenting on, no?
07:13:49 <TFK> Oh, not at all. Just in general, TextPad limits the target audience.
07:14:07 <Philippa> um, consider the nature of the project to start with...
07:14:17 <Philippa> "WinHugs", "WinGhci"...
07:14:39 <TFK> If there is a way to wrap GHCi in some GUI, I'm sure it can be cross platform.
07:14:46 <TFK> (Right?)
07:14:57 <ndm> but how many people who use non-windows care about a GUI
07:15:03 <xs_> me.
07:15:03 <Philippa> also, it's IME cross-platform stuff feels crap under windows
07:15:14 * TFK raises a hand
07:15:17 <xs_> you've not seen enlightenment? mm.. pretty.
07:15:18 <Philippa> plenty of folks do. OTOH, the integration tools off-windows tend to be better IME
07:15:20 <TFK> IME?
07:15:24 <Philippa> In My Experience
07:15:47 <TFK> So I take it that you wouldn't use any GTK stuff under Windows?
07:15:49 <Philippa> cross-platform apps often have a significantly non-native feel under windows
07:15:55 <TFK> (What's OTOH again?)
07:16:05 <TFK> What about wx?
07:16:12 <Philippa> In a pinch, but I'm not fond of it given an otherwise equally-good alternative
07:16:22 <Philippa> wx's been okay IME but has limitations on what you can achieve with it
07:16:48 <TFK> Hmmm, such as?
07:16:52 <ndm> In general, real windows apps are faster and more native looking
07:16:54 <Philippa> I had enough trouble just figuring out how to get an appropriate received-messages box for an IRC client using wxHaskell, it keeps fucking up the positions
07:17:15 <TFK> positions of what? The dialog?
07:17:21 <TFK> You mean laying widgets out in wx?
07:17:35 <Philippa> no I don't, as I'd probably use a similar layout lib under windows anyway
07:17:52 <TFK> Sizers are good for the soul.
07:17:54 <Philippa> I'm pretty sure I found some combinations of dockery and a few other tricks that I couldn't pull off
07:18:19 <Philippa> no, what it was doing wrong was when I appended a message that should cause it to scroll, it scrolled to an invalid state and beeped
07:18:25 <TFK> Yes, because sizers are the wave of the future.
07:18:29 <Philippa> you had to touch the scrollbar to get it to show text again
07:18:36 <Philippa> no, they're the wave of the past catching up with everyone
07:18:37 <TFK> Hmmm.
07:18:48 <TFK> I'm talking in terms of wx.
07:19:00 <Philippa> ah, I'm not an old hand with it
07:19:03 <TFK> What is the global wave of the future, then?
07:19:35 <Philippa> do I look psychic? :-)
07:19:50 <TFK> Well... what is the wave of the present, then?
07:20:11 <Philippa> I'm not looking at the research-level stuff much, though FRP in some shape or form's probably relevant
07:20:49 <TFK> Let me rephrase. What does the market offer that is better than sizers or their equivalents?
07:21:09 * Philippa sighs
07:21:13 <Philippa> did I say it offers anything that is?
07:21:19 <Philippa> they're an old concept, that's all
07:21:37 * poetix warns TFK against running with sizers
07:21:49 <TFK> That's OK. I'm a GTK person anyway :-P
07:22:03 <TFK> (We have boxes and tables!)
07:22:39 <poetix> How do you hook Haskell into GTK?
07:22:45 <Philippa> what's sad is pretty much everyone's stuck having to use a second-rate implementation of old ideas, which really gets in the way of producing nice UIs quickly
07:22:49 <TFK> With Gtk2Hs :-P
07:23:01 <Philippa> I've never yet used a GUI lib that let me just do everything I had in mind at the time
07:23:15 <TFK> FFTSAP?
07:23:18 * TFK giggles
07:23:25 <Philippa> more like FFTwrite my own damn library
07:23:35 <TFK> That's the spirit!
07:23:38 <Philippa> because that tends to be the level of work involved
07:23:43 <TFK> Hey, you might get rich and famous.
07:23:53 <Philippa> and it's not something one person can do /and/ do the projects they want the damn lib for in the first place
07:24:01 <Lemmih> dons: Do you know when we'll know if our cops and robbers have qualified?
07:24:24 <TFK> "I have a dream!"
07:24:59 <Philippa> GUI libs aren't somewhere where FFTSAP is appropriate criticism of ideas. "We don't want to implement this", sure
07:25:13 <TFK> Pardon?
07:25:39 <TFK> You mean they're a big, unmovable mountain of code that is heavily guarded by a few zealous devs?
07:25:40 <Philippa> Your comments regarding GHCi are something that a) doesn't require a complete design overhaul and b) can be implemented by a lone hacker with a bit of spare time
07:26:13 <Philippa> in practice yes, they are. Because it takes more than a lone hacker to make significant changes, which means there needs to be a serious design dialogue
07:26:16 <musasabi> GUI libraries tend to be designed for a C interface which limits things quite a lot.
07:26:45 <TFK> IIRC, wx was designed for a C++ interface.
07:26:52 <TFK> Although GTK is implemented in C.
07:27:09 <poetix> There's increasing mainstream interest in declarative approaches: XUL, XAML, Laszlo...
07:27:16 <TFK> However, if it's so easy (and basic), one can only wonder why it's not there.
07:27:36 <TFK> (As opposed to cool GUI libs, which aren't there either.)
07:27:36 <Philippa> TFK: the underlying support isn't, and I never said it was
07:27:55 <Philippa> the underlying support is somewhat complicated and requires genuine effort
07:28:14 <Philippa> otherwise somebody would've been told FFTSAP and said "sure, here's the code"
07:28:40 <Philippa> (or at least "here's the code for my platform")
07:28:59 * TFK sighs
07:30:27 <ndm> if its any consolation, i have a design for a GUI language
07:30:40 <ndm> which will have all the goodness anyone could possibly want, and be functional in nature
07:30:48 <ndm> (but no time to implement it yet)
07:30:54 <TFK> heh
07:30:54 <Philippa> is it also implementable with native look-and-feel everywhere? That's the hard bit
07:31:09 <ndm> it is on windows, which is the bit i care about
07:31:12 <TFK> How about Qt?
07:31:28 <Philippa> Can't remember the particular way Qt pissed me off aside from having to pay to use it under windows
07:31:31 <ndm> but yes, it should be doable everywhere - Win native, with QT elsewhere
07:31:31 <TFK> Unfortunatelly, having a native look and feel on windows may imply several deficiencies.
07:31:52 <poetix> QT4.0 will be free on windows for GPL projects
07:32:02 <ndm> Mozilla have almost done it with XUL, so its getting possible
07:32:04 <TFK> Specifically what drove me to GTK - apparently, WinXP doesn't support BiDi.
07:32:08 <Philippa> yay for freedom! Oh wait, freedom involves being able to eat in my book
07:32:21 <Philippa> BiDi?
07:32:25 <ndm> WinXP does, i'm pretty sure
07:32:30 <ndm> Bidirection text
07:32:33 <TFK> Bidirectional input.
07:32:38 <TFK> ndm, I dare you to show me how :-)
07:32:44 <TFK> Lord knows I tried for a while now.
07:32:46 <Philippa> I could swear the Rich Text Control does
07:32:57 <TFK> And everything else?
07:33:11 <TFK> Like lables, menus, one-line-text-entries?
07:33:12 <ndm> i have no idea where, but i'm pretty sure - there are flags everywhere for RTL (Right to left)
07:33:25 <ndm> one line text does, from what i remember
07:33:40 <TFK> I don't want a flag. I want to start writing in Hebrew anywhere, and I want for the OS to treat it properly.
07:33:48 <TFK> Not over here.
07:34:03 <Philippa> TFK: you can get an RTC to be a one-liner. Labels and menus don't /do/ input...
07:34:07 <ndm> if you have the flag set, then if the person has an appropriate OS, they will get RTL
07:34:26 <Philippa> and yes, there're flags
07:34:28 <ndm> appropriate, meaning a Hebrew localised edition
07:34:29 <TFK> Philippa, right - so how do I display proper BiDi in them?
07:34:37 <Philippa> and yes, you'll have to build everything on top of the API but that's just windows for you
07:34:42 <Philippa> it's not like it does anything for you at all
07:35:06 <TFK> localised? Many people don't have localized versions (and don't *want* localized versions) but still write in Hebrew and Arabic.
07:36:24 <ndm> yeah - the problem with having more than one mode
07:36:29 <TFK> Incidentally, GTK does it for free. It does it for free regardless of layout (it supports both LTR and RTL layout of widgets) - it detects an RTL language is being typed, and handles it properly.
07:36:40 <ndm> in XP, it may be possible to switch this in the control panel
07:36:47 <TFK> I tried.
07:36:51 <Philippa> yes, GTK's a higher level of library than the win32 API ever attempts to be
07:37:26 <Philippa> in practice, everybody uses a higher-level lib under windows, even if they wrote it themselves
07:37:40 <xs_> yum mfc.
07:37:44 <TFK> Yes, but wx doesn't seem to handle this properly, either.
07:37:49 <TFK> I'm not sure if Qt does, though.
07:38:20 <TFK> I'll have to take a look at it one day...
07:38:21 <Philippa> yeah, I'm glad not to be in a position to worry about i18n
07:38:39 <TFK> Right, right. The i18n people will take care of themselves ;-)
07:38:57 <Philippa> no, my position is that of not writing GUI code intended for anybody else's use :-)
07:39:07 <Philippa> which means it really /isn't/ my problem
07:39:42 <ndm> Haskell is an english language, so developer tools are typically in English
07:40:16 <ndm> the only reason I would personally go to the trouble to Bidi things is if I was being paid to
07:41:09 <TFK> Philippa, that would make sense. But unfortunatelly a lot of public projects seem to take a similar view, even though they are public.
07:41:21 <Philippa> yeah :-(
07:41:26 <Cale> which is a good reason that the widgets themselves should know how to handle BiDi.
07:41:38 <Philippa> and that's the level where I don't consider FFTSAP acceptable, because it's a design-level issue
07:41:47 <TFK> Everything about programming seems to be in English. I'm translating Gazpacho to Hebrew, and I realized that many terms simply don't have Hebrew equivalents.
07:41:58 * Philippa nods
07:41:59 <poetix> Except Ruby
07:42:07 <TFK> hehe
07:42:32 <Philippa> 'mafraid as an englishwoman I'm going to just add to the pile there, with a minor defence of english being the lingua franca in the fields I tend to work in
07:43:04 <Philippa> (and yes, I'm aware of how bad an argument that is coming from someone who speaks it as a first language)
07:43:28 <poetix> I read somewhere that at the current rate of growth, Spanish will replace English as the majority language in the US in a few years' time.
07:43:47 <TFK> poetix, must be KKK propoganda ;-)
07:43:57 <TFK> At any case, this is why I'll keep using GTK for a while.
07:44:09 <Philippa> yeah, I appreciate everyone has reasons for their libs
07:44:35 <Philippa> in turn, lack of native look-and-feel is an issue not dissimilar to localisation for me, if you see where I'm coming from
07:44:41 <TFK> (That shouldn't stop other libs from supporting BiDi, btw.)
07:44:51 <Philippa> 'course not
07:45:27 <TFK> I see where you're coming from. It's a trade off thing, albeit everyone should strive for excellence, reducing the negative aspects.
07:45:36 * TFK envisions a utopia
07:45:51 * Philippa envisions somebody having written a UI lib that doesn't suck one day
07:46:02 <Philippa> but hey :-)
07:46:20 <TFK> Yeah, my vision is way more practical.
07:46:35 <CosmicRay> Philippa: yet to happen, in any language :-)
07:46:50 <Philippa> I'm happy at the user level to have a choice between native l&f and better localisation
07:47:07 <Philippa> CosmicRay: did I specify a language? No :-)
07:47:44 <Philippa> it'd certainly be possible for a specific platform here and now (or if you get to define the look&feel from scratch because you're writing the platform's UI layer)
07:49:42 <TFK> (GTK is completely native on Gnome ;-)
07:50:35 <poetix> Sidebar on population trends: http://www.bytelevel.com/blog/archives/000613.html
07:55:14 <TFK> Guys, does anyone want a gmail account?
07:56:14 <Philippa> I don't, I get too much confidential email to want to worry myself working out what their privacy policy amounts to these days
07:57:38 <TFK> What does everyone's privacy policy amount to?
07:57:49 <poetix> I use mine for mailing lists, where everything's public anyway.
07:58:05 <poetix> And the level of traffic is high, so why not let it clog up their servers?
07:58:10 <Philippa> in the UK, it amounts to something I can sue over exceedingly easily. Which is why my mail account's hosted in the UK
07:58:24 <TFK> Best just buy a domain name and host a pop3/smtp server yourself :-P
07:58:35 <ndm> i use mine for everything, but fortunately my life is very dull - nothing anyone would want to look at
07:58:37 <Philippa> well yeah, but in the absence of that...
07:58:41 <ndm> my gmail account that is
07:59:12 <Philippa> dealing with someone who has to assume customer email is confidential anyway (and is subject to legal enforcement) is as good as I'm going to get
07:59:30 <Philippa> the UK has way tighter data protection laws than the US, too
08:02:52 <TFK> Any other vict... err, interested people?
08:03:24 <poetix> Can't give 'em away nowadays.
08:03:55 <poetix> Not that I used to auction them on ebay, or anything.
08:04:04 <TFK> Riiight...
08:04:12 <TheHunter> people who are concerned about their email's privacy should encrypt them.
08:04:14 <TFK> Well, I got fifty of them.
08:04:42 <poetix> There was a period of about a week when that might have been quite a money-spinner. Oh well.
08:04:50 <Philippa> TheHunter: agreed, but it doesn't always happen in practice
08:04:53 <TFK> A week? More like months.
08:05:25 <TFK> People went crazy over it, being a rare commodity and all.
08:05:27 <poetix> Overlap between the period of the demand and the period in which I had invites was about a week.
08:05:54 <Philippa> and some folks have info that's private but probably safe in the hands of the intermediate ISPs so long as it doesn't end up in a marketing database somewhere (which ISPs in this country will end up in deep, deep shit for doing)
08:05:55 <poetix> I was pathetically grateful when I got mine. And I do mean pathetically.
08:05:59 <TFK> Maybe the friends of your friends have connections to the IT industry.
08:06:12 <poetix> Friends?
08:06:30 <TFK> You have friends, right?
08:06:32 <TFK> o_O
08:06:40 <TFK> Hey, for all you know, you may be a google employee ;-)
08:07:09 <poetix> Oddly enough, most of my friends don't use computers much.
08:07:29 <poetix> I mean my flesh-and-blood friends, as opposed to all the people I yak to online.
08:07:30 <TheHunter> Philippa, yeah, that's a pity. I assume all my unencrypted emails to be saved somewhere - regardless of the provider I use.
08:07:46 <TFK> Hence the "friends of your friends". You never know to whom you may be connected via two or three edges of the friendship graph.
08:07:56 <Philippa> Saved, sure. Likely to propagate anywhere that's a worry? That's the thing people're making a call on
08:08:44 <TFK> Echelon is omnipresent :-P
08:09:00 <Philippa> not quite, but in the UK you're pretty much screwed by it either way
08:09:25 <Philippa> thing is, if you're worried by the spooks you're going to use encryption - most stuff's more domestic-level than that, the equivalent of stuff you told the counsellor
08:09:39 <TheHunter> i once made the rest of my family only send pgp-signed mails. I turned it off soon because they were getting complaints from people who couldn't read their "attachements" again and again.
08:09:53 <TFK> hehe
08:10:14 <Philippa> figures
08:10:25 <TFK> But, again, if privacy is a real concern, than your own e-mail server + encryption + tinfoil hate is the best way to go.
08:10:31 <TFK> *then
08:10:34 <TFK> **hat
08:10:37 <poetix> My hate is naked and unadorned.
08:10:52 <dcoutts_> Horray! ICFP competition is over! (for now) no more difficult hacking for two weeks! :-)
08:10:54 <Philippa> TFK: it's of a level where I don't need that but shouldn't be putting it anywhere it's going to get run through someone's scanners
08:11:03 <TFK> dcoutts_, :-D
08:11:05 <TFK> How did it go?
08:11:18 <dcoutts_> TFK, glad to see you've been keeping up the promotion of Gtk2Hs while I've been away ;-)
08:11:32 <dcoutts_> you should be our marketing spokesperson :-0
08:11:43 <TFK> Philippa, you are merely hoping that fear of punishment will deter malicious parties.
08:11:49 <TFK> \o/
08:11:53 <dcoutts_> TFK, it went so so I think, it's hard to judge
08:12:08 <TFK> dcoutts_, the solution *does* compile, though? ;-)
08:12:17 <dcoutts_> dons, how do you think you did? like you said, AI without know much AI
08:12:25 <dcoutts_> TFK, yes it does :-)
08:12:43 <dcoutts_> they even sometimes rob banks / catch robbers !
08:13:14 <TFK> So it can be even considered to boot! In the words of Linus Torvalds that's perfect :-P
08:13:20 <dcoutts_> indeed!
08:13:22 <TFK> Did you solve it in a group or by yourself?
08:13:23 <kosmikus> hehe
08:13:36 <dcoutts_> group of 3, sadly without kosmikus :-(
08:13:54 <kosmikus> oh, so you didn't find any replacement in the end?
08:13:58 <dcoutts_> nope
08:14:03 <kosmikus> why not?
08:14:15 <dcoutts_> people couldn't / wouldn't
08:14:29 <kosmikus> hmm
08:14:32 <Itkovian> considering it's weekend, that seems logical
08:14:42 <kosmikus> sorry again, but I really wouldn't have had any time left this weekend
08:14:46 <kosmikus> bad timing
08:14:48 <Lemmih> dcoutts_: Do you know when we'll know if our cops and robbers have qualified?
08:14:53 <dcoutts_> we probably could have done with a bigger team this year because the cop / robber split allows you to split your team and work in parallel
08:14:55 <TFK> There are 52 times as more weekends as there are opportunities to participate in the ICFP.
08:14:59 <poetix> Cops and Robbers looks like a game that could run and run
08:14:59 <kosmikus> I'll plan better next year
08:15:02 <TFK> *as many
08:15:04 <dcoutts_> Lemmih, I've no idea
08:15:32 <kosmikus> congratulations anyway to all who participated
08:15:33 <Itkovian> TFK: true, but for some of us, weekends are considered non-computing time
08:15:44 <adept> lets bit binary bots :)
08:15:47 <TFK> Pseudo-geeks, eh?
08:15:53 <adept> pit, even
08:15:56 * TFK joins kosmikus 
08:16:07 <dcoutts_> poetix, yes, we've got various ideas for how to play it better that we did not think of quickly enough or have time to implement
08:17:06 <dcoutts_> TFK, you and someone else had some Gtk2Hs bugs for me?
08:17:21 <TFK> Aye, I posted on gtk2hs-users
08:17:25 <dcoutts_> oh, cool
08:17:41 <poetix> dcoutts_: is your CopBot / RobberBot strategy easily describable?
08:17:42 <dcoutts_> including code to reproduce the bug?
08:17:52 <TFK> Affirmative.
08:17:59 <dcoutts_> TFK, ta muchly
08:18:10 <dcoutts_> poetix, possibly, put I couldn't possibly describe it in public :-)
08:18:32 <TFK> Say, maybe you can get a proper bug database? I'm sure Gnome could host a Gtk2Hs one.
08:18:41 <TFK> They host PyGTK's, for example.
08:18:49 <dcoutts_> TFK, so far we've not had enough bugs :-)
08:18:55 <TFK> heh
08:18:58 <dcoutts_> we could use the SF trackers, but they're horrible
08:19:27 <TFK> You mean the SF bug database?
08:19:34 <dcoutts_> TFK, right
08:19:45 <dcoutts_> I don't know if the gnome people would let us use their bugzilla if we're not using their cvs
08:20:07 <dcoutts_> do they have other SF hosted projects using their bugzilla I wonder?
08:20:31 <TFK> No idea.
08:20:40 <TFK> Well, as long as there aren't that many bugs, perhaps the ml is enough.
08:20:55 <dcoutts_> do you think the SF bug tracker would be better?
08:21:12 <TFK> I'm not familiar with those enough to say for sure.
08:21:35 <dcoutts_> it's more of a pain for users I think, since they need accounts, rather than just sending email
08:21:51 <dcoutts_> perhaps we should ask bugs to be sent to the devel list rather than users however
08:21:58 <TFK> Yes, anonymous submissions would encourage people.
08:22:11 <TFK> I don't think that that would help much.
08:22:16 <dcoutts_> that's what I figure
08:22:51 <dcoutts_> I mean sent to devel rather than user is a seperate issue, it just to reduce the spamming of the people on the users list
08:23:00 <TFK> Since people need to sign up for another list, they might as well get an account.
08:23:03 <dcoutts_> it's about 25 on users vs. 8 on devel
08:23:08 <TFK> hehe
08:23:12 <TFK> then there's no spam ;-)
08:23:32 <dcoutts_> no spam?
08:24:01 <TFK> On a related note, I wanted to alert you to naming collisions in "import Graphics.UI.Gtk" - for example, Entry and TextView event-connector's names.
08:24:28 <dcoutts_> TFK, yes, there are a number of those, name space collisions are a real pain
08:24:33 <TFK> There's not much traffic anyway, so I don't think people would mine. It would also alert them to current gotchas.
08:24:42 <dcoutts_> true
08:25:09 <dcoutts_> we can't really ask that people import GTK qualifiied since they'd have to import every module they used with qualified
08:25:28 <dcoutts_> we need the qualified export extension to solve it (which doesn't exist yet!)
08:25:37 <TFK> heh
08:25:44 <TFK> How do other toolkits handle this?
08:26:17 <dcoutts_> in other languages they use qualifed imports but they can do it better
08:26:19 <TFK> On a different note, it seems that the interface as a whole is somewhat bulky and verbose. Are there plans to give it an overhaul in the future?
08:26:35 <dcoutts_> can you think of any improvements?
08:26:50 <dcoutts_> we are now providing the properties API which improves things quite a bit
08:27:05 <TFK> In OOP languages each class keeps their own namespace, but in Haskell it's a bit of an issue.
08:27:23 <TFK> Not atm. But maybe ideas can be lifted from other toolkits ;-)
08:27:30 <dcoutts_> set obj [ prop1 := val1, prop2 :~ \old -> makeNewVal old }
08:27:55 <TFK> So that is the syntax?!
08:28:21 <TFK> I've been beating my head for a while to figure out how the Prop syntax works.
08:28:28 <dcoutts_> yes, roughly
08:29:01 <Philippa> TFK: it's not really that big a deal. The namespace is per-module, but you can work with that
08:29:17 <TFK> Philippa, after 20 imports.
08:29:25 <TFK> (For a simple GUI)
08:29:46 <dcoutts_> TFK, eg: set window [ containerChild := myButton ]
08:29:47 <Philippa> with no room for overloading?
08:30:03 <TFK> Philippa, what do you mean?
08:30:13 <Philippa> I don't buy all 20 uses of an identifier not having enough in common for a typeclass
08:30:30 <dcoutts_> Philippa, that's what wxHaskell does atm
08:30:33 <Philippa> yeah
08:30:40 <dcoutts_> I'm not convinced however
08:30:48 <dcoutts_> the types of the arguments are often different
08:31:06 <dcoutts_> you'd end up with lots of multi-parameter type classes I think
08:31:14 <Philippa> yeah. I don't have a problem with that, mind
08:31:29 <dcoutts_> using qualified names is closer to what everyone else does
08:31:40 <reffie> http://segfaulted.com/screenshots/Screenshot-32.png
08:32:02 <TFK> what do you mean by qualified names? C-style names, like adjustmentGetFoo?
08:32:10 <Philippa> Module.identifier
08:32:19 <TFK> Ah, that.
08:32:27 <dcoutts_> yes that's what we'd like
08:32:30 <TFK> That's a good approach.
08:32:37 <Philippa> dcoutts_: there're usages where I'd do that. But when you're converting a class hierarchy, the type class solution seems more appropriate to me
08:32:50 <TFK> Will decrease the verbosity to suit the level of the programmer.
08:33:12 <Philippa> not least because type classes offer you the possibility of polymorphism
08:33:17 <dcoutts_> we are using type classes for the type class hierarchy, but there are other things that cut across the type class hierarchy that cause problems
08:33:41 <TFK> reffie, the background is disturbing.
08:33:50 <Philippa> dcoutts_: JOOI, such as?
08:34:09 <reffie> TFK heh
08:34:11 <dcoutts_> JOOI ? huh?
08:34:17 <Philippa> Just Out Of Interest
08:34:18 <TFK> Seriously o.o
08:34:56 <TFK> Do any of you guys use Leo?
08:35:10 <poetix> Tried it ages back
08:35:13 <dcoutts_> oh, TFK's example of the Entry widget and TextView widget definint the same event types, but they have no common ancestor with those event types
08:35:41 <poetix> Didn't have time to scale the learning curve, but it looked potentially very useful.
08:36:14 <Philippa> dcoutts_: I can't see how that's undoable with type classes, maybe I'm not thinking straight?
08:36:19 <dcoutts_> Philippa, we'd have to consider on a case by case basis wether we could stuff both things into some sensible type class
08:36:34 <Philippa> yeah, that's true
08:36:36 <dcoutts_> sometimes I think the two things are jsut too different
08:36:44 * Philippa nods
08:37:15 <Philippa> I'm not saying typeclass everything, just much of it (and assuming much of it's typeclassable, I guess)
08:37:22 <dcoutts_> and it's also a matter of taste, qualified names are the propper thing to do, we don't use type classes just to so we can have heavily overladed short generic names
08:37:52 <dcoutts_> sure, there is a line to be drawn somewhere, I'm not saying we've got the balance right yet
08:38:13 <dcoutts_> our current name prefixing solution is not at all desirable
08:38:20 <Philippa> nor would I, I'd expect there to be something in common conceptually for something to have a (user-visible) typeclass
08:38:22 * TFK nods
08:38:34 <TFK> (Also the only line I could understand from the conversation :-/ )
08:38:42 <dcoutts_> :-)
08:38:59 <dcoutts_> Philippa, right yes
08:39:38 * TFK installs LEo
08:39:55 <poetix> Isn't Leo written in Python?
08:40:12 <dcoutts_> poetix, so did you entry the icfp competition?
08:40:16 <TFK> I'm not entirely sure.
08:40:25 <TFK> But it uses Python, at least.
08:40:29 * poetix is not nerely clevver enuff
08:40:39 * lispy skipped it this year too
08:40:46 <poetix> But I read the description, and it looked like great fun.
08:40:50 <TFK> "100% pure  Python. Leo uses Tk/tcl to draw the screen."
08:41:07 <poetix> Tk! The solution to all your GUI woes!
08:41:11 <dcoutts_> poetix, yes quite fun, but intense
08:41:30 <TFK> Nah, it can't handle BiDi properly as well, it seems :-(
08:42:35 <dcoutts_> I should go fetch my unicycle or it'll get loced in.. bak in a moment...
08:42:36 <poetix> dcoutts_: what were the time frames? How long did you have?
08:51:24 * poetix browses the TMR article on Gtk2Hs
08:59:14 <dcoutts_> poetix, we had 72 hours (3 days)
08:59:14 <wilx> Heh, 2004 ICFP task sounds nice.
08:59:24 <dcoutts_> wilx, yeah it was! :-)
09:00:41 <dcoutts_> I've got a new simulator / visualiser for the 2004 ICFP task, which run really fast. I felt compelled to rewrite them since our original programs were much slower than any other highly placed entry.
09:01:17 <dcoutts_> we were being thrashed by the simulators in Java which is always embassing.
09:01:34 <dcoutts_> but now it's the other way around, so that's ok. :-)
09:01:35 <TFK> hehe
09:01:46 <TFK> Was the code idiomatic, however?
09:02:01 <TFK> *Is the ...
09:02:19 <dcoutts_> reasonably, but optimised code in any language in not usually idiomatic (except perhaps C becasue all C code ...)
09:02:56 <dcoutts_> it was mostly a matter of using a different data representation and then hiding that behind a bunch of little wrapper functions
09:08:33 <lispy> dcoutts_: i made a visualizer for icfp2004 as well, and mine was very slow.  I blame cl-sdl and array access
09:09:13 <CosmicRay> shapr: ping
09:09:17 <lispy> dcoutts_: http://codersbase.com/Icfp2004
09:09:23 <dcoutts_> lispy, yes the array access can be very slow, I tried several different ways when trying to speed it up
09:09:29 <CosmicRay> @seen shapr
09:09:31 <lambdabot> shapr is in #unicycling, #swhack and #haskell. Last spoke 6 hours, 4
09:09:31 <lambdabot> minutes and 21 seconds ago.
09:09:35 <CosmicRay> heh
09:10:51 <dcoutts_> lispy, but then for the gui bit, I was just careful to send only the minimum amounts of requests/command to the X server and that makes it fast. The GDK drawing primitives are really only thin wrappers over the xlib stuff so you can be sure that what you're doing is quick.
09:11:21 <dcoutts_> the other thing is to create all X graphics resources at the beginning so you don't need round trips to the X server later
09:11:29 <TFK> Funky. It seems that TextBuffer's onInsertText doesn't like threads.
09:11:53 <TFK> The non-threaded version seems to work, though. Is this expected behaviour?
09:12:24 <dcoutts_> TFK, threads in GUI libs is a very tricky issue
09:12:52 <TFK> I've noticed.
09:12:56 <poetix> How do you marshall calls back from a worker thread to the GTK event loop?
09:13:08 <dcoutts_> mostly they should be used in a single threaded manner, then it ought to be possible to allow multiple Haskell threads to do everything all at once but it needs tupport from the RTS
09:13:27 <TFK> RTS?
09:13:43 <lispy> run-time system
09:14:22 <dcoutts_> if we do it right it ought to be possible to do GUIs using multiple Haskell and have them map onto one OS thread and so the underlying Gtk+ C library will not barf
09:14:29 <lispy> does lambdabot have an @wtf for acronyms?
09:14:33 <lispy> @wtf RTS
09:14:36 <lambdabot> No match for "RTS".
09:14:42 <wilx> Heh, this http://cristal.inria.fr/~regisgia/icfp04.shtml entry is pretty insane :D
09:14:43 <lispy> @wtf iirc
09:14:45 <lambdabot> No match for "iirc".
09:15:00 <wilx> Whole compiler for the task.
09:15:05 <poetix> In .Net land, Windows.Forms at the moment requires you to pass a delegate to a special method on the window, Invoke, that calls that delegate on the main window thread
09:15:18 <dcoutts_> it's the same issue with wxHaskell and probably others, we need better RTS support for controlling the Haskell thread -> OS thread mapping
09:16:12 <dcoutts_> poetix, yes you can do that in Gtk+ by adding something to be called later in an idle handler, or similar
09:16:34 <poetix> I think callbacks get popped onto a thread-safe queue, and popped-off any time the main window thread isn't busy doing something else.
09:17:03 <dcoutts_> yes, so it's safe to call GUI things from the callbacks
09:17:29 <poetix> I'm fairly comfortable with that pattern
09:18:15 <dcoutts_> but it's really cool to be able to spawn a thread to do some work and to update a progress thingy while that thread is going (althought this can be done another way)
09:18:24 <TFK> Well, this one callback doesn't seem to work very well.
09:18:39 <TFK> (Or am I missing something?)
09:18:59 <dcoutts_> it's ok to spawn a worker thread that does work but doesn't touch any GUI things and have the results communicated back to the main thread
09:19:23 <TFK> What do you mean? My other threads writes to a text buffer, for example.
09:19:29 <TFK> (So does my main  thread)
09:19:54 <poetix> Well, using a callback queue you can send messages back to the GUI any time you like - but the GUI will pick them up in its own time (that is, on its own schedule)
09:19:57 <dcoutts_> Ah, that's probably bad since when you modify the text buffer, it's updates the GUI to reflect the changes in the buffer
09:20:25 <dcoutts_> TFK, and presumably your running with the threaded ghc rts
09:20:27 <TFK> Ah, but that works! Catching text insertion signals does not, however.
09:20:38 <TFK> I suppose I am.
09:20:59 <poetix> It may be that whether it works or not depends on the vagaries of the scheduler...
09:21:17 <dcoutts_> so you're genuinely using 2 OS threads and making (indirectly) GUI calls on the other thread (ie not the one that entered the Gtk main loop)
09:21:46 <dcoutts_> and that's bad
09:21:53 <dcoutts_> at least at the moment it is - I have plans to make it better
09:22:10 <poetix> Haskell threads aren't OS threads?
09:22:14 <dcoutts_> nope
09:22:20 <TFK> Well, I'm using forkIO, just like the progress-bar example did.
09:22:53 <dcoutts_> poetix, many haskell threads can be multiplexed on one OS thread
09:22:56 <dcoutts_> TFK, well it's more subtle than that...
09:23:15 <dcoutts_> TFK, the progress-bar demo was using the single threaded ghc rts
09:23:19 <poetix> How does it work on a multiprocessor system?
09:23:49 <TFK> But what's the difference? frokIO there, and forkIO here.
09:23:55 <TFK> Both threads updated the GUI.
09:24:12 <dcoutts_> @google Haskell on a Shared Memory Multiprocessor
09:24:14 <lambdabot> http://www.haskell.org/~simonmar/papers/multiproc.pdf
09:24:25 <dcoutts_> poetix, check it out, it very cool
09:24:33 <dcoutts_> TFK, sorry I was saying...
09:24:34 <poetix> dcoutts_:thx
09:25:02 <dcoutts_> so the difference is that in the single threaded rts, there is only one OS thread...
09:25:41 <dcoutts_> but then the call to the Gtk+ main loop would block the whole thing, including all other Haskell threads since the RTS doesn't get a chance to schedule...
09:25:59 <TFK> Yes, so isn't that what I'm doing anyway?
09:26:47 <dcoutts_> so, what we do (which is an ungodly hack) is to stick a callback that gets called regularly from the Gtk+ main loop which gives the ghc rts a chance to schedule and run other threads
09:27:05 <dcoutts_> TFK, I'm not sure what you're doing, let me go read your code...
09:28:35 <TFK> http://hbin.dyndns.org/pastebin/57.html <--- this is about it. That code works, I commented out the event handler that doesthe trouble.
09:29:44 <dcoutts_> ok
09:29:51 <poetix> Wow, capabilities for synchronization
09:31:40 <dcoutts_> so it's the onInsertText that goes wrong?
09:32:31 <TFK> Yup
09:32:34 <SyntaxNinja> woot
09:32:46 <TFK> It seems to work fine in single-threaded environment, though.
09:32:53 <dcoutts_> TFK, so that bit is not using threads at all
09:33:00 <TFK> But, probably just my code that's wrong - my first time with threads.
09:33:09 <dcoutts_> TFK, so you're building this with -threaded or not?
09:33:34 <TFK> I fork off watchConn, which can update the text buffer, which in turn triggers that event.
09:33:46 <dcoutts_> oh right
09:34:01 <TFK> I didn't specify any special GHC flags, so whatever is on by default, I suppose..
09:34:07 <dcoutts_> oh, hmm
09:35:03 <dcoutts_> if you comment out the line "idleAdd (yield ..." line does it stop working as in appear to block and not receive network traffic (this will tell us if it's using the threaded rts)
09:38:02 <wilx> Wheee.
09:38:03 <dcoutts_> hmm, so the ghc docs indicate that it should be using the single threaded rts by default
09:38:08 <TFK> Yup, there appears to be no network traffic.
09:38:23 * poetix jogs the arm of a colleague carrying a glass of orange juice, is splashed with ascorbic acid, and dissolves abruptly
09:38:26 <wilx> Looking at the winer's ants solution I cannot wait to see this years solutions :D
09:38:43 <dcoutts_> wilx, I doubt it'll be us this year
09:39:27 <dcoutts_> TFK, ok so maybe the threaded rts is the ghc default these days.
09:39:58 <TFK> I'm confused. Threaded RTS -> OS threads or Haskell-only threads?
09:40:05 <dcoutts_> TFK, er, oh no, the other way around ,that mean
09:40:39 <dcoutts_> (let me get this straight) blocking when you remove the idle yield handler means we running the single threaded rts
09:41:26 <TFK> Right. So the forkIO is a Haskell-only thread.
09:41:39 <dcoutts_> threaded rts = using multiple OS threads, allowing FFI calls to run in parallel to other Haskell threads
09:41:48 <dcoutts_> yes that's right
09:42:20 <dcoutts_> so you're only using one OS thread, so it should work - which means I'm not sure what's going on yet! :-)
09:43:11 <dcoutts_> it may be that idle handlers get run outside of the GDK lock, i'll have to look that up...
09:45:11 <boegel> yo dcoutts_
09:45:19 <boegel> how's HOpenGL support in gtk2hs doing ? :)
09:45:22 <dcoutts_> hia boegel
09:45:24 <dcoutts_> hah!
09:45:31 <TFK> Hmmm.
09:45:42 <dcoutts_> we're in post release bug squashing mode at the moment boegel
09:45:50 <TFK> Should I make a simpler test-case, then?
09:46:01 <dcoutts_> TFK, let me look something up first
09:46:08 <TFK> aye aye
09:46:12 <boegel> dcoutts_: hmm, nice :)
09:46:25 <boegel> but I probably won't have time to play around with it until August
09:46:46 <dcoutts_> boegel, ok that gives me some time :-)
09:46:54 <boegel> dcoutts_: no rush :p
09:48:03 <dcoutts_> TFK, I quote "Idles, timeouts, and input functions are executed outside of the main GTK+ lock. So, if you need to call GTK+ inside of such a callback, you must surround the callback with a gdk_threads_enter()/gdk_threads_leave() pair."
09:48:24 <TFK> O_O
09:48:45 <dcoutts_> so that means that the idle yield is called outside the GDK lock so we can't call Gtk+ functions in other threads
09:48:47 <shapr> CosmicRay: yes?
09:49:19 <dcoutts_> TFK, we might be able to put  gdk_threads_enter()/gdk_threads_leave() around the call to yield
09:49:47 <TFK> But I'm already calling some GTK functions inside threads.
09:50:25 <dcoutts_> however I think it might be better to make the watchConn pass it's GUI stuff back to the main loop
09:50:31 <dcoutts_> what else?
09:51:02 <boegel> shapr: y0 !
09:51:05 <TFK> That's pretty much it. How would I pass stuff back, though? Push to a queue and raise an event?
09:51:22 <dcoutts_> err. something like that, let me think
09:51:49 <dcoutts_> (we really need transparent threading support)
09:52:10 <merkurie_> uhm... hi ^_^ i have a question about start codes
09:52:20 <merkurie_> er, just looking for somewhere with a good example
09:52:42 <TFK> What are start codes?
09:52:48 <merkurie_> oh sorry
09:52:50 <merkurie_> um, in alex
09:52:53 <TFK> Good examples of code in general, you mean?
09:52:55 <merkurie_> for haskell
09:52:57 <TFK> Hi :-)
09:53:08 <merkurie_> hehe =P
09:53:16 <merkurie_> so in alex for lexers in haskell
09:53:25 <merkurie_> how to use start codes
09:53:33 * TFK wouldn't know anything about that, unfortunatelly.
09:53:34 <merkurie_> so that the lexer is flexible
09:53:42 <merkurie_> =(
09:54:09 <merkurie_> hmmm
09:54:17 <kowey> (i'm working with merkurie_ on this one)...
09:54:47 <kowey> so we were looking at http://www.haskell.org/alex/doc/html/wrappers.html
09:54:56 <kowey> we had a lexer written using the posn wrapper
09:55:05 <kowey> and then we upgraded to using the monad one
09:55:23 <dcoutts_> merkurie_, you can take a look at the ghc lexer, it uses start codes
09:55:29 <merkurie_> hehe
09:55:47 <merkurie_> is there a small ghc lexer or is there only one to look at
09:55:56 <kowey> we were a bit overwhelmed by that
09:56:03 <kowey> what's with all those L constructors?
09:56:25 <kowey> well ok... let's try this on a conceptual level
09:56:37 <kowey> on the nice and simple posn lexer:
09:57:09 <kowey> we had a lexing function :: String -> [Foo]
09:57:34 <kowey> and each of our tokens was... (? -> ? -> Foo), important thing being that we return Foo
09:58:00 <kowey> so far so good, anyone following?
09:58:58 <merkurie_> hrm =/
09:59:59 <merkurie_> ok, we were looking at Lexer.x for ghc
10:00:07 <dcoutts_> kowey, the L constructors are just tags saying "this token has location ..."
10:00:12 <merkurie_> does anyone know of a specific part to start looking at?
10:00:30 <dcoutts_> it's something like data Located a = L a Position
10:00:49 <kowey> ok... so, when i see L something something, i think Foo in my terms
10:01:18 <dcoutts_> merkurie_, for start codes look at the bit of the lexer that deals with the #line directives, near the top that should give you an indication
10:01:29 <kowey> idle spectators might do well to read http://www.haskell.org/alex/doc/html/wrappers.html :-)
10:02:48 <kowey> oops, sorry, didn't realise had already given that url
10:02:52 * boegel leaves
10:03:10 <merkurie_> dcoutts_ ok, i'm looking
10:03:33 <merkurie_> dcoutts_ btw, why do i have an underscore after my name?
10:04:14 <dcoutts_> because "merkurie" is already logged in I guess so your client chose to add an underscore
10:04:33 <dcoutts_> I've got one since I'm logged in on a different machine
10:04:53 <dcoutts_> TFK, yeah it looks like we'd need gdk_threads_enter()/gdk_threads_leave() one way or another
10:05:07 <TFK> You're the expert ;-)
10:05:23 <dcoutts_> TFK, posting stuff to be done back to the main loop doesn't cause it to be exectuted inside the Gdk lock
10:05:53 <TFK> So the problem is making it execute within the lock?
10:05:57 <kowey> interesting... the ghc lexer is lexer :: (Located Token -> P a) -> P a
10:06:27 <dcoutts_> Gdk's own window idle update handler uses  gdk_threads_enter()/gdk_threads_leave() around it's gdk_window_process_all_updates() call
10:06:39 <dcoutts_> TFK, yes, so we can just aquire the lock! :-)
10:07:03 <dcoutts_> kowey, since it's a monadic lexer, it descrived in the Alex documentation
10:07:06 <TFK> Give us the lock! THE LOCK!
10:07:12 <kowey> ok
10:07:13 <dcoutts_> :-)
10:07:30 <kowey> we were trying to keep the type of our lexer the same...
10:07:47 <kowey> basically, wrap up all this monadic stuff and give our user a list of tokens, i.e. [Foo]
10:07:54 <kowey> do you think this will be hard to do?
10:08:27 <kowey> or is it more worthwhile to rewrite all our parsers to use a new monadic lexing function?
10:08:56 <dcoutts_> TFK, so since Gtk2Hs doesn't bind the gdk_threads_bla_bla_bla (yet and hopefully we can do something more better so we never have to do this) we can hack it in the client code, FFI is what we need...
10:09:46 * TFK nods
10:10:08 <dcoutts_> fortunately both functions are void -> void
10:10:51 <dcoutts_> kowey, with a monadic lexer, you normally use a monadic parser, but you probably can get a list of tokens
10:11:08 <kowey> for idle spectators, "it is described in the Alex doc" probably refers to http://www.haskell.org/alex/doc/html/api.html
10:11:34 <dcoutts_> kowey, but the real advantage to the monadic lexer is being able to communicate state from the parser back to the lexer which you don't get if you go via a list of tokens
10:11:45 <kowey> ok
10:12:07 <kowey> and...
10:12:08 <dcoutts_> kowey, communicateing between the parser & lexer is nasty but sometimes necessary to parse nasty things like C and perl6...
10:12:15 <kowey> you think it's worthwhile to learn
10:12:20 <kowey> how to do this, rather than trying
10:12:30 <kowey> to figure out how to wrap the stuff and demonadify the lexer?
10:12:52 <kowey> the language we have to parse is very non-nasty, we hope, not even a programming language
10:13:31 <dcoutts_> if the language is straightforward, then a monadic parser & lexer might be overkill but will be very fast
10:14:08 <kowey> would the demonadifying process make our parser/lexer slow? would it add noticable overhead?
10:14:28 <kowey> i.e. is the monadic version faster because of some non-lazy behaviour or something?
10:15:22 <dcoutts_> the monadic version is often faster because there is no intermediate list of tokens and it opens up other crazy optimisations like lexing directly from files rather than via strings, etc
10:15:47 <dcoutts_> but if you want something simple, use alex & happy without makeing your lexer & parser monadic, it's simpler
10:15:58 <kowey> ok... so, it's not that the the non-monadic version is slower, but that monadic one is faster :-)
10:16:04 <dcoutts_> right
10:16:07 <kowey> in fact, all we were trying to do is factorise
10:16:18 <dcoutts_> keep it simple then
10:16:20 <kowey> in the beginning, we had one mega lexer that we used for all our parser
10:16:21 <kowey> s
10:16:40 <kowey> but then we realised that we were being too inflexible, so we tried to break this up into a bunch of little lexers
10:16:57 <kowey> we don't really want to write a bunch of little lexers, because there's lots of overlap
10:17:19 <kowey> so we figured "ah... start codes let you factorise, let's use start codes" and all of sudden wound up in a big mess of monads
10:19:33 <kowey> oh!
10:19:39 <kowey> so that's it then...
10:19:46 <kowey> we can use start codes without all this monadic business
10:19:57 <dcoutts_> yep
10:19:58 <kowey> just write the lexer with the basic api
10:20:12 <kowey> or even posn, assuming it gets passed in somewhere
10:20:18 <dcoutts_> it does
10:20:20 * kowey does a dance of joy
10:20:24 <dcoutts_> :-)
10:20:28 <kowey> thank you! thank you, thank you!
10:20:53 <merkurie_> phew
10:20:56 <kowey> until next time :-)
10:21:02 <dcoutts_> you figured it out! I just lead you on a wild goose chase about monadic lexers & parsers
10:23:47 <merkurie_> thanks, dcoutts_
10:25:51 <dcoutts_> TFK, I'm trying this threads enter/leave thing
10:27:12 <TFK> invoking it with FFI, you mean?
10:27:20 <dcoutts_> yes
10:28:12 <dcoutts_> TFK, ok, try this...
10:28:14 <dcoutts_> foreign import ccall unsafe "gdk_threads_enter"
10:28:14 <dcoutts_>   gdk_threads_enter :: (IO ())
10:28:14 <dcoutts_> foreign import ccall unsafe "gdk_threads_leave"
10:28:14 <dcoutts_>   gdk_threads_leave :: (IO ())
10:28:25 <dcoutts_> and then in your idle handler...
10:29:16 <dcoutts_> idleAdd (do gdk_threads_enter
10:29:16 <dcoutts_>             yield
10:29:16 <dcoutts_>             gdk_threads_leave
10:29:16 <dcoutts_>             return True) priorityDefaultIdle
10:29:45 <dcoutts_> (I should really swap the args to idleAdd, it'd be much more convenient)
10:30:45 <SyntaxNinja> Igloo: will get to cabal debian bugs ASAP
10:30:51 <SyntaxNinja> Igloo: I've been on vacation
10:31:07 <Igloo> OK  :-)
10:31:19 <Igloo> Was it good?
10:31:36 <SyntaxNinja> yeah, a really nice time.  tons of stuff to catch up on now that I"m back, though.
10:31:43 <Igloo> :-)
10:32:08 <SyntaxNinja> I have a review I need to write by the 1st, and a "grave" debian bug
10:32:20 <SyntaxNinja> and work of course too :)
10:33:26 <SyntaxNinja> some guy named isaac jones killed someone
10:33:52 <SyntaxNinja> but I haven't gotten any hatemail yet.
10:34:00 <Igloo> What's the grave bug on?
10:34:46 <Igloo> Oh, that might be mine, actually
10:35:04 <SyntaxNinja> Igloo: yup
10:35:21 <Igloo> Right, OK
11:15:31 <stepcut`> I think the ghc6 debian package is broken... ghc requires gcc to be installed, but the ghc6 package does not depend on gcc ...
11:16:09 <Philippa> I (think I) just finished the next Impure Thoughts article
11:16:23 <Philippa> Anyone in here got author access on TMR and fancy taking a look for me? I could use proofreaders and the like
11:29:23 <arjanoosting> stepcut`: ghc6 depends on gcc-3.3... so it should be ok
11:30:18 <stepcut`> arjanoosting: well, I'll be damned, I will have to see where I went wrong
11:31:10 <arjanoosting> hmm, don't know whether ghc6 calls /usr/bin/gcc or /usr/bin/gcc-3.3 though
11:31:48 <arjanoosting> if it calls /usr/bin/gcc it should depend on gcc i guess
11:31:52 <stepcut`> ah, maybe that was the problem
11:32:46 <stepcut`> I wonder why gcc is not an /etc/alternatives sym-link to gcc-3.3 :-/
11:33:20 <arjanoosting> to make sure gcc is the same compiler on each Debian system
11:33:35 <stepcut`> hrm
11:34:19 <stepcut`> next time I do a fresh install, I will have to look into this a bit, I am hazy on the details
11:34:51 <basti_> hmm i had an idea
11:34:52 * shapr yawns
11:34:52 <arjanoosting> you did a fresh install and were missing gcc?
11:35:00 <shapr> I hate having summer colds, I've been tired all day.
11:35:09 <basti_> how about a haskell shell/os wrapper thing?
11:35:15 <stepcut`> arjanoosting: yes...
11:35:33 <stepcut`> basti_: like bash ?
11:35:36 <basti_> basically an os wrapper
11:35:54 <basti_> like bash by feeling, but a little more into the supporting scripting direction ;)
11:36:05 <pipe> hi basti_
11:36:09 <basti_> hi pipe! :)
11:36:18 <arjanoosting> and when you installled ghc6 you still missed gcc rigth?
11:36:39 <stepcut`> arjanoosting: yes, ghc6 tried to run gcc and could not find it
11:36:45 <basti_> i was thinking like... files should carry type metadata. pipes could be typed and transmit typed information
11:36:54 <pipe> pipes?
11:36:55 <arjanoosting> Igloo: are you here?
11:37:01 <basti_> > and < and | and stuff
11:37:10 * pipe knows what pipes are =]
11:37:12 <basti_> :P
11:37:25 <stepcut`> basti_: I am working on a library like that, but I need to write something like hGetContents  that runs an user supplied action (IO ()) when it encounters EOF
11:37:50 <basti_> hGetContents reads everything from a file?
11:38:10 <Igloo> Yes
11:38:28 <basti_> is hGetContents builtin?
11:39:07 <TFK> basti_, System.IO if I'm not mistaken.
11:39:19 <basti_> i mean, is it implemented in haskell or in C?
11:39:24 <dcoutts_> haskell
11:39:24 <Igloo> Oh, hmm. At least with build-essential installed it'll work
11:39:43 <dcoutts_> basti_, look in the ghc library sources
11:39:52 * basti_ looks
11:40:27 <stepcut`> basti_: yes, lazily -- so if you spawn off a process, you can read stdout using hGetContents. But when you get EOF, you need to call getProcessStatus on the child process, otherwise you will accumulate zombie child processes
11:40:44 <arjanoosting> Igloo: I guess stepcut` found a missing dependency of ghc6
11:40:57 <basti_> hmm i see
11:42:01 <stepcut`> Igloo: yeah, installing build-essential 'fixes' things... but that doesn't make the package any less broken ;)
11:43:13 <basti_> stepcut`: still digging ;)
11:43:38 <stepcut`> Linspire ships with ocaml installed but not gcc :p
11:47:24 <Igloo> No, but it means the buildds won't break building the fixed package  :-)
11:47:38 <SyntaxNinja> stepcut`: you should really do something about that
11:48:08 <SyntaxNinja> er, I read gcc as ghc, which I do all the time.
11:49:37 <stepcut`> SyntaxNinja: well, it does not ship with ghc either :-/
11:50:10 <SyntaxNinja> l4m3
11:50:31 <stepcut`> I am working on it...
11:51:56 <Igloo> stepcut`: Do you have only packages frmo Debian installed, BTW? If so, what version of gcc-3.3?
11:52:07 * basti_ did not come to a conclusion hGetContents wise
11:52:31 <stepcut`> Igloo: hrm, I will have to investigate and get back to you
11:53:04 <stepcut`> basti_: what where you trying to figure out ?
11:53:21 <basti_> if (and if, how) it is implemented in haskell
11:54:15 <stepcut`> basti_: it is implemented in haskell -- using unsafeInterleaveIO
11:56:21 <stepcut`> ghc6-6.2.2/libraries/base/GHC/IO.hs
11:57:59 <stepcut`> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/GHC/IO.hs?rev=1.26.2.1;content-type=text%2Fplain
11:58:55 <basti_> now where are my ghc headers hiding lol
11:59:45 <basti_> ah
11:59:47 <basti_> got them
11:59:50 <Lemmih> SyntaxNinja is back from his vacation.
11:59:50 <basti_> its .hi headers
12:01:02 <SyntaxNinja> hi Lemmih
12:01:28 <basti_> hmmm
12:01:53 <Lemmih> Bringing a new Cabal release with you, SyntaxNinja? (:
12:02:47 <basti_> stepcut`: could there be a possibility of chaining an operation and "something thats to be done after X happened" with >>?
12:05:12 <basti_> or something that eats through a list, monadically, and then ends with said IO ()
12:06:41 <stepcut`> I am not familiar with >>?
12:07:11 <basti_> hmm i'll try something
12:07:16 <basti_> >> is >>= \_ ->
12:07:17 <basti_> =)
12:07:23 <SyntaxNinja> Lemmih: within a few days, I think.  I have some catching up to do.
12:07:34 <stepcut`> though, I like the idea of wrapping a monadic list thing around the existing list...
12:09:09 <stepcut`> oh, I see you meant '>>' not '>>?' :p
12:09:28 <basti_> uh yes.
12:09:30 <basti_> lol
12:10:35 <basti_> uh i think i see how it could work
12:13:11 <TFK_sIRC> OK, so...
12:19:05 <Heffalump> I would just like to say that ST rocks.
12:19:22 <jlouis> ST?
12:19:39 <wagle> i've seen monad instances where there were definitions for both >> and >>=
12:19:55 <jlouis> ST the monad?
12:20:28 <wagle> ST the book?  the motion picture?  *<8-|
12:22:45 <lispy> TFK_shIRC: so it's working?
12:23:08 <TFK_shIRC> It's pretty much the same old client.
12:23:30 <TFK_shIRC> I've wrapped the "yield" call with gdk_threads_enter and gdk_threads_leave, but on the last try it didn't seem to help.
12:23:34 <TFK_shIRC> Now I'm just idling :-/
12:32:51 <basti_> hmm
12:32:59 <stepcut`> ?
12:33:05 <basti_> i tried with liftM2 (++)
12:33:22 <basti_> oh
12:33:29 <basti_> i think i might have forget something
12:33:50 <stepcut`> I tried some stuff, but I could not get the action to happen at the end
12:34:00 <basti_> yes.
12:34:50 <basti_> hmm
12:35:44 <basti_> its hard, yes.
12:39:17 <basti_> i think we'll need to replace unsafeInterleaveIO
12:39:27 <basti_> resp. hGetContents
12:39:40 <Heffalump> jlouis: ST the monad.
12:40:33 <Heffalump> I wrote a pure function to do route planning for one of our other team members to use. Then I realised I needed to worry about it taking too long, so I rewrote it using ST internally to bound the number of iterations, but without requiring any interface changes at all
12:40:38 * wagle waits for it to come out on DVD
12:41:20 <wagle> Heffalump: cool
12:41:38 <stepcut`> basti_: yeah, I think I have to modify hGetContents one way or another
12:46:48 <elmex> hmm, i've just build a lexer for java in haskell with alex... and ghc is compiling quite a while on it.. it takes really long (more than 3 mins) is that normal?
12:47:26 <basti_> hello elmex
12:47:35 <basti_> i cant answer your question, but i bet someone is here who can
12:48:23 <elmex> basti_: hi :)
12:49:02 <elmex> i try to build a java parser in haskell... found yacc grammar and lex grammar and converted it to happy and alex...
12:49:06 <stepcut`> elmex: It is not unheard of -- I think there was a thread on one of the mailing lists recently about ghc taking a long time to compile alex code
12:49:33 <elmex> stepcut`: oh, i will look. do oyu know the mailinglist address?
12:50:09 <SyntaxNinja> elmex: yes, ghc does take a long time on alex code sometimes.
12:50:12 <elmex> stepcut`: oh, i found it i guess
12:50:19 <elmex> alex has a --ghc option
12:51:04 <elmex> -g,--ghc : Instructs  Alex  to generate a lexer which is optimised for compiling with GHC. The lexer will be significantly more efficient, both in terms of the size of the compiled lexer and its runtime' ...
12:51:14 <elmex> i guess thats it
12:51:49 <stepcut`> elmex: the thread is GHC hang on glasgow-haskell-users@haskell.org, but it turns out that they where talking about happy, not alex
12:52:09 <elmex> stepcut`: heh, i guess i might run into that maybe too ;)
12:52:10 <stepcut`> (the message by Ducan Coutts)
12:52:19 <basti_> stepcut`: i got it
12:52:23 <basti_> lisppaste2: @url
12:52:24 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:53:14 <lisppaste2> basti_ pasted "hGetContents, then do something as soon as [] is encountered" at http://paste.lisp.org/display/9449
12:53:24 * basti_ dances
12:53:41 <elmex> basti_: u learn haskelll?
12:53:50 <basti_> elmex: well i'm still learning yes.
12:53:51 <basti_> ;)
12:54:08 <basti_> have a look at the paste and tell me if you think its beginners or rather advanced...
12:54:25 <CosmicRay> basti_: everyone is
12:54:37 <basti_> CosmicRay: thats what i was punning upon
12:54:45 <stepcut`> basti_: nice, seems to work
12:54:58 <basti_> its a little yuck, with the unsafe
12:55:18 <basti_> but i think theres no way around without getting under hGetContents' hood
12:55:21 <stepcut`> yeah, I wonder what the effect of that will be
12:55:42 <basti_> i didnt find a way without
12:55:48 <stepcut`> me neither
12:55:51 <elmex> yahoo, ghc finished compilation
12:56:05 <stepcut`> basti_: I will test it empirically :)
12:56:05 <basti_> i think hGetContents is using it itself, but in a benign way
12:56:15 <elmex> basti_: the main function is in the IO monad
12:56:19 <basti_> elmex: yes.
12:56:56 <basti_> there's no way to fiddle the IO around in a way that won't execute something after gGetContents got its contents, because thats the idea of hGetContents
12:57:27 <stepcut`> yeah
12:57:37 <stepcut`> 'tis tricky stuff
12:57:37 <basti_> you could read eagerly
12:57:44 <basti_> this might break things though
12:58:16 <basti_> =)
12:58:28 <stepcut`> well, things are already broken, so hopefully it will atleast be better
12:58:43 <stepcut`> if worse comes to worse, I can fiddle around underneath hGetContents
12:59:06 <basti_> i think this might be the best solution.
12:59:08 <elmex> basti_: what are u trying to do?
12:59:42 <basti_> elmex: well stepcut asked how one could read a file lazily, so that when you evaluate it's end, something happens
12:59:55 <elmex> hmm
12:59:58 <elmex> weird
13:00:05 <stepcut`> elmex: but useful!
13:04:34 <stepcut`> basti_: I am going to lunch, I will let you know how the code works out later
13:04:39 <basti_> okay =)
13:05:00 <stepcut`> basti_: If things work out well, I might have an article for the next TMR about using haskell as a bash replacement :p
13:05:26 <basti_> =)
13:58:55 <poetix> shapr: http://www.haskell.org/tmrwiki/SolvingSudoku - halfway there...
14:02:04 <shapr> yay!
14:03:31 <poetix> I'm going to go for a slight rewrite of the code as well, using the standard monads, because I think it will be clearer (and shorter)
14:04:15 <poetix> and will also demonstrate in passing the use of monad transformers to layer in multiple notions of computation in a seamless (*koff*) manner.
14:04:34 <Muad_Dibber> :)
14:04:46 * Muad_Dibber still isnt that good friends with monad's
14:04:49 <shapr> In passing, we will demonstrate monads.
14:04:50 * shapr laughs
14:05:01 <Muad_Dibber> i ussually am okay with using them, but creating them still is a problem :P
14:05:08 <poetix> Better get on with it rather than hang around here chatting - see you later, when I've done a bit more...
14:05:09 <shapr> poetix: Was that joke purposeful?
14:05:39 <poetix> I should pretend that it was, and make myself look clever.
14:05:41 <poetix> later...
14:05:47 * shapr grins
14:05:55 <Muad_Dibber> you scared him away shapr
14:07:24 <wilx> What's Sudoku?
14:07:38 <shapr> @google sudoku haskell
14:07:40 <lambdabot> http://lambda-the-ultimate.org/node/view/772
14:10:43 <Muad_Dibber> its like a hard version of the 8 queen's problem?
14:11:25 <bourbaki> moin
14:20:43 <lightstep> i think promoting haskell through comparison to excel is wrong
14:21:39 <TFK> Howdy lightstep
14:21:46 <lightstep> howdy
14:21:59 <astrolabe> Why wrong?
14:22:22 <lightstep> because #haskell is much cooler than all the vb channels
14:22:35 * shapr points at Igloo 
14:22:42 <shapr> It's because he keeps us cool.
14:22:59 <jyp> Yeah, we're all so humble and wise around here =)
14:23:16 <jyp> hiya all, btw :p
14:23:21 <shapr> salut
14:23:32 <jyp> salut Shapr
14:23:59 <lightstep> i just tried to ask a vb question in two vb channels, the first kicked me immediately for asking anything, and on the second, they said they'll ban me if they can answer in a minute, gave a wrong answer, and banned me
14:24:21 <wilx> lol
14:25:12 <jyp> It's true that the haskell community remains quite open...
14:25:14 <wilx> I got similar behaviour from IRCNet's #java and #freebsd.
14:25:50 <jyp> you can even ask dumb questions on the mailing list and get almost not flames ;)
14:26:43 <shapr> Everybody starts at the beginning. They only get flamed if they stay there.
14:26:53 <Muad_Dibber> of course haskell is cooler
14:26:55 <Muad_Dibber> we have lambdabot
14:27:07 <Muad_Dibber> (although i still havent managed to compile it myself..:P)
14:27:21 <shapr> I got lambdabot to compile once!
14:27:30 <TFK> lightstep, conclusion: don't ask questions about vb, ask questions about python!
14:27:43 * shapr remembers when lambdabot was roughly six files total.
14:27:55 <stepcut`> heh
14:28:12 * Muad_Dibber remembers his first year course of haskell thinking: hey, i would like to write an ircbot in haskell
14:28:23 <Muad_Dibber> and then only to look at it again a few years later and discover there is one already :P
14:28:28 <TFK> Why does everyone want to write an IRC bot?
14:28:40 <lightstep> TFK, i wanted to do excel
14:28:40 <shapr> stepcut`: Hey, how's RSS.hs ?
14:28:46 <stepcut`> shapr: same, hold on
14:28:48 <shapr> I want to fix PLog to do real RSS.
14:28:50 <shapr> ok
14:28:59 <TFK> lightstep, is VB the only way?
14:29:03 <lightstep> yes
14:29:19 <TFK> You sure?
14:29:35 <lightstep> not, but i don't know other excel extension pls
14:29:46 <SyntaxNinja> i have in front of me, potato chips which claim to be "revolutionary"
14:29:52 <Muad_Dibber> now, what i would want to have now is a nice xml editor in wxhaskell :P
14:30:15 <TFK> I'm not sure about extensions, but pywin32, for example, provides some COM bindings, and I gather that they can be used to talk to excel (among others).
14:30:25 <Muad_Dibber> SyntaxNinja : watch out, they might be disguised taliban guerrillas
14:30:27 <astrolabe> Are they actually revolting?
14:31:20 <TFK> "Tastes best with propoganda sauce!"
14:31:23 <SyntaxNinja> astrolabe: I would say that "revolting" is an overstatement, but not by much
14:35:28 <lisppaste2> jyp pasted "hMapM" at http://paste.lisp.org/display/9454
14:35:54 <jyp> If you're familiar with HList, please check this aout
14:44:38 <jyp> No flame? Then I'll see if the mailing list likes it =)
14:53:27 <jyp> tts
14:55:25 <astrolabe> I'm curious which text editors people here use when writing Haskell code.
14:55:36 <wilx> (X)Emacs.
14:56:22 <astrolabe> thanks.  With Haskell settings?
14:56:43 <wilx> Haskell settings?
14:56:52 <wilx> I use the default setup.
14:57:48 <astrolabe> Perhaps I'm misrembering.  I thought there was a haskell mode.
14:58:09 <wilx> Oh, of course with haskell-mode.
14:58:10 <shapr> yup
14:58:30 * stepcut` uses ed
14:58:33 <astrolabe> Sorry.  Please don't underestimate my ignorance.
14:59:14 <shapr> oh mine too!
14:59:22 * shapr randomly ignores someone.
15:00:40 <astrolabe> What do you use shapr?
15:00:55 <shapr> xemacs with haskell-mode, but I'll switch to Yi when it's usable.
15:01:23 * lightstep uses vi
15:01:35 <wilx> lightstep, plain vi or vim?
15:02:13 <astrolabe> Thanks guys
15:02:40 <lightstep> vim, with ft=haskell
15:24:27 <poetix> Quick dumb question
15:24:47 <lightstep> which?
15:25:06 <poetix> If I have a Char, e.g. '1', how do I get an 'Int' from the Char?
15:25:41 <lightstep> :t \ch -> (undefined::Int)
15:25:59 <lightstep> poetix, use fromEnum
15:26:12 <lightstep> it works for any enumeration, not just Char
15:26:39 <poetix> fromEnum '1' = 42.
15:26:46 <kaol> read or readS might come in handy too
15:26:47 <poetix> I want something that will equal 1
15:27:24 <poetix> foo :: Char -> Int
15:27:25 <lightstep> i don't think there's a standard function that does it. it's not hard to do it yourself
15:27:27 <poetix> foo '5' = 5
15:27:37 <wagle> @plugs fromEnum '\001'
15:27:42 <lightstep> the question is, what's foo 'v'
15:27:43 <lambdabot> 1
15:27:58 * poetix keeps reinventing standard functions, and has become wary...
15:28:21 <wilx> Beware that Char can be > 255.
15:28:32 <wagle> @plugs fromEnum '\01001'
15:28:33 <lambdabot> 1001
15:28:50 <wagle> @plugs fromEnum '\0100111111111'
15:28:51 <lambdabot> lexical error in string/character literal
15:28:57 <lightstep> @type fromJust . flip lookup ['0'..'9']
15:28:58 <kaol> @plugs read "1"::Int
15:29:04 <lambdabot> bzzt
15:29:04 <lambdabot> 1
15:29:16 <poetix> val c = (fromEnum c) - 41
15:29:17 <lightstep> @type Maybe.fromJust . flip List.lookup ['0'..'9']
15:29:19 <lambdabot> bzzt
15:29:27 <kaol> foo a = read [a]
15:29:45 <kaol> foo a = reads [a]
15:29:49 <wagle> @plugs fromEnum '0'
15:29:51 <lambdabot> 48
15:30:00 <wagle> @plugs fromEnum '1'
15:30:02 <lambdabot> 49
15:30:19 <lightstep> fromJust . flip List.elemIndex ['0'..'9']
15:30:28 <wagle> in some charsets, '0' + 1 /= '1', though
15:30:32 <kaol> @plugs (\x -> read [x]) '1'
15:30:34 <lambdabot> Ambiguous type variable `a' in these top-level constraints
15:30:40 <kaol> @plugs (\x -> read [x]::Int) '1'
15:30:42 <lambdabot> 1
15:30:57 <wagle> @plugs read . return 1
15:30:59 <lambdabot> <Plugins.Eval>:1:
15:30:59 <lambdabot>   No instances for (Show (a1 -> a), Monad ((->) a1), Num String)
15:30:59 <lambdabot>   arising from use of `show'
15:31:08 <wagle> @plugs (read . return) 1
15:31:10 <lambdabot> <Plugins.Eval>:1:
15:31:10 <lambdabot>   No instance for (Num Char)
15:31:10 <lambdabot>   arising from the literal `1'
15:31:18 <wagle> @plugs (read . return) '1'
15:31:19 <lambdabot> Ambiguous type variable `a' in these top-level constraints
15:31:31 <wagle> awww
15:31:57 <kaol> @plugs map (\x -> read [x]::Int) ['0'..'9']
15:31:58 <lambdabot> [0,1,2,3,4,5,6,7,8,9]
15:32:06 <wagle> @plugs (read . (:[])) '1'
15:32:07 <lambdabot> Ambiguous type variable `a' in these top-level constraints
15:32:24 <basti_> @plugs ((:[]).read)  '1'
15:32:26 <lambdabot> Couldn't match `String' against `Char'
15:32:37 <kaol> @plugs (read . (:[]))::Int '1'
15:32:39 <lambdabot> parse error on input `''
15:33:24 <lightstep> @plugs ((read . return)::Char->Int) '4'
15:33:27 <lambdabot> 4
15:34:29 <wagle> ahh..
15:34:47 <wagle> it was cornfoozled about the return type
15:35:16 <bourbaki> does anyone of you know gauss theorem?
15:35:19 <bourbaki> moin basti_
15:35:26 <poetix> Right, I have what I need (going with val c = elemIndex c ['1'..'9'])
15:35:36 <poetix> thx
15:35:57 <basti_> hi bourbs
15:35:59 <wagle> Gauss had many theorems
15:36:12 <bourbaki>  the one that allows you to calculate volumes of objects with their normals
15:36:47 <basti_> i remeber some widget to measure areas by tracing their circumference
15:38:32 <lightstep> Killer Quiz (flash): http://www.malevole.com/mv/misc/killerquiz/
16:04:00 <lispy> bourbaki: green's theorem maybe?
16:04:37 <lispy> bourbaki: i know there are three versions of the theorem you talking about
16:04:52 <lispy> each for a slightly more general context
18:31:48 <lispy> is dons around?
18:32:52 <wagle> @seen dons
18:32:53 <lambdabot> dons is in #haskell. Last spoke 11 hours, 31 minutes and 43 seconds
18:32:53 <lambdabot> ago.
18:33:09 <dons> @dons here
18:33:10 <lambdabot> here not available
18:33:26 <dons> @timein sydney
18:33:30 <lambdabot>  Tuesday, June 28, 2005 at 11:34:30 AM EST
18:33:36 <wagle> @seen dons
18:33:37 <lambdabot> dons is in #haskell. Last spoke 10 seconds ago.
18:33:39 <lispy> dons: hi
18:33:41 <wagle> 8)
18:33:43 <dons> See -- I should be up by now.
18:33:55 <lispy> dons: i need help installing hs-plugins if you have time to help
18:33:58 <dons> heya lispy. what's up?
18:34:04 <dons> ok suure.
18:34:07 <lispy> make register is un happy
18:34:18 <dons> hmm. using latest darcs hs-plugins?
18:34:29 <lispy> as of about 2-3 days ago
18:34:32 <dons> ok.
18:34:37 <lispy> i could pull again
18:34:50 <dons> no. nothing's changed. what's the problem?
18:35:07 <lispy> env LIBDIR=/usr//lib/hs-plugins ghc-pkg -u < src/altdata/altdata.conf.in
18:35:07 <lispy> Reading package info from stdin... done.
18:35:07 <lispy> ghc-pkg: cannot find libHSaltdata.a on library path
18:35:08 <lispy> make: *** [register] Error 1
18:35:18 <lispy> i've changed one thing
18:35:21 <dons> hm. is that LIBDIR right?
18:35:34 <dons> did you: make install ; make register ?
18:35:36 <lispy> it's from configure --prefix=/usr/
18:35:46 <lispy> i've install
18:35:57 <lispy> but i could do it again
18:36:04 <dons> is libHSaltdata.a in /usr//lib/hs-plugins/ ?
18:36:23 <wagle> wouldnt --prefix=/usr (no trailing /) be better?
18:36:42 <dons> shouldn't matter. but possibly that's a proble -- not sure.
18:36:43 <lispy> ya, and world readable
18:36:58 <dons> ok. try fixing LIBDIR
18:37:14 <dons> to not have the extra /
18:37:31 <dons> I'll see if I have any troubles
18:37:52 <wagle> i'd redo the whole thing with ./configure --prefix=/usr
18:37:53 <lispy> where is that defined?
18:37:59 <lispy> oh okay
18:38:12 <dons> lispy, like wagle said. redo the build
18:38:18 <dons> safest that way
18:38:27 * wagle has done mortal combat with autoconf
18:38:56 <lispy> "FATALITY!"
18:39:03 <wagle> someday i will actually write my paper "autoconf considered harmful"
18:39:05 <lispy> compiling now
18:39:26 <dons> ok. I can install and register ok.
18:39:35 <dons> ./configure --prefix=/home/dons
18:39:42 <dons> gmake
18:39:43 <lispy> wagle: mine will be "cvs considered harmful"
18:39:44 <dons> gmake install
18:39:46 <dons> gmake regitser
18:39:55 <dons> well, "register"
18:40:07 <dons> which gives us:
18:40:07 <dons> env LIBDIR=/home/dons/lib/hs-plugins ghc-pkg -u < src/altdata/altdata.conf.in
18:40:08 <dons> Reading package info from stdin ... done.
18:40:08 <dons> Saving old package config file... done.
18:40:09 <dons> Writing new package config file... done.
18:40:12 <dons> for example
18:40:54 * lispy realizes this would go a lot faster if he lets his processor run at full speed
18:41:18 <lispy> yup it worked
18:41:21 <lispy> thanks
18:41:44 <lispy> i was under the impression that extra trailing slashes were safe in the unix world
18:41:52 <dons> me too..
18:41:57 <dons> sounds like a bug in something
18:42:04 <lispy> now on for the grand finale, bulding yi
18:42:12 <wagle> what platform you running on?
18:42:16 <lispy> debian
18:42:28 <wagle> odd
18:42:53 <dons> maybe ghc-pkg doesn't like extra //
18:43:03 <lispy> oh maybe
18:43:22 <wagle> oh..  something besides the kernel parses the path
18:43:41 <lispy> dons: i read your paper about yi and the dynamic code stuff.  Pretty cool.
18:44:22 <lispy> yay, yi finally built
18:45:09 <dons> lispy, cheers :)
18:45:11 <Pseudonym> Oooh, what paper?  Where?  Where?
18:45:23 <dons> hmm. let's try our luck:
18:45:37 <dons> @google dynamic applications from the ground up
18:45:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/SC05.html
18:45:43 <dons> yes!
18:45:48 <lispy> eheh
18:45:51 <Pseudonym> Yay.
18:46:25 <lispy> $ yi
18:46:25 <lispy> yi: /usr//lib/yi/Yi.o: unknown symbol `YiziVersion_version_closure'
18:46:26 <lispy> yi: user error (resolveObjs failed with <<False>>)
18:46:35 <lispy> i _think_ it's due to bad permissions
18:46:56 <lispy> actually, it's world readable
18:47:00 <lispy> Yi.o that is
18:47:03 <dons> ./yi-static ?
18:47:11 <lispy> that works
18:47:11 <dons> then try: ./yi-inplace
18:47:19 <lispy> yup
18:47:37 <dons> ok. it's fine then.
18:48:00 <lispy> any idea why just plain 'yi' gives that message?
18:48:23 <lispy> let me rebuild it with a good --prefix
18:48:24 <lispy> just to be safe
18:48:28 <dons> where's plain 'yi' living?
18:48:41 <lispy> somewhere in my path ;)
18:48:42 <lispy> just a sec
18:48:50 <dons> oh, after the install. right.
18:49:00 <lispy> /usr/bin/yi
18:49:01 <dons> I haven't tested installing much of late.
18:49:16 <lispy>  /usr/bin/yi
18:49:29 <dons> testing installation now ...
18:49:35 <lispy> i have that // thing again
18:49:45 <lispy> fixing that and i'll try again
18:49:49 <dons> could be that again maybe
18:49:53 <dons> did you make clean?
18:49:59 <lispy> it works now
18:50:01 <lispy> yeah i did
18:50:12 <dons> ok.
18:50:20 <lispy> where can i get emacs mode? or should i just rtf?
18:50:22 <lispy> er rtfm
18:50:34 <dons> yi --as=emacs
18:50:34 <dbremner> lightstep - I got 9/10
18:50:51 <dons> just be aware that emacs mode is not as complete as vim mode
18:50:56 <wagle> make clean generally doesnt remove he autoconf files
18:51:15 <dons> right
18:51:20 <lispy> wagle: yeah, i did configure ; make clean ; make
18:51:29 <lispy> and it worked
18:51:37 <lispy> yeah, emacs mode is missing a lot
18:51:42 <lispy> C-n and C-p for example
18:51:48 <wagle> rm <install_dir>; tar xvf - <tarball> is what i do
18:52:04 <lispy> it's a darcs get tho
18:52:13 <lispy> i didn't really wan to grab it from scratch again
18:52:15 <wagle> ah
18:52:30 <dons> lispy, the code for emacs is in Yi/Keymap/Emacs.hs if you want to add any bindings
18:52:40 <wagle> make clean ; configure
18:52:44 <lispy> dons: thanks, i was just typing that question ;)
18:52:54 <dons> uses the same DSL as described in the paper
18:53:08 <lispy> cool
18:53:40 <dons> well, basti's use of that DSL, anyway. which is a bit different to how I wrote the vim, vi, nano and ee bindings
18:54:05 <dons> what are C-n and C-p ?
18:54:08 <lispy> is that a good, bad or neutral thing?
18:54:12 <lispy> up and down line
18:54:15 <lispy> to move the cursor
18:54:29 <lispy> works in just about anything that uses libreadline
18:54:32 <lispy> such as bash
18:55:00 <dons> readline isn't relevant here. but you can add these bindings in about 10 chars of code I think
18:55:10 <dons> just looking in Emacs.hs to see where
18:55:27 <lispy> oh i know readline isn't relevant, but i thought i'd throw it in cuz it can be nice to know
18:55:48 <dons> probably just add it to normalkeymap
18:56:52 <dons> lots and lots of simple bindings like should  be easy to add, once you understand how basti's written Emacs.hs
18:57:14 <dons> you can find the actions to bind to keys in Core.hs, and examples in Nano.hs
18:57:21 <lispy> cool
18:57:47 <lispy> how do you feel about having a plugin that provides a gui abstraction?
18:58:04 <lispy> if that makes any sense...
18:58:12 <dons> I feel good about a gui abstraction, and pluggable guis..
18:58:19 <dons> working on this currently
18:58:19 <lispy> okay
18:58:25 <lispy> ah, using what?
18:58:28 <lispy> wxhaskell?
18:58:31 <lispy> or gtk?
18:58:55 <dons> I've a typeclass for the gui layer, and we have ncurses of course, a simple wxHaskell one, but I want to work on a good gtk2hs ui
18:59:10 <dons> the idea would be to allow hot-swappable guis..
18:59:25 <lispy> right
18:59:34 <lispy> that's what i hopped you would say
18:59:41 <lispy> that's perfect for how i use emacs :)
19:00:27 <lispy> hmm....i did something wrong
19:00:47 <lispy> yi_ is eating all the processor time after adding the keys
19:02:13 <lispy> (char '\^P'   ,"cursor_up")
19:02:21 <lispy> anything wrong with taht?
19:02:55 <dons> hmm. maybe a thread  ran away
19:03:14 <lispy> it would appear that ^N is the one that causes it to 'freak' out
19:03:20 <dons> not sure what "cursor_up" binds to in Emacs.hs ?
19:03:36 <lispy> (char keyUp   ,"cursor_up")
19:03:40 <lispy> i used that as an example
19:04:02 <lispy> Label "cursor_up"    $ String $ \_  -> Action upE
19:04:55 <dons> ok. looks good
19:05:07 <lispy> maybe it's bad terminal interaciton?
19:06:44 <dons> hmm. i'd say its something weird in Emacs.hs. All the modes seem to work fine.
19:06:55 <dons> s/the modes/the modes I wrote/
19:07:12 <lispy> any advice on debugging it?
19:07:49 <dons> compile with profiling, or trace down what ^N does exactly
19:08:04 <lispy> is there a configure switch to turn on profiling?
19:08:31 <dons> I think: make clean ; make way=p             should do it.
19:08:44 <dons> then you only get to use yi-static, btw
19:09:00 <lispy> Rebuilding dependencies... Could not find module `Foreign.C.String':
19:09:03 <lispy> hmm....
19:09:19 <lispy> do i need the profiling version of ghc?
19:09:24 <dons> yes.
19:09:26 <lispy> oh
19:09:30 <lispy> dummer
19:09:32 <lispy> er bummer
19:09:35 <dons> you need the profiled libraries.
19:09:54 <dons> maybe just work out what ^N does
19:10:08 <dons> I doubt it's anything outside of Emacs.hs that's going wrong
19:11:17 <lispy> yeah
19:11:40 <wagle> dos: have you seen Specialization Tools and Techniques for Systematic Optimization of System Software. Dylan McNamee, et al?
19:11:41 <dons> if you felt up to it, you could consider writing your own Emacs binding .
19:11:41 <lispy> is it an error to have two keys do the same action?
19:11:56 <lispy> ^?
19:11:57 <dons> no.
19:12:25 <wagle> ToCS  ACM Transactions on Computer Systems, Volume 19, Issue 2, May 2001.
19:12:31 <dons> if they're in the  same lexer table, then the most recently added binding wins
19:12:47 <lispy> C-n does weird stuff
19:13:11 <lispy> oh, that could be a real problem for emulating emacs
19:13:41 <lispy>                  (char '\^P'   ,"cursor_up"),
19:13:41 <lispy>                  (char keyUp   ,"cursor_up"),
19:13:42 <lispy>                  (char '\^N'   ,"cursor_down"),
19:13:43 <lispy>                  (char keyDown ,"cursor_down"),
19:13:54 <dons> ?
19:13:55 <lispy> let me try getting rid of keyUp and keyDown
19:14:13 <dons> why is there any problem?/
19:14:48 <lispy> it's common in emacs to have multiple keys do the same thing
19:14:57 <lispy> but i thought you just said that wouldn't work
19:15:14 <dons> no, I said it would work.
19:15:35 <dons> it's common in all editors, I'd think
19:15:35 <lispy> "if they're in the same lexer..."
19:15:42 <dons> yeah. but we have many many lexers
19:15:48 <lispy> ah
19:16:09 <lispy> well, the ^P and ^N have behavior that i don't understand
19:17:07 <dons> Ii'm concerned that we're just hacking basti's mode without understanding how things are encoded.
19:17:40 <lispy> maybe
19:17:46 <dons> you might find it easier to copy Ee.hs to Emacs2.hs, and begin there.
19:18:25 <dons> have a look in Ee.hs at how simple it is.
19:19:15 <dons> I don't understand basti's mode myself.
19:19:27 <dons> :}
19:19:43 <lispy> heh
19:19:47 <lispy> it doesn't look that bad :)
19:20:07 <dons> yeah, but it works quite differently to any of the modes I've written.
19:20:15 <dons> so I'm unsure about the methodology
19:20:34 <dons> I do understand that emacs has the name to binding reflection going on though
19:20:37 <dons> which makes things harder
19:20:56 <lispy> emacs is very reflective
19:21:15 <lispy> it's nice for the user
19:21:21 <dons> and that's ok. but we're only emulating that atm.
19:21:22 <lispy> but maybe a pain for the devs :)
19:21:33 <dons> yi gets its own reflection stuff once it embeds ghci
19:21:38 <lispy> i have to turn my proc speed down again, my lap is melting
19:21:47 <lispy> that will be cool
19:23:23 <wagle> dons: in that article, we describe a methology for exchanging components in a running system
19:24:04 <dons> oops. cheers.
19:24:58 <dons> sorry - where's that typo?
19:25:57 <dons> wagle: ?
19:26:13 <lispy> odd, i deleted the key mapping for keyUp and keyDown, but the cursor still moves up and down with the arrow keys...
19:26:29 <dons> you didn't remake?
19:26:41 <wagle> ToCS  ACM Transactions on Computer Systems, Volume 19, Issue 2, May 2001.
19:26:46 <wagle> dos: have you seen Specialization Tools and Techniques for Systematic Optimization of System Software. Dylan McNamee, et al?
19:26:55 <dons> ah, sorry. I see.
19:27:07 <wagle> oh well..  not all that important
19:27:38 <lispy> dons: i did a make clean actually...
19:27:45 <lispy> trying again just to be certain
19:27:47 <wagle> your components seem more like modules, ours were functions
19:28:00 <dons> yep, that's about right
19:28:20 <wagle> general implementions <-> specialized implementation
19:30:16 <dons> ah, interesting
19:32:23 <juhp> dons: I'm having trouble building current hs-plugins on fedora core 4 (fc4)
19:32:37 <dons> how so?
19:32:38 <juhp> <stdin>:1:35: error: operator '&&' has no right operand
19:32:58 <dons> hmm.
19:32:59 <juhp> more fully:
19:33:06 <juhp> seen that before?
19:33:23 <lispy> juhp: what is your version of ghc?
19:33:39 <dons> I wonder if its a cpp issue
19:33:40 <juhp> lispy: ghc-6.4.1.20050620 ;)
19:33:47 <juhp> dons: could well be
19:33:52 <juhp> it is gcc4
19:33:55 <dons> e.g. in: plugins/plugins.conf.in.cpp:#if CABAL == 0 && GLASGOW_HASKELL < 604
19:34:12 <dons> I'll get rid of the &&s now
19:34:25 <dons> maybe you can try that?
19:34:31 <juhp> yeah, I think that is the place
19:35:02 <juhp> I have similar problem with nhc98 fwiw
19:35:08 <dons> there's 3 of them: altdata/altdata.conf.in.cpp, hi/hi.conf.in.cpp, plugins/plugins.conf.in.cpp
19:36:14 <juhp> dons: do you know if hs-plugins will work better in ghc-6.4.1 on x86-64 btw?
19:36:28 <dons> ghci support is better, so I imagine it will
19:36:37 <juhp> aha
19:36:38 <dons> define 'work better'?
19:36:43 <juhp> heh
19:36:48 <lispy> dons: i removed all the kindings for cursor_up and cursor_down, did a 'make clean && make && yi_' and I can still navigate with the arrow keys
19:37:02 <juhp> I should try to rebuild with interactive enabled then...
19:37:03 <dons> you running as=emacs?
19:37:19 <dons> juhp: hmm.. don't think that matters
19:37:30 <dons> it's a matter of how working the Linker.c in the rts is
19:37:56 <dons> I know its been improved of late, so as to get ghci working
19:38:05 <juhp> dons: but then I'd be able to use ghci, no?
19:38:05 <lispy> dons: oh yeah missed that detail, i did run it with --as
19:38:11 <lispy> Iraqi PM optimistic on security
19:38:12 <lispy> A year after the US handed over power, Iraqi PM Ibrahim Jaafari says his country could be made safe by 2007.
19:38:12 <lispy> US's dwindling options in Iraq
19:38:12 <lispy> Iraq rebellion 'could last years'
19:38:14 <juhp> ah
19:38:15 <lispy> ah crap
19:38:18 <lispy> stupid paste
19:38:20 <lispy> sorry!
19:38:47 <dons> hmm. maybe.
19:38:56 <dons> ghci probably does only need Linker.c to work.
19:39:13 <dons> so ghci --> hs-plugins, afaik.
19:39:26 <dons> I was thinking maybe something else needed to be done besides, to get ghci up
19:40:31 <dons> juhp, does editing out the "CABAL == 0 && " fragment of the package.conf.in.cpp make things build?
19:40:54 <dons> (that code is only there to handles certain pre-cabal versions of ghc 6.3)
19:42:26 <lispy> dons: is it possible that Emacs.hs borrows keymap data from one of the other bindings?
19:42:58 <dons> don't think so.
19:43:06 <dons> look at the imports?
19:43:36 <lispy> they don't mean much to me, but it hides Yi.keymap and Lexers.Action
19:43:51 <dons> that's ok.
19:44:10 <dons> Yi.keymap is a default that it wants to not clash names with
19:44:15 <dons> same with Action
19:45:09 <lispy> okay
19:45:13 <lispy> that's reasonable
19:45:30 <lispy> @seen basti
19:45:31 <lambdabot> I haven't seen basti.
19:45:35 <lispy> @seen basti_
19:45:37 <lambdabot> I saw basti_ leaving #haskell 3 hours, 57 minutes and 57 seconds ago.
19:45:41 <lispy> darn
19:47:47 <lispy> dons: maybe i should start from scratch....
19:48:07 <lispy> yi
19:48:11 <lispy> er yi-static is okay
19:48:14 <lispy> it works the way i expect
19:48:28 <lispy> it must not be building yi_ anymore
19:48:50 <juhp> dons: yes, now I get to:
19:49:03 <juhp> /bin/sh: /plugins.conf.inplace: Permission denied
19:49:03 <juhp> /bin/sh: src/altdata/altdata.conf.inplace.in: No such file or directory
19:49:23 <juhp> must missing something?
19:49:24 <wagle> my experience is that i really don't want to battle a installation that is half configured one way, and half another way
19:50:42 <lispy> dons: fwiw, yi-static behaves exactly the way i want
19:50:53 <lispy> and yi_ has the hanging behavior
19:51:13 <wagle> ..  half of it will work, and half of it will break
19:51:27 <lispy> oh, and yi-inplace works too
19:52:01 <dons> lispy, yi-inplace is a script to call yi_ with  the right libpath
19:52:10 <dons> so if yi-inplace works, then so does yi_
19:52:20 <dons> #!/bin/sh
19:52:20 <dons> @YI_TOP@/yi_ -B@YI_TOP@ $*
19:52:22 <lambdabot> Unknown command, try @listcommands.
19:52:57 <dons> juhp, maybe clean everything out. edit the .cpp.in files. remake etc.
19:53:05 * wagle observes that The Way It Works is for them to ignore his advice, then come back 9 months later, exclaiming that I was right after all
19:53:24 <juhp> dons: I'm building from a rpm spec file :)
19:53:39 <dons> oh. scary. /me raises his hands in the air
19:54:06 <dons> I guess you have to write a patch that goes with the rpm spec?
19:54:20 <juhp> I did...
19:54:36 <juhp> I saw the above before patching too fwiw
19:54:43 <dons> oh. hmm.
19:54:51 <juhp> anyway I'll look more later
19:55:26 <lispy> wagle: er?
19:55:31 <lispy> wagle: are we ignoring you?
19:56:05 <wagle> you are still fighting an installation that is half build with the wrong prefix
19:56:20 <lispy> no i'm not
19:56:53 <wagle> make clean generally doesnt take you back to "fresh out of the box"
19:57:10 <lispy> i ran configure
19:57:31 <wagle> ./configure takes up where it last left off
19:58:13 <wagle> you are resuming it, not starting it fresh
19:58:37 <wagle> some things have distclean, but that sometimes isnt done right
19:59:06 <lispy> dons: maybe it's because yi-inplace sets the libdir?
19:59:34 <lispy> ah yeah that is why
20:00:10 <lispy> running yi_ really isn't the recommended way is it? /me starts using yi-inplace
20:00:32 <dons> thank you :)
20:00:52 <lispy> sorry, i just didn't realized that i shouldn't run it by hand
20:01:10 <dons> yeah, guess the docs don't say clearly what yi_ is for.
20:01:25 <dons> it's like ghc and ghc-inplace in the ghc build tree
20:01:41 <lispy> i'm not familiar with those
20:01:59 <lispy> i'm also guilty of not reading this far into the docs
20:02:31 * wagle gets some popcorn
20:02:48 * lispy adds a few more keys
20:09:36 <lispy> i'm not sure that a way to enter Meta keybindings has been implemented
20:10:16 <lispy> in fact, M-x doesn't seem to do much
20:12:29 <wagle> waugh: configure: error: Couldnt figure out how to call GHC.Handle.openFd!
20:12:45 <lispy> if '\^A' is the char for ctrl+a, then what is trick for meta+a?
20:13:25 * lispy realizes he should read the docs now
20:13:53 <dons> you'll have to work out what key sequence yi sees when meta-a is hit
20:16:23 <lispy> okay
20:19:27 <lispy> "- performance issue on very long lines. (C fragment?)" do you use balanced trees to store largestrings?
20:20:20 <dons> the issue is for several-megabyte lines. when moving down a line over such a large line, we inefficiently compute the end of the line
20:20:32 <lispy> oh
20:20:46 <dons> it needs a little change to one file to be a bit smarter
20:20:56 <dons> its on my todo list so I don't forget
20:21:37 <dons> how do I do: sum @a in perl?
20:21:49 <lispy> in perl?
20:21:58 <dons> yep, @a is my list
20:22:06 <dons> can I map ?
20:22:10 <lispy> dunno
20:22:13 <lispy> i run from perl
20:22:30 <wagle> there is a map function in perl
20:22:45 <dons> yep, I know. /me reads the man page
20:24:42 <wagle>  eval join ('+',@a)..  8-D
20:25:35 <lispy> dons: so the docs don't really tell you how to find out what key sequence is being read by Yi does it?
20:25:36 <dons> ah, join is our fold
20:25:49 <dons> lispy, no. but you can use putChar ;)
20:26:34 <wagle> http://perl.active-venture.com/lib/List/Util.html
20:26:44 <wagle>     $foo = reduce { $a + $b } 1 .. 10               # sum
20:27:07 <wagle> reduce is foldl
20:27:46 <wagle> @google perl sum list
20:27:48 <lambdabot> http://perl.active-venture.com/lib/List/Util.html
20:28:06 <lispy> i tihnk i'm too tired
20:28:08 <dons> cool.
20:28:13 <lispy> i should look at Yi again another day
20:28:18 <wagle> oh..  it has a sum operator too
20:28:21 <lispy> dons: thanks for your help
23:44:34 <Enveigler> Hi. Can anyone explain the concept of "lifting" in terms that this simpleton can understand?
23:45:08 <ski> hm
23:45:23 <ski> which concept 'lifting' ?
23:45:34 <ski> seen where ?
23:45:39 <ski> monadic lifting ?
23:45:43 <Pseudonym> The word is used in a few different contexts to mean different things.
23:46:29 <Enveigler> As in "Lifting is a powerful concept which allows you to transform a function into a corresponding function within another (usually more general) setting. -- XXX There must be a better definition"
23:46:40 <Pseudonym> Let floating.
23:46:47 <Pseudonym> I think.
23:46:47 * Enveigler is hoping that there *is* a better definition!
23:47:29 * ski thinks .. lambda lifting
23:49:18 <Enveigler> In less generic terms, I am trying to understand this piece of Haskell "liftM concat . mapM readFile" -- I understand 'readFile' and 'concat' and (I think) 'mapM', but the purpose of 'liftM' eludes me?
23:51:51 <wilx> To lift concat to the IO monad?
23:53:29 <ski> liftM is fmap for the IO monad
23:54:10 <ski> @type concat
23:54:12 <lambdabot> concat :: forall a. [[a]] -> [a]
23:54:18 <ski> @type Control.Monad.liftM concat
23:54:20 <lambdabot> Control.Monad.liftM concat :: forall a (m :: * -> *).
23:54:20 <lambdabot>           (Monad m) =>
23:54:20 <lambdabot>           m [[a]] -> m [a]
23:55:08 <ski> @type mapM readFile
23:55:10 <lambdabot> mapM readFile :: [FilePath] -> IO [String]
23:55:17 <ski> @type Control.Monad.liftM concat . mapM readFile
23:55:19 <lambdabot> Control.Monad.liftM concat . mapM readFile :: [FilePath]
23:55:19 <lambdabot>                 -> IO [Char]
23:56:20 <ski> Enveigler : so, concat takes a list of lists and returns a list, while liftM concat takes an IO action yielding a list of lists, and returns an IO action yielding a list
23:56:56 <Enveigler> Sorry, but all these explanations say /what/ liftM is in terms of other things which are equally opaque. Is it so indescribable to say /what is does/?
23:57:12 <ski> oh
23:57:45 <ski> liftM takes any function of type 'a -> b', and gives back a function of type 'm a -> m b' (in any monad m) ..
23:57:46 <Enveigler> ski: I sent that before seeing your last explanation
23:59:01 <ski> .. and that function takes the 'm a'-action and uses bind/>>= to get a value 'a' out of it, passes that to the 'a -> b' function to get a 'b' and returns that 'b' in the monad as 'm b'
