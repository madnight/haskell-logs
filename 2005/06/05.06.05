00:00:08 <basti_> i can show you what i got, but i don't know if that is releasable
00:00:50 <basti_> for example, "open file" isnt possible yet =)
00:02:38 <basti_> I can't work all the time at this stuff, it ties knots in my brain. but it's progressing
00:22:52 <dons> but Yi is a work in progess, so sending what you have is useful
00:23:25 <basti_> hmm okay
00:23:27 <dons> it's good for me to get an idea of how people are hacking on yi too
00:23:29 <basti_> I'll fix a patch
00:30:04 <basti_> uhm
00:32:05 <lispy> i wish block commenting/uncommenting in emacs haskell-mode was a bit smarter
00:32:18 <basti_> dons: patch is on the way
00:32:21 <lispy> it tends to get the indenting wrong after the uncomment
00:32:26 <dons> basti, got it, cheers!
00:50:53 <dons> basti_, did you send the right patch? the one you sent me removes Yi/Keymap/Emacs.hs ?
00:51:01 <dons> which doesn't seem right
01:11:01 <basti_> dons: uhm
01:11:21 <lispy> er
01:11:32 * basti_ will have a look how that happened
01:12:03 <dons> I knew you simplified the code, but maybe that's too much ;)
01:13:14 <basti_> ooops... o.o
01:13:19 * basti_ goes hunt for Emacs.hs
01:17:32 <basti_> dons: there. didnt know how that happened
01:18:12 <dons> ah, that looks better
01:18:25 <jlouis> dons: simplification by deletion is good
01:18:28 <dons> before I only got the - parts of the patch, not the + bits ;)
01:18:56 <basti_> apparently i did a backup and something went wrong
01:18:56 <basti_> ;)
01:19:25 <basti_> try C-x C-d
01:19:40 * boegel waves
01:20:13 <basti_> hi boegel
01:20:33 <dons> basti, what version of darcs are you using?
01:20:48 <basti_> 1.0.2
01:20:55 <basti_> that was an user error
01:21:25 <basti_> the thing about Emacs.hs disappearing
01:21:49 <dons> for some reason, when I apply your patch, I get:
01:21:50 <dons> pill19$ darcs whatsnew -s
01:21:51 <dons> M ./Yi/Keymap/Emacs.hs +280
01:21:59 <basti_> M?
01:22:13 <dons> that's a merge with the old code. let me try some things...
01:22:28 <dons> maybe  I have an broken repo
01:22:49 <basti_> maybe that's because of my error.
01:23:08 * boegel hates the fact he has to study RTS again
01:23:24 <dons> nope. same thing. I checked out a new repo, and when I apply your patch there's still changes to be recorded.
01:23:35 * basti_ .o° ( ? )
01:24:02 <dons> oh well, I'll just record them and push
01:24:17 <dons> oh, it's a mergeo
01:24:32 <dons> hmm. why was there a conflict? do you have the latest Yi?
01:25:13 <basti_> hmm might be a little outdated.
01:25:17 <basti_> ;)
01:25:32 <basti_> should i upgrade maybe?
01:25:48 <dons> can you do a darcs pull, fix the conflicts in Emacs.hs, and resend the patch
01:25:57 <basti_> ok
01:25:58 <dons> looks like just a couple of lines mess up
01:28:29 * boegel was reading a small biography of Einstein yesterday, and was impressed by the way how he lead his life
01:30:57 <dons> and he didn't even use darcs!
01:31:42 * lispy *gasp*
01:33:34 <dons> I know!!
01:33:47 <basti_> hmm
01:33:56 <basti_> dons would i then send all the three patches or just the new one?
01:34:11 <basti_> (1: remove emacs, 2: add new emacs, 3: pull/merge)
01:35:26 <dons> just send all of them.
01:35:38 <dons> darcs knows when it is safe to ignore a patch, btw.
01:36:05 <dons> and when a patch is missing. darcs is so great.
01:36:20 * dons kisses darcs and kicks diff and patch
01:37:12 * boegel pets darcs
01:37:27 <boegel> nice darcsy
01:37:35 <basti_> there we go
01:38:21 <dons> looks good!
01:38:27 <dons> applies good!
01:38:30 <basti_> great ;)
01:39:50 <lispy> is it possible to redefine show for a data type, or should i create a wrapper and just define show on that?
01:41:19 <Lemmih> The latter.
01:41:53 * boegel grumbles
01:41:54 <Lemmih> It sounds like 'show' may not be the right choice of function here.
01:42:10 <lispy> i don't like the default show for arrays
01:42:14 <dons> ooh.. "Type Key to Describe"
01:42:16 <dons> :)
01:42:19 <basti_> -g-
01:42:25 <lispy> i want something square when i have 2 dimensional arrays ;)
01:42:27 <basti_> theres not too many bindings yet
01:42:29 <dons> really nice, basti.
01:42:56 <basti_> :)
01:42:58 <Lemmih> lispy: What about calling it ppArray?
01:43:07 <basti_> thanks
01:43:08 <Lemmih> (pretty-print array)
01:43:20 <lispy> i could do that
01:45:15 <lispy> here is a question
01:45:42 <lispy> i want a function [(Int,Int)] -> [((Int,Int), Int)]
01:46:21 <lispy> here the first list is pairs like (i,j) and and in the second list (i,j) is untouched, but the third int is the index of (i,j) in the first list
01:46:37 <dons> easy.
01:46:51 <dons> zip with [0..]
01:46:57 <lispy> ah, cool
01:47:33 <dons> @plugs zip "abcdefg" [0..]
01:47:35 <lambdabot> [('a',0),('b',1),('c',2),('d',3),('e',4),('f',5),('g',6)]
01:55:41 <yain> neat.
01:56:36 <lispy> i had a throw a reverse in there to get it to work the way i needed
01:56:43 <lispy> but very nice trick
01:57:20 <lispy> \xs -> zip (reverse xs) [1..]
01:57:24 <lispy> @pl \xs -> zip (reverse xs) [1..]
01:57:26 <lambdabot> flip zip [1..] . reverse
01:57:30 <lispy> heh
01:57:43 <lispy> @pl always amuses me
01:57:45 <lambdabot> always amuses me
01:57:54 <lispy> @pl no, stop it
01:57:56 <lambdabot> (line 1, column 3):
01:57:56 <lambdabot> unexpected ","
01:57:56 <lambdabot> expecting letter or digit, variable, "(", operator or end of
01:57:56 <lambdabot> input
02:01:52 <lispy> i like how musical it sounds
02:01:55 <lispy> flip zip
02:05:46 <boegel> @plugs flip zip [1.. 5] . reverse
02:05:48 <lambdabot> <Plugins.Eval>:1:
02:05:48 <lambdabot>   No instance for (Show ([a] -> [(a, b)]))
02:05:48 <lambdabot>   arising from use of `show'
02:06:03 <boegel> oh,right :) nvm ;)
02:06:19 <boegel> @plugs flip zip [1.. 5] . reverse [a,b,c,d,e]
02:06:20 <lambdabot> Variable not in scope: `a'
02:06:29 <boegel> @plugs flip zip [1.. 5] . reverse ['a','b','c','d','e']
02:06:30 <lambdabot> Couldn't match `a1 -> [a]' against `[a2]'
02:06:33 <boegel> grr :)
02:06:35 <lispy> boegel: you've been reading about RTSs too much ;)
02:06:42 <boegel> apparently :s
02:06:47 <boegel> @type reverse
02:06:53 <lambdabot> reverse :: forall a. [a] -> [a]
02:07:05 <boegel> @type zip
02:07:07 <lambdabot> zip :: forall b a. [a] -> [b] -> [(a, b)]
02:07:07 <xerox> @plugs flip zip [1..5] $ reverse "abcde"
02:07:09 <lambdabot> [('e',1),('d',2),('c',3),('b',4),('a',5)]
02:07:18 <lispy> @plugs (flip zip [1..] . reverse) "aoeu"
02:07:20 <lambdabot> [('u',1),('e',2),('o',3),('a',4)]
02:07:23 <boegel> yeah, right
02:07:30 <boegel> that's what I was going to try next :)
02:11:37 <lispy> the way $ works is not intuitive to me yet
02:12:01 <lispy> i come from the lisp world, so putting () "where they belong" helps me ;)
02:12:24 <boegel> lispy: I think $ just evaluates the stuff on the right first, and just passes it to the left part
02:12:49 <boegel> as would be the same when you put it between brackets (it has priority over the left part)
02:12:53 <basti_> $ is the same as " " just with different fixity
02:12:55 <boegel> here comes the RTS stuff again :)
02:13:08 <basti_> yes right, just like ( ) around what is right of $
02:13:54 <boegel> basti_: I'm used to explaining stuff in human language, although it's not always 100% correct
02:15:01 * basti_ nods
02:16:15 <boegel> basti_: on the first or the last part ? :)
02:16:15 <lispy> well, that good to know
02:16:23 <lispy> i'll probably forget it again soon tho ;)
02:16:29 <lispy> parens die hard in a lisper ;)
02:16:40 <basti_> lol
02:16:55 <basti_> boegel: i think the second is pretty much self-explaining
02:16:56 <boegel> lispy: why did you change from lisp to Haskell ?
02:17:09 <lispy> well, i still use lisp a lot
02:17:13 <basti_> almost all natural language sentences are "flawed" in one way or the other
02:17:24 <lispy> bet this term and last, my classes were Haskell based
02:18:08 <lispy> a few things i love about haskell, 1) list comprehensions 2) lazy evaluation
02:18:30 <lispy> for example, i have a program here that finds knights tours on chessboards
02:18:35 <lispy> my solver finds all solutinos
02:18:41 <lispy> but i just ask for 1 at a time
02:18:44 <neologism> pattern matching is nice as well ;)
02:18:48 <lispy> but sometimes i want more
02:18:52 <lispy> yes, it is
02:19:05 * basti_ did a n-queens problem solver with list comprehension
02:19:13 <lispy> hehe
02:19:22 <lispy> i bet it's cute
02:19:25 <boegel> partial functions are pretty nice too
02:19:28 <basti_> uhm monads
02:19:34 <basti_> but theres not much difference
02:19:45 <basti_> currying is very good.
02:19:50 <lispy> monands...well, hmm...i haven't come to love them yet
02:20:08 <lispy> one thing i miss from lisp is being able to cons up a list and then eval it
02:20:11 <basti_> list monad is about the same as list comprehension, just slightly different notation
02:20:15 <boegel> I haven't even come to use/know them
02:20:20 <lispy> or just have some data lying around and use it as code
02:20:22 <boegel> I hope I can use them for H3D
02:20:26 <basti_> lispy: huh
02:20:36 <boegel> that would be cool, building a 3D modeller using monads !
02:20:40 <lispy> or vice-versa
02:20:42 <boegel> sounds like a nice article for TMR
02:20:50 <basti_> @pugs zipWith ($) [(*10)] [20]
02:20:51 <lambdabot> [200]
02:21:37 <lispy> basti_: i wrote a lisp program that reads itself in (or any lisp list) and returns a list that when eval'd returns waldo if the symbol waldo appeared in the input list.  It does this by wrapping the input list in car and cdr
02:21:55 <boegel> @pugs zipWith ($) [(*10)..(*30)] [20,30,40]
02:21:57 <lambdabot> <Plugins.Eval>:1:
02:21:57 <lambdabot>   No instance for (Enum (b -> b))
02:21:57 <lambdabot>   arising from the arithmetic sequence `(* 10) .. (*
02:21:57 <lambdabot>                    30)'
02:22:01 <boegel> thought so :)
02:22:07 <lispy> it's a toy program, but it shows one of the nice features of lisp
02:22:07 <boegel> @pugs zipWith ($) [(*10),(*20),(*30)] [20,30,40]
02:22:08 <lambdabot> [200,600,1200]
02:22:12 <lispy> and that is that code is data and vice versa
02:22:20 <basti_> lispy: ohh. okay this is not directly possible in haskell
02:23:15 <basti_> but lisp has the unfair advantage of being almost-interpreted
02:23:27 <lispy> it is very dynamic
02:23:37 <lispy> hs-plugin is getting there for haskell tho right?
02:24:00 <basti_> well lisp carries hashes with the function name -> function association
02:24:03 <basti_> doesnt it?
02:24:15 <lispy> macros are nice in lisp, and i see monads as a way of doing some of what macros do
02:24:29 <basti_> TH is macros for haskell
02:24:31 <lispy> depends on what you mean by lisp
02:24:45 <lispy> yeah, those seem powerful
02:24:48 <basti_> s/lisp/many lisp implementations/
02:25:29 <lispy> lisp has a notion of symbols that i don't think most languages have
02:25:34 <lispy> it's a nice notion
02:25:41 <basti_> what is it?
02:27:19 <lispy> that they are names, and you can give them values
02:27:38 <basti_> you mean names as in, human-readable-and-writeable-strings
02:27:56 <lispy> it's the sense that you can just use them as objects, or you can give them values and use them as varibles
02:29:39 <lispy> i'm probably not explaining well
02:29:55 <lispy> i'm half asleep and half coding, and half talking to my gf ;)
02:30:01 <lispy> and that's 3/2s
02:30:19 <basti_> hmm lol
02:30:26 <basti_> no i think i see what you mean
02:30:42 <basti_> but a rather important thing is, in lisp you can call variables their name at runtime
02:31:13 <basti_> isnt it?
02:31:24 <lispy> what is an example?
02:31:28 <lispy> i'm not sure...
02:33:24 <basti_> well in lisp you have access to some "eval" function
02:33:48 <basti_> you can let the user input something, and then eval that, and use that value for whatever
02:34:04 <lispy> right
02:34:30 <basti_> in haskell this is hard to do directly
02:35:50 <lispy> in haskell the emphasis has been taken off of dynamicness, and placed on staticness and typing checking
02:36:18 <basti_> yes.
02:36:26 <lispy> and i guess lisp has type checking, but it's dynamic
02:36:44 <basti_> i think lisp has a "can" type checking hasnt it?
02:36:56 <basti_> you can check things at build time making the code faster
02:37:05 <basti_> but you can also check at runtime
02:37:27 <lispy> right
02:37:38 <lispy> sbcl/cmucl use type inference for optimising
02:37:46 <lispy> and weak error checking
02:37:52 <basti_> but the haskell type system rox the house.
02:38:21 <lispy> well, it's useful, strong and powerful.  But it's a huge turn off to people new to the language
02:38:21 <lispy> and then all implementations have
02:38:24 <jlouis> the advantage of a static type system is compile time type errors, and only that.
02:38:37 <lispy> "<lispy> and then all implementations have"  <-- not sure where that came from
02:39:11 <basti_> c&p blooper. do you use X11?
02:39:35 <lispy> i think i started to type something and hit C-a and then typed something else
02:39:39 <lispy> i'm pretty tired ;)
02:39:41 <basti_> ah
02:39:55 <lispy> (i use emacs through a screen session under X11)
02:40:06 <lispy> so yeah, i do use x11 ;)
02:40:16 * basti_ sometimes hits a mouse button too much
02:40:23 <lispy> usually i hit C-a C-k then type something else
02:40:24 <basti_> which in X11 usually triggers half a catastrophe
02:40:52 <lispy> or half an apostraphe...
02:40:54 <lispy> depending
02:41:22 <lispy> man, the darcs bug address gets sooo much spam
02:41:51 <basti_> :(
02:50:20 <lispy> array can be quite slow
02:50:46 <lispy> i changed my tour solver to use a list of where the knight has been instead of modifying the array with that info
02:50:49 <lispy> and it's much faster
02:50:58 <lispy> i assume it's because the old version was O(n*m)
02:51:11 <lispy> updating the array for every move that is
02:51:37 <basti_> :)
03:09:52 <boegel> yo Smurfje :)
03:10:06 <boegel> I bet nobody in here knows what his/her nick means :)
03:10:52 <cpage> Smurf from Jersey?
03:12:20 <boegel> cpage: ? :)
03:12:37 <cpage> "je" is the ISO country code for Jersey.
03:13:06 <basti_> jersey has an own TLD?
03:13:15 <cpage> Oui.
03:13:17 <boegel> "je" is something Dutch people use when something is small, kind of like "y" in English
03:13:19 <cpage> http://www.theodora.com/country_digraphs.html
03:13:27 <boegel> dog -> doggy, hond -> hondje
03:13:46 <basti_> diminutive
03:13:50 <basti_> english doesn't really have that
03:14:10 <cpage> English borrows "ette" from French.
03:14:40 <cpage> I take it Smurfje translates to Smurfette, the name of the one female Smurf.
03:14:48 <boegel> basti_: yeah, but people use it
03:14:56 <basti_> yes.
03:15:04 <basti_> its hard to live without diminutive
03:15:08 <boegel> cpage: Smurfje translates to "Little Smurf"
03:15:25 <basti_> even if it doesn't inflect a word the "strong" way ;)
03:15:35 <cpage> boegel: Exactly. Smurfette -> Little Smurf
03:16:03 <basti_> btw. how do smurfs reproduce?
03:16:28 <cpage> A cartoonist draws a new one.
03:16:51 <basti_> hm.
03:17:16 <cpage> Google says there are a lot of Smurfje's around.
03:18:27 <boegel> cpage: Smurfette is just "Female Smurf" in French, right ? hasn't to do anything with "little", that's "petit" in French
03:18:37 <boegel> or "petite" in female
03:19:32 <cpage> Yes, it also carries a connotation of gender when used in English, though it is also used for in a gender-neutral way to mean "small".
03:20:34 <cpage> <http://www.bartleby.com/64/C005/006.html>
03:21:22 <boegel> didn't know that
03:21:57 <jlouis> there is one smurf story with a female smurf IIRC
03:22:29 <cpage> I thought the character Smurfette appeared in most of the Smurf cartoons.
03:22:33 <jlouis> she has to be damn productive in the smurf village should be sustainable
03:25:12 <asmodai> in Dutch: smurf / smurfin
03:25:18 <asmodai> like: vriend, vriendin
03:28:03 <boegel> jlouis: she's a how ! :)
03:28:05 <cpage> Is "in" equivalent to "small" or "female"?
03:28:19 <boegel> nope
03:28:39 <boegel> vriend/vriendin is like boyfriend/girlfriend
03:28:51 <boegel> hence smurf/smurfin
03:29:00 <boegel> some topic :)
03:29:07 <boegel> @google Haskell smurf
03:29:09 <lambdabot> http://cristal.inria.fr/ICFP2001/prog-contest/results-elim/
03:29:12 <cpage> Yet it isn't a suffix that means "female"?
03:29:17 <boegel> cpage: no
03:29:53 <cpage> Is it not a suffix?
03:30:05 <boegel> not really
03:30:19 <cpage> Oh, just part of the word "vriendin"?
03:30:32 <boegel> vriendin is just a totally new word :) yep
03:31:06 <cpage> So, is that a common pattern in Dutch, or is "smurfin" a direct reference to "vriendin" and only "vriendin"?
03:31:22 <boegel> the latter probably
03:31:43 * basti_ would like to know why so many programmers are fond of linguistic themes
03:31:51 <boegel> I can't think of another word with 'in' at the end which means "female <something>"
03:31:55 <cpage> Well, thank you for the little Dutch lesson. :-)
03:32:02 <boegel> cpage: geen probleem :)
03:32:16 <basti_> in german, "in" suffix is female, btw.
03:32:16 <basti_> ;)
03:33:06 <boegel> I don't know any german at all, never got a German class in school (as opposed to many others my age)
03:33:37 <basti_> but english instead?
03:33:53 <boegel> no, everybody got english (and french)
03:34:12 <boegel> I just didn't have german because i was a 'science student'
03:34:14 <basti_> ah.
03:34:20 <boegel> I had more math and chemics and stuff
03:34:32 <boegel> languages aren't really my thing
03:34:41 <boegel> just english, I think you can go anywhere with english
03:34:52 <cpage> basti_: Are you sure you aren't thinking of "eine"?
03:34:54 <basti_> yes english is pretty useful
03:34:57 <boegel> and if you can't, just making gestures and drawing stuff gets you quite far
03:35:11 <basti_> cpage: uh no. Bäcker = baker, Bäckerin = female baker etc.
03:35:25 <boegel> oh, we have that in Dutch too :)
03:35:29 <cpage> basti_: Ah! Right.
03:35:43 <boegel> but again, that's something like vriend/vriendin... I don't know if it's really a suffix
03:35:51 <basti_> hmm
03:36:04 <basti_> thats hard to say anyway
03:36:28 <basti_> bbl though
03:36:37 <basti_> bringing gf to the library
03:36:40 <basti_> (what for?)
03:37:24 <yain> to read books!
03:39:49 <boegel> to get rid of her ! :)
03:41:37 * boegel takes a shower
03:51:47 <jlouis> to force her to read ``how to please a man sexually''
03:52:21 <jlouis> hmmm, maybe I should try compiling darcs again
04:05:51 <basti_> back
04:05:58 <basti_> jlouis: yes.
04:06:13 <basti_> no but, i had to bring her to the lib by foot. so that she wouldnt be alone on the way.
04:08:57 <boegel> basti_: O_o
04:09:04 <boegel> where  do you live, the Bronx ?
04:09:12 <basti_> no in marburg.
04:09:24 <boegel> is it that dangerous there ?
04:09:35 <basti_> i think the problem was boredom not danger
04:09:42 <boegel> :)
04:09:49 <basti_> and that we "can never talk" in other situations
04:09:54 <basti_> (she's working all the day)
04:10:16 <boegel> so you talked for 10mins, and that pleased her ? :)
04:10:39 <basti_> hm.
04:10:47 <basti_> i didnt say it would be making sense did I?
04:12:06 <boegel> gf's can be _so_ strange sometimes
04:12:22 <boegel> when you think you're doing it right, you're doing it _totally_ wrong
04:13:36 <basti_> lol
04:13:43 <basti_> well this was not wrong obviously
04:13:53 <basti_> watzlawick wrote a whole book about this
04:14:02 <basti_> not gf's specifically but this problem
04:14:28 <basti_> wrong was, playing twister with that girl yesterday, but, my gf doesn't know.
04:14:28 <basti_> :)
04:14:57 <boegel> :)
04:15:29 <boegel> but we just can't live without them, can we :
04:15:34 <boegel> s/:/:)
04:15:40 <basti_> no that would be hard.
04:15:47 <basti_> for not-that-bisexual people at least
04:16:54 <basti_> and if I hadn't taken that opportunity yesterday, i would have been angry at myself
04:16:59 <basti_> and theres no reason for that
04:17:31 <boegel> opportunity ?
04:17:41 <basti_> playing "twister" with that girl who's not my gf
04:17:45 <boegel> oh
04:17:47 <boegel> it was you :)
04:17:51 <basti_> but all the more interesting
04:17:57 <basti_> :P
04:17:59 <boegel> heh
04:18:01 <boegel> watch it dude
04:18:06 <boegel> if she finds out, you're in hell
04:18:22 <basti_> ah playing twister is not cheating upon my gf.
04:18:35 <boegel> but she'll look at it a whole other way
04:18:43 <basti_> :)
04:18:43 <boegel> "why didn't you play it with me ?"
04:18:49 <boegel> "what's wrong with me ?"
04:18:55 <boegel> "is she cuter than me ?"
04:18:59 <boegel> "she is, isn't she !"
04:19:05 <boegel> "the bitch !"
04:19:15 <basti_> she did that once btw.
04:19:20 <basti_> not because of twister though
04:19:20 <boegel> it starts friendly, but it ends up all messy and shit
04:19:28 <boegel> because of naked twister ? :D
04:19:35 <basti_> ah no.
04:19:53 <basti_> i'll tell her myself if it involved any nakedness
04:19:53 <boegel> note to self: try naked twister with gf
04:20:06 <boegel> why did she go crazy then ?
04:20:24 <basti_> ah she was much into her tutor once.
04:20:31 <basti_> and she told me all the time with that
04:20:36 <basti_> and how that might affect or relation or not
04:20:42 <basti_> and urged me to talk about that
04:20:44 <basti_> etc.
04:20:59 <boegel> talking about it is good dude
04:21:00 <basti_> and asked me once if I knew i girl that I got "closer than usual" with or something
04:21:11 <basti_> uhm yes, but not if its the third week in a row and nothing new
04:21:21 <boegel> heh :)
04:21:25 <basti_> and not if its a rather artificial problem.
04:21:34 <basti_> well, and i mentioned her...
04:21:44 <boegel> my gf just to be really jealous, but I managed to improve that a lot :)
04:21:59 <boegel> her = twister girl ?
04:22:02 <basti_> she met her once, and later she was like "waaah whats so special about her?"
04:22:02 <lightstep> having read about half of the Fudget thesis and half of the Fruit paper, it seems Fruit programming would be fun. is it, or a more advanced library, available for debian?
04:22:02 <basti_> yes
04:22:18 <boegel> is she special to you ?
04:22:45 <basti_> well she's special because we've become friends immediately
04:23:06 <boegel> I had some of those girls too, but things have changed
04:23:07 <basti_> saying that there is no sexual attraction would be lying, at least for my part
04:23:25 <basti_> changed yes.
04:23:33 <boegel> dangerous stuff :) and playing twister with here doesn't make it any easier now is it :)
04:23:50 <basti_> uhm
04:23:55 <basti_> well
04:24:00 <boegel> s/here/her
04:24:24 <basti_> it certainly means better quality of life for me in the short perspective
04:24:36 <boegel> your gf isn't enough you mean ?
04:24:38 <basti_> and if i've learned one thing, it's life always happens in the short perspective
04:24:44 <basti_> i wouldn't put it like that
04:25:01 <basti_> i do not think i should not play twister with that girl if i can
04:25:02 <boegel> how would you put it then :)
04:25:24 <boegel> I think you shouldn't make your gf angry when there's no reason to :)
04:25:38 <basti_> i'm not making her angry
04:25:46 <boegel> because she doesn't know :D
04:25:56 <basti_> i'm even not telling her, which is a problem for my conscience
04:26:24 <basti_> i know this is "not ok".
04:26:31 <basti_> but nothing ever is "ok".
04:27:13 <boegel> my gf was like that too
04:27:21 <basti_> but?
04:27:32 <boegel> but when she noticed I'm ok with her meeting other guys, it watered down
04:27:49 <basti_> i don't mind if she meets guys too.
04:27:51 <boegel> 2 weeks ago, some guy she hasn't seen in over 3 years sent her a message
04:28:03 <boegel> he clearly wanted to meet her without me with it :)
04:28:07 <basti_> -g-
04:28:18 <boegel> I think he was horny and was just seeing what girls he knew :)
04:28:26 <boegel> but I'm perfectly ok with that
04:28:38 <basti_> i think jealousy is a very stupid thing.
04:28:38 <boegel> I know, even if she would meet him, nothing would happen
04:28:46 <basti_> what if? :)
04:29:02 <boegel> what if something would happen ?
04:29:19 <basti_> yes
04:29:50 <boegel> then 1) it would be over, since i can never trust her again, and 2) that guy would have a serious nose bleed within 2 days orso, because I know where he lives :)
04:30:03 <basti_> ah
04:30:11 <boegel> I think when you got cheated on once, you can never trust that person again
04:30:11 <basti_> all that distrust and violence :(
04:30:22 <basti_> i think i do not own my gf's body
04:30:35 <boegel> well, since there no reason for distrust, there's no violence either
04:30:38 <boegel> neither do I
04:30:45 <basti_> i think trust and friendship is a very different thing than sex
04:30:54 <boegel> but a relation is a commitment, you should be too close with someone else
04:31:01 <boegel> yeah it is
04:31:13 <boegel> but "something happening" is more than just friendship
04:31:19 <basti_> hm?
04:31:23 <boegel> I wouldn't mind if she played twister with him
04:31:40 <boegel> but if they would play twister naked, I would be offended
04:31:47 <boegel> because we've never done that (yet)
04:31:58 <basti_> ah.
04:32:11 <boegel> and also, it's just not right to have sex with other people when you're in a relation
04:32:27 <boegel> even if a naked girl would be in front of me, willingly, I don't think I'd go for it
04:32:34 <basti_> most people think so and so i would tell my gf if there was something going on
04:32:55 <boegel> honesty can help a relationship a lot
04:33:16 <boegel> that's how I got my gf less jealous :)
04:33:28 <Philippa> boegel: it's not right to have sex with other people when you're in a /monogamous/ relationship. HTH
04:33:38 <basti_> :P
04:33:52 <Philippa> but yeah, honesty's good. Doubly so when you're not
04:33:58 <basti_> lol
04:34:01 <basti_> what?
04:34:32 <boegel> Philippa: yeah, ok
04:34:43 <boegel> but I don't care for another kind of relationship
04:34:51 <Philippa> yeah, that's fair enough
04:35:11 <boegel> Philippa: honesty is good when you're not honest ? O_o
04:35:21 <basti_> thats what i stumbled over
04:35:55 <Philippa> boegel: honesty is really really important when you're in a non-monogamous relationship
04:36:11 <Philippa> (because non-monogamous != no commitments)
04:36:16 <basti_> ahh
04:37:13 <basti_> but still, there's no point in not living "right here and now"
04:37:27 <basti_> i know what i'm like if i try not to.
04:37:27 <boegel> and it's not in a monogamous one ? surely so !
04:37:54 <Philippa> boegel: I just said more so, not that it doesn't matter in a monogamous one
04:38:05 <Philippa> if nothing else, there's a greater need to be honest about things like safe sex
04:38:08 <boegel> basti_: living right here and now will give you much pleasure with someone else, but a lot of heartache the days after
04:38:14 <boegel> that's why it's not worth it to me
04:38:22 <boegel> and besides, no-one would want me anyways :)
04:38:26 <jlouis> non-monogamous relationsships seems hard to me
04:38:36 <basti_> all relationships are hard.
04:38:40 <Philippa> yeah, it's not easy to make work
04:38:47 <Philippa> there're many, many new ways to mess up
04:38:50 <boegel> that's why I don't start with it :)
04:39:09 <jlouis> Philippa: you sound routinely experienced...
04:39:11 <boegel> like doing one sutff with 1 person, and not wanting it to do with someone else :)
04:39:12 <jlouis> ;P
04:39:16 <boegel> Philippa: yeah, she is ;)
04:39:27 * Philippa spanks boegel
04:39:27 <Philippa> *bad*
04:39:42 <jlouis> bad zoot?
04:39:56 <jlouis> (damn, that quote could be used more than once)
04:40:01 <basti_> I think people think differently about terms like "being true" and "honesty"
04:40:08 <basti_> thats part of the problem
04:40:16 <Philippa> jlouis: I'm in a poly relationship, though there's not quite been anything that would qualify as a second relationship yet (some really close misses and a lot of stuff that'd really bug most folks in monogamous relationships though)
04:40:38 <Philippa> "being true" smells a little too much of "true love" and associated mythology to me
04:40:45 <jlouis> lightstep: I do not know
04:40:46 <basti_> yes mythology thats a point
04:40:57 <Philippa> there are /n/ right people out there for you, the odds of n being exactly 1 are low...
04:41:01 <boegel> Philippa: what kind of stuff that would bug most folks ?
04:41:21 <basti_> if people just wouldnt THINK that much about love
04:41:30 <boegel> basti_: righto !
04:41:31 <Philippa> boegel: going to visit somebody I love and sleeping in the same bed both nights'd be a start
04:41:41 <basti_> boegel: thats what you say yes.
04:41:50 <basti_> ;)
04:42:38 <jlouis> Philippa: Ah, I see
04:42:42 <Philippa> we didn't have sex, at the time Damien wouldn't have been comfortable with that and in hindsight it's a good thing we didn't as she's really not happy with an LDR
04:42:47 <jlouis> @seen shapr
04:42:48 <lambdabot> I saw shapr leaving #haskell 4 days, 12 hours, 7 minutes and 34
04:42:48 <lambdabot> seconds ago.
04:43:16 <basti_> i think feelings happen different to thoughts.
04:43:33 <lightstep> ldr?
04:43:39 <jlouis> long distance rel.
04:43:40 <Philippa> long distance relationship
04:43:41 <basti_> and i do not think I should bug people with the problems i have regarding my though/feeling differences
04:43:42 <boegel> long distance rel.
04:43:44 <boegel> heh :-
04:44:01 <boegel> Philippa: you said she, so you're a lesbian, right ?
04:44:06 <boegel> or bi whatever :)
04:44:07 <Philippa> basti_: depends on the person. Sometimes knowing you're in tension between your thoughts and feelings helps explain a lot
04:44:10 <Philippa> bi, yes
04:44:18 <Philippa> we've been over that in here before :-)
04:44:29 <boegel> I wasn't here, I think :)
04:44:35 <boegel> atleast I don't remember :)
04:44:36 <basti_> yes it can help communication wise
04:44:58 <Philippa> so yes, I should be wandering around in a t-shirt reading "Hot Bi Babe" and waiting for the nearest het couple looking to form a triad that's probably mostly for the guy's benefit
04:45:01 <boegel> so Damien is a girl ? I didn't know that :)
04:45:07 <Philippa> no, he's not
04:45:13 <Philippa> what part of bi do you not understand? :-)
04:45:19 <basti_> but I wouldn't for example think it made sense to tell my gf something like "hey i really love you, but i can't accept that you do X" or "I have had feelings towards another person as well, you might have a problem with that"
04:45:21 <Lunar^> Is that #haskell?
04:45:22 <boegel> oh, okay, I messed up :)
04:45:34 <basti_> lol
04:45:39 <boegel> Philippa we didn't have sex, at the time Damien wouldn't have been comfortable with that and in hindsight it's a good thing we didn't as she's really not happy with an LDR
04:45:51 <boegel> that why I thought Damien is f :)
04:45:52 <Philippa> the 'she' being the friend in london
04:46:17 <boegel> oh okay
04:46:28 <boegel> about the triad, I don't get some guys
04:46:42 <Philippa> basti_: I've done the latter, and with a rephrasing ("I have trouble with you doing X") I've had the former conversation too
04:46:58 <boegel> a friend of mine is a lesbian, and when she was walking with her gf on the street, some guy stopped and asked if they were willing to do a triad
04:47:01 <boegel> I mean WTF ??
04:47:19 <basti_> Philippa: so does it make sense?
04:47:28 <Philippa> "sure, we go for the classic initiation ceremony - wanna do your forefinger first?"
04:47:37 <boegel> basti_: that's for you to determine, isn't it :)
04:47:43 <basti_> ;)
04:47:51 <boegel> Philippa: :D
04:48:10 <Philippa> basti_: yeah. Though Damien and I've been living together for a fair while, dealing with ways we wind each other up's important. And the 'I like somebody else' conversation (which happened a loooong time ago) is how we ended up poly
04:48:27 <jlouis> Philippa: hmmm, you seem to put up some parallellisms to a certain type-inference t-shirt now ;)
04:49:07 <Philippa> jlouis: I guess I kinda inferred the type of relationship I needed to be in
04:49:20 <jlouis> oh, stop...
04:49:26 <jlouis> hehe
04:49:35 <boegel> Philippa: are you still together with Damien ?
04:49:49 <Philippa> yeah
04:50:05 <jlouis> Lunar^: this is actually #haskell. We are discussing an inference algorithm for relationsships as you can se
04:50:08 <jlouis> e
04:51:00 <Lunar^> jlouis:err... that's a bit contrieved :D
04:51:02 <boegel> Philippa: has he been together with other people ?
04:51:24 <Philippa> no. He's kinda shy and not sure he wants to. I do feel a bit guilty about that - mind you, some day he'll want to explore his own bi side
04:52:08 <boegel> I've explored that side, and i really don't like it
04:52:21 <boegel> I'll stick to the straight side :)
04:52:29 <Philippa> fair enough
04:52:41 <boegel> but, he doesn't have to explore his bi side, right ? he can just go for another girl
04:52:48 <Philippa> he doesn't have to, no
04:52:51 <boegel> you wouldn't have any problem with that at all ?
04:52:56 <Philippa> it's just I suspect that's the more likely outcome
04:52:57 <Philippa> nope
04:53:29 <Philippa> (we'd each have problems if eg the other person were spending so much time with their other significant other that they had none left for us - that's a bridge to cross as we get there)
04:54:34 <boegel> we'll, yeah, I think that's kind off hard
04:54:46 <lscd> sure, poly relationships are hard
04:54:57 <boegel> for some reason, people used to think I fancy guys, which isn't the case at all :)
04:55:07 <boegel> guess i was just to 'loose'
04:55:07 <Philippa> OTOH, a friend of mine's barely got any time for an ordinary relationship. Much to my irritation she's straight too :-)
04:55:09 <basti_> klemmschwuchtel :P
04:55:37 <boegel> Philippa: you could try and convert (how do you say this) her
04:55:45 <basti_> lol
04:55:51 <boegel> I think the border to cross for two girls is lower than for two guys
04:56:05 * basti_ doesnt believe in this being a decision
04:56:16 * lscd agrees with basti_ 
04:56:22 <Philippa> boegel: she knows I like her, I'm not going to push any further. It's nice just spending time together, anyway
04:56:57 <basti_> i decide however, that, however erotic i might find men (which i do sometimes), having sex with a man is probably not a very pleasurable experience generally
04:57:01 <basti_> ;)
04:57:19 <Philippa> basti_: that's likely to depend on how you want to go about it
04:57:20 <boegel> Philippa: sure, sex doesn't have to be part of it at all
04:57:39 <Philippa> ah. Well y'see, sexuality is the only issue - close friendships, no problem
04:58:01 <boegel> lscd, basti_: i mean the border to decide you want to try it, not how you feel about it
04:58:01 <basti_> i'm kidding a bit.
04:58:06 <basti_> ah
04:58:27 <Philippa> hugs are fine, massages are cool, massaging /there/ might weird somebody out
04:58:31 <lscd> boegel: eh... true
04:58:31 <boegel> I think you can love a person perfectly without wanting sex with him/her
04:59:08 <Philippa> boegel: I agree, though I find that unlikely for myself personally. OTOH, sex doesn't necessarily have to come with half the baggage people give it
04:59:10 * basti_ would have to find the girl he DOESNT want to have sex with first.
04:59:11 <basti_> :P
04:59:20 <basti_> Philippa: right.
04:59:22 <Philippa> (for me it's a bit like loving somebody and not wanting to hug them)
04:59:37 <basti_> and then there's bonobos
05:00:02 <lscd> yeah; too bad we didn't evolve from them
05:00:16 <basti_> as pleasurable as sex is, its not the most intimate form of being together
05:00:19 <boegel> basti_: I think that's totally different for guys than girls
05:00:40 <boegel> basti_: I agree
05:00:47 <Philippa> basti_: depends. Not least on what you count as sex - certainly I don't stick to the PIV definition
05:00:56 <basti_> i think the truth about this is concealed under centuries of mythology and power
05:01:06 <boegel> PIV ?
05:01:11 <Philippa> Penis In Vagina
05:01:18 <boegel> oh, yeah
05:01:27 <basti_> hmm i would say sex is what actively involves genitals ;)
05:01:29 <boegel> there are far more intimate ways of having sex than that
05:01:51 <basti_> you can be extremely intimate without sex, and vice versa
05:01:57 <Philippa> basti_: would you tell that to somebody who is pretty sure they've experienced an orgasm that didn't involve any genital contact?
05:02:15 <basti_> Philippa: -sighs-
05:02:15 <basti_> ;)
05:02:29 <Philippa> (this is physically possible, FWIW, folks who're paralysed from the neck down have been known to retrain themselves so that stimulating the right part of the neck does it)
05:02:37 <basti_> i know
05:02:53 * boegel tries stimulating his neck
05:02:57 <basti_> ive had orgasms without much genital stimulation too
05:03:01 <Philippa> boegel: takes a /lot/ of training
05:03:03 <boegel> oh, ooh
05:03:05 <Philippa> basti_: not "not much", none
05:03:06 <basti_> but *some* was always involved
05:03:09 <boegel> no, it's not working :)
05:03:23 <basti_> but i agree, that in principle, sex is independant of any genitals ;)
05:03:35 <boegel> i can get really on the edge if my gf has one
05:03:40 <boegel> without bein touched
05:03:50 <boegel> beinG
05:03:50 <basti_> but most people want to be touched there when they're horny.
05:03:56 <boegel> true
05:04:15 <Philippa> sometimes it's not even about being horny though. Generally those're the most intimate moments
05:04:31 <basti_> mmm i think i know what youre talking about
05:04:51 <basti_> but what doesnt include sex then, in your definition?
05:05:10 <boegel> it's hard to define that I guess
05:05:45 * boegel wonders why the topic 'sex' is always active when Philippa is around
05:06:03 <basti_> Philippa always shows up when we're discussing sex
05:06:29 <Enveigler1> Can anyone point to at some source that uses FFI to map over some fairly complicated C-structs? Particularly a C-struct that contains multiple fixed-length byte arrays?
05:06:47 <lscd> basti_: the question is, is that because you're always talking about sex? or is she just talented/lucky?
05:06:58 <basti_> i guess Philippa is more of the lucky kind :P
05:07:02 <boegel> Enveigler1: is that question sex related ? if it isn't, you're on the wrong channel :p
05:07:03 <lscd> uh-huh
05:07:53 <Enveigler1> Huh! I noted and pondered, but every time I ask for the #haskell channel, I keep getting routed here? :)
05:07:55 <Philippa> I tend to be responsible for pushing a conversation from hovering on the border to being definitely about sex. I should probably try not to do that so often
05:08:06 <basti_> ah why
05:08:15 <lscd> Enveigler1: file a bug report ;)
05:08:15 <basti_> whats bad about talking about sex?
05:08:22 <Philippa> Enveigler1: I don't know of anything off-hand. I'm pretty sure HaCanon has to do it, but that's generating everything via Template Haskell
05:08:30 <Philippa> basti_: it stops people talking about haskell
05:08:36 <basti_> right
05:08:37 <Philippa> well, unless you're making really awful puns
05:08:44 <basti_> we should make a new channel for that
05:08:46 <basti_> #haskell-sex
05:08:51 <lscd> or #haskell-puns
05:09:03 <Philippa> *every* IRC chan gets puns though
05:09:03 <genneth> #touch-my-monads
05:09:08 <basti_> LOL
05:09:20 <Philippa> genneth: pred :-)
05:09:26 <genneth> ;)
05:11:06 <boegel> everybody join the latter ! :)
05:11:09 <Philippa> anyway, there're certain trends around here - folks like strong discipline, but it shouldn't be strict...
05:11:19 <Enveigler> Admission: I have no idea what HaCannon is, and I can only guess by association what "Template Haskell" is.
05:11:33 <boegel> basti_: mwoeha :)
05:11:37 <basti_> TH is like lisp macros for haskell.
05:11:50 * boegel likes the power of being an op :p
05:11:53 <basti_> lol
05:11:54 <Philippa> and HaCanon is a library that uses it to build bindings to C++ code
05:12:58 <Enveigler> Right now I'd settle for help in doing it manually -- and any refereces to FFI source code can come later :)
05:13:01 <jlouis> Enveigler: what do you want to do with those structs?
05:13:28 <jlouis> You can marshall those data if you want
05:13:52 <Enveigler> The struct is returned from a sytem call, and I need to be able to access the elements within it.
05:14:11 <jlouis> Enveigler: you have read http://www.reid-consulting-uk.ltd.uk/docs/ffi.html, right?
05:15:38 <jlouis> I am fond of hsc2hs myself, having used it more than once for funny things
05:16:06 <Enveigler> I'm pretty sure that I need to use Foreign.marshall.array in the data declaration, but I need to see some sample code to make sense of the LibRef descriptions (I'm new to Haskell!)
05:16:54 <Enveigler> Yes. I saw the reid docs--but that level of descussion is beyond my needs and it doesn't give much by way of examples.
05:23:39 <dons> hey TheHunter, how's code?
05:24:04 <tibbetts> Do people use Parsec for compiler implementation, or do they stick with more classic parser generators like Happy?
05:24:18 <dons> both are common
05:24:29 <Philippa> I've used Parsec for compiler-like projects. It's nice and easy to work with
05:24:42 <boegel> so is Happy
05:24:44 <Philippa> it's also good for extensible and/or weird stuff
05:24:49 <dons> parsec is the more traditional choice for small projects, happy is gaining ground, and is used in some of the big projects - e.g. ghc
05:24:51 <boegel> that's what I used for my ray tracer
05:25:06 * Philippa nods
05:25:14 <tibbetts> I'm using Parsec, because it seems really cool and easy and extensibility is important to me. But it is so flexible I'm having trouble figuring out how to structure things.
05:25:14 <dons> Philippa's point about extensibility is good.
05:25:14 <Philippa> I have a near-religious allergy to generators
05:25:33 <basti_> Lemmih: did we scare you away ;)
05:25:33 <Philippa> tibbetts: just transliterate your grammar for now
05:25:56 <tibbetts> When using Parsec, do you build an AST and do multiple passes, or do you try to fit more in the first pass? In particulary, typechecking in the first pass seems challenging.
05:25:59 <dons> you can't use happy to dynamically extend grammars, for example
05:26:16 <dons> that's bad form -- typing checking in the parser...
05:26:17 <Lemmih> basti_: Yeah, it became _way_ too geekie. (:
05:26:21 <Philippa> tibbetts: more simple passes is simpler
05:26:28 <Philippa> and don't bother trying for a single-pass compiler
05:26:43 <Philippa> thanks to lazy evaluation and GHC's optimisation, often it'll behave like one anyway
05:26:46 <tibbetts> I don't know that it is bad form, but I should probably stay good.
05:27:06 <Philippa> tibbetts: it's a bad idea because parsing and type-checking are separate operations
05:27:24 <Philippa> you might want a "parse and tell me if it's good" op, but it's better expressed in terms of those two separate operations
05:27:41 <Philippa> otherwise you're left performing a fusion optimisation by hand, which is... error-prone
05:28:00 <jlouis> Enveigler: you want to look at something like peekArray or peekArray0
05:28:07 <tibbetts> So, what do people use for AST representation? Roll your own, or is there a popular package?
05:28:38 <dons> the 'data' keyword ;)
05:28:39 <jlouis> Enveigler: A FFI call will yield you a pointer to the array. A peekArray call on that will convert it into a list
05:28:54 <Philippa> tibbetts: haskell's datatypes're perfect for the job
05:29:05 <Philippa> something I noticed when I was first being taught haskell at uni
05:29:25 <dons> tibbetts, seriously - define your abs syntax as a data type. it's just too easy in Haskell
05:29:38 <dons> and noone does anything else
05:29:45 <jlouis> Enveigler: if you are going to call massive amounts of foreign functions, you want something like hsc2hs
05:29:51 <Philippa> to give an example, just about everybody's seen data Term = Var Ide | App Term Term | Lam Ide Term; type Ide = String; somewhere
05:30:04 <Philippa> (AST for the untyped lambda calculus)
05:30:17 <tibbetts> Feels like it parallels my grammar so much that it is redundant. But that may just be because I'm starting out.
05:30:42 <Philippa> tibbetts: *Abstract* Syntax Tree :-) If your concrete grammar's that simple then hey, cool, the parser's easy to write
05:31:39 <Enveigler> Phillipa: Yes, but the struct in complex. I contains several CULongs,several CULLongs, and two byte arrays one 260 bytes and the 14 bytes. Treating the whole struct as a byte array (or int or double word array) makes life very hard.
05:31:40 <tibbetts> Similarly, much as there is value to Parsec having an easy to use parser for expressions, it seems like having a libraryized AST for expressions would also be useful. But I guess I will go do that.
05:32:01 <dons> tibbetts, maybe check out some of the references here: http://www.cse.unsw.edu.au/~cs3161/References.html
05:32:08 <Philippa> how would you put it into a library?
05:32:13 <Enveigler> jlouis: Not masses just 1, but how?
05:32:19 <Philippa> What features would you want beyond those haskell datatypes provide?
05:32:32 <Philippa> (generic maps and folds I guess, but no Haskell 98 lib can provide those sanely)
05:34:46 <tibbetts> Well, one thing I have found is the Zephyr Abstract Syntax Description Language (ASDL) which allows your passes to be written in various languages and gives your intermediate forms a good on disk representation. But I'm not sure I care about either of those things.
05:35:29 <tibbetts> At any rate, it sounds like these are not the droids I am looking for.
05:35:53 <Philippa> tibbetts: almost all those things'll just regurgitate what algebraic datatypes do anyway
05:36:08 <Philippa> they might claim to be built on eg s-expressions instead, but it's very much same difference
05:37:00 <Philippa> oh, and haskell datatypes're easily serialisable anyway
05:37:03 <Philippa> derive Read and Show
05:37:51 <dons> which is my favourite trick for testing student type checkers
05:42:16 <dons> @uptime
05:42:17 <lambdabot> uptime: 9 days, 10 hours, 17 minutes and 25 seconds
05:42:20 <dons> @ghc
05:42:22 <lambdabot>  Data constructor does not return its parent type
05:42:25 <dons> @y0w
05:42:27 <lambdabot> LOOK!!  Sullen American teens wearing MADRAS shorts and "Flock
05:42:27 <lambdabot> of
05:42:27 <lambdabot> Seagulls" HAIRCUTS!
05:42:27 <boegel> @arr
05:42:28 <lambdabot> I'll keel haul ya fer that!
05:42:58 <dons> hmm @code would be fun. random line of code from $fptools...
05:43:06 * dons hacks
05:43:40 * jlouis grins
05:43:43 <xerox> @vixen Is dons crazy?
05:43:46 <lambdabot> my keyboard doesn't have an
05:44:07 <jlouis> @vixes are you a sexy bugged gal?
05:44:09 <lambdabot> just sexy? not a sexy bitch?
05:44:27 <jlouis> oh, cool, delta change of my typo
05:45:21 <dons> yep, it does up to 3 insert/delete/swap until it finds a match
05:49:30 <Enveigler> !
05:50:29 <dons> !
05:50:52 <basti_> ?
05:51:02 <dons> @ghc
05:51:03 <lambdabot>  Can't mix generic and non-generic equations for class method
05:54:33 <TheHunter_> hey dons, code is pretty bad right now, since i have to figure out what's wrong with my sister's xp notebook.
05:55:56 <dons> :/
05:57:00 <TheHunter> btw, class Foo a where foo :: a -> a; foo {| Unit |} Unit = Unit; foo x = x
05:58:17 <lightstep> in what language is all this {| something |} from the boilerplate papers?
05:58:17 <TheHunter> ok, i highly suspect it's a problem with the hard drive...
05:58:18 <dons> hehe
05:58:42 <TheHunter> you need to pass -fgenerics to ghc.
05:59:05 <TheHunter> @google generic classes ghc manual
05:59:07 <lambdabot> http://www.reed.edu/~carlislp/ghc6-doc/users_guide/generic-classes.
05:59:07 <lambdabot> html
05:59:17 <TheHunter> @google site:haskell.org generic classes ghc manual
05:59:19 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/
06:03:51 <TheHunter> hmm, generic classes are more powerful than SYB, aren't they?
06:04:39 <TheHunter> i don't see how one would implement |toBin|.
06:04:58 <ski> (SYB ?)
06:05:12 <TheHunter> scrap your boilerplate
06:06:00 <ski> mhm
06:08:36 <TheHunter> ok, to be fair, syb can do stuff that generic classes can't (eg. arbitrary finite products).
06:11:50 <TheHunter> oh, windows is so great: "chkdsk has found at least one error on the drive"
06:13:31 <ryko> hi all, this is my first time on the channel - so I don't now what exactly the etiquetes are: can I just pop a Haskell question?
06:13:53 <Igloo> Yes!
06:14:00 <basti_> definitely
06:14:10 <ryko> great! here goes:
06:14:49 <ryko> I'm trying to make an abstract way of processing both regular lists and linked lists.
06:14:59 <ryko> I try to do so using a class.
06:15:08 <ryko> I'd like to do this:
06:15:11 <ryko> data LList
06:15:11 <ryko> 	= MkEnd
06:15:11 <ryko> 	| MkList String LList
06:15:11 <ryko> 	
06:15:11 <ryko> class List a where
06:15:12 <ryko> 	slEmpty :: a
06:15:14 <ryko> 	slCombi	:: b->a->a
06:15:16 <ryko> 	
06:15:18 <ryko> instance List [a] where
06:15:20 <ryko> 	slEmpty = []
06:15:22 <ryko> 	slCombi = (:)
06:15:24 <ryko> 	
06:15:26 <ryko> instance List LList where
06:15:28 <ryko> 	slEmpty = MkEnd
06:15:30 <ryko> 	slCombi = MkList
06:15:41 <kaol> @paste
06:15:42 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:18:51 <ryko> sorry - pasted it at the wiki now
06:19:35 <ski> ryko : the 'b' in the type of slCombi is problematic
06:20:11 <ski> the type of slCombi allows :  slCombi True (slCombi "Hey" slEmpty)
06:20:49 <ski> and neither ordinary lists or your own string-lists support that
06:21:54 <ryko> okay, I see. so it's simply not possible to create an abstract that will work for lists, as well as my 'linked list' type? or am I simply taking the wrong approach?
06:22:36 <ski> each application of slCombi says that it will take something of arbitrary type ('b') and something of the type 'a' (instance of the class) and give something of type 'a'
06:22:59 <ski> looking at your attempts of instances
06:23:05 <ski> you might be wanting something like
06:23:23 <ski> class List a b where ...
06:23:30 <ski> instance List [a] a where ...
06:23:42 <ski> instance List LList String where ...
06:23:46 <Philippa> shouldn't need to be a multiparm class, it's just a constructor class ala Monad
06:24:29 <ski> Philippa : if ryko wants to instance LList, multiparm seem to me to be needed
06:25:45 <ski> ryko : the alternative List class i gave is actually a relation between types, in this case it relates a "list" type with the corresponding "element" type
06:27:12 <ski> (ryko : also, using multi-parameter classes requires extensions turned on)
06:27:18 <TheHunter> ryko, first of all, you should note that LList is pretty much the same as [String], think of [a] as being defined by |data [a] = [] | (:) a [a]|
06:27:25 <Philippa> ski: oops, yeah
06:28:14 <ryko> okay. that's all new stuff for me. need some time to comprehend :)
06:31:03 <ryko> if I do 'instance List [a] a' I get "list is applied to too many type arguments". Does that have to do with the extension I have to enable?
06:31:23 <ski> you have to change the class definition, too
06:31:39 <ski> class List a b where
06:31:45 <ski>   slEmpty :: a
06:31:49 <ryko> okay - I see
06:31:54 <ski>   slCombi :: b -> a -> a
06:33:00 <ski> (hm, in this case you possibly also need another thing to get that accepted ..)
06:33:58 <basti_> was lambda-the-ultimate once hosted on lambda.weblogs.com?
06:34:16 <ski> basti_ : think so
06:34:29 * ski goes to buy some edibles
06:34:42 <dons> hehe:
06:34:44 <dons> @code
06:34:45 <lambdabot> GetOpt.hs: >     , Option ['c']     []          (OptArg inp  "FILE")  "input FILE"
06:34:48 <dons> @code
06:34:49 <lambdabot> Cmd.hs: Nothing Nothing Nothing
06:34:52 <dons> @code
06:34:53 <lambdabot> ST.lhs: (k2 new_s) }})
06:35:02 <dons> instructive code examples!
06:35:32 <dons> @help code
06:35:33 <lambdabot>  @code, print random line of code from $fptools
06:35:46 <xerox> @code
06:35:47 <lambdabot> Float.lhs: sinhFloat, coshFloat, tanhFloat  :: Float -> Float
06:36:44 <tibbetts> I'm building an AST representation. Do I have to tag every algebraic type with "deriving (Eq, Show,...)" or is there a way to just tag the root of the tree and have the compiler do the right thing?
06:37:46 <dons> @code
06:37:47 <lambdabot> Basics.hs: _              -> error "maxConstrIndex"
06:38:26 <dons> I wonder if one could learn Haskell by having @code quoted to them
06:54:41 * SamB wonders what a MS Windows PE 32-bit Intel 80386 native DLL is doing loose in /usr/lib
06:56:06 <basti_> don't.
06:57:53 <Philippa> tibbetts: you'll have to derive on all the new types you introduce
06:58:21 <Philippa> 'snot overly strenuous considering what you're getting for it though
07:18:15 <ryko> ski: thank you for your directions: I think I'm heading in the right direction now. I've pasted the code I've got now at the Wiki, but unfortunately, I'm still getting one type error that I don't understand. Could you have another look please?
07:19:43 <TheHunter> |class List a b | a -> b where| should do the trick.
07:20:12 <TheHunter> it uses functional dependencies, kind of an advanced concept.
07:20:37 <jlouis> SamB: interface to some video codec?
07:21:11 <TheHunter> i'm not sure you need type classes at all to solve your problem.
07:21:55 <ryko> me neither - I'm pretty much a Haskell newbie..
07:22:27 <ryko> I'll try the 'functional dependencies' first though.
07:23:22 <TheHunter> as i said, LList is isomorphic to [String], so you don't need to define it at all.
07:23:49 <TheHunter> back in 30 min.
07:24:08 <ryko> okay, agreed: but this is only a small test-case for a larger problem I'm having in which the types aren't isomorphic.
07:24:10 <Philippa> TheHunter: learning exercises and all that
07:24:28 <Philippa> what's the actual problem? It might be more constrained than we're seeing here
07:26:52 <ryko> I'm working on a (de)serializer. Some sequences get recognized to a list of types, others to a linked list of a specific type.
07:27:21 <Philippa> in the "list of types" case, how're they distinguishable?
07:30:34 <ryko> I'm thinking about how to best formulate that. One sec.
07:31:53 <Philippa> first of all, does the deserialiser have to be extensible, and if so to what extent?
07:32:22 <Philippa> (can you teach it to recognise new types by filling in instances of a typeclass? Does it recognise them from scratch via some kind of tagging in the datastream, or does it get that info from the call context?)
07:33:22 <ryko> no, there's a fixed number of elements that need to be recognized. it works on a tagged data-stream
07:35:25 <ryko> on deserialising, a stream of bytes is transformed in to a linked list of 'tags'. Some tags, however can contain lists of atomic values, which are represented as within the tags as regular lists
07:38:05 <Philippa> so it's a bit like this:
07:38:22 <Philippa> data Stuff = TagA | TagB [SomeAtom] | TagC [SomeOtherAtom]?
07:38:35 <Philippa> and possibly a TagD JustTheOneAtom case?
07:39:26 <ryko> yes, that's correct. but, sometimes specific 'atomic' elements should be deserialized to a linked list, and on other occasions to a regular list. As an additiomal complexity, sometimes the list of values in the sourcestream is terminated by zero, sometimes there's a listcount upfront, sometimes a list-size.
07:39:34 <Philippa> (oh, [Stuff] as the root type)
07:39:43 <Philippa> er, why does linked list vs regular list matter?
07:40:27 <Philippa> the differences in the sourcestream're... well, differences in the sourcestream, the parser's problem rather than any datatype's
07:40:59 <ryko> it doesn't realy, in regards to format I'm deseriazing, but I choose to use lists for small bits, and linked list for larger chunks.
07:42:23 <Philippa> why? The only discernable difference is at the type level
07:42:40 <Philippa> haskell lists're implemented as linked lists anyway
07:43:54 <Philippa> (for now, if you've really gotta do it, why not make your linked lists parameteric types too? Then you get a much simpler type class if you have to do things that way)
07:44:27 <ryko> the serializer uses the same data structures, and since that in turn is part of a compiler, I need to do a lot of 'tail' insertions - so I thought a linked list would be quicker?
07:44:46 <Philippa> no
07:44:53 <Philippa> it'd have to be a reverse-linked one
07:45:08 <Philippa> and tbh it's not that big a deal
07:45:35 <Philippa> (just keep all the lists backwards if you're that bothered)
07:45:49 <Philippa> bear in mind Haskell's a pure language, you never overwrite a list - and thus you can refer to chunks of other lists
07:46:51 <ryko> I don't really get it: if you want to insert an element at the end of a list, you need to use '++' - doesn't that mean that all elements in the list that the element is added to get traversed?
07:47:34 <Philippa> yup
07:47:44 <Philippa> worse yet, the whole of the list has to be duplicated
07:47:58 <Philippa> (unless you're lucky and the compiler proves to itself that the old version's not being used any more)
07:48:15 <genneth> Philippa: it happens quite often tho
07:48:20 <Philippa> true
07:48:41 <Philippa> if it does, /then/ you get the constant-time just-update-the-tail-pointer behaviour (but it still has to traverse the whole list)
07:48:54 <Philippa> that's how linked lists /work/ - adding to the tail's expensive if you don't know where the tail is
07:48:57 <MachinShin> hey +
07:49:04 <Philippa> 'lo
07:50:21 <astrolabe> so use a doubly linked list?
07:51:13 <ryko> So, back to my LList: if I'm building the list, I can do: LList "a" (LList "b" MkEnd) etc. That's adding to the tail, right? Where's the traversal then?
07:51:48 <Philippa> no, you're always adding to the head
07:51:51 <Philippa> MkEnd is the tail
07:52:09 <Philippa> to add to the tail, you have to replace the MkEnd in that expression
07:52:22 <Philippa> so you have to get to it (starting from the LList "a")
07:52:53 <ryko> I see your point
07:55:12 <ryko> but if you never actually 'replace' MkEnd, but only 'build' the value by constantly adding 'the tail' - then it is efficient right?
07:55:48 <Philippa> if you do let foo = LList "a" (LList "b" MkEnd) in LList "z" foo, yeah
07:55:56 <Philippa> (that gets [z,a,b])
07:56:25 <Philippa> none of foo needs to be altered for that
07:57:19 <ryko> okay, that is what I in my compiler, when going from the AST to the assembly data model
07:58:41 <Philippa> and ordinary haskell lists behave like that
07:58:52 <Philippa> so no need for the extra type. Problem solved :-)
07:59:42 <ryko> I think you are right but since I'm not a Haskell guru I need think about it a bit more :)
08:00:31 <Philippa> your LList type behaves like ordinary lists, so either it's wrong or ordinary lists're right. The rest of the problem doesn't actually appear to impact on it at all
08:02:16 <ryko> that makes sense
08:02:58 <ryko> thank you all - I've learnt a lot on my first visit to this channel!
08:04:10 * ski is back
08:52:13 <xerox> Does hs-plugins work with GHC 6.4 now?
08:56:00 <Lemmih> Yes.
08:59:28 <xerox> That's a good news!
09:01:24 <Lunar^> Haskel.Eval -> System.Eval
09:07:04 <xerox> Building lambdabot: Could not find module `System.Plugins.Load'.  Hmpf.
09:09:47 <Lemmih> Did you register hs-plugins?
09:10:39 <xerox> I did.
09:10:59 <Lemmih> Was it a recent version of hs-plugins?
09:11:26 <xerox> Yep
09:11:35 <xerox> Does GHC search on /usr/local by default?
09:11:37 <Lemmih> CVS tarball or darcs repo?
09:12:03 <xerox> Nightly snapshot.  The darcs repo's sources didn't compile.
09:12:44 <Lemmih> Does plugins show up in 'ghc-pkg list'?
09:13:31 <xerox> Between the others I note: altdata-0.9.8, plugins-0.9.8, eval-...
09:14:13 <Lemmih> Can you use System.Plugins.Load with GHCi?
09:14:48 <xerox> Could not find module `System.Plugins.Load': it is not a module in the current program, or in any known package.
09:15:18 <Lemmih> Is System.Plugins.Load listed in 'ghc-pkg describe plugins'?
09:16:17 <Lemmih> Under 'Exposed-Modules'.
09:16:23 <xerox> There is no System.* but there is Plugins.Load
09:16:38 <Lemmih> Get a newer version of hs-plugins.
09:17:21 <xerox> Is unregistering and rm -rf /usr/local/lib/hs-plugins enough for properly unistalling hs-plugins?
09:18:04 <Lemmih> I believe so.
09:19:30 <xerox> Lemmih, that's strange, I downloadd the last snapshot, the newest.
09:22:29 <xerox> I retry with the darcs repo.
09:23:14 <TheHunter> xerox, do you have hsx installed?
09:23:25 <xerox> TheHunter, I think that was the error.
09:24:35 <TheHunter> btw, the hsx tarball contains three things only one of which is actually hsx,
09:24:48 <xerox> Can you point me to it?
09:24:52 <TheHunter> s/tarball/repo/
09:24:59 <TheHunter> @google haskell hsx
09:25:01 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/haskell/hsx-infix-types.
09:25:01 <lambdabot> patch
09:25:08 <TheHunter> @google haskell hsx haskell source
09:25:10 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
09:25:29 <TheHunter> $ darcs get http://www.cs.chalmers.se/~d00nibro/haskell-src-exts
09:25:35 <TheHunter> $ cd haskkell-src-exts
09:25:41 <TheHunter> $ cd src
09:25:43 <TheHunter> $ cd haskkell-src-exts
09:25:57 <TheHunter> $ runhaskell Setup.hs configure
09:26:01 <TheHunter> $ runhaskell Setup.hs build
09:26:03 <TheHunter> $ runhaskell Setup.hs install
09:29:40 <xerox> runhaskell, hmmm...
09:31:26 <TheHunter> no gmp?
09:31:38 <xerox> gmp? Probably not.
09:32:11 <TheHunter> does it work?
09:32:35 <xerox> I don't have either gmp nor runhaskell.
09:32:49 <TheHunter> if you have ghc6.4, you have runhaskell.
09:33:21 <xerox> Sob.
09:33:54 <xerox> Is runghc the same?
09:34:11 <TheHunter> probably.
09:37:11 <xerox> Preprocessing library haskell-src-exts-0.2...
09:37:11 <xerox> Language/Haskell/Hsx/Parser.ly: no happy preprocessor available
09:37:12 <xerox> *** Exception: got error code while preprocessing: Language.Haskell.Hsx.Parser
09:37:20 <xerox> Grumble.
09:38:55 <TheHunter> your distri should have happy.
09:42:14 <xerox> Oh, yes!  Thanks much..
10:14:28 * musasabi does not understand why the patch got first in google ._.
10:14:29 <musasabi> 'c
10:53:33 <_JusSx__> booooreeed
11:46:55 <derelm> using testBit i can check if bit x is set in number y but testBit 10 1 wont work, so how do i use it?
11:48:06 <sorje> Where is testbit defined?
11:48:11 <derelm> Data.Bits
11:50:36 <derelm> ah, got it: testBit (10::Int) 1
11:50:46 <derelm> but why do i have to "cast" to an int?
11:50:49 <Lunar^> @plugs testBit (10 :: Word) 1
11:51:02 <lambdabot> True
11:51:43 <Lunar^> derelm: Word*, Integer and Int* are defined instances of Bits
11:51:56 <Lunar^> derelm: (* = 8, 16, 32, 64)
11:52:17 <ski> derelm : it's not a "cast". it's a type "ascription", you can see it as a constraint
11:52:20 <Lunar^> derelm: Int, and Word are machine size (eg. either 32 or 64 bits)
11:52:27 <derelm> hm i am not sure i understand why it's needed but ok
11:53:04 <ski> derelm : you need to somehow tell testBit which instance of the class Data.Bits.Bits the first argument should be
11:53:12 <musasabi> 'c
11:53:12 <Cale> @type 10
11:53:14 <lambdabot> 10 :: forall t. (Num t) => t
11:53:27 <ski> derelm : and because numberic literals (such as 1) are overloaded, a plain such doesn't work
11:53:37 <derelm> ah ok, i see
11:53:40 <derelm> thanks
11:55:07 <ski> derelm : in most code, it can figure out which instance to use, but not always (especially in an interactive repl)
12:33:07 <AtnNn> how do i find the first occurrence of an element in a list (strchr)?
12:34:41 <Lemmih> @plugs elemIndex 'w' "Hello world."
12:34:43 <lambdabot> Just 6
12:35:02 <Lemmih> @plugs "Hello world."!!6
12:35:03 <lambdabot> 'w'
12:35:11 <Lemmih> @docs Data.List
12:35:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
12:35:29 <AtnNn> kty
12:35:58 <kaol> @plugs (1/0)::Int
12:35:59 <lambdabot> <Plugins.Eval>:1:
12:35:59 <lambdabot>   No instance for (Fractional Int)
12:35:59 <lambdabot>   arising from use of `/'
12:36:31 <kaol> @plugs (1/0)::Double
12:36:33 <lambdabot> Infinity
12:36:55 <kaol> @plugs 0-(1/0)::Double
12:36:57 <lambdabot> -Infinity
12:37:15 <Lemmih> @plugs (-1/0)
12:37:17 <lambdabot> -Infinity
12:43:24 <arjanoosting> @plugs 1 `div` 0
12:43:35 <lambdabot> Fail: divide by zero
12:43:35 <lambdabot>  
13:02:31 <genneth> @index show
13:02:33 <lambdabot> Text.Show, Prelude
13:07:00 <genneth> @plugs foldr (>>) (return ()) (take 10 (zipWith (>>) (map (putStr . show) [1..]) (map putChar [',' | x <- [1..]]) ) )
13:07:06 <lambdabot> No IO allowed
13:07:10 <genneth> DAMN!
13:07:13 <genneth> ahme
13:07:15 <genneth> excuse me
13:11:57 <SyntaxNinja> genneth: nice try!
13:17:34 <lisppaste2> AtnNn pasted "split bug" at http://paste.lisp.org/display/8831
13:17:44 <AtnNn> can anyone help me with that?
13:19:38 <Lemmih> Put parentheses around x:y.
13:19:45 <Lemmih> x:y => (x:y)
13:20:52 <AtnNn> ok
13:22:43 <AtnNn> *Main> split ' ' "1 2 3"
13:22:43 <AtnNn> ["1","2","3"]
13:22:48 <AtnNn> thanks
13:24:49 <AtnNn> what!?
13:32:02 <mikael> hi!
13:33:32 <ski> hello mikael
13:33:38 <mikael> hey ski
13:34:04 <Lemmih> Greetings, phubuh.
13:34:44 <mikael> :-)
13:44:18 * ski wonders if one of the two compositions of the obvious functors between a category and the kleisli category over a monad over the previous category can be extended to a comonad (the other composition seems to yield the original monad back ..)
14:18:13 <boegel> yo Itkovian
14:18:32 <Itkovian> yo, just passing by, going to sleep now :-)
14:18:55 <boegel> heh, bye then :p
14:24:19 <boegel> hey dcoutts
14:24:48 <gaal> hi, can anyone point me to some help on installHandler and Signal sets?
14:26:44 <gaal> eg: can i read a signal handler? how do i use ss's to set a handler?
14:27:02 <Limbic_Region> salutations gaal
14:27:08 <gaal> hey L~R
14:28:00 <gaal> initHandler sigUSR1 h  (Just addSignal) ????
14:28:17 <gaal> can't be right.
14:28:43 <Limbic_Region> no lamda heads in #perl6?
14:29:01 <gaal> this is purely a haskell q, L~R.
14:29:29 <gaal> i'll try there if i get no clues here :)
14:30:12 <Limbic_Region> actually - both channels seem a bit quiet
14:34:43 <gaal> installHandler sigUSR1 catch( h ) Nothing # looks warmer, but i'm not sure yet
14:40:02 * boegel yawns
14:47:43 <basti_> am i lagged or whhat
14:49:32 <boegel> basti_: why should you ?
14:50:13 <dcoutts> hi boegel
14:55:14 <lispy> i have a list [(Maybe a, a)] and I want to map a function onto the list, and when the first element is Nothing, I just want to skip it, how can I do that?
14:56:09 <lispy> i'd even be happy with filtering out each element like (Nothing, x)
14:56:44 <dcoutts> [ (a,b), (Just a, b)  <- xs ]
14:56:51 <lispy> @plugs filter (not . Just . fst) [(Nothing, 1), (Just 2, 2)]
14:57:03 <lambdabot> Couldn't match `Bool' against `Maybe a'
14:57:20 <heatsink> I think you mean isJust
14:57:26 <dcoutts> @plugs [ (a,b), (Just a, b)  <- [(Nothing, 1), (Just 2, 2)] ]
14:57:27 <lispy> @plugs filter (not . isJust . fst) [(Nothing, 1), (Just 2, 2)]
14:57:27 <lambdabot> parse error on input `<-'
14:57:29 <lambdabot> [(Nothing,1)]
14:57:35 <dcoutts> @plugs [ (a,b) | (Just a, b)  <- [(Nothing, 1), (Just 2, 2)] ]
14:57:36 <lispy> @plugs filter (isJust . fst) [(Nothing, 1), (Just 2, 2)]
14:57:37 <lambdabot> [(2,2)]
14:57:38 <lambdabot> [(Just 2,2)]
14:57:44 <Lemmih> @plugs [ (a,b) | (Just a, b) [Nothing, (Just 2,10) ]
14:57:45 <lambdabot> parse error on input `)'
14:57:51 <Lemmih> tsk
14:58:09 <dcoutts> ok, if you want to keep the Just:
14:58:14 <dcoutts> @plugs [ (Just a,b) | (Just a, b)  <- [(Nothing, 1), (Just 2, 2)] ]
14:58:16 <lambdabot> [(Just 2,2)]
14:58:21 <lispy> ii don't care about the just
14:58:32 <lispy> i was "just" trying to understand what you typed ;)
14:58:49 <dcoutts> pattern matching in the binder of a list comprehension is cool :-)
14:58:54 <lispy> yeah, just realized that ;)
15:00:09 <lispy> [(a,b) | (Just a, b) <- zip (map (bestMove b) ps) ps]
15:00:15 <lispy> that's my comprehension ;)
15:00:57 <dcoutts> I think ghc even has a "zip" extension to list comprehensions
15:01:20 <dcoutts> never used it though
15:02:33 <lightstep> are Writer [Char] and State ShowS equivalent wrt. laziness and stack usage?
15:04:16 <dcoutts> that's a difficult question. If no one happens to know, I'd suggest you experiment (to find the strictness) and benchmark (to find the stack usage)
15:07:44 <lightstep> ech
15:07:56 <dcoutts> indeed :-)
15:08:13 <dcoutts> ask too hard a question...
15:11:01 <lightstep> then i'll risk another: why are arr/pure, (>>>), first/second/***/&&& in the same class, while left/right/+++/||| separated into another one?
15:12:34 * boegel leaves for his bed
15:13:32 <heatsink> left/right have to do with case expressions on arrows
15:14:07 <heatsink> everything in that class is for supporting arrow case.
15:15:51 <lightstep> but, if i understand correctly, there is some use for Category, which is like Arrow but without arr (it has returnA, though). also, if you leave out first&co, you get something very much like a monoid. so why not just subclass all these?
15:20:44 <ski> for theoretical reasons, it would be nicer to separate out first&co, yes
15:21:22 <ski> i guess they put it in there because they didn't think of any interresting application which doesn't support first&co
15:42:05 <resiak> Forgive my stupidity. Where's the "done" monad?
15:42:42 <dcoutts> resiak, never heard of it, where did you see this?
15:43:38 <resiak> dcoutts: Introduction to Functional Programming using Haskell, second edition, by Richard Bird. "Another command is done :: IO (); when performed done does nothing." ;-)
15:44:04 <dcoutts> ok, I was not aware.
15:44:12 <dcoutts> I guess you could refine done = return ()
15:44:18 <resiak> That's exactly what I want. Thanks.
15:44:20 <dcoutts> refine/define
15:44:27 <Heffalump> IFPH claims that a 'done' command exists? :-)
15:44:28 <resiak> Sorry, I'm being dumb. :-)
15:44:35 <resiak> Heffalump: Page 326
15:45:15 <Heffalump> so it does. How silly.
15:45:25 <dcoutts> resiak, I'm sure you;re not being dumb, it's probably just that the Haskell standard has changes since Bird wrote the book (long ago)
15:45:38 <Heffalump> mind you, it also seems to think that an interactive system that uses '?' as the prompt exists.
15:45:45 <Heffalump> dcoutts: long ago indeed!
15:45:48 <resiak> That makes sense. I should have thought of return (), though. I've never wondered how to do nothing before.
15:46:15 <Heffalump> it only jus tpredates the Haskell 98 standard.
15:46:22 <resiak> It's not that I'm trying to do anything particularly hard here. :-)
15:46:28 <dcoutts> resiak, one doesn't until you meet the theoretical cs folk. :-)
15:47:05 <dcoutts> they want units and zeros for everything, hence the do nothing and aborting program
15:47:17 <Heffalump> haven't you done FPD? skip is an imporant concept..
15:47:57 <dcoutts> of course it is important, it's just suprising at first that it is actually important
15:48:27 <Heffalump> true
15:49:09 * resiak stops playing around with things that he doesn't need to know yet and sleeps.
17:44:33 <lispy> i'm getting "*** Exception: Predlude.head empty list" is there an easy way to track this down?
17:45:49 <Cale> lispy: depending on the circumstances, it could be tricky
17:46:00 <Cale> how many places in the code do you use head?
17:46:05 <lispy> a lot...
17:46:19 <lispy> i'm trying to convert an algo from C to haskell
17:46:27 <lispy> and it's wrenching my brain...
17:46:57 <Cale> hmm... well, you might try using Debug.Trace
17:49:26 <Cale> write something like tracedHead str xs = if null xs then trace str undefined else head str
17:49:29 <Cale> r
17:49:32 <Cale> write something like tracedHead str xs = if null xs then trace str undefined else head xs
17:51:35 <dons> thee's a way to track it down using the profiling tools as well, you'd have to google for that
17:52:07 <dons> are, -xc
17:52:29 <lispy> i think i'll just put in patterns until i figure it out
17:53:36 <dons> supposed to be easy:     This can be particularly useful for debugging: if your program is complaining about a head []
17:53:40 <dons>     error and you haven't got a clue which bit of code is causing it, compiling with -prof -auto-all
17:53:43 <dons>     and running with +RTS -xc -RTS will tell you exactly the call stack at the point the error was
17:53:45 <dons>     raised.
17:54:03 <Cale> ah, nice
17:54:54 <lispy> can i use that from ghci?
17:55:04 <lispy> i can just add a main, but i'm lazy ;)
17:55:09 <dons> from ghc only.
17:55:13 <dons> ghci doesn't do profiling
17:55:32 <Trevion> Hey everyone.
17:56:08 <lispy> okay, well i'll try to add a main
17:57:29 <Trevion> Quick question: I'm playing with timing RSA operations using getCPUTime.
17:57:49 <Trevion> However, at least on Windows, getCPUTime seems awfully granular... am I doomed?
17:57:54 <lispy> <GHC.List.CAF>warnsdorff2: Prelude.head: empty list
17:58:25 <lispy> and the .prof file is empty
17:58:44 <dons> check the runtime-control.html page of the users guide.
17:58:51 <dons> it has more explanation of what the fields mean
17:59:58 <dons> here: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-debugging
18:00:32 <Igloo> The best solution is to check for empty list earlier and give a better error message
18:00:48 <dons> :)
18:07:11 <AtnNn> what is weak head normal form?
18:08:35 <lispy> it's like normal form, except it has a weak head ;)
18:09:29 <dons> @google what is weak head normal form?
18:09:30 <lambdabot> http://computing-dictionary.thefreedictionary.com/Weak+Head+Normal+
18:09:30 <lambdabot> Form
18:09:39 <Pseudonym> @foldoc whnf
18:09:42 <lambdabot> *** "whnf" foldoc "The Free On-line Dictionary of Computing (27 SEP
18:09:42 <lambdabot> 03)"
18:09:42 <lambdabot> WHNF
18:09:42 <lambdabot>  
18:09:42 <lambdabot>    {weak head normal form}
18:09:42 <lambdabot>  
18:09:49 <Pseudonym> @foldoc weak head normal form
18:09:53 <lambdabot> No match for "weak".
18:09:53 <lambdabot> No match for "head".
18:09:53 <lambdabot> No match for "normal".
18:09:53 <lambdabot>  
18:09:53 <lambdabot> *** "form" foldoc "The Free On-line Dictionary of Computing (27 SEP
18:09:54 <lambdabot> 03)"
18:09:56 <lambdabot> FORM
18:09:58 <lambdabot> [13 @more lines]
18:10:01 <Pseudonym> @foldoc "weak head normal form"
18:10:02 <lambdabot> *** "weak head normal form" foldoc "The Free On-line Dictionary of
18:10:02 <lambdabot> Computing (27 SEP 03)"
18:10:04 <lambdabot> Weak Head Normal Form
18:10:06 <Pseudonym> There you go.
18:10:06 <lambdabot>  
18:10:08 <lambdabot>    <reduction, lambda calculus> (WHNF) A {lambda expression}
18:10:10 <lambdabot> is
18:10:12 <lambdabot>    in weak head normal form (WHNF) if it is a {head normal form}
18:10:14 <lambdabot> [39 @more lines]
18:10:19 <Pseudonym> @more
18:10:20 <lambdabot>    (HNF) or any {lambda abstraction}.  I.e. the top level is
18:10:20 <lambdabot> not
18:10:20 <lambdabot>    a {redex}.
18:10:22 <lambdabot>  
18:10:24 <lambdabot>    The term was coined by {Simon Peyton Jones} to make explicit
18:10:26 <lambdabot>    the difference between {head normal form} (HNF) and what
18:10:29 <lambdabot>    {graph reduction} systems produce in practice.  A lambda
18:10:30 <lambdabot> [32 @more lines]
18:10:41 <mauke> ugh. the line wrapping is horrible
18:10:41 <dons> oh, didn't know it was an SPJism
18:11:00 <dons> @todo
18:11:01 <lambdabot> 0. SamB: A way to get multiple results from a google search
18:11:01 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
18:11:01 <lambdabot> 2. SamB: bare @part either gives error message or parts the channel
18:11:01 <lambdabot> the command was given on
18:11:01 <lambdabot> 3. SamB: stop mangling long urls
18:11:02 <lambdabot> 4. dons: improve formatting of @dict
18:11:04 <lambdabot> 5. SamB: @karma+ should report total karma
18:11:06 <lambdabot> [4 @more lines]
18:11:09 <dons> item number 4 ;)
18:12:00 <lispy> i've wrapped every call to head in an iff
18:12:02 <lispy> er and if
18:12:03 <mauke> it looks like this here: http://tnx.nl/3976QBYX
18:12:08 <lispy> to make sure the list is long enough
18:12:14 <lispy> and i still get the error
18:12:37 <mauke> lambdabot seems to break lines on its own
18:12:43 <dons> oh, looks like lambdabot is expecting a 65 line screen.
18:12:47 <dons> but you've got 50 or so
18:13:13 <Trevion> I rather like todo item 1.
18:13:59 <dons> @code
18:14:01 <lambdabot> Ord.hs: Ord(..),
18:14:09 <dons> @code
18:14:11 <lambdabot> Foreign.hs: ( module Data.Bits
18:14:22 <dons> maybe I should add darcs to the @code search
18:14:36 <dons> and other projects.  hmm..
18:15:29 <dons> @code
18:15:31 <lambdabot> ReadP.hs: skipMany,   -- :: ReadP a -> ReadP ()
18:15:53 <dons> and maybe a couple of lines of context
18:17:18 <Igloo> OK, what's the /nicest/ way to write "apply foo n times to bar"?
18:17:58 <lispy> for (int i=0; i<n;i++) { foo(bar) }
18:18:00 <lispy> ;)
18:18:24 <Igloo> Mmm hmmm  :-)
18:18:33 <dons> we need a composeN
18:18:45 <Pseudonym> We have iterate and !!
18:18:48 <Trevion> yes.
18:19:03 <Pseudonym> @plugs iterate (\x -> x + sin x) 10 !! 10
18:19:09 <lambdabot> 9.42477796076938
18:19:12 <Pseudonym> Hmmm.
18:19:15 <Trevion> Pseudonym types too fast.
18:19:15 <Pseudonym> @plugs iterate (\x -> x + sin x) 1 !! 10
18:19:17 <lambdabot> 3.141592653589793
18:19:19 <Pseudonym> That's more like it.
18:20:24 <mikael> @plugs :t (!!)
18:20:25 <lambdabot> Variable not in scope: `t'
18:20:33 <mauke> @type (!!)
18:20:33 <Pseudonym> @type (!!)
18:20:38 <lambdabot> (!!) :: forall a. [a] -> Int -> a
18:20:38 <lambdabot> (!!) :: forall a. [a] -> Int -> a
18:20:41 * Pseudonym still types fast
18:21:05 <mikael> oh :-)
18:21:05 <Pseudonym> Mind you, I make a lot of misteaks becaues I tipe to fats.
18:21:36 <lispy> @plugs interate
18:21:37 <lambdabot> Variable not in scope: `interate'
18:21:40 <lispy> @type interate
18:21:42 <lambdabot> bzzt
18:21:44 <lispy> @type niterate
18:21:46 <lispy> gah
18:21:46 <lambdabot> bzzt
18:22:24 <lispy> ah, i get it
18:22:29 <lispy> that's kinda cool
18:23:17 <lispy> finally fonud it
18:23:21 <lispy> stupid head...
18:26:02 <lispy> yay, now i get (!!)
18:26:08 <lispy> :index too large ;)
18:34:19 <lispy> ah crap
18:34:42 <lispy> it's implemented, and it gives tours, but they're not knights tours
18:54:18 <Trevion> Does Keith Wansbrough ever hang out here?
20:21:12 <autrijus> hm when I do this
20:21:13 <autrijus> instance (Show a, Monoid a) => MonadWriter a IO where tell x = print x
20:21:21 <autrijus> GHC says
20:21:22 <autrijus>     Illegal instance declaration for `MonadWriter a IO'
20:21:22 <autrijus>         (the instance types do not agree with the functional dependencies of the class)
20:21:33 <autrijus> what is wrong with that definition?
20:25:56 <autrijus> :r
20:25:58 <autrijus> oops :)
20:35:00 <mikael> autrijus: I don't understand why -- because I don't really understand functional dependencies at all -- but MonadWriter w m is declared such that m must uniquely determine w.  I _think_ that means you can only have one MonadWriter x IO, but I'm probably wrong, so read http://www.cse.ogi.edu/~mpj/pubs/fundeps.html :-)
20:35:29 <mikael> (I normally wouldn't answer, being so profoundly confused myself, but it's early morning in Sweden, and as we all know, all Haskellers are Swedish)
20:35:52 <autrijus> right. I'm proud to be Swedish!
20:36:07 <autrijus> (although I don't know what it entitles really)
20:36:28 <autrijus> so there's only one MonadWriter x IO in my program
20:36:37 <autrijus> but seems I can't convey this fact to the fundep analyser
20:36:48 <autrijus> unless there's some way to denote unique types that I'm missing
20:49:56 <FrederikEaton> There should be monads that compile to efficient C-like buffer-filling code. You know, where you have a pointer and a length and you return number of bytes read or written like the UNIX interfaces to 'read' and 'write'.
20:52:28 <dons> hGetBuf ?
20:52:49 <dons> good idea though
21:24:40 <thou> would anyone using ghc with X11 & GLUT installed mind testing a program for me?
21:25:49 <thou> I have something that gives a bus error, and I've tried to isolate why but can't; i'm wondering if it's just my system, if i'm crazy, or what....
21:27:29 <lispy> thou: this sually means you're crazy
21:29:56 <thou> that's not very encouraging news
21:30:08 <lispy> oh...
21:30:17 <thou> :-)
21:30:17 <lispy> well, maybe it's just your system ;)
21:30:23 <reffie> new blog entry my friends!
21:30:24 <reffie> http://segfaulted.com/blog/
21:30:40 <lispy> thou: i'd test it, but i don't have time today or the stuff installed
21:31:50 <thou> lispy: ok, thanks anyways; no rush, i might ask again later
21:33:19 <thou> reffie: do you have a minute to test something on your freebsd box for me?
21:33:29 <reffie> thou i might
21:33:35 <thou> reffie: if you have ghc & GLUT...  http://www.magnesium.net/~thim/tmp/testglut.hs
21:34:01 <reffie> i don't have ghc right now :(
21:34:09 <reffie> i deleted all my ports
21:34:11 <thou> ah, ok, thanks anyways
21:34:15 <reffie> sorry :(
21:34:21 <thou> no problem
21:34:34 * lispy waits impatiently for his algo to finish running
21:35:04 <lispy> it's sooooooooooooooo slow
21:35:20 <lispy> nobody told me exhaustive search would be like this ;)
21:35:27 <reffie> you should read my blog, while you wait, lispy :P
21:35:49 <lispy> heh
21:36:55 <lispy> reffie: that's not in a form of english i understand ;)
21:37:06 <reffie> my english is bad? :(
21:37:19 <lispy> nah, just the level of kernel knowledge
21:37:29 <lispy> "IFS is basically FFS, minus the namespace."
21:37:32 <lispy> that's a good example ;)
21:37:56 <reffie> :(
21:38:02 <reffie> so maybe i sohuld maake it less technical
21:38:16 <lispy> i'm just saying, i'm not a kernel hacker ;)
21:38:39 <thou> FFS is a file system, like ext2, NTFS, etc.
21:39:04 <thou> the namespace just means a mapping of strings to inodes
21:39:08 <thou> right?
21:39:23 <thou> so if you take away that mapping, then you access the files not by name, but by number
21:39:49 <thou> if you do 'ls -i some_file', you'll see its inode number
21:39:58 <thou> dunno if i'm being annoying or helpful  :-/
21:49:13 <Trevion> thou: sorry to seem like a luddite, but are there practical applications for IFS?
21:49:42 <reffie> stuff like squid
21:50:03 <reffie> if you're talking to me :P
21:50:18 <reffie> thou: that's right
21:50:59 <reffie> thou: IFS completely removes the namespace operations.
21:51:04 <Trevion> oh, sorry...
21:51:16 <thou> :)
21:51:47 <thou> Trevion: ah wuz jes' interpretin' thu page ah red
21:54:02 <Trevion> haha, you're clearly better at interpreting pages of text than I am...
22:04:55 <thou> any FreeBSD users out there with GHC and GLUT installed?
22:05:21 <thou> or, s/FreeBSD/X11/
22:05:55 <thou> i'd prefer a FreeBSD tester, but i'm not picky at this point ... :-)
22:08:43 <thou> ok, off for now, see y'all later
23:47:16 <Trevion> Hmm.. anyone in the mood to help an FFI newbie?
