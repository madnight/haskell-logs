00:12:13 <blackdog> anyone round and hacking something cool? I need inspiration to start working again...
00:14:21 <basti_> hi all
00:14:22 <basti_> dons: *poke*
00:40:03 <wilx> blackdog, everybody's hacking with Arrows these days it would seem.
00:45:37 <mflux_> I do wonder if such abstractions which appear to be so difficult to grasp really can make programs easier to understand ;)
00:46:13 <mflux_> btw, are there neat tutorials for arrows around there? there are quite a few for monads..
00:47:44 <wilx> None that I know about.
00:48:29 <wilx> I followed links from www.haskell.org/arrows/
00:59:32 <dons> basti_!
00:59:58 <dons> blackdog, want to read my yi paper?
01:08:33 <blackdog> dons: Yeah, thta'd be cool. don't guarantee i'll bea ble to understand it, though: i've been hacking python, php and excel, and my brain is shrinking daily...
01:09:28 <blackdog> wilx: yah. i dont' really understand arrows yet. They're good for efficient parser combinators, right?
01:09:31 <dons> www.cse.unsw.edu.au/~dons/papers/SC05.html
01:09:54 <dons> blackdog, have you heard about my generalisation of arrows and spears to yoyos
01:09:57 <basti_> ah
01:10:05 <basti_> dons: yi seems to have a bug lately
01:10:12 <dons> providing rewindable computations..
01:10:14 <basti_> if you quit it, the terminal is "hung"
01:10:21 <dons> hung?
01:10:22 <basti_> needs reset then
01:10:26 <dons> oh, yes.
01:10:30 <dons> i've seen that on linux.
01:10:40 <dons> i'm looking into it right now in fact
01:10:41 <basti_> yes but its new, it didnt do that before
01:10:44 <basti_> oh great
01:10:45 <basti_> thanks a lot
01:10:48 <basti_> this is very annoying
01:11:17 <dons> yes, i'm not sure why it is happening yet. but hopefully I'll sort it out today
01:11:30 <basti_> :)
01:12:12 <blackdog> dons: you're kidding.
01:12:19 <blackdog> yoyos?
01:12:32 <dons> singleton yoyos: @
01:12:38 <dons> partial yoyos: -----@
01:12:51 <dons> and reversible yoyos: ------@ ----@ ---@ --@ -@ @
01:13:52 <dons> separate yoyos can be combined, to create knots of yoyos
01:14:14 <dons> however, computations can get stuck this way.
01:14:26 <blackdog> ... you're a deeply disturbing young man.  :)
01:14:38 <blackdog> so what does it mean to rewind a computation?
01:14:45 <dons> i need to work out a way to untie knots in yoyos, essentially.
01:14:59 <dons> needs more theoretical work, though
01:15:15 <wilx> O_O
01:16:10 <dons> computations can be wrapped in a yoyo, and then `spun' up and down.
01:17:26 <ski> but is it turing-complete ?
01:18:31 <dons> oh of course. any turing machine can be encoded as a yoyo with infinite string
01:20:24 <ski> so, it's related to knots and/or braids, then ?
01:23:26 <nothingmuch> is there a list function which does [a] -> [[a]], with each in it's own list?
01:24:04 <dons> @hoogle [a] -> [[a]]
01:24:06 <lambdabot> List.tails :: ([a] -> [[a]])
01:24:30 <dons> @google hoogle haskell
01:24:32 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/hoogle/
01:24:48 <nothingmuch> wow, what a wonderful bot
01:25:46 <dons> though I think you just want to map [] over the list, right/
01:26:10 <ski> @type map (:[])
01:26:12 <lambdabot> map (:[]) :: forall a. [a] -> [[a]]
01:26:35 <dons> @plugs map (:[]) "haskell"
01:26:36 <lambdabot> ["h","a","s","k","e","l","l"]
01:26:47 <nothingmuch> =)
01:26:55 <xerox> 'morning
01:28:02 <nothingmuch> morning xerox
01:41:28 <basti_> xerox: dons is chasing that bug. at least he said so.
01:41:59 <autrijus> yay I got 24 more hours for hw2005 :D
01:42:20 <autrijus> (having submitted a partial submission last night)
01:43:11 <dons> that's what I'm doing, yes, xerox, basti_
01:43:32 <basti_> dons: did you notice me saying that its a new bug and that it worked some time before?
01:44:32 <dons> yep.
01:44:37 <basti_> ok
01:44:45 <dons> i know it worked before, and that somehow it started in the last couple of weeks.
01:44:53 <dons> i think i've got it working now.
01:44:58 <dons> so hopefully that's solved
01:45:08 <dons> just need to do a little more testing.
01:45:12 <basti_> :)
01:53:53 <dons> hmm.. the call to UI.end seems to be miscompiled somehow. very weird
01:54:10 <xerox> How do you are debugging it?
01:54:46 <dons> just rearranging the code and seeing what results
01:55:28 <xerox> I had something to ask you about Yi... but I forgot it, hmpf.
01:55:40 <xerox> Maybe the breakfast will help remembering.
01:56:10 <dons> hehe
01:56:37 <dons> xerox and basti (in particular)- you might like to read the new yi paper
01:56:47 <dons> it covers the keymap edsl
01:58:33 <xerox> I downloaded it yesterday, what a coincidence :)
01:58:50 <basti_> edsl?
01:59:02 <dons> you downloaded it yesterday?! it was only finished in the last 20 hrs or so :}
01:59:19 <xerox> xpdf is opened from that time, let's see if I can see it.
01:59:42 <dons> basti, edsl = embedded domain specific language
01:59:51 <xerox> 31489 paolo     16   0 18368  15m 3760 S  0.0  3.0   0:04.57 xpdf.bin
02:00:26 <dons> hmm. NOINLINE on the call to endWin seems to fix it :/
02:00:27 <basti_> ah okay
02:01:01 * dons keeps testing
02:01:09 <basti_> :-o
02:01:20 <xerox> I maybe downloaded it _early_ this morning.
02:01:27 <dons> how did you find it?
02:01:35 <dons> or did I put a link up?
02:01:46 * dons can't remember
02:02:19 <xerox> http://www.cse.unsw.edu.au/~dons/yi.html "A paper describing the dynamic architecture implemented in Yi" -> http://www.cse.unsw.edu.au/~dons/papers/SC05.html
02:02:41 <dons> oh, *that* link
02:02:42 <dons> :D
02:03:07 <xerox> \o/
02:05:39 <autrijus> dons: thanks again for your hs-plugins.tex. it's really helpful.
02:06:33 <dons> autrijus, no worries
02:06:34 <autrijus> if people here has a spare moment, I'd be very grateful if you can review the style (and content) for my yesterday's hw2005 submission (linked from http://use.perl.org/~autrijus/journal/)
02:07:32 <wilx> Home work? :)
02:13:22 <dons> basti, xerox: can either of you try the latest patch to yi to see if the terminal problem is fixed/
02:13:27 <basti_> okay
02:13:35 <xerox> Sure.
02:18:37 * basti_ still didnt learn how to work with darcs properly
02:19:16 * basti_ gets a new yi
02:19:54 <xerox> I had to do the same...
02:19:58 <xerox> :\
02:20:04 <dons> darcs pull ?
02:20:15 <dons> or was there some problem with the repo?
02:20:45 <basti_> i was manipulating the same place you were to fix the bug, then had a conflict and apparently couldnt resolve it
02:20:49 <basti_> got linking errors then (???)
02:21:01 <xerox> dons, then I did "autoreconf; sh configure; make" and it didn't compile.  So I tried "make distclean; autoreconf; sh configure; make" and it didn't compile again.
02:21:18 <dons> ?
02:21:42 <dons> basti, have you been able to build it?
02:21:58 <dons> don't know what happening xerox. sounds strange
02:22:02 <basti_> no i got linking errors. i'm building anew now
02:22:32 <xerox> dons, what is the correct way to do it?
02:22:53 <dons> autoreconf ; ./configure ; make
02:23:03 <xerox> ooh-kay.
02:23:13 <dons> but sh configure shouldn't make any difference
02:23:33 <basti_> built now
02:23:34 <basti_> strange
02:23:44 <dons> maybe some old .o files left around
02:23:46 <basti_> the bug is gone
02:23:50 <basti_> great thing
02:23:57 <dons> great :)
02:24:20 <xerox> dons, is there any roadmap/plan for yi developement? (that's what I had to ask and I forgot)
02:24:39 <dons> there's a TODO file
02:24:44 <dons> and some Further Work in the yi paper
02:24:59 <xerox> OK great.
02:25:01 <dons> also, we have some ideas floating around here in sydney
02:25:19 <xerox> I was thinking about google's summer of code && yi.
02:25:20 <dons> maybe this should all go on the wiki at some point
02:25:33 <dons> xerox, really? that'd be fun. but hasn't google already closed?
02:25:47 <xerox> dons, there are still 2 days.
02:26:06 <dons> well, that would be cool to do, I think :)
02:26:19 <xerox> But without a mentor organization it will be hard.
02:26:32 <xerox> This reminds me of what shapr proposed some time ago.
02:26:59 <xerox> Some kind of organization mentoring Haskell, but I don't remind the details... I don't know if you do.
02:27:07 <dons> yeah, you'd have to do it though a university, I would have thought
02:27:50 <xerox> So, let's ask _you_ what are the biggest things to do in Yi :)
02:28:35 <dons> ok. syntax highlighting
02:28:48 <dons> wxHaskell and gtk2hs gui
02:29:01 <dons> embedded ghci interpreter
02:29:35 <dons> application framework, e.g. for running irc inside a yi buffer
02:29:51 <dons> a la the ion window manager
02:30:27 <dons> then there's lots of editing stuff.
02:30:39 <dons> like compiler support, refactoring tools
02:30:42 <dons> indenting
02:36:19 <xerox> OK, thank you.
02:36:58 <dons> there's also some things in the further work of the yi paper.
02:45:54 <lightstep> @hoogle Int -> (a -> a) -> (a -> a)
02:45:56 <lambdabot> Prelude.scaleFloat :: RealFloat a => (Int -> a -> a)
02:46:06 <lightstep> is there such a `church' function?
02:46:18 <lightstep> in the libraries?
02:46:41 <lightstep> or a Num (a -> a) instance with exponentiation?
02:47:00 <stefanw> I love it: ghc-6.4: panic! (the `impossible' happened, GHC version 6.4):
02:48:41 <dons> !
02:48:48 <autrijus> yeah, I run into it a lot.
02:48:51 <xerox> ยก
02:48:52 <autrijus> usually make clean solves that.
02:49:15 <lightstep> @ghc
02:49:16 <autrijus> GHC: We make hard things trivial, and impossible things just happen!
02:49:17 <lambdabot>  Try -fglasgow-exts for GHC's newtype-deriving extension
02:49:45 <dons> hehehe
02:54:42 <nothingmuch> how would I get Show functions?
02:55:57 <lightstep> you want the default ones?
02:56:03 <lightstep> you don't want to show a function, you can't (only buddha can)
02:57:19 <nothingmuch> i would be happy with a function being shown as it's type signature
02:59:14 <lightstep> it's hard not haskell, the language isn't suited for it
03:14:23 <stefanw> bug reported, more work for simonpj
03:16:37 <musasabi> nothingmuch: you can define "tshow :: Typeable a => a -> String" for showing a subset of functions.
03:20:47 <integral> @index >>^
03:20:56 <integral> @type >>^
03:21:09 <lambdabot> Control.Arrow
03:21:15 <lambdabot> bzzt
03:21:27 <xerox> @type (Control.Arrow.>>^)
03:21:29 <lambdabot> (Control.Arrow.>>^) :: forall d b (a :: * -> * -> *) c.
03:21:29 <lambdabot>         (Control.Arrow.Arrow a) =>
03:21:29 <lambdabot>         a b c -> (c -> d) -> a b d
03:21:33 <integral> thanks xerox
04:03:21 <dons> 
04:04:12 <xerox> ^? :)
04:50:50 <lightstep> we really need cdecl for haskell
04:52:32 <wilx> Cdecl?
04:53:15 <lightstep> a tool that translates C types and declaration to english and back
04:55:08 <musasabi> lightstep: no we don't really.
04:55:49 <musasabi> lightstep: we should just hang programmers who don't know when to use "type" or "newtype" to make their types readable.
04:59:02 <lightstep> let's take a look: <user1> what is (MonadState Env m => Compile (m Value))? <user2> @hdecl (MonadState Env m => Compile (m Value)) <bot> a computation that compiles to an action that returns a Value, where the computation is preformed in the presence of an Env state
05:00:08 <wilx> :)
05:00:42 <lightstep> the action, that is
05:01:08 <genneth> @seen boegel
05:01:09 <lambdabot> I saw boegel leaving #haskell 1 hour, 45 minutes and 54 seconds ago.
05:02:05 <musasabi> lightstep: I think the english explanation is harder to understand :-)
05:03:20 <musasabi> type CompileValueAction m = MonadState Env m => Compile (m Value)
05:03:33 <lightstep> but then they say `type T a = Either a (T a)' and it'll fail
05:04:06 <musasabi> Of course that might be nice for code that does not have explicit type signatures or is written with very generic types.
05:17:41 <lightstep> @index getArgs
05:17:42 <lambdabot> System.Environment
05:28:05 <lightstep> when using `ghc -e', how can i pass parameters to the program?
05:36:54 <lightstep> @plugs Text.ParserCombinators.PArrow.runParser (Text.ParserCombinators.PArrow.string "") ""
05:36:59 <lambdabot> Variable not in scope: `Text.ParserCombinators.PArrow.runParser'
05:37:41 <musasabi> lightstep: plugs does not have PArrows installed.
05:38:02 <lightstep> yeah
05:38:27 <lightstep> how do i uninstall a cabal package?
05:40:52 <xerox> lightstep, did you find how to do it?  I can't find it.
05:41:51 <lightstep> uninstalling?
05:42:06 <xerox> Passing options with ghc -e
05:42:11 <xerox> @type interact
05:42:17 <musasabi> lightstep: "runhaskell Setup.hs unregister" + rm.
05:42:21 <lambdabot> interact :: (String -> String) -> IO ()
05:43:36 <lightstep> xerox, it's unnecessary with runghc
05:43:54 <lightstep> i still don't know whether it's doable
05:46:19 <lightstep> although using runghc requires using Main.main
06:46:24 <foxy_> @pl  \f -> foldr (\x y -> f x : y) []
06:46:25 <lambdabot> flip foldr [] . ((:) .)
06:47:02 <foxy_> @pl (\x y -> f x : y)
06:47:02 <lambdabot> (:) . f
06:54:45 <foxy_> @index mao
06:54:46 <lambdabot> bzzt
06:54:47 <foxy_> @index map
06:54:48 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
07:21:19 <nothingmuch> @t unsafePerformIO
07:21:20 <lambdabot> Maybe you meant: timein todo todo-add todo-delete topic-cons topic-
07:21:20 <lambdabot> init topic-snoc topic-tail topic-tell type pl wn
07:21:32 <nothingmuch> @type unsafePerformIO
07:21:36 <nothingmuch> i wonder when I'll ditch that habit
07:21:37 <lambdabot> bzzt
07:21:50 <nothingmuch> @index unsafePerformIO
07:21:52 <lambdabot> System.IO.Unsafe, Foreign
07:30:03 * xerox grumbles
07:31:23 * astrolabe wonders why xerox grumbles
07:32:14 <xerox> I just killed my laptop with a bash online function calculating factorial recursively.  Grrr.
07:35:16 <roconnor> Hey, is anyone else going to ``What the Hack'' this year? ... or does anyone even know what I am talking about?
07:35:44 <xerox> roconnor, it would be great fun do go there :-)
07:35:54 <xerox> s/do/to/
07:36:16 <roconnor> I was a CCC in '99,  It was nice.
07:36:30 <roconnor> s/ a / at /
07:36:47 <xerox> pirroH, are we going to go? ;)
07:37:08 <pirroH> xerox: I hope so!
07:38:03 <roconnor> There ought to be a lamba tent ;-)
07:42:18 <camior> I am working an a computer that doesn't have the concept of division and multiplication and I'm trying to do some division. Dividing by a power of 2 is easy, just right shift. Does anyone know of a trick to divide by (a power of 2)-1?
07:44:17 <monochrom> and if there is a trick, will your next question be "what about (power of 2)-2", ad infinitum?
07:44:21 <wilx> Huh, get better machine :D
07:44:30 <camior> monochrom, nope
07:44:44 <roconnor> are you trying to divide by 255?
07:44:48 <camior> wilx: Too expensive.
07:45:00 <camior> roconnor: 0xFFFF actually.
07:45:19 <astrolabe> are you just interested in the whole number part?
07:45:22 <roconnor> do you need the exact answer, or will an approximation due?
07:45:35 <camior> exact
07:45:46 <camior> I need to invert this function:
07:45:53 <camior> stepsToSmidgens :: Double -> Word16
07:45:53 <camior> stepsToSmidgens steps = truncate (steps * 0xFFFF)
07:46:27 <camior> I'm sorry, an approximation _will_ do.
07:46:34 <roconnor> oh
07:46:44 <camior> As in, I don't care about what comes after the decimal point.
07:47:23 <roconnor> Well, Blinn had an algorithm in computer graphics for approximating division by 255 using integer math and shifts.
07:47:38 <roconnor> It gives the correct answer for all by 2 or 3 cases, when it is off by one.
07:47:45 <roconnor> s/by/but/
07:47:57 <roconnor> perhaps it could be adapted for your case.
07:48:12 <camior> roconnor: Thank's I'll check it out.
07:49:50 <astrolabe> m/x = a + (m-ax)/x
07:50:14 <astrolabe> for x = 2^n, take a = m/(2^n -1)
07:51:15 <astrolabe> oops, I mean for x = 2^ -1, take a = m/2^n
07:51:52 <astrolabe> Arrrh! x = 2^n -1, a = m/2^n
07:52:12 * xerox pats astrolabe
07:52:43 * astrolabe needs a parser on my chat input
07:53:02 <xerox> Parse error.  <grin>
07:53:41 <camior> astrolabe: Thanks, give me a minute to fully understand what you're doing here.
08:05:54 <boegel> yo everyone
08:05:58 <boegel> genneth: you rang ?
08:06:06 <astrolabe> hi boegel
08:06:08 <camior> astrolabe: Could you throw me a hint, I don't see a way to reduce this to where I don't need the (m-ax)/x division
08:06:43 <astrolabe> You do, but m-ax should be much less than m normally, so use recursion.
08:06:46 <camior> s/don't need the/don't do a.
08:07:49 <boegel> @seen genneth
08:07:50 <astrolabe> You need an initial check to deal seperately with the case m<=x
08:07:51 <lambdabot> genneth is in #haskell. Last spoke 3 hours, 6 minutes and 41 seconds
08:07:51 <lambdabot> ago.
08:07:59 <boegel> hmm, probbly not active anymore
08:09:00 <astrolabe> But I don't know what you want to do with the 'remainder' part, so I don't know what that case should be.
08:12:53 <camior> astrolabe: I'll ponder it. Thanks for the help.
08:15:58 * boegel leaves again
08:21:20 <xerox> Why I can't do "type Coord = Integral a => (a,a); type CoordTuple = (Coord,Coord)" ?  GHC says: "Illegal polymorphic or qualified type: forall a. (Integral a) => (a, a) In the type synonym declaration for `CoordTuple'"
08:22:02 <integral> maybe you mean: type Coord a = Integral a => (a, a) ? (I think I mean this...)
08:23:36 <Lemmih> More likely: type Coord a = (a,a)
08:23:36 <xerox> integral, hmm I think not.
08:24:47 <xerox> Putting 'a's I get the same error.
08:25:44 <xerox> Ah! I think I got it.
08:26:46 <xerox> ...and what for "type World = [Coord]" ?
08:27:27 <Lemmih> type World a = [Coord a]
08:28:01 <xerox> I can't, because it's a type synonym, I think.
08:28:18 <xerox> Kind error: `Coord' is applied to too many type arguments
08:29:09 <Lemmih> Works fine for me.
08:29:23 <Lemmih> Did you write: type Coord a = (a,a)
08:29:39 <xerox> type Coord a = (Integral a) => (a,a)
08:29:48 <_segv__> Hi
08:30:02 <xerox> Hi _segv__
08:30:10 <Lemmih> You really don't want that context there.
08:30:38 <xerox> I'd better use Integer  everywhere...
08:30:49 <xerox> Are they much slower than Ints ?
08:30:53 <Lemmih> Just use 'a'.
08:31:12 <Lemmih> And then do: someFunc :: (Integral a) => World a -> World a
08:31:15 <_segv__> can someone help me with poting ghc
08:31:49 <xerox> Lemmih, uhm, okay.
08:32:33 <xerox> bounds :: Integral a => World a -> CoordTuple (Coord a)
08:32:43 <xerox> Way much verbose :)
08:33:19 <xerox> Lemmih, does it make sense to use that constraint instead of Integers everywhere?  I mean, there will be any kind of optimization this way?
08:35:12 <Lemmih> If Integers are good enough then use them.
08:35:48 <xerox> I don't know.
08:39:59 <_segv__> I have just a simple question
08:40:07 <_segv__> can someone help me?
08:40:19 <Lemmih> Sure.
08:40:34 <Lemmih> Just ask the question and we'll see.
08:40:59 <_segv__> i'd like to port ghc to solaris x86 since a week and I'am just not able to get all hc-files
08:41:04 <ski> <_segv__> can someone help me with poting ghc
08:42:20 <_segv__> when starting to compile the created hc-files with 'make hc-file-bundle' the make system stops at Array.o
08:45:40 <_segv__> anybody?
08:46:48 <ski> (i haven't compiled ghc .. though .. what error does it say ?)
08:48:19 <_segv__> i can not give you  the message, since I am not at the System,...
08:48:49 <_segv__> but i figured that some of the *.hc files are missing
08:49:13 <ski> mhm
08:49:32 <_segv__> so the problem seems to be, not all *.hc files are generated by the compile step
08:50:06 <ski> _segv__ : sorry, i don't think i can help you. though i think there are people frequenting this channel who prolly can, though they seem to be busy/away/not joined at the moment :(
08:50:28 <ski> _segv__ : maybe try a little later ?
08:58:32 <_segv___> mist
08:59:19 <_segv___> did anybody answered my question?
09:06:35 <Igloo> _segv___: No-one is likely to be able to help you much when you can't get to the computer in question
09:46:16 * xerox just made his first slider have a complete cycle in his Conway's Life Haskell implementation  --  fun fun fun.
09:47:08 <basti_> congratulations
09:48:31 <xerox> http://segfaulted.com/~xerox/stuff/first-slider.text
09:49:02 <basti_> :)
09:49:05 <xerox> ^_^
09:49:34 <basti_> badTick?
09:49:51 <xerox> Yeah, I think I could have done it with a better algorithm.  I'll try.
09:50:05 <basti_> *g+
09:54:47 <xerox> I wonder what could I use to make a GUI for this.  Gtk2hs?  wxHaskell?
09:55:41 <roconnor> I believe it is called a glider.
09:55:50 <xerox> I think you're right.
09:56:31 <xerox> ...and this means I have to login and change the name, hmpf.
09:57:11 <xerox> done.
09:57:12 <astrolabe> Cool xerox.  Will you do an animation?
09:57:25 <astrolabe> wow that was quick ;)
09:57:26 <xerox> astrolabe, yea!
09:59:10 <astrolabe> How do represent an array in haskell?  A vector of vectors?
09:59:45 <astrolabe> (I mean a 2d array)
10:00:39 <xerox> The nice thing is that the world doesn't have bounds :-)
10:01:10 <xerox> ...because I only keep the live cell's Coords in a list (a Set in future), yay!
10:01:43 <xerox> Now I need some water.
10:02:24 <xerox> (Anyway, according to <http://www.math.com/students/wonders/life/life.html>, the world should not have bounds.  The "vector of vectors" solutions seems impraticable to me.)
10:04:14 <astrolabe> Which cells do you test for new life?
10:05:04 * astrolabe suspects that most non-haskell implementations use a finite world.
10:06:00 <arjanb> wouldn't a circular world work too?
10:06:31 <astrolabe> If you mean a torus or something, then yes, but it would be finite.
10:06:34 <xerox> arjanb, it would.
10:08:24 <xerox> astrolabe, I check 1 cell radius far from living cells.
10:09:06 <xerox> And, as now, I check *every* cell, that's why I called it "badTick".
10:10:35 <astrolabe> Every cell on an infinite board?  I think I must be missing something.
10:11:57 <xerox> Given the bounds of the living part of the world I'm checking every cell in that zone, with an external 1 cell radius.
10:12:20 <xerox> Is that understandable?
10:12:34 <astrolabe> Ah right.  I think I'm getting there.  Thanks.
10:12:48 <xerox> But I think there are better solutions, I'm thinking about one at the moment.
10:13:43 <xerox> i.e. it's silly to check everything between (-999,-999) and (999,999) if there are only 2 living cells in the whole world at those coors.
10:14:16 <astrolabe> True.  For sparce worlds, there must be something better.
10:14:24 <roconnor> all you need to do is enumerate all the cells within one of a living cell.
10:15:18 <xerox> I'm going to enumerate all the possible living cells in the next unit of time, `uniq` the list and then check.  Sounds reasonable?
10:15:33 <xerox> I have to think harder to find a way to not have to `uniq` the list.
10:16:46 <astrolabe> and then for each potential living cell, go through the list of current living cells counting neighbours?
10:16:58 <xerox> astrolabe, exactly.
10:17:38 <xerox> My mind is telling me "you know it's doable with a single fold hackery", but I have to concentrate to do that alchemy :)
10:17:57 <astrolabe> It does sound reasonable.  I think to get anything faster, you'd need something complecated like ball-trees.
10:18:14 <xerox> Ball-trees?
10:19:08 <astrolabe> They are a way of doing fast searches for close neighbours in sets of points in a metric space.  Sort of like binary trees help you search in a linear space.
10:20:04 <xerox> Interesting.  Now mine looks like a toy-implementation, heh. ;)
10:21:30 <astrolabe> Yours sounds enough to do a good job to me.
10:21:41 <xerox> Thank you :-)
10:22:01 <ski> Ball-trees similar to quad-trees ?
10:23:01 <astrolabe> Not quite, if I remember what quad trees are :)
10:24:36 <astrolabe> Oh no.  I didn't remember.  Yeah, a bit like quad trees.
10:26:57 <ski> ok
10:27:58 <roconnor> can't you just place all the cells in a Set like you were saying before?
10:28:30 <xerox> roconnor, yes.. why?
10:29:11 <roconnor> set will remove duplicates
10:30:02 <xerox> roconnor, yes, exactly: as in (toList.fromList), that happens to be quite fast too.  (if Cale remember... :))
10:30:30 <astrolabe> Maybe a bag is what you really want
10:30:46 <roconnor> bag?
10:30:59 <monochrom> bag = multiset
10:31:09 <monochrom> I prefer "bag" because it is shorter.
10:31:13 <xerox> Please elaborate :)
10:31:17 <fraxtal> I just saw a haskell data structures library that included bags
10:31:25 <xerox> fraxtal, any url?
10:31:28 <astrolabe> It keeps count of how many of each element.
10:31:32 <fraxtal> It was on haskell.org
10:31:46 <roconnor> a multiset?
10:31:52 <xerox> Gee, it's like saying "you can find it via google", heh :-)
10:32:09 <monochrom> you can find it via google
10:32:13 <fraxtal> Well, I was just letting you know that such a library exists
10:32:19 <xerox> fraxtal, thanks much :)
10:32:22 <musasabi> [(Key,Value)] is a bag most of the time.
10:32:24 <fraxtal> np
10:32:42 <xerox> But what Values do you think I should keep?  Aren't Coords enough?
10:32:46 <xerox> Oh.. neigbours?
10:32:52 <xerox> err, neighbours
10:32:59 <roconnor> In any case, we want to remove duplicates, not keep track of how many dupicates there are.
10:33:18 <astrolabe> values are the number of each kind of element in the bag
10:33:19 <musasabi> well then you want a set/map.
10:33:23 <monochrom> that's set
10:33:37 <astrolabe> No, you don't want to remove duplicates.
10:33:45 <xerox> astrolabe, why?
10:34:12 <astrolabe> The rule for life is that the point should have some number of neighbours
10:34:16 <xerox> "you want a better algorithm" ?
10:34:51 <astrolabe> If that number was 1 only, then you would remove duplicates, and the things they duplicated.
10:35:11 <astrolabe> Yes, a better algorithm I think.
10:35:14 <roconnor> set is a monad-plus right?
10:35:15 <xerox> astrolabe, I know.  The duplicates I'm talking about are the ones created by |concatMap (1-cell-radius) point|
10:35:24 <xerox> s/point/world/
10:36:25 <xerox> where 1-cell-radius :: Point -> [Point]
10:36:50 <roconnor> so we get a set of neighbours by cell >>= neighbours where neighbours (x,y) = return (x-1,y) `mplus` return (x,y-1)  `mplus` return (x+1,y)  `mplus` return (x,y+1)
10:37:28 <roconnor> @info Data.Set
10:37:29 <lambdabot> Unknown command, try @listcommands.
10:38:15 <xerox> @index mplus
10:38:17 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
10:38:17 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
10:38:17 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
10:38:52 <astrolabe> exuse me guys.  I'm off for a walk.
10:39:13 <xerox> astrolabe, enjoy! :)
10:39:42 <roconnor> bah
10:39:53 <roconnor> okay, step 1, make Set into a monad-plus
10:39:53 <xerox> roconnor, don't you think list comprehension would be nicer than bind?
10:40:05 <roconnor> sure
10:40:06 <xerox> Oops, I got it now.
10:40:14 <roconnor> well, maybe
10:41:04 <roconnor> I hope I'm not crazy in saying that Set is a Monad-plus
10:41:16 <xerox> Keep in mind that diagonal-touching cells count as neighbours.
10:41:42 <Heffalump> roconnor: it isn't even a Monad
10:41:47 <Heffalump> cos of the Eq constraint
10:41:58 <roconnor> eq constraint?
10:41:58 <xerox> neighbours w (x,y) = length [(x',y') | y' <- [y+1,y,y-1], x' <- [x-1,x,x+1], (x',y') `elem` w, not (x' == x && y' == y)]
10:42:56 <Heffalump> roconnor: what's the type of an empty set?
10:43:03 <Heffalump> and of a singleton set
10:44:05 <Cale> roconnor: The powerset functor in mathematics does give a monad though.
10:44:14 <roconnor> type of an empty set is polymorphic Set A.
10:44:26 <roconnor> type of a singleton set is Set A where A is the type of the element.
10:44:30 <Heffalump> how polymorphic? Any constraints on A?
10:44:38 <Cale> but Set can't be part of the monad class in Haskell, because it places a constraint on its type parameter
10:44:51 <roconnor> ah
10:44:53 <xerox> @info Set
10:44:54 <lambdabot> Unknown command, try @listcommands.
10:44:55 <Cale> I was rather irritated by this :)
10:45:05 <SamB> since when is A a type variable?
10:45:06 <Cale> It's an obvious monad
10:45:09 <roconnor> :'(
10:45:53 <SamB> Cale: sure it can! just put the right context on the instance declaration...
10:46:34 <Cale> SamB: Look at the class definition of Monad though...
10:46:36 <roconnor> okay, so you will have to use the Set operations directly.  No big deal I guess.
10:47:04 <Cale> class Monad m where ...
10:47:28 <Cale> which means you don't get to make any restrictions in instance declarations
10:47:43 <SamB> Cale: I'm trying it anyway.
10:47:50 <SamB> maybe that was an extension or something...
10:47:53 <boegel> genneth: you there ?
10:48:09 <xerox> The `|' in instance declaration maybe could do the trick
10:48:44 <SamB> xerox: I don't think | is allowed in instance declarations...
10:48:59 <SamB> certainly not in Haskll 98
10:49:54 <xerox> I don't recall how are they called...
10:50:07 <monochrom> functional dependency
10:50:46 <Cale> and they occur in class declarations afaik
10:50:51 <xerox> Functional dependencies!
10:50:56 <xerox> Oh, yes :)
10:51:17 <Cale> class VectorSpace f v | v -> f where...
10:51:23 <xerox> Hmm, you're right, I'm confused.
10:52:36 <SamB> and so they would be useless, because we are certainly not free to change Monad...
10:53:52 <Cale> I'd like to see the Simons come up with something to deal with this sort of problem :)
10:54:31 <Cale> I seem to recall there were some problems with the obvious solution and the module system
10:55:01 <xerox> SamB, did your try work ? :)
10:55:51 <SamB> xerox: oh, right, I'm just playing with the typesystem, no need to make this the best implementation of >>= on Set ever...
10:57:19 <TheHunter> @google "rebindable syntax" ghc
10:57:22 <lambdabot> http://www.mail-archive.com/glasgow-haskell-bugs@haskell.org/
10:57:22 <lambdabot> msg07177.html
10:57:43 <SamB> okay, NOW I see the problem.
10:57:43 * boegel leaves again
10:57:58 <SamB> There is not type variable to constrain at the instance head...
10:58:11 <xerox> @google "rebindable syntax" ghc site:http://www.haskell.org
10:58:13 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-
10:58:13 <lambdabot> features.html
10:58:17 <SamB> s/not//
10:58:25 <SamB> er, s/not/no/
10:59:40 <SamB> @help fact
10:59:41 <lambdabot>  @fact <fact>, Retrieve a fact from the database
10:59:51 <SamB> @listmodules
10:59:52 <lambdabot> babel base code dice dict dummy dynamic fact haddock help hoogle
10:59:52 <lambdabot> karma lambda more pl plugs quote search seen spell state system todo
10:59:52 <lambdabot> topic type version vixen
11:00:10 <SamB> @listcommands fact
11:00:11 <lambdabot> fact provides: fact fact-set fact-delete fact-cons fact-snoc fact-
11:00:11 <lambdabot> update
11:00:22 <SamB> @fact glasgow-exts
11:00:22 <lambdabot> I know nothing about glasgow-exts.
11:00:42 <SamB> @fact-set glasgow-exts http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
11:00:43 <lambdabot> Fact recorded.
11:00:48 <SamB> @fact glasgow-exts
11:00:49 <lambdabot> glasgow-exts: http://www.haskell.org/ghc/docs/latest/html/users_
11:00:49 <lambdabot> guide/ghc-language-features.html.
11:01:25 <jlouis> SamB: oh, people actually use that ;)
11:01:30 <jlouis> I pondered
11:01:36 <SamB> um, probably not, actually.
11:01:47 <SamB> well, I don't think I've seen anyone else do it.
11:02:08 <SamB> but it seemed like it was a better idea than implementing a command just for that ;-)
11:02:12 <TheHunter> @listmodules fact
11:02:13 <lambdabot> babel base code dice dict dummy dynamic fact haddock help hoogle
11:02:13 <lambdabot> karma lambda more pl plugs quote search seen spell state system todo
11:02:13 <lambdabot> topic type version vixen
11:02:22 <TheHunter> @listcommands fact
11:02:23 <lambdabot> fact provides: fact fact-set fact-delete fact-cons fact-snoc fact-
11:02:23 <lambdabot> update
11:03:01 <TheHunter> hmm, @fact-search and/or @fact-list might be useful
11:03:14 <xerox> @help fact-snoc
11:03:15 <lambdabot> snoc information to fact
11:03:32 <SamB> xerox: don't you know what snoc means?
11:03:51 <SamB> it is cons, only backwards!
11:03:56 <xerox> Oh :)
11:04:10 <xerox> Now @topic-snoc makes sense too :)
11:23:14 <Oejet> Java doesn't like my way of thinking.  Haskell does.
11:26:10 <jynxzero> Hi... This seems to work fine in GHC, but fails with arithmetic overflow in hugs:
11:26:14 <jynxzero> (randomR (0.0,10.0) (mkStdGen 0) :: (Float,StdGen))
11:26:33 <jynxzero> Is this just a bug in hugs, or do I need to do something else to get the desired behavior?
11:32:21 <Lemmih> jynxzero: Works fine for me in both Hugs and GHCi.
11:32:44 <jynxzero> :(  What version of hugs?
11:33:01 <Lemmih> November 2003.
11:33:26 <jynxzero> Mmm, same as here.
11:34:04 * jynxzero goes to install hugs on another machine
11:34:09 <Lemmih> Does that exact line you pasted throw the error?
11:34:14 <jynxzero> Yep
11:34:27 <jynxzero> RandomVar> (randomR (0.0,10.0) (mkStdGen 0) :: (Float,StdGen))
11:34:27 <jynxzero> (
11:34:27 <jynxzero> Program error: arithmetic overflow
11:35:07 <Lemmih> System.Random> (randomR (0.0,10.0) (mkStdGen 0) :: (Float,StdGen))
11:35:08 <Lemmih> (9.87277,1601120196 1655838864)
11:36:35 <Lemmih> What's in RandomVar?
11:37:49 <jynxzero> Just tried it without RandomVar and the result is the same, but...
11:38:08 <jynxzero> Installed hugs on another machine and it doesn't error.
11:38:53 <jynxzero> Only difference between them, apart from slightly different versions of Debian is that the buggy one is amd64.
11:39:06 <jynxzero> Maybe related?
11:39:11 <Lemmih> Probably.
11:40:53 <Lemmih> Try installing a new version, and if it also exhibits the error you can file a bug report.
11:42:17 <jynxzero> Will do.  Ta muchly.
12:11:47 <Lemmih> Greetings, conal.
12:12:29 <conal> Hi Lemmih
12:30:04 <basti_> haskell is the #1 language.
12:32:51 <sr_> Hello. I'm a bit confused about the use of the Network.CGI library. I already found the information about those modules needing documentation, but a little example would be just enough to start with (I'm not far enough into haskell to realise how the module should be used just by looking at the source of it... :/ )
12:33:16 <basti_> hmm
12:33:47 <basti_> best get an example huh?
12:34:03 <sr_> I found something, but it included "TextPlain" and stuff like that which can't be grep'ped out of CGI.hs so i bet it was an example of another version of Network.CGI...
12:34:13 <basti_> hmm
12:34:13 <basti_> -.-
12:34:52 <sr_> that's it. i'm gonna have to find an example. that's what i'm failing at completely at the moment ...
12:35:07 <basti_> judging from the types its pretty simple:
12:35:16 <basti_> wrapper :: ([(String, String)] -> IO Html) -> IO ()
12:36:04 <basti_> takes an argument, that takes a list of String-String pairs (names and values) and results in an IO action that delivers Html, and results in some IO action
12:36:20 <sr_> [(String, String)] is the "env" coming from CGI, right?
12:36:26 <basti_> yes
12:36:38 <sr_> but how do i produce the IO Html? Oh wait...
12:36:47 <sr_> i can find out what produces that by looking at the other types.
12:36:48 <basti_> do you know about that strange IO think? :)
12:36:55 <basti_> thing
12:37:42 <sr_> IO () is the main-must-end-in-that-thing which means it outputs something. =)
12:37:51 <basti_> exactly.
12:37:58 <basti_> well not exactly.
12:38:12 <basti_> it means, the result of the function depends on "IO stuff"
12:38:32 <basti_> that can also mean that the function outputs things IO wise
12:38:53 <sr_> so inside wrapper i use some html-specific functions whose "response values" (eek, wrong word; i meant the y of y=f(x) ) are of the type IO Html... which wrapper ... uhm... re-builds somehow
12:39:22 <basti_> "result"
12:39:30 <sr_> alright, sure. thanks.
12:39:32 <basti_> yes it will be rebuilt
12:39:37 <basti_> to a CGI i'd think
12:39:56 <basti_> a thing that waits for IO, which the wrapper unwraps, pushes into your function, which then results some html, which is output
12:40:16 <basti_> global result: nothing but IO (or: the unit, alias "()")
12:42:35 <sr_> hmm... but "IO Html" is something different than what "print" produces, isnt it? I cant find any functions that result in "IO Html", so i could use them as the "argument function" of wrapper...
12:42:43 <basti_> yes of course
12:42:46 <basti_> print delivers no result
12:42:57 <basti_> what value does the call putStr
12:43:00 <basti_> whops
12:43:06 <basti_> putStr "hello" have?
12:43:21 <sr_> isn't "IO ()" the result of print? *confused*
12:43:25 <basti_> none of value, so the type is:
12:43:28 <basti_> @type print
12:43:35 <lambdabot> print :: forall a. (Show a) => a -> IO ()
12:43:48 <basti_> yes but who said you'd output things yourself?
12:43:57 <basti_> youre supposed to produce html
12:44:20 <sr_> i probably don't 'cause wrapper does it. all i need to find out is how to produce the html-data-stuff that wrapper puts out
12:44:28 <basti_> the rather mundane task of feeding that into some pipe that'll deliver it at someone's webbrowser is obviously left to the wrapper
12:44:34 <basti_> well first it needs to be html values
12:44:39 <basti_> *Html
12:45:18 <basti_> then it has to be inside that funny IO thing, but if you don't already have that then you can just say "do return <yourHtmlValue>"
12:45:49 <basti_> i assume the IO would be good for, well, doing some IO, which you might be interested in inside a CGI
12:46:20 <sr_> aah! so "do return <foo>" is the trick!
12:46:23 <basti_> a CGI non dependant on other IO than user input can maximally be funny
12:46:47 <basti_> its a trick for faking IO dependency yes
12:47:36 <basti_> but beware: you're expected to produce a Html value, not to output html yourself, like in some other bizarre environments
12:47:38 <sr_> well, the other IO I need is some SQL Query stuff, but i'd just start with the funny things to find out how it works
12:47:51 <sr_> => no print, just return
12:47:52 <basti_> wise.
12:48:06 <basti_> phone
12:48:09 <sr_> thanks for your hints :)
12:52:05 <_segv__> Hi
12:52:39 <roconnor> why so many underscores in people's names?
12:52:43 <_segv__> can someone help me answering my questions about porting ghc?
12:53:26 <_segv__> roconnor: i wanted to be sure that my name is unique
12:58:55 <_segv__> is there a better place to ask my questions? When where?
13:05:45 <sr_> yay, I got the first page rendered ;)
13:07:18 <TheHunter> _segv__, the glasgow-haskell-users mailing list.
13:08:25 <_segv__> TheHunter: thanks, so no other channel. :-(
13:08:27 <kimbly> [15:12] Don: kim .. do you happen to have winbuild-nulls.setup.log open in an editor?
13:08:27 <kimbly> [15:12] KimBurchettAim: no
13:08:37 <_segv__> by
13:08:40 <kimbly> oops.  excluse me :)
13:08:45 <kimbly> excuse me, I mean
13:11:38 <xerox> @pl \x -> abs (x - n)
13:11:40 <lambdabot> abs . subtract n
13:13:23 <kzm> pl for poinless? :-)
13:13:47 <xerox> @help pl
13:13:48 <lambdabot>  @pointless <expr> - play with pointfree code
13:13:57 <xerox> @botsnack
13:13:57 * kzm smiles.
13:13:58 <lambdabot> :)
13:21:33 <basti_> back
13:21:55 <basti_> sr_: congratulations
13:23:13 <sr_> i finally realised "import Text.Html" might not be a bad idea.
13:23:48 <basti_> oh. yes.
13:24:04 <sr_> :)
13:24:10 <sr_> got to go, bye..
13:24:14 <basti_> cu
13:24:17 <xerox> bye!
13:50:47 * xerox 's head is hurting
13:54:23 <Oejet> xerox: Them arrows again?
13:54:24 <basti_> because of haskell?
13:56:19 <xerox> Oejet, exactly.
13:56:31 <xerox> neighbours (x,y) = List.filter (onecellfar) . Set.toList
13:56:31 <xerox>     where onecellfar = (subtract x) *** (subtract y) >>>
13:56:31 <xerox>                        (((==0) &&& (==1)) *** ((==0) &&& (==1))) >>>
13:56:31 <xerox>                        (uncurry (||)) *** (uncurry (||)) >>>
13:56:31 <xerox>                        uncurry (&&)
13:56:38 <xerox> I have this O_o
13:57:23 * Oejet quickly looks away as he feels the blood filling up his brain.
13:57:55 * Oejet would like to see the corresponding Java program. :-P
13:59:38 <xerox> ahah
13:59:46 <Oejet> (4,7) ==>  (subtract x) *** (subtract y) >>>   (3,6), right?
14:00:03 <xerox> Yep
14:00:26 <xerox> In fact the job is rather simple, I don't know why I caame up with this.
14:01:33 <xerox> I just want to check if given (x,y) and (x',y') then 0 <= x-x' <= 1 && 0 <= y-y' <= 1 applies...
14:01:59 <Oejet> (3,6) ==> (((==0) &&& (==1)) *** ((==0) &&& (==1))) >>>  ?
14:02:23 <Oejet> (3,6) ==> ((==0) &&& (==1)) >>> ?
14:03:02 * Oejet read some arrows papers but doesn't remember many of the operators.
14:03:37 <xerox> It's like trying (==0) || (==1) to both x and y in (x,y)
14:03:50 <basti_> touch-my-monads?
14:04:04 * xerox falls
14:07:24 <xerox> ah-ha!!!
14:07:37 <xerox> I think I did it.
14:07:53 <xerox> Added ">>> abs" after both subtracts.
14:09:04 <wilx> Hmm.
14:09:23 <wilx> It would be nice to have a program that would generate those boxes representations of arrows :)
14:10:06 <SamB> how do you pronounce >>>?
14:10:12 <xerox> bzzt
14:10:40 <wilx> >>> imho just connects one arrow to another.
14:10:56 <xerox> (>>>) = flip (.)
14:11:04 <xerox> So, yes, wilx.
14:11:24 <xerox> I'm looking forward to shapr's illuminating example on tmrwiki... :\
14:11:28 * SamB remembers about the {-# RULE #-}s in Control.Arrow's source...
14:11:39 <xerox> @libsrc Control.Arrow
14:11:41 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Control/Arrow.hs
14:11:43 * SamB sees that they call >>> "compose"
14:13:48 <xerox> SamB, what is a {-# RULE #-} block?
14:13:58 <roconnor> do arrows solve the commutative monad problem?
14:14:15 <SamB> @google site:haskell.org ghc docs latest pragmas
14:14:17 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/
14:14:22 <TheHunter> "reverse composition" would probably more accurate.
14:14:25 <SamB> @google site:haskell.org ghc pragmas
14:14:26 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.
14:14:26 <lambdabot> html
14:14:33 * Oejet ponders the definitions: arr = pure,  pure = arr 
14:14:38 <SamB> TheHunter: not really.
14:14:57 <SamB> I mean, sure it comes out opposite (.)
14:14:59 <TheHunter> <<< is composition.
14:15:19 <SamB> but it is the primitive composition combinator for arrows...
14:16:10 <TheHunter> the name 'Arrows' is already enough a cause of confusion.
14:16:41 <basti_> should they be named Kflvpo?
14:16:46 <roconnor> maybe they should be called ``morphisms''
14:17:15 <TheHunter> i don't know, i'm not good at choosing names.
14:17:17 <Oejet> roconnor: Yeah, like monads should be called mondads.  Very intuitive.
14:17:44 <basti_> monads should be called pink fuzzy warm things
14:17:49 <SamB> I wonder what the class name would be if they had been called "warm fuzzy things"
14:17:58 <TheHunter> roconnor, that'd be just as confusing as 'arrows', because it doesn't reflect that they are only morphisms/arrows in a specific category.
14:17:59 <basti_> PWFT
14:18:06 <roconnor> monads are obious.  They are half moniod and half triad.
14:18:09 <xerox> class PWFT m ...
14:18:45 <SamB> TheHunter: you are being silly! but not as silly as shapr, with that thing about spears...
14:18:48 <basti_> people would only think we're insane if we told them what PWFT actually means
14:19:05 <wilx> Well, I must say I still don't see the advantage over monads. I would really like to see some example where arrows are somehow better than monads.
14:19:19 <SamB> basti_: there is no point in calling it a "warm fuzzy thing" if you don't tell people that it is called that!
14:19:29 <TheHunter> SamB, why exactly am I being silly?
14:19:33 <basti_> maybe the class name should reflect that
14:19:43 <basti_> but PinkWarmFuzzyThing would look silly
14:19:51 <SamB> TheHunter: quibling about names so much!
14:20:06 <TheHunter> it has confused me, and i'm pretty sure it has confused other people, too.
14:20:21 <SamB> probably only people who know a lot of category theory!
14:20:44 <basti_> i sometimes give geographical names to things i dont find an intuitive name for
14:21:26 <basti_> finding "Tokyo" in a sourcecode confuses only as much as an arbitary abbreviation or something
14:21:27 <wilx> I thought that "arrows" comes from that boexes and arrows picture...
14:22:07 <wilx> @type either
14:22:12 <lambdabot> either :: forall c b a. (a -> c) -> (b -> c) -> Either a b ->
14:22:12 <lambdabot> c
14:26:04 <xerox> sob.
14:26:39 <xerox> Maybe I should simply stop it until tomorrow.
14:29:42 <esap> Would the contravariant functor from a category to its opposite category have signature   F : C^{op} -> C^{op}. So, e.g. identity functor on the opposite category would work?
14:30:32 <TheHunter> sure.
14:30:44 <esap> I didn't realise it was that easy :-)
14:30:50 * basti_ 's brain explodes softly in the corner
14:30:52 <esap> previously I mean
14:31:28 <TheHunter> yeah, this op notations is often quite confusing.
14:32:24 * xerox rejuvenates basti_
14:33:14 * xerox get his arrows and then.. uh-oh *blip* his brain explodes in the same corner.
14:33:42 <basti_> lol
14:34:49 * boegel y0ws
14:34:54 <basti_> boeboe!
14:35:02 <xerox> @moo
14:35:04 <lambdabot>          (___)
14:35:04 <lambdabot>          (o o)
14:35:04 <lambdabot>   /-------\ /
14:35:04 <lambdabot>  / |     ||O
14:35:04 <lambdabot> *  ||,---||
14:35:04 <boegel> boeboe ? :)
14:35:04 <lambdabot>    ~~    ~~
14:35:06 <lambdabot>      Bull
14:35:10 <xerox> gelgel!
14:35:33 <boegel> I see genneth still hasn't returned
14:35:40 <boegel> I wonder what he has to say to me :)
14:35:59 <xerox> Wasn't he they you b0rken the computer to?
14:36:04 <kaol> @yow nicely.
14:36:06 <lambdabot> My mind is making ashtrays in Dayton ...
14:36:15 <xerox> Sorry for the english I'm a bit b0rken too.
14:36:26 <boegel> xerox: he clicked the link, yeah
14:36:29 <boegel> but is that my fault ? :)
14:36:47 * xerox doesn't know even how much finger does his right hand have.
14:37:12 <xerox> I'll count them, goodnight :-O
14:37:31 <boegel> xerox: wtf ? =) you drunk or high or something ?
14:37:43 <xerox> boegel, I coded waaaay too much.
14:37:52 <boegel> high on code
14:37:59 <basti_> -g-
14:38:00 <xerox> 17:00 -> 23:00 only pause: dinner
14:38:25 <boegel> xerox: I've done worse
14:38:52 <xerox> You're a seasoned haskell hacker
14:39:01 * basti_ never hallucinated because of coding
14:39:05 <basti_> only because of tetris like games
14:39:12 <xerox> I imposed myself "let's have something finished for this night"
14:40:37 <xerox> http://img140.echo.cx/my.php?image=osxonintel20sw.jpg
14:40:40 <boegel> xerox: seasoned ?
14:40:46 <xerox> I'm hallucinated o_O
14:41:40 <xerox> I think I'll open xaos and trip inside mandelbrot for a while.  Wish me luck.
14:41:53 <boegel> good luck
14:41:56 <boegel> I guess...
14:41:58 <basti_> :)
14:42:15 <basti_> we could recite some castaneda or leary.
14:42:29 * boegel goes to bed
14:42:34 <boegel> lot's of studying to do for me
14:42:58 <boegel> and I have an appointment with some people for my upcoming Phd, so that's quite important too
14:43:36 <basti_> ohh
14:46:36 <boegel> bye every1
14:49:59 <xerox> I'm suggesting http://xach.com/fract/m3.mpg
14:50:10 <xerox> 'night Haskellers!
15:12:54 <lightstep> the atl doesn't come installed with ghc, does it?
15:13:05 <Lemmih> atl?
15:13:16 <lightstep> the arrow transformer library
15:18:18 <lightstep> cabal is so cool
15:22:12 <basti_> haskell is so cool.
15:22:54 <kaol> @fortune
15:22:55 <lambdabot> Hackathon Moose (or other Ex-Magnificent-Forest-Creature) Barbecue
15:22:55 <lambdabot>  
15:22:55 <lambdabot> 30 cups oil
15:22:55 <lambdabot> 15 cups Soy sauce
15:22:55 <lambdabot> 5 cups Worcestershire Sauce
15:22:56 <lambdabot> 40 tsp dry mustard
15:22:58 <lambdabot> 20 tsp black pepper
15:23:00 <lambdabot> [23 @more lines]
15:23:45 <kaol> somebody patch lambdabot to pick only smallish fortunes.
15:24:16 * SamB just translated Parsec.Prims into Arrow notation, and it finally typechecks...
15:24:18 <kaol> @more
15:24:19 <lambdabot> 10 cups lemon juice
15:24:19 <lambdabot> 10 cups white vinegar
15:24:19 <lambdabot> 80 cloves crushed garlic
15:24:19 <lambdabot>  
15:24:19 <lambdabot> About 75 pounds of boneless meat (moose, deer, elk, beef - try
15:24:20 <lambdabot> chicken
15:24:22 <lambdabot> too).  For reference this is roughly an entire large dressed (
15:24:24 <lambdabot> [16 @more lines]
15:24:43 <lightstep> @moo
15:24:44 <lambdabot>          (__)
15:24:44 <lambdabot>          (oo)
15:24:44 <lambdabot>   /-------\/-*
15:24:44 <lambdabot>  / |     || \
15:24:44 <lambdabot> *  ||----||  *
15:24:45 <lambdabot> \/|(/)(/\/(,,/
15:24:47 <lambdabot>   Cow munching
15:24:49 <lambdabot>     on grass
15:25:09 <lightstep> @code
15:25:50 <lambdabot> IntSet.hs: Bin p m l r -> foldr f (foldr f z r) l
15:29:33 <wagle> @oom
15:29:34 <lambdabot> Maybe you meant: moo yow
15:30:09 <kaol> @woof
15:30:10 <lambdabot>          (__)
15:30:10 <lambdabot>          (oo)
15:30:10 <lambdabot>   /-------\/
15:30:10 <lambdabot>  )*)(\/* /  *
15:30:10 <lambdabot> \ |||/)|/()(
15:30:10 <lambdabot> \)|(/\/|)(/\
15:30:12 <lambdabot> Grass munching
15:30:14 <wagle> @ommm mani padme omm
15:30:14 <lambdabot>     on cow
15:30:16 <lambdabot> Unknown command, try @listcommands.
15:30:30 <kaol> too bad I've already seen all the cows.
16:11:34 <TFK> Is there a configuration-file parser for Haskell somewhere?
16:11:34 <TFK> Something simple, like Python's ConfigParser module?
16:11:43 * Lemmih uses Read/Show for simple stuff.
16:12:16 <TFK> And the less-simple stuff?
16:12:32 <Lemmih> Checkout missingh. It got a Haskell version of Python's ConfigParser.
16:13:50 <TFK> Sounds just right :-) will look into it
16:39:16 <machack666> is there a haskell-sanctioned image inflation library which lets us take an image file and treat it as a pixmap?  I'm trying to make texture loading work in OpenGL, FWIW.
16:40:22 <Lemmih> There's SDL.
16:40:53 <machack666> Are there Haskell bindings with ghc 6.4, or is that something I need to get somewhere else?
16:41:12 * Lemmih got an SDL binding and a 'SDL surface -> GL texture' function.
16:41:30 <machack666> Sounds perfect...
16:42:07 <Lemmih> darcs repo: http://scannedinavian.org/~lemmih/SDLstable
16:45:50 <machack666> thanks much.
16:47:23 <Lemmih> He'll probably come back when he realizes surfaceToTexture isn't in SDLstable...
16:48:06 <SamB> hmm, I'm trying to do the arrow equivalent of sequence... I might resort to drawing a diagram if I don't get anywhere soon...
16:54:30 * SamB gives up on using a fold because it is too much for his poor brain
16:56:36 * SamB tries using foldl and reverse...
17:17:20 <TFK> How do I compile missingh? It says something about ./setup, but there is nothing like it besides a Setup.lhs file.
17:22:06 <Lemmih> TFK: 'runhaskell Setup.lhs --help'
17:22:34 <TFK> aye, thanks
17:26:25 <juhp> dons: no big deal - but cpp from gcc4 is giving an error on the && operator in the .conf.in.cpp files of hs-plugins
17:27:05 <juhp> dons: putting _'s before and after GLASGOW_HASKELL seems to help fwiw
17:36:03 <Lemmih> Welcome back, machack666.
17:36:20 <machack666> Lemmih: I'm trying to build the SDL bindings, and I'm getting a ld: Undefined symbols:
17:36:20 <machack666> _ZCMain_main_closure linker error
17:36:31 <machack666> this is the SDL/Core
17:36:40 <Lemmih> How are you building it?
17:36:56 <machack666> runhaskell Setup.lhs build (after configure step)
17:37:20 <Lemmih> What platform and SDL version?
17:37:39 <machack666> SDL 1.2.8, Mac OS X 10.3.9 (darwin 7.9)
17:38:18 <Lemmih> Can you PM me the entire output from 'runhaskell Setup.lhs build'?
17:38:26 <machack666> sure
17:39:20 <machack666> ld: Undefined symbols:
17:39:20 <machack666> _ZCMain_main_closure
17:39:20 <machack666> ___stginit_ZCMain
17:39:20 <machack666> *** Exception: got error code while preprocessing: Graphics.UI.SDL.General
17:39:20 <machack666> d'oh
17:39:22 <machack666> sorry folken
17:39:33 <Lemmih> I've only had the opportunity to test it on x86 Linux.
17:40:15 <machack666> I've had a similar error with a library I was writing without a main function.  I ended up using ghc -c to stop after compilation and before linking (I think it was -c)
17:40:37 <Lemmih> It looks like a problem with hsc2hs.
17:40:51 <machack666> is hsc2hs a ghc thing?
17:40:57 <Lemmih> Yes.
17:41:10 <machack666> I could dcc you the config.log if you'd like
18:25:00 <MachinShin> hey +
19:24:46 <SamB> hmm, GHC appears to not like {-# OPTIONS_GHC -farrows #-} very much...
19:35:08 <jaap> i'm trying to run GHC on a machine with 128 MB of memory, and it thrashes a lot; is that inevitable, or can I somehow make GHC GC more aggressively?
19:52:20 <SamB> boy, point-free Arrows are worse than Forth...
19:59:47 <dons> @y0w
19:59:48 <lambdabot> My boxer shorts just went on a rampage through a Long Island bowling
19:59:48 <lambdabot> alley.
19:59:55 <dons> point-free arrows. oh my
20:00:07 <dons> @remember SamB boy, point-free Arrows are worse than Forth...
20:00:34 <reffie> there's still blood in your hair..
20:00:54 <dons> yikes!
20:01:17 <dons> @code
20:01:19 <lambdabot> Fix.hs: class (Monad m) => MonadFix m where
20:01:24 <dons> @code
20:01:25 <lambdabot> Generics.hs: (:*:)(..), (:+:)(..), Unit(..)
20:01:34 <dons> oooh. fun fun
20:01:40 <dons> @code
20:01:41 <lambdabot> Types.hs: INTEGRAL_TYPE(CIno,tyConCIno,"CIno",HTYPE_INO_T)
20:01:57 <dons> bah, using cpp to dervive Typeable is so evil
20:02:07 <kaol> @code me gently with a chainsaw
20:02:08 <lambdabot> Lazy.hs: readSTRef   :: ST.STRef s a -> ST s a
20:03:24 <dons> @code
20:03:25 <SamB> dons: it is surely less evil than using DrIFT
20:03:25 <lambdabot> Ord.hs: comparing :: (Ord a) => (b -> a) -> b -> b -> Ordering
20:03:38 <dons> nah, DrIFT is much more friendly than cpp
20:03:59 <SamB> because it does not require you to get new derivations into DrIFT before people can use them anywhere else...
20:04:00 <dons> i mean, it's operating on abstract syntax rather than concrete syntax
20:04:10 <dons> oh, that's true.
20:04:15 <dons> we need Extensible DrIFT
20:04:18 <dons> with plugins!
20:04:39 <dons> all it would need is some Config.hs style files
20:04:46 <dons> a la Yi
20:05:10 <dons> what do you reckon, SamB?
20:05:11 <SamB> we also need one that uses ASTs for output...
20:05:21 <SamB> not just prettyprinters...
20:05:42 <dons> DrIFT doesn't use an AST internally??
20:05:49 <SamB> not for output!
20:05:59 <dons> why would it? I don't understand.
20:06:24 <dons> a ppr is just a fancy Show instance for the AST
20:07:09 <SamB> that would be true... if a derivation function got to return an AST...
20:07:40 <dons> it doesn't return fragments of code?
20:07:46 <dons> what does it return?
20:07:49 <SamB> it returns a Doc
20:07:57 <dons> oh, so pre-rendered
20:08:22 <SamB> yeah basically... just not layed out yet...
20:08:25 <dons> hmm. not so bad though. keeping it typed until the last second is probably better.
20:09:27 * dons feels tempted to write DrIFT+p
20:09:31 <SamB> and I don't think DrIFT things can take arguments...
20:09:52 <dons> DrIFT could really be a generic TH-like preprocessor
20:10:13 <dons> then again -- I guess we have TH for that..
20:10:21 * SamB wishes DrIFT could use TH syntax...
20:11:27 <SamB> or something like that.
20:11:33 <dons> I agree.
20:11:40 <SamB> You see, TH has this annoying habbit of requiring GHCi.
20:12:04 <dons> yeah, dynamic linker and interpreter support is required
20:12:44 <SamB> doesn't interpreter support require dynamic linker support?
20:13:04 <dons> well, not necessarily
20:13:13 <SamB> no?
20:13:15 <dons> but ghci won't work without it.
20:13:25 <dons> it needs to be able to run library code.
20:13:30 <SamB> what can it do without dynamic linker support?
20:13:46 <dons> but you could run it all just in the interpreter by only interpreting source
20:13:54 <dons> in the style of hugs
20:14:26 <SamB> the trouble with that is that GHCi doesn't seem to support, among other things, unboxed tuples
20:14:58 <SamB> also, GHC doesn't install library source, but that is easy enough to remedy...
20:15:18 <Heffalump> apt-get install ghc6-libsrc :-)
20:15:38 <SamB> Heffalump: some of them are gzipped, and besides the are installed in /usr/share/doc.
20:16:04 <SamB> fine for reading in Emacs, not so great for interpretting.
20:17:16 <Heffalump> the gzipping is annoying
20:17:37 <Heffalump> it's a pretty out-of-date Debian policy that really should be reversed, IMO
20:18:12 <SamB> I honestly don't care in this case, though it is annoying with example code...
20:19:49 <SamB> of course, even more annoying is that habbit example code has of depending on the build system of the package with which it was originally distributed...
20:24:59 <SamB> I have come to the opinion that Arrows are overkill for parsing, or at least add unnecessary complexity to the API for only a little theoretical increase in speed...
20:26:32 <SamB> I'm beginning to think that "generalize", when taken to extremes, means "cripple"...
20:28:19 <Heffalump> samb: the static analysis stuff ought to be a big win once implemented
20:28:38 <SamB> if anyone could stand to use the resulting library, it might be.
20:28:42 <SamB> I don't think I could./
20:28:53 <SamB> s|/||
20:29:28 <SamB> Heffalump: really, what kind of static analysis are we going to be able to implement that will get us much of anything?
20:30:47 <SamB> that Swierstra/Duponcheel stuff didn't look terribly impressive
20:31:05 <SamB> once I figured out what it was all about, that is
20:32:32 <SamB> I think it is more important to optimize for clarity and usability by mere mortals than, say, raw speed...
20:34:10 <SamB> although I would like to see a set of combinators that could coelesce parsers with overlapping beginnings...
20:38:58 <Heffalump> well, isn't that what the Swiestra/Duponcheel stuff can do?
20:39:44 <SamB> not as far as I can see!
20:40:15 <Heffalump> I thought it build up a static table of prefixes.
20:40:23 <Heffalump> It's ages since I've read it, though.
20:41:55 <SamB> really, there seems to be a lot less functionality in the Swiestra/Duponcheel paper than in Parsec.
20:43:33 <SamB> I mean, with Parsec, I can do some backtracking if I like, just by wrapping it in try...
20:44:00 <SamB> also, Parsec has nice error support
20:45:58 <SamB> the thing about Arrows is that you pretty much have to pass any parameters that might need to depend on input data through the Arrow... which can look, and be, quite messy...
20:46:43 <SamB> (I don't mean to imply that an Arrow-based parser combinator library by any means would need to give up try, or anything like that)
20:50:49 <Heffalump> you are using arrow notation, right?
20:58:02 <machack666> I'll check on a vanilla checkout
21:05:26 <SamB> a little arrows notation...
21:05:48 <SamB> I'm not at all good at typing -<, though...
21:07:34 <SamB> I suppose converting Parsec to use arrows is not exactly going to make arrows look any better than monads, though...
21:08:15 <SamB> but PArrows doesn't even seem to WORK
21:12:24 <SamB> unless someone manages to make some kind of breakthrough in parser usability using arrows, I doubt there will be a compelling reason to use them for that. I mean, Parsec is already claiming thousands of lines a second, and has excellent usability compared with just about anything else I've ever seen...
21:14:27 <Heffalump> what kinds of grammars can it handle?
21:15:29 <SamB> it can handle mostly LL1 grammars.
21:16:14 <SamB> that is to say, you can deviate from LL1 if you want to, but if you do it wrong there will be space leaks...
21:16:32 <SamB> (but you can't do it by accident)
21:18:31 <SamB> however, Parsec seems to make it dead easy to write many grammars in a way that turns out LL1
21:20:47 <SamB> I haven't yet found a satisfactory way to parse Self's directed resends, but the only parsers I've seen for those are handcoded in C++ and C, and the C one is reportedly not something to go by...
23:29:42 <Itkovian> meuning
23:30:03 <Lemmih> Morning.
23:30:46 <Lemmih> And good night.
23:31:21 <andersca> hey ski
23:31:48 <ski> hi andersca
23:36:31 * ski 's cat wont stop meowing ..
23:36:48 <andersca> why not?
23:37:10 <ski> think she's in a heat ..
23:37:25 <andersca> ah, yeah
23:38:17 <ski> (gets a bit irritating after a while ..)
23:40:43 <wilx> In heat?
23:40:56 <wilx> Shove her in your fridge.
23:41:28 <tic> ski, http://www.everything2.com/index.pl?node_id=737861
23:43:17 <wilx> omg :D
