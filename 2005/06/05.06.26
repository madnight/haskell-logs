00:23:14 <Trevion> Does anyone know of any Haskell implementations of mail protocols?
00:23:58 <wilx> Hmm, there is a MTA written in Haskell.
00:28:59 <xerox> dcoutts_!!!
00:29:02 <xerox> 'morning :-)
00:30:04 <Trevion> wilx: perfect, thanks.
01:14:25 <musasabi> morning
01:19:49 <shapr> hei
01:24:14 <musasabi> Has anyone got a link to the article using type inference as an example to defining a reference class and indirect composites in JFP during the last year?
02:29:29 <shapr> So, how's code today?
02:30:47 <TFK> Buggy, as usual.
02:30:56 <TFK> Yours?
02:34:24 <shapr> zero at the moment :-)
02:35:05 <shapr> Though this is a good moment to whip up some arrow parser code from Hughes' paper.
02:35:27 <shapr> FrederikEaton: hiya!
02:37:58 * TFK enjoys reading reviews of anime that got 40% and less in animeacademy reviews, in a perverse way
02:39:55 <shapr> The next TMR looks like it might have swiert's AGs, Philippa's next Impure Thoughts column, Pseudonym's next Pseudocode column, my ArrowsIntroduction, and ... well, nothing else.
02:40:12 <shapr> I still won't publish without five articles.
02:41:40 * xerox throws a Google-coloured lambda to shapr
02:41:41 * TFK would like to see something akin to "Haskell OpenGL bindings for an AAA game" ;-)
02:41:48 <TheHunter> with the arrow transformer library, huhges' parser arrow is |newtype Parser s a b = P (StaticMonadArrow (Writer (SP s)) (StateArrow [s] (->)) a b)  deriving (Arrow, ArrowChoice)|, where |data SP s = SP Bool (S.Set s)| with the obvious Monoid instance.
02:43:08 <shapr> Hm, I wonder how much detail I should skip.
02:43:19 <shapr> And how much I should include.
02:43:23 <xerox> I wonder if there's something better than of OpenSource Haskell Work, Paid by Google.
02:44:44 <shapr> salut cognominal
02:46:42 <astrolabe> Are arrows more difficult than monads?
02:46:58 <shapr> umm
02:47:07 <shapr> I think they're easier actually.
02:47:30 * TheHunter votes for more difficult.
02:47:33 <shapr> But there's so little knowledge of arrows in any programming culture that it's hard to become proficient with them.
02:48:20 <astrolabe> I'm looking forward to an introduction
02:48:51 <shapr> http://www.haskell.org/tmrwiki/ArrowsIntroduction
02:50:15 <astrolabe> Oh.  Thanks :)
02:50:54 <shapr> Monads don't let you separate levels of abstraction, you have to combine the static and dynamic behaviour at the same time. That was harder for me to learn than the arrows approach of separate dynamic and static usage.
02:52:38 <astrolabe> Morphisms are sometimes called arrows in category theory.  Is there a relation?
02:52:45 <shapr> For example, I know that monads are a first class action, but that was hard for me to deal with mentally. Arrows are a first class transformer, that's a lot easier for me to deal with.
02:52:52 <earthy> um. that is not strictly true, shapr
02:53:05 <shapr> earthy: Please explain then, I want to write a good article.
02:53:35 <earthy> the thing with monads is that you are bound to one single form of combining values under the monad
02:53:38 <earthy> i.e. bind
02:53:53 <earthy> arrows are more flexible there
02:54:04 <earthy> that makes it a lot easier to separate behaviours
02:54:05 <xerox> i.e. ?
02:54:12 <earthy> id est
02:54:46 <earthy> but it is still possible to model static and dynamic behaviours separately, with monads
02:54:52 <earthy> it's just harder.
02:55:08 * astrolabe guesses xerox meant eg
02:55:31 <earthy> I *did* mean id est. :)
02:55:32 <xerox> No i mean, what's the example for arrows? :-)
02:55:45 <earthy> ah, just a sec. :)
02:55:55 <TheHunter> astrolabe, i guess each 'Arrow' forms a category. Still, the choice of the name 'Arrow' is very unfortunate.
02:57:08 <earthy> xerox: with arrows you not only have >>>, but also first
02:57:57 <earthy> the latter allows you to bypass a >>>, in a sense
02:58:14 <TFK> Is the Haste project alive?
02:58:18 <xerox> @type Control.Arrow.first
02:58:24 <lambdabot> Control.Arrow.first :: forall (a :: * -> * -> *) d c b.
02:58:24 <lambdabot>         (Control.Arrow.Arrow a) =>
02:58:24 <lambdabot>         a b c -> a (b, d) (c, d)
02:58:26 <xerox> @type (Control.Arrow.>>>)
02:58:28 <lambdabot> (Control.Arrow.>>>) :: forall (a :: * -> * -> *) d b c.
02:58:28 <lambdabot>         (Control.Arrow.Arrow a) =>
02:58:28 <lambdabot>         a b c -> a c d -> a b d
02:59:33 <xerox> 'd' in first is 'id'-ed from the argument to the return value?
03:00:09 <earthy> yup
03:00:25 <xerox> I don't get the 'c'.
03:00:49 <shapr> It's like plugging two pipes together.
03:01:33 <shapr> If you mean the c in >>>
03:01:40 <xerox> If you could draw them, it would be fantastic :)
03:01:48 <shapr> it's like (.)
03:01:48 <xerox> (for you article?)
03:01:57 <shapr> in fact, >>> is flip (.)
03:02:02 * xerox mumbles
03:02:07 <xerox> Yes I know that!
03:02:14 <shapr> ok
03:02:18 <xerox> I'm talking about `first'
03:02:20 <shapr> oh
03:03:04 <earthy> xerox: the c? it's just the result of the function
03:03:19 <shapr> Think about this function --> \(x,y) f -> (f x,y)
03:03:48 <shapr> Parameters are a pair and a function. The function is applied to the 'first' part of the pair.
03:03:57 <xerox> Yep.
03:04:21 <xerox> @type \(x,y) f -> (f x,y)
03:04:23 <lambdabot> \(x,y) f -> (f x,y) :: forall a b a1.
03:04:23 <lambdabot>         (a, b) -> (a -> a1) -> (a1, b)
03:04:52 <shapr> The b stays the same, it gets passed through unchanged.
03:04:57 <shapr> That's the d type in first.
03:05:18 <shapr> a b c -> a (b, d) (c, d)
03:05:22 <xerox> OK. and c?
03:05:37 <shapr> c is the result of the original a b c arrow.
03:05:54 <xerox> @libsrc Control.Arrow
03:05:56 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Control/Arrow.hs
03:05:57 <shapr> a is the arrow, b is the first input type, and c is the output type.
03:07:06 <xerox> first f = f *** id  --  now it's clear.
03:07:11 <shapr> You can think of arrows like GIMP or Photoshop filters, their input is b, their output is c, and the filter itself is the a at the front.
03:07:42 <shapr> @type (Control.Arrow.***)
03:07:44 <lambdabot> (Control.Arrow.***) :: forall (a :: * -> * -> *) c' c b' b.
03:07:44 <lambdabot>         (Control.Arrow.Arrow a) =>
03:07:44 <lambdabot>         a b c -> a b' c' -> a (b, b') (c, c')
03:07:52 <xerox> It is exactly like your previous example.
03:07:55 <shapr> I mentally call that pair apply.
03:08:02 <xerox> (***) f g ~(x,y) = (f x, g y)
03:08:11 <shapr> Yup
03:08:22 <xerox> first f ~(x,y) = (f x,y)
03:08:31 <xerox> "greek-letter-substitution" ;)
03:08:34 * shapr grins
03:09:32 <xerox> I missed something like this.  Now I could probably do even more powerful things.
03:10:49 <shapr> Arrows can do lots. Maybe I should write a series of arrow articles.
03:11:13 <shapr> Although I'll be happy enough if this one ends up with smooth writing.
03:13:43 <astrolabe> I don't think I'm up to the level where I'll be able to understand your article, but I suspect an explicit complete simple example (ie code) would help.
03:13:52 <shapr> Yeah, that's the next step.
03:14:15 <astrolabe> Excellent
03:15:54 <astrolabe> I've just read something about a space leak in the Hudak book that I suspect is similar to the one in your example, and I don't get it.
03:16:30 <shapr> Do you understand the part about a combined parser for "one" "two" "three" ?
03:16:53 <astrolabe> Intuitively I would have guessed that not giving up memory to be collected quickly enough wouldn't be too much of a problem
03:17:15 <shapr> What if you're parsing a 300MB file?
03:17:34 <shapr> And the entire input must be passed to the next parser if the first parser fails?
03:18:05 <astrolabe> Is the implication that you might never need to have the whole thing in memory if you do it right?
03:18:24 <astrolabe> Or that you'd need multiple copies if you do it wrong?
03:18:44 <shapr> Nah, it's more that you can get rid of un-needed input as soon as possible.
03:19:36 <shapr> The basic structure of a multiple choice monadic parser is that all options must fail or one must succeed, and all input must be kept until one of those two happens.
03:19:50 <shapr> If you have a large number of choices, you may have to hang onto input for a long time.
03:20:19 <shapr> An arrow-style parser can export static properties, including what it can parse.
03:20:49 <astrolabe> But if you need to have that much memory at some point anyway, how is it much worse to keep it for longer?
03:20:52 <shapr> So the separate arrow-style parsers for "one" "two" "three" would export "ot" as their first char parser.
03:22:03 <astrolabe> hmm 'away with the learning of the scribes!'
03:22:10 <shapr> Keeping stuff longer is the whole reason people use OCaml instead of Haskell. Non-strict evaluation is elegant, but it costs a lot of thought and speed.
03:22:46 <astrolabe> Oh yes, I'm noticing it costs thought!
03:23:12 <shapr> Personally, I prefer the elegance and speed that I get from non-strict eval, but most people just want speed without too much brainwork.
03:23:24 <astrolabe> Hudaks example is  map (inList xs) ys
03:23:35 <astrolabe> is that the same thing?
03:23:42 <shapr> It's not immediately obvious to me, but it might be.
03:24:23 <astrolabe> I'm hoping that you buy easier maintainability with the extra thought
03:24:51 <shapr> I think so, but you have to keep the non-strict properties in mind.
03:25:05 <astrolabe> What are they?
03:25:48 <shapr> The simplest rule of thumb is to keep your code always able to deal with infinite lists, and then you almost never have to worry about strictness.
03:25:48 * astrolabe is not keeping them in mind
03:26:07 <shapr> On the downside, that doesn't work with all algorithms.
03:26:50 <astrolabe> right.  Does the stricness refer to lazy evaluation or the no altering variables thing?
03:26:57 <shapr> lazy evaluation.
03:27:05 <shapr> immutability is the no altering thing.
03:27:20 <astrolabe> Ah :)
03:27:22 <shapr> For example, one plugin I wrote for lambdabot was a mailing list search plugin.
03:27:58 <shapr> The code was very simple, but it ate 512mb ram and 1GB swap in something like thirty seconds, and still didn't do anything useful.
03:28:19 <astrolabe> hey I've got code like that.
03:28:36 <shapr> The problem was that I was reading all the mbox files from the mailing lists into memory, and only parsing them once everything was in memory.
03:28:59 <jlouis> I did that with some graphs one time
03:29:07 <jlouis> 800mb mem;jvmq;kvkmmjm\
03:29:15 * astrolabe might be beginning to grok
03:29:15 <shapr> Derek Elkins showed me where a single strictness annotation ($!) would force the parse after every file read, and suddenly ram usage was sane again.
03:31:24 <astrolabe> At the moment, writing haskell seems like having to write in poetry instead of prose.  I hope it gets easier.
03:31:39 <shapr> I just got good at poetry ;-)
03:32:00 <shapr> It really does get easier, but the other languages feel like writing pidgin english or ebonics or something :-/
03:32:15 <shapr> yo ma bro gotta have a witness fo sheezy
03:32:47 <shapr> hey ma boss lol lmfao u think?
03:33:01 <astrolabe> I think I should practise more
03:33:04 <astrolabe> LOL!
03:33:52 <shapr> The most terrifying part of irc speak is that it's entered the spoken vocabulary of high schoolers here in northern Sweden.
03:34:00 <shapr> They really say lol and all that.
03:34:21 <astrolabe> Have you read any Pinker?
03:34:25 <shapr> No?
03:34:45 <shapr> Rebecca Pinker?
03:35:01 <astrolabe> He's a linguist I think.  He says that pidgin languages develop a grammer in the next generation,.
03:35:06 <astrolabe> Steven Pinker.
03:35:16 <shapr> Interesting thought.
03:35:45 <astrolabe> I think these things can seem ungrammatical from the outside, but really they have as much grammar as non-anal english.
03:35:55 <shapr> Do you read John Cowan's blog? It has neat related writings.
03:36:12 <astrolabe> No.   googling now.
03:36:21 <shapr> http://recycledknowledge.blogspot.com/
03:36:55 <astrolabe> Danker
03:38:03 <shapr> TheHunter: Hey, what do you think about a MoinMoin plugin that uses kosmikus' lhs2Tex?
03:38:38 <shapr> Oleg suggested such a thing, sounds like it might give the benefits of wikipublishing with advantages of pdf/ps
04:25:54 <Muad_Dibber> hmmpf
04:26:14 <Muad_Dibber> how do i remove the i'th element from a list? i suppose there must be a default function for that
04:27:01 <Lemmih> You usually don't want to do that.
04:27:05 <TFK> drop 1 (take 10 somelist)
04:27:20 <TFK> But yeah, since it's all O(n), it's not very helpful.
04:27:28 <TFK> err, no wait, that won't work.
04:28:16 <Muad_Dibber> why wouldnt i usually dont want to do that Lemmih ?
04:28:19 <TFK> (take n somelist) ++ (drop (n+1) somelist)
04:28:47 <TFK> The more interesting question is, why would you want to?
04:29:11 <Philippa_> drawing random cards from a pack, to give one example
04:30:03 <TFK> Is he drawing random cards from a pack? ;-)
04:30:31 <TFK> Would that task better be served by a mutable array?
04:30:40 <Lemmih> Using an array would be more appropriate.
04:30:47 <TFK> *Wouldn't
04:31:39 <Muad_Dibber> most likely indeed Lemmih , but its "only" a list of 2 elements
04:31:54 <Muad_Dibber> so a list here is as quick to write down :)
04:31:59 <Lemmih> It's a tuple, then?
04:32:32 <Lemmih> @plugs let lst = ['a','b'] in (head lst,last lst)
04:32:39 <lambdabot> ('a','b')
04:38:15 <Philippa> Lemmih: an array would indeed be more appropriate, but only if you realise you can swap the card you pick out with one at the end and keep a separate count of how many cards haven't been drawn yet - the list's more 'natural'
04:41:19 <Muad_Dibber> Lemmih : it can be a tuple, it can be a singleton list, it can be an empty list :P
04:43:11 <jlouis> hmmm, ion2 or ion3-devel?
05:25:42 <TFK> How can I get rid of provisional values? For example, I need to get an IO String from someplace, but I don't want to store it anyway, but send it to a pure function right away. So how can I shorted "str <- getString; process str" ?
05:26:17 <Lemmih> fmap pureFunc monadicValue
05:26:33 <Lemmih> @plugs fmap succ (Just 10)
05:26:41 <lambdabot> Just 11
05:26:47 <Lemmih> @plugs fmap succ Nothing
05:26:50 <lambdabot> Ambiguous type variable `a' in these top-level constraints
05:27:45 <TFK> Which still returns a monadic value.
05:28:05 <TFK> Which isn't that bad, I suppose, saves me the return
05:28:08 * TFK tries
05:29:00 <Philippa> TFK: you can't
05:29:06 <Philippa> OTOH, you shouldn't worry about it either
05:29:13 <Philippa> GHC optimises the hell out of monadic code
05:29:28 <TFK> But my eyes don't.
05:29:52 <TFK> A bit of a problem accumulating provisional names I only use once.
05:30:29 <Lemmih> process =<< getString?
05:30:45 <wilx> Hmm...
05:31:04 <wilx> foo <- func doesn't mean it gets stored anywhere.
05:31:25 <TFK> It means that I have a line in my code which ideally shouldn't be there.
05:31:43 <TFK> Lemmih, so, result <- process =<< getString ?
05:33:14 <Philippa> yeah, that'd work
05:33:24 <Philippa> I should use =<< more myself - is there a << too?
05:34:02 <TFK> much nicer than fmap, too, thanks!
05:46:43 <Lemmih> I don't get this line: "[..] but send it to a pure function right away. [..]"
05:47:47 <TFK> Allow me to demonstrate.
05:49:17 <TFK> http://hbin.dyndns.org/pastebin/56.html
05:54:00 <Lemmih> That would be unsafe.
05:54:39 <Lemmih> It's like : 'readInt - readInt'
05:54:55 <TFK> I'm a big boy.
05:55:03 <TheHunter> @type liftM2
05:55:04 <lambdabot> bzzt
05:55:18 <TFK> I'll take that as a no, then?
05:55:29 <TheHunter> Lemmih, looks perfectly safe to me (with the appropriate Num instance...)
05:55:37 <TheHunter> @type Control.Monad.liftM2
05:55:39 <lambdabot> Control.Monad.liftM2 :: forall r (m :: * -> *) a2 a1.
05:55:39 <lambdabot>         (Monad m) =>
05:55:39 <lambdabot>         (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:56:05 <TheHunter> adjustmentSetValue vadj =<< liftM2 (-) (adjustmentGetUpper vadj) (adjustmentGetPageSize vadj)
05:56:09 <TFK> Incidentally, =<< asks for the left-side function to return the value boxed in a container, which is not what 'process' would do.
05:56:17 <Lemmih> TheHunter: where readInt = unsafePerformIO readLn
05:56:59 <TheHunter> Lemmih, no, instance (Monad m, Num a) => Num (m a) where (+) = liftM2 (+); ...
05:57:05 <TFK> a1, a2? Is that anything like a, b?
05:58:03 <TheHunter> yes, you can always rename type variables.
05:59:48 <TFK> Interesting, that even compiled ;-)
06:26:54 <xerox> yo.
06:28:10 <Philippa> TFK: you mean process is a pure function?
06:28:23 <Philippa> if so, return process is process as a monadic computation
06:28:37 <TFK> Yes. Notice the "send it to a >pure< function" ;-)
06:29:07 <TFK> Ah, true. So, result <- (return . process) =<< getInput
06:32:42 <ski> result <- liftM process getInput
06:33:43 <Philippa> and so forth and so forth. No prizes for guessing the definition of liftM :-)
06:35:29 <TFK> Someone would beat me to it anyway...
06:36:30 <TheHunter> @pl (return . process) =<< getInput
06:36:31 <lambdabot> process `fmap` getInput
06:37:05 <TFK> @help pl
06:37:06 <lambdabot>  @pointless <expr> - play with pointfree code
06:37:23 <TFK> That doesn't explain much...
06:38:01 <dons> @foldoc pointfree
06:38:04 <lambdabot> No match for "pointfree".
06:38:05 <TheHunter> it converts an expression to pointless style - usually makes it look horrible, but occasionally, it simplifies the expressions.
06:38:22 <TheHunter> @pl \x y z -> x z + (y y)
06:38:23 <lambdabot> (. join id) . flip . ((+) .)
06:39:07 <xerox> @pl \f xs -> xs >>= return . f
06:39:08 <lambdabot> fmap
06:39:54 <TheHunter> aarghh! shame on me: \x y z -> x z + y y
06:40:09 <reffie> lol
06:40:26 <xerox> @type \x y z -> x z + y y
06:40:31 <lambdabot> bzzt
06:40:40 <xerox> heh.
06:41:01 <TheHunter> @type \x (y :: forall a. a -> a) z -> x z + y y
06:41:03 <lambdabot> \x (y :: forall a. a -> a) z -> x z + y y :: forall t a.
06:41:03 <lambdabot>                (Num (a -> a)) =>
06:41:03 <lambdabot>                (t -> a -> a) -> (forall a1. a1 -> a1) -> t -> a ->
06:41:03 <lambdabot> a
06:41:35 <xerox> "Num (a -> a)" ?!
06:41:53 <wilx> Because of the +?
06:42:12 <TheHunter> it wasn't meant to be a meaningful expression, obviously.
06:42:16 <xerox> Because of the 'y' and the '+', yes.. but..
06:48:01 <TFK> That's quite horrible indeed.
09:51:48 <xerox>   libghc6-gtk2-dev: Depends: ghc6 (< 6.2.1+) but 6.4-1 is to be installed
09:51:48 <xerox> E: Broken packages
09:51:54 <xerox> Hmm, what does it mean ?!
09:52:32 <stepcut> it probably means libghc6-gtk2-dev requires ghc 6.2, but you already have 6.4 installed
09:53:28 <xerox> Nevermind, it's rather old anyway. I'll compile it by hand.
09:53:30 <stepcut> you can try, apt-get source libghc6-gtk2-dev, and then rebuild it from ghc 6.4 if a newer version is not available somewhere
09:55:34 <xerox> Thanks.
10:03:45 <_michiel> anyone happen to know where I might find something called 'stg_ap_0_ret'?
10:04:24 <_michiel> I'm trying to bootstrap ghc unregistered on netbsd/alpha, and I wondered if it might be part of the rtc or something (which I wasn't able to get working)
10:20:23 <andersca> polli: are you here
10:31:47 <adept> @libsrc nup
10:31:48 <lambdabot> nup not available
10:32:11 <adept> @libsrc ndup
10:32:13 <lambdabot> ndup not available
10:32:53 <xerox> nub?
10:35:15 <adept> @libsrc nub
10:35:16 <lambdabot> nub not available
10:35:22 <xerox> @type nub
10:35:27 <adept> but it;s nub, ok
10:35:28 <xerox> adept, what are you searching for?
10:35:28 <lambdabot> bzzt
10:35:33 <xerox> @type List.nub
10:35:35 <lambdabot> List.nub :: forall a. (Eq a) => [a] -> [a]
10:35:42 <adept> @libsrc runIO
10:35:43 <lambdabot> runIO not available
10:35:47 <adept> :)
10:36:00 <adept> ok, let's hope i'll have better luck with grep :)
10:36:26 <basti_> hi!
10:38:31 <adept> is it possible to write QuickCheck test that should be executed in the IO monad (for IOArray access)?
10:40:50 <basti_> hmm
10:41:02 <basti_> how about surrounding it with PerformUnsafeIO?
10:41:43 <basti_> as long as it only depends on its parameters this should be fine.
10:41:50 <adept> @libsrc unsafePerformIO
10:41:51 <lambdabot> unsafePerformIO not available
10:41:57 <adept> :(
10:42:06 <adept> lambdabot: why are you teasing me?
10:42:19 <xerox> @index runIO
10:42:21 <wagle> @tease adept
10:42:21 <lambdabot> Language.Haskell.TH.Syntax, Language.Haskell.TH
10:42:29 <xerox> @docs Language.Haskell.TH
10:42:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language.Haskell.TH.html
10:42:33 <xerox> @libsrc Language.Haskell.TH
10:42:34 <lambdabot> http://darcs.complete.org/fptools/libraries/template-haskell/Language/Haskell/TH.hs
10:42:36 <xerox> There you go.
10:43:33 <xerox> adept, you could use it in query too.  The point is that @docs and @libsrc talks about modules, not single functions.  But you can lookup the modules using @index.
10:54:10 <wagle> xerox: cool.  now i know too..  thanks
10:54:20 <xerox> No problem :-)
11:07:08 <mikael> hey
11:07:42 <xerox> hiya mikael.
11:11:39 <xerox> Do you know how to get Emacs' haskell-mode to display the function type for symbols defined in imported modules?  This information is vitally important.
11:27:12 <adept> xerox: thanks!
11:27:58 <xerox> adept, you're welcome!
11:52:08 <Lemmih>  /join #ypn
11:52:25 <Lemmih> Uhm, sorry 'bout that.
12:33:43 <xerox> @moo
12:33:45 <lambdabot>          (__)
12:33:45 <lambdabot>          (oo)
12:33:45 <lambdabot>   /-------\/
12:33:45 <lambdabot>  / |     ||
12:33:45 <lambdabot> *  ||W---||
12:33:45 <lambdabot>    ~~    ~~
12:33:47 <lambdabot>   Cow laden
12:33:49 <lambdabot>   with milk
12:36:30 <TFK> @moo
12:36:36 <lambdabot>          )__(
12:36:38 <lambdabot>          (oo)
12:36:40 <lambdabot>   *-------\/
12:36:42 <lambdabot>  / |     ||
12:36:44 <lambdabot> /  ||----||
12:36:46 <lambdabot>    vv    vv
12:36:48 <lambdabot>  
12:36:50 <lambdabot>  Polish Cow
12:37:03 <mflux_> so is cow like the logo of haskell?
12:37:07 * TFK didn't get it
12:37:11 <mflux_> mmm.. lambda cow
12:37:16 <TFK> mflux_, more like a mascot
12:37:17 <xerox> @gc
12:37:25 <TFK> I think that the logo is a lambda o_O
12:37:28 <lambdabot>  GHC internal error
12:38:04 <mflux_> or are all these cows just images of your thoughts perverted by writing haskell programs!
12:38:27 <mflux_> ..
12:38:34 * TFK has only written two micro-programs in Haskell
12:38:55 <TFK> Programs come and go, but the cow remains forever.
12:39:35 * TFK has just started reading up on Haskell idioms on HaWiki
12:51:41 <xerox> @moo
12:51:42 <lambdabot>          (__)
12:51:42 <lambdabot>          (**)
12:51:43 <lambdabot>   /-------\/
12:51:45 <lambdabot>  / |     ||
12:51:47 <lambdabot> *  ||----||
12:51:49 <lambdabot>    ^^    ^^
12:51:51 <lambdabot>  
12:51:53 <lambdabot>  Cow in love
13:05:31 <Spark> @moo
13:05:32 <lambdabot>            (---)
13:05:32 <lambdabot>            (   )
13:05:32 <lambdabot>           /-----\
13:05:32 <lambdabot>           |     |
13:05:32 <lambdabot>           |  |  |
13:05:33 <lambdabot>           |  |  |
13:05:35 <lambdabot>           |  *  |
13:05:37 <lambdabot>           ^^   ^^
13:05:39 <lambdabot>           Coward
13:05:45 <Spark> heh
13:06:17 <ibid> somebody should trim lambdabot
13:06:30 <kaol> I spent a few days on our summer cottage. I heard a lot of moos from the nearby farm.
13:11:01 <kaol> So it felt a bit like being at home, even without #haskell.
13:16:03 <kaol> @vixen I promise to not do any more @moos myself.
13:16:08 <lambdabot> are you sure you're not?
13:39:48 <lightstep> will the semantics of (fail::String->RWST r w s m a) ever change?
13:42:05 * boegel waves
13:42:21 <xerox> Hiya boegel!
13:44:13 <TFK> @index liftM2
13:44:14 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
13:44:14 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
13:44:14 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
13:46:11 <boegel> I finished 'The Hitch Hikers Guide to the Galaxy' today, nifty book !
13:46:30 <boegel> how close does the movie come to the contents of the book ?
13:47:30 <xs> it doesn't
13:47:36 <xs> the radio plays are good though.
13:48:21 <TFK> Yup, Adams wanted to take a different path this time, I think.
13:49:20 <lightstep> isn't he dead?
13:49:38 <xs> yes :/
13:50:00 <lightstep> so how can hetake a different path?
13:50:03 <boegel> He's dead ? oh man, that sucks :(
13:50:11 <boegel> how old was he ?
13:50:18 <xs> he oversaw some of the initial development
13:50:24 <TFK> lightstep, part of the movie was produced while he was still alove.
13:50:26 <xs> boegel: i think 52? or something like that.
13:50:33 <boegel> xs: any way to get my hands on the radio plays ? or they online ?
13:50:40 <boegel> xs: oh, not 42 ? :p
13:50:44 <boegel> quite young though :s
13:50:52 <xs> boegel: they aren't online, but amazon has them. they're published by the bbc.
13:50:56 <xs> yeah young.
13:50:56 <TFK> AFAIK, he had a (big) hand in the script.
13:51:11 <boegel> xs: oh, they're for sale ?
13:51:46 <lightstep> boegel, there's also filesharing
13:52:03 <xs> yep!
14:21:33 * boegel summons shapr
14:43:56 <boegel> shapr: I'll try and finish my TMR article on HRay, but I'm not sure I'll be able to do so...
14:44:04 <boegel> shapr: you'll here from me
14:48:57 * boegel kisses everyone #haskell goodnight
14:49:16 * heatsink is covered in dirt and sweat
14:49:38 * poetix has C# cooties
14:50:21 * boegel falls asleep on his keyboard
14:50:25 <boegel> qlk,nfes<qgbcpho,trsidxru
14:50:26 <boegel> *ZZ
14:50:38 <xerox> 'night boegel!
14:50:44 <boegel> nighto !
14:51:06 * heatsink notes that boegel's face has a shape distinctly unlike cats' paws
14:51:17 <heatsink> don't drool and electrocute yourself
14:55:57 * poetix departs ignominiously
15:17:32 <araujo> Hello haskeller, a _lot_ OT, anyone knows a good synonym for to install/to remove?
15:18:20 <Vjaz> This is not very interesting, but I'm trying to compile a Haskell program (which I didn't write myself) and I'm getting this error:
15:18:23 <Vjaz> ghc-6.2.2: unknown package name: plugins
15:18:42 <Lemmih> Vjaz: Google for hs-plugins and dons
15:18:49 <Lemmih> @google hs-plugins dons
15:18:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
15:18:59 <Lemmih> Vjaz: You may need GHC 6.4
15:19:00 <astrolabe> araujo install = load?
15:19:22 <Vjaz> Lemmih, ok, thanks
15:19:27 <astrolabe> remove = delete maybe
15:20:19 <jlouis> insert/delete?
15:20:23 <xs> araujo: add/delete?
15:20:25 <jlouis> load/unload
15:20:40 <dons> Vjax, that's hs-plugins you're missing
15:20:49 <jlouis> oh, hi dons
15:20:51 <dons> what program are you trying to compile
15:21:04 <dons> hey jlouis!
15:21:25 <Vjaz> dons, Yi
15:21:43 <wagle> initiate/terminate
15:21:48 <dons> Vjaz: my favourite :)
15:22:01 * dons has to go an hack icfp code. Ciao!
15:22:45 <wagle> dons: i wish i'd found time for that..  looks interesting
15:23:31 <jlouis> looks hard ;)
15:24:28 <jlouis> chess algorithm and heuristics on movement in the general case?
15:25:01 <araujo> astrolabe, xs, jlouis thanks
15:33:37 * Lemmih fears dons' CopBots.
15:35:39 <xerox> Vjaz, if you still didn't - I'd suggest to get the last darcs sources for hs-plugins.
15:36:25 <Vjaz> they didn't compile
15:36:37 <xerox> What are you missing this time?
15:36:37 <Vjaz> 0.9.8 did though
15:36:46 <xerox> 0.9.8 is _way_old.
15:37:13 <Vjaz> it's the latest, still
15:37:21 <xerox> It's unsupported, I think.
15:37:29 <Vjaz> oh
15:37:35 <Vjaz> that's silly
15:37:46 <xerox> You do need haskell-src-exts, happy, alex to compile hs-plugins.
15:38:06 <Lemmih> Vjaz: You can poke dons until he makes a new stable release.
15:39:00 <Vjaz> the error I get is:
15:39:01 <Vjaz> AltData/Dynamic.hs:141: Variable not in scope: `funResultTy'
15:39:22 <Lemmih> Using GHC 6.2.2?
15:39:36 <Vjaz> yes
15:40:10 <Lemmih> Not sure if it works with 6.2.2.
15:40:47 <Vjaz> what should it work with?
15:40:53 * Lemmih goes away to catch some sleep.
15:40:58 <Lemmih> GHC 6.4.
15:41:06 <Vjaz> hm, all right
15:50:37 <TFK> How come Char isn't of class Eq?
15:50:58 <TFK> Hmm, it is.
15:54:11 <TFK> GHCi is acting all weird...
15:54:35 <Cale> TFK: what seems to be the problem?
15:55:02 <TFK> I played around with definitions of count (let count = ..), but GHCi acted very inconsistently.
15:55:26 <TFK> Sometimes it said that count isn't in the namespace, sometimes it barfed on types, sometimes it worked. Maybe it's too late here, though...
15:55:44 <TFK> Anyhow, I always have Hugs.
15:57:18 <TFK> I was reading this: http://haskell.org/hawiki/PipeliningFunctions and became interested in the definition: join = (concat.) . intersperse, which takes two arguments. So I tried defining count like that.
16:01:05 <jlouis> what should count do?
16:02:05 <TFK> counts the number of occurances of an element in a list, simply: count elem = length . filter (==elem)
16:03:43 <Cale> let count elem = length . filter (==elem)
16:03:46 <Cale> works for me
16:04:16 <TFK> For me too, but I was wondering if it can be defined purely as function composition, i.e. no 'elem'
16:04:25 <xerox> Sure.
16:04:28 <TFK> Similar to how join was defined in the above example.
16:04:40 <xerox> @pl \x -> length . filter (==x)
16:04:42 <lambdabot> (length .) . filter . (==)
16:04:46 <xerox> There you go.
16:05:23 <jlouis> the pl module is evil
16:05:28 <xerox> I should probably write that article.. mumble mumble.
16:06:19 <TFK> Hmm, refuses to compile.
16:06:37 <TFK> *** Binding             : count
16:06:38 <TFK> *** Outstanding context : Eq b
16:06:56 <TFK> Unresolved top-level overloading <--- not sure what it means (this is in Hugs)
16:07:22 <xerox> It does work in GHC, but it defaults to Integer.
16:07:58 <TFK> Why not to a?
16:08:03 <Cale> looks like the monomorphism restriction problem
16:08:08 <xerox> ..even with an explicit type signature.
16:09:03 <TFK> What is a monomorphism restriction problem?
16:09:04 <xerox> Yep.  With -fno-monomorphism-restriction it works smootly.
16:09:10 <Cale> it's fine with an explicit type sig
16:09:14 <xerox> Prelude> let f = (length .) . filter . (==) :: (Eq a) => a -> [a] -> Int
16:09:14 <xerox> Prelude> :t f
16:09:14 <xerox> f :: (Eq a) => a -> [a] -> Int
16:09:38 <xerox> Cale, given -fno-monomorphism-restriction, otherwise it will default.
16:09:42 <TFK> Oh, compiles in Hugs as well.
16:09:52 <TFK> (With the type signature)
16:09:58 <TFK> What was the problem, though?
16:10:11 <xerox> Monomorphism restriction :-)
16:10:26 * TFK blinks
16:10:35 <Cale> hm? perhaps I have -fno-monomorphism-restriction always on :)
16:10:51 <xerox> Yup :-)
16:11:03 <TFK> Well, I bet that Hugs doesn't, but feeding it  an explicit signature appeased it.
16:11:08 <Cale> http://www.haskell.org/onlinereport/decls.html#sect4.5.5
16:12:07 <TFK> Oh, gimme a break... there's no way I can read that.
16:14:15 <cm> !shapr!
16:16:20 <Pseudonym> @seen !shapr!
16:16:22 <lambdabot> I haven't seen !shapr!.
16:16:25 <Cale> TFK: Basically, "f x y = x + y" doesn't need a type signature, but "g = \x y -> x + y" does, for somewhat technical reasons involving polymorphism.
16:16:27 <Pseudonym> Nope, sorry.
16:16:35 <Pseudonym> @wiki MonomorhpismRestriction
16:16:37 <lambdabot> http://www.haskell.org/hawiki/MonomorhpismRestriction
16:16:48 <Pseudonym> Hmmm.
16:16:56 <Pseudonym> @wiki MonomorphismRestriction
16:16:58 <lambdabot> http://www.haskell.org/hawiki/MonomorphismRestriction
16:18:21 <Pseudonym> I should point out that the practical typing reason for the monomorphism restriction is no longer valid when you have scoped type variables.
16:18:23 <Pseudonym> Which GHC does.
16:18:40 <Pseudonym> The only reason left is therefore the semantic reason.
16:20:28 <Pseudonym> I can give you the easy-to-understand 5 minute version if you want.
16:20:44 <TFK> I'd be greatful :-)
16:20:47 <Pseudonym> OK.
16:20:50 <Pseudonym> Consider this:
16:20:59 <Pseudonym> genericLength :: (Integral n) => [a] -> n
16:21:05 <Pseudonym> genericLength [] = 0
16:21:13 <Pseudonym> genericLength (_:xs) = 1 + genericLength xs
16:21:18 <Pseudonym> Make sense?
16:21:51 <TFK> Integral inherits from Num?
16:21:56 <Pseudonym> Yes.
16:22:06 <TFK> OK then, yes.
16:22:20 <Pseudonym> You could also use Num if you wanted.
16:22:26 <Pseudonym> The problem is the same either way.
16:23:06 <Pseudonym> OK.
16:23:09 <Pseudonym> somePair xs = (l, l)
16:23:10 <Pseudonym>     where l = genericLength xs
16:23:14 <Pseudonym> What's the type of somePair?
16:24:05 <Pseudonym> Don't look it up.  THink about it for a moment.
16:24:07 <TFK> somePair :: (Integral n) => [a] -> (n, n)
16:24:17 <TFK> (yes, I typed that myself)
16:24:21 <Pseudonym> OK.
16:24:28 <Pseudonym> Why?
16:24:48 <Pseudonym> Why isn't it (Integral a, Integral b) => [c] -> (a, b)
16:25:05 <cm> Because the l is the same? :|
16:25:26 <Pseudonym> But what's l's type?
16:25:35 <TFK> Hmm.
16:25:36 <cm> Integral n => n
16:26:13 <cm> [so you get (Integral a, Integral b) => [c] -> (a, b) but you can infer that a=b, no?]
16:26:19 <xerox> Pseudonym, couldn't it default to the more general version?
16:26:30 <Pseudonym> xerox: What do you mean?
16:26:56 <xerox> I mean having GHC say by default: somePair :: (Integral a, Integral b) => [c] -> (a, b)
16:27:05 <Pseudonym> xerox: Good question.
16:27:21 <Pseudonym> And if you specify -fno-monomorphism-restriction, that's exactly what it says.
16:27:22 <Pseudonym> Try it.
16:27:30 <xerox> Indeed.
16:27:34 <xerox> What are the drawbacks?
16:27:45 <Pseudonym> There are two.
16:27:49 <Pseudonym> The first is a typing issue.
16:27:52 <cm> Pseudonym: i don't understand the problem; isn't it guaranteed that a=b?
16:28:04 <Pseudonym> cm: What's the type of l?
16:28:15 <Pseudonym> It's (Integral n) => n, right?
16:28:18 <cm> yeah
16:28:29 <Pseudonym> Operationally, that's a funciton.
16:28:33 <Pseudonym> a function
16:28:38 <cm> ok
16:28:40 <Pseudonym> In System F, it's a type abstraction.
16:28:41 <TFK> Is it?
16:28:55 <Pseudonym> You pass a type dictionary for (Integral n), and return n.
16:29:10 <Pseudonym> Make sense?
16:29:13 <cm> yes
16:29:18 <TFK> Not to me.
16:29:30 <Pseudonym> OK, looks like this might take more than 5 minutes. :-)
16:29:45 * xerox grins
16:29:51 <Pseudonym> The first drawback is that in more complex examples, polymorphism can leak.
16:29:52 <TFK> ^_^;
16:30:09 <Pseudonym> But that would take more than 5 minutes to explain.
16:30:09 <TFK> You mean, lead to the wrong typing?
16:30:18 <Pseudonym> Lead to typing which is not expressible in H98.
16:30:33 <Pseudonym> (But which is in GHC -fglasgow-exts.)
16:30:50 <xerox> Interesting.  I can't think of an example but it's enough for now.
16:31:00 <Pseudonym> Sure.  I'll try to come up with one in a moment.
16:31:06 <Pseudonym> We'll look at the other reason first.
16:31:21 <Pseudonym> Now does it make sense to you that (Integral a, Integral b) => [c] -> (a, b) is the most general type of somePair?
16:31:35 <Pseudonym> And not (Integral n) => [c] -> (n, n)?
16:31:36 <TFK> Speaking of H98, are there any revisions on the horizon anytime soon?
16:31:53 <xerox> Sure.
16:31:57 <Pseudonym> OK.
16:32:15 <Pseudonym> But now you have the counter-intuitive problem that l might be computed twice.
16:32:21 <TFK> The former is more general than the latter in any case, although a=b, the compiler doesn't have to know that, I suppose.
16:32:24 <xerox> Right.
16:32:36 <TFK> Why would that be a problem?
16:32:36 <cm> Pseudonym: but it's a "wrong" kind of general ;)
16:32:48 <Pseudonym> cm: :-)
16:32:50 <xerox> TFK, different return values I presume.
16:32:53 <cm> Pseudonym: like, there is this a=b constraint.
16:32:54 <Pseudonym> Right.
16:32:54 <TFK> Besides eating cycles, that is.
16:33:02 * xerox yows
16:33:04 <TFK> xerox, how is that possible in a pure environment?
16:33:05 <Pseudonym> Well, it's not just eating cycles.
16:33:11 <Pseudonym> Could also be space leaks.
16:33:44 <TFK> The compiler could be made smart enough to handle this properly, no?
16:33:45 <Pseudonym> In a pure language, there's no semantic difference.
16:33:45 <xerox> TFK, because, theoretically, a could be different from b.
16:33:57 <Pseudonym> Right.
16:34:06 <cm> xerox: why?
16:34:07 <Pseudonym> And even if a is NOT different from b, the compiler doesn't know that at compile time.
16:34:17 <Pseudonym> somePair :: [a] -> (Int, Integer)
16:34:24 <TFK> It can try to, though.
16:34:38 <cm> Pseudonym: oh, i get you :-)
16:34:41 <xerox> cm, because the type is the most general, and it does not provide that a=b, if so you'd only write 'a' or 'b'.
16:34:47 <TFK> l should be the same in a given scope, at least in a pure environment. Is that not so?
16:34:49 <Pseudonym> So even if you use it in a situation where a and b are the same, l would STILL be computed twice.
16:34:59 <cm> xerox: but my point was that the type should not be (a,b). but i see :)
16:35:07 <TFK> Hmm.
16:35:39 <Pseudonym> The solution, by the way, is simply to put in an explicit type for l.
16:36:04 <Pseudonym> somePair xs = (l, l)
16:36:04 <Pseudonym>     where
16:36:11 <Pseudonym>         l :: (Integral n) => n
16:36:12 <xerox> cm, but we were fighting the monomorphism restriction :-)
16:36:16 <Pseudonym>         l = genericLength xs
16:36:23 <Pseudonym> You do that, and somePair has the more general type.
16:36:25 <xerox> Pseudonym, right, that's an extension!
16:36:35 <xerox> ..a GHC extension, I mean.
16:36:47 <Pseudonym> I don't think so.
16:36:55 <TFK> That sounds like a good solution. How can I make GHC emit an error and die when it detects such an ambiguity?
16:37:14 <Pseudonym> Ah, that's easy.
16:37:19 <xerox> I'll check.
16:37:21 <Pseudonym> You give somePair an explicit type.
16:37:37 <TFK> Well, the problematic definition of count wouldn't compile at Hugs, but it works just fine after I give it a type signature.
16:37:49 <Pseudonym> If you give somePair the explicit, more general type, but don't give l an explicit type, then you get a type error.
16:37:52 <TFK> But GHCi didn't even warn me, it just defaulted to Int
16:38:06 <TFK> Hmm.
16:38:10 <Pseudonym> Oh, I forgot about the defaulting rules.
16:38:16 <Pseudonym> You're right.
16:38:35 <Pseudonym> Hmmm.
16:38:36 <Pseudonym> Anyway.
16:38:56 <xerox> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#type-restrictions
16:38:56 <Pseudonym> OK, is everyone following, anyway?
16:39:13 <TFK> Although I suppose it would barf anyway if I try to apply it in a more generic sense.
16:39:18 <TFK> err, context
16:39:25 <Pseudonym> xerox: Which section specifically?
16:39:31 <cm> yeah. "[19:35] <Pseudonym> somePair :: [a] -> (Int, Integer)" is all you gotta say next time ;)
16:39:33 <TFK> Kinda following ;-)
16:39:41 <xerox> "The context of a type signature" ?
16:39:51 <xerox> No, it probably is not.  Sorry.
16:39:53 <Pseudonym> Nope.
16:40:14 <xerox> Bah, I think I read it somewhere on the GHC User Guide.
16:40:27 <xerox> Ah-ha!
16:40:31 <xerox> Scoped type variables.
16:40:36 <xerox> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#scoped-type-variables
16:40:38 <Pseudonym> Scoped type variables are different.
16:40:45 <xerox> Right, again.
16:40:45 <Pseudonym> And I'll explain them next, if you don't mind. :-)
16:40:56 <xerox> Thanks much :-)
16:40:59 <Pseudonym> Because they are another solution to the monomorphism restriction.
16:41:25 <xerox> Does it have a name the where l :: .. solution?
16:41:43 <Pseudonym> Right.
16:41:47 <Pseudonym> Uhm...
16:41:49 <Pseudonym> No.
16:41:50 <Pseudonym> Hang on.
16:41:51 <Pseudonym> OK.
16:41:52 <xerox> OK :-)
16:42:06 <Pseudonym> Let's suppose That you want to write this function instead:
16:42:10 <Pseudonym> somePair x xs = (x + l, l)
16:42:10 <Pseudonym>     where
16:42:10 <Pseudonym>         l = genericLength xs
16:42:28 <TFK> Which brings me back to my previous question, of whether there is going to be a revision to H98 anytime in the forseeable future.
16:43:10 <xerox> somePair :: (Integral a) => Int, a
16:43:14 <xerox> ooops!!!
16:43:43 <Pseudonym> Hmmm.
16:43:46 <Pseudonym> Sorry, bad example.
16:43:54 <Pseudonym> Let me think about this for a moment.
16:44:04 <xerox> somePair :: (Integral a, Integral b, Integral c) => a -> [d] -> (b, c)
16:45:10 <Pseudonym> Ah, I know.
16:45:14 <Pseudonym> somePair x xs = (l, l)
16:45:14 <Pseudonym>     where
16:45:14 <Pseudonym>         l = fromIntegral x + genericLength xs
16:45:16 <Pseudonym> There.
16:45:29 <Pseudonym> No, hang on, that's not it.
16:46:04 <Pseudonym> Hmmm.
16:49:53 <Pseudonym> Basically, the problem is this:
16:50:17 <Pseudonym> You can fix the monomorphism restriction by adding an explicit type declaration for l.
16:50:31 <Pseudonym> But there are some situations where you can't, because l's type is not expressible in H98.
16:50:53 <Pseudonym> The situation is where you need to steal polymorphic type variables from somePair.
16:51:58 <xerox> Uhm, Ok.
16:52:11 <Pseudonym> I can't come up with a succinct example at the moment.
16:52:25 <xerox> It's OK :-)
16:52:37 <xerox> Thanks for the explanation.
16:54:50 <TFK> Aye, thanks for your time.
16:54:58 <TFK> I'll need to digest it a bit, though.
16:55:01 * Pseudonym nods
16:55:04 <Pseudonym> No problem.
16:55:42 <TFK> http://www.stacken.kth.se/~foo/rpn/ <--- is it just me or could the Haskell solution be made nicer?
17:03:33 <Pseudonym> Looks like it to me.
17:05:56 <Pseudonym> Actually, just sorting out the layout makes it nicer.\
17:07:48 <xerox> Fed it part by part to @pl and laugh.
17:09:25 <TFK> Even the O'caml solution looks nicer :-/
17:10:33 <Number17> The perl one looks like a program's core dump :\
17:11:14 <Number17> Though I guess the author was *trying* to obfusicate it
17:12:14 * TFK chuckles
17:13:40 <Pseudonym> Part of the problem is that read in Haskell is ugly.
17:15:12 <TFK> It looks like Haskell in general isn't meant for the uninitiated.
17:15:52 <Pseudonym> Mind you, the O'Caml version, while prettier, isn't necessarily any easier to understand.
17:15:56 <Philippa> read isn't too ugly so long as you annotate wtf you're expecting to read
17:16:01 <Philippa> unless I've misunderstood?
17:16:23 <Pseudonym> Philippa: In the example, you're meant to do something sane if you can't parse.
17:16:31 <Pseudonym> Which means you have to use ReadS.
17:16:47 <Pseudonym> Or try to catch the exception, I suppose.
17:16:51 <Pseudonym> Either of which is ugly.
17:17:25 <TFK> Sounds like a lose-lose situation.
17:17:43 <TFK> But what is more disturbing is that the ASM solution is shorter than, say, the C# solution.
17:18:06 <TFK> Err, that's not quite right.
17:18:27 <TFK> About the same length, those. But compare to Pascal, Ada, C and C++.
17:19:38 <shrimpx> the ada solution is scary
17:20:10 <wilx> Heh, Perl rules, one liners for about any problem :)
17:20:14 <TFK> And one Brainfuck to rule them all...
17:20:21 <TFK> wilx, they cheated - they used ;
17:20:37 <TFK> But consider the K solution.
17:20:39 <wilx> Ok, then it is three lines :)
17:24:54 <wilx> Hah! A Sed solution too :)
17:34:50 <Pseudonym> The problem with the Perl one-liners is that all of these comparison problems are simple.
17:35:02 <Pseudonym> What I want to see is an MPEG encoder in every language.
17:35:37 <yain> what for
17:35:54 <Pseudonym> Because it's a real problem.
17:36:01 <Spark> yeah
17:36:02 <yain> it's not going to happen
17:36:06 <Pseudonym> Pseudoknot us a better example.
17:36:08 <Pseudonym> That DID happen.
17:36:09 <Spark> perl is based around pragmatism
17:36:14 <Spark> wouldnt it be nice if we had this feature
17:36:22 <Spark> thats why its application specific
17:36:39 * yain feels that he missed start of discussion
17:36:49 <Pseudonym> http://www.ecs.soton.ac.uk/publications/rj/1995-1996/decsys/phh/hartel2.htm
17:36:54 <Pseudonym> That's a REAL example.
17:37:31 <yain> even this somewhat silly shootout page don't have implementation in all languages
17:37:31 <Spark> you have to trade off the complexity of programs, with the complexity of the actual language required to make the programs simple :)
17:37:34 <TFK> What's Pseudoknot?
17:37:36 <yain> for some of their problems.
17:37:39 <TFK> Why not an IRC client?
17:37:53 <Pseudonym> Pseudoknot is a benchmarking problem.
17:38:18 <Pseudonym> It's a floating point intensive search problem, which makes it really good to test how fast languages are at number crunching.
17:38:43 <TFK> Perhaps that should be an array of programs; a Breakout game; and IRC client (GUI); assorted problems from The Great Language Shootout...
17:39:11 <Pseudonym> The problem with the language shootout is that many of the problems are specified as "same way".
17:39:11 <TFK> *an IRC client
17:39:12 <yain> TFK: did you saw how many implementations are missing on shootout?
17:39:17 <Pseudonym> Rather than "same thing".
17:39:18 <yain> and those are quite simple problems
17:39:33 <TFK> I merely suggested stealing the problems, not the solutions ;-)
17:39:49 <Pseudonym> An MPEG encoder, or Pseudoknot, or some other problem like that, is well-specified, and nontrivial, and by definition "same thing" not "same way".
17:39:50 <TFK> Or, one can benchmark languages in SPOJ, it's much easier, since anyone can give it a go.
17:40:08 <Pseudonym> The other option is, of course, the ICFP contest. :-)
17:40:12 <TFK> How many people are going to write their own MPEG encoder?
17:40:24 <yain> no one
17:40:24 <Pseudonym> Well, a lot of people wrote Pseudoknot.
17:40:26 <jlouis> the problem with the shootout is it adresses solutions to problems. Not problems themselves
17:40:27 <TFK> But everyone writes some web-engine, or a GUI, or a game, or somesuch.
17:40:28 <yain> that's what i'm talking about.
17:40:40 <Pseudonym> There's a version for lots of interesting languages.
17:41:47 <TFK> Well, by "everyone" I mean people on sourceforge :-/
17:42:06 <TFK> Who are not really "everyone", I must admit.
17:42:52 <yain> proving such stuff is a waste of time
17:43:32 <Pseudonym> Actually, it depends on what you're trying to prove.
17:43:33 <yain> if someone really wants to choose he writes his own benchmarks for his own problems
17:43:43 <TFK> Sourceforge hosts a lot of projects. Tens of thousands.
17:43:56 <yain> but in this general sense: "we are faster than X" <-- that's waste of time
17:44:01 <TFK> Yup, everyone gets to choose their own tools in the end, I suppose.
17:44:02 <Pseudonym> Right, I agree with that.
17:44:18 <TFK> So, perhaps benchmarks should be oriented towards productivity.
17:44:28 <Pseudonym> But more intangable measures, like productivity and maintainability...
17:44:28 <Pseudonym> Right.
17:44:30 <TFK> But that's quite difficult to test...
17:44:30 <Pseudonym> Robustness.
17:44:35 <TFK> At least speed is well-defined.
17:44:47 <Pseudonym> What you need to do is get two teams, experts in their own tools, and get them to write the same program.
17:44:59 <yain> it's not going to happen
17:45:05 <yain> what are you thinking about?
17:45:06 <Cale> TFK: is it though? :)
17:45:08 <Pseudonym> Then get the two solutions independently tested.
17:45:09 <TFK> "experts" is a shakey term ;-)
17:45:19 <TFK> Cale, grab a timer and time it ;-)
17:45:21 <yain> yeah. and how's sponsoring that?
17:45:26 <Pseudonym> I reckon there's a PhD in it.
17:45:28 <TFK> Just like SPOJ does, in fact.
17:45:41 <Cale> TFK: It's defined for a single piece of source code written in one language
17:46:29 <TFK> Yes.
17:46:47 <TFK> And it SPOJ, that's hundreds of pieces of source code.
17:47:37 <Cale> (and compiled with one particular compiler, running on some architecture)
17:47:52 <TFK> Speaking of productivity, doesn't the ICFP test for something similar?
17:48:29 <Cale> But if you want to compare multiple languages, you can't really use the same program to compare them :)
17:48:32 <TFK> It is not unconcievable to fund the SPOJ project and get them multiple test machines ;-)
17:48:43 <TFK> Why not?
17:49:01 <Cale> Because it won't be the same program when it's been written in another language.
17:49:27 <TFK> yes, but the SPOJ problems are well defined.
17:49:35 <TFK> Or, you can make a complete solution, a la ICFP.
17:49:48 <Pseudonym> The ICFP contest doesn't really test for robustness or maintainability.
17:49:50 <Cale> There are many solutions in any given language, so which do you choose?
17:49:57 <Pseudonym> It tests whether or not the team that wrote it can maintain it for a weekend.
17:50:08 <TFK> That is a difficult question indeed.
17:50:31 <TFK> All the important metrics are really difficult to measure.
17:50:37 <erg> A good contest would be "implement microsoft excel feature for feature"  you have 3 days
17:50:39 <yain> difficult?
17:50:48 <yain> it is not possible. period.
17:51:02 <erg> whoever got the most features completed
17:51:17 <Pseudonym> Is is possible, just not perfectly.
17:51:21 <TFK> erg, even the bugs?
17:51:30 <Pseudonym> Not Excel. :-)
17:51:32 <Pseudonym> But simpler software.
17:51:42 <TFK> (An invaders game? ;-)
17:52:19 <xerox> Monadius :-)
17:52:38 <TFK> I should look at its code. (Not to mention play it!)
17:54:03 <lispy> invaders eh? cool
17:54:09 <lispy> TFK: how's your client going?
17:55:10 <TFK> It's on halt while the adjustment (pseudo?) bug is being solved.
17:55:28 <lispy> any luck on that front?
17:55:30 <TFK> Auto-scrolling is the last feature I wanted to implement anyway. Then clean up the code a bit.
17:55:47 <TFK> I posted on Gtk2Hs users - now waiting for dcoutts_ to win the ICFP ;-)
17:56:38 <TFK> Speaking of games. Any SDL bindings for Haskell?
17:56:40 <lispy> TFK: have you thought about trying the autoscrolling by itself without all the irc code?
17:56:49 <Cale> TFK: yeah
17:57:03 <TFK> lispy, I did - in fact, I had to, in order to submit a clear test case demosntrating the problem.
17:57:12 <lispy> oh
17:57:13 <TFK> The equivalent PyGTK code worked perfectly, BTW.
17:57:14 <lispy> okay
17:57:22 <lispy> bummer :(
17:57:45 <TFK> Then there's the event issue, I find it weird, I should try testing that separately as well.
17:57:48 <Cale> http://homepages.nildram.co.uk/~ahey/HLibs/
17:58:04 <lispy> TFK: definitely
17:58:04 * TFK crawls
17:58:10 <TFK> 2004?
17:58:23 <TFK> Version 0.0.0?!
17:58:38 <xerox> Doesn't hopengl has SDL bindings too?
17:58:46 <xerox> err, have.
17:59:11 <lispy> how do i use cabal?
17:59:24 <lispy> i looked at the manual and walked away confused
17:59:39 <lispy> i have source here that has already been cabalized
17:59:46 <lispy> i just want to build and install it
18:00:37 <CosmicRay> make setup
18:00:40 <CosmicRay> ./setup build
18:00:43 <CosmicRay> err
18:00:45 <CosmicRay> ./setup configure
18:00:46 <CosmicRay> ./setup build
18:00:49 <CosmicRay> ./setup install
18:00:53 <xerox> runghc Setup.hs --help ?
18:01:02 <lispy> i don't have a Setup.hs
18:01:06 <lispy> hmm...
18:01:09 <xerox> OK.
18:01:16 <xerox> Listen to CosmicRay :-)
18:01:32 <CosmicRay> one sec...
18:01:33 <lispy> $ ls
18:01:34 <lispy> Makefile  _darcs/   hsemail.cabal    prologue.txt
18:01:34 <lispy> Text/     example/  package.conf.in
18:01:47 <xerox> "make" ?
18:01:57 <lispy> the author told me to use cabal and that instructions were in hsemail.cabal, but i don't see any instructions
18:02:17 <lispy> apparently the make file is for use with fptools and it gives errors
18:02:23 <CosmicRay> $ cat Setup.lhs
18:02:23 <CosmicRay> #!/usr/bin/env runhugs
18:02:23 <CosmicRay> arch-tag: Main setup script
18:02:23 <CosmicRay> > import Distribution.Simple
18:02:23 <CosmicRay> > main = defaultMain
18:02:26 <lispy> $ make
18:02:27 <lispy> Makefile:2: ../mk/boilerplate.mk: No such file or directory
18:02:27 <lispy> Makefile:21: ../mk/target.mk: No such file or directory
18:02:28 <lispy> make: *** No rule to make target `../mk/target.mk'.  Stop.
18:02:32 <CosmicRay>         ghc -package Cabal Setup.lhs -o setup
18:03:06 <CosmicRay> the package should really bundle Setup.lhs for you
18:03:24 <lispy> in that case i wonder if the author forgot to 'darcs add' the file
18:03:39 <CosmicRay> anyway, I must run, sorry
18:04:50 <lispy> $ ghc -package Cabal Setup.lhs -o setup
18:04:50 <lispy> Setup.lhs line 3: unlit: Program line next to comment
18:04:58 <lispy> that's a weird message
18:05:14 <jlouis> nope
18:06:11 <lispy> unrecognized option `--global'
18:06:27 <lispy> jlouis: i guess it just seem weird to me for it to be an error
18:06:33 <lispy> to have comments and code side by side
18:07:08 <lispy> i think i need to downgrade to ghc6.4
18:09:00 <xerox> Goodnight people.
18:09:05 <lispy> night
18:09:09 <lispy> thanks for the help
18:11:46 <Pseudonym> Night.
18:11:47 <lispy> 6.4 is much happier
18:11:49 <lispy> night
18:12:00 <lispy> or are you saying good night to xerox?
18:12:11 <lispy> cuz, it's only 6pm ya know
18:12:14 <Pseudonym> Ys, to xerox.
18:12:19 <Pseudonym> And it's 11:20am.
18:12:28 <lispy> no it's not
18:12:29 <lispy> :)
18:12:37 * lispy is being a butt
18:12:42 * Pseudonym noticed
18:13:54 <lispy> what zone?
18:14:03 <lispy> time who?
18:14:52 <Pseudonym> what say?
18:16:41 <heatsink> make time
18:17:13 <Cale> for great justice
18:18:57 <lispy> well, i ran setup install as root, now i get an error trying an example, " runghc message-test.hs  < message-test.input" fails to load interface `Main' because message-test.hi: openBinaryFile: does not exist
18:19:26 <lispy> actually it fails to find the module too
18:19:30 <lispy> (just noticed that part)
18:26:53 <lispy> ah finally
18:26:59 <lispy> got all the permissions set right
18:27:01 <lispy> and it works
18:31:08 <lispy> my root umask must be very....anal
19:11:59 <drbean> @index intToFrac
19:12:01 <lambdabot> bzzt
19:13:34 <drbean> @index Frac
19:13:34 <lambdabot> bzzt
19:14:09 <drbean> @hoogle Frac
19:14:10 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => (a -> b)
19:29:43 <lispy> @hoogle fromIntegral
19:29:44 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => (a -> b)
19:29:56 <lispy> maybe thats what you want?
19:32:47 <Pseudonym> Gotta go.  Fare well!
19:32:54 <lispy> see ya
19:33:02 <lispy> using sirc?
19:33:13 <lispy> i thought TFK was writing sirc ;)
20:19:59 <lispy> hs-plugins 'make register' gives error, it can't find things
20:20:23 <lispy> env LIBDIR=/usr//lib/hs-plugins ghc-pkg -u < src/altdata/altdata.conf.in
20:20:23 <lispy> Reading package info from stdin... done.
20:20:23 <lispy> ghc-pkg: cannot find libHSaltdata.a on library path
20:20:34 <lispy> Biker: hi
20:20:38 <lispy> Biker: how as your weekend?
20:20:54 <Biker> not bad at all lispy
20:59:08 <lispy> anyone know what i should do to convince hs-plugins to register?
23:33:10 <Itkovian> meuning
23:43:05 <ski> good morning
