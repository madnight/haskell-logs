00:00:05 <xerox> Yeah I don't just mean the @pl output, but understanding it would be a start.
00:00:11 <shapr> yain: Do you have a livejournal with the same name?
00:00:37 <yain> yep.
00:00:44 <yain> i should use some cleaning tho
00:00:48 <yain> *it
00:01:06 <shapr> Nice punchcards.
00:03:08 <yain> it's not mine
00:03:14 <shapr> Oh
00:03:19 <yain> i just linked to someone's collection
00:03:24 <xerox> @pl \f g x y -> f (g x y)
00:03:25 <lambdabot> (.) . (.)
00:03:27 <shapr> Nice to see someone else who likes Joy.
00:03:51 <shapr> DEFINE approxEqual == 100.0 / rotate [0 =] [pop] [dup rolldown - swap /] ifte > .
00:04:48 <shapr> Have you seen the 'stack scramblers' William Tanksley suggested?
00:05:55 <yain> nope
00:06:50 <shapr> He suggested using operators like abc-cba to reshuffle the stack in obvious ways.
00:07:00 <shapr> I think Slava ended up using that in Factor as well.
00:07:12 <Pseudonym> Oh, that's a good idea.
00:07:16 <Pseudonym> That's better than the FOrth operators.
00:07:28 <Pseudonym> Nobody can remember what they're supposed to be.
00:07:38 <Heffalump> what would the benefit be?
00:07:40 <shapr> Stack scramblers end up doing just about everything.
00:07:53 <Heffalump> Where would they go, in CPU ISAs, or in bytecode languages?
00:07:55 <shapr> a-aa is dup, a- is pop
00:08:05 <ski> drop
00:08:43 <shapr> Stack scramblers go underneath a Joy implementation.
00:08:55 <shapr> Or other stack based language, if you have one you like.
00:09:25 * ski recently pondered pattern-matching in concatenative lang
00:09:38 <shapr> ski: You may have the chance to do that soon enough.
00:09:52 <ski> ski : mhm ?
00:09:57 <ski> shapr : mhm ?
00:09:59 <ski> :)
00:10:02 <shapr> I hear rumors of some neat code that will be public soon.
00:10:24 <yain> shapr: i thought those are called shuffle words
00:10:37 <yain> that's at least how slava calls them.
00:10:37 <Heffalump> so what's interesting about Joy?
00:10:38 <lightstep> abc-cba = arr reverse
00:10:51 <ski> (something like   : nil length = 0 | cons length = drop length 1 + ; )
00:10:55 <shapr> Maybe so, I thought William Tanksley called them stack scramblers.
00:10:58 <Heffalump> what's the implementation path?
00:11:04 <shapr> Lots of interesting stuff in Joy.
00:11:31 <shapr> Personally, I want to use Joy for non-strict call-by-need per-token metaprogramming.
00:11:59 <shapr> I think Joy's purely concatenative nature will lend itself to metaprogramming more than Scheme or Lisp syntax.
00:12:15 <yain> actually even though joy derviatives look extremely appealing to me i cannot overcome this barrier of writing "backwards" code
00:12:19 <shapr> Factor isn't purely concatenative though.
00:12:35 <yain> well i think this term is seriously flawed.
00:12:44 * shapr quickly rewrites the term!
00:13:22 <shapr> lightstep: That's pretty cute.
00:13:38 <lightstep> not correct, though
00:13:43 <shapr> Still punny.
00:13:58 * Heffalump reads the Joy FAQ and wonders if it's a pisstake
00:14:14 <yain> shapr: http://cvs.sourceforge.net/viewcvs.py/factor/Factor/Factor/library/stack.factor?view=markup
00:14:50 <dbremner> yain - those look familiar.
00:15:12 <shapr> Yeah, those are the ops that Bill Tanksley suggested on the concatenative mailing list.
00:15:32 <lightstep> @pl \n stack -> let (f, r) = splitAt n stack in reverse f ++ r
00:15:33 <lambdabot> (line 1, column 17):
00:15:33 <lambdabot> unexpected "("
00:15:33 <lambdabot> expecting natural, identifier or "in"
00:15:35 <shapr> As Pseudonym said, they're a lot easier to remember.
00:15:46 <shapr> @eval joy "1 dup"
00:15:49 <lambdabot> [1, 1]
00:16:05 <yain> wow
00:16:12 <lightstep> @pl \n stack -> ((\(f, r) -> reverse f ++ r) (splitAt n stack))
00:16:13 <lambdabot> (uncurry ((++) . reverse) .) . splitAt
00:16:17 <yain> @eval joy "2 2 +"
00:16:37 <shapr> Hm, lambdabot must be taking a nap.
00:16:43 <lambdabot> [4]
00:16:46 <yain> hehe
00:16:55 <yain> sorta slow to get this result
00:16:57 <xerox> wow.
00:17:27 * Heffalump reads some more and decides that Joy is taking pointlessness to an extreme.
00:17:28 <xerox> I was searching for a Jow implementation, do you know of a multiplatform one?
00:18:05 <shapr> I haven't tried to use Joy on Windows, I only know Linux implementations.
00:18:08 <xerox> Yeah, no arguments substitution, just function composition.
00:18:17 <shapr> Oh, I have to go catch a bus to go shopping!
00:18:39 <xerox> Enjoy yourself!
00:18:41 <dbremner> shapr - the FP vs. OO article in tmr reminded me of this. http://www.mm.informatik.tu-darmstadt.de/~kuehne/fps/
00:19:08 <shapr> dbremner: Oh yeah, good point! You should mention that in the feedback.
00:19:22 <shapr> I've read that, but hadn't thought of it recently.
00:22:42 * ski is reminded of FAD
00:25:55 <dons> @bot
00:25:56 <lambdabot> :)
00:26:03 <shapr> @botsnack
00:26:07 <lambdabot> :)
00:26:21 <dons> other side of the planet is slower
00:26:36 <dbremner> shapr - just added an entry.
00:26:50 <shapr> Thanks!
00:42:38 <Pseudonym> Nytol!
01:27:35 <Itkovian> meuning
01:45:59 * Itkovian has to spend a whole day hacking Java ... the source ... grrr
01:47:07 <yain> they are compelling you to do it? :-(
01:49:25 <Itkovian> yes, I am imprisoned ... in a cold airco'd room ... fulkl of dells
01:54:26 <yain> you should fight. no one have the right to subject human being to java programming.
01:55:33 <olliej> java is a great language
01:55:38 <olliej> i like to eat toothpaste
01:55:42 <olliej> :)
02:11:25 <Itkovian> yain: well, I usually don't mind, but it is unclear what the goal is :-)
02:17:19 <Itkovian> @seen brianm
02:17:20 <lambdabot> I saw brianm leaving #haskell 7 hours and 17 minutes ago.
02:17:25 <Itkovian> @seen goron
02:17:26 <lambdabot> I saw goron leaving #haskell 13 hours, 1 minute and 53 seconds ago.
02:17:31 <Itkovian> hmm
02:17:56 <Itkovian> does anybody know if brianm included /sw/include etc on his
02:18:05 <Itkovian> mac when building ghc?
02:32:03 <Itkovian> whoiieee got meself darcs 1.0.3
02:32:13 * Itkovian grins
02:32:33 <dons> darcs for everyone! darcs for all!
02:36:03 <Itkovian> all for darcs!
02:41:47 <ikegami--> I love darcs but I think darcs is not popular in Japan, unfortunately
02:42:04 <reffie> what's popular in japan?
02:42:23 <ikegami--> still cvs, and svn becomes popular
02:43:05 <ikegami--> I guess there is a few Japanese documents for darcs
02:46:08 <Itkovian> well, can't you jappies read english? ;-)
02:46:12 <ikegami--> (maybe I should translate the documents)
02:46:21 <Itkovian> ikegami--: a good idea ...
02:46:36 <reffie> is FreeBSD popular, in japan?
02:46:40 <ikegami--> yes
02:46:46 <reffie> cool!
02:47:09 <reffie> i should go to japan
02:47:33 <ikegami--> welcome :)
03:02:02 <kuribas> Hi, is there an easy way of saying (\f1 f2 a -> (f1 a << f2 a))
03:02:23 <arjanb> @pl (\f1 f2 a -> (f1 a << f2 a))
03:02:24 <lambdabot> liftM2 (<<)
03:03:14 <ikegami--> great!
03:03:24 <yain> what else is popular in japan?
03:03:38 <kuribas> heh, nice!
03:03:46 <ikegami--> yain: what kind?
03:04:02 <yain> is postgresql popular, i've heard it is.
03:04:09 <yain> s/./?/
03:04:30 <ikegami--> yes, and MySWL is also popular
03:04:33 <ikegami--> SQL
03:04:39 <yain> crap.
03:04:49 <reffie> ruby is popular :P
03:04:55 <ikegami--> hehe
03:04:57 <ikegami--> right
03:05:08 <yain> how they both can be popular!
03:05:45 <ikegami--> i don't know, i have never used both yet
03:06:15 <ikegami--> but i've seen many blogs about them
03:06:22 <yain> i'd like to go to japan, but the language scares me
03:07:58 <ikegami--> Japanese is not easy language as Haskell
03:08:38 <yain> i remember someone telling me that it takes like 8 years to comprehend it fully
03:09:12 <yain> even though we have some centre here which is claiming to teach nearly everyone who wants to
03:09:14 <yain> it's still scary
03:13:39 * ski 's cat wants to eat his cake
03:14:02 <ikegami--> but you can visit Japan if you get a guide who speaks both English and Japanese
03:14:17 <ikegami--> cute cat
03:14:48 <ski> she actually liked the little part i gave her ..
03:14:59 <ski> weird cat
03:17:50 <yain> ikegami--: so will you be my guide? :-)
03:18:39 <ikegami--> yain: of course, if you visit Kansai-area in Japan
03:18:45 <yain> cool!
03:21:12 <yain> kansai-area is around osaka?
03:22:13 <tromp> yep, and kyoto
03:35:27 <ski> hiya Enveigler1
04:07:13 <TFK> dcoutts_, howdy, sorry for bothering, but is the Windows installer for Gtk2Hs ready?
04:19:18 * ski curses theme
04:25:14 * TFK looks into generators in Haskell
04:27:08 <ski> generators ?
04:29:08 <TFK> Generators.
04:29:47 <TFK> You know, Icon generators, Python generators...
04:31:59 <ski> ok
04:33:28 <TFK> dcoutts, howdy, you there?
04:34:13 <yain> TFK: they are called coroutines more often imho
04:34:38 <dcoutts> TFK, hello
04:34:38 <TFK> "opinion" has no part in statistics ;-)
04:35:09 <TFK> I was wondering if that binary installer for Gtk2Hs was ready.
04:35:23 <dcoutts> TFK, yes it is :-)
04:35:24 <yain> and as far as i understand what's going on in haskell there is no need for them to be explicit because of laziness.
04:35:32 <TFK> WEEEE! Please send it over! :-D
04:35:39 <dcoutts> http://haskell.org/gtk2hs/gtk2hs-0.9.8.exe
04:36:08 <dcoutts> once enough people tell me that it's working, I'll upload it to the SourceForge mirrors
04:36:19 <TFK> yain, well, suppose you're generating the fibonacci series, but you don't want to keep the entire list so far in memory.
04:36:36 <yain> well that's what so called "infinite lists" are for
04:36:37 <yain> imho
04:36:46 <dcoutts> TFK, So your success/failure report (and what ghc & gtk versions your using) would be much apreciated
04:38:08 <TFK> Aye aye. GHC 6.4, GTK Runtime 2.6
04:38:24 <dcoutts> ok
04:38:25 <TFK> As for the actual code, I'm going to write a very (very) simple IRC client now.
04:38:52 <dcoutts> you've seen Hircules? (It's very out of date now)
04:39:23 <dcoutts> http://haskell.org/hircules/
04:39:39 <TFK> yain, so? fibonacci series may be defined as an infinite list, but suppose you take 10 elements from it, and now you want to take the 11th.
04:40:22 <TFK> Or somesuch - you don't know when you'll be taking the next element, and you don't want to keep the previous results in memory. I'm a bit murky on this, maybe there's a much more idiomatic way to handle such situations.
04:40:45 <ski> TFK : passing around the tail of the list ?
04:40:50 <TFK> dcoutts, I've glanced it over, but I'm actually doing the IRC client and the fibonacci generator as a challenge someone issued to me ;-)
04:41:15 <TFK> D'oh >_<
04:41:18 <dcoutts> good good :-) les us know how it goes
04:41:35 <TFK> That makes a lot of sense, actually :-/ but he won't be satisfied, I'm sure.
04:42:05 <TFK> Besides, it's an adventure in the world of the Writer Monad! (I'm less excited than it seems :-/ )
04:42:36 * juhp wishes he had time to update hircules to ghc64 and current gtk2hs...
04:42:42 <ski> i'm not entirely sure what you want and not want with the fib series ..
04:42:58 <dcoutts> hia juhp!
04:43:07 <juhp> hey, Duncan
04:43:47 <ski> TFK : it's someone who wants to write 'similar' code to generators in python ?
04:43:53 * Itkovian is freezing ... this bloody airco cannot be shut
04:43:53 <dcoutts> juhp, so I'm trying to reproduce this gtksourceview parser error on amd64
04:44:12 <juhp> ah yeah
04:44:35 <TFK> No, he doesn't program in Haskell. But the naive approach would keep the previous elements of the list in memory, so the requirement is not to. Getting the head/tail seems like a good solution.
04:45:07 <ski> TFK : which naive approach would keep the prev. elems ?
04:45:12 <yain> do haskell has a some concept of continuations at all?
04:45:30 <TFK> ski, show (take 1000000 fib)
04:45:31 <ski> yain : not real ones, just CPS style and CPS monad
04:45:40 <yain> why do you want to bother with coroutines in that case.
04:46:06 <ski> (yain : though, TheHunter cheated and defined them anyway ..)
04:46:54 <ski> TFK : only if you define fib at top level
04:47:08 <TFK> ski, or even more naively, show (fib !! 10); show (fib !! 11); etc.
04:47:21 <TFK> Why does it matter?
04:47:28 <TFK> It's a problem if I do it repeatedly, though.
04:47:43 <ski> fib5 = let fib = ... in fib !! 5
04:47:57 <ski> that will GC fib ..
04:48:08 <TFK> ...and pay the price of traversing the list.
04:48:20 <ski> yes
04:49:14 <dcoutts> argh, ghc segfaults when building ghc
04:49:25 <ski> TFK : hm, what if you do an exists-object stream ?
04:49:43 <dcoutts> juhp, is there a later ghc-6.4.1_pre amd64 snapshot that I can try?
04:49:49 <ski> TFK : data Stream a = forall x. MkS x (x -> a) (x -> x)
04:49:58 <TFK> But passing around the tail sounds problematic as well, because you have to be aware of the head/tail division, no? With a generator, you just ask for the next element, and it does all the book-keeping itself.
04:50:02 <dcoutts> I'm currently building from source with an older ghc-6.4
04:50:14 <ski> TFK : fib = MkS (1,0) snd (\(a,b) -> (b,a+b))
04:50:16 <TFK> ski, I'm afraid that makes not sense to me...
04:50:29 <dcoutts> and the ghc-inplace segfaults on most operations :-(
04:51:01 <juhp> dcoutts: well i built a snapshot rpm today
04:51:15 <dcoutts> can I unpack that with cpio?
04:51:24 <juhp> I haven't seen binary snapshots
04:51:33 <dcoutts> (and hack the scripts to change the install prefix)
04:51:40 <TFK> dcoutts, it tells me that I don't have GTK 2.6.7 devel, but I do.
04:51:41 <ski> TFK : a variant of the infinite list, where you don't get (i think) problems with defining fib on top-level
04:51:46 <TFK> dcoutts, should I try with 2.6.8?
04:51:51 <juhp> dcoutts: yeah - my pkg is relocatable fwiw
04:52:16 <TFK> ski, can you give me a code example of how it will work?
04:52:28 <dcoutts> juhp, oh, but probably only if I use rpm to install it rather than just unpacking with cpio :-)
04:52:40 <juhp> dcoutts: yep
04:52:42 <TFK> What's MkS anyway?
04:53:41 <ski> TFK :  sHead fib ==> 0   sHead (sTail (sTail (sTail (sTail (sTail fib))))) ==> 5
04:53:42 <dcoutts> TFK, the registry says what version of Gtk you've got isntalled, check HKCU (or HKLM if you're admin) /Software/GTK/2.0/
04:53:50 <ski> TFK : MKs is constructor
04:54:18 <dcoutts> TFK, and see where the "path" value in that key points to
04:54:20 <ski> (TFK : have not shown definition of sHead,sTail ..)
04:54:41 <TFK> ski, still, it requires that the programmer be aware of head/tail.
04:54:46 <ski> yes
04:54:53 <ski> hm
04:55:10 <juhp> dcoutts: also you can install the ghc641 package in parallel to an existing ghc install :)
04:55:30 <dcoutts> juhp, yep
04:55:42 <ski> TFK : how will you make the generators 'remember' how far they currently are ?
04:56:23 <dcoutts> juhp, do I want the one from FC3 or FC4 ?
04:56:26 <TFK> ski, beats me. There's a recipe in the Wiki (following an ml discussion). I'll try to capitalize on it.
04:56:38 <juhp> dcoutts: hangon :)
04:57:16 <ski> TFK : hawiki/PythonGenerator ?
04:57:25 <TFK> ski, aye
04:57:55 <TFK> dcoutts, hmm, well, if you mean /Program Files/Common Files/GTK, then mine is kinda outdated. My real GTK runtime resides in C:/GTK
04:58:26 <dcoutts> TFK, right but if you installed that using the installer then it should have set the registery key
04:58:46 <TFK> That's what I did, all the other software works fine.
04:59:03 <ski> TFK : onquick glance, it only seems they define generators, not invoke them (at least not from within definition of other generator)
04:59:15 <TFK> (Namely, The Gimp, Gaim, my own PyGTK stuff.)
04:59:21 <dcoutts> TFK, well you can set the reg key and it'll work
04:59:56 <dcoutts> hmm, all the Gtk installers I know of, do set that reg key
04:59:59 <TFK> Yes, but why does all the other stuff work while Gtk2Hs doesn't? Are you sure that it needs the reg key?
05:00:08 <TFK> Well, I'll try 2.6.8
05:00:56 <TFK> ski, yes, it looks fishy. But I need to investigate further.
05:01:44 <dcoutts> TFK, well only the installer needs the reg key to find where GTK has been installed
05:02:06 <TFK> Hmmm.
05:02:17 <TFK> OKie, I'll try to tinker with it.
05:04:09 <dcoutts> TFK, oh I've got an idea of what might have heppened...
05:05:08 <dcoutts> TFK, you installed one version as a user and the other as admin, so HKCU/Software/GTK/2.0/ is for the old install while HKLM/Software/GTK/2.0/ is for the new one
05:05:57 * TFK doesn't understand what HKCU and HKLM are, but he always installs stuff as admin. Of course, memory is a fallible thing...
05:06:00 <dcoutts> TFK, and the installer looks at the HKCU one first, would you mind seeing if this is the case? I might need to adjust the logic the installer uses...
05:06:19 <TFK> aye, if I figure out how o_O
05:06:41 * TFK goes to Add and Remove Programs
05:06:42 <dcoutts> HKEY_CURRENT_USER & HKEY_LOCAL_MACHINE, you'll see them in regedit
05:08:50 <TFK> HKLM correctly points to the current GTK runtime path.
05:09:08 <TFK> HKCU doesn't set any (interesting) reg keys.
05:09:57 <dcoutts> TFK, so HKLM points to the correst GTK runtime path but we were somehow picking up the old one?
05:10:15 <dcoutts> and HKCU doesn't have the key "HKCU/Software/GTK/2.0/" at all?
05:10:58 <TFK> It does, but it only sets Installer Language
05:11:09 <TFK> (to 1033, whatever that means)
05:13:40 <dcoutts> TFK, ok, looking at the isntaller code again, it looks like the presensce of the "HKCU/Software/GTK/2.0/" key is messing thins up
05:14:09 <dcoutts> it's giving the wrong error message though, let me see why...
05:14:55 <dcoutts> TFK, so what was the exact error message?
05:15:49 <TFK> "The Gtk+ installation appears to be missing or corruped ..."
05:16:41 <dcoutts> Ah, so it is giving the right error message
05:16:42 * TFK still installs 2.6.8, Glade 2.10, WOO!
05:16:48 <dcoutts> sort-of
05:17:27 <dcoutts> TFK, so it's looking at the "HKCU/Software/GTK/2.0/" noticing that it's messed up (since it is missing the path value) and bailing out
05:17:39 <TFK> Why is it bailing out? Nothing else is.
05:17:46 <TFK> (I can reinstall Gaim to make sure.)
05:17:49 <dcoutts> It should probably be more robust and look at the "HKLM/Software/GTK/2.0/" too
05:17:57 * TFK nods
05:18:30 <dcoutts> I should check out how the gaim installer detects GTK
05:18:52 <dcoutts> TFK, so you can fix it by deleting the messed up "HKCU/Software/GTK/2.0/" key
05:19:10 * TFK tries
05:19:14 <dcoutts> then the Gtk2Hs installer will not be confused
05:19:27 <dcoutts> but I'll see about improving the installer too
05:19:38 <dcoutts> thanks for the bug report! :-)
05:19:47 <TFK> heh, n/p
05:20:09 * TFK tries again
05:20:42 <TFK> Woo, it installed! :-D
05:20:55 <dcoutts> :-)
05:21:32 <TFK> Now let's see if I can compile the demos.
05:22:57 <TFK> ButtonBox works :-D
05:23:15 <dcoutts> try one of the cool ones
05:23:39 <dcoutts> like the fastdraw or the calculator, or profileviewer
05:23:40 <TFK> But the executable is kinda big, and it pops a console window.
05:23:52 <dcoutts> you can strip to get it smaller
05:24:08 <dcoutts> I mean strip it. not yourself :-)
05:24:27 <TFK> I hope so o.o;;
05:24:32 <dcoutts> I'm going to add a FAQ about the console window issue
05:24:43 <TFK> So it's solvable?
05:24:57 <dcoutts> you can get rid of it by compiling with ghc --make -optl-mwindows, but...
05:25:29 <dcoutts> with no console window you can never use the stdin/stdout/stderr or your program will immediately die with an exception
05:25:31 <TFK> But what? Is it unsafe?
05:25:52 <TFK> Huh? Why? Can't I redirect to a file/pipe?
05:26:13 * TFK tried the calculator, btw. :-D
05:26:22 <dcoutts> windows GUI progs have a disconected stdin/stdout/stderr
05:26:37 <TFK> What do you mean?
05:26:58 <dcoutts> That the file descriptors 0,1,2 are set to invalid values
05:27:12 <dcoutts> there is no open file handle for stdin/stdout/stderr
05:27:24 <TFK> Yes, I've noticed this problem with py2exe as well. But it doesn't die.
05:27:42 <TFK> It certainly doesn't die when trying to write or read from them.
05:27:51 <dcoutts> so you'd get an exception like "hPutChar: invalid file descriptior"
05:28:40 <TFK> Exceptions are OK. But, isn't it possible to make some kind of trick to detect this possibility and set null std*?
05:28:46 <dcoutts> Well in my opinion it's an annoyance that GHC should try to work around by making them fail silently rather than by throwing an exception, but you'll have to help me persuade the GHC devs
05:29:06 <dcoutts> or by opening a console as soon as they are written to/ read from
05:29:41 <dcoutts> So it's an unsatisfactory situation that Gtk2Hs can't really work around very well
05:29:55 <TFK> Well, I have a pitchfork. Will that help? ;-)
05:30:03 <dcoutts> hah!
05:30:13 <TFK> Hmmm. But I can set them to some null default myself, right?
05:30:25 <dcoutts> we decided to leave it with the console window poping up rather than with your program randomly failing with an odd looking exception
05:30:39 <dcoutts> and we'll add an FAQ explaining the situation
05:30:41 * TFK nods
05:31:06 <dcoutts> you might be able to do something like that, yes
05:31:36 <dcoutts> in fact that might be a reasonable workaround that Gtk2Hs could use
05:32:36 <TFK> It would be better if GHC did this transparently, I think. Persuading the GHC devs is worth a shot.
05:33:00 <dcoutts> I've tried once :-), now where's JaffaCake...
05:33:50 * TFK hides the pitchfork behind his back
05:34:30 <dcoutts> I probably bully him quite enough, I've been banging on about other things that JaffaCake has been good enough to fix.
05:35:21 <dcoutts> We need more Simons! :-) to spread the work around a bit more
05:36:38 <Igloo> If the price is right I'm willing to change my name  :-)
05:36:53 <dcoutts> heh heh :-)
05:37:38 <dcoutts> TFK, I'll write up a FAQ, I'll tell you when I'm done so you can read it over and tell me if it makes any sense
05:38:10 <TFK> Aye aye!
05:38:26 <TFK> Maybe you can put it in a wiki?
05:38:47 <TFK> Hijack HaWiki for Gtk2Hs'es selfish purposes >-)
05:38:52 <dcoutts> Well our website allows comments on stuff
05:40:15 <dcoutts> what's a good FAQ name? "Hiding the console on Windows"
05:41:25 <TFK> Short and to the point.
05:43:53 <TFK> Hmmm. "Exsorcizing Windows GUI apps."
05:45:44 * TFK stares at FastDraw :-D
05:46:08 <dcoutts> mesmerising?
05:46:45 <TFK> Quite :-)
05:48:06 <TFK> Nice comments in FileChooserDemo ;-)
05:48:17 <Cale> TFK, did you see http://www.haskell.org/hawiki/PythonGenerator ?
05:48:42 <TFK> Cale, yup - as I said, I'll try to use it.
05:50:00 <Cale> but really, Generators are just a concession to the usefulness of lazy lists. Haskell provides a vast generalisation of generators in the form of recursive lazy data structures
05:51:13 <TFK> True. But what other (elegant) solution do you propose to such cases?
05:51:17 <Heffalump> not if the generation of elements has side effects
05:51:33 <TFK> It needs to have state.
05:52:00 <Heffalump> then generators are strictly more powerful (but less elegant) than lazy lists
05:52:10 <Itkovian> @seen boegel
05:52:11 <lambdabot> I saw boegel leaving #haskell 1 day, 14 hours, 33 minutes and 25
05:52:11 <lambdabot> seconds ago.
05:52:20 <CosmicRay> shapr: can you url me to your arrows article again?
05:52:23 <Itkovian> man, the studying is apparently hard
05:52:28 <CosmicRay> I had to leave before reading it yesterday
05:52:56 <Itkovian> CosmicRay: it's on the tmrwiki afaik
05:53:07 <Itkovian> http://www.scannedinavian.org/tmrwiki ?
05:53:07 <TFK> Heffalump, at any case, it will be an interesting excersize indeed.
05:53:22 <Itkovian> http://www.haskell.org/tmrwiki
05:53:26 <xerox> http://haskell.org/tmrwiki/ArrowsIntroduction
05:53:33 <CosmicRay> thank you
05:58:51 <TFK> dcoutts, woo! All the demos seem to be in order.
05:59:04 <dcoutts> cool
05:59:19 <CosmicRay> so, having read that, let me just ask -- in the example shapr provides, would the theoretical Arrow parser *automatically* derive the rules about a string beginning with "t" must be the two or three parser?
06:00:11 <TFK> Regarding the unicode, why wasn't the literal be written as is?
06:00:36 <dcoutts> TFK, I think GHC didn't/doesn't support the unicode string literals
06:01:05 * TFK tries
06:01:12 <TFK> Unicode is most important to me...
06:06:22 <TFK> Well, it compiles...
06:06:31 <TFK> But the glyphs are totally wrong.
06:06:44 <dcoutts> probably fonts
06:07:00 <dcoutts> or the lack thereof
06:07:12 <dons> what does @plugs say, I wonder..
06:07:14 <TFK> Hebrew works just fine in PyGTK.
06:07:25 <Igloo> It could be charset mismatch problems
06:07:43 <dcoutts> but the same string does not come out right in Gtk2Hs?
06:07:53 <dcoutts> if so I'd like a test case
06:08:24 <TFK> Bah.
06:08:32 <TFK> Or maybe my editors are screwed.
06:09:34 <dcoutts> I found that the arabic comes out wrong on my windows box which I think it because of missing fonts
06:09:47 <dcoutts> I had the same issue on Linux before installing some arabic fonts
06:09:49 <TFK> Arabic works fine here.
06:10:02 <dcoutts> but not Hebrew
06:10:22 <TFK> Not in this case.
06:10:36 <TFK> But I'm not sure if my editors are unicode-aware at all.
06:10:46 <TheHunter> wow, the download of the icfp live cd is fast...
06:11:11 <TFK> Hmph.
06:13:41 <dcoutts> TFK, how's this look: http://haskell.org/gtk2hs/archives/category/faqs/
06:15:26 <TFK> Makes sense :-) But why create the console at all? Just make a dummy, optionally a logfile.
06:16:00 <dcoutts> I don't know that windows has a concept of /dev/null that you could redirect stdout/stderr/stdin to
06:16:28 <TFK> Well, if py2exe can do it, I'm sure that Haskell can ;-)
06:16:50 <yain> do what?
06:17:15 <TFK> Not die when invalid std* are used.
06:20:37 <dcoutts> TFK, yes we should see how python does it on windows and see if we can do something similar for ghc
06:21:29 <TFK> I may try, but I suspect that stuff is too deep for me :-(
06:23:31 <dcoutts> well the easy way is to just email the python dev list/people and then translate it and forward it to the ghc-bugs list :-)
06:23:45 <dcoutts> no realy work, just act as messenger
06:24:05 <TFK> Ah, yes, big pimpin' ;-)
06:25:00 <yain> what's up?
06:25:25 <Philippa_> dcoutts: DOS used to have a NULL file, dunno if windows does
06:25:39 <dcoutts> Philippa_, hmm, interesting
06:25:46 <Igloo> Isn't it nul:?
06:26:01 <yain> it's "nul"
06:26:03 <Philippa_> it's a file not a device, though it might've been nul
06:26:03 <yain> yes
06:26:13 <yain> and what's so hard about reading/writing to/from wrong fd
06:26:16 <Philippa_> it also had "files" for the serial ports (COM1, COM2) etc etc
06:27:37 <dcoutts> yain, writing to an invalid file handle gives an exception
06:27:46 <dcoutts> @google haskell cario graphics
06:27:48 <lambdabot> http://www.advogato.org/person/donscarletti/diary.html?start=21
06:28:20 <dcoutts> @google haskell cairo
06:28:22 <lambdabot> http://www.ofb.net/~abe/cairo.shtml
07:34:27 <dcoutts> JaffaCake, Gtk2Hs is now working nicely on amd64 with ghc-6.4.1.20050620. Yay!
07:34:44 <JaffaCake> that's what I like to hear :)
07:35:07 <dcoutts> Well done on all the bug fixing.
07:36:32 <JaffaCake> you're welcome - thanks for all the reporting :)
07:43:38 <jlouis> anybody comitting to the ICFP contest this year?
07:43:55 <dcoutts> jlouis, yep
07:50:17 <jlouis> I am on a ``watch'' basis this year
07:50:20 <jlouis> too many exams
07:50:35 <jlouis> Had they been easier, I'd commit more time
07:51:40 <dcoutts> JaffaCake, one more "possibly a bug" report: ghc includes the .h files in the .hc file in the opposite order to how they are listed in the package file "includes:" field.
07:53:09 <dcoutts> arguable it's a bit dodgy relying on the incluson order to be the same as how they are listed in the .cabal file
07:53:23 <jlouis> Oh, Matthias Blume and John Reppy is in the contest organizing group, heh
07:53:44 <Igloo> Oh, JaffaCake: Should the files that contain "exposed: True" (I think they're what are fed to ghc-pkg) be called foo.cabal?
07:53:50 <dcoutts> but it avoids having to distribute a seperate .h file which #includes them in the right order
07:55:23 <dcoutts> JaffaCake, yes Igloo and I were having some confusion over this point, the difference and naming of the files cabal uses to build a package and the files describing a package that ghc-pkg consumes (and produces with "describe")
08:41:09 <metaperl> CosmicRay: congrats on your book man!!!
08:41:24 <metaperl> wow, I know a book author!
08:41:30 <Heffalump> book?
08:41:42 <metaperl> Heffalump: on Python: http://www.complete.o
08:41:46 <metaperl> www.complete.org
08:41:55 * Heffalump has written a chapter of a book, if that helps :-)
08:42:05 <Heffalump> well, jointly written
08:42:10 <yain> (a glossary to be percise)
08:43:35 <metaperl> ICFP contest is starting soon... they dont appear to accept team entries... it looks like you just mail in the submission via the web form
08:43:44 <metaperl> tomorrow they announce the problem
08:43:45 <Heffalump> they always accept team entries
08:43:54 <metaperl> yeah, but how do you register a team?
08:43:56 <lispy> i almost forgot about ICFP
08:43:56 <Heffalump> you just need one contact email
08:43:57 <Heffalump> you don't
08:44:05 <Heffalump> you just submit with details of your team in the submission
08:44:31 <metaperl> oh
08:56:45 <CosmicRay> metaperl: hi, and thanks! :-)
08:57:06 <CosmicRay> metaperl: ltns, how ya been?
08:57:24 <lispy> starts this weekend eh?
08:57:33 <lispy> anyone around here looking for teammates?
08:57:45 <CosmicRay> metaperl: you may also be interested in http://www.freesoftwaremagazine.com/free_issues/issue_05/haskell/
09:01:24 <yain> lispy: you'll be using haskell? :-)
09:02:23 <lispy> yain: i used lisp last year, but i'd be doing it for fun, not to prove anything about a programming language ;)
09:03:14 <yain> err, last year they had a those antroids?
09:03:25 <Heffalump> yeah
09:03:35 <Heffalump> I liked that one :-)
09:04:04 <yain> yes it's interesting, but also quite complex problem imho.
09:22:49 <dcoutts_> CosmicRay, that's a really good article, it's well written
09:36:38 * lispy waits for eclipse to download
09:36:49 <lispy> emacs just isn't happy on windows
09:36:53 <lispy> maybe eclipse will be happier
09:43:18 <Khisanth> what is wrong with it on windows? seems to be the same
09:44:00 <yain> beware eclipse is written in java.
09:44:59 <Khisanth> well as long as it is as resource hungry as netbeans...
10:20:18 <lispy> Khisanth: i wanted to use some addons, and i got sick of fighting with windows...
10:20:59 <Khisanth> oh, haven't had a need for that beyond JDE
10:22:10 <lispy> i'm new to this source code, so i thought some of the tools like ecb would help me learn
10:36:44 <CosmicRay> dcoutts: thanks!
10:37:08 * Heffalump likes it too
10:38:00 <CosmicRay> thanks, heffalump (if you were talking to me)
10:38:36 <yain> Khisanth: nice nickname :P
10:39:00 <Heffalump> I was.
11:22:03 * xerox sighs
11:22:22 <xerox> I can't read other languages than Haskell anymore, I have the _physical_ need to know the type of the functions used.
11:24:22 <shapr> Wow
11:25:10 <lispy> amazing isn't it?
11:25:15 * CosmicRay hands perl to xerox
11:25:17 <CosmicRay> have fun!
11:25:20 <xerox> :(
11:25:25 <CosmicRay> (have the medics close by)
11:25:30 <xerox> It seems to be a crucial part of the understanding.
11:25:43 <xerox> (process)
11:26:47 <xerox> What do you think?
11:28:10 <ski> it gets harder to keep track of functions taking functions taking functions, without types, yeah :)
11:29:13 <xerox> Indeed, but I'm unconfortable with actual non-functional code, too.. hmpf.
11:29:28 <xerox> e.g. http://www.divmod.org/websvn/wsvn/Quotient/branches/glyph/sigma-2891-3/mantissa/sigma.py?op=file&rev=0&sc=0
11:30:34 <lispy> i find non-functional languages seem very redundant
11:31:21 <ski> xerox : non-functional as not using much functions, or having side-effects ?
11:32:03 <dbremner> lispy - as Philip Greenspun put it, "SQL, Lisp, and Haskell are the only programming languages that I've seen where one spends more time thinking than typing."
11:32:31 <ski> he's said that ?
11:32:43 <Igloo> But for lisp that's only because you can do   126i)<ESC>
11:32:46 <aheller> Probably not the most ringing endorsement to many I know.
11:32:54 <CosmicRay> Igloo: hahaha
11:33:04 <CosmicRay> Igloo: but what self-respecting lisp hacker uses vi?
11:33:05 <yain> he should invest in some speed-typing training
11:33:13 <xerox> ski - it's indeed difficult to keep track of functional arguments in those languages, but I was pointing out the bad feel I get because the understanding process is mostly based on function _names_.
11:33:14 <dbremner> ski - http://blogs.law.harvard.edu/philg/2005/03/07
11:34:37 <ski> xerox : hm, not getting the point about function names ?
11:34:44 <xerox> dbremner, I usually spend much time writing s-expr than thinking while writing lisp.
11:35:02 <ski> xerox : calling functions/methods through strings/symbols ?
11:35:57 <xerox> ski, I mean missing the explicit type signatures.  Just reading the names, they're usually understandable, but it's very uncomfortable.
11:36:07 <ski> ah
11:36:32 <kzm> Is there a list of known GHC issues?
11:36:38 <kzm> (AKA bugs)
11:37:03 <aheller> xerox: do you find ML similarly disturbing, then?
11:37:10 <xerox> aheller, I don't know ML :-(
11:37:39 <xerox> I'm having issues with Haskell code without type signatures too, heh.
11:37:59 <kzm> And in particular, GHC-compiled programs segfault when run with the -xc option.  I wonder if I should bother to bother the developers :-)
11:38:11 <kzm> Is it a known thing?
11:39:09 * kzm nudges JaffaCake.
11:41:15 * kzm found http://sourceforge.net/tracker/?group_id=8032&atid=108032
11:43:25 <yain> ew, ghc is hosted on sf?
11:43:33 <CosmicRay> just its bug tracker
11:43:39 <yain> oh.
11:43:44 <yain> i was getting worried
11:44:08 <CosmicRay> no need to panic
11:44:16 <CosmicRay> obviously you haven't read the Hitchhiker's Guide :-)
11:44:59 <kzm> Hmm... nothing there, though.  Are you able to use +RTS -xc?
11:45:23 * CosmicRay first looks up what -xc does
11:45:38 <kzm> gives a kinda-sorta stack trace
11:45:50 <kzm> You need to compile with -prof, and run with -xc
11:46:17 <kzm> I have a weird error, and thought that, perhaps *this* time, -xc would provide some interesting information. :-)
11:46:41 <CosmicRay> heh
11:46:45 <kzm> I guess it's back to the True way of debugging: staring at the code until one of us gives in.
11:46:45 <CosmicRay> sorry, I haven't tried that
11:46:52 <CosmicRay> heh
11:46:57 <CosmicRay> what about one of the haskell debuggers?
11:47:07 <kzm> Which one do you recommend?
11:47:17 <CosmicRay> I've never used one, but I hear they exist :-)
11:47:25 <kzm> I never got around to delving into them properly.
11:47:58 <kzm> Perhaps I should try budd^H^H I mean "buggha"?
11:48:20 <CosmicRay> I've heard good things about hat, I think
11:48:56 <CosmicRay> http://www.haskell.org/hat/
11:48:57 <kzm> If you find anybody who've used them, ask them to write a tutorial for the next Monad Reader.
11:48:58 <Igloo> Is your code basically Haskell98?
11:49:14 <Igloo> hat has a reasonable tutorial, I think
11:49:17 <kzm> Mine?  I think "basically" covers it, yes.
11:49:48 <Igloo> OK
11:51:28 <Heffalump> oh, buddha got its name back
11:51:29 <kzm> Ubuntu has Hat, er, somewhere.  Installing it now.  Igloo, have you used it?  Will you hang around?
11:51:55 <kzm> Heffalump, yes I heard.  The question is what to call the debugger-formally-known-as-buddha.
11:52:10 <Igloo> I haven't done more than check it works with the first bit of the tutorial
11:52:14 <Heffalump> formally, not formerly?
11:52:26 <kzm> You did mean the other buddha, right :-)
11:52:39 <xerox> @karma kzm
11:52:40 <lambdabot> kzm has a karma of 0
11:52:44 <Heffalump> http://www.cs.mu.oz.au/~bjpop/buddha/
11:52:48 <kzm> Oops.  Typo.  Yes.  Well, actually, formally is perhaps equally good.
11:53:11 <kzm> Okay, I got Hat.  Now what?
11:53:12 <Heffalump> formally is rather more accurate now, it would seem :-)
11:54:00 <kzm> The question is what it is known as informally.  That will be more revealing of its true -- dare I say buddha -- nature.
11:54:11 <Heffalump> :-)
11:54:15 <Igloo> Now read the tutorial  :-)
11:54:17 <lispy> heh
11:55:07 <kzm> Look.  Here I am graciously dignifying this medium with my illustrious presence, and now you tell me to RTFM?  Really!
11:55:17 <CosmicRay> hehe
11:55:35 <CosmicRay> kzm: that is a far higher-quality rant than I typically see :-)
11:55:36 * kzm sighs, and starts Googling.
11:55:59 <kzm> Always strive for excellence!
11:56:02 <CosmicRay> kzm: it's right on the url I sent you
11:56:13 <CosmicRay> kzm: I think you're finding that there is not a lot of debugger experience in this channel
11:56:22 <CosmicRay> http://www.haskell.org/hat/
11:56:32 <CosmicRay> down there under "user guides" is this thingy called "tutorial"
11:56:53 <CosmicRay> you have to put your mouse cursor on the blue thing -- it's called a "link" -- and then depress the left mouse button
11:57:00 <CosmicRay> stop me if this is getting too technical :-)
11:57:36 <yain> :-)
11:58:41 <Igloo> Sorry we can't be more help, but the rest of us just write perfect code straight out. We find it more efficient that way.
11:58:46 <CosmicRay> heh, there's a black-hat command now
11:58:51 <kzm> No, I think I've got it.  The mouse bit me when I tried to get it out of the cage though, but I don't think it's depressed any more.
11:59:12 <kzm> Thank you *so* much for all your help!
11:59:14 <Igloo> What does it do?
11:59:25 <kzm> (Actually, it seems Hat didn't like Unboxed arrays)
11:59:29 <CosmicRay> hehe
11:59:45 <Igloo> You can probably just change the type to fix that
11:59:47 <kzm> I'll try to just write perfect code, then.  Seems like the only reasonable option left.
12:00:02 <lispy> yup
12:00:09 <lispy> debuggers are for imperfect people
12:00:28 * kzm sighs, and goes for a cup of tea while Emacs starts up.
12:02:48 * kzm discovered that Hat doesn't know about Word either.
12:03:29 <lispy> oh, time for open office
12:04:33 <CosmicRay> kzm: pretty soon, you'll be saying it doesn't know of a derby either
12:05:15 * kzm is confused.
12:05:56 <CosmicRay> sorry, bad joke
12:06:00 <kzm> This time it's not Hat, it's me: I have no clue why it can't decide where +! and *! should come from.
12:06:20 <kzm> AFAIK, I don't use those operators.
12:10:43 <CosmicRay> I've never heard of them either
12:12:30 <kzm> Basically, I did the required UArray->Array footwork, and checked that it compiles with ghc.  hmake -hat still gives me errors, though.
12:14:36 <kzm> Hmm...  I suspect it may be because I define my own ! operator.  (Am I the only person in the world to do so?  Seems like such an obvious thing, but...but I digress).
12:14:50 <kzm> I can try to call it something else.
12:17:44 <kzm> Okay.  No ST Arrays with Hat.  Any bright ideas?
12:19:46 * kzm sighs again, and returns to his staring contest with his code.
12:26:13 <wilx> None.
12:26:18 <wilx> Have a good stare :)
12:27:17 <kzm> Actually - I think I'd rather play Enemy Territory (and dream of a PC that would suffice for Battlefield 2)
12:27:23 <TFK> dcoutts, the docs don't come with the installer, right?
12:27:27 <wilx> Heh.
12:27:29 <kzm> But thanks anyway. :-)
12:27:45 <wilx> I was able to play BF2 on Athlon 1.2...
12:27:53 <dcoutts_> TFK, that's right, there is a seperate tarball, or you can browse online
12:28:16 <TFK> But you said yourself that the API has been altered. Is there a fresh tarball?
12:28:25 <dcoutts_> the 0.9.8 docs are not linked from the documentation web page yet but you can figure out the link
12:28:53 <dcoutts_> TFK, I don't understand. the API has been altered since 0.9.7
12:28:56 <TFK> Cleverly hidden ;-)
12:29:08 <TFK> Yup, thanks, I got it now.
12:29:34 <dcoutts_> gotta go..
12:36:59 * ski watches very happy people singing and jumping, on TV
12:49:42 * ski wonders how one gets so .. happy ..
12:49:54 <dbremner> ski - morphine?
12:50:27 <ski> somehow, i doubt they've been taking that ..
12:52:06 <ski> (or, wait .. did you mean morphine, the debugging env for mercury ?)
12:53:16 <lispy> people have silly acronyms
12:53:25 <lispy> or names for projects rather
12:53:57 <lispy> here at IBM we have an IM chat bot specifically for decoding internal acronyms
12:54:08 <lispy> and that makes me laugh
12:54:11 <lispy> out lound
12:54:15 <lispy> loud*
12:55:48 * Khisanth wonders if the pentagon has something similar
13:08:49 <kzm> @acronym FNORD
13:08:50 <lambdabot> Unknown command, try @listcommands.
13:08:56 <kzm> Guess not.
13:09:05 <ski> @wtf FNORD
13:09:09 <olliej> hehe
13:09:10 <lambdabot> No match for "FNORD".
13:09:16 <olliej> what???
13:09:42 <ski> @help wtf
13:09:43 <lambdabot>  @help <command> - ask for help for <command>
13:09:49 <ski> @help @wtf
13:09:50 <lambdabot>  @help <command> - ask for help for <command>
13:09:56 <ski> bah
13:10:03 <ski> @wtf WTF
13:10:04 <olliej> help isn't obviously helpful it seems :)
13:10:05 <lambdabot> No match for "WTF".
13:10:05 <kzm> @wtf help
13:10:07 <kzm> :-)
13:10:08 <lambdabot> *** "help" wn "WordNet (r) 2.0"
13:10:08 <lambdabot> help
13:10:08 <lambdabot>   n 1: the activity of contributing to the fulfillment of a need
13:10:08 <lambdabot> or
13:10:08 <lambdabot>     furtherance of an effort or purpose; "he gave me an
13:10:09 <lambdabot>     assist with the housework"; "could not walk without
13:10:11 <lambdabot>     assistance"; "rescue party went to their aid"; "offered
13:10:13 <lambdabot> [31 @more lines]
13:10:21 <olliej> @wtf am i doing?
13:10:26 <lambdabot> *** "Am" wn "WordNet (r) 2.0"
13:10:26 <lambdabot> Am
13:10:26 <lambdabot>   n 1: a radioactive transuranic metallic element; discovered
13:10:26 <lambdabot> by
13:10:26 <lambdabot>     bombarding uranium with helium atoms [syn: {americium},
13:10:27 <lambdabot>     {atomic number 95}]
13:10:27 <olliej> ooh
13:10:29 <lambdabot>   2: a master's degree in arts and sciences [syn: {Master of Arts},
13:10:31 <lambdabot> [29 @more lines]
13:10:52 * ski points finger at olliej
13:11:01 <kzm> So which is it?  A radioactive metal, or a master's degree?
13:11:19 <olliej> hehe
13:11:24 <ski> both, you dummy person !
13:11:25 <kzm> If you're bombarding uranium with ions, you could be in trouble.
13:11:31 <kzm> :-)
13:25:16 * ski considers going to sleep in time
13:47:37 * TFK has a working GTK prototype!
14:00:35 <Itkovian> nice!
14:01:45 <TFK> Yup. Now to the hard part of sockets and threading.
14:02:46 <Lemmih> What are you prototyping?
14:04:32 <TFK> Well, "prototype" isn't a very good word. I'm writing a painfully simple IRC client, and the GUI for it works. (Of course, I have only *very* basic operations atm...)
14:04:50 <TFK> But, one step at a time...
14:12:31 <lispy> TFK: simple is good with irc
14:12:35 <lispy> in my opinion
14:13:04 <TFK> Well, this is one is *very* simple. It's basically a challenge.
14:13:11 <TFK> I've never done sockets before, or threading.
14:13:49 <TFK> I've never done IRC before, I've just begun browsing the RFC :-/
14:27:04 <blackdog> shapr? You around?
14:27:26 <lispy> TFK: it can actually be easier to make a bot if you're learning irc RFC
14:27:39 <lispy> because the bot doesn't have any UI needs ;)
14:27:45 <Igloo> Does anyone know how I make a new package.conf file with ghc-pkg?
14:27:56 <TFK> I'm not, really. As I said, a challenge was issued, and I'm answering it ;-)
14:28:13 <lispy> TFK: well, good luck
14:28:23 <basti_> hey
14:28:29 <TFK> Speaking of IRC bots, I'm yet to tinker with lambdabot.
14:28:36 <basti_> had anyone ever running fudgets recently?
14:28:36 <TFK> lispy, luck is not a factor :-)
14:28:42 <Igloo> All I can get it to do is tell me it doesn't exist
14:29:24 <lispy> TFK: well, have fun then ;)
14:30:21 <TFK> lispy, heh, thanks :-)
14:31:36 <lispy> i was writting a bot in lisp but i got side tracked and never went back to it
14:31:45 <lispy> i have he frame work, it logs in, but it doesn't do anything
14:31:59 <lispy> but i used someone else's irc lib
14:32:22 <lispy> my goal was to make a bot lib on top of the irc lib
14:33:03 <lispy> i wanted to make a megahal style conversation bot, but i was having a very hard time figuring out the algo from the reference implemenation (which was in C)
14:35:34 <TFK> An IRC lib sounds useful.
14:35:43 <lispy> i also realized that megahal isn't that good at conversation
14:36:15 <TFK> Anyway, all this client is supposed to do is to connect to a single channel (#python on this network) and chat there. Nothing else, no fault tolerance, no nothing. See it as an excersize in "how many lines of code will this take" ;-)
14:36:21 <lispy> if you want to use the one i found as a reference it's called cl-irc
14:36:37 <lispy> ah
14:39:02 <lispy> i once thought it would be cool to have an encrypted irc client and server, but then i realize you can just use ssh, and what's the point because irc is often publicly logged ;)
14:39:50 <mflux_> lispy, simply integrate support for storing encrypted logs
14:40:08 <mflux_> (and nothing else ;))
14:40:46 <lispy> but if the people can view the data on their screen then in principle they can log it in plain text
14:40:51 <mflux_> sure
14:40:53 <mflux_> but they won't bother
14:41:00 <mflux_> if the convenient builtin mechanism is there
16:41:53 <yosemite> is there a pdf or ps version of the hierarchical libs?
16:43:01 <Heffalump> I don't think ghc can execute postscript yet :-)
16:43:27 <yosemite> haha
16:43:32 <yosemite> I mean the docs
16:43:36 <yosemite> I should have said
16:43:58 <Heffalump> http://www.haskell.org/ghc/docs/latest/ seems to have them
16:44:14 <Heffalump> oh no,that's hslibs, not the hierarchical libraries
16:44:22 <Heffalump> So no. Dunno why, I guess haddock can't generate that yet.
16:45:19 <yosemite> weird
16:46:17 <yosemite> I guess I could take the html and xslt it to something
16:49:42 <Heffalump> http://www.haskell.org/haddock/ - there is partial support for generating DocBook
16:49:49 <Heffalump> you might be best off fixing that support completely
16:49:59 <yosemite> yeah
16:50:04 <Heffalump> (in the sense of it being some combination of quickest for you and most useful for other people)
16:50:26 <yosemite> true
17:17:34 <heatsink> geh
17:17:37 <heatsink> Pancito doesn't build
17:25:52 <heatsink> what does this error mean? Something is amiss; requested module name Pancito.Pancito2 differs from name found in the interface file Pancito2
18:37:59 * heatsink generates its first image with pancito
19:02:37 <yain> hm
19:02:41 <yain> pancito looks cool.
19:06:03 <lispy> pancito?
19:06:08 <lispy> is that based on pan?
19:06:20 <yain> it's page says that it's inspired by pan
19:06:59 <lispy> cool
19:10:55 <lispy> what does the author have against "g BcmnDHOrA=bAQW8AIoHF=B
19:10:59 <lispy> sigh
19:11:06 <lispy> that didn't paste correctly
19:11:41 <lispy> what does the author have agaist, "Israeli citizens living in Israel"
19:12:12 <lispy> in fact, that clause goes way against the gpl
19:12:25 <lispy> and how can you make a restriction like that anywhay
19:12:27 <heatsink> what? where?
19:12:35 <lispy> http://www.acooke.org/jara/pancito/RedSquare1.pdf
19:12:38 <lispy> look at the very end
19:12:51 <lispy> the last paragraph
19:13:23 <yain> heh
19:13:26 <yain> weird.
19:14:49 <yain> i looks like a bad joke.
19:15:00 <seidan> quite
19:15:02 <heatsink> I thought author was chilean
19:15:28 <heatsink> He did make a map of military spending, per capita and by country...
19:17:43 <lispy> i don't get the humor
19:18:40 <yain> this "red square" image is great.
19:19:06 <lispy> it is
19:19:27 <lispy> i just got this urge to write a C compiler "just to do it"
19:19:55 <lispy> it's a weird urge
19:20:07 <lispy> instead i should probably go make dinner...
19:20:11 <lispy> but it's hard to fight an urge
19:20:21 <yain> as long as you aren't going to write it in c it's ok
19:20:26 <lispy> hehe
19:20:32 <lispy> i was thinking of writing it in Haskell
19:20:35 <lispy> or lisp
19:20:39 <lispy> but not C
19:22:43 <yain> "Pancito 2.2 Another minor release. Apart from random, undocumented changes (no-one uses this, as far as I know, apart from me).."
19:22:47 <yain> ^^ nice attitude
19:23:35 <bitshifter> Quick question about parsec, I'm trying to parse a file that contains 0 or more occurances of [record type 1] [record type 2] followed by an optional [record type 1]
19:24:17 <bitshifter> I am having difficulty figuring out how get parsec to select the right rule
19:25:47 <bitshifter> I have a parser that gets [record type 1] and one that gets [record type 2] and one that gets a pair [record type one] followed by a [record type 2]
19:27:04 <bitshifter> If I use the many operator on the part that parser that gets a pair but it fails when it sees a [record type 1] without a [record type 2] and bails out of my program
19:27:10 <lispy> i want to learn how to use parsec...
19:27:18 <lispy> maybe that's how i should make a C compiler
19:27:54 <Pseudonym> Eeek.
19:28:01 <Pseudonym> Sorry, this is in appropriate.
19:28:02 <bitshifter> I started learning parsec this morning for a project at work, for the most part its quite easy and nice
19:28:06 <yain> parsec is parser generator?
19:28:09 <heatsink> okay, so you mean (AB*)A?
19:28:13 <heatsink> erm
19:28:17 <heatsink> okay, so you mean (AB)*A?
19:28:21 <bitshifter> yeah
19:28:24 <Pseudonym> If you want to change the world, do what Bram Moolenaar does.
19:28:57 <heatsink> Okay
19:29:06 <lispy> yain: http://www.cs.uu.nl/~daan/parsec.html
19:29:24 <yain> ic
19:29:26 <heatsink> I'd say, look at it this way:
19:29:31 <lispy> yain: you actually right the parser by hand, but it's much like giving the bnf iirc
19:29:52 <heatsink> (1) what is the BNF for what comes after A
19:29:56 <yain> well parsing is like an easiest part in making a compiler :P
19:29:57 <heatsink> (2) what is the BNF for what comes after B
19:30:15 <heatsink> from that you should be able to write the parser straightforward
19:30:28 <lispy> yain: then we should elegant ways of doing it ;)
19:30:54 <lispy> and even if that's the easiest part, lots of compilers have parsing bugs
19:31:01 <lispy> even gcc
19:31:09 <yain> like what?
19:31:21 <lispy> all the ones i know of have been fixed :)
19:31:25 <yain> gcc hardly have any _parsing_ bugs in current mainline
19:31:26 <heatsink> but they don't have nearly as many parsing bugs as opti bugs :)
19:31:30 <lispy> but even 3.x had some bugs
19:31:58 <yain> gcc have a lot of code generation bugs :P
19:32:42 <lispy> gcc needs to be rewritten ;)
19:32:44 <lispy> in haskell ;)
19:32:50 <heatsink> bitshifter: you got it?
19:33:50 <bitshifter> heatsink: not really, every way I've tried so far has blown up on one simple case or another
19:35:50 <heatsink> stringThatStartsWithA = A | A++stringThatStartsWithB
19:35:56 <heatsink> stringThatStartsWithB = B | B++stringThatStartsWithA
19:36:03 <heatsink> right?
19:44:36 <bitshifter> I think I may need to go sleep on this, its just not comming to me today
19:45:21 <heatsink> aokay
19:45:29 <heatsink> good luck on't
19:45:38 <lispy> is this the grammar? P -> AB | S, S -> A | P
19:46:20 * lispy should have dinner and then play with parsec
19:46:53 <bitshifter> in something akin to regular expressions (AB)*A?
19:47:21 <bitshifter> as heatsink wrote earlier
19:47:41 <heatsink> bitshifter, that works
19:48:29 <heatsink> I think the BNF like thing I wrote is easier to render in parsec though
19:48:34 <seafood> heatsink: There is a cross platform implementation of Pan too.
19:48:47 <heatsink> one that doesn't use .NET?
19:48:54 <heatsink> I didn't know that.
19:49:26 <lispy> seafood: i didn't think that version was ready et
19:49:38 <lispy> conal would know for sure, but he's not around
19:49:39 <seafood> It is now.
19:49:43 <lispy> sweet
19:49:47 <seafood> And how do I know that?
19:49:54 <seafood> I'm the one who wrote it.
19:49:58 <lispy> hehe
19:50:00 <lispy> url?
19:50:11 <seafood> http://www.cse.unsw.edu.au/~sseefried/pan/
19:50:39 <lispy> thanks
19:50:42 <heatsink> bitshifter: these are all valid, right? A AB ABA ABAB ABABA ABABAB
19:50:47 * lispy adds pan to his list of things to play with tonight
19:51:00 <lispy> ABAB shouldn't be valid
19:51:05 <heatsink> What is with UNSW and haskell?
19:51:05 <bitshifter> heatsink: yes
19:51:21 <lispy> wasn't it described as (AB)*A
19:51:32 <bitshifter> the ending a is optional
19:51:35 <wli> They seem to use Haskell for educational purposes.
19:51:36 <lispy> oh
19:51:39 <heatsink> (AB)*A?
19:51:50 <lispy> oh, that kind of '?'
19:51:55 <heatsink> yes :)
19:51:56 <lispy> i thought it was a question
19:52:02 <bitshifter> hehehe
19:52:27 <bitshifter> I understand the grammar, but my brain just isn't letting me translate it into parsec at the moment
19:52:33 <bitshifter> been up too long
19:52:57 <heatsink> here's how I would render it: ASTRING = A | A BSTRING; BSTRING = B | B ASTRING
19:54:25 <heatsink> you can also do it the other way
19:54:32 * bitshifter goes over to his code window...
20:03:49 <bitshifter> heatsink: have you much experience with parsec itself?
20:05:38 * heatsink has used it several times
20:06:01 <heatsink> I think I'm familiar with it
20:10:45 <bitshifter> I'm obviously implementing something wrong, I have code to do do what you sugested and it is stopping after it produces the first A in input that contains ABA
20:10:58 <bitshifter> I'm not sure how to make it keep going
20:11:35 <heatsink> show me?
20:13:33 <bitshifter> Is it alright if I paste in here?
20:14:13 <heatsink> if long, use the haskell wiki paste
20:14:52 <dons> @paste
20:14:53 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
20:15:06 <bitshifter> 12 lines for a snippet
20:16:35 <heatsink> which is yours?
20:18:04 <bitshifter> I put it at the end of the page
20:22:52 <heatsink> State is inconsistent when you get to the second branch of a choice.
20:23:28 <bitshifter> do I need to put try in front of the whole thing?
20:23:41 <heatsink> (string "Blue" <|> string "Black") won't match "Black"
20:24:28 <heatsink> In this case, no, because "Start" and "End" do not start with anything in common.
20:25:01 <heatsink> You are doing redundant reads though
20:25:48 <heatsink> (do {a; b}) <|> do a) sometimes does a twice
20:26:45 <lispy> parsec sounds hard to use
20:26:51 <heatsink> do {tmp <- a; (b <|> return tmp)} doesn't do a twice
20:26:55 <lispy> ah
20:27:10 <bitshifter> lispy: Not really, I'm just braindead today
20:27:34 * lispy is braindead 24-7
20:27:50 <bitshifter> Well, I've been at work for 12hrs now, time for me to go home and hit the sack
20:27:50 * heatsink is only braindead on workdays
20:28:04 <lispy> bitshifter: yeah
20:28:10 <lispy> how do you not starve when you work taht long
20:28:23 <lispy> i hate putting money into the vending machines...
20:28:44 <lispy> and there is hardly anything i will eat
20:28:45 <bitshifter> I have a gift(curse?) of not feeling hunger
20:28:51 <lispy> ah
20:29:04 <bitshifter> I've forgotten to eat for days before
20:29:06 <lispy> i guess if i'm engrossed i can go without food for a while
20:29:16 <bitshifter> the longest stretch I've forgotten to eat has been 3 days
20:29:33 <lispy> i'm guessing you are very thin
20:30:23 <bitshifter> I was at the time, my girlfriend has been reminding me to eat for the past year so I've put on a bit of weight
20:30:25 <lispy> i've developed a picky diet in the last year or two
20:31:02 <lispy> recently i've started getting sick the day after i eat anything fried or fatty
20:31:18 <lispy> basically junk food makes me sick
20:31:20 <bitshifter> Metabolism shifts are fun!
20:31:35 <bitshifter> Well, I can still eat the junk for better or worse
20:31:57 <heatsink> but, how can you think after not eating for so long?
20:32:06 <lispy> yeah
20:32:24 <lispy> i like to snack on fruit to keep my blood sugar at a nice happy level
20:33:36 <lispy> my thing with junk food is starting to worry me tho
20:33:41 <lispy> 6months is a long time
20:33:46 <lispy> at first i just thought i was getting suck
20:33:48 <lispy> er sick
20:34:13 <lispy> because i'd wake up with diarreah(sp?) and too much stomach acid
20:34:31 <lispy> but the doctor told me to just take over the counter stuff for the symptoms
20:34:34 <lispy> and sent me home
20:34:46 * lispy has the worst luck getting through to doctors
20:36:10 <lispy> the next time they try to send me home without doing any tests i'm going to say, "I came in here because I have a problem.  Please do some objective tests on my body.  Something is wrong."
20:36:31 <lispy> and go to a different doctor if that doesn't work ;)
20:38:02 * lispy notes that talking about bowel function in #haskell kills the conversation
20:38:20 * lispy blushes and goes back to idling
20:39:15 <bitshifter> heatsink: Practice I guess
20:39:37 <bitshifter> lispy: At least you *have* to eat right?
20:39:55 <bitshifter> and with that I'm going home... I need some sleep
20:48:38 <yain> damn why python doesn't have composition
20:48:45 <yain> it's such a handy feature
20:49:36 <lispy> yain: you mean (.) ?
20:49:57 <lispy> or do you mean the automatic curry stuff like map (+1) xs
20:49:58 <yain> yep
20:50:09 <lispy> it shouldn't be hard to write (.) in python
20:50:10 <yain> no just function composition.
20:50:17 <lispy> should it?
20:50:23 <lispy> i've seen a version for lisp
20:50:36 <lispy> and i've heard other than syntax python and lisp are similar
20:51:05 <yain> hm.
20:51:49 <yain> i'm not sure how to do it.
20:51:58 <lispy> do you know the haskell definition?
20:52:42 <lispy> iirc (f . g) x = f ( g x)
20:53:11 <yain> yep.
20:53:22 <lispy> i suspect that without the automatic currying it will not gain you much
20:54:22 <yain> less typing.
20:54:37 <lispy> i don't know python syntax or i would continue the example ;)
20:55:35 <lispy> (defun compose (f g) (lambda (x) (f (g x))))
20:55:42 <lispy> i think that will do it in lisp
20:55:51 <yain> well you can do same in python
20:55:51 <lispy> but i didn't test it
20:56:14 <yain> but without ability to define operator it doesn't saves much typing :P
20:56:15 <heatsink> def compose(f, g): def comp(x): f(g(x)); return comp
20:56:32 <heatsink> def compose(f, g): def comp(x): return f(g(x)); return comp
20:56:52 <lispy> yain: yeah
20:57:04 <lispy> yain: i was afraid of that
20:57:12 * lispy is fearful
20:57:47 <yain> compose = lambda x, y: lambda z: x(y(z))
20:57:51 <yain> that's better
20:57:58 <yain> but it doesn't help much still
20:57:59 <yain> :/
20:58:43 * yain doesn't relly uses "def" in python
21:00:54 <yain> if only you could extend 'function' object somehow...
21:04:42 <seidan> perhaps define composition as a decorator...
21:07:03 <Khisanth> lambda? wasn't that one of the things that were going away?
21:12:44 <lispy> a latex implemenation in haskell wouldn't be a bad ting
21:13:04 <lispy> i wonder if parsec would be able to handle latex
21:13:13 <lispy> i've heard it's an odd grammar
21:15:53 <lispy> oh, maybe i should make a parser for email
21:16:01 <lispy> that could be handy
21:16:09 <lispy> and probably easy
21:32:52 <lispy> umm...
21:33:15 <lispy> i'm having problems telling ghc where to find parsec
21:36:27 <lispy> oh, the documentation is not as helpful as the main page
21:36:47 <lispy> if i use the hierarchical module name it's painless
21:37:33 <lispy> ToyParser.o(.text+0x145): In function `__stginit_Main_':
21:37:33 <lispy> : undefined reference to `__stginit_TextziParserCombinatorsziParsec_'
21:37:44 <lispy> what does that mean?
21:37:58 <Pseudonym> The central algorithm in TeX is very easy to write in Haskell.
21:38:04 <Pseudonym> If you've got lazy evaluation, that is.
21:38:52 <lispy> that's good to hear
21:39:08 <Pseudonym> Well it's a dynamic programming problem, basically.
21:40:00 <Lunar^> lispy: That means the parsec library is not found during linking
21:40:52 <lispy> Lunar^: i need to add the appropriate -L?
21:41:15 <Cale> lispy: -package parsec ?
21:42:03 <lispy> Cale: yes!
21:42:04 <lispy> thanks
22:20:11 <lispy> bitshifter: perhaps many or many1 would help your parsing of (AB)*A?
22:20:47 <lispy> write an AB parser, then use many abParser, to parse the (AB)* part
22:22:44 <ski> 'morning #haskell
22:22:56 <lispy> heh, good night #haskell
22:23:03 * lispy was just tucking in
22:23:44 <lispy> ski: i suspect we live in opposite time zones
22:24:01 <lispy> ski: what part of the world do you live in?
22:24:13 <lispy> i live on the west coast of north america
22:24:28 <ski> Europe,Sweden
22:24:54 <lispy> ah
22:25:07 <lispy> i work with a girl from sweden iirc
22:25:07 <ski> local time is 07:25
22:25:14 <lispy> nice
22:25:27 <lispy> 22:25 here
22:27:26 <kzm> 07:28
22:27:35 <kzm> Good morning, #haskell!
22:29:58 <ski> hi kzm
22:30:48 <ski> (msg lambdabot @hello
22:32:24 * ski wonders if pair type with first,second,(***) in Arrow class is a premonoidal functor 
22:36:36 <yain> anyone have an example of xemacs config which puts every open file on gutter?
22:37:49 <shapr> Gooood morning #haskell!
22:37:56 <yain> hi shapr
22:38:10 <shapr> @timein Stockholm
22:38:13 <lambdabot>  Friday, June 24, 2005 at 7:39:16 AM CEST
22:38:29 * shapr hops furiously
22:40:34 <ski> moin shapr
22:40:39 <shapr> y0
22:41:54 <wilx> @timein Prague
22:41:56 <lambdabot>  Friday, June 24, 2005 at 7:42:59 AM CEST
22:41:58 <wilx> :)
22:42:00 <wilx> Nice.
22:43:22 <shapr> How's code this fine morning?
22:44:31 <dcoutts_> I find it's unusually bright and early.
22:45:08 <dcoutts_> @timein London
22:45:10 <lambdabot>  Friday, June 24, 2005 at 6:46:13 AM BST
22:45:21 <dcoutts_> yes, very early
22:46:06 <shapr> Why are you up so early?
22:46:15 <shapr> Unicycling addiction requires it?
22:46:25 <dcoutts_> if you cant sleep, at least you can code :-)
22:46:32 <shapr> True that.
22:46:56 <dcoutts_> I'm preparing the Gtk2Hs 0.9.8 release announcement :-)
22:47:16 <shapr> w00
22:47:26 <dcoutts_> and getting a 0.9.8 ebuild into gentoo, and updating the docs... etc.. etc..
22:48:17 <seidan> aheller, i was just checking packages.gentoo.org... Think I'll try gtk2hs again, now that the memory requirements are down.
22:48:47 <dcoutts_> seidan, well wait just a sec, I've not got the new ebuild in yet
22:49:21 <seidan> yes, I figured that. I'm both patient and busy, so I'll wait!
22:49:30 <dcoutts_> it'll be in in a moment and then you'll need to wait an hour or so for it to get to the rsync mirrors
22:50:11 <dcoutts_> or if you're impatient you can get the ebuild: http://haskell.org/~gentoo/gentoo-haskell/portage/dev-haskell/gtk2hs/gtk2hs-0.9.8.ebuild
22:54:10 <dcoutts_> seidan, ok it's in, try syncing in an hour or so, it's only marked ~x86 at the moment, hope that's ok
22:54:11 <seidan> dcoutts, what's the roadmap for integrating GL?
22:54:54 <dcoutts_> I'm going to try it quite soon, we'll see how it goes, if there are few problems then it'll be in the next release
22:54:55 <seidan> yeah, I have everything haskell related marked in package.keywords.
22:55:05 <seidan> cool.
22:55:43 <dcoutts_> cairo will probably have to wait a bit longer, afterall it's not much good until Gtk+ 2.8 comes out
22:56:22 <seidan> that's the new X vector graphics lib, right?
22:56:30 <dcoutts_> yes
22:57:28 <dcoutts_> well really it's the new general purpose graphics lib, it has X, OpenGL, Pdf, Ps, SVG, PNG backends
22:57:54 <dcoutts_> and it does vector stuff and bitmap compositing
23:00:14 <dcoutts_> TFK, ping
23:23:50 <Pseudonym> G'day.
23:25:45 <shapr> g'day Pseudonym
23:45:14 <shapr> hoi rtega
23:45:18 <shapr> How's code?
23:54:48 <shapr> hoi Itkovian
23:54:57 <Itkovian> hi shapr.
23:55:03 <Itkovian> I hope it cooler where you are
23:55:32 <shapr> It's warm enough that I'm wearing exactly one small piece of clothing.
23:55:42 <shapr> Though that's probably TMI.
23:55:45 <earthy> quite
23:57:08 <rtega> shapr: the code is hot ;)
23:57:24 <shapr> hah, Higher-Order Typed!
23:58:21 <rtega> voila
23:59:23 <adept> good(?) morning(?)
23:59:26 <shapr> Hey adept, long time no see.
23:59:35 <adept> shapr: indeed, indeed
23:59:36 <shapr> How's code in the big city?
23:59:51 <adept> shapr: do you plan to take a swing at icfp contest this year?
