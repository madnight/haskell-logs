00:03:30 * boegel yawns
00:04:23 <Lemmih> Morning, #haskell.
00:04:36 <kaol> @moo rning
00:04:37 <lambdabot>              (__)
00:04:37 <lambdabot>              (oo)
00:04:37 <lambdabot>        /------\/
00:04:37 <lambdabot>       /|  |/  |
00:04:37 <lambdabot>      / |  [) ||
00:04:38 <lambdabot>     *  ||----||
00:04:40 <lambdabot>        ^^    ^^
00:04:42 <lambdabot>   This cow was given to
00:04:44 <lambdabot> Hugh Hefner for his Birthday
00:06:52 <boegel> I'm not sure I'm getting this one...
00:07:29 <dons> that looks like a bunny
00:09:36 <boegel> ooooooooooooooooooooh :) okay, stupid me
00:10:02 <boegel> I was looking at it as an R upsidedown, and what wondering what  has to do with Hugh Hefner :)
00:10:10 <boegel> s/what/what R
00:10:12 <kaol> that's the saddle
00:17:33 <Itkovian> meuning #haskell
00:18:36 <boegel> y0 Itkovian
00:24:21 <Itkovian> shouldn't you be studying?
00:24:45 <boegel> I am !
00:24:53 <boegel> and you sound like my mother :)
00:25:16 <boegel> shouldn't YOU be working? :)
00:25:26 <kaol> @moo ther (I'll get bored of this soon, I promise)
00:25:27 <lambdabot>     *        (__)
00:25:27 <lambdabot>      \       (oo)
00:25:27 <lambdabot>       \-------\/
00:25:27 <lambdabot>        | ==$ ||
00:25:27 <lambdabot>        ||----||
00:25:27 <lambdabot>        ^^    ^^
00:25:29 <lambdabot> Old "One Arm" belonged
00:25:31 <lambdabot>   to Ceasar's Palace
00:25:51 <Itkovian> I am working
00:25:53 <Itkovian> lol
00:27:08 <boegel> no you're not :p
00:27:34 <Itkovian> yes I am.
00:28:01 * boegel will quit arguing with Itkovian now
00:38:09 * Itkovian skims through last nights conversation
00:41:07 * boegel notices Itkovian isn't working afterall
00:41:49 <Itkovian> but I am :-)
00:42:09 <Itkovian> not my fault the analysis is slow
00:42:31 <boegel> who created the analysis ?
00:42:38 <Itkovian> R
00:42:53 <Itkovian> let's just say the dataset is _large_
00:44:45 <boegel> that means you created the analysis, right ? :)
00:45:02 <boegel> yo nlv11757_ (what a nick :s)
00:45:14 <nlv11757_> huh?
00:45:20 <nlv11757_> what a nick :)
00:45:23 <nlv11757_> its nice
00:45:24 <nlv11757_> :P
00:45:32 <nlv11757_> hey boegel yourself
00:45:37 <dons> it's just difficult to type
00:45:47 <nlv11757_> hehe ok ok, ill change it
00:46:03 <nlv11757_> it defaults to my linux username, so there :)
00:46:30 <boegel> any reason why you chose that one ?
00:46:57 * boegel just discovered TMR has another meaning besides The Monad.Reader
00:47:14 <cpjvelde> it was a linux username assigned to me
00:47:27 <boegel> you're sometimes here under that name too, right ?
00:47:38 <dons> by an evil sys admin, I guess?
00:47:38 <boegel> I didn't know you where one and the same:)
00:47:57 <dons> oh, I guess users default to nameXYZ where XYZ are digits at my uni
00:48:16 <dons> and name is a practically random combination of letters
00:48:49 <cpjvelde> boegel, yeah this is my other linux username :P
00:49:11 <cpjvelde> and philips assigns every guest/student an nlvXXXXX nr
00:49:19 <cpjvelde> so at work this is my nick, at home its cpjvelde
00:49:25 <dons> there's more personality in "cpjvelde"
00:49:40 <dons> :)
00:49:44 <cpjvelde> hehe barely
00:49:59 <cpjvelde> @plugs fmap (+1) (Just 1)
00:50:00 <lambdabot> Just 2
00:50:04 <cpjvelde> @plugs fmap (+1) (Nothing)
00:50:06 <lambdabot> Nothing
00:50:15 <cpjvelde> ok fmap rule
00:50:16 <cpjvelde> s
00:50:54 <Itkovian> @type fmap
00:50:56 <lambdabot> fmap :: forall (f :: * -> *) b a.
00:50:56 <lambdabot>    (Functor f) =>
00:50:56 <lambdabot>    (a -> b) -> f a -> f b
00:51:58 <Itkovian> cpjvelde: so philips doesn't mind you chatting away all day?
00:53:41 * boegel leeps his mouth shut now
00:53:45 <boegel> s/leeps/keeps
00:56:16 <cpjvelde> Itkovian, im not chatting away all day
00:57:05 <cpjvelde> my days are long enough
01:03:30 <cpjvelde> @type fmap (,)
01:03:31 <lambdabot> fmap (,) :: forall (f :: * -> *) a b.
01:03:31 <lambdabot>     (Functor f) =>
01:03:31 <lambdabot>     f a -> f (b -> (a, b))
01:08:15 <_JusSx_> which module for managin date and time?
01:12:55 <boegel> _JusSx_: System.Time
01:22:23 <yoda-> How do i specify multiple variables in a "where" statement
01:22:38 <Itkovian> yoda-: you drop 'em on separate lines
01:22:47 <yoda-> it aint working...
01:22:54 <Itkovian> where huppel = foo
01:23:00 <Itkovian>          puppel = bar
01:23:03 <Itkovian> etc.
01:23:07 <yoda-> doesnt like it
01:23:10 <yoda-> sigh
01:23:19 <Itkovian> did you include sufficient white-space?
01:23:29 <Itkovian> paste yr code to the IrcPastePage
01:23:37 <Itkovian> @wikie IrcPastePage
01:23:39 <lambdabot> http://www.haskell.org/hawiki/IrcPastePage
01:23:39 <xerox> yoda- where { <var1> = <expr1> ; ... }
01:23:58 <Itkovian> http://www.haskell.org/hawiki/HaskellIrcPastePage
01:24:08 <yoda-> why does this language deal with whitespace so badly...
01:24:14 <xerox> You can substitute '{' and ';' with newline and proper indentation.
01:24:36 <xerox> Itkovian, wikie! :-)
01:24:53 <Itkovian> yeah yeah
01:24:57 <Itkovian> I noticed :-)
01:25:11 <Itkovian> yoda-: it doesn't deal badly with it.
01:25:50 <Itkovian> yoda-: if you want real useful whitespace, I recommend http://compsoc.dur.ac.uk/whitespace/index.php
01:26:03 <mflux> I guess it fails if someone has set their tab into some other length than 8?
01:26:13 <mflux> (and use tabs in the files, not spaces)
01:27:59 <yoda-> grrr
01:28:04 <yoda-> this is so lame
01:28:16 <Itkovian> not it isn't
01:28:20 <Itkovian> -t
01:28:38 <Itkovian> mflux: tabs are always a bad idea imo
01:28:43 <yoda-> only xerox 's worked
01:28:51 <yoda-> just wouldnt do it otherwise
01:28:54 <yoda-> stupid thing
01:29:10 <Itkovian> well, have you yet pasted yr code? I dont see anything
01:29:20 <xerox> yoda- now try to be consistent in your sobstitution of "{}" and ';' with newline and whitespace-indentation.
01:29:53 <mflux> itkovian, I don't deny that, but it might bite with haskell's indentation without people being aware of that?
01:30:14 <xerox> mflux, I think editors should be <grin>
01:30:37 <dons> yi.patch | darcs send ;)
01:30:50 <Itkovian> go go go
01:30:53 * xerox coughs
01:30:59 <yoda-> what should { and ; be substituted with just newline?
01:31:38 <Itkovian> just paste the bloody code, we'll correct it so you can see with your own eyes what you should do.
01:31:49 <yoda-> where do i paste
01:31:56 <yoda-> i got a wiki to edit...
01:32:01 <yoda-> isnt there a form to chuck it in
01:32:04 <Itkovian> @wiki HaskelIrcPastePage
01:32:05 <lambdabot> http://www.haskell.org/hawiki/HaskelIrcPastePage
01:32:07 <yoda-> or u want me to edit the wiki
01:32:15 <Itkovian> yes. add yr stuff at the top
01:32:21 <Itkovian> mention yr name
01:32:26 <Itkovian> yr nick that is
01:33:54 <xerox> yoda-, reload the wikipage, I added something -- I hope it helps.
01:34:14 <SM_ax> anybody using hSQL?
01:34:31 <Lemmih> Yep.
01:35:43 <yoda-> http://www.haskell.org/hawiki/HaskelIrcPastePage?action=show
01:35:50 <SM_ax> Lemmih, what version?
01:36:02 <Itkovian> exactly xerox ...
01:36:19 <Lemmih> SM_ax: 1.4 with GHC 6.4
01:36:20 <Itkovian> I was just on my way typing the same stuff
01:36:35 <mflux> that font isn't exactly the best for haskell's indentation either ;)
01:36:55 <xerox> mflux, do you actually use non-fixed-width font for coding?
01:37:07 <SM_ax> Lemmih, hmm... interesting...  I can't compile this exact version with this exact GHC
01:37:15 <mflux> xerox, isn't that non-fixed-width on the web page?
01:37:18 <mflux> no, I don't
01:37:58 <mflux> oh, I guess one can properly annotate the page to use fixed width
01:38:18 <Lemmih> SM_ax: Try: http://scannedinavian.org/~lemmih/packages/HSQL-1.4.tgz
01:38:22 <mflux> xerox, actually it could be nice to do that, but the editor would need to play ball
01:39:10 <xerox> mflux, you can put your code in blocks like: {{{#!syntax haskell \n <your-code-here> \n }}} (where \n are proper newlines)
01:40:26 <cpjvelde> hey Itkovian, does the university let you also chat all day :)
01:41:05 <Itkovian> yes, they do :-)
01:41:08 <Itkovian> lol
01:41:48 <boegel> good university's allow chatting and provide money for party's
01:42:43 <cpjvelde> gj :)
01:43:39 <cpjvelde> me mentor trusts that im an adult knowing his responsibility...as it should be
01:43:42 <cpjvelde> me=my
01:43:54 <xerox> yoda- did you work out your problems?
01:44:08 <xerox> 'morning JaffaCake
01:44:16 <yoda-> well kinda xerox
01:44:18 <JaffaCake> morning ;)
01:44:48 <yoda-> i worked out that somethign that i am using is useless at handling whitespace
01:44:57 <SM_ax> Lemmih, how to compile this? configure does not create makefile...
01:44:59 <yoda-> so i am using ;
01:45:39 <xerox> yoda-, what editor are you using?
01:46:13 <yoda-> gedit
01:46:20 <yoda-> <3 eyecandy
01:46:44 <xerox> :-)
01:47:25 <Lemmih> SM_ax: It's a Cabal package.
01:47:39 <Lemmih> SM_ax: Don't run the configure script yourself.
01:48:16 <Lemmih> SM_ax: 'runhaskell Setup.lhs {configure --enable-what-you-want | build | install}'
01:48:57 <Lemmih> @google GHC Cabal documentation
01:48:59 <lambdabot> http://www.haskell.org/ghc/documentation.html
01:57:49 <Itkovian> yoda-:  consider using vim -- or yi :-)
01:58:29 <SM_ax> Lemmih, thanks a lot, that worked!
02:01:12 <SM_ax> @paste
02:01:13 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
02:02:32 * xerox hits Itkovian with haskell-mode.el
02:02:43 * Itkovian ducks
02:11:44 <dons> @seen basti
02:11:46 <lambdabot> I haven't seen basti.
02:11:48 <dons> @seen basti_
02:11:48 <lambdabot> I saw basti_ leaving #haskell 10 hours, 39 minutes and 22 seconds
02:11:48 <lambdabot> ago.
02:13:36 <Lemmih> SM_ax: You're welcome.
02:19:45 <dblhelix> boegel: how's H3D going?
02:20:18 <boegel> dblhelix: pretty quiet for now I guess :) I'm studying, not much time
02:20:39 <boegel> but I'm guessing I'll implement a L-system first and go on from there
02:20:57 <dblhelix> seems like a good idea
02:21:07 <boegel> also, there has been some response of the Ogre3D forum about a C interface for Ogre3D, so that can be used from within Haskell
02:21:23 <boegel> now it's written in C++, and Haskell doesn't support that apperently
02:21:42 <dblhelix> nope
02:21:45 <Lemmih> @wiki Hacanon
02:21:46 <lambdabot> http://www.haskell.org/hawiki/Hacanon
02:21:48 <Lemmih> ^^ (:
02:22:48 <dblhelix> cool\
02:22:49 <boegel> Lemmih: any chance they will support C++ any time soon ? :) :p
02:23:04 <Lemmih> They who?
02:23:30 <boegel> Hacanon
02:23:57 <dblhelix> boegel: are you planning to stuck to Haskell 98 for H3D, are do you go for a GHC-only implementation?
02:24:07 <Lemmih> Hacanon does support C++... Generating binding to C++ libraries is its primary task.
02:24:17 * boegel has no idea
02:24:36 <boegel> Lemmih: so I'd be able to use Ogre3D using Hacanon ?
02:25:13 <Lemmih> Probably. Haven't tested it on such a large library.
02:25:48 <boegel> hmm, sounds very interesting :)
02:25:54 <boegel> pitty I have to study :(
02:27:44 * boegel is parsing his HRay code in C to see how the performance compares
02:36:33 <Itkovian> boegel: do you have _large_ scene descriptions? online? I'd like to have those that take > 1 minute to complete.
02:36:51 <boegel> Itkovian: using perlin textures can help
02:37:11 <Itkovian> How would an article on haskell low-level performance, i.e. CPU level stuff, be received at a conference like ICFP? would they be interested?
02:37:23 <boegel> the trans2.hry takes almost 9 minutes to render on my machine, because of the extensite use of Perlin textures
02:37:37 <Itkovian> what machine is that?
02:37:57 <boegel> laptop, Pentium-M 2Ghz with 512mb of RAM
02:38:01 <Itkovian> ok
02:38:15 <boegel> Itkovian: I could cook up a big scene for you
02:38:27 <Itkovian> nono, 9 mins is sufficient :-)
02:38:29 <boegel> or you can just increase the resolution of the image you want :)
02:38:36 <Itkovian> true
02:39:06 <boegel> that will help _a lot_, because it will increase exponentially
02:41:09 * boegel leaves to cook lunch
02:42:39 * boegel returns
02:42:55 <boegel> daddy will cook lunch :)
02:43:35 <Itkovian> heh
02:43:42 <sylvan> boegel: Raytracing is O(w*h*log n) where w and h are the dimensions of the viewport, and n is the number of primitives.. (assuming a space partitioning technique)... Anyway, time shouldn't increase exponentially, it's linear with respect to both width and height, and square if you only have one size parameter for both of these..
02:44:50 <sylvan> (interestingly rastering is O(n) in the number of primitives, which means that ray-tracing should, sooner or later, replace existing rasterizing solutions for games and the like
02:45:17 <boegel> sylvan: wow, impressive ;) I meant square actually, because doubling the resolution results in more than doubling the execution time
02:46:01 <boegel> sylvan: what's rastering ? another render technique ? something like Warnok's method ?
02:46:26 <boegel> and I'm not using a space partitioning technique (yet) in HRay
02:47:33 <sylvan> rastering is when you bascially take a triangle, transform it into view space, and fill it with pixels based on the texture.. That's what all the current 3D hardware does
02:47:38 <sylvan> (and thus, what all games do)
02:50:05 <boegel> Warnok's method is similar, it divides the window in equal parts, and tries to fill in the parts with some color.. if one part is too complex, it'll divide it further
02:53:08 <boegel> Lemmih: how does Hacanon work ? do you just let it go on some C++ library to generate bindings, or doesn't it work that way?
02:54:09 <Lemmih> boegel: It's a TH preprocessor.
02:55:10 <Philippa_> so you do the equivalent of $(import "foo.h"), I assume?
02:55:28 <boegel> Lemmih: meaning ... ?
02:55:52 <boegel> TH = Template Haskell, okay, but what does that mean ?
02:55:54 <Lemmih> Yeah. It's just a bit more complicated since you want to control which objects are imported and how they should be marshalled/unmarshalled.
02:56:31 <boegel> Lemmih: sounds complicated
02:57:40 <Lemmih> It tries to guess everything by itself but you sometimes have to give it some hints.
02:57:45 <Philippa_> how well does it work so far? Would I be satisfied if I grabbed it and knocked up, say, an FMOD binding?
02:58:42 <sylvan> FMOD has a C interface which is pretty easy to use from Haskell
02:59:44 <Lemmih> Philippa_: Hacanon isn't really ready for real work yet.
03:00:53 <boegel> Lemmih: so it probably can't be used for a binding with Ogre3D ?
03:01:03 <boegel> yet
03:01:44 <Philippa_> sylvan: not having to write the binding at all is still easier :-)
03:02:29 <sylvan> yeah true, but I was thinking that if you only needed to play some sound it's probably faster/easier to just use FFI in this case rather than download an external tool...
03:02:35 <Philippa_> I'm reasonably familiar with its C interface, a few years back I got chatting with the guy who wrote it about the DSP module system
03:02:45 <Philippa_> depends how good the tool is, no?
03:02:49 <sylvan> or better yet, you can have my highly unfinished binding
03:02:59 <Lemmih> boegel: Being a TH library is its biggest problem right now.
03:03:02 <Lor> Automatically generated bindings (or other FFI tools) are only useful for generating _real_ interfaces to foreign libraries.
03:03:03 <Philippa_> If I can pretty much do ($import "fmod.h"), the tool'll be preferable
03:03:11 <sylvan> true
03:03:33 <Lor> s/generating/developing/
03:03:34 <Philippa_> Lor: by which you mean dealing with stuff on the library's level rather than providing a clean wrapper? Fine by me
03:04:06 <boegel> Lemmih: howso ? is TH not working good enough ?
03:04:08 <Lemmih> boegel: Code generated by Hacanon is required to link with Hacanon and TH. This gives a pretty big overhead for small bindings.
03:04:29 <Philippa_> *blinks*
03:04:29 <Lor> "link with TH"? What's that?
03:04:35 <boegel> Lemmih: I see... but a binding with Ogre3D wouldn't be exactly slow
03:04:40 <Lemmih> Lor: The template-haskell package.
03:04:46 <Philippa_> there needs to be a TH-datastructures -> concrete haskell func
03:04:58 <Philippa_> I assume you've tried stripping the binary?
03:05:06 <Lor> No, I mean what do you mean with _linking_ to TH. If you only use it at compile-time, there should be no residue of it left in the compiled code.
03:05:07 <Philippa_> I would've hoped there was no trace after you've done that
03:05:25 <Lemmih> Lor: Indeed, but GHC isn't that smart.
03:05:47 <Philippa_> is strip?
03:06:13 <Lemmih> Philippa_: Nah.
03:07:13 <Philippa_> that sucks
03:07:16 <boegel> Lemmih: you think it would be hard for me to give Hacanon on Ogre3D a chance ?
03:07:22 <boegel> just to try it
03:07:50 <Lemmih> boegel: Hacanon depends on gccxml which is kinda hard to build.
03:09:17 <Lemmih> Binding to a single class with one function => 2.1M stripped.
03:09:37 <Philippa_> how big's a stripped hello world on the same system?
03:10:27 <Lemmih> 169KB.
03:10:56 <Philippa_> and I assume a hand-written binding to the same class isn't much bigger. Ouch.
03:12:11 <boegel> Lemmih: damned :) but I'm glad there some work being done in this area... only providing bindings for C library's isn't good enough for a growing language like Haskell
03:13:04 <Lemmih> I'm toying with the idea of using TH as a 'normal' preprocessor which outputs to a file.
03:13:39 <Philippa_> the plan being to write the 'other show' for the TH structures?
03:13:54 <Lemmih> Other show?
03:14:28 <Philippa_> I suspect the Show instance for them is pretty much what you'd get if you derived it?
03:14:43 <Philippa_> whereas it'd also make sense to produce the equivalent concrete syntax
03:15:16 <Lemmih> @index pprint
03:15:17 <lambdabot> Language.Haskell.TH.Ppr, Language.Haskell.TH
03:15:32 <Lemmih> @type Language.Haskel.TH.pprint
03:15:36 <lambdabot> bzzt
03:15:51 <Philippa_> oh cool, it's there already?
03:15:55 <Lemmih> pprint should generate correct Haskell.
03:15:55 <Philippa_> I really should pay more attention
03:16:05 <Lemmih> It's borken in GHC 6.4 though /-:
03:16:10 <Philippa_> ah :-(
03:16:22 <Philippa_> is the read-equivalent there too?
03:16:43 <Lemmih> I don't think so.
03:17:26 <Lemmih> Anyhow, I've put Hacanon on hold since there aren't any attractive C++ libraries around.
03:20:30 <SM_ax> Lemmih, do you happen to have the fixed version of HaskellDB? It generates the same error, which hsql did.. :)
03:21:12 <Lemmih> Yep. http://www.scannedinavian.org/~lemmih/packages/haskelldb-0.9.tgz
03:25:06 <Lemmih> Beware, genericConnect doesn't work.
03:26:03 <SM_ax> Lemmih, thx again
03:26:21 <earthy> lemmih: no attractive C++ libraries?
03:26:30 <earthy> what about wxWindows? :P
03:26:44 <earthy> or Qt?
03:26:48 <Lemmih> Ew.
03:27:09 <Lemmih> Gtk(2hs) is much nicer.
03:27:39 <earthy> ;)
03:27:47 <earthy> G3D? that's pretty okay
03:29:32 <boegel> earthy: what's G3D ?
03:29:34 <earthy> ImageMagick isn't bad either
03:29:38 <boegel> Lemmih: what about Ogre3D ? :)
03:29:55 <earthy> boegel: something not unlike Ogre3D
03:30:05 * boegel thinks Lemmih should continue with Hacanon
03:30:14 <boegel> earthy: url ?
03:30:40 <earthy> Lemmih: look at http://www.trumphurst.com/cpplibs1.html
03:30:42 <Lemmih> boegel: I probably will some day.
03:31:07 <earthy> http://g3d-cpp.sourceforge.net/
03:32:28 * boegel wonders what would be easier to bind to Haskell, Ogre3D or G3D
03:32:51 <Lemmih> So much work, so little time *sigh*
03:33:21 <boegel> Lemmih: what are you working on now ?
03:35:11 <Lemmih> A small 2D collision detection library.
03:35:44 <Lemmih> Should really be debugging HackageDB /-:
03:36:35 <earthy> Lemmih: search for ColDet
03:37:13 <earthy> http://photoneffect.com/coldet/
03:39:00 <Lemmih> Overkill.
03:39:58 <earthy> overkill still kills :)
03:41:35 <boegel> hey Itkovian
03:43:15 * boegel hates smallband
03:46:51 <Itkovian> eh?
03:54:12 <boegel> Itkovian: eh what?
03:54:23 <Itkovian> eh smallband ...
03:55:53 <boegel> well yeah, I've crossed my data limit, and then my ISP puts me on smallband until I get in a new limit-period
03:56:58 <Itkovian> ouch ... stop d/ling pron ...
03:57:42 <boegel> Itkovian: oh no, you caught me
03:58:27 <boegel> no, I've let my eMule running for a few days :s and also, my brother should be studying, but he keeps d'ling stuff in stead of studying...I don't even want to know what he's pullingi n
03:58:34 <boegel> s/pullingi n/pulling in
03:58:35 <Itkovian> hehe
04:25:51 * Itkovian works
04:49:09 <SM_ax> Lemmih, is this ok, that besides hsql-1.4 linker requires hsql-1.2?
04:49:29 <Lemmih> Huh?
04:52:51 <SM_ax> during linking process ghc reports: unknown package hsql-1.2 8-|
04:53:35 <Lemmih> When you're building hsql or haskelldb?
04:54:39 <SM_ax> no, when i building my test script
04:55:04 <SM_ax> not "my", but the one from examples
04:55:18 <Lemmih> Try deleting old .hi files.
04:56:19 <Lemmih> Package management in GHC 6.4 is a black art.
05:02:15 <cpjvelde> like automake tools?
05:03:04 <SM_ax> :(
05:03:47 <mflux> hm, is there a way to see if the resulting value from a function is undefined, without (or with?) using the io-monad? just interested, not likely to need that ;)
05:07:33 <Lemmih> No.
05:08:15 <TheHunter> catch?
05:08:27 <TheHunter> there's also this one:
05:08:30 <TheHunter> @google chasing bottoms
05:08:32 <lambdabot> http://www.cs.chalmers.se/~nad/software/ChasingBottoms/docs/
05:09:09 * Lemmih missed the "(or with)" part.
05:14:26 <Consystor> hi all
05:21:40 <mflux> lemmih, my bad, I put it in parenthesis ;)
05:21:42 <mflux> but thanks
05:23:25 <mflux> thehunter, you know, blindly just giving such keywords to google could bring surprising results, I wonder if that combination has been used in spam..
05:27:03 <TheHunter> it works surprisingly well
05:27:25 <TheHunter> @google hierarchical libraries
05:27:26 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/
05:27:40 <TheHunter> @google monad reader
05:27:42 <lambdabot> http://www.haskell.org/tmrwiki/IssueTwo
05:30:43 <tromp> @index fromIntegral
05:30:44 <lambdabot> Prelude
05:30:53 <_JusSx_> i would like to learn "functors". where can i find papers about that?
05:33:56 <_JusSx_> @functor
05:33:57 <lambdabot> Unknown command, try @listcommands.
05:34:02 <_JusSx_> @functors
05:34:03 <lambdabot> Unknown command, try @listcommands.
05:39:36 <cpjvelde> @google hard bottoms
05:39:37 <lambdabot> http://www.surfingsandiego.com/hardbottoms.asp
05:39:45 <Itkovian> eh?
05:39:54 <tromp> how does haskell decide on the type of 2147483647*2?
05:39:54 <cpjvelde> @google np hard bottoms
05:39:55 <lambdabot> http://www.nps.gov/noca/Mtnlakeshandout/mtnlakes-scoping1.htm
05:40:14 <tromp> whether to multiply in Ints or in Integers?
05:41:06 <TheHunter> @type 2147483647*2
05:41:08 <lambdabot> 2147483647*2 :: forall a. (Num a) => a
05:41:38 <mflux> I would imagine when the going gets tough, it'll pick Integers?
05:41:54 <TheHunter> sometimes defaulting or the monomorphism restriction defaults a to an Integer.
05:42:06 <TheHunter> but that can be controlled using |default|
05:44:10 <tromp> finally got my permutation (un)ranking function working
05:59:28 <basti_> hi
06:07:53 <Itkovian> hi basti_
06:10:17 <boegel> hey basti_
06:10:47 <basti_> :)
06:39:53 <Consystor> hi, i've this class: class Operations b where
06:40:11 <Consystor> top :: b -> a
06:40:22 <basti_> are you sure you want to declare a class? ;)
06:40:42 <Consystor> and this instance: instance Operations (Stack a) where
06:40:44 <Consystor> yes
06:41:12 <Consystor> top (Push _ x)  = x
06:41:52 <Consystor> how i can say haskell that my type a from (Stack a) is the same as in the class declaration
06:42:23 <basti_> in the class declaration its not unified
06:42:30 <basti_> and therefor "any" type
06:42:34 <Consystor> yes
06:42:52 <basti_> so you can't say much about it
06:42:57 <basti_> it's just any type
06:43:04 <basti_> completely unfixed.
06:43:10 <Consystor> yes i understand
06:43:26 <basti_> every other "any" type is the same
06:43:30 <Consystor> but how i can put the types together
06:43:42 <basti_> what do you want to do?
06:43:46 <TheHunter> you probably want multiparameter type classes (with functional dependencies)
06:43:57 <Consystor> yes i understand that the a in the class has nothing to do with that one in the instance
06:44:05 <basti_> you're aware that, thanks to polymorphism, you wouldn't need to use classes for a simple stack?
06:44:13 <TheHunter> class Operations b a | b -> a where top :: b -> a
06:44:32 <TheHunter> instance Operations (Stack a) a where top (Pus _ x) = x
06:44:38 <basti_> (that holds things of a single type)
06:44:48 <TheHunter> this is an extension to haskell 98.
06:45:18 <Consystor> TheHunter: i think you understand me, thanx!!!
06:45:24 <TheHunter> if you want to do it in haskell 98, you can try a higher kinded type variable (as something like Monad):
06:45:38 <TheHunter> class Operations f where top :: f a -> a
06:45:46 <TheHunter> instance Operations Stack ...
06:46:53 <TheHunter> but, as basti_ said, if you are only using one implementation of a Stack, you won't need a type class.
06:48:18 <Consystor> yes i understand but thats only an example...
06:48:32 <Consystor> also thnx 2 basti!
06:49:13 <Consystor> ok it works
06:49:17 <Consystor> but one more question
06:49:36 <Consystor> that all means that i only can do that in haskell98?
06:49:57 <Consystor> and in "normal" haskell i must try other methods?
06:50:13 <TheHunter> haskell 98 is "normal" haskell.
06:50:37 <Consystor> ok but i mean haskell not haskell98
06:50:51 <Consystor> there i must try other ways?
06:50:52 <TheHunter> but both ghc and hugs support addidtional extensions such as multiparameter type classes
06:50:59 <boegel> Consystor: haskell 98 is a standard
06:51:17 <boegel> yo CosmicRay
06:51:20 <TheHunter> in haskell 98 |lass Operations f where top :: f a -> a| is valid.
06:51:29 <boegel> @seen Pseudonym
06:51:30 <lambdabot> I saw Pseudonym leaving #haskell 6 hours, 34 minutes and 36 seconds
06:51:30 <lambdabot> ago.
06:51:32 <CosmicRay> morning boegel
06:51:36 <boegel> damn, missed him
06:51:44 <boegel> a'noon CosmicRay :)
06:51:57 <CosmicRay> bah, europeans :-)
06:52:04 <Consystor> k i understand, i've tried it it haskell 98 but what would be the way in haskell (not 98)
06:52:59 <earthy> um
06:53:00 <boegel> you mean what kind of extensions you can use for this purpose ? :)
06:53:00 <earthy> um
06:53:16 <TheHunter> what do you mean by "haskell (not 98)"?
06:53:17 * earthy boggles at the concept of 'Haskell' not being 'Haskell 98'
06:53:30 <TheHunter> current implementations with common extensions?
06:53:39 <Consystor> you said thats possible in haskell 98
06:53:54 <Consystor> where its not possible
06:53:59 <Consystor> where is it not possible?
06:54:12 <TheHunter> multiparam type classes are not part of haskell 98.
06:54:28 <Consystor> oh
06:54:31 <Consystor> sorry!!!
06:54:49 <TheHunter> earthy, 'Haskell' is definitely not 'Haskell 98'.
06:55:31 <Consystor> ok, i had to load fglasgow-exts
06:55:35 <Itkovian> I'm off ...
06:55:37 <Itkovian> ttyl
06:55:42 <Consystor> what would be the way without these extension
06:57:18 <TheHunter> |class Operations f where top :: f a -> a|. The advantage of that approach is parametricity, the disadvantage is that you can't implement "Operations" that only work if a is constrained (e.g. by Ord)
06:57:28 <bringert> Lemmih: nibron tells me you have a cabal file for HSQL
06:57:41 <bringert> Lemmih: nibro that is
06:59:08 <Consystor> TheHunter: k, thnx!
07:05:26 <CosmicRay> bringert: I do.
07:05:49 <bringert> CosmicRay: oh, nice
07:06:11 <CosmicRay> bringert: http://darcs.complete.org/debian/haskell-hsql/hsql.cabal
07:06:44 <bringert> does that repo contain any other changes to HSQL needed for ghc 6.4?
07:06:51 <bringert> or any other changes for that matter?
07:06:58 <CosmicRay> let me check
07:06:59 <Lemmih> Mine's a bit more complicated.
07:07:09 <CosmicRay> Lemmih: where can I find it?
07:07:15 <bringert> I have write access to the HSQL CVS repo, so I can check that stuff in
07:07:30 <Lemmih> http://scannedinavian.org/~lemmih/packages/HSQL-1.4.tgz
07:07:32 <CosmicRay> bringert: yes, it does contain GHC 6.4 fixes
07:07:52 <Lemmih> bringert: I made some non-cabal related changes to it.
07:08:03 <CosmicRay> bringert: I can get you a simple diff if you'd like
07:08:12 <CosmicRay> bringert: incidentally, when will there be a new HSQL upstream release?
07:08:45 <Spark> anyone involved with links or at least interested with links?
07:09:04 <bringert> CosmicRay: I don't know, I'm only a HSQL developer to fix bugs and such since I use it, Krasimir Angelov is the maintainer
07:09:24 <bringert> Spark: yeah, sort of, but I don't know anything about it :-)
07:09:24 <CosmicRay> bringert: got an e-mail address where I could send this diff?
07:09:34 <Spark> thats about the situation i'm in :)
07:09:49 <CosmicRay> Spark: "links" the web browser?
07:09:52 <Spark> nah
07:10:02 <Spark> links the language
07:10:12 <CosmicRay> bringert: sent, thanks
07:10:25 <Spark> apparently has web stuff as an application domain
07:11:45 <bringert> nibro and I will be supervising a project next year where the students will develop libs for writing web apps in haskell, so Links is interesting to compare with
07:12:51 <liyang> WASH?
07:13:04 <Lemmih> Using HSP I hope.
07:13:08 <bringert> Lemmih: yes
07:13:16 <bringert> CosmicRay: got it
07:14:04 <Lemmih> bringert: With the hspr webserver?
07:16:50 <liyang> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
07:17:40 <bringert> Lemmih: probably, it's up to the students to decide how they want to do it
07:25:32 * Lemmih thinks his HSP apache module will be ready for widespread use soon.
07:35:47 <Lunar^> Lemmih: cool! :)
07:41:07 <CosmicRay> nice, lemmih!
07:43:21 <CosmicRay> Lemmih: does your hsql cabal file split it out into individual per-database packages?
07:44:04 <Lemmih> CosmicRay: No.
07:44:15 <CosmicRay> it would be nice to do that.
07:44:22 <Lemmih> Yeah.
07:51:19 <cpjvelde> can anyone reach svn.cs.uu.nl?
07:52:43 <nibro> Lemmih: does your HSP apache module follow those guidelines I tried to explain to you?
07:53:18 <dcoutts> JaffaCake, do you mind if I ask you a Q about makefiles and parallel make?
07:53:29 <JaffaCake> fire away
07:54:02 <dcoutts> I get this problem where make -j2 invokes the same tool twice to build the same target
07:54:26 <dcoutts> eg Job 1 { ghc -c Foo.hs -o Foo.o } and Job 2 { ghc -c Foo.hs -o Foo.o }
07:54:27 <Lemmih> nibro: What guidelines? :)
07:54:48 <dcoutts> as you can imagine that doesn't do good things
07:55:07 <JaffaCake> hmm, don't recall seeing that before
07:55:13 <dcoutts> I get this for several rules, not just the ghc .hs -> .o rule
07:55:39 <JaffaCake> are you sure you only have one make running?  i.e. no recursive $(MAKE) invocations
07:55:48 <Lemmih> nibro: The stuff about fast cgi?
07:56:25 <dcoutts> well there is one recursive make going on (automake likes to cd to the current directory and then do normal non-recursive make from there)
07:57:16 <JaffaCake> could those two makes be trying to build the same things?
07:57:32 <dcoutts> if the rule immediately touches the target file then it works fine, but of course most rules don't work that way (eg gcc, ghc) and make must be designed to deal with that
07:58:08 <dcoutts> JaffaCake, it's possible I suppose but I think it's unlikely since otherwise all automake makefiels for C files would have the same problem
07:58:20 <sylvan> did anyone successfully build jhc?
07:58:32 <JaffaCake> ok
07:59:33 <dcoutts> JaffaCake, if ypu've never seen this phenomnon before it's probably hard to remote debug it! someone else mentioned they had seen this before and had no idea what was going on
08:00:06 <JaffaCake> no, the usual problem I see with make -j is lack of dependencies causing things to be built in the wrong order
08:00:36 <JaffaCake> I don't think I've ever seen things being built twice
08:00:44 <dcoutts> right, I got a bit of that too but this other issue just makes -jN unusable
08:00:49 <basti_> wow.
08:00:57 * basti_ managed to wrap getChar into an arrow
08:01:14 <JaffaCake> tried 'make -d'?
08:01:24 <dcoutts> I'll see if I can be more creative in my googling to find other people who've had this problem
08:01:49 <dcoutts> JaffaCake, I could try that with a small example and try and narrow it down.
08:02:14 <JaffaCake> do you only have one suffix rule that invokes ghc, or several?
08:02:39 <JaffaCake> ie. are you sure it's the same suffix rule being invoked multiple times?
08:03:17 <dcoutts> JaffaCake, just one pattern rule I think
08:04:01 <JaffaCake> random guess: maybe make is getting confused between ./Foo.hs and Foo.hs?
08:04:22 <dcoutts> oh, interesting, I'll take a look
08:04:23 <JaffaCake> seems unlikely, but maybe it's something along those lines
08:05:33 <nibro> Lemmih: no, the stuff about how I wanted apache to talk to hspr :-)
08:06:40 <Lemmih> It be way easier to use FastCGI for that.
08:07:28 <nibro> you couldn't get all the functionality running things as CGI
08:07:44 <nibro> anyway, I gotta run, we'll have to discuss it more tomorrow :-)
08:07:51 * nibro waves
08:07:57 <Lemmih> Bye. See ya tomorrow.
08:10:45 <dcoutts> oh, JaffaCake on another issue, I found some oddness in the +RTS -Hx -Mx -RTS settings on windows, this was with ghc 6.2.2 so it may have been fixed in 6.4. I'll describe it and if you don't recognise it I'll report it as a bug...
08:11:01 <_21870> can anyony reach svn.cs.uu.nl?
08:11:06 <JaffaCake> ok, go ahead
08:11:28 <dcoutts> with this memory hungry app, +RTS -M90m -RTS the tool runs to completeion
08:11:41 <Oejet> _21870: Not me.
08:11:49 <Lemmih> _21870: I can't either.
08:11:52 <dcoutts> but if I use  +RTS -H80 -M90m -RTS this it dies with heap exhautions
08:11:56 <_21870> timeout? no ssl connection?
08:12:02 <Oejet> Connection refused.
08:12:29 <_21870> omfg im screwed....i was supposed to work my #$ss off through the night so i could do a demo tomorrow....
08:12:46 <_21870> and now the version management system dies on me
08:12:47 <dcoutts> JaffaCake, it seems to be using the difference between -H and -M somehwhere where it should be using the absolute value
08:12:59 <JaffaCake> dcoutts: it could conceivably happen
08:13:33 <JaffaCake> run with +RTS -Sstderr and see if you notice anything strange
08:13:35 <dcoutts> JaffaCake, we can take it to an extreem and say +RTS -H720m -M750m -RTS and it still fails
08:13:41 <dcoutts> ok, I'll try that
08:13:53 <JaffaCake> oh right, maybe that's a bug then
08:14:36 <dcoutts> and what makes me think so even more is that if I say  +RTS -H750m -M750m -RTS then I get heap exhaustion even quicker
08:16:21 <dcoutts> JaffaCake, another interesting thing I noticed was that on Windows the app needs much more memory than on Linux, more or less twice as much
08:16:42 <JaffaCake> wow, that's bad
08:16:55 <JaffaCake> can you profile it?
08:16:58 <dcoutts> on linux it works with +RTS -M48m -RTS and on Windows the lower limit is about +RTS -M90m -RTS
08:17:07 <Lunar^> dcoutts: Does it use STM?
08:17:11 <dcoutts> JaffaCake, yes I could do
08:17:13 <dcoutts> Lunar^, no
08:17:30 <dcoutts> Lunar^, this is with ghc 6.2.2
08:17:33 <JaffaCake> can't think of a good reason why that might happen
08:17:50 <dcoutts> they're both 32bit systems
08:18:04 <Lunar^> JaffaCake: on the same field, I found that programs using STM more often needs a bigger -k
08:18:35 <JaffaCake> hmm, interesting
08:18:53 <Lunar^> but that may be related to these particular use, if only I had time to do more testing
08:19:24 <Lunar^> anyway, STM is something really wonderful :)
08:19:34 <JaffaCake> glad you like it :)
08:20:18 <Lunar^> JaffaCake: I hope to use STM when I will do hOp work again
08:20:33 <Lunar^> JaffaCake: multithreaded kernel without deadlocks.. :)
08:21:15 <JaffaCake> that crossed my mind too - it'd be a great experiment to write a multiprocessor kernel in Haskell/STM with GHC's new multiproc extensions
08:22:03 <Lunar^> JaffaCake: do you think hOp could be seen as research work?
08:22:47 <JaffaCake> I guess multithreaded kernels are still research, but it's not exactly untouched territory
08:23:03 <JaffaCake> Haskell/STM is certainly a fresh approach, though
08:23:12 <Lunar^> JaffaCake: I need to figure out what I will do next years, and I still don't know if working on hOp can be part of a thesis
08:23:34 <JaffaCake> you need to start your thesis research next year?
08:24:15 <Lunar^> JaffaCake: I'm ending 4th year (out of 5), so that I could start the year after
08:24:58 <Lunar^> JaffaCake: but I'm still unsure about which courses to follow next year
08:26:42 <JaffaCake> I think it might be difficult to justify just working on hOp as research, but tacking the multiprocessor angle with STM is definitely research
08:26:52 <Lunar^> It seems to be difficult, as OS and PL are pretty separated fields :(
08:27:15 <JaffaCake> the House guys might already be thinking about this... I'd ask them
08:27:17 <Lunar^> More something for an OS lab, then?
08:28:00 <JaffaCake> maybe, it's a good tie-in between OS & PL
08:28:17 * basti_ kleislis around
08:28:20 <JaffaCake> there are some OS folks who aren't averse to using proper programming languages :)
08:28:21 <Lunar^> JaffaCake: thanks a lot for any idea
08:30:17 <Lunar^> JaffaCake: *sigh* Libre Software Meeting 2005 website is down again
08:31:07 * JaffaCake doesn't know what that is
08:31:21 <Lunar^> JaffaCake: but this year OS topic cover high-level language use, there will be conferences about JNode and CoyotOS at least
08:31:35 <dcoutts> JaffaCake, it looks like your suggestion about the recursive make invocations is the solution to my parallel makefile problems
08:31:52 * JaffaCake looks smug
08:31:57 <dcoutts> :-)
08:32:05 <Lunar^> JaffaCake: french conference targeted at free software enthusiasts
08:32:20 <JaffaCake> Lunar^: sounds cool
08:32:42 <Lunar^> JaffaCake: yeah, it has a really friendly atmosphear
08:33:25 <Lunar^> atmosphere
08:59:30 <Itkovian> bach
08:59:32 <Itkovian> a bit
09:01:09 <basti_> johann sebastian?
09:10:22 <boegel> prolly not :)
09:14:46 <Lunar^> @type Control.STM.atomically
09:14:52 <lambdabot> bzzt
09:14:58 <Lunar^> @type Control.Concurrent.STM.atomically
09:15:00 <lambdabot> Control.Concurrent.STM.atomically :: forall a.
09:15:00 <lambdabot>              GHC.Conc.STM a -> IO a
09:15:22 <Lunar^> *sigh*
09:15:33 * Lunar^ would like to put MonadIO everywhere..
09:21:10 <kaol> @moo nad
09:21:11 <lambdabot>                   (___)
09:21:11 <lambdabot>                   ( O )
09:21:11 <lambdabot>            /-------\ /
09:21:11 <lambdabot>           / |     ||V
09:21:11 <lambdabot>          *  ||----||
09:21:11 <lambdabot>             ^^    ^^
09:21:13 <lambdabot>   The cyclops that Jason and
09:21:15 <lambdabot> the Argonauts met had this cow
09:41:07 <xerox> 'evening
09:50:54 <tromp> wondering if my code can be expressed more concise
09:50:56 * boegel just wrote his HRay program in C, and will test it on performance tonight
09:51:01 <tromp> if now have
09:51:01 <tromp>   let visit _ [] = return ()
09:51:01 <tromp>       visit dist ls = do
09:51:01 <tromp>         new <- expand dist ls
09:51:01 <tromp>         visit (dist+1) new
09:56:34 <Lemmih> What does expand do?
09:57:42 <tromp> build a new list while changing some arrays
09:57:59 <tromp> an ST s monad
10:04:16 <Philippa> you might be able to express it as a monadic fold, but don't hold me to that
10:04:32 <Philippa> er, more likely an unfold
10:04:50 <Philippa> don't think there's an unfoldM though
10:29:39 <derelm> i created a working version of a propositional formula solver(?) now i'd like to optimize it for speed, but how do best do that in haskell`
10:31:40 <ndm> derelm: use profiling
10:31:54 <ndm> typically heap profiling is quite good for getting a speed up, or time profiling of GHC
10:32:05 <stepcut> derelm: is that anything like prolog ?
10:32:28 <derelm> stepcut: i am not sure i know what you mean?
10:32:33 <stepcut> me neither
10:32:40 <derelm> ndm: how do i do that?
10:32:46 <stepcut> I have no idea what a propositional formula solver is
10:32:51 <ndm> http://www.cs.york.ac.uk/ftpdir/pub/colin/jfp93hp.ps.gz
10:32:56 <ndm> thats an early version
10:33:00 <Igloo> I'd have thought thinking about the datastructures and algorithms fit a functional language well would yield bettre results
10:33:17 <ndm> its often hard to guess why the program is going slow
10:33:38 <derelm> stepcut: oh, it solving formulas like " not a && b => c || (a & not c)" and print all solving variables
10:33:50 <stepcut> derelm: interesting...
10:34:02 <ndm> http://haskell.org/ghc/docs/latest/html/users_guide/profiling.html
10:34:23 <ndm> i have written various propositional solvers - all of them quite poor
10:34:31 <ndm> do you intend to release your solver once you've finished it
10:34:54 <stepcut> derelm: I am looking into writing a command-line parser that might do something vaguely along those lines
10:35:33 <derelm> ndm: sure i'll release it, its nothing special :(
10:36:03 <ndm> i have it on my todo list to write a fast and correct propositional simplifier - so if someone else did it then I wouldn't have to
10:36:30 <xerox> derelm, what do you mean by "solving" that kind of "formulas" ?
10:38:12 <derelm> xerox: i put something in like "-a  | (b &c ) => (a & -c & (c <=> a))" and it will tell me what values the variables need to let the statement be true
10:38:41 <ndm> derelm: do you simplify the statement, or just enumerate over all values for True and False
10:39:06 <xerox> Simplifying sounds interesting.
10:39:12 <derelm> for the moment i don't compute any simplifications
10:39:21 <ndm> if you download the nofib benchmark, there is a program called Clausify that does quite a few simplifications
10:39:37 <xerox> I think we did something similar with some Karnaugh's method, for circuits.
10:42:54 <derelm> hmm, i guess profiling won't work with ghci only ghc
10:44:05 <ndm> i think all the methods require some work to get going
10:44:19 <ndm> if you use hugs, there is an option to show the number of reductions and cell's used
10:44:32 <ndm> so you can see if your changes improve things, and by how much
10:45:58 <derelm> well yes but i guess some sort of output how many time was spent in which function would be of more value
10:46:51 <derelm> i'll look into it
10:47:00 <derelm> but in the end it's not worth it ;)
10:54:32 <ndm> derelm: i think you can get the time in each function relatively easily using GHC with some profile flags- shouldn't be much more work than GHCi
10:54:55 <[TWiSTED]> how can i make a function so that it tests whether or not the first character in a string is an integer
10:55:22 <[TWiSTED]> i got something like
10:55:27 <ndm> isDigit
10:55:31 <[TWiSTED]> test a = isDigit s
10:55:31 <[TWiSTED]>          where
10:55:31 <[TWiSTED]>             s = head a
10:55:41 <ndm> test a = isDigit (head a)
10:56:09 <derelm> test (a:as) = isDigit a
10:56:22 <[TWiSTED]> cheers
10:56:40 <ndm> both of these will crash if you do test ""
10:56:50 <[TWiSTED]> o yeh
10:56:57 <ndm> so you might want to add to derelm's with the extra line
10:57:01 <ndm> test _ = False
10:57:06 <derelm> test [] = False
10:57:06 <derelm> ?
10:57:18 <[TWiSTED]> _ or [] ?
10:57:25 <derelm> i think it doesn't matter
10:57:29 <[TWiSTED]> ah ok
10:57:30 <ndm> they are equivalent
10:57:49 <ndm> if you use _, you must put it after the first case - if you use [] it can come before or after
10:57:54 <mflux> only in this case ;)
10:58:21 <[TWiSTED]> ah right
10:58:22 <[TWiSTED]> cheers
11:09:12 <araujo> Sort of a unix question, if i close the STDOUT,STDIN,STDERR of a process, the children of that process will have them closed also?
11:14:39 <[TWiSTED]> is there a way to like get rid of a list
11:15:00 <derelm> what do you mean?
11:15:06 <[TWiSTED]> like ive got [[(String,Int)]] but i only want (String,Int)]
11:15:10 <[TWiSTED]> [(String,Int)]
11:15:32 <kzm> head?
11:15:39 <Si\> or concat
11:15:44 <[TWiSTED]> oo
11:15:45 <derelm> concat i think
11:15:48 <kzm> oh, sorry, yes
11:16:45 <kzm> I missed the double []s
11:16:49 <derelm> ndm: the paper you pointed me to is interesting, i only took a look at the code examples, but it's not haskell is it?
11:17:07 <[TWiSTED]> omg awesome cheers
11:17:58 <ndm> derelm: no, its not - its pre Haskell (93, i.e. before Haskell 98)
11:18:18 <ndm> http://scholar.google.com/scholar?q=author%3Arunciman+heap+profiling&ie=UTF-8&oe=UTF-8&hl=en&btnG=Search
11:18:22 <ndm> that has loads of papers
11:18:41 <derelm> ndm: thanks a lot
11:19:57 <ndm> derelm: None of those papers talk about Haskell as it is today, that I can see, but they are all pretty close
11:21:09 <ndm> TWiSTED: Try http://www-users.cs.york.ac.uk/~ndm/hoogle/
11:21:37 <[TWiSTED]> o  cool
11:21:39 <[TWiSTED]> thx
11:21:47 <ndm> type in "[[(String,Int)]] -> [(String,Int)]" in the search box, without quotes, and it gives you concat as the first result
11:22:32 <[TWiSTED]> o yea
11:22:40 <[TWiSTED]> this site will be quite helpful
11:24:03 <p67634> omg, if anyone ever wants to do analysis on C files, use CIL
11:24:04 <p67634> !!
11:24:17 <p67634> so many usefull transformations and simplicifcations are done by it
11:24:34 <p67634> btw im in no way affiliated with CIL :P
11:27:34 <kzm> p67634, uh, what is it?
11:28:44 <Cale> I'm guessing http://manju.cs.berkeley.edu/cil/
11:29:10 <p67634> Cale is guessing right
11:29:23 <p67634> it may not be in haskell, but still...(ocaml)
11:29:41 <kzm> OCaml is passable, I guess.
11:29:45 <p67634> they have handled the linux kernel and gimp.....so it's serious
11:29:59 <kzm> (Especially if you include a footnote about Haskell's syntax being so much nicer)
11:30:00 <kzm> :-)
11:30:06 <p67634> true kzm
11:30:34 <p67634> since i've dealing with ocaml lately.....i really began to appreciate the concise haskell notation (also commonly referred to as cryptic by ocaml people :P)
11:30:43 <p67634> dealing=dealt
11:31:16 <p67634> the mix of imperative was also a bit confusing for me
11:34:23 <[TWiSTED]> ahh finally finished my assignment hehe
11:34:25 <[TWiSTED]> got them all out but 1
11:34:31 <p67634> which one
11:35:15 <[TWiSTED]> um where like input a string and output [(String,Int)]
11:35:20 <[TWiSTED]> but caters for brackets
11:35:35 <p67634> what was the question exactly?
11:35:41 <[TWiSTED]> for chemical equations
11:35:53 <p67634> you input a string....and then what?
11:36:35 <[TWiSTED]> ok this is the specifics
11:36:49 <[TWiSTED]> Define:
11:36:50 <[TWiSTED]> parseFormula' :: String -> AtomCounts
11:36:50 <[TWiSTED]> -- pre: s represents a valid formula in a chemical equation
11:36:50 <[TWiSTED]> -- pre: s contains only alphabetic characters, digits, and brackets
11:36:50 <[TWiSTED]> -- pre: isUpper (head s)
11:36:50 <[TWiSTED]> -- pre: the brackets in s are balanced
11:36:52 <[TWiSTED]> -- parseFormula' s returns, for each chemical element present in s, the
11:36:54 <[TWiSTED]> -- element's symbol and the atom-count of the element, sorted in
11:36:56 <[TWiSTED]> -- increasing order of element symbol
11:37:07 <p67634> wrong screen [TWiSTED]
11:37:08 <p67634> :)
11:37:15 <p67634> should have done it in the pm screen :P
11:37:15 <[TWiSTED]> ehhe
11:37:18 <[TWiSTED]> aite
12:05:54 <CosmicRay> whoa, this looks kick-ass http://www.scannedinavian.com/2005-05-26.html
12:07:24 <pipe> anyone know about evlan?
12:20:21 <boegel> pretty quiet in here again...
12:21:04 <pipe> sup boegel
12:21:28 <boegel> pipe: sup my brother
12:21:50 <pipe> all is shit my man
12:21:52 <pipe> :(
12:22:14 <boegel> tell me why my brother, maybe I can hook you up
12:23:13 <pipe> i got 3 days vacation and then it's back to my world of pain :(
12:23:41 <boegel> what kind of pain ?
12:24:12 <pipe> army life :|
12:24:17 * boegel has to go for a while
12:24:21 <boegel> ow, sucks :s
12:24:31 <boegel> hey, you're the one who also wrote a ray tracer, right ?
12:25:30 <pipe> yeah, it's me wolf
12:26:07 <boegel> pipe: check out mine (I released my code yesterday): http://studwww.ugent.be/~kehoste/thesisPublic/website
12:31:33 <stepcut> boegel: nice
12:37:26 <pipe> boegel: looks pretty good
12:39:32 <basti_> pipe: i sent shapr your greetings
12:41:14 <araujo> mm...
12:41:17 <araujo> where is shapr?
12:41:30 <basti_> he's in larval stage
12:42:12 <araujo> uh?
12:42:15 <araujo> what's that?
12:42:32 <basti_> he's hacking at his project and doesn't want to be interrupted
12:42:42 <araujo> :-P
12:42:43 <basti_> so he doesnt appear in IRC etc.
12:54:14 <pipe> basti_: alright, thanks mate!
13:00:31 <TFK> Say, did anyone here tinker with Sather?
13:00:59 <RemiTurk> good evening
13:01:00 * basti_ heard about it once.
13:01:18 * RemiTurk tries to remember what it was
13:02:05 <basti_> the karlsruhe CS snobs were tinkering with sather. That disqualifies it, IMO ;)
13:02:22 <CosmicRay> basti_: darn germans :-)
13:02:42 <basti_> they didnt invent it
13:03:09 * basti_ opposes CS snobism, especially of karlsruhe students
13:03:13 <CosmicRay> heh
13:03:15 <basti_> :P
13:03:58 <p67634> counterstrike snobism?
13:04:04 <p67634> :P
13:04:07 <basti_> most CS students bore me anyway.
13:04:12 <basti_> computer science
13:04:19 <basti_> I mean i'm one myself
13:04:25 <TFK> It's apparently dead now. But I wanted to hear comments.
13:04:25 <basti_> so who am I to complain
13:04:56 <basti_> but for each haskell adoring student there's 100 who do "C++" "java" "parallel systems" "middleware" "software engineering" or similar vaporware
13:05:09 <basti_> I've never really used it
13:05:13 <TFK> The premise sounds intriguing - a higher level language that compiles to C and compares to it with speed.
13:05:42 <TFK> C++/Java won't vaporize soon.
13:06:02 <TFK> goron, howdy, how did Psyco turn out to be?
13:06:03 <int80_h> rejoice, my Java vaprizing ray nears completion
13:06:30 <wagle> s/100/100000/
13:06:34 <basti_> thats the sad part about it
13:07:05 <TFK> Hmmm. Who was it that compared Haskell to Latin the last time around?
13:07:19 <wagle> lojban
13:07:28 <basti_> there was some perl/latin document
13:07:34 <TFK> o_O
13:07:38 <basti_> but what's the haskell/latin comparison like?
13:07:42 <TFK> Well, I guess it doesn't matter now.
13:07:44 <integral> Perligata 8-)
13:08:16 <TFK> Well, last time it boiled down to Latin being a dead language, and still people didn't mind the comparisson. Was a few months ago, or was it many months ago.
13:08:26 <wli> perligata
13:08:32 <goron> TFK: It read the first five pages orso, but then it went into details, I didn't care for.
13:08:48 <TFK> goron, I thought you wanted the messy, gorey details? ;-)
13:09:00 <goron> TFK: I installed py-game to see his presentation.
13:09:12 <basti_> well if it's true that studying latin will help you in learning abstract thought, the same probably is true about haskell
13:09:19 <TFK> Heh, it's a cute presentation ;-)
13:09:30 <TFK> Only it won't.
13:09:34 <basti_> but when comparing latin to english, for example, both stand close in expressiveness.
13:09:43 <TFK> That's not the point.
13:09:45 <TFK> Latin is dead.
13:09:53 <basti_> yes it is.
13:10:04 <goron> TFK: I don't really get how code that's interpreted at some point, is "removed" and then replaced with compiled code.
13:10:13 <goron> TFK: Compiling the code isn't the problem.
13:10:16 <basti_> but still (some) people advocating learning dead languages just because
13:10:20 <wli> thunks
13:10:24 <TFK> Neither do I. But he did it; I've seen the results ;-)
13:10:26 <wli> Historical study.
13:10:27 <goron> TFK: I mean while it's running.
13:10:52 <goron> TFK: A register write is atomic, so I think he just changes the address.
13:10:52 <TFK> Well, people won't learn 'em.
13:11:02 <goron> TFK: Of some function.
13:11:13 <wli> People learned things like Ugaritic and Hittite for the purposes of historical and language research.
13:11:25 <basti_> well and then, programming languages are rather different to natural languages.
13:11:27 <TFK> Yes, of course. Academics. So?
13:11:30 <wli> The decipherment techniques developed for the occasion of Hittite were groundbreaking.
13:11:31 <goron> TFK: And doing is more fine-grainly is just seeing it as smaller functions.
13:11:35 <basti_> they are designed.
13:11:41 <goron> TFK: What do you think about that?
13:12:05 <TFK> I must confess my ignorance at this point, I'm afraid.
13:12:23 <goron> Where are the compiler hackers when you need them?
13:12:45 <wli> It's the same kind of thunking as is done by dynamic linkers.
13:12:52 <wli> No need for a compiler hacker.
13:13:07 <basti_> and the objectives people had in mind when designing C were obviously far different to those the people who designed haskell had. And I must say, neither which of both is dead or alive or vapor or whatever, haskell does make more sense.
13:13:08 <wli> The fixup process is merely different from a mere search algorithm.
13:13:23 <goron> wli: What does the word "thunking" mean?
13:13:47 <basti_> thunk = promise
13:13:55 <wli> goron: Indirection via procedure call is the usual meaning.
13:14:14 <basti_> a thing to be computed later
13:14:25 <goron> wli: But that has overhead. Isn't it possible without overhead?
13:14:40 <wli> goron: It depends on precisely what the thunk is intended to do.
13:15:10 <goron> wli: Can I read somewhere about this "thunking" process?
13:15:27 <wli> goron: I'm not sure it's involved enough to really have much written about it.
13:15:35 <wli> goron: For instance
13:16:12 <wli> goron: ELF has the PLT trampoline, which qualifies as something as a thunk.
13:16:47 <goron> wli: PLT?
13:16:51 <goron> wli: I "know" ELF though (by name and what it is for) .
13:17:02 <wli> goron: In that case there are tables of code pointers initialized to point at assembly stubs that save registers and then go on to lookup the actual location of the code the caller wanted, possibly loading it if it's not already loaded.
13:17:19 <p67634> how can you turn (Data.Map.unionWith Data.Set.union) into an operator?
13:17:35 <p67634> simply doing `(Data.Map.unionWith Data.Set.union)` isnt working
13:17:35 <wli> goron: When the fixup handler is invoked it changes the code pointer in that table to point at the routine it stood in for.
13:17:36 <TFK> Strictly speaking, Haskell isn't dead like Icon is, and certainly not extinct like Sather. But C is definatelly more "alive", even if Haskell makes a lot more sense.
13:17:38 <goron> wli: Oh, ok. So this thunk is the promise?
13:17:53 <wli> goron: "promise" is extremely vague.
13:18:01 <dcoutts> p67634, import qualified Data.Map as Map
13:18:06 <goron> wli: Ok, let me be more precise.
13:18:17 <p67634> dcoutts, that wont make it an operator will it....
13:18:21 <dcoutts> p67634, and then usie it like: a `union` b
13:18:35 <p67634> but the second argument should also be passed
13:18:36 <dcoutts> p67634, er, sorry and then use it like: a `Map.union` b
13:18:37 <p67634> thats the point
13:18:52 <p67634> `Map.unionWith Set.union` isnt working
13:19:19 <dcoutts> oh, right, no you can't say `Map.unionWith Set.union`, it's not valid syntax
13:19:32 <wli> goron: basically all you're doing is wrapping direct access to a data structure or function or other thing with a function, and various things can happen behind the scenes when you call that function. Most of the time the result is "not ready" when it's first invoked and prepared for all later usage when it's first called.
13:19:36 <p67634> need to define a separate operator i guess then, ty
13:19:48 <dcoutts> p67634, yes exactly
13:20:24 <wli> goron: sometimes it makes sure it's there whenever it isn't but it may disappear later, e.g. a cache of intermediate results kept to some reasonable size, which does LRU or similar to discard results when the cache overflows.
13:20:55 <dcoutts> p67634, sorry I was confused by what you were saying at first, I didn't realise you were using `` in the technincal sense
13:21:04 <goron> wli: But who initializes these pointers?
13:21:08 <wli> goron: sometimes the results are so vast and so infrequently reused it generates them from scratch every time
13:21:28 <goron> wli: But then it would be called a run-time system, right?
13:21:33 <wli> goron: usually they're statically initialized data structures, i.e. the initial state is how it appears on-disk
13:21:48 <wagle> wli: whats your slick list-of-primes program?
13:22:02 <wli> goron: that's not a runtime system, no. It's a tiny piece of an algorithm.
13:22:35 <alexj> anyone understand error and catch?  (error "foo" `catch` (\x->print $ "hello " ++ (show x))) results in "*** Exception: asd" rather than "hello foo".  I don't understand why.
13:22:38 <goron> wli: And what's LRU?
13:23:28 <goron> alexj: Catching error is done via ErrorT the Id monad, and unsafePerformIO (if I remember correctly).
13:23:48 <basti_> hmm catch just catches IOErrors doesnt it?
13:24:03 <Si\> depends which catch
13:24:10 <goron> alexj: Really nice exercise was it for me when I tried to do it.
13:24:15 <basti_> error is bottom _|_ though
13:24:40 <goron> basti_: In GHC they use "compiler magic" to catch error.
13:24:50 <basti_> ah.
13:25:08 <basti_> this shouldnt happen should it? :P
13:25:46 <goron> wli: least recently used
13:26:01 <alexj> I don't understand.  How do you catch an (error "foo")?
13:26:33 <basti_> you just don't IMO
13:26:58 <basti_> error "foo" is acceptable only as a "shouldn't happen" error
13:27:03 <Si\> alexj: IIRC you have to use Control.Exception.catch
13:27:10 <Si\> you can do it, because I have in the past
13:27:14 <basti_> "normal" errors (file not found or something) are something different
13:27:20 <alexj> basti: you don't?  so what if you need to make sure your program doesn't fail?
13:27:29 <basti_> i didn't say you can't
13:27:33 <goron> alexj: I know 100% certain that you can catch a call to error.
13:27:39 <goron> alexj: in GHC
13:27:48 <alexj> goron: ok, how do you do it?
13:27:48 <goron> alexj: Check the mailinglists.
13:27:52 <basti_> It might be that you can
13:27:53 <wli> wagle: primes = 2:3:5:[p | p <- [7,9..], all (\q -> p `mod` q /= 0) (takeWhile (<=(ceiling . sqrt . fromIntegral $ p)) primes)]
13:27:58 <goron> alexj: I don't have the code anymore.
13:28:03 <boegel> @index read
13:28:04 <lambdabot> Text.Read, Prelude
13:28:08 <boegel> @type read
13:28:10 <basti_> i just say, you should make sure you never encounter an "error"
13:28:14 <lambdabot> read :: forall a. (Read a) => String -> a
13:28:21 <wli> wagle: I've got one for Ramanujan numbers, too.
13:28:22 <goron> alexj: You should check the mailinglists for ErrorT and catch error.
13:28:55 <Si\> you have to also make sure your code is strict, otherwise it can slip through the guard
13:28:59 <goron> alexj: Then you would find something. Use that information with my hints and you should get it working within reasonale time.
13:29:00 <basti_> a program that doesn't fail is a correct one, not one that catches all errors
13:29:00 <alexj> basti: (tail []) (2/0) happen.
13:29:32 <Si\> IIRC, error throws ErrorCall type Exceptions
13:29:36 <basti_> alexj: not if you made sure they don't ;)
13:30:04 <alexj> goron: it sounds like you think this is a class exercise?
13:30:08 <wli> goron: LRU is "Least Recently Used", a policy used to choose which member of a cache to evict when a cache miss is taken while the cache is full
13:30:38 <goron> alexj: no
13:30:44 <goron> alexj: http://www.haskell.org/pipermail/haskell-cafe/2004-April/006029.html
13:30:53 <wli> wagle: There are (much) faster methods of enumerating primes.
13:31:13 <goron> alexj: With this information (and a little help from shapr (I think)), I managed to get it going.
13:31:24 <pipe> wli: i have a question
13:31:33 <wli> pipe: What?
13:31:36 <lispy> wagle: what? someone enumerating primes?  I have some code that does miller-rabin if you want it
13:31:42 <goron> alexj: Good luck
13:32:05 <alexj> goron: I'm confused.  What does catch do if not catch error?
13:32:09 <wagle> wli lispy : looking for fast
13:32:10 <lispy> it enumerates strong pseudo primes...
13:32:13 <wli> lispy: The fastest methods are generally sieving of various kinds IIRC.
13:32:20 <goron> alexj: http://tunes.org/~nef/logs/haskell/04.09.01
13:32:26 <pipe> wli: is it theoretically possible for a compiler to figure out that 2 algorithms actually give the same function? like automatically figure out that this guy's prime algorithm can be replaced with a different algo?
13:32:31 <goron> alexj: Here's the discussion I had back then.
13:32:31 * Heffalump wonders how to track down the source of an exception that shows as "unknown exception"
13:32:53 <lispy> wagle: i found a prime with 4096 bits in about 20 minutes on my computer.  That's pretty fast
13:32:54 <Heffalump> pipe: do you want it to find all instances of primality testing, or just some of them?
13:32:55 <basti_> pipe: no it is not
13:32:58 <Si\> alexj: IIRC the standard catch only catches IO Errors, you want Control.Exception.catch which catches any exception
13:33:00 <CosmicRay> Heffalump: sounds like a Dynamic exception
13:33:04 <wli> wagle: djb's probably only academic paper is on this topic, where he basically gets an asymptotic improvement over known sieving algorithms for that
13:33:19 <goron> alexj: If you can't get it done with this information, you probably need some extra exercise :D
13:33:49 <pipe> basti_: what about a compiler that automatically changes a bubble-sort algorithm to quicksort of something?
13:33:53 <Lemmih> Greetings, Ninja master.
13:33:55 <wli> I think it may be a quadratic sieve or some such which probably almost anyone who understands the sieving techniques used for large factorization problems could have whipped up in a day.
13:34:11 <Heffalump> CosmicRay: that helps, not :-)
13:34:23 <wli> pipe: That's extensional equality. It's undecidable in nontrivial languages.
13:34:26 <basti_> pipe: well you can formulate arbitary equivalent transformations to programs
13:34:27 <SyntaxNinja> hi Lemmih
13:34:34 <CosmicRay> Heffalump: catchDyn then :-)
13:34:42 <Heffalump> CosmicRay: and then what?
13:34:43 <basti_> pipe: that one of them yields a program that makes more sense from any other program is not ver probable.
13:34:47 <lispy> wli: there is an improved version of aks (the poly. time primality test) in the current bulletin of the AMS
13:34:50 <Heffalump> can I print out something that will tell me its type?
13:34:59 <lispy> i think it's pretty easy
13:35:08 <pipe> wli: but a human can prove that both algorithms are extensional equal, right?
13:35:11 <goron> alexj: Actually I only talk about the solution, I didn't post it. :(
13:35:12 <lispy> and quick as far as deterministic tests go
13:35:19 <wli> lispy: Those are rather different from enumerating the first umpteen primes.
13:35:31 <basti_> but you can prove theorems which yield equivalent transformations to programs
13:35:33 <lispy> yeah, that's true
13:35:37 <lispy> but why are you enumerating them?
13:35:40 <alexj> Si: Control.Exception.catch does what I wanted.  Thank you.
13:35:41 <basti_> that might make sense in more than one case
13:35:42 <wagle> lemme think on it more, and get back to you..  (i'm enumerating in a range)
13:35:43 <wli> lispy: Ask wagle.
13:35:51 <lispy> wagle: why enumerate?
13:35:55 <wagle> why not?
13:35:58 <wli> wagle: That's a more typical sieving problem.
13:36:16 <alexj> goron: unless there is some in principle problem with using it....
13:36:17 <wagle> get more facile at haskell, mostly
13:36:19 <lispy> wagle: usually when people want primes they want one with certain properties (like > 1000)
13:36:32 <wli> lispy: Ranges are not atypical.
13:36:45 <Si\> alexj: Also be careful of strictness, because errors are lazy, if the code isn't evaled b4 the IO section with the catch is called, it will slip through
13:36:54 <wli> lispy: (though by and large people really only want one)
13:37:20 <lispy> anyway, you can modify miller-rabin to enumerate primes
13:37:43 <alexj> si: ah good point.  thanks.
13:37:48 <wli> Naive use of Rabin-Miller is not a hot idea.
13:37:48 <lispy> you just pull out the test for compositeness and map that on to an infinite list of odd numbers
13:38:08 <goron> alexj: There's no problem using it. (since a call to error is something else then bottom, which is a infinite computation)
13:38:34 <lispy> because miller-rabin just picks random numbers and goes the same test
13:38:40 <wli> It's probably best used as a filtering pass for candidates after various others (e.g. gcd with products of small primes that fit in a single machine word)
13:38:45 <lispy> so you'd just be modifiying it so that it is fed numbers
13:38:57 <lispy> well, yeah
13:39:02 <lispy> gcd is fast
13:39:05 <arjanoosting> i thought error was bottom, effectively, but ghc changes calls to error to IOErrors in the IO Monad?
13:39:37 <goron> wli: Do you have some references for me that I should read to get like at your level of understanding of those issues? I only have academic experience.
13:39:39 * arjanoosting could be complete wrong of course :)
13:39:53 <basti_> error has the key property of bottom in any case: its a value that belongs to every type
13:40:02 <wli> The product of the first 9 or so primes is probably best for 32-bit.
13:40:29 <lispy> wagle: but anyway, if you want help with this, i can help you modify miller-rabin to enumerate primes
13:40:35 <lispy> and it should be pretty dang fast
13:40:50 <wli> goron: No, it's all "lore". Nothing really discusses this in detail. It's just a term. "Dynamic Programming" as discussed in CS books is likely a good candidate.
13:41:14 <wagle> i'll have to do it later..  have to run errands now
13:41:18 <lispy> wagle: sure
13:41:24 <lispy> wagle: just /msg me if i'm not active
13:41:51 <wli> product (take 7 (drop 3 primes)) looks like a good candidate after starting with numbers coprime to 30 (easiliy enumerated)
13:42:00 <wli> There is a bit more to consider than trying to walk over a spigot.
13:42:08 <wli> er
13:42:14 <wli> walk over the range like a spigot
13:42:15 <goron> wli: I know about Dynamic Programming (from algorithmics courses)
13:42:37 <wli> goron: There you go. Memoization is an something like this.
13:42:45 <goron> wli: I know that too.
13:43:09 <goron> wli: I was more thinking of those dynamic linking stuff.
13:43:12 <boegel> hi Itkovian
13:43:27 <wli> goron: ELF standards discuss how it's implemented, but it's got lots of assembly or some such
13:43:42 <goron> boegel: shapr trains his channel members well ;)
13:44:02 <wli> Anyway, bitmaps to track this are useful.
13:44:08 <boegel> goron: yeah, he does :D
13:44:27 <goron> wli: And the general idea of ELF is documented probably on lots of places on the internet, right?
13:45:07 <wli> The reason is that when you make the gcd pass you don't want to do the gcd to everything. You use the gcd and cross of multiples like the sieve of Eratosthenes.
13:46:22 <goron> boegel: You were busy with some 3d stuff now, right? Is it just for fun now, since your thesis was done?
13:47:50 <pipe> goron: i also made a raytracer in haskell btw... http://benny.kramekweb.com/hrayt
13:48:01 <wli> Being able to play those games with the array indices saves a *tremendous* amount of arithmetic.
13:49:15 <wli> Also, if you represent it as a list of arbitrary-precision numbers, your data set threatens to get explosively large.
13:49:59 <Heffalump> how can I list what classes something is an instance of? (in the current scope)
13:50:17 <goron> pipe: I like the picture on the bottom of that page. Dunno whether it's correct... But I like it :D
13:50:18 <Igloo> :i tells you doesn't it?
13:50:30 <lispy> pipe: you post the code :)
13:50:32 <Heffalump> doesn't seem to..
13:50:36 <lispy> you should*
13:50:50 <Igloo> Well, it tells me
13:50:55 <Heffalump> in ghci?
13:51:03 <Igloo> Yup
13:51:03 <Igloo> Prelude> :i Int
13:51:03 <Igloo> data Int = I# GHC.Prim.Int#     -- <wired into compiler>
13:51:03 <Igloo> instance Eq Int         -- Imported from GHC.Base
13:51:03 <Igloo> instance Ord Int        -- Imported from GHC.Base
13:51:33 <Heffalump> bah. I guess I should install 6.4
13:51:50 <Igloo> I think there's something odd about it, though. You might need to actually use things for the interface files to be read or something
13:52:10 <Heffalump> could you tell me if TypeRep is an instance of Show?
13:52:24 <Igloo> Where is TypeRep?
13:52:28 <Heffalump> Data.Dynamic
13:52:48 <Igloo> instance Show TypeRep   -- Imported from Data.Typeable
13:52:51 <Heffalump> ta.
13:53:28 <wagle> whats the name of the default module (again)?
13:53:33 <Heffalump> Main
13:53:54 <wagle> what i thought..  still cant see my defn
13:54:32 <Heffalump> Prelude Control.Exception Data.Dynamic> :i Dynamic
13:54:32 <Heffalump> -- Dynamic is a type constructor
13:54:32 <Heffalump> data Dynamic = Data.Dynamic.Dynamic TypeRep (forall a. a)
13:54:44 <Heffalump> doesn't that mean that I should get a Dynamic constructor when I import Data.Dynamic ?
13:55:54 <Igloo> I think that's telling you about the type Dynamic
13:56:10 <Igloo> :t doesn't know about it, and :b Data.Dynamic only has "data Dynamic" with no constructors
13:56:31 <Heffalump> so what's the stuff on the right of the = sign about then?
13:56:32 <Igloo> Oh, in fact it says it's telling you about the type on the previous line
13:56:50 <Igloo> I guess it should hide that really
13:57:23 <Heffalump> so, can I get the TypeRep of a Dynamic?
13:57:55 <Igloo> You're talking to someone who didn't even know which module they were in  :-)
13:58:10 <Heffalump> bah, I'm talking to the entire Haskell community :-p
14:00:46 <Heffalump> GRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR
14:02:51 <Igloo> ?
14:03:14 <Heffalump> it's a big pile of arse, having to special case for all the possible errors  Imight get just to be able to print them out
14:07:00 <boegel> goron: it's just for fun now
14:07:17 <boegel> I'm comparing my Haskell HRay with an equivalent implementation in C as we speak
14:07:31 <boegel> and I'm gathering information for a 3D modeller in Haskell
14:07:35 <boegel> @wiki H3D
14:07:36 <lambdabot> http://www.haskell.org/hawiki/H3D
14:08:54 <boegel> but I'm having problems with a memory leak...
14:08:57 <Lycan359> A 3d modeller in haskell? Why?
14:09:13 <pipe> i think it's an awesome idea :)
14:09:21 <boegel> Lycan359: just for fun :)
14:09:23 <pipe> but first someone needs to make a decent gui system in haskell
14:09:29 <boegel> to see what Haskell can do in that area
14:09:36 <Lycan359> That's good a reason as any 	 guess.
14:09:40 <boegel> pipe ! don't swear like that ! :)
14:09:52 <Lycan359> That's good a reason as any I guess.
14:10:19 * boegel has swallowed all of his resources with his memory-leaky raytracer
14:10:38 <yain> is there ncurses interface?
14:10:42 <yain> cannot find anything.
14:11:38 <SamB> yain: you mean Haskell glue for ncurses?
14:11:42 <SamB> grab Yi
14:11:51 <yain> Yi?
14:11:58 <pipe> boegel: eh?
14:12:36 <boegel> pipe: I rewrote the thing in C, to check it's performance
14:12:49 <boegel> but I'm not that good at C, so I have a serious memory leak somewhere :s
14:13:01 <p67634> now that sounds like hell
14:13:05 <p67634> porting to C
14:13:06 <boegel> it's using 1.8gb of memory
14:13:06 <SamB> yain: Yi is a text editor which has ncurses bindings in its source tree
14:13:11 <boegel> :|
14:13:50 <yain> ah, found it.
14:13:52 <yain> thanks
14:14:15 <boegel> it is quite shitty yeah, especially the memory usage :s I'm not used to writing big stuff in C
14:14:51 <boegel> valgrind won't even begin to show where my problem is :(
14:15:22 <Lycan359> Concerning yourself with memory is so last century.
14:18:07 <pipe> boegel: if you want my 2 cents then i recommend that you use a software renderer implemented in haskell for a 3d modeller
14:18:35 <boegel> a renderen implemented _in_ haskell ? hmm
14:18:37 <Lycan359> :D
14:18:52 <boegel> pipe: seems like a hell of lot of work
14:19:05 <boegel> why not use stuff like HOpenGL or a bindig to Ogre3D/G3D ?
14:19:51 * CosmicRay returns
14:19:54 <boegel> damned, I can't even kill the process now anymore, grrr
14:20:00 <pipe> i think it would be waaayy to messy, maintanance nightmare
14:20:03 <Heffalump> wahey, I finally have a decent error message
14:20:13 <boegel> luckily I'm doing this in linux, and not in windoze
14:20:16 <pipe> plus it would kill flexibility
14:20:20 <boegel> pipe: why ?
14:20:28 <pipe> you should be able to code a decent scanline rendere in haskell in maybe 200 lines
14:20:43 <boegel> pipe: really ? sounds really cool :)
14:21:02 <pipe> boegel: first of all, game engines like ogre3d are not suited at all for modelling type apps
14:21:06 <Lycan359> Hey is literate programming popular in haskell or something? First i've heard of it...
14:21:09 <pipe> boegel: something like opengl is much better
14:21:25 <pipe> boegel: but even opengl i think would make things much more complicated then necessary
14:21:30 <stepcut> Lycan359: it is neither popular, nor rare
14:21:56 <boegel> pipe: any more idea's ? have you checked the H3D wiki ?
14:22:34 <boegel> finally, I managed to kill valgrind :s omg, what a mess
14:22:55 <pipe> boegel: yeah, i've read the wiki
14:24:44 <boegel> pipe: any more idea's ?
14:26:43 <pipe> hm...
14:27:16 <pipe> "it's gonna be really hard" :)
14:28:03 <boegel> pipe: heh
14:28:21 <boegel> how about the scanline renderer, how hard would that be ?
14:29:13 <pipe> easy
14:29:25 <pipe> getting it fast will be hard though
14:29:28 <boegel> what would be the hard part then ? :)
14:29:30 <pipe> but you don't need it fast at first
14:29:32 <boegel> as I see
14:29:39 <boegel> pipe: hell no, it's just for fun
14:29:57 <boegel> not meant to be a competitive application for Maya or something like that, not at all
14:30:04 <pipe> ok i understand
14:30:18 <pipe> here's what i think would be cool...
14:30:22 <Lycan359> boegel, can't your use your raytracer as the renderer?
14:30:35 <pipe> raytracer is probably too slow
14:30:50 <Lycan359> Well it's a renderer... they are supposed to be slow.
14:30:58 <Lycan359> Not really... but they usually are.
14:31:07 <pipe> no, a 3d modeller needs realtime rendering so you can interactively drag objects around and stuff
14:31:19 <Lycan359> No, for the renderer...
14:31:35 <boegel> Lycan359: yeah, too slow
14:31:40 <Lycan359> Not the workspace real-time window. For that use OpenGL
14:31:45 <pipe> i think boegel is more interested in the actual modelling aspect right now
14:32:00 <pipe> Lycan359: yeah, opengl is an option... but i think a software renderer would be better
14:32:01 <Lycan359> Ok, but why not use OpenGL for that?
14:32:03 <boegel> but nobody says I can't use several renderer (scanline, raytracer, ...)
14:32:23 <Lycan359> Why would you use a software renderer for the modelling window?
14:32:27 <pipe> Lycan359: i think a pure haskell solution would be much more elegant
14:32:39 <pipe> Lycan359: but opengl might actually be not so bad an idea
14:32:41 <boegel> pipe: yeah, but that would be really hard, right ? :)
14:32:50 <pipe> it depends
14:32:52 <boegel> I think HOpenGL is a decent binding
14:33:07 <pipe> it depends on how your modeller is structured
14:33:42 <pipe> in terms of the actual structure of the modeller... i think something like this might be cool...
14:33:48 <pipe> you have the scenegraph
14:34:08 <pipe> and then basicly you change it :)
14:34:18 <pipe> and viewport is always rendering the scenegraph
14:34:25 <pipe> i guess it's a simple idea :)
14:34:38 <pipe> but the scenegraph is just a haskell type
14:35:06 <pipe> a simple tree
14:35:34 * boegel takes notes
14:35:36 <pipe> you could start out by having a very simple interactive command line interface
14:36:03 <pipe> where you execute functions that take a Scene plus some arguments and return a Scene
14:36:30 <boegel> pipe, I see
14:36:44 <pipe> then maybe add like a button to the gui, "Create Sphere", which is bound to the function CreateSphere :: Scene -> Scene, which simply adds a sphere with radius 1 at origin to the scene
14:37:43 <pipe> for undo/redo simply keep a history list of all the scenes... this will eat memory but will be very simple to implement
14:38:41 <pipe> then you need to figure out some sort of system for selecting objects
14:39:32 <pipe> a "selection" could be just a list of integers, that index the objects in the scenegraph
14:39:40 <boegel> pipe: keep on going :)
14:40:12 <pipe> then you have a function, translate :: Scene -> [Int] -> (dx, dy, dz) -> Scene
14:40:17 <pipe> same thing with rotate and scale
14:41:20 <pipe> now you need some kind of system for editing the attributes of an object, like the radius of a sphere, or the intensity of a light source
14:41:28 <reffie> http://www.livejournal.com/users/pavelmachek/7323.html
14:42:16 <pipe> hm...
14:43:02 <boegel> pipe: do you have any usefull links on scanline rendering ? I think I'll have a go at that first
14:43:26 * stepcut will work on the gl version :p
14:43:37 <pipe> hm... there should be tons of good stuff.... now that i think about it though i think opengl might be the better option
14:43:46 <boegel> why ?
14:43:53 <CosmicRay> anyone here on glasgow-haskell-bugs?
14:43:55 <pipe> easier and faster
14:44:17 <goron> boegel: Do you know how to make a primitive GUI widget?
14:44:34 <pipe> you basicly need a function in IO monad that takes a Scene value and renders it with opengl... should be very easy to code
14:44:46 <pipe> goron: what do you mean?
14:45:11 <boegel> goron: yeah, I'm not sure what you mean too :)
14:46:27 <goron> pipe: I mean how for example wxidgets puts a Window on your screen and responds to the closing event when you press on it with your mouse, etc. Thus how to make a really basic widget(since that's what you need before you could even desing a "functional"(whatever that means) GUI).
14:46:41 <goron> er wxwidgets
14:47:15 <pipe> goron: i've coded a simple gui toolkit and it sucked and my second try was half decent :) but this was c++ OOP style... here are screenshots:
14:47:49 <jlouis> CosmicRay: yup
14:48:23 <pipe> http://www.livejournal.com/users/pavelmachek/7323.html
14:48:25 <pipe> er, not that
14:48:28 <goron> pipe: What platform? And what basic libraries did you use? I.e. on what libraries does any toolkit depends.
14:48:29 <pipe> here are screens:
14:48:33 <pipe> http://die.sourceforge.net/stuff/die-0308104_011328854.jpg
14:48:37 <pipe> http://die.sourceforge.net/stuff/die-0308104_011346102.jpg
14:48:41 <pipe> http://die.sourceforge.net/stuff/die-0308104_011359487.jpg
14:48:44 <pipe> http://die.sourceforge.net/stuff/die-0308104_011415645.jpg
14:48:47 <pipe> http://die.sourceforge.net/stuff/die-0308104_164902381.jpg
14:49:19 <pipe> goron: this was built on ogre realtime graphics engine... the drawing primitives are basicly images, input is just the lowlevel mouse movements and clicks
14:49:53 <boegel> goron: I wrote an article for TMR on gtk2hs, so yeah, I know how to create a widget :D
14:50:18 <goron> boegel: With the memory game and stuff you mean?
14:50:21 <boegel> goron: I could use some basic GUI lib for those reason
14:50:23 <boegel> goron: yeah
14:51:26 <goron> boegel: Well, I know how you can reuse and extend components, but *really* extending a component would mean interacting with some videobuffer or something like that.
14:51:46 <goron> boegel: That's the area that is unclear for me.
14:52:09 <pipe> goron: most good toolkits(gtk, wx, qt) have very good support for custom widgets
14:52:30 <goron> pipe: Another example: how do themes work?
14:52:31 <pipe> goron: problem is that pretty much all toolkits are based around the concept of events
14:52:37 <boegel> goron: shouldn't be so hard to figure out
14:52:50 <boegel> stuff like that has been done with HOpenGL I can imagine
14:53:00 <pipe> goron: ...except for old windows code which basicly had a monster switch{} that handled all gui events
14:53:20 <pipe> goron: take a look at my screens :) i implemented this gui system from scratch
14:53:25 <goron> In my idea, you take some vector drawing, and map that to for instance your Window border.
14:54:14 <goron> Also you do some scaling in the case it doesn't fit.
14:54:27 <goron> Is this all to it? Or does it work all different?
14:55:26 <goron> pipe: I took a look at your screens. I think I could recreate _that_, but that doesn't mean it would work always (i.e. as a GUI toolkit).
14:55:41 <goron> I assume there's some domain knowledge in creating these components.
14:56:14 <goron> Just like learning OpenGL which has also a pretty steep learning curve(at least that's what I think).
14:56:37 <pipe> well, just like in everything in life... if you want to do something, you need to learn how to do it :)
14:57:04 <goron> pipe: But does this make sense?
14:57:37 <pipe> but keep in mind that most modern toolkits... their own built-in widgets like buttons and text boxes are created in the exact same way that you would make custom widgets
14:57:53 <goron> pipe: Since ultimately you just have a pixelbuffer. I don't really see what else you could do(except for some cool effects).
14:58:30 <pipe> goron: well, OOP is actually kind of fitting here, you can inherit from an existing widget and just change what you need, and you can even do more complex things like use components from other widgets
14:59:45 <goron> pipe: I know OOP, I am not talking about that. I was talking about for example adding themes to your widgets(like a Window).
15:00:00 <pipe> what do you mean?
15:00:49 <goron> pipe: Just like I said above: is my idea of how themes are implemented reflecting how for example KDE does themes?
15:01:40 <pipe> themes are a very tricky subject
15:01:55 <pipe> i think i understand your point now
15:02:14 <pipe> you want to know... "if i write a custom widget, how will it be affected by the theme?"
15:02:25 <goron> pipe: no
15:02:34 <goron> pipe: Let me explain again.
15:04:24 <goron> pipe: If I would implement a themeable GUI toolkit (to keep things simple just one that supports a Window). Suppose the window border (just a rectangle) is the only thing I would consider for the theming. How could I support for example Scaled Vector Graphics for use with this?
15:05:00 <goron> pipe: Things like stuff that doesn't fit comes up and so on. Scaling is needed, I think.
15:05:00 <pipe> you want your entire gui system to be based on vector graphics?
15:05:36 <goron> pipe: In this time, that would be sensible, I guess. (or base it on OpenGL (but I guess that has vector support))
15:07:38 <goron> pipe: I just would like to know how for example KDE or Gnome has solved that problem.
15:07:56 <pipe> goron: ok i think i understand now...
15:08:13 <pipe> goron: first of all, even if opengl is used for a 3d modeller, it does not have to be used for the actual gui
15:08:29 <pipe> most 3d modellers use a regular gui toolkit for the gui and use opengl only for the actual viewport
15:08:43 <pipe> an exception is blender which actually renders everything in opengl including the entire gui
15:09:05 <pipe> if you want to see how one would do a gui in opengl then blender is actually a pretty good example, it's gui is themable even
15:09:23 <goron> pipe: Ok, forget the 3d and opengl part.
15:09:43 <goron> pipe: Do you have some knowledge about Gnome/KDE?
15:09:52 <dcoutts> goron, so why not use Gtk+ ?
15:10:09 <pipe> goron: yeah, a bit
15:10:11 <boegel> here comes the gtk2hs guy !
15:10:29 <pipe> yeah, gtk2hs or wxHaskell is a really good practical choice
15:10:34 <goron> dcoutts: I am being curious. I am not thinking of implementing a toolkit.
15:10:36 <dcoutts> Gtk+ is themeable and so might be appropriate for a game gui that want's to look a bit "different"
15:10:40 <boegel> http://www.haskell.org/hawiki/H3D
15:10:41 <goron> dcoutts: I want to know how stuff works.
15:10:53 <pipe> goron: you want to know how themes work in gtk and kde?
15:10:59 <goron> pipe: yes
15:11:01 <boegel> pipe: so , creating a GUI with gtk2hs and using OpenGL to render the viewport is a good idea ?
15:11:01 <dcoutts> goron, cool. knowing how stuff works is good :-)
15:11:06 <pipe> boegel: yes
15:11:28 <dcoutts> boegel, I'm going to add OpenGL support for the release after 0.9.8 (ie 0.9.9)
15:11:43 <goron> dcoutts: But... do you know how theming works in GTK?
15:11:52 <boegel> dcoutts: great ! how long will that take ? :)
15:12:01 <dcoutts> goron, roughly yes
15:12:04 <boegel> dcoutts: will you be using HOpenGL for that purpose
15:12:20 <pipe> goron: well, it's actually pretty complicated, they have "theming engines" which are basicly computer programs that say how to render various components. this is a very flexible system... but pretty complicated... but actually, theming engines were apparently overkill and so we end up with only a handful of theming engines, but 1 theming engine can support hundreds of different themes
15:12:23 <goron> dcoutts: Please enlighten me.
15:12:52 <dcoutts> boegel, we'll the 0.9.8 rc1 will be out in a day or two, yes hopefully it'll be compatible with the existing Haskell OpenGL bindings
15:13:19 <pipe> goron: a popular theming engine in the old days for gtk was "pixmap", which basicly required the theme to provide a bunch of primitive images that would work as various gui primitives
15:13:37 <Igloo> dcoutts: With the low-mem-usage C parser?
15:13:46 <dcoutts> Igloo, yes! :-)
15:13:50 <Igloo> Cool
15:14:02 <Igloo> SyntaxNinja: Has anyone shown interest in packaging gtk2hs, BTW?
15:14:33 <goron> pipe: Ok, so for example: Fixed bitmap for cross (closing window), and bitmap (possibly repeating) for the border coloring itself?
15:14:38 <boegel> pipe: http://www.haskell.org/hawiki/H3D
15:14:45 <dcoutts> it should even build on your old weird arches (at least the memory requirements are probably low enough now)
15:14:45 <pipe> goron: yeah
15:14:54 <goron> pipe: That's like... really basic.
15:15:21 <goron> pipe: How is it in the new days working?
15:15:44 <dcoutts> pipe, the Gtk+ hackers have been talking about new theme engines based on Cairo which should provide some interesting new possibilities
15:16:05 <dcoutts> since the current dev version of Gtk+ uses Cairo quite heavily now
15:16:19 <pipe> cairo seems nice
15:16:23 <dcoutts> indeed
15:17:10 <goron> cairo has opengl as backend, I thought.
15:17:14 <pipe> goron: i'm not entirely sure, but it's basicly the same principle
15:17:17 <pipe> goron: yep
15:17:27 <Heffalump> @seen kosmikus
15:17:28 <lambdabot> kosmikus is in #haskell. I don't know when kosmikus last spoke.
15:17:34 <Heffalump> ignorant bot
15:17:39 <pipe> goron: you might want to try looking for some theming tutorials to see exactly how it works
15:17:57 <pipe> goron: or just take apart some themes and look at all of the images that they contain :)
15:18:04 <dcoutts> Heffalump, kosmikus is rather busy atm I've not talked to him for several days
15:18:18 <goron> pipe: Hmm, well that should expose some of it's implementation details. Good idea.
15:18:26 <Heffalump> dcoutts: hmm, can't think why :-)
15:18:44 <Igloo> What's he doing now?
15:19:37 <goron> pipe: And building a GUI outside X, would just require you to talk to your videodriver via the kernel and use keyboads interrupts and mouse events?
15:20:12 <pipe> goron: yep, but in something like linux you probably do not want to go directly through the kernel
15:21:16 <goron> pipe: No, I guess when you do that, your project would be dead before it's started :D
15:21:40 <pipe> heh
15:22:02 <pipe> what i'm really interested though is "functional guis", shit like fudgets and fruit
15:22:21 <pipe> if only i had free time i would so expirement with my own functional guis
15:22:52 <goron> pipe: I really don't see what's the difference between a high-level API and a functional GUI.
15:23:21 <pipe> it's like the difference between imperative programming and functional
15:23:27 <pipe> in fact it pretty much *is* that difference :)
15:23:41 <pipe> a functional gui has the potential to cut your gui code down to maybe 10%
15:24:35 <goron> pipe: I consider wxWidgets to be quite high-level. I mean giving a list of event functions. The logic for events should stay somewhere.
15:25:08 <pipe> you are missing the big picture... there shouldn't even be "events" :)
15:25:41 <goron> pipe: Ok, but how do you let your program respond when you press the mouse?
15:25:55 <goron> pipe: It must be hidden _somewhere_.
15:26:46 <pipe> yes, but most of the time you don't work on that low of a level, you put together components to make high level components, and then you put those together to make even higher level components
15:27:04 <dcoutts> goron, so the design of the themeing API is quite tricky, the theme authors want to know the *meaning* of each widget so they can draw them how they like while the widget authors (including custom widgets) want to be able to draw things with no particular semantics attaches, like boxes lines etc
15:27:45 <pipe> yeah, designing a themable gui system is very tricky, you gotta get the balance between theme author and widget author just right
15:28:09 <dcoutts> so you can make a system that's easy to extend with custom widgets or a system with a fixed set of widgets thats hard to extend with custom widgets
15:28:10 <pipe> that's why i have a totally different idea about how theming should be :)
15:28:22 <dcoutts> getting both is a tricky comprimise
15:29:10 <pipe> that's why instead of trying to figure out a compromise, you change the problem =]
15:29:25 <goron> pipe: So you imply that wxWidgets has no option to "put together components to make high level components,and then you put those together to make even higher level components?
15:29:27 <dcoutts> because if the widgets are semantic objects that the themes understand then how do you add a custom widget without altering the theme?
15:30:10 <pipe> goron: it's theoretically possible, and actually someone is even trying to do so in the spirit of what i'm thinking of. i'm talking about wxFruit
15:30:25 <pipe> dcoutts: yep, my idea totally dodges this problem altogether
15:30:45 <dcoutts> pipe, what we're you planning on?
15:31:31 <stepcut> some things are very hard to search for on google, eg, A* algorithm
15:31:34 <pipe> instead of themers theming the gui toolkit, they theme individual applications
15:31:47 <pipe> stepcut: yeah, or how about microsoft's .net :P
15:32:06 <stepcut> pipe: indeed! though, I don't know why I would be search for that :p
15:32:17 <dcoutts> pipe, oh, ok so the theme has much more knowledge of the thing it is themeing
15:32:18 <goron> pipe: Still you imply that wxWidgets is to low-level to do it, but on the other hand, you say that wxFruit does it, but that;s based on wxWidgets. This is a contradiction.
15:32:55 <pipe> goron: no, i say that wxWidgets is capable and wxFruit is proof
15:33:09 <pipe> goron: it's possible in general to create a wrapper on top of anything
15:33:23 <pipe> goron: but wxWidgets itself is low level in my point of view
15:33:31 <dcoutts> goron, toolkits like Gtk+ and Qt and wxWidgets can all compose existing widgets into compond widgets
15:34:03 <pipe> dcoutts: my problem with these toolkits is with dealing with events
15:34:11 <dcoutts> how so?
15:34:13 <goron> dcoutts: Yes, that's what I think too. So... my first point.. I just see it as a high level API.
15:34:33 <pipe> dcoutts: indeed it is possible to create nice components that encapsulate all of there internal events, but this isn't enough
15:35:40 <pipe> basicly, if you want to write an app using wx then you must write some imperative code. this isn't acceptable to me :)
15:36:10 <pipe> but wxFruit does indeed wrap up wx nicely so that you *can* write apps without any imperative code!
15:36:15 <dcoutts> pipe, good, we need people like you who are dissatisfied with the imperitiveness
15:36:35 <dcoutts> I'm looking for high level APIs for Gtk2Hs
15:37:03 <pipe> dcoutts: i'm at both extremes actually... i'm now coding for gameboy advance in low level c =]
15:37:05 <goron> pipe: I guess it's just a naming issue.
15:37:24 <pipe> goron: no, it's much more then that
15:37:36 <pipe> goron: i recommend that you take a look at fudgets, it's pretty cool
15:38:24 <goron> pipe: I mean that you call it "functional", while dcoutts and I call it "high level API".
15:38:56 <goron> dcoutts: You are Duncan?
15:39:07 <dcoutts> goron, yes
15:39:22 <goron> dcoutts: Did you change IRC name?
15:40:08 <dcoutts> yes, because I became a Gentoo developer and the nick "duncan" had already been taken. :-(
15:40:21 <pipe> oo gentoo
15:40:25 <goron> Yes, I remember "duncan".
15:42:41 <Heffalump> oh, we'll have to change our ICFP team name..
15:42:57 <Heffalump> dcokosmiloolump doesn't quite have the same ring to it..
15:43:02 <dcoutts> :-)
15:44:57 <Lycan359> When does ICFP start?
15:45:44 <Heffalump> end of the month
15:46:10 <dcoutts> pipe, goron, there is also FranTK. I should see if it's a nice programming model and if so do FranGtk as a wrapper over Gtk2Hs
15:46:23 <Heffalump> 24th June
15:47:09 <pipe> dcoutts: yep, that's also nice
15:47:42 <reffie> that's when we know if we're accepted in summer of code!
15:48:54 <Lycan359> Summer of code?
15:49:41 <goron> reffie: Did someone requested to become a mentor for Haskell stuff?
15:49:53 <reffie> goron not afaik
15:49:55 <reffie> Lycan359 http://code.google.com/summerofcode.html
15:50:19 <boegel> *yaay, fixed my CRay memory leak
15:50:31 <dcoutts> pipe, so which of the existing functional/declarative/high level GUI interfaces styles would you suggest?
15:50:53 <Lycan359> So how much faster is the C version boegel? ;)
15:51:00 <boegel> wait, I'll measure it up
15:51:03 <pipe> dcoutts: i have no idea, i don't really understand any of them :)
15:51:16 <boegel> I have to make sure the C version is completly correct
15:51:48 <boegel> damn, I haven't studied jack squad today
15:51:53 <dcoutts> pipe, sadly all of them seem to be abandoned
15:51:56 <boegel> tomorrow, no IRC a punishment !
15:52:15 <pipe> dcoutts: it's ok, there will be more
15:52:30 <Lycan359> What are you studying?
15:52:31 <pipe> dcoutts: and i can wait :)
15:53:03 <dcoutts> pipe, yes I want to resurect one or two of the better ones and base them on Gtk2Hs, the difficulty is knowing which one(s) to pick
15:54:09 <pipe> i think that would be a mistake
15:54:28 <pipe> a functional gui has so much potential to go beyond what any other gui has in terms of usability
15:55:06 <boegel> Lycan359: I have exam on RTS on Monday
15:55:10 <pipe> a functional gui should be able to make it really easy to make apps that have really powerful guis that let you customize them and drag widgets around and do really awesome stuff like copy and paste entire widget panels and do all kinds of crazy shit and stuff
15:56:13 <goron> pipe: That's the abstract of your paper for ACM? lol
15:56:18 <Lycan359> RTS? ;)
15:56:50 <pipe> goron: eh?
15:57:17 <boegel> real-time systems
15:57:28 <goron> Nobody got the joke? :(
15:57:49 <pipe> i think i got it
15:57:51 <boegel> goron: stuff, shit, ... :)
15:59:46 <goron> Telling people something is a joke, really kills the fun out of the joke.
16:01:23 <Lycan359> Are there any bindings for SDL?
16:01:33 <pipe> Lycan359: yes!
16:01:44 <pipe> Lycan359: they even seem to work pretty well
16:02:55 <Lycan359> Cool.
16:03:23 <Lycan359> Where is it?
16:03:27 <boegel> Lycan359: Lemmih has one
16:03:47 <boegel> Lycan359: http://scannedinavian.org/~lemmih/SDLstable/
16:04:05 <boegel> heh, now my C prog segfaults again :s
16:04:38 <Muad_Dibber> eww @ c anyway
16:12:58 <boegel> Muad_Dibber: I'm just trying to compare my HRay ray tracer with an implementation in C
16:13:22 <Muad_Dibber> aah
16:13:51 * Muad_Dibber was wonderin; have you been promoted yet? or just finished work on HRay?
16:19:24 <boegel> Muad_Dibber: promoted ? to what ? :)
16:19:43 <dcoutts> boegel, a post examined person?
16:19:43 <boegel> Muad_Dibber: my thesis was due June 1st, and now I'm studying for exams
16:19:49 <boegel> or at least I should :s
16:20:02 <Muad_Dibber> hehe
16:20:57 <boegel> Muad_Dibber: I'm meeting up with a professor where I might do a Phd next week
16:21:10 <boegel> if I can, I'll be a colleague of Itkovian
16:21:16 <reffie> you're doing a phd next week?
16:21:31 <blackdog> wow, that's fast.
16:21:40 <goron> reffie: Buy a new semantic parser ;)
16:21:46 <reffie> goron :P
16:22:13 <boegel> reffie: nooo, I'm meeting up with someone to discuss it :)
16:22:45 <goron> reffie: How much experience do you have with UFS and journalling file systems?
16:23:08 <reffie> goron heh, that's the project i'm applying for :P
16:23:18 <goron> reffie: I know, I saw you in ##freebsd
16:23:22 <reffie> oh ok
16:23:27 <goron> reffie: That's why I ask :D
16:23:49 <reffie> goron i've never developed a journaled filesystem
16:23:58 <reffie> if that's what you're asking :)
16:24:16 <goron> reffie: But you wrote kernel modules for the fbsd kernel?
16:24:25 <reffie> oh, goron. of course :)
16:24:29 <reffie> i'm a freebsd developer
16:24:41 <goron> How old are you?
16:24:44 <reffie> 21
16:25:32 <goron> So.. you are a diehard C programmer(next to knowing Haskell ;) ) ?
16:25:44 <reffie> kinda
16:25:58 <reffie> i mean, C isn't that hard :P
16:26:00 <Pseudonym> Most Haskell programmers knew some other language first.
16:26:19 <Pseudonym> And most still program in other languages (e.g. day job).
16:26:29 <Pseudonym> The exceptions being graduate students or other academics. :-)
16:26:33 <boegel> reffie: it is :) when I try my HRay program in C, it uses over 700mb for a 800x600 image and doesn't even complete (it kills itself :s)
16:26:34 <reffie> on the other hand, i suck at haskell :P
16:26:41 <boegel> Pseudonym: w00 !
16:26:51 <goron> I know C from reading code, and knowing it's syntax and semantics, but not from real experience.
16:26:53 <boegel> I heard you have some 3D stuff lying around ?
16:27:07 <Pseudonym> Uhhh... yeah, kinda...
16:27:12 <Pseudonym> What did you have in mind?
16:27:34 <reffie> boegel the thing with C is that you have to be careful
16:27:40 <reffie> or bad things will happen
16:28:05 <boegel> yeah, I've noticed :s
16:28:29 <boegel> is it logical a process will get killed when it uses some amount of memory ?
16:28:40 <reffie> that's because of linux
16:29:20 <pipe> no, linux has infinite stack
16:29:23 <goron> reffie: I don't think it's linux.
16:29:29 <reffie> pipe ?
16:29:39 <goron> reffie: I can give the RTS of GHC 2GB.
16:29:54 <reffie> how much ram do you have?
16:29:54 <Pseudonym> Actually, there's a bizarre thing under Linux.
16:30:05 <goron> reffie: Note I only have 1GB of physical RAM,
16:30:13 <goron> reffie: I never tried more.
16:30:15 <Pseudonym> If you run out of address space, malloc() starts failing.
16:30:23 <reffie> Pseudonym that's not bizarre :)
16:30:24 <Pseudonym> But if you run out of RAM, your process gets killed.
16:30:34 <Pseudonym> That _is_ bizarre.
16:30:41 <boegel> 512mb, and equal swap space
16:30:47 <pipe> what do you mean "run out of RAM"?
16:30:47 <Pseudonym> On a 64 bit machine, you never run out of address space.
16:30:49 <boegel> and it gets killed around 700mb
16:30:53 <Pseudonym> Or, rather, you run out of RAM first.
16:30:57 <reffie> Pseudonym right
16:31:21 <reffie> Pseudonym well, if the system is short on ram, it either starts paging itself to death, or it has to kill processes
16:31:23 <Pseudonym> This is a big problem if you write programs which can actually take their own action to reduce their memory usage.
16:31:32 <boegel> @wiki H3D
16:31:32 <lambdabot> http://www.haskell.org/hawiki/H3D
16:31:36 <boegel> Pseudonym: ^
16:31:52 <reffie> Pseudonym on the other hand using the address space doesn't necessarily mean that you are out of RAM
16:31:54 <pipe> boegel: i'll add some stuff to that wiki in the morning... now i must sleep... i've been up for 27 hours :(
16:32:04 <boegel> reffie: you should help me with writing it better then
16:32:09 <Pseudonym> Of course.
16:32:14 <reffie> Pseudonym the OS probably doesn't actually allocate the memory until it's accessed
16:32:14 <boegel> pipe: okay, fine :) thanks for your help and suggestions
16:32:34 <reffie> boegel i would, but i have to study for my microeconomy midterm tomorrow :(
16:32:35 <Pseudonym> My point is that what _should_ happen when you run out of memory (virtual or otherwise) is malloc() should start failing.
16:32:50 <Pseudonym> So that an application can either kill itself or take action.
16:32:51 <Heffalump> YM OSes shouldn't overcommit?
16:32:55 <Pseudonym> But under Linux, it just gets killed.
16:32:58 <pipe> Pseudonym: are you saying that on linux malloc will never fail?
16:33:07 <reffie> Heffalump not overcommitting sucks
16:33:13 <Pseudonym> pipe: Sure it will.  If you run out of address space.
16:33:17 <Heffalump> can't you just turn off overcommitting? Doesn't malloc fail then?
16:33:41 <pipe> man... i so wish i had midterms to study for :\
16:34:49 <boegel> reffie: no need to do it now
16:35:04 <reffie> boegel sure then
16:35:17 <boegel> reffie: help me remind ;)
16:35:31 <reffie> heh
16:45:39 <boegel> Pseudonym: what stuff do you have lying around ?
16:45:56 <Pseudonym> Well, there's the open source renderer that I hack on occasionally.
16:45:59 <Pseudonym> http://www.aqsis.com/
16:46:09 <Pseudonym> There's my fluid simulator, also in C++.
16:46:11 <Pseudonym> Ujm...
16:46:13 <Pseudonym> Uhm
16:46:22 <Pseudonym> (Times are bad when you misspell "uhm".)
16:46:25 <boegel> Pseudonym: can you add this stuff to the H3D wiki page ?
16:46:38 <Pseudonym> Er... why?
16:46:43 <Pseudonym> How is any of this relevant?
16:47:08 <boegel> Pseudonym: it's only for future reference and so on
16:47:21 <boegel> to know where we can go to ask questions when we get into trouble :)
16:47:37 <lispy> Pseudonym: that url isn't loading for me
16:48:26 <boegel> lispy: it is for me
16:48:40 <Pseudonym> http://www.aqsis.org/
16:48:41 <Pseudonym> Sorry.
16:48:52 <lispy> ah there we go
16:49:06 <boegel> heh, why does the com version work for me ?
16:49:12 <lispy> well once i sort through the redirects :)
16:49:53 <lispy> wow: http://aqsis.sourceforge.net/xoops/modules/xcgal/displayimage.php?pid=20&album=random&pos=-20&cat=
16:50:35 <Pseudonym> Yeah, unfortunately we don't have deep shadow maps yet, so that hairy creature looks like it glows.
16:51:14 <boegel> Pseudonym: would a binding to this renderer for Haskell be an option
16:51:31 <Pseudonym> Yes, because this renderer uses the RenderMan interface.
16:51:36 <Pseudonym> Which is a fairly open standard.
16:51:44 <Pseudonym> I started such a binding some time ago.
16:51:51 <Pseudonym> Never did very much with it...
16:51:57 <boegel> sounds interesting for H3D
16:52:12 <boegel> my simple raytracer, ogre3D, aqsis, ...
16:52:16 <Pseudonym> Right.  If you want to reuse as many tools as you can, going with RenderMan is definitely the best option.
16:52:21 <boegel> supporting many renderers
16:52:37 <Pseudonym> There are something like 20 renderers that support it, including the most commonly used in the entertainment industry.
16:52:47 <Pseudonym> (i.e. Pixar's PRMan)
16:52:56 <boegel> nice
16:52:56 <lispy> GRT was meant to someday support rendeman
16:53:07 <lispy> but it's not yet happened :)
16:53:33 <Pseudonym> Yeah, the problem is that RenderMan requires a certain flexibility that almost no toy renderers have.
16:54:26 <lispy> my problem was (back when i had time) i never found a good explanation of shaders or how renderman worked.
16:54:59 <Pseudonym> There's a good PDF file out there called "RenderMan for poets".
16:55:05 <boegel> Pseudonym: how hard would it be to make something simple like HRay compatible with Renderman ?
16:55:05 <Pseudonym> Also www.rendermanacademy.com
16:55:19 <Pseudonym> boegel: Being compliant is very hard.
16:55:33 <Pseudonym> OTOH, supporting some subset shouldn't be that difficult.
16:55:38 <lispy> Pseudonym: cool, thanks
16:55:46 <boegel> Pseudonym: could you _please_ add some of this info to the H3D wiki ? I would like it
16:55:53 <Pseudonym> OK.
16:59:34 <boegel> Pseudonym: I hope I'll find time to actually get this thing going
16:59:40 <boegel> I think I'd learn a lot from it
17:00:54 <p67634> ok i just spent 1 hour looking for a bug which turned out not to be a bug.
17:00:56 <p67634> word up
17:01:30 <boegel> "it's not a bug, it's a feature" comes to mind
17:02:09 <boegel> been there too btw :) sometimes you're sure a shadow on your image isn't supposed to be there, and when you start drawing things on paper, you see it's quite logical ;)
17:05:07 <p67634> i was so psyched of the fact that it didnt work, that i overlooked something
17:06:25 <boegel> I should really go to sleep now
17:06:34 <boegel> I have a lot of work to do tomorrow
17:06:36 <Pseudonym> Night.
17:06:44 <boegel> today actually :
17:06:44 <boegel> :s
17:07:17 <boegel> g'night everyone
17:07:40 <p67634> later
17:08:00 <p67634> i have to get this finished and have to stay up until that time
17:13:10 <Lycan359> Hey is the next version of haskell on the drawing board or is Haskell 98 going to be it for quite awhile?
17:15:02 <dons> we're incrementally adding new features, and writing addenda to the original report -- see the ffi for example
17:15:14 <dons> rather than doing a complete redesign just yet.
17:17:42 <dons> just add -fglasgow-exts to your command line, and read the extensions section of the ghc manual ;)
17:32:41 <kaol> @monad
17:32:42 <lambdabot> Unknown command, try @listcommands.
17:33:06 <kaol> had to try if that'd map to @moo too
17:36:04 <kaol> @woof like a cow
17:36:05 <lambdabot>              (__)
17:36:05 <lambdabot>              [##]
17:36:05 <lambdabot>       /-------\/
17:36:05 <lambdabot>      / |     ||
17:36:05 <lambdabot>     *  ||----||
17:36:05 <lambdabot>        ^^    ^^
17:36:07 <lambdabot>  This cow belonged
17:36:10 <lambdabot>   to Flash Gordon
17:38:56 <dons> @moonad
17:38:57 <lambdabot> Unknown command, try @listcommands.
17:43:38 <arjanoosting> @index execWriter
17:43:39 <lambdabot> Control.Monad.Writer, Control.Monad.RWS
17:43:54 <arjanoosting> @type Control.Monad.Writer.execWriter
17:43:55 <lambdabot> Control.Monad.Writer.execWriter :: forall w a.
17:43:55 <lambdabot>             Control.Monad.Writer.Writer w a -> w
17:52:27 <arjanoosting> Does anyone know some nice documentation/examples/papers about the Continuation Monad?
18:01:11 <yain> hmhm.
18:01:42 <dons> @ghc
18:01:43 <lambdabot>  At least one of the forall'd type variables mentioned by the
18:01:43 <lambdabot> constraint must be reachable from the type after the '=>'
18:01:57 <dons> that's reasonable too
18:02:40 <yain> which one ffi generator is preferrable.
18:02:49 <yain> there are like 3-4 of them.
18:03:05 <dons> I think this depends on your problem
18:03:18 <dons> some very big bindings use c2hs
18:03:25 <dons> small projects you can write by hand
18:03:39 <dons> hacanon seems cool, but I haven't tried it
18:04:06 <yain> what about greencard?
18:04:44 <dons> that would be another choice
18:04:58 <dons> perhaps look at which ones are most current, and whichh ones provide thhe features you'll need
18:05:26 <dons> how many bindings are you expecting to need? and how complex?
18:05:36 <yain> [5 June, 2003] GreenCard 3.01 released - alpha release
18:05:43 <yain> that's not very current
18:05:49 <dcoutts> there is nothing about c2hs which means it should only be used by "big" bindings. It's not a heavyweight tool particularly.
18:06:00 <dcoutts> I'd say c2hs is quite good.
18:06:19 <dons> this is true. c2hs scales well, I guess I was trying to say.
18:06:35 <yain> dons: what do you mean by "complex"? callbacks etc?
18:06:52 <dons> stuff that would be a pain do derive by hand
18:07:45 <yain> oh.
18:07:54 <yain> seems like i was confused.
18:08:09 <yain> i'll write it by hand.
18:09:20 <dcoutts> the killer feature of c2hs is that is checks that the Haskell type you give to a C function matches the type declared for it in the C header files
18:09:51 <dcoutts> this is not only a time saving feature, it catches many bugs that would otherwise cause segfaults
18:09:59 <lispy> is it possible to add haskell style type checking to a C compiler?
18:09:59 <yain> ic.
18:10:23 <lispy> if so it seems like something that should be in GCC even if it's only optional
18:10:48 <dcoutts> lispy, I rather doubt it, but I guess it depends how far you want to take it.
18:11:13 <dcoutts> for example Linus's 'sparse' tool could probably be considered a type checker
18:11:23 <lispy> well, if it makes linux development easier i'm sure you'd have quite a few users right there :)
18:11:27 <lispy> ah
18:11:30 <lispy> never heard of that
18:11:52 <dcoutts> it allows you to add extra annotations to types and variables and the sparse tool checks that they get used consistently
18:12:02 <lispy> nice
18:12:23 <dcoutts> it allows the kernel coders to enforce a type distinction between user pointers and kernel pointers for example
18:13:09 <dcoutts> or to define new types where as in C there are no genuine new types, typedef just introduces aliases which are type compatible with the original
18:13:27 <lispy> night
18:13:28 <lispy> er right
18:13:31 <dons> simillar things are done in the openbsd kernel using 'attributes' to specify bounds on arrays for example
18:13:58 <dcoutts> sounds like a very similar idea
18:14:56 <dcoutts> I don't know quite how sophisticated or principled these tools are and they are undoubtedly specialised for the problems the kernel coders face. So there may be scope in producing a more general tool.
18:15:16 <liyang> Doesn't that just generalise to ownership (types/domains)?
18:15:25 <dons> or using a real type system. cyclone for example
18:16:09 <dons> but a more principled 'lint' tool would be useful to many C people interested in safety
18:16:19 <dcoutts> yes a real type system with type inference
18:16:33 <dcoutts> but it'd have to cope with not being total
18:16:57 <dcoutts> ie not having enough attributes supplied to prove the whole things works
18:17:12 <dons> i'd imagine you could reparse the C code and analyse it using a cyclone-ish type checker
18:17:23 <dcoutts> so a bit like the way people retrofit type systems into things like scheme
18:17:30 <dons> yeah.
18:17:39 <dons> and erlanng
18:17:48 <dcoutts> yes, and erlang
18:17:49 <dcoutts> I don't know cyclone
18:17:57 <lispy> sbcl/cmucl does type inference on CL as well
18:18:11 <dons> it's an ML-ish type system and rts based on region inference for C
18:18:41 <dons> dcoutts could take his shiny new C parser in alex and happy and do some analysis!
18:18:49 <dcoutts> hah!
18:18:59 <dcoutts> I'll let you do that. :-)
18:19:19 <dons> maybe you could just: putStrLn "you appear to have written your code in the wrong language. Try Haskell"
18:19:24 <dcoutts> It should cover the complete C grammar though.
18:19:26 <Lycan359> hehe, it actually connected :D
18:19:38 <dcoutts> hey! I like that idea. :-)
18:19:46 <dons> hehe
18:20:11 <lispy> lamedabot: hi
18:20:18 <dcoutts> Yes, I was thinking it might be a useful thing to package seperately, a parser for (GNU) C.
18:20:27 <Lycan359> It doesn't do anything yet ;)
18:21:01 <dons> dcoutts, yep. a nice Cabal package would be really useful
18:21:19 <dons> Language.C.Syntax and friends
18:21:19 <dcoutts> perhaps I should cabalise it as Language.C.(Parser|AST)
18:21:31 <dons> yep.
18:22:53 <lispy> does darcs have tools for helping to create Cabal packages?  would this be something that darcs could reasonably help with...
18:23:09 <dcoutts> dons, oh, btw if you want to check out the new parser the first release candidate for Gtk2Hs 0.9.8 is available
18:23:12 <lispy> there is darcs dist, which is nice if a bit simple
18:23:29 <lispy> and there is a tool for helping with debian packages, so it made me wonder :)
18:23:31 <dons> dcoutts, ok. will do.
18:23:32 <dcoutts> http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.7.91.tar.gz
18:23:46 <dons> building now
18:23:55 <dcoutts> that was quick!
18:24:12 <dcoutts> the c2hs that comes with it has both the old and new parsers
18:24:36 <dcoutts> use tools/c2hs/c2hsLocal [--old-parser]
18:24:48 <dons> ok
18:25:12 <dcoutts> if you do $ make gtk/gtk.precomp
18:26:09 <dcoutts> and then cut-n-paste the command it runs, and do it again with --old-parser
18:26:48 <dcoutts> oh and rename the gtk/gtk.precomp to gtk/gtk.precomp-newparser or something and then $ cmp gtk/gtk.precomp gtk/gtk.precomp-newparser
18:33:10 <dcoutts> if it says they're the same that's great, otherwise it's possible to run it again and get a text dump of the AST using each parser
18:33:26 <p67634> im gonna be soooooo tired tomorrow
18:33:51 <dons> ok. it's building ... my laptop's only swapping just a little
18:34:17 <dcoutts> how much ram or your laptop? 128Mb?
18:34:53 <dons> dcoutts, I think I might write up a summer project proposal based on a type checking tool for C as we've disscussed, -- is that ok with you?
18:35:02 <dcoutts> I've set the ghc rts heap limit at -M80m for the c2hs runs
18:35:12 <dcoutts> dons, yeah sure
18:35:12 <dons> 256M
18:35:18 <dcoutts> oh, plenty
18:36:02 <dons> ghc was using 180M
18:36:16 <dcoutts> The C parser is GPL so you can use that of course (it's derived from Manuel's one which was GPL).
18:36:16 <dons> but it's dropped away now.
18:36:36 <dcoutts> really? Oh, I thought I'd stuck a limit on that too. Maybe I didn't
18:36:46 <dcoutts> what was it compiling when it used so much?
18:37:10 <dcoutts> I wonder what minimum I can get away with.
18:37:23 <dons> cannot find -lgobject-2.0 -- guess I need to install some graphics libs?
18:37:35 <dons> or maybe my path is missing some things
18:37:57 <dcoutts> Hmm, it should have found a probs like that during configure...
18:38:02 <dcoutts> what platform are you using?
18:38:26 <dons> openbsd/x86
18:38:49 <dcoutts> what's the output of $ pkg-config --libs gobject-2.0
18:38:52 <dons> oh, config.logs said it found it.
18:39:11 <dons> -L/usr/local/lib -lgobject-2.0 -lglib-2.0 -lintl -liconv
18:39:16 <dcoutts> yes, it was looking for glib (gobject)
18:39:45 <dcoutts> ok what was the failing command line? (I'm guessing it somehow dropped the -L/usr/local/lib bit)
18:40:19 <dons> /usr/bin/ld: cannot find -lgobject-2.0
18:40:34 <dcoutts> presumably libgobject-2.0.a really does exist in /usr/local/lib
18:41:14 <dcoutts> ah, I think we are dropping the -L/usr/local/lib bit
18:41:46 <dons> seems like
18:42:21 <dcoutts> so if you add -L-optl-L/usr/local/lib to the failing command it works?
18:42:42 <dcoutts> if so I'll go figure out a fix
18:43:33 <dons> -L-L/usr/local/lib or -L-optl-L/usr/local/lib  both work
18:43:52 <dcoutts> I'm not sure we've ever actually built on OpenBSD before :-)
18:43:56 <dons> :)
18:44:11 <dcoutts> right, because ghc recognises the -L/usr/local/lib flag
18:44:18 <dons> yeah.
18:44:21 <p67634> what time is it with you guys?
18:44:38 <dcoutts> we'll as soon as it works we'll be able to add it to our list on our web page :-)
18:44:52 <dons> well, I need it for the new Yi gui ..
18:45:14 <dcoutts> then I'd better make sure it works!
18:45:39 <dcoutts> so, what are your plans for that then? the Yi gui I mean
18:46:50 <dons> WolfgangT came up with a nice UI typeclass for his wxHaskell ui. I was going to integrate that ain, make sure the ncurses ui still worked, then start on a gtk2hs ui -- like gvim's
18:46:58 <dcoutts> are you thinking of basing it on an existing multi-line text widget or draw the text directly
18:47:33 <dons> drawing the text directly is how the ncurses libs does it, but it's a pain
18:47:51 <dons> i was going to try out the text widget at lesat
18:48:01 <dcoutts> The Gtk+ text widget is quite good, it provides a great deal of flexability
18:48:20 <dons> oh, ok. that sounds promising
18:49:26 <dcoutts> check out the gtk-demo and the Gtk+ docs: http://developer.gnome.org/doc/API/2.0/gtk/TextWidget.html
18:53:36 <dons> ah cheers. this looks good.
19:05:11 <MachinShin> hey +
19:33:04 <kaol> @vixen good morning
19:33:10 <lambdabot> good? not great?
19:37:12 <Cale> @vixen great morning
19:37:16 <lambdabot> can't do much better than great
19:37:39 <Cale> @vixen incredibly fantastic morning
19:37:43 <lambdabot> so, what made you want to message me?
20:07:30 <Omnipotent> Hey, is it alright to ask a noobish question here?
20:07:58 <Pseudonym> No, we only allow experts here.
20:08:05 <Omnipotent> :)
20:08:11 <Pseudonym> You're only allowed to ask a question if you didn't really need to ask it because you know everything.
20:08:24 <Omnipotent> Good point
20:08:39 <Pseudonym> Was there a question in there, BTW?
20:08:49 <Pseudonym> Apart from the meta-question?
20:08:52 <Omnipotent> i need to write a function String -> [String]
20:09:01 <Omnipotent> It needs to be similar to words
20:09:19 <Omnipotent> Although rather than splitting the string at whitespace, it needs to be at the char '+'
20:09:36 <Pseudonym> There's also lines.
20:09:41 <Pseudonym> @plugs lines "hello\nworld\n"
20:09:43 <Omnipotent> I've searched through the prelude, but I can't find what I'm looking for on words
20:09:46 <lambdabot> ["hello","world"]
20:10:14 <Pseudonym> What I suggest is looking at the prelude source code (perhaps the reference implementation in the spec) and changing it.,
20:10:19 <Omnipotent> Yeah, that's it really. But instead of " " or \n it needs to be +
20:10:40 <Pseudonym> http://haskell.org/onlinereport/standard-prelude.html
20:10:47 <Omnipotent> Ta
20:11:24 <Omnipotent> Ah, beautiful!
20:11:44 <Omnipotent> Much appreciated
20:11:49 <Pseudonym> No problem.
20:12:58 <Pseudonym> BTW, much kudos for actually looking in the prelude first.
20:13:32 <Omnipotent> :)
21:01:26 <kaol> @vixen I'm tired
21:01:30 <lambdabot> i thought you might be
21:02:23 <kaol> @having a conversation with a series of regexpes beats going to bed, I guess
21:02:25 <lambdabot> Unknown command, try @listcommands.
21:02:30 <kaol> @vixen having a conversation with a series of regexpes beats going to bed, I guess
21:02:33 <lambdabot> don't just guess, know!
21:02:35 <kaol> err...
21:03:24 <Pseudonym> @vixen You know, megamonad was way cooler.
21:03:28 <lambdabot> am i cool? well thank you
21:06:33 <lispy> @vixen do you like my new haircut?
21:06:37 <lambdabot> yah, i like
21:06:46 <lispy> @vixen thanks, i like you too
21:06:50 <lambdabot> well, you seem nice too
21:06:58 <lispy> @vixen <3
21:07:02 <lambdabot> I have 2 c what u look like.. u have pic?? URL?? NOT a fake please..
21:07:02 <lambdabot> ill know!
21:07:27 <lispy> wow
21:07:37 <lispy> vixen never ceases to impress me
22:41:14 <autrijus> @vixen metacomputational reified subcontinuations?
22:41:17 <lambdabot> Yeah
22:42:47 <basti_> @vixen do you reify?
22:42:50 <lambdabot> i do occassionally, i guess
22:43:09 <kaol> @vixen would you reify with me?
22:43:12 <lambdabot> i might :)
22:43:55 <Pseudonym> @vixen How often do you reify?
22:43:59 <lambdabot> how? it depends...
22:44:19 <basti_> @vixen do you swallow while reifying?
22:44:22 <lispy> @vixen do you reify yourself when you think about me?
22:44:22 <lambdabot> no... i spit it back into the guy's face... does that bother you?
22:44:24 <Pseudonym> @vixen Do you throw a lot of exceptions?
22:44:26 <lambdabot> when is a good time?
22:44:26 <arjanoosting> @vixen Why do you reify?
22:44:27 <lambdabot> maybe. do you?
22:44:29 <lambdabot> why anything?
22:44:35 <basti_> lol
22:44:58 <arjanoosting> @vixen do you like to reify?
22:44:59 <Pseudonym> @vixen Do you know your types at run-time?
22:45:00 <lambdabot> sure, i definitely don't hate
22:45:15 <lambdabot> yeah, i know
22:45:17 <Pseudonym> @vixen What do you refity?
22:45:17 <kaol> @vixen do you do it with monads?
22:45:18 <lambdabot> maybe. do you?
22:45:19 <lambdabot> i dunno...
22:45:32 <lispy> @vixen  you sound uncertain
22:45:34 <lambdabot> Guys who can speak latin really turn me on.
22:45:51 <Pseudonym> @vixen Can you reflect?
22:45:52 <arjanoosting> @vixen and guys who speak Haskell?
22:45:52 <lispy> @vixen ah, all the latin i know is written on money
22:45:53 <lambdabot> of course i can
22:45:53 <lambdabot> Ooh, functional programmers are so hot!
22:45:54 <lambdabot> i thought you knew
22:46:18 <Pseudonym> @vixen You seem to be highly concurrent.
22:46:20 <lambdabot> ?
22:46:44 <arjanoosting> @vixen do you like it to be popular?
22:46:46 <lambdabot> yah, i like
22:46:57 <Pseudonym> @vixen vi or emacs?
22:46:59 <lambdabot> I like to pick everything up and smell it... Its a fetish of mine...
22:46:59 <lambdabot> And i mean everything! Is that cool with you?
22:47:15 <Pseudonym> @vixen What, even emacs?
22:47:17 <lambdabot> i dunno...
22:47:35 <Pseudonym> @vixen What's the smell of one emacs clapping?
22:47:37 <lambdabot> i give up, what?
22:50:15 <arjanoosting> @vixen can you tell us a story?
22:50:16 <lambdabot> of course i can
22:50:26 <kaol> @moo
22:50:27 <lambdabot>             (__)
22:50:27 <lambdabot>             (@o)
22:50:27 <lambdabot>      /-------\/
22:50:27 <lambdabot>     / |     ||
22:50:27 <lambdabot>    *  ||----||
22:50:27 <lambdabot>       ^^    ^^
22:50:28 <arjanoosting> @vixen about what?
22:50:29 <lambdabot> This cow lived with
22:50:32 <lambdabot> the Little Rascals
22:50:34 <lambdabot> about anything
22:50:48 <arjanoosting> @vixen tells us about cows!
22:50:50 <lambdabot> Uh-huh
22:53:01 <Pseudonym> @vixen What, you don't like cows?
22:53:03 <lambdabot> i'd say i like
22:53:05 <autrijus> @vixen nuqneH
22:53:06 <lambdabot> blah
22:53:20 <dons> take that autrijus
22:53:30 <Pseudonym> @vixen Se nur vi estus silentita, oni kredus, ke vi estus inteligentita.
22:53:32 <lambdabot> Prolly
22:55:25 <autrijus> dons: ;)
22:56:49 <Pseudonym> @vixen Beatles or Elvis?
22:56:51 <lambdabot> i understand
23:01:15 <lispy> @vixen beavis or butthead?
23:01:17 <lambdabot> Hmmm
23:27:17 <lispy> @vixen beavis was my favorite.
23:27:19 <lambdabot> hey, what's in a jack and coke anyhow?
23:28:17 <kaol> @vixen boxers or briefs?
23:28:21 <lambdabot> why do you look like ham?
23:28:44 <fraxtal> What is it doing?
23:37:58 <vincenz> @vixen
23:38:00 <lambdabot> yeah?
23:38:05 <vincenz> @vixen
23:38:07 <lambdabot> Wouldn't it be funny if I really was a super model?
23:38:15 <vincenz> fraxtal: the extra terms are ignored
23:49:07 <_Iww_> Hello, gentlemen!
23:58:12 <Itkovian> meuning
