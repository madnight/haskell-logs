00:00:08 <seidan> they seem to come in order. next is cow in trouble.
00:00:10 <seidan> @moo
00:00:12 <lambdabot>            (__)
00:00:12 <lambdabot>            (oo)
00:00:12 <lambdabot> ~~~~~~~~~~~~~~~~~~~~~
00:00:12 <lambdabot>  
00:00:12 <lambdabot>  
00:00:12 <lambdabot>  
00:00:14 <lambdabot>     Cow in trouble
00:00:49 * seidan looks at lambdabot more closely.
00:01:06 <lispy> ah
00:01:08 <lispy> @moo
00:01:10 <lambdabot>           (__)
00:01:10 <lambdabot>           (oo)
00:01:10 <lambdabot>   /--------\/
00:01:10 <lambdabot>  * o|     ||
00:01:10 <lambdabot>     ||----||
00:01:10 <lambdabot>  ooo^^    ^^
00:01:12 <lambdabot>   Cow taking
00:01:14 <lambdabot>     a shit
00:01:18 <wilx> HEhe.
00:01:37 <lispy> i'm afraid to see what is next if they come in order
00:01:49 <kaol> @moo
00:01:50 <lambdabot>            (__)
00:01:50 <lambdabot>            (oo)
00:01:50 <lambdabot>    /-oooooo-\/
00:01:50 <lambdabot>   * ooooooooo
00:01:50 <lambdabot>  ooooooooooooo
00:01:50 <lambdabot> ooooooooooooooooo
00:01:52 <lambdabot>   Cow in deep
00:01:54 <lambdabot>       shit
00:01:56 <wilx> lol
00:02:00 <lispy> ;)
00:04:52 <seidan> and for completeness's sake...
00:04:54 <seidan> @moo
00:04:55 <lambdabot>  *        (__) *      (__)
00:04:55 <lambdabot>   \       (oo) |      (oo)
00:04:55 <lambdabot>    \-------\/  \-------\/
00:04:55 <lambdabot> o  o|     ||   /     ||
00:04:55 <lambdabot>     ||----||>==/-----||
00:04:55 <lambdabot>     ^^    ^^         ^^
00:04:58 <lambdabot>     Cow getting the shit
00:05:00 <lambdabot>      kicked out of her
00:39:46 <rtega> @moo
00:39:47 <lambdabot>             U
00:39:47 <lambdabot>         /---V
00:39:47 <lambdabot>        * |--|
00:39:47 <lambdabot>  
00:39:47 <lambdabot>  
00:39:47 <lambdabot> Cow at 100 meters.
00:40:04 <rtega> @moo
00:40:05 <lambdabot>           .
00:40:05 <lambdabot>  
00:40:05 <lambdabot>  
00:40:05 <lambdabot>  
00:40:05 <lambdabot> Cow at 10,000 meters.
00:40:15 * rtega luvs ascii-art
00:41:52 <rtega> @moo
00:41:53 <lambdabot>          )__(
00:41:53 <lambdabot>          (oo)
00:41:53 <lambdabot>   *-------\/
00:41:53 <lambdabot>  / |     ||
00:41:53 <lambdabot> /  ||----||
00:41:53 <lambdabot>    vv    vv
00:41:55 <lambdabot>  
00:41:58 <lambdabot>  Polish Cow
00:42:07 <rtega> @moo
00:42:09 <lambdabot>       vv    vv
00:42:09 <lambdabot>       ||----||  *
00:42:09 <lambdabot>       ||     | /
00:42:09 <lambdabot>      /\-------/
00:42:09 <lambdabot>     (oo)
00:42:11 <lambdabot>     (~~)
00:42:12 <lambdabot>  
00:42:13 <lambdabot> Australian Cow
00:43:19 <ibid> @moo
00:43:20 <lambdabot>           (__)
00:43:20 <lambdabot>           (xx)
00:43:20 <lambdabot>    /-------\/
00:43:20 <lambdabot>   / |     ||
00:43:20 <lambdabot>  *  ||----||
00:43:22 <lambdabot>     ^^    ^^
00:43:25 <lambdabot>  
00:43:26 <lambdabot>  Cow who used Jolt to wash
00:43:28 <lambdabot> down psychadelic mushrooms
00:44:24 <ibid> @moo
00:44:25 <lambdabot>              (__)
00:44:25 <lambdabot>              SooS
00:44:25 <lambdabot>       /------S\/S
00:44:25 <lambdabot>      / |     ||
00:44:25 <lambdabot>     *  ||----||
00:44:25 <lambdabot>        ^^    ^^
00:44:27 <lambdabot>     This cow belonged
00:44:29 <lambdabot>   to George Washington
00:45:01 <dons> you can /msg lambdabot to generate all the cows you want ... ;)
00:45:28 <ibid> i was going to say that myself, but then i decided to go with the flow :)
01:11:31 <Itkovian> Hi boegel
01:11:36 <Itkovian> and others
01:11:46 <xerox> 'morning ppl
01:12:19 <boegel> yo everyone
01:12:30 <Petruchio> Hello.
01:13:16 <Petruchio> I have what I'm sure is a simple question.  I have a list, t1, and a function, flakeit.  I can call flakeit with each of the members of t1... for instance, flakeit( head t1 ).  But when I say:  map flakeit t1, I get a type error.
01:13:41 <Petruchio> *** Type : [IO ()]  *** Does not match : IO a
01:13:55 <xerox> Cough :-)
01:13:56 <Petruchio> Any pointers?  I'm quite new to the language.
01:14:03 <boegel> Petruchio: what's the type of flakeit ?
01:14:16 <mauke> and where are you using it?
01:16:18 <lispy> Petruchio: are you doing something like main = map flakeit t1 ?
01:16:56 <Petruchio> I'm hesitating because I'm trying to make sure I answer well... *blush*
01:17:02 <Petruchio> No, lispy.
01:17:15 <Itkovian> Petruchio: no panic, we all make mistakes
01:17:58 <Itkovian> @google hoogle haskell
01:17:58 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/hoogle/
01:18:20 <Petruchio> Let me just the code I'm working on.  I'm editing a little thing a friend did, for practice.
01:18:55 <drbean> @help
01:18:57 <lambdabot>  @help <command> - ask for help for <command>
01:19:10 <Itkovian> Petruchio: if you have a lot of code, paste it on the irc paste page
01:19:18 <Itkovian> @wiki HaskellIrcPastePage
01:19:19 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
01:19:20 <Petruchio> It's not much.
01:19:29 <Petruchio> And I'm almost done.
01:19:39 <Itkovian> well, for > 3 lines, we advise using the wiki paste page
01:19:45 <drbean> @help google
01:19:47 <lambdabot>  @google <expr>, search google and show url of first hit
01:20:02 <Petruchio> http://petruchio.perlmonk.org/haskell.txt
01:20:06 <Itkovian> ok
01:20:13 <Itkovian> ah, a perl monk
01:20:16 <Petruchio> :-)
01:20:37 <Itkovian> autrijus convincing people to join the Haskell plebs, or elite, whichever you like
01:20:42 <Itkovian> ?
01:21:40 <drbean> @help type
01:21:41 <lambdabot>  @type: return the type of a value
01:22:07 <Itkovian> ok, so flakeit :: (Int, Int) -> IO () afaict
01:22:32 <Petruchio> I obviously don't properly understand map, here.  By my understanding, if a function can operate on any member of a given list, "map function list" should work.
01:22:42 <Petruchio> Which is why the particulars didn't seem important, in this case.
01:23:00 <Itkovian> hmm, yes, well, I think they do if you are entering a Monad along the way
01:23:15 * Heffalump suggests the use of sequence or sequence_
01:23:16 <mauke> map function list works, but not if the result type is wrong
01:23:24 <Heffalump> (for your particular problem above)
01:23:27 <mauke> or even mapM_
01:23:30 <Itkovian> @type mapM_
01:23:32 <lambdabot> mapM_ :: forall (m :: * -> *) a b.
01:23:32 <lambdabot>    (Monad m) =>
01:23:32 <lambdabot>    (a -> m b) -> [a] -> m ()
01:23:36 <Itkovian> right
01:23:39 <Heffalump> yeah, or that :-)
01:23:42 <Petruchio> I'm not yet to the point in Yet Another Haskell Tutorial where monads are explained.  :-)
01:23:59 <Itkovian> yet you do make use of the IO Monad
01:24:00 <boegel> @index ortho
01:24:02 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans, Graphics.Rendering.OpenGL.
01:24:02 <lambdabot> GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
01:24:04 <Itkovian> dangewr Will Robinson!
01:24:31 <Petruchio> Well, it's not quite that I make use of it.
01:24:48 <Petruchio> As I said, I'm editing another person's code, trying to make use of what I've learned.
01:25:12 <drbean> @help index
01:25:13 <lambdabot>  @index - yay!
01:25:16 <xerox> @type mapM_ :: (a -> IO b) -> [a] -> IO ()
01:25:17 <lambdabot> mapM_ :: (a -> IO b) -> [a] -> IO () :: forall a b.
01:25:17 <lambdabot>               (a -> IO b) -> [a] -> IO ()
01:25:29 <Petruchio> This seemed to be an easy way to simplify what was going on, but evidently there's a snag where IO is concerned.
01:25:34 <xerox> b == () in your case I think.
01:26:13 * Petruchio is not ignoring all the code being suggested, just trying to grok it.
01:26:24 <lispy> @type mapM
01:26:25 <lambdabot> mapM :: forall b (m :: * -> *) a.
01:26:25 <lambdabot>    (Monad m) =>
01:26:25 <lambdabot>    (a -> m b) -> [a] -> m [b]
01:26:34 <Heffalump> wtf?
01:26:41 <xerox> Heffalump?
01:26:46 <Heffalump> why is apt-get installing ghc5 when I ask for ghc6=6.4-4 ?
01:27:01 <Itkovian> well, that's a hard question Heffalump ...
01:27:03 <Heffalump> Oh, I see, I think it's just upgrading it.
01:27:20 <Itkovian> hmm, not so hard after all
01:27:28 <Heffalump> :-p
01:27:28 <lispy> Heffalump: you should get in the habbit of using -u when you run apt
01:27:32 <mauke> Petruchio: each line in that do block must return a result of type IO something
01:27:44 <Heffalump> what's that do?
01:27:50 <Petruchio> Ah.
01:27:55 <Itkovian> update I guess
01:27:56 <lispy> Heffalump: it's supposed to say which packages are being upgraded
01:27:59 <mauke> Petruchio: flakeit seems to return IO () so the original code is ok
01:28:12 <Heffalump> ah, so it does.
01:28:13 <Petruchio> Okay, I wasn't looking at that.
01:28:22 <Heffalump> Actually, it did before, I just wasn't looking in the right place
01:28:34 <lispy> ;)
01:28:35 <mauke> Petruchio: but map flakeit list returns [IO ()], which is not an IO type but a list of IO somethings
01:28:53 <Petruchio> That makes sense.
01:28:55 <Itkovian> Petruchio: it is a Good Thing (tm) to get the types ... it will help you understand the problems
01:29:04 <dons> @type sequence_
01:29:06 <Petruchio> Yes, no doubt.
01:29:06 <lambdabot> sequence_ :: forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
01:29:20 <mauke> Petruchio: mapM is the same as map except it returns IO [a] instead of [IO a]
01:29:46 <michaelw> shapr: ping?
01:29:51 <mauke> i.e. an (IO (list of a)) instead of a (list of (IO a))
01:30:03 <Petruchio> Okay.
01:30:10 <xerox> dons!
01:30:47 <dons> xerox!!
01:30:54 <Petruchio> While the details aren't entirely clear yet, this now makes sense.  I thought the problem was with the arguments to map, not map's return value.
01:30:58 <mauke> and mapM_ is the same as mapM except it ignores the results and returns IO ()
01:31:18 <xerox> dons, is there a way to have lambdabot join/part channels while online, without modifying the autojoin list && recompiling?
01:31:23 <lispy> you can think of () as the nothing return type
01:31:32 <dons> @help join
01:31:34 <lambdabot> join <channel>
01:31:36 <dons> @help part
01:31:37 <lambdabot> part <channel>
01:31:43 <xerox> :)
01:32:30 <xerox> aiskiii, @hoogle (a -> b) -> [a] -> [b]
01:32:31 <aiskiii> Prelude.map :: ((a -> b) -> [a] -> [b])
01:33:10 <xerox> aiskiii, @hoogle (a -> IO b) -> [a] -> IO ()
01:33:12 <aiskiii> Prelude.mapM_ :: Monad a => ((b -> (a c)) -> [b] -> (a ()))
01:33:31 <lispy> oh, pretty
01:33:38 <Petruchio> So, thanks.
01:34:15 <lispy> @hoogle (a -> b -> c -> d) -> (a, b, c) -> d
01:34:17 <aiskiii> Prelude.flip :: ((a -> b -> c) -> b -> a -> c)
01:34:17 <lambdabot> http://www.envplan.com/
01:34:56 <lispy> @hoogle (a -> b -> c -> d) -> ((a, b, c) -> d)
01:34:57 <aiskiii> Prelude.realToFrac :: (Real a, Fractional b) => (a -> b)
01:34:57 <lambdabot> http://www.envplan.com/
01:35:01 <lispy> er...hmm..
01:35:25 <xerox> lispy, please do "aiskiii, @hoohle <type>" or lambdabot will search on @google too :-)
01:35:37 <xerox> err @hoogle, even.
01:37:47 <boegel> aiskiii, @hoogle Depth
01:37:48 <aiskiii> No matches found
01:37:56 <boegel> stupid aiskiii !
01:38:00 <xerox> :(
01:38:04 <boegel> @hoogle Depth
01:38:05 <aiskiii> No matches found
01:38:05 <lambdabot> http://news.bbc.co.uk/1/hi/in_depth/default.stm
01:38:11 <dons> very nice xerox
01:38:15 <xerox> lambdabot, @index depth
01:38:17 <lambdabot> bzzt
01:38:19 <boegel> xerox: just joking ;)
01:38:22 <xerox> boegel, where is it? :-)
01:38:27 <xerox> dons, good :)
01:38:49 <boegel> well, the documentation says it's in Graphics.UI.GLUT.Initailization
01:38:56 <xerox> dons, what's the proper way to implement process _ _ _ _ _ = ... in lambdabot modules?
01:38:57 <boegel> but when I import it ghc still complains :s
01:39:26 <Itkovian> then it must not be in there ...
01:39:53 <xerox> aiskiii, @hoogle (a -> b (a,c)) -> a -> [b] -> (a,[c])
01:39:54 <aiskiii> Prelude.undefined :: a
01:40:10 <xerox> aiskiii, @hoogle (a -> b -> (a,c)) -> a -> [b] -> (a,[c])
01:40:11 <aiskiii> List.mapAccumR :: ((a -> b -> (a, c)) -> a -> [b] -> (a, [c]))
01:40:47 <reffie> aiskiii, @hoogle (b -> a -> (b,c)) -> b -> [a] -> (b,[c])
01:40:48 <aiskiii> List.mapAccumR :: ((a -> b -> (a, c)) -> a -> [b] -> (a, [c]))
01:41:04 <boegel> Itkovian: it is, but apparently I have to use WithDepthBuffer instead
01:41:10 <xerox> aiskiii, @vixen you're really smart!
01:41:12 <aiskiii> i'm really real
01:41:14 <reffie> aiskiii, @hoogle [a] -> Int
01:41:15 <aiskiii> Prelude.length :: ([a] -> Int)
01:41:39 <Itkovian> ah
01:44:19 <lightstep> aiskiii, @hoogle (a -> b) -> a -> b
01:44:20 <aiskiii> Prelude.($) :: ((a -> b) -> a -> b)
01:44:29 <xerox> yay :)
01:44:37 <lightstep> aiskiii, @hoogle (a -> b -> c) -> a -> b -> c
01:44:39 <aiskiii> Prelude.flip :: ((a -> b -> c) -> b -> a -> c)
01:44:57 <lightstep> wha?
01:45:13 <xerox> lightstep, what function is it?
01:45:32 <lightstep> id
01:45:58 <Itkovian> eh?
01:46:03 <Itkovian> @type id
01:46:05 <aiskiii> id :: forall a. a -> a
01:46:05 <lambdabot> id :: forall a. a -> a
01:46:33 <Itkovian> aiskii, @hoogle (a -> b -> c) -> (a -> b -> c)
01:47:04 <Itkovian> aiskiii, @hoogle (a -> b -> c) -> (a -> b -> c)
01:47:04 <aiskiii> Prelude.log :: Floating a => (a -> a)
01:47:13 <Itkovian> well, now ...
01:47:18 <Itkovian> I'll be damned
01:47:20 <lightstep> aiskiii, @hoogle (a -> b -> c) -> (a -> b -> c)
01:47:20 <aiskiii> Prelude.log :: Floating a => (a -> a)
01:47:36 <Itkovian> maybe it needs some refining
01:47:38 <Itkovian> :-)
01:48:03 <boegel> Itkovian: what's wrong ? the type is right :)
01:48:11 <Itkovian> true
01:48:21 <Itkovian> but there are better matching cases imo
01:48:34 <Itkovian> Where does it get the Floating a constraint?
01:48:43 * boegel just 'created' a rotating cube with HOpenGL :)
01:48:57 <Itkovian> ok, code, code, code and post!
01:49:05 <Itkovian> like now.
01:49:08 <Itkovian> :-)
01:50:14 <boegel> Itkovian: I just rewrote a simple example really, so it works with HOpenGL 2.0 :)
01:50:25 <xerox> Itkovian, it needs some refining indeed; as now it does not count typeclasses: a -> a should indeed return id.
01:51:36 <Itkovian> boegel: is that the HOpenGL in ghc 6.4?
01:51:39 <boegel> yep
01:58:44 <boegel> @wiki HaskLS
01:58:45 <aiskiii> http://www.haskell.org/hawiki/HaskLS
01:58:46 <lambdabot> http://www.haskell.org/hawiki/HaskLS
01:58:48 <boegel> Itkovian: ^
02:02:56 * boegel leaves for a while
02:04:44 <lispy> hmm...HOpenGL doesn't seem to be particularly lispy
02:04:51 <lispy> or haskelly as the case may be
02:05:22 <lispy> $=
02:05:26 <lispy> haven't see that before
02:05:34 <lispy> @index ($=)
02:05:35 <aiskiii> bzzt
02:05:35 <lambdabot> bzzt
02:06:20 <lispy> why is there a > on each line of code?
02:06:31 <lispy> is that for literate programming?
02:06:41 <lispy> if so, isn't it easier to use the code environment?
02:06:48 <lispy> iirc that's what darcs uses
02:07:14 <Itkovian> no idea
02:07:22 <dons> > bird style is considered simpler by many
02:07:35 <dons> it's good for emailed code too
02:07:53 <lispy> why is it bird style?
02:08:01 <lightstep> can i reexport a module while hiding an identifier?
02:08:34 <lispy> you can import a module and hide them...
02:08:36 <dons> invented by Bird, I guess
02:08:40 <lispy> ah
02:09:00 <lispy> one of the things i don't like about opengl is face_vertices
02:09:11 <lispy> it seems like there must be a nicer way to define that shape
02:09:15 <dons> Bird&Wadler developed > style
02:09:38 <dons> The "literate comment" convention, first developed by Richard Bird and Philip Wadler for Orwell, and
02:09:42 <dons> inspired in turn by Donald Knuth's "literate programming"
02:09:44 <dons> http://haskell.cs.yale.edu/haskell-report/literate.html
02:11:20 <lispy> weird
02:11:23 <lispy> well, not weird
02:11:27 <lispy> but, different
02:11:49 <lispy> it reminds me that block comment/uncomment is essentially broken in emacs
02:12:01 <dons> > style is definitely more common in .hs code that the latex form
02:12:28 <lispy> it must be a real pain to remember to type > on every line
02:12:53 <mauke> that's what text editors are for
02:12:54 <dons> the joy of literate programming
02:12:59 <lispy> it reminds me of 10 PRINT "Hello, World" 20 GOTO 10 ;)
02:13:01 <dons> like --
02:13:11 <dons> just let your editor do the work
02:13:38 <dons> @code
02:13:38 <aiskiii> module "code" screwed up: getRandItem: empty list
02:13:38 <lispy> how do you tell emacs to switch back and forth?
02:13:39 <lambdabot> Maybe you meant: more todo
02:13:59 <lightstep> @wiki HaskLS <- where does the pink come from?
02:14:00 <lambdabot> http://www.haskell.org/hawiki/HaskLS <- where does the pink come from?
02:14:00 <aiskiii> http://www.haskell.org/hawiki/HaskLS <- where does the pink come from?
02:14:00 <lispy> between > and not
02:14:06 <xerox> aiskiii, @part #haskell
02:14:07 <dons> @code
02:14:08 <lambdabot> Error.hs: eSRCH                = Errno (CONST_ESRCH)
02:14:18 * dons wonders if I'll hit any .lhs
02:14:20 <dons> @code
02:14:21 <lambdabot> Storable.lhs: readFunPtrOffPtr    :: Ptr (FunPtr a)    -> Int -> IO (FunPtr a)
02:14:27 <dons> oh well.
02:14:45 <lightstep> @heko code
02:14:46 <lambdabot>  @code, print random line of code from $fptools
02:15:00 <dons> rnadom code goodness!
02:15:05 <dons> rnadom, I say!
02:15:08 <lightstep> does lambdabot have dwim?
02:15:19 <lightstep> @help heko
02:15:19 <dons> dwim?
02:15:20 <lambdabot>  @help <command> - ask for help for <command>
02:15:29 <lispy> dwim = do what i mean
02:15:30 <lightstep> fixing heko to help
02:15:42 <dons> faq, yes. it does spelling correction
02:15:43 <lispy> emacs is known for dwim
02:15:52 <dons> oh, I'm a Yi guy myself ;)
02:15:55 <lispy> heh
02:16:01 <lispy> no way ;)
02:16:24 <lispy> dons: does Yi have an incremental parser for any languages?
02:16:36 <dons> not yet.
02:16:51 <lispy> i wonder if continuations would make it easier to write one
02:17:10 <dons> i'm not sure it matters anymore
02:17:17 <dons> visual studio just uses the full ghc parser
02:17:30 <dons> as long as we've got concurrency
02:17:36 <lispy> hmmm...
02:18:07 <lispy> it's just continually building the ast of the current program every time you do an edit?
02:18:22 <lispy> (with maybe a pause so that it doesn't do it supriously)
02:18:29 <dons> not sure, probably has a delay of a few chras
02:18:46 <dons> also, ghc's parser has an expr entry point
02:19:00 <dons> so you can just reparse the expr, if you know its starting point
02:19:07 <dons> I plan to use that in Yi
02:19:23 <lispy> nice
02:19:41 <lispy> it's too bad emacs doesn't parse
02:19:50 <lispy> it just uses regex and such
02:20:07 <lightstep> is there a strict getContents?
02:20:21 <lispy> lightstep: hoogle for it ;)
02:20:26 <lispy> @type getContents
02:20:31 <lambdabot> getContents :: IO String
02:20:38 <lightstep> it'd have the same type
02:20:40 <lispy> @hoogle getContents
02:20:42 <lambdabot> http://www.bouncycastle.org/csharp/docs/html/org.bouncycastle.asn1.
02:20:42 <lambdabot> DERApplicationSpecific.getContents.html
02:20:52 <dons> the hoogle patch isn't in lambdabot yet
02:20:54 <lispy> er oh, hoogle is missing...
02:21:43 <xerox> dons, it works with a local hoogle binary.  The author is going to put a repo online soon, anyway.
02:21:46 <lispy> lightstep: does this help? http://www-users.cs.york.ac.uk/~ndm/hoogle/generated/IO.f.hGetContents.htm
02:22:26 <lispy> lightstep: if not, maybe you can use evaluate?
02:22:29 <lightstep> no, it's the same
02:22:31 <lispy> @index evaluate
02:22:32 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
02:22:34 <lightstep> what's evaluate?
02:22:35 <dons> ok, xerox - so I'll need a local binary?
02:22:45 <lispy> lightstep: it forces the computation
02:22:57 <xerox> dons, yep!  Do you want it now or we'll wait until the author release it?
02:23:02 <lispy> lightstep: so if you have x <- getContents; evaluate x; then x is forced to be evaluated
02:23:32 <dons> well, you can send the patch, and then i'll grab the hoogle repo when it's posted
02:23:35 <lightstep> fully forced?
02:23:43 <lightstep> well, i'll check it myself
02:23:47 <lispy> :)
02:24:25 <lightstep> no, not fully forced
02:24:41 <lightstep> @google haskell deepseq
02:24:42 <lambdabot> http://users.aber.ac.uk/afc/stricthaskell.html
02:24:51 <lispy> lightstep: maybe you should look at the Control module
02:25:19 <dawt> anyone experienced with threading support in the compiler..?
02:25:32 <xerox> dons, OK.  Just a question, is this correct?  |process _ _ _ _ _ = error "HoogleModule: invalid command"|
02:25:42 <Itkovian> hmm .. i can't get boegels code to compile
02:26:30 <lispy> Itkovian: what's the error?
02:26:51 <xerox> dons, every module seem to do more or less what it wants with that case.  Some doesn't even implement it.
02:27:31 <p21870> lightstep, doesnt recursively issuing getLine force stuff?
02:27:37 <dons> yeah, that's ok
02:27:46 <lightstep> p21870, yes, it does
02:28:28 <Itkovian> cube.lhs:73:36: parse error on input `output'
02:29:29 <p21870> lightstep, then you can use that?
02:29:51 <lispy> Itkovian: he must have forgot to post part of it
02:30:31 <lightstep> p21870, yes, i wondered if there is a standard function, so i won't need to write those 6 lines
02:31:05 <lightstep> 5, actually
02:34:16 <drbean> field labels cannot be used in more than one datatype in scope. Is ithis a limitation?
02:34:42 <lightstep> yes
02:34:54 <lightstep> but you have typeclasses, so you can overcome it
02:35:42 <drbean> I wanted to work from the bottom up, rather than top down.
02:36:34 <lightstep> you have qualified identifiers, use them
02:36:48 <lightstep> if you work bottom-up, you can put each part of the program in a module
02:37:02 <drbean> Perhaps I can use the presence of workarounds as an indication I haven't got my type classes finished.
02:37:50 <lispy> i like to program bottom up, and i found just using modules and qualifying names works
02:38:14 <lispy> @type Control.Exception.evaluate
02:38:20 <lambdabot> Control.Exception.evaluate :: forall a. a -> IO a
02:39:04 <drbean> Is there any way of having more than one module per file?
02:39:05 <lispy> @type mapM Control.Exception.evaluate [1..]
02:39:07 <lambdabot> mapM Control.Exception.evaluate [1..] :: forall a.
02:39:07 <lambdabot>               (Num a, Enum a) =>
02:39:07 <lambdabot>               IO [a]
02:39:25 <lightstep> drbean, no
02:39:37 <lispy> which is very confusing in the Haskell 98 report
02:39:52 <lispy> they have several examples that LOOK like they are doing that
02:40:11 <shapr> Good morning #haskell!
02:40:22 <lightstep> i'd expect this to be one of the first extensions to the module system
02:40:23 <shapr> genneth: hiya! wassup?
02:40:43 <lispy> lightstep: i'm not sure it's a good idea
02:40:53 <lispy> shapr: morning
02:41:08 <shapr> Good morning Mr lispy! wazzup?
02:41:14 <lightstep> lispy, it works for scheme48
02:41:17 <lispy> shapr: not much ;)
02:41:26 <shapr> tromp: interested in writing about Lambda Cal or Kolmorogov for TMR?
02:41:42 <xerox> dons, sent.
02:41:45 <lispy> lightstep: seems to me that it would be easy to "misplace" modules that way.  I think file names should match module names
02:41:52 <xerox> y0 shapr!
02:41:53 <shapr> musasabi: hey, did you see your JoinHs was linked from one of the LtU comments?
02:41:57 <shapr> y0 xerox, wazzup?
02:42:01 <xerox> shapr, whatch this:
02:42:03 <xerox> -h
02:42:08 <lispy> shapr: i still dont' have any patches for autoproc in my mailbox ;)
02:42:15 <xerox> aiskiii, @hoogle (a -> b -> (a,c)) -> a -> [b] -> (a,[c])
02:42:16 <dons> cheers xerox
02:42:16 <aiskiii> List.mapAccumR :: ((a -> b -> (a, c)) -> a -> [b] -> (a, [c]))
02:42:23 <dons> yay, @hoogle!
02:42:27 <shapr> w00!
02:42:34 <dons> @karma+ xerox
02:42:35 <aiskiii> xerox's karma has been incremented
02:42:36 <lambdabot> xerox's karma has been incremented
02:42:39 <lispy> hehe
02:42:43 <musasabi> shapr: what, where?
02:42:45 * xerox falls from the chair
02:42:46 <lispy> @karma xeros
02:42:46 <shapr> Man, I want to see the source for @hoogle, does it really use unification?
02:42:46 <aiskiii> xeros has a karma of 0
02:42:47 <lambdabot> xeros has a karma of 0
02:42:47 <lispy> @karma xerox
02:42:48 <aiskiii> xerox has a karma of 1
02:42:48 <dons> aiskiii, @version
02:42:49 <lambdabot> xerox has a karma of 2
02:42:49 <aiskiii> lambdabot 3p3, GHC 6.4 (Linux i686)
02:42:49 <aiskiii> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:43:07 <shapr> Oh cool, you've got tag plus additional patches?
02:43:14 <lispy> @karma c
02:43:14 <musasabi> found it :-)
02:43:15 <aiskiii> c has a karma of 0
02:43:16 <lambdabot> c has a karma of 0
02:43:24 <xerox> shapr, it's not currently released the author will publish the sources soon.
02:43:25 <dons> shapr, yep.
02:43:41 <lispy> in another channel i'm the command to increase karma is just ++, so C has amazing karma there ;)
02:43:43 <xerox> shapr, he sent to me the code, anyway, if you can't wait I could sent them to you I think.
02:43:56 <dons> xerox, I think you forgot to darcs add Hoogle.hs?
02:44:05 <shapr> dons: That's a good way to do version numbers, is the algorithm easily used by any darcs repo?
02:44:07 <dons> the patch you sent me doesn't have the Hoogle.hs code.
02:44:11 <lispy> darcs record -l
02:44:18 <xerox> dons, right! Sorry.
02:44:19 <lispy> that's a good command to get in the habbit of using
02:44:19 <shapr> @karma shapr
02:44:20 <aiskiii> You have a karma of 0
02:44:21 <lambdabot> You have a karma of 0
02:44:24 <shapr> :-P
02:44:33 <musasabi> Nice to see people talking about arrows - but they still need a good interface.
02:44:33 <lispy> makes darcs "look for adds"
02:44:33 <xerox> dons, I redo it.
02:44:35 <shapr> xerox: nah, I'll be patient. I have enough to do.
02:44:47 <dons> shapr - yep. here comes the code:
02:44:48 <dons> PATCH_COUNT=`darcs changes --xml-output | sed -n '/TAG/q;/^<\/patch/p' | wc -l | sed 's/ *//g'`
02:44:55 <musasabi> The pairs of pairs of pairs of ... just does not scale :-(
02:45:07 <dons> "lambdabot 3p", PATCH_COUNT
02:45:28 <dons> so it gets run in configure.ac
02:45:37 <lispy> dons: lambdabot needs a command that allows you to do the informational darcs commands, such as darcs changes
02:45:41 <shapr> Hm, could that be more general by doing tag + PATCH_COUNT ?
02:45:50 <lispy> dons: then people could look at the patches for lambdabot
02:45:59 <dons> yep, you could easily extra the tag from the --xml-output
02:46:16 <dons> lispy, this is a good idea.
02:46:27 <dons> extra-ct
02:47:10 <shapr> musasabi: http://lambda-the-ultimate.org/node/view/750#comment-6796
02:47:34 <lispy> man, i should go to sleep
02:47:42 <lispy> ttyl
02:48:03 <dons> tty
02:48:04 <shapr> g'nite
02:48:04 <dons> /dev/ttyp4
02:48:10 <xerox> 'night lispy
02:48:14 <xerox> dons, sent, again :)
02:48:23 <shapr> tty: /dev/ttyl
02:48:38 <dons> xerox, yep, looks better.
02:48:50 <xerox> I don't use darcs enough :)
02:49:30 <shapr> musasabi: Who's talking about arrows? Do you mean the a <~ b syntax?
02:49:52 <xerox> Oh, that syntax... shapr, do you know how to make it work?
02:49:59 <dons> a ~> b?
02:50:07 <shapr> dons: right, that one
02:50:23 <dons> a <~ b looks like an arrow that would hit you in the eye
02:50:28 <shapr> haha
02:50:40 <xerox> lambdabot, @type arr id :: (Control.Arrow.Arrow (~>)) => b ~> b
02:50:40 <shapr> Remember, the pointy end goes the other direction.
02:50:42 <dons> maybe that's a boomerang
02:50:42 <lambdabot> bzzt
02:51:03 <dons>  hard   to draw boomerangs in ascii
02:51:13 <xerox> \_
02:51:14 <shapr> It's just a lambda
02:51:19 <musasabi> shapr: my issue with arrows is that they are basically monadic (as opposed to polyadic) which is not very nice.
02:51:32 <dons> and just when I was going to generalise arrows and spears into boomerangs and yoyos
02:51:33 <shapr> Could they be polyadic?
02:51:42 <shapr> hoi Smurfje
02:51:43 <musasabi> but this has little to do with theoretical foundations and everything with interfacing with them.
02:51:51 <Smurfje> hehe
02:52:07 <Muad_Dibber> dont ask me about that nick :P
02:52:12 <dons> so we'd have: a @------- b and b -------@ a
02:52:14 <shapr> dons: When Sydney hosts ICFP, boomerangs must be the leaving gift, (as per the QuotesPages)
02:52:16 <dons> in my yoyo model
02:52:34 * dons should use yoyo notation more often
02:52:34 <shapr> What would the "around the World#" trick do?
02:52:42 <musasabi> shapr: not really, as Haskell does not have proper polyadicity (only functions returning functions).
02:53:02 <musasabi> and as "function arg1 arg2" is function application there is quite little one can do.
02:53:40 <dons> @ -@ --@ ---@ ----@ ------@ ----@ ---@ --@ -@ @, just need to work out a semantics for them..
02:53:41 <aiskiii> Maybe you meant: all-dicts arr babel code define definitions del-
02:53:41 <aiskiii> definition devils dice dict dict-help docs dummy dynamic-load
02:53:41 <aiskiii> dynamic-reload dynamic-unload easton echo elements eurohaskell eval
02:53:41 <aiskiii> fact fact-cons fact-delete fact-set fact-snoc fact-update foldoc
02:53:41 <aiskiii> fortune gazetteer get-definition ghc google help hitchcock hoogle
02:53:41 <aiskiii> index jargon join karma karma+ karma- kind learn leave libsrc
02:53:41 <lambdabot> Maybe you meant: all-dicts arr babel code define definitions del-
02:53:41 <lambdabot> definition devils dice dict dict-help docs dummy dynamic-load
02:53:41 <lambdabot> dynamic-reload dynamic-unload easton echo elements eurohaskell eval
02:53:41 <lambdabot> fact fact-cons fact-delete fact-set fact-snoc fact-update foldoc
02:53:41 <lambdabot> fortune gazetteer get-definition ghc google help hitchcock index
02:53:42 <lambdabot> jargon join karma karma+ karma- kind learn leave libsrc listchans
02:53:43 <aiskiii> listchans listcommands listmodules lojban moo more msg part paste pl
02:53:44 <lambdabot> listcommands listmodules lojban moo more msg part paste pl pl-resume
02:53:45 <aiskiii> [4 @more lines]
02:53:45 <dons> ooopss.
02:53:46 <lambdabot> [4 @more lines]
02:53:49 <xerox> ahahah
02:53:49 <shapr> Sure, string me along and make me believe yoyo notation exists.
02:53:52 <musasabi> (with tupled arguments one gets "function (arg1, arg2)" and this does not play nice with partial application.
02:53:56 <xerox> aiskiii, @part #haskell
02:53:57 <dons>  yoyo notation doesn't play well with lambdabot
02:54:37 * dons intends to develop the yoyo notation for a forthcoming TMR
02:54:42 <shapr> It looks vaguely like stack scrambler notation for Joy.
02:54:50 <shapr> dons: too bad you missed the April issue
02:55:00 <dons> oh, true :/
02:55:22 <shapr> Oh hey, I'm sure it's a yoyomorphism
02:55:33 <dons> yeah!
02:55:50 <dons> and we can use yoyo tricks for all the other -phisms
02:55:59 <shapr> Programming with Bananas, Lenses, Barbed Wire, Envelopes, YoYos, and the juvenile delinquents next door.
02:56:35 <dons> I see great potential in YoYo style
02:56:51 <shapr> Are you familiar with YoYoDyne?
02:58:44 <shapr> Oh hey! I got "Dead Reckoning : Calculating without Instruments" By Robert W. Doerfler. Man this is a cool book!
02:59:07 <shapr> It's along the lines of my blog posts that explore the idea of "Programming is Not For Computers"
02:59:17 <shapr> It's all about how to efficient mental algorithms.
03:00:28 <shapr> I hope I can generalize some of these ideas to spoken crypto.
03:01:33 <musasabi> spoken crypto sounds nice :-)
03:21:12 <dons> @code
03:21:13 <lambdabot> Eq.hs: Eq(..),
03:21:15 <dons> @code
03:21:17 <lambdabot> Exception.lhs: \begin{code}
03:21:21 <dons> ah! .lhs
03:21:26 <dons> @code
03:21:27 <lambdabot> Environment.hs: isPathSeparator :: Char -> Bool
03:21:32 <dons> free code for all!
03:21:41 <dons> @code
03:21:42 <lambdabot> Storable.hs: instance HasBounds StorableArray where
03:21:47 <dons> oh, an instance
03:22:03 <lightstep> seems like most of the lines in fptools are metacode
03:22:09 <lightstep> @code
03:22:10 <lambdabot> ReadP.hs: ReadS,      -- :: *; = String -> [(a,String)]
03:22:12 <lightstep> @code
03:22:13 <lambdabot> Internals.hs: commandToProcess string = return ("/bin/sh", ["-c", string])
03:22:17 <dons> that's real code!
03:22:26 <lightstep> yes
03:22:40 <lightstep> on the 6th try
03:22:48 <dons> maybe I should inspect ghc source instead..
03:23:10 <dons> rather than library source, which is high in #defs and meta code
03:23:16 <xerox> ...and call it @trip-to-the-unknown
03:39:16 <boegel> @index updateIORef
03:39:17 <lambdabot> bzzt
03:39:38 <boegel> @writeIORef
03:39:39 <lambdabot> Unknown command, try @listcommands.
03:39:44 <boegel> @index writeIORef
03:39:44 <lambdabot> Data.IORef
03:39:55 <boegel> isn't there a updateIORef function ?
03:41:58 <boegel> @index rotate
03:41:59 <lambdabot> Data.Bits, Foreign, Graphics.Rendering.OpenGL.GL.CoordTrans,
03:41:59 <lambdabot> Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.
03:41:59 <lambdabot> GLUT
03:41:59 <lightstep> @type Data.IORef.modifyIORef
03:42:05 <lambdabot> Data.IORef.modifyIORef :: forall a.
03:42:05 <lambdabot>          GHC.IOBase.IORef a -> (a -> a) -> IO ()
03:42:16 <boegel> lightstep: thanks :)
03:42:56 <boegel> @type Graphics.UI.GLUT.rotate
03:42:58 <lambdabot> bzzt
03:43:08 <boegel> eh ?
03:43:22 <lightstep> @type GLUT.rotate
03:43:23 <lambdabot> bzzt
03:43:27 <boegel> @type Graphics.Rendering.OpenGL.rotate
03:43:28 <lambdabot> Graphics.Rendering.OpenGL.rotate :: forall c.
03:43:28 <lambdabot>             (Graphics.Rendering.OpenGL.GL.CoordTrans.MatrixComponent
03:43:28 <lambdabot> c) =>
03:43:28 <lambdabot>             c -> Graphics.Rendering.OpenGL.GL.CoordTrans.Vector3 c ->
03:43:28 <lambdabot> IO ()
03:44:45 <dcoutts> @seen jyp
03:44:46 <lambdabot> I saw jyp leaving #haskell 25 days, 13 hours, 8 minutes and 33
03:44:46 <lambdabot> seconds ago, and I have missed 10 days, 8 hours, 9 minutes and 12
03:44:46 <lambdabot> seconds since then.
03:44:55 <dcoutts> hmmm
03:45:19 <boegel> lambdabot has missed 10 days? wow
03:45:55 <dcoutts> jyp had a Gtk2Hs bug report for me and now I can't find him :-(
03:46:47 <boegel> heh
03:47:36 <Itkovian> boegel: does your code miss anything? check line 73
03:47:46 <dcoutts> so how do I track him down :-)
03:48:04 <Itkovian> "output left in -"
03:48:51 <dons> hmmm.
03:48:56 <dons> 10 days doesn't seem right.
03:49:10 <dons> @seen dcoutts
03:49:11 <lambdabot> dcoutts is in #haskell. Last spoke 1 minute and 24 seconds ago.
03:49:37 <dons> must have been a gap in the @seen state during an update
03:50:37 <boegel> Itkovian: I don't think so
03:51:11 <dcoutts> ah ha! jyp is J.P. Bernardy
03:52:09 <boegel> Itkovian: output ? uh ?
03:52:11 <Itkovian> boegel: well, it doesn't compile anyway ...
03:52:30 <Itkovian> >           draw_face (colour, face) = do color colour
03:52:30 <Itkovian> >                                    output left in -
03:52:30 <Itkovian>      renderPrimitive Quads face
03:52:34 <Itkovian> ?
03:52:53 <Itkovian> anywya, I'm goign to feed Elias first, so take yr time :-)
03:53:03 <dcoutts> the internet+google is great for tracking people down :-) got his email address
03:54:15 <boegel> there no "output left in" line in the code on the wiki :)
03:57:36 <boegel> hey wait
03:57:37 <boegel> there is
03:57:44 <boegel> but it's not in my wiki code :s
03:58:07 <boegel> seems like a wiki bug ?
03:58:42 * boegel doesn't get this :s
03:58:42 <shapr> boegel: yeah, bug in my code
03:58:49 <boegel> y0 shapr :)
03:58:53 <shapr> hoi boegel
03:58:53 <boegel> how can I avoid it ?
03:58:57 <shapr> Um...
03:59:05 <shapr> comments on a separate line I think
03:59:23 <boegel> there are no comments in that piece of code :D
03:59:38 <boegel> @wiki HaskLS
03:59:39 <lambdabot> http://www.haskell.org/hawiki/HaskLS
03:59:43 <boegel> shapr: ^
03:59:56 <shapr> The problem is that -- means "end of command line params" for gnu utils, that's the only bug I know.
04:00:07 <boegel> hmm
04:00:16 <boegel> I do have comments code in the first bit though...
04:00:26 <autrijus_> hey shapr. I'm going to go offline to finish hw2005.txt now
04:00:30 <autrijus_> shapr: have you take a look at it?
04:00:41 <shapr> autrijus_: sadly no, I've been distracted.
04:00:50 <p21870> distraction is good
04:00:58 <autrijus_> shapr: aw. :-/
04:01:05 <autrijus_> I have only today to finish it
04:01:07 <shapr> autrijus_: but I can look at it right now, can I send you email in about half an hour?
04:01:09 <boegel> shapr: the problem stays, even when I delete all the "--" bits
04:01:13 <autrijus_> shapr: that'd be much appreciated.
04:01:26 <autrijus_> # http://svn.openfoundry.org/pugs/docs/talks/hw2005.txt
04:01:30 <shapr> autrijus_: excellent, I'll read it now.
04:02:10 <shapr> boegel: I'll check it out after I read autrijus' doc, I know it's a bug in my enscript plugin for MoinMoin.
04:02:43 <boegel> shapr: okay then :)
04:02:45 <dawt> does haskell support threads..?
04:02:53 <shapr> dawt: yes, very well.
04:03:09 <dawt> how do threads affect haskell..?
04:03:15 <shapr> three flavors of threads, though the SMP threads may count separately.
04:03:49 <autrijus_> shapr: I'll wait for your mail then. ciao! &
04:04:06 <shapr> dawt: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Concurrent.html
04:04:15 <boegel> shapr: if you want to read autrijus's but, you should probably go offline, right ? :)
04:04:25 <shapr> boegel: probably, yes
04:04:32 * shapr bails out
04:04:47 <boegel> hehe
04:05:09 <dawt> hacking mood..
04:05:29 <dawt> what do threads do anyway..?
04:05:35 <dawt> i have no clue..
04:06:08 <dawt> since they say like, nptl is faster compared to linuxthreads.. i've witnessed that on fedora..
04:06:42 <boegel> threads make concurrent execution possible
04:07:06 <boegel> but you probably already know that :)
04:07:42 <dawt> no, but thanks..
04:08:13 * dawt is noob to the !shebang..
04:08:26 <dawt> eep.. !# ..?
04:08:33 <dawt> no.. #! ..
04:09:37 <dawt> mm..
04:11:25 <boegel> err... ?
04:21:10 <dawt> you're so post 90's..
04:24:54 <boegel> dawt: and you're weird :)
04:40:34 <shapr> autrijus: nifty!
04:40:42 <shapr> autrijus: patch sent your way
04:42:02 <shapr> michaelw: you called?
04:42:30 <shapr> greetz wli, how's code?
04:55:07 * Lemmih ponders what to hack.
04:55:31 <dons> you could send me your hs-plugins profiling hacks?
04:57:35 <Lemmih> Oh yeah, that's right.
05:10:27 <boegel> @index getArgs
05:10:28 <lambdabot> System.Environment
05:17:44 <boegel> Lemmih: I have a working HOpenGL thingie for HaskLS, all I need to do now is interpret a string computed by the L-system, and compose a Vertex3 list based on that interpretation
05:18:11 <Lemmih> Neat.
05:20:37 <Itkovian> boegel: what's the exact stuff on the line with '>                                         renderPrimitive Quadoutput left in -
05:20:40 <Itkovian> s face' ?
05:24:37 <boegel> renderPrimitive Quads face
05:24:50 <boegel> as the wiki says, remove "output left in - s"
05:27:25 <boegel> Itkovian: does it work now?
05:29:14 <Lemmih> s/not/note/ on the wiki page?
05:31:36 <boegel> Lemmih: thanks :)
05:36:34 <shapr> shazam!
05:36:45 * Lemmih wonders if he must recompile GHC or just the RTS when he misses a symbol.
05:36:54 <boegel> shapr: ? :)
05:37:03 <shapr> ndm: Did you write Hoogle?
05:37:16 <ndm> shapr: Yes
05:37:31 <shapr> Are you using type unification for searching?
05:38:02 <shapr> If so, I have a few more questions...
05:38:32 <ndm> yes, i am using unification
05:38:36 <ndm> feel free to ask...
05:38:46 * boegel feels a "write a TMR article" request coming up
05:39:02 <dons> Lemmih, recompile the rts, then relink ghc
05:39:31 <dons> ndm, have you put a binary up?
05:39:38 <ndm> not yet
05:39:46 <dons> xerox wrote a plugin to lambdabot, and its in the main repo now
05:39:50 <ndm> i have it on my todo list
05:40:05 <shapr> It's true, I'd love to have an article on Hoogle in The Monad.Reader.
05:40:13 <ndm> ok, i'll put up the binary/source in the next few days
05:40:14 <dons> well, as soon as I can get the src I can turn on @hoogle here in #haskell
05:40:32 <ndm> i'll certainly write a hoogle article, but not until next month
05:40:44 <ndm> i'm rather busy with other stuff til then, unfortunately
05:40:54 <shapr> But I was wondering more about how you match types.
05:41:06 <ndm> dons: can i email it to you privately? so it doesn't spread too far until the worst bugs are fixed
05:41:13 <dons> yep, that's fine.
05:41:29 <shapr> ndm: Why not just use a darcs repo? Then you can fix bugs and people can auto-update.
05:41:42 <ndm> i don't use darcs, but i'd happily put it in CVS
05:41:43 <dons> it's peer-to-peer patches!
05:41:59 <ndm> if i had a CVS server that was available to me
05:42:07 <shapr> You don't need a cvs server if you use darcs.
05:42:08 <ndm> i know, but www.tortoisecvs.org makes CVS so easy
05:42:21 <dons> you could use cvs2darcs to put any cvs stuff in darcs, and then use darcs
05:42:23 <ndm> good point, i might darcs it then
05:42:34 <shapr> If you use a darcs repo on your desktop, I can mirror it nightly on ScannedInAvian.org
05:42:53 <ndm> but not for a while, i don't have the time to learn it at the moment
05:43:04 <dons> ndm, darcs to cvs is like comparing Haskell to assembly
05:43:06 <shapr> You probably do have time to learn it actually, it takes about ten minutes.
05:43:07 <boegel> @index fromLust
05:43:09 <lambdabot> bzzt
05:43:14 <shapr> But I won't be pushy about it :-)
05:43:25 <boegel> @index fromJust
05:43:26 <lambdabot> Data.Maybe
05:43:27 <ndm> thanks, i will learn - but other things come first
05:43:32 <shapr> ok
05:43:37 <dons> :)
05:43:45 <ndm> i'll just bung the source up now, give me a sec...
05:44:47 <ndm> http://www-users.cs.york.ac.uk/~ndm/temp/hoogle-src.tar
05:44:57 <dons> cheers!
05:45:05 <shapr> thanks!
05:45:06 <ndm> should be easy enough to compile it, but if you need x86 linux or windows binary, just ask
05:45:23 <ndm> with regards to the unification algorithm
05:45:27 <ndm> it tries to unify the types
05:45:45 <ndm> then marks the unification down, based on what things it did badly
05:46:07 <ndm> like unifying two variables to the same variable, unifying a type variable to a concrete type etc.
05:47:13 <shapr> Could this be used to do type error slicing?
05:47:28 <ndm> i don't know what that is?
05:47:48 <shapr> http://www.macs.hw.ac.uk/ultra/compositional-analysis/type-error-slicing/slicing.cgi
05:48:29 <dons> hoogle searches for hoogle.txt in the pwd?
05:48:52 <dons> ok, got it
05:49:25 <ndm> yes, it does
05:49:34 <ndm> but you can edit it easily enough, its hardcoded in
05:50:44 <ndm> Its not designed for type error slicing, and its not that clever, but it might be able to be pushed into doing that
05:52:46 <dons> @help hoogle
05:52:47 <lambdabot>  @hoogle <expr>, Haskell API Search for either names, or types.
05:52:53 <dons> @hoogle a -> a
05:52:55 <lambdabot> Prelude.log :: Floating a => (a -> a)
05:53:03 <shapr> only the first result?
05:53:06 <dons> @hoogle map
05:53:08 <lambdabot> Prelude.map :: ((a -> b) -> [a] -> [b])
05:53:12 <shapr> @hoogle a -> b -> c
05:53:13 <lambdabot> Prelude.(^) :: (Num a, Integral b) => (a -> b -> a)
05:53:24 <dons> looks like that for now
05:53:26 <ndm> it doesn't understand classes
05:53:30 <dons> @version
05:53:31 <lambdabot> lambdabot 3p2, GHC 6.4 (OpenBSD i386)
05:53:31 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:53:38 <ndm> it should be easy enough to add more than one result
05:53:43 <dons> feel free to extend Hoogle.hs
05:53:45 <shapr> @hoogle a -> m a
05:53:46 <lambdabot> Prelude.return :: Monad a => (b -> (a b))
05:53:55 <shapr> nifty
05:54:07 <dons> I think xerox planned to add @hoogle+ or such like for more results
05:54:08 <ndm> and i have tweaked the web version so that you can fire off queries automatically
05:54:16 <dons> oh, google style?
05:54:20 <ndm> as a sort of more... command
05:54:36 <ndm> http://www-users.cs.york.ac.uk/~ndm/hoogle/?a-%3E[b]
05:54:39 <ndm> for example
05:54:45 <dons> yep, ok. we could use that from lambdabot instead
05:54:52 <shapr> @hoogle a -> b -> a b c
05:54:53 <lambdabot> Prelude.divMod :: Integral a => (a -> a -> (a, a))
05:54:59 <ndm> probably best to use the command line version
05:55:17 <ndm> york.ac.uk doesn't seem to like bots scraping the website - they kept giving access denied errors
05:55:22 <shapr> oops
05:55:26 <dons> well, I have to keep up to date as you extend hoogle. unless hoogle was in darcs...
05:55:43 <shapr> oh, the subtlety
05:55:49 <dons> also, probably slows things down grabbing results from .uk when lambdabot was in .au
05:55:57 <ndm> yeah
05:56:03 <ndm> well i'll fix it up soon
05:56:10 <ndm> got to go now, back in an hour
05:56:12 <ndm> bye
05:56:15 <dons> cheers ndm
05:57:26 <lightstep> @hoogle Arrow a => a b c -> a [b] [c]
05:57:27 <lambdabot> List.genericSplitAt :: Integral a => (a -> [b] -> ([b], [b]))
05:57:39 <dons> yeah, so we need to give a few results back
05:57:57 <Lemmih> How can exporting one symbol give 100+ linker errors? *sigh*
05:58:03 <lightstep> is there such a function? i can't define it myself
05:59:22 <TheHunter> @type Control.Arrow.arr map
05:59:24 <lambdabot> Control.Arrow.arr map :: forall (a :: * -> * -> *) a1 b.
05:59:24 <lambdabot>          (Control.Arrow.Arrow a) =>
05:59:24 <lambdabot>          a (a1 -> b) ([a1] -> [b])
06:00:18 <Itkovian> boegel: yes it works, very smoothly
06:00:54 <lightstep> if (~>) is an arrow, a function type in the model language, i want `map' in that language
06:01:25 <Itkovian> @type ($=)
06:01:26 <lambdabot> bzzt
06:02:25 <TheHunter> oh, that was wrong...
06:02:53 <TheHunter> you need ArrowChoice for that.
06:03:09 <TheHunter> unless you only want it to work for streams.
06:03:50 <lightstep> yes, i do. my problem is that i get non-strict infinite loops every time i try. sometimes they leak space, and sometimes not
06:04:03 <lightstep> (i do have an ArrowChoice, that is)
06:06:26 <TheHunter> i think there's only one sensible definition of that function, so if you need different semantics, you'll need to change your Arrow type.
06:07:41 <lightstep> the stack behaviour depends on the details of tying the loop
06:26:49 <Lemmih> Oh no. I've introduced a bug in Cabal /-:
06:28:25 * boegel leaves for squash
06:28:30 <Itkovian> have fun
06:46:13 <shapr> @yow !
06:46:14 <lambdabot> Well, I'm a classic ANAL RETENTIVE!!  And I'm looking for a way
06:46:14 <lambdabot> to
06:46:14 <lambdabot> VICARIOUSLY experience some reason to LIVE!!
06:46:42 <shapr> as if!
06:46:51 <Itkovian> wtf?!
06:47:22 <shapr> I was in MINNETONKA! Butch Cassidy has my children!
06:49:02 <Itkovian> obviously :-)
06:49:19 <shapr> Party on Itkovian!
06:50:18 <shapr> I'm looking for more information on mental algorithms, any ideas?
06:55:02 <Lemmih> dons: How do I recompile the RTS and then relink GHC?
06:56:28 <Lemmih> n/m.
07:00:15 * shapr boings cheerfully
07:00:42 <HmR`> burp
07:01:13 <shapr> I've discovered jazz!
07:01:20 <shapr> Still not sure I understand it, but it sure is fun.
07:01:34 <HmR`> thats so overrated
07:01:57 <HmR`> drL`blok is desperate
07:02:13 <shapr> Is that so?
07:02:24 <drL`blok> ?
07:02:30 <drL`blok> lol, who is this guy?
07:02:51 <HmR`> im your worst daydream
07:03:05 <shapr> My worst daydream is female.
07:03:17 <Philippa_> and frustrating?
07:03:24 <shapr> Philippa_: We'll have nun of that here.
07:03:29 <HmR`> then dont bother mentioning your best :p
07:03:34 <drL`blok> wow, HmR` is a girl?
07:03:39 <shapr> My best daydream is female too.
07:03:45 <Philippa_> :-)
07:03:59 <HmR`> LETS DRIVE
07:04:00 <Philippa_> am spending a little too much time crushing on various female friends of mine atm
07:04:09 <shapr> HmR`: So, you learning Haskell?
07:04:12 <HmR`> |^^^^^^^^^^ ^^^ ||______
07:04:12 <HmR`> |.The WHO GIVES A | ||'""|""\_,_
07:04:12 <HmR`> | __ FUCK TRUCK __ l ||__|__|_|)
07:04:12 <HmR`> |(@)(@)****(@)(@)****|( @)**
07:04:18 <shapr> um
07:04:21 <drL`blok> oO
07:04:25 <shapr> HmR`: that's irc spam, that's not nice.
07:04:41 <shapr> drL`blok: Are you learning Haskell?
07:04:46 <HmR`> i prefer to call it asci art :)
07:04:57 <drL`blok> i have, in 2004
07:04:57 <shapr> Yes, but this isn't #ascii-art
07:04:58 <Philippa_> as drawn by vikings?
07:05:11 <shapr> drL`blok: What do you think? You like it?
07:05:43 <drL`blok> i don't really like functional programing
07:05:51 <shapr> Oh, why so?
07:06:06 <drL`blok> it feels weird to write
07:06:15 * Itkovian things somebody just said the wrong thing to the wrong person
07:06:20 <shapr> Did other programming feel weird when you started?
07:06:35 <drL`blok> not really i started with aiwars :p
07:06:43 <Itkovian> try to leave him in one piece shapr
07:06:55 <shapr> For me, new things often feel weird, and I don't really know if I like something until I've done it a bit.
07:07:11 <shapr> Especially if it involves doing a familiar thing in a unfamiliar way.
07:07:17 <drL`blok> I had to write a program in it, so i've done it a 'bit'
07:07:18 * Itkovian sits back and enjoys the conversation ... $50 on shapr
07:07:29 <shapr> I started doing functional programming after years of writing Python, Java, etc
07:07:34 <Philippa_> a single program isn't really enough to get the feel of it
07:07:42 <Philippa_> well, unless it's a single 10KLoC kinda program
07:07:43 <drL`blok> y ok, i agree
07:08:05 <HmR`> im currently enjoying (euh not) microcode
07:08:05 <shapr> It was really brain twisting at first, but I ended up preferring the functional approach because it's simpler. Of course, it may only be simpler from my viewpoint.
07:08:20 <shapr> HmR`: oh, really? Intel microcode?
07:08:43 <Philippa_> I should write something that isn't a compiler, interpreter or CGI again
07:08:47 <shapr> I've read that there's an interim step between FPGAs and ASICs, is that what microcode is about?
07:08:49 <Philippa_> that is, something that isn't essentially a translator
07:09:01 <HmR`> nah its for univerisity ; integer java virtual machine
07:09:23 <Philippa_> microcode's normally code that a CPU runs to tell it how to interpret its external instruction set
07:09:33 <Philippa_> I would've called that 'bytecode' rather than 'microcode'
07:09:38 <HmR`> yup its about the lowest u can get
07:10:11 <shapr> drL`blok: I did J2EE for a coupla years, the biggest problem I had was that I could never rely on any of the state of the webapp. Anything could be changed even while I was using it. That can't happen in Haskell, and I like that.
07:10:57 <shapr> Another thing I find simpler in Haskell is that everything has a 'limited future.'
07:11:03 <Philippa_> ?
07:11:07 <Philippa_> not sure I've heard this one?
07:11:12 <shapr> With an object, any value can be changed as many times as you want.
07:11:25 <Philippa_> ah, gotcha
07:11:31 <Itkovian> shapr: microcode is what tramslates e.g. CISC instructions into smaller macro-ops
07:11:52 <shapr> If you simulate objects with partial application, you know the entire possible 'future' of the partial application.
07:12:19 <drL`blok> erf, you lost me there
07:12:33 <shapr> Itkovian: Oh that's interesting. Do you know if the specs are available for that sort of thing? I have some older microcode supporting CPUs lying around.
07:12:35 <drL`blok> en btw there is nobody on #ascii-art :(
07:13:06 <shapr> drL`blok: You know you can pass some, but not all of the arguments to a function?
07:13:11 <Itkovian> shapr: no idea, really.
07:13:31 <drL`blok> that's lambda calculus .. ?
07:13:43 <Itkovian> drL`blok: right
07:13:46 <drL`blok> application rule
07:13:46 <shapr> Itkovian: I've been hoping that updatable microcode might be a cheap way to fake FPGAs on Intel cpus.
07:14:19 <shapr> drL`blok: Yeah, that's it. You can use that to emulate OOP-style objects.
07:14:24 <Itkovian> shapr: heh ... I doubt it.
07:14:41 <shapr> I doubt it too, but I gotta follow up on that just in case it will work.
07:14:43 <Itkovian> would be cool thpugh
07:15:25 * drL`blok <- afk
07:15:28 <shapr> drL`blok: In Haskell, you can fake a 'sort object' by giving a function to sortBy, something like sortBy (\(x,y) -> y)
07:15:35 * drL`blok <- nopz, afk
07:15:44 <shapr> <- running around in circles
07:15:55 <shapr> Dang, they always escape...
07:16:09 <shapr> drL`blok: come back! I want to subject you to the rigors of type theory!
07:16:22 * shapr searches for an unsuspecting victim.
07:16:32 <shapr> HmR`: hi! How are you?
07:16:40 <Lemmih> haha
07:16:53 * HmR` <- afk
07:16:53 <shapr> hiya Lemmih, wassup?
07:16:57 <shapr> aww
07:17:41 * Lemmih will go enjoy the beautiful weather on his uni.
07:17:51 <shapr> Lemmih: hey! did I tell you about my new unicycle?
07:18:08 <Lemmih> No you didn't. Got pictures?
07:18:24 <shapr> Yeah, I do.. but it's pictures of the same uni built by someone else...
07:18:24 * shapr gets url
07:18:50 <shapr> You can click on the thumbnails in the bottom right - http://www.scannedinavian.com/2005-05-16.html
07:19:54 <shapr> Lemmih: That black frame in those first two pictures is now on the chair behind me, waiting for the rest of the pieces I purchased to arrive.
07:21:51 <Itkovian> wow
07:22:00 <Itkovian> that is one hell of a wheel you got yrself there
07:22:22 <shapr> Yeah, 3.7 inches, on a 65mm rim
07:22:45 * Lemmih looks at his uni, scraped together from various old pieces.
07:23:00 <shapr> Lemmih: I'll send you more parts soon :-)
07:23:20 <Lemmih> :D
07:31:58 <drbean> '/join #perl6
07:32:21 <drbean> read acme's inflight use.perl post: http://use.perl.org/~acme/journal/24067
07:32:43 <drbean> sorry wrong channel
07:33:41 * Lemmih unicycles to the park for a little devil-stick practice.
07:35:48 <ndm> shapr: back, so if you have any hoogle questions, ask away
07:36:19 <Itkovian> shapr: how hard is it to learn?
07:38:20 <Itkovian> anybody here using lout instead of LaTeX ?
07:48:05 <p21870> anybody using word instead of LaTeX :P
07:48:57 <shapr> Itkovian: Not hard, it took me about ten hours of training to be able to ride without hanging onto the wall. And I'm older than you, so you'll probably learn faster. :-)
07:49:56 <Itkovian> yeah, you're prolly like three years older ... that'll really make a difference :-)
07:50:03 <shapr> How old are you?
07:50:09 <shapr> I'm 33!
07:50:09 <Itkovian> 27
07:50:14 <shapr> Hah, six years :-P
07:50:14 <Itkovian> ah
07:50:16 <Itkovian> oops
07:50:31 <shapr> I learned last year.
07:50:31 <reffie>  http://news.bbc.co.uk/2/hi/technology/4072704.stm
07:51:37 <Itkovian> holy crap ...
07:51:53 <shapr> I'd like to get a recumbent bicycle, something like tromp has.
07:51:55 * Itkovian wonders why anybody would buy a bloody game sword
07:53:07 <reffie> http://news.bbc.co.uk/2/hi/americas/4072746.stm
07:53:12 <p21870> "We want Qui to die, and immediately," he added.
07:53:14 <p21870> lol
07:53:23 <p21870> clear opinion
07:53:56 <Itkovian> leaves no room for mistakes ...
07:54:07 <p21870> law about virtual property lol, what's next....this guy broke into my simhouse
07:54:07 <p21870> hahaha
07:54:29 <p21870> some guys take games soooo serious
07:54:55 <Itkovian> yeah
07:55:14 <Itkovian> gee, I'm going to steal this dude sim-mp3's
07:55:17 <Itkovian> heh
07:55:43 <Philippa_> p21870: evercrack has a larger economy than several countries
07:55:44 <Itkovian> hey, that sim-teenager had sex with my sim-daughter ... I'll sue you
07:56:02 <p21870> Philippa_, that's no reason to take it more seriously
07:56:50 <Philippa_> no? Sooner or later, money translates to people's ability to live. You did see how much that sword went for, right?
07:57:17 <Philippa_> if my game character suddenly lost an item with a hefty real-world value you bet I'd be pissed off
07:57:24 <Philippa_> there're people make their living that way
07:57:39 <shapr> A shell account is a virtual item.
07:57:56 <Philippa_> as is a database, a program...
07:58:01 <shapr> Source code too.
07:58:32 <shapr> Microsoft wasn't happy when some crackers in Russia got a partial copy of the Windows source code (NT4 I think?)
07:58:46 <p21870> Philippa_, in that case you are right, stab the f#cker
07:58:51 * Philippa_ does wonder if there'll be a serious clash between such laws and an MMORPG that allows stealing from other PCs as a legitimate part of gameplay
07:59:02 <shapr> Interesting point.
07:59:02 <jlouis> Currency is imagined inside our heads anyway. That is the basics of it
07:59:03 <koollman> shapr: win2000 too
07:59:23 <Philippa_> jlouis: right. Symbolic goodwill, as it were
07:59:33 <shapr> Right, it's all about trust.
08:00:27 <jlouis> So when value is put into some sword in some game and it is tied to known economies, yadda, yadda. Then the economy in the game becomes real
08:00:54 <jlouis> The only problem is money flow. When you actually get deposits on your visa for picking up a sword.
08:03:32 <p21870> i'd just say...stay out of that whole stuff
08:06:08 <Philippa_> personally yeah, I agree
08:15:22 <shapr> Man, lambdabot needs to run on musasabi's distributed Haskell...
08:15:29 * shapr grins evilly
08:15:40 <shapr> Then when one host goes down, it'll still be around.
08:15:50 <vincenz> Hey shapr, you're back
08:16:51 <shapr> Yes, but I don't plan on spending lots of time on #haskell in the future. I hope to keep my irc time so I can focus on coding.
08:16:59 * vincenz nods
08:21:17 * Lemmih is back.
08:25:46 <boegel> yo Lemmih
08:35:05 * boegel just created a first working version of HOpenGL and cheers
08:35:13 <boegel> s/HOpenGL/HaskLS
08:37:38 * SamB wishes emacs wouldn't save backups with the execute bit set on account of it confusing tab completion...
08:38:26 <SamB> or alternatively, that shells wouldn't complete command names ending in ~...
08:42:35 <Enveigler1> Any references to the pros & cons re: Haskell  -v- Ocaml?
08:43:25 <Enveigler1> Grr!
08:44:47 <SamB> Haskell is purely functional and lazy whereas ocaml is strict. Which of these is a pro and which is a con is the subject of some debate, and probably depends on what you are doing anyway.
08:45:06 <neologism> ocaml is not purely functional?
08:45:13 <SamB> Haskell has a nicer syntax
08:45:23 <SamB> neologism: not really.
08:45:26 <dblhelix> a much nicer syntax, imho :)
08:45:35 <neologism> SamB: due to io?
08:46:07 <SamB> neologism: pretty much
08:46:51 <SamB> Haskell has a simpler module system, or so I've heard... which again is up for debate as to which is better...
08:47:13 <SamB> also, Haskell has typeclasses
08:48:20 <SamB> which are just about essential for using monads without getting quite tied to whatever monad you end up using, as far as I can tell...
08:48:52 <SamB> or maybe I should say "whatever monad you start with"
08:51:00 <Enveigler1> Strange. At a cursory glance, Ocaml syntax seems a whole lot more familiar (and therefore more freindly) to my eyes. Maybe that'll where off with use.
08:51:32 <SamB> Enveigler1: huh. that is odd. is ocaml syntax less like SML syntax than I thought?
08:51:55 <boegel> dcoutts: is Gtk2Hs 0.9.8 working already with HOpenGL ?
08:53:09 <boegel> yo Oejet
08:53:28 <SamB> hmm, the unlambda interpreter written in caml doesn't look too odd in sml-mode
08:53:33 <Enveigler1> SML as in S... Markup Language?
08:53:44 <Igloo> Standard ML
08:54:04 <Enveigler1> Ah! I haven't looked at ML (yet).
08:55:03 <Enveigler1> I was just wondering if running through the Ocaml tutorials first might give me an easier transition?
08:55:40 <SamB> to Haskell?
08:55:59 <shelarcy> http://www.ps.uni-sb.de/~rossberg/SMLvsOcaml.html
08:56:35 <SamB> well, maybe. they have HM-based typing in common, after all ;-)
08:57:36 <Enveigler1> Yep. The imperative parts seem very familiar and avoid the mental leap of the IO monad. Once I get used to the idea of functions as first-class entities, maybe Haskell wouldn;t be such a leap?
08:58:56 <dcoutts_> boegel, no not yet I've been dealing with issues to do with the 0.9.8 release, not further development work yet!
08:59:10 <SamB> speaking of caml, is there anything special about the type (funktion->unit)? funktion is just an ordinary algebraic datatype...
08:59:10 <boegel> okay
08:59:30 <boegel> just because I have a simple version of HaskLS, and this might be a good point to build a small GUI around it
08:59:40 <dcoutts_> I see
09:00:38 <dcoutts_> fear not boegel, you'll be the first person I tell when I get OpenGL support in Gtk2Hs! :-)
09:00:57 <Enveigler1> It seems Ocaml is very SML-like...so maybe I'd find SML syntax preferable. Thanks for the link shelarcy
09:01:03 <mikael> SamB: I don't think there's anything special about it, except that returning () usually denotes that the function is impure
09:01:18 <boegel> dcoutts_: cool :)
09:02:03 <SamB> mikael: it is supposed to represent a continuation...
09:02:31 <SamB> I guess I'm not going to learn anything I can use from there...
09:03:12 <Lunar^> Igloo: there?
09:03:23 <Igloo> yup
09:04:45 <Lunar^> Igloo: Are you aware of any problem with ghc6/unstable on powerpc?
09:05:10 <Igloo> no
09:05:11 <Lunar^> Igloo: I can't get any correct Yi or riot binary
09:05:28 <Lunar^> Igloo: If I use -fvia-C, curses fails (as documented in Yi's makefile)
09:05:37 <boegel> does anyone know how I can upload images to place on a hawiki page ?
09:05:53 <Lunar^> Igloo: And if I use -fasm, I get a segfault in __stginit_Main...
09:05:57 <Igloo> Did it ever work?
09:06:27 <Igloo> This is gcc 3.3.something, right?
09:06:33 <Lunar^> Igloo: I remember building Yi with GHC 6.2, but I might be wrong
09:06:41 <Lunar^> Igloo: gcc version 3.3.5 (Debian 1:3.3.5-12)
09:07:25 <Oejet> yo, boegel.
09:12:27 <Lunar^> Igloo: as far as I can understand from gdb, objdump and the hc file, it seems like Sp gets mangled at some point
09:12:45 <Lemmih> boegel: Got the code online?
09:12:57 <boegel> Lemmih: not yet
09:13:09 <boegel> it needs some tuning, but it works
09:13:26 <Igloo> Lunar^: The stack pointer probably won't be being used as a stack pointer
09:13:28 <boegel> setting the right rotation is now hardcoded, as is the visibility settings
09:13:38 <boegel> Lemmih: let me throw it online for you
09:13:43 <Lunar^> Igloo: I was talking about "Sp"
09:14:16 <Lunar^> Igloo: is it representing only STG stack pointer?
09:15:28 <Igloo> gdb can also be confusing if things are compiled with optimisation, don't forget
09:16:14 <Lunar^> Igloo: I've rebuild everything with -Onot
09:16:25 <Igloo> Including the RTS?
09:16:31 <Lunar^> errrr no :)
09:16:41 <Lunar^> Mhh... -debug RTS is built with -O ?
09:16:51 <Igloo> Not sure OTTOMH
09:17:35 <Lunar^> Igloo: could you pull the patch from upstream GHC that fixes -fvia-C ?
09:17:38 <Igloo> You're probably best starting by making a minimal test case, though
09:17:56 <Igloo> Not right now
09:18:27 <Igloo> Hmm, do you know exactly what that fixes?
09:18:40 <boegel> Lemmih: http://studwww.ugent.be/~kehoste/HaskLS/
09:18:56 <Lunar^> Igloo: In fact, I was trying to package riot...
09:19:01 <Lemmih> boegel: Thanks.
09:19:07 <Lunar^> Igloo: Let's take a look
09:19:11 <Igloo> No, what the -fvia-C patch fixes
09:19:24 <boegel> Lemmih: lemme know what you think :) the code can improve a lot, but atleast it works :p
09:19:30 <Igloo> I'm wondering if I need to sort that out before uploading nhc98
09:19:46 <boegel> Lemmih: there are also some screenshots in that directory
09:21:25 <Lunar^> "HEAD of ghc, (at least as early as) May 17 2005 or later seems to fix this."
09:22:01 * Lunar^ looks at cvs-ghc archives
09:30:22 <Lunar^> shapr: Is Curryspondence still running?
09:30:36 <shapr> I don't think so...
09:30:38 * shapr checks
09:31:40 <shapr> Actually, it is running, but my ISP has screwed up their routing tables so no one can access it.
09:31:51 <Lunar^> shapr: :(
09:32:15 <shapr> At the moment, it's not efficient enough to run on www.ScannedInAvian.org, which is a paltry 600MHz
09:32:30 <Lunar^> shapr: Do you have a local version?
09:32:48 <Lunar^> forget it
09:33:25 <shapr> Any specific question? I have a brain =)
09:33:48 <Lunar^> shapr: when did the -fvia-C with curses bug got fixed ? :D
09:34:05 <wilx> omg!
09:34:19 <shapr> Um, I don't know!
09:34:29 <wilx> I just read that "stabbed because of stolen in-game sword"
09:34:44 <dcoutts_> boegel, you've got your announcement on the Gtk2Hs front page. Hope you're happy with it! :-)
09:34:47 <SamB> oh wow! shapr has a brain! I never would have guessed!
09:34:47 <wilx> I hope they will never ever try to control games by law.
09:34:49 <wilx> Geez.
09:34:49 <shapr> Lunar^: maybe it was fixed in 6.2.1?
09:35:14 <Lunar^> shapr: it was fixed between GHC 6.4 release and May 17 2005
09:35:20 <Lunar^> shapr: to trust Yi makefile
09:35:22 <shapr> Oh, then I don't know.
09:35:55 <Oejet> wilx: Well, if enough people gets hurt in real life because of them, I would control it.
09:36:14 <wilx> Huh.
09:36:21 <Lunar^> shapr: How's FLM going?
09:36:34 <shapr> Ever closer to release...
09:36:45 <wilx> I'd rather we don't start going that way.
09:36:46 <shapr> Right now I just need to whip up some simple macro support
09:37:10 <shapr> I think I'm going to give a releas date and just release whatever I have on that date.
09:37:16 <dcoutts_> Igloo, what Debain Haskell person / alias should I send Gtk2Hs packaging info to? I'm sending (hopefully) helpful info to all the other packaging folk...
09:37:18 <shapr> That should motivate me to spend more time on FLM :-)
09:37:32 <wilx> Next day somebody is going to sue me because of obscene language on IRC?
09:43:42 * boegel checks out the announcment
09:44:15 <dcoutts_> Is boegel satisfied?
09:44:40 * boegel is
09:44:44 <dcoutts_> :-)
09:48:52 <Itkovian> nice ...
09:51:57 <shapr> hiya spart
09:57:19 * shapr boings furiously
09:57:46 * Itkovian ducks
09:58:07 * shapr bounces off the ceiling
09:59:54 * Itkovian dives
10:00:28 <boegel> does anyone know who "alain rouge" is in real life ?
10:01:36 <boegel> I mean what his nick is
10:01:41 * boegel hits himself in the head
10:02:21 <Igloo> dcoutts_: arjanoosting was the person talking aobut it, I think, but you may as well mail debian-haskell@lists.urchin.earth.li
10:02:34 <SyntaxNinja> hiya
10:02:55 <boegel> heya
10:04:04 <dcoutts_> Igloo, thanks I'll email that address
10:04:17 * SamB thinks it is pathetic that you need to upgrade just about all of gcc just to upgrade cpp...
10:11:27 <SyntaxNinja> SamB: cpphs!
10:11:46 <SyntaxNinja> @seen jafacake
10:11:55 <SyntaxNinja> @seen jaffacake
10:12:05 <SyntaxNinja> @yow
10:12:18 <dcoutts_> oh no! lambdabot!
10:12:18 <Lemmih> No lambdabot.
10:12:45 <Igloo> [17:04] -!- JaffaCake [~simonmar@tide97.microsoft.com] has left #haskell ()
10:13:01 <dcoutts_> ah it's Igloobot!
10:13:06 <Lemmih> Igloo: @yow
10:13:15 <Itkovian> fully automated even
10:13:21 <Itkovian> Igloo: @moo
10:14:39 <Lemmih> 17:04 doesn't really mean much without knowing what timezone you're in.
10:15:14 <dcoutts_> Lemmih, if it's in Igloo's timezone it means just over an hour ago
10:17:09 <SyntaxNinja> eh, I was wondering when he last spoke
10:17:53 * SamB again reflects that he must not be a normal user on account of his having binutils-multiarch installed
10:27:13 <boegel> dcoutts_: pls change the link for HRay, it has moved (check the old page for the link)
10:27:25 <dcoutts_> ok...
10:29:16 <dcoutts_> boegel, I don't understand. The link works for me and I don't see what you mean by the 'old' link
10:29:24 <dcoutts_> what should it be?
10:29:52 <boegel> dcoutts: the studwww link now points to a page that says the real page has moved
10:30:43 <reffie> http://ter.air0day.com/?script=revengeofthesith
10:31:23 <dcoutts_> boegel, so I've got http://studwww.ugent.be/~kehoste/thesisPublic/website/ (which works fine) what should it be?
10:32:41 <basti_> hey!
10:33:36 <boegel> dcoutts_: you can't see the "this page has moved"-page when you visit that adress ?
10:33:54 <boegel> dcoutts_: new link -> http://scannedinavian.org/~boegel/HRay/
10:35:11 <dcoutts_> boegel, no "this page has moved" message for me. Let me try bypassing the caches...
10:35:47 <dcoutts_> ok now I get it!
10:35:52 <dcoutts_> I'll update the links...
10:36:59 <dcoutts_> boegel, I'm afraid your HRay announcement is going to get pushed off the top spot in a couple days by the 0.9.8 release announcement :-)
10:38:12 <dcoutts_> boegel, you need to update the link on your page :-) http://studwww.ugent.be/~kehoste/
10:40:06 <boegel> dcoutts: thanks :)
10:40:23 <dcoutts_> ok, the links are updated now
10:41:00 <dcoutts_> (except for the one to your homepage which doesn't seem to have moved)
10:43:54 <boegel> my home page hasn't moved for now, but it will :)
10:44:04 <boegel> have to go and eat ice cream now, bye ! :)
10:48:00 <mikael> hm, does the debian ghc package come with the quickcheck batch driver?
10:48:36 <Igloo> What/where is that?
10:50:06 <mikael> the hughes paper talks about it.  I think it just greps for prop_.* and tests every match
10:50:11 <mikael> oh, I don't think it comes with quickcheck in general.  here it is: http://www.cs.chalmers.se/~rjmh/QuickCheck/quickcheck
10:53:39 <wagle> 10:50 < kees> http://zeeb.at/oops/DamnGoodTrailerHitch.jpg
10:55:10 <shapr> mikael: hey, did you see my test-driven-development version of QC?
10:55:25 <mikael> shapr: ooh, no!
10:56:24 <shapr> It saves the (seed,size) tuple for failing values, and retests with them on the next run.
10:56:50 <shapr> http://www.scannedinavian.org/~shae/qc-tdd.tgz
10:58:15 <mikael> oh!  saves to disk, you mean?
10:59:27 <shapr> Yup, it requires the batch driver because I couldn't figure out a better way to associate a failing value with a prop_
11:00:04 <mikael> I'm using quickcheck to test my math homework :-)
11:00:14 <shapr> It's currently completely naive in that it dumps all the failing tests into the next run, they're not preserved further if they succeed.
11:00:14 <shapr> cool!
11:00:47 <Heffalump> shapr: cool.
11:01:03 <shapr> Heffalump: Your suggestion, of course :-)
11:05:01 <basti_> shapr: oh hi! Is FLM alive?
11:07:33 <shapr> Not yet
11:07:33 <Itkovian> boegel that is an excellent idea!
11:07:34 <CosmicRay> shapr: btw, I believe my Wash GHC6.4/Cabalization tree is working now.
11:08:07 <shapr> CosmicRay: cool!
11:08:30 <CosmicRay> shapr: if you (or anyone else) does any Wash stuff, I'd appreciate an independent sanity check
11:08:50 <shapr> Haven't done any recently, but I'll likely brush up on Curryspondence soon.
11:09:01 <CosmicRay> this, combined with sarge releasing, allowed me to upgrade some production code to ghc 6.4 (woohoo)
11:09:27 <CosmicRay> SEE YOU IN HELL, CPP! :-)
11:10:03 <Igloo> How does sarge releasing allow you to upgrade code to ghc 6.4?
11:10:29 <CosmicRay> Igloo: because it has all the other libraries that I require as well
11:10:40 <CosmicRay> Igloo: I can run the sid 6.4 packages on an otherwise pure sarge machine
11:10:51 <Igloo> Ah, right
11:11:06 <CosmicRay> and I can run the resulting bins on a pure sarge machine.
11:11:51 <_segv__> Hi
11:13:27 <CosmicRay> hello
11:13:41 <Muad_Dibber> Ho
11:14:06 <basti_> oh.
11:14:15 <Rearden> oy
11:14:44 <basti_> rearden is a dancer?
11:15:51 * CosmicRay emails the link to the GHC 6.4 Wash repo to Dr. Thiemann
11:16:18 * CosmicRay really wants to see an upstream 6.4-compatible wash release :-)
11:16:43 <_segv__> i have a question about porting ghc, can someone answer it?
11:16:52 <CosmicRay> _segv__: we can try
11:16:53 <Lemmih> Not before you pose it.
11:17:26 <CosmicRay> Lemmih: you're no fun
11:17:42 <CosmicRay> Lemmih: I'll just make my Frequently Questioned Answers list all by myself then.
11:17:43 <_segv__> i compiled ghc-6.2.2 under linux, created the tar file and extracted in an new ghc-6.2.2 dir, ...
11:18:39 <_segv__> after starting distrib/hc-build it stops with:  Control/Arrow.o,
11:18:39 <_segv__>   bentigt von libHSbase.a, zu erstellen.
11:18:52 <Rearden> NO CARRIER
11:19:00 <CosmicRay> you extracted it in a new dir on that same machine?
11:19:06 <_segv__> yes
11:19:15 <_segv__> just to try it out first
11:19:15 <CosmicRay> why were you doing that?
11:19:38 <CosmicRay> it seems like you may have missed a step in the porting guide, but I don't know for sure which
11:19:38 <Igloo> What are you trying to port from/to, and are you following the porting instructions in the building guide?
11:19:45 <CosmicRay> have you read the porting guide?
11:19:55 <_segv__> Yes, twice
11:20:05 <Igloo> What does that error mean?
11:20:20 <_segv__> control/Arrow.o is missing
11:20:35 <_segv__> my guess is, that the tar file is not complete
11:20:45 <Igloo> It says more than that
11:21:09 <_segv__> give me a second, i will change the locale and give you an english message
11:21:23 <Lemmih> Can you find Arrow.(l)hs in the tarball?
11:21:26 <CosmicRay> _segv__: if I remember the instructions correctly, you are supposed to unpack the tarfile of the .hc files over an unpacked source tree
11:21:35 <Igloo> The porting instructions on the website are now for 6.4, incidentally, so may not quite work with 6.2.2
11:22:01 <Igloo> Lemmih: He'll probably want a .hc, not .(l)hs
11:22:07 <_segv__> Lemmih, no
11:22:25 <Lemmih> Igloo: Oh, right.
11:22:32 <_segv__> igloo, the instruction are for 6.2.2
11:23:17 <CosmicRay> ibid: thanks for the changelog spam on planet.d.o :-)
11:23:30 <Igloo> What are you trying to port from/to?
11:23:40 * Igloo is going to have to disappear in a minute
11:23:56 <_segv__> CosmisRay, you remember correctly, so I did this
11:24:15 <Igloo> But just following the instructions accurately ought to work to platforms that aren't too odd
11:24:19 <_segv__> Igloo, actually from linux to Solaris X86
11:24:37 <_segv__> igloo, thats why I'm here :'
11:24:43 <CosmicRay> _segv__: is there not already a ghc build for solaris x86?
11:25:03 <_segv__> i did not find any
11:25:14 <_segv__> here is the error message in english
11:25:17 <_segv__> No rule to make target `Control/Arrow.o', needed by `libHSbase.a'.
11:25:35 <Igloo> Do you have a Control/Arrow.hc ?
11:25:43 <CosmicRay> can solaris x86 run linux binaries?
11:26:02 <_segv__> Igloo, no i don't
11:26:12 <_segv__> Wait, in what dir?
11:26:17 <Igloo> Is there one in the ghc tree you made the tarball from?
11:26:30 <Igloo> Err, ghc-6.2.2/libraries/base probably
11:26:37 <CosmicRay> autrijus: whoa, you use AIX too, eh?  thanks for making a GHC 6.4 build!
11:26:38 <Igloo> find . -name Arrow.hc
11:26:52 * Igloo disappears
11:27:06 <michaelw> <wagle> 10:50 < kees> http://zeeb.at/oops/DamnGoodTrailerHitch.jpg
11:27:13 <shapr> michaelw: oh yeah?
11:27:18 <michaelw> erh, sorry
11:27:18 <_segv__> Igloo, sorry i meant in the already builded dir or in the port dir!
11:27:22 <shapr> michaelw: hey, you pinged me earlier?
11:27:37 <_segv__> No there is no Arrow.hc in the builded dir
11:27:56 <CosmicRay> _segv__: is there a particular reason you are using 6.2 instead of 6.4?
11:28:04 <michaelw> shapr: yes, i thought you were the one who patched my hmpi binding to make it work with more recent GHCs
11:28:14 <shapr> That would be Hal Daume III
11:28:17 <michaelw> shapr: but it's hal daume
11:28:26 <_segv__> CosmicRay, i first tryed 6.4 but faild with the same error
11:28:35 <shapr> michaelw: http://www.isi.edu/~hdaume/
11:29:10 <michaelw> shapr: nothing there, i already checked. i emailed him
11:29:56 <CosmicRay> is someone looking for YAHT?
11:30:48 <_segv__> i googled the log files of this channel, an found some option problems, could this be the problem?
11:35:31 <shapr> michaelw: I probably have a local copy if you just want the download.
11:37:13 <musasabi> You can get the direct link from google.
11:37:53 <michaelw> shapr: yes please
11:38:05 <michaelw> musasabi: which search string?
11:41:25 <_segv__> I am new to IRC. What happend to Igloo?
11:41:54 <CosmicRay> he left his computer
11:42:17 <_segv__> CosmicRay: thanks!
11:43:00 <ibid> CosmicRay: hmm. should i put the changes file behind a read more link?
11:43:30 <CosmicRay> ibid: it might be polite
11:43:47 <CosmicRay> ibid: it's not a big deal or anything
11:44:15 <ibid> done
11:44:24 <ibid> of course, planet will take a while to notice it :)
11:46:53 <CosmicRay> heh
11:47:03 <CosmicRay> it will have scrolled off the front page before it does, probably :-)
11:47:30 <CosmicRay> shapr: you wouldn't happen to be a HP calculator fan, would you?
11:48:40 <musasabi> michaelw: "Yet another haskell tutorial"
11:49:07 <michaelw> musasabi: ah, sorry, cross-talk then
11:49:30 <goron> Does anyone run FreeBSD and use HOpenGL?
11:49:53 <goron> Somehow the Graphics.Glut.etc module can't be found.
11:50:23 <Lemmih> Try: Graphics.UI.GLUT.
11:50:24 <goron> Before I compiled it from ports I had libglut and libfreeglut installed.
11:50:41 <goron> Lemmih: I wasn't being exact.
11:52:45 <lispy> goron: boegel has been using it on fedora....
11:53:34 <goron> lispy: If I compile it from cvs, it will probably work.
11:53:46 <lispy> goron: oh, right which version do you have?
11:53:48 <Lemmih> You really don't want that.
11:54:01 <goron> lispy: Of what?
11:54:07 <lispy> goron: HOpenGL
11:54:37 <goron> lispy: It should be included in ghc.
11:54:54 <lispy> goron: if i were you, i'd check yesterdays logs for info about HOpenGL.  search for boegel especially
11:55:05 <lispy> he spent most of yesterday getting it working
11:55:31 <Lemmih> He spent most of yesterday getting GHC 6.4 installed.
11:55:35 <lispy> that's probably not accurate in terms of time..but yeah
11:55:44 <lispy> Lemmih: ah
11:55:49 <goron> lispy: Thanks, but getting it to run under Linux I already did.
11:55:53 <lispy> i should have said he spent some time yestarday
11:56:00 <lispy> goron: aight
11:56:03 <goron> I installed ghc a couple of times from cvs.
11:56:06 <lispy> goron: just trying to be helpful ;)
11:56:12 <goron> Building it on Debian is pretty easy.
11:56:22 <_metaperl> CosmicRay: ping?
11:56:24 <goron> Building it on archlinux is a pain, I can tell you that.
11:56:27 <goron> lispy: sure
11:56:30 <shapr> michaelw: http://www.scannedinavian.org/~shae/newhmpi.tar.gz
11:56:34 <shapr> CosmicRay: how so?
11:56:51 <shapr> astrolabe: hiya!
11:56:52 <lispy> well, i'm off to school
11:57:07 <michaelw> shapr: thx
11:57:11 <shapr> CosmicRay: I'm recently a fan of postfix calculation, if that helps.
11:57:14 <CosmicRay> sorry, was afk for a sec
11:57:15 <astrolabe> hiya shapr.  How's things?
11:57:36 <shapr> Especially in the case of Joy, and the secret fork of Joy I'm working on, fittingly named Secret Joy.
11:57:38 <CosmicRay> shapr: I just dug out my HP48GX today.  It powered on and still had all my programs after 6 years in storage.
11:57:40 <Lemmih> goron: GHC's configure script should tell you why it omitted GLUT.
11:57:53 <shapr> CosmicRay: You realize this means you drive off your namesakes?
11:57:56 <goron> I have USE_GL=yes
11:58:03 <goron> in the MakeFile of ports.
11:58:09 <CosmicRay> shapr: heh
11:58:13 <goron> Lemmih: I will track ghc's log now.
11:58:16 <goron> Lemmih: thx
11:58:40 <shapr> Too bad sleepingsquirrel isn't around here.
11:59:12 <CosmicRay> shapr: yah, rpn is nice.
11:59:29 <CosmicRay> shapr: back in the days when I had free time, I was dreaming up an rpn module for camlp4 :-)
11:59:58 <shapr> Have you tried Joy?
12:00:02 <Heffalump> can Cabal use a chain of preprocessors?
12:00:10 <CosmicRay> shapr: url?
12:00:11 <michaelw> shapr: have you tried Factor? :)
12:00:45 <shapr> michaelw: yes, but it's not really concatenative
12:01:08 <michaelw> shapr: how so?
12:01:09 * lispy is gone but if he were still here he'd claim pre-fix notation is even cooler than post-fix.
12:01:17 <shapr> michaelw: And I *require* fully concatenative for the crazy hack I have in mind.
12:01:40 <shapr> If it works out the way I think it will, Secret Joy will knock the socks off Scheme and Lisp.
12:02:12 <shapr> One of the 'concatenative' properties is that you can cut a program on any lexical boundary and end up with two legal programs.
12:02:20 <shapr> Factor does not hold to that.
12:02:36 <_segv__> CosmicRay: btw, I think i figured it. -fvia-C -keep-hc-file
12:02:45 <_segv__> where missing in the makefile
12:02:52 <CosmicRay> _segv__: interesting
12:02:58 <_segv__> I now have an Arrow.hc
12:03:26 <shapr> michaelw: Seen the 'quadratic formula' thread on the yahoogroups concatenative list?
12:03:40 <_segv__> Thanks for help
12:04:05 <michaelw> shapr: hmm, not that i remember. url?
12:04:14 <shapr> umm, lemme dig it up...
12:09:34 <basti_> hmm
12:09:49 * basti_ needs the hs-plugin, but dons' page is not responding
12:10:54 <basti_> st00pid. can't compile yi without. wonder why its broken though
12:11:00 <shapr> Is there a darcs put?
12:11:15 <shapr> I realize I'd like to do the push version of darcs get...
12:11:17 <CosmicRay> that would essentially do a darcs initialize and then a darcs push?
12:11:20 <shapr> righto
12:11:39 <shapr> My desktop is inaccesible from the internet at large, but I have repos (hs-plugins) I'd like to push.
12:11:39 <CosmicRay> nope :-)
12:11:43 <shapr> fooey
12:12:58 <shapr> boegel: http://www.scannedinavian.org/~shae/hs-plugz.tgz
12:13:04 <shapr> That's from two or three days ago.
12:13:09 <goron> Lemmih: Found it: configure: WARNING: no GLUT header found, so this package will not be built
12:13:14 <basti_> thanks shapr.
12:13:48 <goron> Lemmih: Now, the question is: how to I get it to find the GLUT headers.
12:13:54 <goron> er do
12:14:34 <shapr> michaelw: The actual post is somewhere in this massive thread - http://article.gmane.org/gmane.comp.lang.concatenative/972
12:14:34 <Muad_Dibler> hey goron
12:14:44 <shapr> michaelw: but that post refers to the information at least.
12:15:01 <goron> Muad_Dibler: hoi
12:15:16 <Muad_Dibler> how were your practical results for pt?
12:15:19 <shapr> michaelw: Slava posts a Factor solution, Manfred says roughly 'not concatenative'.
12:15:19 <Lemmih> goron: Install the GLUT development package.
12:15:22 <goron> Muad_Dibler: Very good.
12:15:41 <goron> Muad_Dibler: But I am not sure about the result of the big assignment.
12:15:43 <Muad_Dibler> you the one with 9.5 then? :)
12:16:36 <goron> Muad_Dibler: no, 9
12:16:51 <Muad_Dibler> :D
12:16:53 <basti_> Rebuilding dependencies ... Could not find module `Language.Haskell.Hsx':
12:16:54 <goron> Muad_Dibler: you?
12:17:01 <Muad_Dibler> same
12:17:14 <Lemmih> basti_: Install haskell-src-exts
12:17:17 <goron> Muad_Dibler: good
12:17:21 <basti_> ok
12:19:00 <goron> Lemmih: On fbsd there's no separate devel glut. I have the headers.
12:19:53 <basti_> i do have the debian package  libghc6-haskell-src-dev
12:19:58 <goron> Lemmih: I have /usr/X11R6/include/GL/glut.h for example.
12:19:58 <basti_> -.-
12:20:35 <Lemmih> goron: You probably want GHC to look in /usr/X11R6/include/GL then.
12:21:06 <goron> Lemmih: Ok, in other words I need to hack the MakeFile...
12:21:14 <goron> This is becoming a habit.
12:22:04 <basti_> building myself now
12:22:09 <shapr> make self
12:22:15 <basti_> by myself
12:22:22 <shapr> make myself?
12:22:28 <basti_> make shapr mute
12:22:31 * shapr laughs
12:22:42 <shapr> Right, this calls for unicycling!
12:22:58 <CosmicRay> heh
12:25:09 <basti_> error reading ./.setup-config; run "setup configure" command?
12:25:10 <basti_> ??
12:25:26 <basti_> ahh
12:25:28 <basti_> readme etc.
12:33:00 <ibid> CosmicRay: planet noticed
12:33:16 <CosmicRay> ibid: nice.  I didn't know that it would
12:34:39 <ibid> CosmicRay: it does, as soon as it next looks at the feed, which is iirc within teh hour
12:44:08 <genneth> evening shapr
12:44:16 <genneth> kept missing you on here
12:44:20 <genneth> wassup?
12:55:44 <boegel> Lemmih: that was rude
12:59:36 <Itkovian> well boegel, gf gone?
12:59:47 <boegel> Itkovian: yeah :)
12:59:49 <boegel> why ? :)
13:00:10 <Itkovian> well ... there's more pleasant stuff to do otherwise than hinging out here
13:00:20 <Itkovian> btw, the icecream was great, good idea!
13:00:21 <boegel> yeah
13:00:26 <boegel> it was
13:00:37 <boegel> passion fruit ice cream, mmm
13:01:10 <Itkovian> heh
13:01:23 <Lemmih> boegel: What was rude?
13:01:27 <boegel> lispy he spent most of yesterday getting it working
13:01:27 <boegel> Lemmih He spent most of yesterday getting GHC 6.4 installed.
13:01:39 <Itkovian> I was just looking for something to eat, but the cupboards are empty as Veerle has decided she wanted to get her weight pre-pregnancy again :-)
13:02:01 <shapr> genneth: hiya!
13:02:04 <boegel> Itkovian: heh
13:02:14 <boegel> shapr: what is the link you showed me ?
13:02:45 <shapr> Which link?
13:02:54 <boegel> the hs-pluginz.tgz
13:02:58 <shapr> genneth: So, how's your love of Haskell coming along?
13:03:07 <shapr> boegel: http://www.scannedinavian.org/~shae/hs-plugz.tgz
13:03:07 <Lemmih> boegel: Oh sorry. Just wanted to indicate that you were installing GHC and not HOpenGL as a single package.
13:03:17 <boegel> shapr: yeah, but why did you show me ?
13:03:32 <boegel> Lemmih: it didn't take all day for me to install GHC 6.4
13:03:32 <shapr> michaelw: because you wanted to download the most recent hs-plugins, right?
13:03:48 <shapr> er, boegel
13:03:50 <shapr> doh
13:03:57 <boegel> I was having some trouble with it, yeah, but saying it took all day is like insulting me
13:04:12 <shapr> michaelw: Did you find the information about Factor?
13:04:15 <boegel> shapr: ? it wasn't meant for me ?
13:04:38 <shapr> boegel: yes, hs-plugz is the hs-plugins repo from three days ago, I thought you were trying to download a very recent hs-plugins.
13:04:56 <boegel> shapr: no, I wasn't :)
13:04:59 <shapr> oh, sorry
13:05:04 <boegel> no biggy :)
13:05:25 <boegel> thought it was something nifty :p what is hs-plugins ? some extra tools or something ?
13:06:55 <Itkovian> afaik hs-plugins is for dynamically loading haskell stuff
13:09:18 * Itkovian urgently needs to get back to Haskell fiddling
13:11:19 * p67634 saw Itkovian saying that more than once
13:12:12 <Itkovian> yeah
13:12:19 <Itkovian> I added urgently this time though
13:12:29 <p67634> true
13:13:54 * boegel points Itkovian to all the work he has to do
13:16:30 <Itkovian> sssshht
13:35:31 <CosmicRay> Itkovian: hiya, I see you're still here.  would you like some additional work-distracting conversation?
13:35:58 <CosmicRay> here is an excellently distracting link http://bofh.ntk.net/Bastard.html
13:56:02 <Itkovian> I've read those
13:59:55 <boegel> they're quite cool :)
14:00:44 <Itkovian> night all
15:01:32 <wilxSqueak> ...
15:06:16 * boegel created a simple logo for HaskLS, and would like some feedback: http://scannedinavian.org/~boegel/HaskLS/logoSrc.png
15:07:26 <Lemmih> Nice (:
15:07:41 <Lunar^> clean :)
15:07:41 <wilx> What is L-systems?
15:07:50 <Lunar^> You're missing the obligatory lambda, but... :)
15:13:07 <SyntaxNinja> if you cross your eyes, you can see a lambda
15:13:12 <SyntaxNinja> 'course that's usually true..
15:13:47 <Lunar^> hehe
15:19:48 <boegel> Lunar^: hmm, let's see if I can find a lambda in there...
15:19:58 <boegel> wilx: check the wiki, several links there
15:20:02 <boegel> @wiki HaskLS
15:20:09 <boegel> oh
15:20:13 <boegel> lambdabot is gone :s
15:20:22 <boegel> http://haskell.org/hawiki/HaskLS
15:20:25 <boegel> wilx: ^
15:22:21 <wilx> Hmm, interesting :)
15:23:31 <lispy> boegel: have you bumped into the people taht tried out the code from the wiki?
15:23:48 <lispy> boegel: i think "output" and a few other things were missing from the code
15:25:39 <boegel> lispy: there's nothing missing, it's a wiki bug that is manifested somehow...
15:25:46 <boegel> I've added a comment on how to solve it
15:26:00 <boegel> but I'll throw the code into a darcs repo like in 5 min's
15:26:10 <boegel> I'm setting up a page similar to the HRay one
15:26:26 <boegel> new logo: http://scannedinavian.org/~boegel/HaskLS/logoSrc.png
15:27:46 <Lemmih> Yay. Lambda.
15:28:43 <boegel> :)
15:30:14 <Lemmih> Heh. 20% of your visiters are from Denmark.
15:31:52 <boegel> hey, you shouldn't be peeking at that, I'm still setting it up :p
15:36:29 <boegel> Lemmih: care to give the darcs repo a try ?
15:36:34 <boegel> it should be working
15:37:16 <boegel> o wait :)
15:37:23 * Lemmih waits.
15:38:14 <boegel> now it should be working fine :)
15:40:22 <Lemmih> Is it shrinking or rotating?
15:40:30 <boegel> rotating
15:40:45 <boegel> but it's hardcoded
15:41:04 <Lemmih> And GLUT doesn't like GHCi /-:
15:41:14 <boegel> what's wrong ?
15:42:18 <boegel> Lemmih: the darcs repo is working, right ?
15:42:49 <Lemmih> GLUT thinks it's really smart to kill its own process when it is done.
15:42:58 <Lemmih> But that kills GHCi.
15:43:02 <boegel> heh
15:43:03 <Lemmih> Yes, the repo is working.
15:43:19 <boegel> Lemmih: just press 'q' or Escape, should be fine then ?
15:44:43 <Lemmih> GHCi still dies when the window closes.
15:45:10 * Lemmih will hack a version using SDL.
15:47:03 <Lemmih> Ehrm.
15:47:06 * Lemmih will hack a version using SDL when he get the time.
15:47:29 <boegel> hehe :)
15:47:50 <boegel> I've been wanting to try out SDL, but I'm not sure how it works
15:48:08 <boegel> Lemmih: also, there's no support yet for '[' and ']' (branches)
15:48:14 <Lemmih> It's hard to keep working on one thing when there's so much neat Haskell code out there.
15:48:46 <boegel> you think mine is neat?
15:49:01 <boegel> it's was quite easy really, and I think the code itself is kinda crappy :)
15:49:09 <Lemmih> dons: Greetings. Are you bringing lambdabot?
15:49:49 <SamB> how do you do while (1) {...} in haskell again?
15:51:07 <boegel> dons: yeah, we miss her
15:51:19 <SamB> that is, I want a mainloop...
15:51:26 <boegel> SamB: for starters, there's no while :p ;)
15:52:22 <boegel> SamB: loop ?
15:52:49 <boegel> loop (print "a") for example ? just guessing :p
15:53:04 <SamB> @index loop
15:53:09 <SyntaxNinja> boegel: loop = print "a" >> loop
15:53:34 <SyntaxNinja> no lambdabot :(
15:53:44 <SyntaxNinja> you mean... loop... ok
15:53:53 <SamB> what module?
15:54:06 <SyntaxNinja> check the haddock index.
15:54:34 <SamB> something like (\a -> foldl1 (>>) (repeat a))...
15:57:40 <SamB> actually, come to think of it, I don't want that anyway...
15:58:19 <wagle> eh?
15:58:20 <wagle> Prelude> forever (print "a") where forever x = x >> forever x
15:58:20 <wagle> <<IO action>>
15:58:44 <boegel> Lemmih: okay, website is complete, you may check it out :p
16:01:24 <wagle> howcome it doesnt run the IO action?
16:01:47 <SamB> wagle: maybe it is hugs?
16:01:57 <wagle> yeah, so?
16:03:28 <SamB> so maybe hugs doesn't do that?
16:03:51 <wagle> Prelude> print "a"
16:03:51 <wagle> "a"
16:03:51 <wagle> Prelude>
16:04:04 <wagle> odesnt do what?
16:04:05 <SamB> hmm, yes, I just tried that too...
16:04:08 <SamB> okay, no clue!
16:04:29 <wagle> my no clue is bigger than your no clue!
16:05:32 <wagle> ghci doesnt like the toplevel where, but does what its supposed to with" let"
16:05:44 <wagle> oddd
16:06:06 <SyntaxNinja> what'st he type of "forever"?
16:06:13 <SyntaxNinja> oh..
16:06:47 <Igloo> It's because ghci wants statements, and statements can't have where clauses attached
16:15:28 * boegel leaves for bed
16:15:33 <boegel> g'night everyone
16:43:48 <Lemmih> nibro: Ping.
18:35:31 <Heffalump> is http://www.haskell.org/ghc/docs/latest/html/Cabal/bugs.html still accurate in claiming that Cabal can't build packages for nhc98 ?
18:48:41 <Lemmih> Heffalump: Yes.
19:02:15 <SamB> is it just me, or does runghc use different buffering for stdout than basic linking?
19:03:47 <SamB> hmm, unlambda.c has to be one of the simplest C programs ever to translate into Haskell.
19:03:58 <SamB> it was practically MADE to use algebraic types...
19:05:37 <SamB> of course, it was NOT made to use tail recursion, exactly...
19:41:12 <SamB> hey, my Haskell translation of unlambda.c runs more than twice as fast as the original, and I didn't even do anything special...
19:42:50 <SamB> its also has just barely over 1/6 the lines of the original
19:43:27 <dons> so running unlambda on top of Haskell is likely to be  better than unlambda on top of C, right?
19:43:29 <SamB> although I haven't added the version 2 primitives yet
19:43:57 <SamB> dons: yeah, pretty much.
19:44:02 <dons> because you get super-efficient compiled forms for the lambda calc primitives
19:44:19 <dons> unlike in unlambda.c, which is a much simpler `rts'
19:44:23 <SamB> dons: but I did a straight translation!
19:44:36 <dons> @karma+ GHC
19:47:57 <SamB> I think optimizations of algebraic data types and those based on immutable heap that made it win.
19:48:12 <SamB> er, I forgot "it was more likely"...
19:48:24 <dons> so is it the world's fastest unlambda implementation?
19:48:42 <SamB> I dunno, I haven't tried the ocaml or sml/nj ones
19:48:54 <SamB> or that proprietary one
19:49:40 <SamB> but it I put forth no effort towards optimization, I was really wondering how much SLOWER mine might be.
19:49:55 <SamB> s/it //
20:01:42 <SamB> how do I tell if stdin has hit EOF?
20:02:22 <jewel> how are you reading from it?
20:02:39 <SamB> getChar, at the moment.
20:03:20 <SamB> if I had it in a list, I would know what to do, but it doesn't make sense to do that...
20:04:03 <SamB> oh, looks like isEOF should be usefull...
20:04:15 <SamB> I should have looked in System.IO to start with...
20:06:51 <dons> @ghc
20:06:52 <lambdabot>  Duplicate instance declarations
20:23:36 <SamB> hmm, it seems to have gotten slightly slower from my adding the V2 primitives, but it might just be from the larger binary...
20:23:58 <SamB> now its just a little less than twice as fast as the unlambda.c
20:24:53 <heatsink> what kinda memory mgmt does unlambda.c have?
20:27:14 <SamB> it uses boehm's GC
20:27:50 <SamB> there is another variant that uses reference counting, but I imagine it to be slower...
20:32:17 <SamB> hmm, I suppose I might get a little speed from the fact that I don't have a sentinal on my runloop, I just have the run function call exitWith ExitSuccess when it gets a TaskFinal...
20:38:20 <SamB> hmm, interesting that GHC claims that my main is lazy in the RealWorld...
20:39:42 <lispy> @ghc
20:39:43 <lambdabot>  Kinds don't match in type application
20:39:48 <lispy> @moo
20:39:49 <lambdabot>          (__)
20:39:49 <lambdabot>          (oo)
20:39:49 <lambdabot>   /-------\/
20:39:49 <lambdabot>  / |     ||
20:39:49 <lambdabot> *  ||----||
20:39:50 <lambdabot>    ~~    ~~
20:39:52 <lambdabot>      Cow
20:55:02 * SamB sends his code off to the unlambda guy
22:06:27 <SamB> whoa, I didn't know nhc98 supported time travel!
22:06:37 <lispy> sweet
22:06:39 <SamB> this will give us the ability to compete with Python in that area
22:06:42 <lispy> time travel rocks
22:07:12 <lispy> Python has time travel?
22:07:13 <SamB> with Python, they don't even share the time machine! they keep it locked up somewhere where only timbot and guido can get to it, I think...
22:07:20 <lispy> i thought it was jst the delorien
22:08:05 <Lycan359> I still can't decide between haskell and ocaml :P
22:08:34 <lispy> Lycan359: do you need to decide for a particular reason?
22:08:51 <Lycan359> Not really.
22:09:02 <SamB> apparantly nhc98 keeps all the input from the first time round in a buffer so that it can run everything again the same way...
22:10:23 * SamB wonders if that is related to the limited number of foreign objects nhc supports
22:11:19 <Lycan359> I just can't shake the feeling that laziness is a tad overrated.
22:11:43 <SamB> it probably is!
22:11:50 <SamB> but it is still nice
22:12:01 <SamB> for one thing, it got us this purely functional language!
22:12:57 <SamB> (it isn't very practical to have a non-purely-functional language be lazy, because then things get so very confusing as to the order of IO, etc.)
22:13:29 <Lycan359> Doesn't being lazy cause problems with compilation to native?
22:13:38 <SamB> why would it?
22:13:45 <SamB> I mean, more than any other way of being...
22:13:49 <lispy> the main problems i've herad of is the building of thunks that just hang around and take up ram
22:14:41 <SamB> well, yeah, there is that
22:14:58 <mikael> learn haskell, and you'll pretty much know ocaml :-)
22:15:02 <SamB> but it is worth it to not have to compose iteration by hand...
22:15:14 <lispy> the other argument is that most thunks get evaluated so dealing with them just creates overhead
22:15:37 <lispy> SamB: and there is iterate if you do need to ;)
22:15:42 <lispy> @type iterate
22:15:49 <lambdabot> iterate :: forall a. (a -> a) -> a -> [a]
22:16:22 <mikael> is there a primitive for forcing eager evaluation of an expression?
22:16:32 <lispy> @index evaluate
22:16:33 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
22:16:38 <lispy> @index seq
22:16:40 <lambdabot> Prelude, Control.Parallel
22:16:48 <lispy> those will do some of that
22:16:51 <lispy> but i dont' know how much
22:16:53 <SamB> lispy: that doesn't change the fact that my Haskell translation of unlamda.c is about twice as fast as the original...
22:17:27 <SamB> a `seq` b puts a in Weak Head Normal form before entering b...
22:17:39 <lispy> SamB: yeah, if you are using it to avoid unnecessary computation you will have savings
22:17:57 <SamB> lispy: I'm not using it for anything!
22:18:10 <SamB> I'm not even sure whether or not I get any thunks.
22:19:29 <SamB> I just did a straight translation, the program was practically made for Algebraic Data Types...
22:20:06 <SamB> I still have no clue what is wrong with my other implementation...
22:20:54 <SamB> (I hope to look into that tomarrow, when I might hope to be able to untangle my translation and figure out what it is really doing)
22:21:11 <lispy> SamB: what did you translate from?
22:21:14 <lispy> what is unlambda?
22:21:29 <mikael> uh, this is probably a stupid question, but what's an example of an expression that _isn't_ in weak head normal form?
22:21:47 <SamB> c/unlambda.c in the unlambda-2.0.0 distribution
22:22:03 <SamB> mikael: there is no such thing as an expression that isn't in weak head normal form
22:22:17 <SamB> only values can be.
22:22:54 <mikael> oh.  sorry, I mean value (though I'm not clear on what the difference is in a purely functional language :-))
22:23:11 <SamB> basically, something like that is represented in the heap by a closure which does not correspond to a data constructor...
22:23:42 <SamB> (although it is more complicated with functions)
22:24:00 <lispy> something that is not in normal form is a lambda expression that is ready to be evaluated
22:24:24 <lispy> for example (\x -> x) 5
22:24:52 <SamB> @plugs (x -> x) () `seq` 1
22:24:56 <lambdabot> parse error on input `->'
22:25:00 <SamB> @plugs (\x -> x) () `seq` 1
22:25:01 <lambdabot> 1
22:25:12 <SamB> @plugs (undefined) () `seq` 1
22:25:13 <lambdabot> Fail: Prelude.undefined
22:25:52 <SamB> @plugs (undefined :: Int -> Int) `seq` 1
22:25:53 <lambdabot> Fail: Prelude.undefined
22:26:10 <SamB> no wait, duh, of course that don't work...
22:26:11 <lispy> i forget how normal form and WHNF differ
22:26:34 <mikael> FOLDOC claims a value in WHNF is either in HNF or a lambda abstraction
22:26:41 <lispy> isn't WHNF designed to make it easier to do graph reductions?
22:26:48 <SamB> I suspect normal form means the value and all its children are evaluated...
22:27:13 <lispy> yeah, it's like you're done
22:28:06 <SamB> so the only reason to enter such a value is if that is how you implemented your core case construct...
22:30:40 <SamB> for some reason, the C version of the unlambda interpreter, though it claims to be a more or less mechanical translation of the Java version, seems to be a LOT easier to read...
22:31:14 <SamB> or maybe I am confused with my Haskell translation of that...
22:31:15 <lispy> i find C and java hard to read these days
22:31:51 <SamB> I never did have a large enough screen for Java, I think...
22:34:46 <lispy> hehe
23:33:56 <xerox> 'morning -- YAWN.
23:39:04 <ski> m..morn'
23:39:17 <p21870> morning
23:39:28 <p21870> some good ideas....just come early
23:40:11 <xerox> p21870, or very very lately ;)
23:40:55 <ski> or maybe not at all ?
23:41:34 * ski ponders multi-methods
23:41:58 <xerox> ski, as in CLOS?
23:42:06 <ski> maybe
23:42:28 * ski hasn't studied CLOS closely
23:42:50 <xerox> I just read about it on PCL.
23:42:56 <ski> just thinking a little on it, in comparision with ordinary coalgebras ..
23:43:37 * xerox hasn't studied ordinary coalgebras closely^H^H^H^H^H^H^Hat all.
23:44:05 <ski> more or less just (lazy) records (from this pov)
23:44:30 * xerox mumbles
23:45:25 <ski> like  data Stream a = S {head :: a,tail :: Stream a}
23:46:38 <xerox> OK, records.  And.. ?
23:46:49 <ski> mm, just thinking a bit slowly
23:46:56 <ski> head :: Stream a -> a
23:47:01 <ski> tail :: Stream a -> Stream a
23:47:17 <ski> me thinks it would be nice if one could write something like
23:47:27 <ski> from :: Integer -> Stream Integer
23:47:33 <ski> head (from n) = n
23:47:39 <ski> tail (from n) = from (n+1)
23:47:52 <ski> (i.e. defining from that way)
23:50:11 <ski> hm, for something of record/coalgebra type to be fully defined, we of course need to have a case for each projection/selector/field(/method)
23:51:12 <ski> but, each thing that produces, e.g., a stream can be defined independent from all the other such producers
23:51:12 <xerox> It is indeed interesting.
23:51:44 <ski> compare with this multimethods like
23:51:50 <ski> mm
23:52:09 <ski> well, head and tail were the two "methods" above
23:52:17 <ski> now we have a method
23:52:34 <ski> beats :: Gesture -> Gesture -> Bool
23:52:38 <xerox> How does the conversion from Stream a to Integer would happen, in |head (from n) = n ?
23:52:46 <ski> hm
23:53:05 <ski> head :: Stream a -> a
23:53:17 <ski> and from :: Integer -> Stream Integer
23:53:21 <ski> so
23:53:26 <ski> head (from n) = n
23:53:42 <ski> tells what happens if we apply head to a stream produced by from
23:53:51 <ski> and similarly for tail
23:54:00 <ski> clear ?
23:54:03 <xerox> Yep!
23:54:40 <ski> i.e. we don't "directly" give some implementation of a stream back somehow
23:54:55 <ski> we just tell what happens if we pass this internal impl. to head
23:54:58 <ski> so to speak
23:55:22 <ski> this is a bit similar to pattern-matching, but the other way around
23:55:44 <xerox> I see.
23:55:48 <ski> pattern-matching is used to define consumers on algebraic datatype, by cases
23:56:08 <ski> "method-dispatching" is used to define producers on coalgebraic datatype, by cases
23:56:10 <xerox> This is dispatching
23:56:12 <xerox> Yeah.
23:56:40 <ski> btw, of course one cannot (currently) write like i did above in haskell
23:57:09 <ski> but i think it would be nice, and fit in good with the FP way
23:57:24 <ski> ok
23:58:09 <lispy> multi-methods are nice
23:58:14 <lispy> clos does have them
23:58:21 <xerox> ski, is a GHC extension coming along the way?
23:58:36 <ski> if you define a coalgebraic producer (like from, above), then you don't have to keep track of other producers to do that ("of course")
23:58:44 <ski> xerox : not that i know
23:59:04 <ski> xerox : but i would surely like it
23:59:14 <ski> lispy : mm
23:59:19 <xerox> ski, like it as in writing it or having it? ;)
23:59:29 <ski> well, having it
23:59:37 <ski> possibly also writining it :)
23:59:42 <ski> writing
