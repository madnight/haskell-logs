00:00:05 <ski> now, compare with this multi-meth example
00:00:17 <ski> we have a coalgebraic type Gesture
00:00:19 <ski> and
00:00:25 <ski> a multi-method
00:00:34 <ski> beats :: Gesture -> Gesture -> Bool
00:00:44 <p21870> props voor de heistroker
00:01:06 <lispy> @type fromIntegral
00:01:08 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
00:01:18 <ski> now we wanna define the Gesture producers ("classes" or "class constructors") stone,bag,scissor
00:01:28 <lispy> i'm pretty sure fromIntegral would qualify as a multi-method in the clos sense
00:01:34 <ski> xerox : following ?
00:01:37 <yain> tintin++
00:01:59 <xerox> ski, yes.
00:02:19 <ski> lispy : possibly. though here i'm not considering type classes, but rather comparing with coalgebras/(lazy)records
00:02:35 <xerox> lispy, do you know if there is a name for the method-combination done with :before :around :after ?
00:02:49 <ski> so, we need to define those 3 by what the single multi-method over Gesture does over them, of course
00:02:51 <xerox> Ugh, that's probably ``method combination'' :)
00:03:12 <lispy> xerox: yes, standard method combination ;)
00:03:13 <ski> stone,bag,scissor :: Gesture
00:03:28 <lispy> xerox: check PCL (practical common lisp, should be available via google)
00:03:36 <xerox> lispy, yep, it agrees.
00:03:38 <ski> beats stone stone = False
00:03:42 <ski> beats stone bag = False
00:03:48 <ski> beats stone scissor = True
00:03:57 <ski> beats bag stone = True
00:04:03 <ski> beats bag bag = False
00:04:10 <ski> beats bag scissor = False
00:04:14 <lispy> xerox: method combination is wonderfully useful for debugging of all things
00:04:18 <ski> beats scissor stone = False
00:04:24 <ski> beats scissor bag = True
00:04:30 <ski> beats scissor scissor = False
00:04:36 <yain> i thought it's paper, not bad?
00:04:43 <yain> *bag
00:04:49 <tic> a -paper- bag. :)
00:04:51 <xerox> lispy, indeed.  I was on the way to code many things in CL, after reading PCL - but then I learnt of Haskell :-)
00:05:00 * ski is not exactly sure what method combination is ..
00:05:05 <lispy> xerox: ah ;)
00:05:32 <xerox> ski, this is indeed possible in current Haskell, right?
00:05:38 <lispy> ski: you write the same method but put :after, :before or :around after the name and your new method is then called :after, :before or :around the existing ones
00:06:05 <lispy> ski: it's nice for debugging because your debugging version can be :before or :after and output some sort of diagnostic everytime the method is used
00:06:07 <ski> xerox : implementing the above ?  don't think so  (not even with other syntax)
00:06:19 <vegai> what does :around mean?
00:06:27 <lispy> :around can be hard to use
00:06:27 <vegai> both after and before?
00:06:38 <lispy> it runs before and after, and can modify the argument or break the chain of method calls
00:06:44 <vegai> ok
00:06:44 <lispy> or something like that
00:06:55 <ski> lispy : what existing ones ?
00:06:56 <lispy> i don't fully grok it
00:06:58 <vegai> so you can do invariants with those pretty nicely, right?
00:07:03 <xerox> From PCL: ``Finally, :around methods are combined much like primary methods except they're run "around" all the other methods. That is, the code from the most specific :around method is run before anything else. Within the body of an :around method, CALL-NEXT-METHOD will lead to the code of the next most specific :around method or, in the least specific :around method, to the complex of :before, primary, and :after methods. Alm
00:07:03 <xerox> ost all :around methods will contain such a call to CALL-NEXT-METHOD because an :around method that doesn't will completely hijack the implementation of the generic function from all the methods except for more-specific :around methods.''
00:07:37 <lispy> ski: yeah, methods have the same name, but are parameterized on the types (or values) of the arguments
00:07:52 <lispy> ski: does that help?
00:08:10 <ski> but what other existsing methods are there to combine with ?
00:08:10 <xerox> wli, y0!  What an hostname :)
00:08:20 <lispy> ski: any that have been defined with that name...
00:08:34 <lispy> ski: (defmethod foo (x)) (defmethod foo :after (x))
00:08:38 <lispy> ski: like that
00:09:02 <ski> hm, i thought you mean methods that applies to the same input as the current does ..
00:09:16 <lispy> yeah
00:09:21 <lispy> i do mean that ;)
00:09:37 <lispy> ski: PCL gives a much better example ;)
00:09:45 <lispy> and it's easy to read
00:09:53 <ski> are you talking about combining methods which works on difference shapes (cover different cases), or overlapping ones ?
00:09:57 <p21870> tintin++ wasnt that some mud client?
00:10:06 <lispy> ski: yes
00:10:36 <lispy> ski: iirc they work in either case
00:10:43 <ski> please tell which part of the disjunction you affirmed ..
00:10:45 <lispy> ski: CL does a topological sort on classes
00:11:05 <lispy> and then calls the most specific method first
00:11:16 <lispy> and calls the less specific ones after that
00:11:18 * ski is trying to keep this very simple and easy, at the start
00:11:46 <lispy> p21870: yes it was
00:11:46 <ski> so, i want to restrict to exactly one definition matches each specific input
00:11:55 <ski> (for now :)
00:12:35 <ski> lispy : what is PCL ?
00:12:40 <lispy> so you define a class, say c1, then you say (defmethod foo ((c c1)) ...) and also (defmethod foo :after ((c c1)) ...)
00:12:47 <lispy> ski: practical common lisp
00:12:57 <lispy> ski: sorry for the acronyms ;)
00:12:58 <ski> an impl, i assume ?
00:13:01 <lispy> no, a book
00:13:07 <ski> aha, ok
00:13:11 <xerox> @google pratical common lisp
00:13:13 <lambdabot> http://www.nhplace.com/kent/PS/Lambda.html
00:13:16 <xerox> Nope.
00:13:24 <xerox> @google PCL site:gigamonkeys.com
00:13:25 <lispy> ski: http://www.gigamonkeys.com/book/
00:13:26 <lambdabot> No result found.
00:13:29 <xerox> Indeed.
00:14:06 <ski> ty
00:14:09 <ski> anyway
00:14:10 <lispy> i've been meaning to get a copy
00:14:31 <ski> i'm sure i should sooner or later look more closely at what CLOS does
00:14:46 <lispy> clos is interesting, OO was still very new when clos was designed
00:15:06 <lispy> the clos designers allowed almost anything because they didn't know what was good or what would be popular
00:15:21 <ski> but currenly, i'm just trying to pin down how (IMO) it could possibly work (e.g. in a purely functional language like haskell)
00:15:46 <xerox> http://lispmeister.com/blog/lisp-news/OO-Programming-Paepcke.html
00:15:50 <lispy> well, i think everything is there in haskell to do it the clos way
00:16:00 <ski> also, comparing it with simple coalgebras ("one argument decides which method to use")
00:16:07 <lispy> taking for example fromIntegral
00:16:52 <lispy> but, some stuff is mising form haskell
00:16:56 <ski> anyway
00:17:11 * ski would like to make his point, soon :)
00:17:42 <lispy> don't worry about me, i'm just rambling ;)
00:17:45 <ski> lispy : "<lispy> well, i think everything is there in haskell to do it the clos way" "<lispy> but, some stuff is mising form haskell"  ??
00:17:53 <xerox> Sorry :)
00:18:04 <ski> np :) just looked weird
00:18:07 <ski> ok
00:18:29 <lispy> ski: yeah, i did contradict myself
00:18:39 <lispy> because i realized something things that wouldn't work
00:18:47 <lispy> sorry 'bout that
00:18:54 <ski> np
00:19:03 <ski> so we had a type Gesture, with a single multi-method beats :: Gesture -> Gesture -> Bool
00:19:07 <xerox> Hiya boegel!
00:19:34 <ski> and, then we wanted to define three producers stone,bag,scissor :: Gesture
00:19:44 <xerox> ski, ah, now I see why it is impossible in current Haskell: stone, scissor & bag arent -types- :)
00:19:57 <ski> well
00:20:18 <ski> i currently think it would be a mistake to make them types ;)
00:20:31 <ski> but, continuing
00:20:32 <xerox> Why? :)
00:20:48 <tic> data Gesture = Stone | Bag | Scissors?
00:21:41 <ski> and, when we tried to define them, we had to define them together, not possible to separate it  (well, we haven't proved this, but it anyway looks hard to define them independant of each other)
00:22:00 <lispy> ski: right
00:22:07 <ski> tic : no, i don't want an algebraic datatype, i want a coalgebraic datatype or something similar
00:22:34 <lispy> ski: i don't know coalgebraic datatypes, but i see the problem you want to solve now
00:22:38 <lispy> at least i think i do
00:22:45 <ski> well
00:22:58 <ski> let me explain a little
00:23:16 <lispy> okay
00:23:21 <lispy> i have to go to bed soon ;)
00:23:25 <ski> (ok)
00:23:27 <lispy> so i may have to read the logs
00:23:59 <ski> algebraic datatypes have special producers called constructors, like True, False and Nothing, Just, etc
00:24:32 <ski> and you can define "direct" consumers, by patternmatching on all the possible cases
00:25:14 <ski> you can also define indirect producers, like  singleton a = a : []
00:26:00 <ski> an indirect consumers, like  foo xs = sum (map bar xs)   (if xs is a list)
00:26:21 <ski> understand what i mean by direct vs indirect and consumers vs producers ?
00:26:33 <ski> constructors are the direct producers
00:26:34 <lispy> direct producers i don't get
00:26:44 <lispy> sorry indirect
00:27:07 <lispy> i don't really get this one singleton a =  a : []
00:27:16 <ski> one can use Just to construct things of some Maybe type
00:27:38 <ski> ok, another example
00:27:47 <ski> justJust a = Just (Just a)
00:28:02 <ski> this also procudes something of some Maybe type
00:28:05 <ski> but
00:28:15 <ski> you can't pattern-match on justJust
00:28:22 <lispy> righ
00:29:10 <ski> because it's indirect  (it's not one of the constructors)
00:29:11 <xerox> I wonder if there is a reason for thi.
00:29:40 <ski> anyway
00:29:53 <ski> compare this with coalgebraic datatypes
00:30:08 <ski> alg. datatypes have constructors
00:30:16 <lispy> xerox: i think one reason is, how can you tell when something is a function applied to something?
00:30:58 <ski> lispy : right, you'd somehow have to run the function backwards, and that's not always possible, also not always unique result
00:31:16 <ski> coalg. datatypes have deconstructors/selectors/projections/fields/methods
00:31:28 <ski> you follow ?
00:31:48 <lispy> hmm...
00:31:49 <boegel> yo xerox !
00:32:08 <lispy> ski: i think so
00:32:14 <ski> haskell doens't have syntax for coalg. datatypes
00:32:22 <ski> you can simulate it like
00:32:38 <ski> data Stream a = S {head :: a, tail :: Stream a}
00:33:12 <ski> but really, that's an algebraic datatype, with one constructor, and two convenience functions head, tail defined
00:33:15 <ski> anyway
00:33:30 <ski> syntax for coalg. could maybe look like
00:33:46 <ski> data Stream a = Head :: a
00:33:57 <ski>               & Tail :: Stream a
00:34:02 <ski> note the '&' !
00:34:24 <ski> this would give two selectors/deconstructors
00:34:34 <ski> Head :: Stream a -> a
00:34:39 <ski> Tail :: Stream a -> Stream a
00:34:54 <ski> (just like the prev. def in legal haskell)
00:35:00 <ski> ok
00:35:23 <ski> follow ?
00:35:29 <lispy> sort of
00:35:36 <lispy> what is the definition of Head ?
00:35:39 <ski> no
00:35:53 <ski> it has no (in-lang) definition
00:36:04 <ski> just like True has not in-lang definition
00:36:16 <xerox> As in the records, it's a "selector"/"deconstructor"
00:36:21 <ski> it's it already there, given by the declaraion of the new type
00:36:30 <ski> right
00:37:01 <ski> so, the important things are mostly here that it's more or less records
00:37:17 <lispy> it's good stuff but i need to go
00:37:35 <ski> and instead of having constructors, it has deconstructors
00:37:44 <ski> ok, mm
00:37:54 <lispy> see ya
00:37:55 <ski> xerox : you wanna me explain some more ?
00:38:01 <xerox> ski, sure!
00:38:11 <ski> (otherwise i could continue some other time)
00:38:12 <lispy> in that case i'll check the logs tomorrow ;)
00:38:17 <ski> ok :)
00:38:30 <lispy> ski: thanks
00:39:55 <ski> so, for alg. types, you are given a fixed set of constructors = direct producers, indirect producers are defined by calling other indirect or direct producers (which will finnaly call a direct producer for creating the real valeu)
00:40:10 <ski> ok ?
00:40:23 <xerox> Yep.
00:40:46 <ski> (just so you understand my terminology and distinctions and some vital details)
00:41:28 <p21870> callee is the function begin called right?
00:41:36 <ski> also, still for alg. types, direct consumers are defined by pattern-matching on all the cases (i.e. of the fixed set of constructor forms a value could be of)
00:41:41 <p21870> begin=being
00:41:47 <ski> p21870 : yes
00:42:04 <ski> p21870 : (because caller is the one who calls it :)
00:42:45 <ski> and, indirect consumers are similarly just defined by a chain of 1 or morecalls that will finally call a direct producer
00:42:49 <ski> xerox : ok ?
00:42:50 <xerox> ski, an example of alg. datatype's consumer?
00:42:54 <ski> ok
00:43:03 <ski> length Nil = 0
00:43:08 <p21870> ski, ah yes....it seems so obvious now
00:43:13 <ski> length (Cons x xs) = 1 + length xs
00:43:21 <ski> or, if you like
00:43:26 <p21870> really should have that wake-up coffee
00:43:30 <ski> length xs = case xs of
00:43:33 <ski>   Nil -> 0
00:43:39 <ski>   Cons y ys -> 1 + length ys
00:43:47 <xerox> For: data Cons a = Nil | Cons a ?
00:43:48 <ski> ok ?
00:43:50 <ski> yep
00:43:57 <xerox> hmm Cons a a.
00:44:15 <xerox> That's a consumer/destructor.  OK.
00:44:25 <ski> (just used that instead of normal list syntax, to see the constructors more regularily)
00:44:33 <ski> data List a = Nil
00:44:42 <ski>             | Cons a (List a)
00:44:44 <ski> rather
00:44:50 <ski> no
00:44:53 <ski> not a destructor
00:45:01 <ski> a direct consumer
00:45:27 <ski> btw, just so you know, this terminology is my own, and not necessarily some standard one
00:45:43 <xerox> OK :)
00:46:15 <ski> ok, this was direct/indirect consumer/producer for alg. types
00:46:24 <ski> now compare with coalg. types
00:46:59 <ski> (i'm going to use the non-implemented syntax you saw above)
00:47:12 <xerox> '&'
00:47:17 <ski> first, direct consumers are the deconstructors/selectors
00:47:44 <ski> data Stream a = Head :: a
00:47:52 <ski>               & Tail :: Stream a
00:47:55 <ski> ok
00:48:33 <ski> an indirect consumer is just something that is defined and will finally call a direct consumer (deconstructor) on the input
00:48:43 <ski> now, direct producer
00:48:45 <ski> e.g.
00:48:53 <ski> from :: Integer -> Stream Integer
00:48:59 <ski> Head (from n) = n
00:49:06 <ski> Tail (from n) = from (n+1)
00:49:11 <ski> another one
00:49:19 <ski> repeat :: a -> Stream a
00:49:33 <ski> Head (repeat a) = a
00:49:39 <ski> Tail (repeat a) = repeat a
00:49:44 <xerox> :)))
00:49:47 <ski> this can be written as
00:49:51 <ski> repeat a = this
00:49:53 <ski>   where
00:49:57 <ski>   Head this = a
00:50:03 <ski>   Tail this = this
00:50:25 <xerox> This opens a new world :-)
00:50:42 <ski> here, it is actually 'this' that is the direct producer, and repeat is an indirect producer
00:50:44 <ski> heh
00:51:13 <xerox> Yeah
00:51:21 <ski> note that you can already do this in haskell, if you simulate the coal. type as i said above, but it looks way uglier (IMO)
00:51:23 <ski> like
00:51:40 <ski> data Stream a = S {head :: a, tail :: Stream a}
00:51:52 <ski> from :: Integer -> Stream Integer
00:52:09 <ski> from n = S {head = n, tail = from (n+1)}
00:52:19 <ski> repeat :: a -> Stream a
00:52:29 <ski> repeat a = S {head = a, tail = repeat a}
00:52:31 <ski> or
00:52:35 <ski> repeat a = this
00:52:36 <ski>   where
00:52:45 <ski>   this = S {head = a, tail = this}
00:52:49 <ski> ok ?
00:52:55 <xerox> What does "coal" mean?
00:53:02 <ski> sorry
00:53:03 * boegel leaves to get some food
00:53:04 <ski> coalg.
00:53:05 <xerox> I understand the example, yeah
00:53:12 <ski> i.e. coalgebraic (type)
00:53:16 <xerox> Aaaah, yes.
00:54:20 <ski> understand, so far ?
00:54:23 * ski looks at log to see what he was going to say after explaining this
00:54:24 <xerox> I think so
00:55:02 <ski> yes
00:55:35 <TFK> Is GTK+hs active?
00:55:42 <ski> (btw, i'm trying to present this as symmetrically as i can. with comparision to alg. types)
00:55:55 <xerox> ski, yes, I see, and I thank you for that :-)
00:55:58 <ski> so, back to alg. types
00:57:20 <ski> we have a fixed set of direct producers (unless we start allowing subtyping (or maybe some kind of extensible type, like ML's exception type 'exn'). and i don't want to complicate it (yet, at leadt :) with subtyping)
00:59:40 <p21870> @pl \f g x -> f x ++ g x
00:59:41 <lambdabot> liftM2 (++)
00:59:48 <ski> (i hope you have noticed i try to make some parallel of coalg. types and *some* concepts in OO. just note that i'm not considering all of OO. i don't think doing this properly will result in something that is exactly like current OO (or rather some aspects of it, there are also methodology etc in OO). hopefully it will result in something better, or at least clearer ;) we'll see about usability ..)
00:59:48 <TFK> I'll take that as a "no", then?
01:00:03 <p21870> @type liftM2
01:00:04 <lambdabot> bzzt
01:00:11 <p21870> @type Control.Monad.liftM2
01:00:12 <lambdabot> Control.Monad.liftM2 :: forall r (m :: * -> *) a2 a1.
01:00:12 <lambdabot>         (Monad m) =>
01:00:12 <lambdabot>         (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:00:14 <xerox> ski, yea, as in (/methods) before :-)
01:00:21 <ski> xerox : ok ?
01:00:26 <xerox> YEs.
01:01:20 <ski> (".. think doing this properly ..", "this" being what i'm trying to do with coalg. types here :)
01:01:23 <ski> ok
01:02:04 <ski> so, in alg. types, direct producers are fixed. on the other hand, direct consumers are open
01:02:15 <ski> i.e. you can define as many as you like
01:02:26 <xerox> Yup
01:02:46 <p21870> @type Functor
01:02:48 <lambdabot> bzzt
01:03:07 <ski> also, defining one doesn't require knowledge of any other of them   (this sounds obvious, but i'm going to compare with this, in a while)
01:03:28 <ski> ok
01:03:36 <ski> so, coalg. types
01:03:51 <ski> there, it's the direct producers (deconstructors), which are fixed
01:04:00 <ski> and the direct consumers are open
01:04:13 <ski> like 'from' and 'repeat', above
01:04:14 <ski> ok ?
01:04:20 <xerox> YEs
01:04:55 <ski> mm, sorry
01:05:07 <xerox> ?
01:05:14 <ski> should be "there, it's the direct *consumers* (deconstructors), which are fixed"
01:05:23 <p21870> to what monad does liftM2 lift (++) in "\f g x -> f x ++ g x" <=> "liftM2 (++)"
01:05:29 <ski> should be "and the direct *producers* are open"
01:05:37 <ski> xerox : ok ?
01:05:41 <xerox> Let me think
01:05:51 <ski> Head is a direct consumer
01:05:59 <ski> from is a direct producer
01:06:02 <xerox> OK.
01:06:30 <ski> so the direct consumers (here Head,Tail) are fixed (can't be extended (without changing the type definition, i.e.))
01:07:24 <ski> and the same notice applies here to defining direct producers not requiring knowledge of other such   as with the direct consumers in alg. types
01:07:51 <ski> (just trying to be fully clear)
01:07:54 <ski> ok
01:07:56 <ski> now
01:08:06 <ski> Head :: Stream a -> a
01:08:21 <ski> this takes *one* thing and dispatches on it
01:09:10 <ski> now we try to extend to some kind of multimethods (so i'll call this, multimethod types, RN, rather than coalgebraic types)
01:09:12 <xerox> As you just explained
01:09:18 <xerox> Yep.
01:09:30 <ski> (no syntax for this, yet)
01:09:40 <ski> we have a multimethod type Gesture
01:09:44 <p21870> @plugs ((liftM2 (++)) (\x -> [x]) (\x -> [x])) 'a'
01:09:45 <lambdabot> <Plugins.Eval>:1:
01:09:45 <lambdabot>   No instance for (Monad ((->) Char))
01:09:45 <lambdabot>   arising from use of `liftM2'
01:09:50 <p21870> exactly
01:09:57 <ski> and an associated multi-deconstructor
01:10:04 <p21870> @plugs (\f g x -> f x ++ g x) 'a'
01:10:06 <lambdabot> Couldn't match `t -> [a]' against `Char'
01:10:10 <ski> beats :: Gesture -> Gesture -> Bool
01:10:14 <ski> hm
01:10:16 <ski> make that
01:10:19 <ski> Beats :: Gesture -> Gesture -> Bool
01:10:24 <p21870> @plugs (\f g x -> f x ++ g x) (\x -> [x]) (\x -> [x]) 'a'
01:10:25 <lambdabot> "aa"
01:10:42 <p21870> so liftM2 is not equal to \f g x -> f x ++ g x
01:10:51 <ski> (i'm just using upper case to emphasise that this is fixed, similar to constructors for alg. types)
01:10:51 <p21870> so @pl gives me a wrong answer
01:10:55 <ski> xerox : ok ?
01:11:03 <xerox> ski, Yes
01:11:05 * p21870 whipps @pl
01:11:22 <p21870> @pl (\f g x -> f x ++ g x)
01:11:24 <lambdabot> liftM2 (++)
01:11:31 <p21870> @pl (\f g x -> (f x) ++ (g x))
01:11:32 <lambdabot> liftM2 (++)
01:11:36 <ski> so, similar to coal. we should say that the set of multi-deconstructors over Gesture are fixed, ok ?
01:11:47 <xerox> OK
01:12:14 <ski> p21870 : if you don't mind, maybe you could /msg lambdabot privately with such queries atm ?
01:12:47 <p21870> uuh....why?
01:13:03 <xerox> p21870, to keep track of the topic for a while :)
01:13:07 <ski> just, so i can think a little better and see what i'm talking about
01:13:27 <p21870> you could always talk with xerox in private, sounds the same to me
01:13:34 <p21870> :)
01:13:42 <ski> then lispy won't see the logs :(
01:14:09 <ski> p21870 : anyway, you of course don't have to. 'twas just a suggestion
01:14:26 <ski> (i can't force you)
01:14:39 <michaelw> i would second this
01:15:04 <michaelw> ski&xerox discussion is way more interesting that bot chatter
01:15:13 * ski looks up to see where he should continue ..
01:15:28 <p21870> opinions...nothing more
01:15:36 <xerox> Who cares...
01:15:45 <xerox> I was following you, could you continue?
01:15:50 <ski> (p21870 : you are correct. it's opinions)
01:15:54 * ski continues now
01:16:05 <xerox> multi-deconstrucors are Fixed over Gesture
01:16:08 <xerox> err, multi-deconstructors
01:16:21 <ski> we have a multimethod type Gesture
01:16:27 <ski> and an associated multi-deconstructor
01:16:30 <ski> Beats :: Gesture -> Gesture -> Bool
01:16:57 <ski> so, now we should have an open set of direct producers
01:17:10 <ski> i.e. it's not fixed, we could define new anytime
01:17:22 <ski> (at least if similar to coalg. types)
01:17:31 <xerox> As in "from" ?
01:17:38 <ski> e.g. we could like to define
01:17:46 <ski> the direct producers
01:17:55 <ski> stone, bag, scissor :: Gesture
01:18:29 <ski> with the all nine rules i'm have already written earlier (to much work to write them again :)
01:18:35 <ski> ok ?
01:18:37 <xerox> OK
01:18:53 <xerox> Those whom defining them as types would be an error ;)
01:19:12 <ski> ;)
01:19:21 <ski> now, defining stone wasn't an independent activity
01:20:08 <ski> we had to know about bag and scissor, to fully define what the deconstructor Beats returns if given stone as the first argument
01:20:11 <ski> so
01:20:23 <xerox> Yes!
01:21:06 <ski> assume someone now wants, in similarity to defining repeat *after* (not at the same time) (possibly in a different module) for the coalg. type Stream a
01:21:22 <ski> to define a new direct producer for Gesture
01:21:29 <ski> how would that work ?
01:21:31 <ski> e.g.
01:21:43 <ski> fork :: Gesture   -- or something
01:22:41 <ski> in this particular application, this is not likely (because of traditional fixed 3 gesture. but this was just a simple example of multi-methods, not necessarily a representative one)
01:23:08 <ski> (though, i can't up with another simple one atm :( ..)
01:23:14 <ski> so
01:23:27 <ski> Beats fork ... = ...
01:23:33 <ski> Beats ... form = ...
01:23:58 <ski> we definitely need at least one case of each of those two forms
01:24:07 <ski> xerox : ok, so far ?
01:24:58 <xerox> Yes
01:25:22 * earthy thinks he's gotten what ski is trying to explain
01:26:28 * ski just dw an mp3 he heard on web radio
01:26:31 <ski> back
01:27:47 <ski> for simple linear extensions, we could say that we already know that there exists stone,bag,scissor :: Gesture, and thus we can define all the combinations with fork and one of those earlier ones
01:27:49 <ski> but
01:28:28 <ski> if person A extends the original 3 direct producers with 1 dir. prod. in module MA
01:28:40 <ski> and person B extends the original 3 direct producers with another 1 dir. prod. in module MB
01:29:02 <ski> then, if person C just wants to use module MA and MB, there are undefined cases
01:29:22 <ski> namely, those between new direct producers in MA, and new such in MB
01:29:42 <xerox> Yup
01:29:57 <ski> it won't be defined what Beats should return if given one from MA and one from MB
01:30:08 <xerox> While ago I was thinking about "what about undefined instance that could be created this way?"
01:30:20 <ski> so, of course, this problem is not new.
01:30:28 <ski> xerox : :)
01:30:49 <xerox> Beats _ _ = error "call ski."
01:30:57 <ski> (ski is a bit of a slow explainer, atm. just want to be fully clear, hope it's not too irritating)
01:31:06 * ski chuckles
01:31:28 <ski> but, how to solve this ?  i don't know
01:31:41 <xerox> Hrm.. the compiler could notice this I think.
01:31:52 <ski> possibly, it could do
01:32:06 <xerox> Then write some @ghc and let the user have big fun understanding
01:32:27 <ski> but that still leaves us with the modularity problem, person C having to try to understand both MA and MB, to be aply to fill in the missing parts
01:32:32 <ski> ;)
01:33:02 <ski> also, of course the number of specific cases for Beats is quadratic in the number of direct producers
01:33:11 <xerox> Yeah
01:33:34 <xerox> Policy: you must define a default case. ?
01:33:49 <xerox> It isn't obvious / praticable, in fact...
01:33:56 <ski> maybe one try to not always specify every single case, rather lumping some of them together
01:34:33 <ski> e.g. one could lump all the rest of them together in just one single case (default), as you say
01:34:50 <ski> Beats fork ... = ...
01:34:52 <ski> ...
01:35:02 <ski> Beats fork _ = ..some fixed default case..
01:35:07 <ski> hm
01:35:08 <michaelw> xerox: default case might blur the error, i think the compiler should complain about non-exhaustive patterns and that's it
01:35:19 <ski> Beats ... spoon = ...
01:35:21 <ski> ...
01:35:29 <xerox> michaelw, something similar.  But then the modularity comes in the scene to complicate things.
01:35:37 <ski> Beats _ spoon = ..some possibly different defalut case..
01:35:54 <ski> now, what's  Beats fork spoon ?
01:36:03 <ski> which if the two default cases ?   :/
01:36:07 <ski> s/if/of/
01:36:31 <ski> see this problem ?
01:36:33 <michaelw> also, subtypes could help in cases, think Beats spoon/Beats greenSpoon/...
01:37:09 <ski> michaelw : possibly subtyping could help/alleviate, i'm just first trying without subtyping
01:37:18 <ski> hm
01:37:56 <ski> (xerox : see the prob of overlapping default cases in different modules (MA,MB, say))
01:37:58 <ski> ?
01:38:34 * xerox mumbles
01:38:53 <xerox> Sure.
01:38:57 <ski> so, anyway, 'tseems one can't just simply extend coalg. types right off to multi-method types. problems arise
01:38:59 <ski> mm
01:39:24 <ski> this is more or less as far as i've come :)
01:39:29 <ski> (currently)
01:40:42 <ski> ok, that was what i wanted to explain, i think  (hope you liked it)
01:40:46 <xerox> What about method-classes constraints, like type-classes one? :)
01:40:50 <michaelw> ski: btw, somebody at TU Berlin is writing a compiler for coalgebraic functional language
01:41:05 <ski> michaelw : who ? where ?  :)
01:41:13 <michaelw> let me find it
01:41:17 <ski> (i.e. where papers, etc ..)
01:41:44 <ski> (btw, i've been inspired by some of the papers by Erik Poll)
01:41:57 * ski goes to look for links to them ..
01:42:13 <ski> (and some by the lang. Charity, too)
01:43:08 <xerox> http://wwwtcs.inf.tu-dresden.de/~tews/ccsl/ ?
01:46:22 <michaelw> hmm...
01:46:56 <ski> http://www.cs.ru.nl/~erikpoll/    http://www.cs.ru.nl/~erikpoll/publications/kyoto97.html   http://www.cs.ru.nl/~erikpoll/publications/durham97.html
01:46:57 <michaelw> okay, the guy is called Baltasar Tranc√n y Widemann bt@cs.tu-berlin.de
01:47:03 <ski> ok, ty
01:49:47 <ski> http://wwwtcs.inf.tu-dresden.de/~tews/   says  Hendrik Tews
01:49:55 <michaelw> Khisanth: dlbp record shows some papers, but they are not on his homepage, maybe citeseer helps
01:50:16 <michaelw> s/Khisanth/ski/
01:50:50 <ski> (sorry, confused what xerox and michaelw said together)
01:50:54 <michaelw> anyhow, work calls
01:51:18 <ski> (anyway, you can look at those two papers by Erik Poll if you like. they are interresting)
01:51:22 <ski> mm
01:51:35 <michaelw> ski: thanks! nice discussion, btw
01:51:48 <ski> mm, ditto
01:54:19 <xerox> Thank you indeed.
01:54:23 <ski> yep
02:14:22 <xerox> @ghc
02:14:24 <lambdabot>  scavenge_stack: weird activation record found on stack
02:14:32 <xerox> @ghc
02:14:34 <lambdabot>  Splices are not allowed in hs-boot files
02:26:25 <dons> @code
02:26:26 <lambdabot> ConsoleHandler.hs: Default -> rts_installHandler STG_SIG_DFL p_sp
02:26:56 <dons> @hoogle a  -> b -> c
02:26:58 <lambdabot> Prelude.(^) :: (Num a, Integral b) => (a -> b -> a)
02:29:28 <gennet1> @seen shapr
02:29:28 <lambdabot> Last time I saw shapr was when I left #haskell 6 hours, 22 minutes
02:29:28 <lambdabot> and 59 seconds ago, and I have missed 13 seconds since then.
02:30:54 <ski> xerox : hm, what did you mean more specifically with method-classes constraints ?
02:31:54 <xerox> Hmm
02:32:41 <xerox> I tought we could constraint them in some way.  Nothing specifically in fact.
02:33:40 <ski> i'm thinking doing OO-like stuff with type classes is different approach than doing it with coalgebraic types ..
02:33:50 <xerox> Oh, sure
02:35:02 <xerox> In fact constraining would not probably solve the problem.
02:35:03 * boegel bounces
02:35:05 <ski> (though, it seems one can simulate alg. and coalg. types with direct consumers resp. producers  using  type classes and new types and instances ..)
02:37:55 * boegel is bored
02:38:20 <xerox> boegel, implement coalg. types for GHC while solving problems found this morning.
02:38:25 <xerox> plase. :P
02:38:39 <boegel> xerox: no way I'm able to do that :)
02:39:02 <boegel> I don't even know what coalgebraic types are :)
02:40:01 * ski thinks it's more or less just syntax and a new type declaration form we need (+ some stuff in typesystem)
02:40:24 <ski> think one could implement it just in like the simulation given earlier
02:40:52 <ski> boegel : coalgebraic types are more or less the same as records
02:40:54 * xerox would love to being able to play with this in non-theoretical (i.e. programmatica) ways.
02:41:34 * boegel thinks he just doesn't have tke skills to pull such a thing off
02:41:36 <ski> xerox : you can already use the simulation. just it's ugly, and leads the thought in worong direction, possibly
02:42:21 <xerox> Do you mean faking them with records, as in from .. = S { ... } ?
02:42:33 * ski thinks coalgebraic types should be *lazy* records, though. but as haskell is already lazy, that shouldn't be hard to achieve
02:42:39 <ski> xerox : yes
02:42:51 <ski> s/worong/worng/
02:43:02 <xerox> I'll give it a shot.
02:43:39 <ski> you could always write in the nicer syntax in a comment, and translate it to the simulation afterwards
02:44:21 <ski> (also, algebraic datatypes ought to be strict, which haskell's such isn't. or at least, it's not normal alg. datatypes)
02:44:47 <nibro> Gee, that's one for @quote "<ski> s/worong/worng/" ;-)
02:44:49 <xerox> Do you mean by using TH?
02:45:01 <ski> um
02:45:05 <ski> no
02:45:13 <xerox> Pheeeww, I would not be able to :-)
02:45:17 <ski> maybe that could be done, dunno (don't know TH)
02:45:57 <xerox> Oh, I missed that part: "in a comment" :-)
02:46:03 <ski> (nibro : if you like)
02:46:29 <ski> (though, worng ought to be spelled 'worng'. 'cuz it should be worng)
02:46:43 <xerox> Excuses :P
02:46:48 <ski> (but maybe that makes it not worng ? :)
02:46:57 <ski> :)
02:58:15 * boegel is still bored
02:58:18 <dons> @code
02:58:19 <lambdabot> ReadPrec.hs: readP_to_Prec f = P f
02:58:24 <dons> @y0w
02:58:26 <lambdabot> With YOU, I can be MYSELF ...  We don't NEED Dan Rather ...
02:58:27 <boegel> and so is dons apparently
02:58:34 <xerox> @moo
02:58:35 <lambdabot>          (__)
02:58:35 <lambdabot>          (oo)
02:58:35 <lambdabot>   /-------\/
02:58:35 <lambdabot>  / |     ||
02:58:35 <lambdabot> *  ||W---||
02:58:36 <lambdabot>    ~~    ~~
02:58:37 <dons> no. not bored. too busy in fact!
02:58:38 <lambdabot>   Cow laden
02:58:40 <lambdabot>   with milk
02:58:45 <boegel> dons: I can tell :p
02:58:46 <dons> @ghc
02:58:47 <lambdabot>  invalid character
02:58:50 <sylvan> if you're bored take a look at nemerle.org, a nicer way to program .Net
02:59:42 * boegel doesn't like .Net
03:01:32 <xerox> Anyway the lanuage features are nifty ;)
03:01:35 <xerox> *language
03:02:26 <xerox> lambdabot, @vixen do you like .Net?
03:02:27 <lambdabot> yah, i like
03:02:33 * xerox grins
03:03:43 <dons> @vixen, what abou haskell?
03:03:44 <lambdabot> Ooh, functional programmers are so hot!
03:04:07 <xerox> @vixen are you male or female?
03:04:09 <lambdabot> i truely am
03:04:14 <dons> mysterious
03:04:24 <xerox> ...ergo cogito :P
03:06:45 <boegel> @vixen are you male ?
03:06:46 <lambdabot> yes, i am
03:06:50 <boegel> @vixen are you female ?
03:06:51 <lambdabot> do i seem  un-feminine to you?
03:06:55 <boegel> lol :D
03:07:11 * boegel pets lambdabot "smaaaart lambdabot !"
03:07:20 <wilx> Heh.
03:07:22 <xerox> lambdabot, @botsnack
03:07:23 <lambdabot> Unknown command, try @listcommands.
03:07:28 <xerox> *O_O*
03:07:43 * xerox hacks the sources
03:08:04 * boegel leaves for lunch and studying
03:08:11 <xerox> Have fun!
03:13:21 <xerox> @eurohaskell
03:13:22 <lambdabot> less talks, more code!
03:13:22 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
03:13:22 <lambdabot> EuroHaskell - Haskell Hackfest - Summer 2005
03:13:22 <lambdabot> - Gothenburg, Sweden
03:14:12 <ski> really ? yay !
03:14:52 <xerox> I wonder how much would it cost to fly from Italy to Sweden.
03:15:11 * ski would only need to bike
03:15:36 <xerox> Lucky guy.
03:16:20 <lament> hm
03:16:30 <lament> is all haskell activity in europe?
03:16:47 <ski> much of it, anyway
03:17:19 <lament> :(
03:17:40 <ski> e.g. glasgow and chalmers (in gothenburg)
03:19:19 <lament> Is all haskell research classified as strictly CS?
03:19:25 <lament> Despite being so very much like math
03:19:55 <Philippa> pretty much all directly-haskell research is, yeah
03:20:15 <Philippa> certain areas of CS pretty much /are/ maths
03:29:13 <stefanw> the hscurses library (darcs get http://www.stefanwehr.de/darcs/hscurses/) now works with GHC 6.4. Be aware that the repository is "fresh" - just updating your local copy does not work (I've messed up the repository some time ago and creating the repo was the easiest fix)
03:29:50 <dons> stefanw, maybe announce on haskell@ ?
03:30:32 <stefanw> dons: yes, I'll do that, but I wanna finish a small example application first
03:31:05 <dons> sure :)
03:31:15 <dons> or port yi over ;)
03:31:25 <dons> or maybe that's my job..
03:32:20 <stefanw> porting yi shouldn't be hard...
03:33:53 <dons> I agree. Factoring out the ui so that we can swap between gtk and ncurses---that would be fun.
03:36:43 <dons> xerox, thanks for the lambdabot patch
03:54:06 <xerox> dons, oh, nothing really important, just fun :)
03:54:32 <xerox> I think I should start getting my hands over Yi.
03:55:27 <xerox> @botsnack
03:55:29 <lambdabot> Unknown command, try @listcommands.
03:59:25 <p21870> offtopic, who here has got an ipod and if so...what is absolutely the best headphone (earplugs, neck-thingy, large thing covering your ears, whatever)
04:01:36 <dons> @botsnack
04:01:37 <lambdabot> :)
04:01:40 <dons> @bots
04:01:41 <lambdabot> :)
04:01:43 <dons> @bot
04:01:44 <lambdabot> :)
04:01:46 <dons> @bo
04:01:47 <lambdabot> :)
04:01:53 <gennet1> p21870: big 200 W speakers?
04:01:54 <xerox> @buh!
04:01:56 <lambdabot> Unknown command, try @listcommands.
04:01:57 <xerox> :P
04:02:11 <gennet1> @b
04:02:12 <lambdabot> Maybe you meant: babel botsnack pl wn
04:02:13 <dons> prefix is tried first, then spell correction
04:02:27 <gennet1> @bostack
04:02:27 <p21870> gennet1, :D i was thinking a bit more mobile :P
04:02:28 <lambdabot> :)
04:02:47 <gennet1> @bootnasdaq
04:02:48 <lambdabot> Unknown command, try @listcommands.
04:03:00 <p21870> im thinking px 100, pmx 60, some sennheiser HD model
04:03:02 <gennet1> @bombirak
04:03:03 <lambdabot> Unknown command, try @listcommands.
04:03:09 <gennet1> pity
04:03:25 <gennet1> p21870: i'm not really an audiophile, just wanted to be a smart alec, sorry :p
04:04:16 <p21870> gennet1, i grant you that fun :P
04:04:19 <mikael> hey chris2 :-)
04:04:38 <xerox> @index choice
04:04:39 <lambdabot> Text.ParserCombinators.Parsec.Combinator, Text.ParserCombinators.
04:04:39 <lambdabot> Parsec, Text.ParserCombinators.ReadP, Distribution.Compat.ReadP,
04:04:39 <lambdabot> Text.ParserCombinators.ReadPrec, Text.Read
04:04:44 <chris2> hi mikael
04:06:42 <xerox> Just m  -> "http://darcs.complete.org/fptools/libraries/" ++ m ++ "/" ++ map (choice (=='.') (const '/') id) x ++ ".hs"
04:06:46 <xerox> What `choice' is it?
04:08:09 <p21870> maybe none of the above
04:08:14 <p21870> user defined
04:08:25 <xerox> Right.
04:08:33 <xerox> choice :: (r -> Bool) -> (r -> a) -> (r -> a) -> (r -> a)
04:08:34 <xerox> choice p f g x = if p x then f x else g x
04:08:50 <xerox> Now it does make sense :)
04:09:20 <p21870> so it was user defined?
04:09:41 <xerox> Yep.
04:15:06 <p21870> is it normal behaviour for lhs2tex to indent the code blocks denoted by \begin{code} and \end{code}?
04:53:28 <p21870> Muad_Dibber, would you happen to play 'wolfenstein; enemy territory' ?
04:53:53 <p21870> your name is quite unique i think and some guy was named exactly like that yesterday
04:55:02 <dcoutts> p21870, no! not enemy territory! it will take all your time and you'll never get any code written!
04:55:44 <dcoutts> I should start an ET Anynymous support group for people recovering from ET addiction.
04:55:51 <p21870> :D
04:56:12 <p21870> it's a shame i cant get it running under my linux since i have ati troubles
04:56:33 <dcoutts> p21870, use the open source divers, they worked fine for me
04:56:49 <p21870> 3d accelleration as well?
04:57:25 <dcoutts> mind you, I specifically bought an older generation of ATI card (9100) which is still fully supported by the open source dirvers
04:57:57 <p21870> ahhh i have an ati radeon 9700 pro :/
04:58:16 <dcoutts> worse is better :-)
04:58:21 <p21870> in this case :)
04:58:39 <p21870> would two vidcards in one pc cause troubles?
04:59:18 <dcoutts> I don't know, I expect you could get it to work (but the other would need to be PCI not AGP)
04:59:40 <p21870> hmm
04:59:49 <p21870> i'll just play it under windows then
04:59:55 <dcoutts> :-(
05:00:18 <p21870> i know
05:00:45 <p21870> games is basically the only thing i really need to do under windows
05:01:43 <mikael> I know someone who played Quake 3 in Linux with a Radeon 9600 Pro...
05:02:06 <mikael> ...and ET even uses the Quake 3 engine, I think, so that should work
05:02:55 <p21870> yeah, i've also read about people getting 3d accelleration under linux, but havent actually met them in person :D
05:03:30 <p21870> dcoutts, what is the link to the open source drivers you refer to btw. Maybe they are different from the ones i've tried
05:04:55 <dcoutts> p21870, it was just the standard radeon driver that comes with xorg
05:05:32 <dcoutts> but like I said, that doesn't support 3d acceleration for the newer ati cards
05:05:48 <dcoutts> only up to 9250
05:08:28 <p21870> ow
05:08:31 <p21870> :(
05:08:42 <det> I think Nvidia + non-free is the only option for non-legacy 3d hardware
05:10:14 <p21870> true
05:10:35 <det> My 6800 works great
05:10:46 <det> With AMD64 drivers even
05:10:46 <p21870> most nvidea's work great
05:11:05 <p21870> ati + drivers had always been a bit of an issue
05:11:33 <det> Here is something funny, my wireless card works under Linux with AMD64 drivers, but has no available Windows x64 drivers :-)
05:13:21 <p21870> :D
05:13:26 <p21870> that is what i call, sweet
05:13:48 <p21870> except if you're a windows disciple ofcourse
05:17:52 <wilx> Heh, disciple... :)
05:26:18 <gennet1> my gig eth has issues when running under amd64
05:26:32 <gennet1> but it's fine when i run under a 32 bit kernel like knoppix
05:26:34 <gennet1> weird
05:42:59 <kosmikus> p21870: iirc, lhs2TeX indentation is \mathindent, but check lhs2TeX.sty
05:44:30 <p21870> kosmikus, but is it normal for lhs2tex to do it by itself...
05:44:47 <p21870> im not doing anything special in my code blocks, but they appear indented
05:47:42 <gennet1> @find liftm2
05:47:48 <lambdabot> bzzt
05:47:55 <gennet1> @find liftM2
05:47:56 <p21870> @type Control.Monad.liftM2
05:47:56 <lambdabot> bzzt
05:47:57 <lambdabot> Control.Monad.liftM2 :: forall r (m :: * -> *) a2 a1.
05:47:57 <lambdabot>         (Monad m) =>
05:47:57 <lambdabot>         (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:48:03 <gennet1> cheers :D
05:48:09 <gennet1> what's the one to get it to find things?
05:48:19 <p21870> @index liftM2
05:48:20 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
05:48:20 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
05:48:20 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
05:48:28 <gennet1> that's the one
05:48:30 <gennet1> cheers again
05:48:35 <p21870> :)
05:48:51 <gennet1> @moo
05:48:52 <lambdabot>          (__)
05:48:52 <lambdabot>          (oo)
05:48:52 <lambdabot>   /-------\/
05:48:52 <lambdabot>  / |     ||
05:48:52 <lambdabot> *  ||----||
05:48:53 <lambdabot>    ~~    ~~
05:48:55 <lambdabot>      Cow
05:48:59 <gennet1> ;)
05:49:49 <p21870> ahhhh just for me?
05:50:01 <p21870> you shouldnt have
05:51:59 <dons> @bot
05:51:59 <lambdabot> :)
05:53:09 <p21870> @botulism
05:53:10 <lambdabot> Unknown command, try @listcommands.
05:53:59 <p21870> later
05:59:11 <wilx> @yow
05:59:12 <lambdabot> Let me do my TRIBUTE to FISHNET STOCKINGS ...
06:09:14 <dcoutts> @seen boegel
06:09:15 <lambdabot> I saw boegel leaving #haskell 2 hours, 58 minutes and 53 seconds ago.
06:32:59 <ski> @arr
06:32:59 <lambdabot> Smartly me lass
07:18:52 <Lor> Hm, Windows will have a "Monad Shell"? :)
07:20:21 <earthy> and it has nothing to do with functional programming
07:39:20 <wilx> o_O
07:41:50 <xerox> Back in black.
07:47:44 <sjanssen> man, I was hoping one of the Haskell hackers at Microsoft invented a kick ass new shell
07:53:37 <det> Why, did you hear them talking about piping with hash?
07:59:03 <sjanssen> det: I was referring to the slashdot post about the "Monad Shell"
07:59:31 <det> Yeah, I just saw that :-)
07:59:32 <det> My puns are wasted here.
08:01:55 <sjanssen> det: just got the joke.  I am quite naive
08:46:55 <Lemmih> Hey boegel.
08:46:58 <boegel> yo Lemmih
08:47:16 <boegel> Lemmih: I've been working on HaskLS this afternoon, and have made quite some progress
08:47:39 <boegel> I have a simple GUI which allows to set parameters, and also the branching stuff is working
08:48:42 <xerox> @wiki HaskLS
08:48:43 <lambdabot> http://www.haskell.org/hawiki/HaskLS
08:50:09 <dcoutts_> boegel, there is a Fedora rpm for the Gtk2Hs 0.9.8 release candidate available (thanks to juhp)
08:50:41 <dcoutts_> it's already in the Fedora Haskell repository so you should be able to just sync and upgrade
08:51:03 <dcoutts_> boegel, I've also changed the other link you asked me to do
08:52:28 <dcoutts_> JaffaCake, I've sent the prog.exe +RTS -H750m -M750m -Sstderr -RTS output to you, let me know if you want anything else
08:52:43 <JaffaCake> ok, ta
08:54:48 <boegel> dcoutts: thanks :)
08:55:07 <dcoutts_> juhp, thanks :-)
08:55:07 <boegel> dcoutts_: no HOpenGL support yet though ?
08:55:13 <dcoutts_> boegel, chill!
08:55:16 <boegel> yeah juhp, thank you :)
08:55:36 <boegel> dcoutts_: heh :) we'll, I've solved it for now... I created a GUI which summons a HOpenGL window when you click a button
08:56:04 <dcoutts_> right, sounds like a good intrim solution
08:56:28 <TFKv3> Is GTK+hs alive?
08:56:34 <dcoutts_> TFKv3, not really
08:56:50 <dcoutts_> TFKv3, but Gtk2Hs is :-)
08:57:20 <TFK> oooh!
08:58:00 <boegel> TFK: you should check out the TMR article on Gtk2Hs
08:58:16 <dcoutts_> The only feature Gtk+HS still has that Gtk2Hs doesn't is OpenGL support, but that will be along soon (boegel will keep bugging me until it's there! :-)
08:58:30 <TFK> I recall reading some of it, but wasn't sure which binding they were talking about.
08:58:34 <TFK> Cool, then :-)
08:58:41 * TFK will reread said article
08:59:18 <boegel> TFK: I think it's clearly stated the article uses Gtk2Hs, I know the guy who wrote it ;)
08:59:41 <TFK> It may be clearly stated there, but it wasn't so clearly stated in my head :-/
08:59:56 <boegel> TFK :)
09:00:12 <dcoutts_> Gtk2Hs supports Gtk+ 2.x, Gtk+Hs supports Gtk+ 1.2.x, Gtk2Hs has nearly complete API coverage, Gtk+Hs has patchy API coverage, Gtk2Hs has automatic memory management... etc. It's along list :-)
09:00:36 <TFK> Yeah, I got the picture ;-)
09:01:00 <boegel> dcoutts_: you seem to like Gtk2Hs quite a lot ? why's that ? :p :p
09:01:15 <dcoutts_> is it because it is great?
09:01:23 <TFK> It is as portable as GTK itself, right? I.e., it will work on , say, win32 with libglade and the works?
09:01:24 <boegel> maybe
09:01:41 <boegel> TFK: sure, check the HRay screenshots on the Gtk2Hs website
09:01:42 <dcoutts_> TFK, yes
09:01:50 <TFK> I am looking at them.
09:01:54 <boegel> heh ;)
09:02:03 <boegel> I also know the guy who wrote that :)
09:02:09 <dcoutts_> and we're brewing a win32 installer too to make your life even easier :-)
09:02:11 * boegel knows lots of people
09:02:34 <TFK> Tha would be great! :-D
09:02:37 <TFK> *That
09:03:07 <dcoutts_> We have an experimental win32 installer for 0.9.7.1 and the 0.9.8 final release will come with a win32 installer
09:03:18 <boegel> @plugs read "22.5"
09:03:23 <lambdabot> Ambiguous type variable `a' in these top-level constraints
09:03:32 <boegel> @plugs (read "22.5" :: Double)
09:03:34 <lambdabot> 22.5
09:03:36 <boegel> nice
09:03:49 <xerox> Why the parens? :)
09:04:05 <dcoutts_> @plugs read "22.5" :: Double
09:04:06 <lambdabot> 22.5
09:04:06 <vegai> why is it called "plugs"?
09:04:28 <xerox> vegai, because it works like plugs :)
09:04:35 <dcoutts_> vegai, I think it's because it works by using the hs-plugins stuff
09:04:42 <vegai> mmkay
09:05:14 <xerox> PLugin User's GHCi System, for Haskell 98
09:05:14 <xerox> http://www.cse.unsw.edu.au/~dons/hs-plugins
09:05:14 <xerox> Type :? for help
09:05:14 <xerox> Loading package base ... linking ... done
09:05:14 <xerox> plugs>
09:12:27 * boegel leaves for dinner
09:34:10 <Lemmih> SyntaxNinja: I got a Cabal patch for you.
09:40:07 <SyntaxNinja> Lemmih: send it along
09:41:47 <boegel> Lemmih: I've updated the darcs repo, if you want to test it you should have Gtk2Hs installed though...
09:42:52 <Lemmih> SyntaxNinja: Did I mail you the --with-greencard patch?
09:43:10 <Lemmih> boegel: Oki. Will check it out soon.
09:43:28 <dcoutts_> Lemmih, you can try out the Gtk2Hs 0.9.8 release candidate :-)
09:45:11 * TFK ponders about an IDE in Gtk2Hs
09:46:01 <Lemmih> SyntaxNinja: Sent.
09:46:34 <dcoutts_> TFK, that would be great. There was hIDE which used Gtk+Hs, that's no longer being developed. I started to develop hIDE version 2 with the original author using Gtk2Hs but got diverted into developing Gtk2Hs itself.
09:47:06 <SyntaxNinja> Lemmih: don't think so.
09:47:09 <SyntaxNinja> Lemmih: thanks for sendin git.
09:47:53 <dcoutts_> The recent IDE project that some Haskell people round here have been working on could be given a Gtk2Hs GUI (indeed one of the authors was asking me questions and exploring the idea)
09:48:23 <SyntaxNinja> has anyone ever had a paper in, or attended Trends in FP?
09:48:25 <TFK> You men Yi?
09:48:43 <dcoutts_> I was thinking that one based on Gtk2Hs and hs-plugins and Yi would be cool
09:49:11 <dcoutts_> TFK, no, Yi might get a GUI too but this was another thing (I'm trying to remember the name)
09:49:19 <Lemmih> Haste?
09:49:33 <dcoutts_> @google Haste Haskell IDE
09:49:34 <lambdabot> http://haste.dyndns.org:8080/
09:49:35 <TFK> That's wx-based, though.
09:50:08 <dcoutts_> TFK, yes it's currently wx based. One of the authors was looking into the feasability/desirability of changing
09:50:33 <TFK> So there's no shortage of manpower on the IDE front, then?
09:50:44 <dcoutts_> TFK, actually I think there is.
09:51:21 <SyntaxNinja> there's actually an eclipse plugin in the works, but I never hear anything abut it.
09:51:28 <dcoutts_> TFK, Haste was a school project, it's not clear how much development it'll get now. It would be good if it does.
09:51:50 <TFK> I have that one, although I didn't test it thoroughly yet.
09:52:32 <TFK> Eclipse doesn't speak to me, I suppose.
09:52:36 <dcoutts_> And now's the time to develop a Haskell IDE, since ghc is getting various features to support them (the motivation for that is the MS VS Haskell plugin)
09:53:11 * TFK nods
09:53:35 <dcoutts_> TFK, well if you want to start an IDE project using Gtk (or pick up hIDE) I'll certainly lend advice and bits of code
09:54:05 <dcoutts_> I've got various ideas but not enought time to implement them :-(
09:54:53 <TFK> I was thinking about that, but there are yet many (basic) things to learn about Haskell.
09:55:02 <dcoutts_> I originally did the GtkSourceView bindings because I wanted it for a Haskell source code editor in hIDE.
09:55:43 <dcoutts_> GtkSourceView is what GEdit now uses (and it now has Haskell syntax highliting)
09:56:06 <TFK> But not indentation, IIRC.
09:56:17 <ndm> I am working on getting WinHugs back up to scratch
09:56:30 <ndm> and once I've done that, I intend to do closer editor integration
09:56:50 <ndm> so the user can use Emacs/Vi/Textpad along with WinHugs to have a sort of IDE
09:56:54 <TFK> At any case, the next big step for me will be to write that lambdabot plugin for hbin :-)
09:57:01 <dcoutts_> TFK, no, that'll require a bit of extra code. Of course it might be that Yi with a Gtk GUI is the way forward rather than GtkSourceView.
09:57:14 <TFK> ndm, I did that combo with TextPad for a while, but it seems quite cumbersome.
09:58:17 <dcoutts_> ndm, the origianl idea for hIDE was to allow you to use any editor. I'm not qute sure how good an idea that is however. It makes integration of various features rather hard.
09:58:28 <TFK> dcoutts, that means I'll have to build Yi on windows, then :-P
09:58:30 <ndm> TFK, if the errors jumped you straight at the correct line, it might work
09:58:47 <TFK> It's not just about the errors, as dcoutts noted.
09:58:54 <dcoutts_> TFK, yes, we'd want Yi on win32
09:58:56 <ndm> yes, I realise that
09:58:57 <TFK> You want all kinds of nifty things.
09:59:09 <ndm> but hopefully you can do most things
09:59:12 <TFK> dcoutts, is that to say that no one has successfully built it before?
09:59:22 <dcoutts_> TFK, jump to definition/documentation is the killer feature as far as I'm concerned
09:59:37 <dcoutts_> TFK, I don't know, ask dons
10:00:06 <TFK> A code browser is definatelly a must.
10:00:15 <dcoutts_> Gtk2Hs itself works fine on win32, including native themeing and glade support
10:00:56 <ndm> what do you mean by code browser?
10:01:09 <dcoutts_> TFK, but the code browser really has to be integrated into the editor so you can just move the cursor over a function name and hit a key combo or right click and select a popup menu item
10:01:19 * TFK covertly signs himself for gtk2hs users ml :3
10:01:25 <dcoutts_> :-)
10:01:36 <TFK> That's the idea, yes ;-)
10:02:41 <TFK> ndm, well, you have a list of modules/functions/etc., you click on the names and it transports you to their definition.
10:02:42 * boegel leaves for a while
10:03:00 <dcoutts_> TFK, maybe we can rope dons and some of the Haste developers into embeding/extending Yi into a full IDE :-)
10:03:27 <ndm> i think that can be done with hugs/textpad- but obviously with less convenience
10:03:58 <ndm> i also know of a project to write an LXR for Haskell (lxr.mozilla.org), which gives the same thing in a read only style
10:04:12 <dcoutts_> extensible with hs-plugins so all the little Haskell tools can be integrated and so you can distribute development the way you can with lambdabot
10:04:30 <TFK> ndm, yup. Ultimately, you'd want things like dynamic document generation, the IDE showing you the function signature on the fly (calltips?), and all that jazz.
10:04:52 <ndm> would document generation not be handled by haddock?
10:05:08 <ndm> calltips would be incredibly useful!
10:05:10 <TFK> Perhaps, but you want it all to be glued together.
10:05:19 <ndm> i think emacs haskell mode already has that
10:05:29 <dcoutts_> TFK, this is where the GHC integration comes in, the .hi files will give you lots of info and the new GHC package which exposes much of the compiler internals will give you even more info
10:05:51 <TFK> It sounds like the time has come, then ;-)
10:06:01 <dcoutts_> world domination...
10:06:22 <TFK> ...and free milk and cookies!
10:09:41 <dcoutts_> dons, how's Yi development going? I recall I had problems building last time. Is it time for me to try again?
10:25:23 <Lemmih> Yay. I got TH with zero runtime overhead! Finally it can be used for FFI code generation.
10:25:41 <dcoutts_> Lemmih, what's the trick?
10:26:31 <Lemmih> I got a preprocessor which takes the TH code out of a file, evaluates it and puts it back in.
10:28:54 <Lemmih> It was quite easy to hack with haskell-src-exts.
10:32:57 <Lemmih> Bummer. haskell-src-exts doesn't support the FFI extension /-:
10:33:09 <dcoutts_> :-(
10:33:26 <Lemmih> nibro_afk: Get back here! (:
10:37:08 <boegel> Lemmih: I've posted some pics of my new HaskLS program on my website... trees !
10:37:20 <dcoutts_> boegel, URL?
10:37:35 <boegel> http://scannedinavian.org/~boegel -> clickety click
10:37:47 <Lemmih> boegel: Woot.
10:38:09 <boegel> looks nice eh :)
10:38:14 <boegel> seeing it rotate is even cooler
10:39:10 <dcoutts_> that's very cool
10:39:49 <dcoutts_> "Coming up: visualisation using HOpenGL on a Gtk2Hs canvas, not in a seperate window"
10:39:58 <dcoutts_> I'd better get moving then... :-)
10:41:29 <boegel> hehe :)
10:41:40 <boegel> that's so I won't forget what I can do :)
10:42:00 <boegel> the problem is now, when I close the HOpenGL windows, the whole program quits
10:42:25 <dcoutts_> is that because it crashes or just an oddity of the way it works?
10:43:02 <boegel> just an oddity
10:43:10 <dcoutts_> right
10:43:15 <boegel> it has something todo with the way HOpenGL treats a closing window
10:43:48 <boegel> I'll have to figure that out, but there are some more things like that... adjusting the parameters yields another tree (or something else), but then
10:43:53 <dcoutts_> I was wondering, because apparently some OpenGL implementations don't handle cleaning up resources very well
10:44:17 <boegel> (continue) then it might now be centered and stuff
10:44:36 <dcoutts_> in some OpenGL implementations the app must release every GL resource or it can lave the system in an odd state.
10:44:56 <boegel> hmm, kay
10:45:08 <boegel> you think HOpenGL does it the right way ?
10:45:32 <dcoutts_> so it's something I need to consider in doing the GtkGlExt bindings, because they do allocate GL resources
10:45:41 <shapr> @yow !
10:45:42 <lambdabot> I joined scientology at a garage sale!!
10:45:49 <boegel> shapr: yow !
10:45:51 <SyntaxNinja> do you ever do a web search for something, only to find that your own web pages and posts are the only links, and that's because you misspelled the thing every time you wrote about it, and when you did the search?
10:45:58 <shapr> boegel: h0w n0w br0wn y0w!
10:46:17 <boegel> shapr: check out how I'm using the webspace you provided me with (especially the HaskLS part)
10:46:27 <shapr> SyntaxNinja: No, but I do web searches that only turn up my web pages because I use really weird words for common concepts, does that help any?
10:46:37 <shapr> boegel: I noticed, good use of webspace!
10:46:39 <TFK> shapr!
10:46:44 <shapr> TFK!
10:46:51 <TFK> :-)
10:47:03 <shapr> SyntaxNinja: At least you *know* the right word even if you can't spell it...
10:47:35 <shapr> Oh hey, I'm actually here to ask about Cabal. I'm trying to install postmaster, and it has Extra-libs: adns in the cabal file.
10:47:50 <shapr> I think that means it wants -ladns, but cabal doesn't seem to that line.
10:48:22 <shapr> boegel: Oh, I like the new trees. Have you seen CFDG?
10:48:44 <boegel> shapr: nope :)
10:48:52 <shapr> http://lambda-the-ultimate.org/node/view/732
10:49:28 <shapr> Man, I'm melting. I just went unicycling in 20∞ weather! How will I survive?
10:50:18 <Lunar^> shapr: take a shower
10:50:30 <shapr> Yeah, but I can't do that while unicycling.
10:50:40 <Lunar^> hehe :)
10:50:50 <Lunar^> underwater unicycling :)
10:50:54 <shapr> Oh, good idea
10:50:56 <boegel> shapr: looks cool :) but he doesn't even mentioned L-systems, although it's clearly based upon that concept
10:51:26 <boegel> oh wait, the mention it in the comments
10:51:27 <dcoutts_> shapr, ever played unicylce hockey?
10:52:10 <shapr> dcoutts_: Nah, but I want to try it.
10:52:22 <musasabi> "Extra-Libs: foo" => "-lfoo" worked at least in older versions of Cabal.
10:52:29 <shapr> dcoutts_: hey, did I tell you about my new ultimate arctic municycle I'm building?
10:52:30 * SamB thought that sounded cold, until he realized it was ¬∞C and not ¬∞F...
10:52:48 <dcoutts_> shapr, it's extreemly good fun, but rather hard to get enough people together to make decent sized teams
10:53:27 <shapr> The swedish unicycle convention is happening in a few days, but I've decided to skip and lie in the sun instead.
10:54:15 <boegel> shapr: heh
10:54:41 <shapr> dcoutts_: I'm building a unicycle nearly identical to these pix - http://www.scannedinavian.com/2005-05-16.html
10:55:47 <shapr> It won't compete with your Coker for speed, but it'll be great for snow, sand, mud, etc
10:56:03 <dcoutts_> shapr, looks nice. I see it has brakes!
10:56:26 <dcoutts_> playing unicycle hocky on a coker is rather tricky. I'll use my smaller one next time...
10:56:38 <shapr> dcoutts_: btw, do you carry your Coker on the bus? I can barely fit my KH24 between me and the seat in front of me...
10:56:50 <shapr> Yeah, but once you get moving *nobody* can catch you.
10:57:03 <dcoutts_> bus! the very idea. When you've got a coker, you don't need the bus. :-)
10:57:12 <shapr> Hah! Of course! I hadn't thought of that.
10:57:17 <SyntaxNinja> hi shapr
10:57:32 <shapr> y0 SyntaxNinja! Has Extra-libs: disapparated from Cabal?
10:57:43 <dcoutts_> shapr, I do take it up in the lift with me to my office, which is a little tight
10:58:09 <Heffalump> hey SyntaxNinja, you in the mood for more Cabal questions? :-)
10:58:19 <shapr> dcoutts_: oh hey, I had a brilliant (literally) idea... have you seen the electroluminescent wire that's for sale nowaday?
10:58:22 <SyntaxNinja> shapr: don't think so, might be called something else. do the docs say?
10:58:25 <SyntaxNinja> Heffalump: sure.
10:58:51 <SyntaxNinja> "extra-libraries"
10:58:51 <Heffalump> I have a preprocessor of my own that makes .hsc files. Can I persuade cabal to layer them using Distribution.Simple?
10:59:26 <SyntaxNinja> to call your preprocessor, then call hsc2hs or whatever, you mean?
10:59:29 <Heffalump> yep
10:59:33 <shapr> dcoutts_: I'm thinking, wrap the EL wire around the spokes, attach it to a coil of copper wire stuck to the rim, and put powerful magnets on the brake mounts of the uni, inductively powering the EL wire whenever it passes the brake mounts.
10:59:40 <Heffalump> cos right now it just calls my preprocessor asking it to make a .hs file
11:00:07 <SyntaxNinja> Heffalump: unfortunitely, no, not yet.  I'd welcome such a patch, but not sure what it should look like.
11:00:11 <shapr> I think that is the absolute embodiment of the taste standards required to put bright blue lights under your car.
11:00:24 <musasabi> shapr: If you have time could you tell me more about secret joy? (maybe in email)
11:00:27 * Lunar^ reads autrijus' paper
11:00:50 <shapr> musasabi: Sure, I suspect you're interested in the language rather than the unicycle, right? ;-)
11:00:52 <SyntaxNinja> Heffalump: you could always do something in the preBuild step, though.
11:01:05 <Heffalump> next, how do I cope with having a .c file that is generated during build?
11:01:25 <musasabi> yep :-)
11:02:55 <SyntaxNinja> Heffalump: what do you mean?
11:02:56 <shapr> musasabi: The concept behind Secret Joy is very simple, but I'm not totally convinced it'll work. Motivation: I love Haskell, but Lisp and Scheme have better syntax for metaprogramming. Idea: Because Joy is purely concatenative, it has much better support for metaprogramming, especially call-by-need metaprogramming.
11:02:58 <SyntaxNinja> "cope with"?
11:03:45 <Heffalump> SyntaxNinja: how do I tell Cabal about it and how to generate it?
11:03:53 <Heffalump> or do I just generate it myself in pre-build?
11:04:59 <SyntaxNinja> Heffalump: depends; how is it generated?
11:05:02 <dcoutts_> shapr, you mean you'd have an electricly assisted unicycle? or an electricly braked one
11:05:07 <Heffalump> by invoking perl
11:05:12 <shapr> Joy's syntax has all the regularity of Scheme and Lisp. But, I suspect the syntax/semantics mean that a non-strict, optimistic flavor of Joy would lend itself to metaprogramming with much higher 'granularity' than lisp or scheme allows.
11:05:31 <SyntaxNinja> Heffalump: unless it's pretty standard, then you gotta do it in pre-build, then if you want to link it in or whatever ,look at the c-sources field
11:05:34 <shapr> musasabi: What do you think? Is this absolute rubbish, or maybe interesting?
11:05:46 <Heffalump> ok, ta.
11:05:50 <SyntaxNinja> Heffalump: np
11:06:40 <musasabi> shapr: it sounds quite nice, but I haven't read much about the joy quotations.
11:07:03 <musasabi> shapr: so basically you are extending joy with a sort of metaprogramming facility?
11:08:14 <shapr> Joy already has some very basic metaprogramming, but it's strict and eager. Secret Joy would be about making something like Template Haskell work on a c-b-n basis for very small pieces.
11:08:24 <shapr> I'm still not sure I'm describing it well.
11:09:52 <shapr> I like the lazy fib list that generates itself, "fib = 0 : 1 : zipWith (+) fib (tail fib)" and I'd like to have that same sort of granularity for Template Haskell. I think a non-strict flavor of Joy could do that.
11:09:59 * boegel is bored again
11:10:00 <musasabi> isn't template haskell eager (as it is executed at compile time) or then I am misunderstanding the terminology...
11:10:45 <shapr> Yeah, Template Haskell is definitely not cbn.
11:12:41 <shapr> Joy easily allows hygienic macros, since you don't have names anyway.
11:13:29 <shapr> musasabi: What do you think? Possibly interesting? Or seen it all before?
11:15:39 <shapr> I think the interesting idea behind Secret Joy would be integrating call-by-need into Template Haskell.
11:15:42 <musasabi> shapr: Possibly very interesting, but I have some doubts on the readablity of postfix notation programs (reading forth written by other people is very hard), but the idea seems very nice :-)
11:16:05 <shapr> Spiffy :-)
11:17:24 <shapr> Yeah, Joy can be hard to read. But I hear both sides of that from Lispers too. (Parens are great!) {Parens suck!}
11:18:27 <shapr> hiya cona1
11:18:52 <cona1> hey shapr.  how goes?
11:19:03 <shapr> Code is good, how's your code?
11:19:30 <cona1> it's getting somewhere.
11:19:30 <musasabi> How is joy typed?
11:19:49 <cona1> standard keyboard, i think
11:20:12 <shapr> Hah! Joy isn't typed so far. Greg Bucholz (sleepingsquirrel) has done the most towards a typed Joy implementation in Haskell.
11:21:02 <cona1> hey, i don't know why i'm "cona1" instead of "conal" here.
11:21:34 <cona1> irc is still mysterious to me
11:21:37 <shapr> There are a several possible approaches to a typed Joy, you could cheese it with an ugly Stack -> Stack type, or go deeper with StackItem -> StackItem -> StackItem. There's probably a better approach.
11:21:42 <shapr> cona1: try /nick conal
11:21:47 <Lemmih> cona1: You're probably using Gaim.
11:21:51 <musasabi> *Can* joy be statically typed or does it reduce to dynamic typing? (or "are finite lists just tuples in disguise")
11:21:56 <cona1> right -- gaim.
11:22:25 <cona1> is "/nick" per session or permanent?
11:22:31 <shapr> per session
11:22:40 <shapr> I don't know gaim, I use emacs for my irc client.
11:23:10 <cona1> lemmih, how'd you know (gaim)?  is there a gaim solution, rather than per-session /nick-ing?
11:23:22 <musasabi> [ 'a' 1 3.5 ], could be <Char, <Int, <Float, Nil>>>.
11:23:26 <shapr> I *think* Joy can be statically typed. But a lot of the 'standard' Joy doesn't appeal to me, that's why I want to make my own dialect of Joy.
11:24:16 <musasabi> I have to read the papers on the joy site..
11:24:26 <Lemmih> cona1: Gaim replaces the last character in your nick with a number if the requested nick is already in use.
11:24:48 <shapr> It seems that the person using the nick conal is actually Conal Elliot.
11:24:55 <shapr> cona1: are you an impostor?
11:25:04 <cona1> oh, thanks.  does that mean i'm somehow on twice??
11:25:06 <musasabi> => away
11:25:15 <Heffalump>  conal ~Conal@user-0c2iadr.cable.earthlink.net
11:25:16 <shapr> Yes, it likely means you're on twice somehow.
11:25:16 <cona1> shapr, i hope not!
11:25:19 <shapr> haha
11:25:21 <Heffalump> cona1 ~Conal@dsl231-049-008.sea1.dsl.speakeasy.net
11:25:25 <Heffalump> so yes.
11:25:31 <Heffalump> assuming that earthlink thing is also you
11:25:56 <cona1> hmm.  i moved from home to a wifi cafe.
11:26:03 <Heffalump> hi, btw (I'm Ganesh Sittampalam, we know each other through Oege)
11:26:20 <cona1> but in my room members list, i see only 'cona1' and not 'conal'.
11:26:23 <shapr> hej andersca, ltns! wazzup?
11:26:24 <cona1> hi ganesh!
11:26:24 <Heffalump> you'll have problems persuading that client to go away, then
11:26:35 <andersca> hejhej!
11:26:41 <Heffalump> conal is probably connected to the server but not to the channel
11:26:48 <shapr> cona1: If you've registered your nickname with nickserv, you can kick that client from there.
11:26:56 <shapr> andersca: How's code treating you?
11:27:22 <andersca> shapr: good good
11:27:25 <andersca> shapr: do you know about the nokia 770?
11:27:48 <cona1> shapr, "kick that client"?
11:29:03 <SyntaxNinja> Heffalump: _YOU_ are Ganesh!??!
11:29:05 <SyntaxNinja> ;)
11:29:20 <Heffalump> :-p
11:29:33 * Heffalump wonders who SyntaxNinja is
11:30:06 <Heffalump> oh, anyone going to PLDI?
11:31:43 <andersca> shapr: http://www.nokia.com/nokia/0,1522,,00.html?orig=/770
11:32:08 <shapr> cona1: A program connected to an irc server is usually called an irc client. You can use nickserv to force your other running copy of gaim to disconnect from IRC.
11:32:24 <shapr> andersca: Yeah, it looks cool. But it's not available till Q4, right? Otherwise I'd buy one now.
11:32:43 <andersca> shapr: I've been involved in the development of it for about three years
11:33:06 <shapr> I'm looking at the HP TC1100 instead, since the 770 won't be available.
11:33:08 <shapr> andersca: cool!
11:33:35 <vegai> andersca: really?
11:33:42 <shapr> andersca: what do you think about Nokia's 'gift' of patents to the Linux Kernel?
11:33:56 <vegai> andersca: I've been for 7 months :)
11:34:04 <andersca> vegai: oh, cool
11:34:08 <andersca> vegai: you work for movial?
11:34:24 <vegai> nope
11:34:27 <Heffalump> andersca: you work for nokia?
11:34:27 <shapr> And liw left the project because he disagrees with Nokia's pro-patent stance...
11:34:39 <andersca> vegai: nokia?
11:35:01 <vegai> Nomovok
11:35:04 <cona1> shapr, thanks for the explanation.  and how do i get to nickserv?
11:35:08 <andersca> vegai: ah
11:35:11 <andersca> vegai: I'm an imendian...
11:35:25 <Heffalump> cona1: if you don't know how to get to nickserv, you won't be registered with it, so shapr's suggestion won't help you now.
11:35:32 <vegai> this thing has been quite spread out, it seems..
11:35:33 <Heffalump> I suggest you just live with it until you get home, then register.
11:35:34 <shapr> cona1: You can talk to nickserv by sending it a private, "/msg nickserv help" in a standard client.
11:35:37 <andersca> vegai: yep
11:36:38 <shapr> cona1: NickServ allows you to add a password to a nickname so that nickname will be reserved for you (or whoever has the password).
11:36:52 <cona1> shapr, thanks.  the funny thing is that i'm using the same machine here as at home.  and only one gaim process running.
11:37:04 <shapr> cona1: Most irc clients have some scriptability (I'm not sure about gaim) so that the password can be sent automatically when you connect to the irc server.
11:37:27 <shapr> Huh, that's odd.
11:37:32 <cona1> i'm guessing a restart will clear up.  and i will reserve my nickname and set a password.  gaim does have that field.
11:37:42 <cona1> yeah odd.  probably just a fluke.
11:37:53 <cona1> i won't worry about it, but i will learn about nickserv
11:38:04 <SyntaxNinja> sometimes it takes some time after the process dies for the nick to disconnect
11:38:42 <Heffalump> your other client is connected via your home ISP, so restarting your laptop now can't help
11:38:54 <Heffalump> probably it'll time itself out after a while
11:41:50 <cona1> btw, i've been wondering, when i see something like "***Heffalump wonders who SyntaxNinja is", what did heffalump type?
11:42:01 <shapr> he typed /me does something
11:42:04 * shapr does something
11:42:16 * cona1 like this?
11:42:18 <cona1> oh!
11:42:18 <shapr> yes
11:42:37 <SamB> no, you should have typed "/me tries it too"
11:42:37 <cona1> is there an online doc that spells out stuff like this?
11:42:52 * cona1 now gets it!
11:43:00 <SamB> yes, yes, exactly!
11:43:06 <shapr> Hm, you can check the docs on www.freenode.net maybe.
11:43:14 <shapr> You've got most of it at this point.
11:43:34 <lispy> cona1: another handy trick is /whois <nick>
11:43:43 <lispy> you can find out info about someone thta way
11:43:44 <shapr> The only command categories left are topic commands, channel modes, and user modes.
11:44:35 <lispy> cona1: and you probably know about /msg right?
11:45:02 <integral> try www.irchelp.org
11:45:11 <dcoutts_> boegel, it'd be cool to do a 2D version of an L-system or the CFDG thing to show off the cairo graphics system
11:45:31 <cona1> lispy, no, not even that.
11:46:31 <lispy> cona1: you can have private conversations using /msg <nick> and then the person should reply using /msg.  Most irc clients can automate it from there by pretending to create a channel which only has the two people in it
11:47:14 <Heffalump> what kind of hardware does the Nokia 770 have?
11:47:56 <conal> thanks for all the pointers.  i'll read up more.
11:48:06 <dcoutts_> welcome conal, we were talking about some of your work the other day, the Vertigo+shaders stuff (I'm another one of Oege's students BTW)
11:48:15 <conal> and yeah the nokia 770 looks very cool
11:48:40 <lispy> conal: good luck.  irc is really simple once you understand about 4 commands
11:48:46 <conal> dcoutts_, thanks for the welcome.  glad to hear about the interest.
11:49:19 <tic> Has anyone seen any Monad Shell (MSH) scripts?
11:49:28 <dcoutts_> we were pondering a linux port using the OpenGL shader language which presumably is very similar to the DX9 one
11:50:01 <conal> good.  last i looked, it's very similar indeed.
11:50:06 <shapr> conal: oh, speaking of nifty graphics, have you seen CFDG? - http://chriscoyne.com/cfdg/ and http://lambda-the-ultimate.org/node/view/732
11:50:29 <conal> shapr, yeah i saw it.  lovely pictures & ugly language.
11:50:37 <conal> begs a pretty haskell version
11:50:45 <shapr> boegel is working on something like that.
11:50:52 <shapr> HaskLs
11:51:07 <shapr> For L-systems unsurprisingly.
11:51:21 <conal> good ;)
11:51:25 <dcoutts_> boegel is doing a 3D L system which is not quite the same as the CFDG once which uses different primitive shapes
11:51:42 <shapr> I can barely wait for washable e-ink, animated CFDG t-shirt will be extremely cool.
11:52:15 <lispy> "washable e-ink" hmm...
11:52:20 <dcoutts_> a Haskell port of CFDG using hscairo would be nice
11:52:31 <conal> dcoutts_ (or boegel), anything written down?
11:52:45 <shapr> http://www.haskell.org/hawiki/HaskLS
11:53:59 <dcoutts_> conal, are you aware of cairo? (the graphics API not Cairo the city)
11:54:31 <dcoutts_> if so, I was wondering what your opinion of it is.
11:54:52 <conal> no, i hadn't heard of it before.
11:55:13 <dcoutts_> @google cairo graphics
11:55:14 <lambdabot> http://cairographics.org/
11:55:33 <dcoutts_> it's a new vector graphics API being developed
11:55:40 <lispy> conal: any idea what sort of performance PAN would have if it used haskell opengl bindings instead of generating C code?
11:56:34 <dcoutts_> It's api is inspired by the PS/PDF model. It has backends for X11, static images, SVG, PS, PDF.
11:56:35 <ndm> cairo is also becoming the graphics engine behind mozilla and GTK, so its getting quite popular
11:56:53 <dcoutts_> there is a Haskell interface to it
11:56:54 <conal> dcoutts_: does it do booleans on shapes?
11:57:17 <dcoutts_> not sure, I'd have to look at the docs carefully
11:57:27 <dcoutts_> it has various compositing operators
11:57:51 <conal> i worked on interlace designs for a while in java and used booleans.  not sure where i want to go with that work.  http://conal.net/Interlace
11:58:04 <conal> compositing is pretty different.
11:58:36 <conal> lispy:  pan doesn't make any graphics calls.  and is not at all a vector graphics approach.
11:59:08 <conal> it could certainly run as a haskell library on top of a setPixel op.
11:59:13 <conal> and probably be super slow.
11:59:22 <lispy> okay, that's what i was wondering about
11:59:36 <conal> but i'm pursuing a new version of pan that's more integrated with ghc.
11:59:56 <lispy> conal: this is the linux version?
12:00:02 <lispy> (or will support linux)
12:00:10 <conal> definitely
12:00:17 <conal> no more windows-specific
12:00:20 <conal> which i regretted
12:00:23 <dcoutts_> there is a reimplementation of PAN that uses Haskell & Template Haskell and gets reasonable performance, but not as good as the original
12:00:46 <conal> two of them, i think.
12:01:37 <dcoutts_> http://www.cse.unsw.edu.au/~sseefried/pantheon.html
12:01:58 <conal> sean (panTHeon) is interested in collaborating on this new version.  he and [name escapes me] at oxford both tried TH and ran into real problems
12:02:04 <lispy> conal: you must have a linux dev machine at home?
12:02:09 <conal> with missing type info needed in rewriting
12:02:14 <conal> no i sure don't
12:02:29 <lispy> ah, that's too bad :(
12:02:51 <dcoutts_> conal, the Oxford guy is Ian Lynagh, irc nick Igloo
12:03:11 <conal> thanks for the reminder!
12:03:20 <conal> i chatted with ian at oxford a while back
12:03:20 <lispy> ah, i know that name from the darcs list
12:03:30 <conal> seems sean ran into the same problem
12:03:32 <dcoutts_> Igloo is often on this channel
12:03:49 <shapr> sean is seafood
12:04:16 <conal> oh, good, i was wondering.  i need a cheat sheet!
12:04:27 <dcoutts_> :-)
12:04:33 <conal> once saw the wiki page with nicknames, but sparse
12:05:29 <lispy> are people excited about the summer of code?
12:05:44 <shapr> Let's see... JaffaCake is Simon Marlow. SyntaxNinja is Isaac Jones, um, probably 50% of the people here have posted to the Haskell mailing lists at some point, but it's a very long list.
12:06:06 <shapr> Any people you're particularly interested in talking to?
12:06:36 <conal> sean is one.  we've been emailing.
12:06:40 <conal> oops!  gotta run.
12:06:44 <shapr> kosmikus is Andres L√∂h, earthy is Arthur van Leeuwen...
12:06:52 <shapr> cya!
12:07:03 <conal> thanks for the chats, all.
12:07:06 <lispy> it's so easy to get sucked into irc ;)
12:07:12 <dcoutts_> bye conal
12:08:12 <shapr> There are many interesting people on #haskell.
12:08:18 <lispy> yeah
12:08:19 * CosmicRay looks in
12:08:34 <lispy> freenode is a very nice irc server
12:08:39 <shapr> For example, the president of Debian's parent organization is on #haskell.
12:08:49 <lispy> parent organization?
12:08:54 <lispy> who is that?
12:08:55 <shapr> There's at least one kernel hacker on #haskell.
12:08:59 * CosmicRay blends into the background
12:09:05 * Igloo thinks that's a dubious characterisation of SPI
12:09:07 <CosmicRay> shapr: who's that?
12:09:25 <Lunar^> conal: Hi! :)
12:10:17 <Lunar^> conal: I went to a day of french talks about reactive and synchronous programming yesterday
12:10:18 <lispy> open office has gotten much better
12:10:39 <shapr> Lunar^: oh cool!
12:10:46 <CosmicRay> I'd be happer if it: 1) defaulted with all the annoying "helpful" things off, and 2) worked on a vt100 :-)
12:10:53 <CosmicRay> s/happer/happier/, of course
12:10:55 <shapr> Lucid, Synchrone, what?
12:10:56 <Lunar^> shapr: It was interesting
12:11:07 <Lunar^> shapr: Lustre, ReactiveML and SugarCubes
12:11:20 <Lunar^> shapr: and what you've said
12:11:37 <shapr> Have you read about the project Peter Gammie was working on?
12:12:08 <Lunar^> shapr: Lucid Synchrone V3 will have an intersting type system, analyzing both clocks and types together
12:12:12 <shapr> He wanted to use arrows to do something like Lustre on top of Haskell.
12:12:19 <shapr> I have the source handy...
12:12:20 <Lunar^> shapr: interesting! :)
12:12:47 <shapr> I'm interested in using dataflow and type systems for hardware analysis.
12:13:05 <shapr> I wish I could figure out this shape typing problem, I think it would be useful for chip layout.
12:13:06 <Lunar^> shapr: That was definitely the topic :)
12:13:35 <CosmicRay> are there any computer algebra systems written in haskell?
12:13:41 <CosmicRay> anything even remotely physics-related?
12:14:18 <shapr> CosmicRay: DoCon exists, as for physics, I only know of Pseudonym's physical constants code.
12:14:55 <CosmicRay> interesting
12:14:56 <shapr> Lunar^: Do you know if the Xilinx and othe FPGA toolchains put out a netlist as their final component? Basically, can I generate a netlist and get it onto an FPGA with pure open source tools?
12:16:05 <shapr> Lunar^: Also, do you know the name of the chips that are between FPGAs and ASICs? There's something that requires the 'netlist' to be sent each cycle along with the 'code'
12:16:26 <Lunar^> shapr: I'm very novice in that field, sorry
12:16:45 <Lunar^> shapr: It's more a background interest than something I really know about
12:16:46 <shapr> I'd like to play with FPGAs, but I refuse to do it with closed source tools.
12:16:50 <shapr> Yeah, same for me.
12:17:06 <Heffalump> FPGAs are quite expensive, aren't they?
12:17:19 <shapr> fsvo Expensive.
12:17:36 <shapr> about $1000USD for a decent sized FPGA and matching PCI board.
12:17:51 <shapr> Not much more than I spent on my latest unicycle ;-)
12:17:59 <tic> eeeeeeep
12:18:06 <tic> crazy
12:18:07 <shapr> From what I can see, the software tools are the most expensive part of FPGAs.
12:18:34 <shapr> Seems that $10,000 USD is cheap for a layout tool.
12:18:41 <tic> holy crap
12:18:46 <tic> how about opencores?
12:19:16 <shapr> Cores are final designs, they're not the tools that let you design those cores.
12:19:18 <Heffalump> I think you can easily spend several tens of thousands of USD on big FPGAs
12:20:10 <shapr> The most expensive Xilinx FPGA setup I could find was about $5000USD, but that included DIMM slots, DSPs, and all sorts of random crap on the PCI card.
12:21:20 <ndm> @google haskell lava
12:21:21 <lambdabot> http://dx.doi.org/10.1145/289423.289440
12:21:26 <genneth> evening shapr
12:21:39 <shapr> Anyway, I'm interested in building software that makes designs for FPGAs more than the FPGAs themselves. I'd like to be able to write Haskell programs that turn an FPGA into a purpose specific coprocessor.
12:21:44 <ndm> Thats a functional programming hardware description language, which you can use for FPGA's
12:22:20 <shapr> ndm: But, a) it's no longer available, b) it required the Xilinx toolchain
12:22:38 <Heffalump> did you try asking Koen Claessen for it?
12:22:48 <ndm> I didn't realise it was no longer available - I have a friend doing some work on it
12:22:50 <shapr> The chalmers version of Lava is still available, but it's specifically for teaching hardware design, and I don't think it has any Xilinx support left.
12:23:09 <Heffalump> what's the problem with that, then?
12:23:30 <shapr> I want to be able to reprogram an FPGA.
12:24:19 <shapr> And I don't like closed source, I don't trust any vendor to know more about my needs than I do.
12:25:02 <shapr> Plus, I think the typed-shapes problem that I talked about before could be used for layout software.
12:25:04 <SamB> shapr: I thought it was more along the lines of "than the internet does"
12:25:06 <shapr> hiya genneth, how's music?
12:25:16 <shapr> SamB: hm, good point.
12:25:30 <genneth> shapr: nice to see you around, talkin' up a storm
12:25:52 * shapr sees the thunderclouds building up
12:25:56 <genneth> shapr: kill bill ost these days, some neat tracks inside
12:26:22 <shapr> I'm into magnatune.com and e-tree.org these days.
12:26:52 <CosmicRay> hmm.
12:26:53 <CosmicRay> icfp.
12:26:56 <CosmicRay> sounds fun.
12:27:01 <CosmicRay> I haven't particpated in a contest in years
12:27:22 <CosmicRay> because I don't like the languages I'm usually forced to use *cough* Java *cough* C++ *spit*
12:27:32 <genneth> shapr: i've been meaning to get into them. but the bands listed are quite a way out of mainstream, and i just get confused
12:28:07 <shapr> genneth: magnatune is easy to surf, with this page, start listening at the top and work your way down - http://www.magnatune.com/info/stats/best_selling_all_time
12:28:15 <Heffalump> CosmicRay: how does is ${haskell:Depends} from dh_haskell supposed to coexist/interact with the variables that update-haskell-control provides?
12:28:26 <genneth> shapr: cheers for that
12:28:49 <genneth> shapr: wow, i really don't know a single artist from that list.... :-D
12:28:50 <shapr> e-tree.org and archive.org are more difficult, it's easiest to find bands you already like and download live recordings.
12:28:58 <SamB> CosmicRay: well, the IOCCC doesn't require C++ or Java either!
12:29:27 <CosmicRay> hah
12:29:39 <tic> haskell schmaskell.
12:29:41 <CosmicRay> SamB: I could win that by just sending them the output of -fvia-C :-)
12:29:48 <SamB> CosmicRay: heh
12:29:49 <shapr> tic: beos schmeeos
12:29:51 <tic> I should probably read through the Haskell Monads tutorial....
12:30:03 <tic> shapr, nah, thing is that I'm going to read Haskell the entire next year, basically..
12:30:04 <SamB> then they would make a rule against it for the next one, of course...
12:30:12 <genneth> SamB: IOCCC is just too painful. my last attempt gave me a migrain for weeks
12:30:14 <shapr> tic: oh cool! join the collective!
12:30:16 <tic> shapr, taking the "computer languages" direction at school.
12:30:24 <CosmicRay> SamB: that's OK, there's always ocaml... :-)
12:30:28 <shapr> I'm thinking of taking some computer classes too.
12:30:36 <tic> shapr, so I guess it'll be mostly focused on functional stuff. type theory, all that stuff that eventually gets you Haskell.. :)
12:30:45 * CosmicRay just started taking classes again.
12:31:01 <CosmicRay> physics in summer.  this was not such a wise move.
12:31:11 <shapr> Lule√• offers datateknik, I wonder if I can turn my years of professional experience into some way to skip out of some classes.
12:31:20 <tic> shapr, maybe maybe.
12:31:25 <tic> *food*
12:31:28 <genneth> CosmicRay: why is physics not good?
12:31:40 <CosmicRay> genneth: it's the physics+summer combination that is not good
12:31:53 <shapr> Otherwise I'll have to take CS101, Introduction to Programming With Haskell. My teacher will *so* hate that. I will turn solutions using arrows that the teacher does not understand.
12:31:59 <genneth> CosmicRay: given your nick...
12:32:00 <CosmicRay> genneth: in the US, the summer semester is half the length as regular ones.  So you may go to class 4 days a week instead of 2, for instance.
12:32:39 <vegai> shapr: if they have any sense, you should be able to pass it with a short interview with the lecturer
12:32:39 <CosmicRay> in my case, my schedule looks like: 7A-4P: work, 5P-6:30P Physics, 5 days a week, plus Monday and Wednesday I have a lab from 7P to 9:45P.
12:32:54 <CosmicRay> shapr: haha
12:32:59 <shapr> vegai: I can hope.
12:33:01 <genneth> CosmicRay: i see -- too bad; i live in britain, and i haven't started uni yet, so i can't really comment
12:33:21 <CosmicRay> shapr: now you see why I have *no time*! :-)
12:33:23 <genneth> CosmicRay: but since i'm doing phys at uni, my interest was piqued
12:33:38 <shapr> Ooh, good word.
12:33:46 <genneth> :-p
12:33:53 <shapr> Most 19√•rings these days say "peaked" and I wanna smack 'em.
12:33:59 <CosmicRay> hah
12:34:00 * shapr hugs genneth 
12:34:06 * genneth hugs him back
12:34:10 <tic> shapr, huh?
12:34:11 <wagle> awww
12:34:15 <genneth> lets all have a hug
12:34:18 * shapr laughs
12:34:19 * genneth give everyone a hug
12:34:20 * shapr hugs tic
12:34:27 * genneth hugs wagle
12:34:29 <CosmicRay> shapr: I also want to smack people that stay "stick-to-it-iveness" or however they spell that
12:34:39 <CosmicRay> it seems like a lot of corporate HR types like that word
12:34:46 <shapr> Yeah, those people who have not heard of persistence obviously don't have it.
12:34:51 <CosmicRay> I want to remind them of that little word known as TENACITY
12:35:04 <shapr> Tenacious D!
12:35:17 <shapr> tic: You know the engelska word pique?
12:35:38 <shapr> kanske det √§r franska =)
12:35:43 <tic> shapr, no, I don't know that word.
12:35:58 <tic> I actually read it for the first time at ctrl-alt-del-online.com, but other than that, no. :)
12:36:02 <tic> (ctrlaltdel-online?)
12:36:11 <shapr> @wn pique
12:36:13 <lambdabot> *** "pique" wn "WordNet (r) 2.0"
12:36:13 <lambdabot> pique
12:36:13 <lambdabot>   n 1: tightly woven fabric with raised cords
12:36:13 <lambdabot>   2: a sudden outburst of anger; "his temper sparked like damp
12:36:13 <lambdabot>    firewood" [syn: {temper}, {irritation}]
12:36:14 <lambdabot>   v : cause to feel resentment or indignation; "Her tactless
12:36:16 <lambdabot>    remark offended me" [syn: {offend}]
12:36:36 <genneth> i love lambdabot; it's by far the most useful bot i've ever come across
12:36:36 <shapr> It also means "to provoke; to arouse"
12:36:48 <shapr> It's most commonly used as "That piqued my interest."
12:36:50 <CosmicRay> shapr: yes, in fact that would be more common
12:36:54 <tic> Ah..
12:37:12 <shapr> So a lot of younger native speakers of english say, "That peaked my interest."
12:37:12 <tic> sudden outburst of anger, "piqued my interest"
12:37:15 <CosmicRay>     2. To excite to action by causing resentment or jealousy; to
12:37:16 <CosmicRay>         stimulate; to prick; as, to pique ambition, or curiosity.
12:37:16 <CosmicRay>         --Prior.
12:37:17 <tic> does not compute. :)
12:37:30 <tic> aha, that one was better, CosmicRay
12:37:30 <shapr> And I wanna smack 'em when they misuse the word like that.
12:37:39 <tic> Yup, peaked your interest is something completely different.
12:37:45 <tic> even I get that... ;)
12:37:54 <genneth> well, if that's what they call it these days...
12:37:54 <shapr> Since I know that genneth is 18, and he used pique correctly, I was thrilled!
12:37:56 <tic> I assumed piqued meant something like it actually did, but I wasn't sure.
12:38:02 <tic> shapr :P
12:38:18 <tic> I want to live in an English-speaking country for a while to get a feel for the language, would be nice...
12:38:20 * shapr gives genneth a gold lambda (we don't do gold stars on this channel!)
12:38:40 <CosmicRay> ahh, poor tic, thinks he can get a feel for English by living in an English-speaking country... :-)
12:38:42 * tic gives genneth a gold snake
12:38:48 <tic> CosmicRay, huh?
12:38:49 <genneth> :-S
12:38:58 <CosmicRay> tic: the remarkable thing about English is that nobody can agree about what it is
12:39:10 <CosmicRay> tic: so none of us really have a good feel for it :-)
12:39:19 <shapr> Right, I speak American!
12:39:21 <tic> CosmicRay, compare it to my feel, then. ;)
12:39:29 <CosmicRay> hehe
12:39:48 <shapr> Oh, I speak International English also, that's the english you speak to those who have learned it from a textbook.
12:39:51 <tic> CosmicRay, I have a feel for Swedish and Polish, but English I have never really spoken in a longer period of time
12:40:11 <shapr> There's this whole separate culture of non-native English speakers who primarily use English with other non-native speakers. It's wild.
12:40:13 <SamB> genneth: you know why lambdabot is so usefull?
12:40:14 <genneth> i kinda just learnt english by being in the environment (i was born in china)
12:40:17 <tic> CosmicRay, I know my grammar and such (mostly), but there's a world of difference between that and talking.
12:40:35 <genneth> SamB: cos @moo is just perfect for filling the gap ;)
12:40:36 <CosmicRay> tic: I, for instance, am a native English speaker.  I understand most Americans quite well, but some I can't understand at all.  I understand most British accents well enough, but some of them I also have trouble with.
12:40:39 <SamB> it is because whenever somebody complains about a feature lambdabot lacks, someone else says "write a plugin!"
12:40:44 <tic> shapr, same as here in Sweden.  Rinkebysvenska, if you've heard of the term...
12:40:51 <tic> CosmicRay, cool. :P
12:40:53 <SamB> or "add it!"
12:40:56 <tic> CosmicRay, same in Sweden, though.
12:41:01 <CosmicRay> I had a terrible time making out all the conversation in BBC's The Office, for instance
12:41:02 <tic> okay, my egg is done. time for food and Dott. ciao
12:41:17 <CosmicRay> but I have no trouble with BBC's Yes, Minister.
12:41:43 <genneth> SamB: I guess lambdabot would make a decent piece of code to read, for educational purposes then?
12:42:02 <shapr> SamB: I think that part of lambdabot culture actually started that way because I was too lazy to implement all the feature requests.
12:42:07 <CosmicRay> tic: my wife tells stories of spending a year in the southern USA when she was about 4 years old, and translating English-to-English for her parents, from the northern USA
12:42:25 <CosmicRay> shapr understands that, I suspect :-)
12:42:50 <SamB> shapr: this is why they call us "lazy functional" programmers. we are lazy, but we get things done!
12:43:16 <CosmicRay> tic: anyway, my point was that you can get a good feel for "London English" but it will be a lot different from "Birmingham (USA) English"
12:43:36 <shapr> That happened to me! My fianc√©e is from S√§√§rbrucken, she grew up bilingual in German and French. Her English is flawless, but the first time she tried to order at Kentucky Fried Chicken in Birmingham, Alabama, I had to translate between Ebonics and International English.
12:43:38 <genneth> tic: hell, birmingham (UK) english is sufficiently different from London English :p
12:43:47 <CosmicRay> shapr: heh
12:44:02 <shapr> Neither could understand the other, it was amazing.
12:44:03 <CosmicRay> genneth: I almost made a joke about that, but then I wasn't sure if it was, so kept my mouth shut :-)
12:44:09 <CosmicRay> heh
12:44:36 <CosmicRay> I suspect I could understand your fiancee without any trouble, and the KFC people after listening very carefully.
12:44:51 <shapr> I'll call you up sometime, I'm curious about your accent.
12:44:52 <CosmicRay> but it would take effort.
12:45:03 * shapr looks for a phone...
12:45:24 <CosmicRay> shapr: if you ever watch, say, American network news shows, most of the anchors have pretty much the same accent as I do
12:45:40 <shapr> What's your number?
12:45:57 <CosmicRay> not by a phone just this minute :-)
12:46:00 <shapr> awww
12:46:18 <CosmicRay> however!  this would be a fun opportunity to test Asterisk :-)
12:46:25 <shapr> Yes!
12:46:42 <CosmicRay> are you hooked into FWD?
12:46:48 <shapr> Four Wheel Drive?
12:46:52 <CosmicRay> fwdnet.net
12:46:52 <SamB> heh
12:47:01 <shapr> never heard of it.
12:47:16 <CosmicRay> it's a free VOIP network
12:47:17 <SamB> didn't you know that BEFORE you asked if it was Four Wheel Drive?
12:47:29 <CosmicRay> asterisk-compatible, SIP-compatible.
12:48:40 <kzm> Anybody use phantom types?  I'm trying to write a vector type that contains its length, but struggling to make a user-friendly constructor function.
12:51:05 <CosmicRay> data Vector = Double Double
12:51:12 <CosmicRay> seems like a friendly enough constructor
12:52:43 <kzm> I'm sorry?
12:52:48 <shapr> No you're not!
12:52:51 <shapr> You're just saying that!
12:53:05 * shapr stops being silly
12:53:08 <kzm> You're right, I'm not sorry.  I'm puzzled.
12:53:10 <CosmicRay> err make that data Vector = Vector Double Double
12:53:13 <xerox> re.
12:53:15 <SyntaxNinja> shapr: no you're not! you're just saying that!
12:53:17 <CosmicRay> that gives you a constructor named Vector.
12:53:25 <shapr> SyntaxNinja: Ok, true enough. I'm always silly!
12:53:31 <CosmicRay> (Vector 5.5 13.2) would create a new Vector.
12:53:58 <genneth> surely that would be limited to a vector of 2 elements tho?
12:54:11 <CosmicRay> yeah, are you needing a 3d one?
12:54:12 <xerox> @index shift
12:54:13 <lambdabot> Data.Bits, Foreign, Graphics.UI.GLUT.Callbacks.Window, Graphics.UI.
12:54:13 <lambdabot> GLUT.Callbacks, Graphics.UI.GLUT
12:54:15 <genneth> kzm: or is that what you meant?
12:54:50 <kzm> I was wondering if I could use phantom types to ensure that e.g. vectors were only added to vectors of the same lenght.
12:54:57 <shapr> kzm: You should check out Oleg's article on number containing types. It's possible that he'll publish an updated version in the next TMR too.
12:55:06 <kzm> I'm fairly sure that's pretty straightforward, but I'm new to this.
12:55:43 <kzm> Yes, I'll probably look at Oleg's stuff.  I was trying to work it out on my own (and obviously failed :-)
12:55:56 <shapr> kzm: You can do that. The first example that comes to mind is the SQL varchar(n) types in HaskellDB.
12:56:10 <kzm> I think I need some class trickery to get it to work.
12:56:29 <arjanb> kzm: gadt's alternatives in here http://www.haskell.org//pipermail/haskell/2005-May/015815.html
12:56:42 <shapr> Yeah, really good value types are usually require at least a quarter oleg of type trickery.
12:56:58 <Itkovian> evening
12:57:02 <kzm> Hehe - how much trickery is one oleg?
12:57:12 <shapr> Quite a bit =)
12:57:17 <kzm> I can only do a few centiolegs, I think.
12:57:45 * kzm laughs out loud, and gets a worried look from his wife.
12:57:48 * shapr grins
12:58:34 <kzm> any reference?  title fragment I can search for?  Is it a real article, or just a list posting?
12:58:47 <shapr> Oh, I can get the url for you.
12:59:10 <shapr> http://okmij.org/ftp/Haskell/number-parameterized-types.html
12:59:30 <shapr> I think the HaskellDB approach will be easier though.
13:00:29 <kzm> Hmm.. got an URL for that as well?  (BTW, the Wiki page was not terribly helpful to me.  If I remember, IÊll updated it when I know what to put there - but if somebody does know, don't wait for me)
13:00:56 <shapr> Yeah, I don't see anything about phantom types on the wiki page... what's up with that?
13:01:41 <shapr> Who's the responsible party here?
13:01:59 <shapr> hei esap!
13:02:05 <esap> hei!
13:02:12 * shapr suddenly remembers who maintains the Haskell wiki
13:03:01 <kzm> http://haskell.org/hawiki/PhantomTypes
13:03:07 <kzm> Sorry, that's not yours, is it?
13:03:26 <shapr> I didn't write that, but I am responsible for the Haskell wiki :-)
13:03:45 <shapr> Oh, that does mention phantom types, whew.
13:06:03 * Itkovian is glad to be back online after a day of boring meetings
13:08:51 <esap> What's up? I must have missed lots of things :-)
13:13:41 <SamB> shapr: I thought your job was just to keep MoinMoin running smoothly, not to be personally responsible for every omission on the wiki!
13:17:39 <musasabi> Can a thing like powerlist be typed with dependent types? (e.g. powerlist [1 2 3] == [ [1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] [] ])
13:18:49 <SamB> you spout meaningless characters!
13:19:04 <lispy> musasabi: powerlist :: [a] -> [[a]] ?
13:19:13 <lispy> why would you need dependent types
13:19:32 <SamB> or maybe that is just a very, very strange hack...
13:19:49 <musasabi> lispy: with finite heterogenous lists. (sorry that was a very important thing to forget)
13:19:57 <musasabi> like HLists.
13:20:14 <lispy> like lisp style lists?
13:20:34 <lispy> for example ["a", 1.5]
13:21:00 <musasabi> yes.
13:22:39 <lispy> powerlist ["a", 1.5, 1::Int] = [ ["a", 1.5, 1::Int], ["a", 1.5], ["a", 1::Int], ["a"], [1.5, 1::Int], [1.5], [1::Int], [] ]
13:22:44 <lispy> how would you type that?
13:23:28 <lispy> (my point being is that i don't know any easy way)
13:23:36 <musasabi> lispy: I am asking that :-)
13:23:53 <lispy> musasabi: hehe, then i agree with your question
13:24:24 <SamB> you should ask on haskell-cafe, where some crazy type wizard (e.g. oleg) can answer you...
13:25:16 <xerox> musasabi, I think autrijus did that in pugs.
13:26:06 <SamB> doesn't pugs use a big algebraic datatype for stuff like that?
13:26:17 <SamB> namely Val?
13:27:12 <musasabi> I don't want to bother the mailing lists since this has very little to do with Haskell and more with "what paper should I read to understand how to do types like that".
13:27:31 <SamB> that sounds like Haskell to me.
13:29:46 <TFK> It seems that I need mingw to build Haskell stuff, them requiring make, right?
13:32:26 <SamB> mingw doesn't even come with make, does it?
13:32:48 <TFK> I think it does.
13:33:03 <SamB> you'll definately need the assembler and the linker...
13:33:33 <TFK> Ah, there's a mingw-make tool.
13:33:51 <shapr> SamB: I dunno, I think being responsible for the wiki means all of the wiki.
13:34:08 <xerox> musasabi, http://research.microsoft.com/Users/simonpj/papers/gadt/ maybe?
13:34:46 <SamB> shapr: somehow I think that must only cover what IS there, and not what ISN'T...
13:35:10 <shapr> Could be, but what isn't there is part of the reason for TMR.
13:36:33 <musasabi> xerox: I don't think GADTs help, but I am starting to think it can be expressed even in Haskell.
13:37:53 <dcoutts_> TFK, mingw does have make and all the other gnu shell tools
13:38:08 <shapr> musasabi: http://sleepingsquirrel.org/joy/
13:38:28 <shapr> Won't help your current question, but might be interesting.
13:38:31 <TFK> Well, I grabbed mingw-make specifically. If it needs something else, it should tell me with a nice error message ;-)
13:38:58 <dcoutts_> TFK, I use MinGW with MSYS for building Gtk2Hs on windows. It's quite good, it has most stuff you need.
13:40:31 * TFK grabs those
13:42:02 <xerox> @paste
13:42:57 <xerox> hmm
13:43:09 <xerox> lambdabot, @wiki HaskellIRCPastePage
13:43:51 <musasabi> shapr: thanks, that is what I would have searched for next.
13:43:51 <TFK> HBin is still online, btw.
13:44:51 <boegel> @wiki paste
13:44:58 <boegel> lambdabot: has died
13:45:17 <xerox> musasabi, http://haskell.org/hawiki/HaskellIrcPastePage is it what you asked for?  I probably misunderstood.
13:46:05 <musasabi> xerox: I was thanking shapr for the link, because I would have next looked up whether different people had implemented Joy in Haskell.
13:47:36 <xerox> musasabi, I was talking about the powerlist thingie.
13:51:32 <boegel> @seen bourbaki
13:51:44 <boegel> lambdabot: goddamned ! get up !
13:55:52 <boegel> there goes lambdabot :(
13:56:34 <integral> @type repeat
13:56:51 <integral> ah, bot being present would help that work ;-)
13:56:56 <xerox> hmm
13:57:06 <boegel> repeat :: a -> [a]
13:57:18 <xerox> @hoogle a -> [a]
13:57:19 <aiskiii> Prelude.repeat :: (a -> [a])
13:57:23 <xerox> :-)
13:58:25 <TFK> Bah. Heaneat is slow :-/
13:58:36 * boegel leaves to study a (little) bit
14:05:32 <genneth> shapr: thanks for the links to magnatunes; it's great
14:05:51 * genneth goes to bed in preparation for my daily grind starting at 0630
14:09:54 <_metaperl> magnatune classical is so much better than radio classical
14:10:05 <_metaperl> much wider spectrum of stuff
14:10:16 <_metaperl> different ages and styles
14:15:23 <Itkovian> grrrr
14:15:35 * xerox pets Itkovian 
14:16:17 <TFK> 13 kBps. Sheesh. Are there no normal mirrors on sourceforge?!
14:19:07 <boegel> yo Itkovian
14:19:28 <Itkovian> hi boegel
14:19:37 <Itkovian> I am dying to get busy with Haskell
14:19:50 <boegel> Itkovian: but you have no time ! :p
14:21:02 <Itkovian> I know!
14:21:15 <Itkovian> howe about writing a cache simulator in Haskell
14:21:27 <Itkovian> as in simple scalar, but maintainable :-)
14:22:11 <boegel> Itkovian: when will you have time ?
14:27:56 <xerox> Goodnight folks :)
14:30:09 <boegel> bye xerox
14:32:36 * boegel leaves for bed-time
14:34:04 <TFK> Hmph. I can't run ./configure, apparently.
14:36:16 <TFK> sh: ./configure: No such file or directory <--- MSYS tells me.
14:38:58 <wagle> whats the "best" xml lib for haskell?  (read, write, process, etc)
14:41:01 <Heffalump> HaXML is standard.
14:42:01 <SamB> shouldn't ANY haskell XML lib be support reading, writing, and transmogriphying (through a combinator library, of course)
14:42:23 <goron> transmogriphying? Is this a word? :D
14:42:38 <SamB> @wordnet transmogriphy
14:42:38 <aiskiii> Unknown command, try @listcommands.
14:42:45 <SamB> @wn transmogriphy
14:42:47 <aiskiii> No match for "transmogriphy".
14:42:59 <dcoutts_> wagle, I use HaXML too and it works fine for what I do, I've not used any of the other ones (eg HXT) so I couldn't tell you if HaXML is best.
14:43:01 <SamB> who cares, you know what it means anyway...
14:43:25 <dcoutts_> TFK, you could try sh.exe configure and see what that gives you
14:43:27 <shapr> @yow ! I'm so happy!
14:43:28 <aiskiii> module "quote" screwed up: getRandItem: empty list
14:43:37 <shapr> hmm, interesting.
14:43:43 <goron> SamB: Actually I don't. I would guess it means transforming based on context and experience.
14:44:30 <SamB> lambdabot looks a bit odd today!
14:44:48 <shapr> @all-dicts transmogrify
14:44:50 <aiskiii> *** "Transmogrify" gcide "The Collaborative International Dictionary
14:44:50 <aiskiii> of English v.0.48"
14:44:50 <aiskiii> Transmogrify \Trans*mog"ri*fy\, v. t. [A humorous coinage.]
14:44:50 <aiskiii>  To change into a different shape; to transform. [Colloq.]
14:44:50 <aiskiii>  --Fielding.
14:44:50 <aiskiii>  [1913 Webster]
14:44:52 <aiskiii>  
14:44:54 <aiskiii> [10 @more lines]
14:45:18 <SamB> wow, I didn't realize that transmogrify was such an old word!
14:45:19 <goron> My context and experience parser are working fine. :D
14:45:19 <shapr> Most notably used in Calvin & Hobbes in the last few decades.
14:47:51 <xerox> lambdabot died some while ago, anyway, if he/she/it returns one of the so-said lambdabot admin can do aiskiii, @part #haskell anytime.
14:48:04 <shapr> right on!
14:48:12 <xerox> 'cause I'm sleeping, or even pretending to do it.  Bye :)
14:48:14 <drL`blok> bullen for nip-gaming !!
14:48:41 <shapr> drL`blok: Hi! written any Haskell code lately?
14:48:53 <drL`blok> you are here way to often!
14:49:01 <shapr> You think so?
14:49:17 <drL`blok> I haven't, i've been studing
14:49:17 <SamB> yes, I also have left the original admins in my lambdabot's config....
14:49:20 <drL`blok> studying
14:49:39 <shapr> Oh, I've been studying too. But I still have time to write code!
14:49:54 <xerox> Oh, OK.  Last thing, I did write some code...
14:49:57 <xerox> @botsnack
14:49:58 <aiskiii> module "dummy" screwed up: getRandItem: empty list
14:49:59 <shapr> Actually, I'm studying ways of doing efficient mental algorithms.
14:50:04 <xerox> Ouch.
14:50:17 <shapr> What are you studying?
14:50:32 <mikael> what kind of mental algorithmns?
14:50:38 <mikael> like, multiplying large numbers? :-)
14:51:04 <shapr> Yeah, just math so far, but I'm pretty sure the heuristics for math algorithms can be ported to other pursuits.
14:51:18 <shapr> Spoken crypto has always been a dream of mine.
14:51:25 <mikael> that's cool
14:52:05 <shapr> I don't how to make itwork, but I do know how to get closer to making it work.
14:53:42 <shapr> mikael: http://www.amazon.co.uk/exec/obidos/ASIN/0884150879
14:54:26 <shapr> I found that book on Brian Beckham's weblog: http://weblogs.asp.net/brianbec/
14:57:40 <mikael> those both seem interesting :-)
14:57:59 <mikael> "A Relational Algebra Simulator in Haskell" :o
14:59:01 <shapr> Yeah, links worth sharing.
14:59:37 <wagle> ahh  dead reckoning...  what a statically typed program does when its memory is corrupted..  8)
15:01:52 <goron> How do I get aiskii to give me all the lines? I already /msg it.
15:02:07 <shapr> You can use @more
15:02:29 <shapr> There's no command for "all lines"
15:03:26 <wagle> whats aiskii?
15:03:39 <shapr> It's xerox' bot while lambdabot is gone.
15:03:49 <wagle> @pl 1
15:03:50 <aiskiii> 1
15:04:37 <wagle> what's aiskiii mean?
15:08:08 <goron> wagle: It's an ai. And I guess it's ski's bot.
15:08:19 <goron> wagle: Dunno about the other i's.
15:09:03 <goron> wagle: Never mind that.
15:10:18 <goron> shapr: Pretty neat. (it actually works)
15:10:41 <shapr> I wrote the @more code, not that it's anything to brag about.
15:11:07 <wilx`> @type return $ repeat
15:11:09 <aiskiii> return $ repeat :: forall (m :: * -> *) a.
15:11:09 <aiskiii>        (Monad m) =>
15:11:09 <aiskiii>        m (a -> [a])
15:11:18 <wilx`> @type (return $ repeat)
15:11:19 <aiskiii> (return $ repeat) :: forall (m :: * -> *) a.
15:11:19 <aiskiii>        (Monad m) =>
15:11:19 <aiskiii>        m (a -> [a])
15:12:31 <wilx`> @type let repeatM = return $ repeat in repeatM
15:12:32 <aiskiii> let repeatM = return $ repeat in repeatM :: forall (m :: * -> *) a.
15:12:32 <aiskiii>                (Monad m) =>
15:12:32 <aiskiii>                m (a -> [a])
15:12:36 <wilx`> Huh.
15:12:39 <wilx`> nvm
15:15:56 <TFK> dcoutts_, doesn't seem to work either way.
15:17:18 <TFK> C:\msys\1.0\bin <--- doesn't have configure.exe  - should I be worried?
15:17:59 <dcoutts_> there is no configure.exe, configure is usually a script in the local dir
15:18:07 <dcoutts_> check that it does actually exist
15:18:24 <dcoutts_> what package is it you are building
15:19:13 <TFK> gtk2hs-0.9.7.1.gtk-2.6 <--- ah, doesn't have configure inside
15:19:50 <dcoutts_> TFK, no, that's because it's a binary distribution, not a source distribution
15:19:57 <TFK> erm.
15:20:27 <dcoutts_> for that you just need to run the batch file, or instead you can go grab the new windows installer yourself and save the hassle! :-)
15:20:37 * TFK will now go hide under a rock
15:21:00 <dcoutts_> TFK, it's ok, the installer is not yet well publiciced since it is slightly experimental
15:21:06 <dcoutts_> let me find the url...
15:21:09 <TFK> Well, it says that the binaries are precompiled for 6.2, no?
15:21:16 <dcoutts_> yes
15:21:25 <dcoutts_> what ghc do you have?
15:21:51 <TFK> Well, I have 6.4, hence I tried to compile [a binary package... ugh] it.
15:22:31 <dcoutts_> ok, for 6.4 you want to wait for the Gtk2Hs 0.9.8 windows installer (whcih I am just building as we speak...)
15:25:27 <TFK> Or... I can try building 0.9.7.1! The make is running as we speak ;-)
15:26:10 <dcoutts_> you can't build the 0.9.7.1 version from source on windows with ghc-6.4, it's not compatible.
15:26:11 <dcoutts_> or if you can't wait, you can install ghc 6.2.2 (it'll happily co-exist with ghc 6.4)
15:26:12 <dcoutts_> if you decide to install ghc-6.2.2 as well, you can use the 0.9.7.1 installer: http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.7.1-multi.exe
15:26:13 <dcoutts_> BTW apparently that version doesn't work well installing into a path with spaces in it, eg "Program Files", I'm trying to fix that.
15:26:25 <dcoutts_> not with ghc-6.4 you can't!
15:27:25 <TFK> Oh. Guess it wasn't meant to be, then.
15:27:50 <dcoutts_> 0.9.7.1 came out before ghc-6.4 and so it just doesn't work.
15:28:30 <dcoutts_> like, I said, you've got 2 options, install ghc-6.2.2 in addition to 6.4 and use the 0.9.7.1 installer (or .zip) or you can wait for the 0.9.8 release candidate windows installer
15:28:44 <TFK> Can't I grab the current sources from the darcs repo?
15:29:01 <dcoutts_> from cvs, yes
15:29:16 <TFK> Ah, no darcs.
15:29:48 <dcoutts_> if you want to build from source make sure you get the branch-0-9-8 rather than MAIN
15:29:49 <TFK> Well, I guess I'll wait then ;-)
15:30:14 * TFK nods
15:30:20 <TFK> Well, good night and thanks!
15:30:31 <SyntaxNinja> wagle and other portlanders: I'm helping to organize a debian release party any Haskellers are invited!
15:31:10 <dcoutts_> Sadly you can't use the 0.9.8 1st release candidate tarball since I just fixed a build problem for windows with ghc-6.4 which just went into cvs.
15:31:39 <dcoutts_> TFK, I'll ping you when the installer is ready. :-)
15:31:57 <TFK> That just might work unless I'll be snoozing ;-)
15:32:24 <TFK> Well, now I'm really off.
15:32:31 <dcoutts_> :-)
15:35:16 <SyntaxNinja> wagle: email me for details. maybe dylan will be there.
15:39:49 * Heffalump repeats his question about anyone going to PLDI
15:39:50 <Igloo> SyntaxNinja: You're either too late or being very prepared  :-)
15:41:16 <SyntaxNinja> Igloo: huh?
15:41:56 <Igloo> Well, we've aleady released. I guess this weekend coming would be the first post-release, though
15:43:06 <SyntaxNinja> Igloo: exactly!
15:43:15 <SyntaxNinja> Igloo: yo're invited!
15:43:18 <SyntaxNinja> you can stay at my place
15:43:35 <Igloo> Does my invite come with a complementary return flight?  :-)
15:52:15 <SyntaxNinja> :)
16:15:05 * Lemmih frowns at GHC for returning ExitSuccess on errors.
16:34:14 <SyntaxNinja> is that better, or worse than Error (success)
16:34:22 * shapr grins
16:48:56 <shapr> g'day Pseudonym
16:48:57 <shapr> ltns
16:49:05 <Pseudonym> G'day.
16:49:19 <Pseudonym> How's things?
16:49:24 <Pseudonym> Is FLM finished yet?
16:49:37 <Pseudonym> (Maintaining software means never having to say "it's finished".)
16:50:24 <shapr> Nah, it's not even released yet...
16:50:38 <Pseudonym> So what on earth have you been doing while not IRCing?
16:50:48 <shapr> mostly working, sadly
16:50:53 <Pseudonym> Shame on you.
16:51:11 <shapr> FLM is very close to release, but I completely lost the energy to work on it, so I have returned here for inspiration.
16:51:17 <Pseudonym> Ah, OK.
16:51:21 <shapr> It's working too, I'm getting inspiration!
16:51:24 <Pseudonym> So you want us to find some more errors in published papers?
16:51:29 <shapr> haha
16:51:31 <shapr> sure!
16:52:07 <SyntaxNinja> FLM!
16:52:31 <shapr> You want to use it?
16:53:56 <SyntaxNinja> I want you to finish it!
16:54:04 <SyntaxNinja> are you writing a paper on it for icfp? :)
16:54:07 <SyntaxNinja> you could give a demo at HW
16:54:08 <shapr> er, no
16:54:21 <SyntaxNinja> @seen JaffaCake
16:54:21 <aiskiii> JaffaCake is in #haskell. I don't know when JaffaCake last spoke.
16:54:23 <Pseudonym> Tell you what.  You write a paper on it for ICFP, and then we find errors and make margin notes in it.
16:54:27 <shapr> haha
16:54:32 <Pseudonym> Recursive fun!
16:54:35 <SyntaxNinja> all that's required for a demo is an email to Daan
16:54:45 <shapr> Yeah, but you also have to show up.
16:54:53 <shapr> And I'm staying home this year.
16:55:10 <shapr> I'm going to spend that money on a new PC.
16:57:14 <Heffalump> who is planning on going?
16:58:56 <SyntaxNinja> <--- ICFP
16:59:37 <Heffalump> my trouble is I'll have to pay for it myself this year.
16:59:49 * shapr has been there
17:01:46 <Pseudonym> I think it should be free, including the plane fare.
17:01:49 <Pseudonym> Then I'd go.
17:01:52 <shapr> Me too
17:01:57 <shapr> Every year without fail.
17:02:51 <SyntaxNinja> w0rd
17:06:40 <Pseudonym> And I think it'd be really good if snow was warm.
17:06:43 <Pseudonym> And tasted like popcorn.
17:08:43 * Lunar^ would like to be there so much
17:08:59 <Lunar^> I'm pretty sure Hallgren et al. will present their work on House
17:09:19 <shapr> Yeah, I'd like to see that.
17:09:27 <Lunar^> They are preparing a paper
17:09:34 <Lunar^> That must be for Haskell workshop
17:14:19 <SyntaxNinja> I think they already sent some to icfp
17:14:45 <Lunar^> SyntaxNinja: oh?
17:15:13 <SyntaxNinja> we sometimes hang out w/ those guys ;)
17:15:28 <Lunar^> we?
17:15:39 <SyntaxNinja> galois folks
17:16:01 <Lunar^> SyntaxNinja: Are they still at OGI? Marc Pouzet told me that they OGI had been through major changes
17:16:30 <SyntaxNinja> yeah, thomas and mark jones and one other student I think are at ogi, others went to ohsu and psu
17:19:40 <Heffalump> I thought OGI wanted rid of their CS dept?
17:20:05 <Lunar^> SyntaxNinja: It will be hard to do an internship with them, then
17:20:36 <Lunar^> but I should just ask, and stop dreaming of it
17:21:58 <Lunar^> mhh.. internship might not be the right word
17:26:44 <SyntaxNinja> gotta run. tyl
17:26:45 <SyntaxNinja> ttyl
17:29:54 <Lemmih> Today has been a good day.
17:58:04 <wagle> anyone using HaXml via darwinports and GHC 6.4?
17:58:16 <wagle> shapr: 8-p
18:22:59 <Lemmih> wagle: Having problem?
18:23:02 <Lemmih> *problems
18:24:20 <wagle> Lemmih: darwinports has only 1.12
18:24:48 <wagle> 1.13 wants to mix itself in with darwinports
18:25:14 <wagle> (HaXml 1.12 and 1.13)
18:25:49 <wagle> i think the correct solution is to create a darwinport for HaXml 1.13..  8/
18:28:03 <Lemmih> Isn't the current version 1.14?
18:28:25 <wagle> web page says the current version is 1.13
18:57:26 <dons> @yow
18:57:26 <aiskiii> module "quote" screwed up: getRandItem: empty list
18:57:27 <lambdabot> Xerox your lunch and file it under "sex offenders"!
19:44:29 <blackdog> @vixen missed me?
19:44:30 <lambdabot> I Think you're fake
19:44:31 <aiskiii> module "vixen" screwed up: getRandItem: empty list
19:44:55 <blackdog> who is aiskiii?
19:46:44 <dons> @part aiskiii
19:46:55 <dons> aiskiii, @part
19:47:00 <dons> aiskiii, @part #haskell
19:47:07 <blackdog> third time's a charm
19:47:13 <dons> xerox's practice bot, I think.
19:47:33 <SamB> aiskiii was filling in while lambdabot was out....
19:47:48 <dons> oh, that's right. the network went down last night
19:47:48 <blackdog> a casual bot?
19:47:55 <dons> on-call, at least
19:47:56 <blackdog> they'll be wanting holiday pay and sick leave next
19:48:08 <dons> we'll out source to india!
19:48:16 <blackdog> electrons are cheaper there
19:48:24 <dons> that's true.
19:48:46 <SamB> yes, but who will recompile it?
19:48:53 <SamB> who will START it?
19:49:07 <dons> i'm sure we can out-source that job too.
19:49:25 <dons> or maybe some haskeller can move to india to over see the bot's work
19:49:26 <SamB> but would they do a good enough job?
20:54:32 <dcoutts_> yay! Gtk2Hs is now on the GNOME news aggregator. :-) http://planet.gnome.org/news/
20:54:44 <dcoutts_> "Gtk2Hs: bringing the unwashed masses to Haskell" 2002 to 2005
20:57:34 <dons> @karma+ dcoutts
20:57:35 <lambdabot> dcoutts's karma has been incremented
21:35:26 <Pseudonym> Unwashed or hair shirt?  You decide.
21:42:41 <lispy> i forget what does hair shirt mean again?
21:44:07 <Pseudonym> @google hair shirt
21:44:09 <lambdabot> http://www.newadvent.org/cathen/07113b.htm
21:48:51 <kaol> "A garment of rough cloth made from goats' hair and worn in the form of a shirt or as a girdle around the loins, by way of mortification and penance."
21:49:01 <kaol> @google hair shirt haskell
21:49:03 <lambdabot> http://research.microsoft.com/Users/simonpj/papers/haskell-retrospecti
21:49:03 <lambdabot> ve/
21:49:34 <kaol> google is useless.
21:49:48 <Pseudonym> Actually, I found that encyclopedia article fascinating.
21:50:03 <Pseudonym> And that is precisely the analogy that SPJ is using.
22:14:47 <lightstep> @index mapA
22:14:48 <lambdabot> bzzt
22:18:22 <lispy> @index mapM
22:18:24 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
22:18:24 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
22:18:24 <lambdabot> Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
22:18:38 <lispy> maybe it's in the same place as one of those?
22:19:27 <dons> @hoolge mapM
22:19:28 <lambdabot> Prelude.mapM :: Monad a => ((b -> (a c)) -> [b] -> (a [c]))
22:19:46 <dons> yay hoogle
22:19:54 <dons> @hoolge mapA
22:19:55 <lambdabot> List.mapAccumR :: ((a -> b -> (a, c)) -> a -> [b] -> (a, [c]))
22:20:08 <dons> sort of
22:21:31 <lightstep> i don't get this hoogle. doesn't it test for an exact match?
22:21:40 <lightstep> (modul aplha renaming)?
22:22:01 <dons> @help hoogle haskell
22:22:02 <lambdabot>  @hoogle <expr>, Haskell API Search for either names, or types.
22:22:08 <dons> @google hoogle haskell
22:22:10 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/hoogle/
22:22:44 <dons> for identifiers, a substring must mach
22:22:49 <dons> match
22:22:56 <dons> For type searches, anything that will unify is returned
22:23:05 <dons> arguments can be reordered
22:23:27 <lightstep> @hoogle [a] -> (a -> b) -> [b]
22:23:28 <lambdabot> Prelude.map :: ((a -> b) -> [a] -> [b])
22:23:37 <lightstep> hmm
22:23:44 <lightstep> it flips parameters?
22:24:03 <dons> "arguments can be reordered - i.e. [a] -> (a -> b) -> [b] will still match map"
22:24:25 <lightstep> @hoogle a -> (a -> b) -> b
22:24:26 <lambdabot> Prelude.($) :: ((a -> b) -> a -> b)
22:24:29 <dons> which is appropriate, I think, considering we have flip
22:24:52 <dons> really, though, Hoogle.hs should return more matches
22:24:55 <lightstep> @hoogle Monad m => m a -> (a -> m b) -> m b
22:24:56 <lambdabot> Prelude.(>>=) :: Monad a => ((a b) -> (b -> (a c)) -> (a c))
22:25:11 <dons> or we should get some sense of how close a match is, then decide what threshold to return
22:25:31 <dons> (for lambdabot use)
22:25:45 <lispy> @hoogle (a -> b -> c -> d) -> ((a,b,c) -> d)
22:25:47 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => (a -> b)
23:53:10 <dons> @ghc
23:53:12 <lambdabot>  Too many parameters for class
23:53:13 <dons> @code
23:53:14 <lambdabot> Read.lhs: readListPrecDefault        -- Looks for ['f','o','o']
23:53:22 <dons> seriously?
23:53:57 <andersca> @arr
23:53:57 <lambdabot> Ahoy mateys
23:54:21 <dons> @y0w
23:54:22 <lambdabot> Kids, don't gross me off ... "Adventures with MENTAL HYGIENE" can
23:54:22 <lambdabot> be
23:54:22 <lambdabot> carried too FAR!
23:54:28 <dons> @bot
23:54:29 <lambdabot> :)
23:54:40 <dons> cheeky
23:55:17 <dons> @uptime
23:55:18 <lambdabot> uptime: 4 hours, 58 minutes and 3 seconds
