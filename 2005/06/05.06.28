00:00:00 <ski> another explanation is like if 'm a' is vaguely seen as a "collection" of 'a', then liftM takes a function of type 'a -> b' and maps it over this "collection" turning every 'a' inside it to a 'b'
00:01:32 <ski> liftM really doesn't do any monadic effects of any sort, it just waits for the input 'm a' to "produce 'a's" (in whatever way the particular monads does that), and convert those 'a's to 'b's with the argument function
00:01:41 <ski> Enveigler : does this help ?
00:02:56 <ski> (note :  liftM id == id,  so mapping/lifting the function that does nothing over a monadic action will yield back the same monadic action.  also  liftM (f . g) = (liftM f) . (liftM g) )
00:03:46 <Enveigler> Hmmm. I *know* you're gonna fall on me like a tone o'bricks for this, but... 'liftM <function>' maps a list of 'a's to a list of 'b's using <function> (which map an 'a' to an 'b') to do the "conversion"?
00:04:21 <ski> in the list monad, yes :)
00:05:41 <Enveigler> WHy is it I get the impression that there is a whole world of greif and googling hidden behind that "in a list monad" :?
00:05:51 <ski> it's not
00:06:04 <ski> just that there are other monads than the list monad
00:06:35 <ski> in the maybe monad, it works like this
00:06:42 <ski> liftM f Nothing = Nothing
00:06:52 <ski> liftM f (Just a) = Just (f a)
00:07:04 <shapr> Enveigler: It's a whole world of Joy, just so you know.
00:07:18 <ski> which is similar, except there's at most one 'a' present
00:07:30 <ski> good morning shapr
00:07:35 <Pseudonym> G'day shapr.
00:07:40 <shapr> hiya
00:07:53 <Tue7657> its just getting into another realm basically, the lifting
00:07:57 <Enveigler> shapr: I understand Joy. I can visualise how to implement Joy. It makes sense.
00:08:00 <Tue7657> meaning depends on the monad
00:08:00 <shapr> g'day seafood
00:08:07 <seafood> g'day shapr.
00:08:29 <shapr> Enveigler: The state monad is sort of like Joy with arguments left on the stack.
00:08:48 <Tue7657> I like the reader monad
00:09:12 <shapr> Enveigler: The best intro is - http://www.nomaware.com/monads/
00:09:14 <Enveigler> ski: The questions racing around my mind at this point are 1) Why do I need a different function 'liftM' to map a function over a list, when 'map' maps a function over a list?
00:09:47 <ski> Tue7657 : yeah. but still, liftM/fmap should not do any serious effects in the monad. just like 'return <blaha>' creates a "trivial" monadic action, i.e. an action that will not do any monadic effects, just return/yield the given value '<blah>'
00:10:13 <ski> Enveigler : liftM (for the list monad) == map
00:10:47 <Tue7657> ski, effects as in....SIDE-effects?
00:10:48 <ski> Enveigler : while liftM also works for other monads, map is just for lists
00:11:28 <ski> Tue7657 : well, depends on what you concentrate on
00:11:36 <Tue7657> i would think fmap could have an effect on the monad => changing the value within it....but you are referring to a different 'effect' ?
00:12:08 <Enveigler> I read what you write, and whilst I am perfectly sure and content that it is correct, it whistles wildly right over my head leaving me with an inane grin!
00:12:17 <shapr> Enveigler: start with the Maybe monad.
00:12:33 <shapr> The monadic interface is two functions and a partially filled in type.
00:12:59 <shapr> A monad is a type with a certain significance turned into a pipeline with the same useful significance.
00:13:02 <ski> Tue7657 : if you think of  writeFile :: FilePath -> String -> IO () as something taking a FilePath, a String and returning a (), then surely there are effects going on, at the side of this. but, on the other hand, if you think of it as returning *IO* (), then the effects are returned as part of the *IO*-action
00:13:43 <Enveigler> shapr: "A monad is a type with a certain significance turned into a pipeline with the same useful significance." This *means* something?
00:14:00 <shapr> Sure it does. Do you know the Maybe type?
00:14:01 <ski> :)
00:15:04 <Tue7657> ski, i see what you mean with effects now. But changing values with fmap could also be considered an effect. Although a somewhat other effect by nature
00:15:28 <ski> Tue7657 : i'm using the word 'effect' here in a special way. similar to the word 'side-effect', just not necessarily "at the side" :)
00:15:29 <Enveigler> Um. I've seen it. Without looking it up, I think it basically says that "X might be something or nothing".
00:15:35 <shapr> That's correct.
00:15:43 <Tue7657> ski, i see :)
00:15:51 <shapr> So the Maybe type has significance "This computation might fail."
00:16:09 <ski> Tue7657 : maybe it could be considered an effect. In any case, not an effect in the IO-monad !
00:16:09 <Enveigler> That I understand.
00:16:09 <shapr> data Maybe a = Just a | Nothing
00:16:37 <ski> Tue7657 : Maybe-effects consists of possibly not returning a value
00:16:53 <ski> Tue7657 : List-effects consists of possibly not returning a value, and possibly returning more than one value
00:17:34 <ski> Tue7657 : State-effects consists of possibly letting the result of the action depend on some global/implicit state, and possibly changing that state
00:17:49 <ski> Tue7657 : Reader-effects consists of possibly letting the result of the action depend on some global/implicit environment
00:19:05 <Enveigler> It's a good job I've had my breakfast triple brandy, otherwise I would be frustrated rather than giggling inanly!
00:19:06 <Tue7657> did you just put that out of the hat?
00:19:19 <Tue7657> ski
00:19:24 <Tue7657> :)
00:19:31 <ski> from my memory, yes
00:20:22 <shapr> Enveigler: The maybe monad turns that type into a pipeline with the same stacked semantics. You can abstract away a big stack of nested if-then-else with the maybe monad.
00:21:07 <ski> Tue7657 : (Don'tCare)NonDeterminism-effects consists of possibly letting the result depend on some arbitrary choice. And next time you run the action, some other of the possible choices might be taken.   this is a little hard to phrase, perhaps.  think of mutiple processes/threads that will do different things depending on which of them gets scheduled first
00:21:34 <shapr> The two operations/functions for a monad are lift and bind. One puts a value into the monad, one sticks together two filled-in types.
00:21:47 <Enveigler> Hmm. A "coroutine that repeats the same action on a new parameter each time you call it"?
00:22:17 <shapr> For the maybe monad, (return 1 :: Maybe Int) lifts the 1 :: Int by (Just 1)
00:22:40 <ski> Tue7657 : IO-effects consists of State-effects (including Reader-effects) and (Don'tCare)NonDeterminism-effects, and possibly some more effects. People tend to throw a lot of different kind of effects into the IO-monad :(
00:23:25 <shapr> Enveigler: http://www.nomaware.com/monads/html/maybemonad.html
00:23:39 <ski> Tue7657 : that's more or less an overview of some of the most important monads/effects. feel free to ask more about any one in perticular :)
00:24:02 * Enveigler goes off to read -- thanks for your patience!
00:25:31 <Enveigler> Typo? "he plus operation returns the first non-Nothing value or Nothing is both inputs are Nothing." s/is/if/?
00:26:00 <shapr> yup
00:26:24 <shapr> http://www.scannedinavian.org/~shae/ProtoMaybe.hs
00:26:24 * Enveigler nods
00:28:52 <yain> hi
00:29:07 <shapr> If you load ProtoMaybe.hs into ghci or hugs, you'll be able to see the return values by typing the name of the demo you want.
00:30:24 <ski> wb
00:30:51 <Enveigler1> Thanks ski
00:31:09 <Enveigler1> Just popped back to say shapr: danke-u well.
00:34:36 <Tue7657> is there a way to abstract over a constructor in haskell ? (without resorting to template-haskell or generic-haskell)
00:36:25 <Enveigler1> bye.
00:36:32 <shapr> g'bye!
00:36:39 <shapr> Hope the code is helpful.
00:57:09 <Heffalump> Tue7657: for pattern-matching purposes?
01:00:20 <Tue7657> yeah
01:00:29 <Heffalump> not really, then
01:00:34 <Tue7657> like an underscore for constructors :D
01:00:47 <Heffalump> you can pass in a predicate that looks for it, sometimes
01:00:53 <Tue7657> i had a hunch that this wasnt possible...why have generic-haskell otherwise hehe
01:01:29 <Tue7657> i want to uniformly handle two different datatypes that only differ on their constructors, thats why
01:02:59 <shapr> bonjour poetix
01:03:28 <poetix> Good morning
01:03:34 * poetix is feeling a little bleary
01:03:42 * shapr is feeling somewhat bleary also
01:03:47 <shapr> I wish I could get rid of this cold.
01:04:21 <poetix> The sudoku solver has a bug in it. I should have gone to bed earlier - bet I'll fix it in the next ten minutes this morning, after having banged my head against a brick wall for an hour at one o'clock in the morning last night...
01:04:39 <shapr> That sounds familiar.
01:04:40 <Tue7657> cold....it bloody hot outside here :D
01:04:54 <shapr> It's warm here also, something like 10Â° C.
01:05:04 <poetix> Lovely weather in sunny Northampton
01:05:09 <Tue7657> ah the scandinavian type
01:05:10 <Tue7657> :P
01:05:16 <shapr> But I'm still sick today.
01:05:21 <shapr> Yeah, what's warm for you?
01:05:30 <Tue7657> 29 C
01:05:43 <shapr> oh
01:05:52 <Tue7657> too warm actually
01:06:07 <shapr> I'd love it. I'm from Alabama.
01:06:29 <shapr> We got a lot of 40C, and a little of even more.
01:08:37 <Tue7657> pfff, i love cold
01:08:50 <shapr> What about -35C?
01:10:52 <Tue7657> too cold :)
01:14:03 <Heffalump> Tue7657: you could write predicates/deconstructor functions for each datatype
01:14:13 * shapr throws redexs
01:16:08 * Itkovian is trying the exam for thursday ... it is difficult :-)
01:16:18 <Itkovian> even with said redexes :-)
01:16:23 <shapr> Aren't you giving the class?
01:16:43 <Itkovian> i am not making the exam ... I only teach the excercises
01:16:48 <Itkovian> exercises
01:16:49 <shapr> Oh, I see.
01:18:29 <Tue7657> Heffalump, yeah i solved it that way
01:18:39 <Tue7657> not as nice as one single pattern match...but hey :D
01:20:33 <shapr> Hey diddle diddle...
01:20:58 <Tue7657> hey btw is that hitchhiker's guide just one book by douglas adams?
01:20:59 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueThree","Haskell rules","ICFP Contest! http://icfpc.plt-scheme.org/","ghc added to Fedora Extras"]' by shapr
01:21:12 <shapr> HHG is the first of a series.
01:21:39 <poetix> As I thought - a blindingly obvious error, correctable in minutes by a person who isn't about to die of exhaustion...
01:21:46 <shapr> Yay!
01:21:50 <Tue7657> ow ok
01:22:08 * poetix wasn't talking about H2G2...
01:22:17 <Tue7657> is the series worth or is it just basically HHG and then some bad sequals
01:22:41 <shapr> I think the series is worth it, but you can probably find the whole series in your nearby library.
01:22:45 <shapr> Then you can find out for yourself.
01:26:35 <Tue7657> "..Hitchhiker's Guide to SQL Server 2000 Reporting Services.."  :S
01:28:45 * ski bakes banana cake
01:29:24 <shapr> salut Isumi
01:29:37 <Isumi> salut
01:29:50 <shapr> Apprenez vous Haskell?
01:30:06 <Isumi> j'essaye :)
01:30:27 <shapr> Avez vous question?
01:30:42 <Isumi> pas de question précise non
01:30:54 <Isumi> je regarde juste ce qu'il se passe ici :)
01:31:08 <shapr> Ok, if you think of some questions, feel free to ask.
01:31:48 <Tue7657> "The Ultimate Hitchhiker's Guide"
01:31:55 <Tue7657> 6 stories, 5 novels for 12 euros
01:32:14 <Tue7657> is this the complete HHG series?
01:32:15 <shapr> @plugs 11 / 12.0
01:32:20 <lambdabot> 0.9166666666666666
01:32:34 <shapr> Hm, .9 euro per story.
01:34:38 <Tue7657> it appears to contain HHG, restaurant at the...., Life the universe...., so long and thanks for ...., gods final message...., mostrly harmless, Young zaphod plays it safe
01:34:45 <Tue7657> 815 pages or so
01:36:20 <Tue7657> im so going to order it
01:42:29 <FrederikEaton> in WASH is it possible to put a submit button *before* the input elements that it submits?
01:43:13 <FrederikEaton> i think without a MonadFix WithHTML instance it might be impossible
01:46:12 <poetix> shapr: OK, I'm done with the SudokuSolver article - let me know what you think.
01:47:22 <shapr> w00!
01:48:32 <shapr> Oh, I like your graphics.
01:49:13 * ski peels frozen eggs
01:49:21 * shapr freezes peeled eggs
01:50:29 * jewel eggs frozen peels
01:50:54 <shapr> hiya jewel, how's code?
02:02:01 <seidan> @pl \a b c -> fmap (foo a c) . b c
02:02:02 <lambdabot> ap . (((.) . fmap) .) . foo
02:02:11 <seidan> eww...
02:17:49 <shapr> So, any exciting code today?
02:18:16 <shapr> hej norpan
02:19:04 <poetix> I read the Zipper article. That's really neat.
02:19:20 <shapr> Have you read part two?
02:19:35 <shapr> Oleg says that part three might be in the July TMR.
02:20:40 <poetix> Bo!
02:47:22 <poetix> Where Zipper pt ii?
03:08:54 <shapr> poetix: Part 1 http://www.haskell.org/pipermail/haskell/2005-April/015769.html and Part 2 http://www.haskell.org/pipermail/haskell/2005-May/015844.html
03:09:32 * earthy congratulates jaffacake with the nice report
03:09:42 <JaffaCake> ta
03:10:38 <earthy> one thing that is easily noted from the report is that GHC is now used as a production quality compiler in the pursuit of other goals
03:11:35 <autrijus> report?
03:11:51 <earthy> http://www.haskell.org/ghc/survey2005-summary.html
03:12:10 * autrijus is working franticly on the YAPC talk that will be on air in <3 hours
03:12:22 <earthy> good luck!
03:12:25 <autrijus> thanks!
03:12:53 <shapr> JaffaCake: minor misspelling "forthocoming"
03:13:03 <JaffaCake> oh, thanks
03:13:12 * JaffaCake didn't run the spellchecker
03:13:19 <autrijus> trying very hard to explain it's not a bug that Perl 6 is far more suited to write compilers than Perl 5, and that's not because "compiler is a very low level thing and perl5 is a high level language" as some would believe
03:13:35 <shapr> Heh
03:13:52 <shapr> I've been trying to explain that sort of pattern to people recently too.
03:14:25 <shapr> I look forward to archiving the good parts of your talk for later use ;-)
03:14:31 <shapr> Will your talk or notes be online?
03:14:35 <autrijus> it's already
03:14:42 <earthy> url!
03:14:44 <earthy> ;)
03:15:10 <earthy> anyway, methinks true perlers understand the beauty of implementing your own languages more easily
03:15:46 * shapr agrees
03:16:31 <shapr> I think that type error slicing would improve error messages.
03:19:18 <shapr> Another spell fix: "inocrporate"
03:19:55 <shapr> Searching for functions already exists with Hoogle
03:20:01 <shapr> Though Hoogle isn't yet built into ghci
03:20:03 <TheHunter> i don't quite see why Oleg uses delimited continuations for his zipper.
03:20:42 <shapr> As opposed to what?
03:21:09 <TheHunter> data Zipper dir a
03:21:09 <TheHunter>   = Zipping a ((dir, a) -> Zipper dir a)
03:21:09 <TheHunter>   | ZipDone a
03:21:27 <TheHunter> i think this is equivalent to a monadic traversal function.
03:21:50 <TheHunter> you can convert the traversal function to it by using the plain old Cont monad.
03:21:53 <shapr> hehe, Bus Error worries
03:22:12 <shapr> Hm, I'll have to stare at that when I get some spare brain cycles.
03:22:55 <TheHunter> i can upload the whole code somewhere.
03:23:00 <shapr> yes please!
03:23:19 <autrijus> shapr: http://svn.openfoundry.org/pugs/docs/talks/YAPC.spork
03:23:25 * boegel y0ws
03:23:30 <shapr> ah, "interrim" is another typo
03:24:11 <shapr> hiya boegel
03:24:34 <boegel> shapr: I'll try to finish my HRay article, but I'm not sure if I'll make it
03:24:38 <boegel> when's the deadline ?
03:24:53 <shapr> Same as every issue, first of the month.
03:25:00 <shapr> You've got two days or so.
03:25:17 <shapr> I can push the deadline forward two days if you think you can finish by then.
03:25:28 <shapr> I think TMR has been out on the 2nd once before.
03:26:20 <shapr> autrijus: What's this nifty format? Is that yaml?
03:26:45 <TheHunter> http://www.haskell.org/hawiki/HaskellIrcPastePage_2fZipper
03:26:53 <TheHunter> http://www.haskell.org/hawiki/HaskellIrcPastePage_2fZipperG
03:27:15 <shapr> That format looks like a mix of wiki markup and something else.
03:27:39 <poetix> shapr: Sudoku article OK?
03:27:56 <shapr> Oh, I got distracted.
03:28:19 <poetix> That's my permanent state
03:28:22 * shapr cranks up the focus
03:28:28 <shapr> Mine too, but I get lovely drugs to fix that.
03:28:48 * shapr waves a bottle of methylphenidate
03:30:12 <boegel> shapr: hmm... I'll see when I'll be able to finish it
03:30:24 <shapr> poetix: Is puzzle size a given?
03:30:25 <boegel> but I don't like to rush that kind of thing, so I might want to postpone it
03:30:31 <shapr> Oh right, nine by nine, duh.
03:30:38 <boegel> shapr: do you have enough articles for the next issue ?
03:30:46 <shapr> Probably not
03:30:55 <shapr> That's why I want to wait :-)
03:31:27 <shapr> Let's see, poetix, Philippa, and shapr are very likely to have articles.
03:31:44 <shapr> Especially since Philippa and poetix are at the finished except for whinging stage.
03:31:55 * shapr looks for whinges
03:32:01 <poetix> Bring on the whinges
03:32:22 <poetix> Is Philippa being Impure again?
03:32:23 <boegel> shapr: don't wait for me, I'll let you know if I'll be able to make it on time :)
03:32:23 <autrijus> shapr: that format is kwid
03:32:37 <shapr> awright
03:32:44 <autrijus> shapr: it's like markdown but syntax error free and isomorphic to pod (which is then translatable to latex html etc) -- it's an ingy thing
03:33:16 <shapr> hmmm
03:33:25 <autrijus> all my slides are written in it
03:33:41 <shapr> Any LaTeX output demos?
03:33:43 <autrijus> the visual rendering control is not as good as latex, but often close (does highlighting etc)
03:33:56 <autrijus> and is in any case much easier to write than latex
03:34:01 <shapr> Truly
03:34:28 <autrijus> anyway, ingy is still sleeping, I'll ask him when he's up :)
03:34:33 <shapr> Ok
03:34:33 * autrijus goes on writing slides
03:34:42 * boegel leaves to catch his train
03:37:56 <shapr> TheHunter: Have you considered a Dark Corners column for TMR?
03:40:36 <autrijus> JeffaCake++ # truly nice report
03:40:47 <autrijus> it's the first time I heard the expression "Bus Errors in Cambridge"
03:40:52 * shapr grins
03:40:59 <autrijus> eeriely fitting
03:41:09 <TheHunter> shapr, if i find out something funny, i'll write it up for TMR, possibly something about zippers.
03:41:14 <TheHunter> bbl
03:41:20 * poetix pings methylphenidate pills into shapr's gaping maw
03:41:33 <shapr> TheHunter: cool, thanks
03:42:20 <poetix> I have promised the missus that I will stay off the computer this evening, so if there's anything you want fixing it's best if I know sooner rather than later...
03:42:42 * Matt-W wonders if there's an introduction to Standard ML for people who know Haskell
03:43:02 <shapr> poetix: not too many, or I won't be able to sit still!
03:43:11 <shapr> I'll read faster.
03:43:16 <earthy> neat set of slides, autrijus
03:43:56 <autrijus> thanks, earthy
03:44:03 <autrijus> any comments/complaints?
03:46:47 <earthy> well, I hope you're going to put up the ref to TaPL
03:48:11 <shapr> poetix: Seems like getSubGrids could be abstracted somehow, but that's a minor quibble.
03:48:13 <earthy> and the PyPy sidebar is somehow distracting, if you read the slides
03:49:19 <shapr> poetix: I really like the careful introduction of monad trasformers.
03:50:00 <poetix> I don't take it very far - for the purposes of this article, it's enough that StateT Just Works.
03:50:26 <shapr> Yeah, that's good for an intro.
03:51:43 <shapr> poetix: Oh, I think you should solicit the next step from newbie Haskellers.
03:52:11 * ski ponders zipper,derivatives,demand elasticity
03:52:24 <poetix> You mean send them to a tutorial on monad transformers, or challenge them to improve the solver?
03:52:55 <shapr> Yeah, exactly.
03:53:00 <shapr> Both :-)
03:53:51 <poetix> OK - I'll put that in a bit later on.
03:55:11 <autrijus> earthy: reflected, thanks
03:55:42 <shapr> poetix: This is good, it's simple but not completely naÃ¯ve, it clearly shows the intermediate stage so that others can take the next obvious steps. Good article!
03:59:07 <Itkovian> poetix: anything the world may read? yet?
04:00:37 <shapr> I have my article set to read-all, you can do that too if you wish.
04:01:41 <poetix> What do I need to change? The acl setting at the top?
04:01:50 <shapr> Yes, though I can do that if you prefer.
04:01:58 <poetix> "simple but not completely naive" - my new motto
04:02:09 <poetix> shapr: yes, please, go ahead.
04:02:13 <shapr> That's the best teaching step, imho.
04:02:24 <poetix> Well, it's also pretty much where I'm at myself...
04:02:39 <shapr> Because the first step away from 100% simple is the very beginning of optimization, and can suggest lots of different approaches.
04:04:10 <autrijus> shapr: have you given thought to togglable typefulness?
04:04:19 <autrijus> I find it fascinating
04:04:20 <shapr> Like SoftTyping?
04:04:25 <autrijus> the "duck" in Boo
04:04:37 <shapr> Boo?
04:04:41 <poetix> Itkovian: http://www.haskell.org/tmrwiki/SolvingSudoku
04:04:48 <autrijus> boo.codehaus.org
04:04:49 <poetix> Python redux
04:04:56 <poetix> so to speak
04:05:10 <autrijus> it has a pragma that, when enabled, turns entire program into duck typing
04:05:22 <shapr> Ah yes
04:05:30 <autrijus> i.e. capability based very late binding
04:05:52 <shapr> You should read Philippa's latest TMR article, duck typing is covered in interesting ways.
04:05:56 <poetix> Boo has capabilities?
04:06:02 <autrijus> but otherwise it's as type-rich as CLR is, with inference
04:06:16 <shapr> capability based binding? I know of capabilities in E, is this the same thing?
04:06:19 <poetix> I was reading about E the other day, wondering whether to get my feet wet
04:06:28 <shapr> poetix: It's cool stuff.
04:06:51 <autrijus> no, this is more like exploratory interface offered by CLR
04:06:52 <autrijus> CreateInstance("InternetExplorer.Application")
04:07:01 <autrijus> think COM components
04:07:12 <shapr> COM, I never knew thee.
04:07:23 <shapr> It looks like reflective instance creation in Java though.
04:07:43 <poetix> Very similar, I think - it's based on the reflection capabilities of the CLR
04:07:49 <autrijus> so probably not the same thing as in E
04:08:29 <shapr> I like very late binding. I would guess this can be done with typeclasses in Haskell, but I'm not sure.
04:08:44 <shapr> In fact, I'd probably point to Val as an example.
04:08:48 * autrijus hands shapr Data.Dynamics and boiled scratchpads
04:08:51 <shapr> heh
04:09:07 <shapr> Yeah, it does require more than an oleg of type-hackery.
04:09:19 <poetix> oleg's now a unit?
04:09:21 <autrijus> is oleg an unit now?
04:09:31 <shapr> Yup, a rather large unit of type-hackery too.
04:09:34 <Itkovian> poetix: thx, looks nice at first glance
04:09:44 <shapr> Philippa: ayh?
04:10:05 <shapr> Philippa's in-progress TMR article is about duck typing, among other things. But Oleg was called in to offer backup, so...
04:10:21 <musasabi> Has anyone experience with GHC 6.4 panicking with "Unify.unifyTauTyLists: mismatched type lists!"
04:10:38 <shapr> Wow, how'd you get that?
04:10:59 <shapr> TH? hs-plugins?
04:11:02 <musasabi> a few days ago simonpj fixed at least one unify bug, so I am not sure whether that is fixed.
04:11:22 <musasabi> shapr: -fglasgow-exts + compiling with nothing very fancy.
04:11:58 <shapr> autrijus: I'm fascinated by the idea of a modularly typed language. I'd like to have regions with different type systems.
04:12:55 <shapr> That way the top level could be dynamically or weakly typed, but deeper chunks could have HM or whatever.
04:13:26 <autrijus> right.
04:13:39 <shapr> I'm not sure I'd want to explain that language to a classroom of college kids though.
04:13:57 <autrijus> I'm trying to get this sort of design out of larry in the past week
04:14:06 <shapr> Nested type systems?
04:14:22 <shapr> Or optional typing?
04:14:37 <autrijus> modular typing coupled with some whole-program analysis
04:14:39 <shapr> edwinb: Hey, you want to write about dependent types for the next TMR?
04:14:58 <shapr> That might also give you type error slicing, meaning type errors would be oh so informative suddenly.
04:15:07 <autrijus> url for type error slicing?
04:15:28 <shapr> Check out the demo - http://www.cee.hw.ac.uk/ultra/compositional-analysis/type-error-slicing/slicing.cgi
04:15:37 <shapr> That's the sort of thing I'd like to have in Yi.
04:15:39 <autrijus> anyway, I think it makes a damn good case for exploratory programming in dynamic type mode, and then take full advantage of typeful later on
04:15:49 <autrijus> and in a module-by-module basis
04:15:54 <shapr> Sounds like Epigram too, tried it?
04:16:20 <autrijus> I've read the papers, never programmed in it
04:16:44 <autrijus> I thought it's thoroughly typed and has no dynamic mode?
04:16:46 <autrijus> or am I mistaken?
04:17:18 <shapr> It is thoroughly typed, but as you fill in parts of the program, the rest of the program is then limited in exploitable ways.
04:17:27 <shapr> If you follow the tutorial you'll see what I mean.
04:17:32 <autrijus> ah. right.
04:17:39 <poetix> Cool type-slicing demo. Reminds me of DrScheme a bit (the code-highlighting as feedback mechanism).
04:17:41 <shapr> It's incrementally typed, sort of.
04:17:51 <autrijus> thanks, may I steal that phrase?
04:17:55 <shapr> Sure, go for it.
04:18:03 <shapr> I seriously doubt it's original :-)
04:18:17 <autrijus> it is.
04:18:19 <poetix> shapr: My copy of TaPL arrived yesterday...
04:18:24 <earthy> hm. duck typing. me like.
04:18:26 <shapr> yay!
04:18:31 <autrijus> google found 3 pages only
04:18:33 <autrijus> somewhat relevant
04:18:38 <autrijus> but by no means widespread use
04:18:50 <shapr> shocking.
04:18:53 <autrijus> indeed.
04:19:12 <shapr> I came up with the idea of Firm Typing also.
04:19:38 <autrijus> is it like a law firm with people banging away at typewriters?
04:19:41 <shapr> http://c2.com/cgi/wiki?SoftTyping
04:19:47 <shapr> heh, not exactly
04:20:03 <poetix> Somewhere between Rigid and Soft typing. Other intermediate values include Saggy Typing.
04:20:17 <shapr> Soft Typing is sort of what you're talking about, but Firm Typing would reject provably unworkable programs.
04:20:19 <Tue7657> saggy the clown
04:20:26 <poetix> To the extreme left of Soft Typing is Fluffy typing.
04:20:31 <earthy> saggy typing, as in saggy breasts?
04:20:38 <shapr> um
04:20:40 <autrijus> shapr: I want the rejection definitely
04:21:02 <earthy> provably unworkable. now there's a tough one
04:21:10 <shapr> Soft Typing just says "There's an area beyond what the compiler can understand"
04:21:20 <earthy> how would you guarantee that a firm typing is sound?
04:21:48 <shapr> I'd have two classes of type errors, brain exploded and that just ain't right
04:21:49 <JaffaCake> firm typing isn't sound
04:21:59 <autrijus> I don't think soundness can be guaranteed
04:22:06 <autrijus> doesn't mean it's not useful when people want it though.
04:22:19 * autrijus wants soft soundness :D
04:22:24 <earthy> hm
04:22:25 <earthy> right
04:22:50 <musasabi> http://youzen.b2.fi/~musasabi/bug2.hs - 6 lines to cause the 'Unify.unifyTauTyLists: mismatched type lists!'
04:24:04 <shapr> People regularly complain about GHC when it shuts them down over some quibble with extremely subtle type trickery, for that sort of thing I'd want ghc -soft or something. But adding a char to a number is right out.
04:24:19 <Tue7657> why on earthy would one buy one of douglas adams loose books for more than the complete series ....
04:24:35 <earthy> tue7657: simple: they're more portable
04:24:36 <autrijus> shapr: eh.
04:24:47 <autrijus> instance Num Char where ...
04:24:53 <shapr> Yeah, but outside of that :-)
04:24:53 * earthy grins
04:24:54 <JaffaCake> shapr: you've always got unsafeCoerce#
04:25:03 <shapr> Yeah, true.
04:25:06 <autrijus> shapr: but that is exactly what some people wants.
04:25:10 <earthy> plus, I *like* GHC hitting me over the heasd with type errors
04:25:14 <Tue7657> earthy, not really an argument
04:25:27 <shapr> That's one thing I love about Haskell / GHC, it gives me warnings but never stops me doing stuff.
04:25:31 <df_> tue :: whynot?
04:25:32 <shapr> Unlike Java...
04:25:47 <earthy> you've never commuted long distances, have you, Tue7657?
04:25:58 <df_> a little book fits in my jacket pocket on the train, bus and walk, a big thick one doesn't
04:26:05 <JaffaCake> our philosophy has always been to give you the gun, it's up to you where you point it :)
04:26:11 <shapr> Yeah, I like that.
04:26:39 * autrijus invokes the "GHC has the power of Reason" line again
04:26:39 * earthy finds GHC's gun actually has safetyfeatures built in that make sure you don't shoot the gun itself
04:26:53 <autrijus> all bad guys listen to Reason. really.
04:26:57 <Tue7657> earthy, really whats wrong with an 820 pages book for in the train
04:27:24 <earthy> it's not the 'on the train' part that sucks. it's the 'getting to the train part'
04:27:32 <shapr> Tue7657: You have to allocate space for an 820 page book on a daily basis, but I can keep three or four small books in my backpack and choose according to my mood.
04:27:51 <shapr> "I'm personally of the opinion that functional programming makes it even harder to shoot yourself in the foot, but when you do, all that's left are a few strands of red goo dangling from the shattered remains of your brain pan." --Mike Stone in http://www.perlmonks.org/?node_id=450922
04:28:08 <JaffaCake> heh
04:28:43 <JaffaCake> I heard this one recently, it's old, but I think it deserves to be revived: "functional programmers know the value of everything and the cost of nothing"
04:28:58 <shapr> Put it on the QuotesPage !
04:28:58 <Tue7657> i usually just dont read at all but just listen to music while travelling
04:29:11 <autrijus> I know! the cost of Nothing is storage needed for a single boxed (Maybe a) type!
04:29:13 <shapr> I'm a compulsive reader.
04:29:54 <JaffaCake> well, I know the cost of Nothing down to the last byte :)
04:29:59 <autrijus> however the value of everything is harder to know :)
04:30:05 <shapr> World#
04:30:12 <autrijus> ahhh.
04:30:18 <autrijus> GHC.State# RealWorld#
04:30:24 * shapr snickers
04:30:28 <autrijus> truly the value of everything
04:30:40 * earthy laughs
04:30:42 <JaffaCake> heh
04:31:51 <Tue7657> hmm
04:31:54 <Tue7657> i dont get it
04:31:58 <Tue7657> maybe thats a good thing
04:31:58 <Tue7657> :)
04:32:21 <autrijus> Tue7657: type ":i IO" in ghci sometime :)
04:32:48 <dcoutts_> Since I was feeling slightly inspired after reading JaffaCake's Visual Haskell paper, I've jotted down some ideas for a Free Haskell IDE (aka Manifesto for hIDE 2.x): http://www.haskell.org/hawiki/HaskellIde (see the second section about hIDE)
04:33:20 <dcoutts_> I've heard various mumplings about people interested in starting such a project...
04:33:39 <musasabi> I think that using gtk2hs sourceview control with yi could be one step forward.
04:33:40 <dcoutts_> Feel free to add your ideas / level of interest to that page
04:34:06 <JaffaCake> dcoutts_: great, but why not start from an existing IDE?  An IDE shell is a *lot* of work
04:34:30 * autrijus mumbles something about link against jvm and use eclipse
04:34:43 <dcoutts_> JaffaCake, because we want it to be extensible with Haskell, and because "We have the technology!"
04:34:49 * TFK looks at Haskell IDE
04:35:19 <Tue7657> dcoutts_, sounds like a 'born-dead' project
04:35:40 <JaffaCake> but there's a lot of boring stuff to do like the editor (I suppose there's Yi, though)
04:35:46 <dcoutts_> We've got Gtk bindings, we've got an editor (Yi), we've got a plugins system, we've got a clear feature list
04:35:51 <TFK> dcoutts_, btw, your suggestion didn't work, unfortunatelly.
04:36:17 <JaffaCake> I'm not sure that using Eclipse or something would preclude having extensibility in Haskell
04:36:21 <dcoutts_> we've got a development model (see lambadbot development using darcs)
04:36:59 <JaffaCake> darcs integration would be really nice
04:37:18 <dcoutts_> we've got the new cabal build system we've got the upcomming GHC interface
04:37:35 <JaffaCake> there's still a lot left
04:38:21 <dcoutts_> The Haste guys showed it's possible to build an IDE shell in a couple months with a small team
04:38:35 <TFK> In a couple of months o_O?!
04:38:48 <dcoutts_> how long was it then?
04:38:57 <JaffaCake> ooh, I didn't know about Haste
04:39:16 <TFK> I don't know, but if by "shell" you mean a prototype, it sounds like a lot of time.
04:39:22 <dcoutts_> It was a student project
04:39:45 <TFK> Ah, so they couldn't invest too much hours.
04:39:51 <TFK> *too many
04:42:57 <shapr> Some of these features are already planned (and somewhat implmented) for Yi, so it seems like a good overlap.
04:42:58 <dcoutts_> musasabi, it's basically either sourceview or Yi with Gtk UI for the editor component, since they both do the same thing really, the sourceview would be the quickest to get working but Yi should be better ultimately
04:44:13 <shapr> Hoogle is directly useful in GHCi, probably a good feature to include when Hoogle is released.
04:44:36 <shapr> HaRe already exists, PFE exists, I'm sure we could hammer together a workable IDE just with existing code and some glue.
04:44:59 <dcoutts_> right, all the tools are there, it's just the IDE shell thats missing
04:45:06 <shapr> PFE has 'certificates' that can be QuickCheck, HUnit, or full proofs.
04:45:32 <shapr> Intelligent auto-layout will require a real parser, but I want that anyway.
04:45:36 <shapr> hiya valys
04:45:45 <JaffaCake> good luck - I think it's a great project
04:45:50 <autrijus> I thought GHC 6.6 thing and/or TH is a real parser, no?
04:45:57 <dcoutts_> shapr, in Yi presumably?
04:45:59 <shapr> Right
04:46:19 <shapr> On the good side, a real parser will also give really good syntax highlighting.
04:46:41 <JaffaCake> we didn't use a real parser for highlighting in Visual Studio
04:46:43 <autrijus> fwiw, I'm generating Perl/Parrot objects to represent all Pugs internal structures
04:46:43 <shapr> dons has talked about syntax highlighting that's a decorated parse tree.
04:46:44 <dcoutts_> for that all you need is a lexer (which is faster)
04:46:53 <autrijus> thanks to very nice TH-level analysis
04:47:03 <autrijus> which is "syntax highlighting" but with other languages as colors :)
04:47:28 <JaffaCake> dcoutts_: you can do better with a real parser (like highlight types in a different color) but it means saving more state per line
04:47:49 <shapr> There's preliminary code in Yi already. It's not hooked in yet though.
04:47:50 <JaffaCake> with a lexer you can get away with a single integer state.
04:48:17 <JaffaCake> oh, and the lexer version is more resilient to parse errors earlier in the file
04:48:32 <shapr> Yeah, that's the problem with a parser, you need to do highlighting as the source changes.
04:48:47 <dcoutts_> JaffaCake, yes with current editers it has to highlight types and data constructors the same since they anre not distinguishable lexically
04:48:58 <shapr> There are papers on incremental parsers, but I don't know if they fully handle this sort of thing.
04:49:23 <dcoutts_> I think current highliting is ok, doing what our current editors do would be quite sufficient to start with
04:49:41 <JaffaCake> sure, it's fine
04:49:43 <shapr> I'm just afraid it'll stay that way. Emacs has.
04:49:49 <dcoutts_> the real interesting stuff is making a platform to allow integration of cool other tools
04:50:39 <Lunar^> JaffaCake: btw, has Thomas sent you the House paper?
04:50:45 <JaffaCake> I'm jealous in a way, developing an IDE from scratch will be a heck of a lot easier than writing a VS plugin :-/
04:50:46 <shapr> Of course, I could always get off my butt and fix that problem :-)
04:50:52 <shapr> You can help!
04:50:59 <dcoutts_> JaffaCake, ! :-)
04:51:11 <dcoutts_> no VS.net/COM issues!
04:51:18 * JaffaCake sighs
04:51:41 <JaffaCake> Lunar^: no, haven't seen it yet
04:51:45 <shapr> C'mon, you have lots of time after taking care of family, kids, and GHC, right?
04:51:59 <dcoutts_> (however it'd mean I'd have to fix all the Gtk2Hs bugs that such a project would uncover...)
04:52:01 * JaffaCake glares at shapr
04:52:08 * shapr grins innocently
04:52:47 * JaffaCake is about to double the amount of kids in his family
04:52:51 <shapr> Not that I've had that much spare time for Haskell stuff lately.
04:52:57 <shapr> Wow! Cool! Congrats!
04:52:59 <Lunar^> JaffaCake: congrats :)
04:53:14 <JaffaCake> ta :)  no. 2 is due in a month or so
04:53:39 <ski> JaffaCake : no kid-tuple, then ..
04:53:42 <kzm> Congratulations!
04:53:50 <ski> congrats
04:53:51 <dcoutts_> JaffaCake, and yet more congratulations.
04:54:19 <kzm> Promise us you'll get out 6.4.1 first, though!
04:54:24 * Philippa opens fire on all the dancing rodents
04:54:35 <JaffaCake> heh, I'll do my best
04:54:36 <shapr> Conga rats?
04:54:42 <Philippa> shapr: bingo :-)
04:54:51 <Philippa> (but yeah, 'grats)
04:55:02 * poetix attempts a lame joke about unsafePerformIO
04:55:23 <shapr> Any news on the GHC bug/perf party?
04:55:23 * autrijus captures the exception
04:55:47 <JaffaCake> shapr: plan is to do that in the next couple of weeks
04:56:06 <poetix> whois JaffaCake
04:56:26 * JaffaCake hands poetix a '/'
04:56:30 <shapr> He's that guy over there.
04:56:50 * poetix wiggles the / and looks sheepish
04:57:02 <shapr> JaffaCake: Cool, anything I can put into my TMR editorial?
04:57:56 <JaffaCake> I have a bunch of SMP/multiproc stuff to work on first... so I can't say exactly when we'll be ready
04:58:29 <JaffaCake> I should have a clearer idea in a few days
04:59:23 <shapr> Ok, I'll put the info into TMR if I get it before we 'go to press'
04:59:37 <JaffaCake> sure thing
05:10:50 <CosmicRay> heh
05:10:52 * CosmicRay arrives
05:11:01 <CosmicRay> a very interesting couple of pages of scrollback :-)
05:11:10 <shapr> hiya CosmicRay
05:11:15 <CosmicRay> morning shapr
05:11:57 * Lunar^ wonders where is Syntax
05:12:07 <Lunar^> @last SyntaxPolice
05:12:08 <lambdabot> Maybe you meant: fact part paste
05:12:12 <Lunar^> @seen SyntaxPolice
05:12:13 <lambdabot> I haven't seen SyntaxPolice.
05:12:17 <Lunar^> @seen SyntaxNinja
05:12:18 <lambdabot> I saw SyntaxNinja leaving #haskell 11 hours, 11 minutes and 15
05:12:18 <lambdabot> seconds ago.
05:12:28 <Lunar^> uh
05:12:41 <CosmicRay> I haven't seen him in awhile either
05:14:16 <shapr> I hope Wouter finishes his Attribute Grammars article.
05:14:25 <shapr> That would give me four articles.
05:15:00 <CosmicRay> shapr: 7/1 is the go-live date, eh?
05:15:15 <shapr> Probably
05:15:37 <shapr> Unless someone needs a coulpa more days to finish the fifth article.
05:15:42 <CosmicRay> ok.  I should check to be sure, but I think that you could have my FSM Haskell article for the 8/1 edition
05:15:49 <shapr> Spiffy!
05:16:21 <shapr> dcoutts_: gtk2hs for 8/1 ?
05:16:27 <CosmicRay> the question is just how soon does the license turn free -- 1 month after the date it appeared on the website, or one month after the cover date of the magazine
05:16:29 <poetix> shapr: I might go back and look at my Randomly Balanced Trees implementation, and see if I can make an article on it
05:16:51 <shapr> I would like that :-)
05:17:22 <dcoutts_> shapr, 8/1 that's the August one? hmm, possibly. I'm trying to improve my prog since I'm demoing it tomorrow at a depatement open day...
05:17:26 <shapr> I'd be thrilled if TMR starts having more than five articles an issue, but I'm fine with five every month.
05:17:39 <reffie> randomly balanced trees?
05:17:49 <autrijus> shapr++ # TMR -- can't ++ you enough
05:17:56 <shapr> I'm glad you like it :-)
05:17:59 <poetix> Interesting data structure - each new node is tagged with a random value, and you have to preserve the invariant that the tag of any node is greater than the tag of either of the nodes beneath it
05:18:06 <shapr> autrijus: Thanks for being an author!
05:18:27 <autrijus> shapr: If you like my slides I can compress it into another article :)
05:18:33 <autrijus> I think it's still relevant to Hs
05:19:01 <poetix> This results in continuous shuffling of nodes so that even if you add an ordered list to the structure, you end up with a more or less balanced tree
05:19:31 <poetix> It turns out to have fairly good space/time complexity, although analysing that in detail is rather beyond my competance.
05:19:33 <shapr> autrijus: Yes, definitely. I don't think any journal or periodical has had the chance to chronicle the development of a large FP app.
05:20:50 <shapr> I'd be interested in how much of the code is Haskell, and how much is Perl6 written on top of primitives.
05:23:23 <Philippa> Anyone wanna take a look at the next Impure Thoughts? http://www.haskell.org/tmrwiki/ImpureThoughts_2f2
05:24:35 * earthy looks at Mistress Philippa with slightly different eyes
05:26:54 <poetix> "Some people dress for success / and press the flesh under savage duress. / Me I stay quiet 'til the moment is right - / then stand back if you don't want a terrible night..."
05:27:11 * Philippa grins
05:27:17 <shapr> Is that ninety words?
05:27:19 <Philippa> FWIW I'm switch :-)
05:28:26 <ski> 'dom' = ?
05:29:05 <Philippa> top, dominant etc etc etc
05:29:11 <poetix> My first name
05:29:26 <ski> k
05:29:42 <musasabi> nice introduction to the article :-)
05:31:25 <earthy> philippa: it's a bit light on actual content, it seems
05:31:39 <earthy> it hints at stuff but doesn't always deliver
05:31:46 <Philippa> earthy: it's not meant as a how-to on type hackery. I know what you mean though
05:32:07 <poetix> I like the idea of type-hackery as restraint-artistry
05:32:26 <earthy> yeah, but it's like 'we can do this and that and such and so' but no reasoning as to why you might want that or how it would look
05:32:56 <Philippa> what'd you pick out as the worst offender for "why would I do this?"?
05:33:24 <earthy> the unsafewords stuff
05:33:49 <Philippa> ah. Well, most people aren't supposed to (have occasion to) want to
05:34:01 <ski> s/data BelongsToFoo = BelongsToFoo (forall a.(Foo a) => a)/data BelongsToFoo = forall a. (Foo a) => BelongsToFoo a
05:34:05 <TFK> Oh, B&D discussion.
05:34:30 <TFK> "bondage-and-discipline language: n.
05:34:30 <TFK>     A language (such as Pascal, Ada, APL, or Prolog) that, though ostensibly general-purpose, is designed so as to enforce an author's theory of âright programmingâ even though said theory is demonstrably inadequate for systems hacking or even vanilla general-purpose programming. Often abbreviated âB&Dâ; thus, one may speak of things âhaving the B&D natureâ."
05:34:32 <musasabi> Philippa: When you are talking about existential wrapping it might make sense to discuss the alternatives - e.g. a record of functions. Also the existential wrappers are not so nice when they start cascading.
05:34:54 <shapr> hiya zyff
05:35:03 <zyff> hi shapr
05:35:08 <shapr> How's code?
05:35:15 <Philippa> musasabi: maybe. They're less useful in that context IMO though
05:35:24 <musasabi> That is with the existential wrapper being a member of the typeclass and being passes to function which existentially wrap the existential wrapper.
05:35:25 <zyff> getting very higher order
05:35:30 * Philippa nods
05:35:34 <ski> Philippa : got that ?
05:35:36 <shapr> zyff: sounds nice
05:35:44 <TFK> The problem is not with the typing, the problem is with Haskell being with the "pure good; side-effects bad" mindset, which limits the options for the programmer.
05:35:50 <Philippa> I might put a warning in about that
05:35:59 <zyff> have you ever done higher than 4th order?
05:36:12 <shapr> It depends on how you count monads.
05:36:15 <Philippa> TFK: point-head-whoosh - why do you think the column's called impure thoughts?
05:36:18 <TFK> (That mindset need not be good and bad, the point is that it's single and exclusive of other mindsets.)
05:36:23 <shapr> With monad transformers and arrows, 4th order is easy to beat.
05:36:49 <zyff> Do you have any example on the wiki?
05:37:00 <zyff> of useful 5th+ order code
05:37:01 <TFK> To prepare the reader for shoking words that may not sit well with the average Haskelleer?
05:37:20 <shapr> zyff: monad transformers.
05:37:44 <Philippa> TFK: because the column's at least partially about recovering the ability to do all the things that're supposedly bad (and often good fun)
05:37:52 <shapr> zyff: Read "All about Monads" - http://www.nomaware.com/monads/
05:38:30 <Philippa> many Haskellers aren't about purity-everywhere at all, often it's a controlled-impurity thing
05:38:45 <Philippa> that is, knowing all the ways it's possible to shoot yourself in the foot in a given piece of code
05:38:47 <shapr> Yeah, I'd say Haskell is more about knowing the difference.
05:39:15 <Philippa> that's why monads're such a gift to those who like their type systems
05:39:18 <xerox> hi.
05:39:22 <Philippa> 'lo
05:39:45 <zyff> I have good at monads theoretically but never actually used anything other than the IO and the Exception monad (if you not count list-comprehension as monadic)
05:40:53 <zyff> I saw some good comparison between UnixShell programming and Monads, http://okmij.org/ftp/Computation/monadic-shell.html
05:41:05 <shapr> Yeah, everyone loves Oleg.
05:41:13 <kzm> Anybody have problems with GHC 6.4 incorrectly reporting incomplete patterns?
05:42:43 <zyff> shapr: I thought Maybe monad and Error monad are the same
05:42:43 <xerox> kzm, it happened to me before - I fixed it changing the way I was pattern-matching.
05:42:54 <shapr> zyff: Nope, but related via the Either type.
05:43:00 <arjanb> kzm: http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs.html#bugs-ghc
05:43:24 <Tue9531> i'd say attribute grammars are a gift
05:43:27 <Tue9531> :$
05:43:36 <zyff> shapr: so one should generalise the other
05:44:04 <Philippa> Tue9531: show me IO with them and I might buy it
05:44:23 <Philippa> they look neat in some places, but I'm really not convinced they're good for the same level of semantic fun'n'games
05:44:39 <shapr> I don't see how AGs compare to arrows at all.
05:45:10 <TFK> That's not quite the point. What other ways are there to make life easier besides monads? How many ways exist doing the same thing even with monads? etc.
05:45:23 <reffie> http://data.4chan.org/b/src/1119958840317.jpg
05:45:37 <shapr> TFK: It's like saying how many ways exist of doing the same thing even with objects?
05:47:38 <Philippa> AFAICT, AGs can't represent something that can't be written in the host language
05:47:41 <Philippa> that's a big deal
05:47:56 <TFK> No, it's not. In Python, for example, the concept of object is pretty transparent.
05:47:56 <TFK> But the programmer isn't forced to use this or that particular method. Thus the B&D factor is lower.
05:48:09 <ski> from my limited knowledge about AGs, i'd say they overlap a little (Reader,State,Writer, more ?) but are mostly about different things
05:48:18 <shapr> Monads can do more than objects.
05:48:35 <shapr> reffie: Dude, don't paste NSFW urls here.
05:48:47 <TFK> What's "AG?
05:48:53 <shapr> Attribute Grammar
05:49:07 <ski> Philippa : hm, what examples of things that can't be written in host language are you thinking of, here ?
05:49:24 <Philippa> facilities like IO, ST, STM...
05:49:34 <Tue9531> do i dare ask wtf that pic is reffie lol
05:49:48 <TFK> Doesn't matter what they do. But they're the only way, is that not so?
05:50:15 <Philippa> no, there're other monad-like methods. But doing what monads do needs something fairly closely related
05:51:05 <Philippa> (sure, you can go off and write C instead)
05:51:08 <TFK> Consider GUIs, for example. I've heard of functional GUI projects, but afaik existing bindings for wx and GTK don't deviate that much from the OO model.
05:51:21 <Philippa> that's because they're straight bindings of the underlying libs
05:51:23 <ski> IO,ST can be done with linear- / uniqueness- typing  (from which one can in-language rebuild the monads, of course)
05:51:26 <shapr> hscairo has an arrows binding.
05:51:33 <shapr> Fudgets is not at all OO.
05:51:37 <TFK> Indeed. But it also means that you can't program like in Haskell.
05:51:39 <Philippa> wxFruit is notable
05:51:44 <TFK> *like that
05:51:46 <shapr> wxFruit is heavily arrow-based.
05:51:56 * Philippa sighs
05:52:16 <Philippa> TFK: point-head-whoosh. Use the IO monad when you've cause to. And you can program like anything you want given the necessary hooks in the IO monad
05:52:32 <TFK> What is "point-head-whoosh"?
05:52:50 <Tue9531> her new stopword
05:53:03 <Philippa> shorthand for "my point appears to've flown over your head"
05:53:15 <TFK> Philippa, point-head-whoosh.
05:53:18 <TFK> ^_^
05:53:31 <shapr> TFK: wxFruit and several other GUI projects do deviate heavily from the OO model.
05:53:41 <Philippa> Haskell apps aren't supposed to be all-pure. No real application is.
05:53:52 <CosmicRay> heh, the ghc survey results are fun to read
05:53:58 <CosmicRay>  "GHC is honking huge but very nice and impressive."
05:54:06 <TFK> 0.1, May 2004. Is the project alive?
05:54:39 <Philippa> probably not. Someone else can pick it up sometime though, and the underlying mechanisms're understood - the difficulty was in building them on top of wxHaskell
05:54:47 <TFK> Philippa, but more liberal languages make it easier, no?
05:55:27 <shapr> I claim that Haskell is more liberal than Python.
05:55:31 <Philippa> 'easier' amounts to being able to leave out a few returns
05:55:38 <CosmicRay> shapr: I agree, but don't let Bush hear you.
05:56:09 <Philippa> within the IO monad, and especially with GHC's extensions, Haskell's exceedingly capable and pretty liberal
05:56:13 <TFK> shapr, really?
05:56:34 <shapr> Yes, really.
05:56:43 <TFK> How do I add two IO Doubles without lifting or binding them to temporary names?
05:56:53 <CosmicRay> TFK: yeah I agree.  haskell has static type checking, which is a good thing, but type inference means it doesn't get in your way
05:56:58 <shapr> Using unsafewords?
05:57:05 <CosmicRay> I hate it when my Pthon programs crash with an obscure TypeError
05:57:06 <TFK> unsafewords?
05:57:12 <Philippa> TFK: you don't. Deal with it.
05:57:14 <TFK> CosmicRay, the point is not about typing.
05:57:14 <shapr> Like, unsafePerformIO
05:57:28 <shapr> With Haskell, you can always do something if you really want to do it.
05:57:29 <CosmicRay> oh, what is the point?  (sorry, I was afk for awhile)
05:57:51 <Philippa> CosmicRay: the point appears to be "monads're tedious"
05:57:54 <TFK> CosmicRay, http://catb.org/~esr/jargon/html/B/bondage-and-discipline-language.html <--- my point is that Haskell enforces a pretty narrow style of programming
05:58:01 <Philippa> no it doesn't
05:58:13 <CosmicRay> TFK: ah.
05:58:14 <CosmicRay> I disagree.
05:58:18 <Philippa> it does rather the opposite. I've written erlang-style threads-as-objects code in it before...
05:58:30 <CosmicRay> I have used these B&D languages and haskell feels *nothing* like them
05:58:56 <TFK> Well, I can't speak for any other languages but Python.
05:58:59 <CosmicRay> what makes you think haskell falls into that category?
05:59:33 <Philippa> CosmicRay: I've heard ML-like type systems described as B&D, sadly
05:59:39 <CosmicRay> sigh
05:59:46 <CosmicRay> even ocaml doesn't feel like that to me
05:59:55 <poetix> What happened to Vyper?
05:59:58 <Philippa> I suspect SML would irritate me
06:00:02 <CosmicRay> ocaml typing is second only to haskell in terms of power, IMHO
06:00:09 <xerox> Needle!
06:00:13 <TFK> Consider the example of adding two IO Doubles. Or the tediousness of programming a GUI with bindings that are alive *right now*.
06:00:26 <shapr> Vyper sort of died, and then turned into Felix sort of.
06:00:42 <xerox> I think needle type system is very powerful.
06:00:44 <Philippa> TFK: that tediousness is no worse than the tediousness of doing it in any other language I've used
06:00:49 <TFK> The code doesn't flow. At least not at the IO layer.
06:01:09 <poetix> A Haskell version (Hyper?) would be an interesting thing to wave at people.
06:01:13 <shapr> TFK: give us examples!
06:01:15 <Philippa> and the just-adding case is about as bad as it gets. As soon as you're doing anything more complicated with them it works out fine
06:01:21 <CosmicRay> TFK: I dunno, in Python, you'd say:
06:01:24 <CosmicRay> x = readDouble
06:01:27 <CosmicRay> y = readDouble
06:01:29 <CosmicRay> z = x + y
06:01:32 <CosmicRay> in Haskell, you'd say:
06:01:33 <TFK> CosmicRay, no.
06:01:34 <CosmicRay> x <- readDouble
06:01:37 <CosmicRay> y <- readDouble
06:01:40 <CosmicRay> let z = x + y
06:01:51 <TFK> In Python you'd say, z = get_x() + get_y()
06:02:04 <xerox> Blurb.
06:02:17 <TFK> To scroll a window donwards: adj.value = adj.upper - adj.page_size # IIRC
06:02:38 <TFK> That stuff accumulates.
06:02:45 <CosmicRay> TFK: right, that isn't as nice in haskell, true.
06:02:51 <Philippa> TFK: state-modification functions are your friend
06:03:10 <TFK> Just how many functions do I need to know? How many papers do I need to read?
06:03:15 <Philippa> take the entire object as a parm - foo {value = upper foo - page_size foo}
06:03:26 <CosmicRay> TFK: I haven't really read any Haskell papers thus far.
06:03:31 <mflux_> hasn't anyone written a dsl with the aim of making writing that stuff more straight forward?
06:03:35 <mflux_> or is it difficult
06:03:38 <shapr> Which stuff?
06:03:54 <xerox> scanf?
06:03:56 * xerox hides
06:03:59 <poetix> Working with OO-style GUI lib bindings
06:04:03 <xs> mflux_: istm wxhaskell/yampa does that?
06:04:12 <CosmicRay> TFK: I think the Haskell standard library is *far* more sane than, say, the Java one
06:04:15 <mflux_> xs, maybe ;)
06:04:21 <TFK> CosmicRay, you must be very smart. I'm still stuck on monads. Not for long, hopefully. The tutorials on them seem pretty good.
06:04:23 <CosmicRay> TFK: I don't need the API reference by my side constantly with Haskell, at least
06:04:29 <mflux_> yampa might have some promise, as it isn't a binding for something else?
06:04:45 <TFK> Java is not a good comparison, being high on the B&D factor itself.
06:04:45 <Itkovian> CosmicRay: proficient Java programmers don't either ...
06:04:47 <Philippa> TFK: the main trick is that you can do a lot of stuff in a single binding. This often saves a scary amount of typing - maybe not so much compared to Python, but plenty compared to the C-derivatives
06:04:48 <CosmicRay> TFK: no, and I was stuck on them too, until I found two tutorials (What The Hell Are Monads and some other one that shapr sent along whose name I forget)
06:05:00 <CosmicRay> Itkovian: yeah, just ask one of them how to read a string from the keyboard :-)
06:05:12 * Itkovian is still half stuck on Monads
06:05:18 <xerox> Anyway, you could embody the patterns in general abstractions.
06:05:27 <TFK> Philippa, I never said anything about the B&D factor of other languages, bar Python.
06:05:34 <mflux_> anyway, tfk's problem is only using monads, right? I think using ocaml's lablgtk2 is quite nice.
06:05:38 <CosmicRay> "And a fair few people worry about Bus Errors in Cambridge:"...  "... I'm worried about busses in Cambridge, and the effect they may have on Simon and Simon.... :)"
06:05:49 * earthy grins
06:05:57 <Itkovian> I grok the examples, but writing it myself still seems very difficulet
06:06:09 <xerox> @google all about monads
06:06:11 <lambdabot> http://www.nomaware.com/monads/html/
06:06:13 <xerox> CosmicRay, that one?
06:06:14 <CosmicRay> that's the one
06:06:15 <Philippa> TFK: your complaints're low-level syntactic issues
06:06:20 <Itkovian> thta's a good tutorial
06:06:23 <xerox> It's well written.
06:06:36 <Philippa> bear that in mind - shae's claim is largely about high-level semantic issues, where Haskell is highly impressive
06:06:37 <TFK> I don't have that big of a problem, I'm just pointing out that imo, Haskell is high on the B&D factor. Whether this is good or bad... I can't say yet ;-)
06:06:45 <CosmicRay> TFK: you have a point about being able to use I/O directly in calculations, though in truth, it hasn't bothered me since I don't mind writing it out.
06:06:58 <CosmicRay> TFK: however you are not considering many of the uber-cool features of haskell
06:07:02 <TFK> Philippa, hopefully, I will see that for myself very soon ;-)
06:07:15 <earthy> features schmeatures :P
06:07:29 <CosmicRay> TFK: for instance, I, a not-very-skilled Haskeller, developed a working prototype for an equation formatter and a numeric type carrying units, in an hour or two, and 200 lines of code
06:07:34 <CosmicRay> TFK: this is simply *not possible* in Python
06:07:37 <Philippa> TFK: have a play with Control.Concurrent and the networking stuff, write a simple text-mode client for something. That's a fun one to do
06:07:44 <CosmicRay> since Python doesn't support custom numeric types
06:07:54 <earthy> cosmicray: that is not entirely true though
06:07:59 <CosmicRay> TFK: http://changelog.complete.org/node/339
06:08:07 <CosmicRay> earthy: which, that python doesn't support custom numeric types?
06:08:11 <Itkovian> @google What The Hell Are Monads
06:08:12 * earthy nods
06:08:12 <lambdabot> http://www.cs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html
06:08:21 <CosmicRay> earthy: really?  is this something new?
06:08:32 <Tue9531> @google What The Hell Are Monads Not
06:08:34 <lambdabot> http://www.cs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html
06:08:38 <CosmicRay> heh
06:08:50 <TFK> CosmicRay, I'll grant you that. But my interest lays mostly (at least right now) in user-space applications. It is claimed that Haskell is better at it than other languages.
06:08:53 <earthy> http://www.python.org/doc/2.4.1/ref/numeric-types.html
06:08:58 <earthy> and no, it's not new
06:09:09 <earthy> I've known about this for oh... 4 years or so already?
06:09:15 <CosmicRay> hmmph!
06:09:25 <CosmicRay> wonder how I missed it all this time
06:09:25 <TFK> Philippa, I've written a small IRC client, and a CGI script so far. The other challenge I haven't answered yet was generators.
06:09:36 <Philippa> TFK: was the client multi-network?
06:09:40 <TFK> Does anyone here know Icon and/or Unicon?
06:09:40 <CosmicRay> TFK: I plan to port all my Python apps to Haskell.
06:09:47 <TFK> Nope, it is extremely simple.
06:09:56 <CosmicRay> TFK: I expect the result to have approximately half the lines of code as the Python program, and be more maintainable to boot.
06:09:56 <Philippa> OK. Try the multinetwork case, that's a fun one for a couple of hours
06:10:15 <CosmicRay> TFK: I have already done some of this; darcs-buildpackage is essentially a Haskell port of my earlier Python-based tla-buildpackage program
06:10:29 <TFK> I doubt it :-/ there seems to be issues with threading for now, so I'll wait for the green light from dcoutts_.
06:10:31 <earthy> TFK: Icon is a stream processing language, right?
06:10:49 <Philippa> TFK: fair enough. You could do it with a text mode UI?
06:10:52 <TFK> It's a strong point of it, yes.
06:10:58 <TFK> Like curses?
06:11:00 <Philippa> really it's just the concurrency/IO workout that's the fun bit
06:11:05 <TFK> I've heard that curses is not very nice :-/
06:11:16 <xs> hence the name ;-)
06:11:16 <Philippa> like repeated calls to get/put strings, even
06:11:28 <TFK> I suppose I can try it out.
06:11:42 <CosmicRay> TFK: BTW, you may be interested in MissingPy
06:11:49 <CosmicRay> TFK: it lets you call Python stuff from in Haskell
06:11:55 <Philippa> FWIW, I agree the situation for GUIfied user apps isn't good
06:12:01 <TFK> Ah, but that's kinda like cheating, isn't it? :-P
06:12:23 <Tue9531> ow wow...im pleasently surprised about the speed of my haskell app :$
06:12:42 <Tue9531> i was prepared for a core dump or so lol
06:12:42 <CosmicRay> Philippa: yeah, but then it sucks everywhere else too.  Python gives you this evil Tcl hybrid that is prone to segfaulting, Java gives you evil AWT or almost-as-evil Swing....
06:13:02 <CosmicRay> Tue9531: heh, it takes someone with l33t skillz to make a haskell program coredump
06:13:09 <CosmicRay> that, or a C binding :-)
06:13:09 <TFK> Pretty much most user-space apps have some sort of GUI in them, barring shell stuff.
06:13:11 <Philippa> CosmicRay: true. Haskell has seriously spoilt my expectations in a lot of ways
06:13:31 <Philippa> TFK: some don't need really good libs though
06:13:34 <Tue9531> ok lets just say...i was preparing myself for an out of memory thingie and half an hour of calculation
06:13:41 <CosmicRay> hehe
06:13:42 <TFK> What do you mean?
06:13:55 <CosmicRay> TFK: I think that GUI interfaces for most things are overrated
06:14:01 <tomdavie> anyone got any good ideas on how to debug a stack overflow?
06:14:19 <CosmicRay> tomdavie: do you know what function is causing it?
06:14:22 <Philippa> some apps just need a handful of buttons and a few labels. You don't need wonderful GUI support for that
06:14:25 <TFK> CosmicRay, whatever makes the user happy is a good thing.
06:14:38 <CosmicRay> philippa: http://www.haskell.org/hat
06:14:44 <TFK> What about Haste, for example?
06:15:02 <bourbaki> sabah al-chair
06:15:03 <tomdavie> cosmic: not a clue... the most information I have is one input that crashes it and another similar that doesn't
06:15:11 <TFK> A full featured IDE is expected to be pretty flexible, i.e., have a lot of buttons and options and key-bindings :-P
06:15:17 * Philippa would love to be able to clone something like Impulse Tracker's UI easily, but no GUI lib'd touch that
06:15:29 <CosmicRay> err tomdavie: see that hat url
06:15:41 <tomdavie> cosmic: that's what I'm writing ;)
06:15:44 <CosmicRay> hat is a haskell debugger
06:15:47 <CosmicRay> oh...
06:15:48 <CosmicRay> heh
06:15:51 <bourbaki> you could write a mini wrapper for ogre3d
06:15:53 <CosmicRay> you are hacking hat itself?
06:16:01 <bourbaki> that has several UIs
06:16:15 <kzm> xerox, arjanb : thanks for the answers.  I see it's a known issue.  (Sorry about the delay, was thinking for a change)
06:16:23 <tomdavie> well... not hacking it... I work on it at Kent... but I'm writing a new view
06:16:44 <tomdavie> and I can't be arsed trying to compile hat with hat
06:16:55 <CosmicRay> heh :-)
06:17:29 <ndm> tomdavie: which view? (its Neil)
06:17:34 <tomdavie> mostly because the backend I have not much clue about just now... so it would be a world of work
06:17:42 <tomdavie> neil: pretty-hat
06:17:51 <ndm> which does?
06:18:15 <tomdavie> this... http://www.cs.kent.ac.uk/people/rpg/tatd2/fib.pdf
06:18:55 <ndm> generates that, or gives you a nice GUI to navigate around that?
06:19:04 <Tue9531> that's one sick ass drawing
06:19:16 <tomdavie> generates it... it would be fairly easy to tack on a gui
06:19:48 <tomdavie> it uses dot to make draw it, so you could just grab out the attributed dot file
06:20:03 <ndm> thats pretty cool, i'm sure i saw something like that before
06:20:04 <tomdavie> s/make//
06:20:14 <ndm> but it might have been the internal structure, rather than the user structure
06:20:36 <tomdavie> yeh... hat-check -g does it... but as you say it's the internal structure and is not very easy to understand
06:20:48 <ozone> Philippa: have you seen schism tracker?
06:20:55 <tomdavie> spot the better algorithm... http://www.cs.kent.ac.uk/people/rpg/tatd2/goodFib.pdf
06:22:28 <tomdavie> for some reason it dies if I try doing it on the version of fib that works by generating pairs though... :/
06:23:07 <Philippa> ozone: nope?
06:23:21 <ozone> Philippa: http://rigelseven.com/schism/
06:23:33 <ozone> it's pretty nice
06:23:42 <Philippa> just googled it. Am a windows user by-and-large though
06:23:51 <Philippa> what I really want is IT-with-VST(i)s
06:24:22 <Itkovian> eh?
06:25:03 <ozone> Philippa: nod
06:25:27 <tomdavie> hmm... found one that runs for ever... obviously there's a cyclic call in there... but I'm damned if I know what it is
06:25:37 <ndm> black-hat?
06:26:03 <tomdavie> yeh... but hat can't easily be built with tracing support
06:26:09 <ndm> doh
06:26:12 <tomdavie> indeed
06:26:55 <tomdavie> I keep meaning to do that... but I think it's quite a major job
06:27:17 <ndm> wait til hat+nhc is done, then it should be a few minutes
06:27:35 <Tue9531> is nhc widely used?
06:27:41 <Tue9531> i thought it was as good as dead
06:28:01 <tomdavie> that's true
06:28:14 <ndm> its true, but i have a friend with a vested interest in bringing it back to life
06:28:19 <tomdavie> you got any idea how far tom is on getting it finished?
06:28:24 <ndm> so hopefully, soon it will be working well
06:28:36 <ndm> a month maybe at a guess
06:28:51 <Tue9531> why would you want to use nhc then?
06:29:00 <Tue9531> does it have specific features you like?
06:29:13 <tomdavie> well... in a months time... because you wont need to use hat-trans
06:29:24 <tomdavie> it will be able to compile tracing binaries straight off
06:29:32 <ndm> and it will have some pretty impressive features
06:30:03 <Tue9531> but a compiler revival by one person.....isnt that a bit....naive?
06:30:23 <ndm> Tue9531: You haven't met Tom (not tomdavie, another Tom)
06:30:30 <tomdavie> lol
06:30:54 <tomdavie> and he does have the backing of quite a few people in York doesn't he?
06:31:10 <ndm> i am going to help out a bit
06:31:18 <ndm> i intend to do a WinNhc
06:31:25 <ndm> like WinHugs, but 10 times better :)
06:31:32 <TomShackell> hello
06:31:32 <tomdavie> lol
06:31:35 <tomdavie> lo tom
06:31:57 <tomdavie> so... what exactly would winNhc do... other than compile shit?
06:32:21 <tomdavie> mmm... chocolate... bbiam
06:32:31 <TomShackell> lo bob
06:33:16 <ndm> WinNhc will compile stuff, debug stuff, be like GHCi and Hugs rolled into one plus a compiler
06:34:26 <TFK> Don't forget the kick-ass shell ;-)
06:34:31 <tomdavie> ah... so an IDE... including hat and nhc?
06:34:56 <ndm> not really an IDE, I'm hoping I can get away with about 400 lines of C
06:34:59 <tomdavie> I want to kick apple and tell them to stick Haskell support in XCode
06:35:05 <tomdavie> ah... okay
06:35:13 <ndm> calling into nhc, hmake and hat as required
06:35:23 <ndm> and hopefully integrated with TextPad and VisualHat
06:35:28 <TomShackell> lol
06:35:38 <tomdavie> will you not need to write a load of new code every time someone writes a new view?
06:35:58 <ndm> you saw my presentation on VisualHat
06:36:05 <tomdavie> m'hum
06:36:11 <ndm> once that is done, no one will ever want another view (maybe...)
06:36:16 <TomShackell> lol
06:36:44 <tomdavie> was actually thinking... pretty hat, with clicky buttons to expand bits of graph would be essentially visual-hat
06:37:10 <TomShackell> the tricky bit would be portability
06:37:16 <tomdavie> indeed
06:37:30 <tomdavie> because wxWidgets suck on all platforms
06:37:55 <ndm> no, portability isn't a problem - because i only use Windows
06:38:06 <TomShackell> lol
06:38:09 <tomdavie> haha!
06:38:25 * tomdavie gets the big sharp stick out
06:38:35 <ndm> i intend to do a visualhat prototype in C#, Win only with Mono for Linux
06:38:48 <ndm> and then once the interface is fixed, rewrite it in C++
06:39:04 <ndm> with a custom written thin platform compatability layer
06:39:30 <tomdavie> hmm... yeh... tbh... for GUI stuff I think *not* portable is better
06:39:54 <tomdavie> a UI designed for all platforms never works on any platform
06:40:14 <ndm> visual-hat will be unlike most UI's - very few standard widgets, lots of TextOut stuff
06:40:51 <tomdavie> yeh... which is why every OS X user on the planet is going to hate you
06:40:56 <tomdavie> :D
06:43:39 <Itkovian> tomdavie: we will simply put a not-my-problem-field around him
06:43:47 <tomdavie> haha
06:44:03 * CosmicRay personally is not convinced that IDEs are useful inventions
06:46:03 <TFK> What's really useful is syntax coloring and intelligent layout.
06:47:12 <SM_ax> i like keyword completion
06:47:50 <SM_ax> the one implemented in vim is good enough for me
06:48:04 <tomdavie> hmm... SEE has syntax highlighting and keyword completion now
06:48:28 <tomdavie> although... I could do with adding support for data type names and constructors too
06:49:16 * poetix gets tied up in threaded state, yelps an unsafeword, and is dragged down into dismal regions of unspeakable suffering by snarling Cenobites
06:50:31 <Tue9531> justice
06:51:02 <drbean> Where's the logs for #haskell?
06:51:24 <CosmicRay> drbean: you might glance at the topic, the url is there
06:51:32 <Tue9531> where's the topic
06:51:33 <Tue9531> :P
06:52:19 <CosmicRay> type /topic
06:52:27 <CosmicRay> you see it when you join the channel
06:52:34 <CosmicRay> --- Topic for #haskell is ["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueThree","Haskell rules","ICFP Contest! http://icfpc.plt-scheme.org/","ghc added to Fedora Extras"]
06:56:01 <TFK> drbean, the devil's in the details.
06:56:06 <TFK> And so is your soul :-/
06:59:20 <Enveigler1> Sorry to anyone who saw me ask this question earlier, but I still haven't found an answer I understand. Can anyone explain what the term "lifting" means in Haskel?
06:59:56 <shapr> Enveigler1: It means putting a value into a monadic container.
07:00:11 <shapr> http://www.haskell.org/hawiki/MonadsAsContainers
07:01:34 <TheHunter> Enveigler1, it's not a clearly defined word, it can mean different things in different circumstances.
07:01:38 <TheHunter> one attempt:
07:01:45 <TheHunter> @wiki Lifting
07:01:47 <lambdabot> http://www.haskell.org/hawiki/Lifting
07:04:59 * aheller wonders, mostly for humor, whether the join function relies on the Axiom of Choice. 
07:05:21 <earthy> which join
07:05:41 <aheller> join :: (Monad m) => m (m a) -> m a
07:05:49 <earthy> it doesn't
07:05:50 <earthy> IIRC
07:05:53 <aheller> Really, I just saw ``If I have a box of boxes of apples (m (m a)) then I can take the apples from each, and put them in a new box (m a).''
07:06:03 <aheller> and was doing something less interesting than logic at the time :)
07:06:32 <earthy> aheller: but that doesn't need AoC
07:06:39 <kosmikus> nothing infinite, so no AC
07:06:41 <earthy> as you're *given* return, which does that
07:06:50 <shapr> hoi kosmikus, ltns
07:06:50 <earthy> um? nothing infinite???
07:06:56 <aheller> Could I not have an infinite list?
07:07:06 <Enveigler1> TheHunter: I've been there (http://www.haskell.org/hawiki/Lifting), and have to agree with " -- XXX There must be a better definition"
07:07:26 <earthy> (and I should read before responding, bad arthur)
07:07:51 <kosmikus> hoi shapr
07:07:53 <Tue9531> hey kosmikus, can i prevent lhs2tex from indenting my code blocks?
07:08:07 <kosmikus> yes, I'm relatively busy
07:08:20 <Tue9531> ok
07:08:20 <aheller> earthy: prostrating myself before higher intellects here, how does return change things?
07:08:38 <earthy> aheller: as i said, I should read before responding. disregard that comment
07:08:54 <kosmikus> Tue9531: set mathindent to 0pt ?
07:08:59 <earthy> but, mu: M (M A) -> M A is given
07:09:08 <earthy> so, there's no need for an axiom of choice
07:09:24 <Tue9531> kosmikus, i will check it, ty
07:09:37 <shapr> kosmikus: Any ideas for an lhs2tex moinmoin plugin? Oleg suggested that for making TMR academic-friendly.
07:09:45 <aheller> definately a superior intellect :).  I need more theory, clearly.
07:10:01 <shapr> g'day olliej
07:10:01 <kosmikus> shapr: good idea, but I don't know anything about MoinMoin, so I can't say if it's realistic
07:10:08 <olliej> morning
07:10:09 <olliej> :)
07:10:29 <earthy> aheller: nope, you just need to separate concepts ;)
07:10:30 <shapr> kosmikus: I've written mm plugins, but I know nothing about LaTeX or lhs2tex.
07:10:37 <earthy> AoC and join are fully orthogonal. :)
07:10:58 <Tue9531> but are they perpendicular?
07:11:01 <aheller> I haven't really done any set theory with types...
07:11:02 <kosmikus> shapr: ok, let's talk at some point ... but not now :)
07:11:05 <shapr> sounds good
07:11:23 * earthy hits Tue9531 over the head with a monad
07:11:30 <Tue9531> hahaha
07:11:32 <earthy> 'perpendicular' ts. :)
07:11:32 <aheller> ...this is because the set theory course never got taught, and I had a pile of other things to read, not for lack of interest.
07:11:37 <Itkovian> OT: http://media.santoalt.com/funnypictures/insured_by_mafia.jpg
07:11:46 <earthy> ah. right.
07:12:19 <Tue9531> and now you end up with earthy being intellectual superior....damn
07:12:30 <shapr> I thought he always was?
07:14:10 <earthy> anyway, AoC states roughly that a choice function exists
07:14:50 <earthy> with monads however, one is *given* a join
07:15:45 <aheller> I see, I think.  So join, being that choice function, *is* the axiom, to the extent it might exist or be meaningful.
07:16:54 <ski> hm, wouldn't join be more related to the union axiom ?
07:17:00 <earthy> but join does not imply AoC
07:17:21 <earthy> if I read things correctly
07:17:46 <TFK> What's AoC?
07:17:53 <shapr> Axiom of Choice
07:17:54 <ski> axiom of choice
07:18:10 <aheller> oh, I thought we were talking abou Aspect Oriented Coding :)
07:18:15 <shapr> heh
07:18:22 <shapr> monads > AoP
07:18:30 <TFK> aheller, different target audience.
07:18:40 <ski> earthy : well ?
07:18:43 <aheller> sorry, my dayjob is in ruby :)
07:18:50 <shapr> My dayjob is in Python.
07:18:59 <earthy> my dayjob is semantics :P
07:19:05 <shapr> Lucky you.
07:19:06 <ski> heh
07:19:16 <aheller> god willing, some day soon....
07:19:22 <earthy> but I try to steer clear from category theory
07:19:22 <Philippa> shapr: I had an argument with someone about the design of game engines the other day where the solution I was proposing was sort-of an emulation of a monadic one (and thus being slagged off as 'not OO' despite separating concerns better)
07:19:31 <earthy> as it tends to break my mind
07:19:39 <shapr> Philippa: I am not surprised.
07:19:41 <ski> earthy : who brought in CT, now ?
07:19:56 <Philippa> shapr: it was basic layering being argued about, too...
07:20:14 <shapr> I don't really understand how most programmers approach abstraction, or even if they do.
07:20:20 * ski recalls monads comes from CT
07:20:33 <Philippa> yeah. OTOH you don't need to grok the CT to code with 'em
07:20:49 <Philippa> myself I just used the CT to confirm my intuitions as to what was going on
07:21:19 <xs_> CT is taught to some undergrads?
07:21:31 <Tue9531> i use CT to sort out my drawers
07:21:31 * ski is undergrad
07:22:00 <Philippa> xs: not this one. I got some of Graham Hutton's notes from the course he taught at MGS last year though
07:22:03 <ski> (xs_ : and yes, i know some basic CT)
07:22:27 <xs_> ski: but did you acquire that separately?
07:22:28 <earthy> I was never formally taught any CT
07:22:35 <earthy> (unfortunately)
07:22:38 <xs_> Philippa: are they online?
07:22:51 <ski> xs_ : if you mean "did you learn that on your own ?", then yes
07:23:05 <xs_> ok cool.
07:23:08 <Philippa> xs: not AFAIK, I was given them in person. He's my undergrad project supervisor
07:25:38 <Tue9531> i dont think i would appreciate CT
07:25:52 <Philippa> I only really do when I get to do something with it
07:26:08 <aheller> Most of the math profs I knew weren't terribly big fans.
07:26:10 <Philippa> but results're always cool
07:26:54 <aheller> ... and easily diagramed!
07:30:44 <earthy> the maths prof that we approached for teaching a category theory course went 'nah... that's all just trivialities'
07:31:01 <aheller> How unfortunate.
07:31:11 <earthy> quite
07:31:45 <aheller> I understand the distaste; it does sort of take the flavor out of a lot of math stuff.
07:33:06 <Tue9531> earthy, the worst teachers i ever had were math teachers
07:33:08 <Tue9531> so go figure
07:33:12 <Philippa> OTOH, getting trivialities out of the way easily is a good thing
07:33:17 <Tue9531> at our university i mean
07:33:19 <Philippa> I really wish I could prove more of my intuitions
07:35:05 <aheller> I really wish I had more intuitions to prove.
07:37:38 * earthy grins
07:47:15 <Tue9531> as long as your healthy aheller :D
07:49:32 <Tue9531> ow and know CT ofcourse
07:49:45 <aheller> of course.
07:50:14 <Tue9531> :P
08:00:34 <shapr> hoi swiert!
08:00:41 <shapr> Do you think you'll be able to finish the AGs article?
08:01:08 <swiert> it should be finished by Friday
08:01:30 <shapr> Yay!
08:01:37 * shapr cheers
08:01:54 <shapr> This is good, it looks like there really will be five articles again this month! w00!
08:02:34 <swiert> I should add some more exercises, together with the flippi stuff, and wrap up the last section.
08:03:05 <swiert> Shouldn't take more than a day or two.
08:03:10 <shapr> spiffy!
08:03:47 <swiert> What other articles are (semi) definite?
08:04:34 <shapr> shapr's ArrowsIntroduction, Philippa's next ImpureThoughts, poetix' SudokuSolver... umm
08:04:53 <shapr> Oh yeah, boegel's HRay is possible as well.
08:05:01 <aheller> AG?
08:06:19 <swiert> attribute grammar
08:06:38 <aheller> Last publication I'd heard of was TMR.
08:07:06 <Philippa> yes, we're talking about the fourth issue
08:07:26 <aheller> ah, I see.  By which I mean, I can't seem to figure out how to map AG onto TMR :)
08:07:37 <Philippa> An article about AGs for TMR?
08:07:41 <aheller> Being unable to pay attention to IRC as much as I'd like without any form of bandwidth.
08:07:44 <aheller> Ahah!
08:07:49 <aheller> Ingenious.
08:08:31 <shapr> I am often amazed that TMR ever gets published. Everything is very last minute.
08:08:40 <shapr> The editor isn't exactly organized either.
08:09:08 <Philippa> that's the nature of deadlines. Apparently a lot of magazines have similar issues (they just try to set deadlines in such a way that not /everything/ gets done the night before)
08:09:48 <shapr> Hm, maybe I should try that.
08:12:02 <Philippa> unlikely to work unless you set it up so only you have access to the IssueFoo pages (and thus are the only one who can 'publish' an article)
08:18:43 <basti_> hi
08:18:47 <shapr> y0
08:18:56 * basti_ needs type information everywhere.
08:19:03 * shapr :: Human
08:19:08 <basti_> like, in (or with) files. or at Pipes
08:19:18 <basti_> and databases
08:19:39 <basti_> know what i mean? =)
08:19:51 <goron> basti_: Just use the undefined type.
08:19:57 <shapr> hiya Speck
08:20:00 <basti_> stepcut was fantasizing about his haskell shell
08:20:05 <Speck> hi shapr
08:20:05 <shapr> I hear rumors he's coding it.
08:20:06 <basti_> goron: no i mean.... argh...
08:20:09 <basti_> lol
08:20:17 <goron> basti_: yeah, it was a joke.
08:20:22 <goron> :p
08:20:22 <basti_> k
08:20:31 <Philippa> the problem with types-everywhere is you need a sufficiently expressive agreed-upon type system first
08:20:42 <aheller> someone once told me that he needed pipes to be typed.  He said "I don't want to shove the output of my monitor into my soundcard".  I had no idea why not.
08:21:04 <aheller> s/monitor/video card/
08:21:15 <basti_> how do you store those things in lambdabot? ;)
08:21:26 <Philippa> because the sound card won't know WTF to do with it and may even be damaged by it
08:21:35 <aheller> and?
08:21:37 <basti_> Philippa: well it certainly needs to be dynamic on the type level
08:21:51 <Speck> aheller wouldn't happen to be John Cage's avatar, would it?
08:21:54 <basti_> i'm talking about: this file contains a list of tuples (Time,File,Action)
08:21:55 <Philippa> most of us prefer it when our hardware works?
08:22:01 <Philippa> mmm, that /would/ be useful
08:22:09 <aheller> Speck: if I were, I wouldn't be putting /anything/ through my sound card :)
08:22:19 <goron> Philippa: Good soundcards will only get damaged when you hit them with a sledge hammer.
08:22:19 <Speck> haha
08:22:35 <basti_> and sound cards of course would read [Sample].
08:22:43 <basti_> or something like that
08:22:51 <basti_> uh yes thats inductive types vs. coinductive types
08:23:03 <Philippa> goron: yeah, I'll run the power supply for a PA rig through line in then shall I? :-)
08:23:12 <basti_> we'd need both to realize streams and "static data"
08:23:36 <basti_> is making a type system dynamic hard?
08:23:47 <basti_> any non obvious semantics?
08:23:59 <shapr> Read TaPL and ATTaPL first.
08:24:20 * basti_ looks in his crystal ball (G brand)
08:24:26 <Philippa> aside from having to go to some effort to stop something crapping on your type tags? Not much
08:24:44 * shapr craps on a nearby type tag
08:24:45 <Philippa> well, depends what you want to do, but it sounds like you effectively want explicit checks of dynamic type against expected type
08:25:27 * Speck snickers at Edison's snoc function
08:25:33 <goron> Philippa: What does PA stand for?
08:26:23 <Philippa> "public address"
08:26:24 <basti_> tapl: Tulsa Association of Petroleum Landmen
08:28:15 <basti_> yes i should
08:28:45 * basti_ would love to do his thesis somewhere there or near, just need to convince a prof...
08:31:06 <metaperl> does anyone have any feedback on writing efficient code when in-place modification would be ideal? I posted my question here: http://sequence.complete.org/node/72
08:31:16 <goron> Philippa: Translating public address rig to my native language with a machine is pretty funny. It's just music gear(or it just an amplifier) for big events, right?
08:34:51 <Philippa> yeah
08:35:35 <Philippa> so signals that'd likely let the magic smoke out of most sound cards
08:35:39 <dcoutts_> metaperl: you can use any of the MArray instances for this
08:35:41 <basti_> Philippa: after processing what you said...
08:35:49 <metaperl> dcoutts_: oh, I see
08:35:58 <basti_> Philippa: well the run-time ability would not be as run-time
08:36:03 <goron> Philippa: so it's an amplifier?
08:36:17 <Philippa> goron: amps, big speakers, a few other odds and ends (you find PA effects and the like)
08:36:35 <dcoutts_> metaperl, see http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Array.MArray.html
08:36:38 <basti_> Philippa: i would introduce something like a "checked" property, like "this script is checked" (its type information is correct)
08:36:51 <basti_> Philippa: so the demands towards the run-time capabilities would not be high
08:36:56 <goron> Philippa: so it's like a package of music stuff?
08:37:10 <olliej> Yay bludgeoning partial application into .net now... hiss...
08:37:14 <basti_> there needs to be capability to effectively support lots of static information
08:38:18 <Philippa> goron: it's a class of usage rather than a specific item
08:38:18 * basti_ sounds like a buisiness consultant
08:38:40 <Philippa> much as I might talk about "studio kit" (and the reverb on my sound card is most certainly not of sufficient quality)
08:38:43 <basti_> basically there would be a step after compiling, or during the checking phase of scripts
08:38:54 <goron> Philippa: ok
08:39:17 <basti_> (which could be done in advance, or cached)
08:39:55 <basti_> the type system would need to grow types in any case
08:40:15 <basti_> retracting types would not happen lots
08:41:18 <basti_> hmm.
08:41:26 <basti_> i'm thinking about doing that in oz
08:41:32 <shapr> cool!
08:41:52 <basti_> i think oz is underrated.
08:42:07 <basti_> but i also think perl is underrated. its overrated at the same time, though, for other reasons.
08:42:52 <basti_> oz has: GOOD debugging facilities for a language of this construction, and lots of nice toys that all function sanely
08:43:09 <basti_> it doesnt have nice notation (or any capabilities to expand those afaics) though
08:50:29 <shapr> hoi boegel
08:50:29 <bourbaki> hey boegel
08:50:32 <bourbaki> heh
08:50:48 * boegel feels popular
08:50:55 <boegel> for a while atleast :p
08:51:13 <shelarcy> hey, boegel
08:51:19 <boegel> mwoeha :) yo shelarcy
08:57:36 <yain> hmm
09:02:01 * boegel leaves again :)
09:08:29 * poetix absentmindedly plugs his guitar jack to the heart of the Tardis, and promptly vanishes in an unearthly wail of reversed feedback
09:09:16 <Philippa> heh
09:09:28 <Philippa> your guitar is the bad wolf! :-)
09:11:52 <lispy> Tardis?  like in dr who?
09:40:30 <Lemmih> Greetings, SyntaxNinja.
09:54:10 <Clonk_Nukem> Hi
09:54:22 <basti_> hi clonk
09:54:26 <basti_> any questions about haskell?
09:54:30 <Clonk_Nukem> yes :)
09:54:38 <Clonk_Nukem> Well
09:55:12 <Clonk_Nukem> I hope I'll describe it correctly ;)
09:55:20 <Clonk_Nukem> I have a function which has alternatives
09:55:29 <Clonk_Nukem> like
09:55:31 <Clonk_Nukem> func a = ...
09:55:34 <Clonk_Nukem> func b = ...
09:55:42 * basti_ nods
09:55:48 <Clonk_Nukem> and I have to call some other function every time
09:55:54 <basti_> youre aware that this is not correct haskell? =)
09:56:07 <Clonk_Nukem> So do I have to write "where foo = ..." every line...?
09:56:17 <basti_> kinda.
09:56:22 <Clonk_Nukem> Well we leared it that way...
09:56:29 <Clonk_Nukem> *learned
09:56:37 <basti_> well youre talking about a case distinction of some sorts
09:56:42 <Clonk_Nukem> yeah
09:56:52 <Lemmih> Clonk_Nukem: You can do: func a = case a of ... | ... where foo = ...
09:56:54 <basti_> there are several possibilities for this
09:56:55 <Igloo> Can you give us a small real example of something that doesn't work how you expect?
09:57:11 <basti_> first is Lemmih's. And then you can break up values in the function declaration
09:57:18 <Clonk_Nukem> :o
09:57:26 <basti_> like:   func Blah = 1
09:57:35 <basti_> func Foo a = a*2
09:57:42 <basti_> uh no:
09:57:46 <basti_> func (Foo a) = a*2
09:57:46 <Clonk_Nukem> Igloo: It works as I expect, but I found it very strange to have a "where" every second line
09:57:53 <Clonk_Nukem> which is always the same ;)
09:57:56 <basti_> where is special.
09:57:56 <basti_> =)
09:58:11 <basti_> it does not have any direct relation to case distinction
09:58:20 <basti_> but you may do case distinction inside a where clause
09:58:32 <Clonk_Nukem> :o
09:58:37 <Igloo> Oh, I see. Translating it as Lemmih suggested is what you want, then
09:58:56 <Igloo> The case doesn't need to be inside the where IIUC
09:58:57 <basti_> the important thing is to see: the variables appearing on the left side of = are different to those on the right, technically
09:59:07 <Igloo> func x = case x of
09:59:10 <Igloo>            a -> ...
09:59:13 <Igloo>            b -> ...
09:59:16 <Igloo>     where ...
09:59:27 <Clonk_Nukem> huh
09:59:31 <Clonk_Nukem> I'll try that
09:59:38 * basti_ gives Clonk_Nukem some valium
09:59:47 <Clonk_Nukem> valium, hehe :)
10:00:09 <Clonk_Nukem> hey I've *somehow* managed to use Happy already, this can't be that hard ;)
10:00:29 <basti_> its easy isnt it? :P
10:00:34 <basti_> just dont think about it... -g-
10:00:43 <Clonk_Nukem> =)
10:01:27 <basti_> but back to my train of thoughts...
10:01:55 <Clonk_Nukem> aahhh fine that works :)
10:02:03 <basti_> if we had this type system... that would be just awesome
10:02:25 * basti_ cheers and wags pom poms
10:05:41 <lispy> is it just me or is the Yi wiki empty at the moment
10:05:54 <basti_> lispy: -cuddle-
10:06:02 <lispy> basti_: hi!
10:06:07 <basti_> that was for the Yi mention. Hi. :)
10:06:13 <lispy> heh
10:06:22 <lispy> basti_: i got it to compile last night :)
10:06:27 <basti_> did you look at the Emacs thing?
10:06:28 <lispy> and started adding emacs bindings
10:06:35 <basti_> :)))
10:06:41 <lispy> we need M-x
10:06:45 <basti_> we do.
10:06:50 <lispy> but i haven't figured out how to do M
10:06:51 <basti_> i'm working at a string interface
10:06:57 <basti_> want a braindump?
10:07:00 <lispy> sure
10:07:12 <lispy> i'm on a conference call but it hasn't started yet
10:07:19 <basti_> most of the time (and certainly in emacs contexts) by prepending ESC
10:07:28 <basti_> there are other methods though
10:08:00 <lispy> hmm...
10:08:16 <lispy> but ESC and meta behave differently in the way they do input right?
10:08:23 <basti_> well on some layer
10:08:23 <lispy> ESC is a toggle
10:08:30 <basti_> uhm
10:08:42 <basti_> actually ESC is assumed to deploy char 27 iirc
10:08:51 <basti_> from a terminal standpoint
10:09:10 <basti_> then the toggle might be implemented by software
10:09:17 <basti_> and then there might be X and xterm
10:09:23 <basti_> which might have certain other ideas
10:09:27 <lispy> ah
10:09:35 <basti_> or various connectivity software
10:09:40 <basti_> think ssh
10:09:59 * lispy is using ssh -> screen -> emacs, atm
10:10:16 <SyntaxNinja> hi Lemmih
10:10:19 <lispy> each of which may do something special with control chars
10:10:21 <basti_> so M would be differentiated by X (or whatever) and then might be clumped together back to the old ESC form
10:10:35 <basti_> or be reflected as chars > 255
10:10:50 <basti_> or being painted pink and come in yelling through the sink.
10:10:59 <basti_> or whatever people consider being an interface these days.
10:11:01 <lispy> i see....
10:11:46 <lispy> phone conference has started
10:11:48 <basti_> hF
10:11:55 <lispy> so i may be quiet for a bit
10:12:05 <basti_> k ;)
10:13:27 <lispy> so back to your strings thing
10:13:33 <lispy> what is that?
10:14:31 <basti_> strings?
10:14:36 <basti_> ah
10:14:45 <lispy> 10:07 <basti_> i'm working at a string interface
10:14:47 <basti_> you mean the ReflectableAction "String x"?
10:14:49 <basti_> ah no
10:14:57 <basti_> yes sorry that was a braino obviously
10:15:07 <lispy> oh
10:15:12 <basti_> a feedback system for entering stuff in the "bottom line"
10:15:17 <lispy> oh
10:15:33 <lispy> the message bar
10:15:35 <lispy> thingy
10:16:00 <lispy> we can do some stuff to improve over the one in emacs BTW
10:16:04 <lispy> that shouldnt' be too hard
10:16:17 <basti_> like?
10:16:17 <lispy> like line wrapping as you entry data
10:16:23 <basti_> oh
10:16:28 <basti_> yes.
10:16:34 <basti_> when it's working.
10:16:35 <basti_> ;)
10:16:36 <lispy> and perhaps expanding at the same time
10:16:39 <lispy> :)
10:16:50 <basti_> i was already thinking about it
10:16:50 <lispy> actually, emacs can do some of that in the minibuffer
10:16:56 <basti_> yes ive seen it to
10:16:56 <basti_> o
10:16:58 <basti_> but no entry
10:17:00 <basti_> iirc
10:17:13 <basti_> its quite simple to do completion from the technical standpoint i think
10:17:27 <lispy> the tab and space completetion?
10:17:32 <basti_> yes
10:17:55 <lispy> yeah i guess just sort the commands as strings and do a 'take'
10:18:00 <basti_> ah no
10:18:02 <basti_> build a tree
10:18:12 <basti_> alists or arrays or whatever
10:18:16 <lispy> a tree of prefixes?
10:18:19 <basti_> yes
10:18:27 <lispy> okay
10:18:28 <basti_> the fast lazy parser library might do heaps of good.
10:18:29 <basti_> :)
10:19:13 <lispy> meeting is finally getting started
10:19:18 <lispy> done with small talk ;)
10:19:20 <lispy> ttyl
10:19:38 <basti_> cu
10:50:58 <musasabi> Just added javascript generation support to PArrows.
10:52:16 <Trevion> Has anyone read Functional Programming with Bananas, Lenses, etc.?
10:53:48 * basti_ has tried once but didnt understand
10:54:17 <basti_> stepcut posed an interesting problem:
10:54:26 <Trevion> I don't suppose you know how to create their funny brackets in LaTeX?
10:54:40 <basti_> he wants to do some IO () *after* the last byte has been read by hGetContext (when it closes the file)
10:54:52 <basti_> uhm
10:54:58 <basti_> do you have a link to the document?
10:55:24 <ski> this one ? http://citeseer.ist.psu.edu/meijer91functional.html
10:55:28 <Trevion> yeah.
10:55:30 <basti_> can anyone do this without using unsafeIO?
10:56:13 <basti_> i dont think so
10:57:10 <musasabi> basti_: One could use a custom getContents function and use that to run user-defined finalizers.
10:57:31 <musasabi> the definition will need unsafeInterleaveIO.
10:57:32 <basti_> Trevion: that appears to be [ and ( overstruck
10:57:39 <basti_> musasabi: other than in C?
10:57:54 <musasabi> basti_: hGetContents is defined in Haskell (in GHC)
10:58:13 <Trevion> basti_: that's what I'd been trying, but the tops and bottoms don't quite line up.
10:58:16 <basti_> can you do something after unsafeInterleaveIO results have a certain property?
10:58:17 <ski> where's hGetContext
10:58:20 <ski> ?
10:58:27 <xerox> @index hGetContext
10:58:29 <lambdabot> bzzt
10:58:30 <Enveigler1> shapr: By George I think I got it. 'liftM' is a cast.
10:58:37 <musasabi> funnybrace == [\hspace{-1mm}( and tune the amount to fit your needs.
10:58:54 <basti_> hGetContents >>= \_-> b   does b right after hGetContents. not after the last byte being read
10:58:55 <ski> Enveigler1 : i would not say that
10:59:05 <basti_> TheHunter: hmm \vspace \hspace
10:59:07 <basti_> ;)
10:59:13 <musasabi> in http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/GHC/IO.hs?rev=1.30
11:00:19 <basti_> ohh i see.
11:00:23 <basti_> thank you very much
11:00:43 <ski> musasabi : i see no hGetContext
11:01:09 <basti_> ski: hGetContents
11:01:16 <ski> jaha
11:01:32 <basti_> thats great
11:02:38 <basti_> btw.. little ad: does you people know the scrapbook plugin for firefox? http://amb.vis.ne.jp/mozilla/scrapbook/
11:02:51 <basti_> great little tool
11:03:26 <Enveigler1> ski: the only way I can make sense of "lifting" is by equating it to "casting". Just as casting doesn't change the underlying data, just satisfies the compilers need to be told that a value that was previously designated as (say) a ulong can now be treated as (say) a pointer. Lifting satisfies the compilers need to be told that the value of an function defined as 'IO String' can now be treated as a 'String'.
11:04:24 <Trevion> musasabi: thanks
11:04:40 <ski> Enveigler1 : oh, but liftM does change the underlying data
11:04:55 <mflux_> enveigler1, IO String is definitely something else than a String..
11:06:05 <Enveigler1> mflux_: And a ulong is definitely something else that a pointer.
11:06:29 <ski> Enveigler1 : you can't change IO String into String
11:06:51 <mflux_> enveigler1, is a function returning a string the same as a string?
11:06:52 <ski> Enveigler1 : the other way is possibly, with the help of 'return :: Monad m => a -> m a'
11:07:09 <ski> s/possibly/possible/
11:08:35 <Enveigler1> ski: Then perhaps I haven't got it after all.
11:09:54 <Enveigler1> mflux_: At the point of use (application?), a function returning a string is a pretty good substitue for a string (constant).
11:11:05 <ski> Enveigler1 : but, you are on to something, in the sense that, return creates a *trivial* monadic action (one that doesn't have any effects proper), and liftM takes a function 'f :: a -> b', and an action 'act :: m a', and gives back an action 'liftM f act :: m b', that doesn't have any more effects than act has. i.e. when 'liftM f act' is run, it runs 'act', performing any effects that that action has, and then just purely converts the 'a' result
11:11:05 <ski> into a 'b' result, without doing any further effects
11:11:12 <mflux_> enveigler1, but there need to be arguments to a function to apply it fully, somewhat similar to IO needing an environment before you can get a string out of it
11:12:26 <ski> or, in the list monad, an 'effect' means 'possibly returns other than exactly one result (i.e. zero, or more than one)'
11:13:03 <ski> something returning possibly many, possibly zero strings is not a pretty good substitute for a string
11:15:47 <ski> Enveigler1 : i'm not sure my explanation attempts are intelligible .. :(
11:17:09 <Enveigler1> ski: One thing I know is that the more views I get of something, the clearer my own picture of that thing becomes. Ie. I thankyou greatly for your explanations--whether I understand themm (yet) or not :)
11:17:20 <ski> m
11:18:20 <ski> anyway, one way to think of return, is that it creates a trivial action, and liftM takes an action and "appends" a trivial (non-effectful) conversion on the back/top of it
11:19:50 <TFK> Enveigler1, are you reading All About Monads?
11:19:51 <ski> Enveigler1 : i guess one important thing, in my view of this, is to understand better what is meant by 'effect', and what different effects the different monads embody
11:21:26 <Enveigler1> TFK: Yes, and lots more besides. I have an imperical brain and I am trying to build my mental model of what is going on in the machine when "readFiles  = getArgs >>= liftM concat . mapM readFile" is executed.
11:22:15 <TFK> Holy moly... you're way ahead of me ;-)
11:22:15 <ski> would be nicer to write "liftM concat . mapM readFil =<< getArgs", imo
11:24:47 <TheHunter> basti_, hmm?
11:26:35 <TFK> OK, let me have a go. getArgs returns a list of filenames, passes it to the function (liftM concat . mapM readFile). mapM maps readFile onto the filename list. then the contents are concatenated into one big string, but since the results are boxed in IO, concat must be lifted into IO as well.
11:27:16 <ski> yes
11:27:38 * TFK remembers to breathe
11:27:51 <Enveigler1> Probably, but I didn't write it. But I get the gist of 'getArgs' supplying a list of filenames which 'mapM' applies 'readFile' to and 'concat' joins the results together to form the output of 'readFiles'. My sticking point has been "what is 'liftM'" doing, and none of the docs nore many peoples explanations have made it clear to me what this is....but if I think of it as allowing the "IO String" to "escape" from the IO and becom
11:27:51 <Enveigler1> in the functional code. Hence.. it's a cast!
11:28:35 <TFK> I think that it's more like injecting concat into IO, isn't it?
11:29:13 <ski> liftM f act = do {a <- act; return (f a)}
11:30:00 <TFK> Heh, I'll take that as a no.
11:30:10 <ski> so, it uses '<-' in do-syntax (syntactic sugar for (>>=)), to "extract" the string, and pass it to the pure function 'f', remembering to 'return' an IO-action
11:30:23 * TFK nods
11:30:44 <Enveigler1> So, f cannot directly operate on a because a is IO a, so liftM is rquired to make the a resulting from Act "compatible" with f.
11:30:55 <ski> TFK : one could say it's like injecting concat into IO, yes :)  injecting,lifting, what's the difference ? ;)
11:31:18 <ski> Enveigler1 : yes
11:31:20 <Enveigler1> s/Act/act/
11:31:47 <Enveigler1> See... It;s a cast :)
11:32:02 <TFK> Hey, whatever floats your boat ;-)
11:32:14 <ski> compare  (=<<) :: Monad m => (a -> *m b*) -> (m a -> m b)   liftM :: Monad m => (a -> *b*) -> (m a -> m b)
11:32:17 <mflux_> enveigler1, well, if it's a cast, it isn't a cast for the values..
11:32:21 <mflux_> enveigler1, it's a cast for the function
11:33:12 <TFK> But it seems to me more like getting a value from an array than casting objects.
11:33:25 <Enveigler1> mflux_: Yes. It casts the input to be compatible with f rather than the output from f. That's what ski just made clear to me.
11:33:26 <ski> (=<<) (and thus (>>=)) allows the result of one action be used in some function returning a new action (to be run), while liftM is used when the thing we want to run is pure (wrt to the monad), i.e. does not return something in the monad
11:33:30 <TFK> "Monads as Containers" and all ;-)
11:34:04 <ski> Enveigler1 : i did ?
11:34:37 * ski looks puzzingly at ski
11:35:02 <Enveigler1> Yes! "ski	liftM f act = do {a <- act; return (f a)}" for some reason, that is how I read that.
11:35:30 <ski> if you call '<-' / (>>=) a "cast", then i guess yes
11:35:40 <ski> but i wouldn't call that a cast
11:36:33 <Enveigler1> I'm not trying to change FP linguistics--just achieve a mental picture of them in terms of things I know.
11:36:37 <ski> more or less it keeps f around until (and if) it gets its hands on an 'a' (possibly several, e.g. in list monad), and then uses 'f' to convert that value (those values)
11:37:38 <ski> Enveigler1 : np. just to me, a cast means more or less something that changes the systems view of a thing, but doesn't actually change the thing itself (like casting pointers in C, e.g.)
11:39:32 <ski> (or like up- / down- casting of objects in java)
11:41:07 <Enveigler1> That's eactly how I see it. 'concat' cannot accept the output of mapM directly, so it needs liftM to cast it to the required type!
11:41:26 <ski> which, imho, changes the thing itself
11:43:33 <mflux_> enveigler1, I think the biggest problem here is the term you're using
11:43:51 <mflux_> enveigler1, it wouldn't work if you unsafeCoerced the String into IO String
11:44:11 <Enveigler1> One is a list of string the other a list of IO strings. concat can deal with a list of strings but not a list of IO strings. but what is the difference between an IO String and a String? The name of the type. In the underlying storage they're just a collection of bytes.
11:44:16 <mflux_> people here maybe use the words 'wrap' and 'unwrap'
11:46:47 <Enveigler1> mflux_: Again... I don;t expect anyone here to adopt my mental model. And maybe, once I stop worrying about why I would use liftM, I'll adopt the "standard nomeclature", but right now I need to understand when and why I need to use liftM in terms that make sense with my previous existance.
11:47:08 <mflux_> @index unsafeCoerce
11:47:09 <lambdabot> bzzt
11:47:13 <mflux_> @index unsafeCoerce#
11:47:15 <lambdabot> bzzt
11:47:55 <Enveigler1> That darn bee gets around! I see it *all* the time :)
11:48:27 <ski> Enveigler1 : i think it maybe would be good to examine what liftM does in some other monads than IO, to hopefully see what we mean better ..
11:49:02 <Enveigler1> I have been looking at Maybe and State and Error
11:50:02 <Enveigler1> but liftM does not get a mention (where I am looking).
11:50:30 <ski> so you can try it out
11:51:51 <Enveigler1> How: fred = liftM Maybe a?
11:52:31 <ski> liftM (* 10) (do {a <- return 2 `mplus` return 3; b <- return 20 `mplus` return 30; return (a + b)}) :: [Int]
11:53:09 <mflux_> enveigler1, map (liftM (\a -> a + 1)) [Just 5, Just 7, Nothing, Just 42]
11:54:17 <ski> Enveigler1 : that is syntax-error. just call liftM. or, if you want, you can say  fred :: (a -> b) -> Maybe a -> Maybe b   fred = liftM
11:57:41 <ski> wb
11:58:02 <Enveigler> Thanks (darn ISP).
11:58:40 <Enveigler> map (liftM (\a -> a + 1)) [Just 5, Just 7, Nothing, Just 42] gives [Just 6,Just 8,Nothing,Just 43]
11:59:16 <ski> m
11:59:20 <Enveigler>  map ((\a -> a + 1)) [5, 7, Nothing , 42] gives  No instance for (Num (Maybe a))
11:59:47 <ski> naturally
11:59:55 <Enveigler>  map ((\a -> a + 1)) [5, 7, 42] gives [6,8,43]
12:00:03 <Enveigler> @type Just
12:00:09 <lambdabot> Just :: forall a. a -> Maybe a
12:00:57 <Enveigler> Basically Just a is a, but map cannot deal with Just a, so liftM casts Just a's to a's
12:01:15 <mflux_> map can deal but the function given to map can't
12:01:16 <ski> Just a is not basically a
12:01:28 <ski> e.g. Just Nothing is not basically Nothing
12:01:37 <mflux_> Maybe can express a value or the lack of it
12:03:19 <wagle> @plugs map (+1) Just 1
12:03:25 <lambdabot> Couldn't match `[b]' against `t -> t1'
12:03:31 <wagle> @plugs map (+1) (Just 1)
12:03:32 <lambdabot> Couldn't match `[a]' against `Maybe a1'
12:03:33 <ski> liftM
12:03:44 <wagle> @plugs fmap (+1) (Just 1)
12:03:46 <lambdabot> Just 2
12:04:00 <wagle> @plugs fmap (+1) Nothing
12:04:02 <lambdabot> Nothing
12:04:24 <wagle> map cant handle Just a, but fmap can
12:04:26 <basti_> @plugs (liftM (+1)) (Just 4)
12:04:27 <lambdabot> Just 5
12:04:50 <basti_> @plugs  fmap (+1) (Just 4)
12:04:51 <lambdabot> Just 5
12:04:56 * wagle reads more scrollback
12:05:28 <xerox> @pl liftM (+1)
12:05:30 <lambdabot> fmap (1 +)
12:05:34 <xerox> ^_^
12:05:35 <basti_> :)
12:05:38 <ski> @plugs liftM (* 10) (do {a <- return 2 `mplus` return 3; b <- return 20 `mplus` return 30; return (a + b)}) :: [Int]
12:05:40 <lambdabot> [220,320,230,330]
12:05:58 <Enveigler> Well. I can cast ulong to long, but ulong cannot handle -1 and long can.
12:06:17 <ski> that is the other direction
12:06:43 <mflux_> enveigler, but there is a 1:1 mapping between them
12:06:53 <ski> long to ulong would be a little better analogy, in this aspect (but only a little better)
12:07:08 <mflux_> however, there is no value of integer that can represent Nothing::Maybe Integer
12:08:47 <Enveigler1> Grrr.
12:09:29 <Enveigler1> Dratted ISP... Where to I look for what I missed?
12:09:42 <CosmicRay> see topic for link to logs
12:09:47 <wagle> mflux_: bottom!  8)
12:10:04 <ski> <ski> that is the other direction
12:10:04 <ski> <mflux_> enveigler, but there is a 1:1 mapping between them
12:10:04 <ski> <ski> long to ulong would be a little better analogy, in this aspect (but only a little better)
12:10:04 <ski> --> goron (~goron@zonnebloem.demon.nl) has joined #haskell
12:10:04 <ski> <mflux_> however, there is no value of integer that can represent Nothing::Maybe Integer
12:10:06 <ski> <-- goron has quit (Client Quit)
12:10:08 <ski> <-- eq has quit (Read error: 60 (Operation timed out))
12:10:09 <ski> --> Enveigler1 (Enveigler@dial81-131-31-64.in-addr.btopenworld.com) has joined #haskell
12:10:42 * ski wonders why irc client did it that way .. :(
12:12:23 <Enveigler1> Thanks Ski.
12:13:02 <Enveigler1> Yes long to ulong is a better analogy. (Not good as mflux_ points out, but better)
12:16:42 <Enveigler1> I think I need to try and digest all the above and play with stuff some more...but even if it doesn;t fit with you guys sensibilities--"lifting" ~= "casting" (ish) has moved my mental model along a ways for now. Thanks for your time guys.
12:17:34 <ski> Enveigler1 : would you say that map (for lists) is somehow "casting" the '[a]' list into an 'a' (for passing to the function) ?
12:17:51 <ski> Enveigler1 : note that for list monad, liftM == map
12:20:04 <Enveigler1> In that sense... no i doesn't makes sense ski. map applies a function to a list (in my terms). But in my example, mapM appears to play that role.
12:21:08 <ski> yet, map == liftM (for list monad)
12:21:30 <ski> (quiz) figure out what mapM for list monad does ! ;)
12:21:49 <Enveigler1> The casting analogy comes in when the output from mapM is incompatible for input to concat. And liftM is requred to make the two compatible. I still haven;t seen an english explanation that does metter
12:22:22 <Enveigler1> s/metter/better/
12:22:44 <basti_> the bananas lenses and barbwire paper is bizarre
12:24:07 <Enveigler1> (quiz) figure out what mapM for list monad does !... If I knew /how/ to begin to do that, I would try.
12:24:32 <basti_> basically it comes down to:
12:24:33 <basti_> @type liftM
12:24:35 <lambdabot> bzzt
12:24:44 <basti_> @type Control.Monad.mapM
12:24:46 <lambdabot> Control.Monad.mapM :: forall b (m :: * -> *) a.
12:24:46 <lambdabot>         (Monad m) =>
12:24:46 <lambdabot>         (a -> m b) -> [a] -> m [b]
12:25:13 <basti_> just read the type aloud
12:25:34 <basti_> "given a function that goes from type a to things of type b wrapped in m,..."
12:25:54 <Enveigler1> Sorry basti_, but for all people here keep typing stuff like that, it means literally nothing to me.
12:26:29 * basti_ sighs
12:26:53 <basti_> a monad is something like a metatype.
12:26:56 <ski> Enveigler1 : sorry if it was confusing. it was just an impulsive idea i got :)
12:27:04 <Enveigler1> Or perhaps that should be "Meaningless.Text :: forall p( typed p ) => Nothing"
12:27:12 <basti_> if bananas is a type, then in "a box of bananas", box would be a metatype
12:27:29 <ski> type-constructor
12:27:43 <ski> like array is in e.g. C,Java, etc ..
12:28:18 <basti_> just that boxes don't give a nice metatype, so we use "List of things of type a" as a metatype
12:28:21 <Enveigler1> I am arriving at the conclusion that noone will explain this stuff in english, because noone knows how to.
12:28:21 <ski> (except we can define our own ! :)
12:28:29 <basti_> Enveigler1: we agree its abstract.
12:29:17 <Enveigler1> I need to break off now and let you guys get back to what you guys enjoy.
12:29:19 <ski> Enveigler1 : programming is a language in itself (as i'm sure you know) .. :/
12:29:30 <TFK> Enveigler1, I hear you, brother!
12:29:36 <TFK> What seems to the problem?
12:29:51 <basti_> @plugs do x<-[1,1,1];[x,2,3]
12:29:51 <ski> Enveigler1 : good look
12:29:53 <lambdabot> [1,2,3,1,2,3,1,2,3]
12:30:02 <basti_> that was a monadic operation
12:30:18 <TheHunter> basti_, \vspace \hspace ?
12:30:24 <basti_> with List ([]) being a monad
12:30:26 <basti_> TheHunter: not?
12:30:31 <Enveigler1> Yes. I have aquired 20 or so programming langauges over the years--but I can explain any one line of code I write in any of them in english. At an abstract level right down to the bits and bytes
12:30:37 <ski> @plugs [y | x<-[1,1,1], y <- [x,2,3]]
12:30:39 <lambdabot> [1,2,3,1,2,3,1,2,3]
12:31:01 <TFK> Enveigler1, which line do you want explained?
12:31:02 <TheHunter> basti_, i don't get it.
12:31:34 <Enveigler1> I'll probably be back later...if you guys can tolorate me .
12:31:36 <Enveigler1> $
12:31:44 * TFK blinks
12:31:46 <basti_> TheHunter: thats latex commands that will move latex things vertically and horizontally
12:31:53 <basti_> TheHunter: did i accidentaly emit your nickname?
12:31:59 <basti_> Enveigler1: you *are* tolerated! :)
12:33:32 <TheHunter> basti_, yeah no worries, it just didn't seem to fit into any context, so i assumed that maybe you indeed meant me.
12:33:41 <basti_> TheHunter: sorry must have been a typo then
12:34:16 <basti_> oh
12:34:18 <basti_> that was him
12:34:19 <basti_> great.
12:34:19 <basti_> ;)
12:34:50 * TheHunter may not move a millimeter because of a loose contact in his headphones. Sucks big time!
12:35:35 * basti_ may
12:35:48 <basti_> np: Nine Inch Nails - Only
12:35:51 * basti_ *headbang*
12:36:03 <jlouis> basti_: *HEADBANG*
12:36:11 <Paltas> Good evening jesper louis
12:36:16 <jlouis> NiN rocks
12:36:18 <jlouis> oy Paltas
12:36:19 <basti_> oh yes
12:36:41 <basti_> i'm becoming less to find as days go by, fading away well you might say, i'm losing the focus...
12:36:53 <Paltas> jlouis, How are you? Finished exams?
12:37:08 <jlouis> Paltas: exams wednesday and thursday
12:37:16 <jlouis> Algebra and Database systems
12:37:20 <jlouis> the latter is a farce
12:37:35 <jlouis> the first means I actually have to read and write notes ;)
12:37:43 <Paltas> jlouis, Oh databases system, a elementary course or?
12:37:50 <jlouis> elementary
12:37:53 <jlouis> I need points
12:37:58 <Paltas> Hehe
12:37:58 <Paltas> =)
12:38:02 <Paltas> I got mine credited
12:38:35 <Paltas> I've summerholiday now =)
12:39:08 <jlouis> I've used far too many years studying on my own rather than follow courses. It means I now know a freaking lot. But I miss the points that makes you able to take on projects on your own
12:39:32 <jlouis> So currently I am reading 1.5 times the amount I should do ;)
12:39:41 <Paltas> Ok i see.. I'm following the recommended study scheme
12:39:54 <jlouis> the Denotational Semantics Ph.d course got through ;)
12:40:19 <jlouis> also I miss a single obligatory exam
12:40:31 <Paltas> Ah a course for both ph.d and other students+
12:40:32 <Paltas> ?
12:40:37 <Paltas> called DM/DMP here
12:40:53 <jlouis> Paltas: usually they let in good people ;)
12:41:09 <Paltas> Could I get it in danish in private?
12:41:17 <jlouis> When there are only 5-6 ph.ds they can fill up to about 10 members
12:43:22 <xerox> dcoutts_, ping.
12:46:52 <TheHunter> anybody, ping?
12:47:08 <basti_> ping!
12:47:16 <ski> pang
12:47:33 <basti_> polka.
12:47:53 <TheHunter> puh, got it.
12:48:32 <ski> Ni! Peng!
13:00:11 <TheHunter> argh, those bastards! 23 Euros for a stupid headphone cable.
13:02:07 <wilx> What brand?
13:02:47 <shapr> Enveigler1: Have you figured out lifting yet?
13:02:51 <TheHunter> sennheiser, with proprietary connectors.
13:03:23 <basti_> solder in new ones >:|
13:03:31 <TheHunter> don't think i have a chance soldering it...
13:03:37 <basti_> :(
13:03:52 <wilx> Don't they have somethink like lifetime warranty?
13:04:19 <TheHunter> i assume it's pretty near the end of that thing and it's very small.
13:04:26 <TheHunter> wilx, yeah, i wish.
13:06:50 <TheHunter> i guess it's my own damn fault, i lifted my head to often while standing on the cable.
13:07:05 * shapr wants wireless headphones
13:07:38 <Itkovian> @seen boegel
13:07:40 <lambdabot> I saw boegel leaving #haskell 4 hours, 5 minutes and 18 seconds ago.
13:07:54 <TheHunter> and it fell down on the floor quite often, it's a miracle it didn't break earlier.
13:08:31 <TheHunter> last time i checked, wireless headphones all sucked one way or another.
13:10:29 <shapr> Do they already use SPDIF?
13:11:07 <lispy> TheHunter: yeah, and where you live makes a big difference
13:11:49 <Philippa> TheHunter: My sennheisers just used a particularly small jack
13:11:52 <Philippa> yours any different?
13:13:03 <TheHunter> shapr, no they don't (at least a few years ago). i have no idea why.
13:13:59 <TheHunter> Philippa, yeah, my roommates hd580 have a standard 2.5 mm phone jack, mine are proprietary.
13:15:13 <musasabi> evening
13:15:55 <Muad_Dibber> oh, since a while i have a sennheiser wireless thingy which is cool :)
13:16:32 <TheHunter> and the ear foam thingies are even more expensive: 36 Euros.
13:16:59 <TheHunter> Muad_Dibber, which one?
13:18:31 <musasabi> Has anyone implemented a form DSL on top of haskell server pages?
13:19:21 <Muad_Dibber> rs 115
13:25:58 <xerox> Providing the right instance of Functor for tuples, it is indeed possible to write polymorphic function working on lists and n-tuples, right?
13:26:47 <TheHunter> xerox, instace Functor ((,) a) where fmap = second
13:27:02 <xerox> TheHunter, that's all?
13:27:04 <TheHunter> so fmap :: (a -> b) -> (c,a) -> (c,b)
13:27:27 <TheHunter> this behaves differently than a map for a list.
13:28:01 <xerox> (,) is the _type_ constructor, right?
13:28:18 <TheHunter> yes
13:28:19 <xerox> Hmm, it is also the data constructor.
13:28:51 <xerox> But in "instance  Functor ((,) a) where fmap = second" (,) is indeed the type constructor.
13:28:55 <xerox> OK, thanks much.
13:29:56 * Itkovian is going to watch The Thin Blue Line
13:36:56 <Clonk_Nukem> hmmm... goodbye everyone :)
13:36:58 <Clonk_Nukem> thanks again
13:43:26 <Enveigler1> shapr: No. I thought that I had gotten a handle on liftM (and lifting), but it only "worked" for the IO monad, not others as was demonstrated by ski, mflux_ and others. I know that liftM is necessary in my example, but I cannot explain what it is doing for me.
13:43:54 <shapr> Maybe it would help to see other instances of liftM?
13:44:33 <Enveigler1> I've found a few, but none of them explain (in english) what it is doing.
13:45:14 <shapr> Can you give some urls? Maybe I can explain?
13:46:19 <shapr> Casting is sort of right.
13:46:29 <shapr> But it's not casting a type.
13:48:22 <basti_> its casting a function type to a metatype
13:49:49 <Enveigler1> Sorry. I've chased so many urls from ggogle I am having trouble locating the ones where I saw uses of liftM
13:51:20 <shapr> From one viewpoint a monad is a layer of indirection or late binding that gets filled in later. So liftM says "insert a callback here." the actual callback inserted depends on the monad definition.
13:52:41 <TheHunter> Philippa, the problem described in your 'Enforcing Initialisation' section can quite nicely be solved with implicit parameters, too.
13:52:46 <Enveigler1> Here's yet another equally opaque referencehttp://www.nomaware.com/monads/html/transformers.html#lifting
13:53:03 <TheHunter> Acutally, this is a good example why I like implicit parameters, they remove much of the tediousness reader transformers usually come with.
13:54:38 <shapr> Enveigler1: I would encourage you to try using Haskell for a few programs, and keep "All About Monads" handy for on-demand reference.
13:54:52 <TheHunter> and modularity is way easier.
13:55:05 <shapr> For me, it took real use of monads before I could get a good handle on them.
13:55:13 <shapr> Oh, there's one more thing you might like to read...
13:55:55 <wilx> OT: Do you know any channel where I could get help on shell (bash) programming?
13:57:51 <Enveigler1> Shapr: That's how I got here. I have a silly little example program that does part of what I want to do which includes the line I've been baging on about. The line works, but I do not understand why. SO attempting to modify it it to do more is just adding more layers that I cannot explain, and therefore do not know why I need them.
13:58:08 <TFK> Enveigler1, can you paste it?
13:58:10 <shapr> Did you see the several versions of that one line that I wrote?
13:59:24 <xs> wilx: #bash?
13:59:36 <wilx> omg, so obvious.
13:59:37 <wilx> Thanks.
13:59:48 <Enveigler1> I have the one version that you posted a link to:http://www.scannedinavian.org/~shae/ProtoEnveigler.hs.
14:00:22 <shapr> Right, I updated it to have a bunch of versions.
14:00:58 <shapr> readFile' = getArgs >>= \args -> mapM readFile args >>= \many_contents -> return $ concat many_contents
14:01:12 <shapr> readFile''' = getArgs >>= \ghost_arg -> (liftM concat . mapM readFile) ghost_arg -- now you see it!
14:01:28 <shapr> readFile'' = getArgs >>= liftM concat . mapM readFile -- now you don't, results of getArgs are invisibly passed to readFile
14:02:32 * SyntaxNinja uses shaprs functions to read his files
14:02:45 <Enveigler1> Okay. I got the updated version.
14:03:14 <lisppaste2> Enveigler pasted "liftM example" at http://paste.lisp.org/display/9477
14:04:56 <shapr> readFile is applied to each element of the arguments list, then concat is applied to the resulting list.
14:05:27 <reffie> http://ktown.kde.org/~binner/qt4dance_medium.mov
14:05:37 * xerox falls from the chair
14:05:42 <shapr> But, the Haskell implementation can reorder computations in anyway that it wishes.
14:05:57 <shapr> liftM makes sure the correct order is preserved.
14:06:00 <reffie> come on do the qt4 dance
14:06:19 <shapr> reffie: c'mon, don't you want to help me explain monads?
14:06:32 * SyntaxNinja does monad dance w/ shapr
14:06:38 <reffie> sorry :(
14:06:44 <SyntaxNinja> wagle: we've got dylan learning haskell
14:08:19 <shapr> Enveigler1: I can send you a series of files by Steve Atkin that show boring code rewritten to be a monad step-by-step
14:09:22 <shapr> http://www.scannedinavian.org/~shae/atkinmonads/
14:10:43 <Enveigler1> Thanks shapr. Working my way through them now.
14:14:11 <Enveigler1> I read the first file and the first executable line is "data Term = Con Int | Div Term Term deriving Show" -- but what/where do 'Con', 'Div' & 'Term' come from? They are undefined and there are no imports?
14:14:36 <shapr> @wiki HaskellDemo
14:14:37 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
14:14:39 <skiAFK> they are defined by that line
14:16:14 <Enveigler1> Been there before.
14:16:43 <shapr> I'd suggest you write some pure, non-monadic Haskell code, I think that will solidify your understanding.
14:17:43 <Enveigler1> I'll stop wasting your time and mine. Thanks for your attempts to help.
14:18:57 <shapr> You can do it!
14:19:13 <shapr> It took me many months of study to figure out monads, partially because I had zero background in FP. But I got it :-)
14:19:24 <shapr> And I'm getting the next step after monads too.
14:19:51 <lispy> what is after monads
14:20:01 <lispy> on your road map?
14:20:05 <ski> idioms, arrows ?
14:20:15 <Enveigler1> Here's the problem (and this will probably offend but it is not intended to--it's just what I am thinking).
14:20:20 <shapr> Arrows. Idioms are next after arrows.
14:20:34 <Enveigler1> I do not accept the basic premise of FP (provability).
14:20:41 <shapr> That's not the basic premise.
14:21:16 <TFK> Enveigler1, "data Term = Con Int | Div Term Term deriving Show" <--- Con and Div are data constructors,  I believe.
14:21:31 <Enveigler1> I have been trying to make progress by ignoring the propoganda and writing programs that do things.
14:22:19 <shapr> Have you looked at The Monad.Reader articles from the most recent issue? Some of those may help.
14:22:21 <TFK> The path of the pragmatic :-)
14:22:25 <Enveigler1> TFK: And what pray tell is a Data Constructor? Is it a constant? Does it allocate memory? Instantiate an instance
14:22:51 <lispy> it can be used to create an istance
14:22:57 <TFK> You can type Con 5, or Div (Con 10) (Con 2), for example.
14:23:01 <lispy> or for pattern matching
14:23:09 <TFK> It creates a value of type Term.
14:23:21 <TFK> Enveigler1, say, what other tutorials did you read in general?
14:23:25 <xerox> ski, did you see needle?
14:24:00 <xerox> lispy, you use type constructor in pattern matching. (correct me if I'm wrong)
14:24:13 <Enveigler1> It seems to me that in order to follow the tutorial materials for Haskell, you have to be prepared to just accept the recursive definitions of it's terms in terms of themselves ( Lifting blah blah lists blah blah)
14:24:57 <ski> xerox : no
14:25:03 <TFK> Enveigler1, well, what tutorial materials have you followed?
14:25:17 <TFK> Personally, diving right into monads is not a good idea, I think.
14:25:28 <xerox> ski, it seems to me that it does embody your coalg. datatypes! :-)  Let me find the url of the talk of the inventor/implementor.
14:25:31 <ski> xerox : you *don't* use type constructor in pattern-matching
14:25:44 <Enveigler1> This smacks of hiding the reality of the implementation behind terminology in an attempt to retain a mask of "Purity". But I don;t give a fig for purity, I want to "Use" the language to make computers do things. Not prothetise about how cleverly I did it.
14:25:46 <xerox> ski, http://ll2.ai.mit.edu/
14:25:51 <ski> ty
14:25:56 <TFK> Enveigler1, me too!
14:26:24 <xerox> ski, uhm.
14:26:39 <xerox> ski, your're right... but let me think where I saw that.
14:26:42 <shapr> Enveigler1: yeah, I'm self-employed and had cs101 in 1992, I'm all about pragmatic real world solutions.
14:26:54 <Enveigler1> At which point, my frustration is taking over from my desire to learn and I should have ducked out ehen I said I would earlier.
14:26:58 <shapr> Enveigler1: Thing is, Haskell is a real world pragmatic solution, superior to the others I know.
14:27:08 <TFK> Enveigler1, that feeling is familiar to me.
14:27:34 <shapr> Enveigler1: Part of the reason Haskell is superior is because it's so different. But that does make it harder to jump into from the procedural world.
14:27:35 <TFK> Haskell is not exactly a pick-up-and-go language :-/
14:27:37 <xerox> ski, oh.. OK, I'd misread ghc docs about infix type constructor.  Thanks :)
14:27:56 <shapr> TFK: Actually, it's just fine if you don't know about procedural programming beforehand.
14:28:10 <TFK> Maybe. But I'm tainted.
14:28:14 <shapr> Me too.
14:28:20 <TFK> But you're smart.
14:28:27 <Enveigler1> I *know* that Haskell is powerful. I can see that by the astounding progress Autrijus is making with pugs. The problem is, that I cannot seem to find descriptions of Haskell that i understand.
14:28:37 <shapr> Nah, just patient. I have eroded away the frontiers of my knowledge.
14:28:40 <TFK> Enveigler1, that is a problem.
14:28:45 <lispy> yup
14:28:51 <lispy> it's known as the warm fuzzy problem
14:29:13 <shapr> I taught myself to unicycle also, but it took time to get started.
14:29:19 <xs> shapr: on my cs course, the first language for many people was scheme. yet many wanted to use stuff like set{,-car,-cdr}! *shrug*
14:29:20 <lispy> things in haskell are based on mathematical formallisms that can be off putting
14:29:47 <TheHunter> shapr, every monad induces an idiom, UU parsers are idioms, and every idiom (or in arrow template library terminology - every sequence) can be made an arrow - a so called static arrow, which is in case of monadic idioms different from the kleisli arrow.
14:29:49 <TFK> Enveigler1, there is a human description to all this, which one day I hope to be able to formulate :-)
14:29:55 <xerox> xs, R6RS is _probably_ going to have immutable conses, heh.
14:29:55 <Enveigler1> No. Not "warm and fuzzy". I have read the Moands shoudl have been called "warm and fuzzy" and nobody would have a problem with them paper and I vehemntly disagree with it.
14:30:13 <xs> heh!
14:30:20 <xs> that's be amusing.
14:30:37 <shapr> In my cs course we learned BASIC from the ROM.
14:30:46 <TFK> Enveigler1, again, it is a bad idea to dive into monads before understanding more basic stuff.
14:30:51 <xerox> shapr, I saw CP/M yesterday, yay. :-)
14:31:07 <TFK> Particularly since they're so cryptic to newcomers (such as myself).
14:31:13 <lispy> xerox: CP/M? the OS?
14:31:22 <xs> mmm basic.
14:31:33 <lispy> i want to learn state transformer monad
14:31:33 <shapr> xerox: yay!
14:31:44 <lispy> i've seen an example but i wouldnt' be able to really use one
14:31:51 <shapr> Enveigler1: yes, learn the pure non-monadic Haskell first, and then getting into monads will be much easier.
14:31:54 <xerox> Right, a friend of mine discovered some computer archeology in some place... we did C128 BASIC all night long (we even got manuals :-D)
14:31:54 <lispy> so far list is the only monad i really get
14:32:31 <shapr> xerox: wow awesome!
14:32:36 <lispy> shapr: the problem with that is you cannot do much without monads (in a pragmatic sense)
14:32:37 <xerox> It's amusing to see program printed on many, many, many sheets, saying "Copyright 1987".
14:32:38 <ski> xerox : sound like fun :)
14:33:21 <reffie> # dmesg | grep '(c)'                                     [17:24]
14:33:21 <reffie> Copyright (c) 1992-2005 The FreeBSD Project.
14:33:21 <reffie> Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994
14:33:42 <shapr> I'm shapr (c) 1971
14:33:45 <xerox> reffie, it was in Italian, too :-)
14:34:02 <reffie> what's 'copyright' in italian?
14:34:14 <shapr> Something that requires tax stamps?
14:34:21 <xerox> It was a "Yahtzee!" game.
14:34:31 <xerox> reffie, uhm.. "copyright" I think.
14:34:38 <reffie> what
14:34:45 <reffie> an english word!
14:34:56 <TFK> Enveigler1, anyhow, I just want you to know that I'm in the same boat as you are, and maybe I can help you row :-)
14:35:00 <shapr> xerox: Are Italian tax stamps really as much trouble as the rumors I hear?
14:35:15 <xerox> shapr, what do you mean by "tax stamps" ?
14:35:29 <shapr> I've heard that nearly everything requires tax stamps.
14:35:33 <TheHunter> reffie, continental-european legal systems usually don't have the concept of co
14:35:33 <reffie> last year, i had an appointment at a notary's office at 9am
14:35:39 <TheHunter> *copyright
14:35:42 <xerox> shapr, oh yes.  They indeed are..
14:35:43 <reffie> the guy showed up at 2pm
14:35:45 <shapr> I've never actually been to Italy, but I heard that from some friends who have been there.
14:35:51 <TheHunter> iirc.
14:36:10 <Enveigler1> My copy of K&R is Copyright 1978 by Bell Telephone Laboratories, Incorporated.
14:36:10 <Oejet> TheHunter: On the contrary.
14:36:28 <shapr> Aww, chalmers fell off the net.
14:36:51 <aheller> As well as pakistan.
14:37:01 <Enveigler1> Thank TFK. I think I need to back off for tonight before my lack of breeding begins to show :)
14:37:04 * shapr wonders about the relation
14:37:12 <TheHunter> at least, germany doesn't have it. There is the concept of "Urheberrecht" which you can't give away.
14:37:19 <shapr> Enveigler1: I can't get dates either ;-)
14:37:29 <TFK> heh
14:37:44 <xerox> (We also got a sinclair and some other goodies, /me is still emotionally squashed by them, heh)
14:37:52 <TheHunter> but i may be mistaken, i generally don't care very much for legal crap.
14:38:04 <shapr> xerox: oh, I started on a sinclair!
14:38:21 <shapr> membrane keyboard, 16k expansion cartridge.. it was great!
14:38:22 <xerox> So small, we didn't succed in running it, tough.
14:38:24 <Oejet> TheHunter: In Danish it's "ophavsret".
14:38:30 <xerox> Membrane keyboard, yeah :-D
14:38:34 <Enveigler1> Hmm. That's never been a problem except when DataA discovers DateB :/
14:38:41 * ski owns 5 commodore 64's
14:38:55 <xerox> ski, time to setup a cluster <grin>
14:39:04 <Oejet> ski: owns like in pwnz?
14:39:07 <shapr> Enveigler1: Well, you mentioned lack of breeding in connection with frustration, so I had to make the joke...
14:39:39 <Enveigler1> I gotcha shapr: I was do the straight man act :)
14:39:40 <ski> Oejet : owns like in has bought/whatever ..
14:39:45 <shapr> good job :-)
14:39:59 <aheller> clearly #haskell has prophylactic properties.
14:40:06 * shapr chortles
14:40:19 <TheHunter> Oejet, "ophavsret" is probably the same as "Urheberrecht".
14:41:04 <TheHunter> that is if you are the author you have this right and you can't sell it to anybody else. In any case, ianal.
14:41:05 <ski> xerox : thought of idea for protocol, communicating in a ring through joy-stick-ports (2 of them) ..
14:42:23 <shapr> hej polli
14:43:33 <polli> hej shapr, how are the mosquitos treating you?
14:43:42 <shapr> Like a target. What about you?
14:44:11 <polli> The wind in gothenburg keeps most of them away :)
14:45:04 <shapr> Lucky you, I unicycle past and they all think it's lunchtime.
14:45:10 <thedward> ski: you can't send output through the joystick port can you?
14:45:48 <ski> thedward : not sure. never got further than thinking on it ..
14:46:23 <thedward> ski: I seem to remember there being a program that let you network two C64s via a 1541 disk drive or something like that.
14:46:39 <ski> possible
14:47:46 * ski remembers a program that played a song on the disk drive, by getting the read/write head to vibrate by moving it to-and-through ;)
14:47:59 * ski even wrote a simple such himself
14:49:08 <polli> how's code?
14:49:16 <xs> on the pdp8, they caused the core memory to oscillate at an am frequency, then tuned a radio to get sound.
14:49:32 <ski> nice :)
14:49:35 <Enveigler1> Was that on an ACT computer with the variable spindle speed floppy drive shapr?
14:50:29 <shapr> I don't know, I don't know that one.
14:53:09 <Enveigler1> Just wondered. I remembered a program that played Colonel Boggie on that machine by accessing different tracks on the drive .
14:53:41 <shapr> My earliest computer music experience was with the C64 MusicMaker cartridge.
14:54:03 <shapr> I really liked that, I built my own instruments and saved tunes onto our tape drive.
14:54:55 * ski remembers something similar for a calculator ..
14:56:07 * Enveigler1 is gonna give my brain a rest and watch something on TV. Thanks again all.
14:56:17 <Enveigler1> $
14:56:40 <aheller> shapr: did you put up Fermat's Last Margin somewhere?
14:57:18 <shapr> Not yet, I've been slacking off and playing saxophone instead.
14:57:38 <shapr> But I just got a few emails from Josef Svenningsson about FLM, so I'll get to it soon.
14:58:21 <shapr> I still have the same two pieces of code to finish, just can't seem to get started lately.
14:58:29 <aheller> awesome (the saxophone).  I've been sort of itching to do something really similar for quite a while, so I'm very interested.
14:59:56 <shapr> I think I'll set a release date for FLM and just upload whatever I have then, that should be motivating.
15:00:02 * ski decides to yield to the sandman
15:00:37 <aheller> i'm not trying to be bitchy.  Just curious as to how others are thinking about that sort of problem.
15:00:55 <shapr> What is it? A distributed decentralized wiki-based darcs-backed research paper annotation tool called Fermat's Last Margin.
15:01:03 <shapr> How does it work? In short, wget the pdf/ps, throw it into imagemagick, create wiki pages for the resulting page images, and save text annotations into the darcs repo. If your repo is http accessible, anyone can grab your per-page annotations, and you can grab theirs.
15:01:07 <shapr> That's what I think.
15:01:38 <aheller> well, yes.
15:01:45 <aheller> I'm thinking about document annotation in general.
15:01:48 <thedward> Is it in haskell? aside from darcs.
15:01:57 <shapr> thedward: darcs is in Haskell too.
15:02:09 <thedward> heh, that's what I meant.
15:02:19 <aheller> that seems significantly more implementable than my idea. :)
15:02:27 <shapr> What's your idea?
15:02:33 <shapr> There's Annodex for annotations.
15:02:40 <shapr> There's LateXWiki or something
15:02:47 <thedward> (though perhaps not what I said) ; "is the part that is not darcs in haskell?" is what I meant.
15:02:51 <shapr> There's Ka-Ping Yee's Python thingy.
15:04:08 <shapr> thedward: Yes, it is all Haskell apart from imagemagick.
15:04:57 <aheller> My idea is sort of like talmud.  you'd have a canonical text, and an interface to edit/annotate it.  then you'd be able to apply different users to your view, or make comments on *those* comments, and so on.
15:04:58 <shapr> aheller: Advantage of only sharing annotations is that no one will sue you for being a p2p copyrighted material distribution app.
15:05:02 * thedward nods.
15:05:31 <aheller> well, I was in a medieval lit class, so I don't think the beowulf poet was gonna come after me.  And I think even chaucer's copyright had run out.
15:05:51 <shapr> Not if Walt Disney gets their way!
15:06:04 <thedward> aheller: that one you should call palimpsest
15:06:13 <shapr> I suspect that copyright is effectively infinite in the USA now, all because of the Mouse.
15:06:24 <aheller> thedward: that actually was the plan :)
15:07:04 <aheller> well, more lazily evaluated.  when they try to see if the copyright expired on it, it turns out it just keeps going.
15:07:05 <thedward> though, I believe there is an algorithm for concurrent revision called that too.
15:08:17 <aheller> well, a saw a guy from http://www.tei-c.org/ giving a talk at Kalamazoo, and I got the crazy idea that the hard part (encoding text) might already have been handled.
15:10:29 <shapr> How's that the hard part?
15:12:47 <aheller> well, encoding something like beowulf so that every line is marked, posibly every (plotwise) character is identified, each important bit is marked, is time consuming and error prone.  it would require a lot of dedication.
15:13:13 <aheller> not that the idea wouldn't be to use the software to do the markup in the first place?
15:13:20 <shapr> I think that's too much work. I say do it lazily.
15:13:43 <shapr> If you allow people to contribute, you may end up with something like wikipedia.
15:14:36 <aheller> that's the goal, but making it a First Big Haskell project makes it yet more intimidating.  and I still don't have bandwidth at home.
15:14:39 <aheller> :)
15:15:00 <shapr> If you take a distributed approach like I've suggested, you don't need the bandwidth.
15:16:41 <aheller> well, I just meant for finding haskell docs in the middle of the night
15:16:55 <shapr> oh, I see.
15:17:27 <aheller> indeed, I've been told that monads make sense after your First Big Project, but.....
15:24:18 <Heffalump> I sometimes wonder if it makes more sense to teach people the monadic syntax first then expand into pure code
15:26:06 <lispy> Heffalump: yeah
15:26:14 <astrolabe> As a learner that makes sense to me
15:26:14 <lispy> Heffalump: but could you imagine doing that?
15:26:41 <TFK> What do you mean, monadic syntax?
15:26:56 <lispy> someone should write a TMR article about teaching haskell from the monad up
15:27:32 <astrolabe> It is sort of the approach in 'The Haskell school of expression' I think, at least as far as the do notation is concerned.
15:27:38 <TFK> You gotta work up to the monad.
15:28:12 <Heffalump> IM teach people by starting with "Hello world" in IO.
15:28:20 <Heffalump> do putStrLn "Hello world!"
15:28:28 <TFK> Ah, like that.
15:28:31 <Heffalump> then show them 'variables' and stuff.
15:28:32 <shapr> lispy: you volunteering?
15:28:43 <Heffalump> work with some kind of library that makes loops look natural
15:28:50 <Heffalump> (to an imperative programmer)
15:29:06 <Heffalump> it's just a vague idea.
15:29:17 <TFK> Ah, so you didn't try it out?
15:29:21 <shapr> Like lispy says, it would make a great TMR article.
15:29:49 <TFK> And who's gonna write it?
15:30:24 <TFK> People for whom the first reflex while seeing a question on the do-notation is saying, "it's just syntactic sugar"? :-P
15:30:54 * TFK stops pushing buttons
15:31:59 <shapr> I think they're both equally acceptable. They just have different uses.
15:32:51 <TFK> Personally, I find premature monad talk quite intimidating.
15:33:27 * shapr shoots an arrow at TFK 
15:33:52 * TFK slow-motions out of the arrow's way, Matrix-style
15:34:01 <TFK> Keep in mind that the target audience are mostly imperative programmers.
15:34:36 <yain> peremptory even.
15:35:36 <Heffalump> this is why I was suggesting starting with do notation and hiding all the pure stuff.
15:35:48 <Heffalump> You can build up to it bit by bit because you can use it all insid ethe do notation.
15:37:00 <TFK> I think that Gentle's approach is better - explain all the basics first. They don't look so pure and intimidating.
15:37:27 <TFK> Imperative programmers do know about functions :-/
15:38:14 <TFK> And type annotations. Although some of the funkier pattern matches and pattern bindings may need to go into more advanced chapters.
15:38:47 <astrolabe> I think there is advantage to being used to using the do notation before being exposed to the difficulties of what it means.
15:38:59 <TFK> Certainly.
15:39:15 <TFK> Monads should come last, and no crazy "it's just syntactic sugar" talk :-/
15:40:10 <Heffalump> to someone who finds functional programming natural, "it's just syntactic sugar" is great.
15:40:26 <Heffalump> You show them a state-based computation, introduce >>= and return, then introduce do and <-
15:40:39 <Heffalump> That's the way it really started to make sense to me.
15:41:24 <Heffalump> But I have a feeling (without having thought it through in great detail) that the alternative approach I'm suggesting would work very well for people who find the functional way of doing things.
15:41:43 <TFK> I assume that my target audience comes from a purely imperative background.
15:42:13 <Heffalump> well, I did until I learn Haskell too
15:42:27 <Heffalump> but I'm a mathematician by training and inclination (at least to some extent)
15:42:40 <Heffalump> so I took to Haskell (well, Gofer) really well
15:42:50 <Heffalump> introduced in the Oxford (algebraic) way
15:43:55 <astrolabe> I'm a mathematician by training, and it's really got me scratching my head.
15:44:09 <TFK> I don't think that most programmers are mathematicians.
15:44:13 <TFK> I don't think that most care.
15:44:13 <astrolabe> Maybe
15:44:38 <Heffalump> it's quite interesting working in a place with lots of dedicated C hackers who are all pretty smart
15:44:43 <TFK> Just True, in fact.
15:44:52 <astrolabe> :)
15:45:47 <astrolabe> How so Heffalump?
15:45:57 <TFK> A down-to-earth online guide-book for practical Haskell programming would promote Haskell than any talk of monads or FP ever would.
15:47:03 <TFK> *more than
15:47:39 <astrolabe> Do you think it is possible for Haskell to be a usefull tool to someone who doesn't understand monads?
15:48:33 <xs> yes, just stuff like folds are neat.
15:48:50 <TFK> That's the wrong question.
15:49:02 <TFK> The right question is, "can monads be taught to mere mortals?"
15:49:08 <jaap> i'm wondering, with all the talk in the late 90s of replacing GHC's Core by Henk -- did that never happen?
15:49:26 <Heffalump> astrolabe: I'm trying to use Haskell in some places, and I get an interesting spectrum of reactions
15:50:20 <Heffalump> quite a lot of "that's just an academic language" but with the occasional "that's really quite cool"
15:50:21 <astrolabe> I think the problem is not that it can't be taught, but that most people would balk at that level of complication unless they had very good motivation.
15:50:31 <jaap> TFK: when calculus was invented, it was the pinnacle of higher math. pedagogical techniques can be slow to follow. the FP community, I believe, is actually extraordinarily fast at transforming research material into textbook material.
15:51:38 <jaap> TFK: but I must admit, Monads are not quite at the level of accessibility of basic Scheme just yet. I don't think that's inherent complexity.
15:51:54 * astrolabe doesn't think he'll be allowed to switch to Haskell at work.
15:52:04 <jaap> anyhow, anyone know about Henk?
15:52:59 <TFK> basic Scheme is accessible?...
15:53:05 <Heffalump> it's not switching to Haskell, just putting it in some places off-to-one-side
15:53:06 <TFK> Well, I wouldn't know, to be honest.
15:53:21 <Heffalump> for example I've used it to automatically generate some library code
15:54:01 <Heffalump> so the generated code can be checked into CVS, and people don't need to work with or compile the Haskell unless they want to change the generated code. And if I leave they've still got the generated code which is pretty printed and could be edited directly.
15:54:07 <astrolabe> I found most of 'the little lisper' very readable, and the rest was fun enough to be worth bashing through.
15:54:16 <Philippa> <TFK> The right question is, "can monads be taught to mere mortals?" <- sure. Preferably by giving examples of how to use and /then/ motivating them
15:54:23 <Philippa> "this is how we do IO, and many other things"
15:54:34 <Heffalump> Philippa: right, hence my idea of starting with do notation
15:54:41 <TFK> I think that the other way would be better.
15:54:48 <Philippa> starting with do notation is very much the way to go
15:54:51 <TFK> IO is an exception to the rule, but everything else probably isn't.
15:55:01 <TFK> Why does Maybe need to be a monad?
15:55:03 <Philippa> get folks happy that they can write something with them, then go into details
15:55:05 <Philippa> it doesn't
15:55:07 <Heffalump> it doesn't *need* to be a monad
15:55:09 <Philippa> it's merely useful when it is
15:55:11 <Heffalump> it's just useful that it does
15:55:16 * Heffalump IN Philippa.
15:55:22 <Philippa> er...
15:55:30 <Heffalump> s/IN/is not/ # must not use acronyms from other places here
15:55:34 <Heffalump> especially dodgy ones like that
15:55:44 <Philippa> oh, I knew what it meant, but still...
15:55:52 <Philippa> a wee bit presumptious, no? :-)
15:56:00 <Heffalump> I only noticed how dodgy it looked after I pressed Enter ;-p
15:56:11 <TFK> How is that useful?
15:56:13 <Philippa> bah, they all claim innocence :-)
15:56:18 <TFK> Again, Gentle does this.
15:56:30 <Philippa> TFK: why is Maybe being a monad useful?
15:56:36 <TFK> What Gentle doesn't do is give motivation for monads, in the chapter dedicated to them. At least not "mere mortal" motivation.
15:56:38 <TFK> Yes.
15:56:43 <Heffalump> TFK: you can write code that handles failure while hiding the details of pattern-matching for Nothing all the time
15:57:10 <TFK> Erm, can you give an example, please?
15:57:22 <Philippa> do somethingThatCanFail; somethingElseThatCanFail;
15:57:39 <TFK> That doesn't explain anything.
15:57:49 <Heffalump> subtractOneAndStayPositive :: Int -> Maybe Int
15:57:54 <Philippa> possibly you'd want a 'catch' construct, in which case: do catch (somethingThatCouldFail) (handlerIfItFails)
15:58:04 <Heffalump> subtractOneAndStayPositive n = if n <=0 then Nothing else Just (n-1)
15:58:10 <Heffalump> do let x = 5
15:58:21 <Heffalump>    y <- subtractOneAndStayPositive x
15:58:25 <Heffalump>    z <- subtractOneAndStayPositive y
15:58:27 <Heffalump> (...)
15:58:59 <Heffalump> this sequence will abort the minute the value gets to 0, and it will stop trying to call more things
15:59:27 <TFK> Sounds like a poor-man's version of Icon's generators :-P
15:59:51 <astrolabe> If you didn't introduce monads at first, how would you explain when to use do?
16:00:06 <Philippa> astrolabe: about 3 paragraphs in
16:00:16 <TFK> As I said, IO is an exception.
16:00:19 <Philippa> well, earlier than that. Gotta explain when to use return
16:00:24 <shapr> jaap: Have you seen JHC's Core?
16:00:29 * Heffalump googles and reads about them
16:00:29 <TFK> One need not need to know monads to use IO, although some gotchas do need to be explained.
16:00:58 <jaap> shapr: I know JHC's is much like Henk. I was just wondering if it ever made its way into GHC.
16:01:18 <Philippa> TFK: define "know monads". It helps a lot to know what the do notation and return do, you don't need to know how to build your own
16:01:22 <Heffalump> Icon's generators look like verbose list comprehensions to me
16:01:31 <Heffalump> and list comprehensions are basically do syntax
16:01:41 <Heffalump> (but without the do, and specific to lists)
16:01:43 <Philippa> yeah, I was considering pointing out that list comprehensions generalise to monad comprehensions
16:01:44 <TFK> Philippa, one doesn't need to know about bind and about why return is needed.
16:01:59 <TFK> Merely, "when this do this, when that do that, and you'll be OK"
16:02:03 <Philippa> TFK: one /does/ need to understand what return does
16:02:09 <Heffalump> tfk: that was my idea of how to introduce this
16:02:15 <TFK> Not really, no.
16:02:30 <Philippa> rules of thumb lead to fuckups and confusion
16:02:32 <Heffalump> I don't think you need to understand what return does.
16:02:40 <Heffalump> Start by saying you always need it.
16:02:43 <TFK> Merely, "when the computation doesn't return an IO type, you should either use foo <- return $ bar or let foo = bar"
16:02:46 <Heffalump> Then relax that rule.
16:02:46 <jaap> tfk: oh yes, you do. how else do you make sense of the error message you get when you leave it out.
16:03:01 <Heffalump> ah, I think with my approach you'd need a compiler with tuned error messages.
16:03:05 <TFK> Philippa, right, right, so explain monads to them first, that'd work. That WOULD work if you find a good way, actually.
16:03:26 <Philippa> which I mostly have but haven't sat down and refined it into text rather than a conversation
16:03:42 <TFK> jaap, "footnote: if you want to remain sane, do read the chapter on monads as soon as possible ;-)"
16:04:10 <Philippa> jaap: *especially* when the function returned something with its own monad instance
16:04:15 <astrolabe> I think most programmers would not sit through an explanation of monads unless it was REALLY well motivated.
16:04:27 <Philippa> astrolabe: "you're not going to be able to do IO without this"
16:04:46 <TFK> astrolabe, and accessible.
16:04:52 <Philippa> 'sides, the explanation doesn't need to go into too much depth at first. Cover return and what you get out of the do notation, and leave bind for a while
16:04:56 <jaap> philippa: "well, then, er... C++ roxorz" ;-)
16:05:23 <jaap> it seems to me that "motivation" comes much easier from, say, darcs and pugs than from philosophical arguments
16:05:23 <Enveigler1> Definition: Monad--an obscure and complicated way to do what comes naturally in every other language :)
16:05:55 <Philippa> Enveigler1: making code behave nondeterministically comes naturally in every other language?
16:06:01 <astrolabe> Would it be possible to wrap monads up differently so they could be used more easily without understanding?
16:06:01 <shapr> That's what I was thinking.
16:06:04 <Heffalump> OOI, who here came here because of Pugs?
16:06:12 <Philippa> (I mean, usefully-nondeterministically, not just undefined behaviour)
16:06:16 <shapr> Pain, agony, shooting your feet, that does come naturally in many languages.
16:06:26 <Heffalump> Haskell has plenty of pain and agony of its own.
16:06:29 <Philippa> astrolabe: nope. do and return, there's not much to understand...
16:06:39 <TFK> jaap, I think that most languages have practical code to their name.
16:06:42 <Heffalump> I've just spent another does of three solid days hacking on it, so I know this :-)
16:06:46 <Heffalump> s/does/dose/
16:06:47 <shapr> Yeah, but I like my bondage just this way.
16:06:49 <Heffalump> s/on/with/
16:06:51 <TFK> Simply mentioning darcs or pugs wouldn't impress too many people.
16:06:55 <Heffalump> though i will repeat that ST rocks.
16:07:08 <TFK> One should assume that a person reading the tutorial is interesting in Haskell, and the tutorial should keep him that way.
16:07:09 <Philippa> the ST monad is indeed my friend
16:07:12 <xs> i found "tackling the awkward squad" by peyton jones cleared up monads a lot for me. IO was confusing.
16:07:17 <Heffalump> it impresses Haskell people, they're not used to having real useful stuff that isn't GHC written in it :-)
16:07:51 <Philippa> Heffalump: there is a way to make Pugs sound an impressive thing - language processing is supposed to be perl's thing, you'd have thought they'd have a better implementation written in it, right?
16:07:55 <Philippa> (at least, if you didn't know better)
16:08:32 <jaap> philippa: or by saying, they tried to implement perl 6 for n years, did not manage, then did after all, in a month, tadaa...
16:08:51 <jaap> philippa: where of course credit is due to autrijus, but you can make haskell *sound* good at least
16:08:58 <jaap> if thats the goal
16:09:23 <Philippa> credit's due to both, there're many neat things in Pugs that couldn't be done in another language or else would require hell maintaining the conceptual framework
16:09:38 <Philippa> autrijus is great at making use of those things though
16:09:40 <jaap> that's what i gathered from my brief examination of it
16:10:47 <Enveigler1> Phillipa: Define "usefully non-determanistic"?
16:11:12 <TFK> Another thing I don't understand is this "non-determinism" thingie.
16:11:18 <aheller> not that I claim to understand monads, but I wish that the tutorials spent more time beating on the relationship between lazy evaluation, referential transparency, and why io is hard if you want the first two.
16:11:20 <Enveigler1> s/Phillipa/Philippa/
16:11:31 <TFK> Because, afaik, every computation has a well-defined result.
16:11:43 <Philippa> Enveigler1: suppose you want to work with function-like things that could have multiple results. In particular, when you compose them you want to see each possible result be used as a separate input and generate its own multiple results
16:12:14 <shapr> aheller: because, referential transparency means readLine should return the same result everytime.
16:12:17 <Philippa> for example, you're writing some weird simulation with probabilistic stuff and want to maintain Many Worlds in the quantumn sense
16:13:05 <Philippa> better yet, you want to see at the end what the net probability of some particular result coming up is, so you want to keep a list of (probability, result) pairs
16:13:20 <Philippa> in short, mucking around managing this list manually is a pain in the arse
16:13:25 <aheller> shapr: exactly, having thought about that, the need for a complicated abstraction like monads is less frustrating, I know what I'm getting for my trouble.
16:13:27 <Philippa> whereas the List monad does it all for you
16:13:53 <Enveigler1> [ map{ split '', } <STDIN> ] --> produces a list of lists of chars where the length and contents are determined by the input supplied from the keyboard or a file via a pipe.
16:14:33 <TFK> o_O
16:14:50 <Philippa> Enveigler1: uh?
16:15:42 <Enveigler1> You said " function-like things that could have multiple results. In particular, when you compose them you want to see each possible result be used as a separate input and generate its own multiple results"
16:16:52 <TFK> Philippa, an example would be appropriate ;-)
16:17:28 <Philippa> TFK: it's gone midnight here, I'm tired and I don't fancy pulling code out of my arse. Consider how you might solve n-queens with this.
16:17:30 <TFK> I think that Gentle has an example, actually.
16:17:55 <Philippa> ("all possible solutions for placing a queen on column n given existing queens here...", recurse...)
16:17:57 <Enveigler1> More fully sub gen { return [ map{ [ split ''] } <STDIN> ] } -- If you call that function it produces a list os lists of chars by splitting each line of input into a list of chars and wrapping them allin a nother list. Does that meet you spec?
16:18:13 <Heffalump> Philippa: what you said above about Haskell and pugs is exactly how I sell it to people.
16:18:55 <Philippa> Enveigler1: technically anything that returns a list does. The useful cases are where you're using a list to represent a one-to-many mapping of results rather than a result-that-is-a-list
16:19:04 <Philippa> well, the useful for non-determinism cases
16:20:15 <Enveigler1> Philippa: "you're using a list to represent a one-to-many mapping of results rather than a result-that-is-a-list" will need a little more explanation?
16:21:07 <TFK> http://www.haskell.org/tutorial/monads.html <--- section 9.2 has some examples, although how it does what it does is a bit beyond me at this stage :-/
16:21:20 <Heffalump> "what is a way of choosing two numbers that add up to 10"
16:21:34 <Heffalump> "what are all the ways of choosing two numbers that add up to 10"
16:22:40 <TFK> positive? are 1,9 and 9,1 the same?
16:22:49 <Enveigler1> Heffalump: How is that "non-determanistic"?
16:23:36 <lispy> TFK: ya
16:23:41 <lispy> TFK: well, on the same part
16:23:48 <shapr> Enveigler1: It'll be so much easier to learn the monadic parts if you start with the pure parts! Really!
16:23:51 <lispy> TFK: but i get negative is allowed
16:24:05 <lispy> s/get/bet/
16:24:23 <Heffalump> tfk: up to you.
16:24:28 <Heffalump> but let's say positive, and no.
16:25:02 <Heffalump> Enveigler1: if you write that using the list monad, you can answer the second question but write the program as if answering the first one.
16:25:12 <Heffalump> do x <- pick_a_number
16:25:16 <Heffalump>    y <- pick_a_number
16:25:21 <Heffalump>    guard (x+y==10)
16:25:27 <Enveigler1> shapr: I've worked my way through some of the tutorials and I can do the exercises. But then I sit down to write a program that does something useful and the first thing I wan to do is gets some input and rpoduce some output.
16:25:42 <Philippa> so do so
16:25:46 <shapr> I suggest starting out with static input pasted into the program source, or something similar.
16:26:06 <Enveigler1> WHy. Can't Haskell do IO?
16:26:07 <shapr> Or ask someone else to write the file reading code for you so you can play with the input.
16:26:11 * shapr smacks Enveigler1 
16:26:14 <lispy> @type guald
16:26:17 <lispy> @type guard
16:26:21 <lambdabot> bzzt
16:26:21 <lambdabot> bzzt
16:26:25 <Heffalump> @type Control.Monad.guard
16:26:28 <lambdabot> Control.Monad.guard :: forall (m :: * -> *).
16:26:28 <lambdabot>         (Control.Monad.MonadPlus m) =>
16:26:28 <lambdabot>         Bool -> m ()
16:26:28 <Enveigler1> You know I have a prorgram that works
16:26:33 <shapr> Enveigler1: Sure, Haskell does IO just fine.
16:26:40 <lispy> Heffalump: thanks, that's a really cool function
16:26:47 <TFK> Enveigler1, you'll have to be very, very careful ;-)
16:27:06 <Heffalump> do c <- getChar
16:27:19 <Heffalump>    putChar c
16:27:29 <Heffalump> what's the opposite of the 'ord' function? I've forgotten.
16:27:34 <Igloo> chr
16:27:34 <shapr> chr
16:27:36 <TFK> chr ?
16:27:37 <wagle> chr
16:27:44 * TFK chuckles
16:27:45 <shapr> Everyone together now..
16:27:47 * shapr leads the chorus
16:27:53 <wagle> heh
16:27:54 <Heffalump>    putChar (chr (ord c + 1))
16:28:16 * Igloo raises you putChar (succ c)
16:28:42 <Heffalump> my version migrates better into doing the appropriate mod 26
16:29:28 <Enveigler> I just do not understand /how/ it works and nobody appears to be able to explain it.
16:29:50 <shapr> The explanations in those tutorials worked for me, but it did take time to study it.
16:30:14 <Heffalump> explain what?
16:30:45 <wagle> @plugs Monad.guard False
16:30:50 <lambdabot> Variable not in scope: `Monad.guard'
16:30:58 <wagle> @plugs Control.Monad.guard False
16:31:00 <TFK> Enveigler, exactly what do you have trouble with?
16:31:00 <lambdabot> <Plugins.Eval>:1:
16:31:00 <lambdabot>   No instance for (Show (m ()))
16:31:00 <lambdabot>   arising from use of `show'
16:31:01 <Enveigler2> I could keep this up all night!
16:31:15 <wagle> @plugs Control.Monad.guard False :: Maybe Int
16:31:16 <lambdabot> Couldn't match `Int' against `()'
16:31:28 <wagle> huh?
16:31:42 <Heffalump> it's m ()
16:31:47 <Heffalump> it's only for aborting computations
16:31:51 <Heffalump> not for producing results
16:32:00 <wagle> i used guard to convert Bool to Maybe Subst
16:32:01 <Enveigler2> Never mind TFK Seems my not falling for speel is rattling the gates. Best I leave of my own free will this time.
16:32:15 <TFK> okie
16:32:30 <Heffalump> guard b = if b then return () else mzero
16:32:31 <wagle> OOOoooohh
16:33:00 <wagle> i hadnt released the type
16:33:33 <wagle> re/qt* /usr/lib/qt*; do \
16:33:34 <wagle> 	  if [ -f $$d/include/qconfig
16:33:50 <wagle> wrong paste buffer..  >(
16:33:57 <wagle> re/qt* /usr/lib/qt*; do \
16:33:57 <wagle> 	  if [ -f $$d/include/qconfig
16:34:01 <wagle> oh well
16:42:21 <lisppaste2> Enveigler pasted "function returning an infinite list of pairs of numbers that add to 10 in Perl" at http://paste.lisp.org/display/9486
16:44:07 <metaperl_vc> wagle: does Haskell have a qt interface?
16:44:59 <wagle> metaperl_vc: dunno..  i was trying to install qt so i could do a "make config" to the linux source on my macosx powerbook
16:45:48 <wagle> ... but darwinports qt3 didnt install itself the way the makefile wanted, so i was poking around..
16:46:01 <wagle> that wasnt the paste buffer i wanted (up there in the scrollback)
16:47:38 <Heffalump> Enveigler2: now make it handle three numbers adding up to 10
16:50:39 <TFK> Hey, I can do that with a generator in Python, too!
16:51:47 <wagle> Heffalump: should make it so it generates all ordered pairs of ints that add up to 10
16:52:02 <shapr> What about a pi spigot?
16:52:17 * shapr fills a glass full of digits of pi
16:54:38 <Enveigler2> Heffalump: And the 4? You show me yours and I'll show you mine :)
16:55:21 <Heffalump> [(a,b,c,d) | a <- [0..10], b <- [0..10], c <- [0..10], d <- [0..10], a+b+c+d == 10]
16:55:36 <Heffalump> (plenty of ways to make that faster, return results in a different order, handle infinities etc)
16:55:48 <TFK> A mere list comprehension?
16:55:49 <wagle> -1, 0, 0, 11?
16:56:50 <wagle> dont shade your eyes, goedelize!  </lehrer>
16:57:06 <Enveigler2> Will that generate -2000, -1, +1, +2010 ?
16:57:16 <TFK> erm, plagiarize?
16:58:06 <Heffalump> Enveigler2: no. But with some modifications it would.
16:58:25 <Heffalump> but bedtime for me
16:58:52 <shapr> Enveigler2: Can you write a lazy fib list in Perl? --> fib = 0 : 1 : zipWith (+) fib (tail fib)
16:58:53 <wagle> [(a,b,c,d) | n <- [0..], let (a,b,c,d) = diagonalize4d n, a+b+c+d == 10]
16:59:25 <TFK> shapr, a generator?
16:59:42 <shapr> Sure.
17:00:16 <Heffalump> wagle: you'd want something like interleave [0..] [-1,-2,..] to get the negative results too
17:00:19 <TFK> So there ya go.
17:00:22 <Heffalump> but that's the general idea
17:00:41 <shapr> TFK: Yeah, but you have to write it! It's no fun to just say how it can be done.
17:00:42 <shapr> g'day Pseudonym
17:00:47 <TFK> shapr, oh, come on!
17:00:51 <TFK> I'll write it.
17:00:55 <shapr> Yay!
17:00:56 <wagle> need to enumerate the 4-D integer coordinates
17:01:18 <xerox> Goodnight 'skellers.
17:01:23 <shapr> g'night xerox
17:01:50 <Enveigler2> That perl function will start where you like and generate *all* combinations of integers neg and pos. Extending it to 3 or 70 is just code. and there is nothing in there that I cannot explain in english!
17:02:12 <Heffalump> well, I can explain my expression in English, and it's shorter and clearer than your code.
17:02:18 <Heffalump> and I know both Perl and Haskell pretty well.
17:02:30 * TFK doesn't know Perl
17:02:34 <wagle> Enveigler2: it doesnt gernerate -1, 11
17:03:07 <Enveigler2> The please, explain what 'liftM' is doing in this "readFiles  = getArgs >>= liftM concat . mapM readFile" please?
17:03:35 <Heffalump> I'm not sure what that has to do with my code.
17:03:48 <Heffalump> But since you asked, it's making concat have a monadic type.
17:03:55 <Heffalump> concat takes a list of strings and gives you a string.
17:04:13 <Heffalump> liftM concat takes an IO operation that produces a list of strings, and gives you an IO operation that produces a string
17:04:35 <Enveigler2> You're right! I goofed! :(
17:05:26 <Heffalump> it's also rather badly written code, in particular the flow of data is neither left-to-right nor right-to-left
17:05:47 <Heffalump> it starts with getArgs, jumps to mapM readFile, then moves to liftM concat
17:06:01 <TFK> http://rafb.net/paste/results/oNQXSr29.html <--- untested fibonacci generator
17:06:34 <Pseudonym> G'day.
17:06:39 <TFK> howdy ho
17:06:49 <wagle> if it type checks, it must be good  8)
17:06:52 <shapr> Heffalump: I rewrote it to clarify - http://www.scannedinavian.org/~shae/ProtoEnveigler.hs
17:06:54 <Heffalump> tfk: can you write the version that's equivalent to shapr's? (i.e. recursive)
17:07:10 <TFK> Is that a recursive definition?
17:07:13 <Pseudonym> shapr has a Fibonacci generator?
17:07:19 <shapr> Hey Pseudonym, think you'll have time for a Pseudcode column?
17:07:25 <Heffalump> tfk: shapr's is..
17:07:28 <Pseudonym> I really, really hope so./
17:07:33 <Enveigler2> That critisism has been levelled by shapr, but  I didn't write it. I also do not have a problem with it. I do have a problem with your explanation.
17:07:35 <wagle> now write a fibonacci generator generator
17:07:43 <shapr> Enveigler2: what's the problem?
17:07:54 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/Math/Fibonacci.hs <- Here's mine
17:07:55 <shapr> Looked like computery english to me :-/
17:08:02 <TFK> It doesn't look recursive.
17:08:06 <Heffalump> shapr: I apologise for insulting your code (and I didn't realise it was your's originally), but the last two lines are really horrible
17:08:15 <TFK> Maybe you mean that it reads its own tail?
17:08:22 <Heffalump> TFK: fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
17:08:25 <Heffalump> that's pretty recursive..
17:08:31 <TFK> Really?
17:08:39 <shapr> Heffalump: It wasn't my code
17:08:44 <TFK> Well, there's a one liner to do the same in Python, but I'd say that the generator is much better.
17:08:46 <Heffalump> the definition of fibs is in terms of itself, what more do you want? :-)
17:08:50 <TFK> Particularly since it doesn't store the entire list.
17:09:00 <TFK> For it to recursve o_O
17:09:02 <shapr> I just wrote more versions in an attempt to illustrate what the original line actually does.
17:09:04 <TFK> *recurse
17:09:07 <Heffalump> shapr: that's ok then :-) But they're still horrible. </flogging a dead horse> ;-)
17:09:16 <shapr> No argument here, I agree with you.
17:09:26 <TFK> Why was bad code shown to a newbie again?
17:09:26 <Heffalump> it doesn't need to store the whole list, that's the beauty of lazy lists.
17:09:30 <Heffalump> But it's still recursive.
17:09:35 <TFK> Heffalump, only the beginning?
17:09:38 <shapr> TFK: I don't know.
17:10:05 <Enveigler2> Shapr: "liftM concat takes an IO operation that produces a list of strings, and gives you an IO operation that produces a string" Why produce aN IO operation? Why not just get the list of strings from the original IO operation and then concat them?
17:10:31 <TFK> Generators don't have to store anything but their internal state. So while that definition may well keep around the already-evaluated part of the list, the generator doesn't have to.
17:10:33 <shapr> Because an IO operation is incomplete.
17:10:45 <Philippa> TFK: GC. HTH HAND
17:10:46 <Heffalump> TFK: garbage collection
17:11:08 <shapr> An IO operation must have the state passed to it in order to actually do something.
17:11:15 <TFK> Will it really be GC-ed? It's by far not obvious.
17:11:18 <shapr> Hiya mfurr
17:11:18 <Philippa> Enveigler2: sure, you can do that. What do you want to do with the result?
17:11:30 <Enveigler2> "Because an IO operation is incomplete." ?
17:11:30 <Heffalump> tfk: it will
17:11:36 <Philippa> TFK: can anything see the head of the list? No? Well then.
17:11:39 <TFK> You promise?
17:11:53 <TFK> Because I *know* that no such issue will plague the generator solution.
17:11:58 <Heffalump> it won't if you do something like newIORef fibs
17:12:01 <Pseudonym> Oh, look.  GHC users don't use linear implicit parameters.  What a big surprise.
17:12:05 <Enveigler2> Philippa: Why would I not be able to do that? (Sorry to answer a question with a question)
17:12:07 <TFK> Philippa, say I want to show the first 1000000 fib numbers.
17:12:07 <yain> yeah
17:12:07 <shapr> Enveigler2: Did you see how the state was passed in those Atkin Monad examples I showed you?
17:12:10 <Heffalump> well, that's great.
17:12:18 <yain> it's refcounting that plagues "the generator solution"
17:12:21 <Heffalump> if you want tha tkind of explicit guarantee, use a language that forces you to be explicit.
17:12:32 <TFK> ^_^
17:12:34 <Philippa> Enveigler2: you can
17:12:43 <Philippa> it's just not necessarily as useful to do so as you might think
17:13:11 <TFK> putStrLn $ concat $ take 100000 $ map show fib
17:13:18 <Philippa> sooner or later you're going to use it as a parameter for another IO operation, and overall you'll have a computation again
17:13:23 <TFK> Or something o_O
17:13:34 <Philippa> the IO monad is meant to work that way, you can't do a bit of IO inside a pure function
17:13:34 <TFK> Better replace that concat with joinList " " or similar.
17:13:53 <mfurr> shapr: ola
17:14:03 <Heffalump> tfk: that should run in constant space
17:14:07 <shapr> mfurr: Â¿como est as?
17:14:13 <TFK> Why?
17:14:23 <TFK> After all, I create a huge string.
17:14:25 <Philippa> because putStrLn will lazily evaluate its parm
17:14:28 <Heffalump> because putStrLn will consume characters as they are produced
17:14:29 <mfurr> shapr, not bad
17:14:44 <Philippa> it never needs to see more than one character and the rest of the (unevaluated) list
17:14:48 <Enveigler2> Hmm. I do not understand that Philippa. I(O) is timely. Once it is done, you have whatever it inputs.
17:15:03 <shapr> mfurr: learning Haskell?
17:15:04 <TFK> Hmmm. That is quite cool. But still non-obvious.
17:15:20 <Philippa> TFK: only because you've not thought about the consequences of laziness :-)
17:15:35 <TFK> Lots of things to keep in one's head.
17:15:37 <Enveigler2> "the IO monad is meant to work that way, you can't do a bit of IO inside a pure function" -- I do not have this problem in C or Java
17:15:53 <mfurr> shapr, a bit.  This channel is a lot more active than #ocaml :)
17:15:55 <Pseudonym> BTW, it's not _precisely_ constant space.
17:16:00 <Philippa> no, you don't. You have the problem of never knowing when code's going to screw you over with side-effects instead
17:16:04 <TFK> Pseudonym, oh?
17:16:05 <Pseudonym> It's actually technically logarithmic space.
17:16:07 <Enveigler2> Which brings me back to my (controversial) point about making easy things hard.
17:16:09 * Heffalump runs the above code and it indeed runs in constant space.
17:16:14 <Pseudonym> Because show of a big Integer doesn't use constant space.
17:16:16 <TFK> Pseudonym, how come?
17:16:16 <Heffalump> yeah, ok, what Pseudonym said.
17:16:26 <TFK> Oh, heh.
17:16:28 <mfurr> shapr, how are you?
17:16:36 <Pseudonym> So for 1000000 values it may matter.
17:16:37 <Pseudonym> Or it may not.
17:16:41 <Heffalump> (admittedly it's 21MB of constant space. But this is in ghci, which probably has some overhead to begin with, and isn't optimising at all)
17:16:51 <Philippa> Enveigler2: learn to use return and it's really not all that hard at all. The alternative is being unable to do IO sanely at all, or losing lazy evaluation which we just saw a nice example of
17:16:52 <shapr> Enveigler2: You're used to dealing with the things that are hard in the languages that you know. Hard and easy have different trade-offs in Haskell.
17:17:04 <TFK> At any case, it sounds more complicated that it needs to be.
17:17:15 <Heffalump> tfk: what is?
17:17:23 * TFK would agree with shapr
17:17:26 <shapr> mfurr: I'm okay, the code is flowing. Saffire looks neat, can it be applied to Haskell as well?
17:17:32 <TFK> A different language, a different mindset.
17:17:33 <Philippa> TFK: because you don't understand the needs. Sorry, but that's what it boils down to
17:17:42 <Heffalump> ok, Pseudonym is right, it's up to 24MB now
17:17:57 <TFK> Heffalump, consider how many things one needs to know in order to make sure that it doesn't blow up on him.
17:18:06 <TFK> Philippa, "the needs"?
17:18:07 <shapr> Enveigler2: Higher order functions and paramterized types don't work well in C, but they're easy as falling off a log in Haskell.
17:18:09 <Pseudonym> In Haskell, global state is hard. :-)
17:18:27 <Pseudonym> But combinatorial search is easy.
17:18:29 <Pseudonym> Go figure.
17:18:37 <Philippa> TFK: The IO monad is pretty much necessary in order to have IO in a lazy language. There are alternative solutions, but all are at least as hard to use
17:18:47 <mfurr> shapr, well, the ideas can be.  But the current code works only on C, whereas haskell does most of its FFI stuff in haskell
17:18:50 * TFK did not mention the IO monad
17:18:57 <Philippa> ah, I misunderstood then
17:19:03 <shapr> mfurr: Ah, I didn't know that. I don't know much about OCaml details.
17:19:17 <Heffalump> what is Saffire?
17:19:21 <Philippa> you think lazy evaluation's complicated, then? Well, sometimes. Sometimes it lets you fire-and-forget
17:19:27 <TFK> I have no problem with these things per se, but pointing out these little things is fun ;-)
17:19:42 <Philippa> and makes people want to hit you
17:19:53 * Heffalump gets bored of the numbers scrolling past and kills off his fibs
17:19:56 <Philippa> there is a word - "troll". Don't be one
17:19:58 <TFK> A good thing they can't over the inet, eh? :-P
17:20:22 <Enveigler2> Philippa: *That* is actually the problem I wanted to tackle. The code as I have it genrates a huge concatenation of all the files--which gets big fast. I want to make it process the files individuallu, or better, line by line or word by word, but I don;t want someone to hand me that solution on a plate. I want to understand how to move from what I have to where I want to be.--But that requires I understand what I have first>
17:20:26 <TFK> I think that Joel Spolsky has a good point when he says, "make wrong code look wrong". In this example, it is not so obvious.
17:20:41 <TFK> Well, chewing the same issue over and over again does become repetitive.
17:20:46 * shapr chews more
17:20:59 * TFK handles shapr more chewy issues
17:21:01 <TFK> *hands
17:21:09 <shapr> mmm, space leaks!
17:21:14 <Heffalump> Enveigler2: do you know about getContents?
17:21:19 <TFK> So I guess I'll go back to the All About Monads.
17:21:59 <Enveigler2> I have seen and used the function... that will get me a file at a time...but what if the file is 2 GB?
17:23:06 <TFK> I think it should be as effecient, because it's lazy. But you have to know that.
17:23:54 <shapr> I think the only problem with laziness is cultural. I think 99% of programmer intuition assumes strictness, and that's why Haskell is so confusing sometimes.
17:24:31 <Heffalump> A big problem with laziness is space leaks..
17:24:38 <Pseudonym> Yes, I agree.
17:24:42 <TFK> Hard to predict...
17:24:44 <Heffalump> Enveigler2: getContents reads a file lazily
17:24:44 <Pseudonym> Space leaks are a huge problem.
17:24:51 <Pseudonym> But only in large programs.
17:25:17 <shapr> I suspect the primary cause of space leaks is intuition based on years of strict code.
17:25:28 <Heffalump> shapr: I disagree.
17:25:29 <Pseudonym> IMO, it should be part of a module's documented interface whether a returned structure is lazy or strict.
17:25:39 <shapr> I wonder how many space leaks could be fixed by arrows instead of monads.
17:25:49 <Pseudonym> Modularising laziness makes it much easier to reason about.
17:25:57 <Pseudonym> shapr: Probably a negative number. :-)
17:25:58 <Enveigler2> Heffalump: I'll play again, but when I used it in a wc program, large files blew memory.
17:26:04 <Heffalump> shapr: it's fundamentally caused by the fact that in many cases it can be cheaper overall to calculate something than to remember how to compute it
17:26:35 <Pseudonym> It's not just that.  There's also the problem of one lazy producer and multiple consumers.
17:26:40 <Heffalump> Enveigler2: I believe that hGetContents "foo" >>= some_strict_length_function
17:26:42 <Heffalump> should be ok.
17:26:51 <Heffalump> But you'd need to make the length function strict somehow, I think.
17:27:01 * TFK points at "hard to predict" sign again
17:27:09 * Heffalump agrees with TFK.
17:27:18 <shapr> I don't think laziness is that hard to predict.
17:27:19 * Philippa puts "easy to predict" sign on TFK (sure, you're right, but hey)
17:27:21 <Enveigler2> OKay. I'll knock something up and see how I fair this time.
17:27:23 <Pseudonym> I think it's no harder to predict than locking behaviour in imperative languages.
17:27:30 <TFK> And that's a minus in my book.
17:27:32 <Pseudonym> And no harder to manage, either.
17:27:36 <Heffalump> I was being a bit unfair in claiming that it's obvious that the fibs program doesn't leak, but in that case I believe it was reasonably easy to predict.
17:27:45 <Pseudonym> All you've got to do is realise that you do have to manage it.
17:27:46 <TFK> Locking?
17:28:01 <Pseudonym> Yes, locking.  Multi-threading.
17:28:07 <TFK> Race conditions?
17:28:16 <shapr> TFK: Ever tried to find a race condition in multithreaded code in Java, C, Python, etc?
17:28:19 <Pseudonym> Deadlocks, more likely.
17:28:19 <TFK> So Haskell doesn't suffer from those at all?
17:28:30 <TFK> Goodness, no. I'm new to threads.
17:28:31 <Heffalump> not if you use STM :-)
17:29:01 <Heffalump> Enveigler2: you will need to pay some attention to the strictness of your consumer
17:29:04 <Enveigler2> Pseudonym: Erlang has some nice constructs for avoiding race conditions and deadlocking.
17:29:05 <Philippa> and it's much easier to reason about the likelihood of it if you mostly use Chans
17:29:09 <TFK> But I was wondering if Haskell offered significant advantage with thread-related work.
17:29:24 <Philippa> play with Control.Concurrent - it ain't bad at it
17:29:26 <shapr> I always thought that Sisyphus was the symbol of debugging multithreadedness problems.
17:29:28 <Pseudonym> Enveigler2: I agree.
17:29:34 <Pseudonym> I was talking specifically about imperative languages.
17:29:37 <TFK> If that's anything like Python's Queue, then it all boils down to good practices.
17:29:41 <Philippa> the main advantage is that by default all values're thread-local
17:29:42 <Heffalump> I think strict_length (x:xs) n = strict_length xs $! (n+1)
17:29:49 <Heffalump> would do it (feed it 0 to begin with)
17:29:58 <Philippa> TFK: it's probably related. Blocks on read if the channel's empty, stuff like that
17:30:07 <Pseudonym> Multiple threads + global mutable state == trouble
17:30:17 <Heffalump> STM is cool. Really.
17:30:24 <TFK> Hmm. I'll have to learn more about threads in general. Meanwhile, I'll take your word for it ;-)
17:30:36 <Enveigler2> I agree that the low-level stuff available in most threading libraries is fraugt with problems. But it is easily tackled.
17:30:49 <Pseudonym> I think the take-home message is that with great power comes great responsibility.
17:31:01 <shapr> Yeah, I agree with that.
17:31:09 <Philippa> Enveigler2: tell that to the folks who did the concurrency course at my uni
17:31:17 <shapr> Laziness gives more flexibility than strictness, but it can bite you too.
17:31:18 <Philippa> (sure, I handled it fine, but hey)
17:31:19 <Pseudonym> It's dead easy to write simple programs in simple languages that don't let you do much.
17:32:13 <Pseudonym> The other saving grace of laziness-related issues is that once you've found them, they're usually extremely easy to fix.
17:32:57 <Heffalump> Pseudonym: I didn't think that was the experience of the GHC developers.
17:33:05 <Heffalump> And it wasn't our experience during our ICFP 2004 entry.
17:33:22 <Heffalump> This year we just did everything with IOArrays (that we then sometimes froze) to be on the safe side.
17:33:34 <Pseudonym> Was it hard to fix or was it hard to track down?
17:33:41 <Pseudonym> I suspect the latter.
17:33:43 <TFK> BTW, it is possible to define recursive fib. in Python/Icon by doing L=[1,1]; <some conditional code> L.append(L[-1]+L[-2])
17:34:02 <Enveigler2> Philippa: I've done it in assembler, so it ought to be portable to any higher language. The basic scheme is that any shared variable can only be written by the producer and read by the consumer and once it is written, it cannot be re-written until it has been read. and cannot be re-read until it is re-written.
17:34:02 <TFK> I've seen an ingenious one-liner to do that, but I forget :-(
17:34:14 <Heffalump> well, we tried to fix it without entirely understanding the problem. I don't think we ever did quite figure it out.
17:34:25 <Pseudonym> Right.
17:34:40 <Pseudonym> I'm not claiming that laziness-related problems are easy to track down.
17:34:46 <Pseudonym> Just that they're easy to fix once you do.
17:35:09 <TFK> Pseudonym, how would you track down the source of the leak?
17:35:11 <Pseudonym> I've found recently, that being aware of how laziness leaks across a module interface fixes most problems.
17:35:36 <Pseudonym> If you document how lazy a producer is, then you're aware of that when you use it.
17:36:09 <Pseudonym> As an example, a compiler phase should, IMO, deepSeq the compilation unit before returning.
17:36:14 <TFK> Suppose you have lots of laziness going around and don't want to plow thourgh the entire documentation.
17:36:29 <Pseudonym> Hang on, free cakes.
17:36:30 <Pseudonym> BRB
17:36:32 <TFK> How would you know what leaks?
17:36:36 <TFK> Free cakes <3
17:36:48 <wagle> Pseudonym: get me one, please
17:36:48 <TFK> In general, free food <3 <3 <3
17:37:13 <Philippa> TFK: with great difficulty. Read the docs on the things you're calling as you start writing code.
17:37:30 <Heffalump> did anyone tell me what Saffire is?
17:37:58 <mfurr> heatsink, Its a tool to statically type check the OCaml foreign interface to C
17:38:01 <TFK> Philippa, people forget.
17:38:16 <Heffalump> oh, is that the thing that was talked about at PLDI?
17:38:19 <mfurr> http://www.cs.umd.edu/~furr/saffire/
17:38:20 <mfurr> yep
17:38:23 <Heffalump> and I'm Heffalump, not Heatsink :-)
17:38:25 <heatsink> did I ask something?
17:38:28 <TFK> Although, people forget everything, everywhere, so...
17:38:31 <heatsink> oh :)
17:38:34 <Philippa> TFK: read the docs after the code's been written, then
17:38:36 <mfurr> er, oops
17:38:40 <wagle> @google saffire ocaml
17:38:41 <mfurr> stupid tab completion
17:38:42 <lambdabot> http://www.cs.umd.edu/~furr/saffire/
17:38:43 <shapr> I think that laziness properties need to be remembered in Haskell like mutability properties need to be remembered in Java.
17:39:03 <Philippa> if in doubt, perform experiments on an operation-by-operation basis
17:39:04 <TFK> What special mutability processes need to be remembered in Java?
17:39:07 <Heffalump> mfurr: did you give the talk?
17:39:13 <mfurr> yes
17:39:17 <Heffalump> shapr: the Haskell FFI is much less unsafe than the O'Caml one
17:39:19 <Philippa> TFK: String vs StringBuffer
17:39:24 <shapr> In J2EE, you can't just code defensively, you have to be flat out paranoid.
17:39:35 <Heffalump> mfurr: I remember the talk, don't quite remeber you though :-) I thought it was neat.
17:39:41 <shapr> Your data can be modified behind your back at any moment.
17:39:46 <TFK> I'll take your word for it, I'm no Java programmer.
17:39:52 <Heffalump> I mainly remember being disgusted by the complete lack of safety in the O'Caml FFI.
17:40:01 <mfurr> htanks
17:40:05 <Heffalump> and the really horrible games you have to play.
17:40:06 <shapr> J2EE apps are honking massive chunks of code, and very hard to predict.
17:40:14 <Heffalump> are you tall with a ponytail?
17:40:23 <mfurr> well, if you want ultimate flexibility interfacing with C, its sometimes useful to do it from C
17:40:38 <mfurr> yes
17:40:46 <TFK> shapr, I'd say that design by contract and exceptions would at least indicate the source of the error.
17:40:46 <Heffalump> ok, I do remember you then :-)
17:40:52 <shapr> The standard J2EE testing tool must be run from inside J2EE, not separately. J2EE requires too much state to be able to do external tets.
17:40:55 <TFK> and assertions.
17:40:58 <shapr> TFK: haha, try it
17:41:12 <shapr> I did it for a coupla years, it wasn't much fun.
17:41:18 <TFK> I believe you.
17:41:40 <shapr> Sometimes you never find the error, you just code around it.
17:41:40 <Heffalump> mfurr: even to the point of being allowed to monkey with low-level representations of O'Caml things?
17:41:59 <Heffalump> seems to me that that kind of interface is almost impossible to make implementation-independent, for example
17:42:11 <wagle> mfurr: oh, you know virgil gligor?
17:42:30 <TFK> Sooo... does anyone here know Icon/Unicon?
17:42:32 <mfurr> wagle, I don't think so...
17:42:49 <mfurr> Heffalump, well, there's only one implementation of OCaml :)
17:43:00 <shapr> Anyway, I'm off to sleep
17:43:17 <wagle> oh..  he's in the ece dept there
17:43:39 <mfurr> ah, he's one of /those/ people ;-)
17:43:46 * TFK too. Sleep is good.
17:44:18 <Heffalump> mfurr: which is not a good thing :-)
17:44:39 <shapr> Pseudonym: oh, if you can get the next Pseudocode done by the first or the second, TMR would be very happy, I think there's four articles right now.
17:45:04 <mfurr> Heffalump, most FFI's are fairly implementation depenedent.  The JNI assumes a fair bit too
17:46:16 <Heffalump> well, the Haskell one seems refreshingly free of that :-)
17:46:26 <Heffalump> I guess I'm just spoilt by it being the only one I've looked at.
17:46:41 <Heffalump> Apart from Perl, which I just expect to be a grotesque hack.
17:47:07 <Heffalump> Oh, and I guess I've looked a bit at the MLton/Mosml ones and they seemed ok, albeit implementation dependent again.
17:47:55 <mfurr> I definately like how haskell parameterizes its FFI
17:48:25 <Heffalump> hmm ,anyone know the status of the GHC ARM target?
17:50:17 <dons> I didn't know it had a status. But Igloo probably has the best idea.
17:50:47 <Heffalump> ok, that means it's no further than when I last looked (some problem with FP regs)
17:50:57 <dons> yep. that's my understanding
17:51:14 <Heffalump> I really should try to understand that. But first I need to sort out Antibuddha.
17:51:39 <Heffalump> I now have a copy of Embedding and Extending Perl so I can *really* cringe at the Perl FFI.
17:52:06 <dons> yikes!
17:52:21 <mfurr> hehe, have fun
17:53:07 <Heffalump> anyway, right now I'm going to bed.
17:53:10 <Enveigler2> Heffalump: Inline::C is much easier than XS.
17:53:34 <mfurr> the inline stuff is kinda cool actually
17:54:06 <Heffalump> Enveigler2: I'm embedding Perl in haskell, so that doesn't help
17:54:12 <yain> embedding is ok
17:54:21 <Heffalump> no, it's not. Really.
17:54:22 <yain> it's extending which is painful
17:54:44 <Heffalump> If you can explain reference counting to me convincingly in less than a page, I might believe you.
17:55:23 <wagle> "dont create circularly linked structures"
17:55:41 <Enveigler2> Explaining reference counting is easy--explaining Perl's implementation of reference counting--I give up :)
17:55:41 <dons> hehe
17:55:51 <Heffalump> yes, I meant Perl's implementation :-)
17:56:06 <Enveigler2> Hey, you can always weaken your references !
17:56:14 <wagle> does perl refcnt circularly linked structures?
17:56:16 <Heffalump> what does that mean?
17:56:18 <Heffalump> wagle: nafaik
17:56:33 <Heffalump> or rather, I don't think it cleans them up. ICBW though.
17:56:42 <wagle> huh..  i wonder how perl made it hard
17:56:43 <Enveigler2> Indeed. Perl's refcounting code is spread all over the darn place
17:56:44 <mfurr> no, that's correct
17:56:55 <Heffalump> wagle: I'd love to understand how.
17:57:21 <Heffalump> they have some concept of a 'mortal', which is a reference that has refcount 1 for now, but will drop to 0 at some poorly specified time in the future.
17:57:47 <mfurr> Heffalump, I know you said you're not familiar with O'Caml's FFI, but there is a perl4caml package which allows you to call perl <-> OCaml
17:57:49 <wagle> dynamic scope?
17:57:58 <Enveigler2> Circular refs do get refcounted--and therefore never get GC'd, unless you manually weaken (decrement) the references that you store in cirular structures
17:59:10 <wagle> http://citeseer.ist.psu.edu/wise97research.html
17:59:11 <Enveigler2> Mortality occurs at ENTER/LEAVE boundaries --LEAVE anyway/
18:08:19 <Heffalump> mfurr: oh, interesting, I should look at that.
18:08:34 <Heffalump> eno-away: how do you know when to do that? (manually decrement)
18:08:43 <Heffalump> s/eno-away/Enveigler2/ # sorry
18:08:50 <Heffalump> oh, he went, that's why tab complete broke
18:09:54 <heatsink> Can i interrupt with an unrelated question? Whoops, too late.
18:14:36 <heatsink> I'm reading about hindley milner typing. http://www.lfcs.inf.ed.ac.uk/reports/98/ECS-LFCS-98-384/ECS-LFCS-98-384.ps.gz on top of page 7 there's an expression that I don't understand: Gamma(x) > tau
18:15:44 <heatsink> Should the Gamma have a bar on top of it?  Is somewhat offtopic but I'd be gratified to hear.
18:17:35 <wagle> heatsink: see the bottom of the same page..  defines an ordering on types
18:17:50 <wagle> (pdf is searchable for ">", 8)
18:19:40 <heatsink> wagle: thx, I hadn't tried to read that far
18:19:48 <Enveigler2> Is there a reason why attempting to compile Example 1 from http://www.zvon.org/other/haskell/Outputsystem/getArgs_f.html would fail with "test.hs:6:10: The last statement in a 'do' construct must be an expression"?
18:19:49 * heatsink can't search pdfs in ghostview
18:20:09 <wagle> thats because you are looking at postscript
18:20:33 <heatsink> oh.
18:20:34 <wagle> i went to the directory http://www.lfcs.inf.ed.ac.uk/reports/98/ECS-LFCS-98-384, and found a pdf there
18:21:00 <heatsink> Enveigler2: the last stmt is an expression.  Maybe not indented correctly?
18:21:18 <wagle> tabs?
18:21:38 <Enveigler2> I checked that... all spaces p of print under the x?
18:22:14 <heatsink> yea
18:22:46 * heatsink can compile it
18:23:06 <Enveigler2> Tell a lie. I had an extra space -- didn;t realise that too many was a problem. Thanks.
18:23:34 <wagle> wroked for me..  8)
18:24:08 <wagle> ahh..  getargs print x
18:26:45 <Pseudonym> Back.
18:26:49 <Pseudonym> Mmmm... cakes.
18:27:08 <wagle> Pseudonym: you get one for me?
18:27:16 <Pseudonym> Yeah, I saved you a chocolate brownie.
18:27:25 <wagle> excellent!
18:27:27 <Pseudonym> Hope you've got the right device drivers.
19:15:44 <MachinShin> hey all
20:01:06 <Enveigler> Anyone around?
20:10:39 <dons> there's always someone around
20:11:35 <seafood> And 90% of the time they're called shapr
20:11:37 <seafood> :)
20:11:49 <reffie> haha
20:11:55 <dons> @seen shapr
20:11:56 <lambdabot> shapr is in #haskell. Last spoke 2 hours, 27 minutes and 15 seconds
20:11:56 <lambdabot> ago.
20:13:08 <lispy> dons: tell me about ghci integration with yi
20:13:15 <lispy> dons: what will that allow?
20:13:17 <lispy> how will it work
20:14:00 <dons> imagine a ghci prompt in the message buffer
20:14:04 <Enveigler> I think I wore shapr out :(
20:14:10 <dons> so you can define new functions, call existing functions etc
20:14:24 <lispy> hmm...
20:14:31 <lispy> but i can't define functions using ghci
20:14:40 <lispy> unless i edit a file and load that
20:14:54 <dons> no, really, you can.
20:15:07 <dons> Prelude> let f x = x + x
20:15:07 <dons> Prelude> f 2
20:15:07 <dons> 4
20:15:25 <lispy> hmm...okay
20:15:34 <lispy> thought you had to give the in part
20:15:37 <lispy> 'in'
20:15:44 <dons> not in ghci
20:15:52 <lispy> cool
20:16:04 <dons> it's running in a do-block
20:16:39 <lispy> in is optional in a do-block?
20:17:37 <dons> we have a special form of 'let' in monadic code, as above
20:20:47 <lispy> so this will of course require ghci to be installed
20:21:08 <dons> sure. probably -package ghc I would imagine
20:21:16 <dons> which will come out with the next ghc releassse
20:21:26 <lispy> okay
20:21:33 <lispy> (just checking my understanding)
20:21:36 <Igloo> major release, isn't it?
20:21:41 <dons> yeah
23:26:57 <dbremner> I've got a design question, if anyone is interested.
23:28:38 <musasabi> Asking rarely hurts.
23:28:52 <dbremner> What is the right way to express something like inheritance?
23:29:32 <musasabi> That depends very much on the context.
23:30:10 <musasabi> If the hierarchy is fixed then using a simple datatype like data Foo = Base ... | D1 ... | D2 ... is the simplest way.
23:30:33 <musasabi> An another way is to make the interface a typeclass and use an existential wrapper.
23:30:36 <dbremner> I'm thinking of an application at my last job. It backed up firewalls for clients. There was an abstract class firewall and subclasses for each of the particular devices.
23:31:13 <musasabi> Then there is the possiblity of using a system of open records for the purpose (OOHaskell is a step in this direction).
23:31:59 <musasabi> dbremner: would it be enough to have a single firewall type and just have different values of the type?
23:33:35 <dbremner> mususabi - it might. The main thing is I don't want to have a lot of if statements for each type of firewall. That was how my predecessor had written it, I came up with the solution that used inheritance.
23:37:42 <dbremner> musasabi - thanks for your input, I'll read up on existential types.
23:39:33 <musasabi> Existential types will solve inheritance to a point - but usually one ends up refactoring them away at some point :-)
23:44:34 <Pseudonym> You can often get rid of if statements by using views.
23:45:40 <dbremner> musasabi - I think I understand how algebraic types would work. To add a new type of firewall, just add to the datatype and change the routines.
23:47:18 <musasabi> dbremner: yes, and make sure most of the functions are using an abstract view of the datatype so they don't need to be changed.
23:48:22 <dbremner> Psuedonym - thanks, I'll have to read up on those.
23:53:16 <Itkovian> http://www.thedailywtf.com/forums/37197/ShowPost.aspx
23:53:23 <Pseudonym> Concrete views are useful if you want to get a simplified view of a data structure.
23:53:24 <Pseudonym> Concrete views are useful if you want to get a simplified view of a data structure.
23:53:26 <Itkovian> a good way to start a fine day. Hello to y'all
23:54:03 <musasabi> hello Itkovian
23:54:12 <Itkovian> hi musasabi
23:54:19 <Pseudonym> @wiki ConcreteView
23:54:20 <lambdabot> http://www.haskell.org/hawiki/ConcreteView
