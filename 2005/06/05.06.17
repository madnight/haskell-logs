00:08:38 <Itkovian> boegel.
00:08:44 <Itkovian> when is the exam?
00:09:13 <boegel> now
00:09:15 <boegel> I'm sick
00:09:28 <boegel> nah, it's this afternoon :)
00:21:26 <boegel> heh, prof D'Hollander has put a example exam online this morning
00:21:29 <boegel> nice timing !
00:36:33 <Itkovian> idd.
00:36:40 <Itkovian> url?
00:37:51 <musasabi> @pointless (\p -> (p >>= \v -> return [v]) `catch` (\_ -> return []))
00:37:52 <lambdabot> (`catch` const (return [])) . ((: []) `fmap`)
00:39:13 <dons> goot bot!
00:40:36 <xerox> @botsnack!
00:40:37 <lambdabot> :)
00:44:09 <boegel> Itkovian: it's on minerva
00:44:29 <Itkovian> hmm, then I'd have to subscribe to the course
00:44:31 <Itkovian> pfft
01:20:26 <Itkovian> how 'finished' is PArrows?
01:27:00 <xerox> JaffaCake, hi!  What do you have in mind when you talk about "doing better than those ruby guys?" that sounds exciting :)
01:28:12 <JaffaCake> I hear that a lot of folks are jumping up and down about how good Ruby is for web programming these days, that's all
01:28:58 <JaffaCake> http://www.onlamp.com/pub/a/onlamp/2005/01/20/rails.html
01:29:03 <xerox> Yep, I know wat they are talking about.
01:29:38 <JaffaCake> they're doing it by auto-generating fragments of javascript
01:29:42 <xerox> I was wondering what you were thinkitg :)
01:30:31 <JaffaCake> a nice combinator library for building a web GUI, run on the server implemented using the same techniques
01:30:52 <JaffaCake> sounds plausible, no?
01:31:03 <xerox> Indeed.
01:32:03 <xerox> Web means statefullness too, what about that?
01:32:11 <mflux_> it could be nice to have a dsl for generating javascript code
01:32:18 <JaffaCake> continuations, presumably
01:32:36 <foxy> what are the technical reasons that there is a monomorphic restriction on Dynamic? (is it to do with unification and class dictionary lookup?)
01:33:41 <JaffaCake> foxy: there's no way to write an instance of Typeable for a polymorphic type
01:34:26 <foxy> couldn't you use type variables as a TyCon?
01:34:56 <dons> foxy, maybe look at how Clean does it
01:35:02 <Itkovian> anybody succeeded in building the PArrows 0.1 lib with ghc-6.4? It fails miserably on my mac, maybe I'm doing something wrong here ...
01:35:08 <JaffaCake> you can wrap a polymorphic type in a datatype and define a Typeable instance for that
01:35:20 <dons> you end up running a unification algo at runtime, instead of an == instance for TypeReps.
01:35:22 <Itkovian> Setup.lhs: internal error: stg_ap_v_ret
01:35:34 <dons> yeah, or wrap a value like JaffaCake suggests.
01:36:29 <foxy> yeah, I understand there's a runtime cost
01:36:33 <dons> but we don't have a way to do this in Haskell, yet. though System.Plugins.Load.pdynload roughly behaves like a polymorphic dynamic
01:36:48 <foxy> dons, I'm still struggling to get my little interpreter to work
01:37:27 <foxy> I also have a hierarchical object library which I would like to have polymorphic methods
01:37:29 <dons> yeah, i've been busy with a paper, so I haven't been hacking recently :)
01:37:37 <foxy> what for?
01:37:54 <dons> HW
01:38:05 <foxy> ;P
01:39:07 <foxy> what's the chance of c++ calls being added to the FFI?
01:41:41 <michaelw> foxy: why not wrap them instead?
01:42:29 <foxy> I'm thinking about the implications of writing a c++ calling library that understands classes
01:45:26 <wli> michaelw: Got any spiffy Haskell/debian stuff going on?
01:52:02 <musasabi> Itkovian: it works, but does not have fancy stuff.
01:52:46 <Itkovian> musasabi: got to get it compiled first ...
01:53:17 <Itkovian> which nick does einar have?
01:54:10 <Heffalump> foxy: understands in the sense of "does virtual dispatch"?
01:54:39 <musasabi> Itkovian: what does it complain? (just checked out a pure copy and it compiled fine with 6.4)
01:55:15 <Itkovian> Setup.lhs: internal error: stg_ap_v_ret
01:55:41 <michaelw> wli: unfortunately not. i am pretty much inactive, till december
01:55:50 <Itkovian> I did do a configure with as prefix ~/lib
01:55:54 <Itkovian> maybe that's wrong
01:56:18 <dons> stg_ap_v_ret isn't good :/
01:56:32 <musasabi> Itkovian: Setup.lhs is just 4 lines long and uses Cabal's defaultMain.
01:56:44 <Itkovian> hmm, buggers
01:56:58 <Itkovian> dons: I've no bloody idea what it refers to
01:57:05 <musasabi> that sounds like a ghc problem.
01:57:27 <musasabi> Itkovian: "cat Setup.lhs" (should show that it contains nothing PArrows specific)
01:57:53 <Itkovian> musasabi: ic
01:58:11 <musasabi> Has installing other cabal packages worked on that machine?
01:58:22 <Itkovian> it's my first ...
01:58:29 <Itkovian> I'm on MacOSX btw
01:58:41 <Itkovian> 10.3
01:59:08 <Itkovian> I hate filing bug reports
02:01:30 <foxy> Heffalump: yup, I have it working too!
02:01:51 <musasabi> Itkovian: care to try http://youzen.b2.fi/~musasabi/test.tar.gz - that should be a minimal testcase for cabal.
02:01:57 <Heffalump> foxy: working how? I'd have thought that a ccall wrapper would do the job
02:02:00 <Itkovian> sure
02:02:57 <Itkovian> same failure
02:02:59 <Itkovian> grrr
02:03:52 <musasabi> Then it will probably affect everything with Cabal.
02:04:53 <Itkovian> prolly, yeah :-(
02:07:35 <musasabi> I think you could use hugs to install cabal packages for ghc though (runhugs -98 Setup.lhs configure --ghc)
02:07:56 <Itkovian> hugs ... hmm, do I have that lying around?
02:08:07 <Itkovian> nope
02:08:08 <Itkovian> ;-)
02:08:40 <foxy> Heffalump: then you'd have to preprocess a C++ header file twice, once for the class and once to create the wrappers
02:08:57 <Heffalump> foxy: true. So what did you do?
02:09:01 <musasabi> I think that may will be resolved swiftly as with Wolfgang the OS X support is usually very good.
02:09:52 <musasabi> s/may//
02:10:25 <foxy> Heffalump, well I currently have objects and dynamic method lookup in Haskell and was wondering about interfacing it to C++ object code.  The haskell side uses Dynamics for everyting
02:10:42 <foxy> s/yt/yth/
02:11:48 <Heffalump> not quite sure I see the point :-)
02:13:01 <foxy> I don't buy OOP, but the application I'm making has use for a hierarchical object database, this is more specific than just objectify everything
02:15:29 * foxy shrugs
02:16:09 <Heffalump> I think the second pre-processing pass would be easier than modifying the FFI inside all the implementations :-)
02:19:45 <foxy> the FFI allows for other calling conventions :P
02:19:51 * boegel leaves for his exam
02:20:27 <Heffalump> yes, but I don't believe anyone has implemented any..
02:20:41 <boegel> is that correct ? 'leaves for' ?
02:20:56 <Heffalump> yes
02:21:05 <boegel> okay then :) bye !
02:24:15 <Itkovian> @type toInt
02:24:20 <lambdabot> bzzt
02:26:20 <Itkovian> @hoogle Num a => a -> Int
02:26:21 <lambdabot> Prelude.floatDigits :: RealFloat a => (a -> Int)
02:27:36 <ndm> @type toInteger
02:27:39 <lambdabot> toInteger :: forall a. (Integral a) => a -> Integer
02:28:44 <ndm> hoogle doesn't understand class constraints yet
02:30:42 <vincenz> Anyone know a c++ parser?
02:30:46 <vincenz> oops...wrong channel
02:31:11 <michaelw> vincenz: gcc surely has one :)
02:33:59 <vincenz> won't do
02:59:23 <JaffaCake> anyone know of a BibTeX parser in Haskell? preferably using parsec
03:03:47 <Lunar^> JaffaCake: from #haskell logs, it seems that monochrom started writing one
03:04:46 <JaffaCake> @seen monochrom
03:04:47 <lambdabot> I saw monochrom leaving #haskell 2 days, 6 hours, 2 minutes and 1
03:04:47 <lambdabot> second ago.
03:05:41 <Lunar^> JaffaCake: http://www.mail-archive.com/haskell@haskell.org/msg16400.html
03:05:51 <Lunar^> JaffaCake: that was is with UUParse
03:05:58 <Lunar^> s/was/one/
03:06:08 <JaffaCake> yes, I saw that one, thanks
03:06:36 <JaffaCake> prefer one using parsec, though
03:11:38 <Lunar^> http://wiki.tcl.tk/14295 <-- erf!
03:12:00 <Lunar^> monadic parsing in tcl
03:13:33 * Itkovian is out to lunch
03:15:05 <xerox> @index unStM
03:15:06 <lambdabot> bzzt
03:15:19 <xerox> oops, nevermind.
03:16:34 <xerox> @get-definition Y
03:16:35 <lambdabot> Y = \f.U(\g.f(U g))
03:22:12 <xerox> @get-definition U
03:22:13 <lambdabot> U = \f. f f
03:30:05 <michaelw> xerox: are you perhaps looking for fix :: (a -> a) -> a ?
03:34:52 <bourbaki> moin
03:39:10 <xerox> michaelw, right :)
03:56:49 * Itkovian is back
04:15:44 <Itkovian> hmm, how to read a floating point number given eg. 1.2E-4, 1.2 ... and ignore the comma ut you also wat to read 1.3+3.2 as two separate flots and a plus token.
04:16:28 <dons> you need to write a lexer :)
04:17:38 <TheHunter> 'evening, dons
04:18:23 <Itkovian> dons: I am doing so :-)
04:18:26 <dons> hey TheHunter :)
04:19:00 <TheHunter> i think we badly need some kind of testing framework for lambdabot, otherwise i'll keep breaking stuff.
04:19:01 <shapr> shazam
04:19:11 <dons> hehe. testing is good.
04:19:52 <dons> luckily the plugin architecture tends to isolate components rather nicely
04:20:07 <dons> so changes to one plugin don't affect anything else
04:20:21 <TheHunter> i also don't like the uncomposability of the state handling.
04:20:45 <shapr> You could do the flippi state transformer thingy
04:21:07 <TheHunter> but i kind of prefer a dead lock to a race condition...
04:21:29 <dons> hmm. also, I noticed that plugins that invoke threads don't have a way to halt threads on @reload
04:21:38 * TheHunter looks at flippi
04:21:42 <dons>  the darcs plugin is the only case of this so far
04:22:17 <Philippa_> TheHunter: you'll want the darcs version
04:22:17 <dons> dead locks are better than races :)
04:22:31 <TheHunter> probably, moduleExit/Init should be called on reload
04:22:44 <dons> yeah. reckon so.
04:23:39 <dons> shapr, we now have (real time) darcs commit msg call backs into lambdabot, thanks to stefan wehr
04:24:08 <dons> looks like:
04:24:10 <dons> 17:27  lambdabot:: [testing:dons] Test commit
04:24:12 <TheHunter> Philippa_, alrighty.
04:25:20 <TheHunter> shapr, flippi state transformer thingy?
04:26:13 <TheHunter> i'm thinking a readMS inside a withMS shouldn't do any harm.
04:26:36 <TheHunter> man, painkillers suck. make you all dizzy.
04:27:10 <dons> makes your types wobbly?
04:27:58 <Philippa_> TheHunter: Flippi's plugins build a transformer stack for an API for page IO
04:28:10 <Philippa_> so you can do things like patch into page writes and record a version history
04:28:22 <xerox> dons, darcs plugin?
04:28:45 <dons> yep.
04:29:02 <dons> should be useful for small groups hacking on projects via irc
04:29:27 <xerox> Oh, something like perl6's bot.
04:29:46 <xerox> <svnbot6> r4735, autrijus++ | * instead of using confusing $P12345 numbers, generate
04:29:46 <xerox> <svnbot6> r4735, autrijus++ |   temp variables with meaningful local names.
04:29:57 <TheHunter> Philippa_, ah, thanks.
04:30:27 <Philippa_> though shapr did just cause me to think about the possibility of building the monad transformer stack from hell instead :-)
04:30:54 <Philippa_> ('twould allow plugin-specific state which is the main use for it - can always constrain it to be state-only)
04:30:59 <TheHunter> that seems to attack a similar problem as lambdabot's output plugins.
04:31:35 <xerox> @google ghc type extensions
04:31:37 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-
04:31:37 <lambdabot> features.html
04:31:45 <xerox> I tried to fix this unsuccesfully.
04:32:01 <Philippa_> TheHunter: probably, yeah
04:32:35 <Philippa_> Flippi's plugin model's still in something of a state of flux 'til the featureset's sufficient to build off though. I've not got page locking at the moment, for example - and that needs fixing now Flippi's got metadata files lying around
04:32:37 <TheHunter> you could also do |data Plugin { pageIOTrans :: IO PageIOT ...| which would allow state to be held in lexical closures.
04:32:58 <TheHunter> xerox, i think i fixed it yesterday.
04:33:03 <TheHunter> the trick is to use ircPrivmsg'
04:33:20 <xerox> There is one?  I'll take a look.
04:33:23 <Philippa_> true
04:33:40 <TheHunter> xerox, that stuff is all very rough around the edges.
04:34:14 <xerox> I was writing something very similar but I gave up.  OK, good.
04:34:52 <TheHunter> basically, different plugins want different output filtering.
04:35:52 <musasabi> Igloo: ping.
04:35:56 <xerox> It would be nice to being able to select what to use between the default ones or provide an ad-hoc one.
04:37:36 <TheHunter> @google ghc type extensions
04:37:38 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
04:37:49 <xerox> :-)
04:38:07 <dons> @version
04:38:08 <lambdabot> lambdabot 3p36, GHC 6.4 (OpenBSD i386)
04:38:08 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:38:22 <TheHunter> also, flood protection might be worthwhile
04:38:29 <TheHunter> @moo
04:38:30 <lambdabot>          (__)
04:38:30 <lambdabot>          (oo)
04:38:30 <lambdabot>   /-------\/
04:38:30 <lambdabot>  / |     ||
04:38:30 <lambdabot> *  ||----||
04:38:31 <TheHunter> @moo
04:38:31 <TheHunter> @moo
04:38:31 <TheHunter> @moo
04:38:31 <TheHunter> @moo
04:38:31 <TheHunter> @moo
04:38:31 <lambdabot>    ~~    ~~
04:38:32 <TheHunter> @moo
04:38:33 <lambdabot>      Cow
04:38:34 <TheHunter> @moo
04:38:37 <xerox> :(
04:38:41 <dons> :)
04:39:01 <xerox> Where could it be implemented?
04:39:06 <Philippa_> TheHunter: I just remembered why I don't want the transformer stack to be monadic...
04:39:18 <Philippa_> threading the damn thing around all my code becomes a pain in the arse :-)
04:40:59 <jlouis> which you do not want, unless the code is in a sadistic mood and you have masochistic tendencies. The funny thing, figuratively speaking, is many people code languages like C and Java, where this is custom
04:41:25 <xerox> Fail: bug in darcs!
04:41:25 <xerox> There was an attempt to write an invalid pending!
04:41:40 <dons> interesting
04:42:37 <jlouis> the only place to take care of floods is in the output module
04:43:21 <TheHunter> it should be handled on the 'irc level', which unfortunately doesn't exist yet.
04:43:29 <xerox> TheHunter, could you explain to me the changes to Karma.hs?
04:43:49 <TheHunter> which ones?
04:44:24 <TheHunter> |writeMS| should only be used with care, because it is likely to produce race conditions.
04:44:45 <TheHunter> suppose you have code like do s <- readMS; writeMS $ f s.
04:45:24 <TheHunter> if f takes a while to compute and two different users simultaneously alter the state, one of the state changes will be lost.
04:45:30 <dons> clear race.
04:46:05 <dons> so usually in Haskell we have some kind of withState function, which locks the state
04:46:17 <Itkovian> @yow
04:46:18 <lambdabot> If I had a Q-TIP, I could prevent th' collapse of NEGOTIATIONS!!
04:46:26 <dons> or even an: atomicModifyState
04:47:08 <TheHunter> the bad news is |withMS| even locks calls to readMS.
04:47:21 <michaelw> don't you get this for free with MVars?
04:47:24 <dons> xerox, you can get an idea of the issues involved in the Control.Concurrent.MVar
04:47:47 <xerox> I'm pleased to see how one could do getKarma :: ... -> Integer.  Thanks much
04:47:47 <dons> hmm, we don't use MVars on the MS, TheHunter?
04:48:01 <michaelw> TheHunter: well, arguably this is a good thing
04:48:02 <TheHunter> sure, we use MVars.
04:48:08 <xerox> dons, I read it multiple times while crawling Yi sources :-)
04:48:15 <dons> yeah, thought so.
04:48:30 <dons> but we have: readMS = liftIO $ readMVar ?ref
04:48:37 <TheHunter> michaelw, i'm not sure. i can't see where it would do any harm.
04:49:07 <michaelw> TheHunter: the second reader will see a soon-to-be outdated value
04:49:39 <TheHunter> oh, you're right.
04:50:21 <TheHunter> maybe readMS should only succeed inside a withMS?
04:53:04 <michaelw> well, first of all it would be good to know which semantics you would like :)
04:54:01 <TheHunter> withMS :: (s -> (s -> LB ()) -> ModuleT s LB a) -> ModuleT s LB a
04:54:03 <TheHunter> withMS f = lbIO $ \conv -> withMWriter ?ref $ \x writer -> do
04:54:03 <TheHunter>   mv <- newMVar x
04:54:03 <TheHunter>   conv $ let ?ref = mv in f x (liftIO . writer)
04:54:30 <TheHunter> this kinda would do the job.
04:55:07 <TheHunter> not sure it's worth it, though.
04:55:38 <TheHunter> well, readMS should return the old state in this case.
04:57:37 <TheHunter> otoh, a nested withMS would be completely ignored, so this is probably a bad idea.
04:58:15 <bourbaki> anyone versed with petri nets here?
04:59:03 <TheHunter> ok, my conclusion seems to be that we should keep sacrificing composability for semantical clarity.
05:02:43 <michaelw> takeMVar has the advantage of avoiding silent failures (races), it can lead to deadlocks, though, and overlong waiting periods. both of which can be dealt with.
05:04:16 <TheHunter> i very much prefer withMS to takeMVar, since you don't have to remember putting the value back in (exactly once!).
05:04:25 <TheHunter> anyway, bbl.
05:04:54 <bourbaki> AHA!
05:05:04 <bourbaki> hey is anyone of you into SMAs?
05:06:17 <michaelw> TheHunter: they are more or less orthogonal, I'd say.  implement withMS in terms of take/putMVar
05:06:40 <integral> @type fromMaybe
05:06:49 <lambdabot> bzzt
05:07:05 <integral> @type Data.Maybe.fromMaybe
05:07:07 <lambdabot> Data.Maybe.fromMaybe :: forall a. a -> Maybe a -> a
05:07:15 <integral> @type Data.Maybe.fromJust
05:07:16 <lambdabot> Data.Maybe.fromJust :: forall a. Maybe a -> a
05:20:58 <Igloo> musasabi?
05:26:49 <ndm> does anyone know of a haskell library for file path manipulations
05:26:58 <ndm> i.e. get the extension from a filename, get the base name etc.
05:27:18 <ndm> (i realise its pretty easy to do, but there are lots of corner cases)
05:28:39 <Philippa_> GHC6.4 comes with one
05:28:47 <Philippa_> and it's not quite so easy to do if you need portability, sadly
05:29:27 <musasabi> Igloo: How should one handle the license of haskell98 standard in Debian?
05:30:00 <ndm> whats it called in GHC 6.4?
05:30:34 <Igloo> musasabi: What makes you think there's a problem with it?
05:30:46 <musasabi> Igloo: I am using parts of hsx which is using parts of the standard in JoinHs. The standard appears to be packaged in Debian, but looking at the license I want to make sure it is DFSG complicant.
05:31:11 <Philippa_> ndm: System.FilePath or something like that
05:31:27 <Igloo> By the standard you mean the report, right?
05:31:57 <musasabi> yes, some people seemed to think that the "modified versions must have a different name clause" was not DFSG free.
05:32:40 <Igloo> Oh, no, it definitely is
05:32:57 <ndm> Philippa_, found it, thanks very much
05:33:32 <Igloo> "The license may require derived works to carry a different name or version number from the original software." (from DFSG point 4)
05:33:35 <Heffalump> musasabi: you're aware that the report is already in Debian?
05:33:41 <musasabi> Heffalump: yes.
05:33:59 <musasabi> nice, just wanted to make sure that it is not a problem.
05:35:57 <michaelw> hs
05:36:04 <michaelw> er, sorry
05:53:21 <basti_> hi
05:58:47 <Itkovian> hi basti_
06:00:28 <bourbaki> does anyone of you know SMAs?
06:01:36 <basti_> SMA?
06:02:16 <bourbaki> self modifying automatas
06:03:38 <michaelw> bourbaki: pointers?
06:04:17 <bourbaki> http://citeseer.ist.psu.edu/rubinstein95selfmodifying.html
06:04:29 <bourbaki> http://www.google.com/search?q=Self-modifying+automata&hl=en&lr=&client=safari&rls=en&start=0&sa=N
06:05:27 <basti_> hum
06:08:23 <bourbaki> michaelw: are you checking out the paper?
06:08:24 <bourbaki> basti_: ?
06:09:11 <basti_> im reading
06:09:16 <basti_> never heard about that
06:09:59 <bourbaki> neither did i :) but im haveing a hard time to get past page 3
06:10:16 <basti_> i have too
06:10:55 <bourbaki> but im haveing that problem in a lot of the cs papers cause they are not very good ordered imho
06:12:02 <Itkovian> hmm
06:13:42 <michaelw> bourbaki: I wonder what their point is. no rationale given why we should be interested in them.
06:13:49 <bourbaki> right
06:13:54 <bourbaki> im not sure if its what i want
06:14:18 <bourbaki> im just not seeing what the allowed thingies are good for or that state function
06:14:34 <bourbaki> what i want is a functional model of a c++ class like model
06:14:40 <bourbaki> without an interpreter
06:14:59 <bourbaki> and something that is like a petrinet but self modifying
06:16:13 <michaelw> hmm? excuse my ignorance, but aren't petrinets just fancy representations of partial orders?
06:16:37 <bourbaki> hm i dont know :)
06:18:12 <Philippa_> bourbaki: typeclass to hell and back and use a modification of IORefs or STRefs
06:18:33 <bourbaki> Philippa_: regarding what?
06:18:43 <Philippa_> alternatively, take the erlang approach to concurrency and give each process/object an in-chan that accepts messages
06:18:53 <Philippa_> function model of a C++ class like model
06:18:58 <bourbaki> i dont think that erlang is capable of what i want to have
06:19:13 <bourbaki> that c++ model i am looking for is like a graph
06:19:25 <bourbaki> and the set functions are functiors of that category
06:19:30 <michaelw> bourbaki: did you write up what you want?
06:19:47 <bourbaki> the problem is how do you get the modifying function in the category graph petrinet what ever
06:20:31 <bourbaki> michaelw: i started once but havent finished yet cause its really mind boggleing and i dont use it just for this but try to get a lot of artificial intelligence stuff in it as well
06:20:43 <michaelw> might I suggest you do that first? it sounds sufficiently complicated that writing up likely clarifies things
06:20:46 <michaelw> um
06:20:47 <bourbaki> i have started out to write this with my own arrows
06:21:18 <bourbaki> and a graph implementation but stopped doing that in haskell because i failed to get the nodes typless
06:21:31 <michaelw> adding stuff to something that's already mind-boggling doesn't sound like a good strategy for me...
06:21:31 <basti_> :-o
06:21:40 <bourbaki> that is i was unable to write a graph implementation that has heterogenous types
06:21:56 <michaelw> bourbaki: sum type wouldn't do?
06:21:57 <bourbaki> michaelw: i try to boil it down to a simple case
06:22:04 <bourbaki> and this is the simplest i can think of
06:22:28 <bourbaki> michaelw: you mean the direct sum type ?
06:23:07 <bourbaki> well i think it would but that would limit me to some types but i guess ill start out with scheme to glue the language stuff together
06:23:17 <bourbaki> so i can use haskell scheme and prolog in that framework
06:24:11 <bourbaki> i can give you a super simple example of the problem if you want i am able to implement what i want but i dont know if that is going along with the rest of my model mathematically
06:25:34 <michaelw> go ahead, preferably out-of-band (lisppaste or so)
06:25:50 <bourbaki> out of band?
06:26:20 <TFK> (HBin is online atm, btw)
06:26:57 <bourbaki> well think of a graph like this
06:27:10 <bourbaki> start node and end node
06:27:15 <michaelw> bourbaki: i find long stuff hard to follow when it's interleaved with IRC chatter
06:27:18 <bourbaki> two transitions from start to end
06:27:32 <bourbaki> ah ok ill write it down and paste it then sec
06:28:10 <TheHunter> michaelw, oh, and takeMVar is a nightmare in presence of exceptions.
06:28:32 <michaelw> well, exceptions are the nightmare
06:29:46 <michaelw> TheHunter: http://lemonodor.com/archives/001145.html#001145
06:29:48 <TheHunter> withMS uses bracket, so i believe you can't completely deadlock plugins.
06:32:06 <basti_> hmm does anyone know where to find the source code for the yampa arcade?
06:32:54 <bourbaki> http://www.rafb.net/paste/results/3u2R2g11.html
06:32:54 <bourbaki> michaelw:
06:37:20 <bourbaki> michaelw: the problem wouldnt really arise if its run in an interpreter
06:37:45 <bourbaki> but it does if the transtitions have to modify the graph they are in
06:40:09 <michaelw> bourbaki: i fail to understand your intentions, unfortunately.  a graph is a structure, it is not modified in itself.
06:40:37 <bourbaki> the graphs edges are functions
06:40:52 <Philippa_> are we talking graph as in graph reduction?
06:40:57 <bourbaki> so if i keep the graph as it is and run the function with an interpreter
06:41:05 <bourbaki> Philippa_: yes kind of
06:41:23 <bourbaki> but if i want to reduce the graph ie useing arrows to crunch edges
06:41:37 <bourbaki> then its not possible to modify it anymore but thats essentially what i want to do
06:42:03 <bourbaki> i want a dynamic graph (program) that is modifying itself without running an interpreter
06:42:42 <bourbaki> if i use an interpreter that part of the code would be outside so it can modify the code
06:42:55 <michaelw> i am interested in your definition of "dynamic graph"
06:43:03 <bourbaki> though i am not sure if that transition of the graphs is a functor
06:43:27 <bourbaki> a dynamic graph is a graph that can change its edges and vertices
06:43:40 <bourbaki> and also add and delete elements to these sets
06:44:06 <michaelw> a graph in the mathematical sense cannot do that.
06:44:22 <michaelw> you probably want some kind of automaton or machine
06:44:36 <bourbaki> to me that is nothing but a graph
06:44:42 <bourbaki> topologically speaking
06:44:50 <michaelw> um
06:45:01 <bourbaki> im interested if there can be an automaton or machine
06:45:03 <michaelw> ther difference is that they have dynamic semantics
06:45:10 <bourbaki> that is able to modify its own structure
06:45:27 <Philippa_> bourbaki: played Mao?
06:45:37 <bourbaki> Philippa_: moo?
06:45:39 <bourbaki> @moo
06:45:40 <lambdabot>           (__)
06:45:40 <lambdabot>           (oo)
06:45:40 <lambdabot>   /--------\/
06:45:40 <lambdabot>  * o|     ||
06:45:40 <lambdabot>     ||----||
06:45:40 <lambdabot>  ooo^^    ^^
06:45:42 <lambdabot>   Cow taking
06:45:42 <bourbaki> ?:)
06:45:44 <lambdabot>     a shit
06:45:54 <vegai> what does unsafePerformIO actually do?
06:46:35 <vegai> i.e., if I have this (and I know this is not good, no need to say that): unsafeRollDice = unsafePerformIO $ getStdRandom (randomR (1,6))
06:47:24 <michaelw> vegai: it creates a parallel universe and hides all the nasty stuff in there and pretends your world has not changed
06:47:32 <vegai> and throws it away then, I guess?
06:47:39 <bourbaki> michaelw: maybe my use of graph is a little crude but you see the problem in what i am trying to achieve dont you?
06:48:24 <vegai> oh, I wish there could be such things as "fully functional random numbers"
06:48:41 <Cale> vegai: you'll get the same random number every time you evaluate unsafeRollDice
06:48:53 <Cale> at least, in ghc you will
06:48:57 <vegai> seems like I have to wrap a large portion of my code inside IO
06:49:08 <vegai> ...only because I need random..
06:49:08 <Cale> Not a large portion
06:49:35 <Cale> you generate a list of random numbers and pass it to your function
06:49:40 <michaelw> vegai: there are ways around it
06:49:40 <vegai> a significantly larger than I would've needed otherwise. Or so it seems. This is just the planning stage, so obviously I might be seeing it wronf
06:49:46 <michaelw> what Cale says
06:49:49 <Cale> you can even pass in an infinite list of them
06:50:18 <vegai> that would be IO [Int]?
06:50:25 <michaelw> bourbaki: not quite, maybe i am dense, but your mathematics and mine don't seem to match :)
06:50:52 <vegai> ohh, right. Now I see it.
06:51:03 <bourbaki> michaelw: ok you know what a usual fsm is like right?
06:51:09 <vegai> thanks for the nudge
06:51:14 <michaelw> bourbaki: yes
06:51:30 <bourbaki> michaelw: ok what i want to do is have something like a fsm that is able to add transtition to itself
06:51:32 <michaelw> vegai: the drawback is that you need to thread this list through your program
06:51:53 <xerox> @docs Random
06:51:54 <lambdabot> Random not available
06:51:57 <xerox> @docs System.Random
06:51:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System.Random.html
06:52:22 <Cale> sg <- getStdGen
06:52:35 <Cale> let as = randomRs (1,6) sg :: [Integer]
06:52:39 * Itkovian found out about "lex" the hard way
06:53:19 <vegai> ohh, there's even a function for it already. Great
06:53:31 <vegai> thank you very much
06:55:58 <michaelw> bourbaki: how about you use a standard fsm with state :: Graph?
06:57:06 <bourbaki> michaelw: but would that allow me to combine (compile) the edges (arrows) then?
06:57:27 <bourbaki> and is that adding of an edge or deleting one still a functor?
06:57:28 <vegai> seems like there's a good solution for everything, but they hardly ever come to me naturally
06:57:44 <vegai> I hope that changes...
06:57:49 <michaelw> vegai: matter of training
06:58:35 <Itkovian> I'm off home. Good weekend all.
07:01:55 <bourbaki> michaelw: still with me?
07:04:53 <xerox> Cale, would it be possibile to create the infinite list with some mdo code?
07:15:56 <bourbaki> TheHunter: still there?
07:16:38 <Speck> oops... I accidentally installed cabal-0.5 because I didn't know I had cabal-1.0
07:18:33 <Speck> now I can't find where it installed to
07:37:03 <TheHunter> yes, kinda
07:37:45 <bourbaki> TheHunter: do you know a way to get new arrows in a diagram useing a functor?
07:38:18 <TheHunter> i don't understand
07:38:41 <bourbaki> TheHunter: do you still remember that graph thingy we talked about a while back?
07:38:52 <dcoutts_> Speck, this should tell you: ghc-pkg field Cabal-0.5 library-dirs
07:39:17 <Speck> I found it
07:39:30 <Speck> can I remove it without editing the (oddly one line) package.conf?
07:39:47 <TheHunter> more or less, yes.
07:40:01 <dcoutts_> ghc-pkg unregister Cabal-0.5
07:40:43 <dcoutts_> Speck, the above command will remove it from the package.conf file
07:40:50 <Speck> ah excellent
07:40:52 <bourbaki> TheHunter: so i have this graph program thingy and want to add an arrow to that category but it needs to be something like a functor cause i need all that thingy to stay a topos
07:43:37 <TheHunter> you can't just add one arrow; if you add it, you need to add other stuff for it to stay a category and even more if you want it to have additional structure.
07:44:22 <bourbaki> TheHunter: hm and how would i have to do that?
07:44:59 <bourbaki> TheHunter: would it help to assume that there are infinitely many identity functions that are differently labled (so that the uniqueness is preserved)?
07:45:48 <TheHunter> there's only one identity.
07:46:05 <dcoutts_> foxy, are you the same as "foxy_" who was asking me questions about Gtk2Hs the other day (when I was sadly not there to answer)?
07:46:36 <foxy> yup
07:46:48 <bourbaki> TheHunter: one real yes but i just thought that i could use that trick to be able to have infinitely many space for the diagrams
07:48:32 <TheHunter> for groups, something like this is called "free product with amalgations", i don't know anything about the categorical analogon.
07:49:56 <TheHunter> well, it's a pullback.
07:50:00 <bourbaki> the problem is that it would never sufice the functor laws even if this is the case or would it?
07:50:16 <bourbaki> why is it a pullback?
07:56:26 <TheHunter> forget what i said. First of all, I meant pushout and not pullback, then i don't think the said free product is the same as adding an arrow.
07:57:22 <TheHunter> my mind isn't very clear today.
07:58:45 <bourbaki> TheHunter: do you think there is a solution for that?
07:59:50 <TheHunter> sure, "adding" an arrow to a category can't be that difficult.
07:59:56 <Speck> what is the best way to use code that you checked out from darcs and is undergoing constant change (e.g., you are submitting patches and checking it out regularly)
08:00:20 <bourbaki> TheHunter: would you mind to tinker around abit with that not necesarrily now
08:02:07 <TheHunter> obviously, given a category C, and two objects, a and b, you just form the category C' with objects the same as in C and arrows all concatenations of arrows of C with the "new" arrow.
08:02:29 <TheHunter> this certainly satisfied some universal property i'm too stupid to come up with right now.
08:03:30 <TheHunter> Speck, push as frequently as possible to avoid conflicts?
08:03:40 <Speck> push?
08:03:58 <TheHunter> or send.
08:04:48 <Speck> oh I don't mean the darcs part
08:04:56 <Speck> I mean using it from within haskell
08:06:07 <TheHunter> i don't think i understand.
08:09:56 <Speck> I guess I shouldn't use its cabal setup
08:11:02 <TheHunter> does it have a Makefile?
08:16:35 <TheHunter> bourbaki, it's a pushout alright. Given C, a, b, consider functors F: 1 -> C and Id : 1 -> 1, your new category is C' = C \coproduct_{<f,g>} 1, 1 being the two-element category with one nonidentity arrow.
08:17:39 <bourbaki> hm i dont quite get that
08:17:53 <bourbaki> C is just a one arrowed category?
08:18:22 <TheHunter> no, C is your "original" category.
08:18:35 <TheHunter> i should've said F0 = a, F1 = b.
08:18:54 <bourbaki> ah ok so a and b are functors?
08:19:30 <TheHunter> no, a and b are objects in C,.
08:19:51 <TheHunter> the two objects your "new" error should be between.
08:19:59 <bourbaki> ah ok
08:20:00 <TheHunter> s/error/arrow/
08:20:15 <bourbaki> freudian slip that is self refferential ;)
08:20:26 <bourbaki> and f and g?
08:20:39 <TheHunter> oh, i meant to write F and G.
08:20:51 <TheHunter> F and Id_1, even
08:20:52 <bourbaki> and whats G?
08:20:55 <bourbaki> heh :)
08:21:38 <bourbaki> that would be quite like a topological glue for two topologies wouldnt it?
08:22:02 <bourbaki> you just glue that new identity and the new edge in there
08:22:22 <TheHunter> i guess so.
08:22:35 <bourbaki> i use the limit also to abstract the compilation process
08:22:47 <TheHunter> it gives you two functors P: C -> C' and Q: 1 -> C'.
08:23:52 <bourbaki> why 2?
08:24:10 <bourbaki> hey esap
08:24:15 <esap> hei
08:24:25 <esap> What's up?
08:24:38 <TheHunter> that's just the construction of the pullback.
08:24:49 <bourbaki> hm sec let me look that up again
08:25:05 <bourbaki> esap: TheHunter and i try to figure something out with CT
08:25:20 <esap> sounds interesting.
08:25:47 <reffie> http://books.slashdot.org/comments.pl?sid=152993&cid=12837416
08:25:48 <bourbaki> once i am able to show that my graph thingy is a topos i can make free use of that since the pullback is just a special case of the limit right?
08:26:59 <bourbaki> TheHunter: http://en.wikipedia.org/wiki/Pullback_%28category_theory%29 this is what i am looking at atm you are reffering to the first diagram arent you?
08:27:18 <TheHunter> it's a colimit.
08:27:37 <bourbaki> where P is my C' and C is Z right?
08:27:59 <bourbaki> the pullback (also called the fiber product) is the limit of a diagram
08:28:17 <TheHunter> just one sec, my internet connection is slowish atm.
08:28:23 <bourbaki> np
08:28:39 * esap thinks of pullbacks as a way to model composition of relations
08:29:00 <bourbaki> esap: i try to add an arrow to a diagram
08:29:29 <TheHunter> dammit, i mixed them up again.
08:30:00 <TheHunter> *that's just the construction of the pushout.
08:30:41 <bourbaki> TheHunter: but in that diagram P is C' and C is Z right?
08:30:49 <bourbaki> er Z is C
08:30:51 <TheHunter> forget that diagram.
08:30:58 <TheHunter> @wikipedia pushout
08:31:01 <lambdabot> http://en.wikipedia.org/wiki/Pushout
08:31:15 <bourbaki> ok sec
08:31:32 <bourbaki> heh
08:31:38 <bourbaki> i think thats not the right thingy ;)
08:31:45 <bourbaki> A pushout is a student counseled or forced out of a school prior to graduation.
08:31:56 <bourbaki> http://en.wikipedia.org/wiki/Pushout_%28category_theory%29
08:32:09 <xerox> @wikipedia Pushout Category Theory
08:32:14 <lambdabot> No result found.
08:32:18 <xerox> oh :(
08:32:32 <xerox> @wikipedia Pushout (category theory)
08:32:35 <lambdabot> http://en.wikipedia.org/wiki/Pushout_%28category_theory%29
08:32:41 <xerox> woot.
08:32:43 <bourbaki> ok so Z is C and P is C' right?
08:33:56 <TheHunter> Given C, a, b, consider functors F: 1 -> C with F0 = a and F1 = b and Id_1 : 1 -> 1, your new category is C' = C \coproduct_{<F,Id_1>} 1.
08:34:34 <TheHunter> Z is 1, X is C and Y is 1.
08:34:43 <TheHunter> f and g are F and Id.
08:35:21 <bourbaki> and P is C'?
08:35:46 <TheHunter> yep. And i_1 and i_2 are the functors that give you 1 and C within your new category.
08:35:53 <TheHunter> esap, sounds reasonable?
08:36:21 <esap> I suppose C is an object and not  category? :-)
08:37:07 <esap> I'm confusing C in F : 1 -> C and in "C \coproduct_...". Are those the same C?
08:37:23 <TheHunter> C is an object in the category of categories.
08:37:45 <TheHunter> *small
08:37:54 <esap> oh, pushouts in CAT?
08:38:10 <bourbaki> esap: we try to get a new arrow in a diagram
08:38:58 <TheHunter> oh, i thought we're trying to add an arrow to a category.
08:39:08 <TheHunter> esap, exactly.
08:39:12 <bourbaki> isnt that essentialy the same?
08:39:36 <TheHunter> adding an arrow to a diagram is trivial: just add it.
08:39:53 <bourbaki> no :)
08:40:00 <bourbaki> my programs are diagrams
08:40:30 <bourbaki> so if i want to add something or delete something i need to be able to add and delete arrows from that program
08:40:36 <bourbaki> or transitions if you like
08:42:23 <bourbaki> hm let me spitball for a second
08:42:29 <bourbaki> can i do this with a pushout
08:42:43 <bourbaki> Z is M1 + M2 / ~
08:42:54 <bourbaki> and X is M1, Y is M2
08:43:30 <bourbaki> hm ... i still dont get it really
08:45:14 <bourbaki> TheHunter:
08:45:23 <bourbaki> .:17:36:48:. < TheHunter> yep. And i_1 and i_2 are the functors that give you 1
08:45:26 <bourbaki>                           and C within your new category.
08:45:59 <bourbaki> isnt that a bit illogical? then P would just consist of C and 1 wouldnt it?
08:48:34 <TheHunter> C'(=P) consists of C, the addidtional arrow, and everything else that's absolutely necessary.
08:49:17 <bourbaki> and whats the additional arrow now?
08:49:20 <bourbaki> id_1?
08:49:41 <TheHunter> C' is only determined up to isomorphism.
08:50:53 <bourbaki> TheHunter: aha i got my answer and this is very pleasing :)
08:51:09 <TheHunter> if you want a concrete representation, you take the same objects, add the additional arrows and all formal arrows that arise from composition of arrows of C and the additional one.
08:51:11 <bourbaki> cause i can change my vocabulaty to topology :))
08:51:21 <bourbaki> The construction of adjunction spaces is an example of pushouts in the category of topological spaces. More precisely, if Z is a subspace of Y and g : Z → Y is the inclusion map we can "glue" Y to another space X along Z using an "attaching map" f : Z → X. The result is the adjunction space  which is just the pushout of f and g. More generally, all identification spaces may be regarded as pushouts in this way.
08:51:57 <bourbaki> since my programs are topologies (diagrams/automatons/graphs) i can just use that definition and am totally fine
08:52:11 <bourbaki> all i need to do now is to show that my programs are topos
08:52:57 <TheHunter> topological spaces, diagrams and categories are hugely different things.
08:53:06 <bourbaki> i think that showing that there always is a limit is quite easy since it can be shown intuitively
08:53:14 <bourbaki> not in the case i defined them
08:53:40 <bourbaki> a graph is a topological space
08:53:46 <bourbaki> and a diagram is a graph
08:54:00 <bourbaki> and a category is renderable as a diagram
08:55:25 <TheHunter> hmm. ". --- . --- ." ". --- ." are different graphs but homeomorphic as topological spaces.
08:56:21 <bourbaki> its not hemeomorph since the mapping would not be bijective
08:56:57 <TheHunter> which topology do you assign the graphs?
08:57:19 <bourbaki> the neighbourhoods are defined over the edges
08:57:27 <bourbaki> the edges are spaces that are [0..1
08:57:34 <bourbaki> ] mappable to this
08:58:21 <TheHunter> so the second graph is [0,1] and the first one is [0,2] ?
08:58:29 <bourbaki> no
08:58:38 <bourbaki> each edge is a space [0..1]
08:58:49 <bourbaki> so you have a neighbourhood for each node
08:58:56 <bourbaki> otherwise it would be just a point
08:59:14 <bourbaki> im searching the site i had
08:59:38 <bourbaki> http://planetmath.org/encyclopedia/GraphTopology.html
08:59:43 <bourbaki> there it is
09:00:13 <bourbaki> and you also see that the homeomorphism of graphs is the same as graph isomorphy
09:01:11 <bourbaki> there is a strong connection between all these things the problem is that something like the pushout cant be part of a diagram that adds something to itself
09:01:32 <TheHunter> i don't believe that.
09:01:45 <bourbaki> the first or the second part :)?
09:02:09 <TheHunter> the graphs ". --- . --- ." and ". --- ." are clearly homeomorphic.
09:02:28 <bourbaki> then tell me how you map the second to the first
09:03:26 <bourbaki> these two spaces are not mappable with a bijection
09:03:43 <TheHunter> the first one's topology is [0,1] \union_1 [1,2], right?
09:04:00 <bourbaki> ah ok now i see what you mean
09:04:17 <bourbaki> but thats what a compilation would be in my case
09:04:25 <bourbaki> its like +++ in arrows
09:04:40 <bourbaki> just reversable
09:05:09 <bourbaki> http://en.wikipedia.org/wiki/Background_and_genesis_of_topos_theory
09:05:21 <bourbaki> im just finding more and more things that are interesting in this
09:05:32 <bourbaki> They include examples drawing on homotopy theory (classifying toposes)
09:05:41 <bourbaki> They involve links between category theory and mathematical logic, and also (as a high-level, organisational discussion) between category theory and theoretical computer science based on type theory.
09:06:58 <TheHunter> i don't know much about toposes.
09:07:11 <bourbaki> do you know what a power object is?
09:07:20 <TheHunter> i'm pretty sure that planetmath page is wrong.
09:07:34 <bourbaki> a topos is just a thingy that is able to build all limits and every object has a power object
09:07:47 <TheHunter> i can look it up :)
09:08:13 <bourbaki> thatd be nice cause i wasnt able to get it on the net
09:08:29 <bourbaki> TheHunter: but you are right for a chain this seems to be wrong
09:09:30 <bourbaki> but i need something like that to compile the programs
09:09:39 <TheHunter> no mention of "power object" in MacLane's definition of topos.
09:09:48 <bourbaki> hm
09:09:53 <bourbaki> http://en.wikipedia.org/wiki/Topos
09:09:59 <bourbaki> A topos is a category which has the following two properties:
09:10:00 <bourbaki> All limits taken over finite index categories exist.
09:10:00 <bourbaki> Every object has a power object.
09:10:01 <TheHunter> just "subobject classifier"
09:10:19 <bourbaki> on that page that is something that is derived from this
09:10:25 <TheHunter> arrgh! *Mac Lane
09:11:25 <TheHunter> ok, here it is.
09:13:21 <TheHunter> To each obejct b, there is an associated object Pb and an arrow \epsilon_b: b x Pb -> \Omega such that for every arrow f: b x a -> \Omega there is a uniqu arrow g: a -> Pb for which the following diagram commutes: [f = \epsilon_b . (1 x g)]
09:15:21 <bourbaki> hm what would be a simple example for that?
09:15:48 <TheHunter> In Set, P maps sets to their powersets.
09:15:52 <bourbaki> or maybe if you do not mind lets just try to see if that is the case in my programs
09:17:02 <bourbaki> all the nodes in my graphs/programs consist of ... well basically any type
09:17:03 <TheHunter> (Set) and \Omega = {0,1}
09:17:16 <esap> Lawvere&Rosebrugh define a functor PX = 2^X, Pf = im_f
09:17:44 <bourbaki> and why is this of importance for a topos?
09:19:05 <TheHunter> and \epsilon_b is something like a characteristic function.
09:19:55 <bourbaki> can you think of something that doesnt have a power object?
09:21:35 <bourbaki> heh
09:21:39 <bourbaki> http://mathworld.wolfram.com/Topos.html
09:21:49 <bourbaki> thats a really funky definition
09:22:19 <bourbaki> ....
09:22:39 <bourbaki> this definition is even better
09:22:40 <bourbaki> http://mathworld.wolfram.com/Logos.html
09:22:52 <bourbaki> A generalization of a Heyting algebra which replaces Boolean algebra in "intuitionistic" logic.
09:22:59 <bourbaki> http://mathworld.wolfram.com/HeytingAlgebra.html
09:23:07 <bourbaki> An algebra which is a special case of a logos.
09:23:25 <esap> good recursive definition :-) :-)
09:23:28 <bourbaki> yes :)
09:23:32 <bourbaki> anyway
09:23:49 <bourbaki> so as long as my functions deal with sets i am on the save side right?
09:23:50 <esap> power object gives equivalence of elements.
09:24:11 <bourbaki> why is that?
09:25:09 <bourbaki> ah
09:25:22 <TheHunter> bourbaki, a more interesting question would have been: can you think of something that does have a power object, except Set?
09:25:26 <bourbaki> P(1 2 3 1) ((1) (2) (3) ... )
09:25:54 <esap> I think there will be a singleton map  {} : X -> PX, which can be constructed as a characteristic map (=) : X x X -> 2 of diagonal map delta_X : X -> XxX. It satisfies  x1 (=) x2 = true <=> x1 = x2
09:26:04 <bourbaki> TheHunter: i think that there has to be one otherwise the definition would be useless :)
09:26:41 <esap> And the characteristic map has exponential transpose  X -> 2^X (where 2^X = PX)
09:27:23 <bourbaki> hm ok i havent understood that at all :)
09:27:34 <bourbaki> i just cant imagine that atm
09:27:34 * esap reads from Lawvere&Rosebrugh "Sets for mathematics"
09:27:58 <esap> bourbaki: Think of (==) operation in Eq class in Haskell, that's the characteristic map.
09:28:01 <bourbaki> but i think that my programs are topos then right?
09:28:20 <bourbaki> characteristic map is something like ~?
09:28:44 <bourbaki> Eq is not the same as =
09:29:05 <bourbaki> but Eq, == are like ~ arent they?
09:29:17 <esap> what is ~ here?
09:29:28 <bourbaki> an equivalence relation
09:31:08 <esap> yes, I think it's an equivalence relation, but since it's characteristic map of the diagonal, I think it's a special kind of equivalence relation
09:31:45 <bourbaki> hm i need to think about this more
09:31:53 <bourbaki> but i think that my programs are topos
09:32:27 <bourbaki> i just wonder what kind of CT things i can use to do proofs and such for my programs
09:32:49 <bourbaki> esap: oh one more thing you maybe able to help me with
09:33:00 <bourbaki> can there be a diagram that adds arrows to itself?
09:33:22 <esap> bourbaki: I don't understand what you mean by "adds arrows to itself".
09:34:10 <bourbaki> well my programs are diagrams or automatons
09:34:24 <bourbaki> and i try to make them dynamic without an interpreter
09:34:36 <esap> bourbaki: I don't see the correlation between an automaton and a diagram.
09:34:44 <bourbaki> for example a stack would just add arrows to itself for new element
09:34:44 <bourbaki> s
09:35:17 <bourbaki> esap: an automation is a graph so its a topology
09:35:33 <bourbaki> and a diagram is also a graph
09:35:38 <bourbaki> so it has also a topology
09:35:49 <bourbaki> and i try to connect these then
09:36:25 <bourbaki> so if you have two alternative paths in your automaton that end up in the same final state
09:36:38 <bourbaki> its the same as commuteing diagrams
09:37:09 <esap> but a diagram is the same as a functor. I think Lawvere&Rosebrugh has a definition of a graph, and I think they define it as a "right A-set". But functors are "left A-sets", which is different, if I've understood correctly.
09:37:39 <bourbaki> whats an Aset?
09:38:36 <bourbaki> but my programs follow the same laws as the categories
09:38:48 <esap> Well it's somewhat hard to define. [A,Set] is a category of left A sets.
09:39:21 <bourbaki> esap: would you mind if i explain it a little more maybe somewhere else?
09:39:36 <bourbaki> TheHunter: if you are interested as well you can join in also
09:50:20 <SyntaxNinja> galois won an award for how fast we're growing :)
09:51:17 <bourbaki> ?
09:51:25 <bourbaki> who is we?
09:51:36 <bourbaki> and why you can win a price for that?
09:52:49 <SyntaxNinja> we is galois
09:53:03 <bourbaki> a study group?
09:53:09 <SyntaxNinja> www.galois.com
09:53:15 <SyntaxNinja> a company
09:53:22 <SyntaxNinja> we do fp stuff :)
10:38:33 <TFK> SyntaxNinja, do you have any comments on Erlang?
10:38:35 <jlouis> heh, I would love to work for galois.com ;)
10:38:51 <jlouis> unfortunately, no bachelors degree in anything ;(
10:40:13 <TFK> I have a Ph.D. in procrasternation, does that count? ;-)
10:40:15 <wagle> jlouis: get one
10:41:00 <jlouis> wagle: oh, I am working on it. The problem is I am studying more algebra than CS right now ;)
10:41:07 <wagle> TFK: we'll get back to you
10:41:24 <wagle> jlouis: thats good, actually
10:41:29 <TFK> Right, let your people call me people.
10:42:14 <wagle> jlouis: need to algebraically manipulate programs and be able to prove things about them
10:43:11 <jlouis> by operational or denotational semantics? Model checking? etc?
10:43:45 <jlouis> I guess so.
10:44:08 <wagle> i know that galois peoiple use a lot of theorem provers
10:45:18 <jlouis> that would make sense, considering what their abilities are
10:47:32 <roconnor> I'm writing ML code.  I feel dirty.  I try to wash, but the dirt doesn't come off. ;)
10:47:47 * jlouis grins
10:47:58 <jlouis> I _started_ with SML.
10:48:28 <roconnor> I wouldn't feel so bad if I weren't using side effects left, right, and centre.
10:49:27 <TFK> "Beware of bugs in the above code; I have only proved it correct, not tried it." -- Donald Knuth :-)
10:49:58 <roconnor> I'm writing ocaml code, but there are no objects, so I imagine it is similar to SML.
10:53:14 <jlouis> roconnor: very. Most of the difference is nothing but syntactic.
10:53:24 <roconnor> I imagine.
10:53:49 <roconnor> I didn't realize that ocaml was made at inria.
11:02:17 <SyntaxNinja> TFK: never used erlang
11:02:43 <SyntaxNinja> jlouis: if you're a good developer, I think a good company can overlook your lack of advanced degree
11:03:27 <SyntaxNinja> we're looking for a test engineer and a formal methods person now, btw.
11:03:58 <jlouis> yes, but in Oregon. I would need a work permit in the US for a start ;)
11:05:06 * SyntaxNinja nods
11:05:13 <jlouis> it was actually more said in fun. But working with FP sounds very interesting
11:19:09 <AtnNn> is there any prelude operator that does like (.) but with 2 arguments? (c -> d) -> (a -> b -> c) -> (a -> b -> d)
11:20:02 <xerox> @pl \f g x y -> f $ g x y
11:20:02 <lambdabot> (.) . (.)
11:20:09 <xerox> @pl \f g x -> f $ g x
11:20:10 <lambdabot> (.)
11:20:13 <xerox> There you go.
11:21:48 * roconnor wonders how @pl is implemented.
11:21:58 <xerox> @version
11:21:59 <lambdabot> lambdabot 3p36, GHC 6.4 (OpenBSD i386)
11:21:59 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:22:20 <xerox> You could get the sources there, lambdabot/Plugins/Pl*
11:22:24 <xerox> Dinner, bbl.
11:22:26 <xerox> ;)
11:56:43 <Speck> Haha! My patch to parrow was committed!
11:57:23 <xerox> Great, what is it about?
11:57:44 <Speck> adding carriage return and newline to the `spaces' character set
11:58:00 <xerox> ^_^
11:58:22 <xerox> Those paches are always welcome.  Otherwise dons would have killed me ages ago.
11:59:06 <roconnor> I've been on a big anarchism kick this week.  Little things like this bring me much hope.
12:02:06 <fraxtal> What's parrow?
12:05:36 <Speck> parsec-like combinator parser written using arrows
12:31:50 <nothingmuch> i'm getting "module Foo does not export glap, bazz", but i think it did before
12:31:54 <nothingmuch> what I'm I doing wrong?
12:32:11 <nothingmuch> it works in ghci
12:32:12 <nothingmuch> but not in ghc
13:00:23 <d`> hello
13:00:29 <AtnNn> hi
13:01:03 <xerox> hi!
13:01:46 <d`> i got question regarding quicksort in its one-line haskell implementation - does it still maintain the same time complexity bounds as other implementations ?
13:02:11 <d`> what concerns me is the "++"
13:02:32 <d`> it goes something like...
13:03:07 <Speck> @index ++
13:03:07 <lambdabot> Data.List, Prelude
13:03:11 <d`> qsort (x:xs) = qsort [y|y <- xs, y <= x] ++ [x] ++ qsort [y|y <- xs, x > x]
13:03:32 <Itkovian> evening
13:03:43 * Itkovian is watching CTHD :-)
13:03:50 <d`> Speck i read the `gentle introduction' which mentions this implementation, but it said nothing about complexity..
13:04:06 <Speck> right
13:04:13 <Speck> I'm a haskell newbie myself
13:04:20 <d`> mhm
13:04:48 <Speck> but you can see the complexity of ++
13:05:13 <d`> you mean it's specified in the library docs ?
13:05:31 <Speck> It's in Data.List
13:05:43 <Speck> it's just an infix method
13:05:47 <Speck> function, rather
13:06:23 <Speck> I know lambdabot has a thing that will point to source code
13:06:38 <Speck> I forget what that command is
13:07:30 <d`> well the `tour of prelude' doesn't specify complexity
13:07:39 <d`> i mean i know how it works
13:08:05 <d`> but it's a more complex thing
13:08:13 <Speck> you'd need to look at its implementation
13:08:22 <xerox> @type (++)
13:08:24 <d`> for example quicsort would create multiple appends
13:08:28 <lambdabot> (++) :: forall a. [a] -> [a] -> [a]
13:08:47 <xerox> It just concatenates two lists.
13:08:47 <d`> and what complexity is it to force them in such a case ?
13:08:58 <d`> xerox i know what it does.
13:09:19 <xerox> For some functions the Haddock documentations shows the complexity too.
13:09:22 <xerox> @docs Prelude
13:09:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
13:09:49 <xerox> That's not the case :-)
13:10:02 <d`> yup.
13:10:26 <d`> ok, let me visualize the problem
13:10:40 <d`> Cons (x, Append (xs, ys))
13:10:53 <d`> comething like this would equal (x:xs) ++ ys
13:11:01 <d`> now in the quicsort above
13:11:14 <Itkovian> rather it would be equal to x:(xs++ys)
13:11:16 <d`> we do multiple ++'s (for each level of recursion)
13:11:27 <d`> so it would be like
13:11:35 <Itkovian> (++) is taking as much time as the lebngth of its first argument afaik
13:11:40 <d`> Cons (x, Append (Append (xs, ys), zs))
13:11:42 <d`> and so on
13:11:55 <d`> and does forcing these
13:12:00 <d`> nested appends
13:12:05 <Speck> (++) infiniteList anyList returns the first list
13:12:12 <d`> give some asymptotic overhead
13:12:12 <d`> ?
13:12:13 <Speck> @ Itkovian
13:12:14 <lambdabot> Maybe you meant: all-dicts arr babel botsnack code define definitions
13:12:14 <lambdabot> del-definition devils dice dict dict-help docs dummy dynamic-load
13:12:14 <lambdabot> dynamic-reload dynamic-unload easton echo elements eurohaskell eval
13:12:14 <lambdabot> fact fact-cons fact-delete fact-set fact-snoc fact-update foldoc
13:12:14 <lambdabot> fortune gazetteer get-definition ghc google help hitchcock hoogle
13:12:15 <lambdabot> index jargon join karma karma+ karma- kind learn leave libsrc
13:12:17 <lambdabot> listchans listcommands listmodules lojban moo more msg part paste pl
13:12:19 <lambdabot> [5 @more lines]
13:12:21 <Speck> oh crap
13:12:44 <d`> Itkovian i know
13:12:50 <d`> Itkovian the case is
13:13:09 <d`> Itkovian whether combining multiple ++'s leaves the complexity at N level
13:13:37 <d`> becasue when we actually need the result
13:13:50 <d`> they are "forced" (really computed)
13:14:10 <d`> and there's a whole lot of them
13:14:14 <d`> stacked up
13:14:28 <xerox> After spot reviewing the applications we've received for the Summer of Code, we were struck with their high quality. As a result, we were able to increase the funds available to support 400 students, double our original number of 200. While this doesn't allow us to take all applicants, we thought that this would be a terrific thing to do for the mentoring organizations, the students, open source software and computer science.
13:14:33 <xerox> dons, I doubled the chances! ahah :)
13:14:41 <d`> ok, let me say this another way
13:14:45 <d`> in a strict language
13:14:52 <d`> this implementation of quicksort
13:14:56 <d`> would be horrible
13:15:03 <d`> does that change in the lazy setting ?
13:15:05 <xerox> d` indeed.
13:15:08 <TFK> xerox, already working on code to submit?
13:15:41 <TFK> Not to sound like an ass, but can you please not break sentences mid-line like that? :-/
13:15:51 <xerox> d` check <http://haskell.org/aboutHaskell.html>
13:16:13 <xerox> TFK, I tought ERC was smart enough to not do that, sorry.
13:16:24 <TFK> ERC?
13:16:38 <xerox> Emacs iRc Client.
13:16:44 <TFK> xerox, oh, I was adressing d` :-/
13:16:54 <xerox> Oh :-)
13:18:33 <Itkovian> d`: ok
13:19:12 <d`> TFK i don't see any other traffic here so, yes, you do sound like an ass, but sure, whatever, consider it done.
13:19:18 <d`> xerox didn't help ;/
13:21:02 <basti_> is there any arrow type that actually makes sense, besides (->)?
13:21:13 <Speck> keeping sentences on a line tends to force a person to think more about whay s/he actually wants to say
13:21:18 <xerox> basti_, what do you mean?
13:21:33 <Speck> s/whay/what
13:21:51 <basti_> well all arrows i've seen somewhat were like: data Thing a b = a->b, instance Arrow Thing where....
13:22:28 <basti_> basically packing functions in the arrow. I know why that makes sense, but i want to know if there's something else that makes sense too
13:22:59 <TFK> d`, thank you for your cooperation.
13:23:50 <d`> hehe
13:24:01 <d`> ok i guess i figured it out
13:24:16 <d`> so, until next time
13:24:33 <Speck> clever guy
13:24:51 <Lemmih> nibro: Ping.
13:30:12 <basti_> mm xerox? any idea? ;)
13:32:11 <xerox> @type (Control.Arrow.&&&)
13:32:16 <lambdabot> (Control.Arrow.&&&) :: forall (a :: * -> * -> *) c' c b.
13:32:16 <lambdabot>         (Control.Arrow.Arrow a) =>
13:32:16 <lambdabot>         a b c -> a b c' -> a b (c, c')
13:32:17 <xerox> @type (Control.Arrow.>>>)
13:32:18 <lambdabot> (Control.Arrow.>>>) :: forall (a :: * -> * -> *) d b c.
13:32:18 <lambdabot>         (Control.Arrow.Arrow a) =>
13:32:18 <lambdabot>         a b c -> a c d -> a b d
13:32:22 <Itkovian> @seen boegel
13:32:23 <lambdabot> I saw boegel leaving #haskell 11 hours, 10 minutes and 16 seconds
13:32:23 <lambdabot> ago, and I have missed 11 seconds since then.
13:32:43 <basti_> xerox: thats arrow operations, not instances of Arrow
13:33:12 <xerox> Oh, instances.
13:33:53 <xerox> instance Monad m => Arrow (Kleisli m) ? :)
13:34:04 * basti_ sighs.
13:34:04 <basti_> ;)
13:34:05 <xerox> Dunno really.
13:34:20 <basti_> its not that my life would depend on it or something
13:41:54 <basti_> you just have to convince yourself that you know it already, then it works
13:42:22 <xerox> ..and you woke up?
13:42:28 <basti_> no
13:42:30 <basti_> i typed:
13:42:35 <basti_> take 10 $ run (pulse >>> (multiply 10))
13:42:42 <basti_> and it wasn't even wrong
13:43:09 <xerox> (>>>) = flip (.) -- :)
13:43:28 <basti_> flip (.) you say.
13:43:35 <basti_> oof.
13:45:11 <basti_> my arrows are a tool.
13:48:42 <bourbaki> :)
13:48:52 <bourbaki> isnt there an armor arrow also?
13:49:01 <basti_> what would that be?
13:49:23 <bourbaki> the object you apply it to falls in love with you ;)
13:49:30 <basti_> amor arrow
13:49:57 <basti_> armor = hard stuff you wear so that no arrows pierce you
13:49:58 <bourbaki> er right
13:49:59 <bourbaki> heh
13:50:16 <ibid> armor arrow would probably make you impervious to later arrows
13:50:25 <bourbaki> right :)
13:50:59 <bourbaki> now i know why all these italian chicks looked a bit startled at me when i told them i wanted to make armore to them ;)
13:51:11 * basti_ doesn't know if he got the intellectual stamina to define that arrow convolution now
13:51:30 <ibid> amor's arrow btw usually pierces two people and make them in love with each other
13:51:31 <basti_> better then babbling about arrows incoherently
13:51:42 <bourbaki> :)
13:51:43 <ibid> the arrower, amor, is not the one that is fallen in love with
13:51:48 <basti_> exactly two?
13:51:54 <basti_> ive seen other setups
13:51:56 <basti_> ;)
13:51:59 <ibid> :)
13:52:08 <ibid> usually two
13:52:39 <ibid> sometimes someone is so hard to penetrate that the arrow only pierce that one person. thus we get ... all together now ...
13:53:01 <basti_> hm?
13:53:05 <ibid> self-love!
13:53:12 <basti_> ahhh.
13:53:57 <basti_> humm
13:53:59 * ibid had to look that word up in the dictionary.  the result was disappointingly obvious
13:54:20 <basti_> well probably they ommited the slang word
13:54:21 <basti_> s
13:54:34 <ibid> itserakkaus s self-love, self-conceit, ego[t]ism
13:54:37 <ibid> says my dictionary
13:55:01 <basti_> if i only knew finnish
13:55:14 <ibid> come to debconf, we'll educate you ;)
13:55:19 <basti_> :P
13:55:23 <kaol> it's not hard. even a child can learn it.
13:55:34 <ibid> itserakkaus is literally self-love
13:55:44 <basti_> lol
13:55:47 <ibid> that's why i was so disappointed
13:55:52 <ibid> itse = self
13:55:58 <ibid> rakkaus = love
13:56:22 <ibid> but i think it's bed time for me now
13:56:25 <basti_> hmm is "masturbation" what you were looking for? ;)
13:56:29 <ibid> no
13:56:32 <basti_> okay
13:56:40 <ibid> not that kind of self-love :)
13:56:43 <basti_> :P
13:56:52 <basti_> maybe the concept isnt formulated well in english
13:56:55 <ibid> the finnish  vernacular for that is runkkaus
13:56:58 <kaol> that's "itsetyydytys", literally translates as self-satisfaction
13:57:24 <basti_> finnish is somewhat cute
13:57:42 <ibid> basti_: i mean, people can say of somebody, "he so in love with himself" (full of himself, etc)
13:57:49 <ibid> he's
13:57:53 <basti_> i think i know what you mean
13:58:19 <ibid> egoism is actually a rather good word for that
13:58:29 <ibid> but it has slightly wrong overtones
13:58:39 * basti_ nods
13:59:08 <kaol> pride might be a bit closer to the meaning of "itserakkaus" than egoism
13:59:26 <basti_> youre thinking like narciss?
13:59:31 <ibid> no, there is good pride and there is bad pride
13:59:38 <ibid> basti_: yes, narcissus
13:59:43 * basti_ nods
13:59:44 <ibid> or was it narcissos
13:59:52 <basti_> depends on the transcription
13:59:57 <basti_> in german he's called narciss
14:00:11 <ibid> if he was greek, then it's likely narcissos
14:00:16 <ibid> if roman, then narcissus
14:00:17 <basti_> i think the "us" or "os" suffixes are gramattical remnants
14:00:25 <basti_> declinations of the name
14:00:33 <ibid> unlikely
14:00:50 <ibid> -us is characteristically latin, -os is characteristically greek
14:01:01 <basti_> yes, but i think its artifacts
14:01:09 <ibid> it's actually more likely that narcissus is a latinification of narcissos
14:01:15 <basti_> yes.
14:01:18 <ibid> yes, but that's no reason to drop them
14:01:35 <basti_> no.
14:01:40 <ibid> like aristoteles is often mangled in english as aristotle
14:01:45 <ibid> or platon as plato
14:03:05 <ibid> i think it is definitely my bed time now :)
14:03:15 <basti_> o
14:03:16 <basti_> k
14:03:17 <basti_> .
14:03:17 <basti_> ;)
14:03:21 <ibid> :
14:03:21 <ibid> )
14:03:33 <ibid> h
14:03:34 <ibid> o
14:03:35 <ibid> w
14:03:36 <ibid>  
14:03:38 <ibid> m
14:03:40 <ibid> u
14:03:42 <ibid> c
14:03:45 <ibid> h
14:03:47 <ibid>  
14:03:50 <ibid> m
14:03:52 <ibid> o
14:03:55 <ibid> r
14:03:57 <ibid> e
14:04:00 <ibid>  
14:04:02 <ibid> ... screen space can i waste :)
14:04:05 <ibid> bye
14:04:12 <kaol> @moo a bit more too
14:04:13 <lambdabot>            (__)
14:04:13 <lambdabot>            (oo)
14:04:13 <lambdabot>    /-oooooo-\/
14:04:13 <lambdabot>   * ooooooooo
14:04:13 <lambdabot>  ooooooooooooo
14:04:14 <lambdabot> ooooooooooooooooo
14:04:16 <lambdabot>   Cow in deep
14:04:18 <lambdabot>       shit
14:05:25 <SyntaxNinja> shapr: how's life?
14:05:44 <ibid> argh, am i cut off the net?!
14:05:59 <ibid> nope
14:06:00 <ibid> http://www.hermann-uwe.de/blog/holy-cow
14:06:04 <ibid> and i'm gone again :)
14:11:56 <SyntaxNinja> ibid: we can see you
14:18:17 <autrijus> @pl fix fix fix
14:18:18 <lambdabot> fix fix fix
14:18:35 <xerox> ahah
14:42:00 <nothingmuch> anybody know why i get "module Foo does not export someFunc" when using ghc but not when using ghci with the same params?
14:42:34 <TheHunter> that's a bug in ghc6.4. it's fixed in the head, i think.
15:37:51 <kaol> @moo since nobody's saying anything
15:37:52 <lambdabot>  *        (__) *      (__)
15:37:52 <lambdabot>   \       (oo) |      (oo)
15:37:52 <lambdabot>    \-------\/  \-------\/
15:37:52 <lambdabot> o  o|     ||   /     ||
15:37:52 <lambdabot>     ||----||>==/-----||
15:37:53 <lambdabot>     ^^    ^^         ^^
15:37:55 <lambdabot>     Cow getting the shit
15:37:57 <lambdabot>      kicked out of her
15:39:05 <reffie> hehe.
15:39:06 <kaol> I'm getting an itch to continue my quest to learn Haskell sometime soon
15:39:27 <kaol> too bad I'm mired with other things right now
15:43:23 <pipe> who made all these cow pics?
15:44:28 <jaro> @moo
15:44:29 <lambdabot>             U
15:44:29 <lambdabot>         /---V
15:44:29 <lambdabot>        * |--|
15:44:29 <lambdabot>  
15:44:29 <lambdabot>  
15:44:29 <lambdabot> Cow at 100 meters.
15:44:58 <jaro> @moo that's nice :))
15:44:59 <lambdabot>           .
15:44:59 <lambdabot>  
15:44:59 <lambdabot>  
15:44:59 <lambdabot>  
15:44:59 <lambdabot> Cow at 10,000 meters.
15:45:37 <jaro> pipe: the last one cow is especially well crafted :)
15:45:56 <kaol> @moo like a haskeller
15:45:58 <lambdabot>          )__(
15:45:58 <lambdabot>          (oo)
15:45:58 <lambdabot>   *-------\/
15:45:58 <lambdabot>  / |     ||
15:45:58 <lambdabot> /  ||----||
15:45:59 <lambdabot>    vv    vv
15:46:01 <lambdabot>  
15:46:03 <lambdabot>  Polish Cow
15:46:07 <pipe> yeah, i appreciate the artist's composition in that one
15:46:43 <jaro> @moo re cows
15:46:43 <lambdabot>       vv    vv
15:46:43 <lambdabot>       ||----||  *
15:46:43 <lambdabot>       ||     | /
15:46:43 <lambdabot>      /\-------/
15:46:43 <lambdabot>     (oo)
15:46:44 <lambdabot>     (~~)
15:46:46 <lambdabot>  
15:46:48 <lambdabot> Australian Cow
15:47:18 <jaro> @moo -p
15:47:18 <lambdabot>               (__)
15:47:18 <lambdabot>          ____ (oo)
15:47:18 <lambdabot>        /-    --\/
15:47:18 <lambdabot>       / |     ||
15:47:18 <lambdabot>      *  ||___-||
15:47:19 <lambdabot>         ^^    ^^
15:47:21 <lambdabot>  
15:47:23 <lambdabot>      Freshman Cow
15:47:25 <lambdabot> After the "Freshman 15"
15:47:58 <kaol> @moo once more
15:47:59 <lambdabot>          (__)
15:47:59 <lambdabot>          (OO)
15:47:59 <lambdabot>   /-------\/
15:47:59 <lambdabot>  / |     ||
15:47:59 <lambdabot> *  ||----||
15:48:00 <lambdabot>    ^^    ^^
15:48:02 <lambdabot>  
15:48:04 <lambdabot> Cow who drank Jolt
15:48:09 <kaol> @moo on mushrooms
15:48:09 <jaro> :)
15:48:10 <lambdabot>             (__)
15:48:10 <lambdabot>             (@@)
15:48:10 <lambdabot>      /-------\/
15:48:12 <lambdabot>     / |     ||
15:48:14 <lambdabot>    *  ||----||
15:48:16 <lambdabot>       ^^    ^^
15:48:18 <lambdabot>  
15:48:20 <lambdabot>    Cow who ate
15:48:22 <lambdabot> psychadelic mushrooms
15:48:43 <jaro> . . . . . . . . . . cow crowd at 10.000 metres
15:48:59 <jaro> ::: very crowded cows
15:49:11 <kaol> @moo bored yet
15:49:12 <lambdabot>           (__)
15:49:12 <lambdabot>           (xx)
15:49:12 <lambdabot>    /-------\/
15:49:12 <lambdabot>   / |     ||
15:49:12 <lambdabot>  *  ||----||
15:49:13 <lambdabot>     ^^    ^^
15:49:15 <lambdabot>  
15:49:17 <lambdabot>  Cow who used Jolt to wash
15:49:19 <lambdabot> down psychadelic mushrooms
15:49:54 * kaol stops spamming
19:09:38 <Speck> quiet in here
19:10:11 <dons> @y0w
19:10:14 <lambdabot> I'm a GENIUS!  I want to dispute sentence structure with SUSAN
19:10:14 <lambdabot> SONTAG!!
19:10:20 <dons> @ghc
19:10:21 <lambdabot>  Bad eta expand
19:10:23 <dons> @code
19:10:25 <lambdabot> FunctorM.hs: fmapM _ Nothing = return Nothing
19:11:39 <Speck> thanks :-)
19:12:00 <dons> hehe
19:12:20 <Speck> My housemates want me to teach a class in Haskell.
19:12:30 <dons> cool :)
19:12:54 <Speck> One is a phyics/mathematics major, the other is writing sems/philosophy, the other is comp sci (but he only knows java/c++)
19:12:58 <dons> I wonder if it's quiet because it's exam study period in the .eu
19:13:13 <dons> oh, very interesting
19:13:22 <Speck> yeah, I'm an english major
19:13:31 <dons> oh, even more interesting :)
19:13:49 <dons> well, there's lots of materials out there for teaching haskell
19:14:05 <dons> you need to pick an angle though -- what do you want to emphasise
19:14:18 <Speck> I'm not sure what my angle is
19:14:32 <Speck> but I like the kind of general approach that Yet Another Haskell Tutorial takes
19:14:58 <dons> ok. there's also the textbooks. and there's a new text book on using Haskell for maths and logiic
19:15:01 <dons> let me find the ref..
19:15:15 <Speck> oh... that would be good for my physics major friend
19:15:30 <Speck> who is trying to learn c++ for his physics work (I keep telling him it's a mistake)
19:16:06 <dons> http://homepages.cwi.nl/~jve/HR/
19:16:11 <dons> The Haskell Road to Logic, Maths and Programming
19:16:27 <dons> first chapter is available online
19:16:35 <Speck> oh, I've been to this page before but I forgot about it. Thanks :-)
19:16:39 <Speck> I should really start keeping bookmarks
19:17:08 <dons> or build an association list in  your brain :)
19:17:54 <Speck> I have a horrible memory
19:18:04 <Speck> which explains partially at least why I never succeeded in math
19:21:31 <Speck> I don't know if I would consider Haskell to be "a member of the Lisp family."
19:23:30 <dons> well, maybe that helps for people roughly familiar with lisp
19:24:38 <dons> the Haskell98 report says: "we particular wish to acknowledge the influence of Lisp"
19:26:54 <Speck> any new language that isn't inspired at least in part by lisp is already on the wrong track, but I see your point
19:28:00 <dons> well, that's true :)
19:30:00 <dcoutts> dons, have you had a chance to look at the Gtk2Hs 0.9.8 release candidate for the OpenBSD ports collection? If you want any changes to go into the release (rather than you having to apply your own patches) you'd better be quick...
19:30:26 <dons> oh! ok. I'll do a build right now!
19:31:04 <dcoutts> we've probably still got most of the problems that we had last time, eg that odd shell script issue with one of the ./configre macros
19:31:21 <dons> ok.
19:32:08 <dons> hmm. do you have a url for the release candidate?
19:32:17 <dons> google is being unfaithful to me
19:32:36 <dcoutts> http://haskell.org/gtk2hs/gtk2hs-0.9.7.92.tar.gz
19:32:50 <dons> ah, it's not 0.9.8 yet :)
19:33:04 <dcoutts> but it will be very soon
19:33:28 <dcoutts> hence me asking if you have any changes you want to be included
19:33:47 <dons> right -- but I've got 2hrs?
19:34:11 <dons> I may only need 1 hr or so.
19:34:30 <dcoutts> well I probably wont actually have time to do the release tomorrow, probably relase on Sunday
19:34:55 <dons> ok.
19:36:17 <dcoutts> and then we'll give packagers another day or two before sending the release announcement to the haskell lists so that packagers have a chance and so we can announce package availability at the same time.
19:36:47 <dons> ok -- I might be able to get an (unofficial) openbsd package for you then.
19:36:54 <dcoutts> that's cool
19:37:06 <dons> heap usage seems good
19:37:11 <dcoutts> :-)
19:37:54 <dons> hasn't gone above 65M yet.
19:38:12 <dcoutts> the limit is set at 80M
19:38:21 <dons> yep.
19:39:34 <dons> what's the oldest ghc I can build this with?
19:39:43 <dcoutts> 5.04
19:39:51 <dcoutts> probably 5.04.3
19:39:59 <dons> I'm wondering also if I should give it a whirl on freebsd, linux-ia64 or mips64?
19:40:18 <dons> hmm. or amd64 for that matter
19:40:23 <dcoutts> I don't think it's ever been tried on mips or ia64
19:40:27 <dons> any of those would be interesting to you?
19:40:29 <dcoutts> amd64 is knwon
19:40:45 <dcoutts> it works except for when it tickels ghc bugs :-)
19:40:54 <dons> hehe
19:41:11 <dons> hmm. ffi is a bit dicey on mips64. I wonder...
19:41:20 <dcoutts> with the latest 6.4.1 pre-release it mostly works except that some of the demos still segfault I think
19:42:02 <dcoutts> does mips64 have the same number of parameters in a ffi foreign dynamic import restriction as sparc?
19:42:27 <dons> ooh. foreign *dynamic* probably isn't going to work
19:42:40 <dons> no adjustor thunks on mips64 ffi
19:42:49 <dcoutts> if so we have a workaround... (which needs a minor change in configure.ac to enable)
19:43:14 <dcoutts> we have a meachanism which avoids adjustor thunks for all signal handlers
19:43:26 <dons> oh. ok. sounds promising
19:43:49 <dcoutts> which covers most cases of callbacks in Gtk2Hs (except idle and timeout handlers)
19:44:23 <dcoutts> it works by using the GHC RTS API to construct Haskell calls
19:44:31 <dons> huh.
19:45:00 <dcoutts> you mean "uh huh" or "huh?"
19:45:21 <dons> huh! == wow
19:45:27 <dcoutts> :-)
19:45:31 <dons> magic++
19:46:37 <dcoutts> it means we don't need to generate lots of stubs, one for each signal type, but instead can use one generic signal hander written in C that used the GHC RTS API to generically invoke the callbacks
19:46:49 <dons> that's cool.
19:46:50 <dcoutts> saves lots of generated code
19:47:02 <dons> what magic flags do you suggest I use for ./configure on mips64?
19:47:54 <dons> oh. i may need to install some other bulid deps first..
19:47:57 <dons> checking build system type... mips-sgi-irix6.5
19:48:06 <dcoutts> try with just --with-hcflags=-H50m (to override the -O default and speed up the build) first time and then see if anything else is necessary
19:48:17 <dons> ok. gtk2hs built without any hacks out of the box on OpenBSD :)
19:48:37 <dcoutts> wow! but what about all the problems we had last time?
19:48:50 <dons> no build problems. testing install and register now..
19:49:09 <dcoutts> it detected to use .cabal files correctly?
19:49:21 <dons> about to see...
19:49:36 <dcoutts> ok... (I suspect the worst...)
19:50:19 <dons> yes. didn't use .cabal
19:51:01 <dcoutts> because it doesn't do the GHC >= 6.4 version check properly because of the shell script wierdness i presume
19:52:24 <dons> yep. same problem as last time it seems
19:52:58 <dcoutts> I wonder if one of your OpenBSD chums could help debug that bit of shell script.
19:53:20 <Speck> shell script?
19:53:37 <dons> was it GTKHS_PROG_CHECK_VERSION?
19:53:57 <dcoutts> yes
19:54:26 <dcoutts> in aclocal.m4
19:54:35 <dons> hmm. I wonder what happens if I force `bash' to be used..
19:54:42 <dcoutts> err acinclude.m4
19:55:08 <dcoutts> it'd probably work, but the comment claims that it is "quite shell-independent and SUSv2 compliant code"
19:55:53 <dons> yeah. hmm..
19:57:09 <dons> ah ha!
19:57:10 <dons> PKGCONF=''
19:57:10 <dons> PKGEXT='cabal'
19:57:14 <dons> by using bash.
19:57:23 <dcoutts> great :-)
19:57:40 <dons> so I would expect this to be a problem on FreeBSD too.
19:58:22 <dcoutts> hmmm, we can check the FreeBSD makefile
19:59:16 * dons reads man sh to find out where the magic is
19:59:27 <dcoutts> http://www.freebsd.org/cgi/cvsweb.cgi/ports/x11-toolkits/hs-gtk2hs/Makefile?rev=1.17&content-type=text/x-cvsweb-markup
19:59:57 <dcoutts> that mentions gnu make but not bash
20:00:42 <dons> hmm
20:01:57 <dons> this would only be a problem with 6.4 builds.
20:02:34 <dcoutts> true, though I'm suprised it doesn't break other things, GTKHS_PROG_CHECK_VERSION is used in several places
20:03:05 <dons> hmm
20:03:45 <dons> it does pass the -ge 6.0.0 check
20:03:54 <dons> oh. hang on. maybe it doesn't.
20:04:30 <dons> nope, it does. hmm
20:06:01 <dons> needs autoreconf-2.13?
20:06:16 <dcoutts> 2.58 or 2.59 probably
20:06:26 <dcoutts> and automake 1.8 or 1.9
20:06:57 <dons> I get with 2.59:
20:06:58 <dons> aclocal: configure.ac: 200: macro `AM_HCFLAGS' not found in library
20:07:09 <dons> and 2.57
20:07:20 <dons> heaps of  errors with 2.52
20:07:25 <dons> nothing with 2.13
20:07:41 <dons> oh. hang on. 2.13 doesn't work at all :/
20:07:50 <dons> but that's not too surprising
20:08:01 <dcoutts> we're not using AM_HCFLAGS as a macro anywhere! (it's used as a variable)
20:08:30 <dons> yeah. I see.
20:08:36 <dcoutts> it can be changed to HCFLAGS reasonably safely I suppose
20:08:43 <dons>   AM_HCFLAGS="-O"
20:09:09 <EzeKno> allguien conoce el juego haskellstein ??
20:09:14 <EzeKno> hecho en haskell ?
20:09:33 <dons> oh, my automake is old.
20:09:38 <dons> 1.4
20:10:06 <dcoutts> that's useually the default, even when more recent versions are isntalled
20:10:17 <dcoutts> try the versioned names, automake-1.8
20:10:33 <dons> installing 1.8 now...
20:11:29 <dons> do you understand this sh: [$]a
20:11:52 <dons> or, say: h1="[$]1"
20:12:02 <dcoutts> it's m4 macro code for $a but the '$' needs eacaping hance '[$]'
20:12:08 <dons> ah, ok.
20:12:19 <dcoutts> (can't spell this evening)
20:12:36 <dons> it's ok. you can talk in your private language :)
20:12:43 <dcoutts> ha!
20:15:38 <dons> ok. automake-1.8 makes things work.
20:15:44 <dcoutts> :-)
20:15:59 <dons> though I get a few warnings on autoreconf, along the lines of:
20:16:00 <dons> underquoted definition of SC_PATH_TKCONFIG
20:16:22 <dons> doesn't appear related to gtk2hs though
20:16:37 <dcoutts> yes, those are from other packages with things that the newer version of aclocal is more strict about
20:16:57 <dcoutts> I get several from various other packages's installed macros
20:17:11 <dons> ok, so GHC_VERSION="6.4"
20:17:29 <dons> now, what's going on in GTKHS_PROG_CHECK_VERSION. hmm.
20:20:36 <dons> this tweak also makes it work: GTKHS_PROG_CHECK_VERSION("$GHC_VERSION".0, -ge, 6.4.0,
20:21:52 <dcoutts> right because the version string parsing is going wrong with "6.4" but with "6.4.0" it works
20:22:25 <dons> yeah
20:24:45 <dons> ok. installs ok with the only patch being 'sh' -> 'bash' in configure.
20:25:51 <dcoutts> hmmm, that's not a change we can make in configure.ac, it always uses sh
20:26:21 <dons> no. you can't make that change, but  I can live with that being the only patch for now.
20:26:31 <dons> until I work out what the bash/sh-ism is.
20:26:33 <dcoutts> so unless we can find out what wrong with the 'portable' shell code it'll have to be patch you apply in your port
20:26:45 <dons> yep. that's ok.
20:26:58 <dons> ok. so now installcheck has the missing pthread issue
20:27:06 <dcoutts> remind me
20:27:17 <dons> Chasing modules from: GConfDemo.hs
20:27:26 <dons> dies with undefined refs to pthread functions
20:27:40 <dons> which was due to missing -lpthread flags to ld, iirc
20:27:46 <dcoutts> so is -pthread in the gconf.cabal file?
20:28:21 <dons> in extra-ld-opts we have -pthread, which is ok.
20:28:47 <dcoutts> but we still get link errors, hmmm
20:29:23 <dcoutts> try ghc with -v to see what the link command is. I suspect the order of -pthread with respect to the other -l flags
20:30:24 <dcoutts> or try changing -pthread for pthread in the gconf.cabal extra-libraries field (ie using -lpthread rather than -pthread)
20:31:07 <dons> no pthread flag is being propagated to the linker when I run with -v
20:31:23 <dcoutts> really? how odd
20:31:40 <dons> we noticed that last time
20:31:51 <dcoutts> so is that a ghc bug then?
20:32:11 <dcoutts> if you pass -optl-pthread it works then?
20:32:12 <dons> hmm. might be picking up the wrong gtk2hs (there's an older version on my disk too)
20:32:31 <dcoutts> ghc-pkg -l should tell us which is exposed
20:35:23 <dons> adding -optl-pthread to the Makefile works
20:36:12 <dcoutts> sounds like a ghc bug to me, let me see what it passes with on linux...
20:38:46 <dcoutts> oh!
20:39:02 <dcoutts> I think the cabal parameter got renamed...
20:39:36 <dcoutts> what does "$ ghc-pkg field gconf-0.9.7.92 ld-options" show?
20:40:03 <dons> hmm
20:40:03 <dons> ld-options:
20:40:25 <dcoutts> We've been using extra-ld-opts, but the cabal field should actually be called "ld-options"
20:40:53 <dcoutts> try editing the installed gconf.cabal file and re-registering
20:49:12 <dons> manually inserting "-pthread" into the ldOptions field works.
20:49:37 <dcoutts> ok, I'll change the field name in the *.cabal.in files
20:54:54 <dons> just rebuilding with the two patches. one for configure, and one for cabal files
21:09:04 <dons> dcoutts, it installs correctly, and all demos run
21:09:13 <dcoutts> yay!
21:09:13 <dons> :)
21:09:22 <stepcut> hey dons! what are you working on these days ?
21:09:39 <dcoutts> ok that .cabal file change will be in the final 0.9.8 release
21:09:48 <dons> dcoutts, cool.
21:10:20 <dons> stepcut, just finished a paper on Yi, and expect to do more Yi soon. hs-plugins is still trundling along as well. Also spend a bit of time hacking lambdabot
21:10:28 <dons> oh, and I'm trying to do a PhD :}
21:10:44 <dcoutts> dons, yeah I know the feeling
21:10:58 <stepcut> dons: nice!
21:11:00 <dons> hehe
21:11:05 <dcoutts> "and also I'm trying to do a PhD"
21:11:09 <dons> we should get open source credits
21:11:16 <dcoutts> yeah
21:11:39 <stepcut> I am writing an ocaml tutorial -- but I am using halipeto to generate the .html ;p
21:11:39 <dons> i'm sure Igloo would be in for that as well
21:11:47 <dcoutts> but but but, look at all these transferable skills! they must be worth something!
21:11:49 <dons> oh, interesting :)
21:11:57 <dons> yeah, I hope so :)
21:12:10 <dcoutts> management, marketing, etc etc
21:12:15 <dons> oh my!
21:12:28 <dons> what fun that would be.
21:12:28 * boegel y0ws
21:12:39 <boegel> it's like 6am over here, and I'm still awake :)
21:13:15 <dcoutts> boegel, presumabley you've just got up, not just going to bed? (unlike myself who'd ust going to bed at 5am)
21:13:34 <dcoutts> (which is why I can't spell atm)
21:13:36 <boegel> dcoutts: haven't seen my bed the last 21 hours
21:14:13 <dcoutts> boegel, is that because you've been in someone else's bed!? shock, horror! ;-)
21:14:14 <boegel> dcoutts: there's loads of stuff going on in our town, people running marathons, 100km, and bars open until 5-6am :) I love it
21:14:23 <boegel> dcoutts: no, I haven't
21:14:27 <dcoutts> oh, I see. :-)
21:14:33 <stepcut> boegel: my girlfiend and I might start on a 3d modeling program in haskell next week
21:14:34 <boegel> I'm fatihfull to my girl :)
21:14:50 <boegel> she was with me by the way :p
21:14:57 <stepcut> boegel: we just need to figure out how to use the opengl selection stuff and we will be ready to start
21:15:27 <boegel> stepcut: start what ? :)
21:15:50 <dons> now gtk2hs is installed and working, I can think about Yi+gtk
21:15:58 <dcoutts> :-)
21:16:01 <stepcut> [21:38] <stepcut> boegel: my girlfiend and I might start on a 3d modeling program in haskell next week
21:16:32 <boegel> wtf ? I never said that
21:16:39 <boegel> oh
21:16:41 <boegel> you did
21:16:47 <boegel> stepcut: cool !
21:16:56 <boegel> which base are you using ?
21:17:22 <stepcut> base?
21:17:40 <boegel> we'll yeah, where will you start ? scenegraph stuff ?
21:18:39 <stepcut> we will start by letting you draw cubes, move them around, and set vertex colors, materials, texture coordanites, etc
21:18:48 <stepcut> and probably move individual points around
21:19:11 <stepcut> then we will add some more basic 3d shapes, like spheres and add group/ungroup stuff
21:19:42 <stepcut> but, early on, it would be nice to output to something that your stuff can read in
21:20:08 <stepcut> so we can draw a 3d scene, and then spit it out to your 3d renderer
21:20:26 <boegel> I see
21:20:45 <boegel> we'll, you might want to check out the H3D wiki, there are some idea's on there
21:20:52 <stepcut> yeah, I looked around a bit
21:20:57 <boegel> also, I'd like to join this project, if possible
21:21:05 <stepcut> the LS (?) stuff looks neat
21:21:42 <dcoutts> stepcut, so are you going to start bugging me about OpenGL support in Gtk2Hs too? :-)
21:21:52 <boegel> stefanw: L-System
21:21:53 <dons> yeah. Yi+
21:21:55 <dons> OpenGL
21:21:57 <stepcut> dcoutts: no, we are just using SDL+OpenGL for now
21:22:02 <dons> that's what I want !!
21:22:23 <stepcut> dons: hehe
21:22:24 <dcoutts> dons, you want Gtk2Hs with OpenGL?
21:22:44 <dons> well, probably not really. but it sounds fun to have an editor with an OpenGL ui
21:22:54 <dcoutts> ha!
21:22:58 <boegel> dcoutts: I do, I DO ç
21:22:59 <stepcut> dons: one of my life goals is to make an nethackGL -- but it will still be 'text' based
21:23:09 <dons> shapr always said he wanted OpenGL Yi
21:23:12 <dcoutts> boegel, I know you do! :-)
21:23:21 * boegel notices only the birds are awake at 6am
21:24:16 * seidan get the idea he's the only one using wxHaskell for GL stuff.
21:24:45 <stepcut> boegel: my gf and I are actually working on a tool for computer assisted comic book/manga artwork, and exploring some ideas about UI design, but I think a lot of the work will be building a general purpose 3D modeller
21:24:52 <dons> seidan, doesn't seafood using wxHaskell for that too?
21:25:00 <dons> yeah, I think he does.
21:25:06 <boegel> stepcut: I'm not really into manga stuff
21:25:22 <dons> seidan, in PanTHeon and its variants
21:25:24 <seidan> dons: oh, cool.
21:25:34 <dcoutts> I'd better get OpenGL working with Gtk2Hs pretty quick then or all our users will leave us for wxHaskell. :-)
21:25:41 * boegel has a strange feeling in his head
21:25:41 <stepcut> boegel: me neither, but my gf eats it up
21:26:06 <stepcut> boegel: though, I have specifically not read manga, but I am likely to get hooked, and then I will not get any work done :)
21:26:15 <dons> seidan, "This is a cross-platform re-implementation of Pan in Haskell using the wxWidgets GUI library and
21:26:18 <dons> OpenGL graphics library."
21:26:30 <dons> www.cse.unsw.edu.au/~sseefried/pan/index.html
21:27:06 <dons> uses wxHaskell >= 0.9.4 with OpenGL support
21:27:10 <seidan> dons, thanks. I was googling for that.
21:27:18 <dcoutts> dons, any idea why it needs OpenGL? it's not using shaders or anything? it's just doing bitmaps right?
21:27:31 <dons> think so, yes.
21:27:53 <dcoutts> wxHaskell provides some kind of bitmap/array support presumably
21:27:55 <dons> umm. /me is clueless about why OpenGL is required. speed?
21:28:03 <seidan> wait, is this like pancito with a ui?
21:28:40 <dcoutts> Gtk2Hs 0.9.8 provides a new "Pixbuf bitmap as MArray instance" feature :-)
21:29:04 * boegel is seeing strange creatures come out of his screen
21:29:07 <dons> seidan, I think it uses a totally different model for the Pan language embedding
21:29:08 <boegel> is that normal ?
21:29:53 <dcoutts> I really should go to bed... bye folks
21:30:08 <boegel> bye dcoutts
21:30:16 <dons> night.
21:30:19 * boegel finds something to do
21:30:39 <stepcut> Yeah, I should go to sleep too, I had very little sleep last night
21:31:28 <Speck> no sleep for me
21:31:32 <Speck> bwa ha ha ha
21:31:32 <seidan> dons, ok... I really want to read more about pantheon, but I have a presentation to work on. bookmarks are our friends.
21:31:52 <dons> Sean's written a couple of papers on the topic, which you may wish to read
21:32:22 <seidan> ok, that's what google gave me for "pantheon haskell" I'll check them out.
21:32:58 <dons> pantheon's his earlier work using TH for optimisations. He's done a new implementation -- panic et al, which uses ghc plugins for optimisations
21:33:53 <seidan> Ok, I see the darcs links now :)
21:33:55 <MachinShin> hey all
21:37:27 <boegel> yo MachinShin
21:44:41 <boegel> hmm, nothing to do, so I guess I'll lay down a bit then
21:44:46 * boegel leaves
21:45:18 <MachinShin> heh
22:36:51 <dons> @seen Lemmih
22:36:53 <lambdabot> Lemmih is in #haskell. Last spoke 9 hours and 12 minutes ago.
22:37:13 <dons> interesting, Lemmih, trying to compile a module that uses TH with profiling:
22:37:14 <dons> ghc-6.4: ./VariableExpansion.p_o: unknown symbol `era'
22:37:21 <dons> looks a lot like our hs-plugins bug...
22:41:34 <dons> @seen seafood
22:41:35 <lambdabot> seafood is in #haskell. I don't know when seafood last spoke.
23:40:54 <gaal> hi, i'm looking for an idiom:
23:41:14 <gaal> i have Maybe foo
23:42:04 <gaal> and i want an expression that yields myfunc1 $ (the Just part fooVal)
23:42:12 <gaal> when foo is a Just;
23:42:32 <gaal> and myOtherFunc2 when foo is Nothing
23:42:57 <gaal> (well, myOtherFunc2 is really a constant.)
23:43:27 <gaal> of course i can do this with cases and stuff, but i *know* there's some funky monadic stuff I can use instead which makes it nice?
23:43:53 <ski> @type Data.Maybe.fromMaybe
23:43:55 <lambdabot> Data.Maybe.fromMaybe :: forall a. a -> Maybe a -> a
23:44:18 <ski> is that what you are looking for ?
23:44:22 <gaal> but i want to apply soemthing to the Just part it it's there
23:44:37 <ski> and still keep the Just ?
23:44:44 <gaal> no
23:45:18 <ski> hm, sorry, i think i meant this
23:45:21 <ski> @type maybe
23:45:22 <lambdabot> maybe :: forall b a. b -> (a -> b) -> Maybe a -> b
23:46:05 <gaal> what module is this in?
23:46:07 <ski> maybe myOtherFunc2 myfuncl foo
23:46:12 <ski> Prelude i think
23:46:53 <mflux_> @index maybe
23:46:54 <lambdabot> Data.Maybe, Prelude
23:46:56 <gaal> yes! that's what i need. thanks!
23:48:32 <gaal> oh, and while i'm at it. i see that definitions like data Foo = MkFoo {....} are very common. my question is whether "Mk" is actually part of the syntax, or only a convention.
23:49:32 <mflux_> surely it must be just a convention
23:49:46 <ski> yes, convention
23:50:12 <gaal> and runXXXX in monads is a convention too, right? (just checking :)
23:50:18 <ski> yes
23:50:24 <gaal> okay, thanks.
23:50:28 <mflux_> I don't think haskell has any magic label patterns
23:50:37 <ski> some folks do data Foo = Foo ...  but then you can't export the type Foo without also exporting the constructor Foo
23:50:38 <mflux_> except lowercase first letter and uppercase
23:51:06 <ski> and infix (data) constructors all start with ':'
23:51:37 <mflux_> well, : is a special character anyway
23:52:24 <ski> no
23:52:24 <ski> not in other cases
23:52:24 <mflux_> I can't have a binding for label 'a:b'
23:52:24 <ski> you can't have that for 'a+b' either
23:52:42 <mflux_> correct. I think somehow we're on the same page then ;)
23:53:49 <ski> +-*/\:!@#$%&=<>|? and prolly a few i've forgot can be used to make infix functions (and constructors)
