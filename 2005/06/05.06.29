00:00:47 <dbremner> Psuedonym and musasabi, thanks for your help. I'm going to head to bed.
00:18:42 <Itkovian> hi, anybody here familiar with boegel's work? I have to tell his promotor about the response of the haskell community, i.e. you guys :-)
00:24:20 <musasabi> Itkovian: the gtk2hs part was a very nice example that drawing works in an easy fashion (I previously thought it was more complicated), but I am not qualified to say anything about the ray tracer part as I don't have experience with graphics algorithms.
00:24:55 <Itkovian> ok. I just told his promotor that people here were pretty enthusiatic about it all.
00:43:11 <astrolabe> I'm only a beginner at haskell, but I've been encouraged to see that something as cool as a ray tracer is even possible; ie. that it isn't just a 'toy' language.
00:43:58 <Itkovian> astrolabe: true, but a Raytracer isn't a good example for that matter, e.g. ghc and darcs are better examples
00:44:52 <astrolabe> But understanding what they do is not as easy as looking at an image
00:45:06 <seidan> but I like how clear boegel's raytracer is. I think /that/ shows one of the main advantages of askell.
00:45:16 <seidan> er... haskell
00:47:17 <Itkovian> trye
00:47:30 <Itkovian> seidan: well, the design was first made in FunMath afaik
00:47:43 <Itkovian> to allow formal proof of certain things
00:48:16 <seidan> well, I just liked how the basic algorithm just jumps right out at you.
00:48:36 * seidan googles FunMath
01:00:38 <Itkovian> it's a framework devised by his promotor akin to imho lamda calculus
01:00:47 <Itkovian> well, it's a formalism to describe programs ...
01:00:57 <Itkovian> @google FunMath Boute
01:00:59 <lambdabot> http://www.intec.rug.ac.be/groupsites/formal/BoutHome.htm
01:01:04 <Itkovian> et voila ;-)
01:06:25 <seidan> thanks. I had found one paper. Google was being too helpful and assuming I was looking for info on how to make math fun...
01:07:30 <Itkovian> hehe
01:07:36 <Itkovian> well, I know his grades ...
01:07:39 <Itkovian> :-)
01:09:11 <earthy> iew
01:09:14 <earthy> funmath
01:09:18 <earthy> eeeeewwwww.
01:09:25 <earthy> too darn many symbols
01:12:11 <seidan> irc shutdown happens to coincide with the beginning of happy hour here :-)
01:17:54 <shapr> @yow !
01:17:55 <lambdabot> I am covered with pure vegetable oil and I am writing a best seller!
01:29:01 <Itkovian> hmm
01:30:44 <shapr> Wed14616: Why does your irc nickname match the day of the week?
01:30:52 <Wed14616> :)
01:31:16 <Wed14616> i takes the day of the week and pastes some random nr behind it
01:31:17 * Itkovian bounces
01:31:28 <Wed14616> takes the burden of coming up with a name :D
01:31:33 <Itkovian> grrr
01:32:40 <Wed14616> a graph problem i wish to implement efficient; I want all (possibly infinite) paths from a certain vertex....
01:33:22 <Wed14616> ow and i would like to have them in increasing length
01:33:48 <Herrchen> look at Dijkstra's algorithm I would say
01:33:48 <Wed14616> any suggestions?
01:34:15 <Wed14616> it also returns them in increasing length?
01:35:25 <Herrchen> it is just a single source shortest path algorithm which can handle any graph with edge-weights greater or equal to zero (if you have negative wieghts use Bellman-Ford); for the list of nodes/distances, you may be able to patch the algorithm to supply that
01:35:44 <Herrchen> one approach would be using STArray to calculate the lengths and then extract the sorted list
01:37:33 <Itkovian> are there any SoC projects done here?
01:37:59 <Herrchen> what is SoC?
01:40:41 <wilx> Google's Summer of Code.
01:49:03 <shapr> I wonder if the 'dark accelerators' are Dyson Spheres.
01:50:29 <shapr> Think these could be Dyson Spheres? --> http://www.physorg.com/news4806.html
01:50:35 * shapr pokes reffie 
01:53:22 <xerox> Itkovian, /me raises hand :-)
01:53:28 <shapr> hiya poetix
01:53:32 <poetix> halloo
01:53:34 <xerox> 'morning shapr :)
01:54:59 <shapr> hiya xerox
01:55:10 <Itkovian> shapr: maybe they're just stars surrounded by a lot of absorbing gasclouds?
01:55:37 <Itkovian> I don't think anybody would ever have the resorces to actually build a dyson sphere ...
01:55:43 <Wed14616> anything known on the time complexity of Data.Graph.reachable?
01:57:05 <swiert> shapr: when's the deadline for TMR?
01:57:06 <Wed14616> O(nr of vertices)?
01:57:26 <shapr> swiert: AT this point, I'm thinking the first or the second.
01:57:53 <swiert> ok - should be all right
01:58:06 <shapr> Itkovian: How much mass would a Dyson Sphere require? more than a solar system worth?
01:58:17 <Itkovian> I'd think so.
01:58:41 * shapr asks wikipedia
01:58:41 <Itkovian> say that you put the thing at earth orbit, then you'd have erm, let me calculate ...
01:58:48 <Itkovian> heh cheater
01:59:13 <Itkovian> lambdabot needs a wikipedia plugin
02:00:02 <shapr> http://en.wikipedia.org/wiki/Dyson_sphere
02:00:09 <shapr> @wikipedia Dyson_sphere
02:00:11 <lambdabot> http://en.wikipedia.org/wiki/Dyson_sphere
02:00:16 <Wed14616> :D
02:00:16 <shapr> Itkovian: tada!
02:00:17 <Itkovian> so 4 pi 150 10^8^2 square metres, take strong material that should be one metre thick, you have then approx 600 pi 10^16 cubic metres
02:00:24 <Itkovian> grr
02:01:08 <Wed14616> i think the whole dyson sphere thing is pretty hypothetical :P
02:01:26 <poetix> Did lambdabot already have a wikipedia plugin, or did it just learn that from the preceding sentence?
02:01:31 <Itkovian> say the density is about that of water, if we'd ever find such a material... we'd need 600 pi 10^19 kg of material
02:02:08 <shapr> Wed14616: So's consciousness, but most of us claim to posess that one ;-)
02:03:14 <Wed14616> if im not conscious, i wonder what i am when im unconscious
02:03:22 <Wed14616> if im not conscious, i wonder what i am when im not unconscious
02:03:40 <Wed14616> ignore the first line :)
02:04:37 <shapr> hiya olliej
02:06:46 <shapr> Man, I could spend the rest of my life reading and writing on wikipedia.
02:07:31 <earthy> yes, it has its lure
02:19:09 <earthy> @wikipedia Siren
02:19:11 <lambdabot> http://en.wikipedia.org/wiki/Siren
02:19:11 <Itkovian> @help foldoc
02:19:12 <lambdabot> I perform dictionary lookups via the following 14 commands:
02:19:12 <lambdabot>  @all-dicts .. Query all databases on dict.org
02:19:12 <lambdabot>  @devils ..... The Devil's Dictionary
02:19:12 <lambdabot>  @easton ..... Easton's 1897 Bible Dictionary
02:19:12 <lambdabot>  @elements ... Elements database
02:19:13 <lambdabot>  @foldoc ..... The Free On-line Dictionary of Computing
02:19:15 <lambdabot>  @gazetteer .. U.S. Gazetteer (1990)
02:19:17 <lambdabot> [8 @more lines]
02:19:44 <Itkovian> @type liftIO
02:19:46 <lambdabot> bzzt
02:19:56 <xerox> @index liftIO
02:19:57 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
02:19:57 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
02:19:57 <lambdabot> Monad.Error, Control.Monad.List
02:20:01 <dons> @type Control.Monad.Trans.liftIO
02:20:03 <lambdabot> Control.Monad.Trans.liftIO :: forall (m :: * -> *) a.
02:20:03 <lambdabot>           (Control.Monad.Trans.MonadIO m) =>
02:20:03 <lambdabot>           IO a -> m a
02:20:04 <Itkovian> @type Control.Monad.Trans.liftIO
02:20:05 <lambdabot> Control.Monad.Trans.liftIO :: forall (m :: * -> *) a.
02:20:05 <lambdabot>           (Control.Monad.Trans.MonadIO m) =>
02:20:05 <lambdabot>           IO a -> m a
02:20:08 <shapr> g'day dons
02:20:13 <dons> heya shapr
02:20:24 <shapr> I was gonna ask you something, I wonder what...
02:20:28 <Itkovian> @type Control.Monad.State.liftIO
02:20:29 <lambdabot> Control.Monad.State.liftIO :: forall (m :: * -> *) a.
02:20:29 <lambdabot>           (Control.Monad.Trans.MonadIO m) =>
02:20:29 <lambdabot>           IO a -> m a
02:20:30 <JaffaCake> dons: any idea what all those GHCi test failures on OpenBSD are?
02:20:51 <xerox> dons, hi! I should tell you that the Yi project was rejected :-\ I'm sorry.
02:22:01 <Itkovian> btw, since the sequence is drupal based, maybe I should let you know that Dries is getting married ... see drupal.org
02:22:50 <dons> JaffaCake, oh! I'll have a peek.
02:23:01 <shapr> I should really write down or email stuff immediately. I wish I had more focus than a gerbil.
02:23:14 <dons> xerox, oh well, it was worth a try :)
02:23:44 <xerox> dons, yeah!  They preferred a not-so-much research project, but still an Haskell one, and it's great :-)
02:24:18 <dons> did any Haskell projects get accepted, I wonder?
02:24:22 <shapr> Yeah, any?
02:24:40 <dons> if not, we need to think about how to approach this next year -- if they do it again.
02:24:56 <Itkovian> xerox is doing one he told me
02:25:09 <xerox> Yup.
02:25:21 <dons> xerox, oh! you got a different project accepted?!
02:25:37 <xerox> Exactly!  Studends could have sent multiple proposals.
02:25:46 <dons> ah ha! well done!
02:25:49 <dons> @karma+ xerox
02:25:50 <lambdabot> xerox's karma raised to 4.
02:25:54 <xerox> Thanks much :-D
02:25:55 <shapr> @karma+ xerox
02:25:56 <lambdabot> xerox's karma raised to 5.
02:26:00 <shapr> What project was accepted?
02:26:01 <xerox> I'm working on the cairo bindings and integration in GtkHs.
02:26:05 <shapr> w00!
02:27:01 <shapr> into gtk+hs or gtk2hs ?
02:27:07 <xerox> http://151.42.234.254/~paolo/google-soc-application-hscairo+gtk2hs.text
02:27:12 <xerox> Gtk2Hs.
02:27:12 <dons> I guess: 2
02:28:01 <xerox> Yup.
02:28:09 <shapr> nice!
02:28:21 <xerox> I'm pinging dcoutts_ from days, ICFPC stole him.
02:28:41 <xerox> I'm going on vacation on July, without internet connection, and that's a problem.
02:28:44 <Heffalump> I think he's doing an open day today.
02:28:51 <dons> yeah, ICFPc tends to do that ;)
02:29:07 <Itkovian> nice
02:29:20 <Heffalump> xerox: did you send him an email?
02:29:28 <xerox> Heffalump, yup.
02:29:57 <xerox> On the 25th.  I probably should try mail him again.
02:32:08 <xerox> AFK for a while, thanks for the support :)
02:33:15 <Trevion> hey .. anyone feel like answering a stupid IO question?
02:35:51 <dons> ask away
02:36:13 <Trevion> I have a small program that converts programs from Unix to Windows line endings (and vice versa)
02:36:39 <Trevion> Currently, it works by calling readFile on the input file, changing the line endings, and then using writeFile to write the output file
02:37:16 <Trevion> If I provide the same name for the read and write files, I get a file locked error (this is on Windows, btw) .. I assume because readFile doesn't close the file it opens?
02:37:43 <Trevion> Is there an (easy?) better way to do this?
02:38:01 <dons> write the file to a temp file, and copy it over the original?
02:38:15 <Enveigler> se Perl
02:38:40 <Trevion> haha, I've played with Perl occasionally... but my brain always starts hurting. ;-)
02:39:07 <Trevion> and at this point, it seems like giving up to use another tool, even if it would make it easier.
02:39:08 <Itkovian> OT: http://www.xroadsfilms.com/batescomedycentral/
02:40:10 <Itkovian> lol
02:40:26 <Enveigler> Trevian: Ignore me; I'm just jaundiced with IO in Haskell
02:40:53 <Trevion> Enveigler: I can understand the problem; it took me a while to get used to IO (and almost anything else monadic).
02:40:59 <Itkovian> Trevion: I think that for such things you can find better tools than haskell ... sorry to say so, but it's true
02:42:46 <Trevion> Itkovian: I'm sure you're right - but it felt stupid to be stopped by a simple read/write issue like that.
02:43:03 <Itkovian> ah well ...
02:43:15 <swiert> what about closing the handle after reading the file?
02:44:05 <Trevion> hmm.. I'd hoped there would be an easier way than using the handle-based functions.
02:44:25 <Itkovian> "I knwo that human being(s) and fish can co-exists peacefully"
02:44:27 <Itkovian> ahem
02:45:53 <dons> Trevion, http://www.cse.unsw.edu.au/~dons/Copy.hs
02:46:29 <boegel> @y0w
02:46:31 <lambdabot> I have many CHARTS and DIAGRAMS..
02:46:36 * Itkovian waves at boegel
02:46:48 * boegel waves back
02:47:20 <Trevion> Oh.. thanks dons
02:47:45 <dons> if you're writing some real-world app though, close handles and be generally good. if you're just writing a quick script, then that's probably ok
02:48:18 <dons> btw, you need to replace 'id' with your function for coverting line endings ;)
02:49:03 <Trevion> heh, I'd assumed.
02:49:19 <Trevion> (Either that, or Haskell's much better at Guess What I Mean syntax than I'd realized...)
02:49:29 <dons> also, 3 cheers for runhaskell, while we're here!
02:51:52 <poetix> @karma+ runhaskell
02:51:53 <lambdabot> runhaskell's karma raised to 0.
02:51:55 <poetix> @karma+ runhaskell
02:51:56 <lambdabot> runhaskell's karma raised to 1.
02:51:57 <poetix> @karma+ runhaskell
02:51:58 <lambdabot> runhaskell's karma raised to 2.
02:52:11 <dons>  hehehe
02:52:12 <boegel> @karma+ poetix
02:52:12 <lambdabot> poetix's karma raised to 0.
02:52:23 <dons> @karma- lambdabot
02:52:24 <lambdabot> lambdabot's karma lowered to 3.
02:52:26 <boegel> :o
02:52:30 <dons> that's a bug
02:52:31 <Enveigler> @google runhaskell
02:52:33 <lambdabot> http://www.mail-archive.com/glasgow-haskell-bugs@haskell.org/msg07222.html
02:52:39 <dons> @karma+ poetix
02:52:39 <lambdabot> poetix's karma raised to 1.
02:52:45 <poetix> It's a regular mutual appreciation society around here...
02:53:38 <poetix> Karma's all very well, but when do I get mod points?
03:04:00 <musasabi> What solutions are there for i18n in Haskell?
03:10:01 <shapr> musasabi: There's an i18n project on sf.net, not sure what else.
03:11:18 <musasabi> What is it named?
03:12:05 <shapr> http://sourceforge.net/projects/haskell-i18n/
03:12:13 <Itkovian> lunch
03:12:17 <Itkovian> ttyl
03:12:30 <shapr> Seems to be ashley yakeley, pesco, and norpan
03:13:08 <wilx> Heh, no files and no links to other pages?
03:13:15 <wilx> Looks quite dead to me.
03:13:35 * musasabi looks at the CVS
03:14:27 <wilx> Oh...
03:33:12 <poetix> When writing Haskell bindings to C libraries, is all the code typically Haskell FFI code or do you need to write C code on the other side of the interface as well?
03:44:06 <shapr> poetix: Just FFI, check out Oejet's bzlib2 binding in TMR
03:44:16 <shapr> Maybe I should make a TMR index page.
03:44:28 <poetix> And lambdabot plugin
03:44:41 <shapr> To search the wikis by subject?
03:44:45 <poetix> Yep
03:44:50 <shapr> Neat idea.
03:45:02 <shapr> quick, write one! ;)
03:45:09 <boegel> shapr: is the deadline for TMR4 today ?
03:45:17 <shapr> boegel: nah, 1st or 2nd
03:45:21 <poetix> Where lambdabot source?
03:45:26 <shapr> @version
03:45:27 <lambdabot> lambdabot 3p36, GHC 6.4 (OpenBSD i386)
03:45:27 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:45:34 <boegel> shapr: mmkay then, I'll see what I can do :)
03:47:11 <poetix> Where pastebin?
03:47:31 <shapr> @paste
03:47:32 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:47:37 * poetix must stop talking like a Teletubby
03:47:46 <shapr> again! again!
03:50:09 <bourbaki> sabah al-chair
03:50:47 <boegel> yo bourbaki Itkovian
03:51:10 <Wed14616> anyone with dependence analysis experience?
03:51:24 * boegel points at Itkovian
03:51:35 <Itkovian> eh?
03:51:47 <Itkovian> Wed14616: what exactly do you mean by dependence?
03:51:51 <boegel> I thought that might be part of your work ? :)
03:52:20 <Wed14616> data dependence
03:52:40 <Wed14616> well i need to determine which iteration depends on what iteration
03:52:56 <Wed14616> and im having difficulty finding nice literature
03:56:58 <Itkovian> Wed14616: ah, ic. twas a long time ago.
03:57:30 <Itkovian> http://www.elis.ugent.be/~kbeyls/#publications
03:58:51 <Itkovian> there exist tons of stuff on the matter afaik
03:58:59 <Wed14616> yeah too much
03:58:59 <Itkovian> I am not very familiar with most of it though.
03:59:25 <Itkovian> in the publication list of Kristof Beyls you might find some denet references though
04:00:13 <Enveigler1> :(
04:00:19 <Itkovian> http://www.elis.ugent.be/~kbeyls/rdvis/
04:00:47 <shapr> hoi goron
04:04:48 * boegel leaves to catch his train
04:05:08 * Lemmih doesn't get the "GHC error messages are bad"-people.
04:05:36 <poetix> Drat, tmrwiki search doesn't work the same way as google & wikipedia
04:05:51 * shapr reads up on electrostatic transducers
04:05:57 <shapr> poetix: What are you looking for?
04:06:07 <poetix> Trying to plug tmr into the search module in lambdabot
04:06:27 <poetix> Which would be v. easy if the wiki returned a 302 Found header and a location
04:06:35 <shapr> Ah, I see.
04:06:45 <poetix> But instead you'd have to scrape the page for links
04:06:56 <poetix> So not a 5-minute hack (for me anyway)
04:07:07 <shapr> I know MoinMoin has xmlrpc support, maybe it can return search results that way?
04:07:14 <TFK> Morning, Haskelleers.
04:07:19 <xerox> poetix, I had the same problem with some other searches I wanted to add.  I think we need to refactor the module: some searches should result in some content of the page, some other in an url in the headers.
04:08:42 <poetix> In some cases we might want to return several results as well
04:08:49 * poetix doesn't always feel lucky
04:09:19 <poetix> TFK: salut
04:09:32 <Itkovian> TFK: aft'noon
04:09:50 <TFK> Right, right, it's 14:15 here already >_<
04:10:34 <musasabi> GHC error messages are nice as long as they are not panic messages.
04:10:54 * shapr grins
04:12:00 <musasabi> comp died due to heat had to escape to bedroom for irc.
04:12:33 <musasabi> if it didn't rain at nights I could get hacking on the balcony.
04:12:44 <musasabi> s/get/go
04:13:09 <shapr> waterproof laptop?
04:13:11 <basti_> hi all
04:13:26 <basti_> how does one go about to store type information effecitvely
04:13:45 <musasabi> basti_: inside a running program or on disk?
04:13:57 <basti_> in a runtime thingie
04:14:03 <basti_> virtual machine hastenichtgesehen
04:14:03 <musasabi> Typeable.
04:14:24 <basti_> i mean, how does this work at the machine level?
04:14:27 <basti_> im just curious
04:14:31 <mflux_> (somewhat relevant) me, surfing on the lake: http://jolt.modeemi.fi/m-arkisto/data/705/type=viewsize,mime=image+jpeg
04:15:03 <mflux_> I'm not sure how many laptops there are around that can actually be immersed into the water though :/
04:15:08 <musasabi> basti_: it keeps a unique identifier per type and uses comparison of those for casts.
04:15:20 <basti_> how does it handle classes?
04:15:38 <musasabi> A class is not a type.
04:16:07 <basti_> hmm but suppose i would want to write a runtime that uses types
04:16:13 <basti_> somewhat interactively
04:16:21 <basti_> as in, type system might be extended
04:16:56 <basti_> we could grow types. or classes.
04:18:24 <basti_> i thought about putting it in an sql database but that might suck
04:18:37 <shapr> mflux_: Does your laptop still work after being immersed in water?
04:18:53 <mflux_> shapr, infact we didn't try..
04:19:05 <shapr> Aw, too bad.
04:19:11 <mflux_> it did work before though.
04:19:30 <mflux_> but it was some 486 and had a chinese keyboard
04:19:35 <shapr> Wow
04:21:15 <mflux_> (afterwards: http://jolt.modeemi.fi/m-arkisto/data/708/type=viewsize)
04:30:39 <Itkovian> any other numerical stuff in Haskell that isn't mentioned in the libraries page?
04:30:47 <Itkovian> hi Philippa_
04:44:57 <timbod> I'm just reading "Haskell's Overlooked Object system" - what's the difference between return and returnIO?
04:49:11 <poetix> @google Haskell's Overlooked Object System
04:49:14 <lambdabot> http://www.cwi.nl/~ralf/OOHaskell/
04:51:13 <timbod> The paper is interesting - it feels a little like "type system abuse" in the same way of much of the funky stuff done in C++ these days.
04:52:25 <poetix> The HList stuff is quite similar
04:52:47 <shapr> If an Oleg is one of the authors...
04:52:52 <poetix> Using nesting to produce lispy lists of types
04:54:02 <poetix> The difference I think is that type-hackery of this kind in Haskell is not so "abusive"
04:54:19 <poetix> In C++ it's basically metaprogramming
04:57:11 <poetix> Whereas in Haskell it feels more continuous with the expressivity of the core language
04:58:22 <poetix> Doesn't returnIO lift a return value into the IO monad?
05:01:32 <basti_> http://haskell.org/hawiki/TypesOnShellLevel?action=show
05:01:53 <shapr> heh, 'pipe dream' is cute
05:02:11 <basti_> O :-)
05:02:54 <timbod> I'm not sure: return :: forall m a. (Monad m) => a -> m a, returnIO : a -> IO a
05:03:11 <basti_> poetix: yes it does why?
05:03:45 <poetix> Answering an earlier question from timbod
05:04:07 <basti_> timbod: me deems thats actually two commands.
05:04:15 <basti_> the important bit is a -> m a
05:04:37 <basti_> "makes a thing a to the same thing a in a box m"
05:05:11 <basti_> Philippa? http://haskell.org/hawiki/TypesOnShellLevel?action=show
05:05:28 <timbod> I'm confused: but is returnIO just a special case of return
05:05:46 <basti_> returnIO is a different command that fell out of some file :P
05:05:58 <basti_> @type return
05:06:03 <lambdabot> return :: forall (m :: * -> *) a. (Monad m) => a -> m a
05:06:11 <basti_> there you go
05:06:25 <timbod> @type returnIO
05:06:26 <lambdabot> bzzt
05:06:43 <timbod> @type GHC.IOBase.returnIO
05:06:44 <lambdabot> GHC.IOBase.returnIO :: forall a. a -> IO a
05:06:45 <basti_> it might be qualified
05:07:01 <basti_> that looks a lot like an implementation
05:08:05 <basti_> i heard something about that the IO monad is a little hacky
05:08:36 * poetix suspects this has something to do with monad transformers
05:08:47 <timbod> I wonder why returnIO gets  used explicitly in http://homepages.cwi.nl/~ralf/OOHaskell/paper.pdf, if return would do the job.
05:08:52 * shapr wants a 240v to 110v monad transformer
05:09:08 <basti_> hmmm
05:10:36 <TheHunter> timbod, quite possibly, using return would make the compiler infer really huge types.
05:11:25 <TheHunter> Another possibility is that they don't want to require their target audience to know how Haskell's type classes work.
05:11:44 <TheHunter> But I didn't read the paper, so I can't say for sure.
05:12:34 <timbod> Thanks, the former sounds appropriate - the types inferred are complex enough as it is, without parameterising over the monad.
05:50:45 * poetix is lifted into the RealWorld monad
05:51:24 <Itkovian> scary
05:51:44 <Itkovian> I wish something would lift me into the Winter monad
05:52:04 <Philippa_> 'stoo damn hot here even after all the thunder and rain last night
05:52:24 <basti_> Philippa_: http://haskell.org/hawiki/TypesOnShellLevel?action=show
05:53:59 <Wed6894> i want to be lifted into the graduated monad
05:54:35 <rtega> why Wed6894?
05:54:39 <rtega> you'll get to work and stuff
05:54:55 <Philippa_> basti_: how do you prove something's a File? That's more than a shell rewrite
05:55:28 <Philippa_> I'd like to've graduated so I could be looking at a p/t PhD instead
05:55:32 <basti_> Philippa_: hmm.
05:55:33 <Wed6894> rtega, because then i would be finished and can finally work
05:55:45 <xerox> In UNIX, everything is a file! (/me grins evilly)
05:55:55 <Philippa_> basti_: I'm thinking about network connections as an example of a file that's not a File
05:56:01 <genneth> @seen boegel
05:56:03 <lambdabot> I saw boegel leaving #haskell 1 hour, 49 minutes and 40 seconds ago.
05:57:19 <basti_> Philippa_: well of course network connections are streams
05:57:50 <genneth> what's a good name for: nf f (x:xs) = foldr f x xs ?
05:58:02 <genneth> i'm wondering if there is a well known name already
05:58:07 <basti_> genneth: the function that's missing.
05:58:10 <xerox> foldr1
05:58:18 <xerox> @type foldr1
05:58:21 <genneth> aha
05:58:23 <genneth> cunning
05:58:24 <basti_> ah.
05:58:25 <genneth> like a fox
05:58:28 <lambdabot> foldr1 :: forall a. (a -> a -> a) -> [a] -> a
05:58:31 <xerox> :-)
05:58:31 <Philippa_> basti_: the hard part's working out whether a file you're handed is a File or a Stream (unless you assume Stream by default, I guess)
05:59:02 <genneth> xerox: cheers! i'm actually needing it for a C++ version -- damned mpl only has fold and a weird iter_fold of some kind....
05:59:48 <basti_> Philippa_: it's trivial in the case of existing files (some database should store that information) this only would have to be precomputed for every script.
06:00:02 <xerox> genneth, C++ foldr1?  That's a strange request, heh.
06:01:15 <genneth> xerox: actually foldl1, now thinking about it *evil grin*
06:01:32 <genneth> xerox: and it's with templates instead of real code
06:02:36 <xerox> @index foldl1
06:02:37 <lambdabot> Data.List, Prelude
06:02:42 <xerox> @libsrc Data.List
06:02:43 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
06:06:24 <Wed6894> @pl \y b -> (y:x):b
06:06:25 <lambdabot> (:) . (: x)
06:06:53 <shapr> pointless is such a cool plugin.
06:06:55 <xerox> What do you think about a @pl-contest?
06:07:11 <shapr> What rules?
06:07:19 <shapr> What goal?
06:07:27 <Wed6894> What the fuck?
06:07:38 <xerox> One provides the pointy function, 20 seconds, you should tell your points-free version as privmsg to lambdabot.
06:08:10 <Wed6894> with another private screen where you simply @pl lambdabot?
06:08:11 <Wed6894> :D
06:08:58 <xerox> It's pointless, anyway.
06:09:18 * genneth groans
06:10:35 <genneth> <rant>boost::mpl has the most stupid names ever: map is called transform, and zipWith is called transform, but overloaded to take two lists</rant>
06:10:46 <shapr> yeesh
06:10:55 <genneth> oh heh shapr
06:11:01 <shapr> hiya genneth
06:11:14 <tomdavie> anyone know why nhc has been hard-masked on gentoo?
06:11:43 <genneth> tomdavie: nope; but hugs98 and ghc both work perfectly, even on amd64 here
06:12:04 <genneth> actually, that's a lie; STM crashes on amd64
06:12:23 <tomdavie> genneth: yeh, nhc produces some nicer error messages... sometimes
06:12:43 <tomdavie> I like to keep all 3 - then I get all 3 opinions on what the error is
06:12:52 <genneth> fair enough; i haven't occasioned to try it; probably cos it's hardmarked
06:13:27 <tomdavie> it works fine if you d/l the source and build it, so the hard mask seems very odd
06:14:06 <Wed6894> what's a hard mask as opposed to a soft mask?
06:15:27 <tomdavie> it's *meant* to mean that there's something seriously up with the package
06:15:36 <tomdavie> i.e. install this and things go badly wrong
06:15:41 <genneth> on x86 it's usually right
06:15:53 <genneth> the more exotic archs tend to be more conservative
06:16:22 <tomdavie> I know it compiles and works fine on x86, ppc and sparc... but it's masked on all platforms
06:16:44 <genneth> when you emerge -vp nhc
06:17:03 <genneth> does it not give a little exerpt from packages.mask? the exerpt should say why it was maksed
06:17:26 <ndm> nhc crashes if you allocate from the top 2Gb of memory
06:17:33 <Wed6894> ow ok, so a package that is hard masked...is uninstallable (conservatively seen)
06:17:34 <ndm> i.e. if your malloc returns the high bit set
06:17:39 <genneth> tomdavie: http://bugs.gentoo.org/show_bug.cgi?id=73367
06:18:38 <tomdavie> why would that hard mask it though?
06:19:09 <tomdavie> and if that's the case... why isn't hmake masked
06:19:48 <genneth> Wed6894: yep; hardmasks == this *WILL* break
06:19:48 * Wed6894 buzzes earthy for a question
06:19:50 <tomdavie> anyway... the patch is simple... you delete about 5 new lines from the source
06:20:09 <genneth> tomdavie: the build still segfaults later though
06:20:29 <genneth> (at least that's what i think the bug report says)
06:20:33 <tomdavie> gen: how come I can run nhc on my gentoo box then?
06:20:36 <genneth> you can try unmasking it and testing?
06:20:41 <tomdavie> true
06:21:09 <tomdavie> at the moment... I'm wondering how to fiddle the patch, because I know how to get it to build
06:21:24 <genneth> if you have a patch that would make it build
06:21:41 <genneth> submit it to that bug report and maybe the ebuild maintainer will pick it up and incorporate it into the build
06:21:55 <tomdavie> cool
06:30:08 <basti_> http://funnypictures.punt.nl/index.php?id=252936&r=1&tbl_archief=& < thats why camping sucks
06:33:39 * Wed6894 buzzes earthy again
06:35:24 <Wed6894> nice festival lol
06:35:43 <basti_> :)
06:40:16 <tomdavie> that's what makes glastonbury great isn't it?
06:40:57 <Itkovian> haha
06:40:59 <Itkovian> suckers
06:41:26 * Itkovian swore never to camp again on a festival
06:41:47 * tomdavie would... I would just have picked my pitch a bit better
06:42:26 <Itkovian> well, usually you have to camp in designated areas
06:42:44 <Itkovian> and if the sewers are not laid out well ...
06:42:44 <tomdavie> yeh... but then you pick the high ground
06:42:56 <Itkovian> seems like it didn't matter with 1.5 metres of water
06:42:57 <tomdavie> it was about 1 100th of the festival that was flooded
06:43:08 <Itkovian> that also assumes you arrive on time
06:43:21 <tomdavie> yeh... which assumes intelligence ;)
06:43:42 <Itkovian> heh
06:43:46 <shapr> I want to do "for x in `locate Data.fs`; do dirname $x; done; | sort | uniq" What's the right way to pass stuff from a for loop into a pipe?
06:43:51 <shapr> (I'm using zsh, btw)
06:43:54 <tomdavie> note... this is glastonbury... IIRC, there's camping for 125,000 people there... that's a tiny proportion of it
06:43:55 <Itkovian> which contradicts about 80% of festival visitors
06:44:01 <tomdavie> lol
06:44:19 <shapr> Quick! Someone write a real Haskell shell!
06:44:26 <tomdavie> hehe
06:44:28 <shapr> I want to use map and friends in my shell scripts.
06:44:42 <tomdavie> #!/bin/sh
06:44:42 <tomdavie> hugs
06:44:45 <Itkovian> shapr: seems like that's ok to me, no?
06:44:46 <tomdavie> there you go :)
06:46:07 <shapr> tomdavie: ok, how can I write that same cmdline above in hugs? :-)
06:46:14 <aheller> shapr: the semicolon after done
06:46:15 <tomdavie> hehe
06:46:23 <Itkovian> heh
06:46:24 <Itkovian> true
06:46:39 <shapr> aheller: aha! thanks!
06:46:40 <aheller> for i in *; do dirname $i; done | sort -u
06:47:02 <aheller> no problem. finally had the answer to something :)
06:47:21 <shapr> Does sort -u work only in FSF sort?
06:47:40 * shapr learned shell scripting on irix/aix/sunos/solaris/etc
06:47:44 <aheller> probably.  I used to get yelled at by my old boss for using the | uniq because it was an extra fork.
06:48:01 <shapr> I got yelled at when my scripts didn't work on all our unices.
06:48:04 <tomdavie> so what you want to be able to do is something like:
06:48:04 <tomdavie> someShellScript arg1 = (wc . detex arg1) ++ (pdflatex arg1)
06:48:04 <tomdavie> ?
06:48:26 <tomdavie> problem is of course that unix commands are unsafe
06:48:48 <tuomov> locate ... | hack_to_zero-end_stuff | xargs -0 -n 1 dirname | sort | uniq
06:49:03 <tuomov> no loop!
06:49:23 * Wed6894 slaps earthy 
06:49:35 <tomdavie> will the loop not appear in hack_to_zero-end_stuff?
06:49:59 <shapr> Where's the HsShellScript lib again?
06:50:03 <shapr> @google hsshellscript
06:50:04 <lambdabot> http://www.volker-wysk.de/hsshellscript/
06:51:17 <tuomov> tr '\n' '\0' should work
06:52:51 <earthy> hm?!
06:53:04 <earthy> What happen?
06:53:24 <shapr> Take off every Zug!
06:53:48 <earthy> Zero Wing Rhapsody! Wheee!
06:53:56 <xerox> tr -d '\n' ?
06:54:27 <genneth> shapr: look into xargs; using the -n 1 switch you've effectively got a map
06:54:47 * earthy provides Wed6894 with /msg earthy <the question>
06:54:53 <genneth> oh wait, toumov already said
06:55:07 <shapr> I'm trying HsShellScript at the moment, that would be more fun.
06:57:00 <genneth> i did briefly toy with the idea of making a shell that's strongly typed
06:57:32 <aheller> tuomov: why the hack_to_zero | xargs -0; why not just locate ... | xargs -n 1 dirname ?
06:57:47 <genneth> the problem was that there is no feasible way to infer things; you'd have to supply the signature to just about everything
06:57:58 <genneth> aheller: i'd guess it's because most things choke on spaces in the middle
06:58:09 <aheller> ah, ingenious!
06:58:55 <Wed6894> ah earthy is awake
06:58:59 <vegai> hmm, how can I get a revision number with Darcs?
06:59:06 <earthy> fsvo awake
06:59:07 <Wed6894> ow right, private msgs exist
06:59:35 <vegai> does darcs have such things?
07:00:58 <shapr> vegai: You can do tag plus number of patches.
07:02:05 <vegai> number of patches, how? get -h doesn't reveal anything to me
07:02:25 <shapr> @version look at lambdabot
07:02:26 <lambdabot> lambdabot 3p36, GHC 6.4 (OpenBSD i386)
07:02:26 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
07:06:01 <shapr> This is probably a stupid question, but is there some simple way to get the lines output of a shell command as [String] ?
07:06:13 <aheller> lines?
07:06:57 <shapr> Basically I want do `locate foo` in Haskell.
07:07:18 <shapr> And get ["/home/shae/foo","/home/joe/foo"]
07:07:27 <xerox> shapr, popen!
07:07:37 <shapr> Yeah, I guess so.
07:07:40 <aheller> What are you using to run the locate?
07:07:47 <xerox> shapr, dons' implementation is lambdabot sources :)
07:08:40 <shapr> Nothing yet, I'm trying to figure out how to part that tiny shell script above into pure Haskell.
07:08:42 <shapr> hiya lstna
07:09:32 <tomdavie> but surely you can't... because the shell commands have side effects, and thus the can't be included in a pure program
07:10:13 <basti_> genneth: you were talking about a strongly typed shell being infeasible?
07:10:49 <basti_> http://haskell.org/hawiki/TypesOnShellLevel?action=show < look at that idea that i had yesterday
07:11:35 <genneth> i was just worried that it would take too much support from the OS to do feasibly
07:11:39 <tomdavie> I think msh is supposed to be typed, but then the tools play nice and tell you what types they qive/take
07:11:42 <genneth> the biggest barrier is the inference
07:11:47 <shapr> tomdavie: sorry, I meant not pure, but as few external commands as possible.
07:12:09 <basti_> genneth: i was thinking about a shell first, that you can enter type information to...
07:12:20 <tomdavie> ah, k... so, you run locate and put it through lines then?
07:12:26 <shapr> Right
07:12:37 <basti_> genneth: and whats the problem about inference?
07:12:42 <genneth> basti_: but then you'd have to provide the signature of just about everything
07:13:00 <vegai> shapr: hmm, that didn't help
07:13:08 <genneth> basti_: it would just put people off
07:13:26 <basti_> genneth: hmm. well a set of reasonable defaults could be provided
07:13:27 <xs> basti_: smells like microsoft monad?
07:13:27 <vegai> but I guess I could match against the patch short description
07:13:32 <shapr> vegai: I thought lambdabot had some sort of automatic way to calculate version number of tag plus number of patches.
07:13:40 <basti_> then, connections to databases could be autotyped
07:13:44 <genneth> xs: incredibly; except not using .net
07:14:00 <tomdavie> basti: but what type is /Users/jam/ham.hs ?
07:14:05 <vegai> ohh, let's see
07:14:07 <tomdavie> is it type String
07:14:11 <shapr> FilePath
07:14:13 <basti_> tomdavie: well usually File [Char]
07:14:16 <tomdavie> or is it type FilePath
07:14:39 <basti_> hmm no why?
07:14:46 <tomdavie> basti: so what if it isn't actually a file path?
07:14:50 <vegai> shapr: it uses configure and config.h to do that, it seems
07:14:55 <shapr> vegai: oh, too bad.
07:15:00 <basti_> well there would be a type FilePath of course.
07:15:06 <tomdavie> what if it's just a string I want to append to another
07:15:12 <basti_> and you could try to open it
07:15:17 <shapr> Would be nice to have a simple shell script or Haskell chunk that calculated that sort of version number from darcs.
07:15:25 <vegai> dons: could you tag hs-plugins?
07:15:35 <basti_> as long as you dont open it, a FilePath could be similar to a String
07:15:42 <shapr> You can turn Integer and Int into PortNumber, I'm sure you could turn a String into a FilePath.
07:15:47 <genneth> xs: as far as i know, the MS monad shell has the same issues with type inference, in that it's only possible for components written for it
07:16:06 <tomdavie> okay... so I write a shell script then find :: String -> [FilePath]
07:16:17 <shapr> What about Inferno or Jini? Don't those have reflective ways to share types?
07:16:21 <basti_> well one could make that comfortable i think.
07:16:23 <tomdavie> and then want to just print out those paths in a pretty way
07:16:31 <tomdavie> I want [String] in
07:16:46 <basti_> yes you could.
07:16:55 <Wed6894> huh
07:16:59 <tomdavie> but that breaks the type inference system
07:17:03 <Wed6894> there's is no map function for Data.Tree
07:17:04 <basti_> why?
07:17:04 <Wed6894> ?
07:17:14 <tomdavie> [String] is not [FilePath]
07:17:23 <tomdavie> so the types don't match
07:17:45 <basti_> I'm sorry i dont get your point... why is it forbidden to write a function that converts Strings to FilePaths?
07:17:52 * shapr is wondering that too
07:18:04 <tomdavie> it's not... I'm saying that you're gonna have to use a world of them
07:18:11 <shapr> I think FilePath is just an alias for String anyway.
07:18:40 * basti_ is wondering what the problem would be
07:18:47 * basti_ is blank
07:18:56 <tomdavie> and how do you tell that find outputs a list of filePaths anyway? If it produces lots of filePaths one time, it doesn't mean that it will always
07:19:02 <Cale> type  FilePath = String
07:19:05 <Cale> from the Prelude
07:19:12 <basti_> it could produce no FilePath
07:19:13 <basti_> []
07:19:27 <tomdavie> okay yes... but my point is that *everything* on the shell is a String
07:19:33 <tomdavie> (at one level or another)
07:19:34 <basti_> no why.
07:19:36 <basti_> in your shell maybe.
07:19:42 <shapr> Sure, but a smart Haskell shell wouldn't do that.
07:20:07 <tomdavie> but... this is the way unix does things... the find utility takes a string and produces a string
07:20:22 <shapr> Now you just want to add sensible types, right?
07:20:31 <basti_> i want to do: "cat logEvents > mysql_table_x_feed"
07:20:35 <genneth> but if you were to override that with a signature like String -> [FilePath]
07:20:40 <tomdavie> sure... we can interpret that as a list of file paths, but that doesn't mean that find will *always* produce them
07:20:54 * genneth ponders
07:20:55 <basti_> tomdavie: then the list is empty.
07:20:59 <genneth> actually he has a point
07:21:00 <basti_> ...???
07:21:12 <genneth> find, especially the gnu one
07:21:14 <tomdavie> basti: no... it *could* produe "jam" "ham"
07:21:16 <genneth> is a very complex function
07:21:37 <basti_> ah
07:21:39 <genneth> the signature changes according to the command line switches
07:21:39 <tomdavie> or... "error: something get covered in Jam"
07:21:42 <basti_> i think i see what you mean
07:21:47 <aheller> wouldn't the place to put the typing be in the pipes?
07:21:47 * basti_ nods
07:22:01 <Wed6894> fmap duh
07:22:12 <tomdavie> it could produce "version: 1.0b6)
07:22:14 <basti_> yes there would be many scripts like that.
07:22:21 <shapr> Maybe you could use the polyvariadic trick to type find correctly?
07:22:24 * genneth has a strange compulsion to stroke his long imaginary white beard
07:22:33 <tomdavie> haha
07:22:39 <shapr> genneth: How'd you get a long white beard at the age of nineteen?
07:22:55 <genneth> this was actually the problem that i think i ran into trying to design a typesafe shell
07:22:57 <basti_> we should deliver an orthogonal set of primitives for filesystems etc.
07:23:36 <genneth> shapr: accident with bleach and hair regrowth bottle; home-made chemistry sets are dangerous things
07:23:36 <shapr> genneth: Oh, I can dig that.
07:23:40 <shapr> tromp: Hey, what do you think of MR Recumbent Trikes?
07:23:49 <basti_> traversal...
07:23:56 <basti_> wenn schon denn schon...
07:24:08 <genneth> basti_: i think the only way around is to rebuild the unix tools to be statically typed, and have the types well know
07:24:24 <tomdavie> but that would be horrible
07:24:25 <genneth> but then you'd be recreating posix, but a little stricter, which is no simple undertaking
07:24:33 <basti_> hmm.
07:24:39 <basti_> i do not respect holy cows.
07:24:40 <basti_> =)
07:24:57 <genneth> exactly; and i guess that's why only MS has the balls to even think it
07:25:07 <shapr> Why not come up with a sensible shell program for House then?
07:25:09 <tomdavie> because most of them would come out as Either SomethingGood (Either Error String)
07:25:10 <basti_> hmmk
07:25:13 <tomdavie> or some variant of
07:25:24 <shapr> Then you don't need to recreate POSIX, and you have a nice Haskell underpinning to build on.
07:25:40 <basti_> quick House brief?
07:25:53 <shapr> Would the IETF approach be to come up with simple types for the basic gnu utilities?
07:26:07 <shapr> basti_: House is the GHC RTS running on the bare metal, no OS required.
07:26:17 <basti_> ah.
07:26:18 <basti_> :)
07:26:21 <genneth> shapr: i think the file utility and mimetypes are alreayd there
07:26:27 * basti_ needs to dig that
07:26:30 <shapr> basti_: http://www.cse.ogi.edu/~hallgren/House/
07:26:33 <xs> shapr: but the ghc rts is like 40k lines of c..
07:26:46 <genneth> well, it's no microkernel... :-p
07:26:59 <shapr> Speck: Hey, I saw your name in the latest PArrows changelog :-)
07:27:11 <Speck> It was a simple patch :-)
07:27:32 <shapr> I'm sure the author was happy to see that people are using and extending PArrows.
07:27:50 <Speck> yeah I've been so busy at work lately, but I want to start using it
07:27:57 <basti_> shapr: =)
07:28:10 <Speck> libraries are so much better when they're extended via use cases
07:28:18 <shapr> Yeah, I agree.
07:28:28 <shapr> xs: Still works, seen the screenshots?
07:28:38 <shapr> xs: I want to see House with SMP support, that'll be cool.
07:28:46 <basti_> yes.
07:28:49 <xs> shapr: yeah! but it bugs me that so much is in c still :/
07:28:56 <shapr> Fix it!
07:29:11 * basti_ is pragmatic on that.
07:29:12 <xs> i'm hoping to. but first i have to learn haskell :)
07:29:23 <shapr> C'mon, nothing can stop you now!
07:29:26 <basti_> have a seat xs, cookies are over there.
07:29:46 <shapr> The weekly lambda boomerang practice session is every Saturday afternoon.
07:30:06 <Speck> is hIDE 2 a pipe dream? I'm quite interested in the project.
07:30:30 <xs> hehe
07:31:04 <shapr> Duncan was talking about combining gtk2hs, Yi, and Haste to get hIDE 2 moving. That was two days ago, so I guess it'll really happen if you jump in and start helping.
07:32:03 <xerox> dcoutts_, you were talking? ;-)
07:32:05 <Speck> well we'd need hs-plugins too
07:32:21 <shapr> Yi is built on top of hs-plugins, and is by the same author.
07:32:46 <Speck> I need to look more into yi
07:32:54 <shapr> It's quite spiffy.
07:33:09 <Speck> it's like an abstract meta-editor yea?
07:33:14 <basti_> yes i was thinking into the direction of hs-plugins too
07:33:33 <Wed6894> divine moments of truth
07:33:37 <shapr> Yah, the original idea is that Yi is an editor, and can have vi/emacs/etc front-ends
07:33:40 <Speck> basti_, kind of like eclipses very modular setup? that's what I was thinking
07:33:56 <basti_> i wasnt thinking about a programming ide.
07:33:57 <basti_> =)
07:34:16 <basti_> except for wide perception of the word "ide"
07:34:16 <Speck> then what were you thinking?
07:34:18 <shapr> I don't know the details of modularity in eclispe, but Yi has lots of modularity.
07:34:28 <basti_> more like a crude shell with fun toys.
07:34:42 <ndm> I just assumed Yi was like Vi in Haskell - will it be capable of becoming a proper visual editor?
07:34:54 <Speck> eclipse is just a plug-in manager, really. everything else is a module that's loaded in
07:34:55 <ndm> say like www.textpad.com ?
07:35:12 <xerox> ndm, indeed.
07:35:35 <xerox> With gtk and cairo graphics (/me grins evilly)
07:35:39 <Speck> does yi manage the document structure?
07:35:47 <xs> you know vi stands for visual.
07:35:49 <basti_> lol i had this bizarre conversation with lispy about why, if, or why not to build an elisp interpreter into Yi.
07:36:47 <xerox> Embedding GHCi is part dons' PhD research :-)
07:36:57 <basti_> i was thinking, i'm not the pope, so if it makes him happy... -shrug- :)
07:37:24 <aheller> you're not the pope?
07:37:50 <Speck> is there a white paper like thing for yi?
07:37:54 <basti_> i wont go and say something like "elisp support = instant mammoth"... ;)
07:37:55 <shapr> Speck: Not yet, but that's the plan.
07:38:14 <Speck> I guess until then I can try to grok the source
07:38:33 <xerox> Speck, there is a good paper describing the architecture and the workings.
07:38:39 <xerox> @google dons Yi
07:38:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
07:38:54 <Speck> "a paper" I guess
07:38:54 <xs> there's http://www.cse.unsw.edu.au/~dons/papers/SC05.html
07:39:03 <xerox> @google Dynamic applications from the grounds up
07:39:05 <lambdabot> http://slashdot.org/article.pl?sid=00/07/20/1440204&mode=thread
07:39:06 <basti_> i hacked myself into some of the aspects
07:39:15 <basti_> keymaps, fast lazy lexers
07:39:22 <basti_> wasnt all that hard. micro larval stage.
07:39:33 <Speck> weird google result
07:40:10 <xerox> @google "Dynamic Applications From the Ground Up"
07:40:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/SC05.html
07:40:18 <xerox> @botsnack
07:40:20 <lambdabot> :)
07:44:04 <shapr> basti_: oh, is the latest emacs front-end in there?
07:44:17 <basti_> :-o
07:44:24 <basti_> where?
07:44:48 <shapr> In Yi
07:44:57 <basti_> i checked in a version recently
07:45:02 <basti_> i'd hope dons put it on
07:45:03 <shapr> cool
07:45:06 <basti_> it had a weird name
07:45:10 <basti_> =)
07:45:27 <shapr> Hm, does the hs-plugins darcs repo build for anyone else?
07:45:29 <Speck> boo the haste web site is one of those dyndns and it's down
07:45:48 <xerox> shapr, it does for me
07:46:21 <shapr> Strange, I get System/Plugins/Parser.hs:41:9: Not in scope: `parseFileContentsWithMode'
07:49:27 <xerox> shapr, it appears to be in haskell-src-exts.
07:49:41 <shapr> tromp: Is there a relationship between the Busy Beaver complexity and Kolmogorov complexity?
07:49:44 <shapr> ah, ok
07:50:24 <basti_> i think i should run House in an emulator
07:55:22 <Speck> it looks like yi is very much the foundation of some dynamically abstract nonsense (which is good for an ide)
07:55:48 <basti_> lol
07:56:06 * xerox laughs
07:58:40 <Speck> they weren't so off course with calling emacs an operating system. this kind of dynamic linking/loading is very much parallel to forking off a process
07:59:06 <genneth> @type foldl
07:59:07 <Speck> (speaking of house)
07:59:12 <lambdabot> foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
08:00:07 <shapr> Hm, I get "Could not find module `System.Plugins'" when I try to make Yi.
08:00:21 <Speck> is that exported by hs-plugins?
08:00:39 <shapr> yup
08:01:18 <genneth> @type foldl (\x y: x:f(y)) (f a)
08:01:21 <lambdabot> bzzt
08:01:26 <genneth> bzzt indeed
08:02:30 <xerox> @type \f -> foldl (\x y -> x : f y) (f a)
08:02:32 <lambdabot> bzzt
08:02:42 <xerox> uhm.
08:02:47 <xerox> @type \f a -> foldl (\x y -> x : f y) (f a)
08:02:49 <lambdabot> bzzt
08:03:13 <genneth> @pl foldl (\x y -> x : f y) (f a)
08:03:15 <lambdabot> foldl ((. f) . (:)) (f a)
08:03:31 <xerox> aaah.
08:03:36 <genneth> oh dear god
08:03:46 <genneth> there's more dots than real identifiers
08:04:29 <xerox> genneth, foldl first argument is (a -> b -> a)
08:04:48 <genneth> oh oops
08:04:57 <genneth> @pl foldl (\x y -> x ++ f y) (f a)
08:04:58 <lambdabot> foldl ((. f) . (++)) (f a)
08:05:11 <basti_> uhm
08:05:23 <xerox> @type \f a -> foldl (\x y -> x ++ f y) (f a)
08:05:35 <lambdabot> \f a -> foldl (\x y -> x ++ f y) (f a) :: forall b a.
08:05:35 <lambdabot>               (b -> [a]) -> b -> [b] -> [a]
08:05:39 <Speck> is pl the pointless reduction?
08:05:39 <basti_> STM streams + a little wrapper stuff = UI Logic
08:05:41 <reffie> bzzt
08:05:44 <xerox> Speck, yep.
08:05:58 <xerox> Speck, a.k.a. points-free style programming.
08:06:03 <genneth> @type map
08:06:05 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
08:07:11 <Speck> qemu -fda hOp.flp  doesn't run for me using windows :-(
08:11:13 <genneth> @type \f l -> foldl (\x y -> x ++ f y) (f $ head l) (tail l)
08:11:20 <lambdabot> \f l -> foldl (\x y -> x ++ f y) (f $ head l) (tail l) :: forall
08:11:20 <lambdabot> a
08:11:20 <lambdabot>                       a1.
08:11:20 <lambdabot>                     (a1 -> [a]) -> [a1] -> [a]
08:11:28 <genneth> @type map
08:11:30 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
08:11:41 <genneth> YES!!
08:11:45 <genneth> ahem
08:11:46 <genneth> excuse me
08:12:42 <TheHunter> @type \f -> foldr ((:) . f) []
08:12:43 <xerox> NO!!
08:12:44 <lambdabot> \f -> foldr ((:) . f) [] :: forall a a1. (a -> a1) -> [a] -> [a1]
08:12:56 <TFK> What is this forall that I keep seeing?
08:13:11 <genneth> xerox: damn it!
08:13:27 <xerox> TFK, I think the meaning pretty transparent.
08:13:28 <ndm> TFK, a GHC extension
08:13:41 <TheHunter> TFK, http://www.haskell.org//pipermail/haskell-cafe/2005-June/010505.html
08:13:44 <TFK> xerox, why include it at all, then?
08:13:54 * TFK crawls
08:14:27 <xerox> To avoid defaulting?
08:15:07 <TFK> defaulting to what?
08:15:35 <TFK> The "transparent" meaning doesn't seem to change anything, on the surface of it. (I'm still reading the ml linkie.)
08:15:45 <earthy> defaulting, the mechanism that fills in default types for polymorphic values
08:15:48 <earthy> s/values/types
08:16:39 <TFK> Does that make sense?
08:20:15 * Speck wonders why yi doesn't use Just Another Plugin for editor state, which is never reloaded
08:20:16 <xerox> TFK, for transparent I meant "obvious", i.e. forall a.. "for all a" :-)
08:20:47 <musasabi> @repos
08:20:48 <lambdabot> Unknown command, try @listcommands.
08:21:01 <musasabi> hmm.
08:21:15 <shapr> dons: Hey, what do you think about adding load-on-demand and unloading after a certain amount of idle time for a plugin?
08:21:41 <shapr> musasabi: What are you looking for?
08:21:56 <shapr> Speck: Read the Yi paper, it's cool!
08:22:07 <Speck> I am reading it, but it has so many words :-(
08:22:13 <shapr> heh
08:22:20 <Speck> not nearly enough pictures!
08:22:30 <TFK> That doesn't explain why it's there.
08:22:39 <musasabi> shapr: there was an announcement of the @repos plugin to lambdabot at darcs-user, and I wondered whether lambdabot on #haskell used it.
08:22:45 <TFK> I suppose I'll have to live with "it's an extension thing" for now...
08:23:38 <xerox> TFK, http://www.haskell.org//pipermail/haskell-cafe/2005-June/010509.html
08:23:48 <shapr> There are other running lambdabot instances?
08:23:55 * shapr is surprised
08:24:40 <musasabi> shapr: I was running a hacked version of lambdabot for a rpg in a different network.
08:24:48 <shapr> cool!
08:25:28 <shapr> I wish there were some generic open source popularity reporting website.
08:25:42 <TFK> xerox, yes, I've read that.
08:26:22 <xerox> TFK, reason: defaulting and morphism.
08:26:34 <TFK> Now in English, please.
08:27:04 <TFK> Well, some defaulting takes place, that much is known.
08:27:18 <shapr> Something where lambdabot instances could make a web request once a day to say "people are actually using this software".
08:27:18 <shapr> I always wonder who's using code I've written, and what they think about it.
08:27:18 <shapr> I wish for more feedback for TMR too.
08:28:40 <genneth> is there a reason that such a dial home thing couldn't be a plugin?
08:29:21 <shapr> I'm sure it could be a plugin, but there's not a popularity website to dial.
08:29:22 <musasabi> genneth: it could be for lambdabot but a more generic mechanism would be nice.
08:30:11 <xerox> Does anybody know who mantans that site full of Freenode's channels logs?
08:30:24 <shapr> The Common Lisp guys, I think.
08:30:42 <shapr> clog is the meme.b9 logbot, written in Common Lisp, I think.
08:30:59 <shapr> er wait, clog is the tunes.org guys, meme is the CLisp bot.
08:31:08 <genneth> lol
08:31:11 <musasabi> For haskell a very simple solution would be a small program (debian package) that runs in cron and each month emails ghc-pkg --list, but that works only for libraries.
08:31:36 <genneth> i guess the infrastructure could be something as simple as a http post to a certain url
08:32:02 <genneth> GET on that url produces an atom feed (just for show)
08:32:04 <mfurr> there's also pop-con for debian (http://popcon.debian.org/)
08:32:29 <shapr> Yeah, but it's specifically for debs. I was wondering about something more generic.
08:32:41 <shapr> I do use popcon though :-)
08:32:58 <mfurr> what? not everyone uses debian?
08:33:03 <shapr> Why doesn't Cabal handle apps as well as libs?
08:33:09 <shapr> Maybe it does?
08:33:35 <Lemmih> It tries to.
08:35:37 <musasabi> Cabal handles apps.
08:35:55 <musasabi> But it is nontrivial to use cabal with them.
08:36:08 <musasabi> 6.4.1 should help partly with that.
08:36:11 <shapr> cool
08:36:55 <dcoutts_> xerox, Speck, shapr: yes hIDE 2 is a currently a dream. However, there is clearly demand for such a thing and I think we have the technology to do it. It just need developer buy-in.
08:37:06 <xerox> dcoutts!
08:37:13 <dcoutts_> xerox!
08:37:25 <lispy> hIDE 2?
08:37:30 <lispy> an editor?
08:37:38 <xerox> HsCairo + Gtk2Hs proposal got accepted!  Did you see my email?
08:37:38 <dcoutts_> an IDE in Haskell
08:37:46 <dcoutts_> xerox, really! wow! cool!
08:38:02 <dcoutts_> I didn't see you mail, did you send it today? I've not checked yet!
08:38:18 <xerox> I sent it on the 25th ;)
08:38:21 <lispy> dcoutts_: well, i guess you could use Yi as a starting place for the hacking
08:38:31 <dcoutts_> (sorry! too! many! exclamation! marks! - I've very excited!)
08:38:37 <dcoutts_> lispy, exactly
08:38:42 <xerox> dcoutts_, I! am! too! :-)
08:39:01 <dcoutts_> lispy, see http://www.haskell.org/hawiki/HaskellIde
08:40:54 <lispy> dcoutts_: ya cool
08:41:37 <dcoutts_> lispy, we should add a bit at the bottom of that page for people who are interested in contributing code / ideas
08:42:17 <lispy> dcoutts_: is that hint for me to add my thoughts to that page?
08:42:34 <dcoutts_> lispy, yep :-)
08:43:16 <lispy> okay, well not at the moment (I'm supposed to be working...) but if i remember when i get home i'll look at it again
08:56:02 <Lemmih> Given the types 'Zero r' to 'Nine r' and 'End', is it possible to define type classes for runtime addition and subtraction?
08:58:45 <musasabi> Nine?
08:58:53 <Lemmih> s/runtime/compile-time/
08:59:12 <musasabi> It is possible if you had Zero and One, not sure about Nine.
08:59:26 <Lemmih> One (Two (Three End)) => 123
08:59:39 <musasabi> of course doing it without blowing out the context stack is nontrivial.
08:59:49 <Lemmih> 'Succ r' and 'Zero' are no fun (:
09:00:10 <musasabi> What about using binary numbers?
09:00:19 <xerox> newtype Nine = Succ .. ?
09:00:29 <musasabi> END, One r, Zero r.
09:01:01 <Lemmih> xerox: 'data Nine r'
09:01:25 <xerox> Lemmih, I mean, could it be possible to declare Nine in terms of Succ?
09:02:05 <Lemmih> type Nine = Succ Eight?
09:02:22 <xerox> Maybe it would work that way?
09:02:25 <Lemmih> That's not what I'm after.
09:03:16 <Lemmih> musasabi: Can it be done with binary numbers? If so, it should be easy to translate to base 10.
09:03:41 <xerox> Lemmih, how what you're after is different?
09:04:18 <Lemmih> One (Two (Three End)) => 123
09:04:32 <xerox> I see :-)
09:06:05 <Lemmih> I don't actually need this. Just wondering if it's possible.
09:06:10 <xerox> Lemmih, why are you doing it, by the way?
09:06:19 <xerox> Ouch.  Time-traveller.
09:06:45 <Lemmih> Typed matrices.
09:07:19 <musasabi> Lemmih: I think it can be.
09:08:27 <musasabi> class BinPlus a b r | a b -> r; instance (BinPlus a b r) => (One a) (Zero b) (One r); ...
09:08:55 <musasabi> Haven't actually implemented it so I am not sure it won't have problems.
09:09:32 <TheHunter> Lemmih, it's been done.
09:09:38 <TheHunter> @google implicit configurations
09:09:39 <Lemmih> TheHunter: URL?
09:09:40 <lambdabot> http://www.eecs.harvard.edu/~ccshan/prepose/prepose.pdf
09:11:32 <TheHunter> ohh, i thought you were after modular arithmetic, sorry.
09:15:16 <TheHunter> class TypeNatural a; data Nat = forall a. Typenatural a => Nat a; plus :: Nat -> Nat -> Nat. Is that what you want? It's entirely possible.
09:16:10 <Lemmih> That's not what I want.
09:16:56 <TheHunter> musasabi's thing is no problem to implement either.
09:17:13 <TheHunter> probably the HList library implements it.
09:18:00 <shapr> You could take the BoundedList approach from HaskellDB, that encodes everything into typeclass instances.
09:19:24 <Lemmih> TheHunter: Would you care to take a stab at it?
09:20:10 <TheHunter> @google HList "Joy.hs"
09:20:11 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2005-March/009345.html
09:21:28 <Lemmih> How does that relate to my problem?
09:21:30 <TheHunter> http://homepages.cwi.nl/~ralf/HList/HList.zip
09:22:01 <Lemmih> Of course it's easy with 'HZero' and 'HSucc r'.
09:22:11 <musasabi> The BoundedList was a quite verbose implementation if I remember right.
09:22:25 <musasabi> Something more concise should be possible,
09:22:47 <musasabi> HList is probably the best place to start looking.
09:27:59 <shapr> dcoutts_: Do you know if Knit and c2hs have already cross-fertilized?
09:28:04 <TFK> Oooh, a Go bot in O'Caml!
09:28:21 <TFK> 21k, it says.
09:30:06 <xerox> TFK, wow, where?
09:30:12 <dcoutts_> shapr, Knit? what's that
09:30:13 <TFK> on KGS
09:30:16 <TFK> playing it right now
09:30:31 <TFK> LeGoBot
09:36:46 <TheHunter> Lemmih, it's kinda painful, but it's no problem at all.
09:37:09 <xerox> TFK, take a look at
09:37:12 <xerox> @wiki HaskellGoPeople
09:37:13 <lambdabot> http://www.haskell.org/hawiki/HaskellGoPeople
09:37:45 <TFK> I must say that the bot is much more stupid than a 21k player...
09:37:53 <_JusSx__> where can i download HSQL?
09:38:11 <musasabi> most of the time bots are good on small moves and suck on strategy.
09:38:28 <TFK> Do I count as a Haskell person?
09:38:38 <xerox> TFK, indeed :-)
09:38:39 <Lemmih> _JusSx__: htoolkit.sf.net
09:38:53 <xerox> hiya genneth, how's your code going? :)
09:38:53 <_JusSx__> Lemmih: thanx
09:38:58 * TFK scribbles his name on the page
09:39:20 <shapr> @google knit haskell
09:39:21 <lambdabot> http://www.mielkesfarm.com/csm/knit_together.htm
09:39:24 <shapr> hmm
09:39:28 <shapr> @google knit haskell reid
09:39:30 <lambdabot> http://www.reid-consulting-uk.ltd.uk/alastair/publications/
09:39:32 <shapr> ah
09:40:17 <genneth> xerox: fun; i'm finishing off the boundary between compile time and run time; from here on out everything is with metatemplate programming techniques. not sure if that's worse or better
09:40:40 <Lemmih> TheHunter: Care to put code where your mouth is? (:
09:40:51 <shapr> dcoutts_: http://www.cs.utah.edu/flux/alchemy/knit.html
09:40:51 <genneth> xerox: it does mean i can use haskell more and prototype in a saner language :p
09:41:37 <xerox> genneth, "good", I think :-)
09:42:13 <TheHunter> Lemmih, almost done :)
09:42:36 <Speck> mmm... indian food
09:43:53 <SyntaxNinja> good morning all
09:44:15 <Lemmih> Evening, SyntaxNinja.
09:44:17 <shapr> hiya SyntaxNinja!
09:45:43 <Speck> afternoon, syntax
09:46:53 <dcoutts_> shapr, I don't know of any cross-fertilisation between c2hs and Knit
09:47:11 <shapr> Surprising, since it sounds like Knit has an excellent C parser.
09:47:15 <dcoutts_> c2hs has it's own C parser, ast and analysis stuff
09:47:38 <dcoutts_> the C parser is not that hard, it's just hard to do fast :-)
09:47:43 <shapr> oh
09:47:59 <dcoutts_> I re-wrote it using Alex & Happy
09:48:12 <dcoutts_> maybe I should have looked at Knit first
09:48:17 <TheHunter> Lemmih, http://hbin.dyndns.org/pastebin/60.html
09:49:48 <TheHunter> notice it doesn't need undecidable instances...
09:50:28 <shapr> dcoutts_: Seems like the smart approach would be for the community to have a single parser for use by all the projects.
09:50:52 <shapr> I'd like that for Python, PHP and other languages.
09:51:45 <Lemmih> TheHunter: Thanks.
09:52:40 * poetix is consumed by an all-consuming hatred of all things Oracle
09:53:35 <dcoutts_> shapr, yes we should turn one of these into a standard Language.C.* module
09:53:57 <dcoutts_> though we'd have to agree on an AST which is harder
09:54:38 <dcoutts_> I suspect our Happy parser is the fastest though, about 500Kb/s on a fast machine and we're not using GHC's FastString tricks yet
09:56:57 <shapr> In any case, I think Haskell's killer app is parsers/compilers/language implementations, so having featureful standard parsers for a variety of languages would be a great asset.
09:57:14 <dcoutts_> shapr, indeed
09:57:22 * xerox agrees
09:58:13 <dcoutts_> shapr, the curel people say that Haskell is a domain specific language for writing Haskell compilers
09:58:55 <shapr> Yeah, a few years ago the cruel people also said that garbage collection could stay in its ivory tower for all they cared.
09:59:14 * lispy isn't here but if he were he'd have chortled at dcoutts_ 
09:59:31 <TFK> Yeah, while the Java/Python/Perl programmers laughed from above.
10:00:47 <shapr> Nowadays the cruel people say that Java's type system is just fine, they don't need type inference.
10:01:01 <Lemmih> TheHunter: Uhm, 10 + 1 is not 01 (:
10:01:16 <dcoutts_> shapr, well that's ok so long as we all know they're wrong
10:01:58 <Speck> three people?
10:02:03 <lispy> Lemmih: it is mod 10 ;)
10:02:16 <shapr> There are ten kinds of people in the world, those who understand binary, and those who don't.
10:02:27 <TheHunter> Lemmih, but 01 + 1 is 10
10:03:05 <Speck> I think it's "10 kinds of people"
10:03:07 <TFK> "Talk is cheap, show me the code." -- Linus Torvalds
10:03:21 <Lemmih> nat ( testPlus (undefined :: One (Zero End)) (undefined :: One End))
10:03:22 <Lemmih> 2
10:04:12 <Lemmih> :t plus (undefined :: One (Zero End)) (undefined :: One End)
10:04:12 <Lemmih> plus (undefined :: One (Zero End)) (undefined :: One End) :: Zero (One End)
10:04:17 <shapr> Speck: I speak it that way to people, and then they correct me. The joke as I see it is that I'm obviously part of those who do not undersand binary.
10:04:25 <TheHunter> *Main> nat (undefined :: One (Zero End))
10:04:25 <TheHunter> 1
10:04:29 <Speck> hehehe
10:04:41 <TheHunter> you have to reverse the thing :)
10:05:37 <TheHunter> n = \sum{2^i a_i}
10:07:59 <Lemmih> The arguments to 'plus' should also be reversed, right?
10:09:40 <dcoutts_> hey shapr, are you going to CUFP?
10:09:50 <shapr> It's colo with ICFP, isn't it?
10:09:57 * shapr checks
10:10:12 <dcoutts_> oh, yes probably they are
10:10:18 <shapr> Right, I'm not going to ICFP this year.
10:10:21 <dcoutts_> :-(
10:10:34 * Heffalump is not too keen on spending ~800 so won't be either
10:10:40 <Heffalump> dcoutts_: did xerox catch up with you?
10:10:46 <dcoutts_> Heffalump, yes
10:10:48 <shapr> I wish I could show up at CUFP, I have a lot to say.
10:10:53 <xerox> Heffalump, finally :-)
10:10:53 <dcoutts_> I bet you do!
10:11:07 * Heffalump would like to go to CUFP too.
10:11:14 <Heffalump> I missed it last year which was silly.
10:11:45 <dcoutts_> Heffalump, yeah, you'd have got free entry
10:11:51 <Heffalump> I would?
10:11:56 <dcoutts_> I think so
10:12:02 <Heffalump> how come?
10:12:04 * earthy doubts that somehow
10:12:11 <dcoutts_> how many we're we allowed to send?
10:12:34 <Heffalump> sorry?
10:12:43 <dcoutts_> Igloo and I didn't have to pay registration for ICFP last year
10:12:47 <Heffalump> yes, but I did.
10:13:00 <shapr> hiya Jugmaster, learning Haskell?
10:13:01 <Heffalump> Igloo didn't go, but Andres would have gone.
10:13:06 <dcoutts_> err, yes
10:13:12 <dcoutts_> sorry confusion
10:13:18 <Jugmaster> yeah shapr, maybe you can help me
10:13:45 <dcoutts_> Heffalump, so you didn't get in free because you were no longer a student?
10:14:01 <basti_> does anyone have the sourcecode of the yampa arcade? or know where it is
10:14:01 <basti_> ?
10:14:16 <shapr> basti_: It's available in fptools, I think.
10:14:28 <shapr> I've got a patch to get it running with 6.2 (maybe even 6.4)
10:14:44 <basti_> hmm
10:14:54 <shapr> Jugmaster: Do you have prior experience with functional languages? Are you learning for fun or school or work?
10:15:30 <Jugmaster> i need to build a graph representing flow dependencies between statements
10:15:42 <Jugmaster> happen to have a piece of theory lying around
10:15:43 <Jugmaster> :P
10:15:56 <shapr> hIDE had something like that, not sure what though.
10:16:17 <shapr> Oh wait, that was module deps.
10:16:29 <shapr> Programatica might do that.
10:16:56 <Jugmaster> actually, my use for haskell will come after i figure out how the hell i calculate those dependencies efficient
10:16:58 <shapr> Do you want flow among functions or flow among all statements?
10:17:35 <Jugmaster> im looking at one loop. Every iteration should be done in parallel. But for that to work...you
10:17:42 <Jugmaster> need to check the flow dependencies
10:17:48 <Jugmaster> i.e. loop carried dependencies
10:18:04 <Jugmaster> but you'd need to know exactly which iteration produces and which one consumes i think
10:18:27 <shapr> May I suggest a nice cup of declarative parallelism?
10:18:43 <shapr> My favorite flavor is nested data parallelism.
10:19:08 <Jugmaster> could you elaborate some more what you mean shapr?
10:20:35 <shapr> I think what you're describing is loop unrolling, but I'm not sure. I know that loop unrolling is in gcc and some other compilers.
10:21:15 <Jugmaster> well, first of all, i want the graph containing all these flow dependencies right?
10:21:22 <Jugmaster> before i even think what to do about them
10:22:39 <shapr> Do you want to parallelize Haskell code? or some other language?
10:23:04 <Jugmaster> other language, im using haskell to implement my tool that builts up this graph etc
10:23:13 <shapr> I'm not sure if you can find flow dependencies directly from call-by-need.
10:23:49 <shapr> In that case, I'd suggest writing a parser for your language, and then throwing the AST into Erwig's graph library.
10:24:30 <Jugmaster> i already have the cfg in haskell
10:24:34 <shapr> I don't know anything parallelizing loops in procedural languages, so you have to take my advice with a grain of salt.
10:24:52 <Jugmaster> but i lack the knowledge at this moment on how to detect all those flow dependencies nicely
10:26:04 <shapr> I would guess that's a standard graph theory problem, there may already be code to do that in Erwig's graph library.
10:26:48 <shapr> I'm not an expert on graph algorithms either, but it probably won't cost you more than an hour to download, install, and try out Martin Erwig's graph modules.
10:29:09 <Jugmaster> its not really a graph problem i think, but more a data dependency problem...which in turn is ofcourse implemented using graphs...but the theory is really data dependency theory and not graph theory
10:31:39 <shapr> Still might work.
10:33:36 <Jugmaster> ow maybe i could still use his library, no doubt. But my problem now is more that i need to decide how to efficiently build a data dependency graph
10:38:12 <basti_> shapr: where in fptools?
10:40:46 <shapr> Hm, I dunno.
10:41:02 <shapr> It's on cvs.haskell.org somewhere, I'm sure of that.
10:49:37 <thedward> Can anyone tell me what "Non-exhaustive patterns in function foo" means?
10:50:28 <SyntaxNinja> thedward: is it a warning or a runtime error?
10:51:00 <SyntaxNinja> does anyone know offhand which function / library throws this uninformative exception? Fatal error: exception Invalid_argument("index out of bounds")
10:51:02 <xerox> SyntaxNinja, could it happen at runtime?
10:51:14 <shapr> SyntaxNinja: maybe ! or !! ?
10:51:17 <xerox> !! ?
10:51:27 <thedward> SyntaxNinja: it is a runtime error or warning; the program finishes, then says that
10:51:27 <xerox> shapr, 1; xerox, 0
10:51:32 <SyntaxNinja> xerox: a non-exhaustive pattern match failure could, but the wording would probably be different
10:51:41 <SyntaxNinja> I tried ! and !! already :)
10:51:55 <SyntaxNinja> they both output slightly more informative things
10:52:09 <shapr> thedward: I always put myfunction x = "error, myfunction got this unhandled input:" ++ show x
10:52:13 <xerox> grep "index out of bounds" in GHC sources?
10:52:23 <shapr> thedward: as the last line of every pattern matching setup
10:52:50 <SyntaxNinja> thedward: do you know what pattern matching is? the error means that you missed a case in one of your pattern matches
10:52:56 <shapr> SyntaxNinja: the error seems to imply that something is getting "index out of bounds" as the input?
10:53:00 <thedward> ah
10:53:04 <thedward> that makes sense now
10:53:11 <thedward> I think
10:53:34 <SyntaxNinja> shapr: I'm guessing someone thew an exception with that as the error message
10:53:54 <shapr> oh
10:54:02 <SyntaxNinja> I grepped the library sources for it, but I'll try the comp. sources
10:54:13 <thedward> okay, yah, that was it. is there a "best thing" to do for a no-op?
10:54:27 <thedward> returning [] works, but wondering if that is a bad idea
10:55:02 <SyntaxNinja> what do you mean no-op? that case _is_ getting hit during runtime, so you have to return a valid input
10:55:25 <SyntaxNinja> if you want to signal an error case, like if yo're searching for something and haven't found it, you can return Nothing, but you have to change the return type to Maybe
10:56:15 <thedward> well, I'm basically taking a list, and printing it out. was doing it recursively. I don't want to print out anything if it is an empty list.
10:56:18 <shapr> I tend to include the function name in my error throws, it just makes more sense.
10:56:34 <shapr> thedward: That should be your base case then.
10:57:21 <SyntaxNinja> oh, I think I found it. and fortunitely, I can blame it on someone else, and not haskell :)
10:58:16 <shapr> yay!
10:58:34 <astrolabe> witch hunt!
11:03:20 <SyntaxNinja> that guy's lucky he's not here right now
11:06:26 <SyntaxNinja> thedward: clarified?
11:07:31 <xerox> @type putStr
11:07:40 <lambdabot> putStr :: String -> IO ()
11:07:42 <xerox> ;)
11:08:30 <thedward> SyntaxNinja: yeah. now I've got new problems. :)
11:08:51 <xerox> thedward, which features have you discovered? :-)
11:09:17 <thedward> heh
11:09:54 <thedward> I'm building a lits of input recursively, with a 0 to stop, and I am getting the zero at the end of the list, and I'm not sure why
11:11:28 <thedward> ah. bug in the output code, not in the list generation
11:13:13 <thedward> if I put "foo [] = blah" before "foo (x:xs) = blah" the empty list won't go to the second version, yes?
11:13:46 <xs> yes
11:14:27 <xs> but the order doesn't matter, i think.
11:14:42 <xs> since [] will not match with (_:_)
11:15:23 <thedward> it just automatically picks the best fit?
11:16:11 <Igloo> First fit
11:16:39 <thedward> so order does matter?
11:16:46 <dcoutts_> yes
11:16:49 <thedward> (just not in this case?)
11:16:57 <Igloo> right
11:16:59 <dcoutts_> so don't put "foo _" first!
11:17:06 <xerox> Order does matter.
11:17:50 <thedward> I understand.
11:20:48 <shapr> dons: Your page is blank, maybe server issues? - http://www.cse.unsw.edu.au/db/staff/info/dons.html
11:21:19 <thedward> wow. I am dumb. my code was fine. I can't read the screen.
11:28:36 <Jugmaster> i see an aussi barbecueing on that page
11:28:52 <Jugmaster> kangaroo steak
11:31:26 <shapr> huh
11:31:37 <shapr> It's blank for me.
11:32:39 <Jugmaster> weird
11:32:39 <Jugmaster> let me refresh
11:33:49 <Jugmaster> why do i get more thirsty of drinking :S
11:33:54 <Jugmaster> this is not helping
11:38:42 <thedward> It feels really bizarre trying to learn haskell after years of procedural programming
11:38:54 <shapr> Yeah, it's brain twisting.
11:39:04 <shapr> I don't want to go back though.
11:39:15 <jlouis> twist brain, gain gain
11:39:30 <thedward> it is especially painful to be learning haskell, then get paid to write perl
11:40:02 <shapr> I get paid to write Python, so...
11:40:13 <monochrom> I had a decade of procedural programming before I learned Haskell.
11:40:30 <monochrom> It felt like "I knew a better way exists!"
11:40:55 <shapr> Yeah, that was my reaction too.
11:51:49 <Heffalump> dcoutts_: belatedly, yeah.
11:51:59 <Heffalump> the free entries were only for students
11:52:05 <dcoutts_> oh right
12:01:51 <Frederick> is there any channel on freenode for ml?
12:02:40 <Heffalump> #sml?
12:03:09 <shapr> #ocaml?
12:03:53 <Frederick> sml will do it :)
12:03:59 <shapr> Frederick: try /msg chanserv list *ml*
12:04:30 <Jugmaster> i learned haskell and java in parallel on my university
12:04:37 <musasabi> Are
12:04:44 <musasabi> grah. wrong channel.
12:05:04 <shapr> Jugmaster: lucky you, I didn't learn anything at my uni!
12:05:16 <Jugmaster> nothing :D
12:05:22 <Jugmaster> what uni was that
12:06:48 * SM_ax has another problem with ghc-6.4 compilation
12:07:03 <SM_ax> make hangs up in ghc/compiler directory
12:08:53 <SM_ax> debug output from make shows infinite  number of "Pruning file `main/Config.hs'" messages
12:09:30 <SM_ax> can anyone suggest smth?
12:14:50 <Heffalump> wait for the infinite list of messages to end.
12:15:01 <Heffalump> (run it on Linux, which can do infinite loops in 10 seconds)
12:15:48 <monochrom> wow!
12:16:16 <lispy> infinite.... or UNBOUNDED
12:16:32 <lispy> or Arbitrarily large?
12:16:41 <monochrom> omega
12:16:51 <lispy> O(mega) ?
12:17:04 <monochrom> if you need omega*5 iterations, it will take 50 seconds.
12:17:18 <monochrom> the first infinite ordinal, omega.
12:17:30 <lispy> oh, i call it aleph
12:17:44 <lispy> specificaly aleph_o
12:17:49 <lispy> er, that o should be a 0
12:18:00 <monochrom> aleph_0 emphasizes the cardinality.  omega emphasizes the well-ordering.
12:18:40 <monochrom> but in reasoning about non-terminating loops, it is the well-ordering that matters.
12:18:56 <lispy> i see
12:19:00 <monochrom> it comes down to transfinite induction.
12:19:08 <lispy> yay
12:20:16 * lispy has heard of transfinite induction but still needs to develop an understanding
12:21:04 <monochrom> try http://www.cs.utoronto.ca/~trebla/transfinite.txt
12:21:20 <monochrom> I tried to trivialize it.
12:22:38 <lispy> monochrom: nice link
12:22:51 <monochrom> Thanks. I wrote it. :D
12:23:06 <lispy> cool
12:27:37 <Frederick> can anyone here help me with using mapstring fucntion in ml?
12:28:31 <mflux_> maybe, but maybe #ocaml or #sml would be a better match?
12:28:55 <Frederick> mflux_ ppl seem to be sleeping over sml
12:29:49 <monochrom> I would expect mapstring to be similar to map
12:30:09 <monochrom> ( map : list :: mapstring : string  right? )
12:30:15 <mflux_> there is already map, so there must be something different
12:30:25 <mflux_> oh, is mapstring mapping of characters?
12:30:33 <monochrom> I would think so.
12:30:35 <mflux_> that would sound mostly useless to me ;)
12:30:49 <Igloo> What's the type of mapstring?
12:30:57 <monochrom> ML is unlike Haskell in that a string is not the same as [Char]
12:30:59 <mflux_> aha, a web search reveals that: "could be defined as: fun mapstring f = implode o map fo explode"
12:31:22 <mflux_> propably fo -> f o
12:31:32 <Frederick> im trying to do this -> http://rafb.net/paste/results/iDgXUi38.html
12:31:49 <monochrom> implode and explode provides the isomorphism between string and char list in SML.
12:32:57 <monochrom> this makes no sense. why are you defining mapstring?
12:32:58 <mflux_> first maybe you shouldn't call your function mapstring too
12:33:26 <mflux_> second I think using pattern matching would be cleaner and more ml-like
12:33:36 <monochrom> and why are you not using mapstring?  this is very incoherent.
12:33:51 <Frederick> mflux_ im trying to do as it is crappy described here -> http://www.poplog.org/docs/popdocs/ml/help/string
12:34:12 <mflux_> hmh
12:35:19 <mflux_> you should write something like mapstring yourfunctionhere yourstringhere, where yourfunctionhere would not be 'mapstring'
12:35:33 <Frederick> I dont get it
12:36:10 <Frederick> is mapstring already defined?
12:36:11 <monochrom> We don't get you.
12:36:18 <monochrom> Yes.
12:36:43 <Frederick> oki how do I use it?
12:37:00 <monochrom> depends on what you want it to do.
12:37:24 <monochrom> Your second url has a good description and a good example.  It is not crappy.
12:37:39 <Frederick> I want to use mapstring to remove "," "." "(" ")" from my srea
12:37:42 <Frederick> *stream
12:37:46 <monochrom> Maybe it is English and English is a crappy language but that page is not crappy.
12:38:57 <Frederick> monochrom how would I call mapstring to remove the chars ive mentioned from my stream?
12:39:29 <monochrom> mapstring (fn s => if isspace s or s = "," or s = ";" or s = "." or s = "(" or s = ")" then "" else s) "--- Title ---"
12:39:40 <monochrom> My question is why is it not obvious?
12:40:05 <monochrom> It's almost a mindless adaptation of the example
12:40:42 <Frederick> what is this "title" stuff?
12:40:48 <monochrom> the input string
12:41:02 <Frederick> k
12:41:22 * shapr is tempted to add ML to the topic
12:41:50 <monochrom> why is that not obvious?
12:42:42 <Frederick> cause this heck doest has a book like K&R where I can read and check real examples.
12:42:43 <mflux_> hmm, is there sml-equivalent of ocaml's function a -> .. | b -> ..? without fn x => case x..
12:42:48 <monochrom> moreover why were you using := all over the place when clearly it should be = ?
12:42:58 <Frederick> http://rafb.net/paste/results/o81xjz72.html
12:43:24 <monochrom> mapstring (fn s => if isspace s then "" else s) "--- Title ---";   is a real and good example.
12:43:25 <Frederick> monochrom look above url
12:43:30 <monochrom> why?
12:43:38 <monochrom> I think you're just being dense.
12:43:47 <Frederick> cause ive corrected := stuff
12:43:54 <Frederick> and some little things mre
12:44:30 <Frederick> and I get an errorI dont understand over line 13
12:44:51 <monochrom> I am not amused that you call a perfectly clear and well-illustrated page "crappy".
12:45:19 <monochrom> If you're entitled to say that, I think I'm entitled to call you illiterate too.
12:45:19 <Frederick> 
12:46:37 <Frederick> monochrom think as someone who had never programmed in ml before now I got an assignment for school I need it done by next friday. I go google for decent material like a starts guide or something like that but ive found nothing but the same examples
12:46:52 <monochrom> You think K&R is well-written.
12:46:59 <monochrom> Well, it is.
12:47:38 <Frederick> monochrom very well, has explanation, examples exercice structure I cant find in any ml tutorial
12:47:46 <monochrom> I never heard a student reading K&R the first time, looking at the first C example, asking what is this "hello world" thing?
12:48:11 <monochrom> But you did the equivalent of that when you asked what is this "title" thing.
12:48:17 <shapr> Frederick: If you have any Haskell questions...
12:49:03 <monochrom> So I think you're just prejudiced.
12:50:18 <monochrom> How much did you paid for K&R?
12:50:36 <monochrom> Did you get the full K&R text by google?
12:51:24 <monochrom> Go get "ML for the working programmer" by Lawrence Paulson from a real bookstore.
12:56:17 <Heffalump> and stop using a Haskell channel to not only be dense, but be dense about a language that isn't Haskell :-)
12:58:28 <xs> hm, what's the section for - 1?
12:58:49 <Heffalump> (subtract 1)
12:58:50 <monochrom> yuck, that one is hard
12:59:04 <xs> ick. ok, thanks
12:59:13 <monochrom> it's icky either way
12:59:34 * Heffalump has had to ask Igloo that question during both the last two ICFP contests.
12:59:46 <monochrom> haha
12:59:48 <Heffalump> But since the most recent time wasn't very long ago, I can still remember the answer :-)
12:59:50 <xs> hehe
12:59:55 <Heffalump> but yeah. ick.
13:13:32 <TheHunter> @pl flip (-)
13:13:33 <lambdabot> flip (-)
13:13:43 <xerox> subtract!
13:13:50 <xerox> xerox 1, lambdabot 0.
13:18:36 <TheHunter> @pl flip (-) x
13:18:38 <lambdabot> subtract x
13:19:25 <monochrom> xerox 1, lambdabot 1.
13:21:29 <Heffalump> @pl flip subtract x
13:21:30 <lambdabot> (-) x
13:21:39 <Heffalump> Heffalump 0, xerox 1, lambdabot 2
13:22:20 <hyperion> @yo
13:22:21 <lambdabot> I hope you millionaires are having fun!  I just invested half your
13:22:21 <lambdabot> life
13:22:21 <lambdabot> savings in yeast!!
13:22:22 <hyperion> @mo
13:22:23 <lambdabot> Maybe you meant: moo more
13:22:31 <hyperion> @moo
13:22:32 <lambdabot>               ..---..                             (__)
13:22:32 <lambdabot>              /       \                            (oo)
13:22:32 <lambdabot>              |  RIP  |                     /-------\/
13:22:32 <lambdabot>              |       |                    / |     ||
13:22:32 <lambdabot>              |       |                   *  ||----||
13:22:32 <lambdabot>              |       |                      ^^    ^^
13:22:34 <lambdabot> \\\\\\\\\\\\\\\\\/////////////////
13:22:36 <lambdabot>  
13:22:38 <lambdabot>             Elvis's Cow...      ...Or is it alive and living in tax exile???
13:22:39 <Heffalump> hey, stoppit
13:22:54 <monochrom> haha
13:22:59 <Heffalump> that was essentially a whole screenful of you+lambdabot and you only just joined
13:23:02 <goron> hyperion: funny guy...
13:23:17 <goron> Heffalump: I brought him on thie idea.
13:23:22 <goron> Heffalump: I am so sorry.
13:23:23 <monochrom> No, lambdabot is the funny guy.
13:23:43 <goron> monochrom: I know
13:23:56 <Heffalump> I think that moo thing should be turned off. It's a bit too noisy.
13:24:05 <monochrom> alright
13:24:10 <hyperion> @type goron
13:24:15 <lambdabot> bzzt
13:24:25 <goron> @type 5*5
13:24:26 <lambdabot> 5*5 :: forall a. (Num a) => a
13:24:27 <monochrom> goron :: forall a. a
13:24:36 <goron> Yeah. Undefined
13:24:53 <goron> I am bottom :)
13:24:59 <monochrom> monochrom: 1, lambdabot: 0, goron: forall a. a
13:26:22 <goron> @type undefined
13:26:24 <lambdabot> undefined :: forall a. a
13:26:42 <goron> In the next release, that should be goron
13:30:50 <rtega> !moo
13:30:53 <rtega> @moo
13:30:54 <lambdabot>                      (__)
13:30:54 <lambdabot>                      (oo)
13:30:54 <lambdabot>         /---+      +--\/
13:30:54 <lambdabot>        / |  |      | ||
13:30:54 <lambdabot>       *  ||-+      +-||
13:30:55 <lambdabot>          ^^          ^^                             *
13:30:57 <lambdabot>  
13:31:00 <lambdabot>    David Copperfield's Cow               David Copperfield's other Cow
13:31:06 <rtega> lol
13:31:15 <shapr> @arr
13:31:16 <lambdabot> Drink up, me hearties
13:31:22 <shapr> @ghc
13:31:23 <rtega> how many moo's does the beast have?
13:31:23 <lambdabot>  parse error on input
13:31:27 <rtega> @moo
13:31:28 <lambdabot>                                     (__)
13:31:28 <lambdabot>                                     (oo)
13:31:28 <lambdabot>                              /-------\/
13:31:28 <lambdabot>                             / |     ||
13:31:28 <lambdabot>                            *  ||----||
13:31:28 <lambdabot>                               ^^    ^^
13:31:30 <lambdabot>                              (__)  (__)
13:31:32 <lambdabot>                              (oo)  (oo)
13:31:35 <lambdabot>                       /-------\/    \/-------\
13:31:36 <lambdabot>                      / |     || -^^- ||     | \
13:31:38 <lambdabot>                     *  ||----   -^^-       ||  *
13:31:41 <lambdabot>                        ^^                  ^^
13:31:42 <lambdabot>                       (__)                (__)
13:31:44 <lambdabot>                       (oo)                (oo)
13:31:47 <lambdabot>                /-------\/                  \/-------\
13:31:48 <lambdabot>               / |     ||                    ||     | \
13:31:50 <lambdabot>              *  ||----||                    ||----||  *
13:31:53 <lambdabot>                 ^^    ^^                    ^^    ^^
13:31:55 <lambdabot>                  Barnum's Troupe of performing cows
13:32:08 <shapr> I like @moo, but I think it needs a timeout or something.
13:32:21 <shapr> No more than three moos an hour or something.
13:32:27 <shapr> hiya poetix
13:32:33 <poetix> Hi! moos?
13:32:40 <shapr> Um, yes.
13:32:54 <poetix> I love coming into the middle of #haskell conversations
13:32:59 <shapr> We're calculating the max m/s around here.
13:33:08 <shapr> That is, moos per second, of course.
13:33:18 <poetix> I've not heard any mooing at all lately
13:34:04 <poetix> Oh, and I've decided I have to learn to play Go, so I can be a HaskellGoPerson
13:34:10 <dcoutts_> shapr, surely for maximum confusion it should be max m/h
13:34:12 <goron> :)
13:34:19 <shapr> Fair enough.
13:34:34 <shapr> We could even call it max mph
13:34:51 <dcoutts_> yes, even better
13:35:49 * poetix peruses haskell irc logs
13:35:51 <poetix> @moo
13:35:53 <lambdabot>         (__)
13:35:53 <lambdabot>         (00)
13:35:53 <lambdabot>   /------\/
13:35:53 <lambdabot>  /|     ||
13:35:53 <lambdabot> * ||----||
13:35:53 <lambdabot>  
13:35:55 <lambdabot> Cow w/ Glasses
13:36:46 * poetix decides his next project should be to teach lambdabot to write sonnets
13:36:55 <TFK> @moo
13:36:56 <lambdabot>          (__)       (----------)
13:36:56 <lambdabot>          (--) . . . ( *>YAWN<* )
13:36:56 <lambdabot>    /------\/        (----------)
13:36:56 <lambdabot>   /|     ||
13:36:56 <lambdabot>  * ||----||
13:36:56 <lambdabot>  
13:36:58 <lambdabot> Cow after pulling an all-nighter
13:39:02 <musasabi> a moo feeling comes / when one wakes up / and reads the logs of #haskell
13:39:38 <poetix> @haiku
13:39:39 <lambdabot> Unknown command, try @listcommands.
13:40:42 <TFK> A true haiku is 5-7-5, not 5-5-7 :-/
13:41:36 <TFK> But, it was nice :-)
13:42:42 <tomdavie> @listcommands
13:42:43 <lambdabot> all-dicts arr babel botsnack code define definitions devils dice
13:42:43 <lambdabot> dict dict-help docs dummy easton echo elements eurohaskell eval fact
13:42:43 <lambdabot> fact-cons fact-delete fact-set fact-snoc fact-update foldoc fortune
13:42:43 <lambdabot> gazetteer get-definition ghc google help hitchcock hoogle index
13:42:43 <lambdabot> jargon karma karma+ karma- kind learn libsrc listchans listcommands
13:42:44 <lambdabot> listmodules lojban moo more paste pl pl-resume plugs pointless
13:42:45 <lambdabot> prelude quote remember resume seen source spell state timein todo
13:42:48 <lambdabot> [3 @more lines]
13:43:00 <tomdavie> @help eval
13:43:01 <lambdabot>  @eval expr - evaluate the lambda calculus expression, expr
13:43:28 <tomdavie> @help eurohaskell
13:43:28 <lambdabot> urls are good
13:43:35 <tomdavie> :/
13:43:52 <tomdavie> @help learn
13:43:53 <lambdabot> another url
13:44:43 <tomdavie> @eval \y.\x.x \x.x \y.y
13:44:44 <lambdabot> <<EM Dynamic -> EM Dynamic>>
13:44:49 <tomdavie> I see :/
13:45:08 <poetix> There once was a hacker of Haskell
13:45:13 <poetix> who ended up sorely emascul-
13:45:18 <lament> can people stop saying haiku are 5-7-5
13:45:20 <poetix> ated when for "monads"
13:45:20 <lament> jesus
13:45:26 <poetix> the fellow read "gonads"
13:45:38 <poetix> - thereafter, the chaps stuck to Pascal.
13:45:47 <poetix> s/chaps/chap
13:46:04 <tomdavie> heh... my dad would have liked you for that
13:46:40 <poetix> Last line could bear improvement, but there's a dearth of good rhymes
13:47:00 <tomdavie> indeed
13:47:45 <tomdavie> anyway... you just avoid the monads
13:47:52 <tomdavie> or gonads as the case may be
13:48:02 <tomdavie> equally true for either situation
13:48:28 <poetix> I gather gonad lifting is an ancient oriental erotic art
13:48:46 <xs> gonad binding.
13:48:51 <tomdavie> lifting *into* gonads????? :o
13:48:58 <poetix> More Philippa's kind of thing...
13:50:05 <lament> oh go.
13:50:07 <lament> d.
13:51:40 <poetix> Nine times out of ten when I tell someone I like to program in Haskell, they assume I said "Pascal". Typical response is, "oh, does anyone still use that?"
13:52:35 <tomdavie> heh
13:52:46 <poetix> Borland Turbo Haskell
13:53:14 <xs> oxymoron?
13:53:59 <poetix> or pleonasm?
13:54:42 <xs> painful.
13:55:13 <Frederick> can I ask about sml here? if I can what is wrong now? http://rafb.net/paste/results/arKREi65.html
13:55:19 <Frederick> #sml is dead
13:57:10 <xs> s/"s"/s/
13:58:12 * poetix is horribly mangled by a gonad transformer
13:58:22 <tomdavie> there once was a language Haskell
13:58:23 <tomdavie> that sounded a lot like Pascal
13:58:23 <tomdavie> a name that rhymed
13:58:23 * tomdavie put the other in mind
13:58:23 * tomdavie oh why was it not Curry
13:58:25 * tomdavie --- :P - yes I know it's broken
13:58:40 <tomdavie> bah... stupid automated actions script...
14:00:10 <Frederick> I know ml isnt haskell but since you are sparing time drawing cows maybe you can give me a hand... =/
14:00:45 <xs> Frederick: as i said. you at least want to change "s" to s. i've no idea what the problem is.
14:01:50 <Frederick> xs http://rafb.net/paste/results/TyCY2s74.html
14:01:59 <Frederick> but isspace is defined
14:13:12 <Itkovian> evening
14:21:13 * shapr beats Plone with a stick
14:21:33 <aheller> In a good way?
14:21:47 <shapr> Plone frustrates me greatly.
14:22:19 <aheller> I understand.
14:22:48 <aheller> Admittedly, I don't know Zope or CMF, but it would be nice to be able to make it work more easily.
14:32:29 <Lemmih> Tor connections?
14:32:47 <xs> http://tor.eff.org/
14:33:09 <thedward> Lemmih: the onion router http://tor.eff.org/
14:33:15 <Lemmih> Greetings, friend of lscd.
14:33:23 <xs> hehe hello.
14:34:02 * Igloo suggests either banning him or asking the freenode people if they can stop him connecting in the first place
14:35:58 <FrederikEaton> is there a way to do thread-local variables in haskell?
14:36:50 <FrederikEaton> i want to implement something like withArgs or withProgName, but for my own data
14:37:19 <musasabi> FrederikEaton: if you are willing to use your own wrapper for threads then yes.
14:37:24 <musasabi> otherwise it is hacky.
14:38:14 <musasabi> a global IORef (Map ThreadId whatever) will work, but that is ugly.
14:38:20 <TheHunter> implicit parameters?
14:39:13 * lispy grumbles about not being able to access research papers
14:41:17 <Itkovian> lispy: which ones do you need?
14:42:06 <aheller> lispy: After about 3 years of searching, an old prof finally found a copy of a paper I was looking for in a box in his office while he was moving.
14:43:43 <alexj> Igloo: do you have any code examples that use your DES lib?
14:44:10 <musasabi> Getting hold of JFP is hard as the electronic version is not included in many of the deals universities get on electronic versions of journals.
14:44:43 <musasabi> Of course I can just bicycle 12km to read it, but that is not nice when just wanting to check something.
14:48:05 <Igloo> alexj: Not to hand
14:48:08 <Igloo> What's the problem?
14:50:20 <alexj> it seems to work simply by numbers.
14:50:35 <alexj> do I convert a large string into a large integer and then back or use blocks?
14:51:09 <alexj> (also is it DES or triple DES?)
14:54:12 <Igloo> Probably DES, but 3DES is easy to build from that
14:54:29 <Igloo> I'd guess it either wants a list of octets or of 32bit words, but I can't remember now, sorry
14:55:16 <alexj>  :t des_enc
14:55:16 <alexj> des_enc :: HAppS.Protocols.DES.Message
14:55:16 <alexj> 	   -> HAppS.Protocols.DES.Key
14:55:16 <alexj> 	   -> HAppS.Protocols.DES.Enc
14:55:44 <alexj> I assume I have to write code that converts a string into 64bit blocks.
14:56:04 <alexj> that is why I was checking to see if you had example code where you had already done this.
14:56:44 <michaelw> hmm, wasn't there a paper that derived efficient parser combinators through several intermediate steps?
14:57:11 <alexj> aside: are haskell chars 8bit or 16bit?
14:57:39 <michaelw> i remember it was a quite elegant construction, but details escape me :/
14:58:33 <shapr> michaelw: Yeah, I've seen that paper too...
14:59:28 <musasabi> alexj: they are 32bits in theory, but IO uses only the lowest 8 bits.
15:00:38 <alexj> musasabi: so if they come from the outside world I can treat them as 8?
15:04:51 <michaelw> shapr: drats, cannot find it :/
15:08:39 <musasabi> alexj: yes.
15:14:43 <FrederikEaton> musasabi: mapping from ThreadId doesn't sound ugly to me.
15:15:05 <FrederikEaton> TheHunter: yeah I thought of implicit parameters but wouldn't I have to mark up the types for all my functions then? or is it as easy as it should be?
15:20:04 <lispy> aheller: haha, funny
15:20:09 <lispy> and sad....
15:27:13 <FrederikEaton> by the way i want this to hold a database connection, or connection info. that makes sense to do right? you'll have a group of functions that all use the same database so it's annoying to have to pass the connection as a parameter
15:28:19 <musasabi> FrederikEaton: personally I would use one thread to handle database queries and use a Control.Concurrent.Chan (or MVar depending how I would want queing) to send requests.
15:29:18 <musasabi> If there is little concurrency needed a simple MVar + withMVar for the database ops could work too.
15:29:25 <lstna> What does (a -> b) mean?
15:29:52 <FrederikEaton> hmm. well i don't have multiple threads doing queries, at least not yet. i'm just thinking ahead.
15:30:12 <wagle> the rtype of a function that takes a value of some type a, and returns a value of some other type, b
15:30:26 <wagle> s/rtype/type/
15:30:46 <lstna> How would you pronounce that?
15:30:59 <musasabi> FrederikEaton: then just wrap the functionality in a module and start by using the single MVar and withMVar.
15:31:15 <wagle> "a to b"?
15:31:36 <lstna> And this?
15:31:41 <lstna> @type map
15:31:44 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
15:32:19 <Lemmih> "(a to b) to list a to list b" (:
15:32:46 <wagle> a function a to b to a list of a to a list of b
15:33:17 <musasabi> map is a function taking a function from a to b and a list of a as an argument. Map produces a list of b.
15:35:38 <lstna> So the interpretation of -> is position dependant. Sometimes it means "rreturns" sometime sit means "to" and sometimes it's just a separator between multiple arguments?
15:36:11 <TFK> lstna, not really, no.
15:37:09 <TFK> All those interpretations are identical but misleading, although -> is also used in case expressions.
15:37:36 <lightstep> and in kinds
15:37:43 <lstna> Then what is teh correct interpretation? Is this described somewhere I have missed?
15:37:46 <wagle> english is sloppy
15:37:47 <shapr> and in lambda expressions
15:37:59 <TFK> This stuff is difficult :-/
15:38:17 <lstna> So difficult that it cannot be described?
15:38:19 <Lemmih> map is a function taking a function from a to b and produces a function from list a to list b.
15:38:24 <shapr> I think it generally means "evaluates to"
15:38:32 <TFK> lstna, perhaps it's best to think of it as "returns". But "to" is identical. It's not really a separator between multiple arguments, because functions don't take multiple arguments in Haskell.
15:38:55 <lightstep> every function in haskell takes one parameter and produces one result. map takes a function (a -> b), and returns a list function ([a] -> [b])
15:38:57 <TFK> lstna, what happens is that a function takes one argument, and returns a new function, which in turns take another single argument, etc.
15:39:02 <shapr> But it can mean "evaluates to" on both type and code level.
15:39:21 <TFK> so 'map f l' can be written '(map f) l'
15:39:45 <shapr> hiya thaldyron, learning Haskell?
15:39:53 <TFK> lstna, does that make any sense? o_O
15:40:30 <shapr> lstna: For example, in " \x -> x + 1 :: Int -> Int " the first arrow means evaluates to this result, and the second arrow means evaluates to this type.
15:41:05 * TFK listens to shapr
15:41:32 <shapr> lstna: Does that help any?
15:42:25 <shapr> @Wiki HaskellDemo might help explain some stuff.
15:42:26 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo might help explain some stuff.
15:43:27 <lstna> Honestly. Not much. by the "only one argument" rule (a->b)->[a]->[b] ought to be something like (a->b)->([a]->[b])->[b].
15:43:35 <wagle> this is a test @wiki foo 1 2 3
15:43:39 <TFK> Why?
15:43:59 <TFK> ([a] -> [b]) denotes the type of a function that takes a list of a's and returns a list of b's
15:44:11 <wagle> -> associated to the left
15:44:35 <TFK> But the "second" argument is just a list, not a function.
15:45:08 <wagle> a -> b -> c -> d == ((a -> b) -> c) -> d
15:45:24 <lstna> Because if I understood the above, map takes function that maps (a->b) and returns a function that maps ([a]->[b]) which is then passed the [a] and produces the [b].
15:45:31 <wagle> a b c and d are variables
15:45:47 <shapr> lstna: Yeah, that sounds pretty good.
15:46:07 <lstna> But there is no second argument becuas Haskell functions only take one argument?
15:46:09 <shapr> Though nothing really 'returns' in Haskell, it's more about evaluation.
15:46:19 <shapr> Er, huh?
15:46:28 <lightstep> P=NP, but nobody in #math cares
15:46:44 <wagle> [a] -> [b] is the type of a function that takes a list of a's and returns a list of b's
15:47:17 <TFK> lstna, do you have some kind of Haskell interpreter around?
15:47:33 <shapr> @plugs map (+ 2) [1,2,3]
15:47:39 <lambdabot> [3,4,5]
15:47:48 <wagle> ([a] -> [b]) -> [b] is the type of a function that takes a function that takes a list of a's and returns a list of b's, and then returns a list of b's
15:48:57 <wagle> @type map
15:49:03 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
15:49:14 <wagle> @type map (+ 1)
15:49:15 <lambdabot> map (+ 1) :: forall a. (Num a) => [a] -> [a]
15:49:31 <wagle> @type map (+ 1) [1,2,3]
15:49:33 <lambdabot> map (+ 1) [1,2,3] :: forall a. (Num a) => [a]
15:49:41 <lstna> I get what it does wagle. I'm trying to interpret the documentation
15:49:51 <TFK> lstna, which documentation?
15:50:11 <lstna> All of it. Any of it.
15:50:33 <TFK> lstna, well, there's a bit of a difference between The Haskell Report and, well, everything else :-/
15:50:46 <shapr> Have you tried the learning page mentioned in the topic?
15:51:11 <TFK> lstna, what prior programming experience do you have?
15:51:36 <lstna> Lots.
15:51:49 <TFK> Ah, good. Then Gentle should be accessible up to the Monads chapter.
15:51:57 <shapr> Have you used Python, ML, OCaml, or other somewhat functional language?
15:52:11 <shapr> Maybe Scheme, or Lisp?
15:52:34 <lstna> Shapr Yes. and teh Gentle guide and many more. They all use the same diagrams and I would like to be able to read them.
15:53:48 <TFK> shapr, don't ML and O'Caml employ the same currying technique as in Haskell?
15:54:00 <TFK> Don't Lisp and its dialects do that as well?
15:54:27 <shapr> I think ML and OCaml do currying, and I know lisp and kids have map.
15:54:53 <TFK> map is... something o.o
15:54:55 <lispy> in lisp currying must be done explicitly with lambda
15:55:00 <xerox> shapr, you should say "have functions as first-class citizens" :)
15:55:00 <wagle> you can't partially apply arguements in any lisp or scheme i know of
15:55:19 <lament> but you can easily write a partial applier :)
15:55:29 <TFK> I hear that in Scheme you have something called CUT.
15:55:36 <xerox> lament, and then how easily you'll use it?
15:55:46 <wagle> cut?
15:55:54 <lstna> It's not about what map does. It's about being able to interpret the type description of a simple example, so that I can then unerstand those of the more comlex functions
15:56:03 <lament> xerox: i dunno. In Python this would be easy.
15:56:11 <TFK> Which allows to partially apply arguments in arbitrary positions. A Schemer friend told me this, but I never looked into it. Can anyone confirm/deny?
15:56:13 <lament> and i assume, if it's easy in python...
15:56:34 <Philippa_> TFK: don't know, but it'd be a no-brainer to implement
15:56:58 <Lemmih> lstna: Did you see the type of 'map', 'map (+ 1)' and 'map (+ 1) [1,2,3]'?
15:57:02 <TFK> Philippa_, in Python, for example, it's a bit tricky. But he said that in Scheme it's part of the syntax.
15:57:20 <xerox> Which syntax are you talking about? ;)
15:57:27 <Philippa_> quite, sounds like a macro to me
15:57:37 <wagle> i can define a syntactic extension (macro) to do that
15:57:41 <TFK> Well, I'll have to ask him again.
15:58:31 <TFK> lstna, OK, let's see. Do you agree that (a -> b) denotes the type of a function that takes some argument of type 'a' and evaluates to some expression of type 'b'?
15:58:36 <wagle> http://srfi.schemers.org/srfi-26/srfi-26.html
15:59:08 <shapr> lstna: In that case, -> is the type of a function. foo :: (x -> z) means foo wants an x and evaluates to a z. bar :: (x -> z) -> y means bar wants a function with the same type as foo, and evaluates to a y
15:59:42 * shapr listens to TFK 
15:59:52 * TFK shrinks
15:59:57 * shapr explodes
16:00:11 <lstna> shapr: So far so good.
16:00:16 <TFK> o.o;
16:00:17 <lstna> @type map
16:00:19 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
16:00:27 <wagle> watches the pretty fireworks
16:00:41 <TFK> lstna, OK. So map takes a function of the above type, and a list.
16:00:49 <Philippa_> TFK: nearly. -> is a type constructor, not a type
16:01:08 <TFK> But the type of the stuff in the list must be the same as the type of the arguments that the said function takes.
16:01:10 <Philippa_> that is, it's not a well-formed type on its own
16:01:11 <jlouis> tuomov: thanks for ion ;)
16:01:19 <lstna> But above someone said that Haskell functions only take a single arguement
16:01:22 <shapr> tuomov: Yes, thanks for ion
16:01:30 <TFK> That would be me.
16:01:33 <TFK> ^_^;
16:01:45 <jlouis> lstna: yes that is true
16:01:51 <TFK> lstna, it doesn't really matter for our purpose - the effect is the same.
16:01:56 <Philippa_> lstna: yes, they do. OTOH, functions returning functions that take additional parameters is every bit as good as
16:02:19 <lstna> The "So map takes a function of the above type, and a list" ?
16:02:29 <Philippa_> (you just apply the parameters in sequence - in C notation it'd be foo(1)(2)(3) rather than foo(1,2,3) but in Haskell syntax there aren't any parens anyway)
16:02:29 <TFK> Philippa_, ah, thanks for correcting :-)
16:02:42 <TFK> lstna, of type (a -> b), yes.
16:02:45 <lament> it's easier to think about functions as taking many parameters.
16:02:51 <jlouis> it is curried, lstna. So map takes a function f and returns a new function taking a list
16:02:52 <lament> But really, it makes no difference.
16:03:48 <jlouis> it should be named schoenfinkeling, but somehow that name never caught on and curried it ended up being
16:04:05 <TFK> xD
16:06:02 <lstna> so map:: (a->b)->([a]->[b])->[a]->[b] or map is defined as taking a function that maps a to b and returns a function that map a list of as to a list of bs which gets given the list of as and produces the list of bs.
16:06:20 <TheHunter> FrederikEaton, With implicit params, the types of code using the configuration data change, everything else stays untouched. In particular, functions of type |(a -> b) -> c| are automatically converted to |?foo :: Foo => (?foo :: Foo => a -> b) -> c|
16:06:35 <TFK> lstna, the above typing is not how map is defined.
16:07:00 <TFK> lstna, (map f) returns a function that takes a list. ([a] -> [b]) denotes a totally different function.
16:07:01 <lstna> I know. Annoying isn't it.
16:07:11 <TheHunter> FrederikEaton, this is often a considerable simplification wrt a reader monad (transformer) where you have to lift a lot of stuff manually.
16:07:19 <TFK> It takes some time to get used to :-)
16:07:48 <lstna> Cheers.
16:07:56 <TFK> (map f) :: [a] -> [b] -- assuming that f :: a -> b
16:08:23 <xerox> lstna, when you apply arguments to function, they "consume" the type :-)
16:08:32 * Lemmih tries to imagine a function of type :: a -> b
16:08:55 <TFK> Did I screw up? o_O
16:08:56 <Lemmih> Nothing but unsafeCoerce# comes to mind. (:
16:09:01 <xerox> unsafeCoerce# !
16:09:14 <xerox> Lemmih 1, xerox 0.. it's not my day.
16:09:16 <TFK> Lemmih, how about a char to its ascii code?
16:09:28 <shapr> You could have a partially applied function.
16:09:49 <TFK> Or a string to some hash code.
16:09:51 <xerox> TFK, a -> b is too general, that's all.
16:10:04 <TheHunter> FrederikEaton, lambdabot, for example has a function |lbIO :: ((forall a. LB a -> IO a) -> IO b) -> LB b| to be able to lift all IO-functions to their respective LB functions (LB is a ReaderT Something IO), which is very tedious.
16:10:14 * wagle tries to imagine a function of type forall a b . a -> b
16:10:14 <xerox> TFK, but going from _some_ a to _some_ b it surely possible.
16:10:15 <Lemmih> TFK: You didn't screw up. I'm just playing around with my thoughts.
16:10:19 * shapr wanders off to work
16:10:24 <TFK> xerox, but that's the principal type that map defines, no?
16:10:29 <xerox> TFK, now you see, "forall" :-)
16:10:33 <TFK> Ah, OK ^_^
16:10:53 <TFK> I don't know forall. The Gentle doesn't mention forall. My conciense is clear.
16:11:05 <xerox> @type map
16:11:05 <TFK> *clean
16:11:07 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
16:11:15 <jlouis> TFK: it is an extension
16:11:22 <TFK> So I've heard.
16:11:22 <wagle> lambdabot knows something you don't!  8-p
16:11:25 <xerox> meep.
16:11:36 <TFK> wagle, nothing knew there :-/
16:11:39 * TheHunter can think of two safe functions of type forall a b. a -> b.
16:12:14 <jlouis> TFK: when you have something of type, say, a -> Integer, you can quantify over the polymorphic type a. That is: forall a. a -> Integer
16:12:24 <wagle> @type (\f -> (\x -> x x) (\x -> x x))
16:12:26 <lambdabot> bzzt
16:12:32 <wagle> awww
16:12:34 <jlouis> in Haskell98 that is not written explicitly however
16:12:48 <TFK> Yes. I'd rather stick to Haskell 98 for now :-)
16:12:58 <wagle> @type id :: a -> b
16:12:59 <lambdabot> bzzt
16:13:36 * wagle waits for TheHunter to tell all
16:13:53 <wagle> @type undefined :: a -> b
16:13:55 <lambdabot> undefined :: a -> b :: forall a b. a -> b
16:14:03 <jlouis> bingo!
16:14:20 <TheHunter> @type undefined
16:14:22 <lambdabot> undefined :: forall a. a
16:14:24 <TheHunter> @type const undefined
16:14:25 <FrederikEaton> TheHunter: huh so implicit parameters are easier than I'd thought. thanks
16:14:25 <lambdabot> const undefined :: forall a b. b -> a
16:14:49 <Pseudonym> They're not so easy to reason about, though.
16:14:56 * TheHunter tries to type wagle's expression.
16:15:01 <Pseudonym> Actually, what I'd like is compiler support for implicit configuration.
16:15:11 <Pseudonym> They'd make implicit parameters obsolete.
16:15:30 <wagle> @type (\x -> x x) (\x -> x x)
16:15:31 <lambdabot> bzzt
16:15:43 <wagle> @type (\x -> x x)
16:15:49 <TFK> lstna, does that make a little bit more sense now?
16:15:52 <xerox> @type \(x :: forall a. a -> a) -> x x
16:15:52 <Pseudonym> @plugs (\x -> x x) (\x -> x x)
16:15:57 <lambdabot> bzzt
16:15:57 <lambdabot> \(x :: forall a. a -> a) -> x x :: forall a.
16:15:57 <lambdabot>             (forall a1. a1 -> a1) -> a -> a
16:15:59 <xerox> :-)
16:16:01 <lambdabot> Occurs check: cannot construct the infinite type: t = t -> t1
16:16:01 <lambdabot>    Expected type: t
16:16:01 <lambdabot>    Inferred type: t -> t1
16:16:35 <xerox> This is valid \(x :: forall a. a -> a) -> x x, but I don't know if it's meaningful.
16:17:12 <FrederikEaton> Pseudonym: huh? not really the same, if I understand correctly. for instance some of this stuff comes from the command line - not known at compile time
16:17:14 <wagle> Y
16:17:30 <Pseudonym> @type \(f :: forall a. a -> a) -> (\(x :: forall b. b -> b) -> f (x x)) (\(x :: forall b. b -> b) -> f (x x))
16:17:32 <lambdabot> bzzt
16:17:51 <Pseudonym> Sorry?
16:17:57 <Pseudonym> What's the command line got to do with it?
16:18:02 <monochrom> @type const id
16:18:03 <lambdabot> const id :: forall a b. b -> a -> a
16:18:33 <wagle> @type const
16:18:34 <lambdabot> const :: forall a b. a -> b -> a
16:19:34 <wagle> Y -> K
16:20:32 <xerox>     Couldn't match the rigid variable `b' against `t -> t1' `b' is bound by the polymorphic type `forall b. b -> b'
16:21:01 <xerox> By the way, goodnight.
16:22:19 <shapr> g'night!
16:22:22 <TheHunter> Pseudonym, by "compiler support for implicit configuration", you mean the proposal from the implicit configuration paper?
16:22:26 <Pseudonym> Night.
16:22:26 <TheHunter> night, xerox
16:22:28 <Pseudonym> Right.
16:22:33 <Pseudonym> That's what I mean, yes.
16:22:56 <shapr> lstna: More questions?
16:23:11 <wagle> gnite
16:23:30 <Pseudonym> You need compiler support because doing it with serialisation is ugly and inefficient, and doing it without garbage collection is potentially dangerous,.
16:23:37 <Pseudonym> All described in the paper.
16:23:46 <FrederikEaton> so does 'do {t<-myThreadId; return $ unsafePerformIO myThreadId == t}' always return True?
16:24:14 <Pseudonym> I don't think that behaviour is specified.
16:24:21 <TheHunter> i remember thinking about the connection between the implicit configuration paper and implicit parameters, but i'm afraid i've forgotten my conclusions :/
16:24:23 <Pseudonym> But it probably always returns True.
16:24:36 <Pseudonym> Oh, well if you think about a conclusion, please let me know. :-)
16:24:47 <Pseudonym> See, I think you can simulate it with MPTCs and fundeps.
16:25:18 <Pseudonym> class Configuration tag v | tag -> v where
16:25:39 <Pseudonym>     reify :: tag -> v
16:25:44 <lispy> huh, something on my computer told me it had up dates and "click here to view" and it disappeared in less time than it takes to get the mouse to the link...wonderful
16:26:08 <Pseudonym> Yay for Fitz' law.
16:26:21 * lispy suspects it was firefox, since it's always making things disappear before i can get the mouse there
16:26:24 <shapr> if the shou fitz?
16:26:25 <lispy> fitz?
16:26:32 <Pseudonym> @google fitz law
16:26:34 <lambdabot> http://en.wikipedia.org/wiki/Fitt's_Law
16:26:37 <Pseudonym> Ah.
16:26:41 <Pseudonym> Fitt's Law, then.
16:27:08 <Pseudonym> Or Fitts' Law.
16:27:14 <lispy> oh
16:27:17 <lispy> that
16:27:32 <lispy> yeah, yay for fitts' law....
16:27:34 <lispy> :)
16:27:52 <Pseudonym> Now if the button had been huge...
16:28:01 <Pseudonym> Could have made it in no time!
16:28:19 <lispy> actually i saw a cool cursor based on fitts' law
16:28:28 <lispy> the cursor resized to always be close to something
16:28:33 <Pseudonym> Oh, cool.
16:28:45 <jlouis> someone in here mentioned a certain paper about Haskell optimization by karlsen
16:28:46 <Pseudonym> I saw a toolbar based on a similar principle.
16:28:51 <lispy> it was bubble shapped and it resized so that it was always surrounding exactly one target
16:29:00 <Pseudonym> Oh, yes, I saw that too.
16:29:01 <jlouis> anybody know where it is? google is not turning up anything for me
16:29:43 <lispy> Pseudonym: the only problem was when you want to click on something that it doesn't consider to be a "target" like the dead space
16:29:55 <lispy> but if you had a modifier key it would be perfectly fine
16:30:27 <lispy> maybe if you hit ctrl the cursor shrinks back down to normal size
16:32:24 <lispy> someone needs to hack it into gnome and see if people would actually use it
16:33:13 <shapr> I'd use it.
16:34:05 <TheHunter> i'm beginning to recall things. I think the issue I had with it is that the implicit configuration information is tied to values (as in the modular arithmetics example). Implicit parameters solve a different problem, namely how to distribute configuration information that is needed by functions we are calling and can't be attached to any value we pass down.
16:34:49 <Pseudonym> OK, so how is this different from implicit parameters?
16:35:38 <lispy> shapr: yeah, me too
16:35:48 <TheHunter> doSomething :: (?conf :: Conf) => Int -> IO (). I don't see how you could do that with implicit configuration.
16:36:37 <Pseudonym> doSomething :: (Configuration ConfTag Conf) => Int -> IO ()
16:36:39 <Pseudonym> ?
16:36:48 <Pseudonym> Using the Configuration class I mentioned above.
16:36:50 <TheHunter> this is rejected.
16:37:00 <Pseudonym> Oh, hmmm.
16:37:01 <Pseudonym> I see.
16:37:27 <Pseudonym> So you also need an explicit parameter.
16:37:39 <Pseudonym> class Configuration env tag v | env tag -> v where
16:37:47 <Pseudonym>     reify :: env -> tag -> v
16:37:51 <TheHunter> in which you can pass the configuration information anyway.
16:38:00 <FrederikEaton> reading implicit configuration paper
16:38:08 <Pseudonym> doSomething :: (Configuration env ConfTag Conf) => env -> Int -> IO ()
16:38:15 <Pseudonym> Right.
16:39:21 <TheHunter> implicit configurations are still very useful, but they seem to solve a different problem.
16:42:06 <TheHunter> sadly, the type hackery involved is quite deterring.
16:46:11 <Pseudonym> The problem is, I've never actually seen any code that uses implicit parameters.
16:46:19 <Pseudonym> So I have no idea what a "typical use" is.
16:48:56 <Philippa_> all the uses I've seen have been sick and depraved and not in the sort of way I write columns about
16:50:07 <TheHunter> i actually wanted to use it at one point in lambdabot, but I don't remeber what for.
16:50:41 <lambdabot> Thank goodness for that.
16:50:45 <TheHunter> currently I don't see why there's more to it than attaching a value to a type.
16:50:52 <lambdabot> I don't want my innards rotted, thankyou.
17:04:14 <lispy> uh, did lambdabot just talk smack to you?
17:07:00 <shapr> sure looks like it
17:07:16 <lambdabot> Damn straight.
17:07:33 * shapr lays off the catnip, too many hallucinations
17:12:26 <Pseudonym> Goodness.  Paul Winchell AND John Fielder died within a day of each other.
17:12:35 <Pseudonym> This has nothing to do with Haskell, you understand.
17:32:40 <lispy> when i get to a page like this, which link takes me to the document? http://portal.acm.org/citation.cfm?id=54984
17:33:00 * lispy finds the acm portal "hard to use" at best
17:33:12 <shapr> lispy: if you don't have a subscription, none of the links :-P
17:33:32 <lispy> ah
17:33:46 <lispy> that's annoying :)
17:33:54 <shapr> Yeah, acm suxxors
17:33:56 <lispy> a lot of these older papers are not on websites
17:34:03 <shapr> That's right.
17:34:12 <Pseudonym> I have a subscription and it's not there for me either.
17:34:23 <Pseudonym> I think it's on ly there because it's cited by a true ACM paper.
17:34:41 <shapr> I get irritated about papers that my taxes funded, but I still can't read.
17:34:42 <Pseudonym> Did you try Google Scholar?
17:34:53 <Pseudonym> Probably no help, but it's worth a tru.
17:34:54 <Pseudonym> try
17:34:59 <lispy> Pseudonym: as opposed to just google?
17:35:04 <Pseudonym> Right.
17:35:12 <Pseudonym> Google scholar has less noise.
17:35:12 * lispy has to catch a bus, then he'll try that
17:35:21 <Pseudonym> If that's what you're looking for.
17:35:27 <Pseudonym> OK.  Go get your bus.
17:38:00 <Lunar^> http://lkwiki.nomeata.de/index.cgi?WroteItInHaskell
17:38:40 <Pseudonym> Anyone else read the Joel Spolsky article linked to from LtU?
17:41:01 <Trevion> I did.
17:41:29 <shapr> I read the responses. I think Joel is often completely clueless.
17:41:30 <Pseudonym> Typical imperative programmer, trying to find a programmer solution for a type problem.
17:42:09 <Trevion> reminds me of most of the people in my department at school.
17:42:10 <shapr> Lunar^: cute!
17:43:35 <shapr> Pseudonym: did you ever see the discussion on extremeperl?
17:44:03 <Pseudonym> Nope.
17:44:05 <Pseudonym> Where is that?
17:44:33 <Pseudonym> (Never heard of extremeperl, but it sounds like a lot of people would be saying "Regular expression!  Dude!  Wicked!"
17:44:50 <Pseudonym> "Gnarly, man!"
17:45:52 <shapr> http://groups.yahoo.com/group/extremeperl/message/223
17:46:49 <shapr> Just thinking of unchanging people, the extremeperl guy does not want to investigate new ways outside of what he knows.
17:47:04 <Pseudonym> That's a good point.
17:47:22 <Pseudonym> Yeah, well.  I assume you've read the MJD article on advocacy.
17:47:45 <Pseudonym> Always point Perl programmers there.
17:47:49 <Pseudonym> :-)
17:47:59 <shapr> Well, this guy said that if he needed FP or Logic programming, he'd write it himself in Perl.
17:48:32 <Pseudonym> OK, go ahead.  I'll wait here while you do that.
17:49:10 <shapr> I tried to show him how HaskellDB's higher order queries did more than his Perl sql generator, but he didn't respond to that thread.
17:49:34 <Trevion> There was a guy in my department who firmly believed that all problems in computer science could be solved in C++ using some combination of iterators, circular doubly-linked lists, and red-black trees.
17:50:08 <Trevion> I think we managed to get him to take over the freshman writing program and stop teaching CS, though.
17:50:21 <shapr> I get tired of dealing with people who fit the facts to their conclusion rather than the other way around.
17:51:08 <Pseudonym> The guy is wrong.  All problems CAN be solved in C++, but only by introducing another layer of indirection.
17:51:22 <Pseudonym> You can never have enough indirection in C++.
17:54:25 * SyntaxNinja writes shell script to call C++, solving all problems
17:54:36 <Trevion> We FPers thought so too, but there weren't very many of us at Dartmouth.
17:58:02 <Pseudonym> Personally, I think the problem is that people use type synonyms too much.
17:58:23 <Pseudonym> Ideally, types should be what they are.  No more, no less.
17:58:24 <Trevion> They fired the only prof. who taught programming languages and liked FP a year ago, and haven't replaced him yet.  I found an emeritus to oversee my thesis, and got out just in time.
17:59:32 <wagle> wehats PLAI and TAPL?
17:59:44 <wagle> whats..
17:59:48 <Pseudonym> The second is Types And Programming Languages by Benjamin C. Pierce.
18:00:11 <Pseudonym> Not sure about PLAI.
18:01:05 <Trevion> Google says it's Programming Languages: Application and Interpretation.  Appears to be based on Scheme, but I've never run into it personally.
18:01:11 <Pseudonym> Right.
18:02:32 <wagle> huh..  three scheme books and a types book
18:02:55 <Pseudonym> That's an interesting combination for solving what is essentially a typing problem.
18:02:55 <Trevion> can't speak for the others, but I really like SICP.
18:03:08 <Pseudonym> I agree, but I don't think it would help Joel.
18:03:15 <Pseudonym> Not for this problem, anyway.
18:03:37 <wagle> oh, i like sicp and eopl
18:03:44 <wagle> starting on tapl
18:03:57 <shapr> tapl is cool
18:04:05 <wagle> i've wanted eopl for haskell
18:04:08 <Pseudonym> TAPL is trez cool.
18:06:38 <Pseudonym> Has anyone read Semantics of programming languages : structures and techniques by Carl Gunter?
18:06:46 <Pseudonym> Saw this in the library yesterday, curious if it's good or not.
18:07:12 <wagle> seemed good, but havent dne more than skim it
18:07:16 <wagle> dne
18:07:17 * Pseudonym nods
18:07:20 <wagle> done
18:07:31 <wagle> hmm..  my o key seems to be in trouble
18:07:40 <Pseudonym> I'm curious as to whether I should read that or John Reynolds' "Theories of programming languages".
18:07:55 <Pseudonym> (Probably both, but which one to read NEXT is the problem.)
18:08:10 <wagle> shortest job first
18:08:31 <shapr> I always do the hardest job firstr.
18:08:35 <shapr> Then all the others are easy.
18:08:38 <Pseudonym> Yeah, but if someone can definitively state that one of them is a waste of effort...
18:08:48 <Pseudonym> Then that settles the matter.
18:09:37 <Trevion> Hmm.  I'm reading the PDF version of PLAI, and he seems to start by extending Scheme with algebraic data types and a type-case expression.
18:09:50 <Trevion> So it might not be as horribly irrelevant as it seems.
18:11:29 * shapr falls over asleep
18:11:58 <wagle> huh..  that seems to be a different reynolds book than the one i was thinking of..
18:12:07 <Pseudonym> Night shapr.
18:14:03 <wagle> its table of contents looks more interesting that what i remember
18:15:52 <Pseudonym> I thought it looked interesting too.
18:16:11 <Pseudonym> I think I'll go with the Gunter one.
18:16:19 <Pseudonym> I understand categorical semantics less than I think I should.
18:16:31 <wagle> what was recommended to me was Foundations for Programming Languages by John Mitchell
18:16:49 <wagle> (which covers the categorical semantics)
18:20:18 <Pseudonym> I'll make a note of that, thanks.
18:24:15 <Pseudonym> What I really need, I think, is a few examples explaining why categorical semantics are superior to the alternatives.
18:24:20 <Pseudonym> e.g. denotational semantics
18:24:28 <Pseudonym> I believe the reason is related to modularity.
18:24:34 <Pseudonym> Categorical semantics scale up better.
18:26:18 <wagle> i needed non-well-founded set theory for semantics of reflective languages, but wonder if just getting even less concrete (with categories) would be better
18:26:45 <wagle> but i've never actually _seen_ anyone do either
18:29:55 <lstna1> What does '*' represent in a type definition? (And wher will I fond it documented, it's kind of hard to search for!)
18:30:07 <Pseudonym> It's a kind.
18:30:27 <Pseudonym> Kinds are the types of types.
18:30:32 <Pseudonym> For example, take Maybe.
18:30:39 <Pseudonym> Maybe isn't a type, but Maybe Int is.
18:30:41 <Trevion> (and sometimes, they meet Christmas trees)
18:30:52 <Pseudonym> With me?
18:31:32 <dons> @kind Int
18:31:34 <lambdabot> Int :: *
18:31:36 <dons> @kind Int -> Int
18:31:37 <lambdabot> Int -> Int :: *
18:31:41 <lstna1> Kind of. Like IO a is a type but IO isn't?
18:31:46 <dons> @kind Int#
18:31:48 <lambdabot> bzzt
18:31:55 <Pseudonym> Right.
18:31:55 <dons> @kind GHC.Base.Int#
18:31:57 <lambdabot> GHC.Base.Int# :: #
18:32:00 <wagle> Pseudonym: Liang had the modular interpreters with monad transforms, but the only followup work i've seen is by William Harrison
18:32:02 <Pseudonym> dons: Nice!
18:32:15 <Pseudonym> Anyway, Int has kind *, because it's a type.
18:32:19 <dons> @kind Just
18:32:20 <lambdabot> bzzt
18:32:23 <wagle> @kind *
18:32:25 <lambdabot> bzzt
18:32:30 <Pseudonym> But Maybe needs to be applied to a type.
18:32:34 <wagle> @kind ->
18:32:35 <lambdabot> bzzt
18:32:36 <Pseudonym> So it has kind * -> *
18:32:39 <wagle> @kind (->)
18:32:40 <Pseudonym> @kind (->)
18:32:40 <lambdabot> (->) :: ?? -> ? -> *
18:32:42 <lambdabot> (->) :: ?? -> ? -> *
18:32:45 <Pseudonym> Hmmm.
18:32:48 <Pseudonym> @kind Maybe
18:32:49 <lambdabot> Maybe :: * -> *
18:32:53 <Pseudonym> There you go.
18:33:05 <wagle> Just is a constructor
18:33:06 <Pseudonym> You give it a type and it returns a type.
18:33:09 <Pseudonym> @kind IO
18:33:11 <lambdabot> IO :: * -> *
18:33:14 <dons> ?? and ? are magic kinds in ghc
18:33:18 <Pseudonym> Ah.
18:33:31 <dons> let me find the defn...
18:33:32 <wagle> @kind ?
18:33:33 <lambdabot> bzzt
18:33:44 <wagle> @type ?
18:33:46 <lambdabot> bzzt
18:33:49 <dons> no no.
18:33:52 <Lunar^> @kind Arr
18:33:53 <wagle> @magic ?
18:33:53 <lambdabot> Unknown command, try @listcommands.
18:33:54 <lambdabot> bzzt
18:34:04 <wagle> @magick ?
18:34:05 <lambdabot> Unknown command, try @listcommands.
18:34:10 <wagle> heh
18:34:18 <Pseudonym> @kind Control.Monad.State.StateT
18:34:20 <lambdabot> Control.Monad.State.StateT :: * -> (* -> *) -> * -> *
18:34:25 <dons> There's a little subtyping at the kind level:
18:34:25 <dons> 		 ?
18:34:25 <dons> 		/ \
18:34:26 <dons> 	      ??   (#)
18:34:29 <dons> 	     /  \
18:34:31 <dons>             *   #
18:34:34 <dons> where	*    [LiftedTypeKind]   means boxed type
18:34:36 <dons> 	#    [UnliftedTypeKind] means unboxed type
18:34:39 <dons> 	(#)  [UbxTupleKind]     means unboxed tuple
18:34:41 <dons> 	??   [ArgTypeKind]      is the lub of *,#
18:34:42 <Pseudonym> @kind Control.Monad.RWS.RWST
18:34:43 <lambdabot> Control.Monad.RWS.RWST :: * -> * -> * -> (* -> *) -> * -> *
18:34:44 <dons> 	?    [OpenTypeKind]	means any type at all
18:34:53 <wagle> eep!  tabs dont render!
18:34:57 <dons> sorry.
18:35:02 <Pseudonym> I think that's the most complex kind in the hierarchical libraries.
18:35:13 <Pseudonym> But I could be wrong.
18:35:17 <dons> nice :)
18:35:27 <dons> there's nothing in Generic?
18:35:32 <Pseudonym> Possibly.
18:35:59 <Pseudonym> Anyway, lstna1, do you understand now?
18:36:55 <lstna1> Truthfully. Not a word. /me sliks back to TGI in hope that they explain it somewhere :(
18:37:03 <Pseudonym> Let me try again.
18:37:09 <Pseudonym> You know that IO isn't a type, but IO a is.
18:37:14 <dons>         error :: forall a:?. String -> a
18:37:48 <Pseudonym> IO is like a curried function.
18:37:54 <Pseudonym> You give it a type, and it returns a type.
18:38:02 <Pseudonym> Does that make sense?
18:39:16 <lstna1> It casts one type to another?
18:39:44 <Pseudonym> No.
18:40:05 <Pseudonym> You know how currying works?
18:40:11 <Pseudonym> f :: A -> B -> C
18:40:14 <Pseudonym> f a :: B -> C
18:40:16 <Pseudonym> f a b :: C
18:40:21 <Pseudonym> Right?
18:40:35 <lstna1> Yes.
18:40:39 <Pseudonym> OK.
18:40:47 <Pseudonym> Well you can think of IO having a "type" of sorts.
18:40:51 <Pseudonym> This type is called a "kind".
18:40:56 <Pseudonym> IO :: * -> *
18:40:58 <Pseudonym> IO Int :: *
18:41:45 <Pseudonym> Similarly: data Map k v = ...
18:41:49 <Pseudonym> Then Map :: * -> * -> *
18:41:53 <lstna1> So, IO is a function that takes something of some type and returns something of (possibly another) type?
18:41:55 <Pseudonym> Map String :: * -> *
18:41:58 <Pseudonym> Map String Int :: *
18:42:08 <Pseudonym> Right.  You can think of it that way.
18:42:21 <Pseudonym> But it's at the TYPE level, not the level of Haskell functions.
18:42:31 <lstna1> But can't all functions do that?
18:42:41 <Pseudonym> No, this is at the type leve.
18:42:43 <Pseudonym> level
18:42:46 <lstna1> Nope. You lost me.
18:42:55 <Pseudonym> IO isn't actually a Haskell function.
18:43:06 <Pseudonym> You can't say: IO 42
18:43:32 <lstna1> because?
18:43:38 <Pseudonym> Because IO isn't a function.
18:43:42 <Pseudonym> You can't pass it a value.
18:43:53 <Pseudonym> Haskell actually has two languages embedded in it.
18:43:57 <dons> value level | type level | kind level
18:44:07 <Pseudonym> OK, three. :-)
18:44:15 <Pseudonym> At the value level you have functions which you can pass values to.
18:44:26 <Pseudonym> Then you have the type level where you have types and type operators (which are analogous to functions).
18:44:39 <Pseudonym> IO is a type operator.  You give it a type and it returns a type.
18:44:49 <lstna1> An example of a type operator?
18:44:50 <Pseudonym> You can't pass a value to IO, only a type.
18:45:18 <Pseudonym> It makes sense to say IO Int, but it doesn't make sense to say String Int.
18:45:35 <Pseudonym> And that's what kinds are for: To help types make sense.
18:45:47 <dons> Maybe String is another example. Maybe takes a type argument.
18:45:53 <Pseudonym> Right.
18:46:18 <lstna1> But what does IO Int mean/do? What are you asking the IO to do when you pass it the type Int?
18:46:26 <Pseudonym> IO Int is a type.
18:46:39 <Pseudonym> You can make a Haskell function foo :: String -> IO Int
18:46:56 <Pseudonym> So you can make values of type IO Int and pass them around to functions.
18:47:00 <Pseudonym> You can't make values of type IO.
18:47:08 <Pseudonym> Because IO isn't a type, but IO Int is.
18:47:10 <dons> so to work out which types have arguments, and which don't, we have kinds.
18:47:13 <dons> @kind IO
18:47:14 <lambdabot> IO :: * -> *
18:47:16 <dons> @kind IO Int
18:47:17 <lambdabot> IO Int :: *
18:49:01 <lstna1> Thanks. Back to TGI.
18:49:21 <Pseudonym> What's TGI, by the way?
18:49:33 <lispy> thank goodness it's
18:49:42 <lispy> ;)
18:49:48 * Pseudonym laughs
18:49:51 <lispy> Pseudonym: i tried google scholar but not much luck
18:49:59 <Pseudonym> OK, it was worth a try.
18:50:05 <lispy> definetly
18:50:16 <lispy> and i will try there first the next time i'm looking for a paper
18:50:37 <Pseudonym> Citeseer is also good, of course.
18:50:43 <Pseudonym> But you knew that.
18:51:00 <lispy> i usually end up at citeseer from google :)
18:51:01 <lstna1> The Gentle Intro?
18:51:07 * lispy is a google fan
18:51:23 <Pseudonym> Ah, right.
18:51:32 <Pseudonym> Guess it's not gentle enough when it comes to kinds.
18:51:57 <lispy> i've often heard the comment that it's a misnormer
18:52:02 <lispy> er misnomer
18:52:50 * lispy suspects that the problem is learning is not easy
18:53:58 <lispy> can anyone give me an example of a two level grammar that i may already be familiar with?
18:54:11 <lispy> or perhaps an example of something which is not a two level grammar
18:54:22 <lstna1> Normally I find learning easy and fun.
18:54:44 * lispy finds a nice website on the subject
18:54:46 <Pseudonym> lispy: Algol?
18:54:52 <lispy> lstna1: that is a healthy attitude
18:54:56 <Pseudonym> That's the usual example.
18:55:05 <lispy> Pseudonym: okay, i'm not familiar with it, but i'll read up
18:55:20 <Pseudonym> So if it's not easy and fun, then obviously you're not learning something challenging enough. :-)
18:55:20 <wagle> two level grammar?
18:55:26 <Pseudonym> Sorry, if it _is_ easy and fun.
18:55:52 <lispy> "Two-level grammars are Turing-powerful."
18:56:10 <lispy> wagle: http://www.cs.wpi.edu/~jshutt/adapt/2level.html
18:56:51 <wagle> already found that..  it doesnt really explain
18:57:34 <wagle> oh type 0 is turing
18:57:35 <lstna1> I have a good memory. If I don't remember something itself, I remember where I saw it. That's only useful if the information is available.
18:59:34 <lispy> wagle: if you have a better link then please, share it :)
19:02:55 <wagle> hsi guess you read his thesis
19:03:18 <wagle> i guess you read his thesis
19:03:25 <lispy> no
19:03:33 <lispy> butmaybe i should :)
19:03:46 <wagle> http://www.xrce.xerox.com/competencies/content-analysis/fssoft/docs/twolc-92/twolc92.html looks interesting
19:04:01 <wagle> read future, not read past-tense
19:04:23 <wagle> i guess one reads his thesis
19:05:25 <wagle> ugh
19:05:31 * wagle kicks tyhe english language
19:05:54 <lispy> oh, read vs read
19:05:57 <lispy> now i get it
19:06:10 <wagle> reed vs red
19:06:22 <lispy> my get-tinyurl function stopped working
19:06:26 * lispy curses emacs
19:06:58 <lstna> Sorry if I missed a reply. Is it fair to say that kinds are type classes?
19:07:46 <lstna> Or am I mixing apples and eggs again?
19:08:29 <lispy> iirc kinds are for reasoning about classes of types
19:08:33 <lispy> or types of types
19:08:40 <lispy> but type class already has a meaning
19:08:55 <lispy> so i guess we need a different phrase
19:11:00 <lstna> I was reading the stuff in tgi about type classes (Eq) and that leads directly to a bit about kinds--I guess I need to read more slowly!
19:36:37 * lispy experiences his first real bug in sawfish
19:36:40 <thedward> When you request the type of an expression with :t, what is the difference between when it uses a and b versus when it uses a and a1?
19:37:00 <lispy> thedward: nothing
19:37:11 <lispy> thedward: think of them as place holders for types
19:37:22 <lispy> and the names are chosen by the compiler
19:37:42 <lispy> @type when
19:37:44 <lambdabot> bzzt
19:37:52 <lispy> @type Monad.when
19:37:53 <lambdabot> Monad.when :: forall (m :: * -> *).
19:37:53 <lambdabot>      (Monad m) =>
19:37:53 <lambdabot>      Bool -> m () -> m ()
19:37:57 <thedward> well, basically I was asking why it would sometimes choose b and sometimes a1
19:38:00 <lispy> okay, that doesn't help...
19:38:17 <lispy> thedward: you'd have to trace the type inference algorithm to figure that out :)
19:38:46 <thedward> eh, it isn't really that important so long as I know it isn't a relevant difference
19:38:54 <lispy> right
19:39:27 <lispy> if it uses b and a1 when you expect just b, that may be worth investigating
19:39:42 <lispy> otherwise the particular name it uses doesn't mean anything
19:40:33 * thedward nods
19:40:37 <lispy> but i generally have the other problem
19:40:51 <lispy> that i've restricted the type of something without realizing
19:54:00 <thedward> huh. wow. I made ghci segfault
19:58:34 <thedward> adding 'module Main' seemed to fix it.
20:01:09 <dons> segfault! what OS?
20:01:17 <reffie> ghci.segfaulted.com
20:01:44 <thedward> linux
20:01:51 <thedward> (ppc)
20:03:14 <dons> ok. that's a more unstable ghci anyway.
20:04:11 <thedward> are executables so large on all architectures, or is that a ppc thing?
20:05:10 <dons> define large?
20:06:00 <lispy> thedward: what type of ppc? is this a mac?  If so i'm curious what you think about the linux compatibily with the hardware and which distro you use
20:06:14 <lispy> dons: small < large :)
20:06:22 <thedward> >4MB for tiny programs
20:06:23 <dons> thank you lispy ;)
20:06:31 <lispy> dons: no problem ;)
20:06:35 <dons> oh. that's unusual.
20:06:39 <thedward> lispy: I run Debian on a "dual usb" iBook
20:06:41 <dons> more like 200k on linux/x86
20:06:50 <dons> you wouldn't have splitobjs for one.
20:06:57 <lispy> thedward: they don't the dual usb anymore do they?
20:07:02 <dons> tedward. what size after you run 'strip' on the binary?
20:07:20 <thedward> lispy: nope, and the new ones have unsupported (under linux) wireless
20:07:28 <thedward> you can't get them on ebay though
20:07:52 <lispy> thedward: ah okay, thanks
20:08:14 <thedward> dons: still up around 3MB
20:08:35 * lispy has been considering being a new ibook, but he knows the temptation to run linux on it would be very great
20:08:45 <thedward> darcs is 9.5MB
20:08:49 <lispy> thedward: what is your program?
20:08:57 <lispy> thedward: can you give us an example
20:09:27 <thedward> how do I use the pastebot thing?
20:09:29 <lispy> darcs is 5.5MB on my system
20:09:33 <dons> you could ask on glasgow-haskell-users@ why ppc sizes are so large?
20:09:43 <dons> paprika$ du -hs `which darcs`
20:09:44 <dons> 8.3M    /usr/local/bin/darcs
20:09:59 <dons> however, linux/x86:
20:09:59 <dons> pill19$ du -hs `which darcs`
20:10:00 <dons> 592K    /home/pls/bin/darcs
20:10:09 <dons> split-objs
20:10:14 <thedward> split-objs?
20:10:24 <lispy> dons: my measurement was linux/x86
20:10:32 <dons> without split objs, I guess
20:10:35 <lispy> oh right
20:10:42 <lispy> didn't see tah
20:10:44 <dons> ghc needs to be compiled for it. SplitObjs=YES
20:11:13 <dons> thedward, a system for splitting libraries up into lots of tiny piieces, so only the minimal amount of code is linked.
20:11:14 <lispy> what does that do roughly?
20:11:14 <thedward> the debian/x86 version appears to be around 2.4MB
20:11:37 <dons> oh, sorry. my darcs size was wrong.
20:11:40 <thedward> dons: ah, excellent; that makes sense. basically just adds the needed parts instead of chunking the whole thing in?
20:11:41 <dons> that's my *wrapper* over darcs.
20:12:02 <lispy> what do you need a wrapper for?
20:12:05 <dons> pill19$ du -hs `which darcs.real`
20:12:05 <dons> 4.2M    /home/pls/bin/darcs.real
20:12:18 <dons> it sends mail to a commit msg list
20:12:25 <lispy> ah
20:12:32 <lispy> how well does it work?
20:12:36 <dons> very well :)0
20:12:45 <lispy> does it tell you which files have changed?
20:12:57 <dons> darcs get http://www.cse.unsw.edu.au/~dons/code/darcs-mail
20:13:05 <dons> yes.
20:13:09 <dons> it uses whatsnew -s output
20:13:10 <lispy> ah, cool
20:13:27 <dons> it works for remote pushes only though.
20:13:46 <lispy> i se
20:13:49 <dons> i.e. central repo, and a number of developers working on their own machines.
20:13:56 <lispy> right
20:14:20 <lispy> darcs needs prerecord and postrecord script hooks
20:14:34 <thedward> yes. it does.
20:14:37 <dons> I think it's getting them
20:14:48 <lispy> who is working on it?
20:14:51 <thedward> darcs is actually one of the big reasons I started learning Haskell again
20:15:05 <lispy> i mentioned to igloo that i might do it and he said it sounded good to him :)
20:15:07 <thedward> they tried to teach it to me in school, but did an awful job, and it traumatized me
20:15:34 <lispy> but alas, i haven't written any darcs code lately
20:15:44 <lispy> i wrote some last week, but i don't think they wanted my patch
20:16:14 <dons> don't worry, i've had darcs patches rejected too :)
20:16:15 <lispy> i found that long patch descriptions are confusing to create because of the instructions it gives you
20:16:25 <lispy> oh, what did they do?
20:16:34 <lispy> (so i know not to submit similar)
20:16:51 <dons> it was back around 0.9.10 or so, and people just suggested better solns on the mailing list
20:17:16 <lispy> i probably should have asked on the mailling list if anyone liked my features first
20:17:43 <dons> it's good to define a problem, suggest a couple of solns, then see if other people agree there is a problem.
20:18:08 <lispy> i changed ***DARCS*** to ***END OF DESCRIPTION*** and then changed it so that the EOD marker can appear anywhere in the buffer and it terminates the description. (currently ***DARCS*** must start the line, and I find that confusing )
20:18:16 <lispy> yeah
20:18:26 <lispy> i used #darcs for that instead of the mail list
20:18:36 <lispy> but on one responded when i sent in the patch
20:18:51 <dons> but maybe that breaks backwards compatibility a lot?
20:19:12 <lispy> it won't affect a repo, but it may affect external tool
20:19:20 <dons> okk
20:19:33 <lispy> everything after ***DARCS*** gets discarded and is never used by darcs for anything
20:20:08 <lispy> maybe i should ask if anyone thinks its a good idea :)
20:20:23 <lispy> i personally think ***DARCS*** isn't a very descriptive marker
20:24:47 <thedward> the more I learn Haskell, the cooler I think it is.
20:24:54 <thedward> the type system just blows my mind.
20:24:55 <monochrom> yes
20:25:03 <lispy> yeah
20:25:08 <lispy> it's grown on me
20:25:16 <lispy> at first i would groan about it
20:25:20 <lispy> but now i find it useful
20:25:54 <thedward> I've finally written a (short) program without getting type errors. :)
20:26:08 <dons> cooll :)
20:26:24 <lispy> congrats
20:26:32 <lispy> now, you're ready to start hacking on lambdabot ;)
20:26:52 <lispy> dons: where do you find your free time to hack on stuff?
20:27:02 <lispy> does your advisor give you time?
20:27:12 <dons> um... sort of maybe ;)0
20:27:17 <lispy> hmm...
20:27:29 <dons> luckily, we do a lot of open source stuff here anyway
20:27:36 <lispy> my advisor only gives me time for hacking if it's extending or bug fixing on one of her projects :(
20:27:37 <dons> and are involved in the community projects
20:27:46 <lispy> that's cool
20:27:52 <lispy> that's really cool
20:28:21 <lispy> as a school we only acknowledge FOSS if it gains us something
20:28:37 <dons> our research group is strongly pro-open source, so that helps a lot
20:28:49 <lispy> many students think it's great, but the faculty doesn't really think much of it
20:28:57 <dons> all the haskell projects are gettable by darcs, for example
20:29:07 <lispy> yeah, i like taht
20:29:16 <dons> it's one of the conditions of my phd that I make all source available under an open source license :)
20:29:16 <lispy> i'm pushing to exterminate cvs within our group
20:29:27 <lispy> WOW
20:29:36 <lispy> my advisor was bragging about getting patent
20:29:37 <lispy> :(
20:30:05 <ozone> dons: GPL or BSD? :)
20:30:17 <dons> either would be fine, ozone.
20:30:22 <dons> patrykz goes for BSD
20:32:05 <ozone> as do i
20:32:30 <lispy> BSD is less infectious, but also less idealistic
20:32:39 <ozone> yay!  license war!
20:32:46 <lispy> heh
20:32:50 <lispy> i don't mean to troll
20:33:09 <monochrom> better than homework rants
20:33:13 <lispy> i default to GPL but i like to know why others choose BSD
20:33:19 <dons> I think we should write license- battle-code, where programs attempt to license each other!
20:33:53 <lispy> hmm...
20:34:07 <lispy> maybe we could make it a plugin for that new AI game neuro
20:34:10 <monochrom> some of them dislike RMS
20:34:22 <lispy> he's a dislikable guy
20:34:58 <ozone> yeah, and smelly
20:35:04 <lispy> i wonder what impact FOSS has on the economy
20:35:12 <dons> doesn't mean that gcc and emacs aren't useful and important though, right?
20:35:12 <ozone> along with that "de raadt" guy
20:35:17 <dons> hehe
20:35:20 <ozone> and that eric s raymond guy
20:35:40 <lispy> de raadt is from the OpenBSD group right?
20:35:42 <ozone> any geek who writes a "sex guide" needs to get beaten
20:35:48 <lispy> heh
20:35:49 <dons> oh my.
20:36:02 <monochrom> FOSS has prevented some large companies from total domination.
20:36:05 <ozone> oh yeah, and jordan hubbard is evil!  he left freebsd for that closed-source apple company!  booo!
20:36:15 <dons> boo!
20:36:22 <thedward> which one wrote a "sex guide"
20:36:24 <thedward> wait, don't tell me
20:36:34 <lispy> which one writes all the guides :)
20:36:53 <monochrom> I'd bet it has also saved us millions of dollars by being not quite vulnerable to windows related attacks
20:37:22 <lispy> but what about companies that have lost bussiness to 'free' alternatives
20:37:29 <lispy> like Sun
20:37:39 <ozone> i reckon rms, linus, theo, andrew tridgell, and larry mcvoy should all get into a boxing ring
20:37:42 <ozone> i'd pay to see that
20:37:52 <ozone> oh yeah, along with ESR, just so eveyone can beat the shit out of him
20:37:58 <lispy> according to the news feeds i got today Sun is on it's way to bankruptcy if they don't change the way they due bussiness, and it's largely because IBM adopted linux and they didn't
20:38:03 <monochrom> Sun isn't competitive.  It would lose to IBM and Microsoft anyway.
20:38:20 <monochrom> Remember that Sun makes hardware and still loses.
20:38:28 <lispy> heh
20:38:35 <ozone> and now, my work here is done
20:38:37 <lispy> monochrom: my news source was extremely biased too
20:38:53 <lispy> ozone: now that you've promoted your esr beatings? :)
20:39:10 <ozone> not my fault he's a dickhead :)
20:39:30 <lispy> ozone: it's interesting, i've not met anyone that hated him before
20:39:43 <lispy> ozone: in fact, most people i know think good things about him
20:39:55 <monochrom> Sun loses to Intel.  On that front I am sympathetic with it because Sun hardware has a better design - Intel is just a hack.
20:40:23 <monochrom> But on the software front Sun loses to Microsoft and it is Sun's own fault, can't blame others.
20:40:34 <lispy> monochrom: intel has succeded with a design that defies research
20:41:01 <lispy> Microsoft is hard to play against
20:41:10 <lispy> they have very good strategists
20:42:43 <monochrom> For the recent time there are really only two choices: be friendly to Microsoft or be friendly to FOSS.  (This is not to say you succumb; just be friendly.)
20:43:07 <monochrom> Sun deliberately pissed off both.  That was the error.
20:43:45 <lispy> and google is trying to get FOSS on their side, and yet they don't port their desktop search to linux
20:43:49 <lispy> that baffles me
20:43:56 <lispy> or the google toolbar
20:45:35 <monochrom> IBM cleverly and independently remain in good terms with both.  "Peace is good for business."
20:45:59 <lispy> yeah, i think they like keeping options open
20:47:47 <Pseudonym> Back.  Mmm, lunch.
20:55:48 <dons> here's a good one ;)
20:55:50 <dons> @kind 1
20:56:01 * lispy waits for it
20:56:12 <lambdabot> 1 :: *
20:56:13 <dons> lambdabot's machine is a bit buusy at the moment with a ghc build..
20:59:32 <lambdabot> Sorry about that.
20:59:40 <lambdabot> T H I N K I N G
21:01:13 <dons> manzano$ uptime
21:01:13 <dons>  2:02PM  up 205 days, 37 mins, 3 users, load averages: 1.41, 1.19, 0.80
21:01:57 <dons> just takes a little while to swap in some of the apps used by lambdabot.
21:01:59 <ozone> if you wrote a fork-bomb script that called itself "make" "ghc" etc, would anyone notice?
21:02:11 <dons> huh!
21:02:23 * ozone adds to TODO list
21:02:27 <Pseudonym> Building GHC is a fork bomb for your mind.
21:02:29 <monochrom> haha
21:02:41 <ozone> Pseudonym: nice!
21:02:47 <dons> I remember bombing a cluster that I did distributed ghc builds on.
21:03:17 <dons> forking 4 or 5 ghc's on 20 machines aint so nice for other users.
21:05:31 <thedward> huh. pretty much any custom types I make will crash ghci (on ppclinux) , but will compile fine
21:06:41 <lispy> dons: do you have some way of making lambdabot say what you?
21:06:48 <lispy> s/you/you want/
21:08:33 <dons> that information is confidential ;)
21:12:59 <lambdabot> My bits are sealed.
21:13:47 <Pseudonym> lispy: You could always get the source code and see.
21:14:52 <dons> that reminds me, I''d like to implement: @whereis foo, where foo is a Haskell project.
21:15:29 <dons>  along with @whereis-add ghc haskell.org/ghc, for example
21:15:45 <dons> would save us handing out urls all day long, I think.
21:17:05 <SyntaxNinja> posted to SML (got no reply): how would folks say is the most common way to use the option type... the isSome / valOf style, the getOpt style, or the pattern-matching style?
21:21:34 <dons> some more information?
21:22:49 <lispy> Pseudonym: yeah, i could but that wouldn't give dons a chance to show off :)
21:24:19 <dons> who said it was me? lambdabot is Pseudonym's baby too..
21:24:51 <lispy> ah
21:25:03 <lispy> the puppet masters point fingers... ;)
21:25:03 * Pseudonym was the original author but doubts there's much of his code left
21:25:12 <Pseudonym> Probably the IRC protocol stuff only.
21:25:26 <dons> the lowest level IRC stuff is pretty untouched, I would say.
21:25:33 <Pseudonym> Right.
21:25:39 <Pseudonym> Good, that means it was perfect when I wrote it.
21:25:46 <lispy> hehe
21:25:55 <Pseudonym> Or that it's insufficiently tested.
21:26:13 <Pseudonym> I think the CTCP stuff has been untouched because it's been unused.
21:26:53 <dons> yeah. i think TheHunter and I have touched pretty much every file in the last 3 months. Not to mention the 11 other guys who sent patches. And that's all after Heffalump and crew ran lambdabot for a couple of years.
21:27:18 * dons  goes looking for lambdabot 1.0
21:27:37 <Pseudonym> I think it's still on sourceforge.
21:28:28 <dons> "Candy Shop" release?
21:28:38 <Pseudonym> No, before that.
21:29:24 <Pseudonym> I'm thinking pre-1.0.
21:29:58 <Pseudonym> http://cvs.sourceforge.net/viewcvs.py/haskell-libs/libs/lambdabot/IRC.hs?rev=1.1&view=markup
21:30:09 <Pseudonym> That, for example, is the IRC code as I originally wrote it.
21:30:41 <dons> ok, we've only added to that
21:30:46 <Pseudonym> And refactored.
21:30:49 <Pseudonym> Moved the module stuff out.
21:30:51 <dons> those types are still there, for example.
21:31:17 <Pseudonym> Oh, yeah, my big case statement.
21:31:21 <Pseudonym> http://cvs.sourceforge.net/viewcvs.py/haskell-libs/libs/lambdabot/Main.hs?rev=1.1&view=markup
21:32:46 <dons> so that code is still in too, just spread around a bit.
21:32:56 <dons> Config.hs has the constants now, for example
21:56:03 <Pseudonym> @hello
21:56:04 <lambdabot>  @help <command> - ask for help for <command>
21:56:09 <Pseudonym> Guess that code is gone.
21:56:40 <Clonk_Nukem> hi :)
21:57:20 <Clonk_Nukem> I have a question about this case distinction
21:57:21 <Clonk_Nukem> like
21:57:32 <Clonk_Nukem> func a = case a of
21:57:33 <Clonk_Nukem> ...
21:57:47 <Clonk_Nukem> you can use "where" there for things you need every time
21:57:50 <Clonk_Nukem> well
21:58:08 <Clonk_Nukem> if i have some cases that require other "things" than the other cases
21:58:16 <Clonk_Nukem> can I somehow have different "where"s for them?
21:59:41 <dons> you could use let perhaps.
21:59:50 <Pseudonym> Or you could just put them all in the one where clause.
21:59:59 <Pseudonym> Lazy evaluation means they're not evaluated if they're not used.
22:00:00 <Clonk_Nukem> hmmm
22:00:06 <Clonk_Nukem> aaahhh right
22:00:17 <Clonk_Nukem> moin
22:00:27 <Clonk_Nukem> whops
22:00:31 <Pseudonym> But let also works.
22:00:32 <Clonk_Nukem> damn /amsg :/
22:00:36 <Pseudonym> Moreover, you can use case as a let.
22:00:41 <Pseudonym> case someExpression of
22:00:45 <Pseudonym>     x -> use x
22:00:56 <Clonk_Nukem> hm
22:01:00 <dons> you'd use let if you needed to avoid name clashes, or need to use some variable out of scope in a where clause
22:01:19 <Pseudonym> I've _occasionally_ done this hack:
22:01:21 <dons> though you can always paramaterise the where clause defns..
22:01:37 <Pseudonym> case (actualCaseDistinction, otherExpression) where
22:01:41 <Pseudonym> case (actualCaseDistinction, otherExpression) of
22:01:49 <Pseudonym>     (Just a, x) -> ...
22:01:55 <Pseudonym>     (Nothing, _) -> ...
22:02:00 <Pseudonym> But I wouldn't recommend that.
22:02:04 <Clonk_Nukem> wow, okay o_O
22:02:24 <Pseudonym> Better to use let in that case.
22:02:42 <ski> or where
22:02:48 <Pseudonym> Right.
22:02:59 <SyntaxNinja> @type maybe
22:03:04 <lambdabot> maybe :: forall b a. b -> (a -> b) -> Maybe a -> b
22:06:36 <Clonk_Nukem> hmmm does one of you use the "Proton" editor and has a nifty Haskell Syntax file for it?
22:06:53 <dons> what OS?
22:07:09 <dons> I haven't heard of this editor.
22:07:11 <Clonk_Nukem> Windows
22:10:39 <Clonk_Nukem> huh
22:10:41 <monochrom> Outlook Express has the best editor.
22:10:51 <Clonk_Nukem> what's "*** Exception: Prelude.read: no parse" ?
22:11:22 <ski> it can't parse the string
22:11:30 <monochrom> one way to cause that is: 10 + read "hello world"
22:11:57 <Clonk_Nukem> I see
22:12:14 <monochrom> 10+read"56" works, 10+read"hello world" doesn't, for fairly obvious reasons.
22:12:30 <SyntaxNinja> any ML programmers awake enough to look over somethikng for me?
22:12:33 <Clonk_Nukem> okay =)
22:12:54 <Clonk_Nukem> in that case I can imagine why that exception occurs...
22:13:12 <monochrom> Glad my example helps.
22:13:20 <ski> @plugs 10 + read "56"
22:13:25 <lambdabot> 66
22:13:32 <monochrom> Yippee!
22:13:36 <ski> @plugs 10 + read "hello world"
22:13:37 <lambdabot> Fail: Prelude.read: no parse
22:19:48 <Clonk_Nukem> hmmm
22:19:57 <Clonk_Nukem> it must be some kind of collision between these cases.
22:20:23 <Clonk_Nukem> weird
22:21:25 <Clonk_Nukem> ('x':s)         -> [...] works
22:21:26 <Clonk_Nukem> but
22:21:37 <Clonk_Nukem> ('E':' ':'x':s) -> [...] does not
22:22:13 <Clonk_Nukem>                              where p = break (\x -> not (isDigit x)) s
22:22:13 <Clonk_Nukem>                                    var = read (fst p) :: Int
22:22:17 <Clonk_Nukem> hm
22:22:31 <Clonk_Nukem> after those x there are some numbers
22:22:37 <Clonk_Nukem> and then letters again
22:22:40 <Clonk_Nukem> in all cases
22:25:11 <ski> what do you mean with 'works', here ?
22:25:50 <ski> the two cases surely doesn't overlap, so they can't both match with the same value ..
22:26:57 <Clonk_Nukem> ehm... with "works"?... Uhm... that the function extracts those numbers between the x and the next non-digit character
22:27:35 <Clonk_Nukem> and does various stuff with that and later writes a maybe altered number back
22:28:26 <Clonk_Nukem> what do you mean that they can't both match?
22:29:02 <ski> the first matches something that begins with "x" while the second matches something that begins with "E x"
22:29:09 <Clonk_Nukem> yes
22:29:51 <Clonk_Nukem> oh no, it's suddenly broken totally :|
22:42:55 <dons> @where ghc
22:42:57 <lambdabot> ghc: http://haskell.org/ghc.
22:43:19 <dons> @where yi
22:43:20 <lambdabot> yi: http://www.cse.unsw.edu.au/~dons/yi.html.
22:44:55 <smott> have you guys seen this? http://www.freesoftwaremagazine.com/free_issues/issue_05/haskell/
22:45:27 * ski has
22:47:50 <Pseudonym> Yay.
22:48:28 <ski> CosmicRay wrote that, iirc
22:49:25 <ski> @where ones = 1 : ones
22:49:27 <lambdabot> I know nothing about ones.
22:49:53 <Pseudonym> Oh, no.  He wrote "Linux".
22:49:56 <dons> no no. @where is for associating projects with their urls
22:49:58 <Pseudonym> Instead of "GNU/Linux".
22:50:05 <Pseudonym> In the free software magazine!
22:50:19 <monochrom> the editor didn't seem to mind
22:50:38 <monochrom> perhaps Torvalds was behind the magazine!
22:50:39 <ski> dons : (:
22:50:56 <monochrom> @where ghc
22:50:57 <lambdabot> http://haskell.org/ghc
22:51:09 <dons> i'll add some more urls
22:51:15 <monochrom> @where Solaris
22:51:17 <lambdabot> I know nothing about solaris.
22:51:28 <SyntaxNinja> no one does
22:51:56 <dons> that's reasonable
22:52:05 <Clonk_Nukem> hmmm btw is there also a haskell interpreter/compiler for BeOS?
22:52:46 <dons> ghc?
22:52:49 <dons> hugs?
22:52:55 <dons> nhc98?
22:53:05 <Pseudonym> @where Windows
22:53:07 <lambdabot> I know nothing about windows.
22:53:10 <Pseudonym> Unsurprising.
22:53:52 <monochrom> this is no fun
22:54:11 <Clonk_Nukem> I can't find ghc or hugs for BeOS
22:54:15 <Clonk_Nukem> where can I get it?
22:54:43 <dons> @where hugs
22:54:44 <lambdabot> http://haskell.org/hugs
22:54:45 <dons> @where ghc
22:54:46 <lambdabot> http://haskell.org/ghc
22:54:46 <dons> :P
22:55:24 <r2d4> Hi! There is a Haskell class here that I am considering taking. I understand that Haskell is a very good way to understand functional programming. Do you guys use it as an everyday language like say Python as well?
22:55:37 <Clonk_Nukem> I've been looking there..
22:55:59 <Pseudonym> Given that I don't use Python, no. :-)
22:56:18 <dons> nope. I pretty much only use haskell and sh
22:56:34 <r2d4> Pseudonym: or Perl/Ruby or anything in that range.
22:56:40 <dons> the odd C fragment too
22:56:51 <dons> Haskell is an everyday language.
22:56:55 <Pseudonym> I don't use Haskell as a replacement for any language.
22:57:38 <Pseudonym> Not like how I use Perl instead of shell scripts.
22:58:05 <Pseudonym> But yes, Haskell is an everyday language.
22:58:28 <Pseudonym> But it's more suited to higher-level stuff, exploratory programming, serious structure hacking, that sort of thing.
22:58:35 <Pseudonym> At least in what I do.
22:59:13 <r2d4> I only poked around Haskell. Couldn't pick it up effortlessly like Python or Ruby. I try to be as functional as I can in Python.
22:59:34 <Pseudonym> If you've never done functional programming before, Haskell isn't effortless.
22:59:54 <SyntaxNinja> r2d4: I use Haskell like some use python and perl
23:00:20 <SyntaxNinja> I personally think Haskell is great for systems stuff
23:01:21 <dons> SyntaxNinja: I agree. You end up writing non-hacky scripts that don't go wrong.
23:01:25 * Pseudonym nods
23:01:40 <Pseudonym> I tend to use Haskell when I want to think big and other languages when I want to think small.
23:01:47 <Pseudonym> But that's just me.
23:01:53 <r2d4> SyntaxNinja: I don't do much of systems stuff. Just GUIs, text processing. web application servers. How is Haskell here?
23:02:04 <Pseudonym> GUIs not so good.
23:02:09 <Pseudonym> Doable, but not great, IMO.
23:02:13 <dons> @where wxhaskell
23:02:14 <lambdabot> http://wxhaskell.sourceforge.net/
23:02:16 <dons> @where gtk2hs
23:02:18 <lambdabot> http://haskell.org/gtk2hs/
23:02:22 <Pseudonym> Like I said, doable.
23:02:28 <Pseudonym> :-)
23:02:37 <Pseudonym> Others, should be good.
23:02:39 <Pseudonym> @where WASH
23:02:40 <lambdabot> I know nothing about wash.
23:02:47 <dons> not there yet..
23:02:49 <Pseudonym> Ah.
23:02:57 <r2d4> I don't rely on Python for GUIs either. But it calls great from Delphi. Is haskell easily embeddable?
23:02:58 <dons> @help where+
23:02:59 <lambdabot>  @where+ <key> <elem>, define an association
23:03:23 <Pseudonym> More commonly, you call other languages from Haskell.
23:03:39 <Pseudonym> Since Haskell is a dream for high-level stuff.
23:04:31 <SyntaxNinja> eh, when playing with wxwindows in python and in Haskell, I found them to be comparable, though I didn't do anything overly complex.
23:04:50 <Pseudonym> Text processing... depends what you're doing.  Haskell isn't known for Perl-like string manipulation, but many people find Haskell's way superior (if quite different).
23:05:12 <r2d4> SyntaxNinja: How do you compare your Python and Haskell experiences.
23:05:30 <r2d4> Till about 3 years ago, I language shopped a lot.
23:06:00 <r2d4> I haven't learned anything new. Maybe I am just slowing down...
23:06:11 <dons> @seen Speck
23:06:12 <lambdabot> I saw Speck leaving #haskell 2 hours, 47 minutes and 24 seconds ago,
23:06:12 <lambdabot> and I have missed 54 seconds since then.
23:06:26 <r2d4> so wondering if the shift is worth the effort..
23:06:31 <Pseudonym> Yes it is.
23:06:40 <r2d4> I did read a lot of good things about FP.
23:06:48 <Pseudonym> Haskell is sufficiently different that even if you don't use it, it'll improve your programming in other languages.
23:07:03 <Pseudonym> e.g. you may use Python's functional stuff better
23:07:15 <SyntaxNinja> r2d4: I don't really use python, but I've looked at it now and again
23:07:42 <r2d4> All the students who took the Haskell class said more or less the same thing. They liked it's elegance but they said that they will stick to whatever they were using earlier.
23:07:46 <SyntaxNinja> it's always worth it to learn new languages especially something that is different from what you already know.
23:08:13 <Pseudonym> When I program in other languages, I often find myself prototyping bits in Haskell first.
23:08:18 <SyntaxNinja> most ppl who get into it wish they could spend their time writing more Haskell instead of php / c / python or whatever they're using already.
23:08:23 <Pseudonym> Because it lets me think big.
23:08:30 <Pseudonym> Even if I don't use Haskell in the final code.
23:08:57 <r2d4> SyntaxNinja: am not a CS student. I don't intend to program professionally. Fun factor is more important.
23:09:07 <dons> haskell is definitely fun.
23:09:10 <Pseudonym> Then DEFINITELY learn Haskell.
23:09:22 <Pseudonym> Haskell is serious fun.
23:09:23 <dons> way way more fun than perl, say.
23:10:35 <SyntaxNinja> i'm professionally employed writing Hsakell, and I have to have full-time bodyguards to protect me from professional php programmers who know Haskell
23:10:35 <Pseudonym> Definitely.
23:10:49 <Pseudonym> Perl is pragmatic, for sure.  But it's just business.
23:12:55 <r2d4> But one thing though. I revel when I can make things in the shortest code. Often using community code base. I know where to look when I need some functionality in say Python. Are there any such code banks for modules in Haskell? My own search efforts were less encouraging. I found modules but most were low level. I felt this was paradoxical. Haskell is a high level language but I mostly saw...
23:12:57 <r2d4> ...direct C bindings. Of course all this could just be me looking at wrong places.
23:13:28 <Pseudonym> Well that depends what functionality you need.
23:13:51 <dons> @where libs
23:13:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
23:14:04 <Pseudonym> If you're talking bindings to protocols or that sort of thing, that's an in-progress thing.
23:14:17 <Pseudonym> If you mean high-level algorithms and data structures sort of thing, you probably don't need them.
23:14:32 <Pseudonym> Lots of things which are libraries in other languages are trivial in Haskell.
23:14:34 <Pseudonym> And vice versa.
23:15:28 <r2d4> For example, today I wrote a program that went to a web site, logged in, filled a form, followed links and put some stuff in a database. That sort of thing.
23:15:49 <Pseudonym> Right.  For that, you'd have to grab libraries from different places.
23:15:59 <Pseudonym> But you'd probably find them via the URL dons pointed to.
23:16:27 <r2d4> That's fine. I had to libraries in the language I used too :-). Just so long as they are there.
23:16:28 <Pseudonym> Or via haskell.org
23:16:41 <Pseudonym> Yeah, but in Perl, for example, you wouldn't have to search.
23:16:47 <Pseudonym> You'd just call up CPAN.
23:16:55 <Pseudonym> That's what I meant.
23:17:07 <Pseudonym> The Haskell community is fairly closely-knit, so someone usually knows.
23:17:14 <Pseudonym> Asking here usually does the trick.
23:17:42 <Clonk_Nukem> I g2g, thanks for your help!
23:17:44 <Clonk_Nukem> cu
23:18:03 <dons> now we have @where its even easier ;)
23:18:12 <r2d4> OK! Thanks. Looks like I will take that class after all :).
23:18:17 <Pseudonym> True, but as you've noted it's incomplete.
23:18:48 <dons> Pseudonym, feel free to add urls with @where+ as people ask.
23:19:20 <Pseudonym> Will do.
