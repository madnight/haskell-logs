00:11:58 <Trevion> hey.
00:12:20 <Trevion> I have a couple of long character strings whose bits I'd like to interpret as Integers.
00:12:31 <Trevion> I don't see an easy way to do that - am I missing something?
00:16:29 <dons> @type read
00:16:31 <lambdabot> read :: forall a. (Read a) => String -> a
00:16:35 <dons> @plugs read "42" :: Int
00:16:36 <lambdabot> 42
00:17:02 <Trevion> more like "\x00\xAA\x36" etc for a 512 bit RSA key
00:17:21 <Trevion> the first char is the most significant eight bits, and so on
00:17:26 <dons> look in Data.Bits
00:17:35 <dons> @type (Data.Bits..&.)
00:17:37 <lambdabot> (Data.Bits..&.) :: forall a. (Data.Bits.Bits a) => a -> a ->
00:17:37 <lambdabot> a
00:17:55 <dons> @plugs 4 .|. 8 :: Int
00:17:57 <lambdabot> 12
00:18:20 <Trevion> hmm.. okay
00:18:48 <dons> 	       (fromIntegral w6 `shiftL` 16) .|.
00:18:48 <dons> 	       (fromIntegral w7 `shiftL`  8) .|.
00:18:49 <dons> 	       (fromIntegral w8))
00:19:12 <dons> @type Data.Bits.shiftL
00:19:13 <lambdabot> Data.Bits.shiftL :: forall a. (Data.Bits.Bits a) => a -> Int ->
00:19:13 <lambdabot> a
00:19:41 <Trevion> and then presumably fold the string together, shifting each character appropriately?
00:27:21 <Trevion> Okay - I think I have it.  Thanks
01:10:06 * Itkovian thinks boegel is attacked by eddies in the space-time continuum
02:19:26 * Itkovian ponders
02:20:26 <xerox> 'morning!
02:23:55 <Itkovian> hello
02:55:23 * Itkovian eats
03:29:59 <Itkovian> it is awfully quiet around here ...
03:30:08 <Itkovian> people stil mourning the apple move?
03:30:10 <Itkovian> lol
03:30:36 <xerox> Many do :)
03:37:32 <Itkovian> well, if you decide to hang yrself, leave yr shiny PPC-mac to me :-)
03:42:36 <xerox> ihih
04:02:45 <nothingmuch> @type runReader
04:02:50 <lambdabot> bzzt
04:04:14 <xerox> @index runReader
04:04:15 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
04:04:23 <xerox> @type Control.Monad.Reader.runReader
04:04:25 <lambdabot> Control.Monad.Reader.runReader :: forall a r.
04:04:25 <lambdabot>             Control.Monad.Reader.Reader r a -> r -> a
04:06:19 <xerox> @index shift
04:06:22 <lambdabot> Data.Bits, Foreign, Graphics.UI.GLUT.Callbacks.Window, Graphics.UI.
04:06:22 <lambdabot> GLUT.Callbacks, Graphics.UI.GLUT
04:06:24 <xerox> @index reset
04:06:26 <lambdabot> Text.Html, Text.ParserCombinators.ReadPrec, Text.Read
04:08:30 <kowey> hi channel
04:08:34 <xerox> Hello!
04:08:44 <kowey> if anyone knows how to use the heap profiler, maybe help flesh out this page?
04:08:44 <kowey> http://www.haskell.org/hawiki/Profiling
04:12:58 <nothingmuch> could someone explain what is the autocurrying effect of this expr: (`runReader` someValue) ?
04:13:32 <mflux_> \x -> x runReader someValue
04:13:40 <mflux_> with `'s
04:13:53 <mflux_> so: \x -> runReader x someValue :)
04:14:01 <mflux_> @pl \x -> runReader x someValue
04:14:02 <lambdabot> flip runReader someValue
04:14:09 <nothingmuch> oh, i see
04:14:10 <mflux_> @pl \x -> x `runReader` someValue
04:14:11 <lambdabot> (`runReader` someValue)
04:14:34 <nothingmuch> so it's just like autocurrying the second param, in a sense
04:14:36 <nothingmuch> ?
04:14:45 <mflux_> it curries the first parameter?
04:14:55 <xerox> @pl flip runReader $ someValue
04:14:57 <lambdabot> flip runReader someValue
04:15:00 <mflux_> consider this:
04:15:02 <mflux_> @pl ((/) 2) 4
04:15:03 <lambdabot> 2 / 4
04:15:09 <mflux_> @pl (2 (/)) 4
04:15:10 <lambdabot> 2 (/) 4
04:15:13 <nothingmuch> uhuh
04:15:19 <nothingmuch> that's 4/2 right?
04:15:31 <nothingmuch> wait, bah! confusion!
04:15:34 <mflux_> hmh.. yeah, it got it wrong ;)
04:15:38 <xerox> @plugs (2 (/)) 4
04:15:42 <lambdabot> <Plugins.Eval>:1:
04:15:42 <lambdabot>   No instance for (Num ((a -> a -> a) -> t -> a1))
04:15:42 <lambdabot>   arising from the literal `2'
04:15:46 <mflux_> @plugs (/ 2) 4
04:15:48 <lambdabot> 2.0
04:15:59 <mflux_> @plugs (2 /) 4
04:16:00 <lambdabot> 0.5
04:16:07 <xerox> Aah, OK.
04:16:23 <mflux_> using (/) wasn't quite right as I wanted to use it as an operator..
04:16:33 <mflux_> so `runReader` would be analogous to /
04:16:48 <nothingmuch> what my expr does is create a function which will take it's param, and apply it to the the infixifized function, and the created function takes a param, gives it to the infixified thing, and applies the returned function to someValue?
04:18:49 <mflux_> hmmm.. I don't think that's right. basically sayind (`op` x) or (x `op`) creates a function that has one of the arguments to the operator filled in
04:18:59 <nothingmuch> yup
04:19:00 <mflux_> s/sayind //
04:19:11 <nothingmuch> but since functions don't really ever have two parameters, it's generalize
04:19:13 <nothingmuch> d
04:19:48 <nothingmuch> it creates a lambda that takes it's param, gives it to op, and then applies the result of (op y) on x?
04:21:37 <mflux_> I think that's it
04:21:47 <nothingmuch> okay, thanks
04:21:49 <nothingmuch> mflux_++
04:22:09 <nothingmuch> do you guys use ++ here, with immutability and all that?
04:22:46 <Lemmih> Nah, we use 'succ'.
04:22:57 <mflux_> 'flux, you succ!'
04:22:59 <mflux_> great
04:23:03 <nothingmuch> does lambdabot keep track of that?
04:23:08 <mflux_> @karma+ mflux_
04:23:09 <lambdabot> You can't change your own karma, silly.
04:23:10 <mflux_> ;(
04:23:18 <nothingmuch> ;@karma+ mflux_
04:23:31 <nothingmuch> and to compensate for your mishap:
04:23:34 <nothingmuch> @karma+ mflux_
04:23:36 <lambdabot> mflux_'s karma has been incremented
04:23:39 <mflux_> wooho \o/
04:23:40 <nothingmuch> oh wait, i screwed up the first one
04:23:47 <Lemmih> @karma mflux_
04:23:47 <nothingmuch> @karma+ mflux_
04:23:48 <lambdabot> mflux_ has a karma of 1
04:23:48 <lambdabot> mflux_'s karma has been incremented
04:24:56 <nothingmuch> now that I sort of kind of know a little more, back to C++.. *sigh*
04:25:00 <nothingmuch> thanks again mflux_!
04:25:21 <mflux_> happy to be of help
04:29:00 <dcoutts_> @seen boegel
04:29:01 <lambdabot> I saw boegel leaving #haskell 3 hours, 32 minutes and 3 seconds ago.
04:29:37 <dcoutts_> lambdabot, you'll let me know when he get's back wont you, ta.
04:29:38 <xerox> Do anybody know this notation, and where I can find docs about it?
04:29:50 <xerox> @type arr (id) :: (Arrow (~>)) => b ~> b
04:29:53 <lambdabot> bzzt
04:30:16 <mflux_> I wouldn't mind seeing some practical tutorials to arrows, as there are a few for monads
04:31:26 <mflux_> but I guess reading the robotics control whatsitsname source is the solution at the moment?-)
04:33:09 <ski> xerox : http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#infix-tycons "A type variable can be an (unqualified) operator"
04:33:58 <xerox> Great!
04:35:30 <xerox> ski, do you know why what I paste before doesn't parse?
04:35:39 <ski> no
04:36:04 <ski> maybe it only works in latest ghc, and lambdabot doesn't use that .. ?
04:37:28 <xerox> It doesn't work on my GHC 6.4 too.
04:39:26 <ski> there's a red box around this feature, and green around others ..
04:39:39 * ski wonders what that means ..
04:39:51 <ski> maybe it isn't implemented yet ??
04:40:22 <ski> (or, rather, the red box is around the example ..)
04:40:23 <xerox> All the other boxes on the page are red, too.
04:40:53 <ski> not in my browser
04:41:38 <ski> the 3 other boxes under 7.4.1.2 is green, here  (though all boxes under 7.4.1.3 is red)
04:41:41 <xerox> I mean, the majority is red, another green boxes are at the end.
04:41:45 <xerox> Yep.
04:42:25 * xerox curses google, which can't properly search for "~>" or "Arrow (~>)"
04:42:51 <ski> hm, where did you see about ~> initially ?
04:42:54 <ski> here ?
04:42:56 <dons> we need hoogle!
04:42:57 <xerox> Yeah.
04:43:02 <dons> @google hoogle
04:43:04 <lambdabot> http://hoogle.com/
04:43:19 * ski hadn't heard about it 'til since yesterday, when you asked about it ..
04:43:27 <xerox> http://www-users.cs.york.ac.uk/~ndm/hoogle/
04:43:31 <dons> that's it.
04:43:43 <ndm> hey, i wrote hoogle :)
04:43:52 <dons> @karma+ ndm
04:43:53 <ski> yay !
04:43:53 <lambdabot> ndm's karma has been incremented
04:43:54 <ski> nice
04:44:11 <xerox> @karma+ ndm -- indeed.
04:44:12 <lambdabot> ndm's karma has been incremented
04:44:23 <ndm> you have to search hoogle haskell, or the sites are rather dodgy
04:44:47 <dons> @google hoogle haskell
04:44:49 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/hoogle/
04:44:51 <dons> cool
04:44:59 <xerox> Let's search for "hoogle" and click on ndm's site once a day, everyone :-)
04:45:07 <dons> someone should write a hoogle plugin for lambdabot...
04:45:18 <dons> ndm?
04:45:20 <ndm> i am almost ready to release the source code
04:45:20 <xerox> dons, it would be great!
04:45:20 <Itkovian> looks quite cool, but are you sure google doesn't mind?
04:45:38 <Itkovian> last time I heard, they weren't too happy with a west-flemish goegel site
04:45:54 <ndm> no idea if google object
04:46:23 <ndm> i can give a go at writing a lambdabot plugin, but it might take me a while
04:46:36 <dons> not sure.. the plugins are *really* easy to write.
04:46:37 <ndm> someone else has already written an OS X version, and there is a command line version in teh works
04:46:37 * xerox is applying to that job.
04:46:45 <dons> oh, command line. that's good
04:46:52 <dons> wouldn't be hard to adapt
04:47:00 <ndm> i am working on a nice abstraction interface to make all these versions very similar
04:47:03 <dons> along the lines of @plugs or @type
04:47:33 <dons> you can directly call programs, pass args and get stdout in lamdbabot plugins
04:47:48 <ndm> should be very easy then
04:47:55 <dons> @version
04:47:57 <lambdabot> lambdabot 3p2, GHC 6.4 (OpenBSD i386)
04:47:57 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:48:20 <xerox> It could be one line in Plugins/Search.hs
04:48:39 <nothingmuch> is lambdabot command line capable? it could be a very useful tool even off IRC
04:49:07 <dons> xerox, good idea.
04:49:20 <dons> would you like to try?
04:49:23 <xerox> dons, I'm trying it.
04:49:33 <dons> @karma+ xerox
04:49:34 <lambdabot> xerox's karma has been incremented
04:49:45 * xerox bounces happily
04:50:02 <dons> nothingmuch, that's a good idea. it's not currently possible but could be done
04:50:19 <dons> usually I just /msg lambdabot for private testing
04:52:06 <ndm> off to lunch now, if anyone has any suggestions/thoughts on hoogle let me know in about an hour :)
04:59:05 <xerox> dons, in fact hoogle search differs from google/wikipedia's one.  It's not the url the matter of searching, while some content of the page.  Would be better to change Search.hs structure, or write an Hoogle.hs per-se?
05:01:38 <dons> hmm
05:02:05 <dons> can you write a Hoogle.hs?
05:02:27 <xerox> I think I can.
05:02:36 <dons> go for it
05:02:41 <dons> @uptime
05:02:42 <lambdabot> uptime: 1 day, 1 hour, 29 minutes and 12 seconds
05:02:48 <dons> oh!
05:03:03 * dons checks the logs
05:04:47 <dons> oh, brown.freenode.net went down
05:09:24 * Itkovian likes the hoogle stuff
05:09:35 <Itkovian> finally no more skimming the docs looking for a type-sig
05:13:13 <Enveigler> hoogle?
05:13:36 <xerox> @google hoogle haskell
05:13:38 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/hoogle/
05:15:09 <Lemmih> What useful, non-networked task can lambdabot perform?
05:16:04 <mikael> he can rewrite functions into points-free style!
05:16:14 <mikael> if that's not useful, I don't know what is
05:16:15 <Lemmih> Ah, yes.
05:27:08 <xerox> dons, could be Spell.hs interferring with "hoogle" and "google" commands?
05:29:03 <arjanb> you could call it "findtype" instead
05:30:43 <dons> xerox?
05:31:17 <Itkovian> arjanb: isn't it more than just types finding?
05:31:27 <dons> it's possible if you haven't registered the new module by adding it config.mk
05:31:30 <xerox> Silly me.
05:31:51 <xerox> I have two hoogle's, Search.hs and Hoogle.hs :)
05:32:02 <ndm> Itkovian: A bit more, finding names as well - but not a huge amount more
05:33:28 <Itkovian> hey, I was jujst defending you :-)
05:33:59 <Itkovian> a quick question while he's not here, though he prolly will read the logs, even if you don;t mention anything ...
05:34:16 <Itkovian> for those of you that are a bit familiar with Boegel's work, how would you rate it?
05:34:33 <Itkovian> Excellent, very good, good, regular, disappointing ...
05:34:44 <Itkovian> I've made up my mind, but some backing up would be very nice.
05:34:48 <Itkovian> Got to give points ...
05:35:12 <ndm> Itkovian: Thanks for the defense, appreciated anyway :)
05:35:57 <Itkovian> I do think hoogle is a good name ... everybody will know what it does, and if it's extended with more lookup stuff, the name need not change
05:39:35 <ski> mikael : http://www.haskell.org/hawiki/QuotesPage?action=diff
05:43:47 <xerox> dons, is there a way to reload a module without quitting/relaunching lambdabot?
05:44:06 <dons> yep, @dynamic-reload
05:44:27 <mikael> ski: oh, apologies!
05:44:27 <xerox> module "dynamic" screwed up: module is sticky
05:44:29 <xerox> hmmm.
05:44:39 <xerox> OK :-)
05:44:40 <xerox> thanks.
05:45:26 <ndm> btw, if hoogle generates too many results for lambdabot to spew out (and it almost certainly does)
05:45:52 <ndm> you can link to the full results in the frame with
05:45:54 <ndm> http://www-users.cs.york.ac.uk/~ndm/hoogle/?a-%3E%5Ba%5D
05:46:00 <xerox> Yeah, I was thinking about that: should it print the first one, or how many?
05:46:03 <ndm> where the bit after the ? is the escaped search
05:46:04 <ski> mikael : at least according to boegel ..
05:46:33 <ndm> it certainly can't print all - search a->b for an example
05:46:51 <ndm> maybe the first 3 or 4 - that seems to be a useful chunk
05:47:02 <ndm> i am working on proper ranking and cutoffs for it
05:47:53 <xerox> Now I need some HTML parser...
05:48:24 <ndm> probably easier to do it by hand
05:48:35 <ndm> hand-coded i mean
05:48:46 <ndm> each result is one line, strip away the HTML and you've got the relevant bits left
05:48:57 <ndm> i.e. drop it all between < and >
05:51:53 <ndm> and it _should_ be valid XHTML, minus the header and doctype
05:52:37 <arjanb> why does it return filter, (^), const and pi when searching on (a -> b) -> [a] -> [b]?
05:52:49 <mflux_> wouldn't it be more fruitful to get the guy to release the source?-)
05:53:11 <ndm> i can release the source, i have a tar file already bundled
05:53:25 <ndm> but its not necessarily in a "good source" form
05:53:31 * Itkovian is rofl from reading the selected quotes
05:53:34 <ndm> crashes and other bad things inflict on it
05:53:37 <mflux_> oh, you're 'the guy'
05:53:43 <ndm> yep
05:53:46 <mflux_> but in any case, that would allow the bot to work if the website doesn't
05:53:48 <Itkovian> a good way to procrastinate
05:54:03 <ndm> arjanb: const and pi unify with everything, its hard not to return them
05:54:37 <mflux_> ndm, how about simply filtering them out?-)
05:54:54 <ndm> arjanb: imagine filter being (Bool -> Bool) -> [Bool] -> [Bool], that unifies
05:55:19 <ndm> mflux_: working on it :), it currently ranks them, in a while it will rank better and have a cutoff
05:55:40 <mflux_> I wonder if it would be more useful if it didn't do that unification, but would require that to unify a and b must be distinct?
05:55:53 <ndm> arjanb: and for ^, it just doesn't understand classes
05:55:58 <arjanb> i see
05:56:25 <ndm> it does unification, which seems to be a good choice, and then gives "bonus marks" for if they are distinct
05:56:33 <ndm> the bonus marks score needs tuning
05:57:49 <ski> ndm : maybe it would be good to be able to specify explicit "forall" to force some typevars to not be instantiated .. ?
05:58:30 <ndm> ski: hmm, that seems to make sense
05:58:50 <ndm> ski: I'd prefer not to use GHC extensions though...
05:59:00 <ski> so we can eat the cake, and have it too
05:59:17 <ski> it's a common extension between hugs and ghc, i think
05:59:33 <ndm> it gives bonus marks for instantiating somehting to something equally general - i.e. a = Bool looses marks
05:59:51 <ndm> i sit next to a guy who's writing nhc, he might not like it :)
06:00:00 <ski> oki
06:00:26 <arjanoosting> scan
06:00:33 <ndm> but i'll think about it, and add it to the list of possible things to do
06:04:07 <ski> hm, you does hoogling for "" give back e.g. "fromIntegral
06:04:07 <ski> :: (Integral a, Num b) => a -> b
06:04:16 <ski> sorry
06:04:21 <ski> hoogling "for a -> [a]"
06:04:22 <ski> ?
06:05:30 <ski> ndm : because of it doesn't handle constraints correctly ?
06:05:50 <mikael> is it possible to get a usable backtrace out of a ghc-compiled binary?  I'm having some segmentation fault problems with HX11
06:06:35 <ndm> ski: yep, it completely ignores constraints
06:06:53 <ndm> ski: for the moment... - when I have some time it will learn about them
06:07:21 <ski> hm, now i see
06:08:18 <ski> it of course can instantiate in both ways ..
06:17:33 <arjanb> ndm: maybe instantiation of type variables in searched type should get negative marks, on the assumption that the user searches with the most specific type
06:22:06 <ndm> arjanb: It already does
06:23:13 <ndm> lots of things give negative marks
06:23:41 <ndm> at the bottom of the search results the functiosn are typically on about -150 marks, and the top is at about 0 or -2
07:06:47 * Itkovian waves at boegel
07:09:33 * boegel waves back
07:10:52 <xerox> What could it mean something like this? "<TITLE>Error</TITLE><BODY><H1>Error</H1>FW-1 at sentry2.york.ac.uk: Access denied.</BODY>"
07:11:43 <Itkovian> that you're screwed?
07:11:47 <boegel> a HTML-page saying some error has occured ?
07:12:06 <dblhelix> is this a quiz? :)
07:12:11 <Itkovian> lol
07:12:28 <Itkovian> this may be one for the quotes page :-)
07:12:52 <boegel> dblhelix: well, who was correct ? ;)
07:13:53 <xerox> Same code works with othere pages... I think I'm being blacklisted while trying to do Hoogle.hs, hmpf.
07:14:07 <dblhelix> boegel: well, I think you told xerox something he already knew, while Itkovian added some valuable information ;)
07:14:16 <Itkovian> lol
07:14:34 <xerox> :(
07:14:37 <Itkovian> my plaesure
07:14:39 <Itkovian> dang
07:14:45 <Itkovian> s/ae/ea/
07:15:26 <boegel> Itkovian: 1 boegel: 0
07:15:31 <boegel> next question pls ! :)
07:15:36 <xerox> @ghc
07:15:38 <lambdabot>  Interesting!  A join var that isn't let-no-escaped
07:15:45 <xerox> Have fun.
07:16:07 * boegel uses his joker
07:16:21 * Itkovian is confused
07:16:38 <boegel> Itkovian: you should try and explain the ghc error :)
07:16:48 <boegel> I think Itkovian's time is up :p
07:16:54 * Itkovian cranks up Tool -- Lateralus
07:16:55 <xerox> I tought the point was giving a test-case.
07:17:30 <Itkovian> ah well, there is clearly some unclarity regarding the goal of the questions shown
07:17:43 <boegel> Itkovian: at your desk ? :)
07:17:47 <Itkovian> always
07:17:54 <Itkovian> until the train has wireless ...
07:17:58 <xerox> @moo
07:17:59 <lambdabot>          (__)
07:17:59 <lambdabot>          (oo)
07:17:59 <lambdabot>   /-------\/
07:17:59 <lambdabot>  / |     ||
07:17:59 <lambdabot> *  ||----||
07:18:00 <lambdabot>    ~~    ~~
07:18:02 <lambdabot>      Cow
07:18:04 <Itkovian> a cow
07:18:10 <boegel> (Just Cow)
07:18:18 <xerox> Itkovian 1; lambdabot 0
07:18:19 <Itkovian> grr
07:18:34 <xerox> Hmm, OK.
07:18:40 <Itkovian> there is some time inconsistency going on here ...
07:18:51 <xerox> @vixen who do you want to give the next point to? Itkovian or boegel?
07:18:55 <lambdabot> sure, i want to plenty
07:18:56 <TheHunter> hmm, that can't happen unless ghc is compiled with -DDEBUG.
07:18:58 <Itkovian> eddies in the time-space continuum
07:19:01 * boegel feels RTS coming up again :s
07:19:13 <Itkovian> 'where , where'
07:19:27 <xerox> `where`
07:19:35 <TheHunter> @uptime
07:19:37 <lambdabot> uptime: 1 day, 3 hours, 46 minutes and 6 seconds
07:19:41 <Itkovian> there, behind that tree, a couch
07:19:59 <TheHunter> @ghc
07:20:00 <lambdabot>  Malformed context in instance header
07:20:08 <Itkovian> that's easy
07:20:10 <Itkovian> a typo
07:20:20 <boegel> lolz
07:20:48 <Itkovian> @ghc
07:20:49 <lambdabot>  Type signature given for an expression
07:21:02 <Itkovian> an zealotic programmer at work
07:21:47 * Itkovian is procrastinating
07:22:02 <Itkovian> ... pain is an illusion ...
07:22:11 <boegel> Itkovian is using words boegel has never heard of
07:22:32 <Itkovian> well, it's what you wull do the next four years, so I suggest you look it up ;-)
07:22:42 <Itkovian> @google procrastinate
07:22:43 <lambdabot> http://www.businesstown.com/time/time-5reasons.asp
07:22:47 <Itkovian> haha
07:23:03 <Itkovian> exactly
07:23:59 <boegel> Itkovian: like hell I will :)
07:24:11 <boegel> I'll work ! :p
07:24:48 <Itkovian> you still believe in fairy tales, eh ;-)
07:25:12 <Itkovian> grr, this script seems to remain unfinished for all week
07:25:21 <Itkovian> and we're just Tuesday ...
07:25:57 <boegel> Itkovian: good job :p
07:37:37 <boegel> is HOpenGL combined with GHC yet ? or do you have to install it seperatly ?
07:38:15 <Lemmih> It's shipped with GHC 6.4
07:38:28 <boegel> hmm
07:38:35 <boegel> then I should install that :) less effort
07:38:55 <dcoutts_> ah boegel you're back. So it's GtkGlExt that we want. It works on Windows too.
07:39:06 <shelarcy> I think HOpenGL is in sicen GHC 6.2.
07:39:18 <shelarcy> since
07:39:19 <boegel> shelarcy: it is ? How can I tell ?
07:39:32 <dcoutts_> I've got our bindings code generator producing something already :-)
07:39:38 <boegel> dcoutts_: okay... now, what should happen ?
07:39:40 <boegel> oh, nice: )
07:39:50 <Lemmih> The HOpenGL that is shipped with < GHC 6.4 is way old.
07:39:58 <boegel> oh
07:39:59 <boegel> damn
07:40:13 <dcoutts_> boegel, so basically we massage the output of the code generator until it compiles and then test it :-)
07:40:33 <boegel> dcoutts_: shouldn't take to long, right ?
07:41:17 <dcoutts_> probably not, depends on how bad the C API is. Sometimes its not straightforward, but I don't expect this to be too bad.
07:41:27 <boegel> ok, great !
07:41:43 <dcoutts_> you're not going to get it in 0.9.8 however. The first release candidate for that should be released today.
07:41:52 <dcoutts_> (fingers crossed)
07:41:59 <boegel> I'll try to display the output of my HaskLS stuff with HOpenGL tonight, and then we can use that for testing
07:42:18 <dcoutts_> it should be a fairly easy add on however
07:42:29 <boegel> dcoutts_: I'm close to the source, so getting it to work shouldn't be a problem :)
07:42:36 <dcoutts_> :-)
07:43:03 <boegel> hmm
07:43:14 <boegel> how can I uninstall GHC in a clean way on Linux ?
07:44:51 <Itkovian> which distro?
07:45:16 <shelarcy> ah, I wanted to tell that I think GHC 6.2 includes HOpenGL. But this is old version - Lemmih said that.
07:45:29 <boegel> Itkovian: Fedora
07:45:47 <boegel> shelarcy: okay, I'll try and install GHC 6.4 then...
07:45:47 <Itkovian> hmm ... rpm -somethingtoremovesomethingelse
07:46:14 <boegel> rpm -erase probably
07:47:11 <boegel> okay Itkovian, thanks, should work I think
07:47:52 <Itkovian> maybe you can first try if 6.4 works before erasing?
07:49:27 <boegel> is 6.4-7 stable ?
07:49:33 <boegel> Itkovian: why shouldn't it work ?
07:49:42 <Itkovian> one never knows
07:49:57 <boegel> if it doesn't, I'll just re-install 6.2.2 :p
07:50:12 <boegel> my system should be formatted anyways, I'll do that in Aug
07:58:06 <Itkovian> :-)
07:58:23 <boegel> strange stuff :)
07:58:47 <Itkovian> gotta run ...
07:58:49 <Itkovian> ttyl
07:58:50 <boegel> bye
07:59:07 <xerox> Bye Itkovian.
07:59:39 <CosmicRay> has anyone here cared to try my wash packaging for 6.4?
08:02:58 * xerox dances happily
08:03:11 * boegel joins xerox 
08:03:21 <CosmicRay> at least isn't not canon
08:03:24 <xerox> boegel, wait to see!
08:03:39 <Lemmih> There's no -stop-after-th flag for GHC, right?
08:04:21 <boegel> I installed GHC 6.4 using the Fedora Haskell packages, but I'm experiencing two issues
08:04:36 <xerox> aiskiii: @help hoogle
08:04:37 <aiskiii>  @hoogle <expr>, Haskell API Search for either names, or types.
08:04:41 <xerox> @hoogle a -> [a]
08:04:42 <boegel> 1) I can only install 6.4.1, since .2 and .7 produce errors
08:04:42 <aiskiii> Prelude.repeat :: (a -> [a])
08:04:43 <lambdabot> http://www.w3.org/TR/REC-html40/struct/links.html
08:04:52 <xerox> \o/
08:04:52 <boegel> 2) with 6.4.1 installed, I can't run it :s
08:05:12 <xerox> aiskiii, @hoogle map
08:05:13 <aiskiii> Prelude.map :: ((a -> b) -> [a] -> [b])
08:05:18 <reffie> ..
08:05:45 <boegel> does anyone have any pointers how I can get it to work ? :s
08:06:14 <Lemmih> boegel: Did the try the RPM from haskell.org/ghc?
08:06:18 <xerox> aiskiii, @hoogle [a] -> [(a,a)]
08:06:19 <aiskiii> Prelude.zip :: ([a] -> [b] -> [(a, b)])
08:06:42 <boegel> well, they sent me too http://www.haskell.org/fedora/haskell
08:06:52 <boegel> I tried the RPM there, and that failed
08:07:10 <mflux_> aiskiii, @hoole a -> a
08:07:12 <mflux_> aiskiii, @hoogle a -> a
08:07:13 <aiskiii> Prelude.log :: Floating a => (a -> a)
08:07:14 <aiskiii> Prelude.log :: Floating a => (a -> a)
08:07:26 <xerox> mflux_, lambdabot tries to autocorrect, so nevermind of typos :-)
08:07:38 <Lemmih> boegel: Can't you install RedHat 9.0 RPMs?
08:07:46 <mflux_> ghc doesn't try to autocorrect, why should the bot!
08:07:46 <mflux_> ;)
08:07:53 <boegel> Lemmih: I'll try
08:08:09 <xerox> mflux_, it only tries to find similar @commands :)
08:08:20 <boegel> I figured the Fedora Haskell packages would be the best option
08:08:32 <ndm> ok, a -> a should definately give id, the class thing definately needs doing
08:08:55 <mflux_> aiskiii, @hoogle [a] -> [a]
08:08:56 <aiskiii> Prelude.tail :: ([a] -> [a])
08:09:10 <mflux_> maybe it could report many matches in a single row
08:09:53 <xerox> @hoogle a -> Maybe a
08:09:54 <aiskiii> Prelude.return :: Monad a => (b -> (a b))
08:09:56 <lambdabot> http://www.ipl.org/div/farq/
08:11:49 <neologism> @plugs map (+1) [1..3]
08:11:51 <aiskiii> Terminated
08:12:07 <lambdabot> [2,3,4]
08:12:20 <mflux_> maybe lambdabot and aiskiii could form a cluster and evaluate stuff in parallel (!)
08:12:23 <mflux_> or not
08:12:31 <mflux_> distributed computing over irc..
08:12:37 <xerox> I should probably have her quit.
08:14:14 <xerox> @quit
08:14:15 <lambdabot> not enough privileges
08:14:19 <xerox> Gotta go, later folks!
08:15:06 <boegel> bye xerox
08:33:32 <Lemmih> boegel: Is it working?
08:47:10 <lispy> does ghc (or haskell in general) have any code coverage tools?  I'm thinking something that allows you to see how much of your program has been covered by a test suite.
08:48:07 <dcoutts_> not so far as I'm aware.
08:48:15 <nothingmuch> 2-3 months ago pugs people looked into it
08:48:26 <nothingmuch> and it seemed that it was not very possible
08:48:40 <nothingmuch> but GHC has something called "ticky ticky" mode or something like that
08:48:51 <nothingmuch> where it generates a bajillion counters for everything and it's mother
08:49:02 <lispy> hmm...
08:49:12 <lispy> darcs could really use a tools like this
08:49:26 <nothingmuch> i have no clue what it looks like, how it's done, or whether it's useful, but it's purpose is that it's an intrusive profiling tool
08:49:39 <nothingmuch> (that is, it doesn't use interrupts, but instead modifies code)
08:50:00 <lispy> okay, thanks
08:50:15 <Lemmih> Greetings, mikael. You're not phubuh anymore?
08:50:29 <dcoutts_> I guess what you want is something that checks that each case statement's branches have been taken? perhaps someone could write one as a core->core transformation.
08:50:32 <mikael> not officially :-)
08:50:53 <lispy> dcoutts_: not sure what that means..
08:51:13 <dcoutts_> core is the lower level intermediate language used by ghc
08:51:26 <dcoutts_> ghc can emit and accept core files
08:51:46 <ndm> i know hat has a tool hat-coverage
08:51:46 <dcoutts_> you can write programs which transform these core files
08:51:55 <ndm> it takes a hat trace, and shows you the coverage
08:52:08 <dcoutts_> oh, that sounds good
08:52:13 <nothingmuch> but it's all an illusion, and it's really very simple
08:52:18 <nothingmuch> the reader monad is like a magician juggler
08:52:19 <ndm> but i'm not sure if its released yet
08:52:20 <nothingmuch> it pretends to be throwing so much in the air
08:52:45 <lispy> ndm: i'll try to look at it
08:53:18 <nothingmuch> if anyone has a free minute to donate to an idiot, please backlog #perl6, ca. 5 minutes ago, and tell me if my interpretation of Reader is correct
08:53:43 <ndm> lispy: hat-cover is in the latest hat releases
08:53:56 <ndm> and it does exactly what you seem to be wanting
08:55:12 <lispy> ndm: cool, hat looks nice
08:55:28 <ndm> it is, if you can get it buildig
08:55:34 <ndm> and transforming your program
09:07:46 <boegel> Lemmih: ghc 6.4 is working fine now
09:07:50 <boegel> but now gtk2hs is broken :)
09:07:58 <dcoutts_> :-(
09:08:07 <boegel> and using the RPM's from Fedora Haskell isn't working
09:08:14 <boegel> it complains it can't find ghc64 :s
09:08:37 <dcoutts_> I think the Fedora RPMs got updated to use the ghc 6.4 patch for gtk2hs 0.9.7
09:08:54 <dcoutts_> so it should work, otherwise complain to juhp :-)
09:09:48 <dcoutts_> on the other hand it may not be worth it, the first gtk2hs 0.9.8 release candidate is but hours away...
09:10:20 <boegel> hmm okay...
09:10:27 <boegel> I'll wait then I guess
09:10:40 <boegel> but I think I'll have to change my HRay implementation according to it
09:11:10 <dcoutts_> actually it'll be several days before a final 0.9.8 release and probably a day or two longer for Fedora RPMs to come out.
09:11:48 <boegel> but those crappy things aren't working
09:11:51 <boegel> I don't geti t
09:12:14 <boegel> dcoutts_: http://studwww.ugent.be/~kehoste/gtk2hsError.png
09:12:20 <dcoutts_> does HRay have a darcs repo?
09:12:20 * boegel is off for lunch
09:12:28 <dcoutts_> I'll take a look...
09:12:29 <boegel> dcoutts_: yep, check the website
09:12:41 <dcoutts_> oh good
09:12:43 <boegel> dcoutts_: do you have the url ?
09:12:52 <dcoutts_> I'm sure I'll find it
09:12:56 <boegel> kay :)
09:13:08 <boegel> of course you have the url, it's on the gtk2hs (stupid me)
09:13:37 <Lemmih> boegel: Can't you ignore that dependency?
09:13:51 <dcoutts_> boegel, oh, btw we've decided to have more news on our front page, so you may well get your HRay announcement
09:14:54 <boegel> dcoutts_: cool
09:14:58 <boegel> Lemmih: dunno how :)
09:15:08 <boegel> does rpm have such an option ?
09:15:24 <dcoutts_> boegel, you're running FC3 right?
09:17:14 <dcoutts_> boegel, I don't know why you're getting that error, ghc64 is in the FC3 repo at: http://haskell.org/fedora/haskell/3/i386/RPMS.stable/
09:17:37 <dcoutts_> maybe you just need to sync the cache or something, what ghc rpm do you have installed?
09:21:53 <mikael> ten points to the inventor of a good name for the function of type ``Monad m => [a -> m b] -> a -> m [b]''
09:22:06 <mikael> this is pretty much the hardest part of functional programming
09:22:48 <mikael> not that there's anything particularly wrong with `frob'!
09:24:16 <Lemmih> invMapM?
09:25:05 <Lemmih> Maybe not.
09:25:14 <mikael> you're onto something
09:25:30 <dcoutts_> I've got a good name for it: \fs x -> sequence [ f x | f <- fs]
09:25:34 <dcoutts_> no?
09:26:05 <mikael> oh, that's a nice way to write it
09:27:23 <Igloo> Or  \fs x -> mapM ($ x) fs
09:27:46 <dcoutts_> nice
09:27:53 <mikael> that's what I had written :-)
09:28:00 <ski> rmap/pam :: [a -> b] -> a -> [b] is in hawiki/PreludeExts
09:28:13 <dcoutts_> now we just need it point free...
09:28:24 <mikael> flip (mapM . flip id)
09:28:27 * mikael cheated :-P
09:28:41 <ski> "rmap fs x = map ($ x) fs -- or pointlessly, pam = flip (map . flip ($))"
09:29:07 <dcoutts_> so that gives a name of pamM or rmapM no?
09:29:33 <ski> yeah, prolly
09:30:10 <mikael> yes, that's good
09:30:13 <ski> me sometimes uses pam :: [a] -> (a -> b) -> [b]  pam = flip map
09:30:31 <ski> (for infix like :  someList `pam` \element -> ...)
09:30:44 <dcoutts_> yes, that's handy sometimes
09:30:54 <dcoutts_> so rmapM then :-)
09:31:09 <ski> one can also do : (`map` someList) $ \element -> ...
09:32:13 <dcoutts_> or using list comprehensions makes it quite readable if you align things right
09:32:27 <dcoutts_> [ blah
09:32:33 <dcoutts_> | foo <- bar ]
09:33:15 * boegel wonders what he has done wrong...
09:33:16 <ski> that doesn't work with monadic maps
09:33:33 <boegel> ah, I haven't updated my system in ages, that might be the problem
09:33:49 <boegel> and the rpm via the website is only 300KiB or so, I thought that was too small :s
09:33:57 <dcoutts_> yes, you'd need a sequence/sequence_ at the beginning for monadic maps
09:34:23 <dcoutts_> boegel, yes, try more like 17Mb :-)
09:34:24 <ski> for your function maybe
09:34:41 <boegel> strange that the link is different on the Fedora Haskell page
09:34:46 <SamB> dcoutts: wouldn't you just use mapM/liftM?
09:34:55 <ski> dcoutts : i was speaking of stuff like  (`liftM` someAction) $ \value -> ...
09:35:24 <dcoutts_> ski, oh right
09:36:14 <ski> hm, mm
09:36:17 <dcoutts_> SamB, for monadic stuff, yes probably I would. I was just noting that I'd recently rediscovered list comprehensions and they're often rather neat.
09:36:32 <SamB> dcoutts: oh.
09:36:52 <SamB> is that in "evolution of a haskell programmer"?
09:37:04 <SamB> I suppose that doesn't really make it into fib...
09:37:24 <dcoutts_> you mean going round and comming back to nice simple list comprehensions :-)
09:37:51 * boegel would like a "x ? f1 : f2" notation for Haskell
09:38:22 <SamB> I mean using them initially, then forgetting about them amongst all the maps and folds and such, and then revisitting them when you realize how nice it is to be able to pattern match like that and filter out only the things you want?
09:38:38 <dcoutts_> SamB, yes exactly.
09:38:40 <SamB> boegel: if x then f1 else f2
09:39:06 <boegel> SamB: yeah, I know, but I think one should use 'if' and 'else' when you have more than one statement in it
09:39:32 <Igloo> if/then/else is built out of expressions, not lists of statements
09:39:40 <ski> SamB : though of course one can use the list monad for the same effect as list-compr.
09:39:44 <SamB> boegel: doesn't that require a do?
09:40:34 <SamB> I haven't actually got around to the part where I use them again, but I have got to the part where I remembered about them and am thinking they could be really handy for something I'm going to do pretty soon...
09:40:36 <boegel> SamB: it might :) but I like a notation using symbols better
09:40:58 <SamB> I wish it didn't require more dos...
09:41:14 * boegel is listening to Funeral Dress and is loving it
09:41:23 <boegel> Irish music rules !
09:41:51 <ski> boegel : C64 remixes also rules :)
09:42:04 <boegel> ski: ?
09:42:28 <ski> remixes of Commodore 64 game music and demo music
09:42:53 <lispy> nice
09:42:54 <boegel> okay dcoutts_, it works now
09:43:00 <dcoutts_> cool
09:43:05 <boegel> ski: heh :s
09:43:15 <lispy> boegel: do you like Amadan?  (you've probably never heard of them...)
09:43:24 <SamB> @plugs let cond ? ifTrue ifFalse = if cond then ifTrue else ifFalse in (True ? 1 $ 2)
09:43:25 <boegel> lispy: don't know 'em
09:43:26 <lambdabot> Parse error in pattern
09:43:27 <lispy> boegel: they are irish pub style, but from the US
09:43:30 <Trevion> Am I missing an nth root function somewhere in the Prelude?
09:43:38 <boegel> lispy: do you know Flogging Molly ?
09:43:41 * ski is listening to Pex "Mahoney" Tufvesson - Lightforce (Motorhead-mix ala Ollas)
09:43:42 <SamB> hmm, I guess ? isn't a valid operator name...
09:43:42 <lispy> boegel: ah yes
09:43:53 <SamB> @ghci let cond ? ifTrue ifFalse = if cond then ifTrue else ifFalse in (True ? 1 $ 2)
09:43:54 <lambdabot>  bindings for unlifted types aren't allowed
09:43:59 <lispy> boegel: amadan is small time, but they get compplements from real irish groups
09:44:08 <boegel> lispy: they rule ! I saw them live last year, didn't know them before, and I was dancing like crazy :)
09:44:15 <lispy> boegel: hehe
09:44:18 <boegel> lispy: ok, I'll check 'em out
09:44:33 <SamB> hmm, I think lambdabot spell-corrected @ghci to @ghc...
09:44:41 <boegel> I just can't stay still while listening to Flogging Molly
09:44:51 <SamB> @ghci let cond .?. ifTrue ifFalse = if cond then ifTrue else ifFalse in (True .?. 1 $ 2)
09:44:53 <lambdabot>  Can't reify a non-Haskell-98 data constructor
09:44:57 <SamB> @plugs let cond .?. ifTrue ifFalse = if cond then ifTrue else ifFalse in (True .?. 1 $ 2)
09:44:59 <lambdabot> Parse error in pattern
09:45:19 <lispy> boegel: heh
09:45:39 <boegel> dcoutts_: did you find the HRay darcs repo ?
09:46:15 <SamB> boegel: what would you like instead of ? for the operator?
09:46:37 <ski> @plugs let (cond ? ifTrue) ifFalse = if cond then ifTrue else ifFalse in (True ?) 1 2
09:46:39 <lambdabot> 1
09:46:51 <SamB> oh
09:46:52 <ski> @plugs let (cond ?) ifTrue ifFalse = if cond then ifTrue else ifFalse in (True ?) 1 2
09:46:53 <boegel> SamB: I just mean a C-like notation, instead of using if and else keywords
09:46:53 <lambdabot> Parse error in pattern
09:46:57 <ski> bah
09:47:14 <dcoutts_> @plugs let (cond ? a) b = if cond then a else b in True ? 2 $ 3
09:47:15 <Lemmih> @plugs let (?) x | x = fst | otherwise = snd in True ? ('a','b')
09:47:16 <lambdabot> 2
09:47:17 <lambdabot> 'a'
09:47:25 <ski> SamB : only infix operators (except prefix -)
09:48:08 <dcoutts_> so that works fine, you can use ? as an infix operator
09:48:45 <boegel> Lemmih: you've been improving the stuff I added to the HaskLS page ? :)
09:48:47 <lispy> i used to hate C's  a ? b : c (ternary operator) but then learned functional programming and realized it's a functional version of if
09:49:00 <Igloo> SyntaxNinja: When you said I had mail, I think you were lying...
09:49:07 <SamB> boegel: the thing is most of the one-char punctuation has been taken
09:49:11 <Lemmih> boegel: Yepper.
09:49:28 <SyntaxNinja> Igloo: I sent a followup to you and the debian-haskell list. CosmicRay did you get it?
09:49:36 <boegel> Lemmih: how come the tut stuff won't work for HOpenGL 2.0 ?
09:49:45 <SyntaxNinja> gmail _thinks_ I sent it.
09:49:59 <dcoutts_> boegel, yes found the HRay darcs repo
09:50:03 <Lemmih> boegel: HOpenGL-1.0 doesn't have the same interface as HOpenGL-2.0
09:50:03 <Igloo> I didn't see it in the archives either...
09:50:54 <boegel> Lemmih: are there any tuts for 2.0 then ?
09:51:30 <Lemmih> boegel: I'm not sure. 2.0 came out together with GHC 6.4 so it's pretty new.
09:52:49 <boegel> Lemmih: oh, okay, I see
09:53:11 <SyntaxNinja> Igloo: hohum.  It's hard to tell w/ gmail because it always shows the stuff you sent.
09:53:53 <Igloo> Anyway, can you resend it please?
09:53:57 <SyntaxNinja> yeah
09:54:03 <Igloo> ta
09:54:39 <boegel> Lemmih: how much nicer is HOpenGL 2.0 ?
09:55:18 <SyntaxNinja> Igloo: sent
09:55:54 <boegel> Lemmih: there's nothing about 2.0 on the HOpenGL website ? that's pretty strange
09:56:51 <Lemmih> I believe HOpenGL-1.5 is missing texture support or something like that...
09:57:13 <boegel> the website only mentions 1.05, and then it just stops
09:57:17 <boegel> http://www.haskell.org/HOpenGL/releases.html
09:59:43 <Lemmih> They mention the move to the fptools in the status page.
10:01:24 <SamB> @index getArgs
10:01:24 <lambdabot> System.Environment
10:02:16 <SamB> @index stderr
10:02:17 <lambdabot> System.IO
10:04:00 * boegel doesn't know how to use fptools
10:08:29 * boegel leaves for a while
10:12:01 * ski hums along with a very good melody
10:16:05 <SamB> @index exit
10:16:08 <lambdabot> bzzt
10:26:14 <lispy> @index atExit
10:26:16 <lambdabot> bzzt
10:31:45 <SamB> something is wrong with my unlambda interpreter...
10:32:54 <sylvan> I wonder when HOpenGL will support fragment and vertex programs, as well as frame buffer objects...
10:33:29 <sylvan> Until then, Haskell is basically ruled out for any serious graphics app since it's impossible to do _anything_ besides the extremly basic stuff
10:34:39 <Lemmih> What are fragment and vertex programs?
10:36:42 <SamB> there are many different kinds of graphics apps...
10:38:22 <dcoutts_> fragment and vertex programs (if I understand correctly) are little programs that get loaded into the OpenGL rendering pipeine to customise it
10:39:06 <dcoutts_> they can operate on the 3D vertexes or the 2D textures/resulting 2D birmap
10:39:38 <dcoutts_> modern graphics cards run these little programs in the hardware
10:40:01 <dcoutts_> they can be used to achieve special effects like bump mapping I believe
10:40:17 <dcoutts_> or programatically generated textures
10:44:19 <xerox> Back in black.
10:44:57 <lispy> dcoutts_: that's the way i understand it as well
10:45:22 <dcoutts_> I've no idea what language the programs are written in however
10:45:35 <lispy> dcoutts_: there is a shader language
10:45:51 <lispy> dcoutts_: but i believe it just gets turned into a specalized machine code
10:47:11 <dcoutts_> ie the OpenGL driver handles turning it into machine code foe the specific graphics hardware (eg ATI/NVidia etc)?
10:47:26 <xerox> What is this?  |case () of {_ | cond1 -> expr1 | cond2 -> expr2 | otherwise -> expr3 }|
10:49:06 <SamB> xerox: haskell actually has braces and semis like C. it just usually hides them really well.
10:49:34 <xerox> SamB, I can't understand the '_'.
10:49:41 <SamB> oh, that.
10:50:03 <SamB> okay, thats basically the same idea as COND in lisp...
10:50:39 <lispy> er?
10:50:39 <SamB> _ means "I don't care what the value is" in pattern matching...
10:50:47 <lispy> ah
10:50:52 <xerox> Yes but..
10:51:14 <SamB> its basically just using the case statement for guards...
10:51:17 <dcoutts_> xerox, so it's abusing the case syntax to do conditionals rather than pattern matching
10:51:37 <SamB> er, case form...
10:52:13 <xerox> dcoutts_, any sane way to do it?
10:52:16 <lispy> dcoutts_: i'm not sure if the opengl driver handles that, but you're probably right, maybe a just in time sort of compilation by the driver
10:52:26 <lispy> the fragments are often very small
10:52:53 <dcoutts_> xerox, the expression being scrutinised is unit (), the patterns are all don't care _ so it's just the conditionals after the guards | that are the bit being used in that construct
10:53:34 <dcoutts_> xerox, people normally don't write that sort of code since the normal named function with guards can be used most of the time
10:54:32 <dcoutts_> but if you really wanted the list of guards thing and you were in an expression context (and you didn't want to just use a local named function) then you could use that form (but I wouldn't)
10:55:16 <dcoutts_> lispy, someone should re-write PAN to target the OpenGL shader language :-)
10:56:40 <xerox> aiskiii, @hoogle (a -> b) -> [a] -> [b]
10:56:42 <aiskiii> Prelude.map :: ((a -> b) -> [a] -> [b])
10:57:09 <xerox> OK...
10:57:17 <xerox> aiskiii, @hoogle explode!
10:57:18 <aiskiii> Terminated
10:57:37 <xerox> aiskiii, @quit byebye
10:57:38 <CosmicRay> dcoutts: in haskell?
10:58:00 <dcoutts_> CosmicRay, well the original version of PAN produced C code
10:58:10 <dcoutts_> but was written in Haskell of course
10:59:23 <xerox> If GHC says "compilation IS NOT required", does it compile anyway or does it need some flag to avoid it for real?
10:59:49 <dcoutts_> xerox, it skips compilation
10:59:56 <dcoutts_> nothing extra needed
11:00:00 <xerox> Good.
11:00:21 <xerox> I was asking because it takes a while to go to the next file anyway.
11:05:42 <mflux_> there is no typeclass for making things appear to be like lists, is there?
11:05:44 <mflux_> how about plans for?
11:06:11 <mflux_> I suppose often a conversion function (in a lazy language) is sufficient though
11:06:17 <xerox> forall (m :: * -> *) a. m a  ? :-)
11:06:18 <lispy> dcoutts_: it does target opengl shaders afaik
11:06:29 <mflux_> maybe infact even better, as it allows to parametrize the view
11:06:45 <lispy> dcoutts_: i know it's pretty much all shader based
11:06:50 <Igloo> SyntaxNinja: Did you get my reply, BTW?
11:06:58 * Igloo can talk here if you prefer
11:07:05 <lispy> dcoutts_: and it does generate some sort of shaders, just maybe not OpenGL sharders
11:07:11 * CosmicRay suspects we are talking about different PANs
11:07:16 <CosmicRay> I know PAN as a newsreader
11:07:26 <lispy> CosmicRay: hehe, this one is by Conal Elliot
11:07:44 <CosmicRay> ah, indeed that is rather different :-)
11:08:57 <dcoutts_> lispy, I think the original PAN targeted GNU C and Conal Elliot's latest version targets C#/.NET I think.
11:09:09 <shelarcy> Sean Seefried wrote OpenGL version Pan, but read and save Bitmap file function is not implemented .
11:09:20 <shelarcy> http://www.cse.unsw.edu.au/~sseefried/pan/index.html
11:09:55 <shelarcy> It doesn't use any Shader Language.
11:12:11 <sylvan> conal elliot also produced Vertigo, an embedded language for writing shaders in Haskell (which compiles to C# and v2.0 shaders asm IIRC)
11:13:01 <dcoutts_> sylvan, so it does target shaders. Interesting.
11:13:46 <sylvan> I'm not sure about Pan, but Vertigo does
11:13:54 <dcoutts_> right
11:14:01 <Heffalump> CosmicRay: what namespace did you put your python embedding in?
11:14:09 <sylvan> via C# though.. It would be sweet if we could load up shaders in HOpenGL but for that we need the vertex and fragment program extensions
11:14:26 <dcoutts_> sylvan, indeed
11:15:27 <sylvan> as well as the frame buffer object extension to facilitate render-to-texture without an opengl context switch (expensive) which is pretty much needed for all the cool new things (like post-processing effect by "ping-pong"-rendering between two targets using various pixel shaders to filter the texture over and over, or doing simple things like shadow maps efficiently)
11:16:48 <xerox> Where can I find some text about what is "liftIO" ?
11:17:36 <xerox> Haddock documentation doesn't have any written comment.
11:24:15 <xerox> Itkovian!
11:24:45 <Itkovian> hi xerox!
11:24:47 <CosmicRay> xerox: try one of:
11:24:50 <CosmicRay> http://www.engr.mun.ca/%7Etheo/Misc/haskell_and_monads.htm
11:24:50 <xerox> Itkovian, do you have any urls talking about liftIO ?
11:24:57 <CosmicRay> http://www.cs.pdx.edu/%7Eantoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html
11:24:58 <Itkovian> nope
11:25:07 <CosmicRay> http://www.nomaware.com/monads/html/
11:25:10 <Itkovian> now I might :-)
11:25:11 <CosmicRay> xerox: CosmicRay might :-)
11:25:23 <Itkovian> anyway, I'm off ain a few, gotta wash my kid
11:25:32 <CosmicRay> that last one I *know* talks about it
11:25:34 <CosmicRay> the others probably do
11:25:50 <xerox> CosmicRay, great.  Thanks.
11:26:43 <CosmicRay> xerox: also, there is an example at http://quux.org/devel/missingh/html/MissingH.ConfigParser.html
11:26:57 <CosmicRay> where it lifts the IO monad into the Error monad
11:27:32 <xerox> CosmicRay, it is "lifting" because it's not "exiting", right?
11:27:52 <CosmicRay> yeah pretty much
11:28:31 <xerox> Is it like packing the IO a in some IO (m a) ?
11:28:44 <CosmicRay> I think so, but I never did understand it well
11:29:56 <xerox> IO a -> MonadIO (m a)  --  probably more correct.
11:30:35 <xerox> @google hoogle haskell
11:30:37 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/hoogle/
12:00:28 <sqrt> Hi,
12:13:45 <xerox> @index MonadIO
12:13:48 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
12:13:48 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
12:13:48 <lambdabot> Monad.Error, Control.Monad.List
12:14:00 <xerox> @type Control.Monad.Trans.MonadIO
12:14:06 <lambdabot> bzzt
12:14:07 <xerox> @info Control.Monad.Trans.MonadIO
12:14:09 <lambdabot> Unknown command, try @listcommands.
12:14:17 <xerox> @libsrc Control.Monad.Trans
12:14:18 <lambdabot> http://darcs.complete.org/fptools/libraries/mtl/Control/Monad/Trans.hs
12:15:23 * Lemmih wonders if boegel got some pretty haskls graphics for him.
12:15:52 <xerox> instance (MonadIO m) => MonadIO (ListT m) where
12:15:53 <xerox> 	liftIO = lift . liftIO
12:15:57 <xerox> !?!?!
12:17:59 <reffie> xerox did you hear the great news?
12:18:32 <xerox> reffie, you're so selfish.
12:18:40 <reffie> xerox ?
12:19:13 <reffie> btw
12:19:22 <reffie> why aren't you on #verbaetc anyomre?
12:19:47 <xerox> reffie, because of that person, you know.  But I miss the others.
12:20:01 <reffie> dialtone?
12:20:07 <xerox> Yep.
12:20:12 <reffie> he put me on ignore :)
12:20:17 <reffie> he's an idiot
12:20:20 <jlouis> We'll packet him to death ;)
12:20:26 <xerox> :-)
12:20:28 <reffie> :D
12:20:36 <jlouis> Let me just get this Haskell Zombie written...
12:20:56 <jlouis> (It CAN'T possibly be larger in .exe size than a VB zombie)
12:21:06 <jlouis> .... oh ... it was ghc... it was...
12:21:09 <jlouis> hehe
12:21:17 <xerox> ^__^
12:21:24 <xerox> Anyway I can't understand that code.
12:21:49 <SamB> how do I parse options in haskell?
12:22:01 <jlouis> SamB: there is a hierachial library for that
12:22:06 <Lunar^> SamB: or use pesco's
12:22:31 <SamB> @google pesco command line arguments haskell
12:22:33 <lambdabot> http://www.scannedinavian.org/~pesco/man/html3/Optspec.3hs-System-
12:22:33 <lambdabot> Console-Cmdline-Pesco.html
12:22:52 <jlouis> SamB: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.Console.GetOpt.html
12:23:06 <jlouis> it is quite evil, however
12:29:56 <dcoutts_> jlouis, I used to work for an anti virus company. I really wanted to write a proof on concept virus in Haskell and send it to our virus lab just to see if they could make any sense of the ghc rts at the assembler lever. :-)
12:30:11 <Heffalump> :-)
12:30:12 <wilx> Heh.
12:31:21 <dcoutts_> then of course the next thing would be to write a highly polymorphic virus, that knows it's own source code AST and applies aggressive code transformations to it.
12:31:21 <jlouis> dcoutts_: heh, prior-art for my idea. eek.
12:32:07 <dcoutts_> Heffalump, it could use your program and apply a random set of optimisations/deoptimisations
12:32:30 <Heffalump> :-)
12:32:50 <Heffalump> unfortunately the whole "having a compiler optimiser in the virus" thing might make it rather easy to spot..
12:33:06 <xerox> instance (MonadIO m) => MonadIO (ListT m) where
12:33:06 <xerox> 	liftIO = lift . liftIO
12:33:12 <xerox> Who can explain this? :-)
12:33:46 <jlouis> xerox: make ListT a member of the MonadIO class
12:33:49 <Heffalump> do you understand what MonadIO is?
12:34:01 <dcoutts_> Heffalump, well the thing is if you use a general purpose optimiser then it's not really fair to recoginse the general purpose library, or to just recognise the ghc rts for example
12:34:22 <xerox> jlouis, I can't understand 1) how does it work 2) how can I use it.
12:34:39 <Heffalump> MonadIO is a type class for any monad that encapsulates IO operations.
12:34:54 <dcoutts_> anyway, all the Haskell code would be subject to the random transformations, including the transformation framework. The only constant bit would be the behaviour pattern and the ghc rts.
12:35:17 <xerox> Heffalump, I'm trying to understand what liftIO exactly does, and why :-)
12:35:50 * Lemmih hands a black hat to dcoutts_.
12:35:55 <Heffalump> when you write code for a MonadIO monad, and you want to do an IO operation, you do somethig like:
12:36:05 <Heffalump> do ...
12:36:10 <Heffalump>    liftIO $ putStr "foo"
12:36:28 <Heffalump> liftIO :: MonadIO m => IO a -> m a
12:36:37 <Heffalump> i.e. it lifts an IO operation into any other monad that can do IO operations
12:37:03 <xerox> And those monads who can, should all be non-returing monads, right?
12:37:06 <genneth> surely liftIO $ putStr "foo" would just give IO () ?
12:37:09 <xerox> I mean, one-way monads.
12:37:38 <Heffalump> xerox: yes
12:37:48 <xerox> Hmmm.
12:37:51 <Heffalump> the only IO-like monads you can get are made by layering monad transformers on top of IO
12:38:12 <Heffalump> so they're one-way for the same reason that IO is, i.e. lack of an IO a -> a operation
12:38:34 <jlouis> in fact liftIO is kind of a special case of lift
12:38:38 <xerox> Oh.. so ListT /= []
12:40:49 <xerox> How does ListT differ from [] ?
12:42:35 <ski> ListT m a ~= m [a]
12:42:50 <xerox> What does "~=" mean? :-)
12:43:01 <reffie> good question
12:43:10 <reffie> equivalent?
12:43:12 <xerox> Like = with a ~ ontop?
12:43:13 <reffie> yeah
12:43:14 <reffie> that's it
12:43:33 <xerox> @type Control.Monad.List.ListT [1,2,3]
12:43:41 <lambdabot> Control.Monad.List.ListT [1,2,3] :: forall a.
12:43:41 <lambdabot>             (Num [a]) =>
12:43:41 <lambdabot>             Control.Monad.List.ListT [] a
12:44:26 <jlouis> \simeq in LaTeX IIRC
12:45:04 <xerox> I'm not completely getting it, anyway.
12:50:38 <jlouis> xerox: A ListT encompasses a List of type alpha inside a monad m
12:51:32 <xerox> How can it contain mutiple elements (being a List) without m = [] ?
12:52:18 <wagle> if m == [], then ListT [] [a] == [[a]]..  ( ithink)
12:52:35 <jlouis> sounds plausible
12:54:34 <xerox> wagle, but how is it a list, if m /= [] ?
12:55:10 <wagle> if m == Maybe, then ListT Maybe [a] == Maybe[a]..  ( i think)
12:55:41 <Leadhyena> wagle: wait... why not Maybe [[a]]?
12:55:43 <wagle> eating lunch, else i would check
12:55:55 <dcoutts_> Lemmih, just in case you were worried about the colour of my hat, I left the anti-virus company to do a PhD. I wasn't fired for writing viruses :-)
12:56:04 <xerox> m == Maybe  =>  List Maybe a  ~=  [Maybe a]
12:56:07 <xerox> Theoretically.
12:56:19 <dcoutts_> which is to say, I didn't write any, not that I was never caught :-)
12:56:24 <xerox> s/List/ListT/
12:56:28 <Lemmih> dcoutts_: (:
12:56:30 <Leadhyena> xerox: but ListT is a transform monad, not a cap monad right?
12:56:50 <xerox> Leadhyena, what do you mean by "cap" ?  Anyway I think I agree.
12:57:05 <wagle> xethat would make ListT more interesting..
12:57:18 <jlouis> dcoutts_: shouldn't that be the luminance of the hat rather than the chrominance?
12:57:46 <Leadhyena> sorry, I make up my own terminology sometimes... I call it a cap monad, short for encapsulate, because it encapsulates the monad inside it
12:57:51 <xerox> wagle, I'm very very attracted as now, but I can't understand how to use this little light we see at the end of the tunnel :-)
12:57:56 <Leadhyena> so List Maybe a is [Maybe a]
12:58:10 <Leadhyena> but ListT Maybe A is Maybe [A]... I think
12:58:23 * xerox mumbles.
12:58:26 <Leadhyena> not sure though... still a lot to learn about monads I have
12:58:32 <dcoutts_> jlouis, I suppose so :-)
12:58:42 <ski> ListT Maybe a is Maybe [a], yes
12:58:44 <xerox> @type Control.Monad.ListT (Just 1)
12:58:52 <lambdabot> bzzt
12:58:55 <wli> Just cook up a bunch of combinators.
12:58:56 <xerox> @type Control.Monad.List.ListT (Just 1)
12:58:58 <lambdabot> Control.Monad.List.ListT (Just 1) :: forall a.
12:58:58 <lambdabot>              (Num [a]) =>
12:58:58 <lambdabot>              Control.Monad.List.ListT Maybe a
13:01:14 <xerox> @plugs lift [1,2,3] :: Num a => ListT [] a
13:01:19 <lambdabot> Variable not in scope: `lift'
13:01:46 <xerox> @index lift
13:01:48 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
13:01:48 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
13:01:48 <lambdabot> Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
13:01:48 <lambdabot> ParserCombinators.ReadPrec, Text.Read
13:02:02 <xerox> @plugs Control.Monad.Trans.lift [1,2,3] :: Num a => Control.Monad.List.ListT [] a
13:02:03 <lambdabot> Variable not in scope: `Control.Monad.Trans.lift'
13:02:14 <xerox> @plugs Control.Monad.List.lift [1,2,3] :: Num a => Control.Monad.List.ListT [] a
13:02:16 <lambdabot> Variable not in scope: `Control.Monad.List.lift'
13:03:23 <wagle> @type Control.Monad.List.maplistT
13:03:25 <lambdabot> bzzt
13:03:34 <wagle> @type Control.Monad.List.mapListT
13:03:36 <lambdabot> Control.Monad.List.mapListT :: forall b
13:03:36 <lambdabot>              (n :: * -> *)
13:03:36 <lambdabot>              a
13:03:36 <lambdabot>              (m :: * -> *).
13:03:36 <lambdabot>            (m [a] -> n [b])
13:03:36 <lambdabot>            -> Control.Monad.List.ListT m a
13:03:38 <lambdabot>            -> Control.Monad.List.ListT n b
13:03:42 <Leadhyena> lambdabot can be quite rude about that
13:04:00 <wagle> ^^ thats the main thing
13:04:02 <xerox> mapListT :: (m [a] -> n [b]) -> ListT m a -> ListT n b
13:04:02 <xerox> mapListT f m = ListT $ f (runListT m)
13:04:24 * xerox is a bit overtaken by this code :-)
13:05:38 <Leadhyena> I think I understand now... you can't life a normally capped monad like List Maybe a but you can lift into ListT Maybe a
13:06:28 <Leadhyena> otherwise they're both like [Maybe a], right?
13:06:40 <Leadhyena> ^life^list^
13:07:05 <wagle> @plugs Control.Monad.List.mapListT (+1) (Just [1,2,3](
13:07:07 <lambdabot> parse error on input `;'
13:07:09 <wagle> @plugs Control.Monad.List.mapListT (+1) (Just [1,2,3])
13:07:11 <lambdabot> Variable not in scope: `Control.Monad.List.mapListT'
13:07:25 <wagle> waugh
13:07:56 <wagle> @plugs mapListT (+1) (Just [1,2,3])
13:07:58 <lambdabot> Variable not in scope: `mapListT'
13:08:08 <wagle> @plugs mapList (+1) (Just [1,2,3])
13:08:10 <lambdabot> Variable not in scope: `mapList'
13:08:16 <wagle> @plugs Control.Monad.List.mapList (+1) (Just [1,2,3])
13:08:18 <lambdabot> Variable not in scope: `Control.Monad.List.mapList'
13:08:25 <xerox> Isn't it  |mapListT (+1) $ lift (Just [1,2,3])| ?
13:09:04 <Leadhyena> @tupe Control.Monad.lift
13:09:06 <lambdabot> bzzt
13:09:07 <Leadhyena> oops
13:09:26 <xerox> @libsrc Control.Monad.Trans
13:09:27 <lambdabot> http://darcs.complete.org/fptools/libraries/mtl/Control/Monad/Trans.hs
13:09:39 <wagle> it doesnt recognize the symbol
13:09:51 <ski> @type Control.Monad.Trans.lift
13:09:53 <lambdabot> Control.Monad.Trans.lift :: forall (t :: (* -> *) -> * -> *)
13:09:53 <lambdabot>             a
13:09:53 <lambdabot>             (m :: * -> *).
13:09:53 <lambdabot>           (Control.Monad.Trans.MonadTrans t, Monad m) =>
13:09:53 <lambdabot>           m a -> t m a
13:10:45 <Leadhyena> ah... okay... so m has to be a function to accept the lift
13:10:54 * ski wonders why mapListT is not in scope. what is reachable from @plugs ?
13:11:22 <xerox> @type Control.Monad.Trans.lift (Just [1,2,3])
13:11:25 <lambdabot> Control.Monad.Trans.lift (Just [1,2,3]) :: forall (t :: (* -> *)
13:11:25 <lambdabot>                    -> * -> *)
13:11:25 <lambdabot>                  a.
13:11:25 <lambdabot>                (Control.Monad.Trans.MonadTrans t, Num a) =>
13:11:25 <lambdabot>                t Maybe [a]
13:11:47 <xerox> @type Control.Monad.Trans.lift (Just [1,2,3]) :: Num a => Control.Monad.List.ListT Maybe a
13:11:49 <lambdabot> bzzt
13:11:58 * xerox is going nuts.
13:14:16 <ski> @type Control.Monad.Trans.lift "apa"
13:14:17 <lambdabot> Control.Monad.Trans.lift "apa" :: forall (t :: (* -> *) -> * -> *).
13:14:17 <lambdabot>             (Control.Monad.Trans.MonadTrans t) =>
13:14:17 <lambdabot>             t [] Char
13:14:41 <Leadhyena> @type Control.Monad.Trans.lift (+1)
13:14:42 <lambdabot> Control.Monad.Trans.lift (+1) :: forall (t :: (* -> *) -> * -> *)
13:14:42 <lambdabot>               a.
13:14:42 <lambdabot>            (Control.Monad.Trans.MonadTrans t, Monad ((->) a), Num a)
13:14:42 <lambdabot> =>
13:14:42 <lambdabot>            t ((->) a) a
13:14:51 <ski> @type Control.Monad.Trans.lift (Just 'a') :: Control.Monad.List.ListT Maybe Char
13:14:52 <lambdabot> Control.Monad.Trans.lift (Just 'a') :: Control.Monad.List.ListT
13:14:52 <lambdabot> Maybe Char :: Control.Monad.List.ListT Maybe
13:14:52 <lambdabot>                                    Char
13:15:37 <xerox> So it is  |Maybe Char -> ListT Maybe Char|  ?
13:15:45 <ski> so that should evaluate to ListT (Just ['a']), then
13:15:53 <wagle> @type Control.Monad.Trans.lift
13:15:55 <lambdabot> Control.Monad.Trans.lift :: forall (t :: (* -> *) -> * -> *)
13:15:55 <lambdabot>             a
13:15:55 <lambdabot>             (m :: * -> *).
13:15:55 <lambdabot>           (Control.Monad.Trans.MonadTrans t, Monad m) =>
13:15:55 <lambdabot>           m a -> t m a
13:16:04 <ski> think so
13:16:23 <ski> t is ListT, m is Maybe
13:16:56 <ski> so lift adds a trivial internal ListT level, inside the Maybe   (looking at how it's implemented)
13:17:15 <xerox> @libsrc Control.Monad.Maybe
13:17:16 <lambdabot> Control.Monad.Maybe not available
13:17:21 <xerox> @index lift
13:17:22 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
13:17:22 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
13:17:22 <lambdabot> Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
13:17:22 <lambdabot> ParserCombinators.ReadPrec, Text.Read
13:17:31 <xerox> Hmm.
13:17:36 <xerox> Where? :-)
13:17:43 <ski> where what ?
13:18:45 <xerox> Are you talking of this instance: |instance MonadTrans ListT where|  ?
13:23:09 * ski just wondered what xerox was looking for and couldn't find
13:24:10 <ski> (hm, yes, that instance would maybe possible for 't' to be 'ListT' above, right ?)
13:24:19 <ski> s/maybe/make/
13:24:40 <ski> (^ sematic typo :)
13:24:44 <ski> semantic
13:24:49 <boegel> Lemmih: no graphics yet, I was with my gf and was watching a tsunami documentary on tv
13:26:49 <boegel> does anyone know how to get something out of the fptools darcs repo ?
13:29:36 <xerox> ski, I was trying to understand what you said at: <ski> so lift adds a trivial internal ListT level, inside the Maybe   (looking at how it's implemented)
13:34:09 <ski> (this instance of)  lift :: Maybe Char  ->  ListT Maybe Char ~= Maybe [Char]
13:34:41 <ski> so it adds a trivial list ( [] ) level inside the Maybe
13:35:44 <Leadhyena> looking at |mapListT (+1) $ lift (Just [1,2,3])|
13:35:47 <ski> (trivial meaning here : a singleton list, just as return just constructs a trivial list level)
13:36:23 <Leadhyena> oops nm thinking List Maybe not Maybe List
13:37:52 <ski> Leadhyena : if you lift upon Just [...] you'll get three levels : one Maybe, one list, and one given by lift
13:41:07 <ski> hm
13:41:15 * xerox mutters.
13:41:36 <ski> xerox : should i explain better ?
13:43:10 <xerox> ski, if you have the time I'd love to have you explaining it again, thanks!
13:44:02 <Lunar^> tuomov: Are you aware of any Debian package for riot?
13:45:01 <tuomov> umm..
13:45:20 <tuomov> some of the people involved with the ion package were working on something, but I don't know the status of it
13:45:24 <ski> xerox : i'm just thinking how it'd be with state instead of list ..
13:46:07 <Lunar^> tuomov: I might volunteer then
13:46:14 <ski> xerox : maybe i should explain my usage of "levels" first ?
13:51:29 <xerox> Back
13:51:35 <xerox> Sorry, people were bugging me.
13:51:46 <xerox> I'm all eyes now.
13:52:44 <ski> mm
13:54:30 <ski> i've used a ~visualization of monadic levels to understand the monadic laws better, and also for thinking about stacked monads and monads transformers etc
13:54:53 <ski> basically, return creates a trivial monadic level
13:55:19 <ski> and join :: Monad m => m (m a) -> m a   merges two levels into one
13:55:31 <xerox> I understand this, OK.
13:56:33 <Leadhyena> should |mapListT (+1) $ lift (Just [1,2,3])| be |ap (Just (ap [(+1)])) (Just [1,2,3])| ?
13:56:48 <ski> so the monadic laws then are about creating an inner respectively an outer trivial level, and then merging the two (and this being the same as doing nothing, i.e. id). and also about associativity of the levels
13:56:59 <ski> anyway
13:57:12 <ski> in the example above
13:57:17 <ski> we had Maybe Char
13:57:30 <ski> and lift took that into ListT Maybe Char
13:57:43 <ski> i.e. more or less the same as  Maybe [Char]
13:57:57 <ski> so this has added an inner (trivial) list level
13:58:04 <ski> xerox : following ?
13:58:10 <xerox> Yes
13:58:47 <ski> now, i think it becomes a little bit more complicated with StateT
13:58:48 <xerox> I'm a bit frightened about
13:58:54 <xerox> "i.e. more or less the same as..."
13:59:01 <ski> ok
13:59:23 <ski> that's just vague wording for "isomorphic"
13:59:33 <ski> (or did that help ?)
14:00:17 <xerox> I mean, I read "List" and I can agree with you just because you're probably right, but I can't understand how can a |ListT Maybe Char| contain more than one element... so being a List.
14:00:52 <ski> newtype ListT m a = ListT {runListT :: m [a]}  --  means that ListT m a is a new type that is isomorphic (essentially the same as) m [a].  just a new fresh name for it. so we can easily instance it ..
14:01:10 <ski> hm
14:01:52 <ski> ListT Maybe Char  ~=  Maybe [Char]
14:02:03 <xerox> "How?" :-)
14:02:11 <ski> and values of that can of course contain more than one char in the list
14:02:16 * boegel swears
14:02:28 <ski> how it's "~=" ?
14:02:31 <xerox> Yes
14:02:42 <ski> because it's a newtype :)
14:03:11 <Leadhyena> ski: so is ListT Maybe ~= Maybe List?
14:03:15 <ski> newtype always creates a new type (constructor) isomorphic to an old one. that's why it's called so :)
14:03:31 <ski> Leadhyena : no
14:04:15 <ski> Leadhyena : rather  ListT Maybe ~= Maybe . List   where "." is type-function composition, and List is the [] type constructor
14:04:36 <Leadhyena> oooohhhhh
14:04:44 <Leadhyena> I get you
14:05:19 <ski> (Leadhyena : Maybe [Char] is not the same as Maybe [] Char (which isn't even well-kinded))
14:05:37 <Leadhyena> I understand now...
14:05:38 <ski> xerox : ok ?
14:05:46 <xerox> *gasp*
14:06:12 <ski> you don't like the explanation ?
14:06:28 <xerox> I think I should read something
14:06:40 <Trevion> ski: not quite isomorphic.
14:06:52 <ski> Trevion : no ?
14:06:57 <Leadhyena> so when I use a StateT String IO () it is actually applying State String to the () and not the IO?
14:06:58 <ski> Trevion : why ?
14:07:16 <ski> Leadhyena : hm, let me think about that
14:07:32 <ski> i don't think so
14:08:08 <ski> iirc  newtype StateT s m a = StateT {runStateT :: s -> m (s,a)}
14:08:23 <ski> i.e. StateT s m a ~= s -> m (s,a)
14:08:37 <Trevion> ski: if I remember, Int only has one _|_ value.  On the other hand, newtype Thing = Thing Int has two bottom values, Thing _|_ and _|_
14:08:50 <ski> so  StateT String IO () ~= String -> IO (String,())
14:08:56 <ski> Trevion : no
14:09:12 <Leadhyena> okay so StateT String IO () uses String -> IO (String, () )?
14:09:22 <Leadhyena> oops not that
14:09:30 <ski> Trevion : that is true for  data Foo = MakeFoo Bar ,  but *not* for newtype Foo = MakeFoo Bar ! :)
14:09:33 <Leadhyena> wait yes?
14:09:43 <ski> yes
14:10:00 <ski> so, the IO monad is sorta spliced into the type
14:10:08 <ski> not at top, and not at bottom
14:10:24 <Leadhyena> ah... which is why the liftIO thing works in the first place!
14:10:36 <Leadhyena> I'm working on a text adventrue in Haskell
14:10:42 <Leadhyena> started with a simple shell
14:10:48 <Leadhyena> and got lost really quickly
14:10:53 <ski> Leadhyena : possibly (i'm not following you RN)
14:10:56 <boegel> does anyone know why I get this error while compiling (actually while linking) a simple HOpenGL example ? "/usr/bin/ld: cannot find -lglut"
14:11:07 <Trevion> ski: oh, you're right.. I got them mixed up.
14:11:10 <Trevion> ski: sorry...
14:11:30 <lispy> boegel: someone else had that recently
14:11:32 <ski> Trevion : np :)
14:11:39 <boegel> lispy: on #haskell ?
14:11:43 <lispy> boegel: yeah
14:11:51 <boegel> okay, lemme search the logs
14:12:05 <boegel> hmm
14:12:10 <boegel> google doesn't give any results :s
14:12:17 <lispy> boegel: what distro is this?
14:12:26 <lispy> boegel: can you just install glut-dev package?
14:12:32 <boegel> Fedora
14:12:45 <boegel> oh, I should have the dev package ? okay then
14:12:50 <Leadhyena> gotta go... ski thanks for helping me understand monads better!
14:12:56 <ski> np
14:14:58 <xerox> Anyway, thanks much ski.
14:17:18 <lispy> boegel: yeah, usually the headers and what not for linking are only in the -dev pagake (at least on debian)
14:17:53 <lispy> boegel: usually if i install some library on debian i just ask for the -dev version and it will give me the run time version as well, and then i don't run into problems compliing
14:27:36 * boegel grrs
14:29:36 <lispy> boegel: what happened?
14:30:08 <boegel> it just doesn't work...
14:30:27 <boegel> seems like it can't find libglut.a when it's supposed to
14:30:35 <boegel> http://www.opengl.org/resources/libraries/glut/glut_faq.html#Q32
14:30:58 <boegel> there it says to replace -lglut with the location of libglut.a
14:31:03 <boegel> but that's no option for me
14:33:28 <boegel> lispy: any idea's where I should pick up the glut-dev package ? can't find it on the glut page...
14:33:39 <Itkovian> have you tried -L/dit_to_libglut ?
14:33:45 <Itkovian> dir that is
14:33:52 <lispy> boegel: doesn't your distro provide such a library?
14:34:04 <lispy> boegel: and if you have the .a then that's probably all you need
14:34:07 <Itkovian> boegel: you need the dev package, no?
14:34:11 <lispy> where is that file on your filesystem?
14:34:51 <lispy> boegel: i don't know fedora, but i think there is yumm or something that can download and install packages
14:35:07 <boegel> lispy: tried that, yum couldn't find glut-dev
14:35:30 <boegel> lispy: /home/boegel/glut-3.7/lib/glut/libglut.a
14:36:21 <lispy> boegel: what are you using to build the code?  does it have a configure script (then you may be able to pass the path to libglut.a when you run configure) or a makefile you can edit?
14:37:07 <Itkovian> boegel: if that's the case, then you should perhaps add -L/home/boegel/glut-3.7/
14:37:14 <Itkovian> to the flags you use to compile ...
14:37:25 <Itkovian> export CFLAGS=...
14:37:32 <Itkovian> and the run configure?
14:38:47 <boegel> Itkovian: aha !
14:38:54 <boegel> hc --make HOpenGLTest.lhs -L/home/boegel/glut-3.7/lib/glut
14:38:59 <boegel> this works
14:39:19 <lispy> sweet
14:39:30 <Itkovian> nice
14:39:47 <lispy> boegel: what are you compiling?
14:39:58 <boegel> lispy: just some HOpenGL example
14:40:07 <xerox> dons, ping
14:40:12 <boegel> I want to try and visualize my HaskLS stuff with HOpenGL
14:41:07 <lispy> boegel: HaskLS?
14:41:19 <lispy> boegel: let me know how it goes, i think HOpenGL is interesting
14:41:27 <lispy> i'd like to play with it some time
14:41:29 <boegel> @wiki HaskLS
14:41:30 <lambdabot> http://www.haskell.org/hawiki/HaskLS
14:41:50 <lispy> Ah
14:42:42 <boegel> Itkovian: I've tried adding export CFLAGS="/home/boegel/.../glut" in bashrc, but that doesn't seem to work
14:42:50 <boegel> any idea what I should add then ?
14:43:11 <Itkovian> well, CFLAGS is obviously for the C compiler ...
14:43:17 <Itkovian> what is hc?
14:43:23 <Itkovian> or is it ghc?
14:44:16 <Itkovian> Well, you can define your flags as such in your .bashrc and then add the when compiling e.g. as ghc --make ${MY_FLAGS} <rest>
14:44:49 <boegel> Itkovian: GHC :)
14:45:06 <Itkovian> ok ...
14:45:19 <boegel> Itkovian: there's no way to add it to the stuff GHC looks in standard ?
14:45:41 <Itkovian> erm ... no idea.
14:45:49 <Heffalump> anyone familiar with hsc2hs?
14:46:26 <Itkovian> there is a local package.conf in your ~/.ghc dir, but I don't think you can add simply libs there ...
14:47:36 <Itkovian> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/compiler/main/Attic/DriverFlags.hs?rev=1.151.2.5;content-type=text%2Fplain
14:48:01 <Itkovian> I'm off to sleep ...
14:48:03 <Itkovian> ttyl
14:48:19 <boegel> I have to look in there ? :)
14:48:22 <boegel> damn :)
14:51:06 <boegel> hmm, we'll, atleast it's working
14:52:38 <lispy> i figured ghc called gcc for stuff, so i'm a little surprised that gcc doesn't catch the use of CFLAGS
14:55:14 <Heffalump> ghc has a native code generator
14:55:19 <Heffalump> I think that's the default path nowadays
14:55:36 <Heffalump> -fvia-C should go via gcc
14:55:50 <lispy> Heffalump: ah
14:56:02 <boegel> Heffalump: any idea how to add something to the path of the native code generator then, similar to CFLAGS ?
14:56:23 <lispy> boegel: can you just edit the make file?
14:56:33 <dcoutts_> Heffalump, I'm familiar with hsc2hs
14:56:47 <boegel> the make file for what :)
14:56:48 <lispy> boegel: if so you can use a variable LOCALLIBS = ... or some such
14:56:57 <lispy> boegel: i had assumed you had a makefile...
14:57:01 <Heffalump> dcoutts_: I'm trying to define a macro in it.
14:57:02 <lispy> idon't start a project without one ;)
14:57:08 <boegel> I'm just compiling with "ghc --make ..."
14:57:13 <lispy> *gasp*
14:57:16 <Heffalump> #def SV* do_newRV_noinc(pTHX_ SV* sv) { return newRV_noinc(sv); }
14:57:16 <Heffalump> foreign import ccall "do_newRV_noinc" newRVsv_noinc
14:57:18 <Heffalump>   :: Ptr PerlInterpreter -> Ptr SV -> IO (Ptr SV)
14:57:21 <dcoutts_> Heffalump, oh, I've never done that, just used the standars ones.
14:57:25 <Heffalump> is the kind of thing I want to abstract away with one
14:57:35 <boegel> dcoutts: yo, 0.9.8 out yet ?
14:57:39 <Heffalump> oh well
14:57:43 <lispy> boegel: i've done "gcc foo.c -o foo.c" too many times in the past, now i always us a makefile ;)
14:57:52 <dcoutts_> Heffalump, I assume you've looked at ohw the standard ones are implemented
14:58:08 <boegel> lispy: heh :)
14:58:15 <Heffalump> yes, but I don't quite understand it, and I'm not sure where to put my own.
14:58:36 <dcoutts_> boegel, I'm glad you asked! The first 0.9.8 release candidate has just been announced.
14:58:42 <boegel> yaay !
14:58:44 <dcoutts_> http://sourceforge.net/mailarchive/forum.php?thread_id=7459393&forum_id=8415
14:58:58 * Heffalump notices he's missing some line continuation markers and has another go
14:59:39 <dcoutts_> So if anyone feels like helping test out Gtk2Hs, we'd be most apreciative! :-)
14:59:39 <Heffalump> yay.
15:00:56 <dcoutts_> The release announcement has some special instructions for testing in this release (we really want to test that the new c2hs C parser is faithful to the old slow one)
15:05:41 <boegel> @type ($=)
15:05:47 <lambdabot> bzzt
15:06:01 <boegel> hmm, can anyone tell me what this notation is used for ?
15:06:10 <boegel> or is it not standard Haskell ?
15:06:20 <dcoutts_> it's not standard
15:06:36 <dcoutts_> it must be from some other library
15:07:02 <nothingmuch> ski: ping
15:07:45 <nothingmuch> actually anyone: please reparenthesize (return . sel) for me
15:07:47 <nothingmuch> or define (.), if it's definable, and not a syntatic construct
15:08:20 <dcoutts_> (return . sel) = \x -> return (sel x)
15:08:51 <boegel> dcoutts_: it's probably HOpenGL specific then
15:09:13 <dcoutts_> nothingmuch, (f . g) x = f (g x)
15:09:15 <Heffalump> (f . g) x = f (g x)
15:09:17 <nothingmuch> thanks
15:09:18 <dcoutts_> boegel, right
15:09:29 <boegel> nothingmuch: (.) is function composition, as in ° in maths
15:09:33 <Heffalump> or alternatively, (.) = \f g x -> f (g x)
15:09:34 <lispy> yup
15:09:41 <nothingmuch> boegel: i don't know maths =(
15:10:00 <dcoutts_> nothingmuch, and that is propper Haskell syntax, not just some abstract definition
15:10:21 <lispy> dcoutts_: what's the difference ;)
15:10:23 <dcoutts_> (.) is defined in the Prelude you can take a look at the code
15:10:33 <nothingmuch> thanks
15:10:43 <lispy> @type (.)
15:10:45 <lambdabot> (.) :: forall c a b. (b -> c) -> (a -> b) -> a -> c
15:10:50 <lispy> @get-definition (.)
15:10:51 <lambdabot> (.) not defined
15:10:55 <lispy> hmm...
15:11:03 <lispy> why does lambdabot say it's not defined
15:11:47 <dcoutts_> lispy, you can define things abstracly using Haskell syntax that are not legal Haskell definitions
15:11:59 <lispy> and why does the second argument have to be (a -> b) it really should be (a1 -> ... -> an -> b)
15:12:37 <lispy> i guess you can't really express multiple arity in haskell
15:12:42 <lispy> i miss that from lisp
15:12:48 <Heffalump> (.) wouldn't be well-defined if you tried
15:13:04 <Heffalump> given that you can interepret (a1 -> ... -> an -> b) as a1 -> (a2 -> ... -> an -> b)
15:13:25 <Heffalump> so it is defined on that type, it just may not do what you might think it should
15:13:33 <dcoutts_> eg "f is a function such that fold f [] = ..." or something along those lines, depending on the "..." you could make f uniquely defined
15:13:44 <lispy> or (a1 -> ... -> ak) -> a{k+1} -> ... -> b
15:14:36 <lispy> ah, so a = (a1,...,an) would do what i want
15:14:51 <lispy> then you could use (.) on function of different arity
15:14:57 <lispy> @type uncurry
15:15:00 <lambdabot> uncurry :: forall c b a. (a -> b -> c) -> (a, b) -> c
15:15:06 <lispy> so you just need to uncurry first
15:15:16 <Heffalump> yeah
15:15:19 <Heffalump> @type uncurry3
15:15:27 <lambdabot> bzzt
15:15:42 <lispy> @type uncurry . uncurry
15:15:43 <lambdabot> uncurry . uncurry :: forall b c a b1.
15:15:43 <lambdabot>        (a -> b1 -> b -> c) -> ((a, b1), b) -> c
15:15:47 <lispy> hm...
15:16:02 <lispy> how would you make an n-tuple...
15:16:08 <lispy> @get-definition uncurry
15:16:10 <lambdabot> uncurry = \f.pair (\x y.f x y)
15:16:17 <Heffalump> as in (a,b1,b) rather than ((a,b1),b) ?
15:16:22 <lispy> yeah
15:16:34 <Heffalump> there won't be any generic way.
15:16:38 <Heffalump> just write a function
15:16:52 <lispy> uncurry1, uncurry2, ..., uncurryn ?
15:17:00 <Heffalump> yeah
15:17:10 <Heffalump> (or use TH if you're feeling particularly keen to avoid doing that)
15:17:18 <lispy> i was just going to ask ;)
15:17:35 <lispy> the lisper in me says there must be a way to auto-gen those definitions ;)
15:17:43 <lispy> i need to learn some TH
15:17:49 <lispy> i'd probably love it
15:19:36 <Heffalump> you end up with some nasty restrictions
15:22:04 <lispy> uncurry3 f (a, b, c) = f a b c ?
15:22:39 <Heffalump> yes
15:22:55 <lispy> @plugs let uncurry3 f (a, b, c) = f a b c in (uncurry3 foldl) 1 (+) [1..5]
15:23:01 <lambdabot> <Plugins.Eval>:1:
15:23:01 <lambdabot>   No instance for (Num (((a1 -> a1 -> a1) -> [t] -> a)
15:23:01 <lambdabot>          -> b -> (a1 -> a1 -> a1) -> [t] -> a,
15:23:01 <lambdabot>          (a1 -> a1 -> a1) -> [t] -> a,
15:23:01 <lambdabot>          [b]))
15:23:01 <lambdabot>   arising from the literal `1'
15:23:08 <lispy> @type foldl
15:23:10 <lambdabot> foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
15:23:19 <lispy> @plugs let uncurry3 f (a, b, c) = f a b c in (uncurry3 foldl) (+) 1 [1..5]
15:23:21 <lambdabot> Couldn't match
15:23:32 <lispy> @plugs let uncurry3 f (a, b, c) = f a b c in (uncurry3 foldl) ((+), 1, [1..5])
15:23:34 <lambdabot> 16
15:23:39 <lispy> huh, the whole point was the tuple ;)
15:23:46 <lispy> and i forgot it
15:23:50 <Heffalump> I was thinking that ;-)
15:24:50 * Heffalump decides to add another preprocessing layer on top of hsc2hs
15:24:52 <lispy> @plugs let uncurry3 f (a, b, c) = f a b c  in ((+ 15) . (uncurry3 foldl)) ((+), 1, [1..5])
15:24:53 <lambdabot> 31
15:26:03 <lispy> that's cool
15:26:20 <lispy> is there a way to "uncurry" return values?
15:26:28 <Heffalump> in what sense?
15:26:34 <ski> lispy : @get-definition (and @eval and some more) doesn't handle haskell at all, rather it's a lambda-calc thingy ..
15:26:41 <lispy> uncurryRet :: (a -> b -> c) -> (a -> (b, c))
15:26:42 <Heffalump> function returns aren't curried in the first place in the same way as arguments are
15:26:50 <lispy> ski: ah
15:26:58 <Heffalump> errm, no, because those functions are different in what they can do
15:27:17 <Heffalump> a -> b -> c requires values of type a and b to get c.
15:27:27 <Heffalump> a -> (b,c) requires just a value of type a and gives you b and c
15:27:41 <lispy> Heffalump: i think you can do what i want with a -> b -> c if c = (c1, ..., ck)
15:27:46 <ski> b occurs as an input in the first, and as an output in the second
15:30:24 <ski> lispy : the proper way to "uncurry" return values would not be about a -> (b,c) , but more like a -> Either b c  (and thus turning that into something other and back)
15:31:07 <lispy> hmm...
15:31:13 <lispy> i'm not rually sure about Either
15:31:24 <ski> data Either a b = Left a | Right b
15:31:27 <lispy> rually = really
15:31:54 <Heffalump> ski: I don't follow that.
15:31:58 <ski> though, i think for this to work, we need some kind of language with linear continuations
15:32:36 <lispy> i think uncurry just doesn't make sense on return'd things
15:32:59 <ski> Heffalump : like  (a -> Either b c)  <->  (a -> (b >- c))    where >- is (converse) coexponential ..
15:33:49 <ski> lispy : right, it doesn't make sense (at least for tuples ..)
15:34:53 <ski> Heffalump : hmm, um, sorry,  should be  (a -> Either b c)  <->  ((a >- b) -> c)
15:35:06 * boegel goes to bed
15:35:07 <boegel> nighto !
15:35:09 * ski is tired
15:35:09 * Heffalump has no idea what a converse coexponential is.
15:35:11 <xerox> 'night boegel
15:35:15 <Heffalump> category theory scares me.
15:35:19 <lispy> boegel: night
15:35:25 <Enveigler> Is it possible to type a case clause on one line?
15:35:38 <Heffalump> Enveigler: yes
15:35:44 <lispy> using {} and ;?
15:35:49 <Heffalump> case x of { 1 -> True ; 2 -> False }
15:35:55 <xerox> |
15:35:56 <Enveigler> Thanks.
15:36:05 <ski> Heffalump : converse here just means that, if  b -< a  =  a >- b   and -< is coexponential, then >- is the converse of that  (arguments flipped)
15:36:17 * lispy waits on craigslist repies
15:36:21 <Heffalump> that doesn't help me understand coexponential ;-)
15:36:22 <lispy> replies*
15:36:36 <ski> (Heffalump : it's not necessary to use the converse, just i think it looks prettier)
15:36:49 <ski> Heffalump : you are not alone in that .. :)
15:37:10 <lispy> ski: >- = flip (-<) ?
15:37:16 <ski> yep
15:37:19 <ski> on type level
15:37:22 <lispy> right
15:37:27 <lispy> so what is -< ?
15:37:57 <ski> Heffalump : roughly, the intuition i have is that a value of type  'a >- b' is a pair of a value of type a, and a continuation of type b
15:38:04 <xerox> OK, goodnight folks.
15:38:56 <ski> night, xerox
15:45:11 <ski> lispy : -< is the (categoric) dual of ->  (but that prolly doesn't tell you anything ..)
15:45:55 <lispy> ski: it does
15:46:24 <lispy> ski: i don't know category theory, but when i learn what -> is, i'll probably know what -< is based on duality
15:47:40 <ski> not so simple
15:48:10 <ski> in most ordinary categories, there exists exponential (i.e. ->) but no coexponential :(
15:48:36 <lispy> well, that makes sense, lots of functions don't have inverse functions
15:48:51 <lispy> (they have an inverse image tho...)
15:48:59 <lispy> so maybe it's different in that sense
15:54:31 <ski> well, coexponentials (applied to programming) hasn't to do with inverses of functions
16:24:30 <Enveigler1> This <map (\x -> if x == Char.toLower x then True else False ) "aBCde"> works in ghci but not @eval. Why?
16:24:45 <Enveigler1> @eval map (\x -> if x == Char.toLower x then True else False ) "aBCde"
16:25:30 <lambdabot> type error
16:25:40 <lispy> @plugs map (\x -> if x == Char.toLower x then True else False ) "aBCde"
16:25:47 <lambdabot> [True,False,False,True,True]
16:45:41 <Lemmih> @plugs map isLower "aBCde"
16:45:43 <lambdabot> [True,False,False,True,True]
17:20:51 <dcoutts> Heffalump, ah yes, adding more layers of pre-processing, we have 4 or 5 layers :-) (depending on what you think counts)
17:21:03 <Heffalump> :-)
17:21:11 <Heffalump> this one is a nasty perl script, sadly.
17:21:15 <Heffalump> but it seems to be doing the job ok
17:21:29 <dcoutts> We use one of those too! :-)
17:21:44 <Heffalump> my nasty perl script score for the day is at two now.
17:22:33 <dcoutts> C .h files get turned into xml IDL files by a perl script, the xml files get processed by a code generator to produce .chs.pp files which get cpp'ed to .chs files which get c2hs'ed to .hs files.
17:22:50 <Heffalump> wow
17:22:55 <dcoutts> was that 4 layers or 5
17:22:56 <Heffalump> what do you have against .h -> c2hs ?
17:23:04 <Heffalump> 4.
17:23:15 <dcoutts> oh, c2hs process the .h files too
17:23:34 <Heffalump> my problem is that the entire perl API is defined by macros rather than proper functions, and it has a nasty hack involving a hidden first parameter
17:24:03 <dcoutts> you're interfacing with perl code?
17:25:05 <Heffalump> yes
17:26:03 <dcoutts> yes, writing FFI code for macros is not so nice
17:26:23 <dcoutts> I think c2hs might have a feature that helps with this...
17:26:24 <Heffalump> well, my nasty perl script basically constructs a wrapper function as well as the foreign import statement
17:26:31 <dcoutts> right
17:30:42 <SamB> @index tryAllIO
17:30:43 <lambdabot> bzzt
17:31:18 <SamB> @google tryAllIO
17:31:20 <lambdabot> http://www.haskell.org/pipermail/glasgow-haskell-bugs/2002-March/
17:31:20 <lambdabot> 002251.html
17:45:47 <SamB> @index try
17:45:48 <lambdabot> Control.Exception, System.IO.Error, Text.ParserCombinators.Parsec.
17:45:48 <lambdabot> Prim, Text.ParserCombinators.Parsec
18:35:42 <lisppaste2> Enveigler pasted "-1 as a parameter" at http://paste.lisp.org/display/8895
18:36:37 <Enveigler> Why can't I pass -1 to a function?
18:38:14 <mikael> I didn't look at your code, but let me speculate that you need parenthesis to avoid it being parsed as (f - 1) :-)
18:41:40 <Enveigler> Hmm. roots 4 2 -1 is parsed as roots 4 2 (- 1) ?
18:42:37 <mauke> @pl (+) 4 2 -1
18:42:38 <lambdabot> 5
18:43:07 <Enveigler> Nope. roots 4 2 (-1) works.. So how os roots 4 2 -1 being parsed?
18:43:28 <mauke> ((roots 4) 2) - 1
18:45:46 <Enveigler> So, every time I want a negative constant, I have to pass a positive one to teh function (-)?
18:46:48 <mauke> @type (-)
18:46:53 <lambdabot> (-) :: forall a. (Num a) => a -> a -> a
18:47:09 <mauke> looks like (-) requires two arguments
18:48:02 <Enveigler> @scuse my cynisism, but a mathematical langauge that doesn;t understand negative numbers?
18:48:03 <lambdabot> Unknown command, try @listcommands.
18:48:39 <mauke> I don't know any language that has negative numbers in the syntax
18:49:40 <Enveigler> Perl C Java Rexx.. chall I go on?
18:49:51 <kaol> @type (-1)
18:49:53 <lambdabot> (-1) :: forall a. (Num a) => a
18:49:54 <mauke> C doesn't have negative numbers
18:50:09 <kaol> @type (1-)
18:50:11 <lambdabot> (1-) :: forall a. (Num a) => a -> a
18:50:20 <mauke> Perl... maybe; it's probably undecidable
18:50:32 <mauke> or not
18:50:44 <mauke> perl -wle 'print -2**2'
18:51:07 <kaol> @type (- 1)
18:51:09 <lambdabot> (- 1) :: forall a. (Num a) => a
18:51:55 <Enveigler> *Test> :!Perl -wle"print -2**2"
18:51:55 <Enveigler> -4
18:52:06 <mauke> exactly
18:52:19 <seidan> I remember a language that used _ as unary negation... maxima maybe?
18:52:19 <mauke> it's parsed as -(2**2), not (-2)**2
18:52:54 <mauke> just like haskell parses x -2 as (x - 2), not x (-2)
18:55:05 <Enveigler> mauke: Your point is made and taken.
18:55:55 <mauke> AFAIK - is the only unary prefix operator in haskell
18:56:09 <mauke> unfortunately it's also a binary infix operator
18:57:44 <Enveigler> That said:>perl -wle"sub f{ $_[ 0 ] **2 } print f -2"
18:57:44 <Enveigler> 4
18:58:04 <mauke> that works because perl functions aren't values
18:58:15 <mauke> they're parsed as (prefix) list operators
18:58:33 <Enveigler> Which is closer, but I suppose that's because Haskell functions bind tigheter than Perl's.
18:59:36 <mauke> haskell functions are constant values
18:59:59 <Enveigler> Okay. Now I see why passing -1 to a function was never a problem.
19:00:06 <Enveigler> Thanks.
19:00:20 <mauke> perl -wle 'use constant f=>sub{$_[0]**2}; print f -2'
19:01:50 <Enveigler> THat's cheating :)
19:02:03 <mauke> that's what haskell does
19:02:18 <mauke> except haskell parses VALUE VALUE as function application
19:02:25 <mauke> (which is an error in perl)
19:07:28 <Enveigler> Earlier, you did @type (-) which gave (-) :: forall a. (Num a) => a -> a -> a. I see people in here do that a lot, but why? What is (-) :: forall a. (Num a) => a -> a -> a meant to tell me?
19:07:49 <mauke> it's the type of (-)
19:08:24 <mauke> it means: for any instance of Num (called a), you can pass two values of type a to it and get another a back
19:08:24 <Enveigler> I got that...but how does it help explain my misunderstanding? How am I meant to read it?
19:08:59 <mauke> your question was < Enveigler> So, every time I want a negative constant, I have to pass a positive one to teh function (-)?
19:09:27 <mauke> if you pass a value to (-) (like (-) 42), the result is a function
19:09:34 <Enveigler> Yep! And so that was telling me that (-) needed 2 parameters?
19:09:44 <mauke> yes
19:10:46 <Enveigler> Curried waiting for it's second parameter to "finish the job"?
19:10:55 <mauke> exactly
19:11:52 <mauke> huhu, use constant minus => sub { my $x = shift; sub { $x + $_[0] } };
19:12:12 <mauke> er, $x - $_[0]
19:13:29 <Enveigler> I think learning to read sumerian hieroglyphics might be more intuative :)
19:14:17 <kaol> sumerians programmed with FP too?
19:15:20 <Enveigler> Maybe...they still aren't sure if the Babylonian Battery is really a battery. And they did use base-60 for math
19:16:31 <araujo> hah.. they still aren't sure where the sumerians came up :-)
19:50:58 <Enveigler> @plugs f x = x+1
19:50:59 <lambdabot> parse error on input `='
19:51:19 <SamB> hmm, now lets see if bugs hide as easily between lambdas as between pattern matches!
19:51:33 <Enveigler> @plugs let f x = x+1
19:51:34 <lambdabot> parse error on input `)'
19:52:18 <mauke> @pl let f x = x+1 in f 41
19:52:19 <lambdabot> 42
19:52:57 <Enveigler> what's the difference between @plugs and @pl?
19:53:21 <mauke> well, @pl is shorter
19:53:32 <Enveigler> NSS!
19:54:20 <mauke> I think that's it
19:54:50 <SamB> great. My runtime compilation and my eval/apply implementations of unlambda appear to be buggy in different ways...
19:55:42 <Enveigler> OKay. So, is the need for an 'in' clause a limitation of the lambabot?
19:56:15 <mauke> it wants an expression
19:56:46 <SamB> Enveigler: plugs, I think, actually compiles your expression into the middle of a program...
19:56:57 <SamB> @plugs ) (
19:56:58 <lambdabot> Couldn't match `String' against `t -> t1'
19:57:06 <SamB> yup, definately.
19:57:15 <mauke> It's spelled "definitely". See also <http://www.wsu.edu/~brians/errors/definate.html>.
19:57:29 <Enveigler> What I mean is I can do let f x = x+1 in ghci but not in t'bot?
19:57:31 <SamB> mauke: you picker of nits you!
19:57:54 <mauke> huhu, yay for semiautomatic responses
19:58:39 <SamB> hmm, I wonder what I should do with my unlambda interpretation code if I want other people to debug it for me...
19:58:54 <mauke> Enveigler: it would be useless here because the bot doesn't keep state between @plugs invocations
19:59:15 <SamB> @ghci let x = 1
19:59:16 <lambdabot>  parse error on input
19:59:31 <Enveigler> Okay.
19:59:33 <SamB> oh right, that just gets spell-corrected to ghc...
19:59:58 <SamB> somebody should re-enable load spell-correction on command names, it drives me nuts...
20:00:03 <SamB> s/load/loud/
20:00:19 <Enveigler> I was trying to do *Test> let mult n m = n + mult (m-1)
20:00:19 <Enveigler> <interactive>:1:25:
20:00:19 <Enveigler>     Occurs check: cannot construct the infinite type: a = a -> t
20:00:19 <Enveigler>       Expected type: a -> t
20:00:19 <Enveigler>       Inferred type: a
20:00:19 <Enveigler>     In the expression: m - 1
20:00:21 <Enveigler>     In the first argument of `mult', namely `(m - 1)'
20:00:23 <Enveigler> *Test>
20:00:39 <mauke> yeah
20:00:57 <Enveigler> And I din;t understand the error messages?
20:01:13 <mauke> the result of mult (m-1) is a function
20:03:07 <mauke> hmm, and (+) has the type a->a->a, so the result of mult n m has to have the same type as mult (m-1)
20:03:22 <SamB> for some reason my unlambda interpreter is either delaying putting off a lot of computation too long, or doing a little bit too soon...
20:05:02 <Enveigler1> mauke: Did I miss the second line of your explanation--or should "the result of mult (m-1) is a function" tell me everythng I need to know?
20:05:52 <mauke> I'm trying to understand how the typechecker thinks
20:06:14 <mauke> it starts with mult n m = ..., so mult has the type a -> b -> c
20:06:35 <mauke> the body is an application of (+) to two arguments
20:07:18 <mauke> (+) has the type a -> a -> a, so n, mult (m-1) and mult m n must have the same type
20:08:20 <Enveigler1> Is that good or bad? Ie. Am I being stupid trying to do n + mult (m-1)?
20:08:37 <mauke> I think you meant n + mult (m-1) n
20:09:09 <Enveigler1> Ah. I forgot the second param to the recursive call. Thanks!
20:15:17 * SamB wishes he had a type error or something easy like that
20:18:02 * lispy wrote a program that works fine in ghci and runs out of memory when compiled
20:18:32 <lispy> is that the sort of thing i should send in as a bug report?
20:18:43 <lispy> i'm trying to compile without optimizations now and see if it still happens
20:19:14 <lispy> yup still happens
20:19:24 <lispy> so it has to be run from ghci
20:21:07 <AtnNn> what is the program?
20:26:51 <lispy> AtnNn: a heurstic to find knights tour on chessboards with holes
20:27:05 <lispy> it's like 300 lines counting all 3 heuristics and everythig
20:38:31 <lispy> oh, i had to kill the .hi and .o files and recompile with out optimizations
20:40:17 <SamB> hmm, it occurs to me to wonder whether unlambda's promises are supposed to be evaluated more than once...
20:47:59 <lispy> can you use gdb on a haskell program if you compile with -f-via-C and pass -ggdb (not sure how you pass that flag)
20:48:15 <lispy> or would the debugging code be meaningless?
22:27:30 <dons> liispy, you can use gdb, but you end up lookking at compiled functional code and rts calls. So unless you know how haskell is compiled to C, then gdb makes no sense
22:27:38 <dons> much better to use hat or buddha
22:27:50 <lispy> dons: i figured that after i started asking ;)
22:28:14 <lispy> dons: should i report my program that goes oom when compiled with -O ?
22:28:27 <stefanw> dons: did you ever use hat?
22:28:28 <lispy> oom = out of memmory
22:29:50 <dons> stefanw, used it a couple of times. good for people learning haskell
22:29:57 <dons> i've never used it for debugging
22:30:45 <dawt> haskell= derivative of pascal..?
22:30:54 <dawt> awdunno..
22:31:00 <dons> lispy, not necessarily. maybe it's just a space leak?
22:31:18 <dons> play around with it a bit. if it makes no sense, then ask on glasgow-haskell-users@
22:32:03 <lispy> dons: well, when optimization is turned off it runs very quickly and only uses a little space
22:32:11 <lispy> dons: i can't find any obvious bugs either
22:33:15 <lispy> so maybe i'm at the point to ask on glasgow-haskell-users
22:33:20 <ski> dawt : why would you think that ?
22:33:24 <dons> oh, then that's a good one to report.
22:33:41 <gzl> man, there's nothing like Java transformers to make you appreciate higher order functions even more
22:35:34 <lispy> gzl: i feel like we're not taking advantage of von Neumann architecture if we aren't using data and code and code as data ;)
22:35:47 <lispy> that first and should be as
22:36:29 <lispy> did any of you go to ICSE this year?
22:37:47 <ski> 'morning Enveigler1
22:40:49 <lispy> i'll take that as a no ;)
22:41:42 <ski> ICSE = International Conference on Software Engineering ??
22:42:14 <lispy> ski: yes
22:42:27 * ski hasn't heard of it
22:42:32 <lispy> heh
22:42:39 <lispy> i take it you googled?
22:42:57 <ski> no
22:43:03 <Enveigler1> Morning ski
22:43:08 <ski> just tried to expand&guess
22:43:37 <lispy> good guesses
22:43:54 <Enveigler1> Is there a way to say the inverse of [] = ... in a guard?
22:44:19 <ski> (i know that ICFP = International Conference on Functional Programming, so i was surer of the IC than of the SE part ..)
22:44:33 <dawt> okay.. i have a question about something else..
22:44:35 <lispy> Enveigler1: not (null x)  (where x is the list)
22:44:51 <dawt> does haskell use threading libraries..?
22:44:54 <lispy> ski: that's reasonable
22:45:06 <ski> Enveigler1 : do you mean, to check if a list is not the empty list (i.e. has at least one element) ?
22:45:09 <lispy> dawt: i think ghc has some threading support
22:45:41 <lispy> dawt: is that what you meant?
22:45:44 <dawt> i've spotted a couple of threads that might make the OS seem faster..
22:45:55 <dawt> yeeh..
22:46:03 <lispy> dawt: er?
22:46:09 <lispy> dawt: make the OS seem faster?
22:46:14 <dawt> maybe like nptl without the gnome lag of X..
22:46:41 * lispy is confused
22:47:03 <Enveigler1> Lispy: Trouble is that not( null x) is Bool, whereas [] isn't
22:47:29 <lispy> Enveigler1: guards are looking for bools
22:47:33 <Enveigler1> Ski: I was trying to do <let my_map f (x:xs) | [] = [] | not(null x ) = f x : map f xs>
22:47:39 <ski> Enveigler1 : how yould you want to use it ? / more exactly what is it you want ?
22:48:12 <ski> hm
22:48:13 <Enveigler1> Or let my_map f (x:xs) | [] = [] | True = f x : map f xs
22:48:21 <lispy> @plugs map (1+) []
22:48:23 <lambdabot> []
22:48:32 <lispy> why do that test?
22:48:39 <ski> Enveigler1 : are you typing this in hugs/ghci ?  or writing in a file ?
22:49:34 <Enveigler1> TYping it in to ghci... I realise I can use pattern matching rather than a guard, but I was trying to understand guards.
22:49:35 <ski> if you want to check if the second argument is an empty list, and then return something, you can write (in a file)
22:49:41 <ski> my_map f [] = ...
22:49:55 <ski> ok
22:50:03 <ski> so, if you wanna use guards
22:50:16 <Enveigler1> Just to see if I can :)
22:50:18 <ski> then you should prolly *not* pattern-match on (x:xs), right ?
22:50:30 <ski> why not try starting with
22:50:41 <ski> my_map f xs | null xs = ...   | ....
22:50:45 <lispy> let my_map f xs | null x = [] | otherwise = f (head x) : my_map f (tail xs)
22:51:15 <ski> lispy : now you gave him the solution, bad boy :)
22:51:17 <lispy> and not the use of my_map in the recursive call instead of jsut map
22:51:21 <lispy> ski: sorry!
22:51:30 <lispy> ski: didn't realize you were going to ask thta question
22:52:03 <lispy> Enveigler1: note that i use expressions which evaluate to True or False instead of pattern
22:53:04 <ski> Enveigler1 : the most important is that you understand how it works, and how to write similar yourself  (though it would possibly have been better teaching, if you'd gotten some more time to prove your capability ;)
22:53:48 <Enveigler1> Gotcha. Ski's question and your answer combine to clarify my (latest) misunderstanding. It pobably won't stick till I've made it myself, but I might recognise teh symptoms when I do.Thnakyou both.
22:54:07 <Enveigler1> We think teh same way ski
22:54:18 <ski> Enveigler1 : every guard expression should have type Bool, in your attempt above "my_map f (x:xs) | [] = []  | ...", the first guard expr., namely the first [], is not a Bool, but a list
22:54:21 <Enveigler1> (Well, in parts!)
22:54:53 <ski> Enveigler1 : ok, then :)
22:56:05 <Enveigler1> And my poor typing is deteriating further...time for some sleep!
22:56:18 <ski> hehe
22:56:27 <ski> @moo
22:56:28 <lambdabot>          (__)
22:56:28 <lambdabot>          (oo)
22:56:28 <lambdabot>   /-------\/
22:56:28 <lambdabot>  / |     ||
22:56:28 <lambdabot> *  ||W---||
22:56:28 <lambdabot>    ~~    ~~
22:56:31 <lambdabot>   Cow laden
22:56:32 <lambdabot>   with milk
22:56:54 <lispy> Enveigler1: try it again this time try to implement foldl
22:56:56 <Enveigler1> 22222
22:57:11 <ski> @moo
22:57:12 <lambdabot>          (__)
22:57:12 <lambdabot>          (oo)
22:57:12 <lambdabot>   /-------\/
22:57:12 <lambdabot>  / |     ||
22:57:12 <lambdabot> *  ||V---||
22:57:12 <lambdabot>    ~~    ~~
22:57:14 <lambdabot> Betty Ford-type
22:57:16 <Enveigler1> Darn! I can't even type ZZZzzz properly!
22:57:17 <lambdabot> cow with milk
22:57:31 <Enveigler1> Cheers!
22:57:35 <Enveigler1> &
22:59:07 <dawt> what's that site that hosts free web addresses..?  something.org..
22:59:17 <dawt> awdunno..
23:00:41 <dawt> afraid.org
23:00:47 <dawt> cool eh..
23:02:12 <dawt> stop hacking me..
23:02:30 <ski> hm ?
23:07:43 * lispy wonders if dawt is in the right channel
23:15:22 <Pseudonym> quit
23:17:29 <seidan> clear
23:20:54 <seidan> @moo
23:20:56 <lambdabot>          (___)
23:20:56 <lambdabot>          (o o)
23:20:56 <lambdabot>   /-------\ /
23:20:56 <lambdabot>  / |     ||O
23:20:56 <lambdabot> *  ||,---||
23:20:57 <lambdabot>    ~~    ~~
23:20:59 <lambdabot>      Bull
23:58:26 <rtega> @moo
23:58:27 <lambdabot>          (__)
23:58:27 <lambdabot>          (oo)
23:58:27 <lambdabot>   /-------\/-*
23:58:27 <lambdabot>  / |     || \
23:58:27 <lambdabot> *  ||----||  *
23:58:27 <lambdabot> \/|(/)(/\/(,,/
23:58:29 <lambdabot>   Cow munching
23:58:31 <lambdabot>     on grass
23:58:39 <Itkovian> tralalalala
23:58:48 <dons> nice cow
23:59:05 <seidan> @moo
23:59:06 <lambdabot>          (__)
23:59:06 <lambdabot>          (oo)
23:59:06 <lambdabot>   /-------\/
23:59:06 <lambdabot>  )*)(\/* /  *
23:59:06 <lambdabot> \ |||/)|/()(
23:59:06 <lambdabot> \)|(/\/|)(/\
23:59:08 <lambdabot> Grass munching
23:59:10 <lambdabot>     on cow
23:59:13 <rtega> lol
23:59:23 <lispy> nice
23:59:29 <lispy> that's perfect timing
23:59:38 <seidan> @moo
23:59:39 <lambdabot>           (__)
23:59:39 <lambdabot>           (oo)
23:59:39 <lambdabot>    /-------\/
23:59:39 <lambdabot>   / |     ||
23:59:39 <lambdabot> ~~~~~~~~~~~~~~
23:59:39 <lambdabot>  
23:59:42 <lambdabot>  Cow in water
