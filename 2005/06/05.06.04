00:00:05 <lispy> or something...
00:00:10 <lispy> i'm not sure how to explain it
00:00:30 <lispy> i like using gnus from screen, but then when i'm on my laptop i can't get to my email unless i have a net connection
00:12:50 <lispy> yeah,i just can't see my self using thunderbird full time
00:13:13 <lispy> pointing and clicking is so error prone and cumbersome
00:13:58 <dons> mutt!
00:14:06 <dons> or something from your editor
00:15:03 <lispy> yeah, i'll probably stick with gnus
00:15:23 <lispy> although, it's been hiding messages from one person lately
00:15:27 <lispy> and that's annoying
00:16:10 <autrijus> @type join
00:16:11 <lambdabot> bzzt
00:16:16 <lispy> @index join
00:16:17 <autrijus> @type Control.Monad.join
00:16:18 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
00:16:18 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
00:16:18 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
00:16:18 <lambdabot> Control.Monad.join :: forall a (m :: * -> *).
00:16:18 <lambdabot>         (Monad m) =>
00:16:18 <lambdabot>         m (m a) -> m a
00:17:08 <lispy> what i need is a way to have gnus save the message locally, to have a "send later", and have an address book
00:17:23 <lispy> but, since i use gnus remotely, having it save messages locally doesn't mean much
00:17:50 <lispy> for the address book i could be using bbdb
00:19:42 <lispy> for anyone who uses procmail i made a tool this term: http://www.codersbase.com/Autoproc
00:20:02 <lispy> you write your rules in haskell and it generates the procmail recipe for you
00:20:31 <dons> oh, I remember when you were working on that. cool idea.
00:21:21 <lispy> thanks, it needs a lot of work still
00:21:31 <lispy> but it does what i needed/wanted
00:21:59 <lispy> the lamest thing about it, is that you have to put all of your rules in to a list.  It's easy to define a rule and forget to place it in the list
00:22:07 <lispy> i'd like it to warn you when that is the case
00:22:38 <lispy> it's darcs getable too
00:23:46 <dons> have you looked into the literature for other work on embedding a domain-specific language in Haskell?
00:24:19 <dons> there's probably solutions to many of these issues, and other good ideas. getting a sensible type system embedded in Haskell's would be cool
00:24:53 <lispy> i haven't but i should ;)
00:25:23 <lispy> i'd like to have a nice way to add more structure to regexp since that is the main way of specifiying "tests"
00:26:15 <lispy> it would be nice if you could test the rules you right on your emails in a safe way (for debugging)
00:26:24 <lispy> s/right/write/
01:01:00 <genneth> port_scan: thread blocked indefinitely
01:01:02 <genneth> @hgc
01:01:04 <lambdabot>  Exotic Stmt in meta brackets
01:01:06 <genneth> @ghc
01:01:07 <lambdabot>  Illegal polymorphic type
01:01:20 <genneth> hmm
01:01:22 <genneth> try that again
01:01:25 <genneth> port_scan: thread blocked indefinitely
01:01:27 <genneth> @ghc
01:01:28 <lambdabot>  CPR Analysis tried to take the lub of a function and a tuple
01:01:32 <genneth> @ghc
01:01:33 <lambdabot>  GHC stack-space overflow
01:06:45 <lispy> @ghc
01:06:47 <lambdabot>  WARNING: SE CAFs unsupported, forcing UPD instead
01:22:07 <raver> morning :-)
01:22:17 <lispy> morning
01:40:59 <xerox> @moo
01:40:59 <lambdabot>     /-------  (__)
01:40:59 <lambdabot>    / |     || (oo)
01:40:59 <lambdabot>   *  ||----|---\/
01:40:59 <lambdabot>      ^^    ^
01:40:59 <lambdabot> This cow belonged to
01:41:01 <lambdabot> the Headless Horseman
01:44:51 <lispy> creepy
01:44:52 <Lemmih> Good morning, #haskell.
01:45:06 <xerox> 'morning Lemmih!
01:45:31 * xerox enjoys the fact that school just finished, here. \o/
01:45:51 <lispy> xerox: i have a term paper due on monday, then i'm done
01:53:01 <xerox> @dice 3d6+2
01:53:02 <lambdabot> 3d6+2 => 9
01:57:51 <Heffalump> anyone understand the FFI and finalizers?
01:58:13 <Lemmih> As in ForeignPtr's?
01:58:32 <Heffalump> yeah
01:58:49 <Heffalump> in particular, the FFI standard says that finalizers should be implemented in the foreign language
01:59:17 <Heffalump> but my finalizer needs some context and the foreign language (C) doesn't have native closures, so I can't make a purely C function of type Ptr -> IO ()
02:01:01 <Lemmih> I don't think the finalizers has to be defined in a foreign language.
02:02:11 <Heffalump> there's a footnote in the FFI about it being impossible to do them in Haskell without concurrency. It refers to a paper by Boehm at POPL 03 which I haven't yet read
02:10:58 <Lemmih> ForeignPtr's are implemented using Weak pointers. I don't see why it wouldn't work with Haskell finalizers.
02:17:18 <Lemmih> But then again, I'm no Haskell expert.
02:26:54 <xs> clisp include libcallback which allows closures in c. not sure how useful it is though.
02:35:22 * boegel waves
02:36:01 <Lemmih> Greetings, boegel.
02:36:44 <boegel> damn, I hate how slow my connection is :(
02:37:21 <boegel> I have to download some stuff for uni, only 5mb, and it's taking forever
02:38:22 <boegel> Lemmih: what are you currently working on ?
02:39:18 <Lemmih> I'm trying to figure out how two circles should react when they collide.
02:39:47 <boegel> circles ? what do you mean ?
02:40:18 <genneth> elastic collision?
02:42:09 <Lemmih> boegel: How should two objects reflect given their speed, mass and direction.
02:42:51 <lispy> well, if their relative speed is zero it's easy ;)
02:42:57 <genneth> you can always take one of them to be stationary
02:43:16 <genneth> then account for the motion of the observer later
02:47:01 <boegel> Lemmih: sounds like physics :)
02:47:27 <Lemmih> Indeed. And it's definitely not my strong point.
02:48:02 <boegel> mine neither
02:49:03 <lispy> well, the bounciness is also important here
02:49:22 <genneth> the most important thing is conservation of momentum
02:49:48 <genneth> it's actually the only thing you can rely on
02:50:13 <genneth> if you know it's energy preserving (elastic) then you would have enough equations to solve for the motions completely
02:50:44 <genneth> but if there are friction effects and energy loss, then you would need more detailed models of those
02:55:04 <nmoore> hi, i'm attempting to amend a function to be the main function of a ghc compiled program, but I'm slightly confused about how to deal with user input. can anyone help me?
02:55:15 <nmoore> http://www.haskell.org/hawiki/HaskellIrcPastePage
02:55:32 <genneth> @type getArgs
02:55:37 <lambdabot> bzzt
02:55:43 <boegel> nmoore: what seems to be the problem ?
02:55:49 <boegel> @index getArgs
02:55:50 <lambdabot> System.Environment
02:55:57 <genneth> that's the one
02:55:58 <boegel> @type System.Environment.getArgs
02:55:59 <lambdabot> System.Environment.getArgs :: IO [String]
02:55:59 <nmoore> Couldn't match `IO a' against `String -> IO ()'
02:56:19 <boegel> nmoore, you should give main the type IO(), and use the getArgs function
02:56:31 <boegel> that way you can give your program command line arguments
02:56:50 <genneth> boegel: actually, why is getArgs an IO action? it seems to be nondestructive and pure in semantics?
02:56:56 <nmoore> boegel: do i do: IO mystring = System.Environment.getArgs
02:57:15 <boegel> genneth: no idea :) don't ask me about how this IO and monad stuff works, I just use it
02:57:24 <boegel> nmoore, no
02:57:33 <boegel> let my paste it on the wiki for you
02:57:35 <genneth> nmoore: try looking at this example: http://community.moertel.com/ss/space/2004-03-13
02:57:44 <xs> i suppose it simplifies the type of main.
02:58:09 <nmoore> boegel: thanks
02:59:32 <Lemmih> genneth: It's an IO action because the args aren't fixed. See 'withArgs'.
02:59:50 <boegel> @type input
02:59:51 <lambdabot> bzzt
02:59:57 <boegel> @index input
02:59:58 <lambdabot> Text.Html
03:00:18 <boegel> nmoore, is that the input function you want to use ?
03:00:49 <nmoore> boegel: sorry, it's a function i have defined myself that converts a string to an array
03:00:59 <boegel> oh okay :)
03:01:08 <boegel> nmoore:
03:01:10 <boegel> pasted
03:01:46 <boegel> remember, getArgs produces an array, so you might need (head args) instead of args, that will provide you with the first argument of the command line arguments
03:02:15 <xerox> @type Data.Array.listArray
03:02:16 <Lemmih> boegel: Ehem.. s/array/list/
03:02:16 <lambdabot> Data.Array.listArray :: forall e i.
03:02:16 <lambdabot>         (GHC.Arr.Ix i) =>
03:02:16 <lambdabot>         (i, i) -> [e] -> GHC.Arr.Array i e
03:02:32 <boegel> Lemmih: yeah, sorry about that :D
03:03:08 <boegel> nmmore: getArgs produces a _list_ of arguments :) otherwise I'll get kicked by Lemmih ;)
03:03:19 <Lemmih> (:
03:03:33 <nmoore> boegel, Lemmih: thanks
03:06:41 <boegel> nmoore: glad to help
03:41:50 <boegel> yo wli
03:47:09 <wli> you rang?
03:47:54 <boegel> nope, I as only greeting you :)
03:48:00 <boegel> s/as/was
03:55:37 <genneth> how mature is STM in ghc?
03:55:52 <genneth> I know that it has issues on amd64
03:56:12 <genneth> but even on x86 it seems to have problems with deciding that certain threads are deadlocked
03:58:29 <boegel> don't talk to about about threads and deadlock goddamned :)
03:59:11 <genneth> :-D
03:59:31 <genneth> But I thought using STM abstractions made it impossible to deadlock threads?
03:59:54 <genneth> it's something weird, that's for sure
04:00:03 <genneth> I've got this port scanner thing
04:00:13 <genneth> that forks a thread per port to scan
04:00:19 <boegel> hacking eh ? :)
04:00:22 <genneth> but that kills the stack
04:00:38 <genneth> boegel: :D
04:00:52 <genneth> so I've made it only spawn a limited number of threads
04:01:39 <genneth> so with 10 worker threads, it tends to go "port_scan: thread blocked indefinitely" when I give it ~10000 tasks
04:02:01 <genneth> easily solved by upping the limit to 1000 threads, which easily copes with scanning all 2^16 ports
04:02:34 <genneth> but I'm now not sure if I've made a mistake with the logic or if it's just STM/Concurrency acting up
04:02:36 <arjanb> STM is new in ghc 6.4 so it hasn't been used extensively
04:03:43 <magical1> is there any one here?
04:03:45 <genneth> arjanb: I know, but it's just so cool that I absolutely had to use it. :D I've been trying to figure out how to build something similar in C++
04:03:52 <genneth> magical1:
04:03:55 <genneth> @moo
04:03:56 <lambdabot>                  \_|_/
04:03:56 <lambdabot>                   (oo)
04:03:56 <lambdabot>            /-------\/
04:03:56 <lambdabot>           / |     ||
04:03:56 <lambdabot>          *  ||----||
04:03:56 <magical1> hi
04:03:56 <lambdabot>             ^^    ^^
04:03:58 <xerox> Yeah magical1!
04:03:58 <lambdabot> Cow visiting the Statue of Liberty
04:04:19 <reffie> @ghc
04:04:20 <lambdabot>  parse error in data/newtype declaration
04:04:27 <magical1> I had my haskell exam yesterday and there was one question on it that stumped me
04:04:45 <magical1> I just wanted to ask someone else
04:04:56 <xerox> What was it?
04:05:18 * genneth senses a session of haskell golf coming up
04:05:25 <magical1> Explain how one might argue that PostScript is paradigmatic for genetics
04:05:35 <xerox> o_O
04:05:48 <magical1> (Don't know what it had to do with haskell)
04:06:20 <magical1> But it left me stumped
04:06:34 <boegel> magical1: damn, what a question :)
04:06:35 <genneth> @google paradigmatic
04:06:37 <lambdabot> http://www.aber.ac.uk/media/Documents/S4B/sem05.html
04:07:02 <boegel> @google paradigmatic genetics PostScript
04:07:03 <lambdabot> http://n4bz.org/science/parafoot.htm
04:07:24 <TheHunter> genneth, did you use bracket?
04:07:27 <boegel> that actually has a result, heh :)
04:07:38 <magical1> paradigmatic = example, pattern
04:07:41 <genneth> TheHunter: what do you mean?
04:08:05 <TheHunter> iirc, you decrease a counter and increase it again if your IO is finished.
04:08:19 <boegel> magical1: what the hell has that to to with Haskell :s
04:08:20 <TheHunter> now, suppose the thread gets killed for some reason during that IO.
04:08:21 <genneth> TheHunter: yep
04:08:37 <TheHunter> @index bracket_
04:08:39 <genneth> aha....
04:08:39 <lambdabot> Control.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw,
04:08:39 <lambdabot> Graphics.HGL.Core, Graphics.HGL
04:08:48 <genneth> i see what you're getting at
04:08:49 <magical1> boegel: I have no idea
04:08:50 <TheHunter> @type Control.Exception.bracket_
04:08:52 <lambdabot> Control.Exception.bracket_ :: forall c b a.
04:08:52 <lambdabot>           IO a -> IO b -> IO c -> IO c
04:09:04 <TheHunter> the second argument gets executed, no matter what.
04:09:07 <Lemmih> @type Control.Exception.finally
04:09:08 <lambdabot> Control.Exception.finally :: forall a b. IO a -> IO b -> IO a
04:10:30 <genneth> it doesn't seem to have helped
04:11:02 <TheHunter> @index QSem
04:11:04 <lambdabot> Control.Concurrent.QSem, Control.Concurrent
04:12:05 <TheHunter> oops, semaphores aren't good enough, of course
04:12:32 <boegel> magical1: you should have asked your prof at the end of the exam
04:12:54 <magical1> he had disappeared post haste!
04:13:09 <genneth> TheHunter: this is what I've got:
04:13:11 <genneth> limitedThreadsWithChannelMapM :: Integer -> (a -> IO b) -> [a] -> IO [MVar b]
04:13:11 <genneth> limitedThreadsWithChannelMapM lim ioaction x = do
04:13:11 <genneth>     threadpoolcounter <- atomically ( newTVar 0 )
04:13:11 <genneth>     mapM (limitThreads threadpoolcounter . ioaction) x
04:13:11 <genneth>     where
04:13:12 <genneth>         limitThreads poolcount io = do
04:13:14 <genneth>             atomically ( do
04:13:16 <genneth>                 prev <- readTVar poolcount
04:13:18 <genneth>                 if prev >= lim then
04:13:20 <genneth>                     retry
04:13:24 <genneth>                     else writeTVar poolcount (prev+1) )
04:13:26 <genneth>             mvar <- newEmptyMVar
04:13:28 <genneth>             forkIO(do
04:13:30 <genneth>                 out <- io
04:13:32 <genneth>                 putMVar mvar out
04:13:34 <genneth>                         `finally`
04:13:36 <genneth>                                 atomically ( readTVar poolcount >>= writeTVar poolcount . ((-)1 ) ) )
04:13:38 <genneth>             return mvar
04:13:42 * xerox runs nacked through the code
04:14:24 <genneth> I'm thinking that I put the finally in the wrong place
04:14:57 <Lemmih> "\x -> x - 1" is not "(-)1" btw.
04:15:03 <Lemmih> @pl \x -> x -1
04:15:03 <lambdabot> subtract 1
04:15:53 <TheHunter> |finally| only ranges over putMVar.
04:16:00 <genneth> yes
04:16:11 <genneth> trying a different way....
04:16:54 <TheHunter> i'd use bracket.
04:17:24 <genneth> note that I increment the threadcount in the main thread and it's decremented in the child
04:17:29 <genneth> does bracket allow that?
04:17:33 <magical1> boegel: well I guess I better go back to my studies :(
04:17:57 <TheHunter> oh, that makes things nasty.
04:17:59 <magical1> thanks
04:18:09 <genneth> TheHunter: don't I just know it :D
04:18:50 <TheHunter> you both need to decrease both if forkIO fails and if it succeeds and there's some error in your io.
04:19:10 <genneth> Aha, I think I've got it
04:19:44 <genneth>             forkIO(
04:19:44 <genneth>                 finally
04:19:44 <genneth>                         (io >>= putMVar mvar)
04:19:44 <genneth>                         (atomically ( readTVar poolcount >>= writeTVar poolcount . (subtract 1) ) ) )
04:19:47 <TheHunter> with a little confidence forkIO will never fail?
04:20:01 <genneth> yes
04:20:06 <genneth> looks like I'm banking on that
04:20:51 <TheHunter> looking good.
04:21:06 <genneth> well
04:21:12 <genneth> it worked without dying
04:21:20 <genneth> 10 threads for 2^16 tasks
04:21:43 <genneth> TheHunter: thanks for your help
04:22:07 <TheHunter> np
04:24:27 <Lunar^> genneth: What's "io"?
04:25:12 <genneth> io :: IO a
04:25:15 <genneth> I believe
04:25:35 <Lunar^> @index io
04:25:36 <lambdabot> bzzt
04:25:53 <Lunar^> genneth: it's your argument.. ok
04:25:57 <genneth> io is a parameter to throttledFork
04:26:02 <genneth> yep
04:26:07 <genneth> argument, even
04:26:18 * Lunar^ prefer to use "action"
04:26:39 <genneth> yes, the enclosing function calls it ioaction, but I was lazy with the keyboard :D
04:26:44 <TheHunter> hmm, not increasing the counter on failed forkIOs actually makes sense...
04:26:45 <Lunar^> as, IIRC, "io" is often a synonym for liftIO
04:27:04 <Lunar^> at least in WASH
04:27:23 <genneth> TheHunter: really? because I would have thought that's a bit of a problem
04:28:01 <TheHunter> well if forkIO fails and the counter gets decreased, a new thread will be tried to be spawed immediately.
04:28:13 <genneth> oh I see
04:28:17 <genneth> yes, I suppose
04:28:44 <genneth> but it will still run out of threads at some point, and the RTS will kill the program for having a deadlocked thread
04:31:37 <TheHunter> i would think, once the counter has been decreased sufficiently, all forkIOs will succeed - except, of course there's something in your program that spawns many threads.
04:31:46 <TheHunter> s/something/something else/
04:32:07 <genneth> it may just be that the abstraction is not so good in general...
04:32:39 <genneth> in any case, it now works as expected, and it looks like the only point of failure would be if forkIO didn't work, at which point I would say bigger problems were afoot
04:32:52 <TheHunter> right.
04:33:20 <genneth> so the only problem left is that of STM on amd64
04:33:22 <genneth> :-p
04:33:59 <genneth> looking at the cvs for ghc on the web, I can't even find the source for it :-P oh well. I can wait
04:39:32 <TheHunter> @docs Control.Concurrent.QSem
04:39:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Concurrent.QSem.html
04:39:41 <TheHunter> this should do, shouldn't it?
04:40:07 <Lunar^> Igloo: here?
04:41:03 <genneth> TheHunter: I don't quite see it...
04:41:28 <TheHunter> btw, using |io| for an IO variable seems perfectly fine to me, just like using |m| for a monadic value.
04:42:18 <TheHunter> instead of a TVar, you use a QSem initialized with |lim|.
04:42:57 <TheHunter> the first atomically block becomes waitQSem, the second signalQSem.
04:43:08 <genneth> aha.... I see
04:43:33 <genneth> but if the forkIO fails, the signalQSem would still not be called
04:43:57 <TheHunter> it's precicely the same thing.
04:44:04 <TheHunter> anyway, off to lunch.
04:44:14 <genneth> you're in europe too then?
04:44:27 <TheHunter> yep, .de.
04:45:39 <genneth> i'm in .uk
04:45:42 <genneth> anyway
04:45:45 <genneth> enjoy your lunch
04:45:48 <genneth> thanks again
05:52:04 <Igloo> Lunar^: What's up?
05:56:14 <arjanoosting> Hi Igloo
05:57:26 <arjanoosting> I am playing with update-haskell-control but it doesn't work like I expected
05:57:55 <Igloo> How so?
05:58:29 <arjanoosting> If I remove an architecture from the generated debian/control file and run update-haskell-control --check afterwards it does not complain
05:59:05 <Igloo> It won't complain if you change what the variables expand to, only if you change something else
05:59:34 <arjanoosting> ?
05:59:45 <Igloo> I guess it could warn in the first case, but it can't fail because ghc 6.4-2 might support more arches than 6.4-1, say
06:02:37 <arjanoosting> So when does it complain? If i remove or add an build-dependency?
06:09:32 <Igloo> It complains if you change something unrelated to the variables that get expanded. e.g. if you fix a typo in the description, change the policy version, etc
06:13:22 <arjanoosting> Ok, I think i'm starting to understand
06:14:26 <arjanoosting> If a new version of ghc comes out the build-dependencies won't be fullfiled and the build proccess will fail anyway so update-haskell-control doesn't need to check that
07:07:14 <basti_> hi all.
07:07:24 <basti_> Philippa are you there?
07:32:05 <jlouis>   /g 9
08:09:47 <twb> Hi.  I've got a Common Lisp background an want to learn a bit about Haskell and what it can do.  Would anyone care to recommend tutorials, textbooks, compilers, &c?
08:13:47 <basti_> oh there are many
08:13:55 <basti_> of any =)
08:14:10 <basti_> first you'll need a compiler and/or interaction environment
08:14:23 <basti_> what OS do you use? some *nix?
08:14:24 <basti_> twb
08:14:29 <twb> basti_: Debian
08:14:42 <twb> Well, Emacs really.  But that runs inside debian.
08:14:53 <basti_> then I would recommend ghc, it comes with ghci, an interactive haskell system
08:15:27 <basti_> ghc-cvs delivers a late version which is what you might want for tinkering around
08:15:27 <twb> by interactive you mean a REPL?
08:15:33 <jlouis> twb: yes
08:15:35 <basti_> something similar yes
08:15:39 <twb> OK.
08:15:54 <basti_> haskell has no variables.
08:15:55 <basti_> ;)
08:16:08 * basti_ j/k
08:16:09 <twb> How do ghc 6 and ghc-cvs versions differ?
08:16:16 <twb> (other than the obvious)
08:16:41 <basti_> i don't know any specific differences
08:16:57 <TheHunter_> you almost definitely want a stable ghc.
08:17:03 <twb> OK.
08:18:09 <twb> I guess the Gentle Introduction is as good a tutorial as any other, right?
08:18:26 <basti_> hmm
08:18:29 <basti_> its not that gentle
08:18:46 <basti_> about as gentle as a pangalactig gurgleblaster if that tells you anything.
08:18:51 <Lemmih> It's gentle compared to the Haskell98 report.
08:19:16 <xs> bird's book is nice.
08:19:17 <twb> It doesn't look too bad.
08:19:37 <twb> xs: URL/ISBN?
08:19:43 <basti_> if you get ahead with the gentle introduction, don't let us stop you.
08:19:57 <TheHunter> "yet another haskell tutorial" might be worth a look, too.
08:20:01 <basti_> just don't wonder if your brain explodes somewhere
08:20:05 <basti_> YAHT is quite ok
08:20:14 * twb takes notes.
08:20:18 <xs> http://web.comlab.ox.ac.uk/oucl/publications/books/functional/
08:22:00 <basti_> the type system is quite different to lisp, and what makes learning haskell quite an experience
08:22:11 <jlouis> I actually liked the gentle introduction. I learned haskell  from it. With former functional programming language coding experience it has a lot of good properties
08:22:58 <basti_> i hit the gentle intruduction first, too, and understood quite a bit
08:23:10 <basti_> but i knew prolog and a little FP, and i'm good in maths
08:23:38 <twb> Well, I know a little Prolog, and the CL library is mostly functional.
08:23:43 <jlouis> I had a lot of SML experience before attacking it
08:23:55 <twb> SML is a flavour of ML?
08:24:07 <basti_> knowing prolog is a great advantage for learning haskell, since the type system works a lot like prolog
08:24:10 <twb> I think I've got an ML class next semester.
08:24:52 <basti_> (basically its an unification algorithm with some special rules)
08:26:00 <xs> haskell doesn't have lovely polymodality though?
08:26:09 <basti_> polywhat?
08:26:15 <basti_> it doesn't support higher order typing
08:26:19 <basti_> for some value of higher
08:26:44 <basti_> uhm but no
08:26:52 <basti_> it now supports some, but not everything, I think
08:26:54 <xs> predicates have no fixed return argument.
08:27:00 <jlouis> twb: yes, Standard ML
08:27:06 <twb> Aren't sets/lists and such orthogonal to the type system?
08:27:12 <basti_> haskell is NOT like prolog in the way the program is built
08:27:29 <basti_> haskell programs adhere to an evaluation "direction"
08:27:32 <basti_> unlike the rather "search" evaluation of prolog
08:28:04 <basti_> but if you know prolog, you know lots of things that help in various places for haskell
08:28:06 <jlouis> twb: I would not say sets/lists are orthogonal to the type system
08:28:17 <basti_> effective list management, for example, or the type system
08:28:19 <jlouis> a list of something have a type
08:28:36 <basti_> a list *is* a type ;)
08:28:52 <basti_> List a = Cons a (List a) | Nil
08:28:52 <jlouis> basti_: hehe
08:29:02 <basti_> with Cons and Nil and List being prettyprinted
08:30:04 <basti_> that makes a lot of sense since now the compiler knows what to expect when destructing a list (or any other type)
08:30:42 <basti_> it can warn you when you don't expect all cases, for example
08:31:44 * jlouis runs away again
08:32:05 <basti_> twb: is that what you wanted to know?
08:33:26 <twb> basti_: Yeah, pretty much.
08:34:06 <twb> I'm mostly just looking for excuses not to revise for my software engineering >spit< exam.
08:34:49 <basti_> ughhhh.
08:35:00 <basti_> well haskell is a good excuse for anything.
08:35:00 <basti_> :)
08:35:22 <twb> Much better response than I got in #forth :-)
08:35:40 <basti_> heheh
08:35:53 <jlouis> haha
08:35:55 <basti_> forth yoda like talks
08:36:16 <basti_> talking better prefix (like haskell)
08:36:36 <twb> Well, I like RPN...
08:36:45 <twb> I can't use an infix calculator anymore.
08:36:47 <basti_> i think RPN is great for calculators
08:36:59 <basti_> I own a HP48
08:37:13 <basti_> very practical, especially with the stack display
08:37:21 <basti_> lots less confusing than the arithmetic stuff
08:37:50 <twb> Going from CL to C was a nightmare of precedence :-)
08:38:29 <basti_> CL?
08:38:34 <twb> Common Lisp.
08:39:10 <basti_> ah
08:39:32 <twb> Very sexy, but aloof.
08:39:47 <twb> Getting it to talk to anything else is a PITA.
08:39:58 <basti_> ;)=
08:42:09 <basti_> haskell has a great FFI, btw
08:42:18 <twb> Standardized?
08:42:33 <basti_> hmm
08:42:37 <twb> ;-)
08:42:45 <jlouis> twb: standardized, yes
08:42:48 <basti_> not formally
08:42:49 <basti_> it is?
08:42:54 <basti_> then i was lying.
08:43:01 <jlouis> it is an extension to Haskell98
08:43:10 <basti_> ok
08:43:42 <basti_> I'll be back later though
08:43:44 <basti_> cu
08:45:36 <twb> Whoa, lhs format is a little weird.
08:58:53 <twb> Can I write "f g x", or do I have to write "f (g x)"?
08:59:52 <qmole> f $ g x
08:59:55 <arjanb> f g x is the same as ((f g) x)
09:00:21 <twb> So I can leave out parens as long as it's unambiguous?
09:00:44 <twb> Oh, I see.
09:21:40 <SamB> @pl f (g x)
09:21:41 <lambdabot> f (g x)
09:28:24 <genneth> @moo
09:28:26 <lambdabot>             (____)
09:28:26 <lambdabot>             (o  o)
09:28:26 <lambdabot>       /-----\    /----
09:28:26 <lambdabot>      / |   |  \/   |
09:28:26 <lambdabot>      \ |  |      | | |
09:28:26 <lambdabot>       *| | |-----| | |
09:28:28 <lambdabot>        /\ /\     /\ /\
09:28:30 <lambdabot>   This was Salvatore
09:28:32 <lambdabot>  Dali's favorite cow
09:28:47 <genneth> I could do this all day long
09:30:15 <sorje> it responds to private messages too ;-)
09:30:31 <genneth> so you could have a private ascii cow fetish session
09:30:42 <genneth> maybe this is the wrong channel for that
09:30:44 <reffie> @ghc
09:30:45 <lambdabot>  A lazy (~) pattern connot bind existential type variables
09:30:59 <genneth> what does @ghc actually do?
09:31:07 <genneth> because I can't decipher the words :-/
09:31:19 <reffie> it shows error messages that ghc could give
09:31:23 <reffie> gives
09:31:58 <genneth> okay
09:32:14 <genneth> but pretty useless for explaining what an error message means?
09:32:52 <Lycan359> I started learning ocaml today as well... I think I like it better then haskell.
09:33:31 <largezhang> well, ocaml looks hairy with the OO
09:33:36 * genneth gasps and closes his ears
09:33:51 <twb> This may be a dumb question, but if Haskell is purely functional, how does it read/write to files/stdin/stdout?
09:34:13 <largezhang> twb: read about IO Monad
09:34:27 <Lycan359> I just don't like the lazy aspect.
09:35:01 <Lycan359> It doesn't really seem worth it. Sure you can do some neat things but is it really worth the performance penalty?
09:35:02 <largezhang> Lycan359: but it is the only way to handle infinite data structure
09:36:32 <largezhang> lazy evaluation really reflects human thinking-- we talk about natural numbers all through
09:37:44 <SamB> Lycan359: performance penalty?
09:37:59 <SamB> haskell is about thinking!
09:38:38 <Lycan359> :\
09:39:13 <largezhang> maybe lamda is even better
09:39:54 <arjanoosting> @ghc
09:39:55 <lambdabot>  Generic method type is too complex
09:40:20 <SamB> that one is SO bad...
09:40:46 <SamB> @ghc
09:40:47 <lambdabot>  No constructor has all these fields
09:40:52 <largezhang> lamdabot: you mean the strategylib?
09:41:08 <SamB> hmm, that one sounds pretty sweet ;-)
09:41:33 <SamB> @ghc
09:41:34 <lambdabot>  foreign declaration uses deprecated non-standard syntax
09:45:58 <TheHunter> hmm, "Generic method type is too complex"
09:52:20 <TheHunter> yeah!
09:52:27 <TheHunter> |class Foo a where foo :: (forall b. a -> b) -> Int; foo {| a -> Unit |} _ = 0|
09:53:00 <genneth> o_O
09:53:05 <TheHunter> that was quite a challenge
09:55:02 <genneth> that was challenge to read
09:55:27 <genneth> and people say you can't write obfuscated code in haskelll
10:02:26 <TheHunter> you can write all kinds of obfuscated code in haskell
10:04:03 <TheHunter> @plugs let(!)+(?)=(!)(?)in(*2)+2
10:04:11 <lambdabot> 4
10:06:18 <SamB> genneth: who told you that?
10:06:30 <TheHunter> @wiki ObfuscatedHaskellContest
10:06:31 <lambdabot> http://www.haskell.org/hawiki/ObfuscatedHaskellContest
10:33:47 <wagle> i thought all code in haskell was obfuscated..  8)
10:34:45 * wagle has repeatedly watched the haskell people confound the oo people with sample haskell code
10:49:54 <jlouis> wagle: hehe
10:51:51 <xs> is it possible to do something like.. foldr1 ($) [1,2] (\x y -> x + y) ? i'm being dumb.
10:52:58 <jlouis> xs: what do you want to do?
10:53:17 <Igloo> I think you want  foldr1 (\x y -> x + y) [1,2]
10:53:27 <xs> i want to apply a function to a list of values.
10:53:28 <xs> hm.
10:53:29 <Igloo> Or equivalently  foldr1 (+) [1,2]
10:53:57 <xs> but that won't work for say, \x y z -> ..?
10:54:23 <Igloo> No, that's not what foldr does
10:54:28 <jlouis> xs: folds cannot do that
10:54:48 <xs> ah. hm. ok. thanks.
10:55:29 <jlouis> if you write your list as 1 : 2 : ... : [], then a fold, more or less, replaces the ``:'''s with a function of your choice and an initial value for []. In the case of fold{r,l}1 this value is simply taken from the list
10:59:00 <Cale> ikibook
10:59:12 <Cale> odd focus
10:59:50 <Cale> there: http://en.wikibooks.org/wiki/Programming:Haskell_List_Processing
11:00:03 <Cale> You might have a look at the section on folds
11:01:42 <xs> hm, thanks.
11:03:15 <xs> la [] f = f; la (x:xs) f = la xs (f x) is what i want. but it does not like the types. eh.
11:31:30 <jlouis> xs: la xs (f . x) or la xs (x . f) maybe
11:35:33 <xs> hm, i was thinking that, for sample, la [1,2] (+) => 3, la [1,2,3] (\x y z -> x + y +z) => 6. or something.
11:35:42 <xs> but . only works on functions?
11:36:09 <Cale> . is function composition
11:36:22 <Cale> (f . g) x = f (g x)
11:36:52 <xs> ahh
11:36:58 <Cale> just like in mathematics
11:39:06 <xs> hm, so haskell can't do recursive function types?
11:42:35 <ski> depends on what you meant by recursive ..
11:43:37 <xs> f :: Int -> Int -> ...?
11:44:16 <xs> so f :: a, where a is a -> Int
11:44:25 <goron> Anyone using GMail here?
11:44:33 <Lemmih> Yeah.
11:44:48 <ski> xs : that is sometimes called a cyclic type, and sometimes called an equ-recursive type
11:44:59 <ski> xs : haskell doesn't have such
11:45:12 <goron> Lemmih: I get this like a lot. And now I can't access my mail for like 20 minutes.
11:45:15 <goron> Server Error
11:45:18 <goron> Gmail is temporarily unavailable. Cross your fingers and try again in a few minutes. We're sorry for the inconvenience.
11:45:21 <xs> hm, ok, thank you!
11:45:38 <ski> xs : haskell has the other kind, sometimes called just recursive types, sometimes iso-recursive types
11:45:50 <goron> Lemmih: All the kids from the block always shout that they have "massive" computing power, but a simple mailserving is to hard, so it seems.
11:46:07 <ski> xs : like e.g.  data RecFun a b = Ret b | Get (a -> RecFun a b)
11:46:31 <Lemmih> goron: It works for me.
11:46:42 <goron> Lemmih: You can access it now?
11:46:58 <xs> ski: don't those get ugly to use?
11:47:05 <goron> Lemmih: Pinging is also slow: time=163.882 ms
11:47:11 <SyntaxNinja> hiya
11:47:11 <Lemmih> goron: Yes.
11:47:17 <Lemmih> Greetings, SyntaxNinja.
11:47:26 <ski> xs : depends
11:47:37 <SyntaxNinja> Lemmih: YGM.  let me know if you can do that now?
11:47:58 <goron> Lemmih: I tried to access it via links, I got access the first time(I made it to the login page), but that was it. Thanks
11:47:58 <Lemmih> YGM?
11:47:59 <ski> xs : for lists, it's not very ugly, imo
11:48:27 <xs> ski: is there somewhere i read up more about this stuff?
11:48:49 <SyntaxNinja> you've got mail
11:49:26 <ski> xs : possibly, though i'm not sure exactly where
11:49:28 <Lunar^> dons: here?
11:49:59 <ski> xs : mayhaps search for papers with "iso-recursive" and "equi-recursive" ..
11:50:50 <xs> ski: thanks will do
11:52:56 <Heffalump> anyone know how to compare type widths in the C preprocessor? (this is a Haskell-related question, honest..)
11:55:02 <ibid> the only thing you can do is compare limits.h macros
11:55:08 <Lemmih> SyntaxNinja: Both 'runTests.sh' and 'make check' fails because Distribution.Compat.Direction is hidden.
11:55:14 <ibid> cpp does not know sizeof
11:55:24 <Heffalump> yeah, I thought there was some trick one could use
11:55:27 <Heffalump> but maybe not.
11:55:38 <ibid> you can compare limits.h macros :)
11:55:54 <Heffalump> that's no use if the types aren't standard C types
11:56:01 <ibid> true
12:00:04 <Igloo> I think you're thinking of being able to use sizeof in initialisation assignments where expressions normally aren't allowed
12:00:44 <ibid> constant expressions are :)
12:02:08 <Igloo> YKWIM  :-)
12:02:32 <ibid> YID
12:04:36 <SyntaxNinja> Lemmih: you'r eusing ghc 6.4? hide cabal first.
12:05:17 <Lemmih> Same error.
12:06:13 <SyntaxNinja> Lemmih: it should only be complaining about that for installed packages, not modules in the current directory, where it's meant to be looking.
12:06:28 <SyntaxNinja> Lemmih: does ghc-pkg -l |grep Cabal show any cabals not in parens?
12:06:34 <SyntaxNinja> or maybe you actually have to remove it :(
12:06:46 <Lemmih> '-ignore-package Cabal' /= hide Cabal.
12:07:54 <SyntaxNinja> Lemmih: it's not looking at the right Compat.Directory.
12:09:06 <Lemmih> Compiling with '-ignore-package Cabal' is the right thing to do.
12:09:33 <SyntaxNinja> does it work?
12:09:44 <Lemmih> I'm getting lots of failures but they aren't related to my patch.
12:12:15 <SyntaxNinja> if that's the case, and you fixed the one I mentioned, then please send the fix along :)
12:12:59 <Lemmih> Sent.
12:14:14 <goron> Are there any other e-mail services that also have "conversations" like Google does? I am getting very annoyed with GMail.
12:14:37 <SyntaxNinja> goron: sshh. google can hear you.
12:14:51 <goron> SyntaxNinja: I begin to think that yes.
12:15:05 <goron> SyntaxNinja: I think Google is becoming sentient.
12:15:42 <goron> SyntaxNinja: There are guys who haven't been able to read their mail for over a week.
12:15:45 <SyntaxNinja> any minute now it's going to take over my rumba and make it kill me
12:16:00 <Lemmih> Gmail works fine for me...
12:16:03 * SyntaxNinja doesn't actually have a rumba
12:16:10 <Igloo> What's a "conversation"?
12:16:30 <goron> Igloo: Imagine a mailinglist.
12:16:36 <Lemmih> @dict conversation
12:16:37 <lambdabot> Supported dictionary-lookup commands:
12:16:37 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @
12:16:37 <lambdabot> jargon @lojban @prelude @vera @web1913 @wn @world02
12:16:37 <lambdabot> Use "@dict-help [cmd...]" for more.
12:16:47 <goron> Igloo: Combine that with forums.
12:16:57 <goron> Igloo: Think threads in your inbox.
12:17:17 <goron> Igloo: So the messages are ordered by subject.
12:17:20 <genneth> goron: you still out on the gmail count?
12:17:33 <goron> genneth: :?
12:17:55 <genneth> can you still not access your gmail account?
12:18:05 <goron> genneth: oh, ok.
12:18:08 <goron> genneth: yes
12:18:33 <genneth> because I can access it via the webmail interface, but pop3 just complains that my username/password is wrong
12:18:34 <goron> Igloo: Also, when someone replies, not the whole message is repeated again.
12:19:02 <goron> Igloo: It really transforms your webmail in a private forum.
12:19:27 <goron> Igloo: The bad thing... is that (at least in my country) the service sucks.
12:19:39 <goron> I never had that Yahoo! was unavailable.
12:19:58 <arjanoosting> Igloo: I have just uploaded a new version of the haxml package to my weboage
12:20:00 * goron can still receive the Haskell Cafe :D
12:20:52 <arjanoosting> s/weboage/webpage
12:32:52 <Heffalump> buggerbugger can't make String a type class instance
13:31:21 <MachinShin> hey +
13:31:45 * sbeyer wrote a binary search tree balancing function (just as an exercise) in Haskell today and was amazed how few lines of code it took ;)
13:33:47 <SyntaxNinja> sbeyer: :)
13:33:48 <sbeyer> (http://noxa.de/~sbeyer/tmp/bstree.hs)
13:33:50 <sbeyer> :)
13:34:13 <SyntaxNinja> sbeyer: do you find them to be readable  lines as well?  I think Haskell is great because it's not only compact, but also very readable even when its compact.
13:34:15 <SyntaxNinja> though not always.
13:34:37 <sbeyer> SyntaxNinja, yes, readable if you know Haskell syntax, of course ;)
13:35:00 <lispy> well i found some code in darcs that is unreadable, and i know haskell syntax ;)
13:35:17 <sbeyer> SyntaxNinja, and understandable - at least when you took a sheet of paper and draw some trees ;)
13:35:21 <jlouis> Haskell doesn't have a lot of those silly declaration keywords you see in other languages
13:35:56 <sbeyer> lispy, when I read that darcs was written in Haskell I also took a 5-minute-look over the code and thought it was disgusting ;)
13:36:05 <sbeyer> but it was just a 5-minute-look ;)
13:37:39 <jlouis> darcs could use some spring cleaning i think
13:38:48 <jacobian> Sounds like he reinvented transaction logic
13:39:42 <jacobian> not that that is a bad thing
14:23:59 <Heffalump> does the FFI do any type checking on import declarations?
14:34:44 <kosmikus> I don't think so
14:45:16 <Heffalump> hmm, that could be rather inconvenient given the hacky nature of this API
14:45:50 <Heffalump> (it uses a macro to decide whether or not things should take an implicit argument
14:49:58 <lispy> object oriented C?
14:50:41 <lispy> is there any sort of heuristic for deciding if a graph has a hamiltonian path?
14:50:47 <lispy> i can't find one
14:52:09 <Heffalump> can't you just count the number of edges from each vertex?
14:52:42 <Heffalump> oh, no, I'm confusing Hamiltonian and Eulerian, sorry
14:53:54 <lispy> that's true for Eulerian, and it's a important for Ham, but not enough
14:54:12 <lispy> i'm bad at searching
14:54:19 <lispy> i thought google would be a good place to start
14:54:25 <lispy> but it's not really ;)
14:59:50 <astrolabe> have you checked wikipedia?
15:00:01 <lispy> no
15:00:03 <lispy> that's a good idea
15:00:47 <Heffalump> the mathworld article seems just to be an advert for Mathematica
15:00:59 <lispy> they often are
15:01:02 <lispy> sadly
15:09:18 <TheHunter> how large and how random are your graphs?
15:11:23 <jlouis> lispy: splitting it into strongly connected components might be interesting
15:12:42 <lispy> the graphs are actually chessboards which are missig pieces.  The "edges" are given implicitly, by the way a knight can move around the board
15:13:08 <lispy> i have an idea for a heuristic
15:13:24 <lispy> start somewhere, travel as far as you can without using backtracking.
15:13:44 <lispy> then start in a new place, and try to stop so that you'd meet up with the previous "tour"
15:13:59 <lispy> keep doing that
15:14:06 <lispy> then see if you can make it one tour
15:14:45 <jlouis> eventually, let that be the initial guess for a branch-and-bound sucker
15:14:59 <lispy> eh?
15:15:28 <jlouis> hamiltonian paths are NP-C
15:15:35 <lispy> righ
15:15:44 <lispy> i'm just looking for a heuristic
15:15:51 <jlouis> oh
15:15:54 <jlouis> ok
15:16:19 <lispy> i've implemented an exhaustive search
15:16:31 <lispy> but i also need a heuristic
15:16:56 <lispy> since there doesn't appear to be a heuristic for the actual problem i'm solving, and my problem seems similar to ham. path, i thought i could adapt one ;)
15:17:16 <lispy> but finding one for ham. path has proven difficult as well
15:25:53 <jlouis> lispy: no wonder. The one you gave seems quite effective
15:32:16 <lispy> jlouis: really?  I'm working some example and it's not clear to me how to make paths meet up
15:33:59 <astrolabe> Could you come up with some simulated annealing approach?
15:34:15 <lispy> that would be probalistic right?
15:34:27 <astrolabe> yeah
15:34:48 <lispy> hmm...
15:35:06 <lispy> i had assumed out heuristics should be deterministic, but i don't think anything in the assignment rules it out
15:35:46 <astrolabe> and pseudo random numbers are deterministic :)
15:36:22 <lispy> heh
16:31:30 <lispy> ah here we go.  look at the board, if there are any squares of degree=0, then output No.  Otherwise, take the square with lowest degree, make a path until you get blocked by moving to square of lowest degree every time.  Now repeat this until you either have a square of degree 0, or a tour
16:32:08 <lispy> and just don't spend much time joining tours
16:32:17 <lispy> if it's obvious good, otherwise assume they don't join
18:14:25 <dons> @y0w
18:14:27 <lambdabot> I have many CHARTS and DIAGRAMS..
18:16:27 <dons> @seen Lunar^
18:16:28 <lambdabot> Lunar^ is in #haskell. Last spoke 6 hours, 26 minutes and 59 seconds
18:16:28 <lambdabot> ago.
18:16:34 <Lunar^> dons: here :)
18:17:01 <dons> hey, you pinged?
18:17:09 <Lunar^> dons: Are you aware of any problem between forkOS and System.Eval.eval?
18:17:34 <dons> I'm not aware of any issues.
18:18:00 * Lunar^ writes a test case, then
18:18:16 <dons> cheers
18:18:30 <dons> eval is forking ghc in the background
18:19:21 <stefanh> hi dons
18:19:28 <stefanh> ever seen this problem?
18:19:45 <dons> hey stefanh
18:19:57 <stefanh> user error (Curses[-1]:keypad)
18:20:04 <dons> yep!
18:20:22 <stefanh> I'm trying to cabalize HSCurses, everything compiles fine, but then I get this runtime error.
18:20:40 <dons> with ghc 6.4 and -fvia-C
18:21:03 <stefanh> ah, I use -fvia-C ...
18:21:05 <dons> ghc 6.4 generates wrong code on our curses code when compiled -fvia-C, leading to that error
18:21:12 <dons> -fasm fixes this, and so does 6.4.1
18:21:21 <dons> there's a note in the Yi mk/config.mk on the problem
18:22:19 <dons> # With ghc-6.4 -fvia-C produces a buggy binary, dying with:
18:22:19 <dons> #       user error (Curses[-1]:keypad)
18:22:19 <dons> #       yi-static: user error (Curses[-1]:keypad)
18:22:21 <dons> # HEAD of ghc, (at least as early as) May 17 2005 or later seems to fix this.
18:23:15 <dons> I think John Meacham said Ginsu had the same problem
18:23:33 <Lunar^> dons: I confirm, there's a problem
18:24:13 <dons> can you send me the test case and any relevant info?
18:24:18 <dons> platform, compiler etc
18:24:23 <Lunar^> dons: for sure :)
18:24:51 <dons> you using latest darcs hs-plugins?
18:25:13 <Lunar^> dons: yep
18:28:55 <tibbetts> Anyone know of an available Tutorial D or SQL implementation in Haskell?
18:30:25 <Lunar^> tibbetts: look at HaskellDB
18:30:54 <Lunar^> tibbetts: mhh SQL database implementation ? or a binding to a SQL database?
18:31:12 <tibbetts> Database implementation, not a binding.
18:31:26 <tibbetts> I'm looking for a jumping off point for some research.
18:32:22 <tibbetts> What does "mhh" mean?
18:38:14 <Lunar^> tibbetts: that HaskellDB is not what you want
18:38:44 <Lunar^> tibbetts: There is some kind of database in Haskell... can't remember the name though
18:39:40 <dons> was there something to do with Trex?
18:40:05 <Lunar^> dons: damn
18:40:20 <Lunar^> dons: I can reproduce the bug 100% on my Linux PPC
18:40:32 <Lunar^> dons: but Linux i386 works
18:40:37 <dons> oh!
18:40:51 <dons> with forkOS? hmm.
18:41:01 * Lunar^ adds -fvia-C
18:41:08 <dons> yep.
18:43:02 <Lunar^> that's a strange one
18:43:16 <Lunar^> -fvia-C doesn't help
18:43:36 <dons> how is it failing?
18:43:57 <Lunar^> Let me send the mail
18:44:20 <dons> you could compile hs-plugins with -DDEBUG in config.mk:GHC_EXTRA_OPTS and get lots more debug info
18:46:18 <Lunar^> dons: mail sent
18:47:45 <dons> got it. testing on openbsd..
18:48:26 <dons> ok, works:
18:48:27 <dons> paprika$ ./a.out
18:48:28 <dons> starting action
18:48:28 <dons> forkOS
18:48:28 <dons> starting action
18:48:30 <dons> forkIO
18:48:33 <dons> starting action
18:48:35 <dons> main
18:48:37 <dons> that's right, yeah?
18:48:44 <Lunar^> dons: yep
18:49:07 <Lunar^> $ ./a.out
18:49:07 <Lunar^> starting action
18:49:07 <Lunar^> forkIO
18:49:07 <Lunar^> starting action
18:49:07 <Lunar^> main
18:49:18 <Lunar^> that's all what I got here
18:49:33 * Lunar^ is dumb
18:49:41 <dons> ?
18:49:42 <Lunar^> it's not related to hs-plugins at all then
18:50:01 <dons> why?
18:50:19 <Lunar^> there's only 2 "starting action"
18:50:28 <dons> oh..
18:50:41 <dons> forkOS isn't even forking
18:50:46 <Lunar^> but!
18:51:11 <Lunar^> commenting out "eval" and "action" lines yields 3 "starting action"
18:51:24 <Lunar^> so it seems hs-plugins related
18:52:15 <Lunar^> dons: forkOS is forking, addind a putStrLn before calling eval in "test" prints 3 lines
18:52:32 <dons> ok.
18:52:37 <Lunar^> dons: could the background call to GHC close stdout?
18:52:46 <dons> oh!
18:53:11 <Lunar^> dons: what does hs-plugins use to call GHC ?
18:53:33 <dons> exec prog args = do
18:53:33 <dons>     (_,outh,errh,proc_hdl) <- runInteractiveProcess prog args Nothing Nothing
18:53:33 <dons>     output <- hGetContents outh
18:53:33 <dons>     errput <- hGetContents errh
18:53:33 <dons>     forkIO (Control.Exception.evaluate (length output) >> return ())
18:53:35 <dons>     forkIO (Control.Exception.evaluate (length errput) >> return ())
18:53:38 <dons>     waitForProcess proc_hdl
18:53:41 <dons>     return ( lines $ output, lines $ errput )
18:54:22 <dons> emulates popen, basically.
18:54:33 <Lunar^> @index runInteractiveProcess
18:54:35 <lambdabot> System.Process
18:55:18 <dons> but I don't understand why this works on x86 and now powerpc
18:55:23 <dons> s/now/not
18:55:38 <Lunar^> dons: #ifdefs :)
18:55:53 <dons> :P
18:57:05 <dons> oh! maybe it just didn't work on my linux/x86 box
18:57:15 <dons> hmm:
18:57:16 <dons> pill00$ ./a.out
18:57:17 <dons> starting action
18:57:17 <dons> forkOS
18:57:17 <dons> starting action
18:57:19 <dons> main
18:57:28 <Lunar^> where's forkIO ?!
18:57:54 <dons> hmm... there's a race..
18:57:59 <dons> it worked once out of 3
18:58:14 <dons> one time it didn't work at all
18:58:18 <Lunar^> increasing the delay could help
18:58:29 <dons> $ ./a.out
18:58:29 <dons> starting action
18:58:29 <dons> main
18:58:39 <Lunar^> a.out: waitForProcess: does not exist (No child processes)
18:59:38 <dons> should wrap a catch around the wait call
18:59:40 <Lunar^> when trping $ exec "/usr/games/wtf" ["wtf"]
18:59:47 <Lunar^> trying
18:59:56 <Lunar^> means that it's already over?
19:00:29 <dons> hmm. no. it should clean up the zombie
19:00:40 <dons> hmm. though I wonder ..
19:02:00 <Lunar^> runInteractiveProcess in forkIO fail
19:02:08 <Lunar^> but works in forkOS
19:03:06 <Lunar^> runInteractiveProcess or something else, at least I get the ENOCHILD
19:03:13 <dons> hmm
19:03:44 <Lunar^> I wonder what strange thing GHC does
19:04:19 <wagle> how do you wait for the child process?
19:04:21 <Lunar^> anyway, I will make my demo on a x86
19:04:34 <Lunar^> wagle: scrollback to dons "exec"
19:04:48 <wagle> i am
19:05:03 <dons> Lunar^, so you want to run the eval in another thread to avoid the main thread blocking on compilation?
19:05:17 <dons> this seems like a nice idea, btw.
19:05:38 <wagle> i see two forkIO's with no identification of either that i can see
19:05:46 <Lunar^> dons: I'm using 'eval' to write primops in a small agent programming language
19:05:48 <wagle> hence my question
19:06:11 <dons> wagle? we wait with waitForProcess
19:06:22 <Lunar^> dons: and agents fork a lot :D
19:06:29 <dons> ok.
19:06:43 <wagle> the forkIO's arent the forks?
19:06:55 <dons> oh, I see  what you mean.
19:07:13 <dons> there's two issues: (1) Lunar^ has a program with threads of different flavours
19:07:19 <Lunar^> dons: integration was very smooth btw, just a matter of parsing strings between '#' and feeding that to 'eval'
19:07:25 <dons> (2) it's using System.Eval.eval, which runs processes.
19:07:39 <dons> good :)
19:08:01 <dons> now just have to work out what this interaction between concurrency and System.Process is..
19:08:19 <dons> ls
19:08:24 <dons> wrong window.
19:08:31 <Lunar^> dons: using your "exec" with "wtf" doesn't close stdout
19:09:11 <dons> no, I don't think exec is closing any handles
19:10:32 <Lunar^> dons: 4am here.. that's not a big deal either
19:10:54 <dons> :}
19:11:11 <Lunar^> dons: I can always work around by keeping an agent that putStrLn whatever arrive on its channel running in the main thread
19:11:50 <dons> yeah, I was just thinking that
19:12:18 <dons> my guess atm is there's a race between the sleep/the threads finishing, and the forked process finishing
19:12:25 <Lunar^> dons: are you familiar with pi-calculus?
19:12:44 <dons> is that Barendreght's lambda cube?
19:14:10 * Lunar^ checks 
19:15:15 <dons> using a chan or the like to connect the threads back to the main program is probably a good idea.
19:15:28 <dons> like you say.
19:18:19 <Lunar^> can't find any paper in english
19:18:27 <Lunar^> that's a shame
19:19:13 <Lunar^> anyway... off to bed
19:19:22 <dons> I've added a note to the manual to warn people to be careful if they use eval from a thread :)
19:19:41 <dons> night!
19:21:53 <wagle> pi-calculus isnt barendregt's lambda cube
19:22:42 <dons> ok.
19:22:51 <wagle> should be able to find stuff on both in english
19:23:10 <Lunar^> wagle: I was searching for Peschanski's work
19:23:15 <Lunar^> what I'm currently implementing
19:23:35 <wagle> ah..  what is peschanski working on?
19:23:56 <Lunar^> distributed cube-calculus, if I got the background right
19:24:32 * Lunar^ really off this tmi
19:24:33 <Lunar^> time
19:54:32 <tibbetts> What do people use for unit tests when  developing haskel programs? is there a popular package, or do people roll their own?
19:54:52 <Igloo> hunit
19:55:13 <tibbetts> I should probably have been able to guess that name. :) Thanks.
19:55:22 <tibbetts> s/haskel/haskell/ sigh.
20:00:57 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/HUnit/Test.HUnit.Base.html -- it's in the libraries
20:01:19 <Cale> but it doesn't appear terribly well documented from there
20:01:42 <Cale> http://hunit.sourceforge.net/HUnit-1.0/Guide.html
21:10:11 <SyntaxNinja> does anyone know why latex causes some stuff to bleed into the margins instead of breaking the line? particularly when I use \texttt?
21:10:31 <lispy> hmm...
21:10:31 <dons> hey conal
21:10:37 <lispy> it doesn't know how to break it correctly
21:11:06 <conal> dons, hi
21:11:13 <lispy> SyntaxNinja: if you put the thing which bleeds inside a box explicitly it may put it on the next line
21:12:07 <SyntaxNinja> lispy: what do you mean?  like, i have a bunch of plain text, and I use a \texttt{thisisaratherlohngword}; if that comes at the end of a line, then it'll bleed intot he margin
21:12:38 <lispy> SyntaxNinja: \mbox{\textttt{thisisaratherlohngword}}
21:12:45 <lispy> SyntaxNinja: not sure if it will help...
21:12:55 <lispy> probably not in this case
21:13:41 <SyntaxNinja> nah, does the same thing.
21:16:41 <lispy> SyntaxNinja: at this point i only see a few options.  1) Make the texttt stuff in a smaller font 2) explicitly drop it to the next line.  But both of those solutions are terrible.  If you change anything before that text it may come back as a problem
21:17:33 <SyntaxNinja> yeah. I guess I'll wait until I'm just about ready to submit it and then fix all the overfills by hand :(
21:17:45 <SyntaxNinja> but I really thought latext was smarter than this.
21:18:16 <lispy> it's smart, but not perfect
21:19:16 <lispy> iirc the short intro to latex explains how to get slugs in the margins so that you can find overfills easily
21:19:34 <reffie> http://segfaulted.com/screenshots/Screenshot-31.png
21:20:53 <lispy> uh...
21:21:29 <SyntaxNinja> reffie: did you mean to post that to #gbadev? ;)
21:21:40 <reffie> i meant to post it everywhere!!!
21:21:46 <SyntaxNinja> because it's so sweet?
21:21:55 <reffie> sure
21:22:05 <SyntaxNinja> reffie: the transparency is nice, but I see several religious problems with it ;)
21:22:06 <lispy> i don't get it
21:22:17 <reffie> SyntaxNinja hahah
21:22:58 <SyntaxNinja> 1) vi, 2) macOS, 3) C
21:23:21 <lispy> and freebsd segfaulting...
21:23:29 <reffie> well, to be fair, all the terminals (except the one in the back) are sshed to a freebsd box
21:26:25 <SyntaxNinja> I messed with transparency in Linux for a while, but it ended up not being worth it.
21:26:29 <SyntaxNinja> though it's quite cool.
21:26:38 <SyntaxNinja> it really just makes stuff hard to see ;)
21:26:45 * lispy nods
21:26:52 <SyntaxNinja> I guess there's a reason The Maker didn't make everything out of glass ;)
21:27:05 <reffie> the trick is to not make it too transparent
21:27:11 <lispy> the maker?  where is he from apple/
21:27:40 <dons> there's a reason that book pages aren't transparent
21:27:59 <lispy> dons: yeah, it's hard to make transparent paper that lasts
21:28:15 <dons> maybe if our eyes had a tighter focus, and you could blur away the background detail..
21:28:55 <SyntaxNinja> lispy: no, the one who made the rest of the stuff, not by apple
21:29:05 <lispy> tighter in which direction? depth?
21:29:09 <dons> oh, Bill Gates you mean?
21:29:17 <dons> depth, yeah.
21:29:48 <dons> it could be that transparency with a depth of field would work
21:29:54 <lispy> dons: i was going to say, "Well actually..." otherwise
21:30:10 <lispy> dons: but yeah i could see that
21:30:16 <lispy> (pun intended)
21:31:07 <dons> i wonder if anyone hass tried this? transparency with and adjustable gaussian blur on the background windows?
21:31:20 <dons> seems like it might interesting to try
21:31:35 <lispy> but how would you ever focus on the behind things?
21:31:47 <lispy> surely you would want to peek at them (focus) some of the time?
21:31:49 <dons> so 'focus' in the window manager would really be focus.
21:32:15 <lispy> heh
21:32:35 <lispy> i'd prefer motion blur
21:32:51 <lispy> just have all the windows i'm not 'focusing' on zip around the screen
21:33:11 <dons> blur away like a warp jump perhaps
21:33:13 <lispy> have them stop, speed up, slow down, teleport
21:33:55 * lispy wonders why he's never been invited to a UI design session
21:43:14 <dons> fun program:
21:43:17 <dons> import System.Plugins
21:43:17 <dons> main = do
21:43:17 <dons>         s     <- load "t.o" [] [] "main"
21:43:17 <dons>         case s of
21:43:17 <dons>                 LoadFailure _       -> return ()
21:43:20 <dons>                 LoadSuccess m dmain -> dmain
21:43:32 <dons> where this module is "t.hs" ;)
21:44:32 <SyntaxNinja> dons: ooi, have you thought much about integrating cabal w/ hs-pluggins?
21:44:34 <lispy> just keeps loading itself?
21:45:08 <dons> lispy, yep. load..jump..load..jump..load..jump
21:45:14 <ozone_> SyntaxNinja: i was going to get around to that sometime in my lifetime ...
21:45:14 <dons> SN, in what way?
21:45:32 <dons> I think there's a lot of room to add plugin support.
21:45:40 <SyntaxNinja> ozone_: oh yeah? what did you have in mind?
21:45:58 <ozone_> SyntaxNinja: just modify it so you can do a ./cabal setup and all that
21:46:14 <dons> oh, you mean just add a Cabal build system to hs-plugins?
21:46:17 <ozone_> SyntaxNinja: though maybe it's been done already, i haven't checked don's progress in the last few seconds.  you gotta watch out for that don guy, he's fast
21:46:24 <dons> that's on the list fo the next few weeks.
21:46:32 <SyntaxNinja> dons: well, it just seems like, if hs-plugins is meant to compile and load modules, cabal could help w/ more complex ones
21:46:43 <dons> yep. that's what i think too
21:46:53 <dons> ah!
21:46:57 <SyntaxNinja> Lemmih just added profiling support, btw.
21:47:05 <dons> cabalAndLoad  for example
21:47:16 <dons> rather than calling the hs-plugins make() or makeAll()
21:47:22 <SyntaxNinja> I'd be glad to add flags or whatever to cabal if it needs to do anything fancy
21:47:22 <SyntaxNinja> yeah
21:47:25 <dons> hmm.. this seems kinda cool
21:48:08 <dons> if Yi was cabalised, then cabalAndLoad could easily hot swap Yi on the fly. currently Yi's build system is too complex for hs-plugins' make, but not for Cabal!
21:48:08 <SyntaxNinja> ozone_: so do you mean to distribute hs-plugins as a cabal package?  that too :)
21:48:19 <SyntaxNinja> ooh!
21:48:59 <dons> ok. this is definitely something we need to add.
21:49:03 <SyntaxNinja> :)
21:49:06 <ozone_> SyntaxNinja: congrats with cabal, btw.  it's a really good blend of easy-to-use and power
21:49:09 <dons> any cabalised app could get hotswapping support
21:49:13 <ozone_> it's hard to find the right balance, so kudos
21:49:27 * dons makes some notes
21:49:56 <SyntaxNinja> ozone_: thanks!  I had a lot of help too; guys like JaffaCake (simonMar) and ross p have a lot of good taste in that area.
21:50:17 <SyntaxNinja> ozone_: my motto is "just the right amount of magic" :)
21:50:17 <ozone_> SyntaxNinja: not to mention alex jacobson!
21:50:35 * ozone_ will be nice now, promise
21:50:38 <SyntaxNinja> ozone_: lol.
21:51:32 <SyntaxNinja> dons: do let me know if you need anything for that. it's exactly the kind of thing i want to be able to support.
21:52:58 <dons> hs-plugins' make() is a good interface to ghc -c, but can't really do anything more than that (ghc --make -fno-code being the absolute limit). hot swapping of app code dynamically is where hs-plugins is now heading -- particularly in Yi and Lambdabot.  Currently we need to step out to a shell to recompile an application or library, not just a simple plugin .o. This is where cabal fills the gap perfectly.
21:53:48 <dons> so Cabal + HsPlugins would make hot swapping programmable. No command line or makefiles required.
21:54:33 <SyntaxNinja> yay!
21:54:50 <SyntaxNinja> dons: does anything extra have to happen during compiling to make a module hot-swapable?
21:54:58 <SyntaxNinja> or plugable or whateber?
21:54:59 <dons> nope.
21:55:22 <dons> just need to be able to rebuild a library or a suite of .o files dynamically
21:56:56 <SyntaxNinja> so cabal has an API as well as the setup script if you don't feel like using the shell, though you won't be able to necessarily build everything with the API
21:57:12 <SyntaxNinja> but for most packages, you could just call Distribution.Simple.defaultMain directly.
21:57:26 <dons> a few extra system calls to "build" would be enough on top, though?
21:57:44 <SyntaxNinja> yeah, you probably want to use "system" and the CLI.
21:57:55 <dons> oh.... to "eval Setup.hs build" ...
21:58:22 <dons> I wonder if that would work..
21:58:33 <dons> @type System.Eval.Haskell.eval
21:58:35 <lambdabot> System.Eval.Haskell.eval :: forall a.
21:58:35 <lambdabot>           (AltData.Typeable.Typeable a) =>
21:58:35 <lambdabot>           String -> [System.Eval.Utils.Import] -> IO (Maybe a)
21:59:05 <dons> anyway, I'll write some code and get back to you.
21:59:16 <ozone_> yeah, go mark my assignment!
21:59:20 <ozone_> oh, maybe it's been marked.  yay!
21:59:29 <ozone_> hmm, but i probably got a crap mark.  boo!
21:59:37 <dons> assign 1 is already done ;)
22:00:43 <SyntaxNinja> dons: sweeeeet
22:01:41 <dons> I really want this for Yi, so the user can type: :reboot to hotswap yi code without having to type 'make' on the command line.
22:01:47 <reffie> http://garnet.acns.fsu.edu/~dbs02c/images/DSC02128.JPG
22:08:10 <SyntaxNinja> reffie: I only have one, but it's very powerful
22:08:21 <reffie> i have two
22:08:24 <SyntaxNinja> reffie: do you have a fujifilm camera?
22:08:31 <reffie> that's not me, dude
22:08:38 <reffie> i'm not that crazy :)
22:10:01 <dons> that's too many keyboards
22:10:16 <ozone_> dons: yeah, and they're not even happy hacking ones!
22:10:25 <dons> no!
22:10:33 <reffie> what's so nice about the happy hacker keyboards?
22:10:46 <ozone_> they're expensive, and make you feel special
22:10:50 <reffie> they are way too expensive
22:10:52 <reffie> yeah
22:10:54 <ozone_> personally, i prefer The One True Keyboard
22:11:00 <reffie> which?
22:11:05 <dons> they're nicer. but they're not so expensive anymore are they?
22:11:20 <ozone_> http://www.google.com/search?hl=en&lr=&safe=off&c2coff=1&q=%22The+One+True+Keyboard%22&btnG=Search
22:11:24 <dons> I think the price has come down.
22:11:36 <SyntaxNinja> speaking of nerds:
22:11:38 <SyntaxNinja> http://www.extremetech.com/image_popup/0,1554,s=26781&iid=106562,00.asp
22:11:42 <reffie> ozone_ oh model m
22:11:53 <reffie> ozone_ i've never tried one, so i don't know what's the big dea
22:11:54 <reffie> l
22:11:55 <ozone_> SyntaxNinja: that's orksome
22:12:01 * SyntaxNinja has a kinesis keyboard. it rulz
22:12:03 <ozone_> does it fly?
22:12:04 <ozone_> in space?
22:12:07 <dons> oh, the HH ones are still expensive
22:12:11 <ozone_> SyntaxNinja: you're so trendy
22:12:17 <reffie> SyntaxNinja hahah
22:12:18 <ozone_> reffie: oh.  try one, then you'll see what the big deal is
22:12:30 <SyntaxNinja> ozone_: I can program it to type your name.  watch: ozone ozone ozone ozone
22:12:40 <dons> but this isn't http://www.elx.com.au/item/elsKB-MINIUP
22:13:00 <ozone_> SyntaxNinja: go you!
22:13:09 <dons> ooh. foldable keyboards
22:13:32 <ozone_> dons: dude, you can get space saver model m's
22:13:36 <ozone_> they are _the stuff_
22:13:43 <ozone_> absolutely awesome++
22:14:02 <ozone_> http://www.clickykeyboard.com/other_modelm.htm
22:14:11 <ozone_> actually, direct link: http://www.clickykeyboard.com/pics/modelm-015.jpg
22:14:42 <dons> seems kinda big..
22:15:52 <SyntaxNinja> here's the kinesis: it also makes good clicky: http://www.funet.fi/pub/sci/medical/typing-injury/gifs/kinesis.gif
22:16:31 <ozone_> SyntaxNinja: do you have a food pedal?
22:16:32 <SyntaxNinja> it also has the advantage that everyone at work thinks you're piloting that tai fighter I posted earlier, when really you're just programming.
22:16:33 <ozone_> foot pedal, too
22:16:39 <ozone_> though a food pedal would be even more awesome
22:16:54 <dons> oh, that looks fun
22:17:02 <ozone_> SyntaxNinja: some friends of mine used a kinesis at uni ... man they looked like they were flying the death star when they were typing
22:17:07 <SyntaxNinja> ozone_: no.  I could have had one for free, but I gave it to a friend of mine who was having more serious trouble w/ his arms, so I have gotten to try them.
22:17:40 <ozone_> oh, it seems i have overused my quota of star wars analogies for the day
22:17:40 <SyntaxNinja> ozone_: the foot switch is kinda cool. I got used to it pretty fast, not sure if it helped w/ anything though :)
22:17:46 <wagle> SyntaxNinja: i think dylan would go nutz over that tie-fighter desk
22:17:50 <ozone_> i think i should stop procrastinating and start blogging.  yes!  brilliant idea
22:18:04 <SyntaxNinja> wagle: do you know dylan personally, or just from here?
22:18:10 <wagle> personally
22:18:23 <dons> @remember ozone i think i should stop procrastinating and start blogging.
22:18:31 <dons> hehe
22:18:48 <wagle> isnt blogging a form of procrastination?
22:19:05 <SyntaxNinja> wagle: oh, hadn't realized that.  Yeah, I'l have to show him, if he hasn't already seen it.  I got it from slashdot :)
22:19:08 <dons> that's why I think it's memorable that he said that :D
22:19:20 <SyntaxNinja> dylan rulz
22:19:56 <ozone_> wagle: yes, unless you have about a dozen friends back home (some of which are cute) who are saying threatening things to you unless you start telling them what's happening on your travels
22:20:22 <wagle> cute eh?
22:20:34 <ozone_> yes, like don.  he's a cutie!  *tickles don*
22:20:53 * wagle grabs ozone_'s blogging page, and starts writing
22:21:03 <SyntaxNinja> wagle: is that photo on your home page in portland?
22:21:19 <wagle> which home page?
22:21:25 * dons blushes
22:21:41 * dons adds bonus marks to andre's assignment
22:21:47 <SyntaxNinja> the one at ogi, exit 256, perry ->
22:22:13 <wagle> the sign is in ne oregon on 84
22:25:30 * SyntaxNinja goes away to watch a movie
23:49:06 <dons> hey basti_
23:49:19 <dons> going to send me the Yi emacs code soon?? ;)
23:59:53 <basti_> oh
23:59:55 <basti_> hi dons
