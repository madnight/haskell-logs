00:58:35 <Itkovian> Shouldn't the processor core poll be reopened, or if not, removed from the sequence.complete.org? I mean, there was one vote, and it seems a bit dumb to let such a poll remain on the site.
01:10:46 <lispy> does concatMap have to build all the elements before it can do the concat?
01:14:37 <Itkovian> err ...
01:14:57 <Itkovian> I'd think not ... it can concat the pointers to the elements, no?
01:15:14 <lispy> hmm..then i probably had some other bug in my algo
01:15:55 <lispy> i was trying to implement knights tour with back tracking, and take advantage of lazy evaluation to have my algo find all solutions
01:16:10 <lispy> but i did things like take 1 (solve board) and it would grind for ever
01:16:35 <lispy> i changed it a bit to avoid concatMap and now it's fine
01:16:39 <lispy> so i just wondered...
01:19:37 <Itkovian> hmm ... the take one should make sure the solve computes only the first solution in full afaik
01:20:19 <lispy> yeah, the version i have now does that, so i guess the old version had some other bug
01:20:26 <lispy> prehaps my recursion was off
01:21:53 <Itkovian> perhaps perhaps  ... perhaps
01:23:38 <kaol> @plugs take 5 concatMap (\x -> [x]) (repeat 1)
01:23:40 <lambdabot> Couldn't match `[a]' against `t -> t1'
01:24:22 <kaol> @plugs take 5 (concatMap (\x -> [x]) (repeat 1))
01:24:24 <lambdabot> [1,1,1,1,1]
01:24:38 <lispy> @type repeat
01:24:39 <lambdabot> repeat :: forall a. a -> [a]
01:24:53 <lispy> @plugs repeat 1
01:24:55 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
01:24:55 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
01:24:55 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
01:24:55 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
01:24:55 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
01:24:55 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
01:24:57 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
01:24:59 <lambdabot> [24 @more lines]
01:24:59 <lispy> ah
01:25:13 <lispy> replicate is what i was thinking of
01:25:23 <lispy> looking at that example wondering about it...
01:25:34 <lispy> kaol: thanks, that means it was a bug
01:25:37 <lispy> kaol: in my code ;)
01:54:21 * boegel waves
01:55:07 * Itkovian waves back
01:55:35 * lispy seizers
01:57:12 * boegel sighs
01:57:32 * lispy dusts himself off
01:57:41 <lispy> how goes?
01:57:44 * boegel helps lispy dusting
01:57:57 <boegel> my RTS book is boring :(
01:58:19 <lispy> you have a run times system book?
01:58:26 <dons> ?
01:59:03 <boegel> real-time systems
01:59:21 <dons> ohh. not as much fun as runtime systems
01:59:26 <boegel> I have an exam on it Monday, but it's not my thing
01:59:39 <Itkovian> heh ... better make it your thing by Monday then
01:59:53 <boegel> Itkovian: :) I mean it's boring, not that it's hard
01:59:56 <lispy> or your thing till monday
02:00:09 <boegel> and the book explains it too good sometimes, makes it boring to read
02:00:21 <lispy> and easy to forget
02:01:02 <boegel> lispy: we'll see about that :) hopefully it'll stick until Monday
02:02:04 <lispy> my exhaustive search is slow
02:02:07 <lispy> very, very slow
02:02:44 <boegel> that's why it's called exhaustive :)
02:03:13 <lispy> yeah and i don't think this board has a tour
02:03:20 <lispy> so it's trying and trying and trying
02:03:24 <lispy> but it will never find it
02:03:42 <Muad_Dibber> so get some coffee :)
02:03:51 <lispy> good idea
02:04:08 <lispy> i can't have caffine but i can still take a break
02:04:20 <Muad_Dibber> tea then
02:04:23 <Muad_Dibber> or just aqua :P
02:05:00 <dons> I wish my BEVERAGES had a TYPE SYSTEM!
02:05:08 <lispy> @yow
02:05:10 <lambdabot> I want to perform cranial activities with Tuesday Weld!!
02:06:29 <Itkovian> it's all juice to me
02:07:25 * boegel goes for a beer
02:07:29 <Itkovian> eew
02:07:39 * dons hunts for some green tea
02:07:43 <boegel> or maybe I shouldn't, having to study and all :(
02:08:06 * boegel goes for an orange juice
02:08:36 * lispy pours vodka in boegel's orange juice
02:09:07 <Itkovian> hehe
02:09:16 <Itkovian> now there's a tasty juice
02:09:37 * boegel hits lispy in the head with his fat RTS book
02:09:47 * Itkovian recommends ducking
02:09:55 <boegel> ok, I should get back to studying
02:09:57 * lispy hits the ground face first
02:10:08 <boegel> I managed to stay away from here for 2,5 hours, yaay !
02:10:09 <boegel> *sigh
02:10:22 <lispy> heh, yeah, i know how that is
02:10:22 <Itkovian> this analsyis is going nowhere
02:11:24 <Itkovian> so do I
02:12:10 <lispy> what type of analysis is it?
02:12:35 <Itkovian> regression
02:13:21 <lispy> statistics?
02:13:25 <lispy> ewwww ;)
02:14:23 <earthy> beer at 11 am?
02:14:42 <Matt-W> why not?
02:15:08 <earthy> because I've not had breakfast yet, and beer before breakfast doesn't quite agree with my stomach
02:15:18 <Matt-W> hmm, good poing
02:15:29 <Itkovian> earthy: yr talking to belgians here ...
02:15:35 <earthy> yes...
02:15:36 <earthy> I know
02:15:38 <Itkovian> beer == breakfast
02:15:41 <Itkovian> :-)
02:15:49 <earthy> depends on the beer, then
02:15:52 <Itkovian> it is nutricious, has fluid ...
02:15:58 <Muad_Dibber> well, i have to agree with earthy on this matter
02:16:00 <Matt-W> and bubbles
02:16:02 <Itkovian> everything the body needs
02:16:02 <earthy> I wouldn't consider Stella Artois a good breakfast
02:16:09 <Matt-W> I don't get on well with bubbles in the early morning
02:16:11 <Itkovian> yeah, but that's bad beer
02:16:13 <earthy> Westvleteren Abt otoh
02:16:15 <Muad_Dibber> i wouldn't consider stella a good beer either :P
02:16:35 <Matt-W> it makes good batter for deep-fried brocolli
02:16:41 <Matt-W> or for fish, if you happen to like fish
02:16:44 <Matt-W> wouldn't drink it though :-)
02:16:57 <earthy> hm. beerbased batters foor deepfying foods
02:16:59 <earthy> that's a good one. :)
02:17:07 <Itkovian> what's a batter?
02:17:13 <Itkovian> @google batter
02:17:15 <lambdabot> http://www.battersbox.ca/
02:17:22 <Itkovian> should I click that?
02:17:23 <earthy> itkovian: liquid + meal, mostly
02:17:27 <Itkovian> ah
02:17:28 <earthy> what you make pancakes of
02:17:32 <Itkovian> ok
02:17:35 <earthy> e.g.
02:17:38 <Matt-W> doesn't necessarily have egg in it though
02:17:58 <Matt-W> flour + beer, make it quite thick, dip fish in it and deep-fry
02:18:22 <earthy> http://www.waitrose.com/food_drink/recipes/glossary/cookingglossary/Batter.asp
02:18:52 <earthy> s/flour/cornmeal
02:18:55 <lispy> is there a Haskell -> C translator?
02:18:58 <earthy> works as well
02:19:00 <earthy> lispy: ghc
02:19:01 <earthy> :)
02:19:19 <Matt-W> I wouldn't expect to be able to read the resulting code, but it does work...
02:19:21 <lispy> can you convince ghc to give you the .c files?
02:19:29 <earthy> yes, you can
02:19:40 <lispy> oh, how i skimed the manual and didn't see it
02:19:42 <Muad_Dibber> depending on how convincing you are normally :P
02:19:56 <xs__> ghc -C
02:20:09 <lispy> heh, that's too easy
02:20:17 <Matt-W> hey, don't complain
02:20:27 <earthy> -fvia-C -keep-hc-files
02:24:25 <lispy> well, finally my program decided that there was no tour
02:24:28 <lispy> (about damn time too)
02:29:14 <Itkovian> for what size board?
02:29:50 <lispy> the board is small actually
02:29:57 <lispy> it was a 5x5
02:30:02 <lispy> but it was missing pieces
02:30:43 <lispy> on wait it was 6x6
02:30:51 <lispy> missing 4 squares in the center
02:31:20 <Itkovian> ah, ok
02:31:35 <lispy> my program doesn't realize when it is trying a tour which is isomorphic to another tour
02:31:41 <lispy> so it's much slower than it should be
02:31:43 <Itkovian> yeah, I think you can't do a tour on such a board
02:32:31 <Itkovian> iirc, for the last move on the outer suqares, you need at least one square at position two from the side
02:32:43 <Itkovian> I may be missing here though
02:33:09 <lispy> you've studied knights tour on boards with holes?
02:34:30 <Muad_Dibber> no
02:37:22 <Itkovian> nope, but the usual easy way to solve a full baord by hand is by starting at the edge
02:37:32 <lispy> ah
02:37:46 <lispy> i was hoping there was a text or something i could get a reference for ;)
02:39:32 <lispy> these chessboards with the middle missing seem to be very hard for the algorithm
02:39:54 <lispy> you have to make a lot of moves before you find a dead end
02:40:52 <lispy> and i quickly run out of scratch paper ;)
02:41:03 <Itkovian> heh
02:41:56 <lispy> the weird thing is that i hit a dead end on this example, but the squares i have not visited form a knights tour
02:48:21 * boegel yaays as he has studied almost a 100 pages this morning
02:48:42 <Itkovian> yeah right ... you skimmed them ...
02:48:43 <Itkovian> :-)
02:49:59 <boegel> Itkovian: I didn't ! I read them !
02:50:19 <boegel> I've been up since 8.30, and have been reading all the time (when I wasn't in here, and that wasn't long)
02:50:29 <Itkovian> lol
02:50:29 <boegel> I still have over 150 pages to read though :s
02:50:36 <Itkovian> I believe you
02:50:42 <Itkovian> who's giving the course?
02:50:45 <boegel> you should !
02:50:50 <boegel> prof. Boullaert
02:51:01 <Itkovian> aha, I got a nice little anecdote about him ...
02:51:03 <boegel> (maybe without the e, dunno)
02:51:08 <boegel> tell me ! :)
02:52:07 <Itkovian> well, a few years ago, thesisses were being given ... one of the people who submitted a proposal was Bjorn (De Sutter) ... and he just disliked Boullart.
02:52:21 <boegel> he's not the only one :p
02:52:29 <Itkovian> So, one day a student comes along, and asks Bjorn what extra courses he should take for the thesis ...
02:52:58 <Itkovian> the reply was: 'Doesn't matter, just none of Boullart's because they're crap and you won't learn anything'
02:53:21 <Itkovian> The student decided against doing the thesis with Bjorn ... maybe because his name was Tim Boullart :-)
02:54:24 <boegel> mwoeha :) did he get a visit from prof. Boullart ?
02:55:25 <Itkovian> nah, but he did have to ask Boullart to be a part of his PhD jury
02:55:29 <Itkovian> twas either that or Rita ...
02:55:40 <Itkovian> which he disliked even more
02:55:58 <Itkovian> we all had a good laugh
02:56:09 <Itkovian> Boullart _was_ annoying at the defense though
02:56:26 <boegel> Rita is just great :) I heard she wrote a letter to go on pension, but then she went back to the rector to reclaim her letter :)
02:56:41 <boegel> Itkovian: ow :s pain in the ass he is
02:57:01 <Itkovian> yeah.
02:57:09 <Itkovian> had only one course, didn't learn a single thing
02:57:42 <boegel> we'll
02:57:45 <boegel> I'm off for lunch
02:57:48 <Itkovian> yeah, she suddenly changed her mind ... we all had a good laugh then too
02:57:51 <boegel> and then more reading :)
02:58:01 <Itkovian> for more gossip, come work with us :-)
02:58:07 <boegel> so it's true :) heh, didn't know it was actually true
02:58:12 <boegel> I will ! :)
02:59:12 <lispy> bleh, i found a tour faster than my program did
02:59:29 <lispy> which isn't very encouraging ;)
02:59:30 <boegel> lispy: lol :)
02:59:38 <Itkovian> but did you find them all ?
03:00:05 <lispy> nope, just one ;)
03:00:34 <lispy> but i only requested one solution from my solver
03:02:54 <lispy> my program must be trying every possible wrong starting place
03:03:32 <Itkovian> or there's still a bug ...
03:05:06 <lispy> in a sense yes
03:05:25 <lispy> i changed it so that it uses (1,1) the top leftmost square as the starting place
03:05:29 <lispy> now it found the solution faster than i can
03:09:43 <lispy> i wonder if using an array is a huge slow down
03:09:58 <lispy> my program is ponentially making a huge number of small updates to the array
03:11:33 <Itkovian> imo it's better to use a jump :: Position -> Position function an use a set or something, so you can easily check for items already visited.
03:11:35 <dons> win 9
03:11:38 <dons> sleepy
03:12:57 <lispy> a jump function...how would that work?
03:13:00 <lispy> or
03:13:02 <lispy> er oh
03:13:07 <lispy> hmm...
03:15:16 <boegel> lol :)
03:20:54 <Itkovian> well ... possible outcomes are [(x-2, y-1), (x-2, y+1), ...]
03:21:19 <lispy> yeah
03:21:23 <lispy> i get it now ;)
03:21:23 <Itkovian> you have eight possibilities ... check which one lie on the field, and soe them in a fast lookup datastructure
03:21:39 <Itkovian> you want to be able to check for doubles in O(1)
03:21:47 <Itkovian> well, O(log n ) perhaps :-)
03:22:02 <lispy> yeah, arrays are perfect for that if you have destructive modification
03:22:12 <Itkovian> I think it would make a nice student project for next year ...
03:22:18 <lispy> but, using a binary tree would probably be better here
03:22:22 <Itkovian> small, but nice
03:23:14 <lispy> i'm looking at boards which are missing an N x N region in the middle, and have a 2x2 strip all the way around it
03:23:37 <lispy> for n = 1, 5, 9, 13, and 17 i can find a tour
03:23:45 <lispy> and i can find it easily
03:24:03 <lispy> so i bet i can prove that there is a heuristic for this when n == 1 mod 4
03:24:48 <lispy> perhaps that would be more clear as 1 == (n mod 4)
03:27:53 <lispy> i should be asleep...
03:29:31 <autrijus> metaperl: I've just read your journal... just want to say that I agree that perl6 is a big confused mess -- although I hope to turn it into a big enlightened mess soon :)
03:29:48 <lispy> n=21 works as well
03:32:23 * lispy leaves his algo to find a counter example while he sleeps
03:43:47 <kowey> hi room... just out of curiosity: what was the motivation behind replacing Data.FiniteMap with Data.Map?
03:43:57 <autrijus> efficiency
03:43:58 <kowey> is it just for a more sensible API?
03:44:05 <kowey> oh... Data.Map is better implemented?
03:44:07 <autrijus> and qualified API
03:44:13 <autrijus> yeah. it's 2x faster in my application
03:44:18 <autrijus> (if not more)
03:44:22 <kowey> because it refrences the same paper... i figured it was the same
03:44:43 <kowey> ok... curiosity sated... thanks!
03:44:47 <autrijus> np :)
03:45:04 <autrijus> (but the 2x may be also due to GHC 6.4)
03:45:20 <autrijus> (but there's some other reports about Data.Map being faster too)
04:00:29 * Itkovian is bored
04:02:28 <autrijus> Itkovian: start another haskell golf?
04:04:15 <vincenz> @seen shrimpx
04:04:15 <lambdabot> shrimpx is in #haskell. I don't know when shrimpx last spoke.
04:04:18 <vincenz> @seen shapr
04:04:19 <lambdabot> I saw shapr leaving #haskell 2 days, 11 hours, 29 minutes and 2
04:04:19 <lambdabot> seconds ago.
04:04:21 <vincenz> oy
04:05:19 <Itkovian> he's got a flat tire I guess
04:05:26 <Itkovian> and since it's a unicycle ...
04:06:33 <nibro> @seen Lemmih
04:06:34 <lambdabot> Lemmih is in #haskell. Last spoke 14 hours, 32 minutes and 41
04:06:34 <lambdabot> seconds ago.
04:06:40 <Lemmih> @seen nibro
04:06:41 <lambdabot> nibro is in #haskell. Last spoke 6 seconds ago.
04:06:46 <Lemmih> (:
04:06:55 <nibro> hehe
04:07:22 <nibro> so, wanna show me your apache stuff? :)
04:08:08 <JaffaCake> autrijus: Data.Map performed about the same as Data.FiniteMap in the measurements I'm aware of - they were posted on the Haskell libraries list: http://www.haskell.org/pipermail/libraries/2004-May/002177.html
04:08:11 <boegel> Itkovian: bored ? shouldn't you be working ?
04:08:32 <Itkovian> i am ...
04:08:39 <Itkovian> that's the problem...
04:08:40 <boegel> and you're still bored ? :)
04:08:45 <JaffaCake> You might want to look into Adrian Hey's AVL trees, though
04:08:55 <Itkovian> takes long for an analysis to complete
04:09:05 <boegel> Itkovian: you can help me :p
04:09:58 <autrijus> JaffaCake: oh. I thought Data.Map is stricter and therefore faster
04:10:07 <autrijus> I might be imaginnig things, then.
04:10:19 <JaffaCake> I don't think it's any stricter
04:10:38 <autrijus>  Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
04:10:52 <autrijus> that looks like strictness annotations to me
04:11:08 * JaffaCake goes to check
04:13:17 <JaffaCake> autrijus: I think although the old FiniteMap lacked the strictness annotations, in practice most tree construction was strict because of the balancing.
04:13:30 <autrijus> JaffaCake: that may very well be true.
04:13:45 <autrijus> JaffaCake: I did remember pugs running much faster after changing from FiniteMap to Map though.
04:13:59 <autrijus> I should've benchmarked it better.
04:14:03 <JaffaCake> interesting... maybe I'll re-run those benchmarks
04:19:55 <p1870> if lhs2tex gives me '\end{code} not found
04:20:02 <p1870> what is usually going on?
04:20:05 <p1870> i cant find the problem
04:21:13 <boegel> p1870: you're missing and \end{code} tag corresponding with a \begin{code} tag ?
04:22:38 <p1870> obviously i checked that
04:26:20 <Itkovian> boegel: with what?
04:37:48 <Lemmih> @seen SyntaxNinja
04:37:49 <lambdabot> I saw SyntaxNinja leaving #haskell 12 hours, 19 minutes and 5
04:37:49 <lambdabot> seconds ago.
04:43:28 <sylvan> boegel: http://www.openscenegraph.org/index.php?page=News.News
04:45:27 <boegel> Itkovian: err, I'm not sure :)
04:45:44 <boegel> sylvan: what's this ?
04:46:34 <sylvan> open scenegraph.. for H3D maybe..
04:46:44 <sylvan> at least as an inspiration
04:47:37 <boegel> it's in C++, so that makes it hard to use directly with Haskell
04:47:47 <boegel> but I'll add it to the H3D wiki, thanks :)
04:50:55 <boegel> some of the screens are quite impressive
04:54:44 <Itkovian> hard to believe they render 30 fps real time with a GeForce2 imo
04:57:48 <boegel> Itkovian: you'ed be amazed :)
04:58:32 <Itkovian> prolly
04:59:46 <boegel> Itkovian: with H3D, I'm aiming for 40fps on a Geforce 1 ! :p
05:00:14 * boegel stops dreaming and returns to his RTS book
05:04:58 <shelarcy> boegel: simmonmarow's library (wish) list mentioned another and historical 3D  framework OpenInventor http://www.haskell.org/~simonmar/lib-hierarchy.html
05:06:10 <shelarcy> It's in C++. and you can find Java version
05:07:05 <shelarcy> http://oss.sgi.com/projects/inventor/
05:08:26 <Muad_Dibber> boegel? can you post me your url again please?
05:08:44 <_JusSx_> shawn:
05:09:01 <_JusSx_> ll
05:17:38 <goron> Can anyone toss me the name of a function that converts an Integer into an Int? I want it to overflow when the Integer is bigger then the Int.
05:18:44 <wli> fromIntegral and type signatures should do
05:22:13 <ndm> fromInteger is a bit more closely constrained, not sure if its any better...
05:22:46 <wli> Doesn't make a difference, it's all specialized by type inference.
05:23:07 <ndm> so why do both versions exist?
05:28:57 <Rearden> hello
05:30:02 <Muad_Dibber> hi
05:30:51 <Rearden> big channel, I thought there would be like three people in here
05:31:20 <xerox> It's getting bigger and bigger!
05:32:04 <Muad_Dibber> Rearden: guess how many bots there are ;)
05:33:51 <Rearden> Probably a lot... Either way it still looks good. :)
05:37:13 <boegel> Muad_Dibber: which url ? H3D ? or HRay ?
05:38:25 <boegel> Rearden: welcome to the growing Haskell community
05:38:30 <boegel> hey aap ! :)
05:38:36 <boegel> want a banana ?
05:38:40 <aap>  <Muad_Dibber> is there also a Hat version for windows?
05:38:49 <aap> yeplease
05:38:57 <Muad_Dibber> (c:=
05:40:08 <boegel> lolz :)
05:40:18 <boegel> Muad_Dibber: which url did you want ?
05:40:23 <Muad_Dibber> boegel: HRay
05:40:39 <boegel> http://studwww.ugent.be/~kehoste/thesisPublic/website
05:40:48 <boegel> but you can find it on the wiki too you know
05:40:50 <boegel> @wiki HRay
05:40:51 <lambdabot> http://www.haskell.org/hawiki/HRay
05:40:55 <Muad_Dibber> oh
05:40:56 <Muad_Dibber> didnt know that
05:41:05 <Muad_Dibber> you didnt tell me either ;)
05:41:26 <ndm> aap: yes, Hat for Windows, but requires Cygwin
05:41:46 <Muad_Dibber> bleh @ windows, but even more bleh @ cygwin
05:41:52 <ndm> http://haskell.org/hat/requirements.html
05:41:52 <Muad_Dibber> it'll wait till i reboot into nix :P
05:42:13 <boegel> Muad_Dibber: I mentioned it in here a few times before
05:42:54 <Muad_Dibber> boegel: well, i 've not noticed before
05:42:56 <boegel> only 100 more pages on RTS to go, yaay
05:43:09 <Muad_Dibber> and i dont keep logs :P
05:43:39 <boegel> I've read over 150 pages today, I wonder how much will stick :s
05:44:31 <Muad_Dibber> hehe
05:45:12 <boegel> fortunalty, there are also slide shows, which show the most important stuff
05:45:17 <boegel> I'll keep those for the weekend
05:48:59 <Muad_Dibber> have a nice weekend then ;)
05:52:52 <goron> How big is the domain of chr?
05:53:34 <nmoore> hi, does anyone know of an inbuilt function for printing arrays out in grid form, and if possible reading them likewise?
05:54:43 <ndm> goron:  ord (maxBound :: Char) is the max
05:55:40 <ndm> goron: 255 on my copy of Hugs, but may be different if your Haskell supports unicode
06:00:09 <goron> ndm: I was generating random password, but I don't think passwords in Unicode work that well ;) So.. now I do it differently. I have 1114111 as maxBound.
06:01:35 <Itkovian> nmoore; override shows ?
06:02:53 <nmoore> Itkovian: you mean i should override show? i was hoping that i could avoid this
06:12:15 <TheHunter> Itkovian, Show shouldn't be used for 2-dimensional output.
06:12:30 <TheHunter> nmoore, there's nothing like that in the libs, but it should be fairly easy to write.
06:12:50 <Itkovian> TheHunter: ok, sorry
06:12:57 <Itkovian> I'll remember that
06:13:29 <Lycan359> Hmmm... how are rationals represented in haskell?
06:14:38 <TheHunter> as pairs of nominator and denominator?
06:16:07 <Lycan359> 1%2 That's a rather odd syntax isn't it?
06:17:27 <TheHunter> why?
06:17:34 <TheHunter> @type (Data.Ratio.%)
06:17:39 <lambdabot> (Data.Ratio.%) :: forall a.
06:17:39 <lambdabot>       (Integral a) =>
06:17:39 <lambdabot>       a -> a -> GHC.Real.Ratio a
06:18:20 <Lycan359> I just started learning haskell 2 days ago :P
06:18:46 <TheHunter> % is an operator, like *, ++, $, or .
06:18:54 <TheHunter> it's no special syntax.
06:19:45 <Lycan359> I see
06:26:43 <Itkovian> welcome Lycan359
06:29:49 <Lycan359> Thanks.
06:32:28 <Lycan359> WHat does $= mean?
06:33:21 <Lemmih> @index (@=)
06:33:22 <lambdabot> bzzt
06:33:52 <Cale> $= appears to be the statevar setter for the OpenGL library
06:34:09 <Lycan359> Yeah, that's what i'm looking at now.
06:34:34 <Lycan359> Didn't know it was ogl specific though
06:34:54 <Cale> Well, outside of that, it's just a name
06:35:28 <Cale> If you don't import the OpenGL library, you're free to use $= for one of your (infix) functions.
06:35:52 <Lemmih> Lycan359: GHCi can tell you lots about identifiers.
06:41:53 <nmoore> does anyone think that the libs are quite patchy when it comes to Array? i can't seem to do simple things like determining it something is in a column without converting to a list first
06:47:28 <Cale> By "converting to a list first" do you mean something like  any (== x) [a ! (row,i) | i <- [0 .. 10]
06:47:42 <Cale> er, ]
06:48:42 <Cale> That's not really different from a loop.
06:51:24 <TheHunter> $ zgrep RULES Arr.lhs.gz
06:51:24 <TheHunter> {-# RULES "cmpArray/Int" cmpArray = cmpIntArray #-}
06:51:31 <TheHunter> ouch!
06:58:12 <Itkovian> ttyl
06:59:57 <boegel> @seen pipe
06:59:58 <lambdabot> I saw pipe leaving #haskell 14 hours, 11 minutes and 45 seconds ago.
07:00:24 <nmoore> Cale: yes, that's what i mean
07:01:32 <Cale> nmoore: I wouldn't worry too much about doing that, unless you find it inconvenient.
07:01:56 <Cale> You might write some higher order functions which wrap that sort of thing.
07:02:34 <nmoore> Cale: it doesn't worry me too much
07:04:20 <Cale> Lists in a lazy language can be treated like the loops of an imperative language.
07:05:51 <nmoore> i see, the libraries just seem so weak when you're using arrays as opposed to lists
07:07:50 <TheHunter> that's probably due to the fact that updating arrays is very expensive (involves copying the array) and they therefore aren't used that often.
07:08:34 <Cale> Arrays are mostly used when you have some static piece of data you're going to create and then index over and over again
07:09:02 <Cale> there are mutable arrays in the GHC Libraries though
07:10:03 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Array.MArray.html
07:15:45 * boegel sighs once again
07:17:12 <Lycan359> What's wrong?
07:24:47 <Lycan359> Nothing I guess
07:24:58 <nmoore> Cale: that definitely suits my purpose, and i suppose that it's not too large a price to pay
07:25:52 <nmoore> Cale: the part about static data
07:37:13 <kowey> where can i find the doc for forkIO?
07:37:34 * kowey is trying to use the new System.Process stuff
07:39:45 <TheHunter> @index forkIO
07:39:46 <lambdabot> Control.Concurrent
07:39:50 <TheHunter> @docs Control.Concurrent
07:39:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Concurrent.html
07:40:03 <kowey> thanks!
07:40:23 <xerox> @help libsrc
07:40:24 <lambdabot> library source
07:40:31 <xerox> @libsrc Control.Concurrent
07:40:32 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Control/Concurrent.hs
07:43:24 <TheHunter> hehe, "suckIO" is written in m >>= \x -> n >>= \y -> ... style.
07:43:34 <boegel> Lycan359: I'm tired a reading my RTS book , but I have to continue
07:43:35 <kowey> i was just about to ask too
07:43:36 <kowey> why?
07:44:00 <boegel> because I have exam on Monday
07:44:26 <TheHunter> what's RTS ?
07:44:27 <kowey> heh... i was asking rather why not use the "do" sugar?
07:44:34 <xerox> TheHunter, why do not use do-notation?
07:44:34 <boegel> Real-time systems
07:44:43 <boegel> kowey: oh sorry :)
07:45:24 <kowey> :-)
07:45:25 <TheHunter> i don't know, let's see if we can find out when it was written...
07:47:25 <TheHunter> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Control/Concurrent.hs?rev=1.1;content-type=text%2Fplain
07:48:56 <boegel> there's a hell of strom coming up here, and I'm right in the middle of it
07:49:02 <boegel> s/strom/storm
07:53:01 <kowey> hmm... if i may betray my ignorance for a sec
07:53:13 <kowey> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:53:34 <kowey> all i want to do is call a process, write some stuff to its stdin, and then read the stuff back from its stdout
07:54:02 <kowey> code in paste page gives me waitForProcess: interrupted (Interrupted system call)
07:54:22 <kowey> pretty sure i'm doing something obviously silly... but what?
07:54:42 <xerox> @pl foldl (\(x',y') n -> (max n x', max x' y')) (0,0)
07:54:43 <lambdabot> foldl (uncurry (liftM2 (.) (flip . ((,) .) . max) max)) (0, 0)
07:55:09 <Lemmih> 'hGetContents' is lazy but that's probably not it.
07:56:08 <kowey> in place of the System.Process stuff, i used my own horrible forking stuff
07:56:09 <kowey> http://www.loria.fr/~kow/darcs/Geni/src/geni/SysGeni.lhs
07:56:12 <kowey> which worked
07:56:43 <kowey> i used to use... hoping to use the new stuff because it's more correctly implemented (assuming)
08:06:40 <nothingmuch> is putting a Map in an IORef considered good behavior to get a mutable map?
08:08:18 <Lunar^> nothingmuch: use MVar if you need thread safety
08:09:25 <nothingmuch> MVar? as in instead of IORef?
08:11:09 <Lunar^> yep
08:11:16 <Lunar^> or TVar, if you prefer STM
08:11:59 <nothingmuch> so say i need to store add a key to the map, i add it, and put the resulting map in the IORef or equiv that the map was in?
08:12:36 <nothingmuch> being an imperative head that sounds like it might make the garbage collector very mad at me, that's why I'm asking
08:12:58 <nothingmuch> oops, gotta go
08:29:40 <xerox> Did anyone submitted Haskell projects for Google's SoC?  Which mentor organization could be specified if one wants to do that... ?
08:30:50 <reffie> xerox i don't think you'd have much of a chance
08:30:59 <xerox> :(
08:31:03 <reffie> except maybe if you work on pugs?
08:31:08 <reffie> for perl
08:31:11 <xerox> That's an idea...
08:32:34 <MarcWeber> Is there a numeric library for haskell?
08:32:56 <boegel> yo monochrom
08:39:06 <boegel> @google numeric Haskell
08:39:07 <lambdabot> http://www.haskell.org/onlinereport/numeric.html
08:39:10 <boegel> MarcWeber: ^
08:39:24 <MarcWeber> \url
08:39:33 <MarcWeber> Thanks boegel!
08:41:29 <boegel> MarcWeber: np :)
08:41:42 <boegel> glad I can help someone for a change
08:45:32 <MarcWeber> boegel: Learning some new language is just one task, the second one is learning it's library.. ;(
08:46:00 <boegel> yeah, I know, I'm quite new too Haskell too
08:46:11 <boegel> I've only been working with it for a year orso
08:46:19 <boegel> and not full-time :)
08:46:31 <MarcWeber> Which language have you used before?
08:46:39 <boegel> several, mostly Java
08:46:54 <boegel> but I did work with C, C++, Prolog, Pascal, ...
08:47:01 <boegel> only for small stuff though
08:47:28 <boegel> never wrote anything big, besides some stuff Java and a ray tracer in Haskell
08:49:21 <kowey> @libsrc System.Process
08:49:23 <lambdabot> http://darcs.complete.org/fptools/libraries/base/System/Process.hs
08:59:29 <boegel> aap: wtf ? :)
09:00:45 <aap> stupid windows machine
09:01:06 <aap> if only i finish with this movie editing i will nicely reboot into gentoo :P
09:11:26 <boegel> yo Si\
09:12:24 <Si\> hi
09:33:57 <MarcWeber> Just a stupid question.. Can you run your haskell application on Win/linux/Mac without much modification?
09:34:15 <Lemmih> Yeah
09:36:55 <neologism> Probable fix: add an instance declaration for (Integral Char
09:36:59 <neologism> what exactly this mean?
09:43:39 <Lemmih> Did you try something like "'c' + 10"?
09:44:08 <neologism> no
09:44:14 <neologism> or maybe yes.. but I dont see it
09:44:45 <Lemmih> You're trying to use a Char as an Integral somehow.
09:44:50 <Lemmih> @paste
09:44:51 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
09:45:29 <neologism> I have [Integer] and I want to print it
09:46:35 <Lemmih> The function 'print' will do fine for that.
09:47:31 <neologism> but how should I do if I wanted to use putStr?
09:47:36 <neologism> (I am truing to learn so...)
09:48:26 <Lemmih> Try 'putStr (show yourListHere)'.
09:48:36 <Lemmih> Beware of line buffering, though.
09:48:37 <neologism> hm..
09:48:46 <neologism> /usr/local/lib/ghc-6.4/libHSrts.a(Main.o)(.text+0xe): In function `main':
09:48:46 <neologism> : undefined reference to `__stginit_ZCMain'
09:48:49 <neologism> have you seen this?
09:49:20 <Lemmih> neologism: You must have a funtion called 'main' in your Main module.
09:49:21 <xs> are you using --make?
09:49:39 <neologism> Lemmih: like this?
09:49:40 <neologism> main :: IO ()
09:49:40 <neologism> main = do
09:49:40 <neologism>    c <- getInt
09:49:42 <neologism>    print (take c evenNums)
09:49:50 <Lemmih> Yeah.
09:50:06 <neologism> I have this and it gives me that error
09:50:18 <Lemmih> What did you name the module?
09:50:33 <Lemmih> (using --make might also be a good idea)
09:50:34 <neologism> thats it!
09:50:40 <neologism> thnx for answer
09:51:16 <Lemmih> No problem (:
09:51:37 <neologism> I havent touched haskell for ages ;)
09:51:52 <neologism> btw: I am using the getInt
09:51:53 <neologism> which is
09:51:57 <neologism> getInt :: IO Int
09:51:58 <neologism> getInt = readLn
09:52:06 <neologism> is there any way how can I use the readLn direcly?
09:52:21 <neologism> ie. c <- readLn like
09:52:36 <xs> c <- readLn :: IO Int?
09:53:01 <neologism> thnx
09:53:05 <tromp> @index readLn
09:53:06 <lambdabot> System.IO, Prelude
09:53:14 <tromp> @type readLn
09:53:16 <neologism> any good haskell syntax reference on web?
09:53:20 <lambdabot> readLn :: forall a. (Read a) => IO a
09:54:08 <Lemmih> @google haskell report
09:54:09 <lambdabot> http://www.haskell.org/onlinereport/
09:54:26 <neologism> thnx :)
09:54:49 <Lemmih> @google haskell gentle introduction
09:54:50 <lambdabot> http://www.haskell.org/tutorial/
09:55:19 <neologism> the report seems ok
09:55:33 <neologism> ah.. its the same ;)
10:00:10 <SyntaxNinja> neologism: you made that word up.
10:00:19 <neologism> uhm?
10:00:22 <SyntaxNinja> hi Lemmih. sorry I haven't applied your patches yet.
10:00:25 <SyntaxNinja> neologism: your nick.
10:00:35 <neologism> I am afraid I dont understand
10:00:44 <neologism> what neologism did I say?
10:00:59 <SyntaxNinja> Lemmih: I'm worried; my laptop is being flaky on the screen, which happens every few months for some sad reason, and I have to ship it in to get it fixed :(
10:01:11 <_metaperl> SyntaxNinja: what brand?
10:01:15 <SyntaxNinja> neologism: the word that is your nick, I mean.  it's not a real word ;)
10:01:17 <SyntaxNinja> _metaperl:
10:01:18 * _metaperl is unhappy with his Toshiba
10:01:18 <SyntaxNinja> er
10:01:26 <Lemmih> SyntaxNinja: That sucks /-:
10:01:36 <SyntaxNinja> _metaperl: it's a gateway. other than this, I'm happy with it, and I got the 3 year warrenty so they always fix it for free
10:01:37 <neologism> SyntaxNinja: neologism = a new word in language
10:01:45 <_metaperl> oh sweet
10:01:53 <_metaperl> but the time down is the issue
10:02:02 <SyntaxNinja> _metaperl: but its inconvinient, and the warrenty should probably be almost up, so I'll have to see if they'll give me a new machine or something. hehee
10:02:13 <SyntaxNinja> neologism: I know. I was making some obscure recursive joke.
10:02:26 <neologism> which I didnt get ;)
10:02:47 <_metaperl> oh a GEB thing
10:02:50 <_metaperl> :)
10:03:06 <SyntaxNinja> I know that neologism is a real word, but it sounds like a fake word, which I've always thought was funny.
10:03:12 <_metaperl> made_up = "you made up that word"
10:03:19 <_metaperl> neologism = "a word that is made up"
10:03:43 <_metaperl> made_up word = "You made up that " ++ word
10:03:53 <neologism> you're perverse ;)
10:03:58 <_metaperl> neologism word = word ++ "is a new word"
10:04:03 <_metaperl> made_up "neologism"
10:04:24 <_metaperl> made_up "neologism"  === you made up that word which means (a word that is made up)
10:04:38 <_metaperl> my brain is really twisted now
10:05:36 <SyntaxNinja> neologism = "you made up that " ++ neologism
10:06:52 <_metaperl> neologism word = dictionary_add(word, meaningOf word)
10:37:22 <genneth> hi all
10:37:44 <genneth> i thought it was about time that i polished up my l33t haskell skillz
10:37:55 <genneth> so I read through this port scanner: http://community.moertel.com/ss/space/2004-03-13
10:38:03 <genneth> that was fun and fine
10:38:28 <genneth> but the code has a small bug in that it easily overflows the heap if I get it to scan too many ports
10:39:23 <genneth> "simple", I thought to myself, "just have a max number of threads spawned at one time, and only spawn new ones when the old ones have died"
10:40:46 <genneth> so I found myself going towards making a big mutable structure containing all the "currently scanning" ports
10:41:09 <genneth> but this would make the whole thing very imperative, ergo nasty
10:41:34 <genneth> so I was wondering if anyone could give me some hints as to a more functional style to tackle this problem?
10:46:31 <SyntaxNinja> hmm
10:48:01 <Igloo> Why do you need to know the ports currently being scanned?
10:48:05 <SyntaxNinja> genneth: I did something like this once, though not a port scanner. trying to remember what I did.
10:48:58 <SyntaxNinja> genneth: well, you could just spawn n threads, and at the end of each scan, start another scan, rather than spawning a new thread
10:49:19 <SyntaxNinja> or you could block on that thread, and when the  thread returns, spawn a new one.
10:49:33 <SyntaxNinja> not sure why you need that mutable structure
10:50:56 <genneth> my plan, in detail, was to start only as many threads as needed, up to a limit
10:51:39 <genneth> so I would have a main thread, which would forkIO when there was work to be done, and the max thread limit wasn't reached
10:52:36 <genneth> i think the problem lies in my trying to dictate execution order too precisely
11:15:08 <SyntaxNinja> genneth: then you can just have a function which spawns n threads, that's easy enough. then each thread just starts another scan when its done.
11:16:52 <genneth> i guess i would still need a counter to work out the next port to scan
11:17:01 <genneth> not a problem
11:22:44 <genneth> SyntaxNinja: thanks for your help
11:33:05 <monochrom> pardon for a bit more part and join
11:34:27 <basti_> äääääääääääääääääääääääääääääääääääääääääääääääääääääääääääääääääää
11:34:29 <basti_> ls
11:34:31 <basti_> nmxcnmyxcnmyxcnmsddgioe iop
11:34:36 <basti_> wah
11:34:39 <basti_> im sorry
11:34:42 <monochrom> Are you a cat?
11:34:54 <basti_> i didnt know how that did happen
11:34:56 <basti_> something about umlauts
11:35:22 <monochrom> A cat walking on keyboard would also do that.
11:35:33 * basti_ nods
11:39:28 <Si\> does anyone know if it's possible to markup greek characters in haddock?
11:51:47 <Si\> e.g. is there anyway in Haddock of stopping ampersand from being converted to &amp;
11:52:19 <stepcut> \& ?
11:52:26 * stepcut is making stuff up
11:54:24 <monochrom> If you write &amp; the ampersand there will not be converted to &amp;
11:54:28 <monochrom> if you get my drift.
11:55:03 <monochrom> No, don't listen to me.
11:55:08 <Si\> ?
11:55:23 <Si\> I'm trying to achieve &tau;
11:55:52 <Si\> but what I actually get is &amp;tau which aint right
11:57:10 <tic> hej sylvan
12:02:48 <Si\> ah it's actually Text.HTML that does the converting, how annoying
12:36:28 <xerox> Any "@wiki HaskellGoPeople" in the mood for a game?
12:57:57 <genneth> wow
12:58:18 <genneth> just got this out of a ghc compiled prog: port_scan: internal error: scavenge_one: strange object 68
12:58:37 <xerox> @ghc
12:58:39 <lambdabot>  internal error: Invalid object in processHeapClosureForDead
12:59:09 <reffie> @ghc
12:59:10 <lambdabot>  Type signature given for an expression
12:59:23 <xerox> @ghc
12:59:24 <lambdabot>  Can't combine named fields with locally-quantified type variables
12:59:24 <lambdabot> or context
12:59:31 <xerox> Indeed.
13:01:16 <TheHunter> that's easy: data Foo = forall a. Foo { foo :: a }
13:02:04 <xerox>     Can't combine named fields with locally-quantified type variables or context    In the declaration of data constructor Foo    In the data type declaration for `Foo'
13:02:11 <xerox> Right.
13:02:16 <TheHunter> "Type signature given for an expression" doesn't make any sense to me.
13:03:02 <xerox> ...and it says it all.
13:05:15 <TheHunter> google suggests that the error message has something to do with the ffi.
13:15:14 <genneth> :-|
13:15:18 <genneth> i'm confused
13:15:24 <genneth> what just happened?
13:15:35 <genneth> (forgive my incredible n00bness)
13:17:52 <SyntaxNinja> genneth: you got an internal ghc error. are you running on a funny platform?
13:18:16 * genneth looks sheepish
13:18:19 <genneth> amd64
13:18:21 <SyntaxNinja> genneth: the runtime system, written in C, has tried to garbage collect something that wasn't meant to be garbage collected. it's a bug in GHC.
13:18:26 <genneth> ah
13:18:29 <genneth> i was using STM
13:18:31 <genneth> on amd64
13:18:43 <genneth> that really should have sent bells ringing
13:20:13 <genneth> You know the worst thing? There was absolutely no reason for me to use it
13:20:17 <SyntaxNinja> hehe
13:20:29 <genneth> I just thought it would make me look cool
13:20:37 <genneth> :-D
13:20:44 <SyntaxNinja> and now look.  the ghc author is here. he's going to make fun of you. right JaffaCake
13:25:40 <genneth> actually, I just realised why I was using them; and now I can't work out how to do it with MVars
13:25:52 * genneth rattle his head, trying to hear an idea bounce around
13:27:57 <xerox> 'night folks.
13:35:00 <genneth> I made a little threadPooler thing:
13:35:08 <genneth> limitThreads :: TMVar Int -> Int -> IO a -> IO a
13:35:08 <genneth> limitThreads poolcount lim io = do
13:35:08 <genneth>     atomically ( do
13:35:08 <genneth>         prev <- takeTMVar poolcount
13:35:08 <genneth>         if prev >= lim then
13:35:09 <genneth>             retry
13:35:11 <genneth>             else putTMVar poolcount (prev+1) )
13:35:13 <genneth>     out <- io
13:35:15 <genneth>     atomically ( do
13:35:17 <genneth>         prev <- takeTMVar poolcount
13:35:19 <genneth>         putTMVar poolcount (prev-1) )
13:35:23 <genneth>     return out
13:35:56 <Lunar^> genneth: Seems that you only need TVar here
13:36:33 <genneth> Lunar^: so I would
13:36:39 <genneth> silly me
13:37:15 <genneth> do you think the general idea is good tho?
13:37:45 <genneth> the current, nonlimited threading case has a map (threadWithChannel . scan1Port host) ports
13:38:19 <genneth> so with limitThreads you would just do mapM (limitThreads threadpoolcounter 10 . threadWithChannel . scan1Port host) ports
13:38:39 <genneth> where threadpoolcounter is something the caller has to initialize
13:38:55 <genneth> (the first line should have been a mapM too, btw)
13:48:43 <Cale> Probably a good idea actually to wrap the whole pattern as well, so you have a threadLimitedMapM :: Integer -> [IO a] -> [IO a]
13:49:07 <Cale> er
13:49:30 <Cale> wrong type :)
13:50:19 <Cale> threadLimitedMapM :: Integer -> (a -> IO b) -> [a] -> IO [b]
13:50:29 <Cale> right
13:50:43 <Cale> which would simply initialise that TVar
13:50:54 <genneth> Ah yes, I see; that would be an improvement
14:29:44 * SamB wishes for ParserT
14:30:12 * boegel gives SamB an eyelash to make his wish come true
14:30:15 <boegel> blow it
14:30:35 <SamB> blow it?
14:30:50 <basti_> dont you know this?
14:31:03 <boegel> yeah, blow the eyelash away and make your wish (silently, don't say it)
14:31:21 <boegel> when one of your eyelashes falls it, you should blow it away for good luck
14:31:34 <boegel> s/it/out
14:31:51 * SamB blows and makes a wish
14:32:18 <boegel> yo goron
14:33:04 <SamB> I want to do evaluation in the midst of parsing...
14:33:44 <SamB> well, I don't *really* want to, but my datatypes seem to, and so does this Self Programmers Reference...
14:33:48 <boegel> I'm guessing that's not possible using Happy or Parsec ?
14:34:11 <basti_> parsing should be done with arrows.
14:34:18 <basti_> other things shouldn't if you can avoid it.
14:34:55 <SamB> I don't know what to do with object literals...
14:36:50 <SamB> @google Self-4.1-Pgmers-Ref.pdf
14:36:52 <lambdabot> http://research.sun.com/self/release_4.0/Self-4.0/manuals/Self-4.1-
14:36:52 <lambdabot> Pgmers-Ref.pdf
14:37:40 <SamB> on what claims to be page 7 (though gv says it is page 12) of that, in section 2.1.9, it says:
14:38:07 * SamB opens it in Xpdf to paste
14:39:39 <SamB> Object literals are constructed during parsing--the parser converts objects in textual form into real SELF objects. An object literal is constructed as follows:
14:39:40 <SamB> · First, the slot initializers of every slot are evaluated from left to right[...]
14:45:14 * SamB wonders why there are Tolkien quotes everywhere in Pugs...
14:45:36 <SamB> (I'm stealing ideas from Pugs for an interpreter of my own)
14:45:37 <mauke> there are? cool
14:45:42 <integral> a) there's Tolkien quotes in the perl5 source, b) Autrijus and Larry are tolkien fans :-)
14:45:49 <boegel> SamB: becauses nerds like us wrote it ? :)
14:46:10 <boegel> or what he said :p
14:46:24 <SamB> how do you tell if a tree is golden or not in Haskell?
14:46:42 <basti_> uh
14:46:57 <basti_> True
14:47:05 <basti_> the tree is either golden or not
14:47:05 <basti_> ;)
14:47:17 <SamB> how do you tell WHICH it is?
14:47:52 <basti_> (golden-p tree)?
14:48:43 <basti_> something like that
14:50:01 <SamB> so how in the world shall I deal with object literals? Do I actually need to represent code differently in my parser and my interpereter?
14:50:43 <integral> pugs punts and uses all the same stuff for both
14:54:01 <SamB> oh, I see, it uses something called unsafeEvalExp.
14:54:52 <integral> but the way something like parrot works is that you store a serialised form of the object with the bytecode
14:55:12 <integral> and then when the runtime starts up you take the serialised stuff and allocate heap space for real objects
14:55:46 <SamB> now I need to find a way to somehow shoehorn the lobby through Parsec
14:56:27 <SamB> integral: yeah, I'm probably going to want to figure out some way of storing "images" at some point...
14:56:36 <SamB> I'm working on my Self implementation
14:56:52 * integral would like to see Pugs fixed to separate the two too 8-)
14:58:18 * boegel goes to bed with his RTS book (almost finished ! )
14:58:33 <SamB> RTS book?
14:59:05 <boegel> SamB: I have an exam on real-time systems on Monday, so I have to finish the part of the book we need to know (it's boring as hell)
14:59:55 <SamB> oh, I thought you meant something INTERESTING, like RunTime Systems :-(
15:01:51 <boegel> SamB: :)
15:03:25 <SamB> okay, what do I need to do to use unsafePerformIO without the optimizer doing bad things to it?
15:03:54 <TheHunter> {-# NOINLINE #-}
15:04:12 <TheHunter> sometimes you need phantom arguments.
15:04:48 <SamB> actually, I'm sure I have quite enough arguments...
15:05:03 <basti_> :-D
15:07:08 <TheHunter> maybe you need to turn off cse, too.
15:07:39 <SamB> cse?
15:07:45 <SamB> oh, that.
15:08:17 <TheHunter> common subexpression elimination, it has sometimes very evil effects.
15:10:37 <SamB> and what do I {-# NOINLINE #-}?
15:11:39 <TheHunter> the caller of unsafePerformIO, usually
15:12:11 <Igloo> SyntaxNinja: Do you know if anyone plans on packaging quickcheck for Debian?
15:12:54 <Igloo> Hmm, I wonder what the status of hunit is, actually
15:17:00 <SamB> doesn't QuickCheck come with GHC?
15:17:09 <SamB> or do you mean the script?
15:23:52 <Igloo> SamB: Yeah, it comes with all the impls now. I hadn't realised that when I wrote the above  :-)
15:25:57 <SamB> of course, they changed the name...
15:26:32 <SamB> (well, the old one (Debug.QuickCheck) still works, but is deprecated)
15:28:38 <SyntaxNinja> is there a QC version where you can test IO / monad code, btw?
15:28:52 <SyntaxNinja> Igloo: does that answer your question?
15:29:42 <Igloo> SyntaxNinja: I've just sent a mail to the list asking what our plan for hunit+quickcheck and haxml should be
15:32:53 <SyntaxNinja> c00
15:49:06 <SamB> @index unsafePerformIO
15:49:07 <lambdabot> System.IO.Unsafe, Foreign
16:00:15 <nothingmuch> in parsec, how do i negate a parser? notFollowedBy? I'd like to match stuff which is not 'space'
16:01:02 * arjanoosting is going to sleep
16:01:31 <Lemmih> nothingmuch: many1 (noneOf " ")?
16:01:53 <nothingmuch> Lemmih: not space as in %20, but space the parser, which matches any whitespace
16:01:53 <SamB> well, look at the definition of 'space'
16:02:01 <Lemmih> But that will fail on chars other than ' ' /-:
16:02:04 <SamB> space               = satisfy (isSpace)     <?> "space"
16:02:28 <nothingmuch> SamB++
16:02:43 * nothingmuch ought to assume things are simpler than they appear in haskell
16:03:48 <SamB> with parsec, most of the stuff not in [...].Prim is fairly simple.
16:39:42 <resiak> I'm investigating HaXml, but the document that I want to parse has only a schema, not a DTD. Is there an equivalent to DtdToHaskell?
16:59:11 <Lunar^> @index threadDelay
16:59:12 <lambdabot> GHC.Conc, Control.Concurrent
17:05:33 <SamB> resiak: I personally would probably prefer the doctype-independant representation
17:08:45 <dons> moin
17:09:50 <SamB> @help dict
17:09:52 <lambdabot> I perform dictionary lookups via the following 14 commands:
17:09:52 <lambdabot>  @all-dicts .. Query all databases on dict.org
17:09:52 <lambdabot>  @devils ..... The Devil's Dictionary
17:09:52 <lambdabot>  @easton ..... Easton's 1897 Bible Dictionary
17:09:52 <lambdabot>  @elements ... Elements database
17:09:52 <lambdabot>  @foldoc ..... The Free On-line Dictionary of Computing
17:09:54 <lambdabot>  @gazetteer .. U.S. Gazetteer (1990)
17:09:56 <lambdabot> [8 @more lines]
17:10:04 <SamB> @all-dicts moin
17:10:09 <lambdabot> No match for "moin".
17:10:13 <SamB> @all-dicts moinmoin
17:10:14 <lambdabot> No match for "moinmoin".
17:10:28 * SamB forgot what moin means :-(
17:13:18 <resiak> SamB: I've read the documentation further now -- that's probably the best idea.
17:13:46 <lispy> http://en.wikipedia.org/wiki/Moin
17:15:31 <dons> @wikipedia Moin
17:15:33 <lambdabot> http://en.wikipedia.org/wiki/Moin
17:15:37 <dons> :P
17:16:06 <lispy> @wikipedia does it just do a search?
17:16:08 <lambdabot> No result found.
17:16:25 <dons> yep
17:16:29 <lispy> @wikipedia golbach conjecture
17:16:31 <lambdabot> No result found.
17:16:41 <lispy> @wikipedia goldbach conjecture
17:16:43 <lambdabot> http://en.wikipedia.org/wiki/Goldbach_conjecture
17:18:42 <lispy> media wiki says it can block by ip or user name, but when i type in a user name in just says: Invalid IP address
17:18:47 <lispy> that's not very helpful...
17:36:11 <dons> @y0w
17:36:12 <lambdabot> And furthermore, my bowling average is unimpeachable!!!
17:36:16 <dons> @ghc
17:36:17 <lambdabot>  Kind signature on data type declaration has non-* return kind
17:36:27 <dons> oh, that would be fun
17:37:18 <SamB> what is wrong with that?
17:37:32 <SamB> is it only hardwired for (#,#)?
17:37:57 <SamB> no, wait..
17:38:08 <SamB> that was a function...
17:38:23 <SamB> (How could that happen?)
17:38:26 <SamB> @ghc
17:38:28 <lambdabot>  A lazy (~) pattern connot bind existential type variables
17:38:35 <SamB> @ghc
17:38:36 <lambdabot>  Exotic Stmt in meta brackets
17:38:43 <SamB> exotic stmt?
17:38:51 <SamB> erm, Stmt?
17:41:31 <dons> bonus prize to anyone who can produce an exotic stmt
17:42:04 <dons> Stmt is an internal data type
17:42:30 <SamB> yeah, yeah.
17:44:12 <SamB> well, I'm not going to get anywhere comparing Language.Haskell.TH.Syntax with Language.Haskell.Syntax
17:46:24 <dons> how's the Haskell backend going, btw?
17:47:20 <SamB> hmm, I haven't been working on it since I discovered I probably needed to do it in the Eval monad...
17:48:12 <dons> I don't know pugs enough to know what the Eval monad does. But why does  that make it difficult? Is Eval tricky?
17:49:00 <lispy> heh, s/Eval/Evil/
17:49:22 <lispy> instance Monad Evil where ...
17:49:26 <dons> oh the evil monad. sounds nasty
17:49:38 <lispy> actually, this would be a good exercise
17:49:41 <dons> where all the rules are reversed!
17:49:56 <lispy> yeah, show just how awful monads can be
17:50:32 <dons> never as bad as how awful imperative programming can be  ;)
17:50:49 <lispy> any of you know of any famous heuristics to decide if a graph has a hamiltonian path?
17:51:34 <lispy> dons: i was talking with an imperative programmer today about that actually.  They believed that Monads are worse than having a language in which state modification is assumed
17:52:04 <lispy> they believed that languages which assume state modification give you tools for dealing with and controlling it.  Tools that haskell apparently does not provide
17:52:23 <dons> what tools?
17:52:25 <lispy> i wasn't convinced, but that was their argument
17:52:47 <lispy> i'm not sure
17:52:51 <lispy> i couldn't figure that out
17:53:04 <lispy> part of why i wasn't convinced
17:53:25 <lispy> I _think_ they meant how you declare things to be pointers sometimes and non-pointers at other times
17:53:34 <dons> isn't the problem that they provide no tools for controlling state?
17:53:53 <dons> that doesn't seem related.
17:54:05 <dons> do you mean a cast of a point to a word, or such like?
17:54:07 <SamB> maybe they provide tools that haskell doesn't... because haskell doesn't have the associated ways to alter state.
17:54:20 <dons> it doesn't?
17:54:57 <lispy> this was motivated by their struggles with state monads that were changing state in unexpected ways
17:55:11 <lispy> anyway, don't worry about it
17:55:22 <lispy> it was a silly dicussion ;)
17:55:27 <lispy> discussion*
17:55:43 <dons> if  you have to learn functional programming at the same time, then I can imagine there are unexpected changes to state
17:56:34 <lispy> my first language was VB.  Man, I was so impressed by C when I started learning it.
17:56:48 <lispy> it's funny to think about that now
17:57:06 <lispy> but the fact that you could pass any data type to a function and return any data type was amazing
17:57:14 <lispy> even user defined data types
17:57:31 <lispy> then when i learned lisp and you could not only pass data, but also functions
17:57:45 <mauke> well, C has function pointers
17:57:55 <lispy> true, and they can do...stuff
17:58:05 <lispy> but it's just not the same ;)
17:59:19 <mauke> huhu, or you could construct a buffer of machine code and cast it to a function pointer
17:59:36 <lispy> that's a lot more complicated than it sounds
17:59:37 <mauke> instant horrible closures!
17:59:47 <dons> @type "bytes"#
17:59:52 <lambdabot> "bytes"# :: GHC.Prim.Addr#
18:00:00 <lispy> the linux kernel does it in a few places, and the code is very hard to understand
18:00:47 <lispy> the way they do it in the kernel you don't know where the code will be at runtime so they have to take great pains to make it "relocatable"
18:01:16 <lispy> jmps and gotos that are relative are troublesome
18:01:31 <lispy> er perhaps i meant not relative
18:01:35 <dons> @type (GHC.Base.unsafeCoerce# "bytes"#) :: Int -> String
18:01:36 <lambdabot> (GHC.Base.unsafeCoerce# "bytes"#) :: Int -> String :: Int ->
18:01:36 <lambdabot> String
18:01:57 <dons> "construct a buffer of machine code and cast it to a function pointer"
18:02:35 <mauke> ... to emulate closures
18:02:58 <dons> oh sure. I was just pondering how to do something that evil in .hs
18:03:36 <mauke> do you know how to do it in "standard" OCaml?
18:03:51 <dons> the trick is to fill the "bytes"# byte array with something that won't crash when you evaluate it
18:03:59 <mauke> i.e. without using libraries that require extra command line arguments to the compiler
18:04:05 <dons> don't know OCaml enough.
18:05:14 <mauke> I know it has some nice holes in its type system, especially Marshal.from_string
18:11:16 <dons> is Marshal part of their ffi code?
18:12:43 <mauke> I don't think so
18:13:20 <dons> or it could be an eval function with a name like that
18:13:41 <dons> @type System.Eval.Haskell.eval
18:13:43 <lambdabot> System.Eval.Haskell.eval :: forall a.
18:13:43 <lambdabot>           (AltData.Typeable.Typeable a) =>
18:13:43 <lambdabot>           String -> [System.Eval.Utils.Import] -> IO (Maybe a)
18:13:48 <dons> string -> a
18:17:07 <am02> Alright chaps. I'm a touch inexperienced with type classes and IO and am having a slight problem:
18:17:22 <am02>  I've got two functions which do some IO and return different instances of the same class, which I've defined.
18:17:35 <am02>  I'd like to call one or the other of them based on the value of a string, and assign the resulting variable.
18:17:54 <am02>  I'm not sure how to approach this, I wrote a function a :: MyClass a => String -> IO a but the compiler tells me it can't unify the types.
18:19:13 <foxy_> am02: Even though your types share the same class, during typechecking they are nevertheless *different* types.  You could try a union type to solve the problem.
18:19:21 <dons> agreed.
18:19:31 <am02> a type union?
18:19:43 <foxy_> @type Either
18:19:45 <lambdabot> bzzt
18:19:57 <dons> @kind Either
18:19:59 <lambdabot> Either :: * -> * -> *
18:20:24 <Limbic_Region> hello, my name is Limbic_Region and I am an imperative hacker
18:20:32 <Limbic_Region> now that I got that out of the way....
18:20:40 <am02> that's in the prelude, I'll investigate. Thanks.
18:20:40 <Limbic_Region> quick question WRT YAHT
18:21:02 <Limbic_Region> it says that multiplication binds more tightly than division - which seems odd to me
18:21:28 <Limbic_Region> should I just shut up and keep reading or what?
18:21:32 <foxy_> @plugs 2 * 3 / 4
18:21:38 <lambdabot> 1.5
18:21:46 <foxy_> @plugs 2 * (3 / 4)
18:21:47 <lambdabot> 1.5
18:22:31 <Limbic_Region> foxy_ - not intending to be dense here - but that's exactly what I would expect
18:22:49 <dons> infixl 7 /
18:22:56 <dons> infixl 7 *
18:23:11 <dons> division doesn't bind more tightly.
18:23:18 <Limbic_Region> ok - thanks dons
18:23:41 <mauke> @plugs 3 / 4 * 2
18:23:43 <lambdabot> 1.5
18:23:58 <Limbic_Region> not sure why then YAHT states that it does
18:24:36 * Limbic_Region will go back to reading the dark arts now
18:24:37 <Limbic_Region> thanks
18:26:39 <am02> That worked. The union type  - you learn about something new every day, cheers again.
18:30:29 <Igloo> Division effectively binds more tightly for normal types
18:33:41 <nothingmuch> can someone please annotate `:i IO`?
18:33:56 <nothingmuch> it's a type which gets a type variable
18:34:05 <nothingmuch> which is defined to be a lambda
18:34:12 <nothingmuch> that takes stuff representing state and world
18:34:40 <nothingmuch> and returns a touple that contains state, the world, and the thing inside the monad?
19:30:29 <IA-Guest5374697> hi
19:32:59 <LordIczer> excuse me, Im newbie to haskell language and have a doubt about datatypes, may someone help me plz, I really aprecciate because Im stuck  :S
19:34:59 <nothingmuch> LordIczer: i can try
19:35:16 <LordIczer> thanks :D
19:35:19 <am02> I'm not great but I can try also.
19:35:29 <nothingmuch> no promises, though, i'm a newbie too
19:35:54 <LordIczer> well let me write why Im stuck, just give me a sec plz
19:38:28 <nothingmuch> LordIczer: if it's very big put it some nopaste service
19:39:12 <nothingmuch> http://www.haskell.org/hawiki/HaskellIrcPastePage
19:39:37 <LordIczer> sorry, is not so much, but english isnt my primary language and I try to make as clear as posible
19:40:33 <nothingmuch> okay
19:42:05 <LordIczer> well to put it simple, which is the best way to put this C struct as a datatype in Haskell
19:42:06 <LordIczer> typedef struct Color3f {
19:42:06 <LordIczer>     const F4 red;
19:42:06 <LordIczer>     const F4 green;
19:42:08 <LordIczer>     const F4 blue;
19:42:11 <LordIczer> };
19:42:17 <LordIczer> where F4 is a float
19:42:45 <LordIczer> I dont know if is best /efficent use a list or a tuple :S
19:42:54 <nothingmuch> well, your usage will be different, i think
19:43:10 <gzl> i'd use a tuple for rgb values
19:43:12 <nothingmuch> are you casting the constness away? or is it really done at compile time?
19:43:31 <nothingmuch> data Color3f = (Num, Num, Num)
19:43:44 <nothingmuch> or maybe nicer:
19:44:02 <gzl> why not type Color = (Float, Float, Float)
19:44:19 <nothingmuch> data Color3f = { red::Float, green::Float, blue::Float }
19:44:28 <nothingmuch> gzl: because i'm not very awake
19:45:03 <nothingmuch> green _@Color3f{ value } = value -- is the _ necessary?
19:45:04 <gzl> yeah, actually, I was just about to suggest giving them field names
19:45:11 <LordIczer> thats the way I made [this -> data Color3f = { red::Float, green::Float, blue::Float }]
19:45:30 <gzl> what's up with the []
19:45:44 <nothingmuch> i think YAHT has an inspiring type definition for colors
19:45:53 <nothingmuch> anyway, i'm off to the shower
19:46:20 <LordIczer> (gzl): isnt a part of the syntaxis, only a paranthesis
19:46:49 <nothingmuch> LordIczer: it's confusing though, it almost reads like (this -> ... ), which doesn't make sense
19:46:56 <LordIczer> but if sometimes I need an alpha channel?
19:47:03 <nothingmuch> and it almost reads like a list containing such a nonsensical lambda expression
19:47:34 <gzl> if you sometimes need an alpha channel make it a 4-tuple
19:47:58 <nothingmuch> data Color = { red::Float, green::Float, blue::Float } | { red::Float, green::Float, blue::Float, alpha::Float }
19:48:00 <LordIczer> I see  :O
19:48:29 <gzl> or that
19:48:44 <nothingmuch> is there a more concise way to write it?
19:48:55 <gzl> maybe, but I'm half asleep too
19:49:01 <nothingmuch> beh, getting carried away
19:49:04 <nothingmuch> must shower now
19:49:17 <LordIczer> (nothingmuch): thanks, I try that way
19:50:07 <gzl> you'll need to add constructors, no?
19:51:43 <LordIczer> but is a datatype isnt? why I need constructors?  :O
19:52:42 <gzl> that's the way it works
19:52:59 <gzl> if you do something like data Color = Red | Green | Blue, those are all constructors, just ones that take 0 arguments
19:54:54 <gzl> there, Color is a data constructor and Red/Green/Blue are type constructors ... the tutorial has stuff about this
19:55:14 <LordIczer> but then what is the definition of the datatype?... or the data Color = Red | Green | Blue is real "data"? Im confused [indeed is strange when coming from C++ background u_ub]
19:56:12 <gzl> crap, I wrote that backwards
19:56:16 <LordIczer> ahh, ok, sorry, I type without watch that you answer gzl :S
19:56:34 <gzl> Color is the type constructor, Red is a data constructor
19:57:16 <LordIczer> I see
19:57:31 <gzl> this is explained in the tutorial with examples and stuff
19:58:48 <gzl> a more substantive example that may help you make more sense of what is going on is the following, for trees: data Tree a = Leaf a | Branch (Tree a) (Tree a)
19:58:48 <LordIczer> I'll try the tutorial that of the topic ^_^
19:59:58 <gzl> so the type is polymorphic (so you can stick anything into a tree)
20:00:03 <gzl> and recursive
20:00:35 <gzl> e.g. Branch (Leaf 4) (Branch (Leaf 1) (Leaf 2))
20:00:51 <gzl> I'm sort of babbling because I'm tired, but maybe you get part of the point
20:01:09 <Cale> which would be of type Tree Integer, or really (Num a) => Tree a
20:01:18 <LordIczer> that is what I want, because sometimes I need rgb and others hsv
20:02:10 <gzl> so one could do something like data Color = RGB (Float, Float, Float) | CMYK (Float, Float, Float, Float)
20:04:05 <LordIczer> and the data constrcutor for that will be something like data ColorX = 0.50 0.25 1.00 0.75  ?
20:04:19 <LordIczer> in the case of CMYK
20:05:59 <Cale> The data constructors are called CMYK and RGB, and you'd call them like red = RGB 1 0 0
20:06:15 <Cale> red :: Color
20:06:37 <LordIczer> I see  :O
20:06:57 <Cale> or actually,
20:07:03 <Cale> RGB (1,0,0)
20:07:09 <Cale> the way it was written there
20:07:22 <Cale> there's no real need to tuple the elements
20:07:42 <Cale> You could also write: data Color = RGB Float Float Float | CMYK Float Float Float Float
20:09:37 <LordIczer> I thougt about the use of a list [because the use of sometimes 3 args and others 4]
20:10:27 <LordIczer> but I see this way is easier to understand Cale
20:10:29 <Cale> sometimes that would be appropriate, but usually if the entries of the list have special meanings by position, you probably want a record
20:10:46 <Cale> or plain algebraic datatype
20:11:47 <Cale> data Colour = RGB { red :: Float, green :: Float, blue :: Float } | CMYK { cyan :: Float, magenta :: Float, yellow :: Float, black :: Float }
20:12:04 <Cale> will also define extractor functions for free
20:13:06 <Cale> like,  green (RGB 0.5 0.16 0.01) = 0.16
20:13:06 <LordIczer> I see
20:15:13 <LordIczer> I'll implement now correctly the datatypes in order to start the functions, thanks Cale for your help :D
20:15:58 <Cale> no problem
20:57:01 * autrijus tries to grasp the idea of a language centered around runIO
20:57:08 <autrijus> runIO :: IO a -> Q a
23:41:28 <dons> @ghc
23:41:29 <lambdabot>  eval_thunk_selector: strange selectee
23:43:03 <lispy> @vixen so, it's friday night, you doing anything?
23:43:07 <lambdabot> Have you ever killed a hobo?  Ive found eating their liver gives me
23:43:07 <lambdabot> strength.  I think i may just be short on b vitamines.
23:51:38 <dons> vixen is a strange person
23:52:31 <lispy> yeah, it made me run away
23:52:55 <lispy> stupid mail server, why isn't it letting me use ssl
23:54:21 <lispy> and why is there no good email client
23:54:29 <lispy> trying out thunderbird and it's okay
23:54:38 <lispy> but i wish i could take what i like about gnus and mesh it with this one
23:54:47 <dons> mutt?
23:54:56 <lispy> i tried mutt once
23:55:03 <lispy> i wasn't that impressed
23:55:14 <lispy> maybe with the emacs server it would be better
23:56:13 <dons> sendmail then?
23:56:19 <lispy> er?
23:56:28 <lispy> that's not a client is it?
23:57:01 <dons> sendmail me@somewhere < msg
23:57:06 <dons> ;)
23:57:12 <dons> telnet?
23:57:31 <dons> tcp/ip??
23:57:37 * dons should do some work
23:57:38 <lispy> heh
23:59:19 <dons> Network.Socket is the best client by far
23:59:49 <lispy> yeah, i just wish i could get all my accounts to have the same settings
23:59:58 <lispy> and to sync my mail
