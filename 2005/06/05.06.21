00:09:11 <boegel> I guess I can
00:09:36 <boegel> I wish I had time to just add support to the parser, then i'd be able to add it in the wiki
00:18:22 <kzm> vegai, I noticed Bernhard Pope didn't like "buggah" :-)
00:19:22 <boegel> @wiki HRay
00:19:25 <lambdabot> http://www.haskell.org/hawiki/HRay
00:19:28 <boegel> bourbaki, seidan: ^
00:20:47 <vegai> kzm: too bad that he caved in to just some requests
00:21:06 <vegai> on the other hand, perhaps "Buddha" wasn't a very good name anyway. Not very descriptive etc
00:24:08 <Itkovian> boegel, if the code is online we can add stuff to the parser etc, no? I mean, that's the whole point of having it online in a darcs repos, well, one of the main points anyway
00:25:56 <kzm> vegai, it needs a name.  Better than stalin or satan.
00:25:59 <boegel> Itkovian: you mean i should make the repo writable ?
00:25:59 * kzm shrugs.
00:26:16 <boegel> or doesn't it work that way? :)
00:26:34 <Itkovian> erm, no, you can justa ccept email patches, no?
00:26:45 <Itkovian> I just mean that you do not have to do everything yourself
00:27:04 <boegel> yeah, but I won't be able to check them out and add to the repo any time soon
00:27:24 <boegel> I don't have problems with people adding stuff, on the contrary, it's neat :)
00:27:42 <boegel> but the 'problem' with jyp's patches is that they're not complete and/or tested fully
00:27:51 <boegel> i had to work on it a bit to get it working
00:28:09 <Itkovian> well, we can do that too, and just send a patch when it's working, eh
00:28:13 <boegel> but hey, if you feel like adding metaball support to the parser, you're welcome :)
00:28:20 <boegel> yeah sure, no problem :)
00:28:33 <boegel> I wanted to do it myself, but I guess I won't have time
00:33:42 <vegai> kzm: you don't approve of the name of a certain optimizing scheme compiler? =)
00:34:06 <vegai> seriously though, is hdb taken?
00:34:16 <vegai> as in "Haskell Debugger"
00:34:34 <boegel> it could mean "Haskell Database"
00:34:35 <ski> hddb ?
00:34:54 <ski> (.. declarative ..)
00:35:26 <ski> Buggha ?
00:35:39 <vegai> oh, Database. Right
00:36:16 <vegai> hdbg? =P
00:36:21 <vegai> hard to type, not good
00:36:29 <vegai> in dvorak anyway
00:37:14 <ski> hm .. de' Buggha
00:38:34 <vegai> how about haskell-programs-cant-have-any-bugs-but-when-they-do-use-this-program
00:38:55 <vegai> I'm thinking perhaps too schemey now
00:39:15 <boegel> vegai: sounds great !
00:39:32 <boegel> Debuh ?
00:40:36 <boegel> habug (Haskell Anti-Bug)
00:40:55 <boegel> just throwing sutff in here :)
00:41:10 <vegai> hraid
00:41:50 <vegai> hex -- haskell exterminator
00:42:26 <vegai> oh, isn't "hex" some kind of a magic spell too
00:42:42 <vegai> oh, an "evil spell", not good
00:43:16 <ski> hexpel
00:45:02 <vegai> Muhammed :-P
00:45:11 <ski> :)
00:45:21 <boegel> vegai: ? :)
00:45:42 <ski> hammurabug
00:45:55 <boegel> too long imho
00:49:09 <vegai> humbug
00:49:18 <boegel> that's a good one
00:49:34 <boegel> but why 'm' and not 'n' ?
00:49:35 <boegel> hunbug
00:49:37 <ibid> nonono, it's "bah! humbug." :)
00:50:09 <vegai> hunbug would be better
00:50:18 <vegai> as in "Haskell UnBug"'
00:50:23 <vegai> not very grammatical, perhaps, but..
00:50:34 <ski> hungbug
00:50:52 <vegai> humbug would actually mean something, though
00:50:58 <boegel> ski:  ? wtf ? that just sounds weird if you ask me
00:51:05 <boegel> what does humbug mean ?
00:51:24 <ski> http://en.wikipedia.org/wiki/Humbug
00:51:44 <ibid> nobody got my reference? :)
00:52:31 <boegel> ibid: wikipedia says it has to do with 'A Christmas Carol', but I didn't know that
00:52:31 <ibid> well, at least wikipedia knows it :)
00:52:37 <ibid> yes, it does
01:01:19 <boegel> hehe, some painting were sold be some chimp, and they switched owners for more money than painting by Warhol :)
01:01:33 <boegel> s/be/by
01:04:20 <kzm> Perhaps I can convince BP to accept Beelzebuddha by drawing a logo?  A meditating fat curly guy with horns and pronged tail?
01:04:48 <kzm> (I don't think we want any logo if the new name is buggha :-)
01:06:36 <kzm> Or, for MTV fans, what about "buddhead"?
01:07:40 <boegel> don't see the link with "debugging" anymore then...
01:07:56 <boegel> or isn't this the same app we're talking about ? :)
01:12:53 <kzm> Depends if "buddha" is associated with debuggning, I guess.
01:13:22 <kzm> buddha is relatively well known, shouldn't lose the branding effect.
01:13:33 <kzm> (Of course, my suggestions aren't entirely serious)
01:14:14 * ski imagines a meditating fat bug
01:14:41 * kzm imagines bugs being squashed under a meditating guy.
01:15:28 * kzm imagines a falling, flaming buddha being cast onto a sea of bugs (sorry we're out of brimstone)
01:15:52 <kzm> I guess it must be Beelzebug, then?
01:16:04 <Itkovian> Izebug
01:16:07 <kzm> "Lord of ..bugs"?
01:16:20 <Itkovian> pretty satanic eh
01:16:21 <kzm> close enough.
01:16:38 <boegel> kzm: I could try and draw you a logo sketch, if you'd like that
01:16:41 <kzm> Well, it wasn't me who started pulling religion into it :-)
01:16:42 <boegel> for Buddha ?
01:16:59 <ski> (reminds of Lord of Locusts in "Bone" comic ..)
01:17:04 <boegel> or Beelzebuddha, or whatever
01:17:28 <Itkovian> I think we should keep Haskell separated from religious stuff, no?
01:17:35 <kzm> I think you should ask Bernhard Pope about what the new name will be first :-)  (Unless you want to draw a plargleflarb or whatever)
01:17:40 <Itkovian> well, from _other_ religious stuff at least
01:18:05 <Itkovian> drbean, you seem to be phasing in and out.
01:18:29 <Itkovian> having trouble with eddies in the space-time continuum
01:18:31 <kzm> Functional programmer even have their own Church.
01:18:32 <Itkovian> ?
01:18:40 <Itkovian> kzm: true
01:18:42 <boegel> kzm: no, don't ask The Pope, kep Haskell seperated from religious stuff ! :p
01:19:00 <kzm> And a Pope, who apparently believes in Buddha.
01:19:18 <boegel> Itkovian: on the Hitch Hikers topic, does the big whale appear in the movie ?
01:19:39 <kzm> Now there's an opportunity for bug squashing.
01:20:40 <Itkovian> I have no idea
01:21:02 <Itkovian> At least it has found a friend :-0
01:21:18 <boegel> I think that would produce cool images :)
01:21:49 <Itkovian> well, splattered images at least
01:21:56 <Itkovian> the pot of flowers is also important
01:22:01 <Itkovian> 'oh no!'
01:23:08 <boegel> hehe
01:24:12 <kzm> "not again", wasn't it?  Just the feeling I have when I find another bug.
01:24:57 <Itkovian> well, yeah, i thought he said that somewhere else ;-)
01:25:10 <Itkovian> there's lots of opportunities, eh
01:29:46 * boegel yawns
01:41:30 * kzm just bought a house.  Whee.
01:46:28 <Itkovian> congrats
01:46:34 <Itkovian> kzm: pictures?
01:54:04 * boegel in hungry already
01:54:09 <boegel> s/in/is
01:54:11 <boegel> damned
02:05:01 <kzm> Itkovian,  hmm...I'll see if I can find the URL.
02:05:30 <kzm> http://finn.no/finn/realestate/object;pdc=1119249581123?finnkode=5693460&sid=2a_ZZejBv581118&pos=1
02:05:36 <Itkovian> mine is at http://www.elis.ugent.be/~ageorges/huis/
02:05:55 <Itkovian> the pictures at at least a year old, so much work has been done since :-)
02:05:57 <kzm> It's in Norwegian, but if you click on the picture, you should get them all.
02:06:26 <boegel> wow, nice house !
02:06:49 <kzm> Hmm... does that mean you're ready for new engagements, Itkovian?
02:06:51 <kzm> :-)
02:06:54 <boegel> are you sitting at that little desk in the corner now ? :)
02:06:55 <xerox> Indeed.
02:06:59 <xerox> ('morning)
02:07:07 <Itkovian> kzm: cool!
02:07:18 <Itkovian> kzm: what new engagements?
02:07:27 <boegel> that garden rocks
02:07:49 <Itkovian> We still ahve to finish the ceiling, new windows at the front are coming in July, the attich has to be redone, stairway to the attic, paint, ...
02:07:50 <xerox> The garden is absolutely beautiful.
02:07:51 <boegel> kzm: Itkovian is married, and has a little boy, how much more engaged can you be ? :)
02:07:52 <kzm> boegel, no, I still live in our apartement.  Anybody want to buy a nice apartement, close to the centre of Bergen? :-)
02:08:01 <Itkovian> hah
02:08:11 <Itkovian> kzm: i might be interested, but i lack money
02:08:14 <boegel> Bergen ? Belgium ?
02:08:17 <kzm> Engagements as in helping to renovate a house.  I need a new kitchen and a bathroom or two :-)
02:08:22 <dcoutts_> @seen lightstep
02:08:23 <lambdabot> I saw lightstep leaving #haskell 13 hours, 8 minutes and 34 seconds
02:08:23 <lambdabot> ago.
02:08:39 <kzm> Bergen.no, not .be. (Or .nl for that matter.  Or is that Berg-en-tal?)
02:08:52 <Itkovian> kzm: my inlaws have a decorating firm, they build kitchens, bedrooms, everything the body needs :-)
02:09:21 <Itkovian> but somehow, we seem to be at the far end of the production  chain :-)
02:09:35 <boegel> Itkovian: heh
02:09:40 <kzm> Good deal!  My inlaw (only father left now) is a teacher.
02:09:47 <Itkovian> they are waiting for their own bedroom for 13 years ...
02:09:58 <Itkovian> kzm: that's cool
02:10:01 <kzm> So my kids know how to read and write, but my apartement isn't too polished.
02:10:03 <Itkovian> what does he teach?
02:10:13 <Itkovian> hah, well, it's just a place to live, you know ...
02:10:21 <Itkovian> education is more important
02:10:33 <kzm> Mmm...now he's in elementary school.  Used to work with (what is the PC term) challenged children.
02:10:40 <Itkovian> which is why out place has a 10-year plan for getting finished
02:10:44 <Itkovian> ok
02:10:50 <kzm> But they closed down the special schools, and tried to integrate them in the normal school.
02:10:54 <Itkovian> ouch
02:11:01 <Itkovian> must be bad for some kids
02:11:03 <boegel> stupic fucks
02:11:16 <boegel> why were the special schools there in the first place
02:11:25 <boegel> I bet this has something to do with money again
02:11:35 <kzm> Unfortunately, integration too often becomes isolation, and a regular school can't have the same kind of competence.
02:11:44 <kzm> Well, it's a lot more expensive, too.
02:12:21 <Itkovian> doesn't matter.
02:12:23 <kzm> So, yes, "sucks" is a pretty descriptive word for it, I think.
02:12:40 <Itkovian> those kids will be able to have a part in society later, so they MUST be educated in a decent way
02:13:03 <kzm> It's kind of a trend, human rights and social democracy, you know.  Don't "stow away" the "undesirables".
02:13:43 <kzm> But when there is a need for specialized teaching methods, they lose.  Oh well.
02:14:26 <kzm> But I digress.  When would you like to come to a garden party? :-)
02:14:39 <Itkovian> oh, August?
02:14:42 <kzm> (Bring working clothes, and if you come from abroad, bring beer as well)
02:14:45 <kzm> :-)
02:14:59 <kzm> (I get the keys in September)
02:15:01 <Itkovian> should I bring tools as well?
02:15:05 <Itkovian> ah, bummer
02:15:09 <kzm> That'd be nice.
02:15:28 <boegel> kzm: if you pay for the place ticket, tomorrow !
02:15:50 * boegel leaves to fetch some Chinese
02:16:05 <kzm> I probably *am* going to have to pay for a lot of the work, so if you're relatively skilled and the ticket isn't too expensive, that is an option :-)
02:16:49 <kzm> I'll have to talk to an architect or builder first, though, to see what my options are.
02:20:15 <kprime> H'm... quiet this morning...
02:21:18 * xerox bangs some explosives
02:22:22 <kprime> I've just been trying to teach myself Haskell, and have encountered some odd behaviour in Hugs...
02:22:53 <xerox> What exactly?
02:23:57 <kprime> Well, you can find all the code I'm talking about at http://www.horizon.com/primes.hs...
02:24:04 <kzm> kprime, what platform?  If you have enough CPU horsepower, GHCi is also nice, and sometimes give better error messages.
02:24:11 <kprime> I was just writing variants on the sieve of Eratosthenes.
02:24:31 <kprime> Linux-x86, Debian, 466 MHz P-II.
02:24:39 <kzm> Should be sufficient.
02:24:51 <dons> or if you want to use a 2.5 ghz machine, you can use @plugs ;)
02:24:57 <Thu17732> can i have attributes with the same names but different types in UUAG
02:24:58 <Thu17732> ?
02:25:03 <kzm> Marcin recently posted some code to do that using STUArrays.  That's probably as efficient as it gets.
02:25:15 <kzm> On comp.lang.functional, I think.  Check google.
02:25:22 <kprime> What I'm wondering is if the problem is a bg in my code or a bug in Hugs.  Even if it works under GHCi, if my code's not portable, is that my bug,or not?
02:25:26 <xerox> kprime, it does compile on GHCi.
02:25:44 <xerox> (on Windows :-))
02:26:00 <kprime> I'll have a look at that.  As I said, this is just teachning myself HAskell, so it was a toy problem to try a few implementation ideas on.
02:26:12 <dons> I still don't know what the 'odd behaviour' is?
02:26:22 <xerox> By the way, what problem are you experiencing?
02:26:32 <kprime> Okay... do you want to get the code off the web, or shall I spam it here.
02:26:51 <kprime> Problem: code outputs [2  CONTROL STACK OVERFLOW.
02:26:51 <dons> the code form the url you posted?
02:27:03 <kprime> Expected output is [2, 3, 5, 7, 11, 13, 17, ...]
02:27:05 <dons> oh, so there's a space leak
02:27:21 <dons> how do we reproduce this behaviour?
02:27:24 <kprime> Is that what control stack overflow does?  GHCI just hangs.
02:27:52 <kprime> dons: load the code.  Try to evaluate either p6a or p6b.  p6c works.  I don't know why it makes a difference.
02:28:01 <Itkovian> kzm: I can do the electricity :-)
02:28:07 <dons> *Main> p6a
02:28:07 <dons> [2^CInterrupted.
02:28:14 <dons> looks like a space leak to me ;)
02:28:16 <kzm> Itkovian, you're hired!
02:28:17 <xerox> [2*** Exception: <<loop>>
02:28:17 <kprime> Was that GHCI or Hugs?
02:28:18 <ski> Thu17732 : would guess not. but not sure
02:28:19 <kzm> :-)
02:28:36 <xerox> *Main> p6b
02:28:36 <xerox> [2,3*** Exception: <<loop>>
02:28:50 <kprime> But look at the source for p6a vs. p6c.  Damn near no difference.
02:28:57 <kzm> Itkovian, (You need to be authorized (not sure exactly by whom).  Otherwise I'll get nothing from the insurance when the house burns down)
02:29:18 <wli> try primes = 2:3:5:[p|p<-[7,9..], all (\q -> p `mod` q /= 0) (takeWhile (\q -> q^2 <= p) primes)]
02:29:30 <Thu17732> ski, turns out yes
02:29:40 <kzm> And maybe you can help me out on my Haskell projects as well?  Perhaps I could get my job to pay for your visit? :-)
02:29:43 <Itkovian> hmm ... over here they come and verify it ...
02:29:44 <Itkovian> buggers
02:30:39 <kzm> Itkovian, yes, that's a possibility, at least for straightforward stuff.
02:31:03 <Itkovian> well, i did all the stuff in my house, so ...
02:31:25 <dons> when compiled, p6a generates a loop:
02:31:26 <dons> paprika$ ./a.out
02:31:27 <dons> a.out: <<loop>>
02:31:34 <kprime> wli: <snipped> Okay, after deleting the + my IRC client inserted at the line-wrap (confusing), that works, but let me figure out how...
02:32:00 <kprime> dons: I'm trying to understand why.  It looks to me like it should work...
02:32:26 <dons> and p6b too.
02:32:31 <dons> p6c is ok.
02:32:32 <wli> What's p6a?
02:32:55 <dons> in the above url
02:32:57 <kprime> My code I'm trying to understand the misbehaviour of.  http://www.horizon.com/primes.hs
02:33:24 <kprime> p6a = 2 : mergeNot [3..] (foldr1 merge1 $ map (\p -> [p^2,p^2+p..]) p6a)
02:33:39 <kprime> ... but you have to look in the file for the definitions of "mergeNot" and "merge1".
02:34:30 <wli> ah, you're trying to do a more literal sieve of eratosthenes
02:35:06 <kprime> Both take ordered lists, and perform a merge operation.  mergeNot a b produces "a-b", all elements of a that do not appear in b.  merge produces "a union b".  merge1 takes the first element of a before even looking at b, because the caller knows that (head a) < (head b) by construction.
02:35:24 <xerox> merge1 = (++) ?
02:35:51 <ski> mergeNot assumes no repetition in the input lists, yes ?
02:36:43 <kprime> Yes, they all do.  I could eliminate that assumption, but it wasn't needed.
02:37:17 <kprime> Basically, they assume that, for every tail of the list, (head x) < (head $ tail x).
02:37:52 <kprime> What I'm trying to understand is *why* they go into infinite loops.
02:38:12 <kprime> There are basically two parts, as seen in the p5 code.  A list of composite numbers:
02:38:57 <kprime> Er... let me present in a different order.  The primes are defined in terms of the composites simply:
02:39:10 <kprime> p5 = 2 : mergeNot [3..] composites
02:39:32 <kprime> (Although I could use "2 : mergeNot [3,5..] composites" for more efficiency.)
02:39:50 <kprime> And then the composites are defined in terms of the list of primes...
02:39:57 <kprime> composites = foldr1 merge1 $ map (\p -> [p^2,p^2+p..]) p5
02:40:19 <kprime> Now, I can ask for "foldr1 merge1 $ map (\p -> [p^2,p^2+p..]) [2,undefined]"
02:41:19 <kprime> and get [4 before the exception kicks in.  If I start with [2,3,undefined], I get [4,6,8,9 before the exception.
02:41:44 <kprime> Now, 2 : mergeNot [3..] [4,undefined]
02:41:54 <kprime> produces [2,3 before the exception.
02:42:13 <kprime> As I said, foldr1 merge1 $ map (\p -> [p^2,p^2+p..]) [2,3,undefined]
02:42:25 <kprime> produces [4,6,8,9
02:42:48 <kprime> and if I feed [4,6,8,9,undefined] as the prime list to the composites function...
02:43:29 <kprime> 2 : mergeNot [3..] [4,6,8,9,undefined]
02:43:42 <kprime> I get [2,3,5,7,undefined]
02:44:46 <kprime> and so on.  It looks to me like everything should be able to get started with only the one "seed" value of 2.  I'm not sure why I need 2, and I'm *really* not sure why I need 3.  Not understanding *why* my code doesn't work means that I'm not understanding something...
02:46:57 <kprime> For example, the version wli gave me can be abbreviated to just have a single seed value:
02:47:05 <kprime> p7a = 2:[p|p<-[3,5..], all (\q -> p `mod` q /= 0) (takeWhile (\q -> q^2 <= p) p7a)]
02:47:38 <kprime> Although it could be optimized a bit as long as we're skipping even numbers:
02:47:41 <shapr> @yow !
02:47:44 <lambdabot> BARRY ... That was the most HEART-WARMING rendition of "I DID IT
02:47:44 <lambdabot> MY
02:47:44 <lambdabot> WAY" I've ever heard!!
02:47:49 <xerox> hiya shapr :)
02:48:04 <kprime> p7b = 2:3:[p|p<-[5,7..],  all (\q -> p `mod` q /= 0) (takeWhile (\q -> q^2 <=
02:48:19 <kprime> +p) (tail p7b)]
02:49:28 <swiert> shapr: I got your e-mail, I should really finish my article up. It's been dragging for far too long.
02:49:50 <shapr> swiert: Yes please finish it!
02:49:52 <Itkovian> hi shapr
02:49:57 <shapr> hoi Itkovian
02:50:48 <swiert> shapr: on a completely different note - do you know any category theory?
02:51:06 <shapr> Only what I've picked up here and a little bit from a CT book.
02:51:22 <Thu17732> Set.fromList foo `Set.union` fooset ....VS.... foldr Set.insert fooset foo
02:51:22 <Thu17732> ??
02:51:37 <swiert> well, I've been thinking recently about formulating the theory of patches in ct
02:51:44 <swiert> I thought you might be interested.
02:51:54 <xerox> Thu17732, what's the question?
02:52:00 <Thu17732> which one is the preferred one
02:52:17 <shapr> Yes, I'd definitely be interested in that.
02:52:54 <xerox> @docs Data.Set
02:52:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Set.html
02:52:57 <Itkovian> Thu17732: I'd go for the second
02:53:02 <swiert> I talked about it the other day at the nottingham FP lunch - check out http://sneezy.cs.nott.ac.uk/fplunch/?p=4
02:53:59 <Thu17732> Itkovian, one the basis of style or performance?
02:54:00 <xerox> Set.insert is O(log n), Set.fromList is O(n*log n), Set.union is O(n+m).
02:54:07 <Itkovian> style :-)
02:54:53 <shapr> Have you seen the new patch theory slowly happening on the conflicts list?
02:55:37 <swiert> no- I haven't. Have you got any links?
02:56:38 <shapr> Lemme find the mailing list page...
02:56:55 <shapr> http://www.abridgegame.org/mailman/listinfo/darcs-conflicts
02:58:07 <Thu17732> are there any people here that would prefer cvs/svn above darcs?
02:58:31 <Thu17732> s/above/over/
02:58:40 <ndm> Thu17732: yep, me - I prefer CVS because of www.tortoisecvs.org
02:58:46 <swiert> shapr: thanks - I'll look into it.
02:58:53 <shapr> ndm: Have you tried darcs?
02:58:57 * ski omgs .. thunderstorm
02:59:04 <ndm> i now have a darcs repository available
02:59:13 <ndm> and have skirted near the edges of darcs, but not properly, no
02:59:18 <Thu17732> ah yes, i knew ndm preferred it
02:59:27 <Thu17732> the 'windows' disciple :P
02:59:43 <shapr> Everyone gets to make their own choices :-)
03:00:08 <shapr> Otherwise the world would be boring.
03:00:09 <ndm> from what i have seen, darcs is more theoretically pure
03:00:22 <musasabi> morning
03:00:23 <ndm> and seems more designed around the open source/real world model
03:00:25 <shapr> I just think darcs is easier to use.
03:00:29 <shapr> heippa hei musasabi
03:01:03 <xerox> darcs-conflicts isn't available trough gmane, hmpf.
03:01:29 <shapr> You could ask David if you could subscribe it to gmane.
03:01:39 <shapr> Or the other way around, I guess.
03:01:51 <wli> kprime: Trial division is a poor method of primality detection, but is the easiest to code.
03:02:16 <kprime> wli: Um, if you want all primes up to a bound, isn't it pretty much optimal?
03:02:30 <wli> kprime: Atkins-Bernstein sieves are certainly improvements.
03:02:32 <xerox> shapr, is David available on IRC under some nickname?
03:02:47 <kprime> Imperatively, you just set up a bit array and clear every pth bit...
03:02:50 <shapr> He's usually droundy when he's on irc.
03:03:03 <musasabi> Are there any languages with purposefully turing complete type system? (want to look at existing designs)
03:03:19 <kprime> That's what I was trying to reflect with my "merge" functions.  They avoid doing any actual division...
03:03:36 <wli> musasabi: Wild guesses from me would be Cayenne and coq.
03:03:43 <kprime> musasabi: I don't know if it's a type system, exactly, but C++'s templates are known Turing-equivalent.
03:04:10 <musasabi> kprime: yes, but they are not exactly good design ;)
03:04:19 <musasabi> wli: thanks have to look those up.
03:04:33 <kprime> Agreed, C++ is a horrible mess.
03:04:35 <wli> Cayenne is Augustsson, coq is INRIA.
03:04:36 <shapr> swiert: So, you think you can finish your article by the end of the month?
03:04:36 <michaelw> musasabi: Qi as well, IIRC
03:05:10 <swiert> shapr: I'll try.
03:05:14 <shapr> Ok
03:05:25 <shapr> I'm especially interested in how AGs compare to arrows.
03:05:28 <swiert> it should be feasible - I just have to put my mind to it.
03:05:37 <kprime> wli: Anyway, for generating *small* primes, do you know a better technique?  Even for large ones, trial division by a few thousand small primes is suggested before a Fermat test or the like.
03:05:49 <shapr> Have you seen the ArrowsIntroduction I'm writing?
03:06:03 <shapr> (Not that I've done anything the last few days)
03:07:14 <wli> kprime: gcd with products of primes seems to reduce operation counts but is a bit more complex to code
03:07:50 <dcoutts_> ndm, I've been using your hi2hoo code, thanks a lot. I've got it now doing reasonalby good listings of incompatible API changes between different version of the same module(s).
03:08:04 <wli> kprime: usually step 1 is avoiding even generating things not coprime to the product of the first several primes (2*3*5 is most popular)
03:08:14 <ndm> its kind of in flux
03:08:27 <kprime> wli: Yes, that is a standard optimization.  It's basically batching the prime numbers.  Still, even there, you often batch the first 10 primes, then 11..100, then 101..1000, or something.
03:08:27 <ndm> the text format between GHC 6.2 and 6.4 is quite different...
03:08:39 <swiert> shapr: I've seen it, but haven't had a good look.
03:08:54 <kprime> wli: Yes, because there are 8 possible rpime remainders mod 30, so it works well with a bitmap implementation...
03:09:14 <dcoutts_> ndm, one thing that would make it better is if it were possible to detect which functions exported from a module are 'real' and which are just a figment of the optimiser's imagination
03:09:22 <ndm> dcoutts_, it used to target 6.2, but I'm working to upgrade it to 6.4
03:09:42 <dcoutts_> ndm, actually that doesn't matter too much, I'm using 6.4 for both versions of the same module
03:09:43 <ndm> dcoutts_, it should drop most of the optimisation ones
03:10:03 <ndm> in GHC 6.4 there is a textual difference between them, in 6.2 there isn't
03:10:11 <dcoutts_> ndm, right, it would be nice to drop the optimisations ones, I get lots of lvl{num} and other similar things
03:10:17 <ndm> i.e. compare is really exported, compare4 is not - but they appear identical
03:10:28 <ndm> it drops ==2, because it knows that is not a valid name
03:10:33 <ndm> but for functions, it has to be safe
03:10:38 <wli> kprime: not quite, more like 11
03:10:46 <wli> well
03:10:48 <wli> no
03:11:04 <wli> 11 for the first
03:11:06 <ndm> the one i am working on targeting 6.4 should do that - I think they start with $ if they are optimised versions
03:11:19 <dcoutts_> oh, right. so do I need an updated version of the code? 'coz the version I'm using (from a few days ago) gives lots of optimiation exports
03:11:34 <dcoutts_> and that's using ghc 6.4
03:11:36 <kprime> wli: Obviously, if you avoid generating multiples of 2, 3, and 5, you have to supply those separately...
03:12:05 <bourbaki> moin
03:12:14 <wli> 2,3,5,7 gives 48 residues
03:12:55 <vegai> in what way are Arrows "more general" than Monads?
03:13:06 <dcoutts_> ndm, I could probably make it into a generally useful tool if we can identify and ignore the optimisation exports
03:13:19 <kprime> wli: Which is enough to be a bit awkward, IMHO.
03:13:23 <ski> vegai : instance Monad m => Arrow (Kleisli m)
03:13:31 <dcoutts_> it's pretty useful to get a listing of the API differences between versions of a module
03:13:39 <ndm> dcoutts, yeah, i'll give you a copy of the 6.4 one when i get back
03:13:45 <ndm> should be about 20 mins, have to run, bye
03:13:46 <dcoutts_> ndm, cool, thanks
03:13:47 <wli> depends, groups of 6 bytes are not so difficult to deal with
03:13:55 <kprime> wli: The 8 residues mod 30 let you have an outer loop iterating over them, and the inner loop merges a 1-bit mask into every pth byte of the bitmap.
03:13:59 <vegai> ski: right, ok
03:14:10 <vegai> where was that other wiki then...
03:14:15 <vegai> the one that is not hawiki
03:14:22 <ski> tmrwiki ?
03:14:36 <vegai> yes, that's the one. Thanks
03:15:01 <wli> 2,3,5,7,11 give 480 bits or 15B
03:15:13 <kprime> wli: When you have irregular steps between the residues, you have to solve the "where do I start clearing bits" question for each one, and that's a time cost.
03:15:29 <xerox> ski, what does "Kleisli" mean, by the way? :)
03:15:38 <ski> um
03:15:54 <ski> iirc it comes from a person named kleisli
03:16:13 <wli> kprime: this is not as large an issue as it sounds
03:19:11 <wli> (esp. not in Haskell)
03:19:11 <kprime> wli: Maybe, but all you gain going from mod 30 to mod 2310 is 26.6% to 20.7%, 77.9% of the work.
03:20:06 <wli> kprime: if you're doing trial division and just generating them from arithmetic progressions...
03:20:23 <kprime> wli: So you have to not slow down you inner loop by more than the inverse of that ratio.
03:21:26 <kprime> wli: I need to understand wht you mean by "trial division".  Generally, any sieve is a way to *avoid* the division by strength reducing it.
03:22:50 <kprime> Still, it's logically equivalent to trial division, so some people call it that.  Even though the actual divide has been optimized way.
03:23:04 <kprime> I'm just wondering which nomenclature convention you're following.
03:24:02 <wli> trial division == performing a division to check whether one number is a divisor of another
03:25:02 <kprime> wli: Okay, so a properly implemented sieve does ZERO trial division.
03:26:15 <wli> depends
03:26:39 <kprime> wli: Well, for the standard small-prime-enumerator.
03:26:40 <kprime> wli
03:27:33 <kprime> wli: If you're finding possible primes between 2^1023 and 2^1024, you need to do one divide to find a remainder to tell you where to start your stride-p array walking.
03:29:53 <wli> Eratosthenes -like methods are not very good for that.
03:31:18 <kprime> wli: Er, what do you mean?  Every large prime finder I've ever seem starts with a sieve like that.
03:31:26 <kprime> s/seem/seen
03:32:05 <wli> IIRC it's to reduce the search space
03:32:49 <kprime> wli: The problem is, there's a huge effort jump between the small *fraction* of a trial division needed to do sieve by small factor, and the time to do a Fermat test.
03:33:03 <wli> anyway when you are heavily space constrained the extra 6% can matter
03:33:43 <kprime> wli: Really?  I just break the sieve into pages, and do one page at a time.  That's standard.
03:33:48 <jaro> hi there. Trying to use hat debugger, but I didn't yet manage to compile my code for hat. How can I do that? Expected nhc98 -T file.hs, however this fails because of some missing libraries.
03:34:52 <wli> kprime: depends a lot
03:37:11 <kprime> Depending on the parameters, you can even avoid doing a divide when you start a new page.   If you can afford to store an array of all the primes and (start mod p) values for each of them, you can restart the array walking when starting a new page.  I usually find computing the mod explicitly is worth the space saving, but some processors have really slow divides.
03:38:09 <wli> Storing an array of all the primes wasn't practical for what I did.
03:38:28 <kprime> Anyway, there are 6542 primes < 65536.  So if you're willing to live with that sieving limit, it takes 26168 bytes to store all that.
03:39:09 <kprime> Um, you *have* to store all the primes you're sieving bym at least implicitly.  You can *generate* small primes up to the square of that limit, of course.
03:40:57 <wli> I mostly looked for prime quadruplets.
03:42:00 <kprime> That is, primes of the form (p, p+k1, p+k2, p+k3)?
03:42:41 <wli> No, 4 primes congruent to 11,13,17,19 mod 30
03:43:11 <wli> i.e. k s.t. 30*k+11,30*k+13,30*k+17,30*k+19 are all prime
03:43:20 <kprime> With any sort of prime search, you usually use a sieving technique to generate candidates which are then subject to a stricter test.
03:43:52 <kprime> Okay, so (p, p+2, p+6, p+8), with the additional constraint that p `mod` 30 == 11.
03:44:19 <wli> kprime: that constraint turns out to be inherent
03:44:33 <kprime> Yes, I was just thinking that.  Still, it's a good way to optimize the search.
03:50:48 <kprime> Anyway, still no ideas as to why my merge-based sieves don't work, anyone?
03:51:07 <Itkovian> 'noon
03:51:07 <kprime> wli: I tried a merge-based variant of your code:
03:51:14 <Itkovian> man it is hot ...
03:52:07 <kprime> p9 = let { pStep :: [Integer] -> [Integer] ; pStep (p:ps) = p : pStep (mergeNot ps [p^2,p^2+p..]) } in pstep [2..]
03:52:17 <kprime> And that hangs, too!  Very annoying.
03:52:55 <Itkovian> kprime: what does pstep do?
03:53:14 <kprime> mergeNot *seems* too simple to have errors:
03:53:15 <kprime> mergeNot :: Ord a => [a] -> [a] -> [a]
03:53:15 <kprime> mergeNot a [] = a
03:53:15 <kprime> mergeNot [] _ = []
03:53:15 <kprime> mergeNot a@(ah:at) b@(bh:bt)
03:53:15 <kprime>         | ah < bh  = ah : mergeNot at b
03:53:17 <kprime>         | ah == bh =      mergeNot at bt
03:53:19 <kprime>         | ah > bh  =      mergeNot a  bt
03:53:38 <Itkovian> kprime: if you paste that much code, please use the wiki paste page
03:53:49 <kprime> Itkovian: Given a list of numbers (p:ps) it returns p, followed by ps with all multiples of p removed.
03:54:13 <kprime> An alternative implementation (which works) is  pStep (p:ps) = p : pStep (filter (\n -> n `mod` p /= 0) ps)
03:54:38 <kprime> By using a merge with an arithmetic series, I'm trying to eliminate the division.
03:58:12 <Itkovian> kprime: so how exactly do you remove those in pstep?
03:59:04 <kprime> Itkovian: "mergeNot" takes two sorted lists (all (zipWith (<) l (tail l))
03:59:23 <kprime> and returns the first with the elements of the second deleted.
03:59:55 <kprime> So I just generate a list of multiples of p and subtract it from ps.
04:00:28 <kprime> IT turns out that I can start with the first multiple p^2, because anything lower will have a smaller factor and have already been deleted.
04:03:15 <kprime> Itkovian: Sorry for the spam; I didn't know about the wiki page.  You can also get it from http://www.horizon.com/primes.hs.
04:04:44 <michaelw> kprime: unit tests on mergeNot will probably reveal the problem
04:05:19 <michaelw> hmm, maybe not
04:05:36 <ski> kprime : btw, why not use compare instead of (<),(==),(>) ?
04:05:48 <ski> @type compare
04:05:55 <lambdabot> compare :: forall a. (Ord a) => a -> a -> Ordering
04:06:14 <ski> data Ordering = LT | EQ | GT
04:06:16 <Itkovian> ski: is that more efficient?
04:06:21 <kprime> Ah, so do a "case compare ah bh"?
04:06:22 <ski> it can be
04:06:37 <ski> depends on the Ord instance for the particular type
04:06:42 <ski> yea
04:07:03 <ski> it's as easy to read, also
04:08:16 <Itkovian> kprime: so you're using the root of the webserver to upload yr toy stuff? ;-)
04:08:24 <Itkovian> ski: that's true
04:09:05 <Itkovian> ski: but to generate the LT, EQ, GT it will still to make at least one, sometimes two comparisons
04:09:07 <kprime> sli: There is the annoying fact that the "LT" is textually separated from the code that defines *what* is being compared.
04:09:39 <kprime> Itkovian: Depends on the type.  A large Integer can save a lot.
04:10:24 <Itkovian> kprime: I do not understand that first remark ...
04:11:13 <michaelw> kprime: what was wrong again with p9?
04:11:35 <kprime> If I'm comparing a 1024-bit Integer, all comparisons start by searching for a word that's different between the two.  If that's the most significant different word, you can then decide LT, EQ< or GT by just looking at that one word.
04:11:37 <ndm> dcoutts_, can i ask a couple of questions about your interface comparer
04:11:48 <ndm> so i can see what changes hi2hoo will need
04:12:26 <kprime> michaelw: Er... huh!  I *thought* it didn't work... why does it work now?
04:12:38 <michaelw> aha :)
04:12:41 <kprime> michaelw: It's p6a and p6b I'm really confused about.
04:12:59 <Itkovian> kprime: i wasn't even referring to Integers, but to simple Ints
04:13:46 <kprime> Itkovian: For plain Ints, it's indeed a net loss.
04:13:57 <Itkovian> for compare to determine if it should return LT, EQ or GT, it needs on average 1.5 comparisons.
04:16:29 <kprime> michaelw: p6c *works*, in both Hugs and GHCi.  p6a and p6b do not.  But I can step through p6a "by hand" and show that it should work...
04:17:24 <kprime> michaelw: p5 may be easier to understand.  It also doesn't work, and it's easier to read broken up like that.
04:19:48 <kprime> Ooh, I just figured out "#if 0" / "#else" / "#endif" in HAskell..
04:20:01 <kprime> {-
04:20:02 <kprime> code
04:20:04 <kprime> {- -}
04:20:05 <kprime> code
04:20:22 <kprime> Er... wait... that doesn't work.  Let me try a little harder..
04:20:24 <xerox> -- comments the rest of the line
04:20:33 <xerox> {- comments until -}
04:20:40 <xerox> (i.e. multiline comments)
04:21:47 <kprime> xerox: It's the "#else" I was trying to achieve.  Some magic "start a comment if not in a comment, but end one and start normal code otherwise".
04:22:28 <kprime> For example, "-- -}" can serve as #endif.  Inside {-, -- is ignored, so it sees the -}, but in normal code, the -} is commented out.
04:22:37 <xerox> I think GHC supports #pragmas, using the command line option -cpp
04:23:03 <kprime> It's the #else, the state-flip in the middle, that's a bit tricky...
04:24:02 <kprime> Aah, I think this will work (have to check the grammar):
04:24:05 <kprime> -- {-
04:24:06 <kprime> -}
04:24:48 <kprime> Er, no, that's backwards.  End a comment if *not* in a comment to start...
04:24:54 <kprime> Oh, right...
04:24:56 <kprime> -- {-
04:24:57 <kprime> -}
04:25:16 <kprime> Typo...
04:27:14 <wli> looks like he's using quadratics in Z[t] where t is a root of unity.
04:28:48 <kprime> wli: Are you taking about the Atkin & Bernstein paper?  Or something else?
04:29:02 <wli> Atkin-Bernstein sieve yes.
04:30:40 <wli> kprime: looks like it's primes that ramify in Z[t] etc.
04:31:11 <kprime> I have to admit I'm not sure what "ramify" means.  Or "reify", for that matter...
04:31:23 <dcoutts_> ndm, re: questions about interface comparer: yes, of course, ask away
04:32:12 <wli> kprime: A prime ramifies in a unique factorization domain containing Z if it's not prime in that UFD.
04:32:14 <dcoutts_> ndm, I can send you what changes I made to your hi2hoo code + the shell script I use to put it all together
04:35:29 <kprime> wli: I understand your definition of ramify, thanks, but I still don't get "it's primes that ramify in Z[t], etc.".  I mean, by your definition, non-primes can't ramify, so the first part is pretty obvious, and the "etc." is unclear.
04:36:10 <wli> kprime: primes in Z becoming non-primes in Z[t]
04:36:39 <wli> e.g. 5 ramifies in Z[i] because 5 = 2^2+1^2 = (2+i)*(2-i)
04:37:20 <kprime> wli: Clear enough.  For those following along, you can define "prime" in just about any structure, but in something like the rationals, there *are* no primes, because everything's divisible.
04:37:51 <kprime> Basically, as you "add more" to the integers, you "find" more factorizations, and primes disappear.
04:37:59 <wli> kprime: that has to do with units
04:38:27 <wli> kprime: where primality matters, not every number is a unit
04:38:52 <kprime> wli: In the rationals, everything degenerates into a unit.  Which makes primality boring.  It was just a quick description.
04:39:43 <kprime> wli: I was just looking for a limiting case where there are no primes.  Maybe there's one where there are a finite number?  I've never tried to extent the infinitude proof.  Anyway, it doesn't matter.
04:39:50 <wli> kprime: well, ramification is just the phenomenon where a prime in the integers ceases to be prime in an extension of the integers
04:41:14 <wli> kprime: if the gcd works then (p, p+1) are coprime
04:41:32 <wli> kprime: it really has to do with the gcd working
04:42:24 <kprime> Okay, but anyway, you said " looks like it's primes that ramify in Z[t] etc.".
04:42:53 <wli> kprime: if primes are finite, take their product, add 1, gcd says they're coprime, implying the existence of more primes
04:42:57 <kprime> What other than primes *could* ramify?  By your definition, only primes are eligible.  So I could leave the "in Z[t]" part off...
04:43:36 <wli> kprime: Z[t] is important because they're varying t (the thing by which Z is extended) and so on
04:43:58 <kprime> wli: Ah, right, thanks.  Anyway, it was an idle thought.  As I said, I was just searching for a limiting example where primes go away, even if it was trivial.
04:44:34 <kprime> wli: Can you give me an example of something in which non-primes ramify?
04:45:01 <kprime> If there is no such thing, the statement "it's primes that ramify" seems vacuous.
04:45:06 <kprime> Oh!
04:45:08 <wli> kprime: Generally composites aren't considered. They're already composite to begin with.
04:45:53 <kprime> Right.  They're already dead, and can't be killed any deader.
04:45:57 <wli> kprime: Ramification is the behavior where a prime becomes composite in an extension. There isn't much to go on.
04:46:19 <kprime> So "It is primes that ramify" is inherent in the definition of ramification.
04:46:30 <wli> kprimes: Yes.
04:46:38 <kprime> You can't ramify a non-prime, so yes, trivially, "it is primes that ramify".
04:47:04 <kprime> Which is why your statement was confusing to me.
04:48:27 <kprime> Like "it is men that have Y chromosomes".  Modern medicine and hormone therapy apart, that's kind of by definition...
04:49:54 <kprime> Were you trying to say "he's looking at primes that ramify in Z[t], and has managed to produce three cases that cover all primes in Z"?
04:51:26 <wli> kprimes: No idea. The trivial observation has long-since been dwarfed by repeating the definition of "ramify" to where I no longer remember it.
04:56:14 <kprime> foldr1 merge1 $ map (\p -> [p^2,p^2+p..]) [2,undefined]
04:56:41 <Itkovian> men are defined by genotype NOT by fenotype ... so transsexuals are by def not male
05:00:59 <wli> generalizing it loses some of he obvious connections to the extension
05:01:37 <wli> a*x^2+b*x*y+c*y^2 seems to need to be irreducible over Z but to split over Z[t]
05:02:44 * boegel bounces
05:09:23 <kprime> ski figured out my problem.  Not an obvious solution.
05:09:29 <kprime> Basically, foldr1 is too eager.
05:09:47 <kprime> Rewriting as
05:09:48 <kprime> p6a = 2 : mergeNot [3..] (foldr merge1 undefined $ map (\p -> [p^2,p^2+p..]) p6a)
05:10:09 <kprime> fixed the problem.  Notice that it's now "foldr" rather than "foldr1", with a base case of "undefined".
05:12:32 <Thu17732> Itkovian, shouldnt transpeoples be male by that definition.....since they are genotypically male right?
05:12:54 <kprime> Thu: It depends if you're thinking M2F or F2M...
05:12:59 <Itkovian> well, a girl can have her fenotype changed eh ... but she remains female
05:13:12 <Itkovian> i should have said 'gender is detrmined'
05:13:23 <Thu17732> trans is also just a feno change isnt it? or am i confused about the terminology here
05:13:28 <Philippa_> that's even more wrong than 'sex is determined'
05:13:59 <Philippa_> Thu17732: the part that changes is, sure. It's unsure whether or not there's a genetic element to it in the first place
05:14:04 <Itkovian> Philippa_: nope, gender is determined by the chromosones you carry, not by how you appear, duh.
05:14:13 <Philippa_> Itkovian: bullshit. Gender is *not* sex
05:14:23 <kprime> This is a non-terminating (bottom) argument.  It depends on what you mean by gender.  Many people would say it's socially defined, and so it's determined by how you interact.
05:14:26 <Itkovian> eh?
05:14:29 <wli> Itkovian: Klinefelter and Turner (to a lesser degree) syndromes pose issues for such.
05:14:30 <Philippa_> sex is the physical bit
05:14:48 <Itkovian> I stick to my idea.
05:14:54 <Philippa_> depending on how you like to define it, gender's somewhere between social and psychological
05:15:01 <Itkovian> call me old fashioned all you like
05:15:02 <Philippa_> fine. The entire medical community disagrees with you
05:15:02 <kprime> Philippa_ And a good surgeon can do wonders there.
05:15:17 <kprime> I should tell everyone my Christine story.
05:15:34 <Philippa_> as does the entire feminist movement, and many countries' legal systems
05:16:02 <Itkovian> I really don't give a damn. That doesn't mean I will treat those people are weirdos or anything, mind
05:16:25 <Philippa_> no, but it does mean you're enough of an arsehole to insist that your definitions of the words are right when /everybody/ else uses them differently
05:17:00 <Philippa_> wli: there're plenty of other such conditions, too...
05:17:03 <wli> By and large I follow Philippa's convention, though I generally consider it more a matter of expedience, convention, etc. than a resolution of the issues.
05:17:03 <kprime> Let's not go Humpty Dumpty.  As I said, the argument is about the definition of words, and it's non-terminating.
05:18:16 <Itkovian> Philippa_: well, let's say I don't really agree with the whole sex-change thing, tyhough I can understand people can feel unhappy with their gender/sex
05:18:20 <Philippa_> wli: there's an argument to be had that it'd be useful to have separate terms for female/male-gendered and female/male-sexed. OTOH, you'll rapidly run into people suggesting (on fairly reasonable grounds) that neither's a binary thing
05:18:23 <wli> Philippa: Well, he's trying to find unambiguous ground to stand on via genetics. Those are the 2 chromosomal conditions I'm aware of thatbreak the categorization.
05:18:25 <Itkovian> ah well, it doesn't matter
05:18:54 <kprime> Go read _Stone Butch Blues_ and try to define the protagonist's gender...
05:18:59 <Philippa_> Itkovian: do you understand that "unhappy" is a massive understatement, and that "30% suicide rate without treatment" is more accurate?
05:19:31 <Thu17732> case chromosome of Y -> male ; _ -> female
05:19:32 <Itkovian> Philippa_: Maybe, yes, but I think that's also due to society, not necessarily just due to the person's gender/sex ...
05:19:55 <wli> Thu17732: XXY
05:20:06 <Itkovian> besides, I don;t approve of suicide either, although some people seem to be desperate or tired or ...
05:20:24 <kprime> Philippa: I've found that it's just that people learned "boy vs. girl" before they learned to talk, and are unavoidably uncomfortable with having this foundation stone shifted.
05:20:25 <Philippa_> I think you'll find most people who commit suicide would prefer to've felt they had another option
05:20:38 <Itkovian> I agree there
05:20:46 <Philippa_> it's not really a matter of whether you approve. It's a case of it happening
05:21:06 <Itkovian> I know, I was just stating my opinion
05:21:12 <kprime> Philippa: It takes meeting some folks and having experience to get emotionaly comfotable with the idea.  No amount of skilled rhetoric or logic is going to deal with that discomfort.
05:21:39 <Philippa_> and society doesn't do a fuck of a lot for somebody feeling uncomfortable in their own body, unable to interact in the ways they feel the need to because they're not physically capable of it
05:21:42 <xs> people thought atoms were inseparable.
05:21:47 <Itkovian> I don't feel particularly uncomfy with transexuals, I just don't think that it defines the male/female thing
05:22:10 <Philippa_> again, gender or sex?
05:22:14 <Itkovian> Philippa_: society is fucked too, that's true
05:22:15 <kprime> In the meantime, you can be justifiably annoyed with someone for how they *act* to a person of "nonstandard gender", but it's not worth arguing about how they feel.
05:22:18 <Philippa_> I'll happily acknowledge that it doesn't define sex
05:22:40 <Philippa_> kprime: saying "your self-definition is invalid" is not a particularly nice way to act towards someone
05:22:45 <kprime> Someone feels how they feel, and changing that is phychoterapy, not logic.
05:22:50 <Itkovian> hmm, I think I have an issue understanding the subtleties in the terms
05:23:18 <Itkovian> Philippa_: part of the problem also lies in the expectancy society has of boys and girls
05:23:24 <Itkovian> e.g. no playing with dolls et.
05:23:33 <Philippa_> sure, and that doesn't just hit transpeople either
05:23:42 <Itkovian> I actually heard some guys say that their son would never be allowed to have a doll
05:23:52 <Philippa_> but even if able to do everything else they want, many people /still/ want to transition
05:23:54 <Itkovian> I mean, I was very happy with my dolls :-)
05:23:54 <kprime> Philippa: Yes, but sometimes it's true.  There's a fellow sitting in the white house whose self-image is "legitimate president of the U.S. and all-around Good Guy", which many people would vigorously dispute.
05:24:01 <Itkovian> and I am male
05:24:10 * boegel used to play with dolls too
05:24:15 <Itkovian> heh
05:24:17 <boegel> do you guys think that's a nerd thing ? :p
05:24:20 <Philippa_> I know a number of trans women who're more than a wee bit butch and like it that way
05:24:21 <Itkovian> lol
05:24:24 <dcoutts_> a friend who goes to one particular US college says that they have transexuals who are not comfortable with being defined as either sex, so the college has an official policy of using "ze" and "zim" instead of "he/she" "him/her"
05:24:34 <Itkovian> that's crap
05:24:39 <kprime> Boy's dolls are called "action figures", just so you all know.
05:24:52 <ndm> dcoutts, i have various changes already done but not yet checked in
05:24:52 <wli> Philippa: Unfortunately continuum models defy common experience due to rarity of cases outside the binary categories. People are going to want to gravitate back to common experience. Insert chunk-blowing reaction to popular opinion.
05:24:58 <Itkovian> erm, well, mine were girls dolls then, the real baby-like stuff
05:24:59 <boegel> kprime: I had those too, G.I. Joes !
05:25:02 <dcoutts_> ndm, ok, cool
05:25:09 <kprime> With six (seven?) billion people in the world, there are some *really* wierd corner cases.
05:25:14 * boegel used the Barbie doll, fully dressed even
05:25:15 <Itkovian> lol
05:25:22 <Itkovian> yuk, no barbies for me
05:25:29 <boegel> kprime: 6.5 probably
05:25:33 <Philippa_> wli: depends how you explain the continuum models. Most people buy the idea some people are more girly, womanly, boyish or manly than others
05:25:34 <wli> "hijra"
05:25:39 <ndm> the problem is GHC 6.2 has a different text output format from 6.4
05:25:40 <Itkovian> although the various states of undress eemd cool to a 10year old kid
05:25:54 <Itkovian> seemed that should've been
05:25:56 <ndm> any thoughts on what to do about that? demand one or the other? parse both?
05:26:06 <dcoutts_> ndm, right, I'm happy with just 6.4
05:26:24 <ndm> dcoutts, ok then - just 6.4 it is
05:26:24 <kprime> (I am telling my co-workers I am learning about functional programing here.  It's getting hard to say that with a straight face...)
05:26:34 <ndm> but i think the version you have is just 6.2?
05:26:46 <Philippa_> kprime: most places online have off-topic time
05:26:47 <dcoutts_> ndm, really? I've been using it with 6.4
05:27:06 <kprime> Philippa: I'm not complaining, don't worry.  Just laughing.
05:27:23 <wli> Philippa: Maybe broader understanding is possible. I'm not particularly good at devising arguments for common persons in any area (much less one I'm not really involved with) so perhaps I overestimate the obstacles.
05:27:31 <dcoutts_> ndm, did you have another Q about what i was doing or was it just the version of ghc I'm using?
05:27:33 <ndm> dcoutts_, depends exactly when you checked the source out
05:27:40 <dcoutts_> right
05:27:51 <ndm> dcoutts_, mainly GHC questions - i can guess about the rest
05:28:00 <dcoutts_> :-)
05:28:04 <ndm> dcoutts_, but if you have any changes, i'd love to see them
05:28:17 <SM_ax> what do you guys think of "The Craft of Functional Programming"? Is it a good book for FP newbie?
05:28:27 <kprime> As I said, for those who haven't read it, _Stone Butch Blues_ is a good book and quite enlightening.  It's a lightly fictionalized autobiography.
05:28:58 <kprime> Lots of interesting notes on pre-stonewall gay bars and the like.
05:29:38 <kprime> I had a shock when I met my first female drag *queen*.  Made sense, after it was explained to me, but...
05:29:47 * Philippa_ laughs
05:30:04 <Philippa_> yeah, that's about the only way you're ever going to catch me in a dress
05:30:19 <kprime> "Women don't wear those clothes, either."
05:30:27 <kprime> Can you guess what her day job was?
05:30:44 <Philippa_> fashion designer? builder?
05:30:53 <kprime> Wedding dress maker.
05:31:11 <kprime> About the only time women *do* dress like that...
05:31:15 <dcoutts_> ndm, it was mostly stripping out bits I didn't need (I only need functions at the moment) and retaining slightly more structure so I can have a map of function name to type.
05:31:17 <kprime> She put her skills to good use.
05:32:12 <ndm> dcoutts_, that sounds sensible - build a map of functions, classes, instances etc. then write them out at the end
05:32:13 <kprime> Yeah, I can vouch that my GF doesn't own any kind of skirt.
05:32:40 <Philippa_> I suspect the next one I buy won't be for wearing in public...
05:32:50 <kprime> Don't tease!
05:33:00 <Itkovian> dresses are cool.
05:33:07 <Itkovian> on women
05:33:08 <ski> (SM_ax : i learned from it. sufficiently good at least i guess)
05:33:10 <Philippa_> nah, you can't move in the damn things
05:33:21 <kprime> Doll : Action figure :: Dress : Kilt
05:33:22 <Itkovian> come on Philippa_ have you ever tried it?
05:33:37 <Itkovian> it looks great
05:33:47 <dcoutts_> ndm, right, then the rest of the code is probably specific to what I'm doing, sorting and merging the lists of functions to find the differences, and comparing types of functions (with alpha convertability of forall bound vars)
05:33:48 <Itkovian> and all women I know agree that it feels great too
05:33:53 <Philippa_> well yeah, but if I want that I could just not wear anything at all
05:33:59 <Itkovian> not for everyday use but still
05:34:10 <Itkovian> Philippa_: I won't stop you
05:34:26 <ndm> dcoutts_, ok - well i'll try and make it a slightly more common core
05:34:36 <Philippa_> bingo. I've no doubt I'll do it a couple of times in my life, and enjoy it once I've got everything looking okay and so forth. You're more likely to see me in a corset though
05:34:43 <kprime> Women definitely have advantages in flexibility of dress.  On the downside, they're expected to use that flexibility...
05:35:02 <dcoutts_> ndm, ok, in that case I'll use it as a libbrary module rathern than cut'n'paste :-)
05:35:05 <kprime> Ah, yes, the games one can play with a corset...
05:35:07 <Philippa_> I do. The last clothes I bought were meant for guys
05:35:22 <boegel> Philippa_: you don't the ideal figure to wear a dress, as long as you dont weigh 150kg
05:35:24 <kprime> I knoew a fellow who would torture corseted women with his out-of-this-world gelato.
05:35:38 <Philippa_> boegel: I know. I'm a somewhat odd shape though, which doesn't help
05:35:57 <boegel> Philippa_: I'm sure you just think you have an odd shape
05:35:59 <Itkovian> Philippa_: still ...
05:36:03 <boegel> and so what if you do ?
05:36:05 <Itkovian> all women do
05:36:09 <Itkovian> think that
05:36:11 <boegel> nobody's freakin' perfect
05:36:16 <Itkovian> at least three times a day
05:36:16 <Philippa_> boegel: so it's harder to find a dress that fits, is what
05:36:34 <Philippa_> really, I don't give a damn most of the time
05:36:34 <Itkovian> Philippa_: if my sis can wear dresses so can you
05:36:40 <boegel> Philippa_: define fits
05:36:49 <kprime> Any statement, describing people, of the form "all X are Y", can be assumed to be false before considering Y.
05:37:21 <Philippa_> boegel: "doesn't look really damn stupid on me, doesn't leave me looking like I've no breasts"
05:38:37 <boegel> Philippa_: a lot of girls don't have 'breasts', so what's wrong with that ?
05:38:58 <Philippa_> I'm a larger build than you usually see that on
05:39:11 <Philippa_> it just doesn't look overly good
05:39:38 * boegel wishes everyone shouldn't need to worry about their looks
05:39:44 <Philippa_> with the right top I could pass for male without having to bind
05:40:01 * Philippa_ wishes people wouldn't assume she's worrying about them just because she thinks it'd be hard to find a dress that'd look good on her
05:40:23 <Philippa_> now, I've friends who can do that too, but they're usually about half my size
05:42:06 <boegel> I don't look fantastic either, but I've learned not to give a shit
05:42:20 <Philippa_> yes, but what /else/ is the point in wearing a dress?
05:42:36 <Philippa_> the appeal is how it looks, how it feels because of how it looks
05:42:40 <wli> I'm not sure where this all comes from. I've mostly seen dresses as low-utilization components of a mostly-pants wardrobe amongst women.
05:42:59 <wli> (no British slang involved)
05:43:01 <Itkovian> yeah boegel but you've already have a gf ;-)
05:43:01 <Philippa_> yeah, in my case the utilisation'd tend towards nil :-)
05:43:11 <Philippa_> wli: it's not british /slang/
05:43:24 <boegel> Itkovian: I've had a few before too, but that didn't stop me to worry about it
05:43:29 <Itkovian> lol
05:43:51 <boegel> the other ones weren't that great as Joke though
05:44:07 <kzm> My daughter likes to wear dresses.
05:44:07 <boegel> no way near even
05:44:09 <Itkovian> obviously
05:44:19 <Philippa_> wli: dresses for casual wear just aren't me, essentially
05:44:29 <kzm> And, as she's the big idol for my son, so does he.
05:44:32 <Philippa_> actually, pretty much anything that'd prevent me from kicking someone in the head isn't me :-)
05:44:34 <Philippa_> cool
05:44:51 <kzm> :-)
05:45:56 <boegel> Philippa_: how does a dress prevent you of kicking someone in the head ? if your fast enough, he won't be able to see anything :p
05:46:09 <Philippa_> nonono, for that one you /knee/
05:46:29 <Philippa_> admittedly you aim to get your knee about as high as the /other/ head, there just happens to be something in the way...
05:46:54 <kprime> It depends on how full and long the dress is.  Pencil dress = no kicking.
05:47:43 <boegel> hey seidan, checked out the HRay patch already ?
05:48:01 <seidan> yeah.
05:48:11 <boegel> any comments ?
05:49:17 <wli> I have this vague notion which isn't really scientific or anything that things vaguely like what go on in insect colonies' parthogenesis etc. go on elsewhere to some degree, but are implemented behaviorally vs. phenotypically. Not worthwhile scientifically but the analogy makes me feel like I understand some of what goes on.
05:49:52 <seidan> well, I do have a more general quadraatic solver, as mentioned in the comments.
05:50:07 <seidan> er... quadratic
05:50:55 <boegel> comments ? where ?
05:51:24 <seidan> in the patch. something to the effect of "this needs to be a general solver"
05:51:47 <boegel> oh, haven't looked at it yet
05:52:05 <boegel> could you contribute that quadratic solver then ?
05:52:09 <wli> I've been meaning to do an elliptic integral solver.
05:52:10 <wli> er
05:52:20 <wli> I've been meaning to do an elliptic integral computation routine.
05:52:42 <wli> Most of the issues I got boned with had to do with simplifying expressions.
05:54:15 <seidan> sure. it's very simple, but it implements the recommended algorithm and handles all cases.
05:55:03 <boegel> seidan: cool
05:57:10 <wli> basically there's some p-adic algorithm for simplifying nested surds I choked while trying to write.
06:01:07 <wli> Probably overkill since quartics only need square and cube roots.
06:01:10 <Thu17732> surely there's a function (a,b) -> (b,a) ?? i thought i'd be swap
06:01:15 <Thu17732> @index swap
06:01:17 <lambdabot> bzzt
06:01:34 <xerox> swap = snd &&& fst
06:01:47 <Thu17732> indeed, i hoped swap was standard
06:01:48 <xerox> import Control.Arrow -- :)
06:01:52 <dcoutts_> \(a,b) -> (b,a)
06:01:57 <dcoutts_> it's not very long!
06:02:10 <wli> uncurry (flip (,))
06:02:14 <Thu17732> yeah i know, but still....swap looks better :D
06:02:29 <dcoutts_> and the implementation is probably a shorter and clearer description than any other name
06:02:31 <boegel> Thu17732: you can define it yourself then
06:03:00 <Thu17732> i know, but i hate defining functions that should be standard....that is my nr two annoyance factor with ocaml
06:03:25 <wli> uncurry (flip (,)) seems to do the trick for me.
06:04:04 <dcoutts_> Thu17732, but there is also the argument that things that are just so short should be leaft out since they just pollute the namespace
06:04:23 <TheHunter> @pl \(a,b) -> (b,a)
06:04:24 <lambdabot> uncurry (flip (,))
06:04:28 <Thu17732> dont they have modules to keep the pollution under control?
06:04:44 <Thu17732> swap would fit excellent in Data.Tuple
06:05:17 <wli> There are 5 analogues for triples.
06:05:24 <dcoutts_> yes, but it seems a lot of overhead for a 13 character implementation
06:05:29 <wli> 23 for quadruples.
06:05:37 <wli> 119 for quintuples... etc.
06:06:00 <dcoutts_> and as wli point out the names quickly become unmanageble, but each little implementation is still clear.
06:06:04 <TheHunter> there's no library support whatsoever for triples or higher tupels.
06:06:38 <wli> (,,,,) :: a -> b -> c -> d -> e -> (a, b, c, d, e)
06:06:45 <TheHunter> well, except that...
06:06:47 <wli> looks like there is to me. =)
06:06:54 <ski> and instances
06:06:59 <kprime> I have to agree that \(a,b) -> (b,a) is about as clear a "name" as could be asked for.
06:07:11 <dcoutts_> TheHunter, not quite true, there is zip/unzip and probably others I can't think of right now
06:07:17 <TheHunter> one might argue, that's no library support because (,,,,) is obviously not a function a user could define.
06:07:18 <boegel> @plugs (,,,,) 1 2 3 4 5
06:07:26 <lambdabot> (1,2,3,4,5)
06:07:29 <boegel> nice
06:07:32 <dcoutts_> @type unzip3
06:07:35 <lambdabot> unzip3 :: forall c b a. [(a, b, c)] -> ([a], [b], [c])
06:07:39 <dcoutts_> @type unzip7
06:07:41 <lambdabot> bzzt
06:07:44 <dcoutts_> @type unzip5
06:07:45 <lambdabot> bzzt
06:07:51 <wli> analogues of uncurry and flip would do the trick for me, except flip has the same combinatorial explosion issues.
06:08:12 <dcoutts_> @type List.unzip7
06:08:14 <lambdabot> List.unzip7 :: forall g f e d c b a.
06:08:14 <lambdabot>      [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])
06:08:22 <kprime> TheHunter: Well, I *could* define it as \a b c d e -> (a,b,c,d,e), but Haskell has the convention that *everything* is available in both prefix and infix forms, so...
06:08:24 <TheHunter> oh, i didn't think of unzip, but they're clearly exceptions.
06:09:11 <TheHunter> at least i'm pretty sure there's nothing good enough to do a pointless transform of \(x,y,z) -> x + y + z.
06:09:49 <Thu17732> a type would even suffice for the swap function :)
06:10:08 <boegel> @pl \(x,y,z) -> x+y+z
06:10:09 <lambdabot> (line 1, column 6):
06:10:09 <lambdabot> unexpected ","
06:10:09 <lambdabot> expecting letter or digit, operator or ")"
06:10:09 <lambdabot> ambiguous use of a non associative operator
06:10:25 <boegel> @pl \(x,y,z) -> (x+y+z)
06:10:26 <lambdabot> (line 1, column 6):
06:10:26 <lambdabot> unexpected ","
06:10:26 <lambdabot> expecting letter or digit, operator or ")"
06:10:26 <lambdabot> ambiguous use of a non associative operator
06:10:32 <wli> Thu17732: Not quite, types are pointed.
06:10:32 <boegel> meh ?
06:10:49 <boegel> @pl \(x,y) -> (x+y)
06:10:50 <ski> boegel : it doesn't really understand tuples
06:10:50 <lambdabot> uncurry (+)
06:10:54 <TheHunter> i agree with Thu17732, Data.Tuple would be a perfect place for a swap function.
06:10:58 <wli> \_ -> (undefined, undefined) :: (a,b)->(b,a)
06:11:00 <boegel> ski: oh okay
06:11:03 <Thu17732> wli, swap :: (a,b) -> (b,a) is enough for the function
06:11:18 <wli> Thu17732: see the above
06:11:21 <Thu17732> too late
06:11:49 <TheHunter> there's obviously only one total function of type (a,b) -> (b,a).
06:12:20 <wli> Thu17732: you didn't say total earlier... anyway, proof? =)
06:13:13 <Thu17732> left as an exercise to the reader :P
06:13:32 <wli> F
06:20:11 * Itkovian needs a cold shower
06:20:15 <Itkovian> for multiple reasons
06:20:18 <Itkovian> grin
06:20:21 <ski> (one total function, if not using e.g. unsafePerformIO)
06:20:54 <kprime> I never *did* quite understand how unsafePerformIO could violate tye safety.
06:21:18 <xerox> @index unsafePerformIO
06:21:18 <ski> more or less the same as in previous ML, i think
06:21:19 <lambdabot> System.IO.Unsafe, Foreign
06:21:28 <xerox> @type System.IO.Unsafe.unsafePerformIO
06:21:30 <lambdabot> System.IO.Unsafe.unsafePerformIO :: forall a. IO a -> a
06:21:33 <xerox> Gee.
06:22:02 <boegel> Itkovian: stop watching pr0n at work ! goddamned
06:22:19 <Itkovian> eh? prOn? where? what did I miss?
06:22:35 <boegel> you said you need a cold shower for _multiple_ reasons :)
06:22:37 <Itkovian> I am warm and I am sweating eh, you perverts
06:22:44 <boegel> that's one reason
06:22:54 <Itkovian> no, that's two :-)
06:23:04 <boegel> no, they are related, thus one reason :)
06:23:10 <Itkovian> hmm
06:23:17 <Itkovian> I need to wash my hair then
06:23:29 <boegel> weak :p
06:23:57 <ski> evilPolyRef :: IORef (Maybe a); evilPolyRef = unsafePerformIO (newIORef Nothing); unsafeCoerce :: a -> b; unsafeCoerce a = unsafePerformIO (do {writeIORef evilPolyRef (Just a); Just b <- readIORef evilPolyRef; return b})
06:24:02 <Itkovian> I was actually just waiting for Philippa to jump the remark
06:24:28 <Lemmih> [d| (.==.) = undefined |] doesn't generate valid code. *sigh*
06:24:30 * kprime is working on parsing ski's example...
06:24:53 <ski> kprime : just replace each ; with a newline (and indent inside the do-exor)
06:25:01 <ski> expr
06:25:04 <boegel> Itkovian: hehe
06:29:45 <kprime> ski: I've done that, and I'm reading up on the IORef functions.
06:30:20 <kprime> I guess what I don't understand is how the "Just b <- readIORef evilPolyRef" works.
06:31:18 <TheHunter> @type Data.IORef.newIORef
06:31:20 <kprime> I mean, if evilPolyRef contains a "Maybe a", then that can't be assigned to a "Just b" without at least checking that it's a Just, not a Nothing.
06:31:20 <lambdabot> Data.IORef.newIORef :: forall a. a -> IO (GHC.IOBase.IORef a)
06:31:35 <ski> kprime : evilPolyRef :: forall a. IORef a   which implies both  evilPolyRef :: IORef a  and evilPolyRef :: IORef b  for the particular types  a  and  b  in unsafeCoerce
06:32:04 <kprime> Yes, the light begins to dawn.
06:32:06 <ski> the pattern-matching would fail if there was a Nothing there, right
06:32:27 <ski> which would call 'fail' in the IO monad, which is 'error'
06:32:56 <TheHunter> so with unsafePerformIO, newIORef :: forall a. a -> IO (IORef a) and newIORef' :: a -> IO (forall a. IORef a) are the same thing, but the latter is unsafe since you can get out something of a different type than what you put in.
06:33:18 <kprime> unsafePerformIO lets you extract it from the do {} block, which is how you can break the "forall a" scope into two parts, and bind it twice.
06:35:02 <ski> hm
06:35:27 <ski> TheHunter : what do you mean by '.. are the same thing' ?
06:37:01 <TheHunter> i meant if we drop the IO using unsafePerformIO, both yield the same function.
06:37:02 * ski has some kind of idea that this is related to invariance of IORef ..
06:38:02 <ski> the first type would then be an instance of the second type
06:38:53 <kprime> If I really understood that, I might grok monads better.
06:39:07 <ski> i'm still not sure about .. 'the same function'
06:39:21 <kprime> Oh!  A question: I've found three different equivalent statements
06:39:33 <TheHunter> yeah, i expressed it wrongly.
06:40:20 <kprime> of the monad laws.  To help me understand them, I'm trying to illustrate them with a few different monads.
06:40:39 <kprime> Does anyone have a good pedagogical example of a Monad that is *not* a MonadPlus?
06:40:58 <TheHunter> what i meant to say is something like this. If you make the forgetful translation from a pure to an impure language by removing all occurrences of IO (eg. by using an unsafePerformIO function), the two functions newIORef and newIORef' that were distiguishable in the pure language aren't in the impure one any more.
06:41:20 <TheHunter> one of them is safe, the other one is unsafe.
06:41:21 <ski> kprime : 3 formulations of the same monadic laws ?  or of the (at least) 2 different sets of monadic laws ?
06:41:24 <kprime> Maybe, lists, and IO are all MonadPlus.
06:41:47 <TheHunter> well, first of all, the identity monad :)
06:41:57 <kprime> ski: There's on in terms of "bind", one in terms of "map", and one in terms of "monad comprehensions".
06:42:21 <ski> TheHunter : unpureNewIORef :: forall a. a -> IORef a          unpureNewIORef' :: a -> forall a. IORef a     not same type
06:42:23 <TheHunter> then, state, reader, continuation.
06:42:32 <kprime> The papers explaining them show how they're equivalent (you can derive the other two from any one)
06:43:07 <TheHunter> ski, oh, you're right.
06:43:16 <TheHunter> lemme fix that.
06:43:17 <ski> kprime : ok.  there are also 2 different sets ..  the other one uses fmap and join, but not (>>=)
06:43:38 <ski> kprime : State monad
06:44:18 <kprime> ski: That's what I meant.  I think in terms of equivalent axioms.
06:44:36 <ski> (kprime : hm, '.. one in terms of "map" ..' ?  which do you mean ?)
06:44:38 <TheHunter> make it |(forall a. a) -> (forall a. IO (IORef a))| and |newIORef' :: (forall a. a) -> IO (forall a. IORef a)|
06:44:48 <TheHunter> not that an impressive argument anymore...
06:45:02 <ski> :)
06:45:07 <kprime> ski: That's it, join and (f)map.  There's another paper (sorry, I don't have it close at hand) that illustrates a "monad comprehension"
06:46:13 <ski> kprime : but the join,fmap,return formulation is different from the one with bind, of which the comprehension one is syntactic sugar of
06:47:40 <kprime> ski: What do you mean?  I thought the papers said they were equivalent; you could express either one in terms of the other.
06:48:07 <kprime> I may have misunderstood, but that's what I thought it said.
06:48:09 <ski> TheHunter : in some sense, one possibly sane typing would be evilPolyRef :: IORef (forall a. Maybe a),  which would only allow storing Nothing (or bottom) in the ref
06:49:07 <ski> kprime : yes they are equivalent in power. just that the comprehension one is (or at least can be seen as) syntactic sugar for the bind one  (just as the do-expr syntax is)
06:49:58 <kprime> ski: which is exactly what you did, at creation time.  But because you managed to have a side-effect on an object outside the do{} block, you managed to use it as a "Just a" the first time, and as a "Just b" the second.
06:51:24 <TheHunter> ski, i'm beginning to think that's not even unsafePerformIO's fault.
06:52:43 <kprime> ski: Yes, that's a much less obscure mapping.
06:52:44 <ski> kprime : ?
06:52:59 <ski> kprime : what is exactly what i did at creation time ?
06:53:27 <kprime> ski: evilPolyRef = unsafePerformIO (newIORef Nothing)
06:53:54 <kprime> You created an "all-types" IO (IORef a) by using "Nothing".
06:54:20 <ski> brb
07:32:49 * ski managed to snatch the computer back
07:34:21 <ski> kprime : yeah, but that's not what i meant with "in some sense, ..."
07:35:27 <ski> in actual haskell, type of evilPolyRef gets generalized to  forall a. IORef (Maybe a)
07:36:36 <ski> i was considering the different typing  evilPolyRef :: IORef (forall a. Maybe a)     (which is the same as  IORef (Maybe (forall a. a))  because Maybe is a covariant functor)
07:37:44 * kprime hears the whoosh as the long words fly by overhead
07:38:14 <Thu17732> wat is covariant again, i remember something about arrows being reversed
07:38:17 <ski> hm, TheHunter left :(
07:38:21 <Thu17732> in typesystems
07:39:07 <kprime> Well, it somehow means that it commutes with "forall", in the same way that you can interchange a summation and a multiplication by a constant.
07:39:10 <ski> covariant more or less means : varies in the same direction
07:39:30 <ski> while contravariant means : varies in the opposite direction
07:39:34 <wilx> Hmm...in C++ covariant return types are when return type of some virtual function in child class is more specific than that of the same function in base class.
07:40:06 <ski> one can explain it with subtyping, yes
07:40:09 <Thu17732> ah right i described contravariant
07:40:20 <Thu17732> yeah i learned it in the setting of subtyping
07:40:37 <Thu17732> i really should reada TaPL over again
07:40:43 <Thu17732> s/reada/read
07:43:03 <ski> iirc :  covariant f  <=>  forall a b.  f a =< f b  <=>  a =< b    contravariant f <=> forall a b.  f a =< f b  <=>  b =< a         (where  t =< u  means t is a subtype of u)
07:43:32 <ski> data F a = MkF a    -- F is covariant in a
07:43:38 <Thu17732> yep that's it
07:43:45 <ski> data F2 a = MkF2 (Int -> a)    -- F is covariant in a
07:43:56 <ski> data F3 a = MkF2 (a -> Int)    -- F is contravariant in a
07:44:18 <ski> data F4 a = MkF4 (a -> a)    -- F4 is both covariant and contravariant in a, i.e. it is invariant in a
07:44:35 <ski> data F5 a = MkF5    -- F5 is neither covariant or contravariant in a, i.e. it is avariant in a
07:45:30 <ski> also, covariant f means we can define  fmap :: (a -> b) -> (f a -> f b)    while contravariant mean we'll have (b -> a) -> (f a -> f b)
07:49:29 <ski> kprime : yes that too. covariant f  :  forall a. f (..a..)  ~= f (forall a. ..a..), exists a. f (..a..) ~= f (exists a. ..a..)    contravariant :  forall a. f (..a..) ~= f (exists a. ..a..), exists a. f (..a..) ~= f (forall a. ..a..)     (in *classical* logic, i.e.  not fully correct in intutionistic logic)
07:49:49 <kprime> ski: Ah, figured out why foldr1 wasn't working.
07:49:58 <ski> mhm ?
07:50:31 <kprime> The first clause is "foldr1 f [x] = x".  So it looks at the tail of [x] to see if it's [] or something else.  If it's undefined, boom.
07:50:55 <kprime> foldr doesn't do that.
07:51:20 <ski> yes (thought i said that earlier, but apparently not clear 'nuff :)
07:52:15 <kprime> My memory (which may be distorted; I was typing your ideas into another window and running code at the time) is that you said it wasn't lazy enough, but if you mentioned the specifics, I failed to notice it.
07:52:39 <ski> mm, doesn't matter much, i guess
07:53:33 <kprime> If that's your quote, I see how we miscommunicated.  It'll never be *empty* ([]), it's an infinite list.  But it might be bottom (_|_), because it's not available yet.
07:55:46 <Itkovian> ttyl
07:56:10 <ski> mm, gotta go
07:56:11 <ski> bbl
07:58:57 <boegel> bye Itkovian
08:01:44 <Thu17732> later
08:12:39 <kprime> H'm... anybody have a neater way of expressing
08:12:40 <kprime> concatMap (\x -> map (x+) [7,11,13,17,19,23,29,31]) [0,30..]
08:14:03 <dcoutts_> that seems fairly neat to me
08:14:28 <kprime> I was just trying to do it without the lambda.
08:14:42 <dcoutts_> @pl \x -> map (x+) [7,11,13,17,19,23,29,31]
08:14:45 <lambdabot> flip map [7, 11, 13, 17, 19, 23, 29, 31] . (+)
08:15:04 <kprime> What's @pl?
08:15:06 <dcoutts_> I don't know if that's better! :-)
08:15:08 <xerox> Hmm, >>= ?
08:15:36 <dcoutts_> the @pl command turns expressions into point free style
08:15:50 <xerox> @pl concatMap
08:15:51 <lambdabot> (=<<)
08:15:58 <xerox> That's what I meant.
08:16:02 <dcoutts_> also known as pointless style
08:16:03 <kprime> @pl \(a,b) -> (b,a)
08:16:04 <lambdabot> uncurry (flip (,))
08:16:13 <kprime> @pl \(a,b,c) -> (c,b,a)
08:16:15 <lambdabot> (line 1, column 6):
08:16:15 <lambdabot> unexpected ","
08:16:15 <lambdabot> expecting letter or digit, operator or ")"
08:16:15 <lambdabot> ambiguous use of a non associative operator
08:16:16 <arjanb> [x+p | x <- [0,30..], p <- [7,11,13,17,19,23,29,31]]
08:16:37 <dcoutts_> oh, nice
08:16:38 <kprime> arjanb: Nice!
08:17:26 <dcoutts_> @pl [x+p | x <- [0,30..], p <- [7,11,13,17,19,23,29,31]]
08:17:27 <lambdabot> [x + p | x <- [0,30..], p <- [7, 11, 13, 17, 19, 23, 29, 31]]
08:17:39 <dcoutts_> it doesn't like list comprehensions I guess
08:17:46 <xerox> @plugs [x+p | x <- [0,30..], p <- [7,11,13,17,19,23,29,31]]
08:17:54 <lambdabot> [7,11,13,17,19,23,29,31,37,41,43,47,49,53,59,61,67,71,73,77,79,83,89,
08:17:54 <lambdabot> 91,97,101,103,107,109,113,119,121,127,131,133,137,139,143,149,151,
08:17:54 <lambdabot> 157,161,163,167,169,173,179,181,187,191,193,197,199,203,209,211,217,
08:17:54 <lambdabot> 221,223,227,229,233,239,241,247,251,253,257,259,263,269,271,277,281,
08:17:54 <lambdabot> 283,287,289,293,299,301,307,311,313,317,319,323,329,331,337,341,343,
08:17:55 <lambdabot> 347,349,353,359,361,367,371,373,377,379,383,389,391,397,401,403,407,
08:17:57 <lambdabot> 409,413,419,421,427,431,433,437,439,443,449,451,457,461,463,467,469,
08:17:59 <lambdabot> [24 @more lines]
08:19:48 <kprime> @plugs p9c = 2 : 3 : 5 : pStep baseList where { baseList = [x+r | x <- [0,30..], r <- [7,11,13,17,19,23,29,31]];  pStep :: [Integer] -> [Integer]; pStep (p:ps) = p : pStep (mergeNot ps [p^2,p^2+p..]) }
08:19:53 <lambdabot> parse error on input `='
08:20:28 <kprime> @plugs take 100 $ 2 : 3 : 5 : pStep baseList where { baseList = [x+r | x <- [0,30..], r <- [7,11,13,17,19,23,29,31]];  pStep :: [Integer] -> [Integer]; pStep (p:ps) = p : pStep (mergeNot ps [p^2,p^2+p..]) }
08:20:29 <lambdabot> parse error on input `where'
08:20:41 <kprime> @plugs take 100 ( 2 : 3 : 5 : pStep baseList where { baseList = [x+r | x <- [0,30..], r <- [7,11,13,17,19,23,29,31]];  pStep :: [Integer] -> [Integer]; pStep (p:ps) = p : pStep (mergeNot ps [p^2,p^2+p..]) })
08:20:42 <lambdabot> parse error on input `where'
08:20:56 <kprime> @plugs 2 : 3 : 5 : pStep baseList where { baseList = [x+r | x <- [0,30..], r <- [7,11,13,17,19,23,29,31]];  pStep :: [Integer] -> [Integer]; pStep (p:ps) = p : pStep (mergeNot ps [p^2,p^2+p..]) }
08:20:57 <lambdabot> parse error on input `where'
08:21:25 <kprime> @plugs let { baseList = [x+r | x <- [0,30..], r <- [7,11,13,17,19,23,29,31]];  pStep :: [Integer] -> [Integer]; pStep (p:ps) = p : pStep (mergeNot ps [p^2,p^2+p..]) } in 2:3:5:pStep baseList
08:21:27 <lambdabot> Variable not in scope: `mergeNot'
08:23:46 <kprime> @plugs let { mergeNot a@(ah:at) b@(bh:bt) = case compare ah bh of { LT -> ah : mergeNot at b; EQ -> mergeNot at bt; GT -> mergeNot a bt } ; baseList = [x+r | x <- [0,30..], r <- [7,11,13,17,19,23,29,31]];  pStep :: [Integer] -> [Integer]; pStep (p:ps) = p : pStep (mergeNot ps [p^2,p^2+p..]) } in 2:3:5:pStep baseList
08:23:48 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,
08:23:48 <lambdabot> 97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,
08:23:48 <lambdabot> 181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,
08:23:48 <lambdabot> 277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,
08:23:48 <lambdabot> 383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,
08:23:49 <lambdabot> 487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,
08:23:51 <lambdabot> 601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,
08:23:53 <lambdabot> [25 @more lines]
08:24:02 <kprime> Whew, that worked.
08:25:06 <tromp> not quite as fast as http://homepages.cwi.nl/~tromp/pearls.html#sieve, but a lot more readable:)
08:27:38 <kprime> I'll have to study that.  BTW, your link to http://home.wxs.nl/~faase009/Signindex.html is stale.
08:28:47 <tromp> thx; fixed now
08:29:06 <kprime> Gods, there's some nasty code there.
08:29:16 <rhat> I'm working my way through the YAHT, and I'm getting a vague parse error, would some kind person please tell me what I'm doing wrong? (top of http://haskell.org/hawiki/HaskellIrcPastePage)
08:32:11 <rhat> on ghc it spits out: "Ask.hs:19:15: parse error on input `putStrLn'"
08:32:12 <arjanb> rhat: these 'let' are missing 'in'
08:32:28 <rhat> I thought you didn't need that in a do block?
08:32:48 <ndm> kprime: http://scholar.google.com/scholar?q=author%3Arunciman+primes&ie=UTF-8&oe=UTF-8&hl=en&btnG=Search
08:33:02 <ndm> top one, Lazy wheel sieves and spirals of primes
08:33:15 <Igloo> rhat: You haven't indented things far enough
08:33:16 <ndm> thats a very fast Haskell prime number generator
08:33:43 <Igloo> Oh, and you'r also missing a do
08:34:17 <Igloo> In fact, just putting "do " before the "let x = head n" should fix it. The do 2 lines above is unnecessary
08:34:35 <rhat> oh, woops!
08:34:47 <Igloo> Hmm, you also don't have an else branch for that conditional. You might want when instead of if
08:36:56 <rhat> let me give it a try
08:37:52 <kprime> ndm: Thanks!  I'll have to study that a bit, but I hope I'll learn from it!
08:38:17 <ndm> kprime: its totally incomprehensible to me and everyone I know, so good luck!
08:41:50 <xs> even the author?
08:42:30 <ndm> xs: the author can, but no one else
08:43:24 <kprime> I may have to look up one of the papers he references, "explaining the wheel sieve".
08:45:00 <kprime> AFAICT, his "wheel" is like my  concatMap (\x -> map (x+) [7,11,13,17,19,23,29,31]) [0,30..] source
08:45:22 <kprime> It's a way to generate numbers that inherently don't have small prime factors.
08:45:38 <kprime> In his notation, I'm using W_3.
08:45:54 <kprime> But he is dynamically changing the wheel size as the program runs.
08:45:58 <mflux_> so when does it 'begin failing' with that wheel?
08:47:14 <rhat> Igloo: you were right about that cond expression. and it looks like I was ommitting my return statements too
08:53:40 <kprime> I don't understand.  He backs up the wheel with trial division by all larger primes, so it never fails.
09:01:26 <ndm> kprime: I think there may be another paper on the same topic by the same author - not sure though
09:01:30 <ndm> that might have more details...
10:57:50 <Subby> Hi! Kann mir mal jemand schnell sagen, wie ich nochmal aus einer Liste von Listen eine einzelne Liste mache?
10:58:24 <wilx> Speak English.
10:58:27 <Subby> sorry
10:58:49 <Subby> Can s.o. tell me how to make a single list from a list of lists?
10:58:50 <xerox> No problem, you'll just have more chances to be understood :)
10:58:59 <xerox> @type concat
10:59:13 <lambdabot> concat :: forall a. [[a]] -> [a]
10:59:28 <Subby> thx..
10:59:36 <xerox> You're welcome!
11:00:23 <Lemmih> @babel de en Kann mir mal jemand schnell sagen, wie ich nochmal aus einer Liste von Listen eine einzelne Liste mache?
11:00:27 <lambdabot>  Times can someone say to me fast, how I make an individual list
11:00:27 <lambdabot> again from a list of lists?
11:00:29 <Subby> We have to write a Parser and calculator with happy that accepts first order logic and calculates with it
11:00:34 <Subby> much work :(
11:00:35 <mflux_> @hoogle [[a]] -> [a]
11:00:37 <lambdabot> Prelude.concat :: ([[a]] -> [a])
11:00:56 <xerox> Subby, sounds fun :)
11:01:07 <Subby> yeah it is :)
11:01:35 <Subby> it has to calc the prnex-normalform and the skolem-normalform
11:02:00 <xerox> @babel de en prnex
11:02:02 <lambdabot>  prnex
11:02:05 <xerox> @babel de en skolem
11:02:07 <lambdabot>  skolem
11:02:12 <Subby> hmm dont know what it es in english
11:02:43 <Subby> the one is, when no variable exists bound and unbound and all quantors are at the front of the formel
11:02:45 <dcoutts_> skolem is a name I think. Probably a logician.
11:03:20 <dcoutts_> @google skolem normal form
11:03:22 <lambdabot> http://cs.wwc.edu/~aabyan/Logic/normal.html
11:03:47 <Subby> skolem is, when only additionaly all-quantors exists thereabout...
11:06:11 <Subby> i have to go on...
11:08:10 <xerox> Bye?
11:08:19 <Subby> no :)
11:08:28 <xerox> oops :-)
11:08:48 <Subby> btw. haskell is very cool.. at the beginning, i hated it but now i love it
11:08:50 <Subby> ;)
11:09:41 <vegai> you will relearn the hatred ;)
11:09:52 <vegai> it's pretty much a love-hate relationship
11:10:07 <Subby> it helps very much to improve the skills in funktional programming and rekursion
11:10:47 <Subby> but i'm also happy, that we are done with it now and go on with java
11:10:51 <mflux_> any news on jch btw? it sounds really interesting, with its future garbage collection scheme et al
11:10:52 <Subby> :)
11:11:27 <dcoutts_> mflux_, jch? do you mean jhc or is this something else?
11:11:44 <mflux_> mm.. ok, jhc. my route to google is stuck or something atm ;)
11:13:45 <vegai> latest update to jhc darcs repo is dated 23 May 2005
11:13:51 <dcoutts_> so they have a GC plan? they're using the Boehm GC at the moment
11:14:21 <mflux_> didn't it have plans for using region inference
11:14:36 <mflux_> plus a traditional gc on that when that fails
11:14:43 <Philippa> bah, was about to tell him he'd soon be wishing for Haskell again...
11:15:09 <Philippa> much like the MLKit work - would be cool if it happened, certainly
11:15:14 <dcoutts_> yes it says plans for using region inference: http://repetae.net/john/computer/jhc/jhc.html
11:16:03 <mflux_> I actually have an ocaml program I run on a P200, and it spends 50% of its time in GC.. judging by how it uses the memory I'm almost certain that part would be almost completely eliminated with region inference
11:16:11 <mflux_> atleast if I'm understanding the white papers correctly ;)
11:16:38 <Philippa> yeah, though depending on how amenable to the inference process the code is you might just get the heap footprint from hell instead
11:17:04 <Philippa> the problem with region inference is sometimes it doesn't get any further than shoving a newregion at the head of the program and shoving everything in that region
11:17:31 <mflux_> but can't you just use 'traditional gc' on top of that, or is that much more complex?
11:17:40 <mflux_> or maybe it doesn't quite work in that dimension
11:17:59 <Philippa> you can, you'd just end up back in the typical situation
11:18:15 <mflux_> except when region inference Works
11:18:23 <Philippa> I'm happy to not be the one doing work on how to integrate them though
11:18:25 <Philippa> more than happy
11:18:30 <dcoutts_> :-)
11:18:31 <mflux_> in that app I just create loads of objects and the next stage get rid of them
11:18:33 <mflux_> and then do that again ;)
11:18:50 <mflux_> (not objects in oo-sense mind you)
11:19:01 <Philippa> sure they are, they're just immutable ones, right? :-)
11:19:12 <dcoutts_> mflux_, you've tried fiddling with the GC parameters?
11:19:17 <Philippa> oh, wait, you mean you just call functions instead of messing with messages? :-)
11:19:36 <mflux_> yes, it helped a bit. note that it's an ocaml app, not haskell ;)
11:19:51 <vegai> jhc seems a bit hyped in its site
11:20:02 <dcoutts_> but ocaml has GC parameters to fiddle with too I'm sure
11:20:20 <mflux_> yes, and I did fiddle with them and used gprof
11:20:22 <dcoutts_> vegai, yes it does a bit. We'll see if it lives up to it. :-) (I hope so)
11:20:41 <mflux_> and did infact gain some 10 percentage units
11:21:53 <Heffalump> aren't MLKit regions scope-based?
11:21:56 <Philippa> it didn't seem overly hyped to me, AFAICT most of the neat optimisation stuff's already there and working
11:22:17 <Philippa> Heffalump: yes. The hard bit's inferring where you can usefully insert them
11:22:19 <mflux_> it's actually a simple kitchen clock application, but the machine is only P200 and I want the movement of second hand to be fluent ;) (in 1024x768)
11:22:22 <Heffalump> so you only can free stuff once you leave the scope the things were defined in and in which bit they were freed.
11:22:39 <Philippa> more or less - IIRC there's a command for moving something from one region to another
11:23:59 <mflux_> it's not a command a developer would use, but the compiler?
11:24:18 <Philippa> the developer can use it, but normally the compiler'd figure out when it can use it
11:24:39 <Philippa> region inference isn't perfect, so it's generally a good idea to let the user add extra info when they know better
11:25:31 <mflux_> so are the regions themselves visible to the developer?
11:26:17 <mflux_> maybe, some day, I should take a look at MLKit ;)_
11:26:39 <Philippa> you can add explicit newregions and stuff AIUI, but obviously you can't see the bits that've been left for the compiler to infer
11:28:38 <mflux_> hmm.. so does region inference work with non-whole-program compilers?
11:29:03 <Philippa> I get the impression it can be made to
11:29:45 <Philippa> the paranoid thing to do there is to just have every exposed function do everything in its own region before dumping the result in a region specified by the caller
11:34:24 <Lemmih> @seen bringert
11:34:25 <lambdabot> I saw bringert leaving #haskell 4 days, 45 minutes and 24 seconds
11:34:25 <lambdabot> ago.
11:34:30 <Lemmih> @seen nibro
11:34:31 <lambdabot> nibro is in #haskell. I don't know when nibro last spoke.
11:35:35 <Lemmih> nibro: ack?
11:35:47 <Heffalump> Philippa: the result and the things it points to, presumably?
11:39:43 <Philippa> yeah. Was about to say something mildly snarky about "that's just the entire value", but I'd forgotten about references
11:44:21 <xerox> @seen ndm
11:44:22 <lambdabot> I saw ndm leaving #haskell 2 hours, 39 minutes and 38 seconds ago.
12:07:36 <dcoutts_> @seen lightstep
12:07:37 <lambdabot> I saw lightstep leaving #haskell 23 hours, 7 minutes and 48 seconds
12:07:37 <lambdabot> ago.
12:44:51 * Philippa is having trouble encoding a transitive relationship in type classes
12:45:33 <Philippa> the "obvious" encoding falls over because GHC decides the instance that encodes transitivity is more specific than the one that introduces "single-step" relationships...
12:45:45 <Philippa> anybody feel up to lending me a hand?
12:55:43 <dcoutts_> Philippa, try explaining the problem and see if someone jumps in
12:59:52 <Philippa> effectively I'm trying to encode a kind of scope, in a similar vein to runST's tagging references to runST calls only with nested calls
13:01:24 <Philippa> so I've got a series of type constructors which take two parameters (call them the 'current' and 'parent' scopes) which'll generally originate from a quantification. I can easily generate an instance to say "the current scope is within the parent scope", but I can't get from there to the parent's parent easily
13:02:34 <Philippa> the obvious transitivity rule (instance (Enclose a b, Enclose b c) => Enclose a c, give or take) is giving me problems
13:02:48 <Philippa> though it may be that I have a silly way of typing 'root' scopes
13:03:38 <Philippa> which I guess I should try using another type constructor for
13:17:54 <wagle> Philippa: you try fundeps yet?
13:23:32 <Philippa> wagle: I haven't because I can't see how they help
13:24:07 <Philippa> there's nothing functional, effectively - any given scope can have any number of scopes around it
13:24:16 <Philippa> similarly, any given scope can have any number of inner scopes
13:24:43 <Philippa> it ought to determine the instance used, but it doesn't determine any of the type variables at this point
13:25:12 <Philippa> (and all the actual underlying code is the same anyway - "translate it into scope-independant operations")
13:33:04 <wagle> Philippa: my understanding is all flimsy/heuristic (I havent read the formal description of haskell's type system)..  do you have some code i can play with?
13:35:59 <Philippa> wagle: I do, can I have half an hour or so to try it with a different constructor for the 'root' scope?
13:36:30 <Philippa> I think the thing that's screwing me is that I'm defining a /reflexive/ transitive relationship - if I can reframe it in terms of something that isn't that should avoid the problem
13:37:24 <wagle> Philippa: i should be here for another hour or two
13:38:53 <Philippa> cool, thanks
13:39:06 <Philippa> I suspect the next thing I trip over is trying to be too clever with kinds
13:40:59 <wagle> "The class hierarchy must be acyclic"
13:41:35 * wagle starts wandering around the formal description of haskell's type system
13:44:33 <ski> Philippa : could well be the reflexive bit
13:45:12 <wagle> -fallow-incoherent-instances?
13:46:20 <wagle> ski: (from yesterday) yeah, i think I wanted to subclass the objects or something
13:46:41 <Philippa> wagle: it picks the instance that encodes the transitivity rule over the 'base case'
13:48:02 <wagle> Philippa: yeah, i was wondering if thats the direction it would take (didn't know what your defn's looked like it detail)
13:48:04 <ski> wagle : itym subtype
13:48:55 <wagle> ski: -EOVERLAPPINGVOCABULARY
13:49:21 <wagle> ski: subclass like in OO classes, not haskell classes
13:49:59 <ski> (Philippa : maybe related/similar to redesigning a 'declarative' presentation of a typesys with subtyping (which explicit refl & trans) into an 'operational' typesys which without (like in TaPL) ..)
13:50:21 <ski> wagle : i still think you want subtyping, not subclassing
13:50:35 <ski> wagle : looked any at OHaskell ?
13:50:53 * Philippa may finally be writing up a load of Tyop-related stuff as a TMR article at some point in the future
13:51:22 <ski> Philippa : Tyop's your typesys ?
13:51:28 <wagle> ski: timber is based on it
13:51:33 <Philippa> yeah
13:51:35 <ski> wagle : yes
13:51:51 <Philippa> well, strictly speaking Tyop was the toy haskell-like language I was using as a test-bed
13:52:52 <andersca> hey ski
13:52:53 <andersca> what's up
13:52:59 <ski> wagle : anyway, i just thought what you wanted to do seemed a bit similar to "local-extensible" (dunno good term) datatypes, as in e.g. LambdaProlog
13:53:23 <ski> andersca : hejhej. pratar typsystem o snt skoj
13:53:37 <andersca> sounds like fun!
13:53:50 <wagle> ski: the example was data E = V | A E E | L V E
13:53:57 <ski> yes
13:54:14 <wagle> where the second V (in the L constructor) is the V constructor
13:54:38 <ski> in pseudo-LamdaProlog-Haskell that's be instead data E = A E E | L (E $-> E)
13:54:56 <wagle> $->?
13:54:58 <ski> with $-> being a new interresting tycon
13:55:09 <ski> yes, "syntactic functions"
13:56:25 <ski> basically, you introduce new local constant constructors for E, whenever you need them, they serve as variable constructors
13:57:16 <ski> e.g. e0 = A (L ($\X -> A X X)) (L ($\Y -> Y))
13:57:30 <wagle> hmm
13:57:56 <ski> the $\ lambda introduces new local var constructors for E
13:58:38 <ski> (btw, just inventing the concrete syntax, here)?
13:58:45 <wagle> oh..  i've met dale miller
13:58:59 <ski> you have ? nice
14:03:25 <boegel> @y0w
14:03:27 <lambdabot> CONGRATULATIONS!  Now should I make thinly veiled comments about
14:03:27 <lambdabot> DIGNITY, self-esteem and finding TRUE FUN in your RIGHT VENTRICLE??
14:04:49 <boegel> @seen Itkovian
14:04:50 <lambdabot> I saw Itkovian leaving #haskell 5 hours, 57 minutes and 20 seconds
14:04:50 <lambdabot> ago.
14:04:54 <boegel> damn
14:05:04 <boegel> lazy bum :p
14:05:38 <ski> @arr
14:05:39 <lambdabot> This is the END for you, you gutter-crawling cur!
14:05:40 <wagle> ski: yeah, he taught some sections of a 2 weeks "proofs as programs" short course about two years ago
14:06:01 <ski> lambdabot: And i've got a little TIP, for you. Get the POINT ?
14:06:27 <ski> wagle : ok
14:06:50 <ski> lambdabot: do you acknowledge defeat ?
14:06:55 <wagle> first there was cow tipping..  then ... lambdabot tipping
14:07:40 <wagle> @uncle
14:07:41 <lambdabot> Unknown command, try @listcommands.
14:08:11 <cona1> hi all
14:08:49 * ski points wagle to http://www.classicgaming.cc/pc/monkeyisland1/walkthrough.php#swordfighting
14:09:03 <ski> hello conal
14:09:05 * boegel fears he won't be able to finish his HRay article any time soon
14:10:15 * xerox hugs ski
14:10:50 <boegel> yo Itkovian
14:11:09 <conal> was there just some chat about lambdaProlog?   i used to work on that.
14:11:18 <ski> xerox : better have a Jug'O'Grog ! and it'd better not be melting by the time i get it ..
14:11:24 <ski> conal : yes
14:11:41 <xerox> hehe.
14:12:03 <conal> ski, is something afoot with haskell & lambdaProlog?
14:12:08 <ski> um
14:12:13 <ski> not that i know
14:12:49 <ski> wagle wanted something which i thought could possibly be solved with lambdaProlog's "forall-extensible" datatypes
14:12:58 <Itkovian> hi boegel
14:13:23 <ski> (conal : you don't happen to know a proper word for that, do you ?)
14:14:01 <wagle> conal: suppose you have "data Expr = Var String | App Expr Expr | Lambda String Expr"
14:14:05 <conal> "universal quantification" in the context of "hereditary harrop formulas".
14:14:18 <conal> it's really the combo of forall and implies
14:14:32 <ski> yeah, but what to call such datatypes on which it's allowed ?
14:14:46 <wagle> I'd rather had the Lambda data constructor be of type Expr -> Expr -> Expr, instead of String -> Expr -> Expr
14:15:07 <ski> conal : hm, not sure implies goals are totally necessary for it ..
14:15:11 <conal> or wouldn't you really rather it were (Expr->Expr) -> Expr?  i would.
14:15:20 <wagle> so what i think i want is for the first Expr to be restricted to the Var constructor
14:15:31 <ski> conal : that's what i was suggesting, yes :)
14:15:55 <wagle> i want to be able to Show the values
14:16:15 <ski> which syntactic lambdas can provide
14:16:25 <ski> (i think)
14:16:32 <conal> in lambdaProlog (and in general, with higher-order abstract syntax), you would never have a Var constructor.
14:17:21 <conal> showing is a bit tricky, but doable.  Coincidentally, i'm using higher-order abstract syntax (with GADTs) again, in my "Eros" project.
14:18:10 <conal> (with Show)
14:18:11 <wagle> hmm..  i'm getting a faint ping on Dale having some clever thing like that
14:18:15 <ski> conal : hm, but then you can only introspect the funcs by applying them, right ?
14:18:25 <conal> right
14:18:25 <wagle> ... faint ping on a memory of ...
14:19:08 <ski> (conal : and, cuz the funcs can do general turing-complete comp. it can take a long time to get the result ..)
14:19:15 <wagle> but this situation comes up other places besides Expr
14:20:23 <conal> that's right.  it does.
14:20:32 <ski> conal : hm, how do you show the HOAS GADTs in haskell ?  have a Var String constr just used for showing ???
14:21:24 <conal> i use a literal, which has its string form as a field.  here's the type:
14:21:25 <conal> data Term :: * -> * where
14:21:25 <conal>   Lit  :: String -> a -> Term a
14:21:25 <conal>   App  :: Term (a->b) -> Term a -> Term b
14:21:25 <conal>   Lam  :: PatShape a -> (Term a -> Term b) -> Term (a->b)
14:21:57 <ski> and what would 'a' be in such a case ?
14:22:16 <ski> (um, what would the arg of 'a' type be ?)
14:22:43 <ski> conal : interesting, anyway
14:22:48 <conal> ski: do you mean what type args am i usinjg with Term?
14:23:31 <ski> i wonder how you show vars, and if doing it with Lit (as you seemed to say) what is 'a' and the arg of 'a' type, then ?
14:25:04 <conal> i am using Lit, with a simple naming monad.  the 'a' type can be anything.  the 'a' value is bottom.
14:25:11 <conal> which is not used during showing.
14:25:14 <ski> ok
14:25:17 <ski> aha
14:25:37 <conal> a standard laziness hack
14:25:42 <ski> so you merge the lifting and var uses into the same constructor
14:25:55 <ski> what is the string, in the case of a lifted value ?
14:25:59 <ski> empty ?
14:26:18 <ski> (iiuc)
14:26:35 <conal> by "lifting" do you mean converting a value of type a to a value of type Term a?
14:28:17 <conal> if so then yes, i just Lit for both purposes.  for a showable lifted value v, i use show v.  For functions pulled from a library, i use the library name.
14:29:14 <conal> the special Lits i make for showing are just tossed in during show and then discarded.
14:30:34 <ski> re lifting, yes
14:30:45 <ski> aha
14:31:00 <ski> so you use same show code in that case ..
14:31:11 <conal> right
14:31:20 <ski> yeah, of course (re special lits)
14:32:18 <Philippa> *woo!* it works
14:32:18 <conal> and though it's probably irrelevant, i do show via an intermediate rep as a Haskell expression via Language.Haskell.Syntax
14:32:38 <conal> philippa: what works?
14:32:43 <Philippa> wagle: thanks for mentioning fundeps earlier, I needed them later on to beat the compiler into unifying a couple of type variables
14:32:52 <Philippa> conal: a regioned-ST implementation
14:32:58 <Philippa> (layered on top of ST)
14:33:32 <conal> philippa: "regioned" as in region-based memory management
14:33:35 <conal> ?
14:33:40 <Philippa> you can run 'inner heaps' inside an ST-like monad, with references from an outer heap being usable inside an inner heap
14:33:52 <Philippa> (but inner heap references being unusable from outside their 'scope')
14:33:56 <Philippa> yeah
14:34:00 <conal> oho!  cool!
14:34:16 <Maddas> Yow!
14:34:31 <Philippa> wait, there's an important bit I've not implemented yet that I'd better sort out - I'm pretty sure this bit'll work easily though, thankfully
14:34:47 <Heffalump> Philippa: isn't that trivial to implement with access to the internal runST implementation?
14:34:54 <wagle> Philippa: cool!
14:35:04 <ski> Philippa : cool ! :)
14:35:05 <Heffalump> (just have the inner heap be a stacked monad)
14:35:17 <Heffalump> oh, no, sorry.
14:35:31 <Heffalump> I'm sure I hacked together something like that ages ago, though.
14:35:37 <Heffalump> (Interleaved ST rather than nested, IIRC)
14:35:46 * Heffalump tries to find it
14:36:18 * ski has pondered about ST-like refs, but for Reader-monad ..
14:36:39 <ski> (i.e. with a 'dynamic' newRef ..)
14:37:01 <Philippa> Heffalump: it's fairly trivial anyway, the mildly-hard part's beating the type class system into making it all work right
14:37:05 <Philippa> but only mildly hard
14:37:11 <Philippa> it's an example for an article, anyway
15:10:40 <kaol> @botsnack
15:10:41 <lambdabot> :)
15:10:54 <xerox> @moo
15:10:55 <lambdabot>  *        (__) *      (__)
15:10:55 <lambdabot>   \       (oo) |      (oo)
15:10:55 <lambdabot>    \-------\/  \-------\/
15:10:55 <lambdabot> o  o|     ||   /     ||
15:10:55 <lambdabot>     ||----||>==/-----||
15:10:56 <lambdabot>     ^^    ^^         ^^
15:10:58 <lambdabot>     Cow getting the shit
15:11:00 <lambdabot>      kicked out of her
15:11:11 <xerox> Perv.
15:18:45 <boegel> night all !
15:18:49 <ski> m
15:33:26 <Spark> @botsnack
15:33:27 <lambdabot> :)
15:34:45 <xerox> 'night people
15:35:09 * kaol is a night person
15:36:17 <wagle> am i dense, or is the first example on this web page really broken? http://haskell.org/hawiki/StateMonad
15:37:38 <ski> wagle : looks ok to me, at quick glance
15:37:57 <ski> what part are you thinking could be worng ?
15:38:04 <wagle> i got it to work with a major overhaul
15:38:16 <wagle> getNext, numberSt are not defined, for starts
15:38:24 <wagle> numberST
15:38:42 <ski> oh
15:38:48 <ski> s/numberST/number/
15:39:23 <wagle> yeah, and getNext ~> get; put (next + 1)
15:39:50 <wagle> really crummy to put a non functioning example first
15:40:13 <wagle> never mind addings runstate ... 1
15:41:08 <wagle> hey!  i exist now!  (http://www.scannedinavian.org/~shae/haskellers.large.png)
15:42:38 <wagle> or evalState..
15:43:30 <ski> updated page ..
15:44:03 <ski> wagle : nice :)
15:45:28 <wagle> i think that works, might want to mention runState, evalState, and execState
15:46:38 <wagle> hmm..  hugs doesnt have them?
15:46:42 <ski> just not sure i should munge up ChrisAngus' example too much ..
15:46:59 <ski> hugs has hierarchical libs, yes
15:47:32 <wagle> grep -ri runState /sw/share/hugs/
15:47:41 <wagle> finds nothing
15:48:02 <wagle> eeps
15:48:05 <ski> maybe they haven't finished doing that yet, duno
15:48:11 <wagle> Version: February 2001
15:49:56 <ski> Prelude> :v
15:49:56 <ski> -- Hugs Version November 2003
15:49:56 <ski> Prelude> :l Control.Monad.State
15:49:56 <ski> Control.Monad.State> :t (runState,evalState,execState)
15:49:56 <ski> (runState,evalState,execState) :: (State a b -> a -> (b,a),State c d -> c -> d,State e f -> e -> e)
15:50:28 <wagle> yeah, i was using ghci
15:50:48 <wagle> hugs is just faster to try things out with
15:50:55 <ski> m
15:51:06 <wagle> m?
15:52:22 <ski> yes
15:54:00 <wagle> fink is a fink
15:54:24 <wagle> $ port search hugs
15:54:24 <wagle> hugs98          lang/hugs98     Mar2005         The HUGS Haskell Interpreter
16:02:56 * ski 's off to nana land
16:03:17 <wagle> gnight
16:03:23 <ski> m
16:16:00 * Philippa curses
16:16:29 <Philippa> forget my (too-early) celebration earlier, I've just realised why my code's not working
16:17:08 <Philippa> or at least, why I think it isn't, but hey. The inference system isn't propagating info in the direction I want it to, which is why it can't pick the right instance
16:20:19 <dcoutts> yay! Gtk2Hs 0.9.8 has been released: http://prdownloads.sourceforge.net/gtk2hs/gtk2hs-0.9.8.tar.gz?download
16:21:04 <dcoutts> (source only for the moment, packages and a release announcement to follow in a couple days)
16:22:13 <Lunar^> dcoutts: great! :)
16:36:00 <Igloo> Does anyone know what cabal package(s) gtk2hs builds?
16:55:11 * Lunar^ is looking at Oleg's paper
16:55:23 <Lunar^> Does anyone know what FNMOC stands for?
16:55:35 <Philippa> *dammit*. There's no way to tell it I'm never going to unify the type variables that represent different regions and it's falling over on it :-(
16:56:44 <ccshan> Fleet Numerical Meteorology and Oceanography Center
16:57:21 <Lunar^> ccshan: Mh.. your name is on that paper too :) thanks :)
16:57:31 <Pseudonym> Philippa: You're working on supertypes?
16:57:50 <ccshan> lunar: that cuts down the possible papers dramatically (:
16:58:15 <Philippa> Pseudonym: I'm trying to hack up an ST-with-regions monad
16:58:25 <Pseudonym> Ah.
16:58:33 <Pseudonym> Good luck. :-)
16:59:03 <Philippa> oh, I'm close. Unfortunately I suspect I'm running into the bit that makes it impossible
16:59:10 <Philippa> oh, obviously I'm cheating and writing it in terms of ST anyway
16:59:10 <Pseudonym> I'm not even certain it's possible to type that precisely.
16:59:11 <Pseudonym> Ah.
16:59:39 <Philippa> it's almost possible - you tag each region in much the same way you tag calls to runST
17:00:00 <Pseudonym> Do you tag the references?
17:00:04 <ccshan> Philippa: oleg has some (probably unpublished) code related to what you're doing; you can ask him for it
17:00:07 <Philippa> of course
17:00:18 <Philippa> ccshan: what does it do?
17:00:21 <Pseudonym> See, I think that'd make it difficult to program with.
17:00:43 <Philippa> in what way?
17:00:55 <Philippa> (beyond matching references to regions being the whole point of the exercise)
17:00:56 <ccshan> Philippa: i'm not sure - like many messages from oleg, this one has been intriguingly sitting in my inbox
17:01:10 <Philippa> ah. Is it a private message or a public one?
17:01:31 <Pseudonym> OK, let me ask first: What's the point of the exercise?
17:01:33 <ccshan> Philippa: private, but he'll probably send you a copy, possibly revamped to be even better
17:01:38 <Pseudonym> WHY is it useful to tag references with regions?
17:02:07 <Philippa> tighter control over where your state goes
17:02:15 <ccshan> Philippa: have you thought of using eigenvariables (types "gensymed" to typecheck universal introduction or existential elimination) as region tags?
17:02:22 <ccshan> maybe htat's what you're already doing
17:02:26 <Pseudonym> Oh, I see.
17:02:31 <Pseudonym> I thought it was for precise GC or something.
17:02:41 <Pseudonym> Which is what region inference is usually used for,
17:02:47 <Pseudonym> Never mind, then.
17:03:11 <Philippa> a native implementation'd be able to offer a guarantee that the whole region's flushed when the withRegion call finishes, yeah
17:03:26 <Philippa> though on the upside you do at least know there's no memory leak - next time the GC's called, it dies
17:03:37 <Pseudonym> Except that lazy evaluation tends to stuff things up.
17:04:14 <Philippa> yeah, but as the entire monad's based around (strict) ST that's not as big an issue as it could be
17:04:14 <Pseudonym> Knowing that a region has disappeared doesn't mean that what the reference points to is garbage.
17:04:19 * Pseudonym nods
17:04:47 <Pseudonym> Region inference for GC purposes and lazy evaluation really don't mix.
17:05:30 <Pseudonym> There's no guarantee that different bits of the same data structure were allocated by the same thread, even.
17:05:57 <Pseudonym> But if you're just doing it for state control, that's different. :-)
17:06:55 <Pseudonym> Woohoo!
17:07:01 <Philippa> ccshan: I'm doing the same trick runST does at the moment - the computations are all region-polymorphic and the calls that run them are rank-2 polymorphic
17:07:01 <Pseudonym> Oleg made my monad for me!
17:08:11 <Philippa> unfortunately you end up with a bit of a problem - the tag info doesn't seem to propagate effectively enough to let inference do its thing sanely, which makes the whole thing a little too much effort to use
17:09:16 <ccshan> Philippa: hrm. certainly you shouldn't have to keep showing the typechecker how one region is guaranteed younger than another.
17:14:11 <Lunar^> ccshan: What does "functional peal" means, btw?
17:19:09 <ccshan> lunar: "Elegant, instructive examples of functional programming."
17:19:32 <ccshan> http://www.informatik.uni-bonn.de/~ralf/necklace.html
17:20:04 <Lunar^> ccshan: that's rewarding :)
17:27:24 <Philippa> ah well. Trying to hack this up has reminded me of why I once described prolog as "haskell backwards"
18:11:51 <shapr> @yow !
18:11:53 <lambdabot> Now, let's SEND OUT for QUICHE!!
18:20:37 <blackdog> g'day shapr
18:20:42 <shapr> g'day blackdog
18:21:18 <shapr> I'm about to sleep, but in about 6.5 hours I'll have time to help out with Plone
18:21:54 <blackdog> thank god.
18:22:06 <dons> poor blackdog
18:22:11 <blackdog> I'm lost in a maze of twisty little portals, all different
18:22:17 <shapr> heh
18:22:21 <shapr> I know the feeling
18:23:01 <dons> @code
18:23:03 <lambdabot> IOBase.lhs: When passed a value of type @IO a@, the 'IO' will only be performed
18:59:51 <x3n0n> Anybody here messing around with PArrows?
19:01:08 <x3n0n> I'm just trying to figure out why "char :: MD i Char" instead of "char :: MD Char Char"
19:03:05 <x3n0n> The obvious formulation of "string" has type "MD Char String", but the distributed version has what looks like a hack to allow it to have the type "MD i Char"
19:10:36 --- topic: set to 'greasemonkey' by hyrax42
19:10:43 <hyrax42> woops
19:10:44 <hyrax42> :(
19:11:33 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueThree","Shapr rules","ICFP Contest! http://icfpc.plt-scheme.org/","ghc added to Fedora Extras"]' by hyrax42
19:11:40 <hyrax42> :/
19:11:42 <hyrax42> I suck
19:35:15 <ral1> Hi.  I'm reading the build guide for wxhaskell.  Is it okay if I ask a couple of questions if I only have ten minutes?
19:35:23 <ral1> they should be quick questions
21:20:23 <farus> good evening :-)
21:20:30 <farus> would anybody here have a copy of Robin Milner's seminal paper: "A theory of type polymorphism in programming"?
21:20:58 <farus> I already asked #lisp and #scheme :-P
21:22:21 <Cale> farus: let me check
21:22:40 <farus> oh please, thanks Cale :-)
21:22:53 <hyrax42> that's weird
21:23:03 <hyrax42> google scholar just lists it as a citation
21:23:37 <farus> hyrax42: most things published before mid 90s are not online, unless their authors make them explicitly so :-/
21:23:51 <hyrax42> but magic
21:23:52 <hyrax42> internet
21:23:54 <hyrax42> internet makes magic
21:23:57 <hyrax42> :(
21:25:01 <farus> not always. sometimes old librarian ladies with fish-net hats and floors worth of bound journals and publications makes magic.
21:26:11 <Cale> farus: yes
21:26:11 <ccshan> farus: I have a scanned copy
21:26:24 <ccshan> Cale: where's yours from? (:
21:26:25 <farus> sweet
21:26:46 <Cale> http://vx.hn.org/autoshare/milner.pdf
21:27:14 <Cale> scholarsportal.info
21:27:23 <farus> Cale: you're a good man my friend
21:27:27 <Cale> which I have access to as a university student
21:28:25 <farus> nice. I paid $150 for a university library membership, but I don't have online access :-/
21:28:46 <ccshan> (Cale: yours is better quality thanks!)
21:31:26 <hyrax42> what'd be prerequisite for reading that paper
21:33:00 <ccshan> hyrax42: I recommend Luca Cardelli's "Basic Polymorphic Typechecking", at http://www.luca.demon.co.uk/Bibliography.html
21:33:30 <Cale> Doesn't look like it needs too much other than some mathematical maturity and/or functional programming experience
21:33:42 <hyrax42> ccshan: host does not exist?
21:33:59 <hyrax42> Cale: sounds good
21:34:02 <hyrax42> I wish I had
21:34:04 <hyrax42> any of
21:34:04 <farus> what is the best intro book to type theory?
21:34:12 <hyrax42> a) printing credits at school
21:34:13 <hyrax42> b) toner
21:34:17 <hyrax42> c) money to buy toner
21:34:30 <hyrax42> TPL?
21:34:31 <hyrax42> maybe
21:34:33 <hyrax42> :(
21:34:34 <farus> Pierce has one, Gunter has one, Reynolds has one, the scheme community has one, etc.
21:34:35 <hyrax42> I know nothing
21:35:01 <ccshan> farus: sorry, go to the root directory at the same host name
21:36:42 <farus> prolific Luca Cardelli :-)
21:36:49 <hyrax42> yeah
21:36:50 <hyrax42> quite
21:37:10 <ccshan> farus: it depends on your background. I know that Pierce's is good for some people.
21:37:47 <farus> I have Gunter and Reynold's advanced books, I got them cheap at $10 each and they're near impossible to get through.
21:38:05 <farus> Essentials of Programming Languages is a delight, but it doesn't have enough on typing
21:41:05 <hyrax42> EoPL Friedman?
21:41:30 <hyrax42> I've got it but I'm being really lazy about it :(
21:42:32 <farus> if you know Lisp you KNOW that's a delightful book :-)
22:10:01 <musasabi> For the PArrows question - if char had the type "MD Char Char" then it would make sequencing harder.
23:26:03 <lightstep> are gtk dialogs different from windows?
23:52:17 <Heffalump> hi
