00:44:05 * ski 's got debian running :)
00:44:20 <ski> which ghc version/branch should i get ?
00:44:38 <ski> ghc6 ? ghc-cvs ?
00:46:01 <lightstep> ghc6
00:46:29 <ski> the current ghc-cvs is not fully stable ?
00:47:08 <lightstep> i don't know, but it's probably less stable than ghc6
00:47:14 <ski> mm
00:47:19 * ski tries it
00:51:29 * shapr explodes!
00:52:07 <lightstep> oh, not again!
00:52:08 <shapr> kimbly: hiya!
00:52:57 <shapr> kimbly: hey, what did you think of the zipper as tree of subcontinuations? Do you think it's connected to your filesystems blog post?
00:53:57 <shapr> kimbly: If you're looking for useful arrows code, check out PArrows: http://www.cs.helsinki.fi/u/ekarttun/PArrows/
00:59:26 <lightstep> wow, it even fixes the warts of Parsec's design
01:02:26 <vegai> how do arrows differ from monads?
01:03:54 <shapr> increased efficiency in both execution and memory.
01:04:00 <boegel> y0 shapr
01:04:03 <lightstep> monads are containers, arrows are functions in a dsl
01:04:03 <shapr> y0 boegel
01:04:37 <ski> hi shapr
01:05:04 <shapr> Monads are (a -> m a). All you can do with a monad is push the button and see what happens.
01:05:15 <vegai> so... is it probable that many monadic implementations will be replaced with arrows?
01:05:27 <shapr> Arrows are roughly like monads with a static component, but they're also structurally different.
01:06:02 <vegai> an IO arrow...?
01:06:18 <shapr> Monadic computational 'shapes' look like (a -> (a -> (a -> m a))), so some bindings can stay bound deeper in the shape.
01:06:37 <shapr> Arrows look like a >>> b >>> c, the pieces are separated.
01:06:55 <vegai> ah
01:07:01 <lightstep> some libraries can be structured as monads, some can't satisfy all the axioms, so they have to be structured as arrows (or not at all). ArrowMonad and ArrowApply help converting between the two forms
01:08:36 <shapr> The original motivation for arrows was the Swierstra & Duponcheel parsers. The observation was that monadic parsers hold onto input way too long.
01:08:53 <lightstep> are spears real or just a joke?
01:09:50 <shapr> If you have a command-line parser that can handle these options ["-crumble","-cranowky","-pineapple"], you'll know whether a parser would succeed after the first character.
01:09:50 <vegai> "Extending Spears to Catapults"
01:09:53 <dons> lightstep, you may be interested in the generalisation of spears and arrows into yoyos
01:10:01 * shapr laughs hysterically
01:10:09 <shapr> ----@
01:10:22 <dons> the singleton yoyo: @
01:10:28 <dons> or a fully extendend yoyo: ---------------@
01:10:52 <dons> which can `travel backwards', -----@ ---@ --@
01:11:02 <dons> eventually resulting in a singleton: @
01:11:23 <dons> the key thing is that computation can flow `both ways'
01:11:25 <shapr> vegai: Even though you could find out after the first character whether any of the command line options might be parsed, you can't do that with monads. There's no static component, so a) you have to hold onto all the input b) you have to call each parser in turn until *all* of the parsers have failed or one has succeeded
01:11:56 <shapr> dons: This is starting to sound realistic. You could use yoyos to model reversible logic.
01:12:33 <vegai> so, arrows have a sort-of shared, single state through the computation?
01:12:48 <lightstep> what about binary encoding for the length? -~--~~~-@
01:12:57 <lightstep> vegai, yes
01:13:00 <shapr> I'm not sure what you mean by shared...
01:13:17 <lightstep> @arrows
01:13:18 <lambdabot> Unknown command, try @listcommands.
01:13:21 <shapr> But in the case of arrow-style parsers, they can statically figure out what they can parse.
01:13:34 <lightstep> pretty diagrams in http://haskell.org/arrows/
01:14:37 <vegai> so an IO arrow could be quite useful
01:15:11 <shapr> Since you can statically ask a bunch of arrow-style parsers what they can parse, you get to immediately GC unusable input, or immediately go to the right parser without having to fail through all the stacked previous parsers.
01:15:29 <ski> (sometimes it would be nice knowing that all files etc exists before doing something with them ..)
01:16:23 <lightstep> and IO arrow is like the ML function type
01:16:38 <vegai> huh?
01:16:57 * ski wonders if one can make some kind of restricted IO, maybe arrow, that would check for obvious failures of planned steps before embarking on any of them. some kind of transaction ..
01:17:44 <shapr> ski: an STM arrow?
01:18:04 <ski> shapr : maybe, haven't looked at STM yet
01:18:15 <shapr> STM is nifty.
01:18:44 <ski> lightstep : please explain what you mean
01:19:08 <shapr> vegai: Any specific questions about arrows? I can write up an illuminating example that compares arrow-style and monadic parser if you want.
01:19:29 <andersca> god morgon
01:19:34 <boegel> shapr: maybe for TMR ? :)
01:19:36 <ski> (shapr : i was under the loose impression that STM had to do with some kind of memory transactions or maybe distributed stuff.. )
01:19:37 <shapr> hej andersca!
01:19:49 <boegel> "an introduction to monads and arrows"
01:19:53 <boegel> with one nifty example
01:19:56 <shapr> ski: Yeah, it does have to do with memory transactions.
01:20:02 <shapr> boegel: that's a good idea.
01:20:07 <boegel> I think lot's of noobs would appreciate that (including me !)
01:20:38 <shapr> I think I'll write "An Introduction to Arrows" that assumes knowledge of monads.
01:21:18 <wilx> Arrows are interesting beasts.
01:21:29 <boegel> shapr: :(
01:21:40 <shapr> boegel: C'mon, you already understand monads.
01:21:45 <lightstep> ski: you could make an (IOA a Int) counter, just like (a -> int) in ML
01:21:54 <boegel> shapr: I don't man :) I use IO, but that's it :D
01:22:01 <shapr> And there's no way I can do better than Jeff Newbern's monads tutorial.
01:24:18 <Lunar^> shapr: It seems you'll be able to write the ultimate arrows tutorial soon
01:24:38 <shapr> I should start now...
01:24:38 <Lunar^> shapr: maybe I finally suceed in understanding them if someone as practical as you explain them
01:24:40 <ski> lightstep : aha
01:25:03 <Lunar^> shapr: House paper got accepted at ICFP 2005, btw
01:25:06 <shapr> Yeah, I'm definitely not a theoretical powerhouse.
01:25:08 <shapr> Awesome!
01:25:19 <boegel> shapr: be sure to mention the Newbern's tutorial then :)
01:25:28 <shapr> Yeah, definitely
01:25:30 <Lunar^> shapr: I did not authored it, though
01:25:37 <Lunar^> :)
01:25:49 <shapr> Did you write a paper on hOp?
01:26:28 * boegel should get working on his HRay article for TMR
01:26:40 * boegel should get some studying done too
01:26:53 <Lunar^> shapr: we started and never finished it
01:26:59 <shapr> quel dommage
01:27:04 <Lunar^> no big deal
01:27:18 <Lunar^> But Rebekah Lelsie seems to do her thesis on House
01:27:18 <shapr> Still, would be nice to present a paper at HW.
01:27:43 <shapr> Lelsie?
01:27:51 <Lunar^> I should not have listen to anyone saying that hOp couldn't be turned into a research project
01:28:00 <shapr> Leslie
01:28:06 <Lunar^> yep
01:28:27 <Lunar^> OGI and PSU people did!
01:28:32 <shapr> Yeah!
01:28:55 <shapr> Personally, I think hOp would be good for investigating some of Henry Baker's ideas on garbage collection.
01:29:25 <shapr> hOp would be good for many things.
01:29:46 <shapr> QuickCheck plus a pure Haskell TCP/IP stack should make Microsoft quiver in fear.
01:31:34 * Lunar^ returns to more coq'ing
01:31:42 * shapr returns to unicycling!
01:31:48 <dons> I'd love to add hot swappping to a nice purely functional OS
01:31:50 <shapr> vegai: Unless you have more arrows questions?
01:31:58 <shapr> hm, that's a neat idea.
01:32:15 <shapr> I'd like to add asymmetric multiprocessing to some OS somewhere.
01:33:37 <shapr> And hotswapping
01:34:28 <shapr> And some infinitely extensible bus.. like wrapping all the components into cubes and letting the user plug in a new CPU, more RAM, or another hard drive, all at runtime.
01:35:40 <shapr> Oh, I found part of my keylap! There's an HP tablet PC that is only a screen with all the hardware behind the screen, the keyboard isn't part of it.
01:36:27 <Lunar^> shapr: cool
01:37:08 <shapr> Here's the specs - http://h18000.www1.hp.com/products/tabletpc/tc1100/
01:37:28 <shapr> I'm not sure how to stick that together with a kinesis keyboard in such a way that it's usable as a laptop.
01:37:35 <shapr> hiya scandi4ever, looking for Haskell info?
01:37:42 <Lunar^> Is this the one running Debian?
01:37:58 <shapr> Nah, that's the Nokia 770
01:38:13 * Lunar^ mixing everything up
01:39:28 <shapr> I'll send email to Rebekah and invite her to #haskell.
01:39:40 <shapr> I'd like to hear about any House projects.
01:40:49 <dons> me too. maybe we can get lambdabot to run on bare metal :}
01:41:04 <dons> step 1. in the Rise of the Machines
01:42:27 <shapr> haha!
01:48:52 <Lunar^> shapr: Good idea :)
01:50:14 <xerox> shapr, "illuminating example that compares arrow-style and monadic parser" - where where where where?
01:50:27 <shapr> I'm writing it right now on tmrwiki.
01:50:36 <xerox> You're the man.
01:53:35 <xerox> (Oh, g'morning people.)
01:53:48 <shapr> g'mornin xerox
02:09:48 <vegai> shapr: no more questions about arrows at this time, thank you
02:20:43 <shapr> ChannelServices: Hi, want to learn Haskell?
02:22:19 <shapr> ChannelServices: You're not trying to fake ChanServ are you?
02:23:11 <shapr> You have an advertising url in your /whois, and your nick is suspicious, respond or be punted.
02:23:21 <ChannelServices> hi.
02:23:25 <shapr> oh, hi
02:23:32 <shapr> Are you learning Haskell?
02:23:38 <ChannelServices> i'm interested
02:24:08 <shapr> Are you familiar with other functional programming languages?
02:24:22 <shapr> Have you used some procedural languages?
02:24:28 * boegel feels a tour coming up
02:24:43 <ChannelServices> only other languages i've used are perl and python
02:25:13 <shapr> I got into Haskell from Python, I think it's a natural step.
02:25:23 <ChannelServices> good to hear
02:25:53 <shapr> Would you like to see a short Haskell syntax demo?
02:26:04 <ChannelServices> sure
02:26:10 <shapr> http://www.haskell.org/hawiki/HaskellDemo
02:26:34 <shapr> lambdabot includes an interactive Haskell plugin.
02:26:47 <shapr> @plugs map (\x -> x + 1) [1,2,3]
02:26:52 <lambdabot> [2,3,4]
02:27:26 <ChannelServices> -- example
02:27:26 <ChannelServices> author1 = Person "Shae Erisson" 33
02:27:31 <ChannelServices> that's you, right?
02:27:34 <shapr> Yup, that's me.
02:27:41 <shapr> Who are you?
02:27:49 <ChannelServices> i'm nobody
02:27:58 <shapr> Nobody's nobody.
02:28:04 <ChannelServices> i'm brandon haskell
02:28:12 <shapr> Nice to meet you Brandon Haskell.
02:28:13 <boegel> :|
02:28:27 <ChannelServices> brb letting the dog out
02:28:33 <Oejet> Wow, THE Brandon Haskell?
02:28:45 <boegel> Oejet: who is he ?
02:29:04 <Oejet> boegel: Nobody. :-P
02:29:14 <shapr> Nobody's nobody!
02:29:35 <boegel> maybe this one: http://www.theacorn.com/News/2002/0606/Schools/058.html
02:30:00 <ChannelServices> Mark Brandon Haskell
02:30:03 <ChannelServices> that's mark haskell :(
02:30:06 <ChannelServices> whoever that is
02:30:10 <boegel> we'll, close :)
02:30:30 <xerox> boegel, stand still and drop the "'" nobody wants to hurt you
02:30:45 * shapr tackles boegel 
02:30:49 <shapr> I've got him!
02:31:00 * xerox gets the "'" rapidly
02:31:16 <mflux_> phew, that was close.
02:31:28 * boegel trembles in fear
02:31:35 <shapr> Quick, put it into the '-disposal unit!
02:31:41 <boegel> well, ok
02:31:44 <xerox> shapr, mine is full!
02:31:48 <shapr> oh no!
02:32:06 <boegel> shapr in action: http://www.scannedinavian.org:9673/webbhaxor/Members/shae/monad_cycle.jpg
02:32:28 <shapr> sleep: If you'd like to learn Haskell, the Haskell Demo is a good place to start, and "Yet Another Haskell Tutorial" is a good place to continue.
02:32:48 <xerox> Wow, a guy on the pic's background has a shirt with a lambda on it ^_^
02:33:14 <boegel> heh
02:33:32 <shapr> If you would like to read some promotional literature designed to encourage the use of functional programming, there's lots of good stuff here - http://www.haskell.org/learning.html, I especially like http://www.haskell.org/complex/why_does_haskell_matter.html
02:33:51 <ski> xerox : http://www.dtek.chalmers.se/~d00bring/misc/eh-tshirt-bjorn.jpg
02:34:00 <shapr> xerox: http://www.dtek.chalmers.se/~d00bring/misc/eh-tshirt-bjorn.jpg
02:34:03 <shapr> dang, beat me to it.
02:34:17 * ski chuckles evilly
02:35:13 <ski> shapr : i've finally installed debian
02:35:21 <shapr> Cool, what do you think?
02:35:34 <xerox> ahah!
02:35:48 <ski> nice, so far. though i do not know very much about how apt etc works yet
02:36:15 <xerox> ...so this guy is into "beer hacking", I see.
02:36:16 * ski right now tries to learn what to type in fstab ..
02:36:59 <shapr> xerox: That's from the EuroHaskell agenda - http://www.haskell.org/hawiki/EuroHaskell
02:37:30 <shapr> hiya gaal
02:37:42 <shapr> sleep: Do you have any questions about Haskell?
02:37:44 * boegel jumps in the shower
02:37:47 <gaal> hi! I'm looking for a safe subscripting function
02:37:49 <boegel> and slips... aï
02:37:55 * shapr jumps in the living room.
02:38:02 * boegel walks into the shower
02:38:09 <gaal> subscript :: list -> Maybe a
02:38:09 * shapr has a nice subscription to The Monad.Reader.
02:38:26 <gaal> that works like !! but returns Nothing instead of error
02:38:31 <gaal> when the index is too large
02:38:47 <gaal> shapr, ahhhh, but that doesn't sound too safe.
02:38:56 <xerox> @index (!!)
02:38:58 <lambdabot> bzzt
02:38:58 <gaal> is it a local subscription? :)
02:39:00 <lightstep> @type drop
02:39:06 <lambdabot> drop :: forall a. Int -> [a] -> [a]
02:39:18 <lightstep> if the result is not empty, you can take the head
02:39:21 <shapr> Yes, very local. I'm the guy who pushes people to write articles!
02:39:45 <gaal> local (const journal) (subscribe)
02:39:51 <gaal> you said it's Reader...
02:40:21 * shapr snickers
02:40:22 <ski> Monad.WriterT Monad.Reader a ?
02:40:54 <gaal> soooo, is there no such standard function?
02:41:00 <lightstep> no
02:41:05 <gaal> too bad :)
02:41:25 <lightstep> @type \n l -> case drop n l of [] -> Nothing; (x:_) -> Just x
02:41:27 <lambdabot> \n l -> case drop n l of [] -> Nothing; (x:_) -> Just x :: forall a.
02:41:27 <lambdabot>                     Int -> [a] -> Maybe a
02:41:41 <gaal> merci
02:41:45 <lightstep> @pl \n l -> case drop n l of [] -> Nothing; (x:_) -> Just x
02:41:46 <lambdabot> (line 1, column 29):
02:41:46 <lambdabot> unexpected ">" or "-"
02:41:46 <lambdabot> expecting variable, "(", operator or end of input
02:42:29 <gaal> ugh, my type sig up there was way silly
02:42:51 <gaal> Int -> [a] -> MAybe a is indeed what i wanted
02:44:00 <xerox> @wiki HaskellIrcPastePage
02:44:02 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
02:44:05 <xerox> There you go :)
02:44:44 <gaal> xerox++; # if that works here.
02:45:26 <xerox> hmm, it depends on what drop 0 does, ugh :)
02:45:58 <xerox> I think it's correct, anyway.  Can you tell me if giving away the solution was a stupid move?
02:46:37 <gaal> not sure
02:46:53 <gaal> learning both the basics and the unbasics at the same time is stressful
02:46:58 <xerox> :\
02:47:22 <shapr> gaal: Better than digging ditches for a living.
02:47:39 <gaal> meaning i appreciate having the solution, which lets me work on other things.
02:47:52 <xerox> Last time.  Promise :)
02:48:33 <lightstep> not just maybe (i added another version the the paste page)
02:48:38 <shapr> Hm, what's the url to autrijus' paper?
02:48:57 <gaal> docs/talks/hw2005.txt
02:49:28 <shapr> Er, what's the rest of the url?
02:49:46 <gaal> http://svn.openfoundry.org/pugs
02:49:50 <shapr> ah, thanks
02:50:03 <lightstep> xerox, using (==[]) requires an Eq context, but using `null' doesn't
02:51:06 <gaal> ah, fail in Maybe gives Nothing, right? but how does the code know it's in Maybe?
02:51:27 <gaal> (rookie monad user here)
02:51:41 <shapr> RookieT
02:52:06 <lightstep> it doesn't. it works for every monad.
02:52:10 <gaal> cargo monad cult member
02:52:36 <shapr> hehe
02:57:50 <scalopus> Hi
02:57:54 <xerox> lightstep, right!
02:59:11 <ski> hello scalopus
03:01:31 <ski> scalopus : learning haskell ?
03:01:46 * shapr throws lambdas
03:02:05 * araujo jumps over one
03:02:19 <shapr> Ninja Lambdas of DOOM!
03:02:21 * ski ducks under a continuation
03:02:57 <ski> now, where did i put my lambda shuriken ?
03:03:05 <shapr> ShurikenT
03:04:00 <xerox> @index null
03:04:02 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
03:04:07 <xerox> @libsrc Data.List
03:04:09 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
03:04:15 <ski> the stealthy lambdas will sneak into your code, whether you wnat them or not !
03:06:08 <boegel> shapr: have you had any reaction to the tool for converting MoinMoin to LaTeX ?
03:06:24 <shapr> er, which tool?
03:06:49 <shapr> The one by Ketil Z. Malde?
03:08:00 <shapr> The way I see it, I really want to be able to use a wiki and wiki syntax to compose articles. Lots of people want to get pdf and/or ps output. So, I think they should find some way to get that :-)
03:08:16 <boegel> shapr: on LtU you talked about a tool to convert MoinMoin syntax to LaTeX, so you would be able to produce a TMR version in PDF
03:08:38 <shapr> I think I said "someone should write this tool so I can use it for TMR."
03:09:17 <boegel> shapr: yeah you did, and I was wondering if anyone had contacted you who was willing to pull that off
03:09:21 <shapr> Because I don't think pdf or ps output is so important. I think it's most important to get the information out there in a google indexed format.
03:09:42 <shapr> Yeah, kzm, aka Ketil Z. Malde wrote a tool that does part of that.
03:10:24 <shapr> Oleg and a bunch of other people have sent me email asking about someway to get pdf/ps. I get more feedback about that than anything else.
03:11:07 <boegel> well, how far is kzm with writing that tool ? 'cause I'd like pdf/ps output too :)
03:11:17 * shapr checks email...
03:12:20 <shapr> Hm, I can't find it in my email...
03:13:53 <xerox> I wonder if this could be helping: "Txt2tags converts a plain text file with little marks, to any of the supported targets: ...", and the list contains HTML, MoinMoin Page, LaTeX document, ... <http://txt2tags.sourceforge.net/>
03:14:23 <shapr> That's a good idea.
03:15:12 <boegel> it is
03:15:19 <boegel> so it exists already ? :)
03:15:20 * xerox bounces happily
03:15:51 <xerox> I think it does not traslate /between/ the formats, but the input format is fairly simple and goodlooking: <http://txt2tags.sourceforge.net/markup.html>
03:16:05 <shapr> That is a nice format.
03:16:23 <shapr> I could probably turn that into a MoinMoin plugin...
03:16:35 <boegel> shapr: go go go !
03:16:43 <xerox> That's what I was thinking suggesting it :-)
03:16:53 <shapr> But first, my unicycle is calling me..
03:16:59 <boegel> I think TMR would increase in popularity if you distribute each issue in wiki _and_ pdf/ps format
03:17:05 <shapr> Yeah, I think so too.
03:17:14 <xerox> bzzt = "All work and no play makes shapr a dull boy" : bzzt
03:17:32 * chris2 prefers markdown
03:17:35 <shapr> Though I'm still mystified by the huge demand for pdf/ps.
03:17:48 <shapr> What about a better print.css for MoinMoin?
03:18:46 <xerox> It sounds nice.  I think Alex Schröeder wrote a nice one for his wiki <http://oddmuse.org/>.  I could try to find it.
03:19:23 <shapr> Yeah, you could ask him. Too bad he's offline right now.
03:19:36 <shapr> If you find a nice print.css, that may be another option.
03:20:51 <shapr> Anyway, I'll bbl
03:20:53 * shapr wobbles away
03:21:16 <xerox> There it is: http://www.emacswiki.org/cgi-bin/wiki?action=browse;id=CSS;css=/paper/wiki.css
03:25:48 <scalopus> ski: I have got the basic skills with haskell, I consider it very interesting, so I am in this channel to learn from masters :)
03:26:26 <lightstep> do you understand the haskell demo?
03:26:49 <scalopus> lightstep: me?
03:27:16 <lightstep> yes
03:28:03 <scalopus> I don't know what it is :| I am quite new in haskell
03:28:41 <lightstep> @wiki HaskellDemo
03:28:42 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
03:28:47 <lightstep> it shows the syntax of haskell
03:28:55 <scalopus> aha
03:28:59 <lightstep> and some of the features
03:29:28 <scalopus> I am learing haskell with the book "The craft of functional programming with Haskell 2nd"
03:29:43 <scalopus> lightstep: ok, thanks, i will bookmark it :)
03:34:20 <boegel> shapr: the layout isn't the problem, it's the fact most people don't like to read on their screens, and pfd/ps makes it a lot easier to print
03:35:03 <xerox> boegel, a nice print.css would improve the ease of printing.  See the url I pasted before on emacswiki.
03:35:57 <boegel> xerox: okay, I see
03:36:16 <boegel> also, people might want to 'collect' papers, and with only an online version available, that's hard
03:37:12 <vegai> well, all the good browsers have "print to pdf", don't they?
03:37:40 <ski> (scalopus : ok :)
03:37:55 <tuomov> but otoh html is easier to read on screen than pdf/ps
03:38:05 <tuomov> pdf/ps is impossible for longer passages
03:39:05 <vegai> yes. I often feel frustrated that almost everything is in pdf (in the academic circles, at least)
03:39:06 <mflux_> but html is more difficult to read on bed?-)
03:39:26 <xerox> mflux_, it depends on the hardware using, eheh.
03:39:43 <xerox> <shapr> Here's the specs - http://h18000.www1.hp.com/products/tabletpc/tc1100/
03:39:45 * xerox grins
03:40:26 <vegai> just remember to not have any 9999999x9999999 sized images when using that
03:40:46 * xerox points at boegel 
03:41:09 <vegai> how heavy is that thing?
03:41:09 <astrolabe> xerox: Are you the xerox in the maths room on kgs?
03:41:16 <xerox> astrolabe, yep!
03:41:18 <vegai> 1.4kg..
03:41:22 <vegai> not bad
03:41:28 <astrolabe> :)  Great minds...
03:41:29 <vegai> though not exactly paper either
03:41:53 <xerox> astrolabe, nice :-)  How are you called up there?
03:41:57 <astrolabe> I'm tmc there.
03:46:08 <xerox> Time for a game? :)
03:46:23 <astrolabe> sure.  I haven't played for ages.
03:47:41 <xerox> Good!
03:48:20 <astrolabe> I've been trying to work out how to program go though, so I'm not completely rusty.
03:48:56 <xerox> astrolabe, ranked?  Anyway I don't have much time, what about a fast timing policy?
03:49:05 <xerox> err, faster, not that fast :-)
03:50:33 * boegel breaks xerox's finger for pointing at him
03:50:41 <boegel> don't point, it's not polite :)
03:52:11 <xerox> :(
03:53:15 <boegel> anybody know where I find article published in "Generic programming" can be found online ?
03:55:35 * boegel leaves to nurse his gf
03:56:54 <ndm> hi xerox
03:57:05 <ndm> i was going to do a pile of refactoring on hoogle this weekend
03:57:14 <ndm> any particular requests to make your life easier?
03:57:56 <rlj> ss/part
04:03:45 <camio> How do I convert an Int to a Double?
04:04:39 <Oejet> @type fromIntegral
04:04:39 <ndm> ((fromInteger . toInteger) (12::Int)) :: Double
04:04:45 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
04:05:15 <lightstep> @type toInteger
04:05:17 <lambdabot> toInteger :: forall a. (Integral a) => a -> Integer
04:05:21 <Oejet> @plugs (fromIntegral 4)::Double
04:05:26 <lambdabot> 4.0
04:06:14 <camio> Thanks
04:06:54 <camio> It seems a little convoluted, but it works.
04:08:40 <lightstep> 12 is actually short for (fromInteger (toInteger 12))
04:10:04 <camio> If that was the case, then compiling code with "x = 12" that didn't use the function x would result in an error, no?
04:10:45 <lightstep> there's a special case for Num. there is the `default' declaration
04:11:48 <lightstep> http://haskell.org/onlinereport/decls.html#default-decls
04:50:53 <xerox> astrolabe, I could have won! ;)
04:52:20 <vegai> should hs-plugins-0.9.8 be installable with ghc-6.4?
04:52:37 <Lunar^> vegai: the version in darcs repos is
04:53:01 <vegai> mmkay, I'll try that
04:54:14 <astrolabe> xerox.  Definitely.  I ripped you off!
04:55:49 <xerox> astrolabe, nice game anyway.
05:00:36 <vegai> hmm
05:00:48 <vegai> what should provide Language.Haskell.Hsx?
05:01:47 <vegai> oh, haskell-src-exts
05:02:15 <vegai> hs-plugins's configure-script should perhaps check whether that's installed
05:02:44 <xerox> How did you find "haskell-src-exts" from "Language.Haskell.Hsx" ?
05:11:43 <vegai> by google
05:11:56 <vegai> did I miss?
05:14:32 <stefanw> stupid question: is there a library function for deleting a list element by index?
05:18:19 <xerox> I think there is one somewhere on the wiki.
05:18:40 <TFK> @google haskell-src-exts darcs
05:18:42 <lambdabot> http://www.mail-archive.com/haskell@haskell.org/msg16431.html
05:18:51 <TFK> Blechs :-/
05:19:11 <jlouis> stefanw: nope, check http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
05:19:54 <jlouis> you can code it yourself with List.splitAt. However, using index often signifies that something is wrong in your code
05:20:49 <stefanw> jlouis: thanks
05:21:51 <jlouis> I am hacking python at the moment. And I am finding problems with the dynamic type system all the time, heh
05:22:37 <vegai> damn this hardware
05:22:53 <vegai> compiling anything a bit larger causes weird bugs *sigh*
05:22:58 <vegai> time to run a memtest, I guess
05:25:32 <nothingmuch> is CPS in haskell
05:25:35 <nothingmuch> oops
05:25:46 <nothingmuch> is CPS in haskell CPS due to something like a tail call optimization?
05:30:57 <Philippa> nothingmuch: it's CPS due to it acting like you're passing around continuations :-)
05:31:40 <nothingmuch> but in theory will it eventually return via the normal call chain?
05:32:49 <Philippa> yeah, but it's kinda obliged to in a pure language anyway. The question's /what/ returns
05:33:26 <Philippa> and you get the equivalent of not returning a real value if you're doing monadic CPS and something's of type m ()
05:35:19 <nothingmuch> hmm
06:56:09 <SamB> there seems to be something VERY wrong with PArrows...
06:58:06 <SamB> I'm running into infinite loops with many and my choice (where choice = foldr (<+>) zeroArrow)
08:17:48 <autrijus> hey
08:17:54 <autrijus> anyone got the new tex classes working?
08:18:00 <autrijus> (for hw2005)
08:18:11 <autrijus> I tried applying it to dons's hs-plugins source
08:19:08 <autrijus> by simply changing \author to \authorinfo
08:19:20 <autrijus> but apparently that kills the heading entirely
08:19:42 <autrijus> so I wonder if there's someone who has rendered .tex files that uses sigplanconf class that I can look at
08:29:44 <noj> what is hw2005?
08:30:19 <noj> Haskell Workshop 2005
08:33:23 <autrijus> yeah
08:33:32 <swiert> autrijus: the template on Daan's webpage works for me...
08:34:03 <autrijus> swiert: how do you declare your \authorinfo and \title ?
08:34:17 <autrijus> is it possible for you to send me (a url of) the beginning of the .text file?
08:34:33 <swiert> \authorinfo{Name1}
08:34:33 <swiert>            {Affiliation1}
08:34:33 <swiert>            {Email1}
08:34:47 <autrijus> I did that...
08:35:10 <autrijus> oh wow. I missed the \maketitle.
08:35:14 <autrijus> sorry. color me stupid.
08:35:22 <swiert> http://www.cs.uu.nl/~daan/hw2005/sigplanconf-template.tex
08:35:24 <autrijus> <- completely new to TeX
08:35:29 <autrijus> right. I copy-and-pasted incorrectly
08:35:36 <swiert> no problem.
08:35:38 <autrijus> it's all fine now. thanks.
08:38:57 <xerox> Where is the pugs repo?
08:39:30 <autrijus> xerox: http://svn.openfoundry.org/pugs/
08:39:41 <xerox> I mean the darcs one.  But I written in the wrong buffer :)
08:39:45 <xerox> *wrote
08:41:48 <autrijus> :)
08:41:58 <autrijus> http://perlcabal.org/~autrijus/darcs/pugs/
08:42:14 <xerox> Thank you, are they in sync? :)
08:44:37 <autrijus> I think so
09:05:35 <pflanze> Hello. I'm a haskell newbie. Given such idiomatic imperative code: bool flag=false; foreach(list,item){ bool result=calculate_on(item); if(result){flag=true} }, how would you turn that to haskell?
09:06:23 <pflanze> One could make a recursion which is taking two arguments, the rest and the current flag state.
09:06:45 <pflanze> But if there are more than one flag or value to gather, it's getting hairy.
09:06:48 <wilx> Hmm, I would say that it depends on what you want to do with the resulting flag.
09:06:50 <xerox> pflanze, keep in mind that in Haskell you do not have assignment.
09:07:00 <pflanze> xerox: exactly.
09:07:01 <Lemmih> or (map calulate_on list)
09:07:26 <xerox> I'm suggesting map too.  It seems the kind of computation you're doing.
09:07:36 <pflanze> Lemmih: ok, good point. Now what if there are two or more such flags?
09:07:37 <xerox> But it could be probably be a fold to, then you can have a state.
09:07:46 <marnix> @type any
09:07:49 <xerox> *too
09:08:14 * pflanze is going to think about using fold
09:11:21 <Lunar^> @plugs  Control.Monad.msum $ map (\x -> if x == 0 then Nothing else Just x) [0,0,0,42]
09:11:35 <Lunar^> Where's lambdabot!?
09:11:38 <Lemmih> dons: Where's lambdabot?
09:13:31 <xerox> @plugs foldl (const (==3)) False $ [1..5] -- :)
09:14:05 <TheHunter> apparently, lambdabot didn't survive the netsplit.
09:15:20 <xerox> I can compile aiskiii if needed.
09:15:50 <TheHunter> grrr, brown.freenode.net doesn't even resolve here.
09:16:43 <xerox> Anyway the List Monad is another answer to pflanze question.
09:17:27 <xerox> @botsnack
09:17:28 <lambdabot> :)
09:17:36 <xerox> @plugs foldl (const (==3)) False $ [1..5]
09:17:41 <TheHunter> @seen dons
09:17:43 <lambdabot> False
09:17:43 <lambdabot> dons is in #haskell. I don't know when dons last spoke.
09:17:47 <wilx> @moo
09:17:48 <lambdabot>          (__)
09:17:48 <lambdabot>          (oo)
09:17:48 <lambdabot>   /-------\/
09:17:48 <lambdabot>  / |     ||
09:17:48 <lambdabot> *  ||----||
09:17:49 <wilx> @yow
09:17:49 <lambdabot>    ~~    ~~
09:17:51 <lambdabot>      Cow
09:17:53 <lambdabot> What a COINCIDENCE!  I'm an authorized "SNOOTS OF THE STARS" dealer!!
09:18:02 <wilx> Wheee!
09:18:22 <xerox> Oh.
09:18:30 <TheHunter> @eval id 3
09:18:31 <lambdabot> 3
09:22:23 <xerox> @pl \x y -> x || y == 3
09:22:24 <lambdabot> (. (3 ==)) . (||)
09:22:34 <xerox> @pl \n x y -> x || y == n
09:22:35 <lambdabot> flip ((.) . (||)) . (==)
09:22:43 <xerox> @pl \x y n -> x || y == n
09:22:44 <lambdabot> (. (==)) . (.) . (||)
09:22:48 <xerox> Hmm, k.
09:23:04 <xerox> shapr, ping.
09:51:23 <TFK> @moo
09:51:24 <lambdabot>          (__)
09:51:24 <lambdabot>          (oo)
09:51:24 <lambdabot>   /-------\/
09:51:24 <lambdabot>  / |     ||
09:51:24 <lambdabot> *  ||W---||
09:51:24 <lambdabot>    ~~    ~~
09:51:26 <lambdabot>   Cow laden
09:51:28 <lambdabot>   with milk
09:52:22 <reffie> @ghc
09:52:22 <lambdabot>  magic number mismatch: old/corrupt interface file?
09:53:02 <lightstep> is there "the complete cabal guide for the debian user"?
09:53:08 <lightstep> or at least some guid?
09:53:10 <lightstep> e
09:53:50 <vegai> how would it differ from the same of other distros?
09:54:00 <vegai> or did you mean "debian developer"?
09:54:08 <lightstep> i dunno. maybe you would need some ghc6-cabal package?
09:54:14 <lightstep> i want to install PArrows
09:54:18 <TFK> howdy lightstep
09:54:38 <lightstep> hello TFK
09:54:47 <vegai> Cabal should be with ghc-6.4, right?
09:55:15 <TFK> What's cookin'?
09:56:28 <lightstep> libghc6-cabal-dev depends on ghc6 < 6.2.3
09:57:17 <vegai> whoah, lambdabot in top:
09:57:19 <lightstep> what does that mean? what do i do with Setup.lhs and with PArrows.cabal?
09:57:21 <vegai>  1825 scion     15   0 75196  45m 5880 S  0.0 18.0   0:10.21 lambdabot
09:57:25 <vegai> hungry little fella
09:57:40 <lightstep> TFK, i got envy of nothingmuch making a forth, so i want too
09:57:47 <lightstep> but mine'll be cooler
09:58:48 <TFK> "making a forth"?
09:59:18 <lightstep> a forth interpreter. it's as refresheming as implementing Scheme
10:00:11 <TFK> Heh. I know a guy who's obsessed about brainfuck.
10:02:17 <Philippa_> brainfuck's not meant to be at all practical to use though, whereas scheme and forth are
10:03:21 <lightstep> the only way to program in bf is to compile a turing machine or a stack machine
10:04:13 <vegai> huh...?
10:04:22 <vegai> I'm sorry about this if it breaks anything, but....
10:04:24 <vegai> @plugs [1..]
10:04:27 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
10:04:27 <lambdabot> 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
10:04:27 <lambdabot> 49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,
10:04:27 <lambdabot> 72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,
10:04:27 <lambdabot> 95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
10:04:28 <lambdabot> 113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,
10:04:30 <lambdabot> 130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,
10:04:32 <lambdabot> [24 @more lines]
10:04:45 <vegai> Interesting. My bot just died when I did the same
10:05:04 <vegai> perhaps ircnet got mad
10:25:58 <vegai> oh, there's something else wrong there, my version of lambdabot breaks down even just for "@plugs [1,2,3]"
10:26:11 <vegai> with an error message "Broken pipe"
10:26:23 <vegai> I guess the whole @plugs thing is somehow broken then
10:41:28 <stepcut> so, I am trying to setup GHC 6.4 with SDL on Windows. I have ghc6 installed, and now I need to install the SDL developer libraries (and then the haskell SDL bindings). But the SDL developer libraries come in two flavors: VC6 and MinGW, which do I want ?
10:42:58 * stepcut has never really developed anything under windows before, it feels weird...
10:43:19 <Lunar^> stepcut: mingw, I would say
10:44:02 <stepcut> ok
10:45:43 <Philippa_> the windows distros of GHC are mingw-based
10:45:59 * Lemmih ponders which SDL binding stepcut is using.
10:46:40 <stepcut> Lemmih: On linux I have been using this one, http://www.haskell.org/pipermail/haskell/2004-July/014313.html
10:46:54 <stepcut> Lemmih: but I was going to try switching to yours...
10:47:06 <stepcut> since that other one seems to be dead
10:48:06 <stepcut> Philippa_: do you think I need to install mingw in addition to ghc6, or should I just need ghc6 ?
10:48:58 <Philippa_> ghc6 has all you should need (GCC, linker)
10:49:13 <Philippa_> msys is often helpful for building stuff though
10:49:31 <Philippa_> on account of shell scripts not working in the windows command prompt
10:50:05 <stepcut> Philippa_: ok, I will keep that in mind
11:12:58 <wagle> anyone have opinions on ruby, ruby-on-rails, and/or macosx installers?
11:16:39 <jlouis> Heh, I have made about 10 erros today in Python. All of them would have been caught by a type system ;)
11:17:03 <jlouis> I guess somewhat the same would apply to ruby ;)
11:17:08 <esap> Hmm.. is there a good way to characterize subsets of CAT?
11:18:09 <basti_> uhm... black CATs, tigered CATs, black or tigered with a white belly....
11:18:30 <esap> CAT as in category of all categories.
11:18:43 <basti_> oh
11:19:08 <esap> more exactly, 2-category of all categories, functors and natural transformations
11:20:20 <wagle> i have barr and wells, 3rd ed in my car, but i'm only 50 pages in or so..  want me to go look to see what i can find them saying about CAT?
11:20:32 <astrolabe> Can you say more about how you want to characterise subsets?
11:20:55 <wagle> CAT is a class, by the way
11:21:01 <wagle> you mean subclasses?
11:21:23 <astrolabe> Right, so you could look at the 'small' categories.
11:21:55 <esap> wagle: yes. Well I'm thinking about a structure similar to a monoidal category, but with CxD -> E and not CxC -> C. So you get categories from a subset.
11:23:30 <esap> wagle: and then I'm planning on finding a subclass F of CAT that has the property  X \in F /\ Y \in F ->  X * Y \in F. But what kind of structure will be generated by the F?
11:24:26 <wagle> whats "*"?
11:25:19 <esap> wagle: a binary functor, (*) : C x D -> E, for C \in F, D \in F, E \in F.
11:26:01 <wagle> i've over my head here
11:26:14 <wagle> s/ve/m/
11:26:21 <esap> Yea, me too :-)
11:26:39 <astrolabe> Well.  I've got to go to dinner ;)
11:26:56 <esap> I'm thinking you could get a structure similar to a monoid, but with different "levels" separated to different categories.
11:27:06 <esap> or rather, monoidal categories
11:27:23 <esap> but the details are way over my understanding.
11:27:37 <wagle> doesnt a monoid have one object?
11:28:05 <esap> In a monoidal category, you have a binary functor (*) : C x C -> C.
11:28:21 <esap> I'm attempting to generalize that so that different C's there are separated.
11:29:46 <wagle> example?
11:29:53 <astrolabe> I think there is a maths channel
11:30:41 <esap> wagle: Well arrows are *pre*monoidal categories, with *pre*monoidal categories, which are a variation of monoidal categories.
11:31:17 <esap> wagle: the monoidal structure is required by the 'first' operation of the arrow classes
11:31:34 <wagle> yeah, i was getting a vague memory of a generalization of monoidal, but getting no details yet
11:32:03 <esap> I'm also trying to understand it better.
11:32:27 <wagle> which text you using?
11:33:08 <esap> wagle: For monoidal categories?
11:33:40 <wagle> sure..  or in general..
11:34:07 <esap> Wikipedia (http://en.wikipedia.org/wiki/Monoidal_category) + I'm reading "Lawvere: Sets for Mathematics"
11:37:01 <esap> and there are also the arrows papers that deal with premonoidal categories (from the arrows page)
11:38:14 <wagle> i found lawvere to be a bit lightweight..  you might try pierce (thin book) or barr and wells (thick)
11:38:28 <esap> wagle: lightweight?
11:39:12 <esap> wagle: I can't even understand fully the stuff with chaotic graphs in Lawvere.
11:40:46 <esap> You mean "Toposes, Triples and Theories"?
11:41:37 <esap> I understood about third of it :-)
11:41:47 <wagle> oh sorry..  i was thinking lawvere's "Conceptual Mathematics : A First Introduction to Categories"
11:42:35 <esap> ok, I haven't read that one. Sets for Mathematics is intended to give a good background on how to model Set theory with category theory.
11:44:12 <wagle> huh..  never saw "sets for mathematics" before..  does it cover non-well-founded sets?
11:46:08 <esap> I don't think so, though might be one of the excercises.
11:48:03 <esap> The book has lots of information about the axiom of choice,variable sets, epimorphisms, duality etc.
11:48:59 <esap> IMO, very good and comprehensive book.
12:05:00 <nothingmuch> lightstep: what are you going to do with your forth?
12:05:16 <esap> wagle: Hmm.. actually, maybe what he calls "variable sets" are non well-founded sets. Hmm.. interesting idea at least, I didn't actually realise it might be that :-)
12:05:51 <wagle> whats a variable set?
12:06:35 <esap> Well from the book, I'm not really sure about exact definition. He starts to talk about variable sets when he discussess Axiom of Infinity, and natural numbers.
12:06:48 <esap> and fixed points
12:07:42 <esap> I think he means some kind of sets that vary over time or something along those lines.
12:09:41 <esap> but I'm not sure he really defines the term clearly.
12:11:42 <esap> Anyway, he does give many examples of variable sets, such as a category S' of variable sets, where each object has an internal dynamic succ : X -> X
12:13:54 <jacobian_> is there a programming language theory channel?
12:14:35 <esap> other than #haskell? :-)
12:14:47 <esap> I don't know
12:15:49 <Spark> all the various other specific language channels have people in them with biassed points of view
12:15:53 <Spark> so just join them all and take the average
12:16:50 <jacobian_> seems scientific enough :)
12:17:13 <jacobian_> You sure it isn't a weighted average though?
12:17:25 <jacobian_> I mean... what about fortran?
12:23:04 <Spark> mm
12:25:33 <jacobian_> The big mistake Haskell made in the formulation of the language, was not including a common block :)
12:26:13 <autrijus> common block?
12:26:24 <autrijus> do { x; y; z }
12:26:27 <autrijus> like that?
12:26:30 <autrijus> it's in haskell :)
12:26:51 <xerox> ...even without the "do" part :)
12:26:58 <autrijus> that is right.
12:27:29 <Philippa_> I think he's referring to COBOL
12:27:46 <xerox> Philippa_, what does it mean?
12:28:02 <Philippa_> I never quite understood, all I've heard's my dad's ramblings on the subject
12:28:10 <Philippa_> he wrote a sparse matrix library in it
12:28:32 <jacobian_> common block was a completely untyped sequence of typed values.
12:28:49 <jacobian_> it was the responsability of the user of the common block to impose meaningful types on it
12:28:57 <jacobian_> It was scary to say the least.
12:28:58 <xerox> As in [1,'2',"three",Four] ?
12:29:20 <integral> isn't that FORTRAN's COMMON, not COBOL's?
12:29:33 <jacobian_> yeah its from fortran
12:30:14 <integral> it's a block of memory with a name, that you can refer to anywhere.  But in each function you have to specify what's in it, so in one it contains an integer, in another it's a float...!
12:30:28 <jacobian_> terribly evil
12:31:32 <wagle> common block is either a fixed length named ("labeled") block of memory, or a variable length unnamed ("unlabeled") block of memory..  each subroutine could break either up into variables of different sizes, types, and names in any way it wanted..
12:33:55 <wagle> so, in general, you really wanted all the subroutines to declare the common blocks in the exact same way..  of course, aliasing/recasting could be done for clever tricks
12:34:28 <jacobian_> that would of course tend to break horribly when changing architectures.
12:35:03 <jacobian_> But it made programming entertaining!
12:35:39 <jacobian_> Another interesting feature of fortran, is that procedures could be entered from more than one point.
12:35:53 <esap> Hmm.. it would be interesting to try to find a safe type system for common blocks :-)
12:37:16 <esap> Coroutines probably provide similar functionality
12:37:27 <jacobian_> Yeah, its a lot like a continuation
12:41:48 <jacobian_> Fortran also has implicit type declarations that hinge on the character representation of the variable.
12:41:51 <jacobian_> That bit me once...
12:42:35 <jacobian_> Also my compiler didn't bother to do type checking at all.  It would just quietly treat a double like an int.
12:43:55 <basti_> hmm
12:44:13 <basti_> yi breaks terminals so that they need reset, since i had to bash ghc's entrails
12:44:38 <xerox> basti_, does it break the terminal to you too?  Do you know how to fix it?
12:44:47 <basti_> "reset"
12:44:52 <basti_> thats a workaround
12:45:01 <basti_> it didnt before.
12:45:04 <basti_> that sucks galore.
12:45:42 * basti_ can't check what went wrong though, since he had to pull darcs completely anew again 
12:45:51 <basti_> oh but darcs keeps ALL patches doesnt it
12:48:21 <xerox> dons, ping
12:48:41 <xerox> basti_, I think it does.
12:49:37 <basti_> Tue May 17 07:46:37 CEST 2005  Don Stewart <dons@cse.unsw.edu.au>
12:49:37 <basti_>   * Make sure UI.hs can see YiCurses.h. Needed for -fvia-C
12:49:48 <basti_> this sounds like a possible cause
12:52:48 <basti_> dont see how i get the details though (this was through darcs changes)
12:53:53 <basti_> any darcs wizard here?
12:54:21 <basti_> or an apparentice?
12:55:10 <xerox> basti_, maybe -v ? :)
12:55:30 <basti_>     M ./Yi/Curses/UI.hs -1 +1
12:55:41 <basti_> not entirely helpful ;)
12:57:40 <Lunar^> darcs diff --last=n ?
12:57:44 <xerox> basti_, how can we refer that patch?
12:57:53 <basti_> ah okay
12:57:58 <basti_> its just a suspect
12:58:35 <basti_> by the date maybe?
12:59:08 <xerox> darcs diff --last=9 | less
12:59:17 <xerox> then /UI RET
12:59:19 <basti_> < {-# OPTIONS -cpp #-}
12:59:19 <basti_> ---
12:59:19 <basti_> > {-# OPTIONS -cpp -#include "YiCurses.h" #-}
12:59:24 <basti_> hmm
12:59:35 <basti_> i dont know.
13:00:31 <basti_> that doesnt appear to be the problem
13:04:28 <putter> I'm trying to _very_ quickly track down bibtex entries for a number of haskell papers.  A monadic framework for subcontinuations.  GADT. hs-pugins. STM.
13:05:31 <putter> Is there  a haskell bibliography (I haven't found one).  Community or personal?  A recent topical paper with bibtex on the web?  ...?
13:06:14 <putter> I will start hand generating entries, but I'm rusty, and that probably wont meet the deadline of the person I'm helping...
13:06:18 <putter> Thanks for any thoughts.
13:31:15 <SamB> why don't I see any laws for ArrowPlus in the Control.Arrow module?
13:33:53 <xerox> @index ArrowPlus
13:33:54 <lambdabot> Control.Arrow
13:34:08 <xerox> That's probably Control.Arrow.ArrowPlus?
13:35:12 <SamB> xerox: that is the fully qualified name of the class of which I am speaking, yes...
13:35:41 <xerox> OK, sorry.
13:36:22 <TheHunter> well it says that ArrowPlus should be a monoid.
13:37:12 <TheHunter> err, a ~> b is a monoid for all a and b.
13:37:34 <TheHunter> @wiki MonadPlus
13:37:35 <lambdabot> http://www.haskell.org/hawiki/MonadPlus
13:38:30 <xerox> TheHunter, do you know which GHC does actually permit the ~> syntax?
13:39:19 <TheHunter> zeroArrow >>> f === zeroArrow might be reasonable, too.
13:39:33 <TheHunter> xerox, doesn't ghc6.4?
13:39:52 <xerox> TheHunter, it doesn't either here or on lambdabot.
13:41:42 <TheHunter> version 6.5.20050522 supports it, i don't have access to 6.4 right now...
13:41:42 <xerox> @type arr id :: (Control.Arrow.Arrow (~>)) => b ~> b
13:41:50 <lambdabot> bzzt
13:41:57 <xerox> @type Control.Arrow.arr id :: (Control.Arrow.Arrow (~>)) => b ~> b
13:41:58 <lambdabot> bzzt
13:42:06 <xerox> TheHunter, hmm, OK thanks.
13:43:20 <TheHunter> hrmm,
13:43:22 <TheHunter> Prelude> :t Control.Arrow.arr id :: (Control.Arrow.Arrow (~>)) => b ~> b
13:43:22 <TheHunter> Control.Arrow.arr id :: (Control.Arrow.Arrow (~>)) => b ~> b :: forall (~> :: * -> * -> *) b. (Control.Arrow.Arrow ~>) => ~> b b
13:45:39 <TheHunter> http://haskell.org/ghc/dist/current/dist/, dead easy to install on i386-linux.
13:46:18 * xerox would love a .deb :-)
13:48:10 <TheHunter> i don't see why you would need a .deb. you can just extract it into any directory, run configure and make-inplace and adjust your pass. no need to mess around with /usr/local.
13:48:22 <TheHunter> arg, s/pass/path/
13:49:16 <xerox> Surely!  I think I'll try.
15:28:15 <xerox> sssssh!
15:28:25 <kaol> @moo
15:28:26 <lambdabot>          (__)
15:28:26 <lambdabot>          (oo)
15:28:26 <lambdabot>   /-------\/
15:28:26 <lambdabot>  / |     ||
15:28:26 <lambdabot> *  ||V---||
15:28:27 <lambdabot>    ~~    ~~
15:28:29 <lambdabot> Betty Ford-type
15:28:31 <lambdabot> cow with milk
15:29:10 <xerox> lambdabot keeps the record of lines written in the last hour or so.
15:29:39 <xerox> @code
15:29:42 <lambdabot> Strict.hs: ) where
15:29:46 <xerox> @code
15:29:47 <lambdabot> Complex.hs: asin z@(x:+y)  =  y':+(-x')
15:30:04 <xerox> @code
15:30:05 <lambdabot> QSemN.hs: ) where
15:30:19 <xerox> That's strange :-)
15:30:22 <xerox> @code
15:30:23 <lambdabot> Storable.lhs: writeWord8OffPtr (Ptr a) (I# i) (W8# x)
15:30:29 <xerox> @code
15:30:30 <lambdabot> Stable.lhs: A value of type @StablePtr a@ is a stable pointer to a Haskell
15:30:38 <Lemmih> @help code
15:30:39 <lambdabot>  @code, print random line of code from $fptools
15:30:48 <xerox> @code
15:30:49 <lambdabot> TopHandler.lhs: cleanUp :: IO ()
15:31:09 <Lemmih> Wouldn't be nicer to print a random declaration?
15:31:52 <xerox> Yea, some consistent output would probably be better :)
15:43:07 <lumi_> Hi lightstep
16:00:10 <wilx> Huh, where from does lambdabot get this @code?
16:01:20 <sorje> fptools afaik
17:09:20 <AtnNn> what is the usual cause of a "not i nscope: bracket" error?
17:11:02 <Lemmih> Omitting an 'import Control.Exception' line.
17:13:42 <lumi_> Could anyone help me make some code not ugly?
17:14:15 <Lemmih> Sure.
17:14:29 <lumi_> Thanks, can I paste it somewhere?
17:14:34 <Lemmih> @paste
17:14:35 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
17:16:01 <lumi_> Duly pasted
17:16:22 <lumi_> You will note the extreme confusion caused to the author by lists and concat
17:17:06 <lumi_> I put it all the way 'pon the bottom, as I don't know the custom and that seemed best
17:19:30 <Lemmih> urk
17:20:00 <lumi_> As in, "how ugly"?
17:20:22 <lumi_> Yeh but um, you see what I'm actually *trying* to say.. got clue?
17:20:56 <Lemmih> What's the type of MkState and genPiece?
17:21:41 <Lemmih> Oh, just discovered that genPiece is defined there.
17:22:31 <lumi_> genPiece is defined right there, it's PieceType -> (Player -> (Int, Int)) -> Piece
17:22:34 <lumi_> Yeh
17:22:42 <lumi_> Er, [Piece]
17:24:17 <Lemmih> What about only creating (say) white pieces and then mirroring them afterwards?
17:24:34 <lumi_> Afterwards?
17:25:09 <Lemmih> MkState (whitePieces ++ mirror whitePieces)
17:25:30 <lumi_> hm
17:35:20 <lumi_> Thanks lemmih
17:35:42 <lumi_> I meant to say before but I started implementing and got confused
17:36:08 <Lemmih> You're welcome (:
17:36:44 <Lemmih> Is it shorter now?
17:38:24 <lumi_> Yes, and also legible, now let's see if it also works
17:38:28 <lumi_> :P
18:00:47 <Lemmih> Does it work?
18:16:59 <lumi_> It does
18:17:18 * lumi_ -> sleep
18:18:05 <Lemmih> Good night.
20:56:45 <dons> @code
20:56:46 <lambdabot> Eq.hs: #endif
20:57:03 <dons> ok. hmm.. a heruistic for better @code
21:11:49 <dons> @code
21:11:50 <lambdabot> Exit.hs: exitFailure = exitWith (ExitFailure 1)
21:11:52 <dons> @code
21:11:53 <lambdabot> Chan.hs: readChan (Chan read _write) = do
21:11:54 <dons> @code
21:11:56 <lambdabot> Enum.lhs: | otherwise        = C# (chr# x) : go_up (x +# delta)
21:12:00 <Lemmih> @code
21:12:02 <lambdabot> Conc.lhs: let  delays = foldr insertDelay old_delays new_delays
21:12:46 <dons> higher signal/noise ratio, I think
21:13:29 <dons> @code
21:13:30 <lambdabot> Prelude.hs: Read(readsPrec, readList),
21:13:44 <Lemmih> Use haskell-src-exts and show full declarations?
21:14:51 <dons> hmm... parsing is a good idea..
21:15:45 <Lemmih> It's a shame haskell-src-exts can't parse all the code in fptools.
23:50:55 <MachinShin> night all
