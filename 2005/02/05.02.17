00:01:36 * Gokee2 is away: 
00:02:14 * Gokee2 is away: 
00:03:37 <mflux> does anyone know if gokee2 is around?
00:03:42 <Gokee2> I am
00:03:50 <mflux> ..
00:04:02 <Gokee2> Trying to turn off the damn msgs
00:13:47 * Cale struggles to maintain purity while writing lisp code.
00:14:14 <Lemmih> Bye #Haskell. I'm going to sleep.
00:14:30 <Cale> So much expectation that you'll want to destructively update things.
00:14:50 <Cale> night Lemmih
00:18:52 <Itkovian> meunink
00:41:24 <boegel> @seen duncna
00:41:25 <lambdabot> I haven't seen duncna
00:41:27 <boegel> @seen duncan
00:41:27 <lambdabot> I haven't seen duncan
01:13:41 <glimming> an early morning question: is untyped lambda calculus strongly normalizing?
01:13:41 <TFK> Did I get to spam with https://spoj.sphere.pl/ before? It's a fun problem-solving site, and Haskell (and pretty much everything but the horrid C/C++/Pascal/Java alliance) is underrepresented.
01:14:06 <glimming> (\x -> x x) (\x -> x x)
01:14:15 <glimming> does not have normal form.
01:14:53 <glimming> so not SN?
01:15:00 <glimming> how about WN?
01:15:05 <glimming> in presence of, say, eta rule?
01:27:56 <shrimpx> no, untyped lambda calculus is turing complete
01:28:08 <shrimpx> so it's weakly normalizing
01:29:03 <shrimpx> maybe i got my terminology mixed tho
01:29:46 <glimming> well if it were weakly normalising, then there would be a normal form to every term, under _some_ reduction sequence.
01:30:58 <glimming> Let me introduce you to \Omega = (\x.xx)(\x.xx).
01:31:06 <glimming> Can you please reduce this to a normal form?
01:31:38 <glimming> Or am I asking too much?
01:32:22 <glimming> ( I think I am because I think you can't)
01:32:44 <shrimpx> um so i am familiar with the properties of the untyped lambda calculus. i seem to be unfamiliar with the exact definitinos for {weakly,strongly,not} normalizing
01:33:18 <shrimpx> strongly normalizing means there's only one possible reduction sequence for each term, right?
01:33:29 <glimming> heh, If I knew this well, I would not be asking in the first place!
01:33:34 <glimming> indeed
01:34:06 <shrimpx> and weakly normalizing means that there may be more than one sequence but they all lead to a NF?
01:34:22 <glimming> I no
01:34:23 <glimming> no
01:34:34 <glimming> it means merely that some seq leads to n.f.
01:34:49 <glimming> do not confuse WN/SN with confluence/CR
01:35:25 <shrimpx> oic
01:36:13 <shrimpx> so the untyped lc is then not normalizing
01:38:03 <glimming> Nope
01:38:10 <glimming> The typed is I think (simply typed).
01:38:14 <glimming> But if I am wrong, advise me.
01:39:37 <shrimpx> so your \Omega thingie can't be encoded in simply typed LC
01:39:49 <glimming> Try to give it a type.
01:39:56 <glimming> You'l need O->O=O
01:40:26 <shrimpx> yea and assuming you don't have infinite types, that doesn't hold
01:42:26 <shrimpx> damn google is not helping with this WN/SN stuff
01:42:27 <shrimpx> heh
01:43:48 <lightstep> Is there work towards impproving GHC error messages?
01:45:09 <shrimpx> i hope so
01:47:00 <lightstep> They are only helpful if you have type annotations everywhere. And the suggestions are horrible. "It would work, if you add this long list of unreasonable instances"
01:48:41 <shrimpx> glimming: so i believe that the untyped LC is not normalizing given that you can encode terms like \Omega which is definitely not normalizable wrt the beta rule
01:49:02 <glimming> shrimph, consider recursive types instead
01:49:09 <glimming> shrimpx sorry
01:49:27 <glimming> you _can_ type this term in Haskell
01:49:31 <glimming> (try)
01:49:50 <glimming> shrimpx, sure
01:49:52 <shrimpx> what would that prove?
01:49:57 <glimming> nothing
01:50:14 <shrimpx> haskell is based on a typed LC but is extended with lots of stuff
01:50:16 <glimming> only that Haskell is definately not WN or SN
01:50:18 <shrimpx> like recursion
01:50:32 <glimming> (I think...)
01:50:47 <glimming> shrimpx, gotta work now
01:50:51 <shrimpx> haskell is not normalizing but that doesn't show that typed LC's are not normalizing
01:50:59 <shrimpx> since recursion in haskell is a primitive
01:51:04 <shrimpx> it's not intrinsic to the calculus
01:51:14 <shrimpx> have fun
01:51:32 <glimming> (check FPC)
01:51:39 <shrimpx> heh
01:54:25 <shrimpx> lightstep: anyway yea, error messages suck
01:55:28 <shrimpx> supposedly it's a hard problem to give constructive error messages in inference systems; some people are working on the general problem
01:56:16 <TFK> How come?
01:57:31 <shrimpx> how come it's a hard problem?
01:57:42 <TFK> Yes.
01:59:14 <shrimpx> i gather it's due to the fact that the compiler generates lots of dummy typed variables in type checking and that's what you see in errors... eg type a -> b -> c -> d expected but got a -> b -> d is not extremely informative
01:59:25 <shrimpx> plus i guess in haskell the problem is exacerbated by type classes
01:59:49 <shrimpx> shrug
01:59:57 <TFK> Oh. What other information does one need? Isn't that a syntax error?
02:00:25 <shrimpx> no, it's a type error
02:01:35 <shrimpx> like
02:01:37 <shrimpx> let f x y z = x + y + z in f 9 "x"
02:01:50 <shrimpx> that's syntactically correct
02:01:54 <shrimpx> the error is
02:01:55 <shrimpx>     No instances for (Num [Char], Show ([Char] -> [Char]))
02:01:55 <shrimpx>       arising from the literal `9' at <interactive>:1
02:01:57 <shrimpx> :)
02:02:23 <TFK> o_O;;
02:04:46 <glimming> the hack:
02:04:47 <glimming> >  type Plus f g t o1 o2 = Either (f t o1 o2) (g t o1 o2)
02:04:47 <glimming> >  type f :*: g = Plus f g
02:04:49 <glimming> works
02:04:55 <glimming> how about that, kosmikus=
02:15:21 <glimming> Hmm, can you use Functor instances on such type synonyms?=
02:17:33 <lightstep> But a better error message is possible. First, error messages about `it' not being Show should be special-cased. And the Num error could be "f is of type Num a => a->a->a->a, and I saw f 9 "x". There is no type t such that Num t and 9 :: t and "x" :: t.
02:20:35 <glimming> (above did not work, and in this case because of partial application of type synonyms -- but hey, it parses)
02:21:24 <glimming> So here is question. I am not so good at type classes.
02:21:47 <glimming> And I wonder if you can write e.g. instance Functor (MySynonym t a) where ...
02:22:02 <glimming> for some type synonym MySynonym which is built up from data constructors.
02:22:06 <glimming> Clearly the answer is NO?
02:22:27 <glimming> Because why would I?
02:26:43 <lightstep> It's possible to define instances for synonyms.
02:27:14 <glimming> Ah,  but why, since they would follow from data constructor isntances?
02:27:21 <glimming> I assume that () is a functor, for example, and (a,x) is also a functor
02:27:27 <glimming> and Either as well?
02:27:40 <glimming> So all types built up from these using synonyms etc should be instances as well.
02:27:57 <glimming> In a sense all type synonyms are generated by data constructors
02:28:32 <glimming> is the hiarechical ghc library documentation available  as printable PDF file (with colour, preferrably) or can it be printed from source using lhs2TeX?
02:28:55 <glimming> It would be good to have this in printed form. No link at ghc page to the hierarchical libraries though
02:29:26 <kosmikus> it cannot be printed using lhs2TeX atm, but it's somewhere on my todo list to interface haddock and lhs2TeX ...
02:29:34 <glimming> aha
02:29:42 <glimming> But perhaps haddock can generate pdf?
02:29:47 <glimming> Also, is the ghc user guide available in COLOUR?
02:30:33 <TFK> How can I simplify map read $ map reverse ? map (read reverse) doesn't work.
02:31:23 <tromp> map (read . reverse)
02:31:50 <TFK> D'oh! Thanks ^_^;
02:58:57 <autrijus> rehi.
03:22:04 <TheHunter> wow, curry is cool.
03:25:31 <TheHunter> and what's even cooler, the speed of reflect+reify+list monad is comparable to that of the m√ºnster curry compiler.
03:37:58 <TheHunter> and it works in ghci now. Yay!!!
04:05:55 <musasabi> first successfull run with custom sockets using epoll ^_^
04:06:31 <glimming> What's the difference between declaration and definition?
04:07:43 <lightstep> glimming, like declaration vs. definition of independence?
04:08:12 <lightstep> More to the point, you can declare any proposition, but definition is a reduction rule.
04:10:10 <j4r0> Hi there. I'm generating list : [ (a,b,c) | x <-n, y<-n, z<-n, x < y, y < z, x /= inv y, y /= inv z, x /= inv z ], where n is [ 0 .. 5 ] and inv calculates x + 3 mod 6. But I'm curious, whether there exists any way to do this generation better (faster).
04:15:08 <Itkovian> hmm
04:15:30 <lightstep> j4r0, did you mistype?
04:17:48 <Itkovian> let {n = [0..5]; inv = (\x -> mod (x + 3) 6)} in [ (x,y,z) | x <-n, y<-n, z<-n, x < y, y < z, x /= inv y, y /= inv z, x /= inv z ]
04:18:03 <Itkovian> [(0,1,2),(0,1,5),(0,2,4),(0,4,5),(1,2,3),(1,3,5),(2,3,4),(3,4,5)]
04:18:15 <Itkovian> seems pretty fast to me ;-)
04:18:38 <TFK> How can I get n lines from stdin? Or get the input line-by-line until EOF.
04:19:51 <lightstep> TFK, gtkLine and catch can do it (i don't know the better way, though).
04:20:23 <TheHunter> @type replicateM 4 getLine
04:20:28 <lambdabot> bzzt
04:20:35 <TheHunter> @type Control.Monad.replicateM 4 getLine
04:20:36 <lambdabot> Control.Monad.replicateM 4 getLine :: IO [String]
04:21:10 <TFK> Ooh, that looks shiny! Thanks.
04:21:11 <TheHunter> this gets 4 lines (no error handling on eof though, you'll need catch for that)
04:21:26 <TFK> I wonder, is there any recipe repository that lists such useful code?
04:22:44 <lightstep> TFK, it's in the Standard Libraries.
04:22:58 <TFK> Yes, but those are huge.
04:23:50 <lightstep> The really useful parts are Prelude, Monad and List. These are almost part of the language. The others are just libraries.
04:24:16 <TheHunter> TFK, you know that? http://www.zvon.org/other/haskell/Outputglobal/index.html
04:24:45 <TFK> Monad Utilities doesn't even list replicateM :-/
04:25:21 <TFK> TheHunter, yes, but I noticed it's not fully detailed.
04:25:38 <TheHunter> that's true.
04:25:44 <TFK> So I'm using the Online Report, but I'll use both from now on.
04:26:19 <TheHunter> this is the official documentation: http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Monad.html
04:26:40 <TheHunter> and you shouldn't be too afraid to look in the source.
04:27:00 <TFK> I'm a bit baffled that there isn't a full language/standard library references that list and explains what everything does in plain English :-(
04:28:44 <Lunar^> TFK: GHC docs?
04:29:28 <TFK> Lunar^, notice how in that link they don't actually explain replicateM.
04:29:49 <lightstep> Well, it _is_ conditional, in some sense.
04:30:18 <TFK> Conditional?
04:31:25 <lightstep> replicateM 0 doesn't do the action, and replicateM 1 does it once
04:31:43 * TFK nods
04:36:13 <lightstep> Sorry, I just got it. My textual browser confused me.
04:39:00 <Lunar^> TFK: *sigh* It's sometime hard to explain what everything does. Especially with over-generic functions like some that are in the prelude
04:39:39 <Lunar^> TFK: Name + type is enough after a few try
04:41:10 <Lunar^> TFK: ``map'' is the exact example of this... it's harder to explain in natural language than to show the type
04:42:16 * TFK shrugs
04:42:29 <TFK> Maybe after I've read enough function signatures.
04:43:05 <TFK> Meanwhile, I'm longing for Python's help(foo). (And yes, help(map) is meaningful :-)
05:00:39 <lightstep> Is there a standard function to flip a FiniteMap?
05:22:45 <boegel> hey everyone
05:22:54 <TFK> g'day
05:27:26 <TFK> Woo! ADDREV in Haskell submited to SPOJ. Runs 0.16 seconds faster than my Python solution, too xD
05:30:36 <Lunar^> TFK: SPOK?
05:30:41 <Lunar^> SPOJ
05:31:15 <jlouis> spoj?
05:31:54 <TFK> I see I didn't spam enough! https://spoj.sphere.pl/ <--- problem-solving site, includes Haskell.
05:32:54 <TFK> I'm trying to code solutions for the stuff I already solved in Haskell.
05:34:08 * TFK returns to chapter 4 of the Gentle Introduction
05:43:18 <Heffalump> anyone know how to make a qualified reference to an operator (from a module I have to import qualified)?
05:43:50 <Itkovian> NAME.(op) ?
05:44:02 <Heffalump> tried that
05:44:23 <xerox> darcs
05:44:27 <xerox> whoops.
05:44:34 <TheHunter> [1,2,3] Prelude.!! 2
05:45:33 <Heffalump> oh, maybe that works
05:45:37 <Heffalump> the operator here is .&. :-)
05:46:12 <TheHunter> (+1) Prelude.. (+2) $ 3 works...
05:46:21 <Heffalump> ok, ta.
05:48:18 <shapr> achoo!
05:48:45 <xerox> Snuff?
05:48:55 <shapr> xerox: snow
05:49:04 <xerox> yummy
05:57:28 <shapr> boegel: goedemorgen!
05:58:12 <boegel> shapr: goedemiddag :)
05:58:27 <autrijus> whoa. shift/reset is crazy.
05:58:45 <autrijus> <- just implemented various loop / conditional constructs
05:58:50 <autrijus> and each one is like, 5 lines
05:59:40 <shapr> continuations are the basis for all control structures!
05:59:57 <shapr> Dictators would never have a chance if we taught the citizens about shift/reset!
05:59:58 <autrijus> delimited ones doubly so!
06:00:09 <autrijus> shapr++
06:00:12 * shapr grins
06:01:14 <shapr> "call/cc pwnz u!" -- Freddy "shift/reset" Neechy
06:01:42 <shapr> Sometimes my humor is too surreal even for me.
06:02:40 <shapr> autrijus: hey, I mentioned Pugs on LtU, when is the Pugs slowdown coming?
06:03:04 <Itkovian> xerox: i just sent you a 27 page pdf. has it finished printing yet?
06:03:16 <jlouis> shapr: the problem with that humour is that it is hard to get for the girlfriend. Unless she happens to study math/cs herself, hehe
06:04:08 <xerox> Itkovian, don't touch my spool!
06:04:21 <Itkovian> :-)
06:04:27 <shapr> Misquoting Friedrich Nietzche and Guy Steele in the same line should be a Thelony (monk) offense.
06:04:59 <TFK> I feel sharp stuff flying all around me o.o;;
06:05:53 <shapr> Someone is throwing knives at you? This is sometimes a sign that your girlfriend wants you to leave the computer.
06:06:35 <TFK> But only sometimes! It's not proven!
06:07:34 <jlouis> shapr: it means she wants you to do the dishes too afterwards
06:09:34 <boegel> suposse I have a element of type (Maybe (X,Y))
06:09:47 <boegel> how do I get the X-element ? something similar with fst...
06:10:41 <shapr> \(Maybe (x,_)) -> x
06:10:46 <shapr> er wait...
06:10:52 <boegel> okay, thanks :)
06:10:55 <shapr> \(Just (x,y)) -> x
06:10:55 <shapr> doh
06:11:06 <TFK> Just?
06:11:16 <shapr> just what?
06:11:18 <TFK> Oh, those are built-ins, n/m.
06:11:35 <shapr> dem bwaz be jammin wid riddum man!
06:11:56 <Igloo> There may not be an X element to get, of course
06:12:02 <TFK> You have a funny accent.
06:12:14 <shapr> TFK: I grew up in Alabama, what do you expect?
06:12:15 <jlouis> Maybe> :type (fst . fromJust)
06:12:15 <jlouis> fst . fromJust :: Maybe (a,b) -> a
06:12:19 <boegel> Igloo: I'm sure there is...
06:12:57 <TFK> For you to stay there? :-P
06:13:20 <shapr> TFK: watch out, I know where you live.
06:13:39 <shapr> Same place I live.. on the Internet!
06:13:43 <TFK> HAHA! My army of killer ninja monkeys is undefeatable!
06:14:00 <TFK> So true...
06:14:02 <shapr> I'll hire the Bananas in Pajamas to take out the Monkeys!
06:14:30 <TFK> :O
06:15:15 <shapr> http://www.abc.net.au/children/bananas/default.htm
06:15:40 <TFK> Unforunatelly, I know what it is and don't really need to go to that link >_<
06:15:46 <shapr> smart move!
06:15:50 <Itkovian> hmmm ...
06:16:22 <Igloo> So, have you seen http://www.cis.upenn.edu/~bcpierce/attapl / http://www.amazon.com/exec/obidos/tg/detail/-/0262162288/ shapr?
06:17:12 <shapr> Yes, I even sent email to BC Pierce pointing out some broken links on his homepage.
06:17:21 <Igloo> Oh well  :-)
06:17:24 <shapr> But I do not yet have a copy of said book.
06:17:42 <shapr> I've been trying to keep myself from ordering it till I have some free time to read it.
06:18:03 <shapr> I'm particularly interested in the chapter on region allocation, it's said that's the best yet intro to regions.
06:19:01 <Philippa> I ordered a while back, Amazon UK aren't going to have it to dispatch for another couple of weeks at least though
06:19:02 <jlouis> shapr: did you read the ph.d thesis of makholms?
06:19:08 <shapr> No, not yet.
06:19:14 <jlouis> it is the best description of region inference I have seen
06:19:17 <jlouis> and the most thorough
06:19:27 <shapr> I got partway in and had a small explosion of ideas.
06:19:45 <shapr> Then my woman came in the room and asked me if I was going to meet my deadline or not...
06:20:02 <shapr> I let my deadline have lunch by itself of course.
06:20:54 <shapr> GHC + Parr + regions = much interest from me.
06:21:40 <shapr> What else would be useful for automatic parallelization? Does the parallel skeletons stuff fit into that? What about function shapes from FISh etc?
06:25:11 <jlouis> I am not sure regions will help you that much, but I may be mistaken
06:25:39 <Philippa> I can't see them having much direct impact. I mean, they'd be cool for the Cell-on-PS3 situation...
06:25:55 <Philippa> ...but then I'd rather do explicit threading there too
06:26:53 <jlouis> If the Cell is going to be coded like the PS2, then you setup a stream between the vector processors, upload a littel tight floating point SIMD loop to them. Point to the start of the data and go. Then you wait for the interrupt for finish
06:27:17 <Philippa_> it's not like the PS2
06:27:27 <Philippa_> muchly different memory architecture, for starters
06:27:53 <jlouis> Indeed, but the PS2 has 32k cache before it's vector processors
06:28:04 <Philippa_> so?
06:28:26 <Philippa_> the Cell has each vector processor having direct access to up to 64 meg of memory
06:28:43 <jlouis> oh.
06:28:46 <jlouis> not 256k?
06:28:46 <Philippa_> I've forgotten the details, but it's also possible to 'flow' data between them
06:28:56 <Philippa_> that might be the size of the cache on each processor
06:29:23 <Philippa_> very, very different memory architecture
06:29:23 <jlouis> I would rather stream from one vector to the next
06:29:32 <jlouis> vector CPU
06:29:34 <Philippa_> this is roughly it, yes
06:29:57 <jlouis> and I am having a hard time figuring out how regions should help me there
06:29:58 <Philippa_> so you can kiss the PS2 system bottleneck^Wbus goodbye
06:30:18 <Philippa_> just the usual "I know when I deallocate"/"I can do memory pools" stuff
06:30:39 <jlouis> ah
06:30:50 <Philippa_> but the former's useful
06:31:01 <Philippa_> it means you'll never stall a transfer GCing your local heap
06:31:10 <jlouis> yup
06:32:19 <jlouis> ah, makes sense now
06:33:21 <Philippa_> basically, I reckon you want good control over how the processors interact on PS3
06:34:02 <Philippa_> though AIUI you'll only need to go as far as "I have a task using n interacting processors here, allocate 'em for me"
06:34:11 <Philippa_> supposedly the OS'll take care of the rest
06:35:14 * jlouis nods
06:40:29 <shapr> konichiiwa juhp-san
06:44:16 <ikegami--> :))
06:48:22 <shapr> konichiwa ikegami--san
06:50:39 <boegel> @type fail
06:50:40 <lambdabot> fail :: forall m a. (Monad m) => String -> m a
06:50:50 <boegel> @type return
06:50:52 <lambdabot> return :: forall m a. (Monad m) => a -> m a
06:51:45 <ikegami--> today, I have stayed Sweden almost one month
06:51:58 <ikegami--> and will stay until the end of March
06:52:08 <shapr> cool!
06:52:21 <Oeje1> ikegami--: How do you like it?
06:52:37 <ikegami--> yes, I like this winter here very much
06:53:35 <jlouis> I have a cold, I have to finish this goddamn SML project, It is cold outside and I do not want to hack anymore LaTeX
06:55:02 <Itkovian> if I'd like to read data from 3 files, say given their filenames at command line, i.e. I can get them with getArgs, and the data of the three files is to be dropped in three lists in a triplet (l1,l2,l3), how do I proceed?
06:55:18 <Itkovian> do { filenames <- getArgs; ...
06:56:46 <boegel> @tyep getArgs
06:56:46 <lambdabot> Sorry, I don't know the command "tyep", try "lambdabot: @listcommands"
06:56:49 <boegel> @type getArgs
06:56:51 <lambdabot> bzzt
06:56:56 <boegel> @index getArgs
06:56:57 <lambdabot> System.Environment,System
06:57:02 <boegel> @type System.getArgs
06:57:03 <lambdabot> System.getArgs :: IO [String]
06:57:16 <Itkovian> yeah, and how do I open them files?
06:57:18 <boegel> filenames :: [String]
06:57:30 <Itkovian> no. filename :: IO [String]
06:57:30 <boegel> map open fileNames ?
06:57:47 <boegel> filenames <- getArgs    =>     filenames :: [Srring]
06:58:01 <boegel> s/Srring/String
06:58:08 <Itkovian> ok.
06:58:13 <jlouis> Why is it called a finite map, as opposed to just a map??
06:59:13 <Itkovian> gotta go.
06:59:17 <shapr> gbye
06:59:20 <Itkovian> first swimming for my kid.
06:59:23 <Itkovian> ttyl.
06:59:28 <Itkovian> i.e. tonight.
06:59:32 <shapr> jlouis: I think because it's a 1 to 1 mapping.
07:00:40 <jlouis> shapr: oh, it need not be injective
07:01:11 <Cale> jlouis: it acts on a finite domain
07:01:15 <jlouis> representing it as a list [(1,1), (2,1)] is a finite map, but looking at it as a map, it is not injective
07:01:35 <jlouis> Cale: Yes, is that the definition?
07:01:39 <Cale> yes
07:01:44 <jlouis> It seems the plausible definition
07:01:44 <Cale> afaik
07:02:28 <jlouis> I'll buy it. We take a finite map to be a map where the domain is finite
07:02:48 <jlouis> with a definition. Now nobody can come and say I am doing something wrong ;)
07:03:35 <Cale> Usually together with the implication that measures are being taken to make that efficient, but it's obviously not necessary.
07:04:10 <Cale> While a finite list of pairs can represent a finite map, it's usually not the greatest way to do so.
07:04:32 <jlouis> Cale: I'll leave that out of the definition. My implementation uses Red-Black trees ;)
07:04:47 <jlouis> if I remember correctly
07:04:50 <jlouis> yup..
07:10:43 <glimming> What is the difference between newtype and data?
07:10:52 <glimming> kosmikus, can I help you to interface haddock?
07:11:04 <glimming> Maybe I will learn something about parsing along the way.
07:11:13 <glimming> Do you use parser monad for lhs2TeX ?
07:12:00 <TheHunter> in data Foo a = Foo a, a Foo a can be either _|_ or an a
07:12:09 <shapr> Last time I interfaced to a haddock, I had a stomachache from too much salty fish.
07:12:18 <TheHunter> data Foo a = Foo !a is almost the same as newtype, but there are differences in pattern matching.
07:12:49 <glimming> Shall we give it a try together, I mean haddock?
07:12:59 <glimming> A group excerise.
07:13:03 <TheHunter> foo (Foo x) = x is strict if Foo is a data and non-strict if it's a newtype.
07:13:15 <glimming> So you are saying newtype enforces strict evaluation?
07:13:27 <shapr> I don't have time to join any group exercises this month.
07:13:38 <TheHunter> data (with strict fields) enforces strict evaluation
07:13:49 <glimming> ! you mean?
07:14:03 <glimming> Can we not have undefined members of newtype -types?
07:14:19 <glimming> If I define newtype Foo = Mine Int -> Int
07:14:28 <glimming> then I can surely have undefined: Foo?
07:14:49 <TheHunter> of course.
07:14:57 <glimming> newtype Foo a then?
07:15:06 <glimming> Do you mean partial type constructors??
07:15:09 <glimming> I am at loss.
07:15:17 <TheHunter> ok, lemme try again
07:15:18 <glimming> Is there an expert on haddock here, btw?
07:15:39 <TheHunter> there are three ways to define a type alias thingy:
07:15:47 <TheHunter> data Foo a = Foo a
07:15:52 <TheHunter> data Foo a = Foo !a
07:16:03 <TheHunter> data Bar a = Bar !a
07:16:10 <TheHunter> newtype Baz a = Baz !a
07:16:33 <glimming> newtype Bajs a = Bajs a
07:16:38 <glimming> then?
07:16:39 <jlouis> so data is lifted domain theoretic opposed to newtype. But how does it get the _|_ type? If we have to return a constructor and ends up in an infinite loop?
07:17:04 <TheHunter> sorry, i meant newtype Baz a = Baz a the one above is illegal.
07:17:06 <shapr> glimming: lambdabot's HaddockModule has the @index command. Interfacing with Haddock is pretty easy actually.
07:17:21 <shapr> @index anyChar
07:17:22 <lambdabot> Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Char
07:17:24 <TheHunter> Foo is lifted, Bar and Baz not.
07:17:44 <glimming> But all types in Haskell contains the undefined element?
07:17:54 <glimming> bot
07:17:57 <TheHunter> however, Bar and Baz are still different which can be observed by pattern-matching.
07:18:07 <glimming> no wonder lambda bot is not terminating
07:18:32 <TheHunter> a "Foo Bool" can be _|_, Foo _|_, Foo True and Foo False.
07:19:08 <jlouis> what about Bar? It is strict in it's parameter
07:19:28 <jlouis> Bar Bool can obviously Be Bar True, Bar False...
07:19:59 <jlouis> Bar _|_ seems possible too
07:20:05 <glimming> jlouis, please explain how they are lifted. Thinking denotationally, are we working in the cateogory Cppo of complete _pointed_ posets
07:20:06 <TheHunter> right.
07:21:21 <jlouis> glimming: I think we are running into notational hell here. By lifting, I merely mean the adjoining of _|_ to the type, so lift(A), where A is a set of values is A u {_|_}
07:22:10 <jlouis> TheHunter: I am confused if Bar can be of Type _|_.
07:22:50 <TheHunter> i'd say Bar can be _|_, Bar True, Bar False, but not Bar _|_.
07:23:30 <jlouis> ah, since the a is strict
07:23:33 <jlouis> makes sense
07:23:59 <TheHunter> "Baz a" is just another name for "a", which happens to behave different wrt to typechecking.
07:24:48 <TheHunter> s/different/differently/
07:24:51 <TheHunter> s/ to//
07:25:06 <jlouis> glimming: I still lack anything but the most basic Category Theory. I do not know about the category Cppo at all
07:25:56 <TheHunter> glimming, i think we're in cpo here.
07:26:17 <glimming> Well, it is a bit strange with Cpo-categories, and the choice is hard (we easily arrive at inconsistencies)
07:26:37 <glimming> Anyways, I do not understand how data is lifted but not newtype.
07:26:55 <glimming> We can work in various forms of Cpo-categories.
07:27:18 <glimming> The one I am talking about has a bottom element \bot "in" all Cpos, thus pointed.
07:27:28 <glimming> But lifting it adjoins another bottom eleemnt.
07:27:33 <glimming> I think...
07:28:17 <jlouis> complete partial orders are partial orders in which every chain is.... finite??
07:28:57 <jlouis> I have forgot and use the theory too little, grrrr
07:29:36 <glimming> omega-complete but never mind that
07:29:49 <musasabi> Are the cvs ghc-docs displayed somewhere in the web? In particular for cabal?
07:30:16 <glimming> (every directed set has lub)
07:30:34 <jlouis> glimming: ah yes
07:30:54 <TheHunter> http://en.wikipedia.org/wiki/Complete_partial_order
07:31:06 <glimming> So back to the main question.
07:31:14 <glimming> What is the difference between newtype and data put succinctly?
07:32:11 <TheHunter> the data has an additional (lifted, if you will) bottom element.
07:32:49 <TheHunter> Foo (): _|_ <= Foo _|_ <= Foo ()
07:33:14 <TheHunter> Baz (): Baz _|_ == _|_ <= Baz ()
07:34:20 <glimming> Are there any practical differences between them following this (other than for Mu combinator),  in everyday programming?
07:34:30 <glimming> So newtype == data except for this??
07:34:36 <glimming> Same syntax exactly?
07:34:48 <TheHunter> same syntax.
07:34:50 <glimming> I wonder if pointed=with bottom
07:34:59 <glimming> btw
07:35:22 <TheHunter> the implications can become quite huge in some situations.
07:35:32 <glimming> Right so if Baz _|_  is evaluated strictly then we have _|_ = Baz _|_ for sure
07:35:35 <glimming> so if we use !
07:35:36 <glimming> we would have
07:35:42 <glimming> _|_ <= Foo ()
07:35:45 <glimming> the best one
07:35:49 <glimming> no extra element
07:36:00 <glimming> TheHunter, example?
07:36:33 <TheHunter> can't think of anything atm.
07:37:13 <glimming> stick to data !
07:37:16 <glimming> then
07:37:33 <TheHunter> nah, use newtype then.
07:37:46 <glimming> Then I get an extra element!
07:37:58 <glimming> I prefer to use ! because then there is no Foo _|_  - who uses that anyway?
07:38:06 <TheHunter> data ! and newtype are the same except for pattern matching.
07:38:20 <glimming> You just drawed the cpos
07:38:59 <TheHunter> oh maybe my Baz _|_ == _|_ was confusing.
07:39:02 <glimming> If you take data but force it to be strict you will have that data constructor applied to bot is bot, strict evaluation implies this, however for your newtype you say you insert _another_ bot which is a bit strange to me, but a compromise in lazy evalaution I guess.
07:39:06 <TheHunter> i meant to imply, they're the same.
07:39:18 <glimming> Only in strict evaluation, surely.
07:39:27 <glimming> A strict map is a map such that f bot = bot
07:39:32 <glimming> but Haskell is lazy, mind you
07:39:36 <TheHunter> glimming, you got it wrong.
07:39:44 <TheHunter> newtype isn't lifted.
07:39:49 <TheHunter> data is.
07:39:54 <glimming> Aha, I see.
07:40:02 <glimming> so Newtype is to be preffered.
07:40:02 <TheHunter> newtype is just a fancy type alias with no runtime impact whatsoever.
07:40:20 <glimming> and data has runtime impact?
07:40:23 <glimming> ??
07:40:32 <Oeje1> musasabi: PING
07:40:33 <glimming> so data is lifted always?
07:40:38 <TheHunter> i'm not sure about that.
07:41:21 <TheHunter> the report describes data ! using a translation to data, but that's probably not how it's implemented.
07:41:22 <TheHunter> lemme check.
07:41:29 <glimming> TheHunter, you wrote foo (Foo x) = x is strict if Foo is a data and non-strict if it's a newtype
07:41:39 <glimming> What does that mean?
07:42:08 <glimming> Oh, how I would like a color version of the ghc manuals and the report.... ;-)
07:42:16 <glimming> We have a color laser at work...
07:42:34 <glimming> I somebody provides this I will mail them a copy for free!!! (in color!)
07:42:41 <musasabi> Oeje1: pong.
07:42:47 <TheHunter> foo (Bar x) = f x acts like foo (Baz x) = x `seq` f x
07:42:52 <humasect> glimming: heh
07:43:16 <TheHunter> my statement about  foo (Foo x) = x obviously doesn't make sense
07:44:08 <TheHunter> http://www.haskell.org/onlinereport/decls.html (the box above section 4.2.2)
07:45:02 <Oeje1> musasabi: It seems the currenct parallel array implementation just uses GHC's unboxed Prelude arrays.
07:45:59 <TheHunter> glimming, it appears ghc uses the translation from the report, so it indeed should have a (small) performance impact
07:45:59 <Oeje1> Err, boxed.
07:46:27 <glimming> what does unboxed mean?
07:46:48 <TheHunter> unboxed means "no bottom"
07:47:01 <Oeje1> glimming: Box: pointer, unboxed: value.
07:47:07 <musasabi> Oeje1: yes.
07:47:23 <musasabi> Oeje1: the rules for doing it are not bad though..
07:47:50 <Oeje1> musasabi: What rules are that?
07:47:52 <glimming> TheHunter, hmm do you mean the splitting up into different constructors NilSet and ConsSet in 4.2?
07:48:18 <glimming> I can't say that I understood unboxed really.
07:49:00 <jlouis> boxed: Heap allocated with a pointer to it. Unboxed: residing in a register in the CPU, more or less
07:49:17 <glimming> so now FP talks hardware??? ;-)
07:49:32 <glimming> TheHunter's terminology correct unboxed=no bottom??
07:49:38 <musasabi> Oeje1: the usage of loop* to build the arrays.
07:50:27 <jlouis> the boxed variant has the advantage that all data are uniform (a pointer) opposed to an unboxed value.
07:50:29 <TheHunter> NilSet, ConsSet?
07:50:49 <jlouis> glimming: i do not see TheHunter talking about boxes
07:51:03 <glimming> oops, jlouis I mean
07:51:42 <glimming> from the report, TheHunter, you sent an URL to 4.2
07:51:47 <jlouis> glimming: if you take the representation that a null pointer means bottom, then yes. I am not at all sure GHC (the implementation) does this
07:52:41 <glimming> jlouis, I would not hope to ever know that a null pointer of such sort is actually null, since I could be waiting for a long time.
07:52:42 <TheHunter> glimming, i meant 4.2.1 ... Strictness flags, Translation
07:52:43 <jlouis> I would think _|_ means some non-terminating computation in this respect
07:53:00 <glimming> TheHunter, cheers
07:53:53 <glimming> jlouis, indeed
07:54:25 <glimming> jlouis, where did you get these associations to pointers? Is there a paper that takes it further?
07:54:45 <Philippa_> glimming: It's an implementation thing dating back to lisp
07:55:33 <Philippa_> the interpretation of _|_ is just a minor hiccup in that regard
07:55:49 <Philippa_> (and there /are/ ways to yield _|_ that sort-of terminate, eg error)
07:56:08 <jlouis> Philippa_: ah, yes. Didn't see that before
07:56:35 <Philippa_> unboxed tuples are good too when you can handle them effectively
07:57:30 <glimming> unboxed tuples meaning what? example?
07:57:55 <Philippa_> once again, no 'boxing' (that is, no pointer+tags) involved
07:58:46 <Philippa_> "Most types in GHC are boxed, which means that values of that type are represented by a pointer to a heap object. The representation of a Haskell Int, for example, is a two-word heap object. An unboxed type, however, is represented by the value itself, no pointers or heap allocation are involved."
07:59:17 <glimming> so it is faster?
07:59:31 <glimming> like constants, say for huffman code tables?
07:59:33 <glimming> etc?
07:59:55 <Philippa_> yes
08:00:02 <glimming> a typical example being what?
08:00:12 <Philippa_> the output of GHC's optimiser :-)
08:00:26 <Philippa_> it spends a lot of time working out what it can unbox for you
08:01:16 <Philippa_> note that polymorphic types can't take unboxed values as parms
08:01:30 <glimming> why not?
08:01:33 <Philippa_> so no [Int#]
08:01:50 <jlouis> because the representation of a double float is 64 bit and a 32 bit integer cannot fit in the same space
08:02:00 <jlouis> in general, different types have different space needs
08:02:10 <Philippa_> not to mention are allocated and deallocated in different ways
08:02:15 <jlouis> whereas a pointer to a heap-allocated object always have the same space need (the pointer)
08:02:27 <Philippa_> that bit being important when you try to GC the list
08:02:27 <glimming> what is # ?
08:02:35 <Philippa_> Int# is an unboxed Int
08:02:40 <Philippa_> that being GHC syntax
08:02:41 <glimming> A constant int?
08:02:43 <Philippa_> feel free to RTFM
08:02:47 <glimming> RTFM?
08:02:48 * Philippa_ sighs
08:02:51 <glimming> quiz time.
08:02:59 <Philippa_> Read The (pick your translation) Manual
08:03:10 <Philippa_> this is haskell, all ints are constant. Duh.
08:04:10 <glimming> what are good papers on state-of-the-art compiler techniques for FP?
08:04:35 <Philippa_> define "FP"
08:04:58 <glimming> functional programming
08:04:58 <Philippa_> just about anything that appears to've gone into a modern Haskell or ML implementation is a good start, mind
08:05:05 <Philippa_> fine. Define functional programming
08:05:07 <glimming> papers?
08:05:38 <Philippa_> the optimisations available differ greatly depending on things like strict vs non-strict, pure vs impure...
08:05:45 <glimming> I see.
08:06:01 <glimming> There is one book on impl of FPL by SPJ
08:06:02 <Philippa_> also, you're going to end up reading up a lot on garbage collection in general (not my area), inlining in general...
08:06:35 <Philippa_> GHC uses the spineless tagless G-machine as its basis IIRC
08:07:32 <glimming> Aha, can you refer to a paper on that spineless tagless G-machine?
08:07:35 <glimming> IIRC?
08:07:54 <Philippa_> RTFFAQ. I dare say there're plenty on common acronyms for usenet, IRC etc
08:08:08 <Philippa_> and googling for the name of the abstract machine should yield enough info
08:08:10 <Philippa_> GIYF
08:08:15 <glimming> watch you langauge ;_)
08:08:28 <Philippa_> bah, fuck that :-)
08:09:09 <glimming> OK
08:09:22 * Philippa_ shrugs
08:11:38 * wilx was about to point out Documentation section on GHC's pages...
08:11:40 <wilx> Too slow.
08:12:01 <Philippa_> he probably didn't even take the time to realise what GIYF stands for
08:12:17 <Philippa_> and yes, it's an obvious place to look once I've said "anything connected to GHC's implementation", isn't it?
08:12:47 <wilx> :)
08:12:48 <Philippa_> oh, wait, I never hit enter on that because he said something else too fast
08:13:06 <Philippa_> just "any modern impl."
08:14:54 <Oeje1> Argh, why do a lot of papers not have a publishing date written on the front page?
08:15:10 <kosmikus> is the first Monad.Reader really supposed to appear on 1 March?
08:15:16 <Philippa_> AFAIK, yeah
08:15:22 <kosmikus> is this realistic?
08:15:27 <Philippa_> I may be ready by then, dunno about anybody else
08:15:50 <Philippa_> it's Shae. I guess if there's three articles by then, fair enough
08:15:55 <kosmikus> well, but "author ready" doesn't mean that it's ready to publish
08:16:10 <kosmikus> has shapr calculated 0 minutes editorial time?
08:16:17 <Philippa_> well no, we're supposed to be author ready a week before
08:16:30 <kosmikus> ok
08:16:39 <Philippa_> I can manage, but I bashed out the code part of my article in the first week...
08:17:05 <kosmikus> good luck
08:17:33 <Philippa_> oh, I've got most of the article too. I just need a column intro and a final paragraph
08:17:36 <kosmikus> which reminds me that it's only 1.5 months until the next HC&AR call
08:17:49 <Philippa_> point, I really should get another Flippi release done
08:17:56 <kosmikus> hehe
08:18:50 <kosmikus> is your article online?
08:19:49 <Philippa_> er. Nearly :-)
08:19:58 * Philippa_ SSHes into snowblind
08:20:55 <Philippa_> http://snowblind.scannedinavian.org/~flippa/stuff/article.ps
08:21:27 <Philippa_> The opening para is missing a bunch of stuff about what the column's about (making haskell do thoroughly dirty and fun things)
08:24:00 <kosmikus> ok
08:25:31 <musasabi> What should I do to make hsc2hs work with Cabal? In particular with executables...
08:29:57 <musasabi> @seen SyntaxNinja
08:29:58 <lambdabot> I saw SyntaxNinja leaving #haskell 1 day 8 hours 14 minutes 11 seconds ago
08:44:54 <musasabi> making the main module a hs-file seems to help.
08:54:44 <musasabi> But building C-Sources for the executable does seem broken.
09:00:10 <Oeje1> musasabi: Just did some light testing; List.sort seems faster than a parallel array quicksort on "reverse [1..10^4]"
09:04:31 <musasabi> Oeje1: and parr is probably faster on "reverseP [: 1 .. 10^4 :]"
09:04:44 <musasabi> or then it is the lazyness.
09:04:55 <Oeje1> Ah, good point.
09:10:15 <glimming> x
09:10:22 <Oeje1> lisppaste2: url?
09:10:22 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:10:34 <glimming> how to you use a bibfile in a directory ../bib relative to the TeX dir?
09:12:35 <lisppaste2> Oejet pasted "Parallel array quicksort" at http://paste.lisp.org/display/5877
09:12:54 <glimming> oops, that was probably the stupidest question I asked today
09:13:52 <Oeje1> musasabi: Do you mind trying that program?  "ghc -fparr -O2 parr.hs"
09:14:43 <musasabi> Oeje1: ok.
09:16:29 <musasabi> Oeje1: takes about 3.5secs to run.
09:16:45 <Oeje1> musasabi: Ah it gives the correct output?
09:16:54 <glimming> BIBINPUTS
09:17:01 <glimming> sorry
09:18:19 <lisppaste2> Oejet pasted "Bug isolated" at http://paste.lisp.org/display/5878
09:19:31 <musasabi> Oeje1: 50005000 50005000 50004994 [:1,2,3,4,5,6,7,8,9,10:]
09:19:48 <Oeje1> The bug is in the reverseP part.
09:20:35 <Oeje1> reverseP [: 1..10 :]  ==> [:10,9,8,7,6,5,4:]
09:21:21 <wilx> What is [: :]?
09:21:40 <Oeje1> wilx: Parallel array comprehensions.
09:22:02 <musasabi> evil.
09:22:13 <wilx> It certainly sound evil :)
09:22:19 <Oeje1>  reverseP a  = permuteP (enumFromThenToP (len - 1) (len - 2) 0) a
09:22:24 <Oeje1> From CVS.
09:22:39 <Oeje1> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/GHC/PArr.hs?rev=1.7
09:24:42 <musasabi> yes, and if you look at the CVS history you see that it has not gotten much fixing in the last few years.
09:27:47 * Oeje1 meditates a bit over enumFromThenToP.
09:30:05 <TheHunter> hmm, so what's parallel about this parallel array stuff?
09:32:04 <TheHunter> i don't see any forkIO in the lib and the type of loop seems very sequential.
09:33:19 <Oeje1> TheHunter:  It's parallel in principle, which enables some sequential optimizations such as loops.
09:34:00 <TheHunter> i see, thanks (looking at the paper, now)
09:34:33 <Oeje1> "An Approach to Fast Arrays in Haskell"?
09:35:21 <TheHunter> yep.
09:37:11 <Oeje1> TheHunter: It seems though that GHC is far from the potential described in the paper.
09:41:45 <Oeje1> This is how it seems to behave: "reverseP = toP . reverse . drop 3 . fromP"
09:44:37 <TheHunter> enumFromThenToP 6 5 1 ==> [:6,5,4:]
09:50:14 <Oeje1> TheHunter: Do you know what enumFromThenToP is supposed to do?
09:50:32 <TheHunter> @eval enumFromThenTo 6 5 1
09:50:32 <lambdabot> [6, 5, 4, 3, 2, 1]
09:51:20 <Oeje1> @eval enumFromThenTo 10 8 1
09:51:21 <lambdabot> [10, 8, 6, 4, 2]
09:51:55 <Oeje1> enumFromThenToP 10 8 1 ==> [:10,8,6:]
09:52:08 <Oeje1> So the error must be in there.
09:56:12 <TheHunter> hmm, i think enumFromThenToP = ... replicateP (((z - x) `div` delta) + 1) delta does the trick.
09:57:21 <Oeje1> TheHunter: Great, now you get all the honour of fixing the bug.
09:58:42 <TheHunter> http://www.haskell.org//pipermail/glasgow-haskell-users/2005-February/007867.html
09:58:57 <TheHunter> you can report it, if you want.
10:00:04 <TheHunter> zgrep "not implemented" PArr.hs.gz | wc
10:00:05 <TheHunter>      11     103     754
10:01:01 <TheHunter> frankly, i don't think anyone cares about PArr.
10:01:44 <Oeje1> TheHunter: Why not?
10:02:09 <TheHunter> productP  = foldP (*) 0
10:02:37 <Oeje1> Ok, I see.  ;-P
10:03:01 <TheHunter> there are 11(!) unimplemented but exported functions (most of them trivial, i guess).
10:03:16 <wli> If you've got a big enough array that parallelism matters you're going to die from roundoff.
10:04:51 <TheHunter> that library doesn't seem to be about parallelism, just about improving Haskell's poor array processing performance.
10:06:26 <Oeje1> Exactly.
10:12:38 <Oeje1> I will write to that list.  TheHunter, may I use your "TheHunter: hmm, i think enumFromThenToP = ... replicateP (((z - x) `div` delta) + 1) delta does the trick." suggestion?
10:13:57 <TheHunter> Oeje1, sure, write whatever you want (you don't need to give me any credit)
10:20:52 <desrt> does anyone know who autrijus tang is and where his aix packages are?
10:21:28 <desrt> oh nm.  they're on the ghc page... just not linked
10:24:35 <wilx> Her.
10:25:23 <wilx> And I see her here, why don't you ask her directly? :)
10:37:20 <Oeje1> TheHunter: Is the post ok?
10:40:17 <TheHunter> sure.
10:40:36 <Oeje1> Great.
11:10:29 <TFK> Woo! On to type classes (chapter 5 in A Gentle Introduction)!
12:07:38 * CosmicRay looks in
12:07:55 * TFK pokes CosmicRay in the eye
12:08:03 * CosmicRay yelps
12:08:07 * CosmicRay pokes TFK in the monad
12:08:08 <TFK> :D
12:08:25 <CosmicRay> or, perhaps I should instead kick TFK in the monad... :-)
12:08:45 <TFK> ._.;
12:10:02 <TFK> Anyway...
12:10:03 <stepcut> UFIM
12:10:07 <TFK> How's the Haskell treating ya?
12:11:17 <CosmicRay> TFK: good
12:11:17 <CosmicRay> you?
12:11:37 <TFK> "Trial by fire" ;-)
12:12:08 <CosmicRay> ah, using Haskell for a proejct?
12:12:33 <TFK> I couldn't, not yet :-/
12:13:48 <lightstep> Is there a standard function to flip FiniteMaps or association lists?
12:16:07 <Oeje1> lightstep: A finite map might not be bijective.  Couldn't that be a problem?
12:16:22 <CosmicRay> lightstep: I have one in MissingH
12:16:55 <Oeje1> CosmicRay defies gravity.
12:20:18 <CosmicRay> http://www.quux.org/devel/missingh/html/MissingH.List.html#v%3AflipAL
12:20:33 <CosmicRay> flipAL :: (Eq key, Eq val) => [(key, val)] -> [(val, [key])]
12:20:33 <CosmicRay> Flips an association list. Converts (key1, val), (key2, val) pairs to (val, [key1, key2]).
12:20:47 <CosmicRay> http://www.quux.org/devel/missingh/html/MissingH.FiniteMap.html#v%3AflipFM
12:20:57 <CosmicRay> flipFM :: (Ord key, Ord val) => FiniteMap key val -> FiniteMap val [key]
12:20:58 <CosmicRay> Flips a finite map. See flipAL for more on the similar function for lists.
12:21:24 <CosmicRay> lightstep: that what you want? :-)
12:22:35 <lightstep> actually, i want to flip a bijective one
12:22:51 <CosmicRay> what does bijective mean?
12:23:21 <lightstep> one to one
12:24:03 <CosmicRay> so then you could map (\(k, vl) -> (k, head vl)) on the result
12:24:04 <CosmicRay> and then get what you want
12:24:16 <CosmicRay> since the [key] list would always have one element, yes?
12:24:20 <CosmicRay> otoh, your problem is much simpler
12:24:23 <CosmicRay> you could just
12:24:32 <CosmicRay> map (\(k, v) -> (v, k)) al
12:24:52 <CosmicRay> no need to go to all the work flipAL does
12:25:24 <lightstep> yeah. but i wanted it point-free
12:26:33 <wilx> @pointless map (\(k, v) -> (v, k)) al
12:26:34 <lambdabot> Sorry, I don't know the command "pointless", try "lambdabot: @listcommands
12:26:39 <wilx> Hmpf :)
12:26:55 <CosmicRay> heh
12:29:44 <lightstep> On another topic: howcomes Parsec doesn't have the polymorphic equivalent of char?
12:30:43 * boegel bounces
12:32:16 <boegel> how do I recieve the latest up to date info on TMR again? I forgot the darcs url...
12:36:39 <Philippa_> lightstep: I think it does somewhere, lemme check
12:37:12 <lightstep> It has anyToken, which makes it implementable, but I can't find the combinator.
12:37:20 <Philippa_> token
12:38:10 <Philippa_> or perhaps tokenPrim
12:38:22 <lightstep> Except you need some (tok -> SourcePos).
12:39:13 <lightstep> But exactly tok = do {x <- anyToken; guard (t == x)} should work
12:47:20 <Lemmih> Greetings ninja.
12:47:52 <Lemmih> You've cabalized HSQL, right?
12:47:59 <Oeje1> Lemmih: I found a bug in GHC today.  :-D
12:48:26 * Lemmih hands Oeje1 a cookie.
12:48:37 <CosmicRay> Lemmih: yes
12:48:56 <Lemmih> Oeje1: In GHC 6.4?
12:49:04 <CosmicRay> dammit, I hate stupid programmers.
12:49:12 <Oeje1> Lemmih: Yes, and 6.2.1.
12:49:25 <CosmicRay> a consultant is writing a web app for someone here and I had to explain to him what a proxy server is
12:49:31 <CosmicRay> he's extremely frustrated that he has to deal with this
12:49:48 <CosmicRay> even though his .net soap library already supports it.
12:49:49 <CosmicRay> growl.
12:50:01 <CosmicRay> it should be 15 seconds of work.
12:50:01 <Oeje1> He, he.
12:50:02 <wilx> "Consultants..."
12:50:03 <wilx> :))
12:50:10 <musasabi> SyntaxNinja: hello.
12:50:15 <Lemmih> Oeje1: Have you reported it?
12:50:21 <CosmicRay> meanwhile, I am writing a skeletal soap support from scratch in haskell for a different web app
12:50:25 <CosmicRay> I bet I get done first.
12:50:39 <wilx> This reminds me that I should check The Daily WTF site.
12:50:45 <musasabi> isn't there already soap code in haskell?
12:50:53 <CosmicRay> musasabi: as far as I can tell, no.
12:51:10 <CosmicRay> musasabi: I asked on -cafe last month, and there was somebody that was possibly working on something that might be released later this year if lucky.
12:51:15 <Oeje1> Lemmih: Yeps, at Glasgow-users.
12:51:15 <CosmicRay> and google has nothing at all on it.
12:51:21 <CosmicRay> xml-rpc, yes.  soap, no.
12:51:46 <CosmicRay> and I for one suggest that the "s" in "soap" stands for "shitty" isntead of "simple"
12:52:20 <musasabi> CosmicRay: seems it was xml-rpc, I was remembering.
12:52:39 <Oeje1> Lemmih: http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/7551
12:52:43 <Lemmih> .whois Oeje1
12:52:58 <Lemmih> Ops.. (:
12:54:19 <Oeje1> Lemmih: I know.  This the the w1ck3d Windooze machine that I 0wnzzz.  :-P
12:55:47 <Lemmih> CosmicRay: Got an URL for SyntaxNinja's cabalized HSQL?
12:56:25 <CosmicRay> Lemmih: no, but I got a URL for mine.  I can't remember if he originally gave me the cabal file for it or not
12:57:03 <Lemmih> I've seen yours and I don't want it (:
12:57:07 <CosmicRay> heh, ok
12:57:50 <Lemmih> Hardcoding everything seems wrong.
12:58:32 <CosmicRay> maybe, but it works.
12:58:44 <CosmicRay> something funky could be dune with 0.4 and the buildinfo files I suspect
12:58:45 <Lemmih> Yeah, but I'm not interested in HSQL.
12:58:51 <CosmicRay> oh
12:58:59 <CosmicRay> why have you asked about it then? :-)
12:59:27 <Lemmih> Because I want to know how to cabalize it correctly.
13:00:07 <Heffalump> CosmicRay: only works for a specific application, i.e. building the Debian package
13:00:25 <CosmicRay> ah.
13:00:32 <SyntaxNinja> Lemmih: HSQL? eh, you can get it from the CVS repo; it's very rudimentary, just testing some interaction w/ makefiles
13:00:33 <Lemmih> Your cabalization would definitely not play well with Hackage/cabal-get.
13:00:51 <CosmicRay> Lemmih: I have done a much more thorough job with MissingPy.
13:01:01 <CosmicRay> Lemmih: I have a setup.py that generates the .cabal file there.
13:01:05 <SyntaxNinja> hi musasabi
13:01:12 <CosmicRay> Lemmih: it could be trivially modified to use the new buildinfo support, however
13:01:17 <CosmicRay> I was unaware of that feature when I wrote it
13:01:40 <pipe> alright my haskell book arrived!
13:01:59 <SyntaxNinja> what's wrong w/ CosmicRay's cabailzation?
13:02:07 <wilx> Which one?
13:02:13 <CosmicRay> SyntaxNinja: I hard code a bunch of paths to libraries and include files
13:02:18 <SyntaxNinja> of hsql
13:02:21 <CosmicRay> because I know what they are on debian systems.
13:02:27 <pipe> "An Introduction to Functional Programming Systems Using Haskell"
13:02:28 <CosmicRay> SyntaxNinja: things like mysql include paths and whatnot
13:02:29 <SyntaxNinja> CosmicRay: oh, and you want to get them from configure instead? yeah.
13:02:36 <CosmicRay> SyntaxNinja: no, lemmih does.
13:02:40 * SyntaxNinja nods
13:02:43 <CosmicRay> SyntaxNinja: I don't care
13:02:44 <CosmicRay> :-)
13:03:05 <SyntaxNinja> btw, heads-up, HSQL breaks in ghc 6.4, also Krasimir was saying that he wants to cabalize it, so someone should check w/ him.
13:03:16 <CosmicRay> good
13:03:20 <SyntaxNinja> he's been a major participant in cabal.
13:03:28 <CosmicRay> maybe he could make a more standard way for people to select only, say, mysql support
13:03:37 <CosmicRay> without also getting pgsql and odbc if the host system suppotrs them
13:04:55 <Lemmih> SyntaxNinja: Have you thought about how cabal-get should handle packages like HSQL?
13:05:07 <Heffalump> what's cabal-get?
13:05:50 <SyntaxNinja> Lemmih: in what way?
13:06:02 <SyntaxNinja> Lemmih: are you aware of the "hooks" and .buildinfo file?
13:06:12 <Lemmih> Heffalump: Imaginary program which can download and install packages from Hackage.
13:06:31 <SyntaxNinja> it is my imaginary program as well. that's the nice thing about imaginary programs
13:07:47 <Lemmih> SyntaxNinja: But getting that info automatically would be really bad and querying the user would be almost as bad.
13:08:18 <SyntaxNinja> Lemmih: if configure can do it, it's not bad, right?
13:09:11 <Oeje1> Lemmih: OT, Cabal packages are registering themselves with GHC at installation time, right?
13:09:23 <SyntaxNinja> Oeje1: yeah
13:10:08 <Oeje1> Oh, and Cabal is also for recipes, I mean source packages?
13:10:30 <Lemmih> SyntaxNinja: The configure script required user input for selecting alternate paths and non-default (en/dis)abling of features.
13:10:54 <SyntaxNinja> Oeje1: not sure what you mean; it can configure, build, and install packages from source.
13:11:03 <Oeje1> I am going to figure out some time how to fit that into GoboLinux.
13:11:16 <Oeje1> I see, that was what I meant.
13:11:51 <SyntaxNinja> Lemmih: it should either make default assumptions, or it should give up, or it should query the user, what else could it do?
13:12:17 <SyntaxNinja> Oeje1: tmoertel wrote an cabal-to-rpm script, and CosmicRay wrote a similar thing for Debian. is gobolinux a source or a binary distribution?
13:12:32 <Oeje1> Because GHC is in /Programs/GHC/6.2.1/ and other packages are build in a sandbox and installed in their own /Programs/Name/Version/.
13:12:33 <SyntaxNinja> Oeje1: cabal was specifically designed to support being wrapped by distribution systems.
13:12:57 <SyntaxNinja> Oeje1: that's fine, use the --prefix argument to configure to tell it where to put the packages
13:13:27 <SyntaxNinja> but it might make Programs/Name/Version/bin and Programs/Name/Version/lib which might not be convinient.
13:13:47 <SyntaxNinja> but it'll tell GHC where to find the libs, fwiw.
13:14:00 <Oeje1> How is that not convinient?
13:14:14 <SyntaxNinja> because of the $PATH for binaries.
13:14:23 <SyntaxNinja> er, executable programs I mean
13:14:42 <SyntaxNinja> Lemmih: so really it's the collection of the information that's the problem, not Cabal :)
13:14:49 <Oeje1> Ah, Gobo solves that "the other way"; symlinks.
13:14:58 <SyntaxNinja> Oeje1: cool. np
13:15:34 <Oeje1> But will it write into some register in /Programs/GHC/6.2/ ?
13:15:40 <SyntaxNinja> yeah
13:15:52 <SyntaxNinja> it uses ghc-pkg to make ghc aware of the package
13:15:54 <Oeje1> Like GNOME, it seems.
13:16:35 <Lemmih> SyntaxNinja: Maybe there's no good solution. I just think it's annoying that some packages can't be installed with cabal-get.
13:17:33 <Oeje1> SyntaxNinja: That means either opening up the sandbox while compiling and installing, or find some other solution.
13:17:48 <Oeje1> I mean, for GoboLinux.
13:19:07 <Oeje1> What files will Cabal alter in GHC when registering a package?
13:19:23 <SyntaxNinja> Lemmih: Maybe some more smarts can be added to configure to figure these things out itself? I'd ask krasimir, he's working on it.
13:19:37 <SyntaxNinja> Oeje1: use "ghc-pkg -l" see some info
13:20:03 <Oeje1> I will try that.
13:20:10 <SyntaxNinja> Oeje1: the sandbox is Programs/Name/Version?
13:20:29 <SyntaxNinja> Oeje1: fwow, --gen-script (I think) will generate a shell script in order to perform the register step at a later time.
13:21:10 <SyntaxNinja> Oeje1: whatever you discover for ghc 6.2 might be slightly different in ghc 6.4
13:21:13 <Lemmih> SyntaxNinja: It's not about figuring things out automatically, it's about allowing user-supplied values.
13:22:25 <Oeje1> SyntaxNinja: Packages are compiled in their sandboxed source directory, and then are only allowed to install into /Programs/Name/Version/.
13:23:20 <SyntaxNinja> Lemmih: then the ./setup configure command can be tweaked to allow user-supplied flags to trickle through to the configure script itself.
13:23:39 <SyntaxNinja> Oeje1: installing means unpacking, or executing code to install?
13:24:58 <Lemmih> SyntaxNinja: And cabal-get will give its arguments to all downloaded packages? Then I guess there's no problem (:
13:26:03 <Oeje1> SyntaxNinja: Installing means the broad sense of "make install".
13:26:47 <SyntaxNinja> Oeje1: then the sandbox actually prevents arbitrary code from writing to arbitary locations?
13:27:38 <Oeje1> Hence it's called a sandbox. :-)
13:28:47 * SyntaxNinja nods
13:29:11 <SyntaxNinja> yes, unfortunitely, I think you'll have to break the sandbox to register w/ ghc. there are some other, ugly options, thouhg
13:29:39 <SyntaxNinja> ghc has a flag to tell it where to find the package database. I think you can give it multiple flags for mutiple databases, but I'm not sure of that.
13:29:48 <SyntaxNinja> ghc 6.4 might be different in this regard as well.
13:30:29 <SyntaxNinja> in 6.4, you can _maybe_ make a symlink to an entry int he database, since it's _maybe_ a directory
13:30:37 <SyntaxNinja> we talked about that at one point, but I'm not sure how it was implemented in the end.
13:33:32 <Oeje1> That is a general problem it seems.  Central register vs. sandboxing of packages.   A solution might be to make a rule called "is_cabal_package=yes" wich then is allowed just to write to the necesarry files.   I haven't looked into it much though.
13:33:49 <Oeje1> But thanks for your info.
13:35:00 * boegel finds it quite hard to write his first article (the TMR one)
13:37:56 <Oeje1> boegel: Have you made up some examples?
13:39:09 <boegel> Oeje1: examples of what ?
13:40:44 <Oeje1> Code, program snippets.  Or is it an all theoretical article?
13:40:56 <boegel> Oeje1: I created 1 example
13:41:13 <boegel> http://studwww.ugent.be/~kehoste/memory.png
13:41:15 <lightstep> Fuck, Parsec defines replicateM as Parsec.count -- therefore creating warning for whoever that uses -Wall
13:42:23 <Oeje1> boegel: Wow, nice.  GUI library article?
13:47:28 <metaperl_> Ok, this "main :: IO ()" means what? and also this "greet :: String -> IO ()" means what? I am reading an intro to haskell and want some precise descriptions of thise lines in the code
13:47:42 <metaperl_> here is what I am reading http://www.iceteks.com/articles.php/haskell/2
13:48:18 <Lemmih> metaperl_: Those are type signatures.
13:48:37 <metaperl_> yes, and what are they saying precisely
13:48:53 <Lemmih> "main :: IO ()" can be read as "main has type IO ()".
13:49:21 <boegel> Oeje1: yep, an article on Gtk2Hs
13:49:30 <pipe> understanding what IO () means will be more painful then pulling your lower lip over the back of your head
13:50:15 <wilx> lol
13:50:29 <wilx> Now that would be a stunt :D
13:51:26 <lightstep> metaperl_, IO () is just "a block of machine code". So, for example, x >> y is the concatenation of the blocks x and y. IO a for a /= () is more complicated.
13:51:29 <Lemmih> The complexity of monads have been greatly exaggerated.
13:52:07 <Oeje1> boegel: Not anyone knows Gtk or even GUI programming.  So explain GUI principles, then Gtk, then how that translates into Gtk2hs.  Also of course how to get and setup and compile with gtk2hs.
13:52:14 <metaperl_> ok, I will ignore that part of the tutorial for now
13:52:22 <lightstep> So running your program would be building the block of code described by main, then running it
13:55:24 <boegel> Oeje1: hmm, okay... I think the structure of the article will be ok, but I'm having problems with putting my thought into (English) words
13:56:21 <Oeje1> boegel: Then translate into English afterwards, maybe.
13:56:27 <Lemmih> metaperl_: http://haskell.org/complex/introduction_to_programming.html is a more thorough tutorial, IMHO.
13:57:25 <boegel> Oeje1: I'm afraid I won't have time for that
13:57:35 <metaperl_> ok, added to my haskell bookmarks
13:57:37 <metaperl_> thanks
13:57:39 <bringert> CosmicRay: weird bug that missing space that you reported
13:57:40 <boegel> it's due Monday, and I only have time now, and Sunday
13:58:20 <Philippa_> <Lemmih> The complexity of monads have been greatly exaggerated. <- Say it ain't so!
13:59:07 * Philippa_ is tempted to describe monads as "separate programming languages that fit a certain shape and include a haskell interpreter"
13:59:15 <Philippa_> (the haskell interpreter being return)
13:59:27 <Oeje1> That article at iceteks.com looks ok, although it has the FAQ problem about line buffering.
13:59:55 <pipe> do you guys know www.lambda-the-ultimate.org?
14:00:20 <Lemmih> Philippa_: I can't (:
14:00:38 <lightstep> I learned Haskell from the Gentle Introduction. They postponed IO until very far away, and even then portrayed it as scary, and as a magic "Monad" thing. Contrarywise the scsh paper, which is very proud of its parallel thingies.
14:01:20 <Philippa_> pipe: shapr hangs out here a lot, I lurk a few other folks here read
14:02:45 <lightstep> pipe, I surf there once in a while. It seems boring lately
14:02:53 <pipe> are the comments generally good? i'm new to this stuff and don't want to be reading wrong things...
14:03:23 <bringert> pipe: you're assuming that what we tell you is good then?
14:04:15 <pipe> yes =D
14:04:31 <Heffalump> monads are implementable in haskell, though
14:04:48 <Heffalump> so calling them a separate language that includes a Haskell interpreter is a bit weird
14:05:05 <Philippa_> not all monads are implementable in haskell
14:05:26 <Heffalump> depends how much of the world you're prepared to model :-)
14:05:28 <Philippa_> IO and ST spring to mind
14:05:42 <Philippa_> okay, a *real* IO monad :-)
14:05:45 <Heffalump> ST could be implemented in Haskell, just not as efficiently
14:05:46 <pipe> what's ST?
14:06:10 <Philippa_> Heffalump: last time I saw it was impossible to type the heap properly?
14:06:14 <Heffalump> ral IO is fine assuming we can model human beings
14:06:26 <Heffalump> s/ral/real/
14:06:48 <Heffalump> Philippa_: well, you'd need the same rank-2 polymorphism as you need to use ST. But apart from that what would the problem be?
14:07:13 <Heffalump> oh, the STRefs, right.
14:07:16 * Heffalump thinks about that
14:08:04 <Heffalump> it's fine if you assume Data.Dynamic, of course
14:08:07 <Itkovian_> @type mapM_
14:08:08 <lambdabot> mapM_ :: forall m a b. (Monad m) => (a -> m b) -> [a] -> m ()
14:08:09 <bringert> pipe: a monad for " strict state threads"
14:08:22 <Heffalump> there's a LazyST too, isn't there?
14:08:29 <Itkovian_> @type liftM
14:08:30 <lambdabot> bzzt
14:08:40 <Philippa_> basically, it's a monad that gives you mutable variables
14:08:45 <bringert> pipe: haddock here http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Monad.ST.html
14:08:49 <pipe> cool thanks
14:21:14 * boegel goes to bed
14:21:17 <boegel> g'night everyone
14:21:58 <araujo> g'night boegel
14:38:38 <Itkovian_> I'm somewhat at loss here ...
14:38:51 <Heffalump> about what?
14:38:58 <Heffalump> @type Control.Monad.liftM
14:38:59 <lambdabot> Control.Monad.liftM :: forall r m a1.
14:38:59 <lambdabot> 		       (Monad m) =>
14:38:59 <lambdabot> 		       (a1 -> r) -> m a1 -> m r
14:39:03 <Itkovian_> doing args <- getArgs, does that make args :: [String] or IO [String] ?
14:39:09 <Heffalump> args :: [String]
14:39:16 <Itkovian_> ok.
14:39:21 <Heffalump> assuming you do that inside a do .., which is the only place you can do it
14:39:25 <Itkovian_> yes.
14:39:26 <jlouis> Hmmm, what is it you need if you iterate a function to a fixpoint. The function f you are applying has to be monotone in some way. But I remember there is a constraint about conservatism too
14:39:30 <jlouis> can anyone remember it?
14:39:48 <Heffalump> the domain it is operating on shouldn't have infinite descending/ascending chains
14:39:57 <Heffalump> (descending or ascending in the same direction as the function is monotone)
14:39:57 <jlouis> I want the least fixpoint
14:40:10 <Heffalump> no infinite descending chains then
14:40:24 <Itkovian_> but then this: files <- map (flip openFile ReadMode) args
14:40:29 <Itkovian_> should work, no?
14:40:51 <Heffalump> @type flip openFile ReadMode
14:40:53 <lambdabot> bzzt
14:40:59 <Itkovian_> no, forget that
14:41:01 <Heffalump> @type flip System.IO.openFile System.IO.ReadMode
14:41:02 <lambdabot> flip System.IO.openFile System.IO.ReadMode :: FilePath
14:41:02 <lambdabot> 					      -> IO GHC.IOBase.Handle
14:41:18 <Heffalump> try sequence $ map (flip openFile ReadMode) args
14:41:30 <Itkovian_> @type sequence
14:41:31 <lambdabot> sequence :: forall a m. (Monad m) => [m a] -> m [a]
14:41:56 <Heffalump> map ... gives you a list of monadic actions
14:41:59 <jlouis> Heffalump: hmmm, is there a particular name for a domain in which no ascending/descending chain is infinite?
14:42:00 <Itkovian_> maybe the map (..) args works, but it's the <- that flips (no pun intended)
14:42:01 <Heffalump> you want a monadic action producing a list
14:42:12 <Heffalump> jlouis: lattice, IIRC.
14:42:15 <Itkovian_> I want to open a bloody set of files :-)
14:42:25 <Heffalump> Itkovian_: so use sequence, like I said ;-)
14:42:32 <Itkovian_> yeah, trying now, as we speak
14:42:35 <Itkovian_> :-)
14:43:03 <Heffalump> the right hand side of a <- must be of type m foo, where m is the monad the do you are in uses
14:43:04 <Itkovian_> ok, no type errors there any more.
14:43:05 <Philippa_> Itkovian: mapM?
14:43:10 <Heffalump> @type mapM
14:43:11 <lambdabot> mapM :: forall b m a. (Monad m) => (a -> m b) -> [a] -> m [b]
14:43:12 <Itkovian_> Philippa_, I used that
14:43:15 <jlouis> Hmmm, I should go look this up. I do remember the terms, but not the definitions, thanks anyway
14:43:15 <Itkovian_> before
14:43:20 <Heffalump> oh, that should have worked too, yeah
14:43:36 <Itkovian_> well, as some say, timtowtdi
14:43:40 <Heffalump> I always get mapM and liftM confused.
14:44:01 <Itkovian_> well liftM hops both sides on a Monad plane
14:44:41 <Heffalump> I know what they both do when I think about it
14:44:57 <Heffalump> I just have trouble making the connection from "I want to do this" to the appropriate one
14:45:57 <Itkovian_> idd
14:46:05 <Itkovian_> sounds familiar
14:46:47 <lightstep> jlouis: well-ordered or something, i think
14:51:20 <lightstep> actually, well-foundedness gives you the same, and doesn't require total ordering
15:19:49 <Itkovian_> @type System.IO.hGetContents
15:19:50 <lambdabot> System.IO.hGetContents :: GHC.IOBase.Handle -> IO String
15:20:31 <Itkovian_> @type mapM (System.IO.hGetContents)
15:20:32 <lambdabot> mapM (System.IO.hGetContents) :: [GHC.IOBase.Handle] -> IO [String]
15:21:57 <Itkovian_> I immensely enjoy Haskell, but this IO stuff is tough to get the hang of.
15:22:25 <pipe> that's why you should minimize your use of it :)
15:22:38 <Itkovian_> At least the rest of the program can be written fast, making sure I don't exceed the perl programming time
15:22:54 <Itkovian_> pipe, a man's gotta have some data to process, no?
15:23:21 <bringert> @type interact
15:23:22 <lambdabot> interact :: (String -> String) -> IO ()
15:23:33 <bringert> is all you need :-)
15:25:32 <Itkovian_> yeah, and I suppose I'll type in a few thousand lines too ...
15:37:59 <metaperl_> Based on my reading of a tutorial (http://www.iceteks.com/articles.php/haskell/3) it appears that Haskell makes sure that data input via I/O will not do something to damage your system? Is that why it requires data to come through <-
15:38:23 <ibid> no
15:39:28 <dons> hmm. haskell's IO is a little bit like taint checking in perl
15:40:15 <ibid> it's not like it
15:40:23 <ibid> they have very different goals
15:40:45 <ibid> taint check makes sure you don't accidentally use unchecked data in a dangerous context
15:41:01 <dons> yeah, sure. it seems a helpful comparison to make, however.
15:41:15 <ibid> haskell's IO just makes sure that IO does what you want it to do, even in the presence of laziness
15:41:58 <ibid> dons: i don't see how it's helpful, but if it works for you, great
15:42:03 <pipe> what i wanna know more about is how to properly code and use functions that may call error
15:42:15 <dons> Of couse. I would imagine for a beginner, however, getting data out of an IO type is the main concern, hence the analogy
15:42:42 <dons> "how do I get rid of the IO" seems to be one of the most common questions we get :)
15:43:10 <ibid> dons: i find that a better analogy is separation between statements and expressions, between procedures and functions, in pascal-like languages
15:43:29 <ibid> they don't usually enforce it, but breaking it is considered bad style
15:44:05 <ibid> so you write x := readln; some_procedure(some_function(x))
15:44:17 <ibid> instead of some_procedure(some_function(readln))
15:44:30 <dons> that's interesting. statements vs expressions also hints at the underly monadic semantics too.
15:45:13 <ibid> i prefer to think of monads as a way to encode the statement/expression separation in haskell's type system
15:45:28 <dons> indeed, that's how I think of it too.
15:45:36 <ibid> of course, you get a more powerful system from that but that's beyond newbie stuff
15:46:24 <ibid> blah, i feel bad
15:46:40 <ibid> i blundered semipublically today rather badly
15:46:44 <ibid> maybe i should get some sleep
15:46:57 <ibid> (yes, i should, i need to be awake too soon)
15:46:59 <dons> hehe. sleep is good.
15:47:05 <pipe> mmmm... sleep...
15:47:11 <dons> so it isn't 10.46am in ibid land, then.
15:47:21 <Pseudonym> It is here, but I need to sleep, too.
15:47:36 <dons> caffeine too the rescue!
15:47:46 <Pseudonym> It's a well-known fact that the amount of sleep that the average person needs is half an hour more.
15:48:06 <ibid> dons: near 2am
15:48:19 <ibid> Pseudonym: only half an hour?
15:48:29 <pipe> ibid: when is sunrise over there?
15:48:46 <ibid> i need to look that up :)
15:49:01 <Pseudonym> ibid: On average.
15:49:06 <pipe> or wait it up :P
15:49:39 <ibid> Pseudonym: depends heavily on the time of year
15:49:47 <ibid> today it seems to be around 8am
15:50:12 <pipe> hm... sunrise at 8? that's crazy
15:50:21 <ibid> oh the half an hour on average?
15:50:24 <ibid> pipe: too early?
15:50:35 <pipe> too late
15:50:55 <pipe> i'm in your timezone apparently but the sun rises here around 5:20
15:51:11 <ibid> well, it's around 9:30 in december :)
15:51:25 <pipe> sheyza
15:51:27 <ibid> pipe: i'm way north :)
15:51:43 <pipe> right... equator here :)
15:51:49 <ibid> but not north enough to live the dayless day
15:52:19 <pipe> dayless day probably rocks the sausage
15:52:33 <ibid> about a few km north from here the sun doesn't rise for two weeks in december
15:52:34 <pipe> but not as much as the dayless night
15:52:46 <ibid> of course they get the nightless night in midsummer
15:52:51 <ibid> (the sun never sets for two weeks)
15:54:09 <pipe> hm.... i'm doing a desert trip on sunday
15:54:52 <ibid> a few *hundred* km, sorry
15:55:07 <pipe> :D
15:56:28 <ibid> but sleep, bbl
16:05:38 <xerox> 'night folks
16:05:56 <Lemmih> Good night, xerox.
16:21:53 <syntax_syntax> hahaha.
16:22:00 <syntax_syntax> RMS has a girlfriend.
16:22:13 <syntax_syntax> but, get this. She lives in Colombia, and they almost don't meet.
16:24:08 <Heffalump> how is she licensed?
16:31:38 <stepcut> Heffalump: I think she is open sores...
16:36:05 <Pseudonym> Don't be silly.  RMS has nothing to do with open sores.
16:36:09 <Pseudonym> She's free.
16:44:11 <KrispyKringle> RMS has a girlfriend?
16:44:11 <KrispyKringle> wow
16:44:18 <KrispyKringle> Is her beard as long as his?
16:44:54 <Pseudonym> Now, now.
16:45:07 <Pseudonym> Good on him, I say.
16:45:13 <Pseudonym> And good on her, if that's what she's into.
16:46:20 <KrispyKringle> This is just a bit like the kid in high school who had a girlfriend but she lived 5 hours away, but here was her picture and no it's not cut out of a magazine.
16:46:31 <Pseudonym> Well, he has photos.
16:47:01 <KrispyKringle> So did the kid in high school. ;)
16:47:05 <Pseudonym> But she's not cut out of a magazine.
16:47:10 <KrispyKringle> Oh.
16:48:12 <KrispyKringle> i had a professor who said he sat in the same aisle as RMS on an airplane, and could smell him from a seat away.
16:48:15 <KrispyKringle> No idea if that's true or not.
16:49:10 <Pseudonym> Well, having a girlfriend might help him clean up his act, so to speak.
16:49:15 <Pseudonym> I think this is her:
16:49:16 <Pseudonym> http://stallman.org/photos/bolivia/la-paz/valle-de-la-luna/img_0424.jpg
16:50:07 <KrispyKringle> Hmm. She's not bad. I suppose I prefer girls who are less blurry, but to each his own.
16:50:15 <Pseudonym> http://stallman.org/photos/bolivia/la-paz/valle-de-la-luna/img_0420.jpg
16:50:23 <Pseudonym> Less blurry, but also less exposed, so to speak.
16:50:49 <KrispyKringle> Hmm. Bit on the chunky side, but not bad.
16:52:16 <Pseudonym> Never met her, so I can't comment on her relative goodness or badness.
16:52:33 <Pseudonym> My point is, she does not appear to be faked. :-)
16:53:29 <KrispyKringle> True. :P
16:53:37 <KrispyKringle> Well, that's hope for the rest of us, I guess.
16:53:40 <KrispyKringle> In a manner of speaking.
16:53:46 <KrispyKringle> I'm not sure I'd hit it, but whatever.
16:53:54 <KrispyKringle> pardon my vulgarity.
16:56:38 <Pseudonym> Well, you have killed the quality of the conversaion, if that's what you meant.
16:57:02 <Pseudonym> :-)
16:58:13 <KrispyKringle> I do that sometimes, Pseudonym, but we *were* talking about RMS's girlfriend. How quality could it have been? :P
16:58:37 <Pseudonym> You never know.
16:58:48 <Pseudonym> Many people find RMS inspiring.
16:58:51 <Pseudonym> And he's very, very smart.
16:58:53 <Pseudonym> And quite funny.
16:58:57 <Pseudonym> Chicks dig that.
17:00:41 <Pseudonym> And as I say, being in a relationship might encourage him to concentrate on the personal grooming a bit more.
17:00:52 <Pseudonym> Though the beard is cool.
17:01:01 <Pseudonym> Personal opinion.
17:01:30 <Pseudonym> If Alan Cox is allowed to keep his beard, so is RMS.
17:02:26 <Pseudonym> http://www.linux-magazin.de/Artikel/ausgabe/2002/12/award/alan_cox.jpg <- Rejected member of ZZ Top.
17:02:48 <KrispyKringle> heh
17:04:18 <KrispyKringle> Hmm. So what's the recommended way to see if an element is ocntained in a list? I can think of: a) folding some anonmymous function, b) using elemIndex, c) using intersect, ...?
17:04:26 <KrispyKringle> intersect seems pointless.
17:04:31 <KrispyKringle> (b) seems best.
17:04:31 <Pseudonym> A single element?
17:04:34 <Pseudonym> x `elem` xs
17:04:37 <KrispyKringle> ooh :P
17:04:38 <KrispyKringle> thanks
17:04:40 <Pseudonym> @type elem
17:04:46 <lambdabot> elem :: forall a. (Eq a) => a -> [a] -> Bool
17:04:56 <KrispyKringle> i was looking in List instead of Prelude
17:04:57 <KrispyKringle> cool
17:05:30 <KrispyKringle> perfect
17:05:35 <dons> it's in Data.List
17:22:15 <int80_h> greetings
17:22:35 <int80_h> I just got the book I ordered from the library
17:22:46 <int80_h> and I have remote access to a hugs interpreter
17:22:49 <int80_h> sweet :)
17:22:53 <int80_h> all I need
17:27:46 <Lemmih> Great.
17:49:08 <Lemmih> @index readIORef
17:49:08 <lambdabot> Data.IORef,GHC.IOBase
18:18:35 <bourbaki> moin
18:18:43 <Lemmih> Hey.
18:20:33 <bourbaki> Pseudonym: are you there?
18:21:17 <duncan_> I had my new 40 inch wheel unicycle delivered today. It is fantastically fast. :-) I am much pleased.
18:26:42 <bourbaki> Lemmih: how are you doing?
18:28:25 <Lemmih> bourbaki: Great. Trying to get my clanlib binding + pong game under 100 lines (:
18:28:48 <bourbaki> cool
18:29:07 <bourbaki> i have been working on a game as well
18:29:15 <bourbaki> not finished it yet though
18:30:12 <bourbaki> Lemmih: did you start to write some kind of engine?
18:30:26 <bourbaki> im still interested to do something nice in haskell
18:31:23 <Lemmih> bourbaki: I've only made a raw binding to ClanLib so far. Nothing high level.
18:31:33 <int80_h> I just want to learn haskell, then I will figure out what fun thing to do.
18:31:48 <bourbaki> a binding to an engine like ogre3d would be nice
18:32:17 <humasect> duncan: cool =)
18:33:36 <int80_h> or rather, I want to use haskell to learn functional programming style.
18:34:04 <int80_h> all I know is, when I look at haskell code, it pleases my sensibilities.
18:34:25 <Lemmih> bourbaki: If it's written in C++ then a binding would be easy to create.
18:34:53 <bourbaki> Lemmih: do you use windows?
18:35:22 <Lemmih> Nope.
18:36:06 <bourbaki> too bad
18:36:15 <bourbaki> id like to have some dx bindings
18:42:38 <dons> int80_h: that's a nice phrase. i should quote it.
18:45:22 <dons> Haskell: it'll please your Sensibility
18:46:53 <dons> Haskell: it'll categorise your Understanding
18:48:05 <dons> i'll bind your monads
18:48:07 <dons> i'll stop now
18:48:20 <dons> oops. haskell'll bind your monads
20:30:21 * juhp finally gets the jib about donuts ;)
20:52:05 <FanBoy|haskell> Hi dont suppose anyone could help me with a simple haskell function could they please?
20:52:30 <Pseudonym> Might, might not.
20:52:35 <Pseudonym> Never know until you try.
20:53:01 <FanBoy|haskell> Ok well I'll give it a shot ;) I would like to fill a ListInt up with values 1 to x
20:53:06 <FanBoy|haskell> but im not sure how.
20:53:13 <Pseudonym> What's a ListInt?
20:53:30 <FanBoy|haskell> data ListInt = Nil | Cons Int ListInt deriving (Show,Eq,Ord)
20:53:44 <Pseudonym> Aha.
20:53:51 <Pseudonym> Why aren't you just using [Int]?
20:54:07 <FanBoy|haskell> its what ive been taught
20:54:15 <FanBoy|haskell> and I need to do it this way :)
20:54:16 <Pseudonym> Ah, it's homework, is it?
20:54:20 <Pseudonym> Gotcha.
20:54:36 <Pseudonym> Right.  What have you got so far?
20:54:51 <FanBoy|haskell> Ive done the function to get the length of a ListInt, im just finding filling another listint up with 1 to length is hard
20:55:10 <FanBoy|haskell> er heh not a lot
20:55:15 <monochrom> I have a solution, but it is definitely not what your marker is looking for.
20:55:54 <Pseudonym> Well, let's see your code to get the length.
20:55:54 <monochrom> Do you know what the marker is looking for?
20:55:55 <FanBoy|haskell> heh probably not no :)
20:56:14 <FanBoy|haskell> its only 3 lines, can I paste in here or would you rather i pastebin it
20:56:22 <Pseudonym> 3 lines is probably okay.
20:56:28 <monochrom> I'm fine either way.
20:56:31 <FanBoy|haskell> lengthList :: ListInt -> Int
20:56:31 <FanBoy|haskell> lengthList Nil = 0
20:56:31 <FanBoy|haskell> lengthList (Cons _ xs) = 1 + lengthList xs
20:56:52 <Pseudonym> Cool.
20:56:56 <Pseudonym> You know how that works, right?
20:57:10 <FanBoy|haskell> I think so ^_^
20:57:19 <Pseudonym> Try to explain it to me.
20:58:29 <FanBoy|haskell> Cons _ xs matches any value of Cons x(Cons andthenavaluehere)
20:58:30 <monochrom> good idea
20:58:45 * Pseudonym nods
20:59:21 <FanBoy|haskell> and then 1 is added to, and this is where I get shakey, lengthList xs, the number of the interation?
20:59:45 <Pseudonym> Hmmm.
20:59:50 <monochrom> Heh it's recursion.
20:59:54 <Pseudonym> Do you know about proof by induction?
20:59:56 <FanBoy|haskell> er yeah sorry heh
21:00:03 <FanBoy|haskell> I know a bit about it yes
21:00:07 <Pseudonym> Right.
21:00:17 <Pseudonym> What you've got here is a bit like a proof by induction.
21:00:36 <FanBoy|haskell> um...k..
21:00:43 <Pseudonym> If you recall, a simple proof by induction has two cases.
21:00:51 <Pseudonym> A base case, and a recursive "step".
21:00:56 <FanBoy|haskell> yus
21:01:01 <Pseudonym> Right.
21:01:13 <Pseudonym> So, for example, suppose you wanted to prove P(n) for all n >= 0.
21:01:24 <Pseudonym> Then in case 1, you prove P(0).
21:01:37 <Pseudonym> And in case you, you assume P(n), and use that to prove P(n+1).
21:01:46 <FanBoy|haskell> yup
21:01:49 <Pseudonym> Right.
21:01:56 <Pseudonym> Well this is kind of what you're doing here.
21:02:00 <Pseudonym> Only on lists, not numbers.
21:02:04 <Pseudonym> lengthList Nil = 0
21:02:08 <Pseudonym> That's the base case.
21:02:20 <Pseudonym> You find the list of Nil (a list of length 0).
21:02:25 <Pseudonym> lengthList (Cons _ xs) = 1 + lengthList xs
21:02:37 <Pseudonym> Now reading from right to left, you assume that you know the length of xs.
21:02:46 <Pseudonym> And then you use that to find the length of (Cons _ xs).
21:03:12 <FanBoy|haskell> hmm ok
21:03:17 <Pseudonym> Are you following?
21:03:37 <Pseudonym> Or did I lose you?
21:03:54 <FanBoy|haskell> I think i follow
21:03:59 <Pseudonym> OK.
21:04:19 <Pseudonym> In the problem that you have to solve, you'll need to do induction on Ints rather than ListInt.
21:05:10 <Pseudonym> So you need a) a base case, and b) a recursive case.
21:05:12 <Pseudonym> At least.
21:05:17 <FanBoy|haskell> ok
21:05:37 <Pseudonym> OK, so... the base case is usually easiest.
21:05:48 <Pseudonym> Write it. :-)
21:06:29 <FanBoy|haskell> Nil = 0 :P
21:06:39 <Pseudonym> Well that's a syntax error.
21:06:45 <FanBoy|haskell> heh yes sorry
21:06:54 <Pseudonym> You need to give your function a name, obviously.
21:06:56 <FanBoy|haskell> functionname Nil = 0 :]
21:07:08 <Pseudonym> What is the type of this function?
21:07:19 <FanBoy|haskell> calling it fill
21:07:23 <Pseudonym> OK.
21:07:26 <Pseudonym> Works for me.
21:19:19 <FanBoy|haskell> Ok im going to sleep on this, 5:20am here :> Thank you very much for your help and time though, most appreciated!
21:30:53 <Pseudonym> Another satisfied customer!
22:30:52 <akusai> hi
22:31:45 <KrispyKringle> hi
22:32:19 <akusai> ahem...it's kind of funny to see threescore nicks or so, and *no* messages...
22:32:43 <akusai> has everyone fallen asleep? :)
22:32:53 <KrispyKringle> i wish i could go to sleep now.
22:33:11 <akusai> ?
22:33:23 <KrispyKringle> im busy.
22:33:28 <KrispyKringle> no rest for the weary.
22:34:58 <akusai> hm...it may sound as a stupid question, but...what's the point of being in the channel while you're busy doing other things?
22:35:07 <tmoertel`> (we are contemplative)
22:35:37 <KrispyKringle> because sometimes people come in and want to chat, so, if he has something interesting to say, i might return.
22:35:39 <akusai> ahhh...yeah...staring at each other...in a subtly meaningful way ;)
22:35:53 <mflux> also, easier to pick up after returning?
22:36:02 <KrispyKringle> Are you one such interesting people?
22:36:04 <KrispyKringle> Time will tell.
22:36:16 <KrispyKringle> My skills at communication diminish as the night goes on.
22:37:00 <KrispyKringle> I speak in haiku; lack of sleep makes one weary; but one must do work.
22:37:58 <akusai> hm...my guess would be that one must sleep first :)
22:38:17 <akusai> (but i know the feeling, anyway :)
23:30:00 <lightstep> good morning
23:30:46 <bringert> morning
23:40:13 <musasabi> morning
23:52:58 <akusai> morning
23:55:22 * akusai is already overwhelmed by the pace of the discussion
23:55:30 <Itkovian> meuning
