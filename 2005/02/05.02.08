00:00:14 <araujo> well, it looks interesting this game of life thing
00:00:36 <shapr> It is very interesting. I played with it a lot when I was younger.
00:00:43 <araujo> about the emblem, do the world needs another one? 8)
00:00:54 * shapr shrugs
00:01:08 <shapr> I just think the glider is not fitting or inspired.
00:01:16 <shapr> It doesn't feel like an elegant hack to me.
00:01:30 <araujo> Indded. it doesn't look inspiring
00:01:49 <shapr> I think a hack is taking commonly available pieces, and doing something unexpected, with elegant and powerful results.
00:02:23 <araujo> Yes. That is what i actually preffer more the term "artist" 
00:02:27 <shapr> dons: was it da vinci's latest sculptures that had the figures emerging from the blocks of marble?
00:02:48 <araujo> There are many confusions about the term "hacker" nowadays that i just dislike.
00:03:36 <dons> hmm. not sure about da vinci, but I know the one you mean
00:04:13 <dons> been a while since my last visual arts class
00:04:13 <shapr> I'm fond of art, though not clueful about it.
00:05:58 <dons> I think rxvt is more responsive than good ole xterm
00:06:15 * araujo has bunch of Art books here
00:06:59 <shapr> I don't have any art books. Don't think I ever have. I have been to a bunch of art museums in various parts of the US. I really enjoy art museums.
00:07:42 <araujo> I got a bunch of them here because my dad is an artist.
00:08:01 <shapr> The best artists show me that magic and wonder is in everything. You just have to look at it the right way.
00:08:35 <araujo> i think that painting a picture is the more similar to hacking in my humble opinion.
00:08:52 <araujo> even more than making a sculpture
00:09:24 <shapr> The Icarus that Matisse made out of colored paper gives me that feeling.
00:09:32 <dons> I was found hacking to be more like lego construction :)
00:09:36 <araujo> Matisse is pretty good indeed.
00:10:03 <araujo> shapr, know Motherwell?
00:10:13 <araujo> i think it is terrific also to describe hacking
00:10:35 <shapr> Never heard of Motherwell. I'll ask google.
00:11:08 <gzl> I want to take a String s as input and return s in double quotes (i.e. "\"" ++ s ++ "\""). in hugs, the output is something like "\"foo\""; that's just because hugs is wrapping the string in its own set of quotes, right?
00:11:27 <araujo> shapr, he inspired his work in Picasso at the beginning
00:11:32 <dons> gzl: yep
00:11:35 <gzl> ok, good.
00:11:35 <gzl> thanks
00:12:00 <dons> you can just call show on the string to get the quotes though
00:12:22 <dons> Prelude> show "foo"
00:12:22 <dons> "\"foo\""
00:12:22 <dons> Prelude> head $ show "foo"
00:12:23 <dons> '"'
00:13:25 <shapr> I wish GHC had triple-quoted strings.
00:13:32 <dons> try putStrLn if you don't want hugs to pretty-print the string
00:13:38 <araujo> shapr, also look for Morandi
00:13:40 <shapr> I also wish for optional trailing commas in lists.
00:13:46 <dons> triple-quoted!
00:13:53 <araujo> Van Gogh is definetly another good example.
00:14:23 <shapr> Python allows you to start a string with """ or ''' and only be ended by that again, lets you dump a lot of literal text in there, including \n chars
00:14:42 <dons> oh, like in perl
00:14:59 <shapr> I like van gogh. I don't know Morandi. I can see Motherwell's resemblance to Picasso. Picasso had more structure and brighter colors though.
00:15:11 <dons> you can start a pattern with any char, and use that as a delimiter
00:15:35 <fraxtal> I wore my perl tshirt to school today
00:16:03 <shapr> Oh, I like Morandi
00:16:19 <dons> what about Moggi?
00:16:19 <shapr> fraxtal: did anyone try to correct the spelling on your tshirt?
00:16:31 <shapr> dons: I like his category theory art ;-)
00:17:14 <araujo> There is anothe rartist, i don't remenber his name... mmm
00:17:26 <shapr> dons: Luciano Moggi?
00:17:32 <araujo> I like "white-only" pictures.
00:17:43 <araujo> He did a lot of them...
00:18:13 <araujo> Im not good at frencha 8)
00:18:17 <araujo> french
00:18:28 <shapr> pas de problem ;-)
00:18:38 <dons> Eugenio Moggi, it was a silly joke :}
00:19:04 <dons> now, about that 20-box distributed ghc build. hmm..
00:19:06 <shapr> Whew, I couldn't find any artists with the last name Moggi.
00:19:12 <shapr> dons: betcha it explodes.
00:19:35 <dons> I reckon it won't.. but we'll see.
00:19:37 <shapr> I've filed a few bugs from make -j2 on my box.
00:19:45 <dons> on the head?
00:19:45 <shapr> If it doesn't, I'll be thrilled.
00:19:49 <shapr> nah, not on head.
00:20:06 <shapr> I gave up on -j2 after a few iterations, got frustrated.
00:20:07 <dons> yeah, 6.2.2 won't work. but I built the head today -j4 fine
00:20:17 <dons> but I want to try -j>20
00:20:20 <gzl> is it bad form to use "as" as a variable name?
00:20:27 <dons> nah
00:20:30 <gzl> cool
00:20:33 <shapr> it's a keyword
00:20:50 <araujo> oh well, 
00:20:57 <gzl> shapr: i know. but hugs doesn't seem to mind.
00:21:01 <shapr> import Foo.Bar as FB
00:21:15 <dons> f (a:as) = a : f as
00:21:19 <dons> that would be ok to me
00:21:27 <dons> though you'd usually use xs
00:21:30 <shapr> yeah, I'd use that pattern matching name setup.
00:21:59 <shapr> Moggi looks like a serious geek.
00:22:03 <dons> gzl: the 's' at the end of 'as' is a haskell idiom for a list value
00:22:06 <gzl> i know
00:22:12 <dons> k
00:22:13 <gzl> that's what i'm using it for :)
00:22:19 <dons> that's good :)
00:22:41 <shapr> Not that I look any less geeky, just more like a hippie geek instead of his yuppie geek look.
00:23:10 <dons> hehe
00:23:43 <shapr> I've been thinking about notions of computation, specifically how to map them onto new ways of processing.
00:24:11 <shapr> I think I need a collection of 'bases' or whatever you call that.
00:24:46 <shapr> For example, Turing complete can be broken down into a few different sets of operations, what do you call those various sets?
00:26:05 <heatsink> shapr: you could do interesting things by reducing the cost > O(n^2) of completely connecting things together.
00:26:29 <shapr> huh?
00:27:21 <shapr> je ne comprend pas! expliquez?
00:28:02 <heatsink> Just a thought... one of the limits on scaling computers is that to connect N things together you need N^2-N wires
00:28:10 <heatsink> which keeps N small.
00:28:18 <shapr> that is a neat thought.
00:29:03 <shapr> does that assume a circuits are laid out on a plane?
00:29:22 <heatsink> no
00:30:18 <shapr> ohh
00:30:36 <shapr> That's where the new crazy idea of nearest neighbor networks comes in handy.
00:30:54 <heatsink> This is a new idea?
00:31:06 <heatsink> Who talks about this?
00:31:21 <tuomov> shapr: same as usual.. not much is happening
00:31:36 <shapr> err, it is when you use it to replace high speed fiber interconnects in beowulf clusters with a bunch of 10baseT hubs arranged creatively.
00:31:45 <tuomov> still trying to find something remotely interesting to do
00:31:50 <Lemmih> Good morning, #haskell!
00:32:01 <shapr> tuomov: written any cool code lately?
00:32:33 <heatsink> ok
00:32:33 <tuomov> Added colour-coding to the ion statusbar, but not much else
00:33:29 <shapr> heatsink: do you know what I'm describing? there's a nearly total interconnect that you can create with a bunch of broadcast hubs.
00:34:56 <heatsink> Are they really broadcast hubs?  Because I don't see how that would work better than a single Ethernet line.
00:35:44 <heatsink> Hmm. I wonder, if you made a sufficiently long-latency loop of broadcast hubs, could a packet travel around that loop indefinitely?
00:36:14 <shapr> The idea was to get a beowulf cluster with ~80% of the bandwidth of a fiber backbone, for 20% of the cost.
00:37:20 <shapr> They put two or three NICs in each box, with each NIC connected to a different hub.
00:38:00 <shapr> The connectedness closely approaches total, and the way the nodes were connected to the hubs could dramatically increase connectedness.
00:38:11 <shapr> well, for some value of dramatic...
00:39:15 <shapr> Last I heard they set up a genetic algorithm to try to find better setups, and were trying out a few that their code had already found.
00:39:34 <heatsink> Okay, what i'm wondering is how a the hubs know which way to send a message.  I thought that hubs used very simple rules for forwarding.
00:41:57 <shapr> I don't remember, and I'm unable to google it up so far.
00:42:05 <shapr> I think I saw it on slashdot of all places.
00:43:53 <heatsink> I only have a vague idea of the interconnect's shape, don't understand.
00:43:57 <heatsink> But I need to log off and be unconscious for a while.
00:44:04 <shapr> heh, ok
00:44:16 <heatsink> goodnight. /quit
00:44:19 <heatsink> um
00:44:51 <shapr> Sometimes a word-based memory would be useful.
00:45:26 <shapr> But my original question was, how to map notions of computation to existing systems of computation?
00:46:02 <shapr> What are the computational bases?
00:49:34 <wagle> dna, membrane, quantum, turing, neural, cellular, lambda, markov, ...
01:01:30 * Lemmih wonders why his FFI code doesn't work.
01:22:04 <shapr> wagle: crystal, laser, and more
01:23:34 <shapr> wagle: but I think turing and lambda are bases, you execute them on ... media?
01:31:52 <wnoise> shapr: with hub-like architectures, one thing that can be done is have the "send-to identifier" portion of messages be description of how to route it from here to there.  Like the old-style bang paths.  Then each router is very simple, and hence very fast -- take head of route, send rest of packet to that destination.
01:32:20 <wnoise> hubs do use very simple methods -- broadcast everything.  Switches are what you want, if you can afford it.
01:32:58 <shapr> yeah, I have switches on my local lan
01:33:12 <shapr> but I thought they were using broadcast hubs for some reason on this cheap fiber replacement.
01:34:19 <musasabi> Would a pure-haskell postgresql binding be usefull to people?
01:34:20 <wnoise> (this routing method is from that hardware design company, used in their SPI switches, deep internally, at the microarchitecture level)
01:35:02 <shapr> musasabi: I'd like it, I wouldn't need HSQL for HaskellDB.
01:36:18 * musasabi is sick and is trying to get something fun and noninvolved for the day.. -> preliminary hacking.
01:38:55 <shapr> Anyone clueful about computability logic?
01:39:44 <musasabi> I am on a finite model theory course which is supposed to touch such things later on.
01:40:29 <shapr> Cool, I know who to ask when I have questions ;-)
01:42:33 <shapr> wnoise: it's funny to find UUCP in heavy duty parallel hardware.
01:43:05 <shapr> musasabi: do you know if computability logic would be useful in porting bases to 'different media' ?
01:44:21 <shapr> At first glance, it seems like a nicer way to do turing complete proofs.
01:47:20 <musasabi> Well it is quite abstract maybe even too abstract for using in daily stuff.
01:47:56 <musasabi> http://mathstat.helsinki.fi/logic/people/jouko.vaananen/shortcourse.pdf - notes from an older course with ~similar contents.
01:48:57 <shapr> yow
01:48:58 <wnoise> Well, there's no DNS available on chip...  hosts.txt though.
01:49:28 <tuomov> is alioth.debian.org for non-debian projects too these days?
01:49:49 <shapr> wnoise: er, what?
01:51:25 <wnoise> no good way of maintaining a distributed identifier->location mapping system.  But since for any given revision of a chip, we know where everything is...
01:51:45 <shapr> oh!
01:52:08 <shapr> From what I've read of Cell, they added DNS.
01:54:29 <shapr> @arr
01:54:30 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
01:54:33 <shapr> @monad
01:54:33 <lambdabot> Sorry, I don't know the command "monad", try "lambdabot: @listcommands"
01:54:37 <wnoise> Hmm.  "Never put off to runtime what can be done at compile time".
01:54:54 <shapr> Unless you're Alan Kay.
01:55:12 <wnoise> Speaking of which, I should either go to sleep, or do my stat-mech homework.
01:55:14 <wnoise> Heh.
01:55:34 <shapr> I should go to sleep, it's 11am.
01:56:16 <shapr> I think Alan Kay would love monads. I wonder if he knows them already.
01:56:17 <Lemmih> Note to self: Don't _ever_ use unsafe wrapper functions!
01:56:41 <shapr> Monads give the late binding Alan Kay loves, and compile-time power too.
02:01:57 <Lemmih> @index bracket
02:01:57 <lambdabot> Control.Exception,IO
02:22:27 <samc_> lo
02:22:32 <shapr> hi
02:22:51 <shapr> binary conversations...
02:23:14 <samc_> heh
02:23:51 <Lemmih> Woot Woot. Hacanon can now handle callbacks (-:
02:26:16 <glimming> good morning everyone
02:27:12 <samc_> arstechnica has a report on the cell
02:27:30 <glimming> I'm trying to write a mapping   fsplit :: (Functor f, Functor f') => (f a, f' b) -> (f :*: f') (a,b)    where   data (f:*f') o = Pair (f o) (f' o)   but I wonder if it is possible...
02:27:44 <glimming> This just does F AxB ---> FA x FB
02:29:42 <jlouis> abbreviate :: string -> string
02:29:50 <jlouis> abbreviate "DNS on chip"
02:58:25 <musasabi> how did I make parsec work with input from network?
03:00:46 <Lemmih> fmap parse (hGetContents handle)?
03:03:04 <glimming> I am giving a graduate  course in Advanced Functional Programming  and would appreciate all sorts of suggestions on what to cover. 
03:03:17 <glimming> I plan to use Eclipse and its Haskell support.
03:03:29 <glimming> But .NET is also an option (says Microsoft)
03:04:14 <dons> you could look at the AFP course taught at UNSW: http://www.cse.unsw.edu.au/~cs4132/
03:04:24 <glimming> Cheers
03:04:30 <dons> and the one at Chalmer's is excellent too
03:04:35 <dons> there are probably others
03:04:36 <glimming> I want to orient it towards generic Haskell a bit.
03:04:42 <musasabi> Lemmih: I was forgetting how to use getInput.
03:04:44 <glimming> But I will not cover so much compilers.
03:40:44 <Itkovian> @seen boege
03:40:44 <lambdabot> I haven't seen boege
03:40:45 <Itkovian> @seen boegel
03:40:46 <lambdabot> I saw boegel leaving #haskell 12 hours 47 minutes 36 seconds ago.
03:41:37 <glimming> @type map
03:41:41 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
03:41:48 <glimming> (sorry had to try)
03:55:07 <juhp> bwteim03
03:56:51 * juhp pulls his daughter away from the keyboard
03:59:03 <wilx> Heh.
04:10:48 <dons> hmm.maybe pvmgmake would be more suitable for distributing ghc invocations
04:22:39 <dons> 27mins to build ghc head+libs, with the .c compilation distributed across a cluster
04:22:57 <dons> so what we now need is to try to distribute ghc calls, not just gcc 
04:25:00 <musasabi> Is there really no function to read n bytes of a handle (except hGetN h n = replicateM n (hGetChar h)) ?
04:26:10 <dons> hGetBuf?
04:26:22 <dons> hGetBuf :: Handle -> Ptr a -> Int -> IO Int
04:26:34 <dons> -- | 'hGetBuf' @hdl buf count@ reads data from the handle @hdl@
04:26:34 <dons> -- into the buffer @buf@ until either EOF is reached or
04:26:34 <dons> -- @count@ 8-bit bytes have been read.
04:26:35 <dons> -- It returns the number of bytes actually read.
04:26:58 <musasabi> yes, but I was trying to avoid going with Ptrs.
04:27:33 <dons> ok. I don't think there is another way.
04:28:22 <musasabi> it all started from my Ptr api getting too complex...
04:28:31 <dons> hehe
04:28:49 <dons> distcc rules. I can build the ghc rts all ways in 57sec
04:29:10 <dons> it is really good for distributing C src builds
04:29:51 * dons wishes for disthc
04:31:52 <musasabi> I am reading only length prefixed items - the problem was that sometimes the length is quite large (> sizeof buffer) which was making things problematic.
04:31:59 <glimming> I have a problem with Functor instances that I posted to haskell-cafe. Anybody here that saw it and can help me interactively?
04:39:14 <TheHunter> glimming, data (a:*:b) o = Pair { p1 :: a o, p2 :: b o}
04:39:18 <TheHunter> proj = fmap fst . p1
04:43:15 <glimming> thanks, got that one for proj.
04:43:18 <glimming> The other one is harder.
04:44:46 <glimming> TheHunter: why do you prefer record style for products?
04:45:33 <glimming> The other case is:     fsplit :: (Functor f, Functor f') => (f a, f' b) -> (f :*: f') (a,b)       (the first was  ffst :: (Functor f) => (f :*: f') (a,b) -> f a)
04:46:10 <glimming> ffst=proj gives       F x F' AxB ---> F A
04:46:39 <glimming> whereas I now need fsplit :   (F A, F' B) --> FxF' AxB   i.e. the other way...
04:46:54 <TheHunter> glimming, this is just a comfortable way to define the projections, you can still use it as Pair 1 2
04:47:31 <glimming> TheHunter: I am sure you have good reasons, but I am curious and want to learn more, what makes it more convenient?
04:48:18 <TheHunter> the above definition does the same as:
04:48:28 <TheHunter> data ... = Pair (a o) (b o)
04:48:33 <TheHunter> p1 :: ...
04:48:39 <glimming> The problem with the mentioned fsplit that I need to define is that I have FxF' with its fmap   but I want to build two different FA and F'B ...
04:48:39 <TheHunter> p1 (Pair x _) = x
04:48:45 <TheHunter> p2 (Pair _ y) = y
04:49:13 <glimming> TheHunter: good, you learn something every day!
04:50:18 <TheHunter> glimming, i don't get fsplit
04:51:47 <TheHunter> (f :*: f') (a,b) =~= f (a,b) * f' (a,b)
04:51:51 <glimming> TheHunter: So is that generalised algebraic datatype? What is the type of p1 in Pair {p1::a o, p2::b o}
04:52:18 <TheHunter> glimming, no, that has nothing to do with gadts.
04:52:29 <glimming> The intention is to work in a product category, where FxF' AxB   is really FA x F'B
04:53:06 <TheHunter> p1 :: Pair (a :*: b) o -> a o
04:53:31 <glimming> Well it is like the operation of an algebra, from carrier to a o.
04:54:03 <TheHunter> yeah, or it's simply a projection.
04:54:14 <samc_> what sort of morphism is a unfold followed by a fold? 
04:54:15 <glimming> So you are saying my fsplit does something I'd not want it to?
04:54:28 <glimming> with the current type.
04:54:38 <TheHunter> glimming, then your :*: won't do that.
04:54:39 <glimming> hylomorphism?
04:54:52 <glimming> the reverse of hylo was studied by Jeremy Gibbons and Richard Bird recently.
04:55:18 <glimming> for streams and susch
04:55:23 <glimming> such
04:56:38 <glimming> So let me expand the problem. I retract what I said about product category. That was wrong.
04:56:48 <glimming> I really want a fsplit of this type.
04:57:15 <glimming> And I can build it from FA, FB, F'A F'B, B, A which I have at my disposal.
04:57:36 <glimming> (don't ask why ;-))
04:57:41 <TheHunter> if it's ok to define data (f :*: f') a b = Pair (f a) (f' b), then this is the easiest way out.
04:57:55 <TheHunter> otherwise, you're gonna have to mess around with type classes.
04:58:23 <glimming> TheHunter: good I will revert to old definition then in the code
04:58:31 <glimming> saved me some time there ;-)
04:58:38 <samc_> cheers, glimming
04:59:04 <glimming> samc_ who is samc_ who is so interested in dual hylo?
04:59:24 <glimming> ;-) Must be an interesting person who is interested in that... Tell me!
04:59:39 <TheHunter> class isPair p a b | p -> a, p -> b where p1 :: p -> a; p2 :: p -> b
04:59:41 <samc_> no I'n not interesting
05:00:01 <glimming> ;-) Are you doing research on hylo stuff?
05:00:18 <glimming> (even modest!)
05:00:31 <glimming> glimming thinks he is in love
05:02:20 <basti_> hi
05:02:41 <samc_> eww
05:02:50 <basti_> yuck?
05:02:55 <samc_> not you basti_
05:03:21 <samc_> no official research
05:04:11 <glimming> TheHunter: So Indeed I want F (AxB) x F' (AxB) weird as it may seem
05:06:08 <TheHunter> hmm, then you can't define fsplit
05:06:31 <glimming> why not?
05:06:49 <glimming> I have A,B,FA,FB,F'A,F'B at my disponsal.
05:07:04 <glimming> So I should be able to bake up F(AxB)xF'(AxB) somehow....
05:07:31 <TheHunter> fsplit :: (Functor f, Functor f') => (f a, f' b) -> (f :*: f') (a,b)
05:07:51 <TheHunter> you have FA and F'B, haven't you?
05:08:12 <glimming> Yes so we can add a -> b -> f' a -> f b -> ... too
05:08:21 <glimming> I have all these, isn't it great?
05:08:42 <TheHunter> you can't use a and b.
05:09:04 <glimming> (In fact I used them already to get FA,...,FB but that's not relevant)
05:10:04 <TheHunter> still, no way to get from f a and f b to f (a,b)
05:10:34 <TheHunter> what are your functors, anyway?
05:11:38 <glimming> So put more simply I first need fsplit0 :: (Functor f) => F A, FB -> F AxB
05:11:52 <glimming> My functors are polynomials and the idea is that I really don't know ;-) (generic)
05:12:54 <TheHunter> you need additional structure, such as in http://www.haskell.org/arrows/arrows/Control.Sequence.html
05:14:01 <TheHunter> of course, your functors being monads would do it, too
05:14:25 <glimming> Interesting!
05:14:56 <TheHunter> a have no idea how (if possible) to derive that for polynomial functors, though.
05:15:58 <glimming> Strange, because it seems an easy property of any cartesian closed category
05:16:47 <TheHunter> well, actually that should be easy for polynomials.
05:16:50 <glimming> what would monads give us?
05:17:05 <TheHunter> @type liftM2 (,)
05:17:06 <lambdabot> bzzt
05:17:11 <TheHunter> @type Control.Monad.liftM2 (,)
05:17:13 <lambdabot> Control.Monad.liftM2 (,) :: forall a1 a2 m.
05:17:13 <lambdabot> 			    (Monad m) =>
05:17:13 <lambdabot> 			    m a1 -> m a2 -> m (a1, a2)
05:18:55 <glimming> Yes, I think we are requiring strong functors or something like that, but I am not sure.
05:19:02 <glimming> The property of F to distribute over X.
05:19:05 <glimming> X being product
05:19:46 <glimming> And I conjecture - right or wrong - that all polynomials are such.....
05:20:17 <glimming> So maybe I need to subclass Functor into StrongFunctor here
05:20:25 <glimming> with a map strength as well
05:24:05 <glimming> A monad gives a map a -> m a which is perhaps more than we want here, but I am not sure.
05:26:02 <TheHunter> yeah, we can't expect polynomials to be monads.
05:26:23 <TheHunter> mu :: ((a,a),(a,a)) -> (a,a) seems strange.
05:27:39 <TheHunter> lift0 :: a -> f a doesn't pose a problem, though.
05:30:46 <glimming> CORRECTION. This will maybe not hold for functors involving +.
05:31:03 <glimming> I think that what I want here is NOT strength but rather that F preserves products.
05:31:14 <glimming> and right adjoints preserves products.
05:31:50 <glimming> I am not familiar to liftO
05:31:54 <glimming> nor this particular mu.
05:31:58 <glimming> (the type here)
05:32:04 <glimming> what is m?
05:32:27 <TheHunter> m usually denotes a monad in haskell.
05:32:40 <glimming> sure, what is the tyype of m in lift monad here?
05:32:48 <glimming> I take it is some particular m?
05:32:54 <TheHunter> @type return
05:32:56 <lambdabot> return :: forall m a. (Monad m) => a -> m a
05:33:00 <TheHunter> @type join
05:33:02 <lambdabot> bzzt
05:33:07 <TheHunter> @type Control.Monad.join
05:33:09 <lambdabot> Control.Monad.join :: forall a m. (Monad m) => m (m a) -> m a
05:35:50 <glimming> Thanks, and this particular LiftMonad?= and liftM?
05:36:13 <TheHunter> i don't understand your question, sorry
05:37:08 <glimming> Oh, you referred to lift0 above.
05:37:32 <glimming> and
05:37:32 <glimming> @type Control.Monad.liftM2 (,)
05:37:34 <lambdabot> Control.Monad.liftM2 (,) :: forall a1 a2 m.
05:37:34 <lambdabot> 			    (Monad m) =>
05:37:34 <lambdabot> 			    m a1 -> m a2 -> m (a1, a2)
05:37:56 <TheHunter> @type Control.Monad.liftM2
05:37:58 <lambdabot> Control.Monad.liftM2 :: forall r m a2 a1.
05:37:58 <lambdabot> 			(Monad m) =>
05:37:58 <lambdabot> 			(a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:38:24 <TheHunter> this takes a twoary function and lifts it into the monad, which is exactly what you wanted above.
05:38:32 <glimming> binary!
05:38:35 <glimming> ;-)
05:38:53 <glimming> Neat.
05:39:05 <glimming> This was complicated stuff.
05:39:05 <TheHunter> lift0 is from Ross Patersons Sequence library and does the same as return for monads.
05:42:35 <TheHunter> fsplit0 doesn't seem to generally make sense for sums.
05:44:42 <TheHunter> @wiki HaskellIrcPastePage
05:44:42 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:45:05 <TheHunter> this seems to be as far as you can get with polynomials
05:52:00 <glimming> Yepp, and you cannot have sum in that class of polynoimials so it is not really polynomials
05:53:06 <TheHunter> you can still do special polynomials: instance Sequence f => Sequence (Zero :+: f) where ...
05:53:51 <TheHunter> hmm, make that One :+: f
05:55:07 <glimming> That's strange
05:55:10 <TheHunter> nah, Zero was right
05:55:34 <TheHunter> what the hell is wrong with me?
05:55:39 <glimming> because (+1) (A x B) = (A+1)x(B+1)  does NOT hold in algebra
05:55:43 <TheHunter> of course it should be one.
05:56:12 <TheHunter> it's just... my definition of One was wrong.
05:57:49 <TheHunter> yaeh, that's because you lose information if you have Inl One and Inr x.
05:58:54 * wli takes another stab at programmatically factoring a quartic with rational coefficients into a product of 2 quadratics with real coefficients expressed in terms of radicals and rational operations.
06:06:28 <ikegami--> I wonder why Haskell does not have the standard function which means the inverse of intersperse, like "split" in Perl
06:07:32 <ikegami--> I often want to split "a,b,c" => [a,b,c]
06:08:04 <ikegami--> Of course, writing code is easy but I often use it
06:31:06 <Cale> ikegami--: Well, it's a bit less convenient, but split from http://www.haskell.org/hawiki/LicensedPreludeExts seems to do just that
06:37:47 <ikegami--> aha
06:37:52 <ikegami--> Cale: thanks
07:05:04 <Cale> ikegami--: welcome :)
07:07:15 <glimming> I have a problem.
07:08:35 <glimming> I want to map F A into F (AxB) -- but B can be held constant!
07:09:00 <glimming> so I try fmap (\x -> (x,B)) 
07:09:03 <glimming> should that be enough?
07:09:13 <glimming> I get a too specific type.
07:10:07 <TheHunter> @type \x -> fmap (\y -> (y,x))
07:10:08 <lambdabot> \x -> fmap (\y -> (y,x)) :: forall f t a.
07:10:08 <lambdabot> 			    (Functor f) =>
07:10:08 <lambdabot> 			    t -> f a -> f (a, t)
07:10:18 <Cale> by "fmap (\x -> (x,B))" do you mean "fmap (\x -> (x,b))" for a particular b?
07:11:33 <glimming> indeed
07:11:47 <glimming> it seems fine so far.
07:11:55 <glimming> I assume b is instance of Functor f' here
07:12:17 <glimming> oopos I mean to say F A into FxF' (AxB) above
07:13:31 <Cale> So you mean you have (F A)x(F' B) ?
07:14:09 <Cale> you just want to fmap over one of the components in that case
07:14:11 <glimming> No, I have F A and some fixed B
07:14:25 <Cale> what's the actual Haskell type of what you're working with?
07:14:59 <glimming>   psipp :: (Functor f, Functor f') =>
07:15:00 <glimming>     (Obj f, Obj f') -> 
07:15:00 <glimming>     Object Id (f:*:f') (Either (Obj f) (Obj f')) (Obj f, Obj f')
07:15:58 <glimming> where Object and Obj has particular meaning. 
07:16:17 <glimming> Obj f is short for Direc (Object Id f)
07:16:42 <glimming> Object f' f a b = f' a -> f b
07:16:51 <Cale> ah
07:17:06 <Cale> heh, it looked like f wasn't being applied to anything
07:17:21 <glimming> Direc is short for ! (f (Direc f) (Direc f)) 
07:17:41 <glimming> but all of this is irrelevant
07:18:25 <glimming> When in fact it was applide to itself!!!!!
07:18:39 <Cale> :)
07:19:07 <glimming> My problem is that ghci infers same type but where f=f' for some reason
07:19:19 <glimming> It is hard to find what I have done wrong here.
07:20:39 <Cale> hmm...
07:20:41 <glimming> @lispurl
07:20:41 <lambdabot> Sorry, I don't know the command "lispurl", try "lambdabot: @listcommands
07:20:57 <TheHunter> @wiki HaskellIrcPastePage
07:20:57 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:21:44 <glimming> Is there no other page?
07:22:04 <Cale> hm?
07:22:20 <TheHunter> that lisp bot doesn't have haskell syntax highlighting, so i'd suggest you use the wiki page.
07:23:20 <glimming> Ok pasted it
07:23:28 <glimming> No auto-notify in IRC? ;-)
07:23:41 <glimming> We should have a subdir in wiki for this forum.
07:24:16 <glimming> psipp pasted there. That definition is too specific for the type I have written for it.
07:25:20 <TheHunter> glimming, a good way to debug that kind of thing is to replace part of the definition with undefined an see after which change the compiler infers the right type.
07:26:13 <glimming> TheHunter: thanks I was about to ask for such a thing.
07:27:03 <TheHunter> sadly, you can't ask the compiler what type it infers for the undefined.
07:27:44 <glimming> That is a good thing to add!
07:27:49 <glimming> Contextual type check.
07:28:02 <glimming> Such as :t undefined(2) in .....
07:28:08 <glimming> where 2 refers to second occurrence
07:28:14 <glimming> some sort of pattern matching here would be nice
07:28:30 <glimming> Shall I propose this to haskell mailing list, or will you?
07:29:00 <glimming> fmap (\y -> (obj f, y)) (sapp (obj f'))) was the prob'
07:29:28 <kosmikus> I doubt this would get added, but you can of course try
07:29:29 <TheHunter> glimming, go ahead.
07:29:34 <kosmikus> glimming: so it's solved now?
07:29:43 <glimming> Not really.
07:29:56 <glimming> I must be blind but fmap (\y -> (obj f, y)) (sapp (obj f'))) is not wrong !!!
07:30:15 <glimming> Everything is symmetric in this def.
07:30:39 <glimming> If I told you what this psipp computes I'd have to zap you (well, zip you) to outer space ;-)
07:31:26 <glimming> Haskell is only a language for good chess players! That's why it will never be mainstream.
07:31:45 <kosmikus> Can't you paste something reasonably complete? Your definition is not enough to find the error.
07:32:07 <glimming> You have CVS access to hSigma
07:32:29 <kosmikus> yes, but I'm not the only one who might be willing to help you
07:32:44 <glimming> It's in Ocons.hs, try ghci src/Ocons.hs and you will enjoy a strange type.
07:33:13 <glimming> Sure I'll paste a bit more then.
07:33:23 <glimming> @wiki HaskellPastePage
07:33:23 <lambdabot> http://www.haskell.org/hawiki/HaskellPastePage
07:34:00 <araujo> Morning around here.
07:37:09 <glimming> pasted al dente
07:38:01 <glimming> Btw, is it zope for wiki?
07:38:42 <glimming> shapr: do you maintain the wiki?
07:40:04 <Cale> dimap :: (a -> b) -> (c -> d) -> (g b c) -> (g a d) -- really?
07:40:18 <glimming> Yes, why?
07:40:40 <Cale> you pass it an (a -> b) and it's turning a b into an a
07:41:02 <musasabi> Is ghc-6.4 threaded by default?
07:41:37 <glimming> Cale: I do not understand...
07:41:47 <glimming> How turning a b?
07:41:49 <Cale> I would expect
07:41:55 <Cale> (a -> b) -> (c -> d) -> (g a c) -> (g b d)
07:42:15 <glimming> There is contravariance lurking here.
07:42:17 <glimming> in ->
07:42:56 <glimming> I do not think dimap is the problem here.
07:42:58 <glimming> But perhaps how I use it.
07:43:06 <Cale> hmm...
07:43:09 <glimming> Rather, I think it is sapp f' that causes the problem
07:43:13 <glimming> I am  not sure
07:43:37 <glimming> If I comment out the row with sapp f' it is well-typed with most general type as I have suggested
07:43:47 <glimming> Which is a bit strange since the definition is rather symmetric.
07:44:01 <glimming> I mean, I see little difference for the Right component.
07:44:17 <glimming> (dimap works in other settings !)
07:44:30 <Cale> right - I see how you represent that now
07:44:44 <glimming> Sidetrack: how can somebody name a theorem prover Coq? Somebody hate English?
07:45:19 <glimming> Btw, if somebody is a PhD student eager to do this sort of research I am always intereseted in coauthors and such. 
07:45:29 <glimming> Or better Senior Professor ;-)
07:50:22 <basti_> shapr: poing!
07:50:37 <glimming> No this definition of psipp is a real beast! How can it possibly be wrong when the first part is general enough, and the second part is completely symmetric.
07:53:28 <glimming> the problem is in fact (fmap (\y -> (obj f, y)) 
07:53:35 <glimming> if it is replaced to undefined it flies
07:58:18 <TheHunter> glimming, got it?
07:58:19 <Cale> what is the type of (fmap (\y -> (y, obj f')) (sapp (obj f))?
07:59:08 <tintin> glimming: so you are a professor ? 
07:59:24 <TheHunter>   Left ff -> Pair (fmap (\y -> (y,obj f')) (f (Id ff)))
07:59:24 <TheHunter>                   (fmap (\y -> (obj f,y)) (sapp (obj f')))
07:59:25 <glimming> NOOOO
07:59:29 <glimming> I am just a PhD student
07:59:35 <TheHunter> right should be analagous
08:00:32 <glimming> Whereas kosmikus has a hat.
08:01:12 <glimming> are there professors around.
08:01:17 <glimming> Indeed It should be.
08:01:21 <glimming> And it is.
08:02:15 <glimming> TheHunter: what are you saying, that Left is wrong??
08:02:26 <glimming> are there professors around?
08:02:31 <glimming> Peyton-Jones e.g.?
08:02:48 <glimming> Or just us kids....
08:02:55 <Cale> glimming: note that TheHunter actually changed some things there
08:02:58 <TheHunter> glimming, i guess.
08:03:17 <tintin> there are professors hidden as kids :)
08:03:20 <glimming> If TheHunter did, and it works, then I am very impressed.
08:03:34 <glimming> Most are.
08:03:38 <tintin> and all professors are kids :) they like to play with stuff ...
08:03:40 <glimming> So tintin is professor?
08:03:47 <tintin> no 
08:03:59 <glimming> What "famous" people have been seen is in this window?
08:04:13 <tintin> not sure ask shapr 
08:04:16 <glimming> I am getting scared here, all the bad jokes I have been pulling....
08:04:21 <tintin> he keeps track of the celebs :)
08:04:40 <Philippa_> glimming: if you think you've got a problem, I'm in deep shit...
08:04:49 <glimming> Hehe
08:05:04 <tintin> wait for your grades .... 
08:05:12 <glimming> Philippa_: how's that?
08:05:27 <glimming> tintin is Philippa_'s lecturer?
08:05:27 <tintin> if they are good you were lucky ... 
08:06:27 <glimming> TheHunter: why did you move my obj f' ?
08:06:37 <TheHunter> glimming: this typechecks
08:06:38 <tintin> I know what you did in #haskell .... (coming back to haunt you this term)
08:06:39 <TheHunter>   Left ff -> Pair (fmap (\y -> (y,obj f')) (f (Id ff)))
08:06:39 <TheHunter>                   (fmap (\y -> (obj f,y)) (sapp (obj f')))
08:06:45 <Philippa_> tintin: I'm pretty sure gmh doesn't hang out here, so I'm reasonably safe
08:06:45 <TheHunter> sorry
08:06:48 <TheHunter> psipp (Dinn (Object f), Dinn (Object f')) = Object (\(Id x) -> case x of 
08:06:48 <TheHunter>   Left ff -> Pair (fmap (\y -> (y,obj f')) (f (Id ff)))
08:06:48 <TheHunter>                   (fmap (\y -> (obj f,y)) (sapp (obj f')))
08:06:48 <TheHunter>   Right ff' -> Pair (fmap (\y -> (y,obj f')) (sapp (obj f)) )  
08:06:48 <TheHunter>                     (fmap (\y -> (obj f,y)) (f' (Id ff')))
08:06:51 <TheHunter>     )                                                                          
08:07:02 <Philippa_> though he must think I'm either brilliant or completely crazy by now
08:07:18 <glimming> Graham Hutton?
08:07:28 <Philippa_> yeah
08:07:33 <glimming> So you're in Nottingham?
08:07:36 <Philippa_> right
08:07:43 <glimming> Graham is writing a new book.
08:07:49 <Philippa_> yep
08:07:51 <glimming> You're Graham's undergrad?
08:08:12 <glimming> Graham is a nice chap.
08:08:16 <Philippa_> yeah, he's supervising my final "year" (er, I've lost track of how long I've been working on it in theory) dissertation project
08:08:39 * Philippa_ nods
08:08:59 <Philippa_> a mild surprise if you're used to talking to people who get enthusiastic easily, but the other side of that is he means his compliments
08:09:02 <glimming> TheHunter: how did you figure out that so quicklÃ¶y?
08:09:33 <glimming> Philippa_, that being a MSc ?
08:09:51 <Philippa_> BSc
08:09:52 <glimming> TheHunter: I thought I understood what I was computing...
08:09:56 <Philippa_> UoN doesn't do MScs
08:10:00 <Philippa_> well, not in compsci
08:10:03 <glimming> Aaah, Nottingham is a tough place.
08:10:24 <Philippa_> nah, most UK universities do BSc (hons) and thus have a final year project or equivalent
08:10:49 <Philippa_> I'm throwing myself muchly into the deep end on that and doing something that's decidedly research-level
08:11:29 <Philippa_> though really all I've done is find a neat bunch of restrictions for a subtyping relationship on ADTs that fits in well with H-M-style inference and do a bit of thinking about how it interacts with type classes
08:11:39 <glimming> TheHunter: it types!
08:12:27 <glimming> Philippa_: aiming for a research career. And early on. Wow!
08:12:32 <TheHunter> glimming, well, i actually don't have much of an idea what is going on there, just looked a bit at the types.
08:12:48 <glimming> subtyping restrictions?
08:12:50 <glimming> sorry
08:13:07 <glimming> Tell me more!
08:13:31 <glimming> TheHunter: you got me worried.
08:13:31 <Philippa_> glimming: I'm 22, I should've graduated by now. 'snot that early really.
08:13:43 <glimming> Single? ;-)
08:13:48 <Philippa_> nope
08:13:54 <glimming> Darn.
08:13:58 <glimming> ;-)
08:14:14 <Philippa_> plus a strong preference for other women and a tendency to do things to guys that bother most straight men :-)
08:14:34 <Philippa_> anyway...
08:15:13 <TheHunter> glimming, it should behave like
08:15:17 <TheHunter> psi :: a -> b -> Either a b -> (a,b)
08:15:17 <TheHunter> psi x y (Left z) = (z,y)
08:15:17 <TheHunter> psi x y (Right z) = (x,z)
08:15:19 <TheHunter> right?
08:15:27 <glimming> indeed.
08:15:27 <Philippa_> if you define your type constructors as being either data constructors or sums of types, you get a fairly clear hierarchy, yes? There's a fairly obvious restriction, which is that the kinds of the type constructors in a sum must match
08:15:57 <Philippa_> from there on, you just unify types by looking for their least upper bound rather than checking they're equal and failing otherwise
08:16:22 <Philippa_> okay, "hierarchy", it's not really that because any given type can have an arbitrary number of immediate supertypes. You get the point though.
08:17:34 <glimming> Paste an example...
08:17:51 <Philippa_> I don't have an implementation quite as-described, but:
08:18:15 <glimming> You want to subtype disjoint sum types?
08:18:33 <Philippa_> yeah. Well, more supertype - you can't add an arbitrary subtype out of the blue
08:18:40 <Philippa_> (it'd screw up pattern-matching no end)
08:18:55 <glimming> is this structural or nominal subtyping?
08:18:57 <Philippa_> you /can/ add a new supertype, because you're just describing a new type in terms of existing ones
08:19:08 <glimming> I used to have the office next to Graham, btw.
08:19:24 <Philippa_> cool
08:20:42 <Philippa_> Nominal, in that a supertype is always a sum of named types and the 'leaves' are (named) data constructors (you can't build a value of that type without using the data constructor). It's not far off being structural though, IYSWIM
08:21:55 <Philippa_> to use haskell-like notation, data Sub a = Sub Int a; {-data constructor-} data Sup a = Sub | SomeOtherSub; {-type constructor that sums other type constructors-}
08:22:25 <Philippa_> really the type variable in Sup's definition is... irrelevant, it can be inferred and there's nothing you can do with it there and then
08:22:30 <glimming> Sounds very promising. Keep up the good work. Hard work pays off.
08:22:35 * Philippa_ shrugs
08:22:50 <Philippa_> I have an implementation that takes similar syntax to that and looks a bit like the pure subset of Haskell minus a lot of sugar
08:22:57 <Philippa_> Type classes combined with this are where the real fun is
08:23:42 <Philippa_> you get a lot of interesting interplay, you're effectively cross-cutting between two type systems that're close to dual (one types data, the other codata)
08:29:29 <esap> what is this, again OO type systems discussion? :-)
08:29:56 <Philippa_> heh
08:30:00 <Philippa_> I got asked about my project
08:30:18 * esap wants to hear more :-)
08:30:21 <tintin> hehe 
08:30:32 * esap goes to check the log.
08:31:08 <glimming> VERY interesting
08:32:40 <tintin> goodluck Philippa_ and get it done superquick :)
08:32:59 <Philippa_> esap: it's the same old same old I've been talking about for ages, sadly. I never get round to an implementation because the inference is mildly hairy
08:38:48 * esap got my OO library to work for most part.
08:38:59 <Philippa_> cool
08:39:09 <Philippa_> in my case, I'm not really looking to type OO per se
08:39:34 <glimming> esap: post url to your oo library
08:40:14 <esap> glimming: I haven't published it yet. It still needs some cleanup and probably support for some additional things before I'm confident enough to publish it.
08:40:40 <glimming> keep me updated
08:40:40 <esap> glimming: I don't have inheritance yet, which I suppose would be required for an OO library.
08:43:44 <Philippa_> arguable
08:43:48 <Philippa_> delegation'd do
09:48:13 <esap> Hmm.. is there some reason I can't have a class and a data type with the same name?
09:57:02 <kosmikus> export/import list syntax
09:57:43 <esap> ok hmm.
09:58:11 * esap would have got somewhat better syntax for OO if class and data type with same name could exist.
09:59:23 * boegel jumps around like a crazy man
10:02:57 <liquidengineer> hey
10:03:20 <liquidengineer> question: 
10:03:31 <liquidengineer> does anyone know a good chat room for calculus related problems?
10:04:29 <Lemmih> #math?
10:04:42 <Lemmih> Greetings, SyntaxNinja.
10:05:35 <fraxtal> liquidengineer: This channel and maybe the one on undernet are the only math chat rooms i've ever heard of
10:06:02 <wli> EfNet #math is a real math IRC channel
10:06:02 <fraxtal> liquidengineer: Err wrong channel, I thought this was #math 
10:06:11 <wli> There's one on UnderNet too IIRC.
10:06:24 <wli> freenode #haskell isn't a math channel.
10:10:37 * shapr awakens
10:12:24 <shapr> wheeee
10:13:47 <shapr> When people wave to me, I always try to particle back.
10:14:36 <SyntaxNinja> hihi Lemmih
10:15:07 * SyntaxNinja waves at shapr
10:15:38 * shapr particles back at SyntaxNinja 
10:16:30 <shapr> How's the Ninja biz? Anyone dropped a spoon lately?
10:17:42 <desrt> freenode #haskell tends to get mathy and #math tends to get haskelly
10:18:13 <shapr> glimming: yes, I maintain the wiki.
10:18:16 <glimming> is there an expert on bananas in space around? or catamorphism etc?
10:18:31 <fraxtal> Limit of your mind as mushrooms->infinity == haha there is no limit
10:18:56 * desrt watches the channel diverge
10:18:57 <shapr> That's always reminded of The Muppet Show. Pigs in SPACE!
10:20:55 <Fromagxo> hi, people
10:21:02 <Fromagxo> i have a problem with a line
10:21:03 <shapr> hola
10:21:16 <Fromagxo> if fEsAnterior(fecha,fechaf) && ! fEsAnterior(fecha,fechai) then 
10:21:37 <Fromagxo> What is wrong there?
10:21:43 <Fromagxo> Hugs gives me the following error
10:22:01 <Fromagxo> ERROR C:\Archivos de programa\Hugs98\Prac11h.hs:35 - Syntax error in expression (unexpected `;', p
10:22:01 <Fromagxo> ossibly due to bad layout) 
10:22:14 <glimming> check indentation
10:22:23 <Fromagxo> what's that?
10:22:39 <glimming> and brackets ...
10:24:08 <glimming> I have a question about functors of form F:C^op x C ---> C and bananas in space.
10:24:29 <Fromagxo> can anybody help me with this ?
10:24:48 <Fromagxo> it's a matter of life or death
10:24:58 <shapr> how so?
10:25:30 <Oejet> Fromagxo: Debugging a nuclear reactor?
10:25:43 <Fromagxo> Almost that
10:25:51 <Fromagxo> Trying to success in my fuc*** exam
10:25:54 <glimming> The problem is that when providing the maps phi and psi I require a map into something which has an object in C^op
10:25:56 <Fromagxo> I have to do it tomorrow
10:26:15 <glimming> The problem with that object in C^op is that from AxB I will get A+B, i.e. limits becomes colimits.
10:26:20 <Oejet> Fromagxo: Do you like Haskell?
10:26:24 <glimming> So I am lost at how to write catamorphism.
10:26:40 <Fromagxo> Not at all, Oejet 
10:26:56 <Fromagxo> I'm used to programme with other kind of languages
10:26:58 <Fromagxo> Haskel is ...
10:27:01 <glimming> When working in C^op for AxB since the direcursion scheme is not fit for such an exercise as expressed by Achim Jung , Freyd, or Hutton/Meijer.,
10:27:04 <Fromagxo> well, it makes me puzzled everytime
10:27:14 <Oejet> not like Java?  ;-)
10:27:23 <Fromagxo> I don't like java
10:27:27 <Fromagxo> I prefer C or Ada
10:27:28 <glimming> Java is a great language.
10:27:34 <SyntaxNinja> Oo
10:27:47 <Fromagxo> So The question is ...
10:27:59 <Fromagxo> Why the interpreter complains about a ";" that does not exist in that line?
10:28:15 <Fromagxo> if fEsAnterior(fecha,fechaf) && ! fEsAnterior(fecha,fechai) then return true ...
10:28:18 <glimming> So I seem to get A+B instead of AxB....
10:28:27 <edwinb> fromagxo: That usually means you've done the layout wrong; possibly on a different line.
10:28:29 <glimming> ... in the contravariant position of a difunctor.
10:28:39 <edwinb> that line on its own is probably okay
10:28:45 <Oejet> Fromagxo: Could you paste your code?
10:28:51 <Fromagxo> OK ...
10:29:00 <glimming> Not ALL code and not here.
10:29:04 <SyntaxNinja> what's that "!" for?
10:29:17 <Fromagxo> It should be the logical NOT
10:29:22 <Fromagxo> fPertenece :: (TipoFecha, TipoIntervaloFechas) -> Bool
10:29:23 <Fromagxo> fPertenece(fecha,(fechai,fechaf)) =
10:29:23 <Fromagxo> if fEsAnterior(fecha,fechaf) && ! fEsAnterior(fecha,fechai) 
10:29:23 <Fromagxo> 	then	True
10:29:23 <Fromagxo> 	else	False
10:29:25 <glimming> @wiki HaskellCut
10:29:27 <SyntaxNinja> it's NOT
10:29:29 <SyntaxNinja> ;)
10:29:32 <Fromagxo> NOT ?
10:29:34 <Fromagxo> !!!!!!!
10:29:39 <Fromagxo> OK, let me change it
10:29:55 <shapr> oops, lambdabot overflowed.
10:30:04 <SyntaxNinja> shapr: from too many "!"s?
10:30:14 <shapr> heh
10:30:15 <glimming> (glimming is becoming an IRC expert here)
10:30:25 <SyntaxNinja> Fromagxo: I get the feeling you may be judging Haskell too soon ;)
10:30:30 * shapr pats lambdabot 
10:30:39 <SyntaxNinja> Fromagxo: what are those commas for?
10:30:52 <Fromagxo> Because that kind of data needs them
10:30:54 <Fromagxo> It's a ...
10:31:01 <Fromagxo> Well, i'm gonna paste it
10:31:09 <SyntaxNinja> is it a tuple? OK
10:31:10 <Fromagxo> type TipoFecha = (Int,Int,Int)
10:31:10 <Fromagxo> type TipoIntervaloFechas = (TipoFecha,TipoFecha)
10:31:10 <Fromagxo> type TipoIntervalos = [TipoIntervaloFechas]
10:31:12 <Fromagxo> tuple, yes
10:32:00 <glimming> shapr: lambdabot is written in what language?
10:32:27 <shapr> in Haskell of course.
10:32:33 <glimming> How come it overflowed?
10:32:57 <shapr> Likely a space leak somewhere.
10:33:10 <glimming> ?
10:33:18 <Fromagxo> It is completly illogical !!
10:33:31 <Fromagxo> Why does it complain about a ";" when they don't exist in Haskell?
10:33:37 <glimming> How do you access types of Haskell expressions, do you use Jones' typing haskell in haskell stuff?
10:33:48 <Fromagxo> Syntax error in expression (unexpected `;', p
10:33:48 <Fromagxo> ossibly due to bad layout) 
10:33:56 <shapr> Fromagxo: because the whitespace significant layout is translated into a {}; form. Yes, bad layout.
10:34:02 <Lemmih> Fromagxo: Hugs inserts them on its own.
10:34:19 <Fromagxo> if fEsAnterior(fecha,fechaf) && NOT(fEsAnterior(fecha,fechai)) 
10:34:23 <Fromagxo> this is the line
10:34:40 <Lemmih> Fromagxo: Try GHC for better error messages.
10:34:45 <shapr> glimming: Do you mean how is module state saved? THIH isn't used.
10:35:17 <glimming> shapr: you query types of Haskell expressions
10:35:43 <shapr> Oh, that just shells out to ghci
10:35:51 <glimming> aha
10:36:19 <SyntaxNinja> Fromagxo: NOT is not not in haskell, nor is "!", but rather, not.
10:36:20 <shapr> Which means there are some security holes there, but no one has tried them yet.
10:36:28 <SyntaxNinja> Fromagxo: in other words, try "not"
10:36:33 <shapr> SyntaxNinja: whoa, quotable
10:36:36 <Fromagxo> ahhh
10:36:37 <Fromagxo> yes
10:36:46 <Fromagxo> thank you
10:37:31 <Fromagxo> it continues giving me the same error, SyntaxNinja 
10:37:39 <Fromagxo> Look at this simplified version of the previous function
10:38:05 <Fromagxo> fPertenece :: (TipoFecha, TipoIntervaloFechas) -> Bool
10:38:05 <Fromagxo> fPertenece(fecha,(fechai,fechaf)) =
10:38:05 <Fromagxo> if fEsAnterior(fecha,fechaf) && fEsAnterior(fechai,fecha)  then True
10:38:05 <Fromagxo> 	else	False
10:38:31 <SyntaxNinja> Fromagxo: be sure that your "if" is indented as well as your "then" and your "else".
10:38:41 <SyntaxNinja> also, please paste stuff on the haskell wiki
10:38:45 <SyntaxNinja> @wiki HaskellIrcPastePage
10:38:45 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
10:38:49 <glimming> >glimming added lambdabot to his buddy list
10:38:51 <Igloo> And don't use tabs or the monsters will eat you
10:39:08 <Fromagxo> I use tabs
10:39:13 <SyntaxNinja> Fromagxo: so the indentation matters a lot in Haskell, but it's hard to tell when you paste into IRC what the indentation is
10:39:20 <Igloo> Then the monsters will eat you.
10:39:23 <Fromagxo> But they don't appear as well within IRC
10:39:38 * shapr is missing a foot from a bad tab experience.
10:39:51 <Lemmih> Fromagxo: Not use tabs in Haskell source files.
10:40:00 <Fromagxo> Never?
10:40:01 <Fromagxo> waaaaa
10:40:15 <shapr> You want to keep your feet?
10:40:29 <Fromagxo> I could use synthetic boots
10:40:40 <Fromagxo> Sure, I want to 
10:40:53 <SyntaxNinja> Fromagxo: a good text editor will make the difference between tabs and spaces not matter
10:41:09 <SyntaxNinja> (setq-default indent-tabs-mode nil) ;if you use emacs
10:41:19 <Oejet> SyntaxNinja: Thanks!
10:41:54 <SyntaxNinja> and M-x untabify ; if you have already started using tabs and want to convert them to spaces in emacs
10:41:54 <glimming> eclipse is very good
10:42:04 <SyntaxNinja> except that it won't install for me :)
10:42:21 <SyntaxNinja> eclipse is the only debian package I know of that just doesn't work at all. ;)
10:51:47 <Fromagxo> ERROR C:\Archivos de programa\Hugs98\Prac11h.hs:20 - Haskell 98 does not support extensible records   
10:51:59 <Fromagxo> fEsAnterior((f1dia,f1mes,f1año),(f2dia,f2mes,f2año)) = 
10:52:05 <Fromagxo> What the hell means this¿
10:52:57 <Igloo> I wouldn't advise using non-ASCII characters in your programs
10:53:11 <Igloo> Especially if they aren't UTF8
10:53:17 <Fromagxo> They work
10:53:26 <Fromagxo> Well, they work with other programming languages
11:01:34 <SyntaxNinja> I wonder if we can get anti-tabs support in haskell-mode
11:10:14 <SyntaxNinja> Fromagxo: while you're learning, it would probably be best to heed the advice of folks on here for little things like tabs and non-ASCII chars.
11:10:37 <SyntaxNinja> Fromagxo: when you can eliminate other minor problems, then you should experiment with preference issues like tabs and charsets.
11:13:26 <SyntaxNinja> hi Philippa
11:13:33 <Philippa> 'lo
11:26:44 * shapr throws batamorphisms at Philippa 
11:27:52 <shapr> 'Computer Sweden' is the weekly magazine of the national computer club. Today's headline says "there's no protection against spyware". This magazine is either run by total lusers, or it's a mouthpiece for Microsoft.
11:28:06 * CosmicRay returns from lunch
11:28:14 <SyntaxNinja> hi CosmicRay. the answer is 'yes'.
11:28:23 <CosmicRay> SyntaxNinja: sweet :-)
11:28:25 <CosmicRay> SyntaxNinja: doable?
11:28:28 <shapr> hi CosmicRay. the answer is '42'.
11:28:39 <CosmicRay> shapr: Fortunately, I do not remember the question.
11:28:43 <shapr> hehe
11:29:11 <CosmicRay> shapr: I would hate to be responsible for the destruction of the universe.
11:29:16 * shapr grins
11:29:39 <CosmicRay> shapr: although it would be cool to be responsible for the creation of a more-inexplicable one :-)
11:30:12 * shapr boings cheerfully
11:30:15 <chip> Of course there's no protection against spyware, as such protection would require prevention of all unplanned program execution, and no platform is totally free of that
11:30:16 <shapr> The hills are alive!
11:30:26 * CosmicRay runs from the scary hills
11:30:39 <CosmicRay> re chip
11:30:42 <shapr> chip: SELinux?
11:30:50 <chip> "Twenty thousand Maria von Trappes face off against the Mongol hordes!"
11:30:57 <CosmicRay> haha
11:31:08 <shapr> whoa, that sounds cool.
11:31:17 <CosmicRay> chip: with one german, grudgingly applauding
11:31:40 <shapr> I bet twenty thousand Julie Andrews could sing the eardrums out of one Mongol horde.
11:31:40 <chip> "The family von Trappe!  <ak47-full-auto>"
11:31:43 <CosmicRay> heh
11:32:11 <CosmicRay> chip: so how goes your foray into haskell?
11:32:31 <CosmicRay> chip: you may be interested that someone here -- autrijus IIRC -- is writing a perl6 interpreter in haskell
11:32:33 <shapr> Yes, is Haskell Jule Andrews, or a Mongol?
11:32:39 <SyntaxNinja> CosmicRay: I have to think about it more.
11:32:42 <chip> Postponed.  I'm struggling with alternatives to SOAP (yuck ptui) for cross-language RPC
11:32:47 <CosmicRay> shapr: I think it is more fitting for Haskell to be Max.
11:32:57 * CosmicRay sympathizes with chip
11:32:59 <shapr> The Grinch's dog?
11:33:04 <CosmicRay> heh
11:33:10 <CosmicRay> I hate soap
11:33:16 * shapr sniffs CosmicRay 
11:33:19 <chip> XML-RPC is pretty thin.  CORBA seems dead in Perl land.  DCE is moribund
11:33:31 <shapr> RMI + IIOP?
11:33:43 <chip> Is there a Perl client for IIOP?
11:33:48 <CosmicRay> chip: I do usually prefer xml-rpc, though it is thin.  the problem with soap is that it's too complex
11:34:04 <chip> CosmicRay: I'm finding that.  I think XML-RPC is the least evil choice I've found so far
11:34:15 <shapr> I vote for xml-rpc too, it's the least evil of the alternatives.
11:34:19 <CosmicRay> chip: yup, that's the conclusion I've arrived at.  
11:34:27 <CosmicRay> chip: it's well-supported more places
11:34:47 <CosmicRay> Despite there being two distinct SOAP libraries for Python, both appear to suck and be rather fragile
11:35:05 <CosmicRay> it seems SOAP works well as long as the languages being interoperated with are Java.
11:35:08 <shapr> Some part of me desperately wants to believe that XML-RPC is some kind of elaborate joke, like a cross between Discordianism and IP Over Avian Carriers -- Ex-Cyber on #plan9
11:35:14 <CosmicRay> heh
11:35:34 <chip> IP over XML_RPC
11:35:37 <wilx> What is moribund? :)
11:35:51 <chip> <ip <syn/> <src><address>1.2.3.4</address>...
11:35:51 <shapr> I actually use the Haskell xmlrpc binding to do unit testing of Zope/Plone code.
11:36:06 <chip> Moribund = sick unto death
11:36:15 <SyntaxNinja> xmlrpc is quite useful for little apps. I would be scared of it for something big, though.
11:36:19 <chip> nothing happening, no active development
11:37:30 <shapr> Si\ has been working on SOAP for Haskell. (last I heard)
11:38:05 <shapr> SOAP is very OOP though.
11:38:09 <Si\> (still am, getting a perfect XML Serializer is not easy)
11:38:34 <shapr> Is that becuase SOAP is inherently OOP?
11:39:26 <Si\> no
11:39:35 <Si\> SOAP isn't inherently OOP
11:39:49 <shapr> oh, that was the impression I had when I read the spec.
11:40:17 <Si\> it depends what you call an "Object"
11:40:31 <Si\> an Object can just as easily be a Haskell Module as a Java class
11:41:25 <shapr> that makes sense
11:41:37 <chip> SOAP::Lite in Perl makes clear that it's not intrinsically OO.  The HOWTO doesn't get to OO code until section eight or so
11:43:11 <Si\> XML isn't OO, it's more similar to inductive data-types, which Haskell is of course very well suited to
11:43:54 <shapr> Obviously I need to reread the spec.
11:44:06 <chip> that's true but irrelevant.  IIOP is OO even though TCP isn't
11:44:20 <chip> SOAP could have been OO even if XML isn't.  (but it isn't.)
11:44:39 <shapr> Where does IP over Avian carriers fit in?
11:44:42 <Si\> true
11:44:46 <Si\> ;p
11:44:50 * shapr snickers
11:46:20 <Si\> Anyway, getting perfect XML Serialization is difficult, because it's important that I provide enough expressiveness to cope with every eventuality, but at the same time make it as elegant as possible
11:49:56 * shapr boings
11:57:07 <shapr> So, anyone here uses postmaster? The Haskell mta?
12:00:26 <shapr> y0 Mistah Denney
12:00:45 <wnoise> Hello
12:03:16 <CosmicRay> shapr: have you?
12:04:36 <shapr> I've played with it, but I haven't switched ScannedInAvian yet.
12:05:02 <CosmicRay> unfortunately I have to be rather conservative with switching my mail setup
12:05:25 <shapr> I probably should be conservative.
12:05:26 <CosmicRay> plus I doubt that it has enough features to replace exim4 for me yet
12:05:30 <shapr> But that's never stopped me.
12:05:32 <CosmicRay> heh
12:05:39 <CosmicRay> it usually doesn't me either
12:06:02 <CosmicRay> but I host some fairly large mailing lists, plus e-mail for myself and some various nonprofits
12:06:09 <shapr> Actually, I do come from a conservative family. They're still not sure what happened ;-)
12:06:10 <CosmicRay> when things fail, they do so spectacularly
12:06:19 <CosmicRay> heh
12:06:49 <shapr> My family and in-laws up to twice removed flipped out when I changed my name.
12:07:15 <CosmicRay> heh, I didn't know you'd changed it
12:07:19 <CosmicRay> what were you originally?
12:07:25 <shapr> Robert Benjamin Gilliam
12:07:32 <shapr> aka "Ben"
12:07:42 <CosmicRay> that does sound very... southern
12:07:52 <shapr> then about five years ago...
12:09:24 <shapr> Hm, I have the demo Darcs repos on ScannedInAvian. A bunch of other darcs repos for various people.
12:10:16 <CosmicRay> shapr: I heard about this in the darcs news: http://www.edgewall.com/trac/
12:10:21 <CosmicRay> shapr: apparently there are darcs patches for it now
12:10:29 <CosmicRay> it looks like a much friendlier alternative to *forge
12:10:45 <CosmicRay> you may be interested
12:11:15 <shapr> There was minimal darcs support in gforge at one point.
12:11:25 <wilx> Hmm, what makes a man change his name?
12:11:33 <wilx> That doesn't sound too bad a name.
12:11:35 <CosmicRay> and how did you come up with Shae?
12:11:46 <shapr> It's short for shapr of course ;-)
12:11:54 <CosmicRay> ooo, life imitating irc.
12:11:55 * shapr laughs
12:12:45 <shapr> You know my propensity for sneaky jokes.
12:13:01 <shapr> wilx: I wanted a name that described me.
12:13:10 <wilx> Ah.
12:13:13 <wilx> Hm.
12:13:15 <wilx> Well.
12:13:16 <wilx> Hmm.
12:13:41 <Philippa> so one of your parents is called Eri?
12:14:03 <shapr> you left off a letter.
12:14:10 <Philippa> ah, of course
12:14:19 * shapr grins
12:14:20 <Philippa> and Shae?
12:14:38 <shapr> Shae is short for shapr, and shapr is short for synesthesist.
12:15:12 <Philippa> guess that makes sense
12:15:15 <Philippa> anyway, I should be next door
12:15:18 <Philippa> (might IRC from there)
12:15:24 * shapr grins
12:15:39 <chip> Synesthesia sounds delicious
12:15:45 <shapr> It's like flying to another part of the world to get on IRC. It makes a strange kind of sense.
12:16:19 <shapr> chip: it's delicious as long as you don't mention it in social situations.
12:17:54 <shapr> Like, normal people get freaked out.
12:18:09 <CosmicRay> heh
12:19:02 <Philippa_> told you
12:19:25 <shapr> didn't you go next door to be social with the people there?
12:19:56 <CosmicRay> heh
12:20:13 <CosmicRay> shapr: we had a #palmchat get-together in st. louis one year
12:20:27 <CosmicRay> shapr: the exciting thing was that half of the people there could irc wirelessly
12:20:46 <CosmicRay> (this was when that technology was just barely available)
12:20:48 <Philippa_> Damien's here and could use some just-about-here company
12:20:57 <Philippa_> he's playing FF on his GBA again though
12:32:02 <shapr> trac + darcs sounds nice.
12:38:17 <gzl> is anyone familiar with Hudak's animation library?
12:38:35 <gzl> actually, never mind.
12:38:39 <shapr> You mean SOEGraphics?
12:38:50 <shapr> or Yampa? or what?
12:39:24 <forcefield> What´s haskell
12:39:24 <forcefield> ?
12:39:47 <Philippa_> it's a programming language
12:40:32 <shapr> It's a way to expand your perceptions.
12:40:44 <forcefield> Philippa oh thnks !
12:40:45 <Philippa_> ah, the old Haskell/LSD comparison
12:41:00 <shapr> You'll realize this the first time you try to explain to someone that salad :: [Lettuce]
12:41:05 <forcefield> for what? what kinds os OS?
12:41:23 <shapr> It works on Windows, Linux, Macintosh, and others.
12:41:30 <Lemmih> forcefield: Any kind. There's even an OS written in Haskell.
12:41:57 <forcefield> 01,00:10D
12:42:06 <Philippa_> and it's "for" most non-realtime tasks
12:42:13 <shapr> Hm, good answer. "What OSes does Haskell run on? Haskell, Linux, Windows, Mac, and more."
12:42:24 <Lemmih> Is that smiley blinking?
12:42:25 <Philippa_> (if speed or memory usage are really, really important, it may not be a good choice)
12:42:50 <Philippa_> no, it's just coloured. Does freenode have a colour filter mode for channels?
12:43:17 * shapr checks
12:43:22 <Lemmih> It's blinking in irssi. /-:
12:43:32 <CosmicRay> forcefield: are you experienced with programming at all?
12:44:25 <forcefield> CosmicRay very limited...
12:44:28 <forcefield> 01,00;10/
12:44:55 <CosmicRay> forcefield: if you're interested, you might want to get the book "Haskell: The Craft of Functional Programming"
12:45:43 <forcefield> CosmicRay where ? 01,00:10)
12:46:04 <CosmicRay> forcefield: amazon.com and the like
12:46:13 * tic has got that book
12:47:14 <shapr> Philippa_: yes, such a mode exists. Shall I mlock it?
12:47:39 <forcefield> CosmicRay how many? do you know ?
12:47:55 <CosmicRay> forcefield: how expensive, you mean?
12:48:12 <forcefield> CosmicRay i dont know.. 01,00:10P
12:48:22 <forcefield> i have no ideia
12:48:37 <Igloo> shapr: I would
12:48:40 <Philippa_> shapr: gets my vote
12:48:50 <CosmicRay> forcefield: check out http://www.amazon.com/exec/obidos/tg/detail/-/0201342758/qid=1107895782/sr=8-1/ref=sr_8_xs_ap_i1_xgl14/002-2818054-1922422?v=glance&s=books&n=507846
12:48:50 <shapr> awright good enough
12:49:00 <Philippa_> colour codes are one of those things that should never have appeared on IRC
12:51:18 <shapr> I could say that about some IRC users I've met too.
12:51:23 <CosmicRay> hah
12:52:49 <CosmicRay> shapr: http://www.amazon.com/exec/obidos/tg/detail/-/0471197130/qid=/sr=/ref=cm_lm_asin/002-2818054-1922422?v=glance
12:53:22 <shapr> I've wanted to read that.
12:53:38 <shapr> I heard that it shares some content with AntiPatterns collected on WarsWiki
12:54:05 <shapr> Analysis Patterns is a brilliant book. It's only criticism is that it may be too dense for many people.
12:54:18 <shapr> I love books where readers complain of too much content.
12:54:22 <CosmicRay> heh
12:54:49 <shapr> It's true, reading and integrating Analysis Patterns is like mining or something.
13:02:45 --- mode: ChanServ set +c
13:03:24 <shapr> ohh, neat channel modes
13:03:41 * shapr hopes he doesn't accidentally flush the channel
13:09:23 <CosmicRay> flush, no.
13:09:32 <CosmicRay> clog, yes.
13:09:34 <CosmicRay> :-)
13:11:00 <CosmicRay> dammit, I hate it that every routing problem our isp has is fixed 3 seconds faster than I can fire up traceroute.
13:11:30 <shapr> let's see, +z +R +P +n +J 2,1
13:13:44 <SyntaxNinja> who knows what would happen if you could learn to fire up traceroute in < 3 seconds
13:21:00 <CosmicRay> SyntaxNinja: heh
13:21:33 <shapr> oh hey, emoticon poll... what do you guys think of this new fangled <3 emoticon?
13:21:48 <xerox> <3 > *
13:26:04 <wilx> Eh, serious question?
13:26:08 <wilx> Heart.
13:26:52 <psi> or scrotum
13:27:17 <wilx> lol
13:27:20 <wilx> No way.
13:27:36 <shapr> Yeah, I've always thought it looks like a scrotum. So I always read stuff like, "I scrotum my mobile phone."
13:27:46 <psi> haha
13:27:46 <wilx> :D
13:28:22 <Igloo> That's for the luddites. I â¥ unicode!
13:32:57 <CosmicRay> Igloo: pfft, why can't we all just go back to ebcdic?
13:33:11 <CosmicRay> if it worked in 1960, it would work today!
13:33:26 <shapr> speaking of which, where's my SILCnet client?
13:33:53 <shapr> abandon ship!
13:46:29 <funkmando> is it trivial to determine the number of arguments entered by a user?
13:53:32 <SyntaxNinja> yes
13:55:03 <SyntaxNinja> @type System.Console.getArgs
13:55:04 <lambdabot> bzzt
13:55:30 <SyntaxNinja> @type System.getArgs
13:55:32 <lambdabot> System.getArgs :: IO [String]
13:56:47 <shapr> yay, I registered the haskell channel on SILCnet.
14:00:31 <funkmando> hey do i need to include anything for that?
14:01:33 <SyntaxNinja> you could just use the full name, or you could import System
14:01:39 <SyntaxNinja> then call it 'getArgs'
14:08:25 * boegel boings
14:09:10 <Igloo> You'll need to import it if not in ghci
14:15:02 * boegel yawns
14:15:17 <Pseudonym> The project manager here just walked past my desk and was curious what a book called "Lie Groups: Beyond an Introduction" was about.
14:15:24 <Pseudonym> Thankfully, she's an ex-programmer, so I didn't have to explain what a group was.
14:16:11 <boegel> project manager = she ? that's cool !
14:16:18 <Pseudonym> Yes, AND an ex-programmer.
14:16:30 <Pseudonym> Female _and_ one of us.
14:16:31 <SyntaxNinja> ditto my project manager
14:16:44 <SyntaxNinja> and a haskell hacker to boot :)
14:17:14 <Pseudonym> Ah, sadly, not my project manager.
14:17:17 <Pseudonym> She no longer hacks.
14:17:55 <boegel> Pseudonym: why ?
14:18:03 <Pseudonym> Dunno.
14:18:43 <boegel> pff, I still have another final on Friday
14:18:50 <Pseudonym> She hasn't hacked as long as I've been here.
14:19:05 <Pseudonym> Probably managing projects pays better.
14:19:11 <boegel> maybe she realized she can't overclass you :p
14:19:19 <Pseudonym> Well, I think she already knows that.
14:19:25 <boegel> :D
14:19:28 <Pseudonym> I get the impression she hasn't programmed in a long time.
14:19:38 <Pseudonym> While she can't really _do_ what we do, she can understand it.
14:22:15 <boegel> Pseudonym: what kind of project are you working on ?
14:22:38 <Pseudonym> www.teratext.com.au
14:22:42 <Pseudonym> That.
14:23:44 <icb> alright, i finally got ghc built
14:23:55 <icb> after removing objectio
14:27:04 <shapr> I don't ever want to stop hacking.
14:28:24 <icb> why is that?
14:28:43 <shapr> hey Pseudonym, what are the different basic sets in computability theory? like, which ops are necessary for turing machine or lambda cal?
14:28:57 <Pseudonym> Err...
14:29:03 <Pseudonym> I don't understand the question.
14:29:04 <shapr> Pseudonym: would you happen to know of a site that has this sort of info?
14:29:35 <Pseudonym> What sense do you give to the term "op", which makes sense both to a Turing machine and the lambda calculus?
14:29:59 <shapr> I was reading on http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that AND, OR, NOT, and a counter can be done in the game of life, so it's turing complete.
14:30:22 <Pseudonym> Ah, I see.
14:30:29 <Pseudonym> Well, there are single-instruction machines.
14:30:51 <shapr> My goal is to attempt to find a radically cheaper way to do computing, I think photorefractive crystals are one approach, so, which operations would I need to figure out to show that it can be a general purpose computer?
14:30:52 <Pseudonym> i.e. assembly languages with only one instruction
14:31:11 <Pseudonym> I guess if you can implement that instruction, you're set.
14:31:20 <Lemmih> Yes! Finished at last!
14:31:26 <shapr> Lemmih: yay!
14:31:27 * Lemmih mails the patch.
14:32:15 <boegel> shapr: how's the latex stuff going ?
14:32:32 <shapr> I'd like to find (or build) a collection of such basic sets, and show how many things allow computability.
14:33:16 <shapr> icb: why about objectio?
14:33:28 <shapr> boegel: haven't looked at it yet =) I did talk to kosmikus though.
14:34:23 <shapr> icb: objectio is win32-only, maybe that helps?
14:35:42 <boegel> shapr: yeah, but you didn't mention my proposal :(
14:38:58 <shapr> your proposal?
14:39:31 <Pseudonym> The assembly instruction, by the way, is "decrement and branch if less than zero".
14:39:42 <boegel> the dummy .tex file, with some example latex code in it
14:40:10 <Pseudonym> I guess with the Conway's Life, if you can implement NAND, you can implement all (synchronous) logic circuits.
14:40:22 <Pseudonym> Because most VLSI chips these days are just NAND gates.
14:40:29 <Pseudonym> Or NOR, I suppose.
14:40:41 <Pseudonym> You fit as many gates as you can, then wire them up.
14:40:47 <jlouis> an lhs file is ASCII text with haskell code. Can you do LaTeX?
14:41:05 <shapr> yes
14:41:11 <jlouis> how? ;)
14:41:20 <shapr> with an lhs file that's LaTeX and Haskell code.
14:41:26 <jlouis> is there a document describing it?
14:41:33 <boegel> I believe \begin{code} \end{code}
14:41:45 <boegel> among other things
14:42:27 <jlouis> hmm, you will also need some kind of .sty file for latex then
14:42:50 <jlouis> I've seen it, but I've never seen how to actually do it. Maybe there is something in the GHC manual?
14:45:37 <icb> shapr, that explains it :)
14:45:40 <shapr> I have some examples around here somewhere....
14:45:42 <icb> it crapped out halfway on a mac
14:46:17 <jlouis> http://haskell.org/hawiki/LiterateProgramming?action=highlight&value=literatehttp://haskell.org/hawiki/LiterateProgramming?action=highlight&value=literatehttp://haskell.org/hawiki/LiterateProgramming?action=highlight&value=literatehttp://haskell.org/hawiki/LiterateProgramming?action=highlight&value=literate
14:46:32 <icb> is the HaskellSupport.framework build script in the cvs yet?
14:46:32 <Pseudonym> Ow!  My eyes!
14:46:35 <shapr> interesting url
14:46:38 <boegel> jlouis? wtf :)
14:46:46 <boegel> it's like 4 times the same url :)
14:47:00 <shapr> for emphasis? ;-)
14:47:22 <funkmando> hi shapr
14:47:24 <funkmando> what's up
14:47:59 <shapr> ceilings!
14:48:38 <funkmando> correct
14:51:58 <funkmando> one thing i've noticed about haskell
14:52:04 <funkmando> is you spend far far more time sitting there thinking
14:52:06 <funkmando> than u do coding
14:52:11 <funkmando> than in langs like java
14:52:56 <shapr> it gets better...
14:53:14 <SyntaxNinja> I think I spend more time thinking than coding, and I think that's a good thing
14:53:19 <shapr> Soon you get to the point where you don't spend much time thinking about it, because you know how it fits together.
14:53:36 <sh10151> Code is a liability
14:53:38 <shapr> Then you go back to java and you weep, because you're back to the Stone Age :-(
14:53:49 <sh10151> shapr: jython makes it easier
14:53:59 <shapr> not easy enough
14:54:09 <shapr> But I did write some neat commercial apps in Jython.
14:54:20 <sh10151> cool
14:54:35 <shapr> sh10151: http://www.scannedinavian.org/~shae/nokia-emu-jython.png
14:54:49 <sh10151> it's pretty nice for people that work in a shop that practices buzzword-driven design
14:57:42 <ikegami--> wow
14:57:54 <ikegami--> Haskell works on your handy phone?
14:58:11 * Lemmih realizes he's an inapt writer and ends up quoting GreenCard.
14:58:39 <Lemmih> ikegami--: I think that was a jython example.
14:58:57 <shapr> Jython can run on many of the Nokia phones. So can Python nowadays.
14:59:29 <ikegami--> ah, I have misunderstanding
15:03:16 * boegel goes to bed to watch a The 4400 eps
15:03:21 <boegel> bye everyone Ã§
15:03:34 <psi> shapr: do you know finnish?
15:03:34 <boegel> s/Ã§/!
15:03:42 <shapr> psi: no, who's he? =)
15:03:58 <shapr> but really, just a little bit.
15:04:26 <funkmando> it's quite an odd language isn't it?
15:04:44 <funkmando> ie. not much connection to nordic or med langs in europe
15:04:48 <psi> ok :) i noticed you had windows in finnish language. (or was it not your screenshot?)
15:04:58 <psi> no, it's not germanic
15:05:14 <tuomov> it's not indo-european even
15:05:24 <shapr> Oh, that's because I lived and worked in Finland when I had that job.
15:05:37 <tuomov> finnish, estonian and hungarian are oddballs in europe
15:05:44 <shapr> tuomov: and Basque
15:05:44 <psi> shapr: ah, ok
15:05:57 <tuomov> hmm.. that too
15:06:08 <tuomov> although it is unrelated to the three others which are related
15:06:10 <shapr> oh wait, you were probably just talking about finno-ugric languages
15:06:10 <tuomov> (finno-ugric)
15:06:15 <shapr> right, I just realized that =)
15:06:41 <shapr> The category of Finno-Ugric, not the category of Oddball Languages.
15:06:52 <psi> :)
15:07:42 <psi> isn't it a bit odd that a country so close has such a completely different language?
15:07:55 <psi> close to sweden, i mean
15:08:36 <tuomov> yes, it's odd and it is not known how the language(s) came here
15:08:57 <tuomov> there are some related minority languages too, though
15:09:18 <shapr> I wonder if language mobility is related to population migration.
15:09:18 <tuomov> (saame, ingrian, etc.)
15:09:38 <psi> true
15:10:02 <psi> although i don't know what ingrian is
15:10:28 <tuomov> it is a minority language spoken in parts of russia close to finland
15:10:36 <tuomov> and there are quite a few others too
15:10:42 <tuomov> some might consider them just dialects
15:10:51 <psi> ok
15:11:15 <shapr> What's that crazy mish-mash they speak north of here?
15:11:17 <funkmando> i expect those languages (finno ugric) came from russia originally?
15:11:21 <tuomov> http://en.wikipedia.org/wiki/Finno-Ugric
15:11:24 <tuomov> there's a cool map
15:11:36 <tuomov> mÃ¤enkieli?
15:11:41 <shapr> yes!
15:13:05 <psi> pitebondska is quite strange, also :)
15:13:34 <shapr> truly, we had a comedian show up at a recent fÃ¶retagarna meeting who did pitebondska humor.
15:13:54 <psi> hehe
15:13:59 <shapr> I thought I had trouble understanding *swedish* and then...
15:14:11 <dons> shapr: distcc distributing ghc's build across 30 cpus didn't blow up.. (-j30)
15:14:19 <dons> but it was only faster for the .c files
15:14:40 <dons> so I will try pvmgmake, which supposedly will distribute anything
15:14:41 <shapr> Surprisingly, almost everyone in the Boden FÃ¶retagarna understand pitebondska just fine. I think this shows the average educational level of the FÃ¶retagarna. (we just left said organization)
15:14:47 <shapr> dons: awesome!
15:15:17 <dons> if you ever have to build a large C project, I really recommend distcc
15:15:25 <dons> very easy to setup.
15:15:42 <shapr> what's the latency/cpu tradeoff that makes it worthwhile?
15:15:59 <shapr> like, a few 800MHz? a few 200MHz? any idea?
15:16:25 <dons> ok, I tried a cluster of 10 dual 3.2ghz boxes, + 10 single p4 2.4s
15:16:34 <dons> on gigabit ether... :}
15:16:55 <shapr> uh yeah.
15:17:00 <dons> the number of cpus didn't seem to matter much after about 20
15:17:16 <shapr> and how long does it take to build GHC at -j30?
15:17:46 <dons> running the latest head + libraries took 57 mins, which was disappointing actually
15:18:03 <dons> only marginally faster, maybe 5 mins faster.
15:18:10 <shapr> that is surprising.
15:18:10 <dons> but the rts took only 57secs
15:18:15 <shapr> nice
15:18:29 <dons> it only distributes compilation of C files
15:18:38 <shapr> pvm will do better
15:18:45 <shapr> I think
15:18:47 <dons> yeah, hope so. will try tonight
15:18:56 <dons> that way I'll actually get ghc running on each node
15:19:02 <shapr> This is cool research, I hope you're posting summaries to ghc-users.
15:19:03 <dons> and not just the gcc phase of ghc
15:19:13 <dons> I will.
15:19:40 <shapr> If you're using a mounted distributed filesystem with PVM, you can do multi-stage builds just fine.
15:19:45 <dons> distcc would be cool for building a kernel, or a bsd ports tree
15:19:55 <dons> ok. cool.
15:20:45 <dons> or for shifting compilation off a laptop over wireless to a server
15:20:46 <shapr> Is that the sort of setup you have?
15:21:17 <dons> I've got a shared NFS file system . so all boxes see the same stuff
15:21:25 <dons> and the same tools too, which is important
15:21:39 <shapr> Speaking of shifting computation, has Chilli seen the recent Cell report? He should really get back on Nepal and Parr.
15:22:01 <dons> we're looking at running code on gpu's atm ...
15:22:17 <dons> lots of paralellism to exploit
15:22:22 <shapr> That's a good approach. Cell is sort of GPU too.
15:22:45 <shapr> Have you guys considered integrating region-allocation in there as well?
15:23:11 <dons> we've looked at regions fairly deeply, but not in the context of parallelism
15:23:11 <shapr> That would probably be helpful for setups with cpu-local memory, and higher latency between the cpus.
15:24:15 <shapr> The cell is pretty much an ibm Power5 with six (eight?) simplified powerpc 601 chips connected to it.
15:24:37 <dons> oh, hehe, I couldn't actually extract that detail from the reports I'd read :)
15:25:05 <shapr> each 601 has 256k of simplified memory, simplified in that it doesn't have TLBs, protected bits, or any of that stuff.
15:25:50 <shapr> it's interesting, because that ram ends up being both cache and a tiny main memory for each subcpu.
15:26:31 <shapr> I very much wish I could get into a project to port hOp or House to that CPU.
15:26:55 <dons> hehe. maybe we need more industry advocates for haskell
15:27:11 <funkmando> shapr what do you do? (job, academic?)
15:27:31 <shapr> funkmando: I build websites. Isn't category theory good for that?
15:27:37 <dons> certainly
15:27:48 <shapr> dons: http://arstechnica.com/articles/paedia/cpu/cell-1.ars
15:27:59 <shapr> samc point me to that article, it's quite informative.
15:28:22 <shapr> funkmando: Seriously, I'm a self-employed web developer. I mostly build Zope and Plone sites for EU projects lately.
15:29:07 <funkmando> i see
15:29:14 <funkmando> what are Zone and Plone?? lol
15:29:29 <shapr> They're web application servers.
15:29:30 <funkmando> self-employed : good on ya
15:29:42 <funkmando> ah
15:29:51 <funkmando> i did a little php a long time ago
15:29:53 <funkmando> fun
15:30:19 <shapr> sometimes I get frustrated, I wish I could use all the stuff I know on the jobs I do.
15:30:32 <funkmando> what do you use? (langwise)
15:30:45 <shapr> Zope/Plone are written in Python.
15:30:56 <funkmando> oic
15:31:07 <funkmando> i've done a VERY small amount of python
15:31:11 <shapr> I've been slowly integrating Haskell into my paying work, in places where it's a pure service.
15:31:32 <funkmando> the python i did was really just like C
15:31:36 <funkmando> except you have to indent
15:31:43 <shapr> That is, in places where speed of results is all that matters, not the resulting code, then I get to use whatever I want.
15:31:53 <funkmando> ah
15:31:55 <funkmando> then what do you use?
15:32:02 <shapr> Haskell of course.
15:32:05 <funkmando> :)
15:32:16 <shapr> It's really powerful.
15:32:36 <funkmando> yeah after getting frustrated with it, sometimes it shocks me, lol
15:32:44 <funkmando> when i do eventually get the prog to work
15:32:57 <funkmando> it's usually 1/2 the size or less than the equilvalent java program
15:33:07 <funkmando> (that could be my inefficient java coding. dunno) lol
15:33:37 <shapr> German university built an e-learning platform with an unholy mix of XML, PHP, Java, and JavaScript. Then tried to get someone to automatically turn a bunch of ms.doc files into their custom XML format with Java and XSLT. After a month, they gave up. I did it in three days with Haskell.
15:34:28 <shapr> My code was about 200 lines, the unfinished clump of Java, XSLT, and JavaScript went on forever
15:34:34 <funkmando> haha
15:34:43 <funkmando> owned
15:34:48 <funkmando> i bet they felt quite dumb
15:35:00 <dons> that's a perfect haskell app though
15:35:30 <dons> wasn't that similar to what galois began as - a translator company?
15:35:46 <dons> turning hmm something to Cobol I think..
15:35:56 <shapr> Yeah, I agree. I just batched all the ms.doc files into OOo format, and wrote a translator from OOo into 96% of this custom DTD.
15:36:26 <shapr> For the other 3% I used a regex, and the last 1% was checking for stupid mistakes.
15:36:26 <funkmando> what can't you do with haskell?
15:36:47 <Lemmih> Crash.
15:37:08 <dons> i find writing test suite drivers a bit tedious in haskell sometimes. too much unix shell interaction
15:37:19 <shapr> test suite drivers?
15:37:59 <dons> given a bunch of test dirs for, say, a compiler, run your app over all the tests, in different ways, checking the output
15:38:01 <Lemmih> There're no segfaults with in Haskell unless you explicitly enabled them (by turning on non 98 features).
15:38:36 <dons> even simonM gave up on writing a haskell driver for ghc's testsuite, and instead used python
15:38:54 <dons> but his approach was to define an EDSL, which sounds like the way to go
15:38:59 <shapr> I think it would be easier with QuickCheck and QuickCheckM
15:39:04 <dons> once someone does this, then it'll be easier to reuse
15:39:49 <dons> yep QuickCheck is very good for testing. But sometimes you have a huge collection of existing tests. Maybe this is only a compiler problem though
15:40:17 <dons> would it be hard to get QuickCheck to generate arbitrary haskell code i wonder..
15:40:18 <Igloo> I don't thik it is
15:40:26 <Igloo> hunit is also lovely, of course
15:40:54 <shapr> I think QuickCheck should handle existing tests.
15:41:00 <shapr> I've already written some code to do that.
15:41:17 <dons> so the approach is do the whole testing everything in Haskell
15:42:08 <dons> ok. I will investigate, as I need to rewrite the testsuite driver for my POPL subject's compiler
15:42:09 <shapr> I have an idea for extending .lhs files with embedded testing info.
15:42:30 <dons> grr. ghci broken in head and stable last night
15:42:48 <shapr> It's just a straight port of the FIT Java testing framework, with some improvements because Haskell already has .lhs
15:43:21 <dons> ah: /base/HSbase.o: unknown symbol `stg_intToInt64'
15:43:37 <shapr> But I do wish LaTeX .lhs files could export both ps and haddock-style html docs from the same file.
15:44:09 <dons> yeah. I seem to remember someone actually did write a .lhs -> .ps tool though
15:44:18 <shapr> lhs2TeX?
15:44:27 <dons> probably
15:44:36 <shapr> I'm learning that right now for TMR.
15:45:22 <dons> why can't you put the haddock comments in \code chunks of .lhs, and run:
15:45:34 <Igloo> Hmm, prettyprinting can sometimes be confusing for beginners
15:45:36 <dons>   f | lhs2Tex ; f | unlit | haddock
15:45:53 <shapr> Why can't I use a doc format that looks nice in both?
15:46:09 <SyntaxNinja> I think that Simon doesn't Believe In lhs
15:46:41 <dons> Igloo: that's a good point. But it's a lot like parsing, which is also confusing for beginners
15:46:57 <Igloo> Eh? What's a lot like parsing?
15:47:00 <shapr> After seeing the random embedded docs crap that the Python and Java communities have produced, I *love* lhs.
15:47:09 <Lunar^> shapr: IMHO, lhs and haddock are not useful for the same thing
15:47:12 <Igloo> I'm saying ppring for TMR, especially newbie columns, might be a bad idea
15:47:18 <shapr> Lunar^: why?
15:47:28 <dons> oh, ic.
15:47:30 <Lunar^> shapr: lhs is nice when doing code review, comments
15:47:40 <Lunar^> shapr: haddock is meant to document an API
15:47:58 <Lunar^> shapr: one is for the implementation, the other is for API
15:48:12 <shapr> I'm not convinced those are so different.
15:48:25 <Lunar^> I don't want to know how is forkIO written to use it
15:49:13 <Lemmih> @wiki HaCanon RFC and it's 1am so there's probably lots of typos and spelling errors.
15:49:33 <Lemmih> lambdabot?
15:49:37 <shapr> Lunar^: that's a good point
15:49:43 <Lemmih> @wiki HaCanon
15:49:50 <lambdabot> http://www.haskell.org/hawiki/HaCanon RFC and it's 1am so there's probably
15:49:50 <lambdabot> lots of typos and spelling errors.
15:49:50 <lambdabot> http://www.haskell.org/hawiki/HaCanon
15:50:02 <shapr> Lunar^: but, I want a single internal document format that exports to both html and ps
15:50:15 <Lunar^> shapr: documenting implementation or interface ?
15:50:19 <shapr> I'm fine with export two different views of the same docs, one for api and one for implementation, but I just want both outputs.
15:50:50 * Lunar^ still think that PS or PDF isn't really useable for API doc
15:50:55 <shapr> Right now we only get API in html, and we only get implementation in PS
15:51:00 <Lunar^> It miss hyperlinks
15:51:08 <shapr> PDF does hyperlinks?
15:51:15 <Lunar^> Yes
15:51:20 <shapr> PS looks better.
15:51:27 <Lunar^> But it's not like a eral browser
15:51:29 <Lunar^> real
15:51:30 <shapr> true
15:52:23 <shapr> Part of the basic problem here is the lack of ubiquitous smart documents.
15:52:38 <mattam> smart ?
15:52:44 <Lemmih> Good night, #haskell.
15:52:49 <shapr> g'night Lemmih
15:54:04 <shapr> mattam: ask me another time, it'll just distract me right now, but look at wheatfarm.org and Darius Bacon's programmable wikis.
15:54:59 <shapr> dons: have you seen the Python and Java FIT aka fully interactive testing? It's another invention by the guy who invented wikiwiki.
15:55:35 <dons> no, haven't seen it.
15:56:03 <shapr> Here's a Python example - http://fit.zwiki.org/FitExamples, in essence it's a mix of wiki and unit testing.
15:57:06 <shapr> I think software tests should be embedded in the source, along with the docs, and I think test results should show up in the docs, just like FIT.
15:57:40 <shapr> Even better, doc-visible software tests could have more depth, where you can click to see what past versions of the same software passed this test.
15:58:25 <Lunar^> unit testing, doc, code, version integration
15:58:26 <shapr> It would be able to answer questions like, when did fromIntegral start working? when did Simon move around the Posix module?
15:58:32 <Lunar^> die Unix, DIE !
15:58:41 <shapr> ?
15:59:16 <Lunar^> Unix damned philosophy of having a load of separate programs
15:59:16 <shapr> Lunar^: do you think those shouldn't be integrated?
15:59:26 <Lunar^> They should :) And that's killing Unix
15:59:50 <Lunar^> .o are Unix, also
15:59:52 <shapr> maybe we just need to find a better way to do separation?
16:00:06 <shapr> I think that monads and unix shell pipes are very similar.
16:00:07 * Lunar^ would use "cooperation" here
16:00:19 * Itkovian think the unix way is kinda cool.
16:00:21 <Lunar^> well defined interfaces, types...
16:00:31 <mattam> shapr: thanks for the wheat link
16:00:34 <Itkovian> but as always ... there's room for improvement
16:01:55 <mattam> what's wrong with .o's ?
16:03:16 <Lunar^> mattam: e.g. cross-linking, versioned interfaces. GHC has split-objs to overcome .o limitation
16:03:33 <shapr> dons: one dream I have for FIT, is to have some way that random users can submit a real unit test (maybe run it on UMLinux?) so that developers can quickly see what's broken and whether it's fixed.
16:05:22 <mattam> i see, nothing wrong in the C world :)
16:07:39 <dons> shapr: that's a nice idea
16:07:48 <dons> you'd get a lot more tests together that way
16:09:10 <shapr> hello TMR readers and authors, I'd like to hear any feedback on the Guidelines for Authors for The Monad.Reader, darcs get http://www.cs.uu.nl/~andres/TMR
16:09:26 <shapr> mostly contains LaTeX formatting info at the moment
16:09:44 <shapr> actually, that's all it contains I think.
16:10:03 <shapr> But it will also contain licensing info etc, when I get around to tracking down some.
16:11:01 <shapr> dons: I just can't figure out how to keep it from being both automatic and not horribly exploited.
16:11:29 <shapr> er, "both automatic and not exploited"
16:11:40 <shapr> Gahhh, too much stuff going on in my head at once.
16:12:25 * juhp feels the nostalgia of seeing latex output :)
16:12:30 <juhp> ls
16:12:33 <dons> yeah. hmm. they could submit it as Haskell src, you control the imports, and then do type inference to make sure the type is safe..
16:12:35 <juhp> arg
16:13:07 <dons> ls: arg: No such file or directory
16:13:12 * shapr laughs
16:13:21 <juhp> heh
16:13:24 <shapr> hej ski!
16:13:33 <ski> hej shapr
16:13:57 <shapr> dons: you'd also be able to quickly boil submitted code down to a simple test, even if the original author couldn't
16:13:58 * ski just proved skolemization in alfa
16:14:05 <shapr> cool!
16:14:52 <sh10151> skolemization
16:15:00 <sh10151> I remember something about that in mathematical logic
16:15:07 <ski> yes
16:15:15 <sh10151> it's all sort of fuzzy
16:15:17 <sh10151> and incomplete
16:15:18 <shapr> Didn't they have flesh skolems in D&D?
16:15:42 <Lunar^> shapr: you should hide now :)
16:15:42 <shapr> ski: what is a laja-something?
16:15:54 <shapr> Lunar^: or I should stop making that joke ;-)
16:16:00 <ski> it is to change  forall a : A. exists b : B. R (a,b)  into  exists f : A -> B. forall a : A. R (a,f a)
16:16:32 <ski> shapr : iirc, it was a kind of 'vehicle' in magnamund
16:18:12 <ski> shapr : (i.e. magnamund as in the world in the 'lone wolf' single player roleplaying adventure books by Gary Chalk and Joe Dever)
16:18:21 <shapr> aha
16:18:31 <shapr> I've been googling around trying to figure that out.
16:19:26 <ski> http://www.projectaon.org
16:19:33 <ski> (e.g.)
16:19:55 <shapr> looks neat.
16:20:11 <ski> shapr : they have the books online there .. :)
16:20:56 <ski> shapr : hm, did you mean you've been googling around about lajakeka ? :)
16:21:17 <shapr> that too
16:21:22 <shapr> it turned up nothing.
16:21:48 <shapr> Actually, it turned up nothing that told me what a lajakeka actually was.
16:23:47 <ski> i think i've seen a pic somewhere
16:23:52 <ski> (maybe in a paper book)
16:24:33 <ski> of a gigantic (several stories high) vehicle
16:25:12 <ski> with a large "roller" (like the kind used to flatten asphalt roads) but bigger
16:25:29 <ski> crushing enemies under it ..
16:25:31 <ski> ;)
16:29:31 <shapr> wow, sounds cool
16:29:37 <shapr> hiya pesco, new hostname?
16:30:12 <ski> shapr : 'twas kind of an awe-bringing pic ..
16:33:00 * ski was surprised that one could prove skolemization constructively
16:36:05 <mattam> in full intuitionistic logic ?
16:37:10 <ski> dependent intuitionistic logic
16:37:20 <ski> (if i haven't made some error, i.e. :)
16:39:24 <ski> mattam : wanna more expl. ?
16:39:33 <mattam> i imagine implication was not nice
16:39:45 <ski> umm
16:39:50 <ski> you mean what ?
16:40:08 <mattam> V A, E b, A -> B -> E f, V A, A -> f(A)
16:40:32 <mattam> it lacks parenthesis
16:40:37 <ski> mm
16:40:45 <mattam> (V A, E b, A -> B) => (E f, V A, A -> f(A))
16:41:08 <mattam> maybe you did not do an induction on the first proof ?
16:42:00 <ski> (forall a : A. exists b : B. R (a,b)) <-> (exists f : A -> B. forall a : A. R (a,f a))
16:42:23 <ski> why you have "A -> B" in first part ?
16:42:49 <mattam> i'm saying, when R == A -> B
16:42:54 <ski> aha
16:44:33 <ski> hm, i guess that would be a specific instance of my version
16:44:52 <mattam> did you not prove it by induction on R ?
16:45:12 <ski> no inductoin
16:45:16 <mattam> ah
16:45:26 <mattam> i'm curious now
16:46:12 <mattam> what's the proof idea ?
16:46:37 <ski> a value of type (forall a : A. exists b : B. R (a,b)) is a function taking values a of type A and returning pairs of values b of type B and proofs of property R (a,b)
16:47:02 <ski> (constructively looking)
16:47:09 <mattam> yep
16:47:42 <ski> so, if we ignore the proof of the property returned, we get a function from A to B
16:48:15 <ski> this is the first part of the pair of type (exists f : A -> B. forall a : A. R (a,f a))
16:48:18 <mattam> oh right, that's so simple, simply apply it and get the witness
16:48:24 <ski> yep
16:48:39 <ski> it's very simple once one looks at it in the right way
16:48:56 <shapr> dons: I'd love to talk more about Nepal/Parr on Cell sometime. I'd especially like to hear where that project is headed these days.
16:49:14 <ski> the second part of the returned pair takes an a and returns just the property proof, instead
16:49:25 <dons> shapr: ok, I'll have to find out myself. I think there is movement afoot, though
16:49:31 <shapr> excellent!
16:49:53 * mattam has been studying constructive type theory for the entire day...
16:49:56 <shapr> I've been agitating behind the scenes trying to get the Haskell community to jump into declarative parallelism. Multi-core and more is coming soon.
16:50:19 <ski> mattam : and we can easily pass from the (exists f : A -> B. ...) to the left hand side, also
16:50:26 <mattam> yes
16:50:40 <mattam> that i saw, i'm not _that_ tired :)
16:50:41 <ski> mattam : also, these two functions are inverses
16:50:55 <ski> mattam : :)
16:51:42 <ski> shapr : what kind of declarative parallelism (concurrency ?) ?
16:51:51 <mattam> i hope i'll have that question at my exam ;)
16:51:57 <ski> heh
16:52:34 <ski> (mattam : i've also invented a new kind of dependent type, though i'm not sure yet how useful it is ..)
16:52:52 <mattam> let's see!
16:53:04 <ski> well
16:53:05 <shapr> ski: nested data parallelism is my favorite.
16:53:32 <ski> shapr : have only read a little about that projec
16:53:34 <ski> t
16:53:58 <ski> mattam : "((a : A) <-> (b : B)) * R (a,b)"
16:54:55 <mattam> * ?
16:55:08 <ski> i was pondering biimplication
16:55:15 <ski> * is a product sign
16:55:48 <ski> like (a : A) * P a which is another notatoin for exists a : A. P a
16:56:19 <mattam> well, that's just an abreviation no ?
16:56:34 <ski> (and  (a : A) -> P a  is another notation for  forall a : A. P a)
16:57:12 <ski> well, it emphasises more that it is a generalizatio nof product (resp. function)
16:57:13 <mattam> usually "->" is used for non-dependent product
16:57:15 <ski> hi esap
16:57:26 <esap> Hi
16:57:26 <ski> yea
16:57:40 <ski> but it can be used for dep. functions too
16:57:41 <ski> hmm
16:57:49 <shapr> hei esap, check out http://wouter.fov120.com/bla/index.html - what do you think?
16:58:02 <mattam> that's just syntax anyway
16:58:43 <ski> possibly minor mm
16:59:16 <ski> anyway, i might be using slightly different terminology (i realized)
16:59:34 <ski> forall a : A. P a  i call dependent function
16:59:47 <mattam> product
16:59:49 <ski> exists a : A. P a  i call dependent product
16:59:57 <mattam> oh
17:00:18 <ski> this could be that i just have confused two term. with eachother
17:00:34 <ski> or that i have seen this term. in someones paper
17:00:36 <ski> not sure
17:00:39 <mattam> or that alfa is different from coq
17:01:12 <ski> anyways
17:01:21 <esap> shapr: it's an interesting concept. Might overlap somewhat with what I've been doing for the OO library.
17:01:42 <mattam> are there inductive types in alfa ?
17:01:47 <ski> we could define ordinary biimplication as  a <-> b  ===  (a -> b) * (b -> a)
17:02:06 <esap> shapr: But I'm not quite sure what they mean with environment, do they mean a continuation - value pair?
17:02:15 <shapr> esap: That guy has some other neat language ideas as well, including the best visual languages I've seen yet.
17:02:23 <ski> mattam : like vector indexed by Nat ??
17:02:41 <mattam> like haskell 'data'
17:02:43 <shapr> esap: I'm not exactly sure
17:02:47 <mattam> but with deptypes
17:02:58 <esap> shapr: I have to read the paper [didn't even look at it yet]
17:03:04 <ski> mattam : yes
17:03:28 <ski> esap : i would guess that it means the collection of visible bindings ..
17:03:42 <shapr> I haven't read much about it either, many of the details have just hit the web.
17:05:07 <ski> mattam : anyway, i was defining a function with type of form  (a : A) -> (b : B) * R (a,b)  (or  forall a : A. exists b : B. R (a,b)  if you like), for some specific R
17:05:38 <mattam> yep
17:06:10 <ski> mattam : and i realized it would be nice to also define the inverse function of the "value-part" (it was meant to be an iso)
17:06:49 <mattam> ok
17:07:31 <ski> so i wanted a shorthand for  ((a : A) -> (b : B) * R (a,b)) * ((b : B) -> (a : A) * R (a,b))
17:08:03 <ski> e.g. i wanted to not write the R (a,b) part twice  (it wsa bigger in the specific example)
17:08:49 <ski> so i invented the shorthand  ((a : A) <-> (b : B)) * R (a,b)for that
17:09:19 <ski> (though, i'm not sure if one can make nice intro and elim rules for it ..)
17:09:33 <mattam> what's weird is that a <-> b === (a -> b) /\ (b -> a), so * would be equivalent to conjunction
17:09:55 <ski> * is conjuction, of course
17:10:37 <ski> hmm
17:10:51 <ski> anyways, i gotta leave now
17:10:52 <mattam> aha, then i'm confused with notations
17:11:01 <ski> sorry
17:11:06 <mattam> see you later :)
17:11:11 <ski> (could maybe continue later ..)
17:11:13 <ski> bye
17:44:54 <araujo> more than 5 hours compiling ghc
17:44:58 <araujo> mm..
17:49:32 <dons> slow box?
17:50:17 <araujo> yes
17:54:17 <wagle> test
17:54:25 <wagle> test
17:54:34 <wagle> darn
18:05:09 <shapr> wagle: eh?
18:05:30 <shapr> wagle: bemoaning the fact that colors no longer work on #haskell?
18:06:27 <wagle> no i paged back 47 pages to find out who said my name yesterday, and was looking for a short cut back
18:06:35 <shapr> Igloo: Is minstrel documented anywhere? I found a guy in texas working on a neat Haskell music player.
18:06:46 <shapr> wagle: which irc client?
18:06:54 <wagle> irssi
18:07:00 <shapr> try /last wagle
18:07:06 <shapr> or possibly /lastlog wagle
18:07:49 <shapr> from the silence, I assume one of those worked.
18:08:17 <wagle> no
18:08:22 <shapr> speaking of silence, not many people on SILCnet haskell channel (no # used on SILCnet)
18:08:39 <shapr> hoi doc
18:08:41 <doc_modulo> hi
18:08:45 <doc_modulo> it's late I know
18:08:55 <shapr> It is?
18:08:59 <doc_modulo> but I just decided to go Haskell and I'm excited
18:09:01 <doc_modulo> for me it is
18:09:03 <shapr> Hm, I only woke up a few hours ago.
18:09:12 <doc_modulo> 03:15 here
18:09:16 <shapr> here too
18:09:17 <shapr> =)
18:09:22 <doc_modulo> lucky you
18:09:33 <shapr> I'm excited about Haskell too!
18:09:40 <shapr> It's way cool.
18:09:47 <doc_modulo> I'm "officially too sick for work tomorro"
18:09:53 <shapr> er, you are?
18:10:00 <shapr> Time for a learning binge?
18:10:08 <doc_modulo> I won't be able to work tomorrow because i'm "sick"
18:10:13 <shapr> ah, right.
18:10:32 <wagle> oh well
18:10:35 <doc_modulo> learning binges are great when you're in the flow, happens after a few hours of reading
18:10:51 <shapr> wagle: sorry, I used irssi once several years back, that's all I know.
18:11:08 <shapr> I think I got on a learning binge when I was born. Haven't stopped yet.
18:11:22 <doc_modulo> can I ask questions to knowledgeable ppl here
18:11:26 <shapr> On the downside, that means any job I have gets boring after some time.
18:11:28 <shapr> Yes!
18:11:33 <Pseudonym> I've been on a half-baked-ideas binge for some decades now.
18:11:37 <shapr> You are encouraged to ask questions here to help you learn.
18:11:51 <doc_modulo> good shit
18:11:54 <doc_modulo> anyway
18:11:56 <doc_modulo> my question
18:11:57 <Pseudonym> Especially Haskell questions, though this is not compulsory.
18:12:10 <doc_modulo> don't worry, I'm totally convinced about Haskell
18:12:20 <Pseudonym> Phew.
18:12:21 <doc_modulo> some history for your enjoyment
18:12:25 <Pseudonym> That saves us a lot of advocacy.
18:12:31 <doc_modulo> First I thought Java was IT
18:12:32 <shapr> Right, no advocacy required.
18:12:36 <doc_modulo> CHECK
18:12:37 <shapr> I've been there.
18:12:50 <shapr> Learned Java, thought it was the best thing ever.
18:12:55 <shapr> doc_modulo: where'd you go next?
18:13:15 <doc_modulo> then, I started self-edjucation with a couple of books
18:13:24 <shapr> Which books?
18:13:31 <doc_modulo> best book so far was:..
18:13:35 <shapr> Structure and Interpretation of Computer Programs?
18:13:36 * doc_modulo is looking
18:14:05 <dons> ok. got pvmgmake working. lets see how long yi takes..
18:14:09 <shapr> ooh
18:14:18 <doc_modulo> Best book so far: Java How to Program - Deitel & Deitel
18:14:20 <shapr> MP-YI!
18:14:41 <Pseudonym> Deitel & Deitel is a series, isn't it?
18:14:45 <doc_modulo> best introductory book, but still, problem's not the book, it's the language
18:14:50 <doc_modulo> authors
18:14:51 <dons> oops. yi blew up  :(
18:14:53 <Pseudonym> [Language] How to Program
18:15:01 <Pseudonym> Where [Language] is a number of languages.
18:15:03 <doc_modulo> it's a pretty good book
18:15:03 <dons> damn sed script
18:15:13 <Pseudonym> I mean they wrote a series of books.
18:15:16 <shapr> whoa, dons said something bad about sed, run away!
18:15:25 <Pseudonym> see sed run.  run sed run.
18:15:30 <dons> blah!
18:15:35 * shapr grins
18:15:43 <shapr> doc_modulo: and then what?
18:16:16 <dons> lookks like I didn't quite get the hand-coded dependencies right
18:16:27 <doc_modulo> but problem with Java is: All these esoteric rules you have to follow to put together code, can't have >1 public class in a file, bla bla blaX30  members have to be public/private/protected whatever if you want to do something
18:16:41 <shapr> yeah, I dig that.
18:17:15 <shapr> So what did you do next?
18:17:22 <Pseudonym> Yeah.  Java confuses classes and modules.
18:17:23 <doc_modulo> if you self-educate and you have a bad memory like me, it's hard to bring up the motivation
18:17:35 <Pseudonym> Oh, you too?
18:17:37 <Pseudonym> :-)
18:17:39 <shapr> yeah, you too?
18:17:45 <doc_modulo> also because, in the back of my mind, I thought "there must be a better way"
18:17:53 <dons> ok. lets do ghc now
18:18:20 <shapr> Of course, Pseudonym has more self-education than me. I'd never heard of those grubby number bases before yesterday ;-)
18:18:29 <doc_modulo> some concepts of FP were already in back of my mind then, like: why don't they make programming languages more like math etc.
18:19:14 <shapr> Yeah, I went into Python after Java. And I discovered a lot of FP by myself by writing weird looking Python code that worked the way I thought was better.
18:19:18 <doc_modulo> on slashdot.org there was a post about the recommended book as 2nd reading
18:19:27 * doc_modulo looking
18:19:52 <doc_modulo> The Haskell School of Expression:
18:19:52 <doc_modulo> Learning Functional Programming through Multimedia
18:20:05 <shapr> Ah, you read SyntaxNinja's review on slashdot.
18:20:21 <doc_modulo> yeah, one of the "community" guys I think
18:20:33 <shapr> Yeah, Isaac Jones, he's a very cool guy.
18:20:33 <doc_modulo> he said so in a disclaimer
18:21:03 <doc_modulo> said: I'm advocating, but also acquantance of author or something like that
18:21:06 <doc_modulo> I can check
18:21:11 <shapr> yeah, I read it too.
18:21:37 <shapr> http://books.slashdot.org/books/04/03/12/221232.shtml?tid=126&tid=156&tid=188&tid=192
18:21:39 <doc_modulo> after that the functional data structures book by Okasaki also got reviewed
18:22:42 <shapr> did you read those books?
18:23:22 <doc_modulo> I didn't understand the posts completely but it was very interesting, because even if I didn't understand the specifics, the advantages of FP were stated as well
18:23:53 <doc_modulo> I think it stuck in my mind after I read about: in FP you don't have to declare types
18:24:05 <doc_modulo> because that was one of the reasons I stopped with Java
18:24:28 <doc_modulo> too much bookkeeping, too thick a layer around the actual programming
18:24:47 <doc_modulo> but after that, nothing for a long time
18:25:03 <shapr> Yeah, totally. The Pragmatic Programmer talks about the accidental difficulty versus the essential difficulty of programming.
18:25:11 <doc_modulo> some personal problems as well, programming on be backburner completely
18:25:37 <shapr> and then?
18:25:41 <doc_modulo> after problems were gone, I started thinking about my own business
18:25:43 <shapr> lightning struck?
18:25:53 <shapr> You own your own business?
18:26:04 <doc_modulo> yes, one of the reasons I'm able to choose Haskell
18:26:19 <doc_modulo> because it's going to be my own company
18:26:23 <shapr> excellent :-) I own half a business, and I chose Haskell.
18:26:35 <doc_modulo> I'll ask about that later, remind me :)
18:26:38 <shapr> ok
18:26:40 <Pseudonym> Can I work for you two?
18:26:46 * shapr grins
18:26:58 <shapr> Pseudonym: only on the condition that you explain grubby number bases to me.
18:27:09 <doc_modulo> haven't started yet, but when I need programmer nr2 I'll dip in this pool here
18:27:11 <Pseudonym> I thought that was wli.
18:27:16 <Pseudonym> I can explain Lie groups!
18:27:19 <Pseudonym> :-)
18:27:59 <doc_modulo> My business, programming games for mobile phones
18:28:11 <doc_modulo> that's the dream
18:28:13 <Pseudonym> Oh, I know someone else who hangs around freenode who does that.
18:28:14 <shapr> Oh, I had a job doing that in Java.
18:28:16 <Pseudonym> pgregory
18:28:25 <shapr> PJAE suxx
18:28:25 <Pseudonym> He's the lead developer on Aqsis, too.
18:28:33 <shapr> I have some neato screenshots though.
18:28:41 <doc_modulo> specifically, targetting Java MIDP2.0  the 2nd version of Java for mobile phones
18:29:20 <doc_modulo> I now had enough motivation to go ahead, and started researching everything I needed for the business
18:29:23 <shapr> so was this today you were thinking about your business and decided to start learning Haskell?
18:29:24 <doc_modulo> as infrastructure
18:29:34 <doc_modulo> Yesterday
18:29:38 <shapr> right, I don't want to get the story out of order...
18:30:21 <shapr> and then?
18:30:22 <doc_modulo> I've researched off and on while doing normal job at a bank
18:31:09 <doc_modulo> Decided to go for open source programs, mainly for the cost and to prevent lock-in by MS or some other company
18:31:43 <doc_modulo> What I needed was not programmming for the clients, but also a server infrastructure
18:32:27 <Igloo> So what, you want to write Haskell that generates Java for phones? Or compile Haskell to Java bytecode?
18:32:27 <shapr> I want to hear about the lightning bolt...
18:32:27 <shapr> that's my favorite part of learning.
18:32:30 <doc_modulo> as a lone programmer, I need to be as lazy as possible, choosing stuff that's not only clean (to prevent future updating hassles) but also has a lot of features
18:33:48 <doc_modulo> chose an open source database, JBoss, Spring on top of JBoss to avoid complexity, and something which generates webpages from templates
18:34:03 <Pseudonym> Damn, I'm enjoying this story, but I'm also very hungry.
18:34:06 <Pseudonym> Need to eat.  BBL
18:34:21 <doc_modulo> computers are neat, they scroll text up :)
18:34:42 <sheVe> Can i define my own bindings/shortcuts for being used in ghci ?
18:34:58 <doc_modulo> hi
18:35:04 <shapr> sheVe: yes
18:35:10 <sheVe> Ok, thanks
18:35:59 <shapr> doc_modulo: so how did you start learning Haskell? Buy the books reviewed? How far have you gotten? What questions do you have?
18:36:03 <doc_modulo> On my to-do list, I had: "Learn a functional programming language like OCaml"
18:36:25 <Lunar^> shapr: TMR guidelines are good :)
18:36:53 <shapr> Lunar^: excellent, should I put you down for a possible HFuse article in issue2?
18:37:16 <Lunar^> shapr: deadline ?
18:37:17 <doc_modulo> shapr: I am starting to learn Haskell tomorrow with the recommended booK: Simon Thompson, Haskell - The Craft of Functional Programming (second edition)
18:37:28 <shapr> Lunar^: also, it seems the EuroHaskell 2005 process is starting up, but I suspect you'll be busy?
18:37:40 <Lunar^> shapr: I won't have the money
18:37:44 <doc_modulo> The reason I chose Haskell:
18:37:48 <Lunar^> shapr: And there's LSM2005 in Dijon
18:38:14 <shapr> Lunar^: deadlide on article submission for issue2 is march 8th for outline/summary, and march 22nd to have the content to the editor.
18:38:46 <doc_modulo> There were all these news stories on the net about how Intel, AMD, Sun, Sony with PS3 etc. are all going multiprocessor/multi-core
18:38:59 <Lunar^> shapr: I can do it
18:39:10 <shapr> y0 samc_ thanks for the Cell review pointer
18:39:14 <shapr> Lunar^: spiffy!
18:39:26 <doc_modulo> That was another reason for thinking, FP languages are really the future of programming
18:39:35 <samc_> no prob
18:40:22 <shapr> doc_modulo: were there more reasons too?
18:40:31 <shapr> just curious...
18:40:57 <doc_modulo> the good points of FP that came most to mind were: (some) FP languages are able to automatically take advantage of multiple processors, or even a local network/cluster of PCs
18:41:14 <gzl> which ones can do that?
18:41:21 <doc_modulo> so I started reading up on FP again to remind myself of what I read in past
18:41:26 <doc_modulo> more reasons:
18:41:42 <shapr> The only ones I know about use declarative parallelism like Nesl
18:41:49 <doc_modulo> well.... first I researched for the "best" FP language
18:42:13 <doc_modulo> I read about the distributed Glasgow Haskell Compiler
18:42:28 <shapr> The Nepal Project and the Parr paralell array library an UNSW.au does declarative paralellism, but doesn't yet take advantage of multiple processors.
18:42:45 <doc_modulo> don't worry, I won't be put off it Haskell won't be able to automatically takes advantage of multiprocessors
18:42:53 <doc_modulo> if
18:43:13 <shapr> Phil Trinder at heriott-watt does the distributed GHC stuff.
18:43:27 <shapr> I think he's at heriott-watt....
18:43:46 <doc_modulo> I read there are 2 distributed compilers/interpreters 1 from Glasgow, and 1 from MIT
18:43:52 <doc_modulo> both for Haskell
18:44:11 <doc_modulo> There was Sisal, which does that as well
18:44:29 <doc_modulo> and something called: Connection Machine LISP
18:44:36 <shapr> I'm pretty sure Sisal uses array parallelism as well.
18:44:52 <doc_modulo> I'm not sure about the details
18:44:56 <shapr> I can *never* remember where the word parallel has one l or two ls
18:45:03 <doc_modulo> 2
18:45:11 <Cale> 3
18:45:12 <doc_modulo> think of 2 parallel lines
18:45:16 <doc_modulo> 3 yeah
18:45:18 <shapr> Jan Willem-Maessen did pH, the eager parallel haskell, at MIT.
18:45:49 <shapr> At least, I'm relatively sure that's what you're talking about...
18:45:54 <doc_modulo> Lots of Dutch sounding names in Haskell research community
18:46:07 <shapr> Phil Trinder oversees two flavors, GpH and GdH
18:46:12 <doc_modulo> researchers in Utrecht etc.
18:46:13 <shapr> parallel and distributed
18:46:27 <doc_modulo> what's the difference, distributed = for grid?
18:46:27 <shapr> yup, Swierstra
18:46:47 <doc_modulo> like, networked PCs?
18:46:57 <doc_modulo> and parallel is for multiprocessing or something?
18:46:59 <shapr> yeah, I think that's the idea. I've never actually played with them much because they're pretty far behind the standard GHC distribution in terms of version.
18:47:25 <shapr> I think that Manual Chakravarty's Nepal Project is more likely to be directly useful in multi-core setups.
18:47:35 <doc_modulo> let me write that down :)
18:47:42 <shapr> I'd also recommend looking into region-alloction used in Moscow ML and the MLKit
18:47:50 <shapr> er "region-allocation"
18:48:05 <shapr> "Manuel Chakravarty"
18:48:13 <shapr> What is wrong with my spelling??
18:48:22 * shapr smacks self
18:48:42 <shapr> hiya borism
18:48:47 <shapr> sheVe: any other questions?
18:48:54 <doc_modulo> you got Chakravarty right and you misspell Manuel????
18:49:09 <doc_modulo> :)
18:49:10 <shapr> yeah I know :-)
18:49:14 <doc_modulo> anyway, yes
18:49:59 <shapr> Is that the end of the story? If so, I can give you the quick intro to Haskell.
18:50:13 <shapr> Or you can continue if you want :-)
18:50:35 <doc_modulo> I'd like to ask: is it a good idea to take the JBoss Java2 Enterprise Edition server because it's taking care of so much stuff, and do as much as the "middle" bit/thinking bit of the server side in Haskell?
18:51:02 <doc_modulo> using the Haskell <-> Java VM bridge   for example
18:51:04 <shapr> Depends on what you want.
18:51:25 <shapr> I assume you want reliability and ease of development above all else.
18:52:01 <shapr> It sounds like you have a lot of experience with Java.
18:52:12 <doc_modulo> well, I want to do everything in a pure FP language if I can, but JBoss/Spring and the database connections take care of so much stuff I then dont' have to program myself.
18:52:33 <shapr> Right, the best approach is to not write it yourself if you don't have to.
18:53:08 <doc_modulo> I want a programming load I can handle with 1 person, in the beginning, I WILL have much time at the start, but want to avoid maintenance as much as possible once I have nagging customers that want my time
18:53:12 <shapr> I think it depends on how well you know Haskell when you start using that sort of setup.
18:53:40 <doc_modulo> think of me as a blank slate and wanting to do as much as possible in Haskell
18:53:54 <shapr> I can layout the possibilities for you, but you have to choose for yourself :-)
18:54:03 <doc_modulo> that would be great
18:54:08 <shapr> At the pure Haskell end, there's a Haskell webserver.
18:54:33 <shapr> There's an extension for that webserver that supports an apache-style plugin interface, though that extension hasn't been used much lately.
18:55:08 <shapr> There are a few tools for websites, Halipeto is a straight up templating, HaXml is type-safe xml generation
18:55:10 <doc_modulo> that would be the part where I interface my Business logic with the webserver?
18:55:17 <shapr> and WASH is more about type-safe dynamic website generation
18:55:52 <shapr> There's also HXmlToolbox, which is neat for different reasons.
18:56:07 <shapr> What sort of business logic do you want to plug in?
18:56:11 <shapr> Can you give me an example?
18:56:50 <shapr> I've done J2EE before, but not in two years or so, so I have only a minor clue about that.
18:57:42 <doc_modulo> 1 end has the "View", the webpages the other end has the database, and in the middle, the programmming the gaming servers + the parts that administer the client accounts
18:57:46 <shapr> For other options, JVM bridge is a good way to mix java and haskell. There's a mod_haskell apache plugin that I don't know much about.
18:57:55 <shapr> ah
18:58:54 <shapr> HaskellDB is a seriously cool database interface, it sits on top of HSQL which is a lower level binding to PostgreSQL, MySQL, SQLite, and some other backends.
18:58:59 <doc_modulo> the gaming servers don't have much to do with the webpages, but the idea is to not only give clients game-only servers, but also something for their community. A simple site, some organisational help for their "clan"
18:59:02 <shapr> There's also a win32 specific Oracle binding.
18:59:13 <shapr> Right, I understand.
18:59:47 <shapr> You can do it all in Haskell if you want. Not all of the pieces are mature, but it would work.
19:00:06 <shapr> On the other hand, you may want to start out by using what you already know as a springboard.
19:00:28 <dons> ok. sigh. pvmgmake doesn't seem stable enough yet.
19:00:39 <dons> though I got one good run of Yi through in 24 sec
19:00:44 <shapr> cool!
19:00:45 <dons> instead of 54 sec
19:01:17 <doc_modulo> Well, is the java/haskell bridge mature enough? I think it depends on that
19:01:22 <shapr> doc_modulo: I build websites for a living. Right now I used Python in Zope and Plone, but I'm slowly getting paying Haskell work.
19:01:45 <dons> the ghc/compiler directory started alright with -j20 distributed over the cluster, but then I got a lot of panics from ghc because .hi files weren't yet written to disk
19:01:53 <shapr> I don't know, I haven't used the JVM bridge.
19:02:04 <dons> plain old gmake -j4 works fine however
19:02:21 <doc_modulo> is that the distributed GHC?
19:02:25 <doc_modulo> shapr?
19:02:26 <doc_modulo> ehm
19:02:28 <doc_modulo> dons?
19:02:42 <dons> nope, distributed gmake
19:02:45 <doc_modulo> ah
19:03:08 <dons> so, in summary, distcc is excellent for distributing gcc builds. I got up to 4.3x speedup
19:03:18 <doc_modulo> anyway, as I said I've got plenty of time before I start
19:03:19 <dons> pvmgmake might work for very clean Makefiles
19:03:24 <shapr> what filesystem does your cluster use?
19:03:43 <doc_modulo> to finish the story about how "I got it"
19:03:51 <shapr> doc_modulo: a month? a year?
19:03:55 <doc_modulo> year
19:03:58 <shapr> oh, I want to hear the end of the story.
19:04:05 <shapr> In a year, you can do a lot with Haskell.
19:04:06 <dons> hmm. let me see.. ext3 over nfs
19:04:27 <doc_modulo> yeah, another reason why haskell is good, better productivity
19:04:40 <shapr> From what I've read, GFS is faster and smoother than NFS for clusters.
19:04:49 <sh10151> hmm
19:04:55 <sh10151> I think productivity is a bad word
19:05:01 <dons> and gmake -jN is really good if you have enough cpus
19:05:01 <sh10151> Productivity is Taylorism
19:05:14 <sh10151> and Taylorism doesn't mix well with programming
19:05:16 <shapr> How about less time for more results?
19:05:22 <doc_modulo> The most convincing part was the story about how a webshop startup used Lisp to save themselves work/did more in less time
19:05:31 <doc_modulo> see, used "less time
19:05:32 <sh10151> much to the chagrin of process junkies
19:05:36 <shapr> Yeah, that's Paul Graham :-)
19:05:41 <doc_modulo> "
19:06:02 <doc_modulo> don't worry, I'm not a "follower"
19:06:10 <shapr> of what?
19:06:26 <doc_modulo> of marketing speak, fashions, other ppl
19:06:36 <shapr> Are you saying you're one of the rare people who thinks for themself?
19:06:44 * shapr grins
19:06:53 <doc_modulo> not unless I have to influence/convince someone, then I'm all inside their circle
19:06:57 <shapr> hehe
19:07:24 <doc_modulo> has to be done sometimes
19:07:31 <shapr> yup
19:07:50 <shapr> dons: if you've got the pull, you may want try switching to GFS and see if you get better results.
19:08:17 <shapr> I'm not quite clear of whether RedHat's GFS and Google's GFS are the same thing.
19:08:26 <doc_modulo> switching Girlfriends? don's even better at convincing than I am
19:08:33 * shapr grins
19:08:41 <shapr> doc_modulo: so, you want the intro?
19:08:47 <doc_modulo> yes plz
19:08:51 <shapr> awright!
19:08:59 <shapr> first, the tour of #haskell
19:09:00 <dons> I'm not sure if I can get that done :) ghc distribution isn't my phd topic... but i think I'll writee a proposal for a thesis student to write a ghc --make that behaves like distcc
19:09:18 <shapr> here on the left we have the famous lambdabot
19:09:31 <shapr> Several useful tools in that irc bot
19:09:42 <shapr> In the channel topic we have urls to the channel logs for the last three years or so
19:09:56 <shapr> also in the channel topic is the url to the learning page on Haskell.org, which is very handy.
19:10:03 <doc_modulo> that's, a lot
19:10:09 <shapr> Last but not least there's the Haskell wiki where lots of goodies are kept
19:10:11 <doc_modulo> I mean, a lot of logs
19:10:17 <shapr> @wiki FrontPage
19:10:18 <lambdabot> http://www.haskell.org/hawiki/FrontPage
19:10:27 <shapr> Now the intro to Haskell itself...
19:10:30 <shapr> @wiki HaskellDemo
19:10:31 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
19:11:01 <shapr> If you will drive your browser to that url, you'll a very compact demonstration of Haskell, much like the bits of food you get at the grocery store where they want you to buy stuff.
19:11:19 <shapr> The difference being that Haskell is free!
19:11:29 <shapr> You have nothing to lose but your respect for lesser languages!
19:11:36 <doc_modulo> too late
19:11:38 <shapr> hehe
19:12:23 <shapr> ok, read the Demo, and I'm sure you'll have questions...
19:12:42 <doc_modulo> I'll be back
19:12:46 <shapr> awright
19:13:08 <shapr> Wasn't I doing something with a website? hmmm...
19:13:41 <shapr> dons: that would fit nicely with Goffin et al.
19:14:20 <dons> yep
19:16:59 <dons> it's cool watching ghc call distcc to send chunks of C fragments all over the network for compilation
19:17:00 <shapr> I still wish for something like Erlang-OTP in GHC.
19:17:19 <shapr> There's gotta be some hackish and cheesy way to turn hs-plugins into Erlang-OTP
19:17:37 <doc_modulo> deriving is like implementing an interface in Java?
19:18:00 <shapr> doc_modulo: sort of, it's like automatically creating an implementation
19:18:23 <doc_modulo> k
19:19:36 <shapr> doc_modulo: btw, I wrote much of HaskellDemo, so complain if you see anything that needs fixing, or if you have suggestions for improvement.
19:24:43 <doc_modulo> I'm in the presence of a celeb :)
19:26:06 <shapr> I'm famous in my own head ;-)
19:26:17 <doc_modulo> well, I guess that if you want to figure out, "how it's done" theres only 1 way of it figuring out, but it wouldn't be bad to have it spelled out by you if what you "figured" is how it's actually done in Haskell. On the other hand, that would not make the text make the reader think like it does now
19:26:51 <shapr> That last sentence lost me in the curves.
19:27:00 <sheVe> lol
19:27:03 <doc_modulo> let me find an example
19:27:38 <doc_modulo> well, the syntax is what you figure out by example, and I think there's only 1 logical way to figure the syntax out
19:27:40 <shapr> Oh, I see.
19:27:49 <shapr> I think I see.
19:27:50 <doc_modulo> but it's not spelled out by you, only by the examples.
19:28:25 <doc_modulo> but maybe it's better this way, readers won't get distracted by syntax rules like I was distracted in java
19:29:08 <doc_modulo> I mean, reading a thorough explanation about syntax would be distraction from the examples
19:29:13 <shapr> very much so
19:29:39 <doc_modulo> so this is better, as long as there's definitely only 1 way of how readers can figure it out for themselves
19:30:18 <doc_modulo> by the way, I just remembered how I got the difference between imperative and FP
19:30:23 <shapr> how?
19:30:31 <doc_modulo> it was the Playstation Cell chip
19:30:38 <doc_modulo> article on Slashdot
19:30:59 <sheVe> for me, i like it very much to have little examples and slowly becoming more and more complex
19:31:28 <doc_modulo> I read on slashdot that the Cell has 1 main processor and the rest of the cores were SIMD
19:32:00 <doc_modulo> the idea is that you have 1 small set of computations that you do on a large/fast stream of data
19:32:10 <shapr> Yeah, I've read about the Cell.
19:32:32 <doc_modulo> a normal CPU is that you do a lot of computations, massaging a small set of data
19:33:08 <doc_modulo> but the SIMD don't really change their state, they're like ...
19:33:52 <doc_modulo> a filter that changes all the data coming in, and spits it all out again, while the instructions stay the same
19:34:12 <doc_modulo> that clicked with a comment in a previous article about how FP languages are like spreadsheets
19:34:26 <shapr> Yeah, spreadsheets is a good comparison.
19:34:42 * Pseudonym scrolls back
19:34:45 <doc_modulo> and that FP languages don't allow mutable ehm
19:34:55 <doc_modulo> what's the word
19:35:04 <shapr> immutable
19:35:10 <shapr> no variables
19:35:14 <doc_modulo> variables yeah
19:35:17 <doc_modulo> LOL
19:36:14 <doc_modulo> how I thought about it then was, the program in Haskell is, as much as possible, like the unchanging code of the SIMD.
19:36:34 <doc_modulo> the dynamic part is mostly the input
19:36:38 <doc_modulo> and the output
19:37:51 <doc_modulo> a FP program is like, set in stone, as much as possible while a imperative program changes it's variables all the time
19:38:09 <doc_modulo> and monads
19:38:14 <shapr> Yeah, that makes for some unusual setups. In J2EE, state is *everywhere* You can't easily test code because you have to reproduce so much state. In Haskell, all state is only in one place, and even then, you (usually) need only a tiny bit of to reproduce a result.
19:39:12 <doc_modulo> test driven development did make a lot of sense to me reading about it however, maybe less important in FP
19:39:50 <shapr> I think it's just as important in FP, I wrote some code to make TDD work with QuickCheck.
19:40:07 <shapr> If you're interested in software testing, QuickCheck will rock your world.
19:40:24 <doc_modulo> yeah, I saw on the libraries page, the testing framework
19:40:41 <doc_modulo> and the way I see monads
19:41:14 <doc_modulo> they are like the containers of state that carry it inbetween a set routine of mini-haskell programs
19:41:41 <shapr> Yeah, that's the state monad.
19:42:08 <shapr> There's a lot more cool stuff than that in monads, it gets better :-)
19:42:37 <doc_modulo> as if the monad invokes a small-SIMD haskell "processor" which only has 1 input, completely runs, and then gives the output back to the monad, the monad then goes to the other "processor" in it's list
19:43:18 <shapr> I would love to explain monads to you in great detail, but you first need the background of writing some pure Haskell code.
19:43:37 <doc_modulo> no problem
19:43:57 <doc_modulo> but did I get it right a bit?
19:44:03 <shapr> You're almost exactly right
19:44:16 <shapr> there's one minor difference that the real state monad can only wind forward
19:44:35 <doc_modulo> so that's how I got it, Playstation 3, spreadsheets and the rest of the research
19:44:56 <shapr> yeah, it's not complicated, it's just a very different way of organizing programming.
19:45:04 <doc_modulo> yeah I got that, otherwise it wouldn't be like a math function on paper, only 1 outcome
19:45:32 <shapr> right, you got it.
19:46:04 <doc_modulo> I also "got" the fact that imperative languages tell a processor not only what to do, but HOW, in tiny little steps
19:46:15 <shapr> yes, excellent point
19:46:21 <araujo> Yes.
19:46:26 <shapr> that's an important realization
19:46:45 <shapr> especially for understand the more general uses of cool stuff like monads.
19:47:04 <doc_modulo> the spreadsheet comment clicked there because, when I used it with FP in mind, you only a program a spreadsheet WHAT you want done
19:47:55 <shapr> There's a third approach btw, logic/constraint.
19:48:00 <doc_modulo> Also, when you have an elaborate spreadsheet, the way it does it's "programmming" is, it's like set in stone. The only dynamic part is adding input and all of a sudden, shit happens
19:48:22 <doc_modulo> logic/constraint?
19:48:55 <doc_modulo> spreadsheets are an excellent way to explain FP, if someone has used them in the past
19:48:57 <shapr> think of these 'SIMD processors' being able to work in two directions, say left and right.
19:49:16 <shapr> x = y + z, and you can put in any two values.
19:49:17 <doc_modulo> k
19:49:35 <doc_modulo> also for X you mean, leaving Y open?
19:49:40 <shapr> right
19:49:43 <doc_modulo> k
19:49:55 <shapr> you can ask for any value once you've filled in the other two values.
19:50:06 <shapr> It's a bit like bidirectional functional programming.
19:50:38 <doc_modulo> and that doesn't produce side effects either?
19:50:51 <shapr> And it has its own set of good and bad points. Happily, you can do logic/constraint in Haskell with some libraries.
19:52:04 <shapr> I don't know much about logic/constraint, just the very basics.
19:52:21 <shapr> I'm on a tour of the world of programming, and FP was my next stop after I got tired of procedural programming.
19:52:33 <shapr> I've been touring FP for more than three years now.
19:52:43 <doc_modulo> another good thing I got about FP is how bad imperative is in practice
19:53:06 <shapr> I don't disagree, but what exactly do you mean?
19:53:45 <doc_modulo> well, I mean that there are all these syntactic rules in Java, only 1 public class in a file etc.
19:53:59 <doc_modulo> all kinds of incoherent stuff that you have to remember
19:54:34 <doc_modulo> but for the cost of having to think "backwards" you lose a lot of rules in FP
19:54:56 <doc_modulo> as far as I know, I gave up on Java
19:55:17 <Pseudonym> Mind you, tht's not imperative programming's fault.
19:55:20 <doc_modulo> the way polymorphism is not tied to those syntax rules for example
19:55:25 <Pseudonym> That Java is kinda dumb.
19:55:56 <doc_modulo> I think, to prevent bugs, they put in all those restrictions
19:56:01 <doc_modulo> which is good in itself
19:56:10 <doc_modulo> preventing bugs is better than hunting them
19:56:41 <doc_modulo> but if you can find some kind of system where you have to have the least amount of rules to program bug-free, then that's better
19:56:48 <doc_modulo> FP is that system
19:57:35 <doc_modulo> on top of that, the rules in FP prevent a more bugs than the rules in Java
19:57:42 <doc_modulo> as far as I read
19:57:47 <shapr> I agree.
19:58:10 <doc_modulo> that's what I meant by discovering how bad imperative was by researching FP
19:58:14 <shapr> I'm an addict to "least amount of rules"
19:58:29 <doc_modulo> me too, I'm lazy in the extreme and have a bad memory
19:58:54 <shapr> You're perfect for FP =)
19:59:00 <doc_modulo> EXACTLY :)
19:59:59 <shapr> but I think that being lazy and having a bad memory applies to "least rules" far more. I think it's a general design principle. http://wiki.pragprog.com/cgi-bin/wiki.cgi/MindCrayon
20:00:04 <doc_modulo> on top of that, one of the advocacy pages said something about the origin of FP, how LISP was a thought experiment on what the "core" of programming really was, not taking into account the limitations of CPUs of the time
20:00:57 <doc_modulo> so if I first learn to program in FP, then I will understand the core more, it's more upfront in FP and less hidden by the syntax
20:01:14 <doc_modulo> that's what ppl say and that's how I understand it
20:01:27 <shapr> Yes, I agree.
20:01:28 * doc_modulo reading
20:02:11 <doc_modulo> I'll read it later
20:02:17 <doc_modulo> because I have some more questions
20:02:23 <shapr> Also, there are multiple expressions of that core. There's the turing machine and the lambda calculus as the most common.
20:02:44 <Pseudonym> shapr: Just a quick question.  When do you want articles for Monad.Reader 1?
20:02:52 * humasect agrees and relates to the article
20:03:14 <doc_modulo> don't know those 2 concepts, except that Alan turing was a Brit computing pioneer
20:03:25 <shapr> Pseudonym: outline and summary by monday (yesterday?) and full article a week before the March 1st publication date.
20:03:34 <Pseudonym> Ah, OK.
20:03:47 <Pseudonym> Since it's now Wednesday, I guess you'd want it now, huh.
20:03:50 <samc_> and combinatory calculus
20:03:50 <shapr> and I'd like to see interim stuff just so I have a good idea of what's going on.
20:03:54 <Pseudonym> Sure.
20:04:31 <samc_> how's shaping up shapr?
20:04:52 <shapr> Pseudonym: Since you talk about cool stuff I've never heard of before on a regular basis, I have no doubt you'll be able to write a nice article.
20:05:00 <Pseudonym> :-)
20:05:11 <Pseudonym> I actually have two possibilities.
20:05:20 <Pseudonym> One is motivating the axioms for arrows.
20:05:28 <Pseudonym> Since there are a lot of them that don't make a lot of intuitive sense.
20:05:31 <shapr> samc_: shaping is fun, as always. Shaping up is even more fun since it uses a unicycle.
20:05:36 <shapr> samc_: how're you?
20:05:40 <Pseudonym> Another is a recreational maths problem.
20:05:45 <samc_> ooh motivating I like that
20:05:59 <Pseudonym> OK, might do that one, then.
20:06:21 <shapr> I'd be happy with either of those, whatever works for you.
20:06:24 <samc_> I mean, how is TMR shaping up? how many outlines have you recieved?
20:06:37 <shapr> umm
20:06:40 <Pseudonym> Actually, I could put the recreational maths problem in anyway, as a "write-in with your solutions" kind of thing.
20:06:40 * shapr blinks
20:06:48 <shapr> Pseudonym: oh that's great =)
20:07:04 <shapr> I very much want to have a puzzles and solutions column.
20:07:26 <shapr> samc_: Looks to me like we'll have as many as ten articles, possible as few as seven.
20:07:41 <Pseudonym> My problem doesn't have a solution.  Well, not yet.
20:07:49 <Pseudonym> Well, in that I don't know the solution.
20:08:06 <shapr> that's cool
20:08:15 <samc_> a do Pseudonym's homework column is it :p
20:08:22 <Pseudonym> :-)
20:09:12 <shapr> Some peolpe have suggested that five articles is the perfect size. It was suggested that too large means people won't actually read it.
20:10:02 <Pseudonym> How many articles do you have so far?
20:10:10 <shapr> um, I forget
20:13:26 <doc_modulo> some of the leaps in the article are very big, but I agree with most of it
20:13:38 <doc_modulo> http://wiki.pragprog.com/cgi-bin/wiki.cgi/MindCrayon
20:14:04 <doc_modulo> shapr time for some more questions?
20:14:13 <doc_modulo> or anyone else here
20:14:25 <Pseudonym> Probably best just to ask.
20:14:25 <shapr> sure
20:14:29 <Pseudonym> Rather than ask to ask.
20:15:37 <doc_modulo> My plan at the moment: Learn a purely functional language, then learn Java in addition
20:15:45 <doc_modulo> this will take a while but that's ok
20:15:59 <doc_modulo> after that, the setup on the server side:
20:16:15 <icb> why learn java when you have o'haskell?
20:16:30 <doc_modulo> because I have to program the games on Java MIDP2
20:16:31 <shapr> O'Haskell is dead
20:16:47 <shapr> OOHaskell + Yampa is a better replacement.
20:16:55 <doc_modulo> but I'm convinced that FP is much better
20:17:18 <shapr> What languages do you know already?
20:17:33 <doc_modulo> minimal Java
20:17:43 <icb> yup, i need to leanr more about arrow
20:17:49 <shapr> Anything other than Java?
20:18:00 <icb> what promoted you to look at haskell?
20:18:03 <doc_modulo> discrete match course 1 year
20:18:12 <doc_modulo> math
20:18:32 <doc_modulo> no other languages, except german, dutch, english :)
20:18:39 <shapr> I was always too loud and embarassing to take a course with the word discrete in the title.
20:18:55 <doc_modulo> go sit in the corner
20:19:00 * shapr snickers
20:19:17 <Pseudonym> A "discreet" maths textbook is probably sold in a plain brown wrapper.
20:19:24 <shapr> lbe
20:19:27 <shapr> oops
20:20:14 <doc_modulo> icb: I first looked at recommendations for learning FP in the slashdot comments
20:20:28 <icb> and..
20:20:40 <doc_modulo> icb: then I compared features of different FP languages
20:21:02 <shapr> Yay, the sun is coming up soon. I can unicycle then!
20:21:18 <icb> shapr, where are you?
20:21:27 <shapr> I'm in Sweden. Where are you?
20:21:30 <icb> nyc
20:21:34 <doc_modulo> apart from FP being just better, it had the added benefit that purely functional languages CAN be made automatically multiprocessor/work in grid
20:21:42 <shapr> Ah, nice place. Kinda busy.
20:21:48 <icb> come visit :)
20:21:53 <gzl> mm, nyc.
20:22:03 <shapr> I lived in Peakskill for six months long ago.
20:22:09 <icb> i will organize local hask user group meeting
20:22:16 <shapr> heh, that would be cool :-)
20:22:29 <shapr> I'll be in the Deep South in July, but that's about it.
20:22:29 <doc_modulo> with my business, because I want to limit programming time. I just want to add a PC into my cluster to handle more customers
20:22:41 <icb> have you looked at plan9?
20:22:45 <doc_modulo> instead of optimizing and optimizing
20:22:59 <doc_modulo> that's an operating system in development right?
20:23:06 * samc_ wishes he was in sweden or nyc
20:23:08 * icb is trying his luck and building 6-4-branch on mac
20:23:23 <Pseudonym> samc_: North or South Island?
20:23:23 <icb> samc, come visit
20:23:30 <samc_> north
20:23:49 <icb> it is a nice development os
20:23:52 <samc_> it's so damn hot, I can't get any prog done
20:24:01 <Pseudonym> Where exactly, samc_?
20:24:09 <icb> i remember the story told as "daddy, why can't you use windows like everyone else?"
20:24:16 <samc_> near palmerston nth
20:24:24 <shapr> If you want to do that right now, Erlang would be a better choice.
20:24:24 <shapr> Erlang lacks several things that Haskell has, but Erlang is the most network native language I know.
20:24:26 <Pseudonym> Ah, OK.
20:24:28 <icb> daddy: "well in order to build something like windows, you will need to use something like plan9"
20:24:40 <Pseudonym> You're getting the heatwave we got a couple of days ago.
20:24:44 <shapr> I like Haskell better, but I'll always try to give you the most useful information :-)
20:24:48 <doc_modulo> Erlang is the one developed by Ericsson
20:24:58 <samc_> where are you then?
20:25:03 <Pseudonym> West Island. :-)
20:25:09 <Pseudonym> Melbourne, specifically.
20:25:47 <doc_modulo> well, choise for Haskell: first, Scheme seemed to be the best way into FP
20:25:47 <icb> anyone here exporting a large haskell backend systems for C programmers?
20:26:29 <icb> scheme is very easy to get into
20:26:31 <Pseudonym> 27C doesn't seem too hot.  Is it also humid or something?
20:26:36 <shapr> icb: are there many Haskell users in ncy?
20:26:44 <shapr> um, nyc
20:26:53 <shapr> Pseudonym: where?
20:26:56 <samc_> it's still
20:27:03 <icb> i know 2, one is me :)
20:27:04 <Pseudonym> shapr: New Zealand.
20:27:06 <samc_> also I am heat sensitive
20:27:09 <doc_modulo> yeah, but I wanted to go all the way into purely functional, why learn to program scheme which is almost there, while I got the motivation for Haskell
20:27:12 <Pseudonym> Ah, fair enough.
20:27:25 <shapr> wow, big netsplit
20:27:35 <doc_modulo> yeah I waited
20:27:37 <icb> has anyone here played with k?
20:27:43 <Pseudonym> shapr: No, just a small one.  Youjust happened to be on the bit that split.
20:27:49 <shapr> oh
20:27:49 <doc_modulo> yeah
20:27:51 <samc_> at least we don't get bushfires here
20:28:03 <Pseudonym> Well we don't get them precisely here, either.
20:28:10 <Pseudonym> But we did get the storms last weel.
20:28:12 <Pseudonym> week
20:28:37 <samc_> I thought the smoke drifted that far
20:28:53 <doc_modulo> I read: mostly used FP languages are Common Lisp, Scheme and Haskell
20:29:07 <Pseudonym> Yes, the smoke does drift if the fires are local enough.
20:29:23 <icb> ml
20:29:40 <doc_modulo> as Scheme was not purely functional and was subset of Lisp, I looked at Haskell and saw the Distributed Glasgow Compiler as well
20:30:10 <shapr> Sounds like Alabama where being outside on summer days is like having a shower at body temperature with your clothes.
20:30:10 <shapr> icb: I've played with Joy, which is concatenative
20:30:33 <shapr> doc_modulo: well, jump in and learn, Haskell is great!
20:30:51 <doc_modulo> so that looked like the way to go, if I want a super reliable server, it's better to build one with a grid of PCs than 1 giant super expensive one
20:31:10 <shapr> That's true for commodity hardware.
20:31:49 <doc_modulo> and if I need more server power, instead of migrating everything to 1 newer bigger server, with all the hassles....
20:32:04 <doc_modulo> Instead I just plonk extra PCs in the grid
20:32:12 <icb> if that is what you want, seriously look into plan9
20:32:31 <doc_modulo> does it run Hugs/GHC?
20:32:36 <doc_modulo> icb: I will
20:33:09 <Pseudonym> Did you mean Plan9 or Amoeba?
20:33:09 <icb> http://pages.cpsc.ucalgary.ca/~mirtchov/p9/hugs/
20:33:11 <doc_modulo> I also found: http://c-jdbc.objectweb.org/   for clustering your databases
20:33:19 <Pseudonym> Ah, OK.
20:33:32 <icb> i like acme a lot
20:33:42 <icb> i wish the unix derivatives would work as well
20:34:19 <shapr> Have you tried hOp? :-)
20:34:36 <icb> what dat?
20:34:40 <doc_modulo> acme? hOp?
20:34:48 <shapr> http://www.cse.ogi.edu/~hallgren/House/
20:34:52 <icb> acme is an ide for plan9
20:35:33 <icb> h0p, radical!!!
20:35:52 <doc_modulo> ah
20:36:08 <shapr> icb: now I want a CD bootable distro... hOppix
20:36:18 * samc_ wants a Raskin and Pike inspired IDE for haskell
20:36:33 <doc_modulo> where does the plan9 os come into clustering?
20:36:51 <doc_modulo> does it cluster computations? data?
20:36:58 <doc_modulo> both?
20:37:11 <icb> clustering is a very imperative organization
20:37:23 <samc_> I guess I could start with an Archy mode for Yi
20:37:55 <icb> archy is neat
20:37:57 <shapr> I'd argue that clustering is very FP
20:38:07 <doc_modulo> well, if you cluster just computations, that's how I read DGHC works
20:38:24 <doc_modulo> If I understand higher order functions....
20:39:01 <doc_modulo> the functions that make up the higher order function can be farmed out to other CPUs, and the higher order function will wait for the results because it's lazy or something
20:39:08 <shapr> doc_modulo: the solution is to jump in and write code, learn Haskell. Then you'll know.
20:39:23 <shapr> y0 Mistah Denney
20:39:41 <doc_modulo> shapr: I will, definitely, I never saw the path more clearly :)
20:39:46 <doc_modulo> just 1 last question
20:40:04 <shapr> ?
20:40:29 <doc_modulo> mobile phones will become more and more like little computers. Is there a Haskell for restricted platforms (cpu speed/mem)
20:40:44 <shapr> sort of, there's NHC.
20:40:57 <shapr> NHC runtime should run on PalmOS
20:41:13 <shapr> But I don't know how MIDP2 compares to that, I'd guess much smaller.
20:41:15 <doc_modulo> what's it called spelled out so I can google?
20:41:34 <shapr> I think it's 'Not a Haskell Compiler'
20:41:52 <doc_modulo> MIDP2 is the specification of which JVM and some minimum requirements, but not maximum
20:41:53 <shapr> But I'm not sure of that.
20:43:55 <shapr> It'll be difficult to do anything for the JVM in Haskell. It would be easier to port the nhc98 runtime to something like the SymbianOS
20:44:21 <shapr> That wasn't a good explanation, but I'll explain it in more detail tomorrow when I'm awake.
20:44:34 <icb> good night, shapr
20:44:47 <shapr> I'm not sleeping yet, I'm just bailing out to do some work =)
20:44:54 <shapr> I'll be back tomorrow...
20:46:48 <dons> btw, http://www.haskell.org/nhc98/
20:46:56 <doc_modulo> ah
20:47:08 <doc_modulo> was looking at wrong site
20:49:16 <doc_modulo> I think, because games are so realtime, it's better to stick with Java there, but I'm still deciding on how much FP programs on the server side
20:50:18 <doc_modulo> basically, I'm intending to do my server side in clusters. I have the solution for clustering databases: http://c-jdbc.objectweb.org/
20:50:34 <doc_modulo> and Haskell has a quiery language for DBs
20:51:11 <dons> I've personally witnessed nhc98 ported to a credit-card sized arm device: http://www.disy.cse.unsw.edu.au/Hardware/PLEB/
20:51:44 <dons> but that runs linux, so it was not too hard, I think
20:51:53 <doc_modulo> Xscales are often used in mobiles
20:52:02 <doc_modulo> so it's comparable hardware wise I think
20:52:36 <dons> cool
20:52:48 <dons> probably more lightweight than java too
20:54:12 <doc_modulo> yeah, but the good thing about MIDP2 is that it's cross-platform, same environment no matter what phone
20:54:22 <doc_modulo> I think it's going to be a necessary evil
20:55:24 <doc_modulo> other people have done all the hard work of porting the JVM to all those hardware platforms, don't want to do that with NHC for every phone
20:55:58 <doc_modulo> maybe if mobiles standardized on 1 HW platform, but that's extremely unlikely
20:56:47 <doc_modulo> how would you cluster a web/application server using FP?
20:58:45 <doc_modulo> apart fromwell, I'm getting ahead of myself.
20:59:11 <doc_modulo> First Haskell, and I'll figure out the clustering later.
20:59:28 <doc_modulo> I'm going to bed, thanks for the help ppl
21:07:21 <wli> (1) haskell (2) ... (3) clustering!
21:07:37 <Pseudonym> (4) Profit!
21:11:42 <fraxtal> hahaha
21:12:28 <fraxtal> (1) haskell (2) Recursion (3) Recursion (4) Recursion ......... (N) Clustering (N+1) Profit
21:20:29 <Pseudonym> (1) haskell (2) recursion (2) tail recursion (2) tail recursion ... (2) tail recursion (4) deep eval (5) deep eval ...
21:49:49 <Pseudonym> I'm tossing up on two titles for my article.
21:50:02 <Pseudonym> Should it be "Pointless Axioms" or "Making Arrows More Pointy"?
21:51:29 <wnoise> Are the axioms in point-free style?
21:51:36 <Pseudonym> They are at the moment.
21:52:06 <Pseudonym> My point is to show why expressing them in this style makes them needlessly harder to understand.
21:56:09 <Gahhh> Double-pointed Arrows
21:56:26 <Pseudonym> How about "making arrows less pointless"?
22:10:42 <Nioate> heh
22:24:33 <gzl> hmm.
22:24:48 <gzl> has anyone used Hudak's animation library?
23:18:29 <shapr> bah, pseudonym left already
23:32:40 <dons> is that all the sleep you get, shapr?
23:33:13 * araujo just gets up
23:35:28 <shapr> haha
23:35:30 <shapr> dons: :-P
23:35:51 <shapr> dons: I owe you a beer or two for especially funny jokes.
23:36:04 <dons> ha! I'll remember that
23:36:09 * shapr grins
23:38:54 <shapr> g'mornin Mistah Fostah
23:43:40 <shapr> tmoertel: y0 tom! wassup?
23:51:18 <gzl> shapr, you up for a question about some graphics/animation stuff from Hudak?
23:51:28 <shapr> maybe
23:51:45 <gzl> I'm playing with the animation stuff from 13
23:51:47 <shapr> You can ask the question, no guarantees on an intelligent answer.
23:51:49 <shapr> 13?
23:51:52 <gzl> Chapter 13
23:51:54 <shapr> oh
23:52:20 <shapr> You mean the Hudak book, I thought you meant the SOEGraphics library specifically.
23:52:29 <shapr> so, what about chapter 13?
23:53:12 <gzl> he has some animation stuff set up. i want to draw one circle orbiting another one such that the satellite gets smaller towards the "top" of the elliptical orbit and larger towards the bottom (so it looks like it's going farther away and coming back)
23:53:30 <shapr> sounds cute
23:53:31 <gzl> the orbit stuff works fine, but the growing and shrinking is giving me grief.
23:53:40 <shapr> How are writing it?
23:53:53 <gzl> shall I paste the code somewhere?
23:53:56 <shapr> um, what approach are you using?
23:54:02 <shapr> I'd rather you describe it first.
23:54:05 <gzl> sure
23:54:15 <shapr> Are you familiar with the Cardboard Analyst approach to problem solving?
23:54:26 <gzl> no
23:54:44 <shapr> http://c2.com/cgi-bin/wiki?CardboardAnalyst
23:55:07 <gzl> haha.
23:55:19 <gzl> ok, fair enough.
23:55:20 <shapr> ok, go for it, describe your approach?
23:55:22 <gzl> yeah
23:56:02 <gzl> I have an orbit function that takes two pictures, orbit frequency, the x and y radius of the orbit, and some scaling factor
23:56:21 <shapr> ok
23:56:27 <gzl> I calculate the x and y position of the satellite by doing x * cos (f * time) and similarly with sin for y
23:56:39 <shapr> sounds easy enough.
23:56:41 <gzl> right
23:57:28 <gzl> so this makes the satellite orbit around some object, which is fine. so call those x' and y' and then I can basically write b' = translateB (x',y') b to get the satellite to orbit around.
23:57:50 <gzl> then I have a simple check for whether y' > 0 to see whether to draw the first object or the second on top, to simulate one going behind the other
23:57:54 <gzl> anyway
23:58:02 <gzl> this all works fine
23:58:27 <gzl> now I have a scale function that takes some vector (x,y) and a picture and scales it (in a way analogous to translate, which just shifts the picture)
23:58:56 <gzl> so my approach was basically to do b' = scale (s, s) (translateB (x',y') b)
23:59:22 <shapr> sounds good
23:59:29 <gzl> where s is some kind of scaling factor. the basic problem is that I can't find a suitable s. when I find one that makes sense in theory, it has totally bizarre results
