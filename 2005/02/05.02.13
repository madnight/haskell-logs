00:01:20 <shapr> I like my kinesis contoured keyboard.
00:01:27 <shapr> I do wish it had IBM clicky keys though.
00:01:37 <shapr> I wonder.... could I transplant the sexy IBM keys somehow?
00:03:06 <tintin> shapr: kinesis is an expensive clone of maltron :)
00:03:09 <shapr> I do wish for an input system that did not require such a static relation to the human body. something more like http://benjaminrossen.com/KBD/images/model_one.jpg
00:03:09 * tintin hides 
00:03:43 <shapr> tintin: Actually, if you compare the thumb pronation of kinesis and maltron, you'll see that kinesis is a lot less strain.
00:03:58 <shapr> Not only that, but maltron is about a thousand euro, and kinesis is about three hundred.
00:04:18 <shapr> And kinesis has(had?) a one month money back guarantee, maltron doesn't.
00:04:24 <tintin> shapr: Maltron has one of these cheap $180 clones :)
00:04:33 <tintin> and yep there is a money back scheme
00:04:37 <mflux> can people really reach fast typing speeds with such keyboards?
00:04:44 <mflux> and how much would it suck with emacs
00:04:48 <shapr> I'm using ERC Version 4.0 $Revision: 1.693 $ with GNU Emacs 21.3.1 (i386-pc-linux-gnu, X toolkit, Xaw3d scroll bars, built 2004-10-16)!
00:04:57 <shapr> it doesn't suck at all.
00:05:15 <tintin> I'm using ERC Version 5.0 $Revision: 1.743 $ with GNU Emacs 22.0.50.2 (i686-pc-linux-gnu, X toolkit, multi-tty, built 2005-02-13)!
00:05:20 <shapr> And yes, you can improve your typing speeds with more ergonomic keyboards.
00:05:22 <tintin> and it does even better :)
00:05:34 <tintin> shapr: you need to update to 22.x
00:05:38 <tintin> there has been a bug fix
00:05:43 <shapr> I want to get rid of emacs entirely.
00:05:46 <shapr> Yi!
00:05:50 <tintin> or a security fix
00:06:04 <tintin> untill you get Yi get the security fix ....
00:06:11 <shapr> fair enough...
00:07:38 <shapr> As ergonomic keyboards go, the bowl shape for the fingers is important - http://kinesis-ergo.com/contoured.htm - http://www.maltron.com/
00:08:27 <shapr> But if you look at the maltron shape, the thumb angle and depth is more than kinesis, too much more from what I've seen.
00:08:50 <shapr> tintin: obviously we need an ergonomic optimizer written in Haskell.
00:08:54 <tuomov> I just want one without the stupid numpad!
00:08:56 <shapr> then we argue via unit tests.
00:09:28 <mflux> so much wasted space
00:09:34 <mflux> they could put a touchpad into that area
00:09:44 <shapr> I want to get one of the sexy black models - http://kinesis-ergo.com/images/500-blk.jpg I have two white models, but they're not as cool.
00:10:26 <shapr> The maltron has (had?) a model with a built-in trackball in the center. Looks cool, but I haven't tried it.
00:11:03 <mflux> I use trackball in the living room
00:11:24 <shapr> I keep thinking that keyboards are the wrong approach entirely, but I don't know what's better.
00:11:56 <tintin> shapr: www.teleprint.com
00:12:05 <tintin> makes maltron clones and is american
00:12:19 <tintin> they are cheaper than then original maltron s
00:12:36 <shapr> That thumb angle will hurt bad in a few weeks.
00:13:43 <tintin> shapr: there is this data hand that has a well for the fingers and letters all around it
00:13:48 <shapr> I have a theory that any 'shift keys' should be under the thumbs. I call it my "I am not a koala" theory.
00:14:02 <shapr> Yeah, I've seen the datahand, but they're a thousand euro per hand.
00:14:16 <shapr> I would very like to try it, but I don't have that much spare cash.
00:14:40 <shapr> I've remapped my kinesis to move all the shift keys under my thumbs, and it has noticeably cut down on my RSI
00:15:12 <tintin> speaking of keyboard layous google for arensito keyboard layout ... someone wanted profiling
00:15:14 <shapr> If you've heard of 'emacs pinky' that's what my "not-a-koala" layout is designed to fix.
00:15:43 <tintin> shapr: yep that is the exact reason why i got myself a maltron
00:16:05 <tintin> My pinkies already hurt and i broke both while playing cricket when I was younger
00:16:35 <wnoise> fingerworks can use gestures to do shifting keys, so you don't have to stretch your pinky.
00:16:36 <shapr> huh, arensito is neat.
00:17:10 <mflux> those companies should have videos of people using the keyboards
00:17:41 <tintin> wnoise: agreed but i want the tactile feel for the keys too ... i think i would be odd to do a tap dance on a flat plate ...
00:17:53 <shapr> I do know that qwerty users appear to me to jump all over the keyboard for not so much output.
00:17:58 <tintin> and the thumbs are the strongest of all our fingers
00:18:14 <tintin> shapr: but a non dvorak user would never ever accept that
00:18:16 <shapr> wnoise: if you get one, I want to hear your opinions.
00:18:26 * shapr shrugs
00:18:36 <shapr> I try stuff if it looks like it might be better. If it's not, I stop using it.
00:18:43 <tintin> usually the dvorak users move only over the homerow which seems better
00:19:13 <shapr> Thanks for the arensito pointer, this is nifty.
00:19:24 <tintin> yw
00:19:48 <tintin> shapr: also have a look at the Maltron layout ... it can be mapped onto your keyboard
00:20:21 <tuomov> the problem with dvorak is that all programs' bindings become unusable
00:20:23 <wnoise> What does the tactile feel give you?  recentering, mostly.  the fingerworks can see where the rest of your hand is and which finger is pressing to keep its "virtual keyboard" underneath your hand.
00:20:53 <tuomov> related keys are all over the kb
00:20:53 <shapr> tintin: I've seen maltron, it didn't impress me much last time, but I'll check it out again.
00:20:54 <wnoise> shapr: I'll let you know.
00:21:26 <shapr> wnoise: by that logic, a keyboard should really be a pendant your wear that can see your hand movements, no sensing surface required.
00:21:48 <shapr> oh, those exist - http://www.virtual-laser-keyboard.com/index.asp
00:21:57 <mflux> tuomov, I've heards OS X has a mode in which holding for example ctrl down remaps keyboard back to normal
00:22:15 <mflux> I suppose it could work in most cases
00:22:33 <tuomov> perhaps, but it could be a bit odd to use
00:23:10 <mflux> I wonder if anyone has written such support for x-server
00:23:17 <tintin> shapr: maybe arensito moded to dvorak would get you back in action super quick
00:23:40 <tintin> you only have to get hold of the programming characters ...
00:23:57 <tuomov> I don't think it would work very well with X
00:24:05 <wnoise> shapr: doesn't do nice mouse integration.
00:24:18 <tuomov> you'd have to broadcast the changed map to all programs on every control key press and release
00:24:38 <shapr> wnoise: probably depends on whether the display and sense chunks can be reprogrammed
00:24:48 <wnoise> Just have the control map be the unqwertyed one.
00:25:12 <wnoise> shapr: right.  But that specific one doesn't have that functionality.
00:25:18 <shapr> suck
00:26:28 <wnoise> undvoraked, rather, or reqwertyed.
00:26:56 <mflux> tuomov, it would be sufficient to send them only to the program in focus..
00:26:57 <shapr> I'd be fine with a spoken programming language.
00:27:04 <mflux> although that would be sort of a hack
00:27:29 <mflux> sufficient if atleast the terminal application and emacs listens to those messages ;)
00:27:51 <wnoise> And change on focus?  The WM also needs to know.  But as i said, you can create a mapping where s maps to ctrl-o when ctrl is held down.
00:27:51 <mflux> what would be the problem in broadcasting the message to every window anyway?
00:27:58 <musasabi> Having two keymaps and a shortcut between them is quite easy with newer X.
00:28:31 <tuomov> traffic, some programs do grab remapping etc.
00:28:47 <tuomov> of course, you could just lie about the keycode...
00:28:55 <wnoise> most programs don't actually listen for keymap changes, just read it once on startup.  FVWM had this annoying bug forever.  No idea if it still does, since I'm now using Ion.  (Thanks tuomov!)
00:29:08 <shapr> yeah, thanks tuomov :-)
00:29:39 <shapr> Speaking of which, ion had several votes for best graphical desktop in a happy-penguin poll recently.
00:29:50 <wnoise> happy-penguin?
00:30:07 <shapr> http://happypenguin.org/poll?show=369
00:30:18 <tintin> hehe Ion is history use xwem!!!
00:30:42 <mflux> I believe ion's website is also the most search-engine-referred page on modeemi's website (the computer club it's hosted on)
00:31:04 <mflux> not that it means much though ;)
00:31:05 <tuomov> yeah. googling for modeemi returns ion page first
00:31:14 <tintin> www.xwem.org
00:31:50 <tintin> with keyboard macros and strokes :)
00:32:15 * shapr strokes ion3 'mmm, my precious'
00:33:02 <tintin> shapr: try xwem and you will be blown away :)
00:33:30 <tuomov> uh.
00:33:33 <wnoise> emacs?  Bleh.
00:33:41 <tuomov> window manager that requires emacs to run?!?
00:33:50 <tuomov> that's one sick project :)
00:33:54 <gzl> i haven't found an equivalent for emacs' haskell mode
00:34:03 <gzl> a vim equivalent I mean
00:34:06 <shapr> tintin: no thanks, I'm trying to get out from emacs, not deeper in :-)
00:34:25 <shapr> I think emacs has several fundamental flaws that won't be repaired.
00:34:26 <gzl> also tuareg for OCaml has no vim equivalent
00:34:29 <gzl> like what?
00:34:29 <tintin> tuomov: one than is really nice :)
00:34:29 <wnoise> I haven't needed it.  The only time I ran emacs voluntarily was gnus was the best nntp-client I had found.
00:34:51 <gzl> I find the haskell mode useful, for better or worse
00:35:06 <shapr> what flaws?
00:35:08 <gzl> I use vim for most else but the indentation becomes much more convenient in emacs
00:35:12 <gzl> shapr: yeah
00:35:58 <tintin> shapr: sxemacs might address some of them :)
00:36:26 <shapr> Two of the problems that come to mind are lack of multithreading, and elisp.
00:36:44 <tuomov> Hmm.. merits a link in my ion links section..
00:36:48 <shapr> I wrote something relatively comprehensive about this somewhere, I wonder where I put it.
00:36:53 <tintin> multithreading should be taken care of by sxemacs
00:37:30 <tintin> both will be taken care of in a clisp based emacs which is in the works
00:37:39 <shapr> You mean hemlock?
00:37:43 <tintin> nope
00:37:53 <shapr> which project?
00:37:58 <tintin> its a newer implementation which uses idas from hemlock
00:38:05 <gzl> shapr: what editor do you use?
00:38:07 <tintin> shapr: its not yet public
00:38:16 <tintin> clemacs is the present name
00:38:28 <tintin> it would take a year though
00:38:32 <shapr> gzl: I use gnumacs, I used to use xemacs. imho, They're the still the best available. But that's not good enough =)
00:38:48 <gzl> hmm never even heard of gnumacs
00:38:51 <shapr> gnu emacs
00:39:06 <shapr> Sorry, I've spent a long time in the emacs community.
00:39:12 <tintin> clemacs developer uses xeamcs or used to use  xemacs
00:39:56 <tintin> anyways since its a year away ... lets not worry about it too much ...
00:40:07 <shapr> gzl: http://lists.scannedinavian.org/pipermail/post-emacs/2004-October/000003.html
00:40:14 <gzl> looking
00:41:05 <shapr> Mailing list activity dropped to zero when most of the members started discussing here on #haskell.
00:41:26 <gzl> shapr: your use of emacs sounds much heavier than mine, so i haven't run into too many of these problems (e.g. the elisp stuff)
00:41:53 <tintin> gzl: hehe he is baised
00:42:12 <shapr> Yes, I'm a heavy user. I have a long habit of emacs/elisp use.
00:42:14 <tintin> he is une pom-pom girl of yi remember :)
00:42:30 <shapr> But I'm biased because I've been using emacs so long, and so hard.
00:42:36 <tintin> haha
00:42:40 <tintin> :)
00:42:43 <gzl> yeah
00:42:56 <gzl> I really just use the most basic stuff
00:43:21 <gzl> basic window and buffer management, basic editing commands, few basic developer tools
00:43:32 <tintin> anyways its got too many goodies which are best preserved ... not sure everyone will fall into yi just yet ....
00:43:52 <tintin> yi has to get a lot better than being a vi :)
00:43:56 <shapr> I don't expect them to :-) I want Yi for me.
00:44:00 <gzl> never even heard of yi
00:44:12 <shapr> http://www.cse.unsw.edu.au/~dons/yi.html
00:44:20 <tintin> gzl: yi is a "vi" like editor written in Haskell
00:44:35 <gzl> any reason to use it over vim?
00:44:46 <tintin> it uses haskell
00:44:52 <shapr> Emacs isn't really an editor exactly, it's an elisp interpreter written in C.
00:45:20 <shapr> When I decided that emacs wasn't going to get better, I cast about for a way to distill the Emacs QWAN into something similar.
00:45:21 <tintin> yep that is why it is so succesful
00:45:53 * juhp wonders why the ghc 6.4 snapshot builds are so much bigger than the 6.2 linux/i386 ones
00:45:55 <shapr> Originally I wanted to use Joy or another purely functional concatenative language, and implement that language in Haskell.
00:45:58 <gzl> how do i benefit from it using haskell?
00:46:00 <tintin> haskell interpreter is what we need then :)
00:46:33 <wnoise> hence the use of hs-plugins...
00:46:42 <shapr> Don Stewart implement hs-plugins, which allows elisp-quality dynamic loading/execution in Haskell.
00:47:03 <wnoise> Don't we want better than elisp-quality?
00:47:24 <shapr> Works for me. But we sure don't want less than.
00:47:41 <tintin> yi is taking too long ...
00:47:44 <mflux> it is sometimes nice to be send elisp queries interactively (in the minibuffer) to emacs, is that feature already there?
00:48:00 <mflux> ie. to make queries about global state
00:48:07 <gzl> I find vim helps me a little less with writing than emacs does, but at the same time I find it smoother and easier to use most times
00:48:24 <wnoise> hs-plugins feels rather heavy-weight though.  I'm not sure I entirely like how it works.
00:48:31 <shapr> mflux: not that exact feature, but the machinery is in place, and it will be there.
00:48:31 <tintin> gzl: viper mode in emacs might be for you
00:48:40 <wnoise> global state? what sort of heresy is this?
00:48:49 <mflux> ;)
00:49:19 <gzl> tintin: hmm
00:49:34 <wnoise> All right, I'm being a smart ass and getting punchy, so I should probably go to bed.  Good night.
00:49:56 <shapr> That was my original problem with writing a HEmacs, that I wouldn't have to recompile and restart for each change, but hs-plugins solves that.
00:50:31 <tintin> Hemacs was morphed into vi .....
00:50:36 <tintin> woops yi ...
00:51:28 <gzl> tintin: checking this out
00:51:29 <shapr> dons got Yi to be loaded from Boot.hs, so the whole editor is dynamic, you can edit the editor core with itself, and use :reboot to save state, recompile anything that needs it, and reload anything that was changed. That takes about 0.2 seconds.
00:52:06 <shapr> This is why I claim that Yi is more dynamic than emacs, because emacs can't edit itself and reload itself. But it's just a cheesy claim ;-)
00:52:13 <tintin> hehe :reboot is too much like vi :)
00:52:45 <tintin> lol yeah get where emacs is and state the same ....
00:53:22 <shapr> What I'm really looking forward to is investigation of parse tree macros, generic refactoring and the like, as done by the MetaEnvironment - http://www.cwi.nl/projects/MetaEnv/
00:54:30 <shapr> Emacs has the Semantic Bovinator, which generates elisp parsers from a language grammar. That allows a bunch of really cool features like you see in Omnicore's CodeGuide and other really spiffy language-specific editors.
00:54:55 <gzl> tintin: best suggestion ever!
00:55:20 <tintin> gzl: yw :)
00:55:29 <shapr> But very few people actually use Semantic, because it's slow and flaky, most people stick with regex-based modes. And that sucks :-(
00:55:38 <Svrog> hi everyone
00:56:17 <shapr> So what about an editor where every language mode is parser based? Syntax highlighting, indentation, everything?
00:57:05 <Svrog> a friend of mine is working on something like that.. although currently only for c++ heh..
00:57:12 <shapr> One of emacs' strong points is 'editor macros' where the name emacs originated. But they only work on text.
00:57:36 <shapr> Parse tree macros should be interesting.
00:57:50 <gzl> oh man, i didn't expect to like this that much
00:58:12 <gzl> actually
00:58:25 <gzl> this will solve my problem of inserting weird characters into files when editing with emacs
00:58:40 <gzl> i keep having 0 and $ and stuff inserted before i realize i'm not in vim
00:59:05 <tintin> gzl: mode 5 is for expert emacs users iirc ... so you can have as much of vim as you want to :)
00:59:14 <tintin> and still have all the emacs features
00:59:47 <shapr> Svrog: I do believe that's a better way. Regexps must die.
00:59:54 <tintin> viper was the dirty trick of emacs to win over all the vi users :)
00:59:55 <gzl> yeah I started with 3
01:00:11 <gzl> well, I'll still use vim for regular text editing
01:00:21 <Svrog> i agree about regexps having to die :)
01:00:25 <gzl> but for coding, this is nice
01:00:44 <gzl> i'll have to see how well it works when i'm actually working and not just playing
01:00:47 <tintin> gzl: do you need to move out and open a new tool :)
01:00:56 <shapr> gzl: anyway, there's no real reason to use Yi yet, unless you want to help develop a really cool editor that hopes to subsume both vi and emacs at some point.
01:01:16 <gzl> tintin: ?
01:01:20 <gzl> i don't follow
01:01:24 <gzl> shapr: not at the moment, thanks :)
01:01:37 <shapr> I can dig that.
01:01:42 <tintin> gzl: i will still use vi for .... do you have to move out ?
01:01:58 <shapr> hs-plugins is awesome, if you use Haskell much, it's really worth learning.
01:02:02 <Svrog> where can i find this yi? ive heard a number of people talk about it
01:02:03 <tintin> when you can handle everything like you are in vi :)
01:02:18 <shapr> Svrog: http://www.cse.unsw.edu.au/~dons/yi.html
01:02:24 <Svrog> thanks
01:02:40 <shapr> Yi isn't ready for general use yet, but it's getting closer.
01:03:27 <jaro> hi there. Is there any way how I can measure the efficiency of a functions? I did :set +s and compared the numbers, but it is not very comfortable way to do it.
01:03:29 <Svrog> oh ok
01:03:47 <shapr> jaro: Have you tried profiling with GHC?
01:04:03 <jaro> no. I didn't try anything yet.
01:04:05 <gzl> tintin: I mean, if I don't have either editor running, and I just want to do some quick text editing, I'll just use vim, but if I have to do some coding and stuff I'll use this
01:04:17 <tintin> shapr: get yi to accept emacs commands first !!!
01:04:31 <tintin> :reboot is too much of a turnoff
01:05:41 <shapr> tintin: you could jump in and help =)
01:06:27 <tintin> shapr: i believe you are the one behind the emacs keymaps :) atleast that is what dons told me :)
01:07:19 <shapr> You could be one of the people behind the emacs keymaps.
01:08:16 <tintin> but you are already half way there shapr :)
01:08:37 <tintin> to learn to use :wq and :q would make life miserable
01:08:52 <gzl> i'm used to :q and :wq :)
01:08:59 <Svrog> me too hehe
01:09:09 <gzl> i really do like vi
01:09:14 <gzl> but having some of the emacs features is nice
01:09:19 <gzl> oh, is dired really useful?
01:09:25 <gzl> i never really got the point
01:09:28 <tintin> yep dired is wonderful
01:09:58 <Svrog> im off for a bit - bye
01:10:00 <gzl> what do you do with it?
01:10:07 <shapr> I use dired sort of like elisp shell scripting.
01:10:38 <tintin> gzl: organise my mp3s play my mp3s move files around rename files .. edit files ....
01:10:54 <tintin> edit linux config files ....
01:11:13 <tintin> there is even a midnight commander mode ....
01:12:30 <gzl> yeah, but if i want to edit a file, i just do C-x f and give the path
01:15:00 <xerox> C-x C-f ;)
01:15:03 <tintin> gzl: if you have no idea where it is :) or you want to find all there is :)
01:15:04 <tintin> etc etc
01:15:50 <tintin> you woun't remeber any of the key bindings after a while ... it all gets programmed into your reflexes :)
01:16:14 <xerox> Talking of dired, do you know if there is a way to show only files/directories matching a certain regexp?
01:16:55 <shapr> Probably. I know you can mark files with %m regex
01:17:10 <shapr> likely you can hide unmarked files or something.
01:17:16 <tintin> dired-mark-files-regexp ?
01:19:03 <shapr> One thing that frustrates me with emacs is the lack of a consistent function naming system. I wish it would stick with something like module-noun-verb. In any case, I wish someone would refactor the names into something consistent.
01:19:31 <shapr> Kensanata had the idea to release a HumaneInterface version of emacs with all the functions renamed. :-)
01:20:20 <tintin> shapr: you can always create a defalias.el :)
01:20:31 <tintin> take the intiative :)
01:20:42 <shapr> I've got the initiative! I'm working on Yi!
01:21:00 <shapr> (require haskell)
01:21:10 <tintin> (require emacs)
01:21:18 <tintin> yi mode .....
01:21:23 <xerox> Hm, I can't see how to hide unmarked files.. (sorry for being OT)
01:21:23 <tintin> lol
01:21:39 <shapr> I wonder if the general pattern is really a domain specific language for editing.
01:22:39 <shapr> xerox: I don't know, I'd suggest the DiredMode page on emacswiki.org
01:22:52 <xerox> shapr, right. Thank you-
01:23:07 <tintin> not sure it can be done .... you can see it highlighted ...
01:23:44 <tintin> you could always write some elisp :)
01:23:51 <xerox> The best thing would be (at least for me) something like C-x C-f some/path/*.hs TAB TAB to see only *.hs files.. doesn't it?
01:24:21 <tintin> xerox: check out the section Omitting files in dired
01:24:24 <tintin> thats what you want
01:24:39 <tintin> M-o
01:24:56 <tintin> C-h i d m : dired
01:25:01 <tintin> omitting files ....
01:25:52 <tintin> yep thats what you need
01:29:24 <shapr> tintin: written any Haskell recently?
01:31:33 <tintin> not in the past week i have been learnig LaTeX
01:32:13 <shapr> Ah, I've been learning that too.
01:34:25 <tintin> shapr: finalised the format yet ?
01:34:37 <tintin> for the journal ?
01:36:03 <shapr> look at 'darcs get http://www.cs.uu.nl/~andres/TMR'
01:49:43 <jaro> what's wrong with this construction? if ( v == 0 ) or ( v >= top ) then ... where v :: Int. It complains about (==) term and it's type :-((
01:49:54 <araujo> Hello.
01:50:11 <jaro> (where :: Int is just for your information, not in the code)
01:50:13 <shapr> jaro: what's the error?
01:50:32 <jaro> *** Type           : f -> f -> Bool
01:50:36 <jaro> *** Does not match : a -> b -> c -> d -> e
01:51:35 <jaro> Term is (==), expression is the code between if and then
01:52:15 <shapr> @type or
01:52:17 <lambdabot> or :: [Bool] -> Bool
01:52:36 <shapr> jaro: see?
01:53:12 <jaro> yes ;o) but didn't expect that.
01:53:16 <shapr> @type (||)
01:53:18 <lambdabot> (||) :: Bool -> Bool -> Bool
01:54:15 <xerox> shapr, I can understand the error, but how the "a -> b -> c -> d -> e" part is going to mean something?
01:54:36 <jaro> This confusion is probably caused by perl ;-)
01:55:01 <shapr> xerox: most likely has to do with the type signature of v
01:56:48 <jaro> on operators: lower priority (number) precedes the higher ones?
02:04:30 <shapr> I really like Dominic Fox.
02:06:31 <xerox> Non-pertinent answer detected <grin>
02:06:48 <araujo> Gooood
02:06:50 <araujo> Morning
02:06:58 <xerox> 'Morning!
02:07:03 <araujo> 8)
02:07:11 <jaro> morning? ;)
02:07:16 <shapr> Happy snow to you!
02:09:38 <araujo> Nothing better than a papaw-tree juice to start this beautiful day
02:10:09 * shapr sings the "Bear Necesseties"
02:10:20 <shapr> That can't be the right way to spell that word.
02:10:25 <araujo> haha
02:36:04 <tintin> i Love sundays
02:36:43 <Oejet> What is the semantics of "~[n] <- getArgs"?
02:40:30 <TheHunter> the same as [n] <- getArgs, except that the possible error only occurs when n is used.
02:43:30 <Oejet> Well isn't there only an error, if n is used later and length(args)/= 1 anyway?
02:44:08 <lightstep> what makes ghc say "openBinaryFile: hardware fault (Input/output error)" ?
02:44:14 <TheHunter> [n] <- return [1,2]
02:44:14 <TheHunter> *** Exception: user error (Pattern match failure in do expression at <interactive>:1)
02:45:12 <TheHunter> Prelude> ~[n] <- return [1,2]
02:45:12 <TheHunter> Prelude> n
02:45:12 <TheHunter> *** Exception: <interactive>:1: Irrefutable pattern failed for pattern [n]
02:46:04 <chugga> is there a haskell-mode that doesnt suck so bad at colour coding
02:46:38 <shapr> Which haskell-mode are you using?
02:46:44 <dons> the vim mode is rather good
02:47:15 <dons> well, reasonable. it still makes mistakes
02:47:26 <chugga> shapr, haskell-mode 1.45
02:47:28 <shapr> g'day dons, what's up?
02:47:36 <TheHunter> well, except for unboxed stuff
02:47:41 <chugga> it just looks so shit that im better off turning it off
02:47:47 <shapr> chugga: 2.0 is better in some aspects, not sure if the highlighting is better.
02:47:59 <chugga> shapr, oh? where do i find that?
02:48:03 <shapr> What about it bothers you? Choice of colors? or what?
02:48:19 <chugga> shapr, yeah, and it does very little highlighting. most of the stuff just looks white
02:49:25 <shapr> If you want to change the colors, check out emacs' color-theme.
02:49:28 <Oejet> TheHunter: Thanks!  So ~ is a built in operator delaying the computation?
02:49:51 <chugga> shapr, yes yes, it doesnt matter what color-theme i use, the highlighting leaves a lot to be desired
02:50:30 <xerox> 2.0 does highlight more things, in fact.
02:50:31 <TheHunter> Oejet, ~ makes an irrefutable pattern, that ensures that a pattern matching always succeeds and the error gets delayed.
02:51:34 <TheHunter> (\(x:xs) -> 4) [] ==> _|_
02:51:43 <TheHunter> (\~(x:xs) -> 4) [] ==> 4
02:52:19 <TheHunter> 'morning, boegel
02:52:33 <chugga> Ah, well, im gonna check out some other functional languages.. hopefully one of them will have a better emacs mode. If im gonna be sitting there writing code for hours and hours, i need it to look nice, thanks anyways shapr.
02:52:36 <shapr> Most people don't like my choic of color themes - http://www.scannedinavian.org/~shae/peren.png - http://www.scannedinavian.org/~shae/secret-joy.png
02:52:47 <shapr> chugga: have fun...
02:53:14 <shapr> hoi boegel
02:53:17 <Oejet> Thanks again, TheHunter.
02:53:41 <shapr> chugga: how do you like the color themes I'm using?
02:54:17 <shapr> Mmm, misty-day and sandalwood.
02:54:25 <chugga> shapr, one second, lemme have a look
02:55:11 <shapr> People tend to scream and claw their eyes when looking at the misty-day color theme. I just don't get it.
02:55:15 <TheHunter> yep, people are kept away from things for very strange reasons. I myself am reluctant to check out emacs because of its lack of antialiasing.
02:55:16 * shapr sniggers
02:56:02 * shapr thinks about antialiasing in Yi
02:56:23 <TheHunter> shouldn't be a problem if it's running in the console.
02:57:31 <TheHunter> theoretically, i could live without antialiasing, but today's screens have very low resolutions, thank you very much windows and your fixed size dialog boxes!
02:57:35 <chugga> shapr, not really. heres what im looking for: http://203.59.45.92/screenshot.png
02:59:20 * shapr thinks about that.
02:59:37 <shapr> Are there enough different pieces in a chunk of Haskell code to get that many colors?
03:00:18 <chugga> shapr, im not really sure if the limitation is because of the language, or whatever
03:00:39 <shapr> So, you want a buffer with more colors?
03:00:43 <chugga> Yes
03:01:30 <shapr> Much of the stuff in Haskell is just functions applied to each other. I guess haskell-mode could add colors for curly braces and stuff.
03:01:36 <xerox> Hmm..
03:02:53 <chugga> shapr, the stupid thing is that it doesnt even highlight functions
03:03:08 <shapr> How would you want it to highlight functions?
03:03:12 <chugga> i mean check the buffer for a something = and you know that thing is a function (to simplify too much)
03:03:15 <chugga> yeah, that'd be a start
03:03:30 <shapr> Oh btw, haskell-mode 2.0 does highlight functions.
03:03:36 <boegel> hey everyone :)
03:03:54 <xerox> http://151.37.241.111/hshl.png
03:03:57 <chugga> shapr, cool. pity debian doesnt have a package for 2 yet
03:04:18 <shapr> debian/unstable does have a haskell-mode 2.0
03:04:26 <Lunar^> lunar@tsuki:~$ apt-cache show haskell-mode | grep Version
03:04:26 <Lunar^> Version: 2.0-1
03:04:51 <chugga> xerox, see, that just looks entirely homegenous.. it beats the point of doing syntax highlighting in the first place
03:05:21 <shapr> http://www.scannedinavian.org/~shae/chugga.png
03:05:24 <chugga> hmm although on second thought, your colour scheme is too subtle - but its a bit better than mine anyway :)
03:06:47 <chugga> shapr, is that highlighting functions? show isnt highlighted
03:07:42 <boegel> my emacs highlightinh is totally f*cked up
03:08:31 <chugga> does vi look better? because i'd be willing to learn vi just for a good haskell mode
03:08:47 <shapr> chugga: No, defined functions aren't highlighted. I don't think it's possible to tell functions and values apart with regex-based highlighting.
03:09:04 <chugga> shapr, ok
03:09:21 <shapr> Nearly anything can be a function in Haskell.
03:09:44 <shapr> and, since a function is also a value, where would you make the difference?
03:10:41 <chugga> shapr, im sure you could find some distinction to make it nicer to look at on the screen :P
03:11:17 <shapr> There is a project to make a parser-based editor in Haskell, but it's not quite ready yet.
03:12:07 <chugga> Oh well.
03:33:47 <lispy> i wish ghc had an option to resize the stack when it bumps into the limit instead of dying and tell you how to manually up it
03:34:57 <Heffalump> isn't there an RTS option for unlimited stack?
03:34:59 <Heffalump> Or is that heap?
03:35:12 <lispy> Heffalump: if there is i'd like to know about it ;)
03:35:18 <lispy> reading the man page now
03:36:43 <boegel> lispy: I think there is
03:39:10 <lispy> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
03:39:15 <lispy> i don't see anything on that page about it
03:42:59 <duncan_> hi boegel, how did the exams go?
03:46:29 <boegel> duncan_: ok, I think my results will be quite good
03:50:05 <Philippa> bah, shapr left while my connection was working out it'd died
03:50:51 <duncan_> boegel: so does that mean you've got plenty of time to try gtk2hs on windows? ;-)
04:11:57 <juhp> anyone know how debian bootstrapped ghc when it was added?
04:12:07 <juhp> out of "curiosity"
04:12:21 <duncan_> juhp: ask Igloo
04:12:22 * juhp wonders if Igloo's around
04:12:35 <juhp> duncan_: hi
04:12:41 <juhp> :)
04:12:43 <duncan_> jhup: hi
04:14:25 <duncan_> juhp: so I can make fun of rpm for not understanding version numbers properly right? :-)
04:14:54 <juhp> duncan_: sure, if you like ;)
04:15:19 <juhp> duncan_: other packaging systems understand better? :)
04:15:32 <duncan_> juhp: I'm sure we can accomodate it however, 0.9.7.0.91 it is
04:15:46 <juhp> ok, good :)
04:16:28 <duncan_> juhp: portage understands: http://www.gentoo.org/proj/en/devrel/handbook/handbook.xml?part=2&chap=1#doc_chap2
04:18:59 <juhp> duncan_: nice - not sure if many others do though :)
04:19:11 <duncan_> juhp: oh well
04:21:12 <boegel> duncan_: euh, I guess so :)
04:21:18 <boegel> should i try the rc3 release ?
04:21:27 <duncan_> boegel: yes please!
04:21:38 <boegel> duncan_: binary or source ?
04:21:56 <duncan_> boegel: it's up to you, try the binaries to start with, it's easier
04:22:02 <boegel> okay
04:22:08 <boegel> let me boot my desktop :)
04:24:58 <duncan_> juhp: do you mind if I keep using _rc style for this 0.9.7.1 release so as not to confuse people. We can switch to the rpm-friendly style for 0.9.8. There's no need to package 0.9.7.1 for unix machines anyway, all the improvements are for win32.
04:25:53 <duncan_> juhp: I was delibarately calling it "0.9.7.1 for Windows" to try and make it clear that the rest of us do not need to upgrade.
04:29:39 <Heffalump> at a guess, Debian would have bootstrapped ghc by an upload of a binary package along with the source.
04:30:10 <Heffalump> I don't think igloo did that, but he probably has to do it for new architectures.
04:37:05 <boegel> duncan_: how close do you think you are to a full windows release of gtk2hs ?
04:37:50 <duncan_> boegel: pretty close, if we don't find any other major isues we could do a release during the comming week
04:38:35 <boegel> duncan_: nice !
04:38:49 <duncan_> boegel: to be confident we just need to do some wider testing...
04:39:04 <boegel> and that's what I'm doing now :)
04:39:13 <duncan_> boegel: exactly :-)
04:46:32 <Oejet> GoboLinux understands all kinds of package versioning schemes, if that is what you are talking about.
04:46:34 <boegel> duncan_: the functions you provided me with, are already added to gtk2hs ?
04:47:19 <duncan_> boegel: the image one was added but the pixbuf ones were not as we're still thinking if it's the best way to do it.
04:48:00 <boegel> I get a compilation error on 'pixbufGetPixels'
04:48:28 <duncan_> boegel: what, in the module I provieded you with?
04:48:59 <boegel> duncan_: check PM :)
04:57:51 <jlouis> What if I via the FFI interface want a pointer to a struct? The name in haskell is not Ptr CInt, but Ptr CStruct, or what?
04:58:59 <Lemmih> If you define CStruct yourself, then yes.
05:00:29 <jlouis> I guess I could do that
05:02:47 <Lemmih> You might not wanna use the name CStruct.
05:05:53 * Lemmih throws a lambda at CMake.
05:11:23 <jlouis> @index liftM
05:11:24 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
05:11:24 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
05:11:24 <lambdabot> State,Control.Monad.Writer,Monad
05:13:13 <TheHunter_> never ever use liftM
05:13:43 <juhp> duncan_: sure that is fine :)
05:14:34 <Oejet> TheHunter: Why not?
05:15:27 <TheHunter> because the correct name is fmap. It's just that Haskell's hierarchy is so braindead because it doesn't have class Functor m => Monad m
05:15:49 <juhp> Heffalump: ok, thanks - that is good, cos that is how I'd like to bootstrap it for Fedora
05:15:54 <TheHunter> it's one of my pet peeves.
05:16:18 <juhp> who was the debian maintainer before Igloo?
05:18:43 <Heffalump> umm, Michael Weber, I think.
05:29:45 <juhp> Heffalump: ah, yes, thanks
05:40:51 <TheHunter> i guess, people should've listened to Koen Claessen: http://www.mail-archive.com/haskell@haskell.org/msg01569.html
05:40:57 <Igloo> I uploaded a hand-ported binary for each non-i386 arch, yes
05:43:09 <juhp> Oejet: ok - sometimes being a latecomer is advantageous
05:43:46 <juhp> Igloo: aha, thanks - so no .hc files?
05:46:55 <juhp> are there any other packages in debian in a similar situation, I wonder?
05:47:39 <Igloo> gcc
05:48:22 <juhp> :)
05:48:50 <juhp> or something more obscure?
05:50:22 * Igloo doesn't know of anything else
05:58:20 <samc> how is 'Oege de Moor' pronounced?
05:58:41 <duncan_> juhp: when I want to bootstrap ghc on another arch (eg I did sparc) I borrow the debian binary package, fiddle with the paths until it works when installed under /usr/local and then I compile ghc from source
05:59:56 <duncan_> juhp: in other words I rely totally on Igloo's excelent porting work!
06:00:34 <juhp> duncan_: ok, sounds good and reasonable :)
06:01:25 <juhp> for i386, since there already exists upstreams binary installable tarball for Linux, I thought I'd just "cheat" and use that
06:02:14 <juhp> I don't feel x86_64 is "ready" enough to include yet anyway
06:03:19 <duncan_> juhp: x86_64 can't run gtk2hs yet for starters :-(
06:03:32 <juhp> right
06:04:11 <juhp> duncan_: there are some nasty bugs reported for it in sf too...
06:04:12 <Igloo> How come, duncan?
06:04:48 <duncan_> Igloo: the bit of assembler to do FFI "dynamic foreign export" has not been done for x86-64
06:04:59 <Igloo> samc: I says "Ooo ger" (with a short r), but I have no idea if that is right
06:05:23 <Igloo> Ah, right
06:05:55 <duncan_> samc: I think I say "Ooo che" but I don't really know either
06:11:41 <duncan_> juhp: I see two bugs in sf that gour reported, they're both priority >=5 and SimonM wanted to fix all such bugs for ghc 6.4 but we'll see...
06:11:58 <juhp> right :)
06:12:19 <juhp> I hope he got his x86_64 box by now...
06:12:28 <duncan_> juhp: do you know anyone who could help us with the x86-64 assembly?
06:12:57 <duncan_> he doesn't, but wli has given him access to his quat em64t box
06:13:06 <duncan_> s/quat/quad
06:13:07 <juhp> cool
06:13:53 <duncan_> however Simon M has rather a lot to do at the moment. the x86-64 assembly might be some time.
06:33:20 <juhp> duncan_: hmm, is the assembly independent of os?
06:33:32 <duncan_> juhp: yes
06:33:58 <duncan_> juhp: it depends only on the ABI / C calling convention
06:34:40 <juhp> duncan_: I see, but it's not in cvs yet, right?
06:34:42 <duncan_> juhp: (ok, so win32 uses two calling conventions stdcall & ccall but it's otherwise independent of OS)
06:35:32 <duncan_> juhp: ghc cvs has no support for x86-64 FFI foriegn dynamic export (as of yesterday's cvs)
06:35:41 <juhp> ok...
06:35:57 <juhp> cd
06:36:01 <juhp> oops
06:36:38 <duncan_> you can look, it's ghc/rts/Adjustor.c, there's plenty of comments and versions for other arches
06:36:39 * juhp wonders if he'll ever get used to click-to-focus ;)
06:36:46 <duncan_> :-)
06:38:05 <duncan_> I was having a first stab at doing it, it involved spilling registers to the stack (since we have to prepend two args to the call and x86-64 passes parameters in registers)
06:50:35 <autrijus> viirya: ping
06:50:45 <autrijus> viirya: your patch is weird. are you sure it is against the darcs source?
06:51:04 <autrijus> there's no single-line whiteSpace in the repo anymore
06:51:09 <autrijus> viirya: I've already fixed the parser
06:57:07 <shapr> y0 peti
06:57:22 <shapr> did you get my mails?
06:57:31 <peti> shapr: Hi. I figured you were here, you replied to my posting on the list in just a few moments. ;-)
06:57:51 <shapr> yup, I'm here as usual.
06:57:51 <peti> shapr: Sorry I dont' reply faster. I've been busy hacking Postmaster.
06:57:58 <shapr> no worries, I'm happy to hear that.
06:58:04 <shapr> I'd like to get rid of postfix.
06:58:47 <peti> shapr: Postmaster is about to be ready. Having the spooler actually _simplified_ things a lot. Who would have guessed?
06:58:57 * shapr is surprised
06:59:07 <peti> shapr: Plus, I have a plug-in architecture ready.
06:59:28 <Lemmih> Hey shapr.
06:59:30 <shapr> will that work for the remote smtp delivery part?
06:59:32 <shapr> hiya Lemmih
07:00:08 <peti> shapr: It does already if you have another MTA to do outbound delivery. An SMTP module is about to be tested, but my focus so far is on getting that thing really exception safe. I don't want to lose any resources.
07:00:57 <peti> shapr: I'd say, in about 4 weeks or so Postmaster is complete. It will even have a config file! ;-)
07:01:00 <shapr> cool!
07:01:07 <Lemmih> shapr: Cabal/Hackage is one step closer to 'cabal-get' (:
07:01:16 <shapr> Lemmih: excellent!
07:03:08 <peti> shapr: I've started worrying about the I/O article for the e-zine.
07:03:24 <peti> sharp: I'd like to combine writing that with getting the BlockIO library documented, obviously.
07:03:36 <shapr> sounds like a good idea.
07:04:10 <peti> shapr: How many articlen do you have already? Or people who promised to write something? I looked at the LaTeX stuff and that looked pretty good. Although I am a fan of two-column layout myself. ;-)
07:04:32 <shapr> Would you like to delay your Block I/O article till next month?
07:05:19 <peti> shapr: The problem is that if I start delaying things, I usually delay them until, um, ever. I am too god-damn lazy.
07:05:31 <shapr> Well, get it in for the first issue then :-)
07:05:49 <shapr> I know the feeling, I'm the same way. Do it now or drop it completely.
07:06:38 <peti> shapr: The problem is that I am not sure about the scope yet. The interesting part is the callback-driven architecture, not the use of hGetBufNonBlocking. But I wonder how many readers actually write applications that need that kind of thing. So perhaps it _is_ better to focus on hGetBufNonBlocking and the Foreign.* functions around it.
07:06:41 <shapr> You've got a week till the content should be in my inbox. And that can be stretched a day or two if you want to get your article in and you really need the extra time.
07:08:34 <shapr> You could do a two part article.
07:08:35 <peti> shapr: OK. I'll see what I can get done by then. I'd really like to get this article written; it's perhaps the single one topic where I really know what I'm talking about. ;-)
07:08:59 <peti> shapr: How long do you think an article for the e-zine should be? Approximately?
07:09:27 <shapr> So far my only answer to that is "Start at the beginning, go to the end, then stop." as Lewis Carrol said.
07:10:09 <peti> Hehe. ;-)
07:10:16 <shapr> If you can send me an interim version of your article, I'll tell you if I think it's too long or too short. But most important to me is quality content.
07:10:54 <peti> shapr: Right. It's better to write something that's short and useful than long and full of mistakes.
07:11:20 <shapr> Or in other cases, a long article may be required for good coverage of a subject.
07:11:51 <shapr> As long as it's a quality article, I'm fine with it. It's not like we're paying for real paper.
07:12:10 <peti> shapr: You know what? Why don't I just get _started_ writing then? ;-)
07:12:14 <shapr> :-)
07:12:46 <shapr> There may be a suggested size after the first issue, but I don't have a clue yet.
07:13:37 * shapr builds ghc 6.4 for his Template Haskell Tutorial
07:14:33 <peti> shapr: Template Haskell rocks. You spend hours and hours doing stuff that would have taken 10 minutes if you'd done it with cpp(1). But it's _Haskell_, so it must be better. ;-)
07:14:42 * shapr laughs
07:15:48 <peti> Alright, I'll get to work. I'll let you know where the darcs repo is ASAP.
07:15:53 <shapr> I'd like to combine Template Haskell and profiling to get a GHC JIT.
07:16:04 <peti> Have a nice Sunday everybody. ;-)
07:16:08 <shapr> thanks peti!
07:16:32 <shapr> hiya toomasr, how's Haskell treating you this week?
07:16:37 <toomasr> hi
07:17:05 <toomasr> slow, i just learnt to use darcs :)
07:17:12 <sh10151> peti: don't forget, 2 minutes with CL :)
07:17:23 <shapr> cool, darcs is nifty.
07:17:41 <toomasr> amazingly easy, at least the subset of features i use
07:17:48 <shapr> toomasr: did you try the wikiwiki repo?
07:18:00 <toomasr> shapr: nope
07:18:19 <shapr> It freely allows email patches.
07:18:48 <toomasr> checking
07:18:48 <shapr> At least, until someone tries to abuse that.
07:19:46 <toomasr> damn, and as i found that none of the documents in the wiki answered my specific problems i could have just sent them patches
07:20:15 <toomasr> because i ended up writing a short how-to
07:21:37 <toomasr> ofcourse i could have just edited the wiki
07:25:06 <shapr> Yep, feel free to add content to the wiki.
07:30:20 <shapr> I wish I could display .lhs files nicely on the Haskell wiki.
07:32:12 <shapr> hoi goron
07:33:20 <toomasr> shapr: i'm looking at a page at haskell wiki displaying lhs, it looks decent
07:33:43 <shapr> Which page?
07:34:07 <toomasr> it does color some words of the comments :)
07:34:15 <toomasr> http://haskell.org/hawiki/HaskellDbTutorial?action=highlight&value=lhs
07:34:25 <Lemmih> Woot Woot (:
07:35:09 <shapr> I see what you mean.
07:55:57 <autrijus> hey. is there a way to shift twice?
07:56:08 <autrijus> i.e. shift over two reset boundaries.
07:57:04 <autrijus> http://wagner.elixus.org/~autrijus/tmp/Monads.hs is the code.
07:57:26 <autrijus> I tried to use ReaderT to pass it the continuation of two resets above
07:57:53 <shapr> I don't know the answer, but I do like the Perl tradition used in that code.
07:57:55 <autrijus> and indeed it can use it, but then the remaining computation in the one-level-up reset is still run
07:58:06 <autrijus> oh. thanks :)
07:58:36 <autrijus> so it results in the one-level-up code "returned" twice.
07:58:36 <shapr> It's hard to find something equally classic and geeky to quote from.
07:59:09 <autrijus> yeah and we can crack "the Return of the Monad" jokes
07:59:14 * shapr ouches
07:59:23 <shapr> Wow, that's a good one.
08:01:22 <Lunar^> shapr: Did you read the one that was one my blog few weeks ago ?
08:01:36 <shapr> I don't remember it, I'll look.
08:02:48 <Lunar^> shapr: from Knuth\
08:03:00 <shapr> Oh yes! I *love* that quote.
08:03:14 <Lunar^> :)
08:03:23 <autrijus> mm the code from "a monadic framework for subcontinuations" is apparnetly not available online.
08:03:25 <Lemmih> Paste?
08:03:50 <autrijus> [R Kent Dybvig; Simon Peyton Jones; Amr Sabry] -- to which one should I ask for code?
08:03:55 <autrijus> (they are listed as co-authors)
08:04:31 <shapr> I've gotten responses from SPJ, usually only a few days of delay. Haven't emailed the other two.
08:05:55 <shapr> Sometimes getting working code from research paper authors requires a crowbar. I wish they'd keep it on a website somewhere.
08:08:01 <shapr> Lemmih: The hardest thing is to go to sleep at night, when there are so many urgent things needing to be done. A huge gap exists between what we know is possible with today's machines and what we have so far been able to finish -- Donald Knuth
08:08:27 <esap> that quote is so true.
08:08:58 <shapr> I have trouble sleeping because I want to do so many things that are worthwhile, and just take time.
08:09:38 <shapr> Learning, teaching, reading, writing, organizing, disorganizing, clarifying and confusing :-)
08:09:57 <shapr> Oh speaking of which...
08:10:04 <shapr> EuroHaskell!
08:11:12 <autrijus> oh wait. it's only the Scheme code which is not available.
08:11:29 <autrijus> the paper comes with a haskell implementation.
08:11:43 <autrijus> but there's no transformer for it.
08:11:44 * autrijus works on it
08:14:20 <basti_> VA CA TION!
08:14:34 <xerox> Lucky boy!
08:14:39 <Oejet> How do I use unboxed integers with GHC?
08:14:57 <Oejet> I want to do "ack :: Int# -> Int# -> Int#".
08:15:18 <Igloo> Are you sure GHC's optimiser won't do that for you if you write In -> Int -> Int?
08:15:48 <Oejet> No, I'm not shure.  That's the point, Igloo.
08:15:49 <shapr> Igloo: Is there a list TH changes between 6.2 and 6.4?
08:16:10 <Igloo> Well you can use -ddump-simpl to look at the generated code to see if things are being unboxed
08:16:33 <Igloo> You'd need to ask a more specific question if you do want to write code using unboxed ints
08:16:39 <Igloo> Not that I can think of, shapr
08:17:37 <Oejet> How do I enable options in the file?  This does not work: {- OPTIONS -fglasgow-exts -}.  Can't find it in the GHC manual.
08:18:08 <Igloo> What version of GHC? It got changed to OPTIONS_GHC I think
08:18:16 <Igloo> Oh, {-# ... #-}
08:18:21 <Oejet> 6.2.1
08:18:26 <Igloo> To specify a pragma rather than a comment
08:18:27 <Oejet> Ah.
08:18:38 <Oejet> Thanks.
08:19:11 <shapr> Igloo: can I scrub it out of the changelogs or some other centralized spot?
08:19:53 <shapr> I guess I could just see if all the demos on http://www.haskell.org/hawiki/TemplateHaskell work, and fix them if they don't.
08:20:28 <shapr> I predict a flurry of TH emails on the list in the next week as I write my TH intro for The Monad.Reader.
08:20:50 <Igloo> That would be good  :-)
08:21:09 <shapr> The intro? or the flurry of emails?
08:21:58 <Igloo> I meant the flurry of emails, but both  :-)
08:22:08 <shapr> Ok, cool :-)
08:22:33 <Oejet> Igloo: I guess a type of GHC.Prim.Int# -> ... means that it is unboxed.
08:22:44 <Igloo> Yup
08:24:07 <shapr> Alistair Bayley is proposing a series of articles in The Monad.Reader called <quote> "Thinking in Haskell - an introduction for the Java/C# programmer" (ie. Haskell noobs who've had their brains perverted by 5-10 years of imperative, mutable-state, inheritance-oriented programming) </quote>
08:24:28 <shapr> He includes himself in that category :-)
08:25:39 <araujo> hah
08:25:51 <basti_> shapr: did you read what i msgd you yesterday night?
08:25:58 <araujo> ...with the two worse languages for it.."
08:26:16 <shapr> basti_: Yes, about a fixed older version of Haskore online?
08:26:26 <basti_> ...that i plan to put online.,
08:26:39 <shapr> Sounds good to me.
08:27:12 <basti_> k
08:27:40 <shapr> If you fix up a version, I'm sure I can get it online to go with TMR1
08:27:58 <shapr> Gee, I should email Fritz Ruehr and ask for a Monad.Reader logo.
08:28:16 <basti_> well i can put it on my homepage too for now
08:28:44 <shapr> That's the best option before issue publication.
08:28:47 <toomasr> where should i wait/check for that alistair bayley proposed series of articles?
08:29:06 <shapr> toomasr: It'll be in The Monad.Reader, the monthly haskell eZine.
08:29:57 <shapr> I don't have an url for The Monad.Reader yet, but it'll be somewhere on haskell.org
08:30:25 <toomasr> Monad.Reader is not yet online or you just don't have the url?
08:30:59 <shapr> The first issue will come out on march 1st
08:31:05 <shapr> Assuming everything works :-)
08:31:23 <toomasr> oh, i'll make a note to my calendar
08:31:59 <shapr> Since I'm the editor and disorganizer, you can bug me if you need anymore info.
08:33:18 <shapr> So far it looks like we'll have eight or nine articles.
08:33:34 <shapr> Maybe more, maybe less.
08:34:03 <toomasr> the eZine will be free of charge or have to pay for it?
08:34:10 <shapr> it'll be free.
08:34:15 <toomasr> wow, cool
08:34:47 <shapr> Of course, the editor (me) will try to get you to write an article if you start using Haskell :-)
08:35:18 <toomasr> well for that i'll be needing couple of years of exp
08:35:19 <shapr> This is the wiki page with info so far - http://www.haskell.org/hawiki/TheMonadReader
08:35:19 <syntax_syntax> how long are your passwords?
08:35:46 <toomasr> ~10 chars
08:36:05 <shapr> toomasr: If you write about something that you enjoy, it's a lot easier than you might expect.
08:36:20 <syntax_syntax> I'm thinking of upgrading from 6-ish to 12-15-ish.
08:38:03 <shapr> esap: hey do you have a moment?
08:38:03 <sh10151> i use public-key where possible
08:38:11 <toomasr> shapr: yeah, and i've discovered that when you write about something that you know & enjoy, you even discover new things
08:38:15 <syntax_syntax> public-key?
08:38:34 <syntax_syntax> I never really understood how key pairs work. But I never looked too hard into it either, I have no use for encryption
08:38:48 <shapr> wait till you see ssh-agent
08:39:26 <shapr> I also use public instead of passwords.
08:40:31 <toomasr> using darcs ssh repos without ssh-agent would be PITA
08:40:43 <syntax_syntax> I understand how public/private keys can be useful for authenticating messages, for instance.
08:40:56 <syntax_syntax> My private key is needed to sign a message, the public key to verify it.
08:41:11 <syntax_syntax> But how would public keys replace passwords?
08:41:17 <shapr> toomasr: The next version of ssh will have ssh -M (master I think?) that will allow you to reuse a single ssh connection.
08:41:23 <shapr> dons told me about that recently.
08:41:46 <toomasr> wow, will make life easier
08:42:19 <shapr> Yeah, I can barely wait. Setup and teardown of a connection can be expensive when there's crypto involved.
08:42:41 <sh10151> syntax_syntax: challenge/response using the keypair encryption
08:42:47 <Philippa_> shapr: any chance of getting Alistair Bayley in here?
08:43:00 <Philippa_> I owe him a mild apology for not pointing him at the Flippi darcs parsing code
08:43:01 <syntax_syntax> sh10151 uh?
08:43:46 <sh10151> server has the client's public key. server uses the client's public key to encrypt a challenge. the challenge can only be decrypted by use of the client's private key
08:43:46 <shapr> syntax_syntax: Public keys can be freely distributed. I scp my ssh2.pub from here to remote_host:.ssh/authorized_keys
08:44:20 <syntax_syntax> shapr hmm. ok. so?
08:44:22 <shapr> Philippa_: probably not, he sounds like a complete workaholic, and I get the impression he's at IT guy at a big investment company.
08:44:39 <sh10151> the best part is it's all built into ssh :)
08:44:57 <shapr> syntax_syntax: so, like sh10151 said, the server encrypts the challenge with the public key, no one except the holder of the private key can decrypt it.
08:44:58 <syntax_syntax> sh10151 ohh
08:45:08 <shapr> hoi boegel
08:45:29 <boegel> hey shapr
08:45:36 <shapr> Philippa_: but maybe I'm wrong, I'll invite him to show up.
08:45:50 <syntax_syntax> I can see how that's safer, but it's also less convenient.
08:46:14 <shapr> I know he works together with Oleg, so I'm not totally convinced I'll be able to keep up with him realtime.
08:47:19 <shapr> How less convenient?
08:47:24 <sh10151> it's actually more convenient, aside from the onetime setup of putting the public key on the server
08:47:44 <syntax_syntax> I have to lug around my private key file to every terminal I want to connect from.
08:47:46 <sh10151> because then you don't need to type in a password, or if you do, it's the passphrase protecting your private key
08:48:09 <sh10151> aah. i'm not in a job where I change client machines much
08:48:12 <syntax_syntax> Sticks and stones can break my bones, but thumb drives with private keys can be stolen by a burglar.
08:48:20 <Lor> Soon portable memory cards will become ubiquitous, then it is easy to carry the key.
08:48:26 <syntax_syntax> I work in totally different _places_.
08:48:38 <Philippa_> syntax_syntax: I'm tempted to keep one (locked, naturally) on a USB stick or something
08:48:42 <Philippa_> right
08:48:44 <sh10151> you could password protect your private key
08:48:53 <shapr> Private keys are encrypted too, usually with a really big password. My private key passwords are chunks of poetry I wrote.
08:48:55 <Lor> It would be silly not to.
08:49:02 <syntax_syntax> I don't have USB interfaces on all the computers I use in different places.
08:49:22 <Lor> Floppies, then?
08:49:24 <shapr> My gpg and ssh keys are my identity.
08:49:24 <syntax_syntax> all in all, a password is more convenient.
08:49:35 <sh10151> well, if you don't have the keypair set up, ssh falls back to password
08:49:40 <sh10151> that's what it's doing anyway :)
08:49:48 <Lor> Use one-time passwords. That is safe if anything.
08:49:54 <sh10151> mwah
08:49:55 <Lor> ...provided that you don't lose the list.
08:49:55 <syntax_syntax> I don't want to lug around physical media at all.
08:50:21 <Philippa_> yeah, fair enough
08:50:27 <shapr> Try using a time-based hash salted hash then.
08:50:33 <shapr> er..
08:50:39 <Lor> There are PDA programs where you can carry a one-time password list that is encrypted with another password.
08:51:21 <syntax_syntax> anyway, I don't have a "proper" ssh installation in this machine, just the putty client. how can I go about generating ssh keypairs to toy around?
08:51:27 <syntax_syntax> It's sunday, and I'm bored.
08:51:52 <sh10151> i don't remember how it works under putty
08:51:52 <shapr> I don't know if there's support for this... but I'd like to have a password system that lets me specify how to transform the date, IP, etc into a one time password.
08:52:22 <syntax_syntax> I'll google.
08:53:27 <syntax_syntax> oh, I need a program called puttygen. simple :-D
08:55:47 <syntax_syntax> not that I trust the security in a windows computer to keep my private key safe from an interested haxx0r, but I don't have much anyone could be interested in anyway.
08:57:26 <toomasr> except your private key
08:58:03 <syntax_syntax> with which I'll access a buddy's gentoo box.
08:58:28 <shapr> If you join the web of trust that comes from signed keys, your key is central to your identity.
08:58:34 <syntax_syntax> and i only have an account there because (a) I like a linux-ish environment, but I'm forced to have windows and (b) I work from many different places.
08:58:52 <syntax_syntax> shapr that's something I never understood. the web'o'trust.
08:59:18 <syntax_syntax> anyway, I mostly communicate with normals, people who'll see my name online and think it's me.
08:59:37 <syntax_syntax> There's no way I'm ever talking someone into getting and understanding pgp/gpg/whatever is cool these days.
09:00:20 <shapr> Hm, what's the site that shows connections online? Logjam or something?
09:00:38 <syntax_syntax> netstat -a?
09:00:47 <sh10151> well, with all of the phishing and spam and crap, more people might show an interest in pgp/gpg
09:01:11 <syntax_syntax> sh10151 they do understand one thing about ssl: the "locked" icon.
09:01:14 <sh10151> kind of like how nowadays everyone has locks on their doors
09:01:23 <syntax_syntax> if the "lock" icon is locked, then they access the bank.
09:01:28 <xerox> What about canadian? <grin>
09:01:35 <syntax_syntax> and it's the only thing they care about security-wise anyway.
09:01:41 <sh10151> too bad it is taking them to bank0ne.com
09:01:50 <sh10151> :)
09:01:52 <syntax_syntax> I'm very tempted to save my private key unencrypted.
09:02:03 <sh10151> my private key at work is unencrypted
09:02:18 <sh10151> because I primarily use it to not have to authenticate every time I access the cvs server
09:02:47 <sh10151> i'd probably be less cavalier if I cared about the web of trust
09:02:47 <syntax_syntax> an encrypted private key is no more convenient than an ordinary password
09:03:45 <Philippa_> you only have to type the password once
09:05:45 <sh10151> and you only need to know one password
09:06:11 <sh10151> instead of n passwords on remote systems, most of which may be the same but perhaps not due to expirations
09:06:17 <shapr> This is my biglumber entry - http://www.biglumber.com/x/web?qs=40620E18 Does anyone else here have a key I can try to trace to?
09:06:39 <shapr> Someone who is in the web of trust, but not one of my immediate neighbors?
09:06:46 <syntax_syntax> I use one password for most useless stuff (orkut, msn messenger, etc.), another password for semi-sensitive stuff (emails) and one for each bank account.
09:07:54 <sh10151> i always forget my %#$! bank account password and have to re-enter my info anyway
09:08:19 <Lor> You have constant passwords for bank stuff?
09:08:40 <Lor> Hereabouts all online bank services have always used one-time passwords.
09:09:30 <sh10151> how do they give you the list?
09:10:08 <shapr> A business-card-sized scratch-off thingy
09:10:08 <Lor> They mail a new one when the old one only has a couple of passwords left.
09:10:15 <Lor> (Yes, stupid.)
09:10:25 <Lor> They even cannot give it directly in person at the bank office.
09:10:42 <shapr> Constant passwords are far too easy to steal.
09:11:26 <sh10151> I have only done two online banking systems
09:11:30 <sh10151> but both have constant passwords
09:11:32 <syntax_syntax> hmm. banks here use constant passwords. I change them occasionally, yes.
09:11:35 <sh10151> the same with credit card
09:12:08 <shapr> web of trust, start with me - http://keyserver.kjsl.com/pks/lookup?op=vindex&fingerprint=on&search=0x40620E18
09:12:21 <shapr> then click on Ganesh Sittampalam (aka Heffalump )
09:13:09 <shapr> Heffalump signed my key after comparing my passport to my face at ICFP03.
09:13:24 <shapr> So he's saying that he's relatively sure I am who I say I am.
09:13:53 <shapr> I reciprocally sign his key, saying the same thing.
09:14:03 <jadrian> conditional folds...
09:14:12 <jadrian> why aren't they common?
09:14:31 <syntax_syntax> hmm.
09:14:44 <jadrian> for instance, in lists it would be a foldUntil
09:14:59 <syntax_syntax> doesn't seem to work. is there anything else I need to know besides putting my public key in the server's ~/.ssh/authorized_keys?
09:15:12 <jadrian> that may stop under a certain condition
09:15:20 <jadrian> for trees it would be more elaborate
09:15:53 <jadrian> it would just go down a branch if a condition is satisfied
09:16:12 <jadrian> I keep needing this stuff mostyly in mapAccums
09:16:29 <shapr> syntax_syntax: you need to tell your ssh client about your private key.
09:16:33 <jadrian> brb
09:16:41 <syntax_syntax> shapr yes. my ssh client knows that.
09:16:53 <syntax_syntax> I get Server refused our key
09:18:49 <shapr> I dunno, doesn't sound right.
09:19:14 <sh10151> syntax_syntax: the server could be configured with PubkeyAuthentication off
09:19:17 <sh10151> but that's not default
09:19:30 <syntax_syntax> hmm. I'll talk to the owner of the machine later.
09:19:54 <boegel> hey people
09:20:00 <boegel> I need some inspritation
09:20:10 <sh10151> other possibility is the format outputted by the putty system is not the same as the ssh daemon expects in authorized_keys
09:20:17 <sh10151> i had that issue with f-secure ssh
09:20:19 <boegel> I'm re-designing my website, and I need a title for a category
09:20:29 <boegel> I have 'home, persona, links and contact'
09:20:43 <boegel> and now I want a title to represent cs related stuff
09:21:11 <boegel> 'cs related' seems kind of stupid, 'various' is to abstract... does anyone have any suggestions ?
09:21:40 <shapr> Geeky stuff?
09:22:16 <shapr> "On the Essence of Meaning" "Notions of Computation" "Flippin' Bits"
09:23:23 <boegel> shapr: I like the first one, but maybe it should look a bit more 'professional'
09:23:25 <shapr> "Under the Keyboard" "There and Hack Again" "Quantum, It's Cool."
09:23:42 <boegel> what about 'bits & bytes'
09:24:12 <shapr> Sure, if you like it.
09:24:25 <sh10151> "A Prolegomena to Any Future Metaprogramming"
09:24:59 * shapr asks lambdabot what that word means.
09:26:16 <shapr> oh, an introduction.
09:27:22 <sh10151> an enquiry concerning computer understanding
09:27:36 <sh10151> computers within the limits of reason alone
09:27:57 <sh10151> Discipline & Punish / The birth of PASCAL
09:28:14 <shapr> Sadomasochism, the Art of Assembly Programming.
09:28:45 <shapr> boegel: Are you feeling inspired yet?
09:28:49 * xerox goes getting some latex ...
09:29:01 <desrt> "she was into S&M and bible studies, not everyone's cup of tea..."
09:29:01 * shapr grins
09:30:22 <xerox> We're all waiting for a note about Haskell..
09:30:35 * shapr passes notes in class
09:30:50 <shapr> eek, I got scary ghc compile messages about bad eta expansion.
09:31:19 <xerox> Does eta expansion has something in common with points-free code?
09:31:29 <xerox> (It was eta-reduction, right?)
09:31:29 <shapr> I don't remember.
09:31:34 <Igloo> They're ignorable I believe
09:32:24 <Lor> if point-free code means lambdaless code, then yes, since eta reduction gets rid of lambdas.
09:33:06 <basti_> lambdaless? like combinators?
09:42:42 <boegel> shapr: bits and bytes it is I think :)
09:42:46 <shapr> ok
09:43:04 * Philippa_ keeps wanting to point out to folks who slag off langs with strong type systems as "B&D" languages that BDSM is often an incredibly liberating experience...
09:43:07 <shapr> esap: fp data producer - type with constructors, fp data consumer - function with pattern matching, oo data producer - class (with constructors), oo data consumer - ?
09:43:38 <Philippa_> a class that knows of some object it grabs data from
09:43:51 <Philippa_> or the class's methods, if you prefer
09:43:55 <shapr> visitor?
09:44:01 <Philippa_> visitor's too specific
09:44:08 * wli guffaws.
09:44:10 <Philippa_> taking the class's methods as the consumer works well, mind
09:44:27 <Philippa_> you can go for the whole "it's a coalgebra!" thing
09:44:29 <shapr> yeah, hm.
09:44:54 <Philippa_> wli: the BDSM thing? There's a reason my column's to be called "Impure Thoughts" :-)
09:45:26 <xerox> Every time I reach this buffer I have to check that it's not #sex or so..
09:45:37 <xerox> (Just yoday, in fact :P)
09:45:38 * shapr grins
09:45:41 <xerox> *today
09:46:30 <Philippa_> I have to admit, there's far less homoerotica in here than I'm used to in a coding chan
09:46:53 <Philippa_> (fine by me, it means they're too busy to try hitting on me)
09:47:34 <wli> I've got enough trouble trying to keep one woman happy.
09:48:23 <Philippa_> yeah, it's mostly the horny teenagers I have to keep at bay. Easy enough until you run across a latent submissive...
09:48:35 <shapr> Same here.
09:49:03 <Philippa_> which of us're you replying to? :-)
09:49:24 <shapr> Anyway, a "Thinking in Haskell" series sounds great.
09:49:36 <Philippa_> hrmm. Yes and no
09:49:52 <Philippa_> it should possibly have a Thinking in DSLs counterpart?
09:50:12 <shapr> If someone wants to volunteer.
09:50:21 <shapr> Oh hey, I was thinking about your article today...
09:50:39 <Philippa_> yeah?
09:50:46 <Philippa_> I need to get round to finishing it off, certainly
09:51:02 <shapr> I remember reading that an optimizing compiler could recompile itself and the efficiency would improve through several cycles of that.
09:51:17 <Lor> Hey, is anyone coming to ICFP this year?
09:51:28 <xerox> Where will it be?
09:51:31 <Lor> shapr, huh?
09:51:34 <Lor> xerox, tallinn.
09:51:42 <xerox> Hmpf.
09:51:55 <shapr> I was wondering if you could do the same sort of thing with your TH compiler.
09:52:00 * Heffalump is reasonably likely to come
09:52:20 <Philippa_> no, because you don't really compile it separately and because the compiler's not written in the language it compiles
09:52:23 <shapr> I guess it'd be just like applying optimization passes repeatedly.
09:52:30 <Lor> Huh? No.
09:52:44 <Lor> The result from a compiler is the same no matter how fast the compiler is.
09:53:05 <Lor> Optimizing the compiler doesn't change its output.
09:53:18 <sorje> (but its speed)
09:55:08 <shapr> Hm, I see.
09:57:33 <Philippa_> Lor: I didn't think shapr meant that
09:57:58 <Philippa_> anyway, film time
09:58:04 <basti_> Calister: !
09:58:11 <shapr> hiya Calister!
09:58:14 * Calister waves hello
09:58:17 <Calister> :)
09:58:46 <Calister> heya all :)
09:58:51 <shapr> Lor: I was talking about iterative compiles producing a more efficient compier.
09:59:41 <Philippa_> 'lo Calister, 'fraid I'm off
09:59:46 <Calister> lol
09:59:52 <Calister> heya and bye Philippa :)
10:00:47 <Lor> I still don't see why that would be the case.
10:01:18 <Lor> You'd need some iterative process that made the compiler's optimizers _smarter_, not faster.
10:01:23 <shapr> I think because optimization passes are rarely (never?) exhaustively applied.
10:04:15 <shapr> Lor: I dunno, I just read this somewhere and was trying to figure out whether it might be true or not.
10:07:17 <basti_> anyone know how i crop (or translate & then crop, where i could do the crop part myself) ps files? preferably with ps2ps?
10:07:47 <shapr> Calister: how's code?
10:08:28 <shapr> basti_: Lor told me that gv can tell the bounding box, is that what you mean?
10:08:40 <basti_> well approximately.
10:08:55 <basti_> i dont want to KNOW the bounding box, i want to restrict the page i have to a certain bounding box.
10:09:13 <basti_> It's about my graphics. screenshot to gif + \includegraphics works but is ugly.
10:10:06 <Calister> shapr.. deadly :s wanna take my exam on wednesday?
10:10:38 <Lor> I don't know of any way to crop ps files.
10:10:43 <Lor> I would really like it myself, too.
10:10:48 * basti_ -hate-
10:11:06 <basti_> would i need to get down and write a perl script or what?
10:12:07 <basti_> ps2ps clips to the page size. I'd just need a translation.
10:12:31 <Lor> What are you doing?
10:12:51 <Lor> Huh, ps2ps clips?
10:12:57 <basti_> writing an article for TMR.
10:13:03 <Lor> But doesn't ps2ps convert it to bitmap?
10:13:04 <basti_> Its supposed to, i think.
10:13:13 <basti_> it does?
10:13:14 <basti_> o0
10:13:30 <Lor> ps2ps converts from postscript level 2 or 3 to level 1.
10:13:32 <Lor> Usually.
10:13:47 <basti_> ugh
10:14:00 <Lor> Are you sure you don't mean pstops?
10:14:18 <basti_> im sure i dont want to do THAT.
10:14:39 <basti_> http://perlmonks.thepen.com/10635.html < this mentions crop-ps
10:17:07 <Lor> Hmm.
10:18:11 <Oejet> shapr: Without some genetic programming I don't see how that could be possible.
10:18:59 * Oejet didn't notice the scrollbar had moved so far.
10:19:28 <Oejet> Doh.
10:19:37 * shapr subtly pushes Oejet's scrollbar up more.
10:20:07 <Oejet> shapr: You are wicked 3v1l, man.
10:20:12 * shapr snickers
10:20:13 <Oejet> :-P
10:20:46 <shapr> Oejet: you mean the template haskell + profiling + genetic algorithm thingy?
10:24:51 <basti_> at least this perl script seems to do something
10:25:36 <Oejet> shapr: No, the selfoptimizing compiler.
10:48:57 <basti_> Lor: this perl script does a good job when you whack away the "-" in it...
10:49:21 <Lor> All right.
10:49:41 <Lor> I have a script that uses pstops to arrange four pages optimally on one page.
10:50:19 <basti_> ugh -g-
10:50:33 <Lor> I give it the coordinates of the visible text area in a page, and it figures out the right way to place the pages so they fit. It also makes sure there is some extra margin on alternating sides (for two-sided printing).
10:50:57 <Lor> Sometimes footers, headers and page numbers are annoying, though, and it would be neat to be able to crop them out.
10:51:44 <shapr> hiya johs
11:21:14 <jadrian> what is the term for substituting a ter by its definition in some expression?
11:21:19 <jadrian> s/ter/term
11:21:26 <jadrian> "unroll"?
11:21:38 <shapr> substitution?
11:21:56 <jadrian> I think there is a specific term in the context of refactoring
11:22:04 <shapr> oh
11:22:26 <shapr> inlining ?
11:22:28 <jadrian> sorry I didn't said that was the context when I asked :)
11:22:35 <jadrian> shapr: yes I think that's it
11:22:39 <jadrian> thanks!
11:22:48 <jadrian> now I just need a portuguese translation...
11:22:50 <jadrian> eh :-/
12:09:50 <wnoise> I think for Haskell syntax highlighting, I'd want it to be very light.  Hilighting functions, f'rex, doesn't tell me much.  Maybe highlighting IO or other monadic values would help.  Or highlighting different arities differently.  I could see that helping.
12:13:17 <Lemmih> wnoise: I'm sure every haskell-mode is willing to accept patches.
12:21:41 <wnoise> Eh.  I care enough to whine, but not enough to fix.
12:22:16 <musasabi> How would I process a list with a monadic operation discarding all nodes which throw an exception?
12:22:40 <musasabi> foobar :: (a -> IO b) -> [a] -> IO b
12:23:22 <Lor> What should the return value be?
12:23:37 <Oejet> Don't you mean: foobar :: (a -> IO b) -> [a] -> IO [b] ?
12:23:38 <musasabi> sorry IO [b]
12:24:00 <musasabi> like mapM but discard all the values where an exception is thrown.
12:24:24 <Heffalump> make sure your a -> IO b operation fully evaluates its argument, though
12:24:36 <Lemmih> Return Nothing on an exception and filter them out later?
12:25:03 * jadrian hates tuples and lists :-/
12:25:19 <Lemmih> jadrian: How come?
12:25:41 <jadrian> so I have one function f that works over a list xs
12:25:52 <jadrian> and a function g that works over a list ys
12:26:14 <jadrian> I want to merge some code, so I end up having to build a list of pairs
12:26:14 <musasabi> hmm that could work..
12:26:30 <jadrian> so what I get is  zip xs ys
12:26:35 <jadrian> not a problem
12:26:56 <jadrian> I unzip  xs_ys list, and apply f and g
12:27:53 <jadrian> now lets continue
12:28:02 <jadrian> lets merge more code
12:28:32 <jadrian> on the first merge I produced the pairs with
12:28:38 <Lemmih> Maybe you should refactor instead of merging?
12:28:40 <jadrian> producer1 &&& producer2
12:28:55 <jadrian> merging is refactoring :)
12:29:05 <jadrian> it's simple stuff
12:29:17 <Lemmih> It sounds like you're making it more complex.
12:29:47 <jadrian> yes, that's what I'm saying it gets complex, but it's a simple issue
12:29:56 <jadrian> you have producers p1 p2 p3... pn
12:30:07 <jadrian> that work over some data d
12:30:29 <jadrian> and produce lists l1 l2 l3... ln
12:30:39 <jadrian> now instead of using them one at a time
12:31:02 <jadrian> you want them to produce the lists in parallel
12:31:14 <jadrian> it's actually pretty simple
12:31:28 <jadrian> you just end up with lists of tuples
12:31:45 <jadrian> you can even build those lists with
12:31:58 <jadrian> p1 &&& p2 &&& ... &&& pn
12:32:38 <jadrian> this way you'll get  [(...((p1,p2),..., pn)]
12:32:48 <jadrian> hmmm
12:33:32 <jadrian> ok so then unzip once
12:33:38 <jadrian> and you get
12:34:01 <jadrian> (p1, [((p2,p3)...pn)])
12:34:09 <jadrian> now how do you unzip twice?
12:34:25 <jadrian> you need to apply snd
12:34:36 <jadrian> and how do you unzip a 3rd time
12:34:46 <jadrian> need to apply snd twice...
12:35:03 <jadrian> unziping the stuff is the nasty bit
12:35:47 <jadrian> and I need to unzip it because my consumers need a list
12:38:03 <Lemmih> If you want help, maybe you should give a more concise explanation and/or post some code.
12:39:55 <jadrian> Lemmih: yeap you're right...
12:40:54 <jadrian> Lemmih: I'll give it a few more shots and if I don't do anything with it I'll strip it down to a simple example...
12:57:55 <dopegang> hi
12:58:01 <xerox> 'lo
12:58:35 <dopegang> hows life there?
12:59:01 <dopegang> is this about hacking? i need some advice.
12:59:03 <xerox> Strong typed I guess
12:59:06 <xerox> <grin>
12:59:29 <dopegang> i managed to download a password file on a sys full of exploits ;-)
12:59:48 <mattam> no, this is not about this kind of hacking
13:00:08 <dopegang> i can`t find any infos about getting the shaddow file, maybe i am stuck at a honeypot.
13:00:42 <dopegang> coz its a sys that is really interesting to speak of sources about exploits :-)
13:01:31 <dopegang> i mean i have found tools everywhere!
13:06:02 <humasect> o_O
13:06:21 <Calister> lol :x
13:09:54 * boegel boings
13:34:10 * boegel yawns
13:36:34 * Calister yawns too
13:36:46 <xerox> 'night folks
13:37:04 <Calister> g'nite xerox
13:40:39 <boegel> bye copier
13:40:42 <boegel> err, xerox
13:41:29 <boegel> hi anyone
13:41:31 <liquidengineer> afternoon
13:41:40 <liquidengineer> haskell error messages suck
13:41:42 <liquidengineer> a lot
13:41:42 <boegel> hey liquidengineer
13:41:47 <boegel> liquidengineer: no they don't
13:42:06 <Calister> hi boegel
13:42:21 <boegel> hi Calister
13:42:25 <liquidengineer> boegel: coming from Java, they're very ... obtuse
13:42:31 <Calister> and if they'd suck you wouldnt be able to tell cuz you wouldnt understand it :s
13:42:38 <liquidengineer> I mean, what does _this_ mean: Program error: {rPolyDivide testPoly1 testPoly
13:42:39 <Calister> they are just... cryptic ;D
13:42:52 <boegel> liquidengineer: I come from Java too... but I've known Haskell for over a year now
13:43:02 <liquidengineer> it's not working, thus I know there's an error
13:43:07 <boegel> liquidengineer: is that all it says ?
13:43:12 <liquidengineer> I need the interpreter to you know, maybe tell me what hte error is
13:43:13 <liquidengineer> yeah
13:43:19 <liquidengineer> there's a closing brace
13:43:41 <boegel> liquidengineer: what are you using ? ghc? hugs ? ghci ?
13:43:49 <liquidengineer> hugs
13:43:58 <boegel> liquidengineer: how big is your code ?
13:44:07 <Calister> i heard gci is better with error msgs
13:44:11 <liquidengineer> the polynomial division part?
13:44:21 <boegel> liquidengineer: the whole thing I guess
13:44:32 <boegel> or yeah, just the PolyDivide part
13:44:50 <liquidengineer> 52 lines
13:45:01 <boegel> @wiki HaskellIrcPastePage
13:45:02 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:45:18 <boegel> if it doesn't contain big secrets, post it on the wiki page above
13:45:21 <anyone> I go to #c and say, "I come from Haskell, I find C error messages to be very obtuse, 'segmentation fault', what does that mean?"
13:45:23 * anyone ducks
13:45:41 <Calister> lol
13:45:52 * boegel throws a shuriken at anyone and misses
13:45:53 <Calister> java can produce quite interesting error msgs too
13:46:00 <boegel> Calister: idd
13:46:04 <liquidengineer> borism: the big secret is that I hate this damned thing
13:46:06 <Calister> "error - no such error!"
13:46:20 <liquidengineer> I've spent the last 72 hours implementing polynomial arithmetic
13:46:26 * stepcut plays around with asterisk
13:46:27 <boegel> liquidengineer: yaay
13:46:35 <liquidengineer> how do I use this paste thing?
13:46:44 <liquidengineer> boegel: with rational coefficients, even
13:46:55 <liquidengineer> I've got everything working but division
13:46:56 <anyone> Yeah I want to look at the code too.
13:46:59 <boegel> liquidengineer: click the text balloon
13:47:03 <boegel> then you can edit the page
13:47:12 <anyone> You probably have a division by zero problem.
13:47:14 <stepcut> anyone: don't forget, "I missed a semicolon and got 100+ lines of weird error messages"
13:47:18 <boegel> use {{{#syntax-haskell and }}} to put your code into
13:48:16 <boegel> liquidengineer: I meant {{{!#syntax haskell
13:49:31 <liquidengineer> hmm
13:49:32 <liquidengineer> wait a minute
13:49:39 <liquidengineer> part of my logic is commented out
13:49:43 <liquidengineer> that could cause problems
13:49:57 <liquidengineer> though I would have appriciated a patttern matching error of some sort
13:50:16 <boegel> liquidengineer: it should produce such an error
13:50:39 <anyone> I believe ghci would give you exactly that.  Not sure about hugs.
13:51:58 <liquidengineer> okay
13:52:07 <liquidengineer> now I've got an unexpected '=' error
13:52:12 * liquidengineer tries to figure this out
13:52:13 <liquidengineer> bbiab
13:52:54 <liquidengineer> wierd
13:52:59 <liquidengineer> it's a let statement
13:53:02 <liquidengineer> three lines
13:53:06 <liquidengineer> can I paste in here?
13:53:20 <anyone> the paste page is better.
13:53:21 <liquidengineer> I don't really know that much about let yet
13:53:32 <anyone> probably an indentation problem
13:53:50 <anyone> On the paste page we will see the indentation more clearly
13:54:34 <liquidengineer> done
13:54:36 <liquidengineer> it's up
13:55:35 <liquidengineer> should I not have posted with '>'?
13:55:46 <liquidengineer> it doesn't seem to want to do syntax coloring with literate text
13:56:43 <anyone> '>' is fine.  But you see the indentation is mucked up.
13:56:56 <liquidengineer> yeah
13:56:59 <liquidengineer> had some tabs in there
13:57:02 <liquidengineer> replaced with spaces
13:57:12 <liquidengineer> now I'm getting an undifined identifier error
13:57:14 <liquidengineer> we're moving up
13:57:15 <liquidengineer> :P
13:57:25 <anyone> You must align revDividend with revDivisor
13:57:58 <anyone> and after that, 'in' aligned with either them or 'let'
13:58:18 <liquidengineer> done
13:58:22 <liquidengineer> now it's giving me this
13:58:33 <anyone> There are other examples of good indentation on the paste page.
13:58:50 <liquidengineer> ERROR /Users/jtdavis/Documents/Southwestern University/2005 Spring/Functional Programming/Assignments/Assignment 2/Davis#2.lhs:129 - Undefined variable "standardize"
13:59:09 <liquidengineer> standardize is a function
13:59:13 <Lemmih> Where did you define 'standardize'?
13:59:15 <liquidengineer> I'm staring at it
13:59:18 <liquidengineer> it's twenty lines up
13:59:23 <Lemmih> Paste it.
13:59:25 <liquidengineer> outside the let block
13:59:40 <anyone> I only see three lines.
13:59:53 <liquidengineer> excuse me
13:59:54 <liquidengineer> I'm a moron
14:00:03 <liquidengineer> standardize doesn't have > in front of its defintion
14:00:08 <liquidengineer> .....
14:00:17 <anyone> Put the '>'s back.
14:00:23 <liquidengineer> I just did
14:01:19 <basti_> back-o
14:01:24 <Lemmih> wb basti_.
14:01:31 <Calister> wb basti_
14:01:36 <Calister> I UNDERSTOOD IT!!!
14:01:43 <basti_> Calister: =)
14:02:36 <liquidengineer> okay
14:02:39 <liquidengineer> that's all fixed
14:02:51 <liquidengineer> thanks
14:02:52 <anyone> congrats
14:02:55 <liquidengineer> have a new problem, though
14:03:01 <boegel> liquidengineer: shoot !
14:03:09 <liquidengineer> I've got an undefined symbol happening
14:03:16 <liquidengineer> I'm going to stick the function in the pastebin
14:04:20 <liquidengineer> it says a is undefined
14:04:29 <humasect> ghc has good error messages
14:04:34 <anyone> Is it eatz?
14:04:50 <liquidengineer> yeah
14:04:52 <liquidengineer> eatz
14:05:02 <liquidengineer> Rat is an ordered pair of ints
14:05:05 <liquidengineer> represented as a tuple
14:05:06 <anyone> Look at this line again:  eatz (b:bs) = if (b==(0,a) ) then (eatz bs) else (b:bs)
14:05:17 <anyone> 'a' is rightfully undefined there.
14:05:38 <liquidengineer> I need a way to say that if the ordered pair has a zero in the first slot, then do the then stuff
14:05:45 <liquidengineer> I don't care what a is
14:05:54 <boegel> liquidengineer: then use _ in stead of a
14:06:03 <liquidengineer> just an underscore?
14:06:05 <boegel> jep
14:06:10 <anyone> No no no, it's more subtle than that.
14:06:10 <liquidengineer> what's it mean?
14:06:17 <humasect> cool =)
14:06:19 <boegel> 'any value'
14:06:25 <boegel> anyone: ?
14:06:42 <anyone> How do I edit what is already pasted?
14:07:08 <anyone> Namely I want to edit eatz to show you how to correct it.
14:07:42 <boegel> anyone: press the 'text dialog' at the top, and then scroll to the end in the text box
14:07:49 <liquidengineer> it is now saying that is an illegal _
14:08:21 <Lemmih> liquidengineer: You can't use _ as an variable. It's only for pattern matching.
14:08:35 <Lemmih> s/an/a/
14:09:01 <musasabi> case b of (0,_) -> ... or if fst b == 0 then ...
14:09:29 <Lemmih> liquidengineer: eatz ((0,_):bs) = ...
14:09:48 <liquidengineer> so what do I do?
14:09:55 <liquidengineer> I need it on the right side, not the left
14:10:07 <Lemmih> Following any kind of basic Haskell tutorial might be beneficial.
14:10:31 <Lemmih> liquidengineer: eatz (b:bs) = ... -- on the next line.
14:10:50 <liquidengineer> I'm taking a class on FP
14:10:54 <liquidengineer> we haven't gotten very far yet
14:11:13 <liquidengineer> on the next line?
14:11:16 <anyone> I have added the correction, please see.
14:11:19 <boegel> liquidengineer: then you should try fst b == 0
14:11:22 <boegel> @type fst
14:11:26 <lambdabot> fst :: forall a b. (a, b) -> a
14:13:22 <liquidengineer> anyone: ooh
14:13:28 <liquidengineer> this is your correction?
14:13:28 <liquidengineer> eatz (b:bs) = case b of (0,_) -> eatz bs
14:13:28 <liquidengineer>                           _ -> b:bs
14:13:55 <anyone> There are two ways.  I put my preferred way in '>'s.
14:14:51 <anyone> See the two lines before "Here is another way".
14:15:09 <liquidengineer> ah
14:15:25 <liquidengineer> and thta will do the same thing as my if/then was supposed to do?
14:15:31 <boegel> liquidengineer: yep
14:15:36 <liquidengineer> ah
14:15:38 <liquidengineer> neat
14:16:36 <boegel> hey Pseudonym
14:17:00 <Pseudonym> G'day.
14:18:00 <Lemmih> Has any of you used cmake with Haskell sources?
14:20:56 <liquidengineer> Could I trouble ya'll one more time?
14:21:03 <liquidengineer> it's giving me a pattern matching error now
14:21:14 <liquidengineer> I think it's a matter of improper parenthesis
14:21:16 <liquidengineer> but I'm not sure
14:21:36 <boegel> liquidengineer: show us the error :)
14:22:07 <liquidengineer> Expression     : revDividend rGetQuotient (revDivisor revDividend) revDivisor
14:22:07 <liquidengineer> *** Term           : revDividend
14:22:07 <liquidengineer> *** Type           : [Rat]
14:22:07 <liquidengineer> *** Does not match : a -> b -> c -> d
14:22:13 <liquidengineer> I put the code in the pastebin
14:24:11 <Lemmih> 'revDividend' takes a single list of Rats but you've giving it three arguments.
14:24:55 <liquidengineer> revDividend is a list of tuples
14:25:12 <Lemmih> Still only takes one argument.
14:25:21 <boegel> liquidengineer: try this: revDividend $ rGetQuotient (revDivisor revDividend) revDivisor
14:25:27 <liquidengineer> it isn't a function
14:25:32 <boegel> or revDividend (rGetQuotient (revDivisor revDividend) revDivisor)
14:25:52 <boegel> liquidengineer: it isn't a function ? then why do you give it arguments ?
14:26:09 <liquidengineer> I don't mean to
14:26:28 <boegel> then what do you want to do ?
14:26:45 <liquidengineer> okay
14:26:49 <liquidengineer> I need to return a tuple
14:27:17 <liquidengineer> the first in the pair is the result of rGetQuotient revDividend revDivisor
14:27:33 <liquidengineer> reversed
14:27:50 <boegel> reversed?
14:27:54 <boegel> it's a list then ?
14:28:05 <liquidengineer> yeah
14:28:12 <liquidengineer> revDividend and revDivisor are lists
14:28:35 <boegel> and what do you want to return ? a list of tuples ?
14:28:52 <liquidengineer> no
14:28:54 <liquidengineer> a tuple of lists
14:28:55 <liquidengineer> two lists
14:29:17 <boegel> (revDividend, rGetQuotient (revDivisor revDividend) revDivisor)
14:29:18 <boegel> like this ?
14:31:11 <liquidengineer> (reverse (rGetQuotient (revDivisor revDividend)), reverse(rGetRemainder (revDividend rGetQuotient (revDivisor revDividend) revDivisor)))
14:31:30 <liquidengineer> the first item in the pair is the result fo rGetQuotient on the lists revDivisor and revDividend, reversed
14:31:35 <boegel> bwaaah, that's kinda ugly for such a beautifel language :)
14:31:49 <liquidengineer> boegel: I barely know what I'm doing
14:31:52 <liquidengineer> bare with me, please. :)
14:32:26 <liquidengineer> maybe it would look better if I composed reverse with rGetQuotient
14:32:27 <liquidengineer> ?
14:32:37 <jadrian> is there some class tuple with generic projections?
14:32:48 <boegel> liquidengineer: try this
14:33:20 <boegel> let tempResult = rGetQuotient (revDivisior revDividend)
14:33:26 <basti_> shapr: i got latex to decently include lilypond examples now.
14:33:49 <boegel> (reverse tempResult, reverse getRemainder revDividend tempResult revDivisor)
14:34:11 <liquidengineer> boegel: I just thought of that....thanks. :D
14:34:21 <boegel> I'm going to bed
14:34:24 <boegel> g'night everyone
14:34:29 <liquidengineer> also, I'm using composition to cut down on the parenthesis of eye-crossing doom
14:34:41 <liquidengineer> thanks for your help\
14:34:49 <boegel> np
14:35:28 <wnoise> liquidengineer:  Why are you not using the builtin Rational?
14:36:21 <Calister> nite @ all
14:36:29 <basti_> n8 Calister
14:38:57 <liquidengineer> wnoise: because it's my job to implement the damn thing
14:39:15 <liquidengineer> polynomial division with rationals
14:40:53 <Remi> hi all
14:40:57 <Lemmih> Hey.
14:41:02 <Pseudonym> G'day.
14:41:16 <Pseudonym> Remi: I think the comment in the MonadPlus wiki page is wrong.
14:41:30 <Pseudonym> About IO not being a MonadPlus.
14:41:48 <Pseudonym> Or at the very least, it doesn't reflect the current debate adequately.
14:41:49 <Remi> *loads the wiki page*
14:41:57 <Pseudonym> Well I've changed the wording.
14:42:07 <Pseudonym> Do you think I expressed it too strongly?
14:42:40 <Remi> well, er, the thing is, I just don't know
14:42:44 * basti_ ponders darcs
14:42:54 <Pseudonym> That's the thing: nobody knows.
14:43:01 <Remi> I am planning to follow a course on Category Theory next year, but I'll first have to get my bachelor ;)
14:43:06 <liquidengineer> now I'm getting this
14:43:07 <liquidengineer> ERROR /Users/jtdavis/Documents/Southwestern University/2005 Spring/Functional Programming/Assignments/Assignment 2/Davis#2.lhs:132 - Type error in application
14:43:07 <liquidengineer> *** Expression     : revDivisor revDividend
14:43:07 <liquidengineer> *** Term           : revDivisor
14:43:07 <liquidengineer> *** Type           : [Rat]
14:43:08 <liquidengineer> *** Does not match : a -> b
14:43:12 <Pseudonym> The academics all say that m >> mzero == mzero
14:43:17 <liquidengineer> I've put my latest code at hte bottom of the paste thing
14:43:21 <Pseudonym> But very few MonadPlus instances actually obey it.
14:43:27 <Pseudonym> In particular, all bets are off if it
14:43:34 <Pseudonym> if it's a monad transformer.
14:43:55 <Lemmih> liquidengineer: Did you mean (revDivisor, revDividend)?
14:44:29 <Remi> I have recently been wondering wether MonadPlus should be split-up into a few typeclasses
14:44:44 <Pseudonym> Gofer used to have MonadZero.
14:45:04 <Remi> something like a MonadProduct typeclass which doesn't have any methods but requires m >> mzero == mzero
14:45:10 * Pseudonym nods
14:45:15 <Pseudonym> That's not a bad idea.
14:46:19 <Lemmih> liquidengineer: You should really try GHC.
14:46:58 <Remi> btw, IO doesn't satisfy law 2 either
14:47:45 <Pseudonym> DOesn't it?
14:47:48 <Pseudonym> Do you have an example?
14:48:51 <Heffalump> ignoring strictness?
14:49:07 <Pseudonym> Including strictness.
14:49:19 <liquidengineer> Lemmih: yeah
14:49:42 <Pseudonym> I want a k such that mzero >>= k /= mzero in IO.
14:49:45 <Remi> ahh, I'm most certainly just in dire need of coffee
14:49:53 <Remi> (except that I still think coffee is horrible)
14:50:15 <Heffalump> what's mzero in IO?
14:50:24 <Pseudonym> Remi: You're one of those condescending tea-drinking KDE users, aren't you?
14:50:42 * stepcut is a tea-drinking unofficial kde developer ;)
14:50:43 <Pseudonym> Heffalump: Let's say it's error "mzero"
14:50:48 <Pseudonym> :-)
14:50:57 <Remi> I'm running sawfish without gnome with an old gnome-panel right now
14:51:08 <Remi> and looking up what condescending means ;)
14:51:10 <Pseudonym> Ah, well.  You should be drinking coffee, then.
14:51:17 <Pseudonym> @wn condescending
14:51:23 <lambdabot> *** "condescending" wn "WordNet (r) 2.0"
14:51:23 <lambdabot> condescending
14:51:23 <lambdabot>      adj : (used of behavior or attitude) characteristic of those who
14:51:23 <lambdabot>            treat others with condescension [syn: {arch}, {patronizing},
14:51:23 <lambdabot>             {patronising}]
14:51:28 <Remi> ahh, zelfingenomen, well, that depends on the phase of the moon :)
14:51:32 <Pseudonym> Ah, that was helpful.
14:51:43 <Pseudonym> @wn patronizing
14:51:45 <lambdabot> *** "patronizing" wn "WordNet (r) 2.0"
14:51:45 <lambdabot> patronizing
14:51:45 <lambdabot>      adj : (used of behavior or attitude) characteristic of those who
14:51:45 <lambdabot>            treat others with condescension [syn: {arch}, {condescending
14:51:45 <lambdabot> ,
14:51:47 <lambdabot>             {patronising}]
14:51:48 <wnoise> liquidengineer: Okay.  Still seems silly to not be able to use the full facilities of the standard library.
14:51:51 <Pseudonym> Well.
14:51:54 <Pseudonym> Circular reasoning.
14:51:56 <Remi> mfix ;)
14:52:10 <Pseudonym> @wn condescension
14:52:12 <lambdabot> *** "condescension" wn "WordNet (r) 2.0"
14:52:12 <lambdabot> condescension
14:52:12 <lambdabot>      n 1: the trait of displaying arrogance by patronizing those
14:52:12 <lambdabot>           considered inferior [syn: {superciliousness}, {disdainfulness
14:52:12 <lambdabot> ]
14:52:14 <lambdabot>      2: a communication that indicates lack of respect by
14:52:14 <Pseudonym> There.
14:52:16 <lambdabot>         patronizing the recipient [syn: {disdain}, {patronage}]
14:52:19 <lambdabot>      3: affability to your inferiors and temporary disregard for
14:52:20 <lambdabot> [3 @more lines]
14:55:50 <Remi> *googles for MonadProduct*
14:56:48 <Remi> Did you mean: monoproduct : I'm being original today
15:01:10 <Remi> btw, does anyone know whether there is any reason why on http://www.haskell.org/hawiki/PreludeExts Rec is defined with `data' instead of `newtype'?
15:02:12 <Heffalump> can you define recursively defined datatypes with NewType?
15:02:58 <wnoise> I believe not.  You can make an alias for existing ones, of course.
15:03:01 <Heffalump> In fact you certainly don't want to in this case, because the _|_ value for that datatype is quite important.
15:03:50 <Heffalump> and, on an operational level, you need a tag that has to be explicitly deconstructed, I think
15:04:37 <Lemmih> wnoise: You can, actually.
15:05:16 <Remi> and it's defined as data Rec f = In !(f (Rec f)) (strict!!) anyway
15:05:38 <wnoise> Is your assignment "implement polynomial arithmetic over rationals", or explicitly "implement rationals, and then polynomial arithmetic over that"?
15:06:56 <Remi> err, are you asking me that?
15:07:15 <wnoise>  Sorry, liquidengineer.
15:07:30 <wnoise> Lemmih: what's the syntax then?
15:07:46 <Pseudonym> Remi: No idea.
15:08:05 <Pseudonym> It sounds to me like it should be a newtype.
15:08:51 <Remi> newtype Rec f = In (f (Rec f))
15:08:53 <Lemmih> wnoise: Just like with 'data', just without the strictness annotation.
15:12:50 <Remi> as to why you can: the problem with infinite types isn't the implementation, it's the bizarre type errors you can get (each time you'd get an "cannot construct the infinite type ..." now, the compiler would happily infer an infinite type and only die later). But that isn't a problem if one explicitly says "I want an infinite type" with a newtype
15:13:02 <Remi> (or so I heard ;)
15:14:22 <Pseudonym> RIght.
15:14:35 <Pseudonym> And it makes many programs which are obviously bugs type-correct.
15:19:01 <Heffalump> there's a difference between data with strictness annotations and newtypes
15:19:18 <Pseudonym> There's an operational difference.
15:19:25 <Pseudonym> But is there a semantic difference?
15:19:42 <Remi> not unless you profile your code AFAIK :)
15:19:45 <Pseudonym> (Ignoring existential types.)
15:20:27 <Remi> *thinks* what's the existential problem with newtypes then?
15:20:48 <Heffalump> well, you can write programs that can distinguish them
15:20:57 <Pseudonym> Heffalump: Such as?
15:21:06 <Pseudonym> Remi: Think about traditional OO programming.
15:21:17 <Pseudonym> An object, under the covers, is data + vtable.
15:21:33 <Pseudonym> In Haskell, that's data + type context.
15:21:39 <Heffalump> foo (Rec _) = "splat"
15:21:40 <Pseudonym> In a newtype, there's nowhere to put the type context.
15:21:50 <Heffalump> foo (error "bar")
15:21:56 <Remi> ahh, so you can't use existentials with newtypes?
15:21:56 <Heffalump> (not tried this)
15:22:03 <Remi> *tries*
15:22:07 <Pseudonym> Remi: Not sure.
15:22:21 <Pseudonym> But with my armchair implementor's hat on, I wouldn't allow it.
15:22:47 <liquidengineer> excuse me
15:22:48 <Remi> it would definitely make sense not to allow it
15:22:54 <liquidengineer> I'm still getting an error
15:23:00 <liquidengineer> type checking
15:23:05 <liquidengineer> would anyone mind helping me?
15:23:23 <syntax_syntax> it's better in the matinee
15:23:34 <syntax_syntax> is pesco = Sinesio Pesco?
15:23:57 <liquidengineer> I'm getting this error
15:24:07 <liquidengineer> ERROR /Users/jtdavis/Documents/Southwestern University/2005 Spring/Functional Programming/Assignments/Assignment 2/Davis#2.lhs:127 - Type error in application
15:24:07 <liquidengineer> *** Expression     : revDividend tempQ revDivisor
15:24:07 <liquidengineer> *** Term           : revDividend
15:24:07 <liquidengineer> *** Type           : [Rat]
15:24:07 <liquidengineer> *** Does not match : a -> b -> c
15:24:09 <Remi> newtype Foo = forall a. Show a => Foo a
15:24:09 <Remi> foo.hs:2: parse error on input `forall'
15:24:13 <liquidengineer> with the code I last put in the pastebin
15:24:24 <Heffalump> remi: you used -fglasgow-exts ?
15:24:25 <Remi> Pseudonym: and the Simons seem to agree with you ;)
15:24:27 <Remi> I did
15:24:40 <Remi> it does typecheck when s/newtype/data/
15:24:51 <Pseudonym> Heffalump: You're right about distinguishing them.  Hmmm.
15:25:08 <Heffalump> newtype is supposed to be just like type but with more helpful type checking properties
15:25:08 <Remi> is he?
15:25:11 <Pseudonym> But IMO the newtype has superior behaviour here.
15:25:27 <Remi> "<Heffalump> well, you can write programs that can distinguish them"
15:25:56 <Pseudonym> Yes.  His suggested program does indeed distinguish them.
15:26:08 <Remi> you can definitely write typecheckers which destinguish them, but programs?
15:26:30 <Remi> *slaps forehead* I should read before I type ^o)
15:31:16 <Remi> though I don't see yet why that would make a difference here
15:32:27 <liquidengineer> hello?
15:32:36 <basti_> goodnight =)
15:33:54 <liquidengineer> can anyone help me with my type error?
15:34:06 <Heffalump> remi: make a difference in what sense?
15:34:26 <Heffalump> liquidengineer: pasted where?
15:35:33 <wnoise> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:35:37 <liquidengineer> the paste wiki page
15:36:08 <Heffalump> there are several paste buckets people use :-)
15:36:28 <Heffalump> your final tuple is a clear type error
15:36:39 <Remi> well, the advantage of a newtype is that it doesn't exist at runtime, the difference is behaviour wrt undefined. So the question is, is newtypes bottom-behaviour harmful for banana-programmers?
15:36:42 <Heffalump> the (.) operator must return a function type, yet your type signature says the elements should be lists
15:36:44 <liquidengineer> Heffalump?
15:36:50 <liquidengineer> err...what?
15:37:09 <liquidengineer> It's giving me this
15:37:10 <liquidengineer> ERROR /Users/jtdavis/Documents/Southwestern University/2005 Spring/Functional Programming/Assignments/Assignment 2/Davis#2.lhs:129 - Type error in application
15:37:10 <liquidengineer> *** Expression     : revDivisor revDividend
15:37:10 <liquidengineer> *** Term           : revDivisor
15:37:10 <liquidengineer> *** Type           : [Rat]
15:37:11 <liquidengineer> *** Does not match : a -> b
15:37:56 <Heffalump> ah, another error
15:38:00 <Heffalump> stop trying to apply a list as a function
15:38:07 <liquidengineer> I don't mean to
15:38:32 <liquidengineer> revDivisor and revDividend need to be arguments to a function
15:38:46 <Heffalump> well, get your use of brackets right, then
15:38:58 <Heffalump> (try removing some)
15:39:03 <liquidengineer> I'm not using any brackets
15:39:06 <liquidengineer> only parenthesis
15:39:09 <Remi> yes
15:39:10 <liquidengineer> I have this now:
15:39:13 <liquidengineer> tempQ = rGetQuotient (revDivisor revDividend)
15:39:19 <Heffalump> ok, parenthesis then.
15:39:26 <Heffalump> try removing them.
15:39:27 <liquidengineer> rGetQuotient is the function I want to pass the two argument lists to
15:39:48 <Remi> then remove the parantheses
15:40:01 <liquidengineer> okay
15:40:03 <liquidengineer> did it
15:40:07 <liquidengineer> all fits on one line that way
15:40:12 <liquidengineer> getting new type error now
15:40:13 <liquidengineer> ERROR /Users/jtdavis/Documents/Southwestern University/2005 Spring/Functional Programming/Assignments/Assignment 2/Davis#2.lhs:127 - Type error in application
15:40:13 <liquidengineer> *** Expression     : revDividend tempQ revDivisor
15:40:13 <liquidengineer> *** Term           : revDividend
15:40:13 <liquidengineer> *** Type           : [Rat]
15:40:13 <Remi> (I assume you actually want to pass the standardized arguments to rGetQuotient)
15:40:14 <liquidengineer> *** Does not match : a -> b -> c
15:40:20 <liquidengineer> indeed
15:41:06 <Remi> rPolyDivide should return a pair of [Rat], yet the first returned value is "reverse . tempQ", which definitely isn't a [Rat]
15:42:06 <Remi> (instead, it's a function from something to a list, or more likely, just gibberish ;)
15:42:13 <liquidengineer> it is a rat
15:42:18 <liquidengineer> err... [Rat]
15:42:22 <liquidengineer> here's the signiture
15:42:23 <liquidengineer> >rGetQuotient :: [Rat] -> [Rat] -> [Rat]
15:42:28 <liquidengineer> it returns a list of Rat
15:42:50 <liquidengineer> tempQ is therefore a list of Rat
15:42:58 <liquidengineer> I want to reverse this list beore I send it to the tuple
15:43:08 <Remi> okay, try to add that signature inside the let .. in .. and see what type error it gives
15:43:30 <Remi> (adding type-signatures often helps to pin down where exactly the typechecker has a different opinion about types)
15:43:33 <liquidengineer> what do you mean?
15:43:38 <liquidengineer> the function is defined elsewhere
15:43:48 <liquidengineer> like, 20 lines us
15:43:49 <liquidengineer> up
15:44:39 <Remi> add a line (with the same indentation) "tempQ :: [Rat]" before the line where tempQ is defined
15:44:56 <Remi> (sorry my previous sentence didn't make 100% sense ;)
15:45:42 <SyntaxNinja> tmoertel: alive?
15:45:52 <liquidengineer> should I do that for revDivisor and revDividend too?
15:46:22 <Remi> it won't hurt, and you can always remove them once it typechecks if you want
15:46:26 <SyntaxNinja> tmoertel: nm
15:46:32 <liquidengineer> Remi: it's still giving the same error
15:47:53 <Remi> okay, it doesn't _always_ help. However, you now at least know that the compiler agrees with you about it's type. So what types do "reverse", "tempQ" and "(.)" have?
15:48:04 <liquidengineer> problems
15:48:26 <liquidengineer> wait a minute
15:48:34 <liquidengineer> you don't compose a list with a function, do you?
15:48:42 <Remi> exactly :)
15:48:58 <liquidengineer> you could have said that a bit ago?
15:48:58 <Remi> though you may wish to apply a function to a list
15:48:59 <liquidengineer> ;)
15:50:07 <Remi> of course, but - falling right in the middle of a it-doesn't-typecheck-talk - I'm not entirely sure whether I'm helping with homework or not ;) Besides, figuring it out yourself probably is a better learning-experience
15:50:19 <liquidengineer> it is
15:50:32 <liquidengineer> and it still doesn't typecheck. -_-
15:51:10 <liquidengineer> I just stuck the updated code in the pastebin I used earlier
15:51:39 <liquidengineer> I think the error is in this part
15:51:40 <liquidengineer> reverse . rGetRemainder (revDividend tempQ revDivisor)
15:51:51 <Remi> indeed
15:52:05 <liquidengineer> I know all three arguments to rGetRemainder are [Rat]
15:52:16 <liquidengineer> I explicitly made them that way, right?
15:52:20 <Remi> actually, it's probably a combination of the 2 previous errors this time
15:52:21 * Heffalump notes that he did say above that you can't compose things to make a list
15:52:55 <liquidengineer> Heffalump: I just want to reverse the result list that rGetRemainder gives me
15:52:59 <liquidengineer> is that so wrong?
15:53:00 <liquidengineer> ;)
15:53:10 * Remi gives Heffalump credit for spotting the error first
15:53:29 <liquidengineer> so I can't reverse a returned list like that?
15:53:51 <Remi> not like that..
15:53:56 <liquidengineer> hmm
15:54:06 <liquidengineer> so how does one reverse a returned list?
15:54:18 <Remi> <liquidengineer> tempQ = rGetQuotient (revDivisor revDividend)
15:54:22 <Remi> remember that one?
15:54:30 <liquidengineer> yeah
15:54:44 <liquidengineer> except I toook out the parens
15:54:51 <Heffalump> try using function application rather than composition
15:54:56 <Remi> you'll have to take them out once more
15:55:06 <liquidengineer> function application?
15:55:09 <Remi> function application in haskell is "f x y", not "f (x y)"
15:55:15 <liquidengineer> like, aoh
15:55:18 <liquidengineer> ....
15:55:19 <liquidengineer> oh
15:55:24 <liquidengineer> what's the diffference?
15:55:37 <Remi> huge
15:55:49 <Remi> f x y = (f x) y
15:55:50 <liquidengineer> (sorry, in Java f (x, y) was how you called a method.  old habits dying hard)
15:56:06 <Heffalump> that's a valid way of calling some functions in Haskell too
15:56:21 <Remi> you've taken the difficult path to enlightenment, falling is nothing to be ashamed of ;)
15:56:22 <Heffalump> but you can't just remove the commas and expect it to make sense
15:56:35 <liquidengineer> Heffalump: bummer. :)
15:56:39 <liquidengineer> okay
15:56:43 <liquidengineer> so I've changed it to this
15:57:02 <liquidengineer> reverse rGetRemainder (revDividend tempQ revDivisor)
15:57:12 <liquidengineer> so this should run rGetRemainder with the crap I want to run on it
15:57:16 <Remi> nope
15:57:16 <liquidengineer> then reverse that
15:57:17 <liquidengineer> right?
15:57:19 <liquidengineer> oh
15:57:22 <liquidengineer> grap
15:57:27 <liquidengineer> am I at least closer?
15:57:34 <Remi> you're giving reverse 2 arguments, which it isn't going to like
15:57:46 <liquidengineer> HMM
15:57:49 <liquidengineer> err..caps
15:58:06 <liquidengineer> reverse (rGetRemainder (revDividend tempQ revDivisor))
15:58:19 <Remi> function application isn't difficult, but it's rather totally different from languages like Java, so you probably want to read up how it works again
15:58:25 <Remi> indeed
15:58:29 <liquidengineer> I got it?
15:58:32 * liquidengineer falls over and dies
15:59:13 <Remi> I won't promise it works, but the two errors I saw in it are gone at least
15:59:17 <liquidengineer> do I need the parens around rGetRemainder's argumetns?
15:59:25 <liquidengineer> I'm thinking no
15:59:40 <wnoise> I think you do.  Try it :)
15:59:44 <Remi> err, sorry, I'm being dense: they aren't gone yet
15:59:58 <liquidengineer> no, they aren't
16:00:01 <liquidengineer> why aren't they gone?
16:00:02 <liquidengineer> :(
16:00:03 * Heffalump doesn't think function application is particularly different from Java, apart from that parentheses are usually optional and you can return a function result easily
16:00:44 <liquidengineer> I have this now
16:00:46 <liquidengineer> >                                    in (reverse tempQ, reverse (rGetRemainder (revDividend tempQ revDivisor)))
16:01:07 <wnoise> What is the type of rGetRemainder?
16:01:28 <liquidengineer> >rGetRemainder :: [Rat] -> [Rat] -> [Rat] -> [Rat]
16:01:34 <liquidengineer> take three, return one
16:01:37 <liquidengineer> list of Rats
16:02:26 <wnoise> Great.  Remove the parentheses.  As it is now, it's saying that rGetRemainder is a function of one argument, and revDividend takes two arguments, tempQ and revDivisor
16:02:40 <Remi> Heffalump: you may be right, in some sense the fact that f (x, y) is perfectly good haskell may even make it worse
16:03:17 <liquidengineer> revDividend is a list
16:03:24 <liquidengineer> it isn't supposed to take any argumetns at all
16:03:57 <wnoise> Right.  But parenthesizing it like that says "apply the second two arguments to revDividend"
16:04:29 <liquidengineer> oh
16:04:30 <liquidengineer> right
16:04:34 <liquidengineer> that's bizarre to me
16:04:49 <liquidengineer> >                                    in (reverse tempQ, reverse (rGetRemainder revDividend tempQ revDivisor))
16:04:58 <liquidengineer> am i closer now?
16:05:01 <Remi> well, "f x" means "apply f to x", so why would "(f x)" be any different?
16:05:26 <wnoise> You should be.  It's hard to tell whether it will work without seeing the rest of the code.  Try it.
16:06:04 <liquidengineer> my god
16:06:07 <liquidengineer> it compiled
16:06:10 <liquidengineer> I love all of you
16:06:29 <Remi> now, according to folk, it should also immediately be Bug Free(TM)
16:06:41 <Remi> folklore that should be in English I think
16:06:45 <liquidengineer> it compiles
16:06:54 <liquidengineer> that doesn't mean my divison algorithm actually works
16:07:13 <wnoise> No, that just means you get the bugs for free!  No extra price!
16:07:23 <wnoise> It is amazing how many it can catch though.
16:07:34 <liquidengineer> okay
16:07:36 <liquidengineer> it doesn't work at all
16:08:16 <Remi> especially when considering the signal-to-noise ratio in type errors compared to certain other languages
16:08:42 <liquidengineer> no
16:08:43 <liquidengineer> wait
16:08:44 <liquidengineer> it does work
16:08:53 <liquidengineer> I'm just not used to looking at polynomials this way
16:09:08 <wnoise> Write a function to express them more naturally.
16:09:40 <liquidengineer> I think I might
16:09:41 <liquidengineer> thanks, gusy
16:09:42 <liquidengineer> guys
16:14:15 <Remi> Heffalump: to return to Rec, do you know of any cases where the newtype Rec behaviour wrt undefined is a problem?
16:20:45 <Heffalump> I don't understand the theory well enough, but I suspect it could lead to odd behaviour
16:21:01 <Heffalump> you can pass an aliased type as the parameter, can't you?
16:21:31 <Heffalump> so type Id a = a
16:21:48 <Heffalump> what type is Rec Id , then?
16:23:20 <Remi> you can't
16:23:22 <Remi> data Rec f   = In (f (Rec f))
16:23:22 <Remi> type Id a = a
16:23:22 <Remi> type Foo = Rec Id
16:23:34 <Remi>     Type synonym `Id' should have 1 argument, but has been given 0
16:23:34 <Remi>     In the type: Rec Id
16:23:34 <Remi>     While checking the RHS of a type synonym declaration `Foo'
16:23:34 <Remi>     In the type synonym declaration for `Foo'
16:23:42 <Remi> changing the data into a newtype doesn't make any difference
16:24:12 <Remi> I suspect the reason you can't is that related to the reason haskell doesn't support type-level lambdas
16:25:20 <Heffalump> ok, newtype Id a = Id a
16:27:44 <Remi> *looks very hard*
16:28:17 <Remi> isn't that exactly the same as the old trick to simulate GHC's "data Foo" (without a RHS): newtype Foo = Foo Foo?
16:28:35 <Heffalump> oh, maybe
16:28:53 <Remi> except that it's now Abstracted Away Into Oblivion ;)
16:29:24 <Remi> (newtype Foo = Foo Foo is haskell's way to define a datatype with bottom as it's only inhabitant)
16:29:46 * Heffalump questions what the bottom value of that type is
16:30:11 * Remi isn't sure he understands the question
16:30:21 <Remi> "let x = Foo x in x"?
16:30:23 <Remi> undefined?
16:30:28 <Heffalump> hmm, ok
16:30:45 * Heffalump decides he doesn't really understand type theory at all and goes to bed instead
16:31:02 <Remi> that sounds like a good idea for me too (01:33 localtime)
16:31:29 <Remi> I'll add comment about the difference between strict-data and newtype to the Rec-definition tomorrow
16:32:58 <Remi> good night
16:34:55 <duncan_> remi: I think your "let x = Foo x in x" is undefined
16:35:09 <Pseudonym> Night.
16:35:10 <duncan_> since Foo _|_ = _|_
16:35:43 <Remi> it is
16:35:48 <Remi> supposed to be
16:36:16 <duncan_> if you used 'data' rather than 'newtype' then Foo _|_ /= _|_
16:36:57 <Heffalump> yeah, that's the root of my semantic worry
16:37:09 <duncan_> what's the worry?
16:37:12 <Heffalump> with data you get a chain of partially constructed bottoms
16:37:15 <Heffalump> with newtype you don't
16:37:18 <duncan_> right
16:37:50 <duncan_> it all has a perfectly ordinary domain-theoretic explanation :-)
16:38:04 <Heffalump> maybe to you :-)
16:38:17 * Heffalump 's knowledge of domain theory is somewhat lacking
16:38:34 <duncan_> I suffered through Samson Abramsky's domain theory classes
16:38:52 <Remi> I'll just add a comment tomorrow and let the Simons figure it out when they're looking at the wiki for haskell2 ideas ;)
16:39:29 <Heffalump> I don't need to know any domain theory in my nice down-to-earth bit of industry ;-)
16:40:13 <duncan_> :-) how's the C programming going?
16:40:59 <Heffalump> not bad. I found a reason to generate some C with Haskell last week, which was nice.
16:41:45 <Heffalump> anyway, bed really calls
16:41:48 <Heffalump> night
16:41:55 <duncan_> night
16:57:50 <Remi> *sleepy*
16:57:58 <Remi> night
17:56:40 <Spark> oops0r
20:15:27 <shapr> good morning #haskell!
20:16:43 <araujo> shapr, Evening!
20:16:43 <araujo> 8)
20:17:54 * shapr yawns
20:18:18 * araujo boings
20:20:45 * shapr hOps
20:21:10 <Pseudonym> G'day.
20:22:00 <shapr> g'day Pseudonym, what's up?
20:22:26 <Pseudonym> w*rk, sadly.
20:22:41 <Pseudonym> Yourself?
20:22:50 <shapr> yup, same thing.
20:23:02 <shapr> reading a cool book too
20:23:08 <Pseudonym> Oh?
20:23:25 <shapr> "Ship It" from the Pragmatic Programmers
20:23:28 <shapr> quite spiffy
20:25:59 <Pseudonym> Cool.
20:26:07 * Pseudonym is reading "New Foundations for Classical Mechanics"
20:26:40 <shapr> The book I'm reading is just about stuff you can do to get software to your customer in less time.
20:26:47 <shapr> I bet yours has a different goal.
20:26:51 <Pseudonym> Yes. :-)
20:26:56 <Pseudonym> Mine is a manifesto on geometric algebra.
20:28:08 <Pseudonym> So what sorts of things do TPP recommend?
20:28:22 <Pseudonym> 1. Don't read slashdot.
20:28:28 <Pseudonym> 2. No IRC.
20:28:54 <dons> hehe
20:29:35 <shapr> Well, "ship it" was originally "Pragmatic Projects" so it has a bunch of stuff like "use your source code management faithfully"
20:29:43 <Pseudonym> Right.
20:30:05 <shapr> The most useful part is the extremely clear explanations of what can happen if you don't do the things it recommends.
20:30:41 <shapr> "if your hard drive died right this instant, how much work would you lose? if it's more than a day of work, you need to use your SCM better."
20:31:10 <dons> SCM?
20:31:16 <shapr> source code management
20:31:21 <shapr> manager?
20:31:35 <anyone> schemer-converted MLer
20:31:44 <dons> yeah.
20:31:56 <dons> SCheme Mailinglist
20:32:07 <shapr> Anyway, I've been fighting to put everything we change into darcs so that we can instantly rebuild our projects, but I've gotten some opposition.
20:32:12 <anyone> Ha! Mailinglist is a good idea.
20:32:35 <dons> shapr: opposition?
20:32:40 <dons> on what grounds?
20:32:45 <anyone> You send all your code to the mailing list.  If your disk crashes you can retrieve your code back from the mailing list.
20:32:54 <Pseudonym> shapr: What do you use at the moment?
20:33:00 <shapr> Opposition on the grounds that it's an extra step that just wastes time.
20:33:03 <Pseudonym> (If anything.)
20:33:09 <anyone> This is also a reason why when people ask "what is a good editor" I reply "outlook express".
20:33:18 <shapr> I use darcs, most of the time.
20:33:46 <shapr> I try to always have a separate dev and production installation too, but that's not always possible.
20:34:27 <Pseudonym> When I said "you" I meant plural.
20:34:31 <anyone> People also oppose to proving programs correct because they think it's an extra step with no production.
20:34:34 <shapr> So it frustrates me when I make a change to a production server and the whole house of cards come down around me, and then everybody is upset at me.
20:34:48 <shapr> Pseudonym: yeah but it *is* me :-)
20:35:10 <Pseudonym> anyone: Proving programs correct just shifts the problem onto proving the formal statement of the requirements correct.
20:35:26 <Pseudonym> Debugging the proof is at least as hard as debugging the program.
20:35:41 <jemfinch> shapr: you in?
20:35:51 <shapr> We have maybe ten clients, and our company is just two people. I do the code.
20:35:53 * Pseudonym decides not to mention the recent scrapping over the semantics of mzero
20:35:57 <Pseudonym> Ah.
20:36:05 <jemfinch> shapr: I suppose you are :)
20:36:07 <anyone> Yes you are correct about the shifting.
20:36:14 <jemfinch> shapr: mind if I /msg you?
20:36:21 <shapr> what about?
20:36:32 <Pseudonym> Yes, tell us all!
20:36:35 <dons> Pseudyonym: according to Tobias Nipkow, Mr. Isabelle, the proofs for large systems are a factor of 10 times larger than the original system
20:36:37 * shapr looks suspiciously at jemfinch 
20:36:48 <jemfinch> shapr: about source control :)
20:36:48 <dons> Pseudonym: but at least we have some tools to help.
20:37:00 <shapr> Are you reading the logs or something?
20:37:08 <viirya> autrijus: ping
20:37:11 <shapr> jemfinch: why can't you ask me here? :-)
20:37:22 <anyone> dons is also correct, but most people interpret that fact wrong.
20:37:23 <jemfinch> shapr: well, it's sort-of off-topic.
20:37:39 <shapr> Well, what's the question?
20:37:50 <jemfinch> I was only going to note that after looking closely at the design/model of Darcs and Monotone, I've decided that I think Monotone has the better model.
20:37:57 <shapr> Ah, ok.
20:38:05 <Pseudonym> dons: I'd agree with that.
20:38:13 <anyone> The popular interepretation is "ah therefore proving is harder than programming".
20:38:17 <Pseudonym> But the problem isn't the proofs.
20:38:29 <Pseudonym> Proofs can be automated, or at least automatically checked.
20:38:45 <Pseudonym> The problem is: What are you proving?
20:39:04 <dons> yep. the proof exposes all the details you had glossed over
20:39:05 <Pseudonym> You're proving that the code does.. what, exactly?
20:39:24 <shapr> jemfinch: do you have separate dev and production installations?
20:39:38 <jemfinch> shapr: separate dev and production installations of what?
20:39:42 <anyone> The correct interpretation is this.  If you properly internal-document your code, explaining all the subtlties clearly, the internal-doc would be also 10 times as long as the code.  The proof is a better form of internal doc, since it is also checkable and unambiguous.
20:39:44 <shapr> of anything you work on
20:39:57 <dons> and proofs in Isabelle or Twelf are much like functional programming anyway.
20:40:02 <jemfinch> shapr: not usually, but I can stipulate.
20:40:32 <shapr> does that mean you develop on production code that's in use right now?
20:40:54 <jemfinch> shapr: well, I have an "official" Supybot repo and I develop on my laptop, which has a pulled copy of that repo.
20:41:04 <shapr> What about your paying work?
20:41:17 <jemfinch> same model.
20:41:27 <jemfinch> (I test my paid work on my laptop)
20:42:09 <shapr> Hm, I have maybe fifteen unique installations of zope/plone/custom code, I'm not sure if that's workable for me.
20:42:25 <jemfinch> shapr: if what's workable for you?
20:42:33 <dons> another confirmation of the 10-1 proof code ratio. An implementation of a mostly-System-F interpreter in Haskell is around 100-200 lines, sjw produced a Twelf proof of around 2000 lines
20:42:39 <jemfinch> shapr: I'm not yet understanding how you're connecting this line of questioning to my statement :)
20:42:40 <shapr> Keeping all my dev instances on my own box.
20:42:58 <shapr> Oh, it's not connected to your statement. If you think monotone is better, I'm happy for you :-)
20:43:22 <jemfinch> shapr: so why'd you bring that line of questioning up?
20:43:36 <shapr> I'm reading "Ship It" in the pragmatic programmers series and I'm trying to see how other people do things.
20:43:38 <Pseudonym> dons: Yeah, but that's an easy case.  System-F is, by definition, a formal model.
20:43:53 <shapr> In fact, I'm trying to improve the way I do things, but comparison to others is part of that.
20:43:55 <dons> yeah. only large example I had to hand ;)
20:44:29 <dons> I pity those whose foundation isn't formally defined to begin with. That's hard work.
20:44:39 <shapr> I pity the fool!
20:44:48 <jemfinch> shapr: oh, so this is unrelated :)
20:45:07 <Pseudonym> lambdabot: There you are!
20:45:07 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
20:45:16 <Pseudonym> @arr
20:45:16 <lambdabot> Arrr!
20:45:17 * desrt hugs lambdabot 
20:46:06 <autrijus> viirya: pong
20:46:09 <lambdabot> I missed you too, desrt.
20:46:19 <shapr> bot love
20:46:39 <lambdabot> It's a little-known fact that desrt is also a bot.
20:46:39 <viirya> autrijus: the patch is for whiteSpace indent
20:46:51 <dons> I'm not surprised, I have to say.
20:47:15 <shapr> jemfinch: I'm interested in how monotone might be better, but not today.
20:47:15 <dons> Only a bot, or a cyclon, would hack ghc on some the archs desrt has worked on.
20:47:16 <desrt> aw.
20:47:18 <autrijus> viirya: is it against Parser.hs?
20:47:31 <viirya> autrijus: there's a problem when you say " (1+1)" or "   (1+1)"
20:47:35 <jemfinch> shapr: that's fine.
20:47:36 <desrt> dons; only powerpc.
20:47:40 <viirya> autrijus: yes
20:47:56 <autrijus> oh, leading whitespace?
20:48:29 <desrt> dons; how is yi?
20:48:40 <shapr> yippee!
20:48:41 <lambdabot> I ported myself to the VAX 11/780, but it was too cramped.
20:48:47 <viirya> autrijus: it leads to a syntax error msg.
20:48:53 <desrt> heh.
20:49:04 <desrt> the idea of using a haskell text editor seems nice to me
20:49:09 <desrt> but only if it's at least vaguely useable
20:49:10 * shapr doesn't even know what the 11/780 part means.
20:49:13 <viirya> autrijus: even when ". (1 + 1)"
20:49:20 <lambdabot> I'm now thinking of getting a nice little server in the country.
20:49:28 <shapr> 11MHz? 780K of ram?
20:49:34 <dons> dons: well, we've got vi down. it's just getting into the 1990s that I'm looking for now.
20:49:35 <autrijus> viirya: I see. thanks, pushed
20:49:41 <autrijus> I applied it to block also.
20:49:43 <desrt> shapr; probably 11 bit words :)
20:49:44 <anyone> think of it as "version 11.780"
20:50:04 <viirya> autrijus: and the stuff in repo now is works?
20:50:12 <Pseudonym> I think it was a 16-bit version of the PDP-11.
20:50:12 <desrt> desrt; talking to yourself is fasionable.
20:50:18 <autrijus> viirya: I'm cleaning up Eval.hs right now as we speak; should be done in 1 hr
20:50:26 <Pseudonym> Sorry, 32-bit version.
20:50:29 <viirya> autrijus: k
20:50:34 <autrijus> viirya: you can still test the parser :)
20:50:35 <anyone> does anyone know anyone?
20:50:39 <Pseudonym> Dunno about the 780 part.
20:50:41 <anyone> does anyone talk to anyone?
20:50:56 <shapr> No man is an island. Mostly because we don't float that well.
20:51:05 <viirya> autrijus: any change you did for subroutine parser?
20:51:05 <desrt> are you trying to be confusing or is this gonna be a midlife crisis?
20:51:30 <autrijus> viirya: I basically rewrote it
20:51:36 <autrijus> viirya: using Perl6.grammar
20:51:48 <viirya> autrijus: it couldn't work yesterday
20:51:59 <autrijus> viirya: post a nonparsable snippet of code?
20:52:23 <viirya> autrijus: your t/* scripts will fail
20:52:55 <viirya> autrijus: it complains about "sub cool { blah blah...}"
20:53:12 <autrijus> oh! sec
20:54:31 <autrijus> got it. fixing
20:55:48 <viirya> I'm interesting of what's wrong with it.
20:56:14 <autrijus> aha. fixity declaration is wrong
20:56:26 <autrijus> on line 61 if you take the "try" away it says
20:56:30 <autrijus> unexpected "o"
20:56:30 <autrijus> expecting "circumfix:" }
20:56:41 <autrijus> so obviously it sees the "c" in "cool"
20:56:44 <autrijus> and commits into "circumfix"
20:57:15 <autrijus> so the fix is online 90
20:57:15 <autrijus>     fixity  <- option "prefix:" $ choice (map string $ words fixities)
20:57:17 <autrijus> should be
20:57:22 <autrijus>     fixity  <- option "prefix:" $ choice (map (try . string) $ words fixities)
20:57:34 <autrijus> damn parsec for not backtracking by default
20:59:53 <viirya> hmmm
21:00:57 <autrijus> fixed and pushed back.
21:02:38 <viirya> trying
21:04:37 <viirya> autrijus++ # fixing fast
21:04:43 <autrijus> viirya++ # reporting fast
21:05:11 <autrijus> lol (wrt comments on my pugs journal) http://use.perl.org/~autrijus/journal/23175
21:08:53 <shapr> does your journal have an RSS feed?
21:09:30 <autrijus> sure; firefox found it with autodiscovery just fine
21:10:03 <autrijus> http://use.perl.org/~autrijus/journal/rss
21:10:09 <shapr> ah, thanks
21:10:31 <shapr> I'm still trying to find an RSS aggregator that I really like. Any suggestions?
21:10:52 <autrijus> bloglines?
21:10:53 * autrijus <- absolutely needs roaming
21:11:12 <shapr> I'd rather have something local, I live in the couch in front of my computer.
21:11:13 <autrijus> brb, concentrating on shift/reset
21:11:13 <autrijus> &
21:11:39 <shapr> (or on the bed behind my couch)
21:11:52 <Pseudonym> I was thinking of setting up my own web-based aggregator.
21:12:04 <Pseudonym> In fact, that'd be a good introductory CGI-Haskell project.
21:12:12 <Pseudonym> Seeing as I've never done that before.
21:12:35 <shapr> It's weird how focus goes... ADHD means that I can be easily distracted from sleeping, so I get much more sleep in a room without cats.
21:12:40 <Pseudonym> I'd probably end up writing it in Perl, though.
21:12:49 <shapr> Haskell!
21:13:01 <Pseudonym> How good is haskelldb?
21:13:01 <shapr> stepcut: y0, peti was looking for your NewBinary repo, didja hear?
21:13:06 <shapr> good in what sense?
21:13:36 <shapr> HaskellDB is one of the coolest projects I've had the privelege to be associated with.
21:13:41 <shapr> Both technically and otherwise.
21:13:56 <Pseudonym> Does it work on different flavours of server?
21:14:00 <Pseudonym> e.g. MySQL and pgsql?
21:14:12 <shapr> Works on MySql, pgsql, sqlite, and something else.
21:14:18 <Pseudonym> Cool.
21:14:21 <Pseudonym> Might try it out then.
21:14:34 <shapr> You know the basic idea behind HDB?
21:14:42 <Pseudonym> Nope.
21:15:00 <shapr> it's a database UNwrapper, you don't use SQL, you have relational ops embedded in the language.
21:15:08 <Pseudonym> Ah, OK.
21:15:16 <Pseudonym> I can live with that.
21:15:57 <shapr> It has a bunch of really cool features. You can define a few columns, stick those together into a table, then create that table in any of the backends.
21:16:27 <shapr> Or you can go the other way, use DBDirect to read existing tables and generate a DBInfo structure.
21:16:53 <Pseudonym> The reason why I've resisted this sort of thing until now is There Is No Cabal(tm).
21:17:09 <shapr> Two things it's missing right now are tightly defined semantics, and backend specific SQL optimization.
21:17:12 <Pseudonym> i.e. it'd require grabbing a number of packages
21:17:20 <shapr> Yeah, it's a PITA to build.
21:17:30 <shapr> but it has a debian package now :-)
21:17:40 <Pseudonym> Oh, that's handy.
21:17:41 <Pseudonym> Where?
21:17:42 <shapr> CosmicRay packaged both HSQL and HaskellDB.
21:18:02 <Pseudonym> Gimme gimme gimme.
21:18:34 <shapr> looks like it hasn't made it into debian/unstable yet, but I'm sure you can get it from incoming.
21:22:12 <Pseudonym> Looks like I have to download cabal first.
21:22:17 * Pseudonym must be behind the times
21:24:04 <shapr> What do you call a person that you bounce ideas off of? It's 'ballplank' in Swedish, is there an English word for that?
21:24:38 <heatsink> sounding board
21:24:58 <shapr> ah yes, thanks
21:25:00 <Pseudonym> There's also a programmer term, "teddy bear".
21:25:07 <shapr> Cardboard Analyst :-)
21:25:47 <shapr> Sounding board must have interesting etymology.
21:25:59 <shapr> hoi arjanb
21:26:05 <heatsink> I've never heard teddy bear used that way.
21:26:17 * heatsink guesses sounding board has something to do with sonar
21:26:59 <Pseudonym> A teddy bear is a specific kind of sounding board.
21:27:10 <Pseudonym> The idea is that you talk to your teddy bear not because the teddy bear is listening.
21:27:21 <Pseudonym> But rather, because it makes you feel better.
21:28:12 <Pseudonym> A teddy bear is a sounding board that you don't expect a response from; they are merely a convenient entity to force you to explain something.
21:28:39 <xerox> 'morning
21:28:49 <desrt> hm
21:28:53 <heatsink> oh, interesting.  I'll want to remember that.
21:28:54 <desrt> i'm vaguely familiar with this concept
21:29:03 <desrt> i sometimes write emails in the same way
21:29:11 <desrt> and then don't send them
21:29:22 <Pseudonym> Whether a person is a teddy bear or sounding board is usually only obvious in retrospect.
21:29:27 <desrt> the process of explaining my ideas to someone helps me get them straight in my own head
21:29:33 <Pseudonym> i.e. if they didn't actually understand it, they're a teddy bear
21:47:25 <ozone> Pseudonym: or a rubber ducky
21:50:06 <Pseudonym> Could be, yes.
21:55:29 <Pseudonym> OK, must dash.
21:55:33 <Pseudonym> Nytol!
21:56:57 <dons> is it that late. huh. it is.
22:00:33 <desrt> it is :(
22:00:42 * desrt tries again to sleep
22:15:44 <shapr> Damocles' Other Shoe is falling! The sky is falling!
22:15:47 <shapr> panic!
22:16:40 <Gahhh> somebody give this man a monad.
22:16:45 * shapr snickers
22:21:58 <heatsink> that should be an @yow.
22:30:26 <shapr> All your lambda are belong to us.
22:41:28 <autrijus> viirya: ping
22:41:39 <autrijus> I've finish the transition to ContT/ReaderT monadic evaluator.
22:41:43 <autrijus> s/finish/finished/
22:42:02 <autrijus> the unit test works again. will work on the "return" primitive and "callcc" and coroutines today
22:42:15 <autrijus> the code is pushed up.
23:17:02 * shapr throws lambdas at Plone
23:22:21 <Cale> shapr: porting Plone to Haskell now? :)
23:26:41 <shapr> Would be nice, I admit. But my goal is more "kill it to death!" at the moment. Frustration is so much fun.
23:34:20 <viirya> autrijus: the evaluating process is amazing.
23:34:38 <viirya> autrijus: but found a bit problem.
23:35:19 <viirya> autrijus: later to check further and report.
23:35:33 <viirya> &
23:42:16 <vincenz> Hello everyone
23:44:07 <vincenz> I'll ask here since you're my favourite channel
23:44:38 <vincenz> I want to install a wiki at work... But we can't have dynamic content in our public_html... Therefore I'm thinking of installing my own server... Is there a wiki which includes a lightweight httpserver?
23:46:19 <autrijus> viirya: I just fixed op1 casting and extra space in lexers
