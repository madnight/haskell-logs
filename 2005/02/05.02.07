00:47:24 <Lemmih> Good morning, #haskell.
01:23:31 <pesco> Good morning, #haskell.
01:28:44 <Heffalump> morning
01:29:48 * pesco reads an RFC...
03:27:50 <vikasgp> haskell's user-defined datatypes and pattern-matching rock, for the record
03:30:52 <Lemmih> Indeed.
03:31:54 <vikasgp> infact, haskell is the only language where I've felt that the syntax is helpful rather than an impediment
03:32:21 <vikasgp> just look at how the datatype facility is simulated in Scheme (in eopl) ...
03:32:42 <jlouis> haskells syntax is very compact and very concise. I also think it is the right thing to do with syntax
03:35:55 <vikasgp> haskell has arranged syntactic matters for extreme convenience
03:36:21 <vikasgp> the whole thing about infix <--> prefix, etc.
03:51:06 * boegel greets
03:51:46 <Itkovian> hi
03:51:51 <Itkovian> i'm off to lunch
03:59:14 <boegel> hi Itkovian 
03:59:19 <boegel> bye Itkovian 
04:08:56 * pesco greets.
04:16:07 <boegel> @seen shapr
04:16:07 <lambdabot> I saw shapr leaving #webwitches 6 hours 48 minutes 14 seconds ago.
04:16:52 <pesco> cptchaos: Moin.
04:51:31 * boegel coughs
04:53:23 <glimming> what is rank-2 polymorphism?
04:56:57 <jlouis> it is a more general version of polymorphism which allows for some additional constructs compared to rank-1 polymorphism
04:57:12 <jlouis> but I guess you figured that out
04:58:46 <jlouis> http://www.haskell.org/hawiki/RankTwoPolymorphism by the way
04:58:50 <samc> isn't that form D&D ;p
04:59:21 <glimming> You can quantify over type constructors as well?
04:59:38 <glimming> FORALL f. f a b -> f a b  ??
05:01:39 <glimming> ?
05:05:07 <Asta> well there are no "a"s or "b"s
05:05:12 <Asta> argh
05:05:17 <jadrian> well there are no "a"s or "b"s
05:05:35 <jadrian> just   *
05:07:13 <glimming> Huh.
05:07:15 <jadrian> the equivalent of signature for a type constructor would be, its kind
05:07:21 <glimming> So rank-2 polymorphism is just System F???
05:07:37 <jlouis> yes
05:07:41 <glimming> F_3 would allow quantifying over higher types
05:07:55 <glimming> Ridiculous name for a well known concept???
05:08:00 <glimming> This is polymorphism. Period.
05:08:10 <glimming> There is also free variable polymorphism.
05:08:22 <glimming> Is that why we distinguish rank-2 and free variable poly?
05:08:53 <glimming> Another question: how strong is parametric types and type classes compared to subtyping?
05:09:01 <glimming> Are there examples of something, anything, that needs subtypes?
05:09:27 <glimming> (What is "rank-2" in rank-2 parametric polymorphism?)
05:11:19 <jadrian> The answer depends on what you mean by subtyping
05:11:53 <glimming> Subsumption, arrow subtype rule, and standard subtyping for algebraic datatypes.
05:12:37 <glimming> Anybode have some example of interaction between Haskell and Java?
05:13:14 <jadrian> if you include type variables in "types" then you define a subtyping relation among then
05:13:37 <jadrian> by defining classes and subclasses
05:13:48 <glimming> what do you mean by "types"?
05:13:58 <glimming> So you mean you program with types as well as values?
05:14:13 <glimming> I do not understand.
05:14:46 <jadrian> sometimes when refering to types we do not include type variables...
05:14:52 <jadrian> Int is a type
05:14:58 <glimming> aha
05:15:00 <jadrian> "a" is a type variable
05:15:01 <glimming> Right
05:15:04 <glimming> Sure.
05:15:21 <jadrian> anyway if you include type varyables you have
05:15:41 <jadrian> a > Ord a > Eq a > Int...
05:15:57 <glimming> Sure, this is some sort of subtyping.
05:16:05 <glimming> Based on overloading.
05:16:09 <jadrian> but it would be nice to be able to define more general arrows :-/
05:17:21 <glimming> Say you have two type classes C and C', and in C we have a function f:(C' c, C' c') => c -> c'  -> c
05:17:35 <glimming> Now we extend C'  into D'
05:17:41 <glimming> What happens with my overloaded f?
05:18:07 <jadrian> define extend...
05:18:34 <glimming> class (C c) => (D c)
05:19:15 <jadrian> nothing happens to your f, what could possibly happen?
05:20:18 <jadrian> class (C c) => (D c)  <-- this just mean that all instances of C are instances of D
05:20:56 <glimming> In this case I would have class (D c') => (C' c)
05:22:04 <jadrian> I'm lost...
05:22:25 <jadrian> f:(C c, C' c') => c -> c'  -> c    <--- you have this function 
05:22:35 <Lemmih> jadrian: He's gone.
05:22:43 <jadrian> Lemmih: opss :)
05:23:18 <Lemmih> I doubt he understood typeclasses.
05:23:31 <jadrian> yeap, probably
05:23:56 <jadrian> he mentioned Java, maybe he was mixing both concepts
05:24:45 <jadrian> by the way, what is there a specific name for non-variable types?
05:25:24 <jadrian> f :: C b => a -> b -> Int 
05:25:33 <jadrian> "a" is a type variable
05:25:47 <jadrian> Int is a? type constant?
05:26:15 <jadrian> and "b" is a? restricted type variable?
05:28:37 <b0gg1e> Hi.
05:29:26 <b0gg1e> newbie question: What is the most efficient way to realize something like "a list of objects of different types all having the same type class"?
05:31:38 <Lemmih> @wiki ExistentialTypes
05:31:38 <lambdabot> http://www.haskell.org/hawiki/ExistentialTypes
05:32:28 <b0gg1e> ah, thanks!
05:32:40 <Lemmih> No problem.
05:35:30 <b0gg1e> would be nice, if existential types would be automatically spring into existance, so to speak for arbitrary combinations of type classes.
05:45:41 <jadrian> hmm yeah, guess that would be nice
05:46:26 <jadrian> still
05:46:46 <jadrian> how would it decide wich class to generalize to?
05:48:14 <b0gg1e> Would propably require extending the type system, but I dont know much about this stuff.  I imagine somthing like  existential a.  Show a => [a]
05:49:40 <jadrian> what I mean is that you don't have a lattice
05:50:06 <jadrian> you may not have a least upper bound for two given types
05:50:20 <jadrian> for instance
05:50:26 <jadrian> data A = ...
05:50:29 <jadrian> data B = ...
05:50:39 <jadrian> class C1 where
05:50:42 <jadrian> class C2 where
05:50:56 <jadrian> instance C1 A where
05:50:58 <jadrian> instance C2 A where
05:51:01 <jadrian> instance C1 B where
05:51:04 <jadrian> instance C2 B where
05:51:23 <jadrian> now if you put a A and a B on a list, what do you get
05:51:34 <jadrian> a list of elements of class C1 or C2
05:51:49 <b0gg1e> you have to explicitely say that.
05:52:08 <b0gg1e> exits a. C1 a => [a]
05:52:28 <b0gg1e> exits a. C2 a => [a]
05:52:36 <b0gg1e> exits a. (C1 a, C2 a) => [a]
05:53:02 <b0gg1e> if unspecified, least common denominator can be inferred, i guess.
05:53:23 <b0gg1e> ah see your point, well maximum then.
05:54:25 <jadrian> yeah, guess that would work
05:56:04 <kosmikus> the problem is that these are not the types you really want
05:56:58 <b0gg1e> why is that so?
05:57:16 <kosmikus> you want [exists a. C1 a => a], not exists a. C1 a => [a]
05:57:33 <b0gg1e> ok .
05:57:34 <kosmikus> because you said you want the list to consist of objects having different types
05:58:13 <kosmikus> but having impredicative instances of algebraic datatypes is a bit harder to achieve than adding existentials to the Haskell type language
05:58:29 <kosmikus> at the moment, you can only define a specialized list datatype
05:59:07 <b0gg1e> how is that done?
06:03:23 <b0gg1e> besides, even if such list types would be available, one still has to add an instance declaration for the existential type, because there is no notion of "self" with type classes.
06:04:15 * kosmikus doesn't understand
06:05:11 <b0gg1e> say class Foo s where foo :: s -> Int 
06:05:29 <b0gg1e> and instances Bar, Baz.
06:06:28 <b0gg1e> No when creating the existential type, I find it usefull to also be it an instance of Foo which simply calls foo.
06:06:41 <b0gg1e> No=Now
06:07:51 <kosmikus> true
06:08:19 <kosmikus> I've never felt the need to have any such types anyway
06:08:54 <b0gg1e> Really?  Perhaps I'm still thinking to oo and use type classes for the wrong thing.
06:09:10 <kosmikus> possible
06:09:30 <Philippa> afternoon
06:09:44 <samc> morning
06:09:55 <b0gg1e> As an example, to learn haskell I'm writing a small tool that uses the WASHMail parser to generate Graphviz graphs of mail folders (From->To relationship an such things)).
06:10:20 <b0gg1e> I've got a class MessageSource which is a simple provider of [Message].
06:10:49 <b0gg1e> I want to join such things in union MessageSource which again is a MessageSource itself.
06:11:54 <b0gg1e> This requires having an existential AnyMessageSource which can be put into a list.
06:12:10 <b0gg1e> This was the use case that triggered my question.
06:13:17 <TheHunter> hmm, what is the word for a language that doesn't have casts? apperently people use "static type safety" for Java, so that can't be it.
06:13:34 <b0gg1e> :-)
06:14:24 <ibid> TheHunter: you mean dynamic casts?
06:14:50 <ibid> static casts are statically type-safe
06:14:53 <TheHunter> ibid, yep.
06:14:58 <samc> why are casts unsafe, how do the differ from any other (non-endo)function ?
06:15:21 <ibid> and anybody who says full java is statically type-safe is smoking something
06:15:43 <kosmikus> dynamic casts aren't unsafe if they have proper exception handling
06:15:48 <TheHunter> ibid, that was my impression, too, until i googled a bt.
06:16:05 <TheHunter> http://c2.com/cgi/wiki?StaticTypeSafety
06:16:23 <ibid> samc: because their type correctness cannot be verified statically, dynamic casts are statically unsafe
06:16:32 <kosmikus> understandable that people say Java is statically type safe
06:17:10 <kosmikus> the problem is that the type system of Java is so weak that one must resort to casting all the time
06:17:45 <ibid> TheHunter: c2 is not an authoritative source :)
06:18:07 <samc> ibid, you said they are unsafe because they are unsafe
06:18:13 <TheHunter> ibid, true.
06:18:20 <ibid> samc: no, i din't
06:18:34 <samc> or do I not know what safe means
06:18:46 <ibid> type-safe, mind you
06:18:52 <ibid> there are more than one kind of safety
06:19:27 <b0gg1e> kosmikus, as I'm quite willing to learn, is there something wrong with my approach?  What would be viable alternatives?
06:21:11 <TheHunter> b0gg1e, data Foo a = forall b. Bar b => Foo (b -> a)
06:21:29 <TheHunter> you can't derive an instance for Bar here, because b is used contravariantly.
06:21:41 <kosmikus> b0gg1e: sorry, I can't really tell with so little information, and I have not much time right now; best thing would be to let an experienced functional programmer look at the code you've written so far ... possibly even the people here on #haskell
06:21:55 <kosmikus> ibid: dynamic casts can still be statically safe
06:22:01 <TheHunter> (assuming that was the question)
06:22:31 <kosmikus> TheHunter: b0gg1e "question" is how he could avoid existential types for his problem alltogether
06:22:42 <TheHunter> ah, ok
06:23:04 <Philippa> you can't unless you can commit to a limited number of MessageSource types
06:23:16 <b0gg1e> Hmm yes and that would be ugly somehow.
06:23:43 <b0gg1e> 'cause it required touching many pieces of code whenever another one gets added.
06:23:56 <Philippa> right. Existential types good.
06:24:25 <b0gg1e> so I feel like I'm not completely of the track.
06:24:53 * kosmikus doesn't agree with Philippa, but acknowledges that there are different programming styles
06:24:59 <b0gg1e> Hope to release the code in a month or so depending on time available.  I really enjoy hacking haskell, since I stumbled upon it via darcs a month ago or so.
06:25:40 <samc> I dispute that, there aren't different programming styles
06:26:02 <kosmikus> one of the differences with oo is that in Haskell, the types don't contain any functions, only the data
06:26:31 <kosmikus> therefore, in many cases, it *is* possible to give a limited number of alternatives
06:26:39 <b0gg1e> Well but type classes completely feel like interface-oriented oo programming.  Just more sexy.
06:27:08 <kosmikus> only because you limit your "MessageSource" type, it doesn't mean that you can only have a limited number of MessageSources. You can define arbitrarily many functions of that type.
06:28:33 <Philippa> kosmikus: existential types good when that's what you need. Just like ADTs good when you need to fix the types in the union
06:28:37 <b0gg1e> Ah alright using the power of functions as data is a possible alternative, I agree.
06:28:38 <kosmikus> by having something like [exists a. Class a => a], you are essentially storing a number of functions for each of the a's. Often, this can be done directly.
06:28:53 <kosmikus> So, instead of using [exists a. Show a => a] you can simply use [String] in most cases, for example.
06:29:42 <araujo> Hello.
06:29:52 <araujo> kosmikus, Hello buddy
06:29:53 <samc> I dispute that, existential types arent good when you need existential types
06:29:55 <kosmikus> hi araujo
06:30:14 <Philippa> and for multiple functions you can use a tuple or record. Long story short, you can unroll the entire type class mechanism
06:30:16 <araujo> kosmikus, how you doing? :-)
06:30:20 <b0gg1e> But doenst that lead to kind-of re-implementation of the functionality provided by type classes?
06:30:58 <araujo> Hello CosmicRay 
06:31:02 <CosmicRay> morning araujo
06:31:04 <kosmikus> all I'm saying is that in many cases, there isn't the need for existential types
06:31:34 <kosmikus> in some cases, there is; but people coming from oo programming seem to want the more often than necessary
06:32:18 <Philippa> OTOH, there's a reasonable-sized area in which it's fair to ask which of the two possibilities is a better conceptual model
06:33:04 <Philippa> Myself I don't think I've ever used them in anger. But whenever I look at doing something where OO is close to being the best fit I can think of, they spring to mind rapidly
06:34:43 <kosmikus> Philippa: I agree with this. But Haskell isn't a good OO language, so it's usually better to select a non-OO approach if you want to do it in Haskell. This is not saying that OO is bad per se.
06:37:23 <boegel> hey araujo 
06:37:57 <Philippa> kosmikus: Haskell seems to be quite good at not-quite-OO solutions
06:38:27 <Philippa> mostly because of the abundance of roll-your-own-semantics techniques
06:38:47 <boegel> peer, stop bugging these people ! :p
06:39:09 <kosmikus> who's peer?
06:40:22 <Lemmih> He's the guy who resets your connection if you're not nice.
06:40:53 <xerox> hello!
06:40:59 <Lemmih> See?! He did it again.
06:41:18 <Lemmih> hallo, xerox.
06:41:57 <mdmkolbe> According to this (http://www.mail-archive.com/haskell@haskell.org/msg13419.html) post GHC should now support circular instance declarations, but the example program given doesn't seem to work in GHC 6.2.2.  How do I get it to work?
06:42:50 <kosmikus> this is probably not in ghc-6.2.2
06:43:09 <kosmikus> ghc-6.2.2 is from before September 2003
06:43:16 <kosmikus> ah sorry
06:43:18 <kosmikus> confusing years
06:43:39 <mdmkolbe> ah, are there any binary releases that would be after that
06:44:08 <boegel> Lemmih: I hate that guy :p
06:45:17 <musasabi> evening
06:45:38 <kosmikus> nevertheless, ghc-cvs seems to run this program, whereas 6.2.2 does not
06:45:58 <musasabi> @seen shapr
06:45:58 <lambdabot> I saw shapr leaving #webwitches 9 hours 18 minutes 5 seconds ago.
06:46:01 <kosmikus> mdmkolbe: no, no binary releases after ghc-6.2.2, I'm afraid, although ghc-6.4 is supposed to appear soon
06:46:09 <vdrab> hi all
06:46:27 <mdmkolbe> hmm, I'm on cygwin so I'm kind of locked out of using CVS.  thanks for the info
06:46:49 <boegel> musasabi: miss him already ? :)
06:46:53 <vdrab> I was wondering: is there a principled reason why Haskell doesn't have a 'system' function (like perl) that just executes OS commands? Wouldn't typing it be the same as your average other IO action?
06:47:12 <kosmikus> @type System.system
06:47:14 <lambdabot> System.system :: String -> IO GHC.IOBase.ExitCode
06:47:20 <vdrab> duh
06:47:31 <vdrab> thanks kosmikus
06:47:53 <musasabi> boegel: just things about TMR.
06:49:37 <boegel> musasabi: like ?
06:52:39 <araujo> Hello boegel 
06:52:43 <araujo> sorry, was way :-)
06:56:05 <musasabi> boegel: just article ideas.
07:02:18 <shapr> it's monday!
07:02:53 <shapr> Everybody who's wondering about writing a TMR article, this is the day to make up your mind.
07:03:05 <ikegami--> god mondag
07:03:41 <shapr> greetings ikegami-- 
07:03:51 <ikegami--> :)
07:04:18 <tintin> shapr: hmmz make your mind ?
07:04:28 <tintin> shapr: as in you have a deadline for the first issue ?
07:04:34 <shapr> sure
07:04:51 <Philippa> it's a bad thing if I made my mind up earlier?
07:05:10 <tintin> shapr: when is the deadline for the articles to reach you ?
07:05:31 <shapr> Three weeks into the month, the 21st this month.
07:05:33 <Lemmih> Isn't it 'mandag' in Swedish?
07:05:48 <tintin> and the articles are to be in LaTeX ? 
07:06:03 <shapr> no, plain text is an option for the authors who don't want to learn LaTeX
07:06:25 <tintin> shapr: hmmz .... ok but who will do the formating ?
07:06:30 <shapr> me
07:06:44 <shapr> Unless some LaTeXpert volunteers :-)
07:07:06 <shapr> tintin: you want to write an article?
07:07:10 <samc> too late for me it's tuesday, damn
07:07:33 <b0gg1e_> bye & thanks again for the help.
07:07:48 <Philippa> shapr: have you put any time in to learn yet?
07:07:57 <tintin> shapr: yes I was thinking about "How to get confused in Haskell" by a noob :)
07:08:06 <shapr> tintin: what would that cover?
07:08:22 <tintin> some basic haskell 
07:08:29 <shapr> Philippa: not really, just a few minutes getting the broad outline, and some lurking on #latex
07:08:33 <tintin> sort of a Haskell for dummies 
07:08:45 <tintin> by a dummy :) 
07:08:52 <Philippa> a regular "this month I have been mostly confused by"-style column could be a good way to transmit some of the folklore about what error messages are produced by what errors
07:09:01 <shapr> tintin: Can you give me an outline?
07:09:24 <shapr> I agree, sources of confusion and their solutions would be worthwhile.
07:09:37 <samc> this month I are ...
07:09:43 <shapr> hej glimming 
07:09:53 <shapr> hej då glimming
07:10:51 <tintin> shapr: its more a learn haskell tutorial for noobs with no functional programming experience and would take off from very basics 
07:11:28 <shapr> sounds great, I want to see an outline :-)
07:12:33 * boegel_ is experiencing some problems with het internet connection, which sucks
07:13:16 <shapr> samc: since the deadline is monday local time, you can still get an article in...
07:13:21 <tintin> shapr: whats the copyright status of the articles published ?
07:13:22 <tintin> the authors get to retain the copyright ?
07:13:45 <Philippa> tintin: BSD-like license
07:14:10 <musasabi> Some latex guidelines would be nice - e.g. a short example what document-styles etc should be used.
07:14:21 <tintin> Philippa: serious ? 
07:14:41 <Philippa> serious
07:14:46 <Lemmih> tintin: What would you prefer?
07:14:50 <Philippa> musasabi: I'm using article and keeping the markup low
07:15:06 <Philippa> the thing bugging me is that we've no agreed way to mark up code atm - so far I'm just bunging it in the verbatim environment
07:15:14 <shapr> musasabi: I don't actually know anything about LaTeX, I've never used it before. I asked around to see if someone wanted to be LaTeXpert for this issue, but no one has come up with suggested stylesheet, etc.
07:15:21 <vdrab> shapr - just an idea about Haskell didactics: what about a monthly "Yet Another View On Monads", some sort of playing ground for new metaphors/Koans/magic spells trying to explain monads to haskell newbies.
07:16:07 <tintin> shapr: hmmz you better start working Latex takes a while to sink in ....
07:16:32 <Philippa> enough to write a paper with no diagrams in doesn't take long
07:16:36 <shapr> tintin: right, the license of TMR will be such that readers can use the code and ideas in their own applications, from GPL to commercial. BSD will also mean that any code can be added to the standard Haskell libraries.
07:16:42 <kosmikus> shapr: coming up with a stylesheet is work :)
07:17:07 <shapr> yeah, I'll try to have one by friday.
07:17:13 * Philippa winces
07:17:17 <tintin> shapr: and the article itself ?
07:17:18 <Philippa> how much spare time you got before then?
07:17:30 <tintin> the code status harldly matters 
07:17:31 <Philippa> it could conceivably take you that long just to decide on a uniform way to mark up source code
07:17:49 <shapr> tintin: The code status is *very* important to me.
07:17:57 <Philippa> tintin: the article itself, including the raw LaTeX, is currently to be BSD
07:18:49 * Philippa does have a minor issue with the possibility of somebody else putting our articles in print in their magazine
07:18:58 <tintin> i think that could be an issue. Since in most journals the articles belong to the author ... and are distributable by his permission in that journal/magazine ...
07:19:04 <musasabi> shapr: ok, I'll try to keep things minimal and then as time goes by harmonize it with other people.
07:19:27 <Philippa> tintin: we're not really looking for papers, but yes, I agree there may be hiccups
07:19:31 <kosmikus> shapr: what kind of appearance do you want for TMR ?
07:19:32 <shapr> tintin: I think in most journals you have to sign over your firstborn child to submit an article. Look at Springer-Verlag ;-)
07:19:53 <shapr> kosmikus: Whatever is easiest to read.
07:20:09 <Philippa> the LaTeX defaults, then
07:20:20 <tintin> Springer-Verlag is commercial eeek thats a book :) 
07:20:24 <Philippa> well, that and an agreed-on environment for source
07:20:46 <kosmikus> yeah, well, start from scrartcl or article, and decide what's not okay about that
07:21:00 * shapr puts that into his TMR notes
07:21:06 <kosmikus> then, decide on a common way to place floats, code, and bibliography refs
07:21:22 <kosmikus> say something about usage of footnotes (I'd disallow them)
07:21:32 <Philippa> er, there should be multiple allowed ways to place code
07:21:41 <kosmikus> yes
07:21:47 <kosmikus> but there should still be a default
07:21:50 <shapr> hej igen glimming 
07:21:58 <Philippa> my article so far's got a couple of feetneet, one of which is large and arguably belongs in a float anyway
07:22:13 <Philippa> but I'm not touching floats without being given a common way to do the bastards
07:22:48 <shapr> I bet this is what a discussion of lambda lifting sounds like to a Java programmer.
07:22:53 <Philippa> (the other footnote's a "see other article this issue" type one)
07:23:07 <shapr> Yeah, that's true.
07:23:23 <Philippa> footnotes're what they sound like. If you processed my article you'll see I've got a damn massive one
07:23:32 <Philippa> float's the boxes and stuff you find "floated" out on the page
07:23:47 <kosmikus> shapr: if you want to, we can work on a style file tonight
07:23:55 <shapr> sure, sounds good
07:24:45 <shapr> I don't have time right now, I have to go shopping. but tonight...
07:24:51 <kosmikus> ok, shall we say, 2100 Swedish time, on irc?
07:25:02 <kosmikus> or 2000?
07:25:06 <shapr> sounds good
07:25:12 <kosmikus> ok
08:01:21 <rtega> which is the best online document for gaining an in depth knowledge of haskell?
08:02:17 <Philippa> um. Doesn't really work that way. I could be snarky and say "The Haskell 98 report"...
08:02:27 <rtega> hehe
08:02:40 <rtega> well, that's probably good for starters
08:02:44 <rtega> are there other?
08:03:02 <rtega> or does the report cover most of what is in haskell?
08:03:15 <musasabi> well it covers all of haskell98.
08:03:32 <musasabi> of course most of the interesting bits are not there ;)
08:03:50 <rtega> where can I find those?
08:03:59 <rtega> or those only to be gained through experience?
08:05:01 <Philippa> the research papers on the new features can be a good place to start for some
08:05:05 <musasabi> mostly different articles.
08:05:08 <Philippa> the GHC manual may or may not do
08:05:28 <rtega> uhu
08:05:32 <musasabi> and even the GHC manual refers to research papers often ;)
08:05:49 <musasabi> rtega: define in depth.
08:07:21 <rtega> well
08:07:25 <rtega> the situation is as follows
08:07:50 <rtega> i'm currently in the process of writing my masters thesis on a comparison of programming languages for writing scientific software
08:08:02 <rtega> haskell is one of those (quantum theory anyone?)
08:08:09 <rtega> as such ;(
08:08:12 <rtega> ;)
08:08:53 <musasabi> For learning haskell Yet Another Haskell Tutorial is quite good.
08:09:16 <musasabi> Do you have any experience in functional languages?
08:09:39 <rtega> well, I got a course on functional languages last year
08:09:44 <rtega> we did haskell and prolog
08:09:50 <rtega> so I do know some haskell
08:09:53 <rtega> but not a lot of details
08:10:22 <rtega> what is very interesting for what I'm trying to do is the type system in haskell
08:12:37 <musasabi> Some people are doing such stuff (if I am on the right trails) but sadly I have not followed those things very much.
08:13:29 <rtega> well, i found some interesting things mostly regarding quantum theory and algebra group theory
08:14:19 <Philippa> rtega: you want to know how to implement it? Google for "thih" and grab the paper
08:16:51 <rtega> thanks
08:17:09 <boegel_> rtega: where are you from ?
08:17:27 <rtega> belgium
08:17:41 <rtega> you too ;)
08:17:46 <boegel_> rtega: where in Belgium ? where did you get the Haskell/Prolog course ?
08:17:52 <boegel_> rtega: yep :)
08:17:54 <rtega> Leuven
08:18:08 <boegel_> oh, I thought I'd might know you, but I got it in Ghent
08:18:13 <rtega> aha
08:19:50 <rtega> mmm, some other people here from belgium
08:19:58 <rtega> Itkovian, ozone and vincenz_ 
08:20:05 <rtega> oh, not ozone, i'm sorry
08:21:40 <fraxtal> err I just don't know where to start learning this
08:23:30 <Lemmih> Learning Haskell?
08:25:08 <boegel_> rtega: Itkovian is a teaching assistant
08:25:11 <boegel_> in Ghent
08:28:44 <fraxtal> When I see this, increment :: Num a => a -> a, does this constrain a to be a number?  And how similiar is this to: increment :: a -> a .
08:29:44 <boegel> fraxtal: it constrains a to be of type class 'Num'
08:30:06 <boegel> increment :: a -> a doesn't constrain the type of a, which might result in problem
08:30:16 <fraxtal> hmm
08:30:32 <boegel> for example when trying to use String as 'a', not all the operations on numbers are defined on strings
08:30:34 <boegel> you see ?
08:30:40 <fraxtal> Yea
08:30:44 <fraxtal> That's a nice feature
09:11:48 * TheHunter needs to get his own internet connection.
09:12:34 <Lemmih> Greetings, SyntaxNinja.
09:13:43 <Lemmih> Bring any news from the far west about GHC release dates?
09:13:44 <TheHunter> ahh, finally the guy who was talking on his cellphone and listining to hip-hop finally left.
09:14:07 * TheHunter feels soooo relieved.
09:14:25 <Oeje1> Hello, Lemmih.
09:14:41 <Lemmih> Greetings, fellow Dane.
09:14:42 <Oeje1> Hello, TheRelivedHunter.
09:14:52 <TheHunter> hey Oeje1 
09:17:51 <TheHunter> man, the array interface sucks.
09:19:36 <shapr> w00h00
09:19:41 <xerox> w00w00
09:19:44 <esap> arrays are basically functions
09:20:20 <CosmicRay> SyntaxNinja: hi
09:20:41 <CosmicRay> SyntaxNinja: did you see that wishlist bug I filed?
09:21:26 <TheHunter> i'm currently implementing uniqueArray :: Ix i => (i,i) -> [(i,v)] -> Maybe (Array i v)
09:21:28 <shapr> rtega: were you asking about quantum programming done with Haskell?
09:21:43 <TheHunter> which is way harder than it should be
09:22:03 <shapr> What does that do?
09:22:21 <TheHunter> return Nothing when a value is assigned twice.
09:22:53 <shapr> can you use one of the _C functions to bail out?
09:23:07 <TheHunter> _C ?
09:23:29 <shapr> err, I thinking FiniteMap, doh
09:24:01 <shapr> Does Array have the 'fold multiple values with this function' operation like FiniteMap does?
09:24:06 <TheHunter> i'm going for unsafePerformIO
09:24:33 <TheHunter> shapr, apperently not.
09:24:47 <shapr> That's odd.
09:25:28 <shapr> I never did get into using Array, it was too much trouble to figure out. I ended using FiniteMap everytime after trying Array for an hour.
09:25:49 <esap> hmm.. how about just using length (nub (map fst x)) == length x as guard?
09:25:57 <shapr> Part of my problem was that I couldn't find any sort of tutorial on using Array.
09:26:36 <TheHunter> esap, hmm, good idea.
09:27:35 <shapr> tinus: hey, you have an outline?
09:27:53 <shapr> esap: hei, want to write for The Monad.Reader? 
09:28:46 <esap> shapr: hmm.. Maybe. Can't commit in any regular way though.
09:29:09 <esap> shapr: Would need to figure a good idea to write about.
09:30:01 * esap has lots of category theory stuff I could write about though.
09:30:11 <shapr> What about an introductory article on duals? Like, noticing ones that we see everyday, and how to use that in programming?
09:30:37 <esap> Yea, that's one good idea. I've thought about that a lot.
09:31:52 <esap> Another is how to build OO in Haskell
09:32:07 <esap> Or the control operator.
09:32:49 <shapr> From what I've seen, 'duals' is a useful and powerful concept that seems esoteric to most programmers. An introductory article on that would be a good basis for more category theory articles.
09:34:05 <shapr> Today is the last day to get an outline to me if you want to get an article in the first issue.
09:34:37 <esap> oh deadlines :-) I've never been good at those :-)
09:34:43 <shapr> Then two weeks to write the article, and one week for Panic. And then the first issue comes out on March 1st!
09:35:08 <shapr> I'm not good at those either, but I know a lot of people are looking forward to this.
09:35:23 <esap> what kind of outline do you need? just the headings?
09:35:25 <shapr> I got email from Simon Peyton-Jones, John Hughes, John Peterson, and others.
09:35:38 <shapr> basically saying "cool! yay!"
09:36:01 <esap> cool :-)
09:36:25 <samc> yay!
09:36:26 <shapr> Yeah, just enough outline that the rough structure and article subject is understandable.
09:37:01 <Igloo> Is this deadline actually important for nything other than discipline?
09:37:12 <shapr> no, not really.
09:37:42 <shapr> It's completely arbitrary, and may change dramatically next issue if this set of deadlines sucks.
09:37:46 <SyntaxNinja> hi all
09:37:50 <shapr> y0 SyntaxNinja!
09:38:01 <SyntaxNinja> hi Lemmih, shapr
09:38:05 <SyntaxNinja> hm. missed cosmicray
09:38:21 <shapr> Igloo: but I still have to learn LaTeX, and figure out a bunch of other stuff, so I want to know ahead of time what I need to do.
09:39:07 <esap> shapr: ok, I can try to write something. Let me think of an outline, I do have some ideas.
09:39:15 <shapr> esap: spiffy!
09:39:17 <musasabi> Category theory from a haskell point of view would be fun.
09:40:18 * esap doesn't hold my breath just yet, normally when I try to write something, I usually find too early it's full of problems and then all time goes to fixing them :-)
09:41:43 <rtega> shapr: that's part of the "research" that i'm doing yes
09:41:45 <SyntaxNinja> shapr: did I tell you I ran into a programatica hacker on the train?
09:41:59 <shapr> SyntaxNinja: whoa, who? Hallgren?
09:42:36 <SyntaxNinja> shapr: yeah :)
09:42:50 <shapr> rtega: I think I saw one or more quantum programming simulators at ICFP03
09:42:59 <SyntaxNinja> I saw him hacking and struck up a conversation w/ him, then was surprised to realize he was hacking Haskell :)
09:43:03 <shapr> haha
09:43:37 <rtega> shapr: apparently there's still some active research going on there
09:43:44 <SyntaxNinja> I added programatica support to cabal so you can say "./setup pfe" and it'll add all your modules to pfe.
09:43:50 <shapr> I wish he'd make the Fudgets build process easier, Fudgets' InternetLib is powerful stuff.
09:43:52 <rtega> but I will further look into that at the end of this week
09:43:55 <SyntaxNinja> but of course it hardly works since that only works for haskell98
09:43:59 <rtega> first i'll shoot off java
09:44:00 <rtega> ;)
09:44:08 <shapr> rtega: there's a *lot* of active research in quantum programming last I checked.
09:44:52 <shapr> I vaguely recall some connection between quantum programming and null convention logic, but I might be imagining that.
09:45:09 <rtega> do you know of other scientific stuff in haskell?
09:45:22 <shapr> Er, lots. What counts in scientific?
09:45:53 <rtega> well, scientific with a big S ;)
09:46:12 <shapr> Probably 80% of existing Haskell software fits in there.
09:46:19 <rtega> i'm mainly searching for stuff where fortran, c++ and the like fail miserably
09:46:26 <shapr> ah, that's different.
09:46:36 <rtega> that would be very interesting
09:46:56 <rtega> testing group theory and quantum computing are nice examples
09:46:58 <shapr> Check out Paul Hudak's work on domain specific languages.
09:47:20 <shapr> For example, he wrote up a language 'Dance' to describe dancing choreography.
09:47:37 <boegel> shapr: do you need an outline for my article ?
09:47:58 <shapr> boegel: yes please!
09:48:28 <shapr> rtega: oh hey, what about declarative parallelism?
09:48:30 <rtega> mmm, nice
09:49:12 <rtega> interesting
09:50:14 <shapr> The Nepal project has code to do warm fusion on array operations (whatever that means) and automatically parallelize it.
09:51:13 <shapr> Nearly every language fails there.
09:51:18 <rtega> thanks shapr 
09:51:40 <shapr> I can come up with a lot more items on the list of Cool Haskell Things.
09:52:02 <rtega> go on
09:52:38 <rtega> you spare me endless hours of googling and you will get a place in my thanks list ;)
09:52:40 <shapr> A related language is Epigram, it uses a dependent type system so that you can describe behaviour with types.
09:52:43 <shapr> heh, cool
09:53:29 <rtega> what is a dependent type system?
09:53:48 <shapr> umm
09:54:09 <rtega> a type system which is dependent? ;)
09:54:24 <shapr> http://www.dur.ac.uk/CARG/epigram/
09:54:28 <shapr> that's the epigram site.
09:55:08 <shapr> Have studied type theory much?
09:55:14 <rtega> not enough
09:55:18 <rtega> i'm planning to do that this week
09:55:37 <shapr> In short, type systems are simplified automated proof checkers.
09:55:38 <rtega> as I said, i'll first trash Java for numeric programming
09:56:32 <shapr> Haskell has a decent type system, but it's been described as a first-generation type system.
09:56:54 <shapr> (Java was described as having a zero or negative one generation type system by those same people)
09:57:37 <shapr> A type system in a language is like an optional skeleton for your program. You can use types to encode properties about your program and automatically check those properties.
09:58:04 <shapr> Or you can ignore it completely and do everything however you want.
09:58:13 <samc> in a dependent type system you can quantify over any value
09:58:21 <samc> not just types
09:58:47 <samc> so you can specify the type : lists of length n,  and such
09:59:24 <shapr> Right, it's difficult to specify the length of a list in Haskell's type system, but easy to do in Epigram.
09:59:47 <xerox> What's Epigram?
10:00:06 <shapr> bringert came up with a bunch of neat tricks to implement SQL's limited strings, like varchar(20) in Haskell.
10:00:14 <samc> an fpl with dependent types
10:00:48 <shapr> One simple comparison is that types themselves are not values in Haskell, but they are in Epigram.
10:01:08 <shapr> In Epigram, there's almost no difference between a type and a function.
10:01:09 <samc> xerox, shapr gave link above
10:01:30 <shapr> In Haskell, how do you encode the value 3 into a type?
10:01:30 <xerox> Whoops, thanks.
10:02:48 <shapr> rtega: anyway, I suspect that Epigram and resulting projects will be a big part of powerful type systems of the future.
10:04:36 <shapr> The real goal is to find some way to let programmers to build proof info or whole proofs info into their programs without needing to know how it all works under the hood.
10:07:22 <shapr> rtega: Haskell has been used for advances in software testing - http://www.cs.chalmers.se/~rjmh/QuickCheck/ , heavy duty linguistics - http://www.cs.chalmers.se/~aarne/GF/ , as its own operating system - http://www.cse.ogi.edu/~hallgren/House/ 
10:09:06 <shapr> There's Haskell code for neural network, voice recognition, robotics, mobile agents, microchip design.
10:10:02 <shapr> Rather than go into a long list, maybe you'd like to read the communities and activities report - http://www.haskell.org/communities/
10:11:32 <shapr> SyntaxNinja: hallgren seems like a smart and shy person.
10:13:15 <shapr> rtega: My personal approach is that domain specific languages are the best approach to problem solving, so good problem solvers learn languages that are good for writing languages. Haskell is really good for building programming languages, whether compiled or interpreted.
10:15:00 <shapr> rtega: US Navy did an experiment where a simple system was written in several different languages - http://haskell.org/papers/NSWC/jfp.ps
10:15:22 <shapr> Too bad I don't get paid for Haskell advertising ;-)
10:15:28 <shapr> bringert: hej! wazzup?
10:16:37 <xerox> I can understand your sentence about "languages that are good for writing languages" if I talk about LISP, how is it about Haskell?
10:17:44 <shapr> Lisp and Haskell have different advantages for writing languages.
10:18:16 <shapr> Having the abstract syntax tree as the source is a powerful tool for metaprogramming. I like that about Lisp.
10:18:41 <xerox> I think so too
10:19:19 <shapr> I like the purely functional part of Haskell, and the type system, and a bunch of stuff.
10:19:44 <shapr> I should write up a comparison of Lisp and Haskell as language-building tools.
10:20:50 <shapr> Multimethods are another nice powertool, where Haskell has type classes, MPTC, and fundeps.
10:20:52 <jlouis> I don't think metaprogramming is such a big advantage
10:21:05 <jlouis> emphasis think
10:21:44 <shapr> Haskell has metaprogramming too, type-safe metaprogramming even. It's like a strange combintion of lisp's unhygienic macros and scheme's hygienic macros.
10:23:24 * pesco appears.
10:23:32 <pesco> Greetings shapr, hello everyone!
10:23:48 <shapr> xerox: what do you think? How would you compare Haskell and Lisp for building new programming languages? Do you see any important points?
10:23:56 <shapr> greetings pesco!
10:24:48 <shapr> Maybe I should write a Template Haskell tutorial for the first installment of shapr's n00b column.
10:25:16 <pesco> shapr: I'd happily read it.
10:25:47 <shapr> Do you think you'd have time to critique my article before publishing?
10:26:01 <shapr> Obviously I can't edit my own writings :-)
10:26:03 <pesco> I think so.
10:26:57 <shapr> Ok, I'll send it your way when I get it done. I started on a TH tutorial a few months back, hopefully I can still use what I wrote then.
10:28:06 <tic> BNFC's pretty nifty for designing languages.
10:28:19 <tic> generates a parser and lexer automagically from the EBNF grammar. (happy & alex)
10:28:21 <shapr> jlouis: still interested in the all-pairs shortest path kata?
10:28:25 <pesco> shapr: OK.
10:29:43 <shapr> Any ideas for a nifty demo application of Template Haskell?
10:32:25 <Lemmih> Uh! I got some.
10:32:29 <shapr> yeah?
10:33:01 <shapr> btw, you think you'll have time to write about HaskellDB or HaCanon for the first issue?
10:33:35 <Lemmih> My time is very limited at the moment, I'm afraid /-:
10:33:42 <shapr> I understand
10:33:48 <Lemmih> I've collected a couple of TH utils in Hacanon.
10:34:21 <Lemmih> 'puts' (the opposite of 'gets') and some others.
10:36:16 <jlouis> shapr: I have something, but no. I have a report over my head these days, and I need to finish that. 
10:36:29 <shapr> jlouis: cool, want to aim for issue 2?
10:36:31 <Lemmih> For overly interested souls: http://www.scannedinavian.org/repos/hacanon/src/Foreign/Hacanon/Common/THUtils.hs
10:36:43 <jlouis> shapr: i'd want  that, yes
10:37:20 <shapr> spiffy
10:38:36 <Lemmih> Would your TH demo target GHC >=6.3 ?
10:39:21 <Igloo> It should, especially as 6.4 really ought to be out by then
10:41:49 <bringert> hej shapr
11:08:00 <esap> shapr: I just wrote a quick outline.
11:13:53 <shapr> yay!
11:14:13 <shapr> esap: can I see it?
11:14:34 <esap> sure
11:15:26 <Oeje1> shapr: Could you in your articles have some runnable (how to compile and run the) examples?
11:15:28 <shapr> Man I have a really great blog entry bubbling around in my head. But I'm not sure how to put all the pieces together.
11:15:43 <shapr> Oeje1: yes, I prefer executable tutorials.
11:15:52 <shapr> Oeje1: have you seen the HaskellDBTutorial?
11:16:10 <esap> shapr: http://www.kotiposti.net/epulkkin/duality-article.dvi Only headings are there.
11:16:56 <Oeje1> shapr: No, I haven't.
11:18:20 <shapr> esap: oh this looks good!
11:19:11 <shapr> Fits quite nicely into generic Haskell too
11:19:13 <Lemmih> Oeje1: You should check it out. I wrote most of it (:
11:19:22 <shapr> Lemmih: hey, I wrote the first version :-)
11:19:56 <Lemmih> ('most' == the working part :-)
11:20:24 <shapr> yes, true
11:21:04 <Lemmih> Should one write an article in literate Haskell?
11:21:09 <shapr> esap: records versus union types is cool
11:21:31 <esap> shapr: heh, that's the intro example :-) That's not yet very cool. Platforms and applications part is cool :-)
11:22:26 <shapr> I've been thinking about literate Haskell. I very much wish for a way to turn a single .lhs file into both a sexy PS and a haddock-style SGML with the same content.
11:22:28 <Oeje1> Lemmih: What should I check out?  I must have missed something.
11:22:57 <Lemmih> @wiki HaskellDbTutorial <- tradada
11:22:57 <lambdabot> http://www.haskell.org/hawiki/HaskellDbTutorial <- tradada
11:23:15 <shapr> esap: Records versus unions is easily grasped by any Haskeller, and makes a good springboard to the later ideas.
11:23:51 <esap> shapr: yes, that's how I learned about duality.
11:24:16 <Lemmih> Oeje1: It's a literate Haskell script which is runable without any modifications needed.
11:25:12 <tinus> shapr: an outline?
11:25:34 <shapr> I especially wish Literate Haskell were generic enough to generate a variety of documentation formats. printer, browser, plaintext for my palmpilot...
11:26:06 <shapr> tinus: er, I think I meant tintin
11:26:17 <shapr> tinus: Are you writing a TMR article? :-)
11:27:26 <tinus> what's a TMR article? ;)
11:27:38 <Lemmih> @wiki TheMonadReader
11:27:39 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
11:27:58 <tinus> ah
11:28:15 <tinus> i still have to figure out what a Monad is, exactly :)
11:28:20 <Lemmih> shapr: I'll probably have an article ready for the second issue.
11:28:23 <shapr> Lemmih: spiffy
11:28:38 <shapr> tinus: You do metapatterns?
11:29:03 <tinus> no, i just followed a course at my uni which requires haskell knowledge :)
11:29:10 <tinus> that is about what I use haskell for
11:29:27 <tinus> too bad, because i do like the language
11:29:28 <shapr> Ah, ok. If you want to learn more...
11:29:34 <tinus> always :)
11:30:20 <shapr> Any specific questions?
11:30:44 <tinus> not atm, but as I shall use haskell more, questions will arise
11:31:00 <tinus> for now I just lurk around here to see questions and answers and learn from it ;)
11:31:01 <shapr> ok, cool
11:31:44 <shapr> bringert: wassup?
11:32:04 <shapr> bringert: did you already send the HaskellDB demo apps my way?
11:33:02 <bringert> I'm messing with a tablet PC
11:33:14 <shapr> oooh, cool
11:33:15 <bringert> windows is slightly annoying
11:33:30 <bringert> and trying to finish my thesis
11:33:49 <bringert> I haven't looked at any demo apps
11:33:53 <shapr> What's the subject of your thesis?
11:34:18 <bringert> embedded gf grammars
11:34:29 <bringert> embedded in applications that is
11:34:38 <shapr> oh, neat
11:35:03 <shapr> Are you doing a thesis for Russian as well?
11:35:17 <bringert> yeah, but I haven't started working on it yet
11:35:31 <bringert> I will use Haskell :)
11:35:44 <shapr> Are you going to do the same thesis for both? =)
11:35:48 <bringert> heh
11:35:49 <bringert> no
11:35:52 <shapr> Embedding Russian grammars in applications? =)
11:36:08 <bringert> Functional Morphoology for Russian
11:36:17 * shapr snickers
11:38:28 <bringert> I would guess that it will be one of the few liberal arts theses ever where the work consists mostly of writing Haskell code
11:38:29 <shapr> oh, I have a ParseDate user question...
11:38:47 <bringert> oh, I didn't know anyone used that
11:39:17 <shapr> Yeah, I'm using it in curryspondence, it's great. Beats any other date parsing I've found.
11:40:01 <shapr> I'm using a list of formats, and sort of doing head catMaybes on the list.
11:40:26 <shapr> Is there a more intelligent approach to parsing the date when it could be one of twenty formats?
11:41:47 <shapr> I also found out that some mail clients use either capital or lowercase AM/PM, which wasn't handled in ParseDate. I fixed it, but I haven't sent in a patch.
11:43:41 <shapr> I wonder if Peti knows about ParseDate
11:45:12 <bringert> I can't really think of a smarter way of using multiple formats, maybe if you use the pCalendarTime function and some Parsec combinator
11:45:31 <bringert> I should set ut a darcs repo I guess
11:45:40 <bringert> for easy patch handling
11:45:47 <shapr> det låter bra
11:45:57 <shapr> I should set up a darcsforge.
11:46:13 <bringert> I mostly wrote it as a proof-of-concept to see if anyone was interested in putting something like it in the standard libs
11:46:46 <shapr> It's in my standard libs.
11:48:29 <shapr> bringert: I get the impression I shouldn't even ask if you have time to write something for TMR :-)
11:49:49 <glimming> I define data (f :* g) o = Pair (f o) (g o) and want a function proj :: (f:*:f') (a,b) -> f a such that I get the first projection when o=(a,b) in the first datatype definition. 
11:50:41 <glimming> For some reason I cannot come up with this function... Anybody have any idea? proj = fst . pi1 where pi1 Pair(a,b)=a does not type. Here Pair is a (f:*:g) is an instance of Functor so it has fmap...
11:52:24 <glimming> ( I am writing object calculus in Haskell )
11:53:07 <shapr> Sounds like a question for esap maybe?
11:53:46 <Lemmih> Pasting your code might make it easier for us to understand.
11:54:06 <glimming> Lisp link?
11:54:20 <Lemmih> lisppaste2: url
11:54:20 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:57:24 <lisppaste2> glimming pasted "distribute FxF over AxB somehow..." at http://paste.lisp.org/display/5630
11:58:48 <shapr> Huh, that looks a bit like the arrow combinators.
11:59:11 <glimming> I know nothing about arrow combinators. Therefore I don't like them! ;-)
11:59:28 <glimming> (I should learn some day)
11:59:52 <bringert> shapr: yeah, I feel a little busy atm
12:00:14 <bringert> good luck with the TMR
12:00:18 <shapr> Your definition of :+: looks like the arrow definition of first or second .
12:00:44 <shapr> and :*: looks like the pair apply combinator... which I think is &&&
12:01:04 <glimming> :+: is really just supposed to be a coproduct or disjoint sum or whatever you call them (Either)
12:01:14 <glimming> It is a higher-order Either.
12:01:28 <shapr> Yeah, I got that impression.
12:01:58 <shapr> @type (Control.Arrow.+++)
12:01:59 <lambdabot> (Control.Arrow.+++) :: forall a c' c b' b.
12:01:59 <lambdabot> 		       (Control.Arrow.ArrowChoice a) =>
12:01:59 <lambdabot> 		       a b c -> a b' c' -> a (Either b b') (Either c c')
12:02:43 <glimming> So the quesion is given some arbitrary type constructor (here f and g), I make a new type constructor f:*:g.
12:02:57 <glimming> And I apply this to a value (a,b)
12:03:09 <glimming> Now I want to extract a value (f a) from this.
12:04:00 <Oeje1> To anyone interested, I maintain some Haskell recipes for GoboLinux at http://www.student.dtu.dk/~s022018/HaskellStore/
12:04:41 <shapr> glimming: I think you can do that with *** and first in Control.Arrow. That may help you figure out to implement what you really want :-)
12:05:16 <glimming> Is John Hughes around?
12:05:29 <shapr> Nah, he's never visited here.
12:06:21 <glimming> I do not like arrows, because I have heard they lack mathematical foundations. Unlike e.g. monads.
12:06:30 <glimming> I want everything to be simple maths. Here type constructor is just a functor.
12:06:56 <shapr> Well, a) arrows do have math backing, freyd somethings, and b) monads aren't exactly simple math :-)
12:07:39 <shapr> Look at related theoretical work here --> http://www.haskell.org/arrows/biblio.html 
12:08:03 <shapr> specifically "Premonoidal Categories and Notions of Computation"
12:09:07 <glimming> right, sorry, what I really heard someone say was that monads have simpler and well-understood mathematical backing
12:09:14 <glimming> (Tarmo Uustalu said this in Uppsala)
12:09:55 <shapr> Monads are simpler, and maybe well-understood by mathematicians.
12:10:12 <shapr> On the other hand, I've had some trouble converting Java programmers to monadic IO.
12:10:14 * shapr grins
12:10:33 * esap thinks theoretical basis for arrows is hom-sets.
12:12:23 <shapr> Arrows really aren't much more complicated than monads. They are a bit harder to work with, but mostly because when rewritten they result in a bunch of unexpected code. (this is my opinion at least)
12:12:48 <glimming> so much work just for imperative features...
12:13:02 <shapr> but it's not just imperative
12:13:27 <glimming> no, sure you can do concurrency and other notions of computations too... 
12:13:29 <shapr> Arrows are a superset of functions. They can easily do stuff that's very difficult to do with just imperative features.
12:14:13 <shapr> To stay out of the Turing tarpit discussion, I'd say that a language/library/etc is defined by what it makes easy to do.
12:14:32 <glimming> So what is the fundamental type of an arrow?
12:15:04 <glimming> If a->mb is an arrow in the Kleisli category
12:15:22 <shapr> The handwaving explanation is that it's a first class transformation, one step above a monad's first class action ( which is one step above first class functions, etc )
12:15:59 <shapr> @type Control.Arrow.arr
12:16:00 <lambdabot> Control.Arrow.arr :: forall a c b.
12:16:00 <lambdabot> 		     (Control.Arrow.Arrow a) =>
12:16:00 <lambdabot> 		     (b -> c) -> a b c
12:16:06 <glimming> Ok, Well in the problem I posed, I think arrows would be overkill...
12:16:22 <shapr> An arrow type is an arrow value a, that transforms values of type b into values of type c.
12:16:43 <shapr> And of course, satisfies a few laws, much like a monad.
12:17:35 <shapr> Yes, I agree, arrows are likely overkill for what you want. But I don't know how to do what you want, so maybe you can steal (er, borrow) something from how arrows work?
12:17:36 <glimming> Not easy to comprehend.
12:18:31 <shapr> I'm not really a theory guy, so I got into arrows from the motivational example of Swierstra and Duponcheel's parser that couldn't fit into the monad interface.
12:18:32 <glimming> Hmmm. proj :: (f:*:f') (a,b) -> f a
12:19:33 <glimming> This could be written FxF' AxB -> F A
12:20:04 <shapr> Yeah, I've seen code like that somewhere other than the arrows papers, but I don't remember where.
12:21:14 <glimming> Anyone good on catamorphisms etc?
12:21:24 <shapr> You could ask on the haskell-cafe mailing list, I'm sure someone there will know.
12:21:41 <glimming> Good idea.
12:21:57 <glimming> I'll do it straight away
12:23:57 <shapr> My intuitive description of an arrow is that it's like 'nouning a verb.' Then you can operate on that noun. Much like 'I had a run' gives you the whole action as a noun where you can add adjectives or whatever.
12:24:36 <Spark> heh
12:25:22 <shapr> Anyway, I gotta do some work... bbl
12:25:31 <Spark> im not keen on the whole representation of stuff like that in terms of mathematics, even if its inspired from mathematics
12:25:41 <Spark> i much prefer to think of it in terms of technical details, what it can do, etc
12:34:11 <glimming>  bbl
12:38:19 <basti_> hi
13:13:01 <esap> hmm.. how do I embed verbatim in LaTex user-defined environments?
13:13:18 <basti_> uhm
13:13:25 <basti_> verbatim environment
13:13:35 <basti_> wheres the problem?
13:14:03 <esap> \newenvironment{code}{\begin{verbatim}}{\end{verbatim}} doesn't do it properly.
13:14:16 <basti_> hmm
13:14:27 <basti_> ah
13:14:35 <basti_> let me guess it outputs something like }{?
13:14:55 <basti_> or crashes or something?
13:14:58 <esap> heh, it gives strange error message :-)
13:15:08 <basti_> aww thats tricky lol
13:15:24 <basti_> maybe theres an escape for "calling" an environment?
13:16:58 <glimming> use lhs2tex
13:54:45 <Sukh> Hi, I'm learning Haskell and I've been told to implement a prime power finder.  (a prime power is any integer that can be represented in the form p^e where p = a prime and e is an integer >= 0).
13:54:59 <Sukh> I've got some code working but I'm kinda stuck.
13:55:25 <Sukh> is there a paste board for this channel?
13:55:31 <boegel> Sukh: first step: paste your code on the wiki
13:55:39 <boegel> @HaskellIrcPastePage
13:55:39 <lambdabot> Sorry, I don't know the command "HaskellIrcPastePage", try "lambdabot: 
13:55:39 <lambdabot> listcommands"
13:55:44 <boegel> @wiki HaskellIrcPastePage
13:55:44 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:56:25 <Lemmih> lisppaste2: url
13:56:26 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:56:53 <Lemmih> Pick your poison.
13:58:08 <lisppaste2> Sukh pasted "PrimePower" at http://paste.lisp.org/display/5639
13:58:42 <Sukh> that'll be me
13:58:59 <Sukh> From and including "if isPrime(sqrt n) == True then True" i'm stuck
13:59:06 <Sukh> isPrime is a function i made to detect if a number is a prime
13:59:18 <Sukh> however i'm completely stuck as to how to find the prime power
14:00:28 <Sukh> a prime power is any integer that can be represented in the form p^e where p = a prime and e is an integer >= 0
14:01:33 <Sukh> And i can't pass sqrt n to isPrime because it's not an Integer and I'm unsure about casting in Haskell :D
14:02:08 <basti_> uhm
14:02:55 <Sukh> yup, big uhm
14:02:55 <basti_> actually your generalisation would be lacking anyways.
14:03:07 <Sukh> yes i know that, but it's the best i've come up with so far
14:03:12 <basti_> since sqrt sqrt n = 4th root of n
14:03:16 <Sukh> indeed
14:03:26 <basti_> youre looking for kth root of n
14:03:31 <Sukh> yes
14:03:38 <basti_> hmm
14:04:12 <Sukh> Alternatively i could have several lists of 1...n^n and compare each and every number. But we're not meant to do that
14:04:39 <Sukh> e.g. 2^2, 2^3, 2^4 then 3^1, 3^2, 3^3 etc
14:04:56 <basti_> how about starting with p^k = n , p close to n, k = 1, an then alternatively increasing k or decreasing p?
14:04:58 <Igloo> What's the wording of the problem?
14:05:18 <basti_> Igloo: "test if n is a prime power", that is there is a prime p so that p^k = n
14:05:31 <Igloo> No, the original wording
14:05:33 <basti_> oh
14:05:48 <Sukh> One second
14:06:45 <CosmicRay> SyntaxNinja: ping
14:06:45 <Sukh> "A prime power is an integer of the form p^e where p is prime and e >= 0 is an integer.  The first prime powers are 1=2^0, 2, 3, 4 = 2^2, 5, 7, 8 = 2^3, 9 = 3^2, ...  Write a function isPrimePower that tests whether an integer argument is a prime power."
14:07:31 <wli> (1) search for a prime divisor
14:07:43 <wli> (2) divide by it repeatedly
14:08:00 <Igloo> I don't see how that rules out your answer above
14:08:01 <wli> (3) if the result of (2) is not 1, return false, otherwise, true
14:08:21 <basti_> Igloo: sqrt sqrt = 4th root of
14:08:31 <Igloo> No, the one with lists
14:08:37 <basti_> oh.
14:08:37 <Sukh> Oh, it doesn't
14:08:43 <Sukh> weren't not allowed to do it that way
14:08:58 <Sukh> we technically haven't been taught lists yet
14:09:21 <Sukh> wli: i think yours may work
14:09:22 * Igloo was going to try to hint at what wli said WRT whatever clause disallowed that
14:09:56 <Sukh> "WRT whatever clause"?
14:10:11 <Igloo> with reference to whatever clause
14:11:34 <Sukh> so, i guess for x, go through 1 to x, if x = prime number, go though x^0 to x until result >= x
14:11:41 <Sukh> oh, that doesn't sound too bad
14:12:19 <basti_> will work, probably.
14:12:22 <basti_> =)
14:12:29 <Sukh> now to implement it in Haskell... if my object-oriented brain can figure it out
14:13:00 <basti_> just pinch yourself whenever you think of a variable as a memory cell.
14:13:13 <Sukh> i miss for loops :D
14:13:40 <basti_> do it recursive
14:13:48 <Sukh> will try :D
14:14:09 <tromp> try i from 1 to log_2 x and see if i'th root of x is integer and prime
14:14:10 <Sukh> i've kinda figured out how to do it in recursive loops, it'll just require a bit of adjustment i suppose
14:14:22 <tromp> that way it's polynomial in length x
14:14:51 <Sukh> ?
14:15:18 <basti_> sounds good tromp 
14:15:34 <tromp> it becomes exponential time if you try all primes up to x
14:15:58 <basti_> did you include the prime test in your estimation?
14:16:09 <basti_> (with usual algorithms?)
14:16:48 <tromp> use any fast prime test you like
14:20:15 <tromp> like miller's
14:29:38 <wli> http://holomorphy.com/~wli/PrimePower.hs
14:30:36 <wli> removed
14:31:42 <Pseudonym> http://andrew.bromage.org/WheelPrime.hs
14:32:58 * wli attempts to programmatically factor quartics with rational coefficients into quadratic factors with real coefficients
14:33:08 <Pseudonym> Ah.
14:33:15 <Pseudonym> Have fun. :-)
14:33:52 * basti_ doesnt
14:49:17 <lisppaste2> Sukh annotated #5639 with "Aaah!" at http://paste.lisp.org/display/5639#1
14:49:31 <Sukh> I get an error now
14:49:44 <wli> well, I have a Grobner basis for x^4+p*x^2+q*x+r-(x^2+a*x+b)*(x^2+c*x+d) where p, q, r are given, x is indeterminate, and a,b,c,d are to be solved for
14:50:00 <lisppaste2> Sukh annotated #5639 with "Error" at http://paste.lisp.org/display/5639#2
14:50:12 <Sukh> Haskell confuses the hell out of me
14:51:14 <Sukh> I'm passing  recursiveIsPrime (b, a, 0) but it says *** Does not match : (Int,Int)
14:51:14 <basti_> Sukh: at least it does before the program is running
14:51:20 <boegel> Sukh: don't give up !
14:51:39 * boegel goes to bed
14:51:43 <boegel> bye everyone
14:51:49 <wli> it basically comes down to getting a bicubic resolvent, whose associated cubic must have one real root, but in the case the associated cubic's root is negative the bicubic may have no real roots whatsoever.
14:51:50 <Lemmih> Night.
14:51:50 <Sukh> Well i've gotta do this for a good month yet and i just paid for a 40 book, so not any time soon!
14:51:56 <Sukh> nite
14:51:57 <basti_> Sukh: why do you give the function arguments as tuples?
14:52:17 <Sukh> erm, because they look more like parameters to me? :D
14:52:31 <Sukh> as in a function in another language
14:52:36 <basti_> =)
14:52:45 <Pseudonym> wli: Is this for anything in particular?
14:52:58 <Sukh> basti_: do you know what that error is all about?
14:53:00 <basti_> maybe your "does not match" happens in another place
14:53:09 <arjanb> Sukh: where do you have recursiveIsPrime defined?
14:53:17 <wli> yes, I'm trying to write a program to doublecheck some results and CAS's don't compute them in the form I'm trying to derive (and can't handle the equivalence).
14:53:54 <basti_> yes where? =)
14:54:19 <basti_> and isPrime is not defined too
14:54:23 <Sukh> recursiveIsPrimePower :: (Int, Int, Int) -> Bool
14:54:27 <Pseudonym> Ah, OK.
14:54:29 <Sukh> isPrime is further up, I never pasted that
14:54:43 <Sukh> it works though - tested it in an earlier question
14:54:46 <basti_> i see.
14:55:06 <basti_> recursiveIsPrime might be defined from an earlied attempt
14:55:10 <basti_> it is not in your paste
14:55:22 <Sukh> it is
14:55:24 <Sukh> at the bottom
14:55:32 <basti_> there is only recursiveIsPrimePower
14:55:39 <Sukh> oh crap
14:55:41 <Sukh> that's me being a dope
14:55:42 <Sukh> sorry :D
14:55:45 <basti_> =)
14:55:46 <Pseudonym> http://andrew.bromage.org/Prime.hs
14:55:54 * basti_ pats Sukhs back
14:56:03 <Pseudonym> That's O((log N)^6), assuming the Sophie-Germaine conjecture is true.
14:56:06 <basti_> dopeness is language independent.
14:56:11 <Sukh> indeed
14:56:23 <Sukh> i've been doing haskell as a beginner for about four hours straight :/
14:56:40 <basti_> that builds stamina
14:56:44 <SyntaxNinja> 4 hours isn't a long time to be a beginner
14:57:12 <CosmicRay> Sukh: if you haven't rleady sen this, it's a goot read: http://www.isi.edu/%7Ehdaume/htut/
14:58:07 <Sukh> okay... looking
14:59:08 <Sukh> no, 4 hours isn't... but i usually pick up new languages a lot quicker so it's a lil' frustrating :D
14:59:18 <Sukh> Suppose it'll teach me to look at problems in a different way
14:59:47 <basti_> yup
14:59:51 <basti_> have you ever done prolog?
14:59:53 <CosmicRay> Sukh: haskell is very different.
15:00:14 <basti_> thats the only language as far out as haskell from common programmer experience
15:00:34 <wli> mercury is fun
15:01:05 <Sukh> no, never done prolog
15:01:10 <Pseudonym> Mercury is fun until you find the cracks.
15:01:15 <Pseudonym> Then it ceases to be fun.
15:01:57 <wli> It's not good for everything.
15:02:04 <Pseudonym> Let me put it this way:
15:02:20 <Pseudonym> I did a straw poll of people who used to work on the Mercury compiler, and most of them agree that Haskell is more fun.
15:02:30 <dons_> hehe
15:02:35 <Pseudonym> This might be because almost anything is more fun than being supervised by Zoltan. :-)
15:02:53 <wli> That'll do it.
15:03:02 <dons_> "2 in 3 Mercury compiler hackers agree that Haskell is more fun"
15:03:31 <kuribas> what about Curry?
15:04:13 <Pseudonym> Of the ones I can think of: one is working on HAL, one is an evangelist for Microsoft, one is working for Galois, and two of them are C++ hackers, but still program Haskell for fun.
15:04:54 <Pseudonym> The one who is an evangelist for Microsoft used to be the guy in the department who distributed the Debian CDs.
15:05:03 <basti_> good night
15:05:03 * Pseudonym now knows precisely what the going rate for a soul is
15:05:06 <Pseudonym> Night.
15:05:22 <Lemmih> Igloo: Around?
15:05:32 <Igloo> Yup
15:06:10 <Lemmih> runQ [t| (Char -> Int) -> Int |] >>= putStrLn . pprint
15:06:11 <Lemmih> GHC.Base.Char -> GHC.Base.Int -> GHC.Base.Int
15:06:50 <Lemmih> Is this just a malfuntion in the pretty printer?
15:07:06 <Igloo> Almost certainly
15:07:19 <Igloo> You can s/pprint/show/ to confirm
15:08:16 <Sukh> YAY! I've bloody done it :D
15:08:50 * Igloo checks - yup, it is
15:08:53 <Lemmih> Igloo: It generates the correct type structure.
15:09:02 <Lemmih> But my code doesn't work (-:
15:12:38 <Lemmih> TH error messages really suck ass. All errors are located at line 1, char 0 (-:
15:17:13 <dons> I had a TH question yesterday. What is the best ghc flag to use to print out expanded TH code?
15:17:31 <dons> -ddump-simpl works if you know Core, but do people use something else?
15:21:30 <Igloo> I thought Sean had made a flag to do it, but then couldn't find it. I just tweaked the code to print it out as well as splicing it in
15:22:12 <dons> yep. in the pluggable branch I think.
15:22:27 <Igloo> Ah!
15:22:48 <Igloo> Although that doesn't explain why I failed to find the message in the cvs commit logs
15:22:54 <Sukh> Is there a preferred IDE for Haskell?
15:23:03 <Igloo> I assumed I'd dreamt it
15:23:06 <dons> hmm. but isn't that where we saw the msg?
15:23:12 <Lemmih> Sukh: emacs is quite common.
15:23:13 <dons> I'm sure I saw it in the cvs logs
15:23:35 <Igloo> I was sure I'd seen it, but failed to find it either in the archives or in the code
15:23:41 <Igloo> The branch would explain the latter
15:23:48 <Igloo> My incompetence probably explains the former  :-)
15:24:12 <Sukh> Lemmih: That's what i'm using atm... bit fidely on windows
15:24:41 <dons> I'll ask him in person when he comes in
15:25:58 <wli> hmm, looks like this is *always* imaginary
15:29:30 <dons> this is very weird that it isn't in cvs-all@
15:30:56 <Igloo> Oh, so it's not just me? Cool
15:36:09 <dons> hmm. very mysterious
15:39:25 * Lemmih is so very close to callbacks in Hacanon.
19:58:46 <icb1> what's the tag for ghc stable? 
19:59:07 <icb> i am looking at the cvsweb
19:59:13 <icb> and i don't see that tag
20:00:36 <dons> it's now ghc-6-4-branch
20:00:44 <dons> it was ghc-6-2-branch
20:00:48 <dons> depends on what you want
20:01:24 <icb> i was building 622 on mac
20:01:32 <icb> and after finally circumvented the readline problem
20:01:43 <dons> ghc-6-2-2 is the actual 6.2.2 release
20:01:48 <dons> cool
20:01:52 <icb> now it dies in Graphics/UI/ObjectIO/OS/ClCrossCall_12.hc:
20:02:08 <icb> is gtk required?
20:02:13 <dons> nope.
20:02:38 <icb> which platform do you build on, dons?
20:03:06 <dons> openbsd/x86 usually, but i've done amd64,sparc,mips64,ia64 and alpha :)
20:03:23 <dons> sean seefried does nightly stable builds for the mac
20:03:38 <dons> the output goes to the cvs-ghc@haskell.org mailing list
20:03:46 <dons> and should have links to binaries you can "just use"
20:03:51 <dons> (maybe ..)
20:04:01 <dons> time to go.
20:04:19 <icb> yes, some of the tips on his webpage helped alot
20:04:24 <icb> alright
20:04:26 <icb> catch you later
20:04:31 <icb> thanks for the tip
20:20:31 <icb> howdy sqrt
20:32:55 <SyntaxNinja> i've decided that we should have imaginary types, just like there are imaginary numbers.
20:33:15 <SyntaxNinja> we just need to work out the syntax...
20:33:42 <Gahhh> Please express Data Tree a a in polar form. mwahah.
20:34:44 <SyntaxNinja> yes!
20:37:14 <SyntaxNinja> wasn't it voltaire who said "if imaginary types did not exist, then man would be forced to invent them"
20:38:08 <monochrom> Aren't all types imaginary already.  It is not like "infinite lists" are real.
20:39:46 <SyntaxNinja> hmm... that's not really the type that's imaginary, though
20:41:44 <Gahhh> We're sorry. Your imaginary type cannot be instantiated in this universe. Please try again.
21:10:17 <shrimpx> any domain theory buffs? =)
21:41:12 <araujo> welcome kosmikus 
22:23:36 <musasabi> morning
22:25:22 <araujo> Hello musasabi 
22:25:26 <dons> hmm. I wonder how long it takes ghc to compile when distcc'd over 10 dual-p4 boxes...
22:25:59 <araujo> 2 secs?
22:26:09 <araujo> 8)
22:26:13 <dons> I wish
22:26:45 * araujo had to get used to compile in a PIII
22:26:48 <dons> I'll try in a couple of hours and see what happens
22:27:11 <Pseudonym> Knowing our luck, it'll be a few minutes longer.
22:27:25 <dons> !
22:27:39 <dons> nah, with make -j working now in the head, there is a noticeable speedup
22:27:45 <Pseudonym> Ah, OK.
22:27:50 <Pseudonym> Didn't know that was working.
22:27:53 <dons> so, i'd like to try make -j30 :)
22:28:25 <dons> hmm. I think I could even get 20 boxes
22:28:32 <wnoise> Groebner bases?  Holy cow, I didn't expect to see talk about polynomial ideals in an IRC channel, though I suppose this is one of the better bets for it.
22:46:03 <shapr> wnoise: do you have an eponymic sample?
22:47:13 * shapr imagines "Click to hear my name" - fshhshstt
22:55:35 <shapr> this is cute - http://www.informatik.uni-freiburg.de/~thiemann/haskell/HTB/
22:55:40 <shapr> y0 frax
22:55:56 <shapr> Is your brain stretching into that Haskell shape?
22:56:42 <shapr> autrijus: The SPJ retro tribute on your wiki pages is extremely funny. I love it!
22:57:20 <shapr> I was immediately tempted to hack up a "create your own tribute timeline" webapp with WASH and its dynamic image code.
22:58:15 <shapr> tuomov: how's code?
23:01:44 <fraxtal> shapr: I think so.  Its alot like Mathematica
23:06:39 <shapr> yup, functional means "like functions"
23:07:11 <wnoise> Nope.
23:07:16 <shapr> no?
23:07:38 <wnoise> I do not have an eponymic sample.
23:07:38 <shapr> oh, for your eponymic sample?
23:07:42 <shapr> aha, ok then.
23:07:45 <shapr> tyvärr
23:08:25 <shapr> hiya dude4545 
23:10:13 <shapr> random interesting thought of the moment: get a really long CDROM to Soundcard cable, coil it nearyour CPU(s). Turn the CD in all the way up (but don't play a CD). Feed the audio output into synesthesia for a unique CPU activity monitor.
23:11:19 <shapr> wnoise: do you know dan moniz?
23:12:45 <wnoise> Only online.
23:13:49 <shapr> The geek world is surprisingly interconnected. (maybe I'm the only one surprised)
23:15:37 <wnoise> There are only about 50 real people in the world.  Everything else is window dressing.
23:15:55 * shapr snickers
23:16:24 <shapr> Does that make me a pane in the ass? or a total curtain? (cretin?) 
23:17:34 * wnoise giggles
23:18:01 <shapr> Who was the artist who made a sculpture of a bull out of the handlebars and seat of a tricycle?
23:18:39 <shapr> Google is dissing me in this case.
23:25:38 <shapr> aha, it was picasso
23:32:46 <shapr> Picasso's "Bull's Head" made out of a bicycle seat and handlbars feels like an elegant hack to me, and very gnu-punny. I'd rather choose it instead of the floater from the game of life.
23:35:24 <shapr> Any other good ideas for alternative Hacker emblems?
23:38:12 * araujo wonders if shapr is organizing a "Hasckell Club"
23:40:05 <shapr> Hasckell Club?
23:40:20 <araujo> 8)
23:41:10 <shapr> I just try to find ways to fix things that irritate me, and this http://www.catb.org/hacker-emblem/ irritates me. I like the bull at the bottom of this - http://www.artviews.org/cosby.htm
23:41:23 <shapr> But that's not a good picture of that sculpture.
23:46:29 <araujo> shapr, nice
23:46:44 <araujo> im not sure what that game of life thingy is 
23:47:23 <shapr> Have you read about Conway's "Life" ? ESR's hacker emblem is the 'floater' from Life.
23:50:22 <araujo> no
23:52:12 <shapr> One beginning to that story, is von Neumann's studies of artificial life that reproduced itself. He used graph paper and systems of his own design. I think his first success was 92x~150 squares, and each square had something like 180 states.
23:53:36 <araujo> interesting
23:54:24 <araujo> so that game of life is representing it?
23:54:46 <shapr> sort of...
23:55:13 <shapr> http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life
23:56:07 <shapr> You could stretch back even farther and say that Leibniz' monads were the first cellular automata.
23:56:40 <dons> hmm. was it picasso?
23:56:54 <dons> oh. scroll down dons
23:57:49 <shapr> dons: well spotted :-) I thought it was him from the beginning, but it took me awhile to google it up. You know any good pix of this sculpture?
23:58:33 <dons> not online. only art books. i was suspicious that it was actually duchamp, since he was into bicycles
23:58:52 <dons> but picasso was into bulls, so that makes sense
