00:38:33 --- topic: '["Learning Haskell - http://haskell.org/learning.html","See logs @ http://meme.b9.com/cdates.html?channel=haskell","related channels #haskell.se #haskelldb #darcs","Haskell eZine! http://haskell.org/hawiki/TheMonadReader","http://haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - ICFP contest 2004","We put the Funk in Funktion","The people here like donuts"]'
00:38:33 --- topic: set by pesco on [Tue Feb 01 03:11:18 2005]
00:38:33 --- names: list (clog wli dude4545 r3tex tromp zamez isomer juhp SamB tintin creichen gzl viirya kosmikus desrt Lemmih aj_ dustin` ozone rtega kolmodin vincenz wagle CLxyz esap djw hcchien flori shrimpx noj Perite Taaus_ jwpye icb pesco jadrian sjanssen ksandstr Nomius Excedrin_ halfadde1 Cale themaximus_ rossberg_ wilx emu tumm aleator calvin_ araujo tuomov dons noclouds chip ralf jak97_ asmodai shawn_ exnor kpk sorje lambdabot psi shapr borism Lor duncan)
00:38:33 --- names: list (Heffalump camio skylan mornfall|work Gahhh musasabi Itkovian tic Matt-W Nioate thebug johs autrijus ibid earthy Igloo mflux Defty n-- _Codex Lunar^ tinus polli keverets jlouis norpan)
00:39:24 <musasabi> Lemmih: how?
00:39:42 <pesco> shapr: WRT TMR ACK.
00:39:51 <pesco> I'd say per-issue.
00:40:21 <pesco> ;p
00:40:34 <shapr> Some authors don't want to expose in-progress articles.
00:40:50 <shapr> Should still work though.
00:40:56 * autrijus ponders writing SEE-like things in haskell.
00:41:06 <autrijus> that would be a good case to learn about arrows and reactive foo.
00:41:10 <Lemmih> musasabi: Using TH might be easier.
00:41:12 <autrijus> but ENOTUITS
00:41:15 <pesco> shapr: We don't need to expose the repo to the general public...
00:41:19 <shapr> autrijus: haha!
00:41:34 <musasabi> http://youzen.b2.fi/~musasabi/a.hs - getting the dependency right seems to be the problem.
00:47:18 <dons> juhp: regarding .hi files #, there is a magic [Char] at the start of the .hi file representing the version number
00:47:51 <shapr> g'day Svrog 
00:47:56 <shapr> g'bye svrog
00:48:09 <shapr> ?
00:48:18 <shapr> Svrog: y0
00:48:24 * shapr blinks
00:49:14 <dons> you can get an error message with this magic version String in it, if you try to read the .hi file with the wrong version of the compiler
00:49:22 <Lemmih> Bah! [d| data T1 = T1 {f1 :: Int}; data T2 = T2 {f1 :: Int} |] fails /-:
00:49:39 <dons> juhp: so, if no msg, then version == ghc --version, otherwise == error msg string
00:50:06 <dons> pity that --show-iface doesn't print this field
00:50:53 <Svrog> argh..
01:03:49 <autrijus> "Toward Enlightenment" is so funny.
01:03:57 <autrijus> # http://www.eleves.ens.fr/home/madore/misc/totipsism.html
01:04:10 <autrijus> err, # http://www.eleves.ens.fr:8080/home/madore/misc/totipsism.html
01:05:24 <shapr> I proved to myself that solipsism is impossible. I have discovered things that I could not possibly think up.
01:05:46 <autrijus> but, but this is totipsism
01:07:45 <shapr> cute
01:11:09 <Svrog> sorry about all the joining and leaving.. had some problems with my irc client
01:13:55 <shapr> autrijus: have you read http://www.dreamsongs.net/NewFiles/PatternsOfSoftware.pdf ?
01:14:09 <shapr> hoi boegel 
01:14:22 <shapr> comment ça va?
01:14:24 * Itkovian greets boegel
01:14:54 <boegel> haai #haskell
01:15:09 <shapr> Is that japanese? hai!
01:15:19 <boegel> it's going fine... it got a primitive GUI working for my raytracer yesterday
01:15:25 <boegel> haai = shark in Dutch
01:15:25 <shapr> w00!
01:15:58 <boegel> http://studwww.ugent.be/~kehoste/gtk2hs.png
01:16:06 <boegel> the image part is not working yet dough :)
01:16:19 <boegel> I hope to get that part working today
01:17:38 <shapr> neato!
01:17:53 * boegel swears
01:18:22 <boegel> I send out a mail to the gtk2hs mailinglist, but using my ISP mailserver again, it's going to take forever again until it arrives :(
01:37:50 <Itkovian> does ghc run on the opteron? in 32-bit mode? it _should_ work, but anybody any XP with it?
01:38:42 <autrijus> I have opteron in 64bit mode on FreeBSD and I can't get ghc to run.
01:39:54 <pesco_> Quick Quiz! Who knows how to do search+replace in vim?!
01:40:03 <autrijus> :%s/foo/bar/g
01:40:04 <musasabi> pesco_: s///
01:40:35 <pesco_> autrijus: You win!
01:40:56 <Itkovian> well, I'd use 32-bit mode ... 
01:41:52 * pesco types :%s/{'rightarrow}/→/g
01:42:04 <pesco> Muahahar. I _love_ Unicode.
01:43:47 <Svrog> why wouldnt ghc run on the opteron in 32 bit mode?
01:44:01 <Itkovian> no idea, just checking before I make the attempt.
01:44:31 * boegel smelss Itkovian's lazyness
01:44:35 <boegel> s/l/s
01:45:56 <Itkovian> yeah!
01:45:59 <Itkovian> smell it!
01:46:06 <Itkovian> I'm loaded with work ...
01:46:22 <boegel> :)
01:46:26 <Itkovian> And I'm desperately trying to get this Jikes thing in a single darcs repos.
01:46:49 <Itkovian> pretty neat it ignored CVS crap :-)
01:46:52 <shapr> Jikes is a decent Java compiler.
01:46:59 <Itkovian> i meant the Jikes RVM
01:47:01 <Itkovian> :-)
01:47:02 <shapr> oh
01:47:08 <shapr> that's actually a decent jvm.
01:47:15 <Itkovian> yep.
01:47:28 <Itkovian> we're using it for our research ...
01:47:34 <Itkovian> very easy to code in
01:47:44 <shapr> Too bad the Java specs are so inexact... jrvm + classpath + jikes is not enough to get a real java environment.
01:47:48 <Itkovian> as it's Java all the way (well, except for a few files)
01:48:02 <Itkovian> well ... classpath is a bit behind ...
01:48:11 <Heffalump> itkovian: what is your research, OOI?
01:48:15 <shapr> And that's why I claim that java software isn't open source.
01:48:19 <Itkovian> Performance estimation
01:48:33 <Itkovian> notive the capital P
01:48:37 <Itkovian> :-)
01:48:42 <shapr> Do you get HotSpot-style poly-inline caching with jrvm?
01:48:43 <Heffalump> :-)
01:48:55 <Itkovian> erm ...
01:49:10 <Itkovian> I'm not sure ... I don;t think so
01:49:23 <Itkovian> a recompile walks the entire optimisation plan afaik
01:49:24 <shapr> Last I looked at the jrvm it had a lot of pluggable behaviour, and a lot of people interested in writing plugins.
01:49:38 <Itkovian> oh yes, you can override almost anything
01:49:51 <Itkovian> as the source dirs are rather independent of the build dirs
01:49:55 <shapr> But no incremental JIT plugins?
01:50:25 <Itkovian> adding a new compiler is just making sure you code in the right packages, and that the configure script copies your crap instead of the original jikes stuff
01:50:42 <Itkovian> shapr: you can add new steps in the compiler plan
01:50:49 <Itkovian> there's no JIT as such
01:50:54 <Itkovian> it's compilation all the way.
01:51:32 <Itkovian> well, the optimisation is done in separate VM threads ...
01:51:40 <Itkovian> so you could call it a JIT, kind of
01:52:27 <shapr> Too bad JVM doesn't handle TCO, jrvm + jikes are almost interesting enough to play with again.
01:52:28 <Itkovian> the GC is pluggable too ...
01:52:44 <shapr> *that* is neat!
01:53:21 <Itkovian> at ISSM last year, Steve Blackburn demonstrated building a generational collector from 'scratch' in 30 minutes, including compilation time to make the build
01:53:45 <Itkovian> there's these blocks you can configure and plug in ...
01:54:00 <Itkovian> you can create spaces for about anything to go into.
01:54:06 <shapr> You should mention that on LtU in the GC thread.
01:54:06 <Itkovian> pretty neat
01:54:15 <Itkovian> hmmm
01:54:31 <Itkovian> Then I;d have to dig up my LtU password ;-)
01:54:46 <Itkovian> And I think it's been mentioned... not sure though
01:55:07 <Itkovian> for now MMTk is mostly Jikes RVM, but they're making it more general.
01:55:35 <Itkovian> Afaik, Blackburn's group does all their GC stuff in MMTk ...
01:55:47 * Itkovian wonders how one could use it in a Haskell environment
01:56:00 <Itkovian> or a FP env in general
01:56:12 <shapr> I'd like to use the SPJ incremental GC.
01:56:22 <shapr> What's that paper called? non-stop GC?
01:56:48 <dons> Itkovian: they've actually looked into plugging MMTk and ghc together
01:56:59 <dons> they had a thesis student working on it, and got a fair way
01:57:18 <dons> mostly to do with replacing GC calls in generated code, and where to hack the rts
01:57:27 <dons> but it's been idle for about a year
01:57:56 <Itkovian> heh, cool!
02:07:18 <Itkovian> I'm reading the Wadler 1992 paper on Monads for functional programming, and I've got a few questions ...
02:07:35 <shapr> Do those questions start out with WTF?
02:07:41 <Svrog> haha
02:07:42 <Itkovian> not yet ;-)
02:08:14 <shapr> hiya vikasgp
02:08:18 <shapr> looking for Haskell info?
02:08:19 <Svrog> i could never fully understand any of the papers on monads
02:08:25 <Itkovian> he uses (*) :: M a -> (a -> Mb) -> M b and m * La.n <=> let a = m in n
02:08:37 <shapr> Svrog: I may be able to help you out, if you want to understand monads.
02:08:52 <Itkovian> but futher on he claims that unit a * Lb.n == n[a/b] ???
02:09:00 <Itkovian> that should be n[b/a], no?
02:09:21 <Itkovian> unit :: a -> M a
02:09:22 <Heffalump> I can never remember which way round to read that
02:09:34 <Heffalump> but you should replace b with a.
02:09:35 <Svrog> well ive gotten better with using them and creating my own ones and i know the basic theory behind them but i find the papers (especially waddler's papers) too hard to read - after a while my brain just turns off
02:09:46 <Itkovian> Heffalump: v[x/y] means you replace the bound x in v with y
02:09:54 <shapr> Svrog: Have you tried the nomaware monads tutorial?
02:09:58 <Heffalump> then [b/a], yes
02:10:07 <Itkovian> good.
02:10:09 <Itkovian> then ...
02:10:15 <Itkovian> (I'm not finished yet ;-))
02:10:37 <TheHunter> Itkovian, are you sure that it's not the other way round?
02:10:51 <Itkovian> futher on he defines an operation on a monad, e.g. map
02:11:23 <Itkovian> TheHunter: not as I learned it ...
02:11:29 <Itkovian> anyway ...
02:11:59 <Itkovian> map :: (a->b) -> (M a -> M b) and he claims that map f m = m * La. unit (f a)
02:12:07 <Itkovian> I can't wrap my head around that ...
02:12:22 <Itkovian> imo the type def of map is wrong ...
02:12:32 <Heffalump> no, that seems correct
02:12:37 <Itkovian> he provides it with two arguments ...
02:12:41 <shapr> Svrog: nomaware handles the hardecore theory too, I think.
02:12:44 <Itkovian> so what's the type of the function value?
02:12:45 <Heffalump> yes, (a->b) and M a
02:12:57 <Itkovian> no, a->b and Ma -> M b
02:13:01 <Itkovian> the brackets?
02:13:06 <Itkovian> (M a -> M b)
02:13:07 <Itkovian> ??
02:13:08 <Heffalump> the second set is irrelevant
02:13:20 <Heffalump> -> associates to the right anyway
02:13:49 <Itkovian> eh? you mean that a -> (b -> c) == a -> b -> c ??
02:13:50 <Heffalump> you can think of it as one argument and that (M a -> M b)  is a return type if you like
02:13:53 <Heffalump> yes
02:14:06 <Itkovian> no way?!
02:14:12 <Itkovian> erm
02:14:16 <Heffalump> it's a natural consequence of ' ' (space that is function application) associating to the left.
02:14:35 <Itkovian> yeah, erm, I think I'm fouling up here. a sec.
02:14:47 * Heffalump repeats his first-week-of-term Haskell lessons :-)
02:15:00 <Itkovian> sure, my mistake
02:15:16 <shapr> Svrog: http://nomaware.com/monads/html/
02:15:32 * Itkovian slaps himself around a bit with a large trout
02:15:32 * shapr slår Itkovian med en stor forell
02:16:04 <Heffalump> if Svrog knows the basic theory and can write his own, a basic tutorial is probably pointless
02:16:17 <TheHunter> Itkovian, you learned it wrong, then.
02:16:57 <Itkovian> TheHunter: it's in all my courses ...
02:17:12 <Itkovian> but anyway, if the meanings the other way around, I can live with it.
02:18:06 <TheHunter> http://www-2.cs.cmu.edu/~rwh/courses/logic/www/handouts/subst.pdf
02:19:21 <Itkovian> well, we write it the other way round :-)
02:19:21 <boegel> Itkovian: you teached me the wrong way ? :p
02:19:45 <Itkovian> boegel: complain to kdb and boute
02:19:59 <boegel> Itkovian: heh
02:20:09 <boegel> I think it's just a matter of notation
02:20:18 <Itkovian> true.
02:20:27 <Itkovian> but it helps to know which is used.
02:20:38 <boegel> if you make clear how you interpret it, that's fine
02:21:55 <TheHunter> well it's just... one way makes much more sense than the other.
02:22:29 <Itkovian> TheHunter: yes, but I think we write te [] operator on the other side of the expression too :-)
02:23:25 <[1]Svrog> ok... back to using the old irc client... chatzilla sucks
02:24:28 <[1]Svrog> shapr, ive seen those tutorials before
02:24:39 <[1]Svrog> i actually understood those
02:24:46 * boegel == shower
02:25:08 <[1]Svrog> it's mostly waddler's papers that i couldnt fully understand
02:25:46 <Itkovian> well, they're the first I'm examining ...
02:26:50 <Itkovian> I teach lanbda calculus exercises, but usually it's all very easy stuff such as K, S, C, B, combinator stuff and reduction of (complicated) lambda expressions ... and avery brief intro into haskell
02:27:10 <Itkovian> But I want to delve a bit deeper into haskell, so I've got to know more of it myself
02:27:45 <Itkovian> Problem is: I;ve got maybe tow lessons to cover it.
02:27:49 <[1]Svrog> waddler's papers are dry reading - very hard for me to concentrate on - i'd definitley recommend those tutorials that shapr mentioned
02:27:50 <Itkovian> s/tow/two/
02:28:02 <shapr> Itkovian: you could use @eval from lambdabot 
02:28:23 <shapr> It's a lambda calclus interpreter that behaves surprisingly much like Haskell.
02:28:31 <Itkovian> lol
02:28:42 <shapr> That would let you mix the two.
02:29:06 <shapr> I was quite impressed when I saw how easy it is to build 90% of Haskell on top of LC.
02:29:08 <Itkovian> most of the exercises om LC are on the blackboard
02:30:24 <dons> shapr: that's the point of the Haskell Core :)
02:31:03 <Itkovian> So this year, I'll be very brief on LC stuff and show a bit more on Haskell ...
02:31:16 <Itkovian> Maybe no monads, but I'd like to give them a small taste.
02:31:36 <dons> Itkovian: what level of programmers are they?
02:32:08 <[1]Svrog> do you get to choose what you teach them (at least to some extent)? or are the guidelines more strict?
02:32:27 <Itkovian> dons: they've got Java behind their belt, and if I'm lucky they've had C too (they're abolising C for first years), so my students are third year CS or fourth year engineers/CS
02:32:52 <Itkovian> [1]Svrog: I get to choose mostly. Got to make sure they survive the exams :-)
02:33:49 <[1]Svrog> i found haskell very hard to get into when i got into functional programming first - ive found caml and sml to be the easiest to get into and suspect those might be the easiest ones for people who are already familiar with imperative programming
02:34:12 <Itkovian> exams are usually a question on LC/combinator expression (reduction or expansion in terms of K, S, C, B, I), one a bout haskell (writing a small thing / figuring out what a peice of code does), one on logics , one on prolog and then maybe a question on deriving a type for an expression
02:34:27 <Itkovian> [1]Svrog: No, it's definitely Haskell. No choice there.
02:34:27 <dons> ok. mine too. 3rd year CS.
02:34:37 <[1]Svrog> then again i was self tought - would have probably been easier if i had more guidance when i started
02:34:44 <[1]Svrog> fair enough
02:34:44 <Itkovian> dons: I don't teach them the theory though.
02:34:46 <dons> but they've had first year Haskell at unsw.
02:34:54 <Itkovian> nice
02:35:14 <Itkovian> [1]Svrog: I've followed the course myself and two years later I was dropped in front of the class ;-)
02:35:33 <TheHunter> why is it so hard to write "alpha" instead of "alhpa"?
02:35:47 <Itkovian> For me it was a course I choose, not obligatory, so I had one extra year of programming xp.
02:35:54 <Itkovian> alpha
02:35:56 <Itkovian> alpha
02:35:57 <Itkovian> :-)
02:36:22 <TheHunter> it's always alhpa with me.
02:36:31 <mflux> alhpa is difficult for me
02:36:36 <mflux> ahlpa would be easier
02:36:56 <dons> Itkovian: "Concepts of Programming Languages" at unsw is mixed theory (proving properties of static and dyn semantics) combined with (I hope) difficult pracs
02:37:36 <dons> last year they had to write the type inference pass for a mini-haskell compiler, for example.
02:37:55 <dons> yay. 6.4 branch is now STABLE
02:38:17 <dons> that means the release is soon
02:38:21 <Itkovian> woot!
02:39:08 <Itkovian> I'd love to get my head buried more in FP stuff, but my time is so limited ... and spending it here doesn't help freeing up time either 
02:39:11 <musasabi> ^_^
02:39:14 <Svrog> Itkovian, at which university do you teach?
02:39:18 <Itkovian> Ghent
02:39:28 <dons> Svrog: you're not a unsw student, are you?
02:39:36 <Itkovian> I'm working toward a PhD. Well, trying to anyway
02:39:40 <Svrog> nope - im an anu dropout :P
02:39:49 <dons> hehe. that's alright then
02:40:08 <Svrog> dropped out in.. umm.. 2000?
02:40:12 <Svrog> been a while
02:42:22 <dons> Itkovian: you don't have to simultaneously teach prolog and haskell do you?
02:42:32 <Itkovian> not this year. I suck at prolog!
02:42:52 <Itkovian> I've got a colleague who'll wash that pig this year
02:43:03 <dons> hehe. that's good.
02:43:13 <Itkovian> the course entails functional a logical programming, hence haskell and prolog
02:43:35 <Itkovian> the logival theory stuff is a piece of cake, so are the excercises, but that prolog. bwaark.
02:43:39 <Itkovian> :-)
02:43:50 <dons> yep, makes sense.
02:44:09 <Itkovian> I get most thigs I write to work after a while, but man, don't ask me how I do it.
02:44:19 <Itkovian> I only write toy stuff though
02:44:45 <dons> I've had the same experience with Prolog. at least I have a nice text book on the shelf to look at.
02:45:08 <Itkovian> lol
02:45:56 <Svrog> ive never used prolog.. never got around to learning it - always been interested in checking it out though
02:47:25 <Itkovian> I'm told it's cool if you fully grok it.
02:47:52 <boegel> Itkovian: it can be quite nice
02:48:15 <boegel> we had to use it in a business rule engine in a J2EE thing
02:48:38 * dons looks at the prolog src in ghc's testsuite
02:48:53 <boegel> but some students just aren't able to wrap their minds around it
02:48:55 <dons> whoa:
02:48:56 <dons> Mini Prolog Version 1.5                       Mark P. Jones 22nd November 1990
02:49:08 <dons> A simple Prolog interpreter, written in Haskell B.
02:49:09 <boegel> ancient history :)
02:49:47 <dons> I think this might be the oldest still-in-use file in $fptools.
02:49:58 <dons> quote:
02:50:01 <dons>  This is my first significant Haskell program and I've
02:50:02 <dons> been experimenting with a number of its special features
02:50:39 <dons> Mark Jones' first real Haskell program!
02:51:29 <dons> written to run on the Chalmers LML compiler
02:53:03 <dons> no do notation either
02:53:11 <dons> (you still see that in ghc src a bit)
02:54:08 <dons> not a class in sight
02:55:42 <Svrog> i found that there were many cases where i avoided using the do notation in order to improve readability.. then again i like the variable-less approach to programming and try to use haskell like then whenever i can :)
02:56:53 <Svrog> then=that
02:58:54 <Svrog> in particular it seemed to work really well when i was playing around with parsec
03:03:03 <jak_> hey guys, what's the easiest way to force evaluation of a result?
03:04:04 <jlouis> jak_: there are some notation for strictness you might wish to look at
03:04:42 <jlouis> Then you can force something to be regarded as a strict result which in turn makes the compiler compile it strict
03:04:59 <jlouis> I would use it sparingly though
03:06:18 <jak> what I really want to do is to time the evaluation of a function
03:06:34 <jak> so I need it to completely evaluate
03:12:23 <jlouis> jak: what implementation are you using?
03:12:31 <jak> ghc
03:13:56 <Svrog> jak, why dont you just use the profiler?
03:14:25 <Svrog> hmm.. although.. i guess though you'd still have to force the evaluation of the function heh...
03:15:01 <jak> could do, but it's just a simple program that calculates ackermanns function and it'd be nice to know how long it takes to compute the answer. Obviously printing the result will force the eval, but then I don't really want to take into account the time for doing the print
03:15:06 <Svrog> im a bit rusty on this.. would have to write a test app to remember how to do it - havent used haskell for a while
03:16:15 <Svrog> if you use the built in profiler it will tell you how much time it takes to evaluate the function separatley from the printing function
03:16:49 <jlouis> I would use the profiler
03:16:56 <jlouis> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
03:16:58 <Svrog> im pretty sure.. i remember using it ages ago and it spits heaps of useful info
03:17:07 <jlouis> eventually with a cost centre annotation on the ackerman only
03:17:16 <Svrog> yeah
03:37:20 <Lemmih> Igloo: Around?
03:40:19 <Itkovian> com;iling ghc source on opteron-fedora core 2: make[2]: *** No rule to make target `System/CPUTime_hsc.c', needed by `depend'.  Stop.
03:40:25 <Itkovian> using the hc bootsrap stuff
03:40:39 <Itkovian> export CFLAGS="-m32 -O2 -fomit-frame-pointer"; ./configure --enable-hc-boot etc.
03:41:24 <Igloo> Possibly
03:43:34 <michaelw> Igloo: volker pointed me to your libreadline problem.
03:44:34 <michaelw> Igloo: iirc, ghc tries to load libreadline.so dynamically?
03:45:29 <Igloo> The ghc binary itself will, yes, but that's not a problem
03:45:53 <michaelw> ah, right. the problem is that we want to compile and link stuff with readline.
03:46:03 <duncan> Igloo: are you doing your type inference talk at 12?
03:46:09 <Igloo> duncan: yes
03:46:27 <duncan> Igloo: I'd better get moving then :-)
03:46:42 <Igloo> michaelw: The problem is we need to have the right libreadline-dev /in case/ we try to compile and link with readline (the Haskell package)
03:47:11 <musasabi> jlouis: the time to print the result should be small and can be factored out.
03:47:30 <boegel> duncan: hi !
03:48:00 <boegel> damn, missed him again :(
03:48:07 <boegel> damns Igloo :p
03:48:31 <Igloo> boegel: I exist only to make your life harder
03:48:52 <musasabi> jlouis: the time the Ack program should take is time(ack(n) + constant) so with different n you can effectively kill out the constant (which is not important)
03:49:22 <musasabi> jlouis: various timing artefacts are likely to be bigger than the time to print.
03:49:23 <Igloo> michaelw: This can be aoided in the future by making the readline library a separate package. Unfortunately the same issue will arise with libgmp-dev, and I don't think there's a way around that  :-(
03:50:28 <juhp> Itkovian: you're trying to do a build for x86_64?  I mean 64bit
03:50:33 <Itkovian> nope 32 bit
03:50:53 <michaelw> Igloo: but wouldn't ghc(i) depend on ghc6-readline, which then pulls in libreadline4-dev?
03:50:58 <Itkovian> and there's no ghc in the machine
03:51:26 <juhp> Itkovian: oh, ok - why not not just install ghc.i386?
03:52:00 <Igloo> ghc(i) will only need the .so from libreadline(no -dev), won't it?
03:53:17 <Igloo> If I get rid of libHSreadline.a and HSreadline.o then ghci still works
03:53:26 * Lemmih frowns at subtyping and templates.
03:53:37 <michaelw> interesting
03:53:50 <Itkovian> heh ... imagine a fedora machien wthout libreadline and libgpm ...
03:53:57 <Itkovian> hard to do, I know, but still ...
03:54:02 <Itkovian> and the sysadmin is _away_ atm.
03:54:10 <Igloo> Because the .a has been linked into the ghc(i) executable
03:54:10 <michaelw> Igloo: okay, then it probably will work that way.
03:55:12 <juhp> Itkovian: hm, sounds like a pretty minimal install :)
03:55:38 <Itkovian> well, it's not a desktop machine, but still.
03:55:45 <Itkovian> fedora's supposedto be bloated ...
03:55:52 <juhp> heh
03:57:29 <Itkovian> is ghc bootstrappin fubar?
03:57:36 <Itkovian> I've got the 6.2.2 sources
03:58:04 <juhp> Itkovian: ah, you mean readline-devel and gmp-devel ?  then I understand
03:58:45 <Itkovian> prolly, yeah. I'm a fedora newbie :-)
03:59:03 <Itkovian> and proud of it
03:59:07 <Itkovian> :-)
03:59:59 <Itkovian> trying the latest 6.3
03:59:59 <juhp> Itkovian: actually I was having trouble bootstrapping ghc i386 too the other day
04:00:11 <Itkovian> ah, and what did you do with it?
04:00:29 <Si\> does anyone know if (?) :: Bool -> (a,a) -> a is defined anywhere in the GHC HEAD library tree?
04:00:31 <juhp> for x86_64 I had to do it several times until I finally got it right...
04:01:56 <Itkovian> juhp: hmmm ...
04:02:47 <juhp> Itkovian: I have to try again - with unregisterised I think?
04:04:16 <juhp> Itkovian: I want to bootstrap to get ghc added to Fedora Extras
04:04:42 <Itkovian> juhp: i tried with unregistered ... no luck
04:04:47 <juhp> hmm
04:05:25 <juhp> hmmm, it would be strange if it can be bootstrapped on x86_64, but not i386...
04:05:52 <Itkovian> well, I have set the i386 config ...
04:06:13 <Itkovian> that is, I've entered an x86_64 entry with the same settings as the i386 stuff ...
04:06:18 <Itkovian> using -m32
04:07:10 <Itkovian> http://tunes.org/~nef/logs/haskell/04.11.05
04:08:23 <Itkovian> http://www.haskell.org/ghc/docs/latest/html/building/sec-building-from-source.html
04:13:34 <juhp> Itkovian: someone posted a mail about using -m32 recently on x86_64 iirc
04:14:31 <Itkovian> on the cafe list?
04:15:34 <juhp> http://www.haskell.org//pipermail/glasgow-haskell-users/2004-October/007255.html
04:15:46 <juhp> darcs I think
04:16:39 <Itkovian> yeah, but those are options to apss to ghc ...
04:16:50 <Itkovian> and that thing hasn't built yet ...
04:20:27 <juhp> Itkovian: have you tried one of the binary tarballs on the ghc download page?
04:27:51 <juhp> Itkovian: how big is your bootstrap hc tarball?
04:29:27 <Itkovian> juhp: yes, I've d/l'd the 6.2.2 tgz i386, but it needs libreadline ... hmmm, thus not devel, I think ...
04:29:48 <Itkovian> 5406427 Oct 20 16:45 ghc-6.2.2-src.tar.bz2
04:31:05 <juhp> Itkovian: I mean ghc-6.2.2-i386-unknown-linux-hc.tar.gz
04:31:19 <Itkovian> ah
04:31:21 <juhp> mine is 6911810
04:31:28 <Itkovian> 15526161 Jan 17 17:00 ghc-6.2.2-i386-linux-glibc2.2.tar.bz2
04:31:38 <Itkovian> maybe I don;t need the glibc 2.2
04:31:40 <Itkovian> aha!
04:31:43 <Itkovian> lets' try that
04:32:21 <juhp> Itkovian: well you probably want the glibc 2.3 binary, but I'm talking about the i386 bootstrap file I generated
04:32:28 <Itkovian> the minute i d'ld that tarball, i thought to myself ...
04:32:50 <Itkovian> dang i'm confsed and unattentive. sorry
04:33:07 <juhp> (not that my bootstrap file seems to work, but I think it is about the right size)
04:33:13 <juhp> Itkovian: no worries
04:33:35 <jlouis> ghc-6.2.2-i386-unknown-freebsd5-boot.tar.bz2 is what I am bootstrapping with
04:34:02 <juhp> anyway I trying to bootstrap now again with unregistered and separate target and host trees...
04:34:27 <Itkovian> where the heck do I find that tarball?
04:34:38 <swiert> is there a Prelude function of type [a->b] -> [a] -> [b]?
04:34:57 <juhp> Itkovian: I don't think it is available anywhere afaik
04:35:28 <juhp> so I "rolled" my own
04:35:32 <Itkovian> swiert: some form of zip?
04:35:40 <TheHunter> @type zipWith id
04:35:42 <lambdabot> zipWith id :: forall b c. [b -> c] -> [b] -> [c]
04:35:50 <Itkovian> juhp: and how does one do that
04:35:57 <juhp> :)
04:36:06 <juhp> http://haskell.org/ghc/docs/latest/html/building/sec-porting-ghc.html
04:36:13 * Itkovian has to pay more attention to 'id'
04:36:18 <swiert> obviously, I was wondering if it has some obscure name I didn't know.
04:36:37 <TheHunter> Itkovian, the id in this case is actually a ($)
04:36:45 <Asta> id works fine, but maybe ($) is more intuitive
04:37:50 <swiert> look at the types - id : a -> a
04:38:05 <swiert> $ :: (a->b) -> (a->b)
04:40:36 <TheHunter> hmm, there's also ap :: [a -> b] -> [a] -> [b]
04:41:18 <pesco> Where is ap?
04:41:27 <TheHunter> Control.Monad
04:41:50 <pesco> I see.
04:44:49 <juhp> Itkovian: not sure, but if you make an appropriate symlink and tricks with LD_LIBRARY_PATH you may be able to get away with no readline-devel and gmp-devel
04:45:17 <Itkovian> I tracked down the sysadmin ...
04:45:23 <Itkovian> I hope I'll be fine :-)
04:46:48 <swiert> TheHunter: the list monad doesn't behave the way I want it to. I want the zipWith id.
04:47:24 <Itkovian> @type zipWith id
04:47:25 <lambdabot> zipWith id :: forall b c. [b -> c] -> [b] -> [c]
04:47:28 <Itkovian> @type zipWith ($)
04:47:29 <lambdabot> zipWith ($) :: forall b b1. [b1 -> b] -> [b1] -> [b]
04:48:45 <Itkovian> I am wondering.
04:49:05 <Itkovian> Is there, in practive a difference between ($) and id ?
04:50:10 <TheHunter> @type id 4
04:50:12 <lambdabot> id 4 :: forall a. (Num a) => a
04:50:16 <TheHunter> @type ($) 4
04:50:17 <lambdabot> ($) 4 :: forall b a. (Num (a -> b)) => a -> b
04:50:39 <Itkovian> that's true ...
04:50:41 <TheHunter> apart from that (and precedence), there should be no difference.
04:51:17 * shapr bounces cheerfully
04:52:11 <swiert> shapr: I wrote up some thoughts about The Monad Reader on the wiki.
04:52:16 * shapr looks
04:52:38 <shapr> Ah yes, I've read that, and I've thought about it.
04:53:18 <shapr> I think a BSD license is better so that any useful snippets can be included in GHC/Hugs/whatever.
04:53:35 <Itkovian> @wiki TheMonadReader
04:53:35 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
04:54:03 <shapr> I'd like a TMR that appeals to both academic and professional Haskellers.
04:54:53 <swiert> I'm not picky about licenses - as long as people have the possibility of copying, and using the articles.
04:54:58 <shapr> Of course, that totally fits into what you said about apps that deserve more attention.
04:55:02 <Itkovian> woot! http://yro.slashdot.org/yro/05/02/02/2258230.shtml?tid=155&tid=17
04:55:46 <shapr> Yeah, that should be the idea behind whatever license is used.
04:55:54 <pesco> Itkovian: Woot!
04:56:53 <swiert> shapr: I think it appeal to anyone using Haskell - academic, in industry, or just for the heck of it.
04:57:15 <shapr> I'd rather start TMR with as much content as is ready in time, and hope that a wealth of quality articles encourages more people to write articles.
04:58:25 <shapr> I am leaning towards LaTeX myself.
04:58:26 <swiert> but you'll run the risk of having a serious lack of author's for the second issue.
04:58:43 <shapr> That's a possibility, but I'd rather a wealth of content to show that it can be done.
04:58:50 <swiert> oh - there is at least one tool to generate html from latex files.
04:59:50 <shapr> There a lot more activity in the Haskell community than can realistically be covered by a monthly eZine. I actually think more authors and articles are likely in the future.
05:00:24 <Itkovian> ok I can forget about readline ... it's on there but in 64-bit mode. aaargh.
05:01:05 <swiert> the trouble is I think a lot of author's have fairly pressing other commitments - academics need to write other papers, people in industry have their own deadlines.
05:01:35 <shapr> True, but there's a lot of room for content that's something between a wiki page and the HC&AR.
05:01:40 <swiert> I don't want to disagree with the fact that the Haskell community is very acitve
05:01:41 <Igloo> Lemmih: I'm more here now if you still want me?
05:02:32 <swiert> I'm not sure how many people have enought time/interest to contribute.
05:03:12 <Lemmih> Igloo: Nevermind (:
05:03:55 <shapr> I think lots of library and application authors would like to expound on the virtues of what they've written, improvements in the latest versions, etc. And there's *lots* of room for academic papers recast into something friendlier like the Nomaware tutorial.
05:04:15 * boegel leaves
05:04:15 <boegel> bye
05:04:16 <shapr> bye!
05:04:21 <shapr> boegel: come back soon! ;-)
05:04:23 <swiert> Definitely.
05:04:52 <boegel> shapr: I probably will, because I would like to get the image part of my GUI working, and I think I'll need duncan for that :)
05:04:59 <shapr> oh, do you have new screenies?
05:05:13 <boegel> shapr: there's not much more to show :)
05:05:18 <shapr> ok... I'll be patient :-)
05:05:28 <boegel> hehe
05:05:33 <boegel> tata !
05:05:53 <swiert> The risk you'll be running is having one or two great issues, and then a lack of copy.
05:06:12 <swiert> But that is up to you of course!
05:07:58 <kosmikus> I'm with swiert on this
05:08:04 <shapr> I think that four regular authors could keep up an interesting monthly periodical. Anything more than that is a bonus.
05:09:49 <shapr> Well, I hope I can surprise you :-)
05:09:55 <Philippa> oh, one can - you just don't want to read anything written shortly beforehand
05:10:00 <pesco> We must make it clear that everyone is supposed to contribute articles.
05:10:43 <Philippa> (blame Binkley's recent poll for that one)
05:10:45 <shapr> Even if it takes three months for someone to write an article, if there are ten people doing that, it'll be great.
05:12:13 <shapr> I could write a very long list of article ideas. There's an amazing variety in this community.
05:12:59 <swiert> I completely agree with you. There's a lot too write about and a lot of people willing to write.
05:13:12 <pesco> Also everyone always has some ideas they're working on or pondering about. Maybe that's the difference between scientific papers and TMR articles.
05:13:32 <shapr> Right, feel free to write about incomplete or exploratory ideas.
05:13:35 <swiert> The thing is people usually have less time than they would like.
05:13:48 <shapr> But probably enough time to write something short.
05:14:06 <Itkovian> juhp: I've got the binary version working, I rolled my own readline ...
05:14:07 <Philippa> yep. Actually implementing Tyop is taking me too damn long even though I've got the ideas clearly formed now :-(
05:14:16 <shapr> I've been itching to write a type tricks articles on ways and means of producing value types, bounded lists, etc
05:14:41 <juhp> Itkovian: kule :)
05:14:45 <Philippa> shapr: I'm gonna have to write a nice lil' appendix full of those when I finally hand in the dissertation on Tyop
05:14:49 <samc_> Or how you came to an idea--that's missing from acedemic papers
05:14:58 <Philippa> yeah, and often useful
05:15:01 <shapr> Right, papers often leave out the process.
05:15:16 <Philippa> the whole "I spotted this really deep connection from which the inspiration came" bit should really be shared
05:15:21 <shapr> I asked John Hughes how he had the realization about arrows, and that really helped me understand them.
05:15:29 <Philippa> the problem is it's apparently "not scientific" because it's all subjective and comes before you prove the link
05:15:37 <Itkovian> now ... darcs ...
05:15:40 <Philippa> how did he, anyway?
05:15:52 <shapr> I'll ask him to write an article ;-)
05:16:17 <pesco> Usually when I start writing down a short summary of some idea I had, I often automitacally end up with something that could well be close to an article.
05:16:23 <jlouis> Haskell rocks
05:16:29 <jlouis> 'nuff said
05:16:47 <Philippa> no, not 'nuff said. There're far too many cool ways to use it that not everybody knows about
05:16:49 <juhp> Itkovian: btw there are rpms on Fedora Haskell in a yum repository... :)
05:16:49 <shapr> He wrote the type signature of a monad and swierstra&duponcheel's parser above each other on the whiteboard, and he made a few hand gestures, and tada!
05:16:56 <Philippa> hehehe
05:17:07 <Itkovian> juhp: yes, but I've got no administrative rights ...
05:17:10 <Philippa> okay, that I can believe
05:17:28 <jlouis> is there a good paper describing arrows?
05:17:37 <juhp> Itkovian: right - just in case :)
05:17:44 <jlouis> it seems it is the next thing I must read up upon after reading about the STG-machine
05:17:47 <shapr> Ross Paterson's Fun of Programming chapter is the most comprehensive arrow writing.
05:18:03 <Philippa> and Hughes' paper is sometimes good for the categorical insights IIRC
05:18:19 <jlouis> I'll go with Hughes paper then, heh
05:18:27 <shapr> Right, start with Paterson's chapter and then find details in Paterson's and Hughes' earlier papers.
05:18:31 <Philippa> go with both, the FoP chaper's far more practical
05:20:08 <shapr> I asked Alistair Bayley to write a summary article describing his view of the differences between FP and OO. He wrote FpVsOo on WardsWiki, and I learned quite a bit from reading that page. He also said that his views don't follow that page since he's learned more.
05:20:37 <shapr> Of course I'm desperately curious what his views are now.
05:20:50 <jlouis> The differences between OO and FP?
05:21:00 <jlouis> You cannot compare that in my world
05:21:04 <shapr> Right, sounds obvious and simple, but some points surprised me.
05:21:35 <shapr> Like, FP only has value equality, but no other identity. Identity is very central to OO.
05:21:42 <Philippa> yeah, that's a biggie
05:21:42 <jlouis> OO is not a programming paradigm. It is more a way to meta-program an (often imperative) language
05:21:54 <Philippa> not true
05:22:05 <Philippa> C++ and Java ain't the only way to do OO
05:22:14 <Philippa> something like Self is fairly clearly "not just imperative"
05:22:30 <jlouis> Well, OO is not well-defined
05:22:35 <shapr> Yeah, Self is programming that big Object in the sky.
05:22:35 <Philippa> nor's FP, your point?
05:22:59 <jlouis> Philippa: that you shouldn't compare them
05:23:08 <jlouis> because you do not actually know what you are comparing
05:23:18 <shapr> But what about OOHaskell?
05:23:38 <Philippa> I may know exactly what I'm comparing, even if you don't :-)
05:23:49 <jlouis> exactly. Are they even mutually exclusive? Probably not
05:24:01 <Philippa> but I can describe it well enough
05:24:10 <Philippa> "Identity matters" is pretty universal in OO
05:24:28 <Philippa> so's "records with extras are our main datatype"
05:25:01 <shapr> So I guess I have to learn LaTeX very quickly. And all the authors have to learn darcs, which should take about thirty seconds each.
05:25:20 <Philippa> er, OK, what's going on? What do I need to know?
05:25:31 <Philippa> (I'm doing something other than raw wiki text?)
05:25:51 <pesco> Learning darcs was one of my most pleasant experiences last year.
05:25:53 <shapr> Pseudonym said that the advantages of wiki publishing were present in shared darcs repos. I agree with him.
05:26:47 <Philippa> hrmm. You largely lose the possibility of running your own forums/space for comments though
05:26:49 <shapr> Philippa: you can write in raw wiki text if you want, I'll reformat it into LaTeX and ask you to check to see if I've misrepresented something with bad layout.
05:27:10 <Philippa> 'sok, I know LaTeX - I just need to know what we're standardising on style-wise
05:27:13 <shapr> Philippa: how so?
05:27:16 <Philippa> (not to mention paper-size-wise)
05:27:37 <Philippa> with a Wiki, you can have an ArticleNameComments or ArticleNameDiscussion page, open to the public
05:27:43 <shapr> I'd think every article could have a HaWiki page for reader responses.
05:28:04 <shapr> We could put the link into the article itself.
05:28:05 <Philippa> I guess so, having the articles themselves somewhere else doesn't encourage people to view the HaWiki pages so much though
05:28:27 <Philippa> that said, is there a good fix for formulae in wiki pages yet?
05:28:49 <shapr> inline LaTeX or MathML
05:29:42 <shapr> jlouis: you want to write an article for TMR?
05:29:53 <Philippa> will there be a HaWiki "this month's issue" page linking to all the LaTeX once it's released, or anything similar?
05:29:55 <juhp> oh, goodie my new bootstrap file is 7794538
05:30:00 <juhp> bytes
05:30:10 <Philippa> stretch that floppy! :-)
05:30:30 <shapr> Philippa: If that's good for the community, sure.
05:30:47 <shapr> You think I know what I'm doing? I'm just making it up as I go along. ;-)
05:30:49 <musasabi> mathml is iirc quite painfull.
05:31:03 <Philippa> I imagine it would be a good thing
05:31:07 <musasabi> Using latex is easiest for people writing the articles probably.
05:31:15 <Philippa> especially as it can hide the darcsness from casual readers
05:31:17 <shapr> musasabi: yeah, MathML doesn't seem quite ready yet.
05:32:59 <jlouis> shapr: TMR?
05:33:04 <shapr> @wiki TheMonadReader
05:33:04 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
05:33:06 <kosmikus> using LaTeX has the potential of producing the best-looking end result, but if you want the article authors to deliver the articles in LaTeX, prepare for a lot of editing or make very concise style guidelines and hope that the authors read them
05:33:44 <shapr> kosmikus: I've never used LaTeX before. Pseudonym suggested that a stylesheet be set ahead of time. Any suggestions for stylesheets?
05:34:14 <Philippa> also, what formats're we planning on distributing for, bearing in mind that not only do most folks not know what to do with LaTeX, some don't with postscript either and many are stuck with Acrobat Reader which inspires absolute hatred
05:34:17 <Itkovian> oh man ... darcs om x86_64 in 32 bit mode is hell
05:34:46 <shapr> So, I want all TMR authors to have a definite subject by Monday. That's the end of the first week. Then two weeks to write it, and the last week for panic.
05:35:07 <jlouis> shapr: hmmm, what should I write about?
05:35:24 <shapr> I was planning on html first and foremost, and PDF and/or PS second.
05:35:26 <jlouis> How imperative programming mixed with functional programming is stealing my time in Standard ML?
05:35:41 <kosmikus> shapr: actually, no. most journals have style sheets, but they probably look a bit too dry for TMR, and they don't necessarily have an open license
05:35:44 <shapr> jlouis: how do you connect that to Haskell?
05:35:55 <kosmikus> shapr: best thing would be to design one specifically for TMR
05:35:57 <Igloo> Clearly before you start writing articles you need to write a higher order functional typesetting language
05:36:03 <shapr> aieee
05:36:42 <kosmikus> shapr: but I guess this is also something which could grow over the first few editions
05:37:01 <shapr> kosmikus: I am not convinced that I will be able to design a LaTeX stylesheet in time for the first issue.
05:37:10 <Philippa> Igloo: give or take the complete lack of purity, isn't TeX fairly close to that already?
05:37:22 <kosmikus> shapr: I'm quite busy at the moment, but in principle, I could help
05:37:26 <Igloo> TeX is pain in software form
05:37:30 <Philippa> shapr: I've got mine
05:37:39 <shapr> "pure liquid evil" is the Igloo quote.
05:37:59 * boegel needs duncan
05:38:06 <shapr> mars needs women.
05:38:11 <boegel> or maybe someone can help me...
05:38:18 <boegel> ghc complains on this:
05:38:31 <boegel> foreign import ccall unsafe "gdk_pixbuf_get_pixels"  
05:38:32 <boegel> 	gtk_pixbuf_get_pixels :: Ptr Pixbuf -> IO (Ptr Word8)
05:38:32 * Igloo is hoping nonpareil will turn into something good, although there is still a hurdle of acceptence even if it is
05:38:37 <jlouis> shapr: dunno how I connect it to haskell. I do not know what to write about, honestly
05:38:37 <araujo> Good morning all.
05:38:43 <boegel> hey araujo 
05:38:58 <araujo> How you doing boegel ?
05:39:03 <kosmikus> from what I read about nonpareil so far, I'm not convinced it will every do anything at all :)
05:39:08 <shapr> jlouis: well, what do you like about Haskell? What cool things have you used in Haskell? How does it compare to other things of the same nature?
05:39:13 <boegel> araujo: messing around with gtk2hs :)
05:39:17 <araujo> Hello kosmikus :-)
05:39:24 <kosmikus> hi there
05:39:30 <boegel> is there something wrong with this syntax ?
05:39:37 <jadrian> shapr: CodeKatas :)
05:39:41 <jadrian> shapr: nice
05:39:54 <araujo> boegel, cool, i saw yesterday a good book for GTK+ i the bookstore, though for C 
05:40:06 <boegel> @index Word8
05:40:08 <lambdabot> Data.Word,Foreign,GHC.Word,Word
05:40:09 <jlouis> shapr: I have used too little of the cool stuff. Most of what I do has been done in Standard ML. And that is a whole other world. It is non-pure, strict, and awfully fast
05:40:24 <juhp> boegel: you have gtk and gdk in the same line?
05:40:25 <jlouis> But that is too a very big disadvantage
05:40:31 <shapr> jadrian: you want to write the first CodeKata article?
05:41:01 <jadrian> shapr: got about 2 weeks to finish my MSc thesis :(
05:41:12 <shapr> Ok, I'll bug you next issue.
05:41:19 <jadrian> shapr: k :)
05:42:07 <boegel> juhp: it's not my line of code... ghc gives this as an error:
05:42:18 <boegel> gtk2hsTest.lhs:57: parse error on input `import'
05:42:41 <Igloo> What's that line?
05:43:11 <boegel> it's supposed to be a binding to the gtk library
05:43:41 <jlouis> What about a CodeKata where you implement all-pairs-shortest-path algorithms. They allow for some nice fleshing out with matrix-libraries
05:43:43 <shapr> Ok, darcs repos for the articles, LaTeX for the format, first issue is released from the cage on March 1st
05:43:47 <musasabi> boegel: do you suply -ffi to ghc?
05:43:48 <jlouis> and funny ZSP algebras
05:43:54 <boegel> musasabi: no
05:43:56 <boegel> should I ?
05:44:10 <musasabi> boegel: if you use foreign import ... then yes.
05:44:31 <shapr> jlouis: Can you have it written in two weeks? :-)
05:44:52 <boegel> musasabi: ok thanks... is there a way to get it to work in ghci too ?
05:44:53 <juhp> fsck! - get the same error again with the bootstrapped build of ghc :-(
05:45:00 <jlouis> shapr: probably
05:45:25 <shapr> jlouis: You gotta stick one way or the other by Monday.
05:45:32 <musasabi> boegel: give -ffi to ghci?
05:45:47 <juhp> gmake[2]: *** No rule to make target `stage1/deSugar/DsMeta.o', needed by `stag\e1/ghc-6.2.2'.  Stop.
05:45:58 <shapr> jlouis: it sounds cool, I haven't used the Haskell matrix libs much, and I would like to know how to use them.
05:45:59 <jlouis> shapr: ok, I'll bite and see if I can write something up 'till monday to see if it is good enough
05:46:07 <shapr> awright, spiffy!
05:46:07 <jlouis> shapr: me too ;)
05:46:18 <musasabi> juhp: bootstrapping should supposedly become easier with 6.4.
05:46:43 * juhp has a distinct feeling of deja vu from when he bootstrapped for x86_64
05:46:59 <juhp> musasabi: that is indeed nice to hear :)
05:47:15 <shapr> There's software that runs some high-tech nike shoes, I wonder what they called it... sneakerstrapping?
05:47:18 <boegel> musasabi: thanks :)
05:48:44 <Igloo> What are you trying to compile for?
05:49:12 <shapr> jlouis: can you send me an email? shae@scannedinavian.com (and yes, I know my anti-spam system is irritating)
05:50:08 <juhp> Igloo: to get ghc into the Fedora Extras buildsystem :)
05:50:17 <shapr> Ok, I shall announce this unrealistic plan on haskell@haskell.org once I've filled more details into the TMR wiki page.
05:50:21 <juhp> Igloo: oh, i386
05:50:33 <duncan> boegel: alternatively put {-# OPTIONS -fffi #-} at the very top of your module
05:50:51 <Igloo> Oh, odd, I thought that should work
05:51:01 <jlouis> miracle$ echo "Yes, I can" | mail -s mail_to_shapr shae@scannedinavian.com
05:51:09 <boegel> duncan: heya :)
05:51:42 <duncan> boegel: hi. having any success with that gui code?
05:51:45 <juhp> Igloo: yeah it should, however I have niggling feeling I have to run "make" in the top dir or ghc/ to get it to bootstrap on x86_64
05:51:56 <juhp> s/have/had/
05:51:56 <boegel> duncan: I'm getting a weird error now... 
05:52:05 <boegel> gtk2hsTest.lhs:82: Data constructor not in scope: `Pixbuf'
05:52:20 <boegel> while it have used Pixbuf before, and it doesn't complain there
05:52:21 <Igloo> juhp: You are following the bootstrapping guide, right?
05:52:28 <juhp> Igloo: yeah
05:52:35 <shapr> jlouis: awright, I have your email address.
05:52:41 <musasabi> boegel: Pixbuf as type or as a constructor?
05:52:42 <Igloo> That should be complete, then
05:52:48 <jlouis> shapr: check ;)
05:53:32 <juhp> Igloo: I think I've followed it to the letter (except the bit on H/mk/config.mk)
05:53:40 <boegel> musasabi: as type I guess, but Pixbuf isn't even in the line ghc points to
05:53:51 <juhp> but this is i386 -> i386
05:54:25 <jlouis> Heh, supposedly my last change fixes the bug I've had for about 1.5 months
05:55:45 <Lunar^> shapr: do you have a Debian near you ?
05:55:56 <shapr> Lunar^: yes!
05:56:11 <shapr> My desktop runs debian/unstable.
05:56:12 <Lunar^> shapr: want to try HFuse out ?
05:56:23 <shapr> sure! You want to write about HFuse in TMR?
05:56:28 <Lunar^> TMR ?
05:56:40 <shapr> @wiki TheMonadReader
05:56:40 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
05:57:14 <Lunar^> How cool :)
05:57:22 <Lunar^> Yes, I think I could :)
05:57:25 <shapr> excellent!
05:59:29 <Lunar^> shapr: d'oh... I did not finish the getArgs to argv conversion
05:59:39 <shapr> swiert: Mind if I hack your text into the intro to TMR?
05:59:52 <jlouis> no, didn't fix it, but I found out that my path compression algorithm sucks (ie. Is-nonexistent ;)
05:59:56 <Lunar^> shapr: I'll get you a hand on this when this will be done
06:00:03 <shapr> Lunar^: ok, cool.
06:00:45 * Lunar^ wonder how GTK2HS does this
06:06:03 <juhp> Lunar^: does what? :)
06:07:03 <jlouis> Totally side question: How good is the keyboard layout on a Mac iBook + Friends?
06:07:33 <boegel> Lunar^: what's HFuse ? A GUI library too ?
06:07:50 <Lunar^> juhp: getArgs to argc/argv.. I've found it
06:08:08 <juhp> ah
06:08:09 <Lunar^> boegel: FUSE is a Linux module/lib to implement Filesystems in USErspace
06:09:21 <Lunar^> boegel: HFuse in an Haskell binding for FUSE
06:09:57 <shapr> c'est parfait pour Yi
06:10:14 <Lunar^> shapr: why ?
06:10:34 <shapr> parceque c'est emacs tramp pour Yi
06:11:07 <boegel> shapr: parce-que :)
06:11:20 <shapr> HFuse and HVFS will let me treat an ssh, scp, or whatever connection just like a file.
06:11:36 <boegel> foreign import ccall unsafe "gdk_pixbuf_get_pixels"  
06:11:40 <boegel> 	gtk_pixbuf_get_pixels :: Ptr Pixbuf -> IO (Ptr Word8)
06:11:45 <shapr> Or a gmail account, if I used CosmicRay's recent python bindings.
06:12:03 <boegel> should I do anything else especially to get this working ? ghci is still complaining
06:12:13 <boegel> During interactive linking, GHCi couldn't find the following symbol:
06:12:13 <boegel>   gdk_pixbuf_get_pixels
06:12:13 <boegel> This may be due to you not asking GHCi to load extra object files,
06:12:13 <boegel> ...
06:15:09 <juhp> boegel: how are you invoking ghci?  you're binding this function yourself?
06:15:35 <boegel> juhp: it works with ghc, but not with ghci...
06:16:32 <boegel> shapr: new screenshot: http://studwww.ugent.be/~kehoste/gtk2hs-2.png
06:16:48 <shapr> looks nice!
06:16:49 <boegel> but the red default image disappears when the window loses focus...
06:17:01 <boegel> shapr: ow I'll try to get a _real_ image in there
06:17:22 <juhp> boegel: oh cool - it is red now! ;)
06:17:48 <samc_> jlouis, I'm on a powerbook but I don't know what you mean, can you not just look at a pic?
06:17:58 <boegel> juhp :p
06:18:55 <boegel> the scrolling doesn't seem to be working either dough... :(
06:19:07 <juhp> boegel: other gtk2hs stuff is working ok for you in ghci?
06:19:09 <jlouis> samc_: if I could find one, yes ;)
06:20:17 <juhp> boegel: have you tried to use c2hs to bind that function?
06:21:14 <juhp> boegel: I can send you gtk/Graphics/UI/Gtk/Gdk/Pixbuf.hs if it might help
06:21:35 <juhp> but you probably built it yourself?
06:25:19 <boegel> no, I'm just trying out gtk2hs
06:25:30 <boegel> I got some help from duncan and someone else on the gtk2hs list
06:25:44 <boegel> everything else is working in ghci yes...
06:25:45 <juhp> yeah, I saw :)
06:25:49 <boegel> oh, okay :)
06:25:51 <juhp> ok, cool
06:26:01 <boegel> but for now I'll keep working with ghc
06:27:12 <pesco> jlouis: Make _suer_ you get the _US_ layout. The others have crippled Return and left Shift keys.
06:27:25 <pesco> (because of the one useless extra key)
06:28:16 <juhp> boegel: which os btw?
06:32:44 <swiert> shapr: feel free to use/adapt my wiki text.
06:32:50 <shapr> thanks!
06:33:31 <samc_> pesco, what key is that?
06:35:21 <boegel> juhp: Fedora Core 3
06:35:27 <pesco> <LSGT> I guess.
06:35:35 <juhp> boegel: :)
06:36:16 <pesco> Which is of course only useless if you don't plan on typing on a non-us keymap anyway.
06:37:50 <samc_> I take it if I don't know what <LSGT> is I have a US layout then
06:38:20 <boegel> how do I exclude types from being imported ?
06:38:21 <pesco> On German keyboards, for instance, it's a key that has '<' and '>' on it.
06:38:28 <boegel> gtk2hsTest.lhs:66:
06:38:29 <boegel>     Ambiguous occurrence `Solid'
06:38:29 <boegel>     It could refer to either `HRayData.Solid', imported from HRayData at gtk2hsTest.lhs:9
06:38:29 <boegel>                           or `Graphics.UI.Gtk.Gdk.Enums.Solid', imported from Graphics.UI.Gtk at gtk2hsTest.lhs:3
06:38:37 <boegel> I want to use my Solid (the top one)
06:38:55 <boegel> name clashes suck :(
06:40:59 <TheHunter> use import Foo hiding (Solid)
06:41:08 <boegel> TheHunter: thanks
06:41:32 <TheHunter> you can also qualify the import: import qualified Foo as F
06:41:55 <musasabi> or do both:
06:42:01 <musasabi> import Foo hiding (Solid)
06:42:07 <bourbak1> moin
06:42:10 <musasabi> import qualified Foo as F (Solid)
06:42:12 <pesco> samc_: The UK layout has an extra key for "paragraph" and "plusminus".
06:42:42 <boegel> what does qualify mean ? use only the types specified?
06:42:55 <bourbak1> hey boegel
06:43:17 * Itkovian has emerge gtk2hs
06:43:20 <autrijus> no, it means "full name".
06:43:33 <Itkovian> boegel, start hoping yr screenshot is generated by actual code ;-)
06:43:37 <autrijus> "always address 'blah' in Foo as 'F.blah', instead of 'blah'"
06:44:03 <autrijus> actually, s/blah/Solid/.
06:48:03 <boegel> Itkovian: is that so hard to believe ? :)
06:48:20 <Itkovian> no
06:49:53 <boegel> @index fromIntegral
06:49:53 <lambdabot> GHC.Real,Prelude
06:50:00 <pesco> Wow, all my X fonts just got much prettier! This is cool.
06:50:17 <shapr> hej phubuh!
06:50:29 <shapr> vill du skriva en artikel för Den Monad.Reader?
06:50:36 <shapr> pesco: what did you do?
06:51:28 <boegel> how can I convert a Double to a Word8 ?
06:52:16 <pesco> shapr: Update to the latest version.
06:53:03 <shapr> boegel: not sure, maybe something in Foreign or NumExts?
06:53:03 <boegel> fromIntegral (round x) with x :: Double works, but is there a way to achieve this in a different way ?
06:53:55 <pesco> shapr: (of X)
06:54:34 <shapr> I look forward to X.org reaching debian/unstable.
06:55:00 <Itkovian> eh?
06:55:10 <Itkovian> X.org is quite stable :-_)
06:59:01 <Itkovian> find /opt/ghc/lib/ghc-6.2/gtk2hs/ -name "Graphics" ? anybody tried on gentoo to emerge gtk2hs?
06:59:29 <pesco> Itkovian: No, but I can try if you want.
06:59:44 <juhp> Itkovian: is it 0.9.7?
07:00:03 <Itkovian> erm, let me check
07:00:42 <Itkovian> shit no
07:00:49 <Itkovian> 0.9.6 is the latest in portage
07:00:59 <shapr> y0 Coz
07:01:09 <Itkovian> it emerges all right, but using it doesn't work too well :-)
07:01:15 <Itkovian> at least not with boegel's code
07:02:19 <jak> Is it possible to write this: [x, y] <- liftM (map read) getArgs
07:02:25 <jak> any more succinctly?
07:02:53 <jak> (where getArgs is getArgs :: IO [String] which returns the list of arguments to the process)
07:06:25 <juhp> Itkovian: I recommend updating to 0.9.7 - it has loads of fixes and improvements :)
07:06:34 <TheHunter> you can replace liftM by fmap, but that's probably the shortest you can get
07:06:55 <TheHunter> it's a pity there's no readM :: Read a => String -> m a in the libs.
07:07:14 <CosmicRay> hey shapr
07:09:23 <CosmicRay> shapr: I believe I will have MissingPy ready to release by the weekend
07:09:43 <CosmicRay> I've almost got the DBM interfaces done, gzip and bzip2 are already done.  I just want to do zipfile and tarfile yet.
07:09:46 <shapr> excellent!
07:10:06 <CosmicRay> also I have to figure out how to make haddock obey my bidding.
07:10:18 <shapr> That fish is a difficult one to train.
07:10:22 <CosmicRay> heh
07:10:38 <shapr> lambdabot uses Haddock in @index, and it's not pretty.
07:10:43 <CosmicRay> I want to generate a master doc so I can have crossreferences between MissingH and MissingPy
07:10:56 <shapr> Fish bits stuck all over the sides of that module.
07:10:56 <CosmicRay> I know vaguely how to do it from reading ghc sources
07:10:59 <CosmicRay> heh
07:11:35 <CosmicRay> but I have some issues -- mainly that haddock chokes on both lhs and hsc files
07:11:40 <CosmicRay> cabal helps with that
07:11:46 * shapr is liberally hacking Wouter's text into an intro to The Monad.Reader
07:12:00 <CosmicRay> but cabal doesn't let me customize what args i send to haddock
07:19:19 <shapr> What's the magic 8-ball response? "Answer Hazy, please try again." ?
07:32:53 <Itkovian> @wiki TheMonadReader
07:32:54 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
07:33:00 <shapr> yay!
07:49:22 * Lemmih wonders whether to sacrifice subtyping or overloading in Hacanon.
07:51:11 <autrijus> subtyping, as in C++ inheritance?
07:51:55 <Lemmih> Yes.
07:54:42 <autrijus> why you have to sac one?
07:56:27 <Lemmih> Consider two classes, each with the method 'void someMethod(void);'.
07:59:22 <Lemmih> Sorry. Had to leave for a moment.
07:59:57 <Lemmih> We would like to overload that method name.
08:00:20 <Itkovian> i'm off ...
08:00:30 <autrijus> bbiab too.
08:00:32 <shapr> and I'm leaving too...
08:00:40 <autrijus> mmm synchronicity
08:00:42 <Lemmih> Damn, I must be boring.
08:00:46 * shapr grins
08:00:55 <shapr> It's a bad joke. "I'm off. And I'm leaving too."
08:01:09 <shapr> Like, "That guy is a little bit off."
08:01:25 * shapr suspects his lack of sleep is obvious yet again.
08:01:47 <jlouis> hehe
08:02:20 <Lemmih> Anyhow, without overloading it might look like this: someMethod :: (SubClass a) => a -> IO ()
08:03:52 <duncan> Itkovian: gtk2hs 0.9.7 is in portage as ~x86. I know 'coz I added the ebuild! Also, boegel's code uses some functions that are not yet in any released version you'd have to copy all the extra bits
08:04:06 <Lemmih> One could add overloading with yet another typeclass: class OverloadSomeMethod this arguments result | this arguments -> result
08:05:14 <Lemmih> But 'instance (SubClass1 a) => OverloadSomeMethod a () (IO ())' and 'instance (SubClass2 a) => OverloadSomeMethod a () (IO ())' are duplicate.
08:06:11 <musasabi> inheriting and overloading the same method is a very bad habit in C++.
08:07:46 * shapr tries to work function names from Monad.Reader into the advertising blurb.
08:08:40 <Lemmih> musasabi: But possible non the less.
08:10:08 <Lemmih> musasabi: My two example classes didn't inherit anything, btw.
08:11:01 <musasabi> Lemmih: yes, and that means one can use most of the time one of the systems.
08:11:15 <musasabi> but when the general case happens there is no way out.
08:14:13 * Lemmih adds yet another class to make it possible but horrible to use directly.
08:15:11 <boegel> duncan: back already ?
08:16:02 <boegel> duncan: the version Itkovian has is the simple version, without the image part working... that version doesn't use anyof the special stuff yet
08:17:41 <boegel> you b*stard !
08:17:41 <boegel> :p
08:18:02 * shapr sniffles
08:18:06 <shapr> I didn't do nuthin!
08:18:15 <boegel> are there library's for Haskell to convert a PPM file to a JPG ?
08:18:20 <boegel> (or GIF)
08:18:33 <shapr> Not that I know of, but netpbm can do that.
08:18:54 <musasabi> system "convert foo.ppm foo.jpg"
08:19:08 <boegel> shapr: i should have a function to do that for me which I can use from within a Haskell program...
08:19:19 <boegel> aha ! :)
08:24:10 <boegel> hey duncan 
08:26:00 <boegel> shapr: there no such library ? that would be quite strange...
08:29:36 <shapr> hiya lightstep 
08:29:42 <lightstep> hi
08:29:55 <shapr> boegel: Maybe something in Pancito, Pan, Pan#, PanTHeon, etc
08:31:33 * Lemmih is on the edge of tearing off his hair.
08:31:53 * boegel hands Lemmih a razor...
08:31:56 <shapr> yow!
08:31:58 <boegel> don't tear it off, shave it
08:41:35 <ralf> morning
08:41:40 <boegel> hmm, I hate it.. I'm so close to getting this working
08:41:47 <boegel> evening ralf :)
08:44:40 <shapr> @wiki TheMonadReader
08:44:40 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
08:44:51 <shapr> Anyone want to comment on the Advert at the bottom?
08:45:45 <shapr> Speak now or forever eat your peas.
08:46:41 <Lemmih> haha "sequencing your input since 2005"
08:46:54 <pesco> "sequencing your input" haha! Wonderful.
08:47:03 <pesco> Lemmih: :P
08:47:10 <shapr> CosmicRay came up with that marvelous slogan :-)
08:48:57 <autrijus> wonderful.
08:48:57 <autrijus> CosmicRay++
08:49:05 <pesco> shapr: Call me picky, but I find the period in "The Monad.Reader", uh, strange.
08:49:19 <boegel> shapr: looks ok
08:49:23 <shapr> Well, it's a pun on the library of the same name.
08:49:33 <boegel> maybe you should mention something about the 'level'
08:51:05 <pesco> shapr: Mention "idea/vision" articles.
08:51:05 <shapr> pesco: period not required, I can remove it if it bugs you.
08:51:05 <shapr> boegel: good point.
08:51:05 * boegel cheers
08:51:05 <shapr> pesco: like what?
08:51:05 <boegel> shapr: I'm starting to have my doubts on gtk2hs
08:51:05 <boegel> I'm having quite some problems with showing the image's I want to
08:51:09 <shapr> boegel: how so? don't think you can have a short intro to gtk2hs ready in two weeks?
08:51:31 <boegel> the intro shouldn't be a problem, I can use the demo-examples
08:51:46 <boegel> but for my raytracer front-end
08:51:58 <boegel> they're still working on the images-part imho
08:52:19 <shapr> Ah, I see.
08:52:23 <pesco> shapr: "Got a visionary idea people should know about? Write an article..."
08:52:45 <shapr> pesco: sounds good
08:53:54 <pesco> shapr: I think I'd actually go for "The Reader Monad" as title.
08:54:14 <pesco> Even though it increases the pun distance to "The XYZ Reader".
08:54:32 <autrijus> "Monad: The Reader"
08:54:38 <autrijus> collectible card games!
08:54:40 * autrijus ducks
08:54:48 <shapr> Yeah, I like the pun between The XYZ Reader and Monad.Reader.
08:55:04 <pesco> But "The Reader Monad" 
08:55:06 <pesco> Argh.
08:55:06 <shapr> Also fits with "The Monthly Reader"
08:55:48 <sorje> The Monadly Reader?
08:56:15 * pesco shrugs. "The Monad Reader" is worse than "The Monad.Reader" though, because it sounds like "reader about monads".
08:56:17 <shapr> Hm, I really like "The Monad Reader" or "The Monad.Reader"
08:56:44 <swiert> wouldn't the BSD license only cover source code? (I'm no expert)
08:57:00 <lightstep> The System.Time ?
08:58:19 <pesco> OK. It's just that the period seems out of place in a magazine title and "The Monad.Reader" seems to trigger a light syntax error exception in my natural language unit.
08:58:28 <boegel> shapr: http://studwww.ugent.be/~kehoste/gtk2hs-3.png
08:58:44 <boegel> problem is: that's not real :) I just loaded a jpg...
08:58:54 <boegel> + the scrolling doesn't work
08:59:29 <esap> "The Text.PrettyPrint - formatting your Haskell experience" :-)
08:59:29 <boegel> heh :)
09:00:12 <shapr> grrr, emacs suxx!
09:00:20 <boegel> hehe
09:00:28 <esap> heh
09:00:37 <boegel> shapr: seen the screen?
09:00:44 <shapr> nah, lemme check the logs
09:01:04 <shapr> Heh, cute. Even if it is fake.
09:01:14 <CosmicRay> shapr: read the blurb & page.  Like both.  thanks.
09:01:39 * CosmicRay concocts an evil python-cabal hybrid build system.
09:02:04 * CosmicRay interrogates bits of distutils.sysconfig and sys to guess python include paths and libraries for use with cabal
09:02:09 <pesco> I just made some slight modifications. Have a look, shapr.
09:02:11 <shapr> pesco: Yeah, it does trigger a light syntax error. But I consider that part of the attention-getting charm.
09:02:53 <shapr> Yes, visionary is good.
09:03:00 <shapr> I don't know about BSD and text.
09:04:45 <shapr> But I'll check it out before TMR 'goes to screen'
09:04:59 * shapr wonders how you say "goes to print" for an eZine
09:05:36 <lightstep> "gets published"?
09:05:46 <shapr> too easy ;-)
09:07:50 <shapr> Ok then! If there are no other suggestions, I'll send in the Advert and google to see how BSD applies to text.
09:07:51 <lightstep> hmmm. in NewTime, why did the author choose Int for ctYear but Integer for ctPicosec?
09:07:57 <pesco> shapr: Ah, you can use "goes to print", metophorically!
09:08:10 <shapr> True
09:08:31 <pesco> As if we were never going to reach 2^31-1 AD!
09:08:46 <pesco> Ah, 2^30-1, sorry.
09:08:56 <lightstep> i thought it was 2^29-1
09:09:09 <pesco> Hm? two sign bits? ;-P
09:09:24 <lightstep> but it just seems stupid. the choice of picosec is arbitrary
09:09:38 <lightstep> and in a few years, an Int would be 62 bits anyway
09:09:39 <pesco> AFAIK, the report guarantees 31 bits for Int.
09:11:00 <lightstep> no, the report says (sec 6.4) that it's 30 bits, including sign
09:11:25 <pesco> Oh, then I was obviously wrong. Thanks for the clarification.
09:12:19 <pesco> Does ctPicosec wrap around at some point? I suspect not. Then Integer seems right.
09:13:09 * boegel concludes finding a good UI library for Haskell is not easy
09:13:25 <lightstep> i guess that picosec wraps around at 10^12
09:13:43 <lightstep> the docs don't say anything
09:16:46 <pesco> Ah, anyway, 2^29 < 10^12.
09:17:32 <shapr> I'd like to find train number two that's going to 29th street, and just write 2^29.
09:17:33 <lightstep> yeah. i would have done it better   :p
09:18:43 <boegel> does anybody know where i can find more about the actual implementation details behind jpg and png ?
09:19:12 * shapr hopes to get an article on working with image formats out of boegel next issue...
09:19:53 <boegel> shapr: hehe :)
09:20:04 <lightstep> shapr: i believe that BSD is bad for articles, since it requires you to have the ugly capital  letters disclaimer in the binary
09:20:08 <boegel> I hope I can finish my article for the first issue...
09:24:41 <pesco> shapr: OK, I vote for only dropping the period then.
09:25:12 <shapr> Would it really bug you if it stayed in?
09:25:21 <pesco> Nah.
09:25:22 <pesco> :)
09:25:28 <shapr> Ok :-)
09:25:59 * shapr sends
09:27:23 * shapr hops excitedly
09:27:34 * pesco recieves
09:27:40 <shapr> w00, here we go! Adventure time!
09:28:22 <Nioate> what's the name of the wiki page on The Monad.Reader?
09:28:31 <shapr> @wiki TheMonadReader
09:28:31 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
09:28:41 <Nioate> thanks
09:33:49 <swiert> shapr: let me know when you have a repository set up. I'll check in the stuff I have lying around.
09:34:13 <shapr> ok, RSN
09:35:13 <jlouis> what is the general style. Do you have an enter after a ''where'' clause or do you begin the first binding just after the where on the same line?
09:38:18 <lightstep> you can have it on the same line
09:41:41 <boegel> what is the best way to write bytes out to a file in Haskell ? any modules provided for that ?
09:56:28 <jlouis> new syntax question. :: Num a => ... constrains a type be of class Num. What if b also has to have the constraint? Num a, b => ... seems wrong
09:56:30 <shapr> yay, TMR gets hosted on haskell.org
09:56:49 <jlouis> type to be even
09:57:09 <shapr> (Num a,Num b) =>
09:57:24 <shapr> Greetings Herr Zapf.
09:57:33 <basti_> hi shapr 
09:57:35 <jlouis> ah and i general (type_constraint1 a, type_constraint2 b) ?
09:58:02 <shapr> I think so. I don't think you can cut it down to Num a,b
10:00:30 <basti_> I know its not really on topic. But, concerning software patentability: does anyone have a clear and waterproof point why software is different than engineering?
10:00:43 * boegel moans...
10:00:50 <shapr> basti_: because math is an idea.
10:01:03 <boegel> png looks quite complicated, jpg the same (compression, bah)
10:01:10 <musasabi> Can a pure functional language have identity (non-structural equality) ?
10:01:20 <boegel> and it's quite hard to find the specification of bmp
10:01:43 <basti_> [if anyone feels harassed please say, but i just had a discussion about that with an ignorant.] shapr: but, most engineering patents are ideas too.
10:01:45 <shapr> musasabi: I don't think it can, unless you use monads or something to fake it.
10:02:05 <musasabi> shapr: thanks.
10:02:17 <shapr> musasabi: have you read FpVsOo on WardsWiki?
10:02:35 <shapr> I also have some emails I've swapped with Alistair Bayley about that subject. I can track them down and send them to you, if you like.
10:02:48 <musasabi> no, have to look that up. I was thinking about how to classify OQL..
10:04:42 <boegel> is it possible to call an external program from within a Haskell program?
10:04:47 <musasabi> It has identity based comparisons but cannot iirc create new objects.
10:04:50 <lightstep> basti_: programming is less modular
10:05:15 <musasabi> @type System.system
10:05:16 <lambdabot> System.system :: String -> IO GHC.IOBase.ExitCode
10:05:16 <basti_> less? o0
10:05:21 <musasabi> boegel: there you go.
10:07:05 <lightstep> basti_: it's a clear point (not necesserily correct, though)
10:08:22 <basti_> i would say every program is more modular than let's say a car engine. a car engine fits just in one car (well, most do), and you would have a hell of a hard time to fit it to another, and it would probably look ugly, whereas you can extend and connect software easily.
10:09:04 <shapr> For that same reason you end up with gobs of software authors coming up with the same idea separately.
10:09:14 <boegel> musasabi: that could do it for me when I'm using linux, but it won't work when using win32...
10:09:51 <shapr> A given program usually has a much greater number of moving parts than the average car engine.
10:10:16 <basti_> i personally know that IT is a very different topic than engineering concerning patents. I'm just looking for a clear and unmistakable difference that would make even the most stupid ignorant say, "yes there is a difference"
10:10:21 <basti_> shapr: good point.
10:11:18 <shapr> Also, software patents mean I can't use an idea I came up with myself.
10:11:56 <shapr> The spirit of the patent system is to protect the work invested into developing an idea. Developing an idea in software costs *very* little work and time comparatively.
10:12:02 <Philippa_> one of the problems with software patents is that increasingly you can patent nearasdammit an implementation
10:12:18 <Philippa_> parameterise out on all the bits you don't need then specify it in haskell-in-words
10:12:23 <basti_> hmmm
10:13:01 <Philippa_> another is that you *need* good patent checking, and yet another is that 17 years is far too damn long (see work/time)
10:13:04 <shapr> Software is much closer to being an executable idea than it is a forged machine.
10:13:34 <basti_> he explicitely wished for an argument that is not "the implementation of patents is bad", "hippie whining" or "trivial patents"
10:13:37 <Philippa_> obviousness checks for software are hard to specify
10:13:55 <shapr> I forget which numbskull patented XOR, but I bet I could prior art even in the programmable looms that were the hollerith card ancestors.
10:14:04 <Philippa_> well duh
10:14:19 <Philippa_> it was IBM IIRC
10:14:21 <shapr> hippie whining =)
10:14:23 * shapr snickers
10:14:30 <basti_> i know that software patents (like those people wish they would be) would ruin the software industry.
10:15:02 <shapr> One major problem is that a patent case can easily cost 3 million euro. How many companies can afford that?
10:15:04 <Philippa_> there's no restriction on license fees, no effective restriction on being fuckwitted, it's far too easy for everybody to pick up their ball and go home and they're encouraged to do that in hope of profit
10:15:23 <basti_> i think thats "hippie whining"
10:15:40 <shapr> iirc, half a million USD is about the minimum cost to resolve a patent case.
10:15:42 <Philippa_> which part?
10:15:51 <Philippa_> the cost of defending yourself in a patent case is a huge problem
10:15:57 <basti_> "no restriction of license fees"
10:15:59 <basti_> i know.
10:16:11 <shapr> It means that no one can afford to innovate.
10:16:13 <Philippa_> no restriction of license fees in and of itself is, yes
10:16:18 <basti_> i know the problems associated with software patents. but what is the difference between software and hardware patents?
10:16:51 <shapr> Software reduces down to executable math at the core. Hardware doesn't.
10:17:04 <Philippa_> hardware patents frequently involve the exploration of real-world mechanics
10:17:16 <Philippa_> you have to do what's bordering on physics or chemistry research
10:17:17 <basti_> but some hardware patents claim to patent things in a similar way.
10:17:34 <lightstep> yes, but you can have alternative designs
10:17:36 <basti_> like for example, the xerox "selen roll" copy machine
10:17:44 <shapr> From one viewpoint, the person who patented the first programmable thingy has a patent on all software.
10:18:00 <lightstep> if you patent some encryption, you can't have another encryption with those paraters
10:18:03 <basti_> one would say this covers every "selen roll" copying machine. it doesnt.
10:18:03 <Philippa_> no, only on software-running-on-hardware
10:18:23 <Philippa_> patenting encryption is patenting maths
10:19:01 <Philippa_> I'm really not sure how I feel about that, there've been two or three /really good/ inventions there, but I'm not aware of any others of note
10:19:23 <Philippa_> the interaction between obviousness and triviality in that kind of area is scary
10:19:32 <basti_> yes it is
10:19:38 <basti_> but sadly only programmers can see that.
10:19:38 <shapr> Merkle's Puzzles got all of encryption happening. He should have patented the whole deal.
10:19:59 <Philippa_> wouldn't have mattered
10:20:15 <Philippa_> IIRC, if you have a specific improvement on an existing design and you patent that you get to use it no worries
10:20:18 <basti_> anyway. I'm happy that the EU Parliament rebooted the whole sw patent thing
10:20:22 <shapr> me too
10:20:45 <basti_> but i'd love to have a verbal trout to slap those idiots.
10:20:55 <basti_> i mean programs can be infinite.
10:20:58 <Philippa_> one of the big things with software patents is that it's incredibly hard to get the abstraction issues right
10:21:07 <basti_> thats a hell of a difference. but he wouldnt admit that.
10:21:08 <shapr> The goal of the patent system is to encourage progress. Shutting out companies who can't afford to buy a patent at 20,000e per patent, and half a million euro per fight does not encourage progress.
10:21:28 <Philippa_> right
10:21:32 <basti_> thats implementation details he'd say.
10:21:41 <Philippa_> and implementation is vital
10:21:53 <Philippa_> find me a good way to implement software patents and I'll consider
10:21:54 <basti_> yes but i dont want software patents implemented at all.
10:22:12 <Philippa_> ("good" hereby defined as, amongst other things, encouraging progress)
10:22:13 <basti_> good point again.
10:22:16 <shapr> If a software patent lasts for six weeks...
10:22:22 <basti_> hehe
10:22:24 <wli> Erecting barriers to entry is in the interest of larger software vendors.
10:22:26 <Philippa_> I'd make it five years
10:22:27 <basti_> yes something like that
10:22:32 <basti_> no thats too long.
10:22:34 <wli> Though not the world at large.
10:22:38 <Philippa_> with the patent starting from the application date
10:22:39 <basti_> way too long.
10:22:44 <basti_> A year maybe.
10:22:49 <basti_> or half a year.
10:22:56 <shapr> I could go for six months.
10:22:56 <Philippa_> a year's short enough you get no competetive advantage
10:23:10 <shapr> Would encourage people to stop using C++ =)
10:23:11 <Philippa_> somebody else reads the patent, rips the idea, develops like crazy as soon as it's in the clear...
10:23:27 <basti_> hmm you mean because it takes time to develop software?
10:23:29 <Philippa_> and the somebody else can be a big outfit
10:23:30 <Philippa_> yeah
10:23:35 <basti_> but thats the point it doesnt...
10:23:40 <Philippa_> yes it damn well does
10:23:46 <basti_> i mean ok the "big things"
10:23:47 <Philippa_> it's cheap as hell to knock up a 1kloc utility
10:23:56 <Philippa_> but most people don't use 1kloc utilities
10:23:58 <basti_> like, micro$loth word.
10:24:17 <basti_> but thats not patentable anyways.
10:24:21 <Philippa_> they use big apps with lots of the 1kloc utilities built in, or they use medium-weight stuff with a much nicer UI
10:24:23 <shapr> I think you'd end up with a market for powerful commodity frameworks that allow ideas to just plug in.
10:24:30 <Philippa_> no, but at one point the spellchecking would've been
10:24:46 <basti_> yes but why would a year be too long for the spellchecker?
10:25:05 <shapr> That would end up encouraging garage bands and spectacular ideas.
10:25:06 <basti_> i mean if its "the killer app", then a year is plenty of time to earn money.
10:25:19 <Philippa_> because if you're a little outfit and you're doing your own WP app to compete with word, you get no time to compete
10:25:34 <Philippa_> you need that patent before you release, and a year is /not/ going to give you the market
10:25:42 <Philippa_> next year, MS have the feature too
10:25:44 <basti_> hmm.
10:25:58 <basti_> well but then again, five years is clearly too long.
10:26:02 <shapr> But if you're the only one with that feature for a year, you can sell to the whole global market.
10:26:03 <Philippa_> 5 years is more like the time it takes to build a mature product, however small the trick it's built around is
10:26:07 <shapr> Cost per unit is not a problem.
10:26:29 <Philippa_> but if you're in competition with something big without that feature, it don't matter
10:27:11 <basti_> actually i think the whole patent issue is moot. someone with enough money on their hands will always find a way around your patent.
10:27:13 <shapr> If there are powerful and affordable commodity frameworks (think the torque gaming engine), then a year is enough time to sell a zillion copies.
10:27:23 <Philippa_> no, it's not
10:27:29 <Philippa_> it's /really/ not
10:27:41 <shapr> Ya know, this calls for a market simulator.
10:27:43 <Philippa_> basti_: the idea is that they should have to do it by inventing an equivalent technique
10:27:43 <basti_> i mean, i even think the "justice" issue is pretty moot.
10:27:47 * basti_ ducks
10:28:13 <basti_> yes but with enough money on your hands you can just bribe a lawyer or two and they will put the laws how you like it.
10:28:19 <Philippa_> shapr: bear in mind that in the vast majority of cases there is an existing competitor - the new feature is important but rarely killer app
10:28:44 <Philippa_> Better Is Worse is a huge problem when you're entering the market place late
10:28:48 <shapr> In that case, it's probably easier to sell the feature to your competitor for a percentage.
10:29:12 <Philippa_> and they'll tell you to piss off, either they'll pay $100 or they'll do it in a year
10:29:15 <wli> Early entrance is not always the dominant concern.
10:29:15 <shapr> But if you're getting a patent, you have your own marketplace.
10:29:26 <wli> When it is, then quality goes out the window, of course.
10:29:39 <Philippa_> yes, but the market place for exactly-what-you've-done is smaller
10:29:42 <basti_> i dont think the world would break down without patents.
10:29:58 <basti_> in fact i can imagine a world free of patents that is not much different than ours today.
10:30:00 <Philippa_> I think in the engineering world it'd cause big problems
10:30:11 <basti_> like for example?
10:30:11 <shapr> basti_: I agree. Have you seen the crazy zero-patent zero-copyright system that some Californians suggested? It *rocks*
10:30:28 <basti_> shapr: "hippie whining" -ducks-
10:30:54 <shapr> These hippies came up with a dramatically different economic model that looks to me like it would be much better.
10:31:09 <basti_> i mean theres a lot of things that could be changed.
10:31:12 <shapr> I still have problems with the stupidity of hourly paid programmers.
10:31:16 <Philippa_> does it survive being in the same world as those following other models?
10:31:33 <basti_> i find the idea of complementary currency very exciting.
10:31:33 <shapr> Philippa_: it does, but it requires a culture change on the part of the distributors.
10:31:45 <basti_> shapr: do you have a link or two?
10:31:55 <wli> Universal currency would be interesting.
10:31:58 <shapr> umm... not off the top of my head. I'll have to track it down again.
10:32:07 <Philippa_> wli: the west'd hate it
10:32:09 <basti_> id be interested
10:32:19 <Philippa_> we use the lack thereof as a great excuse to fuck other countries
10:32:26 <basti_> no in fact i think "one big currency" is a very bad idea
10:32:33 <wli> Philippa: Predicated on the assumption I get to emigrate first. =)
10:33:10 <shapr> In essence, they say that any creative work can be sold cheaper per copy than any pirating, if sold to the global market all at once. And that an efficient distributor would pay a lump sum to the artist expressing the expectation of sales.
10:33:56 <basti_> hmm cheaper than pirating?
10:34:05 <basti_> i think thats hard.
10:34:09 <Philippa_> pirating needs somebody to crack it and an /underground/ distro network
10:34:14 <Philippa_> the latter has costs in keeping it underground
10:34:20 <basti_> actually it hasnt.
10:34:26 <shapr> Yeah, pirating takes more effort and time than throwing two bucks down to get the latest Britney Spears media with no restrictions on use.
10:34:30 <basti_> no  costs
10:34:45 <Philippa_> basti_: the cost atm is in clue required
10:34:53 <shapr> two bucks times global market = big money
10:34:55 <basti_> well i think it would be really hard to beat file sharing networks
10:35:00 <basti_> right Philippa_ 
10:35:16 <basti_> though i fail to see "clue required" in file sharing networks.
10:35:24 <basti_> but maybe i'm too clueful.
10:35:24 <shapr> but, if the media has no restrictions, there's no point in running file sharing networks.
10:35:24 <basti_> ;)
10:35:29 <basti_> indeed.
10:35:39 <Philippa_> shapr: bandwidth aggregation
10:35:51 <shapr> In that case, it's actually cheaper to buy a copy of the media from this efficient distributor.
10:35:52 <basti_> but they are there and they will stay as long as they are needed.
10:35:59 <Philippa_> it's the commie approach to running a distro site
10:36:01 <basti_> shapr: it might be yes.
10:36:08 <basti_> i see the point.
10:36:23 <Philippa_> or to pay a network sub
10:36:56 <musasabi> shapr: except for the thrill of doing something forbidden.
10:37:03 <shapr> Right, I'd pay five bucks a month to have nigh-instant access to certain creative works. Some of my favorite authors, in both software and literature.
10:37:27 <basti_> i think this "pay the artist once" thing isnt a bad idea.
10:37:30 <Philippa_> what do you think I pay my ISP for? :-)
10:37:40 <Philippa_> I think it's a great idea
10:37:46 <basti_> hell i even think you could start a buisiness this way.
10:37:48 <shapr> musasabi: if it were like paying an ISP, there would be no real point.
10:37:49 <musasabi> One of the problems is that currently the illegal channels are easier to use and give faster & better results than the legal ones.
10:38:04 <basti_> yes thats right.
10:38:13 <shapr> But that's mostly because the media industry has had no competition so far.
10:38:17 <zamez> yes, there is no legal way to buy download music when you're using Linux
10:38:18 <musasabi> true.
10:38:19 <samc_> basti_, have you read Bernard Lietaer's book? If so, what did you think?
10:38:26 <zamez> which is ++bad
10:38:31 <shapr> They've started to suck so bad that homebrew setups can beat their distribution.
10:38:33 <basti_> samc_: i havent why? who is he?
10:38:35 <Philippa_> zamez: that's partly because there's no reliable way to do DRM under linux
10:38:50 <zamez> I don't want DRM, I just want to buy music
10:38:51 <shapr> hiya magnus- 
10:38:55 <magnus-> hi
10:38:55 <basti_> there is no DRM.
10:38:56 <basti_> ;)
10:38:57 <shapr> zamez: magnatune.com
10:38:57 <zamez> why don't they want my money?
10:39:02 <shapr> zamez: yes! I agree!
10:39:10 <shapr> that's my mantra... "don't you want my money?"
10:39:18 <basti_> hehe
10:39:25 <shapr> magnus-: how's code?
10:39:34 <Philippa_> if I can't rip a CD on this PC, it goes back to the shop
10:39:47 <basti_> whats a CD?
10:39:49 <magnus-> shapr: I am struggling on :)
10:39:49 <basti_> uhm
10:39:49 <basti_> ;)
10:39:49 <shapr> Yep, I won't pay to get screwed out of what I bought.
10:39:49 <Philippa_> I don't distribute the rips any further than my mp3 player and my other computers
10:39:51 <zamez> yeah, I'm sticking with CDs for now
10:40:06 <shapr> magnus-: have any questions?
10:40:48 <basti_> no actually i do pay & own cd's. The last one i bought had some sort of copy protection (i think, im not sure), and i'm pretty sure i would return one that cant be ripped.
10:40:49 <magnus-> shapr: I am making an audio processing language in lisp that compiles to c++
10:40:58 <shapr> Sounds neat.
10:41:08 <samc_> the book is 'the future of money' it's about complementary currencies and such
10:41:21 <magnus-> I haven't touched haskell
10:41:28 <basti_> samc_: oh okay =) im interested.
10:41:35 <shapr> greetz toomasr 
10:41:49 <toomasr> hello :)
10:41:49 <shapr> magnus-: Well, I can still give you the short intro if you want.
10:42:01 <shapr> toomasr: How's Java treating you? ;-)
10:42:12 <samc_> I haven't read it, I was hoping for a review
10:42:42 <magnus-> shapr: I know the basics of haskell, i studied it i a university code
10:42:43 <magnus-> course
10:43:12 <shapr> basti_: I'll see if I can find the proposal these Californian guys wrote. No promises though, I was doing some in-depth research on alternate patent/copyright systems.
10:43:20 <magnus-> I find it cool but I am a bit dazzled by the typing and how to work around lack of side effects
10:43:46 <basti_> shapr: dont hurry. but i'll be happy to read it i think.
10:43:48 <shapr> magnus-: in general, shadowing. Have you seen the definition of the length function?
10:44:24 <magnus-> shapr: yes I beleive so, but i don't remember the syntax details
10:44:50 <shapr> Do you want to remember those details?
10:44:53 <toomasr> shapr: same old
10:44:57 <magnus-> sure
10:45:02 <toomasr> shapr: i found a project that i use written in haskell :) darcs
10:45:26 <shapr> length [] = 0 ; length (x:xs) = 1 + length xs
10:45:44 <shapr> toomasr: oh, I like darcs. I've even hacked on it a bit myself.
10:46:28 <toomasr> shapr: wow, cool, i'm checkin the source right now, a bit over my head, but i always wanted to see haskell really used somewhere
10:46:30 <shapr> magnus-: so when length calls itself, the old definition of xs is hidden by the new definition.
10:47:13 <magnus-> shapr: yes I am aware of how to do recursive programming
10:47:16 <shapr> John Peterson wants a survey of the various Haskell tutorials available. Any authors want to volunteer?
10:47:24 <magnus-> thanks
10:47:33 <shapr> magnus-: that's it, mutability not required.
10:48:20 <magnus-> It is when it comes to data structures that I find myself wanting mutability
10:48:26 <shapr> Like what?
10:48:47 <Philippa_> arrays spring to mind
10:49:33 <shapr> Yeah, mutable arrays are handy. But that's mostly for efficiency.
10:50:04 <magnus-> shapr: arrays, hash tables, using results before they have been computed...
10:50:38 <lightstep> also algorithms for graphs, where you store intermediate results in the nodes
10:50:39 <shapr> You can use results before they've been computed. There's something called the credit card transform.
10:50:49 <magnus-> not having to pass around so many arguments...
10:51:03 <Philippa_> "just for efficiency" - may I remind you why my column's called Impure Thoughts? ;-)
10:51:49 <shapr> You can do automatic passing of arguments with a neat code construct in Haskell called a monad.
10:52:23 <Philippa_> better yet, you can grab a whole pile of nifty semantics tricks if you happen to want them at the same time
10:52:34 <lightstep> <devil's adv.>monads are not haskell-unique</devil's adv.>
10:52:50 <Philippa_> no, but if you can find a language that supports them better than Haskell I'm all ears
10:53:13 <shapr> Right, the monad interface does automatic plumbing for you in Haskell, ML, Scheme, Perl, and other languages too.
10:54:32 <lightstep> haskell has a special syntax, it's not fair
10:54:40 <shapr> ?
10:54:43 <Philippa_> it's not just the syntax, type classes're relevant too
10:54:49 <lightstep> in other languages, you can
10:55:00 <lightstep> 't do x >>= \y -> z as easily
10:55:03 <shapr> swiert: looks like I won't be setting up the repo tonight, will you be around tomorrow?
10:55:20 <swiert> shapr: sure no problem.
10:55:24 <lightstep> you'd have to have parens, and the result would be ugly
10:55:36 <shapr> swiert: though you can setup a local repo, stick your article in there, and I can pull it right now.
10:55:49 <Philippa_> 'sok, we all know Haskell's syntax is great :-)
10:56:11 <Philippa_> (things that put me off lisp #1: having to write out 'lambda')
10:56:21 <swiert> ok - I'll have a look. It's now in my subversion repository.
10:56:50 <gzl> minor though it may be, i do find the excessive () annoying.
10:57:00 <lightstep> my opinion is that lambda is the thing missing from haskell. i like words better than punctuation
10:57:04 <gzl> in lisp, i mean.
10:57:26 <Philippa_> I-exps fix that
10:57:42 <lightstep> and i like the parens in lisp. they are as nice (to me) as layout
10:57:45 <Philippa_> lightstep: for me, it's fundamental enough to be worth punctuation, much as I'd rather () than begin/end
10:57:48 <magnus-> monads seem to be cool but oh-so-complex for trying to get back into an imperative framework
10:58:02 <Philippa_> if you're just a monad user, they're pretty trivial
10:58:18 <shapr> magnus-: ah, but they're not imperative :-)
10:58:22 <Philippa_> if you're writing one, there's a bit more thinking to do but it's like having a framework for CPS that lets you think scary thoughts about it
10:58:31 <Philippa_> (monad transformers rock - lego semantics)
10:59:32 <magnus-> shapr: yes
10:59:57 <Excedrin_> zamez: re, legal way to buy music with Linux: http://allofmp3.com/index.shtml?r=1552947564
11:00:21 <shapr> In my opinion, the strength of monads is that they're much like OOP, but you get to choose the semantics used to concatenate your code.
11:01:12 <magnus-> how would you do memoization in haskell?
11:01:44 <Philippa_> copy the value you want memoised like crazy, first time something evaluates the thunk it'll sit there
11:01:51 <Philippa_> (strictly speaking there's no guarantee...)
11:02:06 <shapr> Ok, any TMR authors who have some content to show, setup a darcs repo and send me the url so I can grab it. If you don't have a public IP, talk to me, we can work it out.
11:02:24 <zamez> thanks Excedrin_, I'll have a look
11:02:37 <shapr> But this is not urgent, sleep is calling.
11:02:49 * shapr disappears
11:03:49 <magnus-> Philippa: ahh, but then you have to predict what you will need to compute in the future and then refer to that prediction when you want the value
11:04:16 <zamez> stupid javascript
11:04:19 <Philippa_> as with any situation where you have to do anything but hope
11:04:56 <Philippa_> and really, how else do you get things done under lazy evaluation?
11:04:59 <Philippa_> it's /all/ evaluated in the future
11:05:34 <magnus-> I'm thinking for memoization you'd have to pass around a lookup table with each invocation of some function, and also return the modified lookup table
11:05:42 <magnus-> and thread it around the program
11:05:48 <magnus-> perhaps this is what monads solve?
11:05:54 <monochrom> The heap is the lookup table.
11:06:19 <magnus-> I am not talking about lazy computations here, i'm talking about cached values of computations
11:07:29 <lightstep_> you can have a lazy array. there is an example in the wiki
11:07:37 <magnus-> oki
11:07:39 <lightstep_> @wiki MemoizingCafs
11:07:39 <lambdabot> http://www.haskell.org/hawiki/MemoizingCafs
11:07:41 <Philippa_> magnus-: same difference
11:08:00 <Philippa_> in that once a function's fully applied (a CAF), it's still not necessarily been evaluated yet
11:08:13 <Philippa_> you can pass that value around, everybody effectively gets pointers to the same thunk...
11:09:09 <magnus-> lightstep: aah, that's a neat solution!
11:11:42 <lightstep_> that wasn't me. i don't even understand everything there
11:13:47 <Philippa_> note that it's essentially the same trick I described, they're just using an array to allow a CAF lookup
11:14:28 <pesco> Heheh. Advogato has an article "Where Should XML Go?". "In the bin I say!" :P
11:15:09 <magnus--> Sorry, I got disconnected
11:15:32 <magnus--> Philippa: Ahh, I guess I didn't understand what you meant when you described it.. my apoplogies.
11:28:31 <lightstep> who likes donuts?
11:28:37 <gzl> i like donuts.
11:28:42 <gzl> sometimes.
11:28:47 <tic> donuts 4 the win
11:28:47 <basti_> if its not too many.
11:28:59 <tic> you can -never- have too money donuts.
11:29:02 <duncan> @arr
11:29:02 <lambdabot> I heard andersca is a pirate
11:48:14 <CosmicRay> heh
11:48:14 <CosmicRay> @arr
11:48:15 <lambdabot> Shiver me timbers!
11:48:17 <CosmicRay> @arr
11:48:17 <lambdabot> Arrr!
11:48:20 <CosmicRay> @arr
11:48:20 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
11:50:50 <lightstep> moinmoin seems not very smart. ConstantApplicativeForm is on OrphanedPages
12:05:15 <Philippa_> reasons Template Haskell is cool:
12:05:16 <Philippa_> module Main where
12:05:16 <Philippa_> import Compiler
12:05:16 <Philippa_> $(compile "FILENAME")
12:07:42 <lightstep> hehe. freenode doesn't like metaprogramming
12:08:10 <basti_> hehe
12:13:31 <CosmicRay> shapr: here's what I'd like you to write for the first TMR: something about template haskell
12:15:26 <basti_> ah that reader thing... im getting more and more eager to write something... i still have my seminar at hand though, but the 97% hurdle is tomorrow evening.
12:15:58 <CosmicRay> shapr: that is, if you take requests :-)
12:16:16 <CosmicRay> shapr: because TH seems nifty but there's not much good stuff out there to read about it
12:25:09 * stepcut writes some crazy bash code ==> exec > >(cat -n) 2>&1
12:25:56 <lightstep> what does it do?
12:26:54 <stepcut> assuming I got it right, you can stick it in the middle of a bash script, and from there forward, all stdout/stderr from the bash script will be redirected to the 'cat -n'
12:27:08 <stepcut> of course, you can pipe it to something more useful than cat -n, like cronolog
12:27:40 <stepcut> unfortunately, I think it requires bash, and I am using /bin/sh :-(
12:27:58 <lightstep> some people have sh linked to bash
12:28:26 <stepcut> indeed, but when you invoke bash as /bin/sh, it acts like sh
12:29:38 <lightstep> oh. well, you can always use scsh
12:30:50 <stepcut> no, I have to use /bin/sh, it's /etc/X11/Xsession
12:33:30 <Excedrin> you can do exec 2>&1 cat -n
12:35:49 <Excedrin> oh, nevermind, the bash thing you're trying to do is different
12:40:39 <boegel> @index Array
12:40:40 <lambdabot> Data.Array,Data.Array.Diff,Data.Array.IArray,Data.Array.Unboxed,GHC.Arr
12:40:40 <lambdabot> GHC.Arr,Array
12:41:42 <stepcut> I guess I just need to create the fifo myself...
12:42:40 <Excedrin> exec 2>&1 sh | cat -n # that's similar
12:43:35 * pesco scribbles happily.
12:43:49 <stepcut> Excedrin: um... I don't think so...
12:43:57 <pesco> How enjoyable writing a grammar can be!
12:44:50 <pesco> I can only recommend mapping all those handy Unicode symbols onto your keyboard somewhere.
12:45:27 <pesco> This has finally given some meaning back to “Alt”, too.
12:46:20 <Excedrin> all of the output of sh is piped thru cat -n, how is it not similar?
12:46:28 <boegel> can anyone tell me where I can find some info about Array ?
12:46:41 <boegel> I would like to parse a [Color] to Array (Int,Int) Color
12:47:21 <pesco> @type Data.Array.listToArray
12:47:22 <lambdabot> bzzt
12:47:26 <pesco> hrm.
12:47:32 <pesco> @index listToArray
12:47:32 <lambdabot> bzzt
12:48:02 <boegel> heh...
12:48:27 <pesco> @type Data.Array.listArray
12:48:29 <lambdabot> Data.Array.listArray :: forall e i.
12:48:29 <lambdabot> 			(GHC.Arr.Ix i) =>
12:48:29 <lambdabot> 			(i, i) -> [e] -> GHC.Arr.Array i e
12:48:43 <pesco> There. Then you just need the correct order in the list.
12:49:11 <boegel> being ?
12:50:05 <pesco> You can just try range ((0,0),(2,2)).
12:50:58 <pesco> It's [(0,0),(0,1),(0,2),(1,0)...], so most significant digit first.
12:51:18 * boegel doesn't understand this syntax...
12:51:23 <boegel> [e] = [Color]
12:51:34 <boegel> but what about the (i,i) , what's that ?
12:52:09 <pesco> The i is the index type. (i,i) is the index range the array elements should cover.
12:52:34 <pesco> So since you said you wanted index type (Int,Int)...
12:53:26 <boegel> hmm, but my Color list is 1 dimensional...
12:55:28 <pesco> Right, so the 2d-indices are mapped to a sequence of 1d-indices to which the list elements are assigned in the obvious manner.
12:55:32 <boegel> using Array Int Color would be better then...
12:55:55 <pesco> That depends on how you want to use it. If you'd like 2d-indexing, maybe not. Otherwise, sure.
12:56:27 <boegel> okay, so if colorList :: [Color]
12:56:49 <boegel> then I could do 'listArray (0,0) colorList' to get my Array ?
12:57:17 <pesco> (Basically, in the above case the Ix class would take care of the usual (x+w*y) index conversion for you.)
12:57:23 <pesco> Right.
12:57:27 <boegel> oh no, it should be (0, length colorList), right ?
12:57:34 <pesco> Of course.
12:57:37 * pesco shakes his head.
12:57:40 * boegel tries
12:58:33 <pesco> length list-1 bwabwah.
13:00:13 <boegel> off course :)
13:05:28 <duncan> boegel: for a 2d array you'll want: listArray ((0,0), (width, height)) colorList
13:05:58 <duncan> boegel: I'm not sure how that relates to your 1d list of colours
13:09:48 <pesco> Oh it's wonderful. I think with the new X version, many widgets finally started paying attention to my real screen resolution. Yay!
13:15:16 <boegel> duncan: my current list of colors is 1d...
13:15:30 <boegel> I'll get it working that way first, I'll see if I'll make it 2D later on...
13:17:13 <autrijus> yay, CTK ported and running happily on GHC6.
13:21:38 <boegel> when arr :: Array Int Color, then arr!i :: Color if i :: Int, right ?
13:22:54 <monochrom> Yes
13:27:04 * boegel swears
13:28:34 <boegel> > pixbufSetPixelsRGB8FromArray :: Pixbuf -> Array Int Color -> IO()
13:28:35 <boegel> > pixbufSetPixelsRGB8FromArray pixbuf arr =
13:28:35 <boegel> >    pixbufSetPixelsRGB8 pixbuf (\i -> (\ (r,g,b) -> (fromIntegral (round r), fromIntegral (round g), fromIntegral (round b)) $ arr!i))
13:28:46 <boegel> Color :: (Double,Double,Double)
13:28:55 <boegel> what's wrong with those 3 lines ?
13:29:57 <boegel> (nevermind)
13:30:08 <duncan> boegel: the problem is that pixbufSetPixelsRGB8 takes a function that takes an x,y coordinate, you've just got one argument 'i'
13:30:39 <boegel> yep, I just saw...
13:30:53 <duncan> you need pixbufSetPixelsRGB8 pixbuf (\x y -> ... )
13:31:16 <duncan> how are you representing the 2d image with your list of colours?
13:31:19 <boegel> yeah, I know, but how should I determine the index of the arr then...
13:31:54 <boegel> duncan: well, the pixels are just follow eachother in the list..
13:32:00 <boegel> I really should make it a 2D list
13:32:18 <duncan> if you can write a function to convert your 1d representation to an Array (Int,Int) Color, then you'll be fine
13:32:53 <duncan> boegel: film's starting again, got to go... :-)
13:33:03 <boegel> :)
13:35:19 <boegel> @type liftIO
13:35:20 <lambdabot> bzzt
13:35:25 <boegel> @index liftIO
13:35:26 <lambdabot> Control.Monad.Cont,Control.Monad.Error,Control.Monad.List,Control.Monad
13:35:26 <lambdabot> RWS,Control.Monad.Reader,Control.Monad.State,Control.Monad.Trans,Control
13:35:26 <lambdabot> Monad.Writer,GHC.IOBase
14:02:10 * CosmicRay releases MissingH 0.9.0
14:02:49 <boegel> CosmicRay: what is it ?
14:03:08 <CosmicRay> boegel: http://quux.org/devel/missingh/README
14:03:44 <boegel> CosmicRay: nice
14:04:24 <CosmicRay> boegel: api docs at http://quux.org/devel/missingh/html/index.html
14:06:50 <basti_> CosmicRay really nice
14:07:18 <CosmicRay> thanks
14:07:30 <basti_> i bet this comes handy now and then.
14:08:44 <CosmicRay> basti_: anytime I write code that I think I could use in more than one app, I try to put it in MissingH.
14:08:53 <CosmicRay> also, anytime I *find* code... :-)
14:08:56 <CosmicRay> well almost anytime.
14:09:04 <basti_> :)
14:11:31 <CosmicRay> missingh is 100% pure haskell, btw.
14:11:52 <basti_> i didnt make any other impression
14:12:34 <basti_> it
14:13:17 <CosmicRay> good.  sometimes I am unpleasantly surprised to find C pre-requisites in software (hsshellscript and hsregex are two such packages)
14:14:04 <basti_> well but then again, regexes on todays processors just yell for C
14:14:44 <CosmicRay> basti_: hsregex requires C even for Posix regexps :-)
14:14:52 <CosmicRay> even though fptools already has a C binding for them
14:15:02 <basti_> hmm
14:15:21 <basti_> but, you could write the regex compiler in haskell
14:15:30 <CosmicRay> indeed
14:15:38 <basti_> that would be pervert but it could work.
14:15:42 <CosmicRay> heh
14:15:52 <basti_> is there such an "escape" in haskell somewhere?
14:16:07 <basti_> that you can give your own machine code?
14:16:20 <basti_> oh my that would be beautiful. but pervert.
14:16:36 <CosmicRay> basti_: you mean assembly?
14:16:40 <basti_> yes
14:16:50 <CosmicRay> you can use FFI for that, just like with C
14:16:51 <basti_> assembly refers to the human readable form though
14:16:57 <CosmicRay> heh
14:17:04 <basti_> but can you do from out of a program?
14:17:21 <CosmicRay> oh, you mean dynamically generate machine code at runtime?
14:17:28 <basti_> yes
14:17:29 <CosmicRay> yes, you can, if you dlopen() it
14:17:39 <basti_> oh :)
14:17:54 <basti_> i mean it would be pervert..
14:18:16 <basti_> but, you could have a function that takes a regex, compiles it and returns a function that would evaluate your regex
14:18:59 <basti_> which would be such an "escape" to the assembly/machine language environment
14:19:09 <basti_> so that your regex would be blazingly fast.
14:20:39 <basti_> i mean not that it would matter in normal contexts.
14:38:09 <duncan> @type array
14:38:10 <lambdabot> bzzt
14:38:46 <duncan> @type Array.array
14:38:47 <lambdabot> Array.array :: forall e i.
14:38:47 <lambdabot> 	       (GHC.Arr.Ix i) =>
14:38:47 <lambdabot> 	       (i, i) -> [(i, e)] -> GHC.Arr.Array i e
14:43:48 <duncan> @type print
14:43:49 <lambdabot> print :: forall a. (Show a) => a -> IO ()
14:51:58 <CosmicRay> @seen syntaxninja
14:51:58 <lambdabot> I haven't seen syntaxninja
14:52:03 <CosmicRay> @seen SyntaxNinja
14:52:03 <lambdabot> I haven't seen SyntaxNinja
14:52:08 <CosmicRay> lambdabot: you lie
14:52:08 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
14:52:12 <CosmicRay> :-)
14:53:32 <boegel> @seen Syntaxninja
14:53:33 <lambdabot> I haven't seen Syntaxninja
14:53:36 <boegel> could be :p
15:05:03 * boegel kicks shapr 
15:06:17 <Maddas> Why would regexes on processors yell for C?
15:06:25 <Maddas> er, on today's processors
15:06:39 <Maddas> (I am aware of the fact that basti left)
15:07:00 <zamez> is this a joke?
15:08:23 <Maddas> No, I'm referring to what basti_ said earlier
15:08:45 <zamez> I was looking forward to the punchline :>
15:09:38 <jlouis> Maddas: they wont.
15:09:55 <Maddas> Okay, that's what I thought
15:16:50 <jlouis> does tail recursion yield faster programs in Haskell?
15:23:31 <moofy> Does anyone know of an haskell implementation of A* search I could take a look at?
15:24:21 <Pseudonym> No, but it should be easy if you have a priority queue implementation handy/.
15:24:44 <Pseudonym> That's the tricky part.
15:34:05 <moofy> Hey, I didn't think of that, I'll give that a try, thanks!
15:35:30 <Pseudonym> You can use a nondeterminism monad (e.g. the list monad) to produce successor states if you want.
15:35:30 <Pseudonym> And don't forget to keep a set of already visited states.
15:35:50 <Excedrin> what's a good wiki that doesn't require a database backend?
15:35:52 <Pseudonym> Seriously, it shouldn't be more than about 20 lines or so including whitespace.
15:35:59 <Gowilla> moinmoin
15:36:46 <Excedrin> thanks
15:38:21 <boegel> hello Gowilla
15:43:36 <moofy> I'm still thinking it over, perhaps my program is wrongheaded, but I'm not sure how to get information about the states on the frontier without evaluating everything which would degenerate into BFS
15:46:16 <moofy> I suppose that's where I need the priority queue
15:52:38 <jlouis> a priq is easy
15:52:48 <jlouis> pairing heap
15:53:00 <Pseudonym> Easy when you have source code given to you. :-0
15:53:32 <jlouis> heeh
15:54:20 <jlouis> a pairing heap is like 10 lines of code
15:55:49 <Pseudonym> moofy: Right.
15:56:26 <Pseudonym> The "priority" that you index the prio queue on is the length of the already discovered path plus the value of the heuristic function.
16:03:20 <jlouis> http://www.brics.dk/RS/96/37/BRICS-RS-96-37.pdf seems interesting. Maybe I should read it
16:03:57 <moofy> Thanks for the link
16:05:27 <jlouis> Don't go with that as a first implementation
16:06:26 <ral1> :)
16:06:52 <samc_> why aren't you using a ready-made priority queue, like say edisons
16:08:44 <jlouis> LazyPairingHeap ;)
16:08:50 <moofy> I'm trying to improve my haskell while I work on this thing
16:09:15 <boegel> scene :: (Maybe Scene)
16:09:42 <boegel> how can I express this: if scene == Nothing then putStrLn "Nothing !" else putStrLn "wel iets"
16:10:04 <boegel> the == isn't right...
16:10:09 <Gowilla> where scene is in an IORef?
16:10:28 <boegel> no, scene :: (Maybe Scene)
16:10:44 <Philippa> case scene of
16:10:51 <Philippa>   Nothing -> putStrLn "Nothing!"
16:10:53 <Gowilla> there's probably a isNothing method for Maybe, too
16:11:02 <Philippa>   Just foo -> putStrLn "wel iets"
16:11:02 <Gowilla> I'm fairly sure there's an isJust method so you can just negate it
16:11:08 <Philippa> (to point out the obvious)
16:11:12 <Gowilla> or what Philippa said, but that's harder to fit on one line)
16:11:18 <Philippa> true
16:11:42 <Gowilla> or you could make an Eq instance for Scene but that'd be silly ;-)
16:11:54 <Philippa> is there really no Eq instance for (Eq a) => Maybe a?
16:12:10 <Gowilla> sorry?
16:12:17 <Gowilla> I expect that Scene here is not in Eq
16:12:21 <Gowilla> otherwise the above would have worked
16:12:29 <Gowilla> there is an Eq a => Eq (Maybe a) instance, AFAIK
16:13:15 <boegel> @index isJust
16:13:15 <lambdabot> Data.Maybe,Maybe
16:13:19 <boegel> @index isNothing
16:13:19 <lambdabot> Data.Maybe,Maybe
16:22:01 <boegel> is there a parsec tutorial ?
16:22:23 <boegel> I want to try out parsec tomorrow to parse a file into a scene description for my raytracer...
16:24:59 <boegel> what would be better for a fixed syntax ? Happy or Parsec ?
16:28:14 <dons> if it is fixed, i'd just go with happy. some people find parsec nice though
16:28:33 <dons> a happy generated parser will be faster
16:28:36 <boegel> dons, I'll try them both tomorrow
16:28:48 <boegel> but now I should _really_ go to bed
16:29:36 <boegel> g'night !
18:12:09 <jeff2> anyone have a quicksort implementation in haskell that does median-of-3 pivot selection and recursive cutoff at n=20?
18:26:47 <sh10151> no
18:27:27 <sh10151> and quicksort makes little sense in pure FP anyway
18:53:42 <jeff2> sh10151: how does it make little sense? it was one of the examples in this one haskell tutorial
18:54:08 <jeff2> sh10151: what is the preferred sorting algorithm of purely functional programmers?
19:07:06 <sh10151> it makes little sense because its advantage is that it operates in place
19:08:07 <sh10151> the one haskell tutorial was just showing the expressiveness of the language, not necessarily demonstrating a great algorithm
19:11:03 <jeff2> ah
19:11:25 <jeff2> So mergesort would work well in Haskell?
19:13:15 <sh10151> is there something wrong with List.Sort ?
19:18:37 <jeff2> what does List.Sort use?
19:19:04 <jeff2> looks like it uses quicksort, interesting
19:22:47 <Cale> jeff2: all the library functions are implemented in an implementation dependent way
19:23:12 <Cale> (the Library report just says what they have to do, and gives example implementations)
19:27:34 <moofy> Actually the GHC List.Sort  has an interesting bit of discussion on quicksort vs. mergesort
19:28:39 <moofy> It might make good reading
19:53:16 <Pseudonym> Well that was fun.
19:53:20 <Pseudonym> Internal network died.
19:53:27 <Pseudonym> Couldn't do any w*rk.
19:53:38 * Pseudonym wonders how he's going to explain this on his timesheet
20:17:26 <Shammah> Pseudonym: "Team Meeting" ? ;)
20:21:06 * CosmicRay unleashes MissingPy 0.1.0 on an unsuspecting world.
20:21:13 <CosmicRay> or at least, a suspicious mailing list.
20:21:48 <Pseudonym> Shammah: "Cleaned desk.  Read book on Lie algebras."
20:21:56 <Pseudonym> Maybe "professional development".
20:26:47 <dons> CosmicRay: looks good. why can't you call Haskell from Python?
20:27:37 <dons> I guess you could hack a binding to hs-plugins, a la:
20:27:40 <dons>         hs_eval_i("let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 20 :: Int")
20:28:05 <dons> better would be standard foreign export support, i guess
20:28:42 * dons wonders why we don't foreign export lots of the base package
20:30:53 <CosmicRay> dons: because I haven't bothered to write the code to export haskell to python
20:31:00 <CosmicRay> right
20:31:04 <CosmicRay> it is certainly possible
20:31:45 <CosmicRay> in fact, probably not all that difficult
20:31:53 <CosmicRay> things are somewhat more complex on the python side when doing that
20:31:57 <Lunar^> CosmicRay: you rocks :)
20:32:02 <CosmicRay> Lunar^: thanks :-)
20:32:30 * Lunar^ would like te release HFuse
20:32:43 <Lunar^> but I need to fix this FFI reentrancy bug first
20:32:46 <CosmicRay> what's that?
20:32:54 <Lunar^> It's a binding for FUSE
20:33:11 <CosmicRay> and what's that?
20:33:13 <Lunar^> which is a module/lib to write filesystems in userland
20:33:21 <Lunar^> (for the Linux kernel)
20:33:37 <CosmicRay> oh right
20:33:41 <CosmicRay> you told me about that before.
20:33:45 <CosmicRay> yes, get on that :-)
20:33:48 <dons> that would be cool. Haskell would be much nicer for that job, right?
20:34:04 <CosmicRay> dons: which, fuse?
20:34:09 <dons> yep
20:34:16 <CosmicRay> Lunar^: then we could export HVFS space as a real filesystem.  bwahahaha.
20:34:27 <CosmicRay> ability to mount zip, tar, and gopherspace could come for free...
20:34:44 <Lunar^> unfortunately, it seems that GHC RTS (at least) has a big lock around FFI calls
20:34:50 <dons> gopherspace, oh no!
20:35:00 <CosmicRay> Lunar^: have you tried the "unsafe" decl in your foreign import?
20:35:07 <CosmicRay> Lunar^: is fuse multithreaded?
20:35:16 <Lunar^> CosmicRay: My first though was to implement DarcsFS
20:35:16 <CosmicRay> (or perhaps the "safe" keyword...)
20:35:36 <Lunar^> CosmicRay: I need the -threaded flag to link, I must assume so
20:35:44 <CosmicRay> hm
20:36:11 <Lunar^> CosmicRay: didn't try any {un,}safe trick
20:39:57 <Lunar^> dons: How's Yi going ?
20:40:29 <dons> been working on other things for about 3 weeks, but i've got a bit of a syntax hl plan hacked up
20:40:40 <dons> hopefully get a chance to work on it full time soon
20:40:44 <Lunar^> cool
20:40:57 <dons> shapr's been writing a tutorial on how to do keybindings too, which is good
20:41:09 <Lunar^> :)
21:46:28 <Lemmih> Good morning, #haskell.
21:46:36 <autrijus> Good localtime.
22:04:03 <Lemmih> @index cast
22:04:04 <lambdabot> Data.Dynamic,Data.Generics,Data.Generics.Basics,Data.Typeable
22:19:14 <gzl> so, in 6.4, what will runghc do?
22:38:30 <SyntaxNinja> shapr: alive?
22:38:33 <SyntaxNinja> ralf: hi
22:41:52 <SyntaxNinja> so I was riding the train today...
22:42:03 <autrijus> rehi.
22:42:04 <SyntaxNinja> and I noticed that the guy sitting across from me was hacking in Linux and Emacs.
22:42:19 <SyntaxNinja> and it was totally Thomas Hallgren who I have never met before
22:42:25 <SyntaxNinja> (of the programatica project)
22:42:26 <musasabi> morning
22:42:38 <SyntaxNinja> I feel like I'm living in some kind of alternate reality where programming in Haskell is normal.
22:42:49 <dons> ha!
22:43:00 <dons> the people you run into on the train, hehe
22:43:16 <autrijus> hey dons. I ported part of CTK (SysDep and Utils) to GHC6.
22:43:32 <autrijus> dons: is it correct that it requires this kind of porting, or is there a newer CTK I missed?
22:43:43 <autrijus> I'm using 0.22.2.
22:43:55 <dons> let me check..
22:44:25 <dons> looks like 0.22.2 is the one
22:44:31 <dons> what where the problems?
22:44:55 <dons> (I thought it was pretty much just H98)
22:45:12 <dons> also, if you send me a diff -u, I'll get it to Manuel
22:45:23 <dons> or you could send it to him directly, also
22:45:43 <autrijus> the SysDep is only up to GHC4.
22:46:02 <autrijus> there is lots of functions that is no longer supported, or unly supported under GHC.IOBase, in GHC6.
22:46:25 <dons> i'll check the cvs version..
22:47:16 <dons> ok. looks like it hasn't been touched in a while. send a patch in, if you can
22:47:36 <autrijus> 'kay.
22:47:41 <autrijus> maybe I'll also hierarchify it.
22:47:47 <autrijus> and make it use modern things like FiniteMap.
22:47:56 <dons> yeah, that's a good idea
22:50:11 <SyntaxNinja> what's CTK?
22:50:17 <autrijus> compiler toolkit thing
22:50:25 <autrijus> saved me lots of utility coding.
22:50:39 <SyntaxNinja> running into functional programmers on trains is almost enough to make me think I'm living in europe
22:51:15 <SyntaxNinja> is this for haskell compilers or any old compilers?
22:51:40 <autrijus> any compiler.
22:51:59 <SyntaxNinja> ooh, is it cabal-ized? :)
22:52:13 <autrijus> it provides lexer/parser combinators and state management and symbols and identifiers and namespaces etc
22:52:18 <autrijus> it's not. it's also fairly old
22:52:42 <SyntaxNinja> aj_: still studying haskell?
22:53:52 <SyntaxNinja> sounds cool. does the lexer & parser give you much over Alex / Happy?
22:54:05 <ralf> SyntaxNinja: Hi.  I'm here.  I just didn't respond because I was installing something. 
22:54:17 <dons> a bit. the lexer is dynamically constructed and modifiable. so it is used in Yi to add new bindings at runtime
22:54:18 <autrijus> SyntaxNinja: ~ same. it also has some support to interop with happy via monad
22:54:25 <dons> that's impossible in alex.
22:54:26 <autrijus> right. I totally need that.
22:54:27 <SyntaxNinja> ralf: I ran into a functional programming (haskell) researcher on the TRAIN!
22:54:38 <autrijus> as perl6's lexing rules changes dynamically.
22:54:49 <dons> they do?
22:54:51 <dons> wow.
22:55:09 <autrijus> they do as you can declare (c) as an infix op.
22:55:26 <autrijus> or any nonwhitespace string.
22:55:26 <autrijus> crazy eh.
22:55:58 <autrijus> not only infix, but whateverfix.
22:57:02 <autrijus> and unicode like Sigma symbol.
22:57:02 <dons> hmm. and you don't deal with this by parsing, and then rewriting the syntax tree in light of the infix decls, for example
23:00:14 <autrijus> sure, because you can declare an infix called
23:00:14 <autrijus> ((()
23:00:14 <autrijus> which will kill normal lexers.
23:00:14 <autrijus> or am I missing something?
23:00:14 <SyntaxNinja> ralf: you are the biggest IRC tease ever
23:00:14 <dons> is there a bnf-ish grammar somewhere I could have a peek at?
23:00:14 <autrijus> yes, there are two.
23:00:14 <autrijus> https://svn.perl.org/perl6/grammar/trunk/Grammar.perl6 is newer, less complete
23:00:14 <dons> ah, there are bits missing, yes?
23:00:14 <dons> the stuff marked with {...}
23:02:30 <autrijus> there is a more complete, older, RecDescent grammar
23:02:30 <autrijus> http://search.cpan.org/src/LTOETSCH/parrot-0.1.1/languages/perl6/P6C/Parser.pm
23:02:30 <autrijus> yes. I'm filling the {...} as we speak.
23:02:30 <dons> :)
23:02:30 <autrijus> for userdefined op, http://dev.perl.org/perl6/synopsis/S13.html
23:02:30 <autrijus> is the spec.
23:03:34 <autrijus> lunch &
23:04:01 <dons> ah, I see how it is written with the idea of modifying the lexer dynamically in mind, right?
23:08:41 <ralf> SyntaxNinja: I read about your meeting hallgren on the train.  That's cool.  And I'm not a tease.  I'm just slow. 
23:09:00 <SyntaxNinja> hm
23:10:49 <ralf> yeah.
23:12:23 <musasabi> SyntaxNinja: ping
23:12:27 <ralf> I wanna establish a theocracy where Evolution is taught in public school as dogma; as the central organizing force in, not only biology, but everything;  Where evolution is taught as being a spiritual force. 
23:12:52 <ralf> musasabi: Speaking of pinging.  How do you ping to see if you're on a channel without typing "foo" or something?
23:13:19 <musasabi> ralf: /whois ?
23:14:25 <musasabi> SyntaxNinja: I think I found a bug in Cabal Distribution/Simple/Configure.hs guessPkgToolFromHCPath
23:16:01 <SyntaxNinja> hi musasabi tell me about it
23:16:56 <SyntaxNinja> ralf: I don't think that anyone should put you in charge of any theocracies, but no one ever asks my opinion about these things
23:17:18 <musasabi> SyntaxNinja: http://youzen.b2.fi/~musasabi/a.txt
23:18:36 <Gahhh> I trust SyntaxNinja when it comes to theocracies.
23:18:59 <Gahhh> would be cool if there was a GPL'd religion
23:19:14 <fraxtal> good night #haskell
23:20:17 <wli_> Gahhh: Unitarian Universalists?
23:21:37 <SyntaxNinja> musasabi: I'll look into it
23:23:21 <musasabi> thanks.
23:23:26 <SyntaxNinja> musasabi: patches welcome :)
23:23:53 <musasabi> I have an exam this evening so nothing serious before tomorrow ;)
23:24:27 <musasabi> (was just trying to make the qdbm binding compile with a newer version of cabal to post a link to haskell-cafe)
23:32:21 <lightstep> good morning
23:35:54 <dons> I wanna establish a theocracy where noone is allowed to say anything, unless it can be expressed as valid statements to the Isabelle theorem prover
23:36:12 <dons> hehe
23:36:38 <dons> or possibly, unless it can be encoded as a valid type in Haskell
23:37:00 <Maddas> I want copious amounts of copious amounts of spare time
23:39:54 <lightstep> @wiki HaskellWorldDomination
23:39:54 <lambdabot> http://www.haskell.org/hawiki/HaskellWorldDomination
23:43:32 <dons> any news on the ocr'd version of "implementing functional programming languages.."?
23:44:16 <dons> or do we still only have the 30M .jpg version (which is not too bad, despite)
23:45:27 <ralf> What does it mean to make haskell run on bare metal? 
23:47:38 <lightstep> ralf: that no OS is loaded
23:48:49 <dons> like the way C runs on bare metal
23:51:37 <Itkovian> but slower?
23:52:42 <dons> well, haskell is compiled to C, so it runs as fast as C, right?
23:52:51 <lightstep> dons: i have "Implementing Functional Languages: a tutorial" as pdf. that's what you meant, or another paper?
23:53:30 <dons> yep, not the tutorial, the book: http://research.microsoft.com/%7Esimonpj/papers/slpj-book-1987/index.htm
23:53:36 <SyntaxNinja> 'good night all
23:53:40 <SyntaxNinja> ttyl, ralf
23:54:35 <dons> there's been a recent thread on haskell-cafe@ about producing a .pdf via OCR
23:55:48 <dons> hmm, maybe I should read "Type Theory and Functional Programming"
23:56:30 <dons> " type theory is a functional programming language with some novel features"
23:56:38 <Itkovian> dons: I see very bad IPC for ghc compiled apps, e.g. for wli's fast fibonacci
23:56:46 <Maddas> Everything compiles to assembler sooner or later, so is everything equally fast? :-)
23:57:44 <Itkovian> nah, it's the 0's and 1's that are fast!
23:57:56 <dons> if required, you can often produce really fast code. i have a compiler for a small functional language, that compiles to unboxed, strict haskell. recursive functions are around as fast as gcc -O3
23:58:09 <lightstep> haskell runs really fast, but in circles
23:59:14 <dons> anyway, since a haskell program compiles to, say, 1000 lines of C, then it runs as fast as the same program written in (1000 lines of) C, right?
23:59:35 <dons> haskell is just a C macro language, anyway
23:59:39 <Maddas> No, since you probably wouldn't write it that way if you wrote it in C
23:59:45 <Itkovian> dons: can you get me a binary? I'd like to test it. 
23:59:56 <Maddas> I'm not saying it must run slower, I'm just saying that it probably wouldn't run equally fast
