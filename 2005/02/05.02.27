00:02:05 <musasabi> morning Oejet, how is the bzip2 binding going?
00:04:19 <Oejet> musasabi: Good morning.  I'ts going forward.  I'm just beginning on the higher level interface functions now, and I don't see any obstacles yet.
00:06:04 <musasabi> :-)
00:59:40 <bunnie> hello
01:01:51 <bunnie> is there something like haskell cookbook? common problems solved in haskell & example sources, etc..?
01:02:23 <autrijus> try te wiki?
01:05:08 <bunnie> great, thanks
01:05:18 <sorje> there's http://pleac.sourceforge.net/pleac_haskell/ too
01:05:50 <sorje> of doutfull usefullness
01:07:12 <Oejet> Aargh, my Emacs is confused about syntax highlighting.
01:10:14 <Cale> sorje: and which seems to contain errors
01:11:43 <Cale> What version of haskell is that supposed to be?
01:12:34 <Cale> s8 = "thIS is a loNG liNE".words.map capitalize
01:12:36 <Cale> ?
01:12:42 <sorje> It's got very strange definitions: http://pleac.sourceforge.net/pleac_haskell/a1102.html
01:12:57 <sorje> eg: (.) o f = f o
01:17:17 <Cale> Doesn't it sort of defeat the purpose of having a cookbook if in order to use the code, people need a bizarre set of definitions which conflicts with the prelude?
01:50:11 <shapr> I think pleac needs help.
01:51:25 <shapr> too bad it's not a darcs repo
01:58:15 <shapr> I hope it's quiet here because everyone is doing something useful or relaxing.
01:58:43 <shapr> I'm having fun reading this book, but it's hard to keep from immediately implementing a lot of these solutions.
02:01:34 * Oejet is working on a Bzip2 binding.
02:05:43 * musasabi was baking a pizza 
02:08:07 <Oejet> Nice.
02:35:09 <xerox> 'morning
02:48:21 * boegel boings
02:50:10 <xerox> hi!
02:51:23 <WilX> Wheee. Parsec is so hairy :/
02:57:46 <Lemmih> It is?
02:57:57 <WilX> It is.
02:57:58 <WilX> For me.
03:01:44 <Oejet> WilX: It's was/is a bit hairy for me too.
03:05:48 <danb> try HList :/
03:05:54 <danb> i need sleep
03:10:18 <Oejet> Emacs really needs a redo function.
03:11:42 <mflux> anti-undo or really redo-what-I-just-did?
03:24:14 <Oejet> I'm breathing in, I'm breathing out...
03:24:36 * Oejet dances the Haskell binding dance.
03:54:08 <Oejet> How is "Handle -> IO String" for a function reading from a .bz2 file?
03:54:58 <WilX> Hm, do you want to read the bytes?
03:55:58 <Oejet> WilX: I want to abstract the compression away, so that it returns the uncompressed file as a string.
03:56:15 <WilX> Oh.
04:01:55 <Oejet> WilX: So, I want to read from foo.bz2 like it was just foo.
04:02:09 <WilX> I see.
04:03:14 <Oejet> WilX: I'm trying to learn the Foreign Function Interface (FFI) while making a binding for libbz2.
04:04:53 <WilX> To meet is looks like you would have to hack GHC.IOBase or something to make it work transparently.
04:05:48 <WilX> s/meet/me/
04:08:56 <musasabi> Oejet: I would provide the following API: readBZip2 :: Handle -> IO String, writeBZip2 :: Handle -> String -> IO (), and finally a lower level api for people wanting to work with Ptrs.
04:09:16 <WilX> Hmm, Haskell needs a bit more abstract I/O. Maybe some type class that would group functions like hPutStr etc.
04:09:30 <jlouis> musasabi: where readBZip2 works lazily, I presume
04:09:53 <jlouis> like System.IO.Readfile does
04:09:57 <jlouis> readFile even
04:10:50 <musasabi> jlouis: yes.
04:12:30 <Oejet> musasabi: Thanks, I was thinking in the same lines too.
04:15:28 <Oejet> wilx: I'm not shure, I understand you correctly, why would I have to change IOBase?
04:16:38 <wilx> Well, I thought you want to get Handle by opening a file using some of your functions and then that it should work transparently with standard I/O functions.
04:16:55 <kosmikus> I think MissingH provides a class interface for IO: http://haskell.org/communities/11-2004/html/report.html#sect4.2.13
04:18:53 <wilx> Whee, exactly what I had in mind.
04:18:57 <Oejet> wilx: openFile "foo.bz2" >>= readBZip2.
04:19:08 <wilx> Now only if it was in standard Haskell.
04:22:35 <Oejet> wilx: The thing is that libbz2 opens it's own file on top of that handle: BZFILE* BZ2_bzReadOpen(FILE* f).
04:23:10 <jlouis> hmm, what is the easiest way to chop up a list into equal sized chunks? A bit of play with splitAt, or is there an easier way?
04:23:45 <wilx> Repeated takn n?
04:24:02 <wilx> take n even
04:24:37 <Oejet> @eval repeat (take 4) [1..10]
04:24:38 <lambdabot> (line 1, column 20):
04:24:38 <lambdabot> unexpected "."
04:24:38 <lambdabot> expecting simple term
04:24:38 <jlouis> then I have to drop the elements too, as far as I can see
04:24:58 <jlouis> hmm
04:25:01 <Oejet> @type repeat
04:25:03 <lambdabot> repeat :: forall a. a -> [a]
04:25:07 <jlouis> ah, this is lazy ;)
04:26:03 <jlouis> dummy solution with splitAt and where then
04:26:12 <Oejet> Hm, I think, I would define it myself.
04:27:46 <jlouis> just did here
04:28:00 <zamez> how can I trap (read n) failing?
04:28:08 <zamez> ie. the "no parse" thing
04:28:26 <Philippa_> use reads instead?
04:28:34 <wilx> @index catch
04:28:35 <lambdabot> Control.Exception,GHC.Exception,Prelude,System.IO,System.IO.Error,IO
04:28:37 <wilx> Maybe?
04:28:52 <jlouis> now with a tail-recursive ``chop'' function
04:32:23 <TheHunter> zamez, unfortunately, there's indeed no better way to do it than reads. People have complained about a missing readM :: (Read a, Monad m) => String -> m a quite loudly, but it never made it into the libs.
04:50:39 <zamez> reads looks good, thanks
04:55:39 <shapr> yow!
05:06:17 <Lemmih> @seen SyntaxNinja
05:06:17 <lambdabot> I saw SyntaxNinja leaving #haskell 15 hours 29 minutes 45 seconds ago.
05:20:58 * boegel yawns
05:30:24 <wilx> Bah...
05:31:35 <boegel> wilx: ?
05:31:47 * wilx is confused by Parsec
05:31:57 * boegel suggests Happy
05:32:41 <musasabi> parsec is imho easier.
05:33:04 <wilx> Well, I cannot quite grok it yet :/
05:33:06 <zamez> how can I get show not to use scientific notation for floats?
05:34:02 <TheHunter> zamez, http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
05:34:13 <zamez> thanks, TheHunter
05:36:59 <boegel> musasabi: I think Happy is easier :) but I could be wrong ;)
05:37:49 <jlouis> wilx: Parsec is not that hard. But the document describing it could be better. You should be aware that there is many combinators introduced, and that can indeed be daunting
05:38:16 <jlouis> Also, I think that Parsec being predictive is a bad thing. I often find myself wanting non-predicativeness
05:39:33 * boegel out
05:40:12 <zamez> can't get showFloat / show[FG]Float to give me the output I want :/
05:40:24 <zamez> I just want to show -0.05
05:40:36 <TheHunter> *Main Numeric> showEFloat (Just 4) pi ""
05:40:37 <TheHunter> "3.1416e0"
05:40:45 <cptchaos> wilx: what is confusing you?
05:41:18 <zamez> I'd like -0.05 to be output like that
05:41:34 <wilx> Well, those lexer parsers and the token parser.
05:41:41 <TheHunter> ahh, i didn't see the `not'
05:42:23 <TheHunter> *Main Numeric> showFFloat Nothing (-0.05) ""
05:42:23 <TheHunter> "-0.05"
05:43:07 <zamez> ah, thanks
05:43:31 <zamez> thought I'd tried every combination of Nothing / Just / EFG
05:44:23 <Oejet> Juhuuu!  I have a usefull Bzip2 binding.
05:44:31 <Lemmih> Oejet: Great.
05:45:01 <sorje> Oejet, can we see it? ;-)
05:45:14 <Oejet> It has some issues though; error handling, laziness, bugs, etc.
05:45:43 <cptchaos> wilx: well if I remember right, you will define for each Language an own "alphabet" the "letters" in thos alphabet are called the tokens. But jour inputfile comes in as an bitstream (or char-list in haskell), so you parse the charstream with a lexer (parser) to get the right alphabet for your language, i.e. your tokens.
05:46:27 <cptchaos> s/jour/your/ ... ouch
05:47:45 <Oejet> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:47:49 <cptchaos> so your lexer is in a way a pre-parser
05:48:04 <bourbaki> moin
05:48:08 <wilx> Yup.
05:48:09 <cptchaos> wilx: I hope that helps
05:48:17 <bourbaki> how is the support of haskell for macs?
05:48:28 <bourbaki> i mean is there a ghc port and such?
05:48:50 <Oejet> I hope it's readable.
05:53:46 <cptchaos> @seen pesco
05:53:47 <lambdabot> I haven't seen pesco
05:54:02 <Oejet> Just made some microscopical changes to the wiki: "writeBZip2 h text2" --> "writeBZip2 h text".  Or else it will be too slow, if anyone wants to try. :-)
05:55:20 <Oejet> So any comments, sorje?
05:55:25 <cptchaos> Oejet: I will take a look at it,
05:55:34 <cptchaos> will take a moment
05:56:08 <sh10151> bourbaki: there is a GHC port, it works
05:56:21 <sh10151> bourbaki: someone's got a package for it
05:56:37 <sh10151> OS X is a Unix so it's much better than Windows in general for things like Haskell
05:58:00 <cptchaos> Oejet: Well looks fine, but I don't have time for testing at the moment.
05:58:20 <cptchaos> in a way selfexpanatory
05:58:40 <Oejet> cptchaos: Really?  :-)
05:59:29 <Oejet> Well, you have to know how to use libbz2.
06:00:33 <cptchaos> Oejet: I don't really, but looks like basikly like a read and write for bzfiles i.e. with (de)compression inlined
06:01:08 <cptchaos> Oejet: J don't know libbz2 really
06:02:36 <cptchaos> but actually the the foreign call would make me look there :-), if it does not work the way I expected
06:19:33 <kwrprcw> hi #haskell
06:19:51 <Lemmih> Hey kwrprcw.
06:20:06 <xerox> hiya.
06:20:28 <kwrprcw> a silly question: why is (:%) hidden from module Ratio?
06:20:46 <xerox> @type (:%)
06:20:47 <lambdabot> bzzt
06:21:05 <Lemmih> @index (:%)
06:21:06 <lambdabot> bzzt
06:21:17 <kwrprcw> ?
06:21:25 <zamez> !
06:21:30 <xerox> What is supposed to be?
06:21:36 <jlouis> wouldn't ^B be funnier than bzzt ;)
06:21:44 <kwrprcw> sorry... I'm newbie...
06:22:34 <kwrprcw> could you please explain it?
06:22:48 <xerox> What do you mean with: (:%) ?
06:23:14 <tromp> because it should only be applied to relatively prime numbers
06:23:26 <kwrprcw> the data constructor in Ratio
06:23:46 <tromp> so 2 :% 4 would be illegal
06:23:58 <mauke> @type (%)
06:24:00 <lambdabot> bzzt
06:24:04 <jlouis> since they are not relatively prime (their gcd is non-null)
06:24:12 <jlouis> % is defined in Data.Ratio
06:24:19 <jlouis> gcd is not 1 even
06:24:21 <jlouis> doh
06:24:31 <tromp> gcd is never 0 :)
06:24:32 <jlouis> (sorry for sleeping in the middle of the day)
06:24:37 <kwrprcw> i see... but then how can I pattern-match a rational number
06:24:39 <Oejet> @type (Data.Ratio.%)
06:24:44 <lambdabot> (Data.Ratio.%) :: forall a.
06:24:44 <lambdabot> 		  (Integral a) =>
06:24:44 <lambdabot> 		  a -> a -> GHC.Real.Ratio a
06:24:54 * Oejet won. :-P
06:25:10 <tromp> you cannot pattern-match them...
06:25:13 <jlouis> tromp: hehe, no ;)
06:25:49 <tromp> i wanted to pattern-match named constants, like draw=0 but that wont fly either:(
06:26:24 <kwrprcw> it's a bit inconventient for me
06:26:55 <jlouis> wrap it inside a data type. Then you match on it
06:27:22 <kwrprcw> how to do this?
06:27:36 <jlouis> grab your haskell book/tutorial and read ;)
06:27:52 <jlouis> it is probably easier than me trying to tell you how to use the ``data'' keyword
06:27:53 <kwrprcw> ok :)
06:27:57 <tromp> i dont see how wrapping wld help
06:29:09 <TheHunter> another case where we'd need views, so the best thing we can do are pattern guards...
06:29:24 <jlouis> data Foobar = Rat Data.Ratio.Rational | Somethingelse Int | ...
06:29:35 <jlouis> case x of Rat x -> ...
06:29:39 <TheHunter> foo x | (n,d) <- ratToPair x = ...
06:29:40 * Oejet goes running.  See you later.
06:29:51 <TheHunter> kwrprcw, ignore me.
06:30:24 <tromp> that still won't let him match on Rat (1 :% 3) ...
06:30:37 <jlouis> tromp: ah
06:30:42 <jlouis> no
06:30:51 <tromp> which is what he wanted:(
06:30:55 <jlouis> bleh
06:31:06 <jlouis> then it doesn't work. doh
06:31:14 <tromp> Rats :P
06:31:36 <jlouis> TheHunter: is that haskell98 syntax?
06:31:51 <TheHunter> jlouis, no, it's a ghc (only) extension.
06:32:38 <TheHunter> jlouis, you gotta read this page, a lot of interesting stuff there: http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html
06:33:50 <jlouis> TheHunter: thanks!
06:34:05 <TheHunter> oh, pattern guards are documented here: http://haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
06:35:06 <kwrprcw> it seems that not only Ratio but *every* module hides its data constructors... why?
06:35:50 <xerox> @pointless (\x -> concat . (map x))
06:35:51 <lambdabot> Sorry, I don't know the command "pointless", try "lambdabot: @listcommands
06:36:01 <Oejet> kwrprcw: Data abstraction maybe?
06:37:09 <TheHunter> thbot: @pointless (\x -> concat . (map x))
06:37:10 <thbot> (=<<)
06:37:22 <xerox> Yay.
06:37:40 <kwrprcw> perhaps. but that disables pattern-matching
06:37:48 <xerox> Nomaware says l >>= f = concatMap f l for lists.. ?
06:39:11 <TheHunter> kwrprcw, that's true, but the value of abstraction is considered higher. There's a quite old proposal of "views" to allow pattern matching on non-constructors, but it never got implemented.
06:40:05 <kwrprcw> i see. thanks :)
06:41:25 <xerox> @pointless (flip concatMap)
06:41:25 <lambdabot> Sorry, I don't know the command "pointless", try "lambdabot: @listcommands
06:41:26 <thbot> (>>=)
06:41:32 <xerox> Ah-ha.
06:43:57 <xerox> TheHunter, is it possible to use the @pointless thing in GHCi, without your bot?
06:46:50 <TheHunter> xerox, not in ghci. I can send you my latest version, it has kind of an offline interface.
06:47:32 <araujo> Helo here
06:47:50 <xerox> TheHunter, it would be very nice, thank you.
07:05:44 <wilx> Hmpf.
07:05:55 <wilx> Something wrong with my parser. It doesn't skip white spaces.
07:11:59 <musasabi> back.
07:12:33 <Oejet> I'm back too. :-P
07:13:40 <musasabi> We were skiing on sea ice today too..
07:13:53 <Oejet> Nice.
07:28:23 * boegel kicks Itkovian 
07:29:04 <bourbaki> moin boegel
07:29:10 <bourbaki> quick question boegel
07:29:28 <boegel> bourbaki: shoot
07:29:42 <bourbaki> in your raytracer how do you do the ray intersection to objects?
07:29:54 <bourbaki> based on octrees and the object itself?
07:31:00 <boegel> octrees? :)
07:31:23 <boegel> I simply solve an equation
07:33:02 <bourbaki> ok
07:33:08 <boegel> bourbaki: why ?
07:33:16 <_Codex> boegel: what kind of algo you have for solving equations?
07:33:18 <bourbaki> cause i still think about how to render my geometry mapping stuff
07:34:15 <boegel> _Codex: it's just combining the ray equation and the object equation, and looking for intersection points
07:35:29 <_Codex> any screenshots available?
07:37:52 <boegel> heh :D
07:37:55 <boegel> lot's !
07:38:19 <boegel> _Codex: http://studwww.ugent.be/~kehoste/thesisPublic/website/
07:38:47 <_Codex> ooh, that looks nice.
07:40:20 <boegel> :D
07:40:22 <boegel> thanks
07:46:58 <boegel> I have to go, bye
07:47:04 <xerox> Bye!
07:47:21 <mauke> I wrote my first haskell program!
07:47:27 <mauke> http://rafb.net/paste/results/JIyJNP74.html
07:49:46 <shapr> mauke: yay!
07:50:35 <Oejet> mauke: Nice program.
07:50:44 <wilx> Wheee!!!
07:50:54 <shapr> nnunley: any QuickCheck or TDD-version questions?
07:51:00 <xerox> @type (>>)
07:51:01 <lambdabot> (>>) :: forall m b a. (Monad m) => m a -> m b -> m b
07:51:03 <wilx> The parser is not beautiful but it works.
07:51:05 <wilx> Yay!
07:51:32 <shapr> wilx: yay! you can make things beautiful after they work, if beauty is important to you.
07:51:48 <wilx> True :)
07:53:56 <Oejet> mauke: I have some suggestions, though.
07:54:56 <mauke> yes?
07:55:12 <Oejet> mauke: Hold on a second.
07:56:46 <wilx> The not pretty thing with my parser is that I haven't figured out how to use lexer to skip spaces for me so I have to use "spaces" parser everywhere :/
08:05:02 <Oejet> mauke: http://www.haskell.org/hawiki/HaskellIrcPastePage
08:05:23 <jlouis> wilx: you create a token parser and tell it what is keywords, symbols etc. Then parsing with ``symbol "*"'' instead of ``string "*"'' automatically eradicates spaces
08:05:33 <jlouis> etc
08:05:45 <Oejet> My suggestion is to untangle the IO stuff from the castle generating stuff.
08:06:12 <wilx> Hm.
08:06:41 <jlouis> there is a function call that you use to create token parsers... Text.ParserCombinators.Parsec.Token.makeTokenParser
08:07:09 <jlouis> You will have to read the section on it closely
08:07:16 <jlouis> but it is not hard to utilize it
08:07:26 <wilx> 'k
08:07:29 <wilx> Will do.
08:09:31 <mauke> Oejet: ah, thanks. that's obviously better
08:09:53 <mauke> I didn't know how to do x and join() in haskell :-)
08:14:02 <bloomberg> are you allowed to have undefined elements in an array
08:14:29 <esap> Hmm... how do I define a constructor whose underlying arrow type is not (->)?
08:17:32 <nnunley> shapr:  Not yet.  Been dealing with family issues for the moment. :)
08:18:17 <Oejet> mauke: Can you think of a way to completely get rid of repeated?
08:20:06 <mauke> well, you could inline it
08:20:54 <Oejet> replicate n ' ' == replicated n " ".
08:21:19 <mauke> yeah, but what about "/\\"?
08:22:20 <Oejet> Heh, I noticed that too.
08:23:06 <tromp> what's replicated?
08:23:09 <tromp> @index replicated
08:23:09 <lambdabot> bzzt
08:23:33 <Oejet> tromp: http://www.haskell.org/hawiki/HaskellIrcPastePage
08:24:29 <mauke> hey, could you say replicated = concat . replicate?
08:24:45 <Oejet> mauke: Yeah. :-)
08:26:13 <Oejet> mauke: I've updated the wiki.
08:26:34 <tromp> that's different
08:27:08 <tromp> since replicate has 2 arguments
08:27:26 <lou-tze> hi
08:27:52 * metaperl thinks CPS is a cool idea (from reading YAHT)
08:27:58 <mauke> concat (zipWith (\a b -> [a,b]) (replicate m '/') (replicate m '\\'))
08:28:01 <mauke> OBVIOUS
08:29:27 <metaperl> mauke, are you ....
08:29:55 <metaperl> mauke are you different from #perlhelp's mauke?
08:30:04 <mauke> no
08:30:16 <metaperl> are you a regular haskell user or a new one?
08:30:27 <mauke> very new; this is my first program
08:30:44 <metaperl> i see. i'm fairly new as well.
08:31:05 <mauke> I blame autrijus and pugs
08:31:07 <Oejet> Why is (concat (replicate m "/\\")) /= (concat. replicate) m "/\\"  ?
08:31:44 <integral> (concat . (replicate m)) "/\\" is the same as the first?
08:32:06 <metaperl> my entry into haskell was parallel with pugs, but not beceause of it. I posted on comp.lang.functional about Perl's context sensitivty and a regexp library for Haskell that was context-sensitive caught my attentoin. then I learned of pugs, etc.
08:32:08 <mauke> (concat . replicate) m "/\\" is (concat (replicate m)) "/\\"
08:32:11 <TheHunter> @type (concat .) . replicate
08:32:12 <lambdabot> (concat .) . replicate :: forall a. Int -> [a] -> [a]
08:33:36 <mauke> ah, I remember that posting
08:36:20 <Oejet> mauke: So, are you ready to learn the FFI now? :-P
08:37:05 <mauke> heh
09:17:44 <Oejet> shapr: How's the reviewing going?
09:22:28 <tic> Why is my funktion-returning-something and the next line with return () glued together?
09:26:42 <metaperl> backticks are used to use a function in infix form. However, what is in backticks must be a literal function name. What can one do if a function name is in a variable and you want to use it in backticks form? E.g. docall f a b = a `f` b --- will try to call a literal f instead of what f represents
09:28:16 <tic> Does everything in a monad, say IO, need to return something IO-ish?
09:28:35 <TheHunter> tic, yes.
09:28:53 <TheHunter> metaperl, i don't understand.
09:29:22 <metaperl> I'm just saying that x `elem` lis works
09:29:28 <metaperl> because elem is a real function
09:29:30 <metaperl> but assume
09:29:33 <metaperl> f = elem
09:29:40 <metaperl> can we get x `f` lis to work
09:29:49 <metaperl> where f == elem
09:30:15 <metaperl> so the backticks dont call "f" but the function that f represents
09:30:23 <TheHunter> if you define f = elem, then sure x `f` lst will work.
09:30:26 <tic> TheHunter, okay.  I solved it using case ... of _ -> do putStrLn, as that was what was coming after the expression anyway. :)
09:30:41 <metaperl> oh. the magic of first class functions :)
09:31:09 <TheHunter> metaperl, you mean you want to use the function name (as a string) to access the function?
09:31:18 <metaperl> no, not as a string
09:31:26 <metaperl> just like I showed
09:31:28 <metaperl> f = elem
09:31:33 <metaperl> a `elem` lis
09:31:34 <TheHunter> that works fine.
09:31:36 <tautologico> then f is elem
09:31:37 <metaperl> a `f` lis
09:31:41 <metaperl> should do the same thing
09:31:48 <TheHunter> you can infixate anything.
09:31:48 <metaperl> ok
09:31:52 <tautologico> it does
09:32:33 <tautologico> the difference between f and the function that f represents is that "f" is a string, a name... it represents the same function as elem
09:33:12 <TheHunter> metaperl, a nice thing about haskell is referential transparency: If you define f = ..., then you always get the same result as if you had used ... everywhere where there's an f.
09:33:22 <metaperl> oh ok
09:35:36 <tromp> whenever i see a compiler error like
09:35:38 <tromp>     Couldn't match `[([(Int, GameTree)], b)]' against `Int'
09:35:38 <tromp>         Expected type: [([(Int, GameTree)], b)]
09:35:38 <tromp>         Inferred type: Int
09:35:57 <tromp> i go: yes, of course it's an int. what on earth made you expect the other?
09:36:33 <tromp> ghc could be a bit more verbose in why it expects something
09:38:27 <tautologico> in my experience with HM type systems, it's almost always easy to see why the inferred type is different than what you'd expect... mostly it's just some silly mistake
09:40:34 <wilx> @index htons
09:40:34 <lambdabot> bzzt
09:40:36 <tromp> ah, i have lookup arguments in wrong order:(
09:40:37 <wilx> @index htonl
09:40:38 <lambdabot> bzzt
09:41:03 <wilx> Is there something similar to C hton{l,s}() functions?
09:42:58 <tic> read?
09:59:32 <tromp> profiling can give unexpected results
10:00:26 <tromp> 30% of my allocations are in a routine that just operates on a 64bit with a bunch of shifts + ands
10:00:46 <tromp> isWon bb = dir 1 /= 0 || dir height /= 0 ||
10:00:46 <tromp>            dir height' /= 0 || dir height'' /= 0 where
10:00:46 <tromp>   dir d = let t = bb .&. (bb `shiftR` d) in t .&. (t `shiftR` (2*d))
10:14:15 <tic> hrm, is there no returnIO?
10:14:52 <tromp> to do what?
10:16:38 <Oejet> tromp: My connect-four brain also spends most of it's time doing bit operations on Word64's.
10:17:17 <tromp> at least ur brain has no space leak
10:17:48 <Oejet> Could I see the profile results?
10:18:10 <musasabi> wilx: you could use network-alt, it wraps them.
10:18:15 <tromp> alphabeta                      GameTreeSearch        22.3   17.5
10:18:15 <tromp> isWon                          Connect4              20.4   29.7
10:18:15 <tromp> goodMoves                      Connect4              16.4   17.8
10:18:15 <tromp> move                           Connect4              13.9   16.3
10:18:15 <tromp> isLegal                        Connect4               8.2    4.0
10:18:16 <tromp> updateTT                       GameTreeSearch         5.2    3.4
10:18:18 <tromp> makeGameTree                   Connect4               2.6    1.7
10:18:20 <tromp> isLegalWon                     Connect4               2.3    2.6
10:18:22 <tromp> lookupTT                       GameTreeSearch         2.2    1.1
10:18:24 <tromp> hashTT                         GameTreeSearch         2.0    1.4
10:18:26 <tromp> storeTT                        GameTreeSearch         1.3    0.9
10:18:28 <tromp> encode                         Connect4               1.1    1.1
10:20:00 <Oejet> Looks reasonable.
10:59:33 <shapr> Oejet: it's going, nearly done.
11:07:54 * Oejet is going to the local pub.
11:49:04 <heatsink> Do you put instance definitions near the data definition, or near the class definition?
11:49:24 <Heffalump> depends
11:49:37 <Heffalump> if I control both, it depends which is higher level.
11:49:48 <Heffalump> (in fact, that's a general principle)
11:49:50 <heatsink> higher level?
11:50:00 <Heffalump> in terms of my program structure
11:50:15 <Heffalump> I build high level modules on low level ones
11:52:01 <heatsink> okay...
11:52:03 <lightstep> programs shouldn't be kept in files
11:53:11 <heatsink> In this case I'm not so much building modules on top of other modules as definining interfaces between modules
11:53:42 <heatsink> So I'm writing versions of module A and B that I'll probably replace later, used by module C
11:54:14 <heatsink> so it would probably make sense to put the instance with the data definition for A and B
12:14:18 <tic> reading an integer in haskell should be as easy as the following, right?
12:14:21 <tic> n <- getLine
12:14:28 <tic> let i = read n :: Integer
12:14:33 <tic> dowhatever with i
12:15:11 <lightstep> lambdabot: @type readLn
12:15:13 <lambdabot> readLn :: forall a. (Read a) => IO a
12:15:17 <lightstep> pascal rocks
12:15:19 <tic> a-ha.  what was I doing?
12:16:17 <tic> also, do I need to end the input with a magical character, or is it just \n?
12:16:33 <Heffalump> should just be \n
12:16:46 <Heffalump> and I'd have expected what you said above would work too
12:17:12 <tic> okay, then it's probably something else. Grmbl..
12:18:10 <tic> Oh, a never-ending SWhile. :)
12:18:20 <heatsink> what?
12:18:45 <glimming> Why is a row variable of kind kappa?
12:18:52 <tic> heatsink, writing an interpreter.
12:19:09 <heatsink> hmm, for what language?
12:19:26 <glimming> kosmikus?
12:22:29 <tic> heatsink, my own :)
12:23:55 <Philippa_> oh FFS
12:24:01 <Philippa_> so much for him not asking questions constantly
12:24:32 <heatsink> tic: neato.  Is this #esoteric worthy?
12:24:44 <tic> heatsink, not at all, probably.  just an assignment for school.
12:24:52 <heatsink> ok
12:24:58 <tic> sorry....
12:25:18 <shapr> Philippa_: y0
12:25:40 <Philippa_> 'lo
12:26:12 <shapr> hey, do you want to blab about semantic friggery?
12:26:36 <shapr> no monad transformers article this month, though.
12:41:56 * shapr goes to sleep
12:42:02 <heatsink> night shapr
12:42:38 * heatsink has trouble combatting the fear that someday I will want to make another function with the same concise name as the function that I am making now and thus perhaps I should give this function a longer, more descriptive name.
12:54:36 <Oejet> Good evening all.
12:54:42 <heatsink> good evening
12:54:43 <_JusSx__> no
12:54:50 <heatsink> good evening some.
12:54:52 <_JusSx__> Philippa_: are you female?
12:55:52 <heatsink> Hmm, sets require their elements to be of type Ord.
12:56:11 <heatsink> I guess I can just use a list.
12:56:20 <lightstep> this question really seems to get asked a lot
12:56:35 <heatsink> which question? a/s/l?
12:56:52 <lightstep> _JusSx__' question
12:58:46 <heatsink> I don't see the importance.
13:00:32 <lightstep> of my comment or of the question? or something else entirely?
13:00:38 <heatsink> of the question.
13:01:21 <lightstep> haskell will lead you on the road to enlightenment
13:01:29 <_JusSx__> lol
13:01:46 <_JusSx__> and ocaml?
13:02:14 <heatsink> So if they put a camel on the cover of Perl O'Reilly books, then what do they put on OCaml O'Reilly books?
13:02:28 <Darius> lightstep: If it gets asked a lot, it isn't here.  At least, not in my experience.
13:03:06 <lightstep> i heard it 2 or 3 times
13:03:35 <lightstep> which is a lot, comparing to 0 times on the other 100-odd users
13:03:36 <Darius> heatsink: About a bit earlier: are you likely to define the other function in the same module?
13:04:56 <heatsink> I don't know which other function you're talking about.  I'm putting everything in one file for now.
13:07:24 <Darius> heatsink: A bit earlier you expressed fear of a possible name conflict in the future.
13:07:37 * boegel yawns and cheers
13:07:56 <heatsink> Oh.  I'm more likely to define the other function in another module.  Its name is "unconditional".
13:10:39 <araujo> Howdy
13:10:43 <heatsink> 'alo.
13:11:06 <boegel> hey autrijus
13:11:08 <boegel> woops
13:11:12 <boegel> hey araujo
13:11:24 <araujo> Hello boegel 8)
13:18:30 <boegel> @wiki TheMonadReader
13:18:31 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
13:21:50 <Oejet> How does data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode correspond to fdopen's r,r+,w,w+,a,a+?
13:22:13 <heatsink> IOMode = 'r' | 'w' | 'a' | 'r+'
13:22:58 <Oejet> heatsink: Thanks!  How did you know that?
13:23:41 <heatsink> I'm not positive, but that's what I'd infer from the behavior of fdopen.
13:23:41 <_JusSx__> why learning haskell instead of Ocaml?
13:24:05 <SamB> Ocaml -- is it playful?
13:25:13 <lightstep> haskell has theorems for free, and syntax with less semicolons
13:25:20 <Oejet> _JusSx__: Why not learn both?
13:25:32 <_JusSx__> Oejet: i think you are right
13:25:43 <_JusSx__> Oejet: your answer is the best one
13:26:04 * Oejet won again. :-P
13:26:19 <SamB> I don't know if I'll ever have time to learn Ocaml...
13:26:39 <_JusSx__> who partecipated to ICFP programming constest?
13:26:42 <SamB> it seems complicated
13:26:52 <Darius> it seems ugly
13:27:03 <tautologico> it's not complicated... the syntax is a bit odd though
13:27:09 <Oejet> OCaml maps easier to the pseudo code of usual algorithm books.
13:27:29 <SamB> Oejet: which books are those?
13:27:37 <tautologico> it has some quirks, but it's a good language
13:27:49 <_JusSx__> yeah i studied it
13:27:50 <Oejet> _JusSx__: I participated!  Although my butt got wooped big time by Heffalump's team.
13:27:58 <_JusSx__> i think it's really good
13:28:09 <_JusSx__> but i think functional languages are great
13:28:22 <SamB> Does it have a nice tutorial/spec? The Haskell spec is actually usable as a manual.
13:28:31 <_JusSx__> Oejet: really?
13:29:01 <Oejet> _JusSx__: Yes, indeed.
13:29:34 <_JusSx__> can you send me your post?
13:30:37 <Oejet> You mean my ant brain or my Common Lisp ant macro language or my OCaml simulator?
13:30:51 * Heffalump spots his name being mentioned :-)
13:30:58 <Darius> Next year's ICFP contest should be interesting.
13:31:07 <SamB> when was ICFP?
13:31:14 <_Codex> ants..
13:31:15 <Darius> Er this year's.
13:31:15 <Heffalump> we're wondering how they intend to stop people working on their programs in the gap
13:31:20 <_JusSx__> has your team a homepage?
13:31:24 <_JusSx__> everything
13:31:45 <Oejet> Heffalump: They don't.  I think that's part of the trick.
13:32:05 <Heffalump> http://urchin.earth.li/icfpcontest/2004/Introduction
13:32:14 <heatsink> what's the gap?
13:32:44 <Heffalump> 3 day contest, then 2 weeks later they modify the problem spec and give 24 hours for revised entries
13:32:52 <Heffalump> to encourage people to plan ahead
13:33:11 <_JusSx__> great works
13:33:15 <heatsink> that's an interesting concept.
13:34:36 <Oejet> Which means basically that your first submission should be modular like never seen before.
13:34:58 <Heffalump> maybe, but what's to stop people making their code much better in the two weeks inbetween?
13:35:17 <SamB> combinators, anyone?
13:35:52 <Oejet> Heffalump: If they can do that, then they obviously didn't score well in the first submission.
13:36:13 <SamB> Oejet: not necessarily
13:38:05 <Oejet> What if they change the problem half way through the 72 hours?
14:06:55 <heatsink> typing question on www.haskell.org/hawiki/HaskellIRCPastePage
14:07:09 <lightstep> IRC? not Irc?
14:07:18 <heatsink> Irc
14:08:31 <lightstep> makeBar :: forall a b. (Bar a) => b -> a
14:08:47 <lightstep> Foo :: a -> Foo a
14:09:16 <heatsink> oh, I get it.
14:12:07 <Oejet> mauke: PING
14:12:29 <heatsink> Hmm, what's the command line parameter to ghc so it will understand forall?
14:12:55 <Oejet> -fglashow-exts?
14:13:07 <heatsink> that worked
14:13:54 <Heffalump> is that for if you want drunk Haskell compilation?
14:14:09 <heatsink> heh
14:14:48 <Oejet> Doh.
14:16:18 <heatsink> This still doesn't type properly, I think because the makeBar type given above accepts inadmissible things like (Int -> Foo String)
14:17:15 <lightstep> makeBar would usually be a constant function
14:18:11 <heatsink> what is a constant function?
14:19:16 <lightstep> function that has the same value on every member of the domain
14:19:35 <MachinShin> hey +
14:21:10 <heatsink> In what I'm doing, it's not constant
14:22:15 <heatsink> Is it constant in the sample code?
14:24:51 <lightstep> the sample code looks like it contains a type error
14:25:01 <Darius> heatsink: Perhaps what you want is, class Bar f where makeBar :: a -> f a?
14:25:46 <heatsink> Darius: that sounds correct
14:26:39 <heatsink> I get a Kind error when I do that. I've never gotten a kind error before.
14:27:24 <Darius> In that case the instance declaration would be instance Bar Foo where makeBar = Foo.
14:27:37 <dons> heatsink: you have now reached "level 4 haskell hacker"
14:28:03 <heatsink> dons: I earn a title by getting an obscure error?
14:28:08 <Pseudonym> You reach level 5 when you hit the monomorphism restriction.
14:28:12 <heatsink> man, this is easy!
14:28:22 <heatsink> Actually, I've reached the monomorphism restriction before.
14:28:37 <Pseudonym> Oh, well.  Advance to level 5 immediately, then.
14:30:27 <heatsink> okay, the typing seems to work now.
14:31:52 <heatsink> I take it that now that I've typed makeBar thus, all instances of Bar must be parametrized on one type?
14:32:00 <lightstep> yes
14:32:35 <Shammah> morning.
14:32:36 <heatsink> interestingly, I can parametrize on a dummy type and things work out fine.
14:33:06 <funkmando> yo, how can i check that a String is formatted as i desire (i want it to be 4 digits and nothing else)
14:33:38 <Cale> funkmando: all isDigit str ?
14:33:47 <funkmando> neat
14:33:49 <heatsink> funkmando: isDigit is in module Char
14:33:57 <Cale> and I suppose you want to check that its length is 4
14:33:58 <heatsink> Data.Char
14:34:02 <lightstep> heatsink, what do you mean by dummy type?
14:34:30 <heatsink> lightstep: for example, data Foo a = Foo Int
14:34:33 <dons> funkmando: 'all' is useful here.
14:34:51 <lightstep> that's called a phantom type
14:35:03 <heatsink> I like that name.
14:35:07 <funkmando> cale : yeah
14:36:47 <heatsink> Thanks for your help, lightstep, darius
14:37:11 <Cale> funkmando: For more sophisticated matching, you might be interested in http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text.Regex.html
14:38:37 <funkmando> hmm
14:38:56 <funkmando> i don't see how that applies to my problem
14:39:17 <dons> it lets you check if strings are formatted a certain way..
14:39:53 <dons> but if your requirements are simple, then, say: \s -> all isDigit s && length s == 4 is probably enough
14:40:12 <dons> == [0-9]\{4\}
14:40:29 <funkmando> ok
14:42:00 <dons> alternatively, you could explicitly match: good s@(_:_:_:_:[]) | all isDigit s = True
14:42:39 <funkmando> good?
14:42:44 <Igloo> If this is a real program taking user input then testing length s == 4 is O(n), so something you want to avoid
14:42:44 <funkmando> @type good
14:42:45 <lambdabot> bzzt
14:42:58 <funkmando> igloo, no it's just running off the ghci
14:43:58 <dons> yeah, that length above would suck.
14:44:08 <dons> no 'length' calls in yi, for example.
14:46:03 <funkmando> 4 computations is not really a problem though..
14:46:51 <Oejet> dons: Why not length calls i Yi?
14:46:56 <funkmando> the problem is this check im doing comes *after* a function call, so it throws exception before i've got to the formatting check :(
14:49:01 <dons> Oejet: it is very unwise to call length over an editor buffer, which could be several (many..) megabytes. you end up with huge space usage
14:49:30 <funkmando> any ideas? http://www.pastebin.com/247151
14:50:11 <dons> Oejet: in fact, the critical 2 functions that have to walk an entire Yi buffer are written in C.
14:50:46 <Oejet> dons: Ah, so length is O(n) in memory consumption.   Though that sound suboptimal.
14:50:50 <dons> yeah.
14:51:15 <Oejet> dons: Making a Haskell interpreter in C inside Yi?  :-P
14:51:22 <lightstep> the first recursive call to mycount seems wrong
14:51:27 <dons> I'm not oppposed to fragments of purely functional C :) It's quite useful.
14:51:45 <dons> nah, there's only 5-10 lines of C.
14:51:53 <funkmando> lightstep : why?
14:51:55 <Oejet> What do they do?
14:52:00 <Oejet> Using the FFI?
14:52:08 <dons> e.g. while (p < q) if (*p++ == '\n') c++;
14:52:14 <Itkovian> Igloo, what would be a good way to check if there are k elements in a list, besides using length?
14:52:19 <Itkovian> splitAt?
14:52:23 <lightstep> funkmando, mycount expects 3 args, you give it 2
14:52:37 <dons> Oejet: using the FFI, yep.
14:52:53 <funkmando> lightstep : [] [] count
14:52:55 <funkmando> 3 args
14:53:05 <dons> one function counts the number of newlines, another finds the index of a specific line.
14:53:38 <Darius> dons: What's the (internal) type of a buffer?
14:53:39 <Igloo> That would be one way
14:53:54 <Igloo> You'd need to check length of the fst of the result and null of the second
14:54:05 <dons> data FBuffer_ =
14:54:05 <dons>         FBuffer_ !(Ptr CChar)   -- raw memory           (ToDo unicode)
14:54:05 <dons>                  !Int           -- current position     (ToDo list of pnts)
14:54:05 <dons>                  !Int           -- length of contents
14:54:05 <dons>                  !Int           -- raw size of buffer
14:54:23 <lightstep> funkmando, i meant the call on line 007
14:54:49 <Igloo> It's probably nicest to just write a recursive lengthIs :: Int -> [a] -> Bool, though
14:54:54 <Itkovian> Igloo, yes, that was what I meant...
14:55:08 <Itkovian> hmm
14:55:28 <funkmando> mycount xs ys  count  3 args?
14:55:48 <Oejet> dons: Couldn't that be done with plusPtr then, or is that too slow?
14:56:00 <dons> it turned out to be too slow.
14:56:09 <dons> though I use it in other places
14:56:25 <lightstep> funkmando, here i see line 007 as "      | x == y = mycount xs    (count+1)", which doesn't make sense
14:57:19 <dons> in other places advancePtr seems fine, i.e. to read small chunks of a buffer: peekArray n (p `advancePtr` i)
14:57:50 <Darius> Igloo: It seems better to write more general functions then specialize them.
14:57:57 <funkmando> umm
14:58:07 <funkmando> lightstep it's mycount xs ys (count + 1)
14:58:22 <funkmando> for some reason the ys is underlined
14:58:26 <funkmando> and in turqoise
14:59:17 <lightstep> oh, sorry. anyway, i don't understand the code. strings are usually used for text processing, and here you use them to encode some information
14:59:51 <lightstep> you can use lists of a user-defined type instead, which would be much clearer
15:00:13 <Darius> Igloo: i.e. a version of take or drop that returned Maybe and didn't allow less than what is requested (returning Nothing in those cases)
15:00:16 <funkmando> ...
15:00:18 <funkmando> so anyway
15:00:34 <funkmando> how can i have it do the format check before it processes the function calls?
15:00:49 <Darius> With an if statement.
15:02:03 <funkmando> yeah but i can't assign variables
15:02:26 <lightstep> you can use let
15:02:54 <funkmando> can i say let x = True if(suchandsuch) else False ?
15:04:12 <Oejet> Good night everyone!
15:04:21 <lou-tze> i guess you can, but you'll be the only one knowing what you mean ;)
15:04:21 <funkmando> good night
15:05:26 <Darius> funkmando: You can write let x = if such and such then True else False, of course this is the same as let x = such and such.
15:06:00 <Darius> funkmando: An if statement is an expression (so I guess I should call it an if expression).
15:09:01 <Itkovian> night
15:16:08 * boegel yawns
15:21:02 <funkmando> getting a silver means getting a correct number, but in the wrong place, when trying to guess a target number like 2304, say i guessed 3232, that would be 2 silvers right?
15:21:14 <funkmando> i need to write an algorithm to do this in haskell
15:21:18 <funkmando> and im stumped. lol
15:22:42 <funkmando> i thought first of removing correspondingly equal elements from both lists, then testing to see if the elements of the guess are inside the target number, if they are, add 1 to silver
15:23:00 <funkmando> but its become complicated
15:23:06 <funkmando> anyone have a simpler approach?
15:23:29 <wagle> related to mastermind?
15:23:50 <funkmando> yes
15:24:08 <funkmando> i have to code this game, but only the scores
15:24:15 <funkmando> i did the full thing in java though
15:24:21 <wagle> what if you guess correct place?
15:24:43 <funkmando> then it should say "correct" or something
15:24:45 <funkmando> i think
15:25:05 <funkmando> but im really struggling with this silver function, lol
15:25:26 <wagle> what occurs to me is to sort, then "merge"
15:25:28 <jlouis> I think your approach is quite easy. Remove those who are correct. Then ask for membership
15:25:53 <jlouis> wagle: ah, yes, that would be easier for those not being correct
15:26:27 <funkmando> hmmm
15:26:30 <wagle> i was supposed to take off 27 minutes ago..  sorry..  cya
15:26:35 <funkmando> bye
15:27:02 <funkmando> my very first idea, was make sure they are not correct then ask for membership
15:27:03 <funkmando> but no goes
15:27:16 <funkmando> you have to remove all those that are correct before doing anything
15:27:47 <funkmando> i managed to get my hands on a function that does such a removal, but it's pretty complicated in my eyes
15:32:32 <lisppaste2> metaperl pasted "Help Needed on Implementing a Continuation-Passing Version of map" at http://paste.lisp.org/display/6159
15:33:30 <Cale> funkmando: [y | (x,y) <- zip xs ys, x /= y] ?
15:34:42 <funkmando> what does that do?
15:35:09 <Cale> remove the ones which are correct, where xs is the correct string, and ys is the guess.
15:35:56 <funkmando> so then xs and ys are the new lists?
15:36:01 <Cale> so if removeCorrect xs ys = [y | (x,y) <- zip xs ys, x /= y]
15:36:10 <Cale> removeCorrect [2,3,0,4] [5,3,4,4] = [5,4]
15:36:20 <funkmando> nice
15:36:30 <Cale> because
15:36:42 <funkmando> dont i need removeCorrect (x:xs) (y:ys) ?
15:36:48 <Cale> zip [2,3,0,4] [5,3,4,4] = [(2,5), (3,3), (0,4), (4,4)]
15:37:22 <Cale> and then the condition filters out only those where the first and second part of the pair don't match, leaving just
15:37:30 <Cale> [(2,5), (0,4)]
15:37:49 <Cale> and then it says to just return the second part of each
15:37:52 <Cale> [5,4]
15:38:03 <funkmando> cool
15:40:26 <metaperl> Could someone help with my continuation-based map?
15:40:55 <Cale> metaperl: I could have a look
15:41:02 <metaperl> I pasted it via lisppaste at http://paste.lisp.org/display/6159
15:42:22 <funkmando> what does Malformed LHS to type of declaration mean?
15:42:33 <funkmando> type of class declaration rather
15:42:57 <metaperl> funkmando, can you paste at paste.lisp.org/new/haskell
15:43:09 <metaperl> the entire code which is causing problems
15:43:29 <funkmando> hmm
15:43:36 <funkmando> actually it's the function cale gave me, lol
15:43:46 <metaperl> hmm
15:43:56 <metaperl> I added his code the Haskell wiki so I'm glad you said that
15:43:59 <Cale> hmm
15:44:07 <Cale> ?
15:44:23 <jlouis> how does one indent if e1 then e2 else e3 as an idiom?
15:44:24 <funkmando> well i probably did it wrong
15:44:31 <jlouis> if you have to break lines, that is
15:44:46 <funkmando> class remove where
15:44:46 <funkmando> removeCorrect :: String -> String -> String
15:44:46 <funkmando> removeCorrect (x:xs) (y:ys) = [y | (x,y) <- zip xs ys, x /= y]
15:44:55 <funkmando> that's crap right? lol
15:44:57 <jlouis> aligning if then else, or by aligning then and else indented?
15:45:33 <metaperl> jlouis, my last experience surprised me. I believe I learned the latter was correct
15:45:37 <Lemmih> funkmando: What's with the class and (x:xs) stuff?
15:45:55 <metaperl> Even though in my mind, the else should've been aligned with if
15:46:00 <dons> argh. ghc is kill my laptop.
15:46:05 <funkmando> i dunno (x:xs) didn't make any difference to just xs though
15:46:13 <Cale> metaperl: that last line -- it's not in your file is it?
15:46:31 <jlouis> metaperl: the first variant does not pass the layouter, so
15:46:33 <metaperl> yes it is
15:46:41 <Cale> metaperl: it's not a declaration
15:46:42 <metaperl> that is a test case
15:46:45 <metaperl> the last line
15:46:46 <dons> no. argh. it is ar. bad ar! damn those splitobjs.
15:46:52 <Cale> metaperl: you'll need to give it a name
15:46:54 <Lemmih> funkmando: Are you familiar with pattern matching?
15:47:04 <metaperl> oh ok
15:47:23 <Darius> jlouis: There's a style page on the wiki.
15:47:30 <Cale> funkmando: why the class, and why the (x:xs)?
15:47:45 <funkmando> yes cale removed and working
15:47:45 <funkmando> thanks
15:47:46 <funkmando> lol
15:47:47 <jlouis> Darius: thanks
15:47:48 <Cale> okay
15:47:53 <funkmando> cale that's an excellent function
15:47:58 <funkmando> the other one i had was enourmous
15:47:59 <funkmando> lol
15:48:11 <dons> hey jlouis. how's the bsd?
15:48:19 <Cale> list comprehensions are a nice way to get things done a lot of the time
15:49:22 <jlouis> dons: fine and cool. It has not exploded on me yet ;)
15:49:32 <lisppaste2> metaperl annotated #6159 with "still failing" at http://paste.lisp.org/display/6159#1
15:49:44 <jlouis> Can't wait for 6.4 now. Send patches when you have them ;)
15:49:54 <dons> good good. 3.7 freeze in a few days, so it's good ghc got some testing.
15:50:00 <metaperl> Cale, the continuation is throwing a type error
15:50:19 <dons> ok. will do. I'm building 6.4 right now.
15:50:56 <metaperl> How could (\newhead -> newhead : (cmap f xs) )
15:51:14 <metaperl> be inferred as having type t -> t1 instead of t -> [t]
15:51:41 <Cale> [t] is of the form t1
15:51:42 <metaperl> it is clearly consing things of type a onto a list
15:52:09 <metaperl> ghci did not say that... why wouldn't it be explicit and say [t]
15:52:18 <dons> what's the type of cmap?
15:52:36 <Cale> you're returning a list on the first line
15:52:45 <Cale> cmap f [] = []
15:52:56 <Cale> so the second would have to return a list as well
15:53:07 <jlouis> dons: cool. Then I'll test patches like mad ;)
15:53:44 <lisppaste2> metaperl annotated #6159 with "FIXED!!!!!" at http://paste.lisp.org/display/6159#2
15:54:27 <metaperl> I believe I was returnng a function on the second line wasn't I?
15:54:48 <metaperl> but now I fixed it
15:55:36 <metaperl> it works - but I dont think a CPS version of map is an improvement.
15:55:45 <metaperl> it is much more wordy!
15:56:12 <Cale> CPS is often not an improvement
15:57:38 <metaperl> it seemed OK for parsing (the initial example in YAHT)
15:57:50 <Cale> yeah, it's good for some things
15:57:52 <metaperl> but these exercises I have to do are tough. but I'm glad for them
15:58:11 <metaperl> that is the advantage of yaht over Gentle. Exercises to strain your brain :)
15:58:26 <metaperl> no more skimming over material thinking I know it
15:58:55 <Darius> metaperl: You could always just write something in Haskell.
15:59:10 <metaperl> Darius, what do you mean?
15:59:15 <metaperl> something to address what?
16:00:17 <Cale> metaperl: he's just making the point that a good way to learn a language is to write a program in it
16:00:29 <Cale> anyway, dinner -- I'll be back in a bit
16:00:31 <metaperl> oh, yes
16:01:00 <metaperl> but I like the "babystep" approach of exercises which are very related to what you just learned
16:04:31 <metaperl> I havent started writing the CPS version of filter, but I'm already in love with it. I'm going to supply two continuations for each branch of the if-then-else of the normal way to implement it
16:05:10 <metaperl> however, the non-CPS is fairly tight:
16:05:10 <metaperl> filter p (x:xs) | p x       = x : filter p xs
16:05:11 <metaperl>                 | otherwise = filter p xs
16:07:38 * metaperl has fallen out of love with the idea of a CPS version of filter :)
16:10:38 <Darius> CPS is usually used when one wants to simulate a control effect (though it has other purposes as well).
16:11:06 <Darius> CPS can be used for exceptions and backtracking among many other things.
16:20:48 <wilx> Is there a Haskell coding standard or something?
16:22:21 <dons> there's a commmentary on ghc, which includes a partial coding standard: http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/the-beast/coding-style.html
16:23:03 <dons> another good thing is to always use -Wall -Werror
16:23:49 <metaperl> I've got the 2 continuations for a CPS version of filter, but does it really make sense to pass both of these to the predicate and have the predicate also doing if-then-else?
16:23:50 <metaperl> c1 = (\x -> x: (cfilter p xs))
16:23:50 <metaperl> c2 = (\x ->    (cfilter p xs))
16:24:11 <metaperl> c1 should run if p x is True otherwise c2 should run
16:24:22 <dons> and here: http://haskell.org/hawiki/HaskellStyle?action=highlight&value=coding+standard
16:25:20 <wilx> Thanks.
16:25:26 <Darius> metaperl: It depends on whether you want to expect CPS predicates or not.  I think the intention of YAHT is not, but...
16:25:27 <wilx> This one is much more complete :)
16:25:54 <Darius> wilx: As the wiki page demonstrates.  There isn't really much consensus on most things.
16:27:32 <dons> except that you probably shouldn't code like this http://www.cse.unsw.edu.au/~dons/pretty.html
16:30:32 <Cale> dons: that's beautiful.
16:31:38 <wilx> Hehe.
16:35:16 <Darius> dons: There's nothing too wrong with that as compared to your "crawl" IOHCC entry.
16:37:30 <desrt> what does this program do?
16:42:05 <jlouis> Where does one report a bug in GHC?
16:43:01 <Cale> probably SourceForge would work
16:44:17 <Pseudonym> glasgow-haskell-bugs@haskell.org also works, I think.
16:46:09 <metaperl> I didnt know haskell people had an interest in obfuscated code
16:46:23 <metaperl> I can't say it overjoys me
16:46:25 <metaperl> :)
16:46:50 <metaperl> Haskell to me , coming from Perl, is about the highest clarity possible in computer programming
16:46:54 <Darius> metaperl: Haskell wouldn't be a general-purpose language if you couldn't hold obfuscated code contests in it.
16:47:15 <metaperl> Haskell, to me, is a purely functional language.
16:47:36 <Pseudonym> Any language in which you can't write FORTRAN is insufficiently general./
16:48:00 <metaperl> taking the precision and clarity of mathematical thought and making it available in a programming language.
16:48:08 * metaperl thinks Darius and Pseudonym are joking with him
16:48:22 <Pseudonym> metaperl: "the precision and clarity of mathematical thought"
16:48:28 <Pseudonym> How many mathematicians do you know, exactly?
16:48:28 <tautologico> any language that can't produce code that looks like perl is not general enough
16:48:36 <metaperl> OMFG, LOL
16:48:54 <tautologico> mathematicians are very sloppy
16:48:56 <metaperl> wow, 2 quotes that deserve the IRC Hall of Fame in one day
16:49:30 <metaperl> the other was on our cooperative hosting IRC channel: Our sysop is Jewish and some guy said: "you're not going to be shutting down the server on Sundays are you?"
16:49:56 <tautologico> where "code that looks like perl" = line noise
16:50:35 * metaperl begins Chapter 7 of YAHT with anticipation: "Advanced Features"
16:50:42 <Cale> I resent that, mathematical thought is generally quite clear.
16:51:14 <Darius> Cale: And so are many obfuscated programs.  It's just their presentation that's unclear ;)
16:51:22 <Cale> and mathematicians (good ones, anyway), are generally quite crisp in their reasoning and presentation.
16:52:16 <Pseudonym> "good ones, anyway"
16:52:27 <sh10151> they just rely on things like LEM
16:52:36 <metaperl> LEM?
16:52:36 <Pseudonym> Necessary precondition, there.
16:52:38 <sh10151> sloppy, sloppy thought
16:52:39 <metaperl> what does that mean?
16:52:42 <sh10151> law of excluded middle
16:52:59 <Pseudonym> Like all human beings, most mathematicians are mediocre.
16:53:00 <Cale> sh10151: The law of excluded middle is just part of the rules.
16:53:32 <sh10151> Cale: sure, the rules for the lazy typical mathematician
16:53:34 <Cale> sh10151: If you don't like it, you're free to not accept it, but you should be aware that others might not agree with you.
16:53:44 <Gahhh> you cant define all human beings mediocre.
16:53:47 <sh10151> constructive proofs are far more compelling
16:53:59 <Cale> sh10151: Axioms are arbitrary.
16:54:37 <Darius> Gahhh: Pseudonym is just a lazy logician ;)
16:54:43 <tautologico> I remember a monty python sketch where the existance of god is decided in a wrestling fight :)
16:55:00 <Cale> later
16:55:03 <sh10151> LEM isn't an axiom, and it is not arbitrary
16:55:05 <Cale> heading back to waterloo
16:55:08 <metaperl> Hofstadter did a good job of defining God
16:55:17 <Cale> LEM is part of the logical system
16:55:19 <sh10151> i suppose it is a second-order axiom of sorts
16:55:19 <metaperl> God over Djinn over Djinn over Djinn
16:55:27 <metaperl> that GEB was a great book
16:55:31 <Cale> it's an axiom of the logical language we use
16:55:46 <sh10151> ITYM "law"
16:55:46 <Cale> anyway, have to run
16:55:51 <metaperl> cya Cale
16:55:53 <Pseudonym> Bye Cale.
16:55:56 <Cale> later
16:56:03 <metaperl> i'm alone with these anti-math people.
16:56:03 <Pseudonym> Gahhh: Not _all_ human beings are mediocre.
16:56:16 <tautologico> I'm not anti-math
16:56:26 <Pseudonym> Nor am I.  I'm just anti-most-mathematicians.
16:56:28 <Gahhh> I'm pro math, but what the hey
16:56:38 <Pseudonym> I'm pro-maths.
16:56:50 <tautologico> I guess supporint intuitionistic math doesn't qualify as anti-math either
16:56:55 <tautologico> *supporting
16:56:57 <Gahhh> let's attack marine biologists
16:57:22 <metaperl> ah I see. the people in the trade vs. the trade itself. I make a lot of oversights like that
16:57:31 <Pseudonym> Gahhh: However, given a normal distribution, something like 2/3 of all data points are within 1 standard deviation of the mean.
16:57:45 <Pseudonym> I'm merely stating that most mathematicians are not above-average mathematicians.
16:57:49 <Pseudonym> Only half of them are.
16:57:57 <tautologico> half ? that many ?
16:58:20 <Pseudonym> That does assume that mathematical competency follows a normal distribution.
16:58:35 <Pseudonym> Which isn't always true.
16:58:45 <Gahhh> Pseudonym, it's not a mere statement of statistical standing within a group. Mediocre means mediocre. Sounds almost elitist, to me at least. How good should one be ?
16:59:32 <Pseudonym> Gahhh: One should be above 2 standard deviations below the mean.  Peer review should take care of the rest.
17:00:06 <Pseudonym> BTW, most people have 10 fingers.  A few people have fewer than that.
17:00:16 <Pseudonym> So the mean number of fingers is somewhere just below 10.
17:00:23 <Pseudonym> So most people are above-average.
17:01:03 <Pseudonym> Similarly, it _might_ be that mathematicians' skill does not follow a normal distribution.
17:03:44 <sh10151> tautologico: intuitionist math has higher value than garden-variety :)
17:05:05 <Darius> Pseudonym: Some people have more than 10 fingers.
17:05:26 <Pseudonym> Darius: Indeed.
17:05:35 <Darius> Anyways, see ya.
17:06:20 <Pseudonym> Still, their mere existence doesn't destroy my argument, so long as there are more missing fingers than extra fingers in the universe.
17:06:34 <Pseudonym> There is no phyical law about conservation of digits.
17:08:59 <zalasta> I want to specify a type along the lines of data foo = bar | @, however I get an error from the @ symbol... what is the correct way to use @ in the  data type?
17:14:45 <Pseudonym> No.
17:14:50 <Pseudonym> There is no correct wayt.
17:14:55 <Pseudonym> You can use :@ if you want.
17:15:13 <Pseudonym> But @ is a reserved symbol, used in pattern matching.
17:17:31 <zalasta> What does :@ do? (I mean what effect does the : have?)
17:18:10 <Pseudonym> a) it makes it a different symbol
17:18:18 <Pseudonym> :@ is a symbol in its own right
17:18:25 <Pseudonym> b) it makes it suitable for use as a constructor
17:19:51 <Pseudonym> Haskell has the feature that things which start with a capital letter are type names, class names or constructor functions.
17:20:02 <Pseudonym> If they start with a lower case letter, they're variables etc.
17:20:13 <Pseudonym> Well, there's a similar thing with operators.
17:20:22 <Pseudonym> Actually, no, :@ doesn't work now that I think about it.
17:20:29 <Pseudonym> Unless it's specifically an infix operator.
17:20:43 <Pseudonym> Anyway, if an operator starts with : it's a constructor, otherwise it's a variable.
17:20:51 <Pseudonym> More or less.
17:32:08 <metaperl> is there an easy way to formulate a function so that if it requires n args all of type t and you give it n-1 it returns the values of the other argument?
17:32:16 <metaperl> some sort of equation solver
17:32:27 <metaperl> just thinking way ahead of my current lesson in yaht
17:36:12 <Pseudonym> Err... you want a logic language, I think.
17:36:35 <metaperl> oh
17:36:45 <metaperl> well theorem provers have been written in Scheme,.. for instance
17:36:52 <Pseudonym> Sure, and in Haskell.
17:37:08 <Pseudonym> But you need to build a system with arbitrary dataflow.
17:37:33 <metaperl> yes, or just use None/Just and a lot of cases
17:37:51 <metaperl> f Just a Just b None = a * b
17:37:59 <metaperl> f None Just b Just c = b* c
17:38:02 <metaperl> or something like that
17:38:34 <metaperl> I htink I might write a fahrenheit to celsius and celsius to F converter like in SICP using Either
17:38:42 <metaperl> just to see how it can be done
17:50:58 <Pseudonym> Lunch.
18:08:19 <dons> hmm. should I be able to feel my laptop vibrating while linking ghc?
18:17:34 * gzl guesses no.
18:18:21 <dons> hehe. I'm not too surprised :}
18:18:37 * dons backs up data just in case
18:35:41 <Igloo> Yo Syn!
18:35:46 <Igloo> SyntaxNinja: How should I invoke runghc (with ghc6 6.2.2-3) on Setup.hs?
18:36:08 <SyntaxNinja> hi Igloo
18:36:17 <SyntaxNinja> runghc -package Cabal Setup.hs ?
18:36:38 <Igloo> That says "ghc-6.2.2: missing argument for flag: -package"
18:36:49 <Igloo> And if I remove the space it says it fails to find the interface for Main
18:36:51 <zalasta> I'm having some trouble getting this code to work http://www.pastebin.com/247210, lookUp takes a string and a list of EContents, and returns a Term... what have I done wrong?
18:37:43 * Igloo will assume it's just broken then and wait for 6.4
18:38:19 <SyntaxNinja> Igloo: maybe use quotes around "-package Cabal"
18:38:25 <SyntaxNinja> you should probably report that to simon.
18:38:38 <Igloo> Also fails to load interface
18:38:58 <Igloo> Well, 6.2.2 didn't actually have a runghc, so if it works in 6.4 there's nothing to report
18:40:54 <SyntaxNinja> Lemmih: got ghc 6.4 handy?
18:41:36 <gzl> wait, they're skipping 6.3?
18:42:09 <SyntaxNinja> heh, I didn't know pugs was a hugs pun
18:42:18 <dons> gzl: odd minor numbers indicate cvs/development branches
18:42:30 <gzl> ah, ok
18:42:43 <gzl> when is 6.4 scheduled to be released?
18:42:58 <dons> week or two
18:43:05 <gzl> oh, cool.
18:53:25 <dons> huh. some ./configure options to ghc at build time get hard coded in the binary.
18:53:29 <dons> grr.
18:57:50 <Igloo> How do you mean?
18:58:38 <dons> I was using --with-gcc=egcc as configure flags in my nightly builds, and discovered that egcc is then hardcoded.
18:59:09 <dons> -pgmcgcc3 should have worked, right?
18:59:25 <Igloo> Well if it wasn't then when your ghc compiled things they wouldn't work
18:59:55 <dons> I would have thought that something like -pgmcegcc would be in a package.conf instead
19:00:09 <Igloo> Ah, fair enough
19:00:16 <dons> it's alright though. ln -s gcc3 egcc works fine :)
19:00:23 <Igloo> :-)
19:02:05 <dons> hey Igloo, is there a unsafePerformQ :: Q a -> a ?
19:03:37 <Igloo> Hmm
19:03:50 <dons> nah, maybe I'm being too evil.
19:04:13 <Pseudonym> Is it actually unsafe?
19:04:19 <Igloo> unsafePerformIO . runQ would do it in ghci I think
19:04:42 <dons> looks good to me.
19:04:53 <Igloo> But in GHC you're in the TcM Monad, IIRC
19:05:05 <dons> think so, yes.
19:06:03 <Igloo> So I imagine you can't do it then
19:06:31 <dons> hmm.
19:07:17 <Igloo> Which is a good tihng if the typechecker uses any IORefs or anything  :-)
19:08:05 <dons> yeah. good point.
19:09:19 <dons> ah. let's see: pTypeOf :: (Lift t) => t -> Type
20:09:03 <desrt> @love
20:09:04 <lambdabot> Sorry, I don't know the command "love", try "lambdabot: @listcommands"
20:09:08 <desrt> :(
20:09:14 <MachinShin> @listcommands
20:09:14 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
20:09:14 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
20:09:14 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
20:09:14 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
20:09:14 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
20:09:15 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
20:09:17 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
20:09:19 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
20:09:21 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
20:09:50 <lambdabot> You could try @war if you prefer to make @war not @love.
20:10:04 <MachinShin> hah
20:10:08 <MachinShin> @war
20:10:08 <lambdabot> Sorry, I don't know the command "war", try "lambdabot: @listcommands"
20:10:13 <MachinShin> wtf is that?
20:10:19 <lambdabot> I said you could "try".
20:11:45 <heatsink> @help cmafihe
20:11:46 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
20:13:27 <duncan_> @eurohaskell
20:13:28 <lambdabot> less talks, more code!
20:13:28 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
20:13:28 <lambdabot> EuroHaskell - Haskell Hackfest - Summer 2005 - Gothenburg, Sweden
20:14:01 <heatsink> @lojban
20:41:40 <araujo> what is a good function to conver from Char to String ?
20:42:13 <heatsink> A string is a list of characters.
20:43:32 <araujo> yup
20:44:35 <SyntaxNinja> convertCharToString x = [x]
20:45:51 <araujo> Thanks SyntaxNinja
20:51:29 * desrt wishes he was here 10 minutes ago :)
20:51:46 <desrt> araujo; return :)
20:57:47 <araujo> desrt, here!
20:58:36 <desrt> no.  i mean the answer to your question is 'return'
20:58:42 <desrt> return ::: Char -> String
20:59:10 * araujo now does feel stupid
20:59:24 <desrt> @type (return 'a')
20:59:30 <araujo> Thanks desrt
20:59:31 <lambdabot> (return 'a') :: forall m. (Monad m) => m Char
20:59:34 <desrt> arf.
20:59:42 <araujo> hah.. you woke up lambdabot 8)
21:02:14 <Pseudonym> Actually, this is shorter:
21:02:19 <Pseudonym> @type (:[])
21:02:21 <lambdabot> (:[]) :: forall a. a -> [a]
21:02:24 <Pseudonym> And more obfuscated to boot.
21:02:29 <desrt> interesting.
21:02:46 <desrt> i didn't know that existed, but it makes sense
21:03:02 <Pseudonym> It's a standard operator section/.
21:03:09 <desrt> how do you use that?
21:03:17 <desrt> it looks like an infix operator that takes one argument?
21:03:17 <Pseudonym> @type (:[]) 'a'
21:03:19 <lambdabot> (:[]) 'a' :: [Char]
21:03:24 <Pseudonym> It's no different from:
21:03:26 <Pseudonym> @type (+1)
21:03:28 <lambdabot> (+1) :: forall a. (Num a) => a -> a
21:03:31 <desrt> can you use it without the () though?
21:03:36 <Pseudonym> Sure.
21:03:41 <Pseudonym> @type 'a' : []
21:03:43 <lambdabot> 'a' : [] :: [Char]
21:03:48 <desrt> hah
21:03:50 <araujo> nice, Thanks
21:03:50 <desrt> that's so cheating :)
21:03:56 <desrt> i get it now
21:03:56 <Pseudonym> It is not cheating.
21:04:09 <desrt> i thought ':[]' as such was a constructor
21:04:13 <araujo> Similar to (+1) right?
21:04:22 <desrt> but really it's a partial application of [] to the right side of :
21:04:27 <Pseudonym> Right.
21:04:44 <desrt> araujo; yes. exactly the same.
21:04:51 <araujo> good
21:04:52 <Pseudonym> But the fact that it took you a while to work it out suggests that you shouldn't use it.
21:06:16 <heatsink> desrt: It looked like a constructor to me, because operators starting with : are constructors.
21:06:23 <desrt> heatsink; same logic here
21:06:36 <desrt> [ isn't a valid character for an operator, though
21:06:40 <heatsink> right
21:07:48 <shapr> @yow !
21:07:48 <lambdabot> Now I'm concentrating on a specific tank battle toward
21:07:48 <lambdabot>  the end of World War II!
21:08:08 <desrt> hm
21:08:11 <desrt> @yow world
21:08:12 <lambdabot> Toes, knees, NIPPLES.  Toes, knees, nipples, KNUCKLES...
21:08:12 <lambdabot>  Nipples, dimples, knuckles, NICKLES, wrinkles, pimples!!
21:08:12 <lambdabot>  I don't like FRANK SINATRA or his CHILDREN.
21:08:43 <Pseudonym> @arr
21:08:44 <lambdabot> Prelude.(!!): index too large
21:08:47 <Pseudonym> Oooh!
21:09:23 <shapr> oops
21:09:24 <desrt> @eval []!!0
21:09:25 <lambdabot> (line 1, column 3):
21:09:25 <lambdabot> unexpected "!"
21:09:25 <lambdabot> expecting operator, simple term or end of input
21:09:37 <heatsink> strange
21:09:50 <desrt> lambdabot is having a bad day
21:10:16 <lambdabot> You're telling me.
21:12:18 * shapr yawns
21:12:26 <shapr> mornings happens so early.
21:12:34 <araujo> no, not yet
21:15:04 <Pseudonym> It's a well-known fact that the amount of sleep required by the average person is half an hour more.
21:15:11 <shapr> hah
21:18:51 <araujo> 8)
21:25:30 <shapr> man, lambdabot really needs to do that last failing read on posix pipes so that child processes are collected.
21:25:36 <shapr> lambdabot: @quit
21:26:26 <dons> shapr: otherwise there are lots of zombies?
21:27:00 <shapr> yup
21:27:15 <dons> yeah. I see that here on my lambdabot.
21:27:31 <dons> lots of <defunct>'s left over.
21:27:40 <dons> got a patch?
21:27:49 <desrt> shapr; that's not how to do it
21:27:55 <shapr> desrt: how to do it?
21:27:56 <desrt> read() won't clean zombies
21:28:01 <desrt> you need to call waitpid()
21:28:39 <dons> hmm. so popen() isn't quite right?
21:29:00 <dons> lambdabot could switch to forkProcess, I guess. wonder what the behaviour there is.
21:29:14 <desrt>        The  pclose  function waits for the associated process to terminate and
21:29:15 <desrt>        returns the exit status of the command as returned by wait4.
21:29:22 <desrt> pclose() calls wait()
21:29:29 <shapr> meaning?
21:29:41 <desrt> when a process exits it goes into zombie state
21:29:52 <shapr> what should be used instead?
21:30:04 <desrt> which means it leaves a tiny bit of itself in the kernel holding infromation like its return value and resource usage information
21:30:17 <desrt> wait() grabs that info and removes the zombie from the process table
21:30:41 <dons> hmm. yeah, so we should wait() after our popen() calls.
21:30:52 <desrt> no.  pclose() should be fine, i think
21:31:20 <dons> Posix.popen. not popen(3)
21:31:25 <desrt> o.
21:31:27 <dons> there's no pclose binding.
21:31:40 <desrt> oh.  i see.
21:31:42 * Lemmih votes for moving to GHC 6.4, System.Process and hs-plugins.
21:31:50 <desrt> i have no idea how your crazy fd-leaking language works :P
21:32:12 <dons> desrt just hacks the compiler, right?
21:32:27 <desrt> mostly the parts written in C
21:32:31 <dons> Lemmih: it should be done.
21:32:44 <shapr> Yes, especially hs-plugins.
21:32:55 <dons> especially? why so?
21:33:10 <shapr> So everybody can benefit from dynamic loading!
21:33:25 <desrt> shapr; can you make it evaluate haskell, too?
21:33:33 <dons> yep. we can use runplugs.
21:33:51 <dons> i've been using it in my lambdabot fork for about a year now
21:34:24 <shapr> you want that to be the trunk instead of the fork? :-)
21:34:38 <dons> nah. too many custom hacks.
21:34:43 <dons> I should integrate!
21:34:51 <dons> 16:34 dons:: @plugs last [0..]
21:34:51 <dons> 16:34 \bot:: bzzt
21:35:13 <dons> 16:34 dons:: @plugs [0..] !! 200
21:35:14 <dons> 16:34 \bot:: 200
21:35:31 <shapr> I don't seem to have the motivation to add all the patches to lambdabot and maintain a canonically correct version.
21:35:35 <Lemmih> plugs?
21:35:46 <desrt> how long does it take to bzzt 'last [0..]'?
21:36:15 <dons> desrt: user-configurable at compile time. nominally 10secs.
21:36:23 <dons> 16:35 dons:: @plugs reverse $ map toUpper (sort "shapr")
21:36:24 <dons> 16:35 \bot:: "SRPHA"
21:36:26 <dons> etc.. etc.
21:36:28 <desrt> oh
21:36:29 <shapr> neato
21:36:36 <desrt> so it's a time limit rather than some intelligent detection method
21:36:43 <desrt> and here i was thinking you had a solution to the halting problem
21:36:50 <dons> i'm not hacking the runtime system of Haskell for irc...
21:36:54 <shapr> well, it does halt.
21:37:44 <desrt> last [0..] == bottom
21:38:21 <dons> more useful though:
21:38:21 <dons> 16:37 dons:: @plugs System.Cmd.system "ls"
21:38:22 <dons> 16:37 \bot:: bzzt
21:38:30 <desrt> that's a good call :)
21:38:43 <desrt> do you have a blacklist or a whitelist or something more intelligent?
21:39:04 <dons> regarding unsafe code?
21:39:08 <desrt> ya
21:39:21 <dons> i only allow purely functional modules to be in scope
21:39:24 <dons> so no IO
21:39:29 <desrt> what if i unsafeperformio?
21:39:49 <dons> that's in GHC.IO, which I don't allow to be dynamically loaded.
21:39:54 <desrt> :)
21:40:10 <shapr> hey, do any of you guys program in the lotus position?
21:40:19 <dons> sometimes, yes.
21:40:20 <ozone> hs-plugins: provably safe code or your money back
21:40:21 <desrt> is that legs-crossed?
21:40:25 * shapr suspects that was a) totally random and b) totally off-topic
21:40:35 <dons> s/shapr/lambdabot/
21:40:36 <ozone> shapr: depends if lotus is a nice girl or not
21:40:50 * desrt programs in all sorts of strange leg-configurations
21:41:08 <desrt> i often use my feet to prop up my chin :)
21:41:26 <dons> that's just ridiculous.
21:41:37 <ozone> desrt: you sound like one of my friends who programs in the worst possible positions
21:41:44 <ozone> i'm so surprised he doesn't have back pains yet
21:42:14 <desrt> i obviously can only get away with this at home with bare feet
21:42:35 <desrt> elsewhere, i tend to have at least socks on :)
21:45:07 <dons> Lemmih: plugs is a dynamic- linking based interactive environment that comes with hs-plugins. it is embeddable.
21:46:33 <shapr> desrt: I take my glasses off with my toes sometimes, so I totally agree with you.
21:46:46 <desrt> shapr; thanks for the support :)
21:46:53 <dons> my goal in life is to be able to do up shirt buttons with my toes.
21:47:08 <shapr> Lotus position is where both ankles are on your thighs.
21:47:12 <desrt> dons; you'd better get started while you're still young and nimble
21:47:18 <desrt> that could take a good 15-20 years of work to get down
21:47:39 <Pseudonym> dons: I think it's important to have a purpose.
21:47:50 <shapr> I can write okay with my left foot, not so good with my right foot though. I can write decently with both hands, though I'd rather type.
21:47:52 <desrt> ag
21:47:58 <desrt> you mean pretzel position
21:47:59 <dons> yeah, I can scrawl my name, and pick up small objects fairly easily. but, say, keeping a fork balanced is hard.
21:48:09 <Pseudonym> dons: Might help if the shirt wasn't on you at the time.
21:48:16 <dons> that's true.
21:48:17 <desrt> i prefer both ankles under my theighs
21:48:21 <shapr> desrt: 'lotus' not pretzel :-)
21:49:05 <shapr> I should take a pic of my computer setup...
21:49:13 <dons> i can't imagine it would really take 15-20 years though. it only takes kids 1-2 years to use their hands, right?
21:49:41 <desrt> my computer setup is the best ever.  it consists of a beautiful keyboard, a beautiful monitor and a beautiful mouse
21:49:59 <desrt> and everything else is in the closet
21:50:04 <ozone> all you need is a beautiful luis royo poster next to it, and you're set
21:50:38 <desrt> i have beautiful velocity girl, lisa winn, dot allison, delgados, lush, mogwai, cat power and pink floyd posters all around it
21:53:18 <shapr> I have some unamerican.com posters, and a french poster with a cat programming Java.
21:55:14 <shapr> Is this a cute cat or what? http://www.prologin.org/archives/affiches.php?affiche=affiche_2004_grand.jpg it says (freely translated) This cat codes in Java, what's your problem?
21:56:45 <SyntaxNinja> no such server
21:56:53 <desrt> wmf.
21:57:06 <shapr> isn't that wfm?
21:57:19 <desrt> yes.  sorry.
21:58:00 <SyntaxNinja> strange
21:59:06 <Pseudonym> My response: If you want cat-quality code, by all means use Java.
21:59:51 <Pseudonym> Oh, which unamercian posters do youhave?
22:00:17 <shapr> I have dontforget and immortal
22:00:58 <Pseudonym> You should get "Ganesha Loves You".  Heffalump would approve.
22:00:59 <shapr> Seems that the dontforget file is broken on unamerican.com, I can upload my local copy.
22:01:22 <shapr> I disagree with a lot of the stickers on unamerican.com, but I very much agree with the sentiment to stand up for what you believe.
22:02:16 <Pseudonym> Well, part of their mission is for you to choose your own slogans.
22:02:49 <shapr> Yeah, very Discordian.
22:03:01 <Pseudonym> Hail Eris!
22:03:18 <Pseudonym> Some of them are VERY Discordian.
22:03:23 <Pseudonym> "Confuse Everyone"
22:04:29 <Pseudonym> Ah, I have two of their five recommended books.
22:04:38 <Pseudonym> "The Book of the Subgenius" and "The Boomer Bible"
22:05:01 <SyntaxNinja> prologin works fo rme now
22:05:05 <shapr> yay
22:06:25 <shapr> Any other freely downloadable posters I can check out that people here recommend?
22:06:26 <Itkovian> ozone, I can agree on the Royo poster :-)
22:06:31 <Pseudonym> The Boomer Bible is one of the best books I've ever read.
22:06:44 <Pseudonym> Not sure if I finished it or not.
22:06:49 <Pseudonym> It's that kind of book.
22:11:31 <Lemmih> SyntaxNinja: I've been looking for you.
22:12:08 <SyntaxNinja> hi Lemmih
22:12:18 <SyntaxNinja> I've been looking for yout oo. I didn't grok your email
22:12:25 <SyntaxNinja> and I have a lot of hackage ideas, but I can't get into them now.
22:14:19 <Lemmih> I would like to have executables without any Haskell sources.
22:14:52 <shapr> Wouter Swierstra wrote up a cool arrow-style parser lib that's very close to Parsec. That would likely be faster than a monadic Parsec.
22:17:25 <Lemmih> Ha. Didn't realize "yout oo" was "you too" until now. (:
22:18:45 <Lemmih> I read it as "your object orientation".
22:19:53 <shapr> crap, Jef Raskin died :-( I met at EuroPython 2004, and he'd just gotten a big contract to develop more stuff based on his ideas.
22:20:01 <shapr> http://jef.raskincenter.org/home/index.html
22:20:38 <gzl> yeah, I heard he died earlier today
22:20:40 <gzl> :(
22:20:57 <Pseudonym> Gotta go.  Nytol.
22:21:10 <desrt> raskin died?
22:21:47 <gzl> yes
22:21:48 <gzl> cancer
22:22:13 <desrt> wow.  i own a book that he wrote
22:22:18 <gzl> humane interface?
22:22:22 <desrt> ya :)
22:22:25 <gzl> is it good?
22:22:32 <gzl> i've wondered whether to bother reading it
22:22:33 <desrt> i haven't dug too much into it
22:22:35 <shapr> It is worth reading.
22:22:40 <gzl> ok.
22:22:49 <shapr> He has a lot of ideas that differ dramatically from the mainstream, but I think he's right.
22:22:52 <desrt> a prof lent it to me and i liked what i read of it, so i got one
22:22:58 <shapr> I think that enough to use his ideas in my emacs configuration.
22:23:25 <gzl> like what?
22:23:36 <shapr> Not everything, sadly. Emacs can't do a lot of the stuff he recommends. But Yi could :-)
22:23:55 <desrt> i'm so glad hemacs didn't work out
22:24:02 <desrt> yi is a much nicer name :)
22:24:30 <shapr> One thing he says is that habituation is a good thing, it should be encouraged. That means yes/no/cancel dialog boxes are bad, purpose specific keys are good.
22:25:22 <desrt> his approach to giving 'cost' to interaction is very interesting
22:25:35 <shapr> There are several of those purpose specific keys on emacswiki, diskkey, killkey, etc. disk key is "kill buffer unless unsaved, in which case display a diff" or with C-u disk-key, delete the buffer anyway.
22:26:25 <desrt> man.  i want summer so badly.
22:26:33 <desrt> 2 more months, then commence bliss
22:26:33 <shapr> When my left wrist blew out for a few months, I had lots of time to think while I slowly got up to speed with right-hand dvorak, and those purpose specific keys really helped me get back up to speed.
22:27:03 <SyntaxNinja> Lemmih: heh
22:27:12 <SyntaxNinja> Lemmih: so you want to package a non-haskell library with cabal?
22:27:29 <SyntaxNinja> Lemmih: you could always write a wrapper Main module
22:27:51 <shapr> I also have mailkey, which is "switch to an in-progress reply, or switch to an open summary buffer, or switch to the group buffer, or open gnus" in that order. That sort of single concept key is really a lot less trouble than spreading the info around in random places.
22:28:55 <gzl> huh
22:28:56 <gzl> ok
22:29:04 <shapr> What do you think?
22:29:19 <gzl> I think you use emacs a lot more than I do
22:29:47 <shapr> These ideas aren't emacs-specific, they would work just as well as bindings in your window manager or whatever.
22:30:19 <gzl> yeah, i suppose.
22:31:07 <shapr> Well, try it out when you have the urge to save some brain cycles for more useful stuff :-) habituation can be a powerful time saver.
22:31:21 <Lemmih> SyntaxNinja: Wouldn't it be nicer to make Main-Is optional since it's in the way to all C++ bindings?
22:31:22 <gzl> yeah, i might :)
22:31:23 <thebug> when you say 'purpose specific keys' and give that explanation, it sounds a bit like what I'd call 'context sensitive keys' ... is that an accurate term to draw, or am I misinterpreting you, shapr ?
22:31:43 <shapr> thebug: might be the same, can you explain csk?
22:32:17 <thebug> the keys or combinations of keys perform different functions depending on the task you are currently performing
22:32:34 <desrt> nite nite lambdahumanss
22:33:14 <thebug> for example, ctrl-s being both 'save' and 'send' in a mail program depending on whether you are writing a draft, or have previewed a message and are ready to send it
22:33:33 <shapr> Well, I wouldn't do that specifically.
22:33:37 <shapr> that goes against habituation
22:33:54 <SyntaxNinja> Lemmih: so all we have to do is remove main-is and the linker will figure it out?
22:33:57 <thebug> ok, so I am missing something from your explanation :)
22:35:00 <shapr> thebug: well, read http://jef.raskincenter.org/home/index2.html
22:35:13 <shapr> They're not my ideas, they're from Jef Raskin.
22:35:28 <thebug> sure, I think I've seen his page before
22:36:21 <SyntaxNinja> Lemmih: right now, it work sby running ghc --make over whatever you say in main-is; so it's not a simple matter of making it optional
22:39:31 * heatsink discovered KDE gestures recently and employs some of the same gestures in mailreader and web browser
22:41:04 <heatsink> newtype Neither a b = ()
22:41:17 <heatsink> :)
22:42:03 <heatsink> That should go in the prelude, along with Both.
22:42:13 * thebug hasn't had much opportunity for messing with FP lately, which disappoints him
22:45:47 <thebug> lots and lots of C
22:50:18 <jadrian> heatsink: both is called (,)
22:50:25 <jadrian> s/both/Both
22:50:54 <heatsink> jadrian: I know.
23:30:11 <ycheng> f :: a -> b ; map f :: [a] -> [b]
23:31:09 <musasabi> morning
23:31:32 <ycheng> if f :: a -> b -> c, is there: xxx f :: [a] b -> [f a b]
23:32:59 <heatsink> where did c go?
23:33:17 <ycheng> oops
23:33:19 <musasabi> myFunc f lst b = map (flip f b) lst ?
23:33:32 <ycheng> should be xxx f :: [a] b -> [c]
23:33:35 <desrt> look ma.  no sleep.
23:34:21 <ycheng> musasabi: let me look at flip
23:34:45 <musasabi> @type flip
23:34:47 <lambdabot> flip :: forall c a b. (a -> b -> c) -> b -> a -> c
23:35:50 <ycheng> waa, it seems to be what I want ! I'll try, thanks !!
23:36:32 <shapr> @yow !
23:36:33 <lambdabot> Life is a POPULARITY CONTEST!  I'm REFRESHINGLY CANDID!!
23:37:24 <xerox> yo-w!
23:39:01 <ibid> apt-get install popularity-contest
23:40:26 <shapr> Actually, I wish I could get sasl working so my desktop could send popcon results.
23:40:55 <shapr> I've spent hours trying to get postfix-tls working with sasl auth.
23:41:53 <ibid> why do you ned sasl?
23:42:13 <shapr> because I have a dynamic IP
23:42:29 <ibid> is sasl the only tls auth?
23:43:02 <musasabi> shapr: couldn't you just use your ISP's smtp server?
23:43:06 <shapr> It's the only way I know to login when submitting email to my server.
23:43:09 <ibid> bah, lecture, bbl
23:43:26 <musasabi> or if you want a simple answer then ssh tunnel ;)
23:43:56 <shapr> musasabi: Yes, but my ISP doesn't do SPF, their delivery speed is terrible, they flake out regularly, etc
23:44:30 <shapr> I'd also like to be able to allow sasl auth to the users on my server.
23:44:41 <shapr> and SPF as well.
23:45:03 <earthy> SPF, that's what the spammers use, right?
23:45:18 <ibid> my server supports CRAM-MD5 auth. can't yours?
23:45:29 <ibid> SPF is snake oil
23:45:48 <ibid> but anyway, i have that lecture, bbl for real :)
23:45:49 <shapr> Postfix allows cram-md5 and digest-md5, but I can't get postfix to talk to sasl.
23:46:35 <shapr> I learned way more than I ever wanted to learn about all this, but it still doesn't work.
23:46:46 <ibid> why do you need sasl?
23:46:52 <ibid> blah
23:47:00 <shapr> because I want to submit email to my colo server from my desktop.
23:47:06 <shapr> and my IP is not fixed.
23:47:13 <ibid> and why do you need SASL to do that?
23:47:30 <shapr> how else can I do that?
23:47:45 <ibid> CRAM + SSL?
23:47:46 <shapr> ssh tunnels fall over, and aren't easily handled by my desktop postfix
23:48:10 <shapr> cram requires that you authenticate to the server, afaik, that auth requires sasl.
23:48:42 <ibid> i thought the whole point was to authenticate to the server
23:48:58 <shapr> Can I auth to the server without sasl?
23:49:30 <ibid> hm, it seems i was wrong about what sasl is
23:49:36 <ibid> CRAM appears to be a SASL method
23:50:10 <shapr> I do wish sasl were easier to setup in debian.
23:50:46 <ibid> i had no trouble setting up smtp client authentication for my mother who has a dynamic ip and had a crappy smarthost
23:50:51 <shapr> Specifically, I wish the postfix-tls packages included a detailed howto on getting a client debian postfix-tls to talk to a server postfix-tls
23:50:55 <ibid> with courier, tho
23:51:09 <ibid> and it was, iirc, a non-tls connection
23:51:15 <shapr> hm, I want details after your lecture :-)
23:51:44 <ibid> yeah, bbl :)
23:56:15 <Itkovian> meuning
23:56:36 <Itkovian> shapr: how's TMR coming along?
23:57:05 <ycheng> Coundn't match 'System.Posix.Types.FileMode' against 'Integer', helps !
