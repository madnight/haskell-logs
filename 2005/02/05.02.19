00:00:36 <Gahhh> I have downloaded a dsp library in haskell, but it was mostly FFI. Is this one 100% haskell ?
00:00:45 <shapr> I think so, lemme check.
00:01:30 <musasabi> Lemmih: Simon Marlow had fixed that bug (scheduler: re-entered unsafely) in the CVS :-)
00:02:08 <shapr> Gahhh: Is this the FFI dsp lib? In any case, it's the one I was asking about - http://haskelldsp.sourceforge.net/
00:02:38 <shapr> lou-tze: Greetings, are you looking for Haskell info?
00:04:02 <lou-tze> hi, nope, i just hang around :)
00:04:02 * Gahhh is concatanating pdf's
00:04:11 * Gahhh misspells, great.
00:04:40 <lou-tze> ...but i might be looking for that in the future ;)
00:06:13 <Gahhh> shapr, that one has a lot of FFI stuff, and some in haskell, iirc.
00:06:53 * Gahhh found a floating point bug in cygwin/g++ today.
00:09:25 <metaperl> what are the colons around this + sign for?
00:09:26 <metaperl> > -- repeat something n times
00:09:27 <metaperl> > times  1    m = m
00:09:27 <metaperl> > times (n+1) m = m :+: (times n m)
00:12:22 <Gahhh> looks like a custom operator. what is 'm's type ?
00:12:46 <autrijus> metaperl: it means a data constructor.
00:12:59 <autrijus> for generic types.
00:13:20 <metaperl> oh... beyond my understanding of haskell....
00:13:25 <autrijus> see GHC user's guide
00:13:25 <autrijus> 7.10.2.
00:13:35 <metaperl> I just read 2 tutorials and now am looking at haskore
00:13:38 <metaperl> ok autrijus thanks
00:13:41 <autrijus> that usage is mildly deprecated for the new Data.Generics syntax.
00:13:44 <autrijus> np :)
00:13:44 <metaperl> is that how you learned Haskell?
00:14:02 <metaperl> i was thinking of buying the 2 major books on it
00:14:03 <autrijus> I started by reading yet another haskell tutorial (not finished), then gentle intro, then bought books
00:14:22 <metaperl> I am enjoying looking at the examples in haskore
00:14:26 <autrijus> my booklist is http://use.perl.org/comments.pl?sid=25056&cid=38335
00:14:33 <metaperl> a music composition program for haskell
00:14:46 <autrijus> I think "Algorithms" is a wonderful intro
00:15:08 <Gahhh> when will there be a haskell book by o'reilly ?
00:15:08 <metaperl> well how does f $ g vary from f . g
00:15:10 * Gahhh laughs
00:15:21 <autrijus> metaperl: "f $ g" applies f to g.
00:15:32 <autrijus> I mean, applies f, using g as argument.
00:15:49 <autrijus> "f . g" creates a function that, if you give it an argument, it is given to g first, then the return value from g is given to f.
00:16:10 <metaperl> oh I see
00:16:12 <tuomov> I just read 'gentle
00:16:19 <tuomov> and started coding
00:16:22 <autrijus> Gahhh: it is possible that this year's edition of "Perl6 and Parrot Essentials" will have a chapter on haskell. not sure that counts, though :)
00:16:30 <metaperl> I didnt think that went into types and type classes deep enough tuomov
00:16:48 <Gahhh> it explains type classes iirc
00:16:52 <autrijus> it does.
00:17:01 <autrijus> it just doesn't cover ghc additions like fundep and rank-n.
00:17:15 <metaperl> I'm still trying to see the POWER of this language over Perl
00:17:19 <tuomov> then I joined #haskell and learned about the more advanced stuff :)
00:17:30 <metaperl> there appears to be no comp.lang.haskell
00:17:38 <autrijus> metaperl: oh. easy. the power of this language is in that you can abstract away any duplicated lines.
00:17:43 <Gahhh> comp.lang.functional serves that purpose
00:17:44 <autrijus> while in perl that's almost impossible.
00:17:46 <autrijus> :)
00:17:47 <tuomov> gmane.comp.lang.haskell.*
00:17:57 <tuomov> on news.gmane.org
00:18:20 <metaperl> autrijus, now that is an interesting statement. Perl has modules, subs. And recently Autocurry hit CPAN
00:18:34 <metaperl> that guy is writing haskell-inspired Perl like crazy
00:18:34 <autrijus> metaperl: right, but can you abstract away the "my $self = shift" ?
00:18:51 <autrijus> or the autoboxing process?
00:19:00 <autrijus> or the "die" propagation logic?
00:19:17 <metaperl> no, but how aoubt input <- readfile
00:19:17 <autrijus> or operator overloading?
00:19:20 <metaperl> in haskell ... same thing?
00:19:43 <metaperl> oh I guess that could be afunction if you wnated it to
00:19:49 <autrijus> actually you can change that semantics very easily :)
00:19:56 <autrijus> by entering another monad other than IO.
00:20:05 <autrijus> there's nothing magical about the IO monad.
00:20:30 <autrijus> oh, and while perl only let you pattern match against strings,
00:20:31 <metaperl> someone here said that Haskell was good at creating domain specific languages
00:20:39 <autrijus> haskell can pattern-match arbitary data structures.
00:20:56 <autrijus> and while perl only let you create "macros" via source filtering strings,
00:21:03 <metaperl> yes, I noticed that feature but in perl we make heavy use of "or" "and" and statement modifiers for the same effect
00:21:06 <autrijus> haskell lets you filter source from the syntax tree level.
00:21:47 <autrijus> oh and finally, code produced by ghc is often 1-2 order of magnitudes faster than perl.
00:22:05 <autrijus> and yes, creating domain-specific languages is, like, very fast in haskell.
00:22:16 <autrijus> for example, I created a domain-specific language called Perl6 in several days.
00:22:16 <vincenz> hmm
00:22:18 <autrijus> # http://search.cpan.org/dist/Perl6-Pugs/
00:22:18 <vincenz> damn
00:22:36 <metaperl> good god autrijus, you are amazing
00:22:49 <autrijus> also see http://use.perl.org/~autrijus/journal/ :)
00:23:21 <autrijus> if that's not a testament of how good haskell is, I don't know what is :)
00:24:18 <metaperl> it certainly is well-suited for me and my background... much better than the things I saw online so far
00:24:26 <autrijus> :)
00:24:40 <autrijus> pugs is always looking for more hackers :)
00:24:54 <autrijus> see relevant discussion on its mailing list, perl6-compiler.
00:24:58 <metaperl> oh, I thought PUGS was a joke module for people to write compact perl one-liners or something... when I saw golf in the SYNOPSIS I did not go read on what hte module did
00:25:28 <autrijus> nah. it's a full fledged perl6 interpreter.
00:25:40 <autrijus> http://svn.openfoundry.org/pugs/examples/quicksort.p6 runs, for example.
00:26:30 <autrijus> but you've got a point. I'll change the abstract to "a perl6 interpreter".
00:27:44 <autrijus> oh. you're tbone of P::RD::FAQ?
00:27:54 <metaperl> yes
00:28:04 <autrijus> nice to meet you :)
00:28:20 <metaperl> again we meet. we met in #scheme when you were hacking on a perl interface to PLT
00:28:39 <autrijus> yeah, but I'm lured to the +Inf of syntactic sugar haskell offers.
00:29:02 <autrijus> metaperl: you may find http://svn.openfoundry.org/pugs/src/Parser.hs an interesting read -- it's very recdescentish.
00:29:06 <metaperl> the studlyCaps stuff is aggravating
00:29:10 <autrijus> (parser for perl6 grammar)
00:30:04 <metaperl> i mean haskell defaults to studly caps for function naming
00:30:08 <metaperl> it is disconcerting
00:30:20 <autrijus> you can certainly use name_underscore for your own functios :)
00:31:15 <metaperl> so what do you do for a living autrijus? where do you live?
00:31:28 <autrijus> I live in Taipei Taiwan.
00:31:38 <autrijus> I own a small company that does contract works.
00:31:43 <metaperl> I taught English there in 92-93
00:31:56 <autrijus> I'm currently in a half-year sabbatical to work on pugs and perl6 and rt and whatnot.
00:31:59 <dons> I don't undertand the 'Golfing' part of the name "Pugs"?
00:32:15 <metaperl> I lived in the far east section of wu-long jie (liu duan)
00:32:24 <autrijus> dons: http://perlgolf.sourceforge.net/
00:32:28 <metaperl> that's hanyu pinyin, bopomofo is not easy to write
00:32:41 <dons> ah ha!
00:32:43 <dons> :)
00:32:46 <autrijus> dons: golfing is a frequent pastime for perl hackers.
00:33:00 <autrijus> something that is quite difficult to do in haskell :)
00:34:12 <dons> true. though obfuscation is more of the challenge :)
00:34:29 <autrijus> :)
00:34:42 <autrijus> metaperl: btw, #perl6 just formed on freenode.
00:34:45 <dons> these pointfree-style haskellers do a bit of golfing, I would say.
00:34:52 <autrijus> I can't use #haskell for perl6 discussions forever :)
00:34:57 <dons> hehe
00:37:01 <metaperl> tuomov, what about a dozen short lessons on haskell?
00:37:04 * vincenz blinks
00:37:13 <vincenz> haskell has MEANINGFUL WHITESPACE?
00:37:20 <autrijus> vincenz: that MAKES SENSE
00:37:22 <metaperl> you still recommend hudak's gentle intro over that
00:37:23 <autrijus> and is OPTIONAL
00:37:37 <autrijus> in other words it's designed by Serious People
00:37:43 <metaperl> I hate that there are 2 syntaxes for haskell: free from and colon-separated
00:37:51 <metaperl> i wish there wer ejust one
00:37:54 <autrijus> semicolon-separated?
00:38:03 <metaperl> yes, you can do both
00:38:04 <autrijus> not sure what you mean here
00:38:17 <metaperl> you can use layout or semi colons to format haskell code
00:38:20 <autrijus> well, in perl you also either indent or use oneline blocks.
00:38:27 <metaperl> chris duttons haskell intro went into that
00:38:34 <autrijus> not terribly different.
00:39:05 <metaperl> no, mutiple statments are separated with semicolons always in Perl
00:39:16 <metaperl> with haskell, you can use formatting to get rid of semicolons
00:39:29 <metaperl> I guess that's kind of  how shell programming works though
00:39:40 <Gahhh> ...and it looks like python...
00:39:43 * Gahhh snickers
00:39:46 <metaperl> end the line with return or conctaenate statements with semicolon
00:40:20 <autrijus> right.
00:40:31 <autrijus> and you choose the indent level
00:40:42 <autrijus> and don't have to be consistent across the source file.
00:40:52 <autrijus> so all in all, I think that's a win
00:41:29 <vincenz> I wish ocaml had typeclasses
00:41:33 * vincenz sighs
00:41:46 <mayhem> hey
00:42:19 <tuomov> metaperl: I never found the need to read more than gentle
00:42:48 <tuomov> sure some articles on more advanced stuff, but not the basics
00:42:50 <metaperl> ok, yes it seems to trail right along with the Report. So I think it will be quite comprehensive. Thanks for the reference
00:42:58 * metaperl goes to reading!
00:43:15 <mayhem> are monad transformers a common concept in haskell ?
00:43:27 <tuomov> of course many people say that gentle is only for those who already know fp
00:43:53 <Gahhh> I didnt know fp. gentle was good enough except for monads for me.
00:43:54 <tuomov> I hadn't done any proper fp before, but I have a maths background and have done some functional-style programming in lua
00:43:54 <autrijus> right.
00:44:10 <autrijus> for non-fp people YAHT is better imho.
00:44:12 <TFK> Gentle's pretty tough...
00:44:26 <autrijus> and "All About Monads" is invaluable.
00:44:35 <vincenz> heh
00:44:58 <TFK> How do I get YAHT without typing in my details?
00:45:42 <autrijus> by entering some random spaces.
00:45:44 <TFK> I wonder it filters out mailinator >-)
00:45:51 <TFK> Ah, it eats spaces?
00:45:56 <autrijus> uhm. seems not.
00:46:08 <mayhem> fp = ?
00:46:11 <autrijus> just enter some garbage data.
00:46:13 <autrijus> mayhem: functional programming
00:46:17 <mayhem> oki
00:46:33 <TFK> Well I guess I will, but why does he even need it anyway?
00:52:54 <vincenz> I must say, haskell has some pretty features
00:52:59 <vincenz> seems more orthogonal than ocaml
00:53:03 <vincenz> (imagine that!)
00:54:35 <autrijus> it's really the least broken language I've came across :)
00:55:39 <jlouis> Haskell has nice syntax. I wouldn't say that about SML or Ocaml, though I think they are far better than eg. C, Java, C++ etc
00:56:04 <jlouis> I do not think Python fares especially well in that respect either
00:56:24 <TFK> Haskell is *different* than those languages.
00:56:27 <TFK> What's wrong with Python?
00:57:02 <mayhem> am I false if I say that monads are modular legos replacing the use of continuations and closures ? What the point of using CPS when you can use monads ?
00:58:09 <autrijus> mayhem: there is actually a CPS monad
00:59:18 <autrijus> that I'm making heavy use of.
00:59:18 <autrijus> so yeah, monad is more general, therefore more powerful.
00:59:18 <autrijus> (however arrows are even more general and supposedly even more powerful)
00:59:18 <mayhem> than monads ?
00:59:18 <autrijus> yeah.
00:59:36 <mayhem> never heard of it, I'll check it ou
00:59:37 <mayhem> t
00:59:43 <jlouis> TFK: I was actually talking syntax there, opposed to semantics. I know they are very different and suited for different tasks
00:59:45 <autrijus> arrows let you create legos that has differente upsides than downsides.
01:00:02 <autrijus> compare with monads, which any block's upside always fits with the downside.
01:02:54 <metaperl> does Haskell have continuations?
01:03:01 <TFK> jlouis, sure, but their again it's just different because their are from another group of languages altogether ;-) and imo Python fares very well in that respect (with it's syntax).
01:03:35 <jlouis> TFK: ok.
01:04:24 <jlouis> metaperl: there is a continuation monad
01:04:32 <autrijus> metaperl: yes. you can choose to use continuations or not.
01:04:44 <autrijus> so you decide if you want the performance/codeflow penalty.
01:05:00 <jlouis> metaperl: http://www.nomaware.com/monads/html/contmonad.html#example
01:05:13 <autrijus> you can even change the semantic of how continuations work (delimited vs undelimited, serializable, etc)
01:05:37 <autrijus> simply by defining your own continuation monad (and transformer)
01:10:48 <mayhem> autrijus, okay thanks a lot, I found something cool to read about
01:11:08 <autrijus> =)
01:30:17 <metaperl> Could I get some help with this tree datatype? I posted my question here: http://haskell.org/hawiki/WikiSandBox
01:33:14 <metaperl> hmm, no one seems click-happy :)
01:34:20 <metaperl> anyway, I just wanted to know how this description of a tree: data Tree a  = Leaf a | Branch (Tree a) (Tree a) could describe a tree with 5 as its root node and 5 and 7 as leafs
01:37:00 <vincenz> metaperl: it seems haskell trees are leaf-values only
01:37:25 <metaperl> I think Gentle has a mistake here
01:37:38 <TFK> I think that the point is that THAT tree doesn't store node values, only leaf values.
01:37:51 <TFK> Tree a  = Leaf a | Branch (Tree a) (Tree a) a <--- might solve the problem?
01:37:53 <ycheng> ( ( Leaf ) ( (Leaf ) ( Leaf) )
01:37:57 <vincenz> righ but I thought it was the std tree
01:38:01 <metaperl> oh, we would need a different data type descrpiton.. yes
01:40:47 * musasabi had a nasty mdo + concurrency related bug and solved it ^_^
01:45:08 <vincenz> ghc seems to have a very clean ff
01:45:09 <vincenz> ffi
01:45:13 <vincenz> I assume only ghc has ffi, not hugs
01:52:14 <musasabi> vincenz: hugs and nhc do ffi too.
01:52:39 <musasabi> now only to solve a memleak...
01:58:34 <metaperl> Prelude> data Tree a             = Leaf a | Branch (Tree a) (Tree a)
01:58:34 <metaperl> ERROR - Syntax error in expression (unexpected keyword "data")
01:58:52 <metaperl> why is hugs not accepting this type description
01:58:55 <TFK> metaperl, you can't do assignment in hugs :-(
01:59:08 <metaperl> oh
01:59:14 <TFK> Do it in a file and load it with ':load'
01:59:20 <metaperl> oh
02:00:25 <vincenz> Woo
02:00:29 <vincenz> I got ghc on my system
02:00:33 <metaperl> the "Tree" words on the right are data constructors not type constructors, right?
02:00:50 <vincenz> shapr is going to be STOKED
02:01:44 <jlouis> ah, so Control.Arrow.(&&&) splits the input and uses 2 arrows to produce a new arrow, whereas (***) wants 2 inputs and parallellizes the arrows this way
02:01:49 <jlouis> interestring ;)
02:02:04 <jlouis> But admitted, it makes your brain twist and turn a bit ;)
02:02:15 <metaperl> does anyone know if the Tree on the right are data or type constructors?
02:02:33 <metaperl> actually they must be type constructors for this to be recursive
02:03:59 <jlouis> they are type constructors yes
02:04:07 <jlouis> and they define a recursive type, exactly as you stated
02:04:10 <vincenz> people
02:04:15 <vincenz> get me coding
02:04:48 <metaperl> done: I used the original Tree def to build a tree:
02:04:49 <metaperl> Main> Branch (Leaf 5) (Branch (Leaf 4) (Leaf 6))
02:04:50 <metaperl> Branch (Leaf 5) (Branch (Leaf 4) (Leaf 6))
02:05:05 * jlouis force persuades vincenz: ``There is much code to be written, you should go write some''
02:05:06 <metaperl> root node is 5, with children 4 and 6
02:05:15 <metaperl> implement all of CPAN
02:05:28 <metaperl> start with DBI
02:05:45 <vincenz> jlouis: gimme something interesting to do in haskell
02:05:51 <metaperl> is there are CGI for Haskell
02:05:52 <vincenz> I'm a need-driven learner
02:06:20 <metaperl> seriously build a cpan search site for haskell
02:06:33 <jlouis> metaperl: no, the branches does not contain any values in the definition of tree you gave
02:06:55 <metaperl> they contain leafs 4 and 6
02:07:12 <metaperl> doesnt it?
02:07:27 <jlouis> the root is a brach, where the left node is a leaf of the value 5, and the right node is a branch, where the left leaf is 4 and the right leaf 6
02:07:46 <TFK> vincenz, http://spoj.sphere.pl/ranks/PIVAL/ <--- beat the LISPers.
02:08:10 <TFK> Err, this is the problem itself: http://spoj.sphere.pl/problems/PIVAL/
02:08:18 <metaperl> oh so the 5 has no sibling
02:08:31 <metaperl> or rather, it's sibling is a branch and not a leaf
02:08:43 <vincenz> how lame
02:08:43 <metaperl> I see
02:08:59 <TFK> vincenz, yes, programming is lame.
02:10:03 <vincenz> no pival is lame
02:10:12 * vincenz smacks TFK around with a C++-std
02:10:37 <vincenz> my computer is so functional
02:10:46 <vincenz> I have a constant running screen I can loginto from work
02:11:08 <vincenz> window 0: irssi, window 1: ocaml interpreter, window 2: ghci
02:11:28 * TFK smacks vincenz around with the Java JDK
02:11:44 <TFK> Perhaps pival is lame because... you can't do it? :-P
02:12:34 <dons> the challenge of how many digits to produce doesn't seem to hard in a lazy functional language. this year's iohcc contained such a program, I think
02:12:43 <boegel> @index doNothing
02:12:43 <lambdabot> bzzt
02:12:53 <boegel> is there a 'doNothing' function ?
02:13:07 <vincenz> TFK: no... it's just a fricking pi-generator, what's hard about that?
02:13:11 <autrijus> boegel: sure
02:13:18 <autrijus> it's spelled 'id'
02:13:21 <dons> there it is: http://www.scannedinavian.org/iohcc/succzeroth-2004/PiSpigot.hs
02:13:28 * vincenz codes template-curriers for C++ in his spare time
02:13:30 <boegel> autrijus: can I use it in IO context ?
02:13:30 <TFK> vincenz, what's hard about anything computable?
02:13:40 <autrijus> boegel: in monad, doNothing is spelled
02:13:41 <autrijus> return ()
02:14:21 <boegel> autrijus: but doesn't that 'exit' the do clause ? or is it different from Java ?
02:14:36 <autrijus> it doesn't exit the do clause.
02:14:40 <autrijus> it's very counterintuitive.
02:14:42 <dons> so just load PiSpigot:
02:14:43 <dons> *Main> take 20 Main.pi
02:14:43 <dons> [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4]
02:14:48 <dons> take 100000 ...
02:14:57 <dons> lazy lists rock
02:14:58 <vincenz> oh!
02:14:58 <autrijus> it exits that line
02:15:04 <autrijus> which essentially means, nothing
02:15:06 <boegel> autrijus: ok
02:15:10 <vincenz> is there an easy to use gui lib for haskell?
02:15:25 <autrijus> if you want a Javaish return, you need to use Continuation monad with shift and reset.
02:15:36 <autrijus> shift $ \_ -> return()
02:15:41 <autrijus> shift $ \_ -> return ()
02:15:44 <autrijus> is like Java's return.
02:16:26 <vincenz> ?
02:16:34 <boegel> autrijus: that's not what I need, but thanks anyway :) return() will do for me
02:16:46 <metaperl> ERROR "2.hs":4 - Not enough arguments for type synonym "Association"
02:16:48 <metaperl> type Association a b    = (a,b)
02:17:06 <autrijus> vincenz: I hear WxHaskell is okay
02:17:27 <vincenz> thnx
02:18:01 <autrijus> somebody knows a bot that can track subversion or darcs commits?
02:19:05 <dons> autrijus: no! but I'm always tempted to write one for lambdabot
02:26:18 <metaperl> I cant define association lists:
02:26:20 <metaperl> type Association a b    = (a,b)
02:26:20 <metaperl> data AssocList  a b     = [Association]
02:26:31 <metaperl> oh wait
02:26:54 <metaperl> type Association     = (a,b)
02:26:54 <metaperl> data AssocList      = [Association]
02:26:58 <metaperl> still fails
02:28:19 <metaperl> data Point a            = Pt a a
02:28:19 <metaperl> data Tree a             = Leaf a | Branch (Tree a) (Tree a) deriving Show
02:28:19 <metaperl> data Assoc a b          = (a,b)
02:28:40 <boegel> is 'self-defined' correct in English ?
02:28:48 <boegel> as in 'I defined it myself'
02:29:29 <dons> sounds good to me
02:31:34 <metaperl> self-referential?
02:31:52 <metaperl> self-evident?
02:31:57 <metaperl> why do you want to use that term?
02:32:09 <metaperl> ** forget my earlier pastes, all is well **
02:33:53 <boegel> because I want to translate 'zelfgedefineerd' from my language :p
02:38:18 <seidan> boegel: I think self-defined would be "it defines itself", as in self-motivated, self-preserving, etc. but the intended meaning is obvious. Might interrupt the flow of the reader's thoughts though.
02:38:40 <metaperl> This sentence is true
02:38:50 <metaperl> That is a self-referential sentence. Not self-defined
02:39:04 <metaperl> How does something become self-defined?
02:39:16 <metaperl> definition is achieved through relative conceptualization
02:39:31 <metaperl> relative meaning more than one is required
02:39:35 <boegel> seidan: how should I translate is then ?
02:39:36 <seidan> cogito ergo sum
02:39:40 <metaperl> hence eliminating the possiblity for self-definition
02:39:55 <metaperl> "is" ?
02:40:00 <boegel> metaperl: I defined it myself (as in, I wrote the code myself)
02:40:41 <metaperl> well, if you have anything you want me to read, you can paste it somewhere, perhaps http:rafb.net/paste
02:41:12 <seidan> I think what you just wrote is the most clear way to state it. otherwise: "original" ...maybe
02:41:41 <boegel> metaperl: maybe later :)
02:41:47 <boegel> shapr is the editor, so he should read it ;)
02:41:57 <boegel> seidan: ok, thanks
02:42:16 <seidan> ah, something for the mag I saw mentioned on the wiki?
02:42:39 <IRCusr> can anyone help me with this?: Instances of (Floating Integer, RealFrac Integer) required for definition
02:42:50 <IRCusr> i can show you the code if you like
02:43:20 <boegel> seidan: indeed, an article for TMR
02:44:02 <boegel> I'm out, enough writing for now
02:44:05 <boegel> bye everyone !
02:45:03 <IRCusr> prime n = not(fact==[]) where fact=[y | y<-[1..(floor (sqrt n))], (n `mod` y)==0]
02:45:36 <TheHunter> try ... floor (sqrt (fromIntegral n)) ...
02:45:46 <IRCusr> actually the code wouldn't work anyway, but i'm trying to fix the bug firt
02:47:31 <IRCusr> that's great, could you explain what this does? my code seemed to return an Integer before adding that
02:48:06 <TheHunter> also, you might wanna start with 2 and remove the not.
02:48:10 <TheHunter> @type fromIntegral
02:48:11 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
02:48:19 <TheHunter> @type sqrt
02:48:20 <lambdabot> sqrt :: forall a. (Floating a) => a -> a
02:49:00 <TheHunter> sqrt expects an instance of Floating, e.g. a Double, so you can't pass it an Integer. fromIntegral converts an Integer to a Double.
02:49:37 <TheHunter> @type null
02:49:38 <lambdabot> null :: forall a. [a] -> Bool
02:49:56 <IRCusr> but if I type floor ( sqrt 10 ) at the prompt in hugs i get an Integer as expected
02:50:16 <TheHunter> that's because 10 is overloaded.
02:50:19 <TheHunter> @type 10
02:50:21 <lambdabot> 10 :: forall t. (Num t) => t
02:50:35 <TheHunter> so 10 can be any Num. In your case, 10 is a Double.
02:51:03 <IRCusr> i'm beginning to understand, but i've only being doing haskell for a week or two so it'll be a little while before i cover types in any detail, thanks for your help
02:51:58 <TheHunter> prime (n::Int) = null [y | y <- [2..floor (sqrt (fromIntegral n))], n `mod` y == 0]
02:52:03 <TheHunter> that oughta work.
02:52:41 <TheHunter> oh, forget the ::Int part.
02:52:49 <IRCusr> looks good, do i benefit from lazy evaluation if the number is even?
02:53:07 <TheHunter> Prelude> prime 10000000000000000000000000000000000000000000000000000000
02:53:08 <TheHunter> True
02:53:15 <IRCusr> lol
02:53:31 <TheHunter> hmm.
02:53:59 <TheHunter> here's the problem (I defined the function only on Ints)
02:54:05 <TheHunter> Prelude> 10000000000000000000000000000000000000000000000000000000 :: Int
02:54:05 <TheHunter> 0
02:54:18 <TheHunter> Prelude> prime 10000000000000000000000000000000000000000000000000000000
02:54:18 <TheHunter> False
02:57:04 <Oejet> Prelude> myPrime 134512340574895724095715719574985732451365876325464894775235093230935136532352028023505670106312605063510987017308975737013459357938751
02:57:04 <Oejet> True
02:58:47 <TheHunter>  factors 134512340574895724095715719574985732451365876325464894775235093230935136532352028023505670106312605063510987017308975737013459357938751
02:58:47 <TheHunter> [3,593,1779,776249
02:59:38 <Oejet> TheHunter: Well, in my definition of primes at least, hence "myPrime". :-P
03:04:25 <IRCusr> i can't seem to find a command overview for the lambdabot, any ideas?
03:04:37 <TheHunter> @listcommands
03:04:37 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
03:04:37 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
03:04:37 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
03:04:37 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
03:04:37 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
03:04:38 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
03:04:40 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
03:04:42 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
03:04:44 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
03:04:58 <TheHunter> @wiki
03:04:58 <lambdabot> http://www.haskell.org/hawiki/
03:05:09 <TheHunter> @arr
03:05:09 <lambdabot> I'll keel haul ya fer that!
03:05:21 <TheHunter> @eval 3 + 4
03:05:22 <lambdabot> 7
03:08:15 <TheHunter> yay! I finally fixed the "ghci" problem in my mondadic reflection thingy.
03:09:12 <TheHunter> turns out the meaning of programs using implicit parameters depends heavily on the monomorphism restriction, and I happened to alias my ghci to ghci ... -fno-monomorphism-restriction.
03:17:56 <esap> what do you mean with 'depend'? They require monomorphism restriction, or do not work when monomorphism restriction is there?
03:18:46 <TheHunter> they have a different meaning.
03:19:09 <esap> is there a preferred meaning?
03:19:29 <TheHunter> usually you want the meaning that the monomorphism provides you with.
03:20:04 <TheHunter> But what I'd actually prefer was a -fwarn-monomorphism flag that warns everytime something related to the mm kicks in.
03:20:39 <TheHunter> s/monomorphism/monomorphism restriction/
03:21:48 <TheHunter> and "let a::b = c in ..." is not the same as "let a::b; a = c in ..." (under -fno-mono...)
03:23:12 <TheHunter> it's all a big mess. There should be a letmono construct.
03:23:37 <IRCusr> i think this question is much the same as the last one, but could someone take a look at this and tell me where i'm going wrong?
03:23:38 <esap> hmm.. I should probably try -fno-mono at least to understand what it does. I was under impression that you can always disable the monomorphism restriction by adding a type signature
03:23:42 <IRCusr> perfects n = [(2^x-1)(2^(x-1)) | x<-[1..n], (prime 2^x-1)]
03:24:05 <IRCusr> perfects::Integer->[Integer]
03:24:30 <IRCusr> it doesn't seem to know that i want x to be an Integer
03:24:36 <TheHunter> esap, there are a few circumstances in which programs are (rightfully, imo) rejected under -fno-mono... that work in presens of the mono...
03:25:40 <TheHunter> IRCusr, what's (2^x-1)(2^(x-1)) supposed to do? a multiplication?
03:25:57 <esap> you mean I can get better type checking with -fno-monomorphism-restriction? hmm.. I thought it disabled a restriction, not added one :-)
03:26:05 <TheHunter> in that case, it should be (2^x-1)*(2&(x-1))
03:27:49 <TheHunter> foo y = let x = doStuff y in if p y then x else y
03:28:18 <TheHunter> where doStuff is of type (Monad m, Monad n) => m a -> n a.
03:29:11 <TheHunter> hmm, that still doesn't do it.
03:30:23 <TheHunter> anyway with -fno-monomorphism restriction you can an `ambigous constraint' error in these cases.
03:32:57 <esap> Hmm.. maybe -fno-mono can help me build the OO stuff. I do have some trouble building private data members.
03:34:05 <TheHunter> i think with scoped type variables, you can always live with or without the monomorphsim restriction.
03:34:36 <TheHunter> i always try to make my code run with both, but that still doesn't resolve all possible ambigouties.
03:34:42 <esap> The question is, which semantics is closer to my preferred OO semantics.
03:35:14 <esap> Or whether both do work for it.
03:36:01 * esap has a nice way of implementing OO-style classes in Haskell. The arrow notation really makes a difference there.
03:37:50 <esap> The idea being that one OO-style class would be represented by both a type class and a data type declaration, with very close to same information in both.
03:38:25 <esap> Then you implement the type class by using the projections of the data type.
03:38:28 <TheHunter> how do arrows come into play there?
03:39:00 <esap> OO methods are arrows. Here's an example of a class in that mechanism:
03:40:05 <esap> instance (ArrowApply arr) => ClassAPI NamedObject arr where { selfclass = NamedObjectMethods get_name set_name destroy where { get_name = proc () -> returnA -< "foo" ; set_name = proc val -> update -< val ; destroy = proc () -> get_representation -< () } }  Something like that.
03:41:01 <TheHunter> hmm, why do you use arrow notation instead of do for ArrowApply stuff?
03:41:31 <esap> Not all parts of the system can work with ArrowApply.
03:41:49 <esap> I don't want to make it uniformly ArrowApply. I have many different arrows. One for each class.
03:42:03 <TheHunter> i see.
03:42:07 <esap> No actually, not quite :-)
03:42:13 <esap> I don't have one per class
03:42:40 <esap> More accurately, Methods are in one arrow, Destructors in another, constructors in yet another arrow.
03:44:11 <esap> But the arrow types are parametrized by the class type.
03:45:23 <esap> So there is the type checking aspect to distinguish classes, but those do not really have different implementations
03:46:48 <esap> But the big idea there is how to look up methods from the class.
03:47:00 <esap> And that is using the projection operations from the data type.
03:47:42 <TheHunter> i suppose you can do inheritance and such?
03:48:19 <esap> Yes.
03:48:41 <TheHunter> nice.
03:48:53 <esap> It's related to how you connect the type class and the record type used to implement the type class.
03:49:12 <TheHunter> using template haskell to derive the adt from the type class or vice versa?
03:49:40 <esap> I have done it manually so far. I need to see all the pieces come together first.
03:51:10 <esap> Here's an example: class NamedObjectAPI cls a where { get_name :: Method cls a () String ; set_name :: Method cls a String () ; destroy :: Destructor cls a () String } data NamedObjectMethods a = NamedObjectMethods { get_name_impl :: Method NamedObjectMethods a () String ; set_name_impl :: Method NamedObjectMethods a String (), destroy :: Destructor NamedObjectMethods a () String }
03:52:08 <esap> Then instance declaration: instance (ClassAPI NamedObjectMethods a) => NamedObjectAPI NamedObjectMethods a where { get_name = class_lookup get_name_impl ; set_name = class_lookup set_name_impl ; destroy = class_lookup destroy_impl }
03:52:33 * esap typoes, the other destroy has to be destroy_impl.
03:53:13 <esap> That example doesn't use inheritance though.
03:54:17 <esap> very simple and uniform thing. Could be automatically generated.
03:55:05 <esap> But as I said, I have some trouble doing private members. I think they should map to members in the data decl that are not part of the type class.
03:56:55 <esap> Look at http://www.kotiposti.net/epulkkin/OOArrow.txt for details.
03:57:37 <esap> The object reference type is very weird, I have to say :-)
03:58:34 <esap> but that's not at all ready.
03:59:22 <TheHunter> wow, i'm impressed.
04:01:40 <esap> Look at 'method'. It's probably the most interesting thing there.
04:05:45 <esap> Because that's how you look up methods from a class.
04:05:52 <esap> Using the projections.
04:08:17 <esap> also constructors and destructors are interesting. [Look at the >>> instance for constructors.
04:09:45 <TheHunter> i'm slowly getting an idea of what this is doing. Anyway, i'm off to lunch.
04:09:56 <esap> ok see you later.
04:10:08 * esap has to get something to eat as well.
04:11:14 * musasabi ponders searching food, now that my network implementation finally starts to work..
04:29:20 <Orange1> is there an internet tutorial of haskell anywhere?
04:58:32 <xerox> 'lo
04:58:37 <musasabi> hello
04:59:17 <xerox> 'lo
05:05:52 <araujo> lo
05:06:06 <musasabi> my nfs server broke.. and took both of our desktop machines with it (nfsroot).. :-(
05:27:22 <autrijus> my laptop's hd just exploded. :(
05:27:43 <xerox> That's bad :(
05:29:11 <Oejet> autrijus: Was it a dramatical explosion with flames and pieces flying all over the place?
05:30:37 <autrijus> no, just a internal "boom" sound
05:31:26 <Oejet> Other symptoms?
05:41:22 <autrijus> spins like mad
05:41:25 <autrijus> lots of bad sectors
05:41:35 <autrijus> won't boot
05:41:43 <autrijus> claiming that failed reads
05:41:48 <autrijus> all over the screen
05:41:49 <autrijus> etc.
05:41:55 <Oejet> Smoke and smell of burned magnetic layers?
05:56:38 <pipe> hm... i just saw something very disturbing
05:59:57 <Oejet> pipe: How do you feel?
06:00:17 <pipe> an atm machine had the windows xp screensaver
06:00:37 <Oejet> pipe: Nice!
06:01:28 <Oejet> Oh, could you see if it had SP? :-/
06:01:33 <Oejet> SP2, even.
06:02:03 <pipe> no
06:02:24 <Oejet> Did you press CTRL-ALT-DEL?
06:02:42 <pipe> there's no keyboard
06:03:07 <Oejet> Wow, an atm without a keyboard.
06:04:00 <xerox> @info (++)
06:04:01 <lambdabot> -- ++ is a variable
06:04:01 <lambdabot> infixr 5 ++
06:04:01 <lambdabot> (++) :: forall a. [a] -> [a] -> [a]
06:17:04 <jlouis> @index foldM
06:17:04 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
06:17:04 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
06:17:04 <lambdabot> State,Control.Monad.Writer,Monad
06:56:36 <autrijus> is there a way to do getEnvironment on Win32?
06:56:46 <autrijus> except rebuilding ghc under cygwin
06:57:09 <autrijus> 6.2 here; I'd be happy if 6.4 has it resolved, though
08:12:27 * sqrt waves at vincenz.
08:12:44 <vincenz> hiyas
08:13:00 * vincenz doesn't know haskell, just idles here for the atmosphere
08:14:03 <pipe> "1 + 1" is a complete haskell program :D now you know
08:14:49 <vincenz> sqrt: ?
08:14:54 <vincenz> sqrt: ping
08:15:44 <sqrt> pingeling.
08:15:52 <vincenz> ah
08:15:58 <vincenz> you know anything about linear logic?
08:16:15 <sqrt> me?
08:16:19 <vincenz> yes
08:16:26 <sqrt> probably.
08:16:33 <vincenz> like multiplicative lgoic
08:16:34 <vincenz> logic
08:16:36 <vincenz> and additive
08:16:45 <vincenz> I get multiplicative cause I saw it applied
08:16:50 <vincenz> I don't quite see additive
08:18:13 <sqrt> okey. i'm not sure what the canonical definition of understanding i s ;o)
08:21:46 <vincenz> :/
08:21:49 <vincenz> seems noone does
08:21:49 <vincenz> crap
08:24:27 <sqrt> i think you misunderstood me.
08:25:24 <vincenz> well I understand multiplicative
08:25:31 <vincenz> I realize why the additive rules don't hold for it
08:25:34 <vincenz> but I don't see the additive
08:26:40 <vincenz> I don't have the formulas here with me
08:26:49 <vincenz> but it was on the first page of Pym's paper on BI
08:29:28 <sqrt> ok? i found the definition linear logic on wikipedia. can't seem to find the definition og additive logic.
08:30:03 <pipe> fEED me the lambda calculus!!!
08:30:07 <vincenz> ???
08:31:20 <sqrt> of even.
08:32:06 <vincenz> pipe: ?
08:37:38 <pipe> After all these years of programming and thinking about programming languages, all I can say is that there is only one programming paradigm: the Lambda Calculus.
08:37:47 * vincenz rolls his eyes
08:37:56 <vincenz> you have a lot to learn
08:38:54 <pipe> After all these years of programming and thinking about programming languages, all I can say is that there is only one programming paradigm: the Turing machine.
08:39:08 <vincenz> ...
08:39:20 <vincenz> wolfman!
08:39:31 <pipe> hm...
08:39:41 <pipe> your nick is strangely familia
08:39:42 <pipe> r
08:39:46 <vincenz> you did icfp?
08:40:07 <pipe> what's that?
08:40:09 <vincenz> nm
08:40:24 <pipe> maybe i did that, what is it?
08:40:49 <vincenz> ...
08:40:53 <pipe> dude who are you?
08:41:04 <vincenz> stop asking inane questions
08:41:45 <pipe> dude who are you?
08:42:26 <pipe> brb
08:46:37 * desrt blinks
10:00:20 <araujo> Greetings CosmicRay
10:00:29 <CosmicRay> hellu araujo
10:00:38 <araujo> How you doing CosmicRay ?
10:00:49 <CosmicRay> araujo: remembering whom to ask about Perl this time :-)
10:00:56 <CosmicRay> araujo: you?
10:01:00 <araujo> haha
10:01:06 <araujo> no, not me 8)
10:01:13 <CosmicRay> heh
10:01:19 <CosmicRay> I meant, "how are you doing"
10:01:29 <araujo> oh haha
10:01:31 <CosmicRay> I remember it's autrijus :-)
10:01:38 <araujo> Pretty well thanks, 8)
10:01:43 <araujo> Oh cool
10:14:29 <pipe> who is vincenz?
10:16:06 <Lemmih> pipe: Christophe Poucet.
10:16:15 <pipe> yeah but how does he know me?
10:16:43 <pipe> and what is icfp?
10:21:20 <vincenz> wolfman seemed familiar
10:21:42 <pipe> what do you mean?
10:21:50 <vincenz> ...
10:22:00 <pipe> wtf is wolfman?
10:22:37 <vincenz> your ircname
10:22:37 <vincenz> jezus
10:22:41 <vincenz> how many questions do you ask
10:23:01 <pipe> have i ever spoken to you before today?
10:23:17 <vincenz> I doubt it
10:23:39 <pipe> have you ever spoken to me before today?
10:23:59 * vincenz ignores pipe
10:24:11 <pipe> :(
10:39:47 <pipe> man i love this: http://lambda-the-ultimate.org/node/view/489#comment-3730
10:40:30 <pipe> Lemmih: check this out: http://lambda-the-ultimate.org/node/view/489#comment-3730
10:44:58 <Lemmih> Why should I see that?
10:45:23 <pipe> i love Ronny Wichers Schreur's response
10:45:31 <pipe> even though i don't understand it
10:46:34 <Lemmih> So why should I see that?
10:48:37 <pipe> maybe you can explain it to me :)
10:49:06 * Lemmih finds arguing about different methodologies useless at best and counterproductive at worst.
10:49:49 <Lemmih> pipe: Pipe it to /dev/null. Nothing of it matters, IMHO.
10:49:59 <pipe> it's not really an argument
10:50:20 <pipe> i'm just interested in that one quote, "After all these years of programming and thinking about programming languages, all I can say is that there is only one programming paradigm: the Lambda Calculus."
10:51:08 <pipe> that quote appears to be a joke response to the serious quote, "After all these years of programming and thinking about programming languages, all I can say is that there is only one programming paradigm: the Turing machine."
10:51:18 <pipe> but i'm not sure if it actually is a joke response or not
11:00:59 <pipe> any thoughts?
11:01:29 <arjanb> it's both serious and a joke
11:07:26 <vincenz> not really serious
11:07:34 <vincenz> lambda calculus gave rise to such things like pi calculus
11:07:41 <vincenz> can't model that in lambda
11:08:08 <ibid> the turing machine is actually very overrated
11:08:20 <ibid> no (serious) programming language is modelled after that
11:08:39 <ibid> and it's not very nice theoretically either
11:09:05 <pipe> so the guy in the first quote who talked about only one programming paradigm, the Turing machine... he basicly doesn't know what he's talking about?
11:09:06 <ibid> and, suprisingly - wasn't even the first model of mechanical calculation
11:09:27 <ibid> pipe: i wouldn't go that far
11:10:12 <gzl> vincenz: what exactly is pi calculus, anyway?
11:10:30 <gzl> it models concurrency, right?
11:11:29 <ibid> the turing machine *is* overrated, so many people do think it is something cool
11:11:52 <ibid> and many such people are competent programmers and even computer scientists
11:11:55 <gzl> ?
11:12:02 <gzl> "overrated" in what sense
11:12:23 <ibid> read what i wrote above
11:12:30 <gzl> oh, there.
11:12:31 <gzl> :)
11:12:46 <sqrt> big-Oh-notation is overrated too.
11:13:43 <ibid> you'd have to actually study models of computation to see the overratedness (and not just turing machines, which many series a researcers seem to do)
11:13:54 <ibid> sqrt: yeah, it should be big-theta :)
11:14:03 <sqrt> gzl: yes to the concurrency bit.
11:14:07 <gzl> well, i've studied lambda calculus more than i've studied turing machines.
11:14:36 <sqrt> big theta is overrated too.
11:14:54 <ibid> the notation or the idea of asymptotic complexity?
11:15:05 <gzl> my impression was that the notions of universal turing machine and turing completeness were the significant thing about turing machines
11:15:56 <ibid> gzl: the only significant thing about turing machines, apart from their popularity, is that they were the first intuitively obvious model of mechanical computation
11:16:08 <ibid> but it actyally wasn't the first model of that
11:16:29 <gzl> are you thinking of the lambda calculus or something else?
11:16:36 <ibid> and in my opinion it's not the best :)
11:16:38 <ibid> gzl: yes
11:16:47 <sqrt> the idea, ibid.
11:17:03 <gzl> yes, lambda calculus is nice
11:17:31 <ibid> also recursion theory
11:17:36 <gzl> i thought some kinds of results were easier to handle in lambda calculus and some were easier to handle with turing machines. or is that inaccurate?
11:18:35 <ibid> yeah, but turing machines aren't the only machine-style model
11:18:35 <jlouis> dons: alive?
11:18:41 <gzl> ah, I see
11:18:51 <ibid> i like rams :)
11:19:06 <ibid> much easier to grasp for modern people
11:19:12 <ibid> modern programmers at least
11:19:22 <ibid> and reason about
11:19:25 <sqrt> "modern people"....
11:19:53 <ibid> yeah, when turing came up with his machine, there was no computing culture
11:20:00 <jlouis> ibid: rams is in random access machines?
11:20:06 <ibid> yes
11:20:10 <gzl> what about turing machines do you think isn't so nice theoretically?
11:20:15 <jlouis> how do you feel about word-rams then?
11:20:30 <Philippa_> the lack of constant-time random access is a good starting point. They're a pain in the arse to analyse performance with
11:20:48 <ibid> jlouis: unlimited memory of limited-range integers?
11:20:52 <gzl> ok
11:21:07 <Philippa_> \calc is a lot better in that regard, reductions actually mean something
11:21:08 <gzl> yeah, that's fair
11:21:22 <jlouis> ibid: more or less yes. And the knowledge you can do bit-wise operations on the limited ranges
11:21:36 <ibid> jlouis: haven't done anything with them
11:21:58 <jlouis> Pointer Machines then?
11:22:14 <ibid> nope
11:22:17 <ibid> references?
11:23:10 <jlouis> a PM is a RAM where pointer arithmetic is disallowed
11:23:28 <ibid> so it has two data types essentially?
11:24:18 <jlouis> http://www.nist.gov/dads/HTML/pointermachn.html
11:24:23 <jlouis> is one definition
11:25:25 <ibid> that's a description,  not a definition :/
11:28:24 <jlouis> ibid: I agree one could do more formally than they do there
11:28:33 <ibid> well, that doesn't tell me what it is
11:28:37 <ibid> it's too vague
11:29:51 <ibid> http://www.cs.bu.edu/fac/lnd/toc/z/node5.html <- looks better
11:30:55 <gzl> how would you format this code? http://www.nparikh.org/misc/sample.txt
11:30:57 <gzl> seems kind of nasty.
11:36:33 <Philippa_> I'd eat all the space in the token funcs unless there's a good reason not to
11:36:45 <Philippa_> just work on the basis that all whitespace before a token must be pre-munched
11:42:23 <TheHunter> gzl, i'd format it like
11:42:26 <TheHunter> test = do
11:42:26 <TheHunter>     [3,4]
11:42:26 <TheHunter>   `mplus` do
11:42:26 <TheHunter>     [1,2]
11:44:19 <jlouis> hmm, I need a function, probably in the Foreign. heirachy that converts a CInt to an Int
11:45:11 <jlouis> grep -r 'CInt -> Int' * in the hugs libraries did not help ;)
11:45:43 <jlouis> or do i need that? It is a member of appropriate type classes it seems
11:50:03 <Oejet> jlouis: Have you tried fromIntegral?
11:50:21 <Oejet> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3ANum  It seems CInt is a Num.
11:56:45 <jlouis> Oejet: worked perfectly yes
11:57:00 <jlouis> I am just accustomed to SML/Ocaml where you have to convert
11:58:27 <metaperl> is there a reload last file command in hugs?
11:58:30 <Oejet> jlouis: I didn't know the answer until I just looked it up.  I think fromIntegral is just an overloaded conversion function.
11:59:29 <Lemmih> metaperl: :r
11:59:54 <metaperl> thanks
12:18:17 <Oejet> @info toInteger
12:18:19 <lambdabot> -- toInteger is a method in class Integral
12:18:19 <lambdabot> toInteger :: forall a. (Integral a) => a -> Integer
12:19:21 <Lemmih> Oejet: I'm about to package Hacanon for GHC 6.4
12:20:40 <Oejet> jlouis: fromIntegral = fromInteger . toInteger
12:20:47 <Oejet> Lemmih: Nice.
12:21:30 <Oejet> Lemmih: Will you write some small introduction for TMR?
12:23:36 <Lemmih> Yeah. Probably gonna do it as a case study of a ClanLib binding.
12:24:03 <Oejet> Lemmih: Cool.
12:24:25 <pipe> clanlib? the game library?
12:24:32 <Lemmih> Yes.
12:24:42 <pipe> i'd vote for SDL :)
12:25:10 <Lemmih> Bah. SDL was _not_ designed for actual game development.
12:25:32 <pipe> i think it has an excellent design
12:25:35 <pipe> clanlib is a mess
12:25:40 <Lemmih> Anyhow, I and several others have already written bindings to SDL if you're interested.
12:26:13 <Lemmih> pipe: Yes, but writing games with it is still easier than with SDL.
12:26:17 <pipe> yeah, i actually used some SDL bindings for a haskell raytracer
12:26:58 <pipe> thanks to lazy evaluation you could actually watch the raytracer's progress as the scanline renders the image
12:27:40 <lightstep> Was is that slow?
12:27:51 <pipe> yep
12:28:21 <pipe> i think a blank 640x480 scene took like 2 seconds to render
12:28:32 <Oejet> pipe: Did you profile your program?
12:28:46 <pipe> Oejet: i did according to your instructions :D
12:28:54 <pipe> at least i'm pretty sure it was you
12:32:44 <Oejet> pipe: I forgot.  Sorry. :-[
12:33:02 * pipe used to have a different nick
12:33:45 <Oejet> Are you more in balance with your new nick?
12:33:58 <pipe> yeah
12:37:12 <Lemmih> Greetings, SyntaxNinja.
12:37:31 <lightstep> How can tell GHC not to emit warnings about imcomplete patterns in a specific expression?
12:38:31 <SyntaxNinja> hi Lemmih
12:38:43 <Oejet> lightstep: Complete the pattern? ;-)
12:39:34 <SyntaxNinja> I think I'm going to make a 0.5 release of cabal and upload it to Debian
12:41:07 <lightstep> I use guards, and I manually proved that the patterns are complete. I want to tell in not to warn me, like comments for lint.
12:42:11 <Oejet> lightstep: Add some joker pattern at the end: ( _ ) -> error
12:42:45 <lightstep> Thanks.
12:48:49 <SyntaxNinja> I don't like using joker patterns to suppress warnings; better to actually put the missing cases there. that way if you add new cases that aren't handled, you get the warning back
12:52:18 <Oejet> SyntaxNinja: Valid point.
12:52:25 <lightstep> I have invariants in my data structure which I don't know how to represent by types.
12:54:51 <Philippa_> what sort of invariant?
12:58:06 <lightstep> For example, a leaf can have some value only a some ancestor says so. And I also use guards to simplify the code, and I know that the guard will always catch some of the patterns, so I don't write them explicitly.
12:58:28 <SyntaxNinja> lightstep: sometimes you can't express invariants with types, but you can use quickcheck to test them, at least.
13:00:27 <lightstep> I'm not too worried about correctness. I don't believe I have bugs there. But when compiling with -Wall I get long useless warnings.
13:01:11 <SyntaxNinja> lightstep: can you give us an example code snippet?
13:01:17 <Philippa_> tbh it's not as bad as it could be so long as you can keep the burden of maintaining the invariants to a handful of functions
13:01:25 <Philippa_> it's pattern-matching that's a PITA there
13:03:30 <lightstep> SyntaxNinja, I don't think it would be helpful. They idea is case e of {x | foo x -> y; A x -> z}, where e can also be B x, but foo catches that case.
13:03:55 <lightstep> Philippa_, yes, that was my initial question.
13:04:22 <lightstep> SyntaxNinja: I'd have to paste long code and it won't make this much clearer.
13:04:44 <Philippa_> one way to do that's to have a second "view" type that you can't do anything useful with other than pattern-match and look at the original structure
13:05:11 <Philippa_> that is, each value contains the non-matchable value it was derived from
13:05:30 <Philippa_> (but you can't write broken structure to it because you've got to use the invariant-maintaining funcs in order to generate it in the first place)
13:06:25 <lightstep> I thought there must be some macro pragma, "don't warn about the next pattern list"
13:06:33 <lightstep> s/macro/compiler/
13:11:36 <TheHunter> you could turn that into case e of {x | foo x -> y; otherwise -> assert (A x) z }.
13:13:10 <lightstep> @type assert
13:13:11 <lambdabot> bzzt
13:13:21 <lightstep> What is `assert'?
13:13:38 <TheHunter> well, actually that doesn't work because i didn't realize A was a constructor...
13:13:46 <TheHunter> @type GHC.Base.assert
13:13:47 <lambdabot> GHC.Base.assert :: forall a. Bool -> a -> a
13:14:42 <TheHunter> assert has some built-in magic. It prints the line number where the error occured.
13:18:03 <TheHunter> how about case e of {x | foo x -> y; ~(A x) -> z}?
13:19:14 <TheHunter> hmm, that prints a warning, too.
13:19:39 <lightstep> I have more patterns than this anyway.
13:20:44 <TheHunter> i guess adding _ -> error ... clauses are the price you have to pay for the benefits of -Wall.
13:20:55 <TheHunter> s/are/is/
13:27:33 <goron> Anyone present with experience in Stratego?
13:35:11 <Heffalump> goron: I know it a little.
13:35:16 <Heffalump> but not a huge amount
13:36:31 <goron> Heffalump: The problem is that I need to import a name from a module, but give it another name at the same time. (like the qualified syntax in Haskell)
13:37:13 <goron> Heffalump: If I now import a main strategy, it overwrites my own main somehow.
13:47:32 <Heffalump> oh, I don't know what much
13:47:40 <Heffalump> sorry
13:48:02 <Heffalump> I've never actually used it, I just know a lot about what kind of things it can do.
13:50:27 <goron> Well, thanks, for responding anyway.
14:12:46 <desrt> is ghc HEAD wonked for anyone else here?
14:27:29 <rjbs> I'm working through the YAHT, and I just don't understand one little thing.  Why is my attempt to print the factorials of the list not working here: http://nopaste.snit.ch:8001/1884
14:28:41 <Heffalump> @type map
14:28:43 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
14:28:54 <Heffalump> what type do you think putFact has?
14:29:14 <rjbs> I don't know what the types in Haskell are, but my primitive brain tells me to think it's a function.
14:29:29 <Heffalump> it is, but it's one that returns a value of type IO
14:29:34 <rjbs> Aha.
14:29:38 <Heffalump> Int -> IO ()
14:29:40 <Heffalump> to be precise
14:29:51 <rjbs> I need to learn more about types.
14:29:52 <Heffalump> so what type will map putFact have?
14:30:02 <desrt> mm.
14:30:19 <desrt> rjbs; you can't use map with monadic types, basically.
14:31:00 <Heffalump> desrt: you can. You just need to use sequence or sequence_ afterwards
14:31:00 * Heffalump does this all the time
14:31:00 <Heffalump> though perhaps I should just use mapM / mapM_
14:31:01 <desrt> you want mapM_ here
14:31:01 <rjbs> Heffalump: who knows, a list of IOs?
14:31:01 <rjbs> one sec, let me try my learning...
14:31:01 <desrt> k :)
14:31:19 <Heffalump> rjbs: roughly, yes
14:31:25 <Heffalump> though be a bit more precise
14:31:53 <desrt> does sequence like folding on bind?
14:31:58 <desrt> s/does/is/
14:32:10 <Philippa_> er, sorta, yeah
14:32:39 <Heffalump> @type foldr (>>=)
14:32:40 <lambdabot> bzzt
14:32:47 <Heffalump> not exactly, then :-)
14:32:49 <desrt> @type foldr (>>)
14:32:50 <lambdabot> foldr (>>) :: forall m a b. (Monad m) => m b -> [m a] -> m b
14:32:55 <desrt> @type sequence_
14:32:56 <lambdabot> sequence_ :: forall m a. (Monad m) => [m a] -> m ()
14:33:03 <desrt> @type foldr1 (>>)
14:33:05 <lambdabot> foldr1 (>>) :: forall m a. (Monad m) => [m a] -> m a
14:33:09 <desrt> very close.
14:33:22 <Heffalump> yeah
14:33:29 <rjbs> where can I find how to understand the type defs lambdabot is spewing?
14:33:32 <Heffalump> and if you're just going to throw away the result anyway, it's the same
14:33:39 <desrt> nod.
14:33:45 <desrt> cool.  i didn't know about sequence
14:33:46 <Heffalump> rjbs: I'm not familiar with YAHT, but any tutorial should tell you about types fairly early on
14:33:55 <rjbs> Heffalump: so far, not so much.
14:34:17 * Heffalump looks around hopefully for someone else to explain, since I'm really in the middle of something else
14:34:20 <desrt> @type sequence
14:34:20 <Philippa_> if it helps, the forall <vars>. bit isn't haskell 98
14:34:20 <rjbs> basically I know that there are numbers and strings, because I know about read and show. functions were obvious, and I know monads by word of mouth
14:34:21 <lambdabot> sequence :: forall a m. (Monad m) => [m a] -> m [a]
14:34:24 <desrt> @type mapM id
14:34:25 <lambdabot> mapM id :: forall m b. (Monad m) => [m b] -> m [b]
14:34:30 <Philippa_> do you know how type classes work?
14:34:31 <desrt> :)
14:34:45 <rjbs> Heffalump: no worries
14:34:56 <Heffalump> sequence = mapM id, mapM f = sequence . map f
14:35:11 <desrt> and sequence_ = mapM_ id
14:35:13 <Philippa_> actually, to step back a moment, do you understand type variables? (as in id :: a -> a)
14:35:14 <Heffalump> right
14:35:30 <desrt> or, really, sequence_ = mapM_ [anything] since it doesn't matter
14:35:38 <Philippa_> er, yes it does
14:36:01 <desrt> anything that fits typewise should be the same, no? (since the result is discarded)
14:36:09 <Philippa_> no, because it's a monadic action
14:36:16 <desrt> oh.  right.
14:36:32 <rjbs> Heh.  The chapter that begins after this exercise is Type Basics.  I'll blindly use mapM and move on for now.  Thanks.
14:36:57 <Philippa_> rjbs: you can think of mapM as "foreach" for now if you know an imperative language
14:37:07 <Philippa_> though you're guaranteed stuff happens in list order too IIRC
14:38:05 <rjbs> Philippa_: should I dare ask what the M is for? monad, I assume, telling me that since I'm mapping to something monadic I can be happy to (maybe) let side-effects be discarded?
14:38:35 <Philippa_> it's monadic, and you can't discard side-effects
14:38:40 <desrt> rjbs; working inside a monad is a double-edge sword... not only can you pass your result on via the monadic context, but you also need the monadic context to even work at all
14:38:42 <rjbs> I feel like one little part of this exercise was not possible with the information I'd been given so far.  I think this book is under construction...
14:38:46 <Philippa_> it's mapping a monadic action along the list
14:38:54 <rjbs> Philippa_: heh, sorry, I meant return values be discarded
14:39:01 <desrt> so mapM makes sure that each of your actions can 'touch' (if you will) the monad (in this case, IO)
14:39:05 <desrt> otherwise your actions can't do IO
14:39:10 <Philippa_> and yeah, if you don't need the return values you can ignore 'em
14:39:19 <rjbs> OK.
14:39:41 <Philippa_> an example that might help is mapM print <list>
14:39:44 <rjbs> All I know about monads I get from Leibniz, but so far I think it's enough to understand what they are in Haskell.
14:39:58 <desrt> oh.  ignore those ones :P
14:40:17 <rjbs> desrt: heh. no, I think they're helpful for understanding the basic idea, at least as of page 47 of YAHT
14:40:18 * Philippa_ finds the categorical definition fairly useful, though you have to know how to interpret it in context
14:41:00 <desrt> rjbs; here's my favourite definition of monad: they don't exist.  they're just a class of thing
14:41:00 <rjbs> Philippa_: I won't try to explain my understanding, atm, but I think I understand how useful the idea of monads would be to introduce side-effects to functional programming in a sane way.
14:41:25 <desrt> anything that has 'bind' and 'return' defined on it can be called a monad (in addition, they should obey the monad properties too)
14:41:47 <desrt> which is the same as saying that anything that has + - and * defined on it is a vector (and in addition, they should obey the vectorspace axioms too)
14:41:51 <rjbs> OK, well, I'm going to go back to YAHT and see if I can't learn enough to do something useful with Haskell, like help implement Perl 6 :)
14:41:57 <rjbs> So far, nice language.
14:42:40 <Lemmih> SyntaxNinja: Ping.
14:42:50 <Philippa_> desrt: I find join useful for explaining one property of monads, mind
14:43:02 <Philippa_> but then, I have a possibly-weird view of them anyway
14:43:04 <desrt> join is monadplus?
14:43:15 <Philippa_> join :: Monad m => m (m a) -> m a
14:43:32 <desrt> blink.
14:43:47 <Philippa_> if you view monads as being languages that include haskell as a subset (in the form of return), join tells you the language has to have the equivalent of higher-order functions
14:43:50 <TheHunter> i'd go as far as to say that the idea to base monads on bind and return instead of fmap, return and join is crazy.
14:44:03 <desrt> so join on the list monad would be concat?
14:44:15 <Philippa_> TheHunter: they're equivalent and bind leads to more readable conventional code
14:44:19 <Philippa_> desrt: think so, yeah
14:45:03 <TheHunter> bind swaps the order wrt pure code, so that's probably the worst thing you can do.
14:45:15 <desrt> join n = x <- n; x
14:45:22 <TheHunter> for conventional code, we have do notation.
14:45:25 * desrt scratches head, wondering if that works
14:46:05 <desrt> join :: forall t1 t. (Monad t) => t (t t1) -> t t1
14:46:11 <desrt> rather, join n = do x <- n; x
14:46:16 <desrt> that's neat.
14:46:33 <TheHunter> join + fmap are easier to understand and easier to implement.
14:46:51 <Heffalump> I think >>= is easier to understand.
14:47:07 <desrt> that would desugar to join n = n >>= (\x -> x) or join n = n >>= id
14:47:21 <TheHunter> @type (>>=)
14:47:23 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
14:47:35 <lightstep> I thought that this kind of arguments led to Haskell having default methods.
14:47:39 <desrt> @type (\n -> n>>=id)
14:47:41 <lambdabot> (\n -> n>>=id) :: forall m b. (Monad m) => m (m b) -> m b
14:47:51 <desrt> heh.  i love that.
14:48:09 <TheHunter> the haskell monad hierarchy is broken, imo.
14:48:21 <TheHunter> it has to be class Functor m => Monad m.
14:49:03 <lightstep> The Haskell model of subclasses is broken imo, since you can't define it Functor f => Monad f after the fact.
14:49:10 <pipe> alright! tomorrow is fucking negev desert trip!!!
14:49:12 <TheHunter> Heffalump, what's an easy interpretation of >>=.
14:49:35 <desrt> TheHunter; do
14:50:09 <TheHunter> @type join
14:50:10 <lambdabot> bzzt
14:50:13 <Philippa_> lightstep: the reason you can't do it is that all of a sudden it fucks up every instance declaration that can't see the after-the-fact definition
14:50:16 <desrt> @type (>>=id)
14:50:17 <lambdabot> (>>=id) :: forall m b. (Monad m) => m (m b) -> m b
14:50:18 <desrt> ^^ join
14:50:19 <TheHunter> dammit, that's not even in the prelude
14:50:35 <TheHunter> @type Control.Monad.join
14:50:36 <lambdabot> Control.Monad.join :: forall a m. (Monad m) => m (m a) -> m a
14:50:47 <Philippa_> TheHunter: it's pretty much equivalent of a | b in bash
14:51:16 <TheHunter> now the meaning of join is: take all the monadic effects that are in the outer m, and combine them with those in the inner m.
14:51:29 <Philippa_> or alternatively "run this computation"
14:51:31 <lightstep> Philippa_, a sufficiently smart person could solve this.
14:51:47 <TheHunter> i think every explanation of (>>=) must be more complicated.
14:51:58 <Philippa_> lightstep: not really. Might work in this one specific case, but hey
14:52:04 <TheHunter> "run this computation" is not a correct description.
14:52:06 <desrt> TheHunter; i didn't understand your explanation
14:52:46 <Philippa_> TheHunter: it is when taken as command in the language the monad describes (cf return as "evaluate this expression")
14:53:57 <xerox> Is there something absolutely weird in "foldl1 (\x y -> (+) (2^x) (2^y)) [1..6]" ?
14:55:07 <Philippa_> assuming ^ is defined (I can't remember), I wouldn't have thought so. You getting an error?
14:55:27 <xerox> This kind of error: Process ghci exited abnormally with code 253
14:55:32 <desrt> xerox; that will give you a very large number
14:55:47 <Philippa_> point
14:55:53 <xerox> desrt, right..
14:56:07 <desrt> like, REALLY large
14:56:13 <desrt> i think you'd run out of memory
14:56:14 <xerox> It brokes at [1..5] btw
14:56:31 <Philippa_> how about 1..2?
14:56:36 <Philippa_> or 1..3?
14:56:39 <xerox> *Goodstein> foldl1 (\x y -> (+) (2^x) (2^y)) [1..4]
14:56:40 <xerox> 4722366482869645213712
14:56:54 <Philippa_> and you're about to take 2^4722366482869645213712
14:56:55 <desrt> think about how much memory you'd need to store 2^4722366482869645213712
14:57:00 <xerox> *Goodstein> foldl1 (\x y -> (+) (2^x) (2^y)) [1..3]
14:57:00 <xerox> 72
14:57:19 <desrt> heck... just type "2^4722366482869645213712
14:57:21 <desrt> into ghci
14:57:30 <desrt> same story
14:57:36 <xerox> Yay.
14:57:50 <xerox> Poor GHCi.
14:58:05 <desrt> poor you for not having [lots] megs of ram :)
14:58:35 <lightstep> Still didn't finish with [1..5] here.
14:59:30 <lightstep> Oh, GHC couldn't allocate 27MB
14:59:51 <desrt> increase the RTS heap size
15:00:09 <desrt> +RTS -H200M -RTS or something like that
15:00:40 <xerox> It does [2..5] :)
15:00:59 <xerox> Breaks on [2..6] hmpf ;)
15:01:07 <desrt> 3..6?
15:01:27 <lightstep> desrt, it wouldn't help me. The swap was almost fully used anyway.
15:01:37 <xerox> desrt, nope.
15:01:38 <desrt> ah
15:01:43 <desrt> probably an OS allocation failure, then
15:01:48 <desrt> xerox; 4..6? :)
15:02:19 <xerox> 281474976710720
15:02:35 <xerox> No [4..7].
15:03:01 <xerox> f([5..7]) => 79228162514264337593543950464
15:03:08 <xerox> If it's worth something.. :)
15:04:13 <desrt> heh
15:04:22 <TheHunter> desrt, ok. Lemme give it another shot. A monad m is type constructor that allows one to define actions of type m a. Now join takes an action that produces another action and combines the effects of both actions. What does (>>=) do? it takes a function and an action, applies the function to every result of the action and combines the effects. That's basically "join . fmap f".
15:04:22 <desrt> this -is- sort of a pointless exercise :)
15:05:49 <desrt> talk about >> then
15:05:51 <SyntaxNinja> hi Lemmih I'm sorta here
15:06:15 <desrt> >> takes two actions and composes them so that the second action occurs after the first
15:06:25 <desrt> and results in a complex action.
15:06:59 <TheHunter> yeah, but you can't use >> to define the other monad operations.
15:07:19 <wilx`> Just one thing.
15:07:23 <wilx`> Monads are ebil :)
15:07:34 <wilx`> At least that is what I see :)
15:08:44 <desrt> your definition of >>= is evil.  it forces me to think that you're thinking about the list monad
15:09:06 <Lemmih> SyntaxNinja: I'm using a function which ends on '#' and GHC can't parse it without -fglasgow-exts, so I was wondering what cabal extension I should use?
15:09:13 <TheHunter> the point is, i think fmap, return, join is both mathematically and computationally the easiest set of primitives to describe.
15:09:28 <TheHunter> @wiki MonadsAsContainers
15:09:29 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
15:10:02 <TheHunter> any description of >>= that's based on something like IO is evil.
15:11:10 <SyntaxNinja> Lemmih: hohum. not sure actually... I'd look at the manual to see what they call it, if it's there, and then check cabal to see if that's implemented
15:11:14 <SyntaxNinja> that's what I did to decide on the names, mostly
15:11:49 <TheHunter> note that my sloppy "all results" especially applies to the IO monad. By all results, i mean the results for all possible worlds at the beginning of the computation.
15:12:17 <Heffalump> I think >>= is nicer for fundamentally sequential monads like IO, Exceptions, State, etc, and join is nicer for non-deterministic/container monads like [], Maybe
15:12:39 <Philippa_> TheHunter: my descriptions aren't based on any particular monad, FWIW
15:13:03 <Philippa_> though yeah, join is nicer in terms of being able to think clearly
15:13:28 <desrt> TheHunter; this is a very good wikipage
15:13:40 <Heffalump> the type m (m a) is hard to explain for sequential types
15:13:45 <TheHunter> your descriptions seem to a little bit too handvawy :)
15:13:59 <TheHunter> s/:)/;)/
15:14:12 <Heffalump> TheHunter must be a category theorist or logician or similar evil species ;-)
15:14:15 <desrt> wolfgang always got annoyed by cale talking about monads as containers.  i should email this to him :)
15:14:29 <Philippa_> TheHunter: take the categorical description, assume that the category on the other side of the functor is a programming language
15:14:49 <TheHunter> Heffalump, what's wrong with a monadic action that "returns" a monadic action?
15:15:22 <Philippa_> and that therefore values in it are 'computations' (being essentially the same thing as 'programs', but without the 'complete system' baggage that comes with that)
15:15:45 <Heffalump> it doesn't really mean very much
15:16:08 <Heffalump> you end up having to describe what join does in terms of running the two actions in order, and >>= does that job much better
15:17:48 <Remi> hi all
15:18:18 <Lemmih> Hey Remi.
15:18:21 <TheHunter> the interpretation of sequencing in the IO monad is outside the language anyway.
15:18:26 <TheHunter> hi Remi
15:19:51 <Philippa_> join only 'does things in order' insofar as it naturally has to though. Can all be lazy as hell still
15:20:07 <Heffalump> not in the state monad, though
15:20:10 <Heffalump> which comes down to the same thing
15:20:10 <TheHunter> Heffalump, let's talk about the state monad. join combines two state transformations, which is a very simple function composition.
15:20:32 <Philippa_> TheHunter: I occasionally have to remind myself that you don't get a functor back out again
15:20:48 <Heffalump> no, it's not simple, because the type is ridiculously complicated
15:21:02 <Philippa_> not really, it's just app
15:21:08 <Philippa_> well, not quite but YSWIM
15:21:17 <Heffalump> join :: State -> (State -> (a,State), State) -> State -> (a,State)
15:21:19 <desrt> xerox; here's a fun one for you:
15:21:22 <desrt> let evil = id : map ((\n -> product [1..n]) .) evil
15:21:32 <TheHunter> State s a =~= (s -> s,s -> a)
15:22:09 <desrt> evil :: [Integer -> Integer]
15:22:14 <xerox> O_o ??
15:22:20 <TheHunter> Philippa_, I don't follow.
15:22:21 <desrt> Prelude> take 10 (map ($2) evil)
15:22:21 <desrt> [2,2,2,2,2,2,2,2,2,2]
15:22:34 <Remi> *reminds me of ackermann.. ;)*
15:22:56 <Heffalump> evil!!n k = (k!)^n
15:23:01 <Philippa_> TheHunter: you can put stuff from pure-Haskell into IO, you can't put stuff in IO into pure-Haskell
15:23:04 <Heffalump> oh no, sorry
15:23:15 <desrt> Heffalump; more like k(!)^n :)
15:23:15 <Heffalump> evil!!n k = k(!..n times..!)
15:23:52 <desrt> anyway.. 2!!!!!!!!!!!! is still 2
15:24:00 <desrt> but for any larger numbers things get interesting pretty rapidly
15:25:03 <lightstep> @type Maybe.maybe
15:25:04 <lambdabot> Maybe.maybe :: forall b a. b -> (a -> b) -> Maybe a -> b
15:25:34 <TheHunter> i still don't understand how people can find (>>=) simpler than join. join is just (=<<) id, so every definition of join must be necesarily simpler than the one of (>>=). fmap can usually be automatically derived anyway.
15:26:23 <Remi> the definition or the use of join?
15:26:23 <Philippa_> TheHunter: most of us spend most of our time in semi-imperative monads where bind's the more natural operation
15:26:41 <Philippa_> a completely-from-blank definition of >>= is more complicated, granted
15:26:49 <desrt> does Maybe.maybe throw an exception on Nothing?
15:26:52 <Philippa_> and there're times I'd be happy to define >>= in terms of fmap and join
15:27:25 <Remi> join may be easier to define, but I'd guess that by far the most common monad is IO, and there >>= is used quite a bit more often than join
15:27:29 <TheHunter> i usually define >>= in terms of fmap and join. There are less things to keep in mind then.
15:28:17 <lou-tze> desrt: why would it? it is obviously handled, judging by the type
15:28:54 <desrt> oooh
15:28:56 <desrt> i missed the b->
15:29:02 <desrt> i read it as being part of the forall
15:32:31 <TheHunter> ok, this discussion is leading nowhere. I keep my claim that people only find >>= more natural because they have used it much more often.
15:32:57 * jadrian is with TheHunter  
15:35:36 <jadrian> another thing I've pointed more than once is that we have different "default styles" of composing when working with monadic and non-monadic functions, and I see no reason for such a thing
15:35:42 <Philippa_> I'm close to that, but with the major caveat that it /is/ more natural in monads with a 'proper' concept of sequencing that
15:36:22 <jadrian> granted both styles have their advantages and disadvanteges, but I cannot see why one is better suited for monadic functions and the other for non-monadic ones
15:38:09 <TheHunter> Combining effects and mapping from values of type a to values of type b are different pairs of shoes and should be separeted. Sequencing is what monads are all about.
15:38:16 <jadrian> Philippa_: I don't see why it is more natural in monads...
15:41:39 <lightstep> TheHunter, the way you describe it, you should dispose of monads and functors, and switch to -> and Monoid
15:43:25 <TheHunter> i didn't mean to imply that.
15:44:05 <TheHunter> "separated" should mean "implemented independently".
15:45:30 <TheHunter> desrt, which wolfram, btw?
15:45:44 <desrt> TheHunter; wolfgang
15:46:24 <TheHunter> yeah, of course.
15:46:55 <TheHunter> so wolfgang who?
15:47:23 <desrt> thaller
15:47:39 <TheHunter> ah, ok.
15:48:09 <TheHunter> lightstep, btw. the name "monad" already suggests a close relationship between monoids and monads.
15:49:48 <SyntaxNinja> Lemmih: you know you can use ghc-options, right?
15:49:54 <SyntaxNinja> CosmicRay: alive?
15:53:23 <Igloo> SyntaxNinja: For the # thing? It would be nice if it wasn't necessary as it's probably reasonably common
15:54:03 <lightstep> `instance Expression e => Read e' gives me "Illegal instance declaration". What is the problem?
15:54:38 <Lemmih> lightstep: That's not correct Haskell according to the 98 standard.
15:54:47 * Heffalump reappears, reads scrollback, and disagrees about any implementation of join being simpler than (>>=)
15:55:08 <desrt> heh. thank god :)
15:55:35 <TheHunter> Heffalump, you mean every, right?
15:56:05 <desrt> thems fighting words :)
15:56:10 <lightstep> But I already gave it -fglasgow-exts. Now it requires -fallow-undecidable-instances, which I deem unsafe. Is there no way out?
15:56:28 <TheHunter> desrt, actually i wanted to make it easier for you to argument.
15:56:47 <TheHunter> because finding a monad where join is easier than (>>=) is simple.
15:57:07 <TheHunter> Furthermore, i claim that join is always easier.
15:57:21 <Lemmih> lightstep: It _is_ undecidable, so no.
15:57:28 <TheHunter> because there is only one type involved.
15:57:35 <desrt> join does seem a lot easier
15:57:39 <lightstep> Lemmih, why is undecidable?
15:58:52 <Lemmih> lightstep: Because nothing stops you from creating other instances of Read.
15:59:09 * desrt takes a nap
15:59:15 <TheHunter> good night
15:59:16 <lightstep> And when I try to compile with that option, it fails: conflict with Read (a, b). But no tuple is an instance of Expression.
15:59:28 <desrt> cheers :)
16:00:31 <Remi> good night
16:00:41 <Lemmih> lightstep: Using 'instance Read Expr where ..' is more sound.
16:01:39 <Lemmih> Or even 'instance (Expression a) => Read (Expr a) where ...'
16:03:44 <lightstep> The first option would require externalizing the parsing code, and I don't understance the second option.
16:03:51 <lightstep> *understand
16:07:02 <dons> jlouis: yeah?
16:12:57 <SyntaxNinja> Igloo: what's the extension?
16:14:55 <Igloo> The name would be something like Unboxed I guess
16:15:13 <Igloo> Maybe GHCUnboxed
16:15:55 <SyntaxNinja> and it requires -fglasgow-exts?
16:16:22 <Igloo> AFAIK there's nothing just for it, yes
16:16:33 <funkmando> hi ladies
16:17:04 <SyntaxNinja> Igloo: why GHCUnboxed?
16:17:34 <Igloo> It's GHC specific. I don't know if you have any such convention
16:17:46 <Igloo> I guess it would be bad for future compatibility if you did
16:18:09 <SyntaxNinja> no, there's no such convention; all extensions are generic.
16:18:25 * SyntaxNinja uploads haskell-cabal-0.5 to debian
16:31:06 <Heffalump> TheHunter: yes, every
16:35:10 <TheHunter> ok, then. What's your example?
16:42:37 <SyntaxNinja> the process of actually putting together a release always takes longer than it seems like it should
16:43:20 <SyntaxNinja> tmoertel: does whoever is taking care of cabal RPMs know about your cabal2rpm script?
16:46:39 <Igloo> Ah, that wonderful sensation as your improved algorithm overtakes your 5hour+run in under a minute
16:47:11 <dons> hehe!
16:47:50 <SyntaxNinja> Igloo: by doing it in C? ;)
16:48:35 <Igloo> I don't think you create better algorithms by switching to C  :-
16:49:13 <xerox> 'night folks - 01:49 here - yawwwn.
16:49:29 <TheHunter> 'night xerox
16:51:29 <Igloo> So, I conjecture n=4 is the only base in which you can write more than 1 n digit number such that the ith digit (starting from 0) is the number of times i appears in the number. Anyone bored enough to (dis?)prove it?  :-)
16:51:38 <desrt> dons!!
16:51:48 <funkmando> what does the function words return?
16:51:54 <desrt> HEAD is broken.  help me find out why :)
16:51:58 <funkmando> a list of strings?
16:52:49 <dons> desrt: ok. you think you broke it?
16:52:56 <desrt> dons; no
16:53:29 <dons> I see my last night's build died on: Parallel.lhs:8:0: lexical error in string/character literal
16:53:36 <desrt> when stage2 ghc-6.5 is linked, it seems that some libraries are being left out
16:53:41 <dons> but the  linux build died somewhere else?
16:53:58 <desrt> so you get a bunch of 'unresolved reference' crap
16:54:10 <dons> let me update the tree and have a peek
16:54:21 <desrt> if i manually enter the gigantic link command and add -lm -lgmp i reduce the number of unresolved refs but there are still some
16:54:40 <dons> any suspicious patches went in yesterday?
16:54:48 <desrt> i don't think so
16:54:58 <desrt> simonmar broke the tree in another way but it's fixed
16:55:10 <desrt> (and, i *think* it was unrelated)
16:55:15 <heatsink> Igloo: Does a number exist in which the zeroth digit appears zero times?
16:55:48 <dons> desrt: ok, I'm starting a build. I'll see how it goes
16:56:30 <funkmando> if words returned a list of strings, how would i select a desired element from said list? is it fst and snd thd or something?
16:56:34 <Igloo> heatsink: I think you have misunderstood. For example, 21200 is the only (if I didn't screw up) solution for base 5. It has 2 0s, 1 1, 2 2s, 0 3s and 0 4s
16:56:45 <dons> funkmando: elem
16:57:34 <heatsink> oh, I see.
16:57:50 <desrt> dons; awesome.  i've been waiting all day to talk to someone who can verify my sanity :)
16:57:53 <funkmando> dons: like elem[0](words s) takes the first word of a sentence titled words?
16:59:01 <dons> oh, you want to index it? try the !! function, a la > [1,2,3,4] !! 2
16:59:01 <dons> 3
16:59:16 <Igloo> empirical evidence suggests that it gets into a pattern with numbers like 821000001000 being the only solution, where the 8 increases and a new 0 appears before the final 1 as you increase n
17:00:03 <funkmando> dons : cool
17:02:23 <heatsink> Igloo: can you prove that sum [digit * index | (index, digit) <- zip [0..] number] == length number?
17:02:56 <heatsink> for example, with 821000001000 you have 8 * 0 + 2 * 1 + 1 * 2 + 1 * 8 = 12
17:05:40 <Igloo> If my conjecture is true then that is also true
17:07:41 <heatsink> how does that happen?
17:08:44 <desrt> uh
17:08:50 <desrt> heatsink; that's rarely true
17:08:57 <desrt> very rarely
17:09:36 <Igloo> Well it's easily checkable for n < 6, and beyond that if my conjecture is true you only need to worry about those in the pattern I gave, for which your sum gets one larger as the extra 0 pushes the 1 right an index
17:11:19 <desrt> length /= sum . (zipWith (*) [0..])
17:11:58 <Igloo> desrt: We're talking about a restricted set of numbers - see scrollback for details
17:12:04 <desrt> i see.
17:12:05 <TheHunter> heatsink's observation is true. Also, the sum of all the numbers is n.
17:13:03 <Igloo> The sum of the digits must be n as the sum of the number of times each digit appears is the length of the number  :-)
17:13:19 <Igloo> What's your proof of heatsink's observation?
17:13:38 <Igloo> Oh, duh, it's just the same thing, isn't it
17:13:44 <TheHunter> essentially the same. count how often the number i occurs.
17:14:49 <heatsink> oh, okay.
17:16:14 <desrt> wow
17:16:18 <desrt> igloo has a lot of free time :)
17:16:46 <heatsink> heh
17:22:04 * desrt uses cvs up -D in reverse
17:23:25 <heatsink> From what we have so far, we can say that the mean value of the distribution is always 1; so the number in the 'zero' location must always be greater than the sum of the numbers in locations 2 and above.
17:27:53 <desrt> ok.  so that was a bad idea, it turns out
17:29:05 <desrt> oh.  interesting
17:29:14 <desrt> there are some very suspicious commits on fptools-cvs
17:30:38 <dons> ?
17:31:20 <desrt> stuff like changes to mk/target.mk and aclocal.m4
17:31:32 <dons> yeah. saw that. hmm.
17:31:43 <desrt> it's broken on my mac too
17:31:44 <dons> my build is churning through stage1 atm.
17:31:55 <desrt> ya.  it's only stage2 that appears to break
17:32:00 <dons> ok.
17:42:25 <desrt> ok.  i'm trying the build with those two patches reversed
17:48:11 <heatsink> Actually, we can do better than that.  The markov inequality tells us that the only possible values for the numbers in locations in 2 and above are 0 and 1.
17:50:43 * heatsink forgot he was normalizing; nevermind
17:53:26 <Igloo> desrt: If I had a lot of free time I'd have a proof (I hope)  :-)
17:54:19 <dons> Igloo: would you use a theorem prover, or by hand?
17:55:19 <Igloo> If I had an awful lot of free time I might learn how to use a theorem prover
17:55:25 <dons> hehe
17:57:12 <dons> Dthey're not too hard, at least twelf and isabelle aren't. you essentially write type declarations as the theorem, and try to construct an expression of that type as the proof. feels very natural to fp people.
17:57:18 * Igloo was just reading a puzzle site which asked what the answer was for n = 10, so I wrote a quick program to work it out and then wondered what the distribution of answers across bases was like
17:59:08 <desrt> Igloo; ah.  i thought you had come up with this problem entirely on your own
17:59:40 <dons> desrt: i'm in to stage2 now
18:00:07 <Remi> I just updated the guards-section in http://www.haskell.org/hawiki/ThingsToAvoid
18:00:18 <Remi> does anyone feel like criticizing my changes?
18:00:25 <Remi> *runs a spellchecker over his last sentence*
18:01:31 <desrt> @type map.(+)
18:01:36 <lambdabot> map.(+) :: forall a. (Num a) => a -> [a] -> [a]
18:01:44 <desrt> raise = map.(+) :)
18:03:10 <Remi> that may be too much for a page which is primarily meant for newbies ;)
18:03:21 <desrt> i agree.  just being a jerk :)
18:03:39 * Remi doesn't feel offended as I didn't write that part ;)
18:04:33 <Remi> hm, though I don't really consider myself a newbie anymore, I don't know which one I prefer myself..
18:05:11 <Remi> I definitely don't like "raise x ys = map (x+) ys", but the choice between the last two isn't that easy
18:05:31 <dons> desrt: there it goes. dies at ghci/Linker.lhs:763:58: Not in scope: `Packages.extraLdOpts'
18:05:46 <desrt> dons; did you check out stable or head?
18:05:54 <dons> that's in the head
18:06:00 <desrt> er
18:06:02 <desrt> i just fixed that in head
18:06:09 <desrt> as of a few hours ago
18:06:19 <dons> oh, maybe it hasn't made its way to anoncvs yet.
18:06:26 <desrt> it's trivial
18:06:33 <desrt> edit Linker.lhs and replace extraLdOpts with ldOptions
18:06:41 <dons> my nightly bulids use anoncvs.
18:08:14 <desrt> ah
18:09:38 <dons> ok. patched. continuing..
18:11:04 <dons> where do you expect it to die?
18:11:24 <desrt> when it goes to link the stage2 ghc-6.5
18:11:31 <dons> ok. soon then..
18:14:12 <desrt> i need a 400GHz CPU for the purpose of building ghc
18:14:34 <desrt> alternatively, someone ought to figure out how to make -j work :)
18:14:48 <dons> -j does work!
18:14:55 <desrt> i thought only on libraries/
18:15:03 <dons> nope. see recent post.
18:15:07 <desrt> woh
18:15:09 <desrt> i've been missing out
18:15:22 <dons> in fact, I've even tried gmake -j8 with distcc over a cluster, and that worked
18:15:25 <desrt> i have two gigantic cpus and lots of ram
18:15:37 <desrt> i should get on some more lists or something
18:15:41 <dons> using pvmgmake to distribute ghc calls didn't work however, as pvmgmake is out of date.
18:16:07 <dons> desrt: go for -j5 or something.
18:16:08 <desrt> discc wouldn't do too much, would it?
18:16:14 <desrt> dons; just did :)
18:16:16 <dons> nope. just the rts
18:16:52 <desrt> wow.  my builds now take half as long.  you're my hero :)
18:17:03 <dons> it does effectively distribute the gcc part of a .hs compilation, but they're still sequential, so no obvious benefit
18:17:21 <dons> desrt: thank simonM
18:17:47 <dons> desrt: http://www.haskell.org/pipermail/cvs-all/2005-January/037729.html
18:17:58 <dons> ah ha! : undefined reference to `__gmpn_cmp' ...
18:18:15 <desrt> that's the one
18:18:18 <dons> ok. so where has libgmp gone?
18:18:25 <desrt> take the huge thing and add -lm -lgmp to the end
18:18:35 <desrt> resolves most of the unresolved symbols except about 10
18:18:57 <desrt> i think i blame the target.mk patch but i'm not sure yet
18:20:05 <dons> ok, still got a few gmp syms. i'll try again
18:20:40 <desrt> i should get on cvs-all
18:20:52 <desrt> you miss a lot on cvs-ghc
18:21:20 <dons> yep.
18:21:32 <dons> library stuff, and fptools commits, for one
18:21:47 <desrt> library/ is boring but fptools would be nice
18:22:08 <desrt> oh good.  it gets all the traffic that the other lists do (not just the commits)
18:23:08 <desrt> stage2!
18:24:25 <dons> you got it to go through?
18:24:35 <desrt> no.  it's on it.
18:24:57 <dons> wow. that was fast. did you start from scratch just a few mins ago?
18:25:01 <desrt> no
18:25:13 <desrt> interrupted a build somewhere in the middle of libraries and restarted with -j5
18:25:24 <desrt> and by restarted i guess i mean 'resumed'
18:26:10 <dons> got it to go through!
18:26:18 <desrt> what else did it need?
18:26:41 <dons> via: EXTRA_HC_OPTS='-lgmp -lm -L/usr/local/lib' so as to pick up libgmp in /usr/local properly
18:26:51 <dons> i'll try to get it to use in-tree gmp now
18:27:02 <desrt> are you using bsd?
18:27:12 <dons> si.
18:27:20 <desrt> heh.  you crazy /usr/local abusers.
18:27:40 <dons> heh. you crazy /usr abusers.
18:27:53 * desrt leaves it as it is :)
18:28:08 <dons> /usr/local is for all foreign==untrusted stuff on OpenBSD, in particular
18:28:20 <dons> so you can make, e.g. /usr or /etc ro
18:28:29 <dons> theoretically, at least
18:28:35 <desrt> on my linux box / is r/o
18:28:42 <desrt> which includes /usr /etc /usr/local /var ...
18:29:55 <desrt> (and some magic in /var)
18:31:04 <dons> ok. my theore is we''re losing the path to in-tree gmp somewhere, maybe after something messed with target.mk
18:31:16 <dons> as using out-of-tree gmp works fine
18:32:03 <desrt> my theory is that we're losing the linker options
18:32:17 <desrt> ok.  failure.
18:32:30 <desrt> *gets an idea*
18:32:41 <dons> library-dirs seems correct
18:33:13 * dons trys -v9
18:34:07 <dons> ok, the gmp path is actually there. theory 1 down.
18:35:42 <desrt> my theory is looking pretty broken right now too
18:35:55 <desrt> i'm diffing the working 6.3 link commandline with the broken 6.5 one
18:35:58 <desrt> can't find changes
18:39:09 <dons> hmm. what about this commit: http://www.haskell.org/pipermail/cvs-all/2005-February/038766.html
18:39:51 <dons> you looked at that, I guess?
18:40:17 <dons> no. not that one.
18:40:58 <desrt> i have no idea when it happened.  it could have been as much as 2 weeks ago
18:41:10 <desrt> although i suspect then it would have turned up in the nightlies by now
18:41:28 <dons> nah. must have been in last 2-3 days.
18:41:51 <desrt> and we're looking for a change in fptools or ghc for sure, right?
18:42:02 <desrt> (ie: not libraries or anything)
18:42:14 <desrt> btw: it's not the target.mk patch or the aclocal patch
18:42:28 <desrt> by build with those two reversed still failed
18:42:28 <dons> no. doesn't look like it.
18:43:07 <dons> can Cabal be implicated here? I'm not sure how it works this early in the build
18:43:09 <Igloo> It could be a change in package.conf of the base package
18:43:36 <dons> Igloo: yeah, that's my suspicion.
18:43:38 <desrt> i don't know what Cabal is
18:46:10 <dons> the last working HEAD I have is 18th- that's only yesterday. hmm.
18:46:21 <desrt> ya.  weird eh?
18:46:34 <desrt> i'm gonna jumbo-diff the tree :)
18:46:37 <aFlag> how do i get the greatest element in a list?
18:46:39 <desrt> it's been a slow past few days
18:46:56 <desrt> aFlag; foldr1 max
18:46:59 <Lemmih> @type maximum
18:47:00 <lambdabot> maximum :: forall a. (Ord a) => [a] -> a
18:47:04 <desrt> oh.  that too.
18:47:04 <dons> desrt: get on libraries@, you'll see the Cabal patches flying..
18:47:19 <desrt> k.  what is Cabal? :)
18:47:25 <aFlag> thanks
18:47:44 <dons> new uber-package system
18:47:47 <desrt> i see.
18:48:43 <desrt> http://www.haskell.org/pipermail/cvs-libraries/2005-February/003835.html
18:48:48 <desrt> this looks extremely suspicious
18:49:27 <dons> hmm.
18:50:07 <desrt> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/Cabal/Distribution/Simple/Build.hs.diff?r1=1.39;r2=1.40;f=h
18:51:01 <dons> hmm
18:51:06 <dons> double hmm
18:51:13 <desrt> let's see
18:52:43 * desrt rebuilds stage2
18:55:27 <desrt> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/Cabal/Distribution/PackageDescription.hs.diff?r1=1.40;r2=1.41;f=h
18:55:31 <desrt> another suspicious change
18:57:04 <Lemmih> Why is it suspicious?
18:57:14 <desrt> i think i know what the problem is
18:57:18 <desrt> they changed extra-libs to extra-libraries
18:57:24 <desrt> and didn't change the ghc package.conf to reflect this
18:57:31 <dons> sounds reasonable.
18:58:18 <dons> what's this weird stuff: your/slightest, look/will /easily/unclose, /me,funky, path ?
18:58:28 <dons> these Cabal guys are on crack
18:58:46 <desrt> heh
18:58:55 <desrt> ok.  changing extra-libs to extra-libraries helped
18:59:02 <desrt> a lot of the unresolved syms went away
18:59:10 <dons> in package.conf ?
18:59:20 <desrt> rts/pacakge.conf.in
18:59:54 <dons> testing..
19:03:00 <desrt> extra-ld-opts is also affected.
19:03:58 <dons> just changing extra-libs -> extra-libraries worked for me.
19:04:13 <dons> make sure to re-make in rts/ and in driver/
19:04:17 <desrt> i also needed to change extra-ld-opts to ld-options
19:04:46 <dons> you might need  extra flags on your system, perhaps
19:04:56 <desrt> probably.
19:05:17 <dons> yeah. LEADING_UNDERSCORE..
19:05:45 <desrt> that has nothing to do with it, i don't think
19:05:51 <desrt> it's just #if LEADING
19:05:52 <desrt> _this
19:05:54 <desrt> _that
19:05:56 <desrt> _other
19:05:57 <desrt> #else
19:06:00 <desrt> this
19:06:02 <desrt> that
19:06:04 <desrt> other
19:06:06 <dons> hmm yeah.
19:06:07 <desrt> #endif
19:06:16 <desrt> probably a linux thing
19:06:22 <desrt> ok
19:06:28 <desrt> i'm gonna rebuild stage2 from scratch just to make sure
19:06:50 <dons> ok. still works with ld-options patch too for me.
19:07:04 <dons> I'll just start a quick build
19:07:26 * desrt nukes -r ghc/compiler/stage2
19:08:53 * Remi gets some sleep
19:09:21 <desrt> dons; mind approving this commit?  i'm a bit out of my territory on this one
19:10:24 <desrt> i usually ask wolfgang what he thinks but he's not around atm :)
19:11:12 <dons> let my build go through, first. i don't know the new package.conf that well.
19:11:32 <desrt> k.
19:11:52 <desrt> thanks for the insight into cabal, btw :)
19:13:20 <dons> sure. it's good to fix this stuff on our own, I reckon.
19:13:36 <dons> the simons appreciate it -- if we do it right.
19:15:41 <desrt> i already owe simon marlow a birthday cake, i think :)
19:16:31 <dons> hehe
19:18:16 <dons> so -jN is working well for you?
19:18:22 <desrt> very.
19:19:15 <dons> cool. now we just need to write disthc..
19:19:29 <desrt> that would rule
19:19:37 <desrt> i have a network of 9 dual procesor G5s at work
19:20:20 <dons> huh. that'd be nice. i've got a 20-node pc cluster at uni.
19:20:20 <desrt> gigabit ethernet between them, too
19:20:31 <desrt> work = uni
19:20:53 <desrt> ok.  stage2 worked out.
19:20:56 <dons> pvmgmake was almost there, but it seems to be very out of date vrs. of make.
19:22:59 <hugabugg> hi homies
19:23:03 <Lemmih> Greetings.
19:24:07 <dons> desrt: if I can work out a good way to fragment the compilation of .hs files, so that we don't shoot ourselves sending .hi data back and forth, then I can imagine adding a -distrbuted flag to ghc..
19:24:26 * Philippa_ is having a conversation in #flipcode that is reminding her rapidly why she likes Haskell so much
19:24:26 <dons> roughly the model of distcc, which seems to be very solid
19:26:44 <desrt> dons; well... certainly for libraries, you could parallelise that very effectively
19:27:03 <Buggaboo> hi
19:27:12 <Lemmih> Greetings.
19:29:02 <dons> ok. almost done. churning through stage2 now.
19:29:15 <dons> -j2 on a single cpu is still faster
19:29:17 <Buggaboo> Im trying to write a (e)bnf for a calculator, I was wondering how I could write one and code the precedence of an operator/infix function without hardcoding it.
19:29:29 <desrt> Buggaboo; plz fix your irc client
19:29:44 <Buggaboo> is it borked?
19:30:00 <desrt> it's sending some invalid (not even utf-8) character in place of '
19:30:12 <Philippa_> I'm getting it fine
19:30:17 <Lemmih> So am I.
19:30:29 <dons> yeah, I get a inverse of `
19:30:35 <desrt> i get a <?> symbol
19:30:37 * heatsink is getting no character
19:30:56 <Buggaboo> o you mean this: ' and 
19:31:12 <desrt> i see "o you mean this: ' and <?>"
19:31:25 <Philippa_> just use ', it's generally accepted as the apostrophe char
19:31:40 <Buggaboo> `
19:31:55 <Buggaboo> `_ <- evil looking smiley
19:32:04 <dons> what key combination is producing inverse-` ?
19:32:11 <Buggaboo> actually it's a frowny
19:32:21 <Philippa_> that doesn't work on several clients because it's not in everybody's character set
19:32:33 <Philippa_> basically, anything beyond ASCII shouldn't be assumed
19:32:53 <Philippa_> (and the BEL character may make you unpopular)
19:33:22 <Buggaboo> Is there a channel on freenode about parsing/compilers/etc. ?
19:33:40 <desrt> you're probably in the closest approximation to it :/
19:36:58 <dons> ok desrt. builds fine for me. go for it.
19:37:04 <desrt> w0rd.
19:37:43 <Buggaboo> I remember haskell having a function that can set the precedence of an operator/infix functionormaybenotafunction, I'm trying to do a calculator using boost::spirit, now I want to figure out how to write an ebnf, or even if it is possible to do what I plan to do.
19:38:40 * dons works out how to add -jN to nightly builds
19:39:24 <Philippa_> Buggaboo: google for lecture notes on parsing, you'll almost certainly find a grammar for a basic calculator
19:39:34 <desrt> dons; done
19:40:45 <desrt> i should get nightlies setup on gorecki and gabriel
19:40:52 <desrt> the last time i went to set it up, HEAD was broken
19:40:58 <desrt> but i thought it was my fault so i gave up :)
19:41:13 <Buggaboo> hardcoding stuff in ebnf is doable, but I want to be able to set the precedence of an operator at runtime.
19:41:34 <heatsink> Igloo: I've proven that you cannot put the digit 2 into a position >= 3
19:41:39 * Buggaboo googlificates
19:42:27 <Buggaboo> All I want to know is how haskell does that precedence setting thingy trick.
19:42:56 <Buggaboo> which haskell interpreter/compiler do you guys recommend?
19:43:00 <desrt> heh.  it's checking out of anoncvs.  this should be fun
19:43:04 <desrt> Buggaboo; ghc/ghci
19:43:12 <Buggaboo> okeydokey.
19:43:20 <dons> Buggaboo: there are decls in haskell src specifying the precendence. at compilation time all operators are parsed, then a rewriter walks over the tree rewriting it according to the precendence rules in the src
19:44:15 <dons> thus the precedence rules can be seen as a tiny language for describing how to rewrite the parse tree. ghc essentially evaluates these rules.
19:44:56 <heatsink> Igloo: positions 3 and above can only contain 0 or 1.  This means that only positions 0 and 1 can contain numbers larger than 3, and position 2 can only contain 0, 1, or 2.
19:45:47 <heatsink> Igloo: you can finish the proof yourself if you're interested.
19:50:33 * Lemmih is having problems compiling GHC 6.4 with a Cabal aware version of GHC.
19:51:21 <Buggaboo> could someone please explain this to me ? "configure: error: GHC is required unless bootstrapping from .hc files."
19:51:29 <desrt> Lemmih; 6.4 or head?
19:51:58 <dons> Buggaboo: you need ghc to build ghc
19:52:07 <Buggaboo> ...
19:52:10 <dons> what OS you on?
19:52:13 <Buggaboo> linux
19:52:26 <desrt> what distribution?
19:52:30 <Buggaboo> slackware
19:52:31 <dons> you've probably got binaries of ghc in your package system..
19:52:36 <desrt> ah.  maybe not.
19:52:46 <dons> else, you can download them off the haskell.org/ghc site.
19:53:13 <Buggaboo> but I like compiling my own... *sigh*
19:53:21 <desrt> you can do that too
19:53:36 <desrt> but unless you want to bootstrap it yourself you need a starting point
19:53:54 <Lemmih> desrt: ghc-6.4.20050218
19:54:04 <desrt> very weird.
19:54:09 <desrt> what's the error you get?
19:54:14 <dons> Buggaboo: bootstrapping ghc is more difficult than starting with a binary, and compiling with that.
19:54:27 <desrt> dons and i just killed a cabal-related bug in HEAD about 10 minutes ago :)
19:54:31 <Lemmih> desrt: One moment.
19:55:31 <Buggaboo> I dont get this bootstrapping bidniz.
19:55:52 <desrt> Buggaboo; GHC is written in haskell... in order to compile it you need a haskell compiler
19:56:08 <Buggaboo> ach, nevermind, guys, thanks anyways
19:56:12 <dons> it's much the same as getting gcc onto a machine that doesn't have gcc on it.
19:56:31 <Buggaboo> they should be gcc friendly.
19:56:38 <dons> that's why machines come with a binary of gcc on them, usually.
19:57:07 <desrt> it's pretty cool that gcc is -the- standard compiler... even on commercial systems
19:57:20 <desrt> even the ancient AIX boxes at work have it
19:57:27 <desrt> (although, a somewhat ancient version of it)
19:57:44 <dons> Buggaboo: GHC is gcc friendly, that's how you boootstrap it. it's just harder than starting with a Haskell binary.
19:58:02 <Buggaboo> anyone got a tutorial on bootstrapping?
19:58:10 <desrt> Buggaboo; you really don't want to
19:58:24 <Buggaboo> ... try me.
19:58:34 <Buggaboo> show me the tutorial and Ill be the judge of that :)
19:59:05 <desrt> well.. there's a script somewhere in the tree that hasn't worked since version 4.x or so
19:59:08 <desrt> you can start there
19:59:17 <dons> Buggaboo: step 1. you need another machiine somewhere that has ghc installed.
19:59:39 <dons> you use it to generate .c files, which you take over to your target box, and finish the build with gcc.
19:59:44 <Buggaboo> ... ugh. Steep learning curve.  And other material resources I dont have.
19:59:59 <desrt> Buggaboo; the correct thing to do here (seriously) is to install the binary ghc, then use it to build your own ghc from source, then uninstall the binary
20:00:46 <Buggaboo> why dont the proggers use C++ to code it in the first place?! (insane ghc purists)
20:00:46 <dons> desrt: the porting guide is atually here: http://www.cse.unsw.edu.au/~dons/building/sec-porting-ghc.html
20:00:57 <desrt> dons; ssshhh :P
20:01:34 <Lemmih> Buggaboo: Because then it would be twice as big and twice as buggy.
20:01:35 <dons> Buggaboo: hmm. writing a Haskell compiler of 500,000 lines in C++ -- yummy.
20:01:45 <desrt> admittedly i've used that guide more than once :)
20:02:53 <Buggaboo> guys, thanks.  But I'll leave this endeavour to someone else.
20:02:56 <Philippa_> dons: is it possible to bootstrap via hugs?
20:03:09 <Lemmih> utils/Pretty.lhs:1:0:
20:03:09 <Lemmih>     Module `Pretty' is a member of package text-1.0.
20:03:09 <desrt> Buggaboo; it's already been done (it only needs to be done once, ever)
20:03:10 <Lemmih>     To compile this module, please use -ignore-package text-1.0.
20:03:28 <dons> Philippa: no. but it used to be via hbc or nhc98.
20:03:31 <Buggaboo> I dont like nasty rpms to fiddle with my puter.
20:03:43 <Philippa_> fair enough
20:04:10 <ulph> Buggaboo: Convert the rpm files to cpio archives then or something
20:04:12 <desrt> http://haskell.org/ghc/dist/6.2.2/ghc-6.2.2-i386-unknown-linux.tar.bz2
20:04:14 <desrt> download this
20:04:20 <desrt> ./configure --prefix=/opt/ghc-bin
20:04:24 <desrt> make install
20:04:33 <desrt> then when you're done, rm -r /opt/ghc-bin and it's totally gone
20:04:50 <desrt> no nasty rpms.  no 'puter-fiddling
20:05:33 <Buggaboo> It's been two years since I coded in haskell, is it worth it really...
20:05:35 <dons> these days there's too many ghc extensions required to build ghc. it isn't h98 anymore
20:06:01 <Buggaboo> I must say generic functions opened my eyes.
20:06:02 <desrt> Buggaboo; ok.  it's up to you.  whatever.
20:06:31 <Buggaboo> map, labda funks, foldl, foldr, filter, etc... gotta luv'em.
20:07:33 <Buggaboo> guys thanks a lot, I hope I haven't wasted too much of your time, if I have, I offer my apologies.
20:08:05 <dons> did you get an idea of how to deal with precedence more dynamically?
20:08:20 <Lemmih> desrt: Any idea what goes wrong?
20:08:21 <Buggaboo> um... no not really.
20:08:35 <desrt> Lemmih; no.  this is not the same as the problem we were getting
20:09:18 <Buggaboo> I really can't picture it in bnf (yet).
20:13:47 <dons> Buggaboo: maybe you should consult a book on compiler construction
20:17:33 <Buggaboo> I'll do that.  Thanks dons.
21:00:42 <gzl> in a do expression
21:00:54 <gzl> if foo returns a pair
21:01:07 <gzl> is there any way to do something like do { (a,b) <- foo; ... } ?
21:01:51 <heatsink> gzl: try it
21:02:22 <gzl> it doesn't work. i mean, how do you do what that code would do
21:02:54 <heatsink> it works for me.
21:03:04 <heatsink> Is foo a monad?
21:03:31 <gzl> yeah.
21:03:51 <gzl> oh, wait. hold on
21:04:21 <gzl> sorry. made a stupid mistake. it does work
21:04:38 <gzl> my fault
21:08:26 * jadrian forgot most of what he knew about compilers...
21:10:38 <dons> (a,b) <- foo; is just a pattern: foo >>= \(a,b) -> ...
21:13:22 <gzl> yeah, that's why i was surprised it didn't work. but of course it does, i just made a typo elsewhere. :)
21:24:40 <MachinShin> i'm just starting to learn haskell, and i'm reading one of the tutorials on haskell.org, and i got a quesiton,if anyone can answer?
21:24:51 <MachinShin> _Codex:  hey!
21:25:01 <gzl> ask and see.
21:25:57 <MachinShin> (++) :: [a] -> [a] -> [a]   <-- as i understand this line, it's saying the function ++ takes a 2 lists, and returns a list.  do the param names mean anything?
21:26:55 <gzl> those aren't names, those are types
21:27:02 <gzl> 'a' is a type variable
21:27:21 <LinkMasterSab> All 'a's in the type declaration are the same type, but 'a' can be any type
21:27:24 <gzl> it means (++) takes two lists of *any* type (but both lists must be of the same arbitrary type) and returns a list of that type
21:28:04 <MachinShin> so if it was (++) :: [a] -> [b] -> [c]  it'd be saying  that those a,b,c are different types (can they be the same type too?)
21:28:17 <Gahhh> yes
21:28:18 <gzl> yes
21:28:25 <MachinShin> ah. ok. i understand now. thanks.
21:28:40 <gzl> you may also see stuff like
21:28:42 <MachinShin> all this functional stuff is rather new for me, but that's why i'm learning it :)
21:28:55 <Gahhh> welcome to a brave new world
21:29:05 <MachinShin> Gahhh: s/brave/weird/;
21:29:06 <MachinShin> ;)
21:29:06 <gzl> f :: Foo a => a -> a -> a
21:29:16 <gzl> which means that a can be any type as long as it's a Foo
21:29:51 <MachinShin> what? wait, you're saying it's saying that 'a' can only be of type Foo?
21:29:55 <LinkMasterSab> I'm not sure it's better, but it's worth learning in any case
21:29:56 <gzl> no
21:30:08 <LinkMasterSab> Foo is a type class, right?
21:30:11 <gzl> yes
21:30:17 * LinkMasterSab is a n00b too :D
21:30:32 <gzl> for example:
21:30:35 <gzl> @type (+)
21:30:51 <gzl> oh, the bot isn't here :)
21:31:07 <gzl> anyway, it's (+) :: Num a => a -> a -> a
21:31:28 <gzl> which means that it works on variables of any type as long as that type is an instance of Num
21:32:19 <MachinShin> that sentence doesn't parse to me. first you're saying it can be of *any* type, then you're saying it has to be the Num type?
21:32:37 <gzl> Num is a type *class*
21:32:39 <LinkMasterSab> Num isn't a type, it's a type class
21:32:52 <MachinShin> oh!!! it's a meta-type.
21:33:29 <gzl> you can think of it sort of as an interface that types can implement
21:33:39 <MachinShin> right. right.
21:33:55 <gzl> if you've seen any Java or similar languages
21:34:20 <gzl> "metatype" is not a good word, because there actually is a notion of "types of types" that has a different name
21:34:36 <gzl> and is not quite the same idea as this one
21:35:23 <MachinShin> ok. i'm gonna go back to the tutorial cause you're going beyond what i've learnt so far and it's starting to confuzzle me :)
21:36:02 <gzl> sorry
21:36:08 <MachinShin> np ;)
21:36:18 <MachinShin> happens all the time . i do the same sometimes in #c++
21:36:30 <gzl> seems to be section 5 in haskell.org/tutorial/, if that's the one you mean
21:36:43 <MachinShin> i'm only in section3 so far..
21:37:05 <gzl> makes sense, given your original question
21:37:39 <gzl> hm, they don't really seem to explain what currying is
21:37:42 <MachinShin> just noticed another thing. the next line in (++) is   [] ++ ys = ys  .  why isn't there any ys ++ []  there?
21:37:46 <MachinShin> gzl: no. :/
21:38:27 <gzl> it doesn't matter if the second argument is [] since the cases they have already take care of it
21:38:57 <gzl> the case (x:xs) ++ ys assumes that the first list has at least one element
21:38:57 <MachinShin> ah. so it knows that either side can be [] from parsing that line?
21:39:08 <gzl> if you just have 'ys', it can be empty and there's no problem
21:39:55 <gzl> yes, it knows
21:40:02 <gzl> this will probably become more clear when they discuss pattern matching
21:40:07 <gzl> which seems to be section 4
21:40:12 <MachinShin> k. thanks
21:41:00 <gzl> i can tell you what currying is, if you like, but it may or may not interest you
21:41:50 <MachinShin> from what i can gather it's storing a function with fewer than the required params then 'completing' the call at a later point. yes?
21:42:17 <MachinShin> so like -->  foo = add 1  <.. later ..>  print foo 2 -prints -> 3
21:42:41 <MachinShin> assuming  add :: int -> int -> int
21:43:00 <gzl> no
21:43:09 <gzl> er, not exactly.
21:43:33 <gzl> currying is a way of turning a function with multiple arguments into a function that takes a single argument
21:43:52 <gzl> what you do is that you make the function take the first argument and return a *function* that takes the remaining arguments
21:44:25 <gzl> this is how partial application works
21:44:35 <MachinShin> ah.
21:44:53 <gzl> so when they write that add is equivalent to \x -> \y -> x + y, this is what they mean
21:45:16 <MachinShin> hmmm.
21:45:24 <gzl> it's a function that, given a value for x, returns a function that, given a value for y, returns x + y. so if you just give it the first argument (say 5), you end up with a function \y -> 5 + y
21:48:20 <gzl> see? :)
21:50:26 <MachinShin> i think so
22:15:38 <autrijus> is IORef FiniteMap much slower than, say, HashTable?
22:32:52 <autrijus> is there a way to do IO in Parsec?
22:33:07 <autrijus> aside from the obvious unsafePerform
22:34:17 <autrijus> maybe what I want is a STRef.
22:39:31 <autrijus> bbl, fixing laptop &
22:55:19 <cm> \o/
22:55:46 * cm enjoys the poetry at the beginning of each Pugs source file
23:12:39 <Lemmih> autrijus: Parsec has support for a user defined state.
23:40:29 <musasabi> morning
23:40:35 <cm> herro
23:41:44 <autrijus> Lemmih: but I need to run IO.
23:42:26 <autrijus> what I really want is ParsecT
23:42:35 <autrijus> or port parsec to StateT.
23:42:50 <autrijus> anyone aware of such a beast?
23:42:54 <Lemmih> Wouldn't that be kinda evil?
23:43:29 <autrijus> Lemmih: perl6 needs shift/reset inside the rule (parser) engine.
23:43:47 <autrijus> evil it may be, that is the spec.
23:44:09 <autrijus> (ours is not to ask why...)
23:45:13 <Lemmih> What about making two runs.
23:45:14 <cm> would it be useful to have a Haskell library for YAML serialization?
23:45:53 <Lemmih> cm: What's YAML?
23:46:09 <cm> yaml.org -- "YAML Ain't Markup Language"
23:46:33 <cm> "data serialization format"
23:47:15 <Lemmih> autrijus: Kinda like infix functions are handled in GHC.
23:49:00 <Lemmih> cm: Sure, why not.
23:49:27 <MachinShin> blah.i keep trying to type some of this code from the haskell tuts in ghci, and it keeps giving me a parse error >:(
23:50:02 <MachinShin> *annoying*
23:50:09 <Lemmih> MachinShin: Following the tutorial exactly is very important.
23:51:22 <cm> herro MachinShin from #flipcode :)
23:51:40 <Lemmih> MachinShin: Declarations go in a file which is then loaded into the interpreter where expression can be queried.
23:51:54 <MachinShin> hey cm
23:52:36 <MachinShin> oh. i can't do this in ghci -->  fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]   (straight from tutorial)
23:53:03 <Lemmih> MachinShin: That's a function declaration. Put it in a file and load it.
23:53:42 <MachinShin> blerfgh.
23:53:43 <MachinShin> k
23:53:54 <cm> MachinShin: "load it" as in :l <filename>. use :r to reload any loaded files (modules).
23:54:21 <cm> especially with :r it is a very convenient way of programming, IMO
23:55:16 <MachinShin> right. annoying that i can't just type code into the interpreter.
23:55:19 <MachinShin> *shrugs*.
23:55:31 <Lemmih> MachinShin: Just use emacs.
23:55:59 <cm> you will see that you are able to do so after studying the GHCi handbook.. but really, due to the nature of Haskell it makes more sense to keep definitions in source files
23:56:19 <cm> you would define "fib" using this syntax in GHCi:
23:56:25 <cm> let fib = ...
23:57:11 <MachinShin> ewwwwh. emacs
23:57:19 <Lemmih> MachinShin: What are you reading?
23:57:27 <MachinShin> http://www.haskell.org/tutorial/functions.html
23:57:31 <cm> Prelude> let fib = 1 : 1 : zipWith (+) fib (tail fib)
23:57:31 <cm> Prelude> take 5 fib
23:57:31 <cm> [1,1,2,3,5]
23:57:55 <MachinShin> ah. i can use let. that's sufficient. i just wanna be able to type the code in the tut as i read it.
23:58:24 * LinkMasterSab found Yet Another Haskell Tutorial to be much better than Gentle Intro
23:58:54 <cm> I believe in the combined power of gvim and :r ;-)
23:59:02 <MachinShin> hehe
23:59:17 <Lemmih> LinkMasterSab: They each serve a different purpose.
23:59:42 <MachinShin> cm: if i were really writing code absolutley. but reading a tut and following along is easier if you dont' have to do a multi-step process.
