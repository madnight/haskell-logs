00:56:13 <boegel> hey #haskell
00:57:17 <autrijus> greetings..
00:57:57 <boegel> @seen shapr
00:57:58 <lambdabot> I saw shapr leaving #haskell.se 7 hours 51 minutes 24 seconds ago.
00:58:24 <boegel> hmm, someone should adjust the topic and add the TMR wiki page in it
01:00:05 <Lemmih> TMR wiki?
01:00:13 <boegel> TheMonadReader
01:00:18 <boegel> @wiki TheMonadReader
01:00:18 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
01:00:34 <Itkovian> eh?
01:01:00 <Itkovian> oops sorry, I was reading at the top of my IRC screen ... about a chick and push-ups ... weird stuff 
01:01:38 <boegel> eh ? :)
01:04:03 <Lemmih> Woot. Generated 10kloc with Hacanon (:
01:04:44 <autrijus> 10kloc of whitespaces? :)
01:05:20 <Lemmih> 5696 lines of Haskell and 4343 lines of C++.
01:20:44 <Lemmih> http://www.scannedinavian.org/repos/hclanlib/webpage/gfx/ss[12].png for interested souls.
01:21:30 <boegel> Lemmih, not found ?
01:21:46 <Lemmih> [12] means '1' and '2'
01:22:04 <boegel> oh sorry :)
01:22:23 <boegel> what is it ? :)
01:22:55 <Lemmih> ClanLib binding written completely without touching the FFI.
01:23:05 <boegel> nice
01:27:33 <Lemmih> You just name the classes you wanna use and Hacanon takes care of dependencies, marshalling and overloading.
01:41:52 <pesco_> Yeah, goodbye pesco. I hate you anyway. Don't even think about coming back or I'll freakin' rip your rotten guts out.
01:42:01 * pesco_ shakes his fist at pesco.
02:05:42 <boegel> pesco: temper temper :p
02:09:25 <pesco> boegel: Sorry. :|
02:09:26 <pesco>  ;)
02:48:13 * boegel coughs
02:48:23 * Itkovian finds his cheese to be very runny ... ans sticky
02:48:43 * boegel pets his cat
03:06:25 <boegel> could anyone add the TMR wiki page in the topic ? I'm using mIRC (Windoze) right now, and I can't find how I can adjust the topic...
03:10:15 --- topic: set to '["Learning Haskell - http://www.haskell.org/learning.html","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - ICFP contest 2004","We put the Funk in Funktion","The people here like donuts", Haskell zine: http://www.haskell.org/hawiki/TheMonadReader]' by Itkovian
03:10:16 --- topic: set to '["Learning Haskell - http://haskell.org/learning.html","See logs @ http://meme.b9.com/cdates.html?channel=haskell","related channels #haskell.se #haskelldb #darcs","Haskell eZine! http://haskell.org/hawiki/TheMonadReader","http://haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - ICFP contest 2004","We put the Funk in Funktion","The people here like donuts"]' by pesco
03:10:22 <pesco> bwaah
03:10:26 <Itkovian> ouch sorry
03:10:30 <pesco> ;-)
03:11:13 <Itkovian> well, I forgot the " anyway ..
03:11:42 <pesco> :) OK.
03:41:44 <jlouis> I love trying to grok System-F, fundeps, existential types and more ... ;)
03:44:24 * autrijus is starting to read ATTaPL :)
03:47:05 <pesco> ATTaPL?
03:49:02 <autrijus> http://www.cis.upenn.edu/~bcpierce/attapl/index.html
03:49:21 <pesco> coo
03:49:28 <Itkovian> l?
03:49:31 <pesco> l.
03:54:07 <pesco> That's an awesome cover picture. I desperately need to finish "the brick".
04:20:28 <Itkovian> 'Eddies,' said Ford, 'in the space-time continuum." ... 'Ah,' nodded Arthur, 'is he? Is he?'
04:20:30 <Itkovian> hehe
04:20:38 * Itkovian is bored
04:24:34 * Itkovian is very bored
04:25:12 <autrijus> try counting sheeps with church numbers
04:38:41 <Lemmih> Itkovian: Being bored is a luxury you should enjoy.
04:39:47 <Itkovian> Hah!
04:40:11 <Itkovian> It's a luxury I can't afford. I've got a load of stuff to do, but the chore I'm doing right now is extremely borig ...
04:40:21 <Itkovian> s/borig/boring/
04:40:35 <autrijus> <shapr>take some ritalin!</shapr>
04:41:27 <Itkovian> :-)
04:41:49 <Itkovian> let's put up some music ...
04:42:10 <Itkovian> Umbra et Imago will do just fine :-)
04:42:49 <boegel> Itkovian: which chore ?
04:46:42 <Itkovian> writing a report on a bloody meeting
04:46:52 <Itkovian> yuk
04:47:12 * Itkovian would rather prepare his lessons for the next semester ... 
04:47:14 <boegel> a _bloddy_ meeting ? sounds interesting :)
04:47:27 * boegel would like to see Itkovian's preparations
04:47:33 <Itkovian> yeah yeah ...
04:47:35 <Itkovian> :-)
04:47:37 <boegel> :p
04:47:41 <Itkovian> next year, when you graduate :-)
04:47:50 <Itkovian> well, have graduated
04:47:53 <boegel> I will only get to see them then ?
04:48:12 <Itkovian> dunno ... I am certainly not going to show any of the project stuff.,
04:48:39 <boegel> I'm not asking you to :)
04:48:56 <boegel> I would like to see you lesson slides an stuff like that too
04:49:18 <boegel> I know you don't trust me :p and you shouldn't too :)
04:49:56 <Itkovian> haha
04:50:02 <Itkovian> I don;t trust any student ...
04:50:05 <Itkovian> lol
04:50:13 <Itkovian> I'd like to keep my job
04:50:22 <boegel> nah, I wouldn't show any student projects either
04:51:33 <boegel> I suggest you use a game of some sort for the project
04:51:39 <boegel> that always more fun to solve
04:51:46 <boegel> from a students point of view :p
04:54:51 <timbod> I've got a moderately complex program using arrays. It's falling over with the not particularly helpful "Fail: Error in array index". Any tips on what precondition for what function I have failed, and ideally, some means of locating the erroneous call? (this is under ghc)
04:55:15 <Itkovian> oh, they'll get a game.
04:55:17 <Itkovian> of some sort
04:56:33 <boegel> then I'm ok with it :)
04:56:41 <boegel> 1 or 2 project(s) ?
05:03:50 <musasabi> timbod: -xc ?
05:04:45 <musasabi> "for GHC compile with -prof -auto-all, then add +RTS -xc -RTS when running to get a "stack" trace when an exception is thrown." (from hawiki TipsAndTricks)
05:04:47 <Itkovian> 2
05:05:42 <timbod> thanks musasabi, I just got there: perusing the ghc doco, -prof -auto-all at compile time, in combination with +RTS -xc at run time looks like it ought to help, but not really. Now all I get is:'<GHC.Arr.CAF>\nFail: Error in array index'
05:05:56 <timbod> is <GHC.Arr.CAF> mean to be a stack trace??
05:08:13 <timbod> an attribution to the CAF in the array module doesn't help me much at all.
05:09:42 <musasabi> true.
05:10:00 * musasabi is at the uni, so no easy testing of things.
05:16:27 <Lemmih> @seen shapr
05:16:27 <lambdabot> I saw shapr leaving #haskell.se 12 hours 9 minutes 54 seconds ago.
05:17:48 <boegel> Lemmih: do you find it strange to he isn't here ? :)
05:17:56 <boegel> he's _always_ here :p
05:20:37 <Lemmih> He must be low on funds.
05:21:08 <boegel> is bandwidth that expensive in sweden ? (or where does he live ? finland ?)
05:21:45 <Lemmih> boegel: He also got a girlfriend to feed.
05:22:33 <ozone> sweden
05:22:50 <Lemmih> Hey ozone.
05:22:51 <boegel> Lemmih: I know there more to life than bandwidth, but here you have a fixed price each month, so I don't see the problem...
05:22:54 <ozone> Lemmih: maybe by funds, you mean "brownie points with gf" ;)
05:24:18 <ozone> hey lemmih, hanacon going well?
05:24:23 <Lemmih> ozone: I'm about to add transparent handling of callbacks (aka function pointers) to Hacanon.
05:24:52 <ozone> cool!
05:25:01 <ozone> sounds like your hanacon hacking is going very well, then
05:25:43 <Lemmih> I also hacked up a little webpage for HClanLib/hacanon at http://www.scannedinavian.org/repos/hclanlib/webpage/
05:26:57 <ozone> micro machines ii
05:27:01 <ozone> i see a man with good taste!
05:27:06 <ozone> or woman
05:27:09 <ozone> or, alien
05:27:11 <ozone> or whatever :)
05:27:42 <ozone> nice page, too
05:28:01 <Lemmih> I stole it from clanlib.org /-:
05:28:26 <ozone> s/i stole it/the design was inspired/ ;)
05:28:29 <Lemmih> I've really stolen a lot of things lately.
05:28:56 <ozone> wow
05:29:11 <ozone> my old hoc page actually doesn't look like total crap
05:29:26 <ozone> always nice when you re-visit a webpage after about 6 months and still find that it looks nice
05:29:27 <Lemmih> You're the author of hoc?
05:29:38 <ozone> Lemmih: heh, not really
05:29:41 <timbod> FWIW, I found my problem, by guesswork and the use of Debug.Trace.  A better debugging technique would be nice.
05:29:42 <ozone> wolfgang thaller is the primary author
05:30:00 <ozone> though i guess we both worked on it and did the design together
05:30:42 <ozone> Lemmih: http://hoc.sourceforge.net/documentation.html#history
05:32:36 <Lemmih> Ah yes. You're Andre Pang!
05:32:49 <ozone> that'd be me ...
05:33:07 * Lemmih is really bad with non-IRC handles.
05:33:21 <ozone> heh, i should just rename my irc handle to andre
05:34:05 <Lemmih> Wow. The webpage is actually really flashy.
05:34:25 <ozone> yeah.  i stole ... err, the design was inspired from mac os x, obviously
05:34:36 <Lemmih> (:
05:34:39 <ozone> amazing what you can do with interface builder, photoshop and screenshots :)
05:36:15 <Lemmih> Fooie. Gotta go to the bank and withdraw some money to pay my rent.
05:36:46 <boegel> Lemmih: you have to go outside ? damn, the horror
05:37:56 <Lemmih> boegel: Yeah. It would almost be considered normal if I didn't ride my unicycle (:
05:38:26 <boegel> Lemmih: :D
05:42:43 * boegel hates quick restoring a pc
05:49:52 <boegel> heu basti_
05:49:57 <boegel> s/heu/hey
05:50:01 <basti_> hi
05:50:05 <basti_> stroh
05:50:05 <basti_> ;)
05:50:17 <boegel> eh ? :)
05:50:25 <basti_> uhm thats a german pun sorry
05:50:43 <basti_> heu = hay, stroh = straw
05:50:47 <boegel> I'm from Belgium, and I hate german :p
05:50:54 <basti_> i see.
05:52:36 <basti_> :)
06:08:50 <musasabi> What is the relation of fptools/libraries/{mtl,monads} ?
06:35:22 <araujo> Good morning Haskell hackers.
06:35:47 <CosmicRay> hi araujo 
06:35:52 <araujo> Greetings CosmicRay 
06:35:56 <araujo> how are you today?
06:35:58 <boegel> hi araujo
06:36:01 <CosmicRay> doing well
06:36:03 <CosmicRay> you?
06:36:09 <araujo> Hello boegel , how you doing?
06:36:19 <araujo> Pretty well, thanks, just get up :-)
06:36:19 <boegel> araujo: ok, could be better
06:36:21 <Lemmih> Greetings, autrijus.
06:36:35 <araujo> boegel, really?, i don't think so ;-)
06:36:35 <boegel> bzzt
06:36:42 <araujo> Greeting Lemmih 
06:37:12 * boegel waves at everyone, because his voice it tired
06:37:25 * araujo handles some apple juice to #haskell
06:37:30 <MegaMonad> Howdy all, im having some more though.
06:37:33 * xerox boings cheerfully to everyone
06:37:44 <boegel> hey xerox
06:37:58 <araujo> Hello xerox 
06:38:32 <CosmicRay> hi, canon
06:38:35 * CosmicRay hides
06:38:42 <araujo> :-)
06:38:43 <xerox> Haskell has to wait today, I have some philosophy to study, hmpf.
06:38:50 <Lemmih> An IDE for Haskell would be neat.
06:38:54 * boegel screams: "There he is xerox ! ! !"
06:39:00 <CosmicRay> xerox: MegaMonad has some insights on Haskell philophy :-)
06:39:02 <CosmicRay> eep!
06:39:20 <araujo> Lemmih, we don't have emacs? 
06:39:20 <araujo> ;-)
06:39:40 <xerox> Lemmih, shae has some screenie of an IDE.. hIDE I think, it also makes graphs of code trough grapwiz
06:39:45 <xerox> *graphwiz, maybe
06:40:02 <Lemmih> xerox: hIDE is pretty outdated, iirc.
06:40:14 <boegel> Lemmih: you something like Eclipse for Java?
06:40:22 <boegel> maybe a Haskell plugin for Eclipse would do ?
06:40:30 <xerox> It missed a there ;)
06:42:50 <Lemmih> boegel: I would like stuff structured editing.
06:42:57 <CosmicRay> @seen shapr
06:42:57 <lambdabot> I saw shapr leaving #haskell.se 13 hours 36 minutes 24 seconds ago.
06:43:13 <boegel> CosmicRay: you're the third one doing that in a few hours time :)
06:43:26 <Lemmih> s/stuff/stuff like/
06:43:32 <CosmicRay> heh
06:43:47 <boegel> Lemmih: Eclipse doens't support that ? and what's wrong with hIDE, besides being out of date ?
06:44:17 <CosmicRay> glad you reminded me
06:45:25 <tintin> who maintains the emacs haskell mode ?
06:45:35 * boegel kicks his eMule
06:45:41 <Lemmih> boegel: I doubt it since it would require a Haskell parser and hIDE is very hard to compile.
06:46:10 <xerox> Okay, later folks.
06:46:16 <boegel> oh okay... then you should start a IDE project :)
06:46:24 <boegel> s/a/an
06:46:58 <tintin> Why another IDE when you got the bet IDE in the world emacs :)
06:47:40 <boegel> tintin: ask Lemmih :p
06:48:16 <Lemmih> tintin: Emacs doesn't support structual editing. Any operations would depend on regex and stuff like type information would not be available.
06:48:59 * Lemmih swears at his flawed English.
06:49:25 <tintin> case dismissed motion denied ... next 
06:50:24 <Lemmih> Next case: Speed of execution vs. speed of development.
06:51:52 <Lemmih> boegel: The guys at chalmers are already working on it.
06:51:54 <tintin> all those infavor of Speed of execution put speak now or forever stay silent 
06:52:59 <boegel> ay
06:53:10 <boegel> speed is always important
06:53:23 <samc> ay
06:53:58 <samc> speed is the main issue
06:54:12 <tintin> Court orders samc and boegel be taken into prison and be made to work with C++ on 286 machines with no internet for 10 years 
06:55:03 <boegel> eek!
06:55:07 <tintin> er i change my mind 
06:55:21 <tintin> /s/C++/asm
06:55:25 <tintin>  /s/C++/asm
06:55:42 <boegel> ekk! eek!
06:58:42 <tintin> Now those in favour of Speed of development be given a hike in their pay by 100% and given the choice of moving to their favorite exotic locales to work on their Haskell projects 
06:59:10 <tintin> Case stands closed unless anyone else wants to join boegel and samc
06:59:51 * boegel aims is sniper rifle at tintin
07:00:35 <tintin> do you want another 10 years with asm ?
07:00:55 * boegel cocks his sniper rifle, and hits the 'on'-button on the laser pointer
07:01:27 <jlouis> now tintin looks like one of those girls from india
07:01:54 <boegel> jlouis: right, exactly between the eyes :D
07:02:02 <tintin> take that man away and put him behind bars for the rest of his natural lives :)
07:02:16 <tintin> /s/lives/life
07:02:20 <tintin>  /s/lives/life
07:02:21 * boegel zooms in on tintin's right eye
07:02:46 <jlouis> I am reading on the STG-machine. Is there any papers there are interesting beside that one?
07:02:49 * autrijus zooms in on snowy
07:02:52 * tintin picks up his bazooka and vaporises boegel 
07:03:49 <tintin> autrijus: you can have him he is too old and he can hardly walk these days ....
07:03:53 * boegel watches the pieces melt together and form 2 seperate boegel's
07:03:54 <jlouis> oh, the GTA-game instead of the STG-machine
07:05:11 * tintin pours some liquid helium over boegel prepared via a super secret scientific research project 
07:05:25 * boegel drinks it
07:05:26 <boegel> :D
07:05:55 * tintin watches as boegel breaks down into non mobile atoms ....
07:06:24 * boegel screams: "Atoms, attack !"
07:07:15 <samc> those in favour of dev speed should be forced to wait for a trivial exponential time algorithm to finish, for a problem for which a simple polynomial time algorithm exists
07:07:16 * tintin collects boegel's atoms and puts them into a 0kelvin refrigerator and ships him far far away ... into the vast expanses of the universe 
07:07:39 <boegel> ... where I can find some help from aliens
07:09:35 <tintin> boegel: but thats on the next weeks show :)
07:10:30 <innocentalien> hmm I wonder whats in this fridge...
07:10:44 * innocentalien opens fridge AAARGH!
07:11:05 * _boegel_ laughs: mwoehahahaha
07:11:06 <Lemmih> Time to upgrade your food?
07:11:32 <tintin> be sure to tune in next week to know the fate of the boegel and his encounter with the asm creatures .....
07:12:32 <_boegel_> authographs available at 10$ each
07:12:39 <_boegel_> s/10$/$10
07:13:08 <jlouis> _boegel_: mushroom$ sed -e 's/10$/$10'
07:13:08 <jlouis> sed: 1: "s/10$/$10
07:13:08 <jlouis> ": unescaped newline inside substitute pattern
07:13:13 <jlouis> ;P
07:13:22 <jlouis> and yes miss and ending /
07:13:29 <jlouis> s/yes/you/; hehe
07:13:41 <tintin> lol
07:13:50 <_boegel_> s/10\$/\$10/
07:13:54 <jlouis> s/yes/you/; s/and/an/; even
07:14:21 <tintin> jlouis: educate a comedian and you make him lose his job :)
07:38:00 * basti_ gets a LaTeX crisi
07:38:00 <basti_> s
08:00:12 <Itkovian> i'm off
08:10:36 <CosmicRay> is there any way, other than a foreign ptr, to cause something to be run when an object is garbage collected?
08:13:59 <marco82> hi !
08:15:31 <marco82> Can anyone help me by using that IO Monad.. I would like to use input from stdin as argument for functions, but I do not have any idea, how to do that....
08:16:40 <marco82> For example, I want to use the replicate function, which takes two argruments. The Int-value shoulg be got from stdin.
08:19:36 <basti_> marco82: well you'd need to convert what you got from stdin.
08:19:48 <basti_> typewise and semantics-wise, as you would probably get a String.
08:21:27 <TheHunter> marco82, use do notation: main = do str <- getLine; print (foo str)
08:21:41 <TheHunter> in simple cases, interact will do
08:21:46 <TheHunter> @type interact
08:21:47 <lambdabot> interact :: (String -> String) -> IO ()
08:22:06 <basti_> i think his problem is that the function expects an int
08:22:10 <basti_> (Int)
08:22:23 <marco82> I tries String parsing with "read"
08:22:44 <basti_> marco82: you seem to be on the right way.
08:23:28 <marco82> The problem is always, that i cannot get an Int from IO Int
08:23:54 <basti_> oh that sounds like an io monad problem yes.
08:23:56 <TheHunter> @wiki ThatAnnoyingIOType
08:23:56 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIOType
08:24:56 <TheHunter> hmm, that page is confusing. It should say "You can't do it" right at the beginning.
08:29:12 <humasect> heh
08:29:30 <basti_> -g-
08:30:36 <marco82> hm. It is not possible to get Ints from IO Ints ? Did I understand right ?
08:30:51 <marco82> I have to write functions using IO Ints ?
08:31:43 <basti_> kinda.
08:31:44 <TheHunter> marco82, you should use do notation as the first example suggests.
08:31:54 <basti_> you dont need to care about the "IO" thing really.
08:32:32 <TheHunter> main = do str <- getLine; let number = read str; print (replicate number ...)
08:36:30 <marco82> I would like to do something like this :main=getLine >>= \x -> return . sequence $ replicate read(x) fct
08:36:34 <marco82> But that does not work
08:36:58 <marco82> I would like to have "fct" "x" time executed.
08:38:24 <Lemmih> replicate (read x) fct?
08:38:35 <marco82> fct is my own function
08:38:47 <marco82> oh; I need brackets ?
08:39:34 <Lemmih> 'main' should have the type :: IO ()
08:40:00 <Lemmih> marco82: Is 'fct' an IO action?
08:40:08 <TheHunter> marco82, i think operator precendences are getting in your way. Try
08:40:10 <TheHunter> main = do
08:40:14 <TheHunter>   x <- getLine
08:41:00 <TheHunter>   let foo = replicate (read x) fct
08:41:08 <marco82> fct is IO. It should do the output
08:41:14 <TheHunter>   sequennce_ fct
08:41:21 <TheHunter> err, sequence_ foo
08:41:49 <TheHunter> (you could also use replicateM_ (read x) fct)
08:46:14 <CosmicRay> is there any way to have the rts dump the stack when I get a stack overflow?
08:48:15 <Igloo> You can compile with profiling and use -xc
08:48:21 <Igloo> +RTS -xc, that is
08:48:34 <CosmicRay> that requires all my libraries to also be compiled with profiling, though, right?
08:48:38 <CosmicRay> or just the one I'm doing?
08:48:40 <Igloo> Which may or may not be the info you want
08:48:53 <Igloo> Everything, AFAIK
09:01:33 * boegel leaves
09:01:33 <boegel> bye
09:03:24 <TheHunter> has anyone got insider information when ghc 6.4 will be released?
09:04:46 <Lemmih> Around February.
09:05:21 <TheHunter> i was kinda hoping that it's only a matter of days, now.
09:05:24 <Lemmih> But they said the same thing three months ago. (:
09:39:16 <CosmicRay> w00t. bzip2 working.
09:41:07 <Nioate> w00t
09:41:38 * CosmicRay AFKs for lunch
10:02:45 <derelm> hi, i am to determin the "degree" of a non binary-tree data-structure and i am stuck, i do even miss a idea, can anyone help?
10:03:22 <derelm> btw, my tree is like this : data NBaum a = Blatt a | Knoten a [NBaum a]
10:04:20 <derelm> i started using pattern matching, so degree (Blatt x) = 1 ... but i don't know how to handle the other case yet
10:41:00 <Philippa> is there a standard extension for a haskell file that needs running through cpp?
10:43:42 <Igloo> You can put -cpp in an OPTIONS pragma
10:44:03 <Igloo> Although that might be deprecated WRT OPTION_$impl, I'm not sure
10:44:23 <tromp> not according to http://www.haskell.org/ghc/docs/latest/html/users_guide/file-suffixes.html, Philippa
11:37:20 <Heffalump> why does the Haskell RTS use SIGVTALRM?
11:37:45 <pesco> How does it use it?
11:38:13 <Heffalump> repeatedly ;-)
11:38:18 <Heffalump> try stracing a ghc compiled program.
11:38:23 <Heffalump> and I meant GHC above, not Haskell, of course.
11:38:30 <pesco> Oh. I see. :)
11:38:53 <Heffalump> I'm trying to use SIGALRM to guarantee that some code can't run forever, and it's being odd.
11:39:07 <Heffalump> And I'm wondering if the two are fighting or something
11:39:51 <Igloo> I think the recommended way to do that would be to start a Haskell thread and kill it if it takes too long
11:39:57 <Igloo> by threadDelaying in the watcher
11:41:02 <pesco> I don't think SIGALRM and SIGVTALRM should interfere. Unless your platform defines them equal of course ;p
11:43:21 <Heffalump> tried that
11:43:29 <Heffalump> the problem is that let loop = loop in loop doesn't allocate memory.
11:43:49 <Igloo> Oh, you mean a thread switch never happens?
11:43:53 <Heffalump> so pre-emption never kicks in, and I think black-hole detection gets turned off if you have multiple threads or something.
11:43:56 <Heffalump> right.
11:47:50 <stepcut> Xnest rocks
11:48:39 <Heffalump> but cut and paste doesn't work with it, sadly
11:48:55 <Heffalump> (i.e. you the selection doesn't propagate into/out of it)
11:48:59 <Igloo> Have you got some code to reproduce that?
11:49:04 <Igloo> The obvoius thing doesn't work for me
11:49:07 <Heffalump> oh.
11:49:09 <Heffalump> errm.
11:49:18 <Heffalump> I was loading the let loop = loop in loop with hs-plugins
11:49:31 <Igloo> Ah
11:49:56 <Igloo> How many RTSs does that give you?
11:50:10 <Heffalump> only one, I thought. BICBW..
11:51:13 <Igloo> Do you have a print after the threadDelay so you can be sure it hasn't returned?
11:52:37 <Heffalump> I did, yes
11:52:47 <xerox> hi
11:53:11 <pesco> Greetings xerox, what's up?
11:53:30 <xerox> Studying philosophy all the day long, more or less, hmpf
11:53:36 <pesco> Interesting.
11:53:53 <pesco> Are you majoring in Philosophy?
11:54:07 <xerox> No, high school.
11:54:14 <pesco> oic
11:54:28 <xerox> I mainly put twenty or so pages of notes in an understandable TeX form.. not so much fun.
11:54:39 <pesco> Sounds tiresome.
11:54:40 <xerox> And in fact, I have to finish.. YAWN.
11:55:06 <Heffalump> does ghci have two RTSes?
11:55:21 <xerox> I also have a film about the guy we're studying, it is a good one, it helped somewhere.
11:55:45 <Igloo> I don't think so
12:00:56 <Heffalump> do RTSes have some kind of unique ID I can get at?
12:36:29 * boegel waves
12:36:54 <boegel> duncan: have you heard about hs-fltk ?
12:37:23 <duncan> boegel: yes, I've been taking to its author about building a common medium level API
12:37:52 <boegel> duncan: have you ever tried it ?
12:38:37 <duncan> boegel: I've looked over the code in some detail but never actually run it :-)
12:39:12 <boegel> duncan: someone suggested it to me as an alternative to gtk2hs
12:39:19 <boegel> because it works with Windoze to
12:39:22 <boegel> +o
12:40:01 <duncan> boegel: yes hs-fltk, wxHaskell and gtk2hs work on unix, win23 and mac
12:41:36 <boegel> duncan: you told me yesterday gtk2hs doesn't work yet on win32 ?
12:41:43 <CosmicRay> Is there any way with "read" to get it to parse what it can, and return what it's parsed and the remaining unparsed data in the string?
12:43:35 <duncan> boegel: the latest release has not been tested on win32 but the previous release worked and there shouldn't be too many problems, we ma even do an intrim release of 0.9.7 for win32 since there seems to be quite a bit of interest
12:43:59 <boegel> duncan: any idea when that will be ?
12:44:35 <duncan> boegel: I'll ask the other gtk2hs devs
12:46:17 <boegel> duncan: okay
12:55:14 <Heffalump> cosmicray: the actual implementation of the Read class does precisely that
13:07:56 <boegel> I'll be back *evillaugh
13:18:02 * boegel got his sound working again in Fedora and cheers !
13:34:19 <Heffalump> igloo: you there?
13:34:39 <Heffalump> does your test case still work if you do let loop 0 = loop 0 in loop 0 ?
13:35:05 <Heffalump> I think let loop = loop in loop was throwing an exception thanks to the black-hole detector which killed off the forked thread
13:40:45 <jlouis> I am quite sure Simon P. J. is close to god
13:41:05 <jlouis> and if not, at least he has as much homour as Phil Wadler
13:45:56 <derelm> i have a n-tree (possibly more than 2 children per parent) and i need to return the max number of children a parent has in that tree ...
13:47:56 <derelm> can someone please give me a hint how to do that?
13:48:32 <boegel> derelm: how is your tree structured ? we need to know some more I believe...
13:48:47 <derelm> data NBaum a = Blatt a | Knoten a [NBaum a] 
13:49:43 <boegel> derelm: with childer, do you mean _direct_ children, are do you consider sub children to be children also ?
13:50:00 <derelm> no, direct children matter
13:50:16 <derelm> i mean: only direct children do matter
13:50:43 <boegel> does the data line you specified allow multiple children ?
13:50:48 <derelm> yes
13:50:59 <derelm> Knote a [NBaum a]
13:51:00 <boegel> oh right, the [NBaum a] part
13:51:02 <boegel> sorry :)
13:51:05 <derelm> ;)
13:51:06 <boegel> my mistake
13:51:27 <boegel> well, I guess you need a function first to determine the number of children of a parent
13:51:41 <derelm> so my thought was, basically to find the max of the list part, and that in a recursive waay
13:51:55 <boegel> brb
13:52:32 <derelm> that's what i tried, but that didn't work: degree (Blatt x) = 1; degree (Knoten x liste) = 1 + max $ map (degree) liste
13:53:21 <derelm> so i basically do a pattern matching to see if the given tree is a leaf (only holds a value) or if it has children
13:53:41 <derelm> if it has children, i can access them through the list "liste"
13:53:55 <stepcut> so, I need a way to make kopete forward IMs to quake...
13:54:39 <jlouis> derelm: I am not sure I understand your problem
13:55:03 <jlouis> what did not work in the last part?
13:55:56 <derelm> jlouis: i need to find the maximum number of children a "node" (don't know the english word) hase
13:56:02 <boegel> derelm: shouldn't it be like this: degree (Knoten x liste) = length liste
13:56:25 <jlouis> boegel: that is what I am thinking too
13:56:43 <derelm> boegel: but what if one of my children itself has children (more than in the first level)
13:56:47 <jlouis> derelm: node could be used in a tree. If you regard it generally as a graph, it is a Vertex
13:57:00 <boegel> derelm: then you're not talking about direct children
13:57:21 <jlouis> Dynamic programming?
13:57:25 <jlouis> on the max
13:57:43 <derelm> yes i do, i don't want to get the number of children the toplevel has, i want to get the maximum number of children (a single node has) in the whole tree
13:58:24 <jlouis> So you want to do what? Count the number of nodes in the tree included leaf nodes?
13:58:35 <jlouis> or a particular subtree thereof
13:59:10 <derelm> hmm...
13:59:18 <boegel> derelm: I see
13:59:19 <derelm> i'll give an example
13:59:35 <derelm> a is the topmost node (like the parent)
13:59:41 <boegel> I was suggesting to build a function first who returns just the number off children for a knot (or leaf)
13:59:54 <boegel> and then use that function in a max function for the tree
13:59:55 <derelm> a has 3 children , b, c and d
14:00:25 <derelm> b itself has 4 children (all of these are leafs)
14:00:32 <derelm> c itself is a leaf
14:01:02 <derelm> d has 1 child node f, f has one child node g and g itself is a leaf
14:01:13 <boegel> so your max is 4, right ?
14:01:16 <derelm> yes
14:01:37 <boegel> @type max
14:01:38 <lambdabot> max :: forall a. (Ord a) => a -> a -> a
14:01:54 <boegel> here's your problem
14:01:58 <derelm> ?
14:02:06 <jlouis> it only takes 2 arguments
14:02:10 <boegel> max is a function which compares just two values, and returns the max value
14:02:21 <derelm> ah
14:02:22 <boegel> I'm not sure if a max function exists for lists
14:02:23 <derelm> dammit
14:02:25 <duncan> @type maximum
14:02:26 <lambdabot> maximum :: forall a. (Ord a) => [a] -> a
14:02:31 <jlouis> haha
14:02:32 <boegel> there you go :)
14:02:34 <boegel> try that
14:02:34 <derelm> ;)
14:02:43 <jlouis> this is Haskell, so everything has it's own function ;)
14:02:45 <derelm> ok, i'll try to replace my max with maximum
14:02:47 <boegel> but then you shouldn't do 1+max if I'm correct
14:02:57 <boegel> but just max
14:03:02 <jlouis> @type foldl
14:03:03 <lambdabot> foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
14:03:20 <Igloo> Heff: It doesn't work
14:03:42 <Igloo> (it's  import Control.Concurrent; main = do t <- forkIO (let loop 0 = loop 0 in loop 0); putStrLn "Q1"; putStrLn "Q2"; putStrLn "Q3"; threadDelay 1000000; putStrLn "Foo"; killThread t; putStrLn "Bar"  )
14:04:20 <boegel> jlouis: 'foldl max 1 (map (degree) liste)' should work too, right ?
14:04:28 <boegel> @type foldr
14:04:29 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
14:04:50 <boegel> or should it be foldr ?
14:04:52 * boegel thinks
14:05:09 <derelm> hmm. i do have a problem
14:05:10 <duncan> boegel: but wont that return the max degree rather than the node with max degree (or was that what was required?)
14:05:46 <jlouis> boegel: no, try applying that to the empty list
14:05:53 <jlouis> it returns 1 which is wrong
14:06:00 <jlouis> or counter-intuitive at least
14:06:26 <derelm> it allways returns 1
14:06:52 <boegel> duncan, 'degree' is supposed to return the _max degree_ of a parent, right ?
14:07:08 <derelm> boegel: yes
14:07:21 <boegel> s/duncan/derelm
14:07:23 <derelm> boegel: in my example that is 4
14:07:27 <boegel> so why use 1+ ?
14:07:41 <derelm> because nodes also count, not only leafs
14:07:51 <duncan> boegel: right, so do we want the max degree or the node with the max degree?
14:08:08 <derelm> duncan: the max degree
14:08:10 <boegel> b has 4 children, so you should just return the length of the list (being 4)
14:08:14 <boegel> why do the +1 ?
14:08:29 <duncan> boegel: ah
14:08:29 <jlouis> @type liftM_
14:08:30 <lambdabot> bzzt
14:08:37 <boegel> if you do +1, you'll get 5, right ?
14:08:44 <derelm> well, if b had a fifth child, actually a node having a simple child for example it would cout five
14:08:49 <derelm> bzw it should
14:09:07 <boegel> derelm: but then the list would contain 5 elements, not 4, right ?
14:09:19 <derelm> hmm, yes you're right
14:09:22 <derelm> my fault ;)
14:09:32 <boegel> just making sure you understand why :)
14:09:45 <derelm> yes, but right now, i am only getting 1
14:10:09 <derelm> ...as return value
14:10:38 <boegel> yeah, that's why I think you need a seperate function
14:10:48 <boegel> no you just run down the tree until you get a leaf
14:11:05 <boegel> you keep mapping 'degree' onto nodes
14:11:16 <boegel> only when you have a leaf, you'll get a real value
14:11:56 <derelm> boegel: i had the assumption that every tree stomps at a leave, sometime
14:12:04 <derelm> stops
14:12:10 <boegel> derelm: that' true
14:12:30 <derelm> hmm, ok, but my start might be wrong...
14:12:35 <boegel> but when you get to a knot, you don't count it's children...
14:12:48 <duncan> I din't think I understand the difficulty, don't we just traverse the whole tree, return a list of all nodes, map outregree and take the maximum. outdegree Leaf = 0
14:13:45 <derelm> duncan: i'm not sure i understood that ... thinking about it
14:14:05 <boegel> degree (Blatt x) = 1; degree (Knoten x liste) = max((length liste), (maximum $ map (degree) liste) )
14:14:23 <boegel> maybe this is more like it ? test it, and tell me what it returns
14:14:35 <duncan> maximum (map outdegree (traverse tree))
14:14:55 <derelm> Occurs check: cannot construct the infinite type:
14:14:57 <boegel> duncan: what does traverse do then ? map the tree into a list ?
14:15:06 <duncan> boegel: yes
14:15:18 <boegel> duncan: is that really necessary ?
14:15:49 <duncan> boegel: no, it just easy that way and more compositional (and lazy)
14:15:55 <boegel> derelm: how did you define the type of 'degree' ?
14:16:10 <duncan> outdegree :: Tree a -> Int
14:16:11 <boegel> duncan: won't it be slower ?
14:16:23 <derelm> i didn't define it, but i am to define it as degree :: NBaum a -> Integer
14:16:32 <boegel> try Int
14:16:54 <derelm> Couldn't match `Int' against `a -> a'
14:17:09 <duncan> boegel: speed isn't everything :-)  it isn't necessarily slower if the compiler can do list fusion.
14:17:51 <boegel> duncan: I'm not sure why your version should be better... but then again, I probably don't know enough about Haskell to get it :)
14:17:52 <jlouis> newtype StateT s m a = StateT { runStateT :: s -> m (a, s) } <--- what does the following line do? It builds a new type StateT with type arguments s m and a. But what does the right hand side mean?
14:18:10 <duncan> boegel: traverse is a 'good producer' and maximum is a 'good consumer', it can be fused so that no intermediate list is produced.
14:18:21 <jlouis> StateT consists of a single function, runStateT of type s -> m (a, s) ?
14:18:37 <derelm> still it doesn't work :(
14:18:38 <boegel> duncan: okay, but neither does my version ?
14:18:47 <boegel> derelm: post it on the wiki
14:18:52 <boegel> @HaskellIrcPastePage
14:18:52 <lambdabot> Sorry, I don't know the command "HaskellIrcPastePage", try "lambdabot: 
14:18:52 <lambdabot> listcommands"
14:18:53 <duncan> boegel: true
14:18:58 <boegel> @wiki HaskellIrcPastePage
14:18:59 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:20:02 <jlouis> duncan: deforestation rocks ;)
14:21:21 <duncan> jlouis: :-) ,btw that line is a record definition with a single member which is a function, it's equivalent to an ordinary newtype and a seperate accessor function runStateT :: StateT s m a -> s -> m (a, s)
14:25:00 * CosmicRay implements a dbm virtualization system in haskell
14:25:12 <Heffalump> meaning?
14:25:16 <boegel> go CosmicRay 
14:25:23 <CosmicRay> Heffalump: speaking to me ?
14:25:33 <Heffalump> yes :-)
14:25:35 <derelm> boegel: pastet at the wiki
14:26:16 <CosmicRay> Heffalump: there is now a class that defines operations on (HashTable String String)-like interfaces.  These include HashTable itself, gdbm, dbhash, dbm, and my own StringDBM.
14:26:34 <CosmicRay> Heffalump: one's code can thus get persistence cheaply and with a variety of interchangable interfaces.
14:27:17 <CosmicRay> (StringDBM, btw, has a simple on-disk format that is cached in-memory by a HashTable.)
14:27:37 <CosmicRay> Heffalump: similar to anydbm in Python
14:27:44 <boegel> derelm: I don't see it ? did you save?
14:27:55 <CosmicRay> in fact, I am linking Python's anydbm into this system to provide the interface to the C-based libraries :-)
14:28:04 <Heffalump> right
14:28:05 <CosmicRay> but even without it, one can still use HashTable and StringDBM
14:28:06 <derelm> boegel: yes, but as second, i don't like putting my tiny problems at the top ;)
14:28:28 <CosmicRay> one can also use any dict-like Python object that is from a string key to a string value.
14:28:31 <boegel> derelm, no problem with that... I'll put it at the top
14:29:44 * boegel starts Hugs
14:32:32 <jadrian> is the Writer Monad tha adequate structure for creating lazy streams of output during a computation?
14:32:51 <Heffalump> yes
14:32:54 <boegel> derelm: my mistake
14:33:07 <boegel> max(x,y) isn't correct, it should be 'max x y'
14:33:30 <jadrian> and if I want to use a read-only state, I should go for the RWS Monad, right?
14:33:58 <boegel> derelm: I've saved the changed on the wiki
14:34:12 * Heffalump switches his conversation with Igloo about making a timeout thread back here
14:34:25 <boegel> your testBaum example is working... it's up to you to test it even further
14:34:25 <Heffalump> and wonders why ghc compiled programs require two SIGINTs before they die
14:34:27 <CosmicRay> a timeout thread?
14:34:37 <CosmicRay> Heffalump: I haven't experienced that iirc
14:34:40 <Heffalump> yes, to kill off arbitrary computations if they run too long
14:34:43 <CosmicRay> ah.
14:34:46 <duncan> boegel: or you can say (uncurry max)(x,y)  :-)
14:34:50 <CosmicRay> this exists.
14:34:58 <Igloo> The first one might be killing one of the threads. Have you tried with a program that doesn't fork?
14:35:04 <Heffalump> just about to
14:35:09 <boegel> duncan: true, but why make it hard :p
14:35:13 <Igloo> Oh, although it's only 1 OS thread
14:35:16 <boegel> @type uncurry
14:35:17 <lambdabot> uncurry :: forall c b a. (a -> b -> c) -> (a, b) -> c
14:35:20 <Heffalump> yes, have now
14:35:28 <CosmicRay> Heffalump: http://quux.org/devel/missingh/html/MissingH.Threads.Child.html
14:35:33 <CosmicRay> Heffalump: from Peter Simons
14:35:50 <duncan> boegel: only if you're entering an obfscuation contest
14:35:53 <CosmicRay> specifically: http://quux.org/devel/missingh/html/MissingH.Threads.Child.html#v%3Atimeout
14:36:02 <boegel> duncan: :D
14:36:08 <Heffalump> CosmicRay: how is it implementend?
14:36:23 <CosmicRay> I don't recall
14:36:26 * Igloo can't connect to quux.org
14:36:33 <CosmicRay> feel free to grab the source
14:36:39 <Heffalump> yeah, just looking at it
14:36:41 <Igloo> Canb you easily test whether it works if the child is "let loop 0 = loop 0 in loop 0"?
14:36:43 <CosmicRay> Igloo: what error are you getting?
14:36:49 <Igloo> 503
14:37:02 * CosmicRay wonders what that error is
14:37:03 <Heffalump> ooh, it uses par.
14:37:04 <Igloo> Oh, no, connection could not be established. But now it works.
14:37:10 <CosmicRay> weird
14:37:20 <Heffalump> oh, whic is its own par, not the GPH par.
14:37:21 <Heffalump> right.
14:37:44 * Heffalump apt-get installs missingh
14:38:33 <CosmicRay> install missingh-doc too if you want a local copy of the api reference you hit above
14:38:47 <Heffalump> yeah
14:39:50 * CosmicRay is glad someone else is finding MissingH useful :-)
14:40:02 <Heffalump> don't count your chickens yet..
14:40:05 <CosmicRay> heh
14:40:17 <Heffalump> nope, does't work.
14:40:23 <CosmicRay> it doesn't?
14:40:25 <CosmicRay> what does it do?
14:40:29 <Heffalump> hangs.
14:40:31 <Heffalump> main = do timeout 1000 $ print $ let loop 0 = loop 0 in loop 0 :: Integer
14:40:32 <Heffalump>           print "foo"
14:40:40 <derelm> boegel: yes that seems to work! thanks a lot for helping!
14:40:49 <boegel> derelm: glad to help...
14:41:18 <CosmicRay> Heffalump: ah, I think I see the problem.
14:41:25 <derelm> boegel: btw, what is the difference between the type Int and Integer? as it works with the former but not the latter
14:41:27 <boegel> when I came here first, I appreciated the help, no I try to do my share (even though my Haskell is a bit rusty)
14:41:29 <CosmicRay> Heffalump: peter's code is deisgned to catch timeouts relating to io
14:41:30 <Heffalump> yes, let loop 0 = loop 0 in loop 0 doesn't allocate memory.
14:41:38 <CosmicRay> Heffalump: you are having a cpu loop
14:41:43 <Heffalump> yes, I know :-)
14:41:47 <CosmicRay> Heffalump: forkio won't context switch during that, I bet.
14:41:50 <boegel> derelm: err, I'm not sure... I'm guessing Integer has a bigger range
14:41:54 <boegel> but I'm not sure
14:41:56 <Heffalump> indeed. That being my original problem.
14:41:57 <boegel> @type Int
14:41:58 <CosmicRay> Heffalump: are you really trying to trap long-running computations?
14:41:58 <lambdabot> bzzt
14:42:02 <Heffalump> yes.
14:42:09 <boegel> @type Integer
14:42:10 <lambdabot> bzzt
14:42:14 <derelm> :)
14:42:15 <CosmicRay> Heffalump: perhaps you could take par, adjust it to use forkOS, and that would do it?
14:42:15 <Heffalump> I want to make an application where I allow untrusted users to provide arbitrary source code.
14:42:16 <boegel> @index Integer
14:42:16 <lambdabot> GHC.Exts,GHC.Num,Prelude
14:42:22 <CosmicRay> Heffalump: eep.
14:42:23 <Heffalump> forkOS does't help.
14:42:28 <CosmicRay> why not?
14:42:34 <Heffalump> I have no idea, but it doesn't.
14:42:37 <boegel> well, it makes sense, because Integer and Int _are_ types...
14:42:44 <CosmicRay> well then, fork and sigalrm.
14:42:46 <Heffalump> well, I have some idea; preemption of the RTS still doesn't happen
14:42:53 <Heffalump> why fork and sigalrm?
14:43:02 <Heffalump> I tried sigalrm on its own, with mixed and confusing results.
14:43:08 <CosmicRay> you can tell the OS to send you SIGALRM an arbitrary number of seconds in the future
14:43:14 <boegel> derelm: http://www.cs.uu.nl/~afie/haskell/tourofsyntax.html#Int
14:43:17 <CosmicRay> so fork, set the alarm, and if you get it, exit.
14:43:23 <boegel> Int is limited in size (32 bytes), Integer isn't
14:43:29 <CosmicRay> if you don't, complete your computation, then exit.
14:43:32 <CosmicRay> boegel: 32 bits.
14:43:37 <CosmicRay> boegel: on some platforms.
14:43:40 <Heffalump> I understand, but why do I need to fork first?
14:43:56 <Heffalump> Can't I just do that in one process and abort if necessary?
14:43:58 <CosmicRay> Heffalump: how else will you interrupt the runing computation?
14:44:06 <Heffalump> (well, apart from the fact that it doesn't really work..)
14:44:14 <pesco> boegel, CosmicRay: 31 bits guaranteed by the report, IIRC.
14:44:17 <derelm> boegel: but why would type Ntree a -> Int work and Ntree a -> Integer not?
14:44:22 <Heffalump> well, I tried installing a signal handler that throws an exception.
14:44:24 <CosmicRay> exit(2) will abort anything
14:44:32 <Heffalump> true.
14:44:38 <CosmicRay> Heffalump: does that actually work?  somehow I didn't think it would
14:44:40 <Heffalump> But I want to be able to pass data back from my computation.
14:44:46 <Heffalump> well, it didn't very reliably.
14:44:51 <CosmicRay> yeah
14:44:52 <Heffalump> so fork is bad
14:44:58 <boegel> CosmicRay: woops :)
14:44:59 <CosmicRay> why is fork bad?
14:45:25 <CosmicRay> Heffalump: keep in mind, runaway computations are the least of your worries when runing untested code.
14:45:34 <CosmicRay> Heffalump: what about fork bombs?  filling up disk space?  etc.
14:45:38 <boegel> @type max
14:45:39 <lambdabot> max :: forall a. (Ord a) => a -> a -> a
14:45:40 <Heffalump> they can't do IO
14:45:43 <boegel> @type maximum
14:45:45 <lambdabot> maximum :: forall a. (Ord a) => [a] -> a
14:45:58 <Heffalump> and the CPU time limitation will restrict the time they have to allocate memory, especially with purely functional code
14:46:00 <CosmicRay> ah.  are you *sure*?  (unsafePerformIO may help them)
14:46:08 <Heffalump> I'm sure, because imports will be banned.
14:46:12 <CosmicRay> ghc can allocate a lot of memory very fast :-)
14:46:13 <CosmicRay> ah
14:46:18 <boegel> @type length
14:46:19 <lambdabot> length :: forall a. [a] -> Int
14:46:27 <boegel> derelm: here you go
14:46:40 <derelm> boegel: i see ...
14:46:43 <boegel> length returns an Int, so everything should be Int (I think)
14:46:44 <CosmicRay> as I learned today, when I tried to show two 10MB Strings.
14:47:01 <pesco> derelm: There is genericLength in Data.List.
14:47:07 <Heffalump> I can run the entire application under some memory bound to be absolutely safe.
14:47:13 <boegel> if I'm telling lies, someone will correct me probably
14:47:13 <CosmicRay> yes
14:47:14 <derelm> boegel: but that constructs another problem, the type of my function is to be -> Integer :(
14:47:18 <CosmicRay> see ulimit(1), setrlimit(2)
14:47:20 <Heffalump> but I only want it to abort as a last extreme.
14:47:33 <CosmicRay> if you use fork, only the computation process would be killed.
14:47:33 <pesco> @type Data.List.genericLength
14:47:34 <lambdabot> Data.List.genericLength :: forall i b. (Num i) => [b] -> i
14:47:36 <Heffalump> In the standard "they made an infinite loop" case I want to tell them.
14:47:40 <boegel> @type fromInt
14:47:41 <lambdabot> bzzt
14:47:44 <Heffalump> Yes, but then how do I pass back arbitrary data?
14:47:49 <boegel> @index fromInt
14:47:49 <derelm> toInt?
14:47:49 <lambdabot> bzzt
14:47:50 <CosmicRay> Heffalump: pipe(2)
14:47:58 <boegel> heh...
14:48:10 <pesco> derelm, boegel: fromIntegral
14:48:11 <CosmicRay> haskell versions exist, I just don't know the names off the top of my head
14:48:14 <CosmicRay> look in System.Posix
14:48:36 <Heffalump> remember that in Haskell "arbitrary data" includes HOFs
14:48:40 <boegel> @type fromIntegral
14:48:42 <CosmicRay> HOFs?
14:48:43 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
14:48:46 <Heffalump> higher-order functions
14:48:49 <duncan> Heffalump: that'd be wise, I've seen cases where c2hs alloces all your VM and then the OOM killer starts killing random processes. Allocating memory is mostly pure :-)
14:48:52 <Heffalump> i.e. things that aren't obviously serialisable
14:48:58 <CosmicRay> Heffalump: why do you need to return a HOF?
14:48:59 <boegel> pesco: we need to go from Int to Integer
14:49:04 <boegel> @type toIntegral
14:49:05 <lambdabot> bzzt
14:49:08 <Heffalump> in this specific application I don't, but I might..
14:49:09 <boegel> thought so :)
14:49:10 <CosmicRay> Heffalump: format your return value to its final string form, then return it.
14:49:18 <duncan> @type fromIntegral
14:49:19 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
14:49:27 <Heffalump> though I guess returning a function is just asking for the function to be an infinite loop.
14:49:31 <CosmicRay> Heffalump: in that case, you're probably barking up the hsplugins tree anyway
14:49:35 <pesco> boegel: Yes. Num Integer, Integral Int.
14:49:44 <boegel> pesco: oh
14:49:49 <CosmicRay> Heffalump: if you're using hsplugins, you can return the code over the pipe
14:50:07 <pesco> But I thought the Int were coming from length which you can substitute genericLength for.
14:50:08 <boegel> derelm: degree (Node x node_list) = max (fromIntegral $ length node_list) (maximum $ map (degree) node_list)
14:50:16 <boegel> that should get -> Integer working
14:50:24 <derelm> ah, i'll try that
14:50:25 <Heffalump> can I?
14:50:33 <boegel> derelm: so will i
14:50:36 <CosmicRay> Heffalump: well sure, you're just parsing ascii, aren't you?
14:50:43 <Heffalump> oh, ick.
14:50:50 <CosmicRay> Heffalump: are you usnig hsplugins to parse the ascii incoming code?
14:50:54 <Heffalump> anyway, that wouldn't work, you can't pretty-print arbitrary code.
14:51:01 <Heffalump> yes
14:51:01 <CosmicRay> pshaw
14:51:03 <derelm> boegel: that works!
14:51:06 <CosmicRay> Language.Haskell.foo
14:51:17 <boegel> derelm: idd it does
14:51:18 <CosmicRay> Language.Haskell.Pretty.
14:51:25 <CosmicRay> hooked up with Language.Haskell.Parser.
14:51:27 <boegel> derelm: is this for a school project or so ?
14:51:28 <Heffalump> you can't pretty print arbitrary values of function type
14:51:44 <derelm> boegel: worse, for university :)
14:51:55 <boegel> derelm: university is school :)
14:51:55 <CosmicRay> Heffalump: I don't get it.  You already have a source representation coming in.  Why do you need another one?
14:51:56 <Heffalump> Language.Haskell.Pretty will take an ADT of Haskell code.
14:51:58 <boegel> derelm: which uni ?
14:52:16 <derelm> boegel: goethe university frankfurt, germany
14:52:22 <Heffalump> because if that source representation runs and produces a function as a result, there is no ASCII equivalent for that result.
14:52:56 <boegel> derelm: nice... is the course completely about Haskell, or do they teach other languages in the same course?
14:53:00 <CosmicRay> Heffalump: well then you're hosed whether or not you use fork, right
14:53:40 <Heffalump> I wouldn't be hosed if I didn't fork, because then I wouldn't have to pass the value back along any non-Haskell channel.
14:53:54 <CosmicRay> why do you have to pass back a function?
14:53:55 <derelm> boegel: it's mainly haskell, with a little python
14:54:02 <jlouis> newtype State s a = State { runState ::  (s -> (a,s) } is an implementation of a state monad. How should I view the type variables s and a? 
14:54:11 <CosmicRay> if you can't represent it in ascii, what's the point?
14:54:12 <jlouis> in other words, what would be good names for them
14:54:23 <derelm> boegel: i can point you to the german script?
14:54:26 <Heffalump> remind me why you are using Haskell, again? :-)
14:55:39 <boegel> derelm: naah, my german isn't that good... I never got german in school
14:55:55 <boegel> derelm: how old are you ?
14:56:04 <derelm> boegel: 24
14:56:21 <boegel> derelm: and still at uni ?
14:56:24 <derelm> boegel: rather old for a university beginner ;)
14:56:29 <jadrian> jlouis: you can think of (State s a) as a computation that maintains a state of type s and which returns a result of type a 
14:56:36 <boegel> that's what i was thinking :)
14:56:36 <derelm> yes, i returned after working for a while
14:56:39 <jlouis> ah, the first parameter, s, is the type of the state we are storing. The second parameter, a, is the type of the return
14:56:43 <boegel> oh, ok
14:56:47 <jlouis> jadrian: yup, figured that one out
14:56:52 <jlouis> thanks
14:58:44 * boegel starts trying gtk2hs until eMule finishes the download he's been pulling all day :|
15:00:51 <Pseudonym> Paul, was that you posting the first comment?
15:01:05 <Pseudonym> Actually, no, it's not spelled well enough.
15:02:23 <boegel> duncan: which rpm package should I pull to be able to give gtk2hs a test ?
15:02:40 <jlouis> if a named record has just one constructor, as in newtype State s a = State { runState ::  (s -> (a,s) }. Can you then omit State { runstate = ...} and just write State $ ... ?
15:03:17 <duncan> boegel: for fedora there are packages: http://haskell.org/fedora/ 
15:03:39 <boegel> I know, but I'm not sure which ones I should use... does it work with Hugs too ?
15:04:38 <duncan> boegel: no, not with Hugs. You'd want  gtk2hs-ghc622-0.9.7
15:05:01 <boegel> it says I don't have ghc622, but I do... :(
15:05:13 <duncan> boegel: probably also gtk2hs-glade-ghc622-0.9.7
15:05:30 <duncan> boegel: where did you get your ghc?
15:05:39 <boegel> err, I don't know :)
15:05:56 <boegel> It has been a while
15:06:08 <duncan> boegel: $ which ghc; rpm -q ghc
15:11:48 * boegel kicks his eMule again and starts shouting "oh come on you motherf*cker"
15:12:45 <syntax_syntax> nothing like some insanely fast & hard & dumb jungle music with the heeeeeeavy mean mean mean bass lines to cheer one up when one's got the blues.
15:17:25 <humasect> yeah =)
15:18:03 <humasect> i mean
15:18:04 <humasect> yeah =(
15:18:54 <syntax_syntax> www.drumnbasstv.com
15:18:59 <syntax_syntax> great for all-nighters
15:20:02 <humasect> mm yay
15:21:26 <syntax_syntax> Music like this makes me want to abuse illegal stimulants
15:21:37 <humasect> >:D
15:24:07 <humasect> moderation is masterbation, and what is what and what makes you feel good
15:24:18 <humasect> they always come unglued
15:24:27 <humasect> - STP
16:03:54 <araujo> Hello shapr 
16:04:00 <shapr> hiya araujo 
16:04:01 <araujo> Looking for information about Haskell?
16:04:10 <shapr> yes, I've heard it's this crazy cool language!
16:04:15 <araujo> :-)
16:04:16 * shapr snickers
16:07:30 <boegel> shapr: should I give you the tour ? :)
16:07:59 <shapr> er, I'm ok for the moment, thanks ;-)
16:08:12 <boegel> :D
16:08:24 <boegel> shapr: I added myself to the TMR wiki, as possible author
16:08:28 <boegel> and so did many other
16:08:32 <boegel> (see topic)
16:09:35 <shapr> cool!
16:11:35 <Igloo> Ack, please can you use an OS licence rather than a CC one? BSD would be the obvious choice. Otherwise we'll have hassle converting "neat trick examples" into real programs
16:12:19 <boegel> shapr: I'm planning to do a tutorial on gtk2hs, or maybe describe the design of a GUI for my raytracer
16:15:53 <shapr> boegel: excellent!
16:16:07 <shapr> Igloo: sure, BSD sounds good.
16:16:30 <Igloo> Cool, thanks
16:16:31 <shapr> Igloo: want to write?
16:18:00 <Igloo> Time permitting (=> almost certainly not in the next 9 months)
16:18:15 <shapr> well, not for the first issue then.
16:18:38 <shapr> darius_: y0
16:18:49 <darius_> hey shapr
16:18:52 <shapr> wassup?
16:18:55 <shapr> just read your mail
16:18:59 <darius_> just hanging out
16:19:18 <darius_> worrying about my newly-remodeled tooth
16:19:55 <shapr> What does the tooth diff look like?
16:20:16 <shapr> Does your tooth have a ChangeLog?
16:20:26 <darius_> it was cracked, but i'm afraid it may need another revision
16:20:29 <shapr> hej jberg 
16:20:39 * boegel is sleepy
16:20:42 <boegel> g'night everyone !
16:20:46 <shapr> g'night boegel 
16:20:48 * shapr is also tired
16:21:02 * humasect is boxed
16:21:23 <psi> i'm not, because i fell asleep when i got home, and woke up at 20.00 :|
16:21:27 <psi> i always do that
16:22:19 <jberg> hei shapr
16:24:22 <shapr> puhutko suomea?
16:25:38 <syntax_syntax> Situation normal, all Phuket up?
16:42:57 <stepcut> anyone know a way to burn a picture into the unused portion of a cd-r ?
16:42:57 <stepcut> s
16:42:58 <stepcut> ack
16:43:27 <Igloo> Do you mean write data in such a way that it looks like a picture?
16:44:41 <shapr> stepcut: afaik, only certain writers can do that.
16:48:24 <stepcut> Igloo: yeah
16:48:35 <stepcut> Igloo: specifically a text string
16:48:47 <stepcut> shapr: I wasn't sure if *any* did it :p
16:49:02 <stepcut> though I have seen some that write a label on the top
16:50:26 <shapr> stepcut: cdrecord docs have details, cdrecord does it.
16:51:22 <stepcut> shapr: cool
16:51:43 <stepcut> shapr: any idea what that feature is called ?
16:52:49 <jlouis> stepcut: option-for-wasting-silly-time-while-you-can-study-system-F
16:53:03 <jlouis> ;)
16:53:10 <stepcut> jlouis: better than, wasting time writing labels
16:54:02 <jlouis> heh
16:54:18 <stepcut> tattoo
17:30:32 <Pseudonym> @arr
17:30:33 <lambdabot> I'll keel haul ya fer that!
17:30:44 <Pseudonym> And yer little dog, too!
17:31:02 * shapr blinks
17:31:26 <Pseudonym> Hmmm?
17:31:36 <duncan> what's that arr?
17:31:52 <shapr> It's the talk-like-a-pirate plugin.
17:31:59 <duncan> @arr
17:31:59 <lambdabot> Yeh scurvy dog...
17:32:05 <duncan> I see :-)
17:32:49 <Pseudonym> Oh, shapr, I don't know if you caught this yesterday.
17:32:55 <Pseudonym> But I want to call my column "Pseudocode".
17:33:01 <shapr> Excellent choice!
17:33:42 <shapr> What do you think about issue size?
17:34:14 <shapr> I was thinking of publishing everything that's ready in time, rather than pacing stuff across several issues.
17:34:14 <duncan> btw, I like the idea of TMR, I didn't realise what you were going on about but then I read thw wiki
17:34:41 <shapr> Hopefully the first issue will get more people interested, etc
17:35:00 * shapr isn't sure what the english word works for foldr1
17:35:05 <Pseudonym> Yeah, I'd agree with that.
17:35:20 <Pseudonym> We'll settle on an "average" size soon enough.
17:35:25 <shapr> Yeah, true.
17:35:35 <duncan> I can do a gtk2hs article for the second edition, boegel seems to be doing one for the fist edition
17:35:35 <Pseudonym> And if we get more, we'll just hold some over.
17:36:27 <shapr> duncan: yes please!
17:37:18 <duncan> I guess we can use pictures? screenshots?
17:37:29 <shapr> I see the goal of TMR as something between wiki and HC&AR
17:37:31 <shapr> duncan: yes
17:37:35 * Pseudonym nods
17:37:41 <duncan> everyone likes screenshots :-)
17:37:43 <Pseudonym> How will it be published?  Web and PDF or something?
17:37:45 <shapr> duncan: pretty pictures are preferred in fact.
17:37:56 <Pseudonym> Do we submit in DocBook or TeX?
17:38:08 <duncan> eek! not docbook
17:38:17 <shapr> My original plan was to just have a wikizine, that way I can do as much cheerleading, and as little actual work as possible :-)
17:38:25 <Pseudonym> :-)
17:38:38 <Pseudonym> I was thinking of publishing it like the HC&AR.
17:38:48 <Pseudonym> But it's up to you.
17:38:56 <shapr> how so like the HC&AR?
17:39:09 <Pseudonym> Well, the HC&AR is a PDF document and a web site.
17:39:16 <shapr> Wouter brought up the point that the academic community tends to take PDF downloads more seriously.
17:39:20 * Pseudonym nods
17:39:30 <Pseudonym> And I want the ability to put in diagrams, including xypic ones.
17:39:45 * Pseudonym has several column ideas brewing
17:39:47 <shapr> That would work on a Wiki too, with the moin latex plugin.
17:39:53 <Pseudonym> True.
17:40:44 <shapr> But I would like at least a printable version.
17:41:01 <Pseudonym> I was actually thinking like TPJ.
17:41:10 <shapr> what's the url to that?
17:41:18 <Pseudonym> http://www.tpj.com/
17:41:22 <shapr> ah
17:41:22 <Pseudonym> THough not as fancy as TPJ.
17:42:33 <shapr> Looks nice, both html and pdf immediately available.
17:42:36 <Pseudonym> Right.
17:42:48 <shapr> y0 Coz
17:43:11 <Pseudonym> The easiest thing to do would be to specify a LaTeX stylesheet and just make people submit something that works with it.
17:43:15 <CosmicRay> evening shapr
17:43:20 <CosmicRay> shapr: my low-level python binding is complete.
17:43:25 <Pseudonym> Especially if you specify one that already exists. :-)
17:43:48 <CosmicRay> I also have working gzip and bzip2 interfaces.  I'm tackling *dbm now.  Then maybe I'll make a release :-)
17:43:54 <shapr> I've never used LaTeX, so that will require effort from someone else.
17:45:19 <shapr> From what I can tell, TMR requires a separate wiki for authoring, I hope the haskell.org guys wouldn't mind if I just up and created a new wiki without asking.
17:46:08 <shapr> Pseudonym: want to come up with an existing latex stylesheet that's good to use?
17:46:24 <Pseudonym> I could give it a go, I suppose.
17:46:29 <shapr> Ok
17:46:34 * Pseudonym will take a look and see if anything is already available.
17:46:37 <Igloo> Why does it require a separate wiki?
17:47:39 <shapr> Igloo: Same reason there's a curtain on a stage, I think. Authors don't want readers seeing in-progress articles. Many people in the Haskell community have a huge dedication to quality, and feel that interim versions are embarassing.
17:48:02 <shapr> AT least one of the definite authors has expressed that sentiment.
17:48:37 <Igloo> Can't you handle that with ACLs?
17:48:52 <Igloo> Oh, but there would still be the history when it was unveiled I guess
17:49:12 <Pseudonym> I guess you could write Wiki software that allowed it.
17:49:26 <Pseudonym> Put that on the feature list for Flippi. :-)
17:49:38 <shapr> I've never tried real wiki publishing before, so I'm just guessing.
17:50:15 <shapr> Igloo: Any process suggestions?
17:52:28 <Igloo> Nope
17:52:28 <shapr> Me neither :-)
17:52:28 <Pseudonym> Maybe we could do something with darcs.
17:52:28 <shapr> oh, good idea!
17:52:28 <Pseudonym> Regular contributors get their repositories pulled.
17:52:28 <shapr> Right!
17:52:28 <Pseudonym> But only for their columns.
17:53:10 <CosmicRay> Pseudonym: what is this that you're talking about?
17:53:32 <Pseudonym> I'm suggesting that shapr's copy of each issue is the "one true copy".
17:53:35 <shapr> If each article were in a darcs repo, or pushed to a per-issue darcs repo, that would have all the good points of a wiki, and allow using LaTeX, etc
17:53:40 <Pseudonym> But he pulls articles from developers.
17:53:44 <Pseudonym> From contributors.
17:54:00 <shapr> Excellent suggestion
17:54:05 <Pseudonym> Non-regular contributors wouldn't _have_ to use darcs, of course.
17:54:08 <Pseudonym> They could use shapr's inbox.
17:54:11 <shapr> right on
17:54:14 <Pseudonym> Or some other contributor's.
17:54:30 <shapr> CosmicRay: The Monad.Reader ... have you finished your article? ;-)
17:54:57 <CosmicRay> shapr: haven't started it yet.  due 2/15.  I want to get MissingPy released first.  I'll probably want to mention it.
17:55:07 <CosmicRay> @index Monad.Reader
17:55:07 <lambdabot> bzzt
17:55:10 <CosmicRay> @index Reader
17:55:10 <lambdabot> Control.Monad.RWS,Control.Monad.Reader,Control.Monad.RWS,Control.Monad.Reader
17:55:25 <CosmicRay> what is this about yanking peoples repositories though?
17:55:26 <shapr> Let's see, "John Goerzen - Challenges of Interfacing Haskell to Foreign Languages."
17:55:29 <CosmicRay> heh
17:55:42 <shapr> CosmicRay: pretty much the haskell-v8 dev process.
17:55:59 <CosmicRay> I didn't tank anyone's access
17:56:03 <CosmicRay> s/tank/yank/
17:56:05 * CosmicRay confused
17:56:10 <shapr> No, I mean... ..
17:56:29 <shapr> darcs allows easy distributed development via multiple read-only repos
17:56:47 * shapr was just writing that somewhere....
17:56:58 <CosmicRay> heh: re "Challenges"...  I had a boss once that did grad work on a filesystem that was part of a doomed OS.  he said, of *everything*, "that's easier than writing a filesystem!" and wouldn't understand why problems existed that couldn't be solved in a week
17:57:02 <CosmicRay> ah.
17:57:18 <shapr> yow
17:57:37 <CosmicRay> really, designing a crappy filesystem isn't that hard.
17:57:51 <CosmicRay> I have no reason to believe his was good.
17:57:57 <Pseudonym> :-)
17:58:01 <Pseudonym> Lunch for me.
17:58:03 <Pseudonym> BBL
17:58:07 <shapr> Pseudonym: so, how to do both html and latex publishing? article.lhs ?
17:58:17 * shapr is hungry also.
17:58:46 * shapr looks to see how HC&AR does html + pdf
17:59:05 <CosmicRay> shapr: I'm partial to sgml
17:59:08 <CosmicRay> docbook
17:59:20 <CosmicRay> shapr: if you still have haskell-v8 stuff laying around, you have all my scripts to do it
18:00:02 * shapr runs pullall.sh
18:00:13 <shapr> Does DocBook do LaTeX?
18:00:29 <CosmicRay> yes, though the latex it generates is not human-editable really
18:00:38 <CosmicRay> it's just a step on the way to pdf/ps
18:00:50 <shapr> Can DocBook use LaTeX plugins like xypic, the category theory dealie?
18:01:00 <CosmicRay> I have no idea
18:01:08 <CosmicRay> probably not latex plugins,m but it may have its own
18:01:41 <shapr> hey, have you seen the BasicCompiler.hs Ninja Jones wrote?
18:01:51 <CosmicRay> nope, haven't heard of it
18:01:59 <shapr> it's in haskell-v8
18:02:00 <CosmicRay> but it sounds interesting
18:02:10 <CosmicRay> hmm, obviously I have not been paying attention
18:02:21 <shapr> Neither have I.. life gets in the way sometimes.
18:02:26 * CosmicRay pulls and pushes
18:02:31 <CosmicRay> shit, 25 patches
18:02:35 * shapr grins
18:03:11 <shapr> Neat thing about haskell-v8 is that it's a perfect example of FLM usage.
18:03:46 <shapr> kosmikus: What does HC&AR use?
18:03:47 <CosmicRay> FLM?
18:03:52 <shapr> Fermat's Last Margin
18:04:07 <CosmicRay> geez even pullall.sh is better :-)
18:04:08 <shapr> The research paper annotation app I'm slowly writing.
18:04:50 <shapr> Darcs is the ultimate open source tool.
18:04:53 * shapr cackles evilly
18:04:56 <humasect> @arr
18:04:56 <lambdabot> Drink up, me hearties
18:05:03 <shapr> @arr
18:05:03 <lambdabot> Avast!
18:05:16 <CosmicRay> shapr: you will live this, I think: http://forest.complete.org/node/20
18:07:56 * shapr laughs
18:07:56 <shapr> I gotta show that to Bea
18:07:56 <CosmicRay> s/live/like/
18:07:56 <shapr> No, I'm living it already, thanks ;-)
18:07:56 <CosmicRay> hehe
18:07:56 * CosmicRay got a GPL source code availability notice with the access point he just bought.
18:07:56 <CosmicRay> cool.
18:07:56 * CosmicRay downloads the 128MB (!) tarball
18:07:56 <shapr> Which one?
18:07:56 <CosmicRay> netgear WG602 (v3)
18:08:04 <CosmicRay> got it for like $30 or $40 brand new at compusa
18:08:08 <CosmicRay> 802.11g ap
18:08:17 <CosmicRay> I didn't know any of the non-router ones ran linux
18:08:35 <shrimpx> they run linux? weird
18:08:39 <CosmicRay> yeah
18:08:46 <shapr> Linux at CompUSA... life has changed since I left the States.
18:08:51 <shrimpx> heh
18:09:02 <CosmicRay> shapr: not really, they have no clue this is the case :-)
18:09:09 <CosmicRay> shapr: I didn't either until I got the box open
18:09:18 <shapr> CompUSA is not known for their cluefulness.
18:09:20 <CosmicRay> http://www.warp.at/projects/wg602.html
18:09:38 <shapr> Quite a few times I corrected salespeople who were talking to customers.
18:09:58 <shapr> Only when it might really screw over the customer, of course.
18:10:27 <CosmicRay> compusa people are just as much idiots as best buy people are.  the compusa people are just more smug and sure they're correct.
18:10:40 <shapr> They never messed with me after the first time.
18:10:50 <CosmicRay> heh
18:11:01 <CosmicRay> I'm not there often enough for them to recognize me, or me to care
18:11:11 <CosmicRay> we were just in the area sunday ans stopped by
18:11:13 <CosmicRay> they had some good sales
18:11:20 <CosmicRay> got a 10/100 switch for $10
18:11:28 <CosmicRay> and a 50-pack of DVD+Rs for $40
18:11:30 <shapr> Did you see your book on sale anywhere? :-)
18:11:40 <CosmicRay> I didn't bother to look :-)
18:16:49 <CosmicRay> it is just so damn slow
18:16:49 <shapr> yup, I agree.
18:16:49 <CosmicRay> and kinda buggy
18:16:50 <shapr> Gnus is a lot faster in xemacs.
18:16:56 <shapr> And less buggy too.
18:17:04 <CosmicRay> last I tried it was probably 2-3y ago, and it was in xemacs
18:17:12 <CosmicRay> I found maildir and imap support both to be buggy
18:17:19 <shapr> But xemacs is losing support in the gnumacs world.
18:17:25 <CosmicRay> shapr: oh?  why is this?
18:17:55 <shapr> People don't see much of a need to write portable elisp, and the two flavors are divering more and more.
18:18:03 <shapr> diverging*
18:18:11 <CosmicRay> and more authors are choosing gnu emacs?
18:18:13 <humasect> xemacs has issues with compatibility
18:18:29 <CosmicRay> shapr: oh also, tarfile and zipfile are slated for integration with HVFS too.
18:18:30 <shapr> RMS is the gnu emacs dictator.
18:18:46 <CosmicRay> shapr: so one can open up a tar or zip as a filesystem
18:18:51 <shapr> Which means he got dlopen() code remove from gnumacs because it might allow people to get around the GPL.
18:18:58 <CosmicRay> oh geez
18:20:05 <shapr> Maybe RMS is right, the legal battles are getting very scary. But I prefer the looser, laissez-faire approach of the xemacs developers.
18:20:57 <CosmicRay> well he is right about some things
18:21:11 <CosmicRay> making damn sure he has proof of copyright ownership is not a bad policy
18:21:42 <CosmicRay> but the guy just goes off the deep end sometimes
18:22:18 <shapr> Seems like that to me also. But I didn't get screwed out of years of work at MIT, so...
18:22:33 <shapr> Wasn't it MIT where a prof took off with a cool app RMS wrote?
18:22:37 * shapr asks google
18:22:52 <shapr> ah yes, the MIT AI lab.
18:23:02 <CosmicRay> I hadn't heard of this
18:23:31 <shapr> http://en.wikipedia.org/wiki/Richard_Stallman
18:24:34 <Pseudonym> Back.
18:26:26 <shapr> I've characterized the GPL as a Gödel Attack on the copyright system.
18:26:30 <Pseudonym> "What do you mean, you want a proof?  That's the last theorem you're getting from me!"  -- Pierre de Fermat
18:26:48 <shapr> :-)
18:28:50 <CosmicRay> dammit, megamonad died again.
18:29:01 <CosmicRay> I need to get around to getting irc support into missingh.
18:29:20 <shapr> rewrite MegaMon
18:29:22 <shapr> argh
18:29:28 <shapr> MegaMonad in Haskell?
18:29:34 <CosmicRay> no, just the irc interface
18:29:40 <CosmicRay> megamonad uses the megahal C program
18:29:46 <CosmicRay> but there's a little perl wrapper that makes it into a bot
18:29:52 <CosmicRay> that's the part that really sucks
18:30:01 <Pseudonym> So rewrite that bit in Haskell.
18:30:08 <CosmicRay> exactly.
18:30:25 <shapr> I think Haskell is going to kick butt on the Cell - http://www.theregister.co.uk/2005/02/01/cell_analysis_part_one/
18:30:50 <shapr> Time to dust off the parallel array code.
18:34:59 <CosmicRay> hmm, can someone tell me why ghc chokes on this:
18:35:05 <CosmicRay> openStringDBM :: FilePath -> IOMode -> IO StringDBM
18:35:05 <CosmicRay> openStringDBM = openStringHVDBM SystemFS
18:35:09 <CosmicRay> openStringHVDBM :: HVFSOpenable a => a -> FilePath -> IOMode -> IO StringDBM
18:35:14 <CosmicRay> SystemFS is an HVFSOpenable.
18:35:17 <CosmicRay> ghc says:
18:35:31 <CosmicRay>     Mismatched contexts
18:35:39 <CosmicRay>     When matching the contexts of the signatures for
18:35:41 <CosmicRay> ..blah...
18:35:49 <CosmicRay>     The signature contexts in a mutually recursive group should all be identical
18:35:49 <CosmicRay>     When generalising the type(s) for openStringDBM, openStringHVDBM
18:35:51 <CosmicRay> what does that mean?
18:37:47 <shapr> It's obviously talking about typeclass contexts, but I don't know how to fix it.
18:38:19 <dons> what happens when you delete the types, and ask ghci for the type of the functions
18:38:20 <CosmicRay> oh well, I just deleted one function and now it's fine :-)
18:38:28 <shapr> g'day dons 
18:38:41 <dons> hey shapr
18:40:22 <CosmicRay> SyntaxNinja: ping
18:40:22 <shapr> How's code?
18:40:22 <CosmicRay> SyntaxNinja: I have a cabal feature request for you
18:40:22 <Pseudonym> What's the type of SystemFS?
18:40:22 <CosmicRay> data SystemFS = SystemFS deriving (Eq, Show)
18:40:22 <CosmicRay> that's it
18:40:22 <CosmicRay> I had a bug in one of the functions, it was accidentally recursive with the other one
18:40:22 <Pseudonym> Does openStringHVDBM call openStringDBM?
18:40:22 <CosmicRay> that may have caused it
18:40:22 <Pseudonym> Right.
18:40:22 <CosmicRay> that was the bug
18:40:29 <CosmicRay> shapr: http://www.complete.org/~jgoerzen/shapr/MissingPy/
18:40:51 <shapr> neat
18:40:52 <CosmicRay> also, this is my new meta-dbm infrastructure: http://www.complete.org/~jgoerzen/shapr/MissingH/MissingH.AnyDBM.html
18:41:20 <CosmicRay> and these two functions are a lot of fun: http://www.complete.org/~jgoerzen/shapr/MissingH/MissingH.List.html#v%3AstrFromAL
18:41:22 <Pseudonym> So can Python call Haskell yet?
18:41:58 * shapr blinks
18:41:59 <CosmicRay> Pseudonym: that one someone else will have to do
18:42:10 <CosmicRay> iow, not on my todo list :-)
18:42:30 <CosmicRay> shapr: can you tell I love typeclasses? :-)
18:42:32 <shapr> Isn't this fmToList and the other way around?
18:43:00 <shapr> Did you see the generalized collections libraries?
18:43:01 <CosmicRay> shapr: where are you looking?
18:43:09 <CosmicRay> shapr: no.  crap.  url?
18:43:15 <shapr> strFromAL and strToAL
18:43:32 <shapr> umm, I think Pseudonym was the most recent maintainer of Okasaki's libs...
18:43:46 <shapr> I vaguely recall they were able to act like whatever you want.
18:43:50 <CosmicRay> oh, you're looking in MissingH.FiniteMap
18:43:50 <Pseudonym> Yeah, and nobody wanted them.
18:44:01 <CosmicRay> Pseudonym: url?
18:44:01 <shapr> Well, I did... but I didn't know what to do with them at the time.
18:44:06 <Pseudonym> :-)
18:44:15 <Pseudonym> I'm thinking of changing the interface yet again.
18:44:20 <Pseudonym> This time based more on views.
18:44:26 <CosmicRay> shapr: that code is correct there (in MissingH.FiniteMap)
18:44:51 <CosmicRay> ie, strFromFM...  first we convert the finite map to an association list, then convert that to a string
18:44:52 <Pseudonym> My reasoning is that there's something very convenient about pattern matching on lists which people want from other containers.
18:45:42 <Pseudonym> We kind of already have that.
18:45:50 <Pseudonym> But I think it could be even more so.
18:46:51 <shapr> Is the latest version of that code in haskell-libs?
18:47:06 <Pseudonym> Nope.
18:47:17 <shapr> WhereAt?
18:47:26 <Pseudonym> Deliberately so.  Didn't want people to depend on a work in progress.
18:47:57 <shapr> Maybe we should merge with Ashley Yakeley and do a hostile takeover.
18:47:58 <Pseudonym> http://cvs.sourceforge.net/viewcvs.py/hfl/hfl/edison/
18:48:12 <Pseudonym> Haven't touched it in a while.
18:48:45 <CosmicRay> brb, changing computers
18:49:18 <shapr> dons: Did you think about synhl in Yi on the island?
18:49:58 <shapr> dons: btw, what's the word on you getting paid to hack Yi?
18:50:43 <Pseudonym> Actually, I'd like to see a column by wli on trying to get the fastest Fibonacci numbers.
18:50:51 <dons> shapr: i've got a bit of a plan for syn hl now, just a matter of finding time
18:51:00 <dons> and I should get some yi time soon
18:51:08 <Pseudonym> wli, you there?
18:51:26 <dons> currently working on other official uni projects
18:51:28 <shapr> dons: Anything you want to describe? I still don't know the best approach.
18:51:42 <dons> have to check my notes
18:52:02 <shapr> emacs is pissing me off, and I've been considering wimping out and doing regex highlighting for Python and Haskell.
18:53:06 * shapr hears the ghostly words of SPJ "No deals with the Devil"
18:53:55 <dons> i've got a test that parses a buffer for whitespace words, and constructs a syn tree out of that, using alex and happy grammars. and partially completed code for rendering the buffer, while consulting the parse tree for colours
18:54:34 <shapr> wow, awesome
18:54:35 <Pseudonym> OTOH, SPJ also recommends tackling the awkward squad.
18:55:05 <dons> and there's a Syntax class providing ways to go from a file name to the parser we use, a parser, and a foldSyn :: (b -> a -> b) -> b -> a -> b
18:55:13 <dons> that walks a syn tree
18:55:18 <shapr> wow, cool!
18:55:44 <dons> so the idea would be to implement a parse function, and a traversal function as plugins
18:55:54 <dons> and then yi can work out from that how to render things
18:56:29 <shapr> ohh, neat
18:56:37 <dons> there's a bit of a Style class for mapping syntax items to known (r,g,b) styles. 
18:56:59 <dons> so looks like i've got most of it there now. just haven't had time to touch it in the last 3 weeks
18:57:08 <shapr> Yeah, that is most of it.
18:57:30 <shapr> Sounds like a new language mode would just be a happy/alex grammar and a set of keybindings.
18:58:07 <dons> yep. and a traversal function
18:58:08 <shapr> So the syn tree is a standard type that all buffers will share?
18:58:42 <dons> the Syntax class has different instances for different buffer contents: .hs, .tex, .c etc
18:59:09 <dons> the type of the tree is hidden from yi, which just uses access functions to look things up
18:59:18 <shapr> ah, excellent.
18:59:44 <shapr> That means that parse tree macros will most likely just work :-)
18:59:49 * shapr bounces
19:00:17 <shapr> I don't understand what the traversal function does... 
19:00:28 <shapr> Is it like defining an instance of fmap for this instance of Syntax?
19:01:12 <dons> when rendering a buffer, we simultaneously walk the tree to find the tokens pieces of the buffer correspond to
19:01:17 <dons> like fmap, yep
19:01:55 <shapr> Why would you need different traversal functions?
19:02:18 <dons> for different abstract syntax types, you mean?
19:02:50 <shapr> I don't know what I mean... 
19:03:11 <shapr> Why would you need different ways to traverse the AST?
19:03:32 <dons> you don't. you need 1 way (well, 1 for now).
19:03:37 <dons> but each language is walked differently
19:03:50 <dons> walking the C syntax tree is different to walking the Haskell tree
19:03:58 <shapr> Oh
19:04:09 <dons> instance Syntax Haskell where ...
19:04:21 <dons> parser = Language.Haskell.Parser.parse
19:04:41 <dons> foldSyn = ... something that can fold a function over that type
19:04:48 <shapr> nifty
19:04:51 <dons>  parse       :: Buffer b => b -> IO a
19:05:08 <dons> (has to be IO due to the FastBuffer)
19:05:12 <shapr> right
19:05:44 <stepcut> argh! IT set everyones home directory in /etc/passwd to /home/users instead of just changing DefaultRoot in proftpd.conf from ~ to /home/users
19:05:44 <stepcut> :(
19:06:14 <shapr> I was thinking about how yi could edit via ssh,scp, etc. But I think it'll be as easy as using a different file critter in CosmicRay's HVFS.
19:07:22 <dons> hmm. yeah. probably not too hard. just different fnewE functions
19:09:36 <shapr> Any suggestions for steps in the keymap tutorial? I've got the obvious first step, "insertChar" but I'm not sure where to go next.
19:11:16 <dons> better do a cmd char, right? 
19:11:26 <dons> cmdChar :: NanoMode
19:11:49 <shapr> ah!
19:11:52 <dons> then mode switching is important
19:12:23 <shapr> right, ok
19:12:28 <dons> on certain chars you switch to completely different sets of bindings, usually via a `meta` action. cmdSwitch illustrates this
19:12:57 <dons> also, you should explain how sets of regexes are plugged together with >|<
19:13:08 <dons> echo_km = echoAccum >||< echoEdit >||< echoEval
19:13:12 <dons> >||< sorry
19:13:46 <shapr> ok
19:13:53 <dons> but the basics are insChar and cmdChar. then mode switching other other insert-or-cmd sets
19:14:02 <dons> s/other/to
19:14:57 <shapr> That sounds like a good outline, char insertion, keymap switching, regex plugging, and then putting it all together.
19:15:21 <shapr> By the time I've finished writing that, I should be ready to hack up an emacs keymap.
19:15:31 <dons> then you'd do prefixes to cmds, like 2jd in vi, which involve running the lexer via execLexer.
19:15:40 <shapr> ah, advanced techniques
19:15:44 <dons> and finally IO-based mode switching, via metaM
19:15:52 <dons> metaM and execLexer calls are the advanced stuff, yep
19:16:27 <dons> but with those 2 you can encode pretty much any keybinding behaviour, I reckon.
19:16:43 <shapr> cool
19:17:34 <dons> also, setting prompts would be another topic
19:17:49 <dons> Y/N/C messages and the like
19:18:07 * shapr adds that to the outline
19:18:59 <dons> doing searching is another area as well, as search often has difficult semantics
19:19:16 <shapr> I'll ask you about that when I get there.
19:19:25 <dons> some have prompts, new bindings, echo buffer editing, previous matches etc
19:19:42 <shapr> emacs does lots of that.
19:19:49 <shapr> So I'm sure I'll need to know it.
19:20:41 <dons> yeah. 
19:43:15 <shapr> Oh, I could use this to experiment with my hidden-markov-model keymap idea.
19:44:38 <shapr> I've been thinking about a separate keyboard layout for every key, that's tuned for the most common chars following the char just pressed.
19:46:18 <dons> that's interesting. hmm..
19:46:57 <shapr> Would be best if you like to type one-handed, I think. I wonder if X will deal with my ibm clicky and my kinesis at the same time.
19:47:10 <dons> hehe
19:50:02 <autrijus> hm.
19:50:12 * autrijus discovers "featherweight perl6"
19:50:28 <shapr> Is that the subset of Perl6 that allows you to define the rest?
19:50:31 <autrijus> there is actually a very pleasant, purely functional sublanguage that I can implement first.
19:50:56 <autrijus> with pattern matching, currying, subtyping and other pleasant properties
19:51:04 <autrijus> and some type inferencing.
19:51:40 <autrijus> I'm pretty sure I can't use that to define the rest... references and side effects can't be handled that way
19:52:03 <shapr> Well... monads are pure and side-effecty...
19:52:12 <shapr> Probably wouldn't be pleasant though.
19:52:29 <autrijus> perl6 allows side effects at compile time.
19:52:35 <autrijus> so, heh.
19:52:46 <shapr> Might require Template Haskell...
19:53:09 <autrijus> true...
19:53:55 <autrijus> but hey, I'm writing an interpreter, not a perl6-to-haskell compiler
19:54:15 <shapr> good point
19:55:51 <shapr> I've been thinking about monochrom's amusing quote where "turing was never born, graph reduction was the basis of computing" and wondering how FP-oriented CPUs would work.
19:56:40 <shapr> I can't think of any good approaches.
19:56:52 <Gahhh> like Backus' paper
19:57:01 <Gahhh> "Can programming be liberated..."
19:57:14 <Gahhh> You should write one and become famous
19:58:09 <ozone> autrijus: have a URL for featherweight perl6?
19:58:37 <shapr> Everything I've thought of would require hardware GC. I've thought of how to do that with non-CC NUMA, but it would also require incremental GC for real usefulness.
19:58:39 * shapr ponders
19:59:48 <shapr> I can't figure out how to construct an alternate reality where computing started with FP.
20:00:02 <Gahhh> Isn't there any research at any university on alternate computing architectures ?
20:00:36 <shapr> I don't know. I should check out the LispM CPU.
20:01:21 <wli> Gahhh: Not anymore, no. x86 uber alles in die Welt
20:01:28 <Gahhh> heh
20:01:32 <autrijus> ozone: I'll write a journal entry about it.
20:01:48 <shapr> autrijus: where's your journal?
20:01:50 <Gahhh> "in der Welt", since you are almost correct.
20:02:18 <autrijus> shapr: http://use.perl.org/~autrijus/journal/
20:02:20 <Gahhh> however it is true that the current architectures have massive amounts of research, tool support, etc. behind them
20:02:44 <autrijus> and PCs run lisp faster than Lisp machines.
20:02:48 <shapr> Oh, I just thought of a weird approach. An FPGA could actually be the program. It could reduce and restructure itself.
20:03:10 <shapr> Not really FP though.
20:03:23 <shapr> autrijus: yay!
20:03:51 <shapr> When's your next visit to Scanned In Avia?
20:04:08 <autrijus> o/~ Einigkeit und Recht und Freiheit / fuer das Quantum Vaterland o/~
20:04:17 <autrijus> shapr: you mean the blog or the geographic region?
20:04:24 <shapr> geographic region
20:04:38 <shapr> I was just looking at your itinerary.
20:04:57 <autrijus> oh. I hope I can make it on september to estonia
20:05:08 <shapr> to ICFP?
20:05:11 <autrijus> yeah.
20:05:14 <heatsink> shapr: FPGAs are only advantageous when you configure once, reuse many times.
20:05:19 <autrijus> and if I can, I'll also contemplate flying over to scannedinavia after that.
20:05:24 * shapr grins
20:06:00 <autrijus> since I vowed to not touch U.S. soil on the next 4 years, my yearly OSCON trip has to be replaced by something else.
20:06:03 <shapr> heatsink: yes, but I'm constructing an alternate reality. Anyway, that's only true if you're talking about the out-of-chip bandwidth limitations. In-chip speed is as fast as you can go.
20:06:04 <autrijus> estonia looks beautiful.
20:06:25 <heatsink> shapr: There has been a lot of work in designing processors that reconfigure every cycle.  These include, for example, any superscalar architecture.
20:06:32 <Gahhh> The current hardware building blocks all have state and favor automatons.
20:06:47 <Gahhh> automata ugh
20:07:12 <shapr> I haven't visited estonia before, I'm sure it'll be fun.
20:08:33 <icb> has anyone here successfully compiled GHC 622 from source on a mac?
20:08:39 <icb> i have been trying it for 2 days
20:09:06 <Gahhh> desrt is the guy to ask about ghc compilations
20:09:06 <shapr> What sort of error are you getting?
20:09:22 <icb> well, i backed out of the fink port
20:09:36 <icb> grabbed the 622 pkg dmg from the website
20:09:49 <icb> built/installed happy and alex
20:09:58 <shapr> Hiya monochrom, I've just been trying to figure out the alternate reality you described.
20:10:10 <dons> icb: 6.2.2 is building nightly on the mac, let me find you the log
20:10:20 <icb> now it is failing at /usr/local/lib/ghc-6.2.2/include/HsReadline.h:5:31:
20:10:26 <monochrom> ah ha
20:10:38 <icb> and i already have a -I and -L in my CPPFLAG and LDFLAG env
20:10:53 <icb> for the libreadline i installed
20:10:57 <dons> readline is always an issue on the mac, it seems
20:11:51 * icb is 80% done with SOE
20:12:04 <dons> http://www.haskell.org/pipermail/cvs-all/2005-January/037986.html
20:12:10 <icb> after chapter 18, things gets abstract progressively
20:12:21 <icb> loading..
20:12:23 <dons> so it does build on the mac. you could check the logs for appropriate flags
20:13:36 <icb> that is a full build the the existing 6.2-stable branch right?
20:13:39 <shapr> monochrom: But I can't find the quote at the moment. How did it go? Turing was never born, hardware was based on graph reduction?
20:13:53 <Pseudonym> Errr...
20:14:03 <Pseudonym> OK, so I try to find stylesheets for magazine-type documents.
20:14:07 <dons> icb: yep. the branch is as same as the release. at least, I haven't seen any new commits
20:14:11 <Pseudonym> And I search for "latex magazine".
20:14:16 <shapr> oh no
20:14:17 <Gahhh> Pseudonym, lol
20:14:18 <Pseudonym> There are some weird magazines out there.
20:14:35 <dons> that is so funny
20:14:49 <Pseudonym> This reminds me when I decided to find out once and for all the air speed velocity of an unladen swallow.
20:15:03 <Pseudonym> You don't want to know what sites turn up if you search for "speed swallow".
20:15:07 <Gahhh> you need quotation marks
20:15:14 <dons> dear oh dear
20:16:02 <Gahhh> I think there is a free magazine out there in the GNU sense and they were using LateX
20:16:13 <monochrom> I didn't write a quote.  I have said it in various wordings at various times to various people.  Also I didn't make Turing disappear; rather, I just replaced von Neuman by some person who eloquently explained how to build a graph reduction machine.
20:16:50 <shapr> monochrom: I had saved it in a quotefile somewhere, but I can't find it now.
20:17:02 <shapr> hiya dustin` 
20:17:06 <Gahhh> Pseudonym, check out www.freesoftwaremagazine.com. It may be helpful.
20:17:23 <monochrom> Ah, if you can find it, good; otherwise, I can't find it either (I didn't save it :)
20:18:08 <Pseudonym> They accept in RTF.
20:18:13 <Pseudonym> Or in XML.
20:18:59 <shapr> Aha, I found it in my blog.
20:19:18 <shapr> http://www.scannedinavian.com/2004-11-24.html
20:20:05 <ozone> autrijus: what's the link to your journal?
20:20:20 <autrijus> ozone: http://use.perl.org/~autrijus/journal/
20:20:30 <ozone> ooo, YAPU
20:20:33 <ozone> (Yet Another Perl User)
20:20:55 <ozone> awesome!  perl interpreter in haskell
20:21:08 <Pseudonym> They prefer to be known as Just Another Perl Hacker.
20:21:24 <autrijus> yes.
20:21:35 <ozone> Pseudonym: that title is reserved for the Perl cognescenti!
20:21:50 <autrijus> I think I qualify :)
20:22:01 * ozone bows to JAPH
20:22:04 <Pseudonym> No, it's reserved for anyone who can write a .sig-sized script which prints that, but is sufficiently obfuscated.
20:22:12 <ozone> <- definitely not JAPH
20:22:27 <Gahhh> I thought sufficient levels of obfuscation came with the territory
20:22:57 <shapr> monochrom: I haven't figured out what hardware would have been invented in that alternate reality, but it's burbling around in my head. Any ideas?
20:24:02 <monochrom> Not much from me either.  Need to really think "out of the box".
20:25:43 <monochrom> The path in our world's history --- electronic logic gates -> bitwise memory -> von Neuman machines --- seems natural.  You probably have to start with something other than logic gates.
20:26:54 <monochrom> Pardon my mispelling of Neuman; I forgot how to spell it.  (Tiring but fun day today.)
20:28:19 <shapr> maybe photorefractive crystals
20:29:13 <monochrom> Need some hardware that stores graphs (nodes and links) easily but deliberately inefficient for numbers.
20:29:22 <shapr> Since the essence of programmable is just able to affect self, then any 'recursive' effect like photorefractive, semiconductive, etc would work as a basis. Just have to find a basis that lends itself to FP.
20:29:53 <monochrom> flip-flops are too efficient for storing numbers that it's downhill from that point onwards.
20:30:47 <shapr> A photorefractive computer would be where you set up a self propagating machine in a big chunk of crystel. Sort of like dynamic ram CPUs.
20:31:42 <monochrom> Whee, today has been tiring but fun, I have unprecedent intuition and insight into everything.
20:31:48 <shapr> yay!
20:31:56 <shapr> Any clues how to make a heat semiconductor?
20:32:49 * shapr hasn't been able to find a heat semiconductive material in years of searching.
20:33:06 <Gahhh> are you trying to solve a hardware problem to solve the resulting software problem >
20:33:29 <shapr> what?
20:34:25 <Gahhh> you're trying to make new hardware 
20:34:30 <shapr> ok
20:35:41 <shapr> I'm just trying to figure what sort of hardware would lend itself more to a functional approach than a procedural approach.
20:35:51 <heatsink> what is a heat semiconductor?
20:36:29 <shapr> heatsink: Something that conducts heat in one direction, or at least, more easily in one direction. Just like an electrical semiconductor does for electrons.
20:36:52 <heatsink> There are semiconductor electronics that do that.
20:37:04 <shapr> Tell me more!
20:37:12 <heatsink> Apply current and they generate a temperature gradient, or vice versa.
20:37:33 <heatsink> quite inefficient, though.
20:37:39 <shapr> thermocouples... but they don't conduct heat more easily in one direction or the other... do they?
20:38:11 <shapr> Hm, I guess they'd have to... you'd need some sort of resistance to created electricity?
20:38:25 <heatsink> Anything that conducts heat more easily in one direction than the other needs work as input. Otherwise it violates the laws of thermodynamics.
20:38:46 <shapr> What about semiconductors? What do they do?
20:39:19 <shapr> Do they not violate the laws of thermodynamics?
20:39:33 <heatsink> aha: it's called a peltier junction.
20:39:55 <heatsink> No, semiconductors don't violate laws of thermodynamics.  Where do they seem to?
20:41:12 <shapr> If electrons can only go in one direction, why can't heat only go in one direction?
20:41:59 <heatsink> heat is primarily carried by lattice vibrations.  Those are not blocked by PN junctions.
20:42:21 <monochrom> electronic semiconductors are royally inefficient too.
20:42:30 <shapr> Is there a way to make lattice vibrations work more easily in one direction than another?
20:42:43 <Pseudonym> They're more efficient than vacuum tubes.
20:42:59 <monochrom> need... maxwell's... demon...
20:43:03 <shapr> hehe
20:43:19 <autrijus> is the demon named MaxBSD?
20:43:35 <shapr> Maybe there's some PN junction for heat?
20:43:40 * shapr shrugs
20:43:52 <heatsink> I would be very surprised if such a thing were to exist.
20:43:58 <monochrom> nanotechnology probably provides a way to implement maxwell's demon.  again, it will cost you energy, but it's possible if you pay.
20:43:59 <autrijus> is there similar constructs as perl6 junctions in haskell/ml?
20:44:19 <Pseudonym> What's a perl6 junction?
20:44:27 <dons> I would think almost certainly... but what's a junction?
20:44:33 <autrijus> "JuncOr [1,2,3] * 4" ==> "JuncOr [4,8,12]"
20:44:41 <autrijus> "JuncOr [1,2,3] == 1" ==> True
20:44:49 <autrijus> "JuncAnd [1,2,3] == 1" ==> False
20:44:52 <monochrom> pn junction : semiconductor :: perl6 junction : semisoftware ?
20:44:56 <shapr> hiya fraxtal
20:45:08 <fraxtal> shapr: Hey how's it goin?
20:45:18 <shapr> Code is good, how're you?
20:45:26 <autrijus> you can use junctions whenever you can use values.
20:45:36 <fraxtal> shapr: Learning this Haskell thing
20:45:43 <Pseudonym> autrijus: Two things.
20:45:52 <shapr> I like this Haskell thing from what I've seen so far.
20:45:53 <Pseudonym> First, that's magic semantic overloading.
20:45:55 <autrijus> data Junction a = JuncOr [a] | JuncAnd [a] | JuncXor [a].
20:45:57 <Pseudonym> Haskell doesn't have that.
20:46:03 <shapr> fraxtal: you have any questions?
20:46:08 <Pseudonym> However, we do have equivalents.
20:46:17 <Pseudonym> And generalisations.
20:46:20 <Pseudonym> e.g. the list monad
20:46:33 <Pseudonym> do { x <- [1,2,3], return (x*4) }
20:46:34 <fraxtal> shapr: hmm let me find this snippet of code and paste it somewhere
20:46:35 <autrijus> so you mean I can specialize listmonad.
20:46:46 <shapr> @wiki HaskellIrcPastePage
20:46:46 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
20:46:58 <Pseudonym> As for the two other examples, they reduce lists to values.
20:47:00 <autrijus> so that by binding them I can mix all() and any().
20:47:02 <Pseudonym> We have things like that.
20:47:04 <Pseudonym> @type all
20:47:05 <lambdabot> all :: forall a. (a -> Bool) -> [a] -> Bool
20:47:08 <fraxtal> Good you guys have your own pastebin
20:47:10 <Pseudonym> @type any
20:47:11 <lambdabot> any :: forall a. (a -> Bool) -> [a] -> Bool
20:47:16 <monochrom> "JuncOr [1,2,3]*4 == 1" = any (== 1) $ map (* 4) [1,2,3]
20:47:27 <Pseudonym> Right.
20:47:32 <monochrom> replace any by all for JuncAnd
20:47:51 <autrijus> right. the semantic magic is merely that you can overload all/any/one.
20:48:23 <autrijus> in the sense that there is a multimethod dispatch that pattern-matches on any operator on Junc* and apply the neccessary any/all/one.
20:48:27 <monochrom> Now you have made me hate Perl 6 already.
20:48:44 <autrijus> ha.
20:48:56 <Pseudonym> If it helps, you can kind of implement it in Haskell.
20:49:02 <ozone> autrijus: btw, have you seen python's generator expressions?
20:49:03 <Pseudonym> Using typeclasses and fundeps.
20:49:07 <ozone> (as opposed to their normal generators)
20:49:35 <shapr> heatsink: http://en.wikipedia.org/wiki/Peltier-Seebeck_effect this implies that heat charge carriers are affected by a variety of things... impurities, imperfections, lattice vibrations...
20:50:03 <heatsink> "heat charge carriers"?
20:50:10 * shapr shrugs
20:50:12 <shapr> news to me too
20:50:33 <autrijus> ozone: yes.
20:50:44 <monochrom> What I hate: what can be normally done by higher-order functions and HM polymorphism, they do by introducing yet another syntactic extension.
20:50:45 <autrijus> Pseudonym: to take a concrete example:
20:50:47 <fraxtal> shapr: http://erxz.com/pb/349 Can you look at this?
20:50:47 <autrijus> sub has_twin ($n) { is_prime($n) && is_prime($n + any(2,-2) }
20:50:47 <autrijus> sub is_prime ($n) { $n % all(2..sqrt($n)+1) != 0 }
20:51:12 <autrijus> monochrom: oh but this is but a general case of higher-order functions in perl6.
20:51:17 <monochrom> The process doesn't scale.  It makes no software engineering sense.
20:51:20 <shapr> fraxtal: looks simple enough.
20:51:20 <autrijus> monochrom: i.e. any/all/&/| are user-defined.
20:51:37 <autrijus> monochrom: they are implemented in perl6's equivalent of Prelude as pure perl6 code.
20:51:43 <autrijus> monochrom: so you are free to swap them out.
20:51:49 <fraxtal> shapr: Oh I left out a part http://erxz.com/pb/350
20:52:28 <shapr> fraxtal: there's a piece missing.. you have a single tick where something else should be.
20:52:30 <autrijus> monochrom: so in this regard it's not worse than . or $ or $! 
20:52:33 <Pseudonym> hasTwin n = isPrime n && any isPrime (map (n+) [2,-2])
20:52:41 <fraxtal> shapr: Oh that's supposed to be a 1
20:52:42 <Pseudonym> Rough equivalent.
20:52:47 <monochrom> Is there "map" in Perl 6?
20:52:54 <autrijus> monochrom: sure. and perl5 too.
20:53:18 <autrijus> we are not complete barbarians, you know :)
20:53:26 <Pseudonym> But it's nicer with list comprehensions:
20:53:31 <monochrom> Alright, then it's less ugly.  But the syntax of "JuncOr [1,2,3]*4 == 1" is ugly.
20:53:46 <shapr> fraxtal: you could use guards if you want to abstract some.
20:53:47 <autrijus> monochrom: that was my haskell approximation.
20:53:49 <Pseudonym> isPrime n = all (/=0) [ n % f | f <- [2..n-1] ]
20:53:56 <autrijus> monochrom: in perl6 code that will be
20:53:58 <fraxtal> shapr: How do you do that?
20:54:02 <autrijus> (1 | 2 | 3) * 4 == 1
20:54:10 <autrijus> or
20:54:10 <Pseudonym> (It's a little trickier to do the sqrt because there's no integer square root.  You'd have to do conversions.)
20:54:13 <autrijus> any(1,2,3) * 4 == 1
20:54:23 <shapr> @wiki HaskellDemo
20:54:23 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
20:54:34 <shapr> fraxtal: HaskellDemo talks about guards, among others things.
20:54:43 <autrijus> Pseudonym: right. I think the idea is passing the any(1,2,3) as values to functions.
20:55:21 <autrijus> Pseudonym: which come to think about it, in the isPrime example above, one can do it by instancing the Junction data type as Num etc.
20:55:34 <Pseudonym> Yes, but it's the "etc" which gets you.
20:55:45 <Pseudonym> A more idiomatic way to do it in Haskell is to use monadic code.
20:55:54 <autrijus> and instance it as a Functor.
20:56:03 <Pseudonym> And the user can use the list monad (if they want multiple values) or the identity monad (if not) as they please.
20:56:11 <autrijus> (as well as a Monad.)
20:56:35 <autrijus> but then, mixing any() and all() will be done as monad transformers on top of each other?
20:56:54 <autrijus> or maybe the monad can be pameterized of which kinds of nested junctions are in effect.
20:57:03 <autrijus> parameterized, even
20:57:16 <fraxtal> shapr: Haskell is really different than anything I've ever seen before but I like it
20:57:26 <Pseudonym> As I see it, any and all tend not to get mixed in certain places.
20:57:33 <monochrom> I want to see what happens when mixing any and all in Perl 6.  any(1,2,3) == all(1,2,3)  what will happen?  all(1,2,3)==any(1,2,3)  what about this?
20:57:43 <shapr> fraxtal: yeah, Perlis had a neat quote, something like "Any programming worth learning should change the way you think about programming."
20:58:21 <fraxtal> monochrom: Did cale point in you in this direction too? :)
20:58:31 <autrijus>  1|2 + 3&4;  ==> (4|5) & (5|6)
20:58:44 <shapr> oops, I left out the word "Language"
20:58:55 <shapr> I give up, I'm going to sleep...
20:58:57 * shapr disappears
20:59:19 <autrijus> monochrom: the full spec is http://dev.perl.org/perl6/synopsis/S09.html "Junctions"
20:59:36 <Pseudonym> Night.
20:59:37 <autrijus> monochrom: a valid implementation, already available in perl5, is in http://search.cpan.org/dist/Quantum-Superpositions/lib/Quantum/Superpositions.pm
20:59:48 <autrijus> I've been using it a while now. :) 
20:59:56 <monochrom> ok, "all list contexts are lazy by default", way to go, I like that one.
21:00:02 <Pseudonym> I was at the conference when Damian presented Quantum::Superpositions.
21:00:10 <Pseudonym> I objected, I think.
21:00:20 <Pseudonym> Real quantum observations don't work like any and all.
21:00:29 <autrijus> Pseudonym: right. he repented and renamed it junctions.
21:00:55 <Cale> me?
21:02:14 <autrijus> Pseudonym: damian hopes to use junctions to auto-parallelize perl6 code. I don't have enough knowledge in this area to tell whether he's serious or not.
21:02:47 <Pseudonym> Basically he's going to run into the same problems that everyone else who has tried it has run into.
21:02:59 <Pseudonym> See also the "implicit parallelism" thread on the Haskell mailing list.
21:03:07 <autrijus> ok.
21:03:25 <Pseudonym> But he's welcome to try.  It's his grant money.
21:03:32 <monochrom> Alright, I know how to give a mathematical (denotational) semantics to junctions.
21:04:12 <autrijus> wow.
21:04:23 <autrijus> <- implementing junctions in pugs right now
21:04:50 <monochrom> don't be scared by "denotational".  Other people give scary denotational semantics; but mine are user-friendly.
21:05:06 <autrijus> ok. enlighten me? :)
21:06:06 <fraxtal> Cale: CALE
21:06:27 * fraxtal hugs Cale
21:07:09 <monochrom> I'll use an example.  "any(4,5,6)==all(1,2,3)" = forall x in {1,2,3}. exist y in {4,5,6}. x==y.
21:07:46 <monochrom> it is forall...exist rather than exist...forall because some rule says that "all" takes higher precedence than "any".
21:08:16 <autrijus> yes. all(), even if nested inside, are raised to higher precedence
21:08:20 <Pseudonym> Aha.
21:08:29 <monochrom> You can also think of "all" as demonic choice and "any" as angelic choice.
21:09:14 <autrijus> I wonder what about one().
21:09:42 <monochrom> The "autothreading" part is some very nice distributive laws.  There is a nice algebraic (axiomatic) semantics there.
21:10:12 <monochrom> I have not understood "one" yet.  Nothing is said on the page.
21:10:55 <autrijus> one(1,2,3)==1 ==> True
21:11:02 <autrijus> one(1,2,3)>1 ==> False
21:11:07 <autrijus> that's the intuition.
21:11:09 <monochrom> I see, "one" comes from exclusive or.  This is going to be difficult.
21:11:27 <autrijus> yes. it's the one I'm currently having trouble with.
21:11:39 <autrijus> the intuition is easy.
21:11:43 <autrijus> implementing is hard :)
21:12:36 <autrijus> (also it is not yet specified what happens when you use one(), any() or none() in LHS.)
21:12:44 <Lemmih> Good morning, #haskell!
21:12:53 <monochrom> You are beginning to see that intuitions and a few examples don't explain anything.  If you have no semantics you can't implement.
21:12:53 <autrijus> which I'm going to ignore because this is featherlight perl, I don't have assignments yet
21:13:06 <autrijus> monochrom: that is correct.
21:14:44 <monochrom> But I commend them for popularizing the words conjunction, disjunction, abjunction, injunction.
21:15:13 <autrijus> lol
21:15:29 <Gahhh> +5 points for multisyllabels
21:15:59 <autrijus> the type signatures in perl6 are also junctive.
21:16:07 <Pseudonym> So Damian is doing for Latin prepositions what Erik Meijer did for Greek ones?
21:16:33 <autrijus> Pseudonym: what did erik do?
21:16:44 <autrijus> blahmorphism?
21:16:46 <Pseudonym> catamorphism, anamorphism, hylomorphism...
21:16:48 <Pseudonym> Right.
21:16:57 <autrijus> that sounds about right.
21:18:07 <monochrom> This is important because "if you have and and or, what do you do" is pretty hard to read, but "if you have conjunction and disjunction, what do you do" is clear.
21:18:59 <autrijus> is "if you have fold, then unfold, then unfold and fold" hard to read too? :)
21:19:56 <shrimpx> perl6 has types?
21:20:08 <autrijus> shrimpx: yes, and inference.
21:20:12 <shrimpx> wow
21:20:29 <autrijus> and typecasing, well sort of, they call it multimethod dispatch
21:20:36 <monochrom> My supervisor E.C.R. Hehner has a "bunch theory" in his book.  It is equivalent to "any" in Perl 6.  He doesn't have the other junctions.  (He will be delighted to theorize the extra ones, I'm sure.)  The book is at http://www.cs.toronto.edu/~hehner/aPToP/ if you are interested.
21:20:48 <autrijus> I am.
21:20:49 * autrijus goes to read
21:21:02 <autrijus> online book++
21:21:29 <monochrom> My students probably want to know that Perl 6 now implements bunch theory, too.  It is no longer a theoretical curiosity.
21:23:02 <fraxtal> monochrom: What do you teach?
21:23:12 <monochrom> My supervisor's book.
21:23:21 <autrijus> perl5 too, via the unfortunately ill-named Quantum::Superposition module :)
21:23:42 <autrijus> it only has any() and all() though.
21:24:29 <monochrom> Alright, today has been wonderful.  Beautiful things abound everywhere.
21:24:53 <icb> what's going on mono
21:25:11 <icb> what beautiful things
21:26:35 <autrijus> it's strange when #haskell likes perl6 far more than #perl do :)
21:26:40 <autrijus> <quote>
21:26:42 <autrijus> Programming in Perl5 is like exploring a large medieval castle, surrounded by a dark, mysterious forest, with something new and unexpected around each corner. There are dragons to be conquered, maidens to be rescued, and holy grails to be quested for. Lots of fun.
21:26:46 <autrijus> Perl6 looks like a Louis-XVI castle and garden to me. Straight, symmetric, and bright. There are wigs to be powdered, minuets to be danced, all quite boring.
21:26:47 <monochrom> Today I have understood more about "termination" than before; read a paper on subtyping vs. inheritance; and now this junction thing that generalizes bunch theory.
21:26:50 <autrijus> </quote>
21:26:58 <Pseudonym> Beautiful things.
21:27:32 <Pseudonym> WHo wrote that, autrijus?
21:27:38 <autrijus> Pseudonym: abigail, an important perl5 hacker.
21:27:57 <Pseudonym> Yes, I've met Abigail.
21:27:57 <autrijus> it represent the majority of the current perl5 community consensus.
21:28:19 * Pseudonym hasn't been in the Perl community for a while
21:28:21 <autrijus> which is kind of sad. :)
21:28:29 <Pseudonym> But I presented a paper at TPC 4.
21:28:30 <monochrom> Then woe to be them.
21:28:31 <icb> sometimes things just naturally fit
21:28:52 <autrijus> Pseudonym: oh? what paper is that?
21:30:01 <monochrom> Woe to them.  medieval castle ==> dark age, louis-xvi ==> age of enlightenment.  Really, they are saying they prefer the dark age.  Fun they have, surely, but what about software engineering ethics?
21:30:01 <Pseudonym> Bailey, N., Bromage, A. & Creer, A. (2000). My.University: Personalized portals in Perl. In J. Orwant (Ed.), Proceedings of the Perl Conference 4.0 (pp. 51-59). Monterey, California, USA: O'Reilly & Associates.
21:31:02 <ozone> autrijus/Pseudonym: are either of you running Windows right now, and use Firefox?
21:31:15 <ozone> if so, i have something perl-related you may like to play around it for 5 minutes, if you have time
21:31:17 <fraxtal> I wonder if people still code in ML
21:31:20 <autrijus> ozone: sure.
21:31:29 <Pseudonym> How dare you.
21:31:33 <Pseudonym> Like I would run Windows.
21:31:33 <monochrom> I coded in ML but I am moving towards Haskell.
21:31:35 <shrimpx> fraxtal: sure
21:32:02 <ozone> autrijus: http://www.annodex.net/software/AnnodexFirefoxExtension/
21:32:05 <shrimpx> i code in ML and get picked on by haskell types all the time
21:32:09 <ozone> autrijus: install the extension, and have a look at the YAPC video :)
21:32:16 <monochrom> I don't pick of you.
21:32:16 <fraxtal> shrimpx: Is it fun?
21:32:19 <autrijus> ooh theora?
21:32:21 <ozone> autrijus: (you'll need a >= 512k broadband link, too)
21:32:24 <monochrom> err s/of/on/
21:32:44 <shrimpx> fraxtal: ML? sure, i like it. it has a module system =D
21:32:54 <monochrom> Just for today the haskell types don't pick on it.
21:33:04 <monochrom> err s/it/you/
21:33:09 <shrimpx> yay
21:33:34 <monochrom> Tomorrow you will stop saying "they pick on me all the time" because the statement will be false.
21:33:48 <autrijus> ok, let's see if this extension works...
21:34:05 <autrijus> I need to reboot to freebsd soon. win32 makes me feel out of air.
21:34:07 <shrimpx> however "most of the time" will still hold
21:34:12 <monochrom> Heh
21:34:20 <ozone> autrijus: if it doesn't, please tell me :)  (i'm the author)
21:34:49 <autrijus> it works!
21:34:53 <autrijus> whoa!
21:35:04 <monochrom> I don't understand what is there to pick on.  I don't even pick on Java programmers.
21:35:08 <ozone> Pseudonym: it'll be out soon for linux, promise!
21:35:33 <ozone> autrijus: hopefully you'll have enough bandwidth to stream it
21:35:48 <autrijus> it went smooth for a while
21:35:52 <autrijus> on 0:56 it stuck
21:35:56 <autrijus> will it rebuffer?
21:36:00 <ozone> it should, yeah
21:36:02 <Pseudonym> ozone: Cool.
21:36:03 <ozone> we're using VLC to do the playback
21:36:15 <ozone> and that has ... interesting ... HTTP streaming behaviour
21:36:15 <autrijus> yes it does
21:36:49 <ozone> autrijus: double-click on the different clips to jump to them; it'll do a server-side seek
21:38:15 <autrijus> I did that.
21:38:19 <autrijus> cool extension!
21:38:36 <ozone> good good
21:38:44 <ozone> glad it works for you
21:38:50 <ozone> and that perl video is hilarious if you haven't seen it yet :)
21:38:52 <autrijus> ozone++ # nice to know theora is alive and kicking
21:38:58 <autrijus> I've seen it multiple times :)
21:39:02 <autrijus> and the ones after that :)
21:39:03 <ozone> i'll have to email gnat about it once i get the linux plugin out
21:39:06 <ozone> there's more?
21:39:13 <ozone> wherewhere?  i need to annodex them! :)
21:39:24 <monochrom> what is annodex?
21:40:02 <ozone> autrijus: yeah, theora as a codec is not bad; it's fairly competitive with the 3rd-gen video codecs (h.h263, divx).  problem is that the tools for it totally suck, so it doesn't get used much
21:40:07 <ozone> monochrom: www.annodex.net
21:40:10 <autrijus> ozone: there is a movie for each year's yapc, and recently on oscon
21:40:14 <autrijus> I don't have the links handy
21:40:19 <ozone> ok
21:40:21 <autrijus> ask gnat :)
21:40:22 <ozone> i'll go have a look.  thanks
21:40:34 <autrijus> oh and there's my movie :)
21:40:41 <ozone> oh, who are you?
21:41:05 <autrijus> http://www.perl.org/tpc/2003/movies/perl-lt/
21:41:23 <autrijus> i'm just another perl hacker :)
21:41:24 <ozone> awesome
21:42:09 <ozone> autrijus: you're mad
21:42:37 <autrijus> thank you.
21:42:48 <autrijus> wait till the end
21:46:00 <ozone> autrijus: *applause*
21:46:10 * autrijus bows
21:46:15 <autrijus> slides are at http://wagner.elixus.org/~autrijus/favcpan/start.html
21:46:22 <autrijus> I don't know if your annodex does unicode/chinese.
21:46:32 <ozone> the clip descriptions are all XML
21:46:35 <ozone> so, basically, yes
21:46:45 <autrijus> good good
21:47:12 <ozone> sheesh!  your slides are even more mad
21:47:24 * autrijus smiles
21:58:59 <autrijus> despite the darkness of the language, CPAN is too much fun to live without :)
21:59:07 * autrijus works some more on the underappreciated perl6 implementation
23:21:02 <musasabi> morning
23:25:24 <Lemmih> Good morning, musasabi.
23:39:58 <pesco> Mornin' everyone!
23:45:37 <Itkovian> morning #haskell
23:45:45 <autrijus> morning
23:50:33 <pesco> Four people up. Greetings Itkovian and autrijus, how are you? How's code?
23:52:02 <Heffalump> morning
23:52:14 <pesco> Hi Heffalump.
23:54:51 <pesco> Heffalump: Had any success with your timeouts?
23:58:59 <autrijus> is it ok for me to keep using Perl6UsersGolfingSystem and FeatherweightPerl6 wiki pages to document my designs? I promise I won't pollute the rest of the wiki with more pages :)
23:58:59 <Heffalump> nope.
23:59:06 <Heffalump> I need to ask the ML
