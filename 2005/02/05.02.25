00:05:26 <desrt> damn
00:06:58 <desrt> shapr's talk of sake sent me on a 3hour wikipedia expedition
00:08:09 <shapr> wah?
00:08:19 <desrt> you know how it is with wikipedia
00:08:22 <desrt> they have all of these links
00:08:30 <desrt> and you keep clicking them....
00:09:15 <shapr> oh yeah
00:09:24 <shapr> I'm like that with sake. Have to keep drinking.
00:09:32 <desrt> :)
00:09:34 <shapr> Which is weird, since I don't like beer or wine.
00:09:44 <desrt> i like wine if it's dry
00:09:47 <desrt> preferably red
00:10:01 <desrt> beer is a no-go, though
00:10:04 <shapr> I think the that idea of fermented herring and fermented grapes are equally appealing.
00:10:32 <shapr> Dunno why fermented rice tastes good though.
00:10:36 <desrt> i think that the idea of a dell 20" LCD is somewhat more appealing
00:10:43 <tuomov> beer's good too. real beer, not piss-lager
00:11:02 * ozone pats his dell 20" LCD
00:11:11 <desrt> ozone; wide or normal?
00:11:19 <shapr> I've tried a lot of different beers, but I just don't like the taste. Tastes like something died in there.
00:11:23 <ozone> desrt: wide
00:11:26 <desrt> aw :(
00:11:28 <desrt> wide = suck
00:11:32 <ozone> once you go wide, you can't go back
00:11:36 * tuomov 's at a library where they're running 1024x768 or 1280x1024 tft at 800x600. sucks.
00:11:37 <desrt> i have wide at work
00:11:47 <desrt> i don't particularly care for the reduction in screen space
00:12:28 <desrt> the -only- positive quality of widescreen is that 1680 pixels is enough to put two 80-character-wide 'Andale Mono 13' terminal windows side by side
00:12:35 <desrt> whereas 1600 pixels is not
00:12:39 <ozone> well, the dell is rotatable, if that floats your boat.  though i only use it when staring at ... nice ... photos ... of ... certain ... things
00:12:56 <desrt> xrandr doesn't work for rotation for me for some reason
00:13:10 <tuomov> xrandr doesn't support rotation
00:13:10 <ozone> desrt: ah well, i just like the profile better
00:13:15 <desrt> uh
00:13:22 <desrt> RandR stands for "resize and rotate"
00:13:29 <tuomov> yes it does, but rotation has never been implemented
00:13:32 <ozone> and gamers swear that widescreen is the bomb, though i don't do gaming on this monitor
00:13:34 <desrt> yes.  it has.
00:13:41 <tuomov> I've looked into it, trying to add support to ion
00:13:51 <desrt> look no further than the freedesktop.org xserver
00:14:00 <desrt> it's been implimented for about 2 years
00:14:01 <tuomov> fdo. lol.
00:14:04 <tuomov> totally useless
00:14:22 <tuomov> reduce screen drawing to crawling speed
00:14:24 <desrt> take it back.
00:14:54 <tuomov> I'll check out fdo when it fully supports my nvidia
00:15:00 * desrt decides to vanity-idle
00:15:00 <tuomov> tv out, 3d etc.
00:17:45 <desrt> shapr; does the haskell.org host have irssi installed? :)
00:31:52 <shapr> er, I dunno.
00:33:07 <lightstep> is there an xlib binding for haskell (or ghc)?
00:33:45 <desrt> there are all sorts of higher level toolkit bindings
00:33:46 <desrt> like gtk
00:34:15 <lightstep> i want to experiment with window managers. so if it's not haskell, i'll hack C
00:34:56 <tuomov> You need a very small subset of X for a basic WM
00:35:06 <lightstep> yes
00:35:06 <tuomov> so it should be quite easy to write the ffi definitions
00:36:13 <lightstep> is the ffi addendum clear enough to learn from?
00:36:15 <tuomov> perhaps the biggest part are the event structures
00:37:05 <tuomov> I never read any ffi docs for what little curses+iconv interfacing I had to do for riot..
00:37:27 <lightstep> so i gather it's easy
00:37:36 <lightstep> ok, i gotta go, thank you anyhow
00:38:28 <musasabi> there is an xlib binding.
00:38:46 <desrt> where is it?
00:38:54 <musasabi> Graphics.X11
00:38:59 <desrt> huh
00:39:16 <desrt> so it's one of those things that cause ghc to take longer to build than it ought to  :)
00:39:18 <musasabi> fptools/libraries/X11
00:40:41 <tuomov> Indent, comes with gcc
00:40:44 <tuomov> s/cc/hc/
00:41:11 <tuomov> s/indent/indeed/
00:41:14 <tuomov> *sigh*
00:44:57 <desrt> continuing to be awake is really dumb
00:46:09 <shapr> I wish I could sleep.
00:47:25 <desrt> you can
00:47:31 <desrt> it must be getting close to ciesta time for you
00:47:42 <desrt> siesta even
00:47:50 <shapr> it's almost 10am.
00:48:00 <desrt> well.. siesta is in 3 hours :)
00:52:12 <musasabi> What would be the correct place in the module hierarchy for an alternative Network library? Network.Alt.* ?
00:56:07 <shapr> I vaguely recall someone suggesting a User.* or Unstable.* hierarchy, but that doesn't sound right for an alternative network lib.
00:57:19 <shapr> y0 Mistah Eye
00:57:24 <shapr> wazzup?
00:57:48 <shapr> Oejet: was I misreading the former username? was it really eyeleen?
00:59:21 <Oejet> shapr: You are gay today.
00:59:53 <shapr> Am not. Just a little peril.
01:00:16 * shapr misquotes Monty Python
01:01:51 * desrt goes to sleep now
01:01:56 <desrt> i do hope dbus is fixed by tomorrow
01:02:05 <desrt> nite shae, all
01:02:21 <shapr> gnite
01:03:03 <Oejet> shapr: I used my mothers computer for a week, so you didn't misread it.  She's American born.
01:03:03 <shapr> duncan_: did you say you got something significantly larger than a Coker?
01:03:07 <shapr> Ah, ok.
01:03:11 <shapr> I'm american born to.
01:03:13 <shapr> too
01:03:49 <Oejet> shapr: Speaking Swedish with a heavy American accent?
01:04:44 <shapr> That's me.
01:05:12 <shapr> yah har eengin on-eeng
01:05:32 <shapr> I can feel all the Swedes flinching even now :-)
01:06:08 <shapr> Sad thing is when Swedes ask me to repeat myself because they really had no clue what I just said. After about the third time, I just switch to english rather than continue embarassing myself.
01:06:46 <Oejet> shapr: What a motivating learning evironment.
01:06:49 <shapr> Weird thing is that only happens when I have enough sleep. When I don't have enough sleep my accent is better. I wonder if I'm trying to be too careful or something.
01:07:23 <shapr> Actually, gorgeous blonde woman are a motivating learning environment.
01:07:29 <shapr> women*
01:08:03 <Oejet> They properbly think it's cute.
01:08:25 <shapr> Some of them do. I think some of them just want to steal my unicycle.
01:08:59 <musasabi> Swedes speak swedish with a funny accent.
01:09:06 <Oejet> How fast can you go on a unicycle?
01:09:20 <shapr> musasabi: I actually agree with you. Southern swedes sound strange to me.
01:10:12 <musasabi> but that is probably because I am much more used to finlandssvensk.
01:10:37 <Oejet> I guess southern Sweden around Malmö sounds closer to Danish.  Easier to understand at least.
01:11:07 <shapr> Oejet: depends on wheel size. 29 inch aka 700c is about as fast as a normal bike, 36 inch is faster. I have a sturdy 24 inch mountain unicycle that's somewhat faster than jogging, but not as fast as cycling. But it can power through and over thick snow, logs, gravel, small children, etc
01:12:18 <Oejet> How can it be faster if it has no gearing?
01:12:20 <shapr> Though the time I was assaulted by a 50+ kilo dog.... this dog knew me and thought I was sitting down, and so could jump into my lap. We ended up doing a forward flip off the unicycle together.
01:12:40 <Oejet> He, he.
01:13:02 <shapr> I only wish I had video of that. It must have looked as crazy from the outside as it did from the inside.
01:13:58 <shapr> Speed can be higher because small cranks and a big wheel is like having a geared bicycle turned up to a really fast gear.
01:14:40 <shapr> Makes sense?
01:14:48 <Oejet> Shure, shapr.
01:16:12 <shapr> I'd like to get one of those 36" Cokers. http://www.coker.com/store/customer/product.php?productid=18208&cat=302&page=1
01:16:48 <shapr> They make bicycles that use two of those tires, they look wild.
01:18:08 <jlouis> heh, I should lears to ride on a unicycle someday
01:18:37 <shapr> Show up at EuroHaskell, I'll get you started.
01:18:42 <jlouis> heh
01:18:54 <shapr> Have you seen pix from last year?
01:19:39 <jlouis> nope
01:19:44 <Itkovian> meuning
01:20:23 <shapr> jlouis: http://andersca.org/gallery/eurohaskell?page=3
01:20:40 <shapr> That's John Hughes, author of "Generalizing Monads to Arrows"
01:20:40 <jlouis> heh, cool
01:20:56 <shapr> I'm the guy with the long hair.
01:21:36 <musasabi> eurohaskell is so near that avoiding going sounds hard.
01:21:59 <shapr> musasabi: You might enjoy it.
01:22:12 * shapr grins evilly
01:22:40 <musasabi> too many interesting things too near. (debconf is about 500m from home)
01:22:50 <shapr> 500m is nice.
01:23:39 <Itkovian> ozone: I've put up your pdf on the web, see http://sequence.complete.org/node/19
01:24:24 <earthy> when is eurohaskell?
01:24:37 <Oejet> How many participated?
01:26:28 <shapr> Oejet: Look at the pix, that's pretty much who was there.
01:26:39 <luqui> hey -- which is the "inferred type" and which is the "expected type"
01:26:56 <shapr> luqui: inferred is what it got, and expected is what it wanted.
01:27:05 <luqui> fair enough :-)
01:27:11 <shapr> luqui: do you have the code handy?
01:27:16 <earthy> errr...
01:27:22 <earthy> exactly the other way around
01:27:26 <luqui> the problem i was having was just an associativity issue
01:27:42 <luqui> so nevermind about the particular
01:27:51 <Oejet> Expected -->sqrt "abekat" <-- inferred.
01:27:55 <earthy> but, to be clearer: inferred is what it *calculated* the type to be, expected is what you specified it to be
01:28:08 <luqui> or what it inferred as a return type or something
01:28:38 <shapr> to be honest, what it's saying is that one part of the code says one thing, and another part of the code says something else.
01:28:53 <luqui> very specific
01:28:56 <luqui> :-)
01:29:13 <shapr> @type (**)
01:29:15 <lambdabot> (**) :: forall a. (Floating a) => a -> a -> a
01:29:24 <shapr> @type (^)
01:29:25 <earthy> @type (^)
01:29:26 <lambdabot> (^) :: forall a b. (Integral b, Num a) => a -> b -> a
01:29:27 <lambdabot> (^) :: forall a b. (Integral b, Num a) => a -> b -> a
01:29:31 * earthy smiles
01:29:48 <shapr> Both of those operators do the same thing, but they want different input types.
01:30:16 <shapr> If you hand them the wrong type, you get that sort of complaint about inferred vs specified.
01:31:11 <luqui> I know that much, I was just wondering the difference between "expected" and "inferred"
01:31:17 <luqui> but I think I've got a pretty good picture now
01:31:39 <jlouis> 3 + "hello" is also bound to give a type error. 3 has type Int, "hello" has type String. + is not specified for taking an Int as one operand and a String as the 2nd
01:32:15 <jlouis> it will probably bomb on the String
01:32:24 <luqui> haskell needs to learn from perl then.  Everybody knows that 3 + "hello" is 3 :-)
01:33:12 <shapr> Well, the real deal is that a type system is a simplified automated proof checker. You can use it to check different parts of your program against each other, or you can just skip around it with Dynamic or so.
01:33:34 <luqui> yeah, it's pretty cool
01:33:45 <luqui> most of these errors would only be caught at runtime by other languages
01:34:14 <earthy> @type (+)
01:34:16 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
01:34:16 <jlouis> exactly
01:34:26 <shapr> On the other hand, type systems like in Java and C don't seem very useful to me. They're not very helpful.
01:34:38 <luqui> but they're verbose!  they must be good!
01:34:50 * shapr mutters something about politicians
01:34:51 <earthy> um. they are helpful
01:35:01 <luqui> (of the C-like languages that are statically typed, I tend only to like C++, because of templates)
01:35:10 * earthy likes C
01:35:14 <earthy> for certain purposes
01:35:21 <luqui> (rather, only like C++'s type system)
01:35:30 <luqui> (and I don't like it that much)
01:35:30 <earthy> (such as writing kernel drivers)
01:35:37 * Itkovian likes C, but loathes C++
01:35:37 <luqui> (I should stop speaking in parentheticals)
01:35:40 <jlouis> shapr: any language where you have to type private int foobar (int bleh, int blah) { return bleh * blah; } when you meant foo = (*) is bad ;)
01:36:06 <luqui> Ahh, so that's the definition of bad
01:36:10 <luqui> I had been looking for that
01:36:32 <shapr> I just like my tools to be there when I want to use them, and get out of my way when I don't want to use them.
01:36:57 <shapr> Though I could say Python + C does that.
01:37:12 <luqui> or, oh, say, perl 6 :-)
01:37:20 <shapr> right, alternate hard and soft layers.
01:44:07 <luqui> how come this code compiles:
01:44:10 <luqui> ... = do
01:44:14 <luqui>   list <- stringList
01:44:21 <luqui>   let concatted = homogenConcat list
01:44:24 <luqui>   return concatted
01:44:28 <luqui> and this fails:
01:44:31 <luqui> ... = do
01:44:37 <luqui>   list <- stringList
01:44:49 <luqui>   return homogenConcat list
01:44:52 <luqui> I know why
01:44:58 <luqui> answered my own question
01:45:02 <luqui> silly left-associative composition
01:51:56 <boegel> does anybody know why emacs always creates this anoying *.*~ files, and how I can avoid it ?
01:52:06 <jlouis> boegel: backup files
01:52:07 <shapr> boegel: M-x customize-group backup
01:52:25 <shapr> something like (setq backup-dir "~/.backup")
01:52:51 <Oejet> (setq backup-directory-alist '(("." . "~/.emacs.d/Backup/")))
01:53:39 <Oejet> Then they will be autosaved in ~/.emacs.d/Backup/
01:54:02 <boegel> Oejet: that should be in .emacs ?
01:54:09 <Oejet> Yes.
02:01:16 <vincenz> How come none of the examples of a gentle introduction work?
02:01:40 <vincenz> Prelude> data Tree a = Leaf a | Branch (Tree a) (Tree a)
02:01:40 <vincenz> <interactive>:1: parse error on input `data'
02:02:36 <shapr> put it in a file and load it
02:02:44 <jlouis> vincenz: put it into a file and ... yes, what shapr said
02:02:53 <vincenz> I'm using ghci
02:03:01 <jlouis> :load <file>
02:03:13 <vincenz> I thought ghci allowed you to do tests
02:03:25 <jlouis> you can evaluate _expressions_
02:03:39 <jlouis> you cannot define new definitions (which is good actually)
02:03:50 <vincenz> oh
02:04:09 <jlouis> data ... is a new definition of a data type. That is your problem
02:04:11 <vincenz> test.hs:1: Malformed LHS to type of class declaration
02:04:17 <vincenz> data [a]               = [] | a : [a]
02:04:36 <jlouis> will not go
02:04:38 <vincenz> jlouis: the idea of a toplevel is to experiment
02:04:53 <vincenz> hence it's not a ga good idea to not be allowed to make new defintiions
02:04:58 <vincenz> s/ga/a
02:05:29 <jlouis> vincenz: you obviously havn't tried that your code worked because you entered some definition in the REPL loop, but forgot to save it to a file?
02:05:41 <vincenz> I saved that in a file
02:05:45 <vincenz> it didn't work
02:05:57 <vincenz> note how it says test.hs
02:05:57 <jlouis> Well, you did not define it correctly
02:05:58 <shapr> @wiki HaskellDemo
02:05:59 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
02:06:22 <vincenz> jlouis: why doesn't it?  It comes straight from the tutorial
02:07:28 <jlouis> vincenz: dunno, but it does not look like correct haskell
02:07:45 <shapr> vincenz: if you save the parts between {{{ and }}} from here http://www.haskell.org/hawiki/HaskellDemo?action=raw
02:07:50 <shapr> then load that into ghci
02:08:08 <vincenz> I know but I'm trying to follow the tutorial
02:08:15 <jlouis> (I have not perused the language specification, but I am pretty sure that is wrong syntax)
02:08:58 <jlouis> anyway, the problem with entering things are minor. I always run ghci through emacs anyway and have a command for fast reloading
02:10:18 * vincenz doesn't use emacs
02:10:44 <jlouis> vi(1) then?
02:11:04 <vincenz> ?
02:11:08 <vincenz> vim
02:11:26 <Oejet> MSVSBC?
02:11:28 <jlouis> been there, done that.
02:11:45 <Oejet> Doh.
02:11:52 <vincenz> ...
02:12:02 <vincenz> I code in functional languages just fine, no need to downplay me
02:12:05 <vincenz> just not haskell
02:12:11 <vincenz> which I'm trying to learn at this point
02:12:15 <Oejet> vincenz: Sorry.
02:12:42 <shapr> vincenz: chill out man, people just trying to help :-)
02:12:53 <Lemmih> vincenz: 'data [a] = [] | a : [a]' I'm pretty sure that the tutorial states that this isn't real haskell code.
02:13:00 <vincenz> It states psuedo code
02:13:19 <vincenz> But then they should not have used the typefont they use for real code
02:13:27 <jlouis> surely not
02:13:34 <Oejet> Good point.
02:13:42 <shapr> yeah, submit a patch!
02:14:10 * vincenz grins
02:14:33 <jlouis> vincenz: hugs has a :edit command which uses ${EDITOR}/${VISUAL} for fast editing of definitions. Maybe that suits you better?
02:17:21 <vincenz> thx
02:18:23 <Itkovian> erm, kosmikus around?
02:18:29 <kosmikus> yes
02:18:40 <Itkovian> ahem ...
02:19:17 <vincenz> ooh nice
02:19:20 <Itkovian> i've got gtk2hs 0.9.7, but somehow the Glade part seems to be missing. Any idea where I can get that? I don't do gnime, so that may be the reason why it didn't emerge?
02:20:13 <kosmikus> could be
02:20:20 <vincenz> lists are not defineable?
02:20:21 * kosmikus studies the ebuild
02:20:53 <Oejet> I get an error trying to compile GreenCard 3.01: ghc-6.4.20050221: unrecognised flags: -fno-prune-tydecls
02:21:14 <Lemmih> Oejet: It's a dead flag. Remove it.
02:21:39 <jlouis> vincenz: not in their simplest form with [] and : as operators. data Lst a = Nil | Pair a (Lst a) is ;)
02:21:46 <Itkovian> $(useq gnome && echo \
02:21:47 <Itkovian>      63             "${D}/$(ghc-libdir)/gtk2hs/glade.pkg" \
02:21:47 <Itkovian> ?
02:21:52 <shapr> It would take less time to create an unofficial greencard darcs repo with the needed patches.
02:22:08 <Itkovian> dangm I've no desire to get all the gnome crap (sorry) on my system
02:22:18 <kosmikus> Itkovian: yes, certainly looks that way
02:22:31 <kosmikus> Itkovian: well, you can always enable gnome selectively for gtk2hs
02:22:52 <kosmikus> Itkovian: add a line "dev-haskell/gtk2hs gnome" to your /etc/portage/package.use
02:22:53 <Itkovian> yes, but won;t it pull a whole shitload of libs with it then?
02:23:13 <jlouis> probably
02:23:39 <kosmikus> a few, yes; but they're probably needed for this to work, then
02:24:06 <Itkovian> like gnome-base/libgnomeprint-2.8.2 ??
02:24:38 <Itkovian> glade itself doesn;t need any gnoe stuff afaik.
02:24:49 <kosmikus> I could ask duncan he wants to support a more fine-grained approach for glade without gnome
02:25:06 <kosmikus> duncan_: are you there?
02:25:42 <vincenz> jlouis: I thought one was able to use infix operators in datatype definitions
02:25:46 <vincenz> jlouis: and then match them
02:26:56 * vincenz gets to one of the juicy features of haskell: typeclasses
02:27:51 <kosmikus> Itkovian: for now, I would recommend to make a copy of the ebuild in your local overlay, and edit it according to your wishes
02:28:00 <Lemmih> vincenz: [] and : are reserved.
02:28:12 <vincenz> ah, alright
02:28:23 <vincenz> but one could possibly do it with others?
02:29:27 <Itkovian> kolmodin: ok, thx
02:29:29 <Itkovian> euhm
02:29:35 <Itkovian> kosmikus: ok thx
02:33:24 <jlouis> vincenz: maybe one is. I do not know. You can do it in SML at least
02:33:27 <shapr> cpage seems like an interesting guy.
02:34:11 <vincenz> jlouis: I know it's possible in SML that's why I asked :)
02:36:00 <jlouis> vincenz: 5 `Pair` Nil is pretty close
02:37:17 <Lemmih> Infix type constructors, data constructors and type classes should be possible.
02:38:13 <vincenz> what is the typedefinition of do?
02:39:05 <vincenz> I get the do c <- getChar
02:39:09 <vincenz>   putChar c
02:39:14 <vincenz> and it has type IO ()
02:39:15 <Oejet> vincenz: It's a macro.
02:39:23 <vincenz> but what stops someone from making
02:39:26 <vincenz> do c <- get Char
02:39:29 <vincenz>   c == 'y'
02:39:38 <vincenz> and have it return Bool instead of IO Bool as shown in the tutorial
02:40:09 <Lemmih> That would be: "getChar >>= \c -> c=='y'"
02:40:18 <Lemmih> @type (>>=)
02:40:19 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
02:40:38 <vincenz> taht returns an IO Bool?
02:40:41 <Lemmih> @type (\c -> c=='y')
02:40:42 <lambdabot> (\c -> c=='y') :: Char -> Bool
02:40:58 <vincenz> @type (getChar >>= \c -> c=='y')
02:41:00 <Lemmih> (Char -> Bool) doesn't match (a -> m b).
02:41:00 <lambdabot> bzzt
02:41:11 <Lemmih> @type getChar
02:41:11 <vincenz> @type (getChar >>= \c -> return c=='y')
02:41:12 <lambdabot> getChar :: IO Char
02:41:13 <lambdabot> bzzt
02:41:25 <vincenz> @type (getChar >>= \c -> return (c=='y'))
02:41:26 <lambdabot> (getChar >>= \c -> return (c=='y')) :: IO Bool
02:41:28 <Lemmih> vincenz: 'return' is a normal function.
02:41:32 <vincenz> yip
02:41:43 <vincenz> http://www.haskell.org/tutorial/io.html
02:41:53 <vincenz> they say the "ready" and explain why one needs return
02:42:05 <vincenz> what I don't get is why they don't just define the read as :: Bool
02:42:19 <vincenz> ..ready not read
02:42:29 <wilx`> Because it wouldn't work :)
02:42:35 <vincenz> I figured but why?
02:42:38 <vincenz> what's the limitation on do?
02:42:49 <Oejet> vincenz: Read is not a function.  It doesn't return the same thing every time.
02:42:57 <wilx`> Because of the types of >>= operator for example.
02:43:11 <vincenz> mind if I paste?
02:43:12 <jlouis> ``do'' is syntactic sugar for the monad functions >>, >>= and return
02:43:20 <vincenz> oh
02:43:24 * vincenz nos
02:43:27 * vincenz nods even
02:43:29 <vincenz> so
02:43:35 <vincenz> do x <- Exp
02:43:39 <vincenz>   Exp 2
02:43:39 <vincenz> =
02:43:49 <vincenz> exp >>= \x Exp2
02:44:03 <vincenz> exp >>= \x -> Exp2
02:44:25 <vincenz> alright, that explains it :)
02:44:27 <Lemmih> Yes, except for the wrong case.
02:44:33 <vincenz> right
02:44:40 <vincenz> but they were metavariables
02:44:50 <vincenz> and I defined my metavariables case-insensitive ;P
02:45:07 * vincenz continues reading the tutorial
02:45:12 <vincenz> so far so good
02:45:21 <vincenz> so basically ... once you start IO you're stuck with the IO monad
02:46:00 <Oejet> Lemmih: Is GreenCard really supposed to be this buggy?
02:46:09 <wilx`> Yup, nothing can escape it :)
02:46:23 <Oejet> ghc  -c Foreign/GreenCard_stub_ffi.c -o Foreign/GreenCard_stub_ffi.o
02:46:23 <Oejet> Foreign/GreenCard_stub_ffi.c:1:40: Foreign/GreenCard_stub_ffi.h: No such file or directory
02:50:18 <Lemmih> Oejet: It's kinda old.
02:51:00 <wilx`> Hmm, isn't the preferd way to use GHC's FFI syntax?
02:51:40 <Lemmih> I prefer to use it as little as possible.
02:51:56 <Oejet> Lemmih: Do you have any suggestions for learning FFI?
02:52:56 <wilx`> Why? I haven't used it so I don't know but it seems kinda nice...
02:53:06 <Oejet> wilx`: What I've understand from reading lots of docs is that when things get just a little complicated, you really want a preprocessor to make your marshalling code, etc.
02:53:33 <wilx`> Hm.
02:53:37 <Lemmih> wilx`: Yes it's really nice but still very lowlevel.
02:53:47 <Lemmih> Oejet: Read the paper?
02:55:12 <Oejet> Lemmih: Both the GreenCard manual and that overview thesis.
02:56:21 <Lemmih> I was thinking about the FFI Addendum.
02:58:55 <Oejet> Lemmih: That too.  It's very heavy though, so I haven't learned it yet.
02:59:46 * vincenz woahs at how easily parsers are made
03:00:20 <shapr> yeah :-)
03:00:26 <shapr> Have you reached Parsec?
03:00:48 <vincenz> http://www.haskell.org/tutorial/stdclasses.html
03:00:51 <shapr> Shammah: y0, wassup?
03:01:32 <shapr> Ah, you're talking about Read. It gets better!
03:04:06 <musasabi> Is it possible to create alternating versions of a library for the threaded and nonthreaded rts?
03:05:38 <Shammah> hey shapr.
03:06:02 <shapr> musasabi: only way I can think of is cpp, or possibly using TH to check at runtime.
03:06:19 <Shammah> Well my employer went insolvent, so I've spent the past month forming my own private consultancy.
03:06:24 <vincenz> I don't get this line
03:06:27 <vincenz> xs >>= return . Forest =fmap f xs
03:06:44 <vincenz> xs >>= return . f =fmap f xs
03:06:57 <shapr> Shammah: Cool! I like the sound of "own"
03:07:38 <shapr> Shammah: do you have a website for your new consultancy?
03:08:48 <Shammah> shapr: not yet, the company was only registered last week.  I haven't had a chance to prepare any 'marketing' yet... I'm not sure I can afford to, I've already got more work than I have time to do, and have been forced to arrange sub-contracting ;)
03:09:02 <shapr> Wow, that's great!
03:09:11 <Shammah> yes.  I'm very very pleased.
03:09:35 <shapr> I've been self-employed for a few years. Seems to be either not enough time, or not enough money.
03:09:48 <Heffalump> musasabi: doesn't the same approach as for making profiling versions work?
03:09:51 <shapr> Or you could say, lots of paying opportunies, lots of vacation opportunities.
03:10:07 <Shammah> well at the moment it's a case of not enough money... cashflow is the problem when you're just starting.
03:10:23 <Shammah> I've issued my first invoices, just waiting for them to be paid :).
03:10:36 <shapr> Luckily for us, we only need a colo server since we work at home.
03:10:54 <shapr> The downside of being self-employed is that companies can be very slow to pay.
03:11:07 <Shammah> ditto here.  Although I've had to go out and buy a new workstation, as a PII350 just dosn't cut the mustard when doing development work :)
03:11:11 <shapr> Universities don't think three months from invoice to pay is unusual.
03:11:51 <Heffalump> vincenz: that doesn't look like a valid Haskell definition to me
03:12:03 <shapr> Anyway, lunchtime for me. I'd love to hear more about your new company when I'm back from lunch.
03:12:23 <Shammah> shapr: sure, no problem.
03:12:45 <vincenz> Heffalump: it's not, it's a rule
03:12:54 <musasabi> Heffalump: I don't how to make those either.
03:13:32 <vincenz> Shammah: what sort of consultancy do you do?
03:13:51 <Heffalump> musasabi: look at how GHC gets built?
03:14:16 <Shammah> vincenz: currently development and support for the Kowari rdf-datastore.  (http://www.kowari.org/)
03:15:18 <vincenz> What language is that in?
03:15:22 <Shammah> vincenz: however I know a dozen languages or so, and I've worked in everything from embedded comms equip development to data-warehousing, so...
03:15:24 <Shammah> java
03:17:10 <vincenz> cool, what sort fo development are you aiming for? database, web, applicative, gui?
03:18:14 <Shammah> got to go pick up a dvd off a friend.... bbs.
03:18:49 <Shammah> vincenz: Other than support for kowari, applicative would be my primary target.  But we'll see. :)
03:21:56 <vincenz> alright :)
03:22:17 <autrijus> shapr: "Finally, the #haskell channel on freenode is full of helpful and interesting people." (pa01draft4) :-)
03:26:53 <Itkovian> @karma+ shapr
03:26:54 <lambdabot> shapr's karma has been incremented.
03:27:57 <Itkovian> shapr: can't you state in the contract that payment is due 30 days max after yield?
03:28:41 <Itkovian> then sue them ...
03:28:52 <Heffalump> and don't get any more work from them again..
03:32:48 <Oejet> Itkovian: This is Scandinavia; you don't just sue people over things like that.
03:34:59 <Oejet> Althought you could send them a late-invoice wich of course will cost extra in administration.
03:43:36 <Itkovian> Oejet: yeah, well, the sueing part was just a joke.
03:45:11 <Oejet> Ah.
03:46:09 <Oejet> lisppaste2: url?
03:46:09 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
03:48:38 <Oejet> Lemmih: Did you see my paste yesterday?
03:53:56 <Lemmih> Nope.
03:54:24 <lisppaste2> Oejet pasted "Loosing to the FFI" at http://paste.lisp.org/display/6098
03:54:50 <Oejet> I know how to call simple functions like sinus.
03:55:10 <Oejet> It's the structures/pointers that bug me.
03:55:15 <Lemmih> Eek. Danish /-:
03:56:45 <Oejet> Lemmih's brain explodes.
03:57:12 <Lemmih> Oejet: You have to marshal from/to the Vektor type.
03:58:39 <Lemmih> 'data Vektor = Vektor {x,y,z::Double}' does not have the same memory signature as 'struct Vektor { double x,y,z; }'
03:59:36 <Oejet> maybe data Vektor = Vektor Double Double Double?
03:59:41 <Lemmih> Nope.
04:00:12 <Lemmih> Dude. Haskell data types aren't like C structs (:
04:00:29 <Oejet> I'll just read the FFI reference again.  I'll bug you later.
04:00:59 <Oejet> Well somehow I should be able to marshall between those two.
04:02:12 <Lemmih> Oejet: Make Vektor an instance of storable and use new/with.
04:02:19 <Lemmih> @info Storable
04:02:38 <Lemmih> lambdabot: Yo?
04:02:39 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
04:03:01 <Lemmih> lambdabot: @info Storable
04:03:19 <Lemmih> @info Foreign.Storable.Storable
04:03:20 <lambdabot> -- Foreign.Storable.Storable is a class
04:03:20 <lambdabot> class Foreign.Storable.Storable a where {
04:03:20 <lambdabot>     Foreign.Storable.sizeOf :: a -> Int;
04:03:20 <lambdabot>     Foreign.Storable.alignment :: a -> Int;
04:03:20 <lambdabot>     Foreign.Storable.peekElemOff ::
04:03:21 <lambdabot> 	GHC.Ptr.Ptr a -> Int -> IO a
04:03:23 <lambdabot> 	{- has default method -};
04:03:25 <lambdabot>     Foreign.Storable.pokeElemOff ::
04:03:27 <lambdabot> 	GHC.Ptr.Ptr a -> Int -> a -> IO ()
04:03:29 <lambdabot> [14 @more lines]
04:11:47 <shapr> autrijus: yay!
04:15:15 <shapr> Itkovian: Yeah, we could state that in the contract, but it wouldn't help much. Our customers are ... hard to describe.
04:16:45 <jlouis> sounds awfully much like my experiences
04:27:43 <Itkovian> hmm ... bummer
04:28:55 <shapr> ?
04:31:06 <shapr> oh yes, multi-core GHC will be mine.
04:31:20 * shapr does the frantastic dance
04:31:56 <shapr> look look ! -> http://www.haskell.org//pipermail/haskell/2005-February/015402.html
04:32:09 * shapr boings
04:37:06 <shapr> Greetings carolyn.
04:37:17 <shapr> Looking for Haskell info?
04:38:31 <carolyn> Just discovered ICQ /freenode and easedropping on channels that might want to use
04:38:47 <carolyn> I like Haskell but havn't used since fn pgm class
04:39:14 <jlouis> \hyphenation{Den-ne} grrr
04:39:41 <jlouis> carolyn: all great programmers do ;)
04:39:45 <shapr> carolyn: Ok, if you have any particular questions, feel free to ask here.
04:39:55 <carolyn> ok thanks
04:40:21 <shapr> I can give you the short tour of useful online Haskell resources if you wish.
04:40:59 <carolyn> OK the one thing I didn't understand in class and still has me curious... in monads
04:41:24 <carolyn> "is" not "in"
04:41:31 <shapr> Would you like a short introduction to monads?
04:41:37 <carolyn> Sure
04:42:20 <shapr> Ok! If you've used Haskell some before, you probably know that with a list like [2 + 3,5 * 6] you can't tell what will be executed first.
04:42:38 <carolyn> ok
04:43:00 <shapr> The primary motivation for monads was to find some way to get ordered computations when you really need them.
04:43:38 <carolyn> ok knowing why they are around helps
04:43:57 <shapr> In essence, a monad does something and returns a new function that does the next thing.
04:44:09 <shapr> That way you know things will be done in that order.
04:44:26 <carolyn> So it allows a form of sequenal programming
04:44:30 <shapr> Right, exactly.
04:44:39 <carolyn> I can't spell/type
04:44:51 <shapr> That's okay, this is IRC :-)
04:45:00 <jlouis> doesn't matter. I am miserable with the english grammar anyway
04:45:13 <shapr> We all speak and read fluent typo :-)
04:45:26 <carolyn> good :)
04:45:30 * jlouis hands the crown of the typo kinf to himself
04:45:39 <shapr> jlouis: was that on purpose?
04:46:16 <tuomov> typonglish
04:46:21 <Philippa> shapr: tyop. There are no typos, only tyops :-)
04:46:22 <jlouis> shapr: sure ;)
04:46:35 <shapr> carolyn: Anyway, a monad has three ingredients, two functions and a container type.
04:46:42 <carolyn> as in opps
04:46:58 <carolyn> ok
04:47:00 <shapr> One function puts values into the container, one function puts together two containers to give a useful result.
04:47:47 <shapr> That pattern can do a *lot* of useful stuff.
04:47:54 <carolyn> ok I think
04:48:08 <shapr> This is the best monads intro I've seen yet - http://www.nomaware.com/monads/html/
04:48:27 <shapr> It's likely clearer than any explanation I can give on IRC.
04:48:47 <shapr> There's also http://www.haskell.org/hawiki/MonadsAsContainers on the Haskell wiki.
04:49:24 <Philippa> or there's my explanation, which is good if you're in a state to get them all at once and especially if you mostly want to use rather than create them, but is often a bit abstract for folks
04:49:27 <shapr> I've been using monads for a few years, and I've really understood them for maybe a year total. From my viewpoint, monads are a lot like objects, with more flexibility.
04:49:30 <Philippa> sadly, I've never put it on a web page...
04:49:34 <samc_> I liked the explanation in the awkward squad
04:49:35 <shapr> Philippa: go for it.
04:50:01 <Philippa> carolyn: are you familiar with the idea that languages have semantics?
04:50:28 <carolyn> semantics... meaning vs syntax?
04:50:31 <Philippa> yeah
04:51:11 <Philippa> monads're a trick for embedding another semantics into Haskell - eg you might want prolog-style depth-first search and backtracking, or the ability to pass around a state or do IO
04:51:51 <Philippa> in particular, you get to embed a kind of semantics that a) allows you to use ordinary haskell expressions still (this is what return does) and b) supports the equivalent of higher-order functions
04:52:36 <Philippa> and yeah, like shapr said, >>= lets you glue what I guess're programs in the relevant semantics together
04:52:52 <Philippa> though we tend to call them computations
04:53:18 <carolyn> kinda like Lamda in Lisp?
04:53:38 <Philippa> in which sense?
04:53:43 <Philippa> (we have lambda too)
04:54:01 <tuomov> monads are a way of lifting ordinary haskell expressions into a computational space with extra capabilities
04:54:08 <Lor> Well, an IO action _is_ kind of comparable to a thunk in an impure language.
04:54:22 <Philippa> ordinary functions do actually form a monad, for example (>>= is just function application)
04:54:33 <tuomov> and IO specifically can be thought of as a way of constructing instructions for an i/o interpreter
04:54:34 <carolyn> defining your own function...but its really another level of abstraction
04:54:39 <Philippa> embedding haskell in haskell isn't hard, mind
04:55:03 <Philippa> carolyn: computations in a monad are a bit like that, yeah
04:55:13 <Philippa> and monads as a whole are an abstraction as well
04:56:25 <Philippa> did you ever cover continuation passing style in lisp?
04:56:34 <jlouis> CPS... there the word came
04:56:36 <jlouis> ;)
04:59:37 <carolyn> If so its been too long... don't think I have though... have heard the word...continutaions is something I think I should remember but don't
05:00:24 <carolyn> The explanation with container types is new and really helps
05:01:09 <Philippa> carolyn: fair enough. Monads and continuation-passing're linked, but if you don't remember it's not useful info
05:01:22 * Lor thinks Maybe is the easiest monad to grok.
05:01:29 <Philippa> probably, yeah
05:01:52 <jlouis> Lor: indeed explained as a if .. then .. else if .. else ..... chain
05:02:24 <Lor> I think of it more as a sequence of actions that will stop at the first failure.
05:02:32 <jlouis> You could do that too
05:03:38 <samc_> the awkward squad I mentioned is a paper found here http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/ I liked its explanation of monadic io
05:04:36 <carolyn> OK I found a definition of continuations...
05:07:13 <jlouis> you should look at continuation passing style
05:07:37 <jlouis> continuations and continuation passing style are linked, just as continuation passing and monads are
05:08:36 <carolyn> http://dict.tu-chemnitz.de/ has definition
05:11:13 <shapr> Well, I hope carolyn enjoyed the short tour.
05:12:31 <shapr> hello again carolyn
05:12:33 <Lor> Hm, wonder if Claessen's breadth-first parsing pearl could be used for breadth-first nondeterminism as well...
05:12:43 <carolyn> Hi, press the wrong thing
05:12:44 <Shammah> back.
05:13:08 <lightstep> can i create a Ptr Cint (to pass to a void f (int*)) ?
05:13:09 <shapr> Shammah: Looks like a good job. If it weren't Java, I might apply for teleworking.
05:13:40 * Lor has lately learn to appreciate some of the less obvious merits of Java.
05:14:10 <jlouis> lightstep: yes
05:14:11 <tromp> hi haskellers
05:14:15 <lightstep> how?
05:14:25 <shapr> carolyn: What sort of programs do you usually write? Maybe you'd like to see examples of GUI, scientific programming, or something else in Haskell?
05:14:27 <shapr> hoi tromp
05:14:36 <jlouis> lightstep: never tried, sorry
05:14:44 <shapr> Lor: oh, like what?
05:15:03 <lightstep> lambdabot: @type Foreign.StablePtr.newStablePtr
05:15:05 <lambdabot> Foreign.StablePtr.newStablePtr :: forall a.
05:15:05 <lambdabot> 				  a -> IO (GHC.Stable.StablePtr a)
05:15:26 <lightstep> but this is StablePtr, not Ptr. damned GC!
05:16:07 <shapr> I know you can cast between them, but I forget how.
05:16:18 <Lor> shapr, it enforces even mediocre programmers to structure their code in a somewhat sensible manner.
05:16:31 <lightstep> lambdabot: @type Foreign.StablePtr.caseStablePtrToPtr
05:16:32 <lambdabot> bzzt
05:16:56 <lightstep> lambdabot: go read the docs
05:16:57 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
05:17:10 <lightstep> lambdabot: @type Foreign.StablePtr.castStablePtrToPtr
05:17:11 <lambdabot> Foreign.StablePtr.castStablePtrToPtr :: forall a.
05:17:11 <lambdabot> 					GHC.Stable.StablePtr a -> GHC.Ptr.Ptr ()
05:17:16 <Oejet> Lor, did you see Rasterman's applet code?
05:17:50 <Lor> Nope.
05:18:08 <carolyn> I have mixed background .... both of what you mentioned interest me....
05:18:16 <Oejet> Lor: http://www.cse.unsw.edu.au/~lambert/logocomp/2154962/cse.java
05:18:21 <carolyn> For GUI can I run it from HUGS?
05:18:22 <shapr> Lor: no arguments there, but I sure wish I didn't have to use it.
05:18:34 <jlouis> lightstep: Foregin.Ptr.newPtr together with Foreign.Storable.poke
05:18:48 <tromp> i'm almost finished porting fhourstones to haskell
05:19:01 <Lor> If I had to work in a big project with lots of clueless programmers, I'd rather everyone used java than everyone used scheme.
05:19:08 <jlouis> (CInt is instance of Storable)
05:19:29 <lightstep> jlouis: thanks
05:19:32 <jlouis> scheme really lets the dog out
05:19:33 <carolyn> For scientific ... its interests what kind of real applications use Haskell / fn pgm and the SW engineering of them interest me, too.
05:19:49 <Oejet> Lor: I couldn't even get mediocre programmers to use Scheme even if I forced them.
05:19:52 <shapr> Lor: True that, but I'd much rather not work with clueless programmers. I'd be happiest with 90% clueful and newbies who learn sane coding culture.
05:20:23 <jlouis> lightstep: np
05:20:36 <shapr> carolyn: One of my clients is paying me to install and maintain a mailing list archive search webapplication I wrote in Haskell.
05:20:49 <Lor> Yeah, raster's java code is a mess, but messy code is not a big problem. Messy _interfaces_ are.
05:20:49 <carolyn> Scheme taught right is fine. But at same time the problems people hit makes me curious about SW Eng. side
05:21:35 <shapr> I've also done service type work with Haskell, where someone asked me to accomplish a task and only wanted the results. Specifically, turn a bunch of ms.doc files into a custom XML format. I used openoffice and the Haskell Xml Toolbox.
05:21:37 <tuomov> I'd rather everyone wrote assembly in a project with lots of clueless programmers
05:21:43 <Oejet> Lor: It's not difficult to make messy Java interfaces.
05:21:44 <tuomov> the clueless ones would soon drop out
05:21:46 <shapr> heh, less potential for damage.
05:21:49 <samc_> tromp, the "back to my home page" link at the bottom of your fhoustones page is broken
05:22:16 <shapr> The sucky part about having clueless programmers in a project is that they do far more damage than they help.
05:23:01 <tuomov> I've been writing horrible C code recently..
05:23:20 <shapr> Well, the new workspace is way nifty.
05:23:27 <jlouis> haha
05:23:37 <jlouis> I used ion for some time
05:23:38 <tuomov> #define FIELD2STRUCT(T, F, A) ((T*)(((char*)A)-(int)((T*)0)->F))
05:23:40 <tuomov> eek
05:23:40 <tromp> thx, samc. fixed now
05:24:04 <shapr> tuomov: what is that? an ADT in C?
05:24:12 <tuomov> and missing one &
05:24:15 <Lor> C99 has offsetof.
05:24:32 <lightstep> tuomov: won't it coredump?
05:24:34 <tuomov> C99 is a luxury one can't afford
05:24:44 <jlouis> hehe
05:24:58 <Lor> glib has G_STRUCT_OFFSET
05:24:58 <lightstep> NULL->something usuall coredumps
05:25:04 <tuomov> I tried do some nice vararg stuff once thatonly C99 supports and immediately got complaints
05:25:08 <Lor> lightstep, not if you don't dereference it.
05:25:13 <tuomov> glibc... yuck
05:25:16 <tuomov> -c
05:25:23 <Lor> Bah, glib is neat.
05:25:28 <Lor> Or it used to be until it bloated.
05:25:31 <jlouis> hmmm, my FFI-calls needs streamlining
05:25:32 <shapr> carolyn: As for scientific programming, I've seen Haskell in digital signal processing libraries, hardware design applications used by Xilinx and Intel, dataflow applications, that sort of stuff.
05:25:34 <tuomov> same crappy kind of api as the rest of g*
05:25:43 <Lor> How?
05:25:47 <tuomov> bloated
05:25:55 <Lor> Hm?
05:26:01 <shapr> carolyn: I don't know of any Haskell GUI that works with Hugs. But I don't use Hugs, so I haven't really looked. I mostly use GHC.
05:26:08 <tuomov> g_this_is_a_long_name_that_takes_ages_to_write_do_something_please_now
05:26:09 <jlouis> shapr: I use it for writing toy applications and compilers
05:26:19 <jlouis> tuomov: g_this_is M-/
05:26:36 <tuomov> AND_WE_ALSO_NEED_TO_USE_MACROS_TO_PASS_STUFF_AROUND
05:26:37 <lightstep> g_thi C-p C-p
05:26:37 <Lor> tuomov, some exotic functions, yeah.
05:26:40 <shapr> jlouis: try hippie-expand, it's way more powerful.
05:26:55 <tuomov> plus it kills programs on errors etc.
05:27:00 <jlouis> shapr: never played with hippie-expand
05:27:06 <jlouis> maybe I should
05:27:18 <lightstep> the killing thingy is configuarble
05:27:21 <Lor> It kills programs on errors if you want it to.
05:28:15 <shapr> jlouis: look for hippie-expand - http://www.scannedinavian.org/~shae/src/elisp/shae-other.el
05:28:16 <carolyn> HUGS = great protected environment for students = can't use what learned afterwards as easily for your stuff
05:28:17 <tuomov> and I don't use emacs
05:28:28 <tuomov> lisp sucks too much to configure nice bindings
05:29:16 * Oejet gives tuomov a tudekiks.
05:29:40 <Forest> how can i profile haskell programs ?
05:29:42 <Forest> google: ghc profiler and  google: ghc profiling
05:29:51 <Forest> didn't seem to help much
05:30:01 <Oejet> Forest: ghc -prof -auto-all  abe.hs
05:30:11 <jlouis> shapr: (eval-after-load "dabbrev" '(defalias 'dabbrev-expand 'hippie-expand)) ?
05:30:12 <Oejet> Forest: a.out +RTS -p
05:30:24 <lightstep> user's guide, section 4.17.15
05:30:39 <lightstep> and the whole chapter 5
05:30:40 <jlouis> shapr: ok, I am going to steal with arms and legs from that file
05:30:46 <Forest> thanks a  lot
05:31:29 <shapr> jlouis: Lots of interesting elisp in that dir.
05:33:34 <jlouis> sure is
05:33:45 <jlouis> I am going to steal it ALL!!
05:33:59 * shapr grins
05:34:35 <jlouis> But first, I have to squash more overful h-boxes from the LaTeX document of mine
05:35:54 <araujo> Good morning.
05:36:13 <metaperl> morning
05:36:20 <carolyn> Thanks... This has been helped my understanding...Its been a year since I used Haskell... so I need to think (and do some other things)
05:36:34 <Itkovian> metaperl: did you have any succes with the Either stuff?
05:36:58 <metaperl> Itkovian, my solution did not use either... I dont understand why he thought it was necessary
05:37:01 <carolyn> But first an IRC question... how did you make your message to me red (so it was easy to see?)
05:37:15 <Itkovian> carolyn: like this?
05:37:23 <carolyn> yes
05:37:36 <Itkovian> your client lights up the lines containing your nick I guess
05:37:51 <Shammah> hey shapr, back from lunch I see :)
05:37:56 <tromp> i'm surprised one cannot use normal case layout within a do...
05:38:19 <lightstep> what's the normal layout?
05:38:20 <tromp> getting parse error on
05:38:25 <tromp>         let score = case ttval of
05:38:25 <tromp>           Just (olds,_) | s == (-olds) -> draw
05:38:25 <tromp>            _ -> s
05:38:26 <carolyn> ok thanks.. I'll keep easedropping, but not watching closely... Thanks again
05:38:33 <TheHunter> tromp, let is the problem
05:38:37 <lightstep> tromp: your _ is extra-indented
05:38:46 <TheHunter> Just must be further idented then score
05:38:54 <tromp> i must use let; this is in a do construct
05:39:26 <metaperl> Itkovian, I had to develop my own either... here is my solution: http://www.hcoop.net/~terry/haskell/hs/yaht/4.5/Ex4_5.hs
05:39:31 <tromp> indentation of _ was not the prob
05:39:46 <tromp>         let score = case ttval of
05:39:46 <tromp>              Just (olds,_) | s == (-olds) -> draw
05:39:46 <tromp>              _ -> s
05:39:49 <tromp> fixes it
05:40:03 <tromp> weird that indentation of score matters
05:40:16 <Itkovian> metaperl: that looks like what I'd have done. But I suspect there are cuter ways to do it.
05:40:19 <tromp> ah, i see why
05:40:26 <metaperl> :)
05:40:44 <tromp> learn something every day:)
05:40:46 <metaperl> ok well I'm going to call it case closed for now... after all, who learns Haskell in 1 day? :)
05:41:11 <shapr> Took me a year of idly poking it.
05:41:25 <tromp> didn't realize that within do, let allow multiple definitions
05:41:44 <lightstep> doesn't it always?
05:41:58 <tromp> but this is just let, not a let ... in
05:42:16 <tromp> so it is a different construct
05:42:24 <Itkovian> tromp: yes, in a do you cannot use the 'in'
05:42:25 <lightstep> sure
05:42:29 <kosmikus> otherwise it would be hard to define mutually recursive local functions in a do
06:10:11 * tuomov wants tagged unions added to C :)
06:10:39 <tromp> shame there's no modifyArray
06:11:21 * shapr wants ubiquitous C-- support.
06:11:34 <shapr> Though I'd be fine with a nice vacation instead.
06:16:46 <jlouis> Is about to lay the last hand on a 160 pages report
06:17:13 <tromp> i hope it gets read by 160 ppl:)
06:17:28 <musasabi> The alternative network-library thing - http://www.cs.helsinki.fi/u/ekarttun/network-alt/
06:17:37 <jlouis> tromp: haha
06:17:49 <jlouis> make that 167 pages, heh
06:22:16 <CosmicRay> good morning, #haskell
06:22:35 <Lemmih> Greetings, john.
06:22:42 <CosmicRay> hi lemmih
06:23:02 <tromp> ah, another john:)
06:23:21 <CosmicRay> apparently so :-)
06:25:19 <CosmicRay> http://mako.yukidoke.org/copyrighteous/reflections/20050217-00.html
06:27:28 <musasabi> Has anyone got a tru64 build of GHC?
06:28:07 <CosmicRay> the closest I can come to that is to say that it works under debian on my alpha
06:28:13 <CosmicRay> so you may be able to use that to help you bootstrap it
06:28:38 <musasabi> I got an alpha home, but I think the libraries are going to be the largest part of the mess.
06:29:02 <CosmicRay> the libraries?  doesn't ghc bundle everything it needs save libc?
06:29:59 <Itkovian> grmbl
06:30:12 * Itkovian thinks the people at #R are dead.
06:30:46 <earthy> cosmicray: libreadline
06:30:54 <CosmicRay> ah
06:31:03 <CosmicRay> it's fairly portable, though, isn't it?
06:31:12 <CosmicRay> it's been a gnu project for forever, it seems
06:31:18 <earthy> yes
06:33:47 <musasabi> getting gcc to play nice and such things are non-trivial ;)
06:34:14 <CosmicRay> musasabi: oh, is tru64 one of those unices that is annoying to work with?
06:34:25 <CosmicRay> like AIX, which I have been, uh, blessed with, here?
06:34:37 <CosmicRay> you know that linux can run tru64 bins, right? :-)
06:34:41 <musasabi> CosmicRay: actually it is quite nice as compared to hp-ux.
06:34:50 <CosmicRay> heh
06:35:29 <musasabi> but very few people use tru64 these days so one is usually first to stop that something does not work.
06:36:01 <CosmicRay> yeah, probably fewer tru64 users than aix users...
06:36:06 <CosmicRay> though we also have aix 5.1l
06:36:15 <CosmicRay> apparently very few people are using anything but aix4
06:36:20 <CosmicRay> aix5 is 64-bit for the first tim
06:36:21 <CosmicRay> e
06:36:27 <CosmicRay> so it is double annoying.
06:44:43 <musasabi> The sparc solaris build depends on libgcc_s.so.1, so I guess there is no way to get it working without getting first gcc?
06:51:08 * shapr rebounds
06:53:38 <lisppaste2> Oejet annotated #6098 with "Progressing slowly against the FFI" at http://paste.lisp.org/display/6098#1
06:55:14 <Oejet> So, I've read the FFI Addendum and understood a bit more.
06:56:03 <Oejet> I want to make data Vektor = Vektor {x,y,z::Double} storable.
06:56:30 <Oejet> As a certain C structures, that is.
06:56:54 <Oejet> typedef struct {
06:56:54 <Oejet>   double x,y,z;
06:56:54 <Oejet> } vektor;
06:58:46 <Lemmih> Oejet: What do you think 'sizeOf' should be?
06:58:52 <Oejet> Lemmih: Type class Storable needs a function sizeOf :: Storable Vektor => Vektor -> Int.
06:59:22 <Lemmih> Yes. And how big is three doubles?
06:59:37 <Oejet> Ah, I think it should be 3*2*4*1 byte = 24 bytes.
07:00:10 <Lemmih> How big is a C double?
07:00:24 <Oejet> Eight bytes.
07:00:47 <Lemmih> Next is the alignment.
07:00:50 <Oejet> sizeOf (CDouble).
07:01:36 <Oejet> My guess is wild and 8.
07:01:40 <Lemmih> Your alignment is the alignment of CDouble since you only have CDouble's.
07:02:07 <jlouis> phew
07:02:09 * Heffalump makes ghc-6.2.2 generate code that segfaults and wonders what to do.
07:02:10 <Lemmih> Oejet: Highest alignment is 4.
07:02:12 <jlouis> 166 pages... done
07:02:16 <Oejet> Ah, so alignment (CDouble).
07:02:22 <Lemmih> Oejet: Yep.
07:02:29 <musasabi> Heffalump: are you using unsafe things?
07:02:30 <Oejet> Wait, I saw that somewhere...
07:02:41 <Heffalump> musasabi: nope.
07:02:46 <Heffalump> it's segfaulting inside gmp.
07:02:58 <Heffalump> (sadly I can't just give people my code, cos it's confidential work stuff)
07:03:00 <Lemmih> Heffalump: You should report it then.
07:03:39 <Oejet> alignment x = alignment (0 :: CDouble)
07:03:51 <Lemmih> Oejet: (undefined :: CDouble)
07:04:05 <Oejet> Ah, couldn't find that. :-)
07:04:37 <Oejet> sizeOf x = 3* sizeOf (undefined :: CDouble)
07:04:54 <Lemmih> Yep.
07:06:39 <Lemmih> Oejet: And now there's poke and peek.
07:07:33 <Oejet> Then peekByteOff (Ptr p) n = peekByteOff (p :: Vektor) n
07:08:46 <Oejet> peek (Ptr p) = do x <- peekByteOff (Ptr p) 0
07:09:06 <Oejet> y <- peekByteOff (Ptr p) 8
07:09:19 <Oejet> z <- peekByteOff (Ptr p) 16
07:09:45 <Oejet> return (Vektor {x=x, y=y, z=z})
07:10:12 * Oejet 's brain breaks down.
07:10:18 <Lemmih> Don't define *Off.
07:10:58 <Lemmih> They are derived from peek and poke.
07:11:03 <Oejet> Lemmih: But I need to extract three numbers from that memory area.
07:11:21 <Lemmih> Yes. And you're doing it right.
07:11:44 <Lemmih> But don't define peekByteOff for Vektor.
07:11:50 <Oejet> Ah, plusPtr could be useful.
07:12:26 <Lemmih> The *Off functions are defined with peek/poke + plusPtr.
07:12:46 <Oejet> Let me just sum this up in a paste.
07:13:02 <musasabi> Oejet: why not simple [x,y,z] = peekArray ptr 3
07:15:49 <Oejet> musasabi: That might work.  I'll try, and then later I can generelise to arbitrary structures.
07:23:49 <musasabi> Oejet: you should probably use either a ffi interface generator or a suitable monad..
07:24:10 <musasabi> typically for C structures interface generators are better while for protocols monads.
07:25:28 <Oejet> musasabi: You are overestimating my current knowledge and abilities, I think.
07:26:09 <Oejet> musasabi: And also I haven't succesfully installed H/Direct nor GreenCard yet.
07:26:30 <musasabi> hsc2hs is quite limited but comes with ghc.
07:27:23 <Oejet> Great.  But I want to learn the principles of FFI first.  I'm way clueless at this point.
07:28:32 <lisppaste2> Oejet annotated #6098 with "You can peek and poke all you want." at http://paste.lisp.org/display/6098#2
07:29:05 <musasabi> Basically there are two things in raw haskell->C ffi: 1) the foreign import declarations, 2) functions in Foreign.* for stuffing things to/from raw pointers and manipulating pointers.
07:29:39 <Oejet> Yeah, got that much by now.
07:35:17 <musasabi> http://youzen.b2.fi/~musasabi/a.hs is the correct instance declaration.
07:35:21 <Oejet> "[x',y',z'] <- peekArray 3 ptr"  Here x' is a Vektor, so I need to cast the type to a Double.
07:40:03 <Oejet> He, I was close.
07:45:54 <lisppaste2> Oejet annotated #6098 with "Clearly unacceptable" at http://paste.lisp.org/display/6098#3
07:52:23 <Lemmih> Oejet: Ptr Vektor.
07:53:23 <Oejet> I tried that.  That gives a type error when calling (længde (v::Vektor))
07:53:41 <Lemmih> Oejet: Use 'with'.
07:54:16 <Lemmih> with (v::Vektor) (\ptr -> danishLength ptr) -- or just 'danishLength'.
07:59:30 <Itkovian> gotta go
07:59:31 <Itkovian> ttyl
08:01:04 <MatzeB> Hi, I'm new to haskell and experimenting with classes/instances
08:01:21 <MatzeB> if I have a "class Foo" is there a way to have a list of Foo instances?
08:01:24 <Oejet> Welcome, MatzeB.
08:01:28 <MatzeB> [Foo] doesn't seem to work...
08:01:59 <Oejet> You need to define instances of class Foo first.
08:02:04 <MatzeB> I did that
08:02:15 <Lemmih> MatzeB: (Foo a) => [a]?
08:02:20 <MatzeB> I have 2 data definitions and made them both instances of Foo
08:02:34 <MatzeB> but still I can't do "bar :: [Foo]"
08:03:18 <xerox> Because Foo is a Type Class?
08:03:22 <MatzeB> I'm more or less trying to "convert" some c++ code to haskell but seems class hirarchies don't really map to this...
08:03:42 <MatzeB> moment I'll create an example in a few lines
08:04:02 <Leimy> shapr: around?
08:04:06 <Lemmih> MatzeB: Class in C++ are _not_ like type classes in Haskell.
08:04:17 <MatzeB> Lemmih: I already realized this
08:04:30 <tuomov> he probably wants AnyFoo instance..
08:04:33 <MatzeB> just I wonder how programmers would solve a problem now...
08:04:49 <MatzeB> as I can't have a list of a class now
08:05:07 <tuomov> class Foo a where a_value :: a -> Int
08:05:15 <tuomov> data AnyFoo = forall a. Foo a => AnyFoo a
08:05:24 <MatzeB> (it's a game where I have different "objects" like doors, monsters, ... and they all have something in common like the draw function)
08:05:24 <tuomov> instance Foo AnyFoo where a_value (AnyFoo a) = a_value a
08:05:35 <tuomov> now you can have [AnyFoo]
08:05:59 <tuomov> requires -fglasgow-exts
08:06:07 <MatzeB> ok, moment I gotta understand that :)
08:06:22 <Lemmih> Be careful. That can really fsck things up.
08:06:34 <musasabi> -
08:06:49 <MatzeB> (in my game I then have a big list of objects now and for example iterate over taht list to draw all objects)
08:07:00 <musasabi> (dropped a book on the keyboard only)
08:07:11 <Lemmih> MatzeB: What about 'data GameObject = Obj1 | Obj2'?
08:07:19 <Oejet> data Object = Door | Monster Int | ...  maybe?   Then [Door, Door, Monster 2, Monster 1].
08:07:41 <Oejet> Lemmih: Too fast. :-P
08:07:58 <MatzeB> Lemmih: hmm would be  nicer if I could split it on multiple files or so...
08:09:03 <MatzeB> well probably I could anyway... and just have 1 big data definition...
08:09:14 <tuomov> in any case, you can't conveniently have extensible dynamic types in haskell
08:09:49 <tuomov> that AnyFoo thing is perhaps the best that can be had, but even it requires writing the wrapper class
08:09:51 <Lemmih> MatzeB: 'data Objs = Obj1 SomeObj1 | Obj2 ObjFromAnotherModule'
08:12:52 <lisppaste2> Oejet annotated #6098 with "With is strange" at http://paste.lisp.org/display/6098#4
08:13:32 <Lemmih> Oejet: Don't use unsafePerformIO.
08:14:12 <Lemmih> Or be very careful (:
08:14:24 <Oejet> But with has value  IO b.  I want a Double.
08:14:57 <Lemmih> Yes but allocating new memory isn't a pure operation.
08:15:59 <Lemmih> @type Foreign.Marshal.Utils.with
08:16:00 <lambdabot> Foreign.Marshal.Utils.with :: forall b a.
08:16:00 <lambdabot> 			      (Foreign.Storable.Storable a) =>
08:16:00 <lambdabot> 			      a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
08:16:15 <Oejet> Lemmih: It should be discarded at once.  Conceptually it's a pure function.
08:16:57 <Lemmih> Oejet: Then do 'return . danishLength'.
08:17:26 <Oejet> Where should I do that?
08:18:32 <Lemmih> Ops. I just realized that the C func isn't taking a pointer.
08:19:12 <Lemmih> Oejet: Removing the Vektor struct would be so much easier.
08:19:44 <Oejet> I don't quite follow you.
08:19:59 <Lemmih> Have the C function take three doubles instead of a struct.
08:22:27 <Oejet> Lemmih: That would be easy, since then I would have sin(), which I already know how to do.  I want to understand structures and then pointers.
08:23:32 <Lemmih> I'm not sure how you can push a struct in the stack without it being a hack.
08:24:33 <Oejet> I haven't found anything in the docs about structures.  That's why I'm bugging you so much. :-)
08:26:38 <Lemmih> Oejet: I'm not sure how it can be done without a C wrapper function.
08:26:55 <Oejet> So I would like to wrap længde :: Ptr Vektor -> Double  in  f :: Vektor -> Double.  I need to allocate a Vektor.
08:27:54 <Lemmih> I was thinking: 'double wrapper (Vektor *v) { return length (*v) }'
08:28:06 <Oejet> Then give it the value of the argument then apply length then return the value.  All in an unsafePerfomIO operation.
08:29:36 <Oejet> Lemmih: Ah, good idea.  Maybe even make "double laengde(vektor* v)"
08:30:22 <Lemmih> Yes.
08:32:09 <Lemmih> Oejet: You can also just use 'length' as a function which takes three Doubles from Haskell space.
08:33:00 <Lemmih> Not sure if that would break when optimizations are applied.
08:44:15 <Oejet> It seems to work now.
08:49:18 <lisppaste2> Oejet annotated #6098 with "Seems to work" at http://paste.lisp.org/display/6098#5
08:57:57 <Oejet> Thanks Lemmih and musasabi!  :-)
08:59:05 <Lemmih> Using danish characters doesn't fuck up GHC?
08:59:21 <Oejet> Lemmih: Not at all.
09:14:41 <shapr> y0 SyntaxNinja
09:20:16 <SyntaxNinja> hey shapr!
09:20:20 <shapr> wazzup?
09:37:25 <ski> @arr
09:37:26 <lambdabot> Well me hearties, let's see what crawled out of the bung hole...
09:37:34 <shapr> @arr
09:37:34 <lambdabot> Avast!
09:37:43 <ski> :)
09:37:48 <shapr> hej ski
09:37:50 <ski> hi shapr
09:38:02 <shapr> how's code?
09:38:21 * ski thought a little on undo-systems recently
09:38:35 <shapr> hiya basti_
09:38:49 <ski> shapr : not very much, lately ..
09:38:53 <basti_> hi
09:39:02 * basti_ packed all his and his gf's stuff now.
09:39:05 <shapr> oh, too bad. Hopefully you'll find something interesting to code.
09:39:10 <basti_> almost all.
09:39:25 <shapr> basti_: even your computer?
09:39:29 <basti_> not yet.
09:39:30 <shapr> :-)
09:39:41 <basti_> i didnt even clean up the pile of stuff on my desk yet.
09:39:44 <shapr> heh
09:39:52 <basti_> I'll have to find something to do while offline
09:39:54 <basti_> -shudder-
09:40:00 <shapr> read a book?
09:40:13 <basti_> again?
09:40:33 <basti_> offline, not without computer btw. ;)
09:40:47 <metaperl6> is it the case that getLine strips the line-termination character(s) from the line it reads and returns?
09:40:51 <shapr> Oh right. You could download some fun papers.
09:41:16 <shapr> metaperl6: I think so.
09:42:27 <basti_> it does.
09:42:47 <metaperl6> ok that's nice... no need to chomp() lines as in Perl :)
09:42:48 <ski> shapr : mm, yes, ty
09:43:33 <ski> shapr : i've been thinking and coding/proving a little on some logic-related-things, though ..
09:43:46 * basti_ likes logic
09:44:31 <basti_> as long as noone says "herbrandt universe"
09:44:33 <Oejet> metaperl6: Coulnd't you just define a getLine procedure in Perl with the same semantics?
09:44:59 <ski> basti_ : i've been thinking a little on a possible "unique-quantifier" ..
09:45:04 <ski> basti_ : :)
09:45:17 <basti_> you mean "there exists exactly one"?
09:45:21 <ski> no
09:45:24 <metaperl6> I suppose you could... but most people just $input = <STDIN>; chomp($input); # right autrijus? :)
09:45:29 <ski> "at most one"
09:45:37 <basti_> i see.
09:45:45 <ski> it's a bit hard to find a fitting descr. in natural lang.
09:45:50 <metaperl6> but you are right... no problem writing such a subroutine
09:45:52 <basti_> why?
09:45:59 <ski> why not ?
09:46:03 <ski> :)
09:46:12 <basti_> i mean what you wrote up there, wasnt that a fitting description?
09:46:21 <ski> so we can build "exists unique" from it
09:46:27 <ski> hm
09:46:38 <Oejet> metaperl6: I'd like to see that.  Could you give a oneliner subroutine definition here?
09:46:40 <shapr> oh, uniqueness types in Haskell?
09:47:03 <metaperl6> in Perl? sure...
09:47:39 <ski> basti_ : i mean like :  "exists a. P a" -> "there exists an a such that <P "a"> holds"
09:47:43 <basti_> i think Clean does with "Uniqueness" what Haskell does with monads. I'm not sure that this is the same as the mentioned uniqueness thing.
09:47:53 <metaperl6> sub read_input { my $input = <STDIN>; chomp ($input); return $input }
09:47:58 <ski> shapr : no, not quite related to uniqueness types ..
09:48:05 <metaperl6> maybe we should move to #perl6 for this
09:48:35 <ski> basti_ : there we have a "there" and an "an"
09:48:58 <basti_> ah.
09:49:09 <ski> basti_ : if i say "there exists unique ..." i also claim existance
09:49:29 <ski> basti_ : and using "at most one" seems too low-level, somehow
09:49:38 <basti_> uhm.
09:49:52 <ski> basti_ : so i want to use the word "unique" without "there exists"
09:49:58 <basti_> i see.
09:50:12 <basti_> did i mention that i find semantics pointless? =)
09:50:24 <ski> basti_ : and a sentence/proposition "an unique a such that <P "a"> hold" sounds strange
09:50:35 <basti_> i see the problem now
09:51:35 <ski> this nat. lang. business here was just so i can speak aloud a more informal version (mixed with other nat. lang. phrases), that's why i wanted such
09:51:44 <basti_> i see.
09:52:04 <basti_> it is important to do so occasionally
09:52:25 <ski> basti_ : and no, uniqueness can do things monads can't do (at least not that i've heard of..)
09:52:55 <basti_> i dont know if clean's "unique types" are identical to what we were talking about.
09:53:07 <basti_> i would doubt.
09:53:23 <ski> one can build a state monad on top of uniqueness types, but uniqueness types can be used in other ways too
09:53:49 <ski> <ski> shapr : no, not quite related to uniqueness types ..
09:54:01 * basti_ nods
09:54:24 <musasabi> ski: what do you have in mind? Any semantic or just implementational issues?
09:54:41 <ski> anyway, i defined "unique a : A. P a" as "forall a0,a1 : A. P a0 /\ P a1 -> a0 = a1"
09:54:51 <ski> musasabi : re. what ?
09:54:53 <basti_> that seems to make sense.
09:55:02 <musasabi> ski: uniqueness vs monads.
09:55:11 <SyntaxNinja> hello happy haskell hackers
09:55:18 <lisppaste2> metaperl pasted "help needed with pattern matches overlapped warning in program" at http://paste.lisp.org/display/6102
09:55:34 <musasabi> hello SyntaxNinja
09:55:53 <Oejet> metaperl6: Na, I was just curious.  Thanks.
09:55:59 <ski> musasabi : i wasn't talking about uniqueness types from the beginning, just shapr associated with them or thought i might be speaking of them
09:56:09 <basti_> metaperl6: why do you try to match command with q?
09:56:21 <metaperl6> q is the quit command
09:56:29 <musasabi> ski: ok.
09:56:31 <basti_> hmm.
09:56:45 <basti_> are you sure it is possible to match against variables in patterns?
09:57:06 <basti_> if not, your lines would have a very different meaning than you intended to express i think.
09:57:12 <metaperl6> oh wait. I meant for that to be a list consisting of 1 character
09:57:21 <basti_> ah.
09:57:31 <basti_> :)
09:57:31 <metaperl6> should the case command be "q"
09:57:39 <basti_> i would say so.
09:57:48 <SyntaxNinja> Lemmih: any chance of hackage supporting the upload of tarballs yet?
09:57:55 <metaperl6> but how can == compare... oh == works on lists? I didn't know that
09:57:58 * metaperl6 experiments
09:57:59 <SyntaxNinja> or actually, what it should do is look in a directory for the appearance of a tarball,
09:58:13 <SyntaxNinja> then unpack it, and move it to the database
09:58:15 <metaperl6> wow it works!
09:58:25 <basti_> :)
09:58:33 <SyntaxNinja> shapr: is the new xmp-rpc enabled hackage public yet?
09:58:41 <autrijus> == works on pretty much everything.
09:58:43 <autrijus> @type ==
09:58:45 <lambdabot> bzzt
09:58:47 <autrijus> @type (==)
09:58:48 <lambdabot> (==) :: forall a. (Eq a) => a -> a -> Bool
10:01:28 * metaperl6 heads out to do some shopping and get some orange juice
10:01:45 <metaperl6> :: boss is away, the kiddies go play ! :)
10:02:40 * shapr grins
10:03:09 <shapr> SyntaxNinja: nah, not yet. I think Hackage requires 6.4, so I'm waiting for a deb.
10:03:10 <ski> basti_ : anyway, i seem to recall that the unique condition in categorial product can be written in another way, so maybe there is a nicer way of defining unique
10:03:30 <basti_> hm.
10:03:42 <SyntaxNinja> shapr: ok
10:04:06 <ski> (basti_ : also, this def. is relative to what "=" is, e.g. equals, or maybe just iso (or possible other equiv relation ?))
10:04:39 <ski> (basti_ : and i'm not sure of what would be nice intro and elim rules for ir)
10:05:06 <basti_> i'm not sure at all I'm sorry.
10:05:18 <ski> np. neither am i
10:05:26 <basti_> =)
10:05:48 <basti_> but what is NOT relative to =?
10:05:52 <ski> i'm just thinking on and around it
10:06:01 <ski> exists, and forall, e.g.
10:06:20 <ski> not in the logical formulae
10:06:22 <basti_> thats a point ok
10:06:39 <basti_> but of course "unique" needs to be relative to =
10:06:47 <ski> maybe
10:06:49 <basti_> i mean how would you tell if something is "the same"?
10:07:36 <ski> mm
10:07:55 <ski> just that there can be weaker reasonable "the same"
10:08:00 <basti_> maybe.
10:08:05 <ski> such as "same up to isomorphism"
10:08:09 <basti_> an equivalence.
10:08:25 <ski> more or less
10:08:35 <basti_> hm.
10:08:35 <basti_> ;)
10:08:43 <ski> (depends on what you mean exactly with equivalence ..)
10:08:52 <ski> :)
10:08:54 <basti_> something transitive, symmetric and reflexive.
10:09:12 <ski> ok. equivalence relation, then
10:09:15 <basti_> yes.
10:09:56 <ski> (as opposed to equivalence of categories, or equivalence of logical formulae, i.e. in object-lang. biimplication "<->")
10:10:25 <basti_> hmm yes i see
10:11:00 <Lemmih> SyntaxNinja: I'm kinda waiting for GHC 6.4 before doing anything more on Hackage.
10:11:03 <ski> (or equivalent meaning isomorphic)
10:11:27 <basti_> well "isomorphic" is an equivalence relation
10:11:32 <ski> yes
10:12:09 <basti_> we could switch to meta-level now.
10:12:20 <ski> sorry ?
10:12:25 <basti_> to confuse occasional passer-bys a little more.
10:12:32 <ski> ah, hm
10:12:55 <basti_> like maybe, "what you say is isomorphic to leibniz' definition of equivalence" or something
10:12:59 <basti_> j/k
10:14:01 <ski> actually, i think i see similarities between leibniz' equality and coseparator (in cat. theory)
10:14:13 <ski> "j/k" ?
10:14:16 <basti_> just kidding
10:14:41 * ski was wondering if it might stand for JK-latch .. :)
10:15:23 * basti_ does NOT think about that anymore now.
10:15:33 <ski> JK-latches ?
10:15:42 <basti_> what they might have to do with equivalence
10:15:50 <ski> ahhh
10:15:52 <ski> :)
10:16:33 <ski> (anyway, it seems leibniz might be extensional equality backwards ..)
10:16:45 <ski> in some sense ;)
10:17:48 * ski prolly shouldn't talk more about that rn, when he's tired ...
10:17:51 <autrijus> shapr: http://svn.openfoundry.org/pugs/docs/01Overview.html is up.
10:18:04 <autrijus> shapr: http://autrijus.org/tmp/01Overview.pdf is a simple pdf rendering, which is fine, except it doesn't grok hyperlinks.
10:18:11 <autrijus> it's too late here (2am) and I need to sleep.
10:18:27 <ski> 19:19 local time
10:18:35 <autrijus> if it has to be latexized or pdfized correctly, I'd need to look at other solutions.
10:18:38 <autrijus> but not today.
10:18:39 <autrijus> &
10:18:43 <ski> (but i've been up since 03:45)
10:18:51 <shapr> 2*n?
10:19:16 <autrijus> that I think is a pi.
10:19:27 <shapr> aha
10:19:34 <shapr> very LaTeX punny
10:19:41 <autrijus> very.
10:19:53 <shapr> nifty
10:20:03 <bourbaki> moin
10:20:19 <shapr> autrijus: I'll mail you any corrections, but it looks fine at the moment.
10:20:40 <autrijus> ok, yay!
10:20:53 <autrijus> I hope I'm not the last one to turn in an article.
10:21:04 <shapr> by no means :-)
10:21:21 * basti_ is late one issue.
10:21:22 <shapr> I think mine will be the last ;-)
10:21:41 <shapr> Every time I get started on the Template Haskell tutorial, something distracts me.
10:21:48 <bourbaki> s anyone of you versed with wikis? i want to make my own wiki for myself with all the latex mathsymbols so i can put down my ideas and let other refine them and such
10:22:08 <shapr> bourbaki: mediawiki, moinmoin, other wikis support inline latex
10:22:24 <bourbaki> cool :)
10:22:34 <bourbaki> so i also can use latex to darw stuff?
10:22:39 <shapr> yup
10:22:45 <shapr> have you seen how it works on the Haskell Wiki?
10:22:55 <bourbaki> are there also plotters or 3d renderers for that?
10:23:03 * shapr thinks about that
10:23:11 <shapr> a gnuplot plugin would be pretty easy.
10:23:17 <bourbaki> i just had a look at wikipeda and latex stuff in it
10:23:23 <basti_> i would NOT use latex to draw things.
10:23:37 <shapr> basti_: what about functional metapost?
10:23:43 <bourbaki> i would like to have the possibility to do 3d stuff for my ideas
10:23:54 <bourbaki> maybe one also could do that with pgl
10:23:55 <bourbaki> ogl
10:23:59 <basti_> yes what about it shapr?
10:24:14 <shapr> I just wondered whether it makes drawing easier?
10:24:32 <basti_> i do not know.
10:24:35 <shapr> bourbaki: if you have a batch 3D renderer, I know how to make a plugin.
10:24:39 <basti_> i would still not use latex to draw things.
10:24:43 <bourbaki> maybe pov ray :)
10:24:53 <bourbaki> shapr: that would be cool
10:25:00 <shapr> I'd choose to write plugins for Flippi of course.
10:25:07 <bourbaki> i had the change to write an article in a book
10:25:27 <bourbaki> but i dont want to do that i want to build a small site for my ideas in a wiki so i can add stuff as i think about it
10:25:39 <bourbaki> that way its easier for me to write something good i think
10:25:47 <shapr> musasabi: ayh?
10:26:00 <basti_> 3d rendering sucks most of the time btw.
10:26:01 <basti_> ;)
10:26:37 <bourbaki> pardon ? why is that?
10:26:53 <bourbaki> one of my recent ideas has to do with 3d rendering
10:27:06 <basti_> if you cant do something in 2d so that people understand it, you cant do it in 3d too
10:27:09 <bourbaki> so it would be cool to have shots of it on the site form the newest app all the time and such
10:27:20 <basti_> oh it does NOT suck when you are talking about 3d rendering in itself
10:27:29 <basti_> then it's at hand of course
10:27:51 <bourbaki> right
10:28:04 <basti_> i thought you wanted to do "idea sketches" in 3d.
10:28:13 <bourbaki> it would be cool to just write these programs in a mathcad way or so
10:28:17 <bourbaki> no
10:28:28 <bourbaki> i want to render vectorfields
10:28:39 <bourbaki> or solid objects
10:29:00 <basti_> for demonstration of algorithms yes?
10:29:10 <bourbaki> right
10:29:27 <basti_> it doesnt suck then.
10:29:29 <basti_> :)
10:29:31 <bourbaki> my latest idea is to make 3d objects differentiable
10:29:40 <basti_> hm
10:29:46 <bourbaki> this involves a lot of projection into textures
10:29:48 <basti_> their surfaces?
10:29:56 <basti_> as in "tangent"?
10:29:59 <bourbaki> yep
10:30:11 <bourbaki> the derivation of the x and y axis then is the tangentspace
10:30:14 <basti_> good luck.
10:30:15 <basti_> =)
10:30:22 <bourbaki> its all done already
10:30:27 <basti_> oh great.
10:30:34 <basti_> can you comb an hedgehog? :P
10:30:37 <bourbaki> just want to make it accessable to the others via that site
10:30:43 <basti_> i see.
10:31:04 <bourbaki> atm the idea is just to gain the normal maps of your objects for free
10:31:13 <bourbaki> and beeing able to animate that thing
10:31:19 <bourbaki> and displacementmaps
10:31:37 <basti_> hmm
10:31:44 <basti_> and you got images of this already?
10:32:12 <basti_> or did you mean "done" in the mathematical sense? ;)
10:32:31 <basti_> ("i know it is possible. now i go bother someone until he implements.")
10:32:59 <shapr> man Software Transactional Memory is wild...
10:33:16 <bourbaki> completely done mathematically
10:33:23 <shapr> SPJ says he can use it to implement an SMP shared-memory version of GHC....
10:33:30 <basti_> you mean with tertium non datur? =)
10:33:48 <basti_> my boss is always "done" with his wavelets too. i "just" need to implement the software that does the transformation.
10:33:49 * shapr obviously doesn't understand STM well enough.
10:34:26 * shapr rereads the STM paper.
10:34:46 <bourbak1> thats not that easy to project into a texture because
10:34:49 <shapr> Has anyone else here read the STM paper, and has a clue how Concurrent + STM can be used for SMP GHC?
10:34:56 <bourbak1> what was the last sentence you have got?
10:35:21 <basti_> uhm
10:35:28 <basti_> < bourbaki> completely done mathematically
10:35:32 <bourbak1> ah
10:35:37 <bourbak1> (19:34:29) bourbaki: partial implementation in c++
10:35:38 <bourbak1> (19:34:54) bourbaki: the idea is now to do all that with textures
10:35:38 <bourbak1> (19:35:01) bourbaki: and do some really tricky things with is
10:35:38 <bourbak1> (19:35:16) bourbaki: like building a fork with just 2d manifolds
10:35:50 <ski> shapr : what is STM ?
10:35:56 <bourbak1> i want to apply it to l systems to render plants first
10:36:08 <bourbak1> with displacement on the leafes and the tree
10:36:09 <basti_> mh nice.
10:36:10 <shapr> ski: http://www.research.microsoft.com/%7Esimonpj/papers/stm/index.htm
10:36:20 <basti_> whats displacement in your context?
10:36:23 <bourbak1> then you project the high resolution mesh into a texture for the nomal maps
10:36:35 <bourbak1> like bark that is not flat like a cyilnder
10:36:52 <basti_> i see.
10:36:52 <bourbak1> bumps so to say
10:36:55 <ski> shapr : ty
10:37:02 <basti_> bumpmapping, or "real bumps"?
10:37:09 <bourbak1> real bumps
10:37:10 <basti_> would you see the bumps looking from the side?
10:37:17 <shapr> Man, if SMP GHC is happening I'm saving up for a quad opteron.
10:37:20 <bourbak1> yes
10:37:25 <bourbak1> you would there is a trick though
10:37:27 <basti_> hmm cool.
10:37:34 <basti_> whats the trick?
10:37:35 <bourbak1> i render the plaent with a really high resolution
10:37:38 <bourbak1> on the mesh
10:37:46 <bourbak1> cause anything is parameterized thats really easy
10:37:55 <bourbak1> just sample more or less points
10:38:12 <bourbak1> then you project the  mesh into the texture
10:38:17 <bourbak1> the derivation
10:38:26 <bourbak1> and with that you get the normal at all the points
10:38:33 <bourbak1> then you sample down the mesh
10:38:38 <basti_> hum
10:38:45 <bourbak1> so it has view triangels and is renderable really fast
10:38:57 <bourbak1> and apply the normal map to the mesh as a texture and use it to do the lightning
10:39:06 <bourbak1> thats the way they did it in doom3
10:39:16 <bourbak1> just that they did that in max or maya
10:39:17 <basti_> i see.
10:39:34 <bourbak1> and i can do that all the time and do a lot more things like the displacement and animation
10:39:43 <basti_> :)
10:39:48 <bourbak1> and i have developed a mathematcial calculus for these surfaces
10:40:07 <basti_> oh.
10:40:13 <bourbak1> they form a group and with that you can derive some cool things
10:40:21 <bourbak1> like that you can complex displacement
10:40:30 <basti_> uh.
10:40:34 <bourbak1> that is displace and then displace on the new normal
10:40:49 <basti_> mmmh thats nice.
10:40:57 <bourbak1> and you can add all the heightmaps form the displacement
10:41:01 <bourbak1> the derivations also
10:41:08 <shapr> hey alexj, have you looked at http://www.research.microsoft.com/%7Esimonpj/papers/stm/index.htm for HApps?
10:41:13 <bourbak1> in order to optain the summed derivation
10:41:28 <basti_> thats what one would expect
10:41:32 <bourbak1> all these things would be in that article but i cant write a normal article :)
10:41:54 <bourbak1> and then i also have developed a way to do comprlession with that
10:41:59 <bourbak1> wavlet wise
10:42:06 * basti_ knows wavelets.
10:42:09 <basti_> :)
10:42:26 <bourbak1> so you can use it to make special gemetry for online games
10:42:38 <basti_> a spatial or a special?
10:42:40 <bourbak1> like a face or body that you build with the displacements
10:42:51 <bourbak1> special
10:43:09 <basti_> well i think the idea of using wavelet-encoded heightmaps and render them to triangles is pretty obvious
10:43:21 <bourbak1> the cool thing is that i can once i have a function of my object compress it into a single function
10:43:49 <bourbak1> yes the idea is that you tell the artist to do that for the engine
10:43:49 <basti_> well what's a "single function"?
10:43:54 <bourbak1> so i can use it at runtime
10:43:58 <bourbak1> ie
10:44:00 <bourbak1> you have an apple
10:44:07 <bourbak1> an apple is a sphere with some displacements
10:44:24 <bourbak1> a sphere is just a simple function with an arity of 2
10:44:37 <bourbak1> sphere(x,y) -> |R^3
10:44:46 <basti_> ...?
10:44:56 <bourbak1> sec
10:45:05 <basti_> i mean, of course.
10:45:07 <basti_> but, so what? ;
10:45:08 <basti_> ;)
10:45:17 <bourbak1> http://mathworld.wolfram.com/Sphere.html
10:45:33 <bourbak1> so if you build anything like that from the start
10:45:51 <bourbak1> then you can do a lot of fancy things in your 3d engine
10:45:55 <basti_> i dont have the plugin
10:45:57 <basti_> ;)
10:46:02 <Itkovian> @seen funkmando
10:46:02 <lambdabot> I saw funkmando leaving #haskell 16 hours 58 seconds ago.
10:46:12 <basti_> wait
10:46:31 <bourbak1> just wanted to point you do the spherical coordinates
10:46:37 <basti_> okay.
10:47:11 <bourbak1> in the end the idea is to generate a complety human with that
10:47:20 <bourbak1> with animation hair and all that you can think of
10:47:26 <bourbak1> all parameterized
10:47:49 <basti_> the problem in rendering a realistically looking human is NOT the capabilities of the hardware
10:48:09 <bourbak1> there is
10:48:22 <bourbak1> the newest hardware is capable of a lot of things
10:48:40 <basti_> yes.
10:48:58 <bourbak1> i mean it wont trick you into thinking its real
10:49:05 <bourbak1> but it will look really really good
10:49:20 <bourbak1> if you are interested in seeing what you can do have a look at
10:49:39 <bourbak1> http://www.mpi-sb.mpg.de/~blanz/
10:49:48 <bourbak1> thats an article that inspired me
10:50:20 <shapr> hiya masm
10:50:49 * CosmicRay looks in
10:50:53 <basti_> hmm i see.
10:50:57 <shapr> y0 CosmicRay, wassup?
10:51:05 <CosmicRay> hey shapr
10:51:36 <CosmicRay> workin with wash
10:51:45 <CosmicRay> sorta
10:51:47 <shapr> Ah, I should do that.
10:51:51 <shapr> I need to cleanup curryspondence.
10:52:24 <CosmicRay> I hate web apps.
10:52:25 <CosmicRay> hate hate hate.
10:52:32 <CosmicRay> I should start alt.webapps.die.die.die
10:53:26 <CosmicRay> then there are all the stupid fawning articles about google maps and xml+javascript+xhtml convergence and whatnot, people thinking it's cool because they can drag a damn map on screen.
10:53:36 <CosmicRay> that was already possible with java applets 5 years ago
10:53:51 <basti_> javascript converges?
10:53:53 <CosmicRay> java sucks, but at least it's only one crappy language instead of three
10:54:02 <SyntaxNinja> heh
10:54:09 <basti_> i thought it grew a third leg and then stumbeled away?
10:54:16 <basti_> or something
10:54:19 <CosmicRay> heh
10:54:57 <CosmicRay> SyntaxNinja: did you get my reply to you?
10:55:04 <basti_> html was not what people wanted. java or javascript will not fix this.
10:55:54 <CosmicRay> yah, html sucks
10:56:05 <CosmicRay> but the replacements for it suck so much that they're about to become a black hole
10:56:39 <CosmicRay> I mean, geez, to figure out how to make the text in a table a little bigger I have to consult like 5 different css/xhtml/whatever references
10:56:41 <basti_> replacement for html? i see none.
10:56:52 <basti_> but html is great for what it was intended for.
10:57:04 <basti_> representation of (mostly) static content.
10:57:07 <CosmicRay> basti_: html4 non-transitional has phased out almost all attributes of tags in favor of css
10:57:20 <CosmicRay> w3c keeps trying to push people in that direction
10:57:29 <basti_> thats a good idea in itself.
10:57:36 <basti_> it won't make html any more dynamic.
10:57:40 <CosmicRay> it would be if css didn't stnik.
10:57:51 <basti_> whats so bad about css?
10:58:02 <basti_> i mean its an ugly fix for something ugly, but besides...=
10:58:02 <basti_> ?
10:58:13 <CosmicRay> it is overly complex and more difficult to use than basic attributes on html tags
10:58:20 <basti_> of course.
10:58:27 <basti_> why do you program haskell?
10:58:37 <basti_> its overly complex and more difficult to use than basic.
10:58:46 <basti_> =)
10:58:58 <CosmicRay> I submit that it is easier to use than basic in my problem domain.
10:59:04 <CosmicRay> that's why I use it :-)
10:59:21 <CosmicRay> and when I think things are overly complex, I gripe and/or fix them :-)
10:59:31 <CosmicRay> (see MissingH <g>)
10:59:42 <basti_> well same goes for css
10:59:58 <basti_> if you want to do a "stylesheet" you're very happy with css.
11:01:30 <basti_> i mean most people dont want a stylesheet, most people just want blue scroll bars or a fancy submit button.
11:01:37 <CosmicRay> http://developers.slashdot.org/article.pl?sid=05/02/23/1859222&tid=189&tid=95&tid=217&tid=8
11:01:41 <CosmicRay> this is what I'm complaining about
11:01:49 <basti_> what would be grounds for execution anyway.
11:02:06 <Oejet> shapr: I read the STM paper.
11:02:48 <basti_> CosmicRay: i'm not fond of this stuff also.
11:03:02 <basti_> CosmicRay: i'll enjoy seeing this wither and die.
11:03:20 <CosmicRay> basti_: see, I just did a poor job of explaining why it sucks :-)
11:03:23 <shapr> Oejet: do you understand how STM allows multi-cpu GHC?
11:03:33 <basti_> but its not css that sucks in there is it?
11:03:52 <CosmicRay> no that's a separate thing
11:04:10 <basti_> it is the fact that people take 10 things and pervert them until they give something new. Which is fun, but makes people sick sometimes.
11:04:23 <basti_> especially when someone claims it would be THE way to do the thing.
11:05:17 <Oejet> shapr: No.  It's just a nice way to serialize mutually exclusive pieces of code in a concurrent program.
11:05:50 <shapr> oh, in which case you can do eager scheduling of anything!
11:05:52 <shapr> tada!
11:05:59 <shapr> that *is* nifty
11:07:05 <Oejet> shapr: Instead of explicitly taking a lock before a critical region and releasing it again afterwards
11:07:30 <shapr> Wow, the Bug Kernel Unlock!
11:07:34 <shapr> um Big Kernel Unlock
11:07:47 <Oejet> STM works like databases just with memory,
11:08:21 <Oejet> So just do your manipulations on shared variables and
11:08:26 <musasabi> shapr: pong. (was in sauna)
11:08:32 <shapr> musasabi: oh good idea!
11:08:55 <shapr> gee, now I want a sauna.
11:09:12 <basti_> we will need saunas in germany next week.
11:09:14 <Oejet> in the end the system will do an atomic commit of the shared variables.
11:09:30 <basti_> temperatures are assumed to sink below -20 and probably give new 50 year records.
11:09:37 <musasabi> STM is nice ^_^
11:10:07 <musasabi> SyntaxNinja: How is the cabal hugs support currently?
11:10:48 <shapr> musasabi: SPJ said he's going for SMP shared memory GHC with Concurrent and STM.
11:11:16 <shapr> I *think* I know what he means after what Oejet said... eager scheduling of any transaction on any CPU, right?
11:13:03 <shapr> memory journaling... that kind of makes sense...
11:14:29 <musasabi> shapr: that is tasty, but it will be some time till we get hardware we can play with those features.
11:15:10 <musasabi> shapr: STM is making things simpler and more composable sacrifising a hopefully small amount of speed.
11:15:36 <SyntaxNinja> musasabi: cabal hugs support is great for the version of hugs in CVS
11:15:40 <SyntaxNinja> musasabi: not great otherwise :(
11:15:59 <SyntaxNinja> is there a good way of handling recursive modules? hi-boot is very annoying.
11:16:13 <musasabi> ok, then I just have to build a new version of hugs from cvs.
11:16:26 <musasabi> SyntaxNinja: ghc 6.4 uses hs-boot iirc
11:16:31 <SyntaxNinja> musasabi: what are you up to?
11:16:35 <CosmicRay> when is hugs going to ever make a new release?
11:16:37 <SyntaxNinja> musasabi:  is there any practical difference?
11:16:38 <desrt> i think stm has the ability to improve performance
11:16:40 <CosmicRay> the current one is, what, 1.5 years old?
11:16:44 <Oejet> shapr: What is eager scheduling?
11:16:52 <SyntaxNinja> CosmicRay: we could possibly talk to them about releasing a unix-only one.
11:16:53 <desrt> if you think about data locks in multithreaded systems no longer being required
11:16:58 <desrt> spinning goes away
11:17:01 <desrt> performance is improved
11:17:03 <SyntaxNinja> I want him to release one for sarge
11:17:14 <musasabi> SyntaxNinja: I think it is supposed to be easier.
11:17:28 <desrt> then again, another way of looking at it is just that -all memory accesses- lock :/
11:18:03 <musasabi> SyntaxNinja: I am trying to make my alternative network library work with hugs but it uses cabal...
11:18:03 <SyntaxNinja> maybe I should just redesign my modules
11:18:24 <SyntaxNinja> musasabi: cool. yeah, grab cvs hugs, it does a better job
11:18:39 <SyntaxNinja> I tried to talk ross into improving hugs support for the released versoin, but he doesn't have the cycles.
11:18:50 <shapr> musasabi: I have a two cpu box, I think I will be able to use it immediately.
11:19:03 <musasabi> desrt: carefully designed locking should beat STM in any smallscale scenario. Compare to manual memory management vs GC.
11:20:15 <shapr> Actually, this dovetails nicely with Parr
11:21:30 <alexj> shapr: just got back
11:22:22 <alexj> I looked at STM, but don't know how to integrate it yet.
11:22:39 <shapr> musasabi: You think this can be localized, sort of like region allocation? I'm thinking GHC on Cell.
11:23:50 <shapr> y0 funkmando
11:23:52 <alexj> have you read the paper in detail?
11:24:21 <shapr> Not yet, I'm on page three. I read it before but very little of it stuck for some reason.
11:24:59 <alexj> me too.
11:25:11 <alexj> I don't think I understand the problem it is trying to solve.
11:25:31 <funkmando> hey shapr
11:25:31 <shapr> If you can rollback memory transactions
11:25:42 <metaperl6> having done some SML I am very happy about the fact that GHCi reports type errors with line numbers... SML/nj's interpreter did not do that
11:26:11 <alexj> ok.  but why would I want to do that?
11:26:12 <musasabi> alexj: I have a small ACID thing that works on top of STM.
11:26:28 <shapr> You can execute whatever is required for a transaction, then check the memory at the last instant to see if anyone else has changed the memory. It's after-the-fact lock checking.
11:27:15 <alexj> ok.  my solution was to just stay pure and not involve io
11:27:43 <alexj> if app state is just a state monad...
11:27:58 <alexj> (note: I haven't put it in monad context yet)
11:28:08 <alexj> then what does STM buy you?
11:28:20 <Oejet> alexj: Composability.
11:28:22 <shapr> With STM, you can pass threads to multiple CPUs and they can do the same thing.
11:28:50 <musasabi> I am thinking of ways of making it distributed...
11:29:21 <shapr> Wouldn't you run into the same problem we've talked about before with migrating types?
11:29:51 <alexj> so suppose my server is a sequential number generator.  how does STM help me?
11:29:55 <shapr> Past that, it should be just fine.
11:30:50 <Lunar^> shapr: STM is not multiple CPU aware
11:31:00 <shapr> Lunar^: SPJ is making it SMP aware.
11:31:11 <Lunar^> shapr: Oh good news
11:31:11 <autrijus> SMP on STM?
11:31:14 <autrijus> 6.5?
11:31:33 <shapr> SPJ sounds rather enthusiastic about it, so it might be available in 6.5 soon.
11:31:42 <autrijus> wonderful news.
11:31:47 * autrijus going to relay that to $client.
11:31:47 <alexj> yes I saw the post.  I'm still missing the application....
11:32:20 <autrijus> I see junctions as the obvious application :)
11:32:30 <Lunar^> autrijus: is the dollar in '$client' an intended pun? ;)
11:32:47 <autrijus> it means one client instead of many clients :)
11:32:49 <alexj> junctions?
11:32:49 <autrijus> it's a sigil thing
11:32:56 <shapr> alexj: probably not much use in an algorithm that has no parallel bits.
11:33:00 <musasabi> shapr: yes, but if it is done with limited tables needing Binary, then it should be containable.
11:33:21 <autrijus> alexj: http://www.perl.com/pub/a/2003/07/29/exegesis6.html?page=4
11:33:57 <autrijus> yet another try at automatically parallelizable values.
11:34:19 <alexj> ok.  so lets assume that I have a multitable database.  a transaction looks at a lot of records and update some of them.  does STM help now?
11:34:39 <musasabi> alexj: yes.
11:35:37 <desrt> musasabi; a lot of people believe that GC is faster :)
11:35:59 <Oejet> alexj: What other serialization techniques do you know?
11:36:31 <alexj> musasabi: you want me to believe that STM knows all the assumptions I made about all records in deciding what to update?
11:36:53 <alexj> that sounds like magic.
11:37:00 <musasabi> desrt: GC may be faster for large applications, for small optimized domains a special purpose mechanism bats it most of the time.
11:37:16 <musasabi> alexj: it knows what you read and what you updated.
11:37:25 <musasabi> alexj: that is enough.
11:38:43 <alexj> so if another thread reads or updates anything that the first thread read or updated then its transaction dies?
11:39:13 <Oejet> alexj: It's rolled back and restarted.
11:39:16 <shapr> Looks that way to me.
11:39:51 <shapr> I think you get the equivalent of field-level locking.
11:40:30 <musasabi> actually it is slightly different from locking.
11:40:47 * musasabi does remotely remember a database book describing the technique.
11:41:20 <alexj> so how do you checkpoint?
11:41:23 <musasabi> but that is largely irrelevant. The main point is that it implements a strategy which produces serializable atomic transactions.
11:42:18 <alexj> Why not just serialize the transactions going in?
11:42:25 <Oejet> alexj: Conditional transaction IIRC
11:42:32 <Oejet> +s
11:43:46 <alexj> HAppS does write ahead logging of all transactions before applying them to the state.  It periodically saves the state to disk.  if the server gets knocked over, it replays the log since the last checkpoint.
11:44:28 <musasabi> alexj: because transactions might block.
11:44:29 <alexj> on recover.
11:44:45 <alexj> musasabi: transactions might block?
11:44:59 <musasabi> alexj: e.g. if we have a transaction which takes 2 minutes we don't want to block the whole system for it.
11:46:56 <alexj> if you have 1 CPU this transaction is a problem in any case.
11:47:17 <musasabi> alexj: why?
11:47:38 <alexj> you ar trading off betweeen having that transaction take n times as long or making every other transaction slower.
11:48:07 <musasabi> alexj: the transaction can e.g. wait for some event to happen and sleep most of the time.
11:48:25 <musasabi> alexj: that is why one needs to execute transactions in a concurrent fashion.
11:48:40 <alexj> if the transaction is waiting on IO then I treat it as a callback.
11:49:09 <musasabi> alexj: but what happens if it chooses to rollback later?
11:50:20 <musasabi> e.g. A -> B -> B commit -> A callback rollbacks
11:50:56 <alexj> you don't update the state in the first place until your side effects have completed.
11:51:14 <alexj> the sideeffect carries all the information to rollforward once it has finished.
11:51:31 <alexj> you can't rollback sideeffects in the real world.
11:51:45 <musasabi> alexj: that contains problems too.
11:51:47 <alexj> so HAppS guarantees AT-LEAST-ONCE execution.
11:52:04 <musasabi> alexj: because if A commits then B is invisible.
11:52:18 <alexj> ?
11:52:26 <musasabi> lets say the state is a single integer.
11:52:45 <lisppaste2> metaperl pasted "help needed: type error getting value from do statement" at http://paste.lisp.org/display/6106
11:53:00 <musasabi> B increases the value by one and it is initially 0.
11:53:33 <musasabi> A -> value := value + 2.
11:54:03 <Oejet> @type readLines
11:54:04 <lambdabot> bzzt
11:54:21 <musasabi> A -> (value = 2) -> B -> B commit -> (value = 3) -> A callback rollback => value?
11:54:22 <alexj> musasabi: I don't get it.
11:54:32 <alexj> ok.
11:54:57 <alexj> no I still don't get it.
11:55:06 <alexj> all functions take a state and return a state.
11:55:20 <Lemmih> metaperl6: readLines has type :: [String] -> IO [String]
11:55:30 <musasabi> ok. let me try to elaborate.
11:56:00 <Lemmih> metaperl6: unlines has type :: [String] -> String
11:56:41 <metaperl6> oh, I should untaint the values I read before consing them on?
11:56:57 <autrijus> metaperl6++ # very nice mixing of metaphors!
11:56:58 <musasabi> alexj: how would a x = do { send x to client; x' <- waitForReply client; return x' } be implemented?
11:57:09 <metaperl6> no x <- readLn does that
11:57:17 <autrijus> I shall now start teaching camelfolks about IO using the taint metaphor :)
11:57:23 <metaperl6> lol@autrijus: mixing Lisp and Perl terminology :)
11:57:36 <metaperl6> it was in a tutorial by Chris Dutton
11:57:37 <Oejet> ls <- readLines
11:57:54 <Oejet> return $ unlines ls
11:57:56 <metaperl6> @type readLines
11:57:57 <Lemmih> metaperl6: Once you've touched IO, you can't escape.
11:57:57 <lambdabot> bzzt
11:58:11 <autrijus> you can also use (=<<) to avoid the use of ls.
11:58:12 <alexj> is this GET/PUT?
11:58:18 <Oejet> metaperl6: You are trapped.
11:58:24 <autrijus> but using a variable improves readability to a point.
11:58:45 <metaperl6> this is not funny to me
11:58:48 <metaperl6> :)
11:58:51 <metaperl6> i do feel trapped
11:58:53 <metaperl6> confused
11:58:54 <metaperl6> lost
11:58:56 <metaperl6> hurt
11:59:02 <metaperl6> insignificant
11:59:03 <Oejet> Dooooomed.
11:59:06 <autrijus> You are trapped. You should feel safe. Resist the urge of Performing something unsafe.
11:59:06 <metaperl6> etc, etc...
11:59:15 <alexj> musasabi: it looks like you are implementing PUT x.
11:59:23 <bloomberg> ok can i ask a qn? if you have a list comprehension say [stuff involving x | x<-[0..10], P(x)], does the stuff involving x evaluate at all if P(x) is not satisfied?
11:59:24 <Oejet> unsafePerformIO !!!  \o/
11:59:42 <autrijus> metaperl6: ok. so "readLines []" is an action. you can't throw an action to a function.
11:59:51 <autrijus> ls <- readLines
11:59:58 <Lemmih> bloomberg: Try it!
11:59:59 <autrijus> ls <- readLines []
12:00:07 <autrijus> this performs the action, and store the result into a variable
12:00:12 <autrijus> that variable is now safe to be fed into a function.
12:00:23 <Lemmih> bloomberg: What does [ x | x <- [1..10], even x] give?
12:00:24 <metaperl6> oh, that's right
12:00:27 <autrijus> but you can't just write "unlines ls"
12:00:27 <alexj> am I being dense?
12:00:41 <autrijus> because that would be a value
12:00:45 <autrijus> and writeFile_contents is an action.
12:00:52 <autrijus> to turn a value into an action, use "return".
12:00:56 <autrijus> return (unlines ls)
12:00:59 <autrijus> does the trick.
12:01:04 <autrijus> to lose the parens, use ($)
12:01:06 <autrijus> return $ unlines ls
12:01:23 <bloomberg> [0,2,4,6,8,10] so i guess the answer is "no"
12:01:49 * Oejet grumbles that he already wrote those lines to metaper6 long ago.
12:01:54 <autrijus> to repeat: to turn an action into a value, use the <- syntax. to return a value in an action, use "return".
12:01:55 <Lemmih> bloomberg: That is correct.
12:02:12 <autrijus> Oejet: code without comments :)
12:02:26 <metaperl6> oh ok
12:02:38 * Oejet is doomed to be a Mayer.
12:02:59 <Oejet> And a Colling even.
12:03:03 <autrijus> ha.
12:04:09 <musasabi> alexj: so how would it be in hsapps?
12:04:10 <Lemmih> How do you create a .so file?
12:04:14 <Oejet> Both Mayer and Colling discovered the first law of thermo dynamics before Joule.
12:05:26 <alexj> I am making the assumption that each incoming event describes an entire transaction.
12:05:41 <alexj> this is the assumption of e.g. HTTP
12:05:45 <alexj> or SMTP
12:06:11 <alexj> you don't want a transaction that lasts as long as it takes the user to reply to your message.
12:06:19 <alexj> you just move to a new state on each event.;
12:06:46 <lisppaste2> metaperl pasted "program fails after I enter one line and hit return" at http://paste.lisp.org/display/6107
12:07:26 <alexj> so the client does GET /x and recieves x.
12:07:41 <alexj> the client then does PUT /x x and gets back a 200 OK.
12:07:42 <metaperl6> Lemmih, isn't is gcc --shared or something
12:08:24 <alexj> if the server should handle the PUT differently depending on whether or not the GET happened previously, that is part of application logic.
12:08:58 <musasabi> alexj: ok, then we define a transaction a little bit differently.
12:09:30 * musasabi is interested in transactions which typically use user input in-between.
12:10:16 <alexj> ah yes.  then you have a different sort of problem.  but lets talk about that issue too.
12:10:42 <alexj> suppose that the user POSTs a buytransaction.
12:11:05 <alexj> the server now needs to talk to a credit card processor to complete the transaction.
12:11:34 <musasabi> yes.
12:11:35 <alexj> musasabi: are we in the same space now?  because the server is waiting on the credit card processor and so the transaction is long again?
12:12:40 <musasabi> alexj: yes, if we sent the current state to the credit card processor.
12:12:54 <alexj> ok.  so we don't want to start the credit card transaction unless we have inventory.
12:12:59 <bloomberg> im doing a foldr1 min [list comprehension]. when [] is returned by the comprehension, obviously foldr1 fails. how can i error-trap this?
12:13:20 <lightstep> bloomberg: use case, or foldr
12:13:23 <alexj> and we may have two different clients both trying to buy the last item in inventory.
12:13:40 <musasabi> yes.
12:15:05 <bloomberg> how can foldr help? i want min of a list comprehension. what do i set the seed value to?
12:15:07 <alexj> so we can optimistic concurrency and start both credit card transactions.  the second one realizing that the inventory is gone, then has to send an undo message to the auth.net
12:15:47 <PerlJam> bloomberg: the first element of the list of course
12:15:51 <lightstep> bloomberg: infinity, naturally
12:15:54 <bloomberg> ok
12:15:55 <PerlJam> :-)
12:15:57 <alexj> or we can be pessimistic and lock the inventory until the credit card transaction completes.
12:16:23 <bloomberg> so head xs? but how can this be expressed if if is a list comphrension?
12:16:34 <alexj> I don't see how STM helps me here.
12:16:36 <musasabi> alexj: yes.
12:16:40 <lightstep> lambdabot: @type null
12:16:41 <lambdabot> null :: forall a. [a] -> Bool
12:16:50 <lightstep> bloomberg: lambdabot has an answer
12:17:13 <bloomberg> im not following, sorry.
12:17:29 <lightstep> null checks whether the list is empty
12:17:38 <bloomberg> ok cheers!
12:17:40 <alexj> I would probably do optimistic and have the state transition happen AFTER the auth.
12:17:47 <musasabi> alexj: we can do 2PC with the credit card host and use STM for the local resources. (that needs some tweaking to actually work)
12:18:14 <alexj> if the world had a 2pc interface that would be great!
12:18:20 <metaperl6> i/whois Philippa
12:18:31 <alexj> how do I unsend that nasty message I just sent to my boss!
12:18:39 <musasabi> true/
12:19:00 <musasabi> if you voted yes then you can only terminate. That is your only choice ;)
12:19:37 <alexj> :- )
12:19:59 <alexj> so I guess your point is that if you have 2pc then STM can integrate.
12:20:54 <alexj> but I am assuming most sideeffects including e.g. auth.net and paypal don't do 2pc.
12:21:37 <musasabi> alexj: true, but if I want long local transactions then STM is helping too.
12:21:40 <alexj> instead HAppS guarantees at-least-once execution.
12:22:01 <musasabi> e.g. updating a wikipage.
12:22:15 <alexj> ?
12:23:21 <alexj> you want a bunch of page updates to all succeed or all fail?
12:23:27 <musasabi> yes.
12:23:57 <musasabi> of course the checking can be done by hand..
12:24:10 <musasabi> but doing automatically could be very nice..
12:24:33 <alexj> how long before you expire the client's transaction?
12:24:52 <musasabi> alexj: e.g. 30min
12:25:13 <alexj> and I assume you want isolation...
12:25:31 <musasabi> yes.
12:26:00 <alexj> so when the client does "BEGIN TRANSACTION", you stick the state in a session variable.
12:26:18 <alexj> you apply all updates to the session state.
12:26:22 <musasabi> it can be done with checking the initial versions and then in commit phase lock and check whether there are conflicts.
12:27:37 <alexj> ok.
12:27:45 <alexj> so how does STM help here?
12:28:54 <musasabi> it automates the checking and remebering the state.
12:29:43 <alexj> i'm not convinced that to achieve isolation, you don't end up with basically the same amount of work.
12:30:50 <alexj> you have to maintain a state-session for each user.
12:31:41 <autrijus> is there a code coverage tool for GHC?
12:31:51 <autrijus> # http://www.haskell.org/pipermail/glasgow-haskell-users/2002-October/004235.html says not, but it's 3 years ago
12:31:52 <musasabi> no, just modify the TVars, have a timeout for killing the computation and WAL before committing.
12:33:10 <alexj> TVAR, WAL.  you lost me.
12:33:51 <metaperl6> @type readLn
12:33:53 <lambdabot> readLn :: forall a. (Read a) => IO a
12:34:05 <musasabi> tvars are mutable variables inside the STM monad.
12:34:12 <musasabi> wal = write ahead logging.
12:35:02 <alexj> so does WAL lock the state?
12:36:03 <musasabi> no, there is no need for that.
12:36:34 <alexj> because you unlog if the transaction fails?
12:36:37 <lightstep> metaperl6: are you megaperl_?
12:36:42 <musasabi> alexj: yes.
12:36:46 <musasabi> alexj: or no.
12:37:01 <musasabi> alexj: when walling rollback is just logged.
12:37:11 <metaperl6> no, never heard of megaperl_. I go by metaperl_ usually
12:37:54 <musasabi> there is no need to remove the failed transaction from the log because there is no log of it committing.
12:39:00 * Oejet thinks that alexj could have read the STM paper in the time talking with musasabi.
12:39:20 * wli tries to think about the (software engineering) best way to represent arithmetic in radical extensions over lunch.
12:40:10 * lightstep is happy that the /me hour has finally arrived
12:40:18 <wli> lightstep: ?
12:41:49 <musasabi> alexj: http://youzen.b2.fi/~musasabi/PersistentHash.hs (old buggy prototype but shows the idea)
12:42:16 <alexj> ok.  I'm starting to get it.
12:42:34 <alexj> so STM tracks only read/writes of TVars.
12:42:56 <musasabi> yes.
12:43:38 <alexj> so instead of using a regular FiniteMap a b, you have a FiniteMap a (TVar b)?
12:44:08 <alexj> or do you have a FiniteMap (TVar a) (TVar b)
12:44:25 <alexj> or is it a TVar (FiniteMap a b)
12:44:44 <musasabi> FiniteMap a (TVar b) would be the choice for any real transactions.
12:45:18 <alexj> so if you add a new item to the finitemap, is that part of the transaction?
12:45:21 <musasabi> that code uses TVar (FiniteMap a b) for demonstration, but the change is only locking granularity.
12:46:32 <alexj> or worse, if you delete an item from the finitemap?
12:47:11 <alexj> if you are doing TVar (FiniteMap a b) that is just a global lock.
12:47:17 <musasabi> you can wrap the finitemap if you do such ops. (I was having only insert with unique-id and updates)
12:48:11 <alexj> is the size of the FiniteMap part of the transaction'?
12:48:52 <alexj> perhaps you can instrument all your datastructures to be transactional, but that sounds non-trivial.
12:49:57 <musasabi> alexj: I have trees built on top of TVars but not in that code..
12:56:31 <alexj> ok.  i get it.  it seems like a lot of work to instrument your datastructures, do session timeouts, handle transaction failure from a client perspective, etc.
12:56:48 <alexj> but perhaps you have applications where you really need that sort of thing.
12:58:30 <alexj> for example, darcs is probably a better way to handle multi-document updating than long transactions.
12:59:37 <musasabi> of course darcs is not available as library and gets complex with lots of files.
13:00:12 <alexj> I mean that you can have a client side cache of the new versions of all the pages you care about and send them as a batch update when you want to commit your changes.
13:01:29 <alexj> because after your rollback, you are going to have an angry user who has spent hours fixing the wiki only to find that all his changes are ...?
13:03:04 <musasabi> alexj: diverted to and given to him for fixing. orElse...
13:04:41 <alexj> ok then you are doing all the application logic involving tracking explicitly what has changed.
13:05:18 <alexj> because you need to help the user fix it.
13:06:10 <alexj> are you going to explain that because the user got distracted and read some random page on the wiki that someone else updated in the meantime, they have to unread that random page?
13:06:39 <musasabi> alexj: no, the modified pages are simply not visible until the commit.
13:06:41 <mayhem> hi
13:07:02 <musasabi> explaining this could be quite complicated.
13:07:05 <musasabi> hello mayhem
13:07:38 <alexj> yes.
13:09:12 <alexj> there is a reason that the post succesful protocols in the world are all coonectionless.  e.g http and dns.
13:09:43 <alexj> sorry. i meant stateless.
13:09:43 <ibid> http is connectionless???
13:09:57 <ibid> yeah, and the state was glued on top of it
13:10:13 <ibid> (the http state management system, aka cookies)
13:11:01 <tromp> rehi
13:11:26 <musasabi> dns is very very bad imho.
13:12:05 <ibid> how?
13:12:59 <alexj> DNS may be bad.  but it is also stateless.
13:13:10 <alexj> there is no TPC in HTTP.
13:13:47 <ibid> TPC?
13:14:01 <alexj> two phase commit.
13:14:05 <ibid> yeah
13:18:54 <basti_> re
13:21:20 <bloomberg> gah i cant think atm. what expression can you use to determine the maximum list length in a list of lists?
13:21:35 <bloomberg> ie if xs = [[1,2,3],[1,2]] it should return 3
13:22:15 <alexj> foldr max 0 $ map length
13:22:27 <bloomberg> whats the dollar sign?
13:23:12 <tromp> application, right associative
13:23:31 <tromp> to avoid () around map length
13:24:06 <tromp> instead of foldr max 0 you can use maximum
13:24:51 <bloomberg> so without the dollar sign, could you do foldr max 0 (map length xs)
13:25:14 <tromp> or maximum (map length xs)
13:25:25 <tromp> yes
13:25:49 <bloomberg> thanks
13:52:30 * wli looks at Surd.hs
13:53:42 <wli> simplifying sqrt(5+2*sqrt(6)) is no easy task
13:54:31 <wli> or sqrt(7+5*3^(1/3)+3*3^(2/3))
13:58:28 <wli> hmm
13:59:15 <wli> The Gröbner basis for (a+b*3^(1/3)+c*3^(2/3))^2=7+5*3^(1/3)+3*3^(2/3) doesn't do the expected elimination
14:00:38 * Itkovian had almost forgotten there exists such a thing as grobner bases
14:13:44 <wli> plex sesms to ahve worked
14:35:27 <Itkovian> @seen boegel
14:35:27 <lambdabot> I saw boegel leaving #haskell 12 minutes 52 seconds ago.
14:35:38 <Itkovian> dang
14:36:07 <Oejet> @seen Skal
14:36:08 <lambdabot> I saw Skal leaving #haskell 1 minute 17 seconds ago.
14:36:12 <Oejet> Argh
14:36:18 <CosmicRay> heh
14:36:19 <Oejet> :-P
14:36:38 <CosmicRay> @seen MegaMonad
14:36:38 <lambdabot> I haven't seen MegaMonad
14:36:48 <CosmicRay> damn!
14:38:13 <TheHunter> @seen I
14:38:13 <lambdabot> I saw I leaving #haskell 30 seconds ago.
14:39:04 <Oejet> @seen TheHunter
14:39:05 <lambdabot> I saw TheHunter leaving #haskell 5 seconds ago.
14:39:40 <CosmicRay> well, we are sure going to a lot of effort to abuse lambdabot today.
14:39:51 <TheHunter> @seen me
14:39:52 <lambdabot> I saw me leaving #haskell 30 seconds ago.
14:40:11 <Oejet> TheHunter: Too slow: (23:41:37) lambdabot: I saw TheHunter leaving #haskell 5 seconds ago.
14:40:13 <Cale> @seen you
14:40:14 <lambdabot> I haven't seen you
14:40:59 <CosmicRay> @seen anyone_smart
14:40:59 <lambdabot> I haven't seen anyone_smart
14:41:16 <Oejet> @seen
14:41:16 <lambdabot> I haven't seen
14:41:22 * TheHunter is shoked by his bad grammar.
14:42:26 <Cale> @seen further_due_to_standing_in_the_footprints_of_giants
14:42:27 <lambdabot> I haven't seen further_due_to_standing_in_the_footprints_of_giants
14:43:11 <Oejet> lol.
14:47:03 <Khisanth> lambdabot: tried moving to the shoulders? :)
14:47:04 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
14:47:57 <Oejet> alexj: STM is based on a C library and it's described in http://www.cl.cam.ac.uk/users/kaf24/lockfree.html
15:01:23 <jlouis> STM seems to be interesting
15:01:42 <Oejet> jlouis: I saw it first!
15:02:08 <Oejet> It's mine. }:-]
15:02:49 <Oejet> jlouis: What is it?
15:16:52 <metaperl6> Question One: it doesnt appear possible to construct an integer via it's type information, e.g., Number Int 5 or Int 5 or Number 5. Why is this?
15:17:47 <metaperl6> Question Two: In this type defintion from YAHT, is he actually using the standard Number class in his type defintion for Face?
15:17:47 <metaperl6> data Face = Jack
15:17:47 <metaperl6> | Queen
15:17:47 <metaperl6> | King
15:17:48 <metaperl6> | Ace
15:17:49 <metaperl6> | Number Int
15:17:57 <metaperl6> yay, paste from PDF worked for once
15:18:05 <metaperl6> haskell mode goes berserk on it
15:18:26 <Oejet> metaperl6: Number there is a data constructor not a type constructer.
15:18:49 <metaperl6> you mean in regards to Question Two?
15:18:57 <Oejet> Yep.
15:19:01 <metaperl6> but
15:19:15 <desrt> metaperl6; the Number here is merely a type constructor
15:19:17 <metaperl6> the syntax is data DataName = TypeConstructor args1 arg2 .. argn
15:19:20 <metaperl6> so Queen
15:19:22 <metaperl6> Jack
15:19:22 <metaperl6> Ace
15:19:23 <desrt> it could just as easily be called NotFace Int
15:19:27 <metaperl6> Number Int are all type consturctors
15:19:28 <jlouis> Oejet: STM is a way to get locking of critical regions by looking at the memory like DB transactions, where a failed operation is retried
15:19:50 <jlouis> Oejet: now, this atomic operations can be seen as a typeclass....
15:20:02 <jlouis> add a little operational semantics
15:20:11 <jlouis> A bit of implementation
15:20:15 <jlouis> and it gets mighty fun
15:20:48 <jlouis> I am not through with the paper, but the preliminaries moved it up, so it is on my TODO list for tomorrow
15:22:49 <metaperl6> anyone have any feedback on Question One? How to create a number by calling the type constructor?
15:23:17 <Oejet> You can't.  I don't know why, though.  Historical?
15:23:59 <_Codex> metaperl6: 5 :: Int?
15:24:22 <metaperl6> oh... hmmm
15:24:58 <metaperl6> but let's say you have a Tree datatype. You would not define the tree and then use "::" to cast it
15:25:07 <metaperl6> Branch 5
15:25:32 <metaperl6> Tree (Branch 3) (Branch 5) -- note the use of the type constructor... how do you use type constructors to make numbers?
15:26:06 <Oejet> metaperl6: Tree and Branch are not type contructors; they are data constructors.
15:26:22 <metaperl6> oh
15:26:35 <metaperl6> the LHS has type constructors? and the RHS has data constructors?
15:26:41 <metaperl6> oh now it's coming to me!
15:26:45 <Oejet> Data constructors can be seen af functions:  Branch :: Int -> Tree
15:26:54 <metaperl6> the Char class has a million _data_ constructors
15:27:14 <Oejet> s/af/as
15:27:19 <_Codex> almost everything is a function.
15:27:27 <_Codex> or looks like one
15:27:33 <metaperl6> ok and 5 is a value constructor for the Int type class and the double type class and the fractional
15:28:00 <metaperl6> please respond: the _type_constructor is on the LHS and the _data_ constructor is on the RHS
15:28:01 <metaperl6> ?
15:28:39 <kosmikus> of a data statement? yes
15:28:43 <jlouis> metaperl6: yes, in data type declarations
15:28:50 <Oejet> Yes.
15:29:09 <kosmikus> glad we all agree :)
15:29:25 <Oejet> They are right; lazy evaluation _is_ slower. :-P
15:29:31 <metaperl6> ok now things are making sense. and Number was a _type_ constructor in the prelude but here it is being used as a _data_ constructor and since they do not share a namespace there is no problem
15:29:49 <Oejet> metaperl6: Excatly.
15:30:05 <Cale> Lazy evaluation is slower, except when it's faster
15:30:16 <jlouis> learning which namespaces are shared and which are not is important to know in most languages
15:30:19 <Cale> :)
15:30:30 <_Codex> lazy evaluation just is.
15:31:13 <Oejet> I was talking about how we only answered until we had to.  Just before metaperl6 had strangled us.
15:31:27 <jlouis> the problem is that if you cannot eliminate the lazy evaluation, you end up with a thunk on the heap
15:33:31 <Cale> I've found that the = sign in data declarations consistently confuses people new to Haskell. Perhaps it should be something else.
15:34:09 <Oejet> Yeah, data Blob a = Blob a, is confusing.
15:34:27 <_Codex> cale: why is that?
15:34:44 <Oejet> And the classical: data Quad a a b b = Quad a a b b.
15:34:48 <Cale> because the things placed on either side of it are not even in the same namespace.
15:35:10 <dons> yeah, newcomers take a while to realise that. but it isn't such a big deal.
15:35:10 <Cale> they're not even the same kind of thing
15:35:44 <Cale> perhaps an arrow, or some other symbol would be better
15:35:52 <Oejet> They are not even from the same Haskell designer brain. :o
15:35:56 <Cale> hehe
15:35:56 <_Codex> Well, it puts them to same equivalence class.
15:36:24 <dons> what is the ML syntax?
15:36:51 <_Codex> cale: that's why = fits so well -- the sides are in the same equivalence class, but they are completely different still. Works exactly as it should. :)
15:37:24 <Cale> They're not in the same equivalence class -- the = there isn't even symmetric
15:37:45 <Cale> Also can't be transitive
15:38:03 <dons> datadef Blob_t { Blob_t a; } Blob a;
15:38:04 <dons> hehehaha
15:38:07 <Cale> I think the notation used in the GADT syntax is clearer
15:38:12 <kosmikus> I like (almost) GADT syntax for datatypes
15:38:16 <kosmikus> ah, you too
15:38:38 <Oejet> What is that the GADT syntax?
15:38:51 <kosmikus> data Blob a where { Blob :: a -> Blob a }
15:39:09 <kosmikus> I would like "data Blob :: * -> * where { Blob :: a -> Blob a }" even better
15:39:48 <kosmikus> with the possibility to infer the kind from the constructor type signatures, of course
15:40:00 <dons> isn't that Miranda-ish, at least the explicit kinding? or is my memory fuzzy.
15:40:02 <Oejet> That doesn't make sence to me.
15:40:07 <Cale> but which order do you put the type parameters in?
15:40:29 <kosmikus> Cale: the constructors define everything there is to know about the datatype
15:40:48 <dons> I do like the idea of optional explict kind annotations
15:40:59 <kosmikus> Cale: in GADT syntax, the type arguments are really redundant
15:41:09 <kosmikus> dons: sure, me too
15:41:29 <Cale> ah, right
15:41:49 <Cale> hmm...
15:43:13 <jlouis> night
15:44:07 <Cale> no wait... Suppose you want data Foo :: * -> * -> * -> * where { Bar :: a -> b -> c } -- how do you write the type of (Bar map) for instance? The parameters to Foo don't have any explicit ordering.
15:44:57 <kosmikus> the result type of the constructor must be a Foo
15:45:10 <kosmikus> your declaration is illegal
15:45:11 <Cale> ah
15:45:20 <Cale> yeah, I'm being silly
15:45:33 <Cale> data Foo :: * -> * -> * -> * where { Bar :: a -> b -> c -> Foo a b c }
15:45:38 <Cale> right
15:45:42 <kosmikus> exactly
15:45:47 <kosmikus> thereby giving the order
15:45:51 <Cale> yes
15:47:22 <kosmikus> dons: btw, I don't think that Miranda had kinds; Miranda used *'s to signal parametric polymorphism iirc
15:47:57 * kosmikus should probably use present tense when talking about Miranda
15:48:16 <dons> ah, that was it. yes.
15:48:30 <Cale> Is Miranda still around?
15:49:58 <kosmikus> I don't really know
15:51:07 <dons> it appears it is still taught at some universities
15:52:28 <dons> presumably they use 7+ year old distros though..
15:52:33 <kosmikus> so, there are implementations still around? I can't find this "Research Software" company on the net ...
15:52:57 <dons> neither. I also couldn't find it last time I looked a couple of years ago.
15:53:51 <kosmikus> sad story somehow
15:54:39 <dons> open source is the key to longevity -- lml is still around ~20 years later
15:55:08 <dons> but it does seem strange that all traces of Miranda have disappeared. hmm.
15:55:26 <kosmikus> probably because Haskell was explicitly designed as a Miranda replacement
15:56:21 <dons> so there was social acceptance that everyone should migrate to Haskell, I guess.
16:00:05 <kosmikus> yes, I think so
16:00:33 <kosmikus> although I'm too young; haven't been there myself ;)
16:01:50 <Heffalump> Oxford was using Gofer when I started there, and I think might have switched from Miranda not that many years previously (97)
16:04:08 <dons> UNSW was using Gofer in ~97, then Hugs 98-00, and finally to GHCi in 2001. But it had been Miranda dominated during the 90s -- the textbooks still clog up the library shelves
16:07:18 <MachinShin> hey +
16:10:33 <Oejet> Hello, MachinShin.
17:01:58 <dons> ghc comment of the week: "Beware; the following may make your brain melt."
17:03:51 <Igloo> I quite liked SM's 'We don't have an "official policy" for these things, and exceptions are often made.'
17:04:46 <dons> yeah, that is a good one :)
17:19:27 <dons> hmm. can ghci run external core.. i wonder.
17:23:12 <dons> it appears not: flag `preprocess' is incompatible with source file `F.hcr'
17:26:26 <dons> of course, it doesn't like chasing non-existent .hi files
17:27:13 <TheHunter> hmm, am I right that ghc-6.4 doesn't accept its external core.
17:27:34 <TheHunter> i get a parse error on a %case.
17:30:57 <dons> yep. looks like something broke slightly in Core ppr or parsing
17:31:24 <Svrog> hi dons
17:31:39 <dons> heya Svrog
17:32:23 <dons> hmm. the core has several differences between 6.2.2 and 6.4
17:32:55 <dons> but nothing too serious, mostly seems to be names
17:34:47 <TheHunter> "%case (a) x %of ..." works like "%coerce a (%case x of ...)", i guess
19:52:31 <bourbaki> moin
20:59:29 <Lemmih> Good morning, #haskell.
21:01:52 <wagle> 9pm
21:01:57 <wagle> zzz
21:02:23 <Gahhh> hmm pacific time
22:02:30 <Lemmih> @seen SyntaxNinja
22:02:30 <lambdabot> I saw SyntaxNinja leaving #haskell 3 hours 38 minutes 15 seconds ago.
22:02:43 <Lemmih> Fooie.
22:18:27 <wagle> ghc takes forever to compile if you give it only half the cpu.  8)
23:19:48 <danb_> anyone feel like answer questions about higher-order polymorphism?
23:20:58 <dons> you should just ask, and hope someone knows the anser :)
23:21:01 <dons> answer
23:21:12 <danb> true. that's usually how irc works
23:21:32 <danb> so i'm looking at http://www.eecs.harvard.edu/~ccshan/cs252/usage.pdf
23:22:04 <danb> it formalizes the language of rank-n types, tn, as follows:
23:22:12 <danb> t0 ::= a | t0 -> t0
23:22:42 <danb> t(n+1) ::= forall a. t(n+1) | tn -> t(n+1)
23:22:47 <danb> (excuse my notation)
23:23:10 <danb> so by this grammar, we have the following classifications:
23:23:19 <danb> a : t0
23:23:22 <danb> a -> b : t0
23:23:31 <danb> forall a. a : t1
23:23:37 <danb> a -> forall b. b : t1
23:23:50 <danb> forall a. a -> a : t2
23:24:11 <danb> but shouldn't the identity function (the last example) be rank-1?
23:24:49 <dons> hmm. reading the paper...
23:24:56 <danb> please point-out my misunderstanding, oh enlightened memebers of #haskell ;)
23:27:20 <danb> hmm, i think i see it
23:27:31 <danb> i was thinking:
23:28:06 <danb> forall a. a : t1 , so: (forall a. a) -> a : t2
23:28:19 <danb> but then the forall doesn't scope over ->
23:28:35 <danb> i think the correct grouping is: forall a. (a -> a)
23:28:38 <danb> so:
23:28:41 <danb> a -> a : t0
23:28:46 <danb> forall a. (a -> a) : t1
23:28:49 <danb> which makes sense...
23:28:59 <dons> yes. that's how I was reading it.
23:29:16 <danb> k
23:29:35 <dons> looks like a nice intro paper, too.
23:30:06 <danb> yeah. i'm reading it to try to understand this one: http://homepages.cwi.nl/~ralf/HList/
23:30:21 <danb> (Strongly typed heterogeneous collections)
23:30:26 <dons> yikes. HList will melt your brain..
23:30:32 <danb> hehe
23:30:34 <danb> why so?
23:31:12 <dons> it probably contains the most type hackery of any .hs library out there
23:31:22 <danb> ic
23:32:07 <danb> unfortunately, i'm not expecting it to solve my problem: a friend and i are trying to model a strongly-typed event queue for a project
23:32:31 <dons> what is a strongly-typed event?
23:32:42 <danb> and i think what we want necessitates dynamic decisions on type, so we might be stuck with [Dynamic]
23:32:52 <dons> yeah, that is what I would have suggested
23:33:03 <danb> uh... something better than strings
23:33:26 <danb> algebraic types are a problem because we want the set of events to be extensible
23:33:45 <dons> getting into tricky territory quickly, then :)
23:33:51 <danb> we've looked at template haskell, but we want a different solution
23:34:04 <danb> yeah. it's turning out to be educational, though ;)
23:34:26 <dons> there are a number of recent proposals for extensible data types floating around
23:34:34 <dons> though I guess HList can do that, right?
23:34:47 <danb> it mentions something about extensible record types, but i haven't gotten that far yet
23:35:05 <dons> oh, that's right. they were for record types.
23:35:38 <danb> Lammel's other recent draft seems to embrace the extensible record type idea and extend it to the object plane: http://homepages.cwi.nl/~ralf/OOHaskell/
23:35:46 <danb> err, Lammel, et al.
23:36:44 <dons> yep. though i'm not familiar with the details.
23:58:19 <danb> (still in the context of higher-order polymorphism) what's the difference between ((forall b. b) -> a) and (forall b. b -> a) ?
23:58:40 <danb> that might be a bad question. i'm trying to simplify a more complex example that i don't understand
23:59:36 <dons> hmm. I don't thin there is a difference.
23:59:39 <Leimy> dons
23:59:45 <dons> heya Leimy
23:59:47 * Leimy was just going to try Yi again on Mac OS X :)
