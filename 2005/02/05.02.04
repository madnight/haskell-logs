00:00:46 <dons> Itkovian: it's the compiler used in my "Concepts of Programming Languages" course
00:00:56 <Itkovian> dons: nope ... I was referring to the IPC, so if you compile a haskell proggie to 100000 instructions (at runtime!) then it will take say 10^6 cycles.
00:00:58 <Maddas> dons: So isn't any language that you can compile to C?
00:01:34 <Itkovian> IPC of ~ 0.1 is _very_ bad. OTOH I see that the AMD macro ops to cycles is about 2, which is quite good actually :-)
00:01:34 <Maddas> Heh, maybe we need a C->Haskell compiler :-)
00:03:31 <dons> but calls are a little cheaper in Haskell, yeah: goto (void *)addr;
00:04:43 <dons> Maddas: I wrote this <http://www.cse.unsw.edu.au/~dons/code/hsinc/hsinc> to turn an arbitrary haskell program into a valid C program
00:04:54 <dons> for entering C programming contests..
00:04:55 <lightstep> i thought that calls in haskell are destructive assignments in the graph
00:05:18 <dons> blackdog actually used it, and was leading the contest untill disqualified (somthiing about the "spirit of the rules")
00:05:21 <Maddas> dons: I have no doubt that what you say is correct, it's just that I don't think it is useful, since you can compile anything to C :-)
00:05:26 <Maddas> Haha
00:05:53 <Maddas> I also tried to use other language when possible when we had to hand in C/Java in course work
00:05:54 <dons> Maddas: yeah, I'm being silly
00:06:21 <dons> Haskell is often slower, sometimes faster. but more powerful and fun :)
00:06:34 <Maddas> :-)
00:07:55 <dons> the above program script generates files like http://www.cse.unsw.edu.au/~dons/run_haskell.c
00:08:12 <Maddas> Beautiful ;-)
00:08:20 <dons> which looks like a valid C program to me -- as blackdog attempted to explain to the judges
00:08:28 <Maddas> Heh!
00:08:55 <dons> and you were allowed to use compilers, and C macro languages.
00:09:03 <dons> and like I say, haskell is a C macro language :)
00:09:04 <Itkovian> wow
00:09:35 <Maddas> Wow, that really is bizarre code for somebody who has no idea what it is supposed to do
00:09:38 <Maddas> (bizarre-looking, that is)
00:09:48 <dons> so, maybe if enough Haskell programmers entered enough C/Java contents this way, they'd have to make them Haskell/C/Java contests..
00:10:01 <Maddas> Oh
00:10:21 <dons> you were even allowed to use lex and yacc -- which just generate obfuscated tables of C code too
00:10:25 <dons> bah!
00:11:34 <Maddas> dons: Yeah, I used a different language to generate C in a (course) project where the goal was to write the most efficient C/C++/Java program to solve a particular (small) problem. The professor was actually interested in it since he wondered how well it would perform and the restriction to use C/Java/C++ was given by the framework to evaluate performance
00:11:57 <Maddas> I also managed to be the fastest of the group for everything I wrote, but that's largely because of choosing appropriate algorithms (:
00:12:31 <dons> cool. the rules should really be that as long as you submit something they can test, then any language goes
00:12:38 <dons> abitrary language restrictions suck
00:13:25 <Maddas> Well, it was just a bot that evaluated the programs (online, too, so you would e-mail (or submit otherwise) the source code and it would answer with how long it took, there are also online tables for the fastest solutions for all problems)
00:13:56 <Maddas> Just listing the times, not the source of the fastest programs
00:14:11 <dons> that's quite a nice system
00:14:43 <Maddas> It's fun, yeah. Unfortunately the programs have to have really low overhead for most problems to be competitive, since run times are often <100ms
00:15:31 <Maddas> And the source code can't be over 50k lines, which unfortunately rules out certain compilers :-)
00:15:49 <Maddas> (And you can't use a large class of system calls since the programs don't run in a sandbox)
00:15:50 <pesco> huh?
00:16:08 <Maddas> Hm?
00:16:19 <dons> Maddas: hehe.
00:16:23 <pesco> How does the 50k-line restriction rule out certain compilers?
00:16:28 * pesco yawns.
00:16:33 <dons> hsinc, for one
00:16:39 <Maddas> Stalin, for example, always generated way, way, way, way larger files
00:16:53 <pesco> What's Stalin?
00:16:59 <Maddas> Oh, sorry, there was also a size restriction, not just a line restriction
00:17:01 <Maddas> A Scheme to C compiler
00:17:13 <dons> ghc generates 20,000 line C files from Haskell modules, sometimes
00:17:16 <pesco> Ah! I remember.
00:17:45 <musasabi> of course concatenating lines...
00:17:55 <dons> but then you've also got a 50,000 line rts to append to the file...
00:17:56 <pesco> He did mention the size restriction.
00:18:08 <musasabi> :-(
00:18:10 <pesco> :(
00:18:11 <dons> plus library code... hmm.
00:18:34 <Maddas> dons: Yeah, everything also needed to be in one file. That were the things that severely restricted the choice of suitable compilers
00:18:42 <dons> yup
00:20:14 <pesco> Damn, how do I find out how to properly write Show and Read instances!?
00:20:48 <pesco> Can someone explain to me what an implementation of showsPrec should do exactly?
00:20:56 <dons> have a look in fptools/libraries/base/GHC/Show.lhs
00:21:28 <dons> instance Show Bool where
00:21:29 <dons>   showsPrec _ True  = showString "True"
00:21:35 <Maddas> Stalin compiled with itself for IA32 is 728k lines
00:21:38 <Maddas> (of C)
00:21:52 <dons> hehe
00:23:11 <dons> now, hmm. by my last count GHC was 229,345 lines Haskell + 126,685 comments
00:23:27 <dons> so, hmm, how many lines of C..argh too many!1
00:24:27 <Maddas> Yeah. And trying to 'fix' code like that to remove unallowed dependencies/system calls is unpleasant, to say the least
00:26:17 <pesco> dons: Thanks.
00:34:12 * ralf kisses self goodnight
01:08:24 <jlouis> Maddas: what a magnificient idea. I must use that for a couple of courses from now on
01:08:58 * boegel bows
01:10:04 <Lemmih> Greetings boegel.
01:11:16 <boegel> hey Lemmih 
01:14:22 <Maddas> jlouis: Linj actually worked for handing in Java homework which was read by a TA since it generates very readable source (which is also one of its declared goals)
01:14:32 <Maddas> You do lose power, of course
01:17:12 <Itkovian> @seen shapr
01:17:13 <lambdabot> shapr is in #haskell.
01:17:22 <Itkovian> well now ...
01:19:05 <autrijus> whew.
01:19:51 <autrijus> miraculously I've managed to define the required one-pass lexer+parser that can switch parser components in the middle of the lexeme stream.
01:20:20 <autrijus> (Monadic State Dispatcher)++ # best thing since sliced bread
01:20:38 * Itkovian wonders how one can perform an bitwise or in bash and pass the value on as a string on the command line for a command ...
01:20:44 <Itkovian> did I just say that?
01:20:56 <autrijus> xargs ?
01:21:13 <Itkovian> hmm ... let me check
01:30:55 <wli_> Itkovian: I can do it in zsh
01:31:35 <Itkovian> how?
01:33:06 <wli_> $ printf "0x%lx\n" $(( 0xfff000 | 0x000fff ))
01:33:06 <wli_> 0xffffff
01:33:37 <wli_> $ printf "0x%lx\n" $(( 0x60606060 | 0x0a0a0a0a ))
01:33:37 <wli_> 0x6a6a6a6a
01:33:39 <autrijus> my brain starts thrashing. it's not a good sign.
01:33:55 <Itkovian> groovy.
01:34:12 <Itkovian> heh, bash does it too :-)
01:34:22 <Itkovian> another thing learned.
01:34:42 <pesco> What was the task?
01:34:47 <Itkovian> my scripts will be very leet ;-)
01:34:51 <wli_> Itkovian: try floating point in bash
01:35:01 <Itkovian> no thanks.
01:35:52 <Itkovian> i'll stick at shifting and | bits ;-)
01:41:58 <dons> couldn't you cat it into ghci and use .|. etc ... ;)
01:42:51 <Itkovian> heh
01:43:07 <Itkovian> ghci isn;t installed on all machines I'm measuring on ... :-(
01:44:53 <boegel> so install it :p
01:45:11 <autrijus> suppose TArray is a class that reads "TArray t e | t -> e"
01:45:25 <dons> $ echo "Numeric.showHex ((Data.Bits..|.) 0xfff0000 (0x000ffff::Int)) []" | ghci -v0 
01:45:26 <autrijus> how do I declare the type of "myArray" to be a TArray that has "e" that is another TArray?
01:45:28 <dons> "fffffff"
01:45:40 <autrijus> I can't see a way of doing it.
01:45:59 <autrijus> that is, "e" must fit "TArray e m" as an instance.
01:46:36 <autrijus> the intuition is of course arrays of arrays.
01:47:29 <boegel> @index error
01:47:29 <lambdabot> GHC.Base,GHC.Err,Prelude
01:47:30 <lightstep> for example, if TArray t1 t2 and TArray t2 t3 hold, you can have myArray :: t1
01:47:35 <boegel> @type error
01:47:36 <lambdabot> error :: forall a. [Char] -> a
01:47:38 <autrijus> lightstep: yes.
01:47:48 <autrijus> exactly as such.
01:47:49 <boegel> strange type...
01:48:20 <lightstep> then i can conclude that i don't understand
01:49:53 <autrijus> maybe just 
01:49:54 <autrijus>     myArray :: (TArray t1 t2, TArray t2 t3) => t1
01:49:58 <boegel> @type span
01:49:59 <lambdabot> span :: forall a. (a -> Bool) -> [a] -> ([a], [a])
01:50:29 <lightstep> autrijus: that would make myArray be _any_ array of arrays
01:50:47 <lightstep> autrijus: like [] is of type [a], that is a list of a for all types a
01:51:03 <autrijus> ok.
01:53:06 <wli_> $ let x=0.5
01:53:06 <wli_> $ echo $(( 1.0 + $x/(1.0 - $x/(2.0 + $x/(3.0 - $x/(2.0 + $x/(5.0 - $x/(2.0 + $x/(7.0 - $x/(2.0 + $x/(9.0 - $x/(2.0 + $x/(11.0 - $x/(2.0)))))))))))) ))
01:53:06 <wli_> 1.6487212707001282
01:54:27 <wli_> $ let x=-1.5707963268                                                           $ echo $(( 1.0 + $x/(1.0 - $x/(2.0 + $x/(3.0 - $x/(2.0 + $x/(5.0 - $x/(2.0 + $x/(7.0 - $x/(2.0 + $x/(9.0 - $x/(2.0 + $x/(11.0 - $x/(2.0)))))))))))) ))
01:54:27 <wli_> 0.20787957636314336
01:59:50 <jlouis> taylor?
02:00:01 <wli_> jlouis: w0t?
02:00:23 <wli_> jlouis: that's a continued fraction
02:04:04 <wli_> jlouis: a rather swiftly converging one, at that =)
02:05:45 <jlouis> wli_: ah
02:06:11 <wli_> continued fractions kick ass
02:12:00 <boegel> is there a way to make Happy produce lhs files in stead of hs files?
02:12:18 <wli_> output to pipe, postprocess?
02:13:37 <boegel> wli_: it should work on both linux and win32
02:13:51 * wli_ runs in terror
02:14:04 <boegel> when someone wants to use my raytracer, and add more functionality, it should be quite simple to make the needed adjustments
02:14:09 * wli runs very, very quickly, very very far away
02:14:20 * boegel throws a rope to catch wli 
02:14:25 <boegel> and misses...
02:17:22 <lightstep> compile a postprocessor: main = interact (unlines . map ("> " ++) . lines)
02:26:00 * shapr boings
02:26:06 <jlouis> oy Shammah 
02:26:11 <jlouis> shapr even
02:26:32 <shapr> g'mornin jlouis 
02:28:24 <boegel> @type getContents
02:28:25 <lambdabot> getContents :: IO String
02:28:31 <boegel> @index isAlpha
02:28:32 <lambdabot> Data.Char,GHC.Unicode,Char
02:30:02 <boegel> shapr,check my website to see some screenshots of my raytracer GUI
02:31:12 <boegel> hmm, the example in the Happy docs, I can't seem to get it to work...
02:31:22 <boegel>     No instance for (Show Exp)
02:31:23 <boegel>       arising from use of `print' at TestParser.hs:325
02:33:48 <boegel> hmm, I had to add 'deriving Show' in various places... the Happy example should work straight ahead, no?
02:53:26 <shapr> Why doesn't the internet serve food?
02:54:09 <boegel> I'm hungry too
02:54:30 <boegel> and here comes mommy with soup ! :D
02:54:30 <boegel> bye
03:17:04 <lightstep> which haskell graphical libraries are working well with debian?
03:20:20 <autrijus> wxHaskell surely?
03:20:28 <boegel> gtk2hs ! :p
03:20:30 <autrijus> (or maybe wxCairo)
03:20:32 <boegel> no, I dunno
03:25:23 <lightstep> err, gtk2hs depends on ghc6 (< 6.02.2) (UNAVAILABLE)
03:25:47 <Itkovian> lightstep: certainly you can compile ghc on a debian box?!
03:26:06 <lightstep> yeah. but i already have ghc6
03:26:24 <lightstep> but it's 6.2.2-2
03:26:56 <lightstep> why can't it just work as simply as emacs? (not that i like emacs)
03:27:18 <Itkovian> heh
03:27:21 <Itkovian> I have no idea
03:28:05 <lightstep> maybe i'll just compile gth2hs from the sources. that should be lots of fun
03:34:05 <boegel> lightstep: should work...
03:36:17 <lightstep> nevermind. i found InstallationTips in the wiki
04:01:06 <autrijus> turing completeness with type propagation is finally within sight.
04:01:34 <autrijus> I guess implementing a language for the second time won't be this exciting :)
04:06:37 <boegel> anybody know what this could mean while trying to run happy to generate a parser: 
04:06:45 <boegel> unused terminals: 3
04:06:50 <boegel> that's all I get :s
04:07:46 <lightstep> you should see a plastic surgeon for those lips
04:11:41 <Lemmih> Hey Oejet.
04:17:47 <Oejet> Hej, Lemmih.
04:20:50 <Oejet> Working on anything interesting?
04:22:08 <boegel> is there any way to write 'type Color = (Double,Double,Double)' as a data declaration ?
04:25:13 <dons> data Color = C Double Double Double ??
04:25:46 <dons> boegel: unused terminal means that you've defined some terminals but they don't appear in the grammar
04:28:01 * boegel scratches his head
04:28:19 <boegel> dons: can you help me with Happy a bit ?
04:28:24 <dons> sure
04:28:36 <boegel> okay, let me show you my Happy file...
04:28:40 <boegel> it's full of error :p
04:28:42 <boegel> +s
04:30:05 <dons> the terminals are the bit after the %token decl
04:30:15 <Lemmih> Oejet: Figured out how to add subtyping to Hacanon but I'm stuck in the implementation.
04:31:39 <duncan> lightstep: I should really find someone to make a debian pacakge for gtk2hs, but it should build from source reasonably easily
05:06:40 <lightstep> duncan: thanks. but i discovered that i  don't have time for haskell today
05:19:34 <boegel> anybody familiar with Happy ? I have a small question...
05:29:29 * boegel scratches his head
05:30:45 <Lemmih> Happiness is not quite my area of expertise.
05:34:13 * boegel pets Lemmih 
05:41:25 <shapr> wheee
05:44:17 <Lemmih> Good evening, shapr.
05:44:43 <shapr> g'mornin Lemmih 
05:47:47 * shapr boings cheerfully
05:48:06 <wli> Is Dylan Thurston on this IRC channel?
05:48:23 <pesco> Hello shapr!
05:48:27 <wli> dylan: 2^(O(n)) \supsetneq O(2^n)
05:48:38 <shapr> I think Dylan has been here once or twice.
05:48:44 <shapr> greetings pesco 
05:49:22 <shapr> I got three emails with positive responses to The Monad.Reader, yay! We gonna do something cool!
05:49:53 <pesco> Cool!
05:50:16 <Igloo> wli: Can you give an example?
05:50:39 <shapr> John Hughes likes the idea, says he'd write something if he weren't so busy.
05:51:09 <shapr> I think I'll ask him for a 'process' article if he has time. Maybe he describe how he got from monads to arrows.
05:51:10 <wli> Igloo: n/log(2) is in O(n), but 2^(n/log(2)) = e^(log(2)*(n/log(2))) = e^n which is not in O(2^n).
05:51:37 <pesco> shapr: That's great!
05:52:39 <wli> I said when |f(n)| <= K*|n| is sharp for K >= 1/log(2)
05:53:16 <wli> which is pretty much the same thing as n/log(2)
05:55:20 <wli> Igloo: rather serious problem, eh?
05:58:22 <duncan> Igloo: who should I ask about getting a gtk2hs package into debian?
05:59:45 <Igloo> duncan: Marvin was looking at it a while ago but I think he's given up for now. When it reaches the point it's a cabal package and all one needs to do is aim the Debian cabal packager at it and press fire I'll be happy to do it  :-)
06:00:10 <Igloo> Until then, CosmicRay or SyntaxNinja might be interested (although Syn was looking at wxhaskell, so possibly not him)
06:00:38 <duncan> Igloo: it does ./configure; make; make install fine now, version 0.9.6's build system was more than a bit dodgy
06:01:35 <shapr> hiya ex__nor
06:01:55 <duncan> Igloo: I'm not sure we'll be able to use Cabal for some time, we have difficult requirements for a build system
06:02:56 <Igloo> wli: Ah, I see, thanks
06:03:37 <Igloo> duncan: Hmm, what implementations do you support, and do you plan to support?
06:04:21 <duncan> Igloo: we support ghc 5.04 -> ghc 6.2.2, I've never tried other compilers
06:05:27 <duncan> Igloo: I might be able to get it to work with other implementations we don't use many non haskell 98 features
06:05:31 <Igloo> OK, I'll try to take a look some time
06:06:05 <Igloo> What stops you using cabal OOI?
06:06:47 <duncan> oh, thanks. BTW you need a machine with quite a bit of memory to build or follow the advice on http://gtk2hs.sourceforge.net/download/ for low memory machines
06:07:14 <Igloo> Even if you have your own implementation for setup.lhs, it would be much easier if you took care of being able to build for ghc5 or ghc6 (or any others) etc in the standard way
06:07:39 <Igloo> What does quite a bit mean?
06:07:48 <wli> Igloo: much
06:08:00 <Igloo> Ah, 400M. Some of the buildds could have fun with that
06:08:14 * Igloo wonders what the equivalent number for ghc6 is
06:08:22 <duncan> Igloo: the problem with cabal at the moment is that they are targeting the simple library builds. We have multiple packages with dependencies between them. We build several source generation tools etc.
06:09:12 <duncan> Igloo: the memory issues is because c2hs is very greedy with memory. We're trying to fix it but its an architectural problem in c2hs.
06:09:16 <pesco> Woot. The Pimmle parser has succesfully read its own specification and implementation.
06:10:06 <shapr> Pimmle?
06:10:19 <pesco> shapr: Pescomarkup.
06:10:22 <pesco> ;-)
06:10:45 <shapr> oh, neat
06:10:47 <duncan> Igloo: is it possible to wrap an ordinary autoconf/automake build in a setup.lhs cabal thingy?
06:11:10 * Igloo isn't a cabal expert
06:11:27 <duncan> Igloo: me neither :-(
06:11:47 <pesco> Soon I will have turned XML into what it has always looked like. Muahahahaaa.
06:12:40 <pesco> Time to watch Enterprise...
06:12:51 <shapr> Even though it's cancelled?
06:13:32 <pesco> shapr: Sure, I'm leeching episode after episode from a nice dutch guy. I'm at s02e02.
06:13:53 <pesco> I would not dare watch the show dubbed on german TV.
06:13:55 * pesco shudders.
06:13:59 * shapr laughs
06:14:15 * pesco disappears.
06:14:16 <shapr> speaking of which... I switched the audio on our Star Trek DVDs to German.
06:14:28 * pesco sticks his head back in.
06:14:33 <pesco> What happened?
06:14:36 <shapr> I'd have to agree with your opinion of German dubbing.
06:14:43 <Lemmih> What? Enterprise got cancelled?!
06:14:51 <shapr> french is passable, italian is nutty
06:15:04 <musasabi> duncan: yes, you can use autotools with cabal iirc.
06:15:04 <shapr> spanish is a blast, has me rolling on the floor with laughter.
06:15:25 <pesco> shapr: Heh. Imagine my face when I returned from a year in the USA, first seeing a show I knew from there in German.
06:15:25 <shapr> Raumpatrouille Orion is GREAT!
06:15:30 <shapr> pesco: ouch!
06:15:48 <shapr> have you seen the 2003 DVD of Raumpatrouille Orion?
06:16:09 <shapr> That's really high-quality German Sci-Fi
06:16:14 <musasabi> module Main where \n import Distribution.Make (defaultMain) \n main = defaultMain
06:16:34 <pesco> I just yelled "But! What! I mean their lips, look at their LIPS!" at my family.
06:16:39 * shapr laughs!
06:16:43 <pesco> "How can you _watch_ that?!"
06:16:53 * shapr laughs more
06:17:08 <pesco> But quickly now, I have no time!
06:17:11 <shapr> ok!
06:17:14 * pesco finally disappears.
06:18:00 <shapr> Reminds me of Swedish subtitle text in TV movies. They are so confused sometimes.
06:18:42 <duncan> musasabi: thank's I'll take a look
06:18:44 <jlouis> shapr: as if danish subtitles are any better ;)
06:19:24 <shapr> One instance recently where the whole plot (if you only read the swedish) went horribly wrong because of some confusion on the part of the translator. This translator was *so* lost.
06:19:49 <jlouis> hehe, funny
06:20:02 <shapr> I think it was Lethal Weapon 2 actually. It's like, how you can get confused? It's just caveman stuff!
06:20:13 <CosmicRay> morning, shapr
06:20:17 <shapr> y0 Coz, wazzzup?
06:20:34 <CosmicRay> shapr: I think I am going to write an XML-RPC client for freshmeat.
06:20:40 <CosmicRay> shapr: I am tired of announcing software there. :-)
06:20:54 <shapr> jlouis: I have to try the Danish subtitles on our DVDs to check the humor potential.
06:21:05 <shapr> CosmicRay: can you send in announcements via xml-rpc?
06:21:09 <CosmicRay> yup
06:21:14 <shapr> wow, that's cool.
06:21:25 <CosmicRay> esr has some crappy client for it, apparently it only works with rpm spec files
06:21:26 <shapr> You're going to use Bringert's XmlRpc?
06:21:41 <shapr> With Cabal file input?
06:21:45 <CosmicRay> I think so (that's the most popular one, right?)
06:21:49 <CosmicRay> Hmm.  sweet idea.
06:21:53 <shapr> It's the only one.
06:22:00 <CosmicRay> then that one, yes :-)
06:22:04 <shapr> Actually, Simon Foster may have written some XmlRpc code too.
06:22:12 * shapr looks at Si\
06:22:14 <CosmicRay> I'll probably slap it into missingh if it isn't already
06:22:28 <CosmicRay> what is it with people named Simon and haskell? :-)
06:22:41 <shapr> Simon Foster, Peter Simons...
06:23:20 <Si\> no, I've done nothing on XmlRpc, I'm putting together an XML Serializer for Haskell, which could theoretically be used for XML-RPC, but I'll be using it for SOAP, RDF, OWL, OWL-S and XML-Schema
06:23:52 <CosmicRay> ah, is that serializer part of haxml?
06:24:01 <Si\> no, it uses HXT
06:24:11 * CosmicRay googles
06:24:19 <Si\> The Haskell XML Toolbox
06:25:02 <Si\> it isn't part of anything, it uses SYB3 and HXT to enable maximally automated serialization of Haskell data-types
06:26:05 * CosmicRay bookmarks this
06:26:17 <CosmicRay> Si\: SOAP will be great to see, btw
06:26:36 <CosmicRay> I hate SOAP but am going to be forced to use it before long
06:27:07 <jlouis> Toss it inside a monad. Forget about it
06:27:21 <CosmicRay> heh
06:27:22 * shapr throws his phone into a monad
06:27:31 <shapr> hiya Philippa 
06:27:34 <Philippa> 'lo
06:27:36 <Philippa> 'sup?
06:27:41 <jlouis> Bring the holy water! That monad is impure!
06:27:42 <shapr> Actually, I need to buy a new phone. What should I get?
06:27:42 <CosmicRay> shapr: oh and missingpy is out there now.
06:27:47 <CosmicRay> jlouis: heh
06:27:59 <Philippa> one that calls
06:28:01 <shapr> CosmicRay: yeah, you going to write a TMR demo for missingpy?
06:28:05 <shapr> Philippa: too easy!
06:28:12 <Si\> http://savannah.nongnu.org/projects/haifa
06:28:18 <CosmicRay> jlouis: there was a story on NPR about some spanish church bell that was declared posessed by the catholic church in the 1500s, and ordered to "never ring again"
06:28:33 <shapr> Si\: btw, del.icio.us has a coupla people linked to haifa
06:28:39 <CosmicRay> jlouis: 5 years ago, the church sent a cardinal to the bell to perform an exorcism involving chanting and holy water.
06:28:45 <CosmicRay> jlouis: now they are allowed to ring it.
06:29:02 <shapr> CosmicRay: that's a long time to respond to a bug report
06:29:05 <CosmicRay> haha
06:29:18 <shapr> sounds like microsoft
06:29:34 <CosmicRay> shapr: they originally declared it posessed because some guy was killed while ringing it
06:29:41 <CosmicRay> (it is apparently a *large* bell)
06:29:43 <shapr> I can dig it.
06:30:06 <shapr> I recently read a cool book that had a posessed bell in it.
06:30:11 <CosmicRay> oh?
06:30:17 <tintin> CosmicRay: oh but ghosts do change their houses once in a while and maybe they moved :)
06:30:21 <shapr> something on baen.com/library
06:30:53 <shapr> There's some brilliant (and free) sci-fi on baen.com/library
06:31:00 <shapr> buncha crap too
06:31:05 <CosmicRay> heh
06:31:27 <shapr> But really some of the most original sci-fi I've ever read is up there.
06:31:33 <shapr> I should put book reviews on my blog.
06:31:54 <CosmicRay> shapr: yeah, I'd like to write somthing for tmr about missingpy.  first I need to do my FSM article, and then probably my taxes.  but yes, I'll do it :-)
06:32:01 <shapr> yay!
06:32:18 <tintin> shapr: i prefer gutenberg 
06:33:02 * boegel is still looking for help with Happy
06:33:16 <shapr> Ideas, outline, summary or whatever has to be in to me by Monday the 7th, article must be finished by the 21st.
06:33:21 <CosmicRay> heh, seen on slashdot: "We are pentium of borg.  division is futile.  prepare to be rounded."
06:33:32 <autrijus> shapr: TZ?
06:33:38 <shapr> Since software and schedules go so well together, that last week is reserved for panic.
06:33:44 <CosmicRay> heh
06:34:12 <shapr> autrijus: yes please, you know where I can buy one for less than a thousand crowns?
06:34:19 <boegel> CosmicRay: are you familiar with happy ?
06:34:28 <shapr> autrijus: "Date with the devil, at your own risk"
06:34:32 <Philippa> shapr: had time to look over the code I put up?
06:34:32 <autrijus> shapr: you want to buy a time zone?
06:34:39 <autrijus> shapr: what kind of trade is this?
06:34:39 <shapr> autrijus: er, Twilight Zone?
06:34:49 <shapr> The pinball game?
06:34:50 <CosmicRay> boegel: no, but I've used ocamlyac/ocamllex, which I gather are similar
06:35:14 <shapr> Philippa: I looked at a bit of it, I was thinking it might fulfill CosmicRay's request for shapr's n00b column.
06:35:22 <shapr> autrijus: I'm in CET.
06:35:27 <CosmicRay> oh, something about TH?
06:35:30 <autrijus> ok, so 7th CET.
06:35:39 <boegel> I'm trying to use happy for parsing my scene descriptions... but I'm experiencing some problems with it, since it's my first time ever I've used it
06:35:54 <CosmicRay> boegel: I'm a big parsec fan
06:35:57 <shapr> autrijus: honestly, I'm not picky, I just want high quality articles in the mag.
06:36:08 <boegel> CosmicRay: is it so much better than Happy?
06:36:15 <autrijus> 'kay.
06:36:23 <boegel> shapr: are you sure you want mine then ? :)
06:36:35 <CosmicRay> boegel: if happy is what I think it is, then yes.
06:36:39 <shapr> boegel: Sure, make it so!
06:36:56 <shapr> I reserve the right to veto any article that sucks, especially if I wrote it.
06:37:03 <CosmicRay> lex/yacc are, imho, tired programs who should be given a proper burial
06:37:20 <CosmicRay> modern imitations of them should be left out to rot
06:37:22 <autrijus> they are Undeads of our time.
06:37:35 <boegel> CosmicRay: including Happy ?
06:37:38 <Philippa> shapr: feel free to write a general intro, I'm more about the trickery
06:37:46 <CosmicRay> boegel: yes, sad, isn't it?
06:37:54 <shapr> I haven't tried Happy before.
06:37:55 <Philippa> also, two TH-related articles in one issue could work - one as a general explanation, one doing something mildly sick :-)
06:38:07 <shapr> where's the Happy intro?
06:38:08 <boegel> CosmicRay: well, it kind off ok... I got most of it working in 2 hours or so
06:38:09 <CosmicRay> boegel: but again, I've never used happy, I just read the description once and decided to use parsec :-)
06:38:27 <CosmicRay> parsec has some nice practical features
06:38:30 <CosmicRay> backtracking for one
06:38:34 <boegel> pff, if I'd have to figure out parsec too now, i've lost all my time with Happy...
06:38:42 <boegel> CosmicRay: http://studwww.ugent.be/~kehoste/thesisPublic/happy/
06:38:47 <Philippa> yep, you can make parsec go reasonably quickly
06:38:58 <CosmicRay> ah yes.
06:38:58 <Philippa> and the state in it can allow some really sneaky and impressive tricks
06:39:01 <CosmicRay> this is what I thought it was.
06:39:01 <autrijus> mildly sick, like piping the rest of the program to a SMTP post to haskell-cafe, wait for a proper answer, parse the answer and inject it back to the program, then continue to run it?
06:39:18 <CosmicRay> haha
06:39:27 <Philippa> heh
06:39:30 <shapr> Wow
06:39:32 <boegel> CosmicRay: is parsec easier then than Happy ?
06:39:33 <Philippa> not quite like that, there's no IO hook :-)
06:39:38 <Philippa> very likely
06:39:44 <autrijus> unsafePerformIO, sir
06:39:48 <Philippa> I can't see Happy being any easier than parsec, put it that way
06:39:49 <CosmicRay> boegel: I believe so
06:39:58 * Philippa points at her... nick, shall we say? and coughs
06:40:11 <boegel> CosmicRay: can you some me a good (simple) example of using parsec ?
06:40:11 <autrijus> unsafePerformIO, madam
06:40:24 <Philippa> thank you. You may now lick my boots
06:40:25 <Philippa> ;-)
06:40:28 <shapr> boegel: hm, doesn't look so bad. What's the problem with your Happy.y?
06:40:29 <CosmicRay> boegel: there are two in MissingH, both moderately complex
06:40:33 * autrijus proceeds to boot Philippa's licks
06:40:33 <CosmicRay> boegel: one is an FTP protocol parser
06:40:38 <CosmicRay> boegel: the other is a config file parser.
06:40:38 * shapr laughs
06:40:46 <Philippa> boegel: http://snowblind.scannedinavian.org/~flippa/stuff/Parser.hs
06:40:56 <boegel> shapr: I'll post the GHCi error message on the wiki
06:41:00 <shapr> ok
06:41:01 <boegel> @wiki HaskellIrcPastePage
06:41:02 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:41:58 <basti_> uhm shapr concerning TMR... I've thought about it... I think I could write a CSound/Haskore thing. I have an Idea that could do something entertaining, but I dont know if it would be 1 article or rather 3-5 :P
06:41:58 <Lunar^> CosmicRay: marking FFI calls safe is not enough :(
06:41:59 <shapr> I like this irc channel.
06:42:14 <shapr> basti_: 1 article is cool, 3-5 is even cooler.
06:42:21 <CosmicRay> Lunar^: bummer
06:42:27 <boegel> pasted
06:42:32 <CosmicRay> Lunar^: I'd say check on -cafe
06:42:33 <Lunar^> CosmicRay: yeah :( I don't know how to handle that
06:42:38 <CosmicRay> Lunar^: I'm no ffi expert
06:42:46 <CosmicRay> Lunar^: I just play one on comp.lang.python
06:43:14 <Lunar^> CosmicRay: I will finish the binding (doc, and packaging) and post something on -cafe
06:43:22 <Lunar^> CosmicRay: asking for help
06:43:58 <shapr> boegel: TokenSphere Double Point3D
06:44:23 <basti_> shapr: how many words would a TMR Article have?
06:44:30 <boegel> shapr: what about it ?
06:44:41 <shapr> boegel: all the other places sphere has one argument
06:44:56 <CosmicRay> Lunar^: basically, my method of working with ffi is: 1) read the spec, 2) try to divine all the details it doesn't give by tinkering until it doesn't segfault anymore
06:45:13 <shapr> basti_: well, long enough to cover the subject I guess.
06:45:22 <boegel> shapr: I'm not sure how to translate that in the .y file
06:45:30 <basti_> shapr: >.< yes i'd hope.
06:46:06 <shapr> basti_: are you worried about making it too long?
06:46:07 <Lunar^> CosmicRay: I've been doing FFI stuff for some time now
06:46:21 <Lunar^> CosmicRay: but never bitten by reentrancy
06:46:29 <CosmicRay> yeah
06:46:43 <basti_> shapr: rather, yes.
06:46:46 <tintin> what is reentrancy ?
06:46:48 <CosmicRay> if you solve this problem, then I will probably go on to make Haskell Handles (or any HVIO object) available as a Python file-like object
06:47:20 <shapr> boegel: I think it's ObjType where you need to make space for two numbers
06:47:22 <basti_> shapr: i would say an article has like maybe 4 or 5 book pages of text.
06:47:40 <Lunar^> tintin: entering more than once in a single code fragment
06:48:12 <shapr> basti_: tell me about your Idea
06:48:43 * boegel swears
06:49:01 <shapr> boegel: does that help?
06:49:59 <tintin> Lunar^: and why does that happen and how does haskell avoid it  ?
06:50:39 <boegel> shapr: no...
06:50:51 <boegel> I think I should define sphere having 2 arguments
06:51:01 <boegel>       sphere          { TokenSphere $$ }
06:51:13 <boegel> this means '1 arg' I think
06:51:19 <boegel> but if I do       sphere          { TokenSphere $$ $$ }
06:51:26 <shapr> boegel: try cutting the sphere code out into a single file
06:51:39 <boegel> shapr: how do you mean ?
06:51:46 <shapr> then have just a few line that you can hack around until they work
06:52:46 <Lunar^> tintin: The RTS is a complicated piece of code. What I'm trying to do here is C -> Haskell -> C -> Haskell... (re)Entering Haskell land a second time blocks
06:53:06 <shapr> hiya shlomi
06:53:08 <rindolf> Hi all!
06:53:13 <shapr> wassup?
06:53:20 <rindolf> shapr: hi! are you a bot?
06:53:27 <shapr> Only on odd days.
06:53:32 <shapr> And I think it's an even day today.
06:53:50 <rindolf> shapr: do I know you from somewhere?
06:54:16 <shapr> maybe?
06:54:22 <boegel> rindolf: shapr is our giving-the-tour-bot
06:54:28 <tintin> shapr: is Une pom-pom girl of #hakell our mascot .... 
06:54:29 <shapr> I dunno, I've just seen your code around on the net, nice to meet you realtime.
06:54:29 * boegel laughs
06:55:25 <rindolf> shapr: OK.
06:55:48 <rindolf> I'm looking for a few Haskell built-in functions.
06:55:58 <boegel> @arr
06:55:58 <lambdabot> Prelude.(!!): index too large
06:56:01 <shapr> rindolf: have you heard of Shae Erisson ?
06:56:11 <shapr> Not that I'll be surprised if you haven't :-)
06:56:29 <shapr> @arr
06:56:29 <lambdabot> Well me hearties, let's see what crawled out of the bung hole...
06:56:36 <boegel> @arr
06:56:36 <lambdabot> I'd like to drop me anchor in her lagoon
06:56:39 <rindolf> One of them should ideally split a string into two starting from the first period.
06:56:41 <boegel> lol
06:56:51 <shapr> @type split
06:56:52 <lambdabot> bzzt
06:56:57 <rindolf> shapr: I don't recall your name from anywhere.
06:56:58 <boegel> @index split
06:56:58 <lambdabot> Language.Haskell.THSyntax,GHC.Exts,System.Random,Random
06:56:59 <shapr> rindolf: span and break
06:57:17 <rindolf> shapr: OK looking.
06:57:48 <rindolf> shapr: are they GHC extensions?
06:57:53 <shapr> nope, Prelude
06:58:12 <shapr> That is, part of the standard libraries as specified in the standard
07:01:10 <pesco> Moo.
07:01:14 <rindolf> Hmm... there's splitAt
07:02:21 <rindolf> shapr: I see break in http://www.zvon.org/other/haskell/Outputprelude/index.html but not span.
07:02:29 <shapr> @index span
07:02:29 <lambdabot> Data.List,GHC.List,Prelude,List
07:02:32 <shapr> @type span
07:02:33 <lambdabot> span :: forall a. (a -> Bool) -> [a] -> ([a], [a])
07:03:01 <shapr> span (/= '.') "The Monad.Reader"
07:03:55 <shapr> rindolf: was that clear? or obtuse? :-)
07:04:23 <rindolf> shapr: it was clear enough.
07:04:34 <rindolf> shapr: it seems that break is like span (!cb)
07:04:46 <shapr> Yes, they're pretty much the same thing.
07:04:57 <shapr> rindolf: would you like the Haskell intro and the #haskell tour?
07:05:27 <rindolf> shapr: I already read the Gentle Intro to Haskell.
07:05:45 <shapr> ok
07:06:40 <shapr> Any other questions?
07:07:05 <rindolf> shapr: not at the moment, but I'll just lurk in the meantime.
07:07:31 <shapr> awright, feel free to ask questions when you find them
07:07:31 * boegel thinks he has pinned-down the happy problem
07:11:25 <shapr> boegel: what was it?
07:13:28 * shapr boings cheerfully
07:15:24 <boegel> shapr: we'll, I'm not sure about the sphere-error, so I just did this:
07:15:48 <boegel> TokenSphere (Double,Point3D) instead of TokenSphere Double Point3D
07:15:53 <boegel> so sphere has only 1 arg
07:16:06 <boegel> that removes that error
07:16:08 <shapr> oh, sensible
07:16:13 <boegel> but now I have a problem with the lexer
07:16:41 <boegel> when it reads "window", it shouldn't just provide the TokenWindow, but also the Window which comes along with it
07:16:48 <boegel> and that's no as easy
07:20:07 <boegel> @index read
07:20:07 <lambdabot> GHC.Read,Prelude,Text.Read
07:20:23 <boegel> @eval read "1"
07:20:23 <lambdabot> unbound variable: read
07:20:31 <boegel> @eval Prelude.read "1"
07:20:31 <lambdabot> <<EM Dynamic -> EM Dynamic>>
07:20:34 <boegel> heh
07:20:50 <boegel> @type read
07:20:52 <lambdabot> read :: forall a. (Read a) => String -> a
07:21:58 <boegel> how can I check if there's a Read Double instance ?
07:22:13 <shapr> @type read "1.0" :: Double
07:22:15 <lambdabot> read "1.0" :: Double :: Double
07:22:17 <rindolf> OK, I got the following code http://sial.org/pbot/7257
07:22:36 <rindolf> Is there anyway to make it shorter while still having an O(N) complexity?
07:23:09 <shapr> Are you just trying to remove the periods?
07:23:26 <boegel> Prelude Char> read "1.0"
07:23:27 <boegel> *** Exception: Prelude.read: no parse
07:23:35 <shapr> boegel: explicit type sig
07:23:41 <boegel> oh, ok
07:24:59 <rindolf> shapr: all periods except the last one.
07:26:19 <CosmicRay> rindolf: perhaps it would be easiest to just remove all periods and then tack the last one back on?
07:26:51 <rindolf> CosmicRay: interesting idea. But how would I know where it was placed within the string?
07:26:59 <shapr> or reverse span (/= '.') filter (/= '.')
07:27:01 <Igloo> head end == '.'
07:27:13 <CosmicRay> ah, so it's not necessarily at the end of the string.
07:27:16 <CosmicRay> never mind then
07:27:19 <Igloo> And you can eliminate the tail in tail end by matching against '.':end or _:end instead
07:27:49 <rindolf> I also wrote a recursive function which does not make use of any built-ins.
07:28:31 <shapr> it's much more fun to skip built-ins
07:28:54 <rindolf> shapr: "skip" built-ins?
07:29:03 <rindolf> shapr: do you mean avoid using built-ins?
07:29:08 <shapr> yes, it's fun.
07:29:25 <shapr> Sorry, my American is showing through my English.
07:29:55 <shapr> rindolf: have you read through the Prelude?
07:29:58 <rindolf> shapr: yes, that's what I do usually.
07:30:27 <rindolf> shapr: I've just went over the reference in zvon.org for the Prelude.
07:30:29 <shapr> When I'm hacking around for fun, I like to write my own versions of Prelude functions, but I use whatever gets the job done fastest when I'm getting paid.
07:30:48 <rindolf> shapr: you're getting paid to write in Haskell?
07:30:54 <shapr> Sure, don't you?
07:30:59 * shapr grins
07:31:13 <shapr> Even better, I'm getting paid by an EU Project
07:31:21 <rindolf> shapr: actually, at the moment, I'm only getting paid to write articles.
07:31:27 <shapr> Oh, I do that for free.
07:31:28 <rindolf> shapr: I'm looking for a job.
07:31:38 <shapr> But I would like to get paid to write articles.
07:32:01 <rindolf> shapr: have a job interview in IBM Haifa on Monday.
07:32:06 <shapr> Oh cool
07:32:11 <shapr> What sort of work?
07:33:23 <shapr> I currently display my intellectual and academic prowess by building websites in Python.
07:33:55 <rindolf> shapr: I don't know yet. I think it's the Haifa Research Labs.
07:33:58 <rindolf> They do tons of things.
07:34:01 <shapr> ooo, research
07:34:10 * CosmicRay would like a job doing research
07:34:13 <shapr> me too!
07:35:09 <shapr> I have a long list of research I'd enjoy. Porting region-allocation to GHC for the Cell CPU would be pretty high on my list.
07:36:13 <shapr> Maybe using Poly* to model properties of traffic systems. Or write memetic algorithms for social software that runs on iPods.
07:37:21 <shapr> I've noticed the similarity between recurse, inductively defined code and the sort of stuff that happens in StarLogo or other memetic systems. Look at the ICFP ants for example.
07:38:39 <shapr> I should put this in my blog.
07:39:18 <samc_> why do you call StarLogo a 'memetic system'?
07:39:39 <rindolf> shapr: I guess your "display my intellectual and academic prowess by building websites in Python." was ironic?
07:40:09 <shapr> rindolf: Yeah, or at least an attempt at humor. I actually enjoy writing code that makes clients happy.
07:40:24 <shapr> Hacking on Zope/Plone isn't intellectually satisfying though.
07:40:47 <shapr> samc_: What would you call it? Do you understand what I'm trying to describe?
07:41:00 <shapr> Maybe memetic algorithms isn't the right description?
07:41:32 <samc_> did you coin the phrase?
07:41:52 <shapr> y0 funk, wazzup?
07:41:55 <funkmando> ello ello ello
07:41:55 <boegel> @index isDigit
07:41:56 <lambdabot> Data.Char,GHC.Unicode,Char
07:42:08 <boegel> @list Char
07:42:09 <lambdabot> Sorry, I don't know the command "list", try "lambdabot: @listcommands"
07:42:10 <funkmando> hi shapr. i'm wondering how convert a string to an int?
07:42:20 <boegel> funkmando: read
07:42:26 <shapr> samc_: I haven't heard anyone use it, but I figure it's an obvious step after knowing about memes.
07:42:29 <funkmando> read variable
07:42:31 <funkmando> and that's it?
07:42:37 <boegel> funkmando: 
07:42:41 <boegel> read "123"
07:42:48 <boegel> returns 123
07:44:05 <funkmando> cool thanks
07:44:23 <boegel> np
07:56:06 <boegel> how can I do the inverse of read ?
07:56:13 <boegel> from 123 to "123" ?
07:56:15 <funkmando> show?
07:56:24 <boegel> @type show
07:56:26 <lambdabot> show :: forall a. (Show a) => a -> String
07:56:32 <boegel> funkmando: thanks :)
07:56:42 <funkmando> lool
08:03:28 <funkmando> hmm
08:03:35 * shapr shaboings
08:03:43 <funkmando> it won't let me compare ints after converting to strings
08:03:51 <funkmando> for instance  can't do if read a < read b
08:04:08 <boegel> funkmando: (read a) < (read b)
08:04:15 <funkmando> i tried
08:04:24 <boegel> funkmando: (read a :: Int) < (read b :: Int)
08:04:26 <funkmando> saying ambiguous types variable
08:04:28 <funkmando> ok
08:04:46 <boegel> explicit typing, because read can return different types
08:05:20 <funkmando> right
08:05:41 <funkmando> god this is so completely different to any language i've ever used
08:05:42 <funkmando> lol
08:06:01 <shapr> ain't it great?
08:06:28 <shapr> g'bye frax
08:06:31 <funkmando> it's quite funky
08:08:04 * boegel bounces
08:08:09 * shapr boings
08:09:01 <boegel> the parser is compiling *yaay*
08:09:16 <boegel> @index readFile
08:09:16 <lambdabot> Prelude,System.IO,IO
08:09:25 <boegel> @type IO.readFile
08:09:26 <lambdabot> IO.readFile :: FilePath -> IO String
08:10:18 <boegel> @index fileExists
08:10:19 <lambdabot> bzzt
08:10:21 <boegel> @index fileExist
08:10:22 <lambdabot> System.Posix,System.Posix.Files
08:10:37 <boegel> any function to check if a certain file exists ?
08:13:04 <Cale> doesFileExist in the Directory library
08:13:29 <funkmando> @type swap
08:13:30 <lambdabot> bzzt
08:13:38 <boegel> Cale: thanks
08:14:31 <funkmando> if i was to write a swap, function it would take two integers and return two integers right?
08:14:41 <funkmando> so swap :: integer -> integer -> integer -> integer
08:15:46 <CosmicRay> that takes three and returns 1.
08:15:59 <CosmicRay> swap :: (Integer, Integer) -> (Integer, Integer) might be easier.
08:18:45 <funkmando> is it good practise to keep all functions inside or outside your main function?
08:22:44 <boegel> outside funkmando 
08:22:57 <boegel> else your main will blow up
08:23:34 <CosmicRay> boegel: it won't blow up
08:23:58 <shapr> hiya sisonek 
08:24:12 <sisonek> yo shapr
08:24:22 <boegel> CosmicRay: I mean it will get insanely big
08:24:26 <shapr> sisonek: how's code?
08:24:46 <sisonek> which?
08:24:57 <shapr> I dunno, what code are you writing?
08:25:02 <sisonek> oh heh
08:25:10 <sisonek> actually i have a question about haskell
08:25:16 <shapr> Oh good!
08:25:21 <sisonek> i've used prolog to do some natural language stuff
08:25:27 <sisonek> b/c it's easy to mock-up parsers in it
08:25:54 <sisonek> but avoiding blowups is friggin' annoying, especially because i'm doing work with head-final languages
08:26:14 <sisonek> so i'm looking for a stronger replacement, is haskell up to the job?
08:26:19 <shapr> http://www.cs.chalmers.se/~aarne/GF/
08:27:11 <shapr> Is that a good answer?
08:27:24 <sisonek> sweet, looks like a great place to start
08:27:27 <sisonek> thanks
08:27:51 <shapr> I wrote a neat webapp that uses the Swedish grammar to automatically generate various exercises.
08:27:54 <funkmando> how can i sort 3 variables into ascending size?
08:28:41 <shapr> I did morphology and vocabulary. But if you're doing morphology specifically, there's a more powerful purpose-specific Functional Morphology toolkit.
08:29:03 <boegel> what should the return type be of a function which can return Int _or_ Double ?
08:29:06 <boegel> Num ?
08:29:22 <CosmicRay> that is inappropriate if it can only return Int or Double.
08:29:24 <Lemmih> Either Int Double?
08:29:26 <sisonek> nah, i'm just trying to do syntax
08:29:26 <shapr> sisonek: The GF type-system is based on dependent types, much like Epigram if you've seen that language before. It's well described in the docs.
08:29:30 <CosmicRay> yes, what lemmih said
08:29:45 <sisonek> i'll check that out
08:31:20 <sisonek> shapr: this looks like a fantastic place to start, i'll check back once i've run through it
08:31:25 <sisonek> thanks a million
08:31:32 <shapr> Awright, feel free to ask me any questions you have about GF.
08:31:42 <shapr> I've used it enough to have a minor clue.
08:32:41 <Lemmih> Fooie. Time to work.
08:32:44 <shapr> yay work!
08:32:47 <shapr> I gotta work too.
08:33:29 <Lemmih> I wonder if I should leave IRC to increase my productivity...
08:33:38 <shapr> it does help.
08:33:48 <basti_> its no fun though.
08:33:55 <shapr> yeah, but no money is less fun.
08:34:05 <basti_> theres a saying.
08:34:17 <shapr> ?
08:34:20 <basti_> "weed brings us better through times of no money, than money brings us through times of no weed"
08:34:27 <basti_> =)
08:34:30 * shapr snickers
08:34:45 <shapr> But, internet doesn't grow on trees.
08:35:03 <basti_> one day it will.
08:35:16 <shapr> I've been thinking about that actually =)
08:35:26 <shapr> crazy idea number #424242
08:35:31 <basti_> biological cicrcuits? i'm in.
08:35:39 <basti_> for literary purposes at least
08:35:42 <shapr> Combined with Tesla's ground transmission ideas...
08:36:18 <basti_> thats para again.
08:36:19 * basti_ ducks
08:36:33 <basti_> no actually teslas ideas work, but not as good as some people want them to work.
08:36:52 <basti_> like with more than 100% efficiency.
08:36:57 <shapr> Tesla wanted to transmit power, I only want to transmit bits.
08:37:21 <basti_> so why do you need tesla stuff then?
08:37:50 <shapr> Because the FCC doesn't regulate ground transmissions ;-)
08:37:59 <basti_> afaics "Tesla" technology is just regular radio
08:38:15 <basti_> do you have any information about non-aerial radio?
08:38:23 <basti_> and btw, rules can be changed.
08:39:08 <shapr> It seems easier to try to do something unregulated.
08:39:26 <shapr> Look at Big Media's resistance to mp3.com and friends.
08:39:32 <basti_> we'd need sensible ad hoc networking first anyway.
08:39:48 <basti_> oh yes. media industry. there was such a thing :)
08:40:15 <shapr> How does IPv6 do ad-hoc networking?
08:40:26 <basti_> thats one of the big laughs in the last years... next to german opposition....
08:40:30 <basti_> not at all?
08:41:39 <Lemmih> Hello fraxtal.
08:41:43 <CosmicRay> notation question.  If I say "let x = 5 + 3 in x + 9", what do I call "x"?  Is it an identifier?  a variable?
08:41:47 <fraxtal> hey Lemmih 
08:41:52 <CosmicRay> I'd call it a variable in any other language
08:41:57 <CosmicRay> but it doesn't seem right for Haskell.
08:42:14 <Lemmih> What about constant?
08:42:15 <basti_> thats a semantic question i thik.
08:42:18 <basti_> n
08:42:30 <basti_> actually i'd call it a variable. Even though it isnt variable.
08:42:42 <basti_> if i'd refer to it gramatically it'd be a symbol.
08:42:44 <Igloo> It's a variable
08:43:09 <basti_> it even is variable from a certain point of view.
08:43:28 <boegel> CosmicRay: placeholder ?
08:44:00 <CosmicRay> Lemmih: well, it could also be "let x y = t + y in (x 5) + 3"
08:44:04 <CosmicRay> it's not really a constant.
08:44:07 <CosmicRay> a placeholder maybe..
08:44:26 <pesco> I agree with Igloo. It's a variable.
08:44:35 <Lemmih> Then it would be a variable.
08:44:37 <basti_> it IS
08:44:38 <basti_> :)
08:44:44 <basti_> you just cant write to it.
08:44:54 <basti_> you cant in math, too.
08:45:13 <CosmicRay> ok
08:45:18 <pesco> Exactly. The value of x is variable (=any value of the correct type).
08:46:49 * fraxtal is going to spend the weekend with some Haskell tutorials
08:47:03 <Lemmih> Sounds fun.
08:47:15 <basti_> ...until you run into that annoying IO type... :P
08:47:18 * basti_ ducks
08:47:32 <Lemmih> fraxtal: Feel free to ask shapr if you have any questions.
08:47:49 <fraxtal> Lemmih: shapr is a cool guy
08:48:07 <pesco> The IO Monad isn't annoying!
08:48:19 <basti_> im just nagging
08:48:23 <pesco> ;)
08:48:29 <basti_> i know why its there and what its for.
08:48:40 <basti_> actually i find the concept more convincing than "magical" io functions
08:49:00 <pesco> Yes. They're *spit* disgusting.
08:49:08 <basti_> hm.
08:49:13 * basti_ .o° ( ... )
08:51:27 <boegel> yeah fraxtal, if you have any questions, just ask them, but _only_ to shapr :p
08:51:41 <fraxtal> boegel: heh why is that?
08:52:02 <basti_> we're stupid.
08:52:26 * pesco bangs his head against the wall.
08:52:30 <pesco> And crazy.
08:54:06 <Maddas> basti_: Just wondering, why did you say writing that on today's CPUs regexes shout for C?
08:54:16 <Lemmih> fraxtal: We will always answer with something more crytic than the problem you were asking about (:
08:54:19 <pesco> "Sanity on #haskell Deteriorating in Founder's Absence"  -- TMR
08:54:38 <Lemmih> Take for example monads.
08:54:39 <basti_> because regexes are recognized by finite automata, and today's CPU's emulate finite automata really good.
08:55:02 <basti_> nad
08:55:07 <basti_> Maddas: 
08:55:08 <basti_> gna
08:55:21 * basti_ pounces first his font, then his nickname completion
08:55:23 * Maddas blinks
08:55:25 <Maddas> :-)
08:56:03 <basti_> i know that regexes can be modelled nicely in haskell. But if you want to do it like fast, then you will need to compile them to machine code.
08:56:39 <Maddas> How fast do you mean? 
08:56:45 <Maddas> (Compared to existing libraries)
08:56:57 <funkmando> hello
08:56:58 <basti_> fast like in "grep" or various extensions of this.
08:57:03 <pesco> funkmando: Hello!
08:57:29 <basti_> im not talking the occasional regex for checking an irc line for a @ in the beginning or something
08:57:33 <boegel> fraxtal: just joking :)
08:57:44 <basti_> i'm talking searching a database of 100 GB for a string or something.
08:57:46 <pesco> Has anyone benchmarked a Haskell implementation of regex matching against a standard C impl.?
08:58:06 <basti_> against a "compiler" implementation?
08:58:38 <pesco> Yes.
08:58:49 <basti_> we should do that.
08:58:56 <fraxtal> I need to get the GHC and check that out tonight.  I've been using hugs and from what I hear, GHC produces some pretty fast code.
08:59:06 <funkmando> i'm trying to write a function that calls two other functions in order to find the max of 3 integers
08:59:13 <funkmando> so why is this invalid? :
08:59:15 <funkmando> maxint :: Integer -> Integer -> Integer -> Integer
08:59:15 <funkmando> maxint x y z =
08:59:15 <funkmando>     if x > y > z then x else
08:59:15 <funkmando>     if z > y then z else y
08:59:32 <basti_> because youre comparing an integer value to a truth value.
09:00:04 <funkmando> x y z all integers?
09:00:16 <basti_> look closer.
09:00:17 <basti_> =)
09:00:30 <basti_> what is the type of "x>y"?
09:00:39 <funkmando> boolean
09:00:46 <funkmando> oh shit
09:00:48 <funkmando> got it
09:00:48 <basti_> :)
09:00:48 <funkmando> thanks
09:00:52 <basti_> nM.
09:01:13 <basti_> this is a real bitch in C.
09:01:23 <basti_> because it is not a syntactic error there.
09:01:33 <fraxtal> Could that be rewritten using guards?
09:01:48 <basti_> probaby
09:01:49 <basti_> l
09:02:05 <funkmando> right so im supposed to do (x > y > z) yes?
09:02:15 <funkmando> so it evaluates the boolean
09:02:16 <basti_> no youre not.
09:02:16 <basti_> -g-
09:02:30 <basti_> what are you trying to say with that bit of code?
09:02:39 <basti_> you do not want to compare a boolean to an integer do you?
09:02:42 <funkmando> if true then x else next thing
09:02:49 <basti_> if what is true?
09:03:03 <funkmando> grr
09:03:03 <funkmando> lol
09:03:28 <funkmando> ok how about (x > y) && (y > z) ?
09:03:32 <basti_> sounds better.
09:03:32 <Maddas> basti_: I'm asking because e.g. CL-PPCRE (written in pure Common Lisp) is supposedly significantly faster than PPCRE (written in C), but I don't know whether there is anything similar that executes a lot faster (or whether you didn't mean this kind of RE anyway) 
09:03:34 <Maddas> er, significantly faster than PCRE.
09:04:31 <basti_> Maddas: i just know that the fastest way of doing regexes would be, analyze the regex, build an Finite Automaton, optimize, translate your automaton into your machine's language, and then let it do the search
09:05:05 <basti_> plus optimizing the machine language, maybe. though that is like nailing pudding to the wall
09:05:30 <johs> This is faster than a table-driven automaton?
09:05:51 <basti_> if you can save the memory accesses, sure.
09:06:04 <Maddas> Oh, and you mean just outputting C/assembler in the end as opposed to writing everything in C?
09:06:06 <basti_> well not THAT sure, but pretty probably.
09:06:11 <johs> So you're essentially translating it to a series of branches?
09:06:40 <basti_> Maddas: i was thinking writing the assembler/machine language from haskell, using an escape.
09:06:59 * pesco starts screaming.
09:07:00 <basti_> i know most regex implementations use tables and are reasonable fast.
09:07:12 <johs> I'm just curious because table-driven regex implementations seem more common.
09:07:39 <basti_> i think the table-driven approach is easier by an order of magnitude and not significantly slower.
09:07:47 <johs> Right.
09:07:52 <basti_> :P
09:08:11 <basti_> but it would be a hell of a lot faster than any haskell combinator approach-
09:08:24 <basti_> ...i think.
09:08:30 <basti_> but we can try to prove.
09:08:58 <musasabi> basti_: I think your first problem will be efficient IO.
09:09:05 <pesco> What do you mean by "Haskell combinator approach". I'm no expert on the implementation of regex matching, can you elaborate for me?
09:09:17 <basti_> musasabi: in haskell or in assembler? ;)
09:09:22 <musasabi> in haskell.
09:09:42 <basti_> pesco: well theres a possibility of expressing things like the "*" operator in regexes directly in haskell
09:10:08 <basti_> you'd have functions that "eat" single characters, and the "*" would let any function eat as many characters as it wants etc.
09:10:22 <basti_> i once implemented such a thing as a homework
09:11:12 <pesco> I can't completely imagine the workings of that.
09:11:33 <pesco> Or rather, I'm unsure of which of my possible imaginations matches yours.
09:11:33 <basti_> let me see if i can dig somethin gup
09:11:37 <musasabi> pesco: the same way parsec works.
09:11:48 * boegel sees his parser working and starts dancing across the room
09:12:00 <pesco> boegel: Wooh, what are you parsing today?
09:12:09 <boegel> my scene description
09:12:11 <boegel> +s
09:12:20 <pesco> I see. Congratulations. Parsec is such fun.
09:12:37 <boegel> I can now load a file containing a scene in my GUI, and then render it
09:12:45 <boegel> pesco: I used Happy, if you're referring to me
09:12:59 <basti_> http://www.informatik.uni-freiburg.de/~thiemann/haskell/grep/ <
09:13:02 <pesco> boegel: Oh, of course. I got some synapses mixed.
09:13:12 <basti_> Parsers.hs
09:13:12 <funkmando> what does t -> t1 mean in error messages?
09:13:24 <pesco> funkmando: It's a type.
09:13:25 <basti_> funkmando: "some function that takes a t and returns a t1"
09:13:43 <basti_> where t and t1 would be arbitary types.
09:14:13 <pesco> funkmando: lowercase â type variable
09:14:50 * basti_ no unicode
09:14:57 <boegel> funkmando: it probably means you forget to provide some function with enough arguments
09:18:28 <pesco> basti_: So you mean you'd parse the regex, building a corresponding parser from appropriate combinators in the process?
09:24:52 <funkmando> ok it's compiling
09:25:00 <funkmando> but it won't work, lol
09:25:08 <funkmando> has problems with :
09:25:08 <funkmando> triangle :: String -> String -> String -> Integer
09:25:08 <funkmando> triangle p q r = maxint (read p) (read q) (read r)
09:25:41 <funkmando> saying there is "no instance for (num,string) arising from the literal..." etc
09:27:44 <Lemmih> What's the type of 'maxint'?
09:27:54 <funkmando> and my maxint function takes 3 integers and returns an integer
09:29:09 <Lemmih> How are you calling 'triangle'?
09:29:41 <funkmando> yes
09:29:43 <funkmando> thankyou
09:29:45 <funkmando> that was the problem
09:30:02 <funkmando> needed quotes
09:30:09 <Lemmih> heh No problem (:
09:30:43 <basti_> never think
09:30:47 <basti_> whoops
09:31:00 <basti_> never think that when parents give you a present they mean it as a present
09:31:18 <basti_> pesco: essentially yes.
09:31:23 <basti_> pesco: sorry phone.
09:34:44 <pesco> basti_: OK, I can believe that will be slower than compiling to a DFA because the DFA will be a simpler structure than the combinator-built parser (I suspect).
09:34:59 * basti_ nods.
09:35:22 <basti_> and a DFA is like, maybe 10 machine instructions per letter.
09:35:29 <basti_> its hard to beat that.
09:36:09 <pesco> So the interesting question is: How much faster is a DFA compiled directly to machine code than one emulated in Haskell code?
09:36:32 <shapr> You could also check out the lazily compiled regexes in CTK/CTKlight
09:36:40 <basti_> one should try.
09:37:00 <shapr> The lazy regexes approach is, "don't build a regex unless someone actually asks for it."
09:37:05 <basti_> but i still have to write my seminar stuff. and now i also have to be angry at my parents.
09:37:36 <basti_> can you divorce your parents or something? unadopt?
09:37:59 <pesco> Detach from parent.
09:38:04 <basti_> -g-
09:38:08 <pesco> http://www.daemonize.de/
09:38:40 <pesco> http://arktik.daemonize.de/
09:39:07 <pesco> *cough* Right, I don't have a www alias.
09:43:44 <stepcut> bash needs lists ...
09:43:55 <shapr> stepcut: did I already ask you about writing for TMR?
09:44:15 <shapr> stepcut: zsh has lists, bash doesn't?
09:44:50 <stepcut> well, bash has space seperated lists, which is not so good
09:45:03 <Igloo> It has arrays
09:45:40 <stepcut> I think I just need to do a for loop
09:45:43 <stepcut> :-/
09:45:55 <stepcut> shapr: re TMR, not yet
09:46:01 <shapr> ok
09:48:32 * shapr boings happily
09:48:53 <stepcut> shapr: did I ever send you my 'paper' on the unixs pipes stuff I wrote ?
09:50:03 <shapr> um. I think you sent me an early version.
09:50:15 <shapr> But I would like to get the latest version.
09:50:16 <stepcut> well, i think there is only an early version :)
09:50:42 <stepcut> but I could try to do something with that for TMR
09:51:19 <shapr> That would be great!
09:51:31 <stepcut> when is the cut-off date for the first issue ?
09:51:45 <shapr> Have a definite idea by Monday
09:52:05 <stepcut> hrm, I will be very busy for the next 3 wks unfortunately
09:52:12 <shapr> Have the code and text on my box by the 14th
09:52:20 <shapr> stepcut: in that case, aim for the second issue?
09:52:32 <stepcut> yes, I think the second issue is feasable
09:52:44 <shapr> I think I have three definite articles for the second issue so far.
09:53:16 <shapr> Shall I put you down as a possible second issue article author?
09:53:23 <stepcut> yes
09:53:25 <shapr> ok!
09:53:31 <Cale> the the the
09:54:13 <shapr> Cale: a a a
09:54:26 <shapr> A man, a plan, a canoe...
09:54:40 <stepcut> hehe
09:54:48 <shapr> What's the rest of that?
09:55:11 <shapr> oh, of course "Panama!"
09:56:08 <shapr> Igloo: did you say you're a possible author for issue 2?
09:56:39 <Igloo> no
09:57:06 <shapr> ok
09:57:18 <stepcut> btw, it is canal, not canoe...
09:57:30 <shapr> oh right
09:57:52 <shapr> Do you have the whole book?
09:58:04 <stepcut> no
09:58:18 <stepcut> but I think I checked it out from the library once...
09:58:55 <Heffalump> issue 2 of what?
09:59:05 <shapr> of "The Monad.Reader"
09:59:13 <shapr> Do you want to write an article or column?
09:59:27 <shapr> http://www.haskell.org/hawiki/TheMonadReader
10:00:19 <Heffalump> when for?
10:00:56 <shapr> definite idea by monday, code and text should be in my inbox or TMR directory two weeks after.
10:01:11 <funkmando> hey how can i assign the value of read a to another variable (so i don't have to keep calling read a all the time) ?
10:01:22 <shapr> The last week is reserved for Panic.
10:02:03 <Heffalump> let x = read a
10:02:07 <Heffalump> in ...
10:02:18 <funkmando> ok thanks
10:02:40 <funkmando> how about more than one
10:02:50 <funkmando> for example would i say let x = read a && y = read b?
10:02:55 <funkmando> and so on?
10:03:00 <funkmando> and then in 
10:03:01 <shapr> I'd like to know about the articles being written just so that there's no duplicated effort, and so there's a good distribution of article level.
10:03:49 <Heffalump> let x = read a
10:03:51 <Heffalump>     y = read b
10:03:52 <Heffalump> in ...
10:04:01 <Heffalump> or let x = read a in let y = read b in  ...
10:04:14 <Heffalump> how often will issues be?
10:04:29 <funkmando> quite often
10:04:34 <shapr> First of each month if all goes well.
10:05:36 <shapr> Interested?
10:05:59 <Cale> funkmando: I think Heffalump was referring to issues of the magazine :)
10:06:55 <Heffalump> maybe.
10:07:49 <funkmando> haha
10:07:52 <funkmando> ok :P
10:08:11 <shapr> If you want to get something into the first issue, talk to me on or before Monday.
10:08:17 <Heffalump> how full is it now?
10:08:19 <funkmando> sure will do
10:08:25 <funkmando> (j/k lol)
10:08:28 <Heffalump> and what are the prospects for subsequent issues?
10:08:37 <shapr> what sort of prospects?
10:09:45 <shapr> Four columns and two articles are definite for the first issue.
10:11:33 <shapr> By prospects, do you mean how many possible authors? How many columns? What sort of audience interest so far?
10:12:02 <Itkovian> evening
10:12:06 <shapr> hoi Itkovian 
10:12:12 <Itkovian> gwad azerty keybs suck
10:12:25 <Heffalump> the former
10:13:48 <shapr> Right now there are eight possible authors and at least three others that are interested.
10:14:40 <Heffalump> ok, I can probably manage something, but not sure about the first issue
10:14:42 <Itkovian> I'm interested as well, but I don't think my Haskell skills are good enough (yet)
10:15:12 <shapr> Itkovian: You don't have to write something that requires a lot of skill. You could pick something that interests you, learn that thing, and write about it.
10:15:26 <shapr> Heffalump: cool! I look forward to it.
10:15:54 <shapr> Itkovian: any Haskell libs or tools that particularly turn you on?
10:16:05 <Itkovian> zell, that's true too, but even if I was confident enough, well there's an OOPSLA deadline approaching at a fast pace ... 
10:16:09 <Itkovian> damn azerty
10:16:20 <shapr> I understand that.
10:16:35 <Itkovian> the azerty stuff? yeah well, it sucks
10:16:37 <Itkovian> big time
10:16:41 <Itkovian> :-)
10:16:47 <shapr> Standard libs documentation along with demo code and a deeper description would also be welcome.
10:17:40 <Itkovian> hmm ... well ... I'll certainly think about it.
10:18:33 <shapr> (and you'd get your name into the GHC tarball!)
10:25:49 <syntax_syntax> heh the topic gets fuller and fuller
10:26:12 * shapr stuffs syntax_syntax into the topic
10:26:27 <shapr> Evil strikes!
10:26:31 <shapr> or something....
10:26:45 <shapr> syntax_syntax: y0, wassup?
10:34:46 <shapr> hej Marvin-- 
10:35:17 <syntax_syntax> shapr it's all okay.
10:35:44 <syntax_syntax> I got complimented by the CG professor for something nifty I did changing one line of his Lua code.
10:35:48 <syntax_syntax> Not bad for an economist (H)
10:36:04 <Marvin--> ello
10:36:32 <shapr> Elegant code improvements make me feel so warm and fuzzy inside.
10:36:49 <syntax_syntax> It actually changed completely the purpose of it.
10:37:20 <syntax_syntax> It was supposed to draw implicit curves described by a subset of the image of a r^2->r function. Like f(x,y)=0
10:37:28 <Oejet> I have a comment regarding the regexp talk just before; I saw an OCaml lib using lazy regexps and he said it was darn fast.  Can't seem to find it again, though.
10:37:49 <syntax_syntax> so x^2+y^2-1=0  is the circle yadda yadda yadda. I did something that draws transversal cuts and the region between them in degradée.
10:38:12 <CosmicRay> Oejet: I'm not aware of any lazy regexp in ocaml
10:38:22 <CosmicRay> Oejet: ocaml strings aren't lazy so I don't know how that would be really...
10:38:32 <CosmicRay> Oejet: ocaml does have a pa-regexp library that you may be thinking of
10:38:34 <syntax_syntax> it looks mighty cool.
10:38:38 <CosmicRay> Oejet: and it has some built in regexp support
10:38:40 <Marvin--> meh, how I hate it when something seemingly simple turns out to be really complicated
10:38:48 <CosmicRay> Oejet: in haskell, there is hsregex and pesco's regex
10:39:05 <shapr> What about Chilli's CTK regexps?
10:39:06 <CosmicRay> Marvin--: that's why I hate java
10:39:14 <shapr> And Igloo's regexes?
10:39:14 <CosmicRay> shapr: hadn't known about those
10:39:21 <CosmicRay> (the ctk ones)
10:39:42 <CosmicRay> I never did track down igloo's.
10:39:42 <CosmicRay> home.
10:39:44 <CosmicRay> err
10:39:45 <CosmicRay> hmmm.
10:40:07 <Marvin--> I thought that it would be easy to, when I plug in my pcmcia wlan card, get the wlan0 the default route so I could unplug eth0 and carry away the machine
10:40:27 <Marvin--> but apparently that's not something you easily do
10:40:40 <shapr> I think I saw a deb that handles that for you.
10:41:11 <CosmicRay> laptop-net maybe
10:41:20 <CosmicRay> there's another one too, that I didn't like
10:41:22 <CosmicRay> ifplugd maybe
10:41:29 <CosmicRay> I haven't looked at laptop-net ever
10:42:18 <Igloo> You used to be able to do it with route metrics, but that was removed for some reason I think
10:42:39 <Igloo> Otherwise you'd need to be able to detect the cable being unplugged, or fiddle with other interfaces when bringing up wlan0
10:43:40 <Marvin--> well, something that did 'route del default' (or whatever it's called) before configuring wlan0 would do it, wouldn't it?
10:44:08 <Igloo> Right, fiddling with other interfaces
10:44:13 <Marvin--> yeah :)
10:44:31 <Marvin--> my point sorta is that I can't see this as being an uncommon scenario
10:44:55 <Igloo> I don't suppose hotplug has a cable-unplug event?
10:46:09 <Marvin--> (actually, my first shot at this was putting  pre-up ifdown eth0  in the wlan0 stanza in interfaces, but that deadlocked because ifupdown locks /etc/network/ifstate)
10:46:45 <Marvin--> but this is a classic example of something that I want to Just Work ;)
10:47:30 <shapr> if (haveDefaultRoute network) then sendPackets else whine
10:47:45 <Igloo> Oh, BTW, you're not doing anything with gtk2hs and Debian now, right? Do you have any useful info to pass onto to future potential maintainers?
10:47:49 <Marvin--> ewww, laptop-netconf just has scripts that symlinks /etc/network/interfaces and runs ifup -f eth0
10:48:06 <Marvin--> Igloo: I've been exchanging some mails with Duncan today as a matter of fact
10:48:28 <Igloo> Ah, rightyho - it was him talking here earlier that prompted me to ask  :-)
10:48:33 <Marvin--> I've started fidding with packaging 0.9.7
10:48:40 <Igloo> OK, cool cool
10:49:16 <Marvin--> but my laptop isn't a monster build machine and my other machine is a bit noisy, so I keep putting it off :P
10:49:38 <Marvin--> (and besides, I've *cough* been playing a lot of World of Warcraft lately...)
10:50:07 <Igloo> heh
10:50:14 <Igloo> Is that a C&C-a-like?
10:51:22 <Marvin--> C&C?
10:51:47 <Marvin--> WoW is a mmorpg as long as we're tossing around acronyms :P
10:52:59 <duncan> Igloo: it was talking to you which prompted me to email Marvin-- :-)
10:53:12 <Igloo> Oh, hmm, OK
10:53:14 <Marvin--> hi duncan :)
10:53:15 <Igloo> Command and Conquer
10:53:22 <Igloo> duncan  :-)
10:53:30 <duncan> Marvin--: hi
10:53:31 <Marvin--> Igloo: oh, not so much then :)
10:53:45 <Marvin--> Igloo: more like everquest
10:53:59 <Marvin--> not that I've ever played everquest
10:54:49 <shapr> hey swiert, do you have an article repo I can pull?
10:54:51 <Igloo> Was Warcraft a C&C-a-like or am I hopelessly confused?
10:55:07 <swiert> shapr: no not yet.
10:55:13 <shapr> yeah, but those are called real-time-strategy with 16 player or so.
10:55:44 <shapr> MMORPG tends to involve thousands of concurrent players.
10:56:16 <shapr> Which is causing havoc with the developers of those systems btw. They have huge problems scaling up existing dev processes.
11:01:11 <swiert> shapr: ok I just added everything to a local repository.  What's the easiest way to make it visable for you, without setting up a webserver?
11:02:49 <shapr> You could just send me a tgz, then I could send you back any grammar/spelling patches.
11:03:24 <Igloo> shapr could make a repo on his webserver you send to
11:03:29 <shapr> applying a patch you got in email is just a matter of doing "darcs apply"
11:03:58 <shapr> Igloo: yes, but doing that per-article could get tiresome.
11:04:26 <swiert> shapr: ok, I'll send you a zip.
11:04:43 <shapr> And the repo will be publically visible too, which may not be to the liking of all authors.
11:05:01 <Igloo> You can use basic auth to protect it
11:05:08 <shapr> true, good point.
11:06:07 <shapr> Has anyone tried darcs 1.0.1 on win32? does it send email okay?
11:09:48 <Marvin--> hmm, ifplugd *might* do what I want, *if* I remember to unplug the tp cable before inserting the pccard
11:10:34 <Marvin--> it just kinda bugs me that I can't express this with just ifupdown
11:12:31 <Marvin--> I wonder why ifplugd wants to do stuff for me with hotplug-controlled interfaces though... hotplug already ifup:s and ifdown:s them
11:13:34 <swiert> shapr: I've got to run, but you should have a new e-mail.
11:14:25 <shapr> thanks!
11:14:34 <swiert> no problem.
11:15:25 <basti_> who has a liability insurance (besides for cars) and thinks its normal to have one?
11:15:45 <shapr> It's required by law in parts of the US.
11:15:50 <basti_> o0
11:16:00 <Marvin--> liability insurance?
11:16:06 <basti_> yes like, uhm. 
11:16:18 <basti_> actually i dont know what its for.
11:16:27 <basti_> i mean i know what its for "on the paper"
11:16:32 <basti_> but i dont think reality works like that.
11:17:10 * basti_ wants to move and has to prove he has a liability insurance for that.
11:17:37 <shapr> basti_: er sorry, car liability is all that's required by law in parts of the US
11:17:46 <basti_> its in all germany for all cars.
11:17:49 <basti_> for obvious reasons
11:18:12 <basti_> but my new landlord wants a general one just because we want to live there.
11:18:21 <shapr> weird
11:18:23 <fraxtal> basti_: I have some liability, but I'm forced to have it by law.
11:18:45 <basti_> fraxtal: for your car? or generally?
11:18:52 <shapr> Man, Savannah has gotten tough since I've been out of the States.
11:18:56 <fraxtal> basti_: haha for my car
11:19:14 <fraxtal> shapr: Savannah?
11:19:23 <tuomov> general liability insurance? there is such a thing as "home insurance" over here that many landlords require
11:19:27 <shapr> We have business liability insurance, but that's just because we're paranoid.
11:19:29 <tuomov> maybe that is what is meant?
11:19:38 <shapr> fraxtal: Aren't you in Savannah?
11:19:47 <basti_> no actually he wants not a home insurance but a liability insurance.
11:19:54 <basti_> i wondered about that and my father did so too.
11:19:58 <tuomov> odd
11:20:06 <shapr> yeah, odd
11:20:24 <basti_> i mean its not that expensive or something. just plain odd, as you said.
11:20:26 <fraxtal> shapr: Oh no my isp goes through another ISP in Savannah.  I was wondering if you lived in Savannah.
11:21:10 <shapr> Nah, I live 40 miles south of the Arctic Circle in Sweden. But I used to live in Birmingham, and we went to Atlanta a lot.
11:22:17 <shapr> This place tends to be colder than Birmingham.
11:23:22 <tuomov> It's been a warm winter. Hasn't gone below -15C once here.
11:23:48 <tuomov> february tends to be the coldest month, though
11:24:11 <shapr> I want a battery-heated saddle for my unicycle ;-)
11:25:21 <CosmicRay> heh
11:27:47 <monochrom> Stick a laptop at the saddle.  Battery-heated saddle you have.
11:28:17 <monochrom> Plus during your cycling if you suddenly come up with a coding idea you can immediately write it up.
11:28:31 <CosmicRay> excellent.
11:28:47 <CosmicRay> he could also irc from his unicycle then.
11:28:58 <CosmicRay> you need a hud and spech recog software, shapr.
11:29:03 * shapr sniggers
11:29:48 <shapr> I do forget ideas if I don't write them down. But they stick longer if you sing them or recast them as poetry, limerick, etc
11:30:07 <wli> Sonnets and villanelles, too. =)
11:30:23 <shapr> Or just keep a pen in your pocket and write it on your hand. That works if you're not too sweaty or snowy.
11:30:32 <CosmicRay> heh
11:31:08 <wli> Don't forget rime royale or Alexandrine, either. =)
11:31:25 <autrijus> 90% of pugs/perl6 operators implemented, correctly too.
11:31:45 <shapr> I've never actually tried to write one of those forms of poetry. Sonnets, ok.. but not the rest.
11:31:46 <autrijus> http://wagner.elixus.org/~autrijus/darcs/pugs/Prim.hs is so different from what I'm used to see in perl5 internals :)
11:32:16 <shapr> autrijus: several people on del.icio.us linked to the Pugs HaWiki page.
11:32:32 <autrijus> oh? good to know.
11:32:32 <shapr> You must have mentioned it somewhere interesting.
11:32:47 <autrijus> someone has written it up on perl.com.
11:32:49 <autrijus> not me.
11:33:10 <shapr> nice docs in that file.
11:33:40 <shapr> Too bad GHC doesn't handle unicode, you could have put it down in the correct script too.
11:33:41 <autrijus> oh. it's a perl tradition to prefix each source file with a tolkien passage.
11:34:01 <autrijus> ever since perl1, I think.
11:38:57 <funkmando> hello wondering how to do boolean comparison? as in if a is not equal to b ?
11:39:07 <autrijus> @type /=
11:39:08 <lambdabot> bzzt
11:39:12 <funkmando> kewl
11:39:15 <autrijus> @type (/=)
11:39:16 <lambdabot> (/=) :: forall a. (Eq a) => a -> a -> Bool
11:39:40 <autrijus> @type not . (==)
11:39:41 <lambdabot> bzzt
11:39:47 <autrijus> @type (not . (==))
11:39:48 <lambdabot> bzzt
11:40:10 <funkmando> u turning your bot dude into a haskell library?
11:40:11 <funkmando> ;P
11:41:22 <Heffalump> not . (==) is badly typed
11:41:33 <Heffalump> @type \a b -> not (a==b)
11:41:35 <lambdabot> \a b -> not (a==b) :: forall a. (Eq a) => a -> a -> Bool
11:42:24 <Heffalump> @type ((not . (==)).)
11:42:25 <lambdabot> bzzt
11:42:31 <Heffalump> @type ((.) (not . (==)))
11:42:32 <lambdabot> bzzt
11:42:34 <Heffalump> bah
11:42:38 <autrijus> hehe.
11:42:39 <monochrom> hahahaha
11:42:57 <autrijus> pointless.
11:46:27 <monochrom> @type ((.) not) . (==)
11:46:28 <lambdabot> ((.) not) . (==) :: forall a. (Eq a) => a -> a -> Bool
11:46:37 <monochrom> the solution
11:46:44 <shapr> dang, you got there before me.
11:47:28 <monochrom> could also write (not .) . (==)
11:48:59 <shapr> Aha, the master arrives!
11:49:00 <TheHunter> thbot: @pointless \x y -> not $ x == y
11:49:00 <thbot> (not .) . (==)
11:49:24 <monochrom> neato
11:50:44 <autrijus> thbot: @pointless \x -> let y = x y in y
11:50:44 <thbot> fix
11:50:49 <autrijus> nice!
11:51:16 <funkmando> @type read
11:51:16 <thbot> Sorry, I don't know the command "type", try "lambdabot: @listcommands"
11:51:17 <lambdabot> read :: forall a. (Read a) => String -> a
11:51:28 <monochrom> thbot: @pointless [0,1,2] >>= \x -> [0..x] >>= \y -> return (x+y)
11:51:28 <thbot> s ((>>=) . enumFromTo 0) ((return .) . (+)) =<< [0, 1, 2]
11:51:30 <shapr> I wonder if the break combinator is the ackermann thingy.
11:51:57 <funkmando> @type (OMG HI)
11:51:57 <thbot> Sorry, I don't know the command "type", try "lambdabot: @listcommands"
11:51:58 <lambdabot> bzzt
11:52:06 <funkmando> @isuck
11:52:06 <lambdabot> Sorry, I don't know the command "isuck", try "lambdabot: @listcommands"
11:52:06 <thbot> Sorry, I don't know the command "isuck", try "lambdabot: @listcommands"
11:52:12 <funkmando> pwned
11:52:24 <lambdabot> pwned?
11:52:35 <funkmando> arghhh!!!
11:52:37 <funkmando> hehe
11:52:56 <lambdabot> funkmando: This space for rent.
11:53:09 <funkmando> ook
11:54:08 <shapr> salut mattam
11:54:49 <funkmando> is there anyway to catch errors (exceptions) like in java? cos if someone accidently enters "hello" into my program instead of some digits, i want it to say whatever i want it to say
11:55:00 <shapr> @index catch
11:55:00 <lambdabot> Control.Exception,GHC.Exception,Prelude,System.IO,System.IO.Error,IO
11:55:00 <thbot> Sorry, I don't know the command "index", try "lambdabot: @listcommands"
11:55:29 <funkmando> @type Control.Exception
11:55:31 <lambdabot> bzzt
11:56:01 <funkmando> @type (Control.Exception)
11:56:02 <lambdabot> bzzt
11:56:17 <monochrom> readIO throws an exception, no?  you can catch it, no?
11:56:41 <funkmando> i dunno
11:56:44 <funkmando> what is readIO?
11:57:07 <monochrom> My questions were rhetoric. (rhetorical?)
11:57:38 <Heffalump> read throws an exception too
11:57:45 <Heffalump> (well, something you can catch in IO, anyway)
11:58:04 <Heffalump> you can also use readsPrec instead of read to find out if the input was invalid directly
11:58:11 <funkmando> what about isDigits?
11:58:14 <funkmando> or something like that?
11:58:30 <funkmando> @type isDigits
11:58:32 <lambdabot> bzzt
11:59:00 <Lemmih> @type all . map Data.Char.isDigit
11:59:01 <lambdabot> bzzt
11:59:13 <monochrom> readLn calls readIO and will throw an exception
12:00:11 <funkmando> @index Data.Char
12:00:11 <lambdabot> bzzt
12:00:18 <Lemmih> @type all (==True) . map Data.Char.isDigit
12:00:18 <monochrom> do { n <- readLn; print (n * 10 :: Int) }  This will throw an exception if the user inputs a non-number.
12:00:19 <lambdabot> all (==True) . map Data.Char.isDigit :: [Char] -> Bool
12:00:59 <Heffalump> UGH!
12:01:06 <Heffalump> @type and . map Data.Char.isDigit
12:01:07 <lambdabot> and . map Data.Char.isDigit :: [Char] -> Bool
12:02:32 <Lemmih> Oh well.
12:03:18 <Igloo> @type all Data.Char.isDigit
12:03:19 <lambdabot> all Data.Char.isDigit :: [Char] -> Bool
12:04:01 <funkmando> so for that i have to use a list?
12:04:05 <funkmando> :/
12:04:13 <funkmando> is a string a list of chars?
12:04:34 <Igloo> yes
12:06:38 <Heffalump> oh yes. doh :-)
12:08:32 <TheHunter> thbot: @pointless \x y -> not $ x == y
12:08:33 <thbot> (/=)
12:08:56 <CosmicRay> @type String
12:08:57 <thbot> Sorry, I don't know the command "type", try "lambdabot: @listcommands"
12:08:57 <lambdabot> bzzt
12:09:09 <CosmicRay> hmm, interesting.
12:09:12 <TheHunter> dammit.
12:09:17 <CosmicRay> Heffalump: I guess I can't just ask the bot(s)
12:09:22 <CosmicRay> s/I can't/you can't/
12:09:25 <shapr> @type [] :: String
12:09:26 <lambdabot> [] :: String :: String
12:09:45 <shapr> w00, SPJ like TMR too.
12:09:45 <CosmicRay> shapr: he would have had to know that it's a list to know to ask that :-)
12:09:47 <Heffalump> ask them what?
12:10:00 <Heffalump> shapr: did he offer an article?
12:10:09 <Igloo> @info String
12:10:10 <lambdabot> -- String is a type constructor
12:10:10 <lambdabot> type String = [Char]
12:10:10 <CosmicRay> Heffalump: I was trying to show you how to get the answer to your question by asking the bot
12:10:15 <CosmicRay> Heffalump: however I was mistaken
12:10:15 <Heffalump> what question?
12:10:16 <CosmicRay> ahh
12:10:20 <CosmicRay> igloo got it.
12:10:23 <CosmicRay> Heffalump: about strings
12:10:24 <shapr> Nah, he just said something like "cool!"
12:10:28 <CosmicRay> heh
12:10:31 <Heffalump> I didn't ask that..
12:10:34 <CosmicRay> oh.
12:10:44 <Heffalump> do you really think I wouldn't be aware that a String is a [Char]? :-)
12:10:50 <CosmicRay> oh right, that was funkmando.
12:10:57 <CosmicRay> Heffalump: it was surprising. 
12:11:04 <CosmicRay> Heffalump: but I wasn't going to be insulting :-)
12:11:13 <shapr> I forget totally basic stuff on a regular basis.
12:11:17 * Heffalump is more insulted that you thought I might not know that ;-)
12:11:44 <CosmicRay> Heffalump: I was just going to name the next MissingPy release ['l', 'i', 'b', 'g', 'h', 'c', '6', '-', 'm', 'i', 's', 's', 'i', 'n', 'g', 'p', 'y', '-', 'd', 'e', 'v'] in your honor :-)
12:12:01 <shapr> I remember I spent a week trying to figure out the word for the long curved yellow fruit that comes in bunches.
12:12:06 <CosmicRay> heh
12:12:08 <Heffalump> :-p
12:12:15 <CosmicRay> shapr: post-its? :-)
12:12:19 <Heffalump> someone just asked me to put that word in an email
12:12:46 <shapr> I finally gave up and asked my woman, who gave me a very strange look while I was describing said thingy.
12:12:55 <CosmicRay> haha
12:13:00 <CosmicRay> is she a native english speaker?
12:13:21 <shapr> Nah, native german and french. But Swedish is her sixth language.
12:13:31 <CosmicRay> oh, were you looking for the english or swedish word?
12:13:37 <shapr> No, the english word =)
12:13:42 <CosmicRay> did she know?
12:13:54 <shapr> Yeah, of course. Banana!
12:13:58 <CosmicRay> fabulous :-)
12:14:21 <shapr> Does that ever happen to you? You just totally lose something really basic?
12:14:25 <CosmicRay> yes
12:14:38 <CosmicRay> I couldn't remember if I could put code otuside a fnuction in C last night.
12:14:42 <shapr> hehe
12:14:57 <Heffalump> please tell me you can't :-)
12:15:05 <CosmicRay> Heffalump: you are correct.
12:15:08 <CosmicRay> which was a real bummer
12:15:14 <Heffalump> what did you want it to do?
12:15:19 <shapr> I wrote about forgetting that sort of stuff, and how it should affect software design. - http://wiki.pragprog.com/cgi-bin/wiki.cgi/WeHaveMoved?MindCrayon
12:15:19 <CosmicRay> I want to call py_initialize() automatically anytime someone uses -package MissingPy
12:15:34 <CosmicRay> shapr: sometimes I think that a word sounds wrong but it's not, too
12:15:46 <Heffalump> when the RTS is starting up?
12:15:50 <shapr> Yeah, that happens to me too. 
12:16:07 <Maddas> Heh, World of Warcraft!
12:16:07 <CosmicRay> Heffalump: or it could be the first time they import one of the modules in that package.  either way is fine
12:16:25 <CosmicRay> Heffalump: I tried using the unsafePerformIO trick and storing a fake result in a fake global variable, but it didn't work.
12:16:27 <Maddas> A friend made the mistake of giving me a spare account for the beta test. 
12:16:35 <Heffalump> doesn't the RTS provide any hooks?
12:16:39 <Heffalump> e.g. a weak symbol
12:16:46 <CosmicRay> hmm, I wouldn't know where to look, hmm.
12:17:03 <CosmicRay> that wouldn't be in the ghc lib reference, would it...
12:17:07 <shapr> I think I synthesize a lot of my knowledge automatically by guessing how something really should be. So systems that have irregular names give me a lot of trouble.
12:18:03 <Heffalump> you could also make every call into python check, but that would suck
12:18:06 <shapr> One reason to love Finnish: What you hear is what you spell.
12:18:23 <Maddas> I think Japanese is a lot like that too (but not entirely)
12:18:24 <CosmicRay> Heffalump: indeed, and I call a bunch of different functions too
12:18:30 <CosmicRay> shapr: german is mostly that way too
12:18:42 <Heffalump> right, but your binding must do some kind of translation
12:18:44 <Maddas> CosmicRay: You need some good heuristics though
12:18:49 <Heffalump> How does one pronounce 'Goerzen' then? :-)
12:18:50 <shapr> But english has bought, slough, trough, dough, etc
12:19:06 <Heffalump> (at compile time)
12:19:17 <CosmicRay> Heffalump: heh, it's been anglicized.  My family pronounces is like "GORE-zen"
12:19:21 * shapr never says Goerzen while compiling
12:19:24 <basti_> german is NOT what you hear is what you spell.
12:19:47 <basti_> we have 7 letters for 20 vowel sounds.
12:19:54 <Heffalump> shapr: of course not, that's ghc's job
12:19:57 <Maddas> CosmicRay: consider e.g. 'eu' and 'oi'
12:19:58 <CosmicRay> heh
12:19:59 * shapr laughs
12:20:21 <shapr> Too bad this is so long, that's worth an irc quote.
12:20:21 <Maddas> CosmicRay: and aeu :-)
12:20:35 <CosmicRay> heh
12:20:39 <Igloo> I naturally pronounce it Gerr-tsen
12:20:45 <Heffalump> me too
12:20:46 <CosmicRay> Igloo: yes
12:20:58 <Maddas> I don't pronounce it at all!
12:21:03 <basti_> oe is probably an umlaut... which english doesnt have
12:21:03 <CosmicRay> Igloo: in fact, some of my relatives got their names recorded as Goertzen in english
12:21:09 <CosmicRay> basti_: exactly
12:21:15 <Heffalump> maddas: you should read more email from CosmicRay then
12:21:29 <CosmicRay> Heffalump: I receive far more than I send ;-)
12:21:31 <Maddas> Heffalump: I almost never read e-mails aloud
12:21:32 <Igloo> Oh, wait, when you say 'My family pronounces is like "GORE-zen"' is that before or after anglicisation?
12:21:37 <CosmicRay> Igloo: after
12:21:42 <Heffalump> I read them aloud in my head sometimes.
12:21:46 <Heffalump> anyway, I should go shopping
12:21:47 <basti_> ö < the dots on the o are actually a slurred e in old writing
12:21:51 * Heffalump tries to summon up the energy to do so
12:21:57 <CosmicRay> Heffalump: apparently many people think I could use more hair, fewer spams, and larger body parts
12:22:07 <Maddas> Haskell is hard, let's go shopping!
12:22:25 <shapr> Strange, speech connects to irc for me, but not email. Email is more about symbolic processing.
12:22:25 <stepcut> hehe
12:22:47 <Maddas> What do you mean with 'connects to'?
12:23:29 <goron> How is the package called where unix2dos is in? Debian ofcourse...
12:23:33 <goron> I can't find it. 
12:23:35 <shapr> I never speak emails in my head, but I do sometimes 'speak' what I'm writing into IRC.
12:23:45 <Heffalump> CosmicRay: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#RTS-HOOKS
12:23:45 <CosmicRay> goron: sysutils
12:23:46 <shapr> goron: there's flip
12:23:52 <Igloo> I always pronounce names as I read, I think, but I normally mispronounce them consistently if they're hard to pronounce correctly
12:24:01 <shapr> like "shapr" ?
12:24:05 <stepcut> I speak everything in my head, especially when I am thinking -- I talk to myself and make faces, which drives my girlfiend nuts
12:24:05 <shapr> which is actually shay-per ?
12:24:08 <CosmicRay> goron: the Contents-i386.gz file on the mirrors can answer that question for you
12:24:13 <basti_> i think people should write Phonetic Letters
12:24:15 <Maddas> I think I pronounce them so softly that I can't hear it so pronounciation doesn't matter
12:24:15 <Heffalump> oh, arse, there's no startup hook
12:24:38 <Igloo> No, when I pronounce shapr as shap-err that's just me interpreting what you meant wrong
12:24:46 <CosmicRay> Heffalump: yes, I was just going to say that I'd prefer to initialize *before* the program crashes :-)
12:24:55 <Heffalump> I just assumed there would be one :-)
12:24:58 <shapr> Igloo: but you're not alone, 80% of all IRC-users say shap-err
12:24:59 <CosmicRay> I pronounce it as "shaper"
12:25:05 <CosmicRay> long a
12:25:09 <shapr> CosmicRay: which is correct! you get the gold star!
12:25:15 <Maddas> I pronounce it as shapr!
12:25:16 <CosmicRay> :-)
12:25:20 <basti_> diphtong a or open a?
12:25:24 <Igloo> I don't hav a good example OTTOMH, but often in books they invent character names that have loads of syllables or conflicting sounds that I just simplify
12:25:26 <basti_> or closed a?
12:25:33 <basti_> :)
12:25:39 <Heffalump> we could pronounce him in upper-class English as "sharper"
12:25:45 <Igloo> :-)
12:25:45 <shapr> stepcut: how do you do symbol processing?
12:25:55 <CosmicRay> you know, I hate it when germans know more about english phonetics than I do :-)
12:25:55 <stepcut> goron: sysutils: usr/bin/unix2dos
12:25:59 <shapr> This is really interesting. Do you guys speak code when you write it?
12:26:02 <Igloo> I say I say I say, what's sharper up to these days, old chap?
12:26:07 <shapr> ouch
12:26:13 <stepcut> shapr: what would an example of symbol processing be
12:26:14 <stepcut> ?
12:26:14 <basti_> i find phonetics fascinating
12:26:16 <Maddas> I don't speak it at all
12:26:30 <basti_> i dont "speak" code in my head when coding
12:26:36 <basti_> but i "build" it in my head
12:26:36 <shapr> stepcut: er, APL? Writing or changing code that can't be spoken?
12:26:56 <stepcut> shapr: not very well :)
12:27:02 <basti_> labview?
12:27:37 <basti_> you cant speak that.
12:27:40 <shapr> I process via symbols almost completely. I think that's why spoken languages aren't so hard for me.
12:27:55 <goron> stepcut: Thank you (:
12:27:56 <shapr> Of course, I suck at explaining stuff that I'm thinking.
12:28:03 <basti_> hehe
12:28:04 <stepcut> goron: apt-file unix2dos ;)
12:28:09 <basti_> thats programmer-specific
12:28:12 <basti_> :P
12:28:13 <stepcut> goron: apt-file search unix2dos that is
12:28:15 <CosmicRay> basti_: I'm trying to learn german right now.  can't figure out the difference between the prnouncation of "Deutsche" and "Deutscher".  the only people that seem to pronounce it differently are people that are not native germans :-)
12:28:34 <basti_> hehe
12:28:43 <CosmicRay> and I suspect getting that one wrong would be a faux paux
12:28:43 <basti_> yes this one is subtle
12:28:50 <basti_> mildly
12:28:53 <Maddas> What is subtle about it?
12:28:59 <shapr> stepcut: do you speak Haskell code while you're working on it?
12:29:02 <Maddas> Isn't it just, um, an 'r'? :-)
12:29:08 <basti_> the "r" is usually not to be heard
12:29:15 <shapr> Man, I wish I had SQUID so I could record our brains while we're coding.
12:29:25 <CosmicRay> Maddas: the germans have about 5 'r', some of which apparently are nonexistant :-)
12:29:26 <Maddas> Okay
12:29:40 <basti_> in over-correct talk one would probably pronounce it and thus help understanding
12:29:53 <Maddas> I would certainly pronounce it :-)
12:29:55 <basti_> but in non formal context its just a slight difference in the vowel.
12:30:00 <Maddas> but I don't speak 'proper' German often
12:30:35 <shapr> This makes me wonder if highly symbolic thinkers would be able to use IRC.
12:30:37 <CosmicRay> basti_: hmm.  ok I won't worry about it then :-)
12:30:46 <shapr> Wow, I gotta write a blog post about this.
12:30:55 <basti_> "deutsche" is a short closed vowel, "deutscher" is a little more open and longer
12:30:56 <CosmicRay> shapr: I think code as I write it, but only the things like look like words.  I just type the symbols.
12:31:16 <shapr> I think the pattern and lazily resolve the pieces into code.
12:31:21 <basti_> hehe
12:31:30 <CosmicRay> shapr lives haskell.
12:31:40 <TheHunter> basti_, i think it's not even entirely politically correct to pronounce the "r" in "deutscher"
12:31:43 <basti_> actually i dont "think aloud" my code.
12:31:55 <shapr> Of course, that lead me to try to tell my woman that salad :: [Lettuce]
12:32:05 <Maddas> I don't think aloud much in General, I have no problems reading things that I can't pronounce
12:32:06 <CosmicRay> hah
12:32:19 <basti_> TheHunter: well it would be correct, but noone says it :P  the problem is that this "r" would disrupt the flow of speech.
12:32:35 <Maddas> And there are /plenty/ of things I have no idea of how to pronounce in real life simply because I never talked about them
12:32:48 <CosmicRay> TheHunter: hmm, are you saying that those gender distinctions are politically incorrect in some circles?
12:32:53 <Maddas> Why would it be politically incorrect?
12:33:06 <basti_> well its the difference between male and female
12:33:10 <Maddas> oh, actually, I probably wouldn't pronounce it much either. Hm.
12:33:13 <CosmicRay> TheHunter: in which case, it would modify the article too, eh?
12:33:14 <basti_> (or plural)
12:33:19 * Maddas isn't good at finding out how he pronounces things
12:33:19 <CosmicRay> right
12:33:22 <funkmando> women and men are different? really???
12:33:23 <shapr> My hairstylist in the US had deaf children. She said they sign in their sleep.
12:33:24 <TheHunter> CosmicRay, no it's more because of the way hitler's speeches sound.
12:33:31 <CosmicRay> hm
12:33:38 <CosmicRay> shapr: wow
12:33:51 <basti_> im sorry, but really, in german, words have one of three sexes and they behave.
12:33:54 <basti_> :)
12:33:57 <CosmicRay> heh
12:34:18 <Maddas> shapr: Cool
12:34:23 <CosmicRay> basti_: at least here we don't have to figure out whether the chair or desk is male or female :-)
12:34:34 <basti_> you COULD construct a case in which this difference would end up in calling a man a woman, but this would be highly academical.
12:34:38 <basti_> yup ;)
12:34:39 <CosmicRay> we worry about which spelling rule we violate, and that's it!
12:34:50 <basti_> -g-
12:34:51 <TheHunter> CosmicRay, the gender distinction is another very annoying issue.
12:35:07 <Maddas> Why are genders annoying?
12:35:12 <basti_> in grammar?
12:35:17 <basti_> for native english speakers? =)
12:35:24 <CosmicRay> also, if we are named Bush, we have trouble with vowel order in words like "nuclear"
12:35:25 <Maddas> Do you mean me?
12:35:38 <basti_> yes.
12:36:04 <TheHunter> no, i mean the fact that you have to say "studentinnen und studenten" for "students".
12:36:05 <Maddas> TheHunter said it is annoying, I don't know how exactly he meant it :-)
12:36:10 <CosmicRay> Maddas: german gives male or female genders to inanamite objects without any, um, obvious male or female characteristics :-)
12:36:13 <Maddas> TheHunter: You don't /have to/
12:36:32 <goron> stepcut: I knew there was something like that, but I mostly use the webinterface, and I was kind of in a hurry. Normally I don't spam channels like this. 
12:36:50 <tuomov> even he/she is annoying, let alone noun genders
12:36:58 <CosmicRay> I don't mean what thehunter is saying.  that makes sense to me
12:37:11 <Maddas> CosmicRay: Right
12:37:26 <Maddas> (I'm not trying to be annoying, I'm just wondering)
12:37:32 <basti_> if you learn german the genders are probably really annoying.
12:37:43 <CosmicRay> and of course in English, people will say something like "If a person needs to use the copier, they should turn it on first."  drives me nuts.  subject-verb agreement problems are so comon
12:37:50 <funkmando> hmm i try to import Char using the command import Char at the top but it won't work, lol
12:37:54 <tuomov> german or almost any indo-european language except english
12:37:56 <basti_> CosmicRay: this is not correct?
12:38:01 <basti_> tuomov: -g-
12:38:05 <shapr> funkmando: import Data.Char
12:38:13 <Maddas> I think it's much more annoying if the languages you know don't have genders the way German does than if it has
12:38:14 <funkmando> ok thanks shap
12:38:17 <CosmicRay> basti_: no, it's not.  The subject is the singlar "person", so the plural "they" doesn't match properly
12:38:24 <shapr> funkmando: shae!
12:38:39 <basti_> CosmicRay: i know that its not contigent, but i read it so often that i took it as given.
12:38:44 <CosmicRay> basti_: however, people use that construction all the time.
12:38:49 <shapr> I'm sensitive after people started speaking my name as shap-err
12:38:58 <CosmicRay> basti_: english professors will take off 10% for it though :-)
12:39:05 <funkmando> import Data.Char still doesn't work, says i got a bug on the line below (module stuff where)
12:39:07 <Maddas> CosmicRay: Isn't that common usage and considered correct?
12:39:14 <basti_> then now i know better.
12:39:18 <Maddas> CosmicRay: In certain cases, that is, not in the one you mentioned.
12:39:20 <shapr> what's the code look like?
12:39:32 <CosmicRay> Maddas: I suppose it is being let slide more.
12:39:37 <funkmando> import Data.Char
12:39:37 <funkmando> module Triangle where
12:39:46 <Maddas> CosmicRay: I read about just that in some book teaching English I looked at yesterday :-)
12:39:48 <CosmicRay> I haven't had a formal english class in 10 years.  maybe things have changed
12:39:56 <basti_> -g-
12:40:04 <CosmicRay> funkmando: the module line goes first
12:40:08 <funkmando> o
12:40:08 <funkmando> ok
12:40:33 <monochrom> I could write "if a person wants to walk, he should put on his shoes", but people call me sexist for that.
12:40:59 <monochrom> I could write "if a person wants to walk, she should put on her shoes", but that is just as unfair.
12:41:10 <tuomov> greg egan invented ve/vis/ver for one of his books..
12:41:16 <monochrom> I could write "if a person wants to walk, he/she should put on his/her shoes", but it is clumsy.
12:41:20 <CosmicRay> monochrom: some journals have policies on that
12:41:39 <basti_> in german theres a special pronoun "man" which is as neutral as a pronoun can be
12:41:42 <CosmicRay> monochrom: that authors should switch genders every page or whatever
12:41:50 <monochrom> I could write "if a person wants to walk, they should put on their shoes", but it is grammatically troublesome.
12:41:54 <tuomov> swedish has 'man' too
12:41:58 <CosmicRay> monochrom: exactly
12:42:02 <basti_> (although it sounds like male, but it doesnt to germans)
12:42:04 <Maddas> basti_: Actually, not really
12:42:06 <monochrom> So what do you suggest?
12:42:12 <tuomov> in finnish there just 'hÃ¤n' for 3rd singular
12:42:13 <Maddas> basti_: The Duden now lists 'frau' as alternative
12:42:14 <basti_> not?
12:42:17 <basti_> uh
12:42:21 <funkmando> why is it indo-european
12:42:22 <monochrom> Mind you, I am writing just one sentence, not an entire passage.
12:42:22 <esap> how about "if people want to walk, they should put on their shoes"?
12:42:22 <funkmando> ?
12:42:27 <basti_> thats an artifact
12:42:27 <TheHunter> Maddas, you're kidding, right?
12:42:28 <funkmando> what connection do we have with india
12:42:47 <basti_> sanskrit and european languages are related.
12:42:52 <Maddas> no, I'm not kidding
12:43:06 <shapr> Finno-Ugric languages might as well be Basque.
12:43:12 <CosmicRay> #haskell.  best.  channel.  ever.
12:43:13 <monochrom> I could write "if a person wants to walk, he should put on her shoes" or "she should put on his shoes"...
12:43:16 <shapr> CosmicRay: truly
12:43:26 <basti_> have a look at hindi numbers and words for everyday things like "room"...
12:43:36 <Maddas> frau (/bes. im feministischen Sprachgebrauch fuer/ man); da weiss frau, was sie hat
12:43:40 <CosmicRay> monochrom: that would imply putting on the girlfriend's shoes or something
12:43:43 <basti_> Maddas: i know..
12:43:44 <Maddas> (with the Esszett instead of ss)
12:43:58 <basti_> but thats stupid and intended.
12:44:07 <TheHunter> wow, what were they thinking.
12:44:16 <Maddas> basti_: Sure, but it's German
12:44:22 <shapr> Swedish has sin for "the subjects own" but english only has "his". So I can say "Shapr drove his car." and it could be Igloo's car. Swedish doesn't allow that.
12:44:28 <Maddas> :-)
12:44:39 <basti_> constructed... before feminism people said "man muß das so machen" for example, and noone assumed you were talking about males
12:44:42 <CosmicRay> hey, while we have a bunch of germans here, do any of you know if this is true? http://www.livejournal.com/users/wouterverhelst/57111.html
12:44:44 <Maddas> heeh, "the subjects own" :-)
12:44:44 <monochrom> So basically either the feminist anti-sexist movement is silly or English is silly.  I don't have a nice way to say "x wants to walk ==> x puts on shoes".
12:44:55 <TheHunter> it just sounds plain wrong and suggest that the speaker is some crazy feminist.
12:45:05 <Maddas> basti_: Yes
12:45:14 <CosmicRay> monochrom: english needs typeclasses, eh?
12:45:14 <Maddas> I don't consider it clever at all
12:45:20 <shapr> haha, English typeclasses!
12:45:21 <monochrom> indeed
12:45:36 <basti_> CosmicRay: thats a really touchy issue
12:45:36 <Maddas> I also don't understand why using the masculine form for everything makes so many people angry
12:45:42 <basti_> Maddas: i dont know too.
12:45:58 <esap> English does have typeclasses, as far as I am concerned. References!
12:46:00 <shapr> This place is way too interesting for me to get work done... I'll read the logs after I've made some money :-)
12:46:09 <funkmando> im randomly going to gothenberg on friday
12:46:11 <CosmicRay> heh
12:46:17 <funkmando> me and a friend just said,, so shall we just go to sweden then?
12:46:21 <monochrom> Actually, not many people are angry.  Just a few, but they're loud mouthed, they make a big fuss.
12:46:35 <Maddas> CosmicRay: Wow, that sounds harsh
12:47:44 <tuomov> it's been all over the news
12:48:16 <Maddas> monochrom: Yeah, I guess that's it
12:48:29 <CosmicRay> maddas: also see the snopes article http://www.snopes.com/media/notnews/brothel.asp
12:50:11 <CosmicRay> Maddas: anyway, as to your question about masculine form for everything, it basically came up at the same time as the women's rights movement
12:50:35 <CosmicRay> Maddas: so at the time, women really were excluded, and they felt that people's language was excluding them too
12:51:43 <Maddas> That's because all women are silly!
12:51:44 * Maddas snickers
12:51:45 <Maddas> ;-)
12:53:13 <basti_> -g-
12:53:16 <CosmicRay> Maddas: these days, there are still differences... for instance, women tend to earn less than men for the same work, but doing that is now illegal
12:53:18 <basti_> the thought might come up
12:53:33 <basti_> this sort of law is hard to enforce.
12:53:48 <Maddas> Sure, but I don't see how this has anything to do with using 'man' in German
12:53:49 <CosmicRay> basti_: huge lawsuit against walmart about it right now
12:53:56 <CosmicRay> Maddas: oh, it doesn't.
12:54:01 <CosmicRay> Maddas: I thought you asked about english.
12:54:02 <Maddas> :-)
12:54:04 <funkmando> men and women are beyond comparison
12:54:09 <funkmando> they just complement each other
12:54:15 <basti_> yes but how to prove? i mean if its not walmart and you cant take a meaningful average
12:54:31 <basti_> then one could argue, potential pregnancy.
12:54:32 <CosmicRay> basti_: it usually centers around proving qualifications
12:54:34 <Maddas> funkmando: I'd say that's rubbish
12:54:52 <basti_> basically its unfair to pay women less, i agree.
12:55:00 <CosmicRay> basti_: american law prohibits discrimination in employment, banking, etc. on the basis of race, gender, religion, ethnicity, etc
12:55:03 <basti_> i know.
12:55:06 <Maddas> funkmando: That would just invite people to treat them according to very different standards
12:55:08 <CosmicRay> basti_: you're right, it is hard to prove
12:55:11 <basti_> but that sort of stuff is REALLY hard to prove.
12:55:13 <CosmicRay> basti_: but people can do it
12:55:16 <funkmando> but one size doesn't fit all
12:55:17 <funkmando> imo
12:55:18 <basti_> and it can fuck up the legal system.
12:55:24 <Maddas> funkmando: I never said it does
12:55:39 <CosmicRay> basti_: ah, we don't have to worry about that.  our is already fucked up.
12:55:46 <basti_> if its not implemented very carefully, it allows everyone to sue because of discrimination
12:55:50 <basti_> indeed.
12:55:52 <basti_> :)
12:55:55 <Maddas> I'm not sure whether it makes sense for an employer to pay women and men the same if they work under different conditions
12:55:57 <CosmicRay> basti_: well, anyone can sue for anything
12:56:03 <basti_> in the USA, yes.
12:56:03 <basti_> :)
12:56:04 <CosmicRay> basti_: the question is whether they will win :-)
12:56:22 <basti_> thats not true.
12:56:29 <basti_> because trials have rules.
12:56:41 <basti_> they stop some processes while they're running.
12:56:45 <CosmicRay> sure, but I can plonk down my $30 or whatever it is, serve you with papers, and file a lawsuit.
12:56:56 <CosmicRay> that's suing you and happens before a judge ever sees the case
12:57:11 <basti_> in fact, trialling for 10 years can have its own worth.
12:57:15 <CosmicRay> of course, the judge could dismiss it 5 minutes after he/she/it/they see it
12:57:20 <CosmicRay> basti_: yes, that's sad.
12:57:22 <basti_> for example, if you trial against you being fired
12:57:29 <Maddas> trialling for 10 years?
12:57:32 <basti_> that would usually keep you in the job
12:57:41 <CosmicRay> basti_: not here
12:57:45 <basti_> Maddas: you were never living in germany did you? :P
12:57:47 <basti_> were
12:57:49 <CosmicRay> basti_: unless you're unionized
12:57:51 <Maddas> No, I never lived in Germany
12:57:54 <basti_> -g-
12:57:58 <basti_> lucky boy.
12:58:07 <Maddas> I'm asking what exactly you meant, not an example :-)
12:58:08 <basti_> CosmicRay: see =)
12:58:10 <CosmicRay> basti_: wait, is this why germany has such an unemployment problem?
12:58:13 <Maddas> Just court cases going on for 10 years?
12:58:14 <basti_> no.
12:58:15 <CosmicRay> basti_: nobody ever gets fired? :-)
12:58:26 <basti_> no im just being a bit ironic.
12:58:38 <CosmicRay> yes, me too :-)
12:58:47 <funkmando> after all the feminism etc. when have it twice as hard these days. not only do they usually end up having kids, but they also now have to go out get a job etc whilst being pressured into looking like what you get on magazine covers etc.
12:58:49 <Maddas> I don't know any legal mumbo jumbo at all :-)
12:58:52 <funkmando> lol
12:58:54 <funkmando> when = women
12:58:58 <Maddas> um
12:59:05 <basti_> but actually in germany some official processes would "hold" the state before the debated issue as long as it isnt finished
12:59:10 <Maddas> 'they end up having kids' -- that's a fact of nature
12:59:25 <funkmando> yup
12:59:27 <funkmando> so is inequality
12:59:29 <CosmicRay> basti_: we have that here (a restraining order), but it is not applied often
12:59:30 <Maddas> Yes
12:59:30 <funkmando> sadly for liberal america
12:59:39 <CosmicRay> Maddas: men have kids too
12:59:51 <Maddas> CosmicRay: I meant pregnancy
13:00:06 <Maddas> I'm not sure whether funkmando meant that, though
13:00:15 <basti_> CosmicRay: thats a huge problem for landlords, since you cant get people out of their flats.
13:00:23 <basti_> if they know a trick or two
13:00:36 <basti_> they might stay there for a year or two without ever paying anything.
13:00:44 <Maddas> basti_: I don't think long court cases only happen in Germany
13:00:50 <basti_> i dont think so too.
13:01:01 <Maddas> ('Die Muehlen der Justiz' certainly don't run much faster where I live)
13:01:13 <basti_> but german official processes have a certain justified reputation of going slow.
13:01:26 <basti_> i mean how long does it take for tax return?
13:01:38 <basti_> in germany its like, 9 months? almost a year? something like that.
13:01:38 <Maddas> I thought that's a global observation :-)
13:02:02 <basti_> probably buerocracy is slow everywhere.
13:02:03 <Maddas> I don't know, I don't pay any significant amount of taxes
13:02:09 <Maddas> bureaucracy
13:02:12 <basti_> ok.
13:02:23 <basti_> eoeoiaruei
13:02:23 <Maddas> ;-)
13:02:31 * basti_ throws in a few vowels
13:02:32 <Maddas> (I couldn't resist nitpicking, sorry)
13:02:43 <Maddas> r is not a vowel!
13:02:57 <basti_> pff.
13:03:00 <Maddas> :-P
13:04:34 <basti_> people should really write phonetic alphabet.
13:04:56 <Maddas> Why-
13:04:59 <Maddas> Why?, even.
13:05:07 <Maddas> Reading isn't hearing, writing isn't speaking
13:05:17 <monochrom> But seeing is believing!
13:05:17 <basti_> but it would make reading loud easier.
13:05:22 <basti_> and learning writing.
13:05:32 <basti_> and you could read foreign words.
13:05:36 <monochrom> I am not sure if it is beneficial.
13:05:46 <Maddas> I don't think 'easy to learn' is the thing a language is supposed to aim for
13:05:56 <basti_> but an alphabet!
13:06:07 <Maddas> Oh, don't those exist already?
13:06:13 <CosmicRay> basti_: wow, your state bureacuracies are slower than ours
13:06:21 <CosmicRay> basti_: tax returns get processed in about 2 weeks here
13:06:24 <Maddas> Consider the alphabets used in dictionary
13:06:27 <CosmicRay> passports, though, take 6.
13:06:37 <basti_> Maddas: yes i thought about just this phonetic alphabet.
13:06:43 <Maddas> I'd say Japanese Hiragana and Katakana are also pretty phonetical
13:06:52 <basti_> CosmicRay: well passports took 8 for us. but the tax return is execptional.
13:06:59 <basti_> they are.
13:07:00 <monochrom> My hypothesis: if you have to learn two different languages when you're a child, later you will learn abstractions (math, programming languages) easier.  A distinct between spoken and written serves this.
13:07:08 <wli> The ideograms are the main question.
13:07:17 <TheHunter> i think the korean system is quite good.
13:07:18 <basti_> hiragana are not ideograms ;)
13:07:31 <basti_> yes korean is pretty close to phonetic
13:07:59 <monochrom> If you only know one language, you tend to think in language.  It may be bad.
13:08:19 <Maddas> In my opinion, a language should primarily be easy to read, not easy to write
13:08:32 <CosmicRay> monochrom: unfortunately, learning two programming languages as a child hasn't helped me learn more spoken languages :-)
13:08:35 <basti_> but learning to write is not learning another language
13:08:37 <CosmicRay> err, make that three.
13:08:41 <basti_> hehe
13:08:55 <CosmicRay> if you count basic.
13:09:12 <basti_> its learning the stupid rules that other people speaking your language use to write the words of your language.
13:09:18 <Maddas> Isn't spoken Tibetian really surprisingly much a different language from written Tibetian?
13:09:33 <Maddas> Or just very, um, disconnected
13:09:58 <basti_> actually i think its the same language... as the symbol sets and the combinations of symbols are the same
13:10:09 <basti_> a spoken language and its written form are isomorphic
13:10:12 <Maddas> (You can't easily map between spelling and pronounciation at all, from what I've heard)
13:10:26 <Maddas> basti_: Aren't there often constructs only used in one form?
13:10:27 <TheHunter> basti_, i don't think people think completely in spoken language. Personally, it drives me nuts if I here an English word I don't know the spelling of.
13:10:28 <basti_> mostly on word basis.
13:10:36 <Maddas> I mean grammatical constructs.
13:10:44 <basti_> hmmmm
13:10:47 <basti_> Maddas: like for example?
13:10:48 <tuomov> yeah, languages should be phonetic
13:11:08 <Maddas> basti_: I read about one yesterday, I forgot about it already. I'd have to look it up in the bookshop, sorry.
13:11:13 <basti_> i mean of course there are "informal" things that arent written down
13:11:18 <Maddas> I'll come back to you if I walk past that store again
13:11:24 <basti_> and some utterances you wouldnt write down too.
13:11:41 <basti_> for example almost every language has a "fill sound" you make when you think a little.
13:11:45 <basti_> like "err" in english.
13:12:01 <CosmicRay> I'd think it's "um" or "uh"
13:12:11 <CosmicRay> or do you brits stall differently, too? :-)
13:12:14 <basti_> -g-
13:12:22 <monochrom> In my class, students are asked to prove "forall x. exist x'. S" (they are given the actual S) (forall and exist are the usual symbols you know).  A student asks, "how do you pronounce this?"  This student is a victim of thinking in English; if he can't pronounce something he has problem proving it.
13:12:23 <basti_> it differs with your region
13:12:40 <Maddas> monochrom: Heh
13:12:47 <basti_> monochrom: o0
13:13:00 <Maddas> monochrom: Why? Maybe he was just curious about how to pronounce it.
13:13:09 <basti_> i mean of course its hard to learn things you dont know how to talk about
13:13:17 <basti_> thats why you should talk about the things you learn
13:13:17 <Maddas> I disagree
13:13:23 <Maddas> I never had any problems with that
13:13:26 <CosmicRay> I agree with basti
13:13:32 <monochrom> He asked for the prounciation the day the assignment is due.  This is desperation not curiosity.
13:13:33 <TheHunter> monochrom, mathematical text usually contain a whole lot of symbols i don't know the pronounciation of.
13:13:34 <CosmicRay> that's one reason I have trouble learning some haskell stuff
13:13:57 <basti_> symbols is one thing, but semantics...
13:14:03 <CosmicRay> TheHunter: plenty of haskell papers contain a lot of symbols I don't know the meaning of
13:14:06 * Maddas has more problems pronouncing things he knows than learning things he doesn't know how to pronounce
13:14:09 <CosmicRay> TheHunter: that's what bugs me
13:14:10 <basti_> i think its easier if you can think of a quantifier as, well, a quantifier
13:14:24 <Maddas> CosmicRay: The meaning isn't related to the pronounciation, though :-)
13:14:27 <basti_> and not go like "this silly reverse A here with the x and then the dot uhm"
13:14:30 <CosmicRay> Maddas: I know
13:14:49 <basti_> you could learn that the quantifier binds its variable.
13:15:10 <basti_> this all sounds silly, but it just does because we can talk about it
13:15:25 <basti_> if you cant talk about it, you just see a reverse A and an x and then you dont know
13:15:34 <monochrom> Yes semantics is important.
13:15:53 <basti_> yes but we do semantics all the time.
13:15:59 <Maddas> basti_: I'm not sure I understand where you are drawing a line between understanding something and being able to talk about it
13:16:03 <Maddas> (And pronouncing it)
13:16:15 <basti_> Maddas: well im not sure there is a very thick line.
13:16:21 <monochrom> I am saying that a person who knows only one language tends to have a very narrow sense of semantics, namely he thinks reading aloud is semantics.
13:16:27 <basti_> i know there are things you can understand without being able to talk about.
13:16:50 <funkmando> monochrom is that for all stuff analysis?
13:17:00 <basti_> but, most of the meaning of the word "understand" is "being able to talk about"
13:17:00 <Maddas> I think you can also learn the meaning of things without seeing any formal description of them or without knowing how to explain them
13:17:01 <funkmando> we just got given the formal definition of continuity.. :/
13:17:11 <basti_> i mean how do you check if someone understands something?
13:17:17 <monochrom> But my class is carefully set up so that "forall x. exist x'. S" has a semantics outside reading aloud; the semantics is given by a large pool of proof rules.
13:17:19 <Maddas> Why do you need to check? :-)
13:17:34 <Maddas> basti_: Actually, IIRC Einstein said that a person who can't explain something didn't understand it
13:17:37 <Maddas> (..or something like that)
13:18:03 <basti_> this is heavy philosophy, in any case
13:18:11 <funkmando> for all epsilon greater than 0, there exists N capital natural, such that, for all natural n, n > N implies that |a_n - a| < epsilon, then we say a_n converges to a as n->oo
13:18:18 <funkmando> cool huh?
13:18:38 <basti_> monochrom: i would just tell them how to pronounce. then they can leave that level of thinking and understand more.
13:18:59 <basti_> funkmando: yes cool. and youre talking about it and assuming these symbols have meaning.
13:19:14 <Maddas> I think knowing how to pronounce it is useful when talking to people :-)
13:19:26 <basti_> indeed -g-
13:19:27 <funkmando> oh know, not one of these "maths doesn't exist" people
13:19:28 <funkmando> lol
13:19:30 <Maddas> (to say something more obvious for a change)
13:19:32 <basti_> lol
13:19:41 <funkmando> know = no
13:19:47 <funkmando> damn i keep encoding accoustically
13:19:51 <basti_> see =)
13:19:59 <basti_> language is very very important for our thoughts
13:20:01 <Maddas> I have a hard time reading things written like that :-)
13:20:08 <basti_> actually, people learning no language stay dumb
13:20:11 <basti_> as in stupid
13:20:12 <Maddas> Um
13:20:28 <Maddas> What do you base your claim on?
13:20:44 <basti_> uhm. i can dig up a reference probably if you dont believe.
13:20:51 <Maddas> And what definition of 'stupid' and 'language' do you use? :-)
13:20:53 <monochrom> Yes, language is important for thoughts.  More reason for learning more languages so you can generalize.
13:20:54 <basti_> :P
13:20:57 <funkmando> hypothesis, after an hour of guitar playing you're more likely to encode words accoustically
13:21:02 <funkmando> true/false/inbetween?
13:21:09 <basti_> whats words? :P
13:21:13 <funkmando> any
13:21:19 <funkmando> you start hearing for the sound instead of the meaning
13:21:36 <Maddas> I think this kind of stuff is very personal
13:21:43 <funkmando> yeah
13:21:48 <Maddas> I know people who claim to think in ways I can't even imagine thinking in
13:21:59 <basti_> that happens.
13:22:13 <funkmando> give me some pythagorean triples people
13:22:20 <funkmando> i need to test my program for right angled triangles
13:22:30 <funkmando> and i've done 3 4 5
13:22:31 <funkmando> lol
13:22:32 <basti_> theres an algorithm for finding as many as you want.
13:22:34 <basti_> :)
13:22:50 <funkmando> i could prolly write one in C
13:23:04 <funkmando> loop i up to the point u want
13:23:19 <funkmando> then do tests n stuff
13:23:27 <Maddas> Does any of you think in a very graphical manner?
13:23:34 <funkmando> no
13:23:36 <funkmando> i don't think so
13:23:42 <funkmando> i'm also pretty crap at drawingh
13:23:49 <Maddas> You don't think any of us does or you don't think you do? :-)
13:23:52 <funkmando> although i can imagine 3d stuff reasonably well
13:24:15 <Maddas> I am terrible at imagining things.
13:24:22 <basti_> Maddas: concerning talking and civilisation, i would start with helen keller btw, thats a pretty impressive story about what language does to people
13:24:26 <Maddas> Graphically imagining them, that is.
13:24:37 <basti_> im pretty good at that -:)
13:24:42 <basti_> and i can draw.
13:25:03 <funkmando> psychologists say memory is encoded in 3 ways, semantically, accoustically, or graphically (i think)
13:25:08 <funkmando> and semantic is the highest level of encoding
13:25:19 <basti_> psychologists often simplify things.
13:25:20 <psi> i sometimes think in 2d, but never in 3d. i'm really bad at that (and i can't draw at all)
13:25:30 <funkmando> psychology is mostly opinion/religion anyways
13:25:33 <basti_> yep.
13:25:52 <basti_> did i mention my gf studies psychology, media sciences and philosophy?
13:25:54 <monochrom> But don't dismiss the point just because of the speaker.
13:26:16 <basti_> i think this view of memory is very simplified
13:26:28 <basti_> actually memory is multi layered in more than one way
13:26:30 <funkmando> yeah
13:26:35 <basti_> for example its temorally layered.
13:26:40 <funkmando> this is out of cognitive dogma i think
13:26:45 <funkmando> so they like to turn us into computers
13:26:46 <basti_> theres memory in your low level sensorics
13:27:04 <monochrom> Yes it is, but you don't have to deny that it is at least semantics, accoustics, graphics, and possible more, and they're possibly somewhat coupled.
13:27:12 <basti_> for example, you can decide which part of your receptions to recieve AFTER the event happened
13:27:30 <basti_> yep.
13:27:44 <basti_> but only if you give me a good definition of semantics.
13:27:47 * basti_ ducks and snicker
13:27:57 <monochrom> A problem is that we don't understand the semantics part.
13:28:51 <funkmando> also i can remember how to play a song on guitar better than anything else, i don't even have to think
13:28:55 <basti_> theres many more ways btw... neurobiology has shown the existence of a "anecdotal" and a "procedural" memory for example
13:28:58 <funkmando> and that's accoustic
13:29:17 <basti_> for example, dialling a phone number or a password.
13:29:43 <basti_> many people can type the PIN for their check card, but dont know the numbers
13:29:49 <basti_> cheque
13:30:04 <basti_> same goes with phone numbers you dial often
13:30:12 <funkmando> yeah procederal
13:30:20 <funkmando> yeah music playying is procedural
13:30:36 <basti_> and then there's people who had a brain injury and cant remember anything, but one day discover that theyre good instrumentalists, or know how to fix a bike or something
13:31:06 <basti_> so these two parts of memory seem even phsyically seperate
13:31:29 <funkmando> i still like the computer analogy
13:31:34 <funkmando> neurons = pointers
13:31:35 <funkmando> :P
13:31:38 <basti_> aww.
13:31:38 <basti_> ;)
13:32:00 <Maddas> I find it very offensive to call psychology 'mostly opinion/religion'
13:32:12 <basti_> well a computer is complete. Turing complete. Thats why it seems to be able to be everything.
13:32:24 <funkmando> turing complete?
13:32:27 <basti_> i think psychology is very overrated.
13:32:37 <basti_> ok lets make that "almost turing complete"
13:32:53 <funkmando> psychology has an extremely liberal and leftwing bias
13:33:01 <Maddas> Umm
13:33:13 <basti_> actually psychology has brought some great things. For example there's milgram.
13:33:37 <basti_> who i consider a scientific genius in some way.
13:34:05 <funkmando> and freud of course :)
13:34:09 <basti_> he knew how to poke at the right spot.
13:34:17 <basti_> freud is uhm. religion.
13:34:19 <basti_> and opinion.
13:34:21 <Excedrin> psychology is a science, if science proves that traditionally held values are harmful, I can see how a conservative would object
13:34:36 <funkmando> i dunno some of freud;s stuff just keeps popping up
13:34:38 <funkmando> it's very weird sometimes
13:34:47 <basti_> "my friend you want to sleep with your mother, thats why you feel so bad."
13:34:57 <basti_> "no its not my fault that you are agressive now."
13:35:06 <basti_> "in fact its your hidden attraction to your mother..."
13:35:13 <funkmando> his money = shit analogy was good
13:35:25 <basti_> yes he had some good ideas too.
13:35:27 <funkmando> how many times have you heard some homeless guy shout "eh you tight arsed bastard"
13:35:39 <basti_> and he is very right emotionally.
13:35:43 <funkmando> but likely he was just describing his own neurotic culture
13:35:57 <basti_> he deserves the honor of having brought back the subject into the field of view.
13:36:08 <basti_> although he was a cokehead.
13:36:13 <funkmando> well it still isn't really taken seriously outside of america
13:36:43 <funkmando> one big psychologist i haven't read much of isd Jung
13:36:46 <funkmando> any opinions?
13:37:03 <basti_> well he made up a concurrent myth.
13:37:08 <basti_> to freuds myth.
13:37:29 <basti_> i haven read him. but i havent read freud too.
13:37:40 <basti_> but when i read about jung i think, "hello weirdo".
13:37:45 <funkmando> heh
13:37:59 <funkmando> you're not into psychoanalysis then? :)
13:38:13 <basti_> as i said, i think freud deserves respect.
13:38:27 <basti_> he brought back the subject and emotions into the field of view.
13:38:57 <basti_> but stating that girls get frustrated because they dont have a penis is..
13:39:04 <basti_> .....far fetched.
13:39:07 <funkmando> tee hee
13:39:35 <basti_> psychoanalysis is not a bad idea for neurotics probably.
13:39:46 <funkmando> hahahahah
13:39:53 <funkmando> oh you mean the treatment
13:39:55 <funkmando> lmao
13:39:55 <basti_> but for other types of psychical diseases, it could wreak havoc
13:40:00 <basti_> oh lol
13:40:01 <basti_> yes.
13:40:16 <basti_> lol sorry that double sense wasnt intended
13:41:36 <basti_> my sister wants to become ergotherapist.
13:41:48 <funkmando> what is that?
13:41:59 <basti_> thats for the other end of the spectrum
13:42:13 <basti_> thats for example, for depressive people and schizophrenics
13:42:13 <Excedrin> it's like masseuse, but verbal
13:42:39 <basti_> they make baskets and the like
13:43:20 <basti_> because if you are in a mental hospital with your illness, and medications, after a few years you cant do anything at all
13:44:01 <basti_> and then an ergotherapist would come and show you how to pick up coins, and how to make a basket, and stuff like that, so you dont have to sit in your corner
13:44:15 <basti_> probably a very rewarding work in a way.
14:00:57 <Asta> basti_: gf
14:01:02 <basti_> Asta: ?
14:01:03 <Asta> opss
14:01:21 <Asta> basti_: that was supposed to be a search to confirm what I read, eh
14:01:35 <basti_> ooo kay.
14:01:43 <Asta> basti_: your gf a psychologist?
14:01:57 <CosmicRay> let's see, how can we relate this all back to haskell...
14:01:59 <basti_> no. she studies pychology
14:02:01 <Itkovian> any happy experts here?
14:02:02 <basti_> we cant.
14:02:12 <Asta> right
14:02:17 <CosmicRay> basti_: perhaps haskell is theraputic.
14:02:33 <Itkovian> I'm looking at boegels parser declaration, and I'm confused
14:02:35 <Itkovian> :-)
14:02:38 <basti_> actually most psychotic people cant work with digital things.
14:02:38 <Asta> basti_: do you know what are their views on Richard Bandler, John Grinder and such?
14:02:41 <CosmicRay> basti_: it gives us an outlet to reform our world into its true orderly, and recursive, self? :-)
14:02:46 <Asta> I was always curious about that...
14:03:16 <basti_> Asta: uhm, no, who are those people?
14:03:37 <CosmicRay> basti_: all the while lending a comforting sense of homogeneity to the experience since we know so many smart people named "simon"? :-)
14:03:49 <basti_> eh
14:04:03 <Asta> basti_: the developers of neuro linguistic programming (NLP), Design Human Engineering (DHE)...
14:04:17 <basti_> Asta: oh.
14:04:28 <basti_> Asta: i can tell you my opinion about NLP.
14:04:30 <basti_> =)
14:04:44 <Asta> basti_: as far as I know none of this is taught in Universities, so I wonder what do they think about it, on the other hand it seems to be used by lots of credible entities
14:04:51 <Asta> basti_: ok :)
14:05:01 <Asta> basti_: so what do you think about it?
14:05:14 <basti_> i think when NLP works with you, then you have other problems that wont be solvable with NLP ;)
14:05:15 <wli> I thought NLP was for "Natural Language Processing"
14:05:32 <Asta> wli: that too, and also non linear programming
14:05:36 <Asta> wli: :)
14:05:43 <wli> um
14:05:46 <Asta> basti_: hmm like?
14:05:52 <wli> "Non-Linear Programming" doesn't exist.
14:06:01 <Asta> wli: no?
14:06:05 <basti_> i dont know, too much time at your hands or something? obsession with controlling yourself?
14:06:06 <wli> Asta: No.
14:06:10 <gzl> what?
14:06:15 <gzl> nonlinear programming does exist.
14:06:26 <wli> Asta: Various kinds of programming are defined by what they are, not by what they are not.
14:06:40 <wli> gzl: ahem, try it
14:06:50 <wli> You'll get laughed at.
14:06:55 <Asta> basti_: nlp is not just about controlling oneself, not even just about control... (I'm not an expert though)
14:06:57 <gzl> try what?
14:07:20 <Asta> wli: well then my math department will be laughed at
14:07:33 <gzl> nonlinear programming is a topic in optimization theory, not a style of computer programming
14:07:35 <Asta> wli: because we teach linear programming classes and non linear programming too
14:08:11 <wli> Linear Programming is one thing; there are other kinds of programming (Dynamic Programming, Quadratic Programming, Integer Programming) for other topics.
14:08:21 <wli> None of which involve computer programming.
14:08:32 <gzl> yes, and this doesn't involve computer programming either.
14:08:48 <syntax_syntax> nonlinear continuous programming is not too hard.
14:08:50 <wli> Non-Linear Programming does not exist.
14:09:06 <syntax_syntax> Essentially, you need to learn the [Karush-]Kuhn-Tucker theorem.
14:09:08 <gzl> so then what are all those books titled "nonlinear programming" about?
14:09:26 <wli> gzl: Bad terminology.
14:09:30 <syntax_syntax> discrete optimization is where it gets beefy.
14:09:49 <syntax_syntax> Mathematical programming is called "mathematical programming" since before computer programming came along.
14:10:23 <gzl> how is it bad terminology?
14:10:46 <gzl> you're studying the general case in which the functions and constraints contain nonlinear parts
14:10:53 <wli> The different categories don't really have collective names. There is no underlying unifying concept.
14:11:34 <syntax_syntax> linear programming with Simplex is pretty easy, I just forgot how to do it.
14:12:01 <wli> gzl: I'm sorry, but Karush-Kuhn-Tucker does not have a broad enough scope to constitute a field of study.
14:12:33 <syntax_syntax> wli actually, [Karush-]Kuhn-Tucker is just a crowning achievement of something that was a field of study for centuries.
14:13:00 <gzl> i think you're being too anal about the "field of study" part
14:13:09 <syntax_syntax> so nonlinear continuous optimization might not be a hot research field anymore -- since we basically understand it -- but it was a serious research field for ages.
14:13:35 <wli> Nontrivial programming problems are out there and have fields of study devoted to them.
14:13:55 <syntax_syntax> yes; discrete and combinatorial programming problems.
14:14:24 <syntax_syntax> nonlinear continuous optimization was a serious problem for a long time, and the fact that it's essentially solved doesn't mean it wasn
14:15:01 <syntax_syntax> oops. nonlinear continuous optimization was a serious problem for a long time, and the fact that it's essentially solved and summarized in one single super-powerful t heorem doesn't mean it wasn't a field of study on its own doesn't mean it isn't a research field, albeit one essentially closed.
14:15:47 <esap> research fields are actually closed? :-)
14:16:35 <syntax_syntax> hahaha i totally screwed up in that sentence.
14:16:52 <syntax_syntax> you get the gist of it. English ain't my first language, so give the subgenius the slack it must have.
14:19:56 <funkmando> is everyone a subgenius? since the intelligence of everyone is contained in a genius (assumming genius' know everything ever)
14:20:44 <gzl> bad assumption
14:21:08 <funkmando> yeah i realised that at the end of the line
14:21:10 <funkmando> :'(
14:21:31 <syntax_syntax> www.subgenius.com
14:22:10 <syntax_syntax> I need a new computer.
14:22:31 <wli> Lagrange invented the solution, the standard of proof was merely not up to modern standards.
14:23:32 <wli> So anyway, it's rather difficult to take this seriously. Dynamic programming is something that actually has been around for centuries; Lagrange multipliers was nailed rather shortly after the problem was invented.
14:23:52 <syntax_syntax> hmm. I remember there being a Lagrange theorem for a subset of the problems the full KKT is able to tackle.
14:24:24 <wli> KKT reduces continuity requirements to first-order.
14:25:04 <syntax_syntax> wli well, it needs to be taught at some point. I learned KKT in the end of my Calculus 102 course, but if you're gonna have a calculus course heavier in the analysis bits, you might as well have a separate course for KKT.
14:25:04 <wli> This is not a particularly useful advance because the first-order requirements are not easy enough to verify to do so in an automated fashion.
14:25:25 <wli> I'm sorry, KKT is not enough content for a course.
14:25:42 <syntax_syntax> wli yes, but automated solving is not the only application of optimization theory.
14:25:47 <wli> Calculus of variations maybe.
14:25:56 <wli> But definitely not KKT.
14:26:13 <funkmando> hmm this channel has been overrun by the smart people from #math on EFNet
14:26:16 * funkmando hides
14:26:23 <syntax_syntax> We actually learn KKT as one of the prerequisites for game theory.
14:27:17 <monochrom> Heh thanks for the compliment funkmando
14:27:25 <tuomov> we had kkt on a optimisation theory course
14:27:37 <CosmicRay> mutt
14:27:42 <wli> Yes, it's useful for optimization.
14:27:42 <syntax_syntax> in the field of assymetric information, general-form solutions to continuous nonlinear optimization problems are needed. It's not that you're ever gonna use those closed-form solutions to come up with a number, it's that you use the solution to prove theorems about assymetric-information decision problems.
14:27:58 <CosmicRay> mutt
14:28:07 <wli> No, it's not enough content for a course.
14:28:12 <wli> Or a book.
14:28:25 <syntax_syntax> wli if you don't have previous knowledge of calculus, it might.
14:28:43 <syntax_syntax> You can write a book on "Calculus applied to nonlinear continuous optimization".
14:28:47 <wli> syntax: Then the course is about calculus.
14:29:02 <wli> syntax: Then the book is about calculus and KKT is a footnote.
14:29:05 <syntax_syntax> In my uni, the economics and engineering majors take the same calculus courses.
14:29:38 <wli> syntax: Either a lot of econ majors flunk or a lot of engineering students aren't getting enough math.
14:29:53 <syntax_syntax> and it's a neverending conflict of interest. The engineering departments want to steer the calculus course to cinematics and so on, while the economics department would rather have heavier exposition of the optimization problems.
14:30:10 <syntax_syntax> wli it _is_ a B.Sc, you know.
14:30:18 <tuomov> in the uni (of tech) I went to all took the same basic maths courses except those that did the honours versions
14:30:54 <wli> syntax: KKT is not sufficiently useful even for econ; the calculus of variations is what's truly needed.
14:31:20 <syntax_syntax> Depending on where you look, economics can be heavier in mathematics than, say, mechanical engineering, or can be taught without any mathematics at all.
14:31:24 <wli> syntax: And the Ito and Malliavin calculi.
14:32:27 <syntax_syntax> I don't know what Malliavin calculus is. 
14:32:39 <syntax_syntax> Itô calculus is, as far as I know, useful in finance. 
14:33:01 <gzl> it is
14:33:05 <syntax_syntax> I was actually about to take a course in Itô calculus and stochastic PDEs, but I decided I needed to learn more about measure theory first.
14:33:14 <gzl> malliavin calculus is in the same ballpark
14:33:21 <gzl> "stochastic calculus of variations"
14:33:24 <syntax_syntax> gzl stochastic calculus?
14:33:35 <funkmando> we got the formal definition of a limit today
14:33:39 <wli> Yes, stochastic calc of variations.
14:33:40 <syntax_syntax> I don't have the slightest idea of what you mean with "calculus of variations".
14:33:40 <funkmando> the proofs look hideous :(
14:33:54 <syntax_syntax> the proofs in analysis are always hideous. 
14:34:06 <gzl> funkmando: what, epsilon-delta?
14:34:10 <wli> syntax: optimize int(f(y(x),y'(x),x)dx,x=a..b) wrt. y(x)
14:34:17 <funkmando> gzl, yeah
14:34:20 <funkmando> we just finished series
14:34:26 <wli> syntax: that's the calculus of variations
14:34:32 <syntax_syntax> wli oh, dynamical optimization problems?
14:34:35 <wli> syntax: now make the integral depend on random variables
14:34:36 <gzl> this is why you do algebra instead of analysis ;p
14:34:40 <wli> syntax: dynamic programming
14:34:47 <wli> syntax: now make the integral depend on random variables
14:34:49 <syntax_syntax> Yes, it comes up in Development theory.
14:34:56 <wli> syntax: you get the Malliavin calculus
14:34:58 <syntax_syntax> oh ok.
14:35:03 <wli> syntax: it comes up everywhere
14:35:07 <wli> syntax: it's "fundamental"
14:35:17 <syntax_syntax> I'm starting to feel the whole stochastic approach is a bit overused, though.
14:35:38 <wli> syntax: e.g. GR is just what you get by taking the Lagrangian of the Ricci scalar
14:35:44 <gzl> *over*used?
14:36:53 <wli> syntax: http://www.springeronline.com/sgw/cda/frontpage/0,11855,5-10128-72-1457984-0,00.html
14:36:54 <wli> feh
14:36:57 <syntax_syntax> well, using random variables to model uncertainty is epistemologically questionable.
14:37:24 <syntax_syntax> I wish fuzzy set theory was more rigid, mathematically. I feel there are quite a few insights to be taken from there.
14:37:31 <wli> syntax: http://tinyurl.com/6ocrg
14:37:51 <gzl> questionable in what sense?
14:37:52 <wli> 79.95 EUR
14:38:00 <wli> if only that weren't 10000 USD
14:38:04 <gzl> haha
14:38:15 <wli> well, maybe it's slightly less but you get the idea
14:38:18 <syntax_syntax> many problems in uncertainty and decision under incomplete information belong more to a fuzzy memebership category than a stochastic one.
14:38:24 <lightstep> O Lord of the HaWiki, please save us from the Evil Pr0n Bots!
14:38:39 <funkmando> what are some good math topics to study in my 2nd year?
14:38:51 <gzl> second year of undergrad?
14:38:54 <funkmando> yes
14:38:59 <syntax_syntax> gzl take linear algebra seriously.
14:39:07 <syntax_syntax> It seems pointless, but it isn't.
14:39:11 <gzl> syntax_syntax: whya re you telling me?
14:39:14 <funkmando> im doing linear algebra right now. easy atm but may get hard
14:39:17 <syntax_syntax> gzl heh sorry.
14:39:19 <gzl> :)
14:39:20 <gzl> np
14:39:22 <funkmando> we just defined the axioms for matrices
14:39:32 <gzl> axioms for matrices?
14:39:36 <syntax_syntax> linear algebra _is_ easy. but it's way more useful than it seems.
14:39:36 <funkmando> yeah
14:39:41 <funkmando> like associativity etc
14:39:48 <syntax_syntax> don't you mean vector spaces?
14:39:54 <funkmando> i don't know
14:39:55 <funkmando> :P
14:40:05 <wli> funkmando: Calculus of variations, elliptic functions, and more foreign languages (e.g. French).
14:40:07 <gzl> the properties of those operations have to be proved, they're not axioms
14:40:08 <funkmando> i know we determined that the matrices form a group under addition
14:40:09 <syntax_syntax> linear algebra comes up even in functional analysis.
14:40:17 <funkmando> why foreign languages?
14:40:18 <basti_> universal algebra rocks.
14:40:28 <syntax_syntax> category theory rocks :-D
14:40:31 <gzl> syntax_syntax: that's cheating. functional analysis is half linear algebra :)
14:40:31 <basti_> that too.
14:40:46 <syntax_syntax> I keep on using the jargon of category theory in totally unrelated places.
14:40:48 <funkmando> isn't functional analysis epsilon delta craziness?
14:40:51 <gzl> no
14:40:54 <wli> funkmando: nope
14:40:59 <funkmando> what is category theory?
14:41:02 <wli> functional analysis is good
14:41:06 <syntax_syntax> New Years' eve, and I was drunk in a party talking to this chick
14:41:10 <syntax_syntax> Totally drunk.
14:41:19 <tuomov> functional analysis has some epsilon-delta and some algebra too
14:41:24 <desrt> the amount of linear algebra taught in first year in our university's engineering programme was recently decreased from 2 classes to 1 class
14:41:25 <gzl> category theory is a language for generalizing a lot of concepts in abstract algebra
14:41:34 <funkmando> cool
14:41:35 <desrt> what a ridiculous decission.
14:41:45 <funkmando> is that what you guys babble about in #math ?
14:41:54 <funkmando> the ideals and the rings and the banach spaces and the manifolds et  etc
14:41:56 <wli> desrt: There isn't really enough to study in linear algebra. They should replace it with the calculus of variations.
14:42:00 <basti_> syntax_syntax: what did you talk about with her?
14:42:00 <syntax_syntax> "See, I find your eyebrows very very attractive, but I don't mean this as a sexual compliment. You see, there is a functor between the category of nonsexual judgements and the category of sexual compliments. I am not flirting with you, I just thought I had to etc. etc."
14:42:04 <basti_> ah
14:42:08 <basti_> lol
14:42:11 <desrt> wli; we already have 2 calculus courses first year
14:42:19 <desrt> wli; and there was plenty to study
14:42:23 <funkmando> im bored of calculus now lol
14:42:25 <funkmando> i wanna do group theory
14:42:29 <funkmando> but it's stopped for now
14:42:32 <wli> desrt: calculus of variations != bonehead calc
14:42:34 <desrt> group theory is algebra :)
14:42:36 <funkmando> think we start multivariable calculus soonj
14:42:40 <gzl> funkmando: those things aren't categorical. stuff like functors, adjoints, pushout, pullback, universal property, natural transformation, coproduct, etc, are all categorical terms
14:42:49 <wli> multivariate being separate from univariate is horrible.
14:43:00 <wli> it should all just be done completely generally.
14:43:02 <syntax_syntax> multivariate being separate from univariate is pointless.
14:43:07 <desrt> wli; right, but you'd get all the students seeing 3 classes with the word "calculus" in the name and getting scared/bored/etc
14:43:08 <wli> "let mu be a measure space" etc.
14:43:16 <funkmando> eh
14:43:20 <funkmando> calculus is easy
14:43:25 <funkmando> compared with like, analysis
14:43:34 <gzl> funkmando: you should take algebra second year :)
14:43:53 <syntax_syntax> maybe you'd like to take probability.
14:43:54 <funkmando> i might, i enjoyed group theory
14:43:54 <tuomov> nah. calculus is a lot about tricks, while there's real meat in analysis
14:43:58 <funkmando> mostly the jargon was cool
14:44:17 <gzl> actually, the set of n by n matrices under matrix addition and multiplication forms a ring (not just a group under addition)
14:44:18 <funkmando> group theory sounds awesome to talk about
14:44:26 <wli> desrt: Yes, they should condense two of the bonehead ones into one and replace it with class field theory or some such.
14:44:27 <syntax_syntax> category theory is awesome to talk about.
14:44:39 <jlouis> so is algebra ;)
14:44:42 <funkmando> a ring is just a bunch of axioms right?
14:44:48 <gzl> no
14:44:50 <funkmando> like for a field
14:44:53 <funkmando> oh
14:44:54 <gzl> a ring is a set with two operations satisfying a bunch of axioms
14:44:54 <funkmando> lol
14:44:55 <tuomov> maths is awesome to talk about.. but I don't remember any of it after 2-3 years since the last course
14:44:56 <lightstep> yes
14:45:03 <syntax_syntax> For instance, ever heard of Pompeo's "Compared Lives"? It's essentially the biography of 12 famous greeks and 12 famous romans, with a lot of analogies.
14:45:07 <syntax_syntax> e.g. Alexander and Caesar.
14:45:10 <wli> desrt: actually there's a lot of crap they don't cover, e.g. continued fractions, elliptic functions, etc.
14:45:28 <gzl> funkmando: fields are just special rings
14:45:30 <funkmando> so why is it called a ring?
14:45:36 <wli> desrt: you could ditch the redundant content and cover that stuff
14:45:44 <syntax_syntax> So Pompeo postulates a functor between the category of Greek History, with objects being the actors in history and morphisms being their actions, and Roman History.
14:46:00 <syntax_syntax> I love the jargon in category theory :-D I can't stop using it in totally unrelated places.
14:46:14 <gzl> funkmando: i'm not sure
14:46:21 <funkmando> i get it for fields
14:46:26 <funkmando> because they aren't really 2d
14:46:30 <funkmando> 1d*
14:46:35 <funkmando> cos u got irrationals aswell
14:46:41 <funkmando> uhh for R anyway
14:46:48 <gzl> yeah, only for R. ;p
14:47:04 <lightstep> gzl: also for C
14:47:21 <funkmando> C contains a + bi a and b in R?
14:47:25 <jlouis> A field is actually an extension of a ring
14:47:26 <gzl> yes
14:47:26 <desrt> wli; i actually don't remember what was covered in the 'bonehead' ones
14:47:34 * Gowilla looks around hopefully for dons
14:47:36 <wli> "Caesar was awesome, except he never conquered Persia or Germany, and actually lost battles."
14:47:46 <wli> desrt: obsolete methods for integration
14:47:46 <funkmando> why do all the math people come here?
14:47:47 <desrt> like... obviously, the first one was about derivatives and a bit of integrals... and the second one more about integrals and [something else]...
14:47:56 <gzl> funkmando: if you really want to know, you could probably look up the article in which Hilbert coined the term
14:48:03 <syntax_syntax> funkmando I'm actually an economist. Computer programming is my hobby :)
14:48:07 <funkmando> cool
14:48:13 <funkmando> programming rocks
14:48:20 <boegel> Itkovian: I wouldn't call myself a Happy expert, but I know a lot about boegel's parser :p
14:48:58 <jlouis> anybody that have given ghci on OpenBSD a try (the ports tree only contains the ghc part)
14:48:59 <funkmando> so what do most undergrads do in the third year>?
14:49:05 <syntax_syntax> [20:49] <boegel> Itkovian: I wouldn't call myself a Happy expert, but I know a lot about boegel's parser :p <-- where did this come from?
14:49:06 <funkmando> just get deeper and deeper into algebra?
14:49:12 <gzl> no, you take whatever you want
14:49:15 <syntax_syntax> I'm not a maths major.
14:49:16 <wli> syntax: So as an economist do you make extensive use of the Malliavin calculus and martingales?
14:49:20 <gzl> real/complex analysis
14:49:21 <gzl> topology
14:49:23 <gzl> geometry
14:49:26 <desrt> funkmando; become extremely bored and contemplate suicide
14:49:30 <gzl> whatever
14:49:30 <funkmando> haha
14:49:37 <wli> gzl: elliptic functions
14:49:38 <funkmando> topology sounds wacky and fun
14:49:41 <syntax_syntax> wli dynamical programming usually is taught in graduate school, except for some very basic ideas in a Development course.
14:49:48 <tuomov> in my case: whatever courses were at all available
14:49:53 <tuomov> the uni wasn't big on maths
14:49:57 <syntax_syntax> wli Itô calculus is only studied by those getting involved with finance.
14:49:58 <gzl> wli: masochist. :)
14:50:26 <jlouis> funkmando: topology is wacky and fun
14:50:26 <funkmando> dynamic programming.. seem to recall doing that in my discrete course at A level
14:50:36 <syntax_syntax> wli Myself, I'm into game theory and industrial organization. My undegrad thesis is about network externalities and Apple Computer.
14:50:46 <boegel> syntax_syntax: <Itkovian>	I'm looking at boegels parser declaration, and I'm confused	22:03:36
14:50:50 <funkmando> yeah i did game theory too that was cool
14:51:01 <boegel> (time isn't the same as yours though)
14:51:56 <syntax_syntax> you probably didn't really _do_ game theory. You can't take a serious game theory course without probability and real analysis all in place.
14:51:56 <funkmando> so topology is the study of... surfaces?
14:51:56 <funkmando> spaces?
14:51:56 <funkmando> sets?
14:51:56 <gzl> syntax_syntax: heh neat, available online?
14:51:56 <wli> gzl: they matter a lot, without them there are a lot of problems there's no way to understand analytically
14:52:15 <wli> syntax: Sounds hard to do game theory without calc of variations.
14:52:34 <wli> syntax: Though I can see being able to get by without the Malliavin calculus.
14:52:41 <syntax_syntax> gzl I'm just starting.
14:52:53 <gzl> syntax_syntax: oh, ok
14:52:55 <funkmando> syntax : yeah it was very basic
14:52:58 <gzl> syntax_syntax: let me know when you're done :)
14:53:25 <wli> I personally need a big crash course on SDE's and Malliavin stuff.
14:53:45 <syntax_syntax> wli it actually isn't. You essentially discount the pay-off flow to present-value, like you would do with cashflows.
14:53:45 <wli> But I can see how hugely useful and important it is, sice the reason I need it is that I have a use for it. =)
14:53:59 <gzl> funkmando: no, it's the study of certain properties of spaces
14:54:23 <funkmando> do the matrices form a vector space under multiplication>
14:54:24 <funkmando> ?
14:55:04 <wli> syntax: Eh, realistic game scenarios sound like Pontrjagin principle targets to me.
14:55:05 <gzl> yes 
14:55:08 <syntax_syntax> gzl it's gonna be in portuguese, you know :-|
14:55:15 <gzl> but you have to take the scalars from a field and not a ring
14:55:36 <funkmando> why?
14:55:37 <syntax_syntax> wli the impact of assuming constant discount rates and the like over the conceptual conclusions of game-theoretical models is nil.
14:55:48 <gzl> because a vector space requires the scalars to come from a field
14:55:53 <gzl> otherwise you end up with a module
14:55:59 <syntax_syntax> wli remember, this isn't engineering. You're making a lot of stuff up, beginning with the payoffs.
14:57:41 <wli> syntax: I used that for matrix games.
14:57:49 <gzl> syntax_syntax: suck.
14:58:11 <syntax_syntax> wli hmm. "matrix games" as in repeated iterations of a static-form game?
14:58:17 <funkmando> roughly how many groups have been identified and given a name?
14:58:20 <wli> syntax: Basically.
14:58:30 <syntax_syntax> anything being represented by a matrix is by definition discrete-time.
14:59:05 <wli> syntax: When there are continuous alternatives or continuous time or both, then you start getting integrals to optimize.
14:59:50 <syntax_syntax> wli under very strict assumptions of symmetry between paths and all.
15:00:31 <syntax_syntax> you should take a look at the Cournot model. It's very simple, it involves continuous alternatives and it produces stable Nash equilibria with two simple unconstrained maximization problems.
15:00:32 <funkmando> is complex analysis as nasty as real analysis?
15:00:48 <gzl> no
15:00:50 <gzl> it's much nicer
15:01:03 <gzl> in some ways
15:01:13 <wli> syntax: it can't be a probabilistic strategy if it involves continuous alternatives without the payoff being in the form of an expectation.
15:01:26 <funkmando> how does it differ exactly?
15:01:26 <basti_> 0_0
15:01:30 <funkmando> i is just a constant after all
15:01:31 <wli> funkmando: try multivariate complex analysis =)
15:01:38 <syntax_syntax> wli hmm. you really need to look at the definition of a Nash equilibrium.
15:01:45 <tuomov> real analysis is nicer than complex analysis
15:01:50 <wli> syntax: What makes you think I can't recite it from memory?
15:01:59 <tuomov> measure theory was even nicer
15:02:00 <syntax_syntax> wli in the cournot model, there's a market with a demand curve like P(q) = a - bq
15:02:20 <syntax_syntax> uhh, I'm spending a lot of time explaining the cournot model, and I'll prolly do it badly. 
15:02:22 <funkmando> we're doing countable sets aswell
15:02:27 <funkmando> bloody weird
15:02:34 <gzl> countable sets aren't weird
15:02:48 <funkmando> makes no sense , why isn't a finite set say {1,2,3} countable?
15:02:54 <wli> syntax: Models that simple will end up being able to be done via KKT.
15:02:55 <funkmando> i can clearly label every element
15:02:55 <syntax_syntax> anyway, in the Cournot model, two firms are setting quantitites they're gonna dump in a market.
15:02:56 <gzl> oh
15:02:57 <gzl> that
15:03:01 <gzl> that's just a definitional thing
15:03:05 <gzl> some people define that to be countable
15:03:09 * wagle went to a talk today where they are using clifford algebras in neural nets
15:03:13 <gzl> other people like "countable" to mean "countably infinite"
15:03:29 <tuomov> either that or 'at most countable' and 'countable'
15:03:35 <gzl> yeah, or that
15:03:45 <gzl> or they define "denumerable" to be either and "countable" to be just the infinite one
15:03:47 <funkmando> at most countable = not a continuum right?
15:03:54 <gzl> just do what you want as long as you explain it
15:04:05 <syntax_syntax> the thing is, the firm 1 takes its optimal decision expecting the firm 2 to take an optimal decision given an optimal decision by the firm 1 and so forth.
15:04:06 <basti_> but a countable set can be dense in a continuum
15:04:15 <mattam> denumerable = countable no ?
15:04:21 <syntax_syntax> So there is an instant equilibrium from a continuous alternatives game.
15:04:25 <gzl> mattam: depends on the book, as far as i know
15:04:32 <syntax_syntax> It becomes a simultaneous system of equations.
15:04:34 <gzl> anyway, dinner, bbl
15:04:35 <mattam> good to know
15:04:43 <wagle> i thought denumerable was "emittable by a turing machine"
15:04:47 <funkmando> does dense mean there are infinitely many elements between any two elements you pick?
15:04:52 <wagle> or something like that
15:05:16 <basti_> its enough if there is one
15:05:37 <basti_> i think.
15:05:41 <wagle> dense means "you cant find two adjacent elements"
15:05:47 <wli> syntax: Probabilistic strategies over continuous alternatives clearly give rise to optimal control problems.
15:06:16 <syntax_syntax> wli not if you expect every agent to behave optimally.
15:06:18 <wagle> something like axiom of choice might give you infinite
15:06:19 <tuomov> that A is dense in B means that for each b in B and an environment E of b there is an element a of A in E
15:06:24 <basti_> actually theres two meanings of dense, one is a relation between to sets, and one is the same relation between a set and itself (which gives slightly different results)
15:06:32 <syntax_syntax> a Nash equilibrium is such that no agent has an incentive to deviate.
15:07:19 <funkmando> might doa  course in number theory too
15:07:24 <funkmando> so i can prove some crazy stuff
15:07:28 <wli> Probabilistic strategies don't have individual alternatives as strategies, but rather, probability distributions over the alternatives as strategies.
15:07:49 <basti_> uhm
15:07:51 <basti_> goodnight
15:08:04 <syntax_syntax> wli oh, you mean "mixed-form" solutions. 
15:08:10 <syntax_syntax> That's what they're called in the jargon.
15:08:13 <wli> In a matrix game this gives rise to a KKT problem.
15:08:39 <boegel> duncan: hi :)
15:08:47 <wli> The jargon I heard just called them "probabilistic strategies".
15:09:19 <syntax_syntax> hmm. you might have a point.
15:09:43 <wli> Well, it's not really my point, this was thrust in my face at some point or other.
15:10:08 <syntax_syntax> you need to ease up a bit in your modelling :)
15:10:23 <wli> syntax: ?
15:11:06 <syntax_syntax> Game theory is not engineering.
15:11:27 <wagle> ?
15:11:42 <wli> I just have no idea what you mean. What does "ease up on your modelling" mean?
15:12:14 <syntax_syntax> Game-theoretical modelling is meant to give insight as for the systemic consequences of individual behaviour processes. If you gain no conceptual insight from mapping continuous alternatives to functional spaces of probability distributions over fuzzy sets, you don't need to do it.
15:12:36 <syntax_syntax> You are _not_ coming up with 'exact solutions'. You're just using mathematics as a language.
15:12:45 <wli> I don't know. Everything was probabilistic from the get-go in the game theory class I took.
15:13:04 <tuomov> economics is not engineering. it's even more hand-wavy
15:13:22 <wli> Well, engineering is abominable, I can't imagine worse.
15:13:22 <tuomov> with completely bogus premises
15:13:26 <TheHunter> hmm, i get "Can't find module `HUnit'", does that mean that the HUnit library isn't compiled for profiling?
15:13:51 <funkmando> is maths the best subject ever?
15:14:07 <tuomov> maths isn't hand-wavy. usually.
15:14:16 <funkmando> *cough*calculus*cough*
15:14:27 <Igloo> TheHunter: If you're compiling with profiling that's one possible reason
15:14:35 <syntax_syntax> wli it's an approach, I guess. But you can't get to, say, perfect bayesian nash equilibria while keeping everything probabilistic and continuous in one semester.
15:14:37 <funkmando> i almost laughed
15:14:40 <funkmando> my lecturer was like
15:14:44 <syntax_syntax> it's a matter of choices when planning a course.
15:14:53 <funkmando> "and yes fourier realised this was the series"
15:14:54 <funkmando> hahaha
15:14:57 <wli> tuomov: Hmm, the econ I saw was largely decision-making stuff.
15:15:14 <wli> tuomov: No idea about the normative bullcrap or the social science parts.
15:15:25 <syntax_syntax> Mainstream economics yields results that some people in certain areas of the political spectrum dislike.
15:15:51 <tuomov> mainstream economics is used to justify the dominant economic system
15:15:52 <syntax_syntax> Then they tend to shun economics as whole, instead of subjecting their own political beliefs to rational analysis. I see this happen all the time.
15:16:09 <TheHunter> Igloo, thanks.
15:16:26 <wagle> wli: oh yeah, i noticed a copy of jennings and mckeown "matrix analysis" in the linear algebra section at powells..  it seem to have a couple pages of detail on SVD
15:16:30 <wli> syntax: Don't know what to tell you. If you can handle Malliavin after a 5-minute gloss over the textbook coverage of the SDE grinder, why not.
15:16:34 <wli> wagle: ooh
15:17:04 <wli> syntax: OTOH it was econ for econ, so maybe they were trying to flunk people out.
15:17:22 <wli> syntax: OTTH, it was a tiny class.
15:17:49 * wagle hops the max
15:18:15 <wli> wagle: the code that needs the SVD is still getting the equations set up.
15:19:58 <syntax_syntax> wli trade-offs, I guess. It's a cramped 8-semester program here, so we have only one semester for game theory, and they wanted to reach assymetric information problems.
15:20:02 <wli> syntax: Anyway, the parts of econ I'm interested in might as well be engineering and/or physics; it's all cold hard "optimize the number of dollars" stuff.
15:20:22 <wli> syntax: Hmm, they didn't do asymmetric information at all here.
15:20:25 <syntax_syntax> wli well, I'm interested in theoretical insights from game theory. 
15:20:47 <syntax_syntax> wli yes, assymetric information is stuff needed for financial macroeconomics.
15:21:04 <syntax_syntax> all theoretical. You can show that assymetric information leads to incomplete credit markets.
15:21:17 <syntax_syntax> and incomplete credit markets have long-term development consequences, etc. etc.
15:21:37 <wli> syntax: BTW what are these politically unpopular results from mainstream economics?
15:22:14 <syntax_syntax> wli essentially, market equilibria under a few not-that-restrictive assumptions are Pareto-optimal, which means governments should stay the heck out of most markets for efficiency's sake.
15:22:23 <tuomov> pareto optimality is crap
15:22:56 <wli> syntax: That's one I already knew about.
15:22:59 <wli> okay
15:23:02 <syntax_syntax> wli incidentally, even if you ignore market efficiency,  there are game-theoretical results that show that the political process is inherently suboptimal.
15:23:07 <tuomov> they have all these convergence results that markets will lead to stability under some insane assumptions and pareto optimality
15:23:12 <wli> I didn't realize that was so politically unpopular.
15:23:19 <syntax_syntax> wli just look at tuomov.
15:24:04 <wli> syntax: IMHO the consequence is really fully quantifying the cost of e.g. minimum wages etc.
15:24:06 <syntax_syntax> political decision-making leads to what game-theoretical studies of politics call rent-seeking.
15:24:09 <tuomov> pareto optimality means that the welfare of no-one must decrease for anyone else's to rise
15:24:31 <tuomov> so by their theories a situation where one has everything and everyone else nothing is optimal
15:24:56 <wli> syntax: rent seeking is a big problem
15:24:58 <tuomov> although so is a situation where everything is divided equally
15:25:10 <tuomov> pareto optimality simply doesn't make sense
15:25:20 <syntax_syntax> which is why most economists will advocate ex post facto wealth redistribution, while letting the market handle production.
15:25:47 <syntax_syntax> don't impose minimum wages or trade restrictions, just give cash handouts to the extremely poor so they have a purchasing power.
15:26:02 <tuomov> and great purchasing power is that
15:27:03 <zamez> I urge for a five-year-plan to increase production and exceed capitalism by 300%
15:28:09 <tuomov> I urge for a word wide social revolution, the rest will sort out itself
15:28:30 <tuomov> time to stop obeying capitalist masters
15:28:31 <wli> Speaking of rent-seeking, people should really consider the cost of losing reserve currency status...
15:28:47 <zamez> word wide? capital letters?
15:28:56 <syntax_syntax> the problem with "social revolutions" is that they essentially substitute a marginally faulty (essentially due to incomplete credit markets) market process for an extremely faulty political decision process.
15:28:56 <tuomov> s/word wide/worldwide/
15:29:03 <zamez> :>
15:29:06 * zamez hides
15:29:15 <tuomov> social revolution != socialist revolution
15:29:29 <Gowilla> how much would the $ drop if it did?
15:29:31 <tuomov> social revolution is a change in the minds of people, abandoning slave mentality
15:29:34 <syntax_syntax> a "revolution" means taking matters to a political decision process, period.
15:29:41 <wli> Cowilla: 90-99.99%
15:29:55 <Heffalump> this seems unlikely..
15:30:21 <Heffalump> relative valuations of goods would impose some kind of limit
15:30:50 <syntax_syntax> the Parity of Purchasing Power imposes a limit on exchange rates.
15:30:54 <tuomov> there are all kinds of revolutions
15:31:02 <syntax_syntax> It's surprising that the dollar got as overvalued as it did.
15:31:12 <wli> Heffalump: Not really; the rest of the world would be rather strongly averse to USD if it weren't OPEC's reserve currency, and would probably even spew economic sanctions out the wazoo.
15:31:14 <Jagular_> Heffalump: woo
15:31:31 <syntax_syntax> I guess the international wave of financial crisis led to the US being able to finance a current account deficit for long.
15:32:18 <wli> syntax: the thing is the account deficit won't get resolved by devaluing the currency unless the currency's value is 0 EUR
15:32:47 <Heffalump> if the $ drops high enough the US gets a trade surplus which will resolve the deficit..
15:32:50 <Heffalump> s/high/low/
15:33:02 <syntax_syntax> never underrate the value of the political stability in the US.
15:33:40 <wli> syntax: You say that as the neocons are wiping their backsides with the constitution and overtly threatening to nuke Iran
15:33:55 <zamez> commie!
15:33:57 <syntax_syntax> The rest of the world isn't "strongly averse" to the USD, no matter how bad Dubya fucks up, because it's the only country to essentially have the same institutional framework for >100 years.
15:34:10 <Heffalump> wdym by institutional framework?
15:34:18 <wli> syntax: Plus a fair amount of the world is unconvinced of the legitimacy of succession since '00
15:35:06 <tuomov> iran, venezuela, cuba, ...
15:35:49 <syntax_syntax> wli they aren't.
15:36:21 <syntax_syntax> I live in "the rest of the world", and am in close contact with fund managers and all. 
15:38:40 <funkmando> is communism evil?
15:38:48 <zamez> heh
15:39:12 <zamez> that's an essay topic, not an irc question :>
15:39:15 <wli> syntax: hmm, everything I've heard is everyone's screaming "Euro!" like mad and converting USD to Euros, dumping US bonds, refusing to finance .us debt, etc. as fast as the market will bear.
15:39:49 <wli> syntax; and even Saudi Arabia making noises about switching to Euros
15:40:12 <wli> syntax: (along with the rest of OPEC, of course)
15:40:13 <tuomov> funkmando: please note that the so called "communist states" are and have no been communist
15:40:22 <tuomov> "communist state" is an oxymoron
15:40:39 <tuomov> they're state capitalisms with some socialist tendencies
15:40:41 <wli> syntax: the way I see it is, "When OPEC switches to the Euro, the music stops"
15:41:04 <syntax_syntax> wli sure, they're pulling their political power. 
15:41:16 <syntax_syntax> wli yes, my professors say the same. Though they're more worried about China.
15:42:35 <wli> syntax: I'm worried about China, too, but OPEC will have a far more immediate effect. China's already been silently pulling out of US bonds/etc. along with Japan
15:42:37 <monochrom> communism is not evil, just naive.
15:42:49 <monochrom> perhaps I mean socialism.
15:43:05 <tuomov> the closest example in recent history of something resembling (anarchist) communism has been catalonia in the spanish civil war
15:43:24 <wli> syntax: pretty heavy dumping going on continuously for a while, and they've both stopped attending treasury debt auctions
15:43:37 <syntax_syntax> anarchism is just microcommunism. Tyranny in small groups is still tyranny.
15:44:03 <tuomov> and there it worked very well while it lasted (being tried to exterminate on two fronts)
15:44:03 <syntax_syntax> wli sure, the american current account deficit was pretty bad. It should stop at some point, though.
15:44:03 <funkmando> is nazism evil?
15:44:08 <syntax_syntax> It isn't a panic, it's a correction.
15:44:15 <tuomov> socialism="transitory" "workers'" state between capitalism and communism in marxist theory
15:44:56 <wli> syntax: It doesn't take a panic to wipe me out.
15:44:59 <syntax_syntax> wli to use an analogy, I expect AAPL to take a plunge pretty soon, in spite of the glorious sales of the Mac mini.
15:45:09 <syntax_syntax> it's already overvalued. 
15:45:30 <tuomov> syntax_syntax: what tyranny? if there's tyranny it is by definition not communism (or anarchy)
15:45:45 <lightstep> how can one tell ghc to look in /usr/lib/imports in addition to /usr/lib/ghc-6.2.2/imports ?
15:45:45 <wli> syntax: I know it's not going to be a catastrophe from a global or even whole-country perspective. What matters is whether it's a catastrophe for me personally.
15:46:07 <funkmando> hey in a haskell program is it good practise to keep my functions above the main function im using or below?
15:46:22 <funkmando> by main i mean the one im calling from ghci
15:46:28 <lightstep> funkmando: the way that reads better
15:46:34 <syntax_syntax> tuomov much like if it is politically enforced, it is by definition not capitalism.
15:46:38 <funkmando> functions first then?
15:46:52 <monochrom> either way is fine.
15:46:57 <funkmando> so you read all what stuff does and then see main implement them
15:47:04 <syntax_syntax> tuomov so you can't call the american corporatocracy "capitalism" and attack capitalism on the basis of the faults of the corporatocratic system.
15:47:05 <tuomov> the state exists because some of the capitalists want it
15:47:08 <funkmando> whereas the other way around you see a main function witha  load of unknown calls in it
15:47:21 <tuomov> capitalism=plutocracy
15:47:31 <dustin`> Okay, I'm getting a strange type error with this: "prime x = (notdivisibleby x [2..(truncate (sqrt x))])"
15:47:33 <monochrom> One can argue either way.
15:47:53 <dustin`> hugs says "instances of (RealFrac Integer, Floating Integer) required
15:48:11 <syntax_syntax> tuomov nope. Capitalism = "to those as they choose, for those as they are choosen".
15:48:27 <tuomov> as they're chosen by those with the property
15:48:36 <syntax_syntax> if socialists get to define communism, then libertarians get to define capitalism. *Yawn*.
15:48:42 <lightstep> dustin`: did you annotate it as prime :: Integer -> Integer?
15:48:55 <wli> syntax_syntax: OPEC moving to the Euro is actually very dangerous. There's a very strong likelihood of a large-scale military conflict resulting from it.
15:48:55 <dustin`> Any democracy degenerated to plutocracy.  Look at Athens =)
15:49:04 <dustin`> lightstep: Integer -> Bool
15:49:35 <dustin`> where notdivisibleby is of type Integer -> [Integer] -> Bool
15:49:36 <lightstep> dustin`: well, sqrt works only on Float and such. try fromIntegral
15:49:54 <syntax_syntax> actually, "democracies" don't exist. That's the gist of Arrow's Impossibility Theorem
15:50:03 <syntax_syntax> Collective decision-making is inherently faulty.
15:50:09 <tuomov> capitalism _needs_ the state to enforce its property laws
15:50:13 <funkmando> democracy sux
15:50:21 <funkmando> no one is equal at leading a nation
15:50:22 <funkmando> what a joke
15:50:30 <wli> technocracy baby technocracy
15:50:46 <syntax_syntax> capitalism at its core is a pure, darwinist meritocracy.
15:50:54 <zamez> I prefer to put main at the top
15:51:03 <zamez> and then kind of topologically sort them
15:51:04 <tuomov> with merit measured by wealth
15:51:06 <zamez> if you know what I mean
15:51:14 <syntax_syntax> in pure capitalism, wealth derives from merit.
15:51:20 <dustin`> lightstep: thank you!  Is this sort of conversion not implicit as some kind of safegaurd?
15:51:32 <dons> Heffalump: you looking for me (a while ago)?
15:51:35 <tuomov> or maybe the other way around rather...
15:51:36 <syntax_syntax> even in imperfect capitalist societies, wealth tends to be a better measure of wealth than anything that could be politically enforced.
15:51:44 <monochrom> It comes down to whether you are a top-down person or a bottom-up person.
15:51:44 <tuomov> merit derives from wealth
15:51:50 <syntax_syntax> er, wealth tends to be a better measure of merit.
15:52:10 <dons> jlouis: still want to know about openbsd ghci
15:52:11 <syntax_syntax> as I said, to those as they choose, for those as they are chosen. 
15:52:11 <lightstep> dustin`: no, but explicit numbers such as 18 reads as (fromIntegral (18::Integer))
15:52:12 <dons> ?
15:52:19 <funkmando> whether i climb onto that mountain
15:52:23 <syntax_syntax> if ion3 was any good, you'd be making money from it :-P
15:52:24 <funkmando> or drop onto it from the sky
15:52:25 <funkmando> lol
15:52:26 <Heffalump> dons: I'm trying to add a couple of features to the Plugins.Make interface and I was wondering how you thought it should be done.
15:52:28 <Excedrin> heh, top-down more like I want to surrender my liberty to someone else who's competent please, I can't run my own life
15:52:33 <tuomov> syntax_syntax: LOL
15:52:50 <Heffalump> firstly, I want to restrict what a src file is allowed to do in makeWith, as I mentioned earlier
15:53:15 <funkmando> www.ihatejobs.com
15:53:17 <dustin`> lightstep: Interesting.  Well, thanks again!
15:53:20 <Heffalump> currently my idea is to pass in a ([String],[String],HSModule) -> Either String ([String],[String],HSModule) filter
15:53:30 <Heffalump> the two lists of Strings are the pragmas
15:53:49 <dons> hmm. ok. that doesn't sound too bad.
15:53:51 <Heffalump> the result is either an error message or a modified module
15:53:59 <Heffalump> I think probably a data type is wanted instead of that triple
15:54:06 <dons> sure
15:54:29 <lightstep> dustin`: all of my wisdom was gathered from listening to Qs&As on #haskell
15:54:34 <Heffalump> secondly, I want to store source code in a database and pull it out again to cmopile, so I want a String interface instead of FilePath
15:54:48 <Heffalump> and I'm wondering how that should interact with caching compiled code etc, if at all
15:54:51 <dons> now that is a nice idea!
15:55:09 <lightstep> Heffalump: why String?
15:55:25 <Heffalump> what else would you suggest I store in a database?
15:55:26 <dons> I presume he means the file src as a String?
15:55:30 <Heffalump> I do.
15:55:51 <dons> now, re-making() things might have trouble, as they use file modification times on disk
15:55:57 <lightstep> and why Either (instead of some instance of MonadError)?
15:55:57 <dons> but this is easily circumvented
15:56:38 <Heffalump> lightstep: cos that's the style the existing code uses
15:57:05 <Heffalump> dons: do you think passing in a String and "last-updated" time would be better? I could obviously store the latter in the database too.
15:57:43 <dons> if you could store the time in the database, that would help -- or maybe you don't care about modification times in this scenario?
15:57:53 <boegel> hey dons
15:57:59 <dons> (i.e. always remake?)
15:58:03 <funkmando> hey
15:58:06 <funkmando> how do i use isDigits
15:58:11 <funkmando> to check if a string is all digis?
15:58:13 <funkmando> ts?
15:58:25 <Heffalump> I think having a cache of compiled code would be helpful.
15:58:31 <Heffalump> Otherwise things will always respond quite slowly.
15:58:35 <funkmando> is it if(all isDigits string) ?
15:59:14 <Heffalump> but I'm happy to take responsibility for remembering an object filename to use
15:59:14 <dons> Heffalump: yep, of course. the chalmers guys found this too
15:59:27 <lightstep> funkmando: what is the type?
15:59:33 <funkmando> string
15:59:36 <dons> ok. well I give you my blessing to hack!
15:59:43 <lightstep> @type isDigits
15:59:44 <lambdabot> bzzt
16:00:29 <funkmando> i need to prevent naive users from entering text into my wonderful program
16:00:39 <lightstep> @type isDigit
16:00:41 <lambdabot> bzzt
16:00:41 <funkmando> or at least give them a friendly error message
16:00:48 <Heffalump> okie dokie :-)
16:01:05 <funkmando> so i want to use isDigits
16:01:08 <lightstep> funkmando: what about reads? is that good enough?
16:01:15 <funkmando> reads?
16:01:20 <funkmando> what does that do
16:01:28 <funkmando> im a week old in terms of haskell btw
16:01:28 <funkmando> :P
16:01:43 <lightstep> @info reads
16:01:44 <lambdabot> -- reads is a variable
16:01:44 <lambdabot> reads :: forall a. (Read a) => String -> [(a, String)]
16:02:03 <funkmando> what is => ?
16:02:20 <lightstep> it's a type class constraint
16:02:29 <funkmando> ok
16:02:38 <lightstep> it means that reads is defined whenever a is of class Read
16:03:00 <lightstep> where class Read is the class of types that have reads defined for them
16:03:00 <funkmando> oh im using read a
16:03:08 <funkmando> yeah
16:03:19 <funkmando> to convert digits into integers
16:03:34 <funkmando> but how do i "catch the exception" ?
16:03:38 <funkmando> when someone enters text?
16:03:58 <lightstep> read is built upon reads, but it calls error, so it's not recoverable
16:04:16 <funkmando> hmm
16:04:22 <lightstep> maybe you need to test the result of reads yourself
16:04:36 <funkmando> for entering in text? i have
16:04:43 <funkmando> it just gives an incomprehensible error msg
16:04:57 <lightstep> @eval reads "123" :: Integer
16:04:58 <lambdabot> (line 1, column 14):
16:04:58 <lambdabot> unexpected ":"
16:04:58 <lambdabot> expecting simple term
16:05:08 <lightstep> @eval (reads "123") :: Integer
16:05:08 <lambdabot> (line 1, column 16):
16:05:08 <lambdabot> unexpected ":"
16:05:08 <lambdabot> expecting simple term
16:05:22 <lightstep> @eval reads "123"
16:05:22 <lambdabot> unbound variable: reads
16:05:26 <dons> you can recover from 'error' if you wish, btw.
16:05:49 <dons> it's just a normal exception
16:05:53 <funkmando> i was gonna use
16:05:54 <funkmando> triangle p q r =
16:05:54 <funkmando>     if((all isDigits p) && (all isDigits q) && (all isDigits r)) then
16:06:02 <funkmando> but it wouldn't work
16:06:35 <stepcut> argh, I can't get cdrdao to work as a user or setuid :-/
16:07:26 <funkmando> it said the variable isDigits was not in scope
16:07:34 <funkmando> and i have import Data.Char at the top
16:07:53 <dons> @type Data.Char.isDigit
16:07:54 <lambdabot> Data.Char.isDigit :: Char -> Bool
16:08:09 <dons> @type map Data.Char.isDigit
16:08:10 <lambdabot> map Data.Char.isDigit :: [Char] -> [Bool]
16:08:25 <funkmando> @type Data.Char.isDigits
16:08:26 <lambdabot> bzzt
16:08:28 <funkmando> oh
16:08:28 <funkmando> lol
16:08:30 <dons> @type and $ map Data.Char.isDigit
16:08:31 <lambdabot> bzzt
16:09:07 <dons> @type Data.List.and $ map Data.Char.isDigit
16:09:09 <lambdabot> bzzt
16:09:25 <dons> @type Data.List.and 
16:09:25 <lambdabot> Data.List.and :: [Bool] -> Bool
16:09:27 <lightstep> @type and . map Data.Char.isDigit
16:09:28 <lambdabot> and . map Data.Char.isDigit :: [Char] -> Bool
16:09:39 <funkmando> ok
16:09:41 <funkmando> it worked
16:09:43 <funkmando> but
16:09:50 <funkmando> it didn't return "Invalid"
16:09:56 <funkmando> which i have after else at the bottom
16:09:59 <funkmando> instead it returnde
16:10:00 <funkmando> *Triangle> triangle omg
16:10:00 <funkmando> <interactive>:1: Variable not in scope: `omg'
16:10:22 <boegel> funkmando: "omg" instead of omg ?
16:10:28 <funkmando> yes 
16:10:30 <funkmando> indeed
16:10:30 <funkmando> thanks
16:10:49 * dons throws $ around too often
16:11:04 <funkmando> ok
16:11:07 <funkmando> now it hits me with
16:11:08 <funkmando> *Triangle> triangle "omg"
16:11:08 <funkmando> <interactive>:1:
16:11:08 <funkmando>     No instance for (Show (String -> String -> String))
16:11:08 <funkmando>       arising from use of `print' at <interactive>:1
16:11:08 <funkmando>     In a 'do' expression: print it
16:11:23 <funkmando> wth is that lol
16:11:28 <lightstep> if you use $ too much, you might want to convert to lispy syntax
16:12:05 <lightstep> funkmando: triangle has 3 parameters, you only supplied one
16:12:21 <lightstep> funkmando: so it returns a closure expecting the other 2
16:12:27 <funkmando> ah
16:12:41 <funkmando> so is there anyway to give a friendly error message if args are not 3?
16:12:52 <funkmando> i guess that's delving into IO though
16:13:25 <lightstep> triangle is an internal function to the program. it's not visible to the user
16:13:34 <dons> that's a type error -- you can't generally script it
16:13:53 <boegel> @type return
16:13:54 <lambdabot> return :: forall m a. (Monad m) => a -> m a
16:13:59 <dons> though it can sort of be done by oleg
16:14:23 <boegel> if I have a function of type [Int]
16:14:31 * everything can be done by oleg
16:14:38 <boegel> but the definition of that function requires using a do clause
16:14:58 <boegel> how can I return the result of the function without having to change the type to IO [Int] ?
16:15:26 <lightstep> what do you have in your `do' ?
16:16:13 <boegel> lightstep: I'm working on it :)
16:20:00 <dons> hmm. do chocolate-coated coffee beans and espresso make a healthy breakfast?
16:20:23 <boegel> getPList :: [Int]
16:20:23 <boegel> getPList = do
16:20:23 <boegel>              gen <- getStdGen
16:20:23 <boegel>              let
16:20:23 <boegel>                list = fst $ scramble gen [0..255]
16:20:24 <boegel>              return list
16:20:40 <boegel> off course, that doesn't work, since return list :: IO [Int]
16:21:00 <boegel> and I need the do because of the getStdGen
16:21:01 <dons> can't get around it safely, unless you stop using getStdGen..
16:21:05 <edwinb> what's the type of getStdGen?
16:21:16 <boegel> @type getStdGen
16:21:17 <lambdabot> bzzt
16:21:24 <edwinb> curses!
16:21:26 <boegel> @type Random.getStdGen
16:21:27 <lambdabot> Random.getStdGen :: IO System.Random.StdGen
16:21:32 <edwinb> ah, I see.
16:21:43 <dons> it returns a different value each time -- has to be IO, right?
16:22:02 <lightstep> dons: no, but yes
16:22:04 <edwinb> I suppose you could pass a seed around if you want safe random numbers...
16:22:10 <boegel> we'll, it returns the same value each time
16:22:16 <boegel> but it does need IO
16:22:52 <dons> beogel -- you could just insert an undefined, and then get your random values in a pass after parsing
16:23:05 <dons> so you .y file can stay pure
16:23:22 <boegel> dons: how do you mean, undefined ?
16:23:47 <dons> insert a dummy value, or use a Maybe [Int].
16:24:00 <dons> to avoid having to call an IO function while parsing
16:24:17 <boegel> dons: and where would the actual [Int] be inserted then ?
16:24:22 <dons> then, after you've built your abstract syntax, pass over it again inserting things like random numbers.
16:24:49 * boegel hesitates
16:24:49 <dons> let syn = parse tokens in do syn' <- insertRandoms syn
16:25:33 <dons> it's a fairly standard compiler-ish thing to do.
16:25:33 <dons> don't try to do all your compiling in one pass
16:26:01 <boegel> dons: problem is, it should be easy for anyone who wants to use my raytracer library to add extra functionality
16:26:24 <boegel> which includes creating a new parser with Happy
16:26:30 <dons> then I think your nonterminals will have to { return $ ... }
16:27:06 <dons> the idea of passing around seed values (or just an Int) seems tricky in happy
16:27:11 <duncan> boegel: dons advise is good, you usually want to parse into an expression tree, then evaluate it as a seperate pass
16:27:21 <lightstep> is there any code available for public consumption?
16:27:43 <lightstep> in the raytracer?
16:27:54 <duncan> boegel: that second pass can get a seed passed and so use random numbers ok
16:27:55 <boegel> lightstep: not yet
16:28:19 <dons> yep. duncan's right.
16:28:21 <boegel> duncan: I'm trying to figure out if I even need random numbers at all...
16:28:57 <boegel> because I think if I'd using a fixed [Int], it would provide any problems...
16:29:12 <duncan> boegel: perhaps you don't, you could just use the same seed value every time
16:30:57 <boegel> duncan: probably... I'm trying that now
16:35:15 <lightstep> good night
16:37:00 <fraxtal> Should this work? : foldr mod 30 [1..30] 
16:37:59 <boegel> fraxtal: foldr (mod 30) [1..30]
16:38:40 <fraxtal> That doesn't work
16:38:56 <boegel> @type mod
16:38:57 <lambdabot> mod :: forall a. (Integral a) => a -> a -> a
16:39:02 <fraxtal> foldr mod 30 [1..30]  gives me a division by zero error
16:39:54 <fraxtal> ERROR - Cannot infer instance   *** Instance   : Integral ([a] -> [a])   *** Expression : foldr (30 `mod`) (enumFromTo 1 30)
16:39:57 * boegel doesn't know then
16:40:01 <fraxtal> hmm
16:40:10 <wli> hmm
16:40:21 <boegel> fraxtal: are you sure you don't mean 'map' instead of 'foldr' ?
16:40:38 <fraxtal> Im just playing around with it
16:43:33 <boegel> is there any way to make Happy returns more usable error messages ? like what went wrong orso ?
16:43:39 <boegel> or is that quite hard?
16:44:09 <dons> the only way I know is to insert type sigs into all nonterminal decls
16:44:38 <dons> also, you can check the 'info' file produce by happy -i if the grammar is ambiguous
16:45:18 <dons> or, do you mean, at what point in parsing did the error occur?
16:45:31 <boegel> dons: the latter
16:47:11 <dons> have a look in the docs for "Handling Parse Errors"
16:47:45 <dons> you should be able to print at least the src loc of the token that caused the error
16:59:26 <boegel> w00, I got it working
16:59:31 <boegel> http://studwww.ugent.be/~kehoste/thesisPublic/website/
16:59:42 <boegel> see the most right image of the last update
17:02:39 <duncan> boegel: nice
17:02:53 <duncan> well done
17:06:42 <boegel> now to get the rest of the perlin noise textures working, and then I can build you a nice screenshot duncan :)
17:10:17 <duncan> :-)
17:23:01 * boegel should go to sleep...
17:23:09 <boegel> but I'm to damn excited :
17:23:11 <boegel> :)
18:05:26 * boegel goes to bed, and wishes everybody a good night
18:31:45 <wnoise> On the gender-neutral pronoun discussion earlier today:
18:31:47 <wnoise> http://en.wikipedia.org/wiki/Singular_they
18:32:11 <wnoise> I think using "they" is perfectly fine in most circumstances
18:32:27 <monochrom> Yes.
18:32:31 <dons> yup
18:41:41 <wnoise> I would appreciate any comments on http://haskell.org/hawiki/DimensionalizedNumbers
18:50:31 <dustin`> I'm hunting around the libraries.... what is the most painless way to interpret a string as a base 10 integer?
18:51:57 <Lunar^> @type read
18:51:58 <lambdabot> read :: forall a. (Read a) => String -> a
18:52:55 <monochrom> read "101" + 10   try this
18:54:14 <dustin`> yow, that's weird, and neat... weird "101" bombs, but the full expression works
18:54:45 <Lunar^> dustin`: it doesn't bomb
18:55:05 <Lunar^> dustin`: It just tells you that it don't know what the 'a' type should be
18:56:47 <dustin`> Ahh, okay... do different types implement some "readable" class, so that the appropriate parser is used?
18:57:01 <Lunar^> @info Read
18:57:02 <lambdabot> -- Read is a class
18:57:02 <lambdabot> class Read a where {
18:57:02 <lambdabot>     readsPrec ::
18:57:02 <lambdabot> 	Int -> String -> [(a, String)]
18:57:02 <lambdabot> 	{- has default method -};
18:57:03 <lambdabot>     readList :: String -> [([a], String)] {- has default method -};
18:57:05 <lambdabot>     GHC.Read.readPrec ::
18:57:07 <lambdabot> 	Text.ParserCombinators.ReadPrec.ReadPrec a
18:57:09 <lambdabot> 	{- has default method -};
18:57:11 <lambdabot> [4 @more lines]
18:57:29 <Lunar^> dustin`: *sigh* most Prelude types
18:58:04 <monochrom> read "101" alone bombs because there is insufficient context to deduce you want a number.
18:58:26 <monochrom> Consider read "True" && True
18:58:49 <Lunar^> @type asTypeOf
18:58:50 <lambdabot> asTypeOf :: forall a. a -> a -> a
18:59:05 <monochrom> Yes, once the desired type is known, the correct parser is invoked.
18:59:20 <Lunar^> read "True" `asTypeOf` True
18:59:29 <Lunar^> would also work
19:01:37 <dustin`> Okay, because you're forcing "a" to be bound to a specific type with the second argument, so read is then forced into a certain context...
19:03:13 <Lunar^> you got it :)
20:41:59 <shapr> Looks like I missed the math, economics, and politics discussion.
20:59:45 <Svrog> hi shapr
20:59:57 <shapr> hiya Svrog 
21:00:10 <Svrog> how goes it?
21:01:32 <shapr> It goes well, I'm reading the TMR articles I already have.
21:01:51 <shapr> How goes it with you?
21:02:13 <Svrog> tmr articles?
21:02:24 <shapr> The Monad.Reader, the Haskell eZine
21:02:54 <Svrog> not bad - im having a go at reimplementing the quadratic formula in joy
21:03:00 <Svrog> oh ok
21:03:25 <shapr> Ah, I do love Joy. One day I'll get around to implementing secretJoy, the parallel Joy.
21:04:31 <Svrog> well what im currently doing is implementing the thread combinator that would in theory (under a decent implementation of joy) run a number of different functions simoultaneously, each with its own copy of the stack
21:04:41 <Svrog> then combine the results
21:05:07 <Svrog> i got the idea from a post on the concatenative message board about the limitations of a 1 dimensional stack
21:06:04 <shapr> I do wish everything were first class in Joy, more like PostScript. I can't easily push succ onto the stack, only [succ]
21:06:34 <Svrog> you mean have something like symbols in scheme and lisp?
21:06:36 <shapr> One day, when I focus on concatenative languages again.
21:06:53 <Svrog> i dont know postscript
21:07:16 <shapr> Yes, more like that. PostScript is fun to play with. Especially since you can do evil things to your company workgroup printer with it.
21:07:37 <Svrog> haha
21:07:52 <shapr> Of course, my company printer is the inkjet in the next room, but...
21:09:29 <shapr> I get to learn LaTeX in the next coupla weeks.
21:10:23 <Svrog> by the way why would you want to push succ onto the stack? if you wanted to execute succ you could just push [succ] - a good compiler can easily optimize it - i cant think of any other uses where you'd really need to do something like that
21:10:57 <Svrog> i played with latex a few times but i always forget everything ive learned within a week of not using it hehe
21:11:03 <shapr> Because I'd like to dup succ, dup'ing [succ] is a cheesy hack.
21:11:04 <Svrog> mind you i never really used it for more then a few days
21:11:13 <Svrog> not really
21:11:19 <Svrog> [succ] is a program/quotation
21:11:40 <shapr> I think a language is defined by what is easy to do with that language. I like to be able to manipulate everything in a language as first class values.
21:12:10 <Svrog> hmm the problem with having succ on stack is that it's also a program.. but one that you can't uncons (or pop)
21:12:40 <shapr> I see the stack as a quotation too.
21:12:49 <Svrog> which is also a problem in the current implementation of joy if you uncons [succ] and then do it again on succ that ends up on stack
21:14:04 <Svrog> but everything in joy is first class - it doesnt have symbols so they cant be first class unless you rewrite joy to have something like symbols in lisp and scheme
21:15:21 <Svrog> im more annoyed with the fact that once you get something like succ onto the stack it's a bit of an oddity as it's not quite a quotation and also not a symbol..
21:15:50 <Svrog> hmm.. i guess you could argue that joy does have symbols because of that in which case symbols are not first class
21:16:17 <shapr> I like the fact that almost everything can be manipulated in Haskell. Epigram is even more so. In epigram there's not much difference between a type and a function.
21:16:30 <Svrog> what's epigram?
21:16:48 <shapr> It's a very cool dependently typed language. 
21:16:52 <shapr> http://www.dur.ac.uk/CARG/epigram/
21:17:35 <Svrog> interesting
21:19:27 <Svrog> the code looks a bit weird
21:19:33 <Svrog> what are all those !-----------! things
21:19:38 <shapr> It's far weirder and more interesting when you try it out.
21:19:51 <Svrog> hehe
21:19:53 <shapr> Those are type proofs, pretty much.
21:19:58 <Svrog> oh ok
21:20:25 <shapr> It's really unusual, very much worth diving into for a few weeks.
21:22:17 <Svrog> yeah it looks very interesting
21:23:25 <Svrog> reading the tutorial right now hehe
21:25:26 <shapr> it's 6am, time for me to sleep.
21:25:29 * shapr falls over
21:25:46 <Svrog> fair enough
21:25:50 <Svrog> cya later then
21:48:10 <autrijus> greetings lambdatrons.
21:51:30 <Svrog> hi
21:53:44 <dons> we love partial application!
21:53:54 <dons> we love type inference!
21:54:03 <dons> lambdatrons unite!
21:54:17 <autrijus> you have nothing to lose but your side effects!
21:54:43 <Svrog> hehe
21:55:00 <autrijus> and the Revolution is just around the corner!
21:55:41 <Svrog> i wish - everytime i start talking about functional languages at work everyone just gives me a weird look haha
21:55:53 <dons> join us or you will be coerced..
21:58:46 <Svrog> most people i know just seem happy enough with c++ that they dont want to even look at other languages.. and same when it comes to operating systems and unix clones - everyone seems happy with unix clones.. granted unlike programming languages there arent any reasonable alternatives for os-s just yet..
21:59:11 <Lemmih> Good morning, #Haskell.
21:59:18 <Svrog> morning
21:59:35 <Svrog> afternoon here :)
21:59:47 <autrijus> mmm .au?
21:59:50 <autrijus> 2pm here.
22:00:08 <Svrog> yeah australia
22:00:24 <Svrog> 5pm
22:01:45 <dons> hmm. maybe we should have a haskell.au conference
22:01:55 <dons> like the euro-haskell one recently
22:02:37 <dons> there's lots of interesting haskell research coming out of .au and .nz
22:03:10 <dons> http://www.haskell.org/hawiki/EuroHaskell
22:03:49 <Svrog> sounds like a good idea
22:04:36 <dons> though most of them would be a unsw and maquarie, with a few at melbourne uni. or are there more?
22:04:43 <dons> what about the west coast?
22:06:49 <dons> there's some at waikato, iirc
22:09:57 <dons> hmm. and there's a tiny group in singapore, I think
22:10:48 <dons> ah! they do teach it at anu
22:11:36 <dons> and monash
22:12:43 <Svrog> anu? must be new cause they didn't use to - i think they did at uc though
22:12:44 <dons> there you go, griffith uni too
22:13:11 <dons> the anu course was called "formal methods for software engineering", and they use hugs
22:13:14 <dons> weirdly enough
22:13:19 <Svrog> oh ok
22:13:22 <Svrog> interesting
22:14:23 <dons> and University of Western Australia too
22:14:42 <dons> so lots of haskell courses, but not too many researchers, I think
22:17:04 <dons> hmm. not too good when my own paper comes in at #18 on "haskell publications site:.au"
22:17:48 <Svrog> you in aus too?
22:18:00 <dons> yeah. sydney
22:18:06 <Svrog> cool
22:18:25 <Svrog> im in canberra
22:18:30 <dons> no one else (cept insomniacs like shapr) are awake at this hour, I think
22:18:39 <Svrog> shapr left
22:18:44 <Svrog> i think
22:18:49 <dons> yup
22:19:03 <dons> ah. there's a paper from UTS
22:19:40 <dons> still, doesn't inspire too much confidence in the size of the community.
22:20:53 <Svrog> yeah
22:21:05 <dons> shapr's in sweden .. which worries me when he goes to bed only a few hours before I do, here in the antipodes
22:21:42 <Svrog> why does that worry you?
22:22:09 <dons> his sleep habits get a bit wacked sometimes :}
22:25:17 <Svrog> oh right haha
22:25:45 <dons> Svrog: how did you get into Haskell programming?
22:25:57 <dons> if they didn't teach it at anu?
22:26:33 <Svrog> im actually an anu dropout :)
22:27:02 <Svrog> hmm.. i cant actually remember how i got into functional languages
22:27:12 <dons> long ago, or recently?
22:27:37 <Svrog> i started with caml - haskell was too hard to get into at first - from caml i went to scheme, then to haskell and now im mostly using caml again but only because of the compiler
22:27:59 <dons> why the compiler?
22:28:21 <Svrog> i find it fairly hard to squeeze good performance out of the haskell compiler
22:28:32 * dons replaces 50 lines of hand-unboxed Eq instances with a single "deriving Eq"
22:28:44 <Svrog> and yeah, its been a while since i dropped out - 2000 i think
22:28:59 <dons> yep, you have to read the library code for a while to get the hang of super-fast Haskell code
22:29:20 <dons> but it is possible -- see the ICFP competition this year, haskell came first and second
22:30:05 <Svrog> yeah i know its possible but its often not trivial for beginning and intermediate haskell programmers - i think im probably closer to intermediate
22:30:07 <dons> or yi -- the buffer code in that is pretty fast, and it loads much faster than vi or vim
22:30:28 <dons> yep. agreed. fast code is certainly an aquired art in haskell
22:30:47 <dons> up there with some of the type tricks
22:31:12 <dons> there's no good book on fast code, or systems programming  in Haskell, unfortunately
22:31:18 <Svrog> true
22:33:03 <Svrog> i dont intend to use caml much longer.. im working on my own language that's closest to joy and once thats finished im gonna be using that almost exclusively :)
22:34:01 <dons> cool!
22:35:30 <Svrog> yeah.. although.. almost everyone these days is writing their own language and usually they either never finish it or they do actually finish it but decide that it's not as good as they thought it would be... so maybe it wont be so cool once its finished.. if it's finished
22:35:32 <Svrog> but oh well
22:36:41 <dons> that's true. half the people in #haskell have a language or three hidden somewhere
22:36:49 <Svrog> yeah hehe
22:37:10 <dons> to do good languages seems to need groups and meetings and such like
22:37:19 <dons> can't just hack up C between 2 people anymore
22:37:25 <dons> all those libraries take work
22:37:25 <Svrog> yeah
22:37:43 <dons> and compiler optimisations..
22:37:50 <Svrog> ive redesigned mine and started from scratch at least 20 times
22:37:59 <dons> at least C-- will help with the backend work
22:38:13 <dons> no need to write code gens for all the stupid archs under the sun
22:38:50 <dons> and you can use things like twelf to encode and check type systems automatically
22:39:21 <dons> a defn of a type system in twelf automatically produces a type checker, and more if you're lucky
22:39:26 <Svrog> yeah - i have a hard time making a decision on whether i should write my own code generator or use something like c--
22:39:48 <Svrog> for now i decided to just finish an interpreter and then worry about the rest later once i rewrite the language in itself
22:39:56 <dons> I would definitely go for C-- if you're serious about generating machine code
22:40:10 <dons> generating C from there isn't too much more difficult either
22:40:55 <Svrog> well the problem is that my language needs dynamic code generation and im not even sure yet how different code generators would handle that
22:41:10 <dons> oh.. tricky
22:41:13 <Svrog> yeah
22:41:26 <dons> it _needs_ dynamic code generation?
22:41:31 <Svrog> yup
22:42:04 <Svrog> the thing is even if writing a compiler i'd still need an interpreter in it
22:42:12 <Svrog> if im*
22:42:19 <dons> for reification stuff?
22:42:41 <dons> or just for human interaction?
22:42:49 <Svrog> its more because of the way the language works
22:43:01 <Svrog> it allows you to write code that generates other code
22:43:06 <Svrog> quite easily too
22:43:59 <Svrog> have you ever heard of joy?
22:44:13 <dons> I have, but can't remember the details. was it runtime metaprogramming?
22:44:37 <Svrog> no it was a combinator based language - a bit like a purely functional version of forth
22:45:20 <dons> ok. but why all the runtime code generation stuff?
22:45:24 <Svrog> well arguably pure anyway.. it doesnt allow assignments but at the same time it's io appears non-pure although i've been convinced on the message board that it can be thought of as pure because of certain properties of concatenative languages
22:46:14 <Svrog> well my language also allows you to do meta-programming - it has no macros but the compiler itself should in theory try to evaluate as much of the program at compile time as possible
22:46:24 <Svrog> so the language itself becomes it's own macro language
22:46:43 <dons> compile time meta-programming. but you were talking about generating code at runtime, weren't you?
22:46:53 <Svrog> yes that too
22:46:54 <dons> "allows you to write code that generates other code"?
22:47:02 <dons> or is that at compile time?
22:47:06 <Svrog> im trying to think of an example..
22:47:45 <dons> my lack of Joy experience is obvious :)
22:47:48 <Svrog> no - run time code generation - i guess i could use closures but it would quickly get out of hand as there could potentially be too many of them in even medium sized programs
22:48:26 <dons> isn't runtime code generation by user code also runtime metaprogramming?
22:48:38 <dons> or is it used for something more subtle?
22:49:14 <Svrog> what do you mean?
22:49:40 <dons> I'm trying to work out in what way you want to do runtime code generation
22:50:02 <dons> is it like a JIT, or is it like, say, Template Haskell at runtime?
22:50:19 <dons> source-to-source or source-to-machine code?
22:50:52 <Svrog> source to machine code
22:51:11 <Svrog> im still trying to think of an example..
22:51:33 <dons> ok. cool. I've spent to much time recently with runtime metaprogamming (like TH at runtime).. :)
22:51:50 <Svrog> fair enough
22:52:29 <Svrog> i havent played with templates in haskell yet - i had a go at them for about half an hour once and gave up when i couldnt get them to work
22:52:32 <dons> so you have a bytecode or similar which you wish to compile on the fly?
22:53:04 <Svrog> yeah
22:53:20 <dons> $ ghci -fth
22:53:21 <dons> Prelude> $( [| 1 + 2 |] )
22:53:22 <dons> 3
22:53:52 <dons> i.e. at compile time evaluate the delayed expression "1+2" and splice it into the surrounding code
22:54:18 <dons> if you did that at runtime it would be like: eval "1+2"
22:54:50 <dons> that's the stuff I was wandering off onto :}
22:54:59 <Svrog> oh ok
22:55:26 <Svrog> yeah something like that - in fact a lot like the eval function in scheme/lisp
22:55:51 <dons> oh, ok. well that is essentially runtime metaprogamming, if I understand correctly
22:56:08 <dons> (we also have eval in Haskell too..)
22:59:05 <Svrog> yeah
22:59:34 <Svrog> eval in haskell? didnt know about that
23:00:08 <dons> :) Prelude> :t Eval.Haskell.eval
23:00:08 <dons> Eval.Haskell.eval :: forall a.
23:00:08 <dons>                      (AltData.Typeable.Typeable a) =>
23:00:08 <dons>                      String -> [Eval.Utils.Import] -> IO (Maybe a)
23:00:19 <Svrog> cool
23:00:29 <Svrog> does it actually compile stuff at runtime or just interpret it?
23:00:54 <dons> compile + dynamic linking
23:01:33 <Svrog> i still cant think of a good example.. however in joy one of the main and most commonly used combinators is 'i' which is essentially eval
23:01:57 <dons> > (eval "1+2::Int" [] :: IO (Maybe Int)) >>= print
23:01:58 <dons> Just 3
23:04:07 <dons> you can do printf at runtime this way (so the format string isn't static)
23:04:14 <dons> Printf> let f = printf "%10.4f\n"
23:04:18 <dons> Printf> f
23:04:22 <dons> <Double -> [Char]>
23:04:27 <dons> Printf> f $> (-987654321 :: Double)     ! []
23:04:27 <dons> -987654321.0000
23:04:34 <Svrog> oh ok
23:05:19 <Svrog> hmm.. what do you mean by the format string isn't static?
23:05:19 <dons> is 'i' anything like the I combinator in lambda calculus?
23:05:34 <dons> the format string to the above printf is compiled to machine code at runtime
23:05:45 <dons> so it could be supplied by the user
23:06:05 <dons> printf() is actually a String -> a compiler, that uses eval()
23:06:41 <dons> similar to printf in C, which is an interpreter function
23:07:16 <Svrog> well if you have a list/piece of code such as [3 dup] that will first place 3 on the stack and then duplicate it, you can execute the code but using the i combinator
23:07:22 <Svrog> [3 dup] i --> 3 3
23:07:39 <dons> hmm interesting.
23:08:10 <dons> so what would [3 dup] on its own do? return the value [3 dup] ?
23:08:47 <Svrog> for something a bit less trivial - here's one way to write an accumulator generator in joy:
23:08:59 <Svrog> acc == [uncons [+ dup] dip dup [cons] dip cons] dup [cons] dip cons
23:09:12 <Svrog> [3 dup] on its own is just a list
23:09:53 <dons> ok. that makes sense
23:10:06 <dons> kind of verbose syntax though :)
23:10:33 <dons> or, obfuscated by minimalism perhaps
23:10:44 <Svrog> yeah.. a bit hehe
23:10:48 <Svrog> that wasnt a good example..
23:10:53 <dons> kind of like writing in SKI combinators
23:11:25 <Svrog> i came accross it when it was trying to find an example.. wrote that ages ago in response to paul graham's challange: http://www.paulgraham.com/accgen.html
23:12:24 <Svrog> well it is a combinator based language.. but its not like writing ski combinators - its more like writing forth code except you have higher order functions
23:12:38 <Svrog> and no return stack
23:13:17 <Svrog> or rather no user-visible or accessible return stack
23:13:44 <dons> have't played with forth except in the FreeBSD booter
23:14:19 <dons> but I think I get the idea
23:14:45 <Svrog> its a cool language but it takes a while to pick up - you really have to take factoring to extremes to get something that is readable - lots and lots of little functions
23:15:00 <dons> yep
23:15:42 <Svrog> i try to use the same principle for writing joy functions.. ive written that accumulator generator ages ago before i started practising extreme factoring though so its not quite readable hehe..
23:17:17 <Svrog> i like not having or not being forced to use variables - thats also one of the things i like about haskell - that you can often avoid variables
23:19:11 <gzl> "joy functions"?
23:19:26 <Svrog> what about them?
23:19:29 <dons> like fmap ;)
23:19:44 <dons> or (.) and flip :P
23:20:03 <Svrog> yup hehe
23:20:12 <Svrog> and liftM
23:23:28 <Svrog> or liftM2 and liftM3 rather.. i found them extremely useful for eliminating variables out of parsec definitions :)
23:23:48 <dons> yep
23:23:57 <gzl> Svrog: just wondering what "joy maps" are
23:24:43 <Svrog> joy maps?
23:26:12 <gzl> oh sorry, "joy functions"
23:26:36 <Svrog> functions in programming language called joy
23:30:30 <gzl> ahh
23:30:30 <gzl> ok
23:38:13 <Svrog> http://www.latrobe.edu.au/philosophy/phimvt/joy.html
