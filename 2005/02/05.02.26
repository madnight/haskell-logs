00:00:04 <dons> go for it. let me know if anything breaks
00:00:15 <Leimy> it's been too long
00:00:25 <Leimy> I've forgotten the URL
00:00:31 <Leimy> and required stuffs :)
00:00:46 <dons> http://www.cse.unsw.edu.au/~dons/yi.html
00:00:50 <danb> the complex question is: what's the difference between (forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]) and (forall a. forall b. ((a -> b -> b) -> b -> b) -> [a])
00:00:54 <dons> you need hs-plugins-0.9.8 and ghc-6.2.2
00:01:04 <Leimy> thatnks
00:01:27 <danb> where the only difference is the nesting of forall b
00:01:39 <dons> hmm. you could ask ghci. let's see...
00:03:23 <Leimy> is there darcs for hs-plugins?
00:03:54 <danb> dons: what kinds of "asking" are you doing?
00:04:20 <dons> Leimy: nope, sorry. only cvs. just grab the tarball
00:04:31 <Lemmih> Wheee. I got my ClanLib binding working in GHCi (:
00:04:36 * Lemmih bounces.
00:04:40 <dons> danb: I'm constructing an expression let y = undefined :: big_type_1
00:04:52 <dons> and then trying to see if: let x :: big_type_2 = y works.
00:04:53 <danb> dons: then see if ghci simplifies the type?
00:04:59 <dons> that too.
00:05:08 <danb> ah, testing unification?
00:05:11 <dons> yeah
00:06:14 <dons> got it. they're the same :)
00:06:19 <danb> which two?
00:06:30 <dons> Prelude> let x = undefined :: forall a. forall b. ((a -> b -> b) -> b -> b) -> [a]
00:06:33 <dons> Prelude> let y :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a] = x
00:06:36 <dons> Prelude> :t y
00:06:38 <dons> y :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
00:06:41 <dons> Prelude> :t x
00:06:43 <dons> x :: forall a b. ((a -> b -> b) -> b -> b) -> [a]
00:06:58 <danb> hmm
00:07:12 <dons> I wouldn't have been able to write y = x if they weren't equivalent, right?
00:07:24 <danb> can you try the same with (forall a. (forall b. b) -> a) and (forall a b. b -> a)?
00:07:30 <danb> i'm pretty sure
00:08:06 <dons> hmm.
00:08:07 <dons>     Inferred type is less polymorphic than expected
00:08:07 <dons>         Quantified type variable `b' escapes
00:08:07 <dons>         Expected type: b -> a
00:08:07 <dons>         Inferred type: (forall b1. b1) -> a1
00:08:09 <dons>     In the definition of `y': y :: forall a b. b -> a = x
00:08:14 <danb> yeah. i get that too
00:09:08 <dons> this is a fun game.
00:09:13 <danb> :)
00:09:36 <dons> hmm. I wonder if the other way around works.
00:10:05 <dons> ah ha!
00:10:09 <dons> Prelude> let x = undefined :: (forall a b. b -> a)
00:10:09 <dons> Prelude> let y :: forall a. (forall b. b) -> a = x
00:10:54 <danb> hmm
00:11:03 <dons> you can always tighten the constraints on the type
00:11:04 <danb> well, i verified your first result
00:11:08 <danb> interesting...
00:11:51 <danb> !
00:11:52 <danb> neat
00:12:52 <danb> so by moving the forall out of scopes, we can transform rank-n types to rank-m types, where m < n
00:14:33 <danb> so does this mean that a rank-n type is a subset of such a transformed rank-m type? (again, where m < n)
00:15:49 <dons> I'm not sure of the rules of rank-N.
00:16:18 <danb> i'm just going by the definition given in that paper and our recent experiment
00:17:00 <danb> i don't think i understand higher-order types yet
00:17:00 <dons> yeah, I don't want to claim anything though, as I'm likely to be surprised by some subtle rank-N issue :)
00:17:07 <danb> hehe. yeah
00:26:26 <danb> dons: no, what i said is backwards
00:26:39 <Leimy> dons: how do I set the Keymap again?
00:26:56 <danb> the higher-rank type should subsume the lower-rank type
00:29:21 <danb> which makes sense, because the lower-rank types are more constrained their higher-rank counterparts
00:29:31 <dons> Leimy: ./yi-inplace --as=nano is one way.
00:29:41 <dons> another is to set it in ~/.yi/Config.hs
00:29:49 <Leimy> oh the emacs one isn't working at this time?
00:29:57 <Leimy> I thought I'd missed something
00:30:12 <dons> nope. needs an emacs user to get hacking!
00:30:21 <Leimy> heh
00:30:30 <danb> <- not it
00:30:33 <danb> ;)
00:30:52 <dons> danb: yep, on subsumption. sounds right.
00:32:01 <dons> time for some tasty lentils
00:47:28 <musasabi> And so my old irc-machine is being updated.
00:47:53 <musasabi> Lemmih: weak symbols are a real problem for C++ + ghci on linux.
00:56:28 <Asta> why is there now MaybeT?
00:56:33 <Asta> s/now/no
00:57:50 <shapr> good morning #Haskell!
00:58:10 <Asta> good morning! you almost missed my question!
00:58:31 <Asta> "why is there no MaybeT?"
00:59:43 <shapr> My first guess is that if ErrorT uses Either, then you can use that instead.
01:01:16 <glimming> morning
01:01:21 <Asta> Yeap I thought about that
01:01:35 <Asta> but that would also justify not haveing Maybe at all...
01:01:44 <Asta> s/haveing/having
01:24:26 <Lemmih> MaybeT?
01:32:23 <shapr> LemmihT!
01:34:01 <musasabi> type MaybeT a = ErrorT a () ; runMaybeT c = runErrorT c >>= (\v -> return (either Just (const Nothing) v))
01:34:12 <musasabi> or something similar.
01:38:54 <Lemmih> musasabi: I've mail SyntaxNinja about better Cabal support for C++ bindings.
01:41:11 <Lemmih> s/mail/mailed/
01:43:21 <Cale> Lemmih: I found the start of your recent post amusing: 'During my ongoing research on "doing whatever I feel like"'
01:43:53 <Lemmih> (:
01:55:46 <dons> yes. that was good :)
02:10:07 <Oejet> Hello, boegel.
02:11:12 <boegel> hey Oejet
02:13:01 <Oejet> I got a good start at learning the FFI yesterday. :-)   This evening I will make a Bzip2 bindning if it hasn't been done before.
02:15:22 <shapr> yay!
02:15:58 * boegel bounces
02:16:18 * Oejet tapdances.
02:16:29 * boegel dances
02:19:21 * Oejet goes back to reading about duality theory and sensitivity analysis in the context of operations reseach.
02:19:25 <Oejet> Sigh.
02:20:34 <musasabi> Lemmih: currently I build C++ with Cabal.
02:21:11 <musasabi> Lemmih: the trick is to have a hook doing *.cc -> *.s and use the *.s as c-sources.
02:21:52 <Lemmih> musasabi: And that works with GHCi?
02:22:38 <musasabi> Lemmih: with ghci weak symbols are the showstopper.
02:24:23 <Lemmih> Yes, then you have to build a .so library which I want Cabal to support.
02:26:38 <musasabi> how does the so help?
02:26:47 <musasabi> because you still need the original C++ so.
02:26:58 <musasabi> and that contains weak symbols, which kill the ghci linker.
02:27:22 <Lemmih> The original C++ library contains weak symbols?
02:28:02 * Lemmih haven't encoutered that before.
02:32:30 <Lemmih> s/haven't/hasn't/
02:32:56 <Lemmih> When are they used? Neither ClanLib nor wxWidgets seems to have 'em.
02:33:39 <musasabi> I found 50+ such files by a quick find+nm+..
02:36:16 <musasabi> Lemmih: http://youzen.b2.fi/~musasabi/a.txt contains a quick list.
02:36:51 <musasabi> and the command to produce such a list.
02:37:12 <musasabi> (that can be buggy)
02:38:05 <Lemmih> But GHCi doesn't have a problem with libm, libGLU or libstdc++.
02:40:59 <Lemmih> Are you sure weak symbols are a problem in .so files?
02:54:19 <musasabi> Lemmih: I remember it dying with libfltk and weak symbols.
02:56:11 * Lemmih doesn't have any problem loading libfltk.
02:56:31 <Lemmih> *problems.
02:58:24 <Itkovian> boegel: I've got a whole shitload of remarks :-)
02:58:39 <Itkovian> boegel: do you happen to have a fax machine?
03:00:26 <Oejet> boegel: How's TMR article going?
03:05:47 <boegel> Itkovian: no I don't
03:05:52 <boegel> Oejet: almost finished
03:06:16 * boegel if off to grab lunch
03:06:21 <boegel> s/if/is
03:10:42 <musasabi> Just released a new version of network-alt with hugs support.
03:18:51 <shapr> musasabi: mind if I mention network-alt on sequence? or would you rather write a short blurb about it?
03:20:56 <musasabi> shapr: if it works for you feel free to mention it, I am waiting for a few days for bugs before posting to libraries.
03:23:09 <shapr> ok
03:23:19 <shapr> Do you have HUnit or QC tests?
03:25:26 <musasabi> shapr: test directory contains test cases. (cd test && make && ./test should be enough to test basic functionality)
03:25:54 <musasabi> shapr: unit testing network library is kind of hard as everything is in IO.
03:26:38 <shapr> yeah, true.
03:26:50 <shapr> Too bad there's no decent intro for QCm
03:27:32 * shapr considers that for a future TMR n00b column
03:28:22 <musasabi> QCm would help a little but that wouldn't make things automatic.
03:28:53 <shapr> What would it leave out?
03:29:00 <musasabi> because the results of the tests are related to external interfaces.
03:29:34 <musasabi> e.g. the result of resolving a name depends on the OS and external nameservers.
03:30:15 <shapr> true, but you could at a minimum test against a call to the host program
03:30:25 <musasabi> also most of the bugs I have catched have been related to massive concurrency + timings.
03:30:41 <shapr> I've wondered why that's not used in GHC, like testing against dc for math.
03:31:16 <musasabi> that cannot be used with windoze.. (have to find a machine to get working windows support)
03:32:08 <shapr> True, but might find a bunch of bugs :-)
03:32:37 <shapr> Oh, did I already ask you about declarative protocol languages as they relate to Antony Courney's Fruit thesis?
03:33:11 <shapr> I think we did talk about building network protocols with a bnf-like spec.
03:33:31 <musasabi> yes, the problem being state.
03:33:33 <shapr> I should really keep notes on all my crazy ideas since I can't seem to keep the status in my head.
03:33:45 <shapr> What was the problem with state?
03:34:05 <musasabi> e.g. lenght prefixed fields.
03:34:22 <shapr> that works in Parsec
03:34:25 <musasabi> if you are happy with something like parsec then it is not too gard.
03:34:28 <musasabi> *hard
03:35:22 <shapr> I think it wouldn't be too hard to automatically turn a bnf-like spec into an arrows output that works. Arrows being unoptimized in GHC, it would be rather slow.
03:35:50 <shapr> But you would be able to output implementations that use select/blocking threads/STM/whatever.
03:36:50 <shapr> ok this time I'm writing down the results of this discussion :-)
03:37:29 <shapr> musasabi: do you think such a thing would be useful?
03:37:34 <musasabi> shapr: kind of hGetContents + parsec but with output too.
03:37:48 <shapr> yeah
03:38:05 <shapr> With the added benefit that you could derive a bunch of tests for protocols as well.
03:38:15 <musasabi> that sounds nice.
03:38:27 <shapr> The Oulu guys who broke asn.1 used a tool sort of like that.
03:39:05 <shapr> specifically looking for illegal state paths that worked anyway
03:41:49 <musasabi> yes, that is going to be a problem in practise.
03:42:14 <musasabi> protocol specifications are too liberal and can lead to problems.
03:42:41 <musasabi> my crossbuild hugs does not work on wine :-(
03:43:20 <shapr> So IETF could use a real BNF protocol spec at least.
03:46:14 <musasabi> I think that it could be useful, but seems kind of hard.
03:46:30 <musasabi> shapr: What about using TH to generate the code?
03:46:39 <shapr> sure, sounds fine to me.
03:47:00 <musasabi> shapr: then it would be simple to create monadic parser / marshaler.
03:47:37 <shapr> The reason I'd like Yampa is that you could build an entire tcp/ip stack that way.
03:47:54 <musasabi> and since the code would be generated by TH most of the potential arrow optimizations could be done there.
03:47:59 <shapr> oh, good point!
03:48:35 <shapr> I do so wish for TH input/output/syntax.
03:49:00 <xerox> hi!
03:49:03 * musasabi wishes for a good TH tutorial.
03:49:22 <shapr> 1. slurp in a given module and give me the TH datatypes for it. 2. output generated code as an .hs file. 3. give me syntax to do the whole thing sort of like monadic or arrow syntax.
03:49:32 <shapr> Well, I'm working on a very basic TH tutorial right now.
03:50:03 <shapr> for tmr1
03:50:08 <shapr> y0 xerox
03:50:18 <musasabi> nice, for the TH2? (ghc6.4 variant)
03:50:23 <shapr> yes, for ghc6.4
03:51:06 <shapr> So far my tutorial is just a step by step demo of what the original paper describes, but I try to keep it all coherent, and do it all with 6.4.
03:52:02 <shapr> Can you think of any simple but instructive demos I could add?
03:56:30 <musasabi> maybe, class Foo a where foo :: a -> Bar, th_function :: Bar -> (Foo a => a -> b) -> b, which would automatically newtype and create an instance each time it is called.
03:56:35 <Lemmih> I got some semi-ugly but useful examples.
03:56:42 <musasabi> (not sure whether that is simple to do)
03:56:44 <shapr> Lemmih: can you point me to them?
03:57:10 <shapr> musasabi: I don't quite get it.
03:57:28 <Lemmih> shapr: http://www.scannedinavian.org/repos/hacanon/src/Foreign/Hacanon/Common/THUtils.hs
03:57:34 <shapr> thanks
03:58:59 <musasabi> let's say Bar=Int. Then class Foo a where foo :: a -> Int. th_function :: Int -> (Foo a => a -> b) -> b.
03:59:02 <Lemmih> 'puts' is probably the most interesting.
03:59:46 <Philippa> shapr: feel free to rip code from my article
04:00:01 <shapr> thanks, it's entirely possible I will :-)
04:00:38 <musasabi> then e.g. th_function 3 some_fun would be expanded to data T1 = T1, instance Foo T1 where foo _ = 3, some_fun T1
04:00:56 <musasabi> that is more or less implicit configurations.
04:03:19 <shapr> My brain is just not moving yet today, that's what I get for sleeping four hours more than usual. Maybe exercise will jumpstart (ha) my brain.
04:04:39 <Heffalump> BOUNCE!
04:07:03 <musasabi> have to go shopping..
04:27:44 <mayhem> yop
04:29:18 <mayhem> I am studying monads semantic in 'generalising monads to arrows' by J.Hugues and I have some problem with understanding of the binding operator, how are you supposed to read in natural langage something like :
04:29:24 <mayhem> class Monad m where
04:29:28 <mayhem> return :: a -> m a
04:29:48 <mayhem> (>>=) :: m a -> (a -> m b) -> m b
04:29:54 <mayhem> the second line beeing the binding operator
04:30:16 <Heffalump> I'm not sure what you mean by 'in natural language'
04:30:18 <mayhem> I understand what curryfication is, but I have some troubles with it when it comes to monad I feel
04:30:27 <Heffalump> >>= is a sequencing operator
04:30:28 <xerox> If I give you a box of apples (m a) and for each apple, you will give me a box of blueberries (a -> m b) then I can get a box with all the blueberries together (m b).
04:30:49 <xerox> (c) Cale <http://www.haskell.org/hawiki/MonadsAsContainers>
04:31:05 <Heffalump> xerox: you've got the people the wrong way round
04:31:21 <xerox> Whoops?
04:31:36 <Heffalump> If you give me a box of apples (m a) and a promise to give me a box of blueberries for each apply I give you (a -> m b), then I can get a box of all the blueberries together (m b)
04:31:57 <xerox> Heffalump, it's on @wiki MonadsAsContainers!
04:32:10 <Heffalump> doesn't make it right :-)
04:32:18 <xerox> Correct it :D
04:32:33 <Heffalump> do you agree with my correction?
04:32:44 <xerox> I think so.
04:33:01 <xerox> The guy who gives blueberries is lazy, obviously ;)
04:33:54 <mayhem> its strange that a box of apple isnt traded for a box of blueberries
04:34:00 <mayhem> thats robeery
04:34:04 <mayhem> monads sucks !
04:34:05 <mayhem> ;)
04:41:38 <Lemmih> Why are you reading "Generalizing Monad to Arrows" if you wanna learn about monads?
04:42:05 <xerox> mayhem, try with:
04:42:12 <xerox> @wiki MonadsAsContainers
04:42:12 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
04:42:29 <xerox> And.. <http://www.nomaware.com/monads/html/>
04:43:01 <mayhem> xerox im reading it, it seems really good, thanks
04:43:35 <xerox> Btw, I started understanding monads with "Generalizing Monads to Arrows" too :)
04:43:52 <mayhem> Lemmih : I want arrows, but before understanding why monads are less modular than them, I need to have a correct view on monads ..
04:45:37 <musasabi> back..
04:45:41 <Darius> mayhem: It's not a modularity issue.  Monads are simply less general structures than arrows.
04:46:26 <Darius> mayhem: But unless your thingy really isn't a monad (and is an arrow), you don't really benefit from treating it as an arrow.
04:47:05 <mayhem> Darius okay .. i still want to read that paper which seems really good and interresting
05:16:42 <mayhem> what are the recent type system related advances in haskell ? is there a page about this on haskell.org ?
05:18:51 <jlouis> does GHC6.2.2 include Edison by default?
05:18:59 <jlouis> mayhem: GADTs?
05:19:00 <Heffalump> mayhem: GADTs
05:19:10 <jlouis> Generalised Algebraic Data Types
05:19:30 <mayhem> thx jlouis
05:20:22 <jlouis> The idea is not new, though. It has similarities to ``refinement types'', studied in 1995 AFAIR
05:20:47 <jlouis> I read the paper and had enormous enlightenment instantly ;)
05:20:59 <jlouis> Probably on SPJs homepage
05:21:24 <Darius> mayhem: You could just read the extensions section of GHC's user-guide.
05:22:00 <Darius> jlouis: I believe it does, but it would be in the non-heirarchical libraries and you probably have to import a package.
05:27:21 <jlouis> -package data it seems
05:29:48 * TheHunter wonders if '((a -> r) -> r) -> Direct r a' is an acceptable type of shift or if it has to be '((a -> r) -> Direct r r) -> Direct r a'
05:37:46 <Darius> I'd say the latter assuming what you're talking about and what the things are are the same as what I think they are.
05:41:12 <TheHunter> i think both versions behave the same, but i'm not sure (and maybe even both are wrong). But you never know what implicit parameters exactly do.
05:41:49 <TheHunter> type Direct r a = (%ans :: Prompt r) => a
05:57:31 <jlouis> TheHunter: shift/reset?
05:58:13 <TheHunter> jlouis, yep.
05:58:40 <TheHunter> their implementation makes my head explode.
05:58:58 <jlouis> pencil + paper
05:59:12 <jlouis> it is the trick I use
05:59:34 <TheHunter> thing is, I implemented those babies in haskell using linear implicit parameters and unsafe stuff.
05:59:42 <jlouis> helps getting parts of the explosion down to paper.
05:59:48 <jlouis> hehe
06:00:20 <TheHunter> they seem to do fine, the only little annoyance are higher order functions.
06:00:34 <TheHunter> and I need DeepSeq for reset.
06:01:40 <TheHunter> for example I need map' :: (a -> Direct r b) -> [a] -> Direct r [b] (implementation exactly like map), otherwise it'll give false results
06:08:33 * esap wonders if he should use reallyUnsafePtrEquality# :-)
06:09:12 <TheHunter> hasn't that been renamed to unsafePtrEquality#?
06:09:16 <Heffalump> surely that's less unsafe than unsafePerformIO
06:09:57 <esap> TheHunter: Hmm.. then I don't know where it is, GHC.Exts.reallyUnsafePtrEquality# exists.
06:10:40 <TheHunter> ohh, sorry, must have been wrong then.
06:10:41 <esap> I'm trying to build an inverse to \x -> (x,x) :-)
06:10:59 <lightstep> what about fst?
06:11:22 <esap> lightstep: That doesn't do the correct thing. It shouldn't ignore the second component of the pair.
06:11:37 <tromp> how about snd?
06:11:43 <tromp> :-P
06:11:48 <esap> both components must be used.
06:11:50 <lightstep> if you know that they are the same, you shouldn't care
06:12:00 <Heffalump> f (x,y) | x==y = x
06:12:02 <esap> right. But you need to know they are the same.
06:12:05 <Philippa> if (fst foo == snd foo) then fst foo else <preferred error technique>?
06:12:12 <shapr> man I *love* unicycling.
06:12:41 <esap> Ok, another problem is, I need to use it in code that can't use type class constraints to resolve (==)
06:12:51 * xerox defends skateing in this unicycling channel, yay
06:13:18 <Heffalump> oh, mine relies on Eq
06:13:27 <Heffalump> instance Eq a where
06:13:33 <Heffalump>   a == b = unsafePtrEquality a b
06:13:34 <shapr> xerox: actually #unicycling is the unicycling channel :-)
06:13:53 <ibid> xerox: is the channel good at unicycling?
06:14:03 <xerox> ibid, don't you think? ihih.
06:14:03 <esap> Heffalump: hmm.. ok but that might be pretty dangerous.
06:14:36 <Heffalump> I wasn't serious :-)
06:15:29 <esap> Ok, the situation is, I want to build Adjunction instance for the diagonal functor (copying).
06:15:51 <esap> That has some trouble, because the product category is hard to do...
06:16:25 * xerox 's teatime.
06:16:48 <lightstep> the function you want isn't compatible with haskell semantics, i think. like bottom-avoiding functions
06:17:43 <esap> I figured that out already :-) INow I'm looking at whether GHC has some extensions for it :-)
06:18:21 <esap> I already found that I need to implement Hom-sets for the product category separately.
06:18:33 <lightstep> are you sure you really want it? you can make your CT library require that all the types are member of some class you define, like Dynamic does.
06:19:22 <esap> hmm... interesting idea.
06:22:40 * Darius came across a paper formalizing a language of "universal properties" mainly centered around representability.  Representability may be a better way to go as it should allow most things to be reflected into Set.
06:24:30 <lightstep> we'll lost most of the free theorems
06:24:54 <lightstep> s/st/se/
06:32:05 <esap> I don't seem to be able to build counit of Copy(_) -| _ /\ _.
06:34:40 <esap> Even with GADTs, it seems very hard.
06:35:36 <Darius> Well, what's the code and/or framework?
06:35:46 <Steve_p> Does haskell have something equivolent to "null?" in scheme?
06:35:56 <shapr> @type null
06:36:02 <shapr> lambdabot: allo?
06:36:03 <lambdabot> null :: forall a. [a] -> Bool
06:36:03 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
06:36:17 <shapr> Steve_p: null [] == True ; null _ == False
06:36:39 <Steve_p> Great!  Thanks!
06:36:54 <esap> Darius: I have an Arrow type that represents Hom-sets in CxC, something like: data ProductA a b where { CrossA :: (a -> c) -> (b -> d) -> ProductA (a,b) (c,d) } You can add any other constructors to that type.
06:36:55 <shapr> Is that what you're looking for? test for an empty list?
06:37:15 <esap> Darius: as longs as you can implement Functor and Adjunction for it.
06:37:47 <esap> Darius: I have to generalize Functor class such that it explicitly specifies the categories of the functor in terms of the arrow types
06:38:38 <esap> Darius: class (ArrowA arr, ArrowA arr') => FunctorA f arr arr' | f arr -> arr' where { fmapA :: arr a b -> arr' (f a) (f b) }
06:39:16 <esap> Darius: class ArrowA arr where { idA :: arr b b ; (>>>>) :: arr a b -> arr b c -> arr a c }
06:39:44 * Darius often uses (>->) for sequential composition.
06:40:55 <esap> Darius: and generalized version of Adjunction: class (FunctorA path arr arr', FunctorA space arr' arr) => AdjunctionA path space arr arr' | path -> space, space -> path where { leftAdjunctA :: arr' (path a) b -> arr a (space b) ; rightAdjunctA :: arr a (space b) -> arr' (path a) b ; unitA :: arr a (space (path a)) ; counitA :: arr' (path (space b)) b }
06:44:18 <esap> Darius: The problem with counitA for the adjunction is that the type 'b' needs to be a pair. But it must also be fully universally quantified.
06:46:58 <esap> Darius: I have also defined Copying functor like this: data CopyF a where { UnitCopyF :: a -> CopyF (EitherF a) ; CopyF :: a -> a -> CopyF a }
06:47:35 <Darius> esap: The issue seems to be that you have no way to say that the objects in the adjunction belong to a particular category.
06:48:33 <esap> Darius: true. Hmm...
06:49:41 <esap> Darius: I suppose that would be kind annotations :-)
06:49:54 <esap> Darius: But there is no product kinds :-)
06:50:22 <esap> Hmm.. maybe you can build them...
06:52:08 <esap> Hmm.. maybe (* -> * -> *) -> * will do? The argument is the arrow type?
07:01:17 <shapr> Dang, can't I put an url into a Drupal Poll?
07:02:42 <shapr> suck, I want to link to Fritz Ruehr's Evolution.
07:03:10 <Darius> Which Poll?  On sequence.complete.org?
07:04:08 <tromp> what's the type of 1 in (1/1) ?
07:04:41 <chucky> @type (1/1)
07:04:43 <lambdabot> (1/1) :: forall a. (Fractional a) => a
07:05:32 <chucky> but that doesn't say anything about the type of any of the 1:s, which I would think is Num a
07:06:10 <Darius> @type (/)
07:06:12 <lambdabot> (/) :: forall a. (Fractional a) => a -> a -> a
07:06:40 <shapr> hej chucky! ltns!
07:06:41 <tromp> let a  = 1 :: Word64
07:06:48 <shapr> Darius: yes, on sequence
07:06:59 <tromp> how can you compute a/a ?
07:07:21 * shapr submits the poll anyway, no matter how silly...
07:07:26 <chucky> oh of course you should look at the type of (/). Silly me. :)
07:07:34 <chucky> Hey shapr, ltns indeed. :)
07:07:47 <tromp> oh, i got it:(
07:07:53 <tromp> (fromIntegral a)/(fromIntegral a)
07:08:12 <esap> Darius: It I figured it out correctly, you can express the constraint that one object is in some category using type class constraints.
07:08:18 <esap> Darius: s/It/If/
07:10:06 <esap> Darius: class ProductCat obj a b where { .. } data Object a where { ProductObject :: (ProductCat obj a b) => (a,b) -> Object obj }
07:10:48 <shapr> As for content on sequence.complete.org, is it just me, or do I talk too much?
07:12:18 <shapr> hoi Jan_w
07:12:47 <Jan_w> hoi sh10151
07:12:53 <Jan_w> hoi shapr i mean
07:13:10 <Jan_w> namecomleting :)
07:14:36 <shapr> hoe gaat het met jou?
07:14:38 <samc> if you didn't who would?
07:14:59 <shapr> samc: everyone else?
07:15:23 <shapr> samc: I do worry that I write so much that it stop other people from writing.
07:16:30 <samc> perhaps, but I'd bet not (but what do I know)
07:16:43 <shapr> I don't know either.
07:17:39 <chucky> you'd have to talk quite a lot to silence most Haskell hackers I know. :)
07:17:58 <kosmikus> shapr: better you than some others
07:19:57 * Igloo looks around nervously  :-)
07:22:21 <tromp> how do you write the function that subtracts 1?
07:22:31 <Igloo> \x -> x - 1
07:22:38 <tromp> can u do it pointfree?
07:22:45 <samc> perhaps ask others to post if you think something of theirs is worth posting
07:22:49 <Igloo> flip (-) 1
07:23:01 <shapr> tromp: (1-) ?
07:23:14 <Igloo> That's subtracts /from/ 1, shapr
07:23:20 <shapr> er, right.
07:23:29 <bloomberg> is there any way to reference a column in a 2D array in haskell?
07:23:39 <shapr> I tend to use bibtex.
07:23:43 * shapr snickers evilly
07:23:59 <tromp> i tried (`(-)`1)
07:24:11 <tromp> but get parse error:(
07:24:15 <shapr> bloomberg: Do you want to just pull all the values? or what?
07:24:22 <chucky> whoa!
07:24:24 <bloomberg> yeh in a list if poss
07:24:26 <chucky> it just started snowing
07:24:30 * Igloo campaigns for ~ being the negation unary operator in Haskell 2
07:25:04 * shapr champagnes for Haskell 2 *NOW*
07:25:32 * ozone champagnes for Haskell XP Media Centre Super Turbo Hyper Fighting Champion FX 68000 Edition
07:26:09 <chucky> ozone: Shouldn't there be a .NET in there somewhere? :)
07:26:22 <ozone> chucky: hmmm, after giving that much thought ... no :)
07:26:54 <chucky> fair enough. :)
07:27:11 <ozone> it has XP in there, what else can you ask for?
07:28:58 <TheHunter> @type subtract 1
07:28:59 <lambdabot> subtract 1 :: forall a. (Num a) => a -> a
07:29:05 <bloomberg> shapr: maybe define a function to return a column as an array using ixmap
07:29:48 <TheHunter> i guess the impossibility of using (-) in a section is the reason wjy subtract was put into the prelude.
07:31:56 <chucky> Daan Leijen pointed out that any operator you implement should also be available as a regular function. I tend to agree with that, so that's reason enough for me to have subtract in the prelude
07:32:26 <chucky> it's good for documentation, if nothing else. :)
07:35:56 <musasabi> evening
07:36:05 <musasabi> walking on sea-ice is fun.
07:36:39 <musasabi> shapr: haskell2 would be nice..
07:37:09 <musasabi> shapr: but standardisation is *hard*, look at the time-library discussion @ libraries...
07:37:42 <shapr> yeah, true
07:38:08 <tromp> my program gives stackoverflow:(
07:38:59 <tromp> i want to make a histogram of values in a list, using
07:39:02 <chucky> I think that if we want a Haskell 2 within a reasonable time frame, we probably need to "split" the standard into Haskell 2 and Haskell 2 Libraries, where the libraries would have a much faster release cycle than the language itself
07:39:03 <tromp> cntElems b a = accumArray (+) 0 b $ a `zip` (repeat 1) :: Array Int Int
07:39:30 <tromp> but if you try it on a long list like
07:39:36 <lightstep> Scheme 7 will be out before Haskell 2
07:39:39 <tromp> cntElems (loss,win) (replicate 9999271 1)
07:39:50 <tromp> it gives stack overflow
07:41:12 <tromp> any simple way to avoid that?
07:42:47 * musasabi would like to have a haskell2 where Strings can be instances of classes.
07:42:51 <Darius> lightstep: That isn't really saying much.  Haskell 2 will be the sixth version of Haskell.  R7RS will be the 7th of Scheme.  However, Scheme is twice as old as Haskell.
07:42:57 <araujo> Good morning.
07:43:07 <Darius> tromp: Which implementation are you using by the way?
07:43:17 <tromp> ghc
07:43:24 <shapr> musasabi: sea-ice sounds nifty.
07:43:29 <lightstep> Darius: actually, R6RS is Scheme 7 (scheme being revised 6 times)
07:43:52 <Darius> lightstep: You're right, but my point still holds.
07:44:10 <chucky> tromp: you can try running the program with for example: ./program +RTS -K4M which would make the stack 4 megabytes large
07:44:12 <TheHunter> chucky, subtrace = flip (-), so there's actually a difference. That aside, you can use every operator as a function if you want, so there should be no reason to further pullute the namespace.
07:44:27 <tromp> even 16m was not enough, chucky
07:44:33 <musasabi> btw anyone have experience with Twelf ?
07:44:42 <ozone> i'm sure oleg can reconcile the use of - as unary negation and - as binary subtraction via type classes somehow
07:44:46 <tromp> i want to avoid this excessive stack behaviour anyway
07:44:48 <ozone> let's disguise it as a homework question
07:44:56 <shapr> Oleg can do anything. He's a superhero.
07:45:15 <chucky> thehunter: Ah ok. I didn't know there was a difference between them
07:46:00 <ozone> "dear sir, i am trying to do an assignment which is how to use - as both subtraction and negation!  what do i do?"
07:46:07 <tromp> anyone know where to find the source of accumArray?
07:46:11 <ozone> -> problem solved
07:46:27 <lightstep> what does the permisson "-rwxrwSrwt" mean?
07:46:44 <Darius> It's in the heirarchical libraries, go to www.haskell.org/ghc and look for the web CVS access
07:46:57 <shapr> I think it's a socket that anybody can access?
07:47:00 <musasabi> tromp: Data.Array.Base
07:47:09 <ozone> lightstep: that the directory is group setgid without group write access
07:47:22 <ozone> (which is a bit pointless, i think, unless i'm missing something)
07:47:25 <tromp> that's not in http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
07:47:37 <lightstep> i'm having trouble with my fstab
07:47:38 <ozone> oh, and the t means only the person who created a file in that dir can delete it, like /tmp
07:47:43 <shapr> lightstep: how so?
07:47:45 <Igloo> without group execute, you mean
07:47:54 <tromp> oh you mean in my filesystem?
07:47:58 <ozone> Igloo: oh, indeed.  so, it's not pointless :)
07:48:04 <lightstep> i blindly changed smbfs to cifs
07:48:10 <Igloo> No, but it is somewhat odd
07:48:22 <ozone> yes, it's very uneven
07:48:46 <Igloo> Even if it was write it wouldn't be pointless, anyway
07:48:59 <Igloo> Oh, or maybe it would
07:49:04 <TheHunter> tromp, http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Data/Array/Base.hs?rev=1.24
07:49:07 <ozone> mmm, maybe not
07:49:15 <ozone> the real answer is: who cares? :)
07:49:17 <Igloo> No, it wouldn't for a directory
07:49:29 <tromp> thx, hunter
07:49:42 <Igloo> Don't be silly, that's a question!  :-)
07:49:58 <ozone> yes, a question that is both a question ... and an answer!
07:53:05 * Darius is reminded of a "calculus of knowing"
07:53:23 * shapr wants a calculus of calculi
07:53:36 <ibid> isn't that just an application of modal logic?
07:53:55 * desrt performs implication elimination on shapr
07:54:12 <mayhem> what is modal logic ?
07:54:32 <ozone> whoever wrote the MonadsAsContainers page is very cool
07:54:39 <ozone> that's one of the best introductory explanations i've read
07:54:42 <shapr> Cale wrote it! He's coool!
07:55:06 <ibid> mayhem: add modal operators to classical logic
07:55:17 <ozone> indeed.  now to read the rest of it before i give it too much due praise ;)
07:55:27 * Darius isn't too gung-ho about that page.  Though I believe all the instances where it does (easily) make sense to think of monads as containers are free monads.
07:56:06 * musasabi likes to think of monads as strategies for combining computations.
07:56:52 <desrt> thinking about monads is possibly a good way to get you thinking about monads
07:56:54 <ibid> mayhem: the "classical" modal operators are necessity and possibility
07:57:07 <ozone> desrt: phwoar
07:57:11 <desrt> it's not a very good way to get you thinking about what they mean or how to use them in haskell, though :)
07:57:13 * TheHunter think almost all monads can be though of as "containers".
07:57:35 <TheHunter> if you strech your intuition of containers a bit, even continuation-like monads can.
07:58:04 <ibid> mayhem: but there are many more. for example, an imperative program is also a modal operator
07:58:12 <ibid> mayhem: temporal logic is also a modal logic
07:58:28 <Darius> ibid: I forgot the name of the "calculus" I was referring to (or even if it called itself a calculus).  It has three operators: aKb (a knows b), Ea (everyone knows a), Ca (a is common knowledge)
07:58:50 <ibid> i *think* that's epistemological logic, a branch of modal logic
07:59:10 <ibid> at least the K operator looks familiar :)
07:59:27 * Darius Doesn't think it's of much use, let alone intuitive, to think of anything but free monads as containers.
08:00:26 <ibid> dynamic logic (modal logic where programs are the modal operators) looks cool
08:00:29 <TheHunter> a reader monad isn't free, is it?
08:01:03 <tromp> the implementation of accumArray is
08:01:05 <tromp> unsafeAccumArrayUArray f init (l,u) ies = do
08:01:05 <tromp>     marr <- newArray (l,u) init
08:01:05 <tromp>     sequence_ [do
08:01:05 <tromp>         old <- unsafeRead marr i
08:01:05 <tromp>         unsafeWrite marr i (f old new)
08:01:06 <tromp>         | (i, new) <- ies]
08:01:08 <samc> sounds like update logic
08:01:08 <tromp>     unsafeFreezeSTUArray marr
08:01:35 <tromp> can any1 explain why that uses linear amount of stack?>
08:03:15 <Darius> TheHunter: It's not generated from a finitary algebra in general, and I'm not really seeing it from an infinitary algebra either, so I don't think so.
08:03:22 <samc> mayhem, logic extended with operators which can be considered as quantifiers over possible worlds
08:04:12 <TheHunter> ok, but a reader monad is a nice example of a container.
08:04:19 <Darius> tromp: mapM_ does the same as that sequence/comprehension combination.
08:04:29 <ibid> samc: though the 'possible worlds' interpretation makes sense only for some modal operators
08:06:25 <samc> ibid, what's an example?
08:07:34 <ibid> samc: dynamic logic, for example (the "possible worlds" are program states)
08:08:13 <ibid> possible worlds makes sense really only for the classic modal logic (necessary/possible)
08:08:19 <TheHunter> The property of "being a container", as I understand it, is closed under `(,)', `Either' and `(->) r'. So even many functors that aren't monads are containers.
08:08:57 <Darius> TheHunter: How do you describe (r->) as a container?
08:09:31 <Philippa> TheHunter: functors're commonly used to describe polymorphic containers so that's no surprise
08:10:00 <samc> ibid, I would say that fits, I just stretch the meaning of "possible worlds" more :)
08:10:11 <TheHunter> Darius, `r -> c a' is a container of a's that consists of a container c a of a's for each r.
08:13:41 <maihem> hi mayhem :)
08:13:46 <ibid> samc: sure, the semantics works, but the philosophical  interpretation doesn't
08:14:12 <ibid> i believe the technical term is Kripke semantics
08:14:29 <samc> I don't like to get into the philosophical side of things
08:15:48 <ibid> then don't use philosophical terms ;)
08:17:41 <tromp> i rewrote my cntElems as
08:17:47 <tromp> cntElems b a = runST (do
08:17:47 <tromp>   cnts <- newArray b 0 :: ST s(STUArray s Int Int)
08:17:47 <tromp>   mapM_ (\x -> do
08:17:47 <tromp>     i <- readArray cnts x
08:17:47 <tromp>     writeArray cnts x (i+1)
08:17:48 <tromp>     ) a
08:17:50 <tromp>   freeze cnts) :: Array Int Int
08:18:06 <tromp> any suggestions how to stop it from giving stack overflow:-?
08:18:27 <musasabi> tromp: try sequence_ [ comprehensionHere ] instead of mapM_
08:18:56 <TheHunter> tromp, tried writeArray cnts x $! i+1 ?
08:19:12 <Darius> tromp: Are you constantly storing into the same element in your test code?
08:19:31 <samc> mayhem, e.g. logic extended with the operator necessarily (in all possible worlds) and possibly (in some possible world), or e.g henceforth (at all future times) and eventually (at some future time) etc.
08:19:44 <tromp> yeah, most elements in list are 0
08:19:59 <tromp> sequence gives same stack overflow
08:20:17 <samc> ibid, I just think of them as intuition guiding terms, but I shall be more careful at all future times ;)
08:20:24 <ibid> :)
08:20:51 <ibid> samc: yeah, it's an appropriate intuition for some modal logics
08:21:19 <tromp> $! doesn't help
08:21:20 <Darius> tromp: If the array is strict, I don't -think- you should be having a problem, but with a lazy array the element being stored into the most may be looking like <delay: 3+4+2+7+3...>
08:21:30 <tromp> which makes sense since the array is unboxed anyway
08:23:23 <tromp> maybe the problem is inherent in mapM_ over a very long list?
08:24:46 <tromp> hmm, mapM_ (\i->return ()) [0..9999271] works fine
08:28:14 <Darius> tromp: I'd be more worried about the parts other than the mapM_.
08:28:45 <tromp> if i take out the mapM_ (...) it doesn't overflow
08:28:46 <TheHunter> *Main> cntElems (0,3) $ [i `mod` 4 | i <- [1..1000000]]
08:28:46 <TheHunter> array (0,3) [(0,250000),(1,250000),(2,250000),(3,250000)]
08:29:23 <tromp> my list is 10million long though
08:29:31 <tromp> try 10m
08:29:39 <TheHunter> just finished, works, too.
08:30:11 <Darius> tromp: Well, if you just commented it out, you wouldn't may not be using the list (and hence not evaluating part of the expression).
08:30:23 <Darius> tromp: See what length (replicate ...) does.
08:30:59 <tromp> still waiting for ghci to complete cntElems (0,3) $ [i `mod` 4 | i <- [1..10000000]] :P
08:31:25 <tromp> ah yes, that works
08:34:10 <tromp> here's the code on which it overflows:
08:34:12 <tromp>   ents <- getElems entries
08:34:12 <tromp>   let ints = map fromIntegral ents
08:34:12 <tromp>   let scnts = cntElems (loss,win) [x `shiftR` 5 | x<-ints, x.&.31 > 0]
08:35:14 <tromp> ints is close to replicate 9999271 0
08:38:39 <tromp> well, having trouble reproducing overflow outside complete program:(
08:39:31 <tromp> is there a debugger that can show which part of the code produces the overflow?
08:40:23 <Darius> tromp: If you compile with profiling (or perhaps just link to the profiling libraries) and add +RTS -xc -RTS to the commandline it will give you a "stack trace" on an exception.
08:40:26 <bloomberg> can you have nested list comprehensions?
08:40:31 <Darius> yes
08:40:47 <Darius> bloomberg: List comprehensions are just expressions.
08:41:40 <Darius> tromp: See the wiki page TipsAndTricks for a bit more information.
08:41:43 <bloomberg> ok but in my outer one, m<-[1..n] and in my inner one p<-[0..n-1]. hugs is reporting an undefined variable p
08:42:23 <Darius> bloomberg: It's not because of the two clauses you just showed.
08:42:33 <bloomberg> ok i think i see the problem
08:43:30 <Oejet> Hello all!  Preliminary to making a Haskell Bzip2 binding, I've written a small C program using libbz2.  How do I tell GCC to find the library so I don't get this error:
08:43:31 <Oejet> "/System/Variable/tmp/ccxeqzXj.o(.text+0x6c): In function `main':
08:43:31 <Oejet> : undefined reference to `BZ2_bzWriteOpen'"
08:43:46 <musasabi> Oejet: -lfoo
08:46:59 <tromp> darn
08:47:09 <tromp> the overflow is somewhere else
08:47:32 <tromp> in getElems
08:47:32 <musasabi> have you used heap profiling?
08:47:50 <tromp> nope
08:47:56 <tromp> try this:
08:47:59 <tromp>   entries <- newArray (0,ttsize-1) 0 :: IO (IOUArray Int Int8)
08:48:03 <tromp>   ents <- getElems entries
08:48:20 <tromp> where ttsize=9999271
08:48:38 <musasabi> how is getElems defined?
08:49:07 <tromp> in import Data.Array.MArray
08:49:25 <tromp> you may need the following imports:
08:49:29 <Oejet> musasabi: If foo is the path to libbz2.a or libbz2.so it cannot find it, neither -llibbz2 nor -lbzlib.h works.
08:49:34 <tromp> Prelude Main Control.Monad Data.Array.MArray Data.Array.IArray Data.Array.IO Data.Word Data.Int>
08:49:34 <musasabi> sequence [unsafeRead marr i | i <- [0 .. rangeSize (l,u) - 1]]
08:49:54 <ozone> Oejet: if libbz2 is in the current directory, add -L. to the cmdline
08:49:59 <musasabi> tromp: that is not tail recursive...
08:50:02 <Lemmih> Oejet: Omit the 'lib' part.
08:50:03 <ozone> and it's -lbz2
08:50:17 <tromp> i feel silly rewwriting the wrong part of my program:(
08:51:17 <tromp> doesn't that depend on how sequence is defined, musasabi?
08:51:32 <Oejet> ozone: Lemmih: Thanks, it compiles!  Now I'll just have to fix that segmentations fault. :-)
08:51:50 <TheHunter> tromp, you prolly should be replace sequence by a similar unsafeSequence using unsafeInterleaveIO.
08:52:10 <musasabi> sequence ms = foldr k (return []) ms where k m m' = do { x <- m; xs <- m'; return (x:xs) }
08:53:45 <musasabi> but sauna =>
08:54:32 <Lemmih> Oejet: Got the code online?
08:59:23 <Oejet> Lemmih: http://www.student.dtu.dk/~s022018/Temporary/usebzip.c
09:00:55 <Lemmih> Neat! printf-style debugging (:
09:14:35 <tromp> it's starting to dawn on me that performing getElems on large arrays is a really bad idea
09:14:54 <tromp> because lazyness is out the window
09:15:30 <tromp> unless you're an unsafeOperation wizard I guess
09:16:02 <desrt> unsafeRiskLife
09:16:25 <Philippa> unsafeSex?
09:16:37 * desrt blinks
09:16:51 <Philippa> no, that wasn't an offer :-)
09:16:59 * desrt hands Philippa a comonad
09:17:54 <tromp> @index unsafeRead
09:17:54 <lambdabot> Data.Array.Base
09:19:11 <Oejet> Lemmih: Problem found and corrected.
09:19:25 <TheHunter> in the spirit of unsafeInterleavIO, you can just replace sequence with "return . map unsafePerformIO".
09:20:15 <tromp> @type Data.Array.Base.unsafeRead
09:20:16 <lambdabot> Data.Array.Base.unsafeRead :: forall e a m i.
09:20:16 <lambdabot> 			      (Data.Array.Base.MArray a e m, GHC.Arr.Ix i) =>
09:20:16 <lambdabot> 			      a i e -> Int -> m e
09:20:58 <TheHunter> unsafeRead a i is just like a[i] in C.
09:21:43 <tromp> it's still monadic
09:22:48 <tromp> i'd expect unsafeRead to have type a i e -> Int -> e
09:23:08 <TheHunter> unsafeGetElems marr = case bounds marr of
09:23:08 <TheHunter>     (l,u) -> return [unsafePerformIO $ unsafeRead marr i | i <- [0 .. rangeSize (l,u) - 1]]
09:23:09 <Darius> tromp: The unsafe there is about bounds checks.
09:23:12 <Oejet> Lemmih: Forgot to allocate two integers. :-P
09:23:33 <Lemmih> Oejet: Updated the src at dtu.dk?
09:23:35 <tromp> so how can i define a lazy getElems?
09:24:00 <Oejet> Lemmih: Yes, now.
09:24:21 <tromp> i think i better avoid the list alltogether
09:25:20 <Darius> tromp: That's a good idea (speed- and space-wise).  The prevalence of lists in the array interface is arguably a flaw.
09:26:02 * Oejet votes for array comprehensions!
09:27:12 <Darius> Yes, I'd like to see chilli's Nepal-related work more supported.  It doesn't seem to be being worked on right now and I'm not sure where it's at (in the process).
09:28:06 <Oejet> Darius: GHC's PArr library is severely flawed.
09:46:42 <basti_> hi
09:53:27 <Oejet> Hello, basti_.
09:54:03 <basti_> how's things?
09:56:17 <tromp> finally got Fhourstones benchmark running in haskell
10:12:42 <bourbaki> moin
10:12:47 <basti_> hi bourbaki
10:13:35 <bourbaki> basti_: whats your interest in haskell or what are you doing with it btw?
10:14:11 <basti_> oh i'm heavily into "clean" programming (as in, terse and understandable anyway)
10:14:40 <basti_> I'm doing haskell because I think it's worth the effort of learning a new language
10:14:49 <bourbaki> thats true
10:14:54 <bourbaki> are you interested in math also?
10:15:07 <basti_> yes.
10:15:18 <basti_> as a victim so to say :P
10:15:25 <bourbaki> heh
10:15:35 <bourbaki> do you study CS?
10:15:36 <basti_> no I see that math is neccesairy for almost everything
10:15:37 <basti_> yes
10:15:40 <basti_> "Informatik"
10:15:46 <bourbaki> ah i see where?
10:15:51 <basti_> Marburg
10:15:56 <basti_> ...
10:15:58 <basti_> :)
10:15:59 <bourbaki> thats right which is why i think about studying math
10:16:08 <bourbaki> i have been studying in fluda once
10:16:14 <basti_> :)
10:16:31 <basti_> im not a native to hessen though.
10:16:38 <bourbaki> quite a nice place to be
10:16:49 <basti_> marburg or fulda?
10:16:53 <bourbaki> fulda
10:17:01 <bourbaki> very small you can go everywhere by foot
10:17:08 <basti_> ive been there for a few hours only. but i found it nice too
10:17:16 <bourbaki> i have been liveing next to a brauerei
10:17:25 <basti_> is that good or bad?
10:17:31 <bourbaki> and 50 meters of me away was the dom
10:17:37 <bourbaki> thats good
10:17:39 <basti_> -g-
10:17:40 <tuomov> linux/x is just getting worse and worse day by day
10:17:48 <tuomov> now X is equipped with a drop-shadowed white cursor
10:17:49 <bourbaki> i havent been there often but it was very quite there
10:17:55 <tuomov> does anyone know how to get rid of it?
10:18:02 <tuomov> I want that nice black cursor
10:18:40 <basti_> tuomov: sorry, no idea.
10:19:08 <tuomov> the state of much software is such that one of these days I'm gonna throw the computer off the balcony and go live in the forest
10:19:09 <bourbaki> personally i grow more and more fond of topology
10:19:29 <basti_> tuomov: i think the window manager would deliver the "non default" cursor shapes.
10:19:40 <basti_> (the default being the black X?)
10:19:41 <tuomov> no
10:19:49 <basti_> bourbaki: hm.
10:19:55 <bourbaki> tuomov: have you checked man xfree86?
10:19:58 <tuomov> I tried out galeon (it still sucks) and messed with some gnome shit and thought that did it
10:20:07 <tuomov> but restarting X (just X :1) didn't help
10:20:07 <bourbaki> basti_: i have heared a lecture on neurobiology
10:20:09 <tuomov> it's still there
10:20:14 <bourbaki> give me a sec to find it
10:20:30 <basti_> bourbaki: so? :P any relations to topology?
10:20:48 <bourbaki> http://www.bbc.co.uk/radio4/reith2003/lecture4.shtml
10:20:51 <bourbaki> yes a strong one
10:21:07 <bourbaki> since the brain is interconnected with cells you can look at that as a topology
10:21:18 <basti_> oh i think you gave me that link a whole time ago.
10:21:23 <basti_> i enjoyed reading it a lot
10:21:23 <bourbaki> and in the visual field there is a rougly symmetric mapping
10:21:35 <bourbaki> nope its an audio file
10:21:40 <bourbaki> it deals with synestesy
10:21:44 <basti_> i just read the text.
10:21:50 <ulph> maybe as a graph?
10:21:52 <bourbaki> the cross hopping of senses
10:21:56 <bourbaki> ulph: yep
10:22:08 <basti_> i learned something in my CS studies.
10:22:12 <ulph> a topology is something different in mathematical sense
10:22:13 <bourbaki> ah ok its really cool i see there a strong connection to topology
10:22:21 <basti_> "Artificial Intelligence" is not.
10:22:42 <bourbaki> ulph: no a graph is a discreet topology
10:23:00 <bourbaki> you take the edges and interpolate them from 0 to 1
10:23:35 <bourbaki> anyway math is great :)
10:23:45 <bourbaki> basti_: do you know www.mathescript.de ?
10:23:58 <basti_> no
10:24:04 <basti_> it doesnt reply too.
10:24:43 <bourbaki> sec
10:25:39 <bourbaki> dang cant find it again :( just downloaded my script there yesterday
10:25:46 <basti_> hm
10:26:09 <bourbaki> you can search for scripts there
10:26:16 <basti_> there where?
10:26:18 <bourbaki> in different topics from different unis
10:26:20 <basti_> :)
10:26:36 <bourbaki> a really cool site
10:26:46 <bourbaki> btw
10:27:03 <bourbaki> do you know any videolectures like the ones of ableson and sussman?
10:27:23 <basti_> um
10:27:37 <basti_> who are ableson and sussman?
10:27:52 <ulph> how would you define topology?
10:27:58 <bourbaki> the guys that also wrote the purple book :)
10:28:14 <bourbaki> a topology is the collection of open sets of a set
10:28:37 <basti_> well i was the technican in some video lecture once
10:28:57 <bourbaki> it would be cool to gather all thouse links in a place like wikipedia
10:29:52 <basti_> <tel.
10:33:01 <SyntaxNinja> wow. pugs was implemented in just a few weeks? that's awesome.
10:33:25 <bourbaki> pugs?
10:34:08 <sorje> bourbaki, pugscode.org ;-)
10:34:12 <nnunley> The perl community has been bandying specs around for couple years now
10:35:48 * SyntaxNinja high-fives haskell
10:36:47 <tromp> is there any sort of profiling tutorial for haskell?
10:37:27 <SyntaxNinja> tromp: just this: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
10:40:03 <tromp> thx, SN
10:41:25 <tromp> afk shopping
10:47:41 <basti_> < bpp
10:51:41 <bourbaki> basti_: bpp?
10:51:48 <basti_> back phrom phone
10:51:58 <bourbaki> ah :)
10:52:09 <bourbaki> who was that again with the lisp interpreter in haskell?
10:52:31 <shapr> Ashley Yakeley?
10:52:33 <basti_> i just remember the guy who wanted to do a haskell interpreter on Atmel AVR
10:52:36 <shapr> HScheme?
10:52:47 <bourbaki> oh where is that hscheme thingy?
10:52:57 <shapr> semantic.org / sf.net
10:57:30 <Si\> shapr: Is TMR gonna be out on March 1st?
10:58:43 <shapr> Outcome unclear
10:58:48 <basti_> lol
10:58:58 <shapr> Did you guys have magic eight balls in the UK too?
10:59:51 <Si\> is that a conundrum?
10:59:58 <basti_> a what
11:00:18 <Si\> Definitions of conundrum on the Web: riddle: a difficult problem
11:00:31 <basti_> ah
11:00:33 <shapr> I sure hope it'll be online march 1st.
11:00:52 <basti_> shapr: so will it be html or ps/pdf?
11:01:02 <shapr> It'll be ps/pdf this time.
11:01:17 <shapr> But next issue it'll be wikipublishing.
11:01:20 <bourbaki> what will be delivered as pdf?
11:01:33 <shapr> Because the real bottleneck is that I can't do everything :-)
11:02:16 <shapr> Several of the authors, Si\ for example, organized their own proofreaders other than me.
11:02:43 <shapr> Next issue I want to set it up so that the authors can all see each others in-progress articles, but not the public.
11:02:59 <Oejet> shapr: Nooooo, at least make a high quality ps/pdf an other option to wikipublishing.
11:03:01 <shapr> That way I won't be the only person who's doing grammar/spelling checking.
11:03:09 <basti_> -g-
11:03:10 <Si\> well, not so much proofreading, more of a sanity check ;)
11:03:18 <bourbaki> shapr: what do you publish?
11:03:27 <shapr> bourbaki: The Monad.Reader
11:03:29 <basti_> problem is, ps/pdf is hard to do.
11:03:40 <bourbaki> hehe cool what kind of mag is that?
11:03:46 <Si\> nah, it's dead easy when you know LaTeX
11:03:50 <shapr> Oejet: do you want to volunteer to convert content on the wiki to ps/pdf ? :-)
11:04:06 <basti_> "dead easy".
11:04:09 <shapr> Si\: thing is, I don't know LaTeX, and decentralized development is a real pain in the butt.
11:04:12 <Oejet> Yeah.  Koniechno.
11:04:18 <bourbaki> shapr: what about a TMR sexy girl calender ;)?
11:04:23 <basti_> \includegraphics[trim = 80mm 247mm 70mm
11:04:23 <basti_>     35mm,clip]{haskore1-example.ps}
11:04:26 <basti_> ^ dead easy
11:04:33 <shapr> bourbaki: I think that's an excellent suggestion for the April 1st issue.
11:04:37 <Si\> try marking that up in XML
11:04:45 <shapr> bourbaki: you are now responsible for that part of next issue. :-P
11:04:50 <Si\> or using OpenOffice for a decent bibliography
11:05:16 <bourbaki> shapr: hehe :) ok all i need now is sexy haskell codeing girls ;) where can i get the last issues and what do they feature?
11:05:29 <shapr> bourbaki: the first issue will be out somewhere close to March 1st
11:05:44 <bourbaki> ah now i get it cool idea though
11:05:54 <bourbaki> what kind of articles it will have?
11:06:06 <shapr> @wiki TheMonadReader
11:06:06 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
11:06:07 <bourbaki> is it like dr dobbs? or like what kind of mag?
11:06:14 <bourbaki> like a paper collection?
11:06:23 <shapr> Nah, it's something between journal articles and wiki pages.
11:06:49 <Si\> shapr: What you need to do is get someone to create a cls for Monad.Reader, and then everyone's files will be of the same format
11:06:53 <shapr> Thing is, I don't really care how it looks as long as the content is good.
11:07:07 <shapr> Si\: I've got one, kosmikus was kind enough to donate a few hours of time to make up a nice one.
11:08:01 <shapr> Problem is, I still don't know anything about LaTeX, and my only priority is quality teaching/learning content, rather than sexy print appearance.
11:08:41 <Si\> well, JFP is quite simple after all
11:08:48 <basti_> but appearance matters a lot ;)
11:09:05 <basti_> dont get me wrong Si i think latex is the best approach to that problem.
11:09:26 <shapr> I dunno, I get my best info off of IRC, and it doesn't have much formatting.
11:09:29 * shapr grins
11:09:36 <bourbaki> plus in latex you can make your own style once and use it for all
11:09:50 <Si\> I don't get me wrong, LaTeX can be a severe pain in the neck, especially when doing complex process algebra behavioural semantics n stuff
11:09:51 <shapr> I'd like to do wikipublishing with inline LaTeX allowed.
11:09:56 <basti_> -g-
11:10:14 <bourbaki> shapr:  youc an do that with mediawiki i was told
11:10:21 <basti_> i just loathe the latex approach to all things graphical.
11:10:22 <shapr> HaWiki does it too.
11:10:26 <bourbaki> plus webmathematica that will have a cool thingy
11:10:41 <bourbaki> is it hard to setup a hawiki?
11:10:43 <shapr> inline LaTeX examples on my Wikipage -  http://www.haskell.org/hawiki/ShaeErisson
11:10:47 <Si\> you can format LaTeX to be graphical
11:10:54 <shapr> bourbaki: it's just moinmoin with some plugins.
11:11:07 <Si\> my colleague does all his "powerpoint" presentations in LaTeX
11:11:12 <shapr> neat
11:11:20 <bourbaki> shapr: im webpagically challenged
11:11:21 <basti_> yes you can.
11:11:30 <basti_> usual styles dont do it decently though.
11:11:31 <shapr> bourbaki: you have no webbrowser?
11:11:47 <bourbaki> i have
11:11:58 <bourbaki> but im not very versed with web page stuff
11:12:19 <shapr> You don't need to be versed with web page stuff to do wikipublishing.
11:12:40 <bourbaki> ok i just thought that i would have to host one
11:12:41 <Si\> all you need is create a nice EPS background with inkscape, set up some decent fonts, and decent column layout, create yourself a front and contents page and you've got something cool
11:16:42 <shapr> I know I can organize peer review wikipublishing, if someone can shoehorn that format into a ps/pdf output, I would like that.
11:16:49 <xerox> 'lo
11:17:06 <basti_> well you can use latex2html.
11:17:11 <basti_> hmm
11:17:54 <bourbaki> thats an idea also
11:18:16 <bourbaki> but the problem is that i dont work on it contiously
11:18:32 <bourbaki> so if i have an idea when im at the uni i want to add stuff to my idea
11:18:35 <shapr> don't work on what?
11:18:51 <bourbaki> i cant carry my latest work everywhere
11:19:03 <basti_> version management?
11:19:03 <bourbaki> if its on the net i can work on it whereever inet it
11:19:05 <basti_> usb stick?
11:19:13 <bourbaki> nah usb stick sucks :)
11:19:18 <basti_> they dont.
11:19:39 <bourbaki> the cool thing also is that if someone wants to help me its easier to work on it at once
11:19:49 <bourbaki> i just need some place to dumb ideas
11:19:55 <shapr> Anyway, next issue wikipublishing, if everyone hates it, the search for a better solution will then continue.
11:19:56 <bourbaki> and let them develop over time
11:20:01 <basti_> -g-
11:20:15 <SyntaxNinja> y0 shapr
11:20:27 <shapr> y0 SyntaxNinja, wazzup?
11:20:54 <SyntaxNinja> nomuch. taking' it easy
11:21:01 <shapr> Sounds nice
11:21:47 <SyntaxNinja> what's up w/ you?
11:22:31 <shapr> Lotsa stuff, TMR, reviewing a book, work.
11:23:47 <SyntaxNinja> sounds like fun
11:24:20 <shapr> Yeah it is.
11:26:39 <Darius> shapr: Which book?
11:27:08 <shapr> Ship It from the Pragmatic Programmers, it's quite nice, but the review must be done by Monday.
11:30:56 <Oejet> I'm looking for a way to get at Ptr CFile from a Handle.  FFI reference just mentions the type.  CFile is not even of type Storable.  Library reference and Reid's docs are not a big help.
11:31:33 <shapr> Si\: btw, do you want to use tmr.cls in your article?
11:32:15 <Si\> can do
11:32:36 <Si\> do you still need a front cover btw?
11:32:42 <shapr> hm, neat idea
11:32:45 <shapr> You got one?
11:33:35 <shapr> I'd like a logo too, if anyone wants to volunteer :-)
11:34:02 <Oejet> Maybe a mascot animal?
11:34:51 <basti_> animal.
11:35:14 <Oejet> basti_: Was that a vote?
11:35:24 <basti_> rather a surprised exclamation
11:36:05 <shapr> Si\: darcs get http://www.cs.uu.nl/~andres/TMR for the tmr.cls
11:37:42 <shapr> Si\: does GXS require that both ends of a connection know about the data type ahead of time? (Have I already asked you this? :-)
11:38:18 * shapr should really wait to ask questions after reading the article
11:38:27 <Si\> yes, if you're assuming to Haskell end-points and using it as a SOAP server
11:38:38 <Si\> \s\to\two
11:38:58 <shapr> ok
11:39:12 <Si\> you always gotta know what's coming out for the deserializer to work
11:39:24 <Si\> same as you always need to know the type for Read
11:40:10 <shapr> I wonder if there's some way to use hs-plugins to add the type at runtime.
11:40:33 <Darius> What would make a decent logo for the Monad Reader?
11:41:08 <shapr> A morph between Samuel Clements and SPJ?
11:41:10 * shapr snickers evilly
11:41:33 <Oejet> Like on then back of SICP.
11:41:34 <Si\> hs-plugin doesn't work with GHC-6.4 atm anyway, but why would you want to do that?
11:42:00 <shapr> So you can have Erlang-OTP in GHC.
11:42:19 <Si\> you always need some sort of Schema for a serializer in any language to be able to parse
11:42:55 <shapr> Runtime definition of new types would be the first step to real runtime upgrading of types.
11:45:48 <SyntaxNinja> Lemmih: alive?
11:46:15 <Si\> true, but you'd still need to know the structure before you can perform the upgrading
11:46:33 <Si\> and I think type-classes need some work first ;)
11:46:48 <shapr> I'm sure you know more about it than I do :-)
11:53:41 <j_> hi, can anyone tell me what the # operator (function) does? i've never seen it before but it's in some code example on wikipedia's haskell page
11:54:34 <Darius> j_: It's not a standard function.  It presumably is defined on that page as well.
11:54:50 <SyntaxNinja> j_: it may not be a function, but a syntax clue that something is "Unboxed"
11:55:04 <j_> that's what i thought, but it isn't defined there
11:55:37 * Darius had read Embedding Interpreters but was more interested in the monadic reification/reflection operations.
11:56:00 * Darius reading it again realizes how disgustingly more nice the first part would be in Haskell.
11:56:08 <Darius> j_: Well, which page is it?
11:56:17 <j_> Darius, oh right. http://en.wikipedia.org/wiki/Haskell_programming_language
11:56:21 <SyntaxNinja> j_: this might clarify things: http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
11:58:09 <SyntaxNinja> j_: hm, you're right, looks like a function
11:58:40 <Darius> j_: The only place I see it used, it's defined immediately below in a where clause.
11:59:24 <j_> oh. i missed that
11:59:25 <j_> sorry
12:06:04 <Oejet> lisppaste2: url?
12:06:05 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:10:00 * WilX np: U2 - Pride (in the name of love) [03:50m/160Kbps/44KHz]
12:10:03 <WilX> Wheee.
12:10:08 <WilX> Early U2 is nice.
12:10:12 <WilX> Ooops.
12:10:16 <WilX> Sorry, wrong channel.
12:10:17 <basti_> echan? ;)
12:11:04 <lisppaste2> Oejet pasted "How do I get to a CFile from a Handle?" at http://paste.lisp.org/display/6125
12:12:04 <basti_> Oejet: I don't know too.
12:22:14 <shapr> jnewbern: greetings!
12:22:31 <shapr> jnewbern: are you the author of the famous nomaware tutorial?
12:24:51 <Igloo> SyntaxNinja: Are all the docs under http://www.haskell.org/cabal/release/ the latest-and-greatest?
12:25:59 <SyntaxNinja> Igloo: no, the user's guide is a bit updated since then
12:26:16 <SyntaxNinja> maybe not _a lot_
12:26:50 * SyntaxNinja pokes Lemmih
12:27:23 * Oejet pours curry in Lemmih's eyelid.
12:27:37 <Oejet> Er, into.
12:27:43 <shapr> eww
12:27:55 <basti_> liquid curry?
12:28:00 <basti_> i'd suggest sambal oelek
12:28:09 <basti_> instant eye opener
12:28:10 <Oejet> shapr: Yeah, you wouldn't want that to happen to you, would you?
12:28:26 <shapr> I prefer uncurry.
12:28:33 <jnewbern> shapr, yes it is me
12:28:47 <shapr> jnewbern: Greetings! Have you been here before?
12:28:58 <jnewbern> it's been a while
12:29:12 <shapr> Ah, then you've already had the short tour.
12:29:19 <Igloo> SyntaxNinja: How about the docs in libghc6-cabal-dev_0.5-1_i386.deb (and shouldn't they be in a separate doc package?)?
12:29:46 <SyntaxNinja> I'm too lazy for that.
12:29:54 <SyntaxNinja> those docs are the ones that are consistent w/ the package itself.
12:30:01 <jnewbern> i'm here looking for some good resources for understanding GHC's support for rank-2 polymorphism
12:30:11 <SyntaxNinja> so if I gave you the latest user's guide, it might not be perfectly consistent w/ the 0.5 release
12:30:15 <SyntaxNinja> Igloo: do you have a particular question?
12:30:53 <Igloo> "How do I get from these Haskell sources and testsuite to an optimal cabal package?"
12:31:07 <Darius> jnewburn: There was a "tutorial" paper fairly recently covering higher ranked type checking/inference in GHC.
12:31:07 <kosmikus> jnewbern: PJ and Shield's paper on "practical rank-n polymorphism"
12:31:45 <SyntaxNinja> Igloo: the user's guide is pretty good for that.
12:31:58 <Igloo> Oh, and another question - can I say "license is BSD or GPL v2 at your choice" in such a way that hackage or whatever in the future will understand?
12:32:08 <Igloo> SyntaxNinja: But which one?  :-)
12:32:15 <jnewbern> kosmikus: thanks, I will look that up.
12:32:22 <kosmikus> jnewbern: http://research.microsoft.com/Users/simonpj/papers/putting/
12:32:25 <SyntaxNinja> Igloo: no; you can use LicenseFile to express that, though
12:32:26 <Igloo> I assume the most recent one, but I'd have to build that myself, right?
12:32:48 <SyntaxNinja> Igloo: I can slap a snapshot of the user's guide online if you want, it's probably not much better than that one
12:32:54 <SyntaxNinja> but I would be very happy to hear your suggestions :)
12:33:02 <basti_> hmmm i think if i would see a type 2 polymorphism, i could call it its name.
12:33:11 <SyntaxNinja> btw, ross wrote the user's guide
12:33:25 <basti_> i wonder what it would be good for though.
12:33:41 <Igloo> Well, I don't see the point in not using the latest, so that'd be great if it's not too much trouble
12:34:09 <SyntaxNinja> Igloo: pdf OK?
12:34:12 <Igloo> Yup
12:34:50 <SyntaxNinja> http://www.syntaxpolice.org/tmp/Cabal.pdf
12:36:05 <Igloo> Thanks
12:36:24 <jnewbern> kosmikus: thanks for the link, it's just what I was looking for.
12:47:01 <Cale> ozone: thanks! :)
12:57:12 <Oejet> I'm progressing.  basti_, I cheated and wrapped the "wrapper(FILE* f, char* text)" in a "wrapper2(char* file_name, char* text)".
13:00:20 * Oejet takes his frustration out on some n00by BZFlag players for a while.
13:03:08 <basti_> Oejet: hm. i wonder if that is what you wanted :P
13:11:09 <WilX> Hm, can I get command line parameters without System.Console.GetOpt?
13:11:19 <shapr> yup
13:11:21 <xerox> getArgs ?
13:11:33 <xerox> @index getArgs
13:11:33 <lambdabot> System.Environment,System
13:11:56 <WilX> Thanks.
13:11:58 <shapr> there's also Pesco.Cmdline http://www.scannedinavian.org/~pesco/
13:20:54 <nnunley> shapr: Hrm.  What's the signature of a 2d array of infinite complex doubles?
13:21:10 <nnunley> Err, a lazy stream of complex doubles, that is.
13:24:19 <WilX> Whee. I am a bit confised with System.IO. How can I read 4 bytes from a binary file/handle and get Int?
13:25:47 <WilX> s/confised/confused/
13:31:35 <Oejet> Back.
13:36:25 <ski> nnunley : [Complex Double], maybe ?
13:37:02 <nnunley> ski: So a 2 dimensional array has the same signature as a single dimensional one?
13:37:23 <ski> um
13:37:32 <ski> you said lazy stream
13:37:33 <WilX> @index mallocPtr
13:37:33 <lambdabot> bzzt
13:37:42 <WilX> @index mallocPtrBytes
13:37:42 <lambdabot> bzzt
13:37:44 <tromp> haskell doesn't support binary IO quite yet
13:37:57 <nnunley> ski: Sorry.  Creating an evil structure to represent a julia set.
13:37:59 <WilX> >_<
13:38:00 <ski> nnunley : which normally means 1-dimensional
13:38:11 <nnunley> ski:  Each point is a lazy stream.
13:38:23 <WilX> But GHC seems to allow to open a file in binary mode.
13:38:36 <WilX> Why would it be there if there was no way to get the data using it..?
13:38:59 <ski> nnunley : with an element for every pixel ?
13:39:12 <ski> hm
13:39:12 <nnunley> ski: Right.
13:39:18 <Cale> WilX: you might check out http://quux.org/devel/missingh/html/index.html
13:39:34 <WilX> Yup.
13:39:38 <WilX> Reading.
13:40:11 <ski> nnunley : if you want to use streams (i.e. lists) instead of arrays, i guess you could have a list of lists of some pixel data
13:40:43 <Cale> might be stuff in there related to what you want
13:40:54 <ski> nnunley : why you want to store complex nums in it, btw ?
13:42:50 <nnunley> ski:  Let me try to restate the definition, so my intent is clearer.
13:43:40 <ski> sure
13:44:49 <Cale> oh, hey
13:45:05 <nnunley> Each point of the julia set is an infinite stream of complex numbers, where the first point is rooted on the pixel you're looking at (ie. x :+ y), which is transformed by a function (Complex -> Complex -> Complex), and then used as the basis of the next point in the stream.
13:45:05 <Cale> WilX: have you looked at hGetBuf?
13:45:21 <WilX> Yeah but I do not quite get it.
13:45:29 <nnunley> You then iterate through the stream to some maximum depth, and check for convergance or divergence.
13:45:45 <nnunley> (spelling's not my strong suit)
13:46:59 <nnunley> So... I was mostly just curious what the signature for a 2D array was.  Or a 2D list.
13:47:06 <ski> aha, now i understand more or less what you wanted
13:47:54 <Cale> WilX: look up malloc and mallocBytes for how to create the Ptr required
13:48:02 <WilX> @index malloc
13:48:03 <lambdabot> Foreign,Foreign.Marshal,Foreign.Marshal.Alloc,MarshalAlloc
13:48:08 <desrt> @type (\a (x,y) -> a!!(x,y))
13:48:09 <lambdabot> bzzt
13:48:24 <ski> nnunley : Array (..xindextype..,..yindextype..) (..elementtype..)
13:48:39 <ski> for a 2-dim array
13:48:57 <ski> e.g. Array (Int,Int) [Complex Double]
13:49:04 <desrt> oh.  ! not !!
13:49:30 <desrt> @type (\a (x,y) -> (a!(x,y)))
13:49:31 <lambdabot> bzzt
13:49:32 <nnunley> ski: Thanks.   And thank you for making me work through explaining what I was trying to do.
13:49:42 <desrt> how do i pull Data.Array into scope on lambdabot?
13:50:03 <TheHunter> @type \a (x,y) -> a Data.Array.! (x,y)
13:50:05 <lambdabot> \a (x,y) -> a Data.Array.! (x,y) :: forall e t t1.
13:50:05 <lambdabot> 				    (GHC.Arr.Ix (t, t1)) =>
13:50:05 <lambdabot> 				    GHC.Arr.Array (t, t1) e -> (t, t1) -> e
13:50:09 <desrt> fancy.  thanks :)
13:50:17 <Cale> or perhaps http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign.Marshal.Array.html
13:50:27 <ski> nnunley : lists are not 2d, though you can partly simulate it through nested lists, i.e. lists of lists of something, where e.g. you regard it as a column list of row lists of things ..
13:51:06 <Cale> WilX: yes, I think you want mallocArray together with peekArray at some point
13:51:18 <WilX> Yup, I was just looking at it.
13:51:21 <WilX> Thanks for guidance :)
13:52:06 <desrt> how is it that Ix is preserved across tuples?
13:52:23 <desrt> like, how does haskell know that a tuple is an Ix iff its components are both Ixen
13:53:43 <TheHunter> desrt, there's an "instance (Ix a, Ix b) => Ix (a,b) where ..." somewhere.
13:54:05 <tromp> in Data.Ix
13:54:10 <nnunley> ski: *nods*  Thanks, again
13:54:21 <desrt> i should probably figure out this instance stuff :)
13:56:20 <TheHunter> Read it as: Whenever a and b are instances of Ix, so is (a,b), where the instance is defined using the Ix instances of a and b as follows...
13:56:35 <WilX> @index liftM
13:56:36 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
13:56:36 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
13:56:36 <lambdabot> State,Control.Monad.Writer,Monad
14:11:56 <Oejet> Lemmih: PING
14:12:53 <shapr> I wish I had time to try out all the code before TMR publication.
14:13:17 <shapr> Only partially for article correctness, another big part is that there's a lot of cool code.
14:13:47 <Oejet> shapr: Will there be an FFI article?
14:17:21 <shapr> Not that I've heard about.
14:18:01 <shapr> Maybe you can find someone who wants to write one for next issue?
14:18:06 <Oejet> shapr: You wouldn't know how to get a CFile from a Handle?
14:18:13 <shapr> Nope, never done any FFI.
14:18:37 <Oejet> shapr: TMR is monthly?
14:18:39 <shapr> Si\: only one edit on your article
14:18:54 <Si\> ok
14:18:58 <shapr> Oejet: that's the plan, ask me after three months and I'll give you the reality :-)
14:19:32 <Si\> you can change it to work with TMR just by putting the title and author before the begin{document} and putting my email in an \email{field}
14:20:31 <shapr> I just sent you the diff, not something I can really fix myself.
14:21:00 <Oejet> shapr: Since I'm banging my head against the FFI at the moment, I might be a good candidate for a tutorial.
14:21:09 <shapr> Oejet: excellent idea :-)
14:23:00 <Oejet> shapr: When I get the Bzip2 binding working that might be an interesting example.
14:23:06 <shapr> sounds good to me
14:25:41 <Oejet> shapr: But I want it published in high printing quality.  Something to show the lads, you know. ;-)
14:27:26 <shapr> I'm not yet sure if issue2 will have nice pdf or ps output.
14:28:36 <shapr> I'm off to sleep, g'nite all
14:28:55 <Oejet> Good night, shapr.
14:29:32 <musasabi> good night.
14:29:46 <Oejet> Ah, musasabi!
14:30:35 <Oejet> Do you know how to get a CFile out of a Handle?
14:32:46 <musasabi> I think yes.
14:33:49 <Oejet> musasabi: Oh, oh.  Where can I read about it?
14:34:24 <musasabi> @type System.Posix.IO.handleToFd
14:34:26 <lambdabot> System.Posix.IO.handleToFd :: GHC.IOBase.Handle
14:34:26 <lambdabot> 			      -> IO System.Posix.Types.Fd
14:35:20 <Oejet> Tried that.  Fd /= CFile.
14:35:56 <musasabi> Oejet: what is a CFile?
14:36:51 <Oejet> It's an opaque data type for the type "FILE" in C.  Buttom of http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.C.Types.html
14:37:21 <Oejet> Then Ptr CFile would be "FILE*".
14:37:22 <musasabi> Oejet: data CFile = CFile
14:37:40 <musasabi> Oejet: you are aware of fdopen?
14:38:02 <Oejet> Saw that mentioned somewhere...
14:38:07 <obe1> why can i do this: until (== 5) (+ 1) 0 and not until (== 0) (- 1) 5 ?
14:38:36 <lightstep> the syntax for sections doesn't work with (-)
14:38:38 <musasabi> foreign import CALLCONV "fdopen" fdopen :: Fd -> Ptr CChar -> Ptr CFile
14:38:46 <musasabi> *IO (Ptr CFile)
14:39:28 <obe1> ha, until (== 0) (+ (-1*1)) 5 works
14:39:47 <lightstep> the idiom is (substract 1)
14:39:57 <obe1> oh thanks ;)
14:40:24 <Oejet> musasabi: Where is that documented?
14:40:52 <musasabi> Oejet: but note that using both the FILE* and the Handle after fdopen will lead to problems - you can use one of them. (because both of both haskell and C buffer things unaware of each other)
14:40:56 <musasabi> Oejet: man fdopen
14:41:30 <musasabi> e.g. http://www.opengroup.org/onlinepubs/007908799/xsh/fdopen.html
14:41:38 <lightstep> actually, using both unistd and stdio is also unsafe
14:41:47 <desrt> fdopen is awesome
14:42:13 <Oejet> musasabi: I was thinking about in the setting of FFI.
14:43:13 <musasabi> Oejet: it is not a part of the FFI. Not many people need to get a FILE* from a Handle, so I don't think that using fdopen for it is documented anywhere.
14:44:10 <Oejet> musasabi: He, I mean the all mention a type CFile, but not how to construct a value.
14:44:13 <musasabi> just a standard A->B, B->C and a C function which does B->C to accomplish A->C.
14:45:00 <lightstep> why is it Handle -> IO Fd, and not Handle -> Fd ?
14:45:56 <Oejet> lightstep: I guess then you'd have to "return (f Handle)" all the time.
14:46:26 <musasabi> Oejet: Foreign.C.Types tries to introduce some of the types in the C standard library, not necessary provide any useful way of using them.
14:46:44 <Oejet> Handle is already in the monad world.  So monad functions are usually of type (a -> IO b).
14:46:47 <musasabi> lightstep: because that is not a pure operation.
14:47:37 <Oejet> Ah, of course.  For a given Handle you could get different Fd's.
14:48:20 <lightstep> it smells pure. especially when considering hDuplicate
14:48:39 <lightstep> oh. it actually smells impure
14:50:15 <musasabi> have to go to the bed soon, good night.
14:50:38 <Oejet> Good night, musasabi.
14:50:46 <Oejet> And thanks for the help!
14:52:08 <Oejet> desrt: Why is fdopen awsome?
14:52:30 <desrt> Oejet; because i used it yesterday :)
14:59:31 <Oejet> Hm, how would one go about getting the IOMode (ReadMode, WriteMode,...) from a Handle?
15:01:20 <lightstep> you can pass it toghether with the handle from its creation
15:02:27 <Oejet> I am in a situation, where the function just takes a Handle as parameter and not the IOMode.
15:05:51 <lightstep> in C it's done with fcntl with command being F_GETFL. but you usually don't do that
15:15:26 <Oejet> Yeah!  I succeded with the help of you guys.  :-)
15:17:54 <lightstep> how did you get into a situation where a function gets called with a file and needs to check whether it's writable?
15:18:08 <Oejet> lightstep: I will show you.
15:18:48 <Itkovian> gdnight #haskell
15:18:59 <Oejet> Good night, Itkovian.
15:19:44 <WilX> Hmm, haskell.org/hawiki doesn't link to any PasteBin.
15:19:46 <WilX> Is there any?
15:20:47 <lightstep> @wiki HaskellIrcPastePage
15:20:47 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:23:35 <Oejet> lightstep: >>> wikipastepage
15:25:17 <Oejet> So "bzWriteWrapperWrapper :: Handle -> String -> IO ()" is a wrapper for "void bzWriteWrapper( FILE* f, char* text );"
15:26:18 <WilX> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:26:36 <WilX> Is there any problem with my code wrt/ lazyness?
15:26:43 <WilX> (Bottom of the page.)
15:28:06 <Oejet> And using "fptr   <- fdopen fdescr iomode", iomode is now a hard coded to be "write mode".  I wanted just to take the mode of the Handle.
15:28:53 <lightstep> but you want to write anyway, don't you?
15:29:00 <Oejet> WilX: I don't know, I'm just learning the Foreign.C world.
15:29:22 <Oejet> lightstep: Yes.  I know, it's a bit silly.
15:31:38 <lightstep> WilX, minor comment: you should call peek with the result of hGetBuf, in case the buffer isn't filled
15:32:50 <WilX> Hm, I am not sure what you mean? hGetBuf returns number of read bytes.
15:33:10 <WilX> I do you say that I shouldn't peek unless I got the right amount?
15:33:26 <WilX> Sounds reasonable. Will fix.
15:33:49 <lightstep> you should only peek at the bytes actually read
15:34:24 <lightstep> also, peekCStringLen might be a lazy operation
15:34:40 <WilX> Yeah, that was what I was afraid about :/
15:35:07 <lightstep> which leads to problems parallel to those of hGetContents&hClose
15:35:27 <WilX> Which I have never really understood how to fix...
15:36:31 <lightstep> neither did i
15:38:13 <Lemmih> peekCStringLen isn't lazy, iirc.
15:38:48 <lightstep> these functions are so undocumented
15:39:07 <WilX> Yup :/
15:40:04 <Lemmih> Have you read the FFI Addendum?
15:40:33 <WilX> Nope.
15:41:14 <lightstep> i skimmed through it
15:41:25 * Oejet read it twice.
15:41:28 <lightstep> it doesn't specify which functions are strict
15:41:51 <Lemmih> They all are, I believe.
15:43:31 <Lemmih> Actually I'm sure they are.
15:44:19 <Lemmih> Anyhow, I'm off to get painkillers. bbl.
15:47:11 <WilX> Ok, so, the code should be safe, right?
15:48:17 <lightstep> probably, since Lemmih says  so
15:53:37 <WilX> Geez. I am such a beginner :)
15:53:49 <WilX> putStrLn ("[" ++ show nam ++ "]")
15:54:03 <WilX> show nam shows string with "xyz"
15:54:09 <WilX> Omg.
15:54:11 <WilX> Never mind.
15:56:20 <WilX> Done.
15:56:25 <WilX> It all works fine.
15:57:25 <WilX> otsukaresama
15:58:06 <ski> japanese for ?
15:58:35 <WilX> Thank you/many thanks :)
15:58:58 <WilX> Something you say when you have finished your work and such.
15:58:59 <ski> mhm
15:59:42 <ski> (you've lived in japan ?)
16:01:03 <WilX> Nope. I am just another CS student who got grabbed by anime tentacles and started learning Japanese.
16:02:03 <ski> heh, ok
16:05:11 <kosmikus> so, anyone travelling to expo this year? ;)
16:08:19 <Oejet> Hey would it be insteresting to extend your programs with Guile?
16:12:04 <sh10151> gomen
16:12:52 <Oejet> sh10151: What is gomen?
16:13:07 <WilX> Sorry.
16:13:23 <WilX> "I am sorry."
16:26:57 <Oejet> Ah, more Japanese.
21:02:54 <Lemmih> Hey karingo. Learning Haskell?
21:11:43 <danb_> 17:57 < WilX> otsukaresama
21:11:43 <danb_> 17:58 < ski> japanese for ?
21:11:43 <danb_> 17:59 < WilX> Thank you/many thanks :)
21:12:19 <Lemmih> @seen SyntaxNinja
21:12:19 <lambdabot> I saw SyntaxNinja leaving #haskell 7 hours 35 minutes 47 seconds ago.
21:13:24 <danb_> interestingly, it seems the literal meaning of otsukaresama () is "the (respected) person who wore me out"
21:13:56 <danb_> ...and it also seems my client doesn't handle multi-byte input very well
21:14:23 <danb_> i guess i should also include:
21:14:24 <danb_> 17:59 < WilX> Something you say when you have finished your work and such.
21:15:18 <danb_> <- another CS student sucked into japanese for its geekiness (not its anime)
21:20:06 <wagle> whoa..  my client (ssh to screen running irssi) rendered the kanji and hiragana
21:20:19 <danb> :)
21:21:12 <gzl> hm
21:21:14 <gzl> mine doesn't render it
21:21:27 <danb> should be utf8...
21:21:41 <gzl> yeah, i tried that. didn't do it.
21:21:42 <sh10151> 
21:21:46 <gzl> odd.
21:22:04 <gzl> whatever, not like i can read it anyway.
21:22:15 <wagle> (my terminal emulator is the macosx terminal app)
21:22:27 <danb> yeah, i would expect osx to display it properly
21:23:07 <gzl> yeah, that's what i'm using.
21:23:07 * gzl scratches head
21:23:10 <wagle> (i was partly amazed that none of the stuff in the middle decided to get in the way)
21:23:20 <gzl> wagle, you're using UTF-8?
21:23:30 <wagle> how do i tell?
21:23:32 <gzl> maybe I don't have the fonts installed. :)
21:23:39 <gzl> cmd-i, Display
21:23:46 <gzl> see Character Set Encoding
21:24:00 <wagle> i have a tendency to install all languages...
21:24:07 <gzl> yeah, i have a tendency ... to not.
21:24:25 <wagle> i know what utf-8, just not what all the stuff i got going thinks its doing
21:24:46 <wagle> its hilarious to see all the spam in russian
21:24:53 <gzl> hehe
21:25:17 <gzl> someone should really update the hugs package in fink
21:25:18 * heatsink looks at the japanese spam to see how much it can understand
21:25:33 <gzl> heatsink: btw, thanks for all the help that day with haxml. helped a lot.
21:25:43 <heatsink> am glad.
21:25:43 <gzl> it makes a lot more sense to me now. :)
21:25:45 <wagle> i even get some korean spam
21:25:59 <heatsink> did you finish your application?
21:26:02 <gzl> the stuff i had to do after the initial struggle came through pretty smoothhly
21:26:04 <gzl> * smoothly
21:26:14 <wagle> (i wonder why none from india)
21:26:29 <gzl> i guess indians are too class for spam
21:26:35 * gzl whistles innocently
21:26:44 <heatsink> there's no shortage of visual spam in india
21:26:54 <gzl> yeah, i know.
22:58:43 * shapr hops cheerfully
23:00:19 <heatsink> hi, shapr-bunny.
23:00:46 <shapr> y0 heatsink, howza?
23:02:54 <heatsink> Procrastinating is hard work.
23:03:16 <shapr> hah
23:03:33 <shapr> check out this awesome bike sign SyntaxNinja found - http://blog.syntaxpolice.org/isaac/index.cgi
23:04:35 <heatsink> unicycle lanes?
23:04:45 <shapr> yes! is that awesome or what?
23:05:01 * shapr boings cheerfully
23:05:34 <heatsink> It's great!
23:06:13 <shapr> Are you procrastinating writing some code?
23:06:27 <heatsink> No, i'm procrastinating studying for the qualifying exam.
23:06:39 <shapr> What sort of stuff are you going to study?
23:07:08 <heatsink> MOS transistor properties and the BJT model mostly
23:07:32 * shapr asks google for details
23:07:43 <heatsink> And I need to practice.  Lots of stuff, I can do it but I take too long and I risk running out of time on the test.
23:08:00 <shapr> Aha, bipolar junction transistors. They're moody?
23:08:36 <heatsink> yea.  One moment they're gushing with electricity, the next moment they shut off.
23:08:59 <shapr> Wow, that's really bipolar.
23:10:06 <shapr> Sounds like fun, I like hardware.
23:10:37 <LMSCraft> That reminds me. I have become readdicted to Starcraft and I need to play someone.
23:10:57 <shapr> You could write a starcraft computer player in Haskell.
23:11:10 <LMSCraft> I might actually be able to beat it
23:11:19 <heatsink> Mail me a copy of starcraft, and I'll play iwth you.
23:11:53 <LMSCraft> I'd love to, if you had a code :/
23:12:09 <LMSCraft> Otherwise it's pretty worthless.
23:12:24 <heatsink> you mean it's not a cracked copy? what kind of a gamer are you? :p
23:12:36 <LMSCraft> Starcraft is like the cheapest game ever.
23:13:01 <LMSCraft> Besides.
23:13:06 <LMSCraft> You need the key to get on Battle.net.
23:13:23 <sh10151> SMAC is cheaper I think
23:13:26 <LMSCraft> Install key isn't exactly something you even need to crack
23:21:47 <musasabi> morning
23:22:12 <heatsink> good morning, i'm to bed.
23:37:58 <autrijus> rehi lambdafolks.
23:55:35 <MachinShin> night all
