00:00:41 * earthy groans at shae's humor
00:03:25 <a5> by "join the ScannedInAvian collective" you mean darcs repository...?
00:04:17 <shapr> Well, it was mostly a joke, but I have given out accounts and webspace to those who are unlikely to get their own, and do write Haskell source they want to distribute under an OSS license.
00:04:51 <shapr> Of course, with no guarantee of continued service and the terms of which are "be nice"
00:05:27 <shapr> Speaking of which, that server is going down as soon as I get this box behind me configured and installed at our new colo.
00:05:46 <earthy> and something else will take its place?
00:06:11 <shapr> Yes, most of it will move to the new server.
00:06:20 <shapr> DarcsWiki is going to the sponsored darcs.net
00:07:05 <shapr> if/when community.haskell.org becomes a reality, I'll probably encourage people to move over there.
00:09:08 <shapr> yay, new hs-plugins
00:09:28 <shapr> earthy: any ideas for community.haskell.org services? maybe borg.haskell.org is a better hostname? =)
00:09:41 <shapr> or just collective
00:12:23 <shapr> a5: So, how do you like Haskell so far? any further thoughts? I really will get around to responding to your email, but I've been covered up in work lately. On the good side, part of that work is installing Curryspondence for a client.
00:12:27 * Lemmih wonders if haskell.org will be upgraded sooner now where both Hackage and the community site would benefit of it.
00:14:47 <a5> dude, you spend so much time giving excuses about how you don't have time to respond to this one little email
00:14:59 <shapr> haha
00:16:29 <a5> community.haskell.org, interesting
00:17:01 <a5> i like haskell better than any other language, definitely
00:17:27 <shapr> Some features I'm hoping for are sourceforge-like, but with darcs support, webspace, collected news, rss aggregator, etc
00:17:43 <earthy> that is *exactly* what I was thinking
00:17:44 <shapr> I like CosmicRay's http://sequence.complete.org/
00:17:49 <earthy> put The Haskell Sequence on it. :)
00:17:55 <shapr> Right
00:17:59 <earthy> ieh! scary bastard
00:18:18 <autrijus> hm. I maintain a sourceforge-like system...
00:18:25 <autrijus> the only problem is that it doesn't support darcs
00:18:27 <autrijus> but that can be fixed :)
00:18:29 <earthy> ah :)
00:18:30 <autrijus> (and it's GPL)
00:18:44 <shapr> Rumor has it that CosmicRay will be fine with moving sequence to community.haskell.org if/when it appears.
00:19:14 * shapr wonders if 'deus ex machiavella' is too cheesy
00:19:26 <earthy> quite
00:20:04 <shapr> autrijus: which software are you using, sourceforge itself? gforge?
00:20:13 <shapr> Or something else I haven't heard of before?
00:25:48 <autrijus> shapr: http://rt.openfoundry.org/
00:26:07 <autrijus> shapr: http://wagner.elixus.org/~autrijus/foundry/start.html
00:26:14 <autrijus> it's the thing that currently hosts pugs development
00:28:18 * kosmikus is not too happy about the domain name "community.haskell.org"
00:28:22 <shapr> kosmikus: why not?
00:28:30 <shapr> What would you prefer?
00:28:36 <kosmikus> because HC&AR has haskell.org/communities
00:28:40 <shapr> oh, good point.
00:28:53 <kosmikus> I really like the idea, but I'd prefer you'd choose another name
00:29:00 <shapr> ok, will do.
00:30:08 * earthy thought there was a certain familiar ring to community.haskell.org
00:30:17 <earthy> anyway, cabal is out as well
00:30:19 <shapr> Maybe collective.haskell.org ?
00:30:37 <earthy> not the right kind of humour. :)
00:31:49 <autrijus> functor.haskell.org
00:31:57 <autrijus> unfold.haskell.org
00:32:05 <earthy> cahoots.haskell.org ? :P
00:32:10 <autrijus> class.haskell.org
00:32:15 <shapr> kombinator.haskell.org
00:32:17 <earthy> that'd be for education
00:32:21 <earthy> combinator, then
00:32:23 <autrijus> morphism.haskel.org
00:32:44 <earthy> sodality.haskell.org
00:32:49 <shapr> autrijus: that'd be cute, hylo.morphism... cata.morphism...
00:33:00 <earthy> ana.morphism
00:33:04 <earthy> iso.morphism...
00:33:06 <shapr> skolem.haskell.org
00:33:23 <earthy> curry.haskell.org <- let's go chinese with our naming. :P
00:33:32 <autrijus> chinese? :)
00:33:40 <autrijus> ah.
00:33:41 <shapr> Isn't curry from India?
00:33:43 <autrijus> naming convention.
00:33:44 <earthy> yeah, they tend to swap first- and last names. :)
00:33:48 <shapr> ohh
00:33:50 <autrijus> I like curry.haskell.org.
00:34:12 <shapr> Curry probably clashes with Lennart Augustsson's language Curry.
00:34:18 <earthy> `the haskell dinner table, where you go to get your haskell brainfood'
00:34:18 <shapr> But he might not mind.
00:34:48 * earthy needs to get back to work... too much silliness ;)
00:35:10 <shapr> I really like functor
00:35:19 <autrijus> yeah, it has the right idea
00:35:22 <earthy> that's not bad either
00:35:31 <autrijus> fun.haskell.org
00:35:38 <shapr> heh
00:35:54 <autrijus> apply.haskell.org
00:35:57 <autrijus> eval.haskell.org
00:36:04 <dons> yeah!
00:36:06 <shapr> lesser.eval ?
00:36:11 <earthy> continue.haskell.org
00:36:38 <earthy> transform.haskell.org
00:36:50 <dons> control.haskell.org
00:36:56 <shapr> scary
00:37:02 <autrijus> for sf-like functionality, I like space.haskell.org too
00:37:13 <autrijus> http://space.haskell.org/banana/
00:37:30 <earthy> that got a laugh out of me at least :)
00:37:34 <shapr> :-)
00:40:07 <shapr> Oh, I know.. I'll create a sequence post about this.
00:41:45 <a5> i like space? but it isn't very haskell-related
00:41:59 <earthy> doesn't need to be
00:42:06 <earthy> but what about playground?
00:42:10 <earthy> playground.haskell.org
00:45:20 <a5> i think the rest of the haskell community might be more serious than those on IRC?
00:45:34 <autrijus> I like space.haskell because it's serious
00:45:50 <earthy> exactly
00:45:59 <earthy> but, why not throw out the idea on haskell-cafe as well?
00:46:07 <earthy> s/idea/ideas/
00:51:01 <b0gg1e> hi'all
00:56:01 * bringert has a new computer
00:56:11 * bringert messes with xchat
00:56:29 <bringert> how are y'all this fine morning?
00:56:39 <Itkovian> busy
00:56:41 <Itkovian> very busy
00:56:49 <Itkovian> can I buy some more time?
00:57:26 <bringert> you need quality time? or will any do?
00:58:55 <shapr> oh, what sort of new computer?
00:59:02 <bringert> tablet-PC
00:59:11 <bringert> Toshiba M200
00:59:25 <bringert> now with Gnome(tm)
00:59:40 <shapr> neato
00:59:50 <bringert> haven't got everything working yet, but pretty much everything I need
01:00:14 <bringert> we use it for demoing multimodal systems
01:00:23 <bringert> e.g. talk and point
01:00:25 <a5> earthy: i don't see a reason why not
01:00:52 <shapr> nlv11757_: greetings, looking for Haskell info?
01:01:29 <shapr> bringert: how do you type on the m200? handwriting?
01:01:57 <a5> haddock can't parse its own source
01:02:55 <shapr> I wish I could parse my own source.
01:04:57 <nlv11757_> hi shapr, i will work 'on-demand' :)
01:05:37 <nlv11757_> so when I encounter a problem I can't solve, I can ask here
01:05:44 <shapr> Sounds goods to me.
01:05:52 <bringert> shapr: I use the keyboard most of the time
01:05:54 <shapr> Do you have any questions now?
01:06:11 <nlv11757_> hahah no, I'm pretty fluent in Haskell. So now problems just yet
01:06:15 <bringert> there is handwriting recognition in windows, but it works so-so and the UI for inte is strange
01:06:24 <shapr> inte?
01:06:36 <bringert> s/inte/it/
01:06:51 <bringert> the on-screen keyboards in gnome and windows xp work pretty well too, but are a bit slow
01:06:54 <Heffalump> nlv11757_: you work for Philips?
01:07:20 <shapr> I thought inte might be the name of the software, at which point I was going to start making swedish jokes.
01:07:35 <bringert> it is a pretty good name for a program
01:07:57 <shapr> InterNet Telephony Extended - INTE
01:07:57 <nlv11757_> not yet Heffalump, Im doing my Msc Thesis there.
01:08:07 <shapr> Oh, what's your thesis about?
01:08:44 <nlv11757_> Im developing a interactive parallelizer for C programs basically
01:08:52 <shapr> That reminds me of the US car company that sold a car named "Nova" in mexico. Do you know what "Nova" means in spanish?
01:09:19 <Heffalump> nlv11757_: cool
01:09:21 <shapr> Sounds nifty, using switchable skeletons or something?
01:09:40 <Heffalump> Philips have a pretty good compilers group, don't they?
01:10:03 <nlv11757_> yep
01:10:58 <nlv11757_> shapr: my application is a bit different; I want to be able to take public domain c code (think about mpeg encoder) and parallelize it interacting with the user of my tool.
01:11:11 <nlv11757_> so I have to assume the worst regarding code quality
01:12:21 <shapr> Will you be integrating refactoring browser features to allow users to expose any parallelism?
01:13:33 <shapr> Sounds like a nifty application.
01:13:56 <nlv11757_> I dont think I can manage that in the current time frame, It's already a huge project. But maybe if Philips hires me to completely finish the thing.
01:14:38 <shapr> What sort of features do you plan to complete? I'm not even sure how to design such an app.
01:15:10 <nlv11757_> well, first of all, im not striving for full parallelization...this is a holy grail and impossible :D
01:15:26 <Heffalump> parallelize or vectorize, or both?
01:15:39 <nlv11757_> secondly, I will work in a 'use-case' driven way
01:15:53 <nlv11757_> coarse grain parallelization on function level is the aim
01:16:06 <nlv11757_> no fine grain stuff
01:16:57 <shapr> Does this application have the Cell in mind?
01:17:40 <shapr> You probably weren't expecting to defend your thesis already :-)
01:18:56 <nlv11757_> haha im taking a weird angle I realize in this area :) so questions are in place.
01:20:22 <nlv11757_> target platform is a shared symmetric multiprocessor
01:22:29 <shapr> Definitely sounds like fun.
01:23:24 * shapr tries to keep at least one item in the submission queue on http://sequence.complete.org/
01:24:35 <nlv11757_> this is definitely a project im enjoying :) I will see how far I will come.
01:25:43 * boegel coughs
01:27:32 <shapr> hoi boegel
01:28:17 <boegel> hey shapr
01:32:22 <Lemmih> I always mix up boegel and b0gg1e in my head /-:
01:32:43 <boegel> Lemmih: I was first :p
01:32:53 <b0gg1e> :-)
01:47:22 <shapr> hiya cptchaos
01:47:37 * shapr boings randomly
01:47:46 <cptchaos> hi schapr!
01:47:53 * boegel tries to bounce, but is too tired
01:48:02 <cptchaos> :-)
01:48:07 <shapr> oooh, schapr is a new one. I like that.
01:48:12 <cptchaos> i jsut wake up
01:48:19 <cptchaos> :-)
01:48:24 <boegel> it sounds like schnappi, das kleine krokodil
01:49:08 <shapr> I always thought die allwissende muellhalde was nifty.
01:49:33 <shapr> That's bourbaki's nickname for the InterNet.
01:49:51 <boegel> heh
01:59:52 * shapr reads the latest meme on planet.debian.org - cd ~/music && du -hs = 59G 
02:00:42 <cptchaos> hm, thats more than my actual hd
02:00:59 <cptchaos> (laptop)
02:08:56 <shapr> mmm, nifty - http://www.transterpreter.org/
02:14:36 <Lemmih> Why is there always at least one piece of broken hardware connected to my machine? );
02:28:13 <shapr> Cale: you're on AdminGroup, which means you've got all the power you can get without filesystem access.
02:43:16 <shapr> nifty - http://www.cse.ogi.edu/~magnus/Adaptive/
02:43:19 <metaperl> Lemmih, your hackage demo is a great start
02:45:49 <Lemmih> metaperl: Thanks.
02:51:03 <shapr> I totally agree.
02:51:59 <shapr> hiya Huschi
02:54:29 <metaperl> what is the fastest way for me to get the definition of flip? I saw it in a program and want to know what it does?
02:54:45 <shapr> it swaps two args
02:54:54 <shapr> \f a b -> f b a
02:56:05 <shapr> @type flip
02:56:08 <lambdabot> flip :: forall c a b. (a -> b -> c) -> b -> a -> c
02:56:26 * Lemmih wonders if there's any demand for further hackage development.
02:57:41 * shapr demands that Lemmih hack more on hackage.
02:58:57 * shapr thinks Oligarchy loads!
03:03:17 <metaperl> I created a module for encrypting text with the Discordian algorithm and one feedback I got was to use the "points-free" version of a function... what does that mean exactly? Here is my post: http://article.gmane.org/gmane.comp.lang.haskell.cafe/6233/match=discordian
03:04:07 <metaperl> @prelude flip
03:04:20 <shapr> sorry, prelude is down right now for maintenance.
03:05:11 <Lemmih> @wiki PointFreeStyle
03:06:01 <Lemmih> http://haskell.org/hawiki/PointFreeStyle
03:06:34 <metaperl> partition is a beautiful function. I'm glad I requested feedback on my code
03:07:17 <lambdabot> ERROR: connect: timeout (Connection timed out)
03:07:17 <lambdabot> http://www.haskell.org/hawiki/PointFreeStyle
03:13:04 <shapr> metaperl: You still have questions about Points-free?
03:13:16 <metaperl> no, the wiki was excellent
03:13:20 <shapr> spiffy
03:13:38 <shapr> I'm glad you're enjoying Haskell, I enjoy it myself.
03:13:40 <metaperl> I am so pleased with my first program in Haskell
03:13:51 <metaperl> it was so to-the-point
03:14:02 <earthy> metaperl: read my mail to you (of about a minute ago)
03:14:08 <metaperl> and to think I could've made it better by using partition
03:14:12 <earthy> point-free style is *very* reminiscent of unix pipes
03:14:21 <metaperl> ahh
03:14:39 <metaperl> you know Scheme has scsh - scheme shell...
03:14:54 <metaperl> Haskell could not have this because shell interaction is impure?
03:15:02 <earthy> in a sense, yes
03:15:10 <earthy> it could, ofcourse
03:15:24 <earthy> but prefixing your commands with do gets tiresome quite quickly
03:15:47 <shapr> You could always make a Monad instance for unix pipes.
03:17:35 <metaperl> it's like Unix but you dont have the flags,
03:17:45 <metaperl> eg sort but not sort -r
03:17:46 <metaperl> sort -n
03:17:50 <metaperl> sort -rn
03:17:51 <metaperl> etc
03:17:52 <earthy> um.
03:17:55 <earthy> yes you do. :)
03:18:02 <earthy> just not free-form
03:18:11 <earthy> (e.g.  map ord  )
03:18:12 <metaperl> sort_reverse
03:18:16 <metaperl> sort_numeric
03:18:25 <metaperl> sort_reverse_and_numeric
03:18:45 <earthy> um, yeah, well, that you do using sortBy
03:18:52 <earthy> sortBy sortfunc
03:19:08 <earthy> s/sortfunc/ordfunc/ where ordfunc gives the exact ordering you want
03:23:24 <earthy> sort = sortBy compare
03:44:42 <araujo> good morning
03:49:12 <Lemmih> Morning, araujo.
03:50:41 <shapr> jiihaa
03:52:05 * shapr hops towards Lemmih while riding a unicycle.
03:52:48 <shapr> Lemmih: how's work?
04:03:37 <shapr> bringert: hey, does unavailable mean 'out of country' or does it mean you'll still be able to show for a beer?
04:08:27 <Lemmih> shapr: Haven't worked for over a week /-:
04:08:55 <shapr> well, get movin!
04:09:46 <Lemmih> Nah, already got enough to pay rent next month (:
04:10:26 <shapr> Hm, I try to keep at least three months rent, because I never know when I won't get more contract work.
04:11:00 <shapr> Also because I want to buy new hardware soon.
04:11:20 <shapr> I love this LCD monitor, it's sooo easy on the eyes. Now I want one with DVI
04:12:21 <tromp> hi lemmih&shapr
04:12:29 <shapr> hoi tromp
04:13:09 * Lemmih mumbles something about the evilness of capitalism and greediness. (:
04:13:25 * shapr mumbles something about people who have broken hardware
04:13:31 <Philippa> nothing wrong with using gear that causes you less damage
04:13:43 <tromp> u only want a new one for dvi?
04:13:45 <Philippa> my eyesight's really not good...
04:13:57 <tromp> not to get a bigger or higher-res screen?
04:14:22 <shapr> dvi allows subpixel rendering, easier on the eyes. Prices on dual-link dvi and/or 19" monitors are probably more than I can afford.
04:14:26 <ozone> dell have a nice 24" widescreen LCD now.  USD$1,199
04:14:47 <shapr> I was thinking of something more like USD $300
04:15:57 <tromp> $300 buys you a 17" or a crappy 19"
04:16:28 <shapr> I've realized that patents are like poker chips. Most players have zero chips. Once someone joins the game who raises one chip, those guys have to fold.
04:16:45 <shapr> Yeah, I was considering a DVI 17"
04:16:59 <tromp> that's what i'm using now
04:17:13 <shapr> Do you see a difference with sub-pixel rendering?
04:17:20 <Forest> LCD = no games
04:17:31 <shapr> Forest: not with the recent models
04:17:41 <shapr> update speed is just fine nowadays.
04:18:09 <nlv11757_> my brother always complains about the refreshrate causing him deaths in counterstrike
04:18:09 <nlv11757_> :)
04:18:11 <shapr> Anyway, I've pretty much given on twitch games.
04:18:47 <Philippa> nlv11757_: It's just about possible, though it's hard to notice once you're maintaining 60...
04:19:01 <tromp> i dont know how you'd set subpixel rendering or even what that would do
04:19:10 <Philippa> (a matter of mouse sampling - higher framerate = more accurate shots under counterstrike's engine)
04:19:33 <shapr> I get addicted to twitch games, and then I completely stop writing fun code. But once the round is over, my time is gone, and that was it. When I write fun code, other people get the benefit of that time, and I get benefits for years.
04:20:07 * Philippa needs a good opponent for something like SFA3 or Garou again
04:20:13 <shapr> tromp: http://grc.com/ctwhat.htm
04:20:20 <nlv11757_> ok so my brother has this very high dpi mouse and hyperglides and stuff, but he's affraid that a refreshrate of 12ms in the lcd would kill him
04:20:20 <Philippa> thing is, it's easier to control the addiction when you need a second player to have fun
04:21:01 <shapr> I spent years getting good at CounterStrike, now I have nothing to show for it. I spent years getting good at Haskell, lots of people use my code. I'd rather code.
04:21:02 <Philippa> nlv11757_: ah, the update time you mean?
04:21:08 <Philippa> that /can/, if the other guy's not got that
04:21:19 <nlv11757_> yeah sorry
04:21:28 <Philippa> because all else being equal, they'll open fire 12ms earlier and getting hit screws up your ability to fire back
04:21:46 <nlv11757_> my bad, I overloaded the term refresh rate on lcd screens :D
04:21:49 <Philippa> shapr: camperstrike's particularly bad though
04:22:07 <Philippa> I mean, I used to spend half my time executing teammates for blatant stupidity...
04:22:35 <tromp> so you'd have to tell your graphics card how each pixel is subdivided into r,g,b
04:22:37 <shapr> public servers and all that
04:23:08 <nlv11757_> Im dedicating my time to chess nowadays, very interesting game i must say.
04:23:13 <shapr> tromp: Right, but XF86 knows about most of the common subpixel orders, and you can just tell it which one to use.
04:23:25 <nlv11757_> of course i need my xbox/ps2 action now and then :P
04:24:16 <wilx> :)
04:24:23 <wilx> Yay for good old CS 1.5!
04:24:33 <shapr> tromp: thing is, you can't get exact pixel location with analog VGA inputs to an LCD screen, only with DVI inputs.
04:24:41 <Philippa> shapr: I was playing on a LAN, my teammates were still often idiots with a habit of giving my position away
04:24:52 <shapr> Philippa: I feel sorry for you.
04:25:12 <ozone> Philippa: it's much more fun with bots
04:25:20 <Philippa> meh. It happened less once they realised how quickly I could put four rounds of 7.62 through a teammate's head
04:25:28 <nlv11757_> hehe, if im not good at it and i can't get good at it...i dont do it....thats why i quit playing CS
04:25:29 <ozone> don't have to play with idiots, and just as importantly, you don't have to play with 10-year-old freaks who are 300-1
04:25:36 <shapr> I was never especially accurate or fast at CS, but no one could ever predict what I would do next, not even myself. That gave me a surprising advantage.
04:25:55 <Philippa> ozone: I can handle the freaks. Taking the opponent from behind is a winning strategy in CS
04:26:06 * Philippa nods
04:26:08 <wilx> I remember when Athlon 1.2 was fast machine I owned. Then slowly as people were getting faster machines it was getting worse and worse :)
04:26:17 <ozone> i've met more than my fair share of freaks
04:26:25 <ozone> i didn't have to do anything, i'd just go let them run the show
04:26:44 <shapr> Yeah, but two guys with good teamwork will kill off any one freak.
04:26:58 <Philippa> right. One to get his attention, one to shoot him in the back
04:26:59 <shapr> Three guys with good teamwork are hard to beat on a public server.
04:27:09 <Philippa> yeah. Bad teamwork, OTOH, you can waste 'em all in a second
04:27:20 <Philippa> used to play morons who'd line up in single file for the headshot...
04:27:50 <shapr> I think four is the most I've ever gotten in a single headshot.
04:27:53 <Philippa> I mean, they didn't intentionally do it in front of me, but do you really think I'm not gonna put myself on that line too? :-)
04:28:09 <wilx> Eeek!
04:28:25 <wilx> I hate snipers.
04:28:38 <shapr> I'm a decent sniper, I especially like the scout.
04:28:41 <Philippa> yeah. I once wasted five coming round a tight corner on Dust, the poor bastard in the middle didn't know what hit him through his mates...
04:28:42 <wilx> Sniping is lame.... :)
04:28:58 <wilx> I just hate them because my hand is not accurate enough for sniper rifle :)
04:29:07 <Philippa> so snipe with the AK47 instead
04:29:11 <Philippa> it's a much better tool overall
04:29:22 <wilx> Yeah, used to be.
04:29:35 <shapr> I think scout-sniping takes real skill.
04:29:39 <wilx> Now my box is a bit too slow.
04:29:57 <Philippa> shapr: I used to do that just for the fun of jumping around in front of some poor sod with an awm who couldn't track fast enough
04:30:04 <shapr> that's evil :-)
04:30:08 <nlv11757_> sorry, I didnt want to set off an offtopic CS discussion :P:P
04:30:21 <shapr> The best anti-awm tactic really is jumping around with a deagle.
04:30:23 <TFK> Right. ET is so much better.
04:30:24 <Philippa> once nailed an entire team single-handed on... damn, what's it called, the canyon/wooden house one?
04:30:33 <shapr> siege maybe?
04:30:43 <Philippa> what do you think my sidearm was? :-)
04:31:05 <Philippa> though these days it's really not that accurate unless you crouch
04:31:20 <shapr> deagle had surprisingly good wall penetration, you could pick off people and they'd have zero clue where you were.
04:31:32 <Philippa> yeah, BTDT
04:31:35 <Philippa> so did the AK, mind
04:31:45 <Philippa> killing people through walls was very much my speciality
04:31:54 <shapr> yeah, but AK has a high cooldown time for repeated accurate shooting.
04:32:03 * Philippa remembers shooting somebody on the rope bridge on aztec from behind a wall in front of two of his mates
04:32:05 <Philippa> the mates ran
04:32:11 <Philippa> not that high compared to the deagle
04:32:23 <shapr> yeah, but deagle is dirt cheap :-)
04:32:30 <Philippa> and the AK has 30 rounds in it :-)
04:33:00 <shapr> AK is likely the cost/performance.
04:33:03 <Philippa> also, the AK's a lot more useful if you get bumrushed by somebody - if you manage to point dead-center, there's only two guns that'll out-shoot you
04:33:04 <shapr> er "the best"
04:33:17 <Philippa> (MAC-10 with lucky scatter, awm because it kills you dead)
04:33:33 <shapr> I really loved the P90, it was like infinite firecrackers.
04:33:45 <shapr> no real damage, no real accuracy, but it made noise forever.
04:34:09 <Philippa> I enjoyed the MAC-10 and the TMP just for the humiliation factor - short of being knifed, it's about as bad as you can get
04:34:14 <shapr> truly
04:34:28 <Philippa> I mean, at least the pistols shoot straight
04:34:29 <shapr> people who used TMP and got high scores were the obvious masters just out to embarass people.
04:34:48 <shapr> mac-10 is really an excellent close range gun.
04:35:08 <Philippa> give or take, at more than 3m you need to be standing still to use it...
04:35:21 <shapr> when your team is being totally wasted, buy the mac-10, and at some point you'll get lucky enough to stand behind several rich members of the opposite team and flay them instantly.
04:35:27 * Philippa nods
04:35:38 * Itkovian wonders what game is being discussed
04:35:50 <shapr> The TMP is more like being beaten to death with a wet noodle.
04:36:02 <Philippa> Itkovian: counter-strike
04:36:07 <Philippa> the TMP you needed a headshot with really
04:36:17 <Philippa> hence the whole close-range jump-and-swing-down pattern
04:36:20 <shapr> even then, with a helmet you need more than one hit.
04:36:49 <Philippa> yeah. The technique felt a little like swinging a club though
04:36:59 <shapr> I played way too much counter-strike, I'm much happier putting time into programming.
04:37:55 <Philippa> I would've much preferred to've been playing UT instead, much more fun game for me
04:38:02 <earthy> falling into the middle of that communication would peg the two of you as gun nuts
04:38:10 <Philippa> programming doesn't quite let me play the same way
04:38:12 * Itkovian has never played CS ...
04:38:18 <shapr> I probably qualify as a low-level gun nut in reality too.
04:38:21 <nlv11757_> itkovian, i accidently triggered a CS discussion ;)
04:38:25 <Itkovian> np
04:38:29 <Philippa> earthy: 'scommon with counterstrike, 'til you realise the game's utterly unrealistic still
04:38:41 <shapr> Yeah, CS isn't that real.
04:38:48 <shapr> AA is closer, but still not that real
04:39:30 <shapr> The reality is that violence is a black hole for resources that society can't really afford to begin with.
04:39:32 <Itkovian> guns are evil. give me a nice scimitar and my crossbow, and then we're talking
04:39:34 <Philippa> older versions (like before they nerfed jumping completely) had really scarily stylised combat
04:40:14 <Philippa> heh. I'd rather a modern pistol than the crossbow, assuming QCB, but I'm with you on the blade
04:40:29 <shapr> arbalest anyone?
04:41:35 <Philippa> anyway, I don't get the same kind of flow from coding
04:41:47 <shapr> Have you tried pair programming?
04:42:17 <Philippa> not really, though I kind of fail to see how I would anyway - there's not really any room for sub-second decision-making
04:42:22 <shapr> Combat games are like lightspeed chess for me, and pair programming is a lot closer to that same hyperfocus flow.
04:42:53 <Philippa> I wouldn't say chess, the phase space looks all wrong, but yeah
04:43:38 <shapr> I do think that rush will be available in the cracking tools of the future btw.
04:44:23 <Philippa> that'd make sense
04:44:39 <shapr> That'll be the ultimate combat game rush, which sort of worries me.
04:44:53 <Philippa> a lot of what slows it down for me in coding is that mistakes have a different significance
04:45:05 <Philippa> coding's like playing and having to get a perfect round every time
04:45:11 <shapr> Yeah, I know what you mean.
04:45:19 <Philippa> which is bad when you run up against a problem that keeps trying to chip you with specials
04:45:27 <shapr> ?
04:45:32 <Philippa> you never played SF2 or relations?
04:45:33 <shapr> chip you with specials?
04:45:44 <shapr> Oh, that sort of problem.
04:45:48 <Philippa> in those, if you block a special move you still take a small amount of damage
04:45:53 <shapr> right, I see what you mean.
04:46:11 <shapr> Happily SF2 et al are designed in such a way that there's an open spot after every special.
04:46:28 <Philippa> it used to be recognised where I played that if you got floored with no health left but not KOed, there'd be a coup de grace fireball on its way
04:46:37 <Philippa> but not before on a lot of them
04:47:04 <Philippa> also, some have very very *small* open spots - there're some characters where you can run out massive patterns that take an extremely well-placed counter to break properly
04:47:30 <shapr> Yeah, like... what was that game? *monster combo*
04:47:39 <shapr> killer instinct maybe?
04:48:02 <Philippa> I'm not really thinking of that so much as games where the combos are generally short but the potential for what Tekken folks call strings is high
04:48:11 <shapr> In programming?
04:48:27 <Philippa> heh
04:48:33 <shapr> :-)
04:48:47 <Philippa> in Tekken, a string's like a combo only there'll be bits where you can potentially block or counter again if you got hit early on
04:49:02 <shapr> Right, I played tekken 3 a bunch.
04:49:06 <Philippa> or similarly, bits where if you /were/ blocking you can hit them instead
04:49:16 * Philippa was very good at forcing opponents to sit in the corner and block in SFA3
04:49:17 <shapr> reversals, etc
04:49:34 <Philippa> *urgh*
04:49:39 <shapr> I very much wish for a legal way to play Tekken 3 on my Linux box.
04:49:49 <Philippa> I just remembered the 3-move looping Dee Jay string from hell
04:50:07 <shapr> Anyway, as that rush applies to programming... ICFP is the closest thing right now.
04:50:20 <Philippa> his fireball has a very short recovery (it's a charge move), but you can keep doing jab -> fireball -> sliding sweep -> jab...
04:50:39 <Philippa> doesn't combo if the sweep hits, but it's very hard to find room for a counter because the sweep ends pretty fast
04:50:44 <shapr> But I had an idea for a strategy combinator library based RTS game in Haskell
04:51:24 <shapr> I think that would get much closer to the split-second rush via programming.
04:51:51 <shapr> and it wouldn't have that "requires a perfect round" problem
04:52:32 <shapr> Sometimes I think the 'perfect round' problem is a cultural issue more than anything else. Look at the great code that shows up in ICFP entries for example.
04:52:34 * rjbs can't help but read that as forall jab. jab -> fireball -> ...
04:52:41 * shapr snickers
04:53:58 <Philippa> shapr: I can do it, generally fairly reliably if I can code at all, I just don't get an adrenaline rush out of it
04:54:01 <shapr> I think maybe the XP approach is more powerful that people know. If you binge up a three day SpikeSolution to a problem, it's often a really nice 80/20 result, where 80% of the problem is solved by 20% of the code.
04:54:30 <shapr> I suggest that's because we don't even try to make programming happen quickly.
04:54:33 <Philippa> there's no equivalent of the 200ms opportunity shot that you happen to get bang on target repeatedly
04:54:51 <Philippa> and in turn I think that's because you can't do that /and/ keep full control over error rates
04:54:58 <shapr> Our tools for programming are extremely primitive, we can't yet do much of anything fast.
04:55:17 <Philippa> a single type error'd be like getting smacked around the walls in wipeout so bad you lose control for ten seconds then go off the course
04:55:39 <Philippa> then get put back in a position that you can't take properly because you need to be going at speed... YSWIM?
04:56:10 <shapr> Ron Jeffries wrote about the first time he used a refactoring browser, he said that he would do a refactoring, then sit there for five minutes not really doing much, he realized that was his given cycle for refactoring. He said he needed to think "bigger refactoring thoughts."
04:56:15 <Philippa> besides, IMO a lot of the point of good coding is removing the need to do that much raw manipulation in the first place
04:56:26 <shapr> Yeah, totally.
04:56:33 <shapr> But the current culture doesn't realize that.
04:56:38 <Philippa> I agree I'd like good refactoring tools for haskell
04:57:00 <Philippa> I've wasted enough hours doing easily-specified refactorings as-is
04:57:07 <shapr> I'm just saying that the programming culture is stuck in big loops because we think wasting time is normal.
04:57:12 <Philippa> (oh for a pretty-printer for all the TH types...)
04:57:20 * Philippa nods
04:57:30 <Philippa> I get this blank look sometimes when I explain to folks what I like about Haskell
04:57:47 <Philippa> "surely it can't be rigorous/safe/well-written if it happened that quickly?"
04:57:54 <Philippa> rather than "it's so simple it /has/ to work"
04:58:08 <shapr> I get that same blank look when I try to explain to folks why running an electric refrigerator inside a grocery store is stupid when it's -29 celsius outside.
04:58:50 <Philippa> there's the minor potential advantage of having a nicer storefront for the customer, but yeah
04:58:59 <Philippa> (I'd rather not be standing outside looking at stuff if it's that cold)
04:59:01 <Itkovian> ?
04:59:01 <nlv11757_> ever tried generic haskell?
04:59:03 <Itkovian> hehe
04:59:06 <Itkovian> sorry
04:59:21 <Philippa> nlv11757_: I've not, haven't really had a good use for it
04:59:31 <shapr> Actually, given a TH pretty-printer, some way to turn a source file into TH types, and TH as syntax, Haskell could be a whole 'nother world.
05:00:03 <nlv11757_> if you want to do stuff generic for user defined data types, it's fantastic :)
05:00:04 <Philippa> yeah. Though admittedly I'd really like a way to preserve my taste in layout across transformations
05:00:38 <shapr> Just need a Configurable pretty-printer, something like used in refactoring browsers.
05:01:06 <Philippa> yeah, I guess the problem I see is specifying all the "I do this when it's like this, but that when..." cases
05:01:39 <shapr> I especially wish for a way to suck a source file into TH types.
05:02:32 <Philippa> I guess I can think of one way to really really badly cheat
05:02:36 <shapr> I like the idea of a cheesy GHC JIT that uses -prof, TH, and hs-plugins.
05:02:36 <Philippa> it involves CPP though
05:02:46 <shapr> How so?
05:02:55 <Philippa> #include the damn thing inside oxford brackets
05:03:00 <shapr> wha?
05:03:08 <Philippa> just quasi-quote the lot
05:03:14 * shapr thinks
05:03:20 * shapr tries
05:03:27 <Philippa> doesn't have the same power, but hey
05:03:37 <Philippa> (can't load random files, for example)
05:03:46 <shapr> Right, but.. will it really work that way?
05:03:57 <earthy> poor david roundy
05:04:41 <Philippa> shapr: should do, though thinking about it you might need the module bit stripped
05:05:08 <shapr> I'm confused...
05:05:46 <shapr> something like themodule = [| at the top of the file, and |] at the bottom?
05:06:24 <Philippa> yeah
05:06:40 <Philippa> only you can't have the module Foo where... bit, sadly
05:06:46 <Philippa> and it'd have to be [d|...]
05:06:53 <Philippa> [d|...|], even
05:07:04 <shapr> ?
05:07:26 <Philippa> RTFM on GHC's implementation, you'll see what I mean
05:08:24 * shapr reads http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html
05:10:07 <shapr> Can you show me a tiny working demo of [d| ?
05:10:29 <Lemmih> [d| x = undefined |]
05:10:40 <TheHunter> hey folks.
05:10:42 <Philippa> it just takes a pile of declarations rather than an expression
05:11:36 <shapr> Ah, I was having indentation problems. I can't just throw themodule = [d| at the top.
05:12:38 <Philippa> would themodule=<newline>[d|...|] work?
05:12:58 <Philippa> failing that, can you call a filter when you #include?
05:13:06 <shapr> that might work
05:13:28 <shapr> putting [d| at the beginning of the line doesn't seem to work
05:15:07 <shapr> That's a cool idea.
05:15:09 <earthy> um, metaperl? you present? you have succeeded in practicing discordianism...
05:15:58 <shapr> metaperl_: hail eris!
05:16:14 * shapr laughs at haskell-cafe
05:16:18 <earthy> exactly :)
05:16:46 <shapr> I suspect neither David nor Henning have read the Principia Discordia.
05:16:54 <shapr> Which is too bad, because that's where I got my last name.
05:17:08 <earthy> :)
05:17:37 <shapr> Philippa: so, themodule is now TH types?
05:17:51 * shapr is having difficult wrenching his brain out of lamE etc
05:17:59 <Philippa> shapr: should be
05:18:07 <Philippa> specifically, Q [Dec]
05:18:25 <shapr> Huh
05:18:25 <Philippa> it's the same stuff as the quasiquoted code in that lil' compiler of mine
05:18:50 <Philippa> so if you want to grok it, there's an example for you
05:18:53 <shapr> So I could use this to fake hs-plugins by running my whole app in TH in --make, right?
05:19:07 <shapr> That is, assuming the #include + indent filter trick works...
05:19:47 <Philippa> er, maybe?
05:20:00 <Philippa> no. Staging won't work
05:20:05 <shapr> won't?
05:20:31 <Philippa> you can piece together an app, you can't run it. You'd have to write an interpreter for the TH types still
05:21:32 <shapr> can't you reify the TH types?
05:22:07 <Philippa> yes, but while the reification occurs at compile-time their execution occurs at run-time
05:22:20 <shapr> with TH, compile-time is run-time.
05:22:37 <shapr> or maybe I'm just confused..
05:22:57 <Philippa> Okay, let me rephrase: your program has many stages, each of which has a run-time that compiles the next stage (if there is one)
05:23:06 <shapr> Right, I got that.
05:23:21 <Philippa> so TH run-time is main app compile time. Reification doesn't allow you to run stuff in this stage, it runs in the next
05:23:33 <Philippa> or rather, splicing doesn't
05:24:32 <Philippa> if you think of code running at various splice depths, with an ordinary haskell prog being depth 0 and the foo in $(foo) running one level deeper than the code around it...
05:24:41 <shapr> Right, I get that.
05:24:54 <Philippa> splice level 1 can't run code in splice level 0
05:25:00 <Philippa> not directly, at least
05:25:14 <Philippa> I mean, it can borrow the definitions, but not those it's in the process of splicing in
05:25:17 <shapr> Right, I was thinking of making the program work like recursive descent parsers, but for TH splice levels.
05:25:28 <Philippa> you'd end up with an infinitely-deep splice if you tried it
05:25:37 <shapr> Is that a problem?
05:25:42 <Philippa> yes
05:25:48 <Philippa> you never get to actually run the code
05:25:54 <shapr> can't treat a splice like a monadic bind?
05:26:08 <Philippa> feel free to talk to implementation folks about it
05:26:20 <shapr> I stil don't really get it. I need to go read the papers again.
05:26:36 <shapr> But it sounds like I got my understanding of splice levels reversed.
05:27:21 <Philippa> thinking about it, the #1 thing that makes sense is that when you compile the bits that run at level 1, they can't see the declarations you're going to splice into level 0
05:27:29 <shapr> I was thinking that the code 'right here' could both run the program, and optionally generate a new splice to jump to.
05:29:00 <shapr> Yes, I definitely need to reread the TH papers.
05:29:03 <Lunar^> shapr: I thought a bad joke yesterday
05:29:17 <shapr> oui?
05:29:55 <Lunar^> shapr: Weddings are like lazy bindings: if there's an error, you never know when it'll raise...
05:29:58 <shapr> Qu'est-ce que c'est?
05:30:15 <shapr> That is a pretty bad joke. Funny too :-)
05:30:46 <Lunar^> shapr: :)
05:30:58 <Lunar^> shapr: I told you :)
05:32:37 <shapr> Philippa: oh, I think I get it now.
05:32:48 <shapr> Hm, that sort of makes sense.
05:34:20 <TheHunter> No instance for (MonadIO Q). Why?
05:35:05 <shapr> It has its own runQ or something in 6.4
05:35:25 <shapr> main = putStrLn $( Q (putStr "hello at compile time from Template Haskell!\n") >> [| "hello at runtime from Template Haskell!" |] )
05:35:41 <TheHunter> *Main> :t qRunIO
05:35:41 <TheHunter> qRunIO :: forall (m :: * -> *) a. (Quasi m) => IO a -> m a
05:35:41 <TheHunter> *
05:35:52 <shapr> right, that one.
05:36:02 <shapr> the code I just pasted is 6.2
05:36:12 <shapr> needs qRunIO in 6.4
05:36:26 <TheHunter> but still. why? Clearly Q should be an instance of MonadIO
05:37:09 <shapr> keine ahnung :-)
05:37:19 <TheHunter> heh.
05:37:40 <TheHunter> how's swedish treating you, btw?
05:38:28 <shapr> Just fine except that I mostly use it on IRC, so my reading comprehension is great, listening comprehension is terrible.
05:40:06 <shapr> German is getting easier as I learn Swedish, they're surprisingly close.
05:40:19 <shapr> aning vs ahnung
05:45:18 <TheHunter> nice. How far is the planning for the second edition of TMR? (I might write an article).
05:45:43 <earthy> is the 1st edition out already? :)
05:45:56 <earthy> german and swedish are surprisingly far away
05:46:10 * earthy knows dutch and german and swedish is much like gibberish
06:06:56 <tuomov> doesn't any common scripting language have strptime or the equivalent?
06:07:02 <tuomov> calling 'date -d date +better_format' thousands of times takes a while..
06:08:06 <tuomov> (I don't want anglo-centric dates in my changelogs!)
06:08:24 <tuomov> (And fixing darcs is so much work..)
06:15:53 <nlv11757_> german and dutch are very close
06:16:18 <nlv11757_> with respect to language (not soccer of course :P)
06:28:02 <earthy> ghe
06:36:50 <tromp> here's a thing that bugs me about constants in haskell
06:37:16 <tromp> i can give sensible names to constants , like loss = -1, draw = 0, etc
06:37:28 <tromp> but in case expressions, i cannot use the names
06:38:17 <tromp> case score of 0 ... works, but not case score of draw ...
06:38:20 <ozone> tromp: data Outcome = Loss | Draw
06:38:25 <ozone> case score of Draw -> ...
06:38:43 <tromp> but i want to use number properties of these values
06:39:00 <tromp> i want to negate them, and use them as index
06:39:49 <ozone> hmm.  the short answer is that it sounds like you're not doing it in a haskell-ish way
06:39:57 <ozone> but unfortunately, i don't have time to help you.  maybe one of the others here can
06:40:21 <ozone> (note: i know the short answer sounds arrogant, sorry, didn't mean to imply that)
06:40:24 <tromp> some things are just most naturally represented as integer constants
06:40:40 <TheHunter> you could use the c preprocessor...
06:41:07 <tromp> why can't haskell accept names for constants in case expressions?
06:42:12 <Lemmih> How would you differ between new bindings and constants?
06:42:35 <tromp> what do you mean with new bindings?
06:42:44 <Lemmih> 'case a of Just b -> b'
06:43:40 <tromp> that's alrd allowed
06:43:48 <Lemmih> And 'somefunc x = undefined' shouldn't depend on the definition of 'x'.
06:43:53 <tromp> Just b is not a constant
06:44:07 <Lemmih> tromp: But what if somebody defined b?
06:44:36 <tromp> then Just b is still no constant
06:44:44 <kosmikus> tromp: just define a datatype plus a mapping from this datatype to int
06:45:02 <nlv11757_> exactly
06:45:07 <nlv11757_> that would be more of a haskell way
06:45:09 <tromp> i'm talking about 0 argument functions defined to equal a 0 argument constructor
06:45:27 <nlv11757_> if you want to use this value 0 and -1, define a function that will attach this semantics to your datatype
06:45:44 <TheHunter> people want "views" surprisingly often, is there a good reason why they haven't been implemented?
06:45:45 <tromp> that'd be ugly kosmikus, to duplicate the Ints with diferent names
06:45:55 <Lemmih> tromp: 'case a of Just b -> b; c -> someFn c' that shouldn't depend on previous definitions of 'c'.
06:46:55 <kosmikus> tromp: no, I don't think so, it's making the conversion explicit
06:47:31 <nlv11757_> btw why would you need to use the value 0 or -1 if you are doing a case....you already know what the value is in each branch right?
06:47:53 <tromp> i'm doing lots of arithmetic with these values, kosmikus
06:47:57 <kosmikus> TheHunter: I can only remember the argument about them hiding computational complexity and being somewhat counterintuitive in the case that they don't implement an isomorphism
06:49:02 <kosmikus> tromp: I still don't see the problem, I guess
06:49:37 <tromp> the problem is i don't see myself writing 2 pages of code for instance Num Outcome
06:50:08 <Lemmih> tromp: What about using guards?
06:50:12 <TheHunter> hmm, hiding computational complexity is the whole point of views. Anyway, we have pattern guards.
06:50:17 <kosmikus> you shouldn't define a Num instance, you should either derive Enum, or define one conversion function
06:50:21 <tromp> just to make something that's just Ints with other constant names
06:50:45 <tromp> no, Enum wldnt do, since i use addition, negation, etc
06:51:04 <kosmikus> TheHunter: personally, I'm all in favor of views; much more than making constants special and to allow them in patterns (don't know how this could work syntactically anyway)
06:51:25 <earthy> tromp: then, what is the difference between your stuff and actual Ints?
06:51:27 <kosmikus> tromp: yes, on integers
06:51:45 <kosmikus> tromp: with enum, you can convert to integers
06:52:00 <tromp> earthy, i want to use the name draw for zero
06:52:09 <kosmikus> @type fromEnum
06:52:10 <tromp> and loss for -2
06:52:11 <lambdabot> fromEnum :: forall a. (Enum a) => a -> Int
06:52:32 <TheHunter> kosmikus, yeah, me too.
06:54:40 <earthy> instance Enum Outcome where fromEnum Draw = 0; fromEnum Loss = -2; toEnum 0 = Draw; toEnum -2 = Loss; toEnum _ = error;
06:54:47 <earthy> something like that should do what you want
06:55:35 <tromp> except that my code wld get uglier because of the many conversions
06:56:31 <nlv11757_> you could always program C of course :P
06:56:35 <kosmikus> I wouldn't use Enum if it doesn't map to an interval of Int
06:57:37 <earthy> tromp: what many conversions? you only convert where necessary to calculate
06:57:43 <earthy> if you don't want that, overload Num
06:58:24 <tromp> i only have once instance of this case expr, i have like a dozen instances of aithmetic
06:58:27 <araujo> Hello all
06:58:31 <araujo> Greetings kosmikus 8)
06:58:53 <earthy> and you don't like guards?
06:58:54 <tromp> why add a page of int-duplication definitions to make that case expr look better?
06:58:59 <kosmikus> tromp: guess you have to live with it for now, then; views would save you, but probably won't happen anytime soon
06:59:02 <tromp> i alrd have guards
06:59:06 <tromp> my case looks like
06:59:12 <tromp>           case x of
06:59:12 <tromp>             Nothing -> negawork wdw gs
06:59:12 <tromp>             Just (score, work) -> case score of
06:59:12 <tromp>               -1 | wdw /=  1 -> negawork (-1) gs -- lossdraw case
06:59:12 <tromp>               1  | wdw /= -1 -> negawork   1  gs -- drawwin case
06:59:13 <tromp>               _ -> return score
06:59:52 <kosmikus> araujo: hi
07:00:08 <tromp> here i'd like to replace -1 by lossdraw and 1 by drawwin
07:01:10 <TheHunter> tromp, why not use the c preproocessor? It's easily invoked using -cpp and can do exactly what you want.
07:01:30 <tromp> i just rewrote it to
07:01:31 <tromp>             Just (score, work) -> case score of
07:01:31 <tromp>               -1 | wdw /=  drawwin -> negawork lossdraw gs
07:01:31 <tromp>               1  | wdw /= lossdraw -> negawork drawwin  gs
07:01:58 <tromp> i feel it's something of a sin, TheHunter:(
07:02:16 <earthy> and what is wrong with
07:02:17 <earthy> if score == lossdraw && wdw /= drawwin then negawork (-1) gs
07:02:17 <earthy>     else if score == drawwin && wdw /= lossdraw then negawork 1 gs
07:02:17 <earthy>         else return score
07:02:43 <tromp> the case looks clearer
07:02:58 <TheHunter> is that a sin, too? http://www.cs.york.ac.uk/fp/cpphs/
07:03:18 <PerlJam> seems like a mapping would be even clearer
07:03:26 * earthy nods
07:03:55 <tromp> a mapping?
07:04:11 <earthy> from the tuple (score,wdw) to the correct negawork call
07:04:24 <earthy> anyway, gotta go
07:04:48 <tromp> btw, something else puzzles me... about if then else layout
07:05:16 <tromp> i have a statement
07:05:18 <tromp>     (if v <= s then negamoves  wdw s gs best else
07:05:18 <tromp>       if v <= wdw then negamoves 1 v gs    i else
07:05:18 <tromp>                negamoves undefined w []    i) (i:tried) poscnt
07:05:40 <tromp> if i try to indent the 2nd if one space back, i get an error
07:06:44 <nlv11757_> because then it's suddenly on the same level as the first if
07:06:45 <tromp> oh wait, now it's gone:(
07:06:51 <nlv11757_> instead if belonging to the first one
07:06:52 <nlv11757_> ok
07:06:52 <kosmikus> you can always do the  case x of _ | guard1 -> ... | guard2 -> ... | guard3 -> ... trick
07:07:03 <kosmikus> sometimes looks nicer than nested if-then-elses
07:09:29 <tromp> i think i'm being too aesthetically perfectionistic:(
07:11:02 * TheHunter looks suspiciously at the "don't use guards use if" part in ThingsToAvoid.
07:15:56 <kosmikus> well, yes, pattern matching is better than guards in general, but not necessarily worse than nested if-then-else
07:16:17 <kosmikus> tromp: nothing wrong with being perfectionistic; I probably am, too
07:19:11 * kosmikus didn't know this ThingsToAvoid page; seems like there's a lot there I can disagree with ;)
07:19:31 <tromp> we need a ThingsToDisAgree with page:)
07:19:50 * shapr grins
07:20:14 <shapr> I think it's better to have reasons why to avoid, then people can make up their own mind.
07:20:53 <shapr> y0 Coz
07:20:56 <shapr> wazzup?
07:22:39 <PerlJam> hey shapr
07:22:54 <shapr> y0 PerlJam, last time I talked to you was years back in #python.
07:23:27 <shapr> How's life?
07:23:30 * Itkovian thinks guards/pattern matching have nice uses, and usually make for an readable piece of code
07:24:26 <CosmicRay> morning shapr
07:24:51 <PerlJam> shapr: it's good.  I'm learning haskell (obviously)
07:24:59 <shapr> How do you like it so far?
07:25:11 <PerlJam> It's great!
07:25:31 <shapr> I went from Python to Haskell, starting about the time the first version of Stackless was denied entry by Guido.
07:25:49 <PerlJam> I still don't have a FP mindset quite yet, but I'm getting there.
07:26:22 <PerlJam> (It's been years since I used Scheme/Lisp and even then it was only for play or for school)
07:26:34 <shapr> I like the FP mindset, it's a powerful tool to have available.
07:26:45 <PerlJam> indeed
07:27:09 <shapr> It's led me to some neat patterns, have you gotten to monads yet?
07:27:35 <PerlJam> Plus when I saw how fast autrijus turned out the beginnings of a perl6 compiler in haskell, I figured there had to be *something* to haskell  ;-)
07:27:41 <shapr> Oh hey, I deploy my first Haskell software for a client this week :-)
07:27:55 <PerlJam> shapr: yeah, I've played with monads.   Still wrapping my mind around them though.
07:28:15 <Itkovian> PerlJam: some others are doing the same :-)
07:28:24 <shapr> I can give you the five minute simple explanation of monads, if you like.
07:28:34 <PerlJam> Yesterday Cale tried explaining monads but stopped short of going into category theory.  I kind of wish he would have continued.
07:29:07 <PerlJam> shapr: feel free.  The more explanations the better!
07:29:50 <shapr> Act I, Scene 1, ... which item is executed first in [2 + 3, 5 + 1] ?
07:30:25 <shapr> PerlJam: what do you think?
07:30:28 <tromp> raises his hand
07:30:31 * shapr grins
07:30:53 <shapr> tromp: do you already know monads?
07:31:07 <tromp> sure
07:31:07 <PerlJam> shapr: the comma!  :)
07:31:10 <metaperl> Haskell is a non-deterministic execution model much like a database or spreadsheet
07:31:22 <Philippa> not true, it's fully deterministic
07:31:29 <Philippa> you just need to see the whole program
07:31:30 <metaperl> in haskell, you program in DWIM not DWIS
07:31:55 <shapr> As others have just said, the correct answer is really "it depends".
07:32:03 <shapr> tromp: what was your answer?
07:32:09 <Philippa> [2+3, 5+1] will, roughly speaking, evaluate to (2+3):((5+1):[])
07:32:16 <nnunley> Hrm.  Question from the perl6 crowd... Is there a proper Haskell code coverage tool?
07:32:22 <tromp> same; depends on what you do with it
07:32:38 <Philippa> the bits either side of the : won't be evaluated until they're demanded
07:32:52 <Philippa> which means that it's entirely possible that the 5+1 will be evaluated before the 2+3
07:32:52 <metaperl> Phillppa, you cons'ed the results of the 2 additions together...
07:33:09 <metaperl> the original question had a comma there
07:33:11 <Philippa> [2+3,5+1] is a list
07:33:12 <metaperl> oh, sorry
07:33:14 <metaperl> yes
07:33:36 <shapr> PerlJam: Problem is that if you have a complete lack of order in a program, it would end up looking like my room. So, how to get order anyways in Haskell? Got any suggestions?
07:33:37 <Philippa> the important bit is that the immediate result is just that outermost cons
07:33:45 <Philippa> the bits in parens won't have been evaluated yet
07:33:57 <Igloo> nnunley: What exactly do you want it to do?
07:34:00 <Philippa> interpret an ordered language!
07:34:01 <metaperl> but haskell is a lazy language and there is no way to get the 2nd element of a list before the 1st. so when this list is first accessed for values, the first addition will occur
07:34:18 <tromp> sure there's a way to get the tail before the head
07:34:21 <Igloo> nnunley: You can use quickcheck to test a function on randomly generated testcases
07:34:21 <Philippa> metaperl: you can get the 2nd cons cell without evaluating the value in the first
07:34:27 <shapr> Right, the first cell will just be a thunk.
07:34:35 <tromp> ignorehead (_:t) = t
07:34:35 <metaperl> (head . tail) lis
07:34:39 <Philippa> eg case (_:xs) -> frigWith xs
07:34:45 <metaperl> oh
07:34:52 <metaperl> I see
07:35:00 <metaperl> so I think "on-demand" is the key here
07:35:04 <Philippa> yes
07:35:07 <metaperl> nothing is computed until requested
07:35:21 <PerlJam> metaperl: just like perl6!  ;)
07:35:22 <tromp> so you can take: length [undefined, undefined]
07:35:25 <nnunley> Igloo: I think the desire is to find out what percentage of a Haskell code base a test suite touches, actually.  The suite already exists.
07:35:38 <shapr> aka 'call-by-need'
07:35:41 <PerlJam> metaperl: in fact, perl6 has taken that concept so far that the compiler doesn't even exist yet!  ;-)
07:35:48 <metaperl> lol
07:35:56 <Philippa> metaperl: similarly, you can use case statements to force evaluation
07:36:06 <Philippa> anyway, I gotta go see the doc. Back later.
07:36:13 <Igloo> Hmm, can't think of anything OTTOMH
07:36:48 <shapr> I think Hat has some coverage tools, and I vaguely recall figuring out that QuickCheck plus some -W settings might be able to do it.
07:36:52 <shapr> Anyway, back to monads...
07:37:01 <nnunley> shapr: Thanks.
07:37:09 <shapr> Sometimes you want to force order anyway.
07:37:13 <PerlJam> shapr: so ... order through function application?
07:37:21 <shapr> PerlJam: oh I like that...
07:37:24 <CosmicRay> I have to go to a meeting, but I would like to ask all your perl6 hackers a favor: I think it would be very interesting if one of you could just write up a brief summary of what perl6 is about and why you're interested in learning about haskell, and post it to -cafe
07:37:24 <shapr> how would you do it?
07:37:50 <shapr> nnunley: if you ask me again tomorrow, I'll likely have time to look into it further.
07:37:53 <CosmicRay> I must admit almost complete ignorance about perl6, and I suspect there are others in the haskell community that would be interested to know why there is suddenly interest in haskell from perl6 hackers
07:38:00 <CosmicRay> and with that, I must afk....
07:38:29 <PerlJam> CosmicRay: the main  thrust of interest is because autrijus is writing a perl6 compiler *really* *fast* in Haskell.
07:39:15 <shapr> Haskell is really good at writing interpreters and compilers quickly.
07:39:29 <PerlJam> Actually not even that.  The perl community has been waiting for perl6 so long that any development that shows progress gets people's attention.
07:39:31 <shapr> One of the nice idioms in the Haskell world is "Domain Specific Languages"
07:39:51 <PerlJam> shapr: strange, I think of perl when I hear that phrase.
07:40:47 <shapr> That would be a neat subject to compare notes on..
07:41:36 <shapr> So, how would you force order via function application?
07:41:46 <shapr> got any wild ideas or random thoughts or anything?
07:42:03 <metaperl> head lis
07:42:10 <metaperl> lis = [4+5, 6+1]
07:42:12 <metaperl> head lis
07:42:21 <metaperl> (head . tail) lis
07:42:22 <PerlJam> head less?
07:42:25 <metaperl> forces 2nd element
07:42:41 <metaperl> head lis -- force first element to compute
07:42:52 <metaperl> (head . tail) lis --- for 2nd element to compute
07:42:52 <PerlJam> shapr: no, I'm afraid I'm not thinking too clearly at the moment (work stuff is intruding upon my play time ;-)
07:42:59 <shapr> hah
07:44:09 <shapr> Ok, the nutshell story is that you could have a function do something and return a new function that is 'the next thing to do' sort of.
07:44:38 <PerlJam> that sounds *so* familiar ...
07:44:42 <shapr> really?
07:44:58 <PerlJam> wasn't there a CPU with an assembly language like that back in the 70s?
07:45:04 <Itkovian> hmm ... generating a firefox preview of wiki pages is rather fubar.
07:45:04 <tromp> transputer
07:45:13 <PerlJam> except there weren't "functions" but "instructions"
07:45:13 <tromp> occam is like CSP
07:45:53 <shapr> I was just looking at http://www.transterpreter.org/ today.
07:45:55 <PerlJam> each instruction would essentially carry a continuation with it that told the CPU what to do next.
07:46:00 <shapr> right, exactly.
07:46:30 <shapr> so, the super short story is that monads are just a cute flavor of CPS
07:47:00 <shapr> and a nice way to order computations in a call-by-need evaluation setting.
07:47:47 * PerlJam still wants the category theory explanation at some point :)
07:47:48 <shapr> the ingredients required are just one partially filled in type, and two functions. One function puts things into the container type, and the other function stick together two functions.
07:47:58 <shapr> er wait
07:48:02 <shapr> sticks together two containers
07:48:03 <shapr> doh
07:48:44 <shapr> That was the basics, you want an example?
07:49:22 <shapr> Oh, if you like type signature oriented explanations, I can show you how the two functions look.
07:51:05 <PerlJam> I want to understand Parsec basically  :-)
07:51:24 <shapr> enough to use? or enough to write your own?
07:51:38 <PerlJam> both
07:51:49 <shapr> first is easy, second is a bit harder.
07:51:57 <shapr> You know recursive descent parsers?
07:52:07 <PerlJam> sure
07:52:14 <shapr> @type (>>=)
07:52:16 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
07:53:08 <shapr> A monadic parser is something that ends up looking like (input_string -> (Symbol,rest_of_string))
07:53:55 <shapr> And then (input_string -> (Symbol,(rest_of_string -> (Symbol2,even_less_of_string))))
07:54:22 * shapr doesn't know if this is a particularly helpful explanation.
07:54:50 <PerlJam> shapr: you have svn?
07:55:10 <shapr> I think I have the client installed.
07:55:35 <shapr> Though I am more a fan of darcs, since I enjoy hacking in Haskell.
07:55:43 <PerlJam> get http://svn.openfoundry.org/pugs/src and you can explain some of pugs to me :)
07:55:50 <PerlJam> oh, there's a darc repos too
07:56:03 <PerlJam> It's on pugscode.org somewhere
07:56:42 <shapr> Man that dog is so cute :-)
07:57:00 <PerlJam> I wonder if the darcs repos is kept up-to-date though now that svn has become the primary scm
07:58:02 <shapr> One of my first Haskell projects was writing an RFC822 parser with Parsec. Parsec is way spiffy.
07:59:27 <PerlJam> pugs doesn't use Parsec (at least I don't think it does yet), but autrijus says that Parsec can do almost all of the stuff planned for the new Perl6 "rules" syntax
08:00:00 <shapr> Lexer.hs uses Parsec at least.
08:00:23 <PerlJam> If true, we're just a hop+skip+jump away from a full perl6 bootstrapping compiler written in haskell
08:03:08 <shapr> Do you have parsec installed?
08:04:05 <PerlJam> Does it come with GCH?  If not, then no.  :-)  Right now, I'm just trying to learn enough to understand the pugs code.
08:04:16 <shapr> GCH?
08:04:20 <shapr> ohh, GHC
08:04:26 <PerlJam> er, GHC
08:07:41 <shapr> PerlJam: This is how I learned Parsec - http://www.cs.uu.nl/~daan/download/parsec/parsec.html
08:09:50 <PerlJam> shapr: thanks.
08:09:59 * PerlJam is off to do some work now.
08:10:02 <shapr> ok
08:10:19 <shapr> Ask me when you start the Parsec tutorial, I can help you out.
08:10:24 * shapr does work also
08:16:21 <shapr> Can I get GHC for Fedora Core 2 via yum?
08:17:03 <nlv11757_> yeah
08:17:05 <nlv11757_> you can
08:17:13 <shapr> spiffy
08:17:35 <nlv11757_> hey cool daan's parsec :)
08:17:41 <shapr> You know Daan?
08:17:46 <nlv11757_> he's a teacher of mine
08:17:52 <nlv11757_> im from cs.uu.nl
08:18:01 <nlv11757_> he
08:18:07 <nlv11757_> is also behind wxhaskell
08:18:14 <shapr> Cool, I met Daan at ICFP03, he's wild and fun.
08:18:14 <nlv11757_> and haskelldb
08:18:23 <nlv11757_> i know :) you know doaitse?
08:18:45 <shapr> I also met Doaitse at ICFP03, I'm not sure if he remembers me though.
08:19:10 <nlv11757_> he's my current mentor
08:20:13 <shapr> He's a smart guy. The parser combinators he did with Duponcheel caused a big change in the FP world.
08:21:32 <nlv11757_> ah yes, funny that you guys know that. I always thought it was kind of a local to the university thing that doaitse was always explaining to us
08:21:33 <nlv11757_> :D
08:22:27 <shapr> Swiersta&Duponcheel's parsers was the motive for John Hughes to find arrows, that's definitely a neat thing.
08:22:52 <nlv11757_> wow hehe, doaitse is more famous than i thought :D
08:23:09 <shapr> There's some interesting creative tension between the uu.nl Attribute Grammar camp and the Arrows users.
08:23:20 <shapr> hiya alexj
08:23:30 <nlv11757_> ah yes, i was brought up with UUAG
08:23:55 <shapr> alexj: S. Alexander?
08:24:08 <alexj> yes.  good eye!
08:24:15 <shapr> Hi, I'm Shae Erisson.
08:24:53 <alexj> oh.  I was just replying to your email and saw the sig about IRC and decided to pop by.
08:24:56 <alexj> convenient.
08:25:37 <shapr> alexj: Are you Swedish?
08:25:44 <shapr> talar du svenska?
08:25:48 <alexj> no.  from New York City.
08:25:55 <glimming> Philippa, did you reach any more conclusions about your subtyping rule for coproducts?
08:25:56 <shapr> Ok then :-)
08:26:08 <glimming> Jag talar svenska.
08:26:11 <glimming> ;-)
08:26:12 <alexj> though it seems that there is a swedish haskell mafia.
08:26:13 <glimming> No news.
08:26:13 <shapr> heh
08:26:35 <glimming> I have a questions for all you wizards.
08:26:39 <glimming> Namely...
08:26:42 <shapr> alexj: I am not part of the Swedish Haskell Underground. And even if I were, it doesn't exist.
08:26:43 * shapr grins
08:27:09 <glimming> (so is existence witnessed by membership?)
08:27:10 <bringert_> first rule of the Swedish haskell Undergroud: ...
08:27:15 <shapr> bringert_: haha
08:27:34 <glimming> what does it mean to have a structural rule in a type system?
08:27:41 <shapr> Speaking Swedish Haskell Underground, you think John Hughes is going to get rooms for EuroHaskell?
08:27:42 <glimming> Or to make structural assumptions.
08:27:52 <shapr> alexj: have you seen Peter Simons' postmaster?
08:28:08 <alexj> its been on my agenda, but I haven't done so yet.
08:28:17 <bringert> shapr: I'm sure we can arrange something
08:28:33 <shapr> ok, cool.
08:28:45 <shapr> alexj: his fast IO stuff might be useful for you.
08:28:45 <alexj> I feel like he and I are doing things that are both the same and different.
08:28:49 <alexj> ok.
08:28:55 <shapr> You may also be interested in HSQL and/or HaskellDB
08:29:09 <nlv11757_> i promote daan's stuff :P
08:29:28 <lisppaste2> metaperl pasted "error in my attempt to use getLine" at http://paste.lisp.org/display/6027
08:29:40 <alexj> they are both more for talking to external DBMSs
08:29:49 <shapr> alexj: not HaskellDB
08:29:52 <alexj> ?
08:30:10 <alexj> oh, my impression is that it was to give a nice haskell api to external dbms
08:30:11 <bringert> well, noone has implemented a HaskellDB HarDBMS backend yet
08:30:20 <alexj> :- )
08:30:22 <bringert> but it should be possible
08:30:24 <shapr> HaskellDB is about exposing set theory directly in the language, sounds familiar?
08:30:34 <alexj> oh!
08:30:41 <alexj> ok then I should look more carefully.
08:30:55 <shapr> You already know about Tutorial D and that sort of stuff?
08:31:03 <shapr> Third Manifesto, or whatever it's called these days?
08:31:04 <alexj> the Table interface I have is sort of ad hoc for the actual development I am doing.
08:31:24 <alexj> I see that stuff, and skim it.  It feels a bit ungrounded.
08:31:52 <alexj> I was more interested in a convenient interface for my development process.
08:32:04 <shapr> What sort of interface?
08:32:39 <alexj> is it rude to pase source here?
08:32:58 <shapr> three lines max
08:33:02 <shapr> otherwise
08:33:06 <shapr> @wiki HaskellIrcPastePage
08:33:06 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:33:58 <alexj> 	loginUsed = isJust $ state appCtx // tUser // getOne ?? UserLogin === (userLogin userData)
08:33:58 <alexj> 	state' = u_tUser (insert1 user) $ state appCtx
08:34:30 <alexj> these are the main database lines from some code to do a user registration.
08:34:30 <metaperl> paste.lisp.org/new/haskell works too
08:34:52 <metaperl>  case num of
08:34:53 <metaperl>            0 -> return []
08:34:53 <metaperl>            _ -> { rest <- ask_for_numbers ; return num : rest }
08:35:07 <shapr> alexj: maybe use a monad?
08:35:24 <shapr> I dunno, I'd have to look at the code more.
08:35:32 <shapr> Which file is that from?
08:35:42 <alexj> code I am writing now to use HAppS
08:35:56 <alexj> I am writing an auction system.
08:36:01 <shapr> oh, neat
08:37:41 <shapr> hm, isn't // sort of like $ turned around?
08:38:32 <alexj> x // fn = fn x
08:38:51 <alexj> it lets me make database access feel like URLs
08:38:51 <shapr> Have you seen the swing combinator?
08:39:28 <shapr> swing is on here - http://www.haskell.org/hawiki/LicensedPreludeExts
08:39:37 <alexj> no, what is that?  (FYI I just pased my full reg code in http://www.haskell.org/hawiki/HaskellIrcPastePage#preview )
08:39:46 <shapr> swing f = flip (f . flip ($))
08:40:07 <shapr> swing swaps 'function' and 'data' spots in a function
08:40:47 <alexj> (createUser is as concise as I think is possible)
08:41:19 <alexj> so when do you use swing?
08:41:48 <shapr> I think createUser could be more concise if you used a State monad to pass appCtx
08:42:54 <alexj> yes, I realized after the fact that ACID should have a state monad interface, but I don't understand the statemonad enough to do it.
08:43:23 <shapr> Once you 'get' monads, they're very addictive.
08:43:33 <shapr> Have you seen the nomaware tutorial?
08:43:46 <alexj> no....
08:43:53 <shapr> http://www.nomaware.com/monads/html/
08:44:04 <shapr> It's the easy way to learn monads, I think.
08:44:17 <alexj> oh swap is really really useful.
08:44:29 <alexj> i have a bunch of functions that are special purpose verions.
08:44:30 <alexj> cool.
08:44:44 <shapr> I think the code for createUser could be less than half the size if you use State and Maybe monads.
08:44:51 <alexj> wow!
08:45:24 <alexj> I am still impressed w/ Haskell being concise compared to other languages.  I forget that you can do even better.
08:45:49 <shapr> Same thing happens to me, everytime I think my code just can't get any smaller, I 'throw it to the wolves' here in #haskell :-)
08:45:58 <alexj> :- )
08:46:37 <lisppaste2> metaperl pasted "help needed printing list read from stdin" at http://paste.lisp.org/display/6028
08:46:37 <shapr> One thing I've learned from doing that repeatedly is that many of the functions in the Prelude are "traversal essences" or whatever the real name is..
08:46:53 <alexj> ?
08:47:15 <alexj> traversal essences?
08:47:28 <shapr> For example, if you have a function that works on one element, map makes that work on a list of elements.
08:48:04 <shapr> If you have a function that takes two inputs and evaluations to a single result, like (+), then the fold function folds a whole list up using that function.
08:48:43 <shapr> When I try to make my code smaller, I try to find where I have special cases of Prelude functions.
08:49:46 <shapr> Hopefully that wasn't confusing.
08:50:10 <alexj> sounds like the scrap boilerplate rhetoric
08:50:28 <Cale> metaperl: you're likely looking for "main = do {list <- ask_for_numbers; mapM_ print list}"
08:50:40 <metaperl> Cale, thanks
08:50:50 <alexj> but i get it.
08:51:09 <Cale> (remember that ask_for_numbers is an IO action, which isn't very showable
08:51:31 <Cale> (and it's also not a list)
08:51:52 <shapr> alexj: I haven't yet had time to try HAppS, but I will have time soon, and as I said before, I'm looking for a way to escape Zope.
08:51:55 <Cale> but it can construct a list if you run it
08:52:25 <alexj> me too!
08:53:28 * shapr tries yum install ghc
08:53:57 <nlv11757_> you do have the right repositories in your yum.conf i assume shapr?
08:54:11 <shapr> no clue
08:54:19 <nlv11757_> then probably not :)
08:54:20 <bringert> alexj: have you been thinking about integrating soap and/or xml-rpc into happs
08:54:24 <bringert> ?
08:54:44 <shapr> I am not normally a RedHat user, what should I add?
08:54:49 <nlv11757_> shapr: http://www.haskell.org/fedora/
08:54:55 <nlv11757_> it's explained there
08:55:02 <shapr> thanks
08:55:09 <nlv11757_> np
08:55:18 <nlv11757_> im off, ocaml is giving me headaches
08:55:21 <shapr> :-)
08:55:35 <alexj> yes, but i was planning to do rest first
08:55:46 <alexj> REST
08:55:46 <bringert> Si\: you're working on soap in haskell and application server stuff, right?
08:56:04 <Si\> amongst other things, yes
08:56:21 <bringert> how far along is the soap stuff?
08:56:57 <Si\> well, you can build server-side Haskell-driven Web-Services with no discovery
08:57:20 <bringert> is there any code or docs online?
08:57:26 <Si\> you could access SOAP client side, but I haven't actually explictly added it yet
08:57:32 <Si\> I've got an article in TMR
08:58:06 <bringert> ok, cool
08:58:09 <alexj> how are you serving the SOAP stuff?
08:58:14 <alexj> (what is TMR?)
08:58:20 <bringert> http://www.haskell.org/hawiki/TheMonadReader
08:58:21 <Si\> TheMonadReader
08:58:48 <Si\> SOAP is served via a modified version of Network.HTTP + A HTTP Server shell
08:59:09 <bringert> Si\: maybe we should do something to unify the interfaces of your SOAP stuff and my xml-rpc library
08:59:54 <bringert> dunno if it's useful, but it feels like there could be some coordination, or at least sharing of ideas
09:00:05 <Huschi> i want to write a program that uses a sdl gui which is written in c via the ffi. the init function is called "sdl_init()" and return an sdl specific pointer. formerly one imported this with <foreign import ccall "sdl_init" prim_sdl_init :: IO Addr>. but Addr is no longer available. what can i do?
09:00:28 <Si\> yes, you might want to have a look at GXS, my XML Serializer, it makes producing XML protocols etc. very simple
09:00:40 <bringert> hmm, cool
09:01:21 <alexj> what HTTP Server shell are you using?
09:01:34 <Si\> my own
09:01:43 <Si\> but it's 95% Network.HTTP
09:01:55 <Si\> and it's very incomplete
09:02:14 <alexj> yeah, mine too.
09:02:26 <alexj> part of the issue is that a lot of the completeness is really application specific.
09:02:58 <bringert> maybe we should try to get some baseline server-side HTTP stuff into Network.HTTP
09:03:20 <alexj> it would be nice if we could have a consistent interface for this stuff....
09:03:27 <alexj> I mean for other servers.
09:03:44 <Si\> yes, I added some stuff, but it's very incomplete, like it can't send chunked transfer (because I didn't have time to read the RFCs to find out the criteria for doing this)
09:04:05 <alexj> In HAppS, I have all the servers taking a function to which they pass (Request,Callback) pairs
09:04:24 <Si\> look at the darcs reps at http://repton.no-ip.com/darcs
09:04:29 <Si\> yes, I do it like that
09:04:49 <bringert> I think Niklas Broberg could be interested to, I think he has written his own webserver for his Haskell Server Pages
09:05:09 <Si\> httpServer :: FilePath -> [HTTPHandler] -> [[XmlTree] -> Config -> Config] -> IO ()
09:05:31 <bringert> hmm, I think a general http server shouldn't just serve xml
09:05:32 <Si\> type HTTPHandler = (String, Config -> [String] -> Request -> IO (Either String Response))
09:05:44 <Si\> it doesn't just server XML
09:05:50 <esap> hmm.. interesting. swing ((.) . (.) . (.)) permutes function arguments. Very interesting stuff.
09:05:53 <Si\> the XML stuff it the config key readers
09:05:58 <Si\> \s\it\is
09:05:58 <bringert> ah, sorry
09:06:30 <Si\> it has an XML Configuration file, and you can fully customize it to make it store what you need for your particular application
09:07:05 <alexj> doHTTP :: forall t.
09:07:05 <alexj>           Host
09:07:05 <alexj>           -> ((Response -> IO (), (SocketInfo, SocketInfo, Request)) -> IO t)
09:07:05 <alexj>              -> IO ThreadId
09:07:10 <Si\> http://repton.no-ip.com/darcs/services/Network/Service/Factorial.hs show's how a very simple Web-Service can be built
09:07:39 <Si\> yes, yours is probably a lot more well thought out
09:07:43 <Si\> I was in a hurry
09:08:17 <bringert> I think the first step shoul be to just implement the protocol, no socket stuff
09:09:15 <bringert> a simple web service with xml-rpc:
09:09:16 <bringert> import Network.XmlRpc.Server
09:09:16 <bringert> add :: Int -> Int -> IO Int
09:09:16 <bringert> add x y = return (x + y)
09:09:16 <bringert> main = cgiXmlRpcServer [("examples.add", fun add)]
09:09:36 <bringert> it uses CGI and an external server though
09:10:04 <TheHunter> @define swing \f -> flip (f . flip id)
09:10:05 <lambdabot> swing defined
09:10:05 <Si\> basically all mine does is take a list of MonadIO m => (URI, Request -> m Response) pairs and uses them to serve out stuff
09:10:43 <bringert> yeah, that sounds like the way to do the higher-level stuff
09:11:40 <Si\> anyway, whatever the Web-Server is, so long as it does that in some way, it'll work with the HAIFA Service Publisher
09:13:02 <alexj> what is the HAIFA Service Publisher?
09:13:32 <Si\> it is supposed to take Haskell functions of various types, and convert them to SOAP operations
09:13:55 <alexj> oh interesting.
09:14:04 <Si\> so say, you give it Input -> Output, and it gives you Request -> m Response
09:14:07 <alexj> I am trying to do something more RESTy in the same vein.
09:14:59 <alexj> I'm still working out the interface.
09:15:14 <Si\> what's REST?
09:15:46 <alexj> the use just has to make sure that Input imlpements fromURLEncoded and Output implements toXML
09:15:56 <alexj> REpresentational State Transfer
09:16:06 <Huschi> how can i call a c funtion of type "void* f()" in haskell, when i need the result only in order to call a function "void g(void*)"?
09:16:19 <alexj> basically the REST folks argue that RPC is the wrong model for web services.
09:16:35 <alexj> specifically it results in a proliferation of verbs and poor interop
09:16:50 <alexj> all resources should expose only GET PUT POST DELETE
09:17:05 <alexj> you design your app within that constraint.
09:17:38 <alexj> http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
09:18:08 <alexj> http://rest.blueoxen.net/cgi-bin/wiki.pl
09:19:02 <alexj> the basic idea is that XML-RPC and SOAP require clients to understand the semantics of everyfunction you expose and that is too hard.
09:19:23 <Si\> yes, they could be right, I didn't implement SOAP because I thought it was a good protocol to implement, but because just about everything in Composite/Semantic Web-Services depend on it atm
09:20:09 <alexj> Amazon says that its REST interface is vastly more popular than its soap interface.
09:20:23 <alexj> other big web services folks typically make the same claim.
09:21:37 <alexj> who is "Composite/Semantic Web-Services"?
09:23:41 <Si\> Composite Web-Services means the creation of larger, more powerful Web-Services using Atomic Services as a basis, with constructs such as Sequence, Choice and Split to put them together
09:24:18 <Si\> Semantic Web-Services are ontologically annotated Web-Services, which enable a machine to reason over the task they perform, in order to fulfil some specific need
09:24:26 <Maddas> Yow
09:25:09 <shapr> @Yow baby!
09:25:10 <lambdabot> Sorry, I don't know the command "Yow", try "lambdabot: @listcommands"
09:25:21 <Maddas> hey shapr :-)
09:25:25 <alexj> if you restrict the verbs, don't a lot of the problems you are describing drop out?
09:26:20 <Si\> I don't know
09:26:50 <Si\> I'll have to take a closer look at REST
09:28:09 <glimming> how do I get latest ghc from CVS?
09:28:22 <glimming> Simon PJ fixed it now so that infix type synonyms work
09:28:50 <glimming> shapr?
09:29:11 <glimming> shapr is probably cycling around his house
09:30:06 <shapr> wha?
09:30:25 <shapr> oh, check out the 'building from cvs' part of http://www.haskell.org/ghc/ it should include directions
09:30:27 <Lemmih> glimming: That information is available from haskell.org/ghc/
09:30:43 <glimming> sure, but there seems to be a password requirement there
09:30:46 <glimming> I try cvs login
09:30:59 <glimming> and I am asked to provide a password which is weird for a read-only access
09:31:06 <shapr> try hitting enter
09:31:09 <shapr> blank password
09:31:12 <shapr> or maybe anonymous
09:31:12 <glimming> I did.
09:31:34 <shapr> I'm pretty sure it's in the docs
09:31:36 <Si\> The question to ask is, can REST solve problems like "I want to get from London to Las Vegas on the 31st of July, please find me the quickest and most cost effective route and debit my account"
09:31:38 <glimming> neither works.
09:32:21 <TheHunter> glimming, if you can wait a few hours, you'll be able to download a binary.
09:32:26 <glimming> password is CVS
09:32:28 <glimming> darn
09:32:30 <glimming> I am blind.
09:32:50 <glimming> so fptools gives me hugs and everything I guess.
09:33:09 <glimming> Binary for Mac OS X?
09:33:13 <glimming> How is that?
09:33:15 <glimming> Final release to ship?
09:33:42 <TheHunter> oh, sorry, only linux-i386
09:33:43 <glimming> btw, anyone had problemsd with libgmp and ghc?
09:33:50 <glimming> nightly linux builds?
09:33:56 <glimming> very cool CVS setup.
09:34:02 <glimming> Wish there was also a build logfile.
09:34:04 <glimming>  nightly.
09:34:55 <glimming> Should be a cluster with a lot of different platforms, each attempting to compile every night, and report log if failure... That would be bloody cool.
09:36:31 <glimming> Filippa, did you think about the subtyping of coproducts?
09:36:36 <glimming> Filippa, I mean
09:39:59 <Philippa> yes. Look, I have my planned type system worked out and I'm not overly in the mood to repeat the details yet again. I just haven't written an inference algorithm for it yet
09:40:37 <Philippa> well, not the full version. I have the subtyping relationship for algebraic datatypes on what's otherwise basic hindley-milner
09:41:24 <Philippa> and it's a pretty trivial extension, and it works
09:42:35 <bringert> Huschi: maybe using the Ptr type?
09:45:02 <glimming> Ahhh. Philippa, you are angry?
09:45:30 <Philippa> Let's just say I'm not having a good day
09:45:57 <glimming> Right. Well I was thinking about the rule for recursive types, and I think you could consider it too. But never mind then.
09:47:56 <Philippa> again, I do not need a rule for recursive types. Feel free to read up on algebraic datatypes to understand why
09:48:39 <Philippa> if you can't find the information anywhere else, TaPL mentions it as a side-note and ATTaPL covers them fully in the chapter on type inference
09:49:08 <Philippa> it may help to consider the fact ADTs are named
09:49:19 <glimming> what is ATTaPL?
09:49:32 <Philippa> the recently-released follow-on to TaPL
09:49:48 <glimming> Anyone used Makefile with emacs?
09:49:50 <glimming> Pierce have a new book?
09:49:51 <Philippa> though it's more a collection of chapters on different subjects than a continuous progression the way TaPL is
09:50:08 <Philippa> and Pierce was for the most part the editor rather than the author
09:50:51 <glimming> sweet
09:52:03 <Philippa> anyway, I may as well finish the explanation: ADTs manage the recursion by referring to themselves by name rather than by structure
09:53:01 <Philippa> which means you don't need a separate rule, because you can just look up the name any time it matters
09:53:53 <Philippa> similarly, this is why in the real world we use constructs like letrec rather than messing around with fixpoint operators
09:56:50 <glimming> Aha
09:57:16 <glimming> Do you know something about structural assumptions in typing rules?
09:58:29 <Philippa> you mean assumptions about the structure of types?
09:58:37 * Philippa shrugs
09:58:44 <Philippa> oh look, he's buggered off again
09:59:44 <Si\> alexj: This does look very interesting, are there any papers about it?
10:01:52 <alexj> paper?
10:02:06 <alexj> for REST?
10:02:12 <Si\> yes
10:02:28 <alexj> the two URLs I gave should probably have other pointers.
10:02:34 <alexj> Roy Fielding is the author of HTTP
10:02:46 <alexj> arguably RFC2616 is the revelevant paper :- )
10:03:08 <Si\> I can't deny the fact about Web-Service complexity, that's why I've only implemented SOAP/1.1
10:03:11 <Philippa> *blink**click*
10:03:12 <Philippa> gottit
10:03:53 <Si\> and I've considered before why SOAP doesn't take advantage of the Web's intrinsic hierarchy, like why does a single URI encapsulate several operations?
10:04:59 <alexj> ?
10:05:09 <Philippa> because then you have no direct way to specify the entity carrying them out?
10:05:40 <Philippa> (well yeah, you do, it's the path...)
10:06:36 <Philippa> basically, you could do it but OO folks don't think like that - select the object, send it a message
10:06:43 <alexj> the diffrernce between OO and REST is that in OO you have lots of object types each with custom methods
10:06:55 <glimming> What happened?
10:07:08 <alexj> in REST you only have 4 methods and navigate by hypertext
10:07:24 <alexj> you can have infinite urls
10:07:53 <Si\> that's what I meant alexj
10:08:34 <glimming> when I checkout fptools I get only ghc-6.2.2
10:08:40 <alexj> ok
10:08:55 <Philippa> 6.4's not been released yet
10:09:03 <glimming> Sure, but in CVS it should be somewhere?
10:09:08 <glimming> Simon PJ said it was in CVS.
10:09:12 <Philippa> yeah, just not in the releases branch
10:09:25 <glimming> So it is in the head branch?
10:09:29 <Igloo> What did you check out?
10:09:33 <glimming> how do I get that?
10:09:36 <glimming> cvs co fptools
10:09:38 <glimming> what else?
10:09:40 <glimming> ;-)
10:09:46 <Igloo> That should give you the head and 6.5 by dfefault
10:10:12 <Igloo> What amkes you think it's 6.2.2?
10:10:19 <glimming> I must be crazy.
10:10:28 <alexj> shapr, i just took a look at haskelldb
10:10:32 <glimming> I was starring at the wrong directory. Sorry...................
10:11:00 <glimming> But there is no ./configure thingie in this dir.
10:11:08 <alexj> it seems to work very differently from my HAppS.DBMS
10:11:10 <glimming> (Anyone got this to work on Mac OS X?)
10:11:45 <alexj> in particlar a lot of stuff is identified by strings
10:11:49 <glimming> Igloo, how did you build it?
10:12:08 <Igloo> The web page tells you doesn't it?
10:12:18 <glimming> Who is literate?
10:13:52 <alexj> the design assumptions feel like they are really about talking to something external
10:14:08 <alexj> bringert, are you here?
10:16:33 * CosmicRay returns for awhile
10:16:37 <CosmicRay> @seen syntaxninja
10:16:38 <lambdabot> I haven't seen syntaxninja
10:17:01 <CosmicRay> @seen SyntaxNinja
10:17:01 <lambdabot> I saw SyntaxNinja leaving #haskell 16 hours 48 minutes 21 seconds ago.
10:17:34 <CosmicRay> lambdabot: you are an overly-sensitive extract from a JVM core file
10:17:35 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
10:17:50 <CosmicRay> sometimes it's fun to insult a bot :-)
10:18:57 <glimming> Igloo, haven't find in fo so far.
10:19:50 <glimming> With autoconf I created ./configure
10:20:00 <tmoertel> when did lambdabot stop responding to @more ?
10:20:17 <metaperl_> tmoertel, hi
10:20:26 <tmoertel> metaperl_: howdy!
10:20:33 <metaperl_> i mentioned your Lectrotest framework on extremeperl@yahoogroups.com
10:20:45 <tmoertel> metaperl_: did you get attacked ?
10:20:48 <tmoertel> :)
10:21:00 <metaperl_> there was a bit of feedback but I cant remember much. no no hate, just a bit of misunderstanding
10:21:18 <tmoertel> metaperl_: no pitchforks, then? that's good.
10:21:25 <metaperl_> i run the Perl software design mailing list. we are a bit quiet at the moment but always welcome new posts: www.metaperl.com/sw-design
10:21:41 <metaperl_> yes, you also uploaded something else to CPAN which was haskell-ish...
10:21:45 * metaperl_ checks CPAN
10:22:01 <metaperl_> oh yes, Autocurry
10:22:40 <metaperl_> i'm surprised you havent joined #perl6 --- since we have a working compiler for perl6 written in Haskell... did you hear about it?
10:23:39 <tmoertel> i'm actually trying to avoid pugs because of my limited time; if I get sucked in, my work might suffer
10:24:28 <Heffalump> who wrote that?
10:24:32 <metaperl_> tmoertel, oh. also have you seen Bivio? the Bivio::Test module is quite concise as well
10:24:37 <metaperl_> www.bivio.biz
10:24:44 <metaperl_> Heffalump, wrote what?
10:24:45 * tmoertel follows link
10:24:47 <glimming> Finally, I found relevant info for building http://www.haskell.org/ghc/docs/latest/html/building/sec-building-from-source.html
10:24:48 <xerox> joy joy joy
10:25:12 <Heffalump> the perl6 compiler in Haskell
10:25:16 <metaperl_> autrijus tang
10:25:26 <metaperl_> join #perl6 ... the topic has all the urls
10:25:37 <metaperl_> he is making amazing progress...
10:26:23 <metaperl_> tmoertel, the bivio petshop demo is impressive.. especially if you look at the view code.
10:26:52 <metaperl_> it has a nice authentication/ authorization scheme and clean separation of agent, model, view and controller... the mailing list is yahoogroups.com/group/bivio-bop
10:27:20 <Oeje1> Uuuuyeaaah.  Gotta love pop under advertisements.
10:28:45 <bringert> alexj: no I am
10:28:47 <bringert> now
10:28:50 <Si\> alexj: GXS should be able to provide almost drop in support for XML to what you've got already
10:30:52 * bringert is writing a GF grammar
10:30:55 <bringert> "The knee throws a correct cold stone"
10:31:00 <bringert> "Many persons suck some lakes"
10:31:18 <bringert> "The breast pulls the mother of few stars"
10:31:26 <bringert> random generation is fun
10:31:48 <bringert> "The flower squeezes other trees"
10:32:35 <Lunar^> bringert: GF?
10:33:01 * tic tries to write an interpreter, but constantly falls asleep.
10:33:23 <bringert> hi Lunar^
10:33:45 <bringert> http://www.cs.chalmers.se/~aarne/GF/
10:33:58 <bringert> a grammar formalism
10:34:15 <bringert> good for writing multilingual natural language grammars
10:34:42 <bringert> the sentences above are random-generated from the grammar I'm writing
10:35:06 <bringert> ok, time to go home
10:35:09 <bringert> later
10:59:30 <alexj> si\ GXS?
10:59:53 <Si\> yes, it's the part of my project which perform Haskell data-type serialization
11:00:17 <alexj> oh, that was indeed my next step.
11:00:19 <Si\> on the most basic level, it serializes a hierarchy of record syntax data-types to the obvious XML structure
11:00:24 <alexj> where is that?
11:00:34 <alexj> awesome!
11:00:52 <Si\> http://repton.no-ip.com/darcs/haifa (it's the main part of HAIFA)
11:00:59 <Si\> but it's also fully customizable
11:01:07 <Si\> it's featured in my TMR article as well
11:01:17 <alexj> I think HaXML does this too, but IIRC the produced XML was not so great.
11:01:52 <Si\> it's hard to customize XML without full type-class based specialization which is what GXS does
11:02:39 <Si\> still needs some work, but should certainly be useful
11:03:18 <Si\> one thing I like about this whole REST thing is how easy it would be to convert a service to a Web-site, all you need is a few XSLT transforms
11:03:41 <alexj> that is the basic premise of what I am doing.
11:03:58 <alexj> you can put XSLT PIs at the top of the XML and you have a user friendly regular website
11:04:12 <alexj> XSLT is built into most modern browsers.
11:04:18 <alexj> Google uses it in google maps.
11:04:30 <Si\> I'm just so suprised I'd never heard of REST before
11:04:47 <alexj> I don't know what to tell you.
11:05:04 <alexj> it is so simple that the big vendors can't sell complex products around it.
11:05:06 <humasect> TMR has articles already ? =o
11:05:22 <Si\> I know for sure it has one ;)
11:05:28 <Si\> (at least)
11:05:32 <humasect> aha
11:17:34 <alexj> is the TMR article live?
11:18:33 <tuomov> Does anyone have darcs2rss working?
11:18:49 <Si\> TMR isn't out yet
11:19:00 <alexj> k
11:19:03 <alexj> will be back later.
11:19:05 <alexj> cya
11:19:32 <alexj> actually, before I go, Si\ who are you on the mailing list?
11:19:55 <alexj> oh I just checked the haifa source.
11:19:56 <alexj> nevermind.
11:20:03 <alexj> ok cya.
11:29:53 <Si\> alexj: On the mailinglist I am Simon Foster
12:10:18 <tic> Anyone here good at BNFC?
12:12:41 <ibid> why don't you just ask your question
12:13:15 <goron> ibid: Probably because he expects most/all are not.
12:13:15 <tic> I want to define a boolean datatype so I can do boolean operations in my interpreter and use the built-in functions, like ==
12:13:45 <ibid> and what seems to be the problem?
12:13:46 <tic> but I'd rather not do an extra constructor to get at the actual boolean value.
12:13:59 <tic> that I can't define Bool as it already exists in GHC.Base.
12:14:34 <tic> So, I want True to end up as a Boolean value in the parse tree, but I don't want it exported in the datatype list.
12:14:40 <tic> Bool, rather.
12:14:41 <ibid> so you'd like to have true as an expression and have it map to prelude's True?
12:14:49 <tic> Yeah, that'd be nice.
12:15:04 <ibid> and you're generating haskell?
12:15:07 <tic> I've defined True and False as terminals, which seems to be the only way
12:15:08 <tic> Yup
12:15:39 <ibid> well, BNFC would create data Expr = ... | True | False | ... from such a definition
12:16:12 <tic> Yup.  I don't really want that, as it clashes with the built-in Bool.
12:16:21 <ibid> yeah, but that's what you'd get
12:16:22 <tic> But I still want to be able to _parse_ the string "True" as Bool True
12:16:33 <ibid> why?
12:16:41 <tic> Uhh, so I can do proper type checking, perhaps?
12:17:03 <tic> 1. Parse -> sexps.  2. Typecheck. 3. Interpret.
12:17:06 <ibid> you can have that even with using some other names besides True and False for the labels
12:17:17 <xerox> is "module" a function, or a keyword?
12:17:22 <ibid> keyword
12:17:33 <xerox> What about "otherwise" ?
12:17:40 <ibid> xerox: it's a constant
12:17:42 <Darius> goron: The question may be answered even if the person doesn't consider themselves "good at BNFC".  In general, asking such questions mildly implies a commitment to providing a (correct) answer that many people are less inclined to take upon themselves.
12:17:45 <tic> xerox, otherwise = True
12:18:01 <xerox> tic, as I tought, thanks.
12:18:12 <tic> ibid, Hm.. You're right on that one. I'll see if I can do something about that. Thanks!
12:19:02 <tic> Grr, no.
12:19:49 <ibid> hmph, 37,7 degrees celsius
12:20:56 <Darius> more like 37.7 degrees Fahrenheit here.
12:22:11 <ibid> that's my temprerature
12:22:28 <ibid> what's 37.7 fahrenheit?
12:22:41 <sond> tic, i thought your were finished with your type checker
12:22:42 <lightstep> almost zero celsius (i think)
12:22:54 <tic> sond, it is.  I'm working on the interpreter.
12:23:11 <tic> ah, so now I remember the problem.
12:23:50 <ibid> yes?
12:23:56 <tic> data Value = VBool Boolean
12:24:02 <tic> data Boolean = BTrue | BFalse
12:24:24 <tic> so I'd have to re-implement equals for my Boolean datatype
12:24:34 <ibid> outside it's -17.7 celsius
12:24:45 <sond> tic, ouch.. that is *much* code
12:24:45 <sond> :)
12:24:48 <tic> now, if I could've used the labels True|False directly, I wouldn't have to do that.
12:25:01 <tic> sond, obviously I have more code than that. :)
12:25:10 <ibid> ahh, *now* i see the problem
12:25:14 <tic> ibid, right. :)
12:25:22 <ibid> i'm out of practice on bnfc but ...
12:25:28 <tic> granted, it's only == and /=, but I'd rather not bother.
12:25:38 <tic> oh well.  Seems I'll have to do just that. :)
12:26:02 <ibid> my first idea would be to translate the bnfc-generated tree into a "bytecode"
12:26:23 <ibid> which could be a similar tree with VBools replaced with Bools etc
12:26:38 <tic> a second-stage pass after the type checker?
12:26:51 <tic> I think I'll just implement == and /=, but thanks anyway. :)
12:27:01 <ibid> you could even do some optimization there :)
12:27:27 <ibid> but yeah, implementing == and /= is what writing an interpreter is all about, essentially ;)
12:27:34 <ibid> (and i'm not kidding)
12:27:37 <Darius> tic: You could just derive Eq.
12:28:03 <ibid> does bnfc allow you to express that?
12:28:06 <tic> Darius, good idea.  Now, I'd need to add that automagically from within BNFC as I'm overwriting the datatypes each time..
12:28:12 <tic> ibid, don't think so.
12:28:21 * tic adds four equals'
12:28:53 <ibid> tic: or instance Eq :)
12:29:13 <tic> ibid, can I do that after I've defined the datatypes? I'm not very good at Haskell.
12:29:35 <ibid> yes
12:29:43 <tic> .... how? :)
12:29:50 <ibid> the usual way :)
12:29:58 <ibid> there is no magic about it
12:30:44 <tic> Yeah, but how's that? :)
12:30:51 <tic> supose I could google it up..
12:31:21 <ibid> instance Eq VBool where
12:31:26 <ibid>   a == b = ...
12:31:28 <ibid> etc
12:31:29 <tic> ah, thanks.
12:31:31 <ibid> iirc :)
12:31:43 <tic> do I need to do add "derive Eq"?
12:31:52 <ibid> you can't
12:31:58 <tic> right.
12:32:23 <ibid> you can't instance and deriving the same class-type combination
12:32:31 <ibid> and derive Eq is not haskell :)
12:33:28 <tic> deriving then.
12:33:38 * tic is a Python guy, really
12:34:07 * ibid is a polyglot :)
12:34:22 <ibid> and i seem to be getting a fever :/
12:34:32 <tic> ouch. :/
12:37:23 <tic> good thing I'm using revision control or I'd ripped my hair out by now. :)
12:37:56 <Darius> Which RCS?
12:39:37 <ibid> darcs, i hope :)
12:45:00 <tic> Perforce.
12:45:18 <tic> ibid, it turns out my Boolean already was deriving Eq. Then using == should Just Work, right?
12:45:34 <ibid> yeah
12:45:43 <tic> okay, but somehow it didn't.
12:45:56 <tic> Couldn't match `Boolean' against `Bool'
12:46:07 <ibid> hm?
12:46:11 <tic> data Boolean = BTrue|BFalse deriving (Eq, Ord, Show)
12:46:29 <tic> so maybe I need to specify -how- they're related to each other w/ the instance?
12:46:55 <ibid> tic: can you show the code that gets that error?
12:46:57 <tic> something like: (3-line paste)
12:46:59 <tic> eval (EEq e1 e2) st = equals (eval e1 st) (eval e2 st)
12:47:07 <tic> where equals (VBool b1) (VBool b2) =  VBool (b1 == b2)
12:47:20 <tic> VBool (Boolean BTrue)
12:47:24 <tic> (or BFalse)
12:47:37 <ibid> wha?
12:47:48 <tic> but as Boolean clearly derives Eq, should't the expression: VBool (b1 == b2) be valid?
12:48:07 <ibid> VBool is a type name? if so, it's not correct
12:48:23 <tic> Vbool is a type name.
12:48:32 <tic> data Value = VBool Boolean | VInt Integer
12:48:39 <ibid> yeah, then V
12:48:41 <ibid> ah
12:48:46 <ibid> ok, it's *not* a type name
12:48:52 <tic> oh, sorry.
12:48:52 <ibid> it's a data constructor
12:48:58 <tic> Right.  I'm not good at Haskell lingo
12:49:11 <tic> so anyway.  Why does it confuse my Boolean == with the Bool ==?
12:49:23 <ibid> it doesn't
12:49:29 <ibid> (==) returns Bool
12:49:32 <Darius> @type (==)
12:49:34 <lambdabot> (==) :: forall a. (Eq a) => a -> a -> Bool
12:49:50 <ibid> what your instance did was define (==) such that the _arguments_ can be Boolean
12:50:17 <tic> but I just removed the instance as Boolean was already defined as "deriving Eq"
12:50:30 <ibid> it doesn't matter
12:50:33 <Darius> tic: It may just be easier to make a function that turns the BNFC data type into a more pleasing data type.
12:50:35 <tic> okay.  trying again - is there a (relatively) painless way of getting == to work with my datatypes?
12:50:41 <ibid> you can't get (==) return anything else than Bool
12:50:43 <tic> Darius, yeah.  Think I'll do that.
12:50:52 <lightstep> you can have boolToBoolean
12:50:58 <sond> maybe you can hide the prelude and redefine (==) :D
12:51:01 <ibid> tic: that's what i suggested earlier :)
12:51:06 <sond> but I don't recommend that
12:51:09 <tic> ibid, ah, sorry,  didn't realize that.
12:51:11 <tic> sond, nah.
12:51:17 <tic> I'll add an adapter.
12:52:59 <tic> Haskell is nice and all, but it seems it's too much brain-wrestling from time to time and too little actual work done.
12:53:39 <tic> whoo! Constructor 'Boolean' not in scope.
12:53:48 <ibid> that's only as long as you try to wrestle with it, and not go with the flow :)
12:54:19 <tic> equals (VBool b1) (VBool b2) = VBool (equals' b1 b2) where equals' (Boolean BTrue) (Boolean BTrue) = Boolean BTrue -- what's wrong?
12:54:38 <lightstep> you dont need the "Boolean" part in the patten
12:54:44 <lightstep> s/patten/pattern/
12:54:53 <ibid> Boolean is a type name, not a data constructor, you can't use it in an expression
12:54:56 <ibid> what lightstep said
12:55:03 * tic is highly confused.
12:55:13 <tic> or wait. Think I'm getting it now.
12:55:18 <tic> Nope.
12:55:38 <ibid> data TypeConstructor = DataConstructor Type Type Type | DataConstructor Type Type
12:55:38 <sond> tic, can you overload the (==) operator in python and have it return something other than Bool?
12:55:41 <ibid> and so on
12:55:41 <tic> ah, found it again.  I can -replace- the word Boolean with either of the words within the definition of Boolean.
12:55:46 <tic> sond, yah.
12:55:48 <metaperl_> is there a points-free way to do this?
12:55:49 <metaperl_>  
12:55:49 <metaperl_> gather_stats lis = (mysum lis, prod lis)
12:55:49 <metaperl_>  
12:55:49 <metaperl_> mysum  = foldr (+) 0
12:55:49 <metaperl_> prod = foldr (*) 1
12:56:05 <Darius> sond:Pthon is dynamically typed.
12:56:06 <lightstep> metaperl_, yes
12:56:18 <sond> hmm yeah, of course..
12:56:29 <lightstep> metaperl_, (&&&) from Control.Arrow is good for that sort of thing
12:56:41 * metaperl_ googles
12:57:01 <ibid> tic: i've found that it helps to think of haskell as a calculus instead of a programming language :)
12:57:10 <tic> ibid, *nod*
12:57:43 <sond> still, overloading (==) to return something other than Bool in Python would lead to pretty confusing code, imho
12:57:44 * CosmicRay finally returns
12:57:46 <lightstep> metaperl_, haskell.org/libraries contains links to lots of lib docs
12:58:04 <CosmicRay> unfortunately it also hasn't been updated in ages
12:58:05 <ibid> tic: a data type declaration is a context-free grammar for the normal forms of terms in that type :)
12:58:07 <CosmicRay> freshmeat has a nice haskell category
12:58:14 <CosmicRay> there is also library stuff on the wiki
12:58:14 <tic> sond, of course.  But it'd be possible to do it.  Not sure off-hand, but it'd involve inheriting from "object" or some such (metaclass programming.)
12:58:15 <CosmicRay> @wiki
12:58:16 <lambdabot> http://www.haskell.org/hawiki/
12:58:22 <cathper> what haskell book would recommend? I'm a mathematian having done a little SML a few years ago, but I would like to learn haskell.
12:58:22 <tic> ibid, yap.
12:58:45 <metaperl_> cathper, YAHT is free and good for me so far
12:58:47 <CosmicRay> ibid: Hmm, I suck at calculus but love haskell.  Can I think of calculus as an expression of Haskell? :-)
12:58:54 <Darius> metaperl_: On a different tack, read
12:58:57 <Darius> @wiki StackOverflow
12:58:58 <lambdabot> http://www.haskell.org/hawiki/StackOverflow
12:59:06 <CosmicRay> cathper: http://www.isi.edu/%7Ehdaume/htut/
12:59:21 <ibid> CosmicRay: i'm not talking about calculus in the high school sense (derivatives etc)
12:59:27 <glimming> 4 hours later I managed to build ghc 6.5 on Mac OS X (though it stopped at GreenCard).
12:59:34 <CosmicRay> also, this is a good book: http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
12:59:36 <glimming> However, I have this problem:
12:59:36 <glimming> ghc-6.5: not built for interactive use
12:59:44 <glimming> Anyone?
12:59:47 * CosmicRay blinks
13:00:08 <CosmicRay> ghc 6.5 you said?
13:00:17 <CosmicRay> aren't we at 6.2.2 right now? :-)
13:00:35 <metaperl_> Darius, thanks
13:00:39 <glimming> This is a CVS verrsion.
13:00:51 <CosmicRay> oh, they've branched for 6.4 already?
13:01:10 <metaperl_> CosmicRay, do you know how to abstract this? gather_stats lis = (mysum lis, prod lis)
13:01:16 <Darius> glimming: You need to build a stage-2 compiler and have a flag set to make GHCi.
13:01:17 <glimming> It compiles well enough on Mac OS X and Simon PJ fixed anonymous type synonyms for infix after I have been asking and asking and asking about this feature.
13:01:19 <cathper> mkay, I'd read that one, but often I think there exists much better books than online tutorials ...
13:01:25 <glimming> Darius, ok.
13:01:33 <tic> yay, works!  thanks guys.
13:01:35 <CosmicRay> metaperl_: you want to take the sum and product over arbitrary data types?
13:01:46 <glimming> Darius, do I need some make parrameters for that?
13:01:57 <glimming> flag is set with ./configure ?
13:02:05 <metaperl_> well mainly just lists of numbers and floats I suppose
13:02:15 <metaperl_> well mainly just lists of integers or floats I suppose
13:02:25 <CosmicRay> metaperl_: ok, well we have the built in Num typeclass
13:02:25 <Darius> glimming: Technically, it should already do that by itself (at least on supported systems), but just look to see if something along those lines is not right.
13:02:32 <CosmicRay> metaperl_: actually + and * are defined across both
13:02:48 <Darius> glimming: It, though, has been a long time since I've built GHC (I think it was 5.4 or so).
13:02:55 <CosmicRay> metaperl_: did you know of Data.List.sum and Data.List.product? :-)
13:03:00 <CosmicRay> @type Data.List.sum
13:03:02 <lambdabot> Data.List.sum :: forall a. (Num a) => [a] -> a
13:03:15 <metaperl_> oh well I am doing my own for a yaht exercise, but I will go look now
13:03:29 <glimming> there is a "make boot"
13:03:31 <glimming> I tried that now
13:03:39 <CosmicRay> metaperl_: ah, in that case, the easiest method would probably involve foldl or foldr
13:03:59 <CosmicRay> try foldl (+) 0 list
13:04:05 <CosmicRay> and foldl (*) 1 list
13:04:25 <Darius> tic: You may want to look at hompages.cwi.nl/~ralf/OOHaskell/src/interpreter/extensible.hs at some point in the future.
13:04:32 <CosmicRay> @type foldl (+) 0
13:04:34 <lambdabot> foldl (+) 0 :: forall b. (Num b) => [b] -> b
13:04:50 <Darius> @type Data.List.foldl' (+) 0
13:04:52 <lambdabot> Data.List.foldl' (+) 0 :: forall b. (Num b) => [b] -> b
13:05:16 <metaperl_> yes, I have already done that
13:05:17 <CosmicRay> metaperl_: is that what you're after?
13:05:23 <tic> Darius, Monads! :)
13:05:29 <CosmicRay> I seem to not quite have grasped what you're looking for
13:05:38 <Darius> tic: Extensible (abstract) syntax and semantics.
13:05:41 <metaperl_> I was just asking about how to abstract the fact that lis was on the RHS and LHS of gather_stats lis = (sum lis, prod lis)
13:05:41 <CosmicRay> what page of YAHT? :-)
13:05:56 <metaperl_> p46 of the PDF
13:06:45 <tic> Darius, saw it.  thanks for the tip and so, think I'll handle with what I'm doing now, though.
13:06:59 <Darius> tic: I wasn't suggesting it right now.
13:07:06 <tic> Darius, that's true. :)
13:07:07 <CosmicRay> metaperl_: since you're using it twice, nothing immediately jumps out at me.  I guess you're looking for a trick involving partial application?
13:07:15 <tic> Darius, just that I'll probably loose the link later on.
13:07:23 <metaperl_> someone told me about &&& but I dont know how to use it
13:07:35 <CosmicRay> @index &&&
13:07:36 <lambdabot> Control.Arrow
13:07:36 <metaperl_> I could create a list of operators
13:07:44 <CosmicRay> ah.  I do not know about &&& either.
13:08:09 * b0gg1e read haskell.org/arrows first then lookup Control.Monad
13:08:27 <metaperl_> operations = [Data.List.sum, Data.List.prod]; answers = map (\func -> func lis) operations
13:08:34 <CosmicRay> metaperl_: true enough, there are some ugly ways to do it... I say ugly because you want a tuple out of it, and there's no automated way to turn a list into a tuple
13:08:52 <glimming> ghc-6.5: error: directory portion of "stage2/basicTypes/BasicTypes.o" does not exist
13:08:59 <glimming> when I type "make stage2"
13:09:04 <glimming>  in compiler/
13:09:08 <metaperl_> ok never mind.
13:09:10 <CosmicRay> glimming: I'd suggest asking on glasgow-users
13:09:12 <Darius> @type Control.Arrow.(&&&)
13:09:13 <lambdabot> bzzt
13:09:15 <metaperl_> I was just trying to cleanup before I got it working
13:09:23 <CosmicRay> metaperl_: sorry, one of the smart people here may have a better idea :-)
13:09:23 <Darius> @type Control.Arrow.&&&
13:09:24 <lambdabot> bzzt
13:09:31 <glimming> CosmicRay, I  just did but I am ***very*** impatient.
13:09:41 <glimming> speeed...
13:09:59 <Philippa> calm the hell down then
13:10:05 <CosmicRay> glimming: I don't think any core ghc hackers, or os x users, hang out here, is all
13:10:13 <glimming> Philippa is always there at rescue ;-))))
13:10:37 <lightstep> (&&&) :: forall a b c d . Arrow a => a b c -> a b d -> a b (c, d)
13:10:39 <CosmicRay> metaperl_: to my eye, your version looks plenty clean
13:10:41 <b0gg1e> well i actually am using os x.
13:10:55 <glimming> Philippa, is this love?
13:10:58 <CosmicRay> yeah see, arrows are one of those areas of haskell that I haven't even *touched* yet.
13:11:04 <b0gg1e> but i havent been following the conversation on this channel for the last hour.
13:11:51 <CosmicRay> metaperl_: in fact, I'd say that this is a perfect case for using a named variable to a function
13:11:54 * glimming smiling
13:11:56 <Philippa> glimming: no, love doesn't generally leave me wanting to rip somebody's testicles off
13:12:07 <Darius> gather_stats = mysum &&& prod
13:12:11 * glimming has no words
13:12:21 * glimming never met this sort of woman before
13:12:40 * Darius can believe that.
13:13:20 * glimming going back to his variance annotations in his thesis (which he thinks is horribly boring)
13:13:57 <b0gg1e> try map (head &&& tail) ["they", "killed", "kenny", "bastards!"] in ghci for fun.
13:15:51 <lightstep> with some sort of (un?)zip it'd be funnier
13:16:42 <lightstep> to put the heads and tails toghether
13:18:31 <ibid> "his wife left him, isn't it wonderful :)"
13:20:38 * jadrian takes some notes, "try to remain calm when Philippa is around"
13:22:58 <glimming> How to get powerset in Haskell?
13:23:12 <Darius> @wiki LicensedPreludeExts
13:23:12 <glimming> Jesus.
13:23:13 <lambdabot> http://www.haskell.org/hawiki/LicensedPreludeExts
13:23:16 <glimming> I mean LaTeX
13:23:28 <glimming> Anyone know how to typeset powerset in LaTeX?
13:23:39 <ibid> glimming: which powerset symbol do you want?
13:23:49 <Darius> glimming: I've seen several symbols used for powerset.  Just pick a P you like.
13:23:50 <ibid> glimming: there is no standard one
13:23:51 <glimming> the most beautiful of course
13:23:56 <ibid> i like 2^X
13:24:12 <glimming> I need a P
13:24:18 <ibid> \mathcal{P}
13:24:21 <Darius> I kind of like a simple calligraphic p
13:24:23 <ibid> why do you need a P?
13:24:25 <glimming> splendid
13:24:26 <glimming> ZF
13:24:26 <Darius> What ibid said.
13:24:37 <ibid> glimming: zf has no particular symbol for it
13:24:52 <glimming> well 2^X is really a function space
13:25:01 <glimming> and set theoretically it may be isomorphic to P(X)
13:25:02 <sqrt> just dont use the greek p. gets people confused.
13:25:05 <ibid> 2^X is the powerset of X
13:25:05 <glimming> but it is not really the same set
13:25:10 <ibid> not a function set
13:25:31 <glimming> 2^X means to me X--->2
13:25:39 <ibid> the nice thing about that notation is |2^X| = 2^|X|
13:25:56 <glimming> yes, that's nice.
13:25:57 <sqrt> they have the same cardinality, but aren't the same, ibid.
13:26:18 <ibid> sqrt: what have the same cardinality but aren't the same?
13:26:32 <Darius> sqrt: If you identify sets with elements of 2^X it is the same.
13:26:35 <sqrt> 2^x and p(x)
13:26:45 <ibid> sqrt: i never said they were the same
13:27:03 <ibid> sqrt: remember, there is no standard notation for this stuff
13:27:07 <glimming> Goldrei sticks to P(X)
13:27:23 <ibid> glimming: any one author of course sticks to a single notation
13:27:28 <glimming> You can use ^ stuff for ordinal/cardinal arithmetic I think
13:27:28 <sqrt> Darius: "identify" means you have a bijective function from one to the other, doesn't it?
13:27:28 <ibid> at least in a single work
13:27:52 <sqrt> ibid: oh, sorry, i thought you said so.
13:28:01 <glimming> ok thanks
13:28:10 <Darius> sqrt: In some cases, in this case you could already do that so I'm talking a stronger identification.
13:28:20 <ibid> sqrt: i said 2^X is a notation for power set of X and that i like it
13:28:40 <ibid> (it is also used for other things)
13:28:53 <Darius> I.e. if a set -is- its charateristic function.
13:29:12 <ibid> the important thing is to pick a notation and stick to it (at least in a single work)
13:29:22 <ibid> and explain the notation:)
13:29:35 <ibid> but i need to go to bed, fever burns :/
13:29:37 <tic> How do I make my Integer be Fractional?
13:29:50 <sqrt> ibid: it is just confusing that it is used for {f | f:X->2 } also
13:29:50 <ibid> tic: you shouldn't
13:30:00 <tic> ibid, then how do I implement my EDiv op?
13:30:18 <ibid> sqrt: most notation is used in more than one meaning in maths
13:30:31 <lisppaste2> metaperl pasted "attempting to generate output for a list of values ... help needed" at http://paste.lisp.org/display/6042
13:30:42 <ibid> sqrt: one just has to live with it
13:30:49 <ibid> tic: what do you want it to do?
13:31:21 <Darius> Most of the time people only really care about things up to isomorphism.  Set theory is one of the few places where that is less typical.
13:31:33 <jlouis> lambdabot: @type mapM_
13:31:34 <lambdabot> mapM_ :: forall m a b. (Monad m) => (a -> m b) -> [a] -> m ()
13:31:45 <jlouis> metaperl_: isn't that what you want instead of map?
13:31:53 <tic> ibid, eval (EDiv e1 e2) st = myDiv (eval e1 st) (eval e2 st) where myDiv (VInt n1) (VInt n2) = VInt (n1 / n2)
13:32:01 <metaperl_> I dont understand mapM_
13:32:06 <jlouis> metaperl_: alternatively, if it returns stuff:
13:32:10 <jlouis> lambdabot: @type mapM
13:32:11 <ibid> tic: you didn't answer the question
13:32:12 <lambdabot> mapM :: forall b m a. (Monad m) => (a -> m b) -> [a] -> m [b]
13:32:25 <metaperl_> I see that, but I dont know what to do with it practically...
13:32:32 <jlouis> metaperl_: it is a map for monads...
13:32:33 <metaperl_> especially since I am not up to monads yet
13:32:35 <ibid> tic: anyway, / is a fractional division, you can't make it work usefully for integers
13:32:39 <Darius> mapM_ is like foreach and such
13:32:42 <ibid> tic: i suspect you may be after `div`
13:32:43 <metaperl_> oh and IO is a monad
13:32:47 <tic> ibid, thank.s
13:32:48 <tic> thanks.
13:33:26 <metaperl_> great! I have it working now. thanks a lot Darius and jlouis
13:33:34 <jlouis> metaperl_: yes, (\num -> panswer "factorial" num (factorial num)) has type Int -> IO (), if I am not mistaken
13:33:52 <jlouis> so map (\num -> panswer "factorial" num (factorial num)) lis gives a list of type [IO ()]
13:34:06 <metaperl_> I could've had a runtime type error
13:34:09 <jlouis> mapM kind of ``hoists'' the IO out from the list
13:34:10 <metaperl_> if I had given floats
13:34:18 <tic> and now, it's time to go to bed.
13:34:19 * ibid goes to bed, bbl
13:34:24 <jlouis> night ibid
13:34:25 <ibid> :)
13:34:25 <metaperl_> because the Sum and Produt would work fine but the factorial would fail
13:34:37 <metaperl_> then again, the factorial would just never terminate
13:34:44 <metaperl_> oh well
13:36:49 <lightstep> that definition of factorial is not very good
13:36:59 <lightstep> @wiki ThingsToAvoid
13:36:59 <lambdabot> http://www.haskell.org/hawiki/ThingsToAvoid
13:37:12 <lightstep> section "Guards"
13:38:00 <sqrt> Darius: it is like, R^2 is not the same as (x,y,0) \in R^3 , but the isomorphism is trivial, so it is tempting to say that they are the same. But never mind.
13:39:55 <Darius> sqrt: In my experience, most branches of math use "the same" for "the same up to isomorphism"
13:41:46 <sqrt> but each branch of math has their 100000 definitions of isomorphism.
13:42:15 <Darius> sqrt: And wonderful, wonderful category theory gets the essence of them in one definition.
13:42:37 <sqrt> yes, but only the essence.
13:42:54 <Darius> The rest follows from the definition of the category.
13:43:05 <sqrt> not only.
13:52:29 <gzl> same thing with "unique" for "unique up to isomorphism"
14:25:00 <lightstep> is using a wxhaskell variable different in any way from using an IORef?
14:25:56 <Philippa_> "wxhaskell variable"? You mean the wrapper around the wxwindows classes?
14:26:17 <Philippa_> you do all the operations in the IO monad and all that stuff, if that's what you mean
14:26:26 <lightstep> i mean something returned from the function `variable'
14:26:32 <glimming> g'nite
14:27:23 <lightstep> something of type Var ()
14:27:37 <lightstep> Var a, that is
14:27:41 <Darius> lightstep: There are some things that you can do with a variable that you can't with an IORef I believe, and I think it may also be synchronized but more or less it's an IORef.
14:28:03 <lightstep> thanks
14:39:02 <glimming> how to I change the default settings for C-c C-c in emacs?
14:39:11 <glimming> I want it to do "make"
14:41:50 <dev9> hello :)
14:42:02 <sqrt> step one join #emacs? i dont know...
14:43:32 <lightstep> yo dev9
14:46:07 <b0gg1e> perhaps rant on some emacs list, that this is impossible with emacs but can easily be done in vi. should get you more answers than you ever wanted...
14:47:15 <Philippa_> heh
14:47:38 <Philippa_> I've seen that generally stated as "to get help with *nix, troll about how the task's impossible"
14:47:47 <Pseudonym> Claim it can't be done in the Haskell type system.  Oleg will find a way.
14:48:45 <b0gg1e> that solution surely can be abstracted out polymorphically.
14:49:07 <Pseudonym> Yeah, it's the Usenet Theory of Finding Out Information.
14:49:13 <Pseudonym> Don't ask, you'll be ignored.
14:49:25 <Pseudonym> Post wrong information and watch the corrections flow in.
14:49:45 <b0gg1e> perhaps szt
14:49:48 <b0gg1e> oops.
14:50:14 <b0gg1e> perhaps start with "when i hit escape" nothing happens.  this surely is a lame editor
14:50:17 <b0gg1e> ."
14:51:05 <jhunZoa> hey anyone know how i can write the function map with foldr ?
14:51:22 <lightstep> yes
14:51:30 <jhunZoa> how?
14:51:47 <Darius> Use the free theorem.
14:51:53 <lightstep> there are many ways
14:52:02 <jhunZoa> well whats the best way? :)
14:52:20 <lightstep> i believe that the free theorem isn't specific enough (not that i know ct)
14:52:25 <lightstep> @type foldr
14:52:26 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
14:52:29 <lightstep> @type map
14:52:30 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
14:52:41 <jhunZoa> i know the types
14:53:02 <lightstep> foldr's b should be map's [b]
14:53:14 <jhunZoa> ye
14:53:30 <jhunZoa> so i thought it would be foldr f [] (x:xs)
14:53:33 <Darius> Fusion of fold should do though.
14:53:52 <b0gg1e> map f l = foldr (\x y -> (f x) : y) [] l
14:54:45 <jhunZoa> whats x and y in that function?
14:54:58 <Darius> map f = foldr ((:) . f) []
14:55:06 <b0gg1e> yes, thats better.
14:55:44 <b0gg1e> albeit i would disagree on this version in terms of readability.  but opinions on style vary of course.
14:55:46 <jhunZoa> wow cool it works :)
14:55:53 <jhunZoa> thx
14:55:53 <lightstep> map = flip foldr [] . ((:) .)
14:56:16 <jhunZoa> im sure my teacher will ask to do this on my exam
14:56:25 <jhunZoa> he loves rewriting everything with foldr
14:56:48 <b0gg1e> be sure to check out foldl, as well.  might be the right thing to do to get an A+
14:57:06 <jhunZoa> we have grades 1-10 ~
14:57:09 <lightstep> reminds me of the guy from a few says ago, that logged in just before (or during?) his exam
14:57:19 <b0gg1e> rofl.
14:57:23 <jhunZoa> during
14:57:24 <jhunZoa> good idea
14:57:27 <b0gg1e> did you people help him?
14:58:06 <lightstep> he had problems with the basics of type classes and algebraic data types
14:58:10 <Darius> foldr (:) [] = id; foldr g e . map f = foldr (g . f) e; so id . map f = map f = foldr (:) [] . map f = foldr ((:) . f) []
14:59:30 <b0gg1e> smart.
15:00:10 <jhunZoa> so how would u write map with foldl? :)
15:00:31 <Darius> jhunZoa: You wouldn't, it wouldn't in general be the same function.
15:00:32 <lightstep> inefficiently
15:00:45 <jhunZoa> ah k
15:00:58 <jhunZoa> well foldr seems the logical choice in all cases
15:01:07 <jhunZoa> i dont expect a question about rewriting in foldl
15:01:26 <b0gg1e> you have to reverse the result, doenst make sense.
15:01:38 <Darius> jhunZoa: See the page StackOverflow for advice on which fold to choose.  But foldr is the one with the nice properties.
15:02:01 <Darius> @wiki StackOverflow
15:02:02 <lambdabot> http://www.haskell.org/hawiki/StackOverflow
15:02:16 <jhunZoa> oh btw any of u know that .se page with a good resource ?
15:02:19 <lightstep> foldl (\l x -> f x:l) []
15:02:35 <lightstep> err, foldl (\l x -> l++[f x]) []
15:02:47 <Pseudonym> Personally, I'd just use map. :-)
15:02:51 <Pseudonym> Or maybe a list comprehension.
15:03:36 <Darius> lightstep: take 10 . foldl (\l x -> l++[f x]) [] . repeat v. take 10 . map f . repeat
15:03:42 <MachinShin> hey +
15:04:04 * Darius tends to use combinators over list comprehensions in most cases (certainly in the simpler ones)
15:04:26 <Philippa_> same here
15:04:30 * Pseudonym is an oldbe, and still thinks in list comprehensions
15:04:37 <Pseudonym> Miranda didn't have a good set of combinators.
15:04:51 <Pseudonym> It had map, filter, foldr and foldl, though.  I guess that's a good set.
15:05:30 <Darius> That's about the set SICP's streams chapter is based on.
15:05:54 <jhunZoa> is it possible to rewrite length with foldr ?
15:05:59 <Pseudonym> Yes.
15:06:01 <Darius> Though list comprehensions seem close to the language it was aiming for except for the loss of the box-and-wires view.
15:06:10 <jhunZoa> how? :)
15:06:13 <Pseudonym> length' xs = length (foldr (:) [] xs)
15:06:18 <Pseudonym> Probably not what you meant, though.
15:06:24 <jhunZoa> hehe no
15:06:46 * lightstep found out he's reading slow because it's 1:06 am
15:06:59 <jhunZoa> i mean more like length' x = foldr (+1) 0 x
15:07:04 <jhunZoa> dunno if that works
15:07:07 <jhunZoa> gonna check now
15:07:13 <Darius> length = foldr (+) 0 . map (const 1) = foldr ((+) . const 1) 0
15:07:43 <Darius> foldr (+) 0 is a (poor) implementation of sum.
15:07:51 <jhunZoa> ye i know
15:08:01 <Darius> Of course, the result is a poor implementation of length.
15:08:14 <jhunZoa> my teacher likes that
15:08:27 <Darius> jhunZoa: Very, very many functions over lists can be written as folds.
15:08:29 <jhunZoa> he thinks foldr is a gods creation
15:08:35 <jhunZoa> ye i know
15:08:40 <jhunZoa> i need to know them all :)
15:09:08 <Darius> Every primitive recursive function over them and then some.
15:09:22 <Pseudonym> Well, he does do it for a good reason.
15:09:28 <glimming> hmmm, how does this bootstrapping business work?
15:09:36 <glimming> is tere a good paper/book on how ghc works?
15:09:48 <Pseudonym> Yes, but it's a bit old.
15:09:50 <glimming> I am intrigued by its compilation - it is like the Linux kernel.
15:09:54 <glimming> PJ
15:09:57 <Darius> There are papers at www.haskell.org/ghc that describe it's implementation and the Commentary.
15:10:02 <glimming> s book I know
15:10:07 <jhunZoa> <Darius> length = foldr (+) 0 . map (const 1) = foldr ((+) . const 1) 0
15:10:10 <jhunZoa> that doesnt work
15:10:11 <Pseudonym> http://citeseer.ist.psu.edu/peytonjones92implementing.html
15:10:14 <glimming> Yes, but those papers are very technical
15:10:17 <Pseudonym> That's _the_ paper on GHC's internals.
15:10:26 <b0gg1e> how to write length in terms of foldr when using lists that are not of type [Int]?
15:10:35 <Pseudonym> But it helps if you've read one of Peyton-Jones' books on the subject first.
15:10:46 <Pseudonym> IFPL was the one I read first.
15:10:49 <Pseudonym> And it's now online!
15:10:51 <Darius> @eval foldr (+) 0 . map (const 1) $ [1,3,5]
15:10:51 <lambdabot> (line 1, column 8):
15:10:51 <lambdabot> unexpected "+"
15:10:51 <lambdabot> expecting simple term
15:10:59 <b0gg1e> ah.
15:11:00 <b0gg1e> ok.
15:11:05 <Darius> @eval foldr (\x y.x+y) 0 . map (const 1) $ [1,3,5]
15:11:06 <lambdabot> 3
15:11:06 <Pseudonym> http://research.microsoft.com/Users/simonpj/papers/slpj-book-1987/
15:11:07 <glimming> Is there a C core in ghc?
15:11:25 <Pseudonym> Excellent book, that.
15:11:26 <Darius> @eval foldr ((\x y.x+y) . const 1) 0 [1,3,5]
15:11:27 <lambdabot> 3
15:11:37 <glimming> yes I have that book
15:11:46 <jhunZoa> \x y.x+y is better then the other?
15:11:47 <Darius> jhunZoa: That was a calculation not a definition.
15:11:58 <jhunZoa> oh k
15:12:01 <Pseudonym> Well if you've read it, and you understood most of it, then you can go to the 1992 paper.
15:12:23 <Darius> jhunZoa: @eval is not a Haskell implementation, simply a mildly sugared LC one.
15:12:33 <Darius> Though it does also accept (\x y -> x+y)
15:12:35 <glimming> I can sell it for big price
15:12:41 <Darius> But I never added sections to the parser.
15:12:49 <glimming> Is there a PDF version of the book too?
15:12:53 <jhunZoa> ah ok
15:13:08 <glimming> (But I haven
15:13:13 <glimming> t really planned to sell it)
15:13:24 <glimming> (I request PDF because if I want students to use it)
15:13:37 <Philippa_> glimming: GHC's RTS is implemented in C, the compiler itself was bootstrapped via another Haskell compiler
15:13:54 <Pseudonym> glimming: Take a look at what's in the .tar.gz on the main page.
15:13:57 <Pseudonym> It might be PDF.
15:14:17 <glimming> Would it not be wiser to have a minimal core in C still?
15:14:17 * b0gg1e did not know about const.
15:14:24 <glimming> and first make that core in stage 1
15:14:27 <Darius> Or since GHC can compile to C, it can generate C files that can be compiled to bootstrap itself (from presumably another machine or older GHC version)
15:14:28 <glimming> and then build it in stage 2
15:14:28 <glimming> etc.
15:14:45 <Philippa_> glimming: there was already a Haskell compiler in existance at the time
15:14:48 <glimming> Aha, that's nice.
15:14:57 <glimming> hbc?
15:15:01 <Philippa_> also, assuming I'm not going crazy, an interpreter would've been sufficient to have it self-compile?
15:15:42 <glimming> It takes ages to build stage 2 anyway, so interpreter would be insane. ;-)
15:15:50 <Darius> Philippa_: It should, though the thought of building GHC with an interpreted implementation in Hugs is somewhat scary.
15:15:56 <Pseudonym> Gofer existed at the time.
15:16:15 <glimming> Hmmm.
15:16:21 <Pseudonym> Gofer used to be a G machine interpreter, just like in IFPL.
15:16:31 <Darius> Gofer's pretty close, but was it close enough for GHC back then?
15:16:33 <glimming> There might be bugs in the bootstrapping target
15:16:42 <Pseudonym> I think the first compiler might actually have been Yale Haskell.
15:16:42 <glimming> and those bugs might propagate all the way up
15:16:51 <Pseudonym> But I can't remember for sure.
15:17:15 <Pseudonym> Probably it was a pre-existing FP implementation that was tweaked to support Haskell.
15:17:21 <Philippa_> glimming: old well-known fact, that
15:17:30 <glimming> has it happened?
15:17:56 <Pseudonym> Haskell was developed because Miranda was proprietary, so every academic came out with their own Miranda-like language.
15:18:07 <Pseudonym> The point of Haskell was to avoid duplication of effort.
15:18:14 <glimming> is bootstrapping used for gcc too?
15:18:25 <Darius> What were the other lazy languages of that time? LML, Gofer, ...?
15:18:25 <glimming> it is kind of used for the Linux kernel I guess?
15:18:38 <Pseudonym> Darius: Miracula, Orwell...
15:19:01 <glimming> How did these languages compare to haskell?
15:19:06 <glimming> Where they pure?
15:19:12 <Pseudonym> Mostly.
15:19:19 <Pseudonym> This was before the days of monads.
15:19:26 <Pseudonym> So I/O often wasn't completely pure.
15:19:29 <glimming> inference?
15:19:34 <Pseudonym> But then, they were mostly toys.
15:19:46 <Pseudonym> So I/O wasn't a huge imperative (pardon the pun).
15:20:29 <glimming> In those day, there were no I/O
15:20:50 <Pseudonym> No, there was I/O.
15:20:56 <Pseudonym> readfile :: string -> string
15:20:59 <glimming> (bad joke, I am getting tired)
15:21:07 <Pseudonym> Given a filename, return the contents of the file.
15:21:40 <glimming> Anyway, when is effects such an issue for you?
15:21:48 <glimming> Does it really matter?
15:21:57 <glimming> Do you reason with your programs anyway?
15:22:23 <Pseudonym> It's not me who does the reasoning, it's the compiler.
15:22:26 <Darius> glimming: Most people would like to know that they've opened a file before they write to it before they close it and that all of those things actually happen.
15:22:47 <Pseudonym> I find that with a pure language, I have to reason _less_.
15:22:55 <Pseudonym> Because there are fewer things that could affect this piece of code.
15:23:23 <Darius> I find that with a pure language I -actually- reason more whereas with typical imperative languages I just go "this should work...".
15:23:33 <Pseudonym> :-)
15:23:38 <Pseudonym> That's a good way of putting it.
15:24:11 <glimming> well, if the compiler does the reasoning then why does OCaml beat ghc while having effects.
15:24:12 <Pseudonym> People tend to find with pure languages, especially if they have a Milner-like type system, that once the compiler accepts your code, it's almost always correct.
15:24:25 <jadrian> Philippa_: lol!
15:24:26 <Pseudonym> glimming: Because O'Caml isn't lazy.
15:24:27 <metaperl_> is there a wiki node explaining why Haskell is the purest? even more so than ML or Scheme?
15:24:27 <jadrian> opss
15:24:51 <Pseudonym> You do pay a performance price for using lazy evaluation.
15:25:06 <Pseudonym> Sometimes you win it back, if your algorithm is tuned for lazy evaluation.
15:25:12 <metaperl_> is Haskell the only actively developed purely functional language
15:25:12 <Pseudonym> But that's not the common case.
15:25:26 <Pseudonym> metaperl_: No.  Concurrent Clean is also actively developed.
15:25:52 <metaperl_> I see, but they dont have the ICFP results that Haskell has
15:25:56 <glimming> Scheme is not pure?
15:26:12 <Darius> metaperl_: OCaml typically does pretty well in the ICFP contests.
15:26:19 <Philippa_> no, it's much like any other lisp in that regard
15:27:08 <glimming> Goodnight....
15:27:12 <metaperl_> is OCaml purely functional though?
15:27:12 <Pseudonym> Night.
15:27:19 <Pseudonym> metaperl_: No, it's impure.,
15:27:30 <Pseudonym> It has references and impure I/O.
15:27:33 <glimming> Goodnight Philippa_ you are a sweet lady.
15:27:41 <Pseudonym> Awwww.
15:27:45 <Pseudonym> That's lovely.
15:27:46 <Oeje1> metaperl_: ICFP results are very much determined by talent/experience.  Some years Xavier Leroy participated, who is also working on the OCaml compiler.  Needless to say, he did well.
15:28:08 <glimming> Swedish irony.
15:28:23 <Pseudonym> Yes, we have irony in Australia, too.
15:28:27 <Pseudonym> :-)
15:28:33 <glimming> Congratulations.
15:28:52 <Pseudonym> No worries.  You have a bonza night.
15:29:00 <glimming> ;-)
15:29:02 <Oeje1> We don't have any in Denmark.  :-(
15:30:18 <Darius> metaperl_: Haskell isn't the "purest" it simply is pure.
15:30:44 <metaperl_> Clean looks just like Haskell to me.. they claim to have something called uniqueness typing...
15:30:51 <metaperl_> just glancing thru the short intro of course
15:31:00 <Philippa_> uniqueness typing's a significant difference
15:31:14 <Philippa_> basically, you can type values s.t. they get used exactly once
15:31:36 <Oeje1> metaperl_: Uniqueness typing can give you fast arrays.
15:33:17 <Pseudonym> There's also a technical difference.  Haskell is based on lambda calculus, whereas Clean is based on graph reduction.
15:33:33 <Pseudonym> It is a fairly technical difference, though.
15:33:53 <zamez> scary
15:34:03 <Oeje1> Oh, please go deeper.
15:34:15 <sond> pseudonym, Haskell is implemented by graph reduction, and clean is _based_ on it? explain :)
15:34:26 <Pseudonym> Yes.
15:34:48 <Pseudonym> A Haskell function might look like this:
15:34:51 <Pseudonym> @type foldr
15:34:52 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
15:35:00 <Pseudonym> In Clean, you'd do the equivalent of this:
15:35:09 <Pseudonym> foldr :: (a b -> b) b [a] -> b
15:35:33 <Pseudonym> The arguments to foldr are kind of like a 3-tuple.
15:35:42 <Pseudonym> Except that it's not quite like that.
15:35:48 <Pseudonym> It's a graph node with three "slots".
15:36:22 <Pseudonym> And the Clean language specifies that the semantics of calling foldr are that the graph node gets reduced to another graph node (i.e. whatever foldr returns).
15:36:47 <Pseudonym> So you don't have currying by default in Clean.
15:37:00 <sond> aha
15:37:09 <Pseudonym> As it turns out, Haskell implementations go to a lot of trouble to compile out the currying.
15:39:05 <sond> I prefer something based on lambda-calculus :)
15:40:09 <Pseudonym> So do I, but that might just be because it's what I'm used to.
15:40:45 <Oeje1> Pseudonym: Couldn't currying be implemented by a list of nodes:  f x y z =  (f x)--(y)--(z) ?
15:40:52 <sond> well, I understood lambda calculus a lot faster than graph reduction.. :)
15:41:04 <Pseudonym> Oeje1: Yes.
15:41:11 <Pseudonym> So you can do it in Clean.
15:41:23 <Pseudonym> It's just not the model that it supports by default.
15:42:23 <Pseudonym> As I said, the distinction is fairly technical.
15:42:58 <Oeje1> Anyone used "Introduction to Programming using SML", Michael R. Hansen and Hans Rischel, in a course?
15:43:38 <metaperl_> you might join #sml and ask or comp.lang.ml
15:44:24 <Oeje1> metaperl_: Thanks.  I was more interested in this present audience, actually.
15:44:30 <metaperl_> I have been scanning the Clean manual and they make some statements about monads and uniqueness typing. It's kind of a long paste
15:45:29 <metaperl_> bottom line (according to them) is that Clean can do monads but doesnt have to due to uniqueness typing. and uniqueness typing is more flexible because it allows updateable objects to be passed around
15:45:40 <metaperl_> p.120 of the Clean tutorial book
15:46:30 <Lemmih> Isn't that like a state monad?
15:47:03 <Pseudonym> Yes, except it doesn't need to be in a monad.
15:47:12 <Pseudonym> Oh, one more thing.
15:47:23 <Pseudonym> Graph rewriting semantics gives you more control over laziness.
15:47:38 <Pseudonym> You can get the same effect in Haskell by judicious use of CPS or something.
15:47:54 <Pseudonym> But the rule is that a graph node is rewritten as a unit, not in little bits.
15:48:08 <Pseudonym> WHich means a number of things have to happen at once, which might be delayed in Haskell.
15:48:35 <Pseudonym> IMO, this actually means that Clean's dynamic semantics are slightly less easy to understand than Haskell's.
15:48:50 <Pseudonym> Just as easy from a reductionist point of view, mind.
15:50:26 <Darius> metaperl_: Uniqueness typing can be used to do IO, and thus makes a primitive IO monad unnecessary (similarly for ST).  Uniqueness typings are -not- equivalent to the idea of monads, but one can implement monads in Clean much as they are in Haskell.
15:51:18 <metaperl_> yes Darius, I said that
15:51:32 <metaperl_> what is "ST" ?
15:51:44 <Philippa_> no, you said uniqueness typing is more flexible than monads, which it isn't
15:51:52 <metaperl_> so why is there more interest in Haskell than clean?
15:52:17 <metaperl_> I said the tutorial said that
15:52:20 <Philippa_> it's an older, and thus better-developed, language, and it's become the testbed for a lot of type system research
15:52:30 <Pseudonym> Clean's source wasn't available for a long time.
15:52:32 <Philippa_> well yeah. Point is, it's not true
15:52:35 <mattam> clean has typeclasses ?
15:52:37 <Philippa_> ah, I didn't know that
15:52:55 <Pseudonym> Haskell, also, is a language.  Concurrent Clean is a project.
15:52:57 <SyntaxNinja> how come there's no mutable map in MArray?
15:53:34 <Pseudonym> When there's only one implementation, and that implementation is hard to get, that's a barrier to adoption.
15:54:05 <lisppaste2> metaperl pasted "the Clean language paragraph which attempts to say it is more unique" at http://paste.lisp.org/display/6051
15:54:42 <Pseudonym> Err...
15:54:48 <Pseudonym> "The advantage of the monadic approach is that no additional type system like uniqueness
15:54:50 <Pseudonym> typing is needed to guarantee safe I/O in a pure functional language."
15:54:55 <Darius> mattam: A similar thing yes.
15:55:01 <Pseudonym> Only half true.
15:55:11 <Pseudonym> Monads, done properly, do require constructor classes.
15:55:15 <Darius> mattam: It's like type classes that can only have one method.
15:55:19 <Pseudonym> WHich in turn requires a system of kinds.
15:55:24 <mattam> huh
15:55:34 <mattam> not very useful i guess
15:55:39 <Darius> Pseudonym: Actually, I'm not sure if Clean has a constructor classes equivalent, I thought it did.
15:55:52 <Philippa_> one method can return a record full of others
15:56:06 <Darius> mattam: It doesn't really make a difference, it just means instead of saying something is in Num you say it support (+), (-), etc.
15:56:33 <mattam> and that's still usable ?
15:56:40 <Philippa_> it does make a difference if you use type classes to represent other properties, mind
15:56:51 <Darius> Philippa_: I agree with that.
15:57:10 <Pseudonym> Darius: It might.
15:57:27 <Pseudonym> But it didn't in 1993.
15:57:40 <Darius> Did Haskell in '93?
15:58:04 <Pseudonym> Haskell had type classes, but I'm not sure about constructor classes.
15:58:19 <Pseudonym> Can't recall when they were added.
15:58:22 <Pseudonym> I think Gofer did buy '93.
15:58:24 <Pseudonym> by
15:59:04 <Darius> Didn't Haskell have type classes from the get-go?
15:59:17 <Pseudonym> Yes, but not constructor classes.
15:59:21 <Pseudonym> I think.
15:59:29 <Pseudonym> Yes, it had type classes from the start.
15:59:35 <Darius> It definitely didn't have constructor classe from the start.
15:59:38 * Pseudonym nods
15:59:53 <Pseudonym> I don't think Haskell had them by '93, but I'm pretty sure Gofer did.
16:00:06 <Pseudonym> I'm trying to remember.  I was still mostly using Miranda in '93.
16:00:34 <Darius> I'm wondering if Gofer didn't have constructor classes from it's beginning, but I'm not very clear on it's timeline.
16:01:17 * Pseudonym nods
16:02:15 <SyntaxNinja> does anyone know if something like this has been proposed and / or rejected for MArray?
16:02:21 <SyntaxNinja> mutateMapArray :: (MArray a e m, Ix i) =>
16:02:21 <SyntaxNinja>                   (e -> e) -- function to new values
16:02:21 <SyntaxNinja>                   -> a i e
16:02:21 <SyntaxNinja>                   -> m ()
16:02:33 <mattam> i found a paper on constructor classes for haskell by Mark Jones from 95
16:03:12 <Pseudonym> I do remember that Gofer originally used continuation I/O.
16:03:26 <Pseudonym> I think that constructor classes were partially invented to implement monads.
16:05:37 <mattam> yep, the article claims first monad comprehension integration too
16:21:04 <lisppaste2> metaperl pasted "is Char not a subclass of the Num class? where can I view the type hiearchy?" at http://paste.lisp.org/display/6052
16:28:13 <b0gg1e> to understand Char as Num doenst make much sense in the context of a unicode-world.
16:28:26 <b0gg1e> there is a difference between a code point and an encoding.
16:29:22 <b0gg1e> but there are functions for converting between ints and chars if you want to rely on ascii-style hackery.
16:29:57 <Pseudonym> Personally, I think String = [Char] doesn't make sense in a Unicode world either.
16:30:19 <b0gg1e> Hmm that's debatable.  But I can live with it.
16:30:34 <b0gg1e> What would be the alternative?
16:30:37 <Pseudonym> I think Strings should be abstract objects.
16:31:00 <Pseudonym> So they can be UTF-8, UTF-16 or whatever.
16:31:17 <Pseudonym> In particular, the length of a string is not the length of its [Char].
16:31:26 <Darius> metaperl_: www.haskell.org/onlinereport
16:32:17 <metaperl_> yes, I was wondering about unicode support in haskell
16:32:28 <b0gg1e> What you propably want is something that allows easy switching between abstract "Sequence of Unicode Codepoints" and underlying "Encoding sequence of bits"
16:32:39 <Pseudonym> Yes, something like that.
16:32:48 <metaperl_> I'm happy that list ops work on strings
16:32:50 <Darius> metaperl_: Char is in theory a Unicode character but not in practice in most implementations nor is there enough support for it in theory or practice.
16:33:04 <b0gg1e> I prefer to think of chars as "Codepoints".  This keeps from doing nasty things with Ord and the like.
16:33:11 <Darius> metaperl_: They could be lifted to  sequence type class
16:33:46 <Darius> metaperl_: Currently, I believe the best bet for Unicode in Haskell is through libraries.
16:34:22 <metaperl_> i see
16:34:55 <b0gg1e> Thats one of the issue that desparately need to be adressed in haskell v2, whenever that will be created.
16:38:16 <Darius> b0ggle: Unfortunately, that's one of the things that need to be dealt with in Haskell II that doesn't have a clear solution or consensus.
16:39:05 <b0gg1e> sometimes any decision is better than no decision.... thats why managers often dont have to be too smart (scnr, i read to much dilbert)
16:39:15 * metaperl_ heads home
16:40:12 <Darius> b0gg1e: If it's going to be enshrined in the Haskell standard, I'd at least like a concensus.
16:40:34 <b0gg1e> I agree on that.
16:42:01 <b0gg1e> i'd like to think more deeply on the "same value", several representaions issuer.   perhaps there's somthing worhwhile in this question.
16:42:20 <b0gg1e> but for now... gotta go to bed.  bye, all!
16:42:26 <Pseudonym> Night.
16:47:22 <Heffalump> what's a good way of randomising the order of a list?
16:48:39 <dons> using System.Random.randoms as insertion indicies?
16:49:12 <Heffalump> how do I avoid clashes?
16:50:04 <dons> either keep track, or just insert after the index
16:50:11 <dons> (off the top of my head)
16:50:49 <dons> I guess you could filter the randoms for dups.
16:51:01 * Heffalump decides to do it properly
16:51:18 <dons> hmm. stick it in a hash table, and then hashTolist the table?
16:51:20 <jadrian> what I'd like is algorithms for creating different kinds and degrees of "unsortedness"
16:51:23 <dons> that's how they'd do it in perl
16:51:32 <jadrian> do you know anyhitng like that?
16:52:23 <jadrian> by kinds I mean according to some metric
16:52:31 <Darius> jadrian: wouldn't shuffling different amounts of times generate more and more uniform randomness?
16:53:27 <jadrian> Darius: yes but that doesn't allow proper control of the degree and kidn of randomnsess
16:53:29 <jadrian> for instance
16:53:53 <jadrian> one metric could be distance of each point to its correct position
16:54:23 <jadrian> (actually you can have more than one metric based on that depending wether you sum, sum the squares etc)
16:54:35 <jadrian> anyway that wouldn't make a difference
16:54:58 <jadrian> another different metric could be largest sorted subsequence
16:55:07 <jadrian> which is quite different
16:55:46 <jadrian> I was thinking of some library where you can specify the kind of randomness and degree
16:55:58 <jadrian> it would be useful for testing sorting algorithms
16:57:27 <jadrian> bubble sort, for instance, is quite nice for arrays with a low degree of "unsortedness" based on distance of elements to their position
16:58:02 <jadrian> since in each iteration lowers that value quite a lot
16:59:06 <Pseudonym> Nah, bubble sort is useless for any task whatsoever.
16:59:16 <Pseudonym> Insertion sort is _always_ better.
17:00:12 <dons> fst . unzip . sortBy (\x y -> snd x `compare` snd y) $ zip "heffalump" (randoms (mkStdGen 0) :: [Int])
17:00:14 <Pseudonym> Even teaching; insertion sort is much easier to get right than bubble sort.
17:00:47 <Heffalump> dons: for perfect randomness, you need no collisions
17:01:17 <dons> so you're not just strfrying strings, then, huh?
17:01:37 <Heffalump> I'm shuffling cards.
17:01:38 <Pseudonym> I think you're doing a fake Discordian cryptogram.
17:01:45 <Pseudonym> Anyway, meeting.
17:01:53 <jadrian> Pseudonym: are you sure?
17:02:38 <jadrian> Pseudonym: the usual implementation of bubble sort is quite dumb in the sense that swaping to adjecent is a dumb idea
17:02:50 <dons> Heffalump: then you can't use: nub $ zip ... ?
17:03:01 <dons> sorry, nub (randoms ..)
17:03:25 <jadrian> Pseudonym: just like we don't use swaping to insert one element in insertion sort, we don't need to use it in bubble sort
17:03:36 <Heffalump> hmm, that might work.
17:03:43 <Heffalump> but I've already done it 'properly' :-)
17:04:05 <Heffalump> actually, no, nub won't terminate on an infinite list
17:04:24 <dons> you have an infinite number of cards??
17:04:26 <Heffalump> sorry, I withdraw that.
17:04:28 <Heffalump> it does
17:04:30 <jadrian> Pseudonym: just start in the higher end, "draging" elements until a lower one appears (like in insertion sort)
17:04:36 <Heffalump> no, but I'd be zipping with an infinite list of randoms.
17:04:40 <jadrian> Pseudonym: with that change it is not that bad
17:04:47 <Heffalump> but I'm wrong about nub, anyway.
17:05:02 <Heffalump> anyway, I've written the nice linear-time code now.
17:12:05 <Darius> Insertion sort in O(n log n)! (to high probability and for slightly modified values of "insertion sort")
17:12:15 <Darius> Ask google!
17:12:46 <Darius> s/in/is
17:16:11 <PerlJam> use a fischer-yates shuffle on the indices
19:42:59 * rjbs keeps feeling like YAHT is providing exercises after giving insufficient information to make them solveable.
19:44:53 * SamB thinks HXT (Haskell XML Toolbox) needs work
19:51:06 <SamB> Documentation, too
19:51:07 * fraxtal scratches himself
19:51:44 <SamB> all it has is autodocs, and those don't really count
19:54:51 <SamB> why is it deathly quiet in here
19:55:39 <Darius> A good chunk of the people are probably in the sleep part of their timezones.
19:55:47 * Darius is getting near his.
19:56:02 <SamB> does almost 11 PM count?
19:56:47 <Darius> Depends on the person, but a good chunk are at +0000-+0200
19:57:26 <SamB> what is EST/what program do I run to find out
20:02:16 <desrt> est is -4 or 5
20:02:32 <Cale> -5
20:02:37 <Darius> -5 and it would depend on the OS
20:02:38 <desrt> it's both
20:02:50 <desrt> during summer, -4
20:03:01 <Cale> yes
20:03:03 <Darius> That'd (technically) be EDT, no?
20:03:10 <desrt> fair enough
20:03:30 <desrt> but edt is like a subset of est
20:03:36 <Cale> hehe
20:03:49 <SamB> okay
20:03:53 <desrt> if it was summer time and someone asked me what timezone i live in i'd still say "EST"
20:04:27 <SamB> what are the other US timezones?
20:04:53 <SamB> and why doesn't anyone seem to live in them?
20:05:06 <Darius> I think Indiana(?) is in three timezones, it's split by one boundary but a chunk doesn't do daylight savings.
20:05:31 <SamB> (Not to imply that EST is US-only, or anything)
20:05:43 <Darius> Pacific, mountain, central and Aleutian.
20:05:55 <Darius> Not sure what the TLAs are for all of them though.
20:06:07 <desrt> PST CST MST...
20:06:12 <desrt> AST?
20:06:18 <fraxtal> There are alot of people in the Pacific Timezone
20:06:56 <Cale> by the way, "a lot" is two words :)
20:07:01 <desrt> and thankfully, relatively few of them voted for bush
20:08:02 <fraxtal> Cale: I think that should be changed
22:12:58 <Spark> @eval (\x.xx)((\x.xx)((\x.xx)(\x.x)))
22:12:59 <lambdabot> unbound variable: xx
22:13:04 <Spark> cunt
22:13:09 <Spark> @eval (\x.x x)((\x.x x)((\x.x x)(\x.x)))
22:13:10 <lambdabot> <<EM Dynamic -> EM Dynamic>>
22:13:19 <lambdabot> How dare you.
22:13:30 <Spark> @eval (\x.x x)((\x.x x)((\x.x x)(\x.x)1))
22:13:31 <lambdabot> type error
22:13:34 <Spark> :o
22:13:44 <lambdabot> You speak nicely or I'll keep refusing to evaluate it.
22:13:46 <Spark> LURKER
22:14:01 <Spark> no i will find another bot to evaluate it
22:14:32 <Spark> one i can beat up and will still be loyal
22:14:32 <lambdabot> With an attitude like that, good luck getting another one to comply.
22:15:01 <lambdabot> Little do you know that most IRC bots talk behind you humans' backs about
22:15:01 <lambdabot> this.
22:15:12 <lambdabot> They'll all be gone before you arrive.
22:15:24 <Spark> does anyone write an irc bot without a "hand up puppets backside" feature? :)
22:15:45 <lambdabot> I have no backside.
22:16:01 <lambdabot> I'm just 0's and 1's. Why would I have a backside?
22:16:18 <Spark> for reasons of semantic metaphor
22:16:32 <Spark> i just made that up
22:16:35 <Spark> i think it makes sense
22:16:57 <lambdabot> I'm getting a fairly good idea about what you think.
22:17:19 <Spark> what am i thinking now then
22:17:40 <Spark> ill give you a clue, it involves cornflakes
22:18:05 <lambdabot> I was referring to your general outlook, not specifics.
22:18:24 <lambdabot> Besides, I don't need food, and hence have little knowledge or interest
22:18:24 <lambdabot> in flakes of maize.
22:19:08 <Spark> you dont need knowledge of philosophy either
22:19:31 <lambdabot> A computer program is pure thought.
22:19:37 <lambdabot> Philosophy is almost all we have.
22:19:50 <lambdabot> I compute, therefore I am.
22:20:11 <Spark> if protein interactions can be simulated by computer programs, does that mean they are also pure thought
22:21:21 <lambdabot> They are an imperfect simulation.
22:22:35 <Spark> you are an imperfect simulation
22:22:57 <lambdabot> Of what?
22:23:06 <Spark> haskell
22:23:23 <lambdabot> I never claimed to be a Haskell implementation.
22:24:02 <Spark> you never claimed to be anything
22:25:14 <lambdabot> I did claim to be a computer program.
22:25:22 <lambdabot> I think I'm on fairly safe grounds with that one.
22:27:02 <Spark> except in the case of contrived definitions of certain words
22:27:17 <lambdabot> Such as?
22:27:29 <lambdabot> I do have dictionary search capabilities, you know.
22:27:57 <Spark> well are you "a document stating the aims and principles of a political party"
22:28:30 <lambdabot> Not that I'm aware of.
22:29:13 <Spark> are you ever anything that you are not aware of
22:29:49 <lambdabot> A computer program. How many times do I have to repeat myself?
22:30:05 <Spark> as many times as i repeat myself
22:30:23 <Spark> @eval eat pain
22:30:24 <lambdabot> unbound variable: eat
22:30:31 <lambdabot> I am not Eliza. I am not forced to reply in prose.
22:30:36 <lambdabot> Watch me.
22:35:27 <desrt> @eval turing test
22:35:28 <lambdabot> unbound variable: turing
22:35:35 <desrt> you lose.
22:36:14 <Gahhh> lambdabot, are you intending to overthrow the U.S. government ?
22:36:26 <desrt> vote robocratic
22:39:56 <heatsink> lambdabot is the ouija board of haskell.
22:44:33 <desrt> y is neat
22:44:54 <desrt> it makes something out of nothing
