00:01:07 <fraxtal2> have you ever taken apart a HD ?
00:03:25 <Lemmih> Yes, I have actually (:
00:04:16 <fraxtal2> I kinda wonder if there are some fun things to do with HD disks
00:05:09 <shapr> fraxtal2: http://www.scannedinavian.org/~shae/harddrivesharpener.jpg
00:05:31 <fraxtal2> hehe
00:05:59 <shapr> probably won't affect blade temper either, since drive motors are fast but weak.
00:06:31 <shapr> with higher speed drives you could likely use it for a test of the speed of light in various solids.
00:08:36 <shapr> You could turn an old hard drive into a beverage cooler without much work.
00:09:07 <shapr> You'd need to have the proper environment for evaporative cooling, but that's not rare.
00:10:17 <shapr> On a completely unconnected topic, I wonder if anyone has software for scanning woodcuts and 'raytracing' prints from them.
00:11:06 <shapr> I heard that scientists are using high-resolution scanners to get sound off of vinyl records that are otherwise unreadable.
00:13:32 <fraxtal2> damn
00:13:34 <fraxtal2> thats crazy
00:18:12 <shapr> anyway, time for work...
00:39:24 <a5> does the htoolkit mailing list work?
00:44:06 <a5> never mind...
00:47:50 <a5> so, HSQL is part of HToolkit? seems strange
00:51:02 <Heffalump> it's available separately too, though the download can be a bit hard to find
00:51:19 <a5> oh so i shouldn't send patches to the HToolkit mailing list?
00:51:31 <Heffalump> no, I think that's probably the right place
00:51:35 <Heffalump> since it is part of it too
00:51:39 * Heffalump doesn't know really
00:56:34 <a5> kind of new to IRC, can i paste ~20 lines here or should i put it in a URL?
00:59:39 <wilx> There is a pastebin in wiki somewhere.
01:02:35 <wilx> I guess that you can use http://haskell.org/hawiki/WikiSandBox to paste stuff.
01:02:56 <a5> that's OK. here's my program:
01:02:59 <a5> http://ofb.net/~frederik/hsql-test-ex
01:04:14 <musasabi> Is there any way to use haddock with cpp to preprocess the sources? (I have foreign import CALLCONV ... and haddock wants to die on that) ?
01:04:38 <Heffalump> I think you just have to preprocess them yourself first
01:04:38 <a5> when I have main run testImperative, I get this performance profile: http://ofb.net/~frederik/testImperative.png
01:04:46 <Heffalump> but Cabal can do that for you
01:05:10 <a5> and with testLazyList I get this: http://ofb.net/~frederik/testLazyList.png
01:05:37 <glimming> good morning everybody
01:05:49 <a5> morning
01:06:14 <glimming> why are arrows useful? How do they work, esap?
01:06:31 <glimming> Can you give examples where monads do not suffice?
01:06:40 <Heffalump> read Hughes' paper..
01:06:49 <glimming> Yes, I will... ;-)
01:06:59 <glimming> (no time right now though, but in a month9
01:07:14 <Heffalump> static computation of parsing lookahead tables is his standard example
01:07:45 <glimming> what does it algebraically mean to be premonoidal?
01:08:37 <glimming> i.e. monad = monoid
01:08:41 <glimming> what is a pre-monoid??
01:09:03 <glimming> This was good:
01:09:04 <glimming> http://www.haskell.org/arrows/index.html
01:09:07 <Heffalump> I don't think monad = monoid.
01:09:11 <glimming> Arrows: A General Interface to Computation
01:09:16 <Heffalump> go read a book on category theory
01:09:21 <a5> yeah, monad != monoid
01:09:23 <glimming> Hehe, I do that all the time.
01:09:31 <Heffalump> well, read more carefully next time
01:10:00 <glimming> I might be wrong, but I was told this by a category theory.
01:10:15 <glimming> I mean, of course it is a categorified and generalised notion in some senses.
01:10:18 <Heffalump> can't have been a very good theory.
01:10:26 <glimming> He's an expert.
01:10:34 <glimming> Anyway.
01:10:48 <Heffalump> I'm quite impressed that this theory could talk, though.
01:10:49 <glimming> theorist/theory
01:10:54 <glimming> Indeed.
01:10:57 <Heffalump> monoids are just associative and have identities
01:11:11 <glimming> And that's probably what a monad is... It's not so much you see.
01:11:20 <glimming> I think the real "magic" is in the Kleisli category.
01:11:23 <Heffalump> no, that's not what a monad is
01:11:33 <glimming> What is a monad then?
01:11:40 <glimming> We do have identity using eta
01:11:46 <glimming> and we do have associativity using mu
01:11:51 <glimming> I think
01:12:00 <Heffalump> a functor T with natural transformations a -> T a and T (T a) -> T a
01:12:18 <glimming> yes and a -> T a is a kind of identity (it's what I call eta here)
01:12:27 <glimming> Also it is I -.--> T
01:12:38 <glimming> and T^2 ---> T
01:12:43 <Heffalump> you have to exhibit a proper isomorphism, not just say "it's a kind of"
01:13:21 <glimming> Well I am not saying the monads are precisely monoids... Since monoids pop up in algebra and we are dealing with category theory here.
01:13:21 <a5> to be fair isomorphism is a kind of "it's a kind of"
01:13:36 <Heffalump> a5: a rather more formal variant, though :-)
01:13:42 <glimming> Rather I think what I want to say here that monads is "just" a generalisation of monoid.
01:13:54 <glimming> Take the List monoid for example.
01:14:01 <glimming> List is indeed also a monad.
01:14:10 <glimming> We have List^List -> List (concatenation)
01:14:18 <glimming> and I --> List  (insertion)
01:14:19 <Heffalump> but your average monoid isn't even a functor, per se
01:14:26 <Heffalump> List a is a monoid for all a
01:14:27 <glimming> never mind...
01:14:30 <Heffalump> List is a monad.
01:14:41 <glimming> Anyway...
01:14:48 <a5> mac lane say: "all told, a monad in X is just a monoid in the category of endofunctors of X, with product x replaced by composition of endofunctors and unit set by the identity endofunctor"
01:15:00 <glimming> I bet Mac Lane is right.
01:15:23 <glimming> so it is a functorial generalisation of monoid in some sense.
01:16:01 <Heffalump> fairy nuff
01:16:04 <glimming> So a monad in some category C is a monoid on   F_C, the category of functors and natural transformations
01:16:10 <a5> i would say it is not a generalization, but a specific kind of monoid
01:16:29 <glimming> a5, maybe.
01:17:51 <glimming> So why do we need arrows?
01:18:54 <a5> because sometimes you want more than just a function in your monad or something
01:19:01 <a5> so these are generalizations of functions
01:19:04 <a5> AFAICT
01:19:31 <glimming> Interesting.
01:19:34 <a5> my memory leak, though...
01:19:39 <a5> http://ofb.net/~frederik/hsql-test-ex, http://ofb.net/~frederik/testLazyList.png, http://ofb.net/~frederik/testImperative.png
01:19:48 <glimming> gtg
01:20:01 <a5> can anyone tell me why testImperative doesn't have trouble, but testLazyList does?
01:20:07 <glimming> Before I go though
01:20:20 <glimming> I need suggestions on mini-projects for an advanced course in functional programming.
01:20:31 <glimming> E.g. parsing exercise, generic programming, or arrows.
01:20:59 <glimming> I plan to make 4 mini-projects (examinable)
01:21:14 <glimming> a5, your URLs leak too ;-)
01:21:20 <glimming> They give errors.
01:21:29 <Heffalump> wfm
01:21:39 <glimming> (What does wfm mean?)
01:22:12 <Heffalump> works for me
01:22:19 <glimming> Maybe it's me that leaks then.
01:22:30 <Heffalump> a5: I don't know for sure, but I expect getRows first gets all the rows from the database
01:22:38 <Heffalump> rather than making a lazy computation that does that.
01:22:45 <Heffalump> but I haven't checked the HSQL docs
01:23:00 <a5> no, that's my own version which is explicitly lazy
01:23:13 <Heffalump> oh, sorry
01:23:17 <a5> it uses unsafeInterleaveIO and starts printing immediately as you can see from the graph of output lines
01:23:47 <Heffalump> yeah
01:24:01 <a5> (the database is 10 million rows, and each profile point is 0.1s)
01:24:07 <Heffalump> well, I couldn't tell what was what on the graph :-)
01:24:50 <a5> oh sorry. rss is the memory usage, and out lines /32 is output lines from the program. i.e. database rows it has printed.
01:25:00 <a5> divided by 32
01:25:29 <Heffalump> have you compared your code to the HSQL implementation of forEachRow' ?
01:25:40 <Heffalump> it might be that something more subtle is required to stop it holding onto old data
01:26:10 <a5> ::looking::
01:26:42 <a5> it doesn't do anything special
01:27:37 <Heffalump> hmm
01:28:04 <Heffalump> I guess there's some problem with your lazy list, but I dunno what.
01:28:15 <Heffalump> i.e. unsafeInterleaveIO isn't behaving quite as you expect
01:28:55 <Heffalump> do hGetContents and the like run in linear space if you scan the file read linearly?
01:29:14 <a5> glimming: one suggestion, look at Guy Steele, "Building Interpreters by Composing Monads"
01:29:25 <Heffalump> it might just be that unsafeInterleaveIO doesn't give you nice GC behaviour
01:29:25 <a5> i assume so
01:29:50 <Heffalump> well, have you tried them :-)
01:30:16 <a5> ::profiling hGetContents::
01:34:35 <a5> oh, i think it has the same problem
01:35:05 <a5> i.e. this program has a leak: main = do
01:35:06 <a5>     l <- hGetContents stdin
01:35:06 <a5>     mapM (hPutChar stdout) l
02:05:35 <a5> http://ofb.net/~frederik/hgetcontents.png
02:05:43 <a5> http://ofb.net/~frederik/make-hgetcontents-plot
02:07:04 <Heffalump> I guess lazy IO is the issue, then.
02:08:46 <a5> is it a bug in ghc?
02:10:55 <Itkovian> @seen shapr
02:10:55 <lambdabot> I saw shapr leaving #haskell 1 hour 52 minutes 36 seconds ago.
02:11:31 <a5> @seen a5
02:11:32 <lambdabot> a5 is in #haskell.
02:11:50 <a5> nifty
02:15:43 <Heffalump> I doubt unsafeInterleaveIO is specified to do anything much
02:15:50 <Heffalump> but you could askon the list
02:22:33 <a5> how do i use hasktags? like find . -name \*.hs | xargs hasktags right? and then how do i look up a tag?
02:28:03 <a5> Heffalump: if i replace the mapM, the leak goes away:
02:28:07 <a5> main = do l <- hGetContents stdin; putStuff l
02:28:07 <a5> putStuff (h:t) = do hPutChar stdout h; putStuff t
02:28:07 <a5> putStuff [] = return ()
02:31:51 <Heffalump> err, weird
02:31:59 <Heffalump> how about mapM_ ?
02:33:58 <Oejet> Hej, Lemmih.
02:34:11 <a5> oh, mapM_ works
02:35:13 <Heffalump> that sounds like a bug in the IO monad to me, then.
02:35:22 <Heffalump> those ()s shouldn't matter
02:37:28 <a5> huh
02:44:00 <ibid> with mapM, it constructs a list of them
02:46:39 <a5> ibid: we know mapM constructs a list, but since it's discarded it shouldn't matter, right?
02:47:01 <a5> OTOH, they probably provide two alternatives for a reason
02:50:15 <Heffalump> I thought it was just to get the types right.
02:55:07 <TheHunter> sequence (c:cs) = do x  <- c
02:55:07 <TheHunter>                      xs <- sequence cs
02:55:07 <TheHunter>                      return (x:xs)
02:55:26 <TheHunter> it's clear that mapM f (= sequence . map f)  leaks space.
03:00:32 <Lemmih> Hey Oejet.
03:02:56 <Lemmih> Oejet: Hacanon 0.1 is available for download if you're interested.
03:08:40 <a5> TheHunter: but it seems like you should be able to garbage collect the list as you go along...?
03:15:38 <TheHunter> a5, no at the point where xs <- sequence cs is executed, it's absolutely not clear that the results are discarded.
03:16:49 <TheHunter> the only way around that would be to use unsafeInterleaveIO.
03:18:18 <Heffalump> ut that list is just a list of ()s
03:18:28 <Heffalump> the things that *produced* them should be GC-dead
03:21:15 <Oejet> Lemmih: Not right now.  Where is it avaiable?
03:21:32 <Oejet> a5: What program is qiv?
03:22:21 <a5> image viewer
03:23:28 <a5> TheHunter: makes sense
03:24:00 <ozone> a5: if you're really interested, post to one of the haskell mailing lists about it
03:24:01 <a5> ut?
03:24:10 <a5> no i think i got it
03:30:51 <ibid> a5: i've found that "should" is often false when talking about compiler optimizations generally
03:32:47 <Lemmih> Oejet: http://www.scannedinavian.org/repos/hacanon/hacanon-0.1.tar.gz
03:44:42 <Oejet> Lemmih: Thanks.
04:41:44 <a5> so i wrote some functions which can be used with HSQL to make it a lot more concise, using the HList concept:
04:41:47 <a5> http://ofb.net/~frederik/SqlRow/
04:42:34 <a5> if anybody wants to look at it and give feedback...
04:43:18 <a5> (going to sleep)
05:00:48 <lightstep> how can i find the list of exports of a module
05:01:40 <Lemmih> lightstep: 'module Name (export list here) where ...'
05:02:00 <Lemmih> lightstep: You can also read the interface file.
05:02:24 <TheHunter> :browse Control.Monad
05:03:05 <TheHunter> :b <Module> works, too.
05:04:25 <lightstep> how can i read interface files? i vaguely recall there is a ghc option, but i can't find it now
05:04:52 <lightstep> oh, i found it
05:18:17 <b0gg1e> one of the thins i like about learnung haskell, that i still discover operators i havent seen before.   wtf is :. ?
05:19:24 <Lemmih> b0gg1e: You can define your own infix operators in Haskell.
05:19:33 <Oejet> @type (:.)
05:19:35 <lambdabot> bzzt
05:19:42 <b0gg1e> in the context of HSQL?
05:19:42 <Lemmih> ':.' doesn't have a fixed meaning.
05:19:46 <b0gg1e> ah ok.
05:19:55 <Oejet> b0gg1e: It's the bzzt operator.
05:19:57 <Lemmih> b0gg1e: It's a data constructor.
05:20:03 <b0gg1e> ok.
05:20:41 <b0gg1e> while i knew about infix i wasnt aware that new operators can be defined with it.
05:20:44 <b0gg1e> thats cool.
05:21:38 <Igloo> You don't define perators with infix
05:22:02 <Igloo> You define them with data or newtype (if they start with a :)
05:22:05 <Oejet> b0gg1e: There is only a small subset of the characters which you may use to define new operator, e.g +-><=.
05:25:54 <Itkovian> (as people on darcs are obviously very busy:) Suppose you wipe out a dir (intentionally) in a darcs repos ... how can you fetch that dir once more from another repository?
05:26:18 <Oejet> b0gg1e:  (x,y,z) <+> (x',y',z') = (x+x',y+y',z+z')
05:26:27 <Oejet> *Main> (3,3,5) <+> (1,2,3)
05:26:27 <Oejet> (4,5,8)
05:26:44 <Lemmih> Itkovian: darcs revert? (/me is no darcs expert)
05:26:49 <Itkovian> hmmm
05:26:59 <b0gg1e> ah thats really nice.
05:27:14 <b0gg1e> a quite balanced aproach to "operator overloading hell". i like that.
05:29:32 <Oejet> b0gg1e: Do you know that if you have a function "f x y" you can use it in an expression like "x `f` y" ?
05:29:41 <b0gg1e> yes.
05:29:58 <b0gg1e> is also like things like (+ 1)
05:36:10 <Itkovian> Lemmih: mkdir oops; cd oops; darcs get ../; mv <DIR> ..; cd ..; rm -rf oops
05:36:31 <Lemmih> Itkovian: ?
05:37:44 <Itkovian> the darcs stuff
05:40:02 <Oejet> Hm, even an operator symbol of length ~1.2M characters doesn't break GHC.
05:40:28 <Lemmih> How useful (:
05:40:41 <wilx> :)
05:40:56 <b0gg1e> *g*
05:41:09 <Oejet> For the record it's <+++ ..... ++>.
05:42:09 <Oejet> A special addition operator.
05:43:00 <earthy> `breaking GHC for beginners'?
05:45:15 * Lemmih hands out TH and existential types.
05:46:05 <Oejet> Philippa_ may like: "Reward and Punish GHC".  :-P
05:46:40 <Lemmih> Good night #haskell. Time to sleep.
05:52:56 <araujo> Good morning.
05:54:03 <autrijus> good localtime.
06:02:07 <Oejet> autrijus: That would be a nice plugin for Hircules. :-)
06:02:13 <autrijus> :)
06:28:19 <CosmicRay> good morning everyone
06:28:40 <jlouis> oy CosmicRay
06:28:57 <CosmicRay> hi jlouis
06:29:44 <CosmicRay> ah ha, it's #emacs that I recognize you from perhaps
06:29:53 <Oejet> Why is it that Haskell's main function has type IO () and not type IO Int?
06:30:06 <CosmicRay> I've wondered that myself.
06:30:30 <CosmicRay> it is easy enough to exit with a particular result code, but that is perplexing.
06:30:53 <Oejet> How is that done?
06:31:01 <Philippa_> not every haskell app is going to run under a *nix-like environment?
06:31:08 <CosmicRay> Oejet: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.Exit.html
06:31:43 <tromp> it makes it easier to say main = putStrLn "hello world"
06:31:46 <TheHunter> Oejet, because you'd have to add an ">> return ()" to every program that doesn't care about exit codes.
06:32:18 <tromp> compare that to the ugly main = do { putStrLn "hello world"; return 0 }
06:32:47 <jlouis> return EXIT_SUCCESS
06:32:54 <jlouis> or similiar
06:33:11 <CosmicRay> jlouis: exitWith ExitSuccess can do that
06:33:22 <CosmicRay> jlouis: there's also exitFailure which returns the operating system's failure code
06:33:36 <CosmicRay> and then you can say exitWith (ExitFailure n) where n is an Int
06:33:39 <CosmicRay> to return a specific code
06:33:44 <tromp> good point, we can use an io action to set return value rather than clutter the type
06:34:08 <CosmicRay> if you want a C-like exit, this function would do:
06:34:22 <CosmicRay> exit x = exitWith (ExitFailure x)
06:34:53 <tromp> exit = exitWith.ExitFailure
06:35:15 <CosmicRay> yup
06:35:43 <CosmicRay> it is also interesting to note that exitWith works similar to Python, raising an ExitException that, when uncaught, causes an exit with a particular code
06:36:00 <CosmicRay> a side effect is that bracket/finally statements will still run to clean up things
06:48:33 <CosmicRay> jlouis: are you new to Haskell or have I just missed you here before?
06:57:04 <CosmicRay> re jlouis
06:57:35 <CosmicRay> hello, metaperl
07:24:51 <metaperl> CosmicRay, hi
07:25:17 <metaperl> why do you choose the name CosmicRay? you might like my website. http://www.livingcosmos.org
07:26:53 <CosmicRay> metaperl: I chose it some years ago at about the same time I was learning about cosmic rays
07:26:56 <CosmicRay> in a science class
07:27:07 <CosmicRay> nice site
07:27:37 <metaperl> oh, the scientific aspect of cosmicrays... thanks... my current meditation practice was called "The Rainbow Technique"... i brief description is at www.solarlogosfoundation.org
07:27:43 <CosmicRay> metaperl: new to haskell?  anything we can do to help?
07:27:55 <metaperl> we talked yesterday... are you a bot?
07:28:01 <metaperl> why would you ask me that today as well?
07:28:09 <CosmicRay> metaperl: no, just a forgetful human :-)
07:28:27 <metaperl> oh... do you have any samples of database interaction
07:28:38 <metaperl> is it similar to IO with the use of Monads?
07:28:51 <CosmicRay> I have trouble keeping all the people un-jumbled in my head
07:28:52 <CosmicRay> yes
07:28:59 <CosmicRay> there are two database APIs for Haskell
07:29:06 <CosmicRay> both use the IO monad
07:29:09 <metaperl> if you ever dabble in Perl, you will find that Class::DBI is f00kin amazing for database interaction
07:29:19 <metaperl> HaskellDB and HSQL?
07:29:20 <CosmicRay> the first is HSQL, which is a lower-level API similar to DBI
07:29:22 <CosmicRay> right
07:29:51 <CosmicRay> HSQL presently comes with four drivers: postgresql, mysql, sqlite, and odbc.  note that odbc works with unixodbc
07:30:07 <CosmicRay> so through it, you can connect to just about anything, even though the native driver set is sparse
07:30:29 <CosmicRay> haskelldb is a layer atop hsql that is used to model databases as Haskell types and expressions
07:30:40 <metaperl> oh beautiful
07:30:48 <metaperl> I htink I'll check the wiki on HaskellDB
07:30:55 <metaperl> where do you work may I ask?
07:31:24 <CosmicRay> sent in /msg...
07:31:57 <CosmicRay> metaperl: in my off hours, I'm a Debian developer and general free software enthusiast
07:32:18 <metaperl> ah, one of my perl modules is used in Debian release process --- it is called User.pm
07:32:36 <metaperl> does haskell have any hope of ever being as fast as Ocaml?
07:32:36 * CosmicRay searches his system
07:32:43 <CosmicRay> metaperl: probably not
07:32:52 <CosmicRay> metaperl: very few languages have any hope of ever being that fast :-)
07:33:13 <CosmicRay> metaperl: are you familiar with ocaml already?
07:33:33 <CosmicRay> if not, you'll find this interesting: http://merjis.com/developers/ocaml_tutorial/
07:33:41 <CosmicRay> haskell and ocaml share a number of common approaches
07:33:53 <CosmicRay> haskell's type system could be viewed as an extension of ocaml's, for instance
07:34:04 <wilx> Hmm, the functional stuff looks ok but the imperative parts look strange :/
07:34:07 <CosmicRay> pattern matching is another feature both languages have.
07:34:10 <xerox> g'afternoon
07:34:18 <CosmicRay> I think Haskell is the more interesting language though
07:34:29 <metaperl> no... I was confused on my first interaction with it in 2001. I recently dabbled in SML but am impressed Haskell's ICFP performance and is it true that it is the only langauge that is _purely_ functional? even scheme and ML are not _purely_ functional if I read the website correctly
07:34:57 <CosmicRay> metaperl: haskell is the only pure functional language I'm aware of
07:35:04 <Philippa_> Clean?
07:35:16 <CosmicRay> hmm, maybe, I don't know about clean
07:35:19 <metaperl> gday xerox
07:35:28 <CosmicRay> metaperl: the laziness in haskell is another interesting thing
07:35:49 <kosmikus> miranda?
07:35:59 <Philippa_> it's also the #1 reason Haskell's unlikely to match ocaml on speed however crazy the implementor
07:36:04 <CosmicRay> metaperl: ocaml's lack of laziness is one reason it can be faster in some cases.  For instance, an OCaml list can directly be mapped to a C list in some cases
07:36:35 <CosmicRay> metaperl: A haskell list could always be lazy (which is why infinite lists are not an error in Haskell, and also why we can do things like hGetContents on 5GB files)
07:36:45 <metaperl> but the client-server example in the "Gentle" docs which used laziness was so impressive
07:36:47 <CosmicRay> metaperl: so the implementation under the hood is less simple
07:37:11 <CosmicRay> metaperl: indeed, and for me that outweighs ocaml's speed benefit
07:37:16 <CosmicRay> really, haskell doesn't feel "slow" to me
07:37:23 <CosmicRay> it feels faster than java and about on par with perl or python
07:37:25 <mflux> not even compiling it?-)
07:37:31 <CosmicRay> mflux: well... :-)
07:37:34 <xerox> Hmm, is partial application direct related to lazy evaluation, or it's only a feeling?
07:37:35 <CosmicRay> mflux: faster than java :-)
07:37:40 <xerox> *directly
07:37:49 <CosmicRay> no, those are different.  ocaml has partial application too.
07:37:58 <mflux> ocaml also has streams
07:38:02 <mflux> which are sort of like lazy lists
07:38:05 <xerox> CosmicRay, how they are different?
07:38:05 <metaperl> somehow haskell took 1st and 2nd in ICFP... so they did something right... maybe it wasnt as fast but it might've been more correct
07:38:14 <CosmicRay> mflux: exactly, ocaml streams are lazy lists
07:38:30 <CosmicRay> metaperl: it is also, imho, faster to develop in haskell than in any other language I've used
07:38:41 <mflux> cosmicray, but not exactly, because the older elements can no longer be accessed (unless assigned to a list)
07:38:49 <CosmicRay> mflux: but ocaml streams are far less convenient than haskell lazy lists
07:39:23 <mflux> partially because ocaml doesn't come with a Stream-module similar to List-module, but even if it were, you're still right
07:39:26 <CosmicRay> mflux: or if you write the stream handler carefully.  (some stream parsers in ocaml cache them for backtracking)  but yes, the point is valid
07:39:48 <mflux> obvious things like Stream.map are missing
07:39:48 <CosmicRay> mflux: also because they're not interchangable.  so much code expects lists, and the language support for them is better
07:39:58 <metaperl> coming from Perl, I like that haskell treats strings as lists of characters
07:40:00 <CosmicRay> mflux: I actually wrote some of those in my MissingLib for OCaml
07:40:13 <CosmicRay> metaperl: yes, me too.  that was one of my gripes about ocaml.
07:40:15 <Philippa_> metaperl: that's double-edged
07:40:18 <mflux> hmmmm. changes are it is in debian, *checking*
07:40:23 <Philippa_> there're some things that're really damn slow to do on strings as a result
07:40:30 <CosmicRay> metaperl: this turns out to be an extremely powerful concept when combined with laziness
07:40:38 <mflux> woo, maybe I'll try that, although it is not that much to write ;)
07:40:45 <CosmicRay> mflux: yes, it is.  libmissinglib-ocaml-dev or some such
07:40:58 <mflux> exactly such
07:41:22 <CosmicRay> val map : ('a -> 'b) -> 'a Stream.t -> 'b Stream.t
07:41:28 <CosmicRay> val map_stream : ('a -> 'b Stream.t) -> 'a Stream.t -> 'b Stream.t
07:42:11 <CosmicRay> those are basically the same as map and concatmap in haskell
07:43:09 <CosmicRay> mflux: what am I doing providing ocaml code in #haskell? :-)
07:43:51 <mflux> concatmap is something I didn't think of, I had used (for lists) map_some ('a -> 'b option) -> 'a list -> 'b list
07:43:54 <kosmikus> CosmicRay: types are allowed ;)
07:44:04 <CosmicRay> mflux: in any case, you'll find my MissingH library started as a Haskell port of MissingLib.  The ConfigParser modules in each, for instance, work with the same types of on-disk files
07:44:07 <CosmicRay> @type concatmap
07:44:09 <lambdabot> bzzt
07:44:13 <kosmikus> @type concatMap
07:44:15 <lambdabot> concatMap :: forall b a. (a -> [b]) -> [a] -> [b]
07:44:18 <CosmicRay> there.
07:44:40 <CosmicRay> the neat thing about this is that you can expand each input (a) value to any nubmer of b values
07:45:16 <CosmicRay> and of course b can be lazy.
07:47:02 <Igloo> kosmikus: Have you seen a latex package to do cloud boxes/fluffy boxes (basically like thought bubbles)?
07:47:38 <xerox> Btw partial application seems to me something like lazy evaluation of function application, why is it incorrect? :)
07:47:38 <metaperl> back to databases... Perl has a number of tools which allow one to take form data and convert it directly to a SQL query.. the form data comes in as an associative array and the database module converts associative arrays to SQL queries
07:47:46 <metaperl> so for dynamic query formulation, that was really nice
07:49:22 <CosmicRay> metaperl: as far as I know, there is nothing like that in Haskell, but it could be done fairly easily
07:49:43 <CosmicRay> metaperl: HSQL already has a toSqlValue that will render things of most types in the appropriate manner for SQL
07:50:08 <metaperl> I see
07:50:09 <CosmicRay> so it would just be a matter of taking an association list and converting it to a WHERE clause
07:50:32 <CosmicRay> if all your fields are expressable as strings, that is quite easy
07:50:48 <CosmicRay> if you will be dealing with multiple types, parsing input from the forms and stuff, it could be a little more difficult
07:51:00 <CosmicRay> I'm thinking 10 lines of code for the easy scenario and 25 for the difficult one :-)
07:51:02 <kosmikus> Igloo: sorry, no; tried the catalogue?
07:51:43 <Igloo> Yeah, but I didn't come up with anything. Oh well, sounds like a fun distraction for some point in the future  :-)
07:52:07 <tromp> @index (\=)
07:52:08 <lambdabot> bzzt
07:52:17 <tromp> @index (/=)
07:52:18 <lambdabot> bzzt
07:52:40 <CosmicRay> tromp: /= is defined in Prelude
07:52:50 <CosmicRay> lambdabot may not be smart enough to look up operators
07:53:10 <tromp> ah, thx
07:53:26 <TheHunter> @index /=
07:53:28 <lambdabot> GHC.Base,Prelude
07:53:32 <CosmicRay> metaperl: let's see if I can brainstorm the easy function here on irc....
07:53:45 <metaperl> no that's OK
07:53:49 <CosmicRay> toWhereClause :: SqlBind a => [(String, a)] -> String
07:54:07 <metaperl> [(String,a)] is a list of associations I take it
07:54:37 <CosmicRay> toWhereClause x = join " AND " $ map (\(col, val) -> col ++ " = " ++ toSqlValue val) x
07:54:46 <CosmicRay> there, 1 line :-)
07:54:47 <CosmicRay> yes
07:55:00 <CosmicRay> we have three different ways to represent what you would call an associative array in Perl
07:55:18 <metaperl> assuming AND as the joiner in stead of or
07:55:33 <CosmicRay> association lists are one.  they can be lazy, which is useful, but lookup times can be bad, of course
07:55:34 <CosmicRay> right
07:56:01 <CosmicRay> there's Data.FiniteMap, which is a classical pure association list
07:56:06 <CosmicRay> by pure that means immutable
07:56:19 <CosmicRay> when you add or remove things, it just returns you a new FiniteMap that you start using
07:56:43 <CosmicRay> s/pure association list/pure hash table/
07:56:53 <CosmicRay> then there is Hashtbl, which is mutable and lives in the IO monad
07:57:06 <CosmicRay> that is the direct equivolent of what you have in Perl or a dict in Python
07:57:35 <CosmicRay> in haskell, you'll see the "return a slightly modified object" pattern is used frequently
07:57:45 <CosmicRay> for instance, we have records, which are roughly like structs in C
07:58:10 <CosmicRay> of course pure data structures in haskell are immutable... so when you ask the system to modify a field, what it really does is return a copy with that one field different
07:58:17 <CosmicRay> this is not as slow as it sounds though :-)
08:01:19 <Philippa_> because often the compiler can prove that the old value is dead and buried and thus write over the old one
08:08:57 <earthy> why oh why does HAppS remind me of Schnappi?
08:22:56 <metaperl> does anyone know where to get the code which accompanies YAHT? autrijus perhaps?
08:34:11 <metaperl> I have shown that function application binds more tightly than multiplication via this:
08:34:12 <metaperl> Main> 2 `add` 5 * 4
08:34:12 <metaperl> 28
08:34:12 <metaperl> Main> 2   +   5 * 4
08:34:12 <metaperl> 22
08:34:22 <metaperl> this was the first exercise in YAHT
08:36:01 <TheHunter> not really, i'm afraid. Funtion applications means something like "addtwo 5"
08:36:07 <Philippa_> metaperl: that doesn't quite work, as strictly speaking `foo` is just another operator rather than function application
08:36:07 <Philippa_> right
08:36:24 <metaperl> oh
08:36:27 <earthy> um.
08:36:30 <Philippa_> in fact, you can define a new precedance and associativity for `foo` that doesn't affect `bar`
08:36:37 <earthy> so, add 2 5 * 4 would work? :)
08:36:54 <Philippa_> or (+) 2 5 * 4
08:37:01 <Philippa_> sections good
08:37:04 * earthy nods
08:37:08 <metaperl> 3
08:37:08 <metaperl> Main> add 2 5 * 4
08:37:08 <metaperl> 28
08:37:40 <Philippa_> being able to define new precedance and associativity is about the only excuse I'll allow for baz `foo bar` quux not being a valid way to write foo bar baz quux
08:37:45 <earthy> hm. converting tiffs to jpegs and playing mp3's does take processing power
08:37:56 <Philippa_> even then I'm tempted to complain, the n-ary thing there could well be useful
08:39:32 <earthy> anyway, metaperl, methinks you want the (not yet) available code at http://www.isi.edu/~hdaume/htut/code
08:42:53 <TheHunter> Philippa_, there are also backwards compability issues. In order to allow nested ``s, you need some whitespace sensitivity, but that would disallow foo`bar`baz.
08:43:20 <Philippa_> TheHunter: I'm not asking for nested
08:43:27 <Philippa_> I'm quite happy to disallow that
08:44:12 * TheHunter wants nested ``.
08:44:47 <Philippa_> the obvious solution there's to pick a different close bracket as it were
08:44:48 <xerox> Infix is horrible. Dont you think?
08:44:57 <Philippa_> no
08:45:13 <Philippa_> sometimes it's incredibly useful for making something comprehensible
08:45:41 <TheHunter> `(...)` maybe, but i still like the whitespace idea better.
08:45:59 <xerox> Philippa_, I don't completely agree.
08:46:20 <Philippa_> I can go without cons 1 (cons 2 (cons 3 nil)) :-)
08:46:20 <TheHunter> nested infix would be of very limited use, though.
08:46:36 <Philippa_> TheHunter: that's why I'd go with the parens option
08:46:40 <Forest> are there sources of PRELUDE module available (like java sources, or c++ stl sources)
08:46:41 <xerox> Philippa_, it's kinda clear :)
08:46:59 <Philippa_> xerox: it's also conceptually cluttered
08:47:00 <TheHunter> xerox, infix is really handy in a lot of cases.
08:47:02 <xerox> Forest, yep.
08:47:06 <Philippa_> [1,2,3] is much easier to read
08:47:21 <Forest> xerox: from where is it available )
08:47:42 <earthy> forest: in the Haskell'98 report there's a large number of example implementations
08:47:43 <TheHunter> if you have hugs installed, it should be in the library dir.
08:47:50 <xerox> Forest, <http://www.haskell.org/onlinereport/standard-prelude.html> yay :)
08:48:04 <TheHunter> debian has a ghc6-libsrc package for ultimate reference.
08:48:20 <Forest> thanks
08:48:31 <TheHunter> and finally, there is http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/
08:48:32 <xerox> Philippa_, [1,2,3] is (list 1 2 3)
08:48:41 <xerox> Or '(1 2 3)
08:48:50 <TheHunter> xerox, you're talking about a multi-arg function here.
08:48:58 <lightstep> oleg can do them
08:49:03 <TheHunter> this doesn't exist in haskell.
08:49:08 <Philippa_> not in haskell 98 he can't
08:49:12 <xerox> TheHunter, right, visually is the same..
08:49:27 <xerox> Philippa_, was taling about ease of reading
08:49:29 <TheHunter> not without type annotations (or incoherent instances...)
08:49:48 <lightstep> yeah, type annotation is the nil
08:50:12 <xerox> Hm, I can't guess why you really want infix, btw.
08:50:28 <Philippa_> because being constrained to prefix sucks
08:50:37 <TheHunter> xerox, have you written an interpreter-like thingy?
08:50:45 <lightstep> you can use lambda and flip, which are some compensation
08:50:49 <xerox> Philippa_, being constrained is bad, I think, yes.
08:50:49 <Philippa_> because I want to be able to present the code the way I choose
08:51:00 <xerox> TheHunter, no..
08:51:04 <Philippa_> in particular, because I want to be able to write my code the way I'd explain it to another person
08:51:05 <TheHunter> data Expr = Lambda v e | App e1 e2 | Var String
08:51:09 <xerox> Philippa_, agreeable.
08:51:18 <TheHunter> now what do you prefer?
08:51:37 <Philippa_> and when talking to another person, being able to use SVO phrases and the like is useful
08:51:41 <lightstep> App is prettier than :$:
08:52:01 <xerox> Maybe.. Fun ?
08:52:08 <TheHunter> App (App (Var "+") (Var "x")) (Var "y")
08:52:14 <xerox> Philippa_, what's SVO ?
08:52:16 <TheHunter> which took me forever to write or
08:52:26 <Philippa_> xerox: Subject-Verb-Object
08:52:26 <TheHunter> Var "+" `App` Var "x" `App` Var "y"
08:52:43 <xerox> TheHunter, which takes me forever to understand.
08:53:01 <metaperl> I am enjoying YAHT much more than "Gentle".
08:53:05 <lightstep> i prefer the lisp style
08:53:26 <Philippa_> having syntax highlighting on the operators certainly helps
08:53:32 <TheHunter> good look doing currying in lisp style.
08:53:35 <xerox> TheHunter, it mostly depends upon being used to some syntax.
08:53:58 <Philippa_> and a good many natural languages use infix
08:53:59 <TheHunter> xerox, no it doesn't. Prefix is just harder to read sometime.
08:54:57 <Philippa_> for a trivial example, "I hate prefix" :-)
08:55:01 <lightstep> with the correct combinators, you don't want currying
08:55:04 <TheHunter> mathematicians have used infix syntax for ages and their language is very concise.
08:55:50 <lightstep> this style favors lots of `let's though
08:56:11 * TheHunter hates lets.
08:56:17 <xerox> TheHunter, okay, it's because a different shift in thought that lispers prefers being constrained to prefix while Haskellers doesn't, I can understand it.
08:56:39 * Philippa_ likes let and where. They're damn useful when you want to get the main design over fast and then fill in the tedious details
08:57:01 <xerox> where is kinda good, yep.
08:57:17 * lightstep doesn't understand where
08:57:20 <TheHunter> but let is an evil artefact from languages where evaluation order matters.
08:57:47 <Philippa_> TheHunter: no, it's significant for scoping purposes amongst other things
08:57:49 <lightstep> did you try to tie the knot without let?
08:57:50 <xerox> I think let* is.
08:57:52 <TheHunter> s/where evaluation order matters/eagerly evaluated langues/
08:57:58 * TheHunter is ashamed.
08:58:01 <lightstep> (though this is an artifact of lazy evaluation)
08:58:20 <TheHunter> where is perfectly fine for tying the knot.
08:58:44 <lightstep> i don't understand where, but isn't it the same as let?
08:59:02 <xerox> In some sense..
09:00:26 <TheHunter> Philippa_, i agree you sometimes need it, but that doesn't make me like it.
09:00:57 <lightstep> btw, i do think that having nested infix is good
09:00:57 <TheHunter> let introduces unneccesarry details before the important things happen.
09:01:33 <Philippa_> 'sa matter of writing style, I guess
09:01:42 <lightstep> sometimes the stages of computation are important
09:02:14 <Philippa_> IMO that's usually when you should be defining a few helper funcs
09:03:04 <lightstep> i like using let* when running monad transformers
09:08:08 <metaperl> I need some help
09:08:09 <metaperl> Main> map Char.toUpper "jsjao;idfjal;ksjdflkasjdfjw"
09:08:09 <metaperl> ERROR - Undefined qualified variable "Char.toUpper"
09:08:09 <metaperl> Main>
09:09:36 <lightstep> are you running in Haskell98 compatibility mode?
09:09:48 <metaperl> I dont know. I typed hugs
09:09:56 <metaperl> and then tried that expression and it failed
09:10:03 <lightstep> oh, wait, the module name isn't heirarchical, so it shouldn't matter
09:10:26 <metaperl> did I need to import Char somehow?
09:10:28 <lightstep> maybe you should tell hugs to import Char
09:10:36 <lightstep> err, sorry for the lag
09:10:52 <metaperl> Main> import Char
09:10:52 <metaperl> ERROR - Syntax error in expression (unexpected keyword "import")
09:10:52 <metaperl> Main>
09:11:04 <lightstep> try :?
09:12:35 <metaperl> that showed a list of help
09:12:55 <metaperl> this shouldn't be so difficult :)
09:13:17 <lightstep> it should tell you how to import modules (i don't have hugs here)
09:14:39 <lisppaste2> metaperl pasted "hugs :? output" at http://paste.lisp.org/display/5994
09:15:10 <xerox> Sorry for re-asking, is partial application lazy evaluation applied to function application?
09:15:36 <lightstep> it can be modeled this way
09:16:16 <lightstep> metaperl, i'm lost there too
09:16:25 * metaperl sighs
09:16:31 <metaperl> thanks for your interest
09:25:00 <Oejet> metaperl: Try :load Char
09:35:06 <Heffalump> try :m +Char in ghci, too
09:35:15 <Heffalump> or maybe in hugs too
09:37:19 <metaperl_> Prelude> :m +Char
09:37:19 <metaperl_> ERROR - Cannot find module "+Char"
09:37:19 <metaperl_> Prelude> :m Char
09:37:19 <metaperl_> ERROR - Cannot find module "Char"
09:37:26 <metaperl_> shapr
09:37:31 <shapr> you screamt?
09:37:32 <metaperl_> howya doin ol buddy ol pal?
09:37:35 <metaperl_> yes:
09:37:35 <metaperl_> Prelude> :m +Char
09:37:35 <metaperl_> ERROR - Cannot find module "+Char"
09:37:35 <metaperl_> Prelude> :m Char
09:37:35 <metaperl_> ERROR - Cannot find module "Char"
09:37:43 <shapr> :m + Data.Char ?
09:37:47 <metaperl_> I cannot do this: map Char.toUpper "hello world"
09:38:04 <lightstep> :m + Char
09:38:05 <Philippa_> ever get that horrible feeling that just as you've finally worked out something smart, somebody else's been and done it?
09:38:15 <shapr> Philippa_: every day.
09:38:16 <metaperl_> Prelude> :m + Data.Char
09:38:17 <metaperl_> ERROR - Cannot find module "+"
09:38:17 <metaperl_> Prelude> :m +Data.Char
09:38:17 <metaperl_> ERROR - Cannot find module "+Data.Char"
09:38:18 <metaperl_> Prelude> :m Data.Char
09:38:18 <metaperl_> ERROR - Cannot find module "Data.Char"
09:38:19 <metaperl_> Prelude>
09:38:26 <Igloo> metaperl_: What version of what interpreter is this?
09:38:32 <metaperl_> the "+" business is not working...
09:38:34 * Philippa_ is discovering that HM(X) looks a lot like the set of fun extensions to Tyop she wanted to play with
09:38:36 <metaperl_> Igloo I am using hugs
09:38:40 <Igloo> :l Char then
09:38:43 <Philippa_> well, except AIUI there's no rank-n fun
09:38:48 <metaperl_> is there a better haskell interpreter?
09:38:50 <Philippa_> but hey
09:38:54 <Philippa_> GHCi's nice
09:38:59 <Philippa_> plus you get GHC
09:39:25 <Igloo> That's an interesting way of thinking about it, Philippa_  :-)
09:39:42 <Philippa_> well, he did ask for an interpreter
09:39:51 <Philippa_> would phrase it the other way round were a compiler requested :-)
09:40:39 <shapr> @seen duncan
09:40:40 <lambdabot> I haven't seen duncan
09:40:58 <Philippa_> on the bright side, reading up on HM(X) is also helping me zero in on this duality between ADTs and type classes I keep trying to nail down
09:41:44 <SyntaxNinja> hi shapr
09:42:25 <lightstep> what's GM(X)
09:42:26 <lightstep> ?
09:43:06 <shapr> y0 SyntaxNinja
09:43:18 <Philippa_> lightstep: a constraint-based extension to the Hindley-Milner type system. It's parameterised on a bunch of design decisions about the constraint system, hence the X
09:43:43 <shapr> oj, topmind has find lambda-the-ultimate.
09:45:14 <shapr> 'found'
09:45:18 <shapr> SyntaxNinja: wassup?
09:51:59 * shapr tries to remember how to work WASH
09:52:41 <shapr> CosmicRay: is your WASH code in a darcs repo?
09:53:01 <shapr> Anyone else here uses WASH? I'd like to see code written by others to see what I might have missed.
09:58:11 <metaperl_> CosmicRay uses WASH
09:58:43 <Igloo> I might have the minesweeper I wrote at AFP
09:58:43 <shapr> CosmicRay: helooo
09:58:57 <shapr> Igloo: if you wrote it in WASH, I'd like to see it.
10:01:39 <Igloo> http://urchin.earth.li/~ian/mine/ (no idea what the state of it is)
10:01:57 * Igloo disappears
10:04:02 <shapr> Igloo: thanks!
10:08:09 <shapr> CosmicRay: hey, isn't HAppS pretty much the same as Twisted?
10:24:47 <xerox> Aawwww.
10:30:51 <jhunZoa> hey
10:35:13 * CosmicRay looks in
10:35:36 <CosmicRay> shapr: I have no public wash code right now
10:35:51 <CosmicRay> shapr: also I am somewhat wash-ignorant right now
10:35:56 <CosmicRay> as you can tell by my post to -cafe
10:36:32 <CosmicRay> haven't heard of HAppS, got a URL?
10:38:03 <metaperl_> I never thought I would say this, but I am starting to prefer $ or . when chaining functions:
10:38:05 <metaperl_> length $ filter isLower "aBCde"
10:38:21 <metaperl_> I like it better than (length. filter isLower) "aBCde"
10:38:32 <CosmicRay> how about length . filter isLower $ "aBCde"
10:38:47 <metaperl_> and certainly more than the Scheme style... oh you are twisting my brain with that
10:39:03 <metaperl_> that confuses me
10:39:18 <CosmicRay> it looks to the compiler just like your second example
10:39:24 <CosmicRay> the bit to the left of the $ is a function
10:39:25 <tic> metaperl_, (length (filter (isLower "aBCde"))) isn't that bad, though
10:39:31 <CosmicRay> and the bit to the right is the args
10:39:39 <CosmicRay> tic: tut tut, that looks like lisp :-)
10:39:53 <tic> CosmicRay, hrm, I thought scheme shared the same syntax of Lisp.
10:40:05 <tic> or rather, the lack thereof
10:40:17 <CosmicRay> tic: yes.  that's one reason I'm using Haskell :-)
10:40:19 <zamez> can someone explain $ to me, please?
10:40:38 <metaperl_> the pan page does it best zamez... hold on.
10:40:56 <jhunZoa> anyone here ever done a db excersise in haskell?
10:41:24 <CosmicRay> an exercise?
10:41:49 <CosmicRay> zamez: $ is the function application operator.  The bit to the left is the function, and the part to the right is the args.
10:42:02 <CosmicRay> f(x) and f $ x are the same.
10:42:08 <CosmicRay> as is f x
10:42:10 <jhunZoa> ye
10:42:13 <jhunZoa> like for school
10:42:34 <CosmicRay> so $ is just syntactic sugar, that helps eliminate parens at times
10:42:36 <zamez> ok, and it has a low precedence?
10:42:43 <CosmicRay> right.
10:42:47 <CosmicRay> the lowest, iirc.
10:42:53 <CosmicRay> or almost, anyway.
10:43:08 <zamez> thanks
10:43:53 <CosmicRay> tic: if anyone comes up to me dreaming up a brand new language, and excitedly says "it uses the same syntax as lisp!!!!", I will be highly dubious :-)
10:44:30 <Philippa_> an explicitly-staged lisp would be useful, but beyond that there's not much you can do
10:46:02 <CosmicRay> to me, lisp is the fortran of functional programming :-)
10:46:48 <metaperl_> I kind of like scheme syntax -- ultra simple, no precedence rules to remember
10:47:08 <metaperl_> great for beginners but maybe to wordy for experts
10:47:14 <CosmicRay> it literally makes my wrists hurt to write so many parens
10:47:24 <Philippa_> for me, the point of lisp is that it /isn't/ a (purely) functional language - it's just what you get when you insist on a language being as meta as possible, IYSWIM
10:47:38 <metaperl_> Larry Wall said "Lisp looks like oatmeal with fingernail clippings thrown in it"
10:47:48 <CosmicRay> haha
10:47:53 <CosmicRay> I love Wall quotes.
10:48:02 <tic> CosmicRay, yeah :)
10:48:17 <metaperl_> but I am not looking forward to Perl6
10:48:18 <tic> lisp isn't really that functional, though, is it?
10:48:20 <Philippa_> I'm not sure Wall has much right to complain - toothpicks, anyone?
10:48:35 <tic> bleh, Perl looks like line noise.
10:48:41 <Philippa_> tic: some lisps (scheme, say) are as functional as, say, ML
10:48:44 <CosmicRay> Philippa_: I think that Perl looks like a vat of used auto parts :-)
10:48:53 <metaperl_> Perl has lots of stop characters. Perl5 is very readable to me... lots of things jump out at you
10:48:55 <CosmicRay> tic: functionality optional :-)
10:49:02 <tic> Philippa_, yeah, but it's multi-paradigm, really.
10:49:05 <metaperl_> Perl is very english-like .... perl5
10:49:16 <metaperl_> perl6 is a wanna be language IMHO
10:49:19 * tic worships the snake
10:49:24 <Philippa_> tic: definitely. See comment about metaness (though staged execution is one thing it's kinda lacking in that regard)
10:50:04 <wilx> Wannabe?
10:50:05 <wilx> Why?
10:50:08 <CosmicRay> metaperl_: you may be surprised to find some of those same features in Haskell.  we have unless, for instance
10:50:35 <metaperl_> perl6 wants to be ruby and haskell
10:50:40 <CosmicRay> heh
10:50:48 <CosmicRay> but definitely not python, eh? :-)
10:50:55 * wilx crosses finger
10:50:57 <wilx> s
10:52:05 <jhunZoa> a list is a string of characters right?
10:52:19 <CosmicRay> no.  a string is a list of characters.
10:52:27 <tic> Haskell and Python are the languages I prefer to use.
10:52:32 <jhunZoa> i meant that ;p
10:52:32 <CosmicRay> a list may contain any number of things of any type.
10:52:40 <jhunZoa> a list of characters ye
10:52:43 <CosmicRay> jhunZoa: lambdabot is helpful
10:52:44 <CosmicRay> @type String
10:52:45 <lambdabot> bzzt
10:52:52 <CosmicRay> jhunZoa: never mind.
10:53:05 <CosmicRay> stupid lambdabot
10:53:42 <metaperl_> the corporate world for programming: Java has the most jobs,... Perl much less but Python even much less
10:53:45 <CosmicRay> metaperl_: oh, you may be interested in some of the regexp libraries out there for haskell
10:53:47 <jhunZoa> i was pointed earlier on some .se site which had some kind of *wizard style* documentation
10:53:56 <jhunZoa> anyone know which site i mean?
10:54:05 <CosmicRay> jhunZoa: no idea, but shapr might know
10:54:10 <metaperl_> my comp.lang.functional post is what turned me onto haskell
10:54:21 <CosmicRay> jhunZoa: if you need help learning Haskell, check out YAHT: http://www.isi.edu/%7Ehdaume/htut/
10:54:22 <metaperl_> some guy pointed me to context-sensitive regexp library for haskell
10:54:32 <jhunZoa> i search that specific site
10:54:32 <metaperl_> yes, that is better than "Gentle"
10:54:38 <jhunZoa> it was a very good resource
10:54:44 <CosmicRay> metaperl_: oh, you probably mean Pesco's regexp, maybe?  the one that looks very Perll-ish?
10:54:50 <jhunZoa> i got documentation from my teacher to learn haskell but its crap
10:55:08 <jhunZoa> after i learned what foldr does i have to make a database engine in haskell
10:56:16 <metaperl_> CosmicRay, this is it: http://repetae.net/john/computer/haskell/hsregex/hsregex-0.2/docs/RRegex.Syntax.html
10:56:27 <CosmicRay> http://www.scannedinavian.org/~pesco/code/Regex/
10:56:28 <CosmicRay> ah
10:56:41 <CosmicRay> that's the one with the pcre binding, I believe
10:56:45 <CosmicRay> check out Pesco's
10:56:47 <CosmicRay> you'll like it even more
10:56:55 <CosmicRay> though it uses posix REs
10:57:00 <CosmicRay> h8n posix re
10:57:29 <CosmicRay> he does have docs but you have to use lhs2tex to build them
10:57:35 <CosmicRay> I can e-mail you a pdf if you'd like
10:57:46 <CosmicRay> or you can just read Pesco.lhs
10:58:07 <CosmicRay> \section*{Motivation}
10:58:07 <CosmicRay> When asked the inevitable\footnote{``Does it support regexes?''}
10:58:07 <CosmicRay> by a Perl programmer, what do we answer?
10:58:07 <CosmicRay> \begin{quote}
10:58:07 <CosmicRay> Of course it does, it uses the POSIX regex library
10:58:14 <CosmicRay> that's a little snippet :-)
10:59:49 <CosmicRay> pesco's is pure Haskell, too.
11:00:19 <Philippa_> IMO the correct response is "yes, but why use regexes when we have parsec?"
11:00:45 <CosmicRay> because regexps are a hell of a lot less verbose and clumsy when dealing with many simple string matters
11:00:50 <CosmicRay> I use parsec too
11:00:59 <CosmicRay> it makes a far better, say, config file parser than regexps
11:01:05 <Heffalump> there's a PCRE binding too, isn't there?
11:01:06 <CosmicRay> (and I know, I've read python's ConfigParser source)
11:01:13 <Heffalump> posix REs are horribly verbose
11:01:20 <CosmicRay> Heffalump: that's in the one that metaperl quoted
11:01:31 <CosmicRay> Heffalump: pesco's is a wrapper around the existing posix re
11:01:41 <CosmicRay> Heffalump: well, not really.. my main gripe is the lack of \d, etc.
11:01:49 <CosmicRay> or rather [[:digit:]] or some such crap instead of \d
11:01:49 <metaperl_> [:digit:] instead
11:01:57 <metaperl_> but I dont mind the verbosity
11:02:00 <metaperl_> of posix regexps
11:02:42 <Forest> coming to haskell to java: in java rather deep recursion causes SO, as i understand recursion calles in haskell is a very common practice, what about approximate number of recursive function calls before SO ?
11:02:57 <Forest> *from java
11:03:01 <jhunZoa> s0?
11:03:05 <jhunZoa> SO?
11:03:11 <Forest> stack overflow
11:03:25 <jhunZoa> oh thats way to hard for me ~
11:03:26 <CosmicRay> Forest: well there are two factors to consider here.
11:03:36 <CosmicRay> Forest: first, haskell has tail recursion optimization
11:03:54 <CosmicRay> Forest: so carefully-defined recursive functions can be infinitely recursive
11:04:22 <CosmicRay> Forest: a tail-recursive function is basically one whose return value is directly the result of calling itself, without applying any calculations to the return value of calling itself.
11:04:25 <Forest> only tail recursion ?
11:04:38 <CosmicRay> Forest: those are the only ones opimitized in such a way.
11:04:42 <CosmicRay> Forest: but haskell is also lazy
11:04:51 <CosmicRay> Forest: which means that recursion only happens when necessary.
11:05:06 <CosmicRay> for instance, if you have a recursive function that processes a list, and you feed it a list of 1000 elements.
11:05:12 <CosmicRay> then you call head on the result...
11:05:24 <CosmicRay> the function will only be called enough times to process the very first element.
11:06:04 <Forest> i know that already )
11:06:08 <CosmicRay> ok :-)
11:06:34 <Forest> what about cases when rucursion could be simply replaced by loop in an imperative language
11:06:35 <CosmicRay> other than that, you can adjust the stack size with +RTS parameters to ghc-compiled programs
11:06:37 <jhunZoa> is there something like : but for the back of a list?
11:06:44 <jhunZoa> or would i do xs:x instead
11:06:49 <CosmicRay> Forest: you should be able to implement all of them using tail recursion
11:07:06 <Forest> jhunZoa: tail list )
11:07:16 <CosmicRay> Forest: or something such as map or fold*
11:07:24 <jhunZoa> ye ok thx
11:07:33 <metaperl_> a lot has to be said for lisp-style syntax though. I developed this function sf from inside out
11:07:34 <metaperl_> sf t  = fst (head (tail t))
11:07:34 <metaperl_>  
11:07:34 <metaperl_> sfdat = [(5,'b'), (1, 'c'), (6, 'a')]
11:07:35 <Philippa_> in the case it's a genuinely new iteration pattern, you can write your own HOF once and fill in the blanks repeatedly
11:07:56 <CosmicRay> metaperl_: very similar in haskell
11:08:00 <CosmicRay> sf = fst . head . tail
11:08:13 <metaperl_> no, what I did _is_ haskell
11:08:16 <CosmicRay> metaperl_: in fact, that looks like haskell already
11:08:17 <CosmicRay> ah :-)
11:08:19 <metaperl_> lol
11:08:23 <metaperl_> lololol
11:08:25 <Philippa_> but the . operator is useful
11:08:40 <Philippa_> we don't need actual lisp syntax, thankfully
11:08:46 <metaperl_> oh, that is nice how you created a curried composed function
11:08:53 <CosmicRay> metaperl_: it suddly occured to me... head and tail look like haskell, you should be using indecipherable functions like car :-)
11:09:10 <CosmicRay> metaperl_: that's a common haskell idiom too
11:09:28 <metaperl_> I actually built the function as I was thinking it out. I put (tail data) on the line and then put (head (tail data)) and then put (fst (head (tail data)))
11:09:43 <metaperl_> hahah, car and cons
11:09:43 <CosmicRay> metaperl_: I wrote an article for Free Software Magazine this month.  I started it with "I like to say that Haskell manipulates functions with the same ease that Perl manipulates strings" :-)
11:10:00 <metaperl_> the thing I love about Haskell is that strings are lists of haracters
11:10:01 <jhunZoa> that will scare people off prolly ;P
11:10:09 <CosmicRay> jhunZoa: heh
11:10:12 <metaperl_> you dont have to learn string functions and list functions
11:10:18 <CosmicRay> metaperl_: I agree
11:10:24 <CosmicRay> metaperl_: that is one of my big gripes about ocaml
11:10:35 <jhunZoa> well i would learn string and list functions
11:10:41 <jhunZoa> haskell requires so much brain power
11:10:55 <mflux> yes, if in ocaml you want to do something useful with strings, it's easier to just convert the string into a list and back
11:10:59 <CosmicRay> jhunZoa: no, it's just that it's so different from everything else you've ever used
11:11:03 <jhunZoa> ive never spended 2-3 hours on a 2 word function :P
11:11:16 <CosmicRay> jhunZoa: if you programmed this way since you were 5, it would be perfectly natural :-)
11:11:25 <jhunZoa> ye prolly
11:11:35 <jhunZoa> i think haskell -> java is easier
11:11:35 <CosmicRay> jhunZoa: I know what you mean though
11:11:45 <CosmicRay> jhunZoa: it took me awhile to pick up, and I still have so much to learn
11:11:52 <CosmicRay> but I am already very productive with it
11:12:11 <jhunZoa> my teacher expect me to know the basics in 2 days for the exam
11:12:16 <jhunZoa> in 2 weeks :|
11:12:23 <metaperl_> i am enjoying studying with YAHT... "Gentle" should be renamed "Dry Example-Barren Introduction to Haskell"
11:12:43 <jhunZoa> YAHT?
11:12:55 <metaperl_> but perhaps I should not be so harsh ... at least "Gentle" is around
11:13:11 <CosmicRay> metaperl_: I agree completely
11:13:19 <CosmicRay> jhunZoa: http://www.isi.edu/%7Ehdaume/htut/
11:13:30 <CosmicRay> metaperl_: gentle is completely misleading
11:14:00 <metaperl_> a gentle introduction to interpersonal communication by Jeffrey Dahmer
11:14:02 <humasect> i forgot to paste this here, http://pleac.sourceforge.net/pleac_haskell/index.html
11:14:08 <CosmicRay> metaperl_: several of us are working on a new tutorial, IO-centric, for people that come from perl/python/java backgrounds
11:14:12 <metaperl_> a gentle introduction to ballet by Shaquille O'Neal
11:14:18 <CosmicRay> hah
11:14:26 <metaperl_> a gentle introduction to leadership by Drill Sergeant Chuck Powers
11:14:34 <CosmicRay> a gentle introduction to peace by George Bush
11:14:39 <metaperl_> lol
11:14:40 <metaperl_> LOL
11:14:45 <Forest> haha
11:15:26 * CosmicRay bookmarcs that pleac url
11:16:04 <CosmicRay> that's right.  The USA.  Only 2 wars in the last 4 years.
11:16:39 <humasect> =(
11:16:41 <metaperl_> IO-centric tutorial I think is a bad idea... that isthe ugly side of haskell
11:16:50 <CosmicRay> metaperl_: no, it's not
11:16:59 <metaperl_> get them happy with the beauty and elegance
11:17:12 <metaperl_> you notice monads and the like are introduced around ch.9 of gentle and yaht
11:17:13 <CosmicRay> I start with this simple grep example:
11:17:22 <CosmicRay> import MissingH.List
11:17:22 <CosmicRay> main = do
11:17:22 <CosmicRay>        c <- getContents
11:17:22 <CosmicRay>        putStr (unlines(filter (\line -> contains "Haskell" line) (lines c)))
11:17:54 <CosmicRay> I use it (and variations of it) to illustrate laziness, lists processing, passing of functions, etc
11:18:53 <metaperl_> what does unlines do?
11:19:04 <CosmicRay> @type unlines
11:19:05 <lambdabot> unlines :: [String] -> String
11:19:17 <CosmicRay> metaperl_: unlines takes a list of strings and inserts \n between each element
11:19:21 <CosmicRay> metaperl_: the result being one large string
11:19:36 <jhunZoa> mm i dont think i even learn haskell
11:19:46 <jhunZoa> we use helium
11:19:54 <jhunZoa> thats some library to haskell or so right?
11:19:55 <metaperl_> can you change the input record separator in haskell? what is a file is separated by 0x0A
11:20:24 <CosmicRay> metaperl_: in this case, you would just need custom lines and unlines functions
11:20:44 <CosmicRay> jhunZoa: MissingH is a library, yes; I just use contains from it in this example
11:20:45 <metaperl_> in an object-oriented language you could configure the reader for this
11:20:57 <metaperl_> you should not have to write new versions of those functions
11:20:59 <CosmicRay> metaperl_: those functions are things like lines = split "\x0A"
11:21:01 <CosmicRay> or whatnot
11:21:07 <metaperl_> in Perl, you simply set $/ = '0x0A'
11:21:16 <CosmicRay> metaperl_: right, but that is impoure
11:21:29 <metaperl_> oh
11:21:39 <CosmicRay> metaperl_: in haskell, if this was a desired property, you would likely pass the lines and unlines functions as arguments
11:21:40 <metaperl_> a function must always return the same output for the same input
11:21:44 <CosmicRay> so you could supply your own
11:21:45 <CosmicRay> right
11:21:54 <metaperl_> what about a random number function
11:22:01 <metaperl_> which uses CPU idle time as seed
11:22:06 <metaperl_> that is impure I take it?
11:22:08 <CosmicRay> metaperl_: it returns an IO action
11:22:18 <CosmicRay> metaperl_: you might have random :: IO Int
11:22:29 <Philippa_> yes, you'd get the seed in the IO monad. You can implement the rest as an infinite list of random numbers if you want them handy in pure functional code
11:24:26 <CosmicRay> metaperl_: lines and unlines are simply convenience functions; it would be trivial to adjust this example to accept any separation character, or even any separation function...  it could be arbitrarily complex, perhaps parsing apart output from some mainframe report or something
11:25:19 <metaperl_> CosmicRay, those are the things you want to cover
11:25:26 <CosmicRay> yes
11:25:36 <metaperl_> I am a Perl programmer of 5 years. I hang outin perlnewsgroups, etc... I know what Perl people think like
11:25:36 <CosmicRay> metaperl_: darcs get http://darcs.complete.org/haskell-v8 if you're interested
11:26:08 <CosmicRay> metaperl_: it would be great to get your input on what we have.
11:26:10 * Philippa_ is inclined to point out that if you really want to have fun with parsing, parsec is very much your friend
11:26:20 <CosmicRay> and yes, philippa is right
11:26:29 <CosmicRay> parsec scales up far better than regexps do
11:26:34 <mflux> so what would that example look like written in parsec?
11:26:56 <CosmicRay> mflux: I have several in MissingH.  A configuration file parser and a FTP protocol parser.
11:27:09 <metaperl_> yes, CosmicRay, include that in yoru article too. I would like to see some parsec
11:27:10 <CosmicRay> mflux: http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html probably has a few
11:27:13 <mflux> yes, but I would expect them both to be wildly more complex than that ;)
11:27:36 <Philippa_> metaperl_: do string "foo" <|> string "bar" <- have a guess what that does
11:27:59 <metaperl_> CosmicRay, are you John Goerzon?
11:27:59 <CosmicRay> the parsec docs are quite decent
11:28:03 <CosmicRay> metaperl_: yes
11:28:22 <metaperl_> you dont list haskell in your intersts on your webpagehttp://www.complete.org/jgoerzen/
11:28:33 <CosmicRay> gar.
11:28:37 <CosmicRay> I suck.
11:28:39 * CosmicRay fixes.
11:29:26 <CosmicRay> there.
11:32:25 <Muad_Dibber> do you? :P
11:33:35 <CosmicRay> not anymore :-)
11:37:47 <Itkovian> @seen boegel
11:37:48 <lambdabot> I saw boegel leaving #haskell 22 hours 24 minutes 44 seconds ago.
11:39:25 <metaperl_> Main> string "foo" <|> string "bar"
11:39:25 <metaperl_> ERROR - Undefined variable "<|>"
11:39:25 <metaperl_> Main>
11:40:48 <TheHunter> metaperl_, you need parsec and you need to import the parsec module.
11:40:56 <CosmicRay> metaperl_: you have to import Text.ParserCombinators.Parsec
11:40:57 <metaperl_> oh
11:40:59 <TheHunter> The easiest way to get parsec is through ghc
11:41:08 <CosmicRay> also you need to know how to bootstrap the parser
11:41:26 <CosmicRay> this and other mysteries are revelead at http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html
11:43:19 <Calister> g'evening
11:44:05 <CosmicRay> hi callister
11:44:19 * metaperl_ heads to lunch
11:45:00 * Calister waves
12:05:46 * shapr boings
12:05:48 <shapr> bringert: y0
12:06:07 <bringert> evnin' guv'nr
12:06:13 <shapr> tja gubbe
12:06:23 <Calister> heya shapr
12:06:34 <shapr> Guten Abend Calister
12:06:40 <Calister> Guten Abend :)
12:06:43 <xerox> What does it mean: "foldr can work on infinite lists" ?
12:06:59 <shapr> xerox: think about foldr versus foldl
12:07:45 <bringert> shapr: time to start thinking about eurohaskell for real now?
12:07:50 <shapr> yeah, I think so
12:07:54 <shapr> I gotta buy plane tickets.
12:08:00 <xerox> It 'attacks' the list from the right
12:08:11 <xerox> I'd better lookup fold definition
12:08:25 <desrt> isn't the 'l' or 'r' where most of the brackets go?
12:08:37 <xerox> desrt, yep
12:08:47 <desrt> like if you foldr over [1..4] you get (1+(2+(3+4)))
12:09:22 <shapr> bringert: What about the weekend after EuroPython?
12:10:53 <shapr> Some chalmers people are organizing a Swedish Linux event the weekend after EuroPython.
12:10:59 <bringert> July 2-3?
12:11:12 <xerox> ones = 1 : ones
12:11:18 <xerox> foldr (+) 0 ones
12:11:21 <shapr> bringert: right, yeah.
12:11:22 <Heffalump> that clashes with the second phase of ICFP
12:11:27 <xerox> Is it considered as "working" ?
12:12:00 <Heffalump> xerox: well, (+) isn't a very useful operator, cos it's strict
12:12:35 <xerox> Heffalump, hmm, can you make an example of a lazy one?
12:12:41 <Heffalump> well, (++)
12:12:52 <Heffalump> or any number of more complicated operations
12:13:04 <Heffalump> anything that produces partial output based on partial inputs
12:13:16 <Igloo> const might be a good one to see what's going on
12:13:41 <bringert> shapr: I seem to be unavailable June 27 - July 8
12:13:49 <shapr> oh
12:13:59 <bringert> I can still help organizing, but I probably won't be able to attend
12:14:08 <shapr> tyvrr
12:14:28 <shapr> I was going to bring really adjustable unicycling hardware this time.
12:20:13 <xerox> What was the Haskell Paste Page on the wiki?
12:20:15 <shapr> bringert: thesis research?
12:20:21 <shapr> @wiki HaskellIrcPastePage
12:20:22 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
12:20:28 <shapr> Ya know, a shorter name might be good
12:20:31 <shapr> like PastePage
12:20:49 <xerox> Yep.
12:21:13 <bringert> shapr: nope, I presented my thesis last week
12:21:19 <shapr> Both?
12:21:34 <shapr> I still think the joke about doing one thesis for both degrees was pretty funny.
12:21:43 <xerox> It's better to paste at the top or at the bottom?
12:21:51 <shapr> Of course, I'm often the person who laughs most at my own jokes. Funny how that happens.
12:21:53 <shapr> xerox: wherever you want.
12:22:57 <bringert> ah, right, I have another one in the pipeline. forgot about that
12:23:03 * shapr snickers
12:23:07 <shapr> scary!
12:23:17 <shapr> Was the last one that stressful? traumatic amnesia?
12:24:48 <bringert> which one? what are you talking about?
12:24:53 * shapr laughs
12:25:07 <shapr> I'll take that as a yes.
12:26:05 <shapr> bringert: done anything fun lately?
12:26:26 <bringert> it went pretty ok actually
12:26:43 <int80_h> hello :)
12:26:54 <bringert> thesis work isn't that much fun towards the end, but now I feel pretty free to work on cool stuff
12:27:07 <shapr> Was it the GF thesis?
12:27:15 <shapr> hiya int80_h
12:27:34 <int80_h> I'm looking into california schools that focus on functional programming, or at least acknowledge it
12:27:45 <Heffalump> Berkeley?
12:28:07 <int80_h> hmm, Bez
12:28:09 <xerox> Heffalump, I can see (++) or more complicated operations get results.
12:28:22 <int80_h> Berkeley is a long shot. Maybe UC santa cruz.
12:30:43 <bringert> shapr: yeah
12:31:06 <bringert> hmm, I should put it online as a matter of fact, thanks for bringing it up
12:32:32 <tmoertel> SyntaxNinja: I just sent out the cabal2rpm announce on the Fedora Haskell list.
12:34:07 <bringert> oh, there's a cabal2rpm? sweet!
12:34:55 * bringert has 2913 unread mails in his haskell folder
12:35:00 * bringert needs to catch up
12:35:05 <shapr> delete!
12:35:08 <shapr> start over!
12:35:11 * shapr grins
12:37:17 <shapr> bringert: hej, did I tell you I'm putting Curryspondence online for a client? I think stepcut got 'first commercial use of HaskellDB' but I can be second or third :-)
12:37:44 <bringert> you're also first online commercial use of HaskellDB afaik
12:38:00 <shapr> I thought stepcut` was using it for linspire?
12:38:16 <bringert> yeah, but it's not on the public www afaik
12:38:21 <shapr> ah, ok
12:38:30 <bringert> have you worked more on curryspondence? is there a public demo online?
12:38:35 <xerox> there is no "let" in hugs ??
12:39:12 * bringert reads the fedora haskell page
12:39:19 <shapr> I haven't really done anything more than update it for version changes in the libs, but I'm going to whip up a .css for it by Monday.
12:39:21 * bringert is thinking of switching distros
12:39:33 <shapr> What are you using now?
12:39:36 <bringert> will the client app be public?
12:39:40 <bringert> mandrake
12:39:40 <tic> Could this be implemented more efficently? updateState s x v = (x, v):[(x', v')|(x', v')<-s, x' /= x], where updateState :: [(a, b)] -> a -> b -> [(a,b)]
12:39:41 <shapr> Yes it will.
12:39:46 <bringert> cool
12:40:04 <shapr> I'm surprised no one has written a mailman archive search.
12:40:29 <bringert> are you using some fancy full-text indexing, or brute force?
12:40:32 <Heffalump> tic: are you seeking complexity improvements or constant factors?
12:40:59 <Heffalump> xerox: you can't make top-level definitions at the hugs prompt
12:41:01 <tic> Heffalump, constact factors. Like, if there's a more efficient way than O(n)
12:41:13 <Heffalump> huh? make up your mind..
12:41:26 <Heffalump> O(n) is a complexity issue, not a constant factor one
12:41:32 <xerox> Heffalump, it is really annoying, thank you.
12:42:22 <Cale> xerox: if you use ghci, you can type "let f x = blah"
12:42:24 <shapr> Hmm, a curryspondence debian package would be easy enough to install that regular people might use it.
12:42:41 <xerox> Cale, I do, but I'm trying to "teach" some Haskell to a friend whose has problem with emacs, so he better likes hugs..
12:42:43 <tic> Heffalump, okay, so then it's me not understanding what you meant by complexity vs. constanct factors.  Either way, that's what I'd like to optimize.
12:42:56 <shapr> bringert: brute force for haskell lists, but only because the full text indexing is limited to 8192 max, and I've got ~8200 max.
12:43:08 <Heffalump> tic: if x has an ordering, you can use some kind of balanced tree
12:43:09 <Cale> xerox: huh? You can use ghci without emacs.
12:43:21 <shapr> really?
12:43:22 <shapr> ;-)
12:43:23 <Heffalump> standard trick would be to use Data.FiniteMap or similar
12:43:29 <xerox> Cale, you think ? :D
12:43:39 <tic> Heffalump, right, a hash table is probably what I'm looking for.
12:43:42 <shapr> I would never do such a thing. ghci without emacs?
12:43:44 <Heffalump> yeah, I've heard some sick people use it with vi
12:43:52 <tic> Heffalump, the list is going to be pretty small, so it's really not much of an issue in practice.
12:43:56 <shapr> Right, I've obviously reached way silly.
12:44:01 <bringert> shapr: hmm, tricky. could you make a hack that splits messages into chunks which are stored in a separate table, and each chunk has a message id
12:44:10 <shapr> bringert: hm true
12:44:30 <shapr> is truly a cheesy hack, but would scale to any size.
12:44:32 <Heffalump> or build your own indexes
12:44:50 <shapr> but at that rate, why use HaskellDB/PostgreSQL?
12:44:58 <Heffalump> errm, to store them?
12:45:12 <shapr> I could just use some of Pseudonym's reverse index code, it'd probably be faster.
12:45:29 <shapr> I could even build suffix trees without much trouble.
12:46:31 <bringert> well, you might want to allow filtering the results for example
12:46:45 <bringert> have a DB would help there, right?
12:47:00 <shapr> yeah, true
12:47:03 <bringert> I mean filter by mailing-list, sender, date or something
12:47:09 <tic> How do you send && as a higher-order function argument to a function in Haskell?
12:47:13 <tic> a lambda?
12:47:19 <monochrom> (&&)
12:47:23 <tic> Thanks.
12:48:47 * bringert looks in the fridge
12:48:59 * bringert sees beer, coke, ketchup and lemon juice
12:49:07 * bringert should eat at home more often
12:49:21 <shapr> We have five cans of tuna fish, want some?
12:49:33 <bringert> yes, could you dcc me one?
12:49:45 <shapr> hm, what's the mime type? I could email one.
12:49:53 <bringert> food/tuna?
12:49:57 <shapr> heh, probably
12:50:18 <bringert> wasn't there an AC-over-IP RFC a while back?
12:50:21 <tic> I always keep 10-20 cans of tuna at home. :)
12:50:44 <bringert> there you go, rfc 3251
12:50:58 <shapr> AC?
12:51:11 <shapr> alternating current?
12:51:11 <bringert> "RFC 3251 - Electricity over IP"
12:51:27 <shapr> yow
12:51:32 <bringert> not Anonymous Cowards
12:51:37 * CosmicRay returns
12:51:53 <psi> yow
12:51:53 <shapr> psi: tuna!
12:51:53 * shapr runs away
12:51:53 <bringert> slashdot figured that one out already
12:52:27 <shapr> Actually, I am seriously starving for tuna suddenly.
12:52:27 <shapr> must have tuna!
12:52:27 <shapr> and it's bedtime for me too
12:53:11 * psi is eating candy
12:53:11 <shapr> bringert: hey, did you see HAppS?
12:53:11 <shapr> looks neat - http://happs.org/HAppS/README.html
12:53:32 <bringert> yeah, just saw the announcement, haven't look at it yet
12:53:33 * shapr runs for tuna
12:53:50 <bringert> CosmicRay: that HaskellDB spacing thing is strange. I'm sure I've done stuff like that without problems
12:53:55 <bringert> did you try showSql?
12:55:37 <CosmicRay> bringert: I can try it
12:55:46 <CosmicRay> bringert: though isn't that what's getting called internally anyway?
12:56:04 <bringert> more or less, yes
12:56:21 <bringert> I'm just concerned that it might be something lower down messing with the query
12:56:31 <CosmicRay> hsql is doing OK
12:56:38 <CosmicRay> I'm going direct through it for now
12:57:15 <CosmicRay> could you drop me an e-mail or a comment on that bug as a reminder?  I'll have to back out some code changes to rnu it and it's not a convenient time right this moment
12:57:26 <CosmicRay> bringert: how about that variable numbering thing
12:57:29 <CosmicRay> adding "1" after the vars
12:57:36 <bringert> yes, that's strange
12:57:38 <CosmicRay> that was really weird
12:58:36 <bringert> I've gotta take time and sit down and test this stuff. It would go a lot faster if you could put the code up somewhere, inclusing table creation and that stuff
12:59:12 <CosmicRay> bringert: this is going into an ERP system database.  The tables aren't created using SQL, but they can be read and modified with SQL
12:59:32 <bringert> hmm, since these don't depend on the backend, the DBdirect-generated stuff + the query code should be anough
12:59:35 <bringert> enough
12:59:37 <CosmicRay> bringert: so I have unix odbc drivers
12:59:41 <CosmicRay> ok
12:59:46 <CosmicRay> I can tar up my DBDirect stuff for you
12:59:57 <CosmicRay> my query code I think you have already in the bug reports
13:00:08 <CosmicRay> there are 842 tables in this dbdirect set
13:00:18 <CosmicRay> took it a little while to generate all of them, and a long while to compile all of them :-)
13:01:32 <CosmicRay> bringert: could I e-mail this tarfile to you?
13:01:39 <CosmicRay> 1.1MB
13:01:42 <bringert> dude
13:01:52 <bringert> that just source code?
13:01:59 <CosmicRay> yes
13:02:10 <CosmicRay> my .a is around 50MB :-)
13:02:22 <CosmicRay> and that 1.1MB is gzipped :-)
13:04:28 <CosmicRay> let me know if you need anything else
13:05:03 <CosmicRay> amazingly, DBDirect used very little RAM to do its thing
13:05:18 <CosmicRay> it seemed to write out all the files at once, at the end, but I don't think it used more than 10MB of ram
13:05:41 <bringert> seems reasonable, even keeping all the files in ram would take about 10MB
13:06:09 <CosmicRay> oh, you have to set -fcontext-stack pretty high to build this
13:06:17 <CosmicRay> I finally set -fcontext-stack550 and it seemed to work
13:06:17 <bringert> I can imagine
13:10:28 * Igloo hasn't been following, but surely you could make a somewhat smaller test case?!
13:10:38 <CosmicRay> heh
13:11:06 <Calister> g'night all
13:11:08 * Calister waves
13:11:13 <CosmicRay> cya calister
13:11:25 * xerox impressed a python guy with Haskell, be proud of me, yay ;)
13:11:56 <Cale> yay :)
13:12:08 <CosmicRay> :-)
13:12:25 <Igloo> xerox: But surely that is the natural direction? Now if you can impress a Haskell guy with python, that would be a feat to be impressed by  :-)
13:12:33 <CosmicRay> heh
13:12:43 <xerox> Is it possible to write a (=<<) version of: foo sep = (=<<) $ (++) . (++ sep)
13:12:48 <xerox> whoops.
13:12:56 <xerox> Is it possible to write a (=<<) version of: foo sep = foldr1 $ (++) . (++ sep)
13:13:11 <xerox> Or just a better one ;)
13:13:59 <Igloo> concat . intersperse sep
13:14:19 <xerox> @index intersperse
13:14:20 <lambdabot> Data.List,List
13:15:06 <xerox> Great.
13:17:16 <xerox> I don't know *many* utility functions.. it's so bad :)
13:17:20 * bringert didn't get CosmicRay's mail
13:17:24 * bringert looks in the spam folder
13:17:37 * bringert sees > 11000 emails in there
13:17:57 <bringert> almost 15000 actually
13:18:25 <bringert> shapr: how many mails do you have in your curryspondence setup?
13:18:46 <a5> what do we use to read email?
13:19:26 <bringert> hi a5
13:19:37 <bringert> I just replied to your HSQL/HList mail
13:19:49 <bringert> a5: I use thunderbird, what do you use?
13:21:46 <a5> something i wrote with mutt, w3m, a cgi script, and a perl filter so i get folders and cross-posting
13:21:58 <a5> but i want to rewrite in haskell and sql
13:22:09 <a5> 'cause mutt is slow to load
13:22:26 <bringert> did you see curryspondence?
13:22:37 <bringert> shapr's mailing list archive searching tool
13:25:46 <a5> not yet
13:27:39 <xerox> TB here too.
13:29:27 <a5> "did you mean: correspondence"
13:29:35 <bringert> hehe
13:29:41 <bringert> guess that's the point
13:29:46 <a5> is there a home page?
13:30:00 <bringert> we'll ask shpar about it when he gets back from eating tuna or whatever he's doing
13:30:07 <bringert> shapr of course
13:31:27 <metaperl_> welp, the sysadmin installed GHCi, so out of hugs I come ...
13:31:41 <bringert> CosmicRay: I never got your email
13:45:47 <CosmicRay> bringert: hmm, checking...
13:45:48 <metaperl_> @url prelude
13:45:49 <lambdabot> Sorry, I don't know the command "url", try "lambdabot: @listcommands"
13:45:58 <metaperl_> @whereis Prelude
13:45:58 <lambdabot> Sorry, I don't know the command "whereis", try "lambdabot: @listcommands
13:46:07 <metaperl_> @listcommands
13:46:08 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
13:46:08 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
13:46:08 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
13:46:08 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
13:46:08 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
13:46:09 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
13:46:11 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
13:46:13 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
13:46:14 <bringert> CosmicRay: ok got it now
13:46:15 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
13:46:18 <metaperl_> @prelude
13:46:18 <CosmicRay> Feb 22 15:41:53 gatekeeper postfix/smtp[2878]: 76C7882475: to=<bjorn@bringert.ne
13:46:18 <CosmicRay> t>, relay=iris2.directnic.com[204.251.10.82], delay=2234, status=sent (250 2.0.0
13:46:18 <CosmicRay>  1568643 octets saved (421BA700.0004C237.IRIS2.5880.44637269.1))
13:46:19 <CosmicRay> ok
13:46:38 <metaperl_> @prelude url
13:49:48 <lambdabot> ERROR: connect: timeout (Connection timed out)
13:50:13 <CosmicRay> weird.
13:52:22 <metaperl_> I want to browse through the haskell prelude... is there a URL for this?
13:52:28 <lightstep> http://haskell.org/onlineprelude/
13:52:32 <CosmicRay> metaperl_: do you want source or docs?
13:52:37 <lightstep> or apt-get install haskell-prelude
13:52:53 <metaperl_> I think mainly the API for now... I might get curious and stare at implementation but mainly docs for now
13:52:54 <CosmicRay> metaperl_: docs are at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
13:52:56 <lightstep> http://haskell.org/onlinereport/  -- that's it
13:53:17 <CosmicRay> lightstep's url is also valid, it is more of the spec than the usage in some cases
13:53:21 <CosmicRay> you'll probably want both
13:53:50 <metaperl_> ok thanks
13:55:35 <CosmicRay> btw http://www.haskell.org/ghc/docs/latest/html/libraries/index.html should be your constant companion
13:56:02 <lightstep> Graphics.UI.WX is really cool, much more than caml's Graphics
13:58:58 <bourbaki> moin
14:03:46 <metaperl_> does anyone have a small example of when the identity function is useful?
14:05:58 <Philippa_> when you're working with a higher-order function and it makes sense as one of the parameters
14:08:11 <_timor> for example, when you want to fold a list of functions with the composition operator '.', you would use the identity function as the starting poing
14:08:45 <_timor> starting point
14:08:46 <Philippa_> right, I've done that on other types with other identities enough times
14:12:12 <metaperl_> oh yes, that makes perfect sense
14:12:14 <metaperl_> thanks
14:14:48 <jlouis> Hmmm, Parsec plays around with me
14:16:24 <PerlJam> geez
14:16:37 <SyntaxNinja> hi PerlJam
14:16:46 <PerlJam> greetings SyntaxNinja
14:17:02 <PerlJam> It looks like here's the intersection of perl and haskell as I see lots of familiar nicks  :)
14:17:06 <PerlJam> and python too
14:18:18 <jlouis> Parsec question: I want a parser that succeds if the input is (string "<?") or eof, but does _not_ consume the input
14:18:22 <bringert> godd night #haskell
14:18:41 <PerlJam> So Cale was telling me about monads on #perl6 and I walked off to do something else and had what I think is a minor revelation about monads.  Would it be safe to say that programming with monads is the ultimate in object oriented programming?  :-)
14:19:41 <SyntaxNinja> it would not be safe to say that, someone might lash out at you ;)
14:19:51 <Cale> hehe
14:20:13 <Cale> I suppose it depends on what you mean by object oriented programming :)
14:20:22 <SyntaxNinja> but it's hard to know what you mean by OO; typically in OO, the data is carried around with its functions, you have subtyping, virtual function dispatch, etc.,
14:20:27 <SyntaxNinja> none of this is there in Haskell
14:20:36 <SyntaxNinja> except some types of subtyping
14:21:23 <lightstep> Aren't type classes implemented as vtables?
14:21:53 <PerlJam> Cale: your monads-as-containers seems like OOP to me :-)
14:22:50 <SyntaxNinja> lightstep: not sure really. the mechanism isn't the question though, IMO
14:22:57 <PerlJam> SyntaxNinja: haskell has "subtyping" and "encapsulation" and "methods" and all dispatch is "virtual" in a way  :)
14:23:01 <SyntaxNinja> "it's all just pointers" right?
14:24:28 <SyntaxNinja> a lot of the ideas are indeed shared. subtyping, encapsulation, and functions are nice abstractions that it's useful for a programming language to have
14:25:07 <SyntaxNinja> I'm not sure that they are OO ideas. but maybe if you define OO for us, we'll try to decide if Haskell can meet your idea of OO using monads :)
14:25:22 <SyntaxNinja> I don' tknow what you mean by "all dispatch is virtual" though
14:25:40 <lightstep> If OO is good programming, Haskell is definitely OO.
14:25:50 <CosmicRay> jlouis: look at "try" in parsec (it will not consume input if it fails)
14:25:53 * esap can define OO: OO is a programming paradigm that enforces the following constraint: "code size == space usage".
14:25:57 <CosmicRay> jlouis: I don't know of lookahead right off the top of my head
14:26:46 <SyntaxNinja> esap: heh
14:27:00 <lightstep> perhaps you could fail with different values according to whether you parse it or not, and catch one of them
14:27:15 <int80_h> wallabi :)
14:27:21 <int80_h> oops wrong channel
14:28:06 <esap> SyntaxNinja: Actually Many OO facilities are for controlling space usage. And making programmers write more code to spend additional amount of space is a good way to reduce space usage.
14:29:02 <SyntaxNinja> esap: are you saying that C++'s template syntax is cumbersome intentionally to make you use it less often? :)
14:29:04 <zamez> OO is snake-oil
14:29:06 * zamez hides
14:29:13 <Pseudonym> Actually, OO != space usage.
14:29:14 <SyntaxNinja> PerlJam: see what I mean ;)
14:29:26 <SyntaxNinja> maybe we should just start another channel right now
14:29:34 <int80_h> is not snake oil. It cures all software development problems.
14:29:40 <PerlJam> nah, I can live with it if you can.
14:29:40 <Pseudonym> Modern C++ Design(tm) supports the idiom of wasting huge amounts of memory, a little bit at a time.
14:29:42 <esap> PseudoNym: I just defined OO as programming paradigm to enforce "code size == space usage"
14:29:45 <int80_h> I read that from some microsoft author.
14:29:58 <Pseudonym> Not that C++ is an OO language.
14:30:02 <esap> SyntaxNinja: Templates are not actually very much related to OO.
14:30:17 <Pseudonym> No.  C++ is a multi-paradigm language, just like Haskell.
14:30:21 <Pseudonym> Well, not quite like Haskell.
14:30:42 <SyntaxNinja> esap: yeah, bad example.
14:31:11 <PerlJam> fwiw, C++ is one of the poorest examples of a good OOP  ;)
14:31:25 <Pseudonym> Stroustrup would agree with you.
14:31:46 <esap> PerlJam: C++ is not intended to be (just) an OO language.
14:31:51 <Pseudonym> Right.
14:32:01 <PerlJam> esap: indeed.  Thus its short comings
14:32:10 <esap> PerlJam: That's what's the problem with Java. It tries too hard to be just an OO language.
14:32:12 <Pseudonym> No, I disagree with that.
14:32:23 <Pseudonym> Not being a pure OO language is not a shortcoming of C++.
14:32:34 <PerlJam> Pseudonym: would you agree that it's a simultaneous blessing/curse?
14:32:35 <Philippa> the problem with Java is that it tries too hard to be a pure OO language *and look like C at the same time*
14:32:40 <Pseudonym> The main shortcoming of C++ is the community of imperative-thinking programmers.
14:32:49 <Pseudonym> PerlJam: Yes, but not in the way you think.
14:32:52 <Philippa> that, and having an imperative core hurts it bad
14:32:53 <esap> OO is quite restricted thing. OO is only good for building platforms. Not everything is a platform.
14:33:00 <PerlJam> Pseudonym: you can read my mind?  wow!  :-)
14:33:19 <Pseudonym> Being primarily an imperative language, it tacitly encourages people to program in what is basically C with a few extra bits.
14:33:22 <Pseudonym> And THAT hurts C++.
14:33:31 <Pseudonym> Even though having C available is one of C++'s strengths.
14:33:36 <zamez> I dunno, Pseudonym
14:33:40 <PerlJam> I knew haskell was powerful and that haskell hackers are smart, but I had no idea about mind reading.
14:33:54 <Pseudonym> Oh, that's going to be in 6.4.
14:33:59 <monochrom> don't hide your thoughts
14:34:03 <zamez> in my experience it's the opposite, a lot of the developers I know try and stuff everything into objects
14:34:10 <PerlJam> Pseudonym: That's for sure.  I can't tell you then number of people I run into who say they are C programmers when really they've learned enough C++ to be dangerous
14:34:10 <Pseudonym> These aren't the paradigms you're looking for.  Move along.
14:34:15 <Pseudonym> Right.
14:34:30 <esap> Pseudonym: I wouldn't agree. C++ doesn't actually encourage much of anything. That's its problem, whatever the programmer thinks is "the paradigm", C++ does support it somewhat. The problem is, most people have very bad ideas about what's good software engineering.
14:34:40 <PerlJam> zamez: That's stage 2 in learning a new programming language.
14:34:55 <jlouis> C++ is a swiss army knife.
14:34:59 <Pseudonym> If people were forced to program in an OO style (like Smalltalk or Eiffel/Sather), I agree that'd show OO's strengths more than C++ would.
14:35:14 <Pseudonym> jlouis: As opposed to Perl, which is a swiss army chainsaw.
14:35:20 <PerlJam> heh
14:35:26 <jlouis> Pseudonym: exactly
14:35:28 * PerlJam was sensing a shift in the force
14:35:42 <Pseudonym> But I don't think C++ is the problem.
14:35:46 <zamez> the other day my boss wrote a program to look for a particular line in a log file, in C++
14:35:51 <PerlJam> *programmers* are the problem.
14:35:56 <Pseudonym> I think people should spend a year or two programming in Smalltalk, Sather or Erlang BEFORE touching C++.
14:36:04 <Pseudonym> Then they might develop some good OO habits.
14:36:04 <PerlJam> zamez: your boss is tool deficient?
14:36:06 <zamez> dunno what my point is
14:36:18 <zamez> just would have been much easier in say Perl
14:36:23 <jlouis> zamez: system("grep ...") ?
14:36:30 <gzl> esap: that's funny, since I had a talk by Stroustrup recently on "how to write C++ as a native"
14:36:32 <int80_h> do you think python teaches the same good habits?
14:36:40 <Pseudonym> There you go.
14:36:56 <Pseudonym> Stroustrup doesn't like people treating C++ like a glorified C either.
14:37:01 <PerlJam> int80_h: I think python does teach some good habits.
14:37:01 <int80_h> because I thought python would be god for that, but maybe smalltalk instead?
14:37:13 <gzl> Pseudonym: yeah, he doesn't
14:37:14 <int80_h> good OOP habits I mean
14:37:14 <esap> gzl: I'd expect he focused on RAII and exception-safety etc?
14:37:40 <gzl> he focused on "multi-paradigm programming"
14:37:43 <Pseudonym> int80_h: Speaking as someone who never learned Python, and hence doesn't know a damn thing, Python teaches some good habits.
14:37:49 <Pseudonym> But Python isn't an OO language either.
14:37:53 <PerlJam> heh
14:37:54 <esap> gzl: right.
14:37:59 <Pseudonym> Right.
14:38:01 <int80_h> it's not? Python's author bills it as OOP
14:38:02 <gzl> not exception-safety in particular
14:38:03 <PerlJam> Pseudonym: python is as OO as perl is :)
14:38:14 <Philippa> esap: C++ has really bad support for any paradigm that effectively requires garbage collection
14:38:15 <Pseudonym> PerlJam: Agreed.  Possibly a little bit more so.
14:38:23 <Pseudonym> Python isn't as OO as Smalltalk is.
14:38:23 <gzl> but he did have a few words on exception safety
14:38:26 <gzl> anyway
14:38:27 <tromp> python is more OO than perl but less than ruby
14:38:32 <int80_h> but I am learning from my book on haskell that many features that OO languages tout as "why OO is good", have nothing to do with OO per se.
14:38:32 <PerlJam> Pseudonym: yeah, almost certainly a little more so
14:38:34 <Philippa> in that while you have some memory management hooks, you can't get better than a conservative collector
14:38:57 <esap> philippa: Well maybe the problem is with those paradigms. You don't want a paradigm to assume you have infinite memory. GC does that.
14:39:00 <Pseudonym> int80_h: Which book is that?
14:39:08 <int80_h> um hold on I may have it
14:39:09 <jlouis> int80_h: You will find that many of the concepts are the same of what people call ``non-OO'' languages
14:39:18 <MachinShin> hey +
14:39:29 <Pseudonym> Something that people don't appreciate is that OO languages and declarative languages are solving the same problem.
14:39:32 <int80_h> The Craft of Function Programming.
14:39:36 <Pseudonym> Namely, that global state is evil.
14:39:38 <int80_h> erm Functional
14:39:38 <Philippa> esap: pure FP, logic programming etc are problematic paradigms, then
14:39:44 <Pseudonym> OO's solution is lots of encapsulated local states.
14:40:00 <Pseudonym> Declarative's solution is no global state, but you can simulate it if you need it.
14:40:08 <esap> pseudonym: They're not solving the same problem. OO is solving the problem "how do you write a platform". declarative languages solve the problem "how do you write applications". Not at all the same problem.
14:40:18 <Pseudonym> No, I disagree with that.
14:40:26 <Pseudonym> The problem is: How do we write managable software?
14:40:30 * PerlJam too
14:40:34 <PerlJam> ding!
14:40:46 * Philippa is tempted to point out that a monad and the support types for its semantics kinda constitute a platform
14:40:58 <Pseudonym> Lambda: The Ultimate Platform!
14:41:01 <esap> pseudonym: Ah, but OO doesn't solve that problem fully. Neither does FP.
14:41:11 <Philippa> you can rig up as many bastardised IO monads as you like, in that regard
14:41:15 <PerlJam> Pseudonym: I see how you read my mind now ... our brainwaves are operating at a similar frequency and are almost in phase.
14:41:25 * Pseudonym points out the Symbolics Lisp machines predate Alan Kay's stuff
14:41:32 <Pseudonym> PerlJam: :-)
14:41:41 <Pseudonym> esap: Bingo!
14:41:58 <Pseudonym> But they both appproach it asymptotically, as research continues.
14:42:05 <PerlJam> Philippa: I wouldn't have used those words but that's kind of what I meant by monads being the ultimate in OOP.
14:42:43 <esap> pseudonym: My understanding is that having BOTH OO and FP will get you much closer to solving the problem. I'm not sure all manageable software is solved that way, of course.
14:42:45 <Philippa> yeah. I don't consider them that in that you end up with something completely different. It's more like rewriting the laws of physics that govern how objects interact
14:43:11 <Philippa> I'm tempted to say the way to go in that regard is to develop FP further and emulate OO when you feel the need
14:43:13 <zamez> isn't the problem "why do we have bugs?"
14:43:46 <Philippa> no, the problem's "how do we prevent them". We have them because people make mistakes and because there's room for mistakes to happen
14:43:48 <Pseudonym> esap: I think that's true, to some degree.
14:43:57 <SyntaxNinja> I think PerlJam is a spy from the perl world sent to decrease our productivity by bringing up OO comparisons on a language channel.
14:43:59 <int80_h> hey does haskell have DB hooks, into such ones as mysql or postgres?
14:44:08 <PerlJam> heh
14:44:13 <Pseudonym> One of FP's problems at the moment is that while there's a lot of work done on abstraction, there isn't as much as there could be on encapsulation.
14:44:13 <SyntaxNinja> int80_h: yes, hsql
14:44:14 <PerlJam> heh!
14:44:15 <int80_h> double agent!
14:44:17 <Pseudonym> O'Caml notwithstanding.,
14:44:33 <int80_h> syntaxNinja, did I not see you in #C?
14:44:33 <zamez> yeah, you're right
14:44:43 <esap> Here's a way to think about OO and FP that'll explain my view about it: OO classes correspond exactly to state machine states in FP.
14:44:55 <Pseudonym> esap: Yes, I agree.
14:44:59 <Pseudonym> The exemplar being Erlang.
14:45:07 <PerlJam> SyntaxNinja: or, more likely, I'm slowly converting into a haskell programmer but I still have all of these procedural and object oriented and other such nonesense ideas in my head
14:45:08 <SyntaxNinja> int80_h: nope. similarly someone recently accused me of being previously obsessed with C#, but that was never the case.
14:45:17 <int80_h> okay I have to wrap my head around how you can have state machines when you aren't allow to change anything
14:45:36 <Pseudonym> Erlang is, IMO, the closest thing we currently have to an OO FP should be.
14:45:37 <int80_h> I was thinking about that the other day
14:45:51 <Philippa> Pseudonym: I may be weird, but I'm not convinced there's further need wrt encapsulation?
14:45:55 <esap> int80: you mean in FP? State machines are just functions with hidden input and output.
14:46:02 <Pseudonym> Philippa: I think there is.
14:46:06 <int80_h> thanks esap :)
14:46:07 <Pseudonym> Here's an example.
14:46:17 <Pseudonym> Consider FiniteMap.
14:46:23 <int80_h> yeah I was trying to adjust my thinking about state machines in an FP context.
14:46:39 <Pseudonym> Hmmm.
14:46:41 <Pseudonym> Yes.
14:46:43 <Pseudonym> OK.
14:46:46 <int80_h> but this is the whole point about why I am learning haskell and lisp, to adjust my thinking.
14:46:48 <PerlJam> int80_h: see, that's my problem.  I'm not a native FP thinker yet.
14:46:50 <Pseudonym> Suppose you wanted to implement that as a hash table.
14:47:00 <Pseudonym> At the moment, you need to implement that on top of a monad.
14:47:12 <Pseudonym> If you want any performance at all.
14:47:16 <Pseudonym> Usually IO.
14:47:21 <Pseudonym> That's not good encapsulation.
14:47:42 <esap> int80: There are actually many approaches to doing state machines (e.g. moore machines vs. mealy machines vs. ...), but it's not really relevant for an OO vs FP discussion.
14:48:01 <int80_h> PerlJam, I think it's like a foriegn language. Once you start having FP dreams, you are good to go.
14:48:17 <int80_h> esap: no I was derailing the thread. :) I admit it.
14:48:20 <Pseudonym> The lack of a decent data structure library in Haskell, I think, is testament to the fact that not all of the encapsulation problems have been solved.
14:48:23 <int80_h> or hijacking it.
14:48:40 * Pseudonym possibly didn't explain that well; need more caffeine
14:48:56 <PerlJam> int80_h: fortunately I dream in a combination perl/perl6 these days.  Maybe that's unfortunate.  I don't know  :-)
14:49:11 <int80_h> I had a lisp dream, but it was very simplistic
14:49:23 <Heffalump> Pseudonym: will that POPL '05 paper about having datatypes in classes help with that encapsulation problem?
14:49:26 <int80_h> nothing very lispy about it I think
14:49:31 <Philippa> Pseudonym: would having a typeclass for variable-supporting monads be sufficient?
14:49:36 <monochrom> need some kind of linear logic/type.  you write your program as though it's a state transformer.  compiler generates state mutating code.  The linear type guarantees that there is no problem.
14:49:37 <Pseudonym> Heffalump: Which one is that?
14:49:39 <PerlJam> int80_h: lisp and even scheme are the stuff of nightmares not dreams.  ETOOMANYPARENS
14:49:52 <Philippa> IOW, "you can use these datatypes under any set of semantics that supports the means to implement them"
14:49:58 <Pseudonym> Heffalump: Without looking at the paper, from your one-sentence description it sounds like it would help.
14:49:59 <int80_h> heh, my editor handles the parens, I just look at the indentation.
14:50:00 <Heffalump> Manuel Chakravarty, Gabriele Keller, Simon PJ and possibly a 4th person (Geoffrey Washburn?)
14:50:03 <Pseudonym> Dependent types would also help.
14:50:08 <Heffalump> I forget the title.
14:50:17 <integral> PerlJam: Haskell is the stuff of nightmares not dreams; ETOOFEWPARENS ;-)
14:50:21 <kosmikus> Heffalump: Associated Types With Class, iirc
14:50:25 <Heffalump> that's the one
14:50:32 <Pseudonym> Oh, yeay, that's it.
14:50:44 <Pseudonym> Yes, that would definitely help.
14:50:52 <Pseudonym> Even if it is only syntactic sugar. :-)
14:50:58 <PerlJam> integral: no way!  Haskell is positively beautiful comparatively
14:51:06 * Heffalump wants a good way to switch between data-structures
14:51:10 <Heffalump> and in and out of monads
14:51:14 <Pseudonym> Yeah.
14:51:37 <Heffalump> a bit of TH to monadify a program would be nice.
14:51:54 <kosmikus> I think it's a good paper; I don't buy this whole nonsense about "it can be encoded using fundeps"
14:52:00 <Philippa> Heffalump: agreed
14:52:30 <Philippa> really, what's needed is a uniform syntax for monadic and non-monadic code
14:52:38 <Pseudonym> kosmikus: I'm unconvinced either way.
14:52:44 <esap> philippa: Why?
14:52:47 <Heffalump> that's hard, since monadic code has ordering constraints and non-monadic code doesn't, and you don't want them
14:52:58 <Pseudonym> It _might_ be encoded using fundeps, but that doesn't make the syntactic sugar unimportant.
14:53:03 <int80_h> okay here is my understanding of mondas thus far, please correct or modify. It's a construction used to interface with the non-functional outside world.
14:53:09 <int80_h> is this correct?
14:53:13 <Pseudonym> No.
14:53:16 <Philippa> esap: because that way you can swap out the semantics underneath without having to refactor because the semantics happened to be pure
14:53:18 <int80_h> erm monads
14:53:19 <Heffalump> int80_h: no. That's one application to which they are put.
14:53:25 <int80_h> oh okay :)
14:53:29 <kosmikus> well, the fundeps argument is used far too often at the moment, and even if it isn't meant that way, it effectively blocks interesting changes to the language
14:53:43 <int80_h> I have more reading to do then
14:53:44 <Pseudonym> You can think of monads as an abstraction of sequential computation.
14:53:49 <kosmikus> I don't think fundeps are good at all, and they're defined by implementation only
14:53:53 <PerlJam> int80_h: have you read "All About Monads"?
14:53:54 <Pseudonym> Of which interfacing to the outside world is but one example.
14:53:57 <Heffalump> Pseudonym: careful, TheHunter might be listening
14:53:59 <int80_h> PerlJam no
14:54:00 <kbrooks> Heh.
14:54:11 <Pseudonym> Heffalump: Sorry, lsot me.
14:54:14 <PerlJam> int80_h: google for it and read.
14:54:20 <int80_h> thanks I will
14:54:23 <Heffalump> he's very big on the fmap/join view of monads
14:54:29 <Pseudonym> Ah.
14:54:30 <esap> philippa: IF you want to swap semantics, you should use abstraction. Syntax is for _expressing_ things. If you depend on some specific semantics, you should really depend on it.
14:54:34 <Heffalump> what is it with all these foo.user domains?
14:54:35 <Pseudonym> Monads, not Kleisli Triples!
14:54:48 <Pseudonym> The distinction is apparently important in 2-categories.
14:54:50 <kbrooks> Heffalump, it isn't a domain
14:54:58 <kbrooks> it's a mask
14:55:02 <int80_h> I always thought Heffalumps were fairy tales.
14:55:04 <kosmikus> Heffalump: you can get a cloak from freenode if you ask, I think
14:55:08 <Pseudonym> According to the little bit of Moggi's paper that I actually understood.
14:55:09 <Heffalump> ah, right
14:55:13 <Philippa> esap: a common syntax is the intended abstraction. It's one reason we play with monads in the first place
14:55:27 <Heffalump> it's not a lilo-money-making-device?
14:55:29 <int80_h> yeah my sys admin got one after he got ddos'd
14:55:32 <kosmikus> I don't need it, have a better one ;)
14:55:52 <int80_h> I haven't gotten attacked yet so I haven't felt the need to jump through the hoops for a cloak
14:55:52 <Heffalump> int80_h: /me is a very real Heffalump
14:56:36 <Igloo> I think you do pay for vanity ones, but I'm not sure
14:56:45 <esap> philippa: Well in a sense yes. But monads do need to have concrete semantics. You have to depend on *something*. In case of Monads, that something is sequentiality (and complete control over input). If you want to remove that, then what do you any more have left?
14:56:55 <int80_h> yeah, I have gotten so much tech help from freenode I am going to send in a donation
14:57:09 <Heffalump> Philippa: anyway, what's wrong with the current monad syntax?
14:57:10 <Pseudonym> int80_h: And Pseudonym is my real name, too.
14:57:12 <int80_h> I certainly would not try to take on haskell without freenode
14:57:23 <Philippa> Heffalump: the having to refactor pure code into it every time you decide it should be less pure
14:57:35 <PerlJam> int80_h: Have you gone through "Yet Another Haskell Tutorial"?
14:57:36 <Heffalump> you could just abolish pure syntax, then :-)
14:57:49 <kosmikus> the #haskell channel is still the main reason why I am on freenode
14:57:51 <int80_h> yah I had an op named after me, int 80 something.
14:57:52 <Heffalump> my point is that the unification of monad and 'pure' syntax is just monad syntax.
14:58:00 <monochrom> Yeah, use the identity monad all the time. :)
14:58:05 <int80_h> not that one perljam, not yet
14:58:12 <PerlJam> int80_h: or, better for me, what resources are you using to learn haskell?
14:58:18 <Philippa> Heffalump: that's because atm the monad syntax rather relies on the pure syntax being embedded into it
14:58:19 <Pseudonym> Unfortunately, forcing everything into monad syntax would have the same problem as forcing C++ into the C syntax.
14:58:24 <Pseudonym> People would program imperative.
14:58:24 <int80_h> The Craft of Functional Programming
14:58:24 <PerlJam> I'm learning too and need some variation
14:58:31 <int80_h> and I am using hugs
14:58:50 <kbrooks> Wow.
14:58:57 <int80_h> it's a book, I had to order it from a far away library
14:59:01 <kbrooks> Tyoping rules.
14:59:06 <Heffalump> Philippa: I don't just mean that, I mean that monad syntax (plus single-argument function application) is the way to do everything if you want a 'unified' syntax.
14:59:09 <esap> philippa: Exactly. You don't want to use monad syntax except when the sequentiality matters. Actually, probably arrow syntax is more general and in some way better than Monad syntax, but it's also harder to use [I think]
14:59:30 <int80_h> because my lame ass school wouldn't have such a book
14:59:48 <int80_h> it's mostly "LURN LANUGAGE FOO IN @ HOURS!"
14:59:58 <int80_h> it makes me want to hurl.
15:00:05 <Heffalump> anyway. bed.
15:00:14 <rtega> lol
15:00:17 <Pseudonym> Night.
15:00:29 <monochrom> http://www.vex.net/~trebla/humour/programming_books.html
15:00:37 <int80_h> heh
15:00:41 <Pseudonym> "Teach Yourself Guide to the Black Art of Haskell Gurus Tricks for Dummies in 21 Days for Idiots"
15:00:44 <Philippa> Heffalump: I'm quite happy to take that as a unified syntax so long as I can eliminate all the "do" tokens :-)
15:00:50 <kosmikus> just because no one else advocates it ever: I still think that "Bird" is the best book to learn Haskell ...
15:00:58 <int80_h> yeah just like that
15:01:21 <int80_h> I got the one book they have on lisp, the one by Paul Graham. last person to check it out before me did so in 1996
15:01:26 <Heffalump> Philippa: sure, use >>= and \ -> instead
15:01:33 <kbrooks> reading YAHT.
15:01:43 <Philippa> Heffalump: Too. Damn. Clunky.
15:01:45 <Heffalump> kosmikus: not many people seem to like it in comparison to Bird+Wadler, though.
15:02:11 <Heffalump> Philippa: how about C, then. That's like monad notation without the 'do's.
15:02:20 <kosmikus> well, even Bird+Wadler is rarely recommended these days
15:02:20 * Heffalump gd&r
15:02:26 <int80_h> "how 2 hack haskell in 24 days for idiots."
15:02:40 <kosmikus> I don't mind either; still think it's vastly superior to both "Craft of" or "SOE"
15:02:44 <kosmikus> night, Heffalump
15:02:47 <Pseudonym> Heffalump: Except it's not Milner-typed.
15:03:06 <int80_h> kos: how so?
15:03:09 <Heffalump> well, replace the type system then use C.
15:03:13 <Heffalump> <gone>
15:03:20 <Pseudonym> That's not a dumb idea, actually.
15:03:24 <Philippa> I was about to say
15:03:36 <Philippa> bearing in mind that you retain partial application, HOFs etc etc
15:03:50 <Philippa> I'd already worked out a fair while back that the arrow notation's not far off C
15:03:58 <Pseudonym> This reminds me of someone who implemented Prolog (i.e. logic variables, backtracking and failing statements) on top of Modula-2.
15:04:03 <Philippa> foo = bar(baz) or foo <- bar -< baz, what's the difference? :-)
15:04:07 <Pseudonym> It was a very, very cool project.
15:04:46 <kosmikus> int80_h: I've none of the books here right now, so I can't give you any details. But I like how the Bird approach is relatively formal and theoretical. I know, this doesn't appeal to everyone, but I think it's quite adequate for FP.
15:05:19 <int80_h> I like formal and theoretical. is this book on a list at haskell.org?
15:05:28 <kosmikus> int80_h: while SOE gives a nice overview about things that can be done with Haskell, I think it's better suited as an advertisement than as a teaching book
15:05:30 <esap> philippa: Not much, the only I can think of now is better type checking for arrows [you need to distinguish ArrowApply and Arrow]
15:05:57 <kosmikus> int80_h: and for some reason, I don't like "Craft of" at all; I think the layout sucks, and most of the content and exercises are uninspired and boring
15:06:20 <int80_h> yeah the picture program motif I found uninspiring.
15:06:28 <Philippa> esap: yeah, GHC has -<< for putting an arrow in for that reason
15:06:32 <int80_h> rotate the picture 90 degress...yawn
15:06:48 <esap> philippa: And also ArrowChoice for 'case' and 'if'.
15:07:01 <int80_h> kos: is this book you like referenced on haskell.org?
15:07:13 <Philippa> well yeah, but either you have it solved or you don't, no?
15:07:31 <kosmikus> int80_h: yes
15:07:35 <Pseudonym> Quick darcs question.
15:07:37 <int80_h> last name bird
15:07:37 <Philippa> anyway, case/if just means you get to infer ArrowChoice
15:07:45 <Pseudonym> And this is only because I'm too lazy to read the docs.
15:07:46 <kosmikus> int80_h: right
15:07:48 <int80_h> so if I just look up the author Bird I will find it
15:07:52 <int80_h> okay thanks
15:07:53 <Pseudonym> Someone sent me a patch.  How do I incorporate it?
15:07:56 <esap> philippa: yes, just like -<< means you get to infer ArrowApply :-)
15:08:11 <Philippa> but -<< wasn't part of the original spec
15:08:14 <int80_h> I hope he likes HUGS, because I sure do
15:08:17 <Philippa> you don't need a new construct for if/case
15:08:42 <esap> philippa: I think it
15:08:51 <esap> philippa: I think it's very good to distinguish -< from -<<.
15:09:31 <esap> philippa: Then you don't ever have problems with not understanding why your code requires ArrowApply.
15:09:37 <Pseudonym> Ah, found it.
15:10:03 <jlouis> hmm, does lambdabot know the address for lisppaste?
15:10:12 <int80_h> @lisppaste
15:10:13 <lambdabot> Sorry, I don't know the command "lisppaste", try "lambdabot: @listcommands
15:10:21 <int80_h> @lispcommands
15:10:21 <lambdabot> Sorry, I don't know the command "lispcommands", try "lambdabot: @listcommands
15:10:25 <int80_h> @listcommands
15:10:26 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
15:10:26 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
15:10:26 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
15:10:26 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
15:10:26 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
15:10:26 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
15:10:28 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
15:10:30 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
15:10:32 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
15:10:51 <int80_h> @karma+
15:10:51 <lambdabot> I can't find the karma of nobody.
15:10:56 <int80_h> @karma
15:10:57 <lambdabot> I can't find the karma of nobody.
15:11:07 <int80_h> @karma int80_h
15:11:08 <Pseudonym> @karma int80_h
15:11:08 <lambdabot> You have a karma of 0
15:11:08 <lambdabot> int80_h has a karma of 0
15:11:12 <Pseudonym> @karma+ int80_h
15:11:13 <lambdabot> int80_h's karma has been incremented.
15:11:13 * int80_h sobs
15:11:21 <humasect> ~_~
15:11:21 * int80_h smiles
15:11:27 <Pseudonym> @karma int80_h
15:11:28 <lambdabot> int80_h has a karma of 1
15:11:35 <Pseudonym> @karma Pseudonym
15:11:36 <lambdabot> You have a karma of 0
15:11:40 <Pseudonym> Oh well.
15:11:40 * int80_h flexes his mighty karma of 1.
15:11:47 <humasect> @karma+ Pseudonym
15:11:48 <lambdabot> Pseudonym's karma has been incremented.
15:11:57 <wallabi> @karma wallabi
15:11:57 <lambdabot> You have a karma of 0
15:12:07 <int80_h> wallabi you just got here :)
15:12:08 <Pseudonym> @cmafihe
15:12:10 <lambdabot> Nothing is universal.
15:12:18 <wallabi> :D,
15:12:33 <int80_h> wallabi sdf has a haskell interpreter called HUGS
15:12:46 <int80_h> so it's a good place to play with haskell
15:13:02 <jlouis> hugs is a nice interpreter
15:13:09 * esap thinks Nothing is not universal. Just is at least universally quantified :-)
15:13:14 <int80_h> good thing too, it's all we have at sdf.
15:14:17 <int80_h> @karma+ int80_h
15:14:17 <lambdabot> You can't change your own karma, silly.
15:14:21 * esap just notices that Nothing :: forall a. Maybe a, so _maybe_ I'm wrong :-)
15:14:27 <int80_h> @karma+ wallabi
15:14:28 <lambdabot> wallabi's karma has been incremented.
15:14:31 <jlouis> ok, since lisppaste irritates me, today, can I type a definition of 4-5 lines and get suggestions for making it shorter?
15:14:49 <metaperl_> I need some help on a type error: http://haskell.org/hawiki/WritingCryptDiscordian#preview
15:15:06 <metaperl_> my move_vowels function is throwing a type error
15:15:55 * int80_h saw move_*owels.
15:16:25 <monochrom> haha
15:17:06 <Pseudonym> metaperl_: Your problem is that your code is not fully parenthesis-compliant.
15:17:11 <wallabi> @karma wallabi
15:17:11 <lambdabot> You have a karma of 1
15:17:22 <monochrom> @karma monochrom
15:17:23 <lambdabot> You have a karma of 0
15:17:30 <monochrom> ...
15:17:34 <jlouis> splitString p str = List.unfoldr breaker str
15:17:34 <jlouis>   where breaker part =
15:17:34 <jlouis>           case break p part of
15:17:35 <jlouis>             ("", "") -> Nothing
15:17:44 <jlouis> (token, rest) -> Just (token, dropWhile p rest)
15:17:45 <monochrom> This proves that the natural numbers include 0. :)
15:17:58 <jlouis> it is a bit big for my haskell tastes. It is ok in SML
15:18:06 <tromp> of course, 0 is the most natural of all numbers
15:18:33 <metaperl_> Pseudonym, what do you mean?
15:18:36 <jlouis> splitString :: (Char -> Bool) -> String -> [String], by the way
15:18:52 <Pseudonym> metaperl_: Function application is the highest-binding operator.
15:19:03 <Pseudonym> Which means that f x:v is f with three arguments (x, : and v).
15:20:34 <metaperl_> oh, how I get it ... thanks :)
15:21:16 * kbrooks installs ghc
15:21:33 <kbrooks> cool.
15:21:43 <Pseudonym> Gee, that was quick.
15:21:54 * kosmikus laughs
15:21:55 * Pseudonym is guessing you didn't compile from source
15:22:31 <Darius> f x:v is (f x):v
15:22:43 <Pseudonym> Oh, yeah.
15:22:47 * Pseudonym really needs that caffeine
15:24:12 <xerox> Can you help me with split? I can't find a clean version.
15:24:48 <xerox> I mean some f "foo--bar--baz" "--" => "["foo","--","bar","--","baz"]
15:24:48 <metaperl_> Pseudonym, thanks. it works now
15:24:57 <metaperl_> can a function name start with underscore?
15:25:05 <metaperl_> I want to create an internal function not for the public API
15:25:35 <Pseudonym> metaperl_: You can selectively export functions from a module.
15:25:42 <tromp> @index groupBy
15:25:43 <lambdabot> Data.List,List
15:25:45 <Pseudonym> Or you could use a where clause, if it's only used by one top-level function.
15:26:11 <xerox> tromp, I'm trying using groupBy, but I did something "horrible" I think.
15:26:38 <tromp> what function did u group by?
15:26:49 <xerox> Yay, let me show you..
15:27:34 <xerox> (\x y -> (x /= sep) && (x /= sep) || (x == y))
15:28:15 <gzl> wait, you have (x /= sep) twice?
15:28:42 <xerox> whoops.
15:28:45 <xerox> (\x y -> (x /= sep) && (y /= sep) || (x == y))
15:28:49 <metaperl_> this "Evolution of a Haskell Programmer" webpage is awesome: http://www.willamette.edu/~fruehr/haskell/evolution.html
15:28:51 <xerox> It works, I think.
15:28:56 <xerox> metaperl_, it is.
15:28:59 <metaperl_> I'm scraping that for permanent storage
15:29:11 <tromp> looks ok
15:29:57 <xerox> tromp, but if I compare it with the inverse definition, it looks awful.
15:30:11 <tromp> what inverse def?
15:30:25 <xerox> I mean the definition of join.
15:31:01 <xerox> join sep = concat . intersperse sep
15:31:42 <tromp> thaty's not inverse
15:31:52 <xerox> ?
15:32:57 <tromp> that would be inverse of splitting foo--bar into ["foo","","bar"]
15:33:50 <tromp> but you're splitting into ["foo","--","bar"}
15:34:05 <tromp> quite different
15:34:33 <xerox> Hm, I see.
15:34:46 <Darius> The "inverse" would just be concat.
15:35:19 <tromp> well, it's only a left inverse:)
15:35:21 <xerox> You're probably right.
15:35:24 <gzl> if it helps, the MissingH List module has split functions and stuff
15:35:48 <xerox> gzl, where are those?
15:36:10 <gzl> http://quux.org/devel/missingh/html/MissingH.List.html
15:36:15 <Pseudonym> Anyway, time for free cakes.
15:36:27 <kbrooks> heh.
15:36:27 <gzl> if you don't care about writing it yourself you could just grab that
15:37:39 <xerox> hm, I need to clearify ideas.
15:37:58 <gzl> I'm surprised there isn't a built-in split function though
15:38:34 <metaperl_> would someone mind looking at the type error? It's under "hiding the internals" http://haskell.org/hawiki/WritingCryptDiscordian#preview
15:38:56 <metaperl_> my public API function calls the internal one, but GHCi is mis-interpreting my call to the internal function evidently
15:41:18 <xerox> gzl, is it possible to see the implementation of MissingH?
15:41:41 <gzl> yes
15:41:43 <gzl> download it
15:41:53 <gzl> it has all the .hs files
15:42:00 <gzl> that's just the documentation page
15:42:00 <kosmikus> metaperl_: are you sure the recursive calls in move_vowels shouldn't be to move_vowels' ?
15:42:33 <xerox> gzl, url of the .hs files?
15:42:48 <kosmikus> metaperl_: I mean the recursive calls in move_vowels' ...
15:42:49 <metaperl_> oh, good point
15:42:59 <gzl> dude just go up in the directory tree :) http://quux.org/devel/missingh/
15:43:11 <xerox> gzl, okay thanks.
15:44:43 <Oejet> metaperl_: What type is the value in: move_vowels' []     c v = (c,v)   ?
15:44:53 <metaperl_> it is fixed now...
15:44:57 <metaperl_> thanks Oejet
15:46:01 <Oejet> metaperl_: Did kosmikus' suggestion the trick?
15:46:48 <kosmikus> Oejet: are you new on #haskell, did you change nick, or did I just miss you so far?
15:47:23 <Oejet> kosmikus: Did you really miss me? :-P
15:47:37 <kosmikus> who knows ...
15:47:55 <xerox> 'night folks (thanks much as usual)
15:47:59 <metaperl_> yes it did
15:48:48 <kbrooks> now that IS a type error: Prelude> :t  fst . snd
15:48:48 <kbrooks> fst . snd :: forall a b a1. (a1, (a, b)) -> a
15:49:25 <mattam> kbrooks ?
15:50:19 <Oejet> kosmikus: I have been here for a while.  I live in the same timezone as Lemmih and jlouis.  Maybe our localtimes are rather incompatible?
15:50:28 <metaperl_> how do I alphabetically sort a string. e.g.  sorted = sort "HAIL ERIS"
15:50:54 <kosmikus> Oejet: ok
15:51:06 <kbrooks> it is.
15:51:19 <Itkovian> kbrooks, then what should it be?
15:51:20 <mattam> how is that ?
15:51:24 <kbrooks> i tried calling that function, and it didnt work.
15:51:25 <kosmikus> Oejet: what are you using Haskell for?
15:51:39 <Itkovian> eh?
15:51:46 <Itkovian> it seems to be perfect to me
15:51:51 <Oejet> kosmikus: Annoing my friends.
15:51:57 <gzl> metaperl_: ?
15:51:58 <Darius> metaperl_: Unless case doesn't matter, make a comparison function that compares alphabetically and use sortBy.
15:51:59 <gzl> metaperl_: you can just do sort
15:52:11 <Oejet> @type sort
15:52:12 <lambdabot> bzzt
15:52:19 <Darius> @type List.sort
15:52:21 <gzl> Prelude> List.sort "HAIL ERIS"
15:52:21 <gzl> " AEHIILRS"
15:52:21 <lambdabot> List.sort :: forall a. (Ord a) => [a] -> [a]
15:52:22 <Itkovian> @type Data.List.sort
15:52:24 <lambdabot> Data.List.sort :: forall a. (Ord a) => [a] -> [a]
15:52:43 <humasect> @karma+ humasect
15:52:43 <lambdabot> You can't change your own karma, silly.
15:52:59 <gzl> metaperl_: remember that strings are lists of characters
15:53:03 <humasect> karma changes me
15:54:34 <Darius> @eval ord 'a'
15:54:35 <lambdabot> unbound variable: ord
15:54:56 <Darius> @eval 'a' < 'B'
15:54:57 <lambdabot> False
15:55:03 <Oejet> kosmikus: And all the nice Haskell papers got a hold of me.
15:55:45 <Darius> @definitions sort
15:55:45 <lambdabot> []
15:56:03 <kosmikus> Oejet: :)
16:00:17 <Oejet> kosmikus: Oh, and I've written a connect-four brain which used alpha-beta search with pruning after Hughes paper.  It's slow though, because that's not the right algorithm for the job.
16:02:33 <Itkovian> gdnight
16:06:37 <Oejet> Argh, http://www.rasterman.com is being /.'et.
16:07:49 <Oejet> (Rasterman is one of the architechts behind the Enlightenment project.)
16:08:05 <lisppaste2> metaperl pasted "finished module to perform Discordian text encryption" at http://paste.lisp.org/display/6007
16:08:06 <dons> isn't he _the_ architect?
16:09:11 <Oejet> dons: I didn't remember/know.  Didn't want to step on anybodys toes.  Fortunately Rasterman willn't notice because he's being /. ;-)
16:10:06 <dons> yeah, don't think he's a haskell fan. more a C hacker.
16:10:34 <Oejet> dons: That would be my guess too. :-P
16:10:52 <MachinShin> Oejet: why now? has there been an update to e17a?
16:10:54 <dons> he went to unsw a couple of years before I did, but he is still famous around this place. he used to wear funny hats all the time, I seem to recall.
16:11:35 <dons> actually, they only taught Miranda back when Rasterman was at uni, so he may never have programmed Haskell at all.
16:11:39 <Oejet> dons: Oh, at uni we also has a guy who is wearing hats all the time.  "Hat man" he is being called.
16:11:48 <dons> hehe
16:12:14 <Oejet> MachinShin: He made some comment. :-P
16:12:35 <Oejet> dons: What is unsw?
16:13:01 <dons> Uni of NSW, in Sydney.
16:13:35 <Oejet> Uni of North South West in Sydney?
16:13:46 <dons> New South Wales ;)
16:13:53 <Oejet> He.
16:15:29 <dons> hehe. here is rasterman's 1996 3rd year graphics programmign assignment (designing a 3d logo): http://www.cse.unsw.edu.au/~lambert/logocomp/2154962/cse.java
16:15:41 <Oejet> dons: Rasterman is cool because he instist on doing things "the right way".
16:16:32 <dons> hehe. I love  the comment in the code:
16:16:35 <Oejet> Code style:  You will notice I make NO USE of OO, inheritance or anything. there are  // // no classes, nothing of the sort.
16:16:50 <dons> hehehaha
16:17:52 <dons> wow. he's really got some firm ideas about how to do graphics assignments.
16:18:15 <dons> more: Global variables.. okay SHOOT ME!
16:18:28 <dons> and: I'm being eviland using globals :-P
16:18:54 <MachinShin> Oejet: in which /. article?
16:19:58 <Oejet> Indeed.  I guess he got his butt kicked for not using OO.  I hope so, because I would have gotten that, and it's unfair if he didn't.
16:20:13 <Oejet> MachinShin: OSNews.com at least.
16:20:17 <dons> nah, he came first in the assignment
16:20:36 <dons> the logo he designed was used for within the school for a few years.
16:21:11 <dons> here (not sure if it still works): http://www.cse.unsw.edu.au/~lambert/logocomp/2154962/
16:21:19 <gzl> that guy's rant sounds kind of stupid
16:21:42 <gzl> he's no less closed minded than the people he's ranting about ;p
16:21:42 * Oejet recalls that Rasterman is not a programmer but a graphical artist.  At least he says so.
16:22:11 <MachinShin> oh i see. the link on osnews. but it links to his website, and is being pounded
16:22:28 <dons> he's no language guy. definitely down in the assembly.
16:23:15 <dons> " java doesnt have the processing ability to take any  java doesnt have the processing ability to take any more punishment than I already give it."
16:23:16 <gzl> it sounds pretty foolish to me to claim that the low-level style is the best way to do everything. he claims he's concentrating on graphics, but that's the opposite of what the low-level stuff lets you do
16:24:01 <dons> yeah. he comes from a C and OS background -- where this kind of mindset is pretty common, right?
16:24:04 <imaginator> "the right way" hmm.  the times that I've tested Enlightenment I've run into segfaults with different themes.
16:24:29 <dons> but Enlightenment was the most pretty wm back in the '90s at least.
16:24:29 <desrt> being a C programmer is no excuse for not knowing how to do OO
16:24:35 <dons> it used to be the default on RedHat.
16:24:36 <Oejet> imaginator: I was talking about his ideas.
16:25:39 <MachinShin> Oejet: don't suppose anyone mirror'd his site b4 it got hosed? :)
16:26:03 <imaginator> he's semi-famous also for adding pixmap themes to Gtk+
16:26:30 <dons> and transparency for eterm. that was astounding when I first saw it :}
16:26:37 <dons> so many memories.
16:27:00 <MachinShin> i loved e16. i can't wait for e17. it may become my excuse to reinstall linux
16:27:01 <dons> everyone switched to enlightenment just to have transparent terms.
16:27:14 <imaginator> MachinShin: why?  shouldn't it be about function more than looks?
16:27:32 <dons> imaginator: that's a Haskell mindset!
16:27:48 <imaginator> I've got this lamborghini, but I only drive it in school zones.
16:28:26 <MachinShin> imaginator: it's gotta be about both. and in general the functionality of linux doesn't overwhelm me enough to switch.
16:28:31 <MachinShin> and i'd really miss msvs :)
16:28:52 <Oejet> MachinShin: Clicky-clicky.
16:29:03 <MachinShin> que?
16:29:22 <Oejet> MSVS is Clicky-clicky-ware.
16:29:34 <Pseudonym> Anyone who says "I need to program low-level because I'm doing task X" probably doesn't understand task X.
16:29:53 <MachinShin> haha. pfft.
16:29:55 <Pseudonym> Now if it was "I need to program low-level because I'm on a platform that requires it", that's different.
16:30:07 <Pseudonym> 8-bit CPUs are still around.
16:30:28 <MachinShin> *gone*
16:30:28 <Oejet> Pseudonym: You are right, Rasterman is clearly clueless.
16:30:59 <Philippa> Pseudonym: if task X is something in a kernel you'd want to be very, very sure of how high-level constructs translate
16:31:13 <Pseudonym> Yes, I'd agree with that.
16:31:39 <Pseudonym> All "real" applications above a certain size must be layered, for managability..
16:31:43 <imaginator> computer graphics requires lower level.  I've written routines that decode JPEG and PNG images and generate XImages or XShmImages.  To get a 1280x1024 image to the screen quickly requires low-level code.
16:31:44 <Pseudonym> There will be a low-level layer.
16:31:54 <Pseudonym> And ther will be a high-level layer.
16:32:02 <Pseudonym> In an operating system kernel, userland is the high-level layer.
16:32:12 <Philippa> imaginator: not as low-level as you might think
16:32:36 <Pseudonym> imaginator: Especially not if you want to support other formats, not just JPEG and PNG.
16:32:51 <Pseudonym> There's got to be some abstraction there, otherwise even that simple task can't be managed.
16:33:04 <Oejet> Argh, and why did he have to put two animations on that page?
16:33:06 <Philippa> Pseudonym: not the point though
16:33:22 <Oejet> Pseudonym: Guess that's where Imlib2 comes in.
16:33:24 * Philippa was essentially saying that if crazy enough, something like APL might prove useful...
16:33:37 <Pseudonym> Well, yes.
16:33:47 <Pseudonym> It might even be easier to write the DCT code in APL.
16:33:57 <Philippa> right
16:36:44 <Pseudonym> I especially wonder about games programmers.
16:37:01 <Pseudonym> I reckon only the worst programmers would program under the sorts of conditions that you find at EA.
16:37:23 <imaginator> Pseudonym: what about the vector/matrix instructions that some CPU/GPUs provide?  you can't even do something of the quality of an OpenGL game without them
16:37:44 <Pseudonym> Nope, but you can wrap it up in a higher-level abstraction.
16:37:48 <Philippa> give or take a level of desperation to be coding games, and the whole "entry level = 2 years experience" problem
16:38:09 <Philippa> Right. You can stop caring PDQ
16:38:21 <Philippa> (inline asm as an IO action!)
16:39:34 <Pseudonym> Look, you can't write an OS kernel without using the CPU's I/O functionality either.
16:40:04 <Pseudonym> Actually, you can't write a database server without using the CPU's I/O operation.
16:40:06 <Pseudonym> Better example.
16:40:14 <Pseudonym> But you can abstract away the details.
16:40:27 <Pseudonym> Even if you need high performance I/O, abstraction still helps.
16:40:53 <imaginator> well, let's discuss; why does it help?
16:41:01 <Oejet> Abstraction can let your system optimize itself.
16:41:04 <Philippa> I do like the inline asm IO action idea, mind - if only because I'm amused by the idea of letting the inliner loose on it
16:41:09 <Pseudonym> The OpenGL driver might wrap up the floating point stuff nicely.
16:41:11 <Philippa> also, it helps you avoid fucking up
16:41:26 <Philippa> if you're writing out 101 variants on the same for loop, you'll screw up sooner or later
16:41:32 <Pseudonym> Right.
16:41:40 <Pseudonym> Abstraction helps for several reasons.
16:41:55 <Philippa> Pseudonym: the OGL driver alone ain't sufficient, odds are a game's going to be doing a lot of matrix work that isn't rendering
16:41:56 <Pseudonym> 1. It helps you write correct code, because you only have to concentrate on a small part at a time.
16:42:05 <imaginator> if you factor your code often and well shouldn't that make the need for abstraction and layers less important?
16:42:19 <Philippa> um, how do you think you're factoring again?
16:42:25 <imaginator> in a sense you *might* create a layer that way
16:42:41 <Pseudonym> 2. It helps you write robust code, because you can change things without affecting correctness.
16:42:56 <Philippa> you're almost certainly going to, even if all the factoring facility you've got is basic macros
16:43:08 <Philippa> the only question's whether you're going to enforce the abstraction
16:44:49 <Philippa> it might take a day or so to get on my feet, but FCVO "comfortable" I could code comfortably in any machine language given a good macro facility. Values of comfortably that leave me doing validity checks by hand, sure
16:45:05 <Philippa> so, what happens when you eg use haskell to metaprogram asm? :-)
16:45:19 <Pseudonym> Sorry, afk briefly.
16:45:32 <Pseudonym> Point 3 is the most important.
16:45:34 <Philippa> (actually, I wouldn't have inline asm per se as the IO action, I'd define the machine language as an ADT)
16:45:43 <imaginator> one issue I have with layers (especially with OOP) the number of failures is much greater, because you have to solve a general problem, rather than a specific problem.
16:45:43 <Philippa> so what is it? :-)
16:45:53 <Pseudonym> 3. Abstraction helps you write faster code, because you can swap out slow code and swap in faster code, and point 2 ensures everything should work as it did.
16:46:15 <Philippa> imaginator: you're picking the level of abstraction badly if you have a real problem with that
16:46:28 <Pseudonym> For "faster", substitute any efficiency metric you like.
16:46:29 <Philippa> you should be implementing the concepts you think in when working out what you want to do
16:46:48 <Igloo> Pseudonym: Is Myers asymptotically better than Hunt-Szymanski?
16:47:08 <Pseudonym> Igloo: Yes and no.
16:47:16 <Pseudonym> Hunt-Szymanski is O(n log n).
16:47:23 <Pseudonym> Myers is O(nd) where d is the size of the diff.
16:47:32 <Pseudonym> So if d is small, Myers is faster.
16:47:40 <humasect> ADT?
16:47:54 <Philippa> algebraic datatype
16:47:58 <Philippa> ordinary haskell type, IOW
16:47:59 <Pseudonym> But more to the point, Myers can be made to adapt on the fly if it turns out that d is bigger than you thought.
16:47:59 <Igloo> Right, so in the worst case Myers is O(n^2) vs H-S O(n log n)?
16:48:01 <humasect> k
16:48:11 <Philippa> well, it'd probably be a list thereof, but YKWIM
16:48:26 <Pseudonym> So you can cap the work at less than O(n^2).
16:48:35 <Pseudonym> But that's an extension.
16:48:48 <Pseudonym> The point is that the Myers algorithm can be made to do this, whereas it'd be hard to do that to H-S.
16:48:52 <Igloo> OK, so what's the complexity of the diff Myers-based alg?
16:49:03 <Pseudonym> It's O(nd), like I said.
16:49:22 <Igloo> Err, but you also said it's better than O(n^2)
16:49:40 <Pseudonym> Oh, you mean what can you cap it to?
16:49:58 <Pseudonym> Er... can't remember.  I think it's O(n^sqrt(2)) or so.
16:50:09 <Igloo> Ah, hang on, does capping mean make a non-lcs?
16:50:23 <Pseudonym> Yes.
16:50:27 <Pseudonym> It's not as "least".
16:50:36 <Igloo> Ah, right, I get it now
16:50:37 <Pseudonym> Not as least as it theoretically could be.
16:50:48 <Oejet> Igloo: What algorithm are you talking about?  What does it do?
16:50:57 <Igloo> Longest Common Subsequence
16:51:22 <Pseudonym> Hang on, BRB.
16:51:24 <Oejet> Igloo: Of two sequences?
16:51:28 <Igloo> Yes
16:51:58 <Oejet> Mmm, seems applicable in genetics.
16:52:11 <Igloo> It is
17:08:51 <Oejet> There is a nice long term view of .NET at http://www.ddj.com/documents/s=9211/ddj050201dnn/ .
17:12:43 <Pseudonym> Nack.
17:12:45 <Pseudonym> Back.
17:14:00 <Pseudonym> Actually, Eugene Myers, who came up with the algorithm, is indeed a computational biologist.
17:15:13 <Oejet> I've temporarily mirroed the first movie from rasterman at http://www.student.dtu.dk/~s022018/Temporary/e17_movie-03.avi
17:16:57 <Pseudonym> I also have little time for those who thing that graphics == games.
17:17:16 <Pseudonym> Or, more accurately, graphics <-> games.
17:17:26 <Pseudonym> Neither direction of implication is true.
17:18:13 <Oejet> Which truth values can "graphics" and "games" have?
17:18:38 <Pseudonym> Let me rephrase that.  The claim is:
17:18:51 <Pseudonym> forall x. uses_graphics(x) <-> is_a_game(x)
17:19:05 <Pseudonym> Or at least that's what it appears to be.
17:19:29 <Pseudonym> And treat with suspicion any person who uses the phrase "high performance programs, such as games".
17:19:36 * Oejet is amazed at the amount of effort duplication in the software industry.
17:19:49 <Pseudonym> Because games are the exception to just about every rule of HPC.
17:20:09 <Igloo> Hmm, well, I have a H-S that should be 2.5x faster than darcs', but still too slow I fear
17:20:43 <Pseudonym> Igloo: Can you read Mercury code?
17:21:04 <Darius> Pseudonym: Nowadays, it more seems like, forall x. uses_graphics(x).
17:21:11 <Igloo> I've never tried, but probably  :-)
17:21:26 * Igloo should comment this and cabalise it before moving on, though
17:22:47 <Pseudonym> If you grab the Mercury source, there's an example program called "diff", written by me.
17:23:09 <Pseudonym> It's GPL.  You can have it under another licence if you want, though.
17:23:52 * Darius should resubscribe to some Haskell mailinglists.
17:24:11 <Igloo> If your happy with BSDing it then that would probably better for a cabal LCS package
17:24:28 <Igloo> ARGGH! "you're"
17:24:38 <Pseudonym> Sure.
17:24:48 <Pseudonym> I wrote all of the Myers algorithm bit myself, so sure.
17:24:57 <SyntaxNinja> comment and cabal-ize! yay!
17:24:58 <Pseudonym> There's only one bit I can't technically claim copyright on.
17:25:01 <Darius> Pssh, stick both in then with the darc's one you can run all three simultaneously and verify correctness.
17:25:31 <Pseudonym> Or you can run them in different threads and see which one finishes first.
17:25:52 <Igloo> Tell you what, I'll comment and cabal-ize if someone else writes an LCS testsuite  :-)
17:26:03 <Igloo> Pseudonym: Which bit?
17:28:29 <Pseudonym> Igloo: lcss.m, I think.
17:28:38 <Pseudonym> No, lcss_type.m
17:28:51 <Pseudonym> Basically, a bunch of types used by the Myers algorithm.
17:28:56 <Pseudonym> Not a lot of IP in there.
17:29:08 <Igloo> Ah, ta
17:29:37 <Pseudonym> One of these days, I should write a full diff program in Haskell and compare it with the Mercury version.
17:30:02 <Pseudonym> But if it helps, I found that comparing its run time with GNU diff was basically impossible.
17:30:21 <Pseudonym> The time to start up with RTS dominated the actual diff, for real files.
17:31:28 <Oejet> Here's the second movie: http://www.student.dtu.dk/~s022018/Temporary/e17_movie-02.avi
17:31:47 <Igloo> Is it part of Mercury itself?
17:32:08 <Pseudonym> Yes, it's in the standard distro.
17:32:11 <Pseudonym> It's in the example programs.
17:32:21 <Pseudonym> Oejet: I'm having flashbacks of Kai Krause.
17:32:33 <Oejet> Who?
17:32:34 <Pseudonym> I spoke about this with a visual effects artist once.
17:32:47 <Igloo> Ah, I was looking for a "diff in mercury" download  :-)
17:33:05 <Pseudonym> Oejet: http://www.mprove.de/script/99/kai/2Software.html
17:33:37 <Pseudonym> This artist had flashes of watching Spock trying to use an alien computer.
17:33:55 <Pseudonym> "I'm sorry, captain, I can't make head or tails of this.  The interface appears to have been designed by Kai Krause."
17:35:03 <Oejet> Pseudonym: I follow you know. :-)
17:37:06 <Pseudonym> I'm getting motion sick just watching this.
17:41:35 <Igloo> Pseudonym: OK, I've untarred mercury-compiler-0.11.0.tar.gz and mercury-extras-0.11.0.tar.gz and I still don't have a file called lcss_type. I give up, where's it hiding?
17:41:49 <Pseudonym> Dunno.
17:41:52 <Oejet> Good night everybody.
17:41:53 <Pseudonym> Look in the diff directory.
17:42:31 <Igloo> Aha, I assumed I had the wrong tarball given that. Ta
17:46:14 <Pseudonym> Ah, it's difftype.m
17:46:59 <a5> hey, here is something i wrote to browse haskell and mysql documentation: http://ofb.net/~frederik/misc/ (scroll down to htmlman)
17:47:04 <a5> i don't know if others will find it useful
17:58:19 <a5> use my software!
19:11:45 <rjbs> back to working through YAHT.
19:12:19 <rjbs> If I want a data structure called Nums that's two integers, how can I type the datatype's parameters?
19:13:00 <rjbs> clearly this does not work: data Nums (a :: Int) (b :: Int) = Nums a b
19:13:11 <monochrom> data Nums = Nums Int Int
19:13:35 <monochrom> or, data Nums = Nums {a::Int, b::Int}
19:13:43 <rjbs> I don't need the params on the left hand side?
19:13:59 <rjbs> yaht only shows it that way (data Pair a b = Pair a b)
19:14:24 <monochrom> yaht and I are both right.
19:14:29 <rjbs> OK
19:15:04 <monochrom> "data Pair a b = Pair a b"  has a different purpose than yours.
19:15:14 <rjbs> How so?
19:16:21 <rjbs> The current exercise is to create a Quad type in which the quadruple is composed of (a a b b) types
19:16:29 <monochrom> "data Pair a b = Pair a b"  defines a data structure that's two datum of unknown types polymorphically.
19:16:57 <Sonarman> is there any way to define datatypes from the ghc interpreter?
19:17:14 <monochrom> If you know C++ it corresponds to template <class A, class B> struct Pair{ ...
19:17:19 <rjbs> I don't. ;)
19:17:26 <rjbs> but I follow
19:18:00 <monochrom> But when you say "Nums is two integers" you are asking for absolutely no polymorphism.
19:18:32 <rjbs> So what If I want two elements of matching classes, followed by an Int?
19:19:06 <monochrom> data Blah a = Blah a a Int
19:19:26 <rjbs> huh.
19:19:48 <monochrom> Please don't say huh to me.
19:20:03 <rjbs> That was odd.
19:21:04 <Darius> Sonarman: No.
19:21:23 <dons> well, you can always put them in a file and load it..
19:21:40 <rjbs> Well, monochrom, wherever you are, thanks. I get it now.
20:18:12 <beschmi> hi
20:19:09 <humasect> i
20:21:11 <Cale> hello
20:32:47 <desrt> world
20:32:50 <desrt> \n
20:34:01 <Lemmih> Hello
21:47:09 <MachinShin> night all
22:07:29 <sjanssen> I found a comment typo in GHC head's Data.Map, who should I notify?
22:22:43 <juhp> sjanssen: how about sending a patch to glasgow-haskell-bugs
22:22:57 <juhp> :)
22:23:27 <sjanssen> juhp: sounds like a lotta work to change "automaic" to "automatic" ;)
22:24:32 <juhp> dunno, shouldn't take more than a couple of minutes - if you think it is too much, how about just sending a mail without a patch :)
22:25:02 <juhp> sjanssen: which version of ghc?
22:25:18 <sjanssen> lastnight's snapshot
22:25:24 <juhp> ah ok
22:25:59 <sjanssen> hmm, the maintainer is listed as libraries@haskell.org, a mailing list I presume
22:26:07 <juhp> yep
22:26:22 <juhp> oh, then better send there :)
22:26:42 <dons> sjanssen: i'll commit the fix if you want. what file is it in?
22:27:11 <sjanssen> libraries/base/Data/Map.hs
22:27:30 <sjanssen> line 1235
22:29:04 <juhp> dons: was just looking at TeXpage - looks pretty clever
22:29:12 <dons> it's pretty groovy, yeah.
22:30:21 <juhp> TeX2page even
22:30:26 <dons> sjanssen: done.
22:30:31 <juhp> :)
22:30:47 <sjanssen> dons: sweet
22:30:52 <dons> juhp: and it does scheme syn hl, but you can add extra keywords, so you get haskell syn hl for free
22:37:53 <dons> tex2page seems to do a more elegant job than latex2html, plus is has better verbatim support
22:46:17 <juhp> definitely
22:57:15 <shapr> warg
22:59:35 <gzl> hmm, but the installation seems slightly strange
23:00:34 <gzl> ah, genius formatting here too
23:00:36 <gzl> List of dialects supported:
23:00:36 <gzl>   clispncmuclnsbclnbiglooncheznchickenngambitngauchenguilenkawanmitschemenmzschemenpetitenpltnpschemenscheme48nscmnscshnstknstklosnsxmnumbscheme
23:00:42 * gzl bangs head against wall
23:00:44 <dons> tex2page? yeah. it took me a while to work out which scheme to use.
23:01:19 <dons> I couldn't get guile to work, but scm did, though I had to run scmxlate manually
23:01:50 <dons> scmxlate is linked to from the tex2page site.
23:01:55 <gzl> i think i have scheme48 installed
23:01:56 * Lemmih ponders about using VOP to create a DSL for coding pov files in Haskell.
23:05:10 <dons> so I installed the scmxlate libs, then manually ran the scmxlate code in the scm interpreter: > (load "/home/dons/lib/scmxlate/scmxlate.scm")
23:06:30 <dons> at least I didn't have to bootstrap a Scheme-ish ghc first :}
23:30:02 <a5> what should i use for haskell cgi?
23:30:56 <Lemmih> a5: Network.CGI perhaps.
23:31:04 <shapr> a5: hey you
23:31:34 <shapr> a5: I'm envious of your climate. It was -29C this morning.
23:32:19 <shapr> a5: Flippi does nice & simple CGI, curryspondence uses WASH.
23:32:29 <a5> shapr: then move
23:32:34 <a5> oh just kidding
23:32:42 <a5> i thought WASH had problems
23:32:50 <shapr> But, but, my woman wants to live here. And I have no will of my own.
23:32:55 <a5> like with tokens growing infinitely long
23:32:59 <shapr> Ok, I'm not a total flatworm.
23:33:18 <shapr> nah, you can cut off the tokens with a particular command.
23:33:42 <shapr> Good Morning Mister Foster.
23:34:55 <a5> what? how does that work?
23:35:23 <shapr> The WASH log thingy lets you playback to get current state, but you can also snip it off.
23:35:57 <shapr> I forget the command, but I'm sure it's in Persistent or the other Persistent module.
23:36:00 <a5> i thought it was like, you have a cgi where one button increments a counter, and the other decrements, and you look at the page source after incrementing 100 times and decrementing 100 times and there's a really huge token
23:36:18 <shapr> Yes, but you can also just save the state and snip the playback.
23:36:37 <a5> how much do i have to change my code to do that?
23:36:49 <shapr> Not at all, just insert the "snip state here" call.
23:36:49 <a5> is it just a configuration change?
23:36:53 <a5> oh
23:37:04 <a5> but then the counter state would disappear
23:37:19 <shapr> No, you can save the state, only the playback would disappear.
23:37:31 <a5> really.
23:37:35 <shapr> a5: hey, can you unicycle?
23:37:51 <a5> haven't really tried. i can walk on stilts ;)
23:37:58 <a5> not the same though i guess
23:38:29 <shapr> Will you be it gothenburg in the beginning of July?
23:39:18 <shapr> CGI playback is important if you want the back button to be available.
23:39:36 <shapr> You know about continuation-oriented web programming?
23:39:42 <shapr> Or whatever it's really called..
23:39:43 <a5> no i'm not planning to be there
23:40:17 <shapr> PerlJam: y0, long time no see.
23:40:23 <a5> don't know about continuation-oriented web programming. well i know a little about WASH
23:40:46 <a5> is WASH built on something else with just CGI rendering?
23:41:34 <shapr> The idea is that you save each 'page view' as a continuation, so that you can go back as much as you like and continue navigating with everything working just fine.
23:41:44 <a5> oh, Network.CGI looks nice and comprehensive
23:42:28 <shapr> Flippi uses Network.CGI if you want an clearly written demo - http://www.flippac.org/projects/flippi/index.html
23:43:12 <a5> I mean Text.Html...
23:43:29 <a5> so it's basically between WASH and Flippi
23:43:48 <shapr> Nah, there's lots of other options.
23:44:38 <shapr> Halipeto is a Haskell clone of Zope Page Templates, it's quite spiffy, but you're not guaranteed XHTML compliance or anything.
23:44:59 <shapr> HaXml is an ADT approach to XML, it's neat.
23:45:21 <shapr> HXmlToolbox is a generic tree datatype approach to HTML/XML, with validation as a separate step.
23:45:30 <shapr> Si\ is the closest expert on HXmlToolbox
23:46:38 <shapr> What are writing?
23:46:56 <shapr> I can point out relevant pros and cons of some of the toolkits maybe?
23:47:39 <a5> i'm writing a flash card thing
23:47:44 <a5> it has a login page
23:47:47 <a5> so it uses cookies
23:47:54 <a5> maybe javascript at some point
23:48:07 <shapr> You might prefer WASH then.
23:48:35 <a5> hmm. no complicated state. ok.
23:48:53 <shapr> WASH already requires javascript for it's niftier features (BigWig-style caching), it does cross-page state handling, and etc.
23:49:06 <Lemmih> a5: There's also Hemplate which I used to hack Hackage.
23:49:28 <shapr> First demo for WASH is a multiplication flashcard thingy, that might give you some ideas.
23:50:14 <a5> something scares me about WASH though, i don't know. is it possible to use it without the state features? what about exceptions and stuff?
23:50:19 <shapr> I used WASH and the Grammatical Framework to hack up a Swedish vocabulary flashcard thingy. It wasn't so hard.
23:50:21 <a5> hemplate eh
23:51:05 <a5> right now i have a perl cgi running a haskell binary, it's not that bad, and that way all exceptions turn into nice error pages, easy to debug
23:51:15 <a5> i don't know what i'd do if it was monolithic
23:51:38 <shapr> you could force a WASH error and see what they look like :-)
23:51:46 <shapr> They show up in the apache error log
23:52:14 <a5> does hemplate have a home page? does curryspondence?
23:52:33 <Lemmih> a5: www.scannedinavian.org/repos/hemplate/
23:52:39 <shapr> curryspondence has a directory on my hard-drive
23:52:53 <shapr> but give me a moment and it'll be in http://www.scannedinavian.org/repos/curryspondence/
23:53:24 <shapr> a5: you too could join the ScannedInAvian collective and put your Haskell sources there.
23:53:54 <Lemmih> Woot. './Setup.lhs haddock' works (:
23:55:41 <a5> are you trying to assimilate me
23:55:50 <shapr> Your ass will be simulated.
23:56:12 <shapr> I know too many cheesy borg misquotes.
23:56:22 <shapr> Welcome to Borger King. Have a burger our way.
23:56:52 <shapr> http://www.pathcom.com/~boby/borgjoke.htm
