00:00:00 <autrijus> I've always thought that "Action" is an more accessible term.
00:00:11 <musasabi> No that is the documentation of the existing libraries, I mean the guidelines where to put various new modules.
00:05:48 <glimming> How do I write non-literate source lines in .lhs files? > for literate code, < for literate non-code typeset as code, but what is the prefix for non-literate code?
00:06:31 <autrijus> \begin{code} ?
00:06:45 <glimming> Nah? Isn't that the same as > ?
00:06:47 <glimming> Bird-sdtyle.
00:06:49 <glimming> style
00:07:28 <autrijus> oh. hm.
00:07:30 <autrijus> no idea.
00:07:49 <glimming> So I want code that will not be LaTeXed but will be compiled.
00:08:34 <glimming> \begin{code} is like > AFAIK?
00:08:38 <glimming> kosmikus?
00:09:16 <jadrian> glimming: what I've done is define an \ignore{} command
00:09:26 <jadrian> in latex
00:09:36 <jadrian> so I just do
00:09:39 <glimming> can you paste your ignore command?
00:09:40 <jadrian> \ignore{
00:09:44 <jadrian> \begin{code}
00:09:49 <glimming> right, the best thing would really be
00:10:04 <glimming> > < and %
00:10:05 <glimming> or similar
00:10:38 <glimming> so ignore is a dummy command like \newcommand{\ignore}[#1]{} ?
00:10:43 <jadrian> yeap
00:10:44 <glimming> K combinator
00:10:45 <jadrian> > isn't that great for LaTeX
00:11:07 <glimming> yes, but I really prefer to have a better way with a special-purpose prefix
00:11:07 <jadrian> for some reason that one is Bird style and \begin{code}  LaTeX style
00:11:11 <glimming> maybe !>
00:11:33 <glimming> did not understtand last sentence, jadrian
00:11:48 <jadrian> well >   <-- is called litterate bird style
00:12:02 <jadrian> and the one with \begin{code} \end{code} is latex style
00:12:20 <glimming> I thought it was the other way around.
00:12:24 <glimming> Thanks.
00:12:29 <jadrian> I have no idea how you use   >   with LaTeX...
00:12:42 <glimming> But the question remains - can we add some new prefix to lhs2tex - or maybe there is already one (kosmikus wake up!)
00:12:52 <glimming> lhs2tex
00:13:29 <jadrian> by the way
00:13:33 <jadrian> spealing of latex
00:13:52 <jadrian> do you know how to type pairs like  <a,b>
00:14:01 <jadrian> what are the < and  > symbols?
00:14:10 * jadrian can't find it anywhere...
00:14:45 <glimming> Yes.
00:15:05 <glimming> I use <\!\!  a,b \!\! > I think
00:15:13 <glimming> \langle and \rangle perhaps
00:15:19 <glimming> for < >
00:15:39 <glimming> but \! do decrease spacing because they are too wide for a pair (they are greater and less than)
00:16:50 <glimming> kosmikus, if you read this backlog, please email me if you know how to do the silent > in lhs2TeX  because I am travelling and ireggularly on IRC right now.
00:19:26 <musasabi> Why does pokeCString not exist - and how to implement it best?
00:21:40 <musasabi> seems I have to first map it to [Word8] and then use Foreign.Marshal.Array...
00:33:21 <autrijus> withCString and poke ?
01:09:37 * shapr throws a lambda boomerang
02:15:09 <shapr> wheeeee
02:15:58 <shapr> May I reiterate... lifehacker.com is a Big Media attempt to pretend to be cool. No real Hacker would touch that thing with a forty-foot pole.
02:16:42 <shapr> Your on-topic discussion will be back after these messages.
02:17:21 <Oejet> shapr: I have never heard of the site, and now I will visit it of shear curiousness.
02:17:33 <ibid> aol
02:18:24 <shapr> Lifehacke.com quotes Richard Stallman and Wikipedia when talking about hackers. It then goes on to describe its $25,000 USD corporate sponsorship by Sony, and advertise for windows anti-spyware software.
02:18:40 <shapr> ibid: yes, exactly.
02:18:54 <ibid> no, i meant "me too" :)
02:19:14 <shapr> oh, I thought you meant "obviously, this site is only cool to those who come from aol"
02:19:30 <ibid> specifically, never heard, visited because you piqued my curiosity
02:20:04 <shapr> I strongly suspect lifehacker.com tactfully spammed del.icio.us the day of their launch.
02:21:25 <shapr> aanyway, what's cool in the world of Haskell?
02:22:00 <shapr> Have you guys seen the Perl6 timeline graphic? http://www.haskell.org/hawiki/AutrijusTang
02:23:02 <shapr> That looks like the perfect candidate for one of those "generate your own project timeline" webapps.
02:23:54 <Oejet> shapr: Funny graph.
02:25:02 <shapr> truly
03:03:52 <araujo> Good Morning.
03:07:21 <vikasgp> hi araujo
03:34:07 <xerox> 'morning
03:34:46 <Paladin2e> 'morning.
03:41:39 <tuomov> shapr: How well does that AntiSpamGlobalSolution thing work in MoinMoin?
03:42:22 <tuomov> last night someone has again filled almost 30 pages in the ion wiki with spam links
03:42:42 <tuomov> something need to be done about it. compulsory login didn't help.
03:43:13 <tuomov> (phpwiki)
04:21:10 <soyt> I'm a haskell beginner. Can somebody tell me why the commented functions do not work? -> http://rafb.net/paste/results/5JhXp088.html
04:21:47 <soyt> or how I can achieve this
04:23:25 <Lemmih> soyt: Don't use 'Nothing' as a data constructor.
04:23:55 <Lemmih> It's already being used by Maybe.
04:24:00 <Lemmih> @info Maybe
04:24:01 <lambdabot> -- Maybe is a type constructor
04:24:01 <lambdabot> data Maybe a = Nothing | Just a
04:24:31 <humasect> @info Just
04:24:33 <lambdabot> -- Just is a data constructor
04:24:33 <lambdabot> Just :: forall a. a -> Maybe a
04:25:17 <Lemmih> soyt: And there's no data constructor called 'Tree' (Tree is a type constructor).
04:25:49 <Lemmih> soyt: 'treeHas (Node n left right) x = or [...]'
04:28:47 <Lemmih> soyt: Got it working?
04:28:57 <soyt> not really...
04:29:13 <soyt> I'm still confused with type and data maybe...
04:29:31 <Lemmih> Just rename 'Nothing' to eg. 'Empty'.
04:30:47 <soyt> http://rafb.net/paste/results/zGfbGA39.html
04:31:18 <soyt> hugs gives "Cannot justify constraints in explicitly typed binding"
04:31:55 <Lemmih> You're using (==) which isn't defined for all data types.
04:32:11 <Lemmih> @type (==)
04:32:14 <lambdabot> (==) :: forall a. (Eq a) => a -> a -> Bool
04:32:53 <soyt> the error is on the 'treeHas Empty x = False' line
04:32:55 <Lemmih> Notice the '(Eq a) =>', it tells Haskell that a _must_ be an instance of the typeclass Eq.
04:33:32 <Lemmih> soyt: Add '(Eq a) =>' to the type signatur.
04:33:32 <shapr> tuomov: extremely well
04:33:59 <Lemmih> *signature
04:34:06 <shapr> tuomov: it works so well all the other wiki systems are picking it up.
04:34:42 * shapr feels that rush of focus, mmm
04:34:59 <soyt> Lemmih, it works. thanks a lot.
04:35:07 <Lemmih> soyt: Maybe you should use GHC. It gives better error messages and tries to guess how you can fix it.
04:37:57 <shapr> tuomov: AntiSpamGlobalSolution means that your wiki can only be spammed by a second level domain once at most. When you add the Global part to that solution, wikispam is getting rare.
04:38:26 <shapr> There is a way that spammers can get around this system, but I know how to fix that too.
04:40:12 <Lemmih> @seen SyntaxNinja
04:40:14 <lambdabot> I saw SyntaxNinja leaving #haskell 7 hours 26 minutes 7 seconds ago.
04:43:42 <shapr> @seen You
04:43:43 <lambdabot> You has changed nick to fraxtal.
04:43:43 <lambdabot> I saw fraxtal leaving #haskell 7 hours 15 minutes 58 seconds ago.
04:44:04 <shapr> @seen Would
04:44:05 <lambdabot> Would has changed nick to fraxtal.
04:44:05 <lambdabot> I saw fraxtal leaving #haskell 7 hours 16 minutes 20 seconds ago.
04:44:32 <shapr> @seen Lemmih
04:44:34 <lambdabot> Lemmih is in #haskell.
04:44:43 <shapr> Lemmih: hiii!
04:44:51 <Lemmih> Hey (o:
04:45:12 <shapr> doing paying work?
04:45:24 <Lemmih> Nope. Working on Hackage.
04:45:45 <shapr> oh right, it's the weekend
04:45:51 <Lemmih> (I really shouldn't but it's way more fun)
04:46:49 <shapr> Well, as long you balance what you need to do and what you want to do in such a way that it maxmizes what you want to do in the long term view.
04:47:00 <Lemmih> Holidays doesn't really matter much when you don't have a 9-5 job (:
04:47:38 <shapr> I always feel better when I finish my work before I do fun stuff. (Not that I always do that)
04:48:07 * shapr goes back to work
04:58:13 <xerox> re.
04:58:41 * Lemmih doesn't use lots of money which directly reflects how much he has to work.
05:05:45 <shapr> hoi arjanb
05:06:07 <arjanb> hallo shapr
05:06:35 <Svrog> hi everyone
05:07:04 <Svrog> are there any documents or papers on writing fast haskell code?
05:08:18 <Lemmih> Svrog: Profiling is the best documentation there.
05:10:04 <Oejet> Lemmih: There could be some tricks documented somewhere stating something like: Avoid type classes, avoid higher order functions, avoid functional arrays...
05:10:51 <Lemmih> Rule 1: don't use String I/O.
05:10:52 <Lemmih> Rule 2: Profile your program.  Find the inner loop.  Look for overloading.  Squash.  Repeat.  Look for laziness.  Squash.  Repeat.
05:11:18 <xerox> Oejet, why avoid Type Classes?
05:11:45 <shapr> Svrog: there's a "Fast I/O for Haskell" article coming up in TMR1
05:11:52 <Lemmih> xerox: Overloading is expensive.
05:12:05 <wli> boxing/tagging/dictionaries/etc.
05:12:12 <Lemmih> xerox: But it wont normally effect you.
05:12:31 <shapr> Lemmih: rule 2 is the Simon Marlow quote for optimization.
05:12:33 <Lemmih> xerox: Just make sure it gets resolved at compile-time.
05:12:45 <Lemmih> shapr: So is rule 1 (:
05:13:06 <xerox> Lemmih, I see.  It's a good practice to use it (when needed) as necessary?
05:13:39 <shapr> hiya maihem
05:13:51 <Lemmih> xerox: Use what?
05:14:09 <xerox> Lemmih, type classes.
05:14:49 <maihem> yo
05:14:50 <Lemmih> Yes. Typeclasses are really neat.
05:14:55 * shapr y0dels
05:15:59 <shapr> I am regularly amazed that people still write desktop apps in C.
05:16:32 <shapr> I've been trying to use this liferea RSS aggregator, but it's chock full of bugs. I get the impression it has more bugs than features.
05:16:38 <Svrog> thanks Lemmih and shapr
05:17:02 <shapr> Truthfully though, profiling is the only way to get fast Haskell apps.
05:17:04 <xerox> It's not a feature, it's a bug!
05:17:07 <xerox> whoops ;)
05:17:29 <shapr> If you want excitement, use unsafePerformIO or Debug.trace to get an idea of the real execution order of your program. You will be surprised.
05:17:46 <johs> shapr: I like bloglines.com.
05:17:53 <wli> To be honest I've never had an issue with String IO; usually whatever I'm doing internally is several orders of magnitude larger than what gets printed externally, and worse yet takes far longer than the time required for a syscall to generate one byte of output.
05:18:00 <shapr> In some extreme cases, your application can run from the end to the beginning in order to be most efficient.
05:18:05 <johs> shapr: If you're looking for a good RSS-aggregator.
05:18:15 <shapr> johs: I'm hearing scary things about them.
05:18:22 <johs> shapr: Like what?
05:18:48 <shapr> Basically that they want to use the content of the blogs they crawl for commercial purposes.
05:19:05 <shapr> Several debian developers have put explicit licenses on their blogs just to prevent bloglines from doing so.
05:19:28 <shapr> I do have two bloglines subscribers for my blog as well, so I know it's popular.
05:19:50 <johs> What kinds of commercial purposes?
05:20:01 <shapr> But I really don't know if I want someone to use my blog for data mining or whatever.
05:20:31 <johs> But Google is allowed to do so?
05:20:50 <shapr> google indexes my blog, they don't really sell the data to other companies.
05:21:53 <shapr> I don't mind my content being in a search engine, and I don't mind people using my blog to learn stuff about programming. If commercial resale of my blog content happens, I'll be irritated.
05:22:20 <johs> Are they allowed to do that?
05:22:32 <shapr> Are they not allowed to do that?
05:22:34 <johs> Even if you don't explicitly state that they're not allowed to?
05:22:46 <johs> Resell blog content.
05:23:25 <shapr> I don't know, isn't the default undeclared copyright different for different countries?
05:23:28 <tuomov> I guess it depends on the jurisdiction and how the blog is served
05:23:40 <tuomov> under finnish law eulas are worth shit paper so here it is not permitted
05:23:44 <shapr> I'm a US Citizen living in Sweden. My blog lives in Sweden too. What rules apply?
05:24:24 <tuomov> but somewhere where eulas are considered agreements, and the blog is hosted on someone else's server, it might give them the right
05:25:13 <tuomov> if it is on your own server, clearly you have the copyright
05:25:14 <shapr> So maybe I'm being paranoid, I don't know. But I do know I want any content I create to be free like speech.
05:26:03 <shapr> Anyway, speaking of blogs, I have a bunch of entries I need to finish up and post.
05:26:44 <johs> Bloglines doesn't do a very good job with your blog, by the way.
05:26:53 <shapr> But one is giving me fits... the one that includes "<wli> libraries are a crutch for insufficiently expressive languages."
05:27:02 <johs> I don't know if it's your RSS that is bad, or Bloglines' RSS-parsing.
05:27:18 <johs> Um.
05:27:30 <shapr> Probably my RSS, since I'm the other user of this blog written in Haskell.
05:27:37 <shapr> That is, other than the author.
05:28:55 <shapr> Anyway, I submitted a feature request that asked for better RSS support, since I'm too lazy to fix it myself.
05:33:16 <johs> wli: You don't mean that libraries are bad, but that abundance of libraries is used as an argument for otherwise bad languages, right?
05:36:49 <johs> shapr: By the way, it's nice that someone bothers to propercase their writings on IRC.
05:37:07 <shapr> Actually, he was summarizing something I was trying to describe.
05:37:22 <johs> shapr: (I've counted you and Riastradh so far.)
05:37:59 <shapr> Well, I'm not perfect. My spelling and grammar get worse when I'm tired.
05:38:42 <shapr> Anyway, once the blog entry is up you'll have a much better idea of what I'm trying to describe.
05:39:02 <shapr> Assuming I do a decent job of beating these concepts into shape.
05:40:22 <Philippa> shapr: in berne convention countries, the default is you own it and no license has been given
05:40:59 <Philippa> however, it should be added that many countries have a concept of implicit license, and that you can't copyright an idea
05:41:23 <johs> shapr: Perfection is not required, but attempts at perfection are appreciated. :)
05:42:14 <shapr> Here's the blog entry so far - 1. The only difference between you and Shakespeare is the size of your idiom list. 2. Total Cost of Ownership of is more about the time to knowledge ration than anything else. 3. Open Source is resource competitive, the resources are the minds of developers, 4. Worse Is Better.
05:42:34 <shapr> um, "ratio" not "ration"
05:42:45 <johs> I thought Worse Is Better was worse.
05:42:46 <johs> :)
05:43:14 <Philippa> I don't agree with 1 - you're effectively assuming smart people and similar things to say
05:44:06 <shapr> johs: http://www.scannedinavian.com/2004-11-05.html
05:44:43 <shapr> Philippa: I don't know, I'll think about that.
05:50:09 <johs> I don't I agree that implementation simplicity is more important than interface simplicity.
05:50:34 <johs> What about the implementation simplicity of software built on top of complex interfaces?
05:50:39 <Philippa> it is in terms of getting things done
05:50:54 <Philippa> if the interface is complex but has a trivial implementation, you just sit there with a checklist
05:51:13 <johs> Well, naturally 50% is a lot faster to do than 100%, but it's not better.
05:51:23 <johs> Worse is Faster.
05:51:33 <shapr> I think it is, because ability to change is the most important facet of software.
05:51:36 <johs> Worse is Cheaper. Etc.
05:51:46 <jlouis> What optimizations does GHC do?
05:51:52 <jlouis> is there any list?
05:51:56 <shapr> But now, there's more. Ability to be understood is almost as important as ability to change.
05:52:03 <johs> shapr: I think robustness and functionality is more important.
05:52:44 <shapr> I'm assuming that the software fulfills its goals already.
05:52:57 <shapr> I should mention that in my posts I guess.
05:53:34 <shapr> Depends on what you mean by robustness...
05:54:09 <shapr> Windows is considered to have a far better interface than Linux, but which one will be ported to the Cell first?
05:55:16 <johs> It is?
05:55:20 <araujo> Probably windows, ..... they care more marketing than anything else.
05:55:21 <shapr> johs: Whether you agree or not, do you understand what I'm getting at?
05:55:33 <johs> shapr: Yes, I think so.
05:55:55 <johs> But do you mean that Windows provides a richer interface, or a better interface for the same functionality?
05:56:06 <shapr> What's the difference?
05:56:26 <dottedmag> johs: easier to learn, but conceptually non-effective :(
05:57:03 <johs> shapr: Say, Windows provides GUI-functionality, but Linux provides mostly just file I/O.
05:57:05 <shapr> I think I'm trying to say that if I can do the same thing as something else with less code, that is a huge advantage in several different ways.
05:57:29 <johs> Of course.
05:57:55 <shapr> With less code, I can find bugs faster, add features faster, teach new people to use the code sooner, adapt to new systems faster.
05:58:10 <johs> I don't disagree with that.
05:59:19 <shapr> And I think the advantage of simple, comprehensible code is far greater than 95% of commercial developers realize.
05:59:58 <shapr> And the clearest library is one you don't need, that's why the "libraries are a crutch for insufficiently expressive languages."
06:01:07 * shapr quickly copies parts of this discussion into his blog entry.
06:02:00 <shapr> johs: What do you think? Any feedback?
06:02:53 <soyt> I'm trying to define 'has' as an infix op, but I get 'ERROR "My.hs":23 - Syntax error in declaration (unexpected symbol "has")'. Any hint someone?  ->  http://rafb.net/paste/results/AHY8lt32.html
06:03:11 <jlouis> You are wrong. The first operating system to contain Cell support of the Free ones will be NetBSD
06:03:33 <shapr> jlouis: I didn't say it wouldn't be first ;-)
06:03:40 <jlouis> I am quite sure of that. The argument is they have a much better driver/bus infrastructure than Linux
06:03:51 <Lemmih> soyt: Use `has`.
06:03:53 <johs> soyt: Don't you need to use `s?
06:04:15 <jlouis> Linux is built around x86's, so other architectures need to simulate an x86. Whereas NetBSD has decoupled most of that
06:04:27 <soyt> ok, but why would it work with ++ (in the doc) ?
06:05:00 <shapr> In any case, I'm interested in any feedback about this set of ideas. These ideas have only coalesced in my head in the last few months, so I'm sure they're incomplete.
06:05:11 <jlouis> soyt: because ++ is special and already declared infix
06:05:53 <shapr> Incomplete also means "might be total fertilizer."
06:06:31 <soyt> jlouis, so the tutorial is 'hiding' something, in a way?
06:06:36 <johs> shapr: (Sorry, no feedback.)
06:06:43 <Lemmih> soyt: Nope.
06:06:46 <johs> I like Maude's infix syntax.
06:07:12 <johs> You would define "op _has_ : Something OrOther -> Boolean".
06:07:16 <Lemmih> soyt: (++) isn't starting with [_a-z]. That makes it special (infix).
06:07:21 <johs> And then you can use it like this "X has Y".
06:08:11 <tuomov> that's bad in that you need to know the semantics to parse
06:08:51 <soyt> Lemmih, got it.
06:12:13 <TheHunter> Lemmih, Oejet, (Type classes are expensive). Really? Shouldn't ghc -O take care of that (unless you're using existentials, of course).
06:12:38 * esap just implemented allocators from C++ to Haskell :-)
06:13:46 <Lemmih> TheHunter: Some functions are too big to get instantiated.
06:14:24 <jlouis> In principle one should ignore the fact that type classes are expensive for a very long time.
06:14:39 <jlouis> Or, maybe we should build a whole-program compiler for Haskell ;)
06:14:40 <TheHunter> Lemmih, even when you're using {-# SPECIALIZE #-} or whatever it's called?
06:15:11 <wli> Is there such a thing as polymorphism that can't be eliminated during whole-program analysis?
06:16:42 <Lemmih> TheHunter: That will force GHC to specialize it which eliminates the problem at the cost of increased code bloat.
06:17:01 <esap> wli: Yes there is, if you consider dynamic linking.
06:17:24 <wli> esap: Ignoring that, then what?
06:17:55 <jlouis> wli: no. You can monomorphize at all points. There is the problem of code-explosion though
06:18:05 <TheHunter> Lemmih, chances are, you'll have an even worse code bloat if you avoid type classes.
06:18:44 <Lemmih> TheHunter: Yes. I'm definitely not saying that you should avoid type classes.
06:18:57 <jlouis> and you can do polyvariance analysis too ;)
06:19:29 <Philippa> shapr: re libraries being a crutch, I'm tempted to point out a very good example of one that would be a complete mess were it part of haskell
06:19:44 <esap> Polymorphism can be eliminated, but at the cost of code size. It means you have to make duplicates of code for every polymorphic use.
06:19:46 <Philippa> granted it's one that would be a lot messier to use were Haskell less expressive
06:20:29 <Lemmih> TheHunter: But they _can_ cause some unexpected problems (which can be fixed easily).
06:20:52 <esap> You can actually duplicate code even _with_ polymorphism, just declare specific enough instances.
06:21:09 <Philippa> the point is to factor the duplication out again to just the one token
06:21:11 <esap> That might be useful for efficiency .-)
06:21:21 <Philippa> (and hope you have a good inliner)
06:21:59 <_griff_> has anybody succesfuly compiled HSX11 v1.0 on debian sid (xwindow 4.3.0.dfsg.1-10 ghc6 6.2.2-1 greencard-3.01)?
06:22:28 <_griff_> I get errors after make all (Graphics/X11/Xlib/Region.hs:96: Couldn't match `FinalizerPtr a' against `Ptr r1' Expected type: FinalizerPtr a Inferred type: Ptr r1)
06:22:36 <jlouis> Philippa: polyvariance analysis is a good inliner
06:24:43 <TheHunter> wow, ghc even seems to inline simple type class functions even without -O.
06:25:56 <shapr> _griff_: If you want HGL support the ghc-cvs deb has it already.
06:26:17 <Philippa> cable, dialup, what's the difference?
06:26:37 <shapr> Philippa: cable can drop you faster.
06:26:56 <_griff_> thanks shapr i will try it:)
06:29:33 <LittleDan> can existential polymorphism be made monomorphic in all instances, allowing code explosions?
06:30:18 <LittleDan> like data Blah = Num a => Blah a
06:32:04 <Philippa> only if you can do whole program compilation
06:32:15 <Philippa> if you can, each type class just becomes a massive ADT
06:32:59 <LittleDan> holding the data and the functions on the data?
06:34:02 <Philippa> right
06:34:19 <Philippa> or possibly the functions're all implemented with the equivalent case statement on their end
06:34:22 <Philippa> up to you
06:36:42 <Lemmih> @seen SyntaxNinja
06:36:43 <lambdabot> I saw SyntaxNinja leaving #haskell 9 hours 22 minutes 36 seconds ago.
06:46:46 <polli_> hmm
07:12:36 * goron has changed his opinion on Bash :-)
07:13:57 <TheHunter> goron, you mean you switched to zsh?
07:14:48 <wilx> ZSH is good.
07:14:50 <goron> TheHunter: No, usually I hated Bash (bacause large scripts were basically unreadable), but now I actually created something useful.
07:14:57 <wilx> I don't see what do people see on Bash :))
07:15:11 <goron> wilx: Well, I *had* to use it.
07:15:27 <goron> So I was forced to learn it.
07:15:47 <wilx> Sucks to be you :)
07:17:02 <tuomov> zsh sucks
07:17:03 <TheHunter> yeah, shell scripts are a horrible language. I have to look up the syntax for loops each time I want to use them.
07:17:04 <goron> wilx: It's for a course on Program Transformation. We only need to learn 5 tools an hour, and learn two languages an hour. Pretty tricky..
07:17:22 <wilx> :)
07:17:25 <TheHunter> tuomov, why?
07:17:42 <tuomov> I've never managed to configure it to do decen tab-completion like bash
07:17:54 <tuomov> it won't allow command lines with some characters without escaping them
07:17:55 <tuomov> etc.
07:18:31 <goron> Oh, no! Shell-WAR!
07:18:31 <TheHunter> well I prefer zsh's tab-completion...
07:18:34 <tuomov> showing completions below the command line and jumping back is just brain-damaged
07:18:50 <tuomov> ^d completing is also brain-damaged
07:19:16 <sh10151> i like scsh
07:19:47 <tuomov> and yeah, I'm _forced_ to use zsh on this machine my irc screen is one
07:19:55 <tuomov> because the admins refuse to install a decent shell like bash
07:20:21 <tuomov> well, apparently bash is installed on this particular machine, but on no machine it is in allowed login shells
07:20:35 <tuomov> fascists
07:22:37 <goron> tuomov: You could connect to your home machine via ssh (if the delay is small).
07:22:57 <tuomov> I'm on my home machine..
07:23:09 <tuomov> it's just that the only way for me to read any mail is to connect to one of these machines
07:23:25 <tuomov> and I happen run the irc screen here too
07:24:46 <tuomov> it sucks e.g. escaping mutt -f \=ion when in bash I could do without the backslash
07:25:51 <jlouis> tuomov: bash and zsh are not decent shells
07:26:11 <tuomov> what is then?
07:26:13 <jlouis> ksh
07:26:47 <jlouis> bash and zsh are far too big for my taste, anyway
07:27:02 <tuomov> bash maybe bloated, but at least it is usable unlike zsh
07:27:23 <jlouis> true
07:29:23 <goron> How the hell can I get a newline printed? echo \n doesn't help... It just prints \n instead of a blank line.
07:29:33 <TheHunter> echo -e
07:29:42 <goron> I tried echo -E
07:29:45 <goron> ...
07:30:15 <goron> It works...
07:30:49 <goron> cAse SenseTIvity suxors...
07:50:43 <syntax_syntax> Trebuchet MS is such a sexy font.
07:52:11 <wilx> :)
07:54:43 <xerox> I definitely agree.
07:55:54 <syntax_syntax> I like Computer Modern for printed stuff, though :-)
07:56:19 <syntax_syntax> it reeks of rugged masculinity.
07:56:29 * syntax_syntax puts on his scientist-cowboy hat.
07:56:42 <xerox> ah ah ah.
07:56:53 <xerox> Bitstream Vera Sans Mono here :P
07:57:34 <goron> I am even passing "functions" in Bash... \o/
07:57:55 <syntax_syntax> for LaTeX?
07:59:48 <samc_> what does one of them scientist-cowboy hats look like then?
08:02:05 <tuomov> The kind of hat the inventors of the Harrison-Stetson method use?
08:06:17 <goron> What does this mean in Bash? Command = functionCreatingAValue(); $Command|a; $Command|b? Is $Command evaluated twice or only once?
08:06:49 <goron> Think echo $Command instead of $Command.
08:07:06 <autrijus> gah. it's an utmost pain to convert "Env -> a -> (Env -> Env) -> b" into "a -> State Env b"
08:07:23 <autrijus> I should've done this from the beginning when there are not so many code around :-/
08:08:22 <mattam> goron: it should be call-by-value
08:08:36 <mattam> hence only once
08:22:51 <xerox> Do I need to write "deriving SomeClass" for manually defined datatypes for which I'm going to implement some instance of that "SomeClass"?
08:24:58 <tromp> no, you derive only if you dont want to write ur own impl
08:25:18 <xerox> I mean something like: data Tree a = ... ; instance (Eq a) => Eq (Tree a) where ... ; is it correct or I do need to do: data Tree a = ... deriving Eq; ?
08:25:32 <xerox> tromp, ah, okay, thank you.
08:27:10 <tromp> you have to decide if the default == is right for you
08:28:37 <xerox> tromp, how does the compiler know how to "arrange" == to the new type?
08:32:05 <tromp> it just recursively matches constructos
08:32:12 <tromp> constructors
08:50:44 <rtega> is there some way in haskell to take a list and somehow pass all elements in the list as an argument to function
08:51:16 <xerox> @info map
08:51:18 <lambdabot> -- map is a variable
08:51:18 <lambdabot> map :: forall a b. (a -> b) -> [a] -> [b]
08:51:19 <rtega> for example we have some function (\x y -> x + y) and [2,3]
08:51:26 <sh10151> map
08:51:34 <xerox> sh10151, I think we misunderstood
08:51:34 <wilx> foldl
08:51:41 <wilx> @info foldl
08:51:43 <rtega> nope
08:51:44 <lambdabot> -- foldl is a variable
08:51:44 <lambdabot> foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
08:51:45 <rtega> that's not it
08:51:49 <rtega> wait a second
08:51:54 <desrt> foldl1, actually
08:51:54 <ski> @info foldl1
08:51:56 <lambdabot> -- foldl1 is a variable
08:51:56 <lambdabot> foldl1 :: forall a. (a -> a -> a) -> [a] -> a
08:54:01 <rtega> nope
08:54:04 <rtega> that's not it
08:54:12 <rtega> foldl1 only works with a function with two arguments
08:54:25 <desrt> oh
08:54:28 <desrt> what you want does not exist
08:54:37 <desrt> and can not possibly exist
08:54:50 <rtega> I was afraid so
08:54:58 <desrt> it would have an infinite type :(
08:55:07 <rtega> that's what my compiler tells me ;)
08:55:51 <basti_> shapr: ping?
08:56:18 <xerox> Is there a way to get the implementation of Prelude's function from GHCi prompt?
08:56:43 <desrt> xerox; no.  it's compiled
08:56:47 <xerox> It would be *so* nice, sometimes. :(
08:56:55 <desrt> use the source, luke
08:57:09 <xerox> desrt, but the prompt is handy.
08:57:28 <desrt> so is grep :)
08:57:40 <xerox> desrt, but it means switching :-\
08:58:00 <xerox> It wouldn't be difficult to implement, I think.
08:58:26 <desrt> but you'd have to carry around a copy of the libraries source code with ghci
08:58:58 <xerox> Aren't them carried?
08:59:29 <desrt> no
08:59:36 <desrt> they get compiled into libHSbase
08:59:48 <xerox> hmpf. It would be nice.
08:59:56 <desrt> which ghci uses as a binary...
09:00:25 <xerox> Expecially if it would be usable to get the code of any function.
09:01:09 <desrt> a STG decompiler would be very interesting
09:01:52 <Lunar^> desrt: I think it was done
09:02:04 <desrt> lunar; i fear :)
09:02:15 <Lunar^> desrt: but I can't remember when/where
09:03:00 <Lunar^> http://www.scannedinavian.org/iohcc/succzeroth-2004/crawl.tar.gz is a good example of STG abuse
09:03:24 <desrt> succzeroth?  heh.
09:06:40 <samc_> re rtega's question, can't the list be converted to a tuple, and the function uncurried?
09:07:18 <samc_> nevermind
09:07:23 * samc_ beams
09:15:17 <basti_> I have a problem with the fromInt in bitops.lhs
09:15:34 <basti_> what is the correct way to fix that? which hugs version has the right definition?
09:16:16 <Cale> you edit the code to say "fromIntegral"
09:16:41 <basti_> i know, but the probably the next "upgrade" of hugs will get it again.
09:16:55 <Cale> hm?
09:16:59 <Cale> really?
09:17:02 <basti_> (debian = constant updating, no advance)
09:17:20 <Cale> I thought that fromInt was removed from the language
09:17:21 <basti_> i'd presume the first error free version of hugs will show up in debian mid 2027
09:17:25 <basti_> i thought so too.
09:17:45 <Cale> so...
09:18:21 <basti_> especially, it's for some tutorial kind of thing
09:18:39 <basti_> and i dont want to recommend people "if you get that error, just go there, use your favourite editor, fix this" etc. ;)
09:19:18 <Cale> well, code that uses fromInt is probably quite a few years old
09:19:40 <Cale> I don't even think fromInt is in Haskell 98
09:20:06 <basti_> hmm.
09:20:22 <basti_> i'll just upgrade hugs then and tell that debian package excuse not to touch it ever again.
09:22:34 <Cale> The right way to fix it is probably to submit a patch to that code
09:23:05 <basti_> why bother, if its correct in any hugs release newer than 2 years?
09:24:14 <basti_> uhm. is there any hugs release newer than 2 years?
09:26:14 <Cale> Hugs is suddenly going to start supporting an old version of Haskell from more than 7 years ago?
09:29:10 <basti_> hum
09:29:23 <basti_> sowwy.
09:29:26 * basti_ .o° ( ? )
09:30:27 <Lemmih> basti_: fromInt is not correct.
09:30:53 <basti_> i know. I thought for some reason the error is in some part of the hugs distribution
09:31:09 <basti_> if i only could find out why.
09:50:12 <SyntaxNinja> no cosmicray :(
09:50:39 <SyntaxNinja> does anyone have / know of a very small bsd-style library or tool in Haskell which has a basic ./configure && make && make install interface?
09:50:39 <Lemmih> Hey SyntaxNinja!
09:50:50 <SyntaxNinja> hi Lemmih I just replied.  Are you using the darcs repo or the cvs?
09:51:04 <basti_> argh i got it now
09:51:06 <Lemmih> GHC 6.4 rc1.
09:51:13 <basti_> thanks for pointing out cale & lemmih.
09:51:19 <basti_> and poke my brain, please.
09:52:05 <SyntaxNinja> Lemmih: OK well i'm comitting that change to darcs & cvs now
09:52:44 <SyntaxNinja> d'oh, forgot to cvs up. I hate cvs
09:52:50 <wli> BTW
09:53:23 <wli> Is there any chance of getting a "Normed" class in ghc so numerical algorithms can be made to work on reals, complexes, or vectors when appropriate?
09:58:27 <wli> well, s/ghc/hierarchical libraries/
09:59:22 <Cale> wli: that would be nice - in fact, more common mathematical abstractions being in the hierarchical libraries would be a good idea
10:00:12 <wli> Well, don't expect me to push Algebra.hs or anything
10:00:39 <wli> I'm just irritated b/c convergence conditions require ad hoc classes etc. everywhere.
10:01:21 <wli> I've been writing elliptic function stuff.
10:01:44 <autrijus> aww. pugs's evaluator is ending up becoming StateT ContT IO
10:01:47 * autrijus shudders
10:02:06 <wli> Also, some standard variable representing epsilon would help too.
10:02:31 <SyntaxNinja> wli: post to the libraries mailing list; I'm not sure that anyone here really has the ability to just add something
10:02:36 * autrijus wonders if (ReaderT ContT IO) + IORefs will work better
10:02:52 <SyntaxNinja> wli: of course, the Right Thing is to hack on cabal and hackage and then upload it there! :)
10:03:31 <SyntaxNinja> hi CosmicRay
10:04:06 <Lemmih> SyntaxNinja: I'm getting "*** Exception: Line 9: Unknown field 'synopsis'" when I do './Setup.lhs clean'
10:04:36 <wli> the type signature of abs is brilliant
10:05:26 <SyntaxNinja> Lemmih: compiling w/ the wrong cabal perhaps?
10:08:10 <wli> Where's cabal again (sorry I've yet to hack on it)?
10:08:12 <SyntaxNinja> CosmicRay: how's it going?
10:08:19 <SyntaxNinja> http://www.haskell.org/cabal
10:08:24 <SyntaxNinja> wli: it'll be released w/ the next ghc
10:08:28 <wli> should've guessed
10:08:52 <SyntaxNinja> CosmicRay: got any libraries or tools with a  basic ./configure && make && make install interface?
10:09:00 <SyntaxNinja> (haskell libraries that is)
10:09:53 <musasabi> autrijus: StateT x IO can be even faster sometimes if you are lucky (and use a datatype with strict fields)
10:10:13 <autrijus> mm, not worrying about speed for now
10:10:22 <musasabi> and it is cleaner in any case.
10:10:22 <autrijus> the requirement is that I'm implementing a language with callcc()
10:10:37 <autrijus> and with lexical environment that needs to be maintained
10:10:46 <autrijus> and one that occasionally does some IO.
10:10:57 <musasabi> autrijus: ConT examples would be nice in the wiki ;)
10:11:02 <Lemmih> SyntaxNinja: What about HSQL and HaskellDB?
10:11:05 <autrijus> I don't have a clean way to propagate exceptions, either
10:11:19 <autrijus> I guess "StateT Cont" is good enough for now
10:11:48 <autrijus> although I'm sure it is possible to simulate everything using Cont alone
10:11:48 <SyntaxNinja> Lemmih: I'll check.  are they very big?
10:11:56 <autrijus> but somehow I don't want to think about it too hard :)
10:12:35 <Lemmih> SyntaxNinja: HSQL is not so big. But it uses tools like hsc2hs, iirc.
10:13:23 <Lemmih> SyntaxNinja: I installed the new Cabal package (0.4) but now it complains about not finding Cabal-1.0 /-:
10:13:38 <SyntaxNinja> you gotta remove the old cabal :)
10:13:51 <SyntaxNinja> or change your -package line or something
10:13:54 <Lemmih> I did.
10:14:01 <SyntaxNinja> what complains?
10:14:02 <Lemmih> There is no -package line.
10:14:10 <SyntaxNinja> ie what is 'it'
10:14:24 <Lemmih> It's Setup.lhs from Cabal (:
10:15:12 <Lemmih> Oh wait. Might be my fault /-:
10:15:18 <syntax_syntax> wow.
10:15:23 <syntax_syntax> Louis Mountbatten was murdered.
10:15:27 <syntax_syntax> by the IRA, no less.
10:15:56 <Lemmih> Who's Louis Mountbatten and what's IRA?
10:15:57 * SyntaxNinja nods... of course it's your fault... it can't possibly be THE CABAL'S FAULT!
10:16:09 <syntax_syntax> the IRA is the Irish Republican Army.
10:16:37 <syntax_syntax> Louis Mountbatten was the viceroy of India in charge of coordinating India's and Pakistan's independence.
10:18:25 <SyntaxNinja> Lemmih: hsql looks like a nice choice!
10:20:30 <Lemmih> SyntaxNinja: What are you testing/doing?
10:21:27 <SyntaxNinja> Lemmih: cabal includes a Distribution.Make for people whose build systems are too complex to use cabal, so I'm testing that
10:21:46 <Lemmih> Neat.
10:22:14 * CosmicRay finally looks in
10:22:16 <SyntaxNinja> it's really simple, the idea is just to provide the Setup and foo.cabal interface for make-based systems
10:22:25 <SyntaxNinja> CosmicRay: too late. Lemmih helped me ;)
10:22:34 <CosmicRay> SyntaxNinja: there are several.  haskelldb has one
10:22:43 <CosmicRay> SyntaxNinja: I cabalized it
10:22:56 <CosmicRay> SyntaxNinja: it would be nice if cabal could use find or wildcards for exposed-modules
10:23:08 <CosmicRay> SyntaxNinja: I have a situation coming up where I will need to expose 843 modules
10:23:30 <SyntaxNinja> CosmicRay: then it would definitely save you time to implement a certain feature which I've been longing for but which I haven't had the time to do :)
10:23:55 <SyntaxNinja> and that is chasing dependencies via import statements
10:24:05 <CosmicRay> I thought you already do that?
10:24:13 <SyntaxNinja> shouldn't be hard. hmake does it.
10:24:14 <SyntaxNinja> nope
10:24:19 <CosmicRay> or is it that you do that because ghc --make does?
10:24:34 <SyntaxNinja> but even so, the right way to do it is to chase from exposed-modules; why woiuld you be exposing 800+ modules?
10:24:40 <SyntaxNinja> yeah, ghc --make does it
10:25:04 <CosmicRay> SyntaxNinja: haskelldb auto-generated interfaces to the 842 tables in our database plus the one over-all module it generates
10:25:19 <CosmicRay> however, nothing in the library imports all these 842 modules
10:25:29 <CosmicRay> so dependency tracing wouldn't necessarily help
10:26:56 <Lemmih> CosmicRay: What about the file which contains the DBInfo structure?
10:27:00 <SyntaxNinja> generating the exposed modules list is a little bit against the rules; it should be static so that tools like hackage can use it.
10:27:33 <CosmicRay> SyntaxNinja: couldn't hackage use whatever code cabal uses to expand the list?
10:28:03 <CosmicRay> Lemmih: I didn't think it imported them all, but maybe it does...
10:28:08 <CosmicRay> I don't have the file in front of me
10:28:56 <Lemmih> I'm fairly sure it does. Unless you have tables which aren't in the db.
10:29:00 <CosmicRay> SyntaxNinja: I was pretty sure that if I forgot to list in exposed-modules some dependency of an exposed module, the library would compile ok but attempts to use that module wouldn't work
10:29:06 <CosmicRay> Lemmih: nope
10:29:22 <SyntaxNinja> CosmicRay: yeah, possibly.  we don't really assume that all tool that want to read the description file have access to all of cabal
10:29:26 <Lemmih> CosmicRay: I was wrong?
10:29:31 <CosmicRay> but there are cases with other libraries that various exposed modules are not depended upon by anything else in the lib
10:29:36 <SyntaxNinja> that's why the parser is meant to be very simple to implement
10:29:46 <CosmicRay> Lemmih: by "nope" I meant "no, I don't have tables that aren't in the db"
10:29:47 <SyntaxNinja> CosmicRay: yeah, that could happen
10:30:29 <SyntaxNinja> in my experience, though, systems that use 'find' and friends to discover what to build end up being fragile
10:30:33 <CosmicRay> syntaxninja: well, if cabal itself won't support wildcard scanning and the like, then there is going to be no other practical option save generating cabal files using other tools
10:31:06 <SyntaxNinja> CosmicRay: that's OK, as long as once you create the source tarball the .cabal file never changes
10:31:07 <CosmicRay> in fact, I already do that for MissingPy, since I have to interrogate the host system to find things like library installation paths....  though it looks like some of the new features in your doc may make that unnecessary
10:31:48 <SyntaxNinja> CosmicRay: I definitely hope to find a good solution to this problem.  a tool that exposes 800+ modules is rather a corner case for us right now I'd say. sorry about that :(
10:31:51 <CosmicRay> SyntaxNinja: for me, less fragile.  I have a serious problem with forgetting to add new modules to exposed-modules.  the library will build fine, but break when it is used
10:31:53 * wli brews up a method of generating binomial coefficients for large indices that doesn't blow the stack.
10:32:11 <CosmicRay> SyntaxNinja: I was also wondering if passing that many names to ghc would exceed the command line length limit :-)
10:32:56 <SyntaxNinja> CosmicRay: well one plan is to add a "find" feature to the sanity checker that I'd like to implement. basically it'll complain if you have 'unreachable' .hs files.
10:33:14 <SyntaxNinja> that's basically the same code, and I plan to implement it; just haven't gotten around to it.
10:33:20 <SyntaxNinja> CosmicRay: no idea.
10:33:32 <CosmicRay> syntaxninja: I was hoping to brew up a nifty system that would interrogate a database with DBDirect and brew up a .deb with the resulting interface, ready to install
10:33:41 <CosmicRay> using cabal in the middle
10:34:17 <SyntaxNinja> that would be quite cool... but seriously, there's basically no chance of getting something to generate the exposed-modules before 1.0
10:34:22 <CosmicRay> ok
10:34:49 <SyntaxNinja> go ahead and generate the .cabal file for now; nothing wrong with that as long as the setup script doesn't do it! :)
10:35:00 <SyntaxNinja> (I know, I'm evil)
10:35:44 <CosmicRay> heh
10:36:35 <SyntaxNinja> CosmicRay: I'm sure we're going to get complaints about not generating exposed-modules, and hopefully this will annoy enough people that someone will come up with a great solution
10:37:22 <SyntaxNinja> CosmicRay: in case you haven't seen the traffic on the libraries@ mailing list, I'm basically just working on stability, and ghc is ready to pop; they're holding off for cabal
10:39:06 <Lemmih> SyntaxNinja: Eh did you export basicStanzaFields?
10:39:29 <SyntaxNinja> Lemmih: from PackageDescriptoin,  yeah; it's in CVS and darcs repos
10:40:00 <CosmicRay> SyntaxNinja: shapr filled me in
10:40:24 <CosmicRay> SyntaxNinja: that all makes sense, I'm just sending you my feature requests as they occur to me.  feel free to prioritize them low :-)
10:41:16 <Lemmih> SyntaxNinja: This is the repo, right? http://cvs.haskell.org/darcs/cabal
10:41:39 <SyntaxNinja> Lemmih:
10:41:40 <SyntaxNinja> yeah
10:41:52 <SyntaxNinja> er...
10:41:57 * SyntaxNinja sheepishly runs push
10:42:53 <Lemmih> (:
10:44:59 <wli> well, that didn't work
10:45:16 <wli> (2^21) `choose` (2^20-1) seems "hard"
10:47:14 <Cale> wli: I can do it -- if you're really interested, I could make you up a text file containing that number
10:48:58 <wli> Cale: The methods of finding such numbers efficiently are the question; I can cook up ad hoc hacks to get the actual number too. It was meant more to be indicative of the numerical ranges where naive algorithms break down.
10:49:32 <Oejet> I have a hard time finding any documentation describing a real arrow based parser combinator library.  Any suggestions?
10:49:58 <Cale> well, apparently mathematica uses a divide and conquer algorithm of some sort to balance the number of digits in subproducts
10:51:10 <wli> Cale: I took a stab at using Rational to keep digits down where possible (we expect common factors to come out from the factorial) but didn't get as much mileage out of it as I'd hoped.
10:51:44 <wli> Cale: Dredging up logarithmic methods is what I really need to do.
10:52:54 <wli> similar goes for Stirling numbers etc.
10:53:24 <shapr> Oejet: I've got a prototype that wouter hacked up, and there's somewhat working code in the papers, but I'm about to go to sleep. Ask me tomorrow.
10:54:17 <shapr> Oejet: also, I think a parsec-alike arrow-style parser lib (Parrowt ?) wouldn't be too hard even with no prior code.
10:54:20 <wli> Cale: I'm guessing there are methods using floating point to narrow things down to within some range and then divisibility considerations to find the integer within the range.
10:54:25 * shapr falls over
10:58:39 <SyntaxNinja> hi shapr
11:04:52 <wli> Cale: duplication formula of gamma function and ratios of gamma functions with rational arguments and equal denominators
11:05:20 <wli> or multiplication formula or whatever
11:21:46 <SyntaxNinja> Igloo: is the ghc release candidate packaged, OOI?
12:50:55 <wli> Well, most of the time it's pretty pointless; I suspect things are literally better off doing n `choose` k = (map (!!k) (iterate (\xs -> zipWith (+) xs (0:xs)) (1:repeat 0))) !! n for all reasonable values of n and k
12:51:52 <wli> or n `choose` k = ((iterate (\xs -> zipWith (+) xs (0:xs)) !! n) !! k
12:53:20 <wli> It may even be worthwhile to expose the list directly.
12:53:24 <liquidengineer> is there anywhere that demonstrates simple recursive long division with haskell?
12:53:33 <liquidengineer> on polynomials?
12:53:37 <wli> liquidengineer: of polynomials?
12:53:42 <liquidengineer> yeah
12:54:08 <wli> liquidengineer: hmm, well, I wrote a Grobner basis function, is that close enough?
12:54:55 <Lemmih> SyntaxNinja: Around?
12:55:31 <Lemmih> SyntaxNinja: I'm having problems compiling Cabal with the new patches.
12:55:39 <liquidengineer> I don't know what a grobner is...
12:55:51 <liquidengineer> and I'm more looking for an algorithm, actually
12:56:03 <liquidengineer> I need to write as much of this myself as I can
12:56:08 <liquidengineer> it's a hw assignment
12:56:53 <wli> liquidengineer: Iterate eliminating the head term, record the results. You should probably use unfoldr if you only want the remainders.
12:56:57 <wli> er
12:57:02 <wli> liquidengineer: Iterate eliminating the head term, record the results. You should probably use unfoldr if you only want the quotients, that is.
12:57:41 <liquidengineer> ah
12:57:49 <liquidengineer> what's unfoldr?
12:58:12 <wli> *Lentz> :type unfoldr
12:58:12 <wli> unfoldr :: forall a b. (b -> Maybe (a, b)) -> b -> [a]
12:58:17 <wli> the type signature says it all
13:00:26 <wli> liquidengineer: well, I can hammer it out in one line if need be.
13:04:59 * liquidengineer is very confused
13:05:05 <liquidengineer> I just started doing this a couple of weeks ago
13:05:20 <liquidengineer> I haven't learned those keywords/functions yet
13:08:39 <wli> the head terms are the monomials of highest degree
13:09:58 <liquidengineer> right
13:11:39 <SyntaxNinja> hi Lemmih
13:11:42 <SyntaxNinja> what's the prob?
13:13:49 <liquidengineer> me?
13:13:52 <Lemmih> Distribution.Compat.Directory doesn't export doesDirectoryExist.
13:14:45 <liquidengineer> wilx: okay
13:14:53 <liquidengineer> so, how do I tell if there are remainders or not?
13:15:28 <SyntaxNinja> Lemmih: where?
13:15:40 <Lemmih> SyntaxNinja: It imports System.Directory without enumerating doesDirectoryExist
13:16:30 <SyntaxNinja> what does?
13:16:42 <SyntaxNinja> ooooh
13:17:04 <SyntaxNinja> I don't really understand compat.directory, who wrote that. hmm
13:19:52 <SyntaxNinja> I'm checking to see if exporting everything breaks anythin
13:21:00 <SyntaxNinja> lemmh: OK I pushed that fix
13:21:04 <Lemmih> You might also add an #if in the export list to avoid warnings about duplicate exports.
13:21:37 <Lemmih> Only System.Directory should be exported if GHC > 6.2
13:22:01 <SyntaxNinja> are you using darcs? mind making that fix and "darcs send"ing it to me? I don't have 6.2 yeat
13:23:31 <Lemmih> Sure.
13:23:50 <liquidengineer> wilx: so , how do you know if the division has a remainder?
13:24:23 <liquidengineer> errr...wli, that is
13:24:29 <SyntaxNinja> Lemmih: also, don't suppose you could try "make check" and see if it works at all, would you?
13:25:40 <Lemmih> SyntaxNinja: 'make check' fails. Distribution/ModuleTest needs Distribution.Compat.FilePath which is hidden in Cabal-0.4
13:26:23 <SyntaxNinja> so ghc 6.2 does indeed implement the "hidden modules" 'eh?
13:26:24 <SyntaxNinja> hohum
13:27:41 <Lemmih> The changes are pretty small (about 4 lines). Do you still want me to send them?
13:28:55 <SyntaxNinja> ja I just want to make sure it's right since I can't test it
13:29:13 <lightstep> is th cooler than MetaOCaml?
13:32:14 <Lemmih> SyntaxNinja: Sent.
13:32:47 <Lemmih> SyntaxNinja: I'm using GHC 6.4, btw.
13:33:09 <SyntaxNinja> yeah, that's what I meant
13:33:11 <jaro> Hi there. I have a little problem with haskell. It's probably just my misunderstanding, but. Is there any possibility to use pure random numbers, not wrapped in the IO monad?
13:34:11 <lightstep> jaro: using do {x <- randomIO; ...} should work
13:34:21 <lightstep> jaro: it binds x to a pure number
13:34:58 <jaro> Oh, that would be great. I will try.
13:35:02 <Lemmih> jaro: Checkout 'mkStdGen'
13:35:33 <Lemmih> 'randomIO' is an IO action.
13:36:06 <wli> p `pdiv` q = let { deg = length . dropWhile (==0) . reverse ; dp = deg p - 1 ; dq = deg q - 1 ; c = (p!!dp)/(q!!dq) ; pq = replicate (dp - dq) 0 ++ map (c*) q ; r = take (max dp dq + 1) (zipWith (-) (p ++ repeat 0) (pq ++ repeat 0)) } in if deg r < deg q then (replicate (dp - dq) 0 ++ [c], r) else let (p', q') = r `pdiv` q in (take (max (length pq) (length p')) (zipWith (+) ((replicate (dp - dq) 0 ++ [c]) ++ repeat 0) (p' ++ repeat 0)), q')
13:36:27 <wli> not the most efficient way but it's a one-liner in some twisted, inappropriate sense
13:36:45 <lightstep> but what about a point free version?
13:37:19 <wli> Get real; that was already far above and beyond the call of duty.
13:37:43 <jaro> Going through the documentation of the Random module, being a little confused.
13:38:05 <lightstep> i wasn't here when the challenge was given (if at all). but it seems rather pointless. a compiler could make a "one liner" out of everything
13:38:35 <wli> hmm, f x = let { t1 = x*x; t2 = t1*t1; t3 = t2*t2; t4 = t3*t3; t7 = t2*t1 } in 1/(1/(1.0-0.8586836394657312E22/0.9218843620135047E30*t4*t1+14061623683.0/0.2678117105664E17*t3*t7/(1.0+1991042059053.0/8999439157120.0*t1))*(1.0-3077.0/21897216000.0*t3*t2)+t3/(1.0+173.0/1920.0*t1)/3780.0)*(1.0+t7/480.0)-t1/(1.0+t1/12.0)/2.0
13:39:12 <SyntaxNinja> jaro: what's the confusion?  one issue is that you need to use IO at some point for a source of randomness
13:39:14 <wli> lightstep: The results of program transformations are rarely human-readable.
13:40:45 <lightstep> wli: when i think about iot, you don't even need an advanced program transformer. a parser and ugly-printer could make every program into this kind of thing
13:41:14 <jaro> Well then. If I use the do statement in a function, generate some random numbers and produce some kind of a "randomized" structure. Afterthat, I would like to return the results. I suppose, that they will be automatically wrapped in the IO, am'I right?
13:41:37 <lightstep> it's like finding the 40 factorial by hand, exerting but automatable
13:42:00 <lightstep> jaro: it depends how you use the numbers. is you get into IO, you can't get out
13:42:04 <SyntaxNinja> jaro: btw, requests for library documentation can be added here: http://haskell.org/hawiki/LibraryDocsNeedingHelp
13:42:20 <jaro> I'm sorry for probably dum questions, but i'm not very used to monads yet.
13:42:39 <SyntaxNinja> @wiki ThatAnnoyingIOType
13:42:39 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIOType
13:42:44 <wli> lightstep: I've already written such. The difference is presentation. "one-liner" has more to do with cramming it comprehensibly into a small enough space not to spam IRC channels to death as opposed to the literal linebreak crap.
13:48:51 <SyntaxNinja> Lemmih: you were supposed to pull before sending :)
13:49:13 <Lemmih> Oh right (:
13:49:37 <jaro> lightstep: i suppose, that the randomly generated structure must be (as the product of the "outer world") wrapped in the IO, am I right?
13:50:00 <Lemmih> SyntaxNinja: But enumerating the imports might be desirable.
13:50:02 <SyntaxNinja> jaro: in one way or another, you have to get the "randomness" out of the IO monad, you can then use the number itself for pure computations
13:50:25 <SyntaxNinja> Lemmih: why? I want to be able to import Compat.Directory as if it were System.DIrectory
13:50:27 <Philippa> or perhaps more accurately, you can pass it into pure computations
13:50:56 <Lemmih> SyntaxNinja: Oh. Then why was it enumerated before?
13:51:15 <lightstep> jaro: using mkStdGen and next allow you to stay purely functional, without IO. but then you have to thread the state yourself
13:52:15 <jaro> lightstep: "thread the state"? I don't understand well. You mean to change the state of the random number generator?
13:52:56 <Philippa> to do things purely functionally, an RNG has to return two things: a number and a function to give the next number
13:53:08 <Philippa> "threading the state" refers to passing around all those 'next number' functions correctly
13:53:21 <SyntaxNinja> Lemmih: mistake I think, but I'm not sure
13:54:46 <wli> hmm, discrepancy of 4*eps where eps = head $ dropWhile (\x -> 1.0 + (x/2) /= 1.0) [1/2^k|k<-[0..]]
13:54:48 <jaro> Philippa: yes, thanks. So if I throw away the 'next' function after the computation, next call would be producing the same random numbers?
13:55:07 <wli> I think the builtin exp(x) is less accurate than my rational Chebyshev approximant.
13:55:12 <lightstep> jaro: exactly
13:57:10 <SyntaxNinja> jaro: don't look at the Random docs, look at the System.Random docs.
13:57:16 <jaro> Well then. And if I don't want to cope with this, I have to cope with the IO monad wrapping the random numbers.
13:57:20 <wli> duh, the machine arithmetic results in lower precision suck.
13:57:37 <Philippa> jaro: any given pure-function-with-no-parms will always return the same result
13:57:43 * wli aches for 128-bit floating point
13:57:58 <Gahhh> wli, in haskell ?
13:58:10 <wli> Gahhh: No, in hardware.
13:58:22 <ibid> doesn't sse have that?
13:58:24 <ibid> or sse2?
13:58:28 <ibid> whatever :)
13:58:30 <Gahhh> wli, why, how long is it taking to run your prog ?
13:58:35 <Gahhh> ibid: no
13:58:44 <ibid> i seem to recall there was
13:58:45 <wli> Gahhh: That doesn't matter, it's just the accuracy of the results.
13:59:17 <Gahhh> wli, if performance doesnt matter much, why do you need it in hardwre ?
13:59:20 <wli> Gahhh: Well, it does matter, but it's not a significant factor here.
13:59:46 <wli> Gahhh: If you're doing it in software anyway you might as well go arbitrary-precision.
14:00:14 <wli> Gahhh: (in fact I wouldn't mind an arbitrary-precision floating point lib, and may write one myself)
14:00:19 <Gahhh> wli, haskell already uses gnu mp. should not be hard to include
14:00:23 <ibid> arbitrary precision can be much worse performance-wise than fixed width
14:00:36 <wli> ibid: Doesn't matter for these purposes (verification).
14:01:13 <wli> ibid: What I really want to know is how far off the results are due to roundoff/approximation/etc.
14:01:14 <ibid> verification of what?
14:01:26 <wli> ibid: Numerical approximations to special functions.
14:01:41 <ibid> wli: isn't that where you take pen and paper?
14:01:48 <wli> ibid: No.
14:01:51 <Gahhh> wli, yes
14:02:10 <wli> ibid: The approximations are the output of other algorithms.
14:02:19 <Gahhh> wli, ah
14:02:30 <Gahhh> black box verification ?
14:02:37 <wli> Not quite.
14:03:17 <wli> It's understood what they are (Remez, variations on quotient-difference algorithms, etc.)
14:04:08 <Gahhh> is this algorithm on paper or implented already ?
14:04:42 <jaro> So. I'm writing program solving the rubic cube. I've written all logic already and now I'm trying to get some random cube configurations to have something to work with. I'm coming to conclusion that this should be performed in the imperative way (generating cubes and performing purely functional computations on them). Am I right?
14:05:33 <wli> Gahhh: I'm winging them something on the order of one every 5 minutes.
14:05:56 <wli> Gahhh: The experiment is to find which algorithms for generating approximations suck or are decent.
14:06:11 <Gahhh> wli, heh. Well, that is the field of numerical analysis, right ?
14:06:19 <wli> Something like that.
14:06:41 <lightstep> jaro: seems like a good idea
14:07:49 <xerox> http://nirvana.cuore.org:8000/hello
14:07:54 <wli> Gahhh: Analytically they are all obscenely effective. In practice cancellation effects that are difficult to model dominate.
14:08:01 <xerox> araneida works, okay, so the problem is with lisppaste :(
14:08:28 <jaro> lightstep: It was quite a shock for me to leave my cosy functional place I've been living in last couple of days.
14:08:32 <wli> Gahhh: Something like O(x^40) with 10 flops or some such.
14:08:47 <wli> Gahhh: (they're not unique in this respect)
14:09:44 <Lemmih> SyntaxNinja: I got HackageXmlRpc working.
14:09:46 <lightstep> xerox: this seems evil
14:10:14 <Gahhh> I am confused by O(x^40) with 10 flops. What does 10 flops mean here ?
14:10:30 <xerox> lightstep, let me try reload lisppaste.
14:10:35 <Gahhh> does it mean there are x^40 operations but only 10 of them are floating point ops ?
14:10:38 <wli> Gahhh: 10 floating point operations for an expression that eliminates 40 terms of the power series.
14:10:51 <wli> Gahhh: So the error is O(x^40).
14:11:45 <Gahhh> wli, doesnt numerical analysis tell the error caused by using floating point arithmetic after those 10 fops ?
14:11:49 <SyntaxNinja> Lemmih: awesome! got an example client program I can playu with?
14:12:11 <wli> Gahhh: It comes about because significant chunks of the power series (and actually better still, overall function behavior) are eliminated with the approximation method.
14:12:21 <Lemmih> SyntaxNinja: I would need shapr to install Hackage on his server.
14:12:40 <xerox> lightstep, WHOPS, I just realized I wrote in the wrong channel, sorry.
14:12:42 * SyntaxNinja pokes shapr
14:12:50 <wli> Gahhh: Numerical analysis says it depends on specific coefficients, so I can tell if it worked for a particular function by looking at the coefficients, but this is painful to do by hand.
14:13:18 <Gahhh> wli, I see
14:13:22 <wli> Gahhh: Basically, cancellation. "Are the additions all of terms of the same sign?"
14:13:53 <Gahhh> wli, and you are trying to do this in haskell ?
14:14:17 <wli> Gahhh: The nature of the approximations (continued fractions of weird forms) make accumulated roundoff largely a non-issue.
14:14:46 <wli> Gahhh: I use one-liners at the ghci prompt to find coefficients and search for worst-case behavior.
14:15:50 <Lemmih> SyntaxNinja: Hackage only provides 'getPackageByName' and 'getPackageByNameAndVersion'. Dependency handling should be done on the client side.
14:17:06 <Lemmih> Maybe I should hack a HackageClient package for that kind of stuff.
14:17:09 <SyntaxNinja> Lemmih: I think that some dependency handling should be done on the server side. it would be much more efficient there, especially since you have that cute little 'join' thing in databases :)
14:17:37 <wli> Gahhh: Anyway, those are mostly random snippets.
14:17:52 <Lemmih> SyntaxNinja: That could get complex.
14:18:52 <Lemmih> SyntaxNinja: Dependencies can be really tricky.
14:19:09 <SyntaxNinja> why?
14:19:27 <SyntaxNinja> if it's done on the client side, there's a lot of communications overhead w/ the server
14:19:44 <Lemmih> build-depends: ON_UNIX(utils), >=HaXml-2.3, <=SomeLib-0.1
14:20:03 <Lemmih> SyntaxNinja: What would be very little.
14:20:08 <Lemmih> s/What/That/
14:20:44 <Lemmih> SyntaxNinja: Maybe support for getting more than one description file at a time.
14:20:47 <SyntaxNinja>  I just uploaded darcs-1.0.2 to debian
14:21:04 <Lemmih> But the logic should not be on the server side.
14:21:14 <wli> Gahhh: Most of what I'm on about is trying to write a verifier for some hairy elliptic function crap for a set of orthonormal functions I derived from other considerations. I'll need the hairy approximations for numerical methods to compute them, and some symbolic stuff to get them written out in a way CAS's won't do for me (Rothstein-Trager/Lazard-Rieboo-Trager crud).
14:21:20 <SyntaxNinja> Lemmih: well, the algorithm is the same, whether it's performed on the client side or the server side, but the communications overhead makes it seem like a server-side thing would be better
14:21:32 <Lemmih> Anyhow, patches are welcome if you want that feature.
14:21:36 <liquidengineer> Question:
14:21:41 <liquidengineer> what doest this error mean?
14:21:56 <liquidengineer> ERROR prog.lhs:63 - Instance of Num (Int,Int) required for definition of rPolyMult
14:22:13 <SyntaxNinja> Lemmih: and also, the server should probably perform this algorithm to check to see if there are any packages with missing dependencies, and to disallow that to happen
14:22:41 <SyntaxNinja> liquidengineer: probably that you tried to use a pair of ints as if they were a single int in some calculation
14:22:57 <Lemmih> SyntaxNinja: Sounds great but I'm not gonna hack it (:
14:24:20 <SyntaxNinja> but you won't object if we add it at some point?
14:24:47 <SyntaxNinja> OR I could be mean and not do it and let you deal with the deluge of people who surely want this feature ;)
14:24:54 <int80_h> I am learning lisp. In my explorations I have found references to other functional languages such as Haskell. Could someone sing the praises of Haskell, why you like it so much?
14:25:33 <SyntaxNinja> too bad shapr isn't here, he likes to do that
14:25:46 <int80_h> heh
14:25:57 <liquidengineer> SyntaxNinja: thanks
14:26:01 <liquidengineer> that helps a bit
14:26:07 <int80_h> I could go find an faq somewhere but I'm coding atm.
14:26:15 <Lemmih> SyntaxNinja: They will get it. But the logic will be in the HaskellClient package.
14:26:15 <liquidengineer> though I can't figure out where I'm trying to misues the pair
14:26:18 <SyntaxNinja> @help
14:26:19 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
14:26:21 <SyntaxNinja> @listcommands
14:26:21 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
14:26:21 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
14:26:21 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
14:26:21 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
14:26:21 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
14:26:22 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
14:26:24 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
14:26:26 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
14:26:28 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
14:26:44 <int80_h> @wiki
14:26:44 <lambdabot> http://www.haskell.org/hawiki/
14:26:48 <int80_h> heh
14:27:04 <Gahhh> int80_h, the haskell pages disencourage haskell advocacy
14:27:04 <int80_h> @hitchcock
14:27:12 <int80_h> really?
14:27:16 <int80_h> I wonder why?
14:27:19 <liquidengineer> wait
14:27:33 <liquidengineer> could this happen if I tried to cons an int onto a list of ordered pairs?
14:27:39 <wli> int80_h: cantor = concat . f where f (x:xs) = [head x] : zipWith (:) (tail x) (f xs)
14:27:40 <int80_h> is it like netbsd, those who need it don't need to be told why?
14:27:54 <SyntaxNinja> I swear there was a "tour" feature in the wiki or bot
14:28:03 <Gahhh> int80_h, it's a highly subjective matter, so instead of getting into the flametest, the idea is to let everybody decide for themselves.
14:28:13 <SyntaxNinja> Gahhh: who says no advocacy?!
14:29:11 <int80_h> I'm not interested in starting flame war. I know haskell must have something to offer otherwise no one would use it. But I am very new and don't know details.
14:29:38 <liquidengineer> my god
14:29:42 <liquidengineer> I fixed the error
14:29:42 <Gahhh> int80_h, haskell is unique in some regards such as being a "pure" and "lazy" functional prgramming language.
14:29:48 <liquidengineer> I'm starting to understand haskell
14:29:49 <liquidengineer> freaky
14:29:57 <Lor> Evening, folks.
14:30:06 <int80_h> "pure" and "lazy" okay I have somewhere to go now
14:30:39 <Gahhh> int80_h, You can contrast that with other languages, for example o'caml
14:30:42 <SyntaxNinja> int80_h: haskell is pretty elegant, it has a nice type system which helps me to find errors at build time.  its "pureness" means that when I look at a given function, I can tell what it's going to do
14:30:46 <int80_h> I will make a guess and say pure means no side effects at all. Am I right?
14:30:50 <SyntaxNinja> since there are no side-effects and no external effects
14:30:59 <desrt> syscall; yes
14:31:01 <int80_h> ah my guess was right :)
14:31:15 <SyntaxNinja> int80_h: it's not the case that there are no side effects whatsoever, since then we couldn't do IO
14:31:26 <desrt> SyntaxNinja; IO isn't a sideeffect
14:31:30 <SyntaxNinja> but there is a nice abstraction, Monads, to help us understand side-effects when they happen
14:31:33 <int80_h> ooh yeah my book on lisp mentions that.
14:31:44 <int80_h> now I really *am* curious
14:31:52 <desrt> int80_h; lisp does IO by being impure and having side-effects
14:31:56 <Gahhh> int80_h, now these two features are quite uncommon, and it takes a while to understand them. Some people that do understand love those features.
14:32:13 <desrt> int80_h; haskell isn't the same way.  at least on a theoretical level, it's quite pure
14:32:37 <desrt> it's not how ghc impliments it.... but you could impliment it purely.. it would just be slow.
14:33:16 <int80_h> well thanks for your responses. I think I will stick around
14:33:25 <int80_h> oh is there a canonical book for learnign haskell?
14:33:33 <desrt> the best way i can think to explain it is that the function returns a list of IO actions to perform as part of its return value
14:33:33 <int80_h> I'll bet I should just look at the wiki for that
14:33:36 <Gahhh> visit haskell.org
14:33:47 <wli> fixWhile p f = snd . head . dropWhile (uncurry p) $ (dup $ zip . tail) . iterate f
14:33:52 <wli> etc.
14:33:53 <SyntaxNinja> @learning
14:33:54 <lambdabot> Sorry, I don't know the command "learning", try "lambdabot: @listcommands
14:33:58 <SyntaxNinja> @learn
14:33:58 <lambdabot> http://www.haskell.org/learning.html
14:34:16 <int80_h> well thank you, this channel is very helpful :)
14:34:23 <Gahhh> Heh this is why this channel is crowded. People stick around.
14:34:32 <wli> oh wait doesn't everyone love the quicksort?
14:34:47 <Gahhh> the quicksort in the haskell tutorial ?
14:34:47 <Lemmih> shapr: Wake up!
14:34:48 <SyntaxNinja> wli: show him!!
14:35:23 <wli> qsort [] = []; qsort (h:t) = qsort [x | x <- t, x <= h] ++ [h] ++ qsort [x | x <- t, x > h]
14:35:43 <int80_h> I got interested in haskell because I was googling for proof checking models
14:35:59 <int80_h> the one doc I found that was exactly what U was looking for implemented the model in haskell
14:36:06 <int80_h> s/U/I
14:36:17 <SyntaxNinja> int80_h: you may be interested to know that I work for a company that uses Haskell for high-assurance software
14:36:29 <int80_h> I am indeed interested :)
14:36:30 <Gahhh> int80_h, I believe there is a proof assistant written in o'caml, named Coq, at intria.fr.
14:36:43 <Gahhh> err inria
14:36:56 <int80_h> yes I am interested in writing one myself, as an exercise in fun.
14:37:15 <int80_h> so what I want is a model to implement. cheating off of other people's code would be less fun.
14:37:17 <SyntaxNinja> int80_h: most proof checkers are written in funtional languages
14:37:23 <SyntaxNinja> (from what I hear)
14:37:26 <int80_h> I am begining to see why
14:37:41 <Gahhh> The day an "int 80h" is interested in haskell is a good day for FP
14:37:53 <int80_h> ah the name is old
14:38:00 <int80_h> I keep it because I am lazy
14:38:06 <Gahhh> "lazy" is the key
14:38:34 <int80_h> I came to freenode when I was strictly interested in coding the iron
14:38:40 <int80_h> and improving my C skills
14:39:03 <int80_h> and then I found that studying functional programming improved my *programming* skills.
14:39:08 <SyntaxNinja> is there a standard makefile target for documentation? is it "make doc" or "make docs"?
14:39:40 <SyntaxNinja> int80_h: that is an experience many people have.  Haskell helps me to slow down and think a little more when I program, which in the long run, makes me go faster
14:40:06 <int80_h> I made my way over to #lisp, and through poking about for proof checkeing models found haskell once again. I had heard about it from an old roomate who went to UTexas/Austin
14:40:29 <int80_h> I asked him to explain to me what a function programming lanuage was, contrasted with other kinds. But he couldn't.
14:40:40 <int80_h> needless to say he dropped out fairly soon.
14:40:44 <Gahhh> I learned about FP from reading functional programming examples in Python.
14:41:08 <SyntaxNinja> int80_h: python stole some stuff from haskell :)
14:41:14 <int80_h> yes they did indeed
14:41:21 <liquidengineer> can I call a function on an argument of another function while it's still in that function's argument list?
14:41:27 <int80_h> I like seeing the "been there, done that " languages cropping up
14:41:49 <Gahhh> liquidengineer, give an exmplae plz
14:42:11 <liquidengineer> rGetQuotient (x:xs) (y:ys) gets the quotient of y/x
14:42:23 <liquidengineer> but I need to reverse the order of xs and ys before I can do any work
14:42:29 <liquidengineer> I have a function standardize to do that
14:42:29 <int80_h> so who mentioned haskell being used at work to verify software quality?
14:42:34 <liquidengineer> I want to do this
14:42:43 <wli> I can't even remember what I learned first. I remember it was Lisp and Scheme before the ML's, SML before Caml, Caml before Haskell. and Mercury last.
14:42:47 <SyntaxNinja> int80_h: that would be me
14:42:53 <liquidengineer> rGetQuotient standardize((x:xs)) standardize((y:ys))
14:42:54 <wli> (C and C++ before all of those)
14:43:04 <Gahhh> liquidengineer, no you cant do that, but...
14:43:06 <SyntaxNinja> wli: do you have a favorite language?
14:43:11 <liquidengineer> Gahhh: damn.
14:43:37 <int80_h> SN: when you applied for the job, was Haskell mentioned as a job requiremtn? Or is it one of those skills where, if you know the job, you know that skill in a functional language is needed?
14:43:59 <liquidengineer> Gahhh: I don't suppose there's an easy way to do it
14:44:06 <int80_h> because when I search about who is interested in these languages, haskell and lisp I get very few responses back from google
14:44:10 <liquidengineer> besides telling the user to call only on standarized lists
14:44:10 <SyntaxNinja> int80_h: the later; I had some contacts in the company
14:44:11 <Gahhh> liquidengineer, why not "rGQ (x:xs) (y:xs) = (somethingOrOder as bs) where as = standardize(x:xs)
14:44:13 <int80_h> so I am thinking it is implicit skill.
14:44:21 <wli> SyntaxNinja: I'm not sure I really think of them that way anymore. I know I have ones I very badly dislike.
14:44:36 <int80_h> my favorit language is Visual Basic
14:44:37 <SyntaxNinja> wli: good for you. that's the way to be :)
14:44:44 * int80_h ducks for cover.
14:44:46 <SyntaxNinja> int80_h: in that case, you'll love haskell
14:44:50 <int80_h> just kidding :)
14:44:51 <SyntaxNinja> (I just always say that, don't worry)
14:45:04 <Gahhh> int80_h, I had to write VB recently and I was a sad man.
14:45:18 <SyntaxNinja> I wanted to say that wli is a 1337 kernel hax0r but Haskell is his favorite language, but I guess I'll just have to settle for the 1337 part
14:45:21 <wli> VB is definitely not one I can stand.
14:45:24 <int80_h> No one has ever made me do that yet. I am lucky so far.
14:45:44 <wli> C has major deficits, but Haskell is not the answer to what C was meant to do.
14:45:55 <wli> etc.
14:45:58 <SyntaxNinja> int80_h: this paper might be interesting to you, it's about why FP matters: http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
14:46:01 <int80_h> yes, different problem domain
14:46:07 <int80_h> thanks
14:46:17 <int80_h> I cannot cut and paste so I will look at the logs later for that url
14:46:39 <Gahhh> liquidengineer, does that example make sense ?
14:47:22 <liquidengineer> I was about to ask if you could explain it, actually
14:47:47 * Lor is getting a bit tired of the ancient whyfp paper...
14:48:10 <Gahhh> Lor, shapr would employ you write a new one for his magazine !
14:48:32 <Lor> That would require that I had some Real Results with Haskell. Sadly, that's not the case.
14:48:34 <liquidengineer> it's no problem.  I can just demand that whoever calls the function makes sure its arguments are standardized first
14:48:51 <Gahhh> liquidengineer, you dont have to
14:49:08 <Lor> I might propose at work that we re-implement our software in Haskell, and then see how it turns out, but somehow I don't think that suggestion would go through... :)
14:49:16 <liquidengineer> Gahhh: hmm?
14:49:46 <Gahhh> liquidengineer, simpler example: f1 is your function, and you want the argument standardized. Then you can say: "f1 arg = let argst = standardize(arg) in <define rest of the function>"
14:50:04 <Gahhh> and use argst in its definition
14:50:08 <Lor> There are also ways in which you can avoid standardization _if_ it is already standardized.
14:50:22 <Lor> But that makes the code more complex, and it might be a premature optimization.
14:50:48 <liquidengineer> Lor: all I'm really doing is reversing two lists of tuples on the fly
14:52:27 <wli> I get real results with Haskell but they're boring and minor ones.
14:53:01 <wli> Basically, buttloads of perl-like crap and random calculating thingies.
14:53:29 <Gahhh> That's how I use, too, because at work they won't let me write anything else in haskell
14:54:11 <wli> Well, it just doesn't make sense to try conventional kernel stuff.
14:54:17 <Lor> Haskell is good for prototyping, too.
14:54:36 <wli> (House of course counts as non-conventional kernel stuff)
14:54:39 <liquidengineer> Gahhh: so how do I do it for two arguments?
14:55:02 <Lor> Once I had to implement a hairy algorithm in C, and I first implemented it very straightforwardly in Haskell in a way that made me sure of its correctness, then I reimplented it in C and compared the results of the two versions.
14:55:23 <wli> Almost a third of everything I do that really goes somewhere is in assembly anyway.
14:55:32 <Lor> Wow.
14:55:40 <int80_h> wli: what instruction set?
14:55:42 <Lor> You in the embedded business, I take it?
14:55:49 <wli> in680_h: A variety of them.
14:56:07 <int80_h> bah now I'm jealous
14:56:09 <wli> Lor: No. I just end up doing multiple-architecture sweeps.
14:56:16 <Gahhh> damn
14:56:17 <Lor> Hm?
14:56:21 <int80_h> may I ask the path you took to end up with such an interesting job , wli?
14:56:22 <wli> So I have to dork with assembly routines on 20 architectures.
14:56:37 <Lor> Why do they have to be written in assembly?
14:56:39 <wli> int80_h: similis sum folio de quo ludunt venti
14:56:58 <wli> Lor: They were in assembly before and I just modify them
14:57:21 <int80_h> thanks wli, that was sufficiently obtuse ;)
14:59:08 <wli> int80_h: "I'm like a leaf blown by the wind"
14:59:42 <wli> int80_h: i.e. accident and coincidence
14:59:47 <int80_h> I dunno, that sounds so specialized. Were you an engineering major?
15:00:40 <wli> int80_h: math and CS bachelor's only
15:01:19 <Gahhh> wli, for some reason I think the reason you dork with assembly is not for performance, correct ?
15:01:34 <wli> Generally not, no.
15:01:35 <int80_h> sometimes you gotta code the iron
15:02:00 <wli> It's mostly supporting changes for other things.
15:02:24 <jlouis> @index directory
15:02:25 <lambdabot> bzzt
15:02:31 <wli> e.g. with the ABI-compatible page clustering the entire content of the sweep was changing out one numerical macro for another.
15:02:40 <jlouis> directory manipulations, anyone? lambdabot hates me
15:03:00 <wli> The fork_idle() changes were bugfixes to some stuff Nick Piggin screwed up and rather badly.
15:03:12 <wli> etc.
15:03:40 <wli> I think I'm better known for getting quoted on LWN than my actual code these days.
15:03:52 <int80_h> LWN?
15:03:58 <wli> Linux Weekly News
15:04:08 <wli> No idea why, but I appear to be quotable.
15:04:18 * int80_h quotes you on that.
15:04:37 <duncan_> wli: just on the off chance... do you know anything about x86-64 ABI/assembly/C calling conventions?
15:05:01 <Lor> Who defines the ABIs these days, anyway?
15:05:05 <wli> duncan: yes, though the kernel makes very limited use of them.
15:05:13 * Lor has just been reading AMD64 specs.
15:05:21 <wli> duncan: So I'm only familiar with the kernel code model.
15:05:24 <duncan_> Lor: me too :-)
15:05:34 <Lor> For the first time ever, the x86 platform seems like it might actually be nice to program with.
15:06:01 <duncan_> wli: we're trying to implement something like trampolines for ghc so that callbacks can be supported on x86-64
15:06:07 <wli> Lor: pardon me while I try to climb back up off the floor and stop choking in laughter
15:06:41 <Lor> There are lots of problems still, of course, but the register shortage has been the direst one, imho.
15:06:53 <wli> duncan: Sounds like something rapidly departing from what I know how to cope with.
15:07:03 <duncan_> wli: in ghc there's a little bit of per-arch assembly to implement the FFI's support for "dynamic foreign export"
15:07:19 <Lor> Yes, it's still pretty friggin' ugly that the best way to do addition is the LEA instruction.
15:07:29 <wli> duncan: Mostly I know how to recognize when varargs got screwed up,  how to find args in hexadecimal stack dumps, etc.
15:07:46 <duncan_> :-)
15:09:15 <duncan_> it's this little bit of code that can be called like a regular C function pointer and it transfers control on to a piece of stub code but it has to pass two extra parameters (it's implementing closures that look just like regular C function pointers)
15:10:08 <duncan_> on x86 it's as simple as pushing the two args onto the stack, but on x86-64 with it's register passing C calls it's a bit harder
15:11:18 <Lor> How many caller-save registers does the ABI use?
15:11:48 <duncan_> the problem is none of us round here have the skills and Simon M does not have the hardware yet. It means nobody can run things like wxHaskell/gtk2hs etc on amd64 (since they make heavy use of callbacks)
15:11:51 <Lor> Whatever "the" ABI means...
15:12:09 <wli> duncan: wtf?
15:12:30 <wli> duncan: I'll drop Sunil and Jun a line
15:12:40 <duncan_> Lor: the answer to that sort of question is here: http://www.amd64.org/documentation/
15:13:08 <wli> (it would also be relatively trivial for me to just let them log into one of my boxen at home)
15:13:26 <duncan_> wli: that'd be very helpful!
15:13:52 <cm> f00
15:14:34 <duncan_> in the ghc sources the file is: ghc/rts/Adjustor.c, it has examples for half a dozen other arches and a reasonably detailed explanation of what needs to be done for each arch
15:14:43 <Lor> Wow, the editor is Jan Hubicka, the aalib guy?
15:14:50 <wli> I've got a quad em64t that probably can't run as fast as a UP Opteron
15:15:15 <duncan_> wli: because em64t are no good or what?
15:15:37 <wli> the usual jacked up clock with low cycle efficiency shenanigan
15:15:59 <wli> Actually, simonmar is already set up on a couple of my machines
15:16:29 <duncan_> oh, right. Of course he's pretty busy until ghc 6.4 is released.
15:20:31 <wli> Well, he should be able to log in the same as the other boxen of mine he can log into.
15:20:44 <wli> (the quad em64t that is)
15:20:51 <Lor> the traditional i386 abi has always been pretty dumb, IMHO.
15:21:06 <Lor> -freg-struct-return has often yielded better performance, as has -mregparm.
15:21:23 <duncan_> yes, I was reasonably impressed from reading the ABI document.
15:22:21 <duncan_> which is why you can now compile the kernel with -mregparm=3
15:23:51 <Lor> I kindasorta wish gcc had something like what I proposed ages ago: http://gcc.gnu.org/ml/gcc/1999-04n/msg00729.html
15:26:46 <cm> wow, Martin van Loewis posted there as well (:
15:27:04 <Lor> Who is he?
15:27:19 * Lor has only met one gcc/egcs guy in person.
15:27:43 <cm> i think he often posts on python-dev
15:27:52 <cm> is part of the core developers there, or such
15:28:33 <Lor> does amd64 support 128-bit floats?
15:28:45 <Lor> I couldn't find any mention of it in the specs, yet they are mentioned in the ABI.
15:29:11 <jlouis> ok, question: System.Directory.doesFileExist :: FilePath -> IO Bool. Say A want to test on that bool. if doesFileExist a then ... doesn't work. Neither does do if doesFileExist a then ..., but do a <- doesFileExist a; if a then ... does. Is there any more convenient way?
15:29:28 <Lor> A function like that is absolutely useless.
15:29:39 <Lor> Well, it may be okay for informative purposes, but nothing else.
15:29:43 <jlouis> it is clear to me why it doesn't work
15:30:34 <jlouis> I am just seeking a way to avoid pulling it with a <- operator, but operating directly on it inside the monad
15:30:46 <Lor> You could define a more convenient way: ifM test yes no = do a <- test; if a then yes else no
15:31:01 <duncan_> the ABI document mentions __float128 but I'm not sure there is any direct hardware support for it, ie it's rather slow
15:31:33 <Lor> It's a shame. Also, the only way to use 80-bit floats in the hardware seems to be the ancient x87 interface.
15:31:47 <cm> noone wants to use anything but 32-bit floats :P
15:31:56 <Lor> s/32/64.
15:31:56 <duncan_> that's because the 80 bit type is so non-standard
15:32:12 <Lor> 32-bit floats are quite unusable for anything.
15:32:14 <cm> s/64/32
15:32:15 <wli> I've got a box in my house with 128-bit floating point registers.
15:32:26 <duncan_> wli: what arch is that?
15:32:35 <wli> duncan: MIPS
15:32:36 <cm> Lor: good enough for 3d graphics :-)
15:32:43 <Lor> Bah.
15:32:44 <wli> PlayStation 2
15:32:51 <jlouis> Lor: yes, I'll do that then
15:32:51 <duncan_> oh :-)
15:33:05 <wli> duncan: It's by no means standard in MIPS.
15:33:23 <cm> wli: uhh, but that's 4x32, no?
15:33:34 <wli> cm: No idea. All I heard was "128-bit".
15:33:53 <cm> by that definition, every pentium or athlon with SSE(2)/3D Now! has that ;)
15:34:06 <Lor> jlouis, again: that function is useless for anything except informational messages. What are you using it for?
15:34:31 <wli> cm: It sounded like they meant something else. I'd call that 32-bit SIMD floating point.
15:34:51 <cm> yeah that's what it is
15:35:20 <wli> I have very little direct knowledge of the PlayStation 2's specific variation of MIPS.
15:35:20 <cm> "128-bit Floating-Point SIMD"
15:36:02 <wli> cm: Then I don't care about that at all. I want 128-bit floating point for stiff diffeq's etc.
15:36:22 <cm> I only (barely) know PS 2's specifics and nothing about other MIPS ;)
15:37:04 <wli> I did eigenstuff on Origin 2000's. I've only ever seen one non-SGI MIPS at a programming level, and that was a DEC MIPS.
15:37:49 <wli> Embedded MIPS is a complete mystery to me.
15:38:21 <Lor> I only got acquainted with SSE(2) yesterday, and the first thing I thought upon reading the spec was "wonder if anyone's written a neat functional calculus for these operations".
15:39:31 <wli> Lor: I suspect you'll have to resort to Ito calculus for Intel FPU's.
15:40:16 <Lor> lto?
15:40:29 <Lor> Oh, Ito.
15:40:42 <Lor> (Sans serif font, can't see the difference)
15:45:31 <cm> I think I have to watch "Hitch" tonight :d
15:46:57 <int80_h> this is why I like my gf, she never makes go see chick flicks
15:47:14 <int80_h> for which I am deeply grateful
15:47:45 <int80_h> yes this gf is implemented, it's not a theoretical model.
15:48:14 <cm> http://www.monochrom.at/turingtrainterminal/
15:57:18 <wilx> Chick flicks?
15:57:20 <wilx> Like what?
15:57:35 <cm> i think he means "Hitch"
15:58:37 <cm> .oO(and funnily enough it was not a gf which told me to watch it but I was considering it myself)
15:58:54 <wilx> Hmm.
15:58:58 <wilx> A comedy.
15:59:02 <wilx> Sounds nice.
15:59:24 <jlouis> Lor: I am not using it for anything (System.Directory.does*). They were just convenient for asking this question. What do you suggest using instead?
16:04:51 <Lor> A file existence check is always a race condition.
16:08:14 <jlouis> Lor: are you suggesting the security implications?
16:08:20 <xerox> 'night folks.
16:10:14 <Lor> I'm just pointing out that the information you get from the file existence check is immediately outdated by the time you act on it.
16:10:32 <jlouis> ;)
16:12:44 * Oejet also blinks cleverly like he learned something in "02220 Parallel Systems".
16:28:20 * cm enjoys some more Advanced Topics in Types and Programming Languages
16:29:26 <Lor> I've been intending to write to Pierce about him not having advertised the publication of ATTAPL anywhere.
16:30:16 <Lor> I only found out about it because I google it once in a while due to idle curiosity.
16:31:02 <Lor> I should order it if only to find out if the errors in type rules I pointed out have been corrected. :)
16:32:14 <cm> :)
16:32:38 <dons> hehe.
16:32:43 <liquidengineer> sould someone be willing to help me with an evil parenthesis error?
16:32:50 <cm> I started reading with the last chapter, about ML-style type systems.
16:34:08 <liquidengineer> I'm doing a complex recursive call
16:34:21 <liquidengineer> and I'm not sure what the error it's giving me means
16:34:41 <heatsink> liquidengineer: can you post the code?
16:34:53 <heatsink> paste, post, whatever
16:34:55 <dons> what's the error?
16:35:53 <liquidengineer> the error:
16:35:54 <liquidengineer> Prelude> :r
16:35:54 <liquidengineer> Reading file "Davis#2.lhs":
16:35:54 <liquidengineer> Type checking
16:35:54 <liquidengineer> ERROR Davis#2.lhs:108 - Type error in application
16:35:54 <liquidengineer> *** Expression     : divisor (rPolySub (dividend (rPolyMult (rDiv b a) divisor)))
16:35:56 <liquidengineer> *** Term           : divisor
16:35:58 <liquidengineer> *** Type           : [(Int,Int)]
16:36:00 <liquidengineer> *** Does not match : a -> b
16:36:25 <liquidengineer> polySub and PolyMult are functions that take two arguments and subtract and multiply polynomials with rationals
16:36:51 <liquidengineer> rDiv divides two rationals represented as tuples (ordered pairs)
16:37:12 <liquidengineer> rGetQuotient (a:divisor) (b:dividend) = ( (rDiv b a): rGetQuotient(divisor (rPolySub(dividend (rPolyMult (rDiv b a) divisor)) ) ) )
16:37:15 <heatsink> it's complaining about the type of the function 'divisor'
16:37:24 <liquidengineer> divisor is a list
16:37:31 <heatsink> oh, that's the problem then :)
16:37:33 <liquidengineer> a:divisor
16:37:39 <liquidengineer> where a is the first element
16:37:41 <heatsink> you are using divisor like a function here
16:37:43 <liquidengineer> hmmmm
16:37:45 <liquidengineer> no
16:37:47 <liquidengineer> I mean for it to be a list
16:37:59 <liquidengineer> where am I using it like a function?
16:38:07 <heatsink> divisor (blablabla)
16:38:19 <heatsink> means call function 'divisor' with argument 'blablabla'
16:38:24 <liquidengineer> hmmm
16:38:33 <heatsink> That's what the parser sees when it gets to that place in the code.
16:39:20 <liquidengineer> then how do I do a recursive call where divisor is the first list, and all the rest of that crap is the functions needed to get the second list
16:39:22 <liquidengineer> ?
16:39:58 <heatsink> What function are you calling recursively?
16:40:13 <liquidengineer> i.e.: rPolySub is called on dividend and the result of rPolyMult (rDiv b a) divisor
16:40:46 <liquidengineer> rGetQuotient
16:42:06 <heatsink> (....) : rGetQuotient (divisor (rPolySub ....))
16:42:17 <heatsink> means call rPolySub with arguments
16:42:22 <heatsink> then call divisor on its return value
16:42:32 <heatsink> then call rGetQuotient on divisor's return value
16:42:47 <liquidengineer> divisor's a list
16:42:51 <heatsink> yes
16:43:02 <heatsink> hence the type error.
16:43:03 <liquidengineer> rGetQuotient takes two lists
16:43:47 <liquidengineer> I
16:43:58 <liquidengineer> but i unfortunately have to compute the second one on the fly
16:44:07 <heatsink> that's not a problem.
16:44:15 <liquidengineer> so this:
16:44:15 <liquidengineer>  (....) : rGetQuotient (divisor (rPolySub ....))
16:44:19 <liquidengineer> will do what I need?
16:44:38 <heatsink> no, I was indicating what your current code does.
16:44:44 <liquidengineer> oh
16:44:48 <liquidengineer> well, I don't want it to do that
16:44:53 <liquidengineer> :)
16:44:55 <heatsink> I know :)
16:45:00 <liquidengineer> so, how do I fix it?
16:45:06 <liquidengineer> sorry...I'm a bit of a haskell noob
16:45:50 <heatsink> Suppose I have a function "add" that takes two numbers.  How would you call it with arguments (3*x) and (x*x)?
16:46:34 <liquidengineer> add (3*x x*x)
16:46:53 <liquidengineer> w/o the parenthesis, i guess
16:46:54 <heatsink> no
16:46:57 <liquidengineer> no?
16:47:23 <heatsink> add (3*x) (x*x)
16:47:55 <liquidengineer> oh
16:47:59 <liquidengineer> so
16:48:05 <liquidengineer> I need to change it to this:
16:48:25 <liquidengineer> rGetQuotient((divisor) (rPolySub(dividend (rPolyMult (rDiv b a) divisor)) ) )
16:48:40 <heatsink> add ((3*x) (x*x))?
16:49:16 <liquidengineer> what?
16:49:37 <liquidengineer> I'm confused
16:50:24 <heatsink> you showed me rGetQuotient ((divisor) (rPolySubResult))
16:50:53 <heatsink> which is not the syntax in my example.
16:51:02 <liquidengineer> oh
16:51:46 <liquidengineer> okay
16:52:40 <liquidengineer> rGetQuotient (divisor) (rPolySub(dividend (rPolyMult (rDiv b a) divisor)) )
16:52:47 <liquidengineer> is that closer?
16:52:59 <heatsink> that is correct.
16:53:02 <liquidengineer> it is?
16:53:08 <liquidengineer> I hate this function
16:53:09 <heatsink> Also, you don't need the parentheses around divisor.
16:53:24 <liquidengineer> but in your add example, they're there
16:53:31 <liquidengineer> is it because nothing's being done to divisor?
16:53:36 <heatsink> correct
16:53:57 <heatsink> the parentheses are there because of operator precedence rules.
16:54:35 <heatsink> Function call has higher precedence than multiply
16:54:50 <heatsink> add 3 * x x * x  is the same as
16:54:54 <heatsink> (add 3) * (x x) * x
16:55:47 <heatsink> which won't pass the typechecker.
16:56:29 <liquidengineer> it's still pissed about something
16:56:29 <liquidengineer> Reading file "Davis#2.lhs":
16:56:29 <liquidengineer> Parsing
16:56:29 <liquidengineer> ERROR Davis#2.lhs:112 - Syntax error in expression (unexpected `;', possibly due to bad layout)
16:56:29 <liquidengineer> Prelude>
16:56:52 <liquidengineer> oh
16:56:52 <heatsink> Are you typing this in every time you want to run it?
16:56:57 <liquidengineer> no
16:56:58 <liquidengineer> lhs
16:56:58 * Lor just sent a mail to bcpierce urging him to plug attapl.
16:57:21 <heatsink> ok
16:58:43 <liquidengineer> I have this now
16:58:44 <liquidengineer> >rGetQuotient (a:divisor) (b:dividend) = ( (rDiv b a): rGetQuotient divisor (rPolySub(dividend (rPolyMult (rDiv b a) divisor)) )
16:59:19 <heatsink> okay. You should have different errors this time.
16:59:24 <heatsink> :p
16:59:37 <liquidengineer> no
16:59:40 <liquidengineer> same error
16:59:46 <liquidengineer> missing ; possibly due to bad layout
17:00:08 <liquidengineer> I'm sorry
17:00:12 <liquidengineer> unexpected ;
17:00:23 <heatsink> I don't see a semicolon.
17:01:13 <heatsink> Also, I don't know literate haskell syntax.
17:01:53 <heatsink> Is this code in a 'do' block?
17:02:03 <liquidengineer> nope
17:02:10 <liquidengineer> I'd post th whole thing, but I don't wanna flood
17:02:13 <liquidengineer> it's only six lines or so
17:02:19 <heatsink> use the pastebin
17:02:25 <liquidengineer> pastebin?
17:02:30 <liquidengineer> how do I get htere again?
17:02:43 <heatsink> www.rafb.net/paste/
17:04:22 <liquidengineer> what language should I say it is?
17:04:42 <heatsink> just pick one.  It might color it funny.
17:05:53 <liquidengineer> done
17:06:09 <liquidengineer> that's the offending line
17:06:16 <liquidengineer> commenting it out makes the program compile fine
17:07:01 <heatsink> I forgot to mention, the telepathic interface is down. You'll have to give me the URL manually.
17:07:07 <Cale> it's often good to use the HaskellIRCPastePage on the wiki for working on Haskell code here
17:07:32 * heatsink checks hawiki on haskell.org
17:07:40 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
17:07:50 <liquidengineer> http://www.rafb.net/paste/results/z7ZNAG63.html
17:09:21 * heatsink needs context
17:09:34 <liquidengineer> hmm?
17:09:42 <liquidengineer> you want the whole function?
17:09:44 <liquidengineer> sorry
17:10:02 <Lor> If your whole function is more than a couple of lines, it's too long. :)
17:10:55 <liquidengineer> three lines
17:10:57 <heatsink> If the error is "unexpected ;" then my first guess is there is a semicolon somewhere that is causing error.  I see no semicolon in the pastebin.
17:10:59 <liquidengineer> can I just paste in here?
17:11:09 * heatsink thinks 3 lines is okay
17:11:18 <liquidengineer> >rGetQuotient :: [Rat] -> [Rat] -> [Rat]
17:11:18 <liquidengineer> >rGetQuotient px []   = []
17:11:18 <liquidengineer> >rGetQuotient [] px   = []
17:11:18 <liquidengineer> >rGetQuotient (a:divisor) (b:dividend) = ( (rDiv b a): rGetQuotient divisor (rPolySub(dividend (rPolyMult (rDiv b a) divisor)) )
17:12:48 <heatsink> That's four lines, but anyway: what do you think about the semicolon?
17:13:25 <liquidengineer> I have no idea
17:13:32 <liquidengineer> I'd think whitespace error
17:13:36 <liquidengineer> but I'm doing literate
17:13:41 <liquidengineer> so I don't see how that could be the problem
17:14:23 <liquidengineer> it would tell me if a comment was touching code...
17:15:08 <heatsink> I don't know where the problem is.  Try commenting out parts of the code to see when the error goes away.
17:15:51 <liquidengineer> it goes away when I comment out the last line
17:16:54 <heatsink> Okay, repeat on a smaller scale.
17:17:08 <liquidengineer> how?
17:17:15 <liquidengineer> that whole line fits together
17:17:22 <liquidengineer> it wouldn't make sense to take it apart
17:17:23 <heatsink> save a copy of the last line
17:17:41 <heatsink> then replace it with something shorter like rGetQuotient (a:divisor) (b:dividend) = []
17:18:19 <Cale> you need another close paren
17:18:38 <liquidengineer> okay
17:18:46 <liquidengineer> it didn't mind the empty list at all
17:18:48 <liquidengineer> another paren?
17:18:54 <liquidengineer> where?
17:19:14 <Cale> at the end, or delete the one at the beginning
17:19:23 <liquidengineer> I don't need that for consing?
17:19:28 <liquidengineer> the outer set?
17:19:40 <Cale> yeah
17:19:48 <Cale> you can write 1 : 2 : 3 : []
17:19:52 <Cale> without parens
17:20:15 <heatsink> liquidengineer: is there a semicolon on the next line?
17:20:20 <liquidengineer> cool
17:20:29 <liquidengineer> the less paren sets, the better, IMHO
17:20:31 <liquidengineer> no
17:20:32 <cm> semicolon <=> layouts
17:20:34 <liquidengineer> no ; anywhere
17:20:36 <liquidengineer> I don't use them
17:21:00 <liquidengineer> yeah
17:21:02 <heatsink> geh, misleading error messages.
17:21:08 <liquidengineer> it says possibly due to bad layout
17:21:24 <heatsink> thx Cale.
17:21:36 <liquidengineer> no kidding
17:21:37 <cm> there's a ) missing
17:21:41 <liquidengineer> I removed the other {}
17:21:44 <liquidengineer> same message
17:21:47 <liquidengineer> and those were parenthesis
17:22:08 <cm> rGetQuotient (a:divisor) (b:dividend) = ( (rDiv b a): rGetQuotient divisor (rPolySub(dividend (rPolyMult (rDiv b a) divisor)) )
17:22:10 <liquidengineer> not curly braces
17:22:12 <cm> there's a ) missing at the end
17:22:17 <liquidengineer> there is?
17:22:22 <Cale> cm: we noticed
17:22:30 <cm> sorry
17:22:32 <liquidengineer> oh yeah
17:24:01 <liquidengineer> >rGetQuotient (a:divisor) (b:dividend) = (rDiv b a): rGetQuotient divisor (rPolySub(dividend (rPolyMult (rDiv b a) divisor)))
17:24:03 <liquidengineer> like that?
17:26:06 * heatsink counts matched parentheses
17:27:13 <liquidengineer> I'm now getting this
17:27:14 <liquidengineer> ERROR Davis#2.lhs:108 - Type error in application
17:27:14 <liquidengineer> *** Expression     : dividend (rPolyMult (rDiv b a) divisor)
17:27:14 <liquidengineer> *** Term           : dividend
17:27:14 <liquidengineer> *** Type           : [(Int,Int)]
17:27:14 <liquidengineer> *** Does not match : a -> b
17:27:24 <liquidengineer> this is starting to REALLY annoy me
17:27:52 <Cale> dividend is a list and you're applying it to a value as if it is a function
17:28:08 <liquidengineer> I need it to be the first argument of polysub
17:28:20 <Cale> then don't put the paren there
17:28:25 <liquidengineer> where?
17:28:49 <Cale> rGetQuotient (a:divisor) (b:dividend) = (rDiv b a): rGetQuotient divisor (rPolySub dividend (rPolyMult (rDiv b a) divisor))
17:28:50 <heatsink> this is the same thing we went through when 'divisor' was giving you problems.
17:29:01 <liquidengineer> oh
17:29:04 <liquidengineer> yeah
17:29:05 <liquidengineer> sorry
17:29:10 <liquidengineer> I've been doing this too long
17:30:02 <heatsink> haskell syntax is hard to read if you come from a language that does function calls like f(a,b,c) but you can get used to it.
17:30:58 <liquidengineer> I'm a java nerd
17:30:59 <liquidengineer> so yeah
17:31:03 <liquidengineer> now I'm getting this
17:31:03 <liquidengineer> Type checking
17:31:03 <liquidengineer> ERROR Davis#2.lhs:108 - Type error in application
17:31:03 <liquidengineer> *** Expression     : rPolyMult (rDiv b a) divisor
17:31:03 <liquidengineer> *** Term           : rDiv b a
17:31:04 <liquidengineer> *** Type           : (Int,Int)
17:31:06 <liquidengineer> *** Does not match : [Rat]
17:31:10 <liquidengineer> I think I know what's wrong, though
17:31:23 * cm type checks heatsink
17:31:30 <liquidengineer> should be rPolyMult rDiv (b a) divisor
17:31:37 <liquidengineer> right?
17:31:38 <heatsink> am I pathologically typed?
17:32:06 <cm> i'm still unifying :/
17:32:07 <heatsink> what are the types of rPolyMult and rDiv?
17:32:34 <liquidengineer> rPolyMult takes two lists of Rationals (ordered pair tuples) and returns a third list
17:32:57 <heatsink> [(Int, Int)] -> [(Int, Int)] -> [something]
17:33:04 <liquidengineer> right
17:33:09 <liquidengineer> of Rationals
17:33:18 <liquidengineer> the third list is Rat
17:33:23 <heatsink> [(Int, Int)] -> [(Int, Int)] -> [Rat]
17:33:35 <liquidengineer> right
17:33:42 <liquidengineer> Rat is the same thing as (Int,Int)
17:33:47 <heatsink> oh, okay.
17:34:11 <liquidengineer> you know what?
17:34:19 <heatsink> nope.
17:34:44 <liquidengineer> rDiv (b a) returns constant rational
17:35:11 <liquidengineer> not a list of them
17:35:17 <cm> 8)
17:35:21 <heatsink> I don't think you want to do rDiv (b a).  Do you mean (rDiv b a)?
17:35:42 <liquidengineer> I have a another function that multiplies constant fractions by polynomials
17:36:16 <liquidengineer> duh.
17:36:17 <liquidengineer> sorry
17:36:42 <liquidengineer> at least the rest of the syntax is fixed now
17:36:43 <liquidengineer> thanks
17:36:58 <heatsink> Glad to help.
17:37:56 <liquidengineer> my god
17:37:58 <liquidengineer> it works now
17:38:03 <liquidengineer> and I understand why it works
17:38:09 <heatsink> :D
17:38:25 <Lor> Enlightenment is always cool.
17:38:28 <liquidengineer> yeah
17:38:35 <liquidengineer> it's funny about recursion, though
17:39:12 <liquidengineer> I understand it if I don't try to trace it in my head
17:39:27 <Lor> If you are bored and want to understand what something does and why it does that, try to figure out (call/cc call/cc).
17:39:46 <liquidengineer> I have to write the algoritm, assume it works, maybe test it with pencil and paper, but if i try to think through it, bad things hapen
17:41:40 <liquidengineer> \apparently my brain isn't geared for stack tracing
17:41:41 <liquidengineer> :P
17:42:23 <jaro> By the way, how do you do the debugging of your haskell programs? I noticed, that it usualy works fine on the first run, but if it doesn't it's quite hard for me to figure out, what's wrong.
17:42:55 <jaro> I did use Hat once, but it seems to me quite complicated way to get it working - write, complie, run hat, trace...
17:43:08 <jaro> I would prefer something built into the hugs.
17:43:30 <Lemmih> The Ninja!
17:43:47 * heatsink hasn't done anything requiring more than Debug.trace... yet...
17:44:05 <cm> I want an eager Haskell :o)
17:45:10 <jaro> Ugh. Sometimes, thinking even hurts ;-)
17:46:00 <SyntaxNinja> it is I
17:46:12 <jaro> heatsing: Debug.trace ?
17:46:41 <jaro> heatsink: sorry for miswriting your nick ;)
17:47:23 <dons> @type Debug.Trace.trace
17:47:25 <lambdabot> Debug.Trace.trace :: forall a. String -> a -> a
17:49:09 <jaro> well... I'm confused... @type Debug.Trace.trace (point where I can find it in the docs?)
17:49:21 <heatsink> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Debug.Trace.html
17:49:33 <jaro> thx
17:50:20 <dons> I also like GHC.Base.assert
17:51:14 <SyntaxNinja> jaro: the hierarchical libraries have a nice summary page of all the modules, have you found that?
17:51:17 <heatsink> ooh this could be useful.
17:52:27 * TheHunter thinks more functions (head, tail, etc.) should work like assert.
17:52:44 <jaro> SyntaxNinja: Yes, I think so.
17:52:57 <dons> sorry, it's also Control.Exception.assert
17:53:06 <cm> head (a!=[]) a :o)
17:53:58 <dons> you can even compile away your assertions with -fignore-asserts
17:54:39 <heatsink> if you do that, does GHC still use knowledge of the assertions in optimizations?
17:55:45 <dons> don't know. let's investigate...
17:57:07 <jaro> heatsink: How can GHC use assertions in order to optimize the code?
17:58:54 <jadrian> jaro: assertions? don't you mean pragmas?
17:59:02 <dons> with out -fignore-asserts ghc uses GHC.Err.assertError and once you turn them off, ghc usses instead GHC.Base.assert which is like const
17:59:20 <heatsink> jaro: assert (case x of {Nothing -> False; _ -> True}) (foo x)
18:00:22 <heatsink> if foo is defined one way when called with (Nothing), and another way when called with (Just _), then normally every call to foo would result in a test of x and an indirect jump
18:00:23 <jadrian> "How can GHC use assertions in order to optimize the code?" <-- assertions are not meant to optimize code...
18:00:46 <dons> with -O GHC.Base.assert is optimised away if possible
18:00:52 <heatsink> if x is known to be (Just _), then the indirect jump can be optimized away
18:01:33 <heatsink> The assert communicates that information, if the compiler cannot infer it by other means
18:01:34 <TheHunter> heatsink, if ghc did that, assert would have to be called unsafeAssert
18:01:51 <heatsink> hmm... I suppose so.
18:02:46 <autrijus> anyone versed in shiftT/resetT as implemented on the wiki?
18:02:55 <autrijus> @wiki ContinuationDoneRight
18:02:56 <lambdabot> http://www.haskell.org/hawiki/ContinuationDoneRight
18:03:24 <autrijus> I'm having problem understanding its interaction with ReaderT.
18:05:10 <dons> anyway, both GHC.Base.assert and GHC.Err.assertError are normal Haskell functions (the later throws an exception) and are subject to the usual optimisations
18:05:35 <cm> too bad :)
18:09:20 <autrijus> ah. never mind. I've found ccshan's "Shift to Control".
18:09:26 * autrijus dives some more
18:13:36 * Lemmih throws in the towel. The internals of GCC are way too messy for me.
18:16:53 <dons> yes!
18:17:12 <dons> whose idea was it to write a compiler in C, of all things?
18:17:56 <Lemmih> I've never seen so many casts in my life.
18:21:11 <Igloo> SyntaxNinja: Not yet, no. Sorry.
18:23:49 * Lemmih plans to write the code in Haskell and goes to sleep.
18:29:31 <SyntaxNinja> Igloo: that's OK
18:30:58 <Igloo> Although it looks like hopefully-my-last 6.2.2 compile finished earlier today  :-)
18:42:01 <syntax_syntax> going out is weird.
18:42:20 <syntax_syntax> as in the big black room with little lights.
18:42:31 <syntax_syntax> and no internet.
18:42:42 <shapr> Lor: plug attapl how?
18:42:53 <shapr> good morning #haskell !
18:42:55 <syntax_syntax> shapr I hear you're a dvorakie.
18:43:02 <shapr> since 1992
18:43:34 <syntax_syntax> I tried to learn dvorak yesterday, but it was too frustrating.
18:44:18 <shapr> It took me about a week for the frustrating part to pass, and a coupla more weeks before I was faster than with qwerty.
18:44:34 <syntax_syntax> shapr well, I need deadkeys.
18:44:46 <syntax_syntax> The dvorak layout actually makes a lot of sense for my native portuguese, but I need deadkeys.
18:44:54 <Lor> shapr, I told him to advertise it in comp.lang.*, and in the various mailing lists, like he did with TAPL.
18:44:58 <syntax_syntax> And apparently the only way to obtain deadkeys with dvorak on windows is to replace some dll.
18:45:08 <syntax_syntax> you need to reboot for each change between dvorak and qwerty.
18:45:17 <syntax_syntax> and obviously I can't do that in labs where I have limited access.
18:45:20 <Lor> He answered: "you're right -- it's time for a full-press media blitz"
18:45:22 <syntax_syntax> so it's a nonstarter.
18:45:25 <shapr> Lor: haha!
18:46:13 <shapr> syntax_syntax: You gotta do what works for you.
18:46:17 <SyntaxNinja> syntax_syntax: how'd it go with the girl and the friends situation?
18:46:47 <SyntaxNinja> shapr: you missed out, some guy appeared here and said "convince me that Haskell rules" or something of the kind
18:47:45 <shapr> syntax_syntax: I had the same problem, no computer of my own, learned on windows95. But my goal was (is) to keep my mental flexibility such that I can continue to evolve a keyboard layout and be able to stretch my brain quickly.
18:48:12 <shapr> SyntaxNinja: You can lead a horse to water...
18:48:16 <SyntaxNinja> shapr: this reminds me, do you use gnuemacs?
18:48:30 <shapr> I do, but I'd rather burn it down into a pile of bits.
18:48:36 <SyntaxNinja> shapr: he was pretty cool, and sounded impressed w/ Haskell, but no one can do the "Tour" like you
18:48:59 <shapr> I used to use xemacs, but switched because of some gnus bugs.
18:49:08 <SyntaxNinja> shapr: I wrote a sweet little shell script called "em" that checks to see if there's an emacs-server running and attaches to that if it can, or instead it runs emacs -nw -q
18:49:09 <shapr> Now gnumacs is crashing several times a day for me :-(
18:49:14 <SyntaxNinja> so this is what I use for EDITOR type stuff.
18:49:30 <shapr> Yeah, emacsclient/gnuclient is awesome :-)
18:49:35 <SyntaxNinja> em is also easier to type than "emacs -nw -q"
18:49:38 <SyntaxNinja> do you want my em script?
18:49:49 <shapr> Nah, I've already got one, thanks.
18:49:54 <shapr> I did the same thing long ago.
18:50:03 <SyntaxNinja> oh, I should have asked you before learning to write shell scripts again
18:50:25 <SyntaxNinja> BOOH-YAH! the cvs-libraries list is at my mercy!
18:51:09 <shapr> If you want to expand your emacs knowledge - http://www.emacswiki.org/cgi-bin/wiki/EmacsNiftyTricks
18:51:53 <SyntaxNinja> what do you guys think about shadowing bindings? I do it on purpose sometimes so I don't accidentally use the wrong binding
18:52:06 <SyntaxNinja> but it causes a warning that's annoying
18:52:37 <shapr> Wait a sec, it couldn't have been windows 95 that I learned on....
18:53:14 <shapr> I shadow bindings too, not sure if there's a really good reason that I shouldn't.
18:53:50 <jaro> good night to you all... morning approaches ;-)
18:54:02 <shapr> Lor: I'm looking forward to reading the part about region allocation, I think that'll be really useful for distributed parallelism.
18:54:12 <shapr> g'night jaro
18:56:49 * shapr sings the Good Morning song from "Singing In the Rain"
18:58:13 <shapr> Lor: so, want to write something for The Monad.Reader?
18:58:27 <shapr> I see that Gahhh was already trying to recruit you ;-)
18:58:35 <Lor> Huh?
18:58:56 <Lor> Oh, some Haskell propaganda thing?
18:59:02 <shapr> Did I already ask you about writing an article for http://www.haskell.org/hawiki/TheMonadReader
18:59:18 <Lor> Prolly not.
18:59:24 <shapr> I wouldn't call it propaganda. More like a Haskell eZine
18:59:42 <shapr> hiya gdsx
18:59:53 <Igloo> SyntaxNinja: That means if you delete a binding you think is unused the program will still compile with the wrong results (and fewer warnings)
19:00:13 <Lor> shapr, kindasorta cool.
19:00:27 <Lor> If you bug me really, really hard you might get me to write something.
19:01:06 <shapr> I'd rather you wrote about a subject that interests you, say... proof-carrying code and why it's good?
19:01:18 <SyntaxNinja> Igloo: yeah. which is worse?
19:01:27 <autrijus> hmm, so under a ReaderT, shift/reset restores the context, but callCC lets the inner closure modify the outer context.
19:01:29 <SyntaxNinja> it's hard to delete a binding that you think is not used
19:01:33 <Lor> I think you're thinking of pseudonym. :)
19:02:10 <Lor> One thing I would prolly like to think about is my ancient arrow hack with xml and dtd:s.
19:02:13 <shapr> Nah, you and I have had long discussions about mobile code and type safety.
19:02:15 <Lor> s/think/write/ :)
19:02:20 <shapr> Hm, that would be cool.
19:02:44 <shapr> I'm tempted to try to organize next issue around arrows as much as possible.
19:02:45 <Lor> Anyway, not this month. I have a full-time job _and_ a teaching thingy on top of that _and_ I'm moving.
19:02:47 <Igloo> SyntaxNinja: Moving a block of code then, perhaps
19:03:04 <Lor> Next month I'm no longer moving and I no longer have the teaching thingy.
19:03:14 <shapr> Ok, I'll ask you again for issue 2.
19:03:19 <SyntaxNinja> Igloo: in that case, you probably want the binding that's correct for whatever scope you're moving it to
19:03:39 <Lor> (If I don't show up on IRC often enough, feel free to bug me via email as well)
19:03:43 <shapr> ok, cool.
19:04:10 <shapr> An arrow-style issue would be really good for the Haskell community, I think. Seems most people haven't gotten around to using them yet.
19:05:01 <shapr> Wouter Swierstra wrote a minimal Parsec clone that uses arrows, I could get someone to extend that to cover more of Parsec.
19:05:32 <shapr> Would be neat to profile Parsec against Parrowt for commonly used libs like HsEmail
19:06:10 <shapr> But first, I need to finish my Template Haskell tutorial.
19:06:12 <Lor> I recall once using a huge amount of time trying to figure out a truly deterministic and efficient parser system.
19:06:33 <Lor> I think it's pretty much impossible.
19:06:34 <shapr> I would guess arrows would be central in such a thing?
19:06:48 <Lor> Well, something more static than monads, anyway.
19:07:12 <Lor> The UU_Parser library is not arrow-based, after all.
19:07:13 <SyntaxNinja> does anyone know the difference between ReadP in cabal and ReadP in fptools?
19:07:43 <shapr> True, and one article I *really* want to read is, what's the difference between AGs and Arrows, in words small enough for me to understand?
19:07:57 <Lor> Attribute grammars?
19:08:08 <shapr> Yup, that's what UU_Parser uses, right?
19:08:12 <Lor> Not really.
19:08:23 <Lor> I've been thinking a lot about attribute grammars too, at one point.
19:08:37 <Lor> An attribute grammar is pretty much equivalent to a RWA (reader-writer-arrow).
19:09:01 <Lor> The reader is for the inherited attributes, the writer for the synthesized ones.
19:09:46 <shapr> That's very useful info.
19:10:22 <Lor> There's a paper about AGs in haskell that I read ages ago...
19:10:52 <shapr> If you wanted to write an article about that, I know I would appreciate it. Not sure about the rest of the readers.
19:11:25 <shapr> Which paper?
19:12:04 <Lor> Hm, I can't find it online, yet I remember having printed it. Waitasec, I'll dig out the folder.
19:12:15 <shapr> thanks, I appreciate it.
19:13:14 <Lor> http://citeseer.ist.psu.edu/johnsson87attribute.html
19:13:50 <shapr> nifty!
19:15:52 <shapr> Huh, I didn't know AGs came from Knuth.
19:16:31 <shapr> AGs are three years older than me, yow!
19:17:10 <Lor> Hm, you intend Monad.Reader to be a pure wiki publication?
19:17:26 <Lor> Which wikiengine? How does it handle exotic notation?
19:17:48 <shapr> That was the original idea, though now I'm going with PS/PDF output as well as html output.
19:18:01 <Lor> So the source would be..?
19:18:04 <shapr> I'm seriously considering switching back to a pure wikizine though.
19:18:20 <Lor> mediawiki handles latex.
19:18:23 <shapr> The source would be a combination of text and latex in either case.
19:18:42 <shapr> Moin also handles LaTeX, and writing a plugin for Flippi to handle LaTeX wouldn't be hard.
19:18:59 <Lor> Moin is hack, but a reasonably pretty hack.
19:19:10 <Lor> mediawiki is also a hack, and a huge, complex hack at that.
19:19:18 <shapr> Does MediaWiki handle LaTeX differently than Moin?
19:19:33 <Lor> How many ways are there to handle latex?
19:19:57 <Lor> The only one I can think of is to run latex on it, then use gs to render the ps to a bitmap, and then show that.
19:19:59 <shapr> I only know one, dump it to a ps, hand it to ImageMagick, embed the image.
19:20:08 <shapr> Yup
19:20:09 <Lor> imagemagick just calls gs.
19:20:27 <Lor> By calling gs directly you get more control over what happens.
19:20:41 <shapr> Including snipping whitespace around the edges?
19:21:02 <Lor> Yeah.
19:21:16 <Lor> There's a driver for gs that just calculates the bounding box.
19:21:31 * shapr looks in the man pages
19:21:44 <shapr> ah, cool
19:23:21 <Lor> I've thought about these things, even though I've never actually _used_ them for anything. :)
19:26:57 <shapr> I'd love to try to prove to myself the equivalence of arrows and AGs, but I need to have my TH tutorial finished in the next week.
19:27:11 <shapr> Speaking of wiki hacks, have you seen Flippi?
19:28:07 <Lor> Never heard of it.
19:28:13 <Lor> I could stfw, but I'm too tired for that.
19:28:35 <Lor> (Half past five hereabouts, pretty late there, too)
19:28:47 <shapr> http://www.scannedinavian.org/cgi-bin/flippi/flippi
19:28:52 <shapr> Yeah, but I just woke up :-)
19:29:39 <Lor> All right, a haskell wiki.
19:29:56 <shapr> Yup, it has very clear internals also.
19:31:01 <shapr> The dev version has a nice plugin arch.
19:31:49 * Lor shall sleep now.
19:31:59 <shapr> g'nite
19:32:00 <Lor> Night, folks. Morning. Wadever.
19:32:03 <shapr> heh
19:33:40 <shapr> hiya _dd
19:34:07 <_dd> Hi
19:34:12 <shapr> Looking for Haskell info?
19:34:57 <_dd> Nothing in particular right now
19:35:15 <shapr> Ok, feel free to ask any questions if you find some.
19:58:01 <jadrian> what is an alpha-equivalence check?
19:58:20 <jadrian> I know it has something to do with bound variables...
19:58:33 * jadrian should learn about alpha and beta transformations...
20:01:49 <jadrian> nevermind... I got it
20:05:42 * shapr tries a gamma transformation, and turns into the HULK!
20:19:16 <syntax_syntax> what are alpha and beta transformations?
20:19:49 * desrt eta-reduces shapr
20:20:01 <syntax_syntax> shapr I've been thinking of writing a genetic algorithm to evolve the ideal keyboard layout given a mass of text.
20:23:25 <shapr> I've been thinking of a hidden-markov-model keyboard layout that gives you a separate layout to follow every key you press.
20:24:16 <desrt> as in, pressing one physical key repeatedly might result in the output "thethethethethe"?
20:24:30 <shapr> yes
20:25:14 <desrt> it'd be interesting to meet a person who learned how to use such a keyboard effectively
20:25:19 <shapr> though more likely "the the the "
20:25:35 <shapr> I don't yet have enough data to design the layout :-)
20:25:37 <desrt> space is sacred
20:25:47 <shapr> whatever for?
20:25:49 <desrt> plus, space could be a good way to get you back to a known state
20:25:55 <shapr> good point
20:27:54 <desrt> what might be interesting is a small application that grabs the mouse pointer and pulls it to the centre of its window
20:28:11 <desrt> and all the common letters "rstlne" sort of thing are right in the centre with the less common ones outward
20:28:29 <shapr> ?
20:28:35 <desrt> and every time you click on a letter it pulls the mouse back to the centre and reconfigures the layout so that all of the most likely next-letters are in the centre
20:28:39 <shapr> expliquez vous, je ne comprends pas.
20:28:46 <shapr> ah, right
20:28:48 <shapr> same idea
20:28:50 <desrt> so if you click "t" for example, then "h" might be right in the middle
20:28:57 <desrt> nod.
20:29:09 <desrt> except this way you get some visual help :)
20:29:46 <shapr> Maybe an 80% transparent XOSD keyboard layout display?
20:30:01 <desrt> that could be useful.
20:30:17 <desrt> or using a horizontal touchscreen for your keyboard
20:30:26 <shapr> In fact, you could keep the layout continually changing according to the most recently calculated HMM, as long as the changes were brihtly lit.
20:30:28 <desrt> (or something that accomplishes the same)
20:31:44 <shapr> My goal for an HMM layout would be easy one-handed typing.
20:32:25 <desrt> you're familiar with dvork one-handed layouts?
20:32:27 <desrt> *dvorak
20:32:31 <shapr> Yes, I use them.
20:32:37 <shapr> Well, I use right-hand.
20:32:58 <desrt> my keyboard is capped two-handed dvorak
20:33:02 <desrt> occasionally i use it that way
20:33:32 <shapr> For extra nuttiness in an HMM layout you could require only half the actually needed keys and have a 'shift' key that inverts the HMM frequency to give you the less likely half of the letters.
20:33:59 <shapr> Though I'm not sure if that's ultimate evil as premature optimization goes. It's definitely sacrificing the less common case for speed inthe common cases.
20:35:05 <desrt> it depends on what's worse... one-handed shifting or reaching
20:35:08 <shapr> I used dvorak two-hand mostly, but I like right-hand also.
20:35:38 <desrt> is the shift like hold-down or more like a deadkey?
20:35:54 <desrt> if it was a deadkey it wouldn't be too offensive
20:35:59 <shapr> Hm, good point. In my experience, one-handed reaching is really difficult, it's much harder to jump back to the home row when one hand needs to span all of the keys rather than half of them.
20:37:38 <desrt> i think i'd be good to try left-handed dvorak
20:37:48 <desrt> on qwerty, i'm left-hand dominant anyway
20:37:51 <shapr> Probably the best solution (if you want less than 100% of the keys) is to have 60% of the physical keys and the shift/swap.
20:38:07 <shapr> I'm a leftie, but I usually mouse with my left.
20:38:22 <desrt> ah.  i just got used to the mouse being on the right
20:38:25 <shapr> Oh speaking of which... is there some way to give mouse input from a keyboard?
20:38:32 <desrt> on what os?
20:38:58 <shapr> I was thinking about a mouse-shift, where I can hold down a key, move the mouse around with my keyboard, and let off that key to get back to a real keyboard.
20:39:07 <shapr> Linux
20:39:27 <desrt> not that i know about
20:39:39 <shapr> I wonder how hard it would be to write.
20:39:45 <desrt> oh yes.  gnome has "mouse keys"
20:39:54 <shapr> ??
20:40:02 <shapr> this I must try.
20:40:14 <desrt> it's not bad
20:40:26 <desrt> i'm using it now
20:40:30 <desrt> it takes over the numeric keypad
20:40:52 <shapr> My kinesis doesn't have a separate keypad, just a keypad shift key like a laptop. I dunno if that's good or bad.
20:41:02 <desrt> 5 = click
20:41:07 <desrt> 0 = hold
20:41:09 <desrt> . = release
20:41:10 <shapr> Sounds cute
20:42:43 <araujo> Hello Haskell.
20:43:03 <shapr> hola, espaÃ±a
20:43:10 <autrijus> hello lambdatrons.
20:43:19 <shapr> nyehowma
20:43:43 <autrijus> henhao, xiexie
20:43:46 <shapr> How do you write tonal languages in the latin charset?
20:43:59 <autrijus> hen2hao3
20:44:07 <autrijus> xie4xie4
20:44:11 <shapr> whoa, cool
20:44:28 <autrijus> :)
20:44:31 <shapr> I know the tones for nyehowma, but I don't know their numbers, can you write it?
20:44:41 <autrijus> ni3hao3ma1
20:44:58 <autrijus> but pronounced ni2hao3ma1
20:45:02 <shapr> Also, I was told that ni3hao3 is more like "greetings" and ni3hao3ma1 is more like "are you ok?"
20:45:15 <autrijus> yeah.
20:45:46 <shapr> One day I'll get around to learning a tonal language.
20:46:12 <araujo> shapr, 8)
20:46:43 <shapr> Probably mandarin, I'd rather learn four tones instead of something scary like the twelve tones of some cantonese dialects.
20:46:59 * araujo just got up
20:47:12 <shapr> It's a beautiful day out there! Kind of dark though.
20:47:23 <araujo> i don't know what happen.....
20:47:25 <araujo> hahah
20:47:34 * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost
20:47:47 <shapr> Didn't you write that code?
20:47:49 <araujo> it is around 1 am...
20:48:04 <autrijus> yeah. and it works
20:48:07 <autrijus> I just don't know what it means.
20:48:09 <shapr> araujo: where are you? It's nearly 6am here.
20:48:10 <shapr> autrijus: haha!
20:48:18 * shapr quotes that
20:48:28 <araujo> shapr, venezuela
20:48:36 <shapr> ohh
20:48:36 <araujo> you in finland?
20:48:49 <shapr> Not anymore, I moved to Sweden about three years ago.
20:49:00 <araujo> Ok.
20:49:54 <shapr> autrijus: What do you think? Which tonal languages are easier than others?
20:50:35 <autrijus> shapr: mandarin is probably easier.
20:50:36 <araujo> Oh well, since im on vaxcations im leading a life of awakened during night and sleeping the rest of the day......
20:50:37 <shapr> How'd you get such a cool name like autrijus? It sounds latin.
20:50:39 <autrijus> it's the common tongue anyway.
20:50:45 <autrijus> shapr: Atreju
20:51:34 <autrijus> or rather, atreyu
20:51:57 <shapr> nifty
20:56:00 <SyntaxNinja> ooh, I really like ghc-pkg :)
20:56:08 <SyntaxNinja> (in 6.4)
20:58:53 <shapr> is that because it's Cabal?
20:59:30 <tmoertel> it's because it's better than having to do this in an RPM spec file: perl -00 -ln -e'($n)=/^name = "(.*?)"/m; s{%{buildroot}}{}g;'-e'open F, ">%{buildroot}%{pkgstore}/$n.pkg" and print F'%{buildroot}/all.pkg
20:59:40 <SyntaxNinja> it uses cabal here & there, I think. but i just like the interface "ghc-pkg hide hunit" for instance
20:59:51 <SyntaxNinja> ghc-pkg expose hunit
21:00:03 <shapr> tmoertel: sounds scary
21:00:13 <tmoertel> that's what I had to do to package WashNGo
21:01:06 <SyntaxNinja> tmoertel: I would be very curious to know if building RPMs from cabal-ized packages is as easy as it is for Debian
21:01:57 <tmoertel> i think just having the ability to separate the creation of package-file descriptions from the installation of the packages w/ the descriptions would make it easy as pie
21:02:12 <tmoertel> that's the hard part, pre-cabal
21:02:37 <shapr> The Cabal is led by a Ninja. Who woulda thunk?
21:03:31 <tmoertel> Ninjas certainly are stealthy.
21:04:02 * SyntaxNinja nods sagely
21:04:14 * tmoertel could not see the nodding
21:04:22 * shapr snickers
21:05:07 <SyntaxNinja> tmoertel: you could do that with ghc-pkg pre-cabal, right?
21:05:29 <tmoertel> with ghc-pkg, yes, but most of the makefiles going around didn't allow for it
21:05:52 <tmoertel> they mainly wired "make install" so that the package-info files were created and then used to immediately install the package
21:05:53 <SyntaxNinja> tmoertel: for debian, cosmicRay created a script to debian-ize any old cabal-ized package. any chance of putting something similar together for rpm?
21:06:18 <tmoertel> SyntaxNinja: it's very likely
21:06:23 <SyntaxNinja> tmoertel: right
21:06:38 <SyntaxNinja> tmoertel: I've noticed that annoying thing myself.
21:06:53 <SyntaxNinja> tmoertel: but why not just ship the generated package config file and use ghc-pkg to install it on the target?
21:07:35 <tmoertel> SyntaxNinja: that's what I do. the hard part is coaxing just the package config out of a makefile that is hardware to install the package
21:07:46 <tmoertel> (that's what the above Perl one-liner was for)
21:07:56 <tmoertel> s/hardware/hardwired/
21:08:30 <SyntaxNinja> tmoertel: ahh.  you see, I don't speak gibberish ;)
21:08:44 <tmoertel> SyntaxNinja: that's all I speak, really  :)
21:09:01 <SyntaxNinja> hm. since I can understand you, perhaps I do speak gibberish
21:09:02 <tmoertel> oh, you meant Perl
21:09:37 <tmoertel> packaging WashNGo for RPM was tricky
21:10:04 <tmoertel> take a look at http://community.moertel.com/rpms/fedora/3/SPECS/WashNGo.spec
21:10:39 <tmoertel> look at the "make install" command in the %install section
21:10:57 <SyntaxNinja> tmoertel: are you not allowed to change upstream makfiles?
21:11:34 <SyntaxNinja> ooh, generating that from cabal is a snap!
21:11:35 <tmoertel> yes, you can by adding a patch, but it was easier in this case to trick the existing makefile by providing a carefully crafted value for GHCPKG
21:12:25 <tmoertel> WashNGo has 5 ghc packages
21:12:45 <SyntaxNinja> yeah, I cabalized wash a while back as a test. i use wash2hs in my test suite actually
21:13:16 <tmoertel> I trick the makefile into writing all of their configs into one file (all.pkg) and then use the Perl script to split them into five separate .pkg files, which get shipped with RPM, and passed to ghc-pkg when the RPM is installed
21:14:56 <tmoertel> if I get a few hours next week, i'll look into writing a cabal -> rpm program
21:15:13 <SyntaxNinja> awesome :)
21:15:58 <SyntaxNinja> I'm likely going to re-cabalize wash as soon as cabal hits 1.0
21:16:23 <tmoertel> was a cabalized wash ever released officially?
21:16:58 <SyntaxNinja> nope
21:17:13 <SyntaxNinja> cabal has been changing too fast to make it practical
21:17:31 <tmoertel> how stable would you say cabal is now?
21:18:18 <SyntaxNinja> it's pretty darn close; 1.0 comes with GHC 6.4 whenever that comes out, which is Real Soon Now
21:18:31 <SyntaxNinja> unfortunitely, cabal is holding up ghc 6.4 a bit
21:19:00 <shapr> On the other hand, I'll have to support whatever Cabal interface is in 6.4
21:19:06 <tmoertel> it seems that simon got a few other problem reports when he announced the RC on the list recently
21:19:46 <SyntaxNinja> I don't actually know of any interface changes in the pipe (for cabal) and that's saying something!
21:19:51 <shapr> Quite a few Cabal questions appearing on #haskell lately, 6.4 will increase that.
21:20:05 <SyntaxNinja> yup. speaking of which, I should slap the docs online.
21:20:21 <shapr> and I should cabalize everything I maintain.
21:20:23 <tmoertel> having docs always helps
21:21:46 <shapr> Paging Dr. Moertel...
21:22:13 * tmoertel is on the golf course and not answering his pager
21:22:22 * shapr chortles
21:22:55 <shapr> Along the Straight line of ADD associations, my new ADD doc is Dr. Thor
21:23:35 <tmoertel> my login is "thor". coincidence?
21:23:43 <shapr> That was the straight line I was talking about :-)
21:24:06 * tmoertel must need caffeine
21:24:44 <shapr> ADD doctors either love or hate me. I often know more than they do about the subject, that doesn't always go over well.
21:24:51 <SyntaxNinja> cabal docs. email libraries@haskell.org for bug reports or suggestions: http://www.haskell.org/cabal/Cabal.pdf
21:25:13 * tmoertel is reading docs
21:25:25 <autrijus> I was talking to a conseler about my bipolarity one day, when I'm depressed. when the talking is done, I'm not a bit better, and she became suicidal.
21:25:49 <shapr> autrijus: That's humorous in a morbid sort of way.
21:25:54 <autrijus> yeah.
21:25:55 <tmoertel> time for a new counselour?
21:26:06 <autrijus> well, the best one so far admitted he can't help.
21:26:09 * autrijus shrugs
21:26:25 <autrijus> knowing more than the doc seems to be no good :)
21:26:38 <shapr> Does mean you can find out for yourself what works and what doesn't
21:26:53 <autrijus> true. next month I'll probably get a shipment of ritalin
21:27:02 <autrijus> we'll see if it works.
21:27:36 <shapr> I can talk to you about dosage, etc when you get it. If you want some advice from a user, that is :-)
21:27:43 <autrijus> sure :)
21:28:03 <autrijus> ingy (the friend who'll bring it) is also a user
21:28:08 <autrijus> so I assume he knows something about it.
21:29:19 <shapr> I just got more yesterday, lucky for me.
21:29:48 <autrijus> cool.
21:30:01 <shapr> Sweden is paranoid about methylphenidate, they classify it like amphetamines. It's a pain to get a prescription.
21:30:51 <shapr> Speaking of random associations, find new and better ways to tie your shoes! - http://www.fieggen.com/shoelace/knots.htm
21:32:08 <autrijus> does python let you access your caller's lexical scope?
21:32:49 <shapr> Um, probably does now, but it didn't have nested scope until very recently.
21:32:50 <autrijus> or, for that matter, what is the recommended way to implement it in haskell?
21:33:48 <tmoertel> SyntaxNinja: does "Setup.lhs copy" include a copy of Setup.lhs in the copied files?
21:33:50 <autrijus> I'm using a ContT on top of ReaderT; the ReaderT contains a Env that points to its caller's env
21:34:10 <autrijus> but I wonder if there's a more straightforward way
21:34:42 <autrijus> Env { envPad :: [Symbols], envCaller :: Env }
21:34:47 <SyntaxNinja> tmoertel: no
21:35:15 <tmoertel> SyntaxNinja: the docs recommend calling "Setup.lhs register" after unpacking on the target system. how does that work, then?
21:36:18 <SyntaxNinja> tmoertel: you have to carry Setup.lhs and some other droppings along with you. maybe copy should bring them along actually
21:36:41 <tmoertel> what if Setup.lhs has prereqs?
21:36:43 <SyntaxNinja> right now copy just does what install does.  it would be nice to install the Setup and description files and such someplace
21:36:57 <shapr> autrijus: It looks sensible to me, but I'm not that clueful in that area.
21:37:09 <SyntaxNinja> yeah, it's a little dicey which is why we don't do it.
21:37:22 <SyntaxNinja> that's up to the packager
21:37:47 <tmoertel> SyntaxNinja: it would be ideal for RPM-packaging purposes if there was a Setup command to copy the package configs and the appropriate ghc-pkg commands for them
21:38:51 <tmoertel> at RPM-building time, Setup knows (1) the ghc package configs and (2) the corresponding ghc-pkg commands; can we get that info out so that Setup.lhs does not have to go along for the ride in the RPM?
21:39:47 <SyntaxNinja> hm. we could just dump a shell script to do that.
21:40:00 <tmoertel> (here I use "ghc" to mean any cabal-supported haskell)
21:40:31 <tmoertel> SyntaxNinja: dumping a script would be great, but maybe not entirely portable
21:40:54 <tmoertel> it would be portable enough for RPM use, however
21:41:17 <SyntaxNinja> so really most target systems should have everything needed for the Setup.lhs script, which is more portable. you just need to grab that and a few droppings for the install step
21:41:29 <SyntaxNinja> thing is, it doesn't actually get installed, so that's another reason that copy doesn't copy it.
21:41:57 <tmoertel> as an RPM packager, I would prefer not to need Setup.lhs on the target system
21:42:02 <SyntaxNinja> shapr: did you hear about Lemmih's xml-rpc interface to hackage? :)
21:42:25 <shapr> heard about it, haven't upgraded Hackage yet though.
21:43:27 <SyntaxNinja> tmoertel: I'll think about that a bit. dumping a shell script wouldn't be hard
21:43:54 <SyntaxNinja> that might be Just the Ticket I've been looking for for the tricky step of unregistering on the target as well
21:44:32 <tmoertel> could you also add a command to emit the ghc package-config, too?
21:44:58 <SyntaxNinja> configure does that
21:45:03 <SyntaxNinja> I think...
21:45:24 <tmoertel> i recall reading that from before ...
21:45:37 <SyntaxNinja> no, I guess register does that
21:45:56 <SyntaxNinja> maybe a flag to register, like --dry-run
21:46:24 <tmoertel> let's think about this for a second...
21:46:36 <tmoertel> there are basically two things you can do with the package config: register and unregister
21:47:14 <tmoertel> can we just emit two scripts -- one to register and one to unregister, both of which contain the correct config?
21:48:31 <tmoertel> or are there benefits from keeing the configs and the config-operating shell commands separate?
21:48:39 <SyntaxNinja> unregister doesn't need the config
21:49:08 <tmoertel> by config i mean the appropriate amount of config info
21:49:22 <SyntaxNinja> another option is to move the emission of the installed-pkg-config to the configure step, so you don't have to run configure to get it
21:50:16 <tmoertel> wouldn't it be possible for the config info to depend on the output of the build stage?
21:50:42 <SyntaxNinja> I don't think that happens. do you have an example?
21:51:08 <tmoertel> i'm thinking of a code-generation scenario
21:51:24 <tmoertel> maybe the build process creates some haskell files on certain platforms
21:52:20 <SyntaxNinja> hm
21:55:09 <SyntaxNinja> it would be pretty cool if each command came with a little --emit-script flag that did a dry run and created a self-contained shell script to do the work
21:55:25 <tmoertel> that would indeed be cool
21:55:46 <tmoertel> and developmentwise, you could factor each command into two parts: one that generated the script and the other that executed it
21:55:51 <SyntaxNinja> I think that the compiler authors will fly here from england just to kill me if I did that
21:56:16 <tmoertel> indeed, maybe that's best left for cabal 2   ;-)
21:56:31 <SyntaxNinja> I was thinking more along the lines of "exec dryRunP cmd = if dryRunP then emit cmd else system cmd"
21:57:25 <tmoertel> yeah, that's what I meant
21:58:02 <SyntaxNinja> oh, I thought you were saying that Haskell should emit shell scripts and then execute them!
21:58:30 <SyntaxNinja> personally, I think that would be bad for Haskell's reputation ;)
21:58:46 <tmoertel> no, that seems a rather scary proposition
22:00:15 <SyntaxNinja> yeah, I'm surprised you even suggested it
22:00:19 <tmoertel> looking at Jens's RPM spec for cabal-0.4, it seems that the "register"  and "unregister" bits are hardcoded for ghc
22:00:20 <shapr> hiya mistah noise
22:00:48 <SyntaxNinja> ooh, there's a cabal RPM?
22:01:11 <tmoertel> SyntaxNinja: the source RPM is here http://www.haskell.org/fedora/haskell/3/SRPMS.stable/
22:02:09 <tmoertel> SyntaxNinja: are you using an RPM-based system for your development?
22:02:22 <wnoise> hiya
22:02:27 * SyntaxNinja snarfs
22:02:34 <SyntaxNinja> tmoertel: no, Debian
22:03:07 <tmoertel> when does cabal write out the .installed-pkg-config file?
22:03:17 <SyntaxNinja> during the register step :(
22:03:47 <tmoertel> really? is that a recent change?
22:04:01 <tmoertel> (the reason i ask is because jens doesn't ever call register)
22:04:22 <SyntaxNinja> I didn't change it; someone else might have.
22:04:25 <tmoertel> oh, he does implicitly via "make install"
22:04:32 <SyntaxNinja> ahh right
22:04:54 <SyntaxNinja> I'll have to fix that. that's going to be top priority tomorrow. there must be a way to generate the file without running register
22:05:12 <SyntaxNinja> does he use ./setup install to build it in a temp location?
22:05:27 <tmoertel> great! if you do that, making RPMs should be very easy
22:06:00 <tmoertel> it doesn't look like he uses setup install but rather the makefile
22:06:04 <SyntaxNinja> probably the compilers authors won't kill me if I add a --gen-script to just the register command
22:06:21 <SyntaxNinja> oh my. he's insane ;)
22:06:28 <tmoertel> SyntaxNinja: no, i think that they would love you all the more!  :)
22:06:49 <SyntaxNinja> the makefile is really just a way to create the setup script to bootstrap
22:07:02 <SyntaxNinja> the makefile is a POS actually
22:08:08 <tmoertel> it seems that every major platform is shifting away from makefiles
22:08:26 <SyntaxNinja> fortunitely, someone already refactored the whole thing so that each time I run "system" it takes into account the verbosity level
22:08:28 <tmoertel> java has ant; perl has Module::Build; and now Haskell, Cabal
22:08:49 <SyntaxNinja> so it shouldn't be hard to change it to optionally emit a shell script
22:09:00 <tmoertel> SyntaxNinja: that's good news
22:09:55 <SyntaxNinja> it's fun having the rest of the cabal hackers on the other side of the world. when I wake up in the morning, cabal has more features, and the same is true for them
22:10:38 <tmoertel> ah, I just noticed Jens's other trick: he patched the makefile to replace "setup install" with "setup copy"
22:11:15 <tmoertel> so "setup copy" must also create the .installed-pkg-config
22:11:56 <SyntaxNinja> oh! build does.
22:12:17 <SyntaxNinja> duh
22:12:34 <tmoertel> oh, that make one half of the solution trivial.  :)
22:12:55 <SyntaxNinja> so now we just have to fix unregister?
22:13:39 <tmoertel> we still need to get register and unregister to emit the commands they would use, otherwise RPM spec files will need to be hardcoded for ghc, hugs, etc
22:15:19 <tmoertel> does that make sense?
22:16:34 <SyntaxNinja> not really...
22:16:39 <SyntaxNinja> I don't know much about spec files
22:17:02 <SyntaxNinja> for debian, we can have different commands for the binary target, in our case, ghc-library and hugs-library
22:18:03 <tmoertel> do your debian spec files contain any ghc- or hugs-specific knowledge?
22:18:43 <SyntaxNinja> yeah, they say how to create binary files for each (configure --ghc verses configure --hugs) and then the post-remove files also know how to unregister for each
22:19:19 <SyntaxNinja> how do you tell the rpm spec files which to build?
22:19:47 <tmoertel> since you know WashNGo, look at that link I provided earlier to the spec file I built
22:19:52 <tmoertel> I'll use it as an example
22:20:39 <tmoertel> rpm builds have three stages: prep, build, and install
22:20:51 <tmoertel> prep is when the tarballs are extracted into a fresh build directory
22:20:52 <SyntaxNinja> ok
22:21:09 <tmoertel> build is when ./configure and make are called to build the binaries
22:21:57 <tmoertel> install is when "make install" is called and passed options to coax it into installing into a fake directory structure that mimics a real system's directory structure
22:22:12 <SyntaxNinja> right
22:22:17 <tmoertel> at this point you have an empty directory structure with only the packages files in it
22:22:43 <tmoertel> in the spec file there is a %files section that maps files in this structure to their final, real destinations
22:23:03 <SyntaxNinja> ok
22:23:26 <tmoertel> you can also provide scripts that are to be executed before and/or after package installation and uninstallation
22:23:45 <tmoertel> those are the scripts that must register any pacakge with the haskell system on the target host
22:24:00 <SyntaxNinja> oh, btw, would you have separate binary packages for each source package?
22:24:05 <SyntaxNinja> right
22:24:47 <tmoertel> each spec can build from multiple tarballs and emit multiple binary RPMs; the division is up to the packager
22:24:55 <SyntaxNinja> ok
22:25:39 <tmoertel> now, if cabal could tell me at RPM-build time what ought to go into the scripts, I could factor out ghc and hugs knowledge from the RPMs
22:26:10 <tmoertel> that way the same RPM spec could also build for, say, nhc, assuming cabal supported it
22:27:07 <SyntaxNinja> OK I think I understand the register / unregister bit. I don't understand how you might emit separate RPMs though.
22:27:20 <SyntaxNinja> I guess your build step would have knowledge of the different compilers, but no other step would
22:28:38 <tmoertel> You can declare multiple output RPM files in the spec and specify, with multiple %description and %files, what goes in them
22:29:38 <SyntaxNinja> so couldn't you do the same thing for the register part?
22:30:17 <tmoertel> i think we're talking about different things
22:30:21 <tmoertel> what I'm talking about is this
22:30:39 <tmoertel> you can have one prep, build, and install per spec
22:30:48 <tmoertel> but the results of those can be split into many output binary rpms
22:30:53 <tmoertel> that's what I mean
22:31:34 <tmoertel> so i couldn't (without some heavy trickery) build for both ghc and hugs in one rpm-building process
22:32:31 <tmoertel> what might be nice, however, is to parameterize the spec so that with cabal's help it could build for any cabal-supported compiler
22:32:52 <SyntaxNinja> yeah, that's the way the Debian stuff is supposed to work
22:33:14 <SyntaxNinja> but we cheat a little I guess by generating the control files rather than having generic control files
22:33:19 <tmoertel> e.g.: rpmbuild -ba --define hc=ghc622 mypackage.spec # build RPMS for mypackage/ghc
22:33:28 <tmoertel> e.g.: rpmbuild -ba --define hc=hugs mypackage.spec # build hugs for mypackage/ghc
22:33:49 <tmoertel> whoops, I meant.: rpmbuild -ba --define hc=hugs mypackage.spec # build RPMS for mypackage/hugs
22:34:25 <SyntaxNinja> we have one control file that specifies all the binary packages built from a single source package
22:34:39 <SyntaxNinja> and I don't think you can paramaterize it. it's always static.
22:36:48 <SyntaxNinja> OK I gotta run. I'll think abot this some more. thanks for the advice.
22:37:17 <tmoertel> OK, gnight. bottom line: cabal as is should be fine. if we can get it to emit scripts, we can factor compiler-specific stuff out of specs.
22:37:32 <tmoertel> but that's a nice-to-have, not a required feature
22:37:39 <tmoertel> 'night
22:38:21 <SyntaxNinja> tmoertel: OK great. glad to hear it should work for RPM. that's important to me. if you think of any show-stoppers, let me know ASAP. this weekend if possible.
22:38:27 <SyntaxNinja> I don't know how long I can hold off the GHC guys ;)
22:38:38 <shapr> wow, this front page news on slashdot about people telepathically controlling the output of random number generators is...
22:38:43 <SyntaxNinja> peace
22:39:53 <dons>   
22:40:01 <shapr>                      ?
22:40:08 <dons> oops
22:40:49 <dons> did you just say "telepathically controlling the output of random number generators"??
22:41:12 <shapr> Yes, in fact I did. Is that the sort of stuff you expect to see on slashdot's front page?
22:41:19 <dons> hmm.
22:42:05 <shapr> I think my most tactful reaction is skepticism.
22:42:55 <dons> this is bizarre
22:43:13 <autrijus> whoa. I finally grokked shift/reset.
22:43:17 <autrijus> amazing stuff.
22:44:07 <shapr> It looks like there are hardware RNGs all over the world, and people are checking to see if collective human thought affects the outputs. The implication of these writings is that major disasters like the recent tsunami do affect the outputs.
22:44:22 <wnoise> autrijus: as in shift/reduce conflicts in grammars?
22:44:33 <autrijus> wnoise: no, as in delimited composable continuations
22:44:51 * shapr eats a slice of yesterday evenings continuation.
22:45:24 <autrijus> now I can write "return" just like what "return" means in Other Languages
22:45:46 <autrijus> (i.e. "do { return 1; return 2 }" --- returns 1)
22:46:50 <tmoertel> in which monad?
22:47:02 <autrijus> in the ContT transformer (on top of readerT)
22:47:38 <autrijus> returnScope rv = do shiftT $ \r -> return rv
22:47:43 <desrt> oh god.... this
22:48:24 <autrijus> and because the readerT stores an Env with records "envCaller  :: Maybe Env, envCont    :: Val -> Eval Val"
22:48:27 <desrt> humans are good at optimisticaly finding patterns in random data and relating it to world events after the fact...
22:48:37 <desrt> pretty boring
22:48:54 <autrijus> it means that I can navigate both lexical and dynamic scopes at will.
22:48:55 <dons> that's what I reckon too
22:49:06 <autrijus> yay for monadic expresiveness
22:49:18 <dons> it's meaningless if they don't make a prediction
22:49:32 <desrt> it's still meaningless :)
22:49:58 <dons> hehe
22:50:00 <shapr> The actual GCP doesn't even talk about prediction, just observation. The newspaper article is journalistic cluelessness.
22:50:04 <desrt> if they make lots of predictions then it is meaningful
22:50:20 <shapr> My opinion of slashdot worsens.
22:50:27 <dons> that's what you need, yes.
22:50:47 <desrt> ugh.... dvorak slows me down
22:50:58 * desrt curses shae
22:51:19 <tmoertel> where is shiftT defined?
22:51:25 <shapr> desrt: practice!
22:51:37 <desrt> heh.  i am forcing myself to.
22:51:58 <dons> have you changed the letters on the keys?
22:52:01 <dons> or just  the mapping
22:52:03 <syntax_syntax> dang
22:52:03 <desrt> for now, though, sleep
22:52:24 <desrt> dons; it has always been this way
22:52:48 <desrt> i had a failed dvorak experiment a year or 3 ago
22:53:24 <desrt> and since i don't need qwerty help, i left it in dvorak
22:53:36 <desrt> ok.... bed.  nite.
22:53:44 <syntax_syntax> I'm stuck with misfunctional matlab code :[
22:53:45 <shapr> g'nite
22:54:54 <syntax_syntax> I should really learn some data structures.
22:55:07 <syntax_syntax> I always represent data in my head as matrixes
22:55:16 <syntax_syntax> and end up with the most contrived matlab code for it.
22:55:42 <wnoise> Oh, hmm.  Interesting.
22:56:17 <tmoertel> well, I'm off to bed, too. g'night, all!
22:56:22 <shapr> g'nite tom
22:58:19 <syntax_syntax> how do you reckon an applied maths-minded amateur might start learning data structure theory?
22:59:17 <Gahhh> I am bored with implementing programming contest problems in haskell. They are too algorithmic. They require very basic i/o. Most problems require no more than lists and pairs.
22:59:42 <syntax_syntax> Gahhh ever heard of genetic algorithms?
22:59:50 <Gahhh> yes. why ?
23:00:02 <syntax_syntax> Gahhh that might be fun to implement in haskell.
23:00:29 <Gahhh> It is hard to find the right question for that kind of problem.
23:00:34 <Gahhh> err solution
23:00:47 <syntax_syntax> one that works well?
23:00:59 <syntax_syntax> damn, I can't seem to code a roulette.
23:01:00 <Gahhh> one where genetic algorithms are applicable
23:01:23 <syntax_syntax> i.e. a random variable from an arbitrary discrete distribution.
23:01:43 <syntax_syntax> Gahhh uhh. I got into this because I'm trying to optimize a keyboard layout given a mass of text.
23:01:54 <syntax_syntax> or pessimize ;-)
23:02:07 <Gahhh> I see
23:02:17 <syntax_syntax> I suck, though.
23:02:24 <syntax_syntax> I can't seem to code that damn roulette.
23:02:34 <Gahhh> You know the typical arguments against new keyboard layouts ?
23:03:18 <syntax_syntax> I'm writing my thesis on the economics of such things.
23:03:26 <syntax_syntax> I'm an economist :-D
23:04:19 <syntax_syntax> there are contradictory studies on the relative efficiency of dvorak and qwerty though.
23:04:28 <syntax_syntax> and the story that qwerty is meant to slow you down is disputed.
23:04:40 <syntax_syntax> so I want to evolve optimal and pessimal keyboard layouts given a mass of text.
23:04:43 <tintin> oh but it is practically true
23:05:13 <tintin> syntax_syntax: the best keyboard for prose is the maltron keyboard
23:05:17 <tintin> not so sure about programmers though
23:05:23 <Gahhh> "fghj" are at the center of the qwerty lol. It's horrible even if it was not meant to slow you down.
23:05:26 <tintin> dvorak is faster
23:05:41 <tintin> i have no doubts in my mind
23:05:49 <Gahhh> tintin, how about keyboard shortcuts ?
23:05:56 * Gahhh uses emacs
23:06:02 <tintin> and i switched just 3 months ago so my speeds are faster than ever
23:06:23 <tintin> Gahhh: i use emacs too and dvorak seems to jell with emacs
23:06:58 <Gahhh> tintin, did you remap any key combos ?
23:07:26 <tintin> Gahhh: no i did not have to i find most of them very comfortable
23:07:49 <syntax_syntax> that's all anedoctical.
23:07:54 <syntax_syntax> I wanted something stronger.
23:08:01 <tintin> syntax_syntax: maltron
23:08:15 <tintin> it was a 1980 keyboard model
23:08:21 <syntax_syntax> that's pure hearsay.
23:08:23 <tintin>  /s/was/is
23:08:34 <syntax_syntax> unless you can prove it with graph theory or something.
23:08:39 <tintin> Maltron took 10 years to get the design right
23:09:18 <tintin> syntax_syntax: sure there have been a lot of people with RSI who are pretty happy with that keyboard
23:09:19 <syntax_syntax> hmm. optimal design == minimal distance travelled to type text, or are we in different pages?
23:09:31 <syntax_syntax> tintin people who've had RSI are happy on any new keyboard.
23:09:37 <tintin> syntax_syntax: that is dvorak ...
23:09:47 <syntax_syntax> it puts them out of the old repetitive motions.
23:09:57 <syntax_syntax> tintin that's heavily disputed.
23:10:27 <tintin> syntax_syntax: maltron took the approach of puting in the keys according to their usage ... rather than finger movements
23:10:33 <tintin> so you might want to read up on it
23:10:45 <tintin> I am happy with dvorak though
23:11:02 <syntax_syntax> damn, if I could just get this roulette right :(
23:11:13 <syntax_syntax> I'm trying to code a genetic algorithm in Matlab, but I suck.
23:11:28 <syntax_syntax> the monte carlo simulation shows my roulette wrong.
23:11:37 <syntax_syntax> roulette =  a random variable from an arbitrary discrete distribution.
23:11:59 <wnoise> re: RSI.  A lot of that may just be changing to a different pattern of typing.  I switched to dvorak several years ago, and it definitely helped my hands.
23:12:34 <tintin> what about RSI with dvorak then ?
23:12:45 <tintin> not sure there have been too many cases
23:13:18 <syntax_syntax> not many people use dvorak.
23:13:19 <wnoise> I'm sure RSI with dvorak happens -- I'm starting to show some signs again, years later.
23:13:43 <tintin> wnoise: then switch to maltorn :)
23:14:08 <wnoise> Clearly I should switch to some wacky layout and take forever to learn.  Heh.  A friend has a maltron, and from how he describes it, it's awful.
23:14:43 <wnoise> I think I've gotten a bit faster with dvorak than I was with qwerty, but no huge improvement.
23:15:07 <syntax_syntax> it's a combinatorial optimization problem.
23:15:27 <wnoise> Is it amenable to the usual heuristics such as simulated annealling?
23:15:39 <tintin> wnoise: did he not like the keyboard or the layout ?
23:15:47 <wnoise> Keyboardwise, I've been lusting after a touchstream, but on my salary...
23:16:21 <wnoise> tintin: the keyboard.  It got into weird modes where it would only output some keys capitalized.
23:17:27 <tintin> wnoise: hmmz its just a normal keyboard from what i hear no gizmos ....
23:17:30 <tintin> maybe he got a defective piece
23:17:47 <tintin> anyways i will have mine in 10 days will let you know
23:19:33 <tintin> wnoise: touchscreen is the one that manufactures those keyboards that look like wells ? and you move your fingers in all four directions ?
23:24:06 <wnoise> no, touchstream.  It's a giant touchpad with really nice software that as well as functioning like a normal keyboard also lets you map mouse-gesture type things to text, intelligently.
23:25:03 <wnoise> http://www.fingerworks.com/lp_product.html
23:27:35 <wnoise> Ooh, this is a weird layout:
23:27:37 <wnoise> http://www.fingerworks.com/images/layouts/stealth_QWERAK_printable.html
23:33:53 <mflux> if one randomized his keyboard layout at the beginning of every week, would he learn new keyboard layouts faster.. or not at all?-)
23:34:19 <Gahhh> why would he care about new keyboard layouts ?
23:37:13 <mflux> you mean why bother?
23:37:31 <mflux> no idea.
23:38:35 <mflux> in any case, the proper way to build a personal keyboard layout would be some statistic analysis on keystrokes (and sequences), and maybe some video about one tapping the keys..
23:38:44 <mflux> maybe with some specially colored fingernails ;)
23:45:49 <tintin> mflux: one guy did that
23:45:55 <tintin> and its easier than video
23:46:15 <tintin> alf* layout or somethnig
23:56:01 <wnoise> Dammit, talking about them pushed me over the edge and I've submitted an order for one.
23:57:37 <tintin> wnoise: which one ?
23:57:53 <tintin> fingerworks ?
23:58:33 <wnoise> Yup.  > $300, but another of my friends really loves his, and if I can reduce the force I use to type...
