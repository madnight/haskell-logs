00:00:16 <desrt> http://www.desrt.ca/ghc/11_ghc_stage_2.log
00:00:39 <desrt> <- bed
01:23:56 <danb_> any lhs2TeX users in?
01:24:07 <swiert> sure
01:24:45 <danb_> i'm having trouble with the poly formatting in 1.09 and 1.10_pre
01:25:13 <danb_> there is no padding above/below code blocks, but the rest of the modes (e.g. math, verb) include the padding
01:26:40 <danb_> i'm trying to identify the problem. i downloaded someone else's lhs tex code, and i got the same results, so i don't think my code is incorrect (someone else's code @ http://www.ittc.ku.edu/~alex/teaching/eecs762/files/p1-sol.tgz)
01:26:55 <swiert> I think that's the way it's supposed to behave.
01:27:12 <danb_> no vertical spacing between text and code blocks?
01:27:17 <swiert> You can always insert the padding yourself.
01:27:32 <swiert> Sometimes you want to have a single line of code, without padding.
01:27:35 <swiert> yes
01:27:42 <danb_> hmm...
01:27:55 <danb_> i usually use inline code for those purposes, i guess
01:28:06 <swiert> You can ask kosmikus, if he's around - he's the author of lhs2TeX.
01:28:09 <danb_> but the math and verb modes include the vertical spacing
01:28:15 <danb_> ah
01:28:30 <danb_> kosmikus: in? i have an lhs2TeX question
01:29:21 <danb_> i don't understand why the modes would be incosistent in that way...
01:31:24 <danb> (i feel bad for ghosting this other danb person all the time...)
01:31:41 <danb> swiert: which mode do you typically use?
01:31:47 <danb> swiert: (in lhs2TeX)
01:31:54 <swiert> danb: poly
01:32:18 <danb> swiert: doesn't the lack of veritcal spacing bother you?
01:33:14 <swiert> danb: I tend to put longer bits of code into floats. One liners shouldn't take too much room - so it doesn't really bother me.
01:33:41 <danb> interesting
01:33:46 <danb> swiert: is float an environment?
01:34:17 <swiert> no - \begin{figure}\begin{code} code \end{code}\end{figure}
01:34:26 <danb> ic
01:34:49 <danb> i guess it's nice to prevent page breaks in the middle of long code segments
01:37:31 <swiert> danb: exactly. plus you get all the nice numbering, layout etc.
01:46:07 <danb> hmm... i think i prefer to keep the code blocks inline
01:47:06 <danb> maybe i'll just stick with math mode
01:49:06 <Itkovian> meuning
03:45:21 <autrijus> @last shapr
03:45:22 <lambdabot> Sorry, I don't know the command "last", try "lambdabot: @listcommands"
03:45:27 <autrijus> @seen shapr
03:45:27 <lambdabot> shapr is in #haskell and #haskell.se.
04:03:03 <Forest> i am new to haskell (reading first tutorial) but i can not yet see when haskell is better than for instance java
04:03:07 <Forest> for what task
04:07:05 <Lemmih> Forest: Almost any task.
04:07:33 <Forest> )) rather general answer
04:08:29 <Forest> for example fibbonachi number calculation is much better to be done in java i guess
04:10:14 <autrijus> Forest: are you genuinely looking for examples?
04:10:44 <Forest> yes
04:11:33 <autrijus> ok... haskell is adept at manipulating complex structures.
04:11:40 <autrijus> for example, I wrote a working Perl6 interpreter in Haskell in a couple weeks :)
04:12:01 <autrijus> doing the required syntax tree matching and evaluation with objects and classes would be much more verbose
04:12:04 <autrijus> and much more error-prone.
04:12:39 <autrijus> also, writing parsers in haskell is 1)fun 2)fast 3)easy to maintain.
04:12:52 <autrijus> http://svn.openfoundry.org/pugs/src/Parser.hs # example
04:12:53 <Oeje1> autrijus: And you would propably use the *shiver* Visitor Design Pattern.
04:12:58 <autrijus> Oeje1: yes!
04:13:02 <autrijus> *shiver*
04:13:06 <Lemmih> Forest: http://www.md.chalmers.se/~rjmh/Papers/whyfp.html
04:13:20 <Forest> but i think of perfomance
04:13:25 <shapr> I didn't do it!
04:13:34 <shapr> Wait, what am I being blamed for?
04:13:37 <autrijus> Forest: haskell can compile to native, optimized assembly
04:13:49 <autrijus> Forest: or to C code to be optimized by your favourite C compiler.
04:14:06 <Forest> yes, but i mean algorithms
04:14:11 <autrijus> Forest: so it is generally very fast and with very small memory footprint, compared with virtual machines.
04:14:15 <Lemmih> eh?
04:14:43 <autrijus> Forest: the algorithm that provides fast code in haskell, when directly translated to Java, will indeed be horribly horribly slow.
04:14:53 <autrijus> Forest: but the haskell compiler magically makes them amazingly fast.
04:15:00 <autrijus> that's part of haskell's advantage.
04:15:39 <autrijus> shapr: how many words do you like my TMR article be?
04:15:46 <autrijus> shapr: I'm doing it in Catechism format
04:15:54 <autrijus> so I can cut at any size
04:16:03 <shapr> Catechism format?
04:16:10 <autrijus> Question-and-answers.
04:16:18 <shapr> I memorized a bunch of catechism in school... that was a long time ago.
04:16:32 <Forest> there is a vast compiler theory with very efficient algorithms, as i understand haskell compiler wouldn't use them, there will be some rexexps or smth
04:16:34 <autrijus> aka "little schemer" format.
04:16:47 <Forest> when building parsers
04:17:10 <autrijus> Forest: building parsers using regular expression, versus building parsers using eg. haskell Parsec, is like
04:17:22 <autrijus> building houses using toothpicks versus bricks.
04:17:46 <shapr> autrijus: I won't have any good ideas on article size till after the first issue. So far I tend to quote Lewis Carrol, "start the beginning, go to the end, then stop."
04:17:53 <autrijus> shapr: okay.
04:18:10 <autrijus> Forest: regex is simply not suited to write complex parsers.
04:18:17 <autrijus> (although in my previous life I forced them to.)
04:18:30 <shapr> Especially since regex backrefs only refer to a *match* not a *pattern*.
04:18:48 <autrijus> shapr: unless the match carries closures...
04:18:48 <Forest> ok, i thought haskell would use them
04:19:00 <autrijus> ...that's the base of magic I did with Template::Extract|Generate
04:19:17 * shapr tries to figure that out
04:19:32 <shapr> Do what? The match carries closures?
04:19:52 <autrijus> yeah
04:20:04 <shapr> Is that just to escape the fact that backrefs cannot refer to a pattern by themselves?
04:20:16 <Forest> ok, once again about Fib numbers, in any language it is not a problem to calculate, but in haskell it is not obvious to me how to do it
04:20:34 <autrijus> shapr: that, and to run guard code after and before matches
04:20:45 <shapr> Forest: Here's the slightly perverse version: fib = 0 : 1 : zipWith (+) fib (tail fib)
04:20:58 <autrijus> Forest: in haskell, fib is written thus:
04:21:00 <vincenz> shapr: hi
04:21:01 <shapr> autrijus: Wow, that's crazy and cool.
04:21:12 <autrijus> fib 0 = 0
04:21:15 <autrijus> fib 1 = 1
04:21:25 <autrijus> fib n = fib (n-1) + fib (n-2)
04:21:36 <autrijus> Forest: not exactly obscure, is it?
04:21:37 <Forest> autrijus: it is terribly slow
04:21:51 <autrijus> oh. you want fast?
04:22:01 <autrijus> fib n = flist!!(n+1) + flist!!n where flist = map fib [ 0.. ]
04:22:10 <autrijus> that gives you a very fast performance.
04:22:13 <shapr> heheh
04:22:20 <autrijus> (the first two case for 0 and 1 stays unmodifed)
04:22:20 <Forest> if n = 1000 it would take 100000..0000 years to calculate
04:22:34 <autrijus> Forest: right, but the flist!!n version takes linear time.
04:22:41 <autrijus> so, as fast as anything.
04:22:51 <autrijus> it's also not hard to read once you know that !! means index.
04:23:12 <shapr> Is SPJ still on vacation?
04:23:25 <Forest> ok, thanks
04:23:32 <Forest> will be reading tutorial on
04:24:11 <shapr> Forest: I think Haskell's greatest strength is in speed of creation and maintenance.
04:24:55 <autrijus> and in execution!
04:25:03 <Forest> ))
04:25:08 <autrijus> it's runtime speed is very, very fast. :)
04:25:14 <autrijus> (compared to VMs, not to C)
04:25:44 <shapr> True, the reason I see creation and maintenance speed as the greastest strength is because that's what I'm interested in most.
04:26:13 <autrijus> same here but my @clients care about execution speed :)
04:26:28 <shapr> It's functional! It's logical! It's imperative! And it's elegant and fast! There's something for every member of the family here on the HASKELL IRC CHANNEL!
04:26:37 * shapr starts the #haskell theme music
04:26:37 <autrijus> haskell is logical how? :)
04:26:43 <autrijus> I thought you need Curry for that
04:27:12 <shapr> Actually there's a fair chunk of Prolog in the type system. Someone wrote a nutty paper about implementing Prolog in the type signatures alone :-)
04:27:29 <Forest> is haskell used for commercial projects ? never heard of such examples
04:27:32 <shapr> Or maybe that a mailing list post... I don't remember.
04:27:32 <autrijus> that, is a hack :)
04:27:37 * shapr snickers
04:27:46 <shapr> Forest: I make money with Haskell.
04:27:50 <autrijus> same here.
04:27:55 <Lemmih> So do I! (:
04:28:00 <autrijus> so. :)
04:28:10 <shapr> Also, there are two companies in the USA that specialize in Haskell projects, Galois and Aetion.
04:28:16 <autrijus> Forest: but for large-scale projects used by commercial entities, try darcs.
04:28:32 <Forest> what is that.... darcs
04:28:45 <autrijus> it is a very neat version control system.
04:28:48 <shapr> David's Advanced Revision Control System
04:29:02 <autrijus> # http://abridgegame.org/darcs/
04:29:13 <shapr> autrijus: Hey, do you grok arrows?
04:29:22 <autrijus> shapr: conceptually yes, coding wise no.
04:29:32 <autrijus> shapr: the constraint set by monads is helpful to me.
04:29:40 <shapr> What do you think about an arrowized patch type for darcs?
04:29:40 <autrijus> shapr: I had not outgrown monads.
04:29:51 <autrijus> shapr: I think it'd be wonderful.
04:29:59 <shapr> ok
04:30:11 <autrijus> and I agree w/ your intuition. (we had this discussion before)
04:30:17 <shapr> Oh, cool.
04:30:43 <shapr> Too bad I can't remember this dicussion the last time we had it :-)
04:31:28 <shapr> Anyway, Catechism-style is fine with me.
04:31:43 <autrijus> Forest: there's no denial that a useful-in-real-world Haskell is a very new development, not more than a few year's time.
04:31:53 <shapr> Who made Pugs? Autrijus made Pugs. Who made Autrijus? ...
04:32:09 <shapr> Nobody made Autrijus, he is not a robot.
04:32:10 <autrijus> shapr: try think of some questions?
04:32:16 <autrijus> #perl6 had a list of questions.
04:32:19 <Forest> darcs is haskell-oriented & )
04:32:27 <Forest> *?
04:32:30 <autrijus> Forest: darcs is written in haskell.
04:33:01 <shapr> Is pugs' goal to be a fully fledged Perl6 interpreter/compiler?
04:33:03 <autrijus> shapr: for example, "isn't perl bloated, untyped, fragile, slow, obfuscated? why should I be interested in hacking its next version?"
04:33:27 <autrijus> shapr: that's a good one
04:33:40 <autrijus> I wonder if we should continue the question list here or move to #perl6 :)
04:33:46 <seidan> autrijus: um, your fast fib doesn't seem to work. Gets Killed after taking up all the memory. with -O it appears to sit in an infinite loop... am I missing something elementary
04:33:47 * shapr isn't picky
04:34:22 <autrijus> seidan: oops. the LHS is fib (n+2)
04:34:31 <autrijus> my brain filtered out n+k patterns.
04:34:32 <autrijus> sorry.
04:34:48 <Forest> 1 more issue, as i understood there is no specialized IDE for haskell, for example for java there are many wonderfull ones: Sun Studio, JBuilder, IDEA...
04:34:59 <autrijus> Forest: there is. Eclipse.
04:35:10 <autrijus> Forest: and Visual Studio's haskell mode is getting there.
04:35:14 <seidan> doh! I see I was missing something elementary...
04:35:33 <Forest> it there real time compilation ?
04:35:36 <autrijus> yes.
04:35:47 <autrijus> real time syntax checking, build system integration
04:35:49 <autrijus> you name it.
04:35:49 <Forest> auto-completion ?
04:35:57 <autrijus> context-sensitive word completion.
04:36:11 <Forest> that's nice
04:36:12 <autrijus> # http://eclipsefp.sourceforge.net/haskell/
04:36:24 <autrijus> and if you are into provable code, or automagic refactoring
04:36:30 <autrijus> then try Programmatica.
04:36:30 <shapr> autrijus: not very busy on #perl6
04:38:29 <seidan> autrijus: sorry again, but: Fail: temp.hs:1: Non-exhaustive patterns in function fib
04:38:54 <lou-tze> autrijus: context-sensitive word completion? in eclipsefp?
04:39:05 <lou-tze> autrijus: am i missing something?
04:39:17 <autrijus> lou-tze: yeah. what you're missing is the candidate word list is fixed :)
04:40:38 <autrijus> seidan: weird it worksforme
04:40:48 <autrijus> fib 0 = 1
04:40:49 <autrijus> fib 1 = 1
04:40:49 <autrijus> fib (n+2) = flist!!(n+1) + flist!!n
04:40:49 <autrijus>             where flist = map fib [ 0.. ]
04:40:57 <autrijus> that's the code I fed to ghc.
04:41:06 <lou-tze> autrijus: ahem...i am running it right now, and it doesn't do anything of the sort for me :)))
04:41:28 <autrijus> lou-tze: nothing happens when you hit ctrl-space?
04:41:36 <autrijus> it happens to me
04:42:36 <lou-tze> autrijus: could you give me a name you can atuo-complete?
04:43:03 <lou-tze> i tried fold*, and it did not come up with anything
04:43:18 <seidan> autrijus: my mistake. wow, that is fast.
04:43:23 <autrijus> seidan: =)
04:43:39 <autrijus> lou-tze: what if you hit ctrl-space in an empty space?
04:44:11 <lou-tze> ahhh...
04:44:42 <vincenz> hi shapr
04:44:51 <lou-tze> autrijus: fixed wordlist, eh...those i can complete in my mind ;)
04:45:01 <shapr> hoi vincenz
04:45:11 <autrijus> lou-tze: I merely repeat the haskellfp documentation :)
04:45:18 <autrijus> I didn't say it's Very Intelligent :)
04:45:24 <vincenz> shapr: I'm excited about the ICFP :)
04:45:25 <autrijus> # fib 0 = 1
04:45:25 <autrijus> fib 1 = 1
04:45:25 <autrijus> fib (n+2) = flist!!(n+1) + flist!!n
04:45:27 <lou-tze> autrijus: you have a point though...i hadn't come across this feature so far :)
04:45:27 <autrijus> err
04:45:32 <autrijus> # The Haskell source editor provides syntax coloring, Code Assist (context sensitive code completion), bracket matching and other helpful functionality to make coding in Haskell more convenient.
04:46:10 <shapr> vincenz: If you can get up to the point of being comfortable with using monad transformers by ICFP contest time, I'd be happy to have you on my team.
04:46:35 <autrijus> I'm comfortable with monad transformers!
04:47:18 <earthy> I'm not
04:47:34 <earthy> but that's due to theoretical drawbacks that monad coproducts have less of. :P
04:49:32 <vincenz> shapr: I learned scheme 2 weeks prior to icfp2003
04:49:44 <vincenz> shapr: either way I'm gonna organize my own team this year
04:49:51 <vincenz> I find myself naturally assuming leadership
04:49:59 <shapr> vincenz: http://icfpc.plt-scheme.org/ <-- see that? I'm betting on monad transformers or arrows.
04:50:01 <vincenz> (that's what happened last year and the year before)
04:50:11 <vincenz> shapr: based on?
04:50:30 <shapr> huh?
04:50:49 <Philippa> my copy of ATTaPL has just arrived
04:50:49 <vincenz> shapr: what makes you say that it's based on monad or arrow
04:51:17 <autrijus> the rapidly changing spec
04:51:22 <shapr> Noo, I mean that using monadT or arrowT will likely be the most flexible implementation.
04:51:36 <vincenz> shapr: a tool is a tool
04:51:41 * earthy would guess ag's.
04:51:45 <earthy> but that's just me
04:51:46 <shapr> Stop calling me a tool, that's not nice.
04:51:51 <vincenz> I'm not
04:51:54 * shapr grins
04:51:55 * vincenz rolls his eyes
04:52:00 <autrijus> ...
04:52:00 <vincenz> I think your statement is just.... dumb
04:52:05 * shapr rolls vincenz eyes also.
04:52:14 <vincenz> "a hammer is the best tool"
04:52:18 <autrijus> you rolled a 4, shapr.
04:52:28 * vincenz doesn't have glasses
04:52:30 <shapr> Wow, vincenz has more eyes than I thought.
04:52:58 <vincenz> shapr: any good gui libs for ocaml?
04:53:03 <shapr> vincenz: go read up on monad trasnformers and arrows and then come back and compare/contrast with other approaches.
04:53:18 <vincenz> shapr: how can you know if an approac is good if  you don't know what the problem is?
04:53:24 <shapr> I do not wish to convince you, I just say that this is my prediction.
04:53:37 <vincenz> So you're excited about this new thing you just learned calld "monad transformers"
04:53:41 * shapr sighs
04:54:02 <shapr> vincenz: feel free to argue via unit tests.
04:54:17 <earthy> um, cough
04:54:26 <earthy> monad transformers have their uses, as do arrows
04:54:26 * vincenz bypasses it all with a Coq proof
04:54:31 <earthy> they are not the be-all and end-all
04:54:35 <earthy> of modularity
04:54:35 <shapr> earthy: Truly, I agree.
04:55:12 <vincenz> it's just an implementation of the general idea of category theory
04:55:18 <autrijus> the be-all and end-all for modularity is obviously quantum membranes!
04:55:21 <shapr> I just said that I'm betting that monad transformers or arrows will be a good solution to the contest problem.
04:55:41 <shapr> When the problem shows up, it might be that something else is a better solution.
04:55:48 <earthy> and I'm betting you can do it as well with ag's. but, once again, that's just me and my languages-based background
04:55:56 <vincenz> shapr: I fail to see the reason for making your statement...
04:56:02 <vincenz> earthy: ag's?
04:56:10 <shapr> vincenz: ok
04:56:24 <earthy> attribute grammars
04:56:38 <vincenz> shapr: it's like me walking into a country saying "Hi...it looks nice here"  and they start hammering on me "catholicism is the answer to your problems"
04:57:12 <Oeje1> vincenz: You have problems?
04:57:23 <vincenz> sadly I do not :/
04:57:33 <vincenz> shapr: but be happy I have ghc now
04:57:46 * vincenz has irrsi in screen, ocaml in second window, ghci in third window
04:57:54 <vincenz> but haven't yet found a programming problem to try haskell with
04:58:02 <vincenz> and until I do hvae one I have no incentive to learn haskell
04:58:02 <shapr> vincenz: earlier you said that you might join the #haskell team if you couldn't get an OCaml team going on...
04:58:13 <vincenz> shapr: I'm gonna try to hvae an imec tema
04:58:18 <vincenz> shapr: but I might have to do it in haskell
04:58:19 <shapr> imec?
04:58:25 <vincenz> I said nothing about #haskell
04:58:31 <shapr> Ah, I see. Ok then.
04:58:33 <vincenz> www.imec.be
04:58:40 <shapr> Sorry, my mistake.
04:58:44 <vincenz> cause most of my colleagues with CS background know haskell not ocaml
04:59:00 <vincenz> though I'm by far the best coder
04:59:07 <vincenz> so maybe just me coding and the rest thinking
04:59:08 <shapr> and the most modest =)
04:59:15 <vincenz> shapr: I'm objective in my statement
04:59:30 <wilx> :)
04:59:30 <vincenz> and the data does not come from me it comes from others saying so
04:59:55 <vincenz> I'm reiterating experimental data ;)
05:00:05 <tromp> what date is this contest?
05:00:12 <shapr> hoi tromp
05:00:18 <tromp> hi shae
05:00:20 <vincenz> anyways...back to BOATs and OATs
05:00:39 <shapr> I was going to ask you something about Kolmogorov complexity, but I forgot what...
05:00:50 <shapr> Anyway, I really like your Lambda Calculus Playground.
05:01:02 <tromp> that makes 2 of us:P
05:01:04 * shapr grins
05:01:06 <vincenz> ??
05:01:11 <vincenz> where what?
05:01:49 <vincenz> tromp: cwi is in utrecht?
05:01:57 <tromp> no,amsterdam
05:02:00 <shapr> I should probably just get that Kolmogorov Complexity book and read it before asking questions.
05:02:01 <vincenz> oh
05:02:26 <tromp> there's also lots of info online
05:02:32 <tromp> like chaitin's books
05:02:43 <vincenz> shapr: anyways... I want to learn haskell...but I learn by doing and don't have a problem small enough to be feasible and large enough to be interesting to do in haskell
05:02:56 <earthy> tromp: june 24-27 + july 08-10
05:03:02 <shapr> Anything else you particularly recommend for learning about Kolmogorov Complexity? chaitin and ?
05:03:16 <shapr> vincenz: Ok.
05:03:24 <sorje> vincenz,you may try some of those http://acm.uva.es/p/v1
05:03:29 <vincenz> shapr: http://www.hutter1.de/kolmo.htm
05:03:35 <tromp> of course the Li+Vitanyi book is the most comprehensive
05:05:06 <shapr> Is there a collection of self-definitions somewhere? I know of Lisp, Joy, and your lambda cal page.
05:07:00 <tromp> http://root.cern.ch/root/Cint.html :)
05:07:26 <shapr> hm, good point.
05:07:43 <vincenz> what is "self-definition"?
05:07:55 <tromp> or http://eic.sourceforge.net/
05:08:55 <tromp> you know the brainf*ck ones, of course...
05:09:10 <tromp> an L interpreter written in L
05:09:28 <Philippa> metacircular interpreters and compilers, that sort of thing
05:10:32 <vincenz> oh!
05:10:53 <Philippa> aka excuses to lose important details like evaluation order :-P
05:11:07 <vincenz> evaluation order are not necessary
05:11:28 <vincenz> this is haskell...the language of lazy evaluation :D
05:11:39 <Philippa> which is itself an evaluation order
05:11:45 <vincenz> hmm
05:11:49 * shapr shoots an arrow at Philippa 
05:11:51 <vincenz> but non predictable
05:11:55 <Philippa> it would make something of a difference if your haskell-in-haskell were evaluated as if strict
05:12:26 <Philippa> but nevertheless one you can work through methodically - it's not like there's an RNG picking what to reduce next
05:12:33 * vincenz thinks that scheme/lisp cheat
05:12:36 <shapr> it's an arrow :: (Arrow a) => a Philippa b of course.
05:12:43 <vincenz> Philippa: I know...but the complexity runs high
05:12:56 <vincenz> shapr: CT!
05:13:06 <vincenz> I found that haskell maps very closely to ct
05:13:08 <shapr> Charisma Therapy?
05:13:12 <vincenz> category theory
05:13:18 <vincenz> the end all and be all of math :D
05:13:26 <vincenz> or so they claim
05:13:51 <vincenz> (they claimed the same about set theory until they came out with category theory, so go figure)
05:13:58 <shapr> I think of it as the mountain + telescope of Math. You can see my house from here!
05:14:27 <vincenz> yeah...but you can't open the door
05:14:39 <shapr> You may have a point there.
05:15:57 <shapr> Man I want to start a band. Category and the Functors.
05:16:10 <wilx> Hehe.
05:16:12 <wilx> Geeky.
05:16:20 <rjbs> Functor and the Categoricals would be more traditional, as far as band naming goes.
05:16:33 <shapr> Hm, good point.
05:16:44 <shapr> rjbs: btw, awesome hostname.
05:16:51 <rjbs> :)
05:17:06 <rjbs> There are a set of like-named machines sitting around me.
05:19:29 <vincenz> shapr: first cd "Natural Transformations" ?
05:21:41 <shapr> vincenz: good album title
05:22:03 <shapr> rjbs: alice, caterpillar, red queen, etc?
05:22:36 <b0gg1e> hit single: "Continuation-style, all night long" ?
05:22:42 <shapr> I'm using thunderbird.ScannedInAvian.org right now.
05:22:44 <shapr> b0gg1e: haha!
05:22:49 <vincenz> b0gg1e: lol
05:23:16 <rjbs> shapr: (dhcp).teaparty, {knaveofhearts,queenofhearts}.deck, cheshirecat, plumcake, redking, humptydumpty, whiterabbit, mockturtle
05:23:17 * vincenz coughs
05:23:18 * vincenz laughs
05:23:48 <rjbs> by fiat, there will be no alice
05:24:05 <vincenz> fiat might go bankrupt so no worries
05:24:30 <shapr> rjbs: why no alice?
05:25:01 <rjbs> Same reason my previous naming scheme (saints and martyrs) had no Jesus.
05:25:10 <rjbs> OK.
05:25:12 <vincenz> too central?
05:25:15 <rjbs> Yeah.
05:25:26 <rjbs> miswindowed OK
05:26:31 <shapr> I've been thinking of choosing the national birds of Scandinavia for ScannedInAvian hostnames, but that's only four birds...
05:27:11 <vincenz> which ones?
05:27:37 <rjbs> You could expand to neighboring countries.
05:28:49 <shapr> vincenz: eurasian blackbird, whooper swan, Dipper, mute swan
05:29:03 <vincenz> eurasian blackbird is scandinavian?
05:29:11 <vincenz> (not that I know which bird it is...but the name..)
05:29:33 <shapr> It's the national bird of sweden.
05:29:36 <vincenz> oh
06:04:20 <araujo> Good morning.
06:04:57 <shapr> y0 homey, wassup?
06:05:13 <araujo> shapr!
06:05:46 <araujo> I am fine yourself?
06:06:30 <shapr> Just fine, trying to figure out how to get the up and down scroll buttons on my logitech trackball to be recognized as separate buttons.
06:07:00 <araujo> no idea
06:08:18 <Itkovian> hmmm ... anybody used parsec?
06:08:37 <wilx> OT: Is there any decent Windows RSS feed reader?
06:09:00 <autrijus> Itkovian: yes, hm.
06:09:13 <autrijus> Itkovian: what do you want parsec to do for you?
06:19:42 <Itkovian> heh
06:20:05 <Itkovian> Well, I'm wondering if it could be used to parse exif data located in jpeg files from my digital cam.
06:20:26 <Itkovian> As I'm looking to use haskell for a nice little tool
06:21:25 <Philippa> quite possibly
06:21:26 <shapr> I'd like to have binary file format extensions to Parsec, if it can't already be used for such a thing. I've never tried using Parsec for file formats.
06:21:29 <Philippa> it's not limited to char
06:22:12 <Philippa> shapr: if you can feed it a big list of bits (which you should be able to do if you can feed it, say, [Word8]) the rest should drop out
06:22:44 <shapr> Philippa: lovely .sig
06:22:57 <Itkovian> heh, yeah.
06:22:59 <Philippa> it's a fairly old line, but yeah :-)
06:23:02 <Itkovian> hadn't noticed it.
06:23:15 * Philippa actually has a .sig rotation
06:23:22 <Philippa> I should shove a few more into it at some point
06:23:35 <shapr> Tomorrow it'll be rot13?
06:24:02 <Philippa> heh
06:24:18 <shapr> Btw, my investigations have led me to http://imwheel.sf.net/ and to Option "Buttons" "4" in XF86Config-4. Now to see if those make any difference.
06:24:18 <Philippa> actually, it's not really a rotation - it's random picks from all the .sig files in a given dir
06:26:36 <xerox> 'lo
06:40:11 <Igloo> juhp: Why did you decide to put hircules in Fedora Haskell? Was it just because it was easy or do people actually use it?
06:40:47 <juhp> or because I wrote it ;-P
06:41:06 <Igloo> Oh, sorry, didn't know that  :-)
06:41:34 <juhp> well it is trivial to package anyway...
06:41:43 <Igloo> So what's your excuse for not using it?  :-)
06:42:04 <juhp> no worries - unfortuntately I've been neglecting it too much recently... :-(
06:42:41 <juhp> yeah, so the lack of multi-server support and auto-reconnect to be honest
06:43:07 <juhp> I still prefer its "UI" to other clients though
06:43:35 <Igloo> *nod*
06:43:49 * juhp relunctantly confesses to be using xchat right now - after suffering gaim for a while...
06:44:25 <juhp> both of those are on the todo list along with colour highlighting and other stuff...
06:44:55 <juhp> also waiting to have gtk2hs working on x86_64 ;)
06:47:41 <juhp> though if that takes too long I may fallback to 32bit ghc :)
06:49:50 <juhp> duncan told me ffi needs some assembly instructions to pass variables on the stack to C functions for x86_64 iiuc
06:50:28 <juhp> s/ffi/ghc/
06:55:19 <sh10151> stupid book
06:55:43 <sh10151> "If multiple language support is so vital, why haven't alternative programming languages targeting the JVM enjoyed more popularity? It may be that there is really no reason to use another language, given the flexibility and ease of programming that the Java platform offers. "
06:55:44 <Itkovian> I'm off. ttyl
06:56:33 * juhp wonders why he didn't package hugs yet...
06:56:34 <Oeje1> sh10151: \o/ You cannot get your arms down.  :-)
06:57:26 * Oeje1 recalls he already packaged hugs for GoboLinux.  No sweat.
06:58:48 <juhp> ah, I think I remember - probably because of Hugs's funny version numbering scheme upstream
07:00:23 <juhp> actually I have packaged it in the past, just it is not in Fedora Haskell yet...
07:00:42 <juhp> ^I lie
07:02:28 * juhp drifts off to find sleep
07:10:16 * jlouis just read a bit about GADTs... nice nice concept
07:12:27 <jlouis> sh10151: Given JVM is hard to mangle into understanding other languages, I am not surprised.
07:12:59 <jlouis> The lack of proper support for tail-calls for instance...
07:15:33 <sh10151> support for proper tail calls?
07:19:50 <lightstep> rumor says that the call opcode in java always comsumes stack space, and there is no tail-call operator
07:20:01 <lightstep> s/com/con
07:20:30 <vincenz> woah
07:20:38 <vincenz> o.O
07:22:19 <CosmicRay> lightstep: C doesn't have one either, does it?
07:22:28 <CosmicRay> isn't it the same?
07:22:44 <mflux> but assembler does
07:22:52 <mflux> infact, it has everything ;)
07:23:05 <CosmicRay> sure, so someone could code to java bytecode assembler, right? :-)
07:23:05 <mflux> how many c-compilers for java have you seen?
07:23:11 <CosmicRay> heh
07:23:14 <lightstep> my mistake, i meant the jvm when i said java
07:23:32 <Oeje1> lightstep: I read a blog of someone who looked inside Hotspot: http://jroller.org/comments/slava/Weblog/the_hotspot_source_code_is
07:23:47 <Oeje1> I'm not shure how related that is to JVM, though.
07:24:13 <mflux> anyway, shouldn't it be possible to automatically transform code from tail-call-version into something else?
07:24:19 <mflux> ..might not be trivial or pretty, but..
07:27:13 <CosmicRay> mflux: yes, in fact, isn't that what has to be done when compiling haskell to C or asm anyway?
07:27:14 <lightstep> this requires either large methods with goto statement (the rumor says these aren't available in the jvm), or using trampolines (which should be fine, but then having an interpreter is as easy)
07:27:58 <mflux> cosmicray, well in assembler it's a bit simpler, because you can make a call without consuming stack
07:28:14 <mflux> but maybe it's done for C
07:29:11 <CosmicRay> mflux: I'd assume goto is how C would do it, I guess.
07:29:19 <CosmicRay> mflux: either that, or it is unrolled to a loop
07:29:31 <CosmicRay> hmm, it could be true that bytecode has no goto.
07:30:16 <mflux> goto in C wouldn't work for tail-returning from another function though?
07:30:39 <lightstep> actually, i gathered these rumors scattered in blogs in the last few years. i got the impression that there is some (not very long) limit on method size. i can't recall anything about gotos (so they probably have them)
07:30:41 <CosmicRay> mflux: I believe that longjmp could though
07:30:41 <mflux> I wonder how that would be translated infact
07:31:22 <mflux> cosmicray, hmm, but longjmp requires a longjmp-destination to be setup beforehand
07:32:35 <lightstep> gcc has some tail call elimination
07:34:50 * shapr attacks CosmicRay with a Faraday cage.
07:35:16 * CosmicRay hides his rf energy
07:35:24 <CosmicRay> storing it up for a massive counterattack
07:35:30 * xerox smacks his golden lambda from yesterday
07:35:38 <shapr> xerox: you've got the power!
07:35:41 <lightstep> heh, Slava Pestov asks how much is 8 + 80, to weed out bots. but the question is alyways the same
07:35:47 <xerox> \o/
07:35:51 <CosmicRay> shapr: I have an idea I'd like to run past you.  actually, maybe it was originally your idea, I'm not sure :-)
07:36:01 <shapr> Could be, run it ...
07:36:11 <shapr> lightstep: is that on the concatenative wiki?
07:36:43 <lightstep> it's on the link Oeje1 gave 13 minutes ago
07:36:53 <CosmicRay> shapr: I'm thinking of setting up a haskell news site.  sorta a cross between linuxtoday and kuro5hin.  small posts, mostly links to other sites... interesting stuff on -cafe, new stuff on the wiki, new releases, etc.
07:37:21 <shapr> lightstep: you know about Captcha?
07:37:28 <CosmicRay> shapr: I'm thinking that would be a nice compliment to TMR, not a competitor, but i'm interested in your take... i certainly don't want to sabotage tmr
07:37:47 <lightstep> shapr, no
07:37:54 <CosmicRay> lightstep: also, I'd think that a computer agent shoudl be fairly decent at math
07:38:00 <CosmicRay> lightstep: nice article on captcha at wikipedia
07:38:07 <shapr> http://c2.com/cgi-bin/wiki?CaptchaTest
07:38:53 <shapr> CosmicRay: Yeah, I like it. There are rumors that some company will sponsor a community.haskell.org box, it could do that sort of thing.
07:39:11 <shapr> But, if you just want to set something up and go, that'd be cool too.
07:39:12 <CosmicRay> shapr: maybe syntaxninja's employer?
07:39:25 <CosmicRay> shapr: I can get a drupal instance going in about 1-2 hours to do that.
07:39:46 <CosmicRay> shapr: complete with community moderation, blogspace for anyone, and rss syndication.
07:39:55 <shapr> rss syndication would be nifty.
07:40:26 <shapr> It would also be nice to record the ephemeral wisdom that scrolls past on #haskell
07:40:33 <CosmicRay> this is an example of what it can do: http://changelog.complete.org/aggregator
07:40:44 <CosmicRay> shapr: note the categories and sources links on the right hand side too
07:40:50 <CosmicRay> heh, yeah
07:41:57 <shapr> looks good to me.
07:42:18 <shapr> Maybe something vaguely like kuro5hin,slashdot,etc would work out.
07:42:25 <CosmicRay> shapr: yeah
07:42:28 <CosmicRay> shapr: exactly my idea
07:42:35 <desrt> i like how it classifies thereg as "technology commentary"
07:42:41 <CosmicRay> shapr: kuro5hin is community-moderated for everything
07:42:51 <CosmicRay> shapr: which is nice.  that means I don't have to do much with it :-)
07:42:54 <CosmicRay> shapr: drupal can do that to
07:43:03 <CosmicRay> desrt: <grin>  the categories are mine :-)
07:43:09 <shapr> I'm kind of surprised how little Haskell-related discussion shows up on lambda-the-ultimate. Much of it comes from me.
07:44:19 * Philippa reads #afp and wonders how many people in here've just lost the game
07:44:44 <lightstep> a year ago Frank Attansaw (bad spelling) wrote a lot about haskell, iirc
07:44:47 <xerox> What's afp?
07:45:14 <Philippa> xerox: alt.fan.pratchett - complete bunch of nutters, by and large
07:47:00 <shapr> what game?
07:48:02 <desrt> nobody ever posts to alt.fan.desrt :(
07:48:08 <CosmicRay> heh
07:48:15 <CosmicRay> only spam to alt.fan.cosmicray
07:48:30 <desrt> spam is -so- evil
07:48:36 <CosmicRay> fortunately there is no alt.cosmicray.die.die.die yet :-)
07:48:52 <CosmicRay> desrt: I agree.  I had to delete trackback spam from my blog this morning.
07:48:53 <CosmicRay> hate spam.
07:49:21 <desrt> heh.  i was reading about that on kuro5hin
07:49:33 <desrt> it had a really funny quote in the article
07:49:52 <desrt> "Another way is to use mod_rewrite to either give them a 403 Forbidden or redirect them back to their own site. The latter option might not be the wisest, unless you have a lot of bandwidth and want to escalate matters with the bad guys."
07:50:43 <Philippa> shapr: you are now playing the game. If you remember this, you lose the game.
07:51:19 <Philippa> (there's also a 30-minute period after doing so in which thinking about and mentioning it doesn't count as losing, so you can go infect others with what can only be described as a truly nasty meme :-)
07:51:57 <xerox> Fun fun fun
07:53:56 <b0gg1e> :-)
07:54:17 <shapr> Philippa: that's not a very hard game.
07:54:46 <lightstep> you only need to forget all about it to not lose
07:54:52 <shapr> It would take me real effort to lose.
07:54:58 <Philippa> or being reminded
07:55:06 <shapr> right, that too.
07:55:22 <Philippa> hence the line that started this conversation :-)
07:55:45 <xerox> Which line? I don't remember.
07:56:12 <Philippa> oh, just me wondering if anybody'd lost the game recently
07:56:48 * lightstep points at Philippa 
07:56:54 <lightstep> you lost
07:56:54 <lightstep> you lost
07:56:55 <lightstep> you lost
07:56:56 <jlouis> GADTs mmmm GADTs.... the only problem is I will have to use 1 day to eat through the paper
07:57:12 <Philippa> lightstep: I lost it on #afp, I have a 30 minute grace period :-)
07:57:15 <shapr> jlouis: might save you six or seven days later.
07:57:20 <Philippa> however, I do believe /you/ just lost in pointing that out
07:57:24 <jlouis> shapr: probably
07:57:56 <lightstep> it's only 13 minutes now
07:58:30 <lightstep> omg. it's that number again
08:22:29 <TheHunter> oh, ghci6.4 doesn't catch loops any more :(
08:22:48 <shapr> it doesn't?
08:23:21 <TheHunter> Prelude> let foo = foo
08:23:21 <TheHunter> Prelude> foo
08:23:21 <TheHunter> Interrupted.
08:23:28 <shapr> yow
08:23:38 <shapr> Did you send a mail to the ghc-users list?
08:23:52 <TheHunter> nah, i just discovered it.
08:24:50 <TheHunter> you think that counts as a bug?
08:25:13 <TheHunter> strangely, loops in compiled programs are discovered.
08:25:20 <TheHunter> s/discovered/detected/
08:25:40 <shapr> oh
08:25:44 <shapr> I don't know.
08:25:50 <shapr> If it's different, then it might.
08:26:14 <ikegami--> Hej
08:26:44 <shapr> konichiwa ikegami--san
08:26:45 <ikegami--> I found a small bug of haddock about index
08:27:25 <ikegami--> haddock does not create a link in the index for "lowercase" symbols
08:27:56 <ikegami--> (and I fix it)
08:28:25 <ikegami--> for example, look http://wxhaskell.sourceforge.net/doc/doc-index.html
08:28:44 <ikegami--> there is no "Y", but wxHaskell has a function "yellow"
08:29:48 <ikegami--> but it is easy to fix the problem: http://madscientist.jp/~ikegami/sources/haddock0.6.patch
08:29:55 <ikegami--> :)
08:30:40 <xerox> How was called that function returning his argument?
08:30:47 <xerox> const! nm.
08:33:24 <TheHunter> id?
08:34:22 <xerox> Oh, it was id.
08:36:46 <xerox> TheHunter, do you remember "map (head &&& length) . group" from yesterday?
08:36:55 <TheHunter> yes
08:37:03 * shapr bangs head on desk
08:37:11 <shapr> Lord deliver me from my clients.
08:37:21 <xerox> Can you tell me if it's possible to write an inverse function without "if" ?
08:37:28 <xerox> I want to find it myself, btw.
08:37:43 <xerox> But looking for a non-pointless exercise :)
08:39:51 <TheHunter> @type (=<<) (uncurry replicate)
08:39:56 <lambdabot> (=<<) (uncurry replicate) :: forall b. [(Int, b)] -> [b]
08:40:01 <xerox> yay.
08:40:57 <xerox> I came up with:
08:41:03 <xerox> ml (n,m) | m <= 0 = [] | m > 0 = n:(ml (n,m-1))
08:41:21 <xerox> g l = concatMap (ml) (f l)
08:41:36 <xerox> f = map (head &&& length) . group
08:42:20 <TheHunter> ml is uncurry replicate, concatMap is (=<<) :)
08:42:24 <xerox> replicate will do the job, I think. Thanks - I try :)
08:42:33 <xerox> uhu, let me try :D
08:44:46 <xerox> Great.
08:45:04 <xerox> What exactly is =<< ?
08:45:44 <TheHunter> "monadic function application", aka extend.
08:46:11 <xerox> >>= bind, =<< extend --how does they compare?
08:46:16 <tromp> flip
08:46:25 <TheHunter> (\x -> [x,x+1]) [1,2] ==> [1,2,2,3]
08:47:01 <TheHunter> err, (\x -> [x,x+1]) =<< [1,2] ==> [1,2,2,3]
08:47:02 <tromp> type error:(
08:47:40 <TheHunter> @type (=<<)
08:47:41 <lambdabot> (=<<) :: forall b m a. (Monad m) => (a -> m b) -> m a -> m b
08:47:44 <TheHunter> @type (>>=)
08:47:46 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
08:47:59 <TheHunter> as you see, the type of (=<<) is much nicer than that of (>>=)
08:48:07 <CosmicRay> shapr: hmm, what's a good name for this site I'm working on?
08:48:15 <xerox> TheHunter, "nicer"? :D
08:49:07 <TheHunter> sure, it says, "lift" a function from type (a -> m b) to type (m a -> m b).
08:50:44 <lightstep> @type join . fmap
08:50:45 <lambdabot> bzzt
08:50:55 <xerox> TheHunter, hmmmm..
08:51:06 <TheHunter> @type (join .) . fmap
08:51:07 <lightstep> @type (join . (fmap . ))
08:51:08 <lambdabot> bzzt
08:51:09 <lambdabot> bzzt
08:51:45 <basti_> hi all.
08:51:58 <basti_> shapr: ping?
08:52:21 <lightstep> @type Monad.join . (Monad.fmap . )
08:52:23 <lambdabot> Monad.join . (Monad.fmap . ) :: forall f a b.
08:52:23 <lambdabot> 				(Monad ((->) (f a)), Functor f) =>
08:52:23 <lambdabot> 				(f a -> a -> b) -> f a -> f b
08:52:31 <TheHunter> @pointless \f -> join . fmap f
08:52:32 <thbot> (=<<)
08:52:32 <lambdabot> Sorry, I don't know the command "pointless", try "lambdabot: @listcommands
08:53:01 <lightstep> @type (Monad.join .) . Monad.fmap
08:53:02 <lambdabot> (Monad.join .) . Monad.fmap :: forall a f a1.
08:53:02 <lambdabot> 			       (Monad f, Functor f) =>
08:53:02 <lambdabot> 			       (a1 -> f a) -> f a1 -> f a
08:54:47 <lightstep> CosmicRay, you can have it banal: cco/a
08:55:13 <CosmicRay> unfortunately, I don't get it :-)
08:56:34 <lightstep> changelog.complete.org/aggregator
08:56:44 <lightstep> or did you mean another site?
08:56:44 <CosmicRay> heh
08:56:49 <xerox> Hm, why I can't do (=<<) (+2) $ [1..10] ?
08:56:54 <CosmicRay> lightstep: I meant a name for a new Haskell news site
08:57:11 <CosmicRay> a community-driven site, community-moderated, community-edited, etc.
08:57:18 <TheHunter> (+2) is not a monadic function. You want (+2) `fmap` [1..10]
08:57:31 <xerox> What does define monadic function?
08:57:39 <lightstep> what's wrong with haskell.org/news ?
08:57:45 * boegel greets
08:57:47 <lightstep> or /community?
08:57:53 <xerox> hello boegel.
08:57:56 <CosmicRay> that would work, I suppose
08:57:57 <TheHunter> xerox, that's my name for a function of type a -> m b.
08:58:02 <TheHunter> ho boegel.
08:58:06 <CosmicRay> I was hoping for something clever
08:58:19 <CosmicRay> "Haskell Community" sounds boring compared to "The Monad Reader"
08:58:26 <xerox> TheHunter, so replicate is a monadic function because returns a list?
08:58:33 <xerox> TheHunter, because lists are monads, right?
08:58:40 <lightstep> the cover should be clever only when the book isn't
08:59:01 <TheHunter> xerox, yep.
08:59:09 <lightstep> or you can have a cute abbreviation, like HasComm
08:59:10 <xerox> TheHunter, good.
08:59:39 <xerox> So: (=<<) ((+2) >>> (:[])) $ [1..10]
08:59:40 <xerox> ?
08:59:44 <tromp> replicate i is monadic
09:00:07 <tromp> replicate by itself is not
09:00:25 <xerox> tromp, I see.
09:02:06 <Cale> depending on the way that you define "monadic" :)
09:04:22 <TheHunter> according to my definition, replicate is. But the terminology isn't standard. You might also call such functions effectful.
09:05:00 <xerox> @type replicate
09:05:01 <lambdabot> replicate :: forall a. Int -> a -> [a]
09:05:06 <xerox> @type replicate 1
09:05:07 <lambdabot> replicate 1 :: forall a. a -> [a]
09:05:31 <xerox> I think he refers to the type, now it matches exactly a -> m b
09:06:26 <Cale> on the other hand, effectful seems like a misnomer here :)
09:06:27 <TheHunter> oh, sorry replicate is a binary function. But I call such functions "monadic", too.
09:07:28 <xerox> TheHunter, where can I find other useful things like (=<<) ?
09:07:44 <TheHunter> i think it's ok to call nondetermistic stuff effects.
09:08:13 <TheHunter> in the prelude and Control.Monad. For example
09:08:16 <TheHunter> @type ap
09:08:18 <lambdabot> bzzt
09:08:22 <TheHunter> @type Control.Monad.ap
09:08:24 <lambdabot> Control.Monad.ap :: forall b m a.
09:08:24 <lambdabot> 		    (Monad m) =>
09:08:24 <lambdabot> 		    m (a -> b) -> m a -> m b
09:10:16 <TheHunter> so [(+2),(*2)] `ap` [1,2] ==> [1,3,2,4]
09:10:47 <TheHunter> well, actually [3,4,2,4]...
09:11:17 <xerox> Interesting, I can't see how :)
09:12:31 <Cale> xerox: by applying each function to every element of the list
09:13:05 <Cale> xerox: the list monad models nondeterminism -- that is, computations which may have multiple results.
09:13:13 <xerox> It's really nice.
09:13:23 <lightstep> @eval [id] `Control.Monad.ap` [1, 2]
09:13:24 <lambdabot> (line 1, column 14):
09:13:24 <lambdabot> unexpected "."
09:13:24 <lambdabot> expecting letter or digit or "`"
09:13:26 <xerox> brb.
09:13:29 <lightstep> @eval [id] `ap` [1, 2]
09:13:30 <lambdabot> unbound variable: ap
09:13:37 <lightstep> @eval Control.Monad.ap [id] [1, 2]
09:13:38 <lambdabot> <<EM Dynamic -> EM Dynamic>>
09:13:38 <Cale> eval doesn't evaluate haskell code
09:13:45 <Cale> or does it?
09:14:00 <lightstep> it knows some of the functions
09:14:24 <shapr> Nah, Eval is a lambda calculus interpreter
09:14:44 <shapr> Haskell is very close to typed LC, that's why it's confusing.
09:15:35 <basti_> shapr: !
09:15:52 <lightstep> TheHunter, [(+2), (*2)] `ap` [1,2,3,4] would be [3,4,5,6,2,4,6,8], since bind is like a cartesian product
09:15:55 <basti_> greetings
09:17:50 <TheHunter> the "evaluation order" of ap seems a little bit weird to me.
09:18:49 <lightstep> swing would probably do something very cool the the evaluation order
09:18:58 <lightstep> s/the/to/
09:20:19 <basti_> hehe
09:20:20 <basti_> oops
09:21:50 <Cale> swing ap :: forall a a1 b. (Monad ((->) (a -> a1 -> b))) => ((a -> a1 -> b) -> a1) -> a -> (a -> a1 -> b) -> b
09:21:53 <shapr> hiya basti_
09:22:14 <shapr> Cale: swing is way cool.
09:22:41 <Cale> heh, it's a little surprising that it doesn't cause more explicit type errors :)
09:22:56 <CosmicRay> shapr: what do you think of "show . haskell" as the name for a news site?
09:23:00 <TheHunter> swing ap :: forall a a1 b.
09:23:00 <TheHunter>             ((a -> a1 -> b) -> a1) -> a -> (a -> a1 -> b) -> b
09:23:03 <CosmicRay> shapr: I'm having trouble coming up with good ones
09:23:06 <shapr> I've been thinking that the Prelude is a collection of traversal essences, and I thought before that all the essences were already found. Swing has convinced me otherwise.
09:23:15 <shapr> CosmicRay: call it the thunk
09:23:39 <CosmicRay> hmm... that could work :-)
09:23:41 * shapr brainstorms up some good names
09:23:50 <shapr> The Thunk, Call by Url
09:24:06 <shapr> or um wait...
09:24:20 <CosmicRay> mapM Haskell? :-)
09:24:28 <shapr> What's the trick to pull stuff out of an IO monad unsafely?
09:24:36 <CosmicRay> unsafePerformIO?
09:24:55 <shapr> When I first learned monads I dreamed I restructured my brain in monadic form, and used unsafePerformIO to see five seconds into the future.
09:25:02 <CosmicRay> heh
09:25:17 <shapr> I wonder if you capture that sort of seeing into the future idea in a tiny bit of code.
09:25:31 <unsafeCoerce> freenode ate the # :(
09:26:46 <shapr> CosmicRay: news sites are somewhat like seeing into the future.
09:26:56 <CosmicRay> shapr: hmm, I'm having trouble making something out of that...
09:27:30 * shapr thinks
09:28:39 <shapr> Well, I sent an email to SPJ asking him if he had time to write "The Silk Shirt Prospective"
09:28:47 <shapr> if he's not interested, that would be a cute name.
09:29:05 <CosmicRay> hmm.
09:29:13 <lightstep> runState . delay (-5)   in arrows
09:29:21 <CosmicRay> maybe I'll just use thunk.
09:29:22 <shapr> It implies that you're covering the next fifteen years of Haskell.
09:29:28 <CosmicRay> heh
09:29:34 <Cale> swing zipWith :: forall a b c. [a -> b -> c] -> a -> [b] -> [c]
09:29:48 <CosmicRay> shapr; maybe I could make the first thing a "name this site" contest :-)
09:29:54 <shapr> good idea!
09:32:31 <Igloo> Î»Î½Î½ (gettit?)
09:33:08 <Igloo> (I suspect not if your client renders nu as dull as mine)
09:33:21 <rtega> not ;)
09:33:43 <Igloo> lambda nu's (news)!
09:33:59 <basti_> "nu" is not pronounced like that though :P
09:34:24 <Igloo> How do you pronounce it?
09:34:41 <basti_> english doesnt make that sound, so its hard to type
09:34:51 <basti_> somewhat like "ü"
09:35:11 <basti_> the classical greek tradition wants it a little more closed though
09:35:55 <Igloo> I either say noo or n-yoo, I can't work out which now. But appending an s gives you the same sound as "news" in different dialects
09:36:07 <basti_> mh
09:37:17 <basti_> its funny for english speaking persons prolly
09:38:44 <lightstep> perhaps the least fixed point?
09:39:23 <Cale> swing find :: forall a. [a -> Bool] -> a -> Maybe (a -> Bool) -- takes the list of predicates and Just the first one which returns true for the given value is returned or Nothing, if none of them hold.
09:40:07 <Igloo> I think http://dictionary.oed.com/cgi/display/00327904?keytype=ref&ijkey=opzgmBrC7ciVs agrees with me, but my knowledge of the phoenetic alphabet isn't great  :-)
09:48:45 <xerox> @type swing
09:48:46 <lambdabot> bzzt
09:49:14 <xerox> What is it?
09:50:02 <lightstep> is swings list functions
09:50:47 <lightstep> @wiki LicensedPreludeExts
09:50:48 <lambdabot> http://www.haskell.org/hawiki/LicensedPreludeExts
09:55:30 <Cale> swing fmap :: forall f a b. (Functor f) => f (a -> b) -> a -> f b
09:55:53 <Cale> (lists need not be involved, but they help)
09:56:35 <xerox> Hmm I envy you - how can you guess everything by the type?
09:58:00 <Cale> things with generic enough type can only do one thing
09:58:09 <Cale> (or one sensible thing)
09:58:27 <Cale> but I could add some commentary :)
09:59:55 * Philippa wonders how many useful functions there are of type (a->b) -> [a] -> [b], for comparison
10:00:17 <xerox> Philippa, map?
10:00:56 <Philippa> yeah. I guess you could also count reverse map, map.filter with the filter provided already, stuff like that
10:01:06 <Philippa> but those don't make sense as library primitives
10:01:31 <xerox> I should also get the definition of "Functor"
10:01:33 <basti_> permutations?
10:01:51 <unsafeCoerce> all such functions are \f -> map f . foo where foo :: [a] -> [a], I believe.
10:02:16 <Cale> other way around
10:02:29 <Cale> \f -> foo . map f
10:02:32 <unsafeCoerce> doesn't matter, does it?
10:02:57 <Cale> I suppose it doesn't :)
10:03:15 <xerox> Hmmm
10:03:16 <unsafeCoerce> i would think that this is exactly the free theorem for those functions.
10:03:18 * esap tries ":t swing swing swing" and gets strange results :-)
10:03:22 <xerox> Function that operates on lists?
10:03:31 <Cale> I suppose there are no interesting functions of type (a -> b) -> (a -> b)
10:04:34 <Philippa> I wouldn't have thought there are
10:04:46 <esap> I would think function application would be interesting.
10:04:54 <Philippa> I mean, if you know something about the a, you can twiddle it beforehand
10:05:13 <Philippa> function application doesn't have that type though
10:05:27 <esap> ($) :: forall b a. (a -> b) -> a -> b
10:05:42 <Cale> that's just id
10:06:07 <esap> yes, but it's also function application.
10:06:08 <Philippa> actually wait, fair play, was mis-parenthesising
10:06:24 <Philippa> okay, let's rephrase - any non-identity functions?
10:06:39 <Cale> yes, I said "interesting" after all :)
10:06:45 <Philippa> if you have a more specialised, you can twiddle it on the way in - but the only function in a -> a is id
10:06:59 <Cale> right
10:08:45 <Philippa> and I just wasted five seconds proving to myself that this result generalises to n-parm funcs :-)
10:08:54 <Cale> :)
10:09:13 <Cale> so the only thing we can do to map is to compose with a function that acts purely on the list structure
10:09:37 <Cale> (if we want to maintain the type signature)
10:11:42 <basti_> back from phone
10:12:22 * CosmicRay announces the new haskell news site: http://sequence.complete.org/
10:13:01 * CosmicRay solicits submissions :-)
10:13:52 <Igloo> I still like mine, but it might lack international appeal and renderability for legacy people
10:14:42 <Philippa> what was yours?
10:15:44 <Igloo> Î»Î½Î½ (== lambda news)
10:16:16 <Philippa> doesn't show properly here, but yeah, fair enough
10:16:49 * Igloo stamps "legacy" on Philippa's forehead
10:16:55 <lightstep> it'd be more portable with unicode anyway (i don't even know which iso8859 contains greek)
10:17:16 <Igloo> That is unicode (utf8)
10:17:31 <Cale> How about "The Haskell foldr (liftM2 (:)) (return [])"
10:17:52 <lightstep> so i must have fucked up my terminal
10:18:15 <basti_> i noticed that utf8 just about never works.
10:18:39 <lightstep> you're probably not using enough debian
10:18:57 <basti_> what's missing then?
10:19:16 <lightstep> uxterm
10:19:19 <basti_> i found that using utf8 f---s up my ability to type german special characters
10:19:50 <lightstep> i use hebrew, which is supposedly more complicated, and it Just Works
10:20:06 <basti_> where do i find uxterm?
10:20:59 <basti_> i dont in my apt package list.
10:21:13 <Igloo> It's in the xterm package
10:21:17 <basti_> oh
10:22:05 <lightstep> this and a good setting of XkbOptions did it for me
10:22:36 <basti_> it requires locale de_DE.UTF-8... according to my understanding i would have to tell locale-gen to generate this for me wouldnt i?
10:22:51 <lightstep> you should reconfigure locale (or locales, i'm not sure)
10:23:16 <basti_> locales
10:23:41 <basti_> its doing something
10:23:48 <metaperl_> is the sequencing operator >> or >>=
10:23:51 <basti_> uxterm shows up
10:24:00 <basti_> but still has the same problem as everytime
10:24:08 <metaperl_> "Gentle" starts by saying it is >>= and then later discusses it as >>
10:24:18 <basti_> i can type äöü, but when i delete, i can delete 2 characters for every special character i type
10:24:26 <basti_> seems to be somewhat utf8 related =)
10:24:40 <Cale> metaperl_: >> is the same as >>= except that it ignores the result of the computation on its left.
10:25:06 <metaperl_> Cafe, tahnks
10:25:28 <Cale> (also has a bit of a different type because of this)
10:26:30 <esap> hmm.. uxterm doesn't seem to handle man pages correctlyl, I get garbage on man pages [I tried "man unicode" :-)]
10:27:04 <basti_> ive tried a lot. all utf8 terminal stuff i tried seems completely broken to me.
10:27:38 <metaperl_> yes, I now understand why in "Gentle" he switched to it. He took a list of IO actions and executed them all via sequence_ = foldr(>>) (return ()_
10:27:47 <basti_> its OT anyway =)
10:27:59 <metaperl_> but wait: ... he did not supply the list of IO actions to the sequence function...
10:28:24 <metaperl_> oh, then I think he must've curried foldr to define sequence_
10:28:36 <metaperl_> sequence_        :: [IO ()] -> IO ()
10:28:36 <metaperl_> sequence_        =  foldr (>>) (return ())
10:28:49 <Cale> that's right
10:28:50 <metaperl_> is that right? is that a case of currying foldr()? I thnk so
10:28:53 <lightstep> metaperl_, the real type is more general
10:29:26 <metaperl_> aha. I'm buying the Algorithms book on the recommended book list. I think that will be good but I'll keep hitting "Gentle" for now.
10:30:05 <metaperl_> my feeling is that Perl6 is a messy confusion of Haskell and Ruby. I hope to learn enough Haskell to get into a good graduate school or perhaps a Haskell consulting company... maybe participate in ICFP also
10:30:08 <Sukh> Does anyone know what function/operator I might need to use to concatenate the components of a list? e.g. [1,2,3] to 123
10:30:27 <metaperl_> foldr to the rescue Sukh!
10:30:42 <metaperl_> do you want to make a number or a string out of the list?
10:30:51 <lightstep> Sukh, you might be interested in show
10:30:56 <basti__> hmmm
10:30:58 <basti__> äöüµµµ
10:31:07 <basti_> does not seem utf 8.
10:31:11 <metaperl_> Sukh are you turning the list of numbers into a number or a string?
10:31:39 <basti_> could anyone type some utf8 chars?
10:31:42 <Cale> Sukh: look at concat
10:32:24 <metaperl_> I have a question... what if someone designed a function to take 3 arguments and you want to provide the last 2 arguments positionally and have the first argument as the one to be bound in the curried function?
10:32:25 <Cale> (and show, perhaps)
10:32:46 <basti__> lol utf8 shock -g-
10:32:47 <metaperl_> he never specified if he was creating a number of string from the list
10:32:53 <Cale> (\x -> f x 2 3)
10:33:07 <metaperl_> beautiful :)
10:33:15 <lightstep> basti__, does you font choke on this: ×©××× ×¢××××?
10:33:20 <basti__> the font doesnt
10:33:29 <basti__> the chat client does probably.
10:33:43 * esap gets just boxes, no contents.
10:33:51 <Sukh> concat only turns lists of lists into one list
10:33:55 <lightstep> nine boxes, one space in the middle?
10:33:55 * Cale gets hebrew characters
10:34:02 <Sukh> [[1],[1,2]] = [1,1,2]
10:34:03 <Sukh> ?
10:34:09 <Cale> Sukh: strings are lists of characters
10:34:17 * esap nods to lightstep.
10:34:20 <Sukh> i'm not doing it to a string
10:34:28 <Sukh> need to do it from [1,2,3] to Int 123
10:34:42 <basti__> äöü
10:34:45 <lightstep> basti__, will you write lambda-nu-s again please?
10:34:46 <Cale> read . concat . map show
10:34:48 <Cale> ?
10:34:52 <basti__> µµ
10:34:59 <Sukh> ?
10:34:59 <basti__> im still going latin-1
10:35:00 <lightstep> damn
10:35:08 <basti__> no utf 8 so far
10:35:24 <Cale> Sukh: check if that does what you want?
10:35:48 <basti__> hmm xresources manipulation
10:36:05 <Cale> (It's a little bit cheesy I'll admit)
10:36:16 <Cale> you could also just do a straight fold
10:37:06 <lightstep> foldl1, that is
10:37:11 <Cale> foldl (\x y -> 10 * x + y) 0
10:37:28 <basti__> ÂµÃ¤Ã¶Ã¼
10:37:38 <basti__> better.
10:38:12 <xerox> Finally... back!
10:38:31 <Igloo> lightstep: If that should say shalom tsolumy or something then my client shows the right letters but left-to-right
10:38:49 <Cale> Sukh: Is that what you're looking for?
10:39:49 <Cale> (that builds a number from digits)
10:40:00 <lightstep> Igloo, mine too. bidi is not common yet
10:40:56 <lightstep> foldl1 $ (+) . (10*)
10:41:10 <lightstep> pointless
10:42:28 <shapr> Heh, who voted for CosmicNeal on http://sequence.complete.org/queue/12 ?
10:42:31 <Cale> foldl (\x y -> 10^(ceiling (log (fromIntegral y) / log 10)) * x + y) 0
10:43:08 <Cale> apply it to [4217,34,37] and get 42173437
10:43:26 <Cale> obviously rather base-10 specific :)
10:44:01 <lightstep> @type iterate
10:44:03 <lambdabot> iterate :: forall a. (a -> a) -> a -> [a]
10:44:07 <xerox> Which base do "log" uses ?
10:44:13 <lightstep> shapr, i get Access denied
10:44:26 <Cale> xerox: base e of course
10:44:33 <Cale> :)
10:44:43 <shapr> lightstep: oh, maybe it's only for people who have created an account.
10:45:17 <xerox> Cale, whoops :)
10:46:08 <basti__> Ã¤Ã¶Ã¼
10:46:14 <basti__> done
10:46:17 <basti__> thanks for the hints
10:47:39 <basti_> now, can anyone try a few wacko chars? =)
10:48:40 <lightstep> foldl1 (\x y -> fromJust (find (>y) (iterate (10*) x)) * x + y)
10:49:19 <Cale> heheh
10:49:26 <lightstep> it's exact
10:49:34 <Cale> yes, and the fromJust is safe
10:50:00 <xerox> Is there something like http://www.haskell.org/hawiki/LicensedPreludeExts for the things that page is based on? (Like Functors, fmap, and so on)
10:50:04 <lightstep> it can be more efficient, with a smart `find'
10:50:20 <Cale> xerox: you mean the Prelude?
10:50:29 <Cale> http://www.haskell.org/onlinereport/standard-prelude.html
10:50:30 <basti_> Åech WaÅensa
10:50:31 <xerox> Cale, probably.. :)
10:50:35 <shapr> basti_: whoa cool
10:50:42 <shapr> what is that character?
10:50:44 <basti_> BjÃ¸rk GuÃ°mundsdottir
10:50:49 <xerox> Sorry for asking obvious questions from time to time.
10:50:52 <basti_> thats the polish "struck l"
10:50:56 <shapr> neato
10:51:04 <xerox> Yay, I see that struck l!
10:51:06 <basti_> you just cant read it?
10:51:08 <basti_> -g-
10:51:23 <Cale> Åos' Theorem :)
10:51:25 * esap can also see that :-)
10:51:29 <basti_> Â· dot
10:51:36 <basti_> Ã sz ligatur.
10:51:39 <xerox> I mean, I can't see what's between Bj and rk and so on.. :)
10:52:11 <basti_> Â¨ standalone diaresis (wtf?)
10:52:26 * basti_ needs a compose key
10:52:34 * Igloo reads sequence and wiggles shapr's mouse
10:52:38 <shapr> wha?
10:52:44 <shapr> wiggle my mouse?
10:52:53 <basti_> force feedback mouse would be nice
10:52:53 <Cale> or rather ÅoÅ' Theorem
10:53:02 <Igloo> Giving your entropy gatherer some bits  :-)
10:53:08 <shapr> haha
10:53:08 <basti_> Cale: i dont have that character now ;)
10:53:38 <Igloo> basti_: It'll be primarily for composing with other characters I assume
10:53:43 <basti_> force feedback optical mouse would be even cooler. with light recoil amplifier.
10:53:56 <basti_> Igloo: probably.
10:54:16 <basti_> i think utf8 is a nice idea for the transition phase.
10:54:25 <metaperl_> bpalmer, hi I didn't know you were into haskell... is that what you do at nmsu?
10:56:30 <Cale> basti_: you don't have U+015B: It's an s with an acute accent over it.
10:57:34 <Cale> ÄÄ¿ÅÅ³
10:57:52 <basti_> Cale: well obviously i don't, but I'm happy that now there is an empty spot in my character set that i could retrofit it into if my life ever depended on it
10:58:03 <Cale> Æ§Æ¨
10:58:03 <shapr> what was that? wacky dotted L?
10:58:13 <shapr> bpalmer: greetings, and welcome to Haskell.
10:58:30 <Cale> Latin Capital Letter L with Middle Dot
10:58:36 <shapr> neato
10:59:01 * basti_ would love to have IPA characters available.
10:59:09 <Cale> there was also e with ogonek, letter eng, and u ogonek there.
10:59:13 <Philippa> as opposed to stout characters?
10:59:29 <basti_> uhm
10:59:34 * basti_ didnt get that one
10:59:38 <Cale> and then some reversed Ss
11:00:22 <Igloo> I was most disappointed there wasn't a reversed B I could correctly reference my ABBA CD with
11:00:30 <basti_> awwwwww :P
11:00:46 <basti_> maybe you can have it introduced in the far end of unicode =)
11:01:08 <basti_> near 0x95830000 or something ;)
11:01:21 * Igloo clears out some German characters to make room  :-P
11:01:27 <Cale> Ô±Ô²Ô³Ô´ÔµÔ¶Ô·Ô¸Ô¹ÔºÔ»Ô¼Ô½Ô¾Ô¿ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
11:01:29 <shapr> yow
11:01:33 <basti_> Cale: not a single hit
11:01:38 <basti_> -g-
11:01:39 <Cale> Armenian
11:01:49 <shapr> hiya _timor
11:02:13 <Cale> (I have fairly good unicode coverage)
11:02:38 <basti_> well i have either an ergonomic font, or good unicode coverage
11:03:14 <shapr> Isn't a dyne a centimeter an erg?
11:03:17 <Cale> av â w = v â aw = a(v â w)
11:03:31 <xerox> Square? :)
11:03:38 <Cale> Tensor product
11:05:12 <Cale> âu/âx = âv/ây, âu/ây = -âv/âx
11:05:23 <Cale> (partial differential)
11:05:52 <wli> Cauchy-Riemann?
11:05:52 <basti_> oh i can see that
11:05:53 <shapr> neat
11:06:11 <Cale>  âââââââ
11:06:20 <Cale> shaded blocks :)
11:06:40 <shapr> wow
11:06:44 * CosmicRay returns
11:06:45 <Cale> â_â
11:06:51 <Cale> heh
11:06:52 <shapr> best smiley I've seen yet.
11:08:17 <xerox> Every time I read the Prelude I find something new / interesting.
11:08:37 <wilx> Hmm, I am tying to build Cabal.
11:08:39 <shapr> Yeah, it worth reading regularly.
11:08:40 <wilx> I get dist/tmp/Distribution/Simple/Configure.o(.text+0x7781):fake: undefined reference
11:08:41 <wilx>  to `SHGetFolderPath@20'
11:08:45 <basti_> hmm
11:08:49 * basti_ changing fonts
11:08:53 <wilx> How can I link it with shell32.dll?
11:09:04 <wilx> Appending -lshell32 doesn't seem to be enough.
11:09:10 <xerox> shapr, I think they change it every other week, or something like that <grin>
11:09:25 <basti_> hm
11:09:30 <basti_> i seem to have more chars now
11:09:47 <basti_> i did not say they are in the correct place of the kb.
11:10:01 <Cale> Hey! I seem to have fewer! Give those back!
11:10:08 <basti_> Ã¶Ã¤Ã¼!
11:10:16 <Cale> heheh
11:10:17 <basti_> cyrillic
11:10:33 <Cale> those didn't appear as cyrillic to me
11:11:11 <Cale> ÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯
11:11:48 <basti_> hm
11:11:50 <basti_> great
11:11:54 <basti_> did you see umlauts?
11:11:58 <Cale> yeah
11:12:04 <basti_> -.-
11:12:08 <Cale> â
11:12:17 <Cale> that might be hard to see :)
11:12:20 <basti_> i did not see anything.
11:12:25 <Cale> (It's a snowman)
11:12:47 <Cale> â¢â£â  Danger!
11:12:51 <Cale> heheh
11:13:01 <Cale> so many characters :)
11:14:17 <Cale> awww... I lack coverage of Linear B
11:14:33 <basti_> omg!
11:15:46 <basti_> classical chinese would be great for tao te king discussions
11:15:57 <basti_> if you spoke chinese that is.
11:17:30 <esap> Â«ÅÅÂ» Hmm...
11:17:38 <CosmicRay> there shapr, I got your poll posted finally
11:17:40 <shapr> yay
11:17:54 * esap can now type some unicode chars.
11:18:07 <basti_> that font looks nice but its stupid that it has cyrillic where other people have umlauts
11:18:09 <shapr> CosmicRay: did you vote for CosmicNeal?
11:18:14 <CosmicRay> shapr: are you planning to distribute TMR as a PDF?
11:18:22 <shapr> That was the original idea, yes.
11:18:25 <CosmicRay> shapr: yes.  also ghc (with a test account)
11:18:30 <CosmicRay> shapr: sounds good
11:18:31 <shapr> Though I'm having serious doubts.
11:18:38 <CosmicRay> shapr: maybe also html via latex2html or some such?
11:18:46 <CosmicRay> so people can link to specific articles?
11:19:13 <CosmicRay> how many pages would you PDF turn out to be, using what you hve right now?
11:19:14 <shapr> At the moment I'm thinking about suddenly going back to wiki publishing. LaTeX looks gorgeous, but is very hard to do distributed edits with.
11:19:29 <CosmicRay> shapr: you may be itnerested in Drupal's book feature
11:19:32 <basti_> hehe
11:19:35 <basti_> indeed
11:19:53 <shapr> hiya elk
11:20:09 <CosmicRay> shapr: examples at http://www.railpassenger.org/book or http://drupal.org/node/6261
11:20:26 <CosmicRay> shapr: it's sorta like a wiki that enforces hierarchical categorization
11:20:40 <CosmicRay> shapr: also there can be comments attached to each page
11:20:58 <shapr> that would be interesting.
11:21:43 <shapr> The reason I favor Moin, or maybe Flippi, is that I can hack both of those, and I'd rather not hack PHP.
11:22:01 * CosmicRay can understand that desire
11:22:08 <CosmicRay> what are moin or flippi written in?
11:22:09 <shapr> Sort of like not liking tomatoes on my burgers...
11:22:14 <shapr> moin is python, flippi is Haskell.
11:22:18 <CosmicRay> ah
11:22:23 <Cale> whee
11:22:43 <CosmicRay> shapr: you probably are already aware of whether or not plone would make a good choice
11:22:49 <Cale> now I have all of linear B and a bunch of other Plane 1 stuff :)
11:22:54 <Philippa> plus in the case of Flippi there's an expert on the internal structure to hand, not that said structure is overly complex :-)
11:23:02 <shapr> Darius: hey, Andris(?) Birkman is now agreeing with you on the pi-calculus discussion on LtU
11:23:05 <CosmicRay> last I looked at it, I couldn't figure out what the standard way to do basic stuff was, so I discarded it as too complex
11:23:36 <shapr> I am aware of enough of Plone that my sanity is in doubt.
11:23:45 <CosmicRay> shapr: just as long as you don't use phpnuke :-)
11:24:04 <shapr> Much like that game Call of Cthulhu, some knowledge is not safe for the minds of humans.
11:24:19 <Darius> shapr: I've just started reading the new posts on LtU
11:24:40 <shapr> elk: looking for Haskell info?
11:24:54 <basti_> anyone: talking about haskell at all?
11:24:58 <shapr> me me!
11:25:03 <shapr> Flippi!
11:25:13 <CosmicRay> basti_: sequence me if you dare.
11:25:25 * Darius is just struck about the not unlikely possibility of a Haskeller saying, "I'm looking for my fix"
11:25:33 <CosmicRay> I wish I could get an xml feed of http://freshmeat.net/browse/834/
11:26:02 <shapr> Darius: good idea!
11:26:04 <unsafeCoerce> is there a flag -fno-warn-deprecated ?
11:26:31 <shapr> fix,mfix, or fixIO would be a neat name for a Haskell news site.
11:26:53 <CosmicRay> heh
11:27:00 * unsafeCoerce is pissed because he overlooked some important warning because of all that deprecated crap.
11:27:04 <autrijus> <plug>help me write my TMR article! # http://use.perl.org/~autrijus/journal/23292 </plug>
11:28:06 <CosmicRay> autrijus: is pugs your haskell project?
11:28:10 <autrijus> CosmicRay: yes.
11:28:11 <CosmicRay> yo syntaxninja
11:28:34 <CosmicRay> autrijus: sounds cool. better hurry :-)
11:29:09 * CosmicRay scouts about for any haskellers with blogs and rdf feeds
11:29:16 <CosmicRay> I have shapr ans syntaxninja already
11:29:22 <Philippa> I have an LJ, it doesn't cover haskell stuff though
11:29:25 <xerox> You mean rss? :)
11:29:30 <unsafeCoerce> ahh, -fno-warn-deprecations.
11:29:51 <CosmicRay> xerox: yeah, the xml syndication thingy :-)
11:30:15 <CosmicRay> Philippa: that's OK.  you're *interested* in haskell stuff, right? :-)
11:30:47 <Philippa> it's also largely a meme-pit
11:30:53 <CosmicRay> url me
11:30:55 <bpalmer> there're at least 2 xml syndication things, rss and atom
11:31:00 <CosmicRay> right
11:31:10 <autrijus> CosmicRay: quite a few core perl hackers are learning haskell now :)
11:31:16 <shapr> hey bpalmer, what brings you to the purely functional side of life?
11:31:18 <CosmicRay> autrijus: really.  that is very itneresting
11:31:20 <CosmicRay> autrijus: why? :-)
11:31:25 <CosmicRay> autrijus: isn't Haskell the anti-perl?
11:31:25 <Philippa> CosmicRay: flippac on LJ. Look it up, I imagine you'll decide it's not worth syndicating to others at least :-)
11:31:40 <autrijus> sure and Perl6 is the synthesis
11:32:15 <SyntaxNinja> hi CosmicRay
11:32:59 <autrijus> with strong typing, inference, bunch types, kinding, letrec, continuation, true macros, etc. :)
11:33:45 <autrijus> also because they want to hack on perl6 now, and currently the only codebase that runs perl6 is in haskell :)
11:34:57 <CosmicRay> hi SyntaxNinja
11:35:19 <shapr> Guten Abend flori
11:35:35 <CosmicRay> pfft, europeans.  nachmittag hier.  :-)
11:35:57 <shapr> Hm, I think I'll go unicycling...
11:36:25 <flori> shapr: abend
11:36:48 * CosmicRay is slowly learning german
11:36:49 <CosmicRay> finally.
11:37:38 * Darius should do that.
11:37:57 <shapr> Darius: unicycle? or speak German?
11:38:02 <basti_> what for? ;)
11:38:29 <shapr> Some of the niftiest people I know are German.
11:38:41 <CosmicRay> basti_: how could one go wrong with a langue where "beer" is more important to learn than "water"? :-)
11:38:41 <shapr> I truly admire the German cultural dedication to quality.
11:38:48 <basti_> lol
11:39:21 <Cale> ðð­ðð¾ð¯
11:39:46 <SyntaxNinja> shapr!
11:39:48 <bpalmer> the reinheitsgebot is truly an inspiration to us all
11:39:50 <psi> german commercials are the best.
11:39:50 <SyntaxNinja> it's a day off here. yay!
11:40:01 <CosmicRay> basti_: seriously, I've had three different German courses over the years.  In every single one of them, bier is one of the first words learned, followed closely by wein.
11:40:14 <CosmicRay> SyntaxNinja: lucky
11:40:14 <Cale> heheh
11:40:21 <basti_> i dont know what to say about that lol
11:40:26 <CosmicRay> heh
11:40:29 <flori> CosmicRay: well, they call it liquid bread for a reason ;)
11:40:34 <basti_> i drink only malzbier.
11:41:15 <shapr> I like weiswurst.
11:41:31 <CosmicRay> SyntaxNinja: check out sequence.complete.org
11:41:32 <Gahhh> I like hoechstgeschwindigkeit.
11:41:54 <shapr> hoegaarde is at least interesting.
11:41:56 * basti_ likes gruenkohl with wurst
11:42:53 <CosmicRay> basti_: seriously, my interest in German is because it was the native language of my grandparents.  much of the history of my community is written in german.  (they were ethnic swiss, lowland germans, and dutch)
11:43:03 <basti_> oh.
11:43:31 <CosmicRay> basti_: my name is Goerzen, I grew up near a town named Goessel and a church named Alexanderwohl...  Schmidt is the most common name in this area.
11:43:36 <basti_> hehe -g-
11:43:40 <CosmicRay> basti_: look at all familiar? :-)
11:43:44 <basti_> yes of course
11:44:07 <basti_> i know that theres a lot of german heritage in the usa.
11:44:14 <CosmicRay> indeed
11:44:19 <basti_> many people immigrated there before WW
11:44:19 <SyntaxNinja> CosmicRay: sweet. are you sindicating my blog there?
11:44:19 <basti_> 2
11:44:23 <CosmicRay> SyntaxNinja: yes
11:44:24 <wilx> Heh, "The parrot/perl6 program hasn't made perl6 happen in 5 years. What makes you think you can do it?" I want to see the answer for this one too :))
11:44:40 <SyntaxNinja> CosmicRay: you can just get the "tech" section, which is what planet.debian.org syndicates
11:45:02 <CosmicRay> basti_: in my case, my ancestors left their homeland in the 1600s, then went to prussia for awhile, then ukraine until 1874.
11:45:23 <CosmicRay> basti_: it is very interesting talking to my grandmother, since the german she knows is essentially the german of the 17th or 18th century
11:45:31 <Philippa> wilx: I suspect the answer is "I'm using the right tool for the job" :-)
11:45:39 <basti_> thats sounds difficult.
11:45:48 <basti_> hehe. I would love to hear how that sounds
11:46:06 <CosmicRay> surprisingly not as much as I'd think
11:46:14 <basti_> huh?
11:46:19 <CosmicRay> *reading* her german handwriting, though, that I have trouble with
11:46:31 <CosmicRay> it's not as difficult to understand her german as I'd have thought with such a big time gap
11:46:33 <basti_> oh the handwriting was very bizarre.
11:46:45 <basti_> there were quirks as suetterlin script
11:47:03 <basti_> which is basically unreadable for me, for example
11:47:28 <shapr> Can you read that nifty gothic script stuff?
11:47:33 <CosmicRay> the funny thing is, all my ancestors spoke their own dialect... pennsylvania dutch, low german, whatnot.  Growing up here in the US, they were taught high german in school, but it was not the modern high german.
11:47:46 <basti_> shapr: gothic script? you mean fraktur letters?
11:47:55 <shapr> heckifIknow
11:48:08 <shapr> looks like all caps with pointy bits everywhere
11:48:15 <basti_> fraktur letters.
11:48:23 <Darius> shapr: Both!
11:48:38 <shapr> Darius: yes!
11:48:45 <basti_> http://www.ocist.com/claudius%20fraktur,%20haas.jpg
11:48:47 <basti_> like that?
11:49:02 <CosmicRay> I hate trying to read that
11:49:20 <basti_> some old books you get are like that.
11:49:22 <CosmicRay> but most of the local history before about 1960 was written that way
11:49:44 <CosmicRay> WWII pretty much put a halt to german for daily business around here
11:49:51 <basti_> http://www.ocist.com/hupp-fraktur.jpg < that would probably be a more generic font
11:49:53 <CosmicRay> too much bad feeling from others nearby
11:50:11 <basti_> sure
11:50:27 <basti_> even in germany fraktur is associated with militarism
11:50:39 <basti_> although it was invented by a jew and forbidden for that reason around '40
11:50:41 <basti_> (-g-)
11:50:57 <bpalmer> fraktur is associated with militarism?
11:51:04 <bpalmer> wow, my math courses suddenly seem more exciting
11:51:12 <basti_> (grinning since some nazis use fraktur fonts for their gazettes)
11:51:18 <shapr> bizarre
11:51:38 <wli> The Gothic script has fallen into disuse for similar reasons.
11:52:10 <wli> (I learned it to read pre-1900 handwritten German)
11:52:24 <basti_> thats suetterlin script then i think.
11:52:44 <wli> basti: There is probably a real name for it.
11:52:49 * unsafeCoerce doesn't associate fraktur with militarism.
11:53:14 <basti_> http://de.wikipedia.org/wiki/Bild:Kant_Suetterlin.png
11:53:19 <wli> I mostly see it used in math where lots of different fonts are needed to get different versions of math.
11:53:28 <wli> feh
11:53:32 <wli> s/of math/of letters for math/
11:53:47 <shapr> basti_: that's wild
11:53:54 <CosmicRay> basti_: you guys have some fscked up fonts :-)
11:53:59 <tuomov> calligraphic is much more common in math, though
11:54:06 <tuomov> \mathcal
11:54:08 <basti_> suetterlin is absolutely historic
11:54:11 <wli> basti: That's not a png
11:54:15 <shapr> basti_: man I love fraktur, that's a royally cool font imho.
11:54:25 <shapr> Of course, I have no cultural associations with it.
11:54:28 <basti_> it was liked for its "current" type
11:54:56 <basti_> http://upload.wikimedia.org/wikipedia/de/0/0d/Initialen.jpg
11:55:01 <basti_> another fraktur example
11:55:16 <shapr> beautiful
11:55:24 <tuomov> unredable
11:55:28 <basti_> i mean it looks great, but its hard to read
11:55:35 <basti_> -g-
11:56:01 <shapr> It's easier than tengwar.
11:56:06 <basti_> tengwar?
11:56:18 * shapr gets url
11:56:29 <shapr> http://www.emacswiki.org/cgi-bin/wiki/WritingTengwar
11:56:31 <wli> basti: That's the stuff.
11:56:49 <basti_> shapr: tolkien elven script??
11:56:55 <shapr> yup
11:56:57 <wli> http://upload.wikimedia.org/wikipedia/de/4/40/Kant_Suetterlin.png
11:57:00 <basti_> wli: what you were calling gothic?
11:57:17 <shapr> I was calling fraktur gothic.
11:57:28 <basti_> maybe gothic is the english name for it
11:57:46 <basti_> i think fraktur is even a wrong term, but in german you find this sort of fonts sorted under "fraktur" for some reason
11:57:52 <CosmicRay> shapr: in my head, they mean about the same thing
11:58:08 <wli> basti: That's what I've heard called "gothic script".
11:58:11 <shapr> I've heard of fonts called fraktur, and they look like this.
11:58:12 <CosmicRay> shapr: fraktur supports umlauts :-)
11:58:12 <basti_> fraktur means that the letters are not fully connected i think
11:58:38 <basti_> so its a more generic term
11:58:57 <shapr> I didn't know about Sutterlin, but I like it. Can't see the letters so well though.
11:58:58 <tuomov> hmm.. google "latex gothic" didn't return what I wanted :)
11:59:01 <basti_> but to come back to the question, yes i read whole books it fraktur
11:59:13 <shapr> tuomov: haha
11:59:17 <basti_> shapr: its unreadable for most today people
11:59:42 <tuomov> in any case, I think same latex font was called fraktur/gothic
11:59:49 <basti_> mainly because "e" looks like "n" or something
12:00:13 <wli> basti: I write things in that script to obfuscate things.
12:00:34 <basti_> hehe
12:00:36 <shapr> I write in tengwar.
12:00:39 <wli> basti: (cursive Russian also works)
12:00:47 <shapr> And some scripts I've designed myself (that mostly suck :-)
12:01:02 <basti_> my handwriting is basically unreadable to other people anyway
12:01:04 <basti_> ,)
12:01:19 * CosmicRay grins at lightstep's profile
12:01:29 <CosmicRay> Public E-Mail Address:
12:01:29 <CosmicRay> amir lb @ (.) bonbon net -- you know haskell. concatenate the rest
12:02:15 <kosmikus> I think blackletter is the typographically correct classification, whereas "fraktur" is more specific, and "gothic" is somewhat ambiguous, being also used for sans-serif fonts
12:02:50 <basti_> hmm if you say so
12:03:02 <shapr> CosmicRay: hey, does drupal dislike my blog rss format?
12:03:36 <tuomov> "In the United Kingdom, blackletter type is also called Gothic; elsewhere Gothic is used only in its modern sense as a synonym for sans serif."
12:03:40 <tuomov> http://en.wikipedia.org/wiki/Typeface
12:04:00 <tuomov> not that I've ever heard gothic used in the latter sense
12:04:11 <basti_> century gothic is a sans serif
12:04:58 <wli> shapr: I'm going to stick to real-life ones; I've found Tolkein's stuff is actually better-known than real languages in .us
12:06:20 <shapr> Would be a neat way to organize a geeky group of people. "If you can read this poster written in tengwar, we want to meet you. Every saturday at noon in building X"
12:06:29 <wli> hiragana, katakana, and Arabic are probably good bets to throw people off.
12:06:40 <shapr> alpha bets even
12:06:44 <wli> shapr: except for geeks that aren't into Tolkein
12:13:47 <metaperl_> I just posted about a misusage of terms in "Gentle" at http://haskell.org/hawiki/GentleHaskellDiscuss
12:16:41 <wilx> Hm, for some reason the line on that page doesn't wrap.
12:17:23 * basti_ sees the same
12:17:31 <metaperl_> I used {{{ }}} for the quotes
12:17:36 <metaperl_> what should I have used?
12:18:11 <shapr> probably ''text''
12:19:10 <metaperl_> no , how do you represent a blockquote? I manually broke the lines so it is now more viewable
12:19:59 <glimming> lhs2tex does not seem to like @
12:22:52 <wli> I know some more basic things.
12:24:14 <metaperl_> well anyway, formatting issues aside, you agree with my point that he should not have used the word "error" in the sentence when talking about IOError?
12:24:55 <basti_> i think some clarification would be at hand yes.
12:25:53 <metaperl_> no, he had no business making the distinction between errors and exceptions and then using "error" in the same sentence with IOError
12:26:21 <metaperl_> because IOError has to do with exceptions and has nothing to do with errors, per his own definitions
12:26:29 <basti_> yes.
12:28:14 <kosmikus> glimming: Guide2.pdf, page 5, Section 3
12:28:52 <glimming> kosmikus ;-) thanks
12:32:29 <Gahhh> metaperl_, yes, that use is confusing.
12:32:46 <metaperl_> thanks for the input Gahhh.
12:32:59 <metaperl_> now I'm glad I did not buy Hudak's book :)
12:33:08 <metaperl_> but maybe it is better than his freeware book
12:33:10 <Gahhh> I bought Hudak's book. It's not bad really.
12:33:17 <metaperl_> I bought the algorithms book instead
12:33:41 <metaperl_> so you think Hudak's book is a good one to have? It seems like it has a lot of practical applications in it
12:33:54 <metaperl_> like the music system for instance
12:34:21 <shapr> Haskore is *fun*
12:34:32 <metaperl_> heh. I was using Commonmusic for awhile
12:34:47 <Gahhh> I didn't care much about the music system or the graphics. I thought that I just needed something not in an electronic format.
12:34:49 <metaperl_> it has both SCheme and Lisp APIs. and the book "Notes from the Metalevel" is based on it
12:36:16 <shapr> Gahhh: what do you mean?
12:36:59 <Gahhh> shapr, something printed out heh.
12:37:01 <shapr> I'm not so impressed with SOEGraphics, but Dance is way sexy.
12:38:44 <CosmicRay> metaperl: I do suggest the TSimon Thompson book
12:38:46 <CosmicRay> metaperl: http://www.cs.ukc.ac.uk/people/staff/sjt/craft2e/
12:39:46 <metaperl_> CosmicRay, thanks for the input... when I get my next check in 2 weeks I will seriously consider it
12:40:11 <CosmicRay> metaperl: also, YAHT is a good (free PDF) read... http://www.isi.edu/%7Ehdaume/htut/
12:40:45 <shapr> but you'll learn the most by coming to #haskell and saying stuff like "I wrote this code, it works, can you suggest any improvements? <insert url here>"
12:40:55 <CosmicRay> or haskell-cafe
12:41:47 <metaperl_> i see
12:44:31 <basti_> haskell-cafe?
12:44:56 <CosmicRay> it's a mailing list, see http://www.haskell.org/mailinglist.html
12:45:07 <basti_> oh i see
12:45:19 <basti_> i thought i missed the "talk" channel so far...
12:47:14 <glimming> In a paper by John Mitchell et al, it is claimed that parametric polymorphism is less useful than subtype polymorphism since parametricity means we can only write functions on _any_ type. In OOP, in contrast, one is concered with writing functions that work for any subtype of the type for which they were originally defined.
12:47:24 <glimming> Is this statement true also for Haskell ?
12:48:34 <basti_> hm
12:49:13 <glimming> can someone submit a patch to me that fixes type synonyms in GHC ?
12:49:23 <glimming> they are flakey for infixes
12:49:43 <Darius> The latter part is (to an extent), the former is at least debatable.  At any rate it is clear that parametric polymorphism is of great value even given subtype polymorphism.
12:49:53 <SyntaxNinja> hm. every so often, I see someone say something like "May I ask why?" (just seen on the darcs channel) and I don't know how to interpret it... in American english, that sounds really condescending and rude.
12:49:59 <SyntaxNinja> is that not the case elsewhere?
12:50:44 <Darius> SyntaxNinja: I don't necessarily see it as condescending (though it often is).  Context would usually determine it.
12:51:12 <kosmikus> SyntaxNinja: interesting, I didn't know that. sounds normal to me ...
12:51:39 <SyntaxNinja> in email or irc, there's usually not much context to go on
12:52:03 <glimming> Nothing wrong with "May I ask why" but I am swedish.
12:52:10 <glimming> It is more polite than "Tell me why!"
12:52:15 <Darius> kosmikus, SyntaxNinja: In spoken (American) English, which it is can usually be told by the sharpness of how it's spoken, in electronic media it's usually better to be conservative.
12:52:23 <Philippa> Darius: IMO the natural response is bounded polymorphism
12:52:28 <glimming> or "You'd have to tell me why if I'm to believe you on that one."
12:52:36 <glimming> F-bounded?
12:52:50 <Philippa> and yeah
12:52:52 <glimming> in
12:53:08 <Philippa> (re the "may I ask...")
12:53:26 <Philippa> that said, the phrase "with all due respect" is almost always suspect
12:53:35 <basti_> lol
12:53:42 <glimming> You are crazy!
12:53:42 <Gahhh> heh
12:53:47 <Philippa> more so if the words all or due are emphasised :-)
12:53:51 <glimming> Never trust a person!
12:54:09 <SyntaxNinja> I once heard that "quite good" means "not that good" in british english, whereas I've always considered it to me "really very good" :)
12:54:22 <SyntaxNinja> s/me/mean
12:54:29 <shapr> I think metaquestions suck. "Can I ask you a question?" "Yes, but I only give you permission to ask the question you just asked."
12:54:48 <Philippa> SyntaxNinja: there's a subtlety - "really quite good" is deliberate understatement
12:54:53 <Gahhh> "can I ask you a question" -> "Apparently you can. Would you like to ask another?"
12:54:59 * shapr grins
12:55:11 <glimming> I think subtyping is strongly related to overloading rather than parrametricity.
12:55:30 <Philippa> you're confusing subtyping and inheritance IMO
12:55:36 <kosmikus> "can I ask a question?" is just a waste of time on irc imo
12:55:48 <Darius> glimming: It (on its own) is not related to parametricity at all.
12:55:51 <shapr> I think it's a waste IRL.
12:55:58 <SyntaxNinja> :)
12:55:59 <Darius> hmm, or is it?
12:56:04 <glimming> Darius, what is "it" in this context?
12:56:06 * CosmicRay adds haskell-cafe feeds to sequence.complete.org
12:56:17 <Darius> glimming: Subtyping.
12:56:18 <araujo> Hello all
12:56:20 <kosmikus> shapr: depends; might be necessary to get someone's attention in the first place
12:56:27 <araujo> Hello kosmikus
12:56:35 <kosmikus> hi araujo
12:56:44 <Darius> kosmikus: In IRC, it's a misunderstanding of the medium.
12:56:53 <Gahhh> I usually wave my handgun and ask questions later.
12:57:03 <glimming> Philippa, I generally don't confuse these notions... But I am referring to Castagna's treatment of multiple dispatch languages.
12:57:49 <glimming> Subtyping is in fact related to parametricity.
12:57:57 <glimming> Darious, check implicit coercions.
12:58:04 <Philippa> right. Subtyping does not, in and of itself, have anything to do with any kind of type-based dispatch
12:58:10 <glimming> Subtyping can be encoded using polymorphism.
12:58:41 <Philippa> subtyping's a damn good way of constraining types though
12:59:17 <Philippa> feel free to add Value as a superclass of all typeclasses, for comparison
12:59:17 <Darius> glimming: I was more concerned about the properties each exhibit.
13:01:01 <SyntaxNinja> CosmicRay: you probably want to change my rss feed to only feed the technology section.
13:01:07 <glimming> To me subtyping is a preorder on the universe of types together with a subsumption rule.
13:02:09 <glimming> in fact not preorder but quasiorder.
13:03:13 <Darius> Right now I'm thinking about what the free theorems of subtyping polymorphism would look like.
13:03:28 <glimming> Interesting.
13:03:33 <glimming> And more interesting with F-sub.
13:04:00 <xerox> Yawwwn.
13:04:01 <glimming> I would like to better understand type classes vs. subtyping/inheritance
13:04:33 <CosmicRay> SyntaxNinja: I can if you like
13:04:36 <Darius> glimming: Their very names pretty much differentiate them.
13:04:45 <glimming> You do have this    instance Thing a => SomeThing a
13:04:47 <glimming> How'
13:04:50 <glimming> s that?
13:05:01 <SyntaxNinja> CosmicRay: yes, please. that way I don't have to worry about my random blog posts being "on topic" :)
13:05:12 <CosmicRay> SyntaxNinja: I don't really care if they're not on topic :-)
13:05:21 <CosmicRay> SyntaxNinja: blogs are supposed to be off topic :-)
13:05:27 <CosmicRay> SyntaxNinja: planet.debian.org has plenty of off topic stuff
13:05:35 <SyntaxNinja> I do the same thing w/ planet actually
13:05:38 <CosmicRay> but I'm changing it anyway, no problem
13:05:51 <Darius> glimming: A type class is just a set (class) of types, the "subclassing" there is just the subset of those types.
13:06:01 <Philippa> and there's no real inheritance
13:06:05 <Darius> glimming: subtyping is when one type contains another.
13:06:12 <Philippa> all that really says is that you know ahead of time there's already an instance
13:06:19 <CosmicRay> SyntaxNinja: done
13:06:22 <glimming> Darious, not neccessarily, but fair enough (remember coercions)
13:06:45 <Philippa> that said, but for the lack of an introduction rule (generally, at least), type classes could almost be types unto themselves
13:07:10 <Darius> glimming: The coercions just witness the containment.
13:07:18 <Philippa> there's just no way to create a value of which all you know is that it belongs to a type class
13:07:39 <glimming> (Darius, not necessarily, it depends on the semantics. Consider per models etc.)
13:08:05 <esap> You can simulate inheritance with record projections and type classes.
13:08:16 <Philippa> when it's not about one type containing another, it's not really subtyping any more
13:08:42 <glimming> You just discarded quite a few interesting subtype relations there.
13:08:57 <Philippa> no, I just stopped calling them subtype relations - there's a difference
13:09:21 * CosmicRay tries a 2-column layout
13:09:33 <glimming> esap, how do you do that?
13:09:37 <SyntaxNinja> CosmicRay: so can I link my real blog to my blog in there somehow?
13:09:46 <glimming> So Philippa wants type classes to be types, please expand.
13:09:54 <CosmicRay> SyntaxNinja: not very easily
13:10:09 <CosmicRay> SyntaxNinja: but having it syndicated is almost as good
13:10:12 <Philippa> no, I don't want them to be. I think they're very closely related, indeed in the context of Haskell they'd probably be getting on for dual
13:10:16 <glimming> I think it is best to consider examples.
13:10:25 <CosmicRay> SyntaxNinja: I'm making sure that both syndicated and local blog posts show up in boxes on the front page
13:10:36 <CosmicRay> SyntaxNinja: I'm not moving my blog, for instance
13:10:36 <glimming> Let's consider Functor and Monad.
13:10:40 <esap> glimming: you declare a type class and a data structure for each of your classes. Then you implement instance of the type class for your extended data structure as well.
13:10:49 <SyntaxNinja> CosmicRay: OK. but then articles are kinda a different thing altogether?
13:11:06 <glimming> esap, so you have the attributes in a record and operate on that record then.
13:11:16 <glimming> So you can even extend that record with more attributes I guess.
13:11:29 <CosmicRay> SyntaxNinja: blog posts get posted in their entirety on the front page, but they do show up immediately under /blog/[your userid]
13:11:39 <CosmicRay> SyntaxNinja: articles are things that are destined to be posted on the front page
13:11:43 <CosmicRay> "Cabal 0.5 is out" is an article
13:11:54 <CosmicRay> articles require review before being posted
13:11:58 <CosmicRay> they get voted on in the submission queue
13:12:02 <SyntaxNinja> CosmicRay: did you say that right? in that case, what's the difference?
13:12:16 <esap> glimming: yes. You just need to distinguuish between external interface (the type class) and the internal implementation (the data structure), and then implement the operations in the external interface using projections of the data structure.
13:12:25 <CosmicRay> SyntaxNinja: blog entries get posted immediately, but never get posted in their entirety on the front page
13:12:36 <glimming> esap, interesting.
13:12:37 <CosmicRay> SyntaxNinja: stories get posted on the front page, but only after they've been reviewed.
13:12:52 <CosmicRay> SyntaxNinja: perhaps this clarifies a bit: http://sequence.complete.org/about
13:13:09 <Philippa> note that the internals and externals have differently-behaving subtyping relationships - the safe one for internals doesn't let you add new subtypes at random
13:13:19 <esap> glimming: See http://www.kotiposti.net/epulkkin/OOArrow.txt for some ideas about how to utilize that.
13:13:20 <glimming> And in a context where you would require an original interface, you can also provide ane xtended interface?
13:13:21 <Philippa> the safe one for externals doesn't let you add new supertypes at random
13:13:30 <CosmicRay> SyntaxNinja: there are *links* to recent blog entries posted in the little boxes on the front page, but the entries themselves never hit the front page
13:13:42 <Philippa> glimming: no. That type info is effectively lost
13:14:00 <SyntaxNinja> "(13:12:31) CosmicRay: SyntaxNinja: blog posts get posted in their entirety on the front page..."
13:14:09 <CosmicRay> ah, I did say that wrong then.
13:14:15 <glimming> Philippa, explain more.
13:14:16 <Philippa> however, your extended interface requires that you already have an implementation for the original
13:14:30 <CosmicRay> should have said "do not get posted"
13:14:31 <Philippa> sit down and work out how it works in a dictionary-passing implementation
13:15:34 <Philippa> to support the extended interface, you must support the original. So you just pass the dictionary for the original
13:15:45 <SyntaxNinja> CosmicRay: OK. if I feel like one of my blog entries is good enough for the front page, then I copy and paste it as an article, then?
13:15:59 <Philippa> once you've passed that, nothing past there knows you actually support the extended interface. It's not statically determinable.
13:15:59 <CosmicRay> SyntaxNinja: yes
13:16:06 <CosmicRay> SyntaxNinja: or you write an article that links to your blog entry
13:16:43 <Philippa> (note that esap and I're effectively assuming existential types here)
13:16:44 <SyntaxNinja> CosmicRay: OK cool. thanks
13:16:44 <CosmicRay> SyntaxNinja: unfortuantely there's no way to put syndicated or local blog entries directly into the submission queue without some undesirable side effects
13:16:51 <glimming> Philippa, I do not see this. (And I am not working with dictionaries much.)
13:16:53 <CosmicRay> so copy and paste it is for now.
13:17:10 <Philippa> glimming: Which languages have you coded seriously in?
13:17:22 <Philippa> I ask this because odds are I can give you a good analogy in one of them
13:17:24 <CosmicRay> untill we get enough people using the site to make the voting meaningful, I'll be spot-checking and manually approving things to get some content up quicker
13:17:26 <glimming> I'm a theory person.
13:17:41 <glimming> What is the problem of defining instances of two different type classes then?
13:17:55 <SyntaxNinja> cool
13:17:56 <Philippa> there's no problem there
13:18:05 <Philippa> the problem is when you pass to something that only cares about one
13:18:05 <glimming> If one contains some portion of the interface and some other the other portions.
13:18:54 <glimming> Why is that a problem? Say I care about Functor and am given Monad?
13:18:57 <Philippa> \(x::(ClassA a => a)) -> -- can't use operations in ClassB on a here unless ClassA inherits from it
13:19:05 <Philippa> Monad's not an instance of functor
13:19:12 <glimming> Will lert
13:19:14 <Philippa> IIRC
13:19:37 <Philippa> anyway, were it, you'd not know that it's a Monad
13:19:52 <Philippa> nor, in the absence of dynamic typing, could you determine that it is one
13:19:55 <glimming> Does that matter? You would not know it is a subtype either.
13:20:00 <glimming> In a context expecting a supertype.
13:20:31 <Philippa> right. The thing is, you don't provide the extended interface that is Monad
13:20:37 <Philippa> you just provide the interface that is Functor
13:20:45 <glimming> Does that matter?
13:20:55 <Philippa> in terms of your original phrasing? Yes
13:21:07 <glimming> If I understand correctly, this is equal in a subtype discipline.
13:21:12 <Philippa> don't confuse the interface with things that support it
13:21:41 <Philippa> yes. There's a reason I'm making comments about type classes and algebraic datatypesa
13:21:46 <Philippa> *datatypes
13:22:10 <glimming> So how could you claim that overloading has nothing to do with subtyping?
13:22:55 <Philippa> it has nothing to do with subtyping. Per se. The relation is with type dispatch, and you commonly constrain that with subtyping
13:23:37 <glimming> I am not sure I agree here.
13:23:38 <Philippa> bear in mind that it's entirely possible to have overloading without either inheritance or type classes
13:23:46 <Philippa> C++ manages that quite happily
13:23:51 <Philippa> well, FCVO "happily"
13:24:41 <glimming> I think this is rather subtle.
13:25:08 <Philippa> and I think practical experience would help you a lot in dealing with the subtleties
13:25:25 <glimming> thanks for the advise
13:26:04 <glimming> I take it you are an expert.
13:26:12 <glimming> ;-)
13:26:29 <glimming> If there is something I try to learn from my supervisor it is a modest approach to knowledge.
13:26:42 <Philippa> I'm practiced enough in playing with abstract systems to know that going out and doing something with them is an important part of learning to use them
13:27:16 <Philippa> to put it in perspective, anybody who programs plays with abstract systems
13:27:28 <glimming> OK.
13:28:39 <Philippa> and doing stuff tends to give you a rather rapid crash course in what eg your language of choice's type system will and won't allow
13:30:54 <glimming> The problem when you do research is that there is no such thing as a the language of choice.
13:31:10 <glimming> Since if you do programming language theory then you are studying new kinds  of languages.
13:31:18 <glimming> And such studies are semantical mostly.
13:31:33 <esap> ah but there is :-) You write your own!
13:31:35 <Philippa> perhaps. I'm happily playing around with things that're merely related to those languages I've used
13:31:40 <Philippa> esap: bingo
13:31:46 <Philippa> what else is the point of the research anyway? :-)
13:31:53 <Darius> Philippa: How is Tyop going btw?
13:32:22 <Philippa> not so good atm, I've not had the tuits to bash out an inference algo. Am hoping the copy of ATTaPL that showed up this morning will help kick my brain into gear on that one
13:32:52 <Philippa> atm I'm hoping to implement the same old ADT subtyping thing, single-parm type classes and n-rank polymorphism ala GHC
13:33:45 <Philippa> oh, and GHC-style existential types
13:33:45 * esap is trying to implement category theory atm.
13:34:02 <Philippa> the type system would be rather less fun without them
13:34:07 <glimming> esap, you should contact a guy at Uppsala University who might be interested in that sort of stuff.
13:34:29 <esap> who?
13:35:52 <glimming> So what are the subtypes of List?
13:36:26 <Philippa> Nil and Cons seem good starting points
13:37:04 <esap> glimming: How about different length lists? say 5 element lists?
13:37:21 <glimming> esap, that would need dependent types I think.
13:37:29 <Philippa> esap: that's one of the things you can do with Nil and Cons as subtypes of List :-)
13:37:39 <glimming> I wonder if you can subtype List like that.
13:37:42 <glimming> List is recursive.
13:38:08 <Philippa> yes, so Cons refers to List
13:38:26 <glimming> data List a = Nil |Â Cons (List a) right?
13:38:34 <glimming> oops and an a there too
13:38:49 <Philippa> that formulation doesn't get you the ability to type n-vectors, but yeah
13:39:25 <Philippa> if you have bounded polymorphism or don't mind a little unsafety you can introduce a second type variable for the tail in Cons
13:39:29 <glimming> So what is your subtype rule for sums?
13:39:42 <glimming> You also have a rule for Rec I guess?
13:39:48 <Darius> A < A+B
13:39:53 <Philippa> Darius: bingo
13:39:55 <Philippa> pretty obvious
13:40:08 <Philippa> I don't have proper records atm - mind you, Haskell doesn't really
13:40:22 <glimming> Not records, sorry, I mean mu, fixed points (recursive types).
13:40:30 <glimming> The problem is that you do not have A+B here really.
13:40:36 <glimming> You have a recursive type.
13:40:43 <esap> glimming: Rec is interesting case, because you end up with all kinds of things with equivalence classes.
13:40:47 <Philippa> List = A + B, where B is defined in terms of List
13:41:07 <Philippa> because we're in an ML-like setting, we don't really need it as such
13:41:26 <glimming> That's unusual.
13:41:48 <Philippa> it's also the case in a major family of functional languages. See earlier comment about practical experience.
13:41:51 <glimming> I think you would really need to consider a subtype rule for recursive types here.
13:42:11 <glimming> Hehehehehee
13:42:12 <Darius> Shouldn't it be F < Mu.F
13:42:28 <glimming> Yes, but there are premises too.
13:42:58 <glimming> To subtype algebraic datatypes you will need to consider recursive types.
13:43:27 <Philippa> hate to break this to you, but I already have an algorithm for just ADTs w/subtyping
13:43:48 <esap> F (Rec F) < Rec F, how about that?
13:44:02 <Philippa> well, algorithm's perhaps a little OTT, but basically it's classic H-M stuff only instead of checking type operators match when unifying you find their least upper bound
13:44:25 <Philippa> (in the case where there isn't one due to lack of uniqueness, I have an annotation rule that lets a programmer write useful code)
13:44:52 <Philippa> basically, in this context I don't have to care about recursive types - it all drops out neatly
13:45:16 <Philippa> you may like to consider the implicit annotations that constructors, pattern matching etc offer
13:45:16 <glimming> The subtype rule for recursive types mostly used is called the Amber rule and is due to Luca Cardelli.
13:46:02 <glimming> It says something like
13:46:07 <glimming> A <: B
13:46:08 <glimming> ------
13:46:20 <glimming> mu A <: mu B
13:46:29 <glimming> in a simplified form.
13:46:44 <Heffalump> that sounds very simplified
13:46:47 <Philippa> IOW, if it worked the first time round, it'll work when you unfold it. What a surprise
13:47:02 <Heffalump> cos if it was that simple it would be considered trivial
13:47:02 <esap> glimming: What is the kind of A and B?
13:47:14 <glimming> types...
13:47:23 <glimming> With a free variable.
13:47:35 <glimming> For lists we would have
13:48:03 <glimming> FList a b = Nil |Â Cons (a b) b
13:48:12 <glimming> and a subtype of FList would have to be plugged in this equation
13:48:14 * esap thinks Rec : (* -> *) -> *.
13:48:39 <glimming> I am not sure.
13:48:44 <glimming> I think you might be right.
13:48:46 * esap has to get something to eat. gotta go.
13:48:49 <glimming> Anyway
13:48:51 <Philippa> glimming: yup, as I was describing earlier. If I get as far as designing a real language I'll probably implement tuples on top of a variant of that
13:48:58 <esap> see you later
13:49:01 <glimming> ok.
13:49:04 <glimming> I have to work too.
13:49:18 <glimming> bye for now (I'll be back)
13:49:30 * Philippa sighs
13:52:14 * kosmikus smiles
13:52:34 * basti_ explodes
13:53:12 * kosmikus paramorphs
13:54:02 <Philippa> think I'm gonna head next door with ATTaPL. If nothing else, I should go to bed in the next couple of hours
13:55:09 <Darius> Ah, the comfort of type theory.
13:55:17 <kosmikus> I can't wait to get this book into my hands, but it'll still be 6 weeks
13:55:34 <Igloo> How come?
13:55:48 <kosmikus> it's lying safely at home; only I'm not there ...
13:56:00 <Igloo> Ah
13:56:05 <Philippa> Darius: more a case of I'm really damn bored and if I start playing FF5 again I'll be up all night
13:56:09 <Igloo> Are you anywhere nice?
13:56:21 <kosmikus> in .ee
13:56:36 <kosmikus> until end of march
13:57:13 <Igloo> On work? It seems to have turned into the FP centre of the world overnight  :-)
13:58:16 <kosmikus> only because of afp/icfp?
13:58:25 <kosmikus> but yes, on work :)
14:02:38 <Igloo> afp, this, icfp all within a year, yes  :-)
14:04:08 <tmoertel> SyntaxNinja: to answer your question of some while ago, no, I have not told Jens about cabal2rpm yet
14:05:25 <SyntaxNinja> tmoertel: :)
14:05:56 <tmoertel> SyntaxNinja: Jens just launched a fedora-haskell mailing list today, and so I am going to announce cabal2rpm there today
14:06:06 <SyntaxNinja> excellent.
14:06:14 * SyntaxNinja wonders why there's a fedora-haskell mailing list.
14:06:31 <Igloo> Same reason there's a debian-haskell mailing list?
14:06:35 <SyntaxNinja> I asked about making a debian-haskell one and was asked, "please don't" by the mailing list guys because there are already too-many
14:06:41 <SyntaxNinja> and as a result, Igloo created one himself.
14:06:46 <SyntaxNinja> at least, that's how I remember things
14:07:02 <Igloo> Oh, on haskell.org. Maybe because the /fedora/ directory was already there?
14:13:59 <Heffalump> are the debian people short of resources to host lists, then?
14:14:21 <gzl> anyone here use literate haskell?
14:15:05 <Heffalump> rarely
14:15:09 <Heffalump> (for me)
14:15:38 <gzl> defining a reasonable 'code' environment is giving me serious headaches
14:16:08 <Heffalump> oh, that kind of literate
14:16:11 <SyntaxNinja> Heffalump: I don't think so
14:16:12 <Heffalump> I don't.
14:16:19 <Heffalump> SyntaxNinja: so what did they have against it?
14:16:33 <Heffalump> it's just silly that they wouldn't host it, since now it's somewhere else.
14:17:17 <SyntaxNinja> Heffalump: I think they would have if I had pressed, but they felt that most of the discussion could probably happen on one of the existing lists
14:17:23 <Heffalump> like what?
14:17:59 <SyntaxNinja> -cafe or something, or libraries
14:19:40 <kosmikus> gzl: use lhs2tex :)
14:20:13 <gzl> !
14:20:15 * gzl googles
14:21:32 <Darius> gzl: Look in the TeX section of the Libraries and Tools page off haskell.org
14:21:56 <gzl> yeah, i foudn it.
14:22:43 <gzl> my tetex was blowing chunks when I was trying to use this code formatting package, I dunno what the deal was
14:24:40 <kosmikus> gzl: which one/
14:25:14 <gzl> listings
14:25:28 <gzl> which is preinstalled, but for some reason the typesetter couldn't find it
14:26:30 <kosmikus> I've never used listings, but it's considered to be quite good my many LaTeXers
14:27:42 <gzl> yes, it seems good, i just can't use it :)
14:27:52 <gzl> not really sure what the problem was
14:28:45 <gzl> kept complaining it couldn't find listings.sty
14:29:17 <gzl> but this lhs2tex looks nice too
14:35:16 <CosmicRay> Hello metaperl
14:35:27 <kosmikus> gzl: doesn't it? ;)
14:35:33 <gzl> yeah. :)
14:35:35 <gzl> thanks
14:35:37 <gzl> still installing, though.
14:50:02 <metaperl_> ping
14:50:07 <metaperl_> Hi CosmicRay
14:50:21 <CosmicRay> hi metaperl_
14:50:26 <metaperl_> hi
14:50:34 <CosmicRay> looking for Haskell info?
14:50:46 <metaperl_> sorta...
14:50:57 <metaperl_> YAHT and Gentle are adequate for now I suppose....
14:51:30 <CosmicRay> OK
14:51:47 <CosmicRay> the wiki and haskell-cafe are also good resources
14:51:53 <CosmicRay> as is this channel
14:52:46 <metaperl_> I am confused about the difference between the gmane group haskell-cafe and haskell-general
14:52:58 <metaperl_> and do you mean an IRC channel haskell-cafe?
14:53:19 <CosmicRay> metaperl: haskell-general is haskell@haskell.org, see here: http://www.haskell.org/mailinglist.html
14:53:28 <CosmicRay> metaperl: it would probably have been more accurate for gmane to call it haskell-announce
14:53:35 <CosmicRay> metaperl: no, I mean the list
14:53:46 <CosmicRay> haskell-announce is a fairly low-traffic list
14:53:55 <CosmicRay> there are some technical questions there but they usually get moved off to haskell-cafe
14:55:52 <CosmicRay> s/haskell-announce/haskell@haskell.org/
14:57:02 <metaperl_> i see. i'm on both gmane feeds. what are you using haskell for? did you participate in ICFP?
14:57:27 <metaperl_> I'm a professional perl programmer by trade but I think that Perl6 is rather lost
14:57:43 <Heffalump> do you mean the conference or the contest?
14:57:44 <metaperl_> I hope to transition into graduate work in Haskell or maybe corporate consulting
14:57:48 <CosmicRay> metaperl: I am trying to use Haskell for every programming task, partly as a way to learn it.  My main Haskell work so far is MissingH, my library of Haskell utilities... http://quux.org/devel/missingh
14:58:06 <CosmicRay> metaperl: I suspect I will eventually port OfflineIMAP and PyGopherd to Haskell
14:58:18 <CosmicRay> metaperl: at work, I use Haskell for database, XML, and web stuff
14:58:28 <metaperl_> are you serious?
14:58:31 <CosmicRay> metaperl: I also have a Haskell interface to Python, http://quux.org/devel/missingpy
14:58:35 <CosmicRay> yup
14:58:51 <metaperl_> you use HSQL for database? and what CGI library is there?
14:58:55 <CosmicRay> HSQL, yes.
14:58:57 <CosmicRay> I am using WASH.
14:59:02 <metaperl_> I just did a database driven website in Perl: www.gimblerus.com
14:59:08 <CosmicRay> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
14:59:18 <CosmicRay> metaperl: there are quite a few different web-type libraries for Haskell
14:59:32 <CosmicRay> metaperl: there is a port of Python's TAL to Haskell, though it (currently) generates static pages only
14:59:38 <metaperl_> that is the one nice thing about Perl: CPAN! and CPAN is a monster... all the code for Perl in one place. ready to go in standardized format with docs
14:59:47 <CosmicRay> metaperl: there are also some lower-level CGI libraries floating about, roughly akin to the basic Perl or Python CGI libraries
14:59:51 <Heffalump> Haskell is just getting setup wih the same kind of thing.
15:00:06 <jlouis> Cabal?
15:00:09 <CosmicRay> metaperl: haskell will probably have that in a few months.  The cabal/hackage project is aiming to do this
15:00:11 <Heffalump> and Hackage, yes
15:00:21 <CosmicRay> metaperl: in the meantime, google, freshmeat, haskell.org, and the wiki are your friends
15:00:25 <CosmicRay> metaperl: also haskell-cafe
15:01:48 * SyntaxNinja high-fives Heffalump
15:01:53 * CosmicRay has to run
15:01:56 <CosmicRay> cyall later
15:28:59 <humasect> http://pleac.sourceforge.net/
15:33:56 <metaperl_> in this type signature, what does "=>" represent and what does (Show a) mean and why is it there: show                    :: (Show a) => a -> String
15:35:07 <jlouis> => is the ``type class constraint'' operator
15:35:21 <Pseudonym> You can think of it as a logical implication.
15:35:32 <Pseudonym> If (Show a) is true, then this function has type a -> String.
15:37:03 <humasect> ~_~a
15:45:23 <metaperl_> I see...
15:45:25 <metaperl_> thank you
15:55:37 <xerox> 'night folks
16:16:23 <metaperl_> I know what function composition is: f . g x == f (g x). But I don't know how it associates. What does this translate to:
16:16:24 <metaperl_> showsTree (Branch l r)  =  ('<':) . showsTree l . ('|':) . showsTree r . ('>':)
16:16:40 <metaperl_> I mean, how does it associate?
16:24:21 <dons> moin
16:33:47 <metaperl_> ran across some neat links
16:33:49 <metaperl_> n.fr/~karczma/Work/Clastic_distr/clastic.html
16:33:53 <metaperl_> oops
16:34:03 <metaperl_> http://users.info.unicaen.fr/~karczma/Work/Clastic_distr/clastic.html
16:34:22 <metaperl_> http://conal.net/pan/default.htm
16:36:35 <Heffalump> the rule is
16:36:40 <Heffalump> (f.g) x = f (g x)
16:36:52 <Heffalump> it associates to the left
16:37:22 <Heffalump> sorry, the right
16:37:48 <Heffalump> showsTree (Branch l r) = '<' : (showsTree l ('|' : (showsTree r ('>':str))))
16:39:19 <metaperl_> oh thanks
16:39:27 <metaperl_> s/oh/ok
16:39:54 <Heffalump> :i (.)
16:39:59 <Heffalump> at a ghci prompt told me how it associated
16:40:16 <Heffalump> (my initial intuitive guess was wrong)
16:40:28 <MachinShn> it's a single ascii boobie ;)
16:45:00 <Darius> (.) is associative.  It doesn't matter which way it associates.
16:45:18 <Pseudonym> Actually, it does matter for efficiency reasons.
16:45:45 <Pseudonym> Lazy evaluation evaluates from the outside in.
16:45:50 <Pseudonym> Actually, just from the outside.
16:46:00 <Pseudonym> So it's more efficient if (.) is right-associative.
16:46:13 <Pseudonym> Of course, it's probably inlined at compile time in most compilers.
16:46:36 <Heffalump> if you don't foldr with it or something..
16:47:11 <Pseudonym> Right.
16:47:41 <Heffalump> but if you do associativity won't matter
16:47:48 <Darius> I was about to say that.
16:47:50 <Heffalump> but it will if you pass around (foo . bar . baz)
16:55:59 <Sukh> I've got a list full of integers [1,2,3,10,3] and I want to concatenate the component integers and produce a single integer 123103.  Any ideas how to do this?
16:56:28 <Sukh> I can't use concat for lists because that concatenates a list full of list [[]] -> []
16:56:41 <CrewdenX> Sukh: use show with map to convert them to strings
16:56:55 <CrewdenX> Sukh: concat the scrings and then convert the result back using read
16:57:05 <Sukh> ah
16:57:07 <Sukh> sounds good
16:57:12 <dons> read (concatMap show [1..10])
16:57:23 <Sukh> Sorry if I asked this question earlier and didn't reply... got caught up doing something
16:59:24 <Lemmih> Greetings, SyntaxNinja.
17:00:16 <SyntaxNinja> y0
17:02:05 <Sukh> That works brilliantly
17:02:07 <Sukh> thanks :)
17:26:44 <Sukh> Why would stringToInt :: [Char] -> [[Int]]   stringToInt x = map read x  not work ?
17:27:13 <Sukh> oh
17:27:13 <Sukh> i know
17:27:14 <Sukh> :D
17:27:51 <CrewdenX> Sukh: for starters, enclode read in parenthesis.
17:28:16 <CrewdenX> Sukh: haskell believes you are trying to execute read on x rather than pass it read to map.
17:28:38 <Sukh> Why would map show x work then?
17:28:43 <Sukh> Haskell is confusing ;)
17:29:13 <Heffalump> CrewdenX: huh?
17:29:21 <Lemmih> CrewdenX: I think you're wrong.
17:29:26 <Heffalump> <aol>
17:29:42 <Heffalump> "map read x" is definitely passing 'read' to 'map'.
17:29:54 <CrewdenX> Heffalump: ok.
17:29:59 <Sukh> anyway, figured out why it wasn't working: it was my definition
17:34:27 <Lemmih> @type (map Char.digitToInt (undefined::[Char]))
17:34:33 <lambdabot> (map Char.digitToInt (undefined::[Char])) :: [Int]
17:36:34 <CrewdenX> is there anything that says that tail recursive functions won't use memory proportional to depth at which they're used?  i mean, can you use them and be reasonably certain your program isn't going to hemorrhagege memory?
17:37:05 <Heffalump> CrewdenX: no absolute guarantee in the language spec, but any reasonable implementation will do that
17:37:14 <CrewdenX> Heffalump: ok.
17:37:20 <Heffalump> (eliminate the recursion, that is)
17:37:24 <MachinShn> i'd think haskell's lazy evaluation would guarantee that ...
17:37:28 <CrewdenX> Heffalump: and ghc and hugs are "reasonable" ?
17:37:49 <Heffalump> CrewdenX: I believe so.
17:37:52 <dons> I believe all Haskell compilers currently guarantee that.
17:38:08 <dons> see haskell@ some time in the last 3 years..
17:38:08 <Heffalump> of course you have to be a bit careful about what you mean by tail recursion.
17:38:27 <dons> yes...
17:38:29 <Heffalump> "f x = 1 + f (x-1) | f 0 = 0" isn't, for example
17:38:32 <Darius> CrewdenX: No serious implementation would not support it.
17:38:35 <Heffalump> s/|/;/
17:38:55 <Darius> (which I will admit is just a restatement of what Heffalump said)
17:39:06 <Heffalump> it's rather more definite, though :-)
17:39:29 <Darius> Heffalump: Actually it might be
17:40:26 <CrewdenX> heh, ok.  i just want to know whether or not i can design code such that operating on a list needn't take a linear amount memory.
17:40:40 <Darius> @wiki StackOverflow
17:40:41 <lambdabot> http://www.haskell.org/hawiki/StackOverflow
17:40:52 <Heffalump> can you give an example of the kind of code you're considering?
17:41:20 <CrewdenX> the same issue exists in scheme (or really anything where you rely on recursion), but scheme's spec actually makes statements about recursive optimization iirc.
17:41:29 <CrewdenX> Heffalump: nah, just code in general.
17:41:52 <Darius> Does the ML spec require TCO?
17:42:24 <CrewdenX> Darius: if you're asking me, i don't know.
17:42:52 <Heffalump> darius: I have a feeling it might, but I wouldn't swear to it
17:43:09 <Darius> Heffalump: Yeah, that's about where I am.
17:43:11 <rjbs> My reading of type classes is that they're like interface-providing mixins.  That is, in what they do, not in how they work or why they do it that way.
17:43:16 <rjbs> Am I vaguely on point?
17:43:17 <dons> CrewdenX: you end up with just: goto *(void *)target; in ghc.
17:43:47 <Heffalump> rjbs: I'm not sure where the 'mixins' idea comes from.
17:43:53 <Heffalump> they certainly provide an interface
17:44:44 <CrewdenX> dons: i'd need to look that up to kno exactly what it does, but it doesn't look pretty at first sight.
17:45:18 <rjbs> Heffalump: In Ruby, for example, I mix in Enumerable, which declares that a class provides enumerationo ver itself, which makes useful behaviors emerge when you know that the class is Enumerable.
17:45:40 <rjbs> Heffalump: In Haskell it seems that a type can be in a Class, indicating that it provides a defined interface, that lets the same behaviors emerge.
17:47:00 <Heffalump> the analogy is correct, but I'm not sure why that counts as a 'mixin'.
17:47:42 <rjbs> I wasn't trying to say it was like mixins in that they're mixed in, but in that they provide the same information; if I know that Int is in Num, it's like knowing that List is Enumerable.
17:48:20 <rjbs> I can't explain what I meant, maybe, but I have gained the knowledge I sought. :)
17:49:41 <Heffalump> ok :-)
17:58:41 <dons> how does one do block comments in scheme? is it (* *) ?
17:58:55 <CrewdenX> dons: {- -} ?
17:59:30 <CrewdenX> never, mind.  ithought i was reading "as in scheme"
18:00:01 <dons> nope. not {- -}. I'm asking for the scheme syntax.
18:00:16 <dons> I'm actually hacking a scheme file :/
18:00:28 <SamB> there is no block syntax
18:00:28 <CrewdenX> dons: i'm not sure that there is a way.
18:00:36 <CrewdenX> dons: at least in standard scheme.
18:00:41 <dons> blah. what's the single-line comment then?
18:00:46 <CrewdenX> dons: ;
18:00:58 <dons> ok. hacketty-hacketty-hack i go.
18:01:44 <dons> they're not big on comments in scheme-world?
18:02:40 <SamB> they are content to use columns full of ;s
18:03:25 <heatsink> It's customary to use ;; in block comments.
18:03:37 <heatsink> Of course the second semicolon doesn't do anything.
18:03:52 <dons> hehe.
18:04:30 <SamB> heatsink: well, besides telling emacs it is a block comment
18:04:46 <heatsink> true
18:04:50 * heatsink just built yi
18:05:07 <dons> heatsink: cool!
18:07:25 <Darius> Typically there are three levels of ;'s considered.
18:08:07 <Darius> You could also always run your code through CPP ;)
18:08:46 <dons> nah. just hacking a scm program to get it working for me.
18:08:51 <dons> need to comment out broken stuff
18:13:32 <CrewdenX> dons: scheme programers seem to delight in the small size of the scheme standard.  the lack of block comments probably has something to do with this.
18:14:58 <dons> hehe
18:16:10 <Pseudonym> shapr: You around?
18:16:26 <Pseudonym> Apparently not.
18:28:20 <Lemmih> SyntaxNinja: Ping.
18:29:35 <SyntaxNinja> y0
18:31:21 <Lemmih> How are Cabal handling stub files?
18:34:47 <Lemmih> bbiab.
18:40:25 <SyntaxNinja> stub files?
18:41:05 <SyntaxNinja> so their movie should end at around 9:30. they mentioned getting a drink afterward.
18:42:55 <SamB> CrewdenX: I doubt it. I don't recall Common Lisp having block comments either, and the standard is HUGE!
18:43:11 <CrewdenX> SamB: heh, true. =)
18:43:36 <SamB> of course, they could be in there, but if they are, nobody ever uses them ;-)
18:44:00 <CrewdenX> SamB: i seem to remember that they existed, but i always used ;.
18:44:38 <sh10151> cl has block comments in spades
18:44:53 <SamB> what do spades look like?
18:45:14 <SamB> are they some funky kind of bracket ;-)?
18:48:19 <bpalmer> the only block comments in CL I can think of are, hmm, #|  |#
18:48:20 <SyntaxNinja> er... I'm not insane, really. I just don't know how to use IRC
18:48:55 <Pseudonym> Spades are like hearts, only worth more in Bridge.
18:49:08 <bpalmer> because they are the suite of death!
18:49:18 <bpalmer> and death beats love any day of the week, in a manly game like bridge
18:49:24 <Pseudonym> Actually, death is in the other Arcana.
18:49:25 <SamB> well, still, like I said, nobody ever uses them ;-)
18:50:10 <bpalmer> isn't ace of spade the death card?
18:50:56 <SamB> Ah yes, I see. Section 2.4.8.19. It is even nestable.
18:51:09 <SamB> but it is unfortunately rather ugly
18:58:31 <Pseudonym> Sounds like an after-thought.
19:03:05 <Lemmih> SyntaxNinja: Helper files GHC generates when using, eg., foreign import "wrapper"s.
19:03:25 <CrewdenX^2> SamB: http://www.lispworks.com/documentation/HyperSpec/Body/02_dhs.htm     did someone point this out while i was gone?
19:04:05 <SamB> CrewdenX^2: um, sort of.
19:04:09 <CrewdenX> SamB: ok.
19:04:25 <CrewdenX> SamB: i don't remember them being like that, but that's apparently at least one way to do it.
19:04:33 <SamB> Someone mentioned the syntax, and I found the section in my local hyperspec
19:04:38 <SyntaxNinja> Lemmih: I don't know what handling would be necessary?
19:04:56 <SyntaxNinja> ghc generates them automagically, right?
19:04:59 <CrewdenX> SamB: ok.
19:05:16 <CrewdenX> SamB: i got disconnected, so i couldn't be sure.
19:07:00 <Lemmih> SyntaxNinja: Yeah but they don't seem to be packed in the .a library file.
19:08:46 <SyntaxNinja> do they need to be? they don't supply the symbols, just the headers, right?
19:10:15 <Lemmih> SyntaxNinja: They also contains functions.
19:11:23 <SyntaxNinja> hmm. sounds ugly. that's not how I thought they were supposed to work... could you post a bug report to libraries@?
19:12:25 * Lemmih applies 's/bad grammar/good grammar/' to all his sentences.
19:16:29 <Lemmih> Well, I'm not really sure what role Cabal should play is this matter.
19:17:17 <SamB> Lemmih: have you figured out the regular expression for 'bad grammar' yet?
19:18:24 <SyntaxNinja> Lemmih: well, if they need to be linked in to make sense, then cabal definitely needs to link them in.
19:18:26 <Lemmih> SamB: I leave that to the native English speakers. (:
19:19:34 <Lemmih> SyntaxNinja: But figuring out which modules generates stub files is kinda hard (GHC specific maybe?).
19:20:23 <Lemmih> Maybe naming them yourself is the way to go.
19:22:29 <SyntaxNinja> Lemmih: like with a new field?
19:22:32 <SyntaxNinja> we could just look for _stub?
19:23:19 <Lemmih> SyntaxNinja: Putting them in c-sources is easy but somewhat crude.
19:29:18 <gzl> every time I :l one of my .hs files, ghci compiles a whole bunch of related files. is there any way to avoid doing this every single time?
19:30:36 <Lemmih> gzl: Compile them with GHC.
19:33:27 <gzl> ok.
19:35:17 <gzl> ah, much better. thanks.
19:37:38 <gzl> anyone familiar with HaXml? it has strangely formatted output
19:37:52 <gzl> i.e. it inserts a newline in the *middle* of an XML tag
19:38:16 <SamB> gzl: yes. this is so the whitespace won't change the meaning of the XML
19:38:44 <SamB> Regardless of whether whitespace does anything in that context or not
19:39:01 <gzl> so how does the newline help that?
19:39:16 <SamB> the newline is just to look nice
19:39:35 <monochrom> newlines look nice? :D
19:39:46 <SamB> You would prefer all the elements smashed together on a single line?
19:39:48 <gzl> no
19:39:51 <gzl> but it's doing this:
19:39:53 <gzl> <TAG
19:39:54 <gzl> >
19:40:08 <gzl> I'm not sure we're talking about the same thing
19:40:17 <SamB> Admittedly it looks a bit odd alone
19:40:48 <monochrom> I see.
19:40:54 <gzl> it looks really odd in a whole file too
19:41:08 <SamB> Most people put them outside the tags, but outside the tags it affects the infoset
19:41:18 <gzl> yeah, most put it outside
19:41:35 <monochrom> <tag\n>hello</tag>  and   <tag>hello</tag>  are clearly equivalent.  The former probably is better when you have something longer.
19:41:56 <SamB> HaXml isn't smart enough to know when such infoset changes will make a difference, so it puts the minside the tags.
19:42:01 <monochrom> OTOH <tag>\nhello</tag>  looks nice for long stuff but is something potentially different.
19:42:25 <gzl> hmm, ok, I didn't realize the location of the whitespace could cause so many problems
19:42:56 <SamB> well, probably not many, but enough to have bothered someone, obviously ;-)
19:56:35 <gzl> hmm
20:00:11 <gzl> so if you want to check if a tag contains some text, are you just supposed to do something like if (foo == (keep /> tag "bar" /> txt)) then ... ? I think I'm misunderstanding how to use these combinators
20:00:46 <heatsink> what module are you using?
20:00:50 <gzl> haxml
20:01:38 * heatsink looks at haxml to satisfy its curiosity
20:02:03 <gzl> it seems neat, but it's kind of confusing.
20:03:55 <heatsink> your use of keep is ill-typed.
20:04:45 <heatsink> oh, no it's not.
20:05:13 <gzl> well, they keep giving this example of code like: keep /> tag "foo" /> txt, but I can't get it to actually produce any output on this sample XML document I have.
20:05:33 <heatsink> (keep /> tag "bar" /> txt) is a combinator, so you won't be using the == operator on it.
20:05:49 <gzl> hm, yeah.
20:06:42 <gzl> well, forget that, actually. I'm confused about how to even do anything with just (keep /> tag "bar" /> txt). so this should be searching only the top level tag and returning its text-only children if the tag is named "foo"?
20:06:47 <gzl> er, "bar"
20:07:36 * desrt hugs random people
20:07:41 <gzl> the part about the "top-level tag" seems to be wrong, but i can't think of why else this thing isn't returning any output.
20:09:18 <heatsink> I'm confused about why CFilter :: Content -> [Content].
20:09:33 <heatsink> rather, CFilter = Content -> [Content].
20:09:33 <desrt> it's a non-deterministic filter.
20:09:40 <desrt> O_o
20:09:44 <heatsink> multiple possible results?
20:09:50 <heatsink> like readS?
20:09:51 <desrt> i made that up.  i might be lying.
20:09:57 <gzl> yeah multiple results
20:10:02 <desrt> but that seems probable
20:10:11 <gzl> er, i think.
20:10:37 <gzl> yeah, multiple results.
20:11:50 <heatsink> Can you check the source for the definition of keep?
20:12:03 <heatsink> is it keep a = [a]
20:12:15 * heatsink doesn't feel like downloading anything
20:13:12 <gzl> yeah, one sec.
20:13:34 <gzl> well, keep is just identity
20:13:45 <gzl> just returns the item it's on
20:14:53 <heatsink> but keep is not a -> a
20:15:11 <gzl> it's CFilter
20:15:22 <heatsink> I know that.
20:16:50 <gzl> yeah, you're right. keep a = [a]
20:17:23 <desrt> keep = return
20:17:31 <gzl> ah, yeah.
20:17:34 <heatsink> okay.
20:19:03 <heatsink> So, most of the tests only test a single tag.
20:19:11 <gzl> yes.
20:19:21 <heatsink> If you want to search the entire document, you can apply the deep combinator.
20:19:26 <gzl> right.
20:20:19 <heatsink> I think the use of keep in the above example is redundant.
20:20:48 <gzl> it seemed like that to me too
20:21:12 <heatsink> (tag "bar" /> txt) should always return nothing, because text elements do not have tags.
20:21:17 <gzl> however, it's not redundant
20:21:46 <heatsink> what is the difference?
20:22:12 <gzl> the reason (i think) is that adding the keep makes the (tag "foo") search subtags of some tag rather than top-level tags
20:22:36 <gzl> you end up searching a different set of tags, so you do need the keep
20:23:00 <heatsink> that doesn't make sense with the definition of keep.
20:23:12 <heatsink> Isn't the subtag-searching done by the 'children' combinator?
20:23:16 <gzl> yes
20:23:22 <gzl> here, this is what the article says
20:23:43 <gzl> txt `o` children `o` tag "artist" `o` children `o` tag "album" is equivalent to keep /> tag "artist" /> txt
20:23:53 <gzl> album is a top-level tag
20:24:51 <heatsink> oh, I didn't look at the definition of />
20:25:02 <gzl> yeah, /> does "interior search"
20:25:55 <gzl> but now, I have a certain string of combinators (just call it 'f') that returns "<TITLE>blah</TITLE>". shouldn't f /> txt return "blah" according to this?
20:26:10 <gzl> (f /> txt), to be clear
20:26:16 <heatsink> yes
20:26:28 <gzl> ok, good, but it doesn't
20:26:34 <gzl> hmm, let me see
20:26:38 <heatsink> what does f `o` children do?
20:27:00 <gzl> children `o` f, but checking
20:27:13 <gzl> it says produced more than one output
20:28:21 <heatsink> (fst . children `o` f)
20:29:09 <gzl> that won't typecheck
20:29:12 <heatsink> You had a good understanding of haxml already, but I'm catching up.
20:29:25 <gzl> no, i have no idea what i'm doing :)
20:30:43 <heatsink> oh, duh. Don't use fst. Use head.
20:31:02 <gzl> that's what I had tried
20:31:03 <gzl> originally
20:31:24 <gzl> it didn't typecheck the way I had tried it, let me try again
20:32:11 <gzl> oh, i see
20:34:16 <gzl> dammit, still no cigar
20:34:37 <gzl> just doing (head . children) `o` f doesn't typecheck because it wants Content -> [Content] and I'm giving it Content -> Content
20:35:00 <gzl> I tried something that was way too nasty to be correct, and that didn't work either ;p
20:36:07 <heatsink> I think what you need to do is take (children `o` f), take the head, and make a list out of that
20:36:21 <heatsink> So ((\x -> [x]) . head . (children `o` f))
20:37:08 <gzl> doesn't this seem way too complex to be right? it should have built-in combinators to do this stuff
20:37:28 <gzl> i'm trying to do something fairly simple in the grand scheme of XML parsing
20:37:29 <heatsink> oh yeah. take 1
20:38:28 <gzl> haha
20:38:32 <gzl> still no
20:39:02 <heatsink> Hmm, I don't understand this.
20:39:50 <gzl> neither do I!
20:40:08 <heatsink> Are you displaying the data with 'show'?
20:40:33 <gzl> there are some provided functions that run the filter on the appropriate data
20:40:53 <gzl> it ends up doing a putStrLn
20:40:59 <gzl> of all the output
20:41:34 <gzl> but this stuff doesn't even typecheck
20:42:08 <gzl> what's even more annoying is that these are code snippets given in the article (e.g. (keep /> tag "foo" /> txt))
20:42:37 <heatsink> Do you have a link ot the article?
20:42:55 <gzl> http://www.cis.upenn.edu/~bcpierce/courses/advprog/resources/haxml.pdf
20:43:28 <heatsink> helping people is a great way to learn how to program in haskell. :)
20:43:48 <gzl> heh i appreciate that you're so willing :)
20:47:45 <heatsink> So... (take 1 . (children `o` f)) didn't work?
20:55:21 <gzl> no
20:56:36 <heatsink> and children `o` f reports "more than one output".
20:57:42 <gzl> yes
20:57:51 <gzl> even though it clearly does not have more than one
21:00:27 <shapr> shazam!
21:00:30 <heatsink> I'd like to see what children `o` f produces.  Try printing the result of that combinator with (\x -> trace (verbatim x) x)
21:00:52 * heatsink turns into a duck in a puff of blue smoke
21:00:57 <shapr> whoa cool
21:01:06 <shapr> what's the counter-spell?
21:01:17 <gzl> i'll try that, one sec. shapr, you ever used haxml?
21:01:27 <heatsink> *wak*
21:01:29 <shapr> Yeah, a bit.
21:01:32 <Pseudonym> shapr: Still time to submit my article?
21:01:35 <shapr> heatsink: right, I'll try that.
21:01:40 <shapr> *wak* !
21:01:52 * heatsink turns back into a heatsink
21:01:56 <Pseudonym> I realise it's Tuesday your time, and you said Monday.
21:02:02 <heatsink> ...whoah...
21:02:02 <shapr> Man, gotta watch those magic words.
21:02:04 <gzl> ok. I have a combinator 'f' that returns "<TITLE>blah</TITLE>". I tried stuff like f /> txt to get "blah" and various other things, but nothing seems to work.
21:02:11 <shapr> It's like waving around a shotgun.
21:02:21 <shapr> Pseudonym: yes definitely!
21:02:30 <heatsink> yea.
21:02:35 <Pseudonym> OK, what's the best delivery mechanism?
21:02:46 <Pseudonym> If I set up a darcs repository, can you pull it?
21:02:48 <gzl> shapr: so any ideas would be appreciated. finding it pretty confusing so far :(
21:02:48 <shapr> um, email I guess
21:02:50 <shapr> sure darcs is fine
21:02:54 <Pseudonym> Or email?
21:03:13 <Pseudonym> darcs gives me a chance to incorporate editorial changes.
21:03:20 <shapr> yup, I agree.
21:03:29 <Pseudonym> OK, now I need to work out how to publish a darcs repository... :-)
21:03:41 <shapr> make it http accessible and I can grab it.
21:04:49 <gzl> haha
21:04:51 <gzl> hahaha
21:05:01 <shapr> ?
21:05:12 <gzl> i just figured out what i was doing wrong
21:05:22 <gzl> and it's sort of stupid in retrospect
21:05:43 <shapr> heatsink: good morning! how ah yah?
21:05:59 <heatsink> doing okay.
21:06:06 <heatsink> gzl: What did ya fix?
21:06:14 <heatsink> and yourself?
21:06:34 <gzl> heatsink: if you wrap the result of that in a tag, it displays properly. e.g. mkElem "HTML" [keep /> tag "FOO" /> txt]
21:06:37 <shapr> It's 6am and it's getting light already, the winter is over! w00!
21:06:40 * shapr does the happy dance
21:06:44 <gzl> heatsink: it doesn't know what to do with just a string
21:07:06 <gzl> so it must be thinking there are too many results because it's a list of characters or something
21:07:34 <heatsink> Well, txt is also a CFilter
21:08:40 <heatsink> so it's returning xml elements, but they would be CString instead of CElem.
21:09:04 <heatsink> hmm, and you're in sweden...
21:09:18 <heatsink> wait. Where are you?
21:09:20 <gzl> me?
21:09:24 <heatsink> shapr
21:09:28 <gzl> ok
21:09:40 <shapr> Yes, I'm in the north of Sweden.
21:10:13 <gzl> hmm, now the question is, how do you search for plain text instead of tags?
21:10:43 <heatsink> gzl: Doesn't txt do that?
21:10:53 <shapr> heatsink: and you're in michigan?
21:11:03 <heatsink> shapr: no, but close.
21:11:20 <gzl> no, what I mean is, do something like (txt "blah") analogous to (tag "blah")
21:11:22 <heatsink> Days are getting longer here too.
21:11:28 <gzl> do some kind of matching on the plaintext
21:11:38 <gzl> txt will return a plaintext item
21:11:51 <heatsink> But it doesn't make such a big difference this far south.
21:11:58 <heatsink> oh
21:12:13 <gzl> there doesn't seem to be any kind of general predicate matching
21:13:22 <heatsink> If you have a predicate function, you can make your own combinator
21:13:53 <heatsink> myCombinator elem = if myPred elem then keep else none
21:14:06 <gzl> mm
21:15:15 <heatsink> And there are combinators in the library if you want to match a text string exactly.
21:15:56 <gzl> must have overlooked them
21:17:01 <SamB> huh, the excellent rng-validate-mode tells me that HaXml's example/album.xml doesn't match its DTD
21:21:29 <gzl> heatsink: referring to ifTxt?
21:21:34 --- topic: set to '["Learning Haskell - http://haskell.org/learning.html","See logs @ http://meme.b9.com/cdates.html?channel=haskell","related channels #haskell.se #haskelldb #darcs","Haskell eZine! http://haskell.org/hawiki/TheMonadReader","http://haskell.org/cabal/","http://sequence.complete.org/","Haskell is the language of choice for discriminating hackers! - ICFP contest 2004","We put the Funk in Funktion"]' by shapr
21:21:38 <heatsink> gzl: yes.
21:24:45 <gzl> hmm
21:27:46 <gzl> that's not quite the same though
21:30:17 <gzl> ifTxt doesn't match a text string, it just lets you run one filter if the current item is text and another if it's not
21:32:46 <heatsink> yea, i guess u right.
21:33:20 <heatsink> roll your own, I guess.
21:33:26 <gzl> yeah, I guess
21:38:59 <gzl> nice! works.
21:39:09 <heatsink> rock on.
21:53:51 <gzl> nuts
21:53:59 <Pseudonym> Where?
21:54:31 <gzl> it's buried under my huge pile of garbage. i mean code.
21:57:51 <shapr> Today I get my first commercial deployment of Haskell code I wrote.
21:58:14 <Pseudonym> Woohoo!
21:58:30 * shapr dances cheerfully.
21:58:32 <Cale> shapr: what did you write?
21:58:41 <heatsink> oh, nifty.
21:58:47 <Pseudonym> A very short "cat" program.
21:59:25 <shapr> I wrote Curryspondence. My clients said "which mailing list is most used" and I said "mailman" and they said "Is there also software that lets you search mailing list archives?" and I said "I wrote some in Haskell" and they said "We want that."
21:59:42 <Pseudonym> Woohoo.
22:00:11 <heatsink> So it kinda just fell into place.
22:00:13 <shapr> It's amazing, if you write software that fills a need, people use that software.
22:00:51 <shapr> I don't know of any mailman searching software other than Curryspondence.
22:01:36 <shapr> Now I just have to find a few more needs that are empty and write some more software...
22:01:43 <shapr> heatsink: how's code at your end?
22:02:51 <heatsink> I'm taking a break from coding for about two weeks.  Qualifying exam coming up.
22:03:04 <gzl> ok. the following code works when there's one occurrence of the tag "foo" but not multiple ones. any ideas?
22:03:51 <gzl> mkElem "XML" [deep (tag "foo") </ (tag "bar" /> (matchtxt s `o` txt))]
22:05:16 <heatsink> gzl: use multi instead of deep
22:06:21 <shapr> Crap, wikipedia is down.
22:06:23 <gzl> noe
22:06:24 <gzl> * nope
22:06:47 <gzl> hmm wait a minute. my original code works on some other foo here that has multiple occurrences
22:06:51 * gzl scratches head
22:06:52 <gzl> but not the one I want
22:07:26 <shapr> Cale: written any code lately?
22:07:44 <shapr> heatsink: Is a qualifying exam the kind of thing that gets you into a Ph.D. if you pass?
22:08:02 <dons> they have qualifying exams now?
22:08:11 <shapr> heckifIknow
22:08:22 <Cale> shapr: nothing too serious -- I'm in school at the moment
22:08:32 <heatsink> shapr: yes.
22:08:46 <dons> shapr, hey, got supervisor perms. to work on hs-plugins flat out (as we say down here).
22:08:50 <dons> hence yi should get some kicks
22:08:56 <gzl> heatsink: multi returns content at all levels of the tree, which isn't what's needed here
22:09:04 <shapr> dons: w000
22:09:05 <gzl> in this case it'll do the same thing as deep
22:09:20 <dons> got to make eval faster.
22:09:34 <shapr> dons: When you get synhl working, I'm building my pyre of elisp.
22:09:55 <shapr> Means I'll probably be off IRC for a few days till I get lambdabot ported over to yi for an irc client.
22:10:06 <dons> hehe.
22:10:14 <heatsink> gzl: I get from the definition of deep that it only returns the first result.
22:10:21 <Pseudonym> :-)
22:10:26 <Pseudonym> Well get TMR out first
22:10:27 <dons> shapr: probably munge hircules in, right -- it uses the same ncurses binding.
22:10:31 <heatsink> heh.
22:10:40 <shapr> Does it? I thought hircules did gtk+hs ?
22:10:56 <dons> hmm. what's j.meachams irc client.. oh, ginsu!
22:11:00 <heatsink> oh, where in the source does synhl reside?
22:11:11 <dons> it's outside the src atm :(
22:11:13 <gzl> heatsink: it doesn't, I've tested it
22:11:20 <heatsink> oh.
22:11:21 <shapr> imaginator: hiya, learning to imaginate in Haskell?
22:11:27 <gzl> heatsink: it returns every match
22:11:37 <shapr> Pseudonym: truly, TMR first.
22:11:55 <gzl> heatsink: and I'm using it on two different sets of identically structured tags and getting different results, very annoying
22:12:12 <imaginator> shapr: hi.  just mostly curious now.
22:12:42 <shapr> imaginator: you want the short intro to both #haskell and Haskell?
22:13:09 <heatsink> gzl: try it on <xml>  <foo><bar>abc</bar></foo>  <foo><bar>def</bar></foo>  </xml>
22:13:17 <heatsink> gzl: I predict it will only return abc.
22:13:57 <imaginator> shapr: no thanks.  I think you told me that last time (months ago).
22:14:11 <shapr> ah, ok
22:14:32 <shapr> If you have any questions, feel free to ask.
22:14:39 <imaginator> thank you
22:16:07 <gzl> heatsink: just fixed it
22:16:32 <heatsink> gzl: what was the fix?
22:16:33 <gzl> heatsink: I think some spacing was throwing it off or something, I just rewrote the line
22:16:58 <gzl> i had been commenting and uncommenting stuff, i must have enabled one older line and broken the new one or something
22:17:02 <gzl> who knows
22:17:07 <heatsink> okay.
22:17:34 <gzl> you're sort of right, but for the code I'm writing, I can assume that some of these tags only show up at a certain depth.
22:17:51 <Pseudonym> OK, must head off.
22:17:53 <Pseudonym> Nytol!
22:17:55 <shapr> g'night Pseudonym
22:18:01 <Pseudonym> Enjoy the rest of the IRC session.
22:18:04 <gzl> and moreover that each tag only shows up at one depth, so you won't have stuff like <foo><bar> as well as <bar><foo>
22:18:07 <heatsink> night speudo.
22:18:53 <shapr> konichiwa seidan-san
22:18:58 <heatsink> Your solution fits that.
22:19:14 <seidan> shapr: hi.
22:19:24 <gzl> heatsink: yeah.
22:19:39 <shapr> seidan: how's code?
22:20:36 <seidan> shapr: not coding today :-( Today is a CAD day. Just thought I'd see what discussions were going on.
22:21:59 <shapr> dons: so what's the game plan? speedy eval first?
22:22:30 <shapr> seidan: do you have one of those nifty magellan zillion-button 3D-trackballs?
22:23:29 <seidan> shapr: no, a thinkpad with a trackpoint (or whatever it's called). Good old pencil and paper followed by 2d cad drawings.
22:23:31 <seidan> :)
22:25:23 <shapr> I've wanted to try one of these, but they're a bit expensive. - http://www.3dconnexion.com/spaceball5000.htm
22:31:56 <seidan> shapr: wow. impressive. The supported apps ar epretty expensive looking too :)
22:32:19 <shapr> Yeah, I do wish for an affordable 3D controller.
22:32:27 <shapr> Even better, an affordable glove.
22:34:50 <monochrom> need... a... telepathic... probe...
22:35:16 <monochrom> nothing beats having the computer know what I mean!
22:35:32 <gzl> hmm
22:35:35 <monochrom> I can even do away with all these programming languages!
22:35:39 <seidan> shapr: actually I wasn't doing cad. I was still at the pencil and paper stage. Now I'm reading "Categores for the Working Mathematician".
22:35:54 <seidan> *categories*
22:35:56 <gzl> heh, that's a lot of categories
22:36:09 <heatsink> monochrom: just be careful when programming goal-directed behavior into the computer.
22:36:53 <heatsink> A mind-reading computer that generates its own commands is a bad idea.
22:37:17 <LinkMasterSab> Yes, it could kill us all.
22:38:21 <shapr> Or maybe even set up a successful comedy show.
22:40:49 <gzl> heatsink: how can one do the equivalent of (keep </ chip f) ?
22:41:16 <gzl> chip by itself works fine, but if you use it with </ then the results of the application get thrown out
22:41:38 <heatsink> hmm
22:42:28 <gzl> hmm
22:42:56 <gzl> nm that was stupid
22:43:34 <gzl> yeah, I was trying to come up with a modified version of </
22:43:39 <gzl> but that didn't seem promising
22:44:06 <heatsink> What should it do?
22:45:08 <gzl> i wasn't sure how to define it. basically, it doesn't work with chip, because chip is making modifications in-place, but when you return the outer structure, that stuff gets thrown away
22:46:25 <heatsink> nothing makes modifications in-place in haskell.
22:48:17 <gzl> well, ok. it applies f to all the children and then rebuilds the outer structure with the new children.
22:49:50 <gzl> but it's only temporary since when you go back up to the outer structure, that stuff gets thrown out. i guess that agrees with the fact that the modifications aren't done in place
22:50:01 <heatsink> right.
22:50:58 <gzl> ok, good to confirm that fact. on the other hand it still leaves me nowhere :)
22:50:59 * gzl scratches head
22:51:33 <heatsink> Did you want to run your situation by the room?
22:52:05 <gzl> i'll think about it again for a little bit, then ask again if i don't come up with anything.
22:56:02 <heatsink> hmm... combinators are adverbs!
22:56:09 <shapr> yup
22:56:24 <heatsink> that's why they're so easy to udnerstand.
22:57:07 <shapr> Though writing a combinator library from scratch is hard.
22:57:21 <heatsink> over on the conlang list, sometimes proglang discussions crop up.
22:58:38 <gzl> ok. so I want to do the equivalent of (keep </ chip f), which would essentially take the whole XML tree, apply f "in place" to all the children of the root node, and then return the whole tree. the problem is that doing (keep </ chip f) returns an unmodified tree, because chip's modifications to the children are thrown out when the outer structure is returned.
22:59:02 <gzl> i'm not really sure how to work around that after looking through the various combinators available
22:59:23 <heatsink> gzl: you have to build a new tree that is the same as the old tree, except with the children of f changed.
22:59:33 <gzl> right. but does that need to be done manually?
22:59:47 <heatsink> you can apply chip recursively.
22:59:58 <shapr> heatsink: John Cowan being the best of both worlds.
23:00:19 <heatsink> what does cowan do in the programming department?
23:00:40 <gzl> applying chip recursively would chip every level of the tree though
23:00:55 <heatsink> gzl: Look at the definition of deep or multi (depending on your application) and figure out how to write a similar combinator to use chip.
23:01:11 <shapr> Cowan did one of the Joy implementations, and he's done a bunch of other stuff I can't think of...
23:01:17 <gzl> ah, so I do have to write a new combinator. ok
23:01:37 <heatsink> gzl: or look just under multi...
23:01:53 <gzl> yeah, that's where i am. thanks
23:02:27 <heatsink> can you see how it works?
23:03:55 <heatsink> shapr: I am surprised and pleased to recognize a name from the conlang community here.
23:04:20 <gzl> heatsink: sort of, still reading
23:06:18 <shapr> heatsink: I think those two communities are not so separate, I'm a big fan of lojban, though not a heavy user.
23:06:38 <shapr> I'm interested in exploring expression in all its forms, spoken human languages is one of those.
23:07:16 <shapr> Being a fan of tolkien's languages isn't so unusual in the programming language community.
23:07:42 <heatsink> Or the geek community. ;p
23:07:47 <shapr> True
23:08:27 <heatsink> Yea, programming is such a linguistic phenomenon.
23:08:40 * heatsink hasn't worked on its conlang in a long time.
23:11:21 <dons> shapr, I'll try to get syn hl in. but I also need to work on the speedy eval, so that scripting yi is a bit less heavyweight.
23:11:34 <desrt> dons; any progress on -j stuff?
23:11:55 <dons> nope, not since last night.
23:12:45 <dons> trying to get a new hs-plugins vers. out the door.
23:12:54 <desrt> k.
23:15:11 <heatsink> It's time to get some sleep; goodnight.
23:24:35 <desrt> how should i impliment a 2D array?
23:26:59 <desrt> is a tuple a suitable Ix?
23:27:58 <Cale> desrt: yes, if the components are Ix
23:28:11 <desrt> will i get any slowdown, though?
23:28:44 <Cale> worry about that when your code runs slowly
23:29:06 <Cale> (or are you already having trouble optimising something?)
23:29:15 <desrt> still at the thinking phase
23:29:22 <desrt> i might not even need arrays
23:29:31 <desrt> i'm writing a program that deals with multiplying matricies
23:29:38 <Cale> ah, okay
23:29:43 <desrt> but i realised that it actually just deals with thinking about how coconut will deal with matricies
23:30:20 <shapr> greetz Si\
23:31:00 <Si\> morning
23:31:27 <shapr> How's the nuts from the middle east?
23:31:41 <shapr> Ahem, before anyone misinterprets that, "cashews from haifa"
23:37:02 <Si\> about in the same position it was last time I spoke to you ;)
23:37:31 <shapr> heh, ok
23:39:20 * autrijus forks parsec.
23:39:59 <autrijus> in particular so it can be used as a monad transformer.
23:44:08 <shapr> oh that sounds like a neat project.
23:44:30 <shapr> Also, there are a bunch of Parsec extensions people have come up with over the years that never get put into the final product.
23:45:18 <shapr> I was thinking of an arrow-style parser combinator lib called Parrowt
23:45:30 <shapr> or maybe Parrowdee
23:45:48 <shapr> ParrowT ?
23:46:07 <autrijus> ...
23:46:09 <autrijus> PArrowT
23:46:18 <shapr> right, good point.
23:46:38 <fraxtal2> ParroT
23:46:38 <gzl> hmm
23:46:51 <gzl> now that I'm sort of getting the hang of it, this haxml thing is kind of neat
23:47:26 <shapr> Wait till you check out HXmlToolbox
23:48:04 <shapr> It's neat in a different way, it uses a generic tree type, DTDs checks are a separate step, making arbitrary changes simpler.
23:48:43 <gzl> hm, ok
23:49:06 <gzl> I haven't looked at the haxml stuff about treating DTDs as algebraic data type declarations, only the combinator library
23:49:25 <shapr> Of course, a parser library named PArrowT would encourage jokes about pining for the fjords.
23:50:35 <gzl> please don't name it PArrowT. :)
23:50:55 <shapr> Why now?
23:51:04 <shapr> er, why not?
23:51:13 <shapr> Parser Arrow Transformer
23:51:33 <gzl> Parser Arrow Transformer is fine. but "PArrowT" looks ugly.
23:52:03 <shapr> I really like cheesy names like that. Curryspondence, Paskalle, etc
23:52:23 <shapr> PArrowTee? like pardoy?
23:52:27 <gzl> those are cheesy but not an eyesore. i think the capitalization and stuff just makes PArrowT look gross.
23:52:28 <shapr> um parody?
23:52:36 <gzl> yeah, that's fine :)
23:52:46 <shapr> With all the caps?
23:52:50 <gzl> it's more the visual configuration of the letters
23:52:51 <gzl> yes
23:53:09 <shapr> I dunno, I still like PArrowT.
23:53:25 <shapr> Of course, if wrote something like that first, I would have no reason to write it myself.
23:53:30 <shapr> And then would have no influence on the name.
23:53:49 <shapr> Ah the wonders of open source.. pain-oriented programming.
23:54:24 <shapr> Anyway, I'll probably have time to write PArrrowT next century, so you're safe.
23:55:00 <gzl> haha
23:59:25 * Lemmih is so frustrated.
23:59:55 <Lemmih> Faulty hardware is pure liquid evil!
