00:06:15 <shapr> vincenz: haven't you ever wanted to learn the language that attracts so many cool people? :-)
00:06:31 * shapr proselytizes vincenz 
00:06:34 <vincenz> ?
00:07:22 <shapr> I'm just teasing you about the fact that you use OCaml, but are part of the #haskell community :-)
00:07:45 <vincenz> if I had time..
00:07:51 <shapr> Of course, I live in Sweden and I'm taking forever to learn Swedish, so I understand the feeling.
00:08:45 <vincenz> But as an expert webdesigner, you must know this
00:08:48 <vincenz> I don't want to use apache
00:08:50 <vincenz> I'm not root
00:08:55 <vincenz> I want a simple wiki for internal use
00:08:58 <shapr> I don't know of any wikis that have their own server, but you can ask on #wiki
00:09:01 <vincenz> ooh
00:09:25 <shapr> Or you could run any webserver on a >1024 port as your own user.
00:10:00 <shapr> I'd say I'm an experienced webdesigner, not an expert.
00:10:31 <vincenz> yeah I know...
00:10:35 <vincenz> just I don't want to mess with apache
00:10:39 <vincenz> ;/
00:10:46 <shapr> You could use the Haskell Web Server ;-)
00:10:56 <shapr> or twisted, written in Python...
00:11:00 <vincenz> just a nice little server app that runs on it's own and that I could possibly hack
00:11:04 <vincenz> twisted is quite big
00:11:44 <vincenz> I liked moin a lot, you could update jpgs/etc
00:11:56 <shapr> Moin works with any webserver that supports CGI
00:12:09 <vincenz> I know
00:12:13 <vincenz> which implies apache :P
00:12:24 <shapr> There are as many webservers as there are wikis.
00:12:35 <vincenz> I'm trying to keep the stuff I install on my /scratch to a minimum
00:12:40 <vincenz> less fuss is better
00:13:09 <sorje> http://freshmeat.net/search/?q=httpd ;-)
00:13:31 <sorje> sh-httpd
00:13:33 <sorje> Very small shell script Web server with CGI 1.1 interface.
00:13:37 <vincenz> *sighs
00:13:42 <sorje> hehe
00:14:35 <shapr> HWS supports cgi, though I don't know if CosmicRay's generic server stuff supports CGI.
00:14:51 <shapr> I wonder if CGI works over DNS.
00:16:22 <shapr> Has anyone here used Service Location Protocol? I was thinking about a cute hack that mixes SLP and BitTorrent for easy distribution of debs/rpms/etc
00:17:25 * vincenz sighs and
00:17:34 * shapr sighs or
00:19:03 <vincenz> I'm trying to get this installed quickly so I can go on with work but noone has offered any viable solutions
00:19:31 <shapr> Sometimes you have to search for solutions, rather than having them offered to you ;-)
00:20:45 <vincenz> I am searching
00:20:54 <vincenz> stop the zen bs
00:21:12 <shapr> no zen intended
00:21:17 * shapr meditates
00:21:35 * vincenz tunes out
00:21:48 <shapr> I thought it was tune in, drop out... what was the rest?
01:08:06 * shapr throws lambdas at Cale
01:08:47 * Cale is abstracted away!
01:09:13 <Cale> night
01:10:31 * shapr grins
01:10:56 <jlouis> is there a shorthand for ``import qualified List as List'' ?
01:11:18 <ozone> jlouis: import qualified List, i think
01:11:20 <vincenz> iqa List List
01:13:27 <jlouis> vincenz: huh?
01:14:04 <jlouis> ozone: perfect ;)
01:15:12 <shapr> g'day Svrog
01:15:18 <Svrog> hi shapr
01:15:28 <Svrog> how are you?
01:15:41 <shapr> Do you actually hear phrases such as "don't come the raw prawn" and "stone the crows" ever?
01:16:03 <Svrog> haha
01:16:08 <Svrog> this is the first time ive heard them :)
01:16:16 <shapr> Truthfully, I have a cold, and I'm irritable and whiny, but I'm trying to keep that from the notice of the people around me.
01:16:30 <Svrog> that sucks
01:16:52 <shapr> Builds up the immune system at least.
01:16:58 <Svrog> yeah
01:17:27 <shapr> How are you? Learning anything nifty?
01:18:39 <Svrog> im not bad - a bit frustrated with optimizing dynamic stack effects in a concatenative language.. there doesnt seem to be any trivial solution, not without giving up all the interesting properties of concatenative languages :(
01:19:03 <Svrog> also wondering about whether or not i should use c-- as a code generator for my language
01:19:33 <Svrog> which is actually the main reason i got on irc - to see if anyone had any experience with c-- and what was the experience like?
01:20:00 <Svrog> what does it compile to (i mostly need x86 and ppc machine code), and what is the generated code like
01:29:26 <jlouis> Is there an equivalent to SMLs String.concatWith :: String -> [String] -> String, where concatWith "," ["this", "that", "foo"] yields "this,that,foo"
01:29:43 <jlouis> in haskell, that is ;)
01:29:44 <shapr> Svrog: I know c-- does x86, not sure about ppc.
01:30:01 <shapr> @type concat
01:30:06 <lambdabot> concat :: forall a. [[a]] -> [a]
01:30:31 <Svrog> yeah i assumed it does x86 - i just downloaded the sources and im about to compile it
01:30:44 <shapr> Svrog: I think the next version of GHC, 6.4, will have a C-- backend.
01:30:51 <Svrog> ooh
01:30:53 <Svrog> interesting
01:30:57 <Svrog> must be good then
01:30:58 <mflux> hmm.. what's the point?
01:31:04 <shapr> Anyway, Simon Peyton-Jones is one of the big names behind C--
01:31:09 <shapr> mflux: of C--?
01:31:09 <Svrog> yes i noticed
01:31:17 <mflux> apparently google isn't quite compatible with names like 'c--'
01:31:22 <shapr> cminusminus.org
01:31:32 <jlouis> http://www.cminusminus.org/faq.html
01:31:46 <mflux> or generating code for it when c must be the more available platform
01:31:52 <mflux> s/^/f/
01:32:11 <jlouis> shapr: subtle difference. concatWith has another type than concat ;)
01:32:17 <mflux> oh, so c-- is something designed for that
01:32:19 <shapr> In short, people claim that C is just portable asm. SPJ et al say that a few minor changes can be made to C to make it even better as a portable asm, and you'll be able to use your existing C knowledge.
01:32:40 <shapr> jlouis: aha, you want ShowS
01:33:25 <shapr> ShowS is way cool. It exploits laziness to let you build a string like "foo" + "bar" + "baz" but never actually builds the string till you really use it.
01:33:31 <Svrog> hmm... i just read the faq about 10 minutes ago and missed the part right at the top where they say ppc backend is in the works..
01:34:15 <mflux> but, still, there already is c-backend and c is supported on virtually every platform.. would you expect a c-- backend to be simpler or be able to generate code of better quality?
01:35:14 <shapr> both
01:35:37 <Svrog> yes
01:35:38 <shapr> explicit support for tail recursion, well documented hooks to let you plugin your own GC, that sort of stuff.
01:35:45 <Svrog> yup
01:37:44 <Svrog> i wonder why was c-- written in ocaml rather then haskell considering simon peyton jones is behind it?
01:39:13 <shapr> Probably because SPJ has the goal of good solutions now.
01:39:46 <shapr> SPJ is a really cool guy. I met him at ICFP03, and he's not at all what I expected.
01:40:06 <shapr> He's brilliant, cheerful, bouncy, friendly, and he treats everybody like an equal unless they make a real ass of themselves.
01:41:09 <shapr> He didn't remember me even though we'd exchanged a few emails, and he seemed really upset that he didn't remember me. I guess I wasn't expecting someone so personable.
01:41:41 <Svrog> interesting
01:42:03 <jlouis> shapr: I do not want ShowS. I want an equivalent to concatWith seperator str = tail $ concatMap (seperator ++) str
01:42:38 <shapr> When he gave a talk at the Haskell Implementors Meeting, he took off his sandals and his sweater, untucked his shirt and was very enthusiastic and open to suggestions. I can see why he's a great leader.
01:44:25 <jlouis> Svrog: many people are working on C--. Therefore, ocaml might have been the choice initially
01:44:32 <jlouis> ocaml is a good language too
01:45:06 <shapr> jlouis: ohh, finally I see what you originally asked for.
01:45:32 <shapr> This is my punishment for hours of Python code today, inability to read Haskell.
01:45:58 <shapr> Maybe you could use intersperse and concat?
01:46:13 <shapr> Maybe zip and concat?
01:46:49 <shapr> like concat $ zip ["foo","bar","baz"] cycle ","
01:47:27 <shapr> er, that's not quite right :-)
01:48:17 <shapr> concat $ intersperse "," ["foo","bar","baz"]
01:48:33 <shapr> That one works.
01:48:44 <musasabi> I am trying to formulate a better socket binding in Haskell.. Would it make sense to make bind(2) and close(2) safe operations as they could block in some circumstances? Currently they are imported as unsafe functions and it is just hoped they won't block (which is the case for 90% of the time)...
01:49:25 <shapr> jlouis: is that what you want?
01:49:48 <jlouis> shapr: exactly
01:50:32 <shapr> musasabi: what does safe change?
01:50:34 <jlouis> concatWith2 sep str = concat $ Data.List.intersperse sep str
01:51:19 <musasabi> shapr: blocking behaviour.
01:51:34 <musasabi> and makes it quite a lot slower too.
01:51:37 <Svrog> jlouis: i know ocaml is a good language - its actually the language that i use the most.. although id rather use haskell or scheme
01:52:57 <vincenz> anyone fluent in semantics?
01:53:19 * vincenz is not sure on the difference between rule induction and structural induction
01:55:58 <musasabi> vincenz: structural induction is where you prove inductively things from parts of a sentence.
02:00:14 <musasabi> vincenz: e.g. the value of a sentence is: 1) if it is of the form p(i) => v(i). 2) if it is of the form \neg l and v(l) is true then false otherwise true. 3) if it is of the form (l -> m), if v(l) = false and v(m) true then v(l->m) = false, otherwise v(l->m) = true...
02:00:16 <musasabi> from propositional logic.
02:28:23 * vincenz nods
02:28:33 <vincenz> and rule induction?
02:28:49 <vincenz> so structural looks at the parts of the sentence not how they derive
02:32:06 <vincenz> Just I tried reading Winskel's book and quickly got bogged down
02:32:36 <vincenz> structural induction: induction on syntax, not semantics
02:32:41 <vincenz> rule induction: induction on semantics?
02:32:53 <vincenz> (then how is induction on derivation trees different from rule induction?)
02:40:37 <tic> have any of you guys used BNFC?
02:45:35 <ulph> Where did shapr go?
02:53:48 <Itkovian> ulph: to cross the road on his unicylce i think
04:56:45 <Lemmih> Good morning, Haskell.
04:58:45 <TheHunter> 'morning, Lemmih
05:23:07 <jadrian> renaming bound variables is a alpha what?
05:23:15 <jadrian> "transformation" (?)
05:23:25 <jadrian> alpha "renaming"
05:23:30 <jadrian> (?)
05:23:46 <Igloo> alpha renaming
05:23:53 <jadrian> thanks Igloo
05:24:08 <Igloo> /an/ alpha renaming, too  :-)
05:36:08 * Lemmih curses cmake's inflexibility to a place where the sun never shines.
05:57:32 <araujo> Hello here.
06:02:05 <araujo> How you doing CosmicRay ?
06:02:23 <CosmicRay> araujo: pretty good...  how 'bout you?
06:02:57 <araujo> CosmicRay, very well, thanks 8)
06:15:24 <CosmicRay> araujo: still working on that perl parser thingy?
06:16:08 <araujo> CosmicRay, me?, perl?!
06:16:23 <araujo> ive been able to stay away from it since a few yeras now 8)
06:16:45 <CosmicRay> hmm
06:16:51 <CosmicRay> I must have you confused with someone
06:16:56 <CosmicRay> me too :-)
06:17:16 <Lemmih> autrijus: You're the perl guy, right?
06:17:25 <CosmicRay> ah.
06:17:43 <CosmicRay> yes, I think that's right, lemmih
06:19:04 <araujo> 8)
06:19:12 <CosmicRay> sorry for the insult, araujo :-)
06:19:15 <araujo> haha
06:19:25 <araujo> you made me feel dirty for a sec
06:19:30 <araujo> ;-)
06:19:40 <CosmicRay> dammit, now I've insulted two people (if autrijus has scrollback) :-)
06:19:46 <araujo> haha
06:23:06 <Lemmih> I managed to compile gccxml with ghc. So now I can access its parse tree from Haskell.
06:23:48 <CosmicRay> Lemmih: wait, what is gccxml, and what does compiling it with ghc do for you?
06:24:50 <Lemmih> www.gccxml.org, ops s/compile/link.
06:29:15 <Lemmih> CosmicRay: I'm using it to parse C++ for Hacanon but it was too buggy. So instead of reading through 2.5kl of unreadble C, I intend to rewrite it in Haskell.
06:29:32 <CosmicRay> interesting
06:56:39 <CosmicRay> Lemmih: it ghc-xml would be cool to see
06:56:51 <CosmicRay> or some way to get at the ghc ast, if it has one
07:35:55 <Lemmih> @index bracket
07:35:57 <lambdabot> Control.Exception,IO
07:38:24 <shapr> CosmicRay: have you used SLP before?
07:38:53 <shapr> dude, wassup?
07:40:02 <CosmicRay> hey shapr
07:40:06 <CosmicRay> no, haven't used slp
07:41:43 <shapr> I looked at the interface, it appears that you register a string name with an associated list of string attributes. So I'm thinking "debian" "unstable" and the port of your local bittorrent feed for /var/apt/cache
07:42:13 <shapr> This sounds very easy to do, has someone already done this sort of thing?
07:42:45 <shapr> I guess it would require that apt-secure functions.
07:45:10 <CosmicRay> interesting
07:45:17 <CosmicRay> I don't think anyone has
07:45:24 <CosmicRay> topics like that come up periodically on debian-devel
07:45:40 <shapr> But no one has tried to make it work?
07:45:44 <CosmicRay> is this the fruit of your thoughts about multicasting?
07:45:48 <CosmicRay> I don't know
07:45:55 <CosmicRay> I don't think so, but there may be code someplace
07:45:58 <shapr> One of many connections about multicasting, yes.
07:46:09 <CosmicRay> cool :-)
07:46:31 <shapr> Also, it was nice to see that openslp has about six functions in its API, so maybe an irrigateway application could fly being written in Haskell.
07:47:21 <shapr> Too bad Da Ninja is offline, I could ask him about apt-secure.
07:47:50 <CosmicRay> hmm
07:47:59 <CosmicRay> does that work with repository signing or deb signing?
07:48:17 <shapr> signing of the Release file
07:48:21 <CosmicRay> ah
07:48:30 <CosmicRay> (which is repository signing basically)
07:48:30 <shapr> since it includes md5sums
07:49:11 <CosmicRay> right
07:54:49 <shapr> aj: hey, do you know if apt-secure works yet?
07:57:07 <shapr> bwaha, merkel.debian.org
07:57:48 <Igloo> ?
07:58:47 <shapr> I found an email where aj said "ssh merkel cat /org/ftp.debian.org/web/ziyi_key_2005.asc | gpg --import", and keeping the crypto keys on a box named merkel is perfect.
07:59:08 <shapr> Since all public key crypto is based on Merkel's Puzzles.
07:59:35 <shapr> Igloo: I know, likely an old joke for you, but new for me.
07:59:54 <shapr> Igloo: do you know if apt-secure works?
08:01:08 <Igloo> Ah. Only Merkle is the web is to be believed
08:01:16 <Igloo> I don't
08:01:57 <ibid> shapr: how has it not worked?
08:02:12 <ibid> shapr: the new ziyi key has been out for ages
08:02:19 <ibid> (at least a week or two:)
08:02:56 <shapr> yes but, how do I get my client-side apt to *require* signage?
08:03:10 <ibid> use experimental apt
08:03:16 <ibid> 0.6
08:03:19 <CosmicRay> hmm.  Do you think it will be a problem to have a module that imports 842 other modules?
08:03:41 <shapr> Is experimental apt like fornicating without a condom, or is relatively safe?
08:03:42 <ibid> it doesn't require, really, but it does scream loudly when there are bad or missing signatures
08:03:53 <CosmicRay> heh
08:04:21 <shapr> Why isn't apt-secure in unstable?
08:04:37 <ibid> apt-secure is no longer
08:04:43 <ibid> it's regular apt
08:04:47 <ibid> just in experimental
08:05:02 <ibid> and it's there because we're releasing any day now
08:05:12 <shapr> after which point it'll be in unstable?
08:05:16 <ibid> and have been releasing any day now for close to a year
08:05:25 <ibid> shapr: likely shortly after sarge releases
08:05:43 <ibid> shapr: i've used the experimental apt for months without problems
08:06:19 <shapr> I can't really afford to hose my desktop for even a few days.
08:06:36 <ibid> too bad aptitude isn't perectly integrated with the signing code
08:06:45 <ibid> shapr: why are you running unstable, then?
08:07:00 <shapr> because, I've been running unstable for years without hosage.
08:07:16 <ibid> shapr: why do you expect experimental to break it?
08:07:36 <shapr> Because I don't know the difference between the two, and experimental sounds a lot scarier than unstable.
08:07:49 <ibid> the difference is mainly in that experimental is stuff that cannot be put to unstable yet, and for many packages such as apt that's just an artefact of the delayed release process
08:08:15 <ibid> there are, of course, packages in experimental that will likely break your system
08:08:28 <ibid> but that's why everybody just takes those packages they want from experimental
08:08:49 <ibid> apt pins experimental below unstable, testing and stable by default
08:09:04 <ibid> you won't get anything from experimental without explicitly asking for it
08:09:18 <shapr> ok
08:10:01 <ibid> 0.6 apt would be in unstable if we weren't so close to releasing
08:10:11 <ibid> aiui
08:16:56 <wnoise> @index ap
08:16:57 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
08:16:57 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
08:16:57 <lambdabot> State,Control.Monad.Writer,Monad
08:27:16 <wnoise> @type Monad.ap
08:27:17 <lambdabot> Monad.ap :: forall b m a. (Monad m) => m (a -> b) -> m a -> m b
08:30:48 * shapr stabs Python with a particularly dull and rusty spoon.
08:32:32 <shapr> hiya cognominal
08:32:50 <shapr> salut, comment ca va?
08:33:44 <cognominal> hi
08:34:40 <cognominal> I have trouble compiling ghc on mandrake cooker.
08:34:42 <cognominal> make[2]: *** No rule to make target `System/CPUTime_hsc.c', needed by `depend'.  Stop.
08:35:08 <shapr> Which version of GHC are you building?
08:35:37 <cognominal> 6.2.2
08:37:00 <shapr> I don't know, and google doesn't show anything.
08:38:01 <shapr> I just built GHC 6.4rc1 on debian/unstable last night.
08:38:12 <cognominal> aparently a guy named rillig asked the same question a while ago http://tunes.org/~nef/logs/haskell/04.11.05
08:38:34 <Igloo> Does anyone have a reference for the undecidability of equality of Haskell expressions?
08:38:47 <Lemmih> Which version of GHC do you have installed?
08:39:04 <shapr> Igloo: Ulf Norell's IOHCC entry?
08:39:11 <Heffalump> do you need a reference to say "function equality is undecidable"?
08:40:18 <Igloo> Are you asking if it's really necessary, or clarifying the question?
08:40:47 <Heffalump> the former
08:41:19 <Igloo> Probably not, but it can't hurt
09:16:34 <CosmicRay> bah, DBDirect generated code that won't compile.
09:28:58 <SyntaxNinja> Igloo: alive?
09:29:04 <Igloo> Yup
09:29:44 <SyntaxNinja> Igloo: did you have plans to package ghc 6.4 RCs? I think it might be a good idea, in case that'll help get it tested.
09:30:05 <Igloo> I do have plans
09:30:34 <SyntaxNinja> ok
09:31:01 <Igloo> I don't know if I'll manage before the release, though
09:38:53 <SyntaxNinja> ok. I'm paranoid that either ghc 6.4 or cabal will suck in sarge
09:39:21 <SyntaxNinja> it's nice having such a long and drawn out release process for sarge, it allows us to spread our paranoia and panic over a longer period of time
09:39:28 <Igloo> :-)
09:39:53 * Igloo still doesn't think cabal should be in sarge, nor do I think it should be in ghc 6.4 if that requires it being stable
09:40:06 <Igloo> Anyway, AFK for a bit
09:40:18 <SyntaxNinja> I think we're going to make it a limited subset of cabal in GHC 6.4 / sarge
09:40:33 <SyntaxNinja> anyway, it's free software, it's allowed to change and break everything, right?
09:40:52 <CosmicRay> yes, things change all the time
09:41:04 <CosmicRay> debian releases are snapshots in time that are known to be internally compatible
09:41:13 <CosmicRay> and generally bug-free
09:41:39 * SyntaxNinja igloo and CosmicRay all have a good laugh
09:41:41 <SyntaxNinja> ;)
09:41:45 <CosmicRay> :-)
09:42:18 <SyntaxNinja> basically I think we'll allow defaultMain, defaultMainWithHooks, and the package description file to never change
09:42:27 <SyntaxNinja> the API itself may change
09:42:35 <CosmicRay> or atleast to not change in incompatible ways, eh?
09:42:38 <SyntaxNinja> plus if we have hackage, then we'll have a nice list of all the packages and which features they use
09:42:40 <CosmicRay> you could always add new optional fields
09:42:40 <SyntaxNinja> CosmicRay: right.
09:43:10 <SyntaxNinja> and people who want to use extended features of cabal (there are many) will know what they're getting into. they'll have more complex packages anyway.
10:06:32 <wli> wild
10:10:37 <jlouis> /usr/local/lib/ghc-6.2.2/libHSrts.a(Main.o)(.text+0x16): In function `main':
10:10:37 <jlouis> : undefined reference to `__stginit_ZCMain'
10:10:46 <jlouis> that must happen often, what is the solution?
10:11:03 <jlouis> the stg machine needs its main closure... hmm
10:15:52 <jlouis> http://www.haskell.org/pipermail/hopengl/2004-May/000509.html explains the problem
10:23:26 <SyntaxNinja> jlouis: do you not have a "main" function, and if so, is it of type "IO ()"?
10:23:28 <tmoertel> SyntaxNinja: do you have any cabal-ized packages that I can use to test cabal2rpm?
10:24:39 <SyntaxNinja> tmoertel: peter simons just posted a handful of them to a mailing list, I think the libraries list
10:25:13 * tmoertel hunts down list archives
10:26:16 <jlouis> SyntaxNinja: the problem is lack of a Main module
10:26:34 <jlouis> I have fixed it, the pipermail URL explains
10:38:10 <csmith> Quick question, if one wanted to learn haskell, what would you recommend as a first book?  I know some functional programming from ocaml
10:40:43 <zamez> I would anti-recommend "Introduction to FP using Haskell"
10:41:30 <tintin> is that not the AW book ?
10:43:45 <SyntaxNinja> csmith: Haskell School of Expression is pretty good
10:43:45 <SyntaxNinja> @learn
10:43:46 <lambdabot> http://www.haskell.org/learning.html
10:43:55 <araujo> zamez, why?
10:44:36 <zamez> I found it very verbose and it didn't explain some things so well
10:44:41 <SyntaxNinja> and it's an old book, I think.
10:44:42 <zamez> it's good as a reference
10:45:37 <wli> the third-order Newton (solving 0 = f(x+a) = f(x)+f'(x)*a+f''(x)*a^2/2 + f'''(x)*a^3/6 for a mapping x |-> x+a for the iteration) doesn't seem to work very well
10:56:07 <tmoertel> SyntaxNinja: Peter's tarballs don't seem to have the necessary bits, e.g., Setup.hs
10:56:44 <wli> Unsurprisingly, this is because I flubbed the cubic's solution.
10:59:06 <wli> the cubic seems to have some advantages at "long ranges" but it looks like Muller and/or Newton polish things up better close to the roots.
10:59:50 <wli> Right around machine precision the lower-order methods do better.
11:00:02 <wli> Probably b/c the cube roots can't be done very exactly.
11:00:05 <Oeje1> wli: Funny that you mention Cubic.
11:00:06 <SyntaxNinja> tmoertel: damn :(
11:00:19 <wli> Oeje1: Hmm?
11:00:21 <SyntaxNinja> tmoertel: got access to the darcs or fptools repos? there are some things under tests
11:00:37 <wli> Oeje1: I fiddled around with higher-order Newton-like affairs.
11:01:42 <wli> Oeje1: basically iterate (\x -> let a = root a (f(x) + f'(x)*a + f''(x)*a^2/2 + f'''(x)*a^3/6) in x + a) x0
11:04:00 <wli> last #hask 999
11:04:19 <wli> Oeje1: I was inspired by Muller's method.
11:04:53 <wli> Oeje1: It seems to be a small cut above Newton's, and is the quadratic analogue of Newton.
11:05:05 <SyntaxNinja> tmoertel: I don't have time to chase it down now, I'm at work.
11:05:19 <tmoertel> SyntaxNinja: no problem
11:05:20 <wli> Oeje1: It has the disadvantage that the quadratic not have real roots, where a cubic must have at least one real root.
11:06:15 <wli> Oeje1: Quick sniff-testing of the cubic method reveals that the cubic method dominates Muller's until the residual is close to machine precision, where the error in the cube root dominates.
11:06:56 <wli> Oeje1: of course, given the first 3 derivatives, one might as well just run all of the cubic, quadratic, and linear methods, and take the best result.
11:10:35 <wli> Oeje1: I vaguely like the idea of solving the quintic in terms of elliptic functions and using that solution to guide functions with many known derivatives.
11:11:31 <wli> and, of course, doublechecking that against explicit solutions of the quartic, cubic, quadratic, and linear versions.
11:12:22 <Oeje1> wli: Ok.
11:39:46 <jadrian> I think everyone agrees that records in haskell suck, and that no one agrees on how exactly make them good... but at least some god damn syntatic sugar for application of a function to one of the fields wouldn't hurt :-/
11:40:00 * jadrian just felt like complaining...
11:40:53 * Lemmih does that with TH.
11:41:09 <jadrian> nice...
11:42:30 <pesco> OT: Any Mozilla Thunderbird users here?
11:42:53 <Lemmih> Didn't SPJ came up with a proposal for new records some time ago?
11:43:28 <Oeje1> Lemmih: I have read an article about it.
11:48:24 <mattam> pesco: yep
12:01:47 <jadrian> my point was, everyone as been proposing and disagreeing on how records should be... until we get the perfect records it would be nice to make this ones suck a little less
12:01:59 <Oeje1> Whoa, for TMR someone could write about array comprehensions?!
12:02:22 <wli> What do array comprehensions look like.
12:02:50 <xerox> pesco, yep2
12:03:28 <Oeje1> [: x*x | x <- someArray :]
12:03:52 <xerox> [: smileys :]
12:04:01 <wli> sounds useful
12:04:18 <wli> how would you do matrix-matrix multiplication with array comprehensions?
12:04:24 <Oeje1> That is almost identical to list comprehension, only there are clever vectorization and optimizations.
12:08:17 <Oeje1> There is an example of a matrix and vector multiplication in http://www.cse.unsw.edu.au/~chak/papers/CK03.html
12:08:52 <wli> hmm
12:11:26 <Oeje1> A dot product can be written like:
12:11:51 <Oeje1> dot :: Vector -> Vector -> Float
12:13:01 <musasabi> Oeje1: they are just very buggy at the moment.
12:14:08 <xerox> Oeje1, is dot product cartesian product?
12:14:55 <musasabi> e.g. http://sourceforge.net/tracker/index.php?func=detail&aid=1035575&group_id=8032&atid=108032
12:15:55 <Heffalump> xerox: yes
12:16:14 <toomasr> aloha
12:16:20 <Lemmih> Greetings.
12:16:21 <shapr> y0
12:16:30 <shapr> heippa hei
12:16:34 <shapr> hyvää ihltaa
12:16:56 <toomasr> you finnish?
12:17:05 * Lemmih wonders how to correctly cabalize something like HSQL.
12:17:15 <toomasr> it seems that this semester i have to start learning prolog :)
12:17:25 <shapr> Minä en ole suomi. Minä olen americalainen.
12:17:27 <xerox> yay
12:17:43 <toomasr> lol
12:17:49 <Oeje1> v `dot` w = sum [: v!i * w!i | i <- enumFromToP  (lengthP v) :]
12:18:42 <Oeje1> xerox: Dot product is \sum_0^n v_i * w_i.
12:18:48 <shapr> toomasr: do you speak finnish too? :-)
12:19:00 <Heffalump> lemmih: didn't CosmicRay already do it?
12:19:01 <shapr> I don't speak finnish, just a few words I learned.
12:19:17 <toomasr> oh
12:19:22 <toomasr> finland is 80km from me
12:19:26 <Lemmih> Heffalump: URL?
12:19:29 <toomasr> i speak couple of words too :)
12:19:37 <shapr> Finland is about 80km from me too.
12:19:41 <Heffalump> lemmih: apt-get source hsql ;-)
12:19:52 <Heffalump> it seems like a fairly straightforward cabal file
12:21:32 <Lemmih> Is it online somewhere?
12:21:34 <Oeje1> xerox: Or just "sumP [: v' * w' | v' <- v | w' <- w :]"
12:21:42 <Lor> Some parts of Finland are 80km from me, too. :)
12:22:26 <shapr> haha
12:22:32 <Oeje1> musasabi: That is a nasty bug for such a simple program in the bug report.
12:22:39 <shapr> Lor: that's because you're IN finland!
12:24:07 <Heffalump> Lemmih: http://urchin.earth.li/~ganesh/temp/Setup.description
12:24:34 <Oeje1> musasabi: Oh, but it must be fixed by now.  Do you have any practical experience with parallel arrays?
12:24:35 <shapr> toomasr: Prolog is a fun thing to learn.
12:25:07 * Lor is teaching Prolog right now.
12:25:27 * xerox aims to have some time to check it out.
12:25:29 <Lor> To computer linguists.
12:25:40 <toomasr> shapr: i started reading a book about it, sounded weird, i'll see
12:26:24 <toomasr> Lor: wow, teaching, cool!
12:26:27 <Lemmih> Heffalump: Don't it require you have to postgresql, mysql, sqlite? And all of them installed at predefined places?
12:26:38 <Heffalump> well, it works for Debian :-)
12:26:47 <Heffalump> fair enough, if that's not enough for you
12:27:35 <Lemmih> Heffalump: I cabalized HSQL long a ago for Hackage. I was just wondering if there was a correct way of doing it.
12:27:47 <Lor> I sortakinda realized that the DCG syntax in Prolog is pretty much like a state monad.
12:28:08 <Lor> With relations between the states instead of a one-directional function, of course.
12:28:14 <wli> DCG is nice.
12:28:19 <wli> esp. for parsing
12:28:20 <Lor> Is not.
12:28:24 <Lor> It is too primitive.
12:28:37 <Lor> It is trivial to write a more advanced syntax that better suits your needs.
12:29:04 <Lemmih> s/ a //
12:30:00 <Heffalump> lemmih: best ask SyntaxPolice, then :-)
12:30:07 <wli> Lor: Not sure what you're on about. I largely have in mind parsing problems that don't fit well into standard grammar classes, and e.g. additional context-dependent logic is needed.
12:30:43 <wli> Dropping in random conditions on the goals/etc. is useful there.
12:31:01 <Lor> Well, depends on what you want.
12:31:08 <wli> For programming language parsing it's pretty much useless.
12:31:16 <wli> (including DSL's)
12:31:19 <Lor> I mean that if you want a direct term that represents the parse tree, it's tedious and repetitive with DCGs.
12:31:58 <wli> Lor: When I needed it, I had to go through the tedious and repetitive process and drop in various side conditions and extra rules all over the place.
12:31:59 <Lor> vp(vp(V,NP)) --> v(V), np(NP).
12:32:32 <Lor> whereas one might just as well just say e.g. vp ::= v, np.
12:32:38 <Lor> And have the parser system figure out the rest.
12:32:45 <wli> Lor: Which added up to "This would have been tremendously more painful in almost anything else."
12:40:27 * Philippa is tempted to suggest Parsec
12:41:30 <Philippa> you can do scary things with the state in it
12:41:36 <shapr> Oeje1: I think *you* should write about array comprehensions in TMR.
12:42:33 <Heffalump> Philippa: YM the Parser monad has state?
12:42:54 <Oeje1> shapr: I am flattered.  Only, I haven't compiled a single line of array code yet and will not be ready for this dead line.  Maybe the next?
12:43:01 <shapr> Oeje1: sounds good.
12:44:05 <pesco> Heffalump: There is a user state you can get and set, yes.
12:44:46 <musasabi> Oeje1: I don't think it is fixed.
12:45:37 <musasabi> Oeje1: GHC.Parr seems to be rather rotting away slowly than being developed actively.
12:45:39 <pesco> Oeje1: Nonsense! Just take one afternoon reading the manual, run some simple examples, and start the article with "In case you've not used array comprehensions yet, here's the deal."
12:45:44 <pesco> ;-)
12:45:55 <shapr> musasabi: that's sad :-(
12:46:00 <Philippa> Heffalump: it has it, and you can do fun things
12:46:04 <shapr> Maybe we should steal it.
12:46:14 * shapr breaks into GHC and steals some code.
12:46:19 * pesco grins.
12:46:21 <musasabi> yes, parallel arrays could be fun.
12:46:35 <shapr> We could even implement the SMP part of Parr
12:46:42 <pesco> Why _are_ they rotting? They were so fast.
12:46:48 <shapr> It would be handy for the Cell port of GHC.
12:46:58 <Oeje1> pesco: How fast is that?
12:47:17 <pesco> Oeje1: Faster than any other kind of arrays I could find at the time.
12:47:37 <shapr> Last I sent email to Chilli, he said that the class-local stuff was suppossed to make Parr much easier to implement.
12:47:40 <pesco> Except IOArrays that is, but those don't count. ;)
12:47:52 <Oeje1> Have you some timing data?
12:47:58 <pesco> Oeje1: No.
12:48:14 <pesco> But there was a comparison on the website, I think.
12:48:26 <pesco> Which prompted me to use them in the first place.
12:48:33 <shapr> Array fusion and nested data parallelism is going to be really fast.
12:49:16 <shapr> Also, it's the only way I've seen to get one step closer to the dream of transparent parallelization of FP languages.
12:49:28 <Oeje1> The paper about it has given me a hint of its cleverness.
12:49:34 <musasabi> PArr code has seemed to be faster than other alternatives in haskell when I tried them out, but no good benchmark suite.. (mainly because I kept hitting that bug for interesting problems)
12:49:43 <pesco> shapr: Hahhh. Transparent parallelization.
12:49:53 * pesco drifts away.
12:49:57 <musasabi> The actual implementation is quite small, so hacking that should be simple...
12:50:01 <shapr> If you mix Parr and Moscow ML's region-allocation, GHC could become one of the best compilers for the Cell cpu.
12:50:07 <shapr> pesco: you don't think so?
12:50:22 <pesco> shapr: Yes I do. I was trying to to sound dreamy.
12:50:26 <shapr> oh!
12:50:28 <Philippa> shapr: there's a number of reasons I'd far rather just do the threading on Cell explicitly
12:50:43 <Oeje1> shapr:  Single Assignment C also uses some of the same ideas in my present understanding.
12:50:50 <Philippa> region-alloc good, mind
12:50:50 <shapr> Not me... but you've probably seen my argument against threading on LtU.
12:51:01 <Philippa> think I managed to miss it
12:51:22 <shapr> My claim is that threading just doesn't scale.
12:51:30 <shapr> Where declarative parallelism does.
12:52:06 <Philippa> you're probably right for certain kinds of problem. Mind you, I'm most likely to target Cell on PS3 - in those cases, I think threading's still more appropriate
12:52:14 <Heffalump> with a `par` combinator with the same type as `seq` ?
12:53:27 <shapr> Philippa: likely you're right about the PS3, if the number of Cell cpus in a system is static, you can tune the software to known settings.
12:53:48 <Heffalump> depends on how much effort you're willing to go to to optimise for a specific target
12:53:54 <Heffalump> you could always handcode assembler ;-)
12:54:01 <Philippa> if you're coding for PS3, odds are the answer's "a lot"
12:54:08 <Philippa> people're still doing that in the current generation of consoles
12:54:16 <Philippa> mostly on the PS2 where you've not much choice, admittedly
12:55:09 <pesco> I'm off to bed. Good night everyone!
12:55:10 <shapr> But I was thinking more about programs that should run on a single Cell, but still scale to a four socket quad-core setup where you have sixteen Cells.
12:55:14 <shapr> g'nite pesco!
12:55:16 <Philippa> fair enough
12:55:35 <jlouis> shapr: moscow ML doesn't use region inference
12:55:39 <jlouis> the ML kit does though
12:56:02 <jlouis> If you want to explore it, theres 2 milestone papers, let me find them
12:56:03 <xerox> 'night pesco
12:56:34 <shapr> Google implies that Moscow ML does do region inference.
12:57:03 <xerox> ML as in .. ?
12:57:22 * Heffalump would be surprised if Moscow ML did it, from what I know of it.
12:57:30 <Heffalump> what URL are you reading?
12:57:48 <shapr> I just googled for http://www.google.com/search?q=moscow+ml+region+allocation&ie=UTF8
12:59:19 <Heffalump> did you actually read the references to make sure they weren't mentions of the ML kit and moscow Ml on the same page?
12:59:46 <shapr> Yes, and the references I found before looked like Moscow ML did region inference.
13:00:04 <shapr> But I didn't read the actual papers, so I could easily be wrong.
13:00:14 <shapr> I was hoping to get hold of ATTaPL soon.
13:00:54 <shapr> I got the impression the chapter on region inference in that book was particularly good.
13:00:58 <jlouis> shapr: _the_ Ph.d dissertation to read is http://www.diku.dk/~makholm/thesis.ps
13:01:19 <shapr> jlouis: thanks!
13:01:20 <jlouis> Henning does a great job explaining region inference
13:01:29 <jlouis> http://www.macs.hw.ac.uk/~makholm/publications
13:01:32 <jlouis> in general
13:01:56 <jlouis> the basic idea of region inference is to intersperse the language with a region language, maintaining the regions as the program executes
13:02:26 <jlouis> what Fritz Henglein, Henning Makholm and Henning Niss showed was the idea that an _imperative_ region language yields better allocations
13:03:22 <jlouis> but there are still the problem with the top-level region. If you cannot analyze the live-range of a memory segment, it ends up in the top-level region. This region can then grow very very big and it is only deallocated when the program ends
13:03:31 <jlouis> solution? GC the top-level region
13:03:39 <Heffalump> imperative as opposed to following the dynamic scope of the program?
13:03:41 <jlouis> the MLkit does that. They have some papers on it
13:03:49 <shapr> That sounds perfect for the Cell cpu.
13:04:19 <jlouis> Heffalump: imperative as in all other languages used were functional. If I understand you correctly, then yes
13:04:34 <Heffalump> can you give a small example of where this is a win?
13:04:49 <Heffalump> s/win/significant &/
13:05:00 <shapr> asking me or jlouis ?
13:05:06 <Heffalump> jlouis.
13:05:18 <Heffalump> shapr: I'm ignoring you until you produce some concrete evidence :-)
13:05:22 <shapr> heh
13:05:25 <Heffalump> s/evidence/& or reasons/
13:05:32 <jlouis> http://www.diku.dk/~makholm/ppdp-henglein-makholm-niss.ps.gz, page 2
13:05:37 <jlouis> Heffalump: there ;)
13:06:34 <juneof44> welcome my friends to the chat that never ends.
13:06:57 <jlouis> There are situations where the creation and destruction of regions can be done ``closer'' to how the actual program does
13:07:09 <jlouis> shapr: why do you think it is perfect for the cell CPU?
13:07:25 <juneof44> heh. the cell CPU is all the hype now.
13:07:32 <juneof44> When do you expect it to reach the consumer market?
13:07:34 <jlouis> juneof44: of course it is ;)
13:07:41 <shapr> because Cell has a top level Power5 and eight (six?) simplified 604e chips on the side.
13:07:50 <zipper> hi shapr
13:07:52 <shapr> or was it simplified 601e?
13:07:54 <shapr> hiya zipper
13:07:55 <juneof44> well, it is kinda big, IBM and Sony together.
13:08:05 <juneof44> It almost makes me reconsider getting a Mac.
13:08:23 <juneof44> But I have to put myself through a MAJOR de-geeking intervention, and getting a Mac is the first step of it.
13:08:24 <shapr> In any case, the side chips have 256k of ram, which functions as cache, local ram, and everything else.
13:08:35 <jlouis> shapr: Yes, I know the cells basic layout. I am still wondering where you would use regions? In throwing data at the 604e+RAM?
13:08:57 <Heffalump> jlouis: right, makes sense.
13:09:07 <juneof44> what popular PowerPC OSes are there besides MacOS classic, OS X and Linux?
13:09:38 <shapr> Yes, on a per-cell basis. But more importantly, you will need distributed GC when you have a whole bunch of Cells in the same box, and region inference means you can cut out a lot (all?) of the cross-Cell locking.
13:09:41 <jlouis> shapr: to me, it seems it has to be programmed very much like the PS2 has to be
13:09:43 <jwp> I think fbsd runs on ppc, not sure how stable it is.
13:09:52 <Heffalump> I guess it does make sense to delineate the program into threads that run on certain SIMD units along with regions that go in the local memory for them
13:09:59 <juneof44> well, fbsd is NOT "popular", specially on PPCs
13:10:18 <juneof44> "Of course it runs NetBSD".
13:10:21 <jwp> hehe
13:10:21 <jlouis> OpenBSD runs well on ppc. So does NetBSD (naturally)
13:10:31 <shapr> Heffalump: does that mean you'll stop ignoring that idea? ;-)
13:11:04 <juneof44> when I buy the minimac thing I might turn this machine into a file server and toy with the BSDs.
13:11:17 <juneof44> I like the OpenBSD release songs.
13:11:28 <juneof44> I'm almost tempted to run an old version of OpenBSD because it has the best song.
13:11:29 <shapr> Anyway,time for me to sleep, I'll be back tomorra
13:11:38 <jlouis> shapr: see ya
13:11:49 <juneof44> CAAAAAAAAAAAAAAAAAAAAAAAN'T FIIIIIIIIIGHT THE SYSTEMAGIC! SYSTEMAGIC!
13:11:57 <jlouis> juneof44: don't. 3.6 is faster than all the others ;)
13:12:15 <juneof44> yes, but it doesn't have Systemagic (TM).
13:12:40 <juneof44> the whole point of running OpenBSD is its unique Systemagic :-D
13:13:15 <Heffalump> shapr: yes :-)
13:14:27 * juneof44 goes troll #openbsd
13:19:35 <xerox> 'night folks
13:23:53 <musasabi> night.
13:24:38 <Oejet> musasabi: I have the "A fast approach to Fast Arrays in Haskell" paper by Manuel Chakravarty and Gabrielle Keller.  Are there other interesting documentation on the subject?
13:28:31 <musasabi> The source code tells the truth ;-)
13:28:37 <Link> Haskell is the hardest language that I've ever attempted to learn :o
13:29:32 <KrispyKringle> Link: only if you try to understand it :P
13:29:59 <Link> KrispyKringle: That understanding thing isn't important eh? :D
13:30:25 <KrispyKringle> Understanding is never important. ;)
13:30:26 <musasabi> Learning haskell is very rewarding.
13:30:51 <Link> I can add it to my list of high level modern languages
13:31:12 <Link> The other one being Python, which I love so very, very much
13:31:26 * kosmikus appears
13:31:29 <KrispyKringle> Python is good. Not great, but good. :P
13:31:49 <KrispyKringle> I think the chances of me shootingi myself in the foot are somewhat higher with python than with haskell, though lower than with, say, C or Perl.
13:32:00 <zamez> at least we can all agree that C++ sucks ;)
13:32:02 * zamez hides
13:32:03 <KrispyKringle> (for different reasons with both, though)
13:32:08 <Link> It doesn't help that Perl is terribly ugly
13:32:48 <KrispyKringle> i never really found it that way, but the syntax is a bit fuglier than python, ill admit.
13:33:20 <Link> I think that Python has some of the nicest looking syntax
13:33:30 <Link> Haskell is nice looking too
13:33:33 * musasabi finds perl confusing for nontrivial tasks.
13:33:44 * rtega likes haskell and python more and more
13:33:45 <KrispyKringle> true, b ut it's very useful for trivial tasks.
13:33:53 <musasabi> true.
13:34:02 <Link> Hehe.
13:34:03 <musasabi> for one liners I use it extensively.
13:34:13 <KrispyKringle> same
13:34:16 <KrispyKringle> i don't do anything big in it.
13:34:25 <KrispyKringle> biggest perl program i've ever written would be probably under 300 lines.
13:34:35 <Link> I use Python for short tasks
13:35:30 <rtega> zamez: c++ sucks definitely
13:35:38 <rtega> but it helps getting you a job ;)
13:35:44 * Oejet takes a stab at Java and hides.
13:35:53 <rtega> java sucks monkey ass
13:35:57 <rtega> no point in hiding
13:36:00 <rtega> ;)
13:36:17 <zamez> but at least java isn't an unholy mixture of high- and low-level concepts
13:36:28 <rtega> that's definitely true
13:36:38 <rtega> java is a lot more simpler to use than c++
13:36:41 <Link> Why doesn't Hugs run the 'main' function when you give it a script anyways?
13:36:45 <Oejet> zamez: Like objects and basic types?
13:36:49 <rtega> which gives one so much liberty that you tend to get lost
13:37:03 <rtega> Oejet: pointers
13:37:09 <rtega> to mention but one thing
13:37:23 <rtega> multiple inheritance and all the associated mud
13:37:40 * Oejet hasn't fully grasped the visitor design pattern yet.
13:37:48 <Heffalump> link: I don't understand your question
13:37:57 * rtega didn't know one existed with that name
13:38:32 <Oejet> rtega: Think mapping over trees.
13:38:41 <Heffalump> with side-effects
13:39:04 <rtega> Oejet: why do that in c++ if you could do it in haskell? ;)
13:39:14 <musasabi> Does it make sense to try to handle PF_LOCAL uniformly with other sockets?
13:39:14 <Link> Heffalump: I run my script in Hugs and it doesn't start the function 'main', it just prompts 'Main> '
13:39:23 <musasabi> Or would a separate type be clearer?
13:39:39 <Heffalump> link: use runhugs if you want it to run mani
13:39:42 <Heffalump> s/mani/main/
13:39:45 <Link> Ah.
13:39:47 <Heffalump> hugs is the interactive one
13:41:15 <musasabi> It seems to have quite different semantics from PF_INET/PF_INET6/...
13:44:00 <CosmicRay> Lemmih: I have already Cabalized both hsql and haskelldb
13:44:07 <CosmicRay> Lemmih: both are in NEW waiting for sid
13:44:16 <CosmicRay> Lemmih: both are also in my arch repo on arch.debian.org
13:46:06 <Heffalump> did you make it properly detect libraries etc?
13:59:37 <Link> Someone tell me what the advantages to learning Haskell are anyways?
14:00:12 <zamez> each new language is a step towards enlightenment
14:00:34 <toomasr> like the efect of learning go for a chess player
14:01:13 <Link> Hmm. Okay, well, that is a goal.
14:02:10 <KrispyKringle> Wow. zamez sounds like some sort of tao master.
14:02:43 <LinkMasterSab> I'm going to at least go through the tutorial for ten languages by the end of this year.
14:02:52 <LinkMasterSab> And if I like the language, I'll work on it some more
14:03:17 <KrispyKringle> Ten? Wow. :P
14:03:23 <KrispyKringle> Which languages?
14:03:27 <LinkMasterSab> No idea yet.
14:03:30 <Lemmih> CosmicRay: That's great but not really what I'm after (:
14:03:42 <KrispyKringle> I think, though, it may behoove you more to learn in-depth a few languages from different paradigms.
14:03:44 <Oejet> LinkMasterSab: It's a step towards writing you own languages.
14:03:50 <LinkMasterSab> I'll probably hit D, SmallTalk, Eiffel, some of those other ones.
14:03:54 <KrispyKringle> e.g. haskell, java/C#/C++, C, etc.
14:03:56 <Lemmih> shapr: Ping.
14:05:09 <LinkMasterSab> KrispyKringle: Yes, well, I refuse to learn Java, but yeah, when I mean going over 10 languages, I mean taking a brief look at them and deciding whether or not to go more in-depth with them
14:05:24 <LinkMasterSab> I'll probably abandon languages along the way, like I did with C++
14:06:51 <KrispyKringle> LinkMasterSab: ah, that's good.
14:06:53 <KrispyKringle> :)
14:07:32 <LinkMasterSab> I think Python is going to stay my top imperative language though
14:10:22 <monochrom> someone asked about the advantages of "learning haskell".  An advantage is that after learning haskell you will know how to read haskell. :)
14:10:58 <Pseudonym> And possibly even write it.
14:11:06 <wilx> :)
14:46:53 <Link> Okay, so on the page with my last question...
14:47:03 <Link> What're the advantages of using Haskell?
14:47:32 <Pseudonym> Haskell obeys the Perlis rule.
14:47:47 <Pseudonym> It changes the way you think about programming, and is therefore worth learning.
14:47:51 <LinkMasterSab_> ... what's the Perlis rule?
14:48:16 <CosmicRay> Heffalump: well, it's better now.
14:48:19 <wli> "If you have a procedure with ten parameters, you probably missed some." -- Alan J. Perlis
14:48:31 <Pseudonym> Generally speaking, the more _different_ types of language that you know, the better your programming becomes, no matter what language you're programming in.
14:48:31 <CosmicRay> Heffalump: instead of doing too little, it probably does too much, buti t's better.
14:48:54 <Pseudonym> I find my (for w*rk) C++ code is influenced for the better by knowing Haskell.
14:49:18 <Pseudonym> In fact, I can identify a few Haskell idioms that creep in.
14:49:19 <lightstep> the problem is that learning haskell involves lots of concepts, which do not belong toghether
14:49:21 <dons> I'd _really_ like to be able to derive Lift
14:49:49 <CosmicRay> HaskellDB question.  How can I make it just say "SELECT" instead of "SELECT DISTINCT"?
14:50:04 <CosmicRay> even just the "table myTable" query causes it to add DISTINCT.
14:50:06 <CosmicRay> imho, that's broken.
14:50:18 <Pseudonym> dons: Excuse me?
14:50:31 <LinkMasterSab_> Okay, but the only answers I'm getting are about learning Haskell
14:50:37 <monochrom> "distinct" is the default.  Let me see if there is a command to override it.
14:50:39 <Lemmih> CosmicRay: You can't.
14:50:43 <LinkMasterSab_> After I learn Haskell, are you saying that I won't continue to use it?
14:50:50 <CosmicRay> Lemmih: ugh.  that is incredibly broken then.
14:51:11 <CosmicRay> "i can't use haskelldb" kind of broken.
14:51:12 <Pseudonym> LinkMasterSab_: Surely that's up to you. :-)
14:51:12 <dons> Pseudyonym: the TH class Lift, describing stuff that is automagically turnable into abstract syn
14:51:21 <CosmicRay> why on earth would they do that?
14:51:21 <Lemmih> Semi-broken since you can work around it.
14:51:34 <monochrom> I use Haskell with HaskellDB to replace SQL.
14:51:49 <CosmicRay> Lemmih: how?
14:52:07 <Pseudonym> I have about 45+ languages on my CV, and Haskell is the one that I use second-most-often.
14:52:12 <Lemmih> Can't remember the details but I think I did it Hackage.
14:52:41 <Pseudonym> So I certainly continue to use it.
14:52:53 <wli> Pseudonym: heh, what role do these languages play on your CV?
14:53:01 <Pseudonym> wli: Filler. :-)
14:53:12 <wli> Pseudonym: programming in them or implementing runtimes/compilers/etc.?
14:53:28 <Pseudonym> A lot of them are "familiarity with", as opposed to "fluent in".
14:53:36 <Pseudonym> I'm familiar with SML, but I wouldn't say I'm fluent.
14:53:44 <Pseudonym> i.e. I have written stuff in SML that worked.
14:54:35 <Pseudonym> And I include different languages that some people wouldn't consider different because I happen to know the differences.
14:54:58 <Lemmih> CosmicRay: Don't look like it was in Hackage I encountered that problem.
14:55:02 <Pseudonym> e.g. SQL-2 and SQL-3
14:55:03 * Lemmih tries to remember.
14:55:11 <CosmicRay> hmm.
14:55:15 <Pseudonym> And Modula-2 and Modula-3.
14:55:20 <wli> Pseudonm: Once you get to one from each paradigm it's largely over; they're not like human languages.
14:55:27 <Pseudonym> Right.
14:55:28 <CosmicRay> Pseudonym: Python 1.5, 2.0, 2.1, 2.2, 2.3, 2.4? :-)
14:55:35 <monochrom> hahaha
14:55:41 <Pseudonym> CosmicRay: Oddly enough, Python isn't one of the 45+.
14:55:49 <LinkMasterSab> Pseudonym: Why not?
14:55:54 <CosmicRay> Pseudonym: too bad.  you could have made it 75. :-)
14:55:58 <Pseudonym> LinkMasterSab: Haven't gotten around to it.
14:56:14 <Pseudonym> But I do know the differences between Perl 4 and 5, and between Java 1.0, 1.1 and 1.2.
14:56:15 <LinkMasterSab> Python is my favorite language of the moment.
14:56:18 * wli has completely ignored Perl, Python, Ruby, and several other similar languages.
14:56:57 <lightstep> even ruby? but it's nice!
14:57:01 <Pseudonym> I also know the differences between VB and VBA, though I wish I didn't.
14:57:03 <LinkMasterSab> wli: Why's that?
14:57:24 <CosmicRay> lightstep: it struck me as insufficiently different from python to merit the effort of learning it
14:57:38 <basti_> shapr: ping.
14:57:39 <wilx> Hmm...
14:57:40 <Pseudonym> And I also consider Bourne shell and BASH different languages.
14:57:53 <CosmicRay> Pseudonym: that's a stretch
14:57:57 <LinkMasterSab> I know the differences between BASIC, GW-Basic, QBasic, and VBDOS
14:57:58 <wli> LinkMasterSab: Partly personal preference, partly technical reasons.
14:58:07 <wilx> Perl is the language of my choice.
14:58:14 <wilx> From this class of languages that is.
14:58:16 <Pseudonym> CosmicRay: Perhaps.  But being able to enumerate differences between them makes your shell scripting much more portable.
14:58:33 <CosmicRay> Pseudonym: that, or $SHELL=/bin/sh :-)
14:59:41 <Pseudonym> My favourite line from my CV, though, is this one: "Ironic willingness to adhere to formal software engineering processes and methodologies."
14:59:47 * wli speaks Spanish to God, Italian to women, French to men, and German to his horse.
15:00:06 <CosmicRay> english to #haskell?
15:00:30 * Pseudonym speaks Greek to God, Gibberish to men, Braille to women and Rubbish on IRC
15:00:57 * CosmicRay stops speaking.
15:01:02 <Pseudonym> Night.
15:01:33 <monochrom> Hrm is there a haskelldb command to cause a "group by"?
15:01:34 <wli> CosmicRay: Obviously something else is meant.
15:06:15 <juneof44> my CV is a mess.
15:06:20 <juneof44> a bloody mess, I tell you.
15:06:34 <juneof44> I'm supposed to be some sort of an economist, but half of it is made of computer-related projects.
15:06:43 <juneof44> I might have chosen the wrong career.
15:08:59 <monochrom> computational economist, is what you are.
15:09:03 <Pseudonym> I think lettuce farming.
15:09:07 <Pseudonym> Lettuce don't talk back to you.
15:36:35 <basti_> shapr: ping?
15:55:11 <jadrian> what's the english word for (-1)...?
15:55:17 <jadrian> the operation not the number
15:55:27 <Philippa> negation
15:55:40 <monochrom> minus 1
15:55:44 <Philippa> or do you mean "subtracting 1" or the predecessor function?
15:55:47 <jadrian> yes that one...
15:55:51 <monochrom> negative one
15:55:53 <jadrian> subtracting one
15:55:59 <jadrian> decrement?
15:56:06 <Philippa> decrement, yeah, that'll do
15:56:11 <Philippa> (ah, the joys of synonyms)
15:56:22 <jadrian> is there something better? :)
15:56:27 <jadrian> I was trying to avoid decrement
15:56:35 <monochrom> The additive inverse of 1.
15:56:44 <jadrian> I said better :P
15:56:52 <monochrom> It is better.
15:57:06 <jadrian> I need it for part of a function name!
15:57:33 <monochrom> the_additive_inverse_of_one can be part of a function name.
15:57:35 <jadrian> apply_the_additive_inverse_of_1_to_my_field is not better!
15:57:44 <Cale> decrease? lower? shrink?
15:57:49 <jadrian> decrease!
15:57:56 <jadrian> I think that's the one I wanted!
15:58:00 <jadrian> thanks
15:58:12 <monochrom> You write a bloody named function to decrease by one?!
15:58:34 <jadrian> nested records :-/
15:58:46 <Spark> jadrian: m-w.com has a thesaurus :)
15:58:53 <Spark> its really useful for coding i find
15:59:08 <Spark> since coding is a) inventing structure b) naming stuff
15:59:08 <jadrian> Spark: oh
15:59:08 <Philippa> any reason not to have "modify<Foo>" and leave it at that rather than an explicit decrement?
15:59:25 <Philippa> Spark: I'm highly disappointed at you recommending that piece of yank trash :-)
15:59:29 <jadrian> Philippa: yeap, I don't want to export any modification functions
15:59:33 <Spark> heh if you know an alternative
15:59:41 <Spark> theres wordnet...
15:59:44 <jadrian> Philippa: I need to maintain the structure consistent
15:59:47 <Philippa> @google thesaurus
15:59:47 <lambdabot> Sorry, I don't know the command "google", try "lambdabot: @listcommands
15:59:54 <jadrian> Philippa: so no general operations allowed
16:00:03 <Spark> i want a tool like "dict" but that just returns synonyms, antonyms, etc
16:00:24 <Spark> dict is my friend \o/
16:00:27 <Spark> its like
16:00:54 <Spark> within 1 second i have the definition of any word
16:02:27 <monochrom> http://www.cs.utexas.edu/users/EWD/transcriptions/EWD09xx/EWD958.html
16:03:15 <monochrom> you should not use "meaningful" names.  you should document the meaning unambiguously separately instead.  In reality no name can convey everything you wish to say.
16:05:13 <Spark> heh
16:05:18 <Spark> from one extreme to the other!
16:05:43 <Spark> names serve two purposes, dont compromise either...
16:08:28 <Philippa> I think the most important thing is not to have two functions, <foo><bar> and <synonymforfoo><bar> that do different things
16:09:16 <Spark> heh yeah thats so common as well
16:09:20 <Philippa> that screws up your conceptual mapping no end, because like it or not names will get run through the ol' word association
16:09:28 <Spark> "shit weve already got something called talk lets create one called speak now"
16:11:10 <esap> names do two things: They allow you to uniquely distinguish two things and they allow you to express interface.
16:11:32 <Philippa> They do a third thing. They make the brain play word association.
16:11:36 * Spark interfaces with esap
16:11:41 <esap> heh true
16:11:48 <Pseudonym> Grrr.  Why are people so attached to m >> mzero == mzero?
16:12:12 <Philippa> it's like proper products vs side-effecting arrow pseudo-products
16:12:28 <monochrom> because that is what they associate to the "meaning" of "mzero"?
16:12:32 <Philippa> esap: that part is important, you don't want to play association with concepts that make a mess of your understanding of what you're doing
16:12:54 <Spark> things are often named from a certain perspective though
16:12:57 <Philippa> well yeah, it wouldn't be a zero otherwise
16:12:57 <Spark> like "in", "out"
16:12:59 <Pseudonym> monochrom: The "meaning" of mzero is as an identity for mplus.
16:13:20 <Pseudonym> I have no problem with it being a left-zero.
16:13:36 <esap> pseudonym: I think mzero semantics migth come from commit-rollback semantics for exceptions.
16:13:38 <Pseudonym> But monads are sequencing devices, and if you do something before failing, the something may stay done.
16:13:48 <Pseudonym> Yeah, well.  I came from logic programming.
16:13:54 <Pseudonym> Once upon a time.
16:14:03 <Pseudonym> I know all about backtracking and I/O.
16:14:25 <Spark> heh
16:14:35 <Spark> i need to do some of that actually
16:14:38 <monochrom> People always have biases and attach to unwarranted things.
16:14:40 <Spark> ^Ad
16:15:36 <Lor> Wouldn't it be fun to have backtracking IO? :)
16:15:55 <Pseudonym> Lor: Yeah, you could insert the paper back into the laser printer and it could pull the toner off.
16:15:59 <esap> lor: That's not hard to do. Just add 'commit' operation.
16:16:21 <esap> lor: then only perform I/O at commit.
16:16:29 <Lor> esap, how do you backtrack network communication?
16:16:39 <Pseudonym> That'd still break the mzero-is-a-right-zero-of-bind rule.
16:16:43 <esap> lor: only do it when you know you'll be doing it.
16:16:44 * Philippa points out that a whip is a more traditional source of fun for masochists
16:16:56 <esap> lor: And it's not communication you need to rollback.
16:17:04 <esap> lor: It's the database storage
16:17:07 <Philippa> why not? Communication's a side-effect
16:17:10 <Pseudonym> commit :: IO a -> IO a
16:17:17 <Lor> Philippa, in contrast to what?
16:17:21 <Pseudonym> commit (putStr "foo") >> mzero /= mzero
16:17:29 <Lor> Backtracking I/O?
16:17:38 <Philippa> in the generic case, yeah
16:18:09 <Pseudonym> It's actually not I/O which makes backtracking difficult, it's interactivity.
16:18:15 <esap> philippa: ah, but there are two kinds of side effects. Communication is like modifying a local variable. You have a shared queue that you send data to. This queue does not do any side effects.
16:18:28 <Pseudonym> In principle, you could simulate the real world completely inside the machine, and "commit" it when you're done.
16:18:37 <wagle> cause the receiver to also backtrack
16:18:40 <Pseudonym> Assuming that nothing in the real world has changed since you took your snapshot.
16:18:45 <Philippa> sez you. Try printing "fire at will" on the right screen and backtracking the effects :-)
16:18:50 <Philippa> oh, wait, communication right?
16:19:12 <Lor> Hm, backtracking the world...
16:19:13 <Philippa> once you've sent the communication, you've no idea what further effects it's caused out there
16:19:20 <Pseudonym> Right.
16:19:23 <Philippa> quantum IO monad etc etc :-)
16:19:29 <Pseudonym> Also, the real world is not affected only by the program.
16:19:40 * Lor is reminded of Metamorphosis of the Prime Intellect.
16:19:52 <Philippa> no, but evaluation time's indefinite anyway
16:19:53 <Lor> Philippa ought to like it. ;)
16:20:01 <esap> Backtracking the real world is harder. But you can simulate the effect by adding some isolation layers...
16:20:39 <wagle> receiver might not be the real world, might be something that can backtrack
16:20:51 <esap> For the real world, what you do is you don't perform any actions in real world before you know you can successfully complete.
16:21:24 <esap> which is of course not easy :-)
16:21:46 * Philippa heads bedwards
16:22:16 <Pseudonym> Night.
16:22:23 <esap> And transactional semantics can of course cause the system to get stuck in a retry loop. I suppose that retry needs to happen in real world as well.
16:22:25 <esap> Night
16:22:37 <Lor> Night
16:22:59 <wagle> what?  its only 4pm!
16:23:28 * esap reads the watch: 02:23
16:23:42 <wagle> what are you doing going to bed before dawn your time?
16:24:28 <Lor> Perhaps some of us practice the bizarre custom that is called "work".
16:24:33 * Pseudonym notices it's 11:27
16:24:42 <Pseudonym> And I haven't had any caffeine today.
16:27:44 <fraxtal> Pseudonym: sacrilege
16:42:47 <Pseudonym> I'm having instant coffee.
16:42:53 * Pseudonym feels so dirty
16:48:11 <jadrian> in any monad, if I do    a <- ...
16:48:36 <jadrian> previous a's can no longer be refered to, right?
16:48:58 <jadrian> so I can do
16:49:02 <Pseudonym> Correct.
16:49:07 <jadrian> s <- return (x+1)
16:49:10 <Pseudonym> Not true if it's mdo, though.
16:49:19 <jadrian> s <- return <- (y+2)
16:49:25 <jadrian> a <- return s
16:49:31 <jadrian> a will always be the 2nd s
16:49:34 <Pseudonym> Right.
16:49:38 <jadrian> never played with mdo...
16:49:43 <Pseudonym> mdo is fuyn.
16:49:44 <Pseudonym> fun
16:49:52 <Pseudonym> mdo ones <- return (1:ones)
16:49:55 <jadrian> I used think this overshadowing was dangerous
16:49:56 <jadrian> but now
16:50:09 <jadrian> I think it's really usefull...
16:50:13 <Pseudonym> It's no more dangerous than a let expression or a where clause.
16:50:51 <jadrian> can I use monadic notation on non monads?
16:51:03 <Pseudonym> No, but you can use the identity monad.
16:51:20 <jadrian> and I would run it, right?
16:51:25 <Pseudonym> Correct.
16:51:31 <jadrian> do lets, let you do,
16:51:40 <jadrian> a = a + 1?
16:51:40 <Pseudonym> http://www.nomaware.com/monads/html/identitymonad.html
16:51:47 <jadrian> it would be a recursive definition...
16:51:48 <Pseudonym> Yes, but lets are recursive.
16:51:51 <Pseudonym> Right.
16:51:57 <Pseudonym> You can do this, though:
16:52:07 <Pseudonym> let b = a in let a = b+1 in foo a
16:52:17 <jadrian> yes but what if you have 10 of those
16:52:47 <Pseudonym> What about it?
16:53:12 <jadrian> I don't think it is very readable...
16:55:08 <dons> nope. there's even a compiler flag to warn you about it: -fwarn-name-shadowing
16:56:28 <Pseudonym> Of course it's not.
16:56:29 <Pseudonym> :-)
16:56:33 <Pseudonym> But it does work.
16:56:51 <Pseudonym> You could, I suppose, introduce a non-recursive let.
16:56:57 <dons> it's fun to combine name shadowing, with variable names like: (?)
16:57:12 <jadrian> yes I understand it maight be dangerous
16:57:26 <dons> let (?) = (??) in let (??) = (?) + 1 in (???) (??)
16:57:33 <jadrian> but when I have sequential change of a certain data
16:57:36 <dons> and even more fun to replace lets with lambdas
16:57:40 <jadrian> it's quite handy
16:57:58 <jadrian> I never thought I'd be running an Indentitymonad just to use that
16:58:16 <jadrian> but that's the only way I can get readable code
16:58:20 <Pseudonym> dons: I expect a good entry in this year's IOHCC.
16:58:59 <dons> (\(??)->((\(?)->(???)(?))((??)+1)))(?)
16:59:03 <dons> for example :}
16:59:35 <dons> Pseudonym: yeah, I'd like to automate this process, perhaps via TH. something along those lines
17:00:26 <dons> lambda abstractions are essentially non-recursive lets, aren't they?
17:00:39 <dons> so, if you really required that property
17:00:52 <wagle> 0 -!- Link [LinkMaster@100.orlando-06-08rs.fl.dial-access.att.net] has
17:00:52 <wagle>           joined #haskell
17:01:21 <dons> maybe a tool to produce the maximum amount of name-shadowing would be fun, too.
17:01:28 <wagle> that was odd
17:01:56 <Pseudonym> dons: There's a difference between lets and lambda abstractions.
17:02:03 <Link> wagle, I have to agree
17:02:14 <Pseudonym> Something to do with the type system.
17:02:27 <Pseudonym> let-bound variables may be polymorphic, but lambda-bound variables must be monomorphic.
17:02:30 <Pseudonym> Or something.
17:03:03 <dons> yeah, of course.
17:05:05 <dons> hmm. consequence of the monomorphism restriction?
17:05:19 <Pseudonym> No, it's let-polymorphism.
17:05:41 <Pseudonym> I can't remember the details.  Kinda hazy.
17:05:46 <Pseudonym> http://www.theage.com.au/news/Opinion/Legal-advice-on-rhubarb/2005/02/14/1108229927469.html
17:06:24 * dons has a look in IFPL
17:07:29 <dons> rhubarb? that's odd
17:09:34 <Pseudonym> Yes.
17:09:39 <Pseudonym> I thought it was kinda zen.
17:28:10 <SyntaxNinja> any easy way to print an integer in hex?
17:30:24 <dons> sort of: Numeric.showHex 15 []
17:30:30 <dons> "f"
17:31:20 <SyntaxNinja> dons: excellent, thanks :)
17:31:36 <dons> I think we usually decided on something like:
17:31:37 <dons> > "0x" ++ map Char.toUpper (Numeric.showHex 0xdeadbeef [])
17:31:38 <dons> "0xDEADBEEF"
17:31:42 <sh10151> do I even want to know what that is for? :)
17:32:13 <Heffalump> it's usually used as a marker bit pattern
17:32:17 <Heffalump> cos it's easy to spot
17:34:03 <dons> there's a C hex function in $fptools/ghc/compiler/cmm/PprC.hs:pprHexVal
17:34:29 <dons> -- Print in C hex format: 0x13fa
17:34:29 <dons> pprHexVal :: Integer -> SDoc
18:28:02 <LinkMasterSab> Haskell is good at confusing me I have to say
18:50:37 <Cale> LinkMasterSab: It'll do that for a while. You'll thank it later :)
18:56:12 <LinkMasterSab> Cale: I've decided to document my frustrations on my path of learning lots and lots of languages on a blog
18:56:57 <LinkMasterSab> Sound like a good idea?
18:57:02 <Cale> sure :)
18:57:10 <Cale> LinkMasterSab: if you're tackling monads, I'd appreciate it if you have a look at my article on the wiki...
18:57:35 <LinkMasterSab> Alright
18:57:39 <LinkMasterSab> I'll look later...
18:57:53 <LinkMasterSab> I've got to go to dinner now
18:58:00 <LinkMasterSab> http://zenprogramming.blogspot.com/ <- in the mean time
18:58:08 <LinkMasterSab> Feel free to comment ;)
18:58:21 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
18:58:27 <LinkMasterSab> Ah, I'll bookmark it
18:58:39 <LinkMasterSab> Thanks.
18:58:40 <LinkMasterSab> Bye.
19:15:50 <Pseudonym> Keep disconnecting and connecting.  This channel could do with more traffic.
19:15:54 <Pseudonym> Whoops.
19:16:08 <Pseudonym> Some other channel, obviously.
19:16:49 <fraxtal> cale: Ψαν υοθ σεε τηισ?
19:17:48 <Cale> fraxtal: ШЮР
19:18:21 <fraxtal> ςοοτ!
19:21:31 <KrispyKringle> hmm. a bunch of question marks to you, too.
19:21:49 <Spark> heh
19:21:51 * KrispyKringle 's terminal doesn't like utf
19:21:51 <Spark> ¹²³
19:21:52 <Pseudonym> http://www.whatisdeepfried.com/zogg/zogg1.html
19:22:12 <KrispyKringle> yeah, that's a hilarious book, Pseudonym :P
19:22:17 <Pseudonym> :-)
19:22:25 <Spark> ħ
19:24:22 <Spark> its only happy hardcore keeping me awake
19:24:27 <Spark> i gotta get up at 7:30 tommorow too
19:24:58 <Pseudonym> Uhm...
19:25:06 <Pseudonym> I didn't want to know that.
19:25:37 <fraxtal> Happy Hardcore as in Gabber or pron?
19:30:03 <int80_h> hello gang :)
19:30:40 <Pseudonym> @wn gang
19:30:41 <lambdabot> *** "gang" wn "WordNet (r) 2.0"
19:30:41 <lambdabot> gang
19:30:41 <lambdabot>      n 1: an association of criminals; "police tried to break up the
19:30:41 <lambdabot>           gang"; "a pack of thieves" [syn: {pack}, {ring}, {mob}]
19:30:42 <lambdabot>      2: an informal body of friends; "he still hangs out with the
19:30:44 <lambdabot>         same crowd" [syn: {crowd}, {crew}, {bunch}]
19:30:46 <lambdabot>      3: an organized group of workmen [syn: {crew}, {work party}]
19:30:48 <lambdabot>      4: tool consisting of a combination of implements arranged to
19:30:50 <lambdabot> [2 @more lines]
19:30:52 <Pseudonym> @more
19:30:52 <lambdabot> Sorry, I don't know the command "more", try "lambdabot: @listcommands"
19:30:55 <Pseudonym> Hmmm.
19:31:08 <Pseudonym> Did you mean criminals, friends or workmen?
19:31:49 <dons> or tools?
19:32:08 <int80_h> I would say this was a den of thieves, not a pack.
19:32:13 <int80_h> but who wants to quibble ;)
19:32:17 * int80_h smirks
19:33:09 <int80_h> okay I did it, I sent an order in for a haskel book at the library
19:33:14 <int80_h> it shold be here in about a week
19:33:44 <Pseudonym> So how are you planning to fill in a week?
19:33:54 <int80_h> im reading haskell.org
19:34:31 <int80_h> I will also set up a programmign enviroment much like I did for lisp
19:34:41 <Spark> fraxtal: music
19:34:46 <int80_h> I expect haskell.org speaks to that.
19:34:51 <dons> yeah. bootstrap ghc from scratch. that ought to take a week ;)
19:35:01 <Pseudonym> :-)
19:35:02 <Spark> ive never heard porn referred to as happy hardcore before... :)
19:35:05 * int80_h quivers in phear.
19:35:10 <Spark> is that some foreign thing
19:35:14 <int80_h> don
19:35:15 <int80_h> 't
19:35:15 <fraxtal> Spark: Thats what I thought
19:35:21 <int80_h> eep, a week?
19:35:32 <dons> jokes folks
19:35:35 <int80_h> isn't there a compiler that "just works"?
19:35:37 <fraxtal> how the hell am I supposed to add breathing marks in this
19:35:41 <Spark> calling porn hardcore is just asking for someone to go "thats not hardcore, this is hardcore:"
19:35:42 <int80_h> wait I think netbsd has one in pkgsrc
19:35:51 <dons> netbsd/x86 does.
19:35:52 <int80_h> I'm sure of it in fact
19:36:01 <int80_h> yup I knew it :)
19:36:05 <Pseudonym> Cool.  That's that problem solved, then.
19:36:10 <int80_h> I use netbsd, so what a happy coincidence
19:36:31 <int80_h> now, is there a debugger/
19:36:39 <int80_h> erm debugger/editor combo I should use
19:36:39 <dons> netbsd is well supported by ghc, but not by thhe netbsd porters, unfortunately.
19:36:46 <dons> don't need a debugger usually
19:36:51 <Spark> hehe
19:37:05 <dons> any editor will do - esp. if you're on netbsd anyway.
19:37:05 <int80_h> well now I like that.
19:37:28 <int80_h> okay well I am getting used to emacs, because the #lisp people insist on it. So I will use emacs for haskell.
19:37:47 <dons> the #lisp people insist on it? I guess they would, wouldn't they..
19:37:58 <Pseudonym> Basically, any decent editor works so long as you know it well.
19:38:06 <Pseudonym> That's true for any language, of course.
19:38:07 <int80_h> yah well there is a nice debugger called slime for list, but it needs emacs
19:38:19 <int80_h> erm s/list/lisp
19:38:41 <Spark> some editors are easier to know well enough, than others :)
19:38:53 <int80_h> I know vi , but I need practice with emacs
19:39:03 <gzl> emacs haskell mode is decent
19:39:13 <int80_h> I just started using emacs for my c programming as well. It seem foriegn to me. Like culture shock.
19:39:19 <int80_h> sweet :)
19:39:20 <dons> ah, good. netbsd/x86 now has ghc-6.2.1 -- that'll do.
19:39:23 <Spark> i went from emacs -> vim :)
19:39:52 <int80_h> excellent, I just upgraded to 2.0 because sbcl didn't work at all for <2.0
19:40:48 <int80_h> so generally speaking not needing a debugger sounds like a feature.
19:41:16 <int80_h> how do I do stack taces? or does that question not make sense in haskell?
19:41:21 <int80_h> traces
19:41:44 <dons> usually monitoring runtime behaviour is only needed if you're profiling for space or time usage
19:41:53 <dons> not for debugging purposes
19:45:14 <int80_h> where can I read about FFI for haskell
19:45:31 <int80_h> I'm tooling around but haven't found anything yet
19:45:37 <dons> the FFI report, which is available from haskell.org
19:46:06 <int80_h> that would be under report..I see :)
19:51:11 <LinkMasterSab> Thanks for the suggestions Cale
19:51:52 <LinkMasterSab> I don't think I'm ready for your Monads As Containers thing though
20:10:18 <CosmicRay> is there a haskell http server anywhere?
20:27:37 <Nioate> I think so
20:27:57 <jadrian> lattice implies partial order right?
20:28:05 <jadrian> not just pre order...
20:28:24 <Nioate> http://www.haskell.org/~simonmar/abstracts/web-server.html
20:28:35 <CosmicRay>  int80_h : www.haskell.org/ffi from memory
20:28:39 <CosmicRay> Nioate: thanks
20:28:48 <CosmicRay> int80_h: google for haskell ffi and you'll get some reasonable hints too
20:28:59 <CosmicRay> there is a formal spec and then various peopl ehave published some hints
20:29:07 <CosmicRay> the spec is actuallly not too bad to star twith
20:29:59 <Cale> LinkMasterSab: come back to it if/when you're having trouble with learning about monads (they'll eventually show up in the tutorials)
20:30:10 <LinkMasterSab> Yeah, I will
20:30:22 <CosmicRay> the "what the hell are monads" guide is reasonable
20:30:28 <CosmicRay> as is YAHT
20:36:39 <shapr> Good Morning #haskell!
20:36:51 <CosmicRay> good morning shapr!
20:36:57 <LinkMasterSab> Good morning shapr
20:37:16 <shapr> How's that beautiful lambda?
20:37:19 * CosmicRay calculates the time at shapr's place
20:37:28 <shapr> CosmicRay: The time is 5:38am
20:37:33 * CosmicRay figures roughtly 5:30am.
20:37:35 <CosmicRay> woot, I was right
20:37:43 <CosmicRay> what geek rises that early? :-)
20:37:47 <LinkMasterSab> shapr: Those lambdas are confusing me as usual :)
20:37:48 <shapr> LinkMasterSab: hey, are you new here?
20:37:51 <LinkMasterSab> Yes, I am
20:37:56 <LinkMasterSab> I started learning Haskell yesterday.
20:38:01 <CosmicRay> LinkMasterSab: nice
20:38:06 <LinkMasterSab> Terribly bad for your mental health
20:38:15 <shapr> Oh, you're in for a beautiful roller coaster of ideas.
20:38:21 <CosmicRay> LinkMasterSab: I have two links for you.  shapr has many more, I'm sure :-)
20:38:34 <CosmicRay> LinkMasterSab: this is the best haskell tutorial out there: http://www.isi.edu/%7Ehdaume/htut/
20:38:45 <Pseudonym> G'day shapr.
20:38:51 <shapr> g'day Pseudonym
20:38:58 <CosmicRay> LinkMasterSab: and here is some haskell humor.  http://www.haskell.org/hawiki/MegaMonad
20:39:12 <Pseudonym> CosmicRay: A geek does not rise that early.  A geek does often see 5:30am from the other side, though.
20:39:15 <LinkMasterSab> CosmicRay: I don't imagine I'd understand it ;)
20:39:50 <CosmicRay> LinkMasterSab: some of the quotes we assume are funny, but we're not quite sure why, so odn't feel bad :-)
20:39:57 <CosmicRay> Pseudonym: of course :-)
20:40:33 <CosmicRay> so shapr, I'm a little bummed on haskelldb putting DISTINCT on every SELECT and having no way to turn that off
20:40:35 <shapr> CosmicRay: I've discovered that I need calm for my best thinking, and I can get it by staying up later, or by getting up earlier.
20:40:54 <shapr> Well, it is based on set theory, so it makes sense.
20:41:03 <CosmicRay> hm.
20:41:13 <LinkMasterSab> shapr: Haskell is the first language that I'm learning on a path towards programming enlightenment
20:41:14 <CosmicRay> it seems to break things, and is not nice for server resource use.
20:41:16 <LinkMasterSab> I've heard it's a good step
20:41:22 <shapr> LinkMasterSab: I agree!
20:41:30 <CosmicRay> LinkMasterSab: what languages do you know already, if any?
20:41:43 <CosmicRay> shapr: for instance, I want duplicate rows sometimes
20:41:55 <LinkMasterSab> CosmicRay: Hmm... very familiar with Javascript, Python and QBasic
20:42:13 <LinkMasterSab> I also know smatterings of C++ and a bunch of markup stuff
20:42:15 <CosmicRay> LinkMasterSab: you will find there are a *lot* of people that have moved to Haskell from Python
20:42:20 <CosmicRay> LinkMasterSab: I am among them
20:42:35 <CosmicRay> LinkMasterSab: python actually borrows some ideas from haskell
20:42:39 <LinkMasterSab> CosmicRay: Good to know
20:42:53 <CosmicRay> LinkMasterSab: haskell's indentation system is probably loosely borrowed from python
20:42:54 <LinkMasterSab> Python is my favorite of the "imperative" languages
20:42:58 <CosmicRay> mine too
20:43:04 <CosmicRay> though haskell is now my favorite language
20:43:07 <LinkMasterSab> I'll probably continue to use it
20:43:19 <CosmicRay> LinkMasterSab: you may also be interested in my MissingPy library, which lets you call Python code from Haskell.
20:43:31 <shapr> I think Haskell is about fifteen years old, I wonder if it's had significant whitespace the whole time?
20:43:55 <CosmicRay> shapr: hum.  could it be that guido stole the idea from haskell?
20:44:00 <LinkMasterSab> CosmicRay: Hmm, that sounds nice
20:44:11 <CosmicRay> i always thought he was the first one that used it since fortan or so
20:44:17 <Pseudonym> Occam used it.
20:44:23 <Pseudonym> And Miranda used it.
20:44:32 <Pseudonym> Occam is older than Miranda.
20:44:45 <Pseudonym> Not sure about the pre-Miranda Turner languages.
20:44:47 <Gahhh> How do you use sockets in haskell ?
20:44:58 <shapr> Since Haskell is 'an open source copy of Miranda' it's likely that it's been there from the beginning.
20:45:05 <CosmicRay> Gahhh: see Network.* in your library reference
20:45:06 <Pseudonym> Yes, it was.
20:45:14 <CosmicRay> Gahhh: if you don't know where the library reference is, it is here:
20:45:16 <Pseudonym> Orwell, Phil Wadler's Miranda-alike, also used it.
20:45:16 <CosmicRay> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
20:45:21 <LinkMasterSab> If anyone's interested, I'm recording my experiences in a blog: http://zenprogramming.blogspot.com/
20:45:23 <CosmicRay> orwell, heh
20:45:46 <Pseudonym> CosmicRay: Props if you work out _why_ it was named Orwell.
20:45:46 <shapr> I bet he started that language in 1984.
20:45:52 <Pseudonym> Wrong.
20:45:54 <Pseudonym> But close.
20:46:02 <shapr> He wanted to name it NewSpeak?
20:46:12 <CosmicRay> LinkMasterSab: nice.  I also recorded my impressions at changelog.complete.org
20:46:19 <Pseudonym> Nope, but even closer.
20:46:37 <shapr> I record my impressions at http://www.ScannedInAvian.com/ !
20:46:38 <CosmicRay> you'll have to search for haskell, though, because they've probably bumped off the front page by now
20:46:47 <Pseudonym> The real reason is even more subtle.
20:46:56 <shapr> Pseudonym: ok, I give up, why?
20:46:59 <Pseudonym> He mistakenly thought that Orwell wrote "Brave New World".
20:47:04 <Pseudonym> Actually, it was Huxley.
20:47:04 <CosmicRay> hah
20:47:17 <CosmicRay> yes, that is subtle
20:47:20 <Pseudonym> And the character of Miranda, from The Tempest, first uttered the phrase "brave new world".
20:47:35 <shapr> Wow, that's an interesting connection.
20:47:38 <LinkMasterSab> That's a pretty big screw p
20:47:39 <LinkMasterSab> up*
20:47:40 <Pseudonym> Yeah, I thought so.
20:48:03 <CosmicRay> LinkMasterSab: anyway, you are right.  Haskell is different than anything you've ever done before.
20:48:04 <Pseudonym> It would have been very clever if he'd have gotten it right.
20:48:19 <CosmicRay> Here's another fun little example.
20:48:26 <CosmicRay> import MissingH.List
20:48:26 <CosmicRay> main = do
20:48:26 <CosmicRay>        c <- getContents
20:48:26 <CosmicRay>        putStr (unlines(filter (\line -> contains "Haskell" line) (lines c)))
20:48:30 <CosmicRay> that's a simple grep in haskell.
20:48:40 <shapr> I'd like to name a spoken concatenative language Secret Joy. That assumes I get around to writing something that actually works.
20:48:40 <CosmicRay> yes, I know it can be written smaller
20:49:08 <CosmicRay> LinkMasterSab: getContents returns a string representing the entre contents of the input.
20:49:09 <LinkMasterSab> The only language I've ever written an interpreter for was Brainfuck ;)
20:49:42 <CosmicRay> LinkMasterSab: however, this program works fine for files that are gigabytes large
20:49:43 <CosmicRay> LinkMasterSab: because haskell is lazy, the input is only read as it is demanded, so although you can process it like a string (with care), it is really backed by I/O
20:49:56 <Pseudonym> I had a third year undergraduate project which was to write a compiler for a toy language.
20:50:13 <shapr> So you wrote SantasWorkshop, a DSL for toys?
20:50:20 <CosmicRay> LinkMasterSab: so many problems in haskell can be reduced to operations on lists... a string is a list of chars... so there we go.
20:50:27 <Pseudonym> Mine ended up at about 50 pages, and did flow analysis, global value numbering and aggressive peephole optimisatio.
20:50:49 <Pseudonym> I'm surprised the marker made it through the whole program, actually.
20:50:54 <CosmicRay> LinkMasterSab: I like to say that haskell manipulates functions with the same ease that perl maniuplates strings.  also, haskell has no loops because we don't need them :-)
20:51:09 <shapr> We're loopy enough by ourselves.
20:51:13 <LinkMasterSab> CosmicRay: I think what bugs me the most is that it seems like Haskell is great for utilities, but things like games are going to take quite some thinking...
20:51:43 <CosmicRay> LinkMasterSab: functional languages like haskell are used heavily by people doing AI
20:51:50 <Gahhh> games dont take quite a bit of thinking otherwise ?
20:51:55 <CosmicRay> LinkMasterSab: also there are SDL and OpenGL bindings for haskell, so games are not out of the guestion
20:52:07 <LinkMasterSab> Gahhh: It's rather straight-forward in imperative form though
20:52:16 <CosmicRay> LinkMasterSab: in fact, many games are event-oriented anyway, and haskell works great with that model
20:52:16 <Gahhh> LinkMasterSab, I can't see why.
20:52:30 <Pseudonym> I'm curious why, when people find a language, they always ask "but can I write games?"
20:52:45 <LinkMasterSab> Pseudonym: Because I'm a game programmer by hobby
20:52:52 <Gahhh> Pseudonym, I dont think it's that popular a question.
20:52:53 <LinkMasterSab> And lots of people are.
20:53:05 <shapr> I would guess that it's more fun to use a game program you've written than a calculator or grocery list program.
20:53:21 <LinkMasterSab> That it is.
20:53:27 <LinkMasterSab> I wrote a game in Pygame for a contest over winter break
20:53:28 <Pseudonym> Yeah, but it's also fun to write a compiler or a renderer.
20:53:33 <Gahhh> I used to hack demos in assembly on my amiga. those were the days. not games exactly, but similar.
20:53:43 <shapr> I think the real appeal of games is very similar to that of programming languages, it's a system to explore.
20:53:45 <Pseudonym> Anyway, I did write tic-tac-toe in Haskell. :-)
20:53:56 <shapr> Pseudonym: no! don't show that to a newbie!
20:54:00 <Pseudonym> :-)
20:54:05 <shapr> Talk about losing sanity points!
20:54:15 <LinkMasterSab> shapr: Since you incorporate so many things into a game, yeah, it's a great medium
20:54:21 <CosmicRay> LinkMasterSab: I suspect you could do some fairly cool stuff in haskellwith games
20:54:30 <CosmicRay> hmm.
20:54:35 <CosmicRay> I ought to write a zcode interpreter.
20:54:45 <LinkMasterSab> Yes, but the absense of objects with internal state is what bothers me
20:54:48 <CosmicRay> dammit, too many cool things to mess with!
20:54:48 <shapr> CosmicRay: have you seen Pseudonym's tictactoe?
20:54:53 <CosmicRay> shapr: nope
20:54:55 <CosmicRay> LinkMasterSab: ahh
20:55:01 <Oeje1> It seems Clean has had array comprehension at least since 1.3.
20:55:05 <CosmicRay> LinkMasterSab: we don't have that because we don't need it.
20:55:12 <CosmicRay> LinkMasterSab: you will hear this a lot :-)
20:55:14 <LinkMasterSab> CosmicRay: So I've read
20:55:20 <CosmicRay> LinkMasterSab: oop is data centric.
20:55:28 <CosmicRay> LinkMasterSab: w ehave functions with internal state.
20:55:40 <shapr> This should be it, but it doesn't look right on the screen - http://www.scannedinavian.org/iohcc/zeroth-2003/Pseudonym.hs
20:55:45 <CosmicRay> for instance:
20:55:51 <CosmicRay> func1 x y =
20:56:15 <CosmicRay>   \z -> x + y + z
20:56:24 <shapr> hiya Cale
20:56:24 <Pseudonym> http://andrew.bromage.org/Pseudonym.hs
20:56:30 <Cale> hello
20:56:33 <CosmicRay> that will return a function that essentially takes the parameters as internal state.
20:56:38 <shapr> Pseudonym: 403
20:56:38 <Pseudonym> It's standard Haskell 98, so you can just run it with "runhugs".
20:56:41 <CosmicRay> though of course there are shortcuts for this.
20:56:58 <CosmicRay> whoa
20:57:20 <CosmicRay> samn that is cool
20:57:23 <Pseudonym> Try again.
20:57:31 <CosmicRay> try again?
20:57:47 <Pseudonym> Yes.  Should be readable now.
20:58:48 <CosmicRay> LinkMasterSab: oh, also, we have typeclasses.  sorta oop in reverse.
20:58:49 <shapr> Hm, my local copy is just fine. I wonder what's wrong with the online copy.
20:59:19 <CosmicRay> LinkMasterSab: so instead of defining methods on objects....
20:59:34 <LinkMasterSab> CosmicRay: I'm so accustomed to just storing data and then using it
20:59:36 <CosmicRay> we can use arbitrary data types, and give the system a set of functions that make them conform to a standard
20:59:48 <CosmicRay> LinkMasterSab: I understand
20:59:48 <shapr> yay, fixed - http://www.scannedinavian.org/iohcc/zeroth-2003/Pseudonym.hs
21:00:00 <CosmicRay> LinkMasterSab: this is a radical difference in thinking about things
21:00:37 <CosmicRay> LinkMasterSab: once you grok it, it is liberating
21:00:53 <CosmicRay> LinkMasterSab: until you grok it, it probably seems constricting
21:01:32 <shapr> I wonder if it's nearing time for another IOHCC.
21:01:49 <Pseudonym> I thought we did it around the middle of the year.
21:02:27 <shapr> Sounds reasonable, I can never remember what time of year stuff happens.
21:02:59 <CosmicRay> LinkMasterSab: anyway, do start with that YAHT link I gave you
21:03:25 <shapr> Oh, I should ping all the TMR authors to see if they'll have their articles by Monday.
21:04:01 <LinkMasterSab> CosmicRay: I will
21:04:14 <shapr> Pseudonym: think you'll be ready by Monday?
21:04:28 <LinkMasterSab> Haha, you know what's funny? List comprehensions are one of my favorite Python features. "Python's list comprehension syntax is taken (with trivial keyword/symbol modifications) directly from Haskell. The idea was just too good to pass up."
21:04:34 <Pseudonym> shapr: Should be.
21:04:50 <shapr> Cool, who else can I poke..
21:05:47 <CosmicRay> LinkMasterSab: ahh, I see you found the haskell page on the python wiki :-)
21:06:10 <CosmicRay> LinkMasterSab: and you know the other ironic thing?  I don't usually use them in haskell because I think recursive expressions are clearer :-)
21:06:20 <CosmicRay> but like you, I loved them in python
21:06:33 <heatsink> i never noticed the list comprehension syntax similarity before.
21:07:01 <LinkMasterSab> CosmicRay: I use them so much it's not funny
21:07:43 <LinkMasterSab> Actually, with the new generator expressions
21:07:45 <LinkMasterSab> I might use them less
21:07:46 <CosmicRay> LinkMasterSab: oh, you are going to love haskell.
21:07:51 <CosmicRay> absolutely love it.
21:08:00 <LinkMasterSab> I sure hope so.
21:08:03 <CosmicRay> haskell lists will blow your mind
21:08:15 <LinkMasterSab> That fibo example was nice
21:08:27 <CosmicRay> ah, the one that generates an infinite list, then looks up a particular element in it?
21:08:40 <CosmicRay> yes, it is not a problem to have infinite lists in haskell :-)
21:08:40 <LinkMasterSab> Nah, it generates an infinite list is all
21:08:49 <CosmicRay> laziness again
21:08:51 <LinkMasterSab> Well, you can do infinite lists in Python
21:08:55 <LinkMasterSab> Just takes more work
21:09:20 <CosmicRay> well, you could make a object that implements the list interface so that it behaves similarly to  alist
21:09:21 <shapr> Same for recursion based code.
21:09:26 <CosmicRay> a python list itself cannot be infinite
21:09:36 <LinkMasterSab> Yeah
21:09:51 <LinkMasterSab> Also, Haskell recursion doesn't have the overhead problem, does it
21:10:05 <shapr> You mean tail call optimization?
21:10:08 <CosmicRay> LinkMasterSab: do it right and the compiler optimizes it nicely, indeed.
21:10:25 <LinkMasterSab> You call a function within itself over and over in Python and you'll hit stack problems
21:10:32 <CosmicRay> right
21:10:36 <dons> and in gcc too.
21:10:38 <LinkMasterSab> Or at least, progressively slower loops
21:10:42 <CosmicRay> you will usually not have a problem with that in haskell
21:10:43 <shapr> g'day dons
21:10:48 <CosmicRay> it is possibly to write really bad code that does
21:10:54 <CosmicRay> but most people will intuitively get it right
21:10:58 <LinkMasterSab> That's a good thing
21:10:59 <dons> it's so much fun watching gcc blow up, and then see haskell scoot through.
21:11:08 <dons> heya shapr
21:11:29 <dons> recursive, unboxed functions in haskell are where you can really beat C
21:11:33 <CosmicRay> LinkMasterSab: sometimes it is not even necessary to have an exit condition in haskell.
21:11:56 <CosmicRay> LinkMasterSab: haskell will only continue the recursion while the requested output is in doubt.
21:12:08 <CosmicRay> LinkMasterSab: that is frequently used to create infinite lists.
21:12:12 <LinkMasterSab> CosmicRay: Haskell is going to be an interesting step in the learning path, probably one that I'll keep using
21:12:26 <CosmicRay> LinkMasterSab: that's exactly how I felt about it when I started
21:12:38 <CosmicRay> LinkMasterSab: but I find it annoying to code in anything else these days.
21:12:52 <LinkMasterSab> But in the spirit of keeping my infant blog alive, I have to move past it
21:12:54 <CosmicRay> other languages just feel... less intelligent.
21:13:11 <CosmicRay> LinkMasterSab: nah, you can just mock a new language every month :-)
21:13:19 <LinkMasterSab> Hehe :P
21:13:22 <CosmicRay> LinkMasterSab: check out http://lambda-the-ultimate.org/
21:13:33 <CosmicRay> the programming languages blog
21:13:35 <LinkMasterSab> Blah, I just tried to ctrl+t in IE
21:13:47 <CosmicRay> LinkMasterSab: Personally, I like to Alt-F4 in IE.
21:14:14 <LinkMasterSab> CosmicRay: I have to agree
21:14:15 <shapr> You could make up your own languages. Haskell is pretty good at writing languages.
21:14:23 <CosmicRay> quite right
21:14:30 <CosmicRay> haskell also makes it easy to parse haskell
21:14:33 <CosmicRay> or to generate haskell
21:14:34 <LinkMasterSab> I do want to hit C# and Java htough
21:14:39 <LinkMasterSab> I really want to rip on Java.
21:14:42 <CosmicRay> heh
21:14:43 <shapr> heh
21:14:49 <CosmicRay> what's the challenge in that? :-)
21:14:50 <LinkMasterSab> I have these intense hateful feelings for it :D
21:14:52 <heatsink> CosmicRay: though it's not as good for those purposes as lisp... 9_9
21:15:00 <LinkMasterSab> Well, Java is an industry standard
21:15:06 <LinkMasterSab> I think I'd find myself in a better position if I knew it
21:15:08 <CosmicRay> really, java is pthon plus tons of annoying crap
21:15:22 <LinkMasterSab> I'll probably just learn how to use Java enough to use Jython
21:15:35 <CosmicRay> LinkMasterSab: yes, java is an industry standard.  so is windows.
21:15:40 <CosmicRay> jython is one damn cool piece of hackery
21:15:45 <LinkMasterSab> And say hey, "I'm using Java man, look"
21:15:49 <CosmicRay> heh
21:15:55 <LinkMasterSab> I don't like the industry standards.
21:16:10 <LinkMasterSab> But you can't ignore them if you want to get into the industry
21:16:14 <shapr> LinkMasterSab: btw, have you found Good Pizza yet?
21:16:24 <LinkMasterSab> shapr: Yes, for dinner
21:16:28 <shapr> ah, excellent.
21:16:31 <heatsink> CosmicRay: can you understand how the code will run after it goes through the compiler?
21:16:31 <LinkMasterSab> Pepperoni and mushroom
21:16:32 <shapr> Suddenly I want Pizza.
21:16:35 <CosmicRay> shapr: Ale Emporium, 86th and Alisonville, Indianpolis, IN, USA
21:16:41 <LinkMasterSab> shapr: A little early?
21:16:47 <CosmicRay> shapr: I believe they do fedex them packed in dry ice
21:16:50 <shapr> Here's a cool use of jython - http://www.scannedinavian.org/~shae/nokia-emu-jython.png
21:16:59 <CosmicRay> heatsink: hm?
21:17:07 <LinkMasterSab> Oh yeah, that's what I remember loving about Javascript
21:17:08 <CosmicRay> cool shapr
21:17:11 <LinkMasterSab> All functions were lambda
21:17:20 <LinkMasterSab> That's one thing I don't like about Python
21:17:26 <LinkMasterSab> You can't pass new functions
21:17:35 <CosmicRay> you can pass functions in python
21:17:44 <CosmicRay> anonymous functions even
21:17:45 <LinkMasterSab> Yes
21:18:01 <LinkMasterSab> But in Javascript you can do "pass(function () {hi})
21:18:04 <LinkMasterSab> "
21:18:06 <LinkMasterSab> It's rather nice.
21:18:18 <KrispyKringle> ho is that different than a lambda?
21:18:20 <KrispyKringle> how, even
21:18:30 <heatsink> CosmicRay: For example, I remember some prelude functions -- fold or scan -- will cause stack overflow when given sufficiently long lists as arguments.  You can opt to use strict alternatives that don't overflow.
21:18:36 <CosmicRay> that seems like pass(lambda: return "hi") to me
21:18:46 <shapr> Pizza for 6:30am breakfast sounds just fine to me.
21:18:47 <CosmicRay> heatsink: ah
21:18:49 <KrispyKringle> yeah, looks identical, CosmicRay
21:18:52 <LinkMasterSab> CosmicRay: Yes, but you can do multiple lines
21:18:58 <CosmicRay> LinkMasterSab: ah.
21:19:05 <heatsink> But I don't understand the compiler's translation well enough to look at some code and know when stack overflows happen.
21:19:07 <KrispyKringle> you can't do multiple lines in pthon?
21:19:07 <KrispyKringle> huh
21:19:08 <CosmicRay> LinkMasterSab: python's lambdas are also limiting in that they can only be expressions
21:19:09 <LinkMasterSab> pass(function () {hi; hi2; hi3; if (true) {hi4; hi5;}})
21:19:16 <CosmicRay> KrispyKringle: yeah they suck in a number of ways
21:19:19 <LinkMasterSab> KrispyKringle: Not in a lambda
21:19:26 <LinkMasterSab> CosmicRay: Yes.
21:19:27 <KrispyKringle> that stinks
21:19:31 <mrsolo> well
21:19:33 <shapr> truly, it stinks.
21:19:40 <LinkMasterSab> I never use Python lambdas.
21:19:40 <CosmicRay> LinkMasterSab: haskell lambdas share that limitation, but we don't care, because haskell has nothing but exceptions :-)
21:19:56 <heatsink> The python limit on lambdas is due primarily to python's syntax.  You can't put a block inside a statement, for example.
21:19:58 <KrispyKringle> yeah, it doesn't seem a huge limitation
21:19:59 <LinkMasterSab> CosmicRay: Right, but for imperative, passing anonymous functions is pretty cool.
21:20:07 <LinkMasterSab> heatsink: Yeah.
21:20:21 <LinkMasterSab> KrispyKringle: I've had quite a few uses for delayed execution of code, though
21:20:25 <shapr> I keep trying to build functional pipelines in Python and being denied.
21:20:35 <heatsink> shapr: how?
21:20:45 <CosmicRay> well it is late and my batteries are almost out
21:20:46 <CosmicRay> cyall tomorrow
21:21:05 <heatsink> shapr: (lambda x: f(g(x)))
21:21:18 <shapr> sort = lambda x: (lambda x=x[:]: x.sort() or x)()
21:21:29 <LinkMasterSab> You can't do that
21:21:33 <LinkMasterSab> lambda is a keyword
21:21:39 <LinkMasterSab> Can't put it inside of another lambda
21:21:44 <LinkMasterSab> As far as I know.
21:22:03 <shapr> Works here.
21:22:06 <LinkMasterSab> Really?
21:22:08 <shapr> python 2.3.5
21:22:11 <LinkMasterSab> It's still rather ugly.
21:22:14 <LinkMasterSab> I wouldn't use it.
21:22:33 <shapr> I use it to get the evaluated result rather than a side-effect.
21:22:47 <shapr> list.sort() is in-place, like list.reverse(), etc
21:22:56 <LinkMasterSab> Yeah.
21:22:58 <heatsink> I see.
21:23:00 <LinkMasterSab> In-place is nice to have in some places.
21:23:21 <LinkMasterSab> Python 2.4 has the built-in "sorted" function though
21:23:23 <mrsolo> i remember there was a debate in python mailing list that lamda shouldn't be in python in the first place.. people went back and forth
21:23:34 <heatsink> why not def sort(x): x = x[:]; x.sort(); return x
21:23:38 <LinkMasterSab> So if you use Py2.4, then you no longer have to do that.
21:23:46 <LinkMasterSab> Yes, heatsink has a point
21:23:49 <shapr> One advantage of an operation returning its result is that you can stack up a pipeline of stuff. Seems clearer to me.
21:24:13 <LinkMasterSab> sorted(list) returns the a copy of the list sorted
21:24:16 <heatsink> I suspect sort was made in-place so in-place sorting algorithms could be used.
21:24:25 <shapr> mrsolo: Yes, Guido is not in favor of having FP bits in Python.
21:24:51 <shapr> It was done in-place because Guido thought it was more efficient to not make a copy at the time.
21:25:08 <heatsink> since when was python efficient?
21:25:09 <LinkMasterSab> I'm glad that "sorted" was added though.
21:26:40 <shapr> In any case, pipelines are powerful in a non-strict language, because you can use partial input immediately.
21:26:48 <LinkMasterSab> Oh man, I actually got this page to be almost identical in IE and Firefox with this Javascript fix
21:27:43 <LinkMasterSab> So when can we stop making our pages IE compliant?
21:28:11 <Pseudonym> LinkMasterSab: As soon as IE actually supports the relevant standards.
21:28:23 <Pseudonym> Then you can make your pages Firefox-only with impunity.
21:28:34 <LinkMasterSab> That'll never happen :(
21:29:06 <LinkMasterSab> I think CSS should have a way to detect browsers
21:29:14 <LinkMasterSab> Would be a nice feature.
21:30:42 <LinkMasterSab> I have entirely too many IRC channels open
21:40:30 <shapr> region allocation is really fascinating.
21:40:43 <heatsink> what about it?
21:41:41 <shapr> I'm just about how to apply region inference and parallel arrays to running Haskell programs on a bunch of Cell cpus.
21:41:48 <shapr> er "thinking about"
21:42:14 <heatsink> hmm, what is "region inference"?
21:42:40 <shapr> http://www.google.com/search?q=region+inference+ml+kit&ie=UTF8
21:43:09 <shapr> It's sort of like really cool GC.
21:43:37 <shapr> Or maybe it's like tail-call optimization for memory.
21:44:04 <heatsink> It sounds like what the procedural people call pointer analysis.
21:44:48 <shapr> I don't know about pointer analysis.
21:44:59 <shapr> Heard of it a few times, that's all.
21:45:31 <heatsink> In C and fortran, compilers want to know whether memory accesses can be safely reordered so they can generate more efficient code.
21:46:11 <heatsink> Steensgard type unification is performed by microsoft and intel compilers today.
21:46:48 <shapr> Yeah, that sounds similar. Though I think region inference can let you calculate most of a program in such a way that its memory can be guaranteed to safe to free as a single chunk.
21:48:27 <shapr> I'm interested in region inference as a way to reduce or remove cross-CPU locking in distributed GC.
21:49:37 <heatsink> It looks like regions are analogous to stack frames.
21:49:53 <heatsink> ah! yes.  "letregion"
21:50:19 <shapr> The best result would be a way to easily package up enough code + data to hand off to one of the simplified 601e CPUs on the side of a Cell.
21:51:02 <LinkMasterSab> Talking about those new CPUs?
21:51:03 <heatsink> right.  My understanding is that you'd have to serialize the program because there is no shared address space and data transfers are done in blocks.
21:51:11 <heatsink> LinkMasterSab: yes.
21:51:25 <LinkMasterSab> The ones that are supposed to revolutionize multiple processing?
21:51:33 <LinkMasterSab> Or somethign?
21:51:35 <LinkMasterSab> something*
21:51:37 <heatsink> only if people can make software run on them.
21:52:07 <LinkMasterSab> Yeah, so I've heard of those. Heard lots of good and lots of bad about them
21:52:55 <shapr> The 'bad' is that 99% of the current programming languages won't work on the Cell.
21:53:08 <heatsink> We're trying to make C work on the cell.
21:53:20 <shapr> Your company?
21:53:47 <heatsink> actually, we weren't trying to make it work on the cell, per se, but since the cell came out it's close enough to our (fairly abstract) target architecture that we'll want to target it.
21:53:57 <LinkMasterSab> Well, if we can get programming languages to work on the things, it's going to be very nice.
21:54:57 <shapr> I'm the sort of radical who would want to port GHC + nested data parallelism + region inferencing to the Cell and then just tell everybody to learn it.
21:55:40 <heatsink> The hard part is getting that self-contained subprogram.
21:56:03 <Pseudonym> shapr: You could try porting SISAL first.
21:56:19 <shapr> Yeah, that's why I'm reading these region inference papers, to see if that's workable.
21:56:30 <shapr> Pseudonym: or Nesl, or maybe FISh?
21:56:38 <LinkMasterSab> Yeah, I'm going to bed now.
21:57:07 <Pseudonym> Don't know them.
21:57:38 <shapr> I'm not sure about FISh, but Nesl is just another SISAL clone, NDP arrays.
21:58:10 <shapr> I wonder if chalmers does any research on this stuff.
21:59:29 <shapr> Bah, I should focus on TMR, FLM, etc. It's better to release software than dream unrealistic dreams.
22:02:53 <shapr> Someone was asking me about haskellDB on haskell.org, but I forget who. Anyway, I got email back from Daan, he said he's fine with me changing it to point to the sourceforge project.
22:09:33 <Pseudonym> Gotta go.  Nytol!
22:22:06 <Gahhh> yay. I made my first haskell program with sockets.
22:57:06 <tintin> cool Gahhh
22:59:11 <Gahhh> do I need to use a lambda function to be able to use an 'if' within a do block ?
23:01:52 <heatsink> no
23:02:17 <heatsink> do if True then return 3 else return 2
23:02:29 <Gahhh> hmm
23:11:23 <shapr> Man that Oleg post is scary.
23:11:34 <shapr> "It really begins to look like Unlambda..." -- Oleg Kiselyov
23:11:58 <heatsink> what does?
23:12:13 <heatsink> ```sii``sii
23:15:53 <shapr> heatsink: the post on haskell@haskell.org with the subject "Automatic pointless translation"
23:18:03 <heatsink> this month?
23:18:38 <shapr> just this hour or so
23:20:11 <heatsink> that's probably why it's not in the archive.
23:24:03 <shapr> Is there a library to do a chess-board-style show of an array?
23:24:06 <shapr> hiya pesco
23:25:58 <Gahhh> is that TheHunter's pointless stuff ?
23:28:05 <shapr> It's obviously related, but I don't know if Oleg just had a sudden inspiration after reading TheHunter's and hacked that up.
23:28:31 <shapr> Who understands the Oleg?
23:28:38 <shapr> Surely not me.
23:29:15 <Gahhh> musasabi understands understanding.
23:40:02 <shapr> This is really cool - http://www.georgehart.com/index.html
23:45:19 <shapr> Is there an option to build the 6.4 rc with OpenGL?
23:47:44 <shapr> oh, I've already got one.
23:48:14 <shapr> except for - Loading package GLUT-2.0 ... linking ... ghc-6.4.20050212: /home/shae/download/tmp/haskell/ghc/ghc-6.4.20050212/libraries/GLUT/cbits/HSGLUT_cbits.o: unknown symbol `glutBitmap8By13'
23:48:44 <shapr> Is that a real error, or just the non-standard nvidia libs problem?
23:49:16 <heatsink> nice polyhedra.
23:51:18 <shapr> Now that's a geeky pickup line.
23:54:45 <heatsink> Is that a yes or a no?
