00:57:18 * boegel greetz #haskell 
01:02:37 <autrijus> yo.
01:03:49 <Lemmih> Hello boegel.
01:10:25 * boegel rubs his eyes because of lack of sleep
01:11:36 <Svrog> hi
01:11:44 <jlouis> oy #haskell
01:14:40 <boegel> y0 jlouis 
01:43:21 <boegel> @wiki TheMonadReader
01:43:22 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
01:46:40 <viirya> autrijus: could pugs run in hugs?
01:46:47 <autrijus> viirya: not yet
01:46:59 <autrijus> viirya: it currently improt GHC.IOBase
01:47:07 <autrijus> but it should be able to port it to hugs with minimal effort
01:47:52 <viirya> it complains unexpected '<-' occured in AST.hs
01:47:54 <autrijus> viirya: but ghc is quite easy to install anyway
01:48:09 <autrijus> ah. that's pattern guards. hugs doesn't have it.
01:48:13 <autrijus> viirya: switch to ghc!
01:48:18 <viirya> ha
01:48:42 <autrijus> it's straightforward to port pattern guards into hask98.
01:48:44 <autrijus> it's just ugly to do so.
01:48:59 <viirya> I like the interpreter mode more. :)
01:49:05 <autrijus> viirya: there is ghci.
01:49:09 <autrijus> ghci is exactly like hugs.
01:49:21 <autrijus> and comes with ghc.
01:49:28 <autrijus> so, you can "alias hugs ghci"
01:49:32 <viirya> oh, i don't that. i'll try
01:49:42 <autrijus> =)
01:50:04 * boegel like ghc for the speed, but hugs for the error messages
01:50:07 <boegel> +s
01:50:13 <autrijus> I found that I can't grok hugs error msgs.
01:50:21 <autrijus> and ghc's error msg always makes sense.
01:50:25 <autrijus> but it may just be me.
01:50:55 <autrijus> the only time the error msg doesn't make any sense is in HList.hs.
01:51:00 <autrijus> but I guess it's not ghc's fault.
01:51:01 <boegel> I like the hugs error msgs better
01:55:21 <autrijus> viirya++ # trying out pugs
02:07:46 * boegel thinks lambdabot needs a @active tag
02:08:17 <Heffalump> a what?
02:09:23 <boegel> Heffalump: like the @seen tag
02:09:28 <boegel> @seen Heffalump 
02:09:29 <lambdabot> Heffalump is in #haskell.
02:09:56 <boegel> then @active would return: Heffalump was active 0h01m ago
02:10:01 <boegel> or something like that
02:10:32 <boegel> I know there's the whois command, but that inter-channel
02:10:37 <boegel> s/that/that'sw
02:10:39 <boegel> -w
02:10:40 <boegel> (grr)
02:15:28 <Heffalump> ah, yes
02:15:48 <Heffalump> @seen heffalump
02:15:48 <lambdabot> I haven't seen heffalump
02:15:56 <Heffalump> bah, shapr needs to apply my patch :-)
02:23:03 <lightstep> does somebody here understand ghc flags?
02:25:12 <lightstep> eh. i'll ask anyway, and hope for an answer
02:25:29 <lightstep> how can i add a directory where ghc should look for .hi files?
02:25:34 <pesco> -i
02:25:51 <pesco> I think?
02:26:02 <lightstep> i thought so, but from the ghc -v output, it only looks there for source files
02:26:33 <pesco> Try -I. Then check the users' guide.
02:26:45 <lightstep> thanks
02:30:07 <dons> -i
02:31:47 <dons> -idir1:dir2 for example. -i with a space resets the search path
02:32:02 <boegel> hey dons
02:32:19 <dons> -I is for looking for #include files
02:32:24 <dons> hey boegel
02:32:32 <dons> how's the parsing going?
02:32:38 <boegel> quite well !
02:32:51 <boegel> it's parsing everything it should now
02:32:54 <dons> cool
02:33:03 <boegel> which allows me to render this: http://studwww.ugent.be/~kehoste/thesisPublic/website/05_02_2005/HRayGUI-8.png
02:33:03 <boegel> :D
02:33:29 <boegel> @index time
02:33:30 <lambdabot> bzzt
02:33:33 <boegel> @index cputime
02:33:33 <lambdabot> bzzt
02:33:36 <boegel> @index cpuTime
02:33:36 <lambdabot> bzzt
02:33:40 <boegel> hmm...
02:34:00 <lightstep> i usr -i. and ghc complains "Can't find module". -v says "locations searched". and lists the default directory for the file with .hi extension. it looks the directories that i give only for .hs and .lhs files
02:34:27 <dons> it always searches '.' anyway
02:34:51 <lightstep> only for source files, not interface files
02:34:53 <dons> boegel: ! cool
02:35:22 <lightstep> boegel: where is the second light source?
02:35:24 <dons> it's reading .hi files, unless you've turned on --make, afaik
02:35:32 <lightstep> err
02:35:40 <lightstep> but without --make, i get link errors
02:35:44 <boegel> lightstep: I'll up the scene description, you can see for yourself, ok ?
02:36:24 <lightstep> ok
02:36:44 <lightstep> tons of undefined references
02:37:33 <dons> no, you should use --make unless you have a build system that can handle dependencies
02:37:49 <dons> and -i will add to the list of dirs to build && find .hi files in
02:38:08 <dons> "In --make mode or GHCi, GHC will look
02:38:08 <dons> for a source file for Foo and arrange to compile it first. Without --make, GHC will look for the
02:38:11 <dons> interface file for Foo, which should have been created by an earlier compilation of Foo."
02:38:47 <dons> is there a hierarchical module name getting in the way, perhaps?
02:38:52 <lightstep> ok. so if i downloaded some library that doesn't give me .o files, it bad, right?
02:39:20 <dons> could be alright, if there are .a files
02:39:33 <dons> then you might just have a ghc -package
02:39:53 <lightstep> how do i make ghc look at /usr/lib for .o and .a files?
02:40:12 <dons> ah! is this a C lib or a Haskell lib?
02:40:27 <lightstep> haskell
02:40:41 <dons> but it is a package, not a bunch of src?
02:40:54 <Heffalump> dons: I've gone for the approach of replacing FilePath in some places with a type class encapsulating the "exists, modified time, text of and name of" operations, btw, and adding extra interfaces that allow an arbitrary member of that typeclass to be passed in. Does that sound reasonable?
02:41:28 <lightstep> yes.
02:41:37 <dons> lightstep: you could try linking it explicitly by adding it to the link phase command line, otherwise maybe you can try to register it with the package system and get at it via -package
02:41:57 <dons> if it provides a package.conf, you can specify that with -package-conf /some/file.conf
02:42:05 <boegel> lightstep: click the link under the thumbnail of the image @ http://studwww.ugent.be/~kehoste/thesisPublic/website/
02:42:15 <lightstep> hmm. -L doesn't help
02:42:20 <dons> Heffalump: ok that doesn't sound too bad at all
02:42:24 <viirya> autrijus: have you encountered an error about duplicated liftIO
02:42:39 <Heffalump> unfortunately FilePath can't be made a type class instance directly, otherwise it'd have been much nicer
02:43:16 <dons> lightstep: are you trying to circumvent the package system?
02:43:29 <autrijus> viirya: no... ghc 6.2?
02:43:43 <boegel> lightstep: do you see where the second light source is now ?
02:43:43 <viirya> autrijus: I got an error msg about GHC.IOBase.liftIO conflicts with StateBase.liftIO
02:43:51 <viirya> autrijus: ghc 6.2.2
02:44:02 <lightstep> dons: no. i wan't even aware of it - until now, i wasn't aware there was one. my programs just compiled with --make
02:44:07 <autrijus> viirya: in State.hs?
02:44:32 <viirya> autrijus: in CIO.hs
02:44:43 <boegel> @type System.CPUTime.getCPUTime
02:44:44 <lambdabot> System.CPUTime.getCPUTime :: IO Integer
02:45:02 <boegel> does anybody know if this returns the CPU time in clock ticks or in ms ?
02:45:04 <dons> lightstep: usually Haskell libraries are registered with the package system, so they can be used like: -package coollib
02:45:12 <lightstep> boegel: it sould be in front of the camera?
02:45:19 <autrijus> viirya: weird, I don't have IOBase.lifeIO imported in CIO
02:45:32 <autrijus> viirya: fixing
02:45:38 <dons> otherwise you have to set .hi, link etc. flags by hand (which can be many and varied)
02:46:04 <viirya> autrijus: you import StateBase.liftIO
02:46:05 <boegel> lightstep: there's one behind the camera (the 1.0 one), and one in front (the 0.4 one)
02:46:48 <lightstep> boegel: but there is only one spot of light on every sphere
02:47:13 <lightstep> boegel: there souhld be one near the top too, no?
02:47:19 <boegel> lightstep: check the right small sphere's, they have two
02:47:41 <autrijus> viirya: fixed, darcs pull bah
02:47:51 <viirya> autrijus: k
02:48:07 <lightstep> boegel: so it isn't just the reflection of the light from the plane?
02:48:11 <boegel> lightstep: the 0.4 light source is _behind_ most objects (z = -300)
02:48:34 <viirya> anyway, it's impossible to make it run on Windows now...
02:48:51 <boegel> if you look at the green sphere, you see a faint light spot on the right side of it, above the reflection of the plane
02:48:54 <lightstep> boegel: oh, now i see, on the pink one
02:49:44 <boegel> lightstep: idd, the pink one is closest to it (it has z = -300 too)
02:50:25 <lightstep> yes
02:50:30 <viirya> autrijus: is it inevitable to import modules like System.Posix?
02:51:24 <autrijus> viirya: it is not. it's just I'm lazy.
02:51:38 <lightstep> how should package files look like? ghc complains about the syntax
02:51:41 <autrijus> I suspect most of the SysDep stuff ~= unneccessary.
02:51:52 <autrijus> it's inherited baggage from CTK.
02:52:07 <autrijus> I'll fix them when I've finished compiler state.
02:52:15 <autrijus> so I can know exactly how much of CTK I need.
02:52:27 <viirya> autrijus: hmm, i just trim that making it loadable to ghci.
02:52:35 <autrijus> trim what? posix?
02:52:50 <viirya> just comment that all.
02:52:55 <lightstep> oh, never mind my questions
02:52:57 <autrijus> viirya: interesting. OSX?
02:53:07 <autrijus> viirya: "darcs send" bah
02:53:09 <viirya> autrijus: now on Windows.
02:53:13 <autrijus> darcs rec first, then darcs send
02:53:22 <autrijus> ahh. I see. win32 won't grok posix.
02:53:28 <autrijus> you have a patch handy? or just mail me the fixed file
02:53:30 <autrijus> I'll commit it
02:54:04 <viirya> autrijus: I just comment all the stuff you marked as Posix Stuff.
02:54:30 <viirya> autrijus: seems have no need to patch until now :)
02:54:33 <autrijus> so all of this is in SysDep.hs?
02:54:53 <viirya> just the runPiped
02:55:18 <viirya> and intToFd funcs.
02:55:42 <viirya> I just want to get a runable exe on Windows.
02:55:58 <autrijus> ok ok
02:56:29 <autrijus> ok fixed
02:56:41 <autrijus> pushed.
02:56:45 <autrijus> revert + pull bah
02:56:52 <viirya> ok
02:56:55 <autrijus> you should be able to create pugs.exe now just by typing "nmake"
02:57:03 <autrijus> if not, let me know :)
02:58:08 <viirya> and a question, what's the readline for? It complains that it couldn't linking due to lacking of that.
02:58:42 <autrijus> right, you need to comment it out from Shell.hs
02:58:46 <autrijus> line 2
02:58:49 <autrijus> just uncomment the #define
02:58:57 <autrijus> the readline is for better cmdline experience on unix.
02:59:04 <viirya> k, thanks. :)
02:59:44 <autrijus> put a downloadable pugs.exe somewhere for download?
02:59:48 <autrijus> just to prove it works etc :)
03:00:11 <viirya> if I could make one. :)
03:00:23 <autrijus> ghc --make-o pugs -O Main.hs
03:00:24 <autrijus> :)
03:00:28 <autrijus> ghc --make -o pugs -O Main.hs
03:07:48 <autrijus> <- implementing syscall() in pugs...
03:08:03 <autrijus> which won't call to libc, but instead calls to haskell functions :)
03:08:21 <pesco> Harr harr.
03:08:26 * pesco yawns.
03:09:29 <viirya> autrijus: it runs now. :)
03:09:54 <autrijus> viirya: woot. post the .exe somewhere? :)
03:09:58 <autrijus> viirya++
03:09:58 <autrijus> viirya++
03:10:07 <viirya> autrijus: k, wait a sec.
03:10:27 <boegel> pesco: tired ?
03:10:43 <pesco> boegel: Just got up.
03:11:24 <boegel> pesco: what's the time where you're at ?
03:11:30 <pesco> 12:12
03:12:18 <viirya> total 2.15 mb
03:12:23 <autrijus> that's acceptable.
03:12:37 <boegel> and you just got up ? nice :p
03:12:55 <boegel> I wish I could've slept that long, but my grandmother called me on the phone *sigh*
03:13:01 <pesco> boegel: Well actually, I've been up since 11:30 but haven't taken a shower yet. I don't really wake up until then.
03:13:19 <boegel> hehe
03:14:17 <pesco> boegel: So I'm coding in a sort of limbo state of mind.
03:14:21 <viirya> autrijus: I put on http://www.viirya.org/pugs.exe
03:14:29 <autrijus> cool!
03:14:30 <autrijus> thanks
03:14:47 <autrijus> I'll mirrot it
03:14:48 <viirya> autrijus: but the host isn't stable, maybe you like take it to other place.
03:14:48 <autrijus> mirror it
03:14:53 <autrijus> right.
03:15:25 <pesco> "the host isn't stable". :)
03:15:27 <esap> How can I feed back run-time information into Haskell type checking?`I need to be able to prove two types as same based on information I get at run-time [with pattern matching]? (Assume GADTs).
03:15:54 <autrijus> hsplugin? reified types (aka prepose)?
03:16:04 <viirya> pesco: because the poor connecting of school...
03:16:37 <pesco> viirya: I just meant it sounded like a Star Trek or X-Files quote.
03:17:00 <viirya> pesco: :)
03:17:42 * viirya dinner&
03:18:31 <autrijus> "the host is not stable.  We must concentrate our spirits.  Hosanna! Hosanna!" 
03:22:14 <autrijus> http://p4.elixus.org/snap/pugs-20050204-freebsd5 too.
03:22:28 <TheHunter> esap, doesn't seem to work the way one might think it could work...
03:23:54 <esap> TheHunter: ok, how do I do it then? I think I need to depend on the pattern matching of the GADTs, but it seems difficult. The exact case is I'm trying to build a type checker for identity functor, and I need to match domain and codomain of the functor.
03:24:22 <esap> TheHunter: And I'm using GADTs to enforce type safety in the type checker.
03:24:34 <TheHunter> esap, i don't know. I just tried the obvious approach, but it didn't work.
03:25:22 <esap> TheHunter: I get 'inaccessible case alternative' errors (Can't match types 'dom' and 'cod'".
03:26:22 <esap> TheHunter: which I think means I need to find some way to pattern match the environment such that I can prove dom and cod to be equal...
03:27:13 <TheHunter> esap, it seems impossible in the version i'm using, but that's a fairly old one.
03:27:23 <TheHunter> i'd just use unsafeCoerce#
03:27:50 * esap is using ghc-6.3.20050101
03:28:36 <esap> hmm.. ok, I'll try that.
03:29:15 <TheHunter> i have the feeling that GADTs are just a fancy unsafeCoerce# anyway.
03:29:47 <esap> Heh, maybe. But they're very useful for being able to exactly express what you want.
03:30:36 <esap> Like I wouldn't probably have even noticed that functor application depends on the domain category in very concrete way without GADT checking for the type checker.
03:30:40 <TheHunter> (i couldn't check that yet, because my ghc-6.3.20040725-2 doesn't eat its own -fext-core)
04:01:22 <esap> TheHunter: The unsafeCoerce# seems to work once I give it an explicit type annotation. (unsafeCoerce# :: Equal dom cod -> Equal s s)
04:03:28 * esap doesn't know if it works at run-time though :-)
04:11:19 * boegel scratches his head
04:22:16 <zipper> do i need ghc 6.2.1 if i want to use the windows wxhaskell binaries or will 6.2.2 work?
04:23:45 <Igloo> You need the version they were compiled with
04:24:02 <zipper> it was compiled with 6.2.1, so 6.2.2 for sure won't work?
04:26:20 * boegel just found another bug in his raytracer and wheeps :(
04:28:45 * Oeje1 gives boegel en tudekiks.
04:29:35 * boegel looks at the tudekiks and wonders what it is
04:30:04 * boegel bites in it, and then spits "Bah"
04:32:31 * boegel stopped wheeping
04:32:56 <Oeje1> :-P
04:41:01 <Lemmih> zipper: Yes.
04:41:27 <zipper> 6.2.2 will work?
04:41:37 <Lemmih> No.
04:41:44 <zipper> oh, ok danke
04:59:56 <boegel> @type div
04:59:58 <lambdabot> div :: forall a. (Integral a) => a -> a -> a
05:01:08 <boegel> @type pow
05:01:10 <lambdabot> bzzt
05:01:13 <boegel> @type power
05:01:14 <lambdabot> bzzt
05:01:26 <boegel> @type (^)
05:01:27 <lambdabot> (^) :: forall a b. (Integral b, Num a) => a -> b -> a
05:02:09 <jlouis> ``en tudekiks'' has come to .se?
05:03:28 <jlouis> http://www.leech.dk/bubblegum.php/pivpiv.jpg -- for boegel
05:04:04 <boegel> jlouis: hehe ;)
05:07:16 <goron> Anyone with experience on WASH? I made some simple stuff to work, but I want to combine two values of type WithHTML (but I don't see such an option).
05:08:19 <goron> Oh I think I see it: it's bind :)
05:13:05 <Lemmih> Bwahaha. http://www.leech.dk/bubblegum.php/EthernetKiller.jpg
05:13:30 <boegel> hehe
05:13:33 <boegel> dangerous
05:14:23 <zipper> that's for ethernet over power lines :D
05:15:03 <Igloo> Are these URLs meant to be broken for me?
05:16:05 <boegel> @eval mod 100 9
05:16:05 <lambdabot> 1
05:16:14 <boegel> @eval mod 10 6
05:16:14 <lambdabot> 4
05:16:28 <boegel> @type mod
05:16:30 <lambdabot> mod :: forall a. (Integral a) => a -> a -> a
05:16:45 <boegel> @eval div 10 4
05:16:45 <lambdabot> unbound variable: div
05:16:58 <boegel> @index div
05:16:59 <lambdabot> GHC.Real,Prelude
05:17:04 <Lemmih> Igloo: Yes, it's a deliberate plot against you!
05:17:07 <boegel> @eval (div) 10 4
05:17:07 <lambdabot> unbound variable: div
05:17:09 <boegel> heh
05:17:17 <boegel> mod works, but div doesn't ?
05:17:33 <Lemmih> div isn't defined apparently.
05:17:56 <boegel> @type div
05:17:57 <lambdabot> div :: forall a. (Integral a) => a -> a -> a
05:17:59 <boegel> N
05:18:00 <boegel> ?
05:18:34 <Lemmih> boegel: It's not a Haskell interpreter.
05:19:00 <boegel> Lemmih: sorry
05:19:24 * boegel hides in a corner
05:19:44 <zipper> where is .emacs file on windows?
05:20:10 <boegel> c:/Program Files/emacs ?
05:20:20 <Lemmih> zipper: What does ~ expand to?
05:20:35 <zipper> ~
05:20:38 <boegel> Lemmih: no ~ in Windows I think
05:21:30 <boegel> @type System.CPUTime.getCPUTime
05:21:31 <lambdabot> System.CPUTime.getCPUTime :: IO Integer
05:21:31 <jlouis> is compiling haskell from source hard?
05:21:38 <jlouis> (on OpenBSD ;)
05:21:50 <Lemmih> boegel: There should be a '~' in emacs nontheless.
05:21:57 <jlouis> I guess I'll just use the guide. If it fails I'll patch it to work
05:22:24 <psi> compiling haskell?
05:22:30 <boegel> Lemmih: it's been a while since I've used emacs in Windows
05:22:32 <psi> do you mean ghc or something?
05:23:06 <goron> psi: I think he means compiling hello world or something like that.
05:23:22 <goron> jlouis: What do you mean?
05:23:25 <Lemmih> jlouis: There's no binary GHC distribution for OpenBSD?
05:23:26 <jlouis> psi: bleh, compiling ghc
05:23:34 <psi> ghc is in ports, iirc
05:23:44 <jlouis> Lemmih: I have a GHC 6.2.1 _without_ ghci
05:23:48 <jlouis> the latter part sucks
05:23:55 <psi> *nod*
05:24:08 <psi> i couldn't get ghci, either
05:24:13 <jlouis> So now it is GHC-CVS and a bit of hackery ;)
05:24:24 <jlouis> I guess I can bootstrap from GHC 6.2.1
05:30:20 <zipper> haha, the man sex joke in the emacs tree has an option "-F   nasal sex with plants"
05:56:31 <boegel> hey Itkovian 
06:02:50 <boegel> bye Itkovian :&
06:04:24 <goron> Does anyone have experience with WASH? I think the CSS support is limited, but maybe I miss something. 
06:10:41 <goron> No, I don't miss anything. It's a bit cumbersome. 
06:30:54 <syntax_syntax> wow.
06:31:02 <syntax_syntax> The Beatles are suing Apple Computer _again_.
06:31:46 <xerox> syntax_syntax, why?
06:42:03 <pesco> xerox: Because Apple Computer became active in the music industry.
06:42:47 <pesco> xerox: Which they promised to Apple Music not to do in a previous case.
06:43:31 <xerox> :)
06:48:25 <syntax_syntax> Paul McCartney is such a weasel.
06:51:01 <pesco> Yeah, Beatles stay away off our Computer companies!
07:04:08 * boegel throws a rotten apple at Paul McCartney
07:04:37 <tintin> sue each other to oblivion 
07:05:37 <Igloo> Pah, Paul has produced vastly more worthwhile stuff than Apple Computers ever will  :-þ
07:05:53 <boegel> Igloo: :o
07:06:15 <Philippa_> tbh, the obvious solution is for one to buy out the other
07:06:44 <boegel> Philippa_: who says that put and end to the situation ?
07:07:13 <Philippa_> the fact one'd have control over the other?
07:07:44 <Philippa_> once one company owns both trademarks, there's no case left
07:08:12 <boegel> then Apple should own The Beatles
07:08:15 <basti_> hi
07:08:21 * boegel frowns his eyebrows
07:08:34 <Philippa_> it's Apple Music rather than The Beatles that's at stake
07:09:54 <boegel> The Beatles don't exist anymore, how can they bring Apple in trouble :)
07:10:23 <basti_> the beatles dont exist, but their rights might.
07:10:41 <shapr> achoo
07:10:50 <shapr> @yow !
07:10:51 <boegel> bless you
07:10:51 <lambdabot> Yow!  Are we wet yet?
07:11:39 <Igloo> Do the ex-Beatles still own Apple?
07:12:59 <shapr> dons: a bit wacked is an understatement
07:17:21 * shapr yawns
07:24:31 <syntax_syntax> Philippa_ Apple Music = Ringo, Yoko, Macca and the estate of George Harrison.
07:24:51 <shapr> y0 funk
07:24:52 <syntax_syntax> it's not like if it was a publicly-traded company with a shareholder-appointed board of directors.
07:24:56 <syntax_syntax> It -is- the Beatles.
07:25:04 <funkmando> ello. wondering how i can have a function return either an Integer or a Char ?
07:25:33 <boegel> funmando func : Either Integer Char
07:25:40 <shapr> hoi goron 
07:25:41 <boegel> s/:/::
07:25:46 <funkmando> thanks
07:25:54 <goron> shapr: hej
07:25:59 <shapr> Philippa_: I had fun playing with your Impure Thoughts #1 code.
07:26:10 <Philippa_> syntax_syntax: fair enough. It'd still be fair play for Apple Computers to offer them a deal
07:26:13 <goron> shapr: Did you do anything with WASH? (I believe you did).
07:26:19 <Philippa_> and if Apple Music handed over the trademark, that would be the end of it
07:26:27 <Philippa_> because there'd be nobody left to sue
07:26:27 <shapr> Yes, I've used WASH, but I haven't tried to alter the stylesheet.
07:26:36 <Philippa_> shapr: what sorta stuff did you try?
07:26:42 <goron> blaat=((table (mapM_ buildRow information)) ## attr "class" "balkboven")
07:26:49 <goron> This has a buggy effect. 
07:27:01 <shapr> what effect?
07:27:13 <goron> It gives the attribute to the HTML node. 
07:27:17 <shapr> you're applying the class to the table itself, right?
07:27:18 <goron> Instead of the table node. 
07:27:22 <Philippa_> (it does show pretty fast why static analysis helps you to generate faster code...)
07:27:39 <syntax_syntax> Philippa_ the last settlement involved Apple Computer paying $200 million dollars. The Beatles held the apple brand for "creative works whose principal focus is music", and Apple Computer held the brand for "methods to run, play or execute recorded music", as long as it's not through physical media.
07:27:41 <goron> <table class="balkboven"> is the desired effect.
07:27:51 <shapr> Philippa_: yeah, it's quite spiffy, it reminds me of the partial evaluation stuff that duncan has written about.
07:28:03 <Philippa_> syntax_syntax: fun...
07:28:12 <shapr> duncan told me in email that TH and partial eval could work together nicely.
07:28:35 <syntax_syntax> Philippa_ that's because the previous settlement was already for a second lawsuit. The first lawsuit involved Apple Computers paying $80K to the Beatles and holding the brand for stuff not related to music.
07:28:41 <shapr> But I don't think any demonstrations have been coded up before.
07:28:43 <Philippa_> ouch
07:28:47 <goron> shapr: I don't think he ever tried to make a real webpage. 
07:28:54 <syntax_syntax> Philippa_ the Beatles sued a second time when MIDI capabilities appeared. That's when the $200M settlement was paid.
07:28:55 <goron> shapr: :)
07:28:56 <shapr> goron: hehe, you mean the WASH author?
07:28:56 <Philippa_> as I understand trademark law, they shouldn't have had to
07:29:04 <Philippa_> (the first suit)
07:29:05 <goron> shapr: yes
07:29:38 <shapr> goron: Several of us on #haskell have expressed that same sentiment. We ended up deciding that WASH is not a general purpose webpage/application building toolkit.
07:29:45 <syntax_syntax> Philippa_ it seems pretty clear that the iTMS is not intersecting with Apple Music's industry, which consists essentially of a music label.
07:30:22 <goron> shapr: Is there some other tool I can use? I want to generate static pages for my university site. 
07:30:26 <shapr> goron: WASH is really good at some stuff, but it's really irritating at times. It used to be more a general webapp toolkit, in the earlier versions. This is my opinion at least.
07:30:28 <Philippa_> does iTMS act as an independant publisher at all? That could cause confusion
07:30:32 <shapr> goron: ah, you need Halipeto
07:30:38 <Philippa_> yeah, there's a reason I didn't use WASH for Flippi
07:31:00 <shapr> Halipeto is what I use for my ScannedInAvian.org website, and Lemmih built a very cool dynamic version of Halipeto for Hackage
07:31:27 <goron> shapr: I saw that page once. Does it work with stylesheets? 
07:31:28 <shapr> Lemmih put some extra tricks and speed into Halipeto for Hackage, I haven't had time to fully investigate it yet.
07:31:31 <funkmando> uhh is this right? sum_list :: String -> Either String -> Integer
07:31:39 <shapr> Yes, Halipeto works quite well with stylesheets.
07:31:57 <goron> shapr: Well, then let me try that. Thanks. 
07:32:21 <shapr> Halipeto is a pure templating setup, it doesn't do much with typesafety. Lemmih got it to produce correct XHTML, but I'm not sure how.
07:32:22 <Philippa_> funkmando: can't possibly be
07:32:31 <Philippa_> you're only applying Either to one type, for starters
07:32:37 <funkmando> lol
07:32:42 <funkmando> i want to apply it to string and integer
07:32:58 <Philippa_> String -> Either String Integer, then?
07:33:03 <syntax_syntax> Philippa_ dunno. It's a whole interwoven web of karma
07:33:28 <syntax_syntax> Philippa_ you do realize Wacko Jacko owns the rights to the entire Beatles catalog, right?
07:33:31 <Philippa_> see, I suspect iTMS will eventually go that way if it hasn't done already. That *does* strike me as lawsuit-worthy
07:33:34 <Philippa_> oh joy
07:33:41 <funkmando> couldn't match [char] against Integer String
07:33:41 <funkmando> weird
07:33:43 <Philippa_> (not that it matters here)
07:33:49 <funkmando> Either Integer String i meant
07:33:53 <syntax_syntax> Philippa_ he violated a verbal agreement with Paul McCartney and managed to snatch it.
07:34:07 <shapr> Who's Wacko Jacko?
07:34:09 <Philippa_> yes, that's because "foo" isn't an Either Integer String, it's a String
07:34:11 <syntax_syntax> Michael Jackson.
07:34:16 <shapr> !
07:34:30 <syntax_syntax> it's a whole interwoven web of karma.
07:34:35 <shapr> That's sick, man.
07:34:39 <syntax_syntax> Michael Jackson used to advertise for Pepsi.
07:34:56 <syntax_syntax> the ex-president of Pepsi went on to be the president of Apple.
07:34:57 <funkmando> "foo" is either an integer or a string
07:35:00 <funkmando> it's a string
07:35:01 <funkmando> lol
07:35:05 <Philippa_> funkmando: no
07:35:06 <syntax_syntax> it's a mess :-D
07:35:18 <Philippa_> Either is this datatype: data Either a b = Left a | Right b
07:35:28 <Philippa_> that is, an Either a b is either Left attached to an a, or Right attached to a b
07:35:35 <funkmando> eh
07:35:37 <goron> shapr: Where's Lemmih's version?
07:35:39 <Philippa_> you have to say /which/ type within the either you're dealing with, IOW
07:35:58 <Philippa_> all union types in haskell are disjoint
07:36:12 <funkmando> yeah
07:36:19 <funkmando> but Integers and Strings are disjoint
07:36:25 <Philippa_> but it still needs telling
07:36:28 <shapr> goron: In the Hackage darcs repo, as part of Hackage. You'll get better results if you start with Halipeto proper and check out Lemmih's undocumented code once you've figured out Halipeto basics.
07:36:33 <funkmando> how do i tell it, lol
07:36:42 <Philippa_> use the Left and Right constructors
07:36:51 <pesco> funkmando: Just look at the definitiol of Either. It says the constructors are "Left" and "Right"!
07:37:48 <pesco> funkmando: Sorry, I sounded rude.
07:37:55 <boegel> funkmando: Left String :: Either String Int
07:38:04 <boegel> Right Int :: Either String Int
07:38:08 <boegel> does that help ?
07:38:09 <Philippa_> well, nearly :-)
07:38:10 <funkmando> hmm
07:38:25 * shapr throws comonads
07:38:36 <pesco> shapr: What's a comonad?
07:38:40 <boegel> Philippa_: the syntax might be wrong, but it shows what I mean
07:38:58 <Philippa_> yeah. It also shows something the compiler can't infer without additional context, but hey
07:39:12 <shapr> pesco: It's a dual to a monad. It's a different way to do IO, called OI in fact. (that's all I remember from reading the paper)
07:39:13 <funkmando> whether it returns a string or an int depends on an if construct
07:39:27 <funkmando> so i need a left aand a right in there somewhere.. 
07:39:27 <funkmando> ?
07:39:31 <Philippa_> yep
07:39:45 <pesco> shapr: What exactly do you mean when you say "dual"?
07:39:51 <funkmando> where
07:40:02 <shapr> pesco: not only that, the CoMonads paper is what sparked the idea for Fermat's Last Margin, because several people independently got onto #haskell and said Comonads don't really work.
07:40:02 <pesco> funkmando: Where you construct the Either.
07:40:20 <shapr> pesco: like division is the dual of multiplication
07:40:21 <funkmando> String -> Either Left String Right Integer ?
07:40:51 <shapr> wnoise: y0
07:41:15 <pesco> shapr: Is there a shapr definition of "dual"?
07:41:24 <shapr> err, huh?
07:41:30 <funkmando> @type Either
07:41:31 <shapr> I think dual is a math thing.
07:41:31 <lambdabot> bzzt
07:41:33 <pesco> sharp definition, sorry! :)
07:41:35 <basti_> so how would a comonad work if it would?
07:41:50 <pesco> @type Left
07:41:51 <lambdabot> Left :: forall b a. a -> Either a b
07:41:53 <pesco> @type Right
07:41:54 <lambdabot> Right :: forall b a. b -> Either a b
07:41:55 <shapr> basti_: I forget, ask Pseudonym
07:41:56 <basti_> i think "dual" is what mathematicans say when they mean "the other way round" :P
07:42:02 <basti_> hm
07:42:02 <shapr> yeah, that works.
07:42:03 <basti_> i will.
07:42:14 <shapr> wnoise: Pseudonym wrote the physics code.
07:42:35 <basti_> in category theory it means, all morphisms reversed, epi and mono trade places.
07:43:04 <basti_> hmm i think a monad is a coalgebra. wouldnt that make a comonad an algebra?
07:43:25 * shapr 's brain explodes
07:43:50 * basti_ marks this day in his calendar
07:44:05 <shapr> My brain exploding is not a rare occurence ;-)
07:44:26 <basti_> but its the first time i made it explode.
07:44:30 <shapr> oh!
07:44:36 <basti_> :)
07:44:37 <pesco> basti_: What are epi and mono in category theory?
07:44:39 <shapr> hiya humasect 
07:44:49 <basti_> pesco: very similar to "surjective" and "injective"
07:44:51 <humasect> hey
07:45:09 <basti_> pesco: actually in the category of sets you can say sur and inj instead of epi and mono.
07:45:39 <basti_> pesco: but you can also find pervert examples, like categories where there are no surj epis and the like...
07:45:44 <Philippa_> funkmando: the source of your problems is where you're generating values of type Either Integer String...
07:46:04 <Philippa_> you are trying to do something that doesn't type correctly, because "foo" is not an Either Integer String. Right "foo" is.
07:46:10 <Philippa_> (so is Left 1)
07:47:40 <funkmando> i see
07:48:26 <pesco> shapr: Now what is Fermat's Last Margin?!
07:48:51 <shapr> That's my research paper annotation idea, combination of wiki, darcs, and ImageMagick.
07:49:09 <pesco> Ah, cool!
07:49:16 <pesco> Awesome name.
07:49:21 <shapr> Thanks :-)
07:49:25 <funkmando> says type constructers Left and Right not in scope
07:49:42 <syntax_syntax> heh
07:49:45 <syntax_syntax> Southwest Airlines (an airline who actually has a clueful CEO for a change) did almost this. They had an (unintentional) trademark collision with another airline due to a promotion they were running.
07:49:54 <syntax_syntax> Instead of running to the lawyers, Herb Kelleher (CEO of Southwest), challenged the CEO of the other airline (who's name escapes me right now) to an arm wrestling match.
07:49:57 <pesco> funkmando: Import them from the Prelude.
07:50:03 <syntax_syntax> Herb lost; the trademark dispute was resolved in the other airline's favour. No lawyers involved, and it undoubtedly saved both companies a buttload of money.
07:50:15 <basti_> syntax_syntax: lol
07:50:17 <syntax_syntax> Macca vs The Steve. I wanna see that on TV :-D
07:50:29 <shapr> And the two airlines became friends too, I bet.
07:50:29 <basti_> syntax_syntax: do you have an url?
07:50:30 <sh10151> wow
07:50:38 <syntax_syntax> basti_ it's on a slashdot comment.
07:50:48 <basti_> syntax_syntax: aw.
07:50:52 <Philippa_> shapr: well-oiled friends
07:51:05 <syntax_syntax> basti_ dunno if you were here. We were discussing how the Beatles are suing Apple Computer.
07:51:18 <syntax_syntax> basti_ I'm sure google would come up with something. 
07:51:25 <sh10151> thousands of years of legal history and we are back to judicium Dei
07:51:34 <sh10151> that's progress for you :)
07:51:35 <basti_> syntax_syntax: ive read the last few lines
07:51:36 <syntax_syntax> http://www.pbs.org/kcet/chasingthesun/innovators/hkelleher.html
07:51:42 <syntax_syntax> there is an url.
07:51:45 <zipper> hm... this hello world haskell program has been compiling for 10 minutes already and still going :(
07:51:51 <syntax_syntax> "Those good-natured feelings have everything to do with the man who's been with Southwest since its inception, Herb Kelleher. His down-to-earth, "everyman" demeanor has endeared him to the airline's employees. His zany antics have helped set the tone for the airline's offbeat culture. One outrageous incident was his arm-wrestling showdown with the CEO of Stevens Aviation in 1992. Both Stevens and Southwest were using the advertising tagline "Plane Smart
07:52:06 <syntax_syntax> PBS is trust-worthy enough? :-D
07:52:10 <humasect> heh
07:52:39 <basti_> -g-
07:52:45 <humasect> hello world in fltk is >9mb.
07:53:15 <sh10151> now that trial by combat is en vogue, maybe we can get the amende honorable popular too
07:53:44 <syntax_syntax> what is amende honorable?
07:54:42 <Philippa_> trial by combat's fine by me so long as I can pick the game we use to simulate it ;-)
07:55:10 <shapr> Sounds like Piers Anthony's Adept series.
07:55:23 <shapr> The Gamegrid
07:55:52 <Philippa_> I'll settle for SFA3, Counterstrike or the original UT
07:55:58 <pesco> UT!
07:56:07 * pesco gets shiny eyes.
07:56:17 <sh10151> sentence people to death and have them walk around in chains asking everyone's forgiveness
07:56:31 <basti_> i read a book in which legal issues were settled by the laws of the location where the computer that would do the judgement stands.
07:57:07 <basti_> it was the lawyers job to pick the right jurisdiction
07:57:16 <zipper> http://users.pandora.be/dragon.com/newsfromiraq.wmv
07:57:36 <wli> basti: now that's a nice work of fiction
07:58:04 <Philippa_> the lawyers of both sides, or just the claimant?
07:58:14 <basti_> ian mcdonald... =) i like him. although his books are really off beat... ;)
07:58:20 <zipper> holy shit, this hello world is 9 MB!!!!
07:58:24 <humasect> see? =)
07:58:27 <basti_> i dont remember exactly who picked the right computer
07:58:41 <zipper> humasect: it's not fltk. it's wx and haskell opengl
07:58:55 <funkmando> is there a haskell library anywhere where i can view function definitions?
07:59:00 <humasect> yeap. it turns out about the same.
07:59:12 <humasect> (hello world with neither package is about 2mb or so)
07:59:20 <zipper> :O
07:59:30 <sh10151> static linking will do that
07:59:37 * CosmicRay often wonders why the ghc rts isn't a .so
07:59:40 <zipper> how do i enable dynamic linking?
07:59:43 <CosmicRay> things would be alot smaller if it was
07:59:53 <zipper> i'm on windows btw
08:00:20 <CosmicRay> zipper: I wouldn't panic.  memory requirements of the generated program are fairly small
08:00:27 <humasect> the impression is that compiled haskell code is huge.
08:00:43 <zipper> CosmicRay: i'm worried about compilation time. this took 10 minutes
08:00:49 <basti_> everything compiled statically is huge
08:00:52 <basti_> o0
08:00:53 <funkmando> is there a haskell library anywhere where i can view function definitions?
08:00:58 <humasect> (larger than uncompiled code.. breaking standards is market value..)
08:01:01 <CosmicRay> it's not, really.  the run-time system is large, but generated code is compact
08:01:02 <basti_> funkmando: i know just about types.
08:01:05 <CosmicRay> zipper: to compile a hello world?
08:01:10 <zipper> yes
08:01:11 <CosmicRay> zipper: that should have taken a few seconds
08:01:13 <basti_> funkmando: and you can have a look into the sources of ost libs
08:01:20 <CosmicRay> zipper: do you have a seriously old pc or something?
08:01:26 <CosmicRay> little free ram maybe?
08:01:29 <humasect> CosmicRay: wx and fltk are not part of rts
08:01:32 <basti_> funkmando: s/ost//
08:01:33 <zipper> CosmicRay: no, but i haven't rebooted for a few days now
08:01:35 <humasect> ..?
08:01:36 <CosmicRay> humasect: I know
08:01:39 <CosmicRay> zipper: heh
08:01:57 <CosmicRay> zipper: free downloads to fix that problem at www.debian.org :-)
08:02:21 <basti_> funkmando: but i dont know about "programmatically examining a given haskell lib" if you meant that
08:02:32 <humasect> :) for development, sure
08:02:32 <zipper> CosmicRay: i'm moving my dev environment to windows since i couldn't get any haskell libs installed in linux
08:02:38 <CosmicRay> zipper: that's very strange do.
08:02:45 <CosmicRay> zipper: what was happening in linux?
08:03:32 <zipper> couldn't get HGL installed cause it depended on green-card and couldn't get green-card installed since it's code was broken and i was supposed to apply some patches from this mailing list or something but it was getting too complicated for me
08:03:48 <humasect> the windows ghc package is nice
08:04:13 <CosmicRay> zipper: debian has ready-made packages of ghc6 and greencard... let me check on hgl
08:05:04 <CosmicRay> yes, there are debian packages for hgl at http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
08:05:32 <zipper> hm... i have debian installed on an old laptop, i don't really like it
08:06:44 <CosmicRay> in that case, I'd suggest posting to haskell-cafe with you problem in windows
08:06:45 <goron> I had this problem a ziljion times: I want that GHC imports a directory named halipeto in it's searchpath (without giving it the full path). 
08:06:57 <CosmicRay> goron: -i
08:07:11 <zipper> CosmicRay: i'll try rebooting first
08:07:36 <humasect> i like how haskell-mode-indent cascades everything.
08:07:40 <humasect> =(
08:07:45 <goron> CosmicRay: Well I have done that. But the problem is I need "/home/myusername" etc.
08:07:58 <CosmicRay> goron: I don't understand.  
08:08:02 <goron> CosmicRay: I want to point to the directory in a relative way.
08:08:04 <CosmicRay> goron: I use things like -ilibsrc all the time
08:08:47 <goron> CosmicRay: I don't know what that does exactly, but I will check the docs on that. :)
08:08:58 <CosmicRay> that adds libsrc to the search path
08:09:06 <CosmicRay> that is, exactly what you are wanting, I think :-)
08:10:15 <basti_> funkmando: ?
08:10:27 <humasect> zipper: have you installed wxHaskell from bin or src?
08:10:44 <basti_> humasect: shhhh he left already.
08:10:50 <humasect> oh, oops.
08:10:54 <basti_> humasect: dont disturb his cleansing ritual.
08:10:58 <CosmicRay> haha
08:11:44 <CosmicRay> it seems slightly odd to switch to a microsoft operating system because you couldn't get greencard installed.
08:12:04 <humasect> it's not that much of a left brained finality.
08:12:17 <goron> CosmicRay: Oh, that's not what I want. I want to refer to a subdir. So suppose I am in /home/something/dir and I want GHC to search in /home/something/dir/subdir. How can I do that without using the /home/something/dir part?
08:12:34 <CosmicRay> goron: -isubdir
08:12:55 <goron> CosmicRay: Oh, I thought that didn't work some time ago. 
08:13:05 <CosmicRay> I've never had a problem with it
08:13:43 <tintin> Craft of functional programming has his the third edition ... did'nt notice that 
08:14:03 <goron> CosmicRay: Well, I think I used -i subdir. -isubdir works.
08:14:41 <funkmando> o sorry i'm back lol
08:14:46 <funkmando> i was reading yet another haskell tutorial
08:15:03 <CosmicRay> funkmando: that's a good thing to read
08:15:16 <basti_> ah
08:15:22 <CosmicRay> tintin: hmm, when did that happen?
08:15:26 <humasect> YAHT
08:15:58 <tintin> http://www.pearson.ch/pageid/34/artikel/88295AW/Addison-Wesley/0201882957/HaskellTheCraftofFunctional.aspx
08:16:25 <tintin> not sure thats the link 
08:16:53 <shapr> CosmicRay: hey, a few people have sent me email saying they really like the Monad.Reader slogan.
08:17:16 <CosmicRay> shapr: cool
08:17:20 <basti_> what is the slogan?
08:17:39 <shapr> "The Monad.Reader, Sequencing your input since 2005
08:18:14 <CosmicRay> tintin: that's annoying.  I got Craft for Christmas, and it was 2nd ed.
08:18:16 <basti_> -g-
08:18:30 <basti_> btw shapr i'll do that article
08:18:34 <shapr> basti_: yay!
08:18:38 <duncan> shapr: it is a good slogan :-)
08:18:38 <tintin> CosmicRay: same here ... i got it just a few weeks back 
08:18:39 <basti_> you just have to tell me HOW you expect it
08:18:43 <basti_> html?
08:18:53 <shapr> Nah, LaTeX or just plain text with pix.
08:18:59 <basti_> ah ok
08:19:12 <CosmicRay> tintin: this is odd, simon's website doesn't list a 3rd ed.
08:19:25 <basti_> pictures.
08:19:27 <basti_> o0
08:19:27 <tintin> yes noticed that too ... 
08:19:40 <shapr> basti_: pix are not required, but eye-candy entertains readers.
08:19:53 <basti_> i'll see what i can do.
08:20:02 <basti_> how about musitex or whats its name?
08:20:08 <CosmicRay> tintin: also, amazon has no record of that ISBN number
08:20:11 <shapr> basti_: check this out - http://www.csounds.com/ezine/
08:20:51 <tintin> CosmicRay: its very early probably for the release or its just been released ...
08:21:31 <shapr> basti_: even a few gnuplot graphs that show off interesting bits of your subject would be nifty.
08:21:41 <basti_> i'll see what i can do.
08:21:54 <shapr> excellent, I look forward to reading your article :-)
08:21:56 <CosmicRay> tintin: googling shows that that pearson site is the *only* one with a 3rd ed
08:22:00 <Philippa_> basti_: I don't suppose there'd be a reasonable way to hook up Haskore to a bunch of VSTis?
08:22:20 <basti_> Philippa_: i think theres a csound VST.
08:22:29 <tintin> yes and pearson is a reliable webpage they don't have a picture too  i noticed ....
08:22:37 <basti_> Philippa_: im not sure why one should hype about VST's though.
08:22:51 <shapr> I am selfishly thrilled to be the editor for TMR, I get to read all the articles before the issue is out =)
08:23:04 <Philippa_> basti_: because VSTs/VSTis are what most of us're using to make noise
08:23:15 <Philippa_> I'd like to be able to control a bunch using Haskore
08:23:29 <shapr> Right, time for unicycling and paying work.
08:23:33 <goron> @eval (\(a,b)->"hi") 5 5)
08:23:33 <lambdabot> (line 1, column 3):
08:23:33 <lambdabot> unexpected "("
08:23:33 <lambdabot> expecting identifier
08:23:40 <basti_> Philippa_: i know that they are common. I wonder though why it should be more fun than implementing one's own algorithms
08:23:42 <Philippa_> shapr: simultaneously?
08:23:51 <CosmicRay> tintin: also www.awprofessional.com has only 2nd ed
08:23:51 <shapr> haha, no!
08:23:55 <Philippa_> because some of us are trying to make music rather than develop synths
08:24:05 <basti_> pffff.
08:24:09 <basti_> :P
08:24:30 <Philippa_> really, I tend to bash out stuff over the course of a few hours, having to write code in that time is going to fuck up my flow
08:24:44 <basti_> youre a music professional?
08:24:52 <Philippa_> no, just an amateur
08:24:57 <basti_> ah.
08:25:16 <goron> @eval (\(x,a)->(a,x)) ("h","i")
08:25:17 <lambdabot> (line 1, column 3):
08:25:17 <lambdabot> unexpected "("
08:25:17 <lambdabot> expecting identifier
08:25:19 <Philippa_> but when I'm doing any good I very much get into a flow state
08:25:33 <goron> I think lamdabot is not complete :)
08:26:09 <goron> Or is this GHC specific code?
08:27:04 <boegel> goron: no, but lambdabot isn't a Haskell interpreter (as Lemmih said before)
08:27:44 <tintin> CosmicRay: not fair :( its probably due very soon or already shipping 
08:27:49 <goron> boegel: I thought I was a straight interface to runhugs or something like that. (but that might be a bit dangerous)
08:27:57 <wli> just hack lambdabot to only carry out some maximum number of reductions
08:28:17 <goron> boegel: What language does it interpretate then?
08:28:56 <boegel> goron: you should ask some of the regulars here, I don't know much about lambdabot 
08:29:16 * boegel tickles shapr
08:29:24 <CosmicRay> he just left to go unicycling, boegel
08:29:32 <goron> boegel: I will use the source :)
08:30:45 <boegel> CosmicRay: oh okay
08:32:32 <goron> @eval (\x y-> x y) id 5
08:32:32 <lambdabot> 5
08:32:56 <goron> It doesn't do patterns in lambda variables. 
08:33:22 <goron> Not that anyone uses that feature... 
08:34:12 <arjanb> it's useful for tuples
08:35:55 <Philippa_> good for "I know it's that constructor", too
08:36:07 <Philippa_> fromJust = (\Just x -> x)
08:37:09 <goron> I myself tend to use it more and more, but I don't think it's an advertised feature. 
08:49:52 <esap> I wish Haskell had better support for patterns in lambdas.
08:50:23 <duncan> esap: you mean pattern alternatives like in ordinary functions?
08:50:34 <esap> duncan: yes.
08:50:42 <duncan> esap: me too
08:51:24 <esap> duncan: Actually, you should be able to write something like: (\ Nothing -> 0) +++ (\ (Just x) -> x + 1)  and get a good function.
08:52:18 <duncan> esap: I was imagining different syntax but yes that would be useful
08:53:14 <Philippa_> I'm not going to be popular if I ask "what's wrong with \x -> case x of...", am I?
08:53:58 <lightstep> it's not pretty
08:54:10 <Philippa_> you /could/ do something like that +++ in the IO monad, you can't catch pattern-match failure more generally
08:54:29 <Philippa_> nor's the example, IMO
08:54:39 <esap> philippa: The reason for not wanting that is that with that you have to have the case branches all in one place. That's not what you want.
08:55:25 <esap> philippa: try this example: (\x -> (\Nothing -> 0) +++ x) (\ (Just x) -> x + 1)
08:56:09 <esap> philippa: It's not even clear what sohuld be the type of the function being called in that case.
08:56:58 <Philippa_> well, you're unifying x and Just a -> Int
08:57:20 <Philippa_> er, Maybe a even
08:57:51 <Philippa_> (Num b) => (Maybe a -> Int) -> Maybe a -> b
08:58:16 <Philippa_> (Num b) => (Maybe a -> b) -> Maybe a -> b, even
08:58:36 <esap> philippa: Ok, if so, then replace the argument with "(\ Nothing -> 1)". What happens? I suppose it should be valid according to that typing.
08:58:52 <Philippa_> yes. Non-total functions and all that
08:59:15 <Philippa_> and it's up to you to give appropriate semantics for +++ ("first match" seems about right) to give a clear meaning
09:00:06 <esap> philippa: My preferred semantics would be to reject that at compile time.
09:00:33 <Philippa_> which is basically not doable in the presence of pattern guards
09:00:50 <Philippa_> in their absence, fair play - but why not do the same for pattern-matching more generally?
09:01:13 <esap> philippa: yes, of course, that would need to be extended to pattern matching in general.
09:01:55 <Philippa_> so, what's wrong with (\x y -> case y of {Nothing -> 0; _ -> x y})?
09:02:00 <esap> philippa: The pattern guards situation is interesting, it's even less clear what should be the type of, say (\ x | x > 5 -> x)
09:02:14 <Philippa_> "dependant" :-)
09:03:11 <Philippa_> ultimately you end up with something that's not computable, or a restriction on guards
09:03:14 <esap> philippa: It's not typed correctly.
09:03:56 <Philippa_> arguable. In a non-dependantly-typed world, it's (Num a) => a -> a, or an equivalent that indicates the possibility of non-termination
09:04:10 <esap> philippa: My preferred solution would be to put the restriction on guards [and allow the programmer to override it]
09:04:22 <Philippa_> oh, they can
09:04:27 <Philippa_> they can just desugar the guard
09:04:47 <esap> philippa: But overriding the guard restriction should have a penalty attached to it.
09:05:04 <esap> philippa: say, less support from type system.
09:05:20 <Philippa_> no, it shouldn't. You should never, ever be penalised for knowing more than the type system knows.
09:05:53 <esap> philippa: Ah, but the alternative is that you are always penalized, which is worse.
09:06:14 <esap> philippa: If you know more than the type system, the you should tell the type system.
09:06:25 <Philippa_> then we're not really talking penalisation, we're talking admitting that we can't prove that it terminates
09:06:37 <tic> any of you used BNFC?
09:06:59 <Philippa_> we shouldn't lose any information that's already present
09:07:37 <esap> philippa: right.
09:08:00 <Philippa_> once again, this boils down to dependant types
09:08:24 <Philippa_> and hey, we might be able to reasonably show it terminates for a certain range of values - better'n'nothing
09:08:46 <esap> philippa: Anyway, it leads to complex type system. But I think that's acceptable.
09:08:56 <Philippa_> talk to Conor McBride :-)
09:09:41 * esap has looked at Epigram. It's very nice.
09:10:38 <Philippa_> that, or a relative, is where you're trying to head. You certainly can't have +++ with your desired semantics as an ordinary operator otherwise
09:12:08 <Philippa_> now, if you ignore the guards you can do something with subtyping
09:12:26 <esap> something?
09:12:50 <Philippa_> you treat a case analysis as taking a union type
09:13:16 <Philippa_> if the union is big enough to match a supertype of the types being analysed on, you can safely pass one and know it'll work
09:13:52 <esap> Hmm.. I think you need to distinguish partitions and subtypes.
09:14:19 <Philippa_> you work on the basis that all data constructors are subtypes of the type they belong to
09:14:55 <Philippa_> oh, and you take the arsiest possible subtyping relationship on tuples
09:14:56 <esap> Hmm.. I think they are cells of a partition of the type they belong to.
09:15:42 <Philippa_> you can treat it that way, but treating them as subtypes is less work in the long run
09:16:19 <Philippa_> that, and if you've got the infrastructure for subtypes there're other things you can do with 'em
09:16:52 <esap> subtypes and partitions are very different, I think [because they're somehow duals, and duals are different].
09:17:23 <Philippa_> right. Find me something smart you can do with subtypes you can't with partitions, then
09:17:29 <Philippa_> er, other way round, even
09:17:43 <Philippa_> bearing in mind we're working on ADTs
09:18:03 <esap> philippa: how about checking whether some set of cells covers the whole partition?
09:18:22 <esap> philippa: partitioned type I mean
09:18:26 <Philippa_> we're working with ADTs, it's trivial to check a union type against a supertype because the supertype's just a sum
09:18:53 <Philippa_> because we're working with ADTs, all unions are disjoint
09:19:22 <esap> philippa: but are subtypes always disjoint?
09:20:04 <Philippa_> no, but the leaves of the type tree are and the nodes are nothing but sums
09:20:41 <Philippa_> so if you've got a subtype covered, you've got all its subtypes covered - in the end you're ticking off all the data constructors within the type
09:21:14 <esap> I'm not sure how nodes of the type tree are sums.
09:21:23 <Philippa_> sorry, the non-leaf nodes are
09:21:32 <esap> neither are non-leaf nodes.
09:21:51 <Philippa_> because, for example, Maybe isn't a leaf node. Can't be, it's got two data constructors
09:22:56 <Philippa_> the only potential hiccup is a supertype containing a data con of the same name and a bunch of subtypes. Either disallow it or do some namespace friggery, up to you
09:24:20 <esap> ok, maybe I'm just confusing some things, I'm not sure. I'm trying to compare algebraic data types and coalgebraic data types. One should be partitions, other should be subtypes.
09:24:56 <Philippa_> coalgebraic should be partitions, yeah. Algebraic don't need to because you always know all of a type's subtypes
09:26:29 <Philippa_> in the algebraic case you build it up from the subtypes - 'swhy I've referred to it as supertyping in the past
09:27:14 <Philippa_> in the coalgebraic case (IOW, OO), you don't know about all the subtypes - it's rather the point. Which means you can't pull the same trick of generating a tick-list of leaf-subtypes
09:27:41 <esap> ok right. That clears it I suppose.
09:28:12 <Philippa_> incidentally, I've been doing some thinking on pattern-matching on coalgebras (well, OK, type-class membership)
09:28:17 <esap> Maybe I've been confused with calling it subtypes, because OO does have subtyping :-)
09:28:25 <Philippa_> perhaps
09:28:39 <Philippa_> 'twould be understandable, certainly - ADT sub/supertyping is weird if you haven't thought it through
09:29:23 <Philippa_> but yeah, I've come to the conclusion that I have some applications where I'd really like to be able to ask "is this value, about whom all I know is that I'm allowed to ask this question, a member of the following list of type classes?"
09:29:58 <esap> philippa: you can do that with existential types.
09:30:19 <Philippa_> yes, but not without building all the scaffolding myself atm
09:30:49 <Philippa_> and I won't get a value back whose type says it's in those classes unless I have a function for each possible combination
09:31:07 <Philippa_> (or unless the result's also in the class that lets me ask these kinds of question, I guess)
09:31:33 <Philippa_> though I'm not so sure about the latter, you can't parameterise on type-class membership in Haskell
09:31:36 <esap> philippa: yea, you'd need constraint variables or something like that.
09:32:19 <Philippa_> or, I can reify the type class hierarchy as an ADT, which belongs to a type class that will let me flip it back to an existential type
09:32:28 <Philippa_> (the latter class will have to be two-parm)
09:32:56 <Philippa_> nice trick?
09:33:35 <Philippa_> (it does rely somewhat on being able to match against 'any constructor in this type', but that's not too far out when you think about records)
09:33:39 <esap> hmm.. I'm wondering if the hierarchy can be put in a data type.
09:33:57 <esap> I think it's a preorder.
09:34:56 <Philippa_> I can do it for a closed hierarchy, so long as there's a reasonable way to say "I just want something that's a subtype of this and a subtype of that and..."
09:35:10 <Philippa_> the latter's more for the coder's sanity than anything else
09:35:25 <Philippa_> closed as in "I don't care if some bugger extends it" :-)
09:36:18 <esap> how about subtyping vs. subclassing, wouldn't the data type describe subclassing hierarchy rather than subtyping hierarchy?
09:36:53 <Philippa_> yes, because we're talking about type classes - it's just that there's a meaningful notion of subtyping in existential types still
09:36:57 <Philippa_> but no
09:37:07 <Philippa_> that's not all I'm looking to capture
09:37:22 <Philippa_> because we're looking to do the equivalent in a multiple inheritance situation
09:37:31 <Philippa_> really the hierarchy is a hierarchy of knowledge
09:37:46 <Philippa_> the root node is "don't know it's in any classes", the next level down knows of one class it's in...
09:38:08 <esap> right, root describes the situation where almost nothing is known.
09:38:12 <Philippa_> each node has an attached datacon which says "I know this is the /exact/ amount of knowledge"
09:38:19 <Philippa_> that is, "there ain't any more"
09:38:46 <Philippa_> IOW, all the datacons are the know-everything case, but you match on piles of them at once
09:38:46 <esap> ok, I'm thinking about it in a slightly different way, I'm thinking in terms of size of data.
09:39:03 <esap> and behaviour
09:39:11 <Philippa_> because all you need to know is that it's there, and it has this type so I can transform it back to the appropriate existential type
09:39:31 <Philippa_> that's sorta-irrelevant here, my typeclasses might not even have attached functions
09:40:02 <Philippa_> (the case I had in mind for using this was where typeclasses encode a particular property a value has in some ruleset for a game - 'is this monster RocketProof?')
09:40:31 <esap> do you mean run-time properties or compile-time properties?
09:41:10 <Philippa_> compile-time, all Shamblers are RocketProof. But I want to check whether I'm actually dealing with a RocketProof monster at run-time when I check how much damage a rocket will do to it
09:41:55 <esap> ok
09:42:36 <esap> I'm wondering what purpose does a type class without functions have. You might be able to get indication about instances whether they support a particular class, but what else?
09:42:36 <Philippa_> all I've got to start off with is a (forall a.GameEntity a => a)
09:42:49 <Philippa_> that's all I want
09:43:17 <Philippa_> oh, some of these properties may well have associated functions or related capabilities too
09:43:22 <zipper> hm... after rebooting wx hello world still takes a really long time to compile
09:44:51 <Philippa_> also, if you allow lacks-instance predicates in the context you could insist on a type level that a bot's not stupid enough to try to kill a RocketProof monster with rockets by not giving it a means to target a RocketProof monster...
09:45:36 <esap> philippa: I think determining non-compliance with a type class is harder than determining compliance.
09:46:09 <Philippa_> there're module problems, yeah
09:46:20 <esap> philippa: I've been thinking about being able to associate invariants with the type classes.
09:47:22 <Philippa_> basically, modulo modules lack-of-instance is just the failure to find an instance. The problem's when there's an instance in another module
09:47:43 <esap> philippa: Dynamic loading of modules is the interesting case :-9
09:47:53 <Philippa_> heh, somebody else's problem AFAIC :-)
09:51:15 <Philippa_> but really, just being able to dispatch on "which combination of these properties does it exhibit?" will do me nicely
09:51:39 <Philippa_> it makes for neat expression of certain types of rules
09:52:19 <Philippa_> I guess strictly speaking the instancing here happens at the point where something packaged it up as something you could do that with
09:52:32 <esap> That's just an ordinary dynamic_cast functionality. something along the lines of class (Typeable (f a)) => Class f a where { dynamic_cast :: (Typeable (g a)) => f a -> Maybe (g a) ; dynamic_cast = cast }
09:52:39 <Philippa_> because after that, just about every other function the value ever encounters (except its own instance funcs) is polymorphic
09:53:02 <Philippa_> yes, but dynamic_cast doesn't play well with pattern-matching
09:53:31 <esap> why not?   f x | Just y <- dynamic_cast t = ...
09:53:39 <zipper> what is dynamic_cast?
09:54:08 <esap> zipper: C++ facility. You can almost implement it with Haskell type classes.
09:54:12 <Philippa_> yeah, now try optimising a pile of those into something that dispatches efficiently
09:54:36 <esap> philippa: just use the Maybe monad to combine many tests.
09:55:06 <Philippa_> hrmm, does GHC optimise the Maybe monad at all?
09:55:25 <esap> I don't know. Probably not :-)
09:55:26 <Philippa_> because if not, that doesn't count as efficient
09:56:01 <esap> Well OO is not known to be efficient...
09:56:15 <Philippa_> whereas the pattern-match I'm describing could be cheerfully compiled into a jump-table based on ADT tag
09:56:21 <esap> In particular, dynamic_cast is especially inefficent facility.
09:56:40 <Philippa_> right. It doesn't have to be as much so if more than one possibly end-type is useful
09:57:27 <esap> Normally, that wouldn't happen, of course.
09:57:36 <Philippa_> but once in a while it does
09:57:51 <Philippa_> and in certain cases, it occurs regularly
09:57:54 <esap> Because in OO, everything one client needs will be in the same interface.
09:58:03 <esap> so in the same type class.
09:58:15 <Philippa_> right. Who says I'm writing friggin' business apps anyway?
09:58:21 <esap> hehehe :-)
09:58:34 <Philippa_> sometimes I need the benefit of being able to do my typing both ways - this being an example
10:00:08 <Philippa_> note that I'm trying to do something here that both OO and Haskell have problems with doing efficiently and in a type-safe manner :-)
10:00:40 <zipper> Philippa_: what are you trying to do? :)
10:01:08 <Philippa_> you walked in just after I described the problem :-)
10:01:09 <esap> I'm having some slight trouble imagining why it's not efficient in either. OO tries to implement a platform. FP tries to implement applications. If it's neither, then what is it?
10:01:11 <Philippa_> so:
10:01:12 <Philippa_> <Philippa_> (the case I had in mind for using this was where typeclasses encode a particular property a value has in some ruleset for a game - 'is this monster RocketProof?')
10:01:25 <Philippa_>  <esap> do you mean run-time properties or compile-time properties?
10:01:42 <Philippa_> <Philippa_> compile-time, all Shamblers are RocketProof. But I want to check whether I'm actually dealing with a RocketProof monster at run-time when I check how much damage a rocket will do to it
10:01:44 <zipper> Philippa_: hm... if there is much more then don't paste i'll read the logs :)
10:02:22 <Philippa_> (consider a biiig list of (forall a.GameEntity a => a) as a starting point for "what's going on")
10:02:27 <shapr> hej psi 
10:02:31 <zipper> shapr: hi
10:02:37 <shapr> hiya zippah
10:02:41 <psi> tja
10:02:57 <zipper> shapr: i've almost got all this haskell stuff set up. just gotta get yampa working now
10:03:17 <Philippa_> GameEntity allows you to query which of the defined properties an Entity has - might include things like Damageable, RocketProof...
10:04:01 <zipper> Philippa_: you interested in games?
10:04:06 <Philippa_> so a rocket entity, on hitting something, might want to check it's hit something that's Damageable and not considered RocketProof
10:04:07 <Philippa_> bingo
10:04:14 <zipper> cool, me too
10:04:19 <Philippa_> and these kinds of things are historically a PITA to express
10:04:24 <esap> philippa: hmm.. I have an idea. How about a filter mechanism that filters based on the type class properties. Then you could use all the filters you want, and get a list of all such elements of the list that support the type classes.
10:05:01 <Philippa_> I'd probably need that in the game, but it's not a useful atomic thing unless it's atomic for speed
10:05:16 <shapr> zipper: oh, you got HGL working?
10:05:38 <esap> philippa: the point is that then you could amortize the checking by precomputing.
10:05:44 <shapr> psi: where and when does the Go club meet?
10:05:48 <zipper> shapr: no, haven't tried yet... but i got wx working and they have a cool opengl demo. if i can't get this yampa stuff working then i'll do some opengl coding in haskell :)
10:05:55 <shapr> zipper: spiffy
10:06:03 <Philippa_> yeah, odds are I don't know the list of GameEntities ahead of time though
10:06:23 <Philippa_> something's going to kill that damn Shambler sooner or later
10:07:07 <Philippa_> I mean yeah, I could do that and use all the CAF/memoisation tricks if I felt like it
10:09:36 <shapr> syntax_syntax: I'm still not overwhelmed by Nash equilibriums.
10:10:17 <esap> Nash equilibriums? What's that? a brand of pudding? :-)
10:10:31 <shapr> hehe, sort of, yeah.
10:11:04 <shapr> If you consider pudding a statically balance colloid of forces, sure.
10:16:03 <zipper> shapr: only problem is that wx hello world takes like 40 seconds to compile
10:16:11 <zipper> and the executable is 9 big ones
10:16:49 <Cale> zipper: there's a large constant term in that though
10:17:00 <basti_> hmmm
10:17:06 <zipper> yeah, but even as a minimum 40 seconds is way to long
10:17:07 <basti_> i still dont understant import chasing
10:17:16 <Cale> 40 seconds is quite long
10:17:17 <basti_> i have Haskore in {hugs}/Haskore
10:17:24 <shapr> zipper: it'll get better in ghc 6.4, wolfgang thaller is adding dynamic linking.
10:17:27 <basti_> but import Haskore would complain
10:17:34 <Cale> I don't recall anything taking 40 seconds to compile when I was playing with wx
10:17:49 <Philippa_> it's mostly linking
10:18:06 <zipper> i have to use ghc 6.2.1 since that's the version wx was compiled with
10:18:27 <Cale> zipper: yeah, 6.4 isn't out yet anyway
10:18:33 <shapr> yeah, and ghc 6.4 isn't out yet. Just saying it'll get better soon.
10:18:42 <zipper> i was thinking about 6.2.2
10:22:22 <psi> shapr: we used to meet sundays at 12, in the B building at the university, but we are probably going to change that
10:22:56 <psi> most likely to mondays in "kårhuset" at 18.00 or something
10:24:23 <basti_> Prelude> :l Haskore
10:24:23 <basti_> ERROR "/usr/lib/hugs/libraries/Bitops.lhs":16 - Undefined variable "fromInt"
10:24:35 <basti_> and how would THAT happen? arent prelude things visible everywhere?
10:27:33 <basti_> oh there was a discussion on exactly that stuff here on the chan.
10:27:45 <psi> shapr: apparently it has been decided now, so mondays it is
10:27:50 <basti_> <Cale> yes, that definitely should be a fromIntegral
10:27:51 <basti_> <Cale> > bshiftr b n = truncate ((fromInt n)/2^b)
10:28:15 <Cale> :)
10:28:26 <basti_> Cale: is this fixed now?
10:28:33 <Cale> I don't know
10:29:00 <Cale> fromInt is no longer around
10:51:04 <basti_> can i make hugs traverse a directory plus its subdirectories (plus its subsubdirectories) for library search?
10:51:41 <zipper> do you need the subdirectories of the subdirectories of the subdirectories?
10:51:53 <basti_> like, tree traversal.
10:52:04 <zipper> ok, don't know how to do that sorry
11:01:57 <Philippa_> if you just need the dir and those dictated by hierarchical modules, you can do that
11:02:18 <basti_> obviously it's intended like that.
11:02:26 <basti_> but i cant figure it out completely.
11:02:52 <basti_> would a module Hierarchy automatically descend into its subdirs?
11:03:13 <basti_> like module A (module B, module C...)
11:03:30 <Philippa_> yes
11:03:35 <basti_> or, is it intended to?
11:03:36 <basti_> ah
11:03:45 <basti_> hm.
11:03:45 <Philippa_> A.B is found under A\B.hs
11:04:10 <basti_> then its probably just a single wrong line.
11:04:11 <Philippa_> modules exporting modules is different, I thought that just re-exported everything the module did?
11:04:30 <basti_> phew -shrugs-
11:05:13 <basti_> i wrote the maintainer a mail.
11:12:43 <basti_> and why wouldnt "import X" in module A search for A.X but for X?
11:13:04 <basti_> makes it impossible to include submodules by hand
11:14:46 <Lemmih> Why not just say 'import A.X'?
11:15:08 <basti_> because i dont want to modify the library file just because i want to include it.
11:15:38 <basti_> the situation is: A includes B, which is really X.B
11:15:50 <Lemmih> Oh, then simply give -i[include dirs] to ghc/hugs.
11:16:04 <basti_> uhm like for every subdirectory?
11:16:11 <basti_> i know i can do this.
11:16:31 <Lemmih> I don't quite understand your problem.
11:16:38 <basti_> well I dont understand it too.
11:16:49 <basti_> lets work with the concrete names:
11:17:02 <basti_> I want Haskore.Music which needs Haskore.Pitch
11:17:05 <Lemmih> Why would you place module B in X/B.hs?
11:17:13 <basti_> but it just says "import Pitch"
11:17:24 <basti_> (of course, because its in the same directory)
11:17:38 <basti_> now i say :l Haskore.Music, for example, and hugs goes like "i dont find Pitch"
11:17:51 <basti_> because it doesnt look for Haskore.Pitch.
11:18:13 <Lemmih> 'Haskore.Pitch' is not 'Pitch' no matter in which directory your in.
11:18:25 <basti_> hm then the author did something wrong.
11:18:38 * basti_ shakes head
11:18:58 <Lemmih> Did you download the latest version?
11:19:10 <Lemmih> *latest stable version
11:19:33 <basti_> well the latest stable version is from 2000 or something.
11:19:54 <basti_> this is the maintained "testing" version from a darcs repo
11:20:10 <basti_> but actually i'd love to understand haskell's module/directory association system.
11:20:25 <Lemmih> It's _very_ simple.
11:20:56 <basti_> well simple would include for me, that when i write "include X" that X is searched for right in this directory and not somewhere else.
11:21:14 <basti_> obviously simple means something else for you =)
11:21:59 <Lemmih> That is actually what it's doing.
11:22:18 <basti_> hm.
11:22:26 <Lemmih> But X isn't in the directory. The file X.hs is but that doesn't mean that the module X is.
11:23:01 <basti_> oof.
11:23:14 <Lemmih> We don't include files, we import modules (:
11:23:18 <basti_> yes.
11:23:36 <basti_> so how do i tell to import the module thats in the file right next to the file it is in right now?
11:24:02 <Lemmih> What's the name of the module?
11:24:26 <basti_> "Music"
11:24:57 <basti_> (looked it up)
11:25:00 <Lemmih> Is that the entire module name?
11:25:11 <basti_> Haskore.Music
11:25:41 <Lemmih> Then there's no module named "Music".
11:25:50 * basti_ sighs.
11:25:57 <basti_> well i know what you mean
11:26:14 <Lemmih> You should place Haskore.Music in Haskore/Music.hs
11:26:47 * basti_ will ponder about it some more
11:27:09 <Lemmih> It's not something you can change.
11:27:20 <basti_> hmm i know
11:27:38 <basti_> but i want to know where these things broke.
11:27:45 <basti_> i mean in that Haskore distribution
11:29:08 <basti_> hmm well at least i got it halfway working now.
11:30:39 <basti_> had to rearrange some files
11:31:02 * basti_ wonders what the package maintainer is doing all the time
11:31:04 <Lemmih> The darcs repo doesn't appear to use hierarchical module names.
11:31:41 <basti_> yes and some module names are not qualified as they should be...
11:31:53 <basti_> but at least i can load "Music" now
11:32:09 <basti_> which is enough for now... and i wrote henning a mail...
11:32:57 <Lemmih> Did you enter Haskore before loading Music.lhs?
11:33:27 <Lemmih> *enter the Haskore directory
11:33:36 <basti_> no... actually i want this as, like, a working library, so i can type "import Haskore"
11:34:18 <basti_> i put everything in {Hugs}/libraries, then moved Haskore.lhs .. , where it seems to belong.
11:35:05 <basti_> i can now load Haskore.Music
11:35:29 <shapr> yay
11:35:45 <basti_> shapr: its not that yay.
11:35:54 <shapr> oh?
11:36:05 <Lemmih> Oh well. If you hack the sources yourself then errors aren't really the authors fault (:
11:36:06 <basti_> no the darcs repo seems to be a little confused...
11:37:00 <Lemmih> Apparently it wasn't designed to be prefixed with Haskore.
11:37:07 <basti_> well for my understanding there should be a possibility that i can install this as a library and then use it from everywhere. And not have to work in a certain directory.
11:37:29 <basti_> hmm.
11:37:43 <basti_> but that sucks. i mean i would have to put all that ugly stuff in my main library dir.
11:37:50 <Lemmih> Did you try 'make install'?
11:37:59 <basti_> yes i did
11:38:03 <basti_> it doesnt know how to make install
11:38:33 <Lemmih> 'make register' then?
11:38:56 <basti_> doesnt work too.
11:39:53 <Lemmih> Now you know the difference between a development snapshot and a distribution (:
11:40:06 * shapr boings
11:40:12 <basti_> pfffrtzpft :P
11:40:23 <shapr> that's a neat sound
11:40:42 <shapr> Is that like wnoise?
11:40:53 * Igloo hands basti_ a cloth to mop up his keyboard with
11:40:57 * shapr grins
11:40:59 <basti_> no thats like what you do when you do :P
11:56:23 <Itkovian> @seen boegel
11:56:24 <lambdabot> I saw boegel leaving #haskell 2 hours 9 minutes 31 seconds ago.
11:56:44 <shapr> salut Elendil 
11:56:49 <Elendil> hi :)
11:57:34 <shapr> avez vous un question pour Haskell?
11:57:41 <shapr> (yes, my french is bad!)
11:58:31 <shapr> I wonder if there are any monad tutorials in french.
11:58:50 <Elendil> i dont know
11:59:11 <shapr> This is the best monad tutorial I know - http://www.nomaware.com/monads/html/
11:59:26 <Elendil> ok thanks
12:01:33 <shapr> Elendil: as tu un monocycle? ;-)
12:01:49 <Elendil> non malheureusement :)
12:02:04 <Elendil> pourquoi?
12:02:48 <shapr> quelle dommage... je connais plusiers françaises avec monocycle.
12:02:58 <shapr> I think my french plurals are broken.
12:03:34 <shapr> So is most of my french vocabulary...
12:04:43 <shapr> je ne trouve pas un tutorial monad en français :-/
12:05:12 <shapr> Lunar^: connais tu un tutorial monad en français?
12:05:36 <Elendil> ce n'est pas grave je dois pouvoir comprendre celui en anglais :)
12:06:02 <shapr> and I would like to understand more french
12:07:25 <shapr> It's a good question, I wonder if there are translations for Haskell documents. If so, they would fit nicely on the learning page.
12:08:22 <basti_> women.
12:08:26 <shapr> where? I want one!
12:08:55 <Lemmih> Dude! You already got one.
12:08:56 <shapr> Why do they always run away when I start to talk about monads?
12:09:31 <basti_> you dont want. you really dont.
12:10:39 <anyone> You need to talk about women more.
12:11:11 <basti_> why?
12:11:38 <anyone> It attracts people who love women.  Many programmers love women.
12:11:57 <Kleene-AAH> hi
12:11:59 <Elendil> hi
12:12:01 <basti_> hi
12:12:49 <anyone> You can start like this.  "A woman is an abstract data type (your design or someone else's) that overloads three operators: return, >>=, fail. ...
12:13:31 <basti_> are you sure women have these three operators?
12:13:57 <anyone> "you need to ensure these laws hold because these are the laws of women: f >>= return  equals  f, ..."
12:14:28 <anyone> The programmers will take them as woman jokes.  They love woman jokes.  They don't know they are actually learning monads.
12:15:34 <esap> If you don't know you're learning monads, how would you be able to use them in code? :-) They would be seriously misusing the laws :-)
12:18:09 <anyone> It suffices to get the content into their heads.  The names "women" and "monads" are unimportant.  If the name "women" pleases them more than the name "monads", all the better.
12:18:41 <anyone> But seriously, hahahahahaha.
12:27:08 <goron> Or "warm fuzzy thing", to quote Simon P.J. :)
12:29:02 <dustin`> Is there an alternative to integer2Int (in GHC.Num) for converting an Integer to an Int?  I like to test things in HUGS before compiling them with GHC, and HUGS doesn't have GHC.Num
12:29:25 <Igloo> fromIntegral
12:30:01 <dustin`> Oh, an Int is not an Integral?
12:30:01 <Igloo> You shouldn't use functions from GHC.* without good reason
12:31:25 * Lemmih can hardly wait till GHC 6.4 is out.
12:31:51 <Lemmih> It's like christmas times.
12:32:09 <shapr> Kleene-AAH: looking for a kleene star?
12:35:15 <Philippa> re
12:35:43 <Lemmih> Greetings Philippa.
12:35:56 <Kleene-AAH> shapr .. ;o
12:36:00 * shapr hides adroitly
12:36:38 <Lemmih> wow, autrijus is really active.
12:37:03 <shapr> hyperactive even.
12:37:32 <shapr> Kleene-AAH: if that's your real name, I'm sure you get that joke all the time.
12:38:16 <shapr> musasabi: hei, what do you think about a monad transformers article?
12:40:13 <goron> Is there some way to convert a pdf document to xml? And then change the xml a bit and than transform it back to pdf?
12:43:30 <Kleene-AAH> shapr, AAH means Alan Alonzo Haskell, I guess it gives you a hint about the nature of the handle 
12:43:58 <shapr> You claim an amazing pedigree, can you actually walk the walk? :-)
12:44:08 <Philippa> that must be an interesting case of MPD
12:44:21 <shapr> I'm not even going there :-)
12:44:30 <shapr> Back to my monocycle instead.
13:12:36 <syntax_syntax> http://www.namingschemes.com
13:54:19 <Lemmih> Good night, #haskell.
13:56:44 <TheHunter> good night, Lemmih 
14:11:59 <zipper> shapr: hi you around?
14:12:45 <shapr> nope
14:12:47 <shapr> oops
14:13:07 <shapr> Mmm, I love unicycling.
14:15:21 <Itkovian> we know, we know :-)
14:15:31 * Itkovian is struggling with Happy
14:15:47 <Itkovian> Been a long time since my last yacc experience
14:15:51 <Itkovian> grmbl
14:16:11 <shapr> It's hard to really know until you've had that zen-like feeling of flying. It's especially powerful when you're effortlessly flying through a third of a meter of snow.
14:17:13 <shapr> I rode a bike a few blocks to the store, it felt so weird. It was like riding a brick with pedals. I had no control!
14:17:23 <humasect> hehe
14:17:25 <shapr> zipper: What can I do for you?
14:18:05 <zipper> shapr: i've been thinking of how one would design a 3d graphics engine based on opengl with functional programming
14:18:44 <shapr> Haven't we had this discussion already?
14:18:55 <shapr> Or this the followup?
14:18:55 <Philippa> no, we had game rules earlier
14:19:07 <shapr> No, I mean... zipper and I talked about this a coupla weeks ago.
14:19:09 <Philippa> ah
14:19:15 <zipper> shapr: no, we talked about ode in haskell :D
14:19:19 <shapr> oh
14:19:26 <Philippa> I have to admit, myself I'd probably end up with it structured fairly similarly to the imperative version
14:19:53 <zipper> shapr: the thing about opengl is that you can't really have a render :: scene -> IO () function
14:20:11 <Philippa> not without some context, perhaps
14:20:12 <zipper> since you will want to share opengl state between render calls
14:20:23 <Philippa> but just about everybody I know does the equivalent in C or C++
14:20:41 <zipper> Philippa: that's because they are allowed side effects
14:20:44 <Philippa> render's an IO action, it's allowed to mess with OGL state
14:21:09 <Philippa> it'll still be there for the next IO action to occur
14:21:22 <zipper> right, but i don't want that
14:21:38 <zipper> i want to try to minimize state in the design of the engine
14:21:39 <Philippa> short of setting it to a known state at the end of each render call, there's nothing you can do
14:21:48 <Philippa> it's not the engine messing you about, it's OGL
14:22:08 <Philippa> worse yet, you care about that state if you want the engine to go fast
14:22:15 <shapr> Haskell already has forkOS because of OpenGL
14:22:16 <zipper> just because i can implicitly keep state inside of OGL doesn't mean i should/must
14:22:25 <Philippa> no, you must
14:22:33 <Philippa> even if you zap it back to a known state, OGL will have one
14:22:51 <Philippa> there is nothing you can do about this. You are operating on top of a stateful system.
14:23:04 <zipper> Philippa: the idea is to have state(like opengl textures) stored in opengl without the engine user having to have to worry about it
14:23:44 <Philippa> in the general case, that won't work - you've got a resource allocation problem
14:23:56 <zipper> that's exactly what i'm trying to figure out how to solve
14:23:59 <Philippa> if you can stick to LIFO deallocation, you can use a withTexture func
14:24:58 <humasect> i had contexts, much like the matrix stack
14:24:58 <zipper> Philippa: i have this sort of idea that i need to develop that is about nonmutable texture values
14:25:30 <zipper> zipper: the engine will automatically deal with allocation/deallocation of opengl textures when required
14:26:25 <Philippa> er, that would be non-trivial
14:26:31 <Philippa> you're talking about doing garbage collection
14:26:52 <Philippa> the non-mutable texture values are references to textures
14:27:24 <zipper> yeah, something like garbage collection
14:27:47 <Philippa> and you can't do that in functional code
14:27:53 <Philippa> because you'd be inspecting your own state of execution
14:27:56 <Philippa> sorry
14:28:22 <zipper> right, the engine would need to have some sort of state in order to implement garbage collection
14:28:26 <zipper> but the tricky part...
14:28:42 <Philippa> you can't even get at the relevant state in Haskell
14:28:44 <zipper> is how the engine user conjures up texture values
14:28:53 <Philippa> IO action. Gotta be.
14:29:04 <Philippa> well, monadic action
14:29:06 <zipper> no
14:29:18 <Philippa> they can do the vast majority of their stuff without doing monadic bits, but ultimately rendering is a side-effect
14:29:24 <Oejet> Hm, I have a program which is twice as fast without -O2 compared to with that flag.
14:29:25 <zipper> i could have a pure function, textureFromFile :: string -> TextureID
14:29:37 <Philippa> Oejet: interesting...
14:29:41 <Philippa> odds on it mis-inlining?
14:29:51 <Philippa> you could, but the TextureID would be worthless
14:29:56 <Oejet> It massively concurrent.
14:30:07 <Philippa> because doing this doesn't attach it to anything
14:30:13 <Philippa> you can't even load the file in that pure function
14:30:23 <Oejet> lisppaste2: url?
14:30:23 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:30:31 <zipper> Philippa: right, the actual loading of the file and creation of the opengl texture would be delayed
14:30:57 <Philippa> you're about to reinvent a monad or an arrow
14:31:19 <Philippa> that, or to implement an entire interpreter
14:31:28 <zipper> Philippa: yeah, but the idea is that an engine user could load the same texture twice with textureFromFile and it would really only get loaded once during rendering
14:31:38 * Philippa shrugs
14:31:43 <Philippa> so you have a cache somewhere, big deal
14:31:48 <zipper> right
14:32:09 <Philippa> you can do that from within a textureFromFile IO action, give or take using the NO-INLINE hack to give you somewhere to keep the cache
14:32:15 <Philippa> you can certainly do it from within your own monad
14:32:23 <zipper> thing is, if i don't do it this way, then the engine user must have a monadic action for loading a scene, instead of a pure function
14:32:48 <Philippa> instead you're going to build an entire little language and interpret that as the program?
14:32:57 <Philippa> really, that's all you can manage
14:33:05 <zipper> yeah, that's the idea :)
14:33:07 <Philippa> because ultimately there /will/ be a monadic action for actually loading the damn file
14:33:16 <Philippa> it's a bad idea, it'll run horribly slowly
14:33:24 <zipper> i don't care about performance now, just design
14:33:27 <Philippa> and the best bit is all you're doing is reinventing the monad without the benefits
14:33:43 <Philippa> because ultimately, a monad is an interpreter for a language that includes a Haskell interpreter
14:33:45 <zipper> benefits are that programs that use the engine don't have to write any monadic code
14:34:03 <lisppaste2> Oejet pasted "Death by Concurrency" at http://paste.lisp.org/display/5569
14:34:05 <Philippa> which isn't much of a benefit when you're going to give them all the same problems anyway
14:34:31 <zipper> hm...
14:34:32 <zipper> i don't think so
14:34:51 <Philippa> no? How does your function, which is clearly going to get evaluated at some point anyway, provide any real benefit over a monad?
14:35:02 <Philippa> "it's not in a monad" is not an answer
14:35:48 <zipper> engine users won't have to worry about order of execution, the engine will take care of loading the appropriate textures at the appropriate times automatically
14:36:02 <Philippa> guess what? You can do that within a monad
14:36:14 <Philippa> monadic sequencing isn't something to be taken literally
14:36:27 <Philippa> all it says is that the subsequent computation depends on the former one
14:37:22 <Philippa> guess what else? I'm pretty sure you care about order of rendering
14:37:53 <zipper> right, but the engine users shouldn't have to care about it
14:37:54 <Philippa> (think about it - even if it's only for the sake of alpha-blending)
14:38:05 <Philippa> they do
14:38:22 <lisppaste2> Oejet annotated #5569 with "Optimization timings" at http://paste.lisp.org/display/5569#1
14:38:26 <Philippa> it matters when you specify a scene
14:38:42 <zipper> that's exactly what i'm trying to deal with
14:39:01 <Oejet> Philippa: Mind taking a look?
14:39:19 <Philippa> then quit messing about with functions and admit you're just building an interpreter for a new language. Then build an AST type and an interpreter for that
14:39:38 <zipper> ok maybe that really is what i want =)
14:39:55 <Philippa> Oejet: short version is I've no idea what'll be going wrong there
14:40:01 <zipper> too bad though that i have no idea how i would do that :|
14:40:11 <Philippa> then you won't be able to do what you were trying to either...
14:40:41 <zipper> well right now i'm just trying to think in terms of the design, what would be nice for users of the engine. i'm not thinking how i would implement this
14:41:07 <Philippa> what would be nice for users is either the monadic interface or a well-specified scene description language
14:41:28 <zipper> right, i want a sell specified scene description language i think
14:41:42 <Philippa> okay. Think about the structure of your data a bit then
14:42:37 <Philippa> you might end up with stuff like geometry, materials...
14:42:48 <zipper> yeah
14:42:52 <Philippa> (at this point, it's not about being functional - it's a static description)
14:42:59 <zipper> yes
14:43:53 <Philippa> anyway, I gotta go
14:44:12 <zipper> ok thanks man for the advice
14:44:19 <humasect> hint: avoid opengl
14:44:23 * shapr grins
14:44:26 <zipper> that's not an option
14:44:35 <humasect> it's the only one, i've researched this a lot.
14:44:50 <humasect> besides the overhead philippa was mentioning
14:45:02 <humasect> you can emulate it, but that is probably good enough
14:45:08 <Lunar^> shapr: I don't know many articles about Haskell
14:45:10 <humasect> DSL
14:46:08 <humasect> everything is built then sent to the API/card - so technically (under the hood) it isn't avoidable
14:46:37 <shapr> Lunar^: If you can point me to some, I'll put the collected pointers on the Wiki.
14:47:04 <humasect> zipper: sorry, i'd rather discuss it than to say stuff to shoot anything down.. i want the same thing too
14:47:33 <shapr> I'd like to use a nice 3D engine in Haskell.
14:47:37 <zipper> fact is that opengl is an unavoidable reality
14:47:39 <humasect> ie. image synthesis =)
14:47:42 <humasect> yeah
14:48:00 <humasect> ..with hardware acceleration, that i
14:48:01 <humasect> s
14:48:12 <zipper> and i think that opengl is even very well designed
14:48:29 <humasect> well..
14:48:41 <humasect> perhaps providing functional interface to the state =)
14:49:07 <shapr> I don't know enough about OpenGL to have any opinion.
14:49:12 <zipper> maybe it's fun to think about opengl like a cpu, it's like an assembly language
14:49:20 * humasect nod
14:49:51 <humasect> one could at least take advantage of the main variants, time and user input
14:50:13 <humasect> the latter being branched
14:50:46 <humasect> redColor p -> when p `isFacing` player ...
14:50:59 <zipper> yeah
14:51:00 <shapr> zipper: have you asked about this on the HOpenGL mailing list?
14:51:07 <zipper> no
14:51:17 <shapr> Sven Panne and the others might already have a bunch of ideas for a 3D engine.
14:51:20 <zipper> i don't feel that i know enough about haskell to discuss anything on mailing lists yet
14:51:38 <humasect> zipper: i will be avoiding HOpenGL altogether and providing higher level primitives to support this.
14:51:44 <shapr> Well, you can ask and then read up on anything surprising that's mentioned.
14:51:53 <shapr> That's what I do.
14:51:57 <humasect> heh
14:52:15 <humasect> and... become inspired by Pan and Pancito
14:52:24 <humasect> (the docs at least)
14:52:32 <shapr> "Yes, that requires skolemization" "Oh really"
14:52:47 <shapr> At which point I hit google really fast.
14:53:26 <shapr> Google is the smart half of my brain.
14:53:31 <humasect> 1) specifying state, resetting state, providing vertices+params = bad 2) loading models+data = bad
14:53:31 <zipper> heh
14:53:46 <humasect> =)
14:53:49 <zipper> hm?
14:54:49 <shapr> what's good?
14:57:17 <zipper> squeed is good!!!! http://squeed.bravehost.com/squeed.jpg
14:57:46 <shapr> sqeed?
14:57:54 <shapr> Are you squeed?
14:57:58 <zipper> negative
14:58:06 <shapr> Who is Squeed?
14:58:35 <zipper> dunno
15:00:28 <zipper> you can pm him if you want i guess Squee-D
15:00:57 <shapr> I have nothing to say!
15:01:12 <shapr> "Hi Squeed, this is your mother. What were you doing last night?"
15:01:24 <shapr> Hm, maybe that's not such a good idea.
15:03:45 <zipper> squeed makes connect 4 flash game: http://www.squeed.bravehost.com/C4FlashClient.html
15:04:21 <shapr> I've just been trying to hack my flash plugin.
15:04:59 <shapr> I'd like to add an intro screen to every flash file in my browser that says something like "click here to play this"
15:05:06 <shapr> I *hate* flash ads.
15:05:24 <zipper> i hate flash. i hate the web. i hate computers
15:05:40 <shapr> But look at the other options...
15:05:43 <Oejet> Me too.
15:05:47 <shapr> digging ditches is even less fun.
15:05:53 <wnoise> zipper: do you hate IRC?
15:06:02 <zipper> irc is actually not bad
15:06:06 <shapr> y0 Mistah Denney
15:06:17 <shapr> wazzup?
15:06:26 <wnoise> Hello shae.  Just woke up after hitting the bars last night.
15:06:26 <zipper> only thing that's really bad about icq is bad i8ln
15:07:00 <zipper> er, irc
15:07:06 <zipper> icq totally sucks the shit :)
15:07:12 <shapr> My interest payments are too high on borrowed alcohol happiness for me to participate in that practice.
15:07:13 <zipper> too bad i have to use it
15:07:54 <wnoise> I don't often, but it seems to be the only thing I can use to drag my roommates out of the house.
15:08:09 <shapr> Wow, sounds like me.
15:08:18 <shapr> I have a unicycle, that helps.
15:08:36 <zipper> hm... you icq with your roommates?
15:08:54 <wnoise> no, no, going to bars.
15:08:58 <shapr> Actually, I have two unicycles, and I'm hoping to build a third ultra-heavy duty offroad unicycle.
15:09:28 <shapr> For some reason there's a large amount of snow found near the Arctic Circle.
15:09:43 <wnoise> zipper: I do know of a chat system with automatically distributed public key crypto and unicode messages...
15:09:44 <shapr> aaanyway.
15:09:47 <zipper> ok, i had an image of your roommate totally glued to the screen and the only possible way to get his attention is to im him :P
15:09:54 <shapr> wnoise: would that be SILCnet? ;-)
15:10:00 * shapr is joking
15:10:36 <shapr> When does Gale get MIME messages?
15:11:23 <wnoise> I hadn't heard of SILCnet.  Hopefully never.
15:11:34 <zipper> only problem with irc is that it didn't evolve well in order to support things like multimedia and stuff. of course you could say that it's not the purpose of irc for this stuff, but then at least irc should integrate nicely with services that do offer these things
15:11:39 <zipper> the internet just could be so much better
15:12:00 <zipper> and so could computer environments in general
15:12:03 <shapr> I'd like a protocol like SILC that dealt with IPv6 multicast nicely.
15:12:21 <shapr> Or maybe just IPv6 multicast and skip the rest.
15:12:41 <shapr> I'd like fries with a side of beef please.
15:13:32 <wnoise> I have real doubts about multicast, whether v4 or v6, ever really catching on.
15:13:34 <shapr> Hey, silly question. If someone describes an idea on their website, can another person still patent that idea?
15:13:50 <shapr> BitTorrent is already fake multicast.
15:13:50 <zipper> sure
15:14:08 <shapr> Real multicast is better than BitTorrent.
15:14:09 <wnoise> Yes, of course.  It may be good as prior art in attacking the patent.
15:14:21 <zipper> can't i flood the entire internet with only one packet with real multicast?
15:14:24 <shapr> well foo.
15:14:37 <shapr> zipper: no, a multicast is only routed where it has subscribers.
15:15:08 <zipper> what if microsoft ships there next version of windows so that everyone is subscribed to some ms service?
15:15:31 <shapr> I almost said "no one could be that stupid" but then again...
15:16:05 <wnoise> Not to discourage people from publishing, as providing prior art to attack patents is a good thing, but it won't stop them from getting the patent in the first place
15:16:09 <shapr> Windows users are like wives of alcoholics. They'll take any amount of abuse and keep coming back.
15:16:36 <shapr> hoi boegel 
15:16:41 <boegel> hey shapr 
15:16:43 <shapr> hoe gaat het met jou?
15:16:53 <shapr> ik ben een tandeborstal! w00!
15:16:55 <boegel> hehe, nice !
15:17:01 <boegel> tandenborstEl
15:17:06 <shapr> oops
15:17:22 <shapr> I can't spell in any language!
15:17:28 <boegel> nice going tough...
15:17:38 <boegel> do you know more ?
15:17:41 <shapr> ik heb een glass
15:17:47 <boegel> glas
15:17:50 <boegel> single s:)
15:17:54 <shapr> oops again.
15:18:01 <shapr> ik vel een kikke
15:18:04 <zipper> danke sehr!
15:18:15 <boegel> do you mean 'kikker' ?
15:18:20 <shapr> I give up!
15:18:24 <shapr> no more dutch for me.
15:18:28 <boegel> and do you mean 'to skin' ?
15:18:40 <shapr> no, that was supposed to "I want a frog"
15:18:47 <boegel> ik wil een kikker
15:18:54 <boegel> vel = peel of it's skin :D
15:18:57 <shapr> ewww
15:19:00 <boegel> hehehe
15:19:49 <shapr> I have two articles already! yay!
15:20:26 <boegel> shapr: which ones ?
15:20:30 <wnoise> Speaking of which...  I'd be willing to write, but I'm not sure what exactly to cover, as it's mostly just a stolen Oleg trick.
15:20:33 <shapr> and maybe I can get wnoise to write about values that have quantities and units in the same value for issue two.
15:20:42 <boegel> and there are still two weeks to go, right ?
15:20:55 <shapr> Yes, still two weeks to go until articles should be in my inbox.
15:21:03 <boegel> alrighty then
15:21:12 <boegel> I spoke duncan about my article...
15:21:21 <shapr> wnoise: You could write about the ISS module that was built on the Imperial unit system.
15:21:36 <boegel> I'm gonna do a short tutorial of an example GUI, and mention some of gtk2hs advantages
15:21:53 <boegel> and then duncan will probably write a more thorough article for issue two
15:22:01 <shapr> You could also reference Martin Fowler's Analysis Patterns. I have the book and could give you the page numbers, etc.
15:22:40 <shapr> Since I'd like to write an FP version of Analysis Patterns at some point, I'm interested.
15:22:51 <shapr> boegel: excellent!
15:23:22 <shapr> And you're going to mention your thesis?
15:23:43 <shapr> Maybe just one mouth watering screenshot?
15:23:58 <wnoise> My university's library has a copy, but it's in the branch that flooded...  Not sure where I'd get a copy quickly
15:24:04 <boegel> shapr: I can mention it, but I shouldn't show any code or so
15:24:05 <shapr> *flooded* ?
15:24:22 <boegel> wnoise: where are you from ?
15:24:22 <shapr> boegel: that's fine, "always leave them wanting more"
15:24:54 <shapr> I heard he's from the OFB coven.
15:24:59 <wnoise> Winter, pipe broke.  They caught it within a few hours, so very few books were damaged, but now they're sitting in boxes while they renovate and fix water damage.
15:25:25 <shapr> Whereas we're part of the Freenode Illuminati.
15:25:34 <boegel> shapr: you'll have to show me how this darcs stuff works though, I've never worked with it
15:25:51 <wnoise> I'm currently in Albuquerque, New Mexico.
15:25:54 <shapr> boegel: it'll take you about thirty seconds to learn it. Want to see the darcs tutorial I wrote?
15:26:51 <shapr> Too bad SPJ defected to the Servant of Cthulhu.
15:27:15 <shapr> Right, no more Steve Jackson Games related jokes.
15:27:44 <shapr> wnoise: is Fredrik@ofb.net one of your roomies?
15:28:32 <wnoise> No.  I'm the only OFBite in this area.  He's currently living in Galt, California.
15:28:40 <shapr> Ah, ok.
15:29:37 <boegel> shapr: no, not now... my gf is reading in her book, but that won't take long anymore...
15:29:48 <boegel> when she's done I'm going to bed :)
15:29:53 <shapr> ok
15:30:02 <wnoise> He went to the same school as I did, but I didn't really know him until we were working at the same company for a while.
15:30:37 <boegel> does anybody know how I can show e-mail messages in Thunderbird in 'thread' form ?
15:30:44 <shapr> wnoise: most of the reason I want MIME, utf-8, encrypt, etc on a chat network, is that I want to do shared editing over that network as well. Do you think Gale would be suited for that?
15:31:19 <shapr> Even better, voice chat and shared text editing.
15:31:49 <shapr> SILCnet can do that with MIME messages, though there aren't any clients that support it yet.
15:32:47 <wnoise> What does MIME buy you?  Anyways, no, not directly.  I think the best thing to do would be to arrange a rendezvous via gale, but do collaboration via some other mechanism.  Possibly have editors with communication plugins to communicate over whatever, including gale, irc, e-mail, whatever.
15:32:52 <boegel> shapr: btw, what _is_ darcs ? it's some kind of zip-file which is easliy updated orso ?
15:33:19 <shapr> boegel: the user intro is thirty seconds, the description is forty-five minutes. What do you want to hear? ;-)
15:34:14 <shapr> darcs is a view of a source code repository like a number that's been factored. Each save to the repo is another factor in the big number.
15:34:44 <wnoise> darcs is arch made simple and put on a sound footing
15:34:53 <shapr> Unlike integer factors, darcs patches are inherently ordered. They have a context, but their order can be changed.
15:35:20 <shapr> wnoise: heeey, you know about arrows?
15:35:35 <boegel> there goes the book :)
15:35:42 <shapr> g'nite boegel!
15:35:43 <boegel> so there goes boegel to his bed :)
15:35:50 <boegel> g'night everyone :-)
15:36:16 <wnoise> No.  Last time I looked at the papers was over two years ago, and it made no sense.  It might now.
15:36:59 <shapr> I dunno if you've read about darcs inefficiencies... the most likely speedup seems to be patch groups.
15:37:51 <shapr> Commutes, conflicts, and merges would probably be much faster if you can sort the patches according to what will or won't need more detailed checking.
15:38:06 <zipper> oh man i gotta sleep
15:38:38 <shapr> My thought was to turn patches into arrows so that you can store that sort of property on a single patch, or stick a bunch of patches together to get an arrow value that acts like a single patch with all the properties of its patches.
15:39:25 <wnoise> Interesting.
15:39:29 <shapr> I've been trying to implement this thing, but it's stretching my brain a bit much.
15:39:52 <funkmando> will haskell every achieve moderately wisdespread commercial use?
15:40:13 <funkmando> what demographic have traditionally used haskell? mathematicians?
15:40:14 <shapr> funkmando: I dunno, but I know *I* can get more results in less time with Haskell. Does that help?
15:40:26 <shapr> funkmando: idealists? ;-)
15:40:28 <dons> probably not mathematicians
15:40:37 <dons> though there is a few
15:40:37 <shapr> g'day dons
15:40:42 <dons> heya shapr
15:40:52 <dons> compiler writers love it!
15:41:16 <shapr> wnoise: Any thoughts, ideas, or advice on patch arrows?
15:42:30 <shapr> wnoise: Not a good question to ask during a hangover? ;-)
15:42:59 <dons> jlouis: not still around are you?
15:43:04 <shapr> dons: I think you're right, Haskell is a language for building programming languages.
15:43:22 <wnoise> fraid not.
15:43:46 <shapr> funkmando: My theory is that domain specific languages are the most powerful solution to any programming problem. So, efficient problems solvers should learn a langauge that is good for building languages.
15:43:57 <funkmando> ok
15:44:02 <shapr> ie. Haskell!
15:44:06 <funkmando> :P
15:44:08 * shapr waves the lambda pom-poms
15:44:22 <shapr> rah rah rah! sis boom bah! Go Lambdas!
15:44:30 <funkmando> lambda pwnz
15:45:31 <shapr> On the downside, that's not a low overhead approach. It means you need to be good at writing your own programming language. Which means you need to have already learned a bunch of different languages so you can make up your own mind about what's cool and what sucks.
15:45:53 <shapr> Note the similarity to Jedi building their own lightsaber.
15:48:49 <shapr> funkmando: what do you think?
15:49:02 <funkmando> i don't know whether to agree yet
15:49:14 <shapr> That's an excellent approach.
15:49:15 <funkmando> i've only done 5 months of C and 1 week of java and haskell :P :/
15:49:33 <shapr> I can suggest some other mind-opening languages, if you want.
15:49:38 <shapr> And some books too.
15:49:58 <funkmando> go ahead
15:50:10 <shapr> My goal is to be the best programmer I can be, and part of that is to have the best tools, in both my toolbox and my head. That's why I'm here.
15:50:26 <funkmando> right
15:50:41 <shapr> I'd suggest read Structure and Interpretation of Computer Programs (aka SICP) - http://mitpress.mit.edu/sicp/
15:51:22 <shapr> and "The Pragmatic Programmer" (aka tPP) - http://www.pragmaticprogrammer.com/ppbook/index.shtml
15:52:09 <shapr> SICP uses the langage Scheme, though the book is really about "programming" rather than Scheme itself.
15:53:03 <shapr> Past that, it depends on where you want to go first. If you want to learn about type systems, Benjamin C. Pierce wrote "Types and Programming Languages" (aka The Brick Book)
15:53:35 <shapr> The Brick Book goes from nothing all the way up to System F and beyond.
15:54:21 <shapr> If you want to explore OOP, check out the Smalltalk language, it's the ultimate Object Oriented Language, check out prototype oriented languages like Self and Cecil (and believe it or not, JavaScript)
15:54:47 <shapr> If you want to explore logic and constraint languages, Prolog and Mercury.
15:55:33 <shapr> Heavy duty concurrency would probably involve learning Erlang, and maybe the pi-calculus. And probably capability theory with the E Language (http://erights.org/)
15:56:19 <shapr> Oh, concatenative and stack based languages are fun, that includes PostScript, Forth, and one of my favorites, Joy.
15:58:03 <shapr> There's a lot to be learned in unusual approaches. Most systems can be thought of as term-rewriting systems. One of dons' favorite tools is the famous unix utility sed. You can actually write whole languages as term-rewriting systems and run them through sed. Maybe not what a paying client might want though ;-)
15:59:25 <dons> hehe
15:59:30 <shapr> dons: is lsd available?
15:59:30 <dons> reminds me to get lambda-sed done this year
15:59:32 <shapr> aha
15:59:58 <dons> I think I could whip it up in 2-3 days, though
16:00:06 <dons> hmm.... maybe in a couple of weeks
16:00:08 <shapr> you're going to bootstrap it from sed or something?
16:00:29 <dons> nah. \-sed is a functional language that behaves like sed
16:00:34 <shapr> ah, cool.
16:01:01 <dons> but with more variables, lambda abstractions etc. more like untyped lambda calculus, with string pattern matching primitives
16:01:01 <shapr> I wonder what I left out of that short survey of programming.
16:01:30 <shapr> let's see, tree-rewriting?
16:01:41 <shapr> That's really part of term rewriting.
16:01:51 <Lunar^> dons: woaw, that could be so col
16:01:53 <Lunar^> cool
16:01:55 <shapr> dons: I'm looking forward to it.
16:02:22 <shapr> Oh! I totally left out hardware as it relates to evaluation.
16:03:08 <dons> becaues sed is almost purely functional - but with bizarre primops
16:03:12 <shapr> Computability theory is important, namely lambda calculus and the turing machine.
16:03:25 * wnoise worked on asynchronous hardware connected by CSP-like channels
16:03:27 <shapr> Complexity theory is important so you can estimate the real world behaviour of your algorithms.
16:03:34 <dons> there's very little state maintained between each line that is filtered
16:03:37 <shapr> wnoise: wow, plan9? inferno?
16:03:56 <shapr> clockless logic? null convention logic?
16:04:34 <wnoise> No OS, though one of them could have run standard ones with just a bit more effort in the MMU.
16:04:44 <shapr> funkmando: anyway, there's my short intro to programming =)
16:05:04 <shapr> Were you doing that for theseus.com? or who?
16:05:05 <wnoise> asynchronous isn't quite the right word -- locally synchronized might be better.
16:05:36 <shapr> So you did still use clocks?
16:05:40 <wnoise> http://www.fulcrummicro.com/
16:06:20 <shapr> Theseus' clockless logic basically tugs the string before it starts sending on a wire.
16:06:36 <wnoise> No clocks per se.  Circuits that would transition like clocks when that part of the chip was active, but they resulted from the synchronization rather than causing the synchronization.
16:06:42 <funkmando> shapr
16:06:45 <funkmando> sounds interesting
16:06:55 <funkmando> so you dabble a lot with these funny little languages i take it? :P
16:07:07 <shapr> wnoise: sounds like true clockless to me, where parts of the chip only sync with another part they're talking to...
16:07:17 <shapr> funkmando: yah, and dream up my own languages too.
16:07:28 <wnoise> Theseus had a weird mixed synchronous - asynchronous thing that was fairly ugly.
16:07:48 <shapr> This is why no one likes to look at my Python code. It looks more like Haskell ported to Pyton.
16:08:23 <wnoise> Our microarchitecture basically had a backwards signal saying "go ahead and send data, I'm ready for it" or the reverse to units it took data from.
16:08:36 <shapr> neato
16:08:38 <dons> there's a joke that Appel's compiler construction in java just looks like his compilers in ML code :)
16:08:43 <shapr> heh
16:08:52 <shapr> wnoise: hey, you ever heard of photorefractive crystals?
16:09:25 <shapr> I have another one of my unrealistic ideas...
16:09:30 <funkmando> yuck. i bought this fish pie and now my room *completely* stinks
16:09:47 <shapr> funkmando: and the moral of the story is, eat fish outside!
16:09:57 <funkmando> hehe
16:09:59 <shapr> and feel sorry for eskimos.
16:10:17 <wnoise> shapr: I've heard all the word roots.  Is it anything like birefringent crystals?
16:10:23 <shapr> no clue
16:10:25 * shapr asks google
16:10:38 <shapr> oh birefringent means has two indices?
16:11:04 <wnoise> shapr: I feel like I should know, as I'm studying quantum information, and quite a lot of the proposed implementations are non-linear optics setups.
16:11:13 <wnoise> Yes, depending on the polarization of the light.
16:11:50 <shapr> photorefractive is where photons contribute to a charge in the lattice, thereby locally changing the index.
16:12:19 <wnoise> Oh, I see light changes ... scooped.  So, not much.
16:12:20 <shapr> It's used in pretty much all holographic film, so those grocery store holograms are photorefractive plastic.
16:12:46 <shapr> Sounds just like a transistor to me though, as programmable just requires the ability to affect self.
16:12:54 <Lunar^> shapr: I'm stuck for HFuse btw
16:13:00 <shapr> Or maybe more like an FPGA crystal.
16:13:03 <shapr> Lunar^: how so?
16:13:14 <Lunar^> shapr: reentrancy with the RTS
16:13:38 <Lunar^> shapr: the default FUSE example is xmp, wich simple mounts '/' at some other mountpoint
16:13:45 <wnoise> Might be usable like that.
16:13:51 <Lunar^> shapr: when you do /mnt/mnt
16:13:55 <shapr> So I'm thinking two wavelengths, one for data one for control. And run the whole thing on a raw photorefractive crystal.
16:14:00 <Lunar^> shapr: it needs to do C->Haskell->C->Haskell
16:14:36 <wnoise> control and data are the same thing.  Throw off your von Neumann blinkers!
16:14:43 <shapr> yeah, I know :-)
16:15:11 <shapr> I'm just trying to find some cheap setup that lets people build their own computer at home from a text file.
16:15:34 <shapr> photorefractive crystals might work, but I'm not sure how to test the idea.
16:15:49 <wnoise> Toilet tanks.  Water levels ~ voltage levels.
16:15:51 <shapr> Lunar^: I still don't get it.
16:16:24 <Lunar^> shapr: the second time it needs to enter Haskell RTS, it blocks
16:16:37 <Lunar^> shapr: AFAIK, there's a big lock there
16:16:41 <wnoise> I would expect photorefractive crystals to require fairly high laser power to get decent SNRs.  I can't wait until we have home VLSI.
16:17:41 <shapr> wnoise: I think that it wouldn't require much power at all, the only limitation I can see is index switching speed. The early crystals took twenty minutes to give a noticeable change.
16:18:18 <shapr> But it sounds like you know more about it than I do, why would high power be import to SNR?
16:18:26 <shapr> Lunar^: asked on ghc-users?
16:18:43 <Lunar^> shapr: I'm going to finish the whole thing
16:19:02 <Lunar^> shapr: Cabalization and Haddocking
16:19:05 <shapr> ok
16:19:06 <Lunar^> shapr: pack up and RFC
16:19:17 <shapr> good idea
16:19:32 <wnoise> Hmm.  The refractive change is caused by moving charge carriers around.  There's certainly a speed/power tradeoff.  Further though, the charge-carriers won't be in an equilibrium position, they're going to want to move back.  You need to maintain power to keep them there.  I haven't worked out the timescales though, so maybe it would be okay.
16:19:33 <Lunar^> Marlow will surely find a way if he take some time to look at it :)
16:20:59 <wnoise> I think a fluid-mechanical system would be fun to play around with.  "valves".
16:21:00 <wnoise> I think a fluid-mechanical system would be fun to play around with.  "valves".
16:21:03 <shapr> wnoise: but I don't want to keep them there. I want them to switch back. I'm thinking a big stick of dynamic-ram FPGA with power in one side that rewrites itself all the time like the game of life
16:21:24 <shapr> I want the fastest switching possible.
16:21:30 <shapr> Lunar^: as usual :-)
16:21:59 <wnoise> In that case synchronization will kill you.  You need stability to get a "generation" across the thing.
16:22:06 <shapr> huh?
16:22:22 * shapr thinks about that
16:22:48 <shapr> hiya NIXIS 
16:22:55 <shapr> looking for Haskell info?
16:23:24 <wnoise> Not sure how to explain.  You need the outputs to be from valid inputs, so it needs to know when input is valid.  If one input becomes invalid while another is still becoming valid, it loses.
16:23:34 <shapr> wnoise: I think sync will only be a problem if switch speed is different in different parts of the crystal. And I could probably work around that if I think about it enough.
16:24:27 <wnoise> different parts will have different latencies.  You can carefully design extra latencies in, but it's really fragile.
16:24:38 <shapr> yeah, but so is silicon =)
16:25:26 <shapr> I think clockless designs could handle it, but this is all hot air until I can find out the exact behaviour of real crystals.
16:25:36 <wnoise> Not if you use an asynchronous design style :)
16:26:29 <shapr> So, now I just have to ask google which photorefractive crystals are both inexpensive and switch quickly.
16:26:43 <wnoise> True.  My prejudice is that the light itself isn't enough to program in robust logic, but I could easily be wrong.
16:26:44 <shapr> I wonder if my landlord will mind if I set up a small laser lab in my apartment.
16:27:16 <shapr> g'bye nixis
16:27:38 <syntax_syntax> heh
16:28:02 <wnoise> I'd also expect that you would need massive numbers of lasers and sensors for IO.  And then you also have to deal with energy loss, and somehow pump the material to compensate.
16:28:13 <wnoise> For now, I'd just buy a few FPGAs.
16:28:33 <shapr> I was hoping to use the power as input as well.
16:29:43 <shapr> I have come up with some cute laser-based designs for peripheral such as speakers and monitor, but no way I can afford that on my existing research budget. So I figured I'd use the extra cheesy solution of attempting to write the output as glowing letters on the side of the crystal. Workable? Who knows?
16:29:44 <wnoise> (one of the crazier ideas we had was to compile our designs to FPGA for quicker testing than PC simulation or actually fabricating them -- all our designs were done in a high-level hardware description language.)
16:30:02 <shapr> Ah, so you're familiar with Lava,Hawk,Esterel,etc?
16:30:24 <wnoise> I've seen lava.  Wasn't impressed.  Haven't heard of the others.
16:30:32 <shapr> They're about the same.
16:30:45 <shapr> Well, Esterel isn't... it's a data-flow language.
16:31:09 <shapr> Peter Gammie is taking ideas from all the Haskell-related and data-flow languages and doing something nifty.
16:31:18 <shapr> Not that I really understand what I've seen so far.
16:31:38 <shapr> Anyway, I was thrillled with Lava because it meant I might be able to have a Haskell-programmable coprocessor on a PCI card.
16:31:52 <wnoise> Re: power.  I see how to cut off a given beam.  I don't see how to make a new beam start in the crystal.  You could have the equivalent of the silicon power grid by shoving lots of beams in the top, but it seems terribly wasteful.
16:32:04 <shapr> Too bad the Xilinx version of Lava required the Xilinx toolchain.
16:32:42 <shapr> I'm an open source fanatic. No welded shut hood for my car.
16:34:06 <shapr> It really depends on the speed with which the charge carriers move back.
16:35:57 <shapr> Slower is easier because you can multiplex the power to keep a certain set of angles set up in certain places. Much of the fun would happen at the edges of the crystal. A thin slice of crystal with mirrors on the sides and a spot for input and output is probably the industrial solution.
16:37:20 <shapr> wnoise: do you know of any open source software that simulates photorefractive crystals? I've looked at MIT Photonic Bands, but I have *no clue* 
16:37:29 <humasect> clean is fast.
16:37:46 <dons> this is so great that "The Implementation of Functional Programming Languages" is "open-sourced" now :)
16:37:53 <humasect> ouu
16:38:21 <wnoise> Nope.  Sorry.
16:38:32 <dons> more textbooks for free, I say!
16:39:16 <sorje> Yeah, or make them cheaper at least ;-)
16:40:05 <dons> yep. I can teach a whole course on programming languages now without requiring students to buy a text book. it's good
16:40:26 <dons> the above + Bob Harper's book is enough material 
16:40:34 <shapr> wnoise: I think I could make a VHDL for such a crystal, if I knew enough about the behaviour details.
16:41:30 <sorje> Is there a trend? I know about some free math textbooks too. But I don't know how it evolved over time.
16:42:10 <dons> I don't know if it is such a trend. but I do hope the out-of-print books getting released becomes a trend
16:42:15 <shapr> wnoise: but this is just one instance of "make a dirt cheap computer" do you know any other programmable media that might be able to compete with silicon-based hardware at some point in the future?
16:42:27 <shapr> hiya chip
16:46:51 <wnoise> again, nope.  Why avoid silicon though?  FPGAs are still more expensive than I'd like, but they are within hobbyist reach.
16:47:27 <shapr> Because I want something that allows people to make their own hardware with relying on large companies.
16:47:57 <shapr> I want real open source hardware. If the photorefractive thing works, hardware would really be software. You'd just download a whole new design.
16:49:08 <sh10151> economies of scale
16:49:12 <Igloo> FPGAs give you that
16:49:13 <wnoise> You still need to get large crystals, which would be made by large companies
16:50:01 <wnoise> Xilinx may be an ass about programming about their products, but that's not inherent to FPGAs.
16:52:31 <shapr> Xilinx with a 100% open source toolchain would be a step in the right direction, then you'd need PCs that had really big FPGAs as CPUs
16:53:21 <dons> hmm. maybe hardware is like software in the 80s. we need a gnu revolution :)
16:53:26 <shapr> yes!
16:53:52 <Igloo> the second half of that is trivial, I believe (although you won't touch modern performance)
16:54:33 <shapr> I think optical computing has the potential to beat modern performance, but not with the huge number of patents on optical computing.
16:55:12 <Igloo> It'll take more than handwaving to convince me of that  :-)
16:55:13 <shapr> If companies sell big crystals and a laser mount, it doesn't infringe on the patents.
16:55:43 <sh10151> smarter software is what we need
16:56:44 <shapr> Igloo: as soon as I get a decent photorefractive crystal simulator :-)
16:57:00 <shapr> Igloo: then I'll buy you another beer if I'm full of fertilizer ;-)
16:57:21 <Igloo> You didn't buy me a first beer
16:57:25 <shapr> I know ;-)
16:57:38 <shapr> But that's only because you didn't want it!
16:57:43 <Igloo> :-)
16:58:42 <shapr> My next crazy idea is tiled computers, where components are in something like cubes with a 'PCI interface' on every face. Then you never run out of expansion slots.
16:59:11 <shapr> Rhombic dodecahedrons would probably be a better shape, but cubes are easy visualize as 3D tiles.
16:59:53 <shapr> wnoise: so, uh, written any Haskell lately?
17:02:01 <wnoise> I've been trying to redo the standard unix text utilities...
17:02:35 <shapr> cool, how far have you gotten?
17:02:59 <wnoise> http://ofb.net/~wnoise/haskell/unix/
17:03:19 <wnoise> They need lots of work on the error handling, and "cut" isn't done.
17:03:30 <shapr> cool, this another good candidate for a TMR article.
17:04:23 <shapr> have you seen - http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/haskell-ls/ ?
17:05:08 <dons> that's an interesting coding style in cat.hs:getFilter
17:06:12 <shapr> stepcut wrote some cool code that attempts to handle unix pipes nicely. One non-working version used pipes as arrows before it ran into the same problem John Hughes had with CGI arrows.
17:06:26 <wnoise> yes, it is.  It was the clearest way I could think of doing it though.
17:07:10 <shapr> looks kind of like Generic Haskell stuff.
17:07:22 <wnoise> I have not seen that.  I'll take a look.  Wht was the problem with  pipes as arrows?
17:07:43 <shapr> arrows can't be constrained to instances of Read/Show
17:10:37 <shapr> That's really a Haskell type system thing. You'd have to create a whole separate CGIArrow or PipeArrow typeclass hierarchy to replace the existing Control.Arrow typeclass hierarchy, and the result wouldn't work with existing arrows.
17:10:38 <wnoise> How is that a problem?  Or why was doing that a desired goal?
17:11:47 <shapr> iirc, it's because you can't create an instance that's more limited than the class.
17:12:28 * shapr checks
17:13:19 <wnoise> Why couldn't you use the existing arrows, and not care about limiting them?
17:15:18 <shapr> To have a CGIArrow that can be saved as a first-class websurfer continuation, you must be able to save and load it. That would require your value to be an instance of Read/Show or Binary.
17:15:56 <wnoise> Ah, okay.
17:16:27 <wnoise> So, is autrijus supposed to be pronounced "outrageous"?
17:17:24 <Philippa> shapr: I don't appear to have a mail about the article in my inbox :-)
17:17:26 <shapr> Details of the CGIArrow problem is at the bottom of page 38 in "Generalising Monads to Arrows" by John Hughes.
17:17:36 <shapr> Philippa: whoops, sorry. I thought you were gone for the night!
17:18:08 <shapr> What can I say? It's cool!
17:18:48 <shapr> What's going to fit into semantic friggery?
17:19:06 <shapr> Very cute title.
17:20:43 <Philippa> I don't know I'll stick with it, it was a get-me-by
17:21:02 <shapr> Btw, there is a trick to pass command-line params into TH, I think.
17:21:41 <shapr> At least, Ulf Norell had some unexpected trick that mixed getArgs and TH in his IOHCC entry.
17:21:47 <Philippa> getArgs etc in qIO?
17:22:31 <Philippa> anyway, it was going to be some burbling about static vs dynamic semantics and purity and lack thereof and stuff
17:23:05 <Philippa> I've just thought of a phrase I should use: "finding the beauty in really really dirty hacks"
17:23:11 <shapr> yes, that's it actually. getArgs >>= readFile
17:23:34 <shapr> heh
17:24:31 <Philippa> the point being that by and large the column's about ways to do things that seem incredibly filthy (and coincidentally go really fast or save lots of time) while retaining as much reasoning capacity and/or grounds for believing the code's correct as possible
17:24:33 <shapr> It looks good to me. TH users will enjoy it.
17:25:06 <shapr> Non-TH users will want to understandthe joke in Main.hs
17:26:25 <shapr> It's good :-)
17:26:50 <Philippa> non-TH users should blink and wonder WTF makes that a compiler :-)
18:18:05 <wnoise> So, that thbot thing I saw earlier.  Who was running it, and why isn't running generally?  That @pointless thing was neat.
18:18:34 <shapr> TheHunter runs it, and I just haven't gotten around to integrating the plugin into lambdabot.
18:18:57 <shapr> lambdabot needs a bunch of cleanup, I have a big stack of incoming patches.
18:19:56 <shapr> Anyone want to take over as lambdabot maintainer and hoster?
18:19:59 * shapr blinks innocently
18:24:12 <dons> some much to do, so little time
18:24:34 <shapr> yup
19:05:40 <KrispyKringle> Any recommendations from vim users on how to get proper indentation going?
19:07:08 <dons> we don't have a decent haskell indenter written in vim script
19:07:22 <KrispyKringle> ah, damn. 
19:07:24 <KrispyKringle> c'est la vie. thanks. 
19:07:49 <dons> I've got about 70 lines written of one, but it isn't so nice using regular expression to simulate a Haskell parser
19:08:10 <dons> it's useful to just add:
19:08:11 <dons> set comments=bO:--
19:08:11 <dons> set formatoptions=tcqr
19:08:21 <dons> however, which gives you auto-commenting
19:08:50 <dons> add that to ~/.vim/after/syntax/haskell.vim
19:09:16 <dons> luckily we've got pretty good syn hl these days
19:09:24 <dons> but I'd hate to have to program that stuff again
19:09:30 <CosmicRay_> KrispyKringle: you could always try emacs elvis mode or whatever its vim emulator is called :-)
19:09:38 <dons> bah!
19:10:00 <dons> isn't haskell indent in emacs notoriously broken too, btw?
19:10:17 <dons> sad, considering how easy it is to write a haskell pretty printer :(
19:10:20 <dons> yi yi yi!
19:11:44 <CosmicRay_> dons: well not really
19:11:51 <CosmicRay_> dons: however it is somewhat annoying
19:11:55 <KrispyKringle> CosmicRay_: the reason i use vim is because emacs is so slow on my machine :P
19:11:59 <CosmicRay_> the tab key does not indent as I expect it to normally
19:12:03 <dons> it has improved?  I remember a problem with tab..
19:12:06 <CosmicRay_> KrispyKringle: oh?  how oldis your machine?
19:12:07 <dons> oh that's it :)
19:12:10 <KrispyKringle> CosmicRay_: i just switched about a month ago or so, though. i'd rather not go back :P
19:12:14 <KrispyKringle> CosmicRay_: G4 1ghz. ;)
19:12:19 <CosmicRay_> huh
19:12:27 <CosmicRay_> it was fine on my 400MHz Powerbook :-)
19:12:28 <dons> hehe
19:12:34 <CosmicRay_> KrispyKringle: osx?
19:12:35 <KrispyKringle> Emacs takes about 9 seconds to start up, CosmicRay_. Vim takes 3. :P
19:12:37 <KrispyKringle> yes, osx. 
19:12:40 <CosmicRay_> ah.
19:12:42 <dons> yep those figures are about right
19:12:43 * CosmicRay_ identifies the problem
19:12:59 <CosmicRay_> hmm, actually I don't think emacs takes 9 seconds to start up on my 800mhz imac
19:13:02 <KrispyKringle> it's totally fine once it's running, of course. and i don't have a huge bias towards vim or emacs for functionality; each have their advantages. 
19:13:04 <dons> emacs users always state that you shouldn't have to start it up though :)
19:13:10 <dons> it should always be running..
19:13:13 <KrispyKringle> CosmicRay_: that was a top-of-the-head guess. :P
19:13:17 <CosmicRay_> heh
19:13:23 <KrispyKringle> one-one-thousand, two-one-thousand, three-one-thousand... :P
19:13:25 <CosmicRay_> but I hate terminal.app
19:13:34 <KrispyKringle> ah, i generally use carbon emacs or gvim (now). 
19:13:37 <CosmicRay_> totally lame-ass terminal emulator
19:13:40 <CosmicRay_> ah
19:13:49 <KrispyKringle> but terminal.app is better than most alternatives. font smoothing is god. 
19:14:00 <dons> KK: you could help with Yi, if you hate vim and emacs, and like fast editors... :)
19:14:07 <KrispyKringle> dons: what's yi?
19:14:08 <CosmicRay_> see what happened here was, I got the imac for my video editing.  but my wife decided, about 2 hours after it was set up, that it was "hers"
19:14:11 <KrispyKringle> sounds like an odd war-cry.
19:14:13 <CosmicRay_> so I haven't used it much :-)
19:14:20 <KrispyKringle>  hehe
19:14:31 <KrispyKringle> why an imac? awfully slow for the cost, no?
19:14:35 <KrispyKringle> otoh, final cut pro is swseet. 
19:14:40 <dons> http://www.cse.unsw.edu.au/~dons/yi.html
19:14:50 <CosmicRay_> KrispyKringle: this was a couple of years back
19:14:52 <KrispyKringle> ah, google found it. 
19:14:53 <KrispyKringle> CosmicRay_: ah. 
19:15:02 <CosmicRay_> KrispyKringle: I got what I needed to run final cut pro 3
19:15:02 <dons> it starts up faster than vim and emacs :)
19:15:07 <CosmicRay_> KrispyKringle: imac cheaper than power mac
19:15:19 <KrispyKringle> how usable is yi yet?
19:15:24 <KrispyKringle> CosmicRay_: true. 
19:15:34 <shapr> we love yi
19:15:35 <CosmicRay_> we have one of the first generation lcd imacs
19:15:36 <dons> it does vi + some vim very well, I think
19:15:38 <KrispyKringle> i think i'd have gone with a PC and Adobe, though, if I had to save money. 
19:15:44 <CosmicRay_> I still like it better than the current imacs
19:15:50 <KrispyKringle> good bang for the buck. 
19:15:56 <KrispyKringle> yeah, the G5 imacs aren't pretty, imho. 
19:16:02 <shapr> like shooting deer..
19:16:20 <CosmicRay_> KrispyKringle: using windows makes me nervous
19:16:24 <KrispyKringle> true. 
19:16:30 <KrispyKringle> i've heard it's better ;)
19:16:32 <CosmicRay_> KrispyKringle: also a good firewire+dv editing setup was hard to come by on pcs at the time
19:16:34 <shapr> Windows users are like wives of alcoholics. They'll take any amount of abuse and keep coming back.
19:16:51 <CosmicRay_> lol
19:16:55 <dons> oh that is so non-PC
19:17:01 <shapr> ain't it though
19:17:02 <dons> :)
19:17:14 <shapr> dons: c'mon you an aussie! non-PC is *funny* over there!
19:17:23 <CosmicRay_> KrispyKringle: using windows literally makes me nervous.  I unplug the network cable before I boot to it to run any games.
19:17:30 <shapr> quick, I want to move to Oz!
19:17:35 <dons> sometimes I wonder what the rest of the world thinks .au is like..
19:17:38 <CosmicRay_> KrispyKringle: and if I must do something over the network, I make sure windows doesn't know how to find my router
19:17:41 <KrispyKringle> CosmicRay_: ah, it's not that bad. 
19:17:45 <shapr> pack up the sleigh, where're the reindeer?
19:17:57 <CosmicRay_> KrispyKringle: pfft, average of 8 minutes to get infected from a clean install? 
19:18:14 <shapr> dons: honestly, I really enjoy the aussie sense of humor in medium sized doses.
19:18:20 <dons> hehe.
19:18:24 <CosmicRay_> KrispyKringle: unpached root-type vulns in ie persisting for 2 years?
19:18:33 <shapr> It's good therapy for those of us with an inaccurate self-image.
19:18:43 <KrispyKringle> CosmicRay_: which? 
19:18:46 <KrispyKringle> granted, IE sucks. 
19:19:19 <shapr> Seafood once said "A little bit of Shae goes a long way."
19:19:20 <CosmicRay_> dons: lesse, we think bandwitdh in .au is scarce, your telcos slightly more annoying than ours, your wildlife way cooler, and your seasons interesting :-)
19:19:30 <Gahhh> I dont use IE. I am behind a hardware firewall. no problems.
19:19:35 <KrispyKringle> But XPSP2 introduces security features that aren't standard in any other desktop OS--stack canaries, NX pages, etc. 
19:19:49 <KrispyKringle> Granted, there's always the market share thing, but MS deserves credit for that. 
19:20:00 <dons> CosmicRay_: ok. that's about right.
19:20:03 <Gahhh> MS deserves credit for soo little. but it's working for me right now.
19:20:12 <CosmicRay_> fat lot of good that does you when ie is perfectly content to treat any code as legitimate :-)
19:20:20 <CosmicRay_> dons: heh
19:20:28 <CosmicRay_> dons: oh also, the .au accent is the best.
19:20:32 <shapr> truly
19:20:37 <shapr> the coolest accent ever
19:20:44 <dons> ah, that's interesting
19:21:04 <dons> at ICFP this year, I actually had trouble being understood by some of the utah locals
19:21:07 <CosmicRay_> dons: what do you think of the .us accent?
19:21:09 <CosmicRay_> heh
19:21:15 <shapr> ouch, that's sad.
19:21:31 <CosmicRay_> shapr: I have trouble understanding .us southerners sometimes.
19:21:33 <Gahhh> some .us accent is pretty good imho
19:21:39 <CosmicRay_> shapr: I'm sure you know what I mean
19:21:51 <CosmicRay_> growing up in the .us south, I mean :-)
19:21:55 <shapr> A large percentage of native english speakers have trouble understanding me, but that's just the high speed at which I speak.
19:21:57 <dons> the .us accent sounds normal to .au often, considering the amount of .us tv we get
19:22:05 <KrispyKringle> dons: Bear in mind that this state was founded by followers of a charlatan who convinced them that the lost 10 tribes of hebrews were in north america and that he had discovered golden tablets created by god that only he could read...
19:22:08 <dons> and it seems easy for .au people to pick it up.
19:22:19 <CosmicRay_> KrispyKringle: haha
19:22:23 <shapr> yeah, good point
19:22:27 <dons> considering the number of .au actors on .us tv and movies
19:22:29 <KrispyKringle> ...it's funny because it's true. 
19:22:46 <dons> KK: hehe
19:22:57 <CosmicRay_> dons: everytime there is an actor that is supposed to be playing a typical australian, he seems to have a fixation with knives and beer.
19:23:08 <dons> sigh. I know
19:23:16 <Gahhh> as if americans don't like beer
19:23:29 <CosmicRay_> dons: it's funny watching stereotypes of americans in foreign films
19:23:31 <shapr> CosmicRay_: Great story, my German accented woman has english so sharp you can cut yourself on the edges of words... We went into a Kentucky Fried Chicken, and I had to translate both directions between the cashier and my woman.
19:23:51 <CosmicRay_> the british always portray americans as loud and slightly stupid
19:23:58 <KrispyKringle> Can you blame them?
19:24:00 <dons> .us people are probably loud and stupid here too
19:24:02 <CosmicRay_> shapr: you had to translate from her english to what?
19:24:08 <KrispyKringle> .us people are loud and stupid here, dons. 
19:24:09 <Gahhh> I'd say sluggish and indifferent, not stupid
19:24:13 <dons> hehe
19:24:14 <CosmicRay_> heh
19:24:20 <shapr> I had to translate into Alabama Ebonics.
19:24:24 <CosmicRay_> ah
19:24:36 <shapr> Cashier said "whu shu wah?"
19:24:46 <shapr> which is "what you want?"
19:24:48 <dons> there's a good saying here about no matter how different .au and .uk are, you realise we're basically the same once you talk to an american
19:24:55 <CosmicRay_> haha
19:24:56 <shapr> hah!
19:25:34 <CosmicRay_> you know, my favorite simpsons episode was the one where bart travels to australia to receive a booting
19:25:38 <CosmicRay_> any of you seen that one?
19:25:40 <Gahhh> yes
19:25:42 <dons> oh no. 
19:25:48 <CosmicRay_> I love the device to reverse the coriolis effect on the toilet
19:25:50 <shapr> what's a booting?
19:25:54 <shapr> hahah!
19:26:01 <dons> the toilet thing was a good one
19:26:19 <CosmicRay_> shapr: the prime mister put on his special punishment boot and was to kick bart in the butt
19:26:27 <dons> and the accent was funny too. kind of a convict accent
19:26:28 <shapr> oboy
19:26:28 <CosmicRay_> bart mooned him...
19:26:46 <Gahhh> this was in the parliement iirc
19:26:52 <dons> yep
19:26:54 <CosmicRay_> they wound up escaping the american embasy in a helicopter, vietnam-retreat-style
19:27:03 <dons> that's what it really is like down here. 
19:27:06 <CosmicRay_> heh
19:27:08 <dons> beer instead of coffee
19:27:13 <dons> kangaroos instead of taxis
19:27:17 * shapr snickers
19:27:25 <shapr> bullroarers instead of telephones
19:27:26 <humasect> what is "TH"?
19:27:30 <shapr> Template Haskell
19:27:35 <CosmicRay_> shapr: it all started when bart called some country .au boy collet to see if their toilets really did go backwards
19:27:38 <humasect> thanks
19:27:45 <CosmicRay_> shapr: the boy checked his own, then bart asked him to check his neighbors
19:27:59 <CosmicRay_> shapr: so the kid ran out of the house, and 9 hours later finally got back to report it also did that
19:28:06 * shapr snickers
19:28:19 <Gahhh> bart had no trouble understanding the kid, tho
19:28:35 <dons> yeah. hmm.
19:28:57 <CosmicRay_> lesse...
19:29:10 <CosmicRay_> also the us embasy fence proudly had a "made in america" sign, then failed to operate...
19:29:16 <shapr> I wouldn't mind moving somewhere near Ayers Rock if I could still get decently fast internet.
19:29:27 <Gahhh> Simpsons also had an episode on Mormons. They seem to have tonite's discussion covered.
19:29:41 <dons> shapr: satellite out there
19:29:45 <shapr> how fast is it?
19:29:50 <shapr> and how much? =)
19:29:50 <dons> and it's the desert, so no facilities
19:30:04 <dons> at least you'd have the flying doctor..
19:30:29 <CosmicRay_> shapr: satellite sucks
19:30:34 <CosmicRay_> shapr: high latency
19:30:45 <shapr> No facilities? You mean you get dirt, air, and not much else, right?
19:31:01 <dons> yep. a tank of water, a shed
19:31:08 <shapr> Sounds good.
19:31:13 <CosmicRay_> shapr: would you want to live in the country that gave the world Rupert Murdoch? :-)
19:31:33 <shapr> ?
19:31:45 <dons> he's an american now, anyway
19:31:46 <shapr> ohh
19:31:48 <shapr> http://en.wikipedia.org/wiki/Rupert_Murdoch
19:32:04 * CosmicRay_ was just looking up a wikipedia url for you :-)
19:32:20 <CosmicRay_> dons: yeah but if you australians had been shagging a little less in 1931, the world would be a better place :-)
19:32:36 <dons> he
19:33:01 <shapr> I like warm, isolated, and sunny. Alice Springs sounds perfect.
19:33:19 <CosmicRay_> I like cool, isolated, and sunny.
19:33:33 <shapr> I'm 'bout full on cool.
19:33:34 <CosmicRay_> north dakota I think would be perfect.
19:33:36 <dons> ok, you'd at least have facilities in alice springs itself
19:33:38 <CosmicRay_> maybe canada.
19:33:41 <CosmicRay_> shapr: heh
19:33:45 <wnoise> Sunny?  Bah.  Cool is good.
19:33:59 <shapr> wnoise: Try the Arctic Circle during the winter.
19:34:09 <dons> shapr misses the sun
19:34:13 <shapr> very much
19:34:26 <dons> you need to fly south for the winter
19:34:39 <shapr> Yeah, Alice Springs. I can come back for the millenium.
19:34:49 <wnoise> born and raised in the mountains, snowfall taller than people my first winter.
19:35:48 <shapr> Cycling around Australia would also appeal to me. Around the whole thing, of course.
19:36:12 <dons> that would be pretty fun. people do do it, but it is 1000s of km
19:36:20 <dons> like cycling across russia
19:36:26 <wnoise> I've now finished all the flags for "cat", thanks to actually taking a look at it again.  Now I just need to get error handling & file reading done nicely.
19:37:35 <Gahhh> hmmm mozilla subird
19:37:40 <shapr> A nice recumbent tricycle and a trailer for gear... then take a year off and go round Oz. That would be so much fun.
19:38:20 <wnoise> And my first use of the state monad.  Heh, that code was old.
19:39:55 <dons> shapr: satellite: http://www.bigpond.com/internet-plans/broadband/satellite/default.asp
19:40:40 <dons> fairly expensive if you're in a really remote area, with heavy usage
19:40:41 <shapr> wow, cool!
19:40:59 <shapr> Does it come with bicycle mounts? =)
19:41:10 <shapr> I have wondered about a true tech-nomad lifestyle.
19:41:38 <dons> $500AU/month for 800kbps download
19:41:51 <shapr> What's Au to Euro?
19:42:55 <shapr> aha, that's ~300 euro
19:42:57 <dons> hmm, 298.781 EUR
19:43:10 <shapr> Not bad actually.
19:43:36 <dons> 1000EUR installation
19:43:40 <shapr> Not much more expensive than our first 128k DSL in Finland.
19:44:24 <shapr> Yow, only 300e for our installation.
19:44:47 <dons> ah, you get a .au govt subsidy on the price anyway. 
19:45:03 <dons> so it would really be more expensive, without the subsidy
19:45:39 <Cale> It's only ~$30 CDN for 3mbit down 1mbit up here
19:45:48 <dons> I guess someone has to drive 1000km to find you in the desert, in order to set up the dish..
19:46:06 <Cale> but yeah, if you were in a remote area, I can see it being expensive :)
19:46:45 <dons> you could probably build your own big dish though..
19:47:28 <Cale> oh, satellite, I should pay attention :)
19:50:48 <Cale> Or purchase a dish and set it up yourself
19:52:38 <humasect> why does haskell-mode indent in a cascade =(
19:53:35 <heatsink> that's just what it does. You end up with very long lines that way unfortuantely.
19:54:01 <humasect> hm, i found pressing tab a second time does it 'right'
19:54:09 <humasect> (three different ways, apparently)
19:54:33 <humasect> (simple-indent had problems when i tried it)
19:54:58 <Cale> really? I like simple-indent
19:55:59 <humasect> hm, i'm going to try it again.
19:57:59 <humasect> out of curiosity, does specifying the type of functions have a resulting effect of also shortening compile times?
19:58:10 <humasect> (noticeably for large projects)
19:58:36 <dons> I would not think so
19:59:08 <dons> but they help as assertions of the expected type of the function
19:59:17 <humasect> k
19:59:40 <dons> type inference still has to proceed over the body of the function anyway
19:59:50 <humasect> ahh
19:59:55 <humasect> oh of course
19:59:58 <humasect> 6_9
20:00:20 <dons> they're not statements that 'this function _is_ of this type", rather, I would like it to have this type
20:00:29 <dons> but the compiler still has to check
20:00:47 <dons> hmm. unsafeTypeSigs sound like an interesting idea
20:00:50 <humasect> k, thanks
20:02:44 <dons> but you essentially get that with unsafeCoerce# and a type sig
20:03:53 <dons> > let (f :: Int) = GHC.Base.unsafeCoerce# 'x' in f
20:03:53 <dons> 120
20:05:29 <dons> btw, if it is compile times that are a problem, try -Onot -fasm -H60M, for example
20:05:33 <dons> or even better, develop in ghci
20:05:46 <humasect> one would think that FFI types are interchangeable with HS types
20:05:56 <humasect> ahh, ok
20:06:01 <humasect> mm =)
20:07:03 <humasect> Couldn't match `Double' against `IO Foreign.C.Types.CDouble'
20:07:10 <humasect> this is really putting a hamper on my experimentation
20:07:49 <dons> there's an IO to deal with there
20:08:11 <humasect> foreign import ccall "ticks" ticks :: IO CDouble
20:08:26 <humasect> suchlike?
20:08:50 <dons> x <- ticks
20:08:54 <dons> x :: CDouble
20:09:13 <humasect> ohh, as a newbie i do not know about '<-' but thought it is for IO types..
20:10:58 <humasect> so it isn't as simple as: x <- ticks \n let gray = (x / seconds) - i'll learn =) thanks.
20:11:14 <dons> ticks >>= realToFrac should do it
20:11:54 <dons> Prelude Foreign.C.Types> let x = 7 :: CDouble
20:11:54 <dons> Prelude Foreign.C.Types> :t (realToFrac x) :: Double
20:11:54 <dons> (realToFrac x) :: Double :: Double
20:12:46 <humasect> woo
20:12:48 <dons> do x <- ticks ; let dx = realToFrac x, for example
20:18:59 <humasect> excellent, so far the main bit is ported from ocaml =)
20:19:36 <dons> cool
20:20:05 <humasect> one quick question.. how to define an 'empty' function?
20:20:11 <humasect> as placeholder
20:20:19 <dons> f = undefined ?
20:20:26 <dons> or f = error "not implemented"
20:20:31 <humasect> ahh, nice
20:20:34 <dons> laziness is cool
20:20:37 * humasect thought the type sig would do it
20:20:39 <humasect> yeah =)
20:35:34 <KrispyKringle> dons: laziness rocks. I got no work done today!
20:35:42 <KrispyKringle> (you probably get that joke a lot.)
20:52:09 <humasect> ah, simple mode just inserts enough tabs to meet the target. so if the cursor has tabs in front..
21:11:44 <KrispyKringle> stupid question...how do i put quotes in a String? Apparently escaping them with a \ doesn't work...
21:13:05 <KrispyKringle> which is odd, because it looks like it should, from what i've read. 
21:13:24 <dons> > print "\"foo\"" 
21:13:24 <KrispyKringle> oh, whoops. nevermind me. 
21:14:47 <KrispyKringle> yeah, it's just the toplevel environment that results in it showing the \
21:14:48 <KrispyKringle> nevermind. 
21:14:48 <KrispyKringle> :P
22:37:34 <tintin> ,d erehwon
23:03:05 <SyntaxNinja> does c-- exist, or something like it?
23:03:39 <heatsink> c--?
23:03:48 <heatsink> You mean, like before C and C++?
23:04:17 <ozone> SyntaxNinja: not sure what you mean.  it definitely exists ...
23:04:36 <wnoise> http://www.cminusminus.org/
23:05:08 <SyntaxNinja> yeah, that's it... but the whole idea is that it should target multiple platforms, and it doesn't look like htat's the case; is the project going anywhere?
23:05:41 <ozone> SyntaxNinja: GHC uses some bits of C-- in the code generation backend right now
23:05:58 <ozone> it doesn't generate C-- code for the entire program yet, and i'm unsure exactly what bits of C-- are used.  but it does use it
23:06:11 <ozone> probably best to email dons or simonm for more info
23:06:23 <ozone> or norman ramsey
23:06:28 <SyntaxNinja> hmm
23:06:37 <SyntaxNinja> why in the world is it written in OCaml if it's by SPJ?
23:06:55 <ozone> it's not written by SPJ.  the main contributor right now is norman ramsey, iirc
23:06:59 <desrt> afaik, cmm -is- the ghc backend
23:07:07 <desrt> the NCGs are cmm compilers
23:07:16 <desrt> and even the C backend is just a cmm pretty-printer, basically
23:07:27 <ozone> oh yeah, or ask desrt ;)
23:08:02 <SyntaxNinja> oh, the web page mentions spj a few times...
23:08:55 <SyntaxNinja> desrt: should I get it from that web page, then? or is it in the fptools tree?
23:09:15 <desrt> it's part of ghc....
23:09:44 <desrt> the higher parts of ghc generate a Cmm abstract syntax tree (there's a datatype in there somewhere) then the lower parts produce code from it
23:10:46 <SyntaxNinja> is there a stand-alone cmm compiler that I can just use?
23:10:57 <desrt> http://www.cminusminus.org/qc--.html
23:11:50 <SyntaxNinja> OK, so is that a different compiler for the same language? there's on in GHC too?
23:12:40 <desrt> there are a bunch
23:13:13 <SyntaxNinja> that's cool.  so I basically just want to put together a code generator for a toy language, to play around and experiment; is c-- a good choice?
23:13:46 <SyntaxNinja> I don't feel like going to assembly language. I might also be happy if there were just a good intermediate language I could use.
23:13:54 <SyntaxNinja> or API
23:14:13 <desrt> that's what c-- is for
23:14:37 * SyntaxNinja nods
23:18:26 <SyntaxNinja> ooh, there are debian packages :)
23:25:31 <SyntaxNinja> desrt: thanks for the info. I'll check this out.  good night a..
