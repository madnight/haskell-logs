00:00:31 <Lemmih> shapr: Yo.
00:07:40 <Lemmih> shapr: I'm having problems with the Hackage repo.
00:09:52 <lispy> would it be possible to have lazy evaluation in an imperative language?
00:10:03 <lispy> like a lazy eval version of C for example?
00:10:43 <lispy> i'm thinking no, but i can't figure out why i think that
00:11:15 <Lemmih> You know that GHC can compile Haskell to C, right?
00:11:23 <shapr> Every language has both lazy and strict eval.
00:11:33 <shapr> Otherwise both branches of an if would be executed.
00:12:15 * Lemmih mumbles something about languages without if statements.
00:12:40 <heatsink> so... quantum computers can't do lazy evaluation, right?
00:13:01 <lispy> heatsink: heh
00:13:10 <Lemmih> shapr: I would like you to upgrade Hackage on your server.
00:13:20 <shapr> ok
00:14:14 <shapr> What are the errors?
00:14:38 * heatsink feels snubbed and goes off to eat ice cream by itself
00:14:45 <shapr> snubbed?
00:14:47 <Lemmih> The oh so verbose: "Error applying patch to recorded!"
00:15:09 * shapr upgrades to darcs 1.0.2
00:15:21 <shapr> try it again
00:15:37 <Lemmih> Oki.
00:15:52 <shapr> ah crap, my curryspondence repo is broken.
00:16:12 <shapr> so is my wikiwiki repo
00:16:51 * lispy sometimes has thoughts of switching his language of choice from lisp to haskell
00:17:02 <lispy> i'm in this class this term about programming languages
00:17:08 <shapr> lispy: You could use both of them.
00:17:09 <lispy> and we're always talking about how nice haskell is
00:17:34 <lispy> shapr: true, and the research i do is mostly in lisp
00:17:35 <shapr> I have a dream of a bunch of features that I want in my perfect language, and I use whatever language fits that best.
00:17:56 <lispy> heh, the front end is in VB tho
00:18:25 <Lemmih> shapr: Darcs doesn't like GHC 6.4?
00:18:40 <lispy> hmm..1.0.2 isn't in debian unstable yet
00:18:40 <shapr> And I realize that my dream features change over time, and so does the language that I use most.
00:18:50 <shapr> it sure looks like it is to me.
00:19:01 <lispy> shapr: yeah that's the reason i keep coming back to lisp
00:20:02 <shapr> I think the best approach is to pursue ideas/goals/etc with whatever means you prefer, and don't get stuck on anything.
00:20:03 <lispy> but right now the thing that's bugging me about lisp is maintaining the poorly craft lisp we have in the project from eons past
00:20:25 <lispy> heh, "don't get stuck on anything" you make it sound so easy ;)
00:20:44 <shapr> Well, it is... if you have your goals in mind when you're doing stuff.
00:21:19 <shapr> I really enjoy using Haskell, but I'm aware of its flaws, and languages that are like Haskell but more so (Epigram).
00:21:25 <lispy> some of our past programmers didn't know functional programming so they wrote lisp code that could almost run in C if you replaced the ()'s with {}'s
00:21:30 <shapr> youch
00:22:18 <shapr> Down that line of reasoning, I think that PHP and Perl can be great project languages if the programmers use them in a discipline manner. Just that the culture of those languges doesn't encourage that.
00:22:24 <lispy> the sad thing is that people assume those function are complicated and then write all the function that depend on them to take care of their special cases
00:22:51 <shapr> Sounds like you need get yourself assigned to the refactoring team.
00:23:02 <lispy> i think i'll be using PHP this summer, not sure if i'll get put on that project tho
00:23:32 <shapr> Bad code can be written in any language.
00:23:41 <lispy> shapr: actually, anyone in the group is allowed to refactor anything you want as long as you still pass the testsuite, but...we all have higher priorities
00:23:56 <shapr> Wow, real collective code ownership...
00:24:04 <shapr> Sounds like you guys need to change your priorities.
00:24:09 <lispy> ;)
00:24:23 <lispy> right now my biggest priority is to make our frontend fast
00:24:31 <lispy> but the front end is written on top of excel
00:24:38 <lispy> there isn't much we can do to gain performance
00:24:45 <shapr> Can you persuade your boss to choose a Friday, and buy a few pizzas for lunch, and have the beer shipped in at seven pm, and do a group refactoring binge?
00:24:56 <lispy> heh
00:25:00 <lispy> that'd be cool
00:25:12 <shapr> Are you familiar with the idea of a 'sprint' ?
00:25:23 <lispy> in running yes
00:26:01 <shapr> In coding it's where a few people who work on a project get together in person, and binge for a few hours to a few days. It's popular in the Python world.
00:26:33 <shapr> Probably because much of the Python community only meets on IRC, and that's just not as productive as Pair Programming.
00:26:43 <lispy> ah
00:27:03 <lispy> i think we need to do a feature freeze and work on bugs for a while
00:27:05 <shapr> In any case, the concept applies nicely to other stuff, debian has bug squashing parties, etc.
00:27:10 <lispy> i mean if our front end is to become nice
00:27:16 <lispy> ah yeah
00:27:33 <lispy> i've heard of QA teams meeting with devs to get rid of bugs
00:27:42 <lispy> having contests and such
00:28:15 <shapr> I'm still not convinced that a QA team should be separate from the developers.
00:28:54 <lispy> shapr: is this what you meant when you said Epigram? http://www.dur.ac.uk/CARG/epigram/
00:28:58 <shapr> yup
00:30:31 <shapr> A few sprints would help your application.
00:30:58 <lispy> yeh
00:31:08 <shapr> I'd suggest a refactoring sprint first, because a nicely factored backend will make frontend optimization easier.
00:31:08 <lispy> i may mention that at our tech meeting tomorrow
00:32:22 <musasabi> morning
00:32:29 <shapr> Haskell is a great language, and worth submerging yourself into for a few months or a few years. But I don't think Lisp, Haskell, or anything else I've seen is the best solution to all problems.
00:32:52 <lispy> right
00:33:06 <shapr> I prefer to have a bunch of tools available. The most important tools (imho) are the tools in our head.
00:33:41 <shapr> And I think that includes understanding metaprogramming and why Lisp is good at it, and type theory and how it's useful in Haskell.
00:33:58 <shapr> But those are just two specific instances of good tools, there's lots more.
00:34:47 <shapr> Do you read http://lambda-the-ultimate.org/ ?
00:34:53 <lispy> no
00:34:54 <lispy> should i?
00:35:13 <lispy> i was starting to read about Epigram
00:35:16 <shapr> It's one place to get exposure to new ideas that may be worth investigating.
00:35:24 <shapr> Epigram is worth learning too.
00:35:34 <shapr> It can encode behaviour in type signatures!
00:36:05 <shapr> If you haven't read WardsWiki, it has good stuff too.
00:36:26 <musasabi> type signatures serve as documentation and assertions in haskell.
00:36:27 <shapr> Sadly, lots of idiots recently, but there's a lot of great content lying around there.
00:36:54 <shapr> hei musasabi, what's up?
00:37:39 <lispy> well, it's almost 1am here
00:37:42 <lispy> i should go to bed
00:37:44 <lispy> thanks
00:37:47 <shapr> ok, come back soon!
00:38:18 <shapr> musasabi: did you read the LtU discussion that talked about Haskell as having a zeroth-generation type system?
00:38:32 <musasabi> shapr: still debugging and reworking my socket code.
00:38:38 <shapr> Ah, cool.
00:40:05 <shapr> What have you decided? is blocking better?
00:41:26 <musasabi> I went with nonblocking and warning in the documentation as it is the same behaviour the current module has.
00:42:54 <musasabi> today I have to hack up some locking mechanisms for platforms with broken name resolving functions (autoconf stuff to detect them)
00:44:02 <shapr> That sounds productive. Sort of.
00:45:10 <basti_> hi
00:45:13 <shapr> y0
00:45:15 <Lemmih> Hey.
00:46:00 <basti_> hey shapr were you able to read my article?
00:46:05 <basti_> :)
00:46:55 <shapr> I got it this morning, but then I got distracted into trying to write a Haskell program to find an efficient encoding of a Turing Machine or Lambda Calculus using IceHouse game pieces.
00:47:06 <musasabi> hello basti.
00:47:10 <basti_> icehouse??
00:47:14 <shapr> But I'll check out your article right now :-)
00:47:17 <basti_> is that something like lego?
00:47:21 <basti_> hi musasabi
00:47:26 <shapr> IceHouse - http://www.wunderland.com/icehouse/Default.html
00:47:53 <basti_> ah i've seen that page before....
00:48:34 <shapr> When running  "./ghc/compiler/stage2/ghc-inplace -package GLUT --interactive" does anyone else get "s/HSGLUT_cbits.o: unknown symbol `glutBitmap8By13'" ?
00:49:13 <shapr> I'm using the 20050212 GHC 6.4
00:49:23 <basti_> i've never felt the urge to do ghc-inplace...
00:49:52 <shapr> Do you have the 6.4 release candidate installed?
00:50:02 <basti_> no.
00:50:21 <basti_> i'm using 6.2 something
00:51:16 <Lemmih> shapr: GLUT loads fine here.
00:51:29 <shapr> and you're using nvidia drivers?
00:51:49 <shapr> basti_: topic.txt sounds great
00:52:02 <basti_> hmm -g- i wonder if this is still actual
00:52:38 <shapr> Embedding lilypond is way spiffy.
00:53:11 <wilx> What's lilypond?
00:53:19 <desrt> the sheet music editor?
00:53:27 <shapr> Yeah, LaTeX sheet music layout.
00:53:27 <wilx> Huh, interesting.
00:53:46 <shapr> or as I said when I opened the first .ps file "Wow! That looks cool!"
00:54:37 <basti_> =)
00:54:47 <basti_> lilypond is a great thing
00:55:17 <basti_> the syntax (and cs foundations) lack a little though.
00:55:20 <desrt> so are these new socks
00:55:20 <desrt> mmmm!
00:55:22 <shapr> Do you have a darcs repo for this already? I've spotted a few spelling errors...
00:55:26 <gzl> !
00:55:45 <gzl> slick. i got hudak to come give a talk :)
00:55:46 <basti_> hmm i have one but how would i make it accessible to you?
00:55:47 <shapr> hiya TFK, how's code?
00:55:52 <shapr> gzl: whoa, awesome!
00:56:07 <TFK> Code's featuring goodies like "except: pass" ;_;
00:56:09 <TFK> You?
00:56:12 <gzl> shapr: yeah, pretty neat :D
00:56:14 <TFK> *Yours?
00:56:16 <shapr> basti_: if it's available via http, I can grab it, and email patches back to you. Or we can do it the other way around.
00:56:28 * basti_ ponders
00:56:32 <gzl> he's coaching some high school sports team in april so I have to get him before then, though. first time I had to compete with a lacrosse team for a computer scientist
00:56:48 <shapr> TFK: I'm trying to figure out a way to do Martian Chess with the code on my screen.
00:56:51 <basti_> what happens if you try to connect to my ip via http on port 80?
00:56:58 <TFK> Martian Chess? o.o
00:56:58 <shapr> gzl: haha!
00:57:06 * desrt ditto tfk
00:57:12 <shapr> http://www.wunderland.com/icehouse/MartianChess.html
00:58:17 <shapr> gzl: That's awesome, do you record your talks?
00:58:22 <shapr> basti_: doesn't look like it.
00:58:29 <basti_> shapr: hmm ok wait.
00:58:43 <shapr> At least, I'm pointing my web browser that way with no response.
00:59:06 <gzl> shapr: unfortunately not, the people I have to work with weren't willing to help me out with that and I can't do it myself :(
00:59:08 <basti_> I'll use my uni homepage then
00:59:20 <gzl> shapr: the best I can do is ask the speaker for slides to make available afterwards
00:59:28 <shapr> gzl: suck
00:59:39 <gzl> yeah it's annoying
00:59:42 <shapr> I'd love to hear your talks on ITConversations.com
00:59:43 <gzl> it would be nice to have the stuff recorded
00:59:57 <gzl> hmm
01:00:02 <gzl> maybe we could look into audio recordings
01:00:23 <TFK> shapr, woo, fun!
01:00:25 <gzl> I need some A/V nut who can help me out, basically :)
01:00:54 <desrt> interesting game.
01:00:59 <gzl> I don't know how to do audio recordings properly
01:01:03 <shapr> TFK: You've been here before, haven't you? I think I recognize your irc nick.
01:01:21 * TFK nods
01:01:32 <TFK> I'm "trying" to learn Haskell :-)
01:01:38 <gzl> shapr: I have Stroustrup's slides if you'd like
01:01:42 * gzl grins crookedly.
01:02:11 <shapr> hehe, I'll pass for the moment =)
01:03:15 <shapr> TFK: What stage are you at right now?
01:03:39 <TFK> The very early one :-)
01:03:51 <shapr> gzl: I'd just see if you could patch into the audio system (I assume your talks require a mic?) and dump the output onto a DAT or even better directly onto a drive.
01:03:56 <TFK> I'm rereading the tutorial, to be precise.
01:04:27 <gzl> shapr: no, they often don't use a mic
01:04:36 <gzl> in fact they almost never do
01:04:50 <gzl> fwiw, this is the talk I'm probably going to ask him to give: http://www.cs.haverford.edu/lectures/HudakPoster1.pdf
01:06:18 <basti_> a.r.g.h.
01:06:45 <shapr> basti_: alternatively, I can create a repo on ScannedInAvian, and you can grab it and then send patches to it.
01:07:24 <ozone> gzl: aww, wish i was there to hear that talk
01:07:49 <shapr> Yeah, looks nifty. Likely it'll have neat connections with DSLs.
01:08:03 <shapr> TFK: have you seen http://www.haskell.org/hawiki/HaskellDemo ?
01:08:16 <basti_> shapr: lets do it that way.
01:08:27 <basti_> shapr: i cant ssh my website, and im not fond of copying 30 files per hand
01:08:43 <shapr> I understand.
01:09:42 <basti_> that means, I COULD ssh my website but I'd have to change my password then, which would affect about 100 things.
01:10:03 <basti_> schikane.
01:10:13 <shapr> no worries, I'll set you up a repo.
01:10:37 * basti_ nods
01:15:49 <basti_> i should add a makefile btw.
01:17:58 <TFK> shapr, nope, checking it out now
01:18:13 <shapr> basti_: do you have a gpg key?
01:18:21 <shapr> does your local sendmail/whatever work?
01:19:35 <basti_> hm.
01:19:36 <basti_> -g-
01:19:38 <basti_> i have one wait
01:21:17 <basti_> hmm
01:21:27 <basti_> i'm doing that far too rarely.
01:21:39 <shapr> doing what?
01:21:44 <basti_> gpg stuff.
01:22:03 <basti_> gpg --export?
01:22:34 <TFK> For some reason, hugs doesn't like me using '=', though
01:22:47 <shapr> darcs' patch-by-mail wants incoming patches to be signed by someone on the allowed_keys keyring.
01:22:57 <basti_> TFK: interactively?
01:23:13 <TFK> Yeah. I asked this before, but didn't get any real answer...
01:23:47 <basti_> tfk you can't define things interactively in hugs that way
01:23:57 <TFK> o_O?!
01:24:11 <TFK> What's the point of it being interperted, then?
01:24:42 <basti_> not declaring variables, obviously? =)
01:24:55 <basti_> shapr: http://pgp.mit.edu:11371/pks/lookup?search=Bastiaan+Zapf&op=index
01:25:04 <shapr> cool
01:25:07 <basti_> the first one. the other one was lost a few years ago.
01:25:16 <basti_> had to dig up the url
01:25:19 <shapr> TFK: you can load the file from disk with :load
01:25:19 <TFK> Well that's a weird point...
01:25:26 <TFK> I just did. Still...
01:25:39 <obe1> anyone know how `elem' is implemented? recursively?
01:25:42 <araujo> Hello.
01:25:45 <shapr> I use haskell-mode in emacs, so I can just hit C-c C-l to dump the Haskell buffer into hugs or ghci.
01:25:54 <araujo> What is haskell?
01:26:02 <shapr> araujo: let me introduce you!
01:26:09 * shapr grins
01:26:12 <araujo> haha
01:26:17 <araujo> Greetings shapr
01:26:32 <basti_> obe1: via list comprehension
01:27:03 <obe1> cause implement elem via recursion and i always get less reductions with +s to hugs then elem
01:27:28 <basti_> obe1: :)
01:27:35 <Heffalump> how many less?
01:27:44 <obe1> not much
01:27:46 <Heffalump> a constant number, or a constant scaling factor?
01:28:03 <Heffalump> I wouldn't pay any attention then. It's only a very rough guide.
01:28:15 <basti_> i doubt there is an algorithm that's better than O(n) for elem.
01:28:22 <obe1> a few each time, like i searched for 1,2,3,4 in list of [1,2,3], hehe small test, but i wanted to clarify before i went any further
01:29:02 <Heffalump> I expect elem is implemented in terms of foldr or something.
01:29:12 <Heffalump> which would explain a few extra reductions
01:30:18 <obe1> i also implemented elem with ( foldl (||) map (x==y) list ) and that did the worst
01:30:42 <Heffalump> that's not surprising, I think it would have to scan the whole list even if it found it at the beginning/end
01:31:00 <obe1> yea
01:31:01 <Heffalump> whereas foldr (||) ... wouldn't
01:31:14 <obe1> why whats different with foldr?
01:31:25 <obe1> starts from the right?
01:31:32 <Heffalump> it ends up as x==elem1 || (x==elem2  || (x==elem3 || ...
01:31:39 <Heffalump> and || short-circuits if its first argument is True
01:34:27 <obe1> yea foldl is better, but still not better then elem and neither is better then good old-fashion list-recursion or list-comprehension? have i got my terms right ? list-comprehension applying something to the head and recursing on the tail?
01:35:01 <Heffalump> fold_r_ is better :-)
01:35:17 <obe1> err yea, :) foldr
01:35:36 <Heffalump> I have no idea what the difference between foldr and explicit recursion would be. Tiny, if anything.
01:35:53 <Heffalump> and same for a sensible list comprehension like or [x==y | y <- list]
01:36:27 <obe1> what exactly does second best, where n = filter (\y -> y == x) list and then checking n == []
01:36:42 <obe1> exactly/actually/s
01:38:44 <Heffalump> I think you should stop worrying about the precise number of reductions so much.
01:39:01 <basti_> =)
01:39:03 <Heffalump> If you care about performance you'd use GHC which would probably optimise the difference away anyway.
01:39:07 <basti_> 6502-think
01:39:53 <obe1> not really, i just got into an argument with my professor about using the fold/map/or method, that it sucked
01:40:10 <TFK> data Point a            = Pt a a <--- in this example, what is Pt?
01:40:12 <obe1> i wasn't sure how elem did it. :)
01:40:53 <basti_> TFK: a constructor
01:41:06 <basti_> TFK: it's being introduced
01:41:33 <TFK> But in, say, "data Color = Red | Green" it isn't present.
01:41:34 <araujo> TFK, a nullary data cnstructor
01:41:38 <araujo> constructor*
01:41:46 <TFK> Well that's what the tutorial says, but what does it mean?
01:41:47 <basti_> nullary?
01:42:15 <basti_> TFK: well you would need a "name" to tell your haskell environment that what you're saying is a new thing of type "Point"
01:42:26 <araujo> It creates the data belonging to the type Point.
01:42:50 <basti_> since "Point" is already used (as the name of the type), you use another name, here "Pt".
01:42:52 <TFK> so in case of Color, Red and Green are their own constructors?
01:43:06 <basti_> Red and Green would be constructors for values of the type Color
01:43:22 <TFK> Oh. I thought of them as values.
01:43:34 <basti_> well in that case theres not much difference.
01:43:53 <basti_> when you say "Green" you construct a value of type Color already.
01:44:45 <TFK> hmm, thanks
01:45:25 <TFK> Hmm, so "nullary" means a constructor that takes no arguments?
01:45:40 <TFK> While Pt is not nullary because it takes two arguments?
01:45:41 <basti_> yep
01:45:46 <basti_> right
01:45:54 <TFK> Oh, nice.
01:49:33 <TFK> But I see that I can't "overload" constructors, i.e. I can't do: data Point a = Pt a a | Pt a a a , but instead must do: data Point a = Pt2 a a | Pt3 a a a
01:49:50 <basti_> yes you cant
01:50:06 <basti_> you generally cant overload things that way in haskell, because of currying
01:50:16 <TFK> What's "currying"?
01:50:36 <basti_> well a function in two parameters isn't type (a,b) -> c but a->b->c
01:50:51 <basti_> so you can give one parameter, and recieve as a result a function waiting for the other parameter.
01:51:39 <basti_> (-> is right-associative, btw.)
01:51:55 * TFK nods
01:52:46 <TFK> Ah, so that means that overloading would result in ambiguity.
01:53:09 <basti_> yes.
01:54:07 <basti_> but you can overload in another way, using typeclasses. But the haskell interpretation of typeclasses is a bit different of the C/Java interpretation
01:57:15 * shapr returns from being distracted ...
02:00:19 <shapr> basti_: ok, darcs get http://www.ScannedInAvian.org/repos/basti
02:00:53 <basti_> shapr: thanks
02:01:13 * Lemmih explodes in a fire-rain of segfaults.
02:01:22 <shapr> I've added both our keys to the allowed_keys keyring in the repository, please try to send a test patch to see if it works.
02:01:39 <basti_> I should try configuring my local mail exchange before that.
02:01:50 <basti_> I'll tell you when i'm done with that =)
02:02:21 <shapr> Awright, I'll be afk for a bit. We shutdown our office so the former office computer will be the new ScannedInAvian server.
02:02:24 <basti_> k
02:02:49 <shapr> I really enjoy playing with new hardware  =)
02:02:58 * shapr bounces away cheerfully.
02:06:09 <basti_> did i mention I HATE this local mail stuff?
02:06:44 <Itkovian> erm. yes?
02:09:42 <basti_> i have a different username here than on the "smarthost". big problem huh
02:15:32 * boegel greets
02:15:42 <Lemmih> Hey boegel.
02:18:27 <rafgo> hello
02:20:36 <araujo> Hello boegel , rafgo
02:21:41 <rafgo> any body there
02:23:47 <basti_> why do things rely on the fact that the system you're on at least fakes being a mailserver?
02:36:37 <basti_> oh great, now that i got my mail stuff working, "lilypond" strikes back.
02:44:52 <TFK> Wow, I think I understood section 2 of the tutorial this time around! xD
02:46:44 <basti_> TFK: =)
03:59:00 <wli> Looks like simonmar's got x86-64 hardware incoming.
04:20:45 <basti_> shapr: ping-ping?
04:31:02 <musasabi> Why is ghci not supported on openbsd?
04:33:01 <wli> a.out?
04:34:46 <musasabi> hmm point.
04:48:30 <TheHunter> yay! pointless madness on haskell-cafe.
04:50:15 <wli> valueless measures in pointless spaces
05:04:27 <TheHunter> thbot: @pointless \f g h a b c d -> f (g a b) (h c d)
05:04:27 <thbot> (flip .) . ((flip .) .) . ((((.) .) .) .) . ((((.) .) .) .) . (.) . (.)
05:04:56 <lightstep> @pointless \f g x -> (f x) (g x)
05:04:56 <thbot> s
05:04:56 <lambdabot> Sorry, I don't know the command "pointless", try "lambdabot: @listcommands
05:05:41 <lightstep> is this the "Automatic pointless translation" from the post?
05:06:03 <TheHunter> nah, that's my automatic pointless translation which is a lot fancier
05:06:27 <TheHunter> but for some strange reason, oleg's translation of this term is shorter.
05:06:52 <wli> thbot: @pointless \f g x -> (x : (f g (g x)))
05:06:52 <thbot> (s (:) .) . flip s id . ((.) .)
05:07:07 <wli> heh, there's a lingering 's'
05:07:17 <TheHunter> thbot: let x = const 3 y; y = const 4 x in x + y
05:07:37 <TheHunter> thbot: @pointless let x = const 3 y; y = const 4 x in x + y
05:07:37 <thbot> 7
05:08:01 <wli> thbot: @pointless let f g x = (x : (f g (g x))) in f
05:08:01 <thbot> fix ((s (:) .) . flip s id . ((.) .))
05:08:07 <wli> worse
05:16:50 <wilx> What does the @pointless command do?
05:17:51 <TheHunter> transform a term into pointless style, i.e. no lambdas.
05:18:59 <wilx> Hmm. Interesting.
05:19:14 <wilx> @pointless \x y = x + y
05:19:14 <thbot> (line 1, column 6):
05:19:14 <thbot> unexpected "="
05:19:14 <thbot> expecting pattern or "->"
05:19:15 <lambdabot> Sorry, I don't know the command "pointless", try "lambdabot: @listcommands
05:19:22 <wilx> @pointless \x y -> x + y
05:19:22 <lambdabot> Sorry, I don't know the command "pointless", try "lambdabot: @listcommands
05:19:22 <thbot> (+)
05:19:33 <wilx> I see.
05:20:18 <wilx> @pointless map (\x -> x + 1) [1]
05:20:19 <thbot> [2]
05:20:19 <lambdabot> Sorry, I don't know the command "pointless", try "lambdabot: @listcommands
05:20:22 <wilx> :)
05:20:25 <TheHunter> hmm, (f .) . (g .) ==> ((f . g) .)
05:22:00 <wilx> thbot: @pointless x
05:22:01 <thbot> x
05:22:07 <wilx> thbot: @pointless x .
05:22:08 <thbot> (line 1, column 4):
05:22:08 <thbot> unexpected end of input
05:22:08 <thbot> expecting white space or simple term
05:22:20 <wilx> thbot: @pointless (x .)
05:22:21 <thbot> (x .)
05:22:34 <wilx> thbot: @pointless x . y
05:22:34 <thbot> x . y
05:23:32 <TheHunter> yah!
05:25:33 <TheHunter> thbot: @pointless \f g h a b c d -> f (g a b) (h c d)
05:25:33 <thbot> ((flip . ((flip . (((.) . (.)) .)) .)) .) . (.) . (.)
05:26:28 <wli> thbot: @pointless \(a,b) -> (b,a)
05:26:29 <thbot> uncurry (flip (,))
05:27:22 <wilx> @type uncurry
05:27:27 <lambdabot> uncurry :: forall c b a. (a -> b -> c) -> (a, b) -> c
05:27:30 <wli> Who maintains thbot again?
05:27:40 <lightstep> thbot: @pointless \x y -> x $ y
05:27:40 <thbot> id
05:28:00 <wli> lightstep: parenthesize
05:28:05 <TheHunter> wli, that'd be me
05:28:10 <lightstep> thbot: @pointless \x y -> (x $ y)
05:28:10 <thbot> id
05:28:18 <lightstep> thbot: @pointless \x y -> (x $) y
05:28:18 <thbot> id
05:28:25 <lightstep> thbot: @pointless \x y -> ($ y) x
05:28:25 <thbot> id
05:28:33 <lightstep> thbot: @pointless $
05:28:34 <thbot> (line 1, column 1):
05:28:34 <thbot> unexpected "$"
05:28:34 <thbot> expecting white space, natural, identifier, lambda abstraction or expression
05:28:38 <lightstep> thbot: @pointless ($)
05:28:38 <thbot> id
05:28:50 <wli> TheHunter: what's the deal with the 's' and 'fix' things?
05:29:27 <wli> thbot: @pointless \x y -> (x y)
05:29:27 <thbot> id
05:29:34 <wli> that didn't work
05:29:37 <TheHunter> s is needed so that we have a complete combinator base.
05:29:47 <lightstep> can it possibly output a $ ?
05:29:57 <TheHunter> thbot: @pointless \f g x -> f x (g x)
05:29:58 <thbot> s
05:30:02 <wli> TheHunter: Don't the standard Prelude things suffice?
05:30:58 <TheHunter> yeah, if you're willing to put "(.) (flip (.) (head . uncurry zip . splitAt 1 . replicate 2) . uncurry) . (flip (.) (flip (.)) . flip (.))" in every expression that needs s.
05:31:07 <TheHunter> @type Control.Monad.Fix.fix
05:31:08 <lambdabot> Control.Monad.Fix.fix :: forall a. (a -> a) -> a
05:31:34 <wilx> Heh.
05:32:04 <TheHunter> fix is not strictly necessary, but we want to transform typed terms into typed ones, so we need fix
05:33:22 <wli> Well, let's try this
05:37:18 <boegel> @wiki TheMonadReader
05:37:18 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
05:41:53 <wli> hmm, dup is painful
05:42:14 <wli> (dup f x = f x x)
05:42:32 <wli> thbot: @pointless \f x -> ((f x) x)
05:42:33 <thbot> flip s id
05:43:03 <lightstep> @type (`s` id)
05:43:04 <lambdabot> bzzt
05:43:49 <wli> thbot: @pointless \f g -> flip (flip f . g) . g
05:43:50 <thbot> flip s id . (((.) . flip) .) . (.) . flip
05:44:32 <wilx> thbot: @pointless (flip flip)
05:44:33 <thbot> flip flip
05:44:48 <wli> thbot: @pointless \f (x, y) -> (f x, f y)
05:44:51 <thbot> flip s snd . (. fst) . s (flip . (((.) . (,)) .)) id
05:45:14 <wli> (I call this dup fzip f)
05:45:36 <wilx> thbot: @pointless \f x y -> (flip (flip f)) x y
05:45:36 <thbot> id
05:45:41 <wilx> Good.
05:46:46 <lightstep> wli: i thought fzip is (***)
05:47:18 <wli> lightstep: There are other conventions. I have a "zippable" class meant for different purposes.
05:47:52 <wli> (actually, they're Zip, Zip3, Zip4, etc.)
05:48:38 <wli> itty bitty bloated library of convenience functions
05:50:45 <TheHunter> they probably do about the same as this http://www.haskell.org/arrows/arrows/Control.Sequence.html or that http://www.haskell.org/pipermail/haskell/2004-July/014315.html
05:51:47 <TheHunter> wee, implicit parameters are convenient.
05:53:15 <wli> well, I have to confess, it's nowhere near as abstract as all that
06:16:04 <lightstep> is ghc still the largest haskell program?
06:18:45 <CosmicRay> hmm.
06:18:47 <CosmicRay> probably.
06:18:56 <CosmicRay> darcs is probably a good size too.
06:19:05 <Igloo> Why do you ask?
06:19:06 <CosmicRay> ghc is no doubt the most complex haskell program
06:19:23 * Igloo could quite easily make an arbitrarily large one, but it wouldn't be very interesting
06:20:13 <lightstep> it might be a base to a claim that haskell is unfit for large project
06:20:28 <lightstep> after all, ghc was the largest haskell program a decade ago, too
06:20:45 <lightstep> the extra complexity is put in it instead of in applications
06:21:22 <CosmicRay> lightstep: on the other hand, it might be an argument that haskell can solve difficult programs without requiring difficult solutions.
06:21:23 <Igloo> I wouldn't be surprised if the largest C program hasn't changed in a decade either
06:21:34 <CosmicRay> Igloo: what, Sun JVM? :-)
06:22:42 <Igloo> CosmicRay: I'm not sure how to interpret your smiley - are you saying the JVM is really the largest C program?
06:22:56 <CosmicRay> Igloo: no, I was just making a joke at Sun's expense
06:23:01 <CosmicRay> I don't know what the largest C program is
06:23:25 <CosmicRay> though I suspect the GNU Compiler Collection or somebody's kernel would be fair candidates
06:23:40 <lightstep> windows, perhaps
06:23:55 <Igloo> Or perhaps some part of office
06:23:58 <CosmicRay> Hasn't MS moved away from C as much as possible for a lot of their stuff?
06:25:23 <lightstep> the interface to the OS is in C, so while they could program it in C++, they probably didn't. and i guess that some of office is in VB
06:27:02 <TheHunter> lightstep, that's probably because the haskell community is so small. So all you'd be claiming is that Haskell is unfit for large projects because it's not very popular (yet, hopefully).
06:28:21 <lightstep> i just related some argument i heard to haskell. it didn't sound very convincing in the other formulation, too
06:30:55 <CosmicRay> lightstep: I think that anybody that takes a serious look at the language will conclude that haskell has a number of features that make it more scalable than most, and more reliable than most.
06:31:40 <kosmikus> the language might be reliable, but not necessarily the implementations
06:32:10 <lightstep> i have trouble with english. i meant that the argument was not about haskell, but if i changed some context-dependent words, it would apply to haskell
06:33:19 * shapr loves his LCD monitor.
06:33:27 <Cale> :)
06:33:27 <CosmicRay> true enough kosmikus.  however, experience has shown that ghc in particular is quite stable and reliable
06:33:33 <CosmicRay> shapr: ditto
06:33:40 <CosmicRay> shapr: I have a Dell 2001FP, IIRC
06:33:45 <CosmicRay> ad a 1701FP at work
06:34:00 <shapr> First time I've used an LCD monitor, and this is *so* much better!
06:34:17 <CosmicRay> I love my 2001FP.  20" LCD.  oh yeah.
06:34:28 <shapr> Anyway, looks like I've just dropped into an interesting discussion...
06:34:29 <CosmicRay> 8 xterms on a screen, all crystal-sharp :-)
06:35:02 <CosmicRay> 1600x1200 native resolution
06:35:31 <shapr> Oh hey, maybe I can increase my res
06:35:55 <CosmicRay> what size/model do you have?
06:36:06 <shapr> hyundai imagequest q17
06:36:21 * Igloo would't want something compiled with ghc running my life support machine
06:36:37 <shapr> Igloo: I would... at least I'd be able to debug it! =)
06:37:13 <kosmikus> CosmicRay: while this might be true, a few large Haskell applications /= ghc could certainly support this impression of yours
06:37:15 <CosmicRay> I'd prefer that to something written in c
06:37:28 <Igloo> Debug "Evacuated closure on the heap" with minutes to live? Rather you than me  :-)
06:37:31 <CosmicRay> heh
06:37:33 * shapr snickers
06:37:43 <CosmicRay> I'd prefer that to a sprintf bug
06:37:58 <CosmicRay> nice shapr
06:38:05 <CosmicRay> dell had a sale on the 2001FP.  I got it for $620
06:38:07 * shapr barks
06:38:25 <CosmicRay> normal price was about $850 at the time
06:38:38 <CosmicRay> it was the first time I got a new monitor since 1995, I think.
06:38:49 <shapr> My monitor is from around then also.
06:38:55 <shapr> Er, my old monitor.
06:39:02 <CosmicRay> I got the cheapest 21" I could find at the time.
06:39:05 <CosmicRay> set me back $1300.
06:40:15 * Itkovian recently bought a philips 17" ...
06:40:24 <Itkovian> and it was a 15" from 1996 before that
06:40:38 <shapr> I had no idea an LCD would be so much easier on the eyes.
06:41:23 <Itkovian> it _is_ a vast improvement.
06:41:35 <earthy> igloo: but you *would* want something written in C on your life support stuff?
06:41:38 * Itkovian only waited so he could play his games decently
06:41:46 <CosmicRay> shapr: it is amazing
06:42:19 <CosmicRay> Igloo: the way I think about it, I trust simon more than I trust random college interns at medical equipment manufacturers :-)
06:42:35 <Igloo> earthy: It wouldn't be my first choice, but if it was well written, perhaps with a correctness proof, I'd probably take it over a compiler I didn't trust
06:42:56 <Igloo> CosmicRay: But the same people would be writing the code regardless
06:43:06 <Igloo> It's Simon vs the gcc hackers you have to compare
06:43:32 <Igloo> Or rather their output - I don't mean to imply Simon is incompetent  :-)
06:44:14 <CosmicRay> Igloo: yes but ghc will catch more of their mistakes than gcc :-)
06:44:16 <CosmicRay> I hope
06:44:18 <CosmicRay> heh
06:44:55 <earthy> ghe
06:45:17 <earthy> `with a correctness proof'... methinks that'd be easier for a haskell compiler, if not GHC
06:52:55 <shapr> That SIGINT guy is an evil assassin.
06:53:16 <CosmicRay> yes, but I've managed to catch him once or twice.
06:53:24 <shapr> wow!
06:53:27 <CosmicRay> SIGTERM, though...
06:53:33 <CosmicRay> always escaped the cops.
06:53:39 <Itkovian> I prefer SIGKILL myself
06:54:16 <lightstep> i once saw an erotic story contest, with bones as the topic. the second place was named "minus nine", as in kill -KILL
06:54:28 <CosmicRay> heh
06:55:03 <shapr> That gets a very high score on the convoluted index.
06:56:48 <Oejet> Greetings.
06:56:50 <shapr> Anyway, I guess I should poke all the TMR authors to see if they'll be done in a week.
06:57:00 * shapr pokes Philippa_ 
06:59:15 <Philippa_> er. Maybe.
07:01:30 <kosmikus> shapr: I didn't get any more comments regarding tmr.cls; did you?
07:01:41 <Philippa_> er, where?
07:01:44 <shapr> Nope. I guess every loves it!
07:02:18 <kosmikus> I should try to spend another few hours on it today, though.
07:02:32 * Philippa_ hadn't heard anything'd actually been done, let alone been pointed at it
07:02:42 <Philippa_> oh, and do we have a standardised means of quoting code yet?
07:07:03 <shapr> Um, I think so.
07:07:10 <kosmikus> Philippa_: darcs get http://www.cs.uu.nl/~andres/TMR
07:07:57 <CosmicRay> kosmikus: 403
07:08:09 <kosmikus> Philippa_: no, no standard way to quote code for now; not even JFP does this, so I don't know whether TMR should try to force everyone
07:08:25 <kosmikus> CosmicRay: hmm, strange, I haven't touched it and it used to work ... let me check
07:11:07 <Igloo> Have you made any checkins since?
07:11:16 <Igloo> Things have a habit of setting the umask unhelpfully
07:12:08 <kosmikus> CosmicRay: ah, you mean the webpage ... true, I haven't installed darcs.cgi
07:12:27 <shapr> I could mirror the repo on ScannedInAvian.
07:12:56 <kosmikus> good idea
07:13:12 <CosmicRay> kosmikus: you shouldn't need darcs.cgi
07:13:15 <CosmicRay> it's just files in a dir.
07:13:31 <shapr> looking for the latest patch would need darcs.cgi
07:13:49 <shapr> or at least, easily checking the contents of the latest patch.
07:13:54 <shapr> Hm, maybe not.
07:14:05 <CosmicRay> shapr: but if you just want to see the current state of the files, nope
07:14:10 <shapr> Right, good point.
07:14:12 <CosmicRay> since a darcs repo is current state + history
07:14:16 <CosmicRay> it's a neat feature
07:15:02 <CosmicRay> bah, syntaxninja isn't here.
07:15:11 <CosmicRay> I guess cabalizing and packaging wash will have to wait
07:15:16 <kosmikus> CosmicRay: yes, I'll try to enable directory listing for this directory
07:15:18 <shapr> maybe he's just being a ninja and hiding.
07:15:21 <CosmicRay> heh
07:20:51 <kosmikus> CosmicRay: hmm, don't know how ... I get an internal server error on the directory if I try to enable directory listing
07:21:02 <CosmicRay> weird, well never mind
07:21:03 <CosmicRay> I can use darcs
07:21:48 <CosmicRay> hmm, is it a bad sign that wash includes warnings about using it with certain versions of ghc 4? :-)
07:22:24 * shapr snickers
07:27:19 <tmoertel> CosmicRay: I have made RPM packages of WASH. Is that what you wanted?
07:27:32 <tmoertel> (and i think that syntaxninja cabalized wash, too.)
07:27:33 <CosmicRay> tmoertel: no, .debs.  thanks anyway.
07:27:36 <CosmicRay> hmm
07:28:00 <shapr> Kinda weird they're not ians, ya know?
07:28:17 <Igloo> Syn was working on packaging WASH for Debian, but ran into stumbling blocks over its use of a .so IIRC
07:28:30 <Igloo> Sorry, I'm thinking of wxHaskell, ignore me
07:30:14 <tmoertel> I just check the logs: SyntaxNinja said (2005-02-13 05:13:47) "	yeah, I cabalized wash a while back as a test. i use wash2hs in my test suite actually"
07:30:30 <CosmicRay> huh.
07:30:33 <CosmicRay> ok I will ask him.
07:30:59 <shapr> Maybe gpg-signed .debs will be .ian
07:31:36 <CosmicRay> gpg-signed debs?
07:31:46 <CosmicRay> do you mean debsigs?
07:31:50 <shapr> er, ok?
07:31:52 <CosmicRay> (what's ".ian")
07:31:54 <Igloo> I don't think it'll work - it's just not as pronouncable
07:32:15 <shapr> CosmicRay: debra + ian = debian. foo.deb is an archive, why isn't foo.ian an archive?
07:32:21 <CosmicRay> heh
07:32:36 <CosmicRay> shapr: I wrote support to embed gpg signatures in .debs in 2000 or so
07:32:40 <CosmicRay> apt-get install debsigs
07:32:46 <shapr> Oh nifty. Does it work?
07:32:48 <CosmicRay> yes
07:32:51 <TFK> Isn't it "Deborah"?
07:33:02 <CosmicRay> I believe progeny still uses it
07:33:06 <shapr> TFK: could be.. I am sure about the "deb" part though =)
07:33:14 * TFK nods
07:33:21 <shapr> So, why isn't debsigs used now?
07:33:31 <CosmicRay> because the powers that be preferred repository signing
07:33:39 <CosmicRay> there are tradeoffs either way
07:33:50 <CosmicRay> .deb signing doesn't protect you against outdated .debs
07:34:01 <shapr> Well, I don't care as long as there is something that works.
07:34:08 <CosmicRay> otoh repository signing requires a host of files with correct versions to verify the validity of a given .deb
07:34:22 <shapr> Since apt-secure is only in experimental, I don't think my condition is met.
07:34:32 <CosmicRay> you can't just copy a .deb and give it to someone and expect repository signing to validate it
07:34:39 <shapr> er, why not?
07:34:56 <CosmicRay> because the recipient might not have an authenticated packages file mentioning that particular .deb
07:35:34 <shapr> But the Release file will be signed by a debian developer key, yes?
07:35:40 <CosmicRay> with signatures on the .debs themselves, one can verify at any point that it was part of the debian archive, or perhaps was part of a debian release.
07:35:51 <CosmicRay> shapr: sure, but the release file doesn't mention .debs directly.
07:35:55 <CosmicRay> it mentions Packages files.
07:36:06 <CosmicRay> which in turn mention the .debs in the repository at a particular point in time.
07:36:14 <CosmicRay> if you have a .deb from a different point in time, that system is useless.
07:36:27 <CosmicRay> since the Packages files may no longer refer to the same version of th e.deb
07:36:41 <shapr> Sooo, I can't do my bittorrent + spl thing with apt-secure?
07:37:00 <CosmicRay> no, you probably could.
07:37:22 <CosmicRay> in fact, it's probably the path of least resistance.
07:37:34 <shapr> Hm, ok then.
07:37:38 <ibid> shapr: there seems to be some activity trying to make 0.6 releasable for sarge (and it's not apt-secure, that's an obsolete probgram)
07:37:52 <shapr> ibid: I know, but I don't have a better name for it.
07:37:59 <ibid> apt 0.6 :)
07:38:03 <shapr> ok, fair enough
07:39:59 <Itkovian> @hawikie LicensedPreludeExts
07:39:59 <lambdabot> Sorry, I don't know the command "hawikie", try "lambdabot: @listcommands
07:40:04 <Itkovian> @hawiki LicensedPreludeExts
07:40:04 <lambdabot> Sorry, I don't know the command "hawiki", try "lambdabot: @listcommands
07:40:10 <Itkovian> eh?
07:40:14 <shapr> just @wiki
07:40:26 <shapr> salut mattam
07:40:34 <Itkovian> ah
07:40:36 <mattam> hi shapr
07:40:38 <Itkovian> well, I got it ...
07:40:51 <shapr> I should probably put a stronger warning at the top of PreludeExts
07:40:58 <Itkovian> why?
07:41:11 <Itkovian> it's clear to me
07:41:17 <shapr> Because, if you use code from PreludeExts in your own code, you can't legally release that code.
07:41:22 <shapr> But you can with LicensedPreludeExts
07:43:07 <Itkovian> hmm
07:43:16 <Itkovian> just take from the right page
07:43:20 <ibid> shapr: "the bsd license" is ambiguous
07:44:48 <Itkovian> I think the bsd license pretty much says you can do with it whatever you please, no?
07:45:23 <musasabi> depends whether it is the 3- or the 4-clause variant.
07:45:34 <musasabi> the 4-clause one may be evil.
07:46:52 <chip> it's harmless
07:47:09 <chip> the Regents have gone on record that they'll never enforce the advertising clause.
07:47:25 <CosmicRay> chip: but that doesn't apply to other people that apply 4-clause bsd to their work.
07:47:47 <chip> sure it does, because the fourth clause specificall names the Regents and/or UCB.
07:48:06 <musasabi> chip: no, people substitute their own name/organisation there...
07:48:21 <musasabi> chip: and then you have 50+ different 4th clauses.
07:48:35 <musasabi> and it doesn't look very good.
07:49:10 <chip> Well, you'd have to say it's not a BSD license any more, wouldn't you?
07:49:25 * chip growls at the stupidity of humans, including the lawyer variety
07:51:13 <shapr> It's only the selfish variety that attempts to screw others out of money/property/etc that irritate me.
07:52:32 <chip> shapr: If you'd been brainjacked by a cult, you'd be more leery of the altruistic ones.
07:53:41 <chip> "Men never do evil so completely and cheerfully as when they do it from religious conviction." - Blaise Pascal
07:53:50 <shapr> I've always viewed Christianity as being much closer to the Fivefold Path of Righteousness than some other people.
07:54:17 <chip> shapr: your sampling methodology needs work
07:54:44 <shapr> ?
07:55:52 <shapr> Suffice it to say that I'm a Baptist, and I do see great similarities to the Fivefold Path. And maybe we should drop it there :-)
07:55:53 <chip> shapr: soi-disant "Christianity" is a big field.  There's good, but by and large it's hardly something the Buddha would approve of, AFAICT
07:57:04 <shapr> I think the Fivefold Path is much more a Debian-oriented approach, give freedom to the user. Some other systems are more like GNU, which like enforcing freedom on others.
07:57:19 <shapr> Of course, I've probably just offended everyone in the channel at once =)
07:57:56 * shapr partially applies himself to a can of energy drink
07:59:10 <shapr> chip: So, written any Haskell code lately?
07:59:49 <chip> shapr: No, I really haven't learned to read it yet.
08:00:33 <chip> shapr: I'm used to C and Perl and the like; the lack of punctuational cues is disorienting.  And the occasional variable name with apostrophe doesn't help. :-,
08:01:55 <CosmicRay> shapr: how does Wash manage to make this be valid Haskell source:
08:02:01 <CosmicRay> mainCGI =
08:02:01 <CosmicRay>     ask  <html>
08:02:01 <CosmicRay>            <head><title>Hello World</title></head>
08:02:01 <CosmicRay>            <body>
08:02:01 <CosmicRay>            <h1>Hello World</h1>
08:02:02 <CosmicRay>            </body>
08:02:04 <CosmicRay>          </html>
08:02:07 <CosmicRay> I truly have no clue how ghc is able to parse that.
08:02:55 <tmoertel> there is a preprocessor, i believe
08:03:00 <CosmicRay> I am not using it.
08:03:14 <CosmicRay> ghc -package WASH -package haskelldb -fallow-overlapping-instances -fallow-undecidable-instances -c -o register.o register.hs
08:03:16 <ibid> < and > are operators?
08:03:19 <tmoertel> there is magic, i believe :)
08:03:24 <ibid> that's how i'd assume
08:03:38 * tmoertel goes roaming thru the sources
08:03:40 <CosmicRay> ibid: they are their standard comparisons
08:03:44 <ibid> no idea though
08:03:55 <ibid> CosmicRay: in that context?
08:03:59 * chip mumbles "source filter" from Perl land
08:04:29 <CosmicRay> ibid: as far as I can tell, yes
08:04:44 <Igloo> There a preprocessor specified in the package.conf
08:04:47 <CosmicRay> ah.
08:04:52 <CosmicRay> sneaky.
08:05:03 <ibid> a < > overloading would've been cool
08:05:11 <CosmicRay> Igloo: thanks igloo.
08:05:26 <ibid> like the c++ library that allows you to write c++ so that it looks almost like haskell
08:05:33 <Igloo> <foo> <bar> is a parse error, though
08:07:37 <chip> ibid: what, you mean STL?  STL is what happens when people get high, write a spec, then accidentally mail it to their boss so they have to implement and release it
08:07:37 <tmoertel> here is the magic conf stuff: extra_ghc_opts = ["-F","-pgmF","/usr/bin/wash2hs"]
08:08:32 <ibid> chip: no, i don't
08:10:18 <ibid> chip: stl code looks nothing like haskell
08:13:20 <shapr> chip: so, think you'll have time to play around with Haskell soon?
08:13:30 <shapr> chip: have you looked at Pugs?
08:13:52 <shapr> hiya syntax_syntax
08:14:06 <shapr> are you from june of 1944?
08:17:06 <shapr> basti_: this looks really cool
08:17:13 * shapr is reading basti_'s TMR article.
08:17:46 <shapr> peace lightstep
08:18:03 <lightstep> happiness to all
08:18:37 <lightstep> except smbd
08:18:37 <shapr> How's code?
08:18:42 * shapr grins
08:19:15 <shapr> So you're saying that's SadoMasochismBondageDegradation?
08:19:34 <lightstep> almost
08:21:10 <lightstep> it seems utime gets EIO. which disturbs both lyx and touch
08:29:35 <basti_> shapr: thanks
08:30:19 <basti_> shapr: did you listen to it as well? ;)
08:33:12 <basti_> smbd is a great piece of software. compare sendmail.
08:43:56 * lightstep doesn't like X very much, either
09:00:32 <CosmicRay> is anyone aware of any work regarding integrating authentication (http auth preferable) with Wash?
09:00:37 <CosmicRay> google is not helping me
09:01:11 <shapr> Did you look at the wash shop already? Doesn't it do that?
09:01:24 <CosmicRay> got a url for that?
09:01:40 <shapr> it's one of the demos
09:01:55 <shapr> look at TinyShop and TinyShopXX
09:02:00 <shapr> or something like that.
09:03:13 <CosmicRay> well, it does have a login box
09:03:16 <CosmicRay> but it doesn't do HTTP auth
09:03:59 <CosmicRay> wash looks so nice but it's very under-documented
09:18:06 <TheHunter> yay! the weirdest piece of haskell code i've ever written seems to work (at least under some very special circumstances)
09:19:20 <basti_> -g-
09:20:04 <TheHunter> the special cirumstances are: ghc (no ghci), -fno-pre-inlining, no optimization.
09:20:40 <basti_> at least the circumstances are not data-dependant huh
09:21:05 <samc> huh? doesn't that indicate a bug in the optimisation?
09:21:10 <TheHunter> it's not perfectly clear yet.
09:21:37 <TheHunter> samc, the code uses unsafePerformIO, unsafeCoerce# and linear implicit parameters.
09:21:53 <samc> I see
09:22:15 <samc> yuck :p
09:22:27 <TheHunter> so i can start with the next step: trying to implement filinski's reflect+reify.
09:26:30 <samc> is that that 'reflective tower' lisp stuff?
09:28:09 <boegel> hey everyone
09:28:14 <basti_> hi boegel
09:28:22 <boegel> shapr: how's TMR going ?
09:28:36 <TheHunter> no, it's about reflecting monads. reflect :: (Monad m, ...) => m a -> a
09:28:39 <shapr> boegel: it's hoppin
09:28:44 <TheHunter> reify :: ... => a -> m a
09:28:46 <TheHunter> hey boegel
09:28:52 <boegel> shapr: any articles in yet ?
09:29:35 <samc> oh, I was thinking that must be some weird code :)
09:29:42 <shapr> Yup, I've read non-final content from basti_, Philippa_, pseudonym, and swiert. Maybe others too.
09:29:51 <boegel> nice
09:30:01 <boegel> I'll work on mine tonight and tomorww+day after
09:30:04 <shapr> spiffy.
09:30:07 <boegel> when's the deadline ?
09:30:11 <samc> you have maybe read some by others?
09:30:20 <shapr> Content should be in my inbox or darcs repo by mondey.
09:30:22 <shapr> monday
09:30:32 <TheHunter> samc, you can usually only do that if your language has call/cc.
09:30:53 <boegel> monday.. ok, should be no problem :)
09:31:01 <shapr> Oh, from Alistair Bayley as well. That's going to be an interesting article.
09:31:03 <boegel> shapr: any idea's for a nice, simple GUI ?
09:31:13 * shapr thinks
09:31:16 <Philippa_> what's he writing about?
09:31:30 <shapr> Philippa_: FP vs OO, remember I was asking you about OO consumer?
09:31:35 * Philippa_ nods
09:31:37 <basti_> shapr: say, is it a good idea to send you my patches like I did?
09:31:37 <boegel> a calculator seems a bit foolish...
09:31:44 <shapr> boegel: why?
09:31:53 <boegel> shapr: too common as an example
09:32:11 <shapr> basti_: patches should go to the repo and be applied, but yours are bouncing. That usually means I did something wrong.
09:32:27 <basti_> you mean I can do it from here?
09:32:29 <Philippa_> do a spreadsheet?
09:32:34 * samc is waiting for 1:00PM EST
09:32:42 <Philippa_> should be quick/interesting to do in Haskell
09:32:46 <shapr> basti_: sure yeah, are you sending your patches to basti@ScannedInAvian.org ?
09:32:59 <basti_> uhm that was the default
09:33:05 <basti_> i thought that was wrong
09:33:16 <shapr> Well, try it.
09:33:26 <boegel> Philippa_: hmm.. but I would like to use a 'image' aspect too
09:33:32 <basti_> i'd need to send it there and sign it huh?
09:33:37 <shapr> yup, darcs send --sign
09:33:49 <shapr> If it worked, it'll show up here - http://www.scannedinavian.org/cgi-bin/darcs.cgi/basti/?c=browse
09:33:53 <shapr> You even have an RSS feed!
09:33:55 <Philippa_> boegel: graphs? :-)
09:34:17 <shapr> boegel: what about a nuclear reactor? =)
09:34:32 <basti_> hmm i just sent it, but it doesnt show up yet. maybe there's a delay huh
09:34:42 <shapr> Or maybe it bounced cuz I screwed up something.
09:34:43 <boegel> shapr: lol
09:34:58 <boegel> maybe an image-calculator...
09:35:09 <boegel> or something like that
09:35:11 <boegel> dunno :)
09:35:22 <basti_> i mailed it to you after seeing that the default ad is basti@... because I thought that was a wiser idea.
09:36:00 <shapr> Yeah, it bounced. Lemme see what I did wrong...
09:36:06 * basti_ nods
09:37:35 <shapr> aha
09:38:04 <TheHunter> reify t = reset (return t) doesn't seem to do it :(
09:38:15 <shapr> gpg: CRC error; CC87BA - DC3CC8 \n gpg: quoted printable character in armor - probably a buggy MTA has been used
09:38:23 <basti_> =)
09:38:40 <basti_> dang.
09:39:11 <basti_> i'm using ssmtp. MTA's are above my patience/skill ratio usually.
09:39:11 <shapr> If you look at the bottom of the mail sent it has =3D in two places.
09:39:27 <basti_> hmm I'll have a look
09:40:21 <Igloo> Is the receiver using darcs 1.0.1?
09:40:42 <basti_> enigmail gives me "Signature Mismatch" to
09:40:42 <basti_> o
09:41:19 <basti_> i see the 2 =3d
09:41:38 <basti_> so where do they come from, and how can i get rid of them?
09:41:42 <Oejet> shapr: I read some thoughts on email, that I know you also thought about: http://www.deronyan.com:8080/welcome/?q=node/view/45
09:42:42 <shapr> Yeah, RSS for email is a nice idea.
09:43:00 <shapr> central server won't work
09:43:13 <shapr> basti_: either your email client or your server is encoding them using base64
09:43:15 <shapr> I dunno which
09:43:26 <basti_> hmmmm
09:43:33 <Igloo> If this is darcs it's meant to
09:43:56 <shapr> Igloo: the gpg sig should have chars base64 encoded?
09:44:34 <Igloo> I'm not sure which way round it is, but this sounds like the bug in darcs 1.0.1 to me
09:44:50 <basti_> i do have 1.0.1
09:45:09 <shapr> 1.0.2 is in debian/unstable.
09:45:20 <Igloo> It's the receiver who needs 1.0.2
09:45:26 <basti_> i use testing.
09:45:31 <shapr> oh, I have 1.0.2 installed.
09:46:22 <Igloo> Hmm, shouldn't be that then
09:46:31 <shapr> Oejet: SPF and im2000 are both simpler than this system. In any case, a central server recording all emails just won't work.
09:46:52 <shapr> Oejet: thanks for pointing me to it, I enjoy seeing the ideas of others :-)
09:47:13 <Oejet> shapr: No problem.
09:47:24 <shapr> The good part of this idea is the staged by person email stuff.
09:47:51 <shapr> But that could be more easily done with a pull-only news system. Sort of...
09:48:29 <basti_> I'll upgrade darcs, and when it doesnt fix the problem, i will dig a bit
09:49:05 <basti_> isnt there a "MUST NOT modify" clause in the Email RFC?
09:49:27 <basti_> or does this just count for servers?
09:49:34 * shapr doesn't remember
09:50:29 <shapr> The Register is king of vicious headlines "MS: We are not blackmailing Denmark"
09:50:50 <Oejet> Yeah, read the original Brsen article.
09:50:56 * Oejet shivers.
09:51:06 <Lemmih> url?
09:51:10 <Oejet> Big corps are 3v1l.
09:51:21 <shapr> Where does a 400 kilo gorilla sit? Anywhere he wants.
09:51:21 <Oejet> Per definition.
09:51:27 <shapr> Lemmih: http://www.theregister.co.uk/2005/02/15/ms_patent_denmark/
09:52:57 <TheHunter> haha, it works: reify (reflect [1,2] + reflect [3,4]) ===> [4,5,5,6]
09:53:14 <basti_> huh?
09:54:49 <shapr> ozone: hey! Annodex made slashdot! congratulations!
09:55:05 <TheHunter> it's an evil hack using linear implicit parameters, but yay! (add instance DeepSeq (m a) to the list of requirenments)
09:55:30 <shapr> TheHunter: Where will you be publishing this? Next TMR? Or next IOHCC?
09:55:54 * shapr grins evilly
09:56:28 <TheHunter> it's more like IOHCC, but if I can drop the evil requirenments, i might consider TMR.
09:57:29 <TheHunter> is there a way to fully evaluate something (i.e. catch all exceptions that are lying aroung) in the IO monad?
09:57:33 <basti_> slasso what do reify and reflect do?
09:57:40 <basti_> wah.
09:57:43 <basti_> s/slas//
09:57:52 <TheHunter> reflect :: (Monad m, %ans :: Shift (m b)) => m a -> a
09:57:58 <TheHunter> reify :: (Monad m, DeepSeq (m a)) => ((%ans :: Shift (m a)) => a) -> m a
09:58:18 <TheHunter> reflect is like unsafePerformIO for arbitrary monads.
09:58:21 <basti_> o0
09:58:27 <shapr> Sounds terrifying.
09:58:38 <basti_> oooh i think i see
09:58:43 <TheHunter> you can do that in scheme or sml using callcc.
09:59:00 <basti_> isnt that this exception like thingy?
09:59:25 <TheHunter> yes, it's much more powerful, though.
10:00:29 <basti_> yes it passes a value.
10:00:43 <basti_> and its not obscene to use it because of that.
10:01:46 <TheHunter> i think it's impossible to implement anything like call/cc in Haskell.
10:02:10 <basti_> hmm. I've never digged deep enough into it to be able to tell
10:02:11 <esap> thehunter: with continuation passing transformation, I think it's possible.
10:02:23 <lightstep> i thought that in the context of one expression, shift&reset are equivalent to call/cc
10:02:28 * esap means CPS.
10:03:18 <TheHunter> lightstep: it's possible if you're allowed to replace main.
10:04:24 <TheHunter> esap, like callCC :: ((a -> IO b) -> IO a) -> IO a ?
10:04:40 <esap> TheHunter: Yes.
10:05:36 <TheHunter> hmm, how?
10:06:34 <lightstep> howcomes fortran has features haskell hasn't
10:06:37 <lightstep> ?
10:06:59 <shapr> like loops?
10:07:23 <esap> TheHunter: Hmm.. isn't there actually implementation of callCC in Control.Monad.Cont (if you look at the lib source?)
10:07:50 <TheHunter> yeah, but that doesn't live inside the IO monad.
10:07:54 <shapr> lightstep: loops aren't necessary in Haskell.
10:08:19 <lightstep> like COME FROM
10:08:37 <shapr> good point, Haskell does need COME FROM.
10:08:39 <TheHunter> esap, you can use ContT r IO, of course, but then you don't have unsafePerformIO for your monad.
10:08:58 <TheHunter> what does COME FROM do?
10:09:13 <shapr> It's the other end of GOTO.
10:09:21 <lightstep> when control hits the specified label, it jumps to the "come from" instruction
10:09:31 <esap> TheHunter: right. ContT r IO supports MonadIO, is that not enough?
10:09:50 <TheHunter> not enough to implement the reflect and reify I mentioned.
10:11:08 <samc> how would you use come from in haskell?
10:12:05 <lightstep> maybe cocontinuations?
10:12:19 <esap> TheHunter: The callCC implementation doesn't actually rely on anything but lambda abstractions and function calls. What's the type if you just leave out the wrapping from the monad?
10:13:36 <esap> TheHunter: you'll get a function with type: ((t3 -> t1 -> t2) -> (t3 -> t2) -> t) -> (t3 -> t2) -> t
10:13:49 <esap> TheHunter: for callCC.
10:13:52 <Lemmih> shapr: Haskell _does_ need COME FROM?
10:14:05 <TheHunter> esap, it's clear that Control.Monad.Cont.callCC can't implement my reflect+reify because it's pure.
10:17:15 <shapr> Lemmih: don't you think COME FROM would add expressive power to Haskell?
10:17:38 <tic> bleh, stupid bnfc/haskell. :(
10:17:42 <esap> TheHunter: From your type, I would expect that reflect would be implemented by some kind of interpreter for some very abstract datatype.
10:17:50 <shapr> Should I give up now and mention that COME FROM is actually an Intercal instruction?
10:18:19 <samc> heh
10:18:36 <basti_> we need 2d haskell.
10:18:52 <basti_> what am I saying. 2d lambda calculus!
10:19:01 <samc> why only 2?
10:19:06 <shapr> I've been trying to port lambda calculus to IceHouse pieces... without much luck.
10:19:16 <TheHunter> esap, it's implemented using the IO monad's exception handling + unsafePerformIO + unsafeCoerce#
10:19:20 <basti_> k-dimensional lambda calculus!
10:19:55 <lightstep> but why with a cartesian system? let's represent LC as graphs
10:20:14 <shapr> I can't find a really fun and expressive way to do lambda calculus with IceHouse pieces.
10:20:14 <tic> http://rafb.net/paste/results/lXmU3P36.html <-- anyone got a clue?
10:20:41 <esap> TheHunter: That makes sense [That's how I implemented the control operation, which is very closely related to reflect/reify]
10:20:43 <TheHunter> tic, not without any code.
10:21:06 <shapr> tic: sounds like ts is wrapped in the error monad, but requires a more general type than Err Prog
10:21:32 <TheHunter> esap, hehe, does the implementation of the control operation use linear implicit parameters, too?
10:21:36 <Lemmih> shapr: I don't think introducing GOTOs in Haskell is a good idea.
10:21:39 <esap> TheHunter: But when you go to an interpreter, you'll probably get much improvement in simplicity. The control operation I implemented in an interpreted proved out to be just swapping the context and the input.
10:22:02 <tic> shapr, crap. I've basically done a copy-paste of some other guy's code.
10:22:21 <shapr> Lemmih: On the other hand, TheHunter and esap are discussing really smart GOTOs right now :-)
10:22:23 <tic> shapr, typecheck :: Prog -> IO (). same as putStrV
10:22:32 <TheHunter> esap, not only simplicity, also reliability.
10:22:36 <tic> shapr, or well, putStrV is String -> IO ().
10:22:56 <shapr> tic: copy-paste bad!
10:23:10 <TheHunter> the point was to bring maximally impure programming into haskell.
10:23:14 <tic> shapr, well, it was really only one line. :) (typecheck tree)
10:23:29 <esap> TheHunter: actually, with one use of unsafeCoerce# (you couldn't pass information into the swapped continuation without unsafeCoerce#.
10:23:41 <tic> shapr, either way; my conclusion is that Haskell suxx0rz.  Any suggestions on I'd go about lifting out Prog out of Err or whatever?
10:23:51 <shapr> Not until you apologize to Haskell :-P
10:23:58 * shapr snickers
10:24:17 <shapr> But seriously, I can't help if I can't see the code.
10:24:23 <TheHunter> esap, pretty much the same here.
10:24:28 <shapr> Also, I should really be working instead of chatting.
10:24:29 <esap> TheHunter: eval_counit (TControlAdj _) ctxtype = ContEvalA (\cont -> proc (Minus eit cont') -> case eit of { Left a -> cont' -<< (unsafeCoerce# a) ; Right b -> cint -< b)   is my implementation of control operation.
10:24:44 <shapr> what the heck is -<< ?
10:24:51 <esap> shapr: arrow notation
10:24:52 <tic> shapr, it's a bunch of code, that's the problem.. I'll try to paste..
10:25:05 <esap> shapr: for ArrowApply.
10:25:08 <shapr> ohh
10:25:37 <TheHunter> cool, i didn't know such a notation existed.
10:25:40 <esap> TheHunter: actually, s/cint/cont/
10:26:42 <TheHunter> now, if only there were a way to fully evaluate something without DeepSeq.
10:27:05 <esap> TheHunter: interpreters.
10:27:36 <esap> Though it's kind of cheating :-)
10:27:46 <tic> shapr, http://rafb.net/paste/results/eBaYle64.html
10:29:17 <lightstep> where is the offending case?
10:29:23 <shapr> tic: do you have this all in the same file?
10:29:46 <tic> shapr, no, different files.
10:29:50 <shapr> ok, just checking =)
10:29:57 <glimming> Can somebody give me an example of something that gets more efficient if we built a reversed datastructure while computing something, e.g. opitimisation problem, some list algorithm, etc?
10:30:19 <shapr> What do you mean by a reversed datastructe?
10:30:28 <glimming> random access sort of
10:30:37 <tic> shapr, so, what's wrong? ;)  I mean, typecheck is of type IO, and "OK tree" should lift out "tree" from the Err monad so I should be safe to give it to typecheck. Right
10:30:37 <glimming> we need access to some randomly chosen preceeding value
10:30:39 <tic> ?
10:31:03 <esap> glimming: how about anything that needs a doubly-linked list?
10:31:16 <glimming> esap: great, can you suggest something?
10:31:33 <glimming> what would need dll?
10:31:33 <shapr> Are you talking about something like using the zipper for tree editing?
10:31:39 <glimming> sure...
10:31:53 <glimming> But I have a different approach I hope.
10:32:02 <TheHunter> yay! I don't need -fno-pre-inlining anymore.
10:32:28 <glimming> Any enthusiast who want to port a C thingie to a Haskell thingie? Thingie=small programming language
10:32:36 <esap> glimming: Well simulate turing machines, with the doubly-linked list as a representation for the tape?
10:32:44 <shapr> tic: where does the error happen?
10:32:44 <glimming> Sure...
10:32:54 <shapr> hiya grv, looking for Haskell info?
10:33:03 <grv> yeah
10:33:04 <glimming> esap: is there no well-known algorithm, like list algorithm?
10:33:43 <glimming> or optimisation algorithm that memoizes etc
10:33:50 <tic> shapr, in run.
10:34:04 <tic> http://rafb.net/paste/results/lXmU3P36.html
10:34:10 <shapr> tic: I think the type of myLexer is your problem.
10:34:16 <tic> shapr, m'kay.
10:34:22 <tic> Ugh. Thanks.  Maybe if I remove the type sig.
10:34:23 <xerox> hi.
10:34:50 <shapr> grv: any particular info?
10:35:21 <glimming> it is rather easy to simulate subtyping in Haskell...
10:35:59 <glimming> data f o = Somedata (a o,b o,c o, f o)    where f is a "more" type constructor (row variable?)
10:36:33 <grv> no particular info thanks...just starting to play with haskell
10:39:16 <shapr> grv: ok, if you have questions feel free to ask them here.
10:39:39 <grv> thanks shapr.
10:40:35 <shapr> lightstep has a cute sense of humor. Suggesting COME FROM as an addition for Haskell is way nifty.
10:40:36 <esap> glimming: Hmm.. maybe unification when your language has powerful operations to manipulate the context, I think the context is your reversed data structure.
10:42:55 <glimming> easp: that's nice!
10:53:59 <Lor> Evening, folks.
10:54:11 * Lor just read Claessen's parallel parsing pearl, and it's pretty... wow.
10:55:16 * Lor got five issues of JFP in the mail yesterday. Some reading. :)
10:55:27 <shapr> How do you afford JFP?
10:55:41 <Lor> By having a job.
10:56:14 <Lor> It's not _that_ expensive, 56.
10:56:46 <shapr> 180 pounds? - http://uk.cambridge.org/journals/journal_catalogue.asp?mnemonic=jfp
10:57:29 <Lor> If you click on "full pricing", there's the special 60 price for ACM members.
10:58:15 <Lor> And anyway for individuals it's 75 even without discounts.
10:58:51 <shapr> Still more expensive than my Science News weekly.... but possibly worth it.
10:59:21 <Lor> Well, most of the stuff is of course available online.
10:59:38 <Lor> But still. I may well be the only individual in this country who subscribes to it.
10:59:47 <Lor> There is only one academic institution that gets it.
10:59:55 <Lor> (Or used to get, not sure if it does any more.)
11:02:57 <shapr> I sort of wish Science News would skip the hardcopy and give me an online-only subscription, with the option to save an article locally.
11:03:36 * Lor likes hardcopies.
11:04:04 <Lor> If you want to look up an article, an online version is just fine. But one doesn't _browse_ online papers.
11:04:29 <Lor> With a paper journal, you can just have a glance at articles and you may end up discovering something that you wouldn't have read otherwise.
11:06:29 <ibid> indeed
11:06:50 <ibid> there is nothing better than spending an evening between library's bookshelves :)
11:07:03 <basti_> uhm.
11:07:18 <ibid> just browsing
11:07:36 <basti_> what about women?
11:08:12 <shapr> He didn't say anything about books...
11:08:24 <basti_> indeed.
11:08:31 <ibid> libraries do not discriminate based on gender :)
11:08:39 <ibid> at least, not here
11:08:44 <ibid> women can browse too
11:08:47 <ibid> :)
11:08:48 <shapr> I go to libraries to look at women. Smart women are sexy.
11:09:16 <ibid> i see those in the hallways quite enough :)
11:09:36 <basti_> sadly we have a cs-specific library
11:09:49 <Muad_Dibber> meaning not much women eh basti_  :)
11:09:52 <glimming> Is there any difference between a stream and infinite list?
11:09:54 <basti_> yup
11:10:11 <ibid> glimming: streams can be finite
11:10:34 <glimming> Hi Lor, what's up? Who are you? ;-)
11:10:55 <glimming> sure...
11:10:59 <glimming> but they are codata
11:11:24 <glimming> i.e. coalgebraic datatypes
11:11:41 <Lor> Golly, how does one answer a question like that?
11:11:54 <glimming> Or am I confused? Lazy lists play a role here too?
11:11:58 * Lor is reminded of the koan in GEB: you cannot call a stick a stick, but you cannot not call it a stick either.
11:13:05 * shapr calls Lor a stick
11:13:10 <shapr> Lor: stick!
11:14:32 <int80_h> hi haskell people :)
11:15:07 <shapr> hello interrupt 80
11:15:29 * basti_ excepts int80_h 
11:15:49 <tintin> hello int80_h are you an assembly language programmer or fan ?
11:16:05 <int80_h> just a fan
11:16:15 <int80_h> I like the avr instruction set these days.
11:16:25 <int80_h> when I made the name I only knew about x86
11:16:44 <basti_> avr's are cute
11:16:49 <int80_h> yes they are :)
11:16:58 <int80_h> have you seen the butterfly?
11:17:00 <Lor> What's avr?
11:17:09 <basti_> systems-on-a-chip
11:17:11 <int80_h> it's a microcontroller from atmel
11:17:12 <basti_> no i havent
11:17:18 <Lor> Isn't everything a system on a chip nowadays?
11:17:20 <int80_h> ah the butterfly is self contained
11:17:26 <basti_> my gf's father works at atmel btw. ;)
11:17:37 <int80_h> all you need is a serial cable and the atmel development system and you are good to go
11:18:01 <Lor> Wonder how long it takes before motherboard chipsets get integrated in the processor.
11:18:07 <int80_h> basti_ we must become friends, I want to find a way to get an internship when I am ready. :)
11:18:11 <Lor> In desktop machines, that is.
11:18:20 <basti_> well with the old ones it was a sub9 connector, some cable, a capacitor and you were ready to go too
11:18:22 <int80_h> atmel is on my list of highly desirable internships
11:18:31 <basti_> int80_h: it's in Heilbronn though
11:18:39 <int80_h> oh heh
11:18:45 <int80_h> I forgot they were international
11:18:51 <int80_h> I keep thinking of them as a local company
11:18:57 <basti_> =)
11:19:29 <int80_h> oh well I skipped one detail basti, you have to solder a little bit on the butterfly to talk to it.
11:19:32 <int80_h> but that's all
11:19:43 <int80_h> it has it's own led, and several input devices
11:20:00 <basti_> its an experimental board.
11:20:36 <int80_h> well, the copy claims you can use it for real prototyping, and you can use it as a module with other boards...
11:20:43 <int80_h> but I don't know from experience
11:20:46 * basti_ shrugs
11:21:22 <int80_h> something like haskell would be an interesting language for the butterfly
11:21:34 <basti_> oh.
11:21:34 <int80_h> I see java compilers, bleah
11:21:40 <basti_> yes. ugh.
11:21:44 <int80_h> why not haskell or a functional language?
11:21:55 <int80_h> I mean *some other* functional language
11:21:58 <basti_> hmm good question.
11:22:22 <basti_> i think its hard to do on "fixed program" systems isnt it?
11:22:31 <basti_> you would need an interpretation layer
11:22:37 <int80_h> I am too naive to know for sure
11:22:47 <int80_h> you would, I thought haskell had compilers?
11:22:57 <basti_> no i mean
11:23:14 <int80_h> so would it not be a simple matter of the compiled code being expressed as the instructions of the target machine?
11:23:17 <int80_h> oh go on
11:23:17 <basti_> if the code of your system is fixed (as in ROM), then you'd have to have an interpreter in that ROM to read the program
11:23:44 <Lor> If the program is fixed, why not compile it to the native language of the processor?
11:23:51 <int80_h> well if you can write a haskell compiler, you can have the compiler target the avr machine
11:24:04 <int80_h> lor, people do but they also want other languages
11:24:21 <basti_> i'm sure, but i'm not sure that the reducer would fit into the 1k words of a typical atmel processor =)
11:24:22 <Lor> Huh? How is this relevant?
11:24:32 <int80_h> java seems to be in vogue. So I am suggesting that haskell could target another instruction set besides x86
11:25:01 <int80_h> well not relevant, just me dreaming of porting an interesting language to a machine I like alot.
11:25:11 <basti_> i think the main problem would be a large offset of program size
11:25:12 <Lor> Haskell is kind of heavy on the resources.
11:25:24 <Lor> Requires a nontrivial runtime.
11:25:37 <int80_h> hmmm
11:25:53 <basti_> i think a lisp interpreter should be possible
11:26:04 <int80_h> lisp is alot larger than haskell right?
11:26:18 <int80_h> or no?
11:26:18 <basti_> a basic lisp runtime is tiny.
11:26:21 <ibid> depends on what lisp
11:26:32 <int80_h> oh, I only know about common lisp
11:26:33 <basti_> of course most lisp systems include far more than the runtime system
11:26:57 <int80_h> you wouldn't need a runtime system if you can compile to native instruction set
11:27:15 <basti_> you can't with most processors.
11:27:19 <musasabi> those are orthogonal issues.
11:27:33 <int80_h> basti_ say again...can't what?
11:27:43 <musasabi> you can compile to native and still need a runtime system.
11:27:48 <musasabi> many lisps are like that.
11:27:55 <basti_> you can't compile a functional program to the "native" language of most processors
11:28:02 <int80_h> oooh
11:28:11 <basti_> but then again, the distinction "native"/"not native" is artificial
11:28:34 <basti_> so in a sense, you can compile a functional program to the "native" language of any given Tu-Complete machine
11:28:42 <int80_h> well I thought native instruction set was what was decribed in the manual of a given machine
11:29:03 <basti_> yes but this rarely includes "lambda", for example
11:29:44 <int80_h> ouch my head hurts just thinking about that :)
11:30:08 <basti_> but then, there is microcode
11:30:18 <int80_h> go on
11:30:19 <Lor> basti, in what sense?
11:30:20 <basti_> -g-
11:30:50 <basti_> well today processors have a RISC core and emulate a CISC
11:30:57 <int80_h> avr is pure risc
11:31:07 <basti_> i wouldnt call them risc. ;)
11:31:14 <int80_h> 8-bit instructions for most machines, some more.
11:31:23 <basti_> but in a sense, they are, since they dont use microcode.
11:31:28 <int80_h> oh well the manual says RISC.
11:31:32 <basti_> yes it does i know
11:31:42 <basti_> R stands for reduced.
11:31:43 <int80_h> I have no other way to judge, is how little I know.
11:31:51 <basti_> there are processors that have 16 instructions.
11:31:59 <Lor> Anyway, why couldn't you compile functional languages to these?
11:32:06 <basti_> of course you can.
11:32:10 <int80_h> Lor: this is my question :)
11:32:10 <wli> I should point out here that the "ISC" portions of the acronyms refer to the program-visible instruction sets, not the microarchitecture.
11:32:32 <wli> Pipelined, superscalar, etc. refer to the relevant properties of the microarchitecture.
11:32:41 <basti_> but with said disadvantages (runtime, complication with read-only program memory)
11:33:01 <int80_h> the butterfly has programmable ROM
11:33:10 <int80_h> which is easily erased
11:33:20 <Lor> It's not ROM then. :)
11:33:27 <basti_> if you have only 1k words, then its hard to bring in both your runtime and your program.
11:33:35 <int80_h> well the code stays in even when you shut the power down
11:33:48 <basti_> its EEPROM.
11:34:04 <Lor> If you have a small enough program, the compiler might be able to elide the runtime completely.
11:34:34 <basti_> it will have a hard time, though ;)
11:34:52 <int80_h> well maybe this is outside of the problem domain for haskell
11:35:02 <int80_h> but my line of thinking was this
11:35:09 <Lor> A GC doesn't need to be big.
11:35:28 <int80_h> if a bloated language like java can fit on an AVR, why not something elegant like HASKELL?
11:35:40 <basti_> java isnt bloated. haskell isnt too.
11:35:48 <basti_> java is verbose, ugly and stupid.
11:36:06 <int80_h> ah where you say verbose I say bloated, I think we mean the same thing.
11:36:28 <basti_> but if you write "i++" in java it translates to "inc $0485" in assembler
11:36:29 <esap> Java libraries are bloated :-)
11:36:33 <basti_> or something along that line
11:36:54 <int80_h> and we don't do increments in haskell, form what I understand
11:36:58 <int80_h> I just read a tutorial
11:37:03 <basti_> if you do "inc n = n+1" in haskell, what would it translate to in assembler?
11:37:16 <int80_h> it has to translate to something
11:37:34 <Lor> Quite possibly to "inc $0485" :)
11:37:35 <int80_h> you couldn't run haskell anywhere if there wasn't an instruction to do it
11:37:36 <wli> There's a bit of runtime involved for this.
11:37:38 <basti_> some value in ram, sure
11:37:50 <basti_> and somewhere there's an "inc"
11:37:56 <Lor> ghc would unbox the integers.
11:38:06 <Lor> A tail call would reuse the registers.
11:38:20 <basti_> what if you use "inc" as an argument to another function?
11:38:32 <basti_> (which is the point of functional programming)
11:38:35 <Lor> Depends on what kinds of optimizations the compiler applies.
11:38:38 <Lor> It could inline it.
11:39:00 <basti_> it COULD. ;)
11:39:33 <basti_> but it would need some handle for the function itself in the general case
11:39:43 <basti_> which, in most hardwares, is tricky.
11:39:51 <Lor> Yes. But if you have such a general-case program, it wouldn't fit in 1k anyway. :)
11:39:57 <basti_> =)
11:40:02 <int80_h> it wouldn't be general case
11:40:52 <basti_> hm?
11:41:15 <basti_> anyway i think some reduction algorithm would sure fit into 1k instructions.
11:41:19 <int80_h> or well, I guess I shoudl ask what you mean by general case before I say that
11:41:33 <basti_> well i was thinking like: map inc [1,2,3]
11:41:35 <Lor> Anyway, I think ML would be much more suitable for this.
11:41:39 <basti_> (would return [2,3,4])
11:41:52 <int80_h> Lor: for what reason?
11:42:03 <Lor> Less thunks.
11:42:11 <int80_h> thunks?
11:42:17 <Lor> Lazy closures.
11:42:20 <basti_> i think its stupid to reason about programming languages from the viewpoint of a hardware.
11:42:51 <monochrom> Yeah
11:43:04 <tuomov> depends on the hardware
11:43:04 <int80_h> well basti, for whatever reason people want to be able to program machines in languages other than assembler.
11:43:14 <basti_> yes.
11:43:20 <basti_> thats why there are compilers. and the like.
11:43:30 <int80_h> so stupid or not, if people want this, we have to talk about it.
11:44:04 <basti_> but, i wouldnt go like "waah i dont language X, I can't compile to run in my system Y"
11:44:06 <int80_h> right so what I am talking about I guess, is what the compiler has to do to accompilsh porting a functional language to an AVR
11:44:29 <basti_> and this depends strongly on what language.
11:44:30 <int80_h> nah when I was learning about AVR I was all about learning the instruction set
11:44:46 <int80_h> because, you know, what's the point if you don't want to do that?
11:45:02 <basti_> i have read about people who, as a practice, started implementing a LISP on every new system they got ;)
11:45:14 <int80_h> heh
11:45:35 <monochrom> Some people are hypocrites, double standard.  They say they're "low-level", "close to hardware".  Liars; they can't even tell diodes from transistors.  All they can do is registers, program counters, stack, ... all very high level.  I say, everyone has his own fetish abstraction; no one is close to hardware.
11:45:35 <int80_h> because it's like you said? "whaa I don't know how to code x on Y)
11:46:01 <basti_> no i didnt say that...
11:46:15 <int80_h> I can't tell a diode from a transistor :)
11:46:26 <monochrom> Hypocrite.  You.
11:46:30 <int80_h> soldering that avr gave me troub;e
11:46:31 <shapr> me too!
11:46:37 * Lor has never really understood how control logic works.
11:46:49 <basti_> i was thinking like, its stupid to reason about programming languages themselves basing on the question if a given program fits into a certain environment...
11:46:55 <monochrom> If you don't know transistors, you don't bloody talk about hardware in my presence.
11:47:06 <basti_> ...using some certain compiler, yada yada
11:47:08 <int80_h> sir yes sir
11:47:20 <basti_> i value haskell for its own value
11:47:30 <basti_> and i value avr's for their own value.
11:47:46 <int80_h> heh I guess I was looking ahead for a neat senior yeaR project
11:47:59 <monochrom> Since you're already a high-level person, I don't see what qualifies you in questioning other high-level persons.
11:48:04 <int80_h> oooh I made a haskell subset compiler for the avr oooh
11:48:14 <basti_> i believe it would be quite a task to make a "tiny" haskell
11:48:17 <int80_h> you know, like that
11:48:21 * basti_ nods
11:48:45 <int80_h> someone said ML would be better, why is this?
11:48:46 <basti_> well you should strt with something that at least has a lambda
11:48:52 <int80_h> oh wait you answered that never mind
11:49:12 <basti_> so you could call it "functional"
11:50:27 <int80_h> hey is this channel logged anywhere?
11:50:40 <basti_> but its quite a way to something close to haskell
11:50:43 <shapr> I think someone said it is...
11:50:43 <basti_> yes it is i think
11:51:01 <basti_> i stumbled across logs
11:51:12 <shapr> You could read the channel topic to test the truth of that assertion.
11:51:14 <int80_h> alright I will google
11:51:21 <basti_> lol
11:51:43 <basti_> people never read topics
11:51:49 <int80_h> well what do ya know...logs mentioned in the topic
11:52:04 <int80_h> okay back to work
11:52:30 <monochrom> good luck
11:52:33 <shapr> have fun!
11:52:37 <int80_h> heh thanks
11:52:41 <basti_> int80_h: as good as I find your idea, take care about trying to port haskell to something deliberately tiny ;)
11:52:48 <int80_h> I don't get to use a functional language at work
11:53:23 <int80_h> basti_ I wouldn't do this for some time. Right now it's a naive idea tooling around in my head.
11:53:23 <monochrom> Don't despair.
11:53:31 * shapr despairs.
11:53:41 <basti_> int80_h: =)
11:53:50 <int80_h> this was my fault, for this project I was told I could use whatever language I wanted for implementation
11:53:56 <basti_> int80_h: have a look at lisp, or maybe prolog...
11:53:59 <monochrom> Hahaha
11:54:00 <shapr> But then after despairing I get off my butt and do something to teach more people about functional languages.
11:54:12 <basti_> prolog is another world, but i think it could be "tiny"
11:54:24 <monochrom> What do you do to teach more people about functional languages?
11:54:25 <shapr> Haskell could be tiny if you implement it with SKI
11:54:31 <basti_> SKI?
11:54:35 <int80_h> really? tell me about SKI
11:54:36 <basti_> combinator logix?
11:54:37 <basti_> c
11:54:39 <basti_> s
11:54:39 <shapr> monochrom: I organize The Monad.Reader for example.
11:54:47 <monochrom> Ah.
11:54:51 <basti_> lol
11:54:58 <shapr> And I write tutorials about Haskell stuff.
11:55:10 <wli> basti: basically, unlambda
11:55:12 <int80_h> whwich I will be reading, I assure you.
11:55:15 <basti_> how do people set @yow s?
11:55:20 <shapr> And I host Haskell projects on my servers so that people can easily access them.
11:55:39 <int80_h> shapr, do you provide programming enviroments?
11:55:44 <basti_> wli: the thing with the three "combinators" that is turing complete?
11:55:50 <shapr> Oh, and I maintain the Haskell Wiki, and lambdabot, and I'm the contact for #haskell ...
11:55:50 <monochrom> I invite you to use some of my flamboyant sayings in Monad.Reader as quotes.
11:55:54 <Lor> basti, two are enough.
11:55:57 <Lor> I=SKK
11:56:01 <basti_> ohhh
11:56:12 <shapr> and I do web stuff and some sysadmin for haskell.org
11:56:14 <monochrom> "The Quote of This Month: 'People are hypocrites.' - monochrom"
11:56:38 <wli> I think ther are more combinators commonly used to compact expressions, but I don't quite understand how all that goes.
11:56:54 <wli> I understand the minimal combinator case, but not what happens when you get extra ones.
11:57:02 <basti_> i think people trying to convince me to program in combinator logic are on drugs.
11:57:03 <shapr> int80_h: what do you mean? I use emacs mostly.
11:57:22 <int80_h> I mean, a place to compile.
11:57:24 <wli> basti: not quite what's being suggested
11:57:27 <shapr> basti_: lambdabot's @eval command is just a lambda calculus interpreter with a few definitions on top.
11:57:37 <int80_h> you said you hosted projects, I wasn't sure what you meant
11:57:48 <basti_> lambda calculus is NOT combinators =)
11:57:48 <shapr> but it's enough to confuse many long time users of Haskell as to whether it's 'real haskell' or not.
11:57:49 <wli> basti: I suspect rather an interpreter and/or macro-assembly-like affair based on combinatory logic.
11:57:57 <int80_h> hosting as in a place to keep source. or hosting as a place to develop?
11:58:12 <shapr> keep source at the moment
11:58:16 <int80_h> ah okay
11:58:23 <shapr> place to develop is a good idea.
11:58:36 <shapr> I've been campaigning for community.haskell.org that would allow that.
11:58:38 <CosmicRay> can anyone help me with "once" and "forever" in wash?
11:58:40 <int80_h> I keep bugging my sys admin to add this and that .
11:58:58 * basti_ has his own system to add things
11:59:00 <shapr> There's a real possibility that community.haskell.org will happen sometime soon.
11:59:02 <int80_h> and I think I may have used up all my requests, you know.
11:59:23 <int80_h> well I have my home machine but it's not "connected"
11:59:32 <int80_h> I want a place I can access
11:59:37 <int80_h> at any given monet
11:59:44 <basti_> hmm
11:59:45 <int80_h> moment
11:59:59 * shapr wants access at any given picasso
12:00:17 <monochrom> get a laptop.  you can use it anywhere.
12:00:37 <int80_h> yeah I guess I need to not be cheap and buy a network card for that bad boy
12:00:48 <int80_h> because I already have one :)
12:02:23 <shapr> I'm getting close to orphaning lambdabot, if someone else wants to pick up as maintainer.
12:02:43 * basti_ coughs.
12:02:55 * basti_ is suffering from eggdrops on ircnet.
12:03:00 <int80_h> eep, better formally post that somewhere so as to increase the chance of someone picking it up
12:03:17 <int80_h> I'll ask my buddy athlonrob
12:03:26 <shapr> Is he a haskell programmer?
12:03:41 <int80_h> oh woops, I thought you needed someone to host it
12:03:44 <Lor> "He soon will"?
12:04:46 <shapr> Nah, I've got hosting, I just don't have time to take care of the code.
12:05:08 <int80_h> is this a good way for a total newbie to learn haskell?
12:05:16 <int80_h> or would one need to already be an expert?
12:05:33 <monochrom> It is a good way for a total newbie to confuse lambdabot
12:05:34 <shapr> lambdabot has some seriously weird bits, I don't think it's newbie level.
12:05:39 <int80_h> heh
12:05:47 <shapr> It might be newbie level if I swapped it over to hs-plugins.
12:05:51 * shapr thinks about that.
12:05:55 <int80_h> yes yes :)
12:05:59 <basti_> isnt that the point of functional programming? ;)
12:06:03 <int80_h> I would like a project I could handle
12:06:06 <Lor> what does "grep -cr unsafe ." say in the lambdabot source? :)
12:06:10 <basti_> making a program weird and unreadable
12:06:35 * pesco stares at basti_.
12:06:37 <int80_h> only unreadable to the uninitiated barbarian.
12:06:39 <basti_> -g-
12:06:41 <pesco> ;-)
12:06:56 * pesco waves to everyone.
12:07:00 <basti_> i mean its job security...
12:07:02 <shapr> hiya pesco!
12:07:19 <shapr> Lor: all the unsafe stuff in lambdabot is in the hacked version of ozone's RuntimeLoader.
12:07:19 <basti_> i++; looks like any idiot could do it.
12:07:30 <shapr> Switching to hs-plugins would dramatically improve lambdabot's code.
12:07:39 <int80_h> except at the companies that insist you code in languages that the masses know
12:07:47 <shapr> Why do they do that anyway?
12:07:58 <int80_h> because to them, programmers are replacable parts
12:08:00 <shapr> It's not like it gives them better programs.
12:08:10 <int80_h> and they want to be able to replace you if they need to
12:08:12 * samc says something incredibly witty
12:08:20 <basti_> i think a programmer ought to be replacable.
12:08:29 <basti_> what if he dies suddenly or something?
12:08:31 <shapr> I think programming is a service.
12:08:43 <basti_> or moves to somewhere where companies dont suck?
12:08:50 <shapr> yeah, really
12:08:51 <basti_> [mental hospital?]
12:08:56 * int80_h laughs
12:09:11 <shapr> If programming is a service, then you hire someone to implement a feature, fix a bug, or whatever.
12:09:19 <shapr> and then when they're done, that's it.
12:09:19 <basti_> im pulling a little joke, but i mean it.
12:09:22 <int80_h> brb
12:09:32 <int80_h> I know that's why I laughed it was funny :)
12:09:57 <shapr> I thinking programmers getting paid by the hour is counterproductive. If you got paid by the feature, that would be much better.
12:10:02 <basti_> i will be lucky when all the world thinks like shapr. because programming is a rare skill.
12:10:16 <basti_> but you cant measure features.
12:10:20 <int80_h> good programming is a rare skill
12:10:24 <shapr> sure you can, use a functional test.
12:10:27 <basti_> even rarer.
12:10:35 <int80_h> but you can find crappy programmers everywhere
12:10:38 <samc> shapr, I wouldn't want to be paid for fixing a bug
12:10:38 <basti_> oh you mean as in "completed specification"?
12:10:53 <shapr> samc: you would if you could fix the bug in thirty seconds.
12:11:05 <samc> It would be a gamble
12:11:14 <basti_> but one against yourself =)
12:11:22 <samc> you couldn't know how long it'd take
12:11:31 <shapr> I think hourly programmers totally lack the motivation to improve.
12:11:33 <basti_> you never can in programming.
12:11:38 <shapr> If they did better, they would get paid LESS.
12:11:52 <samc> but specially for debugging
12:11:59 * basti_ sings along: DONT HOLD BACK!
12:12:21 <shapr> On the other hand, in salary jobs... you get overtime when the company needs you, but do you get undertime when your work is done?
12:12:41 <basti_> capitalism is unfair.
12:13:02 <shapr> I think capitalism is fine, I think corporate programming is broken.
12:13:17 <basti_> hmm.
12:13:32 <xerox> Why do you think capitalism is fine?
12:13:42 <basti_> i think most people dont see what the consequences of their decisions are.
12:13:48 <samc> shapr, managers get promoted by managing projects which cost a lot of money, why would they have their programmers use haskell?
12:13:49 <shapr> basti_: yeah, I agree.
12:14:39 <samc> there are some stories here, if only I could find them
12:14:42 <shapr> The way I see it, the best managers should manage, the best programmers should program. Merit should be the basis. So, how do you reward merit?
12:14:54 <basti_> i think free trade is a good idea, basically.
12:15:39 <basti_> bad ideas are: "since my worker has 24 hours a day, I pay him to stay in that room 8 hours, so he has free time 8 hours (-commuting) and can sleep 8 hours)
12:16:22 <shapr> That sort of thing works on an assembly line, but not in programming.
12:16:33 <basti_> or, "since its hard to be productive, we will speculate some with our money. That gains money too."
12:16:43 <shapr> Programmers still get paid like they work on assembly lines.
12:16:51 <int80_h> treating programmers as factory workers is a big part of the problem
12:16:58 <basti_> probably
12:17:05 <rtega> + worthless deadlines
12:17:42 <wli> Programmers are salaried everywhere I've been.
12:17:53 <wli> Worthless/meaningless deadlines are definitely in the equation.
12:18:26 <int80_h> wli: when I say factory worker, I mean measuring your output by how many lines of code you produce.
12:18:39 <shapr> Let's say I could hire the four best Haskell programmers I know, and the best manager I know, and I could bid on programming projects. I'm sure I could get results (implemented in Haskell) in a tenth of the time/cost of other companies.
12:19:05 <glimming> Is there someone who knows some catamorphism?
12:19:16 <glimming> Or rather the theory behind them, i.e. F-algebras etc?
12:19:21 <basti_> "head" is one isnt it?
12:19:30 <int80_h> shapr, I keep seeing jobs on the internet , people want you to implement in their favorite language. if it's the best langauge doesn'tmatter.
12:19:42 <glimming> I have a question to such person.
12:19:43 <shapr> int80_h: That's part of the problem.
12:19:59 <basti_> there is no "best" language btw.
12:20:02 <int80_h> so I want to know how to bid saying "PHP is shit, I can do it in language foo for this much less."
12:20:21 <int80_h> no "best" language but some are better in certain problem domains than others
12:20:22 <shapr> I think PHP is good for some things. I think it's a good example of a domain specific language.
12:21:02 <int80_h> nothing is wrong with it's original domain. But people keep wanting to make it do things it was not meant to do.
12:21:09 <shapr> In fact, PHP is one of my arguments in favor of Haskell =) Learn a language that's good at building domain specific languages.
12:21:37 <shapr> Well, I've enjoyed my evening rant, time to fall over asleep.
12:21:44 <int80_h> no no don't leave :)
12:21:53 <int80_h> oh well fine be that way :)
12:22:01 * shapr throws lambdas at int80_h 
12:22:24 * int80_h returns false.
12:22:39 <int80_h> um
12:22:42 <wli> structural subtyping could be interesting
12:22:44 * int80_h returns nil.
12:22:47 * pesco says No.
12:23:06 <glimming> I need to know ackumulating parameters and tupling generically.
12:24:02 <int80_h> ugh I really have to stop chatting and get to work
12:24:10 * int80_h blames the interesting people in #haskell.
12:24:23 * wli farts around looking for type inference algos.
12:24:23 <sond> int80_h from ircnet #asm?
12:24:43 <int80_h> no no this is the only irc network I frequent
12:24:52 <sond> maybe not then ;)
12:25:00 <Lemmih> Greetings, SyntaxNinja.
12:26:12 <wli> Not 100% sure what to do with the various inequations.
12:26:59 <wli> I guess that's why I'm not a type system designer.
12:28:43 * samc takes a mental note: do not traumatise 8-year-old girls
12:29:12 <samc> sorry, wrong window
12:29:44 <basti_> gf's dad was brought to the hospital...
12:29:53 <basti_> have to care
12:29:56 <duncan_> wli: structural subtyping? That's just what I've been reading about all day!
12:30:23 * wli remembers teaching a 10-year-old girl residue calculus and the calculus of variations and preliminary things as an experiment.
12:30:40 <Philippa_> how'd she cope?
12:30:44 <wli> duncan: interesting, are there any type inference algorithms for that that work with typeclasses?
12:30:59 <Philippa_> wli: are we trying to do the same thing?
12:31:00 <wli> Philippa: She did fine, because she had no idea it wasn't basic algebra.
12:31:18 <Philippa_> (I don't have an algo for Tyop, but I think I know how it would be done - I've just been failing to code it up for months)
12:32:08 <wli> Philippa: I'm not really trying, I'm just curious and sniffing around for prior work. I don't have the time/interest/etc. to actually work out a solution if it's an open problem.
12:32:54 <duncan_> wli: I wasn't thinking about typeclasses, so I'm not sure. How are typeclasses a structural subtyping sort of thing? I thought they were a differnt sort of constraint.
12:33:37 <Philippa_> wli: AFAIK nobody's done anything directly. I'm working on stuff for my dissertation project - it'll be one of the more impressive undergrad projects that year when I finally hand it in
12:33:48 <duncan_> wli: There are certainly constraint solving algorithms that do type inference for type systems with structural subtyping
12:34:50 <Philippa_> really it's just a matter of working out the interaction between type classes and subtyping
12:35:00 <Philippa_> there's a fairly easy way to get coherance
12:35:14 <Philippa_> at least, assuming we're working with algebraic datatypes still
12:35:21 <duncan_> Philippa_: what does your subtyping represent?
12:35:28 <esap> type classes and subtyping are not hard. Type classes and functions is harder.
12:35:44 <wli> esap: hm?
12:36:00 <esap> wli: I mean, getting good semantics for how type classes and functions interact.
12:36:06 <Philippa_> duncan_: a subset of the data constructors in the supertype
12:36:23 <esap> wli: And I'm not talking about the functions declared in a type class.
12:36:31 <duncan_> Philippa_: like rows / extensible records ?
12:36:34 <Philippa_> esap: right. I've not bashed out the relevant orderings for the multiparm case, but for single-parm it's fairly trivial (coherance by coinheritance)
12:36:57 <Philippa_> duncan_: sort of, yeah. Only you can't add new subtypes, only new supertypes
12:37:11 <Philippa_> on account of adding new subtypes being a great way to bugger up everybody's carefully-crafted pattern-matching
12:37:13 <wli> duncan: I'm more interested in extending case alternatives.
12:37:23 <Philippa_> ("oh look, that function's not total any more!")
12:37:36 <Philippa_> wli: do I appear to be looking at the same thing as you?
12:37:37 <duncan_> Philippa_: right.
12:37:45 <wli> Philippa: yes
12:37:52 <wli> Philippa: but I was only trying to look up existing results
12:38:39 <Philippa_> okay, cool. I don't have typeclasses yet, but know how they should be done. Only problem is I keep trying to do both them and the rank-n stuff at once and I've not been having the best of quarters
12:38:52 <Philippa_> I do have the basic H-M thing with this though
12:39:11 <wli> Philippa: Have you seen Dilip Siquiera's dissertation with the Helly posets etc.?
12:39:20 <Philippa_> er, got it, not read through it fully
12:39:37 <esap> Helly posets?
12:40:22 <wli> esap: yes, it's used to classify the posets formed by types and so find various types etc.
12:40:46 <wli> esap: things like existence, uniqueness, etc.
12:41:13 <Philippa_> wli: FWIW, I do think the combination's going to be highly useful once somebody's got it working
12:41:32 <Philippa_> I really should get it done fast enough for consideration for a Haskell 2
12:41:36 <esap> wli: Hmm.. sounds interesting.
12:42:13 <wli> I can't promise help codemonkeying or proving anything; day job etc.
12:42:31 <Philippa_> fair enough
12:42:55 <Philippa_> I'm probably not going to do my own proofs in the end anyway - I'll give intuitive grounds and let others bash 'em out
12:43:08 <wli> I expected one of those two to fall in your dissertation and the other to be a candidate for such.
12:43:17 <duncan_> Philippa_: so what's the use case for adding a new supertype for a record (I can visualise the subtype case but not the other way around)
12:43:30 <Philippa_> duncan_: it's not records we're doing this for, it's ADTs
12:43:45 <Philippa_> think of it as summing the subtypes
12:43:51 <wli> Philippa: What's the name of that PostScript/PDF file?
12:43:57 <wli> Dilip Siquiera's that is.
12:44:30 <duncan_> Philippa_: do you have a nice motivating example where it'd be useful?
12:45:14 <wli> ECS-LFCS-94-280.ps is one by Steffen and Pierce on higher-order subtyping.
12:45:28 <Philippa_> ECS-LFCS-98-403.pdf
12:45:42 <wli> heh, I have it as dvi
12:49:52 <wli> The Haskell class hierarchy is given as an example of a Helly poset.
12:54:19 <tic> How do I write a nestled if in Haskell?
12:54:29 <esap> Hmm.. is the syntax of Haskell functions also a Helly poset?
12:54:31 <tic> if a then b else if c then d else f
12:54:34 <wli> Philippa: Would I be correct in assuming that when an upper bound is not unique, then the type can't be simplified, as opposed to being ill-formed?
12:54:35 <tic> but that doesn't seem to work
12:54:41 <wli> esap: not that I'm aware of
12:55:01 <Philippa_> wli: basically, yeah - hell, if you feel like it you can use union types 'til you have a good match
12:55:10 <Philippa_> (am tempted to do that with the typing rule on pattern-matching)
12:55:29 <wli> Philippa: I'd assume pattern matching proceeds something like:
12:55:50 <wli> Philippa: t >= type_with_all_these_constructors
12:56:03 <Philippa_> that was my original rule, yeah
12:56:06 <wli> Philippa: which may be backward
12:56:11 <Philippa_> but you can do stuff to aid totality a little
12:56:16 <wli> Philippa: maybe that's the rule if there's a _ case
12:56:26 <wli> Philippa: and it goes the other direction when there isn't
12:56:29 <Philippa_> right. For the smallest t unless there's an annotation
12:56:40 <esap> wli: actually, it might be it's not. I confused with instance declarations. I've been thinking that instance declarations with subclassing constraints should have the same structure than function definitions (with the subclassing constraint corresponds to the function type).
12:57:10 <duncan_> tic: there's nothing wrong with the syntax you give, perhaps the problem is something else
12:58:53 <wli> hmm
12:59:08 <basti_> shit
12:59:17 <wli> the opposite inequality makes it work on any variant which is wrong
12:59:27 <basti_> gf's father had a heart attack, looking very bad, we have to go 200 km. be back in days.
13:00:05 <wli> not quite, no
13:00:22 <wli> There is no empty variant, so the "bottom-most" types possible only have one alternative.
13:02:02 <wli> so it's a union of the sets of types bounded below by individual constructors
13:02:16 <wli> when there is a _ case that is
13:02:36 <wli> when there is no _ case then they're also bounded above by all of the cases
13:02:49 <wli> or something on that order?
13:02:55 <Philippa_> roughly, yeah
13:03:22 <wli> the variants are what I really want =)
13:06:34 * boegel boing
13:06:37 <boegel> +s
13:07:19 <tic> duncan_, yup, it was the missing }.. oh well..
13:10:49 <tic> lambdabot, lookuup
13:20:50 <juneof44> .
13:34:33 <int80_h> ghs is a haskell compiler right?
13:34:41 <int80_h> I can't use a web browser atm
13:35:18 <lightstep> ghc
13:35:32 <lightstep> the Glasgow Haskell Compiler
13:52:32 <bourbaki> hi
13:53:04 <lightstep> hi
13:53:25 <Lemmih> Greetings.
13:54:21 <tic> guys, I could use some help on this error message: http://rafb.net/paste/results/RD0ZzB90.html
13:55:02 <lightstep> C++?
13:55:07 <tic> No, Haskell.
13:55:30 <lightstep> apparently, it thinks that Ok is not a data constructor
13:55:40 <tmoertel> where is Ok constructor defined?
13:55:44 <tic> Sec.
13:56:12 <Lemmih> tic: Please post the error message.
13:56:14 <tic> data Err a = Ok a | Bad String
13:56:20 <tic> Lemmih, I did. The description.
13:56:27 <Lemmih> Ah (:
13:56:36 <tic> all it says, which isn't very helpful :/
13:56:47 <tmoertel> is the data Err definition in the scope? let's see the whole thing
13:57:03 <Lemmih> tic: Check your case expressions.
13:57:16 <Lemmih> The correct syntax is: case expr of ...
13:57:20 <lightstep> is the error in the pattern matching? because all thos ;'s look suspicious
13:57:24 <tic> lookup :: .... -> Err b.
13:57:33 <Lemmih> tic: D'oh. Please ignore me /-:
13:57:34 <tic> lightstep, that shouldn't matter
13:57:45 <tic> lookupE actually.  Anyway, it's Err
13:59:02 <lightstep> you forgot a `then'
13:59:08 <tic> hm. *checks*
13:59:13 <lightstep> if the parser is stup[id, it might not recognize it
13:59:33 <tic> lightstep, same thing though.
13:59:38 <tic> but thanks. ;)
14:00:07 <tmoertel> if you comment out everything after line 2, do you still get the error?
14:00:39 <tic> Don't think so.  Is there a way of doing multi-line comments?
14:00:51 <tmoertel> Use {- -}
14:01:50 <tic> nope, did not get that error message.
14:02:36 <tmoertel> un-comment the stuff and them put a semicolon } on line 13
14:02:50 <tmoertel> put the semi after the }
14:02:50 <tic> I'll try.
14:02:53 <tic> yeah
14:03:05 <tic> nope. blerf.
14:03:09 <tic> silly silly haskell parser.
14:03:22 <tic> unless I'm actually _doing_ something wrong. Which I kinda doubt.
14:04:25 <Lemmih> tic: Using Hugs?
14:05:00 <tic> Lemmih, ghc.
14:05:22 <tmoertel> tic: do you have tabs in your document? if so, convert them to spaces and double check your alignment. The Bad and Ok cases should be indented identically.
14:06:02 <tic> tmoertel, does it matter when I use {} and so on?
14:06:23 <tic> okay, I'll try....
14:06:39 <tmoertel> you aren't using { } around the case lookupE ... expression; if you were it would be case X of { x -> ...; y -> ...; ... }
14:07:56 <tic> m'kay.  I tried that as well, wouldn't make any difference.
14:08:00 <tic> now I've removed it and aligned it.
14:08:04 <tic> argh!
14:08:07 * tic rips out his hair
14:08:35 <Lemmih> tic: Could you post a complete example?
14:08:35 <tmoertel> at this point, can you post the whole thing?
14:08:59 <tmoertel> (how's that for timing?)
14:09:16 <Lemmih> (:
14:09:36 <tic> okay, now it works.
14:09:42 <tic> I added {} around everything possible
14:09:44 <tic> thanks guys.
14:09:56 <tic> note to self: avoid actually _writing_ haskell code in the future
14:10:18 <Lemmih> Could you post it anyways?
14:11:29 <lightstep> should i flush the output, or set the buffering mode? (for an interactive terminal program)
14:12:54 <tic> Lemmih, it's a bunch of files actually, kinda difficult to post. :/
14:12:57 <SyntaxNinja> tmoertel: hey. I'm now generating {,un}register.sh :)
14:13:10 <SyntaxNinja> CosmicRay might also be interested to know of this development
14:13:14 <Pseudonym> @arr
14:13:14 <lambdabot> Well me hearties, let's see what crawled out of the bung hole...
14:13:44 <tmoertel> SyntaxNinja: can you show me what a sample register.sh looks like?
14:14:08 <Lemmih> tic: You could DCC them to me, perhaps?
14:14:18 <tic> Lemmih, okay, if you really want the crap, sure.. :)
14:14:38 <tic> actually, e-mail would be easier, I think.
14:15:21 <SyntaxNinja> tmoertel: www.syntaxpolice.org/tmp/register.sh
14:17:32 <CosmicRay> SyntaxNinja: hmm, what development?
14:17:36 <tmoertel> SyntaxNinja: is the version of ghc-pkg used the one associated with the compiler given by the --with-compiler option?
14:17:39 <CosmicRay> SyntaxNinja: btw, rumor has it that you have a cabalized wash
14:17:53 <CosmicRay> shapr: can you give me an example of the syntax for "project" in haskelldb that includes two different columns?
14:18:03 <SyntaxNinja> tmoertel: yeah
14:18:08 <SyntaxNinja> CosmicRay: yeah, it was a while ago
14:18:14 <SyntaxNinja> CosmicRay: but it was pretty easy
14:18:31 <CosmicRay> SyntaxNinja: they are generating three different packages
14:18:34 <SyntaxNinja> CosmicRay: I'm adding a feature, as-yet-unnamed to register and unregister to dump a shell script instead of going right away
14:18:39 <tmoertel> SyntaxNinja: excellent. another Q: where does the --config-file value in the script come from?
14:18:40 <CosmicRay> it's not clear to me how to make a cabal out of that
14:19:01 <CosmicRay> SyntaxNinja: also it's not clear to me how to make the generated package run a preprocessor like wash is doing
14:19:01 <tmoertel> SyntaxNinja: nevermind, figured it out
14:19:11 <SyntaxNinja> tmoertel: if they say --user, then it's ~/.ghc-packages in ghc 6.2, and someplace else in ghc 6.4
14:19:24 <SyntaxNinja> if they don't say --user, then it's some magic ghc-based location
14:19:26 <Lemmih> CosmicRay: project ( column1 << table1!column1 # column2 << table2!column2) ?
14:19:28 <SyntaxNinja> er actually, it doesn't use that flag
14:19:36 <CosmicRay> thanks lemmih
14:19:42 <SyntaxNinja> in 6.4 --user just passes --user to ghc-pkg
14:20:15 <SyntaxNinja> and in 6.2, the global config file is known to ghc-pkg and doesn't end up there
14:20:23 <SyntaxNinja> I'm a little worried about quoting, btw, but I think it'll be OK
14:20:30 <tmoertel> SyntaxNinja: did you cabalize all of WashNGo? if so, how did you handle the separate packages?
14:20:31 <SyntaxNinja> (in the shell script)
14:20:42 <SyntaxNinja> tmoertel: no, I don' tthink there was washNGo when I cabalized wash.
14:20:56 <SyntaxNinja> there's as-yet no mechanism in cabal for handling separate packages, that's a next-release type issue.
14:21:06 <SyntaxNinja> but we have a name for such packages... I can't remember what it is.
14:21:09 <tmoertel> SyntaxNinja: how would one, then, package something like WNG... ah, you beat me too the Q and A
14:21:20 <tmoertel> is the name, "troublesome packages"?   ;-)
14:21:35 <SyntaxNinja> hehe. it's like,  'distributions' or 'collections' or something
14:21:36 <SyntaxNinja> oh!
14:21:39 <SyntaxNinja> "shipments" :)
14:21:46 <SyntaxNinja> but they don't exist yet.
14:21:52 <tmoertel> oh, "shipments," wow, that's a cool name
14:22:10 <SyntaxNinja> I think they will have something to do with a meaningful behavior for multiple .cabal files in one directory, but don't hold me to that.
14:23:27 <SyntaxNinja> CosmicRay: I thought you would jump up and down when I told you about the new register feature :)
14:26:28 <tmoertel> If anybody is interested, my prototype for cabal2rpm is here: http://community.moertel.com/ss/space/tmoertel/Hackery/cabal2rpm.pl
14:27:48 <SyntaxNinja> ohno! perl!
14:27:57 <tmoertel> hey, it's just a prototype.
14:28:06 <samc> everybody run
14:28:13 <CosmicRay> SyntaxNinja: sorry I am only partially here :-)
14:28:15 * CosmicRay scrolls back
14:28:23 <SyntaxNinja> tmoertel: that's totally 1337, I'm thrilled :)
14:28:27 <tmoertel> besides, until the evil mangler is rewritten, perl and haskell will always go together like doughnuts and coffee
14:28:53 <SyntaxNinja> haha
14:29:21 <tmoertel> SyntaxNinja: i still need to shake it out on some real cabalized tarballs and write docs...
14:29:44 <CosmicRay> SyntaxNinja: I already grab ~/.installed-pkg-config from the source tree :-)
14:29:56 <CosmicRay> when I need to, that is
14:30:04 <CosmicRay> that's what this is doing, right?  dumping out that file?
14:30:56 <SyntaxNinja> CosmicRay: no, it's wrapping up the register action so you don' tneed to grab the file or anything
14:31:11 <SyntaxNinja> all you need to do is grab the script itself.  this makes things way more portable
14:31:27 <CosmicRay> ahh.  that is nice
14:31:31 <SyntaxNinja> because your debian creation tool will invoke the same code no matter the version of ghc or even if you're using hugs :)
14:32:02 <SyntaxNinja> tmoertel: did you find a cabalized tool to try yet?
14:32:22 <SyntaxNinja> tmoertel: are you in Pitt. PA?
14:32:26 <tmoertel> nothing that is "official"; have a recommentation or, better yet, a nice tarball?
14:32:38 <tmoertel> SyntaxNinja: yup. good old pixxb0rg, pa
14:33:30 <SyntaxNinja> tmoertel: I'm from ytown, OH.
14:33:42 * tmoertel hopes SyntaxNinja is not planning on sending me a tarball via UPS
14:33:52 <SyntaxNinja> tmoertel: do you have the cabal source tree?
14:33:52 <tmoertel> SyntaxNinja: small world!
14:34:12 <tmoertel> SyntaxNinja: I have been using the 0.4 tree for my tests.
14:34:14 <SyntaxNinja> tmoertel: so I guess I owe you a beer or something. but I don' tlive in ytown anymore, so it'll be a while.
14:34:37 <SyntaxNinja> tmoertel: I recommend cvs or darcs grabbing the latest source tree and using anything under tests.
14:34:38 <tmoertel> SyntaxNinja: that's ok, i can wait a /long/ time for beer!
14:34:53 <SyntaxNinja> tmoertel: that either means you really like beer or you really hate it ;)
14:34:59 <tmoertel> SyntaxNinja: what's the darcs repo url
14:35:06 <tmoertel> SyntaxNinja: the former on the beer
14:35:50 <lightstep> does haskell have cool case patterns like in ml? ('a' | 'b' -> some; 'c' -> other)
14:36:17 <tmoertel> lightstep: yes
14:36:28 <lightstep> what is the syntax?
14:37:03 <SyntaxNinja> cabal: darcs get http://cvs.haskell.org/darcs/cabal
14:37:04 <tmoertel> lightstep: case expr of { pat1 | guard1 -> expr; pat2 | guard2 -> expr; ... }
14:37:17 <tromp> it doesn't allow different patterns to share the same exp though
14:37:39 <lightstep> ok, thanks
14:37:46 <tromp> the | is a guard, not an or
14:38:44 * tmoertel is getting patch 325 of 482 ...
14:40:11 <SyntaxNinja> tmoertel: when that's done, pull again, would you?
14:40:11 <SyntaxNinja> :)
14:40:15 <SyntaxNinja> I just pushed a bunch of stuff
14:40:44 * tmoertel is pulling 14 patches
14:40:48 <samc> tromp, are you the kolmogorov tromp?
14:41:50 <tmoertel> SyntaxNinja: do you have a version number of the current in-development cabal that I just pulled?
14:41:58 <tmoertel> s/of/for/
14:42:10 <SyntaxNinja> tmoertel: 0.5
14:44:00 * tmoertel built the rpm specfile
14:48:50 <tmoertel> prep stage of rpmbuild worked; trying compile
14:49:04 <tmoertel> whoops! can't find HUnit
14:49:08 <tromp> yep, samc
14:49:51 <tromp> although that's the 1st time ppl called me that:)
14:50:07 <samc> I just got Li and Vitnyi's book out from the library :)
14:50:18 <tromp> 2nd edition?
14:50:32 <samc> nice figures
14:50:35 <tromp> shld keep u busy for a wile:)
14:51:00 <tromp> they started working on 3rd ed
14:51:05 <samc> no doesn't seem to be 2nd
14:51:35 <tromp> oh, then it doesn't have my section:(
14:51:50 <samc> :(
14:51:51 <SyntaxNinja> tmoertel: shouldn't need HUnit, DEBUG defined?
14:52:48 <tromp> did you see my paper on a concrete kolmogorov compl. definition?
14:53:04 <samc> the combinatory logic one?
14:53:15 <tromp> and lambda calculus
14:53:21 <tmoertel> SyntaxNinja: here's the build script: http://community.moertel.com/ss/space/tmoertel/Hackery/compilation.txt
14:53:34 <samc> I have only skimmed it
14:54:06 <tromp> hope it made some sense:)
14:54:06 <samc> looks neat, I love minimalist stuff
14:54:29 <tromp> let me know if u can minimize it some more:P
14:54:40 <SyntaxNinja> tmoertel: HUnit is only included if you define DEBUG, so can you undefine it?
14:54:50 <tromp> off to bed now...
14:54:52 <jjang> you guys help with homework too? :|
14:55:23 <tmoertel> SyntaxNinja: I don't think that I defined it. What I did do, though, was not use the makefile but rather tried to build Setup
14:55:40 <tmoertel> SyntaxNinja: i.e., I tried to build it as if it were cabalized
14:56:18 <SyntaxNinja> tmoertel: look at the GNUMakefile for how to bootstrap it, you have to get the paths right.
14:56:31 <SyntaxNinja> look at "make setup"
14:57:00 <tmoertel> SyntaxNinja: what we're saying then is that cabal isn't cabalized (at least in the form I received)
14:57:29 <lightstep> jjang: it depends
14:57:40 <jjang> on?
14:57:50 <SyntaxNinja> tmoertel: oh, you're trying to bootstrap it from a previous version of cabal?
14:57:56 <lightstep> jjang: on the question
14:57:58 <SyntaxNinja> I usually bootstrap it from itself
14:57:58 <Cale> on what you mean by help :)
14:58:00 <wli> recursive cabalization?
14:58:24 <jjang> i have to make a function which returns the numbers after the last 0 in a list
14:58:32 <jjang> with type [Int] -> [Int]
14:58:35 <tmoertel> SyntaxNinja: essentially, cabal2rpm assumes that what you have is a tarball ready tobe expanded and installed via cabal
14:58:57 <tmoertel> SyntaxNinja: so I'm "make dist" first, and then I'll try cabal2rpm on the result
14:59:06 <jjang> but i have no clue how to detect a last 0
14:59:19 <SyntaxNinja> tmoertel: are you trying to package cabal itself?
14:59:26 <tmoertel> SyntaxNinja: yes
14:59:47 <SyntaxNinja> so it won't work "normally" because of the bootstrapping issue, -package Cabal isn't there.
14:59:53 <lightstep> jjang: i stumbled upon this a few minutes ago: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/ListDoc/
15:00:13 <SyntaxNinja> so your ghc line looks wrong, it should include "-package Cabal" I think
15:00:23 <tmoertel> SyntaxNinja: it is because I have Cabal 0.4 installed
15:00:25 <jjang> ok lemme check it seems fine
15:00:35 <tmoertel> SyntaxNinja: ah! lemme fix that ghc line
15:01:59 <SyntaxNinja> tmoertel: hmmmm... so I don't understand, in any case, why it's looking for HUnit
15:02:00 <jjang> ah reverse is what i need
15:02:35 <tmoertel> SyntaxNinja: neither do I
15:03:40 <jjang> lightstep: thanks it works :D
15:03:48 <tmoertel> SyntaxNinja: I have a theory.
15:04:08 <SyntaxNinja> tmoertel: use -cpp
15:04:30 <SyntaxNinja> it's using the local cabal anyways.
15:04:35 <tmoertel> SyntaxNinja: when I use ghc to build Setup.lhs and it imports Distribution.Simple, it doesn't use the installed cabal-0.4 version but install the one in Distribution/Simple.hs
15:04:42 <lightstep> can i ask what this error means? http://rafb.net/paste/results/euZIPS40.html
15:04:45 <SyntaxNinja> tmoertel: right
15:05:08 <lightstep> jjang: where are you a student?
15:05:17 <SyntaxNinja> tmoertel: so _just_ for cabal... you need -cpp :)
15:05:24 <tmoertel> SyntaxNinja: -cpp seemed to do it
15:06:00 <_23skidoo> Hi
15:06:01 <jjang> university of utrecht
15:06:19 <jjang> (guys who made haskell.org/learning)
15:06:23 <jjang> and helium
15:08:42 <tmoertel> that was cool... cabal bootstrapped itself to build Setup, which is now *rebuilding* cabal !
15:09:11 <tmoertel> the build stage has completed; now on to install
15:09:18 <SyntaxNinja> wli: there ya go ;)
15:11:04 <SyntaxNinja> it would be cool if it didn't need the cpp flag
15:11:29 <tmoertel> SyntaxNinja: it's no prob because I can just pass ghcflags=-cpp to cabal2rpm
15:12:28 <SyntaxNinja> but can you do that just for cabal?
15:12:56 <SyntaxNinja> we could actually make it not need the cpp flag, but I think that technique gives hugs heartburn
15:13:59 <tmoertel> SyntaxNinja: right now I just let the user invoke cabal2rpm like so: cabal2rpm Cabal.cabal version=0.5 tarballroot=cabal ghcflags=-cpp
15:15:41 <SyntaxNinja> cool
15:16:12 <SyntaxNinja> theorem: cabal2rpm can package any package
15:16:41 <SyntaxNinja> proof: 1) cabal2rpm can package cabal
15:16:41 <SyntaxNinja> 2) cabal can package any package
15:16:41 <SyntaxNinja> therefore cabal2rpm can package any package
15:16:41 <SyntaxNinja> QED
15:17:08 <SyntaxNinja> ooh, we need to cabalize cabal2rm
15:17:09 <SyntaxNinja> rpm
15:18:06 <tmoertel> SyntaxNinja: I am somewhat afraid of what a tool called "cabal2rm" would do.  ;-)
15:18:15 <dons> hehe
15:18:30 <SyntaxNinja> hehe
15:19:01 <tmoertel> I'll be back in a few minutes; I have got to walk the dog...
15:19:13 <SyntaxNinja> I think you could implement rm in cabal through a series of monad transformers...
15:23:08 <boegel> @index read
15:23:08 <lambdabot> GHC.Read,Prelude,Text.Read
15:23:14 <boegel> @type read
15:23:15 <lambdabot> read :: forall a. (Read a) => String -> a
15:23:22 <wli> I need a fluency course in monads and monad transformers. I can eke them out slowly, under pressure, but not use them "naturally" or to any effective advantage.
15:24:00 <Philippa_> hrmm
15:24:06 <Philippa_> I've got my own way of looking at them, at least...
15:24:27 <Philippa_> getting monads fully will probably tell you enough about monad transformers to make effective use of those as well, IMO
15:24:55 <wli> One-line summaries have failed me for years, I basically need a wide-ranging problem set and some really nasty worked-out examples.
15:25:04 <boegel> @type filter
15:25:05 <lambdabot> filter :: forall a. (a -> Bool) -> [a] -> [a]
15:25:31 <Philippa_> 'k. I'm guessing a good one-paragraph summary with some of the more obvious but nevertheless useful examples won't help?
15:25:39 <wli> Nope.
15:26:07 <wli> (a) practice (b) examples of doing really painfully difficult things, with detailed discussion and explanation
15:26:08 <Philippa_> fair enough. Most of my own use's been the usual "Gimme state! Gimme exceptions!" stuff
15:26:24 <Philippa_> what counts as painfully difficult?
15:26:40 <Philippa_> and is this painfully-difficult-without-monads, or painfully-difficult-with?
15:27:12 <wli> Philippa: Painfully difficult with monads. The basic idea being marching me through stuff that's harder than what I'll actually have to deal with.
15:28:14 <Philippa_> ah. See, I tend not to do that because if it's still painfully difficult odds are I'm thinking about the problem the wrong way...
15:31:09 <Philippa_> also, a lot of the problems boil down to either "how do I solve this problem under the new set of semantics?" (feel free to read up on solutions in languages with similar semantics) or "how do I get the semantics in the first place?"
15:34:24 <wli> Philippa: The latter.
15:35:12 <Cale> wli: did you read my bit about monads as containers?
15:35:49 <wli> Cale: Summaries won't do anyway.
15:36:46 <Philippa_> wli: monad transformers're useful for the latter if you know which bits you want, I guess. Can you do standardish examples like "build me prolog!"?
15:37:08 <Philippa_> if you can do prolog, something concurrent and something pure OO you'll prolly be fine
15:37:53 <wli> Well, this won't get resolved today anyway.
15:38:14 <wli> Odds are I'll have to write what I'm looking for myself.
15:38:24 <Philippa_> probably, yeah :-(
15:39:03 * wli finds it difficult to believe no one else has this issue with monads.
15:39:29 <wli> Actually, it's probably just blatantly prevalent; tons of people go around asking for help with monads.
15:39:52 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers -- well, if you'd read this and let me know what you think, I'd appreciate it. I've always found the description of monads as some sort of abstractions of computation to be rather hard to grasp, so I took a different analogy.
15:39:58 <Philippa_> I don't see many people asking "how do I build this monad?"
15:40:22 <Philippa_> Cale: I went the other way and picked a more concrete version of "notion of computation" :-)
15:40:29 <wli> Philippa: Less constrained. "Given a problem, how do I figure out what monad it needs and build the monad on the fly."
15:40:56 <wli> Philippa: Without that I end up just defaulting to plain old functions.
15:41:11 <Philippa_> wli: ah. This is a bit like "how do I design a program?". Only it's "how do I design a programming language and then a program in it?"
15:41:39 <jjang> anyone know how i can sort a list with foldr ? :|
15:41:46 <wli> Philippa: Well, without this, there's never an obvious opportunity to use a monad.
15:42:25 <arjanb> jjang: try insertion sort
15:42:26 <Philippa_> the short version is "am I spending a lot of time emulating things I could do easily in another language?" (eg passing state around)
15:42:29 <wli> I can decide up-front to shoehorn momands in and ram it through.
15:42:36 <wli> ferh
15:42:46 <jjang> i have to write insertionSort using foldr :)
15:43:07 <dons> jjang: sure, you can use foldr, but that sounds like a homework project  ;)
15:43:14 <jjang> it is :|
15:43:37 <monochrom> I don't think insertion sort is worth any student's time.
15:43:50 <jjang> this whole language isnt worth my time
15:43:55 <boegel> g'night everyone
15:43:56 <jjang> but they still require me it to do it
15:44:06 <dons> jjang: it's a 6 line answer, anyway.
15:44:12 <jjang> 6 line?
15:44:13 <Cale> jjang: you might try writing it by first defining insertionSort [] = ... and insertionSort (x:xs) = ... -- and then figuring out how to use foldr. :)
15:44:23 <wli> I'd think of using unfoldr first, actually.
15:44:42 <jjang> insertionSort [] = [] i got :P
15:45:20 <jjang> if i could use java this would be a 3 minute job
15:45:25 <Philippa_> am I the only one to think "fold insert along the list"?
15:45:38 <SyntaxNinja> jjang: why are you learning haskell?
15:45:40 <Philippa_> (you can write your own insert, mind)
15:45:41 <Cale> Philippa_: no, you're not the only one :)
15:45:47 <jjang> because i need too
15:45:54 <jjang> my study requires it
15:45:57 <SyntaxNinja> it's a 3 minute job in haskell as well
15:45:58 <Cale> jjang: If Haskell was just like Java, then it wouldn't be worth learning :)
15:46:02 <monochrom> How long have you known Java?
15:46:03 <jjang> i have no idea what the purpose of haskell is
15:46:10 <Philippa_> writing programs. Duh.
15:46:10 <jjang> not long
15:46:12 <jjang> 2 months
15:46:16 <jjang> i also dont like java
15:46:24 <xerox> What's the problem's text?
15:46:27 <monochrom> I see.  That is why you can now do it in Java in 3 minutes.
15:46:27 <Philippa_> then perhaps you'll like haskell better once you've learnt it?
15:46:36 <monochrom> How long have you known Haskell?
15:46:37 <Philippa_> monochrom: by looking up the library function ;-)
15:46:48 <jjang> haskell: eh 3 lessons -.-
15:47:00 <jjang> but i could already do php before java
15:47:01 <jjang> so..
15:47:07 <Cale> Haskell is a general purpose programming language well suited to problems which are reasonably difficult algorithmically, or which require certain guarantees about correctness.
15:47:08 <monochrom> I see.  That is why you have some problem now.
15:47:26 <Cale> (but it can be used for basically anything)
15:47:41 <Cale> Forget everything you know about Java and PHP :)
15:47:45 <jjang> i know
15:47:50 <jjang> thats the first they told me
15:48:02 <Cale> (then remember it again later, and fit things together after)
15:48:07 <jjang> and i also use this kid edition compiler
15:48:13 <Philippa_> helium?
15:48:14 <wli> Well, we might as well just spray out the answer.
15:48:15 <jjang> ye
15:48:22 <monochrom> Perhaps don't force yourself into using foldr first.  I can tell you how to convert to foldr later.
15:48:23 <jjang> my teacher made helium
15:48:32 <wli> He needs to see at least *one* worked-out example.
15:48:38 <Philippa_> monochrom: depends. If he wants to learn "what foldr does" then going straight there's useful
15:48:44 <jjang> i just made another function with foldr
15:48:46 <monochrom> But after a year you will be able to use foldr natively.
15:48:48 <Philippa_> jjang: do you understand what the function foldr does?
15:48:48 <SyntaxNinja> wli: we should give it to his teacher to give to him ;)
15:48:56 <monochrom> (I foldr natively now.)
15:49:00 <wli> SyntaxNinja: Sure.
15:49:08 <jjang> i think it does a function on each element of a list
15:49:22 <jjang> something like that
15:49:35 * wli should probably figure out what distinguishes scanr/scanl from foldr/foldl/unfoldr,  since I've rarely ever seen a need for them.
15:49:40 <jjang> a : (b :(c: etc
15:50:00 <Cale> jjang: that's map -- foldr replaces the conses : with a given function, and the empty list at the end, with a value.
15:50:19 <jjang> ye
15:50:22 <SyntaxNinja> @type foldl
15:50:23 <_23skidoo> it's a way of generalizing a common form of recursion
15:50:23 <lambdabot> foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
15:50:46 <Cale> jjang: if you can define a function f on the empty list, and recursively on the list (x:xs), then you can write f as a foldr
15:50:46 <SyntaxNinja> foldl (+) 0 [1..10]
15:50:49 <SyntaxNinja> adds up that list
15:50:53 <jjang> ye
15:50:56 <jjang> 55 is the answer
15:50:56 <monochrom> http://www.cs.utoronto.ca/~trebla/fp/lecture-04.pdf  has some information on foldr.
15:51:06 <jjang> i have some information too
15:51:12 <jjang> but
15:51:21 <_23skidoo> foldr (++) [] [[1], [2, 3], [2, 1]]
15:51:24 <_23skidoo> does the same as concat
15:51:25 <_23skidoo> etc.
15:51:25 <jjang> still hard to makea insertionSort
15:51:39 <Philippa_> jjang: fold insert along the list
15:51:41 <monochrom> It has an example of turning a recursive definition into a foldr.
15:52:07 <jjang> ok lemme read that
15:52:15 <Philippa_> so that [1,2,3] becomes insert 1 (insert 2 (insert 3 []))
15:52:20 <jjang> but insert aint valid right
15:52:26 <Philippa_> so write an insert function?
15:52:39 <monochrom> hrm, perhaps not enough.
15:52:48 <_23skidoo> you can give foldr a default value of []
15:52:48 <jjang> i can just use fold only :P
15:52:54 <monochrom> But read what Philippa_ says.  It is leading to good stuff.
15:53:08 <_23skidoo> and then write an auxiliary function that inserts the items in the list at the end
15:53:17 <Philippa_> _23skidoo: right
15:53:37 <_23skidoo> (i just had my functional program exam today :)
15:53:41 <Philippa_> so insertionSort = foldr insert [] where insertionSort = ...
15:53:48 <_23skidoo> i mean programming, not program
15:53:51 <Philippa_> er, where insert = ...  even
15:54:02 <jjang> ah i see
15:54:11 <jjang> foldr insert [] x
15:54:20 <_23skidoo> insert could be defined as
15:54:24 <_23skidoo> insert a b =
15:54:27 <_23skidoo>   let
15:54:47 <_23skidoo>     (x, y) = span ((<=) a) b
15:54:49 <_23skidoo>   in
15:54:51 <jjang> ok well i try to figure it out myself now :)
15:55:00 <jjang> need to learn it to pass my exams
15:55:02 <_23skidoo>    x ++ [a] ++ y
15:55:06 <_23skidoo> there you go
15:55:34 <jjang> i will prolly mess around with it till i get the hang of it
15:55:44 <monochrom> insert is probably another foldr
15:55:51 <Cale> jjang: you'll find that Haskell contains lots of tools (like foldr) to encode common programming idioms into single functions.
15:56:04 <_23skidoo> btw
15:56:07 <jjang> ye
15:56:11 <jjang> the only thing i learn
15:56:16 <_23skidoo> isn't there a pdf titled bananas or something like that
15:56:17 <jjang> is to rewrite functions
15:56:20 <Cale> One thing that makes Haskell really nice is that you can write your own such functions
15:56:20 <_23skidoo> which is about fold*?
15:56:39 <Cale> (once you notice patterns in the way that you've been coding things)
15:56:45 <dons> _23skidoo: yep :) sort of.
15:57:06 <jjang> so this may be a stupid question but
15:57:11 <_23skidoo> jjang: check this too: http://www.cs.nott.ac.uk/~gmh/fold.pdf
15:57:16 <jjang> how do i make a user interface for haskell programs :)
15:57:25 <_23skidoo> dons: ah, thx
15:57:40 <dons> _23skidoo: you thinking of this: http://portal.acm.org/citation.cfm?id=128035 ?
15:58:03 <Philippa_> jjang: depends. I like wxHaskell, others have their own preferred libraries
15:58:07 <SyntaxNinja> jjang: what kind do you want? a web interface? a GUI? a command-line interface? a library API?
15:58:14 <Cale> jjang: If you want a CLI user interface, you can do it with the IO monad, which you'll hopefully learn about later. There exist libraries for wxWidgets, GTK+, and a number of other graphical user interfaces
15:58:17 <Philippa_> _23skidoo: please don't quote my dissertation supervisor at people :-)
15:58:30 <jjang> ah i see
15:58:33 <Philippa_> oh yeah, Haskell is /good/ at web stuff
15:58:34 <_23skidoo> Philippa_: ouch :)
15:58:39 <jjang> just wanted to know if its possible
15:58:44 <jjang> web stuff?
15:58:57 <Philippa_> I mean, the libraries aren't 100% there and thus the occasional bit of tweaking is good, but once you've got the CGI hookin sorted and so forth it's great
15:58:57 <_23skidoo> dons: loading...
15:59:01 <jjang> can u intergrate it in like php etc?
15:59:02 <Cale> There's some very neat web stuff. :)
15:59:07 <Philippa_> no. You don't want to, for that matter
15:59:21 <jjang> well like let haskell do some algoritms
15:59:26 <Cale> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
15:59:27 <Cale> yes
15:59:30 <jjang> and pass the result to php
15:59:30 <_23skidoo> dons: ah, yes. thanks I vaguely remembered the title :)
15:59:30 <Philippa_> no, let Haskell generate the entire page
15:59:36 <Philippa_> trust me on this
15:59:43 <Cale> yeah, you let Wash do everything
15:59:46 <Philippa_> I wrote a wiki clone in Haskell...
15:59:51 <Philippa_> Wash didn't grab me so much
16:00:00 <Cale> If you're using Wash :)
16:00:02 <_23skidoo> I just finished an introductory course to Haskell and
16:00:11 <_23skidoo> my only annoyance
16:00:13 <_23skidoo> is with I/O
16:00:19 <Cale> Philippa_: did you use any libraries I should know about?
16:00:20 <dons> no Philippa! do it 3/4 in php :P and maybe some perl and sed too ... hehehaha
16:00:22 <_23skidoo> I find it so messy it's terrible
16:00:34 <SyntaxNinja> just use php for the bits you want to be insecure ;)
16:00:37 <_23skidoo> isn't there a way to do I/O easily in Haskell?
16:00:38 <Cale> _23skidoo: IO is actually quite clean if done right
16:00:42 <Cale> and easy
16:00:51 <dons> yeah, that's weird. IO is really clean.
16:00:54 <Cale> Haskell is actually quite a good imperative language :)
16:01:02 <dons> compare with, say, Java..
16:01:05 <wli> feh, where's thbot?
16:01:06 <_23skidoo> Cale: I only studied IO Type. I know there's something about (>>=) but have no idea about it
16:01:07 <dons> or scanf..
16:01:08 <_23skidoo> is that what you mean?
16:01:19 <Philippa_> Cale: nope, I just used Network.CGI, Parsec and Text.Html. Well, you /should/ know about those
16:01:29 <Cale> yeah :)
16:01:32 <_23skidoo> ah
16:01:39 <Philippa_> _23skidoo: you don't need to care 'til you implement your own monad, the do notation'll do fine
16:01:42 <_23skidoo> I'll learn about it then, thx
16:01:46 <Philippa_> Haskell is an *excellent* imperative language
16:01:51 <Cale> _23skidoo: You can use do notation and >>= together as well
16:01:57 <_23skidoo> Philippa_: it's the do { m <- .. } notation what annoys me
16:02:02 <Cale> and you can invent your own control structures :)
16:02:03 <Philippa_> erk
16:02:03 <jjang> does haskell have mysql functions etc?
16:02:09 <dons> SPJ sez: "Haskell - the world's finest imperative language"
16:02:10 <Philippa_> jjang: wrong question
16:02:13 <_23skidoo> oh, that sounds cool
16:02:22 <jjang> i guess i have to code that myself~
16:02:29 <Philippa_> I don't know if somebody's written libraries, but it's not a "built in to the language" thing regardless
16:02:44 <jjang> ah k
16:02:45 <Philippa_> _23skidoo: the do notation is great, it lets you write ordinary imperative code
16:02:47 <_23skidoo> another thing that i miss
16:02:51 <_23skidoo> is open source code in haskell
16:02:57 <Philippa_> er, youwhat?
16:02:58 <Philippa_> there's loads
16:03:00 <_23skidoo> except for darcs I wasn't able to find anything
16:03:00 <jjang> well i just use php for the web for now
16:03:00 <SyntaxNinja> dons: I thought it was wadler who said that
16:03:02 <_23skidoo> :o
16:03:05 <_23skidoo> really?
16:03:12 <_23skidoo> I checked sourceforge
16:03:15 <Philippa_> more libraries than apps, in fairness
16:03:16 <_23skidoo> and nothing turned up
16:03:18 <_23skidoo> aha
16:03:21 <Philippa_> ah. Many of us don't use sourceforge :-)
16:03:33 <_23skidoo> ah, ok
16:03:40 <SyntaxNinja> _23skidoo: all of the open source tools get sucked into the compilers ;)
16:03:48 <Philippa_> if you whois me and hit google, you'll find a wiki clone under the BSD license and a quickie app I use for randomising my sigs in pine
16:03:55 <SyntaxNinja> but Lemmih is working on an open-source package database for Haskell, called "Hackage"
16:03:55 <_23skidoo> Philippa_: the do notation let's you write ordinary imperative code much more painfully than it would be in an imperative language
16:04:00 <dons> SyntaxNinja: i guess it's possible. hmm.. I thought it was in the Awkward Squad paper.
16:04:03 <_23skidoo> oh, cool
16:04:05 <_23skidoo> !
16:04:23 <SyntaxNinja> _23skidoo: link from here: http://www.haskell.org/cabal
16:04:37 <_23skidoo> flippi
16:04:41 <_23skidoo> SyntaxNinja: thanks
16:05:09 <Cale> _23skidoo: well, to really have do notation not bother you, you really should understand what it means, and what monadic functions / control structures are available for working effectively...
16:05:27 <Cale> which is I suppose one thing that catches people off guard
16:05:39 <_23skidoo> we only learnt the very basic stuff about I/O
16:05:40 <dons> SyntaxNinja: google quotes Erik Meijer.
16:05:44 <Cale> (you expect things to be built into the language, when they're just library functions)
16:05:56 <_23skidoo> now that the course finished I want to use Haskell professionally as much as I can
16:05:59 <dons> SyntaxNinja:  but I still think I've seen it in a paper somewhere
16:06:07 <_23skidoo> but I first I need to learn some more stuff on my own
16:06:13 <_23skidoo> (like monadic IO it seems)
16:06:25 <jjang> are there any companies who use haskell ~
16:06:42 <Philippa_> a few, yeah
16:06:43 <_23skidoo> i'm not sure
16:06:46 <SyntaxNinja> jjang: at least two
16:06:51 <SyntaxNinja> dons: I believe you
16:06:52 <Philippa_> Galois Connections and Aetion spring to mind
16:07:00 <jjang> never heard off
16:07:01 <wli> More than two.
16:07:08 <SyntaxNinja> <-- the only guy in the world who has worked at both Haskell companies
16:07:14 <wli> IBM literally gave a Haskell tutorial.
16:07:14 <dons> hehe
16:07:21 <_23skidoo> i work as a freelance programmer, i plan on using haskell at least for my own tools
16:07:23 <SyntaxNinja> wli: really? cool!
16:07:33 <wli> No idea wtf. IBM is using it for, but they saw fit to give a tutorial on their DeveloperWorks website.
16:07:34 <Philippa_> _23skidoo: the do notation is *not* more painful. All you have to remember is that to bind the result of a non-monadic function you need to use return to turn it into a monadic computation
16:07:35 <jjang> u like haskell that much?
16:07:36 <SyntaxNinja> _23skidoo: shapr is a freelance programmer,and aspires to use haskell more
16:07:45 <Philippa_> after that, it beats the shit out of most imperative languages
16:07:45 <wli> SyntaxNinja: This is 2+ years old news.
16:08:01 <_23skidoo> SyntaxNinja: great, perhaps I could talk to him
16:08:13 <jjang> imperative languages require less brain
16:08:16 <jjang> so i like them more
16:08:20 <Philippa_> er, they do not
16:08:24 <SyntaxNinja> less is more
16:08:30 <Cale> jjang: just different brain :)
16:08:41 <jjang> imperative is np for me
16:08:50 <jjang> i can learn any in just a few weeks
16:08:52 <jjang> but this
16:09:02 <jjang> i think i will need at least a few years
16:09:06 <Cale> jjang: well, it's different -- learn prolog and it will be different again
16:09:21 <wli> Cale: Or Mercury =)
16:09:25 <jjang> i dont want ~
16:09:25 <wli> Anyway
16:09:32 <SyntaxNinja> jjang: maybe you're going about learning it wrong
16:09:35 <jjang> one functional language is enough :)
16:09:45 <wli> Doesn't MapleSoft do something they aren't talking about with Haskell?
16:09:52 <Cale> jjang: Prolog is a logical language :)
16:09:53 <_23skidoo> i also loved the lambda calculus too
16:10:04 <jjang> ye i know
16:10:09 <wli> I saw posts from MapleSoft people saying they tutor their new employees in Haskell or something similar.
16:10:13 <_23skidoo> i still wonder how the guy (Church) could invent such a thing
16:10:23 <jjang> but i just failed logics & set theories
16:10:25 <wli> jjang: It's nothing like Haskell
16:10:41 <jjang> im not good in logics ;p
16:10:41 <Philippa_> ah. If you can't do those, you won't get on well with Haskell
16:10:57 <Philippa_> mind you, you'll shoot yourself in the foot every time you try to do something complicated in an imperative language too
16:11:13 <jjang> i can make complicated stuff in imperative
16:11:26 <Philippa_> what's your idea of complicated?
16:11:31 <Philippa_> I hacked up a compiler the other day...
16:11:45 <jjang> oh well im not that advanced
16:11:50 <jjang> im more a web programmer
16:11:50 <wli> Philippa: but what quality of codegen? =)
16:11:54 <Philippa_> (okay, and half the chan are snorting because they know what the compiler looked like, but try cloning it in C++...)
16:12:01 <Philippa_> wli: GHC's quality :-)
16:12:11 <jjang> i code in php/javascript mostly
16:12:16 <Philippa_> you'll be able to read all about it in a couple of weeks
16:12:32 <wli> Philippa: Odd claim.
16:12:54 <Philippa_> wli: Template Haskell is my friend :-)
16:12:58 <wli> Or at least it seems unusual to me for high-quality codegen to be done rapidly.
16:13:00 <Philippa_> (as is doing IO at compile-time)
16:13:25 <wli> Philippa: Is this the thing where you invoke another compiler?
16:13:25 <Philippa_> basically, I did the equivalent of replacing read in a REPL...
16:13:54 <Philippa_> having translated the source language to Haskell (or a representation thereof), yeah
16:14:02 <Philippa_> so like I said, GHC's quality of codegen :-)
16:14:14 <wli> Okay, I would say you called GHC as a library.
16:14:20 <wli> Or similar.
16:14:40 <Philippa_> close, yeah
16:14:53 <dons> Philippa_: did you use hs-plugins make()?
16:14:57 <Philippa_> nope
16:15:01 <Philippa_> just plain TH
16:15:06 <dons> no, right. I guess you can't :)
16:15:09 <Cale> jjang: I wrote a pipeline scheduler for PowerPC and Altivec assembly code in Haskell, which came out to ~1000 lines total, including a parser for our intermediate language for testing purposes, which was about 300 lines.
16:15:11 <wli> I was boggling wondering if this was some kind of newfangled linear-scan register allocator scheme or some such.
16:15:24 <Philippa_> module Main where import Compiler; $(compile "foo.bar")
16:15:33 <dons> Philippa_: yeah. that's cool.
16:15:51 <dons> so you get to use ghci in a nice kind of way
16:15:53 <Philippa_> Cale: cool
16:16:10 <Philippa_> yeah, though I figured a batch file or shell script makes for nice invocation too
16:16:13 <Cale> jjang: It would probably be at least 10 times as long to write in something like Java, and if I wanted to use anything like the algorithm I designed, it would have been incredibly painful.
16:16:31 <wli> I always thought things like GURRR were the way to go.
16:16:31 <Philippa_> the best bit is that the compiler reads almost exactly like an interpreter - the only difference is what you might think of as staging annotations
16:16:49 <wli> Curiously, GURRR is something on the order of a graph reduction approach to codegen.
16:16:58 <dons> Philippa_: is this going to be in shapr's Monad Reader?
16:17:02 <Philippa_> dons: yep
16:17:07 <Philippa_> first article for my column
16:17:10 <dons> cool. look forward to it.
16:17:56 <Philippa_> the source lang is fairly wimpy, mind - a sequence statements that either assign the results of expressions to variables or print results, expressions are basic 4-op arithmetic
16:18:19 <wli> remind me of what the 4th operand is
16:18:26 <wli> I recall 3-op
16:18:35 <jjang> whats a pipeline scheduler~
16:18:35 <Philippa_> er, operator rather than operand
16:18:42 <Philippa_> as in add, sub, mul, div
16:18:54 <wli> Okay, that's not particularly unique.
16:19:34 <Philippa_> no, it's not. The lang was purely a toy for the purpose of demonstration
16:19:37 <wli> It's worthwhile to have a richer set of numerical intrinsics; often trigonometric functions and other things are supplied by the cpu itself.
16:19:46 <jjang> ehm ok what exactly does insertionSort do
16:19:53 <Philippa_> jjang: oh dear...
16:19:53 <jjang> it sorts it by number or ?
16:20:01 <Cale> jjang: Roughly, it's a program which determines a good order to send instructions to the CPU (low-level) in order that data-dependencies are respected (if you need a value, it must be computed first), and such that the machine will execute the code as quickly as possible.
16:20:20 <Philippa_> it sorts by whatever ordering you have to hand (we'll assume by number) by repeatedly inserting items from the list being sorted into an ordered position in a new list
16:20:45 <jjang> ok well i guess by number then
16:20:49 <Philippa_> wli: having any kind of control flow operation at all would've been good :-)
16:20:53 <wli> I should polish off my elliptic function library. I haven't quite gotten to Zeta and Epsilon yet.
16:21:06 <wli> Philippa: CJMP?
16:21:10 <Philippa_> heh
16:21:12 <Philippa_> not even that
16:21:16 <jjang> Cale: u code operating systems or so?
16:21:23 <Philippa_> I figured implementing a language worth using should be left as an exercise to the reader :-)
16:21:55 <Cale> jjang: this was for a compiler for a new kind of programming language which they're working on at McMaster university (Hamilton, ON, Canada)
16:21:55 <ozone> shapr: thanks :)
16:22:05 <samc> Cale, that's cool which processors?
16:22:21 <jjang> ah ok
16:22:29 <Philippa_> Cale: what kind of new?
16:22:33 <jjang> i dont see myself code that kind of stuff later
16:22:35 <Philippa_> or is this NDA material?
16:22:37 <wli> Cale: What kind of language?
16:22:50 <Cale> samc: for now, I think it's PPC G4, G5 -- I heard some murmurs about Cell, but I'm not working there at the moment
16:23:05 <Cale> It's a mathematical description language for signal and image processing
16:23:16 <wli> Cale: we're more concerned about semantics than targets
16:23:17 * Pseudonym reads back
16:23:40 <wli> jjang: I code operating systems.
16:23:56 <wli> jjang: I've worked on 5 different kernels.
16:24:25 <Cale> where the highest level of code written is basically a set of equations involved and what you want, what you have, fairly declarative, and lower levels of code specify increasing levels of detail about the algorithms involved in getting it
16:24:36 <Cale> and the compiler will search for good implementations
16:24:46 <Pseudonym> I'd be curious to know what exactly Alan Perlis liked about the Burroughs machines that's lacking in modern machines.
16:25:12 <samc> Perlis?
16:25:19 <wli> Pseudonym: I'm not an oldbie, so I don't know.
16:25:24 <Cale> http://www.cas.mcmaster.ca/~anand/ -- see coconut
16:25:41 <Pseudonym> Yeah, in the interviews he mentioned that they did better than modern machines when you take Moore's law into account.
16:25:52 <samc> I read the same thing from Kay
16:25:53 <_23skidoo> Pseudonym: you mean Alan Kay?
16:26:02 <Pseudonym> Ah, yes.
16:26:04 <Pseudonym> Alan Kay.
16:26:05 <Pseudonym> You're right./
16:26:08 * Pseudonym was mixing his Alans
16:26:09 <samc> the B5000 Descriptor is online
16:26:16 <Pseudonym> samc: Where?
16:27:21 <samc> http://www.cs.virginia.edu/brochure/images/manuals/b5000/descrip/descrip.html
16:27:33 <wli> I've been meaning to write a simplifier for mathematical expressions that logs its steps. Curiously, doing these things algorithmically can get rather high-flown.
16:27:42 <Pseudonym> Woohoo.
16:27:44 <Pseudonym> Thanks, samc.
16:27:49 <samc> scanned images, I curled it the other day, to see if I could find out, but haven't had a good look
16:28:16 <wli> I had in mind doing it as a something like an interpreter.
16:28:31 <wli> I've spent most of the time trying to come up with methods to parse "IRC math".
16:29:14 <wli> This is rather far from context free. I need some kind of disambiguation engine to decide which of the several parses makes sense.
16:30:41 <Cale> wli: you might use the list monad to model nondeterminism, and filter bad attempts as it becomes obvious after transformations that they were bad.
16:31:32 <wli> Cale: At the moment there isn't a coherent idea of how to decide which ones are good and which ones are bad.
16:31:38 <Cale> but I'm not sure where you'd really begin, after hanging out in #math for a long time, people use pretty varied (and often hard for *me* to parse) notation.
16:32:06 <wli> Cale: Most of that is for more abstract nonsense; this is largely targeted at newbie trig and calc crud.
16:32:06 <Cale> I tend to use a mixture of English and the math symbols which are on the keyboard.
16:33:18 <Cale> So I might write: the integral from 1 to e of dx/x = 1.
16:33:56 <wli> Cale: I've not even seriously thought about those yet; that's a world of pain I'm not prepared to deal with.
16:35:02 <Cale> Some people might write that S(1,e) 1/x dx = 1 -- I find using S to imitate \int (which is also common) is a little grating.
16:35:16 <Cale> but it occurs often
16:35:26 <Pseudonym> Eek.
16:35:32 <Pseudonym> Even Mathematica notation is better than that.
16:36:18 <fraxtal> 
16:36:33 <wilx> English only.
16:36:46 <wli> Cale: That can at least be parsed without natural language processing.
16:36:54 <fraxtal> 
16:37:06 <wilx> fraxtal, English only.
16:37:26 <Pseudonym> wilx: If we're using English, every sentence must contain a verb.
16:37:35 <fraxtal> wahahha
16:37:50 <wilx> lol
16:37:52 <wilx> Right.
16:37:56 <araujo> 
16:38:00 <fraxtal> wilx: You poor, unicode-deprived internet entity.
16:38:18 <fraxtal>   337
16:38:25 <wilx> >_<
16:38:43 <Pseudonym> wilx: And no ASCII Heiroglyphs.
16:38:53 <Pseudonym> Or is it Hieroglyphs?
16:39:03 <wilx> Probably.
16:39:12 <wilx> Well, emoticons are readable.
16:39:34 <fraxtal> wilx: You're just living in the stone age man.
16:39:38 <wilx> The junk I see fraxtal and araujo type is not. Not with my mIRC :)
16:40:15 <Philippa_> there's this little matter of encoding...
16:40:40 <Pseudonym> What's the matter?  Don't you understand plain EBCDIC?
16:40:51 <wilx> Nope.
16:41:04 <samc> unicode may have the cahrs but they are a pain to enter
16:42:24 <wilx> ???
16:42:27 <wilx> Hmm...
16:44:05 <samc> ???? ; Hmm...?
16:45:17 <wilx> I tried to type some Japanese. Won't work with mIRC.
16:46:12 <SamB> Pseudonym: What EBCDIC are you talking about?
16:58:10 <Pseudonym> @foldoc ebcdic
16:58:11 <lambdabot> *** "ebcdic" foldoc "The Free On-line Dictionary of Computing (27 SEP 03
16:58:11 <lambdabot> "
16:58:11 <lambdabot> EBCDIC
16:58:11 <lambdabot>      
16:58:12 <lambdabot>         {Extended Binary Coded Decimal Interchange Code}
16:58:14 <lambdabot>      
16:58:16 <lambdabot>      
16:59:54 <wilx> That doesn't say much.
17:00:58 <samc> Pseudonym, you will find more hints in "the early history of smalltalk" which is online somewhere
17:01:05 <Cale> shapr: could you add a feature to the wiki such that all the recent changes by a particular user could be reverted? Mass-spam is tedious to clean up.
17:01:16 <Pseudonym> samc: OK, I'll take a look.
17:04:16 <Pseudonym> Cale: Do you want some help?  I can take some of them if you want.
17:04:21 <Cale> sure
17:04:30 <Pseudonym> Which ones, so we don't double up?
17:04:45 <Cale> I guess I'll work from the bottom
17:07:42 <jjang> mm
17:07:48 <jjang> cant i do a negative ^ ?
17:08:32 <jjang> i get exception : prelude .^. negative component
17:08:37 <jjang> *exponent
17:09:17 <Cale> try **
17:09:27 <jjang> what u mean
17:09:50 <Cale> ^ is for fast positive integer exponentiation
17:10:08 <jjang> ** is the same but for negative also?
17:10:24 <Pseudonym> Cale: Is that everything?
17:10:30 <Cale> I think so
17:10:33 <Pseudonym> Cool.
17:11:06 <jjang> ah it works now
17:11:34 <jjang> those dots suck if i wanna say they are floats
17:11:48 <Pseudonym> Cale: How do you change LocalBadContent?
17:12:29 <Cale> I have permission to
17:12:51 <Pseudonym> OK.  There was some stuff in UserPreferences.
17:12:58 <Cale> talk to shapr :)
17:13:04 <Pseudonym> :-)
17:13:26 <Pseudonym> Does that work automatically, BTW?
17:13:38 <Pseudonym> Like, does the system detect changes which involve bad content?
17:13:47 <Cale> after you add things, yeah
17:14:07 <Pseudonym> Nice.
17:32:47 <pantorini> howdy!
17:33:13 <Lemmih> Hey
17:33:20 <Lemmih> Learning Haskell?
17:33:56 <pantorini> not really. but i have a really idiot question to make: i don't remember how to convert from float to double
17:34:46 <pantorini> anyone?
17:35:00 <Igloo> realToFrac
17:35:41 <pantorini> argh. that's it. me goes back to hopengl... thanks!
17:36:01 <Igloo> :-)
17:36:12 <pantorini> by the way, does anyone know how to get the projection matrix and modelview matrix from hopengl?
17:37:25 <pantorini> hum. guess not. :-( thanks anyway. see ya!
18:31:08 <a5> hello
18:32:38 <a5> Is there a list somewhere of common equivalences such as: a++b = foldr (:) b a, map f a = foldr ((:) . f) [] a
18:34:13 <CosmicRay> yo yo wazzup in da hood
18:34:57 <CosmicRay> shapr: I think I am going to have to abandon haskelldb.  it is just too buggy to use, I think
18:35:32 <CosmicRay> shapr: https://sourceforge.net/tracker/index.php?func=detail&aid=1123625&group_id=101095&atid=629040
18:35:52 <CosmicRay> shapr: https://sourceforge.net/tracker/index.php?func=detail&aid=1122758&group_id=101095&atid=629040
18:36:00 <CosmicRay> shapr: https://sourceforge.net/tracker/index.php?func=detail&aid=1122530&group_id=101095&atid=629040
18:40:33 <a5> i've been thinking about using haskelldb
18:40:46 <CosmicRay> it's an amazing idea
18:40:55 <CosmicRay> needs a litle more testing for heavy-duty work though
18:42:27 <a5> so far i'm just using a wrapper around the mysql command, about 100 lines, based on popen, returns [[String]], works fine
18:42:48 <CosmicRay> you could at least use HSQL
18:42:56 <CosmicRay> HSQL is basically the equivolent of DBI in Perl
18:43:01 <CosmicRay> it should be easier than using popen
18:43:38 <a5> really? i looked at it and it seemed like a hassle
18:43:48 <CosmicRay> nah, really really easy
18:43:57 <CosmicRay> here's the API
18:44:02 <CosmicRay> basically, you:
18:44:11 <CosmicRay> c <- Database.HSQL.MySQL.connect ....
18:44:22 <CosmicRay> s <- query c "SELECT * FROM ..."
18:45:00 <CosmicRay> forEachRow myfunc s []
18:45:13 <CosmicRay> or even collectRows myfunc s []
18:45:16 <CosmicRay> err
18:45:19 <CosmicRay> collectRows myfunc s
18:47:25 <CosmicRay> myfunc can just call getFieldValue to get the info you need
18:47:26 <CosmicRay> very easy
18:48:03 <a5> so you don't get a lazy list of rows back?
18:48:28 <CosmicRay> a5: no, but a function that gives you that can be implemented in terms of what is there already with about 4 lines of code
18:48:50 <CosmicRay> it gives you slightly lower-level utilities
18:49:03 <CosmicRay> just like one could implement hGetContents in terms of hGetLine
18:49:43 <a5> and what about the column data? is it difficult to extract?
18:49:54 <CosmicRay> trivial really
18:50:05 <CosmicRay> getFieldValue
18:50:10 <CosmicRay> give it a statement and a column name.
18:52:20 <CosmicRay> I suspect it is less code than you are using to parse out the result of mysql
18:52:23 <CosmicRay> and it will be more portable
18:54:40 <a5> parsing could be a toss-up. i don't have to specify column labels now, and few columns are numeric, but when they are i just use 'read'.
18:55:39 <a5> but it's good to know about hsql. it's probably a lot faster for lots of small queries
18:56:37 <a5> also, for things like this:
18:56:38 <a5>             [[min,ave,max,sum]] <- doQuery di $
18:56:40 <a5>                 "select min(a.s), avg(a.s), max(a.s), sum(a.s) from "++ ...
18:57:49 <a5> what would the column labels be? and the code would end up looking pretty repetitive, i'd probably have three occurances of 'min', 'ave', etc. instead of just two each
18:58:25 <a5> "occurrence" sorry
18:58:58 <CosmicRay> I don't know what the labels would be by default, but you can always do min(a.s) AS mincol or whatever
18:59:45 <a5> then make that *four* ;)
19:02:58 <a5> you're right about it being easy to extend though, i didn't think about it when i first looked at it
19:03:37 <a5> i guess it wouldn't be that hard to write something like getFieldValues when all your fields have the same type, since there are functions to get the list of field names
19:51:28 * tmoertel is back from walking his dog (and eating, and doing tax prep)
20:40:43 * shapr yawns
20:40:48 <shapr> good morning #haskell!
20:41:11 <LinkMasterSab> Morning shapr
20:42:18 <Lemmih> Hey shapr.
20:42:23 <shapr> y0 y0!
20:42:30 * Lemmih should really get some sleep.
20:42:34 <shapr> Life is exciting!
20:42:57 <Gahhh> what the monad happened ?
20:44:01 <Lemmih> shapr: I've been recalled for military service /-:
20:45:25 * Lemmih plans to fake a major drug abuse so he can get discarded.
20:45:55 <shapr> yikes
20:46:13 <anyone> Read some Feynman stories.  In one he described how he accidentally got discarded.
20:46:20 <shapr> Can't you do civil service?
20:46:28 <anyone> Perhaps I mean Feymann.  Forgot the spelling.
20:46:46 <shapr> Gahhh: I have a dentist appointment. That's exciting.
20:46:48 <Lemmih> shapr: Sure, but that would also suck.
20:47:04 <Pseudonym> G'day shapr.
20:47:10 <shapr> g'day Pseudonym
20:47:16 <Gahhh> shapr, promise to upload mpg's of your session with him ?
20:47:24 <Pseudonym> Lemmih: According to Mythbusters, poppy seed cake will do the trick.
20:47:38 <shapr> Lemmih: maybe you could get civil service doing programming? Then maybe you'd have more social contacts for doing paying work?
20:48:07 <anyone> It went like this.  The military psychologist checked his sanity.  "Do you talk to yourself?" He honestly answered yes. (We all do, we just don't admit.)  And a couple of other questions that he answered naively and got classified as mentally unfit.
20:48:31 <Pseudonym> anyone: I remember that.
20:48:41 <Pseudonym> It reminds me of the story of Randal Schwartz.
20:49:12 <Pseudonym> He was working as a conslutant for Intel.
20:49:38 <Gahhh> mm consluts
20:49:48 <anyone> haha
20:49:52 <Pseudonym> And he decided to run a password cracker (amongst other things) to show how bad their security was, to get more work.
20:50:01 <Pseudonym> Intel found him out and called the police.
20:50:06 <Gahhh> ahahah
20:50:17 <Pseudonym> Example from his interview:
20:50:25 <Pseudonym> <Police> Did you do this for personal gain.
20:50:48 <Gahhh> Yes lol
20:50:49 <Pseudonym> RandalScwartz thinks about that; he wanted to keep his job at Intel, so...
20:50:55 <Pseudonym> <RandalSchwartz> Yes.
20:51:01 <Pseudonym> :-)
20:51:22 <Gahhh> did he get off the hook eventually ?
20:51:32 <anyone> This world is set up to be hard on us logical and honest people.
20:51:41 <Pseudonym> No.
20:52:00 <Pseudonym> http://www.lightlink.com/spacenka/fors/ <- the story
20:52:20 <Gahhh> Well, I think any company would be at least nervous about unauthorized probing of their security.
20:52:50 <shapr> Problem is that it only upsets them when their employees do it.
20:53:23 <Gahhh> no, it upsets them any time they find out about it.
20:53:52 <shapr> I was once a 'hacking epidemic' at the college I attended. I went around finding really obvious holes and telling the sysadmins about them.
20:54:26 <Gahhh> Our data security people issued me a certificate. Then they told me that I could sent it to my hotmail account, then download it from home. I told them somebody could launch a dictionary attack on it. lol.
20:54:35 <shapr> I got in a lot of trouble, was threatened with expulsion.
20:56:27 <shapr> and they didn't fix the holes :-(
20:56:58 <Lemmih> shapr: That would be neat, even though that kind of work is almost always really boring.
21:00:07 <Lemmih> They don't give funny work to high school dropouts, for some reason (:
21:02:55 <shapr> aha, a5 was frederik
21:04:06 * shapr is wearing his EuroHaskell t-shirt
21:04:56 <shapr> So, who's coming to EuroHaskell?
21:05:39 <Lemmih> Me!
21:05:45 <LinkMasterSab> shapr: Far too far away from me
21:06:07 <shapr> LinkMasterSab: maybe EuroHaskell-US?
21:06:08 <Lemmih> With uni, laptop and everything.
21:07:08 <shapr> spiffy
21:08:06 <LinkMasterSab> shapr: Probably not, I don't have the transportation
21:09:05 <LinkMasterSab> http://zenprogramming.blogspot.com/ <- Updated it from yesterday.
21:59:50 <Pseudonym> Must go.  Nytol.
22:04:03 <shapr> hej magnus-
22:13:38 <Gokee2> He anyone here want a gmail account?
22:14:37 <anyone> No.
22:14:42 <LinkMasterSab> I've got one already.
22:14:48 <LinkMasterSab> And like 1000 invites.
22:16:12 <Gokee2> seidan, What is that?
22:16:27 <Gokee2> seidan, Well?
22:16:57 <seidan> Gokeee2: sure. erm.. please
22:18:00 <Gokee2> please what?
22:18:06 <Gokee2> Load is on my computer?
22:18:09 <Gokee2> lol
22:18:39 <Gokee2> In a few weeks before I do an overhall of my windows side of things
22:18:44 <Gokee2> :)
22:18:45 <Gokee2> lol
22:25:53 <shapr> hiya SyntaxNinja
22:30:55 <musasabi> morning
22:31:26 <musasabi> SHA1 going away sounds sad...
22:31:58 <shapr> yeah it does.
22:32:21 <shapr> More interesting question is how they broke it, whether it's generalizable to other hashes.
22:32:54 <shapr> Less interesting question is how many places will need to rip out code and change stuff (everything based on Java X.509 cryptolibs from Sun)
22:33:08 <musasabi> yes.
22:33:15 <musasabi> and what to use in the place.
22:33:45 <shapr> If it's generalizable, do we need to completely change how hashes work? If not, does this attack generalize to any other hashes?
22:34:08 <musasabi> I think it is only on SHA1
22:34:39 <shapr> Speaking of effing the ineffable, I don't understand Conor's idiom construction.
22:39:54 <shapr> Cale: I've asked the moin folks for a solution. If nothing presents itself, this will be good motivation to switch to Flippi and write a bunch of plugins of this sort.
22:41:38 <SyntaxNinja> hiya
22:41:51 <SyntaxNinja> tmoertel: was that your idea to dump the shell scripts? I really like that idea :)
22:42:10 <shapr> I still quoted your original response to tmoertel
22:42:27 <shapr> "The compiler writers would fly here from england and kill me if I did that"
22:43:26 <SyntaxNinja> shapr: hehe... that was if I added it to _all_ the commands.
22:44:00 <SyntaxNinja> I actually asked permission, and simonMar gave me the "I won't kill you" response, so I think I'm safe.
22:46:06 <SyntaxNinja> does anyone know how the heck hugs pulls its libraries from the fptools tree?
22:46:12 <LinkMasterSab> How is Haskell with threads? It seems to me that it'd be great at them, seeing as how you don't have to worry about screwing things up with side-effects
22:46:55 <musasabi> GHC has soft threads, which are very fast.
22:47:24 <LinkMasterSab> Excellent
22:53:13 <SyntaxNinja> I can't figure out how to coax hugs into picking up the changes I just committed
22:57:14 <shapr> People always told me my karma would come back to haunt me.
22:57:40 <LinkMasterSab> shapr: I have updated the blog that I started last night
22:57:44 <karma> sure it is
22:57:45 <shapr> spiffy
22:57:54 <shapr> karma: hiya, looking for Haskell info?
22:58:14 <karma> shapr: hi, no, just trying to be part of haskell community :)
22:58:33 <shapr> karma: greetings and salutations! welcome to the world of those pure in thought!
22:58:42 <karma> shapr: thanks!
22:59:09 * LinkMasterSab hides the fact that he surfs porn on many an occasion
22:59:18 <LinkMasterSab> Lest I be unpure in thought
23:00:00 <shapr> Well, I guess that's less likely to have side-effects than unprotected sex.
23:00:09 <LinkMasterSab> Yes.
23:01:32 <shapr> hi karma
23:01:33 <SyntaxNinja> I figured it out... cvs is mistifying
23:01:51 <karma> hello :)
23:03:02 <shapr> karma: do you write Haskell code?
23:03:57 <karma> shapr: hmm, i was writing some, didn't code haskell for a while, but i'm big fan of ML languages
23:06:44 <karma> haskell uses bootstrapping, right ? is it possible to compile it using linux binaries in freebsd ? freebsd have binary compatiblity with linux...
23:12:19 <SyntaxNinja> surely there are binaries for freebsd, or its in the ports system
23:12:32 <SyntaxNinja> haskell's not an ML language! ;)
23:14:27 <karma> SyntaxNinja: i have slow connection and don't want to download that stuff, and i have debian mirror in my LAN, so i want to use linux binaries for compiling on freebsd :)
23:15:36 <karma> SyntaxNinja: isn't ML language synonym for functional language ?
23:17:44 <SyntaxNinja> karma: no, ML is an example of a functional language
23:18:44 <karma> SyntaxNinja: ok then :)
23:19:27 <musasabi> and ML is not pure ;)
23:22:52 <SyntaxNinja> karma: ML is a nice one, as is a derivative, OCaml (note the ML at the end :) )
23:23:23 <SyntaxNinja> but haskell shares a lot with ML, more than most languages, and definitely more than lisp or scheme
23:24:08 <karma> SyntaxNinja: i can understand that, i was programming lisp, scheme and haskell
23:26:28 <magnus-> Is there any language like haskell but without strict typing... ie a pure dynamic language?
23:26:37 <shapr> there's Joy
23:26:54 <magnus-> ahh, but that's concatenative
23:27:07 <shapr> Still, it is pure.
23:27:08 <magnus-> i was thinking of mainly applicative languages
23:27:11 <shapr> ah
23:27:11 <magnus-> right
23:27:18 <LinkMasterSab> Python ;o it shares list comprehensions.
23:27:27 <LinkMasterSab> And uh... that's it
23:27:32 <shapr> Python isn't pure.
23:27:39 <LinkMasterSab> shapr: Far from it, it's imperative
23:28:09 <shapr> Yup, I've used Python some.
23:28:18 <LinkMasterSab> I adore Python.
23:28:28 <shapr> Python was my first love...
23:28:40 <shapr> but now.
23:28:55 <karma> Python is good at object-oriented programming and it have clear syntax
23:29:04 <magnus-> While i'm happy to code in a mostly-functional style in lisp it would be interesting to see what it would be like to use a pure language while still keeping the dynamism
23:29:12 <LinkMasterSab> It's just about as straightforward as you can get.
23:30:10 <shapr> Python's OOP model could be better (like that in Ruby) and the syntax is quickly becoming cluttered (what do you think of new decorator syntax? ever heard of it?)
23:30:22 <LinkMasterSab> I think it's handy
23:30:34 <LinkMasterSab> But it does muck up the syntax
23:30:43 <shapr> Oh, I agree. And I make 95% of my income from writing Python. But it's not perfect. (neither is Haskell, of course)
23:31:02 <LinkMasterSab> Nothing's perfect.
23:31:10 <shapr> I really liked the syntax in python 1.5, that was something I could teach to a newbie in eight hours.
23:31:26 <shapr> Nowadays, I have to search the manual for syntax occasionally when hacking on Zope.
23:31:42 <LinkMasterSab> Hehe, well, 1.5 doesn't have nearly the features that 2.4 has, that much can be said
23:32:20 <shapr> I agree that the implementation features are nice (finally I can subclass builtins, C classes, etc) but I don't like the complication of the syntax.
23:32:25 <LinkMasterSab> A compilable Python would be very nice to have
23:32:48 <shapr> Haskell's type system has been somewhat applied to Python. Have you seen Michael Salib's Starkiller?
23:32:58 <LinkMasterSab> Hmm, I might have
23:32:59 <shapr> There's also PyPy, Pyrex, Psyco, etc
23:34:15 * LinkMasterSab nods.
23:34:29 <LinkMasterSab> Psyco does have terrible overhead though
23:35:25 <karma> someone heard about REFAL?
23:36:34 <LinkMasterSab> Oh man, I love this presentation for Starkiller, it's great
23:36:41 <LinkMasterSab> OTHER LANGUAGES SUCK
23:36:51 <LinkMasterSab> + Java sucks beyond all measure and comprehension
23:36:54 <LinkMasterSab> +etc
23:36:58 <shapr> Which of course got Michael Salib invited to EuroHaskell just after EuroPython 2004
23:37:21 <LinkMasterSab> Hehe
23:37:48 <shapr> He's cool, I gotta go to Boston to hang out with him.
23:37:56 <LinkMasterSab> Ex-girlfriends say I'm insensitive
23:37:59 <LinkMasterSab> Haha.
23:41:29 <LinkMasterSab> There is only one logical solution: we must destroy the sun.
23:41:39 <LinkMasterSab> He's brilliant.
23:41:48 <shapr> That's not too hard to do actually....
23:42:05 <shapr> But I'll leave details as an exercise for the reader.
23:42:16 <LinkMasterSab> XD yes.
23:42:37 <LinkMasterSab> I think Java is called Java because it keeps programmers up at night wondering what in the hell is wrong with them for learning Java.
23:43:18 <LinkMasterSab> The next step in programming: intentional programming
23:43:35 * shapr isn't convinced
23:43:36 <LinkMasterSab> You give the language a description, and it does what it thinks you intend
23:43:51 <LinkMasterSab> Because it is SMART.
23:44:04 <LinkMasterSab> Oh man. We'd be out of jobs.
