00:13:31 * shapr burbles
00:41:22 <tuomov> properly converting from svn to darcs use a huge job..
01:27:35 <lightstep> is there difference between `newtype' and `data' with one constructor, except for lazyness-related effects?
01:41:03 <musasabi> What is the direction of threads inside GHC rts? --enable-threaded-rts is deprecated in new ghc...
01:58:03 <Itkovian> I've got a 'parser' (in Java) which takes a file with in it a trace of functions that have been called. On a line is either data at the moment of entering the function, or when exiting the function. I am trying to rewrite this is haskell (the Java solution isn't mine). What would be a good datastructure to keep track of the 'stack', that is simulated by entering and exiting methods? Furthermore, I also need to be able to subtract values of the hig
01:58:03 <Itkovian> her items on the stack from the lower items (of the stack grows upward)
01:58:42 <Itkovian> I can parse the lot, and write out lines where I subtract the entry data from the exit data.
01:59:01 <Itkovian> But I've no immediate clue on how to proceed from there, haskell-wise.
01:59:19 <boegel> hi Itkovian :)
01:59:46 <Itkovian> yeah.
01:59:59 <Itkovian> I'll drop my code on the wiki
02:00:05 <Itkovian> @wikie IrcPastePage
02:00:05 <lambdabot> Sorry, I don't know the command "wikie", try "lambdabot: @listcommands"
02:00:08 <Itkovian> @wiki IrcPastePage
02:00:08 <lambdabot> http://www.haskell.org/hawiki/IrcPastePage
02:00:32 <musasabi> Itkovian: a stack is simply a list.
02:00:33 <Itkovian> hmm
02:00:44 <Itkovian> musasabi: yes, that how I use it.
02:01:10 <musasabi> Is your code monadic?
02:01:29 <Itkovian> when the top is popped, I need to adjust the lower regions too. well, at least the new top
02:01:40 <Itkovian> musasabi: I don't think so ;-)
02:01:46 <musasabi> why?
02:01:49 <Itkovian> still got to wrap my head around monads
02:02:08 <musasabi> that is why/how do you need to adjust it.
02:02:38 <Itkovian> well, simply put, I;ve got a number of lines containing a method id and the number of instructions exectued at that point
02:02:41 <Itkovian> i.e.
02:02:50 <Itkovian> 1:1000
02:02:54 <Itkovian> 2:1200
02:03:03 <Itkovian> 2:1300
02:03:06 <Itkovian> 1:1800
02:03:18 <Itkovian> where the first two are entries (forgot the tag) and the latter are exits.
02:03:48 <musasabi> so you need only to write such a log out to a file?
02:03:50 <Itkovian> so, 1 executes 800 instructions, but without it's children it executes only 700 instructions
02:04:07 <Itkovian> nope, I've got the log, it needs conversion.
02:04:26 <musasabi> ok.
02:04:27 <Itkovian> and the Java stuff does too much and is hard to adapt rapidly.
02:05:03 <Itkovian> so I figured, hey, let me type for 20 mins, and put out a haskell thingie, but heck, I'm at it for 30 mins now, and I still haven't figured out how to do the neat stuff.
02:06:26 <musasabi> One problem is that that log does not tell enough information.
02:07:42 <musasabi> e.g. void foo(bool flag) { if(flag) { bar(true); } void bar(bool flag) { if(flag) bar(false); else { foo(false); exit(); }
02:07:49 <musasabi> where foo=1, bar=2
02:08:00 <Itkovian> oh, but it does.
02:08:05 <Itkovian> the code is up at http://www.haskell.org/hawiki/HaskellIrcPastePage
02:08:12 <Itkovian> exaple log entires are:
02:08:26 <Itkovian> CE:10:4234:99108646:45810167:12734:5152
02:08:26 <Itkovian> CR:10:4234:170279209:38451245:8579:3065
02:08:33 <musasabi> ok, then it works.
02:08:38 <Itkovian> which stands for 'Compiler Entry and Return'
02:09:03 <Itkovian> tag:threadid:methodid:valuelist
02:09:25 <Itkovian> ignore the fact that these values may be fubar ... as 3065 < 5152
02:10:49 <Itkovian> at the moment, assume that all thread ids are equal :-)
02:11:09 <Itkovian> as I should need separate stacks for each thread.
02:15:08 * boegel leaves
02:50:05 <jadrian> @paste
02:50:06 <lambdabot> Sorry, I don't know the command "paste", try "lambdabot: @listcommands"
02:50:15 <jadrian> @wiki paste
02:50:15 <lambdabot> http://www.haskell.org/hawiki/paste
02:56:18 <jadrian> http://www.haskell.org/hawiki/HaskellIrcPastePage?action=show
02:56:33 <jadrian> wouldn't the alternative be better in terms of garbage collection?
02:58:35 <jadrian> hmm wait
02:58:56 <jadrian> let me rethink that
03:08:43 <Itkovian> jadrian: are you talking to me?
03:19:27 <jadrian> Itkovian: I was thinking out loud and made a past on the irc paste page, but I decided to think more about it, I was wondering about the function take
03:20:22 <jadrian> suppose I have a list producer that depends on a large data
03:20:44 <araujo> Good morning here-
03:20:50 <jadrian> let xs = producer data
03:21:24 <jadrian> and I'm going to,   consume (take 1 xs)
03:21:42 <jadrian> when will xs be garbage collected?
03:22:22 <jadrian> by looking at ghc sources my guess would be
03:22:33 <jadrian> "after element 1 is consumed"
03:22:51 <jadrian> which is when the consumer gets an empty list when trying to consume
03:22:58 <jadrian> but it could have been
03:23:16 <jadrian> "after the element is produced"
03:23:42 <jadrian> if take considered the case  n == 1 and returned [x]
03:23:55 <jadrian> instead of just pattern matching []
03:24:03 <jadrian> am I wrong?
03:24:09 <jadrian> I araujo
03:24:11 <jadrian> hi araujo
03:24:59 <Itkovian> ah, and u ask me?
03:25:02 <Itkovian> lol
03:25:24 <jadrian> I was asking the all mighty #haskell :)
03:25:37 <jadrian> "almighty"
03:25:56 <Itkovian> :-)
03:25:56 <jadrian> (my english is sucking today)
03:27:06 <jadrian> this wouldn't take into account the case when you have a singular list and n>1, but that optimization would lead to a diiferent evaluation order
03:27:16 <jadrian> still, pattern matching 1 wouldn't
03:30:53 <araujo> Hello jadrian
03:31:00 <lightstep> lazyness isn't natural, and almost never works well on the first time
03:33:43 <Calister[uni]> morning (or so)
04:06:24 <musasabi> What alternative profiles are there for ghc than -prof - the output (http://youzen.b2.fi/~musasabi/prof.txt) does not help very much...
04:07:45 * Calister[uni] got no clue
04:09:08 <Lemmih> musasabi: Adding some cost centres might help.
04:13:48 <musasabi> true.. have to hack that a little bit up.
04:14:27 <glimming> What's wrong with >  type (f :-+-: g) t o1 o2 = Either (f t o1 o2) (g t o1 o2)
04:17:10 <jadrian> ok, I've sent the question to the ghc mailing list...
04:17:41 <jadrian> maybe I'll understand better how garbage collection works...
04:21:33 <glimming> I get parse error from the above type from :-+-: although ghc accepts it if I use data
04:21:59 <wilx> @type type
04:22:04 <lambdabot> bzzt
04:22:10 <wilx> @info type
04:22:17 <wilx> ...?
04:22:32 <glimming> maybe it crashed again?
04:22:59 <glimming> So I cannot use special symbols in type?
04:23:37 <wilx> Oh.
04:23:39 <wilx> Hm.
04:24:02 <jadrian> glimming: yes you can
04:24:10 <glimming> What's wrong then?
04:24:13 <jadrian> glimming: that is, there is nothing special about those symbols
04:24:24 <glimming> (in ghc)
04:24:26 <wilx> Hmm..., isn't type like alias for a type?
04:24:38 <glimming> yes
04:24:40 <jadrian> type A (f g) t o1 o2 = Either (f t o1 o2) (g t o1 o2)  <-- wouldn't work too
04:24:47 <jadrian> because of the parentheses
04:24:55 <wilx> So, where is the name of the type in your line?
04:25:09 <glimming> :-+-:
04:25:14 <glimming> It is defined infix.
04:25:23 <jadrian> I see no way around it, so that you can define that... :-/
04:25:24 <wilx> That is an operator/function.
04:25:30 <wilx> Types start with capital letter iirc.
04:25:31 <glimming> type (f :-+-: g) t o1 o2  = ...
04:25:43 <jadrian> with a letter for a constructor it would be easy beause you don't need parenthses
04:25:52 <jadrian> but in your case I don't know
04:26:14 <glimming> it works for data, adding a constructor name only
04:26:16 <edwinb> You can have infix type constructors that start with a : ...
04:26:28 <wilx> ...
04:27:01 <glimming> wilx: I do not understand what you mean this is an operator. It is an ALIAS.
04:28:06 <wilx> Hmm, I think it is all wrong. Left of = in type declaration is type's name and type parameters, types start with capital letter. Right of the = there is the type expression that you want to define an alias for.
04:28:24 <wilx> Again, type's name has to start with capital letter as far as I know.
04:28:53 <glimming> So what is the capital letter of ;-+-: ?
04:29:39 <glimming> I do not understand, wilx
04:30:13 <wilx> (I am no good in explaining things.)
04:30:40 <edwinb> Infix type constructors must start with a :, if I remember rightly...
04:30:40 <glimming> type synonyms must be completely applied I think.
04:30:58 <glimming> No, edwinb, I think that the problem is that type synonyms must be entirely applied.
04:31:04 <glimming> And therefore this does not work.
04:31:09 <glimming> Maybe there is a way around it somehow,.
04:31:36 <wilx> Maybe you want something like (untested): data MyType = :-+-: f g t o1 o2
04:32:02 <Calister[uni]> anybody here wanna take my exam? :s lambda calculus (ok, i like that part), haskell (trees mainly i suppose, instances, and so on) ?
04:32:25 <glimming> Well, I could write data (f :-+-: g) t o1 o2 =Either2 Either (f t o1 o2) (g t o1 o2)
04:32:44 <glimming> but it is a bit annoying with a lot of constructor names hanging around
04:33:52 <Lemmih> musasabi: What about compiling with -auto?
04:33:58 <wilx> Well, I think you hare misunderstanding the difference between types and data constructors. Unless of course Haskell has changed in this respect somehow since I've last used it.
04:35:17 <kosmikus> wilx: in GHC, you can have infix type constructors, starting with a :
04:35:40 <glimming> but not type synonyms?
04:35:45 <kosmikus> wilx: infix data constructors starting with : are available even in Haskell 98
04:36:09 <glimming> (but not hugs at least not without parameters)
04:36:13 <kosmikus> glimming: probably, you can have infix type synonyms too, but didn't you say the problem in your case was that it's not fully applied?
04:36:29 <wilx> Hmm, could you point me to a relevant page of GHC docs?
04:36:55 <glimming> Yes, I think so. It is still really annoying to have too many constructors around, is there no way of defining :-+-: from Either?
04:37:32 <musasabi> Lemmih: I used -auto-all. I traced it back to GHC.Conc, and copied a version so I would get better reporting.
04:37:34 <wilx> Oh, found it.
04:37:35 <kosmikus> http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#AEN8592
04:37:36 <kosmikus> 7.1.4.2
04:39:21 <glimming>  going back to type (f :-+-: g) t o1 o2 = Either (f t o1 o2) (g t o1 o2)
04:39:44 <wilx> Hmm, Haskell has become too fast moving target for me :)
04:40:12 <wilx> glimming, sorry for the confusion :)
04:40:53 <glimming> wilx, it is healthy
04:42:14 <glimming> Maybe one could use some other type synonym to distribute the arguments t o1 o2 somehow?
04:45:19 <glimming> (another side-question: can we use composition in data type definitions e.g.   data Something = Anything . Nothing) ?
04:53:58 <musasabi> How are foreign import {safe, threadsafe} different ?
04:54:09 <boegel> hey people
04:54:09 <Itkovian> boegel!
04:54:09 <boegel> is there a standard function which shuffle's a list ?
04:54:09 <boegel> as in shuffle [1..9] = [2,5,4,7,9,1,3,5,8] (for example)
04:54:09 <boegel> Itkovian!
04:54:09 <boegel> @index shuffle
04:54:09 <lambdabot> bzzt
04:54:09 <Itkovian> I recall some permutation stuff somewhere ...
04:54:10 <Itkovian> but that won't be random
04:54:11 * Itkovian thinks his code is almost as ugly as perl.
04:54:11 <glimming> kosmikus, so maybe I can use forall here?
04:54:12 <boegel> Itkovian: it doesn't need to be random really...
04:54:15 <Itkovian> hmmm
04:54:16 <glimming> type (f :-+-: g) = forall t. forall o1. forall o2. Either (f t o1 o2) (g t o1 o2) would be a very big mistake??
05:02:43 <Philippa_> glimming: depends whether that gives the kinds you intended or not, dunnit?
05:04:03 <glimming> type (f :-+-: g) = forall t. forall o1. forall o2. Either (f t o1 o2) (g t o1 o2) gives me a parse error on :-+-: again
05:04:13 <glimming> (previously there was also a parse error!)
05:04:17 <glimming> I wonder what this is...
05:05:24 <Philippa_> *shrugs* evidently too early in the morning for me
05:07:30 <kosmikus> glimming: you're not allowed to have parentheses on the lhs, I think
05:08:23 <glimming> so I better set priorty of :-+-: very high, e.g. 9 then?
05:09:29 <kosmikus> this has nothing to do with the priority
05:09:47 <kosmikus> type f :-+-: g = ..., not type (f :-+-: g) = ...
05:09:49 <araujo> Good morning kosmikus
05:10:09 <kosmikus> the parser should accept your input, but it doesn't
05:10:31 <glimming> maybe a bug!!! yeah I have done it.
05:12:35 <glimming> >  type f :-+-: g t o1 o2   = Either (f t o1 o2) (g t o1 o2)   still gives me a parse error on t
05:13:24 <TheHunter> do you want type (f :-+-: g) t ... ?
05:16:10 <glimming> again, brackets fails.
05:16:14 <boegel> @index IORef
05:16:14 <lambdabot> Data.IORef,GHC.IOBase,GHC.IOBase
05:16:23 <boegel> @type Date.IORef
05:16:24 <lambdabot> bzzt
05:16:39 <boegel> @type Data.IORef
05:16:40 <lambdabot> bzzt
05:16:45 <boegel> eh?
05:16:49 <TheHunter> @info Data.IORef
05:17:03 <boegel> :)
05:17:14 <boegel> at least it doesn't go 'bzzt' :p
05:17:20 <glimming> it's dead
05:17:34 <TheHunter> @info Data.IORef
05:17:37 <boegel> @type Data.IORef
05:17:38 <lambdabot> bzzt
05:17:42 <boegel> hehehe :)
05:17:43 <Itkovian> heh
05:17:44 <glimming> Hehe
05:17:46 <boegel> @info Data.IORef
05:17:49 <TheHunter> @info id
05:17:50 <lambdabot> -- id is a variable
05:17:50 <lambdabot> id :: forall a. a -> a
05:17:56 <glimming> not terminating.
05:17:56 <Itkovian> there ya go!
05:17:56 <boegel> strange
05:18:01 <glimming> Maybe you ought to move to Martin-Löf type theory.
05:18:01 <boegel> :D
05:18:21 <TheHunter> omg!
05:18:25 <TheHunter> @info Data.IORef.IORef
05:18:26 <lambdabot> -- GHC.IOBase.IORef is a type constructor
05:18:26 <lambdabot> newtype GHC.IOBase.IORef a
05:18:26 <lambdabot>     = GHC.IOBase.IORef (GHC.STRef.STRef GHC.Prim.RealWorld a)
05:19:40 * boegel scratches his hair
05:20:10 <bourbaki> moin
05:20:13 <boegel> hey bourbaki
05:22:04 <bourbaki> does anyone of you happen to know a program with which i can save rm streams?
05:22:21 <Itkovian> mplayer?
05:22:29 <bourbaki> for windows
05:22:31 <Itkovian> or am I completely off track here?
05:22:36 <Itkovian> I am.
05:22:38 <bourbaki> you can do that with mplayer
05:22:39 <Itkovian> nope.
05:22:50 <Itkovian> I mean. nope for winblows.
05:22:51 <bourbaki> but when i tried it a while back it was a pain in the ass
05:23:01 <Itkovian> trying using a plate.
05:23:08 <Itkovian> I'm told it helps
05:23:17 <bourbaki> there is streambox vcr but it wont run properly
05:23:19 <boegel> Itkovian: :o
05:23:37 <bourbaki> a plate?
05:25:21 <kosmikus> hi araujo
05:25:31 <Itkovian> yeah. to protect yr ass.
05:25:41 <Itkovian> it's a common joke in Flanders.
05:25:58 <Itkovian> albeit a bit homophobic in origin.
05:26:08 <Itkovian> whis was not intended here
05:26:13 <Itkovian> s/whis/which/
05:27:15 <boegel> shame on you Itkovian
05:27:34 <boegel> they'll start thinking we're all nazi's (again)
05:29:26 <bourbaki> who will what :)?
05:30:29 <boegel> last year (or so), some tv-show in America made clear to be people that everyone in Flanders is a neo-nazi
05:30:40 <boegel> which is not true (of course)
05:31:08 <bourbaki> ?
05:31:24 <bourbaki> did the us declare war on your country?
05:31:53 <bourbaki> i think they did that cause they know flanders from the simpsons
05:32:01 <bourbaki> and homer didnt like him as well
05:32:27 <boegel> I can't remember which tv show it was
05:32:39 <boegel> but I guess it had to do with the 'Vlaams Blok'
05:32:49 <bourbaki> whats that?
05:32:54 <boegel> a political party here which tricks people into voting for them
05:33:13 <boegel> something like Haider in Austria
05:33:20 <bourbaki> aha
05:35:26 <bourbaki> you dont have to believe in what they say in us politics magazines especially if they relate so some country outside of the us ;)
05:35:32 <Itkovian> yeah.
05:35:43 <Itkovian> there are some dumb suckers walking around in our cities though.
05:35:57 <Itkovian> and they'll be the first against the wall when the revo ...
05:35:59 <Itkovian> aaah.
05:36:06 <Itkovian> did I say that?
05:36:13 <boegel> hehe
05:36:32 <boegel> there are some dumb fuckers around here idd
05:37:02 <Itkovian> I don't know if they fuck ... that would require at least two braincells
05:37:19 <Itkovian> ayway, somebody's gonna kick me off for using the f word
05:37:47 <Itkovian> weird how the ouside world sometimes has a totally wrong image of us
05:37:59 <Itkovian> but the above statements prolly don't help too much
05:38:19 <boegel> :)
05:38:32 <boegel> I think we have a wrong image about the us too
05:43:39 <Itkovian> prolly.
05:43:47 <Itkovian> but not about their govt.
05:46:25 <vincenz> od
06:00:39 <vincenz> aha een BELG
06:01:45 <boegel> hehe :)
06:01:57 <Itkovian> welwel
06:02:05 <Itkovian> twee zelfs
06:02:10 <Itkovian> (two even)
06:05:32 <vincenz> ahbon
06:11:26 <boegel> I there a way to allow more than 1 line in a -> clause in case ... of ?
06:12:34 <Igloo> "line"?
06:12:59 <boegel> as in
06:13:03 <boegel> case bleh of
06:13:09 <boegel>        True -> foo
06:13:11 <boegel>                 bar
06:13:21 <Itkovian> foo; bar?
06:13:45 <Igloo> That doesn't make sense (except as the application of foo to bar)
06:13:55 <Igloo> Do you want monadic code?
06:13:58 <Igloo> What are foo and bar?
06:14:06 <boegel> lines of code
06:14:10 <Itkovian> Igloo: I always wondered about that ...
06:14:20 <Igloo> What do they do, though?
06:14:51 <boegel> Igloo: suppose foo = putStr "foo", bar = "putStr "bar"
06:14:52 <xerox> do ?
06:15:01 <Igloo> Right, you want monadic code then
06:15:05 <Igloo> True -> do foo
06:15:15 <Igloo>            bar
06:15:28 <boegel> okay, but what if they're just functions ? non-monadic ?
06:15:36 <Igloo> Then it doesn't make sense
06:15:44 <Igloo> What happens to the result of foo?
06:15:56 <boegel> hmm, true :)
06:16:07 <boegel> okay, thanks
06:22:59 <glimming> >  infix 9 :-+-:
06:23:00 <glimming> >  type f :-+-: g   = Either f g
06:23:00 <glimming> works
06:23:00 <glimming> but
06:23:16 <glimming> >  infix 9 :-+-:
06:23:16 <glimming> >  type f :-+-: g t   = Either (f t) (g t)
06:23:17 <glimming> does not
06:23:26 <glimming> I.e. arguments not allowed???
06:24:05 <wilx> What about   infix 9 :-+-: \n type :-+-: f g t = etc. ?
06:24:22 <Lemmih> Infix type constructors? wow, didn't knew that was possible.
06:24:31 <glimming> nope that does not work either
06:24:54 <Lemmih> type (:-+-:) f g t = ... ?
06:25:00 <glimming> parse errors.
06:25:22 <glimming> Neither did that work
06:25:49 <glimming> ghc 6.2
06:26:10 <glimming> Is it a problem with the various application on rhs?
06:26:18 <Igloo> hugs doesn't accept the first one
06:26:22 <Philippa_> probably
06:26:32 <glimming> hugs does not support infix -- need ghc extensions
06:27:03 <Igloo> And the fact that ghc rejects (:-+-:) f g makes me think it's a bug
06:27:25 <glimming> Is it not possible that it is due to partial applications are not allowed?
06:27:31 <Igloo> But I haven't checked the report on it
06:29:47 <glimming> "After expanding type synonyms, GHC does validity checking on types, looking for the following mal-formedness which isn't detected simply by kind checking: ... Partially-applied type synonym."
06:29:53 <glimming> But this complains about _parsing_
06:30:08 <glimming> (from ghc type extensions)
06:30:14 <glimming> http://web.mit.edu/ghc/www/users_guide/type-extensions.html
06:30:53 <glimming> This must be a bug? kosmikus?
06:31:13 <TheHunter> there are other strange things going on: type Foo f g x  = Either (f x) (g x), then undefined :: ([] `Foo` []) Int complains about not having a Show instance for "Foo [] [] Int"
06:31:41 <glimming> huh?
06:31:47 <CosmicRay> good morning
06:32:53 <TheHunter> "The lexical syntax is the same as that for data constructors."
06:33:06 <CosmicRay> I remember reading that somewhere.
06:33:08 <TheHunter> I guess it's a bug then because data (:-+-:) f g x = ... works.
06:33:18 <CosmicRay> where are you reading, thehunter?
06:33:33 <TheHunter> good old ghc type extensions page:
06:33:38 <TheHunter> http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html
06:33:45 <CosmicRay> ahh.
06:33:56 <CosmicRay> yes, I remember reading that because I remember puzzling over it :-)
06:35:30 <glimming> This will end up at haskell@haskell.org then. Ok?
06:36:09 <glimming> (is that best for ghc extensions?)
06:36:49 <CosmicRay> probably, or glasgow-haskell-users
06:37:08 <glimming> or both?
06:37:37 <glimming> (I am not good at Internet ethics...)
06:37:59 <TheHunter> i'd say ghc-users.
06:38:04 <glimming> oki
06:38:08 <TheHunter> it's not really a general haskell issue.
06:40:12 <CosmicRay> both lists have quite a large number of subscribers
06:40:21 <CosmicRay> you should be find with just glasgow-haskell-users
06:40:28 <glimming> done.
06:40:37 <glimming> it is a e-World.
06:40:54 <glimming> Anyone know dinatural transformations by the way?
06:41:06 <Itkovian> di-what?
06:41:14 <boegel> natural :p
06:41:56 <CosmicRay> some sort of gay nature thing :-)
06:42:10 <CosmicRay> oh wait, that would be *bi*-natural.
06:48:31 <boegel> hey shapr !
06:48:37 <shapr> hoi boegel
06:49:23 <shapr> My dentist redex has now reached weak head normal form.
06:49:55 <Itkovian> that sounds painful
06:50:11 <shapr> At least my fingers aren't anethesized.
06:50:20 <shapr> ulph: hej!
06:50:29 <shapr> Did I miss anything exciting?
06:50:45 * boegel thinks
06:51:01 <Itkovian> shapr: I've seen jemfinch asking for you on #darcs
06:51:21 <shapr> oh, he wants to discuss monotone....
06:51:54 <shapr> I'm currently participating in fifteen projects. I don't really have time to sleep.
06:52:11 <CosmicRay> shapr: you remind me of Ivanova on Babylon 5
06:52:14 <CosmicRay> (ever seen that show?)
06:52:19 <shapr> nah, who's Ivanova?
06:52:33 <shapr> The sci-fi equivalent of Machiavelli?
06:52:43 <CosmicRay> the Russian on Babylon 5.  One of my favorite quotes from her is, "I really don't have time to chat.  I'm in the middle of 15 things, all of them annoying."
06:52:44 <TFK> shapr, making any games? :D
06:52:50 <shapr> TFK: actually, yes...
06:52:58 <TFK> Coo! Which games?
06:53:01 <CosmicRay> shapr: Babylon 5 is, imho, one of the best series ever on TV
06:53:02 <shapr> IceHouse!
06:53:13 <shapr> CosmicRay: One day, I will sit down and watch the whole thing.
06:53:16 <CosmicRay> shapr: the entire 5-year storyline was laid out in advance
06:53:28 <shapr> That makes sense.
06:53:47 <shapr> Series that don't do that do not make sense.
06:53:54 <CosmicRay> it is really fun to watch.  after a little while, you start watching episodes and guessing what bits of it will come back to haunt people later
06:54:04 <CosmicRay> shapr: such as almost every other scifi series out there :-)
06:54:09 <shapr> yup.
06:54:18 <shapr> I have a few storylines in my head I'd like to film.
06:54:26 <shapr> But I'd rather use machinima.
06:55:07 <shapr> I actually came to #haskell to ask a question.... what was it... ... dang.
06:55:17 <CosmicRay> heh
06:55:52 <Itkovian> any Happy experts here?
06:55:56 <Philippa> Ivanova was great
06:56:01 <shapr> TFK: I've been thinking about a simple physics model that's limited to modeling IceHouse pieces, then you'd have *lots* of games at once.
06:56:38 <Itkovian> say I;ve got data State = Forward | Backward  in module A
06:56:45 <Itkovian> and module A exports State
06:56:51 <Itkovian> and module B import module A
06:57:05 <Itkovian> howcome I cannot say t = Forward in module B?
06:57:07 <shapr> hiya jlouis!
06:57:22 <Philippa> because you need to export the constructors separately?
06:57:28 <shapr> Itkovian: because type /= constructors
06:57:32 <Philippa> (this allows you to have abstract datatypes)
06:58:11 <Itkovian> Philippa: so I just do module A where (State, Forward, Backward) ?
06:58:25 <Philippa> yeah
06:58:41 <ulph> hej shapr!
06:58:48 <Itkovian> doesn't seem teo work, I've tried that :-)
06:58:50 <Lemmih> Itkovian: Or '(State(..))'
06:58:51 <TheHunter> where (State(..)) should be fine
06:59:03 <shapr> ulph: Are you here to learn Haskell? =)
06:59:13 <Lemmih> TheHunter: I WIN! (:
06:59:24 <TheHunter> err, module A (State(..)) where ...
06:59:42 <TheHunter> Lemmih, congratulations!
06:59:51 <Itkovian> rightm that does the trick.
07:00:04 <shapr> Gotta love a channel where people compete to answer your questions first.
07:00:12 <shapr> unlike #java...
07:00:26 <TheHunter> or, ... export everything by leaving out the (...) part.
07:00:55 <bourbaki> TheHunter: sry that i didnt made it here the other day
07:02:08 <TheHunter> bourbaki, np
07:02:47 <bourbaki> TheHunter: i hope ill find the time and we can go through that soon
07:03:10 <bourbaki> just am a bit stressed by work atm and by thinking about writeing an article for a book
07:04:39 <ulph> shapr: How do you mean?
07:05:01 <ulph> shapr: I actually know some :)
07:05:18 <shapr> ulph: Everytime a new person shows up on #haskell I offer to give them an introduction to #haskell and to the Haskell programming language.
07:05:46 <Philippa> it's like OCD, only beneficial
07:05:48 <Itkovian> ah, but shapr, java people don't ask questions, they raise problems
07:05:56 <shapr> Evene to the point that sometimes I get onto IRC and someone new tells me "oh hey, they said you'd give me the tour when you got on"
07:06:05 <Itkovian> heh
07:06:11 <Philippa> Itkovian: that's a nasty thing to say about the children of java people...
07:06:31 <Itkovian> well, I;m half java person meself ...
07:06:50 <Philippa> :-)
07:07:06 <Itkovian> I like it. But only where appropriate.
07:07:07 <bourbaki> argh java
07:07:16 <Itkovian> I like C better tho ;-)
07:07:23 <TFK> shapr, neat :-) planning to code AI, too?
07:07:30 <bourbaki> java is like a castrated c++
07:07:30 <TFK> And one Python to rule them all...
07:07:34 <ulph> shapr: I need to write some haskell till friday actually :)
07:07:35 <shapr> TFK: that would be both scary and interesting.
07:07:46 <shapr> ulph: oh, you're going to submit an article for The Monad.Reader?
07:07:49 * TFK nods
07:07:51 <bourbaki> the only things that made sense in c++ where ripped out
07:08:11 <shapr> I like the subset of Haskell that ended up in STL.
07:08:13 <ulph> shapr: Not really. :)
07:08:37 <bourbaki> haskell ended up in stl?
07:09:08 <shapr> ulph: how about.. "A Demonstration of Haskell Physics Libraries: Unicycle Physics 1.0"
07:09:31 <ulph> shapr: We need to start working on that actually.
07:10:13 <shapr> Yeah, I found some neat papers on unicycle physics on scholar.google.com, but it seems that "unicycle" has a different meaning in the context of robotics.
07:10:32 <shapr> In any case, I'm not taking on any more projects until I've dropped below five.
07:11:16 <bourbaki> shapr: did anyone ever told you that you will never get younger?
07:11:31 <shapr> People keep telling I need to get sleep.
07:11:41 <bourbaki> :)
07:11:52 <bourbaki> so you will never ever add new projects?
07:13:06 <shapr> well actually,  I have a whole bunch of projects I do want to add.
07:13:27 <shapr> But I've realized that I have so many concurent projects that I never have time to finish anything.
07:13:48 <shapr> So I'm hoping to reach a balance where I can pick up a project, hack furiously for a few weeks, then release it and do something else.
07:14:21 <TFK> Leaving the maintenance to some other poor soul?
07:14:37 <shapr> ahem "some other pure soul"
07:14:50 <TFK> hehe
07:15:33 <shapr> Nah, I don't mind coming back to stuff to update it, but I realize I never get any of my own projects released in good form.
07:15:55 <wilx> :)
07:16:08 <wilx> This happens not only to you.
07:16:09 <shapr> Curryspondence is sort of released, but it's way ugly. QuickCheck-TDD is just a hack that needs help. lambdabot is suffering because I don't have time to take care of him.
07:17:10 <shapr> I'd like to organize up a Zope replacement in Haskell so I can switch my paying work away from Python.
07:17:56 <Itkovian> anybody knows of any tools that allow editing postscript figures included in LaTeX?
07:18:02 <ulph> shapr: what is zope exactly?
07:18:26 <TFK> Is FunGEn dead? :o
07:18:48 <Lemmih> TFK: Kinda.
07:19:05 <shapr> ulph: It's a collection of integrated libs. Object database, catalog, i18n, content management (huge amount of code), database plugins, templating languages, security framework...
07:19:27 <ulph> It sounds ... huge :)
07:19:42 <shapr> It's probably even larger than that.
07:20:06 <shapr> Trying to track through the source occasionally drives me to drink.
07:20:17 <ulph> How much does plone add?
07:20:18 <TFK> What about HOpenGL?
07:20:38 <shapr> ulph: another huge layer on top
07:20:59 <Lemmih> TFK: HOpenGL is actively maintained.
07:21:19 <TFK> On the site the last release dates to 03, if I'm not mistaken/blind.
07:21:23 <shapr> ulph: zope has CMF on top, CMF has Plone on top... it's *massive*.
07:21:50 * vincenz taps his head
07:22:08 <Lemmih> TFK: They've discontinued their HOpenGL package. It is now a part of the Haskell standard libraries.
07:22:16 <TFK> Oh!
07:22:46 <Lemmih> TFK: Install GHC 6.4 and it'll be there.
07:23:04 <TFK> I have 6.2.2, actually
07:23:28 <TFK> 6.4 is not even in the Portage tree :-/
07:23:47 <Philippa> shapr: I'd be up for a Zope replacement if only it'd eg cover my living expenses...
07:23:56 <Philippa> well, I'd probably be up for the design discussion anyway
07:24:59 <autrijus> greetings lambdafolks.
07:25:06 <TFK> Are there more "higher level" tools to make games with Haskell?
07:25:53 <Lemmih> TFK: I'm working on a ClanLib binding.
07:25:58 <CosmicRay> TFK: I don't know... I'd ask on haskell-cafe
07:26:01 <Philippa> and Yampa could be cool to play with
07:26:07 <Lemmih> But it wont be ready for months.
07:26:13 <CosmicRay> one thing neat about Haskell is that its C interface is fairly easy
07:26:56 <TFK> Oh..
07:32:36 <TheHunter> wow, i didn't know implicit parameters were that evil.
07:39:24 <Itkovian> woot!
07:39:31 <Itkovian> my first happy parser works.
07:39:35 <Lemmih> Yay!
07:39:43 <Itkovian> now let's tackle parsec :-)
07:40:01 <Philippa> parsec's muchly easy if you're fine with monads generally
07:41:53 <Itkovian> yeah ... dang
07:42:17 <Philippa> if not, just think of the do notation as being a kind of annotated EBNF
07:42:34 <Philippa> stuff in sequence is parsed in sequence, <|> is your branching, return provides the annotations
07:43:30 <Philippa> eg do {op <- (char '*'; return (*)) <|> (char '+'; return (+)); return (op 1 2)}
07:43:49 <Philippa> er, missed a couple of dos there, but you get the point?
07:45:32 <lightstep> What does "multiple declataions of <type>" mean? http://rafb.net/paste/results/EfXNW637.html
07:46:54 <Itkovian> Philippa: I've got the nice docs next to me, printed with our new shiny colour laser printer ;-)
07:46:55 <Igloo> Are you sure it isn't multiple declarations of <data constructor>?
07:47:05 <wilx> Hmm, name of your newtype is the same as name of one of your constructors...
07:47:07 <Igloo> In particular, Mu
07:47:17 <Igloo> wilx: That's OK
07:47:19 <lightstep> Igloo: it is. there is a paste link
07:47:25 <wilx> Is it o_O
07:47:26 <wilx> Yay!
07:48:25 <wilx> I will refrain from trying give advices with my poor knowledge in future.
07:48:42 <lightstep> oh. i get it. i wanted `type', not `data'
07:50:36 <lightstep> but it claims that the "deriving Show" is bad
07:52:12 <Itkovian> lightstep: you cannot/need not derive Show for type aliases.
07:52:32 <Itkovian> lightstep: afaik you show declare the original type/data an instance of Show
07:52:36 <lightstep> it complains about the instance for Mu
07:52:39 <Itkovian> s/show/should/
07:52:46 <Itkovian> wtf is Mu?
07:52:47 <lightstep> but i got it wrong anyway
07:53:22 <lightstep> it's like Y of the type domain (i think). i got the idea from some wiki page, and the evolution page
07:55:52 <shapr> lightstep: btw, I really enjoyed your suggestion ... adding COME FROM to Haskell was a great joke to run with.
07:56:40 <lightstep> i really don't know what INTERCAL does if two statements COME FROM the same location
07:58:56 <mflux> btw.. if you guys have ever heard of AOP..
07:59:02 <mflux> it's all about COME FROM I gather
07:59:32 <shapr> I thought it was all about monads and elisp.
07:59:53 <lightstep> its both: Control.Monad.Comefrom
07:59:58 <TheHunter> lightstep, this problem was recently dicussed on the list http://www.haskell.org//pipermail/haskell/2005-February/015325.html
08:00:53 <shapr> TFK: you have been replaced. Version 2 is in stores now!
08:03:34 <TFKv2> TFK is but a drone of the all-powerful Master.
08:03:42 <TFKv2> About to be replaced, too.
08:03:58 * TFKv2 laughs maniacly
08:04:04 <shapr> Into the bit bucket...
08:07:26 <TFK> The General Introduction to Haskell page should really feature something like "Haskell for imperative noobs".
08:07:33 <TFK> Lots of tutorials are offline, too :-(
08:07:46 <shapr> really?
08:07:52 <Lemmih> TFK: www.haskell.org/complex/
08:08:27 <Lemmih> TFK: That's a tutorial for the imperative noob (:
08:08:28 <TFK> Err, one I couldn't connect to...
08:08:46 <lightstep> thank you, the one who gave me the mailing list links before sawfish crashed
08:09:16 <TFK> But this: http://www.numeric-quest.com/haskell/hcompanion/index.html <--- seems to no longer exist.
08:10:07 <Lemmih> TFK: You couldn't connect to www.haskell.org/complex/ ?
08:10:55 <TFK> That one, too. But that's possibly my ISP playing dirty tricks on me.
08:11:00 <musasabi> Does cabal know how to handle hsc-files ?
08:11:07 <TFK> Ah, success!
08:11:13 <TFK> Thanks, will check it out.
08:11:41 <Lemmih> musasabi: Yes.
08:11:51 <musasabi> nice :-)
08:12:38 <rtega> TFK: try yet another introduction to haskell
08:13:32 * TFK does so
08:13:45 <TFK> But then a lot of tutorials are in .ps/.pdf
08:14:12 <Lemmih> Yeah, isn't it nice?
08:14:15 <lightstep> it says "to non-programmers functional languages offer a smaller semantic gap between the programmer and the language"
08:14:22 <xerox> Lemmih, it depends
08:19:07 <TFK> Woo! So many tutorials besides "A Gentle Introduction" (a misnomer, imho). Thanks!
08:28:17 <lightstep> where can i find the list of directories derectly under haskell.org/
08:28:18 <lightstep> ?
09:23:47 <TFK> getLine doesn't grok backspaces? o_O
09:24:29 <TFK> But it does do weird things with left-right movements along the line o.o
09:24:35 <lightstep> TFK: that depends on console settings, i think
09:24:46 <TFK> Oh. I'm doing it in hugs, so maybe that's it.
09:31:13 <araujo> Hello.
09:31:24 <araujo> Has anyone tested the latest ghc snapshot?
09:31:34 <araujo> stable
09:32:27 * humasect lowers hand
09:35:08 <TheHunter> hmm, does someone know an easy combinatorical problem that can be implemented with the list monads and has few solutions, if any?
09:35:17 <TFK> What's the difference between 'let fname = srcName ++ ".exe"' and 'fname = srceName ++ ".exe"' ?
09:35:51 <TheHunter> the former happens in monads, the latter at the top level.
09:36:42 <TFK> So I must use 'let' in IO monads, but not in function definitions?
09:36:50 <TheHunter> right
09:38:32 <lightstep> TheHunter, find all permutations that satisfy: for every position, the numbers left of that position are contigous
09:39:08 <TheHunter> lightstep, nice, thanks.
09:39:46 * humasect fabricates an attempt at solidifying a working 6.4 rc on cygwin
09:43:19 <lightstep> how can i read a number from stdin?
09:43:23 <TFK> Unfortunatelly, haskell.org/complex only has one "home-made" tutorial :-(
09:43:25 <ski> TFK : though, you can use "let ... in ..." in function definitions  (note the "in")
09:43:40 <desrt> lightstep; a <- getLine
09:43:49 <desrt> lightstep; let num = read a
09:44:01 <TFK> Yeah, there's tons of syntax I don't know at this point...
09:44:02 <lightstep> without reading a whole line :)
09:44:11 <desrt> arf.
09:44:18 <desrt> you have to read a whole line
09:44:22 <desrt> non-optional
09:44:28 <ski> not necessarily, i think
09:44:51 <desrt> if there's a way to ioctl() the terminal then maybe not.  otherwise input is line-at-a-time
09:44:52 <ski> but lightstep'll have to switch to NoBuffering, i'd think
09:45:29 <lightstep> i meant, without the reading action consuming a whole line
09:45:37 <ski> yep
09:45:39 <desrt> lightstep; you have to split the line out
09:46:01 <lightstep> oof. i might as well make my type a Read instance
09:46:08 <desrt> heh.  lexing time :)
09:46:10 <ski> hSetBuffering NoBuffering stdin
09:46:53 <ski> that should enable the program to get at characters before the line has ended
09:47:41 <ski> (i haven't tested it with stdin, though, there might be some reason why it won't work with interactive streams ... dunno)
09:48:55 <lightstep> is there getCharsSatisfying? or should i define my own variant?
09:49:31 <desrt> lightstep; do you know how to write lexers?
09:50:14 <desrt> @type lex
09:50:15 <lambdabot> lex :: String -> [(String, String)]
09:50:29 <desrt> @eval lex "123abcdef"
09:50:29 <lambdabot> unbound variable: lex
09:50:34 * desrt scratches head
09:50:46 <desrt> Prelude> lex "123abcdef"
09:50:46 <desrt> [("123","abcdef")]
09:50:52 <desrt> is this something like what you want?
09:51:09 <lightstep> i want to read only the relevant characters from the file
09:51:55 <lightstep> i don't feel like reading it into a string and lazily scan it
09:51:59 <scp2004> SHA-1 is broken, I'm told. What uses SHA-1?
09:52:10 <desrt> scp2004; hmm.  everything, basically
09:52:21 <desrt> who told you that?
09:52:35 <syntax_syntax> Slashdot.
09:52:39 <desrt> aw fuck
09:52:42 <syntax_syntax> this is the relevant link: http://www.schneier.com/blog/archives/2005/02/sha1_broken.html
09:52:46 <desrt> first md5, now sha1
09:52:56 <lightstep> md5 is broken?
09:53:07 <syntax_syntax> from /. "SHA-1 has been broken. Not a reduced-round version. Not a simplified version. The real thing. The research team of Xiaoyun Wang, Yiqun Lisa Yin, and Hongbo Yu (mostly from Shandong University in China) have been quietly circulating a paper announcing their results...'"
09:54:38 <desrt> there's obviously one correct solution
09:54:43 <desrt> md5 hash the message, then sha-1 hash it
09:54:47 <desrt> and concatenate the results
09:55:05 <desrt> two broken algorithms can be secure together :)
09:55:13 <syntax_syntax> I use ROTn, where "n" is the number I ain't telling ya. :-D
09:56:59 <glimming> Is anyone aware of an IRC channel where category theory experts hang around? Or even algebraists.
09:57:35 <shapr> Man, I love unicycling.
09:57:45 <glimming> I bet you do!
09:58:20 <humasect> =)
09:58:49 <humasect> glimming: #math on EFnet is quite popular and spans many general topics
09:59:07 <glimming> thanks for that!
09:59:47 <TFK> Multiple declarations of I/O monads aren't allowed (i.e. to do pattern matching), right?
10:01:20 <humasect> glimming: you're welcome
10:02:32 <Lemmih> TFK: I don't follow.
10:02:46 <TFK> Mmm.
10:06:27 <lightstep> System.IO doesn't have unGet* !
10:10:47 <TFK> http://spoj.sphere.pl/forum/viewtopic.php?t=25&sid=4ff8e7b303b57b55e9cfd3135b7c36e6 <--- I'm mostly trying to understand this thing. It just spits out the input until it hits "42".
10:13:12 <Lemmih> TFK: Playing with the functions in an interpreter might help.
10:14:48 <lightstep> which a simple parser library (simpler the ParSec, that's my default)?
10:15:10 <TFK> mmm, yes. Only I can't actually define any new ones. And there isn't anything like docstrings in Haskell, right?
10:15:36 <TFK> After a "ERROR - Cannot find "show" function for:" it only shows the type signature.
10:15:41 <lightstep> TFK: you can define new ones. use "let" before the definition
10:16:12 <lightstep> and this error is where the result is a type that isn't in class Show
10:17:45 * shapr bounces cheerfully
10:19:34 <TFK> I can't force layout in the hugs interperter, can I?
10:21:09 <Lemmih> TFK: Huh?
10:21:51 <TFK> I.e., how can I make my expressions span multiple lines in hugs?
10:22:36 <wilx> You have to have it properly indented.
10:23:04 <wilx> Or...
10:23:06 <wilx> Never mind.
10:23:10 <Lemmih> TFK: You can't.
10:23:17 <wilx> I said I would refrain from giving advices :)
10:23:35 <TFK> Hmm.
10:26:54 <lightstep> Does GHC inline without -O?
10:26:58 <TheHunter> yep
10:27:53 <TheHunter> btw. for which n does the contiguos permutation problem have more than two solutions?
10:28:11 <lightstep> n > 2
10:28:17 <Igloo> contiguos permutation problem?
10:28:36 <TheHunter> really? then i must have implemented the wrong problem...
10:28:47 <lightstep> 123, 213, 231, 321
10:28:48 * ski grins
10:30:00 <TheHunter> anyway, for my version of the problem, the naïve solution of the problem using my weird reflect+reify outperforms the naïve monadic solution. Yay!
10:30:11 <Igloo> Oh, you want chains where neighbouring elements have only a neighbouring pair flipped?
10:30:40 <Igloo> (and all element different)
10:30:43 <ski> TheHunter : what is your weird reflect+reify ?
10:30:56 <lightstep> Igloo: permutations satisfying (isInterval . take n) for all n
10:31:29 <Igloo> What's isInterval?
10:32:03 <TheHunter> my weird library uses linear implicit parameters and unsafePerformIO (unsafeCoerce# also) to implement shift and reset and then reflect and reify.
10:33:01 <TheHunter> ooh, i forgot exception handling.
10:33:03 <ski> oh
10:33:13 * ski wanna see !
10:33:21 <TheHunter> it works surprisingly well considering that it is built on such thin ice.
10:33:28 <lightstep> better phrasing, using prelude functions: not (any (elem $ take n) (drop n))
10:34:05 <TheHunter> (it doesn't work in ghci, though).
10:34:15 <lightstep> err, stupid me. it's not that
10:34:27 <ski> TheHunter : because of optimisations ?
10:34:45 <TheHunter> ski, no, even -O works.
10:34:55 <ski> mhm
10:35:01 <TheHunter> i guess it has something to do with exception handling, but it's kinda impossible to debug.
10:35:07 <ski> m
10:35:33 <ski> TheHunter : is it possible to get a look at the lib. ? :)
10:36:12 <TheHunter> ski, i'll send you my current version.
10:36:23 <lightstep> not (any (\x -> any (\y -> any (\z -> x < y && y < z) (take n)) (drop n)) (take n))
10:36:44 <lightstep> no element of drop n between elements of take n
10:37:12 <Igloo> Ah, ta
10:37:16 * lightstep just proved SKX = I
10:37:58 * TheHunter hmm, dcc doesn't seem to work, i'm prolly firewalled. Can you give me your e-mail adress?
10:38:15 <TheHunter> oops, sorry that should've been msg
10:38:42 <TheHunter> @pointless not (any (\x -> any (\y -> any (\z -> x < y && y < z) (take n)) (drop n)) (take n))
10:38:42 <lambdabot> Sorry, I don't know the command "pointless", try "lambdabot: @listcommands
10:38:43 <thbot> not (any (flip any (drop n) . flip flip (take n) . (any .) . flip s (<)
10:38:43 <thbot> . (((.) . &&) .) . (<)) (take n))
10:38:52 <TheHunter> scnr
10:39:17 <TFK> interact passes stdin to the function it is passed?
10:39:28 <lightstep> TFK: yes
10:40:01 <lightstep> thbot: @pointless \x -> s k x
10:40:02 <thbot> s k
10:40:13 <lightstep> thbot: @pointless k i
10:40:13 <thbot> k i
10:40:20 <lightstep> thbot: @pointless \x -> s const x
10:40:20 <thbot> s const
10:41:56 <shapr> kaboing!
10:42:33 <lightstep> thbot doesn't know that SKX=I, no matter how you ask
10:43:25 <lightstep> thbot @pointless \a -> (\x y z -> x y (x z)) (\x y -> x) dummy a
10:43:33 <lightstep> thbot: @pointless \a -> (\x y z -> x y (x z)) (\x y -> x) dummy a
10:43:34 <thbot> const dummy . const
10:43:58 <TFK> Is there a more detailed reference to Haskell then "Haskell Reference by Miloslav Nic." in .html format?
10:44:32 <lightstep> haskell.org/onlinereport
10:44:51 <TheHunter> ooh, i have a "s (const . f)" and a "s (const f)" rule, but no s const rule ...
10:45:06 <musasabi> Are there tools to do CPS translation of haskell?
10:45:08 <TFK> Thanks ^_^;
10:47:15 <TheHunter> thbot: @pointless s const
10:47:16 <thbot> const id
10:48:40 <lightstep> So it's rule-based reduction? Are there heuristics to finding short results?
10:51:22 <TheHunter> it successively tries to get a shorter version in two steps, where steps are defined by a rather ad-hoc combinator language.
10:51:35 <TheHunter> thbot: @pointless sum [1,2,3,x]
10:51:36 <thbot> 6 + x
10:51:47 <TheHunter> thbot: @pointless foo x = sum [1,2,3,x]
10:51:48 <thbot> foo = (6 +)
10:53:26 <TheHunter> this approach is for example unable to simplify the thing that was haskell-cafe today.
10:53:48 <TheHunter> thbot: @pointless ( (.) (flip (.) (flip ($)))) . flip (.) . flip (.)
10:53:49 <thbot> ((. flip id) .) . flip (.) . flip (.)
10:54:01 <TheHunter> thbot: @pointless ((. flip id) .) . flip (.) . flip (.) x y
10:54:02 <thbot> ((. flip id) .) . flip (.) . y . x
10:54:09 <TheHunter> thbot: @pointless (((. flip id) .) . flip (.) . flip (.)) x y
10:54:09 <thbot> y . flip x
10:54:22 <TheHunter> thbot: @pointless \x y -> y . flip x
10:54:22 <thbot> flip (.) . flip
10:55:55 <fraxtal> oh snap
10:56:04 <fraxtal> a haskell interpereter bot?
10:56:20 <lightstep> Can't you use eta-transformation for this kind of simplification?
10:57:51 <TheHunter> that's what i'd have to do, but the simplifier currently supports only closed expressions.
10:59:54 <lightstep> What are closed expressions? It handles both free and bound variables.
11:00:50 <TheHunter> you're right, i meant it doesn't support lambdas.
11:01:54 <lightstep> I still don't understand. If you feed it lambdas, it turns them into pointless expressions, doesn't it?
11:01:56 <TheHunter> it's certainly not the best way to first transform to poinless style and then apply transformations.
11:02:12 <TheHunter> right, and then it tries to simplify.
11:02:37 <lightstep> Oh, I understand. I only have an unlambda simplifier (in development).
11:03:25 <TheHunter> then i guess you do eta-transformation.
11:04:38 <lightstep> Not yet. I never wrote a real Haskell program, or a real simplifier. So it goes slowly.
11:05:38 <TheHunter> the plugin was my first "simplifier", too
11:06:25 <TheHunter> i think i could've done much better if i had actually though about it before instead of just hacking.
11:07:59 * lightstep looks at the clock
11:08:06 <lightstep> Dinner time. Bye.
11:08:26 <TFK> Mmm, how can I convert a string to an integer?
11:08:54 <TheHunter> bye
11:08:57 <TheHunter> TFK, read
11:09:00 <TheHunter> @type read
11:09:01 <lambdabot> read :: forall a. (Read a) => String -> a
11:09:18 <TheHunter> read "123" :: Int ==> 123
11:10:42 <TFK> Thanks... I get "ERROR - Unresolved overloading" in hugs, though
11:11:26 <TFK> Have to learn the => thingie.
11:11:28 <TheHunter> you must tell the compiler somehow to which type you want to convert your string.
11:11:55 <TheHunter> ... (read x :: Int) ... should do the trick.
11:12:28 <TFK> Oh, it works like that. Thanks :-)
11:12:54 <TFK> So I can automagically read any type from a string, then, as long as I tell the compiler what type it is?
11:13:55 <TheHunter> any type that is in the class Read.
11:14:52 <Igloo> In a real program you generally won't have to tell it the type as it'll generally be able to infer it for itself
11:16:38 <TFK> Nice, it works :-)
11:17:11 * TheHunter can't believe he actually wrote "and $ zipWith (==) xs ys"
11:17:33 <TheHunter> wait a minute, that did make sense...
11:42:19 <TFK> How can I print without the newline?
11:44:35 <TFK> (print an integer, so putStr doesn't do that off the bat)
11:45:22 <zamez> putStr . show
11:45:24 <zamez> I think
11:46:34 <Oejet> TFK: So either (putStr . show) 34  or  putStr(show 34)  or putStr $ show 34.
11:46:45 <TFK> Aye, it works, thanks :-)
11:49:51 <TFK> Was wrong anyway, print was what I wanted :-/
11:52:23 <metaperl_> I want to play around with hugs/haskell... what filename extension should I name my files so that xemacs will recognize them?
11:52:41 <TFK> .hs, methinks
11:52:56 <shapr> yes
11:52:57 <TFK> At least gedit recognizes that as Haskell :-)
11:53:07 <shapr> greetings metaperl_
11:53:11 <shapr> Are you new here?
11:53:14 <metaperl_> yes
11:53:23 <metaperl_> I am new
11:53:27 <shapr> Would you like the short tour of the channel and the short intro to Haskell?
11:53:42 <metaperl_> I just had a short tour of haskell on haskell.org
11:53:46 <shapr> Ah, ok then.
11:53:57 <metaperl_> if there is some channel netiquette, I'm all ears :)
11:53:58 <shapr> Well, if you have any questions, feel free to ask...
11:54:09 <shapr> I think the netiquette here is "be nice"
11:54:37 <shapr> But I can point you to the channel logs mentioned in the topic, and the learning page mentioned in the topic, and the Haskell wiki.
11:54:44 <metaperl_> I know an SML programmer who says that Haskell is a thing of beauty. It brings tears to his eyes. But that you can't do anything practical with it. So he uses SML
11:54:44 <shapr> Oh, and lambdabot has some useful Haskell tools also.
11:54:51 <araujo> shapr, we didn't have forbidden words like, java or perl? 8)
11:54:56 <shapr> That would be Smerdyakov probably.
11:55:02 <TFK> What's SML?
11:55:06 <metaperl_> I am a professional Perl programmer... no ray racine (GreyLensman)
11:55:22 <shapr> oh, GreyLensman
11:55:23 <metaperl_> SML is a popular ML variant, Ocaml being another one
11:55:40 <shapr> Funny, I occasionally get paid to write Haskell.
11:55:41 <TFK> O'Caml I'm vaguely familiar with...
11:56:02 <metaperl_> shapr, what do you do for a living?
11:56:07 <shapr> Lately I get paid to work on a mailing list archive search webapplication I wrote in Haskell.
11:56:20 <jlouis> SML and Ocaml are strict, so they are an order of magnitude faster than Haskell
11:56:39 <metaperl_> interesting. well if it isn't jlouis from #perlhelp :)
11:56:45 <shapr> I'm a self-employed programmer. I'm half owner of a company. The other half owner is my boss and fiancee.
11:56:53 <jlouis> metaperl_: it isn't. I hate perl
11:57:19 <shapr> c'mon, be nice... emotional comments are harsh...
11:57:23 <metaperl_> oh, when I first looked at Haskell, the only consulting company was one in Oregon
11:57:25 <shapr> and very difficult to unit test.
11:57:26 <TFK> Strict?
11:57:39 <jlouis> TFK: eager/strict as opposed to lazy
11:57:51 <TFK> Oh.
11:57:52 <jlouis> call-by-value semantics opposed to call-by-need semantics
11:57:56 <shapr> metaperl_: I have Haskell listed on our web page, dunno if it shows up in google.
11:57:58 * shapr tries
11:58:07 <metaperl_> How is life without business objects?
11:58:17 <TFK> Good thing I decided to learn Haskell instead of O'Caml :-)
11:58:18 <metaperl_> shapr, what web page?
11:58:42 <shapr> http://www.webwitches.com/ is our company webpage. http://www.ScannedInAvian.com/ is my personal weblog.
11:58:49 <metaperl_> I just posted on comp.lang.functional about Perl's context-sensitivity and was impressed by the regexp library in Haskell that was context-sensitive
11:59:04 <shapr> Neither of them show up when google is asked about haskell consulting.
11:59:15 <jlouis> I think the greatest disadvantage of haskell must be space leaks creeping in in odd ways. They are hard. Otoh, I am developing faster in Haskell than SML due to a good FFI and because of a more comprehensive Standard Library
11:59:37 <TFK> Haskell actually leaks memory?...
11:59:46 <shapr> TFK: not the way you think...
11:59:57 <jlouis> it is due to the laziness
11:59:58 <shapr> jlouis: c'mon, the wonderful humor here on #haskell helps!
12:00:16 <TFK> Well I'm guessing it's keeping objects alive instead of gc-ing them.
12:00:19 <shapr> We have some nice quotes by jlouis himself on the QuotesPage.
12:00:24 <shapr> TFK: correct!
12:00:41 <TFK> w00t! :D
12:00:54 <shapr> You get the gold lambda for good answers!
12:01:00 <jlouis> shapr: haha
12:01:05 <TFK> \o/
12:01:13 <humasect> hmm.. \._./
12:01:23 <jlouis> shapr: the humour of haskell certainly helps. I love to call hell now and then when there are good libraries down there
12:01:28 <shapr> haha!
12:01:53 <desrt> <gold>λ</gold>
12:01:55 <jlouis> But damn, those libraries is the project of hard labour work, you C
12:02:08 <shapr> metaperl_: Do you have particular questions?
12:02:21 <shapr> desrt: looks like a utf-8 croatian character to me.
12:02:33 <metaperl_> not at the moment, I installed hugs under windows and am going to keep plyaing with Gentle Introduction
12:02:36 <desrt> it's a utf-8 lambda
12:02:42 <desrt> and it is gold.
12:02:44 <TFK> tfk = award tfk (goldenify lambda)
12:02:44 * humasect frowns at hugs
12:02:51 <shapr> @wiki HaskellDemo
12:02:51 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
12:03:08 <shapr> metaperl_: I'd suggest you start with the HaskellDemo, if you don't have prior FP experience.
12:03:16 <desrt>  @eval is the right way to execute code, right?
12:03:37 <metaperl_> no, I have programmed in Scheme and learned about 20-30% of SML
12:03:46 <metaperl_> plus I have an MS in Computer Science
12:03:48 <humasect> http://www.iceteks.com/articles.php/haskell/1  is nice afterward
12:04:03 * metaperl_ is drowning in links!
12:04:08 <metaperl_> thanks for the input guys
12:04:25 <shapr> metaperl_: well, MS in CS isn't always significant :-) nor is the lack of any CS education always significant.
12:04:25 <metaperl_> the population of this IRC channel is an order of magnitude greater than #sml
12:04:32 <metaperl_> heh
12:04:58 <desrt> @eval 2+2
12:04:58 <lambdabot> 4
12:04:58 <shapr> What did you do your thesis on?
12:05:05 <desrt> @eval lex "123abc"
12:05:05 <lambdabot> unbound variable: lex
12:05:08 <desrt> tsk.
12:05:43 <shapr> desrt: @eval is just a lambda calculus interpreter.
12:05:58 <desrt> is there a way to make it do haskell?
12:06:11 <shapr> No, but Haskell is very close to lambda calculus.
12:06:17 <shapr> So it's easy to be confused.
12:06:23 <desrt> nod.
12:06:32 <desrt> it seems to have a good deal of the haskell prelude inside of it, though
12:07:16 <shapr> Yeah, I think the Prelude has a lot of 'traversal essences' in there.
12:07:19 <metaperl_> shapr, my thesis was on a C library to allow for computer programming in a variety of languages - C, Emac Lisp, Tcl and One Other I forgot about
12:07:37 <shapr> Sounds interesting. How did you do it?
12:07:40 <desrt> was it perl? :)
12:07:52 <shapr> Sounds like Minotaur.
12:07:58 <metaperl_> it was a C library that provided the other languages using the Tcl embedded interpreter perspective... data conversion was intentionally not automatic
12:08:07 <metaperl_> I dont think it was Perl
12:08:11 <metaperl_> Smalltalk
12:08:14 <metaperl_> that's what it was
12:08:28 <shapr> oh cool
12:08:35 <shapr> Not many smalltalkers come by here.
12:09:12 <shapr> I think you'll like Haskell if you enjoyed that library.
12:09:36 <shapr> One of the most powerful idioms in Haskell is to write your own domain specific language.
12:11:41 <shapr> desrt: I thought the prelude already had all the essences distilled. I was quite surprised that Cale came up with swing. Obviously, there's more to be found.
12:11:52 <metaperl_> what do you do for RDBMS database usage from haskell?
12:12:06 <desrt> what is an essence as you are talking about it?
12:12:12 <shapr> I like HaskellDB, but it's not ready for heavy duty use yet.
12:12:19 <desrt> essential?
12:12:24 <shapr> Like traversal essences or something.
12:12:30 <desrt> hm
12:12:42 <shapr> Like anamorphisms, catamorphisms, etc. There are basic patterns.
12:12:53 <metaperl_> Type :? for help
12:12:53 <metaperl_> Prelude> somenumber = 1
12:12:53 <metaperl_> ERROR - Syntax error in input (unexpected `=')
12:12:53 <metaperl_> Prelude>
12:12:59 <desrt> i wish i knew what a catamorphism was
12:13:04 <desrt> i suspect that i will, within a year
12:13:06 <metaperl_> thats what the Demo had...
12:13:06 <shapr> desrt: catastrophe
12:13:16 <shapr> cata = gets smaller
12:13:31 <shapr> metaperl_: stick the Demo into a file, use :load to load the file.
12:13:55 <metaperl_> I dont know where WinHugs starts ... it's default directory
12:14:03 <shapr> try :cd
12:14:06 <shapr> that might tell you
12:14:18 <TFK> metaperl_, hugs doesn't allow assignment :-(
12:14:19 <metaperl_> Prelude> :cd
12:14:19 <metaperl_> Prelude>
12:14:34 <metaperl_> should I use hugs in haskell98 mode?
12:14:40 <metaperl_> i am using it in hugs mode
12:14:43 <metaperl_> I am confused
12:14:46 <TFK> You can load some haskell code with :load and :reload, and play with hte functions defined there
12:14:49 <Cale> hugs will only evaluate expressions -- you have to load definitions you want from a file
12:14:52 <TFK> metaperl_, I share your confusion :-(
12:15:01 <jlouis> ana, cata, epi and mono are category theory stuff
12:15:14 <metaperl_> oh, jlouis was on #scheme
12:15:16 <metaperl_> now I remember
12:15:20 <jlouis> metaperl_: sure ;)
12:15:28 <shapr> metaperl_: you have a great fondness for hats =)
12:15:30 <jlouis> though I do program in perl now and then ;)
12:16:16 <shapr> metaperl_: I was looking for your thesis and found your pix.
12:18:07 <metaperl_> Prelude> Prelude> :load "demofile.hs"
12:18:07 <metaperl_> Main> Main>
12:18:10 <metaperl_> oh thanks
12:18:25 <metaperl_> I am Terrence Monroe Brannon
12:18:46 <shapr> yup
12:18:50 <shapr> nice hats.
12:18:51 <metaperl_> ok now demofile.hs is loaded with the stuff from http://www.haskell.org/hawiki/HaskellDemo now what?
12:18:55 <metaperl_> thank you?
12:19:00 * shapr grins
12:19:00 <metaperl_> I mean thank you!
12:19:23 <metaperl_> I thought you meant I wear many hats as a programmer because I switch from scheme to Perl to sml to haskell
12:19:42 <shapr> Hm, good point.
12:19:59 <shapr> I'm not used to speaking to native english speakers lately so I hadn't thought of that.
12:20:44 <metaperl_> so how do I play with the load that I loaded in
12:20:52 <metaperl_> :load "filenmae.hs" is the way to load it right?
12:20:55 <shapr> yes it is
12:21:10 <shapr> ok!
12:21:20 <musasabi> how did I make emacs not generate tabs while in haskell-mode?
12:21:23 <shapr> obviously if you want to see the value of somenumber, you can just type it in
12:21:32 <metaperl_> oh yes, that was a dumb question
12:21:40 <metaperl_> I am toying with it now. sorry for the interruption
12:21:48 <shapr> same for some string, it's sort of like the REPL you're used to
12:22:19 <metaperl_> my first type error:
12:22:20 <metaperl_> Main> add1 somenumber
12:22:21 <metaperl_> ERROR -
12:22:21 <metaperl_> Type error in application
12:22:21 <metaperl_> *** Expression     : add1 somenumber
12:22:21 <metaperl_> *** Term           : somenumber
12:22:22 <metaperl_> *** Type           : Integer
12:22:24 <metaperl_> *** Does not match : Int
12:22:26 <metaperl_> Main> Main>
12:22:37 <metaperl_> Integer and Int are different? OMG
12:22:45 <shapr> musasabi: indent-tabs-mode nil
12:23:00 <shapr> metaperl_: yes, Int is a 31 bit int, and Integer is unlimited.
12:23:03 <Cale> desrt: http://db.cs.utwente.nl/Publications/PaperStore/db-utwente-40501F46.ps
12:23:16 <shapr> metaperl_: but usually you don't notice, and you don't care.
12:23:17 <Oejet> musasabi: (setq-default indent-tabs-mode nil)
12:23:26 <metaperl_> the demo is failing though...
12:23:44 <shapr> so try add1 1
12:24:02 <shapr> metaperl_: btw, I wrote most of HaskellDemo, so I'll fix that right away =)
12:24:16 <metaperl_> that worked
12:24:29 <metaperl_> but how to I get add1 somenumber to work
12:24:32 <shapr> you can find out the type of something with :t, like :t add1
12:24:37 <metaperl_> I think that would be a nice thing to know
12:24:50 <shapr> you can cast it with "add1 (fromIntegral somenumber)"
12:25:54 <shapr> Oh, I wonder if you got that error because I didn't try out HaskellDemo with Hugs.
12:26:15 <musasabi> thanks.
12:26:16 <metaperl_> I am using WinHugs in hugs mode
12:26:33 <metaperl_> with no idea what haskell98 mode is and not sure if I should supply the -98 option
12:26:48 <shapr> nah, no worries
12:27:30 <metaperl_> Main> somenumber
12:27:30 <metaperl_> 1
12:27:35 <shapr> that works
12:27:35 <metaperl_> that is not descriptive output
12:27:38 <shapr> heh
12:27:43 <metaperl_> SML would tell you the type of somenumber
12:27:51 <shapr> that's ":t somenumber"
12:27:52 <metaperl_> you cannot infer the type by looking at that
12:27:58 <shapr> or ":type somenumber"
12:28:27 <Cale> metaperl_: it usually doesn't matter, unless you've written a function to specifically work with only one kind of number
12:28:49 <metaperl_> if you had left out the type signature for add1, would it have worked polymorphically?
12:28:53 <Cale> (which we unfortunately have, by providing an explicit type signature which wasn't sufficiently general)
12:28:54 <shapr> yes
12:29:01 <metaperl_> ah
12:29:12 <metaperl_> a generaltypesignature was in order
12:29:14 <shapr> not polymorphically really, but inferentially.
12:29:26 <Cale> you could also provide the type signature (Num a) => a -> a -> a for add
12:29:40 <shapr> I cheekily call Haskell "compile-time dynamically typed".
12:30:36 <metaperl_> will you be here 1.5 hours from now? I am going home to relax for a bit and then come back to "work"
12:30:40 <Cale> and then it would have worked on Int, Integer, Float, Double, Complex, and pretty much every numeric type out there (including user-defined Matrix types, so long as they're made instances of Num)
12:30:49 <metaperl_> I have a lot of free time here these days
12:31:04 <metaperl_> I dont think my bosses are on #haskell :)
12:31:10 <shapr> I'll be asleep, but many people here are helpful.
12:31:16 <metaperl_> oh ok
12:31:16 <shapr> like ... Cale!
12:31:17 <ski> (hmm, ":set +t" could be used to show types after evaluated value)
12:31:37 <ski> (looks nicer in hugs that in ghci, though, t'seems)
12:31:42 <shapr> Cale: did you change everything to Integer that fast?
12:31:47 <Cale> yeah
12:31:47 <metaperl_> ok well thanks for your help Cale and shapr, I will see you guys another day
12:31:50 * shapr blinks sleepily
12:31:54 <metaperl_> or in 1.5 hours
12:31:59 <Cale> okay :)
12:33:04 <shapr> Cale: Btw, I asked the #moin guys for mass revert. Probably would be easy to add to Flippi in any case.
12:33:18 <Cale> cool
12:33:29 <desrt> so folding is catamorphism?
12:33:35 <Cale> desrt: yes
12:33:36 <shapr> yup, gets smaller
12:33:47 <shapr> desrt: so, what's an unfold?
12:33:50 <desrt> wow.  i even understood that from their crazy math language
12:33:58 * shapr snickers
12:34:06 <desrt> mmm
12:34:14 <desrt> isn't there a certain loss of information associated with folding?
12:34:29 <Cale> desrt: yes, usually
12:34:34 <desrt> obviously except for very special cases
12:34:45 <desrt> even in the case of folding a list of primes using * you'd lose order....
12:35:09 * shapr remembers desrt, the early days...
12:35:16 <Cale> desrt: catamorphisms are in general, things which flatten data structures in a catastrophic manner :)
12:35:23 <desrt> good name, then :)
12:35:31 <desrt> shapr; eh? :)
12:36:12 <shapr> Never mind me, I'm too tired to give a coherent answer right now.
12:36:16 <shapr> Ask me tomorrow
12:36:25 <desrt> i hope i remember
12:36:34 <shapr> I know I won't.
12:36:46 <desrt> good night, then?
12:36:49 <shapr> yes!
12:36:56 * shapr disappears
12:36:58 <desrt> :)
12:39:50 <lightstep> Yay, I got a Microsoft keyboard! With Print Screen where Insert should be, so as to easily crash links!
12:41:31 <Cale> lightstep: that's odd... Perhaps you should remap the keys :)
12:43:00 <wagle> split keyboard?
12:44:37 <lightstep> wagle: no, the 6 keys about the arrows moved down, so now they are right above them, with the print screen line is there the insert line should be, with windows keys where print screen should be
12:45:23 <wagle> i know two people who really want some old-design microsoft split keyboards, so thought maybe you found a supply
12:46:01 <ski> lightstep : with useless buttons replacing PrintScreen, ScrollLock, Pause ?
12:46:14 <ski> mhm
12:47:48 <lightstep> When I first fould out about Scheme and Linux, I mapped the windows key (near Alt and Control) to let, lambda and define.
12:49:00 <lightstep> What is the point-free form for \x -> [x]?
12:49:39 <wagle> return?
12:49:56 <ski> (: [])
12:50:12 <wagle> oooo
12:50:53 <ski> this is box at
12:51:00 <ski> @wiki LicensedPreludeExts
12:51:00 <lambdabot> http://www.haskell.org/hawiki/LicensedPreludeExts
12:51:20 <ski> (wagle : it looks like a kind of smiley, see :)
12:51:42 <wagle> (: mzero)
12:52:28 <ski> (`mplus` mzero) . return
12:52:37 <wagle> thanks
12:52:42 <ski> yw
12:52:48 <wagle> was trying to come up with that
12:53:08 <wagle> return == (: [])
12:53:14 <ski> @pointless \x -> [x]
12:53:14 <lambdabot> Sorry, I don't know the command "pointless", try "lambdabot: @listcommands
12:53:27 <ski> (hm, thbot not here ..)
12:54:13 <wagle> but back to the original question..  can you have a pointless function on points?
12:55:16 <ski> what points ?
12:55:22 <wagle> x
12:55:34 <ski> poinless function taking points and returning points ?
12:55:53 <wagle> taking points, returning ___
12:55:59 <ski> which is ?
12:56:07 <wagle> taking points, returning _
12:56:14 <ski> what is "_" ?
12:56:40 <wagle> haskell for "doesnt matter"
12:56:44 <ski> long tones in morse ?
12:57:06 <wagle> . -> _
12:57:09 <wagle> ?
12:57:13 <ski> would _|_ do ?
12:58:14 <lightstep> use `const undefined'
12:58:27 <ski> const bot   where bot = bot
12:59:06 <wagle> no, "doesn't matter" != "has a particular value, such as bottom"
12:59:28 <ski> so "doesn't matter" has no particular value, then ?
12:59:50 <ski> (bottom could be considered not to be a value, if one wants)
13:00:52 <ski> wagle : maybe you want it to return an unconstrained (unshared, uninstantiated) logical variable ?
13:01:35 <ski> f(_) = _.
13:01:49 <wagle> i was just trying to say that if a function took points as input, then it might have difficultly claiming to be a pointless function
13:02:05 <ski> (that could possibly be considered as "doesn't matter")
13:02:16 <ski> why ?
13:02:27 <wagle> 13:11:28 <Riastradh> Arrows generalize pointless functions.
13:02:32 <ski> as long as it doesn't have any point(s) itself
13:03:06 <lightstep> pointlessFunction :: Point -> forall a. a
13:03:17 <wagle> is there a formal definition of "pointless"?
13:03:34 <wagle> my googling isnt getting anything usefull
13:03:40 <lightstep> I think it means "without bound identifiers".
13:03:49 <ski> not using internal structure of "Objects" (~= types) ?
13:04:50 <ski> (wagle : as in category theory Objects and Arrows)
13:05:08 <wagle> hmm,.. http://wiki.di.uminho.pt/wiki/bin/view/Alcino/PointlessHaskell
13:05:48 <ski> cool
13:06:33 <ski> "Pointless.Observe.RecursionPatterns   Recursion patterns with observation of intermediate data structures."
13:08:20 <ski> wagle : i think the term "pointfree/pointless function" comes from category theory ..
13:08:50 * wagle gets lunch
13:08:52 <musasabi> Should readIORef + atomicModifyIORef be faster than readMVar + putMVar ?
13:09:42 <boegel> @seen duncan
13:09:43 <lambdabot> I haven't seen duncan
13:09:58 <boegel> yes you have, liar
13:19:48 <musasabi> atomicModifyIORef appears to be very slow.
13:20:55 <lightstep> Atomic thingies should be slow: they block the whole machine.
13:21:03 <Oejet> musasabi: You could try to compare the implementations by looking at the GHC CVS web interface.
13:21:18 <Oejet> lightstep: MVar's are also atomic.
13:21:44 <jlouis> Man I am tired of zippy the pinhead quotes. Shouldn't we load some good ``DEATH'' from DiscWorld into lambdabot ?
13:22:10 <TFK> What does getContents do exactly?
13:22:36 <jlouis> DARK IN HERE, ISN'T IT?
13:22:51 <musasabi> Oejet: I wrote a quick benchmark and it told quite enough..
13:22:55 <LinkMasterSab> Can't see a thing
13:23:35 <lightstep> TFK, it reads the file lazily into a string.
13:23:58 <Oejet> musasabi: And compared to STM?
13:24:05 <ski> TFK : it lazily interleaves IO reads from the opened file (stdin, in case of getContents, otherwise file associated with handle given to hGetContents), reading from the file when chars are demanded/forced from the resulting string (= list of characters)
13:24:49 <ski> (TFK : and you shouldn't try to do any other operation to a file handle after you've passed it to hGetContents)
13:25:09 <musasabi> Oejet: STM is slightly slower than MVars for simple operations iirc.
13:25:38 <TFK> Well, it reads from stdin by default, right? Until EOF?
13:26:06 <Oejet> musasabi: Though they ought to be faster since they don't take the lock.
13:26:08 <ski> 'getContents' reads from stdin   'hGetContents h' reads from the Handle h
13:26:39 <Oejet> musasabi: In principle, IIRC.
13:26:50 <ski> TFK : yep, until EOF (or until the rest of the string is garbage-collected, unforced)
13:26:58 <TFK> All right, thanks.
13:27:07 <musasabi> Oejet: but they have to make extra bookkeeping.
13:27:12 <lightstep> Is there a typo in the example in the end of Chapter 10 of the Standard Prelude?
13:27:42 <musasabi> Oejet: and actually locking is not bad for this thing.
13:28:29 <Oejet> Yes, I guess it depends.
13:30:30 <TFK> Haskell compiles for so long ;_;
13:31:00 <TFK> (Relativey speaking, of course)
13:31:18 <musasabi> well you don't -O2 for testing ;)
13:31:42 <TFK> I don't. I wonder if my settings specify that as a default o.o;;
13:31:55 * Lunar^ is playing with Alex/Happy
13:43:25 <TFK> http://rafb.net/paste/results/prnkdD83.html <--- this code works, but what do you think of the style (if that even has a meaning for 5 lines of code...)?
13:44:06 <lightstep> +
13:44:08 <lightstep> oops
13:44:49 <TFK> BTW, is there a pastebin that does syntax highlighting for Haskell? rafb doesn't seem to have that...
13:45:13 <Cale> TFK: most people use the paste page on the wiki
13:45:23 * TFK looks it up
13:45:27 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:46:06 <Cale> feel free to clear it off and replace it with whatever you need to paste, or just stick new things at the top
13:46:59 <TFK> Nifty, thanks :-)
13:48:11 <lightstep> TFK, you don't need the Integer type annotation (without it, the type would be any Integral, i think).
13:48:29 <fraxtal> upgrade time
13:49:41 <TFK> Dunno what Integral is (yet! haven't read all the docs to be read yet), although I've seen it a lot. I used that mainly as a kind of docstring substitute :-)
13:51:38 <lightstep> Hmm. I was probably wrong. Any type in both Num and Enum will do.
13:51:43 <wli> argh
13:51:51 <wli> how do you get the stuff to show up without looking crappy?
13:52:00 <Cale> TFK: you might factor out that pattern -- stringify f = show . f . read; facList = map (stringify fac)
13:52:40 <fraxtal> φυχζ0ρ!
13:53:16 <Cale> wli: somehow when you pasted it, the formatting was destroyed... normally you wrap the paste in {{{!#syntax haskell ...}}}
13:54:01 <wli> Cale: I missed that part
13:54:59 <TFK> Cale, so facList would become a list of composite 'show . f . read' functions?
13:55:12 <TFK> Oh, no wait, I got it.
13:55:31 <TFK> facList is only partially applied map.
13:55:34 <TFK> I'll try that!
13:57:04 <wli> Cale: hmm, linewrap doesn't happen by itself
13:59:04 <humasect> +emacs perl
14:16:04 <wli> Cale: Okay, I think I've got it patched up.
14:19:03 <wli> Looks like it actually works as-pasted, too.
14:23:08 <wli> I'm not sure what the order of convergence of that algorithm is but it appears to wipe the floor with Muller's method, which is (of course) of higher-order than Newton's.
14:26:04 <Pseudonym> Higher-order does not imply more accurate.
14:26:11 <Pseudonym> I know you knew that.
14:26:28 <Pseudonym> Nor does it imply more stable.
14:26:56 <ski> wli : what does it do ?
14:27:01 <Pseudonym> But I'm guessing your problem is C^{enough}.
14:28:04 <wli> Pseudonym: it's pretty much assumed C^\infty
14:28:09 * Pseudonym nods
14:28:22 <Pseudonym> What are you doing, as a matter of interest?
14:28:22 <wli> Pseudonym: plus no stiffness
14:28:25 * Pseudonym couldn't find it in the logs
14:28:53 <wli> Pseudonym: That's largely for the sake of a couple of odd functions, e.g. Lambert's W
14:30:42 <wli> Pseudonym: clearly z*exp(z)-x is C^\infty =)
14:30:55 <Pseudonym> Well, yes. :-)
14:31:33 * Pseudonym is wondering if there's a fast way to compute W
14:31:47 <wli> (in fact d^n/dz^n (z*exp(z) - x) = (z+n)*exp(z))
14:31:55 <Pseudonym> There's one that involves Sterling numbers.
14:32:10 <wli> Pseudonym: do tell
14:32:27 <wli> I've not seen anything useful apart from root-solving.
14:33:25 * Pseudonym looks up GAMS
14:40:42 * boegel yawns
14:40:42 <wli> Pseudonym: termination criteria for AGM methods might also help
14:40:57 <wli> Pseudonym: (for Jacobian elliptic functions)
14:43:26 * ski still waits for  wli (\x -> x*x) (*2) (const 2) (const 0) 1  to terminate
14:46:15 <wli> ski: well, it's not meant for polynomial root-finding so I'm not too worried
14:46:32 * ski still wonders what it's meant to do
14:46:52 <wli> ski: solve some weird transcendental equations
14:47:09 <ski> sounds tricky
14:48:18 <LinkMasterSab_> Hmm. What does "Equations give different arities" mean?
14:49:23 <wli> ski: the root vanishes
14:49:33 <wli> ski: likewise wrt. derivatives at the root
14:49:54 <ski> for my test, you mean ?
14:50:32 <wli> ski: yep
14:51:03 <wli> ski: that's one of the bad behaviors you get from badly-behaved functions that a more "industrial strength" method would cope with.
14:51:38 <ski> ok
14:51:56 * ski just tried something, not knowing what is was supposed to do ..
14:52:38 <wli> ski: try
14:52:55 <wli> wli (\z -> z*exp z - 1) (\z -> (1+z)*exp z) (\z -> (2+z)*exp z) (\z -> (3+z)*exp z) 1
14:53:23 <wli> ski: also try fiddling with it so it logs its steps
14:54:19 <ski> tried  mapM_ print [(x,y) | x <- [-3.5 .. 3.5], let y = wli (\x -> x*x - 1) (* 2) (const 2) (const 0) x]
14:54:25 <ski> "logs" ?
14:54:39 <wli> ski: comparing to Newton or Muller in isolation shows it gets there faster (often it goes to very close to machine precision in the first step and then polishes with the lower-order methods)
14:55:46 <wli> ski: replace snd . head . dropWhile (\(u, v) -> abs (u-v) >= 64*eps*abs(u+v)) $ zip xs (tail xs)
14:55:58 <wli> ski: with take 10 (map (\w -> (w, f w)) xs)
14:56:42 <Pseudonym> wli: OK, this also does high-order iteration.
14:56:49 <Pseudonym> But it chooses an initial estimate very carefully.
14:57:00 <ski> replace in the code, you mean ?
14:57:05 <Pseudonym> Only needs one iteration to fill an IEEE 754 double.
14:57:09 <Pseudonym> Which is pretty impressive.
14:57:40 <wli> Pseudonym: try me
14:57:46 <Pseudonym> Hang on.
14:57:52 <Pseudonym> Haven't tested it yet.
15:00:31 <ski> wli : aha, and 10 is # of steps, then ?
15:00:57 <ski> wli : wouldn't it be better to return the whole lazy list ?
15:02:00 <LinkMasterSab_> Anyone have any clue as to what "Equations give different arities" means?
15:02:19 <wli> ski: could be, if you want to see more iterations
15:02:42 <wli> ski: I think if it needs more iterations you need a different method
15:03:22 <gzl> LinkMasterSab_: context?
15:03:36 <gzl> arity usually refers to the number of arguments some function takes
15:03:49 <ski> LinkMasterSab_ : your several defining equations of a function have differing number of arguments to the left of "=". that is not allowed
15:04:00 <gzl> ah, there we go.
15:04:48 <LinkMasterSab_> ski: Heh.
15:04:55 <LinkMasterSab_> I wonder how you do this exercise then
15:05:09 <ski> LinkMasterSab_ : simple example would be  "f [] = id" and then "f (x:xs) y = y/x + f xs x"
15:05:25 <LinkMasterSab_> Write a datatype Tuple which can hold one, two, three or four elements,
15:05:25 <LinkMasterSab_> depending on the constructor (that is, there should be four constructors, one for each
15:05:25 <LinkMasterSab_> number of arguments). Also provide functions tuple1 through tuple4 which take a
15:05:25 <LinkMasterSab_> tuple and return Just the value in that position, or Nothing if the number is invalid
15:05:25 <LinkMasterSab_> (i.e., you ask for the tuple4 on a tuple holding only two elements).
15:05:52 <LinkMasterSab_> In YAHT
15:06:35 <ski> LinkMasterSab_ : maybe you have forgot parenthesis around the constructor with arguments in your function equations/definition-lines ?
15:06:58 <LinkMasterSab_> ski: That's it I bet :D
15:09:58 <Muad_Dibber> g'night
15:12:36 <LinkMasterSab_> ski: Yep, that was it
15:12:49 <ski> good
15:17:58 <wli> there are probably smarter ways of going about things, like e.g. Lagrange interpolation of the 2 endpoints of a bracketing interval plus the 1/3 and 2/3 marks between them or some such, or maybe fitting a cubic curve through 10 points, or similar.
15:22:43 <Pseudonym> The approximation of this function between 0.5 and 30 is a continued fraction expansion.
15:23:04 * Pseudonym is having a bit of trouble debugging it over that range.
15:23:10 <Pseudonym> Outside that range, the function is pretty close.
15:24:59 <wli> Pseudonym: just polish whatever the continued fraction hands you over 0.5-30
15:25:13 <Pseudonym> No, it's REALLY wrong.
15:25:14 <wli> Pseudonym: what's the continued fraction? I have good methods of evaluating those.
15:25:31 <Pseudonym> This is it:
15:25:44 <Pseudonym> let reta = sqrt (em2 * (em - x))
15:25:44 <Pseudonym>                   in reta / (1 + reta / (3 + reta / (reta /
15:25:44 <Pseudonym>                             (an4 + reta / (reta * an6 + an5))+an3))) - 1
15:25:46 <Pseudonym> where:
15:25:52 <Pseudonym> em = -exp (-1)
15:25:52 <Pseudonym> em2 = 2.0 * em
15:26:01 <Pseudonym>         an3 = 8.0/3.0
15:26:01 <Pseudonym>         an4 = 135.0/83.0
15:26:01 <Pseudonym>         an5 = 166.0/39.0
15:26:01 <Pseudonym>         an6 = 3167.0/3549.0
15:26:05 <Pseudonym> :-/
15:26:06 <wli> um
15:26:14 <wli> there should be a closed form for the elements
15:26:15 <Pseudonym> Truncated, obviously.
15:27:24 <Pseudonym> This illustrates the problem:
15:27:25 <Pseudonym> *W> wapprox 0.4
15:27:26 <Pseudonym> 0.2972557628979144
15:27:26 <Pseudonym> *W> wapprox 0.5
15:27:26 <Pseudonym> 0.3519593613933236
15:27:26 <Pseudonym> *W> wapprox 0.6
15:27:26 <Pseudonym> -0.11934040396979695
15:27:42 <Pseudonym> Is that close for 0.4 and 0.5?
15:30:01 <wli> Well, Maple spews 0, [x, 1], [x, 1], [x, 2], [5 x, 3], [17 x, 10], [133 x, 17], [1927 x, 190], [13582711 x, 94423], [92612482895 x, 1597966], [10402118970990527 x, 8773814169] for the first 10
15:30:19 <Pseudonym> Hmmm.
15:30:26 <Pseudonym> What about the acutal returned values?
15:30:36 <wli> Pseudonym: you can check by doing wapprox z - (z*exp z)
15:30:42 <Pseudonym> Right.
15:30:44 <wli> Pseudonym: that gives the residual
15:30:45 <Pseudonym> Good point.
15:30:59 <wli> Pseudonym: well, those are the elements in the continued fraction expansion
15:31:21 <wli> W(0.6) = 0.4015636367870725946626665
15:31:52 <Pseudonym> That's what I figured.
15:31:56 <wli> W(0.5) = 0.3517337112491958260249093
15:32:15 <Pseudonym> Actually, this is an easier test:
15:32:25 <Pseudonym> let z = wapprox 0.3 in z * exp z
15:32:31 <Pseudonym> That should be about 0.3
15:32:37 <wli> W(0.4) = 0.2971677506731385467797270
15:32:50 <wli> W(0.3) = 0.2367553107885593168713670
15:33:02 <wli> or so says Maple
15:33:02 <Pseudonym> *W> wapprox 0.3
15:33:02 <Pseudonym> 0.23677961909473164
15:33:12 <Pseudonym> So looks like this is pretty close.
15:33:16 <Pseudonym> In that range.
15:33:26 <wli> Pseudonym: Polishing with newton should wrap it up
15:33:28 <Pseudonym> In that range, it uses this approximation:
15:33:32 <Pseudonym> x / (1 + x / (1 + x / (2 + x / (0.6 + 0.34*x))))
15:33:50 <Pseudonym> Which is pretty good.
15:34:09 <Pseudonym> Looks very close to Maple's. :-)
15:34:55 <Pseudonym> That's for the range -1/e to 0.5.
15:35:30 <Pseudonym> (Actually, the upper part of the range is variable; at the moment I have the effective precision set to 10 bits of mantissa.)
15:35:37 <wli> let w x = wli (\z -> z*exp z - x) (\z -> (1+z)*exp z) (\z -> (2+z)*exp z) (\z -> (3+z)*exp z) (x / (1 + x / (1 + x / (2 + x / (0.6 + 0.34*x))))) in let { t = w s ; s = 100 } in (t*exp t - s)
15:35:44 <wli> that seems to do nicely =)
15:35:47 <Pseudonym> Cool.
15:36:04 <Pseudonym> What range are you interested in in particular?
15:36:39 <wli> Pseudonym: I'm not sure. It's mostly useful in connection with solving for some parameters of logistic equations.
15:37:31 <Pseudonym> http://www.nomorepasting.com/paste.php?pasteID=31898
15:37:36 <wli> well, not *precisely* logistic
15:37:39 <Pseudonym> Anyway, that's it, with the buggy case marked.
15:37:41 <wli> but things like x*tanh(x)
15:37:48 * Pseudonym nods
15:38:01 <Pseudonym> I'll try to debug the other case later.
15:38:45 <wli> I'm not familiar with these approximations. Hmm.
15:39:41 <Pseudonym> Me neither, but it looks pretty clean.  Should be able to plug reta into W and get a continued fraction expansion.
15:39:42 <fraxtal> no λ ?
15:40:05 <wli> Pseudonym: well, if I can get the continued fraction expansion in closed form I can iterate to convergence...
15:40:06 <LinkMasterSab> How would one represent four different possible types with the Either type?
15:40:17 <Pseudonym> wli: True.
15:40:34 <Pseudonym> Oh, one more thing.  This is a bit unstable for x < 0.
15:40:37 <wli> Maple seems to be able to spit them out rapidly.
15:40:44 <LinkMasterSab> I suppose I could easily just make a similar type of my own.
15:40:46 <LinkMasterSab> Nevermind.
15:40:47 <Pseudonym> But I suspect you don't care about that region.
15:42:11 <wli> Pseudonym: z*exp(x) has a minimum at x = -1 of -1/e
15:42:27 <wli> Pseudonym: the closer things get to that the deeper the doo doo gets
15:42:31 <Pseudonym> Right.
15:42:57 <Pseudonym> The Fortran code I got this from had a special case, where you could compute W(x - 1/e) instead.
15:43:02 <Pseudonym> WHich gives you extra precision.
15:43:51 * Pseudonym never used to like numeric programming
15:43:58 <Pseudonym> But I kinda got the hang of it in the last few years.
15:44:53 <wli> Pseudonym: I don't trust approximations I can't derive myself... maybe useful for starting points, but otherwise...
15:45:36 <Pseudonym> Well it's simple enough in theory.
15:45:47 <metaperl_> something in HaskellDemo confuses me. data People = Person name age
15:45:48 <wli> let { t = w s ; s = (0.0001 - (1/(exp 1))) } in (t*exp t - s)
15:45:48 <wli> 0.0
15:45:59 <ski> LinkMasterSab : how about "using the Either type constructor on itself" ?
15:45:59 <wli> seems to do some good guessing
15:46:09 <metaperl_> why couldnt this be written data Person = name age
15:46:20 <Pseudonym> reta = sqrt (2 * exp(-1) * (exp(-1) - x))
15:46:25 <Pseudonym> Invert that.
15:46:26 <wli> (w x does the root-solving starting from teh continued fraction)
15:46:28 <Pseudonym> Plug it into W.
15:46:33 <Pseudonym> Get the continued fraction expansion.
15:46:39 <Pseudonym> What could be simpler? :-)
15:47:16 <Pseudonym> Could probably do it with Maple right now if you had it handy.
15:47:41 <wli> Pseudonym: I'm not sure what you're calling the continued fraction expansion there; I generally call the continued fraction expansion being a closed form for the coefficients in an infinite continued fraction.
15:48:21 <ski> metaperl_ : with data you introduce a new datatype, so you need a constructor
15:48:23 <Pseudonym> Yeah, that's pretty much what I'm saying.
15:48:28 <wli> numtheory[cfrac](LambertW(x), x); is where I got a nonobvious closed form. Maple doesn't give closed forms for coefficients it just computes the first few.
15:48:37 <Pseudonym> Ah.
15:48:44 <Pseudonym> No, I mean "get the first few", in this case.
15:48:53 <metaperl_> oh so Person is the constructor for the datatype People
15:49:00 <ski> metaperl_ : one could reuse an old datatype also, instead. e.g. the pair (2-tuple) :  type Person = (Name,Age)
15:49:09 <ski> right
15:49:44 <wli> Another tactic would be to smoke out a high-order Pade approximant.
15:49:54 <ski> but the "type .." just creates a type synonym, while "data .." (and "newtype ..") creates a new fresh type
15:49:55 <Pseudonym> OK, could you do something for me?
15:50:19 <Pseudonym> Find the first few continued fraction coefficients for this:
15:50:22 <metaperl_> ski, thanks
15:50:24 <wli> Pseudonym: Sure.
15:50:30 <Pseudonym> W(exp(-1) - x^2 / (2 * exp(-1)))
15:50:32 <Pseudonym> In terms of x
15:50:58 <Pseudonym> I need about 6 or 7.  Maybe 8 just to be sure.
15:51:48 <wli> okay, it's spitting them out by the dozen
15:51:55 <wli> I'll plop down 20.
15:53:17 <wli> Pseudonym: continued fractions have a useful property
15:53:29 <Pseudonym> Which is?
15:53:34 <wli> Pseudonym: the even and odd convergents bracket to value to which the continued fraction converges when it converges
15:53:42 <Pseudonym> Yes.
15:53:52 <Pseudonym> Very handy.
15:53:57 <Pseudonym> Bisection, and all that.
15:54:07 <Pseudonym> Or even better, interval arithmetic.
15:55:59 <wli> Pseudonym: [.2784645427610737951093588, [x^2 , -1.242681450837286970980808], [x^2 , 1.122215877199311927508881], [x^2 , -2.691238166282790525894312], [x^2 , .6482451799197156369707172], [x^2 , -4.045837736135091227507229], [x^2 , .4620480694048691205496176], [x^2 , -5.367341331816616040171714], [x^2, .3607312491941607185211500], [x^2 , -6.669314654033993396713943], [x^2, .2965914438927225833976348], [x^2, -7.957865967739018492039795], [x^2, .2521867087581257341753
15:56:12 <Pseudonym> AH, interesting.
15:57:18 <Pseudonym> Because this appears to be an expansion in terms of x.
15:57:24 <Pseudonym> I wonder if that one is any better.
15:57:25 <wli> Pseudonym: [x^2, -9.236412416551024276999593], [x^2, .2195572037236054349547262], [x^2, -10.50710347965054887604018], [x^2, .1945344048499552842536276], [x^2, -11.77139888150075255512237], [x^2, .1747177602140631328367563], [x^2, -13.03034545539834580995070], [x^2, .1586247097643601376447720],
15:57:32 <Lor> Err.
15:57:43 <Lor> The ircpastepage is probably a better medium for such dumps.
15:57:50 <Pseudonym> Yeah, probably.
15:57:53 <wli> web
15:58:23 <LinkMasterSab> Why is Either defined as "Either a b" when it only has one type per constructor?
15:59:20 <wli> Pseudonym: Maple can do other things, like find Remez approximants on various intervals (least-squares rational approximants, with error bounds attached)
15:59:29 <wli> Pseudonym: And Pade approximants (which are good as starting points for iterative methods and extrapolate behavior way out into BFE)
16:01:01 <Pseudonym> Nice.
16:01:30 <Pseudonym> LinkMasterSab: Because the types on each constructor are different.
16:02:10 <LinkMasterSab> Pseudonym: Yes, but where does that make a difference?
16:02:38 <LinkMasterSab> I'm not criticizing it, I just want to know the rationale
16:03:00 <Pseudonym> data Either a b = Left a | Right b
16:03:21 <Pseudonym> It's what in Pascal you would call a variant record.
16:03:35 <Pseudonym> Variant records are pretty useless if the types that you're unioning are the same.
16:03:50 <Pseudonym> In set theory, it's a discriminated union.
16:03:54 <Pseudonym> In category theory, a coproduct.
16:06:26 <LinkMasterSab_> Ouch, sorry about that.
16:06:57 <LinkMasterSab_> I just thought of the reason why. If you had them all in a list and you wanted to use different types, you have to say 'a' and 'b' in order for them to BE the same type.
16:06:58 <LinkMasterSab_> Right?
16:08:37 <Pseudonym> Right.
16:08:42 <Pseudonym> Kind of.
16:08:47 <Pseudonym> I think I understood you, anyway.
16:09:38 <Pseudonym> Hmmm.
16:12:04 <wli> Pseudonym: found a closed form I think
16:12:07 <wli> http://mathworld.wolfram.com/PowerTower.html
16:15:15 <Pseudonym> Wow, some of those pictures are really pretty.
16:17:03 <wli> the domain of convergence is depressingly small
16:17:15 <wli> which is why root-solving appears to be useful
16:18:50 * LinkMasterSab gone.
16:27:02 <Pseudonym> Hmmm.
16:27:09 <Pseudonym> Well I couldn't get that continued fraction to work.
16:27:37 <Pseudonym> Let me think for a moment.
16:51:10 <CXDoctor> hi all
16:52:54 <Lemmih> Hey
16:54:13 <CXDoctor> so about haskell. it forces programming without side effects, right?
16:54:57 <wagle> carefully controlled side effects
16:57:31 <Cale> CXDoctor: Operations with side effects are given different types in the language, and so things with possible side effects and things which are pure are kept separate
16:58:56 <Cale> this lets you reason about code a quite a lot more efficiently... as most computations don't explicitly require IO to do their job, you can test them separately, and know that they will work the same way under any conditions
16:59:51 <CXDoctor> also
17:00:37 <CXDoctor> Im figuring that haskell does lazy eval by seeing if a function is run that has side effects
17:00:46 <CXDoctor> if none, the code doesnt need to be run.. is this right?
17:01:19 <Lemmih> No.
17:01:21 <Cale> It's more based on demand.
17:01:57 <Cale> If a value is needed, then definitions will be used to compute just as much as is needed to get that value.
17:02:40 <Cale> Values are demanded by IO. The only actual IO action which is run is main, which can in turn be composed of other IO actions.
17:18:56 <Lemmih> themaximus: Learning Haskell?
17:21:48 <themaximus> I've been stuck with school and haven't had much time for anything.
17:23:54 <ski> 'Floogle is the "possibly-therefore-true" modal logic operator'  :)
17:52:54 <a5> Cale> this lets you reason about code a quite a lot more efficiently < this isn't the the only reason why functional programming is important. as john hughes points out in the following paper, you could just leave side effects out of other programming languages and get the same result. the most important part is that you can use combinators like 'foldl', 'map', 'bracket' to combine pieces of code and get better modularity.
17:53:06 <a5> not to mention the class system, monads, etc.
17:53:09 <a5> http://www.md.chalmers.se/~rjmh/Papers/whyfp.html
17:53:17 <Cale> a5: yes I know
17:54:26 <a5> ok. but the paper struck a note with me, for a long time fp never really caught my attention, because people always explained it as he describes in the paper, in terms of what it lacks. and that's not what makes it powerful.
17:57:36 <a5> IOW, i don't think having your expressiveness restricted so that you can better reason about what you write should be a reason to choose haskell. maybe java.
18:00:22 <Lemmih> Did Cale say anything about limiting expressiveness?
18:00:29 <KrispyKringle> But these constructs, a5, are also to some extent replacements for those that would require side effects. As in, you *could* just use recursion all the time in place of loops (which generally require side effects to know when to terminate), but that's just a cheap replacement often, using scoping to replace variable reassignment. Map, fold, etc are alternatives to while, for, etc, that mean you aren't really limited.
18:01:04 <KrispyKringle> But I agree that simply being an alternative isn't a real reason to use it, if it weren't more expressive.
18:11:02 <a5> Limmih: not from my perspective. I'm just trying to suggest better ways to advertise the language. Sorry if I'm not contributing.
18:23:08 <a5> or things that should be pointed out. in my experience, outsiders fixate on the pureness, but i think it's only there to support the burden of the additional complexity which is made possible by the functional features, the class and type system, etc.
18:23:25 <a5> does anyone use HSQL?
18:24:03 <a5> i'm getting "Fail: unknown exception" for a program which just calls 'connect'
18:25:25 <Lemmih> a5: HSQL has a function for catching its exceptions.
18:25:36 <a5> ah, thanks
18:28:33 <KrispyKringle> im not sure i'd describe it as additional complexity, though, a5.
18:28:49 <KrispyKringle> in many ways haskell is much simpler than industrial imperative languages.
18:31:13 <a5> well, i mean the complexity it allows you to put in your programs. if that makes sense.
18:32:03 <a5> i'm kind of making this up as i go along
18:33:28 <KrispyKringle> heh
18:33:33 <KrispyKringle> no, i know what you mean
18:33:48 <KrispyKringle> this stuff can be mind-bending to someone used to just writing recipes for instructions for the machine.
18:34:05 <KrispyKringle> but in other ways, haskell and its kin are much closer to the sort of ideal of computation than, say, C.
18:36:10 <a5> i guess my intuition agrees with that statement. but it's hard for me to imagine how one would justify it.
18:53:42 <KrispyKringle> a5: which is closer to an algorithm written on paper?
18:58:15 <a5> well, both paper and programs are invented by humans, and 'ideal' suggests something a little more universal
18:58:38 <Pseudonym> Many algorithms are not specified in a pure functional style.
18:59:09 <a5> so, HSQL segfaults if I call getFieldValue before fetch. that's lame.
18:59:19 <a5> yeah, what Pseudonym said.
19:02:04 <KrispyKringle> well, again, a5, i think it's sort of universal to say it's higher level, but of course all of this is man-made. The entire universe of computer science is a human construct, so it's a bit odd to be looking for universal truths in it :P
19:04:54 <monochrom> I agree to disagree.
19:05:17 <monochrom> If you just said "most" not "entire" I would agree.
19:05:39 <a5> people *do* have ways of justifying the suitability of various sets of axioms for set theory, for instance. i'm not clear on the details. i think it's a branch of the philosophy of mathematics.
19:05:51 <a5> "the most universe"? ;)
19:06:15 <monochrom> yeah yeah...
19:12:57 <magnus-> I just had a funny idea: extend lazy computations with a hash table for each function. when a value is garbage collected it is also removed from the hash table. this way every computation would be memoized but memoization table would not grow unnecessarily
19:14:17 <a5> isn't that a weak reference or something?
19:14:43 <magnus-> so every function would be memoized
19:15:06 <Pseudonym> That assumes that you can hash arguments.
19:15:19 <Pseudonym> Do you want to hash unevaluated arguments to non-strict functions too?
19:15:31 <Pseudonym> What about higher-order functions?
19:16:03 <magnus-> it doesn't have to be deep hashing. if it's a number, use the number for hashihg. if it's something in memory, use it's address
19:17:24 <Pseudonym> Well that doesn't seem particularly useful.
19:17:26 <magnus-> higher order functions have an address too.. they are data too
19:17:27 <Pseudonym> Using its address.
19:18:08 <Pseudonym> If you're going to apply the exact same memory cell to a function more than once, then common subexpression elimination is almost certainly sufficient..
19:18:32 <Pseudonym> In combination with let floating.
19:18:45 <Pseudonym> Which has the advantage that it's also garbage collected aggressively.
19:18:50 <magnus-> i'm thinking about complex recursive functions on graphs for example, not simple local scope
19:19:00 <Pseudonym> Ah, I see.
19:19:04 <KrispyKringle> monochrom: ok, so im sure somewhere you can find an example to prove that "entire" is wrong. but i can't really think of one.
19:19:09 <KrispyKringle> :P
19:19:59 <Pseudonym> Silicon atoms are not man-made.
19:20:04 <Pseudonym> Hmmm.
19:20:24 <Pseudonym> Well, magnus, if you're doing that, I don't see how you get an advantage over using manual memoising CAFs.
19:20:36 <wagle> some silicon atoms are
19:20:42 <heatsink> I see one advantage: the memory won't stay in use forever.
19:20:55 <Pseudonym> Same with memoising CAFs.
19:21:02 <Pseudonym> Because they wouldn't really be CAFs.
19:21:13 <wagle> CAF?
19:21:20 <Pseudonym> CAF = Constant Applicative Form
19:21:44 * wagle goes back to sleep 
19:22:04 <Pseudonym> It's the standard way to do dynamic programming in Haskell.
19:22:15 <heatsink> My understanding was that memoising CAFs have a root (top-level) object that references memoized data.
19:22:41 <Pseudonym> Well that's true.
19:22:49 <heatsink> So the data is never unreferenced, thus it's never GC'd.
19:22:49 <magnus-> Pseudo: well, it was a crazy idea i got :)
19:22:54 <Pseudonym> But the technique applies to when the CAF isn't top-level, too.
19:23:06 <Pseudonym> i.e. it isn't a CAF :-)
19:23:20 <Pseudonym> But "memoising MFEs" doesn't have the same ring to it.
19:23:42 * heatsink wonders if let-floating could turn it into a CAF anyway
19:24:10 <heatsink> not all the time, of course, but when it's actually independent of locals.
19:24:21 <Pseudonym> Right.
19:24:33 <Pseudonym> But suppose it is a graph algorithm.
19:24:35 <magnus-> I could also imagine a system that twould memoize as much as it could, and remove memoisations in a random way when memory is exhausted
19:24:43 <Pseudonym> Presumably it depends on the specific graph.
19:24:51 <heatsink> magnus: I think that would be useful.
19:24:53 <Pseudonym> So it will not be independent of locals.
19:25:05 <Pseudonym> So long as the let is floated outside the recursive bit.
19:26:12 <Pseudonym> Here, this is a good example.
19:26:18 <Pseudonym> @wiki TyingTheKnot
19:26:19 <lambdabot> http://www.haskell.org/hawiki/TyingTheKnot
19:26:23 <Pseudonym> Go down to indirectToDirect
19:26:29 <Pseudonym> And look at tieArray.
19:29:44 <magnus-> I am not familiar enough with the haskell syntax to understand it i'm afraid
19:32:24 <magnus-> but the page is interesting. thanks
19:35:25 * heatsink figured out what the datatypes mean
19:37:46 <heatsink> oh, I see what you're pointing out.  tieArray's lifetime is local.
19:38:17 <Pseudonym> Right.
20:51:07 <shapr> a5: hiya
20:51:11 * shapr awakens
20:51:14 <shapr> good morning #haskell!
20:51:38 <wnoise> good morning
20:51:48 <Pseudonym> G'day.
20:52:36 <shapr> Anything exciting happening?
20:53:01 <shapr> Nifty new source code to read?
20:53:24 <wnoise> Nope.  But I got my keyboard
20:53:32 <shapr> oh cool, how do you like it?
20:54:00 <Pseudonym> Been doing numeric programming with wli.
20:54:04 <Pseudonym> That was a bit of fun.
20:54:36 <seidan> what type of numeric programming?
20:54:46 <Pseudonym> Trying to compute the Lambert W function.
20:54:53 <wnoise> So for so good.  I've slowed down a bit, but the mouse and text cursor features are real nice.
20:55:08 <desrt> shapr; i was supposed to remind you of something
20:55:21 <shapr> good morning autrijus
20:55:27 <shapr> desrt: oh? what?
20:55:45 <desrt> 15:36  * shapr remembers desrt, the early days...
20:55:53 * desrt hugs ridiculously large scrollback
20:56:03 <shapr> desrt: oh yeah..
20:57:38 <mflux> wnoise, which keyboard did you get?
20:58:13 <shapr> desrt: Your comment  "<desrt> wow.  i even understood that from their crazy math language" reminded me of discussions you had when you first joined #haskell. I was sort of wondering if my understanding changed in the same way yours has.
20:58:42 <desrt> ah :)
20:59:42 <desrt> it's scary how much math i've learned in the past year
20:59:45 <shapr> desrt: Do you think learning Haskell has changed the way you think about programming? Have you found any useful mental tools you can use in other languages?
20:59:52 <desrt> and how little of it was as a result of my classes
21:00:19 <desrt> hm.  that's not something that i often find myself thinking about
21:00:50 <desrt> i've learned some neat tricks for C as a result of hacking on the RTS but that hardly counts :)
21:02:36 <desrt> i've done some thinking about minimal copy-on-write data structures in non-functional languages but haven't actually use it yet
21:04:02 <shapr> Sounds interesting.
21:04:08 <wnoise> mflux: http://www.fingerworks.com/lp_product.html
21:04:11 <desrt> i'm not really a gifted haskell hacker
21:04:31 <desrt> i can do it... but it's not something i'm amazingly good at
21:05:14 <shapr> Neither am I. But I have learned a lot of neat things from using Haskell.
21:05:34 <desrt> hmm.  i always sort of thought of you as a master haskell coder
21:06:38 <shapr> Don't think so. I'm just really interested.
21:07:52 <desrt> hmm
21:07:55 <shapr> I think there are a few people who are amazingly good at hacking Haskell, say Oleg and Lennart Augustsson. I'm not sure why they're so good.
21:08:15 <desrt> i think wolfgang and wolfram are very good :)
21:08:44 <Pseudonym> You know, though, I'm not sure that Oleg could truly write a large application in Haskell.
21:08:51 <Pseudonym> Or, at least, I've never seen him try.
21:09:17 <shapr> He did work on takusen with Alistair Bayley. But that seemed to be for purposes of exploiting the left-fold thingy.
21:09:23 <Pseudonym> True.
21:09:26 <desrt> and what about the simons?
21:09:44 <desrt> they've written the most significant parts of the biggest haskell program i know of
21:09:46 <Pseudonym> John Hughes would probably be my nomination.
21:10:09 <shapr> What symptoms would you point out for great Haskell Hackers?
21:10:13 <Pseudonym> He knows his theory backwards, AND has a proven track record of non-trivial code.
21:10:54 <desrt> (i) knowing the catagory theory definition of "monad" :)
21:12:42 <shapr> What did John Hughes write in non-trivial code?
21:12:53 <Pseudonym> The pretty-printing library.
21:13:20 <Pseudonym> We do have the coloured belt grading system.
21:13:33 <shapr> Good point.
21:15:27 <shapr> Lots of older Hughes papers I don't think I've read yet.
21:16:34 <shapr> desrt: I think if I'm a master of anything, it's random ideas (not necessarily useful ideas, though)
21:17:01 <desrt> sort of the same here.  i feel like i spin my wheels a lot.
21:17:39 <Pseudonym> Hmmm.
21:19:24 <gzl> I don't think I ever finished whyfp
21:19:34 <gzl> something always interrupts
21:20:16 <shapr> I made a neat connection on the way to the denstist yesterday. I realized that the ideas in the Yampa/Fruit thesis are one step away from a declarative protocol specification language.
21:20:32 <shapr> gzl: you could read it now!
21:20:42 <shapr> But then I'd have to interrupt you.
21:23:19 <shapr> I think it'd be straightforward to turn Fruit into a tcp/ip stack made with arrows. I also realized that the whole secret is arrows that masquerade as other arrows. You could actually have smtp command parsing and ip header field parsing as part of the same arrow with a single state.
21:24:32 <shapr> Pseudonym: so is numeric programming the process of finding an equation solution in less steps?
21:24:57 <Pseudonym> Not just that.
21:25:10 <Pseudonym> Speed, accuracy and stability, in approximately reverse order.
21:25:35 <Pseudonym> And it's not just equations.
21:25:44 <Pseudonym> It's.. well, the whole of "Numerical Recipes" and then some.
21:26:17 <monochrom> A symptom of haskell hackers: you write \x->x^2
21:26:24 <Pseudonym> Yeah, eek.
21:26:36 <Pseudonym> I don't, though.
21:27:28 <monochrom> if you write that in #math, you are beyond hope. :)
21:33:07 <shapr> desrt: what qualifies as a master hacker anyway? Lots of produced code? quality code? deep understanding?
21:33:35 <desrt> perceived deep understanding :)
21:33:43 <monochrom> deep understanding ==> scientist, which is often the antithesis of hacking.
21:33:58 <desrt> monochrom; i disagree strongly
21:34:14 <desrt> deep understanding is the opposite of being an engineer
21:34:22 <desrt> and being an engineer is the opposite of being a hacker
21:36:03 <Pseudonym> A master hacker, for Haskell at least, as a deep understanding of both good theory and good practice.
21:36:23 <Pseudonym> Though it need not be deep in some areas.
21:36:30 <Pseudonym> Breadth and depth are a bit of a trade-off.
21:36:30 <wagle> whats wrong with \x -> x^2?
21:36:46 <ozone> desrt: so, what you're saying is that hackers == deep understanding?
21:38:48 <shapr> http://www.catb.org/~esr/faqs/hacker-howto.html#what_is
21:39:08 <wagle> i think hackers turn abstractions (1) on their head (2) inside out
21:40:28 <ozone> shapr: sure, that's if you follow ESR's definition of what a hacker
21:40:40 <ozone> personally, i think ESR can get a hot poker stick and shove it up his ass
21:41:09 <Gahhh> is anyone who programs a hacker ?
21:41:17 <shapr> I don't agree with everything ESR says, but he has some good points about wizardly hackers.
21:41:47 <wagle> 21:37 < wagle> whats wrong with \x -> x^2?
21:42:00 <shapr> Gahhh: No, I've known a lot of codemonkeys why just didn't care.
21:43:35 <monochrom> "delights in having an intimate understanding of the internal workings of a system..."
21:43:40 <desrt> ozone; yes.
21:44:05 <desrt> your typical by-the-book software engineer has exactly as much understanding as he/she needs to do their job
21:44:16 <dons> monochrom: that's my defn. it's about understanding the things hidden by the abstractions.
21:44:25 <ozone> desrt: i use the terms different here, but then again, in down under the water also spins the other way
21:44:29 <ozone> +ly
21:44:35 <Gahhh> Can I be a good programmer without being a hacker ?
21:44:43 <shapr> Gahhh: yes, I think so.
21:44:54 <monochrom> it refers to computing systems.  but you can generalize it to any system.  the cosmos is a kind of system too.  Is Stephen Hawking a hacker?
21:45:08 <Gahhh> Is Stephen Hawking doing anything to the universe ?
21:45:29 <shapr> Some people are good programmers because it's their job, and they want to be good. But when they clock out, they're not interested.
21:45:31 <dons> he's writing the commentary on the universe, surely?/
21:46:07 <Gahhh> Aren't we mistaking his excellence in the subject for hackerdom ?
21:46:28 <wagle> feynman dscribes hacking safes in the 1940's
21:47:10 <dons> yeah. safes and locks are good hacker topics. they're intricate and beautiful
21:47:19 <shapr> I think I see hacking as a joy in finding the edges and unusual spots of the behaviour of systems.
21:47:20 <dons> hmm. watches too
21:47:34 <ozone> dons: so are females, but i'll shut up now. :)
21:47:42 <ozone> before my WILD SIDE TAKES OVER!!!
21:47:43 <dons> lol!
21:47:54 <shapr> Hacking females tends to get you arrested.
21:47:55 <dons> watch out. ozone on a rampage
21:47:58 * wagle waits for answer
21:48:02 <monochrom> I try to throw out Stephen Hawking, and even Albert Einstein, Issac Newton, ... to stretch the limit of ESR's first definition.  Perhaps therefore I am also a definition-hacker.
21:48:27 <monochrom> perhaps I mean deal out, not throw out.
21:48:50 <wagle> my understanding is that esr is a wannabee
21:49:08 <Pseudonym> ESR is many things which I dislike, but he is not a wannabee.
21:49:48 <Pseudonym> The fact that most of his contributions are stuff that you haven't heard of, or take for granted, is proof that the system works.
21:49:58 <wagle> ok, how so (i want to hear somwething positive )
21:50:00 <shapr> fetchmail is really handy.
21:50:06 <shapr> and it just works, all the time.
21:50:14 <Pseudonym> ESR has written more HOWTOs than anyone could ever read.
21:50:34 <Pseudonym> He's also put in a lot of work converting old Linux documentation to DocBook.
21:50:43 <Pseudonym> Unsexy stuff like that.
21:50:44 <wagle> doesnt make him a hacker
21:50:58 <wagle> hacking isnt the only way to do good
21:50:59 <Pseudonym> Doesn't make him a wannabe, either.
21:51:11 <wagle> ok, hacker-wannabee
21:51:53 <shapr> I don't think he's a hacker-wannabee, he seems to be the real deal.
21:51:57 <Gahhh> ot: does anyone know how to remove certificates in Windoze ?
21:52:07 <shapr> But I wouldn't really know unless I got to work with him a bit.
21:52:10 <ozone> yep, it just makes him a tosser
21:52:35 <ozone> hmm, evil ozone is out a bit today.  sorry, will really be quiet now
21:52:52 <shapr> Parts of ESR's personal life are difficult for me to deal with, but that's not related to whether he's a hacker or not.
21:53:06 <Pseudonym> "Tosser" is definitely more accurate than "hacker-wannabe".
21:53:18 <wagle> whats a "tosser"?
21:53:24 <shapr> @wn tosser
21:53:25 <lambdabot> *** "tosser" wn "WordNet (r) 2.0"
21:53:25 <lambdabot> tosser
21:53:25 <lambdabot>      n 1: terms of abuse for a masturbator [syn: {jerk-off}, {wanker}]
21:53:25 <lambdabot>      2: someone who throws lightly (as with the palm upward)
21:54:03 <Pseudonym> The man likes the sound of his own voice.
21:54:11 <shapr> ESR wrote some of the standard Python libraries.
21:54:24 <wagle> well, if he really does produce good faq's and howto's..
21:54:26 <Pseudonym> He also wrote the original GNU sed.
21:55:00 <Gahhh> how about emacs ?
21:55:07 <shapr> I think there's also a problem with hackers who just hack and don't communicate. a) no one really knows how good they are b) they never share their knowledge
21:55:10 <Gahhh> did he have something to do with it ?
21:55:12 <Pseudonym> Emacs was written by RMS.
21:55:16 <Pseudonym> Also GCC.
21:55:17 <Gahhh> ah my bad
21:55:31 <Pseudonym> So I guess RMS' code contributions are technically more impressive.
21:55:41 <dons> esr wrote some of ncurses too
21:55:52 <shapr> So I'd rather have low level hackers that communicate well, instead of high level hackers who communicate badly.
21:55:54 <Pseudonym> Hmmm... I guess ESR wrote some of the stuff that comes with Emacs.
21:56:11 <wagle> i only skimmed part of the esr hacker-howto, and its BS
21:56:22 <shapr> How could it be better?
21:56:30 <shapr> You could always fork it :-)
21:56:46 <wagle> its preaching something, but that something is not hacking
21:57:29 <shapr> I really like it his hacker howto.
21:57:50 <wagle> open sources has little to do with hacking, for example
21:58:06 <shapr> True, but it's easier to get better when you can see examples of better.
21:58:17 <wagle> mm..  being kicked out of this coffee shop
21:58:20 <shapr> It's also nice to have a lot of visible systems in front of you.
21:58:25 <shapr> cya :-)
21:58:42 <Pseudonym> Fare well.
21:59:14 <Pseudonym> I think that ESR's greatest contribution, though, is that he's become the unofficial geek anthropologist.
21:59:50 <Pseudonym> Putting this stuff out in the open needed to happen at the time he did it.
21:59:53 <wagle> in the style of 19th century historians
22:00:02 <Pseudonym> I did notice that he tends to notice things after the event, rather than at the time.
22:00:13 <Pseudonym> Like the link between open source development and agile programming.
22:00:38 * Pseudonym wondered where he'd been for five years
22:00:38 <Gahhh> there's a link ?
22:01:25 <Pseudonym> Well, yes.
22:01:34 <Pseudonym> Open source development is extremely agile.
22:01:37 <Gahhh> I dont really know what agile is anyways
22:01:41 <wagle> me: "hacking is seeing behind the abstractions"
22:01:53 <Pseudonym> In fact, there's only one thing that open source developers don't do, and that's pair programming.
22:02:02 <Pseudonym> But that's made up for by many-eyeball code reviews.
22:02:08 <Pseudonym> And benevolent dictatorship.
22:02:12 <shapr> oss does do pair programming
22:02:13 <Pseudonym> In the better projects, anyway.
22:02:25 <shapr> At least, in the Python community, there are regular sprints.
22:02:35 <Pseudonym> I wouldn't say it's common.
22:02:51 <shapr> A sprint is where you gather people from around the world into the same room and pursue a certain goal. It's *very* productive.
22:02:55 <Pseudonym> The decentralised and timezone-independent nature of OSS makes it difficult.
22:02:57 * Pseudonym nods
22:03:01 <Pseudonym> I'd love to do that some time.
22:03:12 <shapr> The Haskell community does it too. See EuroHaskell =)
22:03:30 <ozone> Pseudonym: i try very hard to do it at least once per week, with some friends
22:03:39 <ozone> and yes, it's very productive, even if you're just all working on completely different stuff
22:04:58 <shapr> I think OSS tends to pick up useful practices.
22:05:34 <monochrom> I am anti-social.  I work worst in a sprint, unless each member works on his own stuff and little communication.
22:05:50 <monochrom> I work best solitude.
22:06:37 <shapr> Groups have a different sort of flow. Group flow has its own advantages.
22:07:04 <Pseudonym> I like pair programming, and then going away and single programming using what I've done in the pair.
22:07:15 <monochrom> If I am in a sprint that works as a group --- the Americans call it brainstorming --- chances are all the time is spent by me shooting down everyone's flawed ideas and no time for me to articulate my working idea.
22:07:33 <shapr> I'm really good at intuitive leaps, but I get easily frustrated with repetitive picky details. If I pair with someone who deals well with picky details, the both of us can be very productive.
22:08:57 <shapr> If I had the choice, I'd never do single programming again.
22:08:57 <monochrom> So you can also call me conceited and condescending, in addition to anti-social.
22:16:29 <Pseudonym> Must go.
22:16:44 <Pseudonym> I wonder if you could do a sprint over IRC.
22:17:10 <dons> yeah. you can.
22:17:11 <Pseudonym> Anyway.
22:17:13 <Pseudonym> Nytol!
22:25:28 <Lemmih> Woot. I made a ClanLib program which printed coordinates out on mouse clicks.
22:26:20 <Lemmih> In Haskell of course and without touching the FFI.
22:29:08 <monochrom> impressive.  what mechanism do you use?
22:30:04 <Lemmih> Hacanon + improved version of gccxml.
22:31:31 <Lemmih> @wiki HaCanon
22:31:31 <lambdabot> http://www.haskell.org/hawiki/HaCanon
22:47:05 * shapr hops
22:50:20 <musasabi> morning shapr
22:50:53 <a5> \me hates wnoise's keyboard
22:51:00 <a5> oh wait i did that wrong
22:52:27 * a5 hates wnoise's keyboard?
22:52:51 <a5> hi everybody
22:54:14 <musasabi> hello
22:54:26 <Lemmih> I keep running into code I don't understand. Pretty annoying since I wrote it myself.
22:56:13 <shapr> hiya a5
22:56:20 <shapr> heippa hei musasabi
22:56:28 <shapr> a5: dude, wazzup?
22:56:44 <shapr> a5: I really will reply to your email soon... I just have a bunch of deadlines.
22:56:56 <a5> what about my deadline
22:57:06 <shapr> What's your deadline?
22:57:19 <a5> NOW!
22:57:20 <a5> j/k
22:57:23 <shapr> Do your emails come with deadlines?
22:57:29 <ozone> shapr: i was going to ask what you do besides sit on irc all day :)
22:57:38 <a5> hey, that's a good idea
22:57:40 <shapr> ozone: I work hard for my money!
22:58:01 <shapr> ozone: no really, I'm a gigolo off irc.
22:58:15 <a5> shapr: i will add a new header to the rfc
22:58:16 <Lemmih> haha.
22:58:33 <a5> oh, *that* "hard"
22:58:54 <ozone> shapr: i prefer letting other people work hard for my money
22:58:59 * shapr grins
22:59:06 <shapr> Is that how Annodex happened?
22:59:23 <ozone> hehe, no, in annodex's case, i'm the main hard-working guy :}
22:59:50 <shapr> I didn't see the slashdot thread, were there any intelligent questions?
23:00:00 <shapr> a5: how are you liking Haskell?
23:00:05 <ozone> hmm, yeah, a reasonable amount
23:00:28 <a5> shapr: just as well, thanks. how did you know who i am, btw?
23:00:39 <shapr> a5: try /whois a5
23:00:42 <ozone> one thing which was very nice to come out of it, was that the comments about "prepping" at the beginning made me realise something else
23:00:58 <shapr> what?
23:00:58 <a5> shapr: sneaky
23:01:04 <ozone> which is that you need an apache module to handle the timed URI requests, and that's just not feasible if we want annodex to take over the world
23:01:17 <ozone> we cannot expect lots of web server operators to install apache modules
23:01:33 <ozone> so, i think we came up with a solution to that, which we'll have to toy with over the next fortnight
23:01:59 <ozone> but it'll be damn cool to be able to get all this working without any sort of special server support
23:02:41 <shapr> Just for advertising purposes, what's the Annodex url again?
23:02:46 * shapr feels like a talk show host
23:03:01 <shapr> ozone: So, your latest album is rising in the charts?
23:03:15 <ozone> www.annodex.net will do :)
23:03:25 <ozone> well, it's only the beginning
23:03:43 <shapr> You have big plans for your musical career?
23:03:56 <ozone> i think we can nail the no-special-server-required problem, and get the content creation tools out to the public, it'll start having some impact.  we'll see, though
23:04:06 <ozone> i used to be a muso, in a former life
23:04:27 <shapr> What's a muso?
23:04:31 <ozone> musician
23:04:37 <shapr> oh
23:05:00 <shapr> I found some great music in Adelaide recently.
23:05:09 <ozone> hehe, haven't written anything for years and years though
23:05:36 <shapr> I've never been able to sync up words and music.
23:05:38 <ozone> adelaide has a good music scene
23:05:46 <shapr> Have you heard of Greg Jones?
23:05:56 <ozone> nay
23:06:23 <shapr> somewhat minimalistic, but very nice - http://www.mp3.com.au/album.asp?id=6342
23:06:39 <shapr> Oh, my review is listed at the bottom of that page.
23:07:00 <ozone> cheers, will have a listen when i get home
23:07:06 <ozone> time to blow this joint
23:07:10 <ozone> l8r sk8rs
23:07:16 <shapr> cya!
23:08:54 <shapr> a5: any questions?
23:09:58 * Lemmih considers going to sleep after more than 12 hours of very produtive Haskell coding.
23:12:46 * shapr considers going unicycling after hours of productive sleeping.
23:13:59 <a5> shapr: do i look like a newbie?
23:14:15 <shapr> I can't see you. I don't know.
23:14:35 <a5> oh
23:14:39 <a5> i forgot
23:14:41 <shapr> But I try to help anyone who's here and might have questions.
23:14:48 <shapr> And that includes you.
23:14:55 <a5> no i was just kidding
23:15:00 * shapr grins
23:15:19 <musasabi> 'c
23:15:21 <shapr> Now if you had a webcam, then I could tell if you look like a newbie.
23:15:29 <a5> i'm trying to switch my project to HSQL since i decided against HaskellDB ...
23:15:35 <a5> oh that would be a bad idea
23:15:46 <shapr> Do I look like a newbie? -  http://www.scannedinavian.org/~shae/foto/need_haircut.jpg
23:16:08 <a5> anyway and i think i'm going to write something to use heterogenous lists as in the HList paper
23:16:09 <shapr> musasabi: 'd
23:16:26 <a5> so i don't have to explicitly name each column because that's dumb
23:16:40 <shapr> Why did you decide against HaskellDB?
23:17:18 <musasabi> How should StablePtrs be handled in concurrent applications? Given T1, which does a loop like: t1_loop = { sptr <- getSomeStablePtr; deRefStablePtr sptr >>= doStuff; t1_loop }, and other threads which can know "getSomeStablePtr will never return sptr_i again". How can I safely delete those?
23:17:58 <a5> shapr: because it's too buggy and i need to express things that i can't in haskelldb
23:18:10 <shapr> You could always jump in and help fix it :-)
23:18:15 <a5> i sent a bunch of queries to the list
23:18:18 <shapr> What can't you express in HaskellDB?
23:18:25 <shapr> Yes, I'm on the list.
23:18:58 <shapr> HaskellDB is a cool tool. I hope people start using it.
23:19:07 <shapr> It's a lot nicer than SQL.
23:19:27 <shapr> musasabi: can you hook the GC somehow? WeakRefs?
23:19:35 <musasabi> The problem is that if I know that it is safe to delete a StablePtr I don't know whether T1 happens to be just waiting to do deRefStablePtr with that one.
23:20:11 <a5> shapr: no 'in' expressions... no group by?
23:20:34 <musasabi> I don't think weak references would help.
23:21:01 <shapr> Hm, I'll have to go back and read your messages after unicycling.
23:21:20 <a5> no rand()?
23:21:38 <a5> i might be able to use haskelldb, i don't know
23:56:37 * Gokee2 is away: Sleep needed
23:57:42 * Gokee2 is away: Er i`m gone so leave me a memo i`m an UBER HACKER so I can read memos!
23:58:26 * Gokee2 is away: Er i`m gone so leave me a memo i`m an UBER HACKER so I can read memos!
