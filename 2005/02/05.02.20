00:00:29 <cm> yeah.. but keep it in mind as a fallback path if you try to enter multiline code and you haven't read about layouts yet :)
00:01:39 <cm> also, I think you cannot do type declarations on the toplevel, I think (someone correct me if I'm mistaken)
00:01:46 <MachinShin> i'm only in section 3, i'm barely anywhere :)
00:01:54 <Lemmih> cm: Haskell doesn't force layout on you. It _is_ possible to write really long and really ugly lines (:
00:02:01 <MachinShin> the use of 'let' makes things easier for this though.
00:02:42 <cm> Lemmih: I probably meant "non-layout"... the "{ ..; .. }" kinda stuff :/
00:02:47 <cm> +then ;)
00:04:26 <desrt> dons; poke?
00:04:37 <Lemmih> cm: Oh sorry. I misread your line.
00:04:44 * Lemmih goes to sleep.
00:05:02 * MachinShin still at the point i'm stuck on syntax issues. 
00:05:04 <cm> Good night Lemmih :)
00:09:23 <MachinShin> ok. so lemme see if i can explain the list comprehension here (part of the decl of 'fib')  : [ a+b | (a,b) <- zip fib (tail fib) ] it returns a list, whose elements are a+b, such that a,b are the retvals of the function zip.  zip is a standard function taking in the first value of zip, and the other vals of zip.
00:11:16 <cm> "...such that the pair (a,b) is the result of the application of zip."
00:11:34 <MachinShin> ah. ok
00:12:05 <cm> "zip is a standard function which, given two lists, returns a list of pairs containing each one element from the first and the second list in sequential order"
00:12:34 <cm> zip [1,2,3] [4,5,6] => [(1,4), (2,5), (3,6)]
00:13:31 <cm> "(the function returns after the shorter of both lists is exhausted)"
00:13:33 <cm> zip [1] [2,3] => [(1,2)]
00:14:21 <cm> in addition, there is a function zipWith, which essentially captures the pattern you are using in that list comprehension
00:14:48 <cm> namely:   zipWith f lhs rhs = [f a b | (a,b) <- zip lhs rhs]
00:15:11 <cm> hence:   fib = 1 : 1 : zipWith (+) fib (tail fib)
00:15:22 <cm> good night
00:15:44 <MachinShin> right, it swizzles them.
00:19:47 <cm> hrmm. is there a way in the IO monad to detect loops in data structures?
00:24:06 <MachinShin> night all
00:32:07 <xerox> 'morning
00:32:19 <heatsink> good morning.
01:22:57 <xerox> What type is "Integral" ?
01:43:45 <musasabi> xerox: it is typeclass
01:44:14 <xerox> Thank you.
01:45:22 <xerox> Can you explain to me why is that: I have "data Sum a = Exp a | Sum [Sum a]" then "(\(Exp n) (Exp m) -> n+m) :: forall a. (Num a) => Sum a -> Sum a -> a" but I get an error with "foldr (\(Exp n) (Exp m) -> n+m)"
01:53:02 <musasabi> hmm let me test that.
01:56:20 <lou-tse> xerox: you need to box the (n + m) again into Sum
01:56:30 <lou-tse> like Exp (n + m)
01:56:33 <xerox> lou-tse, why?
01:56:53 <musasabi> xerox: because of foldr
01:56:55 <musasabi> @type foldr
01:56:56 <lou-tse> because you fold on Sum :)
01:57:27 <xerox> Ah, I tought output type could be different from input type
01:57:47 <musasabi> xerox: but you use the output for input
01:58:04 <musasabi> foldr :: (a -> b -> b) -> b -> [a] -> b
01:59:20 <lou-tse> so, in the light of this, it's either (\(Exp n) m -> n+m), or (\(Exp n) (Exp m) -> n+m)
01:59:46 <lou-tse> oops...(\(Exp n) (Exp m) -> Exp (n+m)), i mean :)
02:01:07 <xerox> Ah-ha! (\(Exp n) m -> n+m) is what I wanted!
02:01:14 <xerox> foldr (\(Exp n) m -> n+m) 0 [Exp 2, Exp 1]  ==>  3
02:02:51 <lou-tse> whatever's best for you -- either would do the job, with some modifications
02:06:07 <lou-tse> can anyone explain what the problem is with this one: "class (Num n, Enum e) => Test n e where
02:06:07 <lou-tse> 	f	:: n -> e
02:06:07 <lou-tse> 	g	:: e -> n
02:06:07 <lou-tse> 	h	:: n -> e
02:06:07 <lou-tse> 	h	= f . g . f
02:06:07 <lou-tse> "
02:06:32 <araujo> Good morning.
02:07:36 <lou-tse> ghc says:
02:07:36 <lou-tse> Could not deduce (Test n1 e, Test n e1) from the context (Test n e)
02:07:36 <lou-tse> ...
02:07:36 <lou-tse> Probable fix:
02:07:36 <lou-tse> 	Add (Test n1 e, Test n e1) to the class or instance method `h'
02:11:05 <lou-tse> i have estab;ished that it is the definition of 'h' that introduces the problem, but the error message is completely uninteligible to me
02:13:06 <tintin> is abridge written in haskell ?
02:52:08 <dons> desrt?
03:07:05 <shapr> it's oh so quiet, it's oh so still...
03:09:21 <samc> you are likely to be eaten by a grue?
03:11:31 <xerox> shapr!!
03:12:12 <xerox> I'm trying misty-days from yesterday.. it's *suprising* usable..
03:18:24 <shapr> hiya xerox
03:18:56 <xerox> Impressive. :)
03:23:28 <shapr> hiya samc_, are you an adventure gruepie?
03:23:54 <samc_> no
03:26:31 <shapr> samc_: what do you do for fun?
03:26:51 <samc_> what is this fun you speak of?
03:27:08 <shapr> It's sold at Disney World.
03:28:48 <samc_> is it a good investment?
03:29:39 <shapr> The Total Cost of Ownership is high.
03:39:42 <samc> does reading cs pubs count as fun?
03:40:08 <shapr> Does for me :-)
03:40:38 <samc> there's your answer then :)
03:41:04 <shapr> My ISP shut me down for a coupla days until just now, so I've had a bunch of fun reading.
03:43:00 <samc> I would probably benefit from that, less collecting/skimming more in-depth studying
03:44:39 <shapr> I can only learn something well when I really use it.
03:45:35 <rtega> idem
03:48:02 <Oejet> Hello, TFK.
03:48:04 <shapr> rtega: ?
03:48:16 <TFK> G'day, Oejet.
03:48:59 <shapr> nyehowma lou-tse
03:49:09 <Oejet> TFK: Or could I say "priviet"?
03:49:46 <TFK> Oejet, that depends on your translatieration :-)
03:50:07 <TFK> And if you use unicode, you are better off with "привет". ;-)
03:50:33 <shapr> spasibo
03:51:02 <Oejet> TFK: I'm taking Russian lessons on monday evenings. :-)
03:51:43 <TFK> Прекрасно :-)
03:51:52 <TFK> shapr, nevoshto :-/
03:52:42 <lou-tze> hi
03:52:55 <shapr> __mattam__: magic method?
03:52:56 <TFK> Oejet, how goes the studying? I reckon it's a pretty horrible language for a non-native speaker...
03:52:58 <lou-tze> anyone here grok ghc type classes?
03:53:21 <shapr> lou-tze: I have some understanding, though I wouldn't say I grok them.
03:53:24 <TFK> A palindromic magic method, no less!
03:53:28 <__mattam__> sort of yes :)
03:53:59 <shapr> I wish the word for palindrome were palindromic.
03:54:10 <shapr> g'day mlh
03:54:14 <mlh> g'day
03:54:21 <mlh> quick question
03:54:25 <lou-tze> shapr: i seem to be stuck with something very stupid
03:54:27 <mlh> head "cat" returns 'c'
03:54:57 <mlh> head ["cat"]  returns "cat".     fine so far.
03:55:11 <mlh> why does head head ["cat"] get an error?
03:55:20 <lou-tze> shapr: i have this: class Test a b where { f :: a -> b;  g	:: b -> a }
03:55:24 <TFK> maybe head (head ["cat"])
03:55:32 <mlh> oh yeah
03:55:43 <shapr> mlh: right, you're trying to do (head head) first.
03:55:44 <mlh> ta
03:55:45 <Oejet> TFK: Kaniechna.  No, actually it's rather easy.
03:55:58 <TFK> You mean, "konechno"? ;-)
03:55:59 <lou-tze> shapr: and this won't compile:
03:55:59 <lou-tze> h	:: Test a b => a -> b
03:56:00 <lou-tze> h	= f . g . f
03:56:37 <TFK> Oejet, easy? Hmmm... how long have you been studying?
03:56:41 <Oejet> TFK: Konechno.
03:56:48 <lou-tze> shapr: any idea?
03:56:50 <Oejet> TFK: Since last monday.
03:56:57 <shapr> lou-tze: First of all, you're using multiparameter typeclasses, which I don't know much about. Second of all, you might really be wanting functional dependencies, which I know only slightly more about.
03:57:17 <TFK> Oejet, xD
03:57:21 <shapr> lou-tze: if you want to learn typeclasses from the bottom, you probably want to start with single parameter typeclasses.
03:57:27 <TFK> Oejet, you're really in for it...
03:57:55 <Oejet> TFK: Well, I had light exposiure to it for a couple of years.  Learning some words and sentences.  Then I decided I might as well learn it well.
03:58:11 <lou-tze> shapr: well, i've never encountered this kind of problem with single-param classes so far...
03:58:19 <shapr> lou-tze: what error do you get?
03:58:26 <lou-tze> shapr: so it seems bottom-less for me :)
03:58:45 <lou-tze> shpr: Could not deduce (Test a1 b, Test a b1) from the context (Test a b)
03:58:47 <shapr> Was that a purposeful joke on _|_ ? :-)
03:59:15 <lou-tze> shapr: err...to be fair - no :)
03:59:51 <lou-tze> shapr: ...nothing to do with _|_, anyway :)
03:59:55 <shapr> Try h :: (Test a, Test b) => a -> b
04:00:05 <shapr> maybe?
04:00:27 <lou-tze> shapr: ahem...that's off-target
04:00:41 <shapr> Maybe Test (a b) then?
04:00:52 <shapr> This sounds like a good time to read up on MPTC.
04:01:01 <TFK> Oejet, the best of luck. I hope you'll find it always easy :-)
04:01:40 <lou-tze> shapr: not that, either (i tried taht, too, even though it made no sense to me, and it did not work, much to my expectations :)
04:02:10 <lou-tze> shapr: ...so i'm partially gratified, but still stuck ;)
04:02:41 <Oejet> TFK: Thanks.
04:02:43 <lou-tze> shapr: what's MPTC?
04:02:53 <shapr> multiparameter typeclasses.
04:03:02 <shapr> Speaking of which, I wonder if the fact plugin for lambdabot would be easy to hack in again.
04:03:54 <shapr> Huh, wasn't there a MultiparameterTypeclass wiki page?
04:05:09 <lou-tse> shapr: i guess i will, then :)
04:05:17 <lou-tse> shapr: thanx
04:05:33 <shapr> By the way, are there many Haskellers in Bulgaria?
04:06:40 <lou-tse> well, i don't know of many, except for krasi angelov (ObjectIO guy) and a couple of others who have demonstrated occasional vague interest
04:06:55 <shapr> Krasi does a lot of stuff.
04:07:05 <lou-tse> i myself am a c++ guy, and that's what most of us are :)
04:07:10 <shapr> ObjectIO, HToolkit, and HSQL that I know about.
04:08:02 <shapr> Are you learning Haskell for school then?
04:08:03 <lou-tse> well, i don't know him personally, only heard of him in connection to ObjectIO (FWIK, HToolkit is relatively new)
04:08:06 <TheHunter> lou-tse, solved your problem?
04:08:32 <Oejet> TFK: I find this quite funny: http://duma.ru/
04:08:41 <lou-tse> TheHunter: nope, preparing to "read up" on MPTC on shapr's suggestion :)
04:08:56 <lou-tse> shapr: no, i'm long past this, already 7 years in the industry
04:09:16 <shapr> lou-tse: Cool! So How'd you get into Haskell?
04:09:25 <TheHunter> you need scoped type variables.
04:09:59 <lou-tse> shapr: ah...long story :)
04:10:17 <TFK> Oejet, lol...
04:10:18 <lou-tse> TheHunter: what are those?
04:10:27 <shapr> lou-tse: Oh, I want to hear :-)
04:10:28 <TheHunter> lou-tse, one sec.
04:10:55 <lou-tse> shapr: the funny thing is, i was surfing round the net, looking for an SQL alternative :)))
04:11:19 <lou-tse> shapr: ...which i did not find (not to my satisfaction, anyway)
04:11:31 <Oejet> TFK: Putinik bolshoj, pribolshoj medved.
04:11:54 <lou-tse> shapr: but i fortunately stumbled upon haskell instead :)))
04:12:09 <TFK> Oejet, "putinik"?
04:12:14 <shapr> Did you find HaskellDB? Do you know about Tutorial D?
04:12:18 <TheHunter> lou-tse, this works:
04:12:39 <Oejet> TFK: Da. :-P
04:12:45 <TheHunter> foo' :: Test a b => a -> b
04:12:45 <TheHunter> foo' (x::a) :: b = f (g (f x :: b) :: a)
04:12:48 <lou-tse> shapr: ...and, following wirt's wisdom about PL-s worth knowing, i decided that i must learn it :)
04:13:06 <TheHunter> to write this as a function composition you seem to need ghc 6.4.
04:13:23 <TFK> Oejet, ya ne ponyal :-/
04:13:29 <shapr> Was it Wirth? I thought it was Perlis? I don't know who, but I totally agree.
04:13:45 <lou-tse> TheHunter: ...which doesn't seem to be there for the lazy us that don't want to build it ;)
04:13:58 <lou-tse> TheHunter: thanx for the tip :)
04:14:02 <Oejet> TFK: Putinik malinkij Putin.
04:14:21 <jlouis> is HaXml in GHC6.2.2?
04:14:31 <shapr> I think it's a separate package.
04:14:41 <jlouis> I think too, but I want to be sure ;)
04:14:46 <lou-tse> shapr: yeah, wirth - sorry..."a programming language that does not affect the way you look at programming is not worth knowing"
04:15:13 <TheHunter> lou-tse, the problem is if you write f . g . f then f could also be f :: a -> c, g :: c -> a, so you need to tell the compiler that you want to use the a and b from your type signature.
04:15:24 <TFK> Oejet, vsyo ravno ne ponyal. Ya ochen otdalyon ot rossiyskoy politiki :-/
04:15:54 <shapr> Speaking of which, I was going through the Self tutorial some last night. I haven't used it since the mid-nineties.
04:16:38 <shapr> I desperately want a simple cross-platform graphics solution for Haskell. SOEGraphics is a pain to build. Anyone know if it would be hard to port to OpenGL?
04:17:31 <TheHunter> lou-tse, btw, you're not by any chance the Lu-Tse who posts at heise?
04:18:03 <lou-tse> TheHunter: no way :)
04:18:17 <TheHunter> alright, sorry.
04:19:36 <TheHunter> fwiw, in ghc6.4 you can write
04:19:43 <TheHunter> foo :: forall a b. Test a b => a -> b
04:19:43 <TheHunter> foo = f . (g::b->a) . f
04:19:47 <shapr> I had a random thought about a metalanguage for optimization passes yesterday. Is there already such a thing? Something where you can calculate the dependencies of passes?
04:19:49 <TheHunter> but foo' doesn't compile anymore...
04:20:47 <lou-tse> why is that?
04:21:18 <TheHunter> oh, i'm sorry it still does.
04:22:16 <shapr> hiya Forest
04:22:20 <shapr> How're the trees?
04:22:43 <Forest> just fine )
04:23:22 <shapr> How's the code?
04:23:57 <TheHunter> ghc6.4 only breaks scoping of higher-rank types: Couldn't match `forall a. a -> a' against `forall a. a -> a'
04:25:11 <Forest> no code yet - reading tutorials
04:25:13 <lou-tse> TheHunter: TMI...i'll need at least a week to let all this sink-in :)
04:28:14 * shapr tries to figure out how Tempate Haskell has changed in 6.4
04:35:12 <swiert> shapr: how is TMR doing?
04:35:23 <ntfirewall> I like to know how to construct a decision tree for merge sort with n=3
04:35:36 <shapr> I did some editing over the weekend, I need to send out edits.
04:35:53 <swiert> will the first edition be out on time?
04:36:24 <shapr> I surely hope so.
04:36:53 <shapr> If all the authors have their articles to me by monday, I think it'll be out on time.
04:37:18 <swiert> good stuff!
04:42:26 <lou-tse> shapr: my conscience has been nibbling on me, so i just checked...you were right, it was perlis, not wirth :)
04:42:51 <jlouis> shapr: you rather want your transformations to be as independent as possible
04:43:14 <jlouis> MLton did use some generic programming to select transformation order, as far as I remember
04:43:22 <shapr> lou-tse: in any case, both guys are worth reading about, and that bit of wisdom is worth applying.
04:43:23 <jlouis> *genetic
04:58:43 <rtega> shapr: idem is latin for "the same goes for me"
04:59:00 <rtega> http://dictionary.reference.com/search?q=idem
04:59:25 <shapr> jlouis: I was thinking that explicit properties and dependencies of the passes could allow you to have a smooth scale from -O0 to -O99, from one pass each up to brute force passes.
04:59:39 <shapr> rtega: ah, thanks
05:11:09 <jlouis> shapr: ah
05:12:03 <TheHunter> yay! an even more evil version of my monadic reflection stuff using usual implicit parameters seems to work.
05:14:15 <ski> heh >:->
05:14:33 <TheHunter> *Main> reset (callCC (\k x -> k (x+)) 5) :: Int
05:14:33 <TheHunter> 10
05:16:01 <TheHunter> *Main> reify (map (\x -> reflect [x,x+1]) [1,2]) :: [[Int]]
05:16:01 <TheHunter> [[1,2],[1,3],[2,2],[2,3]]
05:16:05 <ski> how about returning the cont. out from the callCC call, and jump back with it then ?
05:17:30 <TheHunter> i don't see how you want to type that.
05:18:27 <ski> data ContOrVal a = forall o. Cont (a -> o) | Val a
05:18:33 <ski> e.g.
05:18:38 <TheHunter> ok.
05:21:15 <ski> another variant :  data SelfContOrVal a = forall o. Cont (SelfContOrVal a -> o) | Val a
05:21:56 <ski> even   data SelfCont = forall o. SelfCont (SelfCont -> o)   is possible, but not as useful, maybe
05:23:49 <ski> (hm, or is newtype possible for single constr. with single arg, even when using existential quant. tyvars ?)
05:24:54 <TheHunter> *Main> reset (case callCC (\k -> C k) of V x -> x; C k -> unsafeCoerce# $ k (V 4)) :: Int
05:24:54 <TheHunter> 4
05:25:24 <TheHunter> the unsafeCoerce# only being there because of being not polymorphic enough crap.
05:26:30 * shapr thinks about polymorphic crap
05:26:33 <ski> hm, why not ?
05:27:12 <TheHunter> my callCC has type callCC :: ((a -> Cont r (forall b. b)) -> Cont r a) -> Cont r a
05:27:20 <ski> (hugs seems to accept existential newtypes, while ghc doesn't, hmmm ..)
05:27:47 <TheHunter> but that's somehow not enough...
05:28:53 <ski> is Cont r a an instance of Num ?
05:29:17 <qFox> ok i'm trying to concat a list of strings to one string ([String] -> String), http://www.rafb.net/paste/results/38FHg597.html
05:29:21 <TheHunter> type Cont r a = (?ans :: Shift r) => a
05:29:32 <qFox> i dont know how to pass on the list without the head...
05:29:48 <ski> TheHunter : or was this typing of callCC for the nonreflected version, while you used the reflected version in the examples above ?
05:30:16 <TheHunter> this typing is for the reflected version, where Cont r a is just a fancy notation for a context.
05:32:00 <TheHunter> more specifially, the reason why i needed unsafeCoerce# is the same as why this doesn't compile:
05:32:02 <TheHunter> case id :: (forall a. a -> a) of f -> (f 1, f 'c')
05:33:42 <ski> TheHunter : ok. not polymorphic enough, then ..
05:33:49 <qFox> why cant i do something like something list = something(drop 1 list)
05:34:15 <qFox> the argument to something should be list without the head...
05:34:37 <TheHunter> here's a working version:
05:34:39 <TheHunter> newtype C' a = C' { runC' :: forall o. ContOrVal a -> o }
05:34:39 <TheHunter> data ContOrVal a = C (C' a) | V a
05:34:39 <TheHunter> test1 :: Int
05:34:39 <TheHunter> test1 = reset (case callCC (\k -> C (C' k)) of V x -> x; C k -> k `runC'` V 4)
05:35:04 <ski> qFox : i can't see anything not working with your version, atm
05:35:19 <qFox> you mean its working for you?
05:35:28 <qFox> helium says the types dont match
05:35:54 <ski> qFox : though, there is a specific counterpart for 'head', called 'tail' that will give all elements but the head one of a list (provided it is nonempty)
05:36:03 <qFox> hm
05:36:05 <ski> qFox : no, i haven't tested it, just looked at it yet
05:36:43 <qFox> maybe i'm not allowed to use (++) as an operator?
05:37:12 <ski> TheHunter : hmmm, sorry, of course it shouldn't be existentially quantified (as i did it), but universally quantified ..
05:38:11 <ski> qFox : hmm, right
05:38:40 <ski> qFox : either use '++' as an (infix) operator, OR, use '(++)' as an ordinary (prefix) function
05:39:08 <ski> qFox : i.e. '.... ++ ....'  OR  '(++) .... ....'
05:39:12 <qFox> yeah
05:40:16 <qFox> ok, if my function needs [String], why does this not match with [a] ? i mean, now its telling me that tail is of type [a] and something requires [String]
05:40:27 <qFox> which is correct, but tail, in this case, is of type [String]
05:40:59 <Heffalump> is tail the standard tail, or one you've defined?
05:41:45 <qFox> standard
05:42:26 <ski> tail should have type  [a] -> [a],  or in your specific case,  [String] -> [String]
05:42:39 <ski> (not [a] or [String], i.e.)
05:42:48 <Oejet> qFox: Do you know about pattern matching?
05:43:47 <qFox> truth be told, i'm new to haskell, and its terms. if by pattern matching you mean that [a] -> [a] means that a should simply be of one type (String, Int, or whatever), then yes
05:43:47 <ski> qFox : maybe you could paste your specific error message (here or e.g. on rafb.net or hawiki/HaskellIrcPastePage)
05:44:43 <qFox> http://www.rafb.net/paste/results/Fwm9cv29.html
05:45:13 <qFox> oh
05:45:16 <qFox> tail v :(
05:45:28 <qFox> ehr, tail list
05:45:45 <ski> (qFox : that could possibly be seen as a kind of pattern-matching(unification), but i think what was meant here was things like your '[]' in 'something [] = ""' and more complicated such things on the left of the '=' sign)
05:46:28 <qFox> oh, i'm familiar with that type of pattern matching, but dont know yet how haskell behaves in this
05:46:43 <ski> ok
05:46:56 <ski> in your example here
05:47:17 <Oejet> qFox:  something (x:xs) = something xs ++ x
05:47:21 <ski> instead of writing  'something list = ...(tail list)...(head list)...
05:47:39 <ski> you could write 'something (h:t) = ...t...h...
05:48:16 <qFox> hm yeah.
05:48:16 <ski> qFox :  'h:t' means the same as '[h] ++ t' , btw
05:49:24 <qFox> btw, IS there a function for concatting a list of strings to one string? i couldnt find one so i figured it would be a good practice thing
05:49:37 <Oejet> qFox: concat.
05:49:52 <Oejet> @type concat
05:49:54 <ski> it is a good practice thing, but yes, there is such a function :)
05:49:55 <lambdabot> concat :: forall a. [[a]] -> [a]
05:50:01 <qFox> but concat only does it on a list of list of strings
05:50:21 <qFox> i looked at that...
05:50:32 <ski> qFox : see, it works for any list of lists, not just a list of strings (strings are lists of characters, you know)
05:50:44 <qFox> aye
05:50:59 <xerox> How can I count the number of same elements in a list? I mean something like going from [1,1,2,2,2,3,3] to [(1,2),(2,3),(3,2)].
05:51:03 <ski> the type String is the same as the type [Char]
05:51:44 <ski> xerox : even if they aren't contiguous ?
05:52:03 <xerox> ski, in my case are ordered and contiguous.
05:52:31 <TheHunter> map (head &&& length) . group then.
05:52:41 <xerox> &&& ?
05:52:42 <ski> @type group
05:52:44 <lambdabot> bzzt
05:52:52 <TheHunter> @type Control.Arrow.&&&
05:52:53 <lambdabot> bzzt
05:53:01 <TheHunter> @type Control.Arrow.(&&&)
05:53:02 <lambdabot> bzzt
05:53:13 <qFox> lambdabot is a bee..
05:53:19 <xerox> Oh my..
05:53:25 <xerox> @index group
05:53:29 <lambdabot> Data.List,List
05:53:37 <TheHunter> anyway (f &&& g) x = (f x, g x)
05:53:52 <Igloo> @type (Control.Arrow.&&&)
05:53:55 <lambdabot> (Control.Arrow.&&&) :: forall a c' c b.
05:53:55 <lambdabot> 		       (Control.Arrow.Arrow a) =>
05:53:55 <lambdabot> 		       a b c -> a b c' -> a b (c, c')
05:53:57 <musasabi> What is the best way to define multiple modules implementing the same interface in Haskell? Particularly from a documentation standpoint...
05:54:19 <TheHunter> Igloo, of course.
05:54:46 <xerox> TheHunter, can you point me to some doc about &&& and other `arrows' (I suppose) ?
05:54:50 <Igloo> musasabi: I don't think we really have a good way. Foo.Bar.Baz, Foo.Bar.Quux with Foo.Bar re-exporting one of them is most common I think
05:55:37 <TheHunter> xerox, the key observation is that (->) is an arrow.
05:56:01 <TheHunter> Therefore the functions (***),(&&&), first, second are nice functions that work on pairs.
05:56:28 <TheHunter> http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Arrow.html
05:56:51 <TheHunter> likewise (|||),(+++),left and right work on Eithers.
05:58:11 <xerox> I find difficult to understand how the function behaves only with the type signature :\
05:58:14 <musasabi> ok. Will just have to do it that way.
05:58:39 <xerox> <TheHunter> anyway (f &&& g) x = (f x, g x)
05:59:30 <TheHunter> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Control/Arrow.hs?rev=1.9
05:59:41 <TheHunter> look for instance Arrow (->)
05:59:47 <TheHunter> and instance ArrowChoice (->)
06:00:12 <jlouis> hmmm, Parsec takes some time gettin used to
06:00:28 <jlouis> Theres just too many damn things I need to look up
06:00:31 <xerox> Great.
06:02:06 <TheHunter> wow, ^>> and friends must be new :)
06:02:14 <xerox> This is going to help *so* much.. I always missed something like (&&&)
06:03:23 <Oejet> jlouis: I have the same feeling.
06:04:37 <esap> ^>> ?
06:05:04 <ski> "-- | Precomposition with a pure function."
06:05:08 <TheHunter> composition of an arrow with a pure function, obvioulsy
06:05:46 <TheHunter> s/obvioulsy/apperently/
06:07:42 * esap doesn't see the need for such composition.
06:11:52 <jlouis> Oejet: yes, and it is predictive per default... grrr
06:12:04 <jlouis> I would rather have had a non-predictive parser
06:12:50 <xerox> @index count
06:12:52 <lambdabot> Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Combinator
06:12:59 <xerox> Hmm..
06:13:41 <xerox> Okay, map (head &&& length) . gourp
06:13:46 <xerox> *group
06:14:34 <jlouis> TheHunter: map (head &&& length) . group was nice ;)
06:15:10 <Oejet> jlouis: Having a hard time fitting "try" in everywhere?
06:15:26 <xerox> I did know of group :\
06:15:32 <xerox> @index group
06:15:34 <lambdabot> Data.List,List
06:19:52 <jlouis> Oejet: yes, I know the performance implications of not left-factoring
06:29:29 <xerox> Do you know where (or how) "span" is defined?
06:32:04 <TheHunter> in the prelude
06:32:06 <TheHunter> @type span
06:32:08 <lambdabot> span :: forall a. (a -> Bool) -> [a] -> ([a], [a])
06:32:30 <xerox> Hm..
06:33:34 <xerox> What can I get from the signature? It gets a "selecting" function, a list, and returns a pair of lists
06:38:07 <TheHunter> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Aspan
06:38:14 <TheHunter> span p xs is equivalent to (takeWhile p xs, dropWhile p xs)
06:40:21 <TheHunter> (which can btw written as liftM2 (&&&) takeWhile dropWhile...)
06:59:48 <musasabi> Can I create two versions of a library - one for threaded rts and one for the nonthreaded one with GHC?
07:00:10 <Heffalump> @type (&&&)
07:00:12 <lambdabot> bzzt
07:00:37 <xerox> TheHunter, yay, without reading you I did (takeWhile (==x) &&& dropWhile (==x)) .. now I should check what's liftM2
07:01:46 <TheHunter> @type liftM2
07:01:47 <lambdabot> bzzt
07:01:55 <TheHunter> @type Control.Monad.liftM2
07:01:56 <lambdabot> Control.Monad.liftM2 :: forall r m a2 a1.
07:01:56 <lambdabot> 			(Monad m) =>
07:01:56 <lambdabot> 			(a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:03:01 <TheHunter> so importing Control.Monad.Reader, we have
07:03:07 <TheHunter> liftM2 :: (a -> b -> c) -> (r -> a) -> (r -> b) -> (r -> c)
07:03:55 <TheHunter> since "(->) r" is a monad.
07:04:24 <funkmando> hello, could anyone give me some idea on how to words function works?
07:04:35 <funkmando> i'm told it breaks a string into it's seperate words
07:04:53 <funkmando> but i have to take this string and return a data structure i defined
07:05:26 <xerox> Hmmm
07:05:42 <Oejet> funkmando: words "abekatten gik en tur" ==> ["abekatten", "gik", "en", "tur"].
07:05:48 <funkmando> cool
07:11:18 <funkmando> so if i have a data type i defined like this
07:11:18 <funkmando> data Shape =
07:11:18 <funkmando>    Rectangle Point Point | Circle Point Double
07:11:28 <funkmando> how would i write a function that took a string and returned something in that form?
07:11:52 <funkmando> i tried making it write an ordered pair, but with 3 entries
07:11:59 <xerox> TheHunter, I can't really understand liftM2, maybe because I can't really understand Monads.. Arrows seemed more "simple" to me
07:12:07 <funkmando> but it said can't match Shape against (t,t1,t2)
07:21:43 <qFox> i dont suppose haskell has variables?
07:21:48 <TheHunter> xerox, for the reader monad, liftM2 does the same as liftM2 f g h x = f (g x) (h x)
07:21:50 <qFox> not constants...
07:22:06 <TheHunter> it has variables, but no assignment.
07:22:16 <qFox> then whats the point of variables?
07:22:23 <qFox> oh right, i meant globals...
07:22:23 <xerox> TheHunter, nice, what is the reader monad, if I could ask?
07:22:30 <qFox> ok, tnx :)
07:23:21 <TheHunter> the reader monad "passes" an environment.
07:23:37 <xerox> Hmm.
07:23:57 <qFox> ok, then is it perhaps possible to define a constant from within a function?
07:24:24 <TheHunter> xerox, there is newtype Reader r a = Reader { runReader :: r -> a}, which looks more like other monads.
07:24:59 <TheHunter> but in fact, it is also done without the wrapping: instance Monad ((->) r) where ...
07:25:02 <TheHunter> qFox, nope.
07:25:04 <qFox> thing is, for this assignment we need to create a "sql" type of output, including the proper allignment. the padding requires the knowledge of hte longest string in the table, this means recursing thru it for every string. saving this length would increase performance by... well you can figure it out
07:25:38 <TheHunter> ah, you want where.
07:25:46 <qFox> the table isnt big or anything, but i'm just curiuous how to solve (optimize) this type of problem in haskel
07:25:47 <qFox> l
07:26:00 <qFox> i dont see how where will help?
07:26:22 <TheHunter> foo x = doStuff x maxLen where
07:26:36 <TheHunter>   maxLen = bar x
07:26:57 <qFox> hm, as the main call or something?
07:27:06 <qFox> or at least hte main call under which all that stuff is done...
07:27:13 <Heffalump> TheHunter: problem with doing it without wrapping is that you can clash with someone else's instance
07:27:24 <xerox> :t (->)
07:27:30 <xerox> @type (->)
07:27:31 <lambdabot> bzzt
07:27:36 <TheHunter> Heffalump, no it's defined like that in Control.Monad.Reader.
07:27:41 <Heffalump> oh
07:28:04 <TheHunter> :i (->)
07:28:07 <TheHunter> @i (->)
07:28:08 <lambdabot> Sorry, I don't know the command "i", try "lambdabot: @listcommands"
07:28:11 <TheHunter> @info (->)
07:28:45 <TheHunter> there's no info on that ...
07:31:15 <TheHunter> qFox, i don't quite see what you want to do. You can paste your code and I'll see if/how it can be optimized.
07:31:40 <funkmando> could anyone help with my problem?
07:32:06 <Heffalump> MPTCs are silly.
07:32:14 <Heffalump> Prelude Control.Monad.Reader> ask 5
07:32:20 <Heffalump> <interactive>:1:
07:32:20 <Heffalump>     No instance for (MonadReader r ((->) t))
07:32:20 <Heffalump>       arising from use of `ask' at <interactive>:1
07:32:20 <Heffalump>     In the definition of `it': it = ask 5
07:32:26 <qFox> hunter i understand what you meant with where, i'm gonna try and give it a shot
07:32:35 <Oejet> funkmando: Could you give an input/output example, i.e. f(4) = 3.
07:32:44 <qFox> the output needs to be exactly like here, http://catamaran.labs.cs.uu.nl/twiki/st/bin/view/FP/Practicumopdracht1 , at about half the page
07:33:22 <qFox> so for each tupel i (without WHERE or any variables) would need to get the max length of the strings of each column
07:33:31 <funkmando> Oejet thats the problem
07:33:42 <funkmando> i just know i need to return a string in the form of this data type
07:33:44 <qFox> which is simply slow :)
07:33:55 <funkmando> as an example
07:34:02 <funkmando> the sentence might be Rectangle (3,4
07:34:10 <funkmando> the sentence might be Rectangle (3,4) (5,6)
07:34:21 <TheHunter> qFox, even that might be shared, but it depends on the code.
07:34:21 <funkmando> and i need to turn that into my data structure
07:35:26 <xerox> TheHunter, can you tell me a working example of liftM2 with (&&&) ?
07:35:48 <TheHunter> *Main Control.Monad.Reader> ask 4
07:35:48 <TheHunter> 4
07:36:06 <funkmando> which is Rectangle Point Point | Circle Point Double
07:36:18 <funkmando> and Point has been defined as (Double, Double)
07:36:23 <xerox> Okay, brb
07:36:26 <TheHunter> xerox, don't read to much into the liftM2 stuff, it's kind of a hack
07:36:36 <xerox> Thanks much!!
07:36:39 <qFox> yeah, i'll fiddle about a bit. its good practice, i havent coded in haskell before and the first test is this week, so i figured i'd get some handson experience ;)
07:36:54 <xerox> TheHunter, ah! Okay, brb, it's all so much interesting.
07:37:04 <qFox> (but not new to coding, just to haskell)
07:37:56 <qFox> i'm just gonna let that where pass on a table of max lengths
07:37:56 <Oejet> So like: f "Rectangle (3,4) (5,6)"  ==> Rectangle (3,4) (5,6)
07:38:05 <qFox> a list.
07:38:32 <funkmando> yeah
07:38:54 <funkmando> so do i need to use words to split it into it's parts?
07:39:08 <wli> bourbaki: about?
07:39:35 <Oejet> You want to parse it.  Maybe there is an easier way...
07:39:49 <Oejet> @type read
07:39:51 <lambdabot> read :: forall a. (Read a) => String -> a
07:39:58 <qFox> bourbaki, wli, omg i sense evil present!
07:40:08 <wli> qFox: eh?
07:40:40 <qFox> its a small world, is all
07:40:45 <funkmando> so just read the string?..
07:40:50 <Oejet> funkmando: If you could somehow make your datatype an instance of class Read, then: read "Rectangle (3,4) (5,6)", would work, I think.
07:41:02 <funkmando> hmm
07:41:02 <wli> qFox: Sorry, I'm rather confused by your remarks. Could you clarify?
07:41:08 <qFox> #asm efnet
07:41:36 <qFox> and bourbaki on #ai :)
07:41:48 <qFox> i think
07:41:58 <xerox> re
07:42:49 <Oejet> funkmando: Try adding  "deriving Read" just after your datatype declaration.
07:44:09 <metaperl> I think I am going to need some support material on type classes... "Gentle Introduction" was a bit too terse for me... any suggestions? I
07:44:24 <metaperl> I am willing to buy a book or two if need be
07:46:56 <TheHunter> Heffalump, you need -fno-monomorphism-restriction for that to work. ask 'c' will work fine in any case.
07:47:39 <Heffalump> oh, right. /me tries to work out why the monomorphism restriction affects this
07:48:16 <Heffalump> I suppose it had no way of knowing not to look for  MonadReader Int ((->) Integer)
07:49:51 <Heffalump> hmm, that doesn't explain it
07:50:02 <funkmando> Oejet it's saying Read is out of scope
07:50:33 <funkmando> do i need an import for that function?
07:51:19 <Oejet> @info read
07:51:21 <lambdabot> -- read is a variable
07:51:21 <lambdabot> read :: forall a. (Read a) => String -> a
07:51:30 <Oejet> @index Read
07:51:31 <lambdabot> GHC.Read,Prelude,Text.Read
07:51:49 <xerox> TheHunter, is "Generalizing Monads to Arrows" a good place to start from?
07:52:39 <TheHunter> xerox, i'd suggest to start with "Arrows and Computations" and then read Hughes' paper.
07:52:58 <Oejet> funkmando: Try "import Text.Read"
07:53:33 <funkmando> no go
07:53:40 <funkmando> data constructor not in scope
07:53:42 <funkmando> : Read
07:54:20 <Oejet> Could you paste the code somewhere?
07:54:36 <Oejet> lisppaste2: url?
07:54:44 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
07:55:33 <funkmando> http://cpp.enisoc.com/pastebin/?5258
07:56:59 <Oejet> funkmando: Is the error at line 17?
07:57:11 <funkmando> wqell it says 18
07:57:11 <Oejet> Er, 18?
07:57:14 <funkmando> yes
07:57:53 <Oejet> Data constructors always begin with a big letter.  You need "read".
07:58:10 <TheHunter> xerox, or you might want to dig into monads first
07:58:17 <TheHunter> @hawiki MonadsAsContainers
07:58:17 <lambdabot> Sorry, I don't know the command "hawiki", try "lambdabot: @listcommands
07:58:21 <TheHunter> @wiki MonadsAsContainers
07:58:22 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
07:58:39 <funkmando> damn
07:58:42 <xerox> TheHunter, I'd like to
07:58:42 <funkmando> now it says line 13
07:58:49 <funkmando> invalid class assertion
07:58:52 <funkmando> weird
07:59:42 <MachinShin> morning all
07:59:53 <Oejet> Try  type Point = (Double, Double)  deriving (Eq, Show, Read)
08:00:13 <Igloo> You can't derive things for type synonyms
08:00:26 <Oejet> Igloo: Says who?
08:00:39 <Oejet> :-P
08:01:27 <Oejet> Hm, then I'm out of suggestions.
08:02:04 <funkmando> il try it anyway, lpl;
08:02:05 <funkmando> lol*
08:02:06 <TheHunter> i don't think it's that bad an idea to start with arrows and move over to monads afterwards, but there's not much literature on arrows and it assumes more prerequisites than the introductionary texts to monads.
08:02:27 <funkmando> no
08:02:29 <Igloo> What's the problem?
08:02:33 <funkmando> still "invalid class assertion"
08:02:39 <funkmando> http://cpp.enisoc.com/pastebin/?5258
08:02:55 <funkmando> note i changed the Reads to read except with the import
08:03:02 <xerox> TheHunter, (&&&) really impressed me, and I find it more or less easy to use.. while Monads appears to me as a huge/dark/blurry monster.
08:03:09 <Oejet> Igloo: Parsing a user defined data type with "read".
08:04:07 <Oejet> funkmando: It should be "deriving (Show, Read)" with an R.
08:04:11 <Igloo> "hy lol" isn't of type Double for a start
08:04:29 <Igloo> Other than that it works for me
08:04:33 <funkmando> hmm
08:04:59 <Igloo> What command is failing for you?
08:05:10 <funkmando> 13
08:05:19 <funkmando> illegal class assertion
08:05:29 <Igloo> No, I mean something like "hugs foo.hs"
08:05:47 <jlouis> xerox: arrows are general. More so than monads
08:05:56 <funkmando> :load test.hs
08:06:35 <xerox> jlouis, I'm reading the wiki page about Monads now, I'll try to understand.
08:06:52 <Igloo> ghci or hugs? Which version? Quit and start fresh to make sure it's not got confused
08:06:59 <funkmando> ok
08:07:41 <Igloo> You have "Read" on lines 4 and 9 and "read" on line 18, right?
08:07:42 <xerox> Apples and blueberries help much :))
08:07:50 <funkmando> igloo ah
08:07:52 <funkmando> no
08:08:33 <funkmando> now it says the deriving thing is wrong
08:08:37 <funkmando> but you said that was bad earlier
08:08:40 <xerox> @index join
08:08:41 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
08:08:41 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
08:08:41 <lambdabot> State,Control.Monad.Writer,Monad
08:08:42 <Igloo> Ah, ghci's error position reporting isn't great there
08:08:51 <funkmando> aha
08:08:53 <funkmando> compiled
08:09:04 <Igloo> Anyone got ghc 6.4 handy?
08:09:05 <funkmando> excellent
08:12:28 <Oejet> funkmando: Working?
08:14:58 <funkmando> yeah
08:15:08 <funkmando> now i gotta extract the elements out of shape..
08:15:44 <funkmando> but its' not a list or anything so icant really go s !! 0 to get at what type of shape it is
08:17:47 <Oejet> funkmando: Pattern matching:  match x with Rectangle p1 p2 -> foo; Circle c r -> bar
08:18:06 <funkmando> ah
08:18:09 <funkmando> do i write functions for that?
08:18:35 <funkmando> so a function that takes a shape and returns... a part of the shape data type lol
08:21:35 <Oejet> area (Rectangle (x1,y1) (x2,y2)) = ...
08:21:36 <Oejet> area (Circle (x,y) r) = ...
08:22:12 <Oejet> That's also pattern matching, but at the function definition level.
08:22:17 <funkmando> ah
08:22:18 <funkmando> smart
08:28:24 <funkmando> is there a way to say any other in put is denied?
08:28:37 <funkmando> so like area (anything else) = "STFU NOOB"
08:28:56 <TFK> area _
08:29:28 <funkmando> @type _
08:29:30 <lambdabot> bzzt
08:29:43 <Oejet> funkmando: It cannot have any other input than Rectangle and Circle.
08:30:30 <funkmando> but i want a user friendly error message if someone typos rectangle
08:30:34 <funkmando> not variable not in scope
08:30:39 <funkmando> or what have you
08:31:00 <Oejet> funkmando:  Then you will get a read error during parsing.
08:31:46 <funkmando> i see
08:31:50 <funkmando> cos it has to return a double
08:31:52 <Oejet> read can only return a Shape or an error.
08:32:23 <funkmando> oh sorry
08:32:30 <funkmando> im not using that function right now
08:32:36 <funkmando> using area
08:32:49 <funkmando> which takse a shape and returns a double
08:33:22 <Oejet> funkmando: Yes, you are garanteed by the type system, that area will always get a Shape.
08:34:53 <Oejet> So any errors will happen in "shape :: String -> Shape" only.
08:35:56 <Oejet> funkmando: Am I understanding you correctly?
08:43:43 <xerox> I can't imagine why is worth learning Monads, can somebody explain to me?
08:45:01 <tic> they encapsulate state for you
08:46:16 <MachinShin> so it's like an object?
08:46:32 <tic> I suppose.  I
08:46:49 <tic> I'm not really good at monads, but I see them as a mean of encapsulating a computation. or transforming, perhaps.
08:54:20 <Forest> having a list, how can i print its elements to screen ?
08:55:50 <lightstep> mapM_ print
08:56:22 <Forest> more details plz
08:56:27 <lou-tze> ...or maybe just print?
08:56:53 <lightstep> lambdabot: type mapM_
08:56:54 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
08:57:02 <lightstep> lambdabot: @type Monad.mapM_
08:57:04 <lambdabot> Monad.mapM_ :: forall m a b. (Monad m) => (a -> m b) -> [a] -> m ()
08:57:43 <lightstep> As you can see, if you can produce IO () from every element (that is print), you can produce an IO () from the whole list
08:58:49 <Forest> i want to do putStrLn (show(n) ++ " Some text") for each element n of a listy
08:58:52 <Forest> *list
08:59:31 <funkmando> @type sum
08:59:33 <lambdabot> sum :: forall a. (Num a) => [a] -> a
08:59:41 <funkmando> @type zip
08:59:43 <lambdabot> zip :: forall b a. [a] -> [b] -> [(a, b)]
08:59:44 <funkmando> @type map
08:59:46 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
09:06:48 <qFox> am i not allowed to do something like this?   str _ (len <= 0) = ""
09:07:09 <qFox> to check whether a given parameter is 0 or negative?
09:08:04 <lightstep> it depends on what `str', `len' and `<=' are
09:08:12 <qFox> str :: Int -> Int -> String
09:09:03 <qFox> what do you mean <= btw, isnt that a normal lesser or equal then?
09:09:05 <lightstep> so you probably mean str _ len | len <= 0 = ...
09:09:09 <lightstep> it's called a guard
09:09:21 <qFox> oh ok
09:09:27 <lightstep> and you can hide (<=) in your module
09:10:54 <Forest> is there if's without then in the language ?
09:11:07 <Forest> is there if without then in the language ?
09:11:41 <qFox> would you mind giving an example in which this is usefull? just out of curiosity
09:11:52 <lightstep> Forest, no
09:12:11 <lightstep> qFox, it isn't useful
09:12:16 <qFox> i know that
09:12:22 <Forest> <qFox> i was printing a list to screen
09:12:23 <Forest> pr l =
09:12:24 <Forest>    if length(l) > 0
09:12:24 <Forest>       then do
09:12:24 <Forest>         putStrLn ((show (head l)) ++ " factorial is " ++ (show (fact (head l))))
09:12:24 <Forest>         pr (tail l)
09:12:24 <Forest>       else do
09:12:25 <qFox> but he's asking for it, so i'm guessing he has a use to it...
09:12:26 <Forest>         return []
09:12:39 <lightstep> unless you run out of operators, and prefer to give up on numbers
09:12:53 <Forest> else here is redundant
09:13:08 <qFox> you mean if without else
09:13:23 <qFox> and no, its not the same ;)
09:13:35 <Forest> yes ))) of course, sorry
09:13:59 <qFox> (ok, that could depend on how branching is implemented i suppose)
09:14:47 <Forest> i just could't compile the code above without else
09:15:37 <lightstep> but if you know the condition is true, you don't have to test it anyway
09:15:48 <lightstep> hence you won't need an if at all
09:16:10 <Forest> i ve posted a piece of code above
09:16:13 <Forest> is it recursiv
09:16:14 <Forest> e
09:16:31 <Forest> so condition is not constant
09:16:42 <shapr> How many recursions does it take to screw in a lightbulb?
09:16:53 <qFox> :p
09:17:10 <shapr> c'mon the answer is obvious! it's n-1 recursions!
09:17:19 <lightstep> Forest, the idiom that is used for things like you posted is pattern matching
09:17:46 <shapr> Let's see, who can I pester for TMR articles?
09:17:52 <shapr> Philippa: y0, article?
09:17:54 <Forest> pattern matching ??? why here
09:18:00 <shapr> musasabi: heippa hei
09:18:00 <lightstep> on l
09:18:10 <shapr> autrijus: namaste
09:18:15 <lightstep> to see if it's null or not
09:18:22 <goron> Anyone working with an USB mouse and Debian?
09:18:24 <lightstep> (the length call is very inefficient anyway)
09:18:30 <shapr> goron: yeah, I got it working.
09:18:48 <shapr> goron: my question now is how to get X to tell buttons 3 and 4 apart.
09:18:56 <goron> shapr: You are a wizard. Can you help me? lsusb gives my mouse at address two.
09:19:18 <goron> shapr: I want it to use with cat to see whether my mouse works.
09:19:27 <Forest> but what i m trying to do - getting rid of else keyword -that's all
09:19:32 <goron> shapr: I can't find the device file.
09:19:47 <shapr> um, I just did a modprobe on the usb kernel module, added a usb entry to XF86Config-4 and it worked.
09:19:54 <autrijus> oh. right. article.
09:19:59 <autrijus> i've been writing lots of journals. :)
09:20:04 <shapr> yeah, they're fun to read.
09:20:05 <autrijus> I'll just recollect them :)
09:20:34 <lightstep> Forest, if you want if, you must have an else. exp^10 -> if exp thewn exp else exp. no escape
09:20:34 <shapr> Someone has both you and me in their functional and blog del.icio.us collection.
09:20:36 <goron> shapr: Can you past your entry?
09:20:37 <shapr> I was amazed.
09:20:48 <goron> shapr: In #flood
09:21:08 <shapr> I was mostly amazed that this person thought my journal was an FP journal. I don't think I put any code in there.
09:21:10 <Forest> lightstep: but in the function i ve posted else is no use
09:21:49 <lightstep> Forest, why? it determines the return value of the function
09:22:04 <Philippa> shapr: 'lo
09:22:13 <shapr> goron: I only changed it to point to /dev/input/mice
09:22:26 <shapr> Philippa: shazbot!
09:22:45 <lightstep> Forest, you can't have recursion without the base case (except for shapr's jokes)
09:22:56 * shapr snickers
09:23:28 <Forest> lightstep: i dont use return value, i written that line because i couldn't compile without else and i couldn't compile with empty else branch
09:23:41 <Forest> *wrote
09:24:26 <Forest> lightstep: so return value is always required  ?
09:24:36 <lightstep> yes
09:24:46 <Forest> i see now, thanks
09:25:09 <araujo> Hello all
09:25:14 <shapr> @seen all
09:25:15 <lambdabot> I haven't seen all
09:25:21 <lightstep> @seen *
09:25:21 <lambdabot> I haven't seen *
09:25:23 <shapr> hiya araujo
09:25:58 <shapr> funkmando: y0 y0
09:28:38 <shapr> I wish citeseer had an rss feed.
09:29:28 <MachinShin> why is the prompt in ghci  "Prelude>"  ?
09:29:43 <shapr> Because that's the module loaded. Try :m + Data.Map
09:29:53 <shapr> err, :m + Data.List
09:29:55 <lightstep> it's the list of modules in scope
09:30:00 <shapr> guten abend flori
09:30:29 <shapr> I have to remember Data.Map isn't in 6.2
09:30:31 <MachinShin> lightstep: meaning there are no modules in scope now?
09:31:06 <lightstep> only the Prelude is in scope
09:31:21 <lightstep> shapr, is it in 6.4?
09:32:22 <lightstep> MachinShin, Prelude is a module. it contains useful types like numbers and strings.
09:32:29 <desrt> dons; pong
09:32:32 <shapr> Yes, there are a bunch of new modules coming up in 6.4
09:32:48 <MachinShin> ah. so in theory you could load up ghci w/o even the Prelude module?
09:34:24 <shapr> yup
09:34:27 <lightstep> try :m - Prelude
09:35:07 <MachinShin> ah. ok.
09:35:13 <Philippa> 'lo MachinShin
09:35:38 <qFox> whats the invert of readInt ?
09:35:44 <lightstep> show
09:36:00 <MachinShin> can't do shit w/o Prelude though. tried typing '5+5' and it gave me an error on +
09:36:03 <MachinShin> hey Philippa
09:36:33 <qFox> so Int -> String
09:36:59 <Philippa> show
09:37:18 <qFox> helium doesnt know show...
09:37:22 <Philippa> ah
09:37:31 * Philippa doesn't know helium :-)
09:37:34 <qFox> :)
09:37:36 <Philippa> tried showInt?
09:37:43 <qFox> gah
09:37:50 <qFox> why would the docs miss such :\
09:38:51 <qFox> and oh wait i already mailed about that :) they mentioned the function in an example but did not explain it.
09:38:53 <lightstep> helium always has the type name appended to the generic function
09:40:44 <Oejet> IIRC Helium doesn't implement type classes yet.
09:41:04 <Philippa> I got the impression that it may never do just because they're the complicated bit of Haskell 98's type system
09:41:55 <qFox> oejet is correct, it is mentioned on the website. however helium is a creation of some wizzes on my university so they're promoting it like hell
09:42:01 <qFox> and, well its working pretty nicely so far
09:42:59 <Heffalump> I think the main reason they don't want to implement them are that they make it harder to teach basic types.
09:43:39 <Oejet> qFox: Is functional programming mandatory a your uni?
09:44:02 <qFox> it is for my study, artificial intelligence
09:44:11 <qFox> haskell and prolog
09:44:19 <qFox> (and java of course...)
09:44:21 <shapr> eek
09:44:56 <Oejet> Mmmm, Java, mmmmmm.
09:45:03 <qFox> they teach prolog first though, which is a wise choice i believe, seeing how most of my fellow students never coded a single word in their lives
09:45:14 <Philippa> Oejet: didn't know you're into coprophagy? :-)
09:45:30 <shapr> I would love to talk to someone who learned Prolog first and Haskell second. That would be a neat perspective.
09:45:39 <Oejet> Philippa: I didn't know it was called that. :-P
09:46:07 <qFox> well... it was my first contact with a logical language, and i think haskell is the first for being functional
09:46:13 <Spark> shapr: if i learn haskell, that'd be me :)
09:46:15 <qFox> but not exactly the first "weird" language :)
09:46:24 <Philippa> Oejet: how else would one like the taste of Java? :-)
09:46:35 <shapr> Spark: any procedural languages mixed in there?
09:46:50 <qFox> but i do believe its best to learn prolog before anything else, because it took me quite some time to get adjusted to prolog's way of thinking
09:47:01 <Oejet> They used to teach SML in introductory programming at DTU.  Now it's Java.
09:47:02 <Spark> yeah c, some c++, java, ada
09:47:10 <qFox> and it does make haskell easier to understand, in respect to lists
09:47:37 <Spark> recursion is essential for prolog
09:47:45 <Spark> especially with the lack of things like 'map'
09:47:47 <qFox> yeah but i was familiar with recursion
09:48:03 <Spark> pattern matching :)
09:48:15 <qFox> i did hear several complaints of my fellow students that they still dont understand recursion very well though
09:48:22 <Spark> prolog is basically just a functional language, with back tracking, and more advanced pattern matching, right?
09:48:36 <qFox> its evil, but no its a logical language
09:48:41 <sh10151> typical programmers don't understand anything, I've decided
09:48:44 <qFox> its really just a "trial and error" language if you ask me
09:48:49 <shapr> sh10151: heh, what does that mean?
09:48:53 <Philippa> Spark: no, IIRC predicates aren't first class
09:49:00 <shapr> sh10151: oh, I see. Yeah, you're probably right.
09:49:11 <qFox> prolog just tries to match anything and fails only if every option has been tried
09:49:15 <Philippa> also, the control flow is completely different even if it's related
09:49:28 <Spark> yeah thats the backtracking bit
09:49:33 <qFox> aye
09:49:36 <Philippa> I mean yeah, you can sum up a lot by saying haskell = graph reduction, prolog = DFS...
09:49:38 <Spark> which you really really have to be aware of if you write anything sophisticated
09:49:49 <sh10151> there's one guy I know who will take Perl code and remove "my" from all variable declarations
09:50:21 <qFox> well, prolog is a nice idea, but it would never be my language of choice, not even for language parsing (which is why we're required to learn it)
09:50:56 <qFox> it cant even freaking get input without its mandatory . suffix! well, not builtin anyways
09:51:07 <lightstep> sh10151, does he have an excuse?
09:51:29 <sh10151> "my" is unnecessary and slow
09:51:34 <shapr> I have a doctor's excuse. My doctor says I'm excused from all programming on grounds of cluelessness.
09:51:44 <sh10151> I have found that ignorant programmers often use "slow" vs "fast" as excuses
09:51:59 <shapr> sh10151: I totally agree with you.
09:52:01 <sh10151> anyway, I think he might slowly be realizing that his practices suck
09:52:13 <qFox> anyways, prolog before haskell was a wise choice i believe. i dont haskell for at least the layout rules. i dont like being forced like that, plus there are better ways to do such things. layout based syntax just sux imo
09:52:23 <lightstep> realization should always come from the inside
09:52:26 <shapr> qFox: you're not forced to use layout.
09:52:45 <shapr> lightstep: I'd say, it can only come from the inside. You know the quote "You can lead a horse to water, but you can't make him drink." ?
09:52:46 <sh10151> since he will have an issue, ask me about it, I will come over for 10 seconds and say "put 'my' in front of this variable initialization" and it will behave as he expects
09:53:02 <sh10151> he does a lot of assignment/initialization inside of if-statements
09:53:24 <sh10151> as a matter of fact I am not sure if he can coherently express the difference between assignment and initialization
09:53:28 <qFox> not forced? i'm not very familiar yet, but i'm quite sure you're required to indent at certain parameters (of guards for instance?) which you may not even tab.
09:53:38 <lightstep> shapr, people can be persuaded without thinking
09:53:40 <shapr> I think it's weird that people will choose one thing or another on the basis of speed, before writing any code. How can you tell without profiling?
09:53:56 <shapr> lightstep: Yeah, true. But that's not enlightenment.
09:54:18 <araujo> shapr!
09:54:21 --- topic: set to '["Learning Haskell - http://haskell.org/learning.html","See logs @ http://meme.b9.com/cdates.html?channel=haskell","related channels #haskell.se #haskelldb #darcs","Haskell eZine! http://haskell.org/hawiki/TheMonadReader","http://haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - ICFP contest 2004","We put the Funk in Funktion","The people here like donuts","one step on the road to enlighten' by shapr
09:54:27 <shapr> araujo!
09:54:30 <araujo> 8)
09:54:38 <shapr> Heffalump!
09:54:44 <Heffalump> shapr?
09:54:48 <qFox> well, its an ok language, but i'll stick to forth
09:54:52 <shapr> hi Heffalump! nice to see you!
09:55:08 <shapr> qFox: Have you reached monads?
09:55:12 <qFox> monads?
09:55:13 <Oejet> My group had an argument about weather C# or Java would be fastest for heavy vector calculations.
09:55:16 <qFox> (appearantly not...)
09:55:17 <shapr> qFox: what do you think of joy vs forth?
09:55:25 <qFox> i dont know joy
09:55:33 <Spark> Oejet: heh
09:55:37 <shapr> I'm a fan of concatenative languages.
09:55:49 <araujo> Oejet, neither
09:55:50 <shapr> Oejet: I think that deserves rolling of the eyes and pounding of the head.
09:56:13 <Spark> ive never actually seen any c# running
09:56:28 <shapr> qFox: do you like languages that run bare hardware? (trick question, Haskell does it too)
09:56:36 <araujo> Oejet, actually, i will go further with my sentence, and ask why those two languages have to exist at all?
09:56:58 <shapr> I think Microsoft did dotnet to escape Intel.
09:57:13 <shapr> I think Sun did Java to escape Microsoft.
09:57:17 <araujo> haha
09:57:23 <qFox> shapr> the only main objection against haskell is the enforced indentation (layout) thing. well, that and its somewhat unusual notation, but thats a matter of getting used to i guess
09:57:25 * Oejet doesn't want to get lynched by his group mates.
09:57:28 <araujo> looks like a GO game
09:57:37 <MachinShin> haskell has forced indentation. hrmph
09:57:44 <shapr> qFox: Layout isn't enforced. You can use {}; just fine.
09:57:45 <qFox> but to answer your question, no not especially
09:58:12 <qFox> you can? will it cry for me using tabs at certain points in the code?
09:58:30 <qFox> using layout as part of syntax is just a silly idea imo
09:58:31 <lightstep> it _is_ enforced. if you use {}; and are naive about indenting, you will run into trouble
09:58:32 <shapr> I dunno, I love significant whitespace, so I don't use {};
09:58:33 <qFox> i like freedom
09:58:46 <qFox> whitespace should be just that, whitespace.
09:58:53 <shapr> so, why indent?
09:58:56 <Heffalump> it would be nice to be able to compile files without the layout rule
09:59:00 <qFox> indent is like tabbing right
09:59:08 <tuomov> I don't care so much for layout in python; writing 'end' isn't so much work, but it suits the mathy style of haskell very well
09:59:26 <Philippa> qFox: tabs are really stupid in Haskell because of the significant whitespace
09:59:27 <shapr> I mean, why use anything more than a single space to separate anything from the next thing is whitespace isn't important?
09:59:29 <lightstep> Heffalump, you have tr '\n' ' '
09:59:34 <qFox> Philippa> exactly my point...
09:59:40 <Philippa> so use spaces
09:59:43 <Philippa> deal
09:59:48 <tuomov> tabs are evil
10:00:00 <qFox> shapr> outlining strings or ... whatever. i like to be free to choose as i please
10:00:06 <Heffalump> lightstep: true
10:00:23 <Oejet> araujo: In a group you have to go for the lowest denominator.  Choices were C++/Java/C#. :-(
10:00:47 <araujo> Oejet, get C++
10:00:49 * qFox sticks to forth nevertheless :p
10:01:00 <tuomov> use plain C
10:01:04 <shapr> You might like Joy, oh and try Self also.
10:01:20 <Philippa> the layout rule's simple enough that it's very, very rare to find a time it actually gets in the way of doing something that's readable
10:01:34 --- topic: set to '["Learning Haskell - http://haskell.org/learning.html","See logs @ http://meme.b9.com/cdates.html?channel=haskell","related channels #haskell.se #haskelldb #darcs","Haskell eZine! http://haskell.org/hawiki/TheMonadReader","http://haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - ICFP contest 2004","We put the Funk in Funktion","one step on the road to enlightenment"]' by shapr
10:01:42 * araujo realizes he is recommending C++ in #haskell
10:01:52 <Philippa> in preference to Java, mind
10:02:05 <Philippa> though I have to admit it's a close call if you don't have access to boost
10:02:07 <Oejet> araujo: You saw the alternatives. :-P
10:02:09 <desrt> there's something about haskell programmers that make them tend to tollerate C++ as a language
10:02:16 <desrt> i'm not sure what it is :)
10:02:21 <shapr> qFox: I like languages that change how I think about programming. Forth is one of those..
10:02:29 <shapr> desrt: count me out :-) no C++ for me.
10:02:38 <desrt> shapr; likewise :)
10:02:41 <qFox> rpn forces that yes, but i dont mind that, i actually like it :)
10:02:42 <araujo> desrt, mm.. was that an insult? 8)
10:02:43 <lightstep> you can easily compile haskell to c++
10:02:43 <Philippa> desrt: if you're willing to learn monads to do IO, you can just about see how C++ came about from the opposite direction
10:02:51 <lightstep> even in your head
10:03:01 <Philippa> erm, not all of it
10:03:01 <shapr> lightstep: my head segfaults :-(
10:03:13 <desrt> lightstep; i generally disagree with that statement
10:03:17 <Philippa> any time you really /need/ a GC to stay sane, the translation's a PITA
10:03:22 <desrt> because you -can- easily compile c++ to c
10:03:34 <shapr> Ah, there's my problem. My head needs GC to stay sane.
10:03:35 <desrt> and the size of ghc is a testiment to the fact that it's not easy to go from ghc to c :)
10:03:39 <Philippa> though there's a lot of useful stuff in C++ if you want to program in a single-assignment fashion
10:04:01 <lightstep> you can have GC in c++
10:04:19 <desrt> you can have it in C too, though
10:04:25 <tuomov> you can have it in assembly!
10:04:26 <MachinShin> boehm
10:04:32 <desrt> MachinShin; instead
10:04:53 <lightstep> it's integrated much better in c++ than in c
10:05:00 <Philippa> however, it's not foolproof
10:05:11 <sh10151> Philippa: there are the jakarta libs that give you some of boost
10:05:20 <Philippa> GCing in C++ is inherantly going to be conservative because of the sheer number of holes in the type system
10:05:55 <xerox> Are there wiki pages about Arrows?
10:06:22 <qFox> thats probably the main "downside" of forth... most forthers are stubborn like heck and think they can do it better. as a result there are a gazilion forth's and forthclones out there, and nobody tends to like the fig or ansi standards
10:07:11 <qFox> there are a few "commands" (words) that are almost globally accepted as standard, and even those get raped in a few implementations
10:07:42 <qFox> not that anyone cares.. sorry :)
10:08:00 <xerox> @wiki UnderstandingArrows
10:08:00 <lambdabot> http://www.haskell.org/hawiki/UnderstandingArrows
10:08:07 <desrt> "Massive stars live fast, die young and leave rapidly spinning corpses," said Andrew Fruchter with the Space Telescope Science Institute in Baltimore.
10:12:00 <shapr> goron: did you get my paste?
10:12:04 <goron> shapr: no
10:12:44 <shapr> goron: basically, /dev/input/mice and ImPS/2
10:13:10 <goron> shapr: The protocol shouldn't matter with a device file, right?
10:13:16 <goron> shapr: I just want to cat something.
10:13:35 <goron> shapr: I don't know what my real device file is.
10:13:56 <shapr> do you have /dev/input/* ?
10:14:02 <shapr> xerox: what do you want to know?
10:14:06 <shapr> xerox: do you already understand monads?
10:14:18 <goron> shapr: yes
10:14:30 <qFox> whats this monads thing you keep talking about? like the holy grail of haskell? ;0
10:14:31 <shapr> goron: have you tried /dev/input/mice ?
10:14:46 <goron> shapr: yes, but it does not do anything when I move my mice.
10:14:55 <goron> shapr: Or click/..?
10:15:04 <xerox> shapr, I think I understand (&&&) - I tried with monads, but they're more complex - so I think Arrow would be simpler to me, could it be possible?
10:15:04 <shapr> I've never tried that.
10:15:21 <shapr> xerox: umm... probably.
10:15:38 <goron> shapr: Can you do this command: cat /dev/input/mice and check whether you see data?
10:15:45 <xerox> In fact (&&&) impressed me, that's exactly what I need for a long time..
10:15:48 <shapr> well, I don't use usb anymore, so not right now.
10:16:06 <shapr> xerox: have you read Ross Paterson's Fun of Programming chapter about arrows?
10:16:11 <MachinShin> what's &&& ?
10:16:26 <xerox> MachinShin, (f &&& g) x = (f x, g x)
10:16:32 <funkmando> @type sum
10:16:35 <lambdabot> sum :: forall a. (Num a) => [a] -> a
10:16:36 <xerox> That's *so* nice to have.
10:16:51 <shapr> xerox: do you know >>> *** first and second?
10:17:09 <MachinShin> so it returns the retvals of applying the funciton f to x, and applying g to x.
10:17:29 <xerox> shapr, I was reading about, I didn't understand them as now
10:17:36 <xerox> MachinShin, exactly!
10:18:40 <MachinShin> interesting
10:19:29 <shapr> >>> is the same as (.) for functions.
10:19:42 <xerox> shapr, why "for functions" ?
10:20:08 <shapr> Because functions are a subset of arrows. In Haskell, they're one instance of the Arrow typeclass.
10:20:50 <xerox> Prelude Control.Arrow> ((+2) >>> (*4)) 2
10:20:50 <xerox> 16
10:20:50 <xerox> Prelude Control.Arrow> ((+2)  .  (*4)) 2
10:20:50 <xerox> 10
10:21:02 <shapr> !
10:21:13 <shapr> maybe it's the same as (flip .) ?
10:21:33 * shapr blinks
10:21:41 <xerox> -- | Left-to-right composition of arrows.
10:21:41 <xerox> (>>>) :: a b c -> a c d -> a b d
10:22:06 <xerox> Let me check the implementation, typing is not completely enough for me
10:23:07 <xerox> f >>> g = g . f  --clear
10:23:30 <Spark> heh
10:23:34 <Spark> is that fix?
10:23:40 <Spark> oh
10:23:44 <Spark> i just read g = g.f
10:24:05 <xerox> instance Arrow (->) where
10:24:05 <xerox> 	arr f = f
10:24:05 <xerox> 	f >>> g = g . f
10:24:05 <xerox> 	first f = f *** id
10:24:05 <xerox> 	second f = id *** f
10:24:05 <xerox> 	(***) f g ~(x,y) = (f x, g y)
10:26:04 <shapr> @type (arr (+2) >>> arr (*4))
10:26:07 <lambdabot> bzzt
10:27:00 <xerox> (arr (+2)) >>> (arr (*4)) :: forall a b. (Arrow a, Num b) => a b b
10:27:28 <shapr> So, what's the arrow instance to put into the type sig?
10:28:34 <shapr> I'd say the 'instance Arrow (->)' part, but I can't figure out how to specify it so that the arrow part stays in the sig.
10:28:53 <xerox> I can't understand what you're saying
10:29:49 * shapr fights the type system
10:30:15 <shapr> aha
10:30:56 <xerox> So what?
10:30:57 <shapr> @type (arr (+2) :: (Arrow a,Num b) => a b b) >>> (arr (*4))
10:30:59 <lambdabot> bzzt
10:31:01 * shapr blinks
10:31:08 <shapr> poo, I'm using 6.4
10:31:09 <MachinShin> the bot's farked?
10:31:18 <shapr> Nah, the bot is using 6.2
10:31:19 <xerox> I'm using 6.2 :(
10:32:08 <shapr> That was fun :-)
10:32:22 <xerox> In *your* head :)
10:32:25 <shapr> heh
10:33:18 <shapr> I can explain monads if you want an interactive tutorial. I don't think you can skip them and go to arrows, sadly.
10:33:29 <autrijus> haskell-eclipse support is wonderful.
10:33:32 <autrijus> I dropped vim today.
10:33:35 <shapr> I agree with you, arrows are a lot easier in my head too.
10:33:37 <xerox> shapr, I'd really love to.
10:34:05 <shapr> But right now, there's very little code that uses arrows, I think mostly because very few people understand them and their benefits.
10:34:21 <xerox> Btw "(arr (+2)) :: forall a b. (Arrow a, Num b) => a b b" here, why did you specify it by hand?
10:34:42 <MachinShin> hrmm..if i do ->  head [[1,3],5,6] it gives me an error, shoudlnt' it return me the the list [1,3] ?
10:34:58 <shapr> Because I was trying to get it into the @type command of lambdabot, and also because :: (Num b) => b -> b  is an equally valid type sig.
10:35:05 <xerox> MachinShin, lists are homogeneous
10:35:12 <MachinShin> que?
10:35:26 <shapr> head [[1,3],[5],[6]]
10:35:30 <xerox> MachinShin, you can have a list of numbers OR a list of lists
10:35:41 <MachinShin> oh.
10:36:42 <shapr> xerox: you want a short interactive monads tutorial? Once you get monads it's a short step into arrows.
10:37:00 <xerox> Yes! Thank you.
10:37:40 <shapr> Ok, if you have a list like [1+1,3+4] which one gets executed first?
10:38:09 <xerox> shapr, I can't know the order, right?
10:38:14 <shapr> correct answer!
10:38:21 * shapr gives a golden lambda to xerox 
10:38:32 * xerox smacks it
10:38:35 * shapr grins
10:38:46 <shapr> So, how could you make something with a given order in Haskell?
10:39:11 <xerox> I know you people use Monads, I ""know"" the do form.
10:39:32 <shapr> Right, but ... if you yourself wanted to make something happen in a particular order, how could you do it?
10:39:51 <tic> How do you do >1 statement in an if?  if exp then s1; s2; s3; then s4?
10:40:08 <xerox> shapr, using functions
10:40:20 <desrt> tic; you can put do inside an if
10:40:25 <tic> desrt, thanks.
10:40:40 <desrt> the layout is probably what you'd expect
10:40:53 <shapr> xerox: yeah, you could have one function do something and return a function that can do the next thing, right?
10:41:01 <xerox> shapr, exactly
10:41:07 <shapr> xerox: that's monads.
10:41:14 <xerox> shapr, too simple, I bet.
10:41:19 <shapr> No, that's really it.
10:41:27 <shapr> look at the type sigs.
10:41:31 <shapr> @type (>>=)
10:41:33 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
10:42:23 <xerox> I have some difficulties extrapolating the meaning of the function ONLY with the type signature
10:42:31 <shapr> xerox: the whole motivation behind monads was to figure out some way to force ordering in Haskell, which doesn't have ordering.
10:42:44 <xerox> I can understand it.
10:43:11 <shapr> So these monads are effectively (a -> ...) which becomes (a -> (a -> ...)) and then (a -> (a -> (a -> ...))
10:43:27 <shapr> One easy way into this is to look at the Parser monad, it's just a recursive descent parser.
10:44:04 <xerox> Hmm.
10:44:13 <xerox> I don't know much about parsing, in fact.
10:44:48 <shapr> This is why people often say that monads are only hard if you think they are... it's way simple, but it gets more complicated when you see how much it can do.
10:44:51 <gzl> heh I was doing stuff with Parser earlier
10:45:45 <xerox> shapr, maybe I need something pratical to understand.
10:45:49 <shapr> Yes, I agree.
10:46:11 <shapr> Open your hymnbook to http://www.nomaware.com/monads/html/
10:46:42 * gzl follows along.
10:46:51 <gzl> hey, nice.
10:47:13 <xerox> shapr, thanks shapr, I try.
10:47:17 * shapr tries to reformat his understanding into simple words.
10:48:11 <shapr> When the "m a" thingy expands, you get to define how it expands.
10:48:32 <gzl> maybe Maybe is a good example.
10:48:50 <gzl> one of the easier ones I think
10:48:54 <shapr> In OOP, your code combines with a given set of semantics. With monads, you define the set of semantics to use to combine.
10:49:14 <qFox> how do i pass one something like this:    str (32 (lengte - (length h)))
10:49:15 <qFox> str :: Int -> Int -> String
10:49:44 <Igloo> I don't suppose anyone knows a good site that describes things like Masek and Paterson's LCS algorithm?
10:49:47 <qFox> it now complaints that 32 is not a function, obviously its not, but if i remove the braces it will not evaluate subtraction first
10:49:54 <shapr> Let's take Maybe as an example.... first of all it's a parameterizable type. or as http://www.haskell.org/hawiki/MonadsAsContainers would say, it's a container. So the m part of "m a" can be Maybe
10:50:43 <gzl> qFox: so str 32 (lengte - (length h)) doesn't work?
10:50:52 <tic> In a language where variables come to life as they're assigned to, what's the best of way of typechecking an if...else statement, where you don't know which branch will be chosen?
10:51:09 <xerox> shapr, I'm with you
10:51:19 <qFox> hm
10:51:32 <qFox> it does.
10:51:33 <qFox> :)
10:51:53 <shapr> If you've ever written a big bunch of nested if-then-else, you've probably wondered if there was some way to factor out that pattern. The Maybe type represents failure or success and a result. The Maybe monad turns that into an active operation where you can combine chunks of code with failure checking. Basically a bunch of nested if-then-else chunks.
10:52:53 <shapr> xerox, gzl: ok so far?
10:54:35 <shapr> Igloo: any suggestions for cute and easy non-trivial demos of TH? I'm doing a tour, but I'd like to put in something more than "this is a splice, this is a ..."
10:54:50 <gzl> xerox: yes
10:54:52 <gzl> er...
10:54:53 <gzl> shapr: yes
10:54:56 * shapr grins
10:55:12 <gzl> I was just looking at that, actually
10:55:39 <gzl> that page you linked to looks like exactly what I was looking for, actually
10:55:51 <xerox> brb
10:55:53 <gzl> Hudak's explanation is good but I had wanted something more fleshed out
10:55:59 <xerox> Sorry away for a moment, I'll read.
10:56:25 <shapr> Yeah, it's the best monads tutorial yet. I emailed the author asking for a matching arrows tutorial, but he said he wouldn't be doing that. So I've been thinking about how to write one for arrows myself.
10:57:34 <shapr> gzl: so, do you have a vague grasp of monads now?
10:58:09 <gzl> well i had a vague grasp a week ago. i'm trying to move to a solid grasp :)
10:58:16 <gzl> this tutorial should help a lot though
10:58:17 <shapr> Getting closer?
10:58:29 <gzl> yes. I stumbled through some Parser code
10:58:33 <gzl> and managed to get it working
10:58:43 <gzl> but still not quite comfortable
10:58:46 <xerox> Back!
10:59:04 <xerox> Maybe monad resembling nested ifs? how?
10:59:24 <shapr> One I really got monads, I was amazed that such a simple pattern could do so much. I'm not sure I really get arrows, but I'm pretty close. I'm seeing the power and simplicity again.
10:59:49 <shapr> xerox: do you see how the Maybe type can represent either failure, or success that includes a result?
10:59:55 <xerox> When I saw the usage of &&& I felt the same. I really needed such a thing.
11:00:08 <shapr> data Maybe a = Just a | Nothing
11:00:14 <xerox> shapr, I can understand the concept, can you make an example?
11:00:43 <gzl> there's a good example in the Maybe sectionC[C[C[C of that tutorial
11:00:48 <gzl> * section
11:00:52 <xerox> gzl, which of them?
11:00:57 <gzl> the one shapr linked too
11:01:01 <gzl> wtf am I doing
11:01:03 <gzl> * to
11:01:12 <shapr> what the function?
11:01:25 <gzl> dictionary lookups
11:01:38 <shapr> Right, that's the best example.
11:01:43 <gzl> http://www.nomaware.com/monads/html/maybemonad.html#example
11:01:52 <basti_> 00f.
11:01:58 <shapr> guten abend basti_!
11:02:07 <basti_> shapr: !
11:02:08 <sh10151> abend?
11:02:09 <shapr> @type Data.FiniteMap.lookupFM
11:02:11 <lambdabot> Data.FiniteMap.lookupFM :: forall elt key.
11:02:11 <lambdabot> 			   (Ord key) =>
11:02:11 <lambdabot> 			   Data.FiniteMap.FiniteMap key elt -> key -> Maybe elt
11:02:15 <basti_> i'm so sorry that i couldnt write you shapr
11:02:19 <shapr> sh10151: ok ok, nacht
11:02:23 <shapr> basti_: no worries
11:02:33 <basti_> my gf's dad had a heart infarct.
11:02:37 <shapr> yikes!
11:02:45 <Heffalump> :-(
11:02:54 <basti_> we had to rush there immediately and i didnt have the opportunity to go online until now...
11:02:55 <shapr> Is he ok?
11:02:59 <sh10151> abend (n):  (1) Abnormal end of task. (2) Synonym for abnormal termination.
11:03:00 <basti_> not at all :(
11:03:03 <Heffalump> (the English term for that is generally 'heart attack' btw)
11:03:11 <basti_> hmm ok
11:03:12 <shapr> sh10151: spreuchen Sie deutsche?
11:03:19 <shapr> basti_: :-(
11:03:21 <sh10151> No :)
11:03:28 <basti_> he isnt dead.
11:03:32 <xerox> basti_, :\
11:03:42 <shapr> I hope he recovers.
11:03:48 <basti_> everyone does
11:04:34 <basti_> he has a brain edema now. monday evening they will do another ct. If it doesnt go back or gets worse, he will be dead soon :(
11:04:51 <shapr> :-(
11:05:18 <basti_> ICU's are not healthy for the visitors, btw.
11:05:25 <shapr> ?
11:05:49 <basti_> well the psychical condition of his family is worsening too.
11:06:05 <basti_> I mean, of course it is. But would it have been worse if he had died immediately? I don't suppose.
11:06:29 <shapr> Oh. ICUs are stressful, I agree. I spent quite a bit of time in one a year ago.
11:06:47 <basti_> as a patient?
11:06:52 <shapr> no, thankfully.
11:06:58 <basti_> ic.
11:07:09 <shapr> It's rough.
11:07:12 <basti_> yes it is.
11:07:48 <shapr> Well, Don't worry about your TMR article. (obviously)
11:08:10 <basti_> next issue?
11:08:21 <shapr> Sure, if you want.
11:08:38 <basti_> i still want to do it but i dont think i can complete it in time.
11:08:47 <basti_> i will have to do the move by myself now.
11:09:22 <shapr> Well, I'd show up to help you if I were somewhere nearby.
11:09:51 <basti_> I have people to help. But my gf is with her half-dead father, and i'm here and have to do the move.
11:10:16 <Heffalump> was it all sudden or was he in poor health already?
11:10:31 <basti_> well how healthy is smoking a pack a day for 30 years? :P
11:10:41 <Heffalump> heh
11:10:54 <Heffalump> some people seem to get away with that without obvious ill effects
11:10:56 <basti_> but did not have any history.
11:11:04 <basti_> plus he had a check up.
11:11:26 <basti_> but they can't see nearly clogged up heart vessels with these checks.
11:17:43 <xerox> shapr, the sheep example is kinda clear, nice one.
11:17:48 <basti_> sheep example?
11:17:59 <xerox> basti_, this one: http://www.nomaware.com/monads/html/meet.html#example1
11:18:51 <Gahhh> baaa
11:19:06 <basti_> hmm yes :)
11:25:28 <qFox> i dont suppose its possible to make a last minute change to the return of a recursive function, a change thats not recursed?
11:25:41 <basti_> ?
11:25:43 <qFox> like suffix a return to a string built with recursion
11:26:48 <lightstep> qFox, it the function tail-recursive?
11:27:01 <lightstep> if so, it's possible without extra work
11:27:05 <qFox> no, left recursion
11:27:14 <qFox> (head ...)
11:27:58 <qFox> but for tail recursion the same would happen right, i mean the return would get suffixed as many times as the function recursed
11:28:13 <qFox> while i only want it once
11:28:28 <lightstep> it really should be clear from the types
11:28:36 <qFox> the simple alternative would be to create an additional function that suffixes it, but its just ugly etc
11:28:48 <lightstep> values entering and exiting the monad
11:29:24 <qFox> nevermind... it was worth a shot :)
11:31:57 <shapr> Darius: heyy!
11:32:16 <lightstep> what interesting error types are there, except functions, monads, fudgets and predictive parsers?
11:32:31 <lightstep> *arrow
11:32:34 <MachinShin> rotfl.. "if yu're thinking about cheating w/ someone at work, go into the bathroom and masturbate too take the edge off " -> http://www.ediets.com/news/article.cfm/cmi_867211/cid_4
11:33:23 <shapr> lightstep: There's also Automato, NonDeterministic, and some others. Check out Ross Paterson's FoP chapter for some good examples.
11:34:05 <shapr> lightstep: but the question is equivalent to asking what Object can be used for...  objects/monads/arrows are all abstractions of a vaguely similar sort.
11:35:07 <shapr> greetings Picola
11:36:08 <shapr> Automato is of course fruit that picks itself =)
11:36:35 <qFox> hm, funny how "" can cause a linebreak... not.
11:36:53 <qFox> no matter, i replaced it with [] now
11:38:00 <shapr> Darius: hello!
11:38:30 <Oejet> @eval ""==[]
11:38:31 <lambdabot> True
11:41:03 <lightstep> Oejet, that doesn't mean anything. It parses to ""=="".
11:43:20 <shapr> I think that was the point.
11:43:24 <Spark> @eval L==[L]
11:43:24 <lambdabot> unbound variable: L
11:43:31 <Spark> oops
11:43:52 <Spark> i had a good night out last night
11:43:59 <Spark> still havent recovered
11:46:41 <Heffalump> @evel \l -> l==[l]
11:46:42 <lambdabot> Sorry, I don't know the command "evel", try "lambdabot: @listcommands"
11:46:44 <Heffalump> @eval \l -> l==[l]
11:46:45 <lambdabot> <<EM Dynamic -> EM Dynamic>>
11:46:50 <Heffalump> booring
11:46:54 <Heffalump> @eval (\l -> l==[l]) 5
11:46:55 <lambdabot> type error
11:50:46 <kosmikus> @seen duncan
11:50:47 <lambdabot> I haven't seen duncan
11:54:37 <Oejet> Once I read a paper, by Wadler I think, which described an intepreter which was extended two times using monads.
11:54:53 <Lemmih> 126 people in #haskell. We're getting popular!
11:55:19 <Oejet> I found one, but it's not quite it.  Maybe it's the sequal to "Monads for functional programming" by Wadler.
11:55:26 <Oejet> Ring any bells?
11:55:31 <Heffalump> it's annoying when I want to do /names to see if someone is on the channel :-)
11:55:47 <Heffalump> oejet: you sure you don't mean Modular Interpreters and monad Transformers, or similar?
11:55:52 <Heffalump> (which isn't by Wadler)
11:56:07 <Oejet> Maybe.  Let me find it...
11:56:28 <Lor> Modular monadic semantics?
11:56:51 <Heffalump> yes, or that
11:58:08 <Oejet> Heffalump: Nope, but in the same ball park.
11:59:19 <Oejet> It was much simpler.
12:09:44 <Darius> Heffalump: just /whois the person
12:09:46 <Darius> shapr: Heya
12:09:58 * Darius was reading a paper on generative programming.
12:10:30 <Heffalump> darius: that depends on me knowing what their exact current nick will be
12:11:43 <shapr> Darius: found any cool papers with new ideas lately?
12:14:08 <Darius> shapr: I've been reading a lot of papers on behaviorial reflection of late, but many of them aren't particularly new.
12:14:42 <shapr> nifty!
12:15:19 <shapr> Possible in Haskell?
12:15:43 <Heffalump> what is behavioural reflection?
12:16:09 <Darius> Heffalump: Being able to "change the interpreter from within the intepreter"
12:16:10 <shapr> I was idly thinking about some way to combine TH and profiling to make a cheesy JIt.
12:16:52 <xerox> back
12:16:53 <Darius> Also, an online ASIC book that I ran across before was finished and made available.
12:17:01 <shapr> url?
12:18:48 <Darius> Google for "Designing Analog Chips"
12:19:19 <xerox> shapr, so the interactive Monad tutorial is to be considered finishe?
12:19:20 <xerox> *d
12:19:37 <shapr> xerox: unless you want more lessons
12:20:02 <xerox> If you have some time I'd be pleased to.
12:20:31 <shapr> Do you have any particular questions?
12:21:13 <xerox> Can we go on something different from the Maybe Monad?
12:22:02 <shapr> Do you understand how the Maybe type models failure or success plus result?
12:22:21 <xerox> I think so.
12:22:39 <shapr> Can you explain it?
12:23:17 * Darius still needs to make a free (co)monad wiki page.
12:24:00 <shapr> yes please :-)
12:24:14 <shapr> Want to write a CoMonad article for The Monad.Reader?
12:24:45 <desrt> Darius; "careful with that, it's unsafe"
12:24:48 <Darius> The problem is I've gotten more ambitious and want to make most of the (Co)Monads by transforming free ones.
12:26:06 <xerox> Maybe a is a parametrized type, with two Constructors: Nothing represents the failure, Just a the success -- You can do case switching upon return values, but it gets annoying. So a combinator will take care of doing things in the right order and propagate the possible errors: this way you can check the result of the computation with only 1 case switching.
12:26:23 <shapr> xerox: yup, you got it.
12:26:36 <Oejet> Yay! Found it: The essence of functional programming by Wadler.
12:26:52 <shapr> xerox: So, how you do upgrade that to return an error message instead of Nothing ?
12:26:55 <Heffalump> that's just about monads, isn't it?
12:27:12 <Darius> Heffalump: Yes
12:27:26 <xerox> shapr, Parametrizing Nothing, maybe changing it to "Error" or something like it?
12:27:54 <Darius> An enjoyable paper though, "implementing backwards state is left as an exercise to the masochistic reader"
12:28:11 <shapr> xerox: Is there already a type that gives back one of two possible results?
12:28:20 <vincenz> hi
12:28:29 <vincenz> I installed ghc
12:28:36 <xerox> shapr, Either! By using Left and Right
12:28:50 <shapr> xerox: can you guess what type is used in the Error monad?
12:30:06 <shapr> xerox: ok, that wasn't very hard...
12:30:25 <xerox> I mean, probably Either
12:30:35 <xerox> But I was trying to find what was the real question :D
12:30:39 <shapr> You're right, the error monad uses Either.
12:30:56 <shapr> http://www.nomaware.com/monads/html/errormonad.html
12:31:09 <xerox> Like, "What are the types of the instances of return and bind for the Error Monad"
12:33:53 <shapr> I think you should read the nomaware tutorial and come back with questions.
12:34:04 <Darius> Okay.  What are the types of the instances of return and bind for the Error Monad?
12:34:14 <xerox> shapr, I'll do.
12:34:22 <shapr> My bedtime is nearly here.
12:34:39 <xerox> Darius, I think it isn't a good question either, they should have the same ype of other Monads', right?
12:35:05 <xerox> shapr, Thank you :)
12:35:50 <Darius> xerox: It should be an instance yes, though there is a minor subtlety
12:36:50 <xerox> Darius, is it about the type of the parameter?
12:37:47 <Darius> Mainly. The head of the instance declaration is where it is a bit more of an issue.
12:38:22 <xerox> Darius, can you elaborate on that?
12:39:16 <Darius> xerox: It's simply that Either doesn't form a monad, but rather (Either t) for some type t.
12:39:47 <Darius> Of course calling Either something like a "parameterized monad" would be sensible.
12:40:00 <lightstep> so substitute (Either t) for m in bind :: m a -> (a -> m b) -> m b
12:40:33 <xerox> (Either t) a --something to think about
12:40:41 <lightstep> it's curried
12:42:00 <xerox> What would be a reasonable value type for t ?
12:42:28 <lightstep> did you read the relevant page in AAM?
12:43:19 <lightstep> s/curried/schoenfinkeled/
12:44:02 <xerox> Can you remind me which of `type' and `newtype' is type aliasing?
12:44:33 <lightstep> type
12:44:55 <xerox> Is the other about isomorphism?
12:46:15 <Heffalump> yes
12:46:21 <Heffalump> well, sort of
12:46:37 <Heffalump> it creates an isomorphic type that can have different type class instances
12:47:24 <Darius> xerox: Any type is a reasonable value for t that's (part of) why it makes sense to talk about Either as a parameterized monad.
12:48:35 <Darius> (The other part is that mapLeft f = either (Left . f) Right is a monad homomorphism.
12:48:38 <xerox> Heffalump, how is the new type isomorphic to the first one? If it's not too long to explain.
12:49:24 <lightstep> xerox, the syntax for newtype is like for data, with one constructor of one parameter
12:49:47 <lightstep> like newtype A x = A (T x)
12:49:56 <lightstep> so A is equivelent to T
12:49:59 <Darius> xerox: Given newtype NT = NT T there are two functions NT and unNT (NT t) = t such that NT . unNT = id and unNT . NT = id.
12:50:59 <xerox> Thanks again.
12:56:35 <gzl> haha
12:56:39 <gzl> schoenfinkeled
12:56:50 <lightstep> he did it first
12:56:54 <gzl> i know
13:21:59 <xerox> Okay, enough for today, 'night folks.
13:23:27 <gzl> is the categorical definition of monads worth looking into?
13:23:44 <_Codex> gzl: yes.
13:24:31 <gzl> helps you understand what's going on, or some other reason?
13:24:50 <_Codex> helps with category theory, yes.
13:26:39 <gzl> you mean pure category theory, or the categorical perspective on haskell?
13:26:42 <Heffalump> I don't think it's at all helpful.
13:26:59 <Heffalump> unless you care about deep theory
13:27:09 <Heffalump> (which you might)
13:27:26 <gzl> i don't have much interest in pure category theory, but if it gives a useful perspective on some things, i'm happy to learn it
13:28:45 <gzl> going to learn some anyway for algebra, so if has something interesting to say for haskell, ...
13:33:25 * boegel yawns
13:34:19 <_Codex> gzl: it's going to tell you why id and . and fmap are so useful...
13:34:33 <gzl> ok.
13:34:41 <gzl> any recommended references?
13:35:48 <Philippa> Heffalump: I found it worthwhile having been able to grok it, but that's more for the sake of confirming my own intuitions
13:35:49 <boegel> can anybody wake up shapr ? :)
13:36:17 * Philippa whispers something about a pair of bricks into shapr's ears
13:36:21 <Philippa> that might wake him up
13:36:28 <_Codex> if you already know some, then "sets for mathematics" is a good book. Otherwise maybe "categorical primer".
13:36:39 <boegel> Philippa: bricks _into_ his ears ? :)
13:37:17 <basti_> hi Philippa btw.
13:37:29 <gzl> _Codex: the former by Lawvere?
13:38:02 <_Codex> gzl: yes.
13:38:02 <ski> gzl : think so, iirc
13:38:07 <gzl> ok.
13:38:51 <boegel> hey Oeje1 !
13:39:27 <Oeje1> Hej, boegel.
13:39:44 <Philippa> boegel: er, not quite his /ears/...
13:39:54 <Philippa> closer to an anagram of ears, in fact
13:41:57 <boegel> oh, like that
13:41:58 <boegel> brrr :s
13:43:13 <lightstep> "arrows and computation" says that a stream map is an Arrow. but how can first be defined? the type should be ST a b -> ST (a, d) (b, d), which is (Stream a -> Stream b) -> Stream (a, d) -> Stream (b, d). but then you can't distribute the d's correctly. what is the definition? is the first d duplicated? are they just copied first->first, second->second? some other mapping?
13:44:43 <_Codex> lightstep: huh?
13:45:32 <lightstep> i can't figure out an "interesting" function with that type
13:47:05 <lightstep> so i don't know what the natural instance declaration is
13:47:53 <ski> lightstep : is that stream as in always-infinite-lazy-list ?
13:48:03 <boegel> where's shapr when you need him :p
13:48:09 <lightstep> yes
13:48:52 <lightstep> the paper also says that /\ a b -> [a] -> [b] isn't an Arrow
13:50:35 <Heffalump> odd, I'd have thought it was one
13:50:55 <Heffalump> you can do the tuple distribution thing by using map fst, map snd and zip, surely?
13:51:00 <lightstep> yeah. both of them are put as exercises
13:51:07 <gzl> hmm, neat
13:51:19 <lightstep> you can, but you can do it lots of other ways too
13:51:23 <gzl> record types
13:52:18 <lightstep> as many as the functions of type forall a. Stream a -> Stream a
13:52:44 <_Codex> lightstep: the d in the first doesnt really do anything.
13:54:22 <lightstep> yeah, i know. but you only get a stream of b's and a stream of d's, and you need to combine them. it isn't obvious how to do it, and why the solution isn't applicable to lists.
13:55:53 <_Codex> lightstep: for lists, first's type would be: first :: [a]->[b] -> [(a,d)] -> [(b,d)]
13:56:31 <Heffalump> what's wrong with zip?
13:56:34 <lightstep> the paper says that this is "almost an arrow type", and asks "what goes wrong?"
13:56:44 <Heffalump> ah, ok, some law is probably violated then
13:57:12 <lightstep> oh, you lose some state if the lists aren't of the same length
13:57:45 <lightstep> but how did you choose to zip the lists?
13:57:53 <Heffalump> I was assuming infinite lists
13:58:54 <lightstep> Heffalump, the paper is more rigorious than me in that respect
14:03:50 <boegel> I'm off to bed
14:03:54 <boegel> tell shapr I said hi :p
14:05:08 <Oeje1> Good night boegel.
14:05:43 <boegel> bye !
14:10:14 <qFox> hm
14:10:15 <qFox> getColumn column ((column:h):tafel) = column
14:10:23 <qFox> he's not able to patern match like this?
14:10:28 <qFox> getColumn :: String -> Table -> [String]
14:10:41 <qFox> Table is [[String]] btw
14:11:14 <arjanb> you can't use the same name twice in the patterns
14:11:19 <qFox> appearantly
14:11:21 <gzl> yeah you've used column twice
14:11:26 <robert> qFox, Sonarman... Are you leaving the Forth sect for Haskell?
14:11:34 <qFox> i know but i was hoping it would be as smart enough to figure it out himself ;)
14:11:34 <gzl> which makes no sense
14:11:39 <robert> You know the Leader can't allow that.
14:11:41 <qFox> robert> i'm learning it under force ;)
14:11:50 <gzl> how could it figure that out?
14:11:50 <MachinShin> nanananannana. Leader... ananananananan. Leader
14:11:51 <robert> I will, too, next year.
14:12:01 <robert> MachinShin: Hehe, nice episode I admit.
14:12:27 <MachinShin> ;)
14:12:28 <qFox> gzl> it does. that would only be allowed if the given column is the same as the first string of the first list of table
14:12:30 <robert> I wish I could use Haskell instead of Java for some of my homework.
14:12:43 <qFox> pfff hell no
14:12:44 <qFox> :(
14:13:01 <qFox> oh, uhm
14:13:03 <robert> You prefer Java to Haskell, qFox?
14:13:06 <qFox> "no"
14:13:07 <qFox> :p
14:13:10 <gzl> ...that seems like a really strange way of writing it
14:13:10 <qFox> yeah.
14:13:11 <gzl> but whatever
14:13:23 <qFox> gzl> i guess its what left after learning prolog
14:13:25 <qFox> :)
14:13:33 <gzl> apparently
14:13:44 <qFox> but making a guard is just as easy
14:16:19 <qFox> ok, or not
14:16:31 <qFox> can you do a double head tail like i'm trying?
14:16:36 <qFox> getColumn column ((dinges:_):tafel)
14:16:47 <qFox> can i acces dinges? or is this not allowed...
14:17:01 <qFox> robert> join us, resistence is futile.
14:17:02 <MachinShin> what is _|_ ?  /me reading tutorial
14:17:16 <ski> the undefined value
14:17:23 <__mattam__> bottom, the undefined value
14:17:26 <ski> also called "bottom"
14:17:30 <__mattam__> :)
14:17:39 <qFox> "i wonder why..."
14:17:56 <ski> is is supposed to look a bit like an up-side-down "T"
14:18:10 <ski> s/is is/it is/
14:18:18 <__mattam__> which is called Top...
14:18:23 <qFox> oh yeah, that was a clear correction right there ;)
14:18:51 <MachinShin> so . it's not a type, it's a value? /me trying to figure an analogue in languages he knows.
14:19:03 <ski> sortof a value
14:19:17 <ski> or rather, one such value for every type
14:19:30 <__mattam__> sortof a value which has no value :)
14:19:39 <ski> (except maybe the unboxed ones ..)
14:19:59 <MachinShin> similar to NULL in c?
14:20:03 <ski> no
14:20:15 <__mattam__> you can't test if a value is equal to bottom
14:20:31 <ski> when some expression fails to terminate (while evaluating it) we say that it has value "bottom"
14:20:33 <__mattam__> in fact you can't do anything with it except returning it
14:20:47 <ski> you can ignore it, too
14:20:48 <__mattam__> it's similar to assert(false) in spirit
14:21:10 <lightstep> it's also a type
14:21:10 <ski> (\_ -> 5) (let bot = bot in bot)  === 5
14:21:44 <ski> lightstep : you're thinking of the empty type, yes ?
14:22:03 <lightstep> no, about the type whose only element is _|_
14:22:15 <ski> yep, the "empty" type
14:22:22 <MachinShin> __mattam__: spirit?
14:22:30 <ski> (would be empty if it hadn't bottom as element)
14:22:54 <MachinShin> so .. _|_ is a type whose only allowable value is _|_ ?
14:23:14 * ski would not conflate the type with the value
14:23:15 <lightstep> there is not syntax for it in haskell
14:23:30 <araujo> MachinShin, think about bottom as the infinite in mathematics
14:23:36 <__mattam__> in C you write assert(false) in branches you're confident you won't take. In haskell you use it when there is no meaningful value. eg div x 0 = _|_
14:23:43 <ski> i think they are different things, just sometimes called the same thing  (though there are connections, yes)
14:23:55 <Lor> The empty type can be defined e.g. by newtype Void = Void Void
14:24:51 <ski> lightstep : for what ?  the totally-empty-type ?  the empty-except-for-the-bottom-value-type ?
14:25:16 <lightstep> for "the type that is the intersection of all haskell types"
14:25:36 <ski> (ok, the latter, then)
14:26:10 <lightstep> actually, that'd be forall a. a, so it is definable in haskell
14:26:23 <lightstep> with the proper extensions
14:26:31 <ski> ;)
14:27:17 * MachinShin got lost some time back :) 
14:29:16 <lightstep> MachinShin, it's not entirely relevant for haskell programming
14:29:52 <ski> more for reasoning more or less formally about (e.g. haskell) programming
14:32:03 <lightstep> the types in haskell are not disjoint. rather, there is a common element, which is named _|_. naturally, it is always a thunk, and cannot be evaluated. one way to create those is using the error function. error :: forall a. String ->a
14:34:08 <ski> all kinds of "not returning (to place expecting value, or at all)" can be modelled by bottom
14:35:11 <ski> such as nontermination "let bot = bot in bot", partiality/(non-IO-)exceptions "div 1 0"
14:35:42 <ski> (more or less)
14:41:25 <qFox> hum, haskell (or at least helium) reads source from disc before executing?
14:52:12 <CrewdenX> With ghc's Network.Socket  MkSocket, what is the CInt paramater?
14:54:56 <Lemmih> CrewdenX: It's the file descriptor.
14:56:57 <ski> qFox : why do you ask ?
15:03:49 <jlouis> FFI question. If one has an Int, but needs a CInt, what does one do? They are both a member of the Num class.
15:05:33 <jlouis> http://haskell.org/pipermail/ffi/2004-September.txt hints I should use fromIntegral to convert between them
15:05:33 <Lemmih> jlouis: fromIntegral
15:06:09 <Lemmih> :t fromIntegral :: Foreign.C.Types.CInt -> Int
15:06:20 <Lemmih> @type fromIntegral :: Foreign.C.Types.CInt -> Int
15:06:22 <lambdabot> fromIntegral :: Foreign.C.Types.CInt -> Int :: Foreign.C.Types.CInt
15:06:22 <lambdabot> 					       -> Int
15:06:37 <jlouis> May I ask. What is an ``Integral''
15:06:49 <Lemmih> @info Integral
15:06:51 <lambdabot> -- Integral is a class
15:06:51 <lambdabot> class (Real a, Enum a) => Integral a where {
15:06:51 <lambdabot>     rem :: a -> a -> a {- has default method -};
15:06:51 <lambdabot>     div :: a -> a -> a {- has default method -};
15:06:51 <lambdabot>     mod :: a -> a -> a {- has default method -};
15:06:51 <lambdabot>     quot :: a -> a -> a {- has default method -};
15:06:53 <lambdabot>     divMod :: a -> a -> (a, a) {- has default method -};
15:06:55 <lambdabot>     quotRem :: a -> a -> (a, a);
15:06:58 <lambdabot>     toInteger :: a -> Integer;
15:07:14 <Lemmih> Integral is a class. (:
15:08:43 <jlouis> I need to look closer at that class it seems ;)
15:17:13 <jlouis> so, mod and rem are synonyms?
15:17:23 <Pseudonym> No.
15:17:33 <Pseudonym> Try 5 `mod` (-2) and 5 `rem` (-2)
15:17:40 <jlouis> of course
15:24:47 <jlouis> so, if I am not much mistaken, quotRem is the mathematical definition based on i = qd + r, and divMod is what the computer returns?
15:26:24 <Pseudonym> More or less.
15:26:35 <Pseudonym> It is legal for divMod to be identical to quotRem.
15:26:44 <Pseudonym> If the computer returns the mathematically "right" answer.
15:27:15 <Pseudonym> The Haskell spec doesn't specify, so long as mod obeys the same rule as ANSI C '%'.
15:27:36 <Heffalump> doesn't ANSI C leave a lot of %s behaviour unspecified?
15:27:42 <Pseudonym> Yes.
15:28:04 <Heffalump> or rather, implementation defined
15:28:22 <basti_> c's % is plainly broken.
15:29:20 <Pseudonym> No, it does exactly what it advertises.
15:29:30 <basti_> but thats the wrong thing.
15:29:31 <basti_> imo
15:29:31 <basti_> ;)
15:45:13 <jlouis> It seems that if a newtype has only one constructor, you can refer to the values without referring to the constructor
15:45:18 <jlouis> Am I right?
15:45:42 <desrt> newtype may only have one constructor, iirc
15:45:52 <jlouis> yes
15:46:13 <jlouis> newtype Foo = MkFoo Int
15:46:20 <jlouis> now is:
15:46:23 <desrt> yes.  one constructor with one argument
15:46:27 <jlouis> add :: Foo -> Int -> Int
15:46:33 <jlouis> bleh
15:46:46 <jlouis> I'll check this
15:46:51 <desrt> :)
15:47:04 <desrt> sorry for not really knowing very much about newtype :)
15:50:02 <jlouis> nah, it is not allowed.
15:50:07 <jlouis> add5 :: Foo -> Int
15:50:10 <jlouis> add5 x = x + 5
15:50:13 <jlouis> is a type error
15:50:23 <jlouis> The trick I've seen is to define Foo as
15:50:32 <jlouis> newtype Foo = MkFoo {foo :: Int}
15:50:39 <jlouis> so
15:50:43 <jlouis> ad5 x = foo x + 5
15:50:44 <jlouis> works
15:50:46 <Lemmih> Why not just 'type Foo = Int'?
15:50:50 <jlouis> pretty neat
15:51:12 <jlouis> Lemmih: because I want them to be different type-inference wise
15:51:22 <jlouis> in the particular thing I am writing
15:51:38 <dons> moin
15:52:18 <jlouis> heya dons
15:52:52 <dons> hey jlouis
15:53:07 <dons> tried out ghc-6.2.2 in -currrent, or darcs, yet?
15:53:39 <jlouis> dons: both, works perfectly. Thanks
15:53:50 <dons> cool. good to know.
15:53:57 <jlouis> i386
15:54:41 <dons> yeah, I added amd64 a couple of days ago
15:55:35 <dons> let me know if there is other haskell software you think should be ported
15:57:27 <dons> you tried ghci?
15:57:43 <dons> that was such a pain.
15:58:13 <dons> then I realised W^X was messing with things
15:59:10 <wilx> wax?
15:59:11 <wilx> :)
15:59:57 <dons> Write xor eXecute
16:01:14 <wilx> Oh :)
16:02:07 <desrt> how long is a nightly build supposed to take?
16:02:24 * desrt looks at gabriel which has been working for the past 6 hours
16:03:04 <dons> yeah. 6-7 hours, depending on flags
16:03:11 <desrt> wow :)
16:03:40 <dons> the testsuite is usually twice as long as the normal build, and then you run a bunch of nofib tests for another hour or more
16:03:52 <desrt> **** running tests                ...
16:04:20 <dons> ok. so it only takes 4.15hrs on my 2.4ghz box
16:04:37 <dons> no, sorry. way more than that. 10 hrs
16:05:13 <dons> began "Sun Feb 20 22:00" finished successfully at Mon Feb 21 08:20
16:16:01 <jlouis> dons: of course W^X messes around
16:16:04 <jlouis> ghci is nice
16:16:25 <jlouis> You wont go after 6.4 before around 6.4.1, right?
16:17:06 <jlouis> or rather, put it into the ports tree before
16:17:35 <jlouis> I'll probably be messing around with it before that, heh
16:18:30 <dons> I'm now thinking of having them simultaneously, along the lines of the python port
16:20:10 <desrt> dons; did you make progress on the -j support for the scripts?
16:20:38 <dons> sure, I just added -j2 to all the obvious places in the nightly build, and then it broke :}
16:20:50 <desrt> heh
16:20:51 <dons> so I will try again, but be a bit more cautious ..
16:21:04 <desrt> i really don't understand why the nightly build scripts are like they are
16:21:33 <desrt> for building they should just checkout, ./configure, touch happy/src/Parser.hs; make -j5
16:22:02 <desrt> instead of trying to do all this manual stuff
16:22:09 <dons> yeah, I know. But it is useful to be able to pass all sorts of options to all sorts of phases, and to be able to turn off certain phases.
16:22:22 <desrt> (pst; what is stage3?)
16:22:25 <wilx> Hmm, is there any C/C++/<insert your favourite imperative language> application that uses Haskell as language for its extensions/plugins?
16:22:41 <dons> stage3= using stage2 to build a compiler == a good test of stage2
16:22:54 <desrt> that makes a reasonable amount of sense
16:23:17 <desrt> and basically any errors in stage2 would be in the RTS....
16:23:17 <dons> wilx: not that i know of, other than some toy apps in hs-plugins. have you read the plugins paper?
16:23:28 <wilx> Nope, will do.
16:23:39 <desrt> (since you already verified that the compiler was able to cook its stage2 self)
16:24:18 <dons> but the stage1 compiler was built with a possibly fault code gen, right. so stage2 could be flawed, right?
16:24:27 <desrt> right
16:25:01 <dons> wilx: http://www.cse.unsw.edu.au/~dons/hs-plugins/paper/
16:25:03 <desrt> so stage3 actually would be catching errors in the stage 1 compiler :)
16:25:31 <desrt> i think i'm just gonna make my own build scripts :)
16:25:48 <dons> argh, no! not another fork. that's what sseefried did too.
16:25:49 <desrt> and plug them into the existing system for logging/mailing/etc
16:25:57 <desrt> o.
16:26:11 <dons> what's wrong -- they're complex, but good
16:26:26 <desrt> because i already had to modify them to make them work at all :P
16:26:38 <desrt> they don't like running on systems that lack happy/alex
16:28:15 <dons> desrt: yes they do. you co alex and happy in the cvs dir, and they build that.
16:28:30 <desrt> it wasn't working for me
16:28:40 <desrt> it kept trying to build ghc before happy/alex which of course didn't work
16:28:46 <Lemmih> wilx: I wrote a plugin for Apache which loads Haskell modules at runtime.
16:28:48 <desrt> so i had to move things around and put happy/alex first
16:29:15 <wilx> Lemmih, do you have a link for sources that I could see?
16:29:28 <dons> Lemmih, yeah. sorry, forgot about that.
16:29:40 <dons> desrt: let me find the flag you need...
16:30:14 <dons> do_haddock="YES"
16:30:14 <dons> do_happy="YES"
16:30:15 <dons> do_alex="YES"
16:30:20 <desrt> yes.  ihave those
16:30:22 <desrt> mine the haddock one
16:30:24 <desrt> *minus
16:30:27 <Lemmih> wilx: http://www.scannedinavian.org/repos/modhaskell/
16:30:55 <jlouis> dons: good idea. I would love helping out where I can
16:31:05 <wilx> thanks.
16:31:06 <Heffalump> does that repo mean people are working on it?
16:31:23 <dons> wilx: I guess it isn't surprising that people who like Haskell tend not to write their apps in C.
16:31:25 <MachinShin> hey guys, what is "literate haskell" ?
16:31:38 <wilx> Hehe, it indeed is not :)
16:31:39 <dons> so most apps that have haskell extensions, tend to be in Haskell too
16:31:56 <desrt> anyway... you make a point
16:32:04 <desrt> it's actually working now so i may as well just leave well enough alone
16:32:54 <dons> MachinShin: it's Haskell with "literate" comments
16:34:38 <dons> also, C support for Haskell plugins could be improved. It isn't very polished (though the FFI does most of the work).
16:36:31 <MachinShin> dons: yah. that doesn't explain enough.
16:36:51 <jlouis> MachinShin: it is a normal text document, where there are escapes to haskell code.
16:37:02 <MachinShin> ah
16:37:14 <jlouis> MachinShin: normally, the > character in the beginning of the line enables haskell for that block
16:37:19 <MachinShin> similiar to how you'd write jsp or php or something?
16:37:30 <MachinShin> w/ text instead of html
16:38:33 <jlouis> MachinShin: yes, but the ``unlit'' tool _strips_ the text instead of inlining the output like php or jsp does
16:39:57 <dons> wilx: in the paper is a nice example of a ObjectC gui app, that loads Haskell plugins for various parser, using a wrapper to do the loading on the Haskell side. That model is probably the easiest to follow.
16:40:07 <dons> I'm not sure how Lemmih did modhaskell though
16:40:24 <dons> Lemmih? how is the binding to Haskell done?
16:41:08 <MachinShin> jlouis: gotcha
16:44:02 <Lemmih> dons: mod_haskell.c calls haskellHandler which is defined in HaskellMod.hs
16:44:26 <dons> and HaskellMod.hs does the actual loading?
16:45:44 <Lemmih> dons: HaskellMod.hs calls requestPlugin which is defined in Register.hs
16:47:16 <dons> ok. cool. so it follows the same model. we do as much as possible on the Haskell side
16:50:31 <Heffalump> bah, I intended to spend this w/e finishing my hs-plugins based app and feeding my changes back to you. Instead I got distracted by other things and now I probably won't have time for ages.
16:51:22 <dons> ok. well I might try and get hs-plugins-0.9.8 (is that what it's up to?) out this week based on the current snapshot
16:51:35 <dons> as there are some big changes once 6.4 is out.
16:52:41 <MachinShin> is a guard basically a pre-condition?
16:54:21 <Heffalump> in that case would you prefer my changes before the release or after?
16:54:28 <Heffalump> MachinShin: pretty much
16:54:51 <MachinShin> k. thought so
16:55:04 <Heffalump> though not in the sense of causing an assertion if it fails
16:55:06 <dons> Heffalump: the API won't change , so after is fine.
16:55:25 <Heffalump> it just causes fall-through to the next clause of the definition
16:55:25 <MachinShin> Heffalump: oh. waht happens if a guard fails?
16:55:54 <MachinShin> you mean it checks the next guard, what if they all fail?
16:56:23 <Heffalump> if there are no clauses of a definition that apply, you get a runtime error
16:56:47 <MachinShin> ah
17:12:40 <dons> wilx: want are you planning to do, btw?
17:17:11 <CosmicRay> ah ha!  shapr is back!
17:18:10 <jlouis> ``IRC channel steals poor Swedish-talking person from wife''
17:18:21 <CosmicRay> heh
17:18:42 <CosmicRay> ``IRC channel discovers rare married geek''
17:19:04 <monochrom> IRC channel cooks rare married geek to well-done.
17:19:33 <CrewdenX> Lemmih: am i supposed to specify my own or am i expected to have gotten this descriptor from elsewhere?
17:20:29 <Lemmih> CrewdenX: Use 'socket' instead of 'MkSocket'
17:20:51 <CrewdenX> Lemmih: hmm, ok.
17:21:10 <CrewdenX> Lemmih: you wouldn't happen to know of a tutorial for this library, would you?
17:21:37 <Lemmih> CrewdenX: Any socket tutorial for C would do.
17:21:51 * basti_ is not married but in a relatively steady relationship.
17:21:51 <Lemmih> Are you sure you need low level access to sockets?
17:21:59 <CrewdenX> Lemmih: oh, i already know how to use sockets from c.
17:22:17 <CrewdenX> Lemmih: it's stuff like what you just mentioned that would be handy.
17:22:53 <CrewdenX> Lemmih: it's not immediately apparent what features of this module i'm expected to use compared to what it uses internally.
17:22:55 <Lemmih> CrewdenX: Well there's a one-to-one binding between Network.Socket and C sockets...
17:23:30 <Lemmih> CrewdenX: socket is like socket(2), connect is like connect(2) and so on.
17:24:25 * jlouis ponders... Combinator filter/selector library for directory/filepath processing
17:24:41 <CrewdenX> Lemmih: yeah, i see the similarities, and would stiff benefit from at least an example.
17:24:46 <Lemmih> Stuff like sIsReadable and the likes usually don't require a tutorial.
17:25:11 <CrewdenX> Lemmih: i'm figuring it out, it would just be nice if it was documented in a normal sense.
17:25:49 <Lemmih> CrewdenX: The Network.Socket module is for when you want full control over sockets. Essentially the entire C socket API is exposed through this module; in general the operations follow the behaviour of the C functions of the same name (consult your favourite Unix networking book).
17:25:52 <jlouis> I am very fond of Haddock
17:26:02 <CosmicRay> jlouis: I'm not so much
17:26:13 <jlouis> CosmicRay: ok, what do you prefer then?
17:26:14 <CosmicRay> jlouis: the concept is nice but is ha sseveral annoying limitations
17:26:30 <Lemmih> CrewdenX: It is already documented. No reason to do it again.
17:26:37 <CosmicRay> jlouis: I use haddock because everying else sucks more :-)
17:26:50 <jlouis> CosmicRay: ok ;)
17:27:47 <CrewdenX> Lemmih: uhh, ok.
17:28:28 <Lemmih> CrewdenX: Are you sure you need low level access to sockets?
17:28:45 <CrewdenX> Lemmih: nope, but it's what i'm accustomed to using.
17:29:08 <Lemmih> CrewdenX: Take a look at the module Network instead.
17:29:13 <Lemmih> CrewdenX: http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
17:30:00 <CrewdenX> Lemmih: you've been talking past me rather than to me so far.  i kinda figure i made it clear that i've used bsd sockets before.  and i figured you'd understand that i've already looked at that.  we're just not agreed on what makes for good documentation is all.
17:32:00 <Philippa> the haddock stuff tends to be completely lacking in stuff like a design overview
17:32:08 <Lemmih> CrewdenX: How would you document, eg., 'socket' better than it's done in its man page?
17:32:13 <Philippa> I had to waste a good 4-5 hours figuring out Text.Html when I started working on Flippi...
17:32:34 <Heffalump> I think it does support a comment at the top of the file, doesn't it?
17:32:44 <Philippa> A note that that's what's being bound is a good start. As is some details of which exposed bits're probably lower-level than you want to screw with
17:32:51 <Heffalump> but lots of modules just don't have one, or refer to papers or something
17:33:09 <Philippa> yeah. They really ought to include the real Parsec docs, for example
17:33:26 <dons> yeah. you can attach arbitrary chunks of text. but it doesn't often happen that way..
17:33:29 <Lemmih> Philippa: Text.Html isn't exactly a pearl (:
17:33:36 <CrewdenX> Lemmih: in the online doc i would separate out those functions which are dealt with immediately from those that are typically used from outside the module.  then, about 10 lines of example code which clears up pretty much any confusion how to make an outbound tcp connection, for example.  you could be up in running in about 10 minutes, instead of 30.
17:33:47 <CrewdenX> Lemmih: it's not that i can't figure it out.  it'd just be a lot quicker.
17:34:33 <CrewdenX> Lemmih: if you're already familiar with the api, this might not seem like it would be a help.
17:34:35 <Philippa> Lemmih: no shit :-)
17:34:46 <Philippa> er, wait, I missed an "it's" there...
17:34:49 <Lemmih> I don't see how duplicating documentation would help.
17:35:04 <desrt> nightly build still going :)
17:35:16 <desrt> i wonder if one of the tests is caught in an infinite loop
17:35:28 <Philippa> not everybody using the lib has a man page handy
17:35:29 <desrt> nope.
17:35:43 <CrewdenX> Lemmih: i wouldn't for example be looking up the PortNumber constructor to see what i need to pass to it.
17:35:56 <CrewdenX> Lemmih: i have a guess, but it's a guess until i see it.
17:36:17 * Philippa still gets bugged by the whole protocol etc mess
17:37:21 <CrewdenX> Lemmih: hmm, is Word16 a type synonym for Int? I dunno, i'll have to go look at that as well.  all questions that would be made reasonably apparent by 10 lines of example.
17:38:00 <Philippa> no, it's not a type synonym, it *is* however a standard part of the libs (and it belongs to Num)
17:38:15 <CrewdenX> Lemmih: anyways, i appreciate the response all the same.
17:38:17 <Heffalump> isn't it hyperlinked?
17:38:26 <Lemmih> CrewdenX: One click on Word16 would tell you every thing about it.
17:38:40 <CrewdenX> Lemmih: oh, i know.  that's what i'm doing.
17:38:47 <Philippa> then deal
17:38:56 <Philippa> because once you've looked that up, you know all you need to in that regard
17:39:01 <Lemmih> CrewdenX: And that takes 20 mins?
17:39:19 <CrewdenX> Lemmih: if you've never used the library before, that and all the other types, sure.
17:39:22 * Philippa really ought to finish off whirc once GHC 6.4's out
17:39:32 <Heffalump> whirc?
17:39:42 <Philippa> WxHaskell IRc Client
17:39:57 <CrewdenX> Heffalump: have a look.
17:40:00 <Heffalump> bah, what I want is a text-mode one
17:40:02 <Philippa> though I did get fed up and just register mirc in the end
17:40:03 <wilx> dons, nothing in particular. I have seen "Why you should not use Tcl" by RMS posted to comp.lang.tcl and I have became curious.
17:40:15 <Heffalump> wilx: when'd he post that?
17:40:16 <Philippa> I have a non-sucky text-mode client, non-sucky GUI clients are rarer
17:40:20 <wilx> It is old post.
17:40:24 <wilx> Like 1996.
17:40:47 <Philippa> anyway, I dare say you could rip most of the code post-release anyway, all you'd have to do is reimplement the top of the GUI
17:40:52 <wilx> 1994 actually.
17:40:57 <wilx> http://www.vanderburg.org/OldPages/Tcl/war/
17:41:02 <dons> well, RMS is a big fan of lisp scripting, yeah?
17:41:43 <Lemmih> CrewdenX: If you refuse to use the high level interface then it's your own problem that you aren't familiar with types such as Word16.
17:42:16 <CrewdenX> Lemmih: sigh.  does having an example sound all that strange?
17:42:39 <CrewdenX> Lemmih: does boxing the function the user uses as opposed to the internals sound strange?
17:43:32 <CrewdenX> Lemmih: that's all i'm saying.  you really don't have to worry about it.  thanks for your help.
17:43:33 <dons> btw, data Word16 = W16# Word# deriving (Eq, Ord)
17:43:56 <Philippa> dons: that's not an overly useful definition :-)
17:44:09 <dons> ?
17:44:26 <Lemmih> CrewdenX: When the library is _exactly_ like the C interface then the best documentation is your favorite Unix networking manual.
17:46:10 <CrewdenX> Lemmih: dunno what to tell you.  need to get back to my code.
17:55:19 <Heffalump> wossa Word# ?
17:55:54 <CosmicRay> CrewdenX: Internetworking with TCP/IP, Volume III, by Comer and/or Stevens
17:56:02 <CrewdenX> Heffalump: apparently an integral type at # bits in size.
17:56:38 <CrewdenX> CosmicRay: =) thanks, but i'm not sure you understood me.
17:57:16 <CrewdenX> CosmicRay: i'm up and running now.  got a connection and receiving on it.
17:57:17 <CosmicRay> aren't you the one looking for networking info?
17:57:34 <CrewdenX> CosmicRay: yes and no.
17:57:58 <CrewdenX> CosmicRay: not on socket programming in general. i was just hoping to find a ghc example.  i've got my own now though.
17:58:00 <jlouis> Heffalump: unboxed value which is the size of an integer register on the CPU you are working on?
17:58:12 <jlouis> (yes, it is a bet)
17:58:21 <CosmicRay> CrewdenX: check out Network.FTP in my MissingH library
17:58:25 <Heffalump> CosmicRay: pardon?
17:58:25 <CosmicRay> CrewdenX: examples of both client and server in there
17:58:39 <CosmicRay> hmm?
17:58:52 <Heffalump> jlouis: /me is sort of assuming it's a native word size, which seems a bit odd if it's being used to implement Word16 like that
17:59:03 <CrewdenX> CosmicRay: well, i'm pretty much where i need to be now.  but i'll check it in a bit anyways.
17:59:04 <Heffalump> sorry, s/CosmicRay/CrewdenX/
17:59:08 <Heffalump> too many Cs
17:59:17 <CosmicRay> heh
18:00:31 <CrewdenX> Heffalump: gotta go.  i'll be back later.
18:00:43 <Heffalump> I'm going to bed :-)
18:06:49 <cm> hi
18:06:57 * cm shapes shapr
18:08:04 <metaperl> lol
18:08:26 <metaperl> shapr, which of the intro books does a thorough job of teaching type classes?
18:12:58 <Lemmih> metaperl: You might take a look at http://haskell.org/tutorial/classes.html
18:13:23 * heatsink was taught how to type in a class. It was _boring_.
18:14:06 <heatsink> but faster than hunt-and-peck.
18:14:48 <metaperl> Lemmih, yes I have been going through Gentle, but I found the type class stuff to move a bit too quick... perhaps if I slowed down and read it I would be OK
18:15:32 <metaperl> I want something a little more applied
18:16:16 <metaperl> I suppose I could read the prelude and ask questions but I think it would be good to buy a book
18:18:11 <Lemmih> heatsink: Heh.
18:29:47 <MachinShin> why is the basis of all functional languages appears to be lists?
18:30:51 <desrt> we're all a bunch of cons artists
18:30:57 <dons> Word# == W_ == StgWord == StgWord32 (usually) == unsigned int
18:30:58 <wilx> :)
18:31:03 <dons> desrt: so true.
18:31:04 <MachinShin> hah
18:31:32 <desrt> i need that on a shirt
18:31:48 <desrt> "λ cons artist"
18:32:06 <MachinShin> seriously though..
18:32:13 <dons> hmm. what are the first 2 chars -- ascii please ;)
18:32:17 <desrt> lambda
18:32:31 <desrt> "\ cons artist" for the utf8-disabled :)
18:32:39 <dons> yep. good
18:32:57 <dons> weren't you complaining about non-ascii yesterday, btw?
18:33:07 <desrt> i was complaining about non-utf8
18:33:14 <dons> ah, I see.
18:33:25 <dons> as long as you were complaining about something.
18:33:29 <desrt> :)
18:36:16 <desrt> it's been quiet in here today
18:38:38 <Igloo> Can I complain about people complaining about utf8?
18:39:03 <desrt> at your own risk
18:39:28 <Igloo> Well, in dons' case I couldn't be much further away at least  :-)
18:39:31 <wilx> What are the people complaining about about the UTF-8?
18:39:49 <desrt> don complained at me for using it
18:39:55 <desrt> i complained at someone else for not using it
19:25:32 * desrt plays the nightly game
19:28:23 <MachinShin> night all
20:24:15 <desrt> dons; -j is broken sometimes
20:26:09 <desrt> specifically, happy is unhappy
20:46:32 <dons> that's not too surprising.
20:46:52 <desrt> i've modified my build scripts to help it out a bit
20:47:04 <dons> as long as libraries/ and ghc/compiler/ work, then we don't really care, right?
20:47:17 <desrt> there are other places it breaks too, but they fix if you run make again
20:47:32 <desrt> so i just do make -j5 || make -j5 || make -j5 || make -j5 || make -j5
20:47:32 <desrt> :)
20:47:37 <dons> yeah. that's what i noticed last night.
20:47:58 <dons> but  it does all work if you just 'make' ghc in $fptools
20:48:17 <desrt> hmm
20:48:39 <desrt> i guess maybe happy/alex/glafp-tools/etc needs to come first and the makefiles don't know that
20:50:41 <desrt> woh
20:50:53 <desrt> going to http://www.osxvnc.com/ doesn't get you what it used to
20:54:47 <dons> hmm.
20:57:55 <autrijus> rehi lambdafolks.
20:58:04 <desrt> rah
21:02:30 <desrt> dons; i've thought about why a stage3 isn't really important
21:02:52 <desrt> if the stage1 compiler produced a stage2 that is somehow defective then you'll find out during nofib/testsuite
21:06:12 <Gahhh> is 6.4 out ?
21:06:20 <desrt> i hope not
21:06:28 <Gahhh> uh ok
21:06:46 <desrt> it'll be along soon
21:06:52 <desrt> but not yet
21:06:59 <Gahhh> will it support cygwin builds do you think ?
21:07:40 <desrt> i see a lot of mingw stuff in the tree
21:07:57 <desrt> i really don't know.
21:08:04 <Gahhh> the win32 port is built within cygwin but for target mingw.
21:11:06 <Gahhh> hmmm, simonj is going to give the keynote speech on IBM's prog lang day this year.
21:38:55 <desrt> does there exist some platform on which 'time' is a command?
21:40:15 <ibid> all unices?
21:41:07 <desrt> not any i know of
21:41:08 <beschmi> it's a shell builtin on most (all?)
21:41:10 <seidan> actually time is a reserved word in bash (and other shells?) not a command...
21:41:14 <desrt> it's a shell builtin here
21:42:08 <desrt> nofib is trying to use it as if it is a command
21:45:58 <gombe> i read that haskell is good for large scale applications.  can someone name some applications wirtten in haskell
21:51:15 <newpers> hey, this is gombe.. i logged off and switched nicks.  (just in case anyone was going to reply to my previous question)
21:51:33 <Gahhh> darcs is the most famous app written in haskell
21:51:47 <Gahhh> ghc (the compiler) is also written in haskell
21:52:07 <aFlag> any ideas on writting a recursive function f of the type Int -> Bool which gets a integer n and applies 0..n to a function n and if the function returns 0 then the function f returns true and it returns false otherwise
21:52:35 <newpers> GAhhh, thanks
21:53:09 <Gahhh> aFlag, you almost wrote it with that paragraph lol
21:53:31 <aFlag> hehe i can't figure it out though hehe
21:53:46 <aFlag> i know how to do it with a for :P
21:53:48 <Gahhh> you are confused tho
21:54:04 <Gahhh> it sounds like your function takes another function as an argument as well
21:54:32 <aFlag> yeah, it could, but it's not what i'm having trouble with
21:55:32 <aFlag> it's an excercice from a book and since it haven't tought about passing functions as parameters yet it didn't ask for it
21:56:30 <Gahhh> well, then you need to rephrase your question because it's not clear.
22:00:00 <aFlag> it's something like this boolean f(int n) {for(int x=0, x<=n; x++) { boolean b = some_function(x)==0; if (b) return true; } return true;}
22:00:45 <aFlag> i thought on doing something with b but then it ended up being unecessary :P
22:01:12 <Gahhh> I see
22:01:42 <aFlag> that's what i want to do recursively, but i don't know how :(
22:02:05 <Gahhh> so it returns true if "some_function returns true for at least one value of x" or "some_function returns false for all x". am I correct ?
22:02:56 <aFlag> it returns true if some_function returns 0 at any point, and returns false if it doesn't happen
22:03:14 <Gahhh> oops yes
22:03:40 <Gahhh> your last return should be return false then
22:03:50 <aFlag> boolean f(int n) {for(int x=0, x<=n; x++) { if (some_function(x)==0) return true; } return false;}
22:03:56 <Gahhh> ok
22:04:09 <Gahhh> firstly, why do you want to make this 'recursive' ?
22:04:35 <Cale> aFlag: you're writing C code?
22:04:54 <aFlag> that was what the exercice asked and now i want to figure it out
22:05:12 <aFlag> Cale, yeah, i was trying to clearly tell what i wanted to do hehe
22:05:20 <Gahhh> aFlag, you can do this, but it won't be recursive.
22:05:23 <Cale> okay, so the first thing you do is to apply the function parameter f to the elements of the list
22:05:38 <Cale> then check if any of the results are 0
22:05:57 <Cale> there's a nice prelude function called "any"
22:06:45 <Cale> (any p xs) is true if p x is true for any one of the elements x of xs, and false otherwise
22:07:36 <Cale> does your function need to be explicitly recursive?
22:08:15 <aFlag> hum... it says only it should be recursive
22:08:43 <gzl> well, you can do it with a map, and map is recursive, so it's sort of implicitly recursive
22:08:58 <aFlag> doing it with a list shouldn't be that hard, i was wondering if i was missing something about recursion though
22:09:15 <gzl> actually, it's kind of nice how compact the haskell version is
22:09:17 <Cale> test f = not . any (==0) . map f
22:09:36 <desrt> hello cale
22:09:43 <Cale> desrt: hello :)
22:10:03 <gzl> i think that's backwards, no?
22:10:05 <desrt> head exploding yet?
22:10:19 <Cale> my head?
22:10:23 <desrt> too much math
22:10:40 <gzl> heh, i'm buried in some math right now myself.
22:10:44 <desrt> when did you write your wiki page about monads as containers?
22:11:06 <Cale> desrt: back a while ago. Most of it I wrote while I was working at McMaster.
22:11:12 <desrt> hmm
22:11:17 <desrt> i wish you'd shown it to me back then
22:11:29 <desrt> i'd have been able to make sense out of the craziness you were spouting :)
22:11:33 <Cale> :)
22:11:58 <Cale> I did actually go over that way of thinking about them in a presentation I gave
22:12:00 <aFlag> ok, thanks guys
22:12:10 <desrt> i know.. but nobody understood
22:12:18 <Cale> aFlag: so, one thing you could try is to write it explicitly
22:12:23 <Cale> test f [] = ...
22:12:28 <Cale> test f (x:xs) = ...
22:12:30 <desrt> i think either the idea wasn't as fully developed at the time or you're better at written presentation than oral
22:12:41 <Cale> probably both
22:13:27 <aFlag> yeah, i get it, i thought on doing something like that, but i thought there might be some other way to do it that might be better
22:14:17 <aFlag> i'm going to bed, good night to all
22:14:23 <Cale> night
22:16:24 <Cale> desrt: so you like that way of thinking about monads? I find it a little odd that they aren't described that way more often.
22:16:39 <desrt> well
22:16:54 <desrt> i'm not sure it's useful for the purposes of understanding their purpose in haskell
22:17:12 <Cale> well, half the time it is
22:17:25 <desrt> i didn't know about the whole functor thing
22:17:44 <Cale> It's about half of the picture -- the other way being the usual idea of monads as an abstraction of computation.
22:17:54 <desrt> you think haskell would have functors and impliment map as a generic method
22:18:09 <desrt> (and have list be an instance of monad which is an instance of functor)
22:18:34 <Cale> It does have functors, but the situation is a little odd.
22:18:56 <Cale> You're not required to make your monad an instance of functor
22:20:49 <Cale> (You'll notice "class Functor f  where fmap :: (a -> b) -> f a -> f b" in the prelude)
22:21:29 <dons> I do love fmap.
22:21:37 <dons> I should use it more often.
22:23:40 <desrt> are there any functors actually used in haskell, though?
22:24:44 <dons> actually used?
22:24:54 <dons> used in libraries, you mean?
22:24:58 <dons> or ghc
22:25:19 <desrt> anything that's available to me at the ghci prompt
22:25:47 <dons> well, many things are instances of Functor
22:25:55 <dons> FiniteMap springs to mind
22:26:32 <dons> damn it, can't ssh into a laptop that's hibernating..
22:26:57 <desrt> is this the new or old finitemap?
22:27:34 <dons> current. and old. I see IntMap is too, Tree, Queue, Maybe, Map, Array
22:28:00 <dons> hmm. and I've never used FunctorM either
22:29:17 <desrt> you're gonna want to run my nightly scripts when i'm done
22:29:19 <desrt> they're l33t
22:29:41 <desrt> for example, instead of saying "ok" or "success" or something boring it says "awesome" and "rad!" and "l33t" on success
22:30:01 <dons> seriously, it says "l33t" on success. :}
22:30:03 <dons> ?
22:30:09 <desrt> well.  it does now
22:30:11 <dons> that's bizarre.
22:30:15 <desrt> i doubt that will be in the final version :)
22:30:18 <dons> hehe
22:30:35 <desrt> the setup is ultra-modular
22:30:52 <desrt> there exists a 'tasks' directory in which you put a whack of scripts
22:31:43 <desrt> 01_checkout_tree, 02_update_tree, 03_create_build_directories, 04_autoconf, 05_glafp-utils, 06_happy, 07_happy_stage_2, 08_alex, 09_ghc_stage_1, 10_libraries, 11_ghc_stage_2, 12_ghc_stage_3, more later...
22:31:44 <ozone> desrt: do you use SOAP and Web services for interaction between your GHC build components?
22:31:54 <desrt> ozone; in version 1.1.
22:32:16 <ozone> well, without SOAP, i can't tick this checkbox, you see
22:32:28 <desrt> just wait for version 1.1 then :)
22:32:30 <ozone> so, i'm afraid i won't be able to use them
22:32:33 <ozone> :}
22:33:15 <dons> ozone is crackers
22:33:28 <desrt> anyway.. it runs the scripts one at a time
22:33:39 <desrt> and if one fails, then it's all over
22:33:57 <desrt> but otherwise it just goes about its merry way, generating logfiles as it goes
22:34:08 <dons> log files are the best
22:34:21 * dons is tired
22:34:21 <desrt> hmm
22:34:30 <desrt> my nightly build script is indicating that -j is giving troubles.
22:34:32 <desrt> >:|
22:34:37 <ozone> dons: if you eat more red meat, i'm sure you'll be less tired
22:34:47 <dons> :P
22:34:48 <ozone> <- dark side points++
22:34:57 <desrt> heh
22:35:09 <dons> not enough caffeine today
22:35:21 <dons> where's my choco-coffee beans
22:35:26 <ozone> dons: hey, if you want any
22:35:29 <ozone> i've got _heaps_ of them
22:35:34 <ozone> as in, no way in hell i can finish all of them
22:35:38 <desrt> i don't think 'boot' is -j able
22:35:44 <ozone> i can bring some for you next time i'm at uni, if you like
22:35:48 <desrt> in general
22:36:00 <dons> oh, i've got some here ozone. from the oxfam store.
22:36:04 <dons> yummy in my tummy
22:36:13 <ozone> oh.  i've got tons of haighs ones :)
22:36:38 <dons> desrt: well, why does -j work when we just use the in-tree scripts
22:36:42 <dons> gnu make is nasty
22:36:46 <desrt> dons; it doesn't for me
22:36:56 <desrt> i have to restart the build
22:36:59 <dons> ah! so maybe something got broked
22:37:03 <desrt> (then it works the 2nd time)
22:37:16 <ozone> dons: what we really need to do is write a more straightforward language to wrap GNU make
22:37:20 <dons> yeah, but that's just because one of the dependencies got created.
22:37:21 <ozone> i know, let's call it automake
22:37:23 <desrt> this breaks it: make -j5 -C build/head/ghc boot
22:37:24 <ozone> that'll fix everything
22:37:36 <dons> ozone: nah. got a thesis topci for that. no takers yet.
22:37:58 <desrt> i'm running my buildy script to see if it works if i do the 'make boot' non-parallel
22:39:49 <desrt> heh.  'happy stage 2'  i love it :)
22:41:01 <desrt> dons; you going to bed soon?
22:41:14 <desrt> oh.  i guess not :)
22:41:34 <dons> oh, dinner. but the box will be on for another 5-6 hrs
22:41:42 <desrt> oh.  it's ok
22:41:52 <desrt> was just gonna try to find the -j problem
22:42:16 <desrt> if you find it after i go to bed can you please email me and tell me so i don't end up looking for it tomorrow after you've fixed it? :)
22:42:29 <dons> yep.
22:42:37 <desrt> thx.
22:42:46 <dons> though I still don't have a good idea of how to resolve -j problems methodically
22:43:01 <desrt> there is no method.  only madness :)
22:43:10 <dons> seems so.
22:43:19 <lou-tze> hi
22:43:31 <desrt> anyway.  it's no biggie
22:43:39 <lou-tze> @seen TheHunter
22:43:39 <lambdabot> I saw TheHunter leaving #haskell 14 hours 13 minutes 34 seconds ago.
22:43:45 <desrt> make boot for ghc only takes 1m56s real
22:43:51 <desrt> even when non-parallel
22:44:00 <dons> desrt: i'd like to in fact test -jN nightly, so we don't lose it
22:44:08 <desrt> dons; i agree
22:44:35 <desrt> failure to successfully -j is the same as any other build failure, as far as i'm concerned :)
22:45:03 <dons> it's a sign of reliance on funny behaviour in the scripts, anyway.
22:45:12 <dons> implicit dependencies
22:45:22 <desrt> it's a sign of reliance on order
22:45:30 <desrt> sometarget :: task1 task2 task3
22:45:46 <desrt> with task1 2 and 3 otherwise not marked as dependant on each other when really they are
22:45:58 <Lemmih> ozone: I've released Hacanon 0.1.
22:45:58 <dons> true. good point.
22:46:25 <ozone> Lemmih: woo, congrats!
22:46:44 <desrt> oh neat.  i just got an actual breakage
22:46:49 <desrt> nativeGen/PprMach.hs
22:46:58 <ozone> Lemmih: btw, i was musing on another idea about OO<->haskell interoperability yesterday.  i can discuss it here if you're really bored
22:47:06 <ozone> (haven't thought about it much at all, so it'll be rough)
22:47:09 <dons> desrt: what, from a bug? or a weird dep?
22:47:21 <desrt> bug
22:47:27 <Lemmih> ozone: Please, do tell (:
22:47:30 <desrt> this is weird
22:47:51 <desrt> it's a PIC thing
22:48:10 <ozone> Lemmih: basically, right now the OO approaches seem to be heavyweight
22:48:11 <dons> hmm
22:48:23 <desrt> it looks like the compiler is producing invalid C output
22:48:29 <ozone> i.e. the technique that chak and i came up with was to make huge use of fundeps to do OO-style overloading
22:48:30 <desrt> (gcc is throwing syntax errors)
22:49:01 <ozone> i'm wondering whether it's possible to do it in a more lightweight, neater, more "haskell-like" way, by using partial application (currying)
22:49:07 <desrt> the lame part is that gcc-6.2.2 is the transgressor here
22:49:22 <desrt> *ghc
22:49:58 <dons> desrt: weird weird
22:50:10 <desrt> weird weird evil
22:50:17 <ozone> Lemmih: if you make all an object's methods functions, which take in the state of the object but also _returns_ you the object with the new state that is also partially applied, well, that might be a ... nicer ... way of doing things
22:50:23 <dons> ozone: hey, what days do you/are you s'posed to come in to uni?
22:50:26 <ozone> haven't thought about it much, but it deserves some investigation
22:50:58 <desrt> sigh.  i think -j is causing all sorts of heisenbugs and we're the first people to really give it a good workout :/
22:51:13 <ozone> dons: most probably monday and tuesday
22:51:21 <ozone> but that's subject to confirmation
22:51:28 <dons> desrt: hey! 6.2.2 is broken wrt. -jN
22:51:37 <dons> it's only in the head. see simonm's commits.
22:51:45 <desrt> i'm building head
22:51:48 <desrt> (using 6.2.2)
22:51:54 <desrt> that should be ok, no?
22:51:57 <dons> oh! ok. bizarre.
22:52:03 <dons> ozone: ok
22:52:08 <Lemmih> ozone: I don't quite follow.
22:52:17 <desrt> lemme upload the l33t logfile
22:52:20 <dons> desrt: maybe make some notes somewhere.
22:52:24 <dons> yah
22:53:14 <ozone> Lemmih: OK, if you think of objects as two things: (1) a set of methods, and (2) a storage for some internal, hidden state
22:53:28 <ozone> then you can take the idea of (1), and put that into a library
22:53:44 <ozone> i.e. imagine an "object" which is just a whole bunch of static methods.  like you're writing a library in java
22:54:00 <dons> desrt: you working on head, or head-stable?
22:54:07 <desrt> head
22:54:09 <dons> I'm going to do some 'vestigations.
22:54:15 <desrt> :)
22:54:56 <dons> ozone: you enrolled in cs9161 yet?
22:55:12 <ozone> Lemmih: so, now you have a set of methods.  to do (2), just make those methods take the "object" as a parameter, which is meant to be partially applied
22:55:18 <ozone> dons: yep, i believe so
22:55:28 <dons> k. cause it's full up.
22:55:36 <ozone> Lemmih: so, say you have an object Coffee, and a method named drink
22:55:40 <ozone> in C++/java, you could write
22:55:47 <ozone> Coffee c = new Coffee(); c.drink();
22:55:51 <desrt> http://www.desrt.ca/ghc/logs/
22:57:36 <desrt> i went back into the directory and redid the make.  success.
22:57:50 <ozone> the idea is that if you wanted to model that in haskell, your mapping of the drink method in haskell would be a function which is designed to be curried
22:57:55 * desrt tries again from scratch to see if he gets more(less?) lucky
22:58:04 <dons> desrt: funny dependency then?
22:58:10 <desrt> i guess?
22:58:12 <desrt> sigh.
22:58:15 <dons> weird though
22:58:25 <desrt> i'll leave the logs there as an example of what can go wrong :)
23:00:24 <dons> jah. alex is not -j happy
23:00:53 <Lemmih> ozone: I still don't have the slightest clue of what you mean (:
23:01:02 <desrt> woh
23:01:04 <desrt> dude look at this:
23:01:07 <desrt> http://www.desrt.ca/ghc/logs/07_happy_stage_2.log
23:01:13 <desrt> it's doing everything twice
23:01:31 <dons> hmm...
23:01:53 <dons> I get some: coommppiillaattiioonn  IISS  NNOOTT  rreeqquuiirreedd
23:01:57 <desrt> same with alex
23:02:05 <desrt> /usr/bin/ghc -H16m -O    -c DFA.hs -o DFA.o  -ohi DFA.hi
23:02:05 <desrt> /usr/bin/ghc -H16m -O    -c DFA.hs -o DFA.o  -ohi DFA.hi
23:02:05 <desrt> compilation IS NOT required
23:02:05 <desrt> /usr/bin/ghc -H16m -O    -c Parser.hs -o Parser.o  -ohi Parser.hi
23:02:05 <desrt> /usr/bin/ghc -H16m -O    -c Parser.hs -o Parser.o  -ohi Parser.hi
23:02:18 <desrt> compilation not required because the first instance of the command already finished
23:02:23 <dons> oh well, as long as ghc realises what's not required.
23:02:37 <dons> and we can disregard the extra tools for now, anyway
23:02:52 <desrt> ya.. ghc and libraries are the things that really matter
23:02:57 <desrt> i'm just gonna turn off -j for the other stuff
23:04:51 <ozone> Lemmih: i think i'll have to think about it a bit more first
23:05:13 <ozone> Lemmih: will get back to you :)
23:07:36 <ozone> dons: i'll double-check my 9161 enrolment
23:07:57 <dons> maybe a good idea. but it's probably fine.
23:08:53 <ozone> dons: UNSW rule #1: never trust NSS ;)
23:09:01 <ozone> (or even administration)
23:15:00 <desrt> yay
23:15:03 <desrt> stage 1 = success
23:15:18 <desrt> let's see if i get so lucky with libraries :)
23:15:31 <dons> cool. so far I'm cruising through stage1
23:15:45 <desrt> (actually, i should probably be annoyed that stage1 worked... that means that the bug is difficult to reproduce) >:|
23:16:02 * dons feels he should attempt something on the quad ia64..
23:16:10 <desrt> *raise eyebrow*
23:16:17 <desrt> you have a quad ia64?
23:16:37 <dons> nah, uni.
23:16:43 <dons> Linux 2.6.7-1-itanium-smp ia64
23:16:48 <desrt> think you could get me an account? :)
23:17:05 <dons> hehe. not sure. it was hard for me to get an account.
23:17:23 <desrt> no prob.
23:17:30 <desrt> you're not the ia64 porter, are you?
23:17:53 <dons> nah. i messed with it a few times, but it was matt chapman who did the really hard yards
23:17:57 <dons> like ghci.
23:18:11 <desrt> the ghci parts are scary :)
23:18:35 <dons> they relocate your head
23:18:40 <desrt> that they do.
23:18:56 <desrt> admittedly, i like Linker.c
23:19:07 <desrt> by virtue of it being the single file in the entirety of GHC that i actually understand
23:19:10 <dons> ha!
23:19:22 <dons> yeah, it is the usual entry point.
23:19:39 <desrt> it's a good place for C hax0rs to wet their feet :)
23:20:01 <dons> yeah. no scary haskell to deal with.
23:20:18 <dons> and you can cast pointers to your heart's content.
23:20:24 <desrt> the only haskell i've written for ghc is a function that produces raw machine code :)
23:20:35 <dons> then dive into Adjustor.c for some more action.
23:20:52 <dons> where's that in?
23:20:57 <ozone> desrt: that's abuot the extent of my GHC understanding, too :)
23:20:57 <desrt> hmmm
23:20:59 <dons> some powerpc native gen thingo?
23:21:04 <desrt> ghci/ByteCodeFFI.lhs or something
23:21:19 * shapr takes a byte outta da code
23:21:24 <desrt> ow
23:21:34 <desrt> my fingers were still inside there
23:21:57 * shapr grins
23:22:14 <shapr> Who was that Bond villain? The guy with the teeth?
23:22:27 <desrt> ya.  everything from like 537 down in that file is mine :)
23:22:43 <shapr> Googles says "Jaws"
23:22:54 <desrt> there are more hexidecimal constants (machine code) than there is haskell code, though :)
23:23:33 <dons> what's this then?: include/HsBase.h:405: #error at least ftruncate or _chsize functions are required to build
23:23:52 * dons kicks make
23:23:59 <desrt> fun fun fun
23:24:11 <dons> nope. did it again.
23:24:24 <dons> libraries/base
23:24:25 <desrt> maybe it's legit
23:24:43 <desrt> the copy i'm working with right now was checked out about 6-7 hours ago
23:24:51 <desrt> so maybe some badness went into the tree since then
23:25:00 <dons> hmm. looks like.
23:25:18 <dons> In file included from CPUTime.hsc:37 include/HsBase.h:405:
23:25:19 <beschmi> is there something like http://sbcl.boinkor.net/bench/ for ghc?
23:25:37 <dons> what does that do, beschmi?
23:26:06 <beschmi> show benchmarks for different cvs checkouts of sbcl
23:26:45 <dons> nope. we don't have that. but it wouldn't be too hard to write, as we do have the nofib, and the ghc-regress tests
23:27:21 <dons> for i in 4 5 6 ; for j in 0 1 2 ; do cvs checkout ghc-$i-$j ... ; cd fptools ; gmake ;)
23:27:29 <desrt> i remember seeing something liek that for gcc
23:27:55 <dons> simonm does do a comparison pior to release. don't know how it's done though
23:29:00 <desrt> "new features of this release: now only 20x (not 25x) slower than C!"
23:29:11 <dons> bah.
23:29:15 <desrt> heh.
23:29:36 <dons> write some Word# recursion and watch gcc blow up
23:29:37 <shapr> I'd like to benchmark the authoring speed of Haskell vs C.
23:30:07 <desrt> shapr; whatever you do, don't use SE 3E03 as a sample
23:30:14 <dons> I like the idea for this year's ICFP prog comp -- you have to modify your soln to solve a second problem.
23:30:32 <shapr> Never heard of it... course at McMaster?
23:30:45 <desrt> ya
23:30:48 <shapr> dons: Where's that mentioned?
23:30:49 <desrt> dr. kahl's haskell course
23:31:13 <shapr> He's Wolfram Kahl, right?
23:31:17 <desrt> ya
23:31:19 <dons> shapr: http://icfpc.plt-scheme.org/
23:31:21 <desrt> he's l33t :)
23:31:30 <shapr> I always get confused between Wolfgang and Wolfram
23:31:40 <desrt> for most of the class everyone was always like "why can't we just do this in C?!?"
23:31:59 <shapr> dons: I love it.
23:32:01 <desrt> then he showed us parsers in haskell and parsers in Java, and we were glad we had haskell
23:32:09 <vincenz> Anyone familiar with transformation matrices?
23:32:24 <dons> shapr, yeah, might be hard for the C/perl/bash/sed guys.
23:32:24 <desrt> vincenz; like #math? :)
23:32:39 <vincenz> I tried
23:32:52 <desrt> you mean for rotating/scaling/etc a vector?
23:32:57 <shapr> dons: Cool, I hope I can get on an ICFP team this year.
23:33:16 <earthy> shae: be an ICFP team. :P
23:33:37 <desrt> i have a very small knowledge of them so there's a non-zero chance that i know the answer to your question
23:33:39 <shapr> Team usually means more than one person :
23:33:55 <earthy> granted :)
23:33:58 <vincenz> shapr: I might join to haskell if I find no candidates for ocaml
23:34:02 <earthy> drag in the good wife ;)
23:34:06 <vincenz> shapr: or I might do it with colleagues who know haskell
23:34:08 <shapr> vincenz: you don't know haskell.
23:34:11 <vincenz> cause none of them know ocaml
23:34:12 <vincenz> shapr: SO?
23:34:16 <dons> hehe
23:34:26 <vincenz> shapr: I didn't know scheme...took up a book 2 weeks before icfp and did it in 2003
23:34:27 <desrt> pfft.  all functional languages are the same
23:34:36 <earthy> desrt: not quite ;)
23:34:37 <vincenz> shapr: and before that I knew no functional languages
23:34:47 <earthy> it took me some figuring out what vars did in ml
23:34:56 <vincenz> anyways perhaps you guys can answer
23:35:00 <shapr> Did you win?
23:35:02 <earthy> `wha? this likes like toplevel things with identity... *wha*?'
23:35:05 <vincenz> given an affine transformation matrix T (4x4)
23:35:06 <earthy> s/likes/looks/
23:35:14 <vincenz> or call it X
23:35:21 <vincenz> I want it split into translation, scaling and rotation
23:35:27 <vincenz> X = T*S*R
23:35:27 <shapr> crap, my keyboard is flaking out.
23:35:49 <desrt> vincenz; transformation matricies can't translate
23:35:55 <vincenz> desrt: 4X4
23:36:13 <desrt> transformation on R^4?
23:36:19 <vincenz> no
23:36:25 <vincenz> learn about transformation and get back to me ;)
23:36:28 <shapr> earthy: The wife doesn't enjoy programming. Which is too bad because she's a powerful and efficient problem solver, she would be a contribution to any team.
23:36:29 <desrt> k :)
23:36:51 <earthy> shapr: then lure her in as if it were a puzzle contest!
23:36:54 <desrt> the transformation matricies i know about are left-multiplied to a vector
23:36:57 <earthy> (which, in a sense, it is)
23:37:15 <vincenz> desrt: yes and typically you use 4-d vectors
23:37:17 <vincenz> x y z t
23:37:21 <vincenz> t = 1 point
23:37:28 <desrt> ah
23:37:28 <vincenz> t = 0  point on infinity (direction)
23:37:36 <vincenz> and it allows for translation
23:37:39 <lou-tze> vincenz: trans part is easy - take last column (row, if it's row-major)
23:37:48 <desrt> so it's like introducing a constant term into the matrix
23:37:53 <vincenz> lou-tze: I know
23:37:59 <vincenz> lou-tze: I want to know how to get the x y z scaling
23:38:03 <vincenz> desrt: pretty much...
23:38:24 <desrt> well in that case it seems pretty easy to separate out the translation
23:38:31 <vincenz> [1 0 0 x
23:38:31 <vincenz>  0 1 0 y
23:38:31 <vincenz>  0 0 1 z
23:38:31 <vincenz>  0 0 0 1]
23:38:35 <vincenz> translate by x y z
23:38:38 <desrt> just take out the row (or column or however it works) that corresponds to the ....
23:38:41 <desrt> ya
23:38:42 <vincenz> yes I know
23:38:43 <desrt> :)
23:38:46 <vincenz> I'm stuck on the scaling
23:38:53 <vincenz> I'm considering determinant but that won't work
23:38:58 <vincenz> maybe submatrix determinants?
23:39:45 <desrt> well
23:39:54 <desrt> scaling will be solely on the diagonal
23:40:01 <vincenz> ooh
23:40:06 <vincenz> I think I know
23:40:16 <desrt> so basically (ignoring the constant part) you'll have a diagonal matrix multiplied by a rotation matrix
23:40:16 <vincenz> desrt: yes but I'm trying to split an X
23:40:25 <vincenz> so get the x y z scaling factors
23:40:27 <vincenz> but I might have an idea
23:41:00 <vincenz> determinant of matrix / determinant of matrix -row/column of dimension
23:41:08 <vincenz> I think that might do it
23:41:32 <desrt> i hope you are right :)
23:41:34 <vincenz> (there's a name for that Major////)
23:41:46 <vincenz> desrt: well I checked for x rotation matrix...seemed fine...
23:41:56 <vincenz> basically if you check any of the rotation matrices...
23:42:08 <desrt> ya. it seems to make sense :)
23:42:10 <vincenz> one sees that scaling will result in det = x *y*z
23:42:38 <vincenz> coolies :)
23:42:52 <vincenz> and I only have to do it for the 3x3 submatrix
23:43:24 <vincenz> see I'm redoing the ICFP contest that I wasn't in
23:43:31 <vincenz> the 2001 one (3D raytracer)
23:43:35 <desrt> ahh
23:43:50 <vincenz> I thought that splitting into three matrices might make it easier to do gross bounding circle collision checks
23:43:51 <desrt> ((mental note: bring linear algebra book to ICFP))
23:44:28 <vincenz> anyways
23:44:31 <vincenz> in 1h I have a class
23:45:09 * vincenz is at home right now...Gonna leave in 45m
23:45:58 <desrt> hmm
23:46:15 <desrt> i need some GhcLibWays= action
23:46:16 * vincenz subscribed for a class :)
23:46:28 <vincenz> Anyways my biggest worry for icfp is gui
23:47:02 <desrt> by biggest worry for icfp is being assulted by some estonian thug
23:47:26 <desrt> :)
23:49:01 <vincenz> ??
23:49:23 <vincenz> well fortunately I just learned lablgtk2 (or rather...I copy pasted the examles from a tutorial but it looked pretty straight forward)
23:49:29 <desrt> </joke>
23:49:30 <vincenz> if I were to start with haskell I'd be stuck without a gui again
23:50:02 <desrt> it never ceases to amaze me... the number of language bindings gtk has
23:52:42 <desrt> dons; my build scripts are on to stage2 and i'm on to bed
23:59:47 <desrt> ARGH
23:59:49 <desrt> another break
23:59:51 <desrt> this one in stage2
