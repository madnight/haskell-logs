00:18:52 <Lemmih> Good morning, #haskell.
00:26:54 <viirya> autrijus: ping
00:36:42 <autrijus> viirya: pong
00:37:17 <viirya> autrijus: I built a redhat9 version of pugs, do you like to mirror?
00:37:30 <autrijus> sure, k
00:38:59 <viirya> autrijus: www.viirya.org/pugs20050206-redhat9-i386
00:39:34 <viirya> using stuff pulled now.
00:40:05 <autrijus> ok, thanks.
00:40:11 <autrijus> I'll call it 0205.
00:40:22 <autrijus> 0206 is not yet over :)
00:40:56 <viirya> oh, ok. :)
00:41:10 <autrijus> mirrored, thanks
00:46:15 <viirya> it has smallest size.
00:47:23 <autrijus> right.
00:47:28 <autrijus> ~same with freebsd
00:48:11 <viirya> chubby solaris and win32.
00:48:15 <autrijus> :)
01:36:03 <jlouis> hmm
01:36:13 <jlouis> someone wrote me, but I do not know who
01:39:46 <Lemmih> Did you check the logs?
02:00:24 <basti_> women dont generally understand the nernst equilibrium equation do they?
02:25:12 * boegel giggles
02:33:27 <boegel> hey Jan_w 
02:33:48 <Jan_w> hi boegel
02:35:02 <boegel> @wiki TheMonadReader
02:35:03 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
02:39:03 <boegel> Jan_w: are you the first implementor of generic haskell ?
02:39:14 <boegel> I mean GHC
02:39:48 <Jan_w> no
02:39:51 <Jan_w> just a user
02:40:15 <boegel> Jan_w: isn't this you ? http://www.haskell.org/hawiki/JanDeWit
02:40:26 <boegel> oh, it's not :D
02:40:29 <boegel> sorry :p
02:40:36 <Jan_w> hehe, i wish
02:40:44 <boegel> I thought Jan_w -> Jan De Wit :D
03:10:18 * Oejet hammers his head into the wall in frustration and shame.
03:11:45 <boegel> Oejet: ?
03:11:58 * Oejet crawls to #haskell on his knees and mutters in tears:
03:12:10 <Oejet> Could someone help me with a permutation function?
03:14:06 <basti_> maybe we could try.
03:15:08 <lisppaste2> Oejet pasted "Permutation that doesn't work :'(" at http://paste.lisp.org/display/5584
03:15:52 <Oejet> I just can't get my head around the problem.
03:17:38 <basti_> youre basically definining permutations for (x:xs) as [(x:xs),xs++[x]]?
03:18:42 <basti_> oh no as all rotations of these two
03:19:50 <Oejet> It's too complicated.  There has to be something simple, e.g. using list comprehension.
03:20:34 <basti_> afair "all permutations" never was really easy.
03:20:54 <basti_> and this function just does return an empty list
03:21:06 <Oejet> Yes.
03:21:19 <samc> I would've thought of it as traversals of a tree
03:21:52 <Oejet> samc: Yes, good idea.
03:22:15 <basti_> what would the branches of the tree be? i think theres more than one possibility
03:44:13 <samc> sorry, I was away. Ah, you can? What are they? I was thinking of making each element a branch mand doing the same for its children with the rest of the list
03:45:18 <Oejet> data Tree = Node Int [Tree]
03:47:37 * boegel yawns
03:49:26 <samc> just ask boegel he got 135
03:50:14 <Oejet> In the IQ test?
03:50:33 <samc> y
03:51:06 * Oejet looks at boegel
03:52:38 <TheHunter> my favorite permutation function: \n -> filter ((==n) . length) $ replicateM n [1..n]
03:53:01 <jlouis> basti_: the branches are choices
03:53:07 <basti_> do tell.
03:53:08 <basti_> =)
03:53:16 <boegel> what about me ?
03:53:20 <jlouis> there are n! permutations
03:53:27 <jlouis> each leaf is one such permutation
03:53:49 <jlouis> the branches are the choices you make to get down to such a permutation
03:53:56 <basti_> so what choices do you make?
03:53:58 <boegel> samc: that was an accident ! :p
03:54:01 <jlouis> x < y
03:54:17 <jlouis> it is the same argument that proves that you cannot sort faster thon O(n lg n) by comparisons
03:55:00 <samc> sure, you can't get out of it that easy, now you have to answer the tricky problems
03:55:13 * boegel scratches his hea
03:55:16 <jlouis> I have to go ;)
03:55:17 <boegel> +d
03:55:38 <boegel> I barely know what you guy are talking about
03:55:54 <boegel> what's a 'tree' ? :p
04:00:30 <basti_> boegel: uhm a tree is either a leaf, or a "branch" with one or more trees attached.
04:00:44 <boegel> basti_: I was joking :)
04:00:47 <basti_> ok.
04:01:14 <boegel> tree = boom, leaf = blad, branch = tak
04:01:17 <boegel> does that help :p
04:01:25 <basti_> no.
04:01:31 <basti_> =)
04:01:49 * boegel watches as his IQ takes a dive
04:08:22 <tromp> splits [] = [([],[])]
04:08:22 <tromp> splits xs@(x:xs') = ([],xs):[(x:a,as) | (a,as) <- splits xs']
04:08:22 <tromp> picks l = [x:(ls++rs) | (ls,x:rs) <- splits l]
04:08:22 <tromp> perms [] = [[]]
04:08:22 <tromp> perms l = [a:ps | (a:xs) <- picks l, ps <- perms xs]
04:08:56 <basti_> w0ha
04:09:13 <basti_> as i said, the problem is not as trivial as it looks.
04:09:31 <basti_> i couldnt solve it myself.
04:09:38 <basti_> in that time
04:09:49 <Philippa> oh joy
04:10:04 <TheHunter> fwiw:
04:10:07 <TheHunter> permute :: [a] -> [[a]]
04:10:07 <TheHunter> permute [] = return []
04:10:07 <TheHunter> permute xs = do
04:10:07 <TheHunter>   (y, ys) <- select xs
04:10:07 <TheHunter>   (y:) `fmap` permute ys
04:10:08 <TheHunter> select :: [a] -> [(a,[a])]
04:10:16 <TheHunter> select []     = []
04:10:18 <TheHunter> select (x:xs) = (x,xs) : second (x:) `map` select xs
04:10:50 <TheHunter> it's definitely easier than finding out how to play a video at half resolution with mplayer...
04:11:12 <basti_> the question is, what is more frustrating?
04:11:22 <Oejet> Thanks tromp and TheHunter.
04:13:50 <tromp> @index second
04:13:50 <lambdabot> Control.Arrow
04:16:29 <samc> what's joyous?
04:17:31 <Itkovian> hi
04:19:45 <tromp> stealing from thehunter's approach:
04:19:49 <tromp> picks [] = []
04:19:49 <tromp> picks l@(x:xs) = l:[a:x:as | (a:as) <- picks xs]
04:19:49 <tromp> perms [] = [[]]
04:19:49 <tromp> perms l = [a:ps | (a:xs) <- picks l, ps <- perms xs]
04:23:07 <Philippa> samc: my cable connection acting like dialup and dropping orders of magnitude more than my knickers
04:24:00 * TheHunter can't believe he wasted the last 20(!) minutes fighting mplayer.
04:24:04 <samc> oh
04:24:07 <samc> joy
04:24:35 <samc> sadly, I can believe it
04:24:58 <TheHunter> and i haven't even solved my problem in a reasonable general way.
04:24:59 <Lemmih> Isn't the mplayer man page pretty comprehensive?
04:25:24 <TheHunter> i have no idea how to navigate in that monster manpage
04:27:35 <ozone> TheHunter: try -xy 0.5
04:28:23 <TheHunter> hey, thanks ozone, that works
04:29:01 <ozone> TheHunter: all good
04:29:25 <TheHunter> must have missed that among the 100 occurrences of "scale" in that manpage.
04:33:54 <TheHunter> talking about permutations, it is notoriously difficult to write the function in such a way that it returns a "list" that doesn't cache the results.
04:34:34 <TheHunter> the following list type did it: data AList a = forall b. AL (b -> Maybe (a, b)) b
04:36:27 <Oejet> TheHunter: What do you mean by cache the result?
04:37:03 <TheHunter> middle xs = walk xs xs where
04:37:03 <TheHunter>   walk (_:_:ys) (_:zs) = walk ys zs
04:37:03 <TheHunter>   walk _ (x:_)         = x
04:37:41 <TheHunter> now middle $ perm [1..10] has a serious space leak, because one whole half of the list gets shared.
04:38:37 <TheHunter> in this case, (because computation of permutations is fast), you want to recompute it instead of sharing it.
04:41:02 <TheHunter> in sml, you can simply do datatype 'a llist = nil of unit | cons of 'a * (unit -> 'a llist), but that's not enough in haskell...
04:41:20 <esap> The AList type is very interesting. It somehow can pass values through the list.
04:42:24 <esap> I mean, the 'b' represents the whole lists state, in a sense.
04:43:23 <TheHunter> btw. data CList = CL (forall b. (a -> b -> b) -> b -> b) still caused sharing.
04:44:12 <TheHunter> nah, that one doesn't even have an efficient tail iirc.
04:45:45 * esap wonders what happens if you put in some access methods for 'b' in AList.
04:56:57 <Oejet> Good old SICP came up with:
04:57:00 <Oejet> perm [] = [[]]
04:57:00 <Oejet> perm s = concatMap (\x -> map (\p -> x:p) (perm (delete x s))) s
04:57:10 <Oejet> :-P
04:57:49 <jlouis> better than mine
04:57:53 <samc> SICP?
04:57:59 <jlouis> perms xs = accuperms xs [] []
04:57:59 <jlouis>   where accuperms []     tl res = tl:res
04:57:59 <jlouis>         accuperms (x:xr) tl res = cyc [] x xr tl res
04:58:05 <jlouis>         cyc left mid [] tl res = accuperms left (mid:tl) res
04:58:05 <jlouis>         cyc left mid (right@(r:rr)) tl res =
04:58:06 <jlouis>           cyc (mid:left) r rr tl (accuperms (left ++ right) (mid:tl) res)
04:58:15 <TheHunter> Oejet, that needs an Eq constraint, doesn't it?
04:58:18 <Oejet> Even faster. ;-)
04:58:46 <Oejet> TheHunter: Yes, in delete.
04:59:53 <Oejet> I didn't think about that because the applications is going to be with integers.
05:00:54 <jlouis> I do not know if mine is fast in Haskell. It shines on the MLs
05:01:07 <jlouis> strictness can play in here a great deal I assume
05:01:57 <TheHunter> SamB, http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start
05:02:15 <TheHunter> oops, that should've been samc, sorry
05:02:32 <samc> thanks
05:06:35 <Oejet> In GHCi: SICP 6.55s, tromp 7.30s, jlouis 1.56s.
05:06:56 <TheHunter> p n = filter ((==n) . length . nub) $ replicateM n [0..n-1]
05:07:03 <TheHunter> perms xs = map (map (xs!!)) (p $ length xs)
05:08:58 <Oejet> TheHunter: ...swapping...
05:09:24 <TheHunter> that wasn't meant to be fast...
05:09:36 <jlouis> haha
05:10:20 <jlouis> Ok, it is fast in Haskell too. I guess building up a tail is smart. Increases sharing opportunities
05:11:44 <TheHunter> thbot: @pointless perms xs = let p n = filter ((==n) . length . nub) $ replicateM n [0..n-1] in map (map (xs!!)) (p $ length xs)
05:11:47 <thbot> perms = id (flip (s ((.) . map . map . (!!)) (flip ($) . length)) (s ((
05:11:47 <thbot> ) . filter . flip ((.) . flip (==)) (length . nub)) (s replicateM (enumFromTo
05:11:47 <thbot> 0 . (- 1)))))
05:11:47 <thbot> optimization suspended, use @pl-resume to continue.
05:11:54 <TheHunter> thbot: @pl-resume
05:11:58 <thbot> perms = flip (s ((.) . map . map . (!!)) (flip id . length)) (s (filter
05:11:58 <thbot> . (. (length . nub)) . (==)) (s replicateM (enumFromTo 0 . (- 1))))
05:12:16 <Oejet> Well, it really needs to be compiled to be interesting.
05:12:37 <Oejet> TheHunter: You are half way to a Haskell obfuscator. :-P
05:13:01 <xerox> (!!) ?
05:13:19 <wli> Oejet: only if he had done it completely pointfree
05:14:41 <TheHunter> wli, you mean like church encoding all datatypes?
05:44:12 <Oejet> @pointless pfannkuchen n = maximum $ map (length . takeWhile (\(x:_)->x/=1) . iterate flipping)  (perm [1..n])
05:44:12 <lambdabot> Sorry, I don't know the command "pointless", try "lambdabot: @listcommands
05:44:12 <thbot> (line 1, column 56):
05:44:12 <thbot> unexpected "_"
05:44:12 <thbot> expecting natural, identifier or "("
05:52:53 <TheHunter> thbot: @pointless pfannkuchen n = maximum $ map (length . takeWhile (\(x:a)->x/=1) . iterate flipping)  (perm [1..n])
05:52:54 <thbot> pfannkuchen = maximum . map (length . takeWhile ((1 /=) . head) . iterate
05:52:54 <thbot> flipping) . perm . enumFromTo 1
05:54:46 <Oejet> TheHunter: Thanks!  It's an unoptimized version for http://shootout.alioth.debian.org/benchmark.php?test=fannkuch&lang=all&sort=cpu
05:57:39 * Oejet pets SICP
05:57:48 * shapr barks at SICP
05:58:17 <Oejet> My precious.
05:58:36 <Oejet> My own.
05:58:53 <Lemmih> Good morning, shapr.
05:58:57 <shapr> y0
05:59:08 <Lemmih> How's code?
05:59:18 <shapr> My thread is still sleeping.
05:59:53 <shapr> But if you ask me in a few Hertz, my context will have swapped in.
06:00:10 * basti_ gives shapr a bigger cache.
06:00:21 <shapr> Man, I wanted caSH!
06:00:22 * shapr snickers
06:00:28 <basti_> or a fsb boost (coffee)
06:01:21 <shapr> good idea
06:01:56 <Lemmih> You're in need of cash?
06:02:04 <shapr> no, just joking.
06:06:37 * Lemmih wonders why a C function can't return a function pointer.
06:08:13 * boegel boings
06:08:18 * shapr biffs
06:08:30 <ozone> Lemmih: mmm?  i'm sure it can
06:09:24 <basti_> Lemmih: it can?
06:11:36 <Lemmih> Well you can return a 'void*'.
06:11:52 <ozone> why can't you return a FuncPtr type?
06:12:01 <ozone> (just FuncPtrType, not FuncPtrType *)
06:12:05 <basti_> you can even return a void (*) or what a function pointer is a called.
06:12:37 <basti_> you just have to remember the wacko syntax for it
06:12:47 <basti_> void (*) () name() { } ?
06:14:16 <Lemmih> lisppaste2: url
06:14:31 <Lemmih> lisppaste2: please?
06:15:45 <Lemmih> basti_: parse error.
06:15:54 <basti_> i'll try
06:17:11 <Oejet> Lemmih: Returning a function pointer is exactly what GHC did one time, see the spineless-tagless-gmachine paper page 43.
06:18:09 <Lemmih> Oejet: And what was the type of that function?
06:18:43 <Lemmih> lambdabot: @wiki HaskellIrcPastePage
06:18:43 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:22:25 <Lemmih> My initial wondering was clearly misphrased.
06:22:47 <basti_> http://www.newty.de/fpt/fpt.html#chapter2
06:22:53 <basti_> 2.7
06:23:28 <basti_> pastebin?
06:23:42 <basti_> lisppaste2: ?
06:24:18 <Oejet> lisppaste2: url?
06:24:27 <basti_> lisppaste2: url?
06:24:30 * basti_ shrugs
06:25:10 <Lemmih> Ah. Goody.
06:25:33 <Oejet> http://paste.lisp.org/new/haskell
06:25:53 <basti_> Oejet: i found it myself but it doesnt respond
06:29:53 <basti_> hmm
06:30:11 <basti_> Lemmih: do you get it working yourself? lisppaste is striking apparently.
06:31:42 <basti_> Lemmih: http://paste.mine.nu/Pastebin/
06:31:44 <basti_> wah
06:31:54 <basti_> Lemmih: http://paste.mine.nu/tmp/GetPaste.aspx?paste=938501206516&header=true
06:32:11 <Lemmih> Not the typedef solution, but it doesn't really matter.
06:32:36 <basti_> typedef sucks anyway
06:33:40 <Lemmih> Now I know it can be done so that's another thing Hacanon should handle.
06:36:32 <Lemmih> wb xerox.
06:36:42 <xerox> hello
06:48:38 <samc> this is something I've never understood: why define concatMap when one can write concat . map ?
06:50:27 <jlouis> Why use list comprehensions when a mix of filter and map does the same?
06:50:32 <Lemmih> 'Cause 'concatMap' is shorter than '(concat . map)', perhaps.
06:50:37 <xerox> Two keypress less
06:50:49 <shapr> two more keypresses for IRC!
06:51:53 <jlouis> and maybe it is easier to comprehend when you have some longer expression. concatMap has a certain meaning. (concat . map) has to be scanned by the brain, understood and then put in the same box as concatMap
06:52:19 <xerox> I finished HaskellTutorial.pdf, but classes and instances are not so clear to me. Hmm, any suggestion about where can I find explanation of them?
06:52:40 <Lemmih> http://www.haskell.org/tutorial/
06:52:57 <samc> those reasons suck
06:53:20 <Lemmih> Why shouldn't there be a 'concatMap'?
06:53:25 <basti_> samc: you dont NEED to use concatMap
06:53:34 <basti_> samc: noone will force you.
06:55:46 <samc> perhaps because concatMap is bound absolutely tight?
06:57:10 <samc> though I still prefer (concat . map)
07:00:08 <samc> either give it a non-composite name or don't bother
07:02:24 <Lemmih> But if we did that, what would we complain about on IRC? (:
07:03:15 <xerox> About giving to (un)curry a descriptive name, instead of a lastname <grin>
07:05:34 <jlouis> does GHC employ polyvariant flow analysis transformations to inline individually at call sites?
07:09:37 <boegel> xerox: classes and instances are OO related stuff, right ?
07:10:18 <Lemmih> boegel: Nope. Not in Haskell at least.
07:10:32 <xerox> boegel, I think so
07:10:37 <xerox> whoops :-)
07:11:34 <jlouis> a class defines a number of values and functions which a given type must work on.
07:11:56 <jlouis> an instance is an implementation which defines how these functions and values look to the given type
07:12:31 <boegel> Lemmih: classes are kind of OO related, aren't they ?
07:12:33 <jlouis> The class Eq consists of all types that can be compared for equality. It defines the functions == (equal) and =/ (not equal)
07:13:18 <xerox> @info Eq
07:13:19 <lambdabot> -- Eq is a class
07:13:19 <lambdabot> class Eq a where {
07:13:19 <lambdabot>     (/=) :: a -> a -> Bool {- has default method -};
07:13:19 <lambdabot>     (==) :: a -> a -> Bool {- has default method -};
07:13:19 <lambdabot>     }
07:13:24 <Lemmih> boegel: I'm not very familiar with OO but type classes are nothing like classes in eg. C++.
07:13:26 <Heffalump> it consists of all types that someone has defined an Eq instance forone would hope that their Eq instance satisfies the normal laws, but one can't be sure :-)
07:13:28 <boegel> Lemmih: a class defition is kind of like an interface in Java, and an instance is a implementation of that interface...
07:14:18 <Lemmih> boegel: But are interfaces object oriented?
07:15:10 <xerox> Hmm, so what's the purpose of an Eq class? Can't I make an == function without it?
07:15:23 <jlouis> usethe term Type Class. Then you avoid confusion
07:15:41 <jlouis> xerox: the point is that == can become overloaded in definitions
07:15:44 <Lemmih> xerox: Sure you can, but overloading it would be a bitch.
07:16:07 <xerox> I think I understand
07:16:36 <xerox> It's like "(TypeClass a) => a" in functions type signatures?
07:16:55 <jlouis> yes
07:17:42 <jlouis> f :: a -> bool is a polymorhpic function where a can be anything.
07:18:16 <jlouis> f :: Eq a => a -> bool is also a polymorphic type, but the type of a is constrained to be only those types which are instances of the Eq class
07:18:48 <jlouis> meaning that you can use == and /= inside the function on the a type
07:19:14 <jlouis> (it doesn't make sense before it takes to a's like :: Eq a => a -> a -> bool)
07:20:14 <xerox> I think I managed it, nice.
07:21:43 <jlouis> You need to learn the basic ones: Ord is the type of ordering (< <= etc). Show is the type of output (they can be showwn in the interpreter) and Num is the type of numbers
07:21:48 <Lemmih> isSomethingReallyWrong a = a /= a
07:22:08 <boegel> Lemmih: I think so... it's a type of inheritance, which is very mutch OO related, no ?
07:22:35 <xerox> isSomethingReallyWrong :: forall a. (Eq a) => a -> Bool
07:23:11 <Lemmih> boegel: But Haskell doesn't support suptyping...
07:23:46 <xerox> So, if i create a data type that "overloads" == I should put it under some "instance Eq mytype where (==) ..." ?
07:24:18 <boegel> Lemmih: I know, it's not really subtyping... an interface isn't really a type, it's a specification
07:24:38 <jlouis> xerox: exactly
07:24:38 <boegel> and all types in a Haskell class respect that specification
07:25:07 <Lemmih> So where's the OO bits?
07:25:08 <xerox> jlouis, what if another datatype supports something other than what the class define?
07:25:23 <boegel> Lemmih: in Java: ClassX implements InterfaceX
07:25:35 <boegel> and ClassX extends ClassY (that's subtyping)
07:25:54 * boegel is confused...
07:25:55 <Lemmih> But there's no suptyping in Haskell (:
07:26:08 <boegel> I know, but interface's aren't subtyping :)
07:26:18 <boegel> inheritance was the wrong word i guess
07:26:23 <Lemmih> So where's the OO bits?
07:26:28 <boegel> I should've used 'specification' instead
07:26:46 <boegel> well, I only know interface from Java, which is OO, so I guessed it's OO related :)
07:27:23 <xerox> jlouis, I think I understood, I simply put those definitions *out* of "instance TypeClass DataType where ..."
07:27:54 <xerox> jlouis, and their signatures will not be TypeClass-depending but only DataType-depening
07:27:55 <Lemmih> boegel: I doubt the concept is OO-related.
07:29:27 <xerox> "type" is like an alias, right?
07:30:18 <autrijus> yeah. or a macro
07:32:53 <boegel> Lemmih: interfaces are Java's way of supporting multiple inheritance...
07:34:50 <jlouis> xerox: if some type supports more operations than what the instance defines it is no problem. But you can off course not use these extra functions in a Typeclass constrained function since other types might not have these extra functions defined
07:34:59 <jlouis> did that answer your question?
07:35:18 <boegel> Lemmih: http://www.toa.com/pub/OOBasics.pdf
07:35:25 <xerox> jlouis, yep!
07:35:39 <xerox> Thank you.
07:35:42 <boegel> Lemmih: check page 6
07:36:41 <Lemmih> How does that make typeclasses object oriented?
07:37:14 <Lemmih> Dude (: I don't care about the basics of OO nor Java.
07:38:02 <boegel> Lemmih: because type classes are the equivalent of interfaces
07:38:22 <Lemmih> Aren't they just similar?
07:38:42 <boegel> every type which is an intance of a class = every class which implements an interface
07:39:01 <boegel> Lemmih: I might be wrong, but I don't see the differences
07:39:35 <Lemmih> Why is that OO?
07:39:53 <boegel> because interface is an OO concept (see the pdf)
07:41:32 <Lemmih> Let's forget about Java interfaces for a moment. Now tell me why typeclasses are an OO concept?
07:42:43 <boegel> because they hide the implementation of the functions ?
07:43:24 <boegel> if you know a type in an instance of a class, the defition of that class is enough to know which functions are available for that perticular class
07:43:28 <arjanb> implementation hiding isn't a OO concept
07:43:29 * boegel might be wrong
07:43:44 <boegel> information hiding is, isn't that almost the same ?
07:46:08 * boegel starts cleaning up the mess he made last night
07:46:34 <autrijus> @wiki TheMonadReader
07:46:34 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
07:46:37 <autrijus> @seen shapr
07:46:38 <lambdabot> shapr is in #haskell.se and #haskell.
07:48:44 <shapr> ?
07:50:11 <boegel> haai
07:50:14 <shapr> autrijus: you called?
07:50:31 <TheHunter> type classes and OO interfaces are quite different.
07:50:46 <boegel> TheHunter: can you explain me why ?
07:50:58 <autrijus> shapr: I added a link to http://creativecommons.org/licenses/by/2.0/ to TMR wiki page. also, when is the deadline for 1st issue again? can't find it in precide date format on the wiki page
07:51:07 <TheHunter> first of all:
07:51:10 <TheHunter> @wiki WikiSandBox
07:51:11 <lambdabot> http://www.haskell.org/hawiki/WikiSandBox
07:51:35 <TheHunter> the proper analogon to java interfaces are existential types.
07:51:44 <boegel> autrijus: 1st of March, it's on the wiki
07:52:00 <boegel> autrijus: see "Timeline"
07:52:07 <shapr> autrijus: register definite interest and subject by the end of the first week of the month (tomorrow), have the code and pix in shae's hands by three weeks into the month, release on the 1st of every month.
07:52:20 <autrijus> boegel: the submission deadline I meant.
07:52:30 <shapr> autrijus: this timeline is totally arbitrary, and may be adjusted drastically after the first issue.
07:52:37 <autrijus> shapr: okay, got it.
07:52:45 <autrijus> so I have 14 days to write about it?
07:52:45 <TheHunter> boegel, type classes give default operations for each type, interfaces give you as many implementations as you want, but you always have to explicitely pass the interface around
07:52:48 <autrijus> ok, I'm game.
07:53:02 <boegel> autrijus: oh, I think one week in advance
07:53:28 <shapr> autrijus: I'd like to see some actual content before the real submission deadline, but hey, whatever works for you.
07:53:45 <autrijus> shapr: ok. an abstract good enough?
07:53:49 <boegel> TheHunter: oh, I see
07:53:50 <shapr> yeah, that's cool.
07:54:07 <autrijus> ok. will do an abstract tonight
07:54:10 <shapr> excellent.
07:54:31 <TheHunter> it's ok if I move Darius' SandBox text to it's own page, isn't it?
07:54:33 <shapr> I'll read up on CC
07:54:39 <Lemmih> Time to unicycle!
07:54:54 <autrijus> the CC is sort of de facto for text works if you don't want GFDL.
07:55:03 <shapr> TheHunter: if it says sandbox, you can do whatever you want.
07:55:25 <jlouis> Do you juggle too lemmi?
07:55:34 <jlouis> +h
07:55:36 <shapr> Hm, maybe it is time to unicycle.
07:55:44 <Lemmih> jlouis: Actually I do.
07:56:01 <jlouis> heh ;)
07:56:06 <Lemmih> jlouis: I also play with devel sticks.
07:56:12 <TheHunter> shapr, i recall him asking wheter it should be named UnderestimatedTypeClasses or UnderEstimatedTypeClasses.
07:56:15 <jlouis> I am lousy. I only play with clubs these days
07:56:26 <shapr> jlouis: who do you beat up on?
07:56:45 <autrijus> "under estimated type classes" ?
07:56:47 <boegel> TheHunter: my promotor suggested me I should use type classes in my raytracer program
07:56:50 <shapr> TheHunter: Do what you think is best.
07:56:52 * jlouis passes 3 clubs to shapr
07:57:03 * shapr ends up bruised and bloody on the floor.
07:57:14 <jlouis> ow, you don't juggle clubs?
07:57:21 * boegel gives shapr some water to recover
07:57:27 <jlouis> 'sorry 'bout that
07:57:28 <shapr> Actually, I can pass balls while juggling three, but I've never tried juggling clubs.
07:57:44 <shapr> I learned ball passing from Alistair Cockburn of all people.
07:57:58 <TheHunter> shapr, ok, i like the text, i'll just make it an artical so that it gets the attention it deserves.
07:57:59 <shapr> hoi Zkyhawk 
07:58:05 <Lemmih> Juggling clubs is _a lot_ harder than balls, IMHO.
07:58:05 <shapr> TheHunter: good idea
07:58:26 * Lemmih can't even do it while unicycling.
07:58:27 <shapr> Lemmih: bring some to EuroHaskell ;-)
07:58:37 <shapr> Zkyhawk: learning Haskell?
07:58:47 <jlouis> clubs is much much fun than balls. 
07:58:53 <jlouis> much more
07:59:03 <jlouis> I do not hope I code the way I type
07:59:07 <shapr> Zkyhawk: hey, do you know John Tromp?
07:59:37 <shapr> jlouis: you're coming to EuroHaskell?
07:59:42 <boegel> TheHunter: I currently use an ObjType to show the available objects my raytracer supports
08:00:03 <boegel> TheHunter: my promotor suggest using a type class 'class IsObject a where ...'
08:00:37 <TheHunter> boegel, yeah, that makes sense
08:00:40 <Lemmih> shapr: I definitely will (: *puff* and lemmih is away on his uni.
08:01:29 <boegel> TheHunter: so you agree using a type class is better than using the ObjType ?
08:02:06 <jlouis> shapr: wheres EuroHaskell?
08:02:26 <shapr> Gothenburg
08:02:33 <shapr> gÃ¶teborg, om du talar svenska
08:03:00 <shapr> vet inte om det Ã¤r samma i dansk
08:03:02 <xerox> Can someone expand in english this line? "class (Objects o) => Databases d o where ..."
08:03:19 <autrijus> shapr: where do I sign up and paste link to abstracts?
08:03:22 <TheHunter> boegel, i don't know your code, but it's probably quite a good match for type classes.
08:03:30 <autrijus> I only see "issue 2" on the wiki page
08:03:48 <boegel> TheHunter: ObjType = Sphere ... | Plane ...
08:03:48 <shapr> autrijus: do you want to sign up for issue 1 or 2?
08:04:03 <autrijus> 1
08:04:09 <boegel> TheHunter: and then I provide functions like intersectRayWith and getNormalAt
08:04:10 <shapr> apocrypha =)
08:04:14 <autrijus> yup :)
08:04:25 <boegel> TheHunter: I could put those functions in a type class
08:04:46 <shapr> autrijus: well, put yourself under definite authors.
08:04:54 <boegel> TheHunter: the only problem is: he suggested me this option partially because he sees it as OO in Haskell
08:05:04 <shapr> obviously that page needs cleaning. the issue 2 part is confusing.
08:05:10 * shapr blames the author
08:05:25 <shapr> and the author will come back and fix it after unicycling....
08:05:28 <shapr> where's my helmet...
08:09:02 <TheHunter> boegel, hmm, i'm not so sure anymore.
08:10:01 <TheHunter> boegel, a scene consist of a list of object, right?
08:10:27 <TheHunter> with type classes, you'd have to mess around with existentials, if you want to make a list of your objects.
08:10:35 <boegel> a scene consists of a list of objects, among other things (list of lights, a camera, ...)
08:10:47 <boegel> TheHunter: how's that ?
08:11:11 <jlouis> shapr: when is EuroHaskell?
08:11:22 <jlouis> Goeteborg is not far from here, really
08:11:28 <boegel> oh, I see, because there no 'objType' anymore
08:11:38 <boegel> Object = (ObjType,Material)
08:11:46 <TheHunter> yeah.
08:11:49 <boegel> so I wouldn't be able to use that anymore...
08:11:50 <boegel> I see
08:12:33 <jlouis> You need existensial types then boegel 
08:12:44 * boegel looks into them
08:12:51 <jlouis> that is not Haskell98 though
08:12:58 <TheHunter> i say, keep it the way it is.
08:13:00 <jlouis> theres something on the wiki about them
08:13:08 <jlouis> I agree with TheHunter
08:13:16 <boegel> oh... so it's only GHC ? or what does 'not Haskell98' imply ?
08:13:36 <TheHunter> hugs -98 or ghc -fglasgow-exts
08:15:00 <boegel> I should meet up with him next week orso, to show my progress with the parser and GUI...
08:15:09 <boegel> I'll talk to him about this..
08:15:43 <jlouis> good idea. Mention that you will need to break Haskell98 standardisation by doing it
08:16:23 <boegel> I will..
08:16:34 <boegel> he made me some other suggestions too, but I have to go now...
08:17:11 <boegel> I'll be back within an hour orso, I hope I can talk to you guys about some of the other suggestions he made too
08:22:18 <TheHunter> see ya, boegel 
08:41:44 * Lemmih has returned without food.
08:57:39 * boegel has returned with a hot pizza :)
09:01:18 <boegel> TheHunter: still active ?
09:08:54 <TheHunter> boegel, yep
09:10:39 <boegel> TheHunter: the reason he suggested type classes for my ObjType type, is because when a user adds an extra ObjType (say Cube), he won't get warned at compile time when he forgets to implement a function needed by the new type (getNormalAt, intersectRayWith)...
09:10:53 <boegel> do you have any idea how I can fix this without using type classes ?
09:11:28 <autrijus> this problem is the problem type classes are designed to solve.
09:11:34 <autrijus> so good luck without using it :)
09:11:51 <boegel> hmmz :s
09:12:05 <TheHunter> boegel, data ObjType = Sphere | ... | UserDefined {
09:12:08 <TheHunter>   op1 :: ?
09:12:13 <TheHunter>   op2 :: ?
09:12:14 <TheHunter> ...
09:12:14 <TheHunter> }
09:12:28 <TheHunter> where op1, op2 are the operations a user needs to define.
09:12:33 <TheHunter> brb
09:12:49 <boegel> hmm... so UserDefined is a keyword ?
09:13:01 <autrijus> it's a type constructor.
09:13:02 <boegel> or just a label ?
09:13:08 <autrijus> you may name it WhateverYouWant.
09:13:14 <boegel> hmm, okay
09:13:52 <boegel> but how does that help when I would adjust it like this : data ObjType = Sphere | Plane | Cube | UserDefined { ... } 
09:14:24 <boegel> when there are no functions defined for the 'Cube' type, the compiler will complain ?
09:14:44 <boegel> or is this meant to allow the user to add an extra ObjType during runtime ?
09:14:51 <autrijus> yes.
09:15:36 <shapr> mmmm, pizza
09:15:39 <shapr> I wish
09:15:39 <boegel> autrijus: which one ? the latter ?
09:15:50 <autrijus> the latter.
09:15:51 <autrijus> bbiab.
09:16:16 <boegel> autrijus: then that doesn't solve my problem :)
09:16:24 <autrijus> yeah :)
09:16:29 * autrijus purrs.
09:19:40 <TheHunter> back
09:20:49 <boegel> TheHunter: see the above :)
09:21:39 <TheHunter> boegel, first of all, ghc -Wall will emit a warning if a function defined by pattern matching doesn't have an exaustive list of patterns.
09:22:01 <boegel> oh, that's nice
09:22:23 <boegel> so there's no need for the UserDefined option ? or is there?
09:22:53 <TheHunter> the other suggestion I made was for every function you need to be defined in your raytracer, you could put a destructor of that type into UserDefined:
09:23:02 <TheHunter> data ObjType = ... | UserDefined {
09:23:43 <TheHunter>   udGetNormalAt :: type of getNormalAT,
09:23:45 <TheHunter> ...}
09:24:15 <TheHunter> and then getNormalAt foo@(UserDefined {}) = udGetNormalAt foo,
09:24:32 <TheHunter> or similar.
09:24:58 <boegel> and how does that destructor help me ? (I don't know the concept)
09:26:16 <TheHunter> if the user (assuming your raytracer is a library) wants to give a new object, he can simply do
09:26:24 <TheHunter> myObj = UserDefined {
09:26:49 <TheHunter>   udGetNormalAt = ... (the definition of getNormalAt the user wishes to use for his object)
09:26:50 <TheHunter> }
09:27:16 <boegel> whyis it called destructor then ?
09:27:28 <TheHunter> @wiki FunctionsNotDataStructures
09:27:29 <lambdabot> http://www.haskell.org/hawiki/FunctionsNotDataStructures
09:27:41 <TheHunter> @wiki ChainOfResponsibility
09:27:41 <lambdabot> http://www.haskell.org/hawiki/ChainOfResponsibility
09:28:05 <TheHunter> data Foo a = Foo { unFoo :: a }
09:28:28 <TheHunter> the type of unFoo is unFoo :: Foo a -> a, so it "destructs" a Foo.
09:28:54 <TheHunter> that's why I called it destructor (not sure if this is standard terminology, though)
09:29:03 <boegel> oh, I see
09:29:08 <boegel> hmm, quite interesting
09:29:23 <Philippa_> deconstructor's probably more accurate in a functional setting, but hey
09:29:49 <TheHunter> thanks, Philippa_, that's the word i was searching for.
09:31:18 <boegel> okay, deconstructor then
09:31:29 <tautologico> unwraps, no ?
09:31:43 <tautologico> Foo is a wrapper, unFoo unwraps
09:32:01 <TheHunter> tautologico, i'd use "unwrap" for newtypes.
09:32:02 * boegel is confused :)
09:34:55 <TheHunter> that's what makes haskell so great for prototyping: don't think about which datatypes something to represent with, just use the types of the operations you want to support.
09:36:33 <boegel> TheHunter: can you elaborate ?
09:38:17 <TheHunter> like in the FiniteMap example on ChainOfResponsibility. You want something that can lookup a value, so you can just use newtype Map k v = Map { lookup :: k -> Maybe v }.
09:39:28 <TheHunter> it might not be the fastest possible implementation, but it's often remarkably good, and you can implement your stuff in almost zero time.
09:40:16 <TheHunter> see for example, http://haskell.org/papers/NSWC/jfp.ps
09:42:30 <TheHunter> then you have:
09:42:41 <TheHunter> empty = Map $ const Nothing
09:43:11 <TheHunter> Map l `union` Map l' = Map $ liftM2 mplus l l'
09:43:29 <boegel> TheHunter: there's no need to repeat 'lookup' ?
09:43:58 <TheHunter> what do you mean?
09:44:19 <boegel> well, you say empty = Map $ const Nothing
09:44:43 <boegel> I would do empty = Map $ lookup  = ...
09:44:47 <boegel> or something like it
09:45:16 <TheHunter> no either one of Map (const Nothing) and Map { lookup = const Nothing } is fine.
09:45:54 <boegel> oh okay
09:46:12 <boegel> but when Map has two functions, the first one wouldn't work anymore, would it ?
09:46:23 <TheHunter> sure it would
09:46:38 <boegel> Map (const Nothing) (... ...) ?
09:46:42 <TheHunter> data Foo a = Foo { foo1 :: a, foo2 :: a }
09:46:51 <TheHunter> foo = Foo 3 4
09:46:57 <boegel> oh okay
09:47:00 <boegel> I see
09:47:02 <TheHunter> or foo = Foo { foo1 = 3, foo2 = 4}
09:47:36 <TheHunter> the only thing that doesn't work is Map { lookup _ = Nothing }, which is a pity.
09:47:43 <boegel> okay, I'll push all this in front of my promotor's nose, and see how he replies
09:48:21 <boegel> TheHunter: I have to go now, thanks you very mutch for your help :)
09:48:36 <TheHunter> bye
09:48:47 <Cale> There are some places where the syntax sugar could be more convincing :)
09:49:19 <Cale> especially with records
09:54:13 <TheHunter> Cale, what do you suggest?
09:54:42 <Cale> Well, what you mentioned would be nice
09:54:59 <TheHunter> especially in connection with pattern matching.
09:55:14 <TheHunter> commas should be semicola, i guess.
09:55:21 <TheHunter> where should be allowed.
09:55:38 <TheHunter> yep, there are a few things that come up immediately.
10:14:52 <jlouis> is it ambiguity problems?
10:16:55 <TheHunter> jlouis, why would that be ambigous?
10:17:07 <jlouis> I don't know the grammar. 
10:17:11 <jlouis> I am just asking
10:42:52 <heatsink> Strange -- xemacs says that getLine :: IO Char
10:49:02 <jlouis> that is odd
10:51:34 <xerox> GNU/Emacs here says getLine :: IO String
10:56:28 <jlouis> :type in hugs agrees with xerox
10:56:42 <jlouis> and I agree with :type in hugs, so by transitivity...
10:56:52 <xerox> jlouis, eh eh!
10:57:28 <xerox> jlouis, maybe he refers to the minibuffer string that appears when you edit some .hs file and type "getLine" standing with the cursor to the end of the word, for some secs
10:58:23 <heatsink> yes, that's what I'm talking about
10:59:03 <jlouis> xemacs is woring, but why?
10:59:04 <jlouis> wrong
10:59:10 <heatsink> no idea
10:59:34 <heatsink> What is the function to convert an Int to a Float?
11:00:02 <Lemmih> fromIntegral
11:00:33 <heatsink> thx
11:02:26 <jlouis> I really begin to like Haskell. The STG-machine running GHC seems quite clever
11:02:40 <xerox> What's a "STG-machine" ?
11:03:13 <wli> Spineless Tagless Goteborg machine.
11:03:27 <xerox> Hm :)
11:04:39 <heatsink> what does Goteborg mean?
11:04:49 <Oejet> xerox: Look down in http://haskell.org/ghc/documentation.html
11:05:03 <autrijus> Pugs 6.0.0 uploaded to CPAN. :)
11:05:07 <wli> Goteborg is a city in Sweden or some such.
11:05:07 <Oejet> heatsink: Göteborg is a Swedish town.
11:05:14 <heatsink> ok
11:05:23 * autrijus lured quite nearly a dozen perl hackers into installing GHC today. more to come :)
11:05:31 <heatsink> hee!
11:06:18 <Oejet> heatsink: Göteborg is home to Chalmars Technical University which employs a.o. John Hughes.
11:06:45 <heatsink> How come this prints "Name:" _after_ reading input?
11:06:46 <heatsink>  do {putStr "Name:"; name <- getLine}
11:06:53 <heatsink> uh
11:06:56 <wli> Lennart Augustsson is there, no?
11:06:57 <heatsink>  do {putStr "Name:"; name <- getLine; return ()}
11:07:00 <Oejet> heatsink: Because of buffering.
11:07:18 <heatsink> I should flush, then?
11:08:12 <xerox> Oejet, what does a.o. mean?
11:08:32 <Philippa_> that, or change the buffering mode
11:08:51 <Philippa_> IIRC the default's line - so a putStrLn would work
11:08:52 <xerox> Like in hSetLineBuffering
11:09:16 <heatsink> ok, since it's a small program I inserted flushes.
11:09:47 <Oejet> hSetBuffering stdout LineBuffering
11:10:06 <Oejet> xerox: Among others.
11:11:41 <xerox> whoops, sorry.
11:13:16 <heatsink> great, my program seems to work now.
11:18:03 <jlouis> xerox: amongst others
11:18:06 <jlouis> bleh
11:18:10 <jlouis> Oejet is too fast
11:18:17 <xerox> :)
11:20:39 <xerox> My math book is kinda wrong, I think. It says if f : A -> B and g : B -> C the function : A -> C is g o f
11:20:43 <xerox> isn't it f o g ?
11:21:19 <xerox> (where o is composition)
11:21:40 <Oejet> xerox: Nope. (f o g)(x) = f(g(x)).
11:22:32 <jlouis> xerox: Some math books defines f o g to be the other way around, eg g(f(x))
11:23:00 <jlouis> so you have to look the definition up or figure it out based on the domains and codomains
11:23:01 <xerox> What's the correct one? I'm a bit lost, I'm "used" to Haskell's composition
11:23:18 <jlouis> the ``correct'' one is the one you define it to be
11:23:33 <xerox> damn book :) Okay.
11:23:38 <jlouis> I think theres a greater amount of authors who use f o g = f (g(x))
11:24:58 * heatsink wants to use lowercase letters as infix operators in haskell!
11:25:03 <heatsink> ;)
11:25:26 <xerox> Book says (f o g)(x) = g(f(x)), okay..
11:39:22 <pesco> xerox: (fâˆ˜g)(x) = f(g(x)) !
11:39:53 <pesco> Oh.
11:39:56 * pesco reads the backlog.
11:40:45 <xerox> :-)
11:41:06 <pesco> I just want to use unicode operator characters in Haskell!
11:41:23 <CosmicRay> pesco: evil
11:41:27 <pesco> CosmicRay: good
11:41:32 <CosmicRay> heh
11:41:34 <Oejet> That would be sooo cool.
11:41:36 <xerox> It would be nice :)
11:41:38 <CosmicRay> nonono
11:41:46 <CosmicRay> geez what are we becomming, perl? :-)
11:41:56 <xerox> hmpf.
11:41:57 <CosmicRay> can't we use things that a standard keyboard has? :-)
11:42:06 <pesco> My keyboard has âˆ˜.
11:42:14 <xerox> Square? ihih.
11:42:36 <pesco> Well, I've mapped a bunch of important operators and symbols onto my keyboard.
11:43:00 <Oejet> ¤£%¾½
11:43:40 <pesco> I especially enjoy Â­, -, and â€”. :)
11:43:46 * xerox waits for pesco's Unicode-Haskell-keyboards
11:44:00 <pesco> xerox: I can send you my xkb map...
11:44:51 <xerox> pesco, not a bad idea, but what is it useful for?
11:45:08 <pesco> With Â­ (HYPHEN) you could finally have names with, well, hyphens in them.
11:45:20 <pesco> Like lisp has. I think that's prettier than _.
11:45:41 <xerox> Can you make an ASCII art of hypen? Isn't it ` right?
11:45:43 <xerox> :)
11:46:26 <pesco> xerox: I actually have a little preprocessor that maps a bunch of unicode characters to either ascii art or _uABCD codes or something.
11:46:53 <pesco> Think â†’ and Î» all over the place.
11:47:04 <xerox> Squares again.. :)
11:47:18 <pesco> Hm, I think I'd avoid them.
11:47:29 <pesco> Anyway, I gotta go.
11:47:31 <xerox> Maybe it's only my Emacs
11:47:33 <pesco> See you
11:47:34 <xerox> bye bye!
11:52:26 * shapr lags horribly
11:52:57 <shapr> wow, lag of  2112 seconds??
11:53:37 <xerox> piiiiiiiiiii.... ... .. ...ng!
11:53:40 <shapr> hello
11:53:56 <xerox> ^_^
11:58:45 <Spark> so
11:59:13 <Spark> unification in a beta= type system is equivlent to normalisation
11:59:16 <Spark> yes, no?
12:00:05 <Spark> if so, which reduction strategy does it use
12:23:05 <shapr> Is there a word for a cutesy tricksy advertising name that that binds up an idea into a cute package for easy transport?
12:23:11 <shapr> It's not meme, not really.
12:23:40 <shapr> asmodai: have you written any Haskell lately?
12:25:38 <Philippa_> shapr: mnemonic? Slogan?
12:25:42 <shapr> hm
12:26:00 <shapr> I've been trying to describe the real power of HaskellDB by calling it a database UNwrapper.
12:26:35 <shapr> what would you call 'database unwrapper' ?
12:28:07 <shapr> I guess it's an idvert
12:28:13 <shapr> idea + advert
12:29:57 <Spark> buzzword?
12:30:04 <shapr> hm, maybe so...
12:30:20 <shapr> yeah, that's pretty good, thanks!
12:33:35 * Lemmih curses his own inability to concentrate.
12:33:45 * shapr forgets to curse his .. what?
12:35:54 <Lemmih> I've figured out exactly how to handle callbacks in Hacanon but I just can't hack the finishing code /-:
13:08:01 * boegel boings
13:08:11 * shapr bounces
13:11:11 * boegel missed duncan :s
13:11:26 <boegel> he told me he has a windows build for gtk2hs
13:11:36 <boegel> I would like to try it, but I guess he's off
13:15:43 <shapr> suck, RSS advertising :-/
13:18:29 <boegel> what is RSS actually ? I've seen it on websites and stuff, but what is it ?
13:18:50 <stepcut> boegel: an xml document :)
13:18:51 <tic_> recent postings, basically.
13:19:08 <tic_> answer(stepcut) U answer(tic)
13:20:02 <stepcut> tic: don't you think an intersection might be more accurate ?
13:20:18 <tic_> No, that'd be Ø
13:20:29 <tic_> you'd want "an XML document with recent postings"
13:21:02 <tic_> but I guess that depends on how you define "recent postings", "xml document" and "intersection" in this case. :)
13:21:41 <stepcut> um
13:21:42 <_Codex> tic: intersection is something defined in category theory.
13:21:59 <tic_> _Codex, I thought it was defined in set theory.
13:22:08 * stepcut was just looking for where 'xml documents' and 'recent postings' overlap...
13:22:19 <tic_> stepcut, hrm, good point.
13:22:20 <boegel> and why is it used ? to report recent changes to visitors ?
13:22:30 <_Codex> tic: yes.
13:22:33 <tic_> boegel, yeah. so they don't have to visit the site.
13:22:34 <stepcut> boegel: you view it in your rss reader
13:22:47 <boegel> hmm, kay
13:22:57 <tic_> boegel, and you can "syndicate" many RSS "feeds" on one page, so you needn't go to each page to see what's new.
13:23:04 <tic_> boegel, like http://beclan.org/aggregator
13:23:11 <stepcut> boegel: so instead of having to go to 20 different websites every morning too see if there are any updates, you run one program, and it gets the latest 'headlines' from the sites you read
13:23:25 <jlouis> for instance, firefox allows your bookmarks to have a fold-out window which shows the recent changes
13:23:34 <jlouis> quite effective
13:23:46 <boegel> nice, very nice
13:24:04 <boegel> e\/01ut10n
13:24:18 <shapr> On the downside, it's fragmented. RSS 0.9, 1.0, 2.0, Atom...
13:24:45 <shapr> On the good side, it may replace email.
13:25:20 <stepcut> RSS feeds are also a pull mechanism -- so instead of signing up for a mailing list which you may never be able to unsubscribe from -- you just add the RSS feed to your reader, and when you get bored of the content, you just delete the entry
13:25:39 * shapr is a BIG fan of pull
13:25:49 <lightstep> tic_: is BeOS any good?
13:26:01 * lightstep just read lots of backlog
13:26:21 <tic_> lightstep, yeah. extremely light-weight, very easy to understand the architecture, compact & easy-to-use API and highly extensible.
13:26:36 <lightstep> and it runs on linux? :)
13:26:40 <tic_> err, no.
13:26:46 <tic_> linux is teh suck
13:26:51 <shapr> Does OpenBeOS boot yet?
13:27:12 <tic_> yeah, sure. There's even a Haiku HD-image floating around with the latest stuff from the middle of january
13:27:17 <tic_> just lacks the app_server :)
13:27:24 <tic_> but registrar is working, so you can run basic beos apps.
13:27:31 <shapr> What's app_server?
13:27:33 <tic_> has a tty layer and all.
13:28:06 <tic_> it's what's taking care of communication between native (i.e., non-posix) BeOS applications (BMessage, the IPC stuff), as well as doing the graphics stuff.
13:28:22 <shapr> Oh. I want to try it when the graphics stuff works.
13:29:10 <tic_> yeah. Right now, app_server is developed by linking regular BeOS applications against libhaiku.so instead of libbe.so, and then running the haiku app_server in a window.  When you run the application (in BeOS), it displays in the haiku app_server window. :))
13:29:17 * boegel spots the 'gtk2hs win2 build' on the gtk2hs mailinglist and cheers
13:29:31 <tic_> That'd be how the haiku app_server is tested, rather.
13:30:08 <shapr> I'd like to try other open source OSes, but I want more than a tty on my desktop.
13:30:19 <tic_> shapr, so get BeOS right now. 
13:30:28 <tic_> Haiku R1 == BeOS R5, anyway
13:30:29 <lightstep> or use Squeak
13:30:35 <shapr> BeOS is open source?
13:30:56 <tic_> shapr, nope.  But the aims of Haiku R1 is to re-create R5 as closely as possible.
13:30:58 <shapr> Squeak isn't really an OS :-)
13:31:07 <tic_> shapr, and then use that as a foundation for extending the OS.
13:31:08 <xerox> I like the bunny!
13:31:10 <xerox> ;)
13:31:51 <tic_> shapr, so there's really no difference in using BeOS R5 and Haiku R1 (when it's done) in the beginning.
13:32:20 <shapr> Except that I'm an open source fanatic, who refuses to have closed source software when I have any choice at all.
13:32:29 <tic_> Yeah.  Of course.
13:33:00 <shapr> I wish I could set a callback somewhere that would send me email when OpenBeOS has graphics.
13:33:06 <tic_> But -right now-, you can use BeOS R5, and replace input_server, media kit, mail kit and translation kit with their Haiku counterparts and use a mostly open-source OS :)
13:33:13 <tic_> shapr, it has graphics. But not a desktop. :)
13:33:39 <tic_> the nice part about BeOS' modularity is that you can swap out "kits" with affecting the rest of the OS.
13:33:46 <tic_> (having only one API and all..)
13:33:47 <shapr> Enough graphics to run something like Ion3?
13:33:54 <tic_> Not really. ,)
13:34:04 <shapr> That's my callback point.
13:34:11 <tic_> by the way, they've changed name to Haiku now.
13:34:13 <sh10151> GNUStep
13:34:19 <sh10151> try that :)
13:34:22 <tic_> shapr, #haiku, should you be interested.
13:34:27 <shapr> ok, thanks.
13:34:39 <shapr> I'll get around to doing a survey of open source OSes for my blog at some point.
13:34:51 <tic_> great idea.
13:35:02 <tic_> lemme know, I can point you to the right resources with regards to BeOS.
13:35:07 <tic_> shapr, http://darkwyrm.beemulated.net/images/drawview.png
13:35:18 <shapr> neat
13:35:37 <tic_> yeah, not too bad. that's in BeOS.
13:36:25 <tic_> http://darkwyrm.beemulated.net/images/windowcomparison.png <-- left all Haiku code, right all BeOS code. Kinda funny :)
13:36:57 <shapr> In other open source OS news, I heard that the GNU OS is giving in to Machiavellian politics. Ok really, it's finally started working with the L4 kernel.
13:37:09 <tic_> yay.
13:37:31 <tic_> good idea. isn't hurd/mach suckage, anyway?
13:37:43 <shapr> I guess the pun between machiavellian and L4 isn't too stratospheric?
13:37:52 <tic_> it is :|
13:37:58 <shapr> Oh well.
13:38:14 <tic_> More info about Haiku. Then I'll stop punish you. http://openfacts.berlios.de/index-en.phtml?title=Haiku
13:38:20 <shapr> I dunno if it's suckage or not. I've seen a lot of recent discussion about exokernels on LtU, and now I'm curious.
13:38:35 * shapr has filled his Haiku quota for the day.
13:38:46 * tic_ is happy with modular monolithic kernels. :)
13:39:45 <shapr> My latest crazy thought is wonderment as to whether exokernels could get the best of both worlds using the pure STArray trick.
13:40:21 <shapr> Like, use the exokernel setup to get all the guarantees, and optimize after the fact into something more like a monolithic kernel.
13:41:04 <shapr> On the other hand, maybe hOp is that same thing.
13:42:50 <shapr> aanyway, I should get back to work.
13:46:47 * boegel sings "Go shapr , go shapr , ..."
13:47:44 * stepcut tries to figure out if the monolithic linux kernel is broken in regards to cd burning or not
13:50:47 <lightstep> what is the difference between (strong, type-safe) state threads and the (weak, user-space) state monad?
13:57:37 <dons> moin
13:57:49 <boegel> hey d
13:57:52 <boegel> +ons
13:58:13 * boegel 's tab completion failed on him
14:02:10 <dons> hehe
14:09:07 <boegel> hey humasect 
14:10:42 <humasect> hey =)
14:13:18 <boegel> hey kuribas 
14:14:18 <kuribas> boegel, hi
14:14:30 <boegel> hey edwinb 
14:14:38 * boegel is pulling a "hello" streak
14:14:55 <boegel> y0 Philippa 
14:15:00 <basti_> come on boegel! one more!
14:15:00 <basti_> lol
14:15:01 <Philippa> evenin'
14:15:05 <basti_> hi Philippa 
14:15:11 * Philippa is lying in bed next to a presumedly-frustrated b/f
14:15:24 <basti_> and then youre chatting?
14:15:28 <boegel> Philippa = f ?
14:15:50 <edwinb> hi
14:15:54 <anyone> Philippa = t
14:16:08 * boegel frowns
14:16:16 <basti_> f(phillippa) in predicate notation.
14:16:35 <anyone> f = false, t = true, Philippa = true
14:16:57 <lightstep> F Philippa in haskell notation
14:17:10 * boegel tries again
14:17:14 <boegel> Philippa = female ?
14:17:20 <Philippa> yes
14:17:28 <boegel> oh, /me didn't know
14:17:40 <Philippa> hence the female name. I mean really, what's the point of crossdressing my nick in a coding chan?
14:17:49 <basti_> i would not call this equal.
14:17:57 <araujo> i thought Philippa was unisex
14:18:04 <anyone> haha
14:18:15 <boegel> *a doesn't mean female...does it ?
14:18:20 <Philippa> yes
14:18:23 <basti_> sexy_chick_17 would have been definitely female.
14:18:31 <boegel> basti_: watch it :)
14:18:31 <araujo> :-P
14:18:40 <Philippa> no, sexy_chick_17 is a 40 y/o fat guy :-)
14:18:46 <boegel> 50 !
14:18:52 <anyone> sexy_chick_17 would be definitely the 17th lier.
14:18:55 <anyone> err liar.
14:19:05 <sexy_chick_17> omg
14:19:17 <basti_> actually this mechanism is very useful
14:19:21 <hot_and_handsome> hey sexy_chick_17 
14:19:25 <basti_> for example when you need something quick.
14:19:41 <sexy_chick_17> hot_and_handsome: your hello streak is /so sexy/
14:19:56 <hot_and_handsome> sexy_chick_17: I'm _so_ hot
14:19:58 <dons> this is nuts
14:20:14 * edwinb wonders which channel he's wandered onto by mistake ;)
14:20:28 <boegel> dons: this happens on some channels though...
14:20:35 <anyone> Yes people use sexy nicknames to get quick help on irc.
14:20:37 <basti_> i once wanted the phone number of a guy i didnt know the location of
14:20:56 <anyone> I have programmed myself a countermeasure for precisely that.
14:21:23 <anyone> If I see a sexy nick, I begin to sound harsh.
14:21:28 <basti_> in germany you cant search this way in the internet phone book, but on an old cd
14:21:34 <basti_> but i dont have this cd
14:22:14 <anyone> <sexy_chick> I need help with f(x)=x^2 f'(x)=? LOL  <anyone> Have you read your books and notes?  You should drop the course.
14:22:16 <basti_> it works.
14:22:38 <boegel> hey fraxtal 
14:22:41 <boegel> strike 6 !
14:22:43 <fraxtal> hey
14:23:22 <Philippa-> dammit
14:23:31 <boegel> hey Philippa- :p
14:23:52 * boegel is seeing triple :|
14:24:02 <boegel> Philippa, Philippa_ and Philippa-
14:25:15 <Philippa-> one'll drop soon
14:25:19 <Philippa-> another's running next door
14:26:23 <boegel> Philippa-: how's the bf doing ?
14:26:46 <Philippa-> "poor frustrated me", apparently. Puppy-eyed.
14:27:27 <boegel> Philippa-: why is he frustrated then ? because he has to go to work tomorrow ?
14:27:46 <Philippa-> er, no
14:28:01 <Philippa-> because he's lying in bed with his girlfriend who is currently IRCing on a laptop
14:28:19 <boegel> oooooooh, the poor guy
14:28:32 <Philippa-> (though he's playing FF2 on his GBA...)
14:28:48 <xerox> He'll get his one, and came here to talk to you? :)
14:28:48 * boegel likes it that his girl only read books whilst in bed
14:28:50 <basti_> you should play him some fantasy
14:29:09 <boegel> FF2 ? what's that ?
14:29:14 <basti_> final fantasy 2?
14:29:15 <boegel> Firefox 2 ? :p
14:29:20 <Philippa-> basti_: bingo
14:29:21 * Heffalump starts worrying about the number of people who seem not to have realised Philippa is female :-)
14:29:40 <boegel> Heffalump: I know ! I know !!1!
14:29:53 <Heffalump> you're the second one in a few days
14:29:54 <dons> Heffalump: maybe there are lots of secret females... dons == donna ..!
14:30:01 <basti_> final fantasy is one of the few "rpgs" i did like
14:30:05 <fraxtal> Heffalump: Ah it makes alot more sense now
14:30:09 <anyone> I keep forgetting that Philippa is a girl.
14:30:28 <fraxtal> Philippa is the first lambdatron I have ever heard of then
14:30:33 <Heffalump> dons: well, you did a great job of hiding it in Snowbird :-)
14:31:01 <Philippa-> anyone: if it helps I like strap-ons...
14:31:02 <dons> hehe. puts on girlish homer-simpson voice "oh, I knoooow. wink wink"
14:31:39 <xerox> 'night folks
14:31:40 * boegel stares at Philippa-
14:31:48 <boegel> g'night xerox 
14:31:54 * boegel starts a goodbye streak
14:31:58 <Philippa-> boegel: I'm not straight. This is not news to this channel.
14:32:12 <boegel> Philippa: but you have a bf ?
14:32:18 <Philippa-> right
14:32:31 <Philippa-> of course, it's entirely possible he likes the strap-on too...
14:32:34 <boegel> Philippa-: for how long now ?
14:32:45 * boegel laugs
14:32:56 <Philippa-> we've been going out for a year or so
14:32:58 <boegel> I shiver at the thought off it
14:33:12 <Philippa-> good shiver or bad shiver? :-)
14:33:12 <boegel> and does he know you're not straight ? :p
14:33:16 <Philippa-> yes
14:33:17 <boegel> bad !
14:33:17 <lightstep> hey i_of_k5 
14:33:26 <boegel> hey i_of_k5 
14:33:34 <i_of_k5> hi lightstep
14:33:34 * boegel almost missed that
14:33:37 * lightstep breaks the streak
14:33:52 * boegel wheeps and wants the stop-crying-cookie
14:33:55 <fraxtal> Philippa-: Were you straight when you started dating him?
14:34:05 <Philippa-> nope
14:34:09 <Heffalump> "not being straight" presumably includes being bi..
14:34:15 <boegel> fraxtal: mwoeha
14:34:19 <Philippa-> indeed
14:34:25 <Philippa-> or other variants on the theme
14:34:26 <Heffalump> lol, that'd be a great advert for a bloke. "I'm the one that turned her into a lesbian"
14:34:40 <fraxtal> boegel: Is that a weird laugh or some odd mnemonic I havn't heard of yet?
14:34:51 <basti_> i find "straight" is a stupid word for it
14:34:56 <Philippa-> it is
14:34:57 <boegel> fraxtal: evil laugh
14:35:07 <Philippa-> especially as it's derived from bent as in "gender bender"
14:35:28 <lightstep> Heffalump: i know someone like that
14:35:31 <dons> anyone written a primops preprocessor in TH, along the lines of ghc's genprimopcode?
14:35:38 <dons> sorry to ask a Haskell question..
14:35:52 <fraxtal> boegel: My Weener Omega Energy has Anal
14:35:54 <Heffalump> dons: shhh
14:36:08 <Heffalump> we're having a _non-geek_ conversation
14:36:24 <dons> :P
14:36:24 <boegel> for once...
14:36:34 <boegel> fraxtal: ieuw
14:36:45 <boegel> fraxtal: as in icky :p
14:36:56 <fraxtal> boegel: "I Envy Ur Weener" ?
14:37:21 * boegel can't wait until shapr reads the logs
14:37:25 <Philippa-> nah, with a strap-on you can customise it however you like
14:37:34 <boegel> fraxtal: you shouldn't :p
14:37:54 <Heffalump> why would shapr reading the logs be particularly interesting?
14:38:01 <lightstep> shapr reads the entire logs?
14:38:11 <boegel> Heffalump: because he'll read this conversation :)
14:38:27 <Heffalump> so..?
14:38:37 <boegel> I think shapr skims he logs to see what happened in here when he wasn't here... I'm not sure though
14:38:50 <basti_> i think thats very possible
14:38:54 <basti_> i mean we're talking about shapr
14:38:55 <boegel> Heffalump: I would like to see the look on his face:p
14:38:57 <Philippa-> boegel: he wouldn't be learning anything new about me
14:39:00 <lightstep> cool. he must have lotsa time
14:39:13 * Heffalump wonders how badly he's fucked up his sleeping cycle. I went to bed at 3:30am or so last night (after a friend's stag do), got up at 10:30ish, got home and went to sleep for 5 hours, and only just got up again.
14:39:18 <boegel> Philippa-: that's not what I said... it's not always about you you know :p
14:39:21 <boegel> hi Pseudonym !
14:39:37 <Pseudonym> G'day boegel!
14:39:51 <boegel> Heffalump: nice going...
14:39:58 <boegel> bye Philippa :D
14:40:11 <Philippa-> Heffalump: ow. Try to get some rest before the day starts, I guess
14:40:12 <boegel> I think we scared i_ok_k5
14:40:15 <Pseudonym> I hope we're not engaging in personal attacks, people.
14:40:35 <boegel> Pseudonym: we'll try, now shut up ;)
14:40:46 <Pseudonym> boegel: You suck!
14:40:54 * boegel cries
14:41:08 * Philippa- hands boegel and Pseudonym a tub of lube and tells them to wrestle for it
14:41:11 <lightstep> boegel only cries 'cause he's a loser
14:41:12 <basti_> LOL
14:41:19 <Pseudonym> Oooh, kinky.
14:41:20 <Heffalump> Australians smell </non-personal-attack>
14:41:26 <boegel> Pseudonym: I always knew you didn't like me :'(
14:41:30 <boegel> :D
14:41:41 <boegel> lightstep: I am? :)
14:41:41 <dons> Heffalump: bah!
14:41:45 <Pseudonym> boegel: I didn't say that.  Sucking is considered a good thing in certain contexts.
14:42:03 <boegel> Pseudonym: sexual contexts ? :p
14:42:09 <Pseudonym> I didn't say that either. :-)
14:42:12 <lightstep> boegel: yeah! i helloed this i_something!
14:42:14 <boegel> hehehe
14:42:18 <Philippa-> I can't imagine a black hole giving good head mind - there's a limit
14:42:30 <boegel> lightstep: you're right, I am a loser :p
14:42:40 <basti_> guys, sometimes this channel is seriously weird
14:42:50 <Philippa-> well yeah. We don't always talk code though
14:42:53 <Pseudonym> Philippa-: Yes, I believe the limit is referred to as the event horizon.
14:43:15 <boegel> basti_: weird ? where ? here ? naaaah
14:43:29 <boegel> hi pyoko 
14:44:31 <_Codex> "S has all finite limits".
14:45:20 <boegel> _Codex: ? :D
14:45:39 <_Codex> It's a quote from "Sets for mathematics" :)
14:45:48 <Pseudonym> aka "The Joy of Sets"
14:45:50 * boegel wants Philippa- to tell more stories
14:46:21 <Philippa-> bah. What else do you want to know? How many furries I've slept with?
14:46:44 <boegel> I want to know what a furry is ;
14:46:53 <boegel> s/;/;p
14:46:59 <Pseudonym> Bizarrely, I was just reading a paper on black holes.
14:47:04 <lightstep> From Webster's Revised Unabridged Dictionary (1913) [web1913]:
14:47:06 <lightstep>   Furry \Fur"ry\, a. [From {Fur}.]
14:47:07 <Pseudonym> And it described black holes as "having no hair".
14:47:07 <lightstep>      1. Covered with fur; dressed in fur. ``Furry nations.''
14:47:18 <Pseudonym> So black holes clearly aren't furry.
14:47:30 <Pseudonym> Though fur is not the same thing as hair, I do realise.
14:47:53 <Philippa-> lightstep: Webster's is unlikely to contain the usage in question here
14:48:12 <lightstep> yeah, well, i just set up my dict client
14:48:20 <lightstep> so i use it all the time
14:48:26 <Pseudonym> I don't think there are any dict servers which serve up this particular definition, either.
14:49:04 <Philippa-> urbandictionary might
14:49:16 <Pseudonym> Yes, it might.
14:49:19 <Philippa-> anyway, you want to explain?
14:49:23 <Pseudonym> Nope.
14:49:25 * boegel still doesn't know what a furry is
14:49:26 <Philippa-> heh
14:49:31 <Pseudonym> There's a FAQ out there somewhere.
14:49:39 <Pseudonym> Google will know, hang on.
14:49:43 <boegel> it could be all kinds of things/people
14:49:52 <Pseudonym> Ah, yes.  alt.fan.furry
14:49:55 <Pseudonym> http://www.faqs.org/faqs/furry/faq/
14:50:32 <Pseudonym> Bonus points if you can classify all usages of the term "yiff".
14:50:57 * boegel blinks
14:51:05 * Philippa- laughs
14:51:22 * Pseudonym is a Usenet Old Fart.  He remembers this stuff.
14:51:35 <Philippa-> it's largely synonymous with "fuck", with "yiffy" ~= horny
14:51:43 <Pseudonym> That's not the only usage.
14:51:57 <Philippa-> yeah, seems to be the only common one now though
14:51:57 <Pseudonym> But yeah, more or less.
14:52:00 * Pseudonym nods
14:52:18 * boegel blinks again
14:52:38 <Philippa-> incidentally, aside from "slept on the floor in the same room" values of "slept with", the answer's 0
14:52:54 <Pseudonym> Well, that's a relief.
14:52:56 <Philippa-> however, I do play with a friend of mine once in a while
14:53:12 <Philippa-> furdom is more or less not involved, give or take some posters on his wall
14:55:20 * boegel yawns
14:55:22 <Philippa-> one way or another both the furries I've known in person are people I'm fond of though. Daft world, isn't it?
14:55:46 <Pseudonym> Not particularly.
14:56:27 <Pseudonym> Maybe it's just that I have odd friends too.  Just part of life, I guess.
14:56:59 <Pseudonym> The strange thing is, though... knowing details of your friends' sex lives is a little off-putting...
14:57:01 <Heffalump> hmm, do where clauses have to cover an entire set of | clauses?
14:57:09 <Pseudonym> ...except when it's also their hobby, so to speak.
14:57:31 <Pseudonym> Then it's just like: "Well, I like kayaking."  "Really?  I'm into leather."
14:58:06 <boegel> Heffalump: sssh
14:58:13 <Heffalump> bah :-p
14:58:21 <boegel> Pseudonym: hehe
14:58:39 <Pseudonym> Heffalump: Yes.
14:58:53 <Pseudonym> I believe that "where" clauses are a property of the "definition".
14:58:57 <Heffalump> oh well, /me uses a let
14:59:10 <Pseudonym> There is more than one way to do it.
14:59:25 <samc> as we have been hearing
14:59:28 <Heffalump> you make Haskell sound like perl :-(
14:59:35 <dons> it is a bit odd that let and where aren't completely interchangeable
15:00:23 <lightstep> Heffalump: i think that yes
15:00:56 <lightstep> but your functions shouldn't be so big that it is a problem
15:01:00 <Pseudonym> Any language which is sufficiently useful has more than one way to do most things.
15:01:10 <Pseudonym> That way, you have a choice about which is the most appropriate.
15:01:19 <Philippa-> Pseudonym: what's fun is when it's not so much part of somebody's sex life as something that happens to intersect it sometimes
15:01:25 <Igloo> Wasn't where only invented because people wanted something that wasn't interchangeable with let?
15:01:40 <dons> hmm, that's interesting
15:01:43 <Pseudonym> Igloo: No.  Miranda had where, but not let.
15:02:11 <anyone> Haha, then "let" was invented because people wanted something different from "where". :D
15:02:25 <Pseudonym> There were probably languages before it that had "let" but not "where", though.
15:02:37 <anyone> Yes of course.  SML.
15:02:42 <lightstep> no, "let" was invited for lisp, when terminals weren't even invented
15:02:42 <Pseudonym> Right.
15:03:01 <Igloo> Oh, OK
15:03:08 <Pseudonym> But "where" was invented for the Babbage machine, where they didn't even have "lambda".
15:03:50 <dons> my abacus doesn't have lambda either, damnit
15:04:07 <lightstep> even haskell doesn't have lambda, only \
15:04:29 <anyone> (Joke.)  <A> Wow, before terminals weren't invented. How did people communicate with computers then?  <B> Speech recognition and synthesis, as the movies showed, you idiot.  <A> Wow the past technologies must have been more advanced than the present.  <B> Blame it on Microsoft.
15:04:43 <anyone> s/weren't/were/
15:05:12 <Igloo> Higher-order abacuses with little abacuses instead of balls? ISAGN
15:06:23 <Igloo> Except that doesn't quite work, but n/m
15:07:15 <dons> need to bind abacuses some how
15:08:09 <Igloo> Well, really you need abacuses to change size, or perhaps to interact via scary mechanical whatsits
15:08:40 <dons> whatsits are good
15:09:32 <dons> maybe if all the beads of the abacus where lambdas, and we could compose them
15:09:48 <lightstep> preferably arrows
15:09:49 <dons> so a lambdabacus
15:10:23 <Pseudonym> Arrows are kinda difficult, because the abacus model doesn't encourage a point-free style.
15:10:48 <dons> hmm. nesting lambda beads seems tricky. need a whatsit
15:11:08 <dons>  (\x. (\y. ... ))
15:12:01 <dons> a lambdabcus would let you construct only valid untyped lambda calc expressions
15:12:21 <dons> and you'd have to do the reductions by hand, of course
15:15:12 <lightstep> maybe that was the strange game from "Mimsy Were the Borogoves"
15:16:40 <Pseudonym> You might end up with evaluation black holes if your snark be a boojum.
15:16:59 <basti_> this is a seriously wierd conversation day.
15:17:37 <dons> aha. found where ghc turns primop src strings into PrimOps good good
15:18:14 * Pseudonym isn't sure that dons' sentence there isn't another Lewis Carrol line
15:18:25 <basti_> good night
15:18:33 <boegel> bye basti_
15:18:37 <boegel> damn, too late :)
15:19:23 <dons> hmm. stilll can't see where src strings go to primops though
15:19:46 <Pseudonym> dons, you've just uttered a contradiction.
15:19:58 <Pseudonym> Are you sure that you don't believe A and not A?
15:20:13 <boegel> hi sond 
15:20:19 <Pseudonym> sond is almost the anti-dons.
15:20:23 <sond> hey
15:20:26 <sond> hehe
15:20:26 <Pseudonym> G'day.
15:20:36 <boegel> Pseudonym: no, that'd be snod
15:20:38 <dons> oh. oops. I can see how to do PrimOp -> Id, but not  Id -> PrimOp
15:20:43 <dons> my first stmt was false
15:20:44 <humasect> petsung !
15:20:46 <Pseudonym> boegel: I did say "almost".
15:20:50 <humasect> PETSUNG
15:21:03 <boegel> Pseudonym: woops :)
15:21:13 <Pseudonym> petsung would clearly be KDE.
15:21:20 * boegel gives humasect some candy
15:21:24 <Pseudonym> Or is it petsUNG?
15:21:29 <humasect> =)
15:24:43 <dons> hmm. a hyperlinked ghc src would be fun
15:24:53 <dons> or at least a hasktags version
15:25:59 <dons> also, what is the best way to dump TH-expanded code in ghc?
15:26:10 <dons> -ddump-simpl ?
15:28:03 <dons> don't TH users like to check what their code expands to :} ?
15:28:34 <Pseudonym> Maybe we dont use TH.
15:28:53 <dons> maybe.
15:29:26 <Philippa-> it'd be nice to be able to get that sometimes, yeah
15:29:37 <Philippa-> certainly it'd help for debugging
15:29:51 <Philippa-> (a haskell -> TH types parser would be good, too)
15:30:09 <dons> _that_ is a good idea.
15:30:26 <dons> hmm. almost just showing the Haskell syntree type inside ghc
15:30:43 <humasect> ~_%
15:31:54 * boegel goes to bed
15:31:59 <boegel> g'night everyone !
15:32:18 <lightstep> bye boegel 
15:43:24 <dons> ghc-6.5!
15:44:15 <Heffalump> is 6.4 out?
15:44:41 <Heffalump> or did they branch 6.4 and make the HEAD be 6.5?
15:52:49 <dons> it's been branched.
15:52:55 <dons> 6.4 has become the stable branch
15:53:28 <Philippa-> thank fuck for that, maybe it'll be released this year after all
15:54:08 <Pseudonym> Who is this "fuck" and why must they be thanked?  Are they responsible for GHC?
15:55:08 <Heffalump> and can they be got to help with sarge too?
15:57:42 <Philippa-> Pseudonym: As an atheist, I find "fuck" to make a suitable replacement for "god" in many phrases :-)
15:58:00 * Gahhh wonders how many haskellers are atheists
15:58:14 <Philippa-> actually, atheist isn't quite accurate
15:58:21 <Philippa-> agnostic/apatheist
15:58:34 <Gahhh> I believe it also carries that meaning nowadays
15:58:42 <Pseudonym> Philippa-: So tyou believe in "fuck", then?
15:58:51 <Philippa-> fuck yeah :-)
15:58:57 <Gahhh> Holy fuck, to be exact
15:59:30 <lightstep> hey nsh 
15:59:34 <Pseudonym> Gahhh: Probably the same proportion as in any other group of random computer sciency-type people.
15:59:37 <anyone> You can offend both theists and atheists by "omfg"
16:00:20 <Pseudonym> anyone: Depends.  If the theist is of a religion where their deity is sexually active, that's not offensive.
16:00:34 <Gahhh> Pseudonym, I find haskellers to be a little more out of the ordinary, tho.
16:00:38 <Igloo> Presumably not polythesists, as they tend to have a god for fucking (although they generally use a different word, admittedly)
16:00:46 <Pseudonym> Gahhh: True./
16:01:03 <Pseudonym> I find most geeks to be fairly tolerant, thought he intolerant ones are often loud about it.
16:01:27 <Pseudonym> IOW, to a True Geek(tm), it matters not what you believe, so long as said beliefs are held for the right reasons.
16:01:44 <Pseudonym> Faith is okay.  Blind faith is not.
16:02:33 <Philippa-> Igloo: they tend to have a god /of/ fucking. Not the same thing.
16:02:56 <lightstep> Pseudonym: except in lazy functional programming languages
16:03:00 <Gahhh> I feel like God when I am f'ing personally
16:03:14 <Pseudonym> lightstep: Or just declarative languages.
16:03:20 <Philippa-> you'd be a top, then?
16:03:26 <Igloo> Sure it is. One is just the English equivalent of the eta expansion of the other, or something  :-)
16:03:29 <Gahhh> blasphemy
16:06:11 <Philippa-> hrmm, I think Damien's encouraging me to do a little worship...
16:06:27 <Gahhh> gently put
16:06:44 <Philippa-> 'night
16:06:54 <Gahhh> amen
16:07:11 <Pseudonym> Night.
16:07:24 * Pseudonym just got TMI
16:07:30 <Gahhh> tmi = ?
16:07:44 <Pseudonym> Too Much Information
16:07:48 <Gahhh> ah
16:08:15 <Gahhh> I didn't mind it. I applaud them.
16:08:30 <Gahhh> more fun than watching super bowl
16:09:13 <Pseudonym> Look, I'm glad for them.
16:09:32 <Pseudonym> I just don't particularly want to know about it.
16:18:49 <wilx> @type ,
16:18:50 <lambdabot> bzzt
16:19:17 <wilx> @type (,)
16:19:18 <lambdabot> (,) :: forall b a. a -> b -> (a, b)
16:19:28 <wilx> Heh, nice.
16:21:43 <Pseudonym> @type (,,,)
16:21:44 <lambdabot> (,,,) :: forall d c b a. a -> b -> c -> d -> (a, b, c, d)
16:21:58 <lightstep> does GHC really use tagless garbage collection?
16:22:09 <Pseudonym> Yes.
16:22:14 <Pseudonym> Kind of.
16:24:06 <lightstep> @type (,,,,,,,,,,,,,)
16:24:07 <lambdabot> (,,,,,,,,,,,,,) :: forall n m l k j i h g f e d c b a.
16:24:07 <lambdabot> 		   a
16:24:07 <lambdabot> 		   -> b
16:24:07 <lambdabot> 		      -> c
16:24:07 <lambdabot> 			 -> d
16:24:07 <lambdabot> 			    -> e
16:24:09 <lambdabot> 			       -> f
16:24:11 <lambdabot> 				  -> g
16:24:13 <lambdabot> 				     -> h
16:24:16 <lambdabot> [20 @more lines]
16:24:22 <wilx> :))
16:25:07 <duncan> how do we define tagless garbage collection? If I understand correctly, each boxed/heap object has an pointer to a bunch of info (like which fields are pointers) and the garbage collector makes use of this to do accurate collection
16:25:20 <Pseudonym> Right.
16:25:28 <Pseudonym> So the pointer is effectively a tag.
16:25:38 <duncan> right
16:26:00 <Pseudonym> But it's not a tag.
16:26:09 <duncan> what's a tag then?
16:26:37 <Pseudonym> Previous languages pulled some bits out of arguments to use as tags.
16:26:46 <Pseudonym> Many languages still do.
16:26:54 <Pseudonym> For example, consider how you'd implement a "list" type.
16:27:00 <wnoise> A tag is usually meant as "tells what type the object is".
16:27:14 <Pseudonym> data List a = Null | Cons a (List a) | Thunk (() -> List a)
16:27:19 <Pseudonym> That's logically what the type is.
16:27:24 <Pseudonym> wnoise: No!
16:27:29 <Pseudonym> Not in a strongly-typed language.
16:27:29 <duncan> the ghc tags would tell you what the head type
16:28:00 <Pseudonym> A tag is usually meant as "given a type, this is the constructor that we're using".
16:28:02 <duncan> like it'd tell you it was a cons cell or end of list but not the type of the list element
16:28:07 <Pseudonym> Right.
16:28:31 <Pseudonym> So anyway, a common approach is to steal the lower bits off a pointer.
16:28:32 <wnoise> YM statically typed?  Even ocaml tags it's 31 bit integers, for example.
16:28:47 <Pseudonym> Yes, I mean statically typed.
16:29:15 <Pseudonym> Because pointers are generally aligned.
16:29:29 <Pseudonym> That gives you four tags.
16:29:42 <duncan> I think that ocaml int thing is for different reasons, it's do that so they can unbox their ints
16:29:50 <Pseudonym> Right.
16:29:58 <Pseudonym> Anyway.
16:30:26 <Pseudonym> It's actually not a tag, it's a code pointer, so every heap object is a closure.
16:30:41 <Pseudonym> It's just that with only that info, you can garbage collect.
16:30:49 <Pseudonym> So it kind of plays the role of a tag.
16:30:51 <Pseudonym> But it's not a tag.
16:30:59 <duncan> it's a combination of a code pointer and info table
16:31:01 <Pseudonym> The disadvantage is that it's hard to unbox objects.
16:31:12 <Pseudonym> But that's going to be hard in a lazy language anyway.
16:31:44 <Pseudonym> Because even the simplest types every type operationally includes a "thunk" alternative.
16:34:43 <lightstep> g'night
18:35:12 <redlion> wtf, someone rebuilt a delorean, and they decide to put *two* engines in it...
18:35:31 <redlion> http://www.gendreaumicro.com/tenpointtwo/11472index.htm
18:49:05 <Pseudonym> Then there's no room for the time machine.
18:51:55 <stepcut> suck...
18:52:08 * stepcut ponders getting a delorean
18:53:11 <stepcut> John Delorean ~193cm, stepcut ~190cm
18:56:36 <Pseudonym> A Delorean would be a very cool car.
18:56:44 <Pseudonym> Unfortunately, you can't get the parts.
18:57:48 <stepcut> http://www.usadmc.com/dmcstore/viewdir.asp
18:58:19 <Pseudonym> That's fine if you're in the US.
18:58:25 <stepcut> I am
20:26:43 <wilx> @eval show "Test"
20:26:44 <lambdabot> unbound variable: show
20:26:51 <wilx> @eval "Test"
20:26:52 <lambdabot> Test
20:31:46 <Pseudonym> @eval (\h -> (\x -> h (x x)) (\x -> h (x x))) (\x -> x)
20:32:16 <lambdabot> out of fuel - use @resume to continue
21:13:15 <wilx> @resume
21:13:46 <lambdabot> out of fuel - use @resume to continue
21:13:58 <Spark> @eval Fix I
21:13:58 <lambdabot> unbound variable: Fix
21:14:28 <Spark> @eval (\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.xx)(\x.x)
21:14:29 <lambdabot> unbound variable: xx
21:15:02 <Spark> @eval (\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x)
21:15:32 <lambdabot> out of fuel - use @resume to continue
21:15:35 <Spark> :>
21:15:45 <Spark> @eval (\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x x)(\x.x)
21:16:15 <lambdabot> out of fuel - use @resume to continue
21:16:18 <desrt> uh
21:16:21 <desrt> id?
21:16:43 <Spark> yeah of course
21:16:46 <Spark> just plenty of computation involved
21:17:09 <Spark> actually im being a spanner
21:17:14 <Spark> it associates the other way
21:17:32 <Spark> @eval (\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)(\x.x)))))))))
21:17:33 <lambdabot> <<EM Dynamic -> EM Dynamic>>
21:17:42 <Spark> @eval (\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)(\x.x))))))))
21:17:43 <lambdabot> (line 1, column 94):
21:17:43 <lambdabot> unexpected end of input
21:17:43 <lambdabot> expecting simple term or ")"
21:17:50 <Spark> @eval (\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)(\x.x)))))))))
21:17:50 <lambdabot> <<EM Dynamic -> EM Dynamic>>
21:17:53 <Spark> what does that mean?
21:18:02 <Spark> @eval (\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)3))))))))
21:18:02 <lambdabot> type error
21:18:14 <Spark> @eval (\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)((\x.x x)(\x.x)))))))))3
21:18:15 <lambdabot> 3
21:18:18 <Spark> ah ok
21:18:42 <desrt> a dynamic is a dynamically typechecked value
21:18:43 <Spark> what type system does it use, do you know?
21:18:48 <Spark> ah ok
21:18:56 <desrt> HMish
21:19:05 <desrt> probably almost exactly what haskell uses
21:19:37 <Spark> can hm type (\x.x x)(\x.x) ?
21:19:54 <desrt> ya.  of course
21:20:00 <Spark> can it type (\x.xx) ?
21:20:09 <desrt> is that (\x.x x)?
21:20:11 <Spark> yeah
21:20:14 <desrt> ya
21:20:18 <Spark> what is its type?
21:20:22 <desrt> a -> a
21:20:36 <Spark> that would imply that it could be applied to 3
21:20:43 <Spark> @eval (\x.x x)3
21:20:44 <lambdabot> type error
21:20:54 <ibid> does lambdabot have @type?
21:20:57 <desrt> good call
21:21:00 <ibid> @type (\x.x x)
21:21:01 * desrt thinks a moment
21:21:02 <lambdabot> bzzt
21:21:02 <desrt> no
21:21:07 <desrt> it's (a->a) -> a -> a
21:21:08 <ibid> apparently not :)
21:21:09 <Spark> @type (\x.x x)(\x.x)
21:21:10 <lambdabot> bzzt
21:21:34 <Spark> you cant type that sort of thing without a polymorphic type system with principal typings, i think
21:21:51 <Spark> @eval let f = \x.x in f f
21:21:51 <lambdabot> (line 1, column 7):
21:21:51 <lambdabot> unexpected "="
21:21:51 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
21:21:51 <lambdabot>  "(", operator, simple term or end of input
21:22:06 <Spark> help me out
21:22:31 <desrt> aparantly it has an infinite type
21:22:35 <Spark> @eval fun f = \x.x in f f
21:22:36 <desrt> i don't understand that
21:22:36 <lambdabot> (line 1, column 7):
21:22:36 <lambdabot> unexpected "="
21:22:36 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
21:22:36 <lambdabot>  "(", operator, simple term or end of input
21:22:51 <desrt> OH
21:22:58 <Spark> let polymorphism...
21:23:01 <desrt> i'm thinking (\x.x.x)
21:23:11 <desrt> yes.  (\x.x x) is not typeable
21:23:38 <Spark> the problem with (\x.x x) is you need to collect together the requiremnt for each x, with the intention of allowing only an x that satisfies all requirements
21:23:53 <Spark> with let polymorphism you first type the argument, and then ensure that it meets all requirements
21:24:05 <Pseudonym> @type (\x -> x x)
21:24:07 <Spark> you have to first type the (\x.x)
21:24:08 <lambdabot> bzzt
21:24:15 <Pseudonym> @type (\x -> x)
21:24:17 <lambdabot> (\x -> x) :: forall t. t -> t
21:24:19 <Spark> and then show that it is suitable for (\x.x x)
21:24:29 <Pseudonym> @type (\x -> x x)
21:24:32 <lambdabot> bzzt
21:24:41 <Pseudonym> Whoops.
21:24:54 <desrt> Pseudonym; it definitely has an infinite type
21:24:58 <desrt> x would have to take itself
21:24:59 <Spark> since (forall t.t->t)<=((t->t)->(t->t)) and (forall t.t->t)<=(t->t))
21:25:41 <Spark> extra bracket on the end :(
21:26:08 <Spark> @eval
21:26:09 <lambdabot> (line 1, column 1):
21:26:09 <lambdabot> unexpected end of input
21:26:09 <lambdabot> expecting white space or simple term
21:26:11 <Spark> @eval let
21:26:12 <lambdabot> unbound variable: let
21:26:14 <Spark> @eval let x
21:26:14 <lambdabot> unbound variable: let
21:26:23 * desrt blinks
21:26:24 <Spark> whats the syntax for something like that?
21:26:36 <Spark> define a function, give it an identifier, then use the identifier
21:26:48 <desrt> lambdabot: let x = id in x 3
21:26:49 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
21:26:57 <desrt> @eval let x = id in x 3
21:26:57 <lambdabot> (line 1, column 7):
21:26:57 <lambdabot> unexpected "="
21:26:57 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
21:26:57 <lambdabot>  "(", operator, simple term or end of input
21:27:01 <desrt> evil.
21:27:08 <desrt> @eval x 3 where x = id
21:27:08 <lambdabot> (line 1, column 13):
21:27:08 <lambdabot> unexpected "="
21:27:08 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
21:27:08 <lambdabot>  "(", operator, simple term or end of input
21:27:11 <desrt> guess not
21:27:32 <Spark> shame
21:27:35 <Pseudonym> @eval (\x -> x 3) (\x -> x)
21:27:36 <lambdabot> 3
21:27:39 <Pseudonym> That works.
21:27:44 <desrt> heh
21:27:57 <desrt> but that's just the same as writing 'id 3' :P
21:28:10 <Spark> i was interested in typing the let syntax
21:28:12 <Spark> as opposed to
21:28:17 <Spark> @type (\x.x x)(\x.x)
21:28:21 <lambdabot> bzzt
21:28:22 <Spark> same semantics, you see
21:28:29 <desrt> the let syntax doesn't have a type....
21:28:39 <Pseudonym> Well, let foo = bar in baz is _somewhat_ identical ot (\foo -> baz) bar
21:28:42 <Spark> does too
21:28:46 <desrt> Pseudonym; i take it back.  that's actually fairly useful
21:28:51 <Pseudonym> Certainly as far as @eval is concerned.
21:29:33 <Spark> desrt: "let x = 3 in x" has type int ...
21:29:50 <desrt> right
21:29:54 <desrt> but let on its own doesn't
21:30:05 <Spark> well no, only valid syntax can be typed :)
21:30:36 <desrt> @type id
21:30:37 <lambdabot> id :: forall a. a -> a
21:30:41 <desrt> fascinating.
21:30:58 <desrt> for (a->a)->a->a i think i was thinking about (\x.x.x)
21:31:04 <desrt> @type (\x -> x.x)
21:31:05 <lambdabot> (\x -> x.x) :: forall c. (c -> c) -> c -> c
21:31:09 <desrt> c?!?
21:31:13 <desrt> pfft.
21:31:32 <Spark> hmm
21:31:37 <Spark> is that (\x.x)x ?
21:31:43 <desrt> no
21:31:51 <Spark> how is "." different to " "
21:31:57 <desrt> . is function composition
21:32:01 <Spark> oh right
21:32:06 <desrt> ' ' is function application
21:32:10 <desrt> :)
21:32:27 <Spark> thats fucked cos in lots of things ive seen, . is application :)
21:32:27 <Gahhh> choice of c is peculiar heh
21:32:37 <desrt> Gahhh; i say!
21:32:45 <desrt> i think lambdabot must have haskell inside of it
21:32:51 <Gahhh> in maths, it's a hollow circle for composition
21:32:54 <Spark> presumably it got to c after choosing some new variables and then discarding them during unification
21:33:00 <Spark> @type (\x -> x.x.x)
21:33:01 <lambdabot> (\x -> x.x.x) :: forall a. (a -> a) -> a -> a
21:33:07 <Spark> perhaps not :)
21:33:13 <desrt> well
21:33:20 <desrt> at first, it would see that x is a function from a->b
21:33:30 <desrt> and that the other x therefore must be a function from b->c
21:33:30 <Spark> @type \x\y\z.xyz
21:33:32 <lambdabot> bzzt
21:33:33 <Spark> @type \x\y\z.x y z
21:33:34 <lambdabot> bzzt
21:33:35 <desrt> but then it would realise the x == x
21:33:41 <desrt> so a == b == c
21:33:57 <Spark> @type \x.\y.\z.x y z
21:33:58 <desrt> then for some reason it shows the c *shrug*
21:33:59 <lambdabot> bzzt
21:34:00 <Pseudonym> desrt: Read "The Implementation of Functional Programming Languages". :-)
21:34:03 <Pseudonym> All covered there.
21:34:05 <Gahhh> it's no a requirement to express it as a->a, tho. c is equallyu god heh.
21:34:12 <Pseudonym> And it's online, even.
21:34:14 <Gahhh> uh. s/god/good
21:34:15 <desrt> Spark; it uses \x -> x for lambda notation
21:34:29 <Spark> @type \x\y\z -> x y z
21:34:30 <wnoise> @type \x y z -> x y z
21:34:31 <lambdabot> bzzt
21:34:32 <lambdabot> \x y z -> x y z :: forall t t1 t2. (t -> t1 -> t2) -> t -> t1 -> t2
21:34:35 <Spark> rightoh
21:34:42 <Spark> now it uses t_n :0
21:34:43 <dons> anyone heard anything more about the ocr'd version of IFPL?
21:34:59 <Pseudonym> Nope.
21:35:03 <dons> i'd like to set it as a reference text
21:35:17 <desrt> Pseudonym; microsoft research?
21:35:22 <dons> oh well, 30M of .jpgs is still referenceable,  I guess
21:36:21 <desrt> you can buy it in print (sort of)
21:36:29 <Spark> heh
21:36:36 <Spark> why is it not in a sane format
21:36:36 <dons> can you? it wasn't at cafe press last time I looked
21:36:44 <desrt> http://www.cafepress.com/haskell_books
21:36:47 <Pseudonym> desrt: ?
21:36:47 <Spark> did the author forget to make backups?
21:37:00 <desrt> oh evil
21:37:04 <desrt> Implementing Functional Languages: a tutorial
21:37:11 <Pseudonym> Oh, that's good, too.
21:37:13 <desrt> this sounds the same but is probably different
21:37:15 <wnoise> someone volunteered to scan it, but didn't choose a good format.  I hear .pngs will make an appearance at some point.
21:37:22 <Pseudonym> It's a bit more tutorial-related.
21:37:31 <dons> different. less in depth. more haskell/miranda code
21:37:35 <Pseudonym> Right.
21:37:46 <Pseudonym> IFPL is less of a "how to" and more of a "what happens".
21:37:49 <Spark> what is the content of these books?
21:37:52 <Spark> specifically...
21:38:05 <Spark> optimisations, code generation?
21:38:08 <dons> compilation of functional programming languages
21:38:09 <Spark> program analysis?
21:38:31 <dons> combine both of them and you could just about write a toy ghc
21:38:44 <Spark> both of what sorry?
21:38:53 <dons> IFPL and the tutorial
21:38:55 <Spark> ah right
21:39:24 * desrt already knows how to write a toy ghc
21:39:43 <desrt> you just need a spineless tagless g-machine
21:39:49 <desrt> now... if i only knew what that was :/
21:40:05 <ibid> desrt: rtfp:)
21:40:12 <desrt> p?
21:40:16 <ibid> papers
21:40:18 <desrt> :)
21:40:26 <ibid> :)
21:40:29 <desrt> rtf? :)
21:40:31 <Pseudonym> Actually, the STG paper does not to into any detail about translating STG code to C.
21:40:39 <ibid> read the fine/f*ing
21:40:47 <Spark> sometimes i wonder whether some people deliberately obfuscate their papers
21:40:51 <dons> Pseudonym's right, unfortunately
21:41:04 <Spark> this one i just read is like a symbolic slap in the face
21:41:06 <Pseudonym> IFPL does have some useful stuff in it for beginners, though.
21:41:11 <Pseudonym> Like the problem of CAFs.
21:41:19 <ibid> Pseudonym: i usually find such details distracting in a paper; i can usually reconstruct them myself if the rest of the paper is well-written
21:41:23 <Pseudonym> And a very thorough description of generating code for the original G machine.
21:41:26 <desrt> wolfgang has challenged me to write a lambda calc compiler
21:41:35 <desrt> so i could probably use to learn this stuff
21:41:37 <dons> yep. you could probably compile to G machine code, then come back and tackle STG code generation
21:41:49 <dons> desrt: read IFPL, it's all in there
21:41:55 <Spark> is it worth learning about compiling without actually knowing about assembly languages?
21:41:58 <desrt> cool
21:42:04 <desrt> i'm downloading the tarball
21:42:06 <Pseudonym> Spark: Yes.
21:42:24 <Pseudonym> Many higher-level languages compile to C, since it's effectively a portable assembler.
21:42:32 <Spark> is there a sort of toy assembly language that is a close enough representation to express the ideas, but still elegant and simple
21:42:35 <Spark> oh ok
21:42:45 <dons> Spark: C-- ?
21:42:46 <Spark> hmm i wouldnt call that elegant and simple :)
21:42:55 <Spark> c--... which ones that
21:43:03 <desrt> Spark; the backend language for ghc...
21:43:05 <ibid> it seems to me like there are two stages: functional programs to imperative code, and then imperative to native code; the latter is (rightly) not covered in the fp compilation papers and books
21:43:06 <dons> the more elegant and simpler C
21:43:24 <ibid> Spark: i had a pseiudo-assembler in my popl course  :)
21:43:26 <Spark> dons: what does it exclude?
21:43:38 <ibid> desrt: ghc uses c-- nowadays?
21:43:44 <dons> yes. in 6.4
21:43:52 <desrt> now i'm confused
21:43:53 <ibid> wow
21:44:04 <desrt> what are all these Cmm files in 6.2?
21:44:14 <ibid> Spark: c-- is not a c subset
21:44:23 <dons> ghc's code generation translates STG code (a functional language) into Cmm (a C-- superset)
21:44:27 <desrt> it just has a vaguely C feel to it
21:44:28 <Spark> i guess it makes validating the compiler easier if the target language is also typed (to some extent) :)
21:44:46 <ibid> Spark: the intermediate language being typed is the kicker
21:45:11 <dons> Spark: yep! that's why ghc has a Cmm lint pass
21:45:31 <desrt> dons; doesn't 6.2 generate Cmm too?
21:45:36 <dons> desrt: there are .cmm files in 6.2? since when?
21:45:50 <dons> we added it to the head in Jan last year
21:45:52 <desrt> i might be crazy and just assumed they were always there
21:45:57 <dons> which was 6.3
21:46:29 <desrt> what did it use before that?
21:46:43 <dons> AbstractC
21:46:52 <dons> which was C as a data type
21:46:56 <desrt> :)
21:47:00 <dons> and it was horribly complex
21:47:01 <desrt> i have one of those
21:47:12 <desrt> it lives in a file called c-compiler/AbstractSyntax.hs
21:47:37 <Spark> ok ive got a bit of background in type theory for the lambda calculus, combinator systems, term rewriting systems and a subset of ml (lc + let, fix)
21:47:46 <Spark> but i want to know about the HM type system
21:48:04 <desrt> type theory for the lambda calculus isn't very difficult
21:48:36 <Spark> heh
21:48:54 <Spark> depends on the type system used :)
21:48:55 <desrt> ok.  it's definitely bed time
21:49:10 <desrt> ok.  if you try to type lambdacalc using HM, then you run into trouble :)
21:49:23 <Spark> why?
21:49:33 <Spark> presumably HM only makes sense in the present of let, etc
21:49:35 <desrt> you try to form an infinite type pretty soon
21:50:01 <desrt> (\x.x x) is a good example
21:50:09 <Spark> thats a haskell expression though
21:50:13 <Spark> not just a lambda one
21:50:16 <desrt> no.  that's lambdacalc
21:50:23 <desrt> it's not valid in haskell... it won't type
21:50:42 <Spark> youre missing the point :)
21:51:01 <desrt> maybe.  i'm just a bit tipsy right now
21:51:05 <ibid> Spark: the pseudo-assembler i mentioned is quadmachine, http://kaijanaho.info/~tuukka/qm
21:51:05 <desrt> and my ears are ringing
21:51:11 <desrt> and i think i'm going to go to bed
21:51:41 <desrt> cheers, all
21:51:50 <Spark> ibid: whats that exactly? :)
21:51:50 <Pseudonym> Night.
21:51:57 <Spark> desrt: nn
21:52:22 <ibid> Spark: a pseudo-assembler language and simulator, made for my popl course last autumn
21:52:46 <Spark> whats popl?
21:52:58 <ibid> of course, the only spec is in finnish currently :)
21:53:06 <ibid> principles of programming languages
21:53:46 <Spark> ah right
21:53:48 <ibid> whoa, we have wiki spam there :)
21:53:51 <Spark> thats a pretty broad subject area :)
21:54:08 <Spark> (hmm, wiki would be a good place to set up farms of links to increase google page ranks)
21:55:08 <Spark> so the students write compilers for toy languages to the pseudo assembly code?
21:55:27 <ibid> not reallt
21:55:29 <Spark> and the assembler makes byte code
21:55:31 <Spark> oh
21:55:49 <Spark> oh, you were the student?
21:56:02 <ibid> the compilers were demonstration stuff at exercises and lectures, with students writing extensions
21:56:08 <ibid> Spark: i was the teacher
21:56:12 <Spark> right ok :)
21:56:20 <Spark> ah i see
21:56:38 <Spark> so it gives a platform by which you can talk about the target language of other compilers
21:56:51 <ibid> writing the extensions required grasping how the things worked without having to take the time to write the things from scratch
21:57:30 <ibid> Spark: it gives a simple, idealised platform as an example of assembler and machine-level user-space architecture
21:57:41 <Spark> right
21:58:06 <Spark> did it interface with syscalls as well?
21:58:10 <Spark> (the assy langauge)
21:58:11 <ibid> there is one big design mistake in it, though, which degraded the pedagogical value
21:58:27 <sh10151> wow
21:58:40 <sh10151> bochs is like someone emulating a PC with pen and paper
21:58:43 <ibid> Spark: the simulator provides a linux-like user-mode environment
21:58:49 <sh10151> while suffering from a robitussin overdose
21:59:03 <ibid> Spark: though, again, idealizing the system interface
21:59:08 <Spark> right
21:59:19 <Spark> this is too low level for my knowledge base unfortunately :)
21:59:25 <Spark> maybe i should take your course ;)
21:59:29 <ibid> the big design mistake was eschewing registers
21:59:41 <ibid> the idea was that register stuff could be put in bss
22:00:04 <Spark> bss?
22:00:07 <ibid> but that was, obviously, a mistake
22:00:21 <ibid> i should've had a separate 2^32 register file
22:00:32 <ibid> Spark: the bss segment
22:00:53 <Spark> dunno
22:00:57 <ibid> with probably register windows or something
22:01:23 <ibid> Spark: unix processes have text, data, bss and stack segments
22:01:31 <ibid> Spark: bss is all zero at the beginning
22:02:07 <ibid> Spark: the idea is that an executable image only stores the length of the bss segment, not its content (since it's all-zero)
22:02:24 <ibid> Spark: C static variables are put in bss
22:02:33 <Spark> ah i see
22:02:48 <ibid> unless explicitly initialized, of course
22:02:55 <ibid> text contains the executable code
22:03:02 <Spark> heh
22:03:03 <ibid> data contains initialized static variables
22:03:09 <Spark> "text"
22:03:11 <Spark> who named it that
22:03:16 <ibid> no idea
22:04:02 <Spark> so is the bss quite large compared to the data then
22:04:19 <ibid> traditionally, the bss is where the heap resides
22:04:20 <Spark> there shouldnt be that much static stuff in a given program should there?
22:04:27 <Spark> oh right
22:04:29 <ibid> (it can be resized with the brk system call)
22:04:31 <Spark> so you can get more of it
22:04:33 <Spark> ah
22:04:57 <ibid> of course, modern heap arrangements often use private anon mmap space
22:05:17 <Spark> why not combine data and bss?
22:05:25 <Spark> in terms of segments
22:05:35 <ibid> because then you'd have to store all the zeros in the executable
22:05:35 <Spark> two different representations in the executeable --> one segment
22:05:50 <ibid> the segments only exist in the executable
22:05:53 <Spark> oh ok
22:06:01 <Spark> i thought segment was in terms of virtual memory and all that
22:06:04 <ibid> they don't really exist in the live memory
22:06:15 <ibid> of course, the text segment is usually write-protected by paging
22:06:34 <ibid> and the area between top of bss and top of stack is unmapped
22:06:50 <ibid> (except that that's the space where mmaps happen)
22:06:59 <Spark> heh ok
22:07:35 <ibid> one exercise i had in this course was to exploit a security hole i had planted in a qm program
22:08:03 <ibid> it turned out that i had designed qm too well, it required a special insecure mode for the exploit to be possible at all :)
22:08:13 <Spark> heh :)
22:08:18 <Spark> overwriting the text bit
22:08:32 <ibid> no
22:08:43 <ibid> my stack was too well protected
22:08:50 <Spark> or a goto out of the text bit
22:08:53 <ibid> (you couldn't access memory below the stack pointer)
22:09:02 <Spark> ah
22:09:34 <ibid> http://www.mit.jyu.fi/antkaij/opetus/okp/2004/demot/insecure.s <- the insecure program
22:10:21 <ibid> http://www.mit.jyu.fi/antkaij/opetus/okp/2004/demot/insecure.alk <- the ALKEIS-program that that was hand-compiled from
22:12:21 <Spark> i think im suffering the effects of 6am
22:12:34 <ibid> it's 8am, and i'm really tired myself
22:12:36 <Spark> will have to leave that un-understood
22:12:40 <ibid> and i have a lecture at 10am
22:12:46 <Spark> heh
22:12:53 <ibid> as a lecturer :)
22:12:58 <Spark> yeah
22:13:02 <Spark> i cant lecture for shit, i imagine i'll get better with more practice
22:13:21 <Spark> i tend to get really hyperactive (feeding off the attention)
22:13:22 <ibid> the formal methods course, topic is sets, relations and functions
22:13:28 <Spark> and totally lose control :)
22:13:38 <ibid> i slept for about two or three hours
22:13:39 <Spark> heh surely thats a discrete maths course theen
22:13:47 <ibid> woke up at around 4am
22:13:52 <ibid> Spark: no, formal methods
22:14:09 <Spark> oh is that like Z and all that
22:14:17 <ibid> something like that :)
22:14:30 <Spark> an excuse for obscure symbols
22:14:47 <ibid> i need to refresh people's memory on those topics and i want to present a more rigorous definition of sets :)
22:14:53 <Spark> "formal methods" isnt really specific enough as a title :)
22:15:19 <Spark> especially with methods overloaded as it is
22:16:18 <ibid> but it's a standard name for it :)
22:16:31 <ibid> though i agree that there is little cohesion in the subject matter
22:16:54 <Spark> its all about pre and post conditions and stuff isnt it
22:17:36 <ibid> that's one aspect of it
22:17:36 <Spark> i remember hating Z during my BSc
22:17:40 <ibid> :)
22:17:48 <ibid> i did my msc diss about the b method
22:17:56 <Spark> mm
22:17:59 <ibid> (a later method designed by the guy who invented z)
22:18:03 <Spark> operational semantics i loved though :)
22:18:05 <Spark> ah right
22:18:08 <Spark> never heard of it but ok :)
22:18:25 <ibid> Spark: they share a conference, zb
22:18:40 <Spark> ah right
22:18:48 <ibid> http://www.mit.jyu.fi/antkaij/gradu.pdf <- my msc diss
22:19:02 <Spark> my lecturer for Z was ah crap i cant remember her name, we always called her "Z woman"
22:19:03 <ibid> http://www.mit.jyu.fi/antkaij/splst03_kaijanaho.pdf <- a paper based on (a part of) it
22:19:11 <ibid> where?
22:19:18 <Spark> Error: Couldn't open file 'http://www.mit.jyu.fi/antkaij/splst03_kaijanaho.pdf'
22:19:23 <Spark> heh it really is late
22:19:27 <Spark> Warwick uni, UK
22:20:25 <Spark> hmm, jane sinclair?
22:25:00 <Spark> earlier on i was on a roll with this work i was doing
22:25:17 <Spark> i demolished a lot of confusion i was having with unification & intersection types
22:25:24 <Spark> but then at about 4am i tired and ground to a halt
22:25:28 <Spark> and have been talking on irc ever since :)
22:26:20 <ibid> the splst url works for me
22:26:33 <Spark> ah yes its not actually clear what i was on about
22:26:38 <Spark> i put it as an argument to xpdf
22:26:41 <Spark> without thinking :)
22:26:56 <Spark> expecting it to work like media streaming
22:27:01 <ibid> :)
22:28:22 <samc> where's the syntax error in this? perm xs = concatMap (\(n+1) -> ((\(as,b:bs) -> map (b:) (perm $ as++bs)) . splitAt n) xs) [1..length xs]
22:29:29 <ibid> are the parens ok?
22:29:50 * samc hits himself
22:29:54 <ibid> hm?
22:30:37 <samc> sorry, apparently it wasn't written to disk, hehe
22:31:28 <Spark> heh
22:32:23 <samc> tis no wonder I couldn't figure it out, of course as soon as I post it here I notice
22:33:07 <Spark> heh
22:33:19 <Spark> ive noticed you dont realise the scope of your understanding until you try writing about something
22:33:40 <Spark> undergrads tend not to write much
22:34:18 <Spark> but on the msc course im doing, i think they are "grooming" us for actual research, so they have us reading lots of papers and summarising the info in 30 page reports
22:34:22 <Spark> 1 per term
22:34:50 <Spark> you can read lots of papers and go "ahhah i understand", then try actually writing about it and find out "ahhah actually i dont have a clue"
22:35:53 <samc> yes indeed
22:36:00 <vikasgp> that's very true. Writing something, even if noone else reads it, is a very good way to structure your knowledge
22:36:38 <Spark> it also forces you to tread the dark corners that you may have glimpsed at but generally ignored
22:38:19 <Spark> like "whats the point of this" :)
