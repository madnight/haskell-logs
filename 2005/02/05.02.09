00:00:15 <gzl> and for some reason, in some situations, the choice of s can actually change the orbit path of the satellite in addition to how it's being scaled
00:00:19 <shapr> do you know the minimum value of y?
00:00:27 <gzl> yes
00:00:44 <shapr> wait, you want largest at the bottom, right?
00:00:47 <gzl> yes
00:01:35 <shapr> if you know the max value of y, can you just pretend the maximum of y is zero, and the minimum is however many units down?
00:01:51 <gzl> the orbit is centered on (0,0)
00:02:11 <gzl> so when y > 0 you have the top half of the orbit and y < 0 is the bottom half
00:02:15 <gzl> if that changes anything
00:02:30 <shapr> Right, but... if the orbit were centered in such a way that your y values only went from zero up to ten, it'd be easy, right?
00:02:45 <gzl> for some reason, no
00:02:57 <shapr> y is the up and down axis, isn't it?
00:02:59 <gzl> yes
00:03:33 <gzl> it didn't seem like it should be difficult, but then things I thought made sense didn't really work the way I thought they should
00:04:25 <shapr> ok, if your orbit were such that all the possible values of y were from zero to ten, wouldn't it be easy to scale the picture by swapping the range of values?
00:04:57 <shapr> like, zero is ten, where the shape should be largest, and ten is zero, the smallest
00:05:33 <gzl> if i understand what you're saying, yes
00:05:34 <shapr> makes any sense?
00:05:43 <gzl> yes
00:06:17 <shapr> The y axis increases as it goes up, decreases as it goes down, if your shape should be largest at the top, you could use the y axis directly, right?
00:06:52 <shapr> so, you can flip it by multiplying by negative one?
00:07:00 <gzl> hm, i guess
00:07:37 <gzl> so you're suggesting I basically translate the y-axis up temporarily so it's like it's from 0 to max y, flip it, and multiply that value with the scaling factor?
00:07:54 <shapr> that would be my approach.
00:07:56 <gzl> hm
00:08:18 <shapr> does it sound like a complete departure from the simple solution?
00:08:26 <gzl> no, it sounds like a return to the simple solution
00:09:40 <gzl> scaling = y' + y/2 is a lot simpler than the trig functions I was playing with before
00:10:59 <shapr> Of course, my suggestion requires you to know the range of y values, so it could be more general.
00:11:02 <gzl> but the thing that's confusing me is that for some reason this scaling stuff is screwing up the actual orbit
00:11:23 <shapr> it shouldn't affect the orbit at all
00:11:27 <gzl> yes, exactly
00:11:28 <gzl> but it does
00:11:32 <wnoise> perhaps you somehow scale the translation as well.
00:11:40 <gzl> hm.
00:11:50 <wnoise> i.e. scale (translated object), instead of translate (scaled object).
00:12:02 <gzl> yeah I just thought of that when you said scale thr translation :)
00:13:04 <gzl> ah, excellent. this seems to be doing the exact opposite of what i want. so it almost works
00:13:36 <wnoise> "Clearly you should just be required to specify the three parameters of the Euclidean group E(2), and not be allowed to compose them."
00:14:24 <shapr> This sounds cool, I should really go through the Hudak book.
00:14:26 <gzl> what's the Euclidean group? symmetry-preserving transformations in euclidean n-space?
00:14:59 <wnoise> Well, if the symmetry is "it's rigidly mapped onto itself".
00:15:06 <gzl> shapr: yeah, it's cool when you're not too tired to play with it and you just end up belaboring the obvious. :)
00:15:06 <wnoise> Rotations + translations, IOW.
00:15:14 <gzl> shapr: the book's definitely nice
00:15:26 <gzl> he has some music stuff later on too
00:16:26 <shapr> I own the book, I started the book. I got distracted into writing my own fun code in Haskell.
00:16:32 <gzl> fair enough.
00:16:40 <gzl> what fun code did you come up with?
00:16:59 <xerox> Is "The Haskell School of Expression" the book you are referring to?
00:17:01 <gzl> yes
00:17:06 <shapr> I wrote the plugin system for lambdabot
00:17:15 <gzl> cool
00:17:23 <shapr> It was only three lines of code, but it took me a week =)
00:17:27 <gzl> hahaha
00:17:40 <gzl> that sounds about right from my limited haskell experience so far
00:17:54 <xerox> Three lines?!
00:17:58 <shapr> of course, once I had that, everything else got so much easier.
00:18:04 <xerox> I wonder how long are those ;)
00:18:18 <shapr> xerox: maybe 80 characters without whitespace.
00:18:23 <gzl> this whole solar system animation is only a few lines
00:18:38 <wli> gzl: whoa
00:18:43 <wli> gzl: show me
00:18:44 <xerox> If that book has this effects, I want it too!
00:18:57 <gzl> no, because it doesn't work right now. :)
00:19:24 <shapr> Pseudonym (who wrote lambdabot) said "This is the simplest thing that could possibly work, but really..."
00:19:36 <gzl> i mean, it depends on how one counts. there are lots of type declarations and tiny helper functions here and there, but the core code is just a few lines
00:20:28 <shapr> lambdabot's plugin system was drop dead simple, it was just a hook that checked to see if an incoming message was a plugin call, and if it was, call that plugin.
00:21:53 <gzl> to what extent have you felt limited by the smaller number of modules and libraries and stuff available for haskell as compared to other languages?
00:22:00 <shapr> It took me a week to get my head wrapped around the type system.
00:22:49 <shapr> I haven't felt limited at all, writing your own libs is pretty easy once you have a grasp of the language itself.
00:23:23 <shapr> The existing tools are really good for making libs.
00:23:26 <gzl> wnoise: thanks a lot, that was one big thing i kept overlooking :)
00:23:38 <gzl> shapr: thanks too, that simplified this code a lot
00:24:10 <shapr> I wrote an RFC822 parser that sucked, it was my first parser. Then Peter Simons showed me his complete rfc2822 parser.
00:24:15 <gzl> that's fair. but what if you don't have the expertise to write a library for say, database transactions but you need to use a database?
00:24:34 <gzl> even if haskell makes it easy to write, you still have to know how to write it, no?
00:24:38 <shapr> There's already libs and bindings for databases.
00:24:45 <gzl> i know, it's just an example
00:25:01 <shapr> Yeah, but the hard part of writing that sort of thing isn't learning how to do it, it's making sure what you do really works.
00:25:23 <shapr> database transactions are perfectly sensible when you think about it a bit.
00:25:50 <shapr> 1. the hardware can crash at any instant 2. you are not allowed to have any data loss
00:26:45 <gzl> right, but you may have to use all kinds of services in some application. is it reasonable to expect someone to learn enough about all of them to implement a dozen libraries?
00:26:52 <shapr> so, find a way to setup input such that there is never an invalid state. you set up a change, and at the last instant change a value to point from one chunk to another.
00:27:07 <gzl> i'm not trying to be argumentative, just curious how people think about it.
00:27:16 <gzl> lest it be misinterpreted :)
00:27:52 <shapr> Well, I'm writing a big long blog entry on how open source code is valuable only if any random programmer can understand and learn from it.
00:28:13 <shapr> So I probably have a biased opinion
00:29:20 <shapr> I don't think anyone can anticipate your needs, especially not a big vendor with a multi-month release cycle. I think that programmers always get partial solutions for their needs/problems.
00:29:40 <gzl> it's ok, everyone's biased.
00:30:15 <shapr> I like to have libaries available that I can easily understand, so that I can modify them to do what I really want.
00:30:36 <shapr> Libraries that I don't understand aren't very useful to me, because I can't modify them.
00:31:04 <gzl> sounds reasonable enough
00:31:09 <shapr> I doubt I explained that well, that's why I haven't finished the blog entry, because my explanation isn't really coherent.
00:31:56 <gzl> yeah, but i know what you're saying, more or less
00:32:03 <shapr> Anyway, I wrote a mailing list search webapplication in three evenings of spare time, it was 200 lines when I was done. (153 lines without blank lines)
00:32:11 <wli> gzl: I'm boggling at how the heck you can do a solar system simulation in "just a few lines".
00:32:47 <gzl> you can't do it in a few lines using nothing but the standard prelude
00:33:08 <shapr> gzl: I guess I'm trying to say that the most important tools are in your head, libraries aren't the largest factor.
00:33:09 <gzl> but using some basic animation infrastructure, it takes just a few lines to write this particular animation
00:33:30 <gzl> if you count differently you could say it takes 200 lines to do it i guess
00:33:43 <shapr> Oh that's a pretty good line. I gotta put that in the entry.
00:34:37 <shapr> gzl: what do you think about that? libraries vs mental tools?
00:34:52 <shapr> I'm self-employed, so I have a vested interest in actual production =)
00:34:53 <gzl> i think it's a good tagline for your point of view. :) and i agree with it to an extent.
00:34:53 <wli> shapr: mental tools win every time =)
00:35:14 <shapr> wli: I'll quote you on that ;-)
00:35:22 <shapr> gzl: to what extent do you disagree?
00:35:48 <gzl> i wouldn't say i disagree, actually. i would just say that though i agree with that, i don't think libraries aren't a factor.
00:35:53 <wli> shapr: libraries are crutches for inadequate modes of expression
00:36:00 <xerox> Every time this kind of discussions happen, I get the feeling I need to know more Haskell.
00:36:08 <shapr> wli: this is approaching the eschatology quote =)
00:36:20 <gzl> but i also consider my opinion uninformed. i'm really new to haskell.
00:36:44 <shapr> gzl: well, don't trust us, find out for yourself ;-)
00:36:54 <gzl> i am. :)
00:36:58 <shapr> xerox: so learn! jump in!
00:37:01 <xerox> I'll give another try to the Gentle Introduction, no founds to shorten amazon's whishlist.
00:37:05 <wli> gzl: I'm interested in getting a look at this because I'm vaguely interested in doing similar sorts of animation (the product being the images, not the code).
00:37:06 <gzl> shapr: hence the hudak.
00:37:18 <gzl> wli: Hudak has the stuff available online
00:37:20 <shapr> gzl: yeah, good approach.
00:37:34 <wli> gzl: URL?
00:37:55 <shapr> wli: That's actually really a good point. I never thought of it that.
00:37:59 <shapr> er "that way"
00:38:16 <gzl> hmm
00:38:23 <shapr> hey, that explains why every Python user writes a web system, even though there's no explicit support for web systems in Python...
00:38:26 <gzl> wtf
00:38:31 <gzl> I don't know where Hudak has put this
00:38:33 <gzl> here, I'll upload it
00:38:50 <shapr> http://www.haskell.org/soe/
00:39:04 <gzl> oh there
00:39:17 <gzl> yeah, the demos have all this stuff there
00:39:27 <gzl> I was looking on Hudak's own page
00:39:41 <shapr> gzl: btw, are you in Europe?
00:39:54 <gzl> no, I'm having a craptacular night.
00:40:06 <shapr> oh, ok.. no EuroHaskell for you.
00:40:14 <gzl> i thought you were asking because of the time.
00:40:34 <shapr> well, yeah. seemed likely you were in the EU
00:40:39 <gzl> wli: the demos on that page are the kind of thing I mean by "a few lines"
00:41:12 <gzl> shapr: this is part of pierce's course, btw. i think i was talking to you about it before, you might not remember. :)
00:41:20 <shapr> ah yes, I remember now.
00:41:39 <shapr> Sorry, It's nearing 10am, and I woke up at 7pm or so.
00:41:46 * gzl scratches head
00:41:47 <gzl> what?
00:42:16 <shapr> I have a sleep strange attractor. It doesn't even resemble a Schedule.
00:42:28 <gzl> you and me both.
00:42:40 <wli> sleep?
00:42:49 <gzl> really, the problem was that i had a lot of chores today, a talk to host, etc so i didn't get a chance to finish work i needed to do
00:43:06 <shapr> wli: yes I know, my modes of expression are inadequate that's why I need sleep ;-)
00:43:11 * shapr grins
00:43:20 <shapr> what was the talk about?
00:43:29 <gzl> information assurance research at the NSA
00:43:36 <shapr> wli: that really is an excellent quote, thanks
00:43:38 <shapr> !
00:43:44 * wli =)
00:44:01 <shapr> gzl: those guys scare me.
00:44:14 <gzl> haha they were a little odd
00:44:31 <wli> They're probably being outdone by the academic community anyway.
00:44:51 <shapr> Maybe recently, but not earlier.
00:44:58 <gzl> the talk was ok. decently interesting. tomorrow should be better, i have stroustrup coming
00:45:17 <shapr> like, uh, *the* stroustrup?
00:46:01 <shapr> gzl: if you hang out with pierce and stroustrup, your life is far cooler than mine ;-)
00:46:37 <shapr> Well, I did get to hang out with SPJ and a bunch of other cool people at ICFP03. Wadler did blow me off for lunch though :-)
00:46:46 <gzl> yes, the stroustrup
00:46:55 <gzl> took me months to convince him to come :)
00:47:00 <gzl> sort of.
00:47:08 <shapr> Maybe ICFP05 will be as cool as ICFP03
00:47:27 <shapr> gzl: What is information assurance anyway?
00:47:31 * shapr asks google
00:47:35 <gzl> it's the NSA's word for security
00:47:49 <shapr> oh. How does stroustrup fit into that?
00:48:16 <gzl> he doesn't. he fits into my inviting people to give talks. :)
00:48:23 <shapr> oh, cool.
00:48:29 <gzl> i'm going to invite hudak, dunno if he'll come
00:48:48 <shapr> That would be nifty. He appears to be the world expert on domain specific languages.
00:48:58 <shapr> I'm really impressed with Dance.
00:49:15 <gzl> pierce was telling me about some of the things he's doing, it seems neat
00:49:17 <shapr> Of course, I want to pervert it into a two or more person variant used to explore martial arts, but hey =)
00:49:19 <gzl> i want to look into it further at some point
00:49:25 <gzl> I wanted to check out Generic Haskell too
00:49:42 <shapr> GH is quite nifty.
00:49:53 <shapr> type-indexed types are cool.
00:50:13 <shapr> gzl: what sort of stuff are you interested in?
00:50:16 <Philippa> if only for the acronym?
00:50:20 <shapr> oj
00:51:23 <gzl> i don't know yet.
00:51:31 <shapr> gzl: what sort of talks are you looking for?
00:51:39 <gzl> anyone interesting who is willing to come.
00:52:02 <gzl> i did some work on programming languages, so i find that interesting. that's one of the reasons i took this course.
00:52:02 <xerox> What about ``Haskell - The Craft of Functional Programming'' ?
00:52:35 <gzl> i also like math, so i had wanted to read a little about elliptic curve crypto. and i find search interesting.
00:52:37 <shapr> John Launchbury might be a cool speaker, Galois Connections is the pinnacle of Haskell academia meeting real world problems :-)
00:52:41 <gzl> and several other things.
00:53:08 <gzl> yeah, i'll keep them in mind if hudak says no or for next year
00:53:53 <shapr> Too bad all the epigram guys are in the UK, probably wouldn't show up.
00:54:44 <shapr> gzl: Do you know if all crypto is based on Merkle's Puzzles? I had the vague recollection that some of it wasn't.
00:55:03 <gzl> i know literally nothing about crypto. but i've been meaning to find out. :)
00:55:44 <shapr> For some reason I think ECC isn't based on computational complexity.
00:55:49 * shapr asks google
00:55:55 <gzl> but my uninformed impression is that a lot of crypto is inspired by merkle
00:56:04 <gzl> though i'm reluctant to say all
00:56:56 <wli> merkle?
00:57:13 <shapr> Well, when you have more thoughts on libraries vs expressive power, I'd like to hear your opinion.
00:57:25 <gzl> ok. :)
00:57:41 <shapr> wli: um, early 70s, the very first guy to think of secure communications across insecure channels
00:57:50 <wli> gzl: It's comparatively easy to create hard-to-solve problems vs. solving them.
00:57:57 <Philippa> shapr: no he wasn't, but hey
00:58:10 <gzl> wli: true. but why bring this up? :)
00:58:29 <wli> gzl: To support the claim that cryptanalysis is the more "interesting" field.
00:58:36 <shapr> Philippa: someone else got it to work earlier?
00:59:05 <Philippa> FCVO "work". The one-time pad is well-known, for example, and everybody was dealing with insecure channels
00:59:15 <shapr> oh right
00:59:28 <shapr> I meant communication across insecure channels where the channel is all you've got.
00:59:42 * Philippa nods
00:59:50 <gzl> wli: ah, ok.
00:59:54 <Philippa> the old method was "hope like hell you can get one communication in safely"
01:00:28 <Philippa> and yeah, being able to negotiate keys etc safely, that was new
01:00:58 <shapr> Anyway, Merkle said that if you sent a bunch of puzzles across a wire to the other person, the other person would have to solve only one to have 'sort of secure' crypto key, but an eavesdropper would have to solve on average 50% of the puzzle to listen in
01:01:32 <shapr> assuming you get the key from a solved puzzle.
01:02:23 <shapr> and that's the same principle for most crypto used today (possibly all?)
01:02:57 <shapr> I've been trying to think of another basis for crypto, because I want spoken crypto that is still difficult to crack with a computer.
01:03:26 <gzl> are there any numeric classes that are an instance of Eq that just throw an error when you try to compare two values?
01:05:30 <Philippa> you can do it
01:05:51 <Philippa> the Prelude types won't
01:06:20 <Philippa> and it'd be really, really bad form for somebody to write an instance that does
01:07:11 <wli> not entirely improbable for function types
01:07:20 <wli> but it's better really to replace the numeric hierarchy
01:07:40 <gzl> why?
01:07:50 <gzl> no, I know I can if I want to. I was wondering if any built-in classes do it
01:08:08 <wli> Because the needs for such Eq instances arise from the numeric hierarchy sucking.
01:08:53 <Philippa> wli: if somebody puts a function type in the Num type class, they need a thorough kicking IMO. Wrappers around church numerals, perhaps I'll excuse.
01:09:43 <wli> Philippa: I don't bother putting functions in the Num type class, I dump the standard Prelude's Num type and use a proper one without the need for the Eq constraint etc.
01:09:47 <Philippa> gzl: none of the built-in numeric types do that
01:09:51 <gzl> ok.
01:10:25 <gzl> do any of them land up with other oddities because of subclassing?
01:10:53 <Philippa> not really. The subclassing kinda cross-cuts the various types, if that makes sense
01:11:16 <gzl> ok.
01:11:29 <TheHunter> imo, Eq a => Num a was a wrong decision, but the numerical hierarchy is broken anyway.
01:11:44 <gzl> broken?
01:12:08 <TheHunter> i mean, there are too many wrong decisions.
01:12:12 <gzl> ok.
01:12:34 <TheHunter> Like putting + and * in one class, the fact that fromInteger is in Num, etc.
01:12:37 <Philippa> it works, it's just that eg if you have a type that supports + and * meaningfully but not, say, equality, it doesn't fit into the hierarchy at all
01:13:21 <wli> TheHunter: fromIntegral is the lethal blow for ghc; it doesn't use the fromIntegral currently in scope.
01:13:46 <gzl> Philippa: ah, I see. I guess functions are one example
01:13:49 <wli> TheHunter: It's hardwired to some modulepath .fromIntegral
01:13:50 <gzl> though I don't know if it's a good one
01:14:01 <TheHunter> wli, it should use the Num currently in scope. That is a bug then.
01:14:20 <wli> TheHunter: It has to be named "Num"?
01:14:31 <TheHunter> i guess.
01:14:44 <wli> TheHunter: I looked at ghc source and it looked like the module path was hardcoded
01:14:45 <TheHunter> Just class Num a where fromIntegral :: Integer -> a should do.
01:15:07 <wli> TheHunter: if that works then I'd be surprised
01:15:52 <wli> the ghc source said it was substituting a specific function in a specific module
01:15:53 <TheHunter> wli, http://haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
01:16:03 <TheHunter> section 7.3.5
01:16:34 <TheHunter> anyway, there is NO reason why anything numerical should be an instance of Eq.
01:16:48 <Philippa> everything rather than anything, I assume? :-)
01:17:16 <wli> TheHunter: doesn't work
01:17:23 <wli> TheHunter: not as that webpage claims it does
01:17:26 <TheHunter> Philippa, yeah.
01:17:45 <TheHunter> wli, then either the documentation is out of date, or it's a bug.
01:19:26 <musasabi> morning
01:20:16 <TheHunter> wli, seems to work here.
01:21:18 <wli> TheHunter: needs to be ghc-cvs
01:21:28 <wli> *Algebra> :type 0
01:21:28 <wli> 0 :: forall t. (Module Z t, MultiplicativeMonoid t) => t
01:21:29 <TheHunter> btw, forget what I said about fromInteger having to be in a class Num.
01:22:24 <TheHunter> wli, it's 6.2.2
01:23:33 <swiert> Philippa: I've been looking at Flippi - I might use it as an example for my article on attribute grammars for TMR.
01:23:45 <swiert> I thought I'd let you know.
01:27:28 <Philippa> swiert: dare I ask what you'll be doing with it?
01:27:37 <Philippa> and have you seen the parsing stuff in the darcs repo?
01:28:15 <swiert> Philippa: I've looked at the parser and deWikifying - this is the sort of thing that makes sense to do with attribute grammars.
01:28:18 * Philippa should look into the attribute grammar stuff more, in fairness
01:28:29 <Philippa> ah, fair enough
01:28:32 <swiert> I haven't looked at the darcs rep yet.
01:28:42 * shapr cheers for TMR
01:28:50 <Philippa> the version in the darcs repo lets you plug in new bits of syntax just by adding the plugin to a list
01:28:50 <shapr> yay, people are learning stuff!
01:29:23 <gzl> wli: what's that Algebra module?
01:29:32 <swiert> ok - I'd like to have a look at that.
01:29:44 <shapr> yay Flippi 0.4!
01:30:04 <wli> gzl: Something I banged out in a jiffie.
01:30:16 <gzl> what does it do?
01:30:18 <Philippa> basically, it keeps an association list of parsers in Parsec's state. You can temporarily add or remove them using with/withoutParser funcs
01:30:47 <Philippa> the withoutParser bit lets you do things like traditional bold tags properly, where you want to be able to parse any currently valid markup /other/ than another *
01:31:17 <Philippa> I'd like to take it further, but really that's not a project for a wiki so much as one for a programming language with syntax macros or something like that
01:31:50 <swiert> Philippa: I see where you're heading.
01:31:52 <Lunar^> shapr: when is issue1 scheduled?
01:32:03 <Philippa> no doubt because it's been worked on elsewhere
01:32:07 <shapr> Lunar^: it'll be out on March 1st
01:32:18 <swiert> I know some guys in Utrecht are tackling the same problem.
01:32:25 <Philippa> anything that occurs to me within a few days of seeing a problem is going to have been done elsewhere somewhere by now, however smart the idea is
01:32:27 <Lunar^> shapr: yeah :)
01:33:10 <shapr> Lunar^: TMR comes out on the 1st of the month, that's the plan at least.
01:33:15 <shapr> 1st of every month.
01:33:48 <Lunar^> shapr: ok :) Are you planing to party this friday ?
01:33:54 <shapr> party?
01:33:58 <Lunar^> Have you planed
01:34:09 <shapr> Why would I party this friday?
01:34:11 <Lunar^> Yes, 11th feb is 42th day of the year
01:34:15 <shapr> oh!
01:34:16 <wli> hm, well, atm. I'm in trouble with:
01:34:22 <wli> *Algebra> 2 + 3 :: Z
01:34:22 <wli> Loading package haskell98 ... linking ... done.
01:34:22 <wli> *** Exception: stack overflow
01:34:26 <gzl> wli: so what does your algebra thing do?
01:34:29 <wli> open question as to wtf hit me
01:34:38 <shapr> Lunar^: I may buy a pizza to celebrate.
01:34:40 <wli> gzl: just redefines the numeric hierarchy out the wazoo
01:34:42 <shapr> Lunar^: thanks for reminding me.
01:34:44 <Lunar^> shapr: :)
01:38:04 <wli> *Algebra> 0::Z
01:38:04 <wli> *** Exception: stack overflow
01:38:14 <wli> who knows what on earth it's doing
01:40:10 * boegel greetz
01:40:15 <swiert> Philippa: anyway, I'll let you know once I have something worth looking at - right now I'm too busy with other stuff.
01:40:22 * shapr snores quietly
01:41:29 <shapr> Does anyone get real use out of the haskell-doc plugin for emacs' haskell-mode ?
01:41:52 <shapr> I just realized it would be easy to dump haddocks into haskell-doc format.
01:42:39 <wli> I wonder if I can get anything to say why I'm getting a stack overflow
01:42:53 <wli> or why it's loading package haskell98
01:43:32 <wnoise> Any chance the numeric tower will get fixed in Haskell 2?
01:43:47 <wli> wnoise: I've long-since given up hope.
01:44:08 <gzl> "haskell 2"?
01:44:10 <shapr> I wish the Haskell 2 standardization effort would begin.
01:44:16 <wli> *Algebra> :type \a b -> a + b
01:44:16 <wli> \a b -> a + b :: forall t. (AdditiveSemigroup t) => t -> t -> t
01:44:26 <shapr> But I don't yet wish that enough to actually spearhead such an effort myself.
01:44:40 <wli> any tips on debugging this stack overflow?
01:47:59 <wli> the "interesting" bit is "loading package haskell98"
01:48:18 <wli> there's no clear reason why that should be necessary
01:48:51 <wli> so it may be relevant to what's going wrong
01:50:46 <wli> interesting, when I compile it and load it, the -fno-implicit-prelude stuff breaks again
01:52:43 <TheHunter> wli, if nothing else helps, compile it with profiling enabled (-prof -auto-all) and then call the program with an argument +RTS -xc to get a kind of stack trace.
01:54:24 <wnoise> is Z supposed to be arbitrary Integers?  What's your hierarchy like, and what are the defs for Z?
01:55:14 <wli> wnoise: http://holomorphy.com/~wli/Algebra.hs
01:55:19 <wli> I just did type Z = Integer
01:55:58 <TheHunter> good morning, glimming
01:56:20 <glimming> Hello TheHunter! Just came from a nice morning Tennis game
01:57:48 <wli> $ ./try +RTS -xc
01:57:48 <wli> <Algebra.fromInteger,Algebra.CAF>Fail: <<loop>>
02:00:55 <wli> heh
02:01:00 <wli> the integer literals are killing it
02:01:21 <wli> fromInteger :: (MultiplicativeMonoid t, Module Z t) => Z -> t
02:01:21 <wli> fromInteger n   | n < 0 = P.error "negative literal???"
02:01:21 <wli>                 | otherwise = n .*. one
02:01:36 <wli> the MultiplicativeMonoid instance defines one as the integer literal 1
02:01:54 <wnoise> Right where I had just got in my analysis.
02:02:20 <wli> Any ideas?
02:02:50 <wnoise> succ 0?  Not really.  It seems like literal require magical compiler support.
02:04:07 <wnoise> Can you shove that instance in another module with different imports or defaulting rules?
02:04:27 <wli> data Integer = S# Int# | | J# Int# ByteArray#
02:06:12 <wli> GHC.Num.zeroInteger
02:07:18 <wli> let's see if GHC.Num.S# 0# works
02:07:21 <wnoise> I must say that the whole thing seems a bit overly pedantic.  Does any one really use preorders instead of partial orders?  I mean, you might as well throw in quasigroups and loops so you can handle the octonions.
02:08:16 <wli> wnoise: it's somethnig of a reaction to the "playing fast and loose with math" more than a serious attempt to get anyone to use anything
02:08:47 <wnoise> I do like the Zip class though, and Denumerable is cute.
02:09:25 <wli> wnoise: just a few of my thoughts on the subject(s)
02:09:26 <wnoise> If there were a standard that was useable I could see writing stuff in it.
02:11:11 <wli> wnoise: also see the applicative class, useful for functions represented via structure
02:12:00 <wnoise> Yeah.  And I like having a standard polynomial rep.  (since I'm working on orthogonal polynomial transforms at the moment...)
02:12:25 <wnoise> Know any good way to handle polynomials over multiple variables?
02:12:39 <wli> wnoise: a lot of things break down but I've written some Grobner basis stuff, hang on
02:13:42 <wli> wnoise: http://holomorphy.com/~wli/Poly.hs
02:15:04 <wli> wnoise: it seems to produce correct results when it doesn't break due to running out of memory
02:15:37 <wnoise> Hah.
02:15:41 <wnoise> Hah.
02:16:01 <wnoise> There's silght a chance this might actually be useful to me.
02:16:41 <wli> wnoise: unofficially "public domain", officially LGPL, 2-clause (or whatever the most liberal is) BSD, or anything else that qualifies as DFSG-free.
02:16:56 <wli> wnoise: note nonvirality
02:17:09 <wli> wnoise: Algebra.hs looks vaguely fixed
02:17:24 <wli> *Algebra> ((2*) + 1) (3::Z)
02:17:24 <wli> 7
02:17:51 <wli> *Algebra> (2*) + 1 $ 3::Z
02:17:51 <wli> 7
02:17:56 <wli> better yet =)
02:18:23 <wli> pedantic as all fsck I love it =)
02:18:34 <wnoise> Cool. Though I'm a bit confused as to how that parses that way.
02:19:36 <wli> 1 ends up as "const 1"
02:19:40 <wli> (2*) is obvious
02:20:08 <wnoise> I actually wouldn't mind virality for this case, but MIT or 2-clause is probably best in terms of getting it used.
02:20:27 <wnoise> Ah, lifted to functions.  All makes sense.
02:21:02 <wli> I can't say "DFSG-free" but rather I have to list them, but the list is exactly the DFSG-free license list from debian.org; same for all my code except where other licenses conflict (e.g. Linux kernel).
02:21:24 <wnoise> Reasonable policy.
02:22:19 <wnoise> so how does one get the operator sections rather than functions?
02:22:57 <wli> not sure what the question is there
02:23:36 <wli> it's still creaky around the edges, though
02:23:37 <wli> *Algebra> (^(Natural 2)) + (3*) + 1 $ UniPoly [1,1] :: UniPoly Z
02:23:37 <wli> UniPoly [5,5,1]
02:24:02 <wli> literals aren't implicitly converted to naturals but probably should be
02:24:23 <wnoise> never mind.  What options do I have to give ghc to compile this beast?
02:24:37 <wli> ghci-cvs -fno-implicit-prelude -fallow-overlapping-instances -fallow-undecidable-instances -fno-monomorphism-restriction -fglasgow-exts
02:25:00 * wli drops a license statement in there
02:27:31 <araujo> oh ohoh
02:28:11 <wli> okay, license statement all set up
02:29:00 <wnoise> Should this work?:
02:29:13 <wnoise> *Algebra> 1 :: N
02:29:27 <wli> Not as-written, no.
02:29:31 <wnoise> Because it gives  "No instance for (Module Z N)"
02:29:35 <wli> Natural 1
02:29:56 <wli> wnoise: N is not a Z-module, so there's trouble
02:29:57 <wnoise> Ah, right.  You definitely don't want autoconversion.
02:30:31 <wli> wnoise: I'm not aware of what additive semigroup + multiplicative monoid + module-like structure adds up to
02:31:21 <wli> wnoise: I suspect it's not any better-classified than a bigmagma or some such, maybe quasiring or semiring, but I've not gotten those kinds of refinements to play well with the type system.
02:32:37 <wnoise> I'd guess semiring, but don't recall.  I hate the term magma.
02:33:26 <wli> well, it's not quite that good, since we need a module-like structure defined in terms of semirings or quasirings
02:33:37 <wli> s/good/easy/ I guess
02:34:18 * wli adds the same license statement to Poly.hs
02:34:27 <wnoise> sure.  It definitely is a semiring, but you need more structure to have conversion from integers to be well defined.
02:35:14 <wli> Multiplicative monoid, then it's got some kind of relationship to N I don't have a name for.
02:35:42 <wli> no
02:35:44 <wli> additive monoid
02:35:55 <wnoise> "ringoid"
02:36:02 <wli> nope, additive semigroup, multiplicative monoid
02:36:36 <wli> the e from the multiplicative structure gets repetitive addition done with the module-like structure relating N to the "ringoid" R
02:37:33 <araujo> Good morning all.
02:37:36 <wli> Then the "ringoid" R is an N- "moduloid"
02:37:50 <Lemmih> Morning, araujo.
02:38:36 <araujo> Hello Lemmih
02:39:37 <wnoise> Hmm.  Anyways, I must sleep now.
02:39:41 <wli> wnoise: more fun
02:39:43 <wli> *Algebra> (^(Natural 2)) + (3*) + 1 $ UniPoly [1,1] $ 3 :: Z
02:39:43 <wli> 64
02:40:34 <wnoise> Nice!
02:41:34 <wli> I'm trying to figure out why the results are wrong =(
02:43:22 * boegel says "hi!"
02:45:07 <Lemmih> Greetings, boegel. How's code?
02:47:35 <araujo> boegel, hello there
02:47:43 <boegel> Lemmih: kinda quiet lately... with the finals and all :(
02:47:48 <boegel> hey araujo
02:49:06 <boegel> I have another final on friday, and then I'll take some time off with my gf
02:49:25 <wli> solved
02:49:29 <boegel> I'll work on my raytracer after the weekend (in between the lessons :s)
02:51:14 <boegel> @wiki HaskellIrcPastePage
02:51:14 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
02:51:52 <boegel> @wiki TheMonadReader
02:51:52 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
02:52:31 <boegel> hmm
02:52:47 <boegel> shapr still has no dummy .tex file to start with ?
02:53:29 <samc_> check the logs
02:55:12 <samc_> darcs http://www.cs.uu.nl/~andres/TMR (or something)
02:58:09 <boegel> samc_: hmm, okay, I will, but not now...
02:58:12 <boegel> I have to go :)
03:00:37 <samc_> http://tlb.org/eunicycle.html
03:00:50 <samc_> self-balancing unicycle
03:01:22 <samc_> I don't know if the unicyclers here will like or dislike the concept :)
03:12:11 <musasabi> What is the preferred way of getting C constants into haskell programs?
03:13:44 <musasabi> just #include the needed files and hope they are #defined rather than anonymous enums?
03:17:14 <Lemmih> samc_: hahaha.
03:34:59 <wli> fixed multiplication
03:36:04 <musasabi> hmm this seems more complex. I could use #include + #const, but glibc headers are incompatible with traditional cpp...
03:43:00 <wli> fixity
03:43:13 <wli> okay, things seem to be doing relatively well now
03:46:18 <wli> id :: forall (t :: ??). t -> t
03:46:25 <wli> hmm, what the heck is that?
03:49:48 <wli> Well, apart from defaulting sucking, it seems to be doing okay.
03:50:36 <wli> integer literals don't default as they should
03:53:26 <wli> brilliant
03:53:38 <wli> default is hardwired to Num
03:53:45 <wli> something of the name Num, that is
04:06:40 <wli> another small brilliancy
04:06:56 <wli> *Algebra> :type 0
04:06:56 <wli> 0 :: forall t. (Module Z t, MultiplicativeMonoid t) => t
04:07:08 <wli> *Algebra> 0
04:07:08 <wli> Top level:
04:07:08 <wli>     No instance for (Module Z t)
04:07:08 <wli>       arising from use of `it' at Top level
04:07:22 <wli> you *must* be kidding?
04:10:23 <wli> better yet
04:10:48 <wli> get an instance (Module Z t, MultiplicativeMonoid t) => Num t where fromInteger = ...
04:10:59 <wli> *Algebra> :type 0
04:10:59 <wli> 0 :: forall t. (Algebra.Num t) => t
04:11:10 <wli> *Algebra> 0
04:11:10 <wli> Top level:
04:11:10 <wli>     No instance for (Module Z t)
04:11:10 <wli>       arising from use of `it' at Top level
04:11:16 <wli> #1 there is such an instance
04:11:27 <wli> #2 I've got Num, the defaulting should be there
04:14:50 <wli> isn't :kind in ghci supposed to work on classes, too?
04:15:30 <Lemmih> Nope.
04:16:11 <wli> *Algebra> :kind Natural
04:16:11 <wli> <interactive>:1:0: Not in scope: type constructor or class `Natural'
04:16:30 <wli> this implies such
04:18:37 <wli> brilliant, the Num class name, hardwired to defaulting, is also hardwired to other ghc typeclasses
04:18:52 <wli> (the latter hardwiring not required by the standards)
04:27:54 <aleator> What is the haskell idiom for priority queues when items to be queued are not of Ord type, but instead classified by some function?
04:28:28 <wli> aleator: use Ord and/or Ix on the classifier type
04:29:10 <aleator> wli: classifier type?
04:29:39 <wli> aleator: yes
04:29:59 <wli> aleator: classify :: UnorderedType -> TypeDescribingTheClassItIsIn
04:30:27 <aleator> Ah.
04:30:32 <wli> aleator: Ord TypeDescribingTheClassItIsIn and Ix TypeDescribingTheClassItIsIn should do it
04:30:53 <aleator> Thanks wli.
04:42:37 <wli> hmm, how do you remove a binding made at the prompt via e.g. let x = 1
04:48:13 <wli> These instances overlap pretty badly. It'd be nice if things just defaulted on overlap instead of puking their guts out.
04:48:26 <wli> They do most of the time, or so it seems.
04:49:26 <wli> some of these type constraints are obscene
04:49:36 <wli> let asdf = (((^(Natural 2)) + (3*) + 1) $ (UniPoly [1,1])) $ 3
04:50:30 <wli> asdf :: forall t''. (MultiplicativeMonoid t'', Module Z t'', MultiplicativeMonoid (UniPoly t'' -> UniPoly t''), Module Z (UniPoly t'' -> UniPoly t''), MultiplicativeMonoid (UniPoly t''), Module Z (UniPoly t''), Applicative (UniPoly t'') t'' t'') => t''
04:51:26 <wli> Things need to be able to infer slightly better.
04:51:32 <lightstep> i just got here, but it seems that you defined functions as instances of some classes?
04:52:02 <wli> lightstep: yeah, the "issue" is that the type hierarchy ended up a wee bit clunky from the POV of needing type annotations often
04:52:36 <wli> most notably integer literals can't get echoed back by the ghci repl because various things can't be inferred.
04:53:26 <wli> I don't have a whole lot of time to spend on this so it'll probably get dropped for months in the next 15 minues or so
04:54:37 <lightstep> i never liked the whole type classes thing
04:56:26 <dons> that's a pretty good type :}
04:56:40 <wli> lightstep: http://holomorphy.com/~wli/Algebra.hs
04:59:30 <glimming> Anyone tried to implement duality? E.g. the dual of a functor.
05:00:00 <glimming> instance DualFunctor f  from Functor f ? Any suggestions?
05:02:04 <glimming> Notably the dual of AxB is A+B
05:03:15 <glimming> So data Pair a = Pair (a, a) is a functor with the dual data Sum a = Inl a | Inr a   -- how to make this explicit using Functor -class extensions?
05:03:57 <glimming> Also one could use a class Bifunctor I thinkj
05:04:14 <glimming> TheHunter: maybe what you pasted was a bifunctor?
05:12:50 <tintin> hello all
05:15:48 <lightstep> hello tintin
05:16:04 <tintin> io lightstep
05:26:49 <glimming> Where is Functor defined?
05:40:15 <lightstep> Control.Monad
05:53:46 <glimming> (not in GHC, it is in Base)
05:56:07 <Lemmih> glimming: Don't import GHC.*
06:09:12 <glimming> No but it is imported by Prelude
06:09:14 <glimming> I think
06:09:22 <glimming> I did not find Functor in Control/*
06:09:42 <glimming> Dotnet.lhs in GHS - what is it for?
06:09:51 <lightstep> @info Control.Monad.Functor
06:09:52 <lambdabot> -- Functor is a class
06:09:52 <lambdabot> class Functor f :: (* -> *) where {
06:09:52 <lambdabot>     fmap :: forall a b. (a -> b) -> f a -> f b; }
06:11:27 <glimming> It is exported by Control.Monad
06:11:34 <glimming> but not defined there.
06:11:37 <glimming> in GHS anyway
06:11:56 <TheHunter> glimming, it's in the prelude.
06:12:03 <lightstep> are you looking at a specific file?
06:12:07 <glimming> @info GHS.Functor
06:12:14 <glimming> @info GHS.Base.Functor
06:12:24 <TheHunter> right, the thing i defined was a functor F: CxC -> CxC where C is the category "Haskell"
06:12:37 <glimming> Then I propose
06:12:45 <TheHunter> @info Functor
06:12:46 <lambdabot> -- Functor is a class
06:12:46 <lambdabot> class Functor f :: (* -> *) where {
06:12:46 <lambdabot>     fmap :: forall a b. (a -> b) -> f a -> f b; }
06:13:00 <glimming>   class Bifunctor f where
06:13:00 <glimming>     bmap :: (a -> b) -> (a' -> b') -> f a a' -> f b b'
06:13:08 <glimming> Rather than gadts
06:13:26 <glimming> E.g.   instance (Functor f, Functor g) => Bifunctor (f :**: g) where
06:13:26 <glimming>     bmap f g (BPair (a, b)) = BPair (fmap f a, fmap g b)
06:13:34 <glimming> where
06:13:38 <TheHunter> yeah, that's probably better.
06:13:50 <glimming>   data (f :**: g) o1 o2 = BPair (f o1 ,g o2)
06:14:12 <glimming> So we can make a CxC->CxC bifunctor from any two functors here
06:14:21 <glimming> This should be in Prelude imo
06:15:09 <lightstep> glimming: add it to PreludeExts
06:15:50 <glimming> how do I do that? What is PreludeExts?
06:16:04 <peti> Hi.
06:16:08 <glimming> bimap probably better fhan fmap
06:16:11 <TheHunter> @wiki LicensedPreludeExts
06:16:12 <lambdabot> http://www.haskell.org/hawiki/LicensedPreludeExts
06:16:12 * peti is testing the new ERC version. ;-)
06:19:53 <glimming> ESA: nice adjunction
06:19:55 <doc_modulo> hi
06:20:42 <glimming> esap: nice adjunction
07:08:16 * tmoertel requires tea
07:10:00 <doc_modulo> tea is liquid CRACK!!
07:10:16 * doc_modulo getting tea
07:10:45 <tmoertel> doc_modulo: no, when tea cracks, it's no longer liquid but solid
07:10:59 <tmoertel> doc_modulo: it's that whole "state change" thing, you know  :)
07:12:34 * tmoertel is also getting tea (verily, it is liquid CRACK)
07:26:16 * doc_modulo is back
07:26:43 <doc_modulo> if tea were liquid, I'd shoot it up :)
07:26:50 <doc_modulo> ehm, solid ehm
07:26:52 <doc_modulo> nevermind
07:27:02 * doc_modulo takes a sip
07:27:14 <doc_modulo> tea destroys braincells
07:27:52 <doc_modulo> people, a question:
07:28:29 <doc_modulo> I've decided to program in a Functional Programmming language as much as possible
07:28:46 <doc_modulo> I'm going to make my own server later as part of my own business
07:29:24 <doc_modulo> I will have to make both a game server and a dynamic website server
07:29:38 <doc_modulo> now I've limited my choises to Haskell and Erlang
07:30:11 <doc_modulo> Erlang seems to have better support for actually running servers for a business
07:30:28 <doc_modulo> and Haskell seems to be more of an academic research thing
07:30:54 <doc_modulo> however, Haskell the language itself seems "cleaner"
07:31:30 <doc_modulo> my questions, which language prevents more bugs?
07:32:37 <doc_modulo> 2. is Erlang's dynamic typing like Python's dynamic typing? Is the strict typing in Haskell responsible for catching more bugs?
07:33:38 <doc_modulo> 3. If you had to create servers for a business like the one I'm going to set up, which environment would you choose?
07:35:13 <doc_modulo> 4. Is it a good idea to go with Haskell first to learn functional programming and then switch over to Erlang if it's needed, or is it better to just go with Erlang from the beginning?
07:35:32 <doc_modulo> thanks in advance
07:40:03 <wilx> If you want Erlang you start with Erlang.
07:40:19 <wilx> Haskell and Erlang are too different imho.
07:40:41 <doc_modulo> you looked at both?
07:40:57 <doc_modulo> well, you are into Haskell, but looked at Erlang?
07:42:25 <wilx> I am not too much into either but I have looket at both.
07:42:57 <doc_modulo> I think I will go with Erlang, the more I read, the more my mind is swayed that way. The reason is because I need a lot of stuff done FOR me as I'm going to be the sole programmer of my company in the beginning
07:43:04 <wilx> They are just too different for anybody to hope to switch without having to re-learn most of everything.
07:43:26 <doc_modulo> that's good advice before starting to learn either
07:43:36 <doc_modulo> glad I asked
07:44:28 <doc_modulo> I DO believe that Haskell would be a better language after a few more years of changing it, as far as correctness and as a language for the future.
07:44:55 <doc_modulo> However, I'm coming at this from the perspective of purely a language user, not a researcher.
07:45:17 <doc_modulo> I'm saying this becuase it is a bit rude to ask mostly Erlang questions in #haskell :)
07:46:45 <Itkovian> aft'noon
07:47:05 <doc_modulo> lo
07:57:44 <doc_modulo> I was distracted earlier by my tea, what I wanted to say was, if Tea were a solid, I'd smoke it :)
07:58:22 * musasabi came to haskell from Erlang
07:59:12 <doc_modulo> musasabi: what do you think of the difference between dynamic and strict typing, is it a hassle to check for errors during runtime?
07:59:26 <musasabi> Haskell is a much nicer language, but Erlang has a better library support for many things. (but e.g. for GUI Haskell gives more options and the ffi is easier)
08:00:16 <musasabi> doc_modulo: error handling is very clean in Erlang because of the nice library.
08:01:58 <doc_modulo> It looks like Haskell is the top language in existence at the moment, but for a business like my future one, Erlang seems better at the moment. It is still a FP language
08:03:58 <doc_modulo> what direction is Haskell moving into? The automatic clustering of Erlang is a very convenient feature for me, is the Parallel Glasgow Haskell Compiler in active development?
08:04:59 <doc_modulo> advantages of clustering is that it's easier to make a reliable server, if 1 of your cluster PCs dies, your "server" will only slow down, not crash
08:05:13 <doc_modulo> and if you want to speed up your "server" you just add PCs to the cluster
08:05:38 <doc_modulo> it's the way Google works, I think
08:06:07 <musasabi> Distributed haskell is developed in a number of directions by various academic groups.
08:06:08 <doc_modulo> and thank you musasabi
08:06:45 <musasabi> But if you want something distributed now I would go with erlang.
08:07:10 <doc_modulo> that's what I figured, andres said something like that yesterday when I explained my situation
08:07:22 <doc_modulo> but I was in love with Haskell
08:07:29 <doc_modulo> *sniff*
08:08:39 <doc_modulo> it's a damn shame when stuff like this happens, it's what happening in a more broad sense with FP languages that are inherently better, but Java that has more applicable value "at the moment" for businesses (at least they look at it that way)
08:10:53 <doc_modulo> but, I think, in the end, Haskell will come out on top. It's just better in almost all respects. Either Haskell is the future of programming, or something that doesn't exist yet.
08:13:14 <doc_modulo> another subject: I've been trying to figure out how you actually implement a program in a FP language. There are of course several ways of processing data but is this one of them:
08:14:49 <doc_modulo> there is a "controller" part of the program that doesn't change much/basically set in stone. To process some data, you can pattern match for what kind of data it is, and then process it with a certain part of the program you made beforehand
08:15:12 <doc_modulo> forget the controller part in that sentence
08:16:03 <doc_modulo> but if you pattern match, everything you ever wanted to do with the program has to be thought of beforehand and made into a processing structure for a certain pattern of data
08:16:30 <doc_modulo> and be made ready in memory for the processing of that data
08:16:45 <doc_modulo> (I'm not a programmer yet so bare with me plz)
08:17:08 <doc_modulo> but if you want to make your program a bit more dynamic, would this be the way:
08:18:33 <doc_modulo> first you get settings from the outside world and encapsulate them in monads, the info in the monads is then used to create a piece of Haskell (or runtime equivalent) / a custom filter for the data you're about to process
08:18:55 <doc_modulo> is that a common way to program in FP?
08:19:28 <doc_modulo> I can explain more fully what I meant if it's not clear
08:22:16 <musasabi> Many times I find myself defining a DSL and then programming the progam using it.
08:23:06 <doc_modulo> DSL?
08:23:42 <musasabi> domain specific language
08:23:47 <doc_modulo> ah
08:24:41 <doc_modulo> another good thing in Haskell, is that a prominent feature in Erlang as well?
08:29:06 <doc_modulo> In any case, it looks like I'm going to go with Erlang as my first FP language. Later, as Haskell gets the features I need like mature clustering and maybe more realtime features, I'll be able to switch over (although it will be hard).
08:29:43 <doc_modulo> But better that method than start out with Java
08:31:06 <doc_modulo> it's time for more tea!!1
08:31:40 <boegel> hey humasect
08:32:00 <humasect> hey boegel
08:32:25 <xerox> hey hey
08:32:28 <boegel> how's code?
08:32:59 <humasect> which code now? T_T
08:33:12 * Lemmih throws a lambda after wxHaskell.
08:33:34 * xerox joins the throw-the-lambda game
08:34:39 <Lemmih> xerox: Ten points for hitting wxHaskell is the balls. (watch out! they're bouncing)
08:34:41 * boegel offers gtk2hs
08:34:54 <boegel> hey Philippa
08:34:59 <Lemmih> boegel: gtk2hs is not very windows friendly.
08:34:59 <boegel> how's the bf ?
08:35:09 <boegel> Lemmih: it's coming dough...
08:35:18 <boegel> there a beta windows installer available
08:35:43 * Lemmih needs stable software in this case.
08:35:48 <boegel> Lemmih: Also, I've uploaded a rather experimental binary version.
08:35:48 <boegel> >
08:35:48 <boegel> > http://gtk2hs.sf.net/gtk2hs-0.9.7.1_rc1.win32.zip
08:35:52 <Lemmih> Which kinda rules out wxHaskell (:
08:36:18 <humasect> o_o
08:36:21 <boegel> I believe gtk2hs if much better than wxHaskell... and they're working hard on a windows installer
08:36:51 <Lemmih> I don't really feel like porting all my code, atm.
08:38:02 <boegel> Lemmih: what kind of gui are you building ?
08:38:12 <musasabi> packaging code for windows is harder than for other platforms :-(
08:39:23 <boegel> musasabi: I think gtk2hs will have a full windows installer within the week
08:41:46 <musasabi> boegel: having to create separate installers for all packages does not sound very friendly ;)
08:41:58 <musasabi> maybe cabal could help with that...
08:44:58 <boegel> musasabi: how do you mean for all packages ?
08:46:54 <musasabi> boegel: meaning that you have to actually write an insteller program. (or does msi work?)
08:47:18 <boegel> I believe they're trying msi
08:48:22 <musasabi> Would it be possible to do cabal -> msi ?
08:48:23 * pesco greets.
08:48:30 <musasabi> hello pesco
08:48:40 * boegel doesn't know
08:48:43 <pesco> Hi musasabi. What's up?
08:48:45 <boegel> I've never used cabal
08:50:15 <musasabi> just coding up and down.
08:57:06 <CosmicRay> shapr: can I pick your brain about haskell web stuff?
09:04:23 <musasabi> gah, MSI appears to be a complex beast.
09:05:32 <Philippa> CosmicRay: would I be of any use?
09:06:06 <Philippa> boegel: 'mafraid you saw my client logging back in after a dropped connection. Damien's okay
09:06:53 <boegel> Philippa: okay, I was just making conversation :p
09:09:53 <CosmicRay> Philippa: maybe so
09:10:03 <CosmicRay> Philippa: I'm going to need to write a web application.
09:10:14 <CosmicRay> Philippa: I need basic session tracking, form parsing, and html generation
09:10:23 <CosmicRay> Philippa: I've found CGI libraries that will be ok for my use
09:10:36 <CosmicRay> so I'm mainly concerned with session tracking and html generation
09:10:48 <CosmicRay> I think I may be able to do the html generation with HaXML but I haven't really looked into that yet
09:11:03 <CosmicRay> are there any frameworks other than WASH for this sort of stuff?
09:11:28 <doc_modulo> the Erlang movie is old-school but interesting :)
09:17:20 <Philippa> CosmicRay: I've found Text.Html tolerable for HTML generation, not really looked at session tracking
09:18:48 <Philippa> I'd be tempted to bung the session data in a file per session and run a clean-up script to pick up the expired ones
09:19:05 <Philippa> then just use a cookie with a session-id
09:19:33 <musasabi> I had something similar to that.
09:20:32 <Philippa> that said, I should generally be considered an occasionally-enthusiastic amateur when it comes to anything web-based
09:20:42 <Philippa> as by and large I have no particular reason for caring :-)
09:20:43 <SyntaxNinja> good morning
09:21:37 <musasabi> http://youzen.b2.fi/~musasabi/s.hs
09:22:51 <Philippa> how were you checking session expiry (if any)?
09:23:33 <musasabi> Philippa: a script in cron killing old sessions (timestamps).
09:23:59 <Philippa> figures :-)
09:24:16 <musasabi> the way of the least resistance.
09:26:26 <Philippa> I'd be inclined to keep an explicit expiry etc in the session as well, but maybe that's just me being paranoid
09:30:52 <goron> > Am I correct that perl5-porters is the proper forum for submitting
09:30:52 <goron> > my ideas?
09:30:52 <goron> I think you didn't get a reply because you used the terms "correct" and
09:30:52 <goron> "proper", neither of which has much meaning in Perl culture. :-)
09:30:53 <goron>             --Larry Wall
09:32:23 <Philippa> thus explaining all the buggy perl code out there?
09:37:15 <jlouis> Philippa: yes, and the lack of typing
10:21:23 <doc_modulo> just to throw this in the group, it would be great if Haskell could keep the quality of the language itself but gain the features of Erlang: * Distribution
10:21:23 <doc_modulo> * Fault Tolerance
10:21:23 <doc_modulo> * Massive Concurrency
10:21:23 <doc_modulo> * Soft Real Time
10:21:23 <doc_modulo> * Non Stop (For Upgrades / Patch Installation / Crashes)
10:22:42 <doc_modulo> real time might be extremely hard, but the rest is possible
10:22:52 <doc_modulo> (I'm guessing)
10:23:03 <Lemmih> Feel free to send patches.
10:23:06 <CosmicRay> heh
10:23:08 <doc_modulo> :)
10:23:09 <goron> :-)
10:23:23 <CosmicRay> doc_modulo: I've never used erlang, but I know periphally of its purpose
10:23:32 * goron remembers something about GPL and Lemmih :)
10:23:39 <CosmicRay> doc_modulo: for tasks that don't require any of the above, how do you think it compares to haskell?
10:23:46 <Lemmih> goron: huh?
10:23:48 <gzl> to what extent are functional language features orthogonal? (in the sense that you can have one or the other but not both)
10:24:03 <CosmicRay> gzl: what sort of features do you mean, gzl?
10:24:24 <gzl> I mean anything nontrivial (something trivial is single inheritance vs multiple inheritance)
10:24:37 <gzl> is that too vague?
10:24:46 <CosmicRay> gzl: we'll see :-)
10:24:51 <doc_modulo> CosmicRay: Erlang is not as nice a language as Haskell (speaking as noob), because I think strict typing helps prevent bugs
10:25:21 <CosmicRay> gzl: I suppose to start with the highest level, being a functional language doesn't imply many other features save being able to pass functions, closures, and optimization of tail recursion
10:25:33 <musasabi> haskell has got:
10:25:35 <CosmicRay> doc_modulo: so erlang has weak typing, ala perl?
10:26:03 <doc_modulo> gzl: as far as I read, it is difficult to implement real-timeness in combination with Haskell's lazy evaluation
10:26:22 <musasabi> * Massive concurrency - sometimes even faster than erlang ;)
10:26:23 <doc_modulo> but I also read on research to improve real-time of haskell
10:26:39 <doc_modulo> for multimedia
10:26:53 <CosmicRay> musasabi: do you mean gph or what we already have in Control.Concurrent?
10:26:55 <doc_modulo> or maybe not real-time, but more timing
10:27:04 <musasabi> soft real time is not very well defined. In general neither erlang nor haskell is realtime but you can make them appear so.
10:27:16 <musasabi> CosmicRay: what we have in Control.Concurrent.
10:27:26 <musasabi> CosmicRay: MVars are very very fast.
10:27:43 <musasabi> of course that is comparing apples to oranges ;)
10:28:15 <gzl> CosmicRay: well I don't just mean core features. i mean, OCaml has some strengths and Haskell has some strengths (that the other doesn't have). is there any reason you can't have most of the strengths in both?
10:29:24 <CosmicRay> gzl: well, let's take one strength of ocaml: blazing fast speed.  It is probably not possible to get this in haskell.  ocaml's lists are highly optimized and are not lazy.  Its streams are lazy but are probably slower than haskell's lists
10:29:28 <goron> Lemmih: I thought you once said that with GPL software you could just say: well, you can patch it yourself, or something like that. It could also had been shapr....
10:29:49 <doc_modulo> I think having imperative parts in the language prevents it from having the ability to "automatically use multiprocessors" like Erlang and Distributed/parallel Haskel does
10:30:05 <goron> Lemmih: <shapr> That's one reason I'ma fan of the GPL. ...
10:30:11 <gzl> CosmicRay: hm, how would you compare ocaml's speed to other nonfunctional languages?
10:30:26 <goron> Lemmih: Ok, that was shapr. Excuse me.
10:30:27 <Lemmih> goron: ah (:
10:30:28 <CosmicRay> gzl: a lot of things are made possible by having lazy lists in haskell, though.  things like getContents don't work in ocaml (it could probably work with streams in ocaml though)
10:30:46 <CosmicRay> gzl: superior to most.  It occasionally outperforms c++ code, and even rarely outperforms C code.
10:31:06 <musasabi> of course one can use seq ;)
10:31:13 <wli> *Lentz> let f x = let { as = repeat (x^2) ; bs = 2:map (+4) bs } in lentz (as!!) (bs!!) :: Double in let x = pi/3 in (f x, x/tanh(x/2), abs (f x - x/tanh(x/2)))
10:31:13 <wli> (2.1795148420575217,2.1795148420575226,8.881784197001252e-16)
10:31:19 <wli> for instance, that
10:32:01 <CosmicRay> musasabi true, but that still doesn't bring the performance of ocaml
10:32:20 <musasabi> CosmicRay: compiler optimizations ;)
10:32:27 <CosmicRay> gzl: there is no doubt in my mind that ocaml is faster than haskell, and that haskell is faster than ocaml
10:32:29 <gzl> CosmicRay: wow, didn't know it was that fast
10:32:30 <wli> infinite lists are just another way of writing loops
10:32:33 <CosmicRay> musasabi: send me the patches :-)
10:32:57 <musasabi> most of the ocaml speed advantage comes from custom call convention using registers (that is why it can beat C sometimes).
10:33:20 <wli> -mregparm=3 puts C on equal footing
10:33:30 <doc_modulo> musasabi: you say that massive concurrency feature is also already in Haskell. About the other features:
10:33:32 <CosmicRay> musasabi: I think it also has a very efficient in-memory representation for common data structures
10:33:42 <musasabi> CosmicRay: true.
10:33:43 <doc_modulo> * distribution: DGHC ?
10:34:09 <CosmicRay> of course, all this speed for ocaml comes at a cost
10:34:17 <CosmicRay> it doesn't have typeclasses, and probably couldn't.
10:34:17 * musasabi hasn't found a satisfactory answer to distributed systems inside haskell.
10:34:24 <doc_modulo> * fault tolerance: Can you replace parts of code in a running system?
10:34:43 <CosmicRay> basic things that we use all the time in haskell, such as read and show, are flat impossible in ocaml
10:34:59 <gzl> CosmicRay: why?
10:35:01 <doc_modulo> musasabi: are they still working on it?
10:35:01 <musasabi> doc_modulo: with hs-plugins you can, but it does not protect you against shooting yourself in the foot.
10:35:13 <CosmicRay> gzl: because read and show require typeclasses, which ocaml doesn't support
10:35:30 <musasabi> CosmicRay: type-classes are not that hard to implement.
10:35:37 <jlouis> I think they provided something which is printf style
10:35:39 <doc_modulo> anything involving shooting your own bodyparts should be avoided
10:35:46 <wli> gzl: BTW, these continued fractions rock
10:35:50 <CosmicRay> jlouis: that is a hack in the compiler itself
10:35:54 <gzl> CosmicRay: no, I mean, why couldn't it support them
10:36:02 <CosmicRay> jlouis: it is not possible to write their printf in ocaml
10:36:02 <gzl> wli: "these" continued fractions?
10:36:02 <jlouis> Even in SML you can simulate it quite simple
10:36:14 <gzl> wli: did I speak with you about continued fracitons before? can't remember
10:36:15 <musasabi> actually the haskell typeclass implementation would work in ocaml if I understand things correctly.
10:36:22 <CosmicRay> gzl: of course it could, but the current runtime representation doesn't provide enough information to do so
10:36:28 <wli> gzl: I've smoked out a bunch of useful continued fraction approximations to things
10:36:49 <wli> gzl: main thing is to doublecheck floating points results when things don't work
10:36:56 <gzl> wli: I'm just puzzled because I organized a talk on doing stuff with continued fractions just a few days ago
10:36:59 <musasabi> CosmicRay: a typeclass is just an extra parameter that is a record containing the functions that the typeclass defines (at the implementation level).
10:37:26 <wli> gzl: kick ass
10:37:37 <wli> gzl: what are you doing with them?
10:37:44 <gzl> i'm not doing anything
10:37:53 <gzl> the speaker was talking about using them to approximate real numbers
10:37:55 <wli> gzl: what is the presentation doing with them?
10:38:03 <CosmicRay> musasabi: hmm, that does make sense.
10:38:08 <wli> gzl: okay, is this for computational purposes?
10:38:09 <gzl> yes
10:38:11 <CosmicRay> well then I don't know why ocaml doesn't do that
10:38:31 <CosmicRay> I always assumed it was because typing information was lost too early in the process
10:38:38 <wli> gzl: Look for HAKMEM.TXT and the continued-fraction -oriented add-on to HAKMEM.TXT
10:38:41 <wli> gzl: also
10:38:59 <wli> gzl: there's a Haskell module implementing the stock algorithms, but not the continued logarithm algorithms
10:39:08 <CosmicRay> attempts at making an equivolent for show in ocaml always have serious flaws -- it's impossible to distinguish a 0 from an empty list, an int, or the false value, for instance
10:39:10 * musasabi thinks it is because ml aproaches polumorphism in a different way 
10:39:11 <wli> gzl: I've posted about it. =)
10:39:13 <gzl> ok. I don't really need it myself, but maybe I'll check it out at some point.
10:39:19 <CosmicRay> musasabi: via modules?
10:39:25 <musasabi> yes.
10:39:31 <gzl> if you've heard of mj dominus, he was the guy who gave the talk
10:39:39 <wli> gzl: It turns out that it's not terribly useful due to certain nontermination conditions, e.g. subtracting equals from equals yields nontermination
10:39:45 <CosmicRay> musasabi: I don't know why, but I've seen that used very infrequently in ocaml.
10:40:00 <CosmicRay> musasabi: in fact, I've only read about it.  Never actually seen it in use.
10:40:02 <musasabi> it is used at least in SML.
10:40:10 <jlouis> musasabi: ml has parametric (implicit) polymorphism via hindley-milner inference. It does not have overloading apart from a few exceptions (+, -, etc)
10:40:19 <wli> gzl: Also, squaring an infinite continued fraction that yields a rational result is also a nonterminating operation
10:40:24 <CosmicRay> jlouis: ocaml doesn't overload + and -
10:40:31 <jlouis> CosmicRay: I know, but SML does
10:40:39 <gzl> oh man, not overloading + and - is really annoying.
10:40:41 <CosmicRay> jlouis: you must say 5 + 3 or (iirc) 5.5 +. 3.3
10:40:46 <CosmicRay> gzl: yes, it is.
10:40:47 <gzl> yeah it's +.
10:40:48 <gzl> and *.
10:40:48 <jlouis> CosmicRay: exactly
10:40:53 <gzl> very irritating
10:40:56 <wli> gzl: BTW I got Algebra.hs working, same URL
10:41:00 <gzl> wli: cool
10:41:22 <wli> gzl: I also put up my Grobner basis solver, http:///holomorphy.com/~wli/Poly.hs
10:41:34 <wli> feh
10:41:40 <wli> gzl: http://holomorphy.com/~wli/Poly.hs
10:41:40 <gzl> cool, i'll check them out.
10:41:51 <doc_modulo> personal opinion as a user, not a builder of Haskell: The future of hardware is not faster and faster single processors until they burn your house if a fan breaks. It's in multi(core)processors. that are relatively slow, but divide computations among themselves. All imperative languages are too difficult to program for that architecture. FP like Haskell could use multiprocessors automatically.
10:42:09 <jlouis> The SML module system is very good. It can probably be used to simulate type classes, although more keyboard-typing is involved in doing that
10:42:19 <doc_modulo>  If you're looking for the killer feature to promote Haskell with, my vote would go to distributed/parallel computing automatically
10:42:40 <doc_modulo> I can't see hardware going any other way than multiprocessing
10:42:45 <wli> jlouis: I'd literally like to have both SML-ish modules and Haskell type classes even if they are somewhat redundant.
10:42:48 <musasabi> eden does that kind of stuff.
10:43:14 <jlouis> wli: that could be a good feature
10:43:28 <doc_modulo> musasabi: eden does automatic multiprocessing?
10:43:29 * musasabi is more interested in interacting potentially hostile peers i.e. in scenarios where transparency is not desirable.
10:43:37 <jlouis> doc_modulo: Me neither. You need a good distributed/parallel environment these days
10:44:23 <musasabi> doc_modulo: http://www.mathematik.uni-marburg.de/~eden/
10:44:25 <doc_modulo> yeah, for example, google never goes down because their "server" is thousands of PCs, if one breaks, they just take it to the shop and work on it at leasure
10:44:29 <gzl> are there any proof assistants for haskell? stuff that helps you prove statements by unfolding/folding definitions?
10:44:30 <CosmicRay> doc_modulo: doesn't haskell already do this?
10:44:34 <doc_modulo> musasabi: thanks
10:44:34 <CosmicRay> doc_modulo: http://www.haskell.org/ghc/docs/latest/html/users_guide/sec-using-parallel.html
10:44:42 <wli> more like they junk 'em
10:44:48 <CosmicRay> doc_modulo: my reading of that is that haskell code is already able to automatically scale to n cpus
10:44:53 <doc_modulo> CosmicRay: I think they're working on it
10:45:02 <doc_modulo> or already possible
10:45:11 <CosmicRay> doc_modulo: and the cpus could be on up to n machines
10:45:17 <doc_modulo> CosmicRay: musasabi: reading
10:45:21 <wli> scaling is not a "yes/no" answer
10:45:28 <wli> scaling is also not a single number
10:45:32 <wli> scaling is a function
10:45:47 <doc_modulo> as a feature you can say, it has it yes/no right?
10:45:55 <wli> f(1) = 1, and 0 < f(n) < 1 for all n > 1. n is an integer.
10:46:30 <wli> It's the fraction of the time it takes to run the workload on a uniprocessor when you run it on an n processor system.
10:46:32 <doc_modulo> musasabi: how is eden as a programming language in your opinion?
10:46:53 <doc_modulo> wli: yes, but harware will reach a limit as uniprocessor
10:47:11 <wli> you basically want to characterize f(n) as g(n) + O(h(n)) for known g(n) and h(n)
10:47:16 <musasabi> doc_modulo: the papers looked nice, but I haven't touched it really and I am not very qualified in parallel scientific computing.
10:47:27 <musasabi> CosmicRay: gph/gdh/... seems to be different research groups doing papers and developing different (incompatible) extensions which slowly bitrot until a new groups creates yet-another-parallel haskell.
10:47:57 <doc_modulo> how is Erlang distributed processing different from Eden?
10:48:04 <kosmikus> CosmicRay: are you working on an lhs2TeX debian package? (google has some results which looke that way ...)
10:48:17 <CosmicRay> kosmikus: yes, it is in incoming
10:48:31 <kosmikus> CosmicRay: for 1.9, or 1.10pre ?
10:48:42 <doc_modulo> musasabi: extensions which slowly bitrot until a new groups creates yet-another-parallel haskell.  <- looks that way yeah, different implementations at least
10:48:43 <tuomov> would anyone happen to have any experience on all the sourceforge (which itself is out of question) clones? e.g. berlios.de as it supports svn
10:48:47 <musasabi> doc_modulo: works in commercial settings with support and many deployment in different places.
10:49:00 <CosmicRay> kosmikus: I don't recall right off hand, but I rarely package up pre fersions, and probably haven't in this case
10:49:13 <doc_modulo> musasabi: and eden still in research phase you said
10:49:16 <tuomov> (I need a new mailing list provider)
10:49:29 <kosmikus> CosmicRay: ok, please tell me if it's officially available, so that I can put that on the page
10:49:31 <CosmicRay> tuomov: alioth.debian.org may be useful for you
10:49:36 <kosmikus> CosmicRay: and thanks
10:49:41 <tuomov> but isn't it for debian projects only?
10:49:45 <musasabi> doc_modulo: eden is a research project, erlang distribution is designed for a real world need.
10:49:46 <tuomov> or projects of debian developers?
10:49:47 <CosmicRay> kosmikus: it is not in debian yet.  new packages take up to a month to get into it
10:49:54 <musasabi> doc_modulo: so they have different priorities.
10:50:05 <wli> one seriously iffy thing about typeclasses is the scoping
10:50:06 <CosmicRay> tuomov: no, it's open to any free software developers.
10:50:25 <doc_modulo> musasabi: thanks for clarifying
10:50:30 <Igloo> It's at least easier to have a DD advocate the project
10:50:37 <Igloo> I'm not sure if it's actually necessary or not
10:50:43 <kosmikus> CosmicRay: I know ... that's why I ask for a notification when it is :)
10:50:51 <tuomov> I googled about it and only found the original announcement that said it was only for debian projects, and then some complaint that although the homepage doesn't say anything, it isn't open
10:51:04 <tuomov> but if it really is open, that's great
10:51:24 <musasabi> doc_modulo: you won't probably find "interesting" stuff in the erlang implementation - only things that are tested and known to work well in different settings.
10:51:27 * CosmicRay suddenly puts together who kosmikus is and why he's interested in this :-)
10:51:32 <CosmicRay> kosmikus: will do :-)
10:51:38 <kosmikus> CosmicRay: :)
10:52:00 <musasabi> doc_modulo: on the other hand various parallel haskell implementations are usually driven by research...
10:52:28 <CosmicRay> tuomov: I'm 98% sure that it really is open
10:53:00 <doc_modulo> musasabi: the advantage of corporations steering a language and runtime is that those systems are nicely "packaged up" into a complete working system. As you said Haskell's non-commercial distributed systems are fragmented
10:53:03 <Igloo> tuomov: What's this for, anyway?
10:53:10 <CosmicRay> tuomov: if you look at the top projects on the home page, you see a bunch that aren't directly related to debian... minicom, orinoco drivers, sane, outlook folder conversions, etc.
10:53:29 <tuomov> but they could have a debian developer is significant member
10:53:40 <doc_modulo> well, advantage for me, a language user, not researcher
10:53:47 <tuomov> Igloo: I need a new mailing list provider for ion, I could just as well switch to one of these sf clones almost completely
10:53:50 <wli> Who's kosmikus?
10:54:02 <CosmicRay> tuomov: minicom doesn't appear to
10:54:19 <CosmicRay> wli: andres loeh, author of lhs2tex
10:54:24 <wli> spiffy
10:54:29 <CosmicRay> and my apologies for not knowing how to type an umlaut
10:54:30 <wli> screw minicom
10:54:31 <wli> ser2net
10:54:35 <doc_modulo> I think distributed Haskell could do with some centralisation, speaking purely as someone who's feature horney but has nothing to contribute
10:54:53 <tuomov> http://www.kuro5hin.org/story/2004/4/26/222354/580
10:54:54 <wli> seriously, don't even think about minicom; ser2net
10:55:07 <tuomov> "f you're working on a Debian project, Alioth is another option. They don't say anywhere on the site that it's specific to Debian projects, but (as I found out the hard way) your project will be rejected if it isn't, citing a TOS document that's 404."
10:55:09 <CosmicRay> wli: uhm, that doesn't even come close to doing many things that minicom does
10:55:22 <CosmicRay> hum.
10:55:44 <tuomov> that and the original announcement are all information I could find on it
10:56:02 * ibid got my first ever mail from a local court of law today :)
10:56:04 * CosmicRay asks around a bit
10:56:18 <Igloo> If you want to ask the admins if it would be accepted then #debian-alioth either here or OFTC would be the place to ask, I think
10:56:36 <CosmicRay> nobody in that channel either place
10:56:40 <CosmicRay> I already checked :-)
10:56:49 <Igloo> Err, do I mean #alioth then?
10:56:53 <CosmicRay> tried that too
10:57:08 <wli> CosmicRay: I'm unaware of the features of minicom it does not implement (only the 1 incredibly important feature it has that minicom does not).
10:57:31 <Igloo> Well, something certainly used to exist, at least  :-)
10:58:00 <CosmicRay> wli: [xyz]modem downloads, phone books and automatic dialing, strict ansi emulation needed for some BBSs, to start.
10:58:29 <wli> Okay, I can see why I never noticed them gone.
10:58:38 <wli> BBS's still exist?
10:58:45 <CosmicRay> sure
10:59:01 <wli> Or, for that matter, anything you'd need dialing/etc.
10:59:17 <CosmicRay> any number of proprietary dial-up systems still exist for a host of reasons
10:59:36 <CosmicRay> heck, I maintain one for my employer that can give me a shell for troubleshooting remotely if the network is down
10:59:48 <CosmicRay> and sometimes being able to spontaneously transfer a file is a useful thing in that situation
10:59:58 <glimming> how do you use @ together with .  in an effective way?
11:00:01 <CosmicRay> type sz filename on the server, and poof, instant download.
11:00:32 <basti_> yes the golden times
11:00:47 <wli> CosmicRay: I only ever use serial ports in conjunction with terminal concentrators, e.g. Cisco 2511, Cisco 3640, Digi CM48, etc.
11:01:01 * basti_ had a terminal program with autmatic z modem transfer recognition
11:01:18 <basti_> the fact that i remember that gives away that there was a program BEFORE that.
11:01:31 <CosmicRay> basti_: heh
11:01:36 <glimming> also I am writing a book on AFP. Send me suggestions on what to include to glimming@kth.se
11:01:42 <CosmicRay> wli: yep, I can see why ser2net would be fine for you
11:01:53 <wli> basti: what, like cu, or uucp?
11:02:04 <glimming> is this out of topic?
11:02:06 <basti_> wli: actually that was before my first *nix contact =)
11:02:07 <CosmicRay> basti_: most of the old terminal programs had that.  course [xy]modem usually weren't automatically recognized
11:02:21 <basti_> i know.
11:02:26 <basti_> been there, done that.
11:02:29 <CosmicRay> glimming: we're lazy about everything here.  we don't get back to haskell unless forced to by the need to evaluate discussion :-)
11:02:44 <glimming> right so let's @
11:02:55 * CosmicRay has no idea what @ means outside of a type declaration
11:03:13 <glimming> it forces application
11:03:19 <glimming> I think?
11:03:25 <CosmicRay> are you thinking of $?
11:03:35 <glimming> yes indeed, sorry.
11:03:35 <CosmicRay> just $, not dollar-questionmark
11:03:46 <glimming> the question is, how to use $ and . effectively.
11:03:53 <CosmicRay> ok, this could be why you got no responses :-)
11:03:57 <mflux_> just plain dollar-comma?
11:04:02 <CosmicRay> bah
11:04:13 <wli> gzl: Anyway, continued fractions are *incredibly* effective numerical approximations
11:04:15 <CosmicRay> glimming: well let's start with .
11:04:27 <glimming> also please report on progress with setting up Haskell .NET
11:04:32 <mflux_> haskell should support defining whitespace.
11:04:33 <glimming> I know .
11:04:38 <CosmicRay> actually, I think YAHT has some pages on this topic...  have you checked out http://www.isi.edu/%7Ehdaume/htut/?
11:04:52 <CosmicRay> glimming: I don't know that anybody here has tried that, you may wish to ask on -cafe
11:04:57 * Igloo doesn't understand what's being asked
11:05:07 <glimming> Oh, it's supported I think!
11:05:08 <CosmicRay> Igloo: glimming wants to understand . and $
11:05:20 <CosmicRay> yes, there is code in both hugs adn ghc for .net interop
11:05:23 <glimming> e.g. f.g $ x
11:05:27 <CosmicRay> afaik it only works on windows
11:05:34 <glimming> but It might be that I used @....
11:05:42 <glimming> @ was more logical since it was a as in apply.
11:05:42 <lambdabot> Sorry, I don't know the command "", try "lambdabot: @listcommands"
11:05:43 <CosmicRay> could be, f . g $ x is valid
11:05:52 <glimming> oops.
11:05:56 <CosmicRay> glimming: also the spaces often annot be ommitted
11:06:03 <glimming> so $ binds less hard than .
11:06:04 <glimming> good.
11:06:07 <glimming> so that's why we need it.
11:06:11 <glimming> what spaces?
11:06:13 <wli> gzl: the main thing I'd be interested in is doing some extended software floating point type for verification of numerical algorithms (this is mainly when there are good error bounds)
11:06:19 <glimming> f.g$x
11:06:23 <CosmicRay> you can't write f.g$x but you can write f . g $ x
11:06:28 <glimming> means f(g(x))?
11:06:32 <Igloo> You can write both
11:06:34 <musasabi> I think there was discussion on haskell + .net on -cafe@ (or haskell@) in january.
11:06:38 <wli> gzl: or (secondarily) using huge amounts of precision to compensate for numerical crappiness
11:06:44 <Igloo> A.x is different to A . x, though
11:06:46 <glimming> so $ is to eliminate brackets?
11:06:49 <CosmicRay> Igloo: no, ghc will complain something weird about $x
11:06:58 <CosmicRay> glimming: let's break this down first
11:07:03 <Igloo> Oh, if you turn on all the extensions, sure
11:07:14 <glimming> Iglooo : hhwhat?
11:07:15 <musasabi> glimming: there are two problems 1) either generate untrusted or slow code 2) port the whole rts.
11:07:18 <Igloo> But if you do that you're asking for the compiler to thwack you on the head with a rhino anyway
11:07:19 <duncan> CosmicRay: $x should be ok unless you're using Template Haskell...
11:07:28 <CosmicRay> duncan: I'm not, but it complains anyway
11:07:40 <CosmicRay> glimming: do you understand what f . g means?
11:07:44 <Igloo> Prelude> id.id$4
11:07:44 <Igloo> 4
11:07:49 <Igloo> WFM (in ghci)
11:07:54 <CosmicRay> glimming: in haskell terms, (f . g) x is the same as f (g x)
11:07:55 <glimming> I have come across function composition, yes.
11:08:13 <kosmikus> hi duncan .. how's the quiz?
11:08:25 <glimming> hi kosmikus
11:08:37 <duncan> kosmikus: ah yes, that's what I was finnishing off this evening...
11:08:48 * Igloo wonders what quiz
11:09:05 <CosmicRay> glimming: ok.  you can just say (f . g) x, or you can say f . g $ x
11:09:11 <glimming> how can A.x be different to A . x
11:09:17 <kosmikus> hej glimming
11:09:22 <Igloo> A.x is x from module A
11:09:25 <CosmicRay> glimming: $ is merely syntactic sugar
11:09:28 <duncan> kosmikus: sorry, I've been busy with PhD work (Igloo can attest to that)
11:09:31 <glimming> right.
11:09:38 <glimming> Sure, but useful for non-Lispers.
11:09:42 <Igloo> kosmikus: Nah, he hasn't done any work in /weeks/
11:09:45 <glimming> Btw, A Little Lisperer is a cool book
11:09:45 <kosmikus> duncan: I understand perfectly ... no reason to apologise
11:10:01 <Igloo> There are rumours he's just taken the money and skipped the country
11:10:06 <CosmicRay> glimming: the stuff to the left of $ makes up a function.  The stuff to the right of $ makes up its parameters.
11:10:10 <duncan> Igloo: plwdbh!
11:10:17 <Igloo> :-)
11:10:22 <glimming> ok got it.
11:10:25 <CosmicRay> glimming:  f . g x is not valid, because (g x) is not a function, and . operates on functions
11:10:26 <glimming> I used @ that's the prob
11:10:29 <kosmikus> Igloo: :)
11:10:30 <duncan> :-)
11:10:36 <musasabi> of course "a $ b c" fails in some cases where "a (b c)" is safe.
11:10:57 <glimming> so another Q, even easier
11:11:01 <glimming> Why guards for Int?
11:11:14 <CosmicRay> musasabi: well it depends on what you want, no?  a $ b c means something different than a (b c)
11:11:16 <kosmikus> the way Oxford colleagues support each other is legendary ;)
11:11:31 <glimming> Did kosmikus study in Oxford ?
11:11:56 <Igloo> I was clearly joking. The amount they pay us we couldn't even afford to swim to another country.
11:12:24 * glimming confused
11:12:30 <Igloo> glimming: No, duncan and I do
11:12:44 <glimming> Nice, I studied there at Lincoln.
11:12:48 <glimming> Are you in for a DPhil?
11:12:51 <musasabi> CosmicRay: true.
11:12:52 <Igloo> Yup
11:13:08 <glimming> Both DPhil:erers?
11:13:13 <duncan> kosmikus: btw, I've not been able to find it documented anywhere what gentoo-core is for. It's a closed list so I presume security issues go there but what else?
11:13:41 <kosmikus> management flamewars
11:13:45 <glimming> comlab?
11:13:51 <duncan> kosmikus: :-)
11:13:55 <Igloo> Yup yup
11:14:10 <duncan> kosmikus: I can't say that on my test though!
11:14:20 <glimming> Supervisor?
11:14:40 <kosmikus> duncan: this is not funny ;)
11:14:43 <Igloo> Oege de Moore
11:14:48 <kosmikus> duncan: yes, you can ...
11:14:53 <glimming> Both of you?
11:14:59 <glimming> So you know Sitampalan?
11:15:07 <glimming> (Indian spelling not started )
11:15:18 <duncan> kosmikus: ok (!) perhaps I'll be more diplomatic...
11:15:21 <glimming> I was working with Oege for a bit before
11:15:28 <glimming> Is he a good sup=
11:15:29 <glimming> ?
11:15:29 <kosmikus> hey, how's Heffalump anyway?
11:15:46 <kosmikus> haven't seen him in a while ...
11:16:22 <doc_modulo> musasabi: thanks for the Eden link
11:16:25 <Igloo> He seems happy enough at Arm. Haskell hacking in his spare time I believe  :-)
11:16:31 <kosmikus> ah, ok
11:16:34 <kosmikus> old habits ...
11:16:49 <tuomov> " the submitting user grants BerliOS Developer the royalty-free, perpetual, irrevocable, non-exclusive and fully sublicensable right and license to use, reproduce, modify, adapt, publish, translate, create derivative works from, distribute, perform and display such Content (in whole or part) worldwide and/or to incorporate it in other works in any form, media, or technology now known or later developed, all subject to the terms of any applicable Open
11:16:56 <tuomov> that doesn't sound so good..
11:17:03 <tuomov> does it mean that they get to choose the license?
11:18:04 <glimming> Jeremy is for sabbatical I heard.
11:18:07 <tuomov> I release my program under LGPL, but they can choose to relicense it under some non-free but OSI-approved license
11:18:11 <glimming> Also, how's Bird? Is he around a lot these days?
11:18:31 <kosmikus> duncan: soon, you'll see the thruth about gentoo-core, and then you'll understand why you don't have to be diplomatic ;)
11:18:34 <tuomov> of course, I only need the mailing list atm
11:18:47 <doc_modulo> musasabi: Parallel Haskell and PVM seem a bit bolted onto Haskell, and a bit unelegant compared to Eden
11:19:26 <glimming> Ian and Ross: what are your thesis topics?
11:20:23 <glimming> why guards for Int, we cannot pattern match on (1+n) ?
11:20:51 <glimming> Btw, can anyone recommend good textbooks for an AFP course...
11:20:55 * wli would love (2*n+1) etc. patterns
11:20:59 <glimming> I know school of expression
11:21:17 <glimming> So 1+n can only be used in guards?
11:22:45 <kosmikus> glimming: Bird is better than SOE if you're more theoretically interested
11:23:09 <kosmikus> glimming: no, Haskell has n+k patterns, but they're a very controversial feature
11:23:25 <kosmikus> even the Haskell report says that you should be aware of this fact when using them ...
11:24:42 <glimming> Both Bird and SOE are too easy for AFP, must dig into type theory and lambda...
11:25:40 <kosmikus> Pierce's TAPL?
11:26:00 <glimming> Yes, that's a good text.
11:26:12 <glimming> But I am more oriented towards Generic Haskell and PolyP stuff
11:26:20 <glimming> And no OOP
11:26:24 <glimming> So neither is this book perfect.
11:26:28 <wli> Thank $DEITY
11:26:43 <kosmikus> well, Pierce is not very much oriented towards OOP either
11:26:55 <glimming> subtyping...
11:26:59 <kosmikus> it's definitely good basic knowledge about type systems, useful in any case
11:27:11 <wli> Subtyping is good, esp. structural subtyping. =)
11:27:11 <glimming> I like Mitcell's Foundations book
11:27:19 <wli> I've got Mitchell.
11:27:28 <kosmikus> Mitchell's good, too
11:28:08 <wli> Crole's "Categories for Types" has some useful material in it but I think there's probably a better presentation of the more advanced material to be found somewhere.
11:28:09 <glimming> Yeah, but there are no functional datastructures, algorithms, and derivations.
11:28:17 <glimming> Are you kidding me for a grad course?
11:28:27 <glimming> Who is wli?
11:28:44 <wli> glimming: /whois says, http://holomorphy.com/~wli/ etc.
11:29:01 <wli> kernel programmer in the employ of Oracle
11:29:23 <glimming> nice page wli, full name?
11:29:32 <CosmicRay> wli: ooo, evil-sounding :-)
11:29:35 <wli> *** wli is wli@holomorphy.com (William Lee Irwin III)
11:29:57 <wli> Why the sudden concern?
11:30:06 <glimming> shit, really III?
11:30:35 <glimming> Anybody that knows Crole's book is interesting.
11:30:42 <wli> glimming: If I don't use the suffix I get bank accounts etc. mixed up with I and II.
11:30:54 <glimming> Which might be good anyway.
11:30:56 <glimming> I guess.
11:30:59 <glimming> ;-)
11:31:13 <wli> I, maybe, II, it depends on the precise transaction.
11:31:16 <glimming> But why not Succ Succ Zero?
11:31:24 <CosmicRay> heh
11:31:49 <glimming> Sorry...
11:31:50 <wli> I don't generally get that option for suffices in checkboxes for names to be printed on checks, credit cards, or similar things.
11:32:32 <wli> I'm aware that to e.g. people in .eu and/or .uk it's vaguely weird, though common practice in .us
11:32:33 * glimming enjoying myself
11:32:46 <glimming> It is cool to have a digit.
11:32:49 <glimming> Royal.
11:33:14 <CosmicRay> huh, what is the suffix in .uk for this sort of thing?
11:33:30 <wli> It's some sort of pretense of royalty, though motivated in my case by the availability of it for use as a disambiguation method.
11:33:41 <CosmicRay> huh
11:33:53 <CosmicRay> yeah we have suffixes like III all the time here in .us
11:34:05 <glimming> Anyway it must have annoyed royalties that the French calls a good hamburger Royal.
11:34:11 <glimming> We are now off topic.
11:34:19 <CosmicRay> glimming: you took us there :-)
11:34:47 <glimming> I tend to agree with the French on this matter.
11:34:54 <wli> Anyway, the hyperdoctrine stuff was something of a stretch for me wrt. category theory.
11:35:06 <glimming> Interesting.
11:35:12 <glimming> I never fully understood hyperdoctrine.
11:35:43 <wli> I can't actually do any original work with hyperdoctrines (or that level of category theory in general), though I can "follow the arguments" for whatever that's worth (which isn't much).
11:36:03 <glimming> So you can introduce me later.
11:36:12 <glimming> Would be nice to query some things from the book.
11:36:41 <wli> If I went about practicing category theory; my current learning project is actually Malliavin calculus.
11:36:46 <glimming> anybody understand codata in martin-löf type theory btw?
11:36:58 <glimming> What's that M...?
11:37:15 <wli> glimming: Also known as "stochastic calculus of variations".
11:37:32 <glimming> Sorry I have to work now. This is too fun ... ;-)
11:37:52 <wli> Alrighty, good to meet you.
11:37:58 <glimming> yeah, later!!!!
11:38:25 * shapr yawns
11:38:32 <kosmikus> morning shapr
11:38:39 <shapr> g'mornin kosmikus
11:39:42 <shapr> Cool, Alistair Bayley updated his FpVsOo article, it'll be in issue 1.
11:40:21 <humasect> *crowley
11:40:21 <kosmikus> got any comments on the .cls?
11:41:04 <shapr> kosmikus: Lunar^ was in favor
11:43:03 <doc_modulo> I like the suffix Esquire
11:43:24 <kosmikus> shapr: nice. no other remarks yet?
11:43:32 <doc_modulo> motherfucker is less nice
11:44:04 <doc_modulo> doc modulo, esquire
11:44:09 <shapr> kosmikus: not that I've seen
11:44:37 <kosmikus> ok
11:45:49 <kosmikus> if you want any changes, you should tell me tonight, because I'll not have much time tomorrow, and I'll be away from Friday to Monday
11:46:01 <shapr> ok, sounds good.
11:50:49 * shapr hops
11:51:02 <SyntaxNinja> w00t
11:52:10 <duncan> kosmikus: I've sent you my updated quiz answers. I've got to go now for a play rehursal. :-)
11:52:14 <basti_> oh shapr
11:52:31 <basti_> tmr: how would i expect the article to be distributed?
11:52:35 <kosmikus> duncan: thanks
11:52:44 <kosmikus> duncan: I'll process them as soon as I can
11:53:04 <basti_> i was assuming, digital, with the possibility to deliver files?
11:53:10 <duncan> kosmikus: cheers. No need to rush.
11:53:21 * basti_ boings shapr 
11:54:28 <clavijo> hi
11:54:47 <Lemmih> Greetings, clavijo.
11:55:32 <Lemmih> clavijo: Learning Haskell?
11:55:36 * clavijo suggest topic as a lambda expression instead of a list of String (you know, more functional ;-)
11:55:39 <clavijo> not
11:55:40 <clavijo> :)
11:55:55 <clavijo> Lemmih: looking for a way to have class aliases
11:56:54 <clavijo> any suggestion?
11:56:55 <Lemmih> I'm not sure that's possible.
11:58:09 * clavijo was afraid
11:58:11 <shapr> basti_: tmr will be html and PS, at least for issue 1
11:58:29 <Lemmih> clavijo: What exactly are you trying to write?
11:58:46 <shapr> CosmicRay: sure, I can tell you what I know about Haskell web programming
11:58:51 <basti_> shapr: then I can't assume i can deliver files ok.
11:59:28 <shapr> basti_: I'm planning to have a hawiki page for each article, that would allow comments and be a place to put files.
11:59:37 <basti_> hmm
11:59:53 <basti_> I'll think something up
11:59:55 <shapr> but you're right about PS not allowing easy file attachments.
11:59:57 <shapr> ok
12:00:05 <clavijo> Lemmih: i define a class and i want all types instanced as Double to be automatically instanced in my class
12:00:34 <shapr> SyntaxNinja: wassup?
12:00:44 <clavijo> Lemmih: instance (Double a) => MyClass a where   does not work, because a instance must be done in a totally defined type
12:00:58 * glimming is back
12:01:18 <glimming> Is there a good implementation of exact real computations for Haskell somewhere?
12:01:37 <glimming> Also, how can there be 109 members here??
12:02:01 <shapr> http://www.scannedinavian.org/cgi-bin/darcs.cgi/hlibs/exactreal/?c=browse
12:02:05 <Lemmih> clavijo: Double is not a typeclass. Or did you make it yourself?
12:02:07 <syntax_syntax> hello.
12:02:11 <syntax_syntax> http://www.wall.org/~larry/pm.html
12:02:20 <clavijo> Lemmih: Real, sorry
12:02:40 <shapr> glimming: what do you mean how can there be 109 members?
12:02:50 <Lemmih> clavijo: And why didn't it work?
12:02:56 <glimming> It's listed that there are 109 people in this forum!
12:03:07 <shapr> glimming: yes?
12:03:18 <clavijo> Lemmih: because an instance has to be defined in a totally defined type
12:03:20 <shapr> hiya syntax_syntax
12:03:39 <glimming> shapr: can you mail me that stuff? I can't seem to download it all?
12:03:40 <doc_modulo> syntax, there's no Haskell in that article :)
12:03:51 <glimming> shapr: that's a big class of listeners
12:04:02 <glimming> I get agorafobia from it.
12:04:03 <clavijo> Lemmih: if not, someone could make an instance of Real instance of MyClass too, and there would be a conflict to choose the function
12:04:11 <shapr> glimming: you need to install darcs to grab that repository.
12:04:11 <Lemmih> clavijo: instance (Real a) => YourClass a where [...] is valid Haskell. Can you post the error message?
12:04:21 <glimming> what's darcs?
12:04:21 <clavijo> of course
12:04:37 <shapr> glimming: see darcs.net
12:04:44 <syntax_syntax> doc_modulo it's an entertaining article about programming languages. One that I tend to disagree with, true.
12:04:52 <glimming> Oh, well, maybe you can mail it? ;-)
12:04:56 <clavijo>     Illegal instance declaration for `MyClass a'
12:04:56 <clavijo>         (The instance type must be of form (T a b c)
12:04:56 <clavijo>          where T is not a synonym, and a,b,c are distinct type variables)
12:04:56 <clavijo>     In the instance declaration for `MyClass a'
12:05:01 <clavijo> Lemmih: ghci, not hugs
12:05:10 <shapr> glimming: No, but you can use darcs to get it.
12:05:14 <clavijo> glimming: a revision control system
12:05:15 <syntax_syntax> doc_modulo people here tend to be fond of all sorts of leftfield languages, and Larry "Perl" Wall finds a way around bashing the entire idea of leftfield languages.
12:05:38 <Lemmih> @wiki HaskellIrcPastePage clavijo: Try pasting your code here.
12:05:39 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage clavijo: Try pasting your
12:05:39 <lambdabot> code here.
12:05:55 <clavijo> lambdabot: ok
12:05:55 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
12:06:20 <clavijo> XD
12:06:45 * tmoertel runs of to make more delicious tea
12:07:04 <doc_modulo> syntax_syntax: you mean he's bashing or he's dismissing the bashing?
12:07:15 <doc_modulo> or both? :)
12:08:08 <shapr> tmoertel: hiya tom, how's code?
12:08:41 <doc_modulo> syntax_syntax: I read the answer
12:09:04 <glimming> darcs installed?
12:09:12 <glimming> is there some URL that I enter?
12:09:38 <syntax_syntax> doc_modulo he's bashing.
12:09:40 <shapr> yes, use 'darcs get http://www.scannedinavian.org/repos/hlibs/'
12:10:29 <glimming> darcs is in ghc!
12:10:55 <shapr> darcs is written in Haskell, is that what you mean?
12:11:03 <glimming> shapr, whole in one.
12:11:18 <syntax_syntax> i should learn to use a CVS system soon.
12:11:18 <doc_modulo> syntax_syntax: yeah, and he's rubbing his nipples while doing it
12:12:21 <syntax_syntax> for my Haskell stuff.
12:12:21 <syntax_syntax> er, not for my Haskell stuff, for my LaTeX stuff.
12:12:21 <syntax_syntax> maybe I need to consider darcs.
12:16:21 * tmoertel is back, tea in hand
12:20:50 <doc_modulo> syntax_syntax: http://www.odetocode.com/Articles/337.aspx
12:20:50 <shapr> syntax_syntax: have you tried darcs?
12:21:59 <tmoertel> shapr: howdy! things are good here. how about w/ you?
12:21:59 <clavijo> Lemmih: i think i already have done it
12:22:40 <CosmicRay> hey shapr, can I pick your brain about web-related haskell libs?
12:22:40 <CosmicRay> shapr: I'm needing to write a web app, and I think I will need three things: cgi form parsing on the input side, session tracking, and html output on the output side (preferably tied in with cgi processing)
12:23:06 * wli has
12:23:25 <tmoertel> ah, netsplits (grumble)
12:25:25 * wli is particularly proud of: xcothx x = let { as = repeat (x^2) ; bs = 2:map (+4) bs } in lentz (as!!) (bs!!) :: Double
12:25:36 <shapr> wow, what does that do?
12:25:45 <wli> it computes x*coth(x/2)
12:25:53 <wli> lentz is something else I wrote that's too long to paste
12:26:03 <CosmicRay> argh... shapr, did you see me question before the split?
12:26:07 <wli> the results are approaching machine precision
12:26:07 <shapr> CosmicRay: no?
12:26:13 <wli> with a high order of accuracy
12:26:20 <CosmicRay> <CosmicRay> hey shapr, can I pick your brain about web-related haskell libs?
12:26:20 <CosmicRay> <CosmicRay> shapr: I'm needing to write a web app, and I think I will need three things: cgi form parsing on the input side, session tracking, and html output on the output side (preferably tied in with cgi processing)
12:27:04 <wli> this particular continued fraction can be used for sin(x), cos(x), and e^x
12:27:05 <shapr> CosmicRay: WASH does forms and html output, and I think it does Sessions too.
12:27:13 <wli> normally you don't have to write these things yourself
12:27:21 <CosmicRay> shapr: I'm really hoping for something other than wash
12:27:28 <CosmicRay> shapr: there are several things about it that I don't like
12:27:44 <CosmicRay> it is too heavy-handed in its html generation, mainly
12:28:24 <wli> However, if you're cooking up some e.g. higher-precision arithmetic, then you need something beyond the hardware and/or libs.
12:28:56 <Excedrin> CosmicRay: but it has cool animated washing machine logos!
12:28:58 <wli> Which is what this is intended for use in conjunctino with.
12:29:04 <CosmicRay> heh
12:30:55 <wli> tan(x) would probably be equally usable.
12:33:33 <syntax_syntax> wli have you done one for Pi already? :-D
12:33:45 <syntax_syntax> The only series for Pi I know is the Asimov's one. It's prolly really inefficient, though.
12:33:49 <CosmicRay> shapr: halipeto looks nice, but I need something that can generate dynamic content
12:34:06 <shapr> CosmicRay: Lemmih got halipeto to generate dynamic content.
12:34:18 <shapr> halipeto was designed to be extended in that direction.
12:34:44 <syntax_syntax> uhh. would you write something like WordPress in Haskell?
12:34:45 <shapr> wli: have you read Jeremy Gibbons' spigot algorithms paper?
12:34:51 * tmoertel likes wash's html generation
12:35:07 <shapr> syntax_syntax: my blog is written in haskel
12:35:12 <wli> shapr: no, URL?
12:35:14 <CosmicRay> shapr: hmm, do you know where his code is?
12:36:12 <syntax_syntax> shapr oh. wow.
12:37:12 <shapr> wli: http://www.scannedinavian.org/iohcc/succzeroth-2004/
12:37:36 <shapr> CosmicRay: hackage darcs repo - http://www.scannedinavian.org/cgi-bin/darcs.cgi/hackage/?c=browse
12:38:10 <CosmicRay> sweetness.
12:38:11 <shapr> syntax_syntax: there are at least two Haskell blogs, there's PLog by Peter Gammie and BloB by Björn Bringert
12:39:23 <shapr> wli: Probably obvious to you, but I was amazed at how nicely lazy eval mixes with spigot algorithms.
12:40:36 <wli> shapr: well, even and odd convergents of a simple continued fraction form upper and lower bounds for the result, when they converge.
12:41:15 <shapr> so you can get spigots for a wide range of algorithms easily?
12:41:20 <wli> shapr: yes
12:41:39 <shapr> neato
12:42:25 * tmoertel used an adaptation of Gibbons's pi-spigot to extract digits of e
12:42:52 <wli> e has a vaguely regular continued fraction
12:42:55 <shapr> tmoertel: did you use the new digit-finger for e that was discovered in 2004?
12:43:19 <wli> shapr: what's the new digit finger for e?
12:43:34 * tmoertel hunts down the code
12:43:45 * shapr looks
12:44:09 <wli> the code is going to be mostly indecipherable
12:44:20 <wli> a description is needed
12:45:26 <wli> It only takes 131 iterations of the continued fraction for 4*arctan(1) to get 100 digits of pi
12:46:23 <basti_> uuuh.
12:46:34 <tmoertel> shapr: I used the series e = 2 + 1/2 * (1 + 1/3 * (1 + 1/4 * (1 + 1/5) ... ))
12:46:46 <tmoertel> shapr: for more see http://www.hulver.com/scoop/story/2004/7/22/153549/352
12:48:24 <shapr> tmoertel: speaking of writing, want to write something for TMR?
12:48:41 <wli> anyway, for e it's something like [2;1, [2*k, 1, 1]_{k\geq 1}]
12:48:42 <tmoertel> when is the deadline?  :)
12:48:44 <glimming> what is a digit finger?
12:49:40 <shapr> The deadline for issue 1 content is to have it to the editor by feb 22
12:49:52 <wli> the first 10 convergents are:
12:49:59 <zamez> what's TMR?
12:50:02 <glimming> anybody knows of any algorithm which seems to need "bananas in space", i.e. recursion over function spaces, or something which is simplified?
12:50:08 <glimming> http://www.cordis.lu/tmr/home.html
12:50:11 <wli> [3., 2.66666666666667, 2.75000000000000, 2.71428571428571, 2.71875000000000, 2.71794871794872, 2.71830985915493, 2.71827956989247, 2.71828358208955, 2.71828171828172]
12:50:29 <shapr> and the deadline for an outline was loudly proclaimed to be the 8th, but if you have a cool article you really want to write, I'm sure the editor would like to hear about it.
12:50:49 <glimming> (or maybe not...)
12:50:59 <tmoertel> well, given my current work load, it would not be wise to think I could make the deadline
12:51:01 <shapr> zamez: TMR is The Monad.Reader - http://www.haskell.org/hawiki/TheMonadReader
12:51:11 <shapr> tmoertel: what about issue 2?
12:51:14 <tmoertel> especially because I don't have any ideas for an article atm
12:51:31 <tmoertel> shapr: oh, issue 2! sure, I can do something then.
12:51:59 <wli> glimming: easy, printf
12:52:06 <tmoertel> i could write about preaching the Haskell gospel to the Perl masses  ;-)
12:52:12 <shapr> heh, that sounds nifty
12:52:17 <glimming> print and parse, sure
12:52:22 <glimming> any other things?
12:52:28 <wli> glimming: printf is quite nasty
12:52:42 <glimming> wli: how is that?
12:52:52 <wli> glimming: never seen Printf.hs?
12:53:02 <glimming> nope
12:53:23 <wli> glimming: combineS = (.) . combineS -- Wow!
12:53:35 <wli> glimming: it does real C format strings, but with typechecking
12:53:53 <wli> glimming: no typesystem extensions or compiler hacks
12:54:00 <glimming> Where is this, in Prelude?
12:54:04 <syntax_syntax> tmoertel http://www.wall.org/~larry/pm.html
12:54:11 <wli> glimming: no, it's floating around somewhere
12:54:16 <wli> glimming: I've got it webabble
12:54:19 * tmoertel follows link
12:54:27 <wli> glimming: http://holomorphy.com/~wli/scripts/Printf.hs
12:54:31 <glimming> nice, that will be useful.
12:54:37 <glimming> Any other examples?
12:55:00 <wli> glimming: I do it all the time as a matter of convenience but it's never essential when I do, unlike the Printf.hs case.
12:55:35 <glimming> are there any particular algorithms which are easier to express with bananas in space?
12:55:55 <glimming> and why do we need it for printf...?
12:56:36 <wli> glimming: I've not seen any where it's a legitimate simplification, it's usually an artifact of surrounding "crap", and not particularly clean/whatever.
12:57:06 <wli> glimmer: In the Printf.hs case they are going through rather extreme contortions to shove the algorithm through the type system. The bananas in space are essential there.
12:57:22 <syntax_syntax> so, is darcs useable in Windows?
12:57:28 <syntax_syntax> Do I need Cygwin/Interix?
12:57:36 <glimming> I was hoping for graph algorithms etc.
12:57:50 <tuomov> It should run natively afaik
12:57:52 <wli> I've not been doing many of those recently.
12:58:05 <glimming> Anybody seen Mac OS X Tiger preview with their graphics filters which are like functions. They need a Haskell composition language!
12:58:40 <syntax_syntax> I mean, does it depend on the Unix  toolchain -- like, using grep, awk, sed?
12:58:53 <doc_modulo> PS3 needs a Distributed Haskell/Eden/Erlang
13:01:29 <tuomov> I don't think so. A friend just yesterday installed the package linked to from the wiki without problems.
13:03:25 <syntax_syntax> ok, thanks.
13:03:45 <syntax_syntax> tuomov so, what's so special about Lua?
13:03:55 <syntax_syntax> Apparently, my university had a lot to do with the development of Lua.
13:04:15 <syntax_syntax> But I've been using it because a professor at the math graduate school I attend during summers did a graphics library, and I can
13:04:20 <tuomov> it's a lightweight scripting language that supports functional style too
13:04:27 <syntax_syntax> But I've been using it because a professor at the math graduate school I attend during summers did a graphics library, and I can't quite get why this is better than Matlab.
13:04:41 <tuomov> matlab? it's awful!
13:05:15 <zamez> lies!
13:05:21 * zamez hides
13:05:25 <syntax_syntax> Octave -- the open source matlab interpreter -- is crashy and leaks memory, apparently. But the language itself is a rioting success in the scientific world.
13:05:34 <tuomov> matlab has one usable data structure: matrix. everything else is crap.
13:05:44 <tuomov> structs use linear search and so on
13:05:59 <basti_> matlab is crap.
13:06:19 <tuomov> they have awful oo glue on top of it these days
13:06:20 <syntax_syntax> many things can be done away with with matrix multiplication.
13:06:22 <basti_> i could tell you stories....
13:06:39 <basti_> for example matlab collapses singleton dimensions.
13:06:45 <tuomov> cell arraus had some strange limitations too
13:06:48 <basti_> if they're in "front".
13:06:54 <syntax_syntax> basti_ as in [1] becomes "1"?
13:06:57 <tuomov> it's been a while since I've actually used matlab
13:07:02 <basti_> and it expands as many singleton dimensions as you like.
13:07:16 <basti_> and as in, "1" becomes [1 1 1 1] in some cases
13:07:29 <basti_> or, logical "1" being something different than numerical "1"
13:07:33 <syntax_syntax> basti_ oh, sure. But that's only if you use the dot operators.
13:07:34 <basti_> despite looking really the same
13:07:48 <syntax_syntax> [1 2 3 4] .^ 2 = [1 4 9 16]
13:07:52 <basti_> yes.
13:08:00 <syntax_syntax> which is different from [1 2 3 4] * [1 2 3 4]'
13:08:02 <basti_> but its implied sometimes isnt it?
13:08:15 <syntax_syntax> well, afaik, only when it's mathematically sound.
13:08:22 <syntax_syntax> sure, 2* [1 2 3] = [2 4 6]
13:08:29 <basti_> oh and, functions can see how many results they are supposed to return
13:08:35 <basti_> and behave accordingly
13:08:57 <tuomov> matrix language with inferred dependent typing would be cool..
13:08:59 <syntax_syntax> functions don't return "more than one result", they return vectors, possibly containing matrixes as elements.
13:09:16 <basti_> and sometimes breaking the bounds of an array results in the array growing.
13:09:23 <syntax_syntax> maybe it's just that in econometrics one gets used to doing _everything_ in matrix form because it helps proving theorems.
13:09:33 <basti_> maybe.
13:09:33 <tuomov> no, they don't really return vectors, because the results may contain things of various types
13:09:40 <basti_> tuomov: yep.
13:09:42 <tuomov> although they syntax might suggest that
13:09:47 <tuomov> -y
13:10:02 <syntax_syntax> tuomov well, [1 "blue" [1 2; 3 4]] is a vector.
13:10:14 <tuomov> it shouldn't be valid iirc
13:10:20 <basti_> it isnt
13:10:25 <basti_> not as a vector
13:10:29 <syntax_syntax> it's not valid for most vector operations.
13:10:40 <tuomov> you can't assign something to it
13:10:41 <syntax_syntax> I don't think there's even a strctly enforced definition of "vector".
13:10:55 <wli> It looks like the continued fraction for e gets a little over 2 digits per iteration.
13:11:02 <basti_> oh, and, in normal vectors the default "direction" is "horizontal" (second dimension)
13:11:16 <syntax_syntax> basti_ that is awful, yes.
13:11:19 <basti_> in cell vectors its "vertical" (first dimension)
13:11:24 <syntax_syntax> so size([1 2 3]) = [1 3]
13:11:35 <tuomov> using ' for transpose and strings and leaving " unused is a serious design mistake
13:11:43 <basti_> and as i said, singleton dimensions sometimes collapse and sometimes dont.
13:11:50 <basti_> tuomov: I agree.
13:11:59 <syntax_syntax> it's mathematically intuitive.
13:12:00 <basti_> oh and the "..."
13:12:06 <tuomov> octave fortunately fixes this
13:12:13 <tuomov> it uses " for strings
13:12:18 <basti_> leaving " unused it NOT intuitive.
13:12:33 <syntax_syntax> I only use Octave to run Matlab code, I never bothered to learn what it changes.
13:12:44 <tuomov> also not ending functions with 'end' is wrong when everything else is ended with it
13:12:55 <basti_> yup.
13:12:57 <tuomov> again, active fixes this, but otoh wants one to use 'endif' etc. which I don't like
13:13:01 <tuomov> s/active/octave/
13:13:21 <basti_> oh and then, the matlab interpreter is like, slow.
13:13:24 <basti_> i mean, slow.
13:13:26 <syntax_syntax> I like how helpful the Matlab environment is in debugging.
13:13:41 <tuomov> yes, never use loops for what you can do with matrices
13:13:42 <syntax_syntax> I tend to write dozens of small files that do just one thing.
13:13:44 <basti_> the operations themselves are fast. but the interpreter is DAMN slow.
13:13:54 <tuomov> (which otoh is good functional style..)
13:14:26 <syntax_syntax> the Matlab environment points out where the function is called from.
13:14:37 <tuomov> oh, yeah, structs can't be indexed by arbitrary strings
13:14:37 <basti_> you mean it does a stack trace?
13:14:48 <tuomov> so there's no dictionary data structure
13:14:49 <syntax_syntax> Sometimes I write code that's never ran, because I go around coding the mathematical concepts before I think of the algorithms.
13:15:18 <tuomov> struct entries, although you can use setfield(s, "foo", whatever) (or s.("foo")=whatever in recent versions), mustbe proper variable names
13:15:39 <basti_> oh yes. matlab and its idea of namespaces.
13:15:51 <tuomov> (of course " is wrong above)
13:16:03 <basti_> in fact, engineers and mathematicans love matlab. programmers dont.
13:16:20 <basti_> and then, for
13:16:21 <tuomov> I'm a bit of all of those, and I don't like it :)
13:16:29 <basti_> for can iterate over "things"
13:16:31 <syntax_syntax> basti_ don't forget about us econometrists :)
13:16:39 <basti_> you cant do something useful with that though
13:16:44 <basti_> because you cant write back into the things.
13:16:57 <basti_> (which might be OO intuition)
13:17:50 <syntax_syntax> in any case, Matlab is _not_ a general-purpose language.
13:18:05 <tuomov> syntax_syntax: in any case, for what little matlab is good for (sticking just to matrices), I wouldn't think of using lua
13:18:19 <basti_> matlab is a limited-purpose language.
13:18:23 <syntax_syntax> Matrices are dead useful in applied mathematics.
13:18:28 <basti_> linear algebra.
13:18:44 <syntax_syntax> I can't seem to move out of Matlab because everything in the end is a matrix.
13:18:51 <tuomov> but once you need to write something more than just a few lines of matrix manipulation, switch to a proper language
13:19:39 <basti_> like, haskell
13:19:45 * basti_ bingo, back on topic
13:19:52 <syntax_syntax> give me a proper language that out-of-the-box implements matrix multiplication and I might.
13:19:56 <peti> Hi, does anyone know a bit about template Haskell by any chance?
13:19:57 <syntax_syntax> heh. well, I am learning Haskell.
13:20:05 <tuomov> yeah, but it would be even cooler if you had matrices dependently typed on their dimensions with inference..
13:20:14 <basti_> indeed.
13:20:22 <syntax_syntax> Mostly as a hobby. I can't see myself moving my Matlab code over yet.
13:20:48 <peti> I try to splice generated functions into a module, but I fail miserably. :-(
13:20:50 <basti_> I'd love to see a sensible matrix implementation in haskell.
13:21:13 <syntax_syntax> almost everything in applied maths falls back to matrix algebra.
13:21:36 <basti_> actually i once did matrix implementation for fun in haskell.
13:21:36 <tuomov> well, numerical maths at least
13:21:40 <syntax_syntax> numerical computing of partial diff. equations falls back to matrix algebra all the time.
13:21:45 <basti_> just to demonstrate how a haskell variable can be infinite.
13:22:02 <basti_> programmed an "grow as much as you need" unit matrix
13:22:58 <syntax_syntax> well, there's my wishlist. Matrix algebra in Haskell. O Wizards Hear Me.
13:23:07 <basti_> hmh.
13:23:15 <gzl> you want it built in or you just want some functions?
13:23:20 <gzl> should be easy enough to write, no?
13:23:23 <syntax_syntax> dunno yet.
13:23:25 <gzl> unless you want fancy stuff
13:23:29 <basti_> well its hard to write "sensible"
13:23:31 <basti_> i think
13:23:53 <syntax_syntax> I'm not even sure I understand the "Haskell way" yet.
13:24:07 <basti_> its a little like the tao.
13:24:11 <wli> SVD would be handy
13:24:18 <basti_> the tao we're talking of, it's not the eternal tao.
13:24:33 <wli> shifted QR too
13:24:52 <wli> maybe some Lanczos biorthogonalization too
13:25:22 <tuomov> an interface to lapack would be a start
13:25:27 <basti_> youre sure you dont want to use a C escape? ;)
13:25:42 <basti_> if i hear the name lanczos i think huge matrices.
13:26:02 <basti_> it makes no sense to implement this part of a system in matlab.
13:26:23 <tuomov> ah, there actuallyis HBlas
13:26:49 <tuomov> I really need to get a new keyboard..
13:27:15 <tuomov> but I don't want a numpad, and the mini kb:s are crammed
13:28:24 <syntax_syntax> cool! I got darcs working on my LaTeX thesis.
13:28:26 <SyntaxNinja> me curses in the general direction of Network.recvFrom
13:29:41 <syntax_syntax> wow. How does darcs produce .gz files if I ain't got gzip lying around?
13:29:48 <tuomov> zlib
13:30:22 <syntax_syntax> oh.
13:30:35 <syntax_syntax> this is kinda cool. I work from different computers.
13:31:02 <syntax_syntax> I was using a buddy's machine via ssh, but text-mode vim is annoying with long paragraphs, and slow latency when typing gets on my nerves.
13:31:25 <syntax_syntax> I could just set up an online repository in my web server or something.
13:33:30 <SyntaxNinja> or securely with ssh :)
13:33:58 <SyntaxNinja> darcs get syntax@foo.org:/path/to/repo
13:34:06 <SyntaxNinja> then you can use 'push'.
13:36:18 <syntax_syntax> hmm. I hope ftp is possible,.
13:36:58 <shapr> tuomov: kinesis contoured?
13:38:12 <shapr> hiya devilbis
13:38:34 <shapr> devilbis: have you been here before?
13:38:55 <devilbis> no, first time here; watch the wiki and haskell-cafe
13:39:13 <shapr> in that case, greetings! would you like the short intro to the #haskell channel?
13:39:23 <devilbis> sure, go ahead. :)
13:39:43 <shapr> The first stop on our tour is the handy haskell irc bot, lambdabot
13:39:52 <shapr> @index anyChar
13:39:53 <lambdabot> Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Char
13:40:04 <shapr> @type Text.ParserCombinators.Parsec.Char.anyChar
13:40:05 <lambdabot> Text.ParserCombinators.Parsec.Char.anyChar :: forall st.
13:40:05 <lambdabot> 					      Text.ParserCombinators.Parsec.Char.CharParser st Char
13:40:12 <shapr> several useful commands in lambdabot
13:40:34 <shapr> Next we have the useful urls in the channel topic, including the logs, the learning page, and the wiki
13:40:58 <shapr> Since you already read haskell-cafe and the wiki, that's about all the intro you need.
13:41:03 <syntax_syntax> I never got the lambdabot introduction when I first got here :-(
13:41:15 <shapr> syntax_syntax: sorry, I didn't see you come in :-)
13:41:19 <syntax_syntax> anyway, I'm already acquainted with everything :-D
13:41:34 <syntax_syntax> devilbis I'm the local prog-rock snob. Pleased to meet you.
13:41:36 <shapr> well, if you have any questions...
13:41:56 <devilbis> :) thanks
13:42:01 <devilbis> pleased to meet you all too.
13:42:18 <shapr> devilbis: I'm Shae Erisson, I'm the maintainer (read, head janitor) of the Haskell Wiki and the #haskell channel.
13:42:42 <lightstep> and he reads all the logs
13:42:46 <lightstep> so be careful
13:42:46 <devilbis> I'm actually at work at the moment and thought I'd probably just lurk for a while.
13:42:50 <devilbis> :)
13:42:53 <devilbis> consider me warned
13:42:54 * shapr grins
13:44:19 <shapr> syntax_syntax: so, how do you like darcs so far? have you read the patch theory?
13:44:23 <tuomov> shapr: expensive, hard to get
13:45:06 <tuomov> and I would like normal arrow keys, though
13:45:19 <tuomov> just cut the numpad off
13:45:19 <syntax_syntax> shapr yep. I can't seem to find out (how | whether) I can use FTP to communicate with an online repository.
13:45:29 <syntax_syntax> It also seems I need a scp program to use SCP.
13:45:31 <shapr> you can, but it's not optimal.
13:45:32 <tuomov> so that the kb is smaller
13:45:56 <shapr> tuomov: someone should sell keyboard lego
13:46:03 <tuomov> yeah.
13:46:08 <syntax_syntax> shapr well, I could use a machine I have shell access to, but it's a friend's, and he could just reformat it at any time.
13:46:15 <tuomov> some logitech dinovo whatever actually has a separate numpad
13:46:18 <shapr> syntax_syntax: do you have a public ip?
13:46:20 <tuomov> but it is wireless, and I don't like wireless
13:46:22 <devilbis> I've actually been writing some code in my off-time and I keep having to write lambdas of the form (\x y -> f x `binop` f y), where f::a->b and binop::b->b->c; is there some better way to do that?
13:46:29 <syntax_syntax> shapr or I could use the web server I pay for.
13:46:49 <syntax_syntax> shapr no, I'm behind some sort of proxy that won't let me serve stuff out. And in any case, I don't leave the machine on 24/7.
13:47:13 <shapr> syntax_syntax: if you have a public ip on your desktop, you could use dyndns. A world-available read-only darcs repo just needs an http server.
13:47:16 <syntax_syntax> (actually, the webserver my parents pay for, but being the webjanitor...)
13:47:48 <shapr> devilbis: I think you could use two of the arrow combinators that already do that.
13:47:53 <lightstep> devilbis: use the S combinator
13:48:10 <shapr> hiya timbod
13:48:53 <syntax_syntax> hmm. the darcs manual is not being helpful to me.
13:48:53 <devilbis> what name does S have in the standard lib?
13:51:04 <SyntaxNinja> is there anything like M-x count-lines-region for columns or characters?
13:51:59 <shapr> There's C-x =
13:52:42 * syntax_syntax starts a vi x emacs war.
13:52:49 <shapr> Yi!
13:53:58 <syntax_syntax> yi is the vi clone written in emacs, right?
13:53:59 <lightstep> devilbis: it seems there isn't (didn't manually find it, and it's defined somewhere in "The Evolution of a Haskell Programmer") but it's really simple. s is the only function of type (a -> b -> c) -> (a -> b) -> a -> c. modulo bottom
13:54:01 <syntax_syntax> er, I mean, in Haskell.
13:54:14 <shapr> yes, in Haskell
13:54:42 <SyntaxNinja> shapr: hm. that kinda works
13:54:52 <SyntaxNinja> but I already use column-number-mode
13:55:03 <shapr> What result do you want?
13:55:35 <SyntaxNinja> I want it to tell me how many columns I've highlighted, like if I wanted to check the length of a string
13:56:05 <shapr> oh
13:56:34 <shapr> I've never tried to do that, I don't know.
13:57:24 <devilbis> lightstep: I had seen s before (and that page, for that matter), but didn't know if I'd be rewriting the wheel if I put it in my program.
13:58:13 <lightstep> probably not
13:59:13 <SyntaxNinja> bbiab, meeting &
14:08:18 <shapr> Hm, I thought swing &&& would do the 'apply a function to two pieces of data' part of that.
14:08:32 <lightstep> swing?
14:08:39 <shapr> yeah, Cale's nifty combinator
14:08:43 <shapr> swing f = flip (f . flip ($))
14:08:58 <shapr> swing is here - http://www.haskell.org/hawiki/LicensedPreludeExts
14:08:58 * CosmicRay wraps his head around that
14:09:07 <lightstep> :type \f -> flip (f . flip ($))
14:09:16 <shapr> swing map is where you have one piece of data and a list of functions
14:09:17 <lightstep> @type \f -> flip (f . flip ($))
14:09:19 <lambdabot> \f -> flip (f . flip ($)) :: forall b a b1 c.
14:09:19 <lambdabot> 			     (((a -> b) -> b) -> b1 -> c) -> b1 -> a -> c
14:09:32 <CosmicRay> see, that was not the most helpful. :-)
14:10:01 <shapr> if you apply swing to a function, that function now takes functions where it would take data, and data where it would take functions
14:10:21 <shapr> CosmicRay: thing of swingers ;-)
14:10:30 <shapr> 'that guy swings both ways'
14:10:33 <CosmicRay> ahh, tese examples helpd:
14:10:40 <CosmicRay> swing map :: forall a b. [a -> b] -> a -> [b]
14:10:40 <CosmicRay> swing any :: forall a. [a -> Bool] -> a -> Bool
14:10:40 <CosmicRay> swing foldr :: forall a b. b -> a -> [a -> b -> b] -> b
14:10:43 <CosmicRay> that is damn cool.
14:10:57 <shapr> Yeah, extremely useful bit of code.
14:11:04 <shapr> Won't find that in Java =)
14:11:57 <shapr> @type (Control.Arrow.&&&)
14:11:59 <lambdabot> (Control.Arrow.&&&) :: forall a c' c b.
14:11:59 <lambdabot> 		       (Control.Arrow.Arrow a) =>
14:11:59 <lambdabot> 		       a b c -> a b c' -> a b (c, c')
14:12:37 <CosmicRay> shapr: what is the best place to read a tutorial about th?
14:12:41 <shapr> So I think &&& applies two functions to the same data. So swing &&& should apply two datas to the same function?
14:13:20 <lightstep> @type flip ((Control.Arrow.&&&) . flip ($))
14:13:22 <lambdabot> flip ((Control.Arrow.&&&) . flip ($)) :: forall c' b a.
14:13:22 <lambdabot> 					 ((a -> b) -> c') -> a -> (a -> b) -> (b, c')
14:13:24 <shapr> Then I just have to figure out how to get the `binop` factored out... it seems like the most basic case of foldr1 ?
14:13:47 <lightstep> it's almost
14:15:09 <shapr> CosmicRay: I read the papers and the mailing list. I'm considering doing shapr's n00b column on TH this issue.
14:15:26 <shapr> Would fit in nicely since Philippa is doing a TH article.
14:15:58 <CosmicRay> shapr: excellent
14:16:03 <CosmicRay> shapr: I would very much like to see that.
14:16:18 <shapr> ok then, I'll submit an outline by tomorrow
14:16:36 <CosmicRay> as I write this, I wonder if it is possible to make ghc dump a "processed" haskell tree?
14:16:45 <CosmicRay> that is, one that could be compiled by non-th-aware tools?
14:17:11 <shapr> Yes, but you lose the multi-step power of TH.
14:17:23 <CosmicRay> hmm.  then I don't understand it fully yet.
14:17:26 <CosmicRay> no surprise there :-)
14:18:11 <shapr> Well, when do you dump out the TH code? After one cycle of evaluate macros, produce code, compile?
14:18:50 <shapr> I'm probably biased because I want to use TH at runtime.
14:19:12 <CosmicRay> hmm.
14:19:22 <CosmicRay> I need to read more on TH before I can intelligently think about this, I guess
14:20:03 <shapr> Well, think of a recursive tree process. Each descent into a node could call a whole new TH cycle just for this node.
14:20:33 <shapr> I don't want to say too much more, I'd give away some of the cool surprises in Philippa's article =)
14:20:40 <CosmicRay> heh
14:21:37 <shapr> Oh, have you read Igloo's papers on TH? the "Report from the field" is quite informative.
14:22:21 <CosmicRay> no, I'll check it out
14:23:09 <CosmicRay> maybe it would be easiest to just wait for your article though :-)
14:23:33 <shapr> I started a TH tutorial on the wiki, don't remember how far I got.
14:24:09 <shapr> not very far - http://www.haskell.org/hawiki/TemplateHaskellTutorial
14:27:25 <lightstep> in the tutorial, it is hinted that ghci sees the "bare code", after the meta-programming stage
14:28:27 <shapr> because the compile-time string happens immediately?
14:30:32 <syntax_syntax> Jesus, I just saw the dumbest thing of mi perra vida.
14:31:09 <lightstep> i never ever tried th. but if ghci can do it, it seems reasonable that ghc can output the code to stdout (of course i will also wait for the Monad.Reader to clear it up)
14:31:43 <shapr> I'll make sure and add that point to my outline =)
14:32:24 * CosmicRay grumbles indignantly at python.  profile.py being non-free, indeed.
14:38:49 <shapr> Pseudonym: did you get my email?
14:38:52 <Cale> @type (\f -> flip (f . flip ($)))(Control.Arrow.&&&)
14:38:54 <lambdabot> (\f -> flip (f . flip ($)))(Control.Arrow.&&&) :: forall b a c'.
14:38:54 <lambdabot> 						  ((a -> b) -> c') -> a -> (a -> b) -> (b, c')
14:39:12 <Pseudonym> Haven't checked all of the email yet.
14:39:23 <Cale> ah, that was tried
14:39:44 <shapr> Cale: it's the right approach, isn't it?
14:39:53 <shapr> and then the first of foldr1, or something to that effect.
14:40:01 <jlouis> I am having a hard time understanding what happens with (.) when it is used in conjunction with curried functions
14:40:03 <Cale> I'm not sure what the previous discussion was
14:40:24 <jlouis> tupled types are easy. It works like the mathematical ``o'' operator
14:40:36 <CosmicRay> jlouis: do you have an example to illustrate something you dont' understand?
14:40:44 <jlouis> @type (map .)
14:40:46 <lambdabot> (map .) :: forall a b a1. (a1 -> a -> b) -> a1 -> [a] -> [b]
14:40:54 <jlouis> @type map
14:40:55 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
14:41:05 <syntax_syntax> Profile.py being non-free?
14:41:07 <shapr> Cale: just a request for a better way to do (\x y -> f x `binop` f y)
14:41:09 <CosmicRay> heh, that is a funny one
14:41:18 <CosmicRay> syntax_syntax: yes, it was removed from the debian 2.3.5 package for that reason
14:41:30 <CosmicRay> jlouis: you are passing the . function as an argument to map
14:41:40 <CosmicRay> err.
14:41:43 <CosmicRay> maybe not.
14:41:46 <jlouis> nope
14:41:56 <CosmicRay> either that or you are partially applying .
14:41:57 <jlouis> that would be map (.)
14:42:01 <syntax_syntax> http://lists.debian.org/debian-legal/2005/02/msg00103.html
14:42:07 <jlouis> I am partially appling
14:42:07 <syntax_syntax> hmm. what does profile.py do anyway?
14:42:17 <CosmicRay> syntax_syntax: identifies bottlenecks in python cdoe
14:42:50 <jlouis> a -> b -> c binds like a -> (b -> c), right?
14:42:56 <lightstep> yes
14:43:04 <CosmicRay> yes
14:43:24 <CosmicRay> I have to wrap my head around partially applying (.)
14:43:30 <syntax_syntax> I'll never understand of debian's freeundamentalism.
14:43:50 <syntax_syntax> especially since the FSF doesn't recognize it as totally free anyway.
14:44:16 <CosmicRay> syntax_syntax: well the license for profile apparently says that I can't take it and use it unless I have it as part of something else
14:44:17 <CosmicRay> that's silly
14:44:25 <CosmicRay> and an unreasonable restriction
14:44:29 <Cale> that approach seems like it ought to go somewhere -- it's probably just easiest to define a combinator to do that directly
14:45:24 <jlouis> so if map has type (a -> b) -> ([a] -> [b]) with excessive parens, we must be able to map it unto (.) :: (a -> c) -> (b -> a) -> (b -> c)
14:46:05 <jlouis> so, a = (a -> b), c = ([a] -> [b])... as far as I can calculate
14:46:40 <Pseudonym> Eek.
14:46:44 <Pseudonym> Just got to your mail, shapr.
14:46:50 <Pseudonym> "Terrifying Oleg solutions"
14:47:37 * shapr snickers
14:48:02 <Pseudonym> I like that phrase.
14:48:58 <shapr> syntax_syntax: There are two definitions of freedom, DFSG and FSF. DFSG is user-centered freedom, FSF is public-centered freedom.
14:49:17 <syntax_syntax> shapr I think there are more definitions of freedom than that ;-)
14:49:33 <syntax_syntax> I'm cynical. I'm getting me a Mac as soon as I have the $$$.
14:49:34 <shapr> well yeah, but...
14:50:33 <syntax_syntax> I'm reading debian-legal right now, and they are having major quips about Mozilla Foundation's trademark on "Firefox".
14:50:48 <shapr> At EuroPython 2004 I asked the FSF guys that difficult question, how do you compare Debian's user-centered freedom to FSF's public centered freedom? and I asked about nasty interpretations of the GFDL. They hated me :-)
14:50:50 <Pseudonym> Why?
14:50:56 <syntax_syntax> I mean, gee. Just swallow it, it's a working browser almost IE-complete.
14:51:00 <Pseudonym> Have they not provided a good licence for using the trademark?
14:51:45 <syntax_syntax> Pseudonym this is prolly not the best starting point, but you can browse around in the debian-legal archives from here: http://lists.debian.org/debian-legal/2005/02/msg00006.html
14:52:38 <kuribas> hi, what does $ do?
14:52:42 <syntax_syntax> life is full of frogs to swallow. Fundie-isms are so 1994.
14:52:55 <CosmicRay> syntax_syntax: debian wants to fully comply with the law.
14:52:56 <kuribas> sorry if it is a stupid question
14:53:11 <CosmicRay> syntax_syntax: the attitude of "legal technicalities are unimportant" has long since been shown to have serious long-term consequences.
14:53:17 <shapr> kuribas: mostly, $ is low priority function application
14:53:29 <CosmicRay> syntax_syntax: debian cannot adopt that attitude and expect to remain safe from being sued into oblivion
14:53:46 <kuribas> shapr: hmm, I don't remember seeing that in the "Gentle introduction"
14:54:01 <shapr> Yeah, I agree. You have to be careful to stay safe from the law. Debian cannot afford court cases.
14:54:04 <CosmicRay> shapr: I have to leave in 5 minutes, but remind me sometime to ask you about your public vs. personal freedom idea.  I haven't heard things framed this way before and think it could be sueful.
14:54:14 <syntax_syntax> CosmicRay but Mandrake can?
14:54:19 <shapr> CosmicRay: I'll try to remember.
14:54:31 <shapr> CosmicRay: I didn't know you're the SPI president.
14:54:32 <syntax_syntax> Mandrake even ships with WMV, DivX, RA, etc. codecs.
14:54:35 <CosmicRay> syntax_syntax: it is not for us to judge the level of risk-taking engaged in by others
14:54:37 <kuribas> shapr: where is it documented?
14:54:43 <CosmicRay> shapr: yes, it appears so :-)
14:54:50 <shapr> neat!
14:54:55 <syntax_syntax> CosmicRay well, it is not for us to judge anything, really.
14:54:56 <Pseudonym> Woohoo.
14:55:10 <lightstep> kuribas: it's, among other places, in the Standard Prelude
14:55:32 <Pseudonym> So we might actually get timely official Debian packages for GHC now? :-)
14:55:34 <syntax_syntax> I think the only way to be risk-free from lawsuits is to be placed under artificial coma in a hospital for the span of your life.
14:55:35 <CosmicRay> syntax_syntax: I'm just saying, perhaps they are unaware that they are violating the law, or perhaps they believe it nulikely that they will get sued over something, or perhaps they believe that being in france shields them from some software patent issues.
14:55:38 <humasect_> FunGEn is dead
14:55:40 <humasect_> >:o
14:55:46 <jlouis> now, I got my head wrapped around (map .)
14:55:55 <shapr> humasect: yeah, sad isn't it?
14:56:07 <shapr> jlouis: that was fast.
14:56:08 <CosmicRay> syntax_syntax: I don't really know what their mindset it.  Perhaps they have obtained licenses to things so they can legally distribute them, even though the need for a license would cause them to be non-dfsg-free
14:56:11 <jlouis> it is just partial application. You only need to remember to rename the types in the map before trying to put them into (.)
14:56:59 <CosmicRay> syntax_syntax: the fsf considers debian not fully a Free Sofwtare project because we have non-free and contrib sections.
14:57:10 <humasect> shapr: i've never seen it, but it sounds like it is a start. but it relates to what i have planned anyhow... would be curious to see the docs and/or source though.
14:57:19 <CosmicRay> syntax_syntax: I agree with them, and have twice proposed general resolutions calling for those sections to be abolished.
14:57:40 <syntax_syntax> why? to make a debian user's life  harder?
14:57:53 <CosmicRay> syntax_syntax: my proposals were eventualyl defeated.  however, the fact remains that debian does not consider non-free and contrib to be part of the distribution, and thus is the most free major distribution available.
14:58:03 <CosmicRay> syntax_syntax: pfft, what's a line in sources.list among friends? :-)
14:58:14 <jlouis> CosmicRay: OpenBSD is even free'er
14:58:25 <syntax_syntax> and secure by default!
14:58:34 <syntax_syntax> CAAAAAN'T FIIIIIIGHT THEEEE SYSTEMAGIC! SYSTEMAGIC!
14:58:35 <jlouis> Especially without the /usr/src/gnu tree
14:58:35 <CosmicRay> few people need things from non-free these days anyway.  debian's installer doesn't list those things in sources.list by default either.
14:58:45 <syntax_syntax> Man, I love the OpenBSD release songs.
14:58:53 <jlouis> syntax_syntax: they are nice ;)
14:58:54 <CosmicRay> jlouis, syntax_syntax: that's only because a default installation of openbsd contains little more than /bin/true :-)
14:59:07 <shapr> Wow, SPI supports a bunch of neat projects.
14:59:10 <CosmicRay> recent releases may include /bin/false
14:59:13 <syntax_syntax> 3.1 "Systemagic" is the best one :-D
15:00:07 <syntax_syntax> TEAR ALL THE SCRIPTS, SECURE BY DEFAULT! CAAAAAAAAAAAN'T FIIIIIGHT THEEE SYSTEMAGIC! SYSTEMAGIC! :-D
15:00:12 <CosmicRay> shapr: drupal recently joined, too
15:00:21 <shapr> You should get that on the website.
15:00:25 <CosmicRay> yes
15:00:27 <CosmicRay> we should.
15:00:29 <CosmicRay> our website sucks.
15:00:29 <jlouis> syntax_syntax: exacly
15:00:44 <CosmicRay> long story
15:00:46 <shapr> CosmicRay: I can build you a nice Plone site ;-)
15:00:51 <syntax_syntax> I never used BSDs, I just like the song.
15:01:00 <syntax_syntax> s/song/songs.
15:01:07 <syntax_syntax> Every open source project should have release songs.
15:01:09 <Pseudonym> CosmicRay: Curious why you called for non-free to disappear.  Is it technically illegal?
15:01:10 <CosmicRay> shapr: seriously, if you did that and it was easy to maintain, and supported language translations, we just may take it.
15:01:13 <syntax_syntax> Maybe that can be added to the GPL.
15:01:19 <Pseudonym> Or is it just not DFSG?
15:01:22 <CosmicRay> Pseudonym: not illegal, but against the spirit of what debian is about.
15:01:26 <Pseudonym> Right.
15:01:30 <syntax_syntax> "You may not fork this project without releasing a new theme song"
15:01:33 <CosmicRay> Pseudonym: non-free are things that fail dfsg but are legal to distribute
15:01:39 <CosmicRay> they may not come with source
15:01:46 <CosmicRay> or may have onerous restrictions
15:01:47 <Pseudonym> That's what I thought.
15:02:01 <CosmicRay> things that are not legal are not distributed by debian at all, or are in non-us if they can only be legally distributed outside the us
15:02:04 <shapr> CosmicRay: send me a rough website structure, I'll check with my boss to see if having our name at the bottom in tiny letters is worth the time it'd take us to build it.
15:02:08 <CosmicRay> (very little falls into that category these days)
15:02:19 <syntax_syntax> Pseudonym why call for doing away with nonfree then?
15:02:19 * Pseudonym nods
15:02:29 <CosmicRay> shapr: ok, I will run that by our web peolpe and get back to you
15:02:38 <CosmicRay> thanks
15:02:39 <Pseudonym> syntax_syntax: Did you mean to ask me that?
15:02:54 <syntax_syntax> Pseudonym nope :-)
15:02:55 <syntax_syntax> sorry.
15:03:14 <CosmicRay> syntax_syntax: Debian says in our social contract that our priorities are our users and free software.
15:03:39 <CosmicRay> syntax_syntax: I find it extremely difficult to find an argument that states that supporting non-free does great damage to our users anymore
15:03:40 <syntax_syntax> well, doing away with nonfree harms your users.
15:03:48 <CosmicRay> syntax_syntax: most users don't even know it's there.
15:03:58 <CosmicRay> syntax_syntax: those that do can add a different line to sources.list and never miss a beat
15:04:14 <syntax_syntax> well, as everything, it's a matter of principle.
15:04:19 <CosmicRay> exactly.
15:04:23 <syntax_syntax> they can also download pir8 Matlab from a torrent.
15:04:24 <CosmicRay> there was a day when most users used non-free
15:04:28 <CosmicRay> for things like netscape.
15:04:29 <Pseudonym> Actually, it's not even principle.
15:04:42 <Pseudonym> It's the vibe of the thing.
15:04:55 <CosmicRay> anyway, I most go.  search for goerzen in debian-vote from summer 2000 or so if you are curious for more reasons.
15:05:00 <Pseudonym> And, as CosmicRay points out, it's not as useful as it was once.
15:05:06 <Pseudonym> OK, fare well.
15:05:11 <CosmicRay> cya
15:06:03 <tuomov> I think non-free should be abolished, but a separate project for all kinds of non-free (even warez) packages established
15:06:37 <syntax_syntax> *yawn*. I'm cynical.
15:06:44 <Pseudonym> Yes, Debian isn't nearly warez-compatible enough.
15:06:52 * boegel bounces
15:06:57 * shapr boings
15:08:04 <boegel> shapr: how's the latex stuff going ?
15:08:17 <shapr> Well, I tried the pants, but they were so uncomfortable...
15:08:29 <syntax_syntax> latex pants? o_O
15:08:43 <boegel> shapr: wait until you try the underwear, that's _tight_
15:09:13 <syntax_syntax> \documentclass[spandex]{pants}
15:09:21 <boegel> did you agree with kosmikus on some standard stuff ? or is it still wip ?
15:10:14 <shapr> darcs get http://www.cs.uu.nl/~andres/TMR
15:10:39 <shapr> Pseudonym: hey, do you have time to check out the TMR stylesheet and see what you think?
15:11:23 <boegel> shapr: I don't know how to use darcs :)
15:11:59 <shapr> boegel: install darcs, then run darcs get http://www.cs.uu.nl/~andres/TMR, after which you'll have a directory named TMR
15:12:26 <boegel> shapr: and where should I get darcs ?
15:12:38 <shapr> from darcs.net, if your linux distro doesn't have a package
15:13:13 <shapr> Actually, I think the darcs.net download points to the DarcsWiki on ScannedInAvian.
15:13:41 * boegel tries 'yum install darcs'
15:13:58 * tmoertel must leave for a Perl Mongers meeting ...
15:14:19 <shapr> have fun tom
15:14:28 <kosmikus> I guess you can just download http://www.cs.uu.nl/~andres/TMR/tmr.cls and Author.pdf directly
15:14:29 <tmoertel> shapr: thanks!
15:14:42 <kosmikus> Author.tex, that is
15:14:52 <shapr> Oh, I got distracted while looking for that new digits of e algorithm...
15:15:12 <Pseudonym> Which new digits of e algorithm?
15:15:29 <shapr> The one found in 2004.
15:15:47 <kosmikus> boegel ^^
15:16:03 <Pseudonym> Ah, I see.
15:16:12 <Pseudonym> Found it.
15:16:17 <boegel> kosmikus: ?
15:16:48 <kosmikus> boegel: you don't need darcs ... what I said above
15:17:52 <shapr> Pseudonym: ah, Harlan J. Brothers
15:18:03 <boegel> kosmikus: I need when I want to contribute... so I should learn it anyway
15:18:27 <kosmikus> it's simple enough
15:19:27 <boegel> will the pdf be available on the wiki too ?
15:19:33 <boegel> nicely done btw, elegant
15:19:53 <kosmikus> you mean tmr.cls? thanks
15:19:54 <shapr> wli: 'Improving the convergence of Newton's series approximation'  - http://www.brotherstechnology.com/math/
15:20:30 <kosmikus> sure, the pdf can be put on the wiki, I don't mind; you can do it yourself, if you want to
15:20:59 <kosmikus> but add a comment that it might be outdated and where the lates version is available from
15:22:15 <boegel> kosmikus: I'm just reading the pdf for now...
15:22:30 * boegel found a type
15:22:38 <boegel> s/type/typo
15:22:43 <kosmikus> ok
15:22:48 <shapr> Pseudonym: is that improved convergence stuff really worthwhile?
15:22:49 <kosmikus> if you want to learn darcs
15:22:56 <kosmikus> try to darcs send me a patch ;)
15:23:22 <Pseudonym> shapr: http://andrew.bromage.org/E.hs
15:23:31 <Pseudonym> Different algorithm, but I think you'll find it cool.
15:23:37 <Pseudonym> Oh, yes, improved convergence is always useful.
15:23:53 <Pseudonym> You want the same precision using fewer computrons.
15:24:29 <boegel> kosmikus: let me read up first :)
15:25:21 * shapr tries to wrap his head around that spigot
15:26:35 * shapr 's brain explodes
15:29:03 <kosmikus> shapr: hey, your in best company with SPJ ;)
15:29:42 <shapr> huh?
15:29:47 <Pseudonym> My failed attempt at beating wli's Fibonacci number computation might be more comprehensible.
15:29:47 <kosmikus> you're, even; what is this these days .. I'm getting lazy typing
15:29:53 <Pseudonym> shapr: http://andrew.bromage.org/Fib.hs
15:30:08 <shapr> I'm in best company with SPJ?
15:30:16 <shapr> His head explodes too?
15:30:21 <kosmikus> shapr: when GHC says "mbje ...", then I always here SPJ's voice in my head ...
15:30:32 <Nioate> Pseudonym: Fib.hs failed?
15:30:42 <Pseudonym> It failed to beat wli's solution.
15:30:49 <Nioate> ah
15:30:59 <shapr> kosmikus: mbje?
15:31:06 <kosmikus> my brain just exploded
15:31:11 <shapr> oh hah!
15:31:33 <shapr> That is an excellent error message.
15:31:40 <kosmikus> although I haven't seen this error message that often any more lately
15:31:53 <kosmikus> spj's brain's becoming more robust
15:33:18 <boegel> hmm, I have some comments on the TMR Authors pdf...
15:33:23 <boegel> including 1 typo :p
15:33:52 <kosmikus> everything there is just a basis for discussion, so go ahead
15:34:38 <boegel> hmm, i don't know where too start :p
15:34:44 <boegel> first off all, the type:
15:35:05 <jlouis> ah, now (. map) makes sense too
15:35:16 <boegel> top of page 3, just above the 'Blocks ...' section
15:35:19 <jlouis> I can recommend using hugs as a scratchpad for typing
15:35:27 <boegel> vy vertical space -> by vertical space
15:36:02 <kosmikus> fixed
15:36:46 <boegel> ok, next, a small detail... the 'qed' symbol looks strange in my pdf
15:36:58 <boegel> the top line is lowered a bit
15:37:03 <kosmikus> rounding error
15:37:08 <jlouis> boegel: that is rounding error
15:37:09 <boegel> the symbol looks like an almost full basket now
15:37:16 <boegel> and, is that my fault ? :)
15:37:18 <jlouis> it is better when printed
15:37:21 <jlouis> try ;)
15:37:25 <boegel> oh, okay then :)
15:37:34 <kosmikus> no, it's not your fault, but your pdf reader's
15:37:38 <kosmikus> try to zoom in
15:37:57 <boegel> okay, I see
15:38:08 <boegel> next: last page, 'Use consistent markup'
15:38:34 <boegel> first you say, don't use \textit or \ŧextbf, then you say, use \textit and \textbf instead of \bf , \it
15:38:42 <boegel> that's not really what I call consistent :)
15:39:12 <kosmikus> well, they're hierarchical directives :)
15:39:37 <Pseudonym> "If you must break this rule, don't break this rule."
15:39:46 <kosmikus> right
15:39:55 <shapr> ah, pattern matching
15:40:02 <kosmikus> also, if you define logical markup directives, you might still want to use \textbf etc.
15:40:27 <boegel> well, I should try and make that more clear then... because it just looks weird now ;)
15:40:38 <kosmikus> something like \newcommand\categoryname[1]{\textbf{#1}}
15:40:47 <kosmikus> I know that not everything is just right yet
15:40:54 <kosmikus> but patches are definitely welcome
15:40:54 <boegel> especially when the word 'consistent' is 2 lines above it ;)
15:41:19 <boegel> I don't think I should patch those things without asking you first, right ?
15:41:42 <kosmikus> well, you can't without going through me anyway, as long as the repo is on my server
15:41:55 <kosmikus> you can always send me patches, and I can still reject them :)
15:42:23 <kosmikus> but yes, I don't mind discussing things here either
15:42:50 <boegel> okay then...
15:42:55 <boegel> so, that's one suggestions
15:42:58 <kosmikus> the point is only, I won't change anything before tomorrow afternoon, or more likely, before Monday afternoon if it isn't *really* easy, because I'll be away most of the time
15:43:20 <boegel> so it's better to send you patches then ?
15:43:21 <kosmikus> if I only have to apply a darcs patch, that counts as being really easy
15:43:33 <kosmikus> well, right now I'm still here to discuss things
15:43:37 <boegel> apply or reject ? :)
15:43:49 <kosmikus> but if we agree on changes, the easiest thing is to send me patches realising the changes
15:44:17 <boegel> kosmikus: well, I'm not sure if my way of explaining stuff will be better than yours :D
15:44:27 <kosmikus> (sorry, I have a talk to prepare for tomorrow, otherwise I would be more cooperative)
15:44:47 <kosmikus> boegel: don't worry; this is a public document, and probably constantly in flux
15:45:15 <boegel> oh okay then... we'll, besides some sugestions i have, it looks quite fine...
15:45:21 <kosmikus> if someone else can explain better what you mean, he/she will send another patch
15:45:29 <boegel> okay then
15:45:43 <boegel> I should go to bed now, I'll look into patches tomorrow if I can find the time
15:45:50 <kosmikus> ok
15:45:52 <kosmikus> thanks
15:45:56 <Itkovian> gdnight boegel
15:45:56 <kosmikus> your input is appreciated
15:46:24 <boegel> one big thing though... you should mention people how to can use the TMR layout in their document... how should they start ?
15:46:47 <kosmikus> ah, I forgot to mention that they should \documentclass{tmr}, right?
15:47:15 <boegel> yes, I didn't see that... I was wondering :)
15:47:17 <kosmikus> sure, you're absolutely right
15:48:04 <boegel> and maybe also mention which files they need in order to make it work, and where they can get the latest version of those files...
15:48:11 <kosmikus> certainly
15:48:23 <kosmikus> but these things are still likely to change in the future
15:48:35 <kosmikus> at a certain point, I guess the darcs repo will be moved to scannedinavian.org
15:48:36 <boegel> I'm only suggesting :)
15:48:42 <boegel> kosmikus: I see
15:48:51 <kosmikus> yes, yes, and good suggestions they are :)
15:49:11 <boegel> but I like it where this is going... it's no amature thing, but it looks like this will start off quite good
15:49:21 <kosmikus> I'll add a todo to the document
15:49:22 <shapr> yay
15:49:35 <boegel> kosmikus: that's a good idea
15:50:53 <kosmikus> done
15:51:04 * boegel goes to bed now
15:51:20 <boegel> one more day of studying to do for me tomorrow, then it's ove (for now that is)
15:51:57 <boegel> bye everyone ?
15:52:00 <shapr> bye!
15:52:02 <boegel> s/?/!
16:40:02 <dons> moin
16:40:23 <shapr> y0
16:40:44 <dons> heya!
16:40:51 <pesco> moin moin
16:44:03 <shapr> hey pesco, do you have an outline for your Code Probe column?
16:44:32 <shapr> not that I have an outline for my first column....
16:44:38 <pesco> Not yet, but I'll probably review bringert's XML-RPC module.
16:44:52 <pesco> Which, incidentally, looks pretty nice.
16:44:58 <Pseudonym> shapr: What's your column on?
16:45:19 <shapr> Template Haskell tutorial
16:45:49 <shapr> Good choice, I look forward to your explanation of the variable args trick.
16:46:26 * Pseudonym suspects that HList is Haskell's answer to C++ template ugliness
16:47:10 <araujo> Anyone has tried to build ghc-6.4_20050208 by any chance?
16:47:57 <dons> last nights?
16:48:20 <dons> 2 nights ago the head was broken, last night is fine and very stable -- only 2/4000 tests failed
16:48:25 <dons> almost ready for release
16:48:33 <araujo> yes.
16:48:42 <araujo> here im getting an error with 'make html'
16:49:04 <dons> oh, hmm. haven't tested that. seem to recall a thread on one of the ghc mailing lists last week
16:49:48 <araujo> yes, apparently they fixed the problem.
16:49:55 <pesco> shapr: Did you mean me wrt. the variable args trick?
16:50:23 <araujo> but here it throws a different error with make html
16:50:36 <dons> what's the error?
16:51:10 <shapr> pesco: yes
16:51:41 <araujo> http://rafb.net/paste/results/OU3Q9Y66.html
16:52:11 <pesco> shapr: Hm, oh it's used in XML-RPC? Ah yes, I guess now. I only skimmed the paper today ;-)
16:52:40 <shapr> This is beautiful, Alan Kay calls Java the boy band of programming.
16:52:48 <dons> araujo: oh, that's a haddock error. the backslash in \n I think
16:52:53 <Pseudonym> LOL
16:52:57 <Pseudonym> Yeah, I'm reading that now.
16:54:04 <Pseudonym> I sometimes wonder if Haskell is a style language or an agglutinative language.
16:54:23 <dons> arujo: try adding a backslash in front of the / in "I/O" on line 149 of libraries/template-haskell/Language/Haskell/TH/Syntax.hs
16:54:24 <Pseudonym> In recent years it's become a testing ground for type system extensions.
16:54:30 <shapr> He compares the non-academic programming culture to a bunch of illiterates!
16:54:53 <shapr> Man, I thought *I* was vicious and abrasive.
16:55:02 <shapr> I must learn from the Master.
16:55:16 <dons> araujo: haddock likes to see I\/O
16:55:32 <araujo> dons, Ok, let me try that one
16:56:45 <dons> hmm. class Bounded is fun
16:56:53 <shapr> "So the problem is - I've said this about both Smalltalk and Lisp - they tend to eat their young." -- Alan Kay
16:57:15 <dons> he!
16:57:43 <araujo> shapr, i got a vide where he talks very tough about Java
16:57:47 <araujo> video*
16:58:27 <araujo> "For the god the sake, Standfor is the Jhon McCarthy house, and you guys are programming in java"
16:59:53 <shapr> ouch - "All of these ideas could be part of both software engineering and computer science, but I fear - as far as I can tell - that most undergraduate degrees in computer science these days are basically Java vocational training."
17:02:27 <dons> that's not too controversial.
17:02:46 <araujo> hah
17:02:56 <shapr> I can barely grasp how much Alan Kay understands about programming. I want to learn from this guy.
17:04:42 <shapr> I wonder if he's tried Haskell.
17:04:59 <shapr> It seems like it would fit into much (most?) of what he's decribing as good points.
17:05:27 <shapr> Pseudonym: I think Haskell is a style language, that's what I like most about it.
17:05:51 <araujo> yes, he also uses to say that, that java isn't good for learning programming and about computers.
17:05:51 <shapr> But I agree, some strange bits are adhering to the basic idea.
17:06:23 <araujo> It actually retards the process 8)
17:07:16 <araujo> And i agree with the idea that we still don't have a software revolution
17:07:33 <araujo> we keep using the same software approiach that 20-30 years ago
17:07:46 <araujo> In contrasta with the hardware innovations
17:08:06 <shapr> We don't have so much innovation there either.
17:08:16 <araujo> But more than software imho
17:08:28 <shapr> If the Cell doesn't die, it'll force some software changes.
17:08:52 <ozone> shapr: read alan kay's smalltalk manifesto, if you really want to be fascinated
17:09:06 <ozone> the man's a remarkable visionary
17:10:06 <shapr> huh, does Dave Reed's thesis description sound like darcs and Erlang-OTP to you?
17:10:10 <ozone> ah, sorry, i meant "the early history of smalltalk"
17:10:36 <dons> shapr: got a link?
17:10:52 <shapr> http://lambda-the-ultimate.org/node/view/531
17:11:26 * shapr considers moving to Gothenburg and starting a research commune.
17:15:01 <gzl> wow, C++ is seriously ugly.
17:15:40 <dons> they have a bit of a syntax brain explosion, yep
17:16:02 <gzl> i was expecting stroustrup's C++ to be nicer than the average code
17:16:16 <shapr> wasn't?
17:16:55 <gzl> no, i was. it wasn't.
17:17:07 <shapr> :-)
17:17:23 <gzl> i mean, not the design, just the way it looked.
17:19:55 <KrispyKringle> gzl: how'd the talk go?
17:20:15 <KrispyKringle> anyway, it's not as if C++ has the nicest syntax. what did you expect? :P
17:20:23 <gzl> KrispyKringle: it was good.
17:20:30 <KrispyKringle> hmm. Maybe I should have gone?
17:20:41 <gzl> two idiot grad students spilled soda on the floor and fouled up the entire hallway.
17:20:45 <gzl> typical. :)
17:20:47 <KrispyKringle> Haha.
17:21:00 <Pseudonym> shapr: I think Haskell 98 is a style language.
17:21:02 <KrispyKringle> I'm still slaving away here in the lab, though. I think it's good I didn't go.
17:21:12 <Pseudonym> I'm not convinced that all of the glasgow extensions are "style".
17:21:14 <gzl> yeah, probably not.
17:21:32 <dons> Pseudonym: good point
17:21:36 <KrispyKringle> it's a regular party down here. too bad you're not in the course anymore, dude.
17:22:25 <dons> death to implicit parameters, I say!
17:22:35 <Pseudonym> That's an excellent example. :-)
17:22:47 <Pseudonym> All of the problems that are being solved with HList seem... strange, too.
17:22:48 <shapr> yeah, implicit params suck
17:23:03 <Pseudonym> They're good problems, but the HList solution isn't "style" enough for my tastes.
17:23:23 <SyntaxNinja> what's wrong w/ implicit params?
17:23:33 <Pseudonym> I'd like language support for implicit configuration, with no space leak.
17:23:37 <shapr> I realized that Joy and Haskell have very similar style purities.
17:23:45 <Pseudonym> I think that would rock.
17:23:59 <Pseudonym> And it would kill the last argument for implicit params. :-)
17:25:45 <shapr> implicit params kill the style of Haskell
17:25:58 <dons> yep.
17:26:14 <Pseudonym> I think the typeclass-based implicit configuration approach is much more "Haskell".
17:26:22 <shapr> recent thread of concatenative mailing list argued against some Factor features for the same reason, means the language is no longer concatenative
17:26:27 <Pseudonym> But I think we need first-class language support for it.
17:26:29 <dons> if some program you didn't write breaks, and has implicit params, it is much harder to fix than normal hasskell
17:26:47 <dons> hmm.. it's a good obfuscation technique
17:26:53 <ozone> shapr: thanks for the link.  awesome interview
17:27:06 <desrt> implicit params like functions that are lambda abstractions?
17:27:12 <desrt> or something different and more evil?
17:27:21 <ozone> in fact, i don't think i've ever read even an average essay or interview concerning alan kay
17:27:25 <dons> succ succ zeroth... implicit params + unsafecoerce + hlists ... hmm.
17:27:25 <Pseudonym> Implicit params are arguments to functions which you don't have to pass.
17:27:41 <shapr> dons: choose the lesser of two evals ;-)
17:27:52 <dons> ha!
17:28:00 <dons> ooh.. that's good.
17:28:17 <desrt> Pseudonym; that sounds confusing
17:28:24 <dons> slogan for s(s(z)) should be "Choose the lesser of two evals"
17:28:29 <shapr> dons: I think I heard it somewhere in the Python community
17:28:33 <desrt> Pseudonym; how does it know if i want the default case or a partial application of the explicit case?
17:28:34 <slava> :-P
17:28:38 <dons> oh, ok :}
17:28:38 <ozone> desrt: think "default parameters" in e.g. C++
17:28:38 <shapr> dons: excellent, I'll steal that :-)
17:28:41 <Pseudonym> desrt: Yup, it's confusing.
17:28:45 <shapr> hey that was slava!
17:28:51 <ozone> except that the parameters are always default. :)
17:28:59 <Pseudonym> And don't ask me how to use them.  I never have.
17:29:01 <Pseudonym> Because they're evil.
17:29:15 <dons> a bit like $_ in perl too
17:29:23 <dons> a bit.
17:29:28 <ozone> yeah, but even more evil :)
17:29:53 <dons> desrt: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#IMPLICIT-PARAMETERS
17:30:00 <ozone> dons: i wanted support for them in template haskell, of course, since i wanted to do evil things with them in mocha/hoc ...
17:30:10 <dons> oh you bad boy
17:30:41 <ozone> well, it does match the idea of the this/self pointer being an implicit parameter quite nicely
17:30:51 <ozone> whether that's good or bad is another question :)
17:31:10 <dons> shapr, really should be the "greater of two evals" right? since we're encouraging eval in all its monstrous forms
17:31:21 <ozone> it'd also be useful for regex libraries, since e.g. ?_1 is the equivalent to perl's $1 match variables
17:31:46 <shapr> I never did figure out if there's a way to convert a haskell module into a TH AST.
17:32:05 <desrt> dons; please tell me this isn't part of the standard
17:32:14 <dons> shapr: we need a tool... ghc -ddump-ast
17:32:34 <dons> desrt: -fglasgow-exts only.
17:32:55 <dons> must be close to winning a prize for most unpopular extension, though
17:33:06 <desrt> it hurts my eyes
17:33:40 <dons> hmm.. sounds like another good s(s(z)) category: program that uses the greatest number of unpopular extensions
17:33:53 <desrt> why can't you be like gtk
17:34:05 <desrt> gtk_do_something(w,x,y) and gtk_do_something_with_defaults(w)
17:36:34 <shapr> dons: twould be better if it could be done programmatically.
17:37:31 <shapr> import Foo.Bar as FB ; let thAST = Q {| FB |}
17:42:25 <Pseudonym> Lunch.
17:58:09 <dons> shapr: agreed
19:05:19 <sh10151> man, I am getting quite testy lately
19:05:40 * sh10151 has little tolerance for ignorant programmers
19:16:03 <Pseudonym> Gee, it's been quiet.
19:16:07 * Pseudonym should have lunch more often
19:16:20 <Pseudonym> That's got nothing to do with #haskell, it's just something on my TODO list.
19:16:39 <dons> lunch! ha.. for the weak!
19:17:27 <Pseudonym> http://spamusement.com/view.php?id=191
19:19:24 <dons> that's just kooky
19:19:56 <Pseudonym> They all are.
19:21:13 <desrt> why is it that compiler writers always say things like "we're almost as good as C"
19:21:31 <Pseudonym> http://c2.com/cgi/wiki?AsFastAsCee
19:21:37 <Pseudonym> Read and weep. :-)
19:21:40 <desrt> well... yes :)
19:25:49 <desrt> arf.  i get annoyed when people have discussions in wiki articles
19:28:26 <desrt> this is sort of humourous :)
19:32:13 <heatsink> "Some languages ain't fast; some languages ain't slow; some languages are just half-fast" :)
19:44:59 <cm> hallo!
19:45:04 <Pseudonym> G'day.
19:45:20 <cm> hello Pseudonym (:
20:24:20 * tmoertel is back from the Perl Mongers meeting
20:24:45 <Pseudonym> How was it?
20:25:19 <Pseudonym> Can you summarise as a one-line regex?
20:25:19 <tmoertel> pretty good. the featured talk was on using Slony to replicate PostgreSQL dbs
20:26:28 <tmoertel> sure: ($replications{$i++} = $_) =~ s/ID=(\d+)/$1+1/e foreach @database;
20:26:51 <Pseudonym> Got you so far.
20:27:22 <tmoertel> Just add some slide, a laser pointer, and there you go -- the complete talk.
20:27:28 <Pseudonym> :_)
20:27:42 * Pseudonym is so glad he doesn't do that stuff any mor
20:27:52 <Pseudonym> Perl/web dev/SQL stuff.
20:28:16 <tmoertel> yeah, i know
20:28:31 <tmoertel> some stuff in the imperative world seems very crude
20:28:48 <tmoertel> (by comparison (to Haskell), that is)
20:34:11 <sh10151> aaaaah
20:34:43 <sh10151> i don't mind the crude languages nearly as much as the bad programmers
20:35:12 <cm> and loads of libraries available :-)
20:35:28 <sh10151> bad libraries
20:35:32 <cm> ..because then you have to solve actual problems :P
20:50:18 <Pseudonym> I was thinking more along the lines of clients.
20:50:26 <Pseudonym> Clients get in the way of a good web dev task.
20:52:18 <Gahhh> Alan Kay gives an interview on programming languages, fails to mention one of the FP kind. What the ?
20:52:28 <cm> FUD! :o)
20:54:21 <Gahhh> "whoa lisp is described in lisp while the JVM is not."
21:00:02 <cm> :)
21:01:01 <Gahhh> 12 hour workdays suck
21:02:35 <heatsink> The bit on the cell architecture was interesting.
21:02:54 <heatsink> (unrelated suj)
21:04:37 <Gahhh> I dont know why, but I have this weird feeling that the cell is overhyped.
21:07:43 <cm> Gahhh: i think you read that one crackpot's article about it
21:07:56 <cm> ars.technica linked to it a while ago
21:08:35 <heatsink> It's overhyped in the sense that it won't give you any speedup unless you rewrite your program
21:08:41 <heatsink> Sort of like multithreading
21:08:58 <heatsink> Except harder.
21:09:28 <cm> sort of like PS2 programming.. :o)
21:09:52 <Pupeno> Hello, I'm learning Haskell with http://www.cs.ou.edu/~rlpage/fpclassCurrent/textbook/twoDznQ.ps and using the GHCi. I've typed shortPalindrome = "ERE" and I've got this error: "<interactive>:1: parse error on input `='". What am I doing wrong ? (I'm a newbie as you can see).
21:09:55 <heatsink> Well it _is_ the PS3 architecture.
21:10:13 <heatsink> Pupeno: the ghci syntax is
21:10:17 <heatsink> let var = value
21:10:23 <cm> heatsink: indeed
21:10:27 <cm> minus the GPU, of course
21:10:41 <Pupeno> heatsink: oh, thanks.
21:11:23 <cm> Pupeno: in general it is a good idea to put all your code in a Foo.hs file, load it to ghci using :l Foo, and edit the file in your texteditor of choice + use :r to reload
21:11:27 <cm> (for me, at least :o)
21:11:33 <Gahhh> I was going to say the same
21:12:01 <Pupeno> cm: ok, but that required a lot of things I don't know, well, I didn't know, yet.
21:12:20 <cm> Pupeno: just giving tips..
21:12:33 <Pupeno> cm: thanks.
21:14:01 <Pupeno> My project is to make a desktop environment (on X window), probably on Cairo, from the toolkit and up, making the applications and all. I want it to be as light as possible, but also as nice as possible for the programmer. Do you think Haskell would be the right language for this ?
21:14:35 <sh10151> cairo?
21:14:53 <Pupeno> sh10151: Cairo is a graphic library: http://cairographics.org
21:15:47 <Pseudonym> Pupeno: I wouldn't recommend it at the stage you're currently at.
21:15:56 <dons> pretty big project
21:16:17 <Pseudonym> Damn interesting, though.
21:16:20 <Pupeno> dons: indeed, but I'm young and I have the rest of my life to do it :)
21:16:38 <sh10151> now that is the long view
21:17:08 <dons> you could enrol at unsw and do it as an honours thesis project: http://www.cse.unsw.edu.au/~pls/thesis-topics/windowmanager.html
21:17:11 <Pupeno> Pseudonym: can you explain to me how my current stage changes what you'd recomend me ?
21:17:12 <Gahhh> Ok, maybe the question is "Is this a good project to learn Haskell at the same time"/
21:17:36 <Pseudonym> Ah, yes.
21:17:44 <Pseudonym> Well, the answer to Gahhh's question is "not yet".
21:18:02 <Pupeno> Gahhh: I've learn any language I'll use 'before' using it. I even have among my possibilities to create my own language/compiler.
21:18:19 <dons> well haskell is good for that project!
21:18:21 <Gahhh> Ok, how about a text editor for an already existing gnome/kde/etc.
21:18:33 <dons> and that too :)
21:18:54 <Gahhh> then a clock, systray, etc.
21:18:57 <Pupeno> Gahhh: I'm trying to test new concepts on GUIs.
21:19:22 <Pseudonym> Pupeno: Have you looked at the NeXTStep interface?
21:19:27 <Pupeno> dons: will you say that haskell is good for anything ?
21:19:28 * Pseudonym probably didn't capitalise that correctly
21:19:52 <Pupeno> Pseudonym: I've done, to GNUStep to be more precise.
21:19:55 <Pseudonym> Right.
21:20:13 <dons> Pupeno: you might want to look at the existing work on guis in haskell. there is a fairly large array of interesting research
21:20:22 <Pseudonym> It'd be interesting to find analogies for that model in Haskell.
21:20:24 <Pseudonym> Yes.
21:20:31 <Pseudonym> Pupeno: Look at Fudgets, specifically.
21:20:48 <cm> I've enjoyed skimming through the Editor Combinators paper recently.
21:20:52 <Gahhh> Pupeno, testing new concepts may (does?) require a lot of writing and rewriting and throwing away code (imho). You might wanna be good at haskell before any concept work.
21:21:00 <Pseudonym> Haskell is a general purpose langage, which isn't the same thing as being "good for anything".
21:21:26 <Pseudonym> Or "everything", anyway. :-)
21:21:43 <Pupeno> Gahhh: I won't use one of the languages I know just because I know it, I'll spend some time in finding the right language.
21:24:07 <cm> How did Slate prove to be the wrong language?
21:24:11 <cm> prove->show
21:24:23 <cm> "turn out" :/
21:25:02 <dons> Pupeno: you can find the gui work from haskell.org/libraries
21:25:39 <Pupeno> cm: I've found that most dynamic environments have the same problems: they are slow, very slow (I want my desktop environment to work on very old computers) and there's no separation of kernel and userspace.
21:26:15 <Pupeno> cm: Slate or Squeak are like M$ OSs, the user/application has totall power (totall power to corrupt and destroy the system as well as other applications).
21:27:00 <Pupeno> cm: inside Slate or Squeak, there is not even the concept of 'user'.
21:27:46 <cm> The OS does that for you.
21:28:11 <cm> Anyway, maybe you should evaluate Haskell's performance characteristics once you're a bit more familiar with it.
21:28:34 <cm> It's quite unusual in comparison with the kind of language background you have IIRC.
21:30:08 <Pupeno> cm: But Slate and Squeak tend to be OSs on themselves, or do you spect to run a whole VM (any of them) for each application you are running. I have more than 100 processes running on my workstation now, do you imagine 100 squeaks/slates running ?
21:31:04 <cm> Possibly.
21:32:07 <Gahhh> Is a squak gui any faster than Java's swing ?
21:32:47 <cm> no
21:35:04 <cm> Pupeno: Of course I'm not saying that it's practical, I'd like to discuss performance + security as orthogonal aspects (ideal world etc. pla pla).
21:35:53 <cm> Like, claiming that the Squeak user has total power to destroy his environment is a bit like claiming that text editor users have total power to corrupt the text files they are editing ;)
21:36:00 <cm> .oO(unless Clippy saves them :o)
21:37:29 <Pupeno> cm: I disagree. I can destroy the data I'm producing with a program, but I can't destroy the program nor the data of another program nor another program (on a Linux environment for example). It's very hard for me to disturb other users, Squeak/Slate doesn't even separate the users.
21:37:50 <cm> Squeak/Slate runs under your user account.
21:38:11 <cm> The same security model applies to Squeak as to gvim.
21:38:12 <Pupeno> cm: so, you expect each user to be running one Squeak/Slate vm ?
21:38:38 <cm> Do you generally share your text editor among users? :o)
21:38:55 * cm will slap anyone mentioning pair programming or screen
21:39:23 <Pupeno> cm: but you are comparing apples to chairs. gvim is a program, Squeak is more than a program (ok, it's just a program from the linux side).
21:39:41 <cm> You can surely compare its aspects with different programs.
21:39:51 <Pupeno> cm: nevermind, I don't think this discution usefull (and it's way out of topic here).
21:39:53 <cm> For instance, a topless squeak is similar to apache.
21:40:46 <cm> And obviously the same security privileges apply.
21:41:56 <cm> Ok.
23:44:43 <humasect> heller skellers
23:54:23 <musasabi> morning
