00:09:55 <Itkovian> meuning
00:10:10 <earthy> Good Morning, #haskell!
00:17:02 <Itkovian> good korning earthy
00:17:07 <Itkovian> grr morning
00:53:16 * Itkovian is going to upgrade macosx
00:53:19 <Itkovian> ttyl
00:53:23 <Itkovian> I hope ghc still works
00:53:49 <xerox> hiya people.
00:54:17 <Gahhh> god it's late
00:59:32 <earthy> 10:00 am
00:59:34 <earthy> not late
01:01:26 <xerox> 09:00 am isn't late, right.
02:07:37 * genneth contorts his fingers around a dvorak keyboard typing in a password
03:09:35 <geneticp> hello I´m working on genetic programming and also I´m a newbie in Haskell
03:10:08 <Lemmih> Hello geneticp.
03:10:51 * autrijus resists a joke about frogs boiling and scratchpads
03:10:56 <geneticp> my main question is: while in LISP and other functional language, in Haskell it is not possible for a function to build a new lambda expression and return it
03:11:12 <autrijus> f = \x -> x + 1
03:11:14 <autrijus> there.
03:11:16 <geneticp> this is a feature critical for genetic programming
03:11:26 <geneticp> god
03:11:31 <autrijus> f x = \y -> x + y
03:11:52 <geneticp> but how i can construc rather than have it harcoded ?
03:12:10 <autrijus> what do you want to construct from?
03:12:16 <autrijus> quasiquoting?
03:12:21 <autrijus> if so, you can use template haskell
03:12:27 <autrijus> in the Language.TH package
03:12:45 <autrijus> if you want to use string form, then there is a type-safe "eval" function as part of the hs-plugins package.
03:12:54 <geneticp> I mean, In genetic programing an operator is for example, a mutation. a mutation involves the modification of a lambda expression at runtime
03:13:17 <autrijus> but oftentimes you don't need either of those two; just represent your genes as data structures
03:13:26 <autrijus> and mutate them with regular record or data mutators
03:13:37 <geneticp> template haskell can help me on that?
03:13:38 <autrijus> and write a very simple evaluator for the gene minilanguage.
03:13:39 <geneticp> fine
03:14:52 <geneticp> and write a very simple evaluator for the gene minilanguage.<- but this is the thing I´m doing now: to write an evaluator for my own simple language , in haskell
03:15:08 <ndm> geneticp: i'd have thought template haskell was a bit too much
03:15:21 <autrijus> geneticp: if so, then the mutability is in the minilanguage
03:15:33 <autrijus> the evaluator need not to be recompiled at runtime.
03:15:34 <ndm> you should be able to construct a basic data struture, and an interpretter, without too much hassel
03:15:57 <Lemmih> I think TH is pretty unrelated to what you're trying to accomplish.
03:16:04 <geneticp> yes, that is, but I had the hope that haskell had something like eval
03:16:17 <autrijus> Lemmih: indeed. hs-plugins is related, though
03:16:21 <autrijus> but is imho overkill.
03:16:23 <geneticp> and lambda expression manipulation
03:16:33 <geneticp> ok
03:17:12 <Lemmih> Could you elaborate on the lambda expression manipilation?
03:17:27 <geneticp> yes
03:17:44 <geneticp> it has two basic manipulations: mutations and mating
03:18:07 <geneticp> mutation is a random modification of a program, a lambda expression in this case
03:18:13 <autrijus> geneticp: hs-plugins does provide eval; you can manipulate haskell programs as documents (Language.Haskell.Syntax) or as quasiquoted AST (Language.Haskell.TH); but an easier way is to simply use normal data structure to represent mini language, and mutate that data structure, and feed it to an evaluator
03:18:22 <geneticp> matin is a combination of two lambda expressions
03:20:12 <geneticp> autrijus that is what I need to be sure before programming all the stuff
03:20:12 <autrijus> (you can trivially define untyped lambda calculus as a simple data structure in haskell)
03:20:23 <ndm> i think hsplugins is overkill as well
03:20:34 <geneticp> good
03:20:36 <jlouis> ndm: I agree
03:20:41 <ndm> a simple standard data structure is required, so you can do the mutations
03:21:05 <ndm> its just lisp allows the merging of data and functions, in a way that haskell does not
03:21:19 <autrijus> s/does not/prefers not/
03:22:17 <autrijus> if your evaluator becomes so rich that it starts to resemble haskell, then hs-plugins/TH may actually start to make sense.
03:22:17 <geneticp> yes lisp is more flexible but more boring
03:22:34 <geneticp> good point
03:22:42 <autrijus> but not applicable to most GA minilangs, I think
03:23:33 <ndm> a complex language is usually wrong for GA stuff, a Core like language is better
03:23:47 <ndm> or one with situation dependant instructions
03:23:57 <geneticp> I fond the pattern matching also very helpful
03:24:30 <geneticp> ndn yes
03:24:59 <geneticp> the combinatorial explosion grows with the language complexity
03:25:28 <geneticp> it must be simple and as powerful as possible for the domain problem
03:25:29 <Lemmih> OOI, in what way can you modify a function in LISP which you can't in Haskell?
03:25:56 <geneticp> Lemmih in lisp a lambda expression is just a list
03:26:26 <geneticp> you can manipulate it like any other list data
03:26:30 <Lemmih> A list of what?
03:26:32 <ndm> lemmih, you can peel apart the data structure
03:26:42 <ndm> a list of function and arguments
03:26:44 <geneticp> a list of untyped elements, whatever
03:26:51 <geneticp> yes
03:26:55 <ndm> in haskell if you do (12 +)
03:27:05 <ndm> you have a plus function with the 12 bound in and HIDDEN
03:27:13 <ndm> in lisp you could get the 12 back
03:27:38 <geneticp> and you can substitute the 12 by 200 at runtime
03:27:49 <geneticp> even the +
03:28:15 <ndm> while haskell functions are just "black boxes"
03:28:15 <geneticp> or modify it to whatever other expression
03:28:35 <Lemmih> Sounds dangerous. (:
03:28:46 <dons> sounds like runtime metaprogramming
03:28:58 <autrijus> ooh the resident runtime metaprogramming madperson speaks.
03:29:00 <geneticp> yes it is dangerous but very helpfun for some things like meta-programming
03:29:23 <dons> autrijus, you're logo went down well :)
03:29:26 <dons> your
03:29:39 <autrijus> dons: they laughed? :)
03:29:52 <dons> sure!
03:29:56 <autrijus> :D
03:29:59 <autrijus> cool!
03:30:05 <geneticp> hehe
03:30:22 <dons> kind of like: "oh well, we better let you do the phd then"
03:30:53 <autrijus> I wonder if I should put it to haskell wiki somewhere
03:32:00 <geneticp> so TH can do things like LISP with lambda expressions?
03:32:30 <jlouis> Lemmih: you get freedom with lisp. And you get your head cut off many times because of it
03:33:18 <dons> TH is *compile* time metaprogramming, but yes, basically.
03:33:32 <dons> what we don't have is runtime metaprogramming, almost.
03:33:36 <geneticp> aha
03:33:47 <dons> you can manipulate ASTs at runtime, and then feed them to hs-plugins' eval though
03:34:05 <dons> there's even a MetaML primitive lib based on eval and TH i'm toying with
03:34:42 <autrijus> dons: I've done the TH+hs-plugins route for Pugs's runtime use of haskell modules too :)
03:35:04 <autrijus> I'm addicted ever since.
03:35:15 <dons> ah, ok. cool. I better look at that then.
03:35:26 <geneticp> good I will ckeck it
03:35:42 <autrijus> dons: although the TH part is just taking apart the signatures
03:35:54 <autrijus> and manufacture a symtable-like new function
03:36:07 <dons> right.
03:36:14 <autrijus> I think I'll make use of it more heavily when the PIL->TH compilation backend
03:36:18 <autrijus> is in place
03:36:32 <autrijus> (PIL being the Pugs intermediate language thing)
03:36:33 <dons> really, TH lets us do runtime metaprogramming, almost, with the splice() replaced by an eval()
03:36:53 <autrijus> I don't see any "almost" about it
03:36:57 <autrijus> I think that's the real deal :)
03:37:29 * dons makes a funny face and mutters something about semantics
03:37:45 <dons> eval forces us to use closed code in splices
03:37:57 <dons> also, there's no cross-stage persistence.
03:38:11 <dons> though-- in pugs you've got an AST going anyway, so you can do *heaps* more tricks
03:38:21 <dons> than in a normal compiled haskell app
03:38:23 <autrijus> yes :)
03:38:35 <autrijus> I'm in ContT ReaderT
03:38:44 <autrijus> so there's vastly more state to shuffle around in each eval
03:39:51 <dons> also, to be typesafe, we need to check the splice points at runtime
03:40:06 <dons> so you either use Dynamic (and have only monomorphic splices) or try something trickier
03:40:22 <autrijus> I still think Evalable is a good idea
03:40:41 <dons> well, we use to have an Eval class in Haskell 2, I think (?)
03:41:13 <autrijus> sort of like a two-arg class for compatibility of splice and reply type
03:41:23 <dons> ah, interesting.
03:41:37 <autrijus> so it's more like "Liftable across eval"
03:42:20 <geneticp> And the minor question: I made the language tree structure, but some extra info is needed to store the available methods, their arguments, an return types for my minilanguage what could be the best way to store it apart from the program tree and how to access it by method name? . I´m sorry for my ignorance
03:43:54 <autrijus> define another data structure.
03:44:13 <autrijus> use record syntax to simplify access if needed
03:44:20 <Wed30367> Haskell 2: reloaded?
03:44:55 <geneticp> a list of tuples?
03:45:38 <autrijus> data Prim = MkPrim { primName :: String, primParam :: [Param] ... }
03:45:51 <autrijus> type Env = [Prim]
03:46:18 <geneticp> with named fields ok
03:46:41 <dons> or was Haskell 2 called Haskell B?
03:46:56 <geneticp> thanks
03:47:54 <autrijus> np. if your minilang is allowed to shadow bindings of prims
03:47:54 <autrijus> then
03:48:06 <dons> people seem to refer to `Haskell 3000' as `Haskell 2' these days
03:48:13 <autrijus> type Env = [(String, Exp)]
03:48:47 <autrijus> data Exp = Prim {...} | Lit ... | Lam ... | App ...
03:49:02 <autrijus> the ... depends on what your minilang looks like
03:50:10 <geneticp> if fact when i mutate a program tree I must access the list of allowed methods and to insert in the program a method with the same return type that the originary method at this position
03:51:02 <autrijus> mm your language is typed. more fun
03:51:50 <geneticp> yes, typing is very helpful. I need it. I can not multiply two strings. typing is essential
03:52:12 <geneticp> if not, mutation would be disastrous
03:52:21 <Wed30367> dons, what are concrete plans regarding to Haskell 3000/reloaded/B ?
03:52:54 <dons> no no, Haskell B was a 15 years ago.
03:53:58 * ski thought lambda-exprs in lisp was opaque (as opposed to lists of symbols and stuff, which can be passed to eval --)
03:54:01 <geneticp> uless I restrict the domain of programs to one only type of data manipulation, for example mathematical expressions with float only parameters
03:54:28 <Wed30367> ow ok
03:54:39 <Wed30367> so what about the new haskell :D
03:55:04 <ski> can you (in e.g. common lisp) take apart  #'(lambda (x) (+ x 10))  ?
03:55:53 <Wed30367> hahah ski is coming with totally obscure stuff
03:57:18 <ski> Wed30367 : http://www.haskell.org/hawiki/HaskellTwo
03:58:56 <ski> <Lemmih> OOI, in what way can you modify a function in LISP which you can't in Haskell?
03:58:56 <ski> <geneticp> Lemmih in lisp a lambda expression is just a list
03:58:56 <ski> <geneticp> you can manipulate it like any other list data
03:59:17 <geneticp> yes ski, as far as i know
03:59:32 <ski> i guess i don't see what geneticp meant by 'you can modify a function in LISP'
03:59:44 <geneticp> at runtime, i mean
04:00:00 <ski> afaik, one can not "take apart" a function in Lisp
04:00:09 <ski> runtime, yes
04:00:47 <geneticp> what is taking apart in this context? sotty I´m no native english speaker (a my english is limited)
04:00:50 <ski> another thing would be a feature to look up a symbol against current definitions and possibly getting back it's definition ..
04:02:11 <genneth> i think geneticp's point is that in lisp you can change the expression at will, then have the entirety of lisp available to run it; in haskell, we can build a compiler/intepreter for a dsl, but it would be a subset of haskell's full power
04:02:29 <ski> you seemed to be wanting to take apart (implementation) of functions and mutate some parts etc. but afaik, you cannot do this in Lisp either
04:03:27 <ski> geneticp : if you (defun f (x) (+ x 10)), then i don't see how you can change the body expression of f at will (at runtime)
04:03:54 <geneticp> with list processing primitives ski
04:04:01 <ski> but f is not a list
04:04:08 <ski> f is a function/prodecure
04:04:13 <geneticp> yes it is
04:04:16 <tromp> lisp has a sort of built in template-lisp
04:04:19 <ski> (car f) is a runtime error
04:04:27 <geneticp> let a (lambda x y (.......
04:04:27 <dons> genneth, but you *can* build and change a haskell expression at runtime -- with Language.Haskell.TH -- and then run it with all of Haskell, using Language.Haskell.Eval
04:04:45 <geneticp> ski in lisp everiting is a list
04:04:57 <ski> in lisp a number is not a list
04:05:01 <ski> a function is not a list
04:05:04 <genneth> dons: but I thought that TH ran at compile time...?
04:05:08 <tromp> you just have to get used to the quoting/unquoting rules
04:05:25 <ski> it's another matter that the syntactical representation of a function implementation is a list
04:05:27 <geneticp> every structure is al list of elemenst that can be of any type
04:05:38 <ski> when it's compiled/evaled, it's no longer a list
04:05:53 <genneth> dons: specifically, TH runs intepreted in the compiler, and helps to generate the resulting code which is then compiled
04:05:58 <ski> don't confuse the AST with what the AST compiles/evals into
04:06:00 <dons> TH consists of a data type and a splice mechanism, basically. the data type works at compile time or runtime time.
04:06:04 <tromp> the troublesome part is that the value of an expression depends on how many times youy evaluate it:(
04:06:05 <genneth> i supposed there's actually not much different
04:06:14 <dons> the splice mechanism happens in the compiler, using ghci
04:06:25 <dons> at runtime, you use Language.Haskell.Eval to do splices
04:06:36 <dons> (this is very new stuff by the way, less than 12 months old)
04:06:47 <genneth> so it basically does come down to having an intepreter built into the runtime?
04:06:55 <dons> but its what autrijus and I were talking about earlier
04:07:17 <dons> you *could* have an interpreter at runtime (just like TH uses one a compile time)
04:07:20 <ski> geneticp : the syntax of every structure in lisp is either some atomic thing (like number etc) or a list
04:07:27 <dons> but instead, we use the compiler at runtime, and dynamic linking
04:07:34 <geneticp> an interpreter in the runtime that is in the implementations of lisp. short of
04:07:36 <dons> then the generated code runs at full speed.
04:08:04 <dons> yeah, this is how lisp does its thing.
04:09:56 <ski> geneticp : how come, if f (defined above) is a list, then (listp #'f) yields f ?
04:12:24 <geneticp> mmm
04:12:39 <geneticp> let a (lambda x y (.......
04:12:49 <geneticp> eval a
04:13:14 <geneticp> let b  a
04:13:25 <geneticp> let a= "hello"
04:13:29 <geneticp> eval b
04:13:35 <geneticp> are right
04:13:49 <ski> (let ((a #'(lambda (x y) ...)))  (eval a))   % this binds a function to a, and then attempts to eval it
04:13:56 <ski> that results in error
04:14:03 <geneticp> yes I think
04:14:30 <geneticp> I´m not a lisp expert, but i played a lot with it in the past
04:14:32 <ski> (let ((a '(lambda (x y) ...)))  (eval a))   % this binds a *list representing the AST* of a function to a, and then attempts to eval it
04:14:38 <ski> which is o-kay
04:14:49 <shapr> dblhelix: It wasn't announced...
04:14:57 <geneticp> eval (a  x y)  sorry
04:15:27 <ski> rather  (funcall (eval a) x y)   (in e.g. common lisp)
04:15:43 <ski> in scheme it'd be just  ((eval a) x y)
04:15:55 <geneticp> that depends on the dialect
04:16:09 <ski> exact syntax, yes
04:16:25 * ski is not a lisp expert, either
04:17:17 * shapr hath no ideath
04:19:18 <ski> anyway, in lisp a function is a function, not a list, just as in haskell, and those functions are opaque, you can not muck around with the impl of them
04:20:17 <geneticp> his representation is a list, and you can do with it whatever you can with a list
04:20:43 <ski> (maybe some lisp has some kind of reflective feature that allows to get the representation of a function, whether it'd be a sexp AST, or asm (bytecode or native) ..)
04:20:58 <shapr> I think you mean the source code vs the actual function.
04:21:17 <dblhelix> shapr: ah, okay
04:21:21 <ski> yes, (i think) you are speaking of mucking around with representation/AST of functions, *and then* you call eval to get a function from that
04:21:32 <shapr> You can treat the source as an abstract syntax tree, that's how macros work.
04:21:42 <ski> indeed
04:21:45 <dons> hehe. haskell has this. with unsafeCoerce# you can read the bytes of a closure, of the actual function.
04:21:46 <shapr> dblhelix: I had the forlorn hope that there would be five articles at some point this month.
04:21:53 <geneticp> I know some compilers create machine code when you apply something like  "compile"
04:22:18 <shapr> dblhelix: So, you want to write for next month's TMR?
04:22:32 <dons> hacker bonus points to some who, with unsafeCoerce#, can turns (+ 1) in (+ 2) without a segfault
04:22:44 <geneticp> if you do (compile a) in golden common lisp, then the lambda expression dissapear and a machine code pointer is assigned to a
04:22:48 <shapr> Sounds like a winning IOHCC entry.
04:22:50 <geneticp> then you can not modify it
04:22:57 <dons> so many typos. should stop typing in a horizontal position.
04:22:58 <ski> dons : only if you happen to know how the particular implementation represents functions  (might e.g. be an index into some, to you, unknown array of bytecode, not just a plain mem address)
04:22:59 <dblhelix> shapr: :) have nothing to write about though ;)
04:23:09 <shapr> dblhelix: Don't you work with Haskell?
04:23:25 <dons> ski, yes, you *need* to know the representation. see the IOHCC entry shapr's talking about ;)
04:23:40 <earthy> dons: big hacker bonus points if you can do that portably
04:23:44 <dons> it's easy to find out with -ddump-cmm ;)
04:23:56 <dons> earthy, quite so.
04:24:02 <shapr> dons had a winning IOHCC entry that did crazy stuff with compiled representations.
04:24:04 <dblhelix> shapr: I do, but I don't do anything that's worth mentionable at the moment; as soon as I do, I let you know
04:24:41 <shapr> dblhelix: You could write a bit about Top.
04:24:42 <geneticp> ski: may this can clarify something    if you do (compile a) in golden common lisp , then the lambda expression dissapear and a machine code pointer is assigned to a
04:24:42 <dons> shapr, but that only read the fields out. it didn't chase pointers or write anything. that's phase 2. phase 3 == profit, of course.
04:24:59 <dblhelix> shapr: as a matter of fact, I use the UUAG system quite frequently lately, but I saw you had that one already covered ;)
04:25:44 <Itkovian> any suggested way to install ghc 6.4 on Tiger?
04:25:47 <ski> geneticp : ok, hm
04:26:04 <earthy> itkovian: darwinports?
04:26:06 <shapr> I'd like to read more about attribute grammars. I still don't see how they can do all the stuff that monads can do.
04:26:13 <earthy> the can't
04:26:14 <earthy> +y
04:26:23 <shapr> Oh
04:26:25 <Itkovian> earthy: only has 6.2.2 ... maybe use that to bootstrap ...
04:26:26 <earthy> they are in a completely different domain
04:26:33 <shapr> ok then
04:26:37 <shapr> That's what I thought.
04:26:41 <ski> :)
04:26:59 <shapr> dblhelix: You want to write a bit about constraint based type inferencing?
04:27:23 <shapr> dblhelix: Is there a connection between type error slicing and cbti?
04:27:38 <shapr> Seems to me like they should be nearly the same thing.
04:28:04 * ski seem to recall one paper on type error slicing using constraints
04:28:43 <shapr> So I wonder, can you get type error slices from constraints directly? Or does it require extra work on top of the constraint inferencing?
04:29:21 <dblhelix> shapr: I can write something constraint based typing, but I can't promise you it'll be for next month's issue ... I've just started at my new job... so I'm rather busy giving myself a good start... reading, reading, reading
04:30:07 <pejo> Itkovian, doesn't the binary distribution on ghc homepage just work <tm>?
04:30:17 <shapr> dblhelix: Sure, no hurry. Do you think it's possible you could show working code that did a tiny bit of cbt for a tiny limited interpreter? Or is that asking a huge amount? I have no idea how difficult that is.
04:30:17 <dblhelix> shapr: it's kind of our philosophy that it's good to do it on top of constraint inferencing instead of integrating it ;)
04:30:44 <dblhelix> shapr, no it's actually very well doable, I think
04:30:47 <Itkovian> pejo: I am trying now ...
04:31:41 <pejo> shapr, "cbti"?
04:31:47 <shapr> My favorite TMR articles include small code examples that demonstrate the ideas. That way I can read all of the code, and it's small enough that I can modify it.
04:31:55 <shapr> pejo: constraint based type inferencing
04:31:55 <dblhelix> pejo: constraint-based typing
04:32:09 <dblhelix> pejo: or type inference, rather
04:32:29 <shapr> I first read about that in 2003, Martin Sulzmann's work.
04:33:41 <dblhelix> shapr: I'm currently studying Sulzmann's work on other constraint-based analyses than type inference
04:34:58 <jlouis> cpu assembly scheduling?
04:35:25 <jlouis> Crack that nut, and Itanium becomes rather fast
04:35:37 <dblhelix> jlouis: less ambitious, binding-time analysis, strictness analysis :)
04:35:46 <shapr> strictness would be quite handy.
04:35:56 <jlouis> so is binding time analysis
04:35:58 <shapr> Actually, so would binding-time
04:36:15 <shapr> For example, that could really improve the typeclass system in Haskell.
04:36:41 <jlouis> with bind-time analysis you can run partial evaluation in the compiler
04:37:00 <shapr> And you might be able to float constraints up as well as down.
04:37:08 <dblhelix> from what I understand Glynn and Sulzmann's binding-time analyser is integrated in GHC
04:37:45 <shapr> Cool, I'll add that to my reading list.
04:37:50 <dblhelix> as of 2001 or so
04:38:13 <pejo> jlouis, isn't Itanium already rather fast?
04:38:32 <dblhelix> shapr: Glynn et al, "Boolean constraints for binding-time analysis"
04:38:45 <jlouis> pejo: for long floating point basic blocks yes
04:39:41 <jlouis> pejo: in general, I am thinking of scheduling of an In-order executing CPU. The Cell or Xenon are also in this class
04:40:32 <Itkovian> pejo: ok, works ... maybe the webpage should say Panther or above or >= 10.3.0
04:41:47 <shapr> nothingmuch: You're twins!
04:43:54 <pejo> jlouis,  HP Integrity rx4640-8 (1.6GHz/9MB Itanium 2) seems to do rather well on both specfp2000 and specint2000. Beats a 3.6Ghz Xeon on SpecInt.
04:44:41 <pejo> jlouis, isn't the size of the basic block one of the things that get in the way for more ILP as of today though?
04:44:49 <shapr> Yeah, but that's because it's a big single homogenous chunk of calculations.
04:45:56 <pejo> shapr, but then it's not limited to big bb's of fp ops, it works well for any large size bb's.
04:46:52 <shapr> As far as I understand it, the Itaniums are good at doing server stuff, where deep pipelines are useful.
04:47:11 <shapr> The Cell cpu is designed around having almost zero pipelining.
04:48:36 <shapr> The advantage of little or no pipeline is that you can put a bunch of simple CPUs in the same die space as one CPU with a deep pipeline. And you can make those simple CPUs effectively faster because there's less distance between the RAM and the CPU itself.
04:48:48 <pejo> shapr, but at every context switch you flush the pipeline. Isn't the deep pipeline of P4 one of the reasons they 'invented' Hyperthreading?
04:49:15 <shapr> Yes, hyperthreading is just cute cache stuffing.
04:49:15 <earthy> yups
04:49:44 <earthy> in fact, the reason for itanium's explicitly parallel instruction code is to make shorter pipelines
04:50:34 <earthy> the problem is that development in dynamic instruction rescheduling has had so much more investment thatn static instruction scheduling, that it is nearly impossible to get an itanium to perform at full speed
04:51:00 <Wed30367> i wasnt born with enough middle fingers
04:51:30 <pejo> shapr, there's more than just the pipeline that occupies space in a modern CPU as of today. Sun has some multicore chip which shares 1 fp execution unit between all cores iirc.
04:51:48 <shapr> Wow, which cpu is that?
04:52:58 <tomdavie> I thought IBM's 8 FPUs for two cores was a bit more impressive
04:53:09 <pejo> earthy, instruction scheduling in general is NP-complete though? Or do you mean finding an effective heuristic?
04:53:23 <shapr> pejo: Hej, you're in the next city over from me. Do you know if there's any sort of regular Haskell geeky meeting in your town?
04:53:29 <pejo> tomdavie, something tells me they're not aiming for the same market.
04:53:41 <earthy> pejo: doesn't matter if it is np-complete or not
04:53:55 <tomdavie> pejo: large clusters IIRC
04:54:04 <tomdavie> ... and playstations of course
04:54:05 <earthy> thing is that dynamically rescheduling x86-streams is a shitload more developed than statically scheduling C code for EPIC
04:54:27 <Wed30367> shapr, is craving for geeky haskell meetings?
04:54:30 <shapr> Personally, I like the idea of simple CPUs like the Cell and better scheduling with declarative parallelism.
04:54:33 <shapr> Wed30367: as always?
04:54:38 <Wed30367> hehe i dont know
04:54:52 <tomdavie> shapr: the cell is what I'm talking about... it's far from simple
04:55:02 <shapr> It's funny how my IRL friends don't like to hear about arrows.
04:55:03 <tomdavie> the 2 cores are simple
04:55:06 <Wed30367> i'm personally not able to follow this hardware jibbertalk :)
04:55:14 <tomdavie> but trying to make them talk to 8 FPUs is not
04:55:22 <shapr> Cell has nine cores if you count the SPEs
04:55:32 <tomdavie> 10 I thought...
04:55:41 <shapr> Have you seen Manual Chakravarty's parallel arrays?
04:55:55 <pejo> shapr, its' called "Niagara". A pic is avail on http://blogs.sun.com/roller/page/jonathan/20040910#the_difference_between_humans_and
04:55:55 <shapr> Nah, one simplified ppc 601 and eight sidekick cpus.
04:55:56 <tomdavie> the 8 I was refering to were the SPEs (just modified AltiVec units)
04:56:15 <tomdavie> oh... I thought it was 2 750s
04:56:45 <pejo> shapr, heh, don't think so. The language group is pretty limited around here.
04:57:38 <shapr> How many Haskellers at LuleÃ¥ ?
04:58:13 <shapr> I've heard about HÃ¥kan somebody.
04:58:25 <tomdavie> shapr... after some reading... it's 1 core, but it's a 750
04:58:29 <tomdavie> (modified)
04:58:30 * nothingmuch sees his name was mentioned
04:58:40 <pejo> shapr, it's taught in first and second year classes, really not a community around it. All work is centered around Timber, but thats 3-6 people, if you count optimistically.
04:59:00 <nothingmuch> too bad I don't know how to search with irssi =P
04:59:11 <nothingmuch> shapr: twins? you mean nothingmuch and nothing_pasta?
04:59:24 <nothingmuch> nothing_pasta lives on my box at home, and nothingmuch lives on my laptop
04:59:41 <pejo> shapr, ah, Håkan Jonsson? He's the teacher for those classes I think. his dissertation was computational geometry (Traveling salesman problem with fences and <...> iirc).
05:00:13 <pejo> shapr, you in Uleåborg or smth like that?
05:00:18 <shapr> I'm tempted to show up at LTU and get a degree.
05:00:30 <shapr> Nah, I'm in that world famous Mecca of technology, Boden!
05:01:00 <shapr> nothingmuch: Does that mean you only get food at home, so the nickname is there to motivate you to leave work on a regular basis?
05:01:34 <shapr> nothingmuch: You can probably do /last nothingmuch
05:01:45 <shapr> or maybe /lastlog
05:02:27 <pejo> earthy, ok, I don't follow. How does it not matter whether instruction scheduling is NP-complete or not?
05:02:50 <shapr> pejo: That sun cpu looks nice, but I'd rather have something cheap and powerful that runs Linux.
05:03:28 <shapr> Do you think that Sun cpu will do better than the IBM cpu he mentions?
05:04:07 <Philippa_> I'd like a chance to hack around with a Cell
05:04:12 <pejo> shapr, I don't know much about those CPU's, I was just pointing out that IBM isn't exactly alone about those ideas.
05:04:23 <Philippa_> dunno how much I'd get done though, my productivity drops /bad/ when I have to code in a lower-level lang
05:04:39 <Philippa_> of course not. IBM's throwing out consumer-space product though
05:04:55 <nothingmuch> the reason nothing_pasta exists is for having a persistent connection so I can see logs and get messages
05:05:13 <pejo> shapr, if you want a degree and some fp - go to Chalmers I'd say.
05:05:13 <shapr> nothingmuch: Couldn't you use screen on a single server?
05:05:40 <shapr> pejo: Yeah, but I live in Boden which is only half an hour from LuleÃ¥, so it'd be a lot easier to get a degree there.
05:05:51 <shapr> I already have some fp clue.
05:06:41 <shapr> I really just want a betyg
05:07:08 <tuomov> and can't you do courses in other unis if there's some course you really want the cu's from?
05:07:46 <tuomov> of course, e.g. chalmers is a bit far to go for a few lectures..
05:10:03 <shapr> Or I could go for something different like a math degree. I think it'll be hard to find new CS stuff that I want to learn in classes, but new math stuff would be easy to find.
05:10:08 * shapr likes that idea
05:10:55 <shapr> pejo: Any sort of geeky programming language theory meetings at all?
05:11:00 <genneth> why not go for something differently entirely... physics?
05:11:29 <tuomov> something different entirely would be something in the arts or something
05:11:40 <pejo> shapr, yeah, if you don't want to relocate I guess LTU is your only chance.
05:12:07 <shapr> tuomov: I tried that one before.
05:12:15 <pejo> shapr, not that I know of. There are some graduate courses relating to programming language stuff sometimes.
05:12:18 <shapr> I have more art education than anything else.
05:12:30 <shapr> You think I could attend the graduate courses without having a degree?
05:12:43 <pejo> shapr, as for math - it's either numerical stuff or analysis up here.
05:13:17 <shapr> I'm not very informed about math, but group theory stuff seems interesting so far.
05:14:06 <pejo> shapr, uh, heh. I have no idea. You ask a lot of hard questions. :-)
05:14:24 <tuomov> almost every uni probably has the basic courses on that, but for more advanced stuff... well you can't find much in .fi at least, and I don't know if it is much done in .se either
05:14:29 <shapr> Yeah well, thanks for sharing what you know :-)
05:15:50 <tuomov> I don't think group theory is that "hot" research area anymore either
05:16:07 <tuomov> with all the groups having been classified and so on
05:16:11 <pejo> shapr, basic algebra is a part of "Matte C" I think. Goes nation wide, I think.
05:23:17 <Wed30367> shapr, graduate courses are for people that don't have a degree yet right? or are we having a lingual mixup
05:23:31 <shapr> No, that's undergraduate.
05:23:44 <Wed30367> ow check
05:23:48 <shapr> 'graduate' implies getting a degree.
05:23:49 <Philippa_> graduate courses are for graduates, ie people who've graduated
05:24:08 <Wed30367> graduated people are not on university anymore right....
05:24:23 <hyrax42> theyr'e graduate students
05:24:31 <hyrax42> students for masters or phd or whatever
05:24:32 <shapr> They could still be in university, but it means they've completed some part.
05:24:47 <Wed30367> university offers coarses for persons that are already graduated?
05:24:54 <hyrax42> and undergrads can often take grad courses with permission
05:25:07 <hyrax42> who hold a bacherlor's degree or equivalent, yes
05:25:09 <earthy> undergrads are going towards bachelor's
05:25:14 <dblhelix> Wed30367: B.'s wanting to become M.; M. wanting to become Ph.D.
05:25:21 <hyrax42> they go back for some higher degree
05:25:25 <Philippa_> B. wanting to become Ph.D too
05:25:27 <Wed30367> does anyone know the dutch equivalence of graduate coarses?
05:25:39 <Wed30367> seminaria?
05:25:48 <Wed30367> master vakken?
05:25:58 <Wed30367> doctoraal vakken?
05:25:58 <Philippa_> (or possibly just BSc.Hons -> PhD, I'm never sure about that part)
05:26:00 <dblhelix> Wed30367: the latter
05:26:12 <earthy> master vakken
05:26:18 <Wed30367> ow check
05:26:22 <earthy> 2nd years doctoraalvakken don't count
05:26:32 <tuomov> in .fi and .se master's was an undergrad degree..
05:26:46 <Wed30367> i dont want msc i want my drs
05:26:53 <Wed30367> i have a right to that
05:26:54 <tuomov> in .fi they changed it for next year
05:27:03 <tuomov> now everyone is supposed to do B too
05:27:12 <earthy> yeah, in .nl it used to be undergrad until drs.
05:27:19 <earthy> technically
05:27:24 <shapr> I wish I could test out of the classes. Classes are almost always boring, but learning itself is fun.
05:27:41 <shapr> Why can't I actually do some learning in the *classes*?
05:27:51 <hyrax42> indeed
05:27:54 <hyrax42> :(
05:27:56 <tuomov> because most lecturers suck?
05:28:02 <shapr> tuomov: I think so.
05:28:04 <Wed30367> shapr, i thought you were a phd student
05:28:19 <Wed30367> i mean, you always talk about obscure stuff and so on :D
05:28:27 <shapr> Wed30367: No, I had a computer class once in 1992, that's the extent of my formal education.
05:28:35 <shapr> Everything else I taught to myself.
05:29:06 <shapr> Who needs college? It just slows you down :-P
05:29:21 <Wed30367> what a pitty, since the outside world requires some formal proof of your education
05:29:31 <shapr> Yeah, I agree.
05:29:44 <shapr> And writing articles for The Monad.Reader doesn't count.
05:29:47 <Philippa_> nah, the outside world mostly requires x years experience. The education is just an excuse for an entry-level job
05:29:57 <dblhelix> Wed30367: is that your def. of a Ph.D. student? s.o. who talks about obscure stuff? *grin*
05:30:01 <shapr> As I often say "I've tried to teach people autodidactism, but I've realized they have to learn it for themselves."
05:30:02 * earthy knows about a certain prof. C. H. A. Koster
05:30:27 <earthy> no, that's not prof. dr. Koster. Nor prof. drs. Koster. Just prof. Koster
05:30:30 <Wed30367> dblhelix, most of the time, a lot of phd students are talking about stuff and i don't even notice they're speaking my language
05:30:42 <shapr> Anyway, I don't talk about obscure stuff, just interesting stuff ;-)
05:31:29 <Wed30367> hey earthy, is using USE-copy rules to leave out semantic rules for production considered bad style? cause i find it quite useful :D
05:32:03 <earthy> um
05:32:19 <shapr> earthy: Prof Koster has no degree?
05:32:32 <earthy> shapr: exactly. he was a physics major, but never graduated
05:32:37 <pejo> About classes - the good part is that they're normally taught by someone who already knows the material. Therefore the contents should be rather well designed.
05:32:38 <shapr> Huh, neat.
05:32:46 <earthy> due to doing too much computer science on the side
05:32:55 <shapr> Hah, that's funny.
05:33:24 <shapr> CS is rather addictive.
05:33:34 <hyrax42> pejo, one would hope
05:33:41 <shapr> I'm saving up for ATTaPL at the moment.
05:33:46 <earthy> wed30367: depends. using USE-copy rules to *eliminate* excessive replication of semantic rules is considered good style
05:33:53 * hyrax42 is still bitter over recent programming languages and paradigms course
05:33:57 <pejo> earthy, did you answer why it didn't matter if instruction scheduling was npc or not?
05:33:58 <shapr> "The other brick book"
05:34:07 <hyrax42> what is ATTATAPTPL/
05:34:09 <earthy> pejo: um, no
05:34:11 <shapr> hyrax42: What happened?
05:34:18 <hyrax42> guy was useless
05:34:20 <shapr> @where tapl
05:34:21 <lambdabot> I know nothing about tapl.
05:34:34 <hyrax42> ah, TaPL I know of
05:34:35 <shapr> hyrax42: That's happened to me in most of my courses.
05:34:36 <hyrax42> same book?
05:34:43 <hyrax42> well this guy especially so
05:34:43 <earthy> but, it really doesn't, since dynamic instruction scheduling manages to get higher utilisation than static instruction scheduling, currently
05:34:43 <Wed30367> earthy, i want for example only to define the attribute for a handful of productions....the rest i dont want to have to type lhs.foo = <<base case>>
05:34:50 <shapr> Nah Advanced Topics in TaPL
05:34:51 <Philippa_> nah, ATTaPL is the sequel (Advanced Topics in TaPL)
05:34:55 <Philippa_> jinx!
05:34:58 <shapr> hah
05:35:01 <earthy> wed30367: that is exactly what user-defined copy rules are for
05:35:08 <Wed30367> kickass
05:35:09 <Wed30367> thanks
05:35:11 <pejo> earthy, have you read the optimal instruction scheduling papers by Wilken and <...>?
05:35:16 <hyrax42> he used (null? 1) and (null? '()) when he wanted to return #f and #t in scheme
05:35:17 <earthy> nope
05:35:18 <Wed30367> ahaha i have ATTaPL lying around but absolutely no time
05:35:19 <earthy> haven't
05:35:27 <hyrax42> at least the solutions to assignemnts did
05:35:29 <shapr> Wed30367: Mail it to me! ;-)
05:35:34 <earthy> or me!
05:35:37 <shapr> I really want to read it.
05:35:42 <earthy> :)
05:35:43 <Wed30367> earthy, you can lend it from jur
05:35:45 <shapr> I'm especially interested in region allocation.
05:35:46 * earthy has no time
05:35:50 <hyrax42> that's just a silly example, but he was generally useless
05:35:56 <earthy> I can borrow it from dblhelix, should the need arise
05:36:03 <shapr> hyrax42: that's sad
05:36:09 <Wed30367> or maybe dblhelix, borrowed it from jur in turn :D
05:36:09 <hyrax42> you're telling me
05:36:20 <Wed30367> or the book i saw lying around was dblhelix's to begin with
05:36:21 <Wed30367> :)
05:36:21 <shapr> I don't know Scheme, but I know more than that.
05:36:21 <hyrax42> cos my alternative to taking the course was to work throuch sicp by myself
05:36:30 <hyrax42> which I have to do now anyway
05:36:35 <shapr> Actually, that's really fun. SICP kicks butt.
05:36:38 <hyrax42> not like the course was required
05:36:43 <Wed30367> earthy, you know they are actually considering to use ATTaPL in a course!!
05:36:45 <shapr> Working through it by yourself or with others is really a blast.
05:36:51 <earthy> oh goody
05:36:54 <hyrax42> well yeah, but I was thinking it would happen with the course, since it was the text for th ebook
05:36:59 <earthy> ATTaPL in a course
05:37:00 <pejo> earthy, he's done a bunch of optimal <...>, register allocation for example. solves it with Linear Integer Programming. It seems doable with todays computers and CPLEX. But of course his aim isn't EPIC.
05:37:12 <earthy> pejo: ah
05:37:33 <Wed30367> i mean,....TaPL was quite overwelming in the way doaitse brought it hehehe, like to see him doing ATTaPL in that pace lol
05:37:36 <shapr> hyrax42: Anyway, it doesn't matter SICP is so good that you don't need anyone else to help you out. You may want to find a nearby theory expert just in case you have really deep questions, but that's about it.
05:37:41 <hyrax42> shapr, would you reocmmend doig all exercises?
05:37:50 <hyrax42> #haskell and #scheme are my nearby experts :o
05:37:54 <hyrax42> :)
05:38:14 <hyrax42> and mostly I just lament losing two months
05:38:14 <hyrax42> on it
05:38:15 <pejo> earthy, anyways, as I've understood it the amount of paralellism depends on the size of the basic blocks, and how dependent each statement is on next. With small basic blocks there isn't much to do, no?
05:38:24 <shapr> It depends on the time you have available. SICP exercises go from easy to deep.
05:38:32 <hyrax42> aye
05:38:48 <hyrax42> and if I skipped any it'd be easy, but I think I should do all
05:38:54 <shapr> So, I'd recommend you always do the simple exercises, and base the rest of your effort on motivation.
05:39:04 <earthy> pejo: the term basic block is one you're going to have to scrap if you want to do good instruction scheduling
05:39:08 <hyrax42> I know myself too well
05:39:21 <shapr> I'd also recommend you come back through SICP a second time and do as many of the exercises as possible. You will learn very much about programming.
05:39:22 <Wed30367> hey is making all exercises in TaPL a good idea or will that extend your reading period with one year :D
05:39:27 <earthy> just think of dynamic instruction scheduling as is done in e.g. a Pentium IV. does it look at basic blocks? hell no!
05:39:31 <hyrax42> give myself precedent on skippiing, and poof I do no exercises
05:39:44 <hyrax42> will do
05:39:46 <shapr> SICP is really about 'programming' it just uses scheme as a handy vehicle.
05:39:53 <hyrax42> that much I know
05:39:56 <shapr> Wed30367: The exercises in TaPL aren't that hard, imho.
05:40:03 <hyrax42> ack, hungry
05:40:15 <shapr> But they are illuminating.
05:40:19 <pejo> Wed30367, some of the exercises are enough to publish a paper on, if it's not already done. So it should take you some time.
05:40:22 <hyrax42> some person has both (well I assume one person has both) TaPL and ATTaPL out of our library
05:40:30 <hyrax42> (hey, there's an advantage of being at school!)
05:40:47 <shapr> Yeah, I wonder if LTU has ATTaPL... hm!
05:41:07 <shapr> pejo: Hey, is Nordlander at LTU also?
05:41:16 <Wed30367> hmmm too conflicting statements about the exercises :D shapr finds them easy, pejo say it will take a long time
05:41:20 <shapr> He's one of the main Timber guys, isn't he?
05:41:39 <CosmicRay> so I am considering making a Haskell wrapper for GnuTLS.  Where can I find docs on making this I/O play nice with forkIO?
05:41:45 <Wed30367> im not really fond of proving stuff, actually i hate it....
05:41:46 <shapr> Wed30367: I didn't say they wouldn't take time, but they're not hard.
05:41:59 <pejo> shapr, Nordlander is employed by LTU. Part Luleå, part Skellefteå. He
05:42:14 <pejo> shapr, he's the senior guy in the "group".
05:42:42 <pejo> earthy, give me a few minutes to reply. Reading some.
05:42:42 <shapr> I should read up on Timber. I think it uses dependent types maybe? I know it's the O'Haskell successor...
05:42:46 * shapr googles
05:43:22 <shapr> Oooh, I want to go to the next Timber course.
05:43:26 <pejo> shapr, not that I know of. afaik you don't guarantee termination of the type checker with dpeendent types.
05:43:36 <pejo> don't = can't.
05:43:43 <Philippa_> AIUI that depends on a lot
05:44:00 <Philippa_> there're some dependantly typed systems that have a terminating checker and many that don't
05:44:00 <shapr> Yeah, doesn't Epigram have both termination and dep types?
05:44:47 <pejo> Wed30367, the exercieses in TaPL have a difficulty-indication. Atleast one of the ****-exercises had a reference in the answers-part as "Read <...> by <...>".
05:45:43 <Philippa_> shapr: Epigram doesn't have general recursion IIRC
05:45:55 <Philippa_> it doesn't have non-terminating code on any level
05:46:15 <dblhelix> Philippa_: that's right, only structural recursion
05:46:54 <pejo> Philippa, ok, point taken. I should be more careful with what I say.
05:47:59 <Philippa_> to put this in perspective, a totally-general dependantly-typed system lets you run arbitrary code during type-checking :-)
05:48:49 <pejo> Yeah, Cayenne was an experiment with dependent types. I'm personally not too fond of the idea that you might need to press ^C during compilation. :-)
05:49:32 <Philippa_> don't code in C++ then :-)
05:50:06 * shapr grins
05:50:11 <integral> or perl :-)
05:50:23 <shapr> hiya integral, how's code?
05:50:42 * ski bangs head against comonads, again
05:50:58 <shapr> Education and Co-Education?
05:51:04 * integral still isn't programming haskell
05:51:21 <pejo> earthy, ok. "Optimal Superblock Scheduling Using Enumeration" by Shobaki and Wilken. Seems to talk about global instruction scheduling.
05:51:41 <CosmicRay> integral: why not?
05:52:00 <shapr> hiya cptchaos, what's up?
05:52:32 <integral> CosmicRay: mainly I'm not familiar enough with the libraries,  but GHC is also a wee bit slow on my boxes
05:52:41 <ski> shapr : i have an idea of a kind of problem which might fit into state-in-context comonad, only i'm not sure if the problem only happens to fit, or if there's something interesting here ..
05:53:10 <shapr> ski: Tell us about it!
05:53:12 <cptchaos> hi, shapr. Last week of lectures for me.
05:53:24 <ski> shapr : it's more or less repMin ..
05:53:28 <shapr> cptchaos: And then you'll be on vacation? What are you doing for the summer?
05:54:13 <ski> shapr : i'm wondering if i can make some useful generic state-in-context operations (like get and put are ops for state monad)
05:54:32 <shapr> Sounds nifty
05:55:58 <ski> shapr : 'repMin (Leaf a)       = fmap Leaf (transform a)'   here one can read 'transform' as "magically" transform the local value to a new value (in actuality, passing it upward, and merging with 'min', pssing up to toplevel,  then passing down again ..)
05:56:28 <ski> transform :: s -> StateCM s s
05:56:39 <pejo> earthy, your comment about the instruction scheduling in the P4 - I'll take your word for that.
05:56:44 <CosmicRay> integral: ah.  what sort of boxes?
05:56:49 <shapr> That's not immediately understandable to me, I'd have to read up on repMin
05:57:13 <cptchaos> shapr: well I have to do some tests, and a practical in Physics, and finish a seminar in numeric of ODEs, actually a circuit simulation that I have written in haskell.
05:57:22 <ski> shapr : i like this transform primitive, but i'm not sure about what exact other primitives should be there (there must be more, i'm sure of)
05:57:33 <earthy> pejo: simple: how would the P4 hardware know what to take as a basic block?
05:57:38 <shapr> cptchaos: Cool, will your code be online?
05:57:49 <shapr> ski: Can you ask the comonads authors maybe?
05:57:51 <cptchaos> shapr: yes
05:58:02 <shapr> Nifty, I want to see it when it's online.
05:58:03 <cptchaos> in about a month
05:58:06 <ski> shapr : repMin replaces all elements of a tree with the minimum of the elements
05:58:12 <ski> shapr : who ?
05:58:13 <earthy> it can't really know, as it only has an instruction stream, no higher level structure to look at
05:58:14 <shapr> Oh yeah, I remember that.
05:58:24 <ski> shapr : Kieburz ?   Pardo ?
05:58:38 <shapr> I still don't understand the rest of that code though. I think it'd take me some hours of study.
05:59:02 <shapr> How does transform do that?
05:59:11 <ski> hehe
05:59:22 <ski> it just does it :)
05:59:33 <ski> or you wanna know implementation ?
05:59:43 <shapr> Yeah, I think I do :-)
05:59:47 <shapr> If the code isn't too scary.
05:59:57 <ski> no
06:00:00 <ski> data StateCM s a = MkSCM s (s -> a)
06:00:03 <pejo> earthy, ok. Trouble is to know whether anything jumps to this "statement"?
06:00:10 <ski> transform s = MkSCM s (\s -> s)
06:00:25 <earthy> something like that, yeah
06:00:49 <ski> shapr : maybe it'd be more helpful if i showed you this
06:01:07 <pejo> earthy, anyways, that just points out they didn't have much choice in the design.
06:01:33 <ski> shapr : repMinInternalLoop :: Ord a => Tree a -> (a,a -> Tree a)
06:02:30 <shapr> I still don't get it, but I'll think abou tit.
06:02:45 <shapr> My new unicycle is calling me, I'll be back later.
06:02:46 <ski> shapr : this traverses a tree, and gives a pair of the local minimum in the tree, and a function, which given the global minimum, gives back a tree of the same shape, but with all elements replaced by the global minimum
06:02:48 <pejo> earthy, hm. What are we discussing now anyways? It's obviously possible to schedule superblocks optimally.
06:02:55 <ski> shapr : this is not hard to write at all
06:03:06 <ski> (shapr : in fact, it's related to AGs :)
06:03:22 * Itkovian can't get darcs to compile on Tiger using ghc-6.4 "/usr/bin/ld: Undefined symbols: __DISCARD__"
06:03:22 <shapr> Oh that's neat, how is it related?
06:03:31 <Itkovian> make that ___DISCARD__
06:04:25 <Igloo> Itkovian: Sounds like a bug in ghc rather than darcs
06:04:37 <ski> shapr : the first a in the pair is like a synthesized attribute, the second is like an inherited attribute, and the final Tree a is like a synthesized attribute which depends on the inherited one
06:04:58 <Itkovian> Igloo: never said it was due to a bug in darcs ...
06:05:07 <Igloo> Sure, just letting you know
06:05:18 <Igloo> Can you compile other Haskell programs with it?
06:05:28 <shapr> ski: Hm, I'll think about that, thanks for the info.
06:05:46 <ski> shapr : anyway, i just remarked that '(a,a -> Tree a)' is actually 'StateCM a (Tree a)', where 'StateCM a' is a state-in-context comonad (with state type 'a')
06:06:22 <ski> so, 'Tree a' is the final answer, while 'a' is the intermediate state answer, in some way, i think
06:06:28 <shapr> That sort of makes sense to me.
06:06:34 <shapr> Yeah, I think I see that.
06:07:26 <shapr> ski: Actually, that makes a lot of sense.
06:07:33 <ski> anyway, i have a feeling i might be thinking to less "co", i.e having '... -> StateCM s ...' instead of 'StateCm s ... -> ...' :/
06:07:44 <CosmicRay> anyone here with experience using FFI for C libraries that do I/O?
06:08:08 <Igloo> What's up, CosmicRay?
06:08:22 <ski> shapr : so, 'transform' just sortof puts the input value as state, and waits for the context to transform it in some way (up at toplevel) and then pushh it down again, so we can return it
06:08:41 <shapr> ski: Seems to me that it's a bit like a reader monad in that the state is all the nodes of the tree, and you're just looking for the smallest part of the state.
06:08:41 <ski> shapr : ty
06:08:51 <CosmicRay> Igloo: pondering a Haskell wrapper for gnutls
06:09:35 * shapr thinks about that
06:09:42 <ski> shapr : hm, maybe (not getting exactly what you mean)
06:09:55 <Itkovian> Igloo: yes I can, toy stuff at least ...
06:09:58 <shapr> I'll have to read the comonads paper again. Last time I read it I understand almost nothing.
06:10:05 <shapr> understood*
06:11:02 <shapr> Too bad GHC doesn't come with a series of diagnostic tests that can tell you whether it's satisfying all the 'normal' behaviour.
06:11:21 <ski> shapr : about OI comond, i think this is unsafe *unless* you have a linear type system (like Clean) .. it's a bit unlucky that in state monad with internal linear state (like IO), the linearity doesn't "shine through" but with corresponding comonad, it does :(
06:11:38 <CosmicRay> shapr: OTOH, it does come with a great tester for the kernel oom killer :-)
06:12:12 * shapr grins
06:12:19 <ski> shapr : the unsafeness lies in that if you duplicate e.g. an 'OI ()' value, you are duplicating the world state, which is bad :/
06:12:52 <shapr> I've heard about people who live in their own little world, but I had no idea I could do it myself.
06:12:54 <ski> (or rather, the declarative reading doesn't agree with the operational workings, then)
06:14:24 <Wed30367> hey...a great idea suddenly struck me.....im going to dedicate my life to ghc
06:15:23 <cptchaos> Wed30367: Are you sure?
06:15:26 <Wed30367> hahaha
06:15:30 <Wed30367> i was joking
06:15:46 <Wed30367> i cant image ever spending my best half of life to something work related
06:15:54 <Wed30367> certainly not ghc
06:16:15 <Wed30367> i wonder if there are that kind of people though....
06:16:24 <Wed30367> that look back and only see ghc in their life :D
06:18:21 <cptchaos> Wed30367: Well last time I tried to get a rough clue on how the ghc works internally, I failed miserably.
06:19:08 <Wed30367> hehe, doesn't seem really attractive to do also
06:19:18 <Wed30367> looking in ghc's guts
06:19:45 <cptchaos> Well, after actually doing it, I won't disagree.
06:21:44 <cptchaos> But anyway. Ghc does an awesome job.
06:23:19 <Wed30367> without a doubt
06:26:13 * ski utters : vooob !
06:29:45 <Wed30367> crap, why in godsname can one only build a Data.Graph with integer vertices :S
06:30:54 <cptchaos> Wed30367: otherwise it would be too easy ;-)
06:31:30 <Wed30367> hehe obviously :)
06:38:01 <Wed30367> still crap though :P
06:38:09 <Wed30367> im a lazy programmer
06:39:29 <iwlx> Hm.
06:41:42 <wilx> Let's say I have a bunch of functions with some parameters. One of these parameters is always both (Bounded a) and (Enum a). Can I write dummy type class like class (Bounded a, Enum a) => BnE a where {} and use (BnE a) instead?
06:42:32 <dblhelix> wilx: iirc, in Haskell 98, you can't
06:42:47 <wilx> Ok, you can assume GHC with extensions.
06:42:51 * ski thinks you can
06:43:05 <dblhelix> wilx: then you can
06:43:11 <ski> (even in Haskell98 .. but i may be worng)
06:43:14 <liyang> dblhelix: ooi, why not?
06:43:17 <wilx> The thing is I tried this:
06:43:17 <wilx> foo :: (BnE a, Num a) => a -> a
06:43:17 <wilx> foo x = (maxBound::a) - (succ x)
06:43:32 <wilx> The operation is dummy, just so that I can use both at once.
06:43:39 <wilx> But I get some error.
06:43:50 <dblhelix> ski, liyang: instance decls should be of the form instance (...) => C (T a1 ... an)
06:44:05 <dblhelix> ski,liyang: where T is a tycon, not a tyvar
06:44:10 <ski> dblhelix : hm, right, i forgot about that :)
06:44:10 <liyang> *nod*
06:44:25 <dblhelix> ski,liyang: furthermore a1, ..., an need to be distinct
06:44:36 * ski focused on the no-method-detail ..
06:44:47 <Wed30367> someone has been reading vaxen :P
06:44:53 <dblhelix> wilx: what error?
06:45:20 <wilx> be.hs:4:9:
06:45:20 <wilx>     No instance for (Bounded a)
06:45:20 <wilx>       arising from use of `maxBound' at be.hs:4:9-16
06:45:20 <wilx>     Probable fix: add (Bounded a) to the expected type of an expression
06:45:20 <wilx>     In the expression: maxBound :: a
06:45:21 <wilx>     In the first argument of `(-)', namely `(maxBound :: a)'
06:45:23 <wilx>     In the definition of `foo': foo x = (maxBound :: a) - (succ x)
06:45:39 <wilx> Line 4 is foo :: etc.
06:45:51 <wilx> Err, 3.
06:45:59 <cptchaos> wilx: how did you define BnE ?
06:46:15 <wilx> class (Bounded a, Enum a) => BnE a where
06:47:02 <dblhelix> wilx: mmm, are you sure the type var a is in scope in (maxBound :: a)?
06:47:26 <wilx> Just a sec, I paste teh whole thing somewhere.
06:47:26 <ski> hm, it's not i think
06:47:39 <ski> @type \x -> (maxBound::a) - (succ x)
06:47:42 <dblhelix> wilx: I think it's not the same as the one in the type sig
06:47:45 <lambdabot> bzzt
06:47:50 <wilx> @paste
06:47:51 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:47:56 <ski> @type \x -> maxBound - succ x
06:48:21 <cptchaos> I guess that maxbound has kind *->* and will need an arguent
06:48:37 <ski> maxBound is not a type
06:48:39 <lambdabot> forall a.
06:48:39 <lambdabot>          (Num a, Bounded a, Enum a) =>
06:48:39 <lambdabot>          a -> a
06:48:46 <ski> good
06:49:12 <wilx> Ok, top of the IRC paste page.
06:49:26 <ski> wilx : try just deleting the " :: a" part after maxBound
06:49:32 <cptchaos> ski: ok the type of maybound has kind *->*
06:49:39 <ski> no
06:49:48 <wilx> @type maxBound
06:49:49 <lambdabot> forall a. (Bounded a) => a
06:49:52 <wilx> See.
06:49:56 <ski> the kind of the type of some value is always *  (barring unboxed stuff)
06:50:05 <ski> right
06:50:14 <dblhelix> wilx: what if you loose the :: a part behind maxBound?
06:50:29 <dblhelix> ski: right
06:50:34 <cptchaos> ski: right,
06:50:41 <wilx> omg, it works without it.
06:50:42 <ski> @kind forall a. (Bounded a) => a
06:50:43 <wilx> Hmm...
06:50:43 <lambdabot> *
06:50:49 <wilx> But I do not understand why.
06:51:05 <ski> because (-) ensures both it's arguments have the same type
06:51:24 <dblhelix> wilx: maxBound :: a basically says that maxBound gives you a value of type a, for any type a
06:51:41 <ski> (in class Bounded)
06:51:54 <wilx> Ah, I see, and with ::a I constrained it to just Bounded a and nothing else, right?
06:52:10 <wilx> Bah./
06:52:11 <wilx> Nope.
06:52:19 <wilx> I still do not understand :)
06:52:40 <dblhelix> wilx: well, you tries to convice the compiler that you can derive (Bounded a) for any type a, and that's just not true ;)
06:52:54 <genneth> wilx: afaik, your syntax of (function::type) is invalid
06:53:07 <wilx> It is valid afaik.
06:53:12 <dblhelix> genneth: it is valid
06:53:28 <ski> maxBound :: a0   x :: a1,   succ x :: a1   we now know (Enum a1)  maxBound - succ x :: a2  we know know (Num a2) as well as a0 = a1 = a2
06:53:28 <genneth> oh well; i'll just shut up and learn then
06:53:53 <dblhelix> @type (undefined :: a)
06:54:05 <lambdabot> forall a. a
06:54:07 <wilx> But now it complains during use that there is no instance for (BnE a)
06:54:21 <wilx> I guess this just won't work.
06:54:37 <ski> because you haven't made any instance
06:54:55 <ski> hmm
06:56:02 <ski> dblhelix : hm you were speaking of instance declarations (with head must be tycon applied to distinct tyvars), but he was just declaring a class
06:56:32 <dblhelix> ski: but I was one step ahead, now he should declare a suitable instance ;)
06:56:50 <ski> i think wilx initial class declaration is Haskell98 (compare with Ord class, e.g)
06:56:58 <ski> dblhelix : yah :)
06:57:03 <dblhelix> ski: yes, it is
06:57:26 <ski> so, a general instance is prolly not Haskell98, then
06:58:19 <dblhelix> ski: indeed
06:58:34 <liyang> Well, it's one line to define a specific instance. :)
06:59:04 <ski> (of course he can make specific instances, if that suffices / is not too ugly)
06:59:14 <cptchaos> i have read something about class synonyms here: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#undecidable-instances
06:59:32 <dblhelix> wlix: just insert instance (Bounded a, Enum a) => BnE a where
07:00:03 <cptchaos> there is an example of the think wilx tries, I think.
07:00:30 * ski thinks you can leave out the "where" in both the class and instance declarations, if you have no methods
07:01:43 <wilx> Hmm, thanks for the link.
07:01:58 <dblhelix> wilx: does it work now?
07:02:07 <Wed30367> is there no syntactical shorthand for if-then-else in haskell ?
07:02:12 <Wed30367> no ternary operator?
07:02:29 <Igloo> if/then/else /is/ a ternary operator  :-)
07:02:38 <autrijus> no ternary infix, though.
07:02:38 <Wed30367> you know what im getting at Igloo
07:02:59 <autrijus> although it wouldn't be terribly hard to define one, would it
07:03:40 <Wed30367> ..? .. : .. kind of thing?
07:03:43 <Wed30367> with two symbols?
07:03:43 <liyang> Syntactically there practically is no difference between (say) b ? x : y and if b then x else y ...
07:03:52 <liyang> (so why would you want one?)
07:03:57 <Wed30367> its shorter
07:03:58 <Wed30367> :D
07:04:02 <liyang> ...
07:04:56 <Heffalump> if you could syntactically define : and ? binary operators, you could do it
07:05:21 <autrijus> something like
07:05:24 <autrijus> c .? x = (c, x)
07:05:25 <wilx> Yup. It works when done the way the page describes.
07:05:27 <autrijus> (c, x) .: y = if c then x else y
07:05:46 <Wed30367> possible indeed
07:05:48 <Igloo> It would be cleaner to have x and y being tupled
07:05:52 <wilx> Thought it seems to me it is quite brutal way to do it. It opens door for too many bugs, imvho.
07:06:05 <wilx> I guess I will have to endure the extra typing :)
07:06:27 <autrijus> Igloo: sure. either way it's very possible
07:06:31 <liyang> -- (?) :: Bool -> a -> a -> a
07:06:31 <liyang> (b ? x) y = if b then x else y
07:06:49 <liyang> Then write (True ? 1 $ 2)
07:06:51 <Igloo> Yeah, except for the interaction with other operators
07:08:34 <dblhelix> what about:
07:08:35 <dblhelix> infix 1 <?>; infix 2 <:>
07:08:35 <dblhelix> b <?> (x, y) = if b then x else y
07:08:36 <dblhelix> (<:>) = (,)
07:08:59 <dblhelix> False <?> 4 <:> 3
07:09:03 <dblhelix> gives 3
07:10:09 * liyang figures you can just reuse $ ... :-/
07:10:22 <dblhelix> liyang: yeah I like that better
07:10:31 <dblhelix> time to get some work done, though
07:10:33 <liyang> (and just define (?), or whatever you want to call it. There's no need to tuple things up.)
07:10:54 <liyang> (if to tuple-up can indeed be considered a verb. <_<)
07:13:30 <Wed30367> hey thanks for all the suggestions btw, dont be mad i resorted to if..then..else.. anyway :P
07:14:00 <liyang> (all for a saving of 9 keystrokes.)
07:14:09 <liyang> Wed30367: good. :)
07:14:13 <autrijus> Wed30367: I don't know about others, but I kind of hoped you will go back to if/then/else :)
07:14:49 <Cale> nonidiomatic Haskell can be really strange :)
07:14:55 * liyang will make a point to use his (?) from now on. :p~~~
07:15:45 <Wed30367> hehehe
07:16:04 <Cale> http://pleac.sourceforge.net/pleac_haskell/index.html is a huge example of some rather nonidiomatic Haskell code.
07:16:30 <Cale> Well, not that huge, I suppose it's only 20% done :)
07:17:33 <ski> dang ! was just going to paste that url ..
07:17:40 <Cale> (.) o f = f o -- this is perhaps the strangest bit.
07:17:57 <ski> :)
07:18:18 <liyang> method call?
07:18:35 <Cale> yeah, it makes function application look like method calling.
07:19:19 <ski> (?) True  (a,b) = a
07:19:20 <ski> (?) False (a,b) = b
07:19:21 <ski> hehe
07:21:01 <Cale> Someone should really redo the Haskell PLEAC in something that looks more like Haskell. :)
07:22:12 <Cale> It's sort of an odd dialect there. They seemed to want to make the implementations as close as possible to the original perl.
07:23:31 <Wed30367> in general, im a fan of going all the way
07:23:36 <Wed30367> in almost any context
07:25:56 <Cale> also, the code claims things which aren't entirely correct, like it says that there are no multiline strings. While this is kind of true, you can still break strings across lines using string gaps.
07:33:38 <basti_> hi
07:37:46 <Heffalump> show foo `deepSeq` foo should fully evaluate foo assuming the Show instances are all derived, right?
07:39:13 <ski> is deepSeq :: DeepSeq b => a -> b -> a  ??
07:39:29 <basti_> @type deepSeq
07:39:34 <lambdabot> bzzt
07:39:44 <ski> @index deepSeq
07:39:45 <lambdabot> bzzt
07:39:57 <liyang> @hoogle deepSeq
07:39:59 <basti_> i'd say it has no constraints
07:40:17 <ski> really ?
07:40:20 <Heffalump> no, it does
07:40:33 * liyang -> afk
07:40:39 <basti_> so which ones?
07:40:59 <ski> some DeepSeq class, i think
07:41:22 <ski> @type seq
07:41:24 <lambdabot> forall b a. a -> b -> b
07:41:46 <ski> that's why i thought deepSeq had the forced argument first
07:42:10 <basti_> http://urchin.earth.li/icfpcontest/2004/sub/tools/shared/DeepSeq.lhs
07:44:06 * ski utters : just as i thought :)
07:44:10 <Wed30367> passing parameters which are for examples Data.Graphs will only pass around pointers i hope?
07:44:13 <basti_> so Heffalump... (show foo) `deepSeq` foo   should evaluate everything of foo that's needed for showing foo
07:44:39 <basti_> Wed30367: basically yes.
07:44:51 <Wed30367> ok, then i wont have to worry about passing large structures i guess
07:45:01 <Wed30367> from memory perspective that is
07:45:22 <basti_> not in the sense that they'd rise like yeast through uncontrolled multiplication
07:45:36 <basti_> you will, however, discover that most haskell implementations are memory hogs.
07:45:58 <Wed30367> haskell implementations of Data.Graph or implementations of any application?
07:45:59 <Wed30367> :D
07:46:34 <basti_> any application. but memory is not the bottleneck nowadays
07:46:39 <Wed30367> true
07:46:59 <Wed30367> managability may be
07:47:04 <Wed30367> or maintainability
07:47:23 <basti_> yes.
07:47:44 <basti_> which is a point for haskell
07:48:07 <Wed30367> exactly the answer i was hinting for :P
07:50:00 <basti_> oh and its O(1) overhead usually.
07:50:56 <Wed30367> speed is still an issue i think with Haskell isnt it?
07:51:21 <basti_> actually i haven't had any speed issues for years.
07:51:37 <Wed30367> sweet
07:51:43 <basti_> which is not haskells fault
07:51:56 <basti_> my UI isnt implemented in haskell, and everywhere else speed is rather optional.
07:52:22 <Igloo> WASH doesn't stop you constructing broken HTML, right?
07:52:26 * Igloo asks in the right place this time
07:53:12 <basti_> i've seen some correct html enforcing thing. I think it was wash.
07:53:27 <basti_> that is, w3c compliant
07:53:34 <Igloo> Hm, OK, ta
07:53:37 * Igloo digs deeper
07:53:46 <basti_> as opposed to "looks the same on every device" which is not the intention of HTML
07:54:03 <Igloo> standard-compliant is what I meant
07:54:07 * basti_ nods
07:54:19 <Wed30367> Wash enforces the correct html generation through those special types
07:54:31 <Wed30367> which only allows you to nest stuff within a body that makes sense
07:55:18 <Igloo> What special types?
07:55:23 <Igloo> em, em_S, em_T :: Monad m => HTMLCons x y m a
07:55:25 <Igloo> td, td_S, td_T :: Monad m => HTMLCons x y m a
07:55:35 <Wed30367> let me look them up
07:55:46 <Igloo> but td can contain block level stuff whereas em can only contain inline stuff, no?
07:55:48 <Wed30367> it was kind of phantom type kind of trick
07:56:06 <basti_> heh
07:56:17 <Igloo> (Is WashNGo-2.4.6/WASH the right place to be looking?)
07:57:01 <Wed30367> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
07:57:33 <Igloo> I got that far; that's about when I got confused  :-)
07:57:39 <Wed30367> WashHTML is probably what you want right?
07:58:57 <Igloo> Ah, WASP-HTML rather than WASH itself seems to be it. Thanks!
08:31:48 <thedward> I need to hurry up and get proficient with Haskell so I can use it for real projects, switching between Haskell and perl is driving me batty.
08:32:25 <tomdavie> heh... best way to do that is use it for a real project...
08:32:32 <tomdavie> but one that doesn't really matter much
08:32:56 <thedward> I'm almost ready for that.
08:33:20 <thedward> (un)fortunately, I have important projects that need to be working in a timely fashion.
08:33:43 <thedward> they don't care what language I use, but do have a timeline.
08:34:54 <Oejet> thedward: Cool.  Better than the other way round. ;-)
08:35:37 <thedward> indeed. "You have all the time you want, but you have to use C64 Basic"
08:35:40 <tomdavie> what? I don't care how long it takes, but you're using cobol?
08:35:49 <tomdavie> ahh... okay... maybe worse
08:36:11 <thedward> I actually really enjoyed C64 basic, but I was young and naive.
08:36:15 * skiAWAY remembers coding C64 Basic
08:36:44 <tomdavie> yeh... but I enjoyed TI basic when I was young and naÃ¯ve... doesn't mean I do now *g*
08:36:52 <thedward> my first development box was a timex sinclair. :)
08:37:03 <tomdavie> ... even though I'm still young and naÃ¯ve
08:37:20 <Gahhh> poke 53281,0
08:37:33 <skiAWAY> me first programmed on a PB-100F pocket calculator (with 510 bytes of ram for programs !)
08:37:37 <thedward> huh, this combo of irc client + terminal isn't liking non-ascii characters
08:37:46 <tomdavie> sorry
08:37:51 <thedward> 510 bytes of RAM!
08:37:54 <tomdavie> it's an i with 2 dots
08:37:54 <thedward> Luxury.
08:37:57 <tomdavie> hehe
08:38:23 <tomdavie> I think I first programed on a Macintosh Quadra 610... late start
08:38:25 <thedward> My dad tells me stories about spinning magnetic cylinder "Ram"
08:38:41 <skiAWAY> Gahhh : seen http://www.ffd2.com/fridge/jpeg/ ? :)
08:38:55 <tomdavie> heh... mine used to tell me stories about mercury tube ram
08:39:31 <thedward> heh
08:39:59 <skiAWAY> "Luxury. We used to have to get out of the lake at three o'clock in the morning, clean the lake, eat a handful of hot gravel, go to work at the mill every day for tuppence a month, come home, and Dad would beat us around the head and neck with a broken bottle, if we were LUCKY!"
08:40:12 <Gahhh> hah. I was more of an amiga d00d, tho. see http://www.back2roots.org/News/
08:40:30 * skiAWAY remembers Mental Hangover :)
08:40:35 <tomdavie> heh... that was the other story my dad used to tell me... when the pond was there not to look pretty...
08:40:40 <tomdavie> but to cool the lab computer
08:41:22 <skiAWAY> (Gahhh : was member of any group ?)
08:41:34 <thedward> my progression was timex sinclair -> c64 -> c128 -> amiga 500 -> amiga 1200 -> a long series of commodity pcs running linux
08:41:46 <thedward> then my ibook running linux that I know and love today.
08:42:21 <tomdavie> Macintosh 128k -> Quadra 610 -> Powermac 8600 -> iMac -> G4 desktop -> iBook -> Mac Mini
08:42:35 <tomdavie> out of interest... why put linux on it?
08:43:13 <thedward> I'm just so used to Linux by now, and I like having my laptop setup as close to my desktop set up as possible.
08:43:32 <tomdavie> fair enough... why spend the money on apple hardware then?
08:43:36 <thedward> MacOS X is pretty sweet, but I would spend way to much time learning how to tweak it.
08:43:45 <Gahhh> skiAWAY: I sorta was but we were very much newbies. I remember doing horizontal scrollers with the blitter, etc.
08:43:56 <tomdavie> heh... that's the point though... you don't *need* to tweak it
08:44:06 <thedward> maybe you don't ;)
08:44:22 <tomdavie> I've got several friends who now use it specifically because they want a system that just runs
08:44:39 <tomdavie> and now prefer it over their old very customised linux setups
08:44:52 <thedward> when I bought my iBook none of the other laptops that I could afford had a built in wifi antenna, amoung other things
08:45:01 <tomdavie> ah... fair enough
08:45:13 <thedward> I also do have a philosophical preference to run free software
08:45:37 <thedward> my next laptop will probably be a dell or a lenovo
08:45:51 <thedward> if I can figure out how to buy one without windos.
08:45:54 <skiAWAY> Gahhh : ok
08:46:20 <tomdavie> heh... I have a philisophical preferance that if I pay for the software in the price of the hardware then I damn well use what I payed for ;)
08:46:42 <thedward> heh
08:47:17 <basti_> soo
08:47:19 <basti_> ups
08:47:23 * skiAWAY read thedward as the dwarf, first ..
08:47:31 * genneth recomends a thinkpad
08:47:36 <thedward> Oh, and furthermore, the iBook has removable keycaps. so I could easily rearrange the keyboard to be dvorak.
08:47:53 * genneth is learning dvorak
08:48:01 <genneth> a true PITA
08:48:22 <thedward> skiAWAY: it is short for 'the Edward'; I'm just lucky that my first unix account had a 8 char limit for logins, otherwise I might be thEEdward
08:48:37 <thedward> genneth: frankly, I don't know if I would recommend it.
08:48:47 <thedward> I can't type worth shit on qwerty these days.
08:48:51 <skiAWAY> (thedward : ya, realized that after a few mins)
08:49:07 <genneth> thedward: my qwerty is still fine
08:49:12 <genneth> sorta
08:49:24 <genneth> a tendency to hit d a lot...
08:49:26 <thedward> maybe if I had practised both I'd be better off now.
08:50:25 <thedward> people always look at me funny when I help them with their computer and I am sitting there hunting and pecking. I am sure they are thinking to themselves "so this guy is supposed to be a computer expert, wtf can't he type?"
08:51:36 <thedward> there is a program out there that you can run and it'll do statistical analysis of how you actually use your keyboard, and create a key map optimized to your personal use.
08:51:50 <thedward> I decided that was a bit much, even for me.
09:05:54 <wilx> Heh.
09:06:04 <mikael> I type both Dvorak and QWERTY well enough, FWIW
09:06:19 <wilx> That must be hard when probably 90% of world's keyboards are QWERTY.
09:07:37 <thedward> it is trivial to turn on dvorak support on any vaguely modern os, but I don't like doing that when I am just using someone's computer for a couple minutes.
09:07:56 <thedward> if you aren't touch typing, there really isn't any point to dvorak, after all.
09:08:33 <Beelsebob> hmm, I bother when it's OS X, it's one menu selection to change it... but on other OSes I don't bother
09:11:08 <mikael> If I'm the only one using a computer for a good while, I'll remap it; usually, I don't bother.  As long as it's not a keyboard I'm not *used* to typing Dvorak on, though, I switch into QWERTY mode pretty easily
09:11:35 <mikael> trying to type QWERTY on my own keyboard is extremely confusing :-)
09:12:01 <Beelsebob> yeh... ditto
09:12:26 <Beelsebob> I can do dvorak on either a qwerty or a dvorak keyboard... I can't do qwerty on my dvorak keyboard
09:22:49 <shapr> @yow !
09:22:50 <lambdabot> I'm having a RELIGIOUS EXPERIENCE ... and I don't take any DRUGS
09:23:18 <liyang> Life is a drug, or something.
09:23:21 <shapr> Man I love unicycling!
09:23:36 <Beelsebob> hmm?
09:23:39 <liyang> ... and juggling laptops at the same time?
09:23:48 <shapr> Haven't tried that.
09:23:49 <Beelsebob> laptops are difficult
09:23:53 <Beelsebob> they don't fly well
09:23:59 <Beelsebob> iPods work though
09:24:21 * liyang was just wondering how shapr managed to simultaneously IRC. :)
09:25:47 <shapr> I just got back from a ride around the lake and partway up the ski slope.
09:26:08 <shapr> It's really quite challenging going up mountains where skiers go down in the winter.
09:26:22 <shapr> Unicycles aren't geared, so you end up using the same ratio for everything.
09:26:43 <Beelsebob> I think there is a geared uike now
09:26:55 <Beelsebob> but it's ludicrously expensive
09:27:09 <shapr> Yup, and it's still not much good for going up mountains.
09:27:16 <shapr> Beelsebob: How come we don't see you on #unicycling?
09:27:28 <Beelsebob> because the 12 year olds anoy me
09:27:39 <shapr> I'm not 12 :-)
09:27:47 <shapr> There are some teenagers on there though.
09:31:15 <mikael> oh, hey shapr
09:31:32 <shapr> hej mikael, wassup?
09:31:45 <shapr> Have you continued with your Haskell wm?
09:32:26 <mikael> not really, no.  I ran in to some problems with Graphics.X11 that I didn't particularly feel like solving at the time :-)
09:32:34 <shapr> Ah, too bad.
09:33:16 <mikael> and I've been effectively internet-less due to an apparently fried onboard network interface
09:33:40 <shapr> I get a lot of code done when I have no internet.
09:34:46 <mikael> I'm so used to having it that I never save API references and such :-/
09:34:55 <shapr> Oh, I keep those on my drive just in case.
09:35:07 <mikael> yeah, that's a good idea...
09:35:19 <shapr> ndm: Hey, when do you plan on a Hoogle release?
09:35:33 <shapr> ndm: You have the urge to write about Hoogle for TMR? :-)
09:35:35 <ndm> shapr: soonish
09:35:46 <ndm> i do mildly have the urge to write for TMR
09:36:05 <ndm> but not yet - have just submitted to TFP, so want to "give up" on writing for a few days at least
09:36:18 <ndm> i suppose the current hoogle is 2.0
09:36:29 <ndm> the next one will be 3.0, massively improved in every way
09:36:30 <Beelsebob> heh... aren't you the lucky one
09:36:45 <ndm> i submitted to TFP because I got rejected from Haskell Workshop
09:36:55 <Beelsebob> I finish my mini thesis next week and then go straight into writing for IFL
09:37:18 <shapr> I'd really like to have a Hoogle article for TMR, so tell me if you get the urge.
09:37:21 <ndm> i finished my qualifying disertation a few weeks ago, and have a Colin+Detlef meeting about it 8:15 AM on thursday
09:37:24 <ndm> i have the urge
09:37:27 <shapr> I'm interested in reading about unification based searching.
09:37:39 <ndm> i will do something soonish
09:37:50 <shapr> Ok, tell me when you want a user account.
09:38:02 <ndm> shapr: its all been covered by Runciman and Rittri
09:38:22 <ndm> way back in the 80's - i just update with a pretty UI and workable on a modern functional langauge
09:38:42 <ndm> i'll write it up in plain text first
09:38:48 <shapr> Cool, I look forward to it.
09:39:07 <ndm> bob: what are you submitting to IFL?
09:39:27 <Beelsebob> neil: something about testing and delta debugging haskell
09:39:41 <Beelsebob> ... combining what I talked about on Hat day with quickcheck
09:39:47 <ndm> have you got an implementation going yet?>
09:40:03 <Beelsebob> no... I've got too much writing to actually code anything :(
09:40:08 <shapr> Aww
09:40:16 <ndm> (and are you going to have the cool slide fades at IFL)
09:40:17 <shapr> I can help you with quickcheck if you need it, but it's pretty simple.
09:40:26 <Beelsebob> of course I am
09:40:30 <Beelsebob> *g*
09:40:54 <Beelsebob> I think I've got the jist of it... but I'll come pester you if it turns nassty
09:40:59 <shapr> awright
09:41:17 <ndm> Colin has a paper on QuickCheck + Hat, which I'm guessing you've read
09:41:28 <shapr> I wish I could get up the motivation to add IO monad support to QuickCheckM.
09:41:44 <Beelsebob> niel: yeh
09:41:55 <Beelsebob> quickcheck is kinda an after thought...
09:42:10 <Beelsebob> kinda gives you the correct cases and incorrect cases automatically
09:42:38 <Beelsebob> so rather than quickcheck saying "this test failed" it should be able to say "this failed, and the bug is here"
09:42:44 <shapr> How can you do that?
09:43:15 <Beelsebob> hehe... you'll have to wait till I finish the paper won't you ;)
09:43:23 <shapr> bah, ok :-P
09:43:48 <ndm> Beelsebob, does that mean you're going to Ireland, and not Estonia?
09:43:49 <Beelsebob> basically comparing good and bad executions
09:43:58 <shapr> What do you compare, code paths?
09:44:02 * shapr thinks
09:44:14 <Beelsebob> neil: What's in estonia? TFP?
09:44:15 <shapr> It sounds like partition testing somewhat...
09:44:19 <shapr> ICFP
09:44:22 <ndm> TFP+ICFP+Haskell Workshop
09:44:29 <ndm> me and Tom are off to all 3
09:44:47 <Beelsebob> you jammy gits
09:45:02 <ndm> we have both submitted to TFP
09:45:15 <Beelsebob> fair enough
09:45:16 <ndm> but yeah, was surprised i was allowed to all of them
09:45:26 <shapr> Beelsebob: I'm just a self-employed programmer.
09:45:27 <Beelsebob> yeh, I'm going to IFL by the looks yof it
09:45:44 <Beelsebob> shapr: fair enough... shame
09:45:54 <Beelsebob> would be cool to have a couple of unicyclists there
09:46:04 <Beelsebob> DAMN IT! There's a fly *in* my monitor
09:46:24 <Beelsebob> it's somehow got between the LCD and the backlight
09:46:25 <ndm> shapr: for TMR, does HTML/Txt or what suit you best?
09:46:38 <ndm> beelsebob: yours, or your one at uni
09:46:44 <Beelsebob> mine
09:47:03 <shapr> TMR is wikipublishing, so you use the MoinMoin formatting. It's pretty simple though.
09:47:23 <Beelsebob> it seems to have got scared by me chasing it with a cursor
09:47:24 <shapr> The great advantages of wikipublishing is that you get a feedback from the other authors while you put in new content.
09:47:40 <shapr> Beelsebob: That's totally quotable
09:47:53 <Beelsebob> heh
09:48:11 <Beelsebob> ARGH! There's two now
09:48:20 <Beelsebob> has some fly made a nest in there or something?
09:48:50 <Beelsebob> I may have to take this monitor apart
09:50:06 <shapr> Another great advantage of wikipublishing is that the editor is never the bottleneck, authors' content is immediately and always available to readers if the authors so wish.
09:50:09 * Beelsebob wonders why axel hasn''t phoned
09:50:25 <shapr> He doesn't love you anymore, get over it.
09:50:36 <shapr> He's mine now!
09:50:42 <shapr> Um... anyway.
09:50:44 <Beelsebob> heh... I was meant to be taking some of Olaf's stuff to him in hospital
09:50:46 <Spark> queers!
09:50:46 <Beelsebob> but hey
09:50:59 <shapr> Axel Simon?
09:51:01 <Beelsebob> yeh
09:51:07 <shapr> Why's he in the hospital?
09:51:12 <Beelsebob> he isn't... Olaf is
09:51:19 <ndm> why is Olaf?
09:51:19 <shapr> um... ok
09:51:29 <Beelsebob> gaul stones they think
09:51:37 <shapr> "gall"
09:51:43 <Beelsebob> someting like that
09:51:46 <shapr> Gaul Stones is funny, but something completely different.
09:51:50 <Beelsebob> haha... french stones
09:51:54 <Spark> shapr: (re wikipublishing) isnt that a benefit of the internet rather than the wiki bit, and its a hazard as well since theres less quality control
09:52:11 <shapr> Beelsebob: Yeh, maybe means he eats too much greasy French food? :-)
09:52:33 <Beelsebob> heh... I doubt it... he's German
09:52:39 <shapr> Spark: Well, no.. with wikipublishing all the other authors are QC
09:52:43 <ndm> i'll have to check with my supervisor before i start on a TMR issue, in case he wants it publishing academically or soemthing
09:52:44 <shapr> Yeah, I know. I met him at ICFP2003.
09:52:51 <shapr> ndm: fair enough.
09:53:03 <shapr> TMR may become academic publishing at some point.
09:53:13 <shapr> That'll be weird... I don't even have a four year degree.
09:53:35 <Beelsebob> heh... I don't think anyone cares as long as you did something clever
09:53:37 <ndm> yeah, that would be interesting - half way between full academic and just on the web
09:53:39 <shapr> That's true.
09:53:41 * basti_ has more than four years but no degree.
09:53:42 <Spark> shapr: so you get something akin to a beta preview :)
09:53:54 <shapr> Spark: Yeah, which has turned up lots of stuff for me.
09:54:14 <shapr> I would have finished my arrows intro quickly, but all the feedback I got showed me I really needed to write something else.
09:54:23 <Spark> i wonder whether it would be better if academic papers were published like freshmeat
09:54:33 <Spark> and there were votes and stuff for them
09:54:35 * Beelsebob doesn't have a four year degree... but I do have a 3 year one
09:54:42 <shapr> It would be cool. I do wish I got more feedback for TMR though.
09:54:45 <Beelsebob> spark: they do... they vote in citations
09:54:52 <shapr> I really don't know what people like and what they don't like.
09:54:54 <shapr> y0 SyntaxNinja
09:55:00 <Spark> Beelsebob: heh like page rank
09:55:02 <ndm> does anyone use WinHugs with a preprocessor?
09:55:32 <shapr> I'd really like to hear ideas for TMR improvement.
09:56:12 <metaperl_> shapr: asciidoc!
09:56:16 <SyntaxNinja> 'morning
09:56:18 <shapr> What about kwid?
09:56:36 <shapr> ingy: Hey, is there a kwid processor in Haskell?
09:56:36 <metaperl_> shapr: does it produce PDF and HTML and plain text as well as asciidoc?
09:56:48 <metaperl_> kwid is completely off the mark for me
09:56:53 <shapr> I dunno, but it does produce those.
09:57:03 <metaperl_> pure pod I would prefer over kwid
09:57:18 <metaperl_> kwid does head1, head2 by ^= ^==
09:57:32 <metaperl_> shapr: i dont think there is a pdf generator for pod
09:58:28 <shapr> y0 KrispyKringle
09:58:31 <shapr> wazzup?
09:58:32 <metaperl_> latex is actually fine for producing HTML and PDF... but plain text is bad... you dont want people to have to strain to learn a new formatting system just to publish
09:58:45 <shapr> LaTeX is a new formatting system for me.
09:58:52 <shapr> And so far, it's caused lots of problems.
09:59:04 <metaperl_> i mean plain text prduction from latex is bad... oh really? latex is the researcher's standard
09:59:06 <KrispyKringle> hey, shapr
09:59:09 <shapr> Oleg suggested using lhs2TeX for TMR, that sounds like a good halfway point.
09:59:12 <metaperl_> I used it for both of my MS theses
09:59:16 <KrispyKringle> long time, no see. We're debating typesetting languages?
09:59:28 <metaperl_> KrispyKringle: for the monad reader
09:59:31 <shapr> metaperl_: Yeah, but I'm a self-employed programmer with no formal education.
09:59:37 <KrispyKringle> ah
09:59:48 <KrispyKringle> My personal favorite is Lout, but it's fringe. ;)
10:00:03 <metaperl_> shapr: how about creating TheMonadReader.Org, with mailing list subscriptions, rss feeds and more... all written in Haskell
10:00:11 <KrispyKringle> hehe
10:00:16 <shapr> metaperl_: That sounds really cool actually.
10:00:24 <Oejet> metaperl_: You must be from the US; they like having many titles. ;-)
10:00:28 <metaperl_> with a "view source" link on each page to show the haskell
10:00:38 <shapr> That would rock =)
10:00:38 <metaperl_> Oejet: titles? I am from US, yes
10:01:17 <KrispyKringle> So you want some markup that can be easily rendered in these different formats?
10:01:25 <metaperl_> I come home and dont study haskell. However, I will be riding public transit everyday soon. 1.5 hour bus ride to/from work. So I will have my laptop computer and do at least 30mins of haskell a day
10:01:40 <KrispyKringle> I mean, XSLT seems th easiest to do. Can one of the Haskell XML libraries do it?
10:01:47 <Oejet> I meant titles.  Like three master degrees, two phds, four bachelors...
10:02:15 <metaperl_> Oejet: oh I see what you mean... heheh
10:02:30 <metaperl_> yes, titles are everything here
10:02:44 <metaperl_> do you have vanity plates in denmark?
10:02:49 <shapr> What master's degrees do you have?
10:03:01 <metaperl_> M.S Computer Science, M.S. Computational Neuroscience
10:03:09 <metaperl_> Lehigh and Southern Cal, respectively
10:03:34 <metaperl_> http://metaperl.com/resume/perlresume.html
10:03:44 <shapr> Computational Neuroscience?? whoa!
10:03:46 <Oejet> metaperl_: And you have to have them from good universities too. ;-)
10:03:51 * metaperl_ loves having a domain for each of his activities
10:03:56 <metaperl_> Oejet: oh yes!
10:04:05 <metaperl_> it's not what you know, it's how you look!
10:04:13 <shapr> Hey! I had this idea for a high-speed spherical neural network bit of hardware.
10:04:20 <metaperl_> hardware?
10:04:36 <metaperl_> maybe burn to hardware compiled from software
10:04:51 <metaperl_> now why a spherical geometry?
10:04:55 <Oejet> metaperl_: What is a vanity plate?
10:05:02 <metaperl_> Oejet: I knew you would ask... lol
10:05:39 <jlouis> =c 4
10:05:40 <Beelsebob> oejet: a board you put on your desk with "Dr John Smith PhD MA MSc MEng BSc BCS IEEE" written on it
10:05:44 <metaperl_> Oejet: in the United States, the cars all have license places.. normally people take a standard number on the back of the plate. But in US-California, people pay extra money to spell out words with their license plate. This is known as a vanity plate
10:05:53 <metaperl_> Oejet: no it isn't. Beelsebob is wrong
10:05:56 <shapr> Yeah, I was thinking about how to build hardware neural nets, and my idea was a sphere with a ball for each neuron, and a facet for each other neuron.
10:06:02 <Beelsebob> oh... okay... different meaning here
10:06:19 <metaperl_> shapr: oh , interested in connectivity issues
10:06:31 <shapr> I think that an LCD layer over the facets would be an easy way to adjust the weights.
10:06:34 <shapr> metaperl_: right, exactly.
10:07:02 <Oejet> metaperl_: We do have those; I've seen one alot which the letters "DR NO".
10:07:11 <Oejet> *a lot
10:07:13 <metaperl_> shapr: so you want to build neurally inspired computer hardware. Carver Mead at caltech has done quite a bit of that with semiconductors
10:07:44 <metaperl_> Oejet: yes, people here love to spell things out... MYBENZ for "my mercedes benz"
10:07:49 <metaperl_> TUFFGUY
10:07:50 <metaperl_> SHEJUMPS
10:08:06 <metaperl_> LLJ <3 YYX
10:08:10 <metaperl_> (llj loves yyx)
10:08:14 <Oejet> Our plates cost $1000. :-P
10:08:35 <shapr> metaperl_: Has anyone tried using josephson junctions for neural nets?
10:08:36 <metaperl_> oh god no. just maybe 40.00
10:09:12 <Oejet> And a phd costs $3000?
10:09:14 <metaperl_> shapr: I dont know. I was a biological neuroscientist. I worked on a _single_ neuron for 3 years. I was working on networks within a neuron
10:09:24 <shapr> Oh that's interesting.
10:09:53 <Oejet> metaperl_: How did you keep the neuron alive for so long?
10:09:58 <metaperl_> a single visual cell has 10,000 inputs. I studied how various degrees of periodicity and synchronization of those inputs would affect output
10:10:18 <metaperl_> Oejet: I did computer simulations of biological data... no "wet" lab work
10:10:19 <KrispyKringle> metaperl_: Did you name it?
10:10:26 <metaperl_> KrispyKringle: name?
10:10:29 <KrispyKringle> Oh. Dissapointing. I was hoping you kept it as a pet.
10:10:32 <KrispyKringle> metaperl_: The neuron.
10:10:32 <metaperl_> lol
10:10:34 <KrispyKringle> "Bob."
10:10:51 <KrispyKringle> "Ned The Neuron."
10:10:51 <Beelsebob> yes?
10:10:53 <KrispyKringle> Something lik that.
10:11:41 <cptchaos> Beelsebob:  nice nick
10:11:59 <metaperl_> "Pyramidal Neuron as 2-Layer Neural Network. Neuron, 37, 989-999" - http://www-lnc.usc.edu/library/Poirazi_etal03b.pdf
10:13:34 <basti_> a neuron thats simulated by neurons?
10:14:01 <metaperl_> basti_: a single biological neuron with the computational capacity of 2 layers of traditiional artificial neurons
10:14:22 <basti_> is there any explanation why this model would make sense?
10:14:30 <metaperl_> a single neuron has voltage compartments
10:14:45 <basti_> hmm
10:15:02 <metaperl_> basti_: it is biologically accurate neuron. with firing ability everywhere instead of just at the cell body
10:15:17 <metaperl_> artificial neurons take inputs and only fire at one integration point - the cell body
10:15:25 <metaperl_> real neurons can fire everywhere
10:15:29 <basti_> i see.
10:15:39 <metaperl_> in the dendrites.. and there are 1000s of dendrites
10:16:44 <Beelsebob> hmm... I should drag my sister into this discussion
10:16:53 <Beelsebob> she might be able to explain to me what's going on
10:17:09 <basti_> did anyone ever try to match a simulated and a natural neuron?
10:17:20 <shapr> metaperl_: That's quite nifty.
10:17:34 <shapr> That would explain a lot of troubling neuron behaviour I've read about.
10:17:42 <basti_> ?
10:18:26 <metaperl_> shapr: one important thing in real neurons is synaptic turnover
10:19:07 <metaperl_> shapr: once synaptic turnover was proven (by turrigiano and others) the idea of neurons storing long-term memory in synapses was gone...
10:19:42 <shapr> Huh, I'm surprised that distance from the soma didn't matter.
10:19:42 <basti_> its long known that proteins form some part of long term memroy.
10:20:09 <metaperl_> I'm not long-term potentiation is the term they use
10:27:42 <mwc> there are diff't geometries of neurons too, some have all dendrites, etc.
10:28:06 <basti_> neuroscience is interesting but NN as silver bullets is not.
10:29:15 <shapr> Yeah, but there aren't any silver bullets.
10:29:45 <basti_> yes
10:30:01 <shapr> Oboy, x.org is in sid, time to upgrade! bbl!
10:30:20 <basti_> most computer scientists "into" NN go like "hey lets just simulate neurons and we get AI"
10:38:29 <Oejet> The only silver bullets are the ones you load into your Java shot gun and shoot yourself in the foot with.
10:40:29 <vegai> I hear that's bad
10:42:49 <Oejet> vegai: Nah, only when you think it was a rare random accident and reaim at your other foot.
10:43:47 * Oejet needs to translate the typing monkey song into English some time.
10:51:29 <Oejet> Bon jour, Skal.
10:55:24 * basti_ now xorg
11:07:56 <SyntaxNinja> QOTD: "We shouldn't teach recursion, I have never found a practical use for it."
11:08:39 <wilx> Heh.
11:10:32 <KrispyKringle> Who said that?
11:13:09 <lament> haha
11:13:49 <lament> kinda similar to my favouritest quote ever
11:13:53 <lament> "I know COBOL doesn't have the glamour of Java or Visual Basic or web programming, but who says that the students are in any position to know what's good for them?"
11:14:12 <SyntaxNinja> it's anonymous ;)
11:14:23 <lament> he must have been afraid of assassination
11:14:25 <SyntaxNinja> lament: wow
11:15:13 * basti_ is chatting in a transparent window now
11:16:29 <mikael> is this transparency due to the X server of X.org finding its way into Debian?
11:16:38 <basti_> yes.
11:16:42 <mikael> :-)
11:16:50 <basti_> switched it off again already.
11:17:00 <mikael> haha
11:17:02 <basti_> =)
11:17:16 <mikael> I've noticed that xcompmgr is very, very flaky
11:17:46 <thedward> was it a straightforward upgrade?
11:17:52 <basti_> and it slows down virtual desktop switches
11:17:55 <basti_> pretty much so yes
11:18:45 <mikael> the upgrade doesn't even install any new packages.  just a plain new version of x-window-system and friends :-)
11:20:19 <tuomov> hmm.. X unstability to be expected
11:20:44 <mikael> how so?
11:20:53 <tuomov> I already tried Xorg before it got into debian for working screen rotation (only new feature worth anything in it), and it hang constantly when switching vts
11:22:15 <basti_> screen rotation?
11:22:26 <mikael> oh, that sucks.  exempting xcompmgr silliness, Xorg has been apparently stable for me
11:22:32 <tuomov> tilting tfts, you know
11:22:38 <basti_> ah
11:22:40 <basti_> yes.
11:23:37 <mikael> heh, udev depends on a kernel >= 2.6.12, but that can't be statically determined by apt, so it broke the upgrade half-way through
11:24:32 <tuomov> hmm.. and when I tried to udev/whatever stuff a bit over a year ago, it took a minute at boot time...
11:24:39 <tuomov> s/to/the/
11:24:52 <tuomov> and it seemed like nobody was even interested in fixing that at that time
11:25:21 <mikael> rebooting is for weenies anyway, right? :-P
11:25:38 <tuomov> well, given a hanging X...
11:53:32 <shapr> CosmicRay: Are you using the nvidia binary drivers with xorg?
11:57:27 <mikael> hm, that doesn't sound good :-)
11:58:52 <mikael> by the way, a friend told me that the open source ``nv'' driver is just as good (or better) than the proprietary drivers -- unless one wants 3D acceleration.  if you don't, you might want to try it
11:59:01 <tuomov> or tv-out
11:59:21 <tuomov> and I want both
11:59:38 <shapr> I want 3D accel.
11:59:53 <shapr> I'd rather have open source 3D accel though, any news on that totally open card?
11:59:56 <mikael> I want both, too :-/
12:00:30 <tuomov> I could live with out 3d if there just was working tv-out
12:00:43 <tuomov> and does the nv driver support dvi either?
12:00:55 <tuomov> at least matrox I think requires the proprietary driver for dvi
12:02:27 <shapr> What's the name of that open 3D card project?
12:02:58 <shapr> I know the company that was doing it was TechSource.
12:03:53 <shapr> Aha, http://lists.duskglow.com/mailman/listinfo/open-graphics
12:26:39 <Number17> Hi, I'm trying to learn haskell.  I'm trying to think of a somewhat neat project, just for the purpose of learning the language, that would play into haskell's strengths, however I can't think of one now.  Any ideas?
12:27:42 <xerox> What do you miss in your everyday work?
12:29:00 <Number17> Well, I can't think of anything.  Any programming in my work is just parsing log files and stuff
12:29:14 <shapr> Aha, parsing!
12:29:23 <shapr> Haskell is really good at parsing.
12:29:25 <xerox> @google Parsec haskell
12:29:27 <lambdabot> http://www.cs.uu.nl/~daan/parsec.html
12:30:03 <Number17> well, not even really doing anything that complicated that would require a recursive decent parser; just split it by endlines, and splitting the lines by delmiters
12:30:31 <xerox> If it's simply manageable, it's just probably better :)
12:30:33 <shapr> Well, it would get you writing some code.
12:30:34 <Akshaal> Number17: you are happy one :)
12:30:40 <Number17> I am :)
12:31:19 <Number17> I was unhappy ~8 years ago when I had to do all this parsing, and the only way I knew how to do it was with the left right and mid functions in vb :\
12:31:36 <shapr> yow!
12:31:48 <Akshaal> ö)
12:31:52 <Akshaal> :)
12:31:59 <shapr> Scary thing is, I did that too in the mid 90s. I did parsing with left right and mid in VB.
12:32:39 <liyang> Number17: that sounds like a perfect beginner's project. :)
12:33:32 <liyang> re: parsing -- /me ditto. He was so happy when he first came across Perl.
12:37:23 <Number17> I really wish I knew all I do now then; I had to parse some reasonably complicated stuff, and it took days to figure the things out
12:37:43 <Number17> I also wish I didn't start with VB as my first programming language.  It damaged my mind I think :\
12:38:42 <bpalmer> could be worse, you could have been parsing in prolog :p
12:38:44 <Spark> i started with bbc basic and my mind is perfectly sound
12:38:59 <xerox> Hiya bpalmer, didn't see you hang here too :)
12:39:06 <liyang> I think it's the `V' bit that affected his.
12:39:14 <Spark> i moved on to vb though
12:39:20 <Number17> liyang:  exactly
12:39:28 <liyang> (who didn't? :-/)
12:39:34 <Spark> bbc basic is worse than vb
12:40:16 <bpalmer> xerox: occasionally. Only a dabbler in haskell so far
12:40:30 <Number17> I wonder how haskell will turn out for simple parsing things vs python
12:41:09 <xerox> Try :)
12:41:17 * Number17 starts
12:42:04 <mikael> I recall a very easy-to-use regular expression library (with a Perl-like =~ operator, even), and Parsec is -really- good for languages beyond the regular ones
12:53:42 <Philippa_> Parsec's not too bad for the regular languages either, it's just wordier than regexes
12:58:41 <Speck> Can someone explain the notation used in the bananas, lenses, envelopes, barbed wire paper?
13:00:02 <Speck> In the catamorphism section they have something like:  b <- B and (+) <- A||B -> B, then h <- A* -> B
13:00:18 <Speck> I understand what catamorphisms are, but the <- part and the || part confuse me.
13:00:39 <Speck> What would those three things look like in more haskell-like notation?
13:01:04 <Speck> (note that I am using <- the way list comprehensions use <-)
13:02:02 <xerox> What is it? :)
13:02:22 <Speck> "exists in" ?
13:02:49 <Speck> but it seems to be more analagous to :: in Haskell
13:02:50 <xerox> No, what you are reading at all :)
13:03:04 <Speck> the bananas paper? http://citeseer.ist.psu.edu/cache/papers/cs/10165/http:zSzzSzwww.cs.uu.nlzSz~erikzSzPublicationszSzfpca91.pdf/meijer91functional.pdf
13:03:27 <Speck> page 3
13:06:31 <xerox> What is the "*" ?
13:06:57 <shrimpx> A-star search!
13:07:13 <Speck> A* means a list of A
13:07:18 <Speck> I beleive, in that paper
13:10:14 <smott> yeah looks like the \elem symbol is just "has type"
13:10:47 <Speck> what about the ||?
13:10:50 <Speck> tuple?
13:11:17 * liyang always wondered what if, instead of being called regular expressions, they were called Kleene expressions.
13:11:36 <mauke> hahaha
13:12:00 <xerox> heh.
13:12:26 <smott> Speck: seems like |a,b| == foldr a b
13:12:29 <xerox> Does anybody know the meaning of |- in logic?
13:12:44 <Philippa_> liyang: then unix tools'd use Dirty expressions
13:13:01 <Speck> smott, I mean the || in the part where it says:  (+) \elem A||B -> B
13:13:17 <Speck> banana brackets I (mostly) understand
13:13:31 <liyang> The turnstile ( |- ) usually means syntatically implies...
13:13:45 <smott> xerox: tautology? (ie a or not a)
13:13:51 <ibid> smott: no
13:13:56 <xerox> |= is tautology on this book
13:13:59 <ibid> liyang is correct
13:14:04 <liyang> Philippa_: that's another level up on the in-joke scale. XD
13:14:11 <ibid> |= is usually semantic entailment
13:14:12 <xerox> Syntactically implication? OK.
13:14:22 <xerox> -y
13:14:33 <ibid> not implication
13:14:37 <ibid> that's inside the lagnuage
13:14:46 <ibid> syntactic entailment
13:14:50 <xerox> Implication in the metalanguage?
13:15:06 <ibid> yes, but we don't call that implication :)
13:15:18 <liyang> Philippa_: wow, you're at Nottingham?
13:15:22 <xerox> Uhm
13:15:31 <Philippa_> liyang: yeah, what's wow about that?
13:15:36 <xerox> I don't know the meaning of some words :(
13:15:54 <xerox> turnstyle, entailment, .. ?
13:16:07 <liyang> Philippa_: I'm hopefully starting a PhD with the FoP group in January. :)
13:16:09 <Philippa_> I mean yeah, there're a few cool folks here, I should try actually chatting to Conor sometime...
13:16:19 <Philippa_> ah, cool. I'll have to talk you into buying me a drink then :-)
13:16:25 <Philippa_> what've they got planned for you?
13:16:26 <liyang> <_<
13:16:28 <liyang> >_>
13:16:45 <liyang> That doesn't work out fairly for me. I'm allergic to alcohol. >.<;;
13:16:51 <liyang> ;)
13:17:14 <Philippa_> well, normally the plan is to get the other person drunk while not being so drunk yourself that you forget the purpose of doing so ;-)
13:17:19 <xerox> ibid: do you have any enlightening urls?
13:17:24 <liyang> Abstractions for concurrency, e.g. transactional memory.
13:17:30 <Heffalump> liyang: what are you doing at the moment?
13:17:32 <ibid> xerox: turnstile is the name of the symbol |-
13:17:37 <Philippa_> ooh, fun
13:17:48 <ibid> xerox: read logic books :)
13:17:50 <xerox> ibid: (about the whole topic, maybe)
13:18:01 <ibid> xerox: what's the whole topic?
13:18:10 <Philippa_> at the moment I'm still a threads-and-Chans kinda girl, but any improvement on that's good
13:18:23 <xerox> ibid: propositional logic
13:18:38 <ibid> xerox: there are lots of good books
13:18:53 <liyang> Heffalump: MSc in Advanced Computing at ic.ac.uk... :)
13:19:05 <ibid> xerox: specific recommendations depend on what level you want to get to :)
13:19:10 <xerox> I'm not aiming in a complete understanding of the whole topic, I was reading a book between "disclosure" and "epistemiologic"
13:19:15 <Heffalump> ah, cool.
13:19:29 <Heffalump> My gf went there (Physics, though)
13:19:43 <liyang> Heffalump: your name sounds familiar... ^_^;
13:19:51 <ibid> xerox: also, my msc thesis and a lecture note booklet i've written cover that subject ;)
13:19:58 <Heffalump> liyang: scary :-) why?
13:20:03 <Heffalump> oh, MAG?
13:20:10 <ibid> xerox: but they are not intended for introductory use
13:20:18 <liyang> Heffalump: er... you've lost me.
13:20:21 <xerox> ibid: I think something more introductionary / divulgative is better.
13:20:37 <Heffalump> never mind. Just a guess - I vaguely remember someone at IC being interested in some stuff I did for my PhD
13:20:41 <ibid> xerox: basically, any university-level introduction to logic will do
13:20:56 <xerox> ibid: do you know of anything freely available online?
13:22:04 <liyang> Heffalump: ah, it'll be the ComLab pages then, I'd bet. :)
13:22:14 <ibid> (xerox, fyi, my 24 hour netpass will expire within the hour)
13:22:44 <xerox> ibid: what does it mean?
13:23:17 <Heffalump> liyang: as in the Oxford ones?
13:23:48 <ibid> xerox: that i will drop off the net without warning within the hour
13:24:10 <ibid> xerox: since my irc is in a screen session, there will be no quit message, so you can't tell it from there
13:24:55 <xerox> You're in good company, I'm in a similar situation, UMTS phone, not that good connection, but fast enough for this vacation place without a phone line :)
13:25:33 <ibid> i'm sitting in a hotel room with excellent but expensive wireless
13:25:36 <xerox> By the way, any pointers to introductionary online documents?
13:25:42 <liyang> Heffalump: *nod* Either that or earth.li; I know a couple of earthlings either via the Belfast LUG or Cambridge. :D
13:25:47 <ibid> i bought a 24-hour access to it about 24 hours ago
13:25:48 <xerox> This UMTS connection is rather expensive too :(
13:25:52 <Heffalump> ah :-)
13:26:03 * liyang -> afk
13:26:03 <ibid> xerox: i'm  looking
13:26:05 <liyang> later :)
13:26:15 <xerox> But it's the best I could get here - and I _needed_ it :-\
13:26:20 <Heffalump> small world strikes again..
13:27:39 <ibid> xerox: i'm at debconf, btw :)
13:28:00 <xerox> Ah, I saw a pic of you guys :)
13:31:59 <ibid> xerox: oh, what's your background on logic?
13:33:24 <xerox> @type (&&)
13:33:25 <xerox> :)
13:33:34 <lambdabot> Bool -> Bool -> Bool
13:33:57 <ibid> xerox: i mean, truth tables?
13:34:26 <xerox> Sure
13:34:35 <ibid> ok
13:34:45 <ibid> (i'm running out of time)
13:35:22 <xerox> :| Thanks for the effort
13:35:43 <ibid> i'm still trying
13:35:54 <ibid> ask again tomorrow if i disappear
13:36:03 <ibid> (finnish local time, now is 2337(
13:36:30 <xerox> OK :-)
13:41:57 <Akshaal> how to get last_insert_id with HSQL?
13:43:39 <xerox> Byebye ibid ;)
13:44:13 <ibid> hm?
13:45:28 <ibid> http://cs.wwc.edu/~aabyan/Logic/Book/book/ looks promising
13:45:35 <xerox> Ah, you're still here, thanks much.
13:45:39 <ibid> haven't had time to look at it in detail
13:46:57 <xerox> Oh, great.
13:47:31 <Igloo> Hmm, anyone got any idea what's going on here?
13:47:31 <Igloo>     Overlapping instance declarations:
13:47:31 <Igloo>       HTMLT.hs:17: MonadHTML e (HTMLT e m) (HTMLT e' m)
13:47:31 <Igloo>       HTMLT.hs:27: MonadHTML e (t m1) (t m2)
13:47:41 <Igloo> I have -fallow-overlapping-instances -fallow-undecidable-instances on
13:48:05 <Igloo> Oh, n/m, I see it
13:48:13 <basti_> :)
13:48:15 <basti_> i know this
13:48:21 <xerox> @ghc
13:48:22 <lambdabot>  A lazy (~) pattern connot bind existential type variables
13:48:23 <basti_> asking a question and then suddenly seeing the answer
13:48:27 <xerox> And this? :P
13:48:36 <basti_> hmm
13:48:37 <xerox> Oh, misunderstood, eheh
13:48:41 <basti_> :)
13:48:41 <shapr> @ghc
13:48:42 <lambdabot>  Can't represent Oxford brackets
13:48:46 <basti_> lol
13:48:47 <shapr> What are those?
13:48:47 <xerox> Who can!
13:49:05 <Igloo> basti_: I only see the problem, not the answer, unfortunately  :-)
13:49:13 <basti_> whats oxford brackets?
13:49:19 <basti_> Igloo: thats bad, then.
13:51:48 <Igloo> Bah. Is there an obvious way that I'm missing to write an HTML transformer monad that checks only valid HTML can be constructed?
13:52:04 <Heffalump> 'transformer monad'?
13:52:17 <xerox> C-t <g>
13:52:28 <shapr> Igloo: Why not do it the way HaXml does it?
13:53:11 <lament> @ghc
13:53:13 <lambdabot>  Use -fcontext-stack20 to increase stack size to (e.g.) 20
13:53:23 <shapr> HaXml generates ADTs from a DTD, so only valid tags structures can be created.
13:53:31 <Igloo> Like StateT
13:53:33 <Igloo> Hang on a tick
13:53:52 <shapr> HXmlToolbox uses a generic tree structure, and does regexes validation in a separate step.
13:54:29 <Heffalump> you want a monad transformer that checks for valid HTML? I'm confused.
13:54:46 <Heffalump> where will it see the HTML at all?
13:55:26 <Philippa_> nonono, an "HTML transformer monad" - cf "state transformer"
13:55:27 <shapr> If the HTML is passing through a monadic call, you could use the HXmlToolbox approach.
13:55:44 <shapr> Philippa_: explain?
13:55:45 <Igloo> darcs get urchin:/ian/bts and look at HTMLT.hs and the bottom of Foo.hs for some use of it
13:55:57 <Igloo> s#/#~#
13:55:59 <Philippa_> AIUI, you'd wire the HTML through the monad, monadic operations affect it etc etc
13:56:09 <Philippa_> sorta Writer-on-crack
13:56:18 <Philippa_> unless I'm talking shite, Igloo?
13:56:56 <Igloo> I think you're right, Philippa_. The monad transformer itself just wraps StateT
13:57:17 * Heffalump gets bitten by darcs' broken ~ expansion again
13:57:22 <Philippa_> 'k. Was just checking I'd got the concept right from the three words I read :-)
13:57:41 <shapr> Nothing here? -> http://urchin.earth.li/~ian/bts
13:57:41 <Igloo> Oh, it's at http://urchin.earth.li/darcs/ian/bts/ if that's easier, or if anyone else wants to look
13:57:46 <Heffalump> ok, and you want a static guarantee?
13:57:53 <Igloo> Yes
13:58:17 <Igloo> I want lots of "instance CanContain BODY P" type things, and appropriate constraints
13:58:25 <Heffalump> ignoring the monad transformer, do you have a statically correct constructoin interface for HTML?
13:58:44 <Heffalump> if you do, then you can just embed the interface in the monad operations. If not, how can you hope to make this work?
13:58:46 <Igloo> I could make one easily enough
13:59:20 <Heffalump> if you can never construct XHTML_1_1_HTML without it being correct, what's the problem?
13:59:26 <Igloo> The problem is basically the instance on line 49 of HTMLT
13:59:51 <Igloo> The HTMLT monad itself will have to be parameterised by the element type it is constructing children for
14:00:05 <Igloo> so the transformers above me need to be able to change their types accordingly
14:00:23 <Heffalump> ah, right.
14:00:42 <Heffalump> no, I still don't see.
14:01:07 <Heffalump> if you have lift operations, what's the problem with the overall stack just having the element type in the HTMLT part of the stack?
14:02:11 <Heffalump> and why does that instance have Monad (t m) in the constraint rather than Monad m?
14:02:23 <Heffalump> doesn't MonadTrans t, Monad m => Monad (t m) anyway?
14:02:35 <Heffalump> oh, and MonadHTML m so Monad m
14:05:28 <Igloo> OK, let me think about this. If we just had a normal monad then we'd have mk_tag :: "p" -> HTMLT "p" a -> HTMLT "html" a
14:05:46 <Heffalump> have you taken to using dependent types?
14:06:07 * Heffalump doesn't understand that type at all
14:06:09 <Igloo> Refering to my use of strings as types or something else?
14:06:14 <Heffalump> strings as types
14:06:18 <Igloo> I forgot I was writing a type
14:06:27 <Heffalump> ok, so you mean something representing the "p" level in the tree.
14:06:35 <Heffalump> and you are assuming "html" comes directly above it.
14:06:35 <Igloo> mk_tag :: TagName -> HTMLT P a -> HTMLT HTML a
14:06:46 <Igloo> Yeah, just thinking about a particular use
14:06:57 <Heffalump> what is the meaning of 'HTMLT P a' ?
14:07:09 <Heffalump> a computation producing an a that also contains a P somehow?
14:07:42 <Igloo> Function in an HTMLT monad that produces an HTML -> HTML function in its state that applies to the body of a P tag
14:08:09 <Heffalump> sorry??
14:08:18 <Heffalump> "IO a" is a computation producing an "a"
14:08:43 <Igloo> And doing stuff in RealWorld#
14:08:46 <Heffalump> StateT Foo a is a computation that, given an initial value for Foo, produces an a and a final value for Foo
14:09:03 <Heffalump> ok, I think I see.
14:09:19 <Heffalump> HTMLT a b is always HTML -> (HTML,b)
14:09:28 <Igloo> Yup
14:09:31 <Heffalump> but it is somehow restricted to only operate under whatever tag 'a' is.
14:09:44 <Igloo> Right, by contraints on functions like p
14:10:21 <Heffalump> how do you impose them?
14:10:33 <Igloo> OK, so I also need  mk_tag :: TagName -> StateT St (HTMLT P m) a -> StateT St (HTMLT HTML m) a, say
14:10:40 <xerox> ibid: http://people.debian.org/~aigarius/debconf5_group.jpg
14:11:39 <Igloo> It'll be something like (MonadHTML p1 m1, MonadHTML p2 m2, Contains p1 p2) => m1 a -> m2 a I think
14:11:47 <Heffalump> I'm still lost as to how you impose the constraints.
14:11:49 <Igloo> where p is the parent element type
14:11:53 <Heffalump> just by type hiding?
14:12:01 <Igloo> "hiding"?
14:12:18 <Igloo> Oh, I don't mean that at all, do I
14:12:20 <Heffalump> not exposing 'newtype HTMLT e m a = HTMLT (StateT St m a)
14:12:23 <Heffalump> to clients
14:12:32 * Heffalump looks for people he knows in the debconf photo.
14:12:44 <Heffalump> (apart from Noodles :-)
14:12:49 <Igloo> (MonadHTML p1 m1, MonadHTML P m2, Contains p1 P) => m1 a -> m2 a
14:13:05 <Igloo> Right, yes
14:13:45 <Heffalump> errm, allowing the contained monad to change seems odd
14:14:24 <Igloo> It's only changing in a phantom type. But allowing that's basically the problem I have...
14:15:09 <Heffalump> m1 and m2 aren't phantom types, are they?
14:15:12 <Philippa_> you only need to do that when using the results of a computation to build more HTML, right?
14:15:28 <Heffalump> your code doesn't have two parameters for MonadHTML
14:15:59 <Igloo> Hmm, no. So that type's too general for p.
14:16:23 <Igloo> No, that's because I found out I couldn't make it work half way through so reverted to something that works in case you wanted to prod it  :-)
14:16:47 <Igloo> Philippa_: Right, but that's what p does (makes a <p> tag)
14:17:06 <Heffalump> what is the intended effect of mk_tag?
14:18:16 <Igloo> mk_tag "p" f runs f in a fresh state, takes the children left in the state, makes a p tag from them and then puts the p tag in the state you started off with
14:18:28 <Philippa_> think I'm too braindead/overheating right now. Which is bad, it should be cooler by now...
14:19:57 <Heffalump> so bits of HTML just sort of exist in a state?
14:20:10 <Heffalump> is the state in HTMLT P a really a [P] ?
14:20:29 <Heffalump> or did you not mean children above?
14:21:32 <Igloo> The state in HTMLT P a is a list of things that can be child tags of a p tag (actually a function of type HTML -> HTML that adds the children to an empty p tag, as what I actually said won't typecheck)
14:22:49 <Igloo> So the state after running f above might be effectively (\(Tag "p" []) -> Tag "p" [Tag "p" [Text "foo", Text "Bar"]])
14:23:08 <Heffalump> how does it know which empty p tag to add them to?
14:23:29 <Igloo> mk_tag makes an empty tag and applies them itself
14:24:24 <Heffalump> sorry|?
14:25:50 <Igloo> I'm not sure where you're lost?
14:28:31 <Heffalump> where does mk_tag make the empty tag?
14:28:47 <Heffalump> you said that the state is actually a function of type HTML -> HTML that adds the children to an empty p tag.
14:28:52 <Igloo> Line 23
14:29:12 <Igloo> Right
14:29:25 <Igloo> The state read by trans' <- get_trans
14:30:04 <Heffalump> what happens if I pass this HTML -> HTML function something like "<html> </html>"?
14:30:29 <Igloo> Eh? For which argument?
14:30:40 <Igloo> Oh, I see
14:30:58 <Igloo> It doesn't work on strings
14:31:11 <Igloo> data HTML = Tag WhiteSpace TagName [HTML]
14:31:14 <Heffalump> well, something like that. Or does your well-formedness guarantee stop me doing that?
14:31:26 <Igloo> So that would be roughly Tag _ "html" []
14:32:00 <Igloo> Passint that to it it what I am trying to stop happening
14:32:43 <Heffalump> ok, what about if it gets passed some HTML with two empty P tags? Or is that also to be stopped?
14:33:01 <Heffalump> i.e. will it always be passed some standard skeleton that has just one P tag in it?
14:33:21 <Igloo> It applies it on line ~23: add_child (trans' $ Tag ws t [])
14:33:46 <Igloo> There's no way it can be applied to a non-empty tag, the [] of children is sitting right there
14:33:48 <Heffalump> oh, hangon, HTML isn't a full document, right.
14:34:15 <Igloo> Hmm, I wonder if I should call it Fragment
14:34:22 <Heffalump> why would what you said above not typecheck?
14:34:44 <Heffalump> If all the things that can be child tags of P are just Fragments, then why is there a typechecking problem?
14:34:50 <Heffalump> the monad state can just be [Fragment]
14:34:57 <Igloo> It would type check, which is why I want phantom types to stop it doing so   :-)
14:35:15 <Heffalump> I'm still lost as to your high-level motivation.
14:35:44 <Igloo> OK, what you have (if it was complete) is an HTML monad transformer with which you can make valid or invalid HTML
14:35:52 <Igloo> I want one just like it, but that won't let you create invalid HTML
14:36:17 <Heffalump> how do you get the HTML out at the end?
14:36:36 <Igloo> runHTMLT :: Monad m => HTMLT XHTML_1_1_HTML m () -> m HTML
14:39:05 <Heffalump> is the only well-formedness property you want to impose that only certain tags can be children of certain other tags?
14:39:39 <Igloo> Yes
14:41:37 <Heffalump> and you want mk_tag to be the means by which this is imposed.
14:41:46 <Igloo> Not necessarily
14:41:57 <Heffalump> ok, but that's your current plan.
14:42:03 * Heffalump finally understands the phantom type.
14:42:37 <Heffalump> why don't you have an explicitly structured datatype, OOI?
14:42:46 <Igloo> Where?
14:42:57 <Heffalump> data HTML = HTML HEAD BODY
14:43:00 <Heffalump> data HEAD = ...
14:44:45 <Igloo> Hmm. It would mean some things would be larger (like htmlToString) and you wouldn't be able to allow some unsafe commands that might be useful
14:44:58 <Igloo> It might be simpler, though
15:00:55 <Igloo> Bah
15:00:59 <Igloo>     Overlapping instance declarations:
15:00:59 <Igloo>       HTMLT.hs:52: MonadCast (HTMLT e1 m1) (HTMLT e2 m2)
15:00:59 <Igloo>       HTMLT.hs:55: MonadCast m m
15:01:11 <Igloo> And that one I really don't get
15:02:00 <Igloo> Unless overlapping instances just aren't allow on MPTCs
15:08:29 <Heffalump> I'm fairly sure they are.
15:08:50 <Heffalump> but those are obviously overlapping. Do you have -fallow... ?
15:09:25 <Igloo> Yes
15:09:31 <Igloo> Ah, 6.4 might allow it
15:15:33 <Igloo> Doh, but it won't work anyway
15:18:12 <Igloo> Right, that's it, Haskell sucks. I'm going to become a Java programmer.
15:20:23 <SyntaxNinja> Igloo: you'll be rich
15:22:58 * Igloo gets an e-mail frmo Peter Thiemann saying I can copy all the instances just as I give up on getting them working. Pah  :-)
15:23:34 <Igloo> SyntaxNinja: Well, I was hoping for a "Please don't go, we couldn't cope without you!", but I guess cash is a good second best  :-)
15:26:07 <SyntaxNinja> Igloo: we could cope, but it would be ugly.
15:28:38 <Igloo> Hmm, I think I can do it safely with an unsafeCoerce#, actually
15:29:28 <SyntaxNinja> safeCoerce = igloo . unsafeCoerce
15:29:30 <Igloo> Hmm, maybe not
15:29:45 <SyntaxNinja> safeCoerce = not . igloo . unsafeCoerce
15:29:48 <Igloo> :-)
15:30:01 <SyntaxNinja> safeCoerce :: Maybe Not
16:05:09 <jlouis> Igloo: a former haskell programmer in Java would be two things: An awfully good Java programmer and a masochist.
16:17:25 <lispy> jlouis: or very frustrated
16:20:03 <jlouis> lispy: that is the masochist part
16:20:48 <lament> much unlike a former java programmer doing haskell
16:21:00 <lament> who would be a pretty bad haskell programmer, but still a masochist.
16:21:49 <jlouis> It goes: ''Why can't I write imperative statements? Why can't I assign? What the heck is a Monad? ARRRRRGH!''
16:22:06 <jlouis> The monad is the real sadist here
16:23:13 * Igloo wonders what his chances of finding someone to maintain ghc6 backports to stable are
16:27:45 <Heffalump> do you need a maintainer, or somewhere to build them?
16:28:43 <Igloo> A maintainer
16:38:41 <liyang> 
16:50:28 <SyntaxNinja> Igloo: you could just annouce that you'll stop supporting them and someone might volunteer ;)
16:52:44 <gzl> yeah, using java can be pretty annoying at times after haskell
16:52:49 * shapr agrees
16:53:31 <gzl> the kinds of crap people come up to simulate higher order functions is unreal
16:53:34 <gzl> * up with
16:53:41 <stepcut> shapr: did you see this already http://www.tlb.org/eunicycle.html
16:53:45 <shapr> stepcut: Yeah, it's cool.
16:54:00 <shapr> gzl: Yeah, sometimes they get called "Design Patterns"
16:54:03 <stepcut> too bad it costs so much to make :-
16:54:04 <stepcut> /
16:54:30 <jlouis> ''Design patterns'' -- bow in awe
16:54:59 <shapr> Template Method is simply higher order parameter functions like 'sortBy'. Strategy is just map/fold/etc. State is obvious, Observer doesn't really apply. Memento is obvious, Iterator is fmap. Interpreter is obvious. Command is just like Strategy. Chain of Responsibility is function composition.
16:55:17 <jlouis> This thing takes a lot of time to explain and is known as a factory. It has type: a -> Maybe b
16:55:21 <shapr> I had the urge to write a TMR article on "Design Pattern in Haskell"
16:55:38 <Pseudonym> On the other hands, monad transformers, implicit parameters and some of the grosser unsafePerformIO hacks are just an uglier form of global state.
16:55:44 <Pseudonym> You win some, you lose some.
16:55:55 <gzl> shapr: yeah, I know :)
16:55:56 * Pseudonym removes tongue from cheek
16:55:57 <shapr> Since I have the design patterns book as my mousepad, it would be fun to show how to do each pattern in Haskell.
16:56:25 <gzl> some design patterns are ok, but transformers and stuff are just annoying
16:56:30 <shapr> As for Structural Patterns, Adapter is worker wrapper, Bridge is typeclasses, Composite I don't know, List monad? Decorator could be function composition or higher order functions, Facade is worker wrapper and accumulators. Flyweight is obvious, Proxy is also worker wrapper.
16:56:44 <gzl> it's just a method wrapped in a class so you can pass it around as an argument
16:57:18 <jlouis> I do not know half those patterns, but I am sure I use them all the time in Haskell
16:57:35 <Pseudonym> Flyweight is MemoisingCafs
16:57:43 <Pseudonym> I don't think it's _that_ obvious.
16:57:59 <Pseudonym> Maybe in retrospect.
16:58:05 <Spark> programmers get a bit gungho with the design patterns
16:58:18 <Spark> they tend to implement them in inappropriate places, just to show that they know what they are
16:58:19 <shapr> For Creational Patterns, Singleton is too easy, Prototype either doesn't apply or is records. Not sure about Factor, Abstract Factory or Builder.
16:58:21 <Pseudonym> Some programmers don't understand what design patterns are.
16:58:42 <shapr> Pseudonym: MemoisingCafs covers several patterns.
16:58:46 * Pseudonym nods
16:59:09 <shapr> Like Prototype, why make instance copies when you can just use the original?
16:59:13 <Pseudonym> Which brings me to my main point: The design patterns which make sense in Haskell are different to those that make sense in Smalltalk.
16:59:27 <Pseudonym> See also CommonHaskellIdioms
16:59:36 <shapr> I wonder if you could compare Factory to your average datatype constructor.
16:59:57 <Pseudonym> I deliberately compared Factory to smart constructors.
17:00:01 <Pseudonym> @wiki FactoryFunction
17:00:01 <lambdabot> http://www.haskell.org/hawiki/FactoryFunction
17:00:18 <shapr> Anyway, would be a fun short TMR article to write up Design Pattern comparisons and see what the readers think.
17:00:39 <Pseudonym> To be fair, you should also mention some Haskell design patterns for things which are trivial in an OO language.
17:00:46 <shapr> Like what?
17:01:00 <shapr> autrijus pointed out that 'real' visitor is hard in Haskell.
17:01:05 <Pseudonym> The zipper, for example.
17:01:19 <dons> 'real' visitor is hard?
17:01:27 <Pseudonym> That's right, because "visitor" is generic fold.
17:01:29 <Spark> what is the zipper?
17:01:33 <Pseudonym> @wiki TheZipper
17:01:34 <lambdabot> http://www.haskell.org/hawiki/TheZipper
17:01:50 * Beelsebob pokes shapr in the #unicycling
17:01:55 <shapr> autrijus describes the Visitor pattern as gmap.
17:01:55 <Pseudonym> TyingTheKnot is another example of something that's more trivial in an imperative language.
17:02:07 <dons> yeah, gmap is what I would have said too
17:02:20 <SyntaxNinja> there's a paper by Gerald Baumgartner about how Design Patterns are there to fix bad language design.
17:02:46 <shapr> grr, stoopid emacs
17:03:12 * shapr sighs
17:03:15 <Pseudonym> Does gmap also do reduction?
17:03:28 <shapr> Beelsebob: I just upgraded emacs, now it refuses to deal with unicode.
17:03:29 <Pseudonym> Like can you gmap a binary tree and end up with its maximum depth?
17:03:36 <Beelsebob> :/
17:03:38 <gzl> well, the one I find most annoying is Transformer
17:03:41 <Pseudonym> (I'd think of that as a fold rather than a map.)
17:03:43 <gzl> because I have to use that constantly
17:03:51 <Beelsebob> I see... so this was an upgrade in what way?
17:04:03 <shapr> In a bad way, I guess.
17:04:08 <Speck> Pseudonym, that does sound like a cata
17:04:24 <Pseudonym> cata, fold... same difference.
17:04:37 <Speck> I know, but I was illustrating why it sounded like one
17:04:41 <Pseudonym> Right.
17:05:10 <shapr> Beelsebob: I think it's the utf-8 in the #unicycling topic that's causing problems, can you change the topic?
17:05:43 <Beelsebob> How do you change the topic?
17:05:48 <shapr> use /topic foo
17:06:11 <Beelsebob> try now
17:06:14 <Pseudonym> But you should tell lambdabot to do it.
17:06:20 <Pseudonym> @topic-cons Foo
17:06:23 <lambdabot> I do not know the channel Foo
17:06:25 <Pseudonym> Hmm.
17:06:30 <Pseudonym> @topic-cons #haskell Foo
17:06:31 --- topic: set to '["Foo","logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueFour","ICFP Contest! http://icfpc.plt-scheme.org/"]' by lambdabot
17:06:36 <Pseudonym> @topic-tail
17:06:37 <lambdabot> I do not know the channel
17:06:40 <Pseudonym> @topic-tail #haskell
17:06:40 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueFour","ICFP Contest! http://icfpc.plt-scheme.org/"]' by lambdabot
17:06:45 * Pseudonym keeps forgetting that
17:07:00 <Pseudonym> There's also topic-snoc and topic-init.
17:07:54 <shapr> As for Analysis Patterns, I'd like to actually implement all those in Haskell.
17:08:00 <shapr> I think that would be a great teaching resource.
17:10:06 <jlouis> Shouldn't we just make lambdabot take the current channel if no channel is given?
17:10:11 <jlouis> i'll make the hack
17:10:14 <shapr> Go for it.
17:10:39 <gord> Does anybody know of a transactional database implemented in Haskell (kinda like Mnesia for Erlang)?
17:10:56 <shapr> Mnesia is distributed as well.
17:11:05 <gord> Ooh!
17:11:25 <shapr> I wonder if you could use STM for the transactional bit?
17:11:34 <shapr> At a minimum you could use Oleg's zipper of continuations.
17:11:44 <gord> I very much want something like STM with persistence grafted on.
17:11:53 <gord> Zipper of continuations?
17:12:01 <jlouis> tomorrow. It is too late here. Then I'll attack it.
17:12:09 <shapr> Lemme see if I can find the url.
17:12:12 <jlouis> Zipper of continuations is a mind-bender ;)
17:12:18 <shapr> I think it's elegant.
17:12:34 <Speck> I think a persister for ADTs would be a good foundation for a database, then a DSL for querying, but I dunno about the transactional/distributed bit
17:12:43 <gord> @google oleg zipper of continuations
17:12:45 <lambdabot> http://okmij.org/ftp/Computation/Continuations.html
17:12:47 <shapr> Is NewBinary derivable yet?
17:13:30 <shapr> Er hey.
17:13:35 <shapr> SerTH is derivable
17:14:30 <shapr> gord: http://www.cs.helsinki.fi/u/ekarttun/SerTH/
17:14:57 <shapr> Speck: SerTH is a good start for persistable ADTs
17:15:09 <shapr> SerTH is by musasabi
17:15:27 <shapr> He also did the Join-Hs article for TMR, you may be able to use that to get the distributed part of Mnesia
17:15:30 <Speck> there's a whole lot of research on transforming adts, and a good paper on catamorphisms-as-queries
17:25:53 <Igloo> Waah. "foo: internal error: stg_ap_pp_ret". GHC hates me tonight.
17:26:56 <dons> oh it doesn' hate you Igloo, it's just grumpy in general
17:27:27 <gord> shapr: What issue is the Join-HS article in?
17:27:34 <shapr> Issue Three I think.
17:28:34 <Igloo> Oh, actually it's some problem with the Makefile I can't reproduce, I think
17:29:08 <dons> a problem with a Makefile broke the rts?
17:29:40 <SyntaxNinja> heh
17:29:53 <Igloo> It rebuilt HTMLT but not Foo, then linked and did the above. Then make again built Foo (or failed to)
18:06:23 <marcot> Hello, I'm having a problem trying to use c2hs 0.13.6 with ghc 6.4.
18:06:32 <marcot> I'm running the script as I always run it:
18:07:54 <mwc> marcot: I'm having a problem with c2hs and ghc 6.4 myself
18:08:21 <mwc> c2hs can't parse stdio.h on OS X apparently
18:08:41 <marcot> ghc -I. --make -O2 -Wall -lc2hs `c2hs-config --cflags` gpc.o new_form.o Main.hs
18:08:46 <marcot> mwc: hum...
18:08:54 <marcot> mwc: So you're at least running it.
18:09:00 <marcot> I can't run it with ghc 6.4
18:09:05 <marcot> Are you using 0.13.6?
18:10:55 <marcot> It sais:]
18:11:04 <marcot> ghc-6.4: unknown package: c2hs
18:12:58 <mwc> hmm, I'm betting that it's actually a problem with this new 'improved' lexer/parser that gtk2hs is using
18:13:35 <marcot> hum..
18:13:45 <marcot> mwc: anyway, are you using c2hs with ghc 6.4?
18:13:49 <Igloo> marcot's problem is that c2hs isn't installed for your ghc 6.4
18:14:11 <marcot> Igloo: it's installed for what?
18:14:20 <marcot> pre-6.4?
18:14:28 <marcot> That was the conf file:
18:14:30 <Igloo> I don't know. Possibly nothing.
18:14:38 <marcot> c2hs.conf.pre-6.4
18:14:42 <marcot> Igloo: ??
18:14:46 <marcot> Igloo: it's installed.
18:14:56 <Igloo> Well it's not registered with ghc
18:15:08 <marcot> Igloo: must I register it?
18:15:25 <marcot> Igloo: in the other versions make install was enough.
18:15:36 <Igloo> I would have thought make install was enough
18:16:21 <Igloo> But ghc is saying it doesn't know about the package
18:16:52 <marcot> Igloo: it should know because of the -package-conf /usr/lib/c2hs-0.13.6/ghc6/c2hs.conf
18:17:00 <marcot> marcot@tonhao:~/gpc-haskell$ c2hs-config --cflags
18:17:00 <marcot> -package-conf /usr/lib/c2hs-0.13.6/ghc6/c2hs.conf -package c2hs
18:20:53 <Igloo> Not sure then. You could see if ghc-pkg thinks it exists with those options
18:37:46 <marcot> I think it's a problem with the c2hs.conf file.
18:37:53 <marcot> tonhao:~# ghc-pkg register /usr/lib/c2hs-0.13.6/ghc6/c2hs.conf
18:37:53 <marcot> Reading package info from "/usr/lib/c2hs-0.13.6/ghc6/c2hs.conf" ghc-pkg: Line 1: Invalid syntax (no colon after field name)
18:38:06 <marcot> With the other file distributed I got:
18:39:07 <marcot> ah!!!
18:39:11 <marcot> E não é que com o cabal rolou?
18:48:56 <marcot> Ok, now c2hs is "working".
18:49:02 <marcot> But I get this strange error:
18:49:14 <marcot> GPCHaskell.chs:91:8: parse error on input `import'
18:50:35 <marcot> Will it be a c2hs problem?
18:53:50 <Igloo> What's there?
18:53:58 <Igloo> I'd guess a foreign import?
18:54:11 <Igloo> You might just need to give ghc -fffi
18:57:07 <marcot> hum..
18:57:09 <marcot> nice point.
18:58:27 <marcot> EEEEE!!!!!!
18:58:32 <marcot> Igloo: thank you!
19:05:09 <Igloo> np  :-)
19:36:13 <Spark> does anyone have a copy of erlang the movie
19:36:17 <Spark> it doesnt seem to be available
19:37:14 <Gahhh> geez
19:37:41 <Gahhh> hmm I still have some of the sicp videos
19:37:56 <Spark> erlang erlang erlang
20:12:19 <mwc> Wow
20:12:26 <mwc> Anybody watching the Daily Show?
20:12:37 <mwc> This author could pass for Stewarts' father
20:38:56 <Nioate_> which author
20:40:11 <mwc> Some author he had on tonight
20:41:09 <Gahhh> gahI missed it
20:43:05 <Nioate_> it's on again in 1:15 in this timezone
20:44:53 <Nioate_> that would be 1.25 hours
20:45:12 <Gahhh> yeah I'm going to record
20:45:28 <Gahhh> did you see him on crossfire ?
20:45:36 <Nioate_> yes
20:46:10 <Gahhh> well that made me buy the book heh
21:28:53 <Lemmih> Evening, SyntaxNinja.
21:43:43 <Gahhh> I just ordered Types & Programming Languages. You are welcome, amazon.com.
21:45:03 <gzl> haha
21:45:05 <gzl> that's a good book
21:46:01 <gzl> it's kind of funny, since most of the people I know who have heard about that book are in this channel
21:49:36 <Pseudonym> I know a few people on LtU who aren't in this channel.
21:49:40 <Pseudonym> But yeah.
21:49:41 <Gahhh> lol
21:50:01 <Gahhh> Is Ehud Lamm on ? heh
21:50:24 <gzl> Pseudonym: LtU?
21:51:14 <Gahhh> http://lambda-the-ultimate.org/
21:51:31 <gzl> oh, that
21:51:41 <gzl> is that worth reading? last time I looked I didn't find too much of interest
21:51:47 <gzl> but I probably didn't look that carefully
21:51:52 <Gahhh> I check it daily
21:52:11 <Gahhh> There have been some really interesting threads
21:52:23 <gzl> ok
21:52:31 <Gahhh> I try to stay away from static vs dynamic kinda topics, tho
21:52:50 <Pseudonym> Yeah, unless you like eating tinned worms.
21:52:55 <gzl> do those end up being something like "static!" "no, dynamic!" "no, static!"?
21:53:11 <Gahhh> I found this in the archives today, which rocks imho: http://lambda-the-ultimate.org/classic/message2629.html
21:55:50 <Pseudonym> Actually, they tend to be "static!" "no, dynamic!" "no, it depends!" "Ehud: Will you guys stop please?"
21:59:05 <gzl> hahaha
21:59:10 <gzl> this Malbolge post is funny
22:07:28 <Speck> I didn't think anyone on LtU was dynamic.
22:17:03 <Pseudonym> There are a few schemers.
22:25:31 <Speck> Still, it must be hard to be a dynamic guy when 99% of all the discussions are about types.
22:30:20 <Pseudonym> A lot are about semantics in general.
22:30:34 <Pseudonym> But yeah.
22:32:18 <SyntaxNinja> hi Lemmih
22:35:22 <ski> good morning #haskell
22:37:16 <ski> shapr : ping
22:39:18 <SyntaxNinja> hi ski
22:39:28 <ski> hiya SyntaxNinja
22:39:38 <SyntaxNinja> how's it going?
22:40:24 <ski> QuotesPage more or less inspired me with an idea related to monads :)
22:40:59 * ski 's referring to the duel between Igloo and shapr
22:43:35 <pejo> Gahhh, interesting piece of reading about the AMD FPU, I must say.
22:56:41 <SyntaxNinja> making releases is so tedious.
23:09:05 <Gahhh> pejo: Yeah. And this was about the time of the FDIV bug (1996?) The fact that they uncovered bugs must have made it well worth the money
23:11:09 <ibid> xerox: i have a copy of it on my server :)
23:38:27 <SyntaxNinja> Lemmih: care to give a new cabal release-candidate a try? http://www.haskell.org/cabal/download.html
23:39:11 <dons> hehe, lennart says: The offside rule is patronizing. :)
23:39:26 <dblhelix> dons: just read it :)
23:39:51 <dons> i've got a collection of lennart quotes floating around somewhere.
23:40:39 <dblhelix> this one seems like a nice addition
23:40:55 <dons> @remember lennart The offside rule is patronizing.
23:41:40 <Pseudonym> @quote
23:41:41 <lambdabot> Heffalump says: CPP leads to suffering
23:41:58 <dblhelix> for completeness' sake: lennart was only confirming the findings of the op
23:42:27 <dons> it should probably be typeset as: The offside rule *is*  patronizing. :)
23:44:20 <pejo> dons, "Lennart"?
23:45:01 <SyntaxNinja> frederik is the op
23:45:44 <ibid> pejo: everybody knows lennart :)
23:45:45 <dons> @google Lennart Augustsson
23:45:46 <lambdabot> http://www.cs.chalmers.se/~augustss/
23:47:04 <dons> in particular, co-inventor of compiled graph reduction (is that fair to say?)
23:47:10 <pejo> ibid, sure, but it's a pretty common name. What are the odds that you'd pick a Swede? ;)
23:48:00 <Lemmih> SyntaxNinja: Sure.
23:48:16 * SyntaxNinja met Lennart!
23:48:28 <dons> also developed Lazy ML, aka Haskell-before-there-was-Haskell
23:48:36 * dons also met Lennart!
23:48:47 <dons> he happens to also be a NetBSD kernel hacker
23:48:59 <pejo> dons, and Cayenne, hbc, hbcc, USB framework in netbsd, u.s.w.
23:49:11 <dons> yeah, USB.
23:49:17 <dons> same stuff is in OpenBSD.
23:49:20 <ibid> pejo: linus is also a pretty common name, but i suspect you know immediately who i'm referring to :)
23:50:08 <dons> oh, and apparently won the obfuscated C contest 3 times. (!)
23:50:17 <dons> so that's lennart then.
23:50:23 <pejo> dons, I'm not sure that's something to be proud of. ;)
23:51:32 * SyntaxNinja sends out pre-release annoucement to libraries mailing list.
23:52:43 <dons> the announcement where SyntaxNinja begs not to have to do releases anymore :}
23:53:51 <pejo> dons, oh, thats easy. Just call it "work in progress", tell people that it'll be ready "real soon now" and if they try to rush you claim that you can't force progress in research!
23:53:52 <SyntaxNinja> I was just about to mention that here
23:53:53 <dons> it usually takes me a day to prepare an hs-plugins or Yi release. is Cabal esp. tricky?
23:54:19 <SyntaxNinja> dons: by a day do you mean 8 hours?
23:54:24 <dons> yeah :)
23:54:30 <SyntaxNinja> it's apparently not as tricky as those :)
23:54:38 <dons> oh. ok.
23:54:48 <SyntaxNinja> well, maybe it's taken me 8 hours over the course of a few weeks
23:54:56 <dons> I like to check and test and test and test ;)
23:55:00 <SyntaxNinja> but there are some tricky bits wrt bootstrapping and old versinos of cabal already installed, and a bug in ghc
23:55:09 <dons> blargh :/
23:55:30 <SyntaxNinja> in particular, if you're not careful, you can get into a state where ghc won't even start!
23:55:41 <dons> hmm. doubleplus ungood
23:56:08 <SyntaxNinja> yeah. this happens if a package depends on cabal-1.0, then a new version of cabal is installed, hiding 1.0.
23:56:22 <SyntaxNinja> but the package that depends on cabal-1.0 is not "hidden"
23:56:34 <dons> oh right.
23:56:51 <SyntaxNinja> so it tries to load it, it gets pissed off that there are two cabals (I think) and won't run ghc or ghci anymore. simon has fixed this for versions > 6.4
23:57:08 <SyntaxNinja> that took me some time, so if you count that as part of the release process, then yeah, cabal is kinda tricky.
23:57:29 <dons> yeah, there's a lot of interactions to check
23:57:44 <dons> pretty good that it only takes you 8 hours :)
23:57:54 <dons> maybe you need to release less often..
23:58:02 <SyntaxNinja> I see it this way: It's easy for anyone to pick up and manage cabal releases, but only a few people can easily alter the cabal codebase, and I'm one of those ppl, so...
23:58:07 <SyntaxNinja> less often? heh
23:58:14 <SyntaxNinja> haven't released since march or so
23:58:31 <dons> maybe not quite less-often-debian-style, but every 6 months perhaps.
23:58:50 <dons> ok. so that's 6 months approx.
23:59:15 <SyntaxNinja> here's what I said on the release announcement if anyone is wondering: BTW, if anyone loves to manage releases and would like to relieve me of this duty so I can spend my time fixing bugs and adding features, just let me know ;)
23:59:50 * dons wonders if anyonne loves to manage releases
23:59:54 <ozone> SyntaxNinja: mmm, i'm sure all the ladiez will be climbing over each other to get to you!
23:59:54 <SyntaxNinja> yeah. I actually want to do them more frequently.  maybe if I could get the test suite working better, and better automation of releases that would help. I added some automation this time.
