00:15:42 <r2d4> Hi! When I used to use interpreted languages earlier, I would edit in the editor and just hit a key to run them. For example F5 in SciTE. Hugs seems different from that. Isn't there such a workflow available for Haskell?
00:17:15 <mflux_> I think you can make any decent editor to do that with a single keystroke, such as emacs
00:18:00 <r2d4> Any tips for SciTE? Unless you don't think it is descent :-).
00:18:37 <dons> can you run shell scripts from SciTE?
00:18:38 <r2d4> I did find a properties file for SciTE while searching. It did not quite do what I expected.
00:18:42 <r2d4> yes.
00:19:04 <r2d4> Is there a command line to invoke the interpreter?
00:19:13 <dons> hugs file.hs
00:19:20 <dons> and varients on that
00:19:36 <dons> maybe you'd like to try ghci, while we're here?
00:21:40 <r2d4> I tried hugs like you say. Does not work like other interpreters I know. Maybe I should poke around more. I will give GHCi a shot too.
00:21:56 <dons> what's the problem?
00:22:23 <dons> M> f
00:22:23 <dons> "hello"
00:22:44 <r2d4> it drops me at the interactive prompt.
00:23:16 <dons> oh, you want to run some functoin automatically?
00:23:31 <r2d4> yes. like a script for example.
00:23:43 <dons> easy peasy...
00:24:01 <dons> pill19$ echo f | hugs t.hs
00:24:06 <dons> M> "hello"
00:24:06 <dons> M> [Leaving Hugs]
00:24:12 <dons> to run ''f'
00:24:16 <dons> maybe you want to run 'main'
00:24:44 <r2d4> running main from command prompt would solve my issue.
00:25:02 <dons> echo main | hugs foo.hs
00:25:32 <r2d4> great. that's what I wanted. thanks.
00:25:49 <dons> now, there's also a flag to turn off all that verbose messaging
00:26:12 <r2d4> ok. will check.
00:27:00 <r2d4> BTW, any editor recommendations for Windows that support this cycle? I would rather not use Emacs.
00:27:04 <dons> pill19$ echo f | hugs +q t.hs | sed '1,/help/d;s/.*> //;/Leaving/d'
00:27:04 <dons> "hello"
00:27:20 <dons> no need for +q, actually
00:27:38 <dons> umm, I guess any useful programmer's editor would work
00:27:48 <dons> I'm not sure what people use on windows
00:28:44 <r2d4> OK! My usual ones did not have syntax highlighting for Haskell. I am currently using the Eclipse plugin. But it is sometimes heavy.
00:28:59 <dons> yeah, java will do that to you ;)
00:29:26 <dons> year's ago I remember PFE being what some  people used
00:31:03 <dons> maybe if you install ghc things might be a little easier:
00:31:04 <dons> pill19$ runhaskell t.hs
00:31:04 <dons> hello
00:31:19 <dons> pill19$ ghc -e 'main' t.hs
00:31:20 <dons> hello
00:31:30 <r2d4> I do have ghc
00:31:33 <dons> pill19$ echo 'main' | ghci -v0 t.hs
00:31:34 <dons> hello
00:31:40 <dons> lots of ways to run haskell!
00:31:41 <lispy> is there a haskell one liner for 'cat'
00:31:45 <dons> sure.
00:33:38 <dons> paprika$ ghc -e 'getContents >>= putStr'
00:34:53 <lispy> thanks
00:35:07 <pejo> When studying the asm output of ghc, what kind of code produces this? ".long   Main_main_srt+0"
00:35:28 <dons> srt's. hmm. static reference tables, iirc?
00:37:16 <dons> pejo, what you doing by the way? seems like lots of interesting backend hacking..
00:38:05 <pejo> dons, trying to get correct code out of it.
00:38:33 <dons> oh, you chasing down a bug?
00:38:33 <pejo> Which is interesting, since the GHC commentary is outdated, and I don't know enough about ghc internals.
00:38:59 <pejo> Heh, no, I have a 1700 line patch for nativeGen/. :-)
00:39:07 <dons> ah!
00:39:18 <dons> mysterious. new nativeGen?
00:40:49 <pejo> My idea was to use nativeGen for other purposes. According to mail from Simon Marlow AsmCode*hs is the top module for that directory. But it didn't build for me, so I'm trying to beat it into submission.
00:41:42 <pejo> Now that it builds it doesn't generate the same code as it did in 6.2.2, something as is unhappy about.
00:42:47 <dons> hmm.
00:42:51 <dons> heh, I wrote a manzano$ wc -l stix.patch
00:42:51 <dons>     1578 stix.patch
00:43:05 <dons> 1578 line patch a couple of years ago :)
00:43:22 <pejo> I would have been perfectly happy with a working nativeGen, that would have saved me a lot of trouble. :-)
00:43:35 <mflux_> I guess haskell programs don't usually (ever?) have big reindentatation or whitespace patches?-)
00:43:43 <dons> I don't understand why the nativeGen didn't build?
00:43:54 <dons> mfux_: hmm. quite true.
00:44:06 <pejo> mflux, lots of this is indentation.
00:44:10 <pejo> dons, ah. I'm on sparc.
00:44:20 <dons> but sparc is supported.
00:44:30 <pejo> Please tell nativeGen/ that.
00:44:32 <dons> i've built up to 6.2.2 on sparc/openbsd
00:44:42 <dons> in what way is it breaking?
00:44:45 <pejo> Yeah, the nativeGen rewrite removed the support in 6.4.
00:44:52 <dons> yup
00:45:16 <dons> oh, you're trying to get sparc going again with *6.4*
00:45:17 <dons> I see
00:46:08 <pejo> To be honest I'm not really interested in ghc. But C-- seems like a worse alternative for me. And it's written in Ocaml.
00:46:24 <dons> why worse?
00:46:34 <dons> too hard to generate?
00:46:51 <pejo> So I figured I'd give nativeGen a try. Worst thing that can happen is that I've lost some time.
00:47:18 <dons> yeah, but learnt something about a real world code gen. can't hurt
00:47:22 <pejo> Cmm and C-- seems to essentially be the same from the comments in cmm/Cmm.hs.
00:47:43 <dons> hehe. I wrote those comments ;)
00:47:45 <pejo> But the 050321 release of C-- only supports ia32 for Linux according to the release notes.
00:48:05 <dons> ah. ok. didn't know that. I thought they had several archs going
00:48:30 <dons> Cmm in ghc uses only a simple subset of C--, and we add a few extra types
00:48:38 <dons> but almost the same
00:48:49 <pejo> I'm not really sure. They talk about Alpha/sparc support. I find it really hard to judge whether information is new/old and correct/incorrect without starting to dig deep into the code.
00:49:15 <pejo> And I'm even worse at Ocaml than Haskell.
00:49:32 <dons> only from talking to nr last year. he said he had some students working on other backends
00:50:04 <dons> so you want to compile to  a Cmm that ghc will accept ?
00:50:15 <pejo> Ramsey has a paper on his home page about how they implemented a new CFG in C-- though. Commit logs seem to have commits from May 'fixing' things. I would really prefer a stable code generator in a known language.
00:50:39 <dons> C-- will be that, I think. But it is new
00:50:49 <dons> you could target gcc ;)
00:51:24 <pejo> Yeah, to cmm that ghc will accept sounds good to me. Currently my best plan.
00:51:32 <dons> ok.
00:51:45 <pejo> And I have everything but time and money. :-)
00:51:50 <dons> I wrote (my patch above) was a stix backend to ghc
00:52:00 <dons> stix was the asm backend's intermediate format
00:52:04 <dons> before cmm
00:52:18 <dons> that worked. 1500 loc. so 1700 and you must be getting close ;)
00:52:58 <pejo> While generating C is good in all kinds of ways I'd like a 'native' backend. I looked into porting Gcc to M16 and i trembled in fear.
00:53:43 <dons> I think there's a need for a well-defined external interface to the Cmm layer of ghc
00:54:04 <dons> since several people have attempted to hack in backdoors to the nativeGen
00:54:35 <pejo> I can live without a well defined external interface and yada yada, as long as it doesn't make me work too much.
00:54:58 <dons> sure
00:55:13 <dons> just seems a pity to redo work others must be doing too
00:55:26 <dons> but nothing to be done about that for now
00:55:27 <pejo> I know. Thats why I'm giving nativeGen/ a chance.
00:56:11 <dons> feel free to mail cvs-ghc@ with questions
00:56:21 <pejo> My idea was that it would be less work (and less error prone) to just whack nativeGen into some shape.
00:56:36 <dons> yeah, I reckon it's a good idea too
00:56:44 <pejo> Heh. "Help, it doesn't work!", how about that one? :-)
00:57:24 <dons> at least on cvs-ghc@ wolfgang will see your msg. he wrote the new powerpc backend last year.
00:57:49 <dons> and you're likely to get good help on "what's an srt+0?" etc.
00:58:19 <pejo> Yeah, I've been looking at the powerpc backend. While it's a lot cleaner than alpha/sparc version it's not very similar either.
00:58:36 <pejo> Although I guess the architectures are not that different.
00:58:57 <dons> i wouldn't expect so, it's a complete rewrite post-Cmm, compared to sparc/alpha which must be 10+ years old
00:59:52 <pejo> But sparc has been maturing for 10 years. I hope most bugs are shaken out of the backend.
01:00:10 <dons> that's true.
01:00:28 <dons> though i know there's 1 bug in 64 bit words I stumbled across.
01:00:42 <dons> it's on the sourceforge bug list, fwiw
01:00:58 <dons> otherwise sparc was rock solid till 6.2.2 at least
01:01:27 <dons> just none of the developers has a sparc anymore
01:02:06 <pejo> I've seen that bug. I could live with it though, I think. If I can't, I'll have to fix it (later).
01:03:30 <pejo> (Or, in theory - someone else with a sparc might fix it if they just had a code generator that worked well enough for them).
01:17:23 <lispy> @hoogle makeTokenParser
01:17:51 <dons> only knows about the prelude
01:17:54 <dons> or h98, actually
01:18:13 <dons> @index makeTokenParser
01:18:13 <lambdabot> Text.ParserCombinators.Parsec.Token
01:18:20 <lispy> ah, prefect
01:18:21 <lispy> thanks
01:20:45 <lispy> the parsec documentation is out of sync
01:21:32 <lispy> @index ParsecLanguage
01:21:33 <lambdabot> bzzt
01:21:50 <dons> 6.2 versus 6.4, perhaps
01:22:05 <lispy> @index haskellDef
01:22:06 <lambdabot> Text.ParserCombinators.Parsec.Language
01:24:24 <pejo> dons, ah. It's all documented in CLabel.hs, srt is static reference table, as you said.
02:15:59 <pejo> Anyone on a non-sparc machine with ghc installed? I'd much appreciate parts of the output from "ghc -v5 Main.hs" where Main.hs is "main = do putStrLn "Tjaba"".
02:16:11 <pejo> Err, ghc 6.4 or newer, even.
02:26:58 <musasabi> pejo: http://youzen.b2.fi/~musasabi/output.txt
02:27:08 <sorje> pejo, http://martin.lddd.org/foo.out
02:30:03 <pejo> sorje, how come you get multiple definitions and musasabi not? :-)
02:32:11 <sorje> No idea
02:34:56 <pejo> Ok, thanks anyway. I'd appreciate if you let the log hang around for a day if it's not too much to ask.
02:36:35 <sorje> sure
02:57:22 <basti_> hi
03:07:29 * basti_ tunes in for the #haskell n00b session
04:25:31 <pejo> Hm. When compiling a program I get a section "data" { s1rO_closure: const s1rO_info; const 0; const 0; const 0; } ... s1rO_entry() { s1rO_info { const s1rO_srt-s1rO_info; const 131072; const 65560;  } label: ...
04:26:52 <pejo> This makes s1rO_srt and s1rO_info to end up in different segments, yet I get a ".text RET .align 8 RET .long s1rO_srt-(s1rO_info)+0 in my asm.
04:27:28 <pejo> And it seems like assemblers can't compute the difference between symbols in different segments.
04:29:21 <lightstep> segments? when are we, the 20th century?
04:29:28 <Igloo> What arch/OS is this?
04:29:54 <Igloo> And is ghc registerised or not?
04:32:12 <pejo> Igloo, sparc/Solaris. Second question I have no idea about, it's the stage1 compiler I'm seeing this behaviour with.
04:34:37 <Igloo> Ah, you're trying to build it yourself then?
04:35:30 <Igloo> Try a fresh build with   echo "GhcUnregisterised=YES" >> mk/build.mk; echo "SplitObjs=NO" >> mk/build.mk
04:36:23 <pejo> Igloo, yes. I got some output from ghc -v5 on MacOS X/Windows/ and they generate the same Cmm/asm basically, however their assemblers don't complain about it.
04:37:29 <pejo> Igloo, what does that do? Turn off the native codegen, the evil mangler and the splitter?
04:39:41 <Igloo> Yes (not sure about the NCG)
04:41:13 <pejo> Igloo, hm. Are you suspecting bit rot in the splitter/mangler?
04:42:25 <Igloo> Yes
04:50:47 <pejo> Igloo, hm. The unregistered stuff only affects stage2, doesn't it?
04:51:40 <Igloo> I thought stage 1 was an unregisterised compiler generating registerised code, BICBW
04:52:58 <pejo> config.mk says "NOTE: the stage1 compiler will be a registerised binary (assuming the compiler you build with is generating registerised binaries), but the stage2 compiler will be an unregisterised binary.".
04:54:12 <pejo> And I have no idea if the ghc I'm building with is registered. Boggle.
04:54:22 <Igloo> It doesn't matter, as long as it works
05:01:47 <pejo> Igloo, err. An unregistered build generates plain C. Thats not what I wanted. :-)
05:03:07 <Igloo> What do you want?
05:03:40 * Igloo assumed you wanted a working GHC, in which case unregisterised is the route most likely to get you there
05:05:10 <musasabi> btw if any haskeller happens to be at debconf it could be nice to spend some evening chatting.
05:06:04 <pejo> Yes, I want a working GHC. I'd be thrilled if I could get code that passed the assembler from it too, since nativeGen is unusable otherwise.
05:07:24 <musasabi> pejo: usually one should first compile an unregistered build and then worry about trying to get a registered one.
05:19:18 <pejo> musasabi, my stage1 compiler generates fine code with -fvia-C, it's just with nativeCodegen it's not working.
05:19:53 <musasabi> pejo: -fvia-C produces usually faster code than nativeCodegen.
05:20:09 <musasabi> pejo: what you want is a registered -fvia-C.
05:21:13 <musasabi> usually unregistered-via-c < nativeCodegen < registered-via-c
05:21:24 <musasabi> but depends on the code.
05:23:41 <pejo> musasabi, I want a working nativeCodegen, I don't care much about the front end.
05:25:51 <Igloo> If you want a working NCG you'll probably have to fix it
05:27:21 <pejo> Igloo, I know, hence my original question.
05:48:24 <jynxzero> Hi.  There are two functions in Data.Map called insertLookupWithKey and updateLookupWithKey.  The behaviour seems a bit inconsistent.  The lookup done by insertLookupWithKey is always done on the old map, whereas the lookup with updateLookupWithKey is done on the old map if the item is removed, but on the new map if the item is updated.
05:48:54 <jynxzero> Would anyone agree that, either insertLookupWithKey should behave the same as insertLookupWithKey, or the difference should be specified in the documentation?
05:49:06 <jynxzero> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Map.html#v%3AupdateLookupWithKey
05:49:41 <jynxzero> Personally I think maybe the behaviour of updateLookupWithKey is a bug, it should be like insertLookupWithKey
05:50:07 <jlouis> ask on libraries@
05:50:59 <jynxzero> OK, will do.
05:56:45 <basti_> HAH
05:56:54 <basti_> i got an idea what to write a TMR article about
05:57:22 * basti_ boinks happily
05:57:41 <jyp> what's it?
05:57:51 <jyp> !?!? :))
05:59:26 <jyp> ?
05:59:47 <basti_> algorithmic algorithms for csound =)
06:00:03 <basti_> i was talking about time stretching algorithms (DSP) with someone
06:00:26 <basti_> these involve lots of parametric "arrays" of things
06:01:01 <basti_> like, 50 biquad filters with some processing inbetween
06:01:10 <jyp> ouch :)
06:01:54 <basti_> but going to buy food now
06:01:54 <jyp> @google csound
06:01:55 <basti_> bbl
06:01:56 <lambdabot> http://www.csounds.com/
06:02:04 <jyp> k
06:26:28 <basti_> re
08:20:10 * basti_ flips a few bits
08:26:10 * genneth is mesmorised by the bits barbeque basti_ has got going
08:44:00 <musasabi> Igloo: is the alpha ghci thing solved?
08:48:14 <Igloo> no
08:51:43 <autrijus> @type Control.Monad.Trans.lift
08:51:49 <lambdabot> forall (t :: (* -> *) -> * -> *)
08:51:49 <lambdabot>             a
08:51:49 <lambdabot>             (m :: * -> *).
08:51:49 <lambdabot>           (Control.Monad.Trans.MonadTrans t, Monad m) =>
08:51:49 <lambdabot>           m a -> t m a
08:54:14 <autrijus> hm, is there a class that resembles something like
08:54:29 <autrijus> class Liftable m n where
08:54:36 <autrijus>     lift' :: m a -> n a
08:54:36 <autrijus> ?
08:55:23 <TheHunter> not in the libs, but it can easily defined.
08:55:38 <TheHunter> Iavor's monad library does something like that iirc.
08:55:38 <autrijus> nod. I wonder its general usefulness
08:55:43 <TheHunter> *be
08:55:44 <autrijus> 'k.
08:56:15 <autrijus> I'm mostly tired of having to count the number of lifts :)
08:57:31 <TheHunter> i actually think it's better if you define a custom lift operation for every monad you want to lift.
08:57:48 <autrijus> indeed? you don't think liftIO is a good idea?
08:58:01 <TheHunter> like liftState :: MonadState s m => State s a -> m a
08:58:08 <autrijus> or do you mean that there should be a liftSTM, liftReaderIO, liftState
08:58:21 <TheHunter> yeah, exactly like liftIO.
08:58:32 <autrijus> i.e. instead of using 2param class, always use 1param
08:58:36 <autrijus> what's the win of that?
08:58:38 * TheHunter thinks notices lagging a bit.
08:59:18 <TheHunter> you always see that you're lifting a state and error messages are less weird.
08:59:29 <TheHunter> s/that/what/
09:00:20 <autrijus> *nod*
09:00:35 <autrijus> but this is one of the rare cases that 2param class won't need fundeps
09:00:57 <TheHunter> but i've never actually tried the transitive closure of MonadTrans approach.
09:01:11 <autrijus> transitive closure?
09:01:14 * autrijus professes ignorance
09:01:49 <basti_> what are monad transformers?
09:01:53 <TheHunter> well, MonadTrans kinda defines a relation on monads.
09:02:01 <basti_> what kind of a relation?
09:02:08 <autrijus> "one level higher" relation.
09:02:11 <shapr> basti_: http://nomaware.com/monads/html/transformers.html
09:02:19 <autrijus> the relation as defined in "lift"
09:02:26 <TheHunter> right.
09:02:33 <basti_> hmm
09:03:20 <basti_> ooooo
09:04:40 <Igloo> musasabi: It's not likely to be soon unless an alpha person does the work, BTW
09:07:06 <musasabi> Igloo: I just noticed it and I *do* have an alpha system with debian and some experience with it.
09:07:19 <musasabi> it == the architecture.
09:07:47 <musasabi> I think I will try tackling it.
09:07:59 <Igloo> OK, cool. IIRC the problem is that Alpha Elf relocations need to be handled in Linker.c
09:08:46 <Igloo> It's possible that looking at the equivalent file in xfree86's source would help you if you get stuck, and of course you may find help on the mailing list
10:27:17 <TheHunter> Damn you, moinmoin.
10:30:41 <TheHunter> grrr, it's FootNote, not Footnote.
10:38:05 <TheHunter> it apparently can't produce links inside a footnote and doesn't even leave enough room in the comment to explain the problem properly.
12:35:02 * genneth gazes sadly at the rolling tumble weed
12:35:59 * AtnNn chooses a point on the tumbleweed and draws a cycloid
12:37:59 * basti_ paints lines on the lonesome road --------------
12:40:31 * lament carefully chooses another point on the tumbleweed and draws a line
12:40:52 <basti_> oooooo oooo
12:55:42 * genneth sings "oooooo oooo"
12:56:33 <xerox> Hey hey.
12:59:56 <SM_ax> genneth, i like that song :)
13:00:28 <SM_ax> I wonder, how are cops doing? All dirty? :)
13:05:36 <genneth> :-D
13:05:48 <genneth> actually, I have a really stupid question: what is literate haskell?
13:06:56 <basti_> uhm
13:07:06 <basti_> you write > before the source code lines, and the rest is comments
13:07:57 <genneth> oh okay
13:08:10 <xerox> Yes, you write a description of your program intervalled with "commented" (via > or \code, if I'm correct) blocks of code.
13:08:10 <genneth> I guess the logical following question would be... why?!
13:08:20 <xerox> For clarity!
13:08:27 <mauke> for great justice!
13:08:28 <xerox> @code
13:08:29 <genneth> O_o
13:08:30 <lambdabot> List.hs: zipWith6                :: (a->b->c->d->e->f->g) ->
13:08:32 <xerox> @cide
13:08:33 <lambdabot> Eq.hs: {-# OPTIONS_GHC -fno-implicit-prelude #-}
13:08:44 <xerox> Uhm, search for a .lhs file in $fptools :)
13:09:18 <mauke> genneth: see http://okmij.org/ftp/Haskell/CCard-transform-DFA.lhs for an example
13:10:05 <genneth> ah...
13:10:07 <genneth> I see it now
13:10:15 <lispy> it's not passible to have a dotted list in haskell is it?
13:10:21 <genneth> haskell _actually_ should have more comments than code
13:10:43 <mauke> lispy: no, because haskell's lists aren't constructed from pairs
13:11:13 <pejo> genneth, Knuth has written some stuff about literate programming. http://www-cs-faculty.stanford.edu/~knuth/lp.html
13:11:30 <lispy> okay, trying to make a lisp parser, so i either need a dotted type, or to roll my own list type
13:11:40 <pejo> genneth, and apparently there's lots of information at http://www.literateprogramming.com/
13:12:38 <genneth> pejo: thanks for those
13:12:52 <genneth> I think I get it now; obvious (like all great ideas) on one level
13:13:01 <genneth> now to make my team do it... *evil grin*
13:38:35 <frederik> hello
13:39:47 <frederik> hello!
13:40:12 <basti_> HI!
13:40:19 * basti_ shakes frederik 
13:41:10 <frederik> i'm in a better time zone now
13:41:21 <frederik> in fact the canonical one
13:41:33 <basti_> uhm?
13:41:49 <basti_> which phase angle do you canonicalize?
13:43:01 <frederik> 0
13:43:02 <lament> canonize
13:43:12 <basti_> ;)
13:43:24 <basti_> angle 0 measured against what?
13:44:01 <lament> against Greenwich probably
13:44:37 <basti_> ah i forgot... the center of the world's surface... ;)
13:45:10 <lament> basti_: no, that's Jerusalem
13:45:37 <lament> it's common knowledge that the earth is a flat disk, with Jerusalem at the centre
13:45:38 <frederik> mecca
13:45:48 <basti_> ahhh.
13:45:50 <lament> frederik: Even Muslims put Jerusalem at the centre.
13:46:06 <frederik> really?
13:46:14 <lament> I believe so.
13:46:33 <basti_> we should paint it green then.
13:46:54 <basti_> to mark it.
13:47:10 <lament> frederik: in particular the Rock over which the huge mosque is, at the site of the old jewish Temple, is the center of the entire universe
13:47:36 <frederik> i wonder if that makes it a tortoise
13:48:10 <basti_> bert the turtle?
13:48:47 <frederik> i think it would be called "ommm"
13:49:41 <frederik> so does anyone here use WASH?
14:06:39 <lightstep> -
14:07:41 <ski> +
14:08:47 <lightstep> hand-keyboard miscoordination
14:21:09 <frederik> i'm thinking of making my own release of WASH
14:22:28 <frederik> with cabal, single package, add things that rely on non-standard ghc libraries like MonadFix and MonadTrans (at least Peter Thiemann tells me these are non-standard)
14:22:42 <frederik> also Typeable...
14:23:16 <frederik> but i'm not sure how many other people would use it
14:32:36 <gzl> frederik: what's the goal?
14:32:43 <gzl> frederik: and yes, I've used WASH
14:33:29 <frederik> well Thiemann's goal is apparently to have it work on any compiler, but I think most users use ghc
14:34:02 <frederik> and i think the adoption of WASH is being slowed down by his concerns over compatibility
14:34:40 <gzl> I think the adoption of WASH is also being significantly slowed by the fact that it's a pain in the ass to use
14:34:51 <frederik> how?
14:35:07 <gzl> it's extremely complicated to do a lot of simple things
14:35:32 <gzl> and the whole type structure he's developed for WASH is too complicated
14:36:02 <frederik> i mean i agree, but all the examples i've come up with boil down to compatibility fears
14:36:17 <gzl> that may be, I don't know
14:36:21 <frederik> like you have to implement Types for things you want to put in a cookie
14:36:27 <Igloo> What features need MonadFix and MonadTrans OOI?
14:36:28 <gzl> I also can't give a good example because I haven't used WASH in two months or so
14:36:39 <frederik> there should be an instance Typable => Types but he doesn't want this because it's ghc
14:37:00 <frederik> WithHTML should be MonadFix so that you can put submit buttons before the fields they submit (gasp)
14:37:19 <gzl> ah yes, WithHTML is a pain in the ass
14:38:05 <frederik> and MonadTrans because its 'fix' is the same type IIRC
14:38:24 <frederik> why else is it a pain though?
14:38:30 <frederik> i found it quite nice aside from these things
14:38:57 <frederik> how would you do things differently?
14:39:43 <gzl> unfortunately, I've not used it in a while, so I can't give you more concrete information right now
14:41:38 <frederik> he made one big improvement for me, there is a "callWithCurrentHistory" (i think) which allows you to do looped interactions without growing the log
14:43:30 <gzl> I don't think it does a great job of separating content and display
14:43:58 <frederik> well that's not really its job
14:44:02 <frederik> or should it be?
14:44:10 <gzl> I think it should be
14:44:55 <frederik> can't you just write wrapper functions to format your content?
14:45:08 <gzl> I can't give more specific examples right now, but I found doing things that are relatively simple in other languages extremely annoying in WASH
14:45:19 <gzl> often due to type conflicts
14:45:22 <frederik> what languages do you recommend?
14:46:00 <gzl> I haven't done enough web authoring to recommend anything in particular, but I've been told about some python-based packages that are supposed to be nice
14:46:10 <gzl> something called cherrypy, iirc
14:46:36 <gzl> my admittedly vague complaint is that WASH is just way too complicated
14:46:50 <gzl> most of the time people want to do really simple things
14:47:41 <gzl> it's also extremely opaque -- it's very difficult to figure out what exactly the system is doing
14:48:04 <frederik> well that's the price of power
14:48:21 <gzl> I don't agree
14:48:25 <gzl> I think it's just bad design
14:48:30 <gzl> the easy things should be easy
14:48:47 <gzl> only if you want to do something really wild should you have to get your hands dirty with all the junk in the system
14:49:12 <gzl> of course, it's not easy to accomplish that, but that's the goal imho
14:49:16 <frederik> hmm
14:49:36 <gzl> I took a class last term where everyone's final project had to be WASH-based, and pretty much everyone had the same complaint
14:49:48 <frederik> oh interesting
14:49:52 <gzl> everyone managed to get pretty good stuff working, but it was more annoying than it needed to be
14:50:09 <frederik> well i can't say i completely trust Peter's judgment. i think he's smart, i think WASH is a good system, but i'm also complaining about annoyances
14:50:26 <gzl> I wish I could give you concrete examples, but I just can't remember
14:50:48 <frederik> where was this class? what was it called?
14:51:33 <gzl> http://www.cis.upenn.edu/~bcpierce/courses/advprog/index.html
14:51:58 <frederik> oh how's pierce? i thought he was an ocaml guy
14:52:11 <gzl> he's great, I've done a few things with him
14:52:32 <gzl> he was debating for a while whether to use OCaml and Haskell and decided on Haskell for the course
14:53:07 <gzl> yeah, he is more familiar with OCaml, but he decided on Haskell for various reasons
14:53:54 <frederik> tell him to rewrite unison in haskell
14:54:36 <gzl> if you can give a good reason why he should rewrite thousands of lines of code I'll tell him
14:55:05 <frederik> so i will hack on it
14:55:14 <frederik> maybe
14:55:15 <gzl> I think the more reasonable solution is that you learn OCaml. :)
14:55:28 <frederik> also so the argument parsing will be sane
14:58:08 <frederik> anyway, so i take it that even if i improved various things about WASH you stil wouldn't like it
14:58:53 <gzl> ok, here's a slightly more specific gripe about WASH. if you want to write even simple things, you very quickly have to get involved in understanding the subtleties of the type system
14:59:08 <gzl> I think it needs some more serious rethinking
14:59:17 <frederik> what subtleties?
15:00:33 <frederik> (going home, may log on again...)
15:00:34 <gzl> things like how those monads work, the WithHTML x CGI a types
15:01:10 <frederik> he could explain it much better in his papers, but i think it's very intuitive
15:01:46 <gzl> maybe it is and the documentation is just poor
15:01:53 <gzl> those example programs he's offered I found largely useless
15:02:48 <frederik> should i call a fork "spin"? or "dry"?
15:04:31 <basti_> neither?
15:09:45 <gzl> what?
15:11:48 <kowey> hi haskellers,  does anyone know the status of Unicode Chars in ghc? (6.4)
15:12:23 <kowey> latest news i have is from 5.04 http://www.haskell.org/hawiki/UnicodePrelude
15:14:45 <kowey> or i suppose i'm confused... if i understand correctly, Char is a Unicode code point
15:15:09 <kowey> but what about IO? is it still not possible to read/write beyond iso8859-1?
15:37:17 * cm lifts autrijus
15:40:16 <frederik> i thought unicode io was well-supported
15:40:38 <frederik> gzl: the fork of wash i am planning. well maybe it doesn't deserve a special name
15:41:45 <gzl> how about FWASH?
15:41:51 <gzl> that's fun to say.
15:43:28 <frederik> 'spin' is neat because you can spin a website. and it's what washing mashines do after 'wash'
15:43:34 <kowey> frederik: i dunno... seems to only accept latin-1
15:44:10 <kowey> but then again, i'm also trying to use alex to parse something
15:44:24 <gzl> frederik: that's a good idea too. I thought FWASH because of Frederik's WASH or something.
15:47:03 <frederik> kowey: yeah alex is probably the problem
15:48:06 <frederik> it doesn't support anything
15:48:17 <frederik> gzl: i got that
15:48:33 <gzl> well, who knows. :)
15:49:07 <tautologico> fwash could be anything... like fancy wash
15:49:15 <frederik> the only question is whether i'll have enough time to make something which is better enough to deserve a whole new name
15:49:27 <cm> ("spin" sounds neat)
15:49:42 <frederik> but it may be a matter of being more open to patches than Peter is
15:52:05 <lispy> well, not sure why i've bothered, but i have an elisp parser in haskell now :)
15:52:26 <frederik> i'm not sure why you bothered either :)
15:53:09 <lispy> if i can get the evaluator to match that of emacs then Yi could emulate emacs :)
15:53:16 <lispy> so that's one possible use
15:54:31 <frederik> i see
15:54:43 <frederik> is it compatible already? sounds hard
15:54:57 <lispy> well, the parsing is the easiest part
15:55:12 <lispy> and it may have bugs that i don't know about
15:55:16 <frederik> oh i misread
15:55:31 <lispy> but it appears to parse my .emacs and some elisp that i've written over the years
15:55:53 <lispy> parsec makes it really easy
15:55:54 <joao> Hello
15:56:10 <tautologico> hi
15:56:46 <lispy> and you know what, i bet my number parser fails on some cases....
15:57:31 <joao> Just a simple question: is it possible to implement Sets as lists (for instance) and make them instance of class Functor? fmap complains about Eq restriction, right?
16:02:30 <TheHunter> it's not possible. fmap would have to have type fmap :: Ord b => (a -> b) -> Set a -> Set b
16:03:21 <TheHunter> there's a paper by Hughes about it and it has popped up several times on the mailing lists if you're interested.
16:03:35 <joao> Then, there's not any Set implementation which can derive Functor?
16:03:45 <joao> I'd like to read it...
16:03:47 <joao> :)
16:03:57 <joao> Can you point me out the link or something?
16:05:24 <TheHunter> http://www.cs.chalmers.se/~rjmh/Papers/restricted-datatypes.ps <- i think, that's the paper.
16:05:49 <TheHunter> it proposes an extension that has never been implemented
16:06:22 <joao> Thanks :)
16:07:02 <TheHunter> @google haskell cafe monad set
16:07:04 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2004-March/005988.html
16:07:21 <TheHunter> that's one of the discussions.
16:15:46 <esap> Hmm.. how can I make GHC unify two types that are only available from two separate existentally quantified packages, when I only know at run-time whether they are equal or not?
16:16:32 * esap uses GADTs.
16:20:29 <ski> don't think you can unify them
16:21:05 <ski> possibly you can use some kind of type equality witness ?
16:21:21 <esap> I've been thinking all kinds of approaches, but can't seem to get it working.
16:21:25 * TheHunter doesn't understand the question
16:22:49 <TheHunter> if you define |data E :: * -> * -> * where E :: E a a|, any non-bottom value of a type E a b will be a proof that a and b are identical.
16:23:30 <esap> basically I have constructor      TCompose :: TArrow c mid cod -> TArrow c dom mid -> TArrow c dom cod, and two values x :: TArrow c dom mid   y :: TArrow c mid' cod, where I can prove at run-time that the codomain type of x and domain type of y are the same.
16:23:41 <autrijus> esap: unifying based on runtime type equivalence needs either fromDyn/toDyn or unsafeCoerce, iirc
16:25:39 <TheHunter> a function of type |E mid mid' -> TArrow c dom mid -> TArrow c mid' cod -> TArrow c dom cod| should be implementable.
16:26:21 <esap> TheHunter: Hmm.. that's a good idea. I'll try it out whether it works.
16:27:06 <ski> TheHunter : i think one can also do leibniz equality instead of inductive equality ..
16:28:14 * TheHunter neither knows the term leibniz equality nor the term inductive equality...
16:30:04 <ski> TheHunter : that |data E :: * -> * -> * where E :: E a a| is the inductive one
16:30:43 <TheHunter> and forall f. f a -> f b is the leibniz one?
16:31:04 <TheHunter> both can be easily transformed into each other.
16:31:14 <ski> TheHunter : leibniz is  data E a b = E (forall f. f a -> f b)      -- you can prove both directions of the impliction from just one direction
16:31:18 <ski> yes
16:31:19 <ski> yes
16:38:48 <esap> I get 'couldn't match rigid variable 'f' against rigid variable 'g'' errors even from the inductive version of equality.
16:39:57 <esap> It's strange, it occurs when I call the function.
16:40:05 <esap> not at the definition of the function itself.
16:40:31 <esap> Maybe it's not valid to just declare they are equivalent, I need to prove them fully there? :-)
16:41:46 <TheHunter> at some point, you need a proof of type equality, or unsafeCoerce#...
16:42:23 <esap> The problem I'm having is I don't know where to put it. I don't see any place where the compiler could infer it correctly.
16:43:12 <esap> I have a 'case' construct that matches a pair, but I have no idea how to tell that construct that the types are equivalent.
16:43:29 <esap> because declaring a type annotation on a pattern does not do it
16:44:19 <ski> with leibniz, you can use the equality witness to coerce between value of type with one typevariable and value of type with the other typevariable
16:45:51 <esap> Ok, I'll think this more, I think I can write a (big and complicated) way to do it, by explicitly pattern matching all pairs of expressions, and reconstructing them as different type.
16:50:33 <esap> actually, hmm. there is a simpler way. constructing the witness from that. hmm..
16:53:29 <cognominal> I am reading "practical type inference for arbitrary rank types" and I am stuck page 4 by the @
16:53:37 <cognominal> what does it mean?
16:54:01 <frederik> what does it say?
16:56:37 <cm> foo@bar?
16:57:02 <cm> foo is bound to the same value as captured by the pattern bar
16:57:10 <cm> or is that a non-Haskell @
16:57:53 <cognominal> Map m@(Mon { return = retm bind =bnd }) f xs = ...
16:57:57 <tmccort> Hey how's the contest going? Did they announce that alteration of the spec yet?
16:58:15 <cognominal> I don't know if I give enough context to make that subexpression understandable
16:59:14 <cm> I dunno, but in "foo bar@(Baz boink)", bar is bound to the (Baz boink), and boink to the boink in Baz
17:02:51 <frederik> i have to give a talk on haskell in August
17:03:02 <frederik> to a bunch of machine learning people
17:03:30 <frederik> is there something which gives a complimentary perspective to Hughes' whyfp?
17:03:30 <tmccort> Have fun :)
17:03:33 <frederik> thx
17:04:40 <cognominal> cm: thx
17:04:49 <tmccort> Like "Why Functional Programming DOesn't Matter" or somesuch?
17:05:34 <Beelsebob> haja
17:05:48 <Beelsebob> sounds about right for half the people here
17:06:20 <frederik> no, like "why the important part about functional programming is preventing people from using side effects"
17:06:51 <frederik> IIRC hughes says that the important part is compositionality or modularity or something, not this restrictiveness
17:07:25 <tmccort> I've never really had a problem with side effects really.
17:07:50 <frederik> well it's nice to be able to see where data comes from
17:10:14 <tmccort> I'm not really sure how I feel about haskell so far. I just started learning it.
17:11:51 <tmccort> Ocaml is pretty cool but it has a horrid syntax
17:11:57 <tautologico> it's not necessarily the side effects, but
17:12:21 <tautologico> many experiences are showing that's useful to avoid side effects when possible
17:12:31 <tautologico> take the simple example of Erlang
17:13:24 <tautologico> it makes concurrent programming far simpler than the crazy java model by avoiding shared state
17:13:58 <tmccort> Don't know much about Erlang myself.
17:14:14 <tautologico> when you know erlang, threads with shared state and syncronization primitives start to seem like a horrid hack
17:15:03 <tmccort> Heh.
17:15:13 * frederik goes to sleep
17:15:26 <autrijus> I don't know erlang, but I always thought explicit synchronization is a horrid hack :)
17:16:56 <tautologico> I still haven't read the papers on composable memory transactions... should do it soon
17:36:41 <cm> chocolate!
17:40:49 <wagle> tautologico: ah, thanks for reminding me about that
17:42:02 <tautologico> about ?
17:42:14 <tautologico> stm ?
17:42:44 <wagle> stm.pdf
17:42:50 <wagle> ya
17:43:06 <tautologico> :)
17:44:46 <autrijus> I find the powerpoint to be easier to grok before reading the paper
17:44:59 <autrijus> http://homepages.inf.ed.ac.uk/wadler/linksetaps/slides/peyton-jones.ppt
17:47:24 <tautologico> thanks
17:47:30 <tautologico> I'll have a look at it
17:47:55 <autrijus> :)
17:48:39 <tautologico> in maybe... 2 or 3 weeks, as my planning goes :)
17:50:02 <jlouis> there are 2 tricks in erlang: 1: Threads sends messages to each other. This is the only way to send information to another thread. All messages are effectively copies, so there is no shared state.
17:50:44 <jlouis> 2: messages are ''fire-and-forget''. We do not know if the message arrives at the other endpoint. If we want to know, let it send a message back
17:51:08 <jlouis> 3: (Theres 3 tricks) If you know the name of a thread, you can send it a message
17:51:33 <lispy> 4?
17:51:35 <lispy> ;)
17:51:38 <jlouis> hehe
17:51:39 <tautologico> a pair of 3 tricks ? :)
17:51:45 <tautologico> like a trilogy of 5 books
17:51:52 <lispy> basti_: where are you?
17:51:54 <autrijus> maybe 4: is that messages are dynamically typed :)
17:52:00 <jlouis> I think the solution are better than STM
17:52:29 <jlouis> messing with shared state is... irritating at the least
17:52:41 <jlouis> though the monad packaging is rather nice
17:54:28 <autrijus> and STM retains the imperative feeling
17:55:28 <autrijus> but maybe I'm still too brainwashed in the mutable state school
17:55:35 * autrijus decides to start reading up on erlang
17:58:14 <tautologico> ctm is a good book to read about concurrency models
17:59:31 <wagle> ctm?
17:59:59 <tautologico> sorry... concepts, techniques and methods of computer programming
18:00:05 <tautologico> by peter van roy and seif haridi
18:00:20 <tautologico> oops, the m is for models
18:01:12 <tautologico> http://www.amazon.com/exec/obidos/tg/detail/-/0262220695/qid=1120957297/sr=8-1/ref=sr_8_xs_ap_i1_xgl14/104-1988057-3389557?v=glance&s=books&n=507846
18:01:32 <autrijus> the erlang course is very nicely written
18:01:54 <autrijus> with graphs! I wished that haskell courses has graphs.
18:03:57 <liyang> graphs?
18:04:31 <wagle> tautologico: cool
18:05:16 <autrijus> liyang: drawings that explains the control flow etc
18:05:49 <tautologico> monadic graphs ? :)
18:05:54 <liyang> control? ... flow? ... Haskell?
18:05:58 <tautologico> control flow is not very haskell
18:06:04 <liyang> tautologico: Perhaps. :)
18:06:11 <autrijus> control flow is indeed very haskell
18:06:19 <autrijus> only we call it "reduction order" ;)
18:06:35 <autrijus> lazy eval makes the evaluation order nonapparent for newbies
18:06:47 <wagle> scuttlebutt is that its very hard to predict evaluation order
18:06:56 <wagle> .. even for experts
18:07:19 <tautologico> and it should be nonimportant
18:07:34 <autrijus> it is nonimporatnt if you don't care about performance :)
18:07:48 <wagle> important if you want real time
18:07:49 <autrijus> (or you don't need to debug)
18:08:20 <wagle> which is why timber is strict
18:08:34 * liyang worries about correctness first. :p~~
18:08:58 <wagle> prediction is part of correctness for real-time
18:09:08 <wagle> s/prediction/predictability/
18:10:09 <tautologico> well... I don't believe haskell was originally meant for real-time...
18:10:27 <tautologico> and I believe lazy evaluation may be too complicated for that
18:10:57 <cm> i'd prefer lazy evaluation to be optional
18:11:05 <cm> ocaml-esque, IIRC
18:11:11 <wagle> x = 1 : x
18:11:26 <tautologico> my dream is something that integrates well lazy and strict
18:11:28 <liyang> cm: kinda makes it rather akward to use then...
18:11:38 <cm> x = 1 : lazy x
18:11:39 <tautologico> default strict
18:12:12 <wagle> cm: which language?
18:12:21 <cm> "Haskell of my dreams"
18:12:26 <wagle> ah
18:12:28 <lispy> strict requires special rules for the order of evaluation.  So from that point of view it can be harder to learn.
18:12:55 <lispy> take short-circuit evaluation found in many languages
18:13:34 <cm> wagle: O'Caml would be lazy (1 : x) I think.. if : is cons in O'Caml..
18:13:41 <wagle> eh?  the hoops R4RS jumped through in its denotational semantics of shceme were (in my opinion) way more opaque
18:13:56 <cm> anyhow, default lazyness is nothing which particularly appeals me about Haskell
18:13:57 <autrijus> sub infix:<or> ($x, $y is lazy) { if $x { $x } else { $y } }
18:14:16 <tautologico> :: is cons in ocaml
18:14:17 * heatsink figured out how to make the Haskell typesystem compute the XOR function on 4-bit numbers :D
18:14:23 <wagle> eh?  the hoops R4RS jumped through in its denotational semantics of scheme to not specify the order of evaluation of arguments were (in my opinion) way more opaque
18:14:38 <cm> ah, right
18:14:47 * heatsink thinks about how to add numbers
18:14:59 <wagle> heatsink: subtract
18:15:19 <heatsink> what?
18:15:22 <autrijus> heatsink: next you'll be writing data N c = Z | S c
18:15:31 <tautologico> peano
18:15:32 <lispy> if you have xor, you could build a half and then full adder :)
18:15:35 <wagle> church numeral subtraction is quite a mind bender
18:15:51 <heatsink> these aren't church numbers, though, they're binary numbers
18:16:15 <wagle> ok..  just thought subtraction would still be harder than addition
18:16:23 <heatsink> xor (undefined :: Nybble Zero One One Zero) (undefined :: Nybble One Zero Zero One)
18:16:33 <wagle> s/harder/harder or the same as/
18:16:47 <cm> :)
18:17:23 <wagle> heatsink: where does the answer come out?
18:17:44 <heatsink> xor produces an int
18:18:12 <heatsink> I wanted it to produce another Nybble but I got type check problems
18:20:39 <wagle> you try fundeps?
18:21:30 <heatsink> I don't understand fundeps/
18:22:00 <wagle> here's your chance then..  >)
18:22:46 <heatsink> phbmpf. >:p
18:23:02 <wagle> rofl
18:51:20 <heatsink> I think I understand why it doesn't work.
18:52:52 <heatsink> I can pass an instance of class Bit as a parameter, but I can't return a specific instance of class Bit as a return value.
19:01:10 <wagle> its all done with fundeps, i tell ya
19:06:49 <wagle> geez.  install one darwinports package, and it installs all the rest
19:07:35 <jlouis> heatsink: a fundep is used to solve certain cases of ambiguity in multi parameter type classes.
19:08:43 <jlouis> in general, it might be that the parameters of a mptc cannot be inferred. The fundep then helps the inference by defining a dependency between parameters
19:09:44 <heatsink> ok...
19:10:28 <jlouis> the original paper is an easy read. But beware that his math skills could be better. He makes it a lot more complicated than it really is
19:13:12 <wagle> which paper is that?
19:13:44 <heatsink> http://www.cse.ogi.edu/~mpj/pubs/fundeps.html I think
19:13:49 <liyang> the fun with fundeps one
19:23:01 <lispy> fairly often i type do { x <- foo; return (bar x)} or do {x <- foo; bar x} is there an easier way using >> or similar?
19:23:31 <heatsink> >>=
19:24:10 <wagle> foo >>= bar in the latter case
19:24:39 <wagle> foo >>= (return . bar) in the former
19:27:25 <lispy> ah
19:27:28 <lispy> thanks
19:28:50 <Tigerclaw> wow guys , this is litle new for me .. i am from a Different Network .. owner of Globalchat .. i didn't see non of the room an op ..
19:29:48 <liyang> (There's also `ap` and =<< )
19:29:51 <lispy> that's common on freenode
19:30:58 <lispy> Tigerclaw: there are probably people here who can gain op in a split second, but i think the philosophy on freenode is to not show off or op status
19:31:12 <heatsink> *our
19:31:55 <lispy> heatsink: i meant to type 'your' but 'our' works as well :)
19:32:39 <lispy> liyang: how would you do it with ap?
19:32:42 <lispy> @type ap
19:32:47 <lambdabot> bzzt
19:32:56 <lispy> @hoogle ap
19:32:57 <lambdabot> Monad.ap :: Monad a => ((a (b -> c)) -> (a b) -> (a c))
19:32:57 <lambdabot> Prelude.appendFile :: (FilePath -> String -> (IO ()))
19:32:57 <lambdabot> Ratio.approxRational :: RealFrac a => (a -> a -> Rational)
19:33:05 <wagle> hoogle?
19:33:18 <lispy> it's like google for haskell :)
19:33:25 <wagle> hahah
19:33:34 <lispy> @hoogle (a->b->c) -> (a ->c)
19:33:35 <liyang> If you have a function wrapped up in a monad, use `ap`.
19:33:35 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => (a -> b)
19:33:35 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => (a -> b)
19:33:35 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => (a -> b)
19:33:59 <lispy> liyang: huh, okay
19:34:12 <lispy> liyang: ap is maybe short for apply?
19:34:21 <lispy> @hoogle [a] -> a
19:34:22 <lambdabot> Prelude.last :: ([a] -> a)
19:34:22 <lambdabot> Prelude.head :: ([a] -> a)
19:34:22 <lambdabot> Prelude.product :: Num a => ([a] -> a)
19:34:34 <lispy> sometimes hoogle is smart, other times not so smart
19:35:13 <liyang> rather than say, do { f <- foo ; b <- bar ; return $ f b }, you can write foo `ap` bar
19:35:39 <liyang> ap does indeed seem to be short for `apply'.
19:36:12 <liyang> It's like $ for when you're stuck in a monad. :)
19:39:22 <wagle> @type liftM2 ap
19:39:24 <lambdabot> bzzt
19:39:29 <wagle> @type liftM2 ($)
19:39:30 <lambdabot> bzzt
19:39:39 <wagle> @type liftM ($)
19:39:40 <lambdabot> bzzt
19:39:48 <wagle> @type Monad.liftM ($)
19:39:49 <lambdabot> forall a b (m :: * -> *).
19:39:49 <lambdabot>        (Monad m) =>
19:39:49 <lambdabot>        m (a -> b) -> m (a -> b)
19:39:55 <wagle> @type Monad.liftM1 ($)
19:39:56 <lambdabot> bzzt
19:40:00 <wagle> @type Monad.liftM2 ($)
19:40:01 <lambdabot> forall b a2 (m :: * -> *).
19:40:01 <lambdabot>        (Monad m) =>
19:40:01 <lambdabot>        m (a2 -> b) -> m a2 -> m b
19:40:22 <wagle> @type Monad.ap
19:40:23 <lambdabot> forall b (m :: * -> *) a.
19:40:23 <lambdabot>     (Monad m) =>
19:40:23 <lambdabot>     m (a -> b) -> m a -> m b
19:40:30 <liyang> liftM1 would be return :)
19:40:42 <wagle> i mistyped the 2 as a 1
19:40:52 <liyang> *nod*
19:41:00 <wagle> ap == liftM2 ($)
19:41:22 <MachinShin> hey all
19:42:01 <liyang> (except shorter to type. :)
19:42:09 <lispy> hmm...Data.HashTable is not very haskelly
19:43:13 <lispy> hmm... fromList will probably make this easier
19:44:40 <liyang> Use Data.Map instead?
19:45:01 <jlouis> Data.Map is nice
19:46:54 * lispy looks it up
19:47:18 <wagle> @hoogle map
19:47:19 <lambdabot> Prelude.map :: ((a -> b) -> [a] -> [b])
19:47:19 <lambdabot> List.mapAccumR :: ((a -> b -> (a, c)) -> a -> [b] -> (a, [c]))
19:47:19 <lambdabot> List.mapAccumL :: ((a -> b -> (a, c)) -> a -> [b] -> (a, [c]))
19:47:27 <wagle> @hoogle Map
19:47:28 <lambdabot> Prelude.map :: ((a -> b) -> [a] -> [b])
19:47:28 <lambdabot> List.mapAccumR :: ((a -> b -> (a, c)) -> a -> [b] -> (a, [c]))
19:47:28 <lambdabot> List.mapAccumL :: ((a -> b -> (a, c)) -> a -> [b] -> (a, [c]))
19:47:29 <lispy> i'm trying to make a symbol table for an interpreter
19:47:39 <heatsink> @hoogle singleton
19:47:50 <heatsink> @hoogle empty
19:48:11 <liyang> @hoogle Data.Map
19:48:12 <lambdabot> Prelude.undefined :: a
19:48:12 <lambdabot> Prelude.minBound :: Bounded a => a
19:48:12 <lambdabot> Prelude.maxBound :: Bounded a => a
19:48:22 <heatsink> what is that/?
19:48:24 <liyang> ...?
19:48:51 <heatsink> @type Data.Map.fromList
19:48:53 <lambdabot> forall a k.
19:48:53 <lambdabot>        (Ord k) =>
19:48:53 <lambdabot>        [(k, a)] -> Data.Map.Map k a
19:51:05 <lispy> hmm..hashtable is probably better for my purpose
19:51:15 <lispy> this guy is O(log n) most of the time
19:52:15 <liyang> HashTable doesn't look like it's persistent though, given it's in IO...
19:52:15 <heatsink> you can coerce it to a monadic form with judicious application of unsafePerformIO
19:52:20 <wagle> hashtables are supposed to be O(1) average case?
19:52:27 <tautologico> yes
19:52:55 <tautologico> I believe if the load is below 70% and the hash function is good, it's O(1) average, guaranteed
19:53:42 <heatsink> DiffArray is also O(1) when used single-threaded
19:54:06 <wagle> though, i saw a denial of service attack that shoved a bunch of stuff into one bucket of a hash table for a server
19:54:47 * lispy wonders how he will represent function bindings in the symbol table
19:55:21 <lispy> some of my functions will be implemented in haskell, others will be defined in elisp
19:56:08 <wagle> http://www.cs.rice.edu/~scrosby/hash/
19:57:29 <lispy> interesting
19:57:47 <lispy> if my application sees enough use to worry about that i will take that as a compliment :)
19:57:49 <heatsink> lispy: then you'll be using IO anyway, right?
19:58:00 <lispy> heatsink: yes, i will be using IO ()
19:58:38 <wagle> sendmail started out the same way..  as a class project..  now look where we are!  8)
19:58:38 <lispy> heatsink: hmm..i'm not sure i understand what you're getting at?
19:58:44 <lispy> hehe
19:58:56 <lispy> i wants an elisp emulator
19:59:24 <lispy> so that elisp can be wired into non-emacs things
19:59:28 <heatsink> lispy: I read ne of liyang's comments as yours
19:59:40 <lispy> heatsink: np
19:59:42 <wagle> why elisp?
19:59:50 <lispy> for Yi
20:00:08 <wagle> compatibility?
20:00:20 <lispy> if Yi could emulate emacs at the level of elisp i could start using Yi instead of Yi
20:00:41 <lispy> for example if Yi could run gnus while those programs are ported....
20:00:56 <wagle> i could use Yi instead of Yi, too
20:01:00 * liyang tries to stay out of IO for all but actual system IO. 
20:01:01 * lispy believes Yi has more potential than emacs
20:01:11 <wagle> *<8-D
20:01:45 <wagle> prolly have to surgically remove the elisp interpreter from emacs.
20:02:02 <wagle> or write your own in... haskell!
20:02:07 <lispy> hmm...it's written in C, i'd hate to try reading it
20:02:17 <lispy> wagle: yes!
20:02:24 <lispy> my parser seems okay
20:02:38 <lispy> just embarking on eval now
20:02:57 <lispy> but this is the furthest i've ever made it in any of my interpreter projects
20:03:05 <lispy> so from here it's all new territory...
20:03:21 <wagle> lisp interpreters are easy
20:03:58 <wagle> unless it gets groody with mutations,etc
20:04:08 <lispy> mutations?
20:04:11 <lispy> groody?
20:04:22 <wagle> set-car!, set-cdr!, etc
20:04:46 <lispy> hmm...
20:05:00 <lispy> so far i have no functions and t and nil are my own builtin symbols :)
20:05:10 <lispy> s/own/only
20:05:53 <wagle> http://www.urbandictionary.com/define.php?term=grody
20:06:28 <lispy> ah
20:07:17 <lispy> i'm thinking that for user defined functions i can just store the function definition and re-evaluate it every time (who wants bother with compilition for this project?)
20:07:45 <lispy> but i need some way to specify when a function is builtin and also specify what function it corresponds to
20:08:08 <lispy> oh, maybe i can say it's (SExp -> SExp)
20:08:14 <wagle> is elisp still dynamically scoped?
20:08:19 <lispy> wagle: ya
20:08:29 <lispy> wagle: does that mean i can have just one global symbol table?
20:08:36 <lispy> i forget how dynamic typing wrks
20:08:58 <wagle> (define foo (x) (baz 3))
20:09:15 <wagle> (define baz (y) (+ x y))
20:09:35 <wagle> baz can see the x of the function in the call chain, foo
20:10:08 <lispy> (foo 5) => 8
20:10:15 <wagle> ya
20:10:35 <lispy> so a global symbol table is not the solution
20:11:21 <wagle> no..  gotta maintain an environment, and extend the environment when you do a call..  no closures
20:11:48 <lispy> so the environment is throw away right?
20:12:05 <lispy> when the function returns i just toss the part that extended the previous environment?
20:12:26 <wagle> a function using the application time environment, not the definition time environment
20:12:36 <lispy> and no closures makes implementation easier right?
20:13:06 <wagle> binding lookups are O(n), for n = call-chain length
20:13:10 <lispy> oh, so that's why it's called dynamic, because i deal with environments at run time
20:13:55 <lispy> i know sicp has a section on interpreters, i wonder if they talk making one with dynamic scope
20:13:58 <wagle> static scoping means you can tell where x is defined by looking at the source
20:14:17 <wagle> dynamic scoping means you have to consider the call graph
20:14:43 <tautologico> dynamic scope is actually easier to implement
20:14:47 <lispy> wagle: so i may want to store a list/heap of hashtables (where the hashtables are my environments) ?
20:14:49 <wagle> dont know about sicp..  eopl should
20:15:07 <lispy> er not heap, but stack
20:15:19 <tautologico> to implement static closure you need to make closures and carry them around
20:15:21 <lispy> @google eopl
20:15:23 <lambdabot> http://www.cs.indiana.edu/eip/eopl.html
20:15:40 <hyrax42> don't think it's free
20:15:42 <wagle> hashtables would be overkill if the average number of arguments is 1
20:15:56 <tautologico> static scoping
20:16:14 <tautologico> you should look at plai too... Programming Languages: Application and Interpretation
20:16:25 <hyrax42> @google plai
20:16:26 <lambdabot> http://www.essentialoils.org/plai.htm
20:16:30 <hyrax42> lol
20:16:39 <hyrax42> @google Programming Languages: Application and Interpretation
20:16:40 <lambdabot> http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/
20:16:54 <tautologico> that's it... shriram krishnamurti, I believe
20:17:02 <tautologico> it's good
20:17:29 <wagle> i havent read that one yet
20:18:06 <tautologico> in some points I prefer it than eopl
20:19:01 <lispy> oh, man the safari pdf viewer isn't very nice
20:19:32 <gzl> there's a browser plugin you can get
20:19:40 <gzl> what's wrong with it? (i've never used it)
20:20:11 <lispy> you can't navigate with the mouse, and you have to bring up the mouse menu to zoom in/out
20:20:33 <gzl> navigate with the mouse?
20:20:35 <gzl> like, drag the image?
20:20:37 <lispy> but the mouse menu also has an option to open in preview which is better
20:20:41 <lispy> yea
20:20:52 <gzl> you can do that with the third party plugin
20:22:27 <lispy> huh, okay
20:22:40 * lispy listens to japanese music and wonders what it says
20:23:57 <wagle> its interesting to listen to a sound redone in japanese that you've heard dozens of times in english
20:25:22 <lispy> (define (foo x) ...) == (defun foo (x) ...) ?
20:25:35 <lispy> is that right, where the left is scheme and the right is lisp?
20:25:37 <wagle> lispy: most likely
20:25:52 <wagle> i havent done lisp in a very long time
20:25:52 <lispy> cool, thanks
20:26:27 <tautologico> lispy: that's correct
20:26:31 <lispy> i've never done scheme :)
20:27:14 <tautologico> scheme is cool
20:27:39 <wagle> http://www.amazon.com/exec/obidos/tg/detail/-/B000003SZU/qid=1120966033/sr=8-2/ref=pd_bbs_ur_2/102-1687799-2966558?v=glance&s=music&n=507846
20:27:43 <wagle> 8)
20:33:56 <sh10151> there are too many cool programming languages
20:34:03 <sh10151> i can't get good with any of them
20:34:43 <gzl> so pick one and stick with it for a while
20:34:45 <wagle> after the first 20 or 30, they get easier
20:35:03 <lispy> heh
20:35:08 <lispy> wagle: yeah
20:35:20 <lispy> wagle: man, that's so true....and yet...it just sounds wrong
20:35:39 <lispy> @google site:norvig.com 21
20:35:41 <lambdabot> http://www.norvig.com/21-days.html
20:35:47 <lispy> sh10151: read that link
20:35:56 <wagle> good one
20:36:35 <lispy> that essay change the way i look at life
20:36:53 <wagle> ooo..  wikipedia dead!
20:37:16 <sh10151> I don't want to pick one and stick with it
20:37:22 <sh10151> the grass is always greener
20:37:37 <sh10151> when I am in perl I wish I were in python
20:37:47 <sh10151> when I am in python I wish I were in scheme
20:37:54 <sh10151> when I am in scheme I wish I were in haskell
20:37:56 <sh10151> etc
20:38:29 <lispy> definitely
20:38:51 <Khisanth> well just use haskell then :)
20:38:55 <tautologico> well... you must eliminate languages that are similar or that don't add nothing to what you already know
20:39:05 <tautologico> if you know scheme, why bother learning python ?
20:39:19 <lispy> oh, and perl, you can eleminate it on general principle :)
20:39:31 <MachinShin> not much demand for scheme programmers :)
20:39:38 <tautologico> well, maybe a syntax for generators... but then go ahead and learn Icon, it would be more enlightening :)
20:40:23 <lispy> that's another thing, as a programmer  you can pickup and forget syntax like nobodies business.  But paradigms and concepts will stay without
20:40:29 <sh10151> then when I am in haskell I wish it were a language that any coworker of mine would appreciate
20:40:38 <sh10151> leaving me wishing for java or perl in order to be a team player
20:40:39 <SamB> python will teach you how to do stuff without needing macros every time you turn around?
20:40:39 <sh10151> :)
20:40:39 <lispy> s/without/with you/
20:41:37 <lispy> yeah, there is a weird social/psychological factor to what people program in
20:41:44 <lispy> i'd love to understand it better
20:41:57 <Khisanth> learn one language very well, write everything in it and then just write converters for other languages :)
20:42:10 <SamB> "JUST"?
20:42:14 <lispy> hehe
20:43:00 <wagle> my helloworld program for each new laguage i learn is a scheme interpreter...  8)
20:43:07 <lispy> sh10151: actually, Khisanth has an excellent point. Use a language you know to write a compiler/interpreter for a language you want to learn.  You'll be an expert in no time.
20:43:26 <MachinShin> interesting interpertation of 'no time' :P
20:43:34 <lispy> hehe
20:43:42 <lispy> i meant, you'll have no time
20:43:48 <tautologico> hehehe
20:43:51 <wagle> scheme is easy
20:43:53 <lispy> you'll be an expert with no free time
20:44:16 <wagle> if you are a pure functional programmer, you dont bellieve in time anyway..  8-p
20:44:49 <lispy> wagle: ya, just do everything in thunks
20:44:57 <MachinShin> wagle: lol
20:45:37 <wagle> GAH..  this stupid darwinports install is installing EVERYTHING
20:45:57 <wagle> (but going at it for 5 hours now..  i wanna go home
20:46:05 <wagle> s/but/been/
20:46:09 <wagle> )
20:46:48 <wagle> its eaten 400M of disk too
20:50:00 <lispy> wagle: what did you try to install?
20:50:12 <wagle> planner
20:54:52 <gzl> I was about to ask what planner was
20:55:03 <wagle> 49 packages so far
20:55:19 <wagle> gzl gannt charts
20:55:26 <gzl> oh, good
20:55:34 <gzl> so the question wasn't completely stupid
20:55:43 <gzl> I would have felt silly if it was just a planner :)
20:55:48 <wagle> hahah
