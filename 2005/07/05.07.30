00:00:58 <Enveigler_> This one has less syntax and is possibly clearer: liftM words $ readFile "route.dat"
00:01:41 <lispy_> yup, except for the $ it's nice
00:01:54 <lispy_> liftM words (readFile "route.dat")
00:02:02 * lispy_ prefers explicit parens
00:02:43 * Enveigler_ is undecided. The whole darn syntax just looks weird to me.
00:16:39 <Enveigler_> @type [a:b] <- System.getArgs
00:16:41 <lambdabot> bzzt
00:16:58 <Enveigler_> @type [a,b] <- System.getArgs
00:16:59 <lambdabot> bzzt
00:17:11 <lispy> @type getArgs
00:17:13 <lambdabot> bzzt
00:17:19 <Enveigler_> @type System.getArgs
00:17:21 <lambdabot> IO [String]
00:17:49 <lispy> @type do [a:b] <- System.getArgs
00:17:50 <lambdabot> bzzt
00:18:17 <lispy> i think you're going to have to use do as <- System.getArgs
00:18:34 <Enveigler_> @type do{ [a:b] <- System.getArgs; return (a,b) }
00:18:35 <lambdabot> IO (Char, [Char])
00:18:46 <lispy> ah cool
00:18:51 <Enveigler_> @type do{ [a,b] <- System.getArgs; return (a,b) }
00:18:52 <lambdabot> IO (String, String)
00:19:44 <Enveigler_> The difference between [a,b] and [a:b] is real subtle.
00:20:16 <lispy> well, [a:b] is a list of lists and [a,b] is a list with two elements
00:20:49 <lispy> @type a:b
00:20:50 <lambdabot> bzzt
00:20:56 <Enveigler_> but most places a list with two elements is [a b] (no commas)
00:20:59 <lispy> @type [a:b]
00:21:00 <lambdabot> bzzt
00:21:12 <lispy> @type [1:[]]
00:21:14 <lambdabot> forall a. (Num a) => [[a]]
00:21:37 <lispy> Enveigler_: a list always has commas between the elements
00:21:58 <lispy> well, either that or they use (:)
00:23:10 <lispy> @type liftM zipWith (,) System.getArgs
00:23:11 <lambdabot> bzzt
00:23:27 <lispy> @type liftM (zipWith (,)) System.getArgs
00:23:28 <lambdabot> bzzt
00:23:43 <lispy> @type zipWith (,) [1..3]
00:23:44 <lambdabot> forall a b.
00:23:44 <lambdabot>         (Num a, Enum a) =>
00:23:44 <lambdabot>         [b] -> [(a, b)]
00:24:12 <lispy> @type liftM (foldl1 (,)) System.getArgs
00:24:14 <lambdabot> bzzt
00:24:23 <lispy> @tpe foldl1 (,)
00:24:24 <lambdabot> bzzt
00:24:36 <lispy> @type foldl1
00:24:38 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
00:24:48 <lispy> @type (,)
00:24:49 <lambdabot> forall b a. a -> b -> (a, b)
00:24:57 <Enveigler_> Right. It arguments that don;t have commas ;)
00:25:25 <lispy> @type curry
00:25:27 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
00:26:03 <Enveigler_> @type do{ [a:b] <- System.getArgs; return (a,b) }
00:26:04 <lambdabot> IO (Char, [Char])
00:26:16 <Enveigler_> @type do{ [a,b] <- System.getArgs; return (a,b) }
00:26:18 <lambdabot> IO (String, String)
00:27:44 <lispy> @type mapM print System.getArgs
00:27:45 <lambdabot> bzzt
00:28:09 <lispy> @type System.getArgs
00:28:11 <lambdabot> IO [String]
00:28:13 <lispy> @type mapM
00:28:14 <lambdabot> forall b (m :: * -> *) a.
00:28:14 <lambdabot>    (Monad m) =>
00:28:14 <lambdabot>    (a -> m b) -> [a] -> m [b]
00:28:48 <lispy> @type print
00:28:49 <lambdabot> forall a. (Show a) => a -> IO ()
00:29:16 <lispy> @type liftM print System.getArgs
00:29:17 <lambdabot> bzzt
00:29:20 <lispy> hmm...
00:29:58 <lispy> @type print >>= System.getArgs
00:29:59 <lambdabot> bzzt
00:30:26 <Enveigler_> @type System.getArgs >>= print
00:30:27 <lambdabot> IO ()
00:30:33 <lispy> ah
00:30:54 <Enveigler_> @type print =<< getArgs
00:30:55 <lambdabot> bzzt
00:31:07 <Enveigler_> @type print ==< getArgs
00:31:08 <lambdabot> bzzt
00:31:20 <lispy> @type print =<< System.getArgs
00:31:21 <lambdabot> IO ()
00:31:24 <Enveigler_> I'm sure I saw one that fed the other way
00:31:45 <Enveigler_> That's the one
00:32:04 <lispy> so, main = print =<< System.getArgs is essentially the echo command
00:32:22 <Enveigler_> I guess...
00:32:35 <lispy> hmm...
00:33:13 <lispy> main = (putStr . show) =<< System.getArgs is closer, but we may need to drop the first element of the list
00:33:20 <lispy> @eval drop 1 [1..3]
00:33:25 <lambdabot> [2,3]
00:33:59 <Enveigler_> C:\ghc\ghc-6.4\code>main fred bil 123
00:33:59 <Enveigler_> ["fred","bil","123"]
00:34:28 <lispy> @type drop =<< System.getArgs
00:34:30 <lambdabot> bzzt
00:34:49 <lispy> @type liftM (drop 1) System.getArgs
00:34:50 <lambdabot> bzzt
00:35:03 <ozone> @tupe =<<
00:35:05 <lambdabot> bzzt
00:35:07 <lispy> @type leftM
00:35:07 <ozone> @type =<<
00:35:08 <lambdabot> bzzt
00:35:09 <lambdabot> bzzt
00:35:14 <ozone> that might be why :)
00:35:19 <lispy> @type liftM
00:35:21 <lambdabot> bzzt
00:35:42 <lispy> @type Control.Monad.liftM
00:35:43 <lambdabot> forall r (m :: * -> *) a1.
00:35:43 <lambdabot>         (Monad m) =>
00:35:43 <lambdabot>         (a1 -> r) -> m a1 -> m r
00:36:12 <lispy> @type Control.Monad.liftM (drop 1) System.getArgs
00:36:13 <lambdabot> IO [String]
00:36:59 <lispy> @eval Control.Monad.liftM (drop 1) [1..4]
00:37:01 <lambdabot> <Plugins.Eval>:1:
00:37:01 <lambdabot>   No instances for (Num [a], Enum [a])
00:37:01 <lambdabot>   arising from the literal `4'
00:37:22 <lispy> @eval Control.Monad.liftM (drop 1) [1..4::Int]
00:37:24 <lambdabot> Couldn't match `[a]' against `Int'
00:37:43 <palomer> you silly goose
00:37:45 <lispy> @eval Control.Monad.liftM (drop 1) ([1..4]::[Int])
00:37:46 <lambdabot> Couldn't match `[a]' against `Int'
00:37:51 <lispy> what am i doing wrong?
00:38:04 <lispy> oh, right
00:38:12 <Enveigler> main = mapM_ print =<< System.getArgs
00:38:15 <lispy> @eval Control.Monad.liftM (drop 1) [[1..4]]
00:38:17 <lambdabot> [[2,3,4]]
00:39:33 <lispy> @type mapM_ print =<< System.getArgs
00:39:34 <lambdabot> IO ()
00:40:22 <lispy> @type mapM_ print =<< Control.Monad.liftM (drop 1) System.getArgs
00:40:24 <lambdabot> IO ()
00:40:31 <lispy> heh, that's echo
00:40:39 <lispy> oh, wait
00:40:58 <lispy> @type mapM_ (putStr . show) =<< Control.Monad.liftM (drop 1) System.getArgs
00:41:00 <lambdabot> IO ()
00:45:26 <Enveigler> Do you need to drop the 1st arg?
00:45:30 <lispy> nope
00:45:33 <lispy> i was wrong about that
00:46:21 <lispy> @hoogle foldM
00:46:23 <lambdabot> Monad.foldM :: Monad a => ((b -> c -> (a b)) -> b -> [c] -> (a b))
00:46:27 <Enveigler> I can get them 1 per line (with "s) but can work out how to map (++) over them
00:46:40 <lispy> concat
00:46:45 <lispy> @type concat
00:46:46 <lambdabot> forall a. [[a]] -> [a]
00:47:35 <lispy> @type foldM (++) [] System.getArgs
00:47:36 <lambdabot> bzzt
00:47:42 <lispy> @type foldM
00:47:44 <lambdabot> bzzt
00:47:53 <lispy> @type Monad.foldM (++) [] System.getArgs
00:47:54 <lambdabot> bzzt
00:48:08 <lispy> @type Monad.foldM
00:48:10 <lambdabot> forall a (m :: * -> *) b.
00:48:10 <lambdabot>      (Monad m) =>
00:48:10 <lambdabot>      (a -> b -> m a) -> a -> [b] -> m a
00:48:27 <lispy> @type Monad.foldM (++)
00:48:29 <lambdabot> bzzt
00:49:58 <lispy> @type Control.Monad.liftM (++)
00:49:59 <lambdabot> forall a (m :: * -> *).
00:49:59 <lambdabot>           (Monad m) =>
00:49:59 <lambdabot>           m [a] -> m ([a] -> [a])
00:50:55 <lispy> @hoogle m [a] -> m a
00:50:56 <lambdabot> Prelude.concat :: ([[a]] -> [a])
00:50:56 <lambdabot> Monad.join :: Monad a => ((a (a b)) -> (a b))
00:50:56 <lambdabot> Monad.msum :: MonadPlus a => ([(a b)] -> (a b))
00:51:51 <Enveigler> I can't believe It's taking 20+ attempts to emulate echo :)
00:52:04 <lispy> @eval join [[1..3],[4..5]]
00:52:06 <lambdabot> [1,2,3,4,5]
00:52:12 <lispy> Enveigler: :)
00:53:02 <lispy> @type Monad.join System.getArgs
00:53:03 <lambdabot> bzzt
00:54:10 <Enveigler> I just got "      Expected type: IO (IO (IO a))" WTF?
00:54:15 <lispy> @type Monad.msum System.getArgs
00:54:16 <lambdabot> bzzt
00:54:33 <lispy> Enveigler: not sure
00:54:42 <lispy> @hoogle m [a] -> m b
00:54:44 <lambdabot> Prelude.concat :: ([[a]] -> [a])
00:54:44 <lambdabot> Monad.join :: Monad a => ((a (a b)) -> (a b))
00:54:44 <lambdabot> Monad.msum :: MonadPlus a => ([(a b)] -> (a b))
00:55:16 <Enveigler> @type (=<<)
00:55:18 <lambdabot> forall b (m :: * -> *) a.
00:55:18 <lambdabot>    (Monad m) =>
00:55:18 <lambdabot>    (a -> m b) -> m a -> m b
00:55:26 <lispy> @hoogle IO [[a]] -> IO [a]
00:55:27 <lambdabot> No matches, try a more general search
00:55:44 <lispy> @hoogle m [[a]] -> m [a]
00:55:45 <lambdabot> Prelude.concat :: ([[a]] -> [a])
00:55:45 <lambdabot> Monad.join :: Monad a => ((a (a b)) -> (a b))
00:55:45 <lambdabot> Monad.msum :: MonadPlus a => ([(a b)] -> (a b))
00:57:09 <Enveigler> @type (>>-)
00:57:11 <lambdabot> bzzt
00:57:14 <Enveigler> @type (>>=)
00:57:16 <lambdabot> forall (m :: * -> *) b a.
00:57:16 <lambdabot>    (Monad m) =>
00:57:16 <lambdabot>    m a -> (a -> m b) -> m b
00:58:08 <Enveigler> @index (a -> m b)
00:58:08 <lambdabot> bzzt
00:58:34 <Enveigler> @hoogle (a -> m b)
00:58:35 <lambdabot> Prelude.return :: Monad a => (b -> (a b))
00:58:35 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => (a -> b)
00:58:35 <lambdabot> Prelude.fail :: Monad a => (String -> (a b))
00:59:40 <Enveigler> Seeya lispy
00:59:49 <Enveigler> $
00:59:55 <lispy> see ya
01:03:37 <lispy> @pl \x y -> x ++ " "++ y
01:03:38 <lambdabot> (. (' ' :)) . (++)
01:06:06 <lispy> got it
01:06:15 <lispy> (putStr =<< Control.Monad.liftM (foldl1 ((.(' ':)).(++))) System.getArgs) >> putStrLn ""
01:06:52 <lispy> the last new line may not be needed....
01:14:55 <lispy> @hoogle [a] -> Bool
01:14:56 <lambdabot> Prelude.null :: ([a] -> Bool)
01:14:56 <lambdabot> Prelude.or :: ([Bool] -> Bool)
01:14:56 <lambdabot> Prelude.and :: ([Bool] -> Bool)
01:22:11 <lispy> @type when
01:22:13 <lambdabot> bzzt
01:22:17 <lispy> @hoogle when
01:22:17 <lambdabot> Monad.when :: Monad a => (Bool -> (a ()) -> (a ()))
01:28:32 <lispy> @hoogle m Bool -> m a -> ma -> ma
01:28:32 <lambdabot> Monad.liftM3 :: Monad a => ((b -> c -> d -> e) -> (a b) -> (a c) -> (
01:28:32 <lambdabot> a d) -> (a e))
01:28:44 <lispy> @hoogle m Bool -> m a -> m a -> m a
01:28:45 <lambdabot> Monad.liftM3 :: Monad a => ((b -> c -> d -> e) -> (a b) -> (a c) -> (
01:28:45 <lambdabot> a d) -> (a e))
01:28:45 <lambdabot> Prelude.zipWith3 :: ((a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d])
01:34:41 <xerox> back home!
01:34:53 <lispy> @type /=
01:34:54 <lambdabot> bzzt
01:34:59 <lispy> @type (/=)
01:35:00 <lambdabot> forall a. (Eq a) => a -> a -> Bool
01:36:46 <lispy> @pl \x -> when (not (null x)) ((putStr =<< liftM (foldl1 ((.(' ':)).(++))) x) >> when (x !! 0 /= "-n") (putStrLn ""))
01:36:48 <lambdabot> liftM2 when (not . null) (liftM2 (>>) ((putStr =<<) . fmap (foldl1 ((
01:36:48 <lambdabot> . (' ' :)) . (++)))) (flip when (putStrLn []) . ("-n" /=) . (!! 0)))
01:37:22 <lispy> @pl \x -> when (not (null x)) ((putStr =<< liftM (foldl1 ((.(' ':)).(++))) (return x)) >> when (x !! 0 /= "-n") (putStrLn ""))
01:37:24 <lambdabot> liftM2 when (not . null) (liftM2 (>>) (putStr . foldl1 ((. (' ' :)) .
01:37:24 <lambdabot> (++))) (flip when (putStrLn []) . ("-n" /=) . (!! 0)))
01:44:04 <lispy> @pl \x -> when (not (null x)) ((putStr =<< liftM (foldl1 ((.(' ':)).(++))) (return x)) >> when (x !! 0 /= "-n") (putStrLn ""))
01:44:06 <lambdabot> liftM2 when (not . null) (liftM2 (>>) (putStr . foldl1 ((. (' ' :)) .
01:44:06 <lambdabot> (++))) (flip when (putStrLn []) . ("-n" /=) . (!! 0)))
01:45:25 <lispy> @type liftM2 when (not . null) (liftM2 (>>) (putStr . foldl1 ((. (' ' :)) . (++))) (flip when (putStrLn []) . ("-n" /=) . (!! 0)))
01:45:27 <lambdabot> bzzt
01:46:07 <lispy> @type Control.Monad.liftM2 Monad.when (not . null) (Control.Monad.liftM2 (>>) (putStr . foldl1 ((. (' ' :)) . (++))) (flip Monad.when (putStrLn []) . ("-n" /=) . (!! 0)))
01:46:08 <lambdabot> bzzt
01:48:39 <xerox> Do you know of any Haskell related book by O'Reilly?
01:50:54 <lispy> @pl \x -> (when (not (null x)) ((putStr =<< liftM (foldl1 ((.(' ':)).(++))) (return x)) >> when (x !! 0 /= "-n") (putStrLn "")))
01:50:57 <lambdabot> liftM2 when (not . null) (liftM2 (>>) (putStr . foldl1 ((. (' ' :)) .
01:50:57 <lambdabot> (++))) (flip when (putStrLn []) . ("-n" /=) . (!! 0)))
01:52:01 <lispy> hmm...that pl code is wrong
01:56:45 <vegai> obfuscated code contests will be too easy with @pl
02:00:50 <jyp>  @ yaow
02:01:05 <jyp> @yaow !!!
02:01:06 <lambdabot> -- I have seen the FUN --
02:01:47 <xerox> No O'Reilly Haskell books it seems.  Hmpf.
02:02:22 <lispy> can you have multiple imports on one line?
02:02:34 <lispy> import Foo, Bar
02:02:36 <lispy> that sort of thing?
02:03:06 <xerox> Dunno really.
02:03:11 <jyp> I think not
02:03:23 <jyp> imoprt Foo; import Bar
02:03:49 <lispy> ah, nice
02:04:04 <lispy> my echo implementation is only 3 lines
02:04:59 <lispy> heh, but i just found a bug
02:07:16 <jyp> Makes me think ... smallest quine I found in haskell is 50 chars only
02:07:37 <jyp> Anyone knows something smaller? In any language?
02:08:14 <lispy> i saw as asm program that returned 42 that was only a few bytes when complied
02:08:26 <lispy> but that's sort of different i guess
02:08:48 <lispy> it was actually smaller than elf headers should be
02:09:06 <jyp> I guess :)
02:09:16 <lispy> the author had cleverly reused some segments of code as data :)
02:09:56 <jyp> There's that 4k demo that implemented a whole 3d rendering engine :)
02:10:07 <lispy> heh
02:10:14 <lispy> people do some crazy stuff
02:10:44 <jyp> indeed
02:15:14 <Enveigler> jyp: A perl quine in 4 chars
02:15:25 <Enveigler> s/4/34/
02:15:34 <xerox> perl one
02:15:43 <xerox> <Interrupted by Enveigler>
02:16:24 <Enveigler> seek DATA,0,0;print<DATA>;__DATA__
02:17:28 <xerox>  $_=q;eval
02:18:31 <xerox> Sample quine in HQ9+:
02:18:32 <xerox> Q
02:18:36 * xerox O_o
02:19:09 <xerox> http://www.absoluteastronomy.com/encyclopedia/h/hq/hq9_plus1.htm -- oh, heh.
02:22:08 <Enveigler> xerox: I don't get the $_=q;eval thing?
02:25:12 <lispy> @pl \a b -> if x !! 0 /= "-n" then putStrLn (fold1 (\x y -> x++" "++y) a) else putStr (foldl1 (\x y -> x++" "++y) b)
02:25:14 <lambdabot> (. (putStr . foldl1 ((. (' ' :)) . (++)))) . if' (x !! 0 /= "-n") .
02:25:14 <lambdabot> putStrLn . fold1 ((. (' ' :)) . (++))
02:26:04 <lispy> @hoogle if'
02:26:04 <lambdabot> Prelude.undefined :: a
02:26:04 <lambdabot> Prelude.minBound :: Bounded a => a
02:26:04 <lambdabot> Prelude.maxBound :: Bounded a => a
02:27:25 <lispy> well, this version is 7 lines and it doesn't have the bug that the last version had
02:29:08 <lispy> heh, it's not really readable, but i used {} and ; to make it 2 lines :)
02:33:45 <Enveigler> @index fold1
02:33:46 <lambdabot> bzzt
02:34:16 <Enveigler> @type fold1
02:34:17 <lambdabot> bzzt
02:34:18 <lispy> @hoogle foldl1
02:34:19 <lambdabot> Prelude.foldl1 :: ((a -> a -> a) -> [a] -> a)
02:34:28 <lispy> there is an l
02:34:32 <Enveigler> ah!
02:34:40 <xerox> Enveigler: me neither.
02:34:49 <xerox> @hoogle fold
02:34:50 <lambdabot> Prelude.foldl1 :: ((a -> a -> a) -> [a] -> a)
02:34:50 <lambdabot> Prelude.foldr1 :: ((a -> a -> a) -> [a] -> a)
02:34:50 <lambdabot> Prelude.foldr :: ((a -> b -> b) -> b -> [a] -> b)
02:34:51 <lispy> @eval foldl1 (+) [1..4]
02:34:52 <lambdabot> 10
02:35:12 <lispy> it assums that the first value should be the head of the list
02:36:36 <Enveigler> @eval foldl (+) [1..4]
02:36:38 <lambdabot> <Plugins.Eval>:1:
02:36:38 <lambdabot>   No instances for (Show ([[t]] -> [t]), Num [t])
02:36:38 <lambdabot>   arising from use of `show'
02:36:51 <Enveigler> @eval foldl (+) 1, [1..4]
02:36:52 <lambdabot> <Plugins.Eval>:1:
02:36:52 <lambdabot>   No instance for (Show ([b] -> b))
02:36:52 <lambdabot>   arising from use of `show'
02:36:58 <lispy> s/,//
02:37:04 <Enveigler> @eval foldl (+) 1  [1..4]
02:37:05 <lambdabot> 11
02:37:13 <Enveigler> @eval foldl (+) 0  [1..4]
02:37:14 <lambdabot> 10
02:37:24 <Enveigler> @type foldl
02:37:25 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:37:33 <Enveigler> @type foldl1
02:37:34 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
02:37:56 <lispy> Enveigler: i finally got the echo implementation: import Control.Monad; import System; main = do { args <- getArgs; when (not (null args)) (do { arg <- return (drop 1 args); if args !! 0 /= "-n" then putStrLn (foldl1 (\x y -> x++" "++y) args) else putStr (foldl1 (\x y -> x++" "++y) arg) })}
02:38:13 <Enveigler> Yesh!
02:38:36 <lispy> i had to use the do syntax tho, which i was hoping to avoid
02:38:45 <lispy> and i was hoping to makeit pointfree
02:38:56 <lispy> (not caring about readability of course)
02:40:19 <Enveigler> try this
02:40:21 <Enveigler> import System
02:40:21 <Enveigler> import Monad (liftM, foldM, join)
02:40:21 <Enveigler> main = print =<< Monad.liftM (foldl1 (\x y -> x++" "++y))  System.getArgs
02:41:10 <lispy> most of my code is to handle the case when someone uses the -n command line switch
02:42:00 <Enveigler> true.
03:04:59 <Enveigler> @pl (\x y -> x++" "++y)
03:05:00 <lambdabot> (. (' ' :)) . (++)
03:06:10 <Enveigler> @pl (foldl1 (\x y -> x++" "++y))
03:06:11 <lambdabot> foldl1 ((. (' ' :)) . (++))
03:24:25 <vikasg> magnitude 1:+1 ==> 1.0 :+ 1.0
03:24:31 <vikasg> what's happening?
03:24:44 <vikasg> isn't magnitude supposed to return a Float?
03:26:23 <vikasg> @type magnitude
03:26:25 <lambdabot> bzzt
03:26:36 <vikasg> @type Data.Complex.magnitude
03:26:37 <lambdabot> forall a.
03:26:37 <lambdabot>          (RealFloat a) =>
03:26:37 <lambdabot>          Data.Complex.Complex a -> a
03:46:33 * xerox does a little dance for his new skateboard just arrived
03:50:16 <astrolabe> Other than the book ' purely functional data structures', does anyone know any references for data structures in a functional language? (a web ref would be nice)
03:54:16 <Heffalump> have you looked if any of Okasaki's papers are online?
03:55:02 <astrolabe> Heffalump: No.  That's a good idea.
03:58:58 <boegel> hello earthlings !
03:59:35 <xerox> http://img218.imageshack.us/my.php?image=300720050254ft.jpg
04:06:17 <vikasg> once again, why does magnitude 1:+1 return 1.0 :+ 1.0?
04:11:25 <astrolabe> vikasg:  Maybe you need to put parentheses round the argument.
04:11:51 <vikasg> oh, right
04:12:00 <vikasg> thanks
04:12:29 <shapr> @YOw !
04:12:30 <lambdabot> I'm wearing PAMPERS!!
04:13:00 <astrolabe> Hi shapr.
04:13:03 <boegel> yo shapr
04:13:19 <astrolabe> Do you know where I can read about data structures for fp?
04:13:39 <musasabi> astrolabe: the Okasaki book.
04:14:02 <shapr> good morning!
04:14:06 <musasabi> morning shapr
04:14:06 <astrolabe> musasabi_: thanks.  It seems to be out of print though.
04:14:49 <musasabi> astrolabe: you can get it from lots of places - http://froogle.google.com/froogle?q=okasaki%20purely%20functional&hl=en&lr=&sa=N&tab=wf
04:15:06 <astrolabe> Is there a STL for haskell?
04:15:25 <astrolabe> musasabi_:thanks.
04:15:41 * boegel is showing off his brown tan
04:15:57 * jyp whstiles
04:16:07 <astrolabe> boegel:  have you had your viva?
04:16:15 <boegel> astrolabe: viva ?
04:16:41 <astrolabe> Were you doing a PhD, or am I misremembering?
04:17:01 <boegel> I'm not sure what you mean by 'viva' ... never heard of it
04:17:38 <astrolabe> It is a kind of exam by conversation.  I guess it means 'live'
04:17:58 <astrolabe> Also known as a defence in some places.
04:18:21 <boegel> oh, no, I haven't even started working yet :)
04:18:49 <boegel> I start on Monday, and the exam for my scholarship is in September I think
04:18:49 <astrolabe> Ah ok :)
04:18:51 <shapr> astrolabe: There's also the Rabhi & Lapalm book - http://www.iro.umontreal.ca/~lapalme/Algorithms-functional.html
04:19:20 <shapr> boegel: Hey! Will you have time to finish your HRay article in August?
04:19:33 <boegel> shapr: eh,I believe I will
04:19:54 <boegel> I'm not home until 6.30pm orso, but I think I should find some time somewhere :)
04:20:14 <boegel> I'm still getting used to my computer, haven't seen one in over 3 weeks
04:20:20 <shapr> wow!
04:20:22 <boegel> feels quite strange, a mouse in you hand :)
04:20:38 * astrolabe believes he is the worst haskell programmer in the world.  Long rambling functions... :(
04:20:53 <musasabi> shapr: Is the Rabhi & Lapalm a must have book - and how is it as compared to other alternatives?
04:21:06 <boegel> you guys didn't miss me ? :(
04:21:09 <boegel> ;)
04:21:29 <astrolabe> shapr: thanks.
04:21:39 <astrolabe> boegel:  Of course we did!
04:22:06 * boegel read his mail twice while on vacation, but only removed spam
04:22:09 <shapr> boegel: Yeah, we talked about you, but only nice things ;-)
04:22:18 * boegel checks the logs :p
04:22:57 <shapr> musasabi: I don't know, that's the only book I have. I'd like to get Okasaki's book at some point.
04:23:24 <astrolabe> shapr:  What do you think of it?
04:23:42 <shapr> I wrote a review of it on sequence.complete.org, I'll get the url.
04:24:29 <shapr> Here's my short review - http://sequence.complete.org/node/17
04:24:46 <astrolabe> Excellent, thanks.
04:24:49 <boegel> have you guys seen Itkovian lately ?
04:24:54 <boegel> @seen Itkovian
04:24:55 <lambdabot> I saw Itkovian leaving #haskell 2 days, 22 hours, 1 minute and 33
04:24:55 <lambdabot> seconds ago.
04:25:11 <boegel> hmm, almost 3 days non-active
04:25:19 <shapr> He must be sleeping
04:25:51 <boegel> I think he's on holiday too or something
04:26:02 <boegel> bummer, I'd like to ask him some practical stuff for Monday
04:31:04 <astrolabe> Hmmm It looks as though I'm going to 'have' to get Okasaki and Rabhi&Lapalme.  Does anyone have any general haskell recommendations for me while I'm at it?  I've read 'The haskell school of expression', and I've got the report.
04:31:07 <shapr> Have you all read the Cisco Lynn article?
04:31:57 <xerox> Point the remainder of us :-)
04:32:23 <astrolabe> No,  I've got 26 firefoxs running, and they all have multiple tabs!
04:32:29 <shapr> astrolabe: I learned the most from collaborations with others. When I worked on lambdabot with Pseudonym and others, and on ICFP with Igloo and Heffalump, I learned how others do things. Those are the best lessons, imho.
04:32:59 <xerox> Thermal 1: ok, 53.0 degrees C  sob.
04:33:59 <shapr> xerox: Cisco sued Michael Lynn, seems they got a permanent injunction - http://it.slashdot.org/article.pl?sid=05/07/29/1850234&tid=99&tid=172&tid=123&tid=218
04:36:25 <xerox> Gee.
04:37:17 <shapr> See, I think Cisco should use Haskell in their routers, then they'd be much safer.
04:37:27 <musasabi> astrolabe: I think Rabhi&Lapalme will be better if you want Haskell - the Okasaki book is about general FP.
04:38:05 <xerox> shapr: what do you think should not use Haskell? <grin>
04:38:08 <astrolabe> musasabi: Thanks.  I guess the ideas are pretty transferable though?
04:38:30 <shapr> xerox: I can't think of anything :-)
04:40:12 <astrolabe> I'm amazed that people can't seem to design systems without vulnerabilities.  It probably shows I don't know what I'm talking about.
04:40:12 * boegel leaves for a while
04:42:00 <musasabi> astrolabe: yes, that is quite easy.
04:46:32 <Enveigler> @docs Observe
04:46:33 <lambdabot> Observe not available
04:46:42 <Enveigler> @index observe
04:46:43 <lambdabot> bzzt
04:46:50 * shapr observes Enveigler
04:46:50 <xerox> @hoogle observe
04:47:04 * Enveigler hides
04:47:12 <xerox> shapr: I got my new vehicle!
04:47:26 <xerox> http://img218.imageshack.us/my.php?image=300720050254ft.jpg
04:47:35 <Enveigler> @google haskell Observe
04:47:36 <lambdabot> http://cvs.haskell.org/Hugs/pages/users_guide/observe.html
04:48:46 <Enveigler> Is Observe only for hugs?
04:52:02 <shapr> xerox: w00, tasty!
05:00:26 <reffie> hax!
05:04:58 <Enveigler> I found the source for Observe.lhs (for ghc 5). What do I have to do to make it usable?
05:08:00 <Enveigler> @index Util.Observe
05:08:01 <lambdabot> bzzt
05:08:31 <Enveigler> NIH!
06:49:48 <CosmicRay> anyone aware of a text-wrapping tool for haskell?
06:51:10 <astrolabe> Is there one in lambdabot?
06:51:20 <CosmicRay> good suggestion
06:51:21 * CosmicRay checks
06:53:07 <TheHunter> you better not check that one, it's poorly implemented.
06:53:23 <CosmicRay> are you aware of a better one?
06:54:01 <TheHunter> not really, except piping fmt(1)
06:55:51 <CosmicRay> yeah, could do that, but it's inconvenient in this case
06:55:52 <TheHunter> lambdabot's algo is mlines in Lambdabot.hs.
06:55:59 <CosmicRay> yup, I see it there
06:56:26 <CosmicRay> I'll try it and see what happens
06:57:19 <Igloo> You can make one with words and fsep from Text.PrettyPrint I think
06:57:52 <CosmicRay> ahh, is that the key... I was trying to shove a large string into it with text, and it never wrapped
06:59:09 <CosmicRay> I also couldn't figure out how to force it to leave a blank line between paragraphs
07:00:21 <Igloo> $$ text "" $$
07:02:00 <CosmicRay> that is doing something, but it seems that it is wrapping far lower than the line length (the docs for this module are rather poor)
07:02:21 <Igloo> It'll wrap at 80 by default
07:02:31 <Igloo> You'll have to tell it if you want it to be wider or narrower than that
07:02:40 <CosmicRay> it looks like it's wrapping at about 65
07:03:03 <CosmicRay> Prelude Text.PrettyPrint> let d = fsep $ words $ "this is a test asdf qwerkljh asdflkjhqwer lkj asdflk qwerlk asdflkjh qwerlkjh asdflkjh qwerlkjh asdfk qwerasdf"
07:03:12 <CosmicRay> Prelude Text.PrettyPrint> putStrLn $ render d
07:03:12 <CosmicRay> this is a test asdf qwerkljh asdflkjhqwer lkj asdflk qwerlk
07:03:12 <CosmicRay> asdflkjh qwerlkjh asdflkjh qwerlkjh asdfk qwerasdf
07:04:05 <lambdabot> this is a test asdf qwerkljh asdflkjhqwer lkj asdflk qwerlk asdflkjh
07:04:05 <lambdabot> qwerlkjh asdflkjh qwerlkjh asdfk qwerasdf
07:05:03 <Igloo> Maybe it's 72 by default
07:05:21 <CosmicRay> the docs claim it's 100 (!)
07:05:31 <CosmicRay> style :: Style
07:05:31 <CosmicRay> The default style (mode=PageMode, lineLength=100, ribbonsPerLine=1.5)
07:05:47 <Igloo> Hmm, yeah, just saw that
07:06:16 <Igloo> It seems to be wrapping at 100/1.5, actually
07:06:40 <CosmicRay> I had that thought too, but if I set ribbonsPerLine to 1.0, very weird things happen
07:07:02 <CosmicRay> I guess I could try lineLength=112
07:07:24 <CosmicRay> that's more like it
07:43:12 <moea> ok, i'm confused.  i want to generate a random integer inside a given range
07:43:30 <moea> i see references to Random and randomR and StdRandom, but no working code
07:44:10 <Igloo> randomRIO (lower, upper) if you're in the IO monad
07:44:25 <Igloo> Otherwise randomR is similar but you need to give it your generator
07:44:43 <moea> Igloo: sorry, this is my first haskell program, how do i get into the IO monad?
07:46:28 <Igloo> main = do x <- randomRIO (3, 6); print (x :: Int)
07:50:06 <moea> Igloo: thanks, last question -- what is wrong with rand_elem seq = do x <- randomRIO(0, length seq)\nreturn seq !! x
07:50:29 <Igloo> return (seq !! x)
07:50:36 <Igloo> function application binds tightest
07:52:02 <moea> Igloo: thanks - the declaration i have is "rand_elem :: [a] -> a", but i get a "unification would give infinite type" error
07:56:22 <moea> [a] -> IO a seems to fix it
08:15:13 <CosmicRay> does arjan oosting irc?
08:15:46 <Igloo> Yes
08:15:51 <Igloo> As arjanoosting I think
08:15:52 <CosmicRay> do you know his nick?
08:16:01 <CosmicRay> ah, straight forward enough then.
09:03:30 <Fide> hi
09:04:31 <CosmicRay> hi fide
09:08:15 <CosmicRay> hello arjan
09:08:29 <CosmicRay> did you get my e-mail about haxml?
09:09:51 <arjanoosting> yes I did
09:10:19 <CosmicRay> are you looking for a sponsor?
09:10:24 <arjanoosting> the package is quite ready, just waiting for a new version of ghc6 and nhc98 to hit unstable
09:11:11 <arjanoosting> well I think SyntaxNinja will sponsor me
09:11:20 <arjanoosting> he already sponsors DrIFT for me
09:11:22 <CosmicRay> ah, ok, great.
09:12:12 <arjanoosting> but if he is to busy to sponsor me I will let you know
09:12:14 <arjanoosting> :)
09:26:59 <Fide> test (x:xs) (y:ys) = x:y:(test xs ys) == test (x:xs) (y:ys) = [x] ++ [y] ++ test xs ys?
09:29:37 <Igloo> yes
09:38:17 <Fide> == test xs ys = head xs ++ head ys ++ test (tail xs) (tail ys)?
09:38:43 <Fide> there are lot of variations
09:43:49 <Beelsebob> yeh, the question is, can you proove it
09:43:58 <Beelsebob> and actually, that last variation is not equivalent
09:50:49 <Fide> test xs ys = [head xs] ++ [head ys] ++ test (tail xs) (tail ys)
09:51:04 <Beelsebob> also not equivalent
09:51:06 <Fide> but I dislike that using of [] here
09:51:34 <Fide> it works like them obove
09:51:37 <Beelsebob> that will fail with a patern match failure in head if you give it empty list
09:51:40 <Fide> *above
09:51:43 <Beelsebob> the other will fail in test
09:51:50 <Beelsebob> it *works* like those above
09:51:53 <Fide> test :: [Integer] -> [Integer] -> [Integer]
09:51:53 <Fide> test [] ys = ys
09:51:53 <Fide> test xs [] = xs
09:51:53 <Fide> test xs ys = [head xs] ++ [head ys] ++ test (tail xs) (tail ys)
09:51:56 <Fide> ~
09:51:58 <Fide> ~
09:51:59 <Beelsebob> it doesn't work in a different way
09:52:10 <Fide> it works
09:52:20 <Beelsebob> yeh, if you add those two matches to all of them then they are equiv
09:52:23 <xerox> What are you trying to do?
09:52:44 <Beelsebob> interleave by the looks of it
09:53:00 <Fide> zip to lists
09:53:07 <Beelsebob> in as many ways as possible
09:53:11 <Beelsebob> and that isn't zip
09:53:23 <Beelsebob> zip :: [a] -> [b] -> [(a,b)]
09:53:24 <xerox> @type zip
09:53:28 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
09:53:35 <xerox> @type zipWith (:)
09:53:36 <lambdabot> forall a. [a] -> [[a]] -> [[a]]
09:53:37 <Fide> test [1,3,5] [2,4,6] => [1,2,3,4,5,6]
09:53:47 <xerox> Sort of intersperse... how was it called.
09:53:48 <Beelsebob> yes... that's not zip
09:53:54 <xerox> @hoogle [a] -> [a] -> [a]
09:53:55 <lambdabot> Prelude.(++) :: ([a] -> [a] -> [a])
09:53:55 <lambdabot> List.(\\) :: Eq a => ([a] -> [a] -> [a])
09:53:55 <lambdabot> List.union :: Eq a => ([a] -> [a] -> [a])
09:54:02 <Beelsebob> interleave or iintersperse or something
09:54:07 <xerox> @hoogle interleave
09:54:07 <Beelsebob> @hoogle intersperse
09:54:08 <lambdabot> List.intersperse :: (a -> [a] -> [a])
09:54:15 <xerox> Nope.
09:54:26 <Beelsebob> no... but nearly
09:54:48 <Fide> that is zip
09:54:57 <Fide> babelfish told me that
09:54:58 <Beelsebob> no it isn't
09:55:10 <Fide> Reiﬂverschluss = zip
09:55:17 <Beelsebob> @plugs zip [1,3,5] [2,4,6]
09:55:22 <lambdabot> [(1,2),(3,4),(5,6)]
09:55:25 <Beelsebob> see
09:55:27 <Beelsebob> not zip
09:55:34 <xerox> @plugs zipWith (:) [1,3] [2,4]
09:55:35 <lambdabot> <Plugins.Eval>:1:
09:55:35 <lambdabot>   No instance for (Num [a])
09:55:35 <lambdabot>   arising from the literal `4'
09:55:43 <xerox> ^_^
09:55:54 <Fide> it's that in hoses
09:56:23 <Fide> that called zip method in german
09:56:23 <Beelsebob> ?
09:56:30 <smott> transpose?
09:56:36 <Beelsebob> well... it's not zip in the haskell Prelude
09:56:36 <Fide> make 2 lists to one
09:56:41 <Fide> is zip
09:56:54 <Beelsebob> go into hugs and try it
09:56:56 <Beelsebob> it is not zip
09:57:20 <Fide> Main> test [1,3,5] [2,4,6]
09:57:20 <Fide> [1,2,3,4,5,6]
09:57:38 <Beelsebob> yes
09:57:41 <Beelsebob> try zip
09:57:43 <Fide> like a zip
09:57:50 <Beelsebob> and you'll notice that it's different
09:58:16 <Fide> I am not spwak about haskell zip, but zip
09:58:17 <Beelsebob> Main> zip [1,3,5] [2,4,6]
09:58:18 <Beelsebob> [(1,2),(3,4),(5,6)]
09:58:24 <xerox> @pl \xs ys -> concat $ zipWith (\x y -> x:y:[]) xs ys
09:58:26 <lambdabot> (join .) . zipWith ((. return) . (:))
09:58:32 <Fide> and this called zip method
09:58:40 <Beelsebob> pretty much anyone will tell you zip pairs elements
09:58:46 <xerox> @plugs let f = (join .) . zipWith ((. return) . (:)) in f [1,3,5] [2,4,6]
09:58:47 <lambdabot> [1,2,3,4,5,6]
09:58:48 <Beelsebob> a schemer will tell you that
09:58:51 <xerox> ^_^
09:58:59 <Beelsebob> :) xerox
09:59:19 <Beelsebob> I'm worried that you had to use it monadically though
09:59:48 <xerox> @pl \x y -> x:y:[]
09:59:49 <lambdabot> (. return) . (:)
10:00:13 <xerox> @plugs let f = concat . zipWith ((. return) . (:)) in f [1,3,5] [2,4,6]
10:00:14 <lambdabot> Couldn't match `[[a]]' against `[b] -> [c]'
10:00:15 <Beelsebob> @pl
10:00:16 <lambdabot> (line 1, column 1):
10:00:16 <lambdabot> unexpected end of input
10:00:16 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
10:00:16 <lambdabot> expression
10:00:22 <Beelsebob> @help pl
10:00:23 <lambdabot>  @pointless <expr> - play with pointfree code
10:00:28 <Beelsebob> ah, okay
10:00:57 <xerox> ooh-kay.
10:01:20 <Fide> well :)
10:01:28 <xerox> @plugs let f xs ys = concat $ zipWith (\x y -> x ++ [y]) xs ys in f [1,3,5] [2,4,6]
10:01:29 <lambdabot> <Plugins.Eval>:1:
10:01:29 <lambdabot>   No instance for (Num [b])
10:01:29 <lambdabot>   arising from the literal `5'
10:01:52 * xerox should test code better before pasting, sorry
10:02:48 <xerox> @plugs let f xs ys = concat $ zipWith (\x y -> x:[y]) xs ys in f [1,3,5] [2,4,6]
10:02:49 <lambdabot> [1,2,3,4,5,6]
10:02:53 <xerox> Silly me.
10:04:19 <xerox> Fide: any questions?
10:04:27 <Fide> hm?
10:04:45 <Fide> nope, my zipper method works well :)
10:04:56 <xerox> What is it?
10:05:13 <Beelsebob> note... it's a function, not a method
10:05:19 <Beelsebob> there are no objects here
10:06:23 <Fide> sorry, but that called so
10:07:09 <Fide> a method like a zip at hoses
10:07:42 <Fide> zipper method *grml* why is english so difficult to explain such an easy thing
10:10:28 <Fide> Reiﬂschlussverfahren - zipper method -
10:10:43 <Fide> ProcÈdure de tirette
10:17:19 <TheHunter> zip merging?
10:19:49 <xerox> Merging sounds right.
10:22:02 <Fide> but this is known as a method
10:22:23 <xerox> Why do you talk about methods?
10:23:37 <Fide> because this is known as a method in german
10:23:53 <kosmikus> is it? I've never heard of it (except in driving lessons).
10:25:13 <jyp>  nnnnnnnnnnnnnnn(?
10:25:50 <TheHunter> so "zipper method" is the literate translation, but i don't think anybody would understand it.
10:26:41 <TheHunter> @google "zip merging"
10:26:42 <lambdabot> http://www.iam.org.uk/Pressroom/News_Releases/Archive/nr0115.html
10:26:45 <TheHunter> @google "zipper method"
10:26:47 <lambdabot> http://www.henryfordestate.org/zipper.htm
10:27:04 <Fide> yes zip merging makes sense
10:28:40 <xerox> Maybe you're using "method" as in "way to do something" ?
10:29:19 <Fide> yes, because that's the meaning in german
10:31:34 <xerox> I understand.  The word method has a Object-Oriented specific meaning too, which people tend to use often in programming language contexts.
10:32:00 <xerox> Liberally using "specific" ;)
10:32:19 <Fide> hmm in german we makes differences between procedures, functions and methods
10:32:56 <TheHunter> these words can often be used interchangably, though.
10:33:50 <Fide> it must not be Object-oriented if I use methods
10:35:06 <Fide> a function is a method as Well but with a return
10:35:18 <Fide> I mean that for me
10:35:50 <Fide> s/I mean that for me/ it's my optinion
10:46:28 <Enveigler> Anyone know if HOOD (http://www.haskell.org/hood/) is maintained/useful/buildable with GHC 6.4?
10:47:17 <Beelsebob> I don't... but hat-observe serves the same purpose
10:47:24 <Beelsebob> and does build/work with 6.4
10:49:21 <Enveigler> Ah. I look at that. Thanks Beelsebob
10:49:38 <Beelsebob> (part of the hat package obviously)
10:50:38 <Beelsebob> I did have hood working with 6.2 about a year ago
10:50:41 <Beelsebob> so it may well work
11:19:00 <Lemmih> Where are inline primops stored in GHC? The documentation points to nonexistent files.
11:33:45 <Lemmih> Found it.
11:42:57 <autrijus> @pl \c -> return . c =<< arbitrary
11:42:58 <lambdabot> (`fmap` arbitrary)
11:43:06 <autrijus> right. of course!
11:44:04 <autrijus> gen :: (Arbitrary a) => (a -> b) -> Gen b
11:44:04 <autrijus> gen = (`fmap` arbitrary)
12:56:43 <goron> Does Haskell have stuff like ACID Transactions? I.e. does it have support for distributed applications?
13:01:56 <Enveigler_> @pl (\x xs -> xs ++ x )
13:01:57 <lambdabot> flip (++)
13:02:06 <Enveigler_> @type flip
13:02:08 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
13:02:52 <goron> So... this means "no support"?
13:03:10 <jp> What's ACID Transactions?
13:03:27 <musasabi> goron: there are distributed things and there are things which seem to be ACID.
13:03:52 <goron> @google ACID transaction site:wikipdeia.org
13:03:53 <lambdabot> No result found.
13:03:58 <jp> k
13:04:06 <goron> @google ACID transaction site:wikipedia.org
13:04:07 <lambdabot> http://en.wikipedia.org/wiki/ACID
13:04:46 <ibid> atomic, consistent, isolated, durable (unless i remember wrong:)
13:05:00 <xerox> @wikipedia ACID
13:05:03 <lambdabot> http://en.wikipedia.org/wiki/ACID
13:05:15 <goron> xerox: optimizing my code, heh?
13:05:18 <jp> @google Alexander Jacobson ACID
13:05:20 <lambdabot> http://www.haskell.org/pipermail/haskell/2004-April/013949.html
13:05:24 <xerox> Brought to you by.. ;)
13:06:09 <musasabi> goron: I haven't heard of anyone doing two-phase commits or similar in Haskell if you mean that.
13:06:11 <jp> better ;
13:06:20 <jp> @google haskell ACID
13:06:21 <lambdabot> http://www.haskell.org/pipermail/haskell/2004-April/013949.html
13:07:56 <goron> Did anybody already write a Haskell -> Java compiler?
13:08:08 <xerox> @google haskell java jhc
13:08:09 <lambdabot> http://lambda-the-ultimate.org/node/view/655
13:08:18 <goron> xerox: yes, I saw that.
13:08:18 <xerox> I think it's named jhc.
13:08:33 <goron> xerox: I more meant it like: is there still one in development.
13:08:45 <jyp> Jhc targets C atm
13:09:50 <goron> Produces 100% portable ISO C
13:09:58 <goron> jyp: yep
13:10:21 * arjanb is working on a java code generator now
13:10:59 <jyp> arjanb, that's good news :)
13:11:13 <goron> arjanb: A Haskell -> Java code generator?
13:13:32 <arjanb> i only have a proof of concept code generator using a core language as input but i will try to read ghc external core later
13:16:46 <batkins_> haskell -> java?  unclean! unclean!
13:18:08 <jyp> I suppose it's more haskell -> jvm ?
13:18:48 <arjanb> there's very little difference between java and jvm bytecode
13:19:40 <goron> arjanb: what about lazyness?
13:20:47 <jyp> What I meant is, you don't target maintainable java code :)
13:21:10 <jyp> Not a haskell -> java in order to get rid of haskell :p
13:22:43 <arjanb> lazyness can be done but has some indirection overhead (because you can't overwrite objects on the heap in java)
13:24:50 <goron> arjanb: What lazyness architecture are you considering? (I understand it's non-trivial to make an efficient implementation).
13:25:59 <musasabi> jvm is not very suitable for compiling haskell.
13:26:20 <musasabi> the list archives contain some discussion about it.
13:28:22 <arjanb> atm i put every lazy (updatable) expression in a wrapper object
13:31:22 <Korollary_> is clr any better as a target ?
13:34:12 <arjanb> i don't think the jvm is that bad for compiling haskell
13:35:58 <arjanb> afaik the clr is similar to the jvm in features useful for compiling haskell
13:55:45 <jyp> make
13:55:49 <jyp> dammit
14:22:51 <CosmicRay> !seen shapr
14:22:58 <CosmicRay> @seen shapr
14:22:59 <lambdabot> I saw shapr leaving #haskell 7 hours, 27 minutes and 38 seconds ago.
14:41:57 * boegel takes a peek in #haskell
15:43:57 <lispy_> geez, people were talking about climacs in #emacs and i took a minute to mention Yi had a lot of promise and it turned into a war about haskell vs. lisp which quickly turned into people bitching about how you have to circumvent the type system to do anything...
15:44:10 <lispy_> last time i try to sell Yi to the #emacs crowd :)
15:44:56 <Korollary_> even with that nick eh
15:45:50 <Heffalump> autrijus: you about?
15:47:21 <autrijus> Heffalump: yes?
15:48:15 <Heffalump> I finally got round to tidying up my perl5 binding a bit more - darcs get http://urchin.earth.li/darcs/antibuddha
15:48:30 <Heffalump> comments appreciated!
15:48:52 <Heffalump> (next thing to do is to get it to build a proper GHC package)
15:49:02 <autrijus> ooh nice!
15:50:42 <Heffalump> I'm off to bed shortly, but if you're interested in switching Pugs to it drop me an email with what would need doing first.
15:55:41 <Igloo> pugs needs a perl5 binding/
15:56:52 <Igloo> s#/#?#
16:09:24 <Korollary_> perl6 is meant to be backwards compatible iirc
16:10:48 <autrijus> yes.
16:10:50 <autrijus> Igloo: it's just for the interim.
16:11:02 <autrijus> next step is compile perl6 into perl5.
16:11:09 <autrijus> and then, vice versa.
16:12:14 <autrijus> I need to sleep. ciao! :)
16:13:39 <lispy_> Korollary_: yeah, after taking the time to learn Haskell better, I'm liking it more than lisp lately
16:14:14 <autrijus> real haskell hackers use Data.Dynamics for all types!
16:14:27 <lispy_> i really didn't write my code in a way that needed the dynamic capabilities of lisp very often, and the type checker helps me find my bugs
16:14:27 <Korollary_> lispy_ : the static vs non-typing is a low blow
16:15:11 <lispy_> Korollary_: er....lisp is typed, just that values have the types (refering to the non-typing comment)
16:15:34 <lispy_> but, you probably know that
16:16:04 <lispy_> in fact sbcl and cmucl have type checkers, they're just not very aggressive, and are mostly used to help generate fast code
16:16:26 <Korollary_> ah, scheme is not typed. I didnt know about lisp
16:16:36 <lispy_> they will occasionally complain at compile time that you have invalid code
16:16:53 <autrijus> ...but they insert runtime coerce and let you survive anyway.
16:17:29 <lispy_> autrijus: yeah, and that coerce is often okay, but comes at a huge performance hit
16:18:00 <lispy_> and i swear sbcl/cmucl programs require much more memory
16:18:02 <autrijus> nod. I'm trying to do better than that: http://www.nntp.perl.org/group/perl.perl6.compiler/1000
16:20:49 <lispy_> autrijus: nice
16:21:10 <autrijus> thanks =)
16:21:10 <lispy_> yeah, i never thought of the type checker that way before.  But it really is trying to prove that my program is sound from the point of view of types
16:22:04 <lispy_> people say that Haskell syntax is confusing
16:22:14 <Korollary_> which people ?
16:22:45 <lispy_> i hear it from lispers (which arguably has the simplest syntax possible) and from C/Java/Perl programmers
16:23:08 <autrijus> fact is, any unfamiliar syntax is confusing.
16:23:11 <autrijus> by definition
16:23:15 <Korollary_> but not from python folks
16:23:41 <autrijus> hs and py looks superficially similiar :)
16:23:43 <lispy_> Korollary_: the only python programmer i know thinks that Haskell sounds interesting and wants to learn more when he gets a chance :)
16:24:15 <Korollary_> I really didn't like perl's $array vs @array for the same variable. I still cannot remember it well heh.
16:24:30 <lispy_> i gave up on ever learning perl
16:24:32 <autrijus> $calar for Scalar, @rray for Array, %ash for Hash :D
16:25:01 <autrijus> I often refer to the J language, successor to APL, whenever the topic of punctuations comes up...
16:25:04 <autrijus>   qsort =: ]`(($:@:((}.<:{.)#}.)),{.,($:@:((}.>{.)#}.)))@.(*@#)
16:25:07 <autrijus> # from http://en.wikipedia.org/wiki/J_programming_language
16:25:15 <Korollary_> holy monad
16:25:28 <autrijus> you think perl is bad? try J :)
16:25:29 <lispy_> i think that perl does too many dirty things behind your back with global state
16:25:37 <Korollary_> that looks like a failed attempt at writing arabic in us-ascii
16:25:54 <lispy_> yeah, ouch
16:26:57 <Korollary_> I actually like haskell syntax more than any other now
16:27:09 <lispy_> i like parts of haskell syntax
16:27:49 <lispy_> i don't like that whitespace can have semantic meanin
16:27:51 <Korollary_> I had minor objections to data constructors and type constructors being able to have the same name, but it vanished.
16:28:12 <lispy_> Korollary_: yeah, that's confusing the first time, but i found the confusing goes away too
16:28:46 <Korollary_> well, both in python and haskell you were going to indent your code anyway. so why not carry some information with that act as well.
16:29:04 <autrijus> although reading code with the mix of two styles hurts
16:29:06 <lispy_> i tend to like explicit delimiters, so i use parens and avoid $, and I use {;} and avoid relying on whitespace for the do nation
16:29:07 <autrijus> data X = X Y
16:29:07 <autrijus> vs
16:29:12 <autrijus> data X = Y Y
16:29:36 <Korollary_> lispy_ : I use {} too, but because emacs haskell mode and my tab settings dont get along.
16:30:14 <lispy_> oh that's another thing that bugs me in haksell-mode, is that uncomment region doesn't play nicely with comment region
16:30:33 <Korollary_> lispy_ : surely not something an lisp hacker like you cannot fix ;)
16:30:50 <lispy_> Korollary_: i think it's a problem with the language
16:30:53 <wagle> whitespace has _semantic_ meaning?  not just syntactic?
16:31:03 <lispy_> wagle: hmm.....
16:31:15 <Korollary_> it's syntax
16:31:30 <lispy_> yeah, i guess so
16:31:36 <lispy_> my bad :)
16:31:40 <wagle> " " /= "     "
16:31:43 <wagle> 8)
16:32:06 <wagle> eh, i was hoping maybe i was missing something..
16:32:34 <lispy_> Korollary_: i think -- followed by certain things is not considered a comment
16:33:00 <Korollary_> "Network.Socket.setSocketOption :: Socket -> SocketOption -> Int -> IO ()". Does anyone know what the "Int" arg does ? It's not documented.
16:33:07 <wagle> @index --
16:33:08 <lambdabot> bzzt
16:33:21 <lispy_> Korollary_: so, because of that, comment region adds a space after --, but uncomment doesn't remove the extra space, because it should work when you've manually put a -- at the beginning of each line
16:33:28 <Korollary_> ow
16:33:49 <wagle> hahahahahahaha
16:34:14 <wagle> score one for the "computers suck!" team
16:34:23 * lispy_ is so lost
16:34:51 <Korollary_> why doesnt comment-region use block comments anyway
16:35:24 <lispy_> Korollary_: because comment-region . uncomment-region = id
16:35:26 <wagle> i think i've seen special stuff inside of {* *}'s
16:35:48 <lispy_> Korollary_: or at least in some languages it does
16:36:09 <lispy_> Korollary_: which is going to be harder if you use block commennts
16:36:25 <lispy_> it's a weak argument
16:36:42 <lispy_> i don't completely buy it, but i'm trying to figure out why it's that way :)
16:36:49 <wagle> lispy_: but you just observed that /= id
16:36:55 <Korollary_> a healthy dose of skepticism
16:37:10 <lispy_> wagle: yeah, but it's harder to see that it's /= id?
16:37:32 <lispy_> i think, that without a parser can't really get it right
16:37:59 <wagle> i've long thought that editors HAD to have the REAL parser
16:38:08 <Korollary> yesh
16:38:11 <lispy_> i think that the syntactic meaning of whitespace contributes :)
16:38:37 <wagle> s/syntactic meaning/syntax/ ?
16:38:42 <lispy_> wagle: i agree, and Yi better have a real parser :)
16:38:51 <lispy_> wagle: thanks
16:38:57 <wagle> s/a/the/
16:38:58 <Korollary> ok, the problem with uncomment-region is that you can select a subset of the commented region. if that subset is not "--" commented, you cannot perform an action without looking around the subset.
16:39:47 <wagle> hmm..  "Editors as Aspects of Compilation Systems"
16:40:00 <Korollary> so, comment-region [lines] = map commentLine [lines]
16:41:02 <wagle> ick..  weak title..  how about: "Editors should be Aspects of Compilation Systems"
16:41:26 <wagle> insertion points between stages, etc
16:41:28 <Korollary> or just, Eclipse
16:41:55 <wagle> eclipse does its own parsing.  i was to use The Parser..  8/
16:42:26 <wagle> hahaha..  eclipse wont build from its own official source!
16:42:35 <wagle> ...
16:42:36 <wagle>     [javac]  (at line 422)
16:42:36 <wagle>     [javac]     if (method.isVarArgs()) {
16:42:36 <wagle>     [javac]                ^^^^^^^^^
16:42:36 <wagle>     [javac] The method isVarArgs() is undefined for the type Method
16:42:38 <wagle>     [javac] ----------
16:42:41 <wagle>     [javac] 18 problems (18 errors)
16:43:12 <lispy_> wagle: what do you mean The parser?
16:43:34 <wagle> gcc, the c compiler contains a parser.  thats The Parser
16:43:56 <wagle> everyone keeps writing their own parser, then wonders why they got burnt
16:43:57 * lispy_ still doesn't get it
16:44:00 <Korollary> ghc comes with a haskell parser too
16:44:39 <wagle> i want to use gcc's parser to parse stuff
16:44:46 <lispy_> wagle: you want to use the same parser as the compiler that is being used so that they have the same set of bugs and extensions?
16:44:51 <lispy_> ah okay
16:45:01 <wagle> same everything
16:45:25 <wagle> editing as reflection
16:45:26 <lispy_> but is the parser so clearly defined within the compiler that you can really just use it
16:45:39 <wagle> lispy_: not at all
16:45:57 <lispy_> wagle: so there is still research to bedone?
16:46:03 <wagle> i just say what i want, not what is easy, etc
16:46:19 <lispy_> wagle: fair 'nough
16:46:55 <wagle> its a research project thats tossing around in my head..  a big too big as stated, maybe
16:47:19 * wagle runs off to do errands
16:48:13 <Korollary> lispy, where in the bay area are you ?
16:48:26 <lispy_> san jose
16:48:39 <lispy_> south bay :)
16:48:50 <Korollary> wah. I thought I was all alone as a haskeller in san jose
16:48:56 <lispy_> heh
16:49:00 <lispy_> i don't live here
16:49:07 <lispy_> i'm just working at IBM for the summer
16:49:13 <Korollary> ah. almaden ?
16:49:16 <lispy_> yup
16:49:31 <lispy_> i normally live in Corvallis up in Oregon
16:49:44 <lispy_> lots of haskellers there because they teach it an the grad level
16:49:50 <Korollary> at ogi ?
16:49:54 <lispy_> no OSU
16:50:01 <lispy_> ogi is near portland
16:50:12 <lispy_> at least what used to be OGI
16:50:55 <lispy_> Korollary: what part of the bay are youin?
16:51:20 <lispy_> i heard berkley was having a kite festival today, but i can't go
16:52:34 <Korollary> I live in sunnyvale and work in San Jose
16:52:52 <lispy_> ah, not sure where sunnyvale is from here, but i think i've seen a sign
16:53:09 * lispy_ is pretty new to the area
16:53:10 <Korollary> it's 9 miles to the west
16:53:23 <lispy_> just north of los gatos then?
16:53:47 <X-Scale> google earth is your friend
16:53:56 <lispy_> heh
16:54:04 <Korollary> yeah north of los gatos and cupertino
16:54:13 <Korollary> err los altos
16:55:04 <lispy_> X-Scale: google earth requires windows :(  perhaps you meant google maps?
17:00:48 <lispy_> i wish haskell had a built in version of 'if' that was a function
17:00:59 <Korollary> ugh why ?
17:01:29 <lispy_> Korollary: well, when i was writing a haskell version echo it would have been nice
17:01:40 <lispy_> but in general it would be nice with point free functions
17:02:22 <lispy_> @pl \x y z -> if x then y else z
17:02:23 <lambdabot> if'
17:02:33 <lispy_> but, where is if'?
17:02:37 <lispy_> @hoogle if'
17:02:39 <lambdabot> Prelude.undefined :: a
17:02:39 <lambdabot> Prelude.minBound :: Bounded a => a
17:02:39 <lambdabot> Prelude.maxBound :: Bounded a => a
17:03:19 <dons> lispy, maybe you can use maps.google.com, that's a sort-of web based google earth
17:03:48 <dons> oh, I should read to the end of the sentence :}
17:03:54 <lispy_> dons: :)
17:04:19 <Korollary> lazy reader
17:04:28 <dons> true!
17:05:10 <Korollary> dons, do you understand the C output from ghc ?
17:06:06 <dons> yeah, pretty much :)
17:06:50 <Korollary> I was trying to see what was happening for the array based permutation generator of mine, and I got lost. Too many JMP's and goto's heh.
17:07:25 <dons> can you post the file somewhere, and tell me what function you're interested in?
17:07:52 <Korollary> do you still have my perm2.hs ?
17:08:45 <dons> nah, it would have been in /tmp :)
17:09:04 <Korollary> aight
17:09:54 <lispy_> hmm...looking at my code just made me realize it's time to invest in learning literate haskell :)
17:10:07 <lispy_> so, which is easier to get started with Bird style or the other one?
17:11:40 <dons> or you could use haddock and normal .hs
17:11:50 <dons> that's what I do
17:12:05 <lisppaste2> Korollary pasted "perm2" at http://paste.lisp.org/display/10359
17:12:17 <TheHunter> lispy, there's no if' in the libs, but there's also nothing short an if-expression can be tranformed to.
17:13:10 <lispy_> TheHunter: not sure what you mean?  are you suggesting that i should just define if' ?
17:13:50 <lispy_> dons: hmm...is haddock easy to learn?  I thought it was mostly meant for generating library documentation?  the stuff i'm hacking on isn't really a library....
17:14:01 <TheHunter> lispy, you asked where if' was.
17:14:30 <Cale> lispy_: I like the TeX one, but that's because I like TeX.
17:14:40 <lispy_> TheHunter: right, and your saying no it's not in the standard libs. I get lost after the coma
17:14:55 <lispy_> Cale: yeah, that was was tempting, i like LaTex
17:15:15 <lispy_> coma, comma, whatever :)
17:15:56 <TheHunter> lispy, what I was trying to say is that i couldn't find a short pointless expression that is equivalent to \b x y -> if b then x else y.
17:18:07 <lispy_> TheHunter: ah
17:18:37 <lispy_> TheHunter: and now your statement makes sense, but before i just couldn't parse it :)
17:19:09 <lispy_> so does emacs support the Bird style literate comments?
17:19:21 <lispy_> will it automatically insert the > character?
17:22:00 <TheHunter> @pl \b x y -> last $ y: (guard b >> return x)
17:22:01 <lambdabot> (((last .) . flip (:)) .) . (. return) . (>>) . guard
17:22:21 <TheHunter> @pl \b x y -> head $ (guard b >> return x) ++ return y
17:22:22 <lambdabot> ((head .) .) . flip flip return . (((.) . (++)) .) . (. return) . (>>
17:22:22 <lambdabot> ) . guard
17:23:46 <lispy_> dons: is it possible to just completely turn off line wrapping when lambdabot is outputting code? I find the line wrapped stuff hard to copy&paste
17:25:11 <lispy_> haddock looks line, but i think i'll try out bird style for now since it has a low level of entry
17:25:18 <lispy_> s/line/nice/
17:25:46 <dons> hmm. yeah, we could turn off line wrapping with code, I guess
17:27:53 <lispy_> i've been using lambdabot enough that i was having a hard type remembering to type :t instead of @type :)
17:28:52 <dons> hehe
17:28:56 <TheHunter> in fact, we should think about that whole output filter mess.
17:29:38 <Igloo> If you just turn it off then you'll lose the ends of long lines
17:31:07 <lispy_> Igloo: is there a max line length per message?  I guess there is...
17:31:16 <Igloo> Yes
17:31:42 <lispy_> i'm already getting sick of typing > at the beginning of lines
17:31:49 <lispy_> there must be a way to automate this with emacs
17:32:22 <dons> i'm sure there is, there is in vim
17:33:07 <dons> @seen jyp
17:33:08 <lambdabot> I saw jyp leaving #haskell 1 hour, 55 minutes and 48 seconds ago.
17:36:22 <dons> hmm, TheHunter, I can't write this with ghc 6.2.2:
17:36:23 <dons> getDynamic :: forall a. Initializable a => IO a
17:36:24 <dons> getDynamic = do
17:36:24 <dons>         ps <- readEditor dynamic
17:36:24 <dons>         case M.lookup (show $ typeOf (undefined :: a)) ps of
17:36:26 <dons>             Nothing -> initial
17:36:28 <dons>             Just x -> return $ fromJust $ fromDynamic x
17:36:32 <dons>     Ambiguous type variable `a' in the top-level constraint:
17:36:32 <dons>       `Typeable a' arising from use of `typeOf' at Yi/Core.hs:633
17:36:37 <dons> but I can write this:
17:36:44 <dons> getDynamic :: forall a. Initializable a => IO a
17:36:45 <dons> getDynamic = getDynamic_ undefined
17:36:46 <dons> getDynamic_ :: forall a. Initializable a => a -> IO a
17:36:46 <dons> getDynamic_ a = do
17:36:46 <dons>         ps <- readEditor dynamic
17:36:48 <dons>         case M.lookup (show $ typeOf a) ps of
17:36:51 <dons>             Nothing -> initial
17:36:53 <dons>             Just x -> return $ fromJust $ fromDynamic x
17:36:58 <cm> hello lambdas
17:39:15 <TheHunter> hmm, does |getDynamic :: a = do ...| work?
17:44:07 <TheHunter> no, it won't work.
17:45:28 <dons> is it the locally-scoped type variable?
17:45:42 <dons> but then this is ok: getDynamic = getDynamic_ (undefined :: a)
17:45:53 <TheHunter> well, the docs say it should work.
17:46:22 <dons> I can write both with 6.4
17:46:36 <TheHunter> yes.
17:46:57 <TheHunter> but getDynamic :: IO a should actually work to, but it doesn't, unless i've made some silly mistake in my example
17:47:42 <TheHunter> "A lexically scoped type variable can be bound by: [...] A result type signature"
17:48:07 <dons> hmm
17:48:36 <TheHunter> let x :: Typeable a => IO a; x = print (typeOf (undefined :: a)) >> return undefined
17:49:08 <lispy_> hum....haddock may actually be nicer than the latex or bird styles, at least for me
17:49:26 <TheHunter> err, let x :: Typeable a => IO a; x :: IO a = print (typeOf (undefined :: a)) >> return undefined
17:54:54 <TheHunter> I can't make any sense out of "    All of the type variables in the constraint `Typeable a' are already in scope
17:54:54 <TheHunter>         (at least one must be universally quantified here)
17:54:54 <TheHunter> "
17:55:39 <TheHunter> i thought this error message would only come from ghc manual, 7.4.3.1.2
17:55:49 <dons> yeah, that's where I was stuck
18:01:28 <TheHunter> and I don't understand why "bar :: forall a. Typeable a => a" and "bar :: Typeable a => a" give different results
18:02:37 <TheHunter> ok, ghc-6.2 treats them equally.
18:05:02 <TheHunter> even worse, the behavior even changes when alpha-renaming the signature (containing no forall, so no scoping!).
18:05:14 <dons> :/
18:06:34 <Speck> Sufjan Stevens is so good.
18:08:01 <interferon> this is a pretty vague question, but is haskell well-suited to user applications, simple gui stuff that isn't really too centered around algorithms?
18:08:09 <TheHunter> dons, do you want to write the bug report?
18:08:42 <Speck> how can a progamming language be too centered around algorithms?
18:09:13 <interferon> Speck: well, i mean an application along the lines of an instant messenger or a text editor rather than something that's solving real computer science problems
18:09:15 <dons> TheHunter, perhaps you should, since you found the strange behaviour with 6.4
18:09:15 <interferon> if that makes any sense
18:09:28 <dons> and can probably understand it better ;)
18:09:47 <Speck> interferon, there are a few good GUI libraries that I at least would argue are as good as their counterparts in other languages (wxHaskell, gtk2hs), but the elegant nature of Haskell will leave you wanting.
18:10:20 <dons> this is really quite sensitive to how the code is arranged
18:11:03 <TheHunter> dons, oh, i don't understand the behavior at all. But I'll keep playing around a bit (install ghc-6.4) and then bug spj about it.
18:11:38 <dons> ok.
18:21:03 <interferon> Speck: leave me wanting?
18:25:07 <dons> hmm. yeah, if I alpha-rename tyvars then ghc 6.4 also acceptts the code
18:25:26 <Igloo> !
18:31:31 <TheHunter> the strangest thing is that ghc-6.4 doesn't even accept "bar :: forall a. Typeable a => a; bar :: a = typeOf (undefined :: a) `seq` undefined", so return type annotations are different from both expression and pattern annotations.
18:32:49 <dons> argh
18:47:04 <Speck> interferon, since haskell is so elegant, even a gui library that is "just as good as" those in other languages won't be good enough
18:47:18 <Speck> that's why we have all the functional reactive gui research in haskell-land
18:47:31 <interferon> Speck: ah
18:48:25 <Speck> once cabal-get and hackage are popularized, we'll have a cpan like library source too
18:48:36 <Speck> s/popularize/finished and popularized
19:01:58 <Lemmih> Too bad the main programmer of those tools is a lazy bastard. (:
19:05:02 * TheHunter wonders if the 'a' in the type signature of qux, |qux :: Typeable a => a; qux :: a = typeOf (undefined :: a) `seq` (undefined :: a)|, is bound by "qux :: a".
19:05:12 <TheHunter> That would explain the strange error message.
19:08:42 <TheHunter> things like this always remind me of how small the haskell community is.
19:09:00 * TheHunter checkes hugs...
19:09:29 <dons> hmm. perhaps that is the case, and 
19:09:32 <TheHunter> oh, hugs doesn't understand result type annotations.
19:09:46 <TheHunter> what's that?
19:11:02 <dons> the above point about where `a' is bound
19:11:58 <TheHunter> oh, i just couldn't decipher .
19:18:32 <TheHunter> erm, so, what's ?
19:21:35 <dons> ?
19:22:02 <TheHunter> my irc client shows only weird characters there.
19:23:33 <dons> oh, I see nothing. maybe my wireless connection sent some garbage bytes, it dropped out
19:24:20 <TheHunter> oh, that's strange, nevermind.
19:33:22 <lispy_> i thought, "hey, implementing a lisp interpreter would be fun and easy!" but i'm find it to be quite difficult
19:33:48 <lispy_> i had to create my own type of list, and working with it has been a pain :)
19:34:11 <lispy_> and dealing with multiple arity of lisp functions is hard too
19:34:55 <lispy_> my way of coping with arity has been to create a list that contains all the arguments and pass that to the function
19:35:44 <lispy_> i wish i could use the haskell built in list functions, but i can, so i have to keep reinventing the wheel
19:35:53 <Lemmih> Why can't you?
19:36:01 <lispy_> dotted pairs mostl
19:36:10 <Lemmih> dotted pairs?
19:36:57 <lispy_> Lemmih: (1 . 2) -> (Cons 1 2) versus (1 2) -> (Cons 1 (Cons 2 Nil))
19:37:31 <lispy_> (phone call)
19:37:33 <Lemmih> I still don't get why you can't use Haskell's list.
19:38:37 <TheHunter> everybody who says lisp is based on lists is a liar, it's based on binary trees.
19:40:31 <interferon> TheHunter: how so?
19:41:55 <CrewdenX> TheHunter: it is?
19:42:07 <wagle> (((1 2 3) (4 5 6))(7 8 9) 10 11 12 13) is a binary tree?   or a recursive list of lists?
19:42:52 <TheHunter> to me, it's clearly a tree.
19:43:12 <interferon> TheHunter: a tree, perhaps.  but a binary tree?
19:43:38 <wagle> technically (and mostly traditionally) cons cells consist of pointers to two values, but in, say, 3-lisp, there are rails, which can be represented as vectors
19:43:42 <TheHunter> degenarated trees are favored in a way.
19:44:08 <wagle> TheHunter: yeah, but you called the "its all lists" people liars
19:45:05 <TheHunter> wagle, you shouldn't take that too seriously.
19:45:40 <wagle> the true schemer can see it both ways
19:52:23 <TheHunter> i'm having serious trouble with the list of lists approach, which is probably because i'm thinking statically typed.
19:54:02 <TheHunter> interferon, yes, a binary tree. Everything is either a cons-cell (a node) or something else (a leaf).
19:54:52 <TheHunter> wtf is wrong with ftp.us.debian.org?
19:56:51 <lispy_> Lemmih: does it make more sense now?
19:59:01 <TheHunter> does apt-get dist-upgrade always choose the nearest mirror, if the name resolves to more than one address?
19:59:19 <Lemmih> lispy_: No.
19:59:26 <lispy_> TheHunter: it chooses the one listed in your sources, iirc
19:59:44 <lispy_> TheHunter: not fully sure i understand the question tho
19:59:52 <TheHunter> $ host ftp.us.debian.org
19:59:53 <TheHunter> ftp.us.debian.org       A       128.101.80.133
19:59:53 <TheHunter> ftp.us.debian.org       A       204.152.191.7
19:59:53 <TheHunter> ftp.us.debian.org       A       204.152.191.39
19:59:54 <TheHunter> ftp.us.debian.org       A       216.37.55.114
19:59:56 <TheHunter> ftp.us.debian.org       A       35.9.37.225
20:00:14 <lispy_> Lemmih: well, I need someway to represent dotted pairs on the haskell side, so that they can be created in the interpreter, how can I do this with haskell lists?
20:00:35 <TheHunter> apt-get update chooses a different one each time, dist-upgrade always  35.9.37.225, which appears to be fucked up.
20:00:48 <Korollary> what ? ACM's Special Interest Group on Programming Languages (SIGPLAN) recently awarded the 2005 Programming Languages Achievement Award to Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (known as the 'Gang of Four') for their creation of 'Design Patterns' (from slashdot)
20:00:49 <lispy_> TheHunter: it's probably round-robin DNS
20:01:23 <lispy_> Korollary: well, that book had a big impact in industry....*shrug*
20:01:41 * TheHunter changes is sources.list to explicit ip addresses.
20:01:58 <Korollary> lispy_ : That is fine by me. But it's not an achievement "in" programming languages.
20:02:11 <lispy_> Korollary: oh....true
20:02:39 <Korollary> Why not give the next one to Scott Meyers or something.
20:02:54 <TheHunter> yep, 216.37.55.114 works fine.
20:03:36 <Lemmih> lispy_: And (.) == Cons?
20:03:58 <TheHunter> in any case, if a debian mirror is hacked, all packages are verified against a gpg signature, right?
20:04:13 <lispy_> Lemmih: the dot is just a representation, to help show the user how the list is structured in memory
20:04:38 <Korollary> eww low level concerns like memory layout ;)
20:04:58 <lispy_> Lemmih: a cons has two pointers, when the second pointer points at a concrete thing instead of another cons, you put a dot in front of it before you print it out
20:04:59 <Lemmih> lispy_: You have to explain it a little more.
20:05:35 <lispy_> Lemmih: which is why i said this originally: (1 . 2) -> (Cons 1 2) versus (1 2) -> (Cons 1 (Cons 2 Nil))
20:05:52 <lispy_> in (Cons 1 2), the 2 is not a cons, so you print a dot before it
20:05:53 <TheHunter> lispy, are there scheme interpreters supporting something readline-like?
20:06:10 <Lemmih> lispy_: Isn't this a pretty printing issue?
20:06:14 <lispy_> TheHunter: i've never used scheme :(
20:06:29 <lispy_> Lemmih: it also affects traversal
20:06:43 <Lemmih> lispy_: How so?
20:07:19 <lispy_> Lemmih: consider mapcar (it's lisp's version of map), it takes the first element of the list, and then apply a function, then it does a mapcar on the rest of the list
20:07:35 <lispy_> Lemmih: when it hits a dotted pair, the list is not a real list, and mapcar gives an error
20:08:00 <lispy_> Lemmih: it's not a real list is the sense that it's not of the form (Cons x (Cons y (Cons z .... )))
20:08:20 <lispy_> Lemmih: mapcar expects to find a Cons not an element at the front of the list
20:09:05 <TheHunter> so how come (1 . 2 . 3) is (2 1 3) ?
20:09:12 <lispy_> * (cdr '(1 . 2))
20:09:12 <lispy_> 2
20:09:12 <lispy_> * (cdr '(1 2))
20:09:12 <lispy_> (2)
20:09:35 <Lemmih> I'm unfamiliar with lisp. What's 'cdr'?
20:09:43 <lispy_> TheHunter: in what implementation?
20:10:16 <lispy_> @hoogle rest
20:10:24 <TheHunter> Welcome to MzScheme version 209, Copyright (c) 2004 PLT Scheme, Inc.
20:10:24 <TheHunter> > '(1 . 2 . 3)
20:10:24 <TheHunter> (2 1 3)
20:10:24 <Lemmih> tail?
20:10:26 <lispy_> Lemmih: i think cdr is rest
20:10:51 <lispy_> Lemmih: yeah, that's probably it
20:11:01 <lispy_> it takes everything but the first element of the list
20:11:08 <lispy_> cdr = drop 1
20:11:14 <Korollary> TheHunter: That gives an error for me in guile
20:11:35 <lispy_> TheHunter: yeah, i've never used a lisp where that is valid :(
20:11:53 <Lemmih> lispy_: And why can't you use Haskell lists?
20:12:10 <lispy_> Lemmih: a haskell list is always a true list
20:12:12 <TheHunter> why doesn't it just mean Cons 1 (Cons 2 3) ?
20:12:26 <Lemmih> (I'm assuming you're not hacking a DSL)
20:13:18 <lispy_> TheHunter: Cons 1 (Cons 2 3) would be (1 . (2 . 3))
20:13:31 <lispy_> i think
20:13:39 <Lemmih> lispy_: That doesn't matter since you aren't hacking an embedded language.
20:13:54 <TheHunter> oh, it's lisp, right. Left associativity would be confusing.
20:14:01 <TheHunter> *Right
20:14:19 <lispy_> Lemmih: why not?
20:15:05 <TheHunter> no, (1 . (2 . 3)) appears to be (1 2 . 3).
20:15:20 <TheHunter> so, *Left
20:15:42 <lispy_> TheHunter: right, because (2 . 3) is a cons, so you don't show the dot before it :)  or at least, that's the way i think it's supposed to work
20:16:29 <Lemmih> lispy_: data LispExp = LispFnCall String [LispExp] <- Or whatever a Lisp syntax tree would look like.
20:16:32 <lispy_> TheHunter: in your original example (1 . 2 . 3) was interpreted as (Cons 2 (Cons 1 (Cons 3 Nil))) which is just odd to me
20:16:46 <TheHunter> i didn't understand it either.
20:17:35 <lispy_> Lemmih: i'm not following you
20:18:09 <lispy_> dotted pairs suck :)
20:18:21 <Lemmih> lispy_: 'Cons 1 2' would be 'LispFnCall "Cons" [LispLit 1,LispLit 2]' and 'Cons 1 (Cons 2 Nil)' would be 'LispFnCall "Cons" [LispLit 1,LispFnCall "Cons" [LispLit 2]]'.
20:18:30 <TheHunter> 4 dots aren't allowed in mzscheme...
20:19:32 <lispy_> Lemmih: i think i see what's going on, I'm trying to use Conses for my AST because that's usually the way lisp interpreters think
20:19:39 <TheHunter> lemme just bug #scheme
20:19:47 <Korollary> TheHunter: or #lips ?
20:19:49 <Korollary> err
20:19:50 <Korollary> lol
20:19:51 <Korollary> wow
20:20:30 <Korollary> lispy_: did you google for an existing lisp implementation in haskell ?
20:20:55 <Korollary> it sounds a lot like a class project
20:21:08 <lispy_> Korollary: i thought, "hey, implementing a lisp interpreter would be fun and easy!" but i'm find it to be quite difficult
20:21:19 <lispy_> ah
20:21:23 <lispy_> i see what you're saying
20:21:34 <lispy_> i did want to roll my own, but that doesn't mean i can't use the ideas of others
20:21:53 <Korollary> right
20:22:44 * cm installs emacs and awaits food
20:23:35 <lispy_> Korollary: i'm not finding much
20:24:05 <Lemmih> TheHunter: I didn't know 'qux :: a = ...' was valid Haskell.
20:24:47 <lispy_> Korollary: i think SICP says how to implement scheme in scheme but i'm not sure how much that will help :)
20:24:52 <Korollary> heh
20:24:59 <TheHunter> it's valid ghc haskell. It's called "result type annotation".
20:25:09 <TheHunter> but it's nowhere near working...
20:26:49 <TheHunter> so this might have something to do with mzscheme's "!/("%&$¬ß($/& infix syntax stuff.
20:31:15 <TheHunter> and it's not valid scheme.
20:33:09 <TheHunter> Lemmih, i'm very curious about spj's response.
20:54:50 <lispy_> so here is a problem, I need to define a certain number of builtin functions, for example, setq.  I had been giving all the builtin functions the type Env -> SExp -> SExp, so that is they take an environment and a lisp expression and return a lisp expression.
20:55:06 <lispy_> Should I have them return (SExp, Env)
20:55:16 <lispy_> in case they modify the environment?
20:55:27 <lispy_> and if I do that, shouldn't I be using a state monad?
21:01:06 <lispy_> "Building interpreters by composing monads" by guy steele, could it be more perfect?
21:03:56 <lispy_> this paper could also be a bit weird
21:04:04 <lispy_> they are talking about "psuedomonads"
21:11:58 <Enveigler> @type (\x xs -> xs:x)
21:12:00 <lambdabot> forall a. [a] -> a -> [a]
21:12:32 <Beelsebob> snoc?
21:13:26 <Enveigler> As in reverse cons? (if so, maybe, but that wasn't my intent).
21:13:49 <Beelsebob> fair enough
21:13:53 <Enveigler> @eval (\x xs -> xs:x) [1 .. 4]
21:13:55 <lambdabot> <Plugins.Eval>:1:
21:13:55 <lambdabot>   No instance for (Show (a -> [a]))
21:13:55 <lambdabot>   arising from use of `show'
21:14:22 <Beelsebob> @eval (\x xs -> xs:x) [1 .. 4] 5
21:14:25 <lambdabot> [5,1,2,3,4]
21:14:31 <Beelsebob> @eval (\x xs -> xs:x) [1 .. 4] 0
21:14:32 <lambdabot> [0,1,2,3,4]
21:14:34 <Beelsebob> woops
21:15:03 <Beelsebob> it's not snoc
21:15:08 <Beelsebob> it's cons'
21:15:09 <Enveigler> I am trying to understand how to pattern match (?) head:tail in a lambda
21:15:21 <Beelsebob> and there's a snoc' to go with it
21:16:04 <Enveigler> As in, I wan't the type [a]->[a], but be able to access x:xs insode the lambda
21:16:34 <Enveigler> @type (\x:xs -> xs:x)
21:16:36 <lambdabot> bzzt
21:16:44 <Beelsebob> I see
21:16:53 <Enveigler> @type (\(x,xs) -> xs:x)
21:16:54 <Beelsebob> my sugestion is to use a named function
21:16:55 <lambdabot> forall b. ([b], b) -> [b]
21:17:02 <Beelsebob> easier to debug anyway
21:17:31 <Enveigler> The purpose of the exercise was to explore lambda expressions :)
21:17:52 <Enveigler> @type (\(x:xs) -> xs:x)
21:17:54 <lambdabot> bzzt
21:18:25 <Beelsebob> heh... well... perhaps the purpose was to show their limitations too
21:18:26 <Enveigler> Is what I am trying actually possible?
21:19:49 <Beelsebob> I don't think so
21:20:00 <Beelsebob> I think it's one of the proposals for Haskell 2
21:20:13 <Lemmih> @type (\(x:xs) -> xs:[x])
21:20:14 <Beelsebob> (or 05-07 depending on who you ask)
21:20:15 <lambdabot> bzzt
21:20:21 <Lemmih> @type (\(x:xs) -> xs ++ [x])
21:20:22 <lambdabot> forall a. [a] -> [a]
21:20:38 <TheHunter> what's a proposal for haskell2?
21:20:39 <Beelsebob> anyway... gonna hit the sack... you know it's been a good party, when the sun's rissen
21:20:57 <Enveigler> Thanks Lemmih
21:21:17 <Enveigler> (I was getting close....kinda)
21:30:05 <Enveigler> @pl @type (\(x:xs) -> xs ++ [x])
21:30:05 <lambdabot> (line 1, column 1):
21:30:05 <lambdabot> unexpected "@"
21:30:05 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
21:30:05 <lambdabot> expression
21:30:12 <Enveigler> @pl  (\(x:xs) -> xs ++ [x])
21:30:12 <lambdabot> ap (flip (++) . return . head) tail
21:30:35 <Enveigler> @index ap
21:30:36 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
21:30:36 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
21:30:36 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
21:30:36 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.
21:30:36 <lambdabot> Inductive
21:31:18 <Enveigler> @type flip
21:31:19 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
21:32:07 <Enveigler> @type ap
21:32:09 <lambdabot> bzzt
21:32:17 <Enveigler> @type Monad.ap
21:32:19 <lambdabot> forall b (m :: * -> *) a.
21:32:19 <lambdabot>     (Monad m) =>
21:32:19 <lambdabot>     m (a -> b) -> m a -> m b
21:39:11 <Enveigler> @pl (\(x:xs) -> return( if x == "-n" then xs else (x:xs++["\n"] ) ) )
21:39:13 <lambdabot> liftM2 ((return .) . liftM2 ap (if' . ("-n" ==)) ((. (++ ["\n"])) . (
21:39:13 <lambdabot> :))) head tail
21:42:40 <Enveigler> @type liftM2 ((return .) . liftM2 ap (if' . ("-n" ==)) ((. (++ ["\n"])) . (:))) head tail
21:42:42 <lambdabot> bzzt
21:44:04 <lispy_> Enveigler: no let it die :)
21:44:15 <lispy_> what is ap?
21:44:18 <lispy_> @hoogle ap
21:44:19 <lambdabot> Monad.ap :: Monad a => ((a (b -> c)) -> (a b) -> (a c))
21:44:19 <lambdabot> Prelude.appendFile :: (FilePath -> String -> (IO ()))
21:44:19 <lambdabot> Ratio.approxRational :: RealFrac a => (a -> a -> Rational)
21:45:39 <Enveigler> Echo (tm) Version 320.3
21:45:46 <Enveigler> :)
21:46:09 <Enveigler> the monadix eqivalent of (.) ?
21:46:21 <Enveigler> monadic even
21:47:08 <Enveigler> Like you, that if' confuses the begebbers out of me.
21:47:32 <wagle> @type LiftM ($)
21:47:33 <lambdabot> bzzt
21:47:41 <wagle> @type liftM ($)
21:47:43 <lambdabot> bzzt
21:48:12 <Enveigler> @type Monad.liftM ($)
21:48:13 <lambdabot> forall a b (m :: * -> *).
21:48:13 <lambdabot>        (Monad m) =>
21:48:13 <lambdabot>        m (a -> b) -> m (a -> b)
21:48:27 <wagle> @type Monad.liftM2 ($)
21:48:29 <lambdabot> forall b a2 (m :: * -> *).
21:48:29 <lambdabot>        (Monad m) =>
21:48:29 <lambdabot>        m (a2 -> b) -> m a2 -> m b
21:49:13 <wagle> hmm..
21:49:17 <wagle> @type Monad.liftM2 id
21:49:19 <lambdabot> forall a2 r (m :: * -> *).
21:49:19 <lambdabot>        (Monad m) =>
21:49:19 <lambdabot>        m (a2 -> r) -> m a2 -> m r
21:49:25 <wagle> bwahaha
21:49:58 <lispy_> why is that funny?
21:50:32 <wagle> why isnt it funny?
21:50:39 * lispy_ boggles
21:51:11 * wagle tries to bounce, but falls over instead
21:51:30 <lispy_> Enveigler: i understand if', i just wish it was part of the standard stuff
21:51:48 <lispy_> if' b x y = if b then x else y
21:52:20 <lispy_> so i want to use a state monad in my interpreter State Env SExp
21:52:46 <lispy_> what should be the type of a function then?  (SExp -> State Env SExp)
21:52:52 <lispy_> that's what i'm thkinking it is
21:54:36 <Enveigler_> lispy: You moved on from where I saw you discussing if'
21:54:56 <lispy_> ah
21:55:43 <lispy_> if functions are of type (SExp -> State Env SExp) then what is the type of mapcar?  mapcar :: (SExp -> State Env SExp) -> SExp -> State Env SExp right?
21:55:44 <Enveigler_> So if' is defined somewhere but just not a part of prelude?
21:55:57 <lispy_> Enveigler: i think it's just agreed upon
21:56:05 <lispy_> Enveigler: but not part of Haskell
21:56:11 <Enveigler_> Okay.
21:56:24 <lispy_> Enveigler: try this
21:56:35 <lispy_> @pl \x y z -> if x then y else z
21:56:36 <lambdabot> if'
21:56:42 <lispy_> so now we know what if' is :)
21:57:01 <Korollary> it's not part of the prelude
21:57:08 <Enveigler_> I saw that before, and then went off looking for the definition
21:57:33 <lispy_> if i use the above definition for mapcar, how will i actually write the definiton of mapcar?
21:58:19 <lispy_> mapcar f sexp = f (car sexp) >>= mapcar f (cdr sexp)
21:58:36 * Enveigler_ backs away. I can't remember any of the little lisp I did, and I didn;t like it when I could.
21:58:46 <lispy_> heh
21:59:10 <Lemmih> lispy_: How about writting it in Lisp?
21:59:52 <wagle> (define mapcar (lambda (f xx) (if (null? xx) '() (cons (f (car xx)) (mapcar f (cdr xx))))))
22:00:20 <lispy_> Lemmih: i want to use haskell :)
22:00:29 <wagle> prolly should invert the if and replace the null? with pair?
22:00:32 <Lemmih> lispy_: Why?
22:00:41 <Lemmih> lispy_: Aren't you writting a Lisp interpreter?
22:00:47 <Enveigler_>  ./That's/ what I'm takin'bout!
22:00:49 <lispy_> Lemmih: my goal is to build a fully working elisp interpreter
22:01:03 <Lemmih> As a Haskell DSL?
22:01:05 <wagle> so write mapcar in elisp
22:01:24 <lispy_> i have to write some part of it in haskell don't i?
22:01:39 <wagle> hmm..  write a tranlator from elisp to ehaskell
22:01:59 <Lemmih> If you were writting a Haskell interpreter in language X then you would write 'map' in Haskell and not in language X.
22:02:00 <wagle> (eyi?)
22:03:02 <lispy_> Lemmih: if i shouldn't be writting mapcar in haskell to operate on the lisp expressions, then would should i be writting instead?
22:03:45 <Lemmih> Write an elisp interpreter and implement the libraries in elisp.
22:04:16 <lispy_> Lemmih: right, and i'm writing the interpreter at the moment.  What should I implement in place of mapcar?
22:04:45 <Lemmih> What interpreter?
22:04:45 <wagle> eq
22:04:59 <wagle> the primitive
22:05:01 <lispy_> Lemmih: the elisp interpreter
22:05:01 <wagle> the primitives
22:05:10 <Lemmih> lispy_: Then write mapcar.
22:05:21 <lispy_> i'm so confused
22:05:29 <lispy_> didn't you just tell me not to write mapcar?
22:05:41 <Lemmih> Don't write it in Haskell, write it in elisp.
22:05:47 <lispy_> okay, got it
22:05:59 <Korollary> does anyone use Ratpoison ?
22:05:59 <lispy_> now, what do i implement instead, so that i can build up mapcar?
22:06:13 <wagle> (define mapcar (lambda (f xx) (if (null? xx) '() (cons (f (car xx)) (mapcar f (cdr xx))))))
22:06:35 <wagle> need define, lambda, if, eq, cons, car, and cdr
22:06:47 <lispy_> wagle: lambda, cons and null?
22:06:48 <wagle> define might be a macro that uses set!
22:06:56 <lispy_> wagle: set!?
22:07:08 <wagle> sorry, i'm thinking in scheme
22:07:11 <lispy_> ah
22:07:13 <wagle> setq
22:07:31 <wagle> havent programmed in lisp for quite some time
22:07:53 <lispy_> so i started working on lambda, but it's a pain in the but to work with my SExp (my ASTs) so I was implementing some things in haskell, for example, mapcar
22:08:04 <wagle> (define nullp (lambda (x) (eq x nil)))
22:08:25 <dons> Korollary, ion is popular here, I think
22:08:55 <reffie> did someone say sex
22:09:20 <dons> no, just sexy types
22:09:43 <wagle> (define car (lambda (x) (if (pair? x) (#primitive-car x) (error "error in car: nil is not a pair!")))
22:09:44 <reffie> ah
22:10:53 <wagle> pair? is probably primitive
22:11:08 <dons> didn't someone already write a lisp shell thingo in haskell?
22:11:23 <wagle> wheels exist to be reinvented, silly
22:12:04 <wagle> if you cant reinvent them, what good are they?
22:12:28 <lispy_> especially when learning
22:12:29 * dbremner is reminded of an old k5 poll about Scheme - one option was "I grow scheme implementations in my basement."
22:12:58 <dons> are there formal semantics for lisp? I'm guessing yes?
22:13:39 <wagle> .. but actually, its elisp, not lisp
22:14:16 <wagle> theres a quasi denotational semantics for scheme in r4rs..  didnt look at r5rs or r6rs
22:14:18 <dbremner> elisp is also dynamically scoped, most newer dialects  are lexically scoped.
22:14:47 <lispy_> what are formal semantics?
22:14:53 <wagle> my hello world programs are scheme interpreters
22:15:05 <dons> heh
22:15:36 <wagle> really interesting in java..  wasnt very interesting in haskell
22:15:47 <dbremner> dons - http://www.appsolutions.com/SchemeDS/ is this what you mean?
22:15:56 <wagle> couldnt figure out how to use classes, so didnt.  result was boring
22:16:05 <wagle> i have hopes for hlists, though
22:16:21 <dbremner> wagle - Peter Norvig wrote a decent scheme in Java.
22:16:46 <wagle> dbremner: yeah, i just saw that he did that earlier today
22:17:04 <dons> well, I guess a formal implementation is reasonable, I was thinking more of some operational semantics with greek letters, but this would do I'd say
22:17:28 <dons> oh, there's also some .pdfs cool
22:17:36 <wagle> but lispy_ 's problem is that he wants to be able to run emacs's vast library of elisp
22:17:49 <wagle> which is NOT scheme
22:17:55 <lispy_> hehe
22:18:05 * lispy_ will never get there at this rate
22:18:13 <dons> ok, so an implementation of elisp, harder, since you have no reference on how the language is defined?
22:18:20 <lispy_> if i want to implement lambda, i'm not actually sure how i should do it
22:18:40 <lispy_> dons: i have a reference implementation tho, and even the source code if needed
22:19:24 <lispy_> i'm thinking that my interpreter needs a function that takes the current environment, plus the lambda's list and then does X.
22:20:06 <lispy_> actually, i guess it doesn't really need to do anything unless the lambda is being evaluated
22:20:20 <lispy_> and evaluating a lambda is something i think i can figure out.....
22:20:38 <sh10151> wagle: have you considered learning awk?
22:20:41 <sh10151> ;)
22:20:52 <wagle> why awk?
22:21:05 <sh10151> I would like to see a scheme interpreter implemented in awk
22:21:07 <lispy_> dons: i'm also hoping that i will only have to implement the core of elisp and just use all the existing elisp code
22:21:10 <dons> lipsy, maybe check out some of the books on  implementing fp languages
22:21:10 <sh10151> for the sheer shock value
22:21:11 <wagle> ahahahahaahaha
22:21:25 <lispy_> dons: yeah, i'm staring at SICP at the moment
22:21:36 <lispy_> dons: i don't have very good library access here :(
22:21:37 <dons> SPJ  has written a couple, on line for free. Also Bob Harper has a textbook online
22:22:01 <wagle> i think eopl might be better for writing interpreters
22:22:11 <dbremner> lispy - Anatomy of Lisp discusses implementing a dynamically scoped lisp.
22:22:55 <dons> lispy, here's some references: http://www.cse.unsw.edu.au/~cs3161/References.html
22:23:28 <dons> but you probably want a lisp-specific book, perhaps
22:23:43 <wagle> main thing is that you need two kinds of application: (1) lambda (2) primitive operations
22:24:03 <lispy_> i have primitive :)
22:24:13 <lispy_> i have car, cdr, +, and a few others
22:24:34 <lispy_> and i think i understand lambda application, so i'm going to go try that
22:25:49 <vikasg> lispy, you writing lisp interpreter in Haskell
22:25:53 <vikasg> ?
22:27:10 <lispy_> vikasg: yes
22:27:25 <wagle> you evaluate each of the elements of the application.  if the first (function) element is a lambda, then you evaluate the body of the lambda in the current environment extended by the formals of that lambda and the values of the rest of the application.
22:27:28 <lispy_> dons: thanks for the pointers to references
22:27:55 * vikasg was thinking of writing a Scheme interpreter
22:28:10 <lispy_> wagle: my eval function already does something similar
22:28:19 <wagle> thus in dynamic binding, you extend the environment of the call site.  in static binding, you extend the environment of the defining site of the lambda.
22:28:36 <lispy_> wagle: but i think i need to reimplement it for lambdas because it's going to be a bit different
22:29:15 <wagle> so in scheme, the lambda evaluates to a "closure" value that drags the environment around.  there is no environment dragging around in elisp
22:29:33 <lispy_> wagle: okay, and for now i'm just using a list of Bindings for my environment.  [Binding "symbol" value functionbinding]
22:30:00 <cm> wagle: elisp uses dynamic binding only/by default?
22:30:01 <lispy_> and extending it, means just adding on to that list
22:30:02 <cm> :O
22:30:09 <lispy_> cm: only
22:30:20 <lispy_> cm: it's older than the argument to switch to lexical binding
22:30:21 <cm> woah
22:30:38 <wagle> cm..  they decided to move to scheme many years ago..  hasnt happened yet, though.
22:30:53 <lispy_> wagle: i don't think RMS was actually ever happy about that
22:31:04 <cm> RMS is weirder than i thought :-)
22:31:16 <lispy_> RMS is set in his ways technologically
22:31:38 <lispy_> but it would also take a great deal of effort to "fix" all the existing elisp code
22:31:49 <wagle> i saw an argument for dynamic binding for elisp somewhere..  i dont remember any details, though
22:32:33 <cm> i guess it's cool for all the globals.. but, strange. :)
22:32:43 <wagle> i remember the pain debugging accidental name collisions was though
22:33:11 <lispy_> wagle: the application of the lambda may modify the environment, so using a state monad for the environment would be a good idea wouldn't you say?
22:33:53 <lispy_> i guess for now maybe it's easier to just thread it
22:34:36 <wagle> no, its the environment monad..  you need to unwind when you return from functions
22:35:43 <lispy_> there  is an environment monad?
22:35:53 <wagle> its just that application reads the environment, and not lambda evaluation
22:36:38 <wagle> yeah, there's an environment monad..  it unwinds the extensions to the environment
22:36:55 <wagle> the state monad wouldnt unwind
22:37:16 <lispy_> yeah :(
22:37:28 <wagle> if you hacked in an explicit unwind, you'd lose tail recursion, i think
22:37:52 <lispy_> not sure that matters to elisp which has a maxium recursion depth
22:38:22 <lispy_> well, okay that makes it seem even more necessary, but i doubt emacs optimizes for tail recursion
22:38:50 <wagle> classier to use the environment monad..  >)
22:39:45 <lispy_> true, i think i'll implement it in the naive way first and then fix it up to do unwinding via the environment monad
22:40:10 <wagle> i bet you spend a lot of time getting the unwinding right
22:40:38 <lispy_> i'm not even going to implement it at first
22:40:52 <lispy_> i'll wait to implement that when i start using the environment monad
22:41:04 <lispy_> baby steps.....
23:17:51 <Korollary> @pl interact $ unlines . (filter (\x -> not (Data.Set.member x myDict))) . lines
23:17:53 <lambdabot> interact (unlines . filter (not . ((Data . Set) .) . flip member
23:17:53 <lambdabot> myDict) . lines)
23:18:09 <Korollary> @pl interact $ unlines . (filter (\x -> not (member x myDict))) . lines
23:18:10 <lambdabot> interact (unlines . filter (not . flip member myDict) . lines)
23:26:41 <lispy_> well, i have lambda, but it doesn't have an implicit progn
23:27:39 <lispy_> i think to get that i need to switch to using the environment monad
23:27:54 <lispy_> I'll need to thread the env through the body of the lambda
23:28:11 <lispy_> and then unwind it when the lambda is done
23:51:44 <Leimy> anyone around who can critique/improve some simple code I wrote?
23:52:04 <Leimy> it's  small utility to wrap ssh-agent, parse out the bits of the string I care about and do something not terribly secure with it :)
23:52:08 <Leimy> but convenient :)
23:52:31 * lispy_ wonders if he should comment on security
23:52:37 <Leimy> heh
23:52:43 <lispy_> do you use ssh keys?
23:52:48 <Leimy> sometimes
23:52:52 <Leimy> not for everything
23:53:13 <lispy_> what are you doing with ssh-agent?
23:53:18 <Leimy> running it.
23:53:21 <Leimy> reading the output
23:53:25 <Leimy> creating a symlink
23:53:36 <Leimy> so that programs on Mac OS X can find the ssh-agent socket
23:53:56 <Leimy> so, basically you have to have that environement stored in .MacOSX/environment.plist
23:54:41 <Leimy> what I'm more interested in is the Haskell I wrote to do all of ht above
23:54:42 <lispy_> so you can ssh once, and then all your other shells will not need a password?
23:55:12 <lispy_> i'm not good enough with haskell to comment on it :(
23:55:15 <Leimy> you can run ssh-agent... authenticate 1 time for the session and ssh-agent will be used to access the keys
23:55:32 <Leimy> so it decrypts my local key and uses it for authentication on remote machines
23:55:47 <Leimy> actually... it proabably holds the decrypted keys when I run ssh-add :)
23:57:17 <lispy_> w00t!
23:57:22 <Leimy> one that has me a bit concerned is
23:57:24 <Leimy> trim
23:57:26 <lispy_> lambda with implicit progn
23:57:39 <lispy_> @hoogle trim
23:57:42 <Leimy> trim s = dropWhile isSpace (reverse (dropWhile isSpace (reverse s)))
23:58:09 <lispy_> @vixen are you still here?
23:58:12 <lambdabot> i'm here
23:58:12 <Leimy> I wonder haw good that is :)
23:58:21 <Leimy> her how
23:58:51 <Leimy> damn... wine's kickin in
23:58:53 <Leimy> can't type
23:58:54 <Leimy> :)
23:59:03 <lispy_> wel, you reverse the list, that's O(n), then  you start a traversal, then you reverse it again O(n), then you start a similar traversal, so it's O(n)
23:59:13 <Korollary> why not use Text.Read
23:59:25 <lispy_> @type Text.Read
23:59:31 <lambdabot> bzzt
23:59:41 <lispy_> @hoogle Text.Read
23:59:42 <lambdabot> Prelude.undefined :: a
23:59:42 <lambdabot> Prelude.minBound :: Bounded a => a
23:59:42 <lambdabot> Prelude.maxBound :: Bounded a => a
23:59:43 <Leimy> Korollary: cuz I'm too new to know that existed? :)
