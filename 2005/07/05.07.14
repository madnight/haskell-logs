00:00:07 <dons> maybe the same people who love GNU makefiles :)
00:00:19 <ozone> maybe ask some of these "debian people", they seem to love doing pointless things all the time.  snigger snigger
00:00:44 <ibid> pointless programming are haskeller's forte :)
00:00:47 <dons> yeah. I have a release script for most projects -- that helps a lot.
00:00:56 <ozone> ibid: touche!
00:01:05 <dons> @pointless ozone
00:01:06 <lambdabot> ozone
00:01:09 <dons> !
00:01:12 <ozone> ipso facto, oleg would like to manage releases
00:01:14 <SyntaxNinja> ozone: debian ppl are crack like that. and btw, I climb often with lots of ladies... I don't think they're climbing over each-other, though... and come to think of it, they dont' look like they're climbing to get to me... hmm...
00:01:19 <ozone> SyntaxNinja: hahahaha
00:01:28 <ozone> SyntaxNinja: i just thought ... "hey, go ask alexander jacobson ..."
00:01:57 <SyntaxNinja> were you laughing at your own, yet-to-be-spoken thought, then?
00:02:02 <ozone> yes
00:02:05 <SyntaxNinja> hehe
00:02:06 <ozone> i do that quite a lot, ask dons
00:02:28 <dons> he's a silly boy, this is true.
00:02:49 <SyntaxNinja> and I thought you were laughing at me.
00:02:50 <SyntaxNinja> with me, that is.
00:02:54 <SyntaxNinja> i mean, at my joke
00:02:54 <SyntaxNinja> .
00:02:56 <SyntaxNinja> not my expense.
00:03:20 <dons> I'm still pondering the implications of that joke
00:03:20 <SyntaxNinja> so stop me if you've heard this one...
00:03:59 <SyntaxNinja> someone came up to me and said, "Hey, how are you"? ... "fine" ... "How's the blood pressure?" ... "fine." ... "How would it be if I said ALEXANDER JACOBSON!!"
00:04:50 <ozone> @karma+ AndyMoran
00:04:51 <lambdabot> AndyMoran's karma raised to 1.
00:06:24 <Lemmih> @seen alexj
00:06:25 <lambdabot> I saw alexj leaving #haskell 13 days, 6 hours, 58 minutes and 41
00:06:25 <lambdabot> seconds ago, and I have missed 2 days, 22 hours, 26 minutes and 15
00:06:25 <lambdabot> seconds since then.
00:06:31 <SyntaxNinja> <chirp> <chirp>
00:07:18 <dons> silly lambdbot's seen state seems to go wonky sometimes for some people
00:07:33 <SyntaxNinja> aww, alex knows we're cool... and he probably knows that he raises my blood pressure.
00:07:36 <ozone> when in doubt, blame the GHC RTS
00:07:50 <dons> @remember ozone when in doubt, blame the GHC RTS
00:07:57 <dons> that's almost zippy-ish
00:08:17 <dons> I'll stg_ap_ret_p you!
00:08:28 <ibid> i blame the GHC RTS for this heat wave
00:08:36 <dons> @temp
00:08:38 <lambdabot>  @help <command> - ask for help for <command>
00:08:44 <dons> oh, no temp in #haskell
00:08:55 <dons>  now 15.8°
00:09:00 <dons> not hot at all ;)
00:09:17 <ibid> it's been near 30 degrees here for many days
00:09:23 <ibid> today is a little cooler, only 22 or so
00:14:20 <SyntaxNinja> OK. I'm going to bed. let me know if you need help recovering from my jokes.
00:16:03 <Lemmih> G'night.
00:16:13 <Itkovian> If anybody recalls the problem I had yesterday compiling darcs, it seems like the bug's due to using gcc-4.0.0 (macosx tiger)
00:17:03 <Itkovian> with 4.0.
00:17:14 <ozone> Itkovian: __DISCARD__ ?
00:17:28 <Itkovian> grr ... with 4.0.0 there is on extra symbol, i.e. ___DISCARD__ that is not present when using gcc-3.3
00:17:33 <Itkovian> ozone: idd
00:17:37 <ozone> right
00:17:42 <ozone> yes, use -fasm instead
00:17:43 <ozone> or gcc 3.3
00:17:45 <ozone> or GHC head
00:17:54 <Itkovian> ok
00:18:22 <Itkovian> ozone: I've no idea how to tell ghc to use gcc-3.3
00:18:37 <Itkovian> aliasing gcc to gcc-3.3 doesn't exactly help either
00:18:59 <ozone> sudo gcc_select 3.3
00:19:15 <ozone> or i think you can do -pgmc gcc-3.3 with ghc
00:19:17 <Thu16236> i hope it will cool down and rain here
00:19:43 <Itkovian> -fasm doesn't seem to help
00:20:02 <ozone> Itkovian: if you have any optmisation or profiling flags, make sure you put -fasm after those flags
00:20:07 <Itkovian> ok
00:20:14 <Itkovian> next try
00:20:14 <ozone> since -O et al use -fvia-c by default
00:21:07 <Itkovian> nah, will try gcc-select ... grmbl.
00:21:47 <pejo> Itkovian, for me (Solaris) ghc picks 'gcc' that is first in path.
00:22:07 <Itkovian> pejo: well, that's probably true here as well
00:30:19 <Gahhh> there was a --with-gcc option for configure, iirc.
00:33:07 <Thu16236> too bad UUAG doesn't support the syntax;
00:33:10 <Thu16236> lhs . bla | <<cond>> = ...
00:33:18 <Thu16236>             | otherwise = ....
00:33:29 <Thu16236> looking at the generated code, it should be possible
00:37:05 <Thu16236> now i have to do a buttugly case
00:38:40 <Thu16236> is this where i should blame the RTS?
00:39:50 <dons> @quote ozone
00:39:52 <lambdabot>  when in doubt, blame the GHC RTS
00:42:55 <jlouis> @hoogle isPrefixOf
00:42:57 <lambdabot> List.isPrefixOf :: Eq a => ([a] -> [a] -> Bool)
00:44:14 <Thu16236> what does hoogle do?
00:44:45 <Thu16236> searches where a function resides and gives the type in addition to the location?
00:44:56 <Thu16236> @hoogle null
00:44:57 <lambdabot> Prelude.null :: ([a] -> Bool)
00:46:01 <dons> @hoogle a -> a
00:46:03 <lambdabot> Prelude.id :: (a -> a)
00:46:03 <lambdabot> Prelude.succ :: Enum a => (a -> a)
00:46:03 <lambdabot> Prelude.pred :: Enum a => (a -> a)
00:46:09 <dons> that's what it does!
00:46:18 <dons> (besides identifier searches)
00:46:37 <dons> @where hoogle
00:46:38 <lambdabot> I know nothing about hoogle.
00:46:42 <dons> oh. my bad
00:47:45 <dons> @where hoogle
00:47:46 <lambdabot> http://www.cs.york.ac.uk/~ndm/hoogle/
00:49:42 <Thu16236> a neat feature would be it would give all null functions instead of just Prelude.null
00:49:49 <Thu16236> that's useful i think
00:49:55 <dons> all null functions?
00:50:04 <dons> @hoogle map
00:50:05 <lambdabot> Prelude.map :: ((a -> b) -> [a] -> [b])
00:50:05 <lambdabot> List.mapAccumR :: ((a -> b -> (a, c)) -> a -> [b] -> (a, [c]))
00:50:05 <lambdabot> List.mapAccumL :: ((a -> b -> (a, c)) -> a -> [b] -> (a, [c]))
00:50:09 <Thu16236> Data.Map.null, Data.Set.null
00:50:09 <dons> @hoogle+
00:50:11 <lambdabot> Maybe.mapMaybe :: ((a -> (Maybe b)) -> [a] -> [b])
00:50:11 <lambdabot> Prelude.mapM_ :: Monad a => ((b -> (a c)) -> [b] -> (a ()))
00:50:11 <lambdabot> Prelude.mapM :: Monad a => ((b -> (a c)) -> [b] -> (a [c]))
00:50:25 <dons> oh, it doesn't search non-h98 yet, I think.
00:50:29 <dons> coming soon.
00:50:42 <Thu16236> ow ok, so it *does* do what i mean, only it doesnt search those modules yet
00:50:43 <dons> @hoogle+
00:50:44 <lambdabot> Monad.mapAndUnzipM :: Monad a => ((b -> (a (c, d))) -> [b] -> (a ([c]
00:50:44 <lambdabot> , [d])))
00:50:44 <lambdabot> Prelude.concatMap :: ((a -> [b]) -> [a] -> [b])
00:50:44 <lambdabot> Prelude.fmap :: Functor a => ((b -> c) -> (a b) -> (a c))
00:50:48 <dons> yep.
00:50:50 <Thu16236> cool
00:51:06 <dons> @hoogle (b -> c) -> (a b) -> (a c)
00:51:07 <lambdabot> Prelude.fmap :: Functor a => ((b -> c) -> (a b) -> (a c))
00:51:07 <lambdabot> Monad.liftM :: Monad a => ((b -> c) -> (a b) -> (a c))
00:51:07 <lambdabot> Prelude.map :: ((a -> b) -> [a] -> [b])
00:51:08 <Thu16236> they should definitly add non-h98 though
00:51:19 <dons> let they = ndm
00:51:21 <dons> @seen nndm
00:51:22 <lambdabot> I haven't seen nndm.
00:51:24 <dons> @seen ndm
00:51:25 <lambdabot> I saw ndm leaving #haskell 14 hours, 38 minutes and 29 seconds ago.
00:51:39 <Itkovian> ozone_: the -pgmc stuff works
00:51:41 <Itkovian> thx
00:52:09 <ozone_> Itkovian: sure
00:52:28 <Itkovian> I'll try the -fasm stuff now, with gcc-4.0
00:52:42 <Itkovian> nah
00:52:45 <Itkovian> bummer
01:15:55 <icb> ahhhh!
01:18:42 <Heffalump> ahhhhh?
01:26:27 <frederik> sweet
01:26:35 <frederik> about hoogle i mean
01:26:42 <frederik> they should have called it hahoo tho
01:33:14 <Thu16236> hahoo?
01:35:19 <Thu16236> as in ....
01:35:48 <Nioate_> yahoo
01:41:20 <genneth> how 'bout "hahoohle"?
01:42:04 <Nioate_> I was thinking hayoo after frederik's comment
01:43:06 <Thu16236> wow that uuag USE-copyrule really kicks ass in gathering error messages with minimal effort, because the gathering is handled automatically
01:48:34 <frederik> oh, hoogle doesn't pay attention to the value of type variables? or what? i search for: (c -> d -> c) -> c -> (m d) -> c and it comes up with foldl and foldr::(a -> b -> b) -> b -> [a] -> b
01:49:26 <frederik> maybe it reorders function arguments?
01:49:57 <frederik> ah it says so in the help text :)
01:56:29 <Thu16236> but those types perfectly unify don't they?
01:57:23 <Thu16236> ow wait
01:57:25 <Thu16236> nm
01:58:21 <Thu16236> how can it suggest foldr ....hmm
01:58:42 <Thu16236> does it look merely at shape?
02:07:24 <frederik> it reorders function arguments
02:09:11 <Thu16236> but the correspondence of the c's are lost then....
02:09:33 <bourbaki> hi
02:15:11 <astrolabe> Thu16236: Why do you say that?
02:16:07 <bourbaki> what would you think is a function in haskell that maps to a single element and has as input some functions and some values a tensor?
02:20:55 <ski> tensor ?
02:21:22 <bourbaki> do you know the dual of a vector space?
02:21:28 <bourbaki> V*
02:21:47 <bourbaki> that is V -> R
02:23:33 <astrolabe> bourbaki: I understand tensors, but I can't parse your question
02:24:09 <bourbaki> well
02:24:20 <bourbaki> if you have something like
02:24:56 <jyp> was it "What is a function that maps to a single element and has as input some functions and some values? A tensor?"
02:25:05 <bourbaki> Fn_1 x ... x Fn_n x Input_1 x ... x Input_n -> Element_Foo
02:25:20 <bourbaki> then this looks roughly like a tensor to me
02:25:50 <ski> why ?
02:25:53 <bourbaki> its just that we are missing the underlying structure for these functions right now
02:26:06 <ski> what are Fn_1 etc ?
02:26:19 <bourbaki> Fn are some functions that dually pair with Input
02:26:56 <ski> itym Fn_X are *types* of some functions ...
02:27:10 <bourbaki> V* behaves like functions in haskell to me that is you can pair it with an elements of the domain and it gives you the putput
02:27:10 <ski> (or sets, if you like)
02:27:31 <bourbaki> Fn are functions yes (a -> b)
02:27:40 <ski> putput ?
02:27:44 <bourbaki> input :)
02:27:50 <bourbaki> er
02:27:50 <ski> in... ? out.. ?
02:27:51 <ski> ok
02:27:51 <bourbaki> output
02:27:54 <bourbaki> sry
02:27:55 <ski> heh
02:27:56 <astrolabe> jyp:  Thanks.  Is the code for that parser available?
02:28:41 <bourbaki> well i am just wondering about all this cause it would be trilling to apply some of the knowledge of topology to programming
02:28:53 <bourbaki> thrilling ... dang todays not my day
02:29:25 <ski> i don't see how that function would be a tensor (but then, i possibly don't understand what you mean by tensor)
02:29:45 <bourbaki> well you know what the dual space is right?
02:30:02 <bourbaki> some vector space V and its dual V* (V -> |R)
02:30:23 <ski> bourbaki : re topology in haskell http://www.haskell.org/pipermail/haskell/2004-June/014134.html :)
02:30:34 <bourbaki> ow let me check
02:30:35 <ski> vaguely, yes
02:30:56 <bourbaki> i have for example written a small 3d lib with math stuff
02:31:17 <bourbaki> then if i wanted to use the dot product i take a vector and build its dual space
02:31:17 <ski> bourbaki : but that may possibly not be in the way that you think. but it's still interesting (though i'm completely lost somewhere in later chapters :)
02:31:23 <bourbaki> thats like lifting it
02:31:44 <bourbaki> so V -> V* and then you can apply a new vector and get the dot product
02:31:53 <bourbaki> with that i define matrix multiplication and so on
02:31:59 <ski> hmm
02:32:21 <ski> intresting
02:32:23 <bourbaki> in this case its all pretty straight forward cause its all linear algebra but this looks really cool
02:32:34 <bourbaki> very short and pregnant
02:33:05 <bourbaki> now i just wonder if one maybe able to find a way to apply these things in general that is you define a structure that you want your Hom sets on
02:33:12 <bourbaki> Hom(V,|R) = V*
02:33:35 <bourbaki> that is once you have a structure we could try to think of programs topologically
02:33:35 * ski wonder why the '|' ..
02:33:52 <bourbaki> well cause it looks more like the thingy in the books :)
02:34:06 <bourbaki> |N, |R and so on
02:34:07 <ski> aha, just a fat/bold R ..
02:34:11 <bourbaki> yes
02:34:17 <astrolabe> Tensor products appear as adjoint functors to hom functors in categories of vector spaces.  maybe you are talking about some more general adjoint functors?
02:35:11 <bourbaki> well my book simply says
02:36:13 <bourbaki> T: V*_1 (*) ... (*) V*_n (*) V_1 (*) ... (*) V_n -> |R
02:36:15 <ski> astrolabe : hm, which hom functor is that ..  C^op -> Set ?
02:36:36 <astrolabe> ski: no
02:36:41 <ski> the difunctor one ?
02:36:52 <bourbaki> where this is a multilinear function
02:37:14 <astrolabe> In tthe category of vector spaces over some field
02:37:58 <astrolabe> oh ski I may have spoken to quickly when I said 'no'.  Let me think.
02:38:03 <ski> astrolabe : just wondering what the types (dom and cod) of the functors you mentioned was ..
02:38:22 * ski has forgotten what multilinear is
02:38:47 <bourbaki> like the Det
02:38:56 <ski> ?
02:39:01 <bourbaki> when you exchange two elements then it changes sign
02:39:17 <bourbaki> if the elements are not linear independant then its 0
02:39:35 <bourbaki> and i think there was something else that i cant remember atm :)
02:40:05 <ski> hm
02:41:08 * ski is reminded of monad comonad duel again ..
02:41:43 <Thu16236> a bit late but; when hoogle gives (a -> b -> b) -> b -> [a] -> b when asking for (c -> d -> c) -> c -> (m d) -> c, the connection between the c's are gone no?
02:43:04 <ski> Thu16236 : i think hoogle just swapped the order of the 'c' and 'd' in the argument function (and then renamed '[d |-> a,c |-> b]' and generalized '[]' to 'm')
02:43:17 <astrolabe> ski: Both functors go from the category of vector spaces over some field k, to itself.
02:43:32 <ski> Thu16236 : what do you mean by 'the connection between the c's are gone no?' ?
02:43:50 <astrolabe> The left adjoint takes a vector space V to W \otimes V
02:43:54 <ski> astrolabe : ok, so they're endo
02:44:33 <astrolabe> The right adjoint takes U to Hom(W,U)
02:44:36 <ski> astrolabe : but, hm, i was under the impression that Hom functors went to Set (at least in non-internal categories) ..
02:44:38 <astrolabe> ski: right.
02:45:14 <astrolabe> You can set up other targets for hom.  See for example abelian categories.
02:45:32 <Thu16236> ski, well because if the connection of the c's would be respected....every occurence of c should have been renamed to b
02:45:42 <bourbaki> the Hom set are all functions from the first element to its second that are homomorphisms
02:46:23 <ski> e.g. functor Hom_C(A,-) for some cat C with obj A, maps obj B in C to the Set obj that is the morphism class from A to B, in C
02:46:28 <astrolabe> Thu16236:  It is isn't it?
02:47:14 <ski> astrolabe : in your case, Hom(W,U) is an obj in Vect, yes ?
02:48:09 <astrolabe> ski: Yes.
02:48:44 <ski> Thu16236 : every c has been renamed to b, but the argument function type 'b -> a -> b' (renamed from 'c -> d -> d') *also* has had it's argument swapped to 'a -> b -> b'
02:49:11 <ski> astrolabe : how do we make it into a vector space ?
02:49:39 <ski> (astrolabe : i guess this might well be basic questions in this field :)
02:50:14 <astrolabe> The key point is that a linear map from W \otimes V is essentially equivalent to a bi-linear map from W \time V, which is essentially equivalent to a linear map from V into the linear maps from W.
02:50:37 <ski> (anyway, as iv'e currently seen Hom used, it's only for getting a morphism class, not also enriching that with some structure (well, almost :))
02:51:51 <bourbaki> hm i just wonder how i can do the crossproduct of vectors with this
02:51:52 <ski> hmhm
02:52:02 <astrolabe> ski:  Given f,g:W->U and k \in K, Define (f+g)(w) = f(w)+g(w) and (kf)(w) = k(f(w))
02:52:35 <bourbaki> crossproduct is the exterior product but that wont fit in the notion i have yet cause in not mapping to the codomain again
02:52:38 * ski guesses he has to read up on what exactly linearity bi-linearity means (think i know the first one more or less)
02:53:14 <bourbaki> ski http://en.wikipedia.org/wiki/Bilinear
02:53:51 <ski> astrolabe : oh, just a reader/environment monad :) (i should have remembered this i think)
02:54:22 <astrolabe> bourbaki.  There is a determinent tensor D : V \otimes V \otimes V-> R.  The cross product is the dual of \x -> D(v,w,x)
02:54:29 <ski> astrolabe : hm, but what is K ?
02:55:09 <astrolabe> ski:K is the field
02:55:37 <astrolabe> and bilinear means if you fix either of the two arguments, it is linear in the other.
02:55:39 <bourbaki> astrolabe how does that yield a vector?
02:57:29 <astrolabe> bourbaki: Well \x-> D(v,w,x) is in V* and dualising is a map V* -> V (got from the dot product).
02:58:21 <ski> (astrolabe : sorry, read the last scalar mult as if you applied k to f(w) ..)
02:58:27 <bourbaki> so you dualize to Hom(Foo,V) ?
02:58:48 <bourbaki> cause my book explicitly sayd you map to |R
02:59:35 <astrolabe> V*  = Hom(V,R)
02:59:54 <bourbaki> yes
03:00:03 <bourbaki> but whats V* -> V then?
03:00:06 <astrolabe> Dual :: V* -> V
03:00:17 <bourbaki> the dual of the dual?
03:00:29 <astrolabe> bourbaki right
03:00:33 <astrolabe> The inverse of the dual
03:01:15 <astrolabe> There is a natural equivalence V** ~ V
03:01:30 <bourbaki> yep
03:01:40 <bourbaki> isomorphism
03:01:46 * ski seems to recall this
03:01:49 <astrolabe> I guess that is why it is called a dual
03:02:21 <bourbaki> hm but how would i implement this
03:02:28 <bourbaki> the dot product is just like this
03:02:41 <astrolabe> bourbaki:  You got me.  I'm a newbie
03:02:41 <bourbaki> foo :: V -> V*
03:03:00 <bourbaki> where V* is just V -> Float
03:03:06 <Thu16236> @plugs flip (,) (1,2)
03:03:12 <lambdabot> <Plugins.Eval>:1:
03:03:12 <lambdabot>   No instance for (Show (a -> (a, (t, t1))))
03:03:12 <lambdabot>   arising from use of `show'
03:03:16 <bourbaki> and foo would like like this
03:03:22 <Thu16236> @plugs flip (uncurry (,)) (1,2)
03:03:23 <lambdabot> Couldn't match `b -> c' against `(a, b1)'
03:03:39 <Thu16236> @plugs flip (curry (,)) (1,2)
03:03:41 <lambdabot> <Plugins.Eval>:1:
03:03:41 <lambdabot>   No instance for (Show (a -> b -> ((a, (t, t1)), b)))
03:03:41 <lambdabot>   arising from use of `show'
03:03:41 <ski> @type flip (,) (1,2)
03:03:42 <bourbaki> well it just generates a function that picks a vector and returns the dot product
03:03:46 <lambdabot> forall a a1 b.
03:03:46 <lambdabot>       (Num a1, Num b) =>
03:03:46 <lambdabot>       a -> (a, (a1, b))
03:03:56 <astrolabe> How about setting up functors taking V to V** and V** to V?
03:04:02 <Thu16236> @type uncurry
03:04:03 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
03:04:24 <bourbaki> astrolabe well wait a sec lets just see how it works for the dotproduct thingy
03:04:30 <Thu16236> @plugs uncurry (flip (,)) $ (1,2)
03:04:32 <lambdabot> (2,1)
03:04:46 <bourbaki> so the function that was yielded by the foo thingy is then
03:04:54 <bourbaki> V* -> V -> R
03:04:55 <astrolabe> bourbaki: LOL .  Sorry, I was trying to make it easier!
03:05:11 <bourbaki> :)
03:05:27 <Thu16236> ski, swapping those arguments changes the relations between the types doesnt it?
03:05:33 <bourbaki> so the dotproduct is a tensor (1,1)
03:05:43 <Thu16236> i mean, a -> b -> a is different from b -> a -> a
03:05:54 <bourbaki> now we want to take the dual of (V* -> V) right?
03:06:04 <ski> Thu16236 : correct
03:06:07 <astrolabe> bourbaki:  No, I think dotproduct is a tensor (0,2)
03:06:18 <ski> (Thu16236 : but they are "isomorphic")
03:06:20 <bourbaki> well but i have one V* and one V
03:06:50 <bourbaki> the foo thingy transposes the vector
03:06:53 <astrolabe> But V* is (V->R) so V->V*->R is easy, no dot product needed.
03:07:13 <Thu16236> but it would involve changing the function right?
03:07:20 <Thu16236> passing the arguments in different order
03:07:28 <ski> Thu16236 : yes
03:07:38 <bourbaki> V* -> V -> R is (1,1) isnt it?
03:07:46 <Thu16236> so why is it usefull that hoogle gives these? because they are isomorphic functions
03:07:56 <Thu16236> and that's interesting knowledge?
03:08:08 <astrolabe> bourbaki: Yes.
03:08:36 <astrolabe> contract:: V->V*->R
03:08:46 <ski> Thu16236 : yes (or more specifically, it can be that one remembers argument order wrong,  or that one wants all functions that match a specific patten, no matter what exact argument order, as long as the arguments are present)
03:08:47 <astrolabe> *Contract
03:09:07 <bourbaki> ok and now i take the dual of (V* -> V) to get the crossproduct?
03:09:14 <astrolabe> Contract v f = f v
03:09:27 <bourbaki> or dual pairing
03:10:03 <astrolabe> bourbaki:  You need the alternating thing in somewhere (ie the determinant) to get the cross product.
03:10:04 <Thu16236> ski, ow right, like the common mistakes of changing the order of arguments when calling a certain function. Helium detects this and suggests you swap the arguments...this is kind of the same thing
03:10:04 <Thu16236> cool
03:10:33 <bourbaki> oh maybe
03:10:38 <bourbaki> V* -> V* -> V
03:10:45 <bourbaki> this is a bilinear map
03:10:54 <ski> Thu16236 : indeed
03:11:44 <astrolabe> CrossProd :: V->V->V
03:12:28 <bourbaki> V -> V -> V ~= V* -> V* -> V
03:12:42 <astrolabe> CrossProd u v = Dual (Det u v)
03:13:10 <bourbaki> but det yields a float
03:13:41 <astrolabe> bourbaki Det: V->V->V->R
03:14:19 <bourbaki> ah ok
03:14:24 <ski> Dual : (V -> R) -> V  ?
03:14:27 <bourbaki> so you end up with V -
03:14:30 <bourbaki> er
03:14:33 <bourbaki> so you end up with V -> R
03:14:44 <bourbaki> and the dual of V -> R is V
03:14:51 <astrolabe> bourbaki:  Yeah"
03:14:55 <astrolabe> Yeah!
03:15:10 <bourbaki> ok then lets try to put that into haskell
03:16:02 <bourbaki> well the problem is that that way
03:16:13 <bourbaki> you implicitly use the crossproduct in Det already
03:16:14 <bourbaki> that is
03:16:28 <bourbaki> (u x v) . lastvector
03:16:56 <bourbaki> so what you reatrun from Dual Det is the vector that was generated by the crossproduct
03:17:21 <astrolabe> I would recommend defining Det without using cross product
03:17:40 <bourbaki> yes but how?
03:18:12 <bourbaki> i mean whats the partial thingy after V -> V
03:18:31 <bourbaki> the function V -> R i cant imagine how it would look like but
03:19:13 <bourbaki> orthogonal_of_u_v . input -> Float
03:19:20 <astrolabe> Have you seen the form \epsilon_{ijk}  which is 1 for even perms, -1 for odd perms and zero for (i,j,k) which are not permutations of (1,2,3)?
03:20:03 <bourbaki> no
03:21:23 <astrolabe> So \epsilon_{231} =1, epsilon_{232} = 0, \epsilon_{213}=-1
03:22:06 <bourbaki> thats just bilinearity
03:22:14 <bourbaki> multilinarity that is
03:22:36 <astrolabe> Then Det u v w = sum_{i,j,k} epsilon_{ijk}u_i
03:22:47 <astrolabe> whoops hit return by mistake!
03:23:49 <astrolabe> to repeat the RHS, sum_{i,j,k}\epsilon_{ijk} * u^i v^j w^k
03:24:05 <ski> astrolabe : shouldn't there be a nice irc abbrev. for such circumstances ?
03:24:50 <astrolabe> ski: Yeah.  I'm not sure "Oh B*******s" would have been understood.
03:25:07 <bourbaki> astrolabe ok looks reasonable so you end up with a sum that has this w vectors left out
03:25:15 <bourbaki> in haskell that is
03:25:45 <astrolabe> bourbaki:  Yeah.  I don't know enough haskell to be sure though.
03:26:26 <bourbaki> ok but you see that its not that easy to return something from that that is the cross product then
03:26:34 <bourbaki> i mean you have a sum with some variables in it
03:27:00 <astrolabe> bourbaki: The sum thing is a function V->R
03:27:01 <bourbaki> and now we need to define dual of V -> R when this function is a sum
03:27:03 <cptchaos> hm, does anyone know if, there is a latex aware irc-client?
03:27:20 <bourbaki> right i see all this mathematically :) but i just wonder how to implements it really
03:27:37 <bourbaki> astrolabe if you are interested in this we could start a small thingy with all that
03:27:41 <astrolabe> bourbaki:  Yeah, I would try to define the dual of a general function V->R (and just assume it is linear).
03:27:52 <bourbaki> cptchaos i have been searching for something like that a long time
03:28:12 <bourbaki> astrolabe this sum is provably a linar map
03:28:26 <astrolabe> bourbaki: I'm very much a haskell newbie, but if you can handle that side of it.
03:28:30 <cptchaos> bourbaki: me too
03:28:34 <bourbaki> ah i think i have got it i just need to prove it on paper
03:28:45 <bourbaki> astrolabe well haskell is dead easy really
03:28:52 <astrolabe> bourbaki: Yes, it is, but I don't think dual should check its argument is linear.
03:29:08 <bourbaki> i am a newbie as well and dont care to get deeper into it as long as i can solve my probs
03:29:17 <bourbaki> astrolabe codemages.sf.net.homopoty1.hs
03:29:19 <bourbaki> dang
03:29:23 <bourbaki> astrolabe codemages.sf.net/homopoty1.hs
03:29:24 <astrolabe> bourbaki: Now you are stretching my credulity.  I'd be happy to give it a go though.
03:29:30 <bourbaki> maybe have a look at this thingy
03:29:56 <bourbaki> astrolabe thats a problem with haskell that checking thingy
03:30:12 <bourbaki> i think you have to make sure as a coder that ppl useding this only use linear maps
03:30:23 <astrolabe> bourbaki:  Was that a web link? I don't understand it.
03:30:27 <bourbaki> i also wanted to implement a topological class based on the poset from haskell
03:30:44 <bourbaki> http://codemages.sf.net/homopoty1.hs
03:31:03 <bourbaki> http://codemages.sourceforge.net/homotopy1.hs
03:31:16 <bourbaki> man today i am doing a lot of error sorry
03:31:31 <astrolabe> Ok, these links are converging to something useable :)
03:32:01 <bourbaki> the stuff i did there was not very abstract so it would need to use classes for vectors and such
03:32:28 <bourbaki> but i have a bit of a problem with these mathematical constructs cause you cant check for the side requirements
03:35:05 <bourbaki> astrolabe in the det thingy of a mat (a,b,c,d,e,f,g,h,i) /in R^3x3
03:35:11 <bourbaki> then det of this is
03:35:35 <bourbaki> a * (ei - fu) + b * (di - fg) + c * (du - eg)
03:35:38 <bourbaki> so
03:36:11 <bourbaki> Dual ( a * (ei - fu) + b * (di - fg) + c * (du - eg) ) -> ((ei - fu),(di - fg),(du - eg))
03:36:26 <bourbaki> if (a,b,c) is the vector we are searching for
03:36:27 <bourbaki> cause
03:36:49 <bourbaki> a * (ei - fu) + b * (di - fg) + c * (du - eg) = ((ei - fu),(di - fg),(du - eg)) . (a,b,c)
03:37:09 <autrijus> syb3++ # finally found time to read and grok it
03:37:28 <autrijus> answers so much of my half-formed questions about typeclass variables
03:38:21 <autrijus> I have this feeling that it may lead to an OO encoding more robust than OOHaskell
03:38:38 <autrijus> but that needs more thinking
03:38:42 <astrolabe> bourbaki:  sorry just putting my socks in the washing machine.  If there is a world sock shortage, I'm sorry, it's my fault.
03:39:16 <bourbaki> heh np
03:39:33 <bourbaki> dont forget to get the socks of your feet first though ;)
03:39:45 <astrolabe> bourbaki: Doh.
03:40:56 <astrolabe> bourbaki:  By the way, is your first name Nicolaus?
03:41:59 <bourbaki> nicolas ;) and no
04:03:35 <bourbaki> astrolabe http://rafb.net/paste/results/BlDxvI33.html
04:03:42 <bourbaki> ski if you are still interested
04:03:48 <bourbaki> have a look at the link as well
04:04:27 <bourbaki> maybe i should get into the class stuff some more maybe its possible to build a general system for all this for LA
04:05:11 <astrolabe> That would be best if possible.  It would be nice to have a library.
04:06:42 <bourbaki> yes but i am not too good with all the class stuff as well :)
04:07:30 <bourbaki> ok this is better
04:07:31 <bourbaki> http://rafb.net/paste/results/F74KTI31.html
04:07:39 <bourbaki> now its all defined in terms of duals
04:08:13 <astrolabe> In the first link, the (1,1,1) looks wrong
04:08:26 <bourbaki> a * (ei - fu) + b * (di - fg) + c * (du - eg) = ((ei - fu),(di - fg),(du - eg)) . (a,b,c)
04:08:36 <bourbaki> left side is the usual det
04:08:42 <bourbaki> right side is the dual notation
04:08:59 <bourbaki> so
04:09:12 <bourbaki> ((ei - fu),(di - fg),(du - eg)) is the normal of u and v
04:09:33 <bourbaki> or the normal is
04:09:44 <bourbaki> ((ei - fu),(di - fg),(du - eg)) . (1,1,1)
04:09:57 <bourbaki> no dang ...
04:10:09 <ski> (bourbaki : looking at link)
04:10:11 <bourbaki> youre right
04:10:14 <bourbaki> sec
04:10:50 <bourbaki> http://rafb.net/paste/results/AS1Efe63.html
04:10:53 <bourbaki> now thats better
04:11:10 <bourbaki> though there is no + for the vectors yet
04:11:37 <ibid> xerox: is it of any help?
04:12:26 <bourbaki> http://rafb.net/paste/results/YxYCex99.html
04:13:21 <bourbaki> in general i just need to define something that does an exterior product for all the tensors that have a form like the crossprod
04:14:14 <bourbaki> crossprod is a dual (tensor (0,3))
04:14:25 <astrolabe> Sorry, it's time for me to go to work
04:14:40 <bourbaki> heh ok
04:14:43 <bourbaki> thanks anyway
04:14:46 <astrolabe> Maybe I'll have lunch first.
04:14:49 <bourbaki> :)
04:15:07 <astrolabe> It was fun
04:15:56 <Thu16236> wow still talking about tensors o_0
04:16:12 <bourbaki> yep id like to use haskell in my 3d apps
04:16:22 <bourbaki> ski did you check it out?
04:16:32 <Thu16236> i dont know what they are to begin with :P
04:17:41 <ski> bourbaki : trying to understand it .. :)
04:18:11 <bourbaki> :)
04:18:19 <bourbaki> you have to get the last link though
04:18:26 <bourbaki> cause there was an error in the others
04:18:30 <bourbaki> http://rafb.net/paste/results/YxYCex99.html
04:18:37 <ski> have got all four :)
04:20:36 <ski> (hm, why both transpose or dual ?)
04:20:43 <ski> (s/or/and)
04:20:59 <astrolabe> I know how to define a type parameterised by a type, but can I define a type parameterised by a value?
04:21:29 <ski> that's called an indexed type
04:21:39 <ski> it's possible in dependent type systems
04:22:17 <bourbaki> ski just to emphasis that its the transpose
04:22:31 <bourbaki> if M is a matrix whats M* like then?
04:22:48 <bourbaki> is that an endomorphism on matrices then?
04:22:49 * ski has no idea
04:23:09 <pejo> Thu, http://planetmath.org/encyclopedia/Tensor.html has a quite readable explaination.
04:23:14 <ski> i thought matrices could be morphisms between vector spaces
04:23:15 <astrolabe> It is an anti-endo
04:23:33 <astrolabe> bourbaki: the dual_hm definition should be changed
04:23:42 <bourbaki> astrolabe why?
04:24:07 <astrolabe> replace the (add_Vector_Float_3D) with a comma I think.
04:24:40 <bourbaki> ah ok i right
04:25:16 <bourbaki> i made the mistake to think i had mulled it with e_i
04:26:21 <astrolabe> I see :)
04:26:34 <ski> is dual_Vector_Float_3D and dual_hm supposed to be inverses ?
04:26:49 <ski> (for linear stuff, i.e.)
04:26:56 <bourbaki> in the matrix case that i am atm thinking about its the transpose
04:27:02 <bourbaki> and in the vector case it is alsp
04:27:04 <bourbaki> also
04:27:17 <bourbaki> in order to multiply two vectors you always do this
04:27:26 <bourbaki> v^t u = v . u
04:27:37 <bourbaki> and in the matrix case
04:27:43 <astrolabe> Also maybe crossproduct u v = dual_hm \w -> det_Mat_Float_3D (u,v,w)
04:27:46 <bourbaki> M^t N
04:27:52 <ski> bourbaki : vectors seen as matrices, yes
04:28:18 <ski> (bourbaki : global elements, i.e. i think)
04:31:24 <astrolabe> ski: thanks, I guess haskell doesn't have dependent type systems?
04:32:54 <astrolabe> template haskell?
04:35:48 <ski> astrolabe : indeed it doesn't (though one can come closer than maybe expected, with the help of multi-parm typeclasses with fundeps, as well as GADTs)
04:47:14 <Thu16236> never expected Adam Curry to show up in some wikipedia page :S
04:56:19 <earthy> why not?
04:56:35 <earthy> all the world's on wikipedia
04:56:55 <Thu16236> heheh true, if complete pages on the biography of pokemons exist....
04:57:00 <Thu16236> anything's possible
04:57:11 <Thu16236> is there a wikipedia page about you earthy ? :)
04:57:57 <earthy> not that I *know* of
04:59:30 <Thu16236> hehehe
04:59:46 <Thu16236> no garanty whatsoever :D
05:02:10 <mikael> hey chris2
05:02:28 <chris2> hi mikael
05:17:50 <nothingmuch> sorry everyone... client trouble
05:44:08 <jlouis> Why does Data.Map.lookup include a Monad?
05:44:15 <jlouis> exception?
05:45:25 <ski> @type Data.Map.lookup
05:45:27 <mikael> I'd guess it returns ``return foo'' if foo is found, and fails otherwise
05:45:31 <lambdabot> forall a (m :: * -> *) k.
05:45:31 <lambdabot>        (Ord k, Monad m) =>
05:45:31 <lambdabot>        k -> Data.Map.Map k a -> m a
05:45:59 <mikael> but then, wouldn't MonadZero and mzero instead of failing be more appropriate?
05:46:06 * ski thinks that should have MonadZero, then
05:46:10 <ski> :)
05:47:55 <ski> imo, fail should just be used either for catching pattern-matching failure to give better error message, or for things in MonadZero
05:51:29 <ski> @arr
05:51:30 <lambdabot> Drink up, me hearties
05:51:46 <tomdavie> ohhhhh! It's time for spelling with pirates
05:52:05 <tomdavie> today, lambdabot is going to try and spell right...
05:52:09 <tomdavie> @arr
05:52:09 <lambdabot> Aye Aye Cap'n
05:52:14 <ski> :)
05:52:14 <tomdavie> @aye
05:52:15 <lambdabot> Maybe you meant: arr type
05:52:31 <tomdavie> hmmm... don't know what's next
05:52:35 <tomdavie> ARRRR!
05:52:39 <ski> @arrr
05:52:40 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
05:52:43 <mikael> using MonadZero instead of Maybe is really cool
05:52:59 <tomdavie> sounds like a silly idea to me
05:56:32 <trovao> hello to everyone. Could you please give me some advice on using ghc? I'm am trying to profile a program, but I just want to profile a specific function (like kdBuild, to build a KdTree, for instance). Do you know how to do that or where to get this kind of information?
05:57:09 <mikael> tomdavie: it still works just as before if you use it as a Maybe, but you can meaningfully use it as an IO, a list, a parser, et cetera
05:59:51 <Igloo> Anyone know if there's a good MIME module around?
06:01:22 <AtnNn> is there a function that prints a Show to stderr and returns it as-is?
06:01:59 <TheHunter> almost.
06:02:04 <TheHunter> @type Debug.Trace.trace
06:02:06 <lambdabot> forall a. String -> a -> a
06:03:21 <AtnNn> ty
06:04:20 <TheHunter> it's unsafe, but useful for debugging. And often doesn't help due to the inpredictablity of the evaluation order.
06:05:27 <Thu16236> using trace has actually confused me more often than helped me
06:06:34 <ski> trovao : maybe http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html can help ??
06:06:35 <Thu16236> but i guess if your just printing constants, it doesnt matter in the first place
06:06:52 <AtnNn> i made a long imperative style program into a series of dots and its not working like i thoughtit would, adding a (\a -> trace a a) in beetween helps
06:07:31 <Thu16236> ah if it imperatively handles the seperate functions than the evaluation order is static in your program
06:08:55 <AtnNn> its basically foldl f.map g.lines
06:10:36 <trovao> ski: thank you, I'll take a look at it
06:12:00 <Thu16236> does a trace flush immediately? or will you get the prints to stderr in undefined order....cause then it would still be confusing
06:12:15 <Thu16236> then later calls to trace could appear earlier
06:13:40 <AtnNn> usually stderr is unbuffered
06:13:57 <Thu16236> im just talking about the evaluation of the trace function basically
06:14:18 <Thu16236> if it is forced as soon as it is encountered...its fine...
06:15:13 <ski> when (trace s a) is forced, then s is forced, i think
06:18:46 <Thu16236> @plugs foldl (\b a -> flip (:) b . Debug.Trace.trace (show a) $ a) [] [1..10]
06:18:47 <lambdabot> Variable not in scope: `Debug.Trace.trace'
06:19:01 <Thu16236> @plugs foldl (\b a -> flip (:) b . trace (show a) $ a) [] [1..10]
06:19:02 <lambdabot> Variable not in scope: `trace'
06:19:06 <Thu16236> ow right, no IO :P
06:19:32 <Cale> I've used trace to track down some pretty tricky bugs. You can write little wrappers around it which only print out values when certain conditions occur, which can help find testcases where an algorithm is broken.
06:21:55 <Cale> Things need to be pretty complicated before I'd consider using it though, because for small programs, it's usually easier just to examine them carefully by hand.
06:40:01 <ndm> have you seen lazy assertions, they can be "a bit like trace" - but they don't break lazy evaluation
06:41:16 <AtnNn> no, what are those?
06:41:56 <ndm> http://scholar.google.com/scholar?hl=en&lr=&q=lazy+assertions+author%3AChitil&btnG=Search
06:41:58 <ndm> first paper
06:42:03 <ndm> you have an assert function
06:42:14 <ndm> assert :: (a -> Bool) -> a -> a
06:42:28 <ndm> but if the subject of the assertion is not required, it is not evaluated
06:42:41 <ndm> so the behaviour of your program does not change
06:42:46 <AtnNn> cool
06:42:50 <ndm> unlike trace and GHC's assert which alter the program
06:50:07 <kosmikus> re lazy assertions: sadly, I'm not convinced they're helpful
06:51:54 <ndm> kosmikus: not generally maybe, but in specific cases
06:52:14 <ndm> often you have a bug thats being invoked under some circumstance, so you want to trap it
06:52:31 <ndm> if your assertion is strict, the nature of the program changes - which is bad for debugging
06:52:50 <kosmikus> it's a minor change of the program
06:53:06 <kosmikus> can affect runtime, but so can assertions in general
06:53:31 <ndm> strict vs lazy is sometimes quite important
06:53:48 <ndm> but yeah, in most real context's probably not _that_ important
06:54:02 <kosmikus> oh, I can imagine contexts where you depend on laziness
06:54:17 <kosmikus> but I'm not sure if I'd need a strict assertion in such a context
06:54:28 <kosmikus> usually you want to assert something about things that you'll evaluate sooner or later
06:55:15 <ndm> there are a few examples in that paper which give clear situations where strict assertions just wouldn't be acceptable
06:55:59 <ndm> i.e. assert that all the prime numbers are ordered
06:56:08 <Thu16236> forgive me if i've asked this before kosmikus, but is it normal for lhs2tex codeblock to indent w.r.t. the rest of the text?
06:58:47 <kosmikus> I think you used to ask me how to indent it
06:59:06 <kosmikus> but yes, I think it's normal
06:59:25 <kosmikus> and I think it's using \mathindent
07:00:41 <kosmikus> ndm: true, but with lazy assertions you have to really watch out how you phrase you assertion, otherwise it might never get evaluated
07:01:21 <ndm> kosmikus: also true, but i think that problem is being investigated and solved
07:01:27 <kosmikus> not exactly nice either; you want assertions to have guarantees in certain parts of your program; now you have to watch out that you actually evaluate enough for the assertion to get triggered, otherwise you don't have this guarantee
07:01:50 <kosmikus> well, there's a new paper, but I'm not convinced it's a good solution
07:02:21 <ndm> kosmikus: assertions are nice, but i think whether people want lazy or strict is undecided yet
07:02:38 <ndm> ideally you want lazy to stop non-termination, but strict otherwise
07:03:27 <kosmikus> ndm: I think there's really no good way to have assertions in a lazy language without affecting evaluation
07:04:02 <ndm> kosmikus: unless you could check them statically - but that's a whole different area
07:04:17 <kosmikus> yes, that's nice
07:04:25 <kosmikus> then they're not assertions anymore
07:05:06 <kosmikus> interestingly, in languages like Epigram, where you can check some of these things statically using dependent types, there are also reasons (albeit different ones) to abandon lazy evaluation
07:05:25 <kosmikus> tim sheard's omega is also strict afaik
07:05:26 <ndm> doesn't epigram guarantee termination under any evaluation order though?
07:05:49 <ndm> i know Turner's Total Functional Programming does - making lazy vs strict a performance issue
07:05:55 <kosmikus> possibility of general recursion in epigram is under discussion or even implemented
07:06:06 <kosmikus> but yes, in the original prototype you couldn't write non-terminating programs
07:06:56 <ndm> if general recursion is permitted, doesn't that only proof properties if termination happens
07:07:02 <kosmikus> ok, maybe I shouldn't say "you don't want laziness", but rather "you don't want bottom as an inhabitant of any time"
07:07:09 <kosmikus> any type <- any time
07:07:31 <dblhelix> kosmikus: can possibly non-terminating programs (under the new implementation) be used in types in Epigram?
07:07:51 <kosmikus> if you're using general recursion, you get less guarantees, but you only *have* general recursion when you explicitly select it
07:08:10 <kosmikus> so parts of your program relying on general recursion will be flagged much like IO-parts in Haskell programs
07:08:20 <ndm> ah, the non-termination monad
07:08:23 <ndm> i've seen some of that
07:08:42 <kosmikus> dblhelix: not sure what's possible, I've not looked at the implementation for quite some time
07:09:16 <kosmikus> dblhelix: only place I've seen "general" in action is in the paper Conor and Thorsten had submitted to ICFP
07:09:33 <kosmikus> I've heard them discuss it several times, too
07:09:53 <kosmikus> swiert would probably know more ...
07:09:55 <dblhelix> kosmikus: the 'why DT's matter' paper?
07:10:02 <kosmikus> yes, that one
10:17:12 * genneth is frightened by the silence
10:17:59 * basti_ is not
10:19:06 * shapr is thinking about unicycling 
10:19:12 * basti_ is not
10:19:25 <autrijus> (SII(S(K(S(S(K(SII(S(S(KS)(S(K(S(KS)))(S(K(S(S(KS)(SS(S(S(KS)K))(KK)))))
10:19:41 <Akshaal_> what is it?
10:19:50 <basti_> autrijus: increment?
10:19:53 * TheHunter reminisces about @moo
10:20:13 <autrijus> basti_: the beginning of the prime number generator in lazy k
10:20:20 <basti_> autrijus: omfg.
10:21:02 <shapr> Hey autrijus, did I ask what you thought about per-token non-strict metaprogramming in Secret Joy?
10:21:59 * shapr doesn't remember
10:22:12 <autrijus> shapr: e a Profile hub with 175mm cranks, a Large Marge 65mm rim, Endomorph 3.7 inch tire, gb4 custom frame?
10:22:21 <shapr> er, Secret Joy the language design =)
10:22:40 <shapr> I thought up part of it, Greg Buchholz thought up part of it.
10:22:47 <autrijus> no, you didn't say.
10:22:56 <autrijus> I grok Joy a bit.
10:23:02 <autrijus> so you want to do what to Joy?
10:23:50 <SyntaxNinja> if this were a different channel, I'd /topic autrijus: so you want to do what to Joy?
10:24:09 <SyntaxNinja> er, I mean... good morning
10:24:12 <shapr> Basically, metaprogramming in Lisp/Scheme requires consuming a whole sexp to do anything, but a purely concatenative language can consume per-token. So I wonder if there are advantages in the much finer granularity you'd get from non-strict per-token metaprogramming.
10:24:41 <autrijus> good morning, semantic ronin.
10:24:45 <shapr> haha
10:25:35 <SyntaxNinja> ... /topic  autrijus: so you want to do what to Joy? ... shapr: blah blah blah sexp blah blah blah
10:26:14 <autrijus> shapr: it is the same as if you do ski level metaprog though, no?
10:26:35 <shapr> SyntaxNinja: haha!
10:27:05 <SyntaxNinja> sorry, been hanging out on #orlug too much
10:27:23 <SyntaxNinja> lispyoncrack knows what I'm talking about.
10:27:32 <autrijus> shape: ... consuming ... sexp ... do anything ... advantage ... get ...
10:27:39 <autrijus> s/shape/shapr/
10:27:50 <autrijus> hm, what is this orlug?
10:27:55 <shapr> autrijus: I'm not sure. Possibly so. All the joy ops could be considered combinators, that's pretty much how concatenative languages work.
10:28:11 <autrijus> right.
10:28:20 <autrijus> so as such I doubt it will be more expressive.
10:28:27 <autrijus> and as such I don't think it's token level per se
10:28:44 <autrijus> it's just more primitively decomposed
10:29:07 <SyntaxNinja> oregon linux user's group
10:29:16 <autrijus> but it's still manipulating semantic constructs; you can never manip a compile time error
10:29:20 <shapr> So you think the same advantages could be gotten from a primitive decomposition of existing code and then doing metaprogramming on that?
10:29:28 <autrijus> whereas in true tokenbased metaprogramming you can easily get bogus programs out.
10:29:33 <autrijus> shapr: yes.
10:30:40 <shapr> Basically, I want lazy Template Haskell.
10:31:12 * autrijus mumbles something about hs-plugins.
10:31:36 <shapr> Yeah, that's probably the simplest approach.
10:32:06 <autrijus> I hear that ocaml people are especially adept in that.
10:32:13 <shapr> I hope ghc-api will give profiling hooks, would be fun to genetically discover efficient TH transforms or compile-time options.
10:33:05 <Muad_Dibber> whats ghc-api?
10:33:40 <shapr> It's the fabled api into ghc itself. Lots of the internal functionality of GHC would be useful to Haskellers.
10:34:13 <Muad_Dibber> ah so, the idea is that the ghc compile functions are going to be available to us?
10:34:56 <shapr> Well, I was just wishing for a way to programmatically profile my code so I could try out a bunch of different Template Haskell optimizations.
10:36:12 <shapr> For example, you could use Template Haskell to do various things to your code, hs-plugins to dynamically reload the different results, and ghc-api to profile each result.
10:37:02 <astrolabe> What was that haskell parser I here people talking about called?
10:37:21 <astrolabe> (and good evening everyone)
10:37:30 <shapr> hiya astrolabe
10:38:21 <astrolabe> hey shapr.  I'm beginning to understand monads!
10:38:30 <shapr> yay!
10:38:34 <basti_> wow.
10:38:35 <shapr> Can you explain what you understand so far?
10:39:07 <astrolabe> I've defined Quantum a :: a->Complex
10:39:44 <astrolabe> Or probalistic a: (a->Bool)-> Real
10:40:08 <basti_> o0
10:40:21 <shapr> Hm, a probability monad would be nifty.
10:40:35 <astrolabe> My understanding is that they seem to model differences between pure code and some kind of real-world thing it is supposed to approximate
10:41:00 <basti_> i read about something like that
10:41:09 <shapr> I'd say monads are a way to do predictable concatenation of two chunks of code.
10:41:11 <basti_> it evaluated n random things in the end
10:41:38 <astrolabe> The quantum one models wave functions
10:41:47 <astrolabe> the probablistic one, pdf s
10:44:09 <astrolabe> hmmm embaressed silence?
10:44:19 <shapr> Sorry, I'm chatting about my new unicycle on #unicycling :-)
10:44:39 <astrolabe> Is it what you hoped?
10:45:08 <shapr> I'd say that you make a type with a certain semantics/significance, and then you turn it into pipeline with a monad.
10:46:10 <shapr> My new uni is quite awesome, yes. I'm using an interim 3" tire, but I'll switch to the 3.7" tire when it's available in a few weeks.
10:46:14 <thedward> shapr: do you have anything published on the web about Secret Joy?
10:46:20 <astrolabe> That sounds sensible.  As long as the pipeline doesn't suggest linearity
10:46:41 <shapr> thedward: I don't think so.
10:47:23 <shapr> But I could put something online.
10:48:05 <thedward> no rush on my account, I'm just curious
10:48:32 <shapr> My main worry is that non-strict per-token metaprogramming just isn't that interesting from a research perspective.
10:49:10 <ski> astrolabe : you're trying to understand monads by defining quantum or probablilistic monads ?!?
10:50:24 <sond> is there a haskell library for high precision timers?
10:50:38 <thedward> shapr: I'm interested in reading about and playing with different language paradigms. it stretches my mind.
10:50:41 <shapr> But I think it could be... amortized complexity is a powerful tool, so...
10:50:47 <shapr> thedward: Have you tried Joy?
10:50:54 <astrolabe> ski:  Well, they are more fruits of my understanding than a route to getting it.
10:51:01 <shapr> Joy is pretty mind bending at first, or it was for me.
10:51:08 <thedward> I've played with it, but haven't written anything beyond a couple tiny programs
10:51:23 <ski> astrolabe : np :)
10:51:59 <thedward> I have some forth background, so that aspect was okay, but I was lacking on the functional side of things.
10:52:22 <thedward> I'm basically learning functional programming via haskell at the moment
10:52:50 <shapr> imho the real benefit of learning all these different approaches is that then you can use any or all of them when it makes problem solving easier.
10:53:07 <thedward> yeah
10:53:28 <shapr> If you read about the theory behind Joy, Manfred von Thun shows how Joy can be viewed stack based, term rewriting, or something else I forget, because all three of those are the same thing.
10:54:22 <shapr> One interesting question I haven't gotten around to answering yet is whether a concurrent Joy could have the same properties. Is automatic parallelization easier in different paradigms? Probably not, but it seems like a neat question.
10:54:59 <shapr> thedward: I'd also recommend a prototype oriented language, I like Self.
10:55:25 * ski should look at prototype OO, sometime ..
10:55:53 <shapr> ski: http://gliebe.de/self/index.html
10:56:06 <thedward> concatenative notation
10:56:21 <ski> shapr : btw, i yesterday came up with an idea, possibly inspired by your duel with Igloo on QuotesPage :)
10:56:39 <shapr> Oh, what is it?
10:58:07 <lament> mmm prototypes
10:58:19 <ski> class (Monad m,Comonad w) => DualMonadComonad m w | m -> w , w -> m where duel :: (m a,w b) -> (a,b)
10:58:45 <ski> i have thus far two instances ..
10:59:20 <shapr> Hm, I think that exploded my brain. It also makes a lot of sense.
10:59:45 <ski> i'm not sure how useful this is, but function 'duel' seems to be related to the QuotesPage monad vs comonad dual, in a sense
11:00:01 <ski> the monad and the comonad annihilates eachover, leaving the returned values
11:00:06 <ski> :)
11:00:12 <shapr> It reminds me of a discussion from long ago on #haskell about defining a 'reversible' typeclass for operations like editing, refactoring, etc.
11:00:47 <ski> maybe you want to know what examples/instances i have too (which inspired me to make this class) ?
11:00:58 <shapr> Is this related to the commutative squares diagram?
11:01:02 <shapr> Yes, definitely!
11:01:09 <ski> dunno what that is ..
11:01:18 <TheHunter> the usual suspects are the two adjunctions: reader, product and state, context.
11:01:31 <ski> ok, environment/reader monad is  EnvM e a = e -> a
11:01:48 <ski> the corresponding comonad is EnvW e a = (e,a)
11:02:26 <ski> instance DualMonadComonad (EnvM e) (EnvW e) where duel (e_a,(e,b)) = (e_a e,b)
11:02:41 <ski> TheHunter : exactly
11:02:43 <shapr> Did you choose m and w just because they're horizontally mirrored? :-)
11:03:07 <ski> i did not choose w, but i suspect the one that did, did it because of that, yes :)
11:03:29 <ski> TheHunter : maybe you can relate this idea to some already known CT thing ?
11:03:29 <shapr> Definitely typographically cute.
11:04:04 <ski> i wonder what would be appropriate laws for duel ..
11:04:42 <ski> shapr :  the state-monad vs state-in-context-comonad instance is a little but complicated, but not much
11:04:46 <TheHunter> no, and what i said didn't really make sense.
11:05:07 <ski> StateM s a = s -> (s,a)   StateW s a = (s,s -> a)
11:05:28 <ski> shapr : if you want you can prolly figure out the instance for yourself .. :)
11:05:36 <ski> TheHunter : ok ?
11:05:54 <shapr> I just don't get that second one, I really need to go back and reread the comonads paper. It was totally opaque to me when it was published.
11:06:40 <ski> you don't need to understand much of how StateW s works as a comonad to be able to define duel
11:07:03 <astrolabe> In the def of DualMonadComonad, what does | mean, and has it got higher or lower precidence than comma
11:07:04 <ski> if you want, i can give the second instance here, too. it's not long
11:07:05 <astrolabe> >
11:07:28 <ski> astrolabe : it's called a "functional dependence" (actually two of them)
11:07:29 <shapr> astrolabe: functional dependency.
11:07:35 <ski> *y
11:07:39 <shapr> ski: sure, second instance please
11:07:47 <ski> waitamoment
11:08:50 <ski> instance DualMonadComonad (StateM s) (StateW s) where duel (s_sa,(s0,s_b)) = (a,s_b s1) where (s1,a) = s_sa s0
11:09:10 <ski> (indent for more readable)
11:09:27 <mauke> oh, dueling monads
11:09:35 <ski> yes :)
11:09:43 <basti_> o0
11:10:38 <ski> here, first the comonad takes a thrust at the monad (passing the state s0), then the monad slashes at the comonad (passing state s1), and then there's nothing left but the results, a and b
11:10:54 <TheHunter> ski, no, can't relate it two anything. But it look intriguing.
11:11:38 <TheHunter> *looks
11:11:47 <shapr> Yeah, it looks quite nifty.
11:12:05 <shapr> I wish typeclasses came with QuickCheck properties so you could test out your instances.
11:13:18 <ski> TheHunter : i'm especially interested in possible coherence laws or stuff for duel ..
11:13:48 * ski assumes there must be some, but hasn't found out which, yet
11:15:05 <ski> shapr : anyway, i thought the association to your and Igloo's duel was just to good to ignore ;)
11:15:29 <shapr> Yeah, it's cute :-)
11:17:25 <ski> TheHunter : i think duel is in some way related to cut / throw / reductio-ad-absurdum
11:19:58 <ski> (TheHunter : assume b = ~a and ~(m x) = w (~x) (forall x), then you get duel :: (m a,~(m a)) ---> (a,~a)   (  ---> _|_)  )
11:25:39 <astrolabe> The report says that there are six different types of names in Haskell: variables, type variables, constructors, type constructors, type classes and module names.  I'm trying to get a simple example of each (except for a module name)
11:26:14 * ski wants an FPL with typesys based on full linear logic !..
11:26:58 <ski> id, a, Just, Maybe, Eq, Prelude ?
11:27:24 <astrolabe> ski: thanks.  Let me think about that.
11:27:45 <ski> there are no global tyvars
11:27:53 <ski> so, i just picked 'a'
11:28:55 <astrolabe> Yay, that all makes sense!  But what is 'Integer' ?
11:29:06 <ski> type constructor
11:29:26 * ski wonders if report includes type synonyms in type constructors .. ?
11:29:30 <astrolabe> That's so cool! :)
11:29:44 <ski> @kind Integer
11:29:52 <lambdabot> *
11:29:53 <ski> @kind Maybe
11:29:55 <lambdabot> * -> *
11:30:19 <MarcWeber> Is there any support for databases?
11:30:23 <ski> hmm, isn't there also a namespace of selectors ?
11:30:33 <ski> MarcWeber : in libs i think
11:30:50 <wagle_> ski: there isnt one already?
11:33:06 <ski> wagle_ : what ? db support ?
11:33:12 <wagle_> 11:27  * ski wants an FPL with typesys based on full linear logic !..
11:33:26 <ski> ah
11:33:37 <ski> wagle_ : you were thinking of ?
11:34:14 <wagle_> trying to remember..  i do get hits for google "linear logic" "type system"
11:36:09 <ski> MarcWeber : HaskellDB is one i think (google finds this http://www.haskell.org/haskellDB/index.html, but i'm not sure that's the latest version ..)
11:37:06 <wagle_> ahh..  it was dale miller...
11:37:49 <ski> wagle : Lolli is a (linear) logic programming language, not a functional programming language ..
11:38:18 <wagle> sorry, the week of lectures was 3 years ago..
11:39:11 <wagle> but the theme of the entire two week course was "proofs as programs"
11:39:42 <MarcWeber> ski: Thanks
11:42:02 <wagle> [93] Philip Wadler, Linear types can change the world!, Programming concepts and methods, North Holland, 1990, pp. 561â581.
11:42:14 <wagle> ooops
11:43:39 <jlouis> @hoogle arguments
11:45:10 <ski> wagle : not that one ?
11:45:25 <ski> @index getArgs
11:45:26 <lambdabot> System.Environment
11:45:37 <ski> @type System.Environment.getArgs
11:45:43 <lambdabot> IO [String]
11:45:48 <ski> jlouis : that one ?
11:45:51 <wagle> i just didnt mean to paste it here..  but wadler seems the main source of linear type stuff
11:46:17 <ski> yes, afaik he only use intuitionistic linear logic
11:46:57 * ski wants to hack around with 'par', 'why not' and an involuent 'negation' ! :)
11:47:42 <wagle> whats stopping ya?  8)
11:47:56 <astrolabe> ski: Google should pay you commision
11:48:23 * wagle wonders whats stoppin' /me
11:48:31 <wagle> hmm  hmm
11:49:20 * ski is stupid :(
11:49:33 <ski> MarcWeber : http://haskell.org/hawiki/HaskellDB  (follow sourceforge link)
11:49:50 <wagle> is the bungie cord stronger than the tangental force of Yet Another Project?
11:50:23 <ski> wagle : 'par' and 'why not' is not in intuitionistic linear logic
11:50:39 <ski> (btw, 'par' is multiplicative disjunction)
11:53:13 * ski tries to figure out what 'commision' means
11:55:03 <wagle> context?
11:55:36 <ski> <astrolabe> ski: Google should pay you commision
11:56:46 <wagle> 6 : a fee paid to an agent or employee for transacting a piece of business or performing a service; especially : a percentage of the money received from a total paid to the agent responsible for the business
11:56:55 <wagle> commission
11:57:18 <wagle> http://www.m-w.com/cgi-bin/dictionary?va=commission
11:57:41 <ski> (astrolabe : care to elaborate your comment ?)
11:58:22 <astrolabe> I meant that when I'm trying to follow what you say, I seem to use google a lot.
12:01:43 <ski> aha, ok
12:03:37 * ski was hypothetizing about the remark meaning something like : ski should look up full linlog FPL on google ..
12:03:45 <Aksh> Conflicting definitions for `scanDirectory'
12:03:54 <Aksh> scanDirectory | ... =
12:04:03 <mwelsh> is there a way i can specify the location of external libraries in my path so i dont have to include them every time i load my programs?
12:04:04 <Aksh> scanDirectory | otherwise = ...
12:04:08 <Aksh> why not?
12:04:23 <ski> Aksh : remove all but the first scanDirectory
12:05:12 <Aksh> ski: it works when i add _ as variable: scanDirectory _ | ... =
12:05:23 <Aksh> scanDirectory _ | otherwise =
12:05:24 <ski> sortof works
12:05:28 <ski> but still ugly
12:05:43 <ski> it's mostly supposed to be used as
12:05:53 <ski> foo | ... = ...
12:05:56 <ski>     | ... = ...
12:05:57 <ski>     | ... = ...
12:06:14 <Aksh> oh, really, thanks
12:06:28 <TheHunter> ski, assuming the monad and the comonad come from the same adjunction, i can derive DualMonadComonad, but it ain't pretty.
12:06:29 <ski> and if you have args (prolly with pattern-matching) you can also use several equations after one another, as you tried
12:06:30 * Aksh forgot that syntax
12:07:05 <ski> having several equations, when you don't have any args after the main name being defined, is however not allowed
12:07:20 <ski> TheHunter : ok
12:07:31 <ski> TheHunter : derive where ?
12:07:36 <ski> TheHunter : in which Cat ?
12:08:02 <ski> (TheHunter : or maybe i should ask : under what conditions ?)
12:08:06 <TheHunter> instance Adjunction f g => DualMonadComonad (g `O` f) (f `O` g)
12:08:18 <ski> aha, in haskell, you meant ..
12:08:42 <TheHunter> (with the Adjunction class from LicensedPreludeExts)
12:08:52 <TheHunter> it's quite simple categorically.
12:09:08 <ski> alas, haven't grokked Adjunctions fully
12:09:53 <ski> hm, i'd like to see that instance
12:10:16 <TheHunter> ok, i'll put it up.
12:11:00 <ski> (hm, this will only work for monads,comonads constructed from adjoint endofunctors, of course ..)
12:11:41 <ski> (hm, um, well maybe i've already restricted to that by having m,w :: * -> * in DualMonadComonad, on second thought)
12:11:42 <TheHunter> yes, right :)
12:13:04 <TheHunter> @paste
12:13:05 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
12:13:50 * ski has a hunch that one could make a coduel :: a # b -> m a # w b   (with '#' being 'par' i.e. multiplicative disjunction)
12:13:54 <ski> TheHunter : ty
12:16:04 <wagle> is a "coduel" a situation where you suck the bullets out of each other, then pace 10 steps backwards?
12:16:16 <wagle> *<8-)
12:16:57 <ski> i don't know :)
12:17:06 <ski> 'par's are strange beasts
12:17:30 <TheHunter> the construction should also work for non-endofunctors, but that's a bit too much of a pain in haskell.
12:17:40 <ski> TheHunter : m
12:17:57 <TheHunter> what's par?
12:18:12 <ski> multiplicative disjunction in linear logic
12:18:27 <ski> ('par's a stupid name, yeah)
12:19:05 <ski> 'par' is the dual connective of 'tensor' (which is the (,) that duel uses :)
12:19:12 <TheHunter> ok, thanks. Guess i'll have to read up on linear logic.
12:19:18 <ski> 'with
12:19:21 <ski> bah
12:19:32 <ski> 'with' is the dual of 'either' (Either in haskell)
12:19:53 <ski> (those are respectively, additive conjunction and additive disjunction)
12:20:57 <ski> 'par' (and 'why not') are the connectives of linear logic that are hardest to understand (at least from a type-theoretic perspective)
12:21:13 <ski> the others are easy
12:27:46 <TheHunter> ok, thanks, i don't think i have the mental capacity to grok linear logic right now - sleep deprived as i am :(
12:57:59 <wagle> ski: this looks interesting: http://www-2.cs.cmu.edu/~fp/courses/linear/
12:59:58 <wagle> ski: this looks interesting: http://www-2.cs.cmu.edu/~fp/courses/linear/
13:03:33 * shapr throws linear illogic
13:04:11 * SyntaxNinja peers at shapr
13:05:37 * Muad_Dibber just stairs
13:05:41 <Muad_Dibber> *stares
13:05:45 <ski> wagle : m
13:06:07 <shapr> It's funny, everytime I listen to Pearl Jand and/or Eddie Vedder, I feel sorry for them. Eddie fell apart under the pressure. I'm always happier listening to Led Zeppelin. I saw Robert Plant last night giving a (live?) interview on some Swedish talk show, and he was doing just fine.
13:07:47 <shapr> He was flirting with the cute twenty-something talk show host woman. She had no idea how to handle it :-)
13:08:17 <SyntaxNinja> heh
13:10:35 <shapr> I've heard a lot of people say that 'dissolute genius' is necessary for some people, like Jim Morrison, Charlie Parker, Janis Joplin, Jimi Hendrix... But I think it's bullshit, I think that without the addictions they would have instead had long productive careers and adoring grandchildren.
13:10:45 * shapr is probably an idealist
13:11:16 <lispyoncrack> shapr: yeah, actually i think the same thing
13:11:34 <shapr> :-)
13:11:56 <astrolabe> You can't talk.  You're on crack!
13:12:02 <lispyoncrack> heh
13:12:45 <lispyoncrank> not to mention crank
13:13:15 <lispyoncrack> which is all to trouble shoot my dsl connection
13:13:51 <astrolabe> I think artistic people are often unstable, but that is a different point.
13:14:04 <lispyoncrank> my dsl recently became very inspired by the phrase, "What goes up, must come down."
13:14:20 <shapr> There was some other singer who was generally considered to be more creative but couldn't get to shows on regular basis. So the people chose Robert Plant because he always showed up for practices and gigs and because he worked hard. I hope to be part of team where all the members are like that at some point.
13:15:15 <shapr> astrolabe: I think instability can give you new viewpoints, but it means you have to work that much harder to fit into society.
13:15:22 <shapr> This is my experience at least.
13:16:33 <Oeje1> Stability is the difference between good and great.
13:17:20 <shapr> I think a lot of inspirations require personal stability so that the inspired can make them reality.
13:17:54 <astrolabe> On the face of it, instability just seems disfunctional, but I don't think it can be.
13:19:32 <shapr> On a vaguely related note, I have a Richard Hamming question, "What are the import problems of computer science?" Or more specific, "What are the important problems of Functional Programming?"
13:21:03 <shapr> dbremner suggested this to me, it's great if you haven't read it yet: http://www.cs.virginia.edu/~robins/YouAndYourResearch.html
13:21:12 <shapr> But I still want answers to that question.
13:21:48 <shapr> Any ideas? space leaks?
13:23:46 <shapr> Maybe how to teach monads to the average programmer?
13:23:55 <der_eq> for functional programming, it's clearly popularity ;)
13:23:57 <astrolabe> Well it would be nice to know how efficient a functional program was as easily as you can for a procedural program.
13:24:10 <ski> parallelism implementation ?
13:24:21 <ski> how to make yet more powerful type systems ? :)
13:24:33 <shapr> der_eq: So you think it's just marketing?
13:24:41 <ski> figure out how to use them practically ? ;)
13:24:42 <Speck> A metaphor for abstraction of technical details.
13:24:44 <Oeje1> Standardization!
13:25:10 <astrolabe> I want to be able to program using a restricted part of natural language.
13:25:18 <ski> finding more idioms/design patterns ?
13:25:28 <Oeje1> That is the most important software engineering problem at least.
13:25:52 <shapr> Oeje1: How so?
13:26:12 <shapr> Speck: for which details?
13:26:24 <der_eq> shapr: I think that's very important, we have plenty of theoretical superiority but yet no or very few "real" programs written in haskell
13:26:29 <mikael> standardization is a problem because it impedes progress :-)
13:27:16 <shapr> der_eq: What about Postmaster, or darcs, or hws?
13:27:36 <Speck> shapr, think about the OO metaphor. Something like that, but for fp (and not necessarily anything like OO)
13:27:50 <shapr> Speck: but that's monads
13:27:58 <ski> heh
13:28:11 <Speck> I'm skeptical
13:28:23 * ski is not sure such a metaphor would be a good thing
13:28:23 <shapr> The monadic abstraction is actually simpler than OO, less rules, less pieces, and it does more stuff too.
13:28:35 <der_eq> what's postmaster, and what's hws? See, even I as someone who knows haskell doesn't know them... so for me, it's clearly marketing
13:29:00 <shapr> Postmaster is an MTA written in Haskell, and hws is a web server. Both are very fast.
13:29:17 <mikael> how do we combine arbitrary & arbitrarily many monad-like types?  that seems like an important problem to me
13:29:28 <Speck> I think that monads are too unstructured to be a good metaphor, but they are indeed good.
13:29:50 <shapr> Can you explain that more? How unstructured?
13:30:00 <shapr> mikael: What about monad transformers?
13:30:01 <Speck> you said it yourself, there are fewer laws
13:30:27 <Speck> monads can be wildly different, and very little makes one monad resemble another, making it hard to pinpoint the actual metaphor
13:30:35 <ski> possibly franka is right about monads being more general than effect concept
13:30:40 <shapr> I think you can always use the monads as containers approach.
13:31:01 <mikael> to be fair, I haven't really used monad transformers (except for the occasional StateT), but don't they get sort of unwieldy with more than a couple of monads?
13:31:28 <shapr> They don't get unwieldy as long as you know how you want to plug the semantics together.
13:31:37 <shapr> This is just my perception of course.
13:31:53 <mikael> interesting -- I'll have to learn a lot more about monad transformers :-)
13:32:11 * shapr pokes autrijus 
13:32:28 <Speck> I think that hylo/metamorphisms are an interesting basis for a data-centric programming metaphor
13:32:36 <shapr> autrijus: Do you think monad transformers get unwieldy once you've nested a number of them?
13:33:01 <shapr> I think pugs has had more monad transformer stuff than I've ever put into a program.
13:33:26 * ski 'd possibly want more "wiggle room" with combining monads
13:33:35 <shapr> Like commutative monads?
13:33:40 <ski> that too
13:34:19 <wagle> i dunno..  i'd prefer to work at home
13:34:20 <mikael> by the way, I think parser combinator libraries (like Parsec), while not applications, are a really good example, being great practical boons & quite simple to understand and write
13:34:31 <ski> though i was more thinking on ability of implicit parameters ability to float across each other
13:34:44 * Speck always has some problem with parsec, namely his being stupid
13:34:45 <ski> (imagine similar for state monad)
13:34:47 <shapr> wagle: it gets boring
13:35:13 <wagle> you like long commutes?
13:35:34 <mikael> Speck: so do I, but not as many as with yacc :-)
13:36:42 <shapr> wagle: No, but I like to meet people too.
13:36:48 <Speck> I always manage to make parsec eat huge amounts of memory
13:38:54 <der_eq> shapr: where is hws? I can't find it
13:39:07 <shapr> wagle: I've been working at home for more than two years, and I would *really* like to hang out with some geeks again in person.
13:39:29 <wagle> i was making a lame joke about commuting monads
13:39:34 <shapr> oh, doh
13:40:53 <shapr> der_eq: The paper is "Writing High-Performance Server Applications in Haskell, Case Study: A Haskell Web Server" - http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/ still looking for the latest hws tarball.
13:41:10 <shapr> I have a version of hws that's been modified to use hs-plugins for 'servlets', you want that?
13:41:48 <wagle> i do know what you mean.  once i had two part-time jobs.  one was really cool (working with MRI data), and the other hohum (sysadmin).  the first was in a windowless room all by myself, and the second was in a big sunny windowed room with a bunch of friendly geophysicists..
13:42:04 <wagle> i quit the first, and added hours to the second.
13:42:20 <der_eq> okay
13:42:20 <wagle> hws?
13:42:21 <shapr> Yeah, boring jobs can become great fun if you have cool coworkers.
13:42:28 <shapr> hws == Haskell Web Server
13:42:38 <mikael> bleh, X restart...
13:42:50 <der_eq> shapr: see, no one knows it ;)
13:42:59 <shapr> Some people do :-P
13:43:04 <shapr> I know it!
13:43:21 <der_eq> anyone else?
13:43:54 <shapr> Peter Thiemann must know it, he wrote the extension that adds hs-plugins support.
13:44:21 <der_eq> tell me again that haskell needs anything _other_ than marketing
13:44:39 <shapr> Ok, any marketing suggestions?
13:44:43 <astrolabe> So by the law of zero, one, many, lots of people know it.
13:44:56 <der_eq> perhaps making hws easy to find?
13:45:06 <shapr> Hackage is in progress.
13:45:33 <thedward> I think both pugs and darcs are good marketing
13:45:57 <shapr> Hm, I can't figure out where I left it.
13:46:06 * shapr has too much Haskell stuff
13:47:37 <shapr> In any case, you can get the standard version out of the fptools cvs tree.
13:48:12 <shapr> der_eq: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/hws/
13:52:32 <der_eq> at least this postmaster thing is easy to find :)
14:12:22 <ski> (hm, gnu page says perl licence is disjunction of artistic and gpl .. think they want to use linear logic 'with')
14:34:45 <astrolabe> Wow.  What was that?
14:34:52 <der_eq> netsplit
14:38:41 <AtnNn> uhg
14:41:20 <shapr> Man, we should really switch to silcnet
14:41:43 <mflux_> is it theoretically splitfree?
14:41:51 <shapr> Nah, but it sure is better.
14:42:14 <shapr> It uses a hybrid ring/star topology.
14:42:37 <shapr> Alternatively, we could come up with a IPv6 multicast protocol, that would be nifty.
14:43:49 <shapr> Speaking of which, why can't a single bittorrent instance handle multiple downloads at once?
14:44:16 <wilx> Instance?
14:44:30 <wilx> You need to use something better than the Mainline.
14:44:53 <shapr> I'd like to run a single tracker that can handle any number of uploads and downloads.
14:45:12 <wilx> Trackers can handle any number of uploads and downloads...
14:45:15 <shapr> I get a lot of live music from archive.org and I'd like to keep everything I've downloaded available.
14:45:28 <shapr> Are the clients not called trackers?
14:45:33 <wilx> Nope.
14:45:35 * shapr should probably get a clue...
14:45:38 <wilx> :)
14:46:47 <thedward> azureus can work with an arbitrary number of torrents at a time
14:46:57 <thedward> but it is a gui app
14:47:09 <jlouis> the tracker tracks which people wants which torrents
14:47:38 <shapr> Yeah, but azureus is also Java based... and I refuse to install Java on my box.
14:48:11 <astrolabe> shapr: why?
14:48:19 <thebug> btdownloadmany is what you want
14:48:21 <shapr> Years of writing Java
14:48:36 <thedward> it is a nice app, regardless.
14:48:37 <thebug> it comes as part of the original bittorrent client/library
14:48:55 <shapr> Hm, doesn't seem to be part of the bittorrent deb.
14:49:13 <thebug> try the bittornado package
14:49:21 <thebug> I know it's in one of those two
14:49:30 <thebug> oh! duh
14:49:48 <mwc> something needs to be done about the Haskell.org mailing lists
14:49:55 <shapr> astrolabe: Ok, partly because there's not a real open source Java.
14:50:00 <shapr> mwc: Better searching? or what?
14:50:09 <thebug> btlaunchmany.py or btlaunchmanycurses.py
14:50:16 <thebug> sorry :)
14:50:24 <mwc> shapr, reduce the spam volume >90% :P
14:50:52 <shapr> Hm, I don't see any spam. Maybe because I'm using gmane.org?
14:50:58 <mwc> making them subscribed-to-post only would be a nice start, I guess
14:51:01 <mwc> heh, that's probably why
14:51:22 <mwc> I pity the poor bastard using outlook on those lists
14:51:27 <shapr> thebug: ah thanks!
14:51:34 <Speck> I don't get spam on haskell@haskell.org or haskell-cafe@
14:51:47 <mwc> c2hs@haskell.org is prettty bad
14:51:48 <thebug> :)
14:55:40 * musasabi undies from irc
14:58:40 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/hswebforms/ - some prototyping into web form DSLs and integrating HaskellDB with them.
15:17:44 <_metaperl> excuse me, I have a question about tracing an error I got: http://www.hcoop.net/~terry/haskell/craft-of-fp/q/traceback.txt
15:18:31 <_metaperl> "The library uses HSP" --- what is HSP?
15:18:40 <musasabi> Haskell Server Pages.
15:18:49 <_metaperl> oh
15:19:14 <shapr> _metaperl: You can use Hat if it's simple code.
15:21:01 <_metaperl> actually my initial use of hat on this caused problems with its -i flag. I posted them to the hat mailing list and the author emailed a patch to the list. I'm too lazy to get involved with patches as I installed the debs
15:21:14 <_metaperl> it was a very simple thing I did to break hat
15:21:32 <shapr> You could send the patch to the deb maintainer.
15:21:37 <_metaperl> so, if hat's the only option, then I will just print and trace and print and trace
15:23:23 <_metaperl> http://blog.gmane.org/gmane.comp.lang.haskell.hat
15:23:28 <_metaperl> that shows my post and comments
15:24:30 <musasabi> There is ghc -xc, but I think it is broken.
15:25:05 * _metaperl tracks down the debian maintainer
15:25:44 <_metaperl> Igloo: you there?
15:26:17 <_metaperl> Maintainer: Ian Lynagh (wibble) <igloo@debian.org>
15:26:23 <_metaperl> I think I've found my man
15:26:41 <Igloo> Yes
15:27:25 <_metaperl> can you apply this Igloo  http://permalink.gmane.org/gmane.comp.lang.haskell.hat/181
15:28:00 <SyntaxNinja> man igloo: The lazy man's patch(2)
15:28:09 <Igloo> I'm unlikely to make any uploads before ghc 6.4.1 is released
15:28:11 <SyntaxNinja> er patch(1)
15:28:21 <_metaperl> Igloo: just as long as it's in there
15:28:51 <SyntaxNinja> Igloo: is that going to be any time soon?  I thought it could be > a month or two
15:29:05 <_metaperl> oh, maybe hat is in source on my debian machine?
15:29:06 * _metaperl checks
15:30:14 <musasabi> Would the idea of compatiblity library packages make sense?
15:30:25 <Igloo> I thought it was expected within a month, now, in which case it's not worth me back porting the gcc 4 fixes into 6.4 as I don't think we'll get everything else sorted by the time it's released
15:31:01 <Igloo> Hmm, the hat patch links on the download page don't work
15:31:01 <SyntaxNinja> two weeks ago, Simon said "not more than a couple of months" to me.
15:31:12 <musasabi> For example compat-ghc-6-4 which would try to provide as much as possible of the 6.4 API to older compilers.
15:31:33 <Igloo> I think it's the top one, though, so as long as I remember to apply them it'll get in
15:31:46 <shapr> _metaperl: You can do 'apt-get source hat-ghc6' then apply the patch and rebuild.
15:31:50 <_metaperl> musasabi: I cannot understand why someone using a metaprogramming technology like Haskell would want to inline programming logic along with HTML...
15:31:59 <_metaperl> shapr: that's brilliant. thanks
15:32:25 <Igloo> "we plan to put out 6.4.1 in about a month" -- Simon Marlow "Subject: It's bug time!" "Date: Wed, 6 Jul"
15:32:46 <_metaperl> Debian takes using Linux to another level. Fedora takes it to another level as well. Debian improves and makes Linux use a great  pleasure and comfort. Fedora the opposite
15:33:06 <musasabi> _metaperl: to allow for rapid prototyping and keep them consistent.
15:34:03 * SyntaxNinja nods
15:34:07 <SyntaxNinja> debian rulz
15:35:37 <jlouis> I thought debian ruled. Then I tried FreeBSD. I thought FreeBSD ruled, then I tried OpenBSD. I thought OpenBSD ruled, then I tried NetBSD
15:37:19 <musasabi> _metaperl: and that approach *does* support templating.
15:37:21 <shapr> hoi takuan
15:37:44 <jlouis> it doesn't matter that much what distribution or BSD-variant you use. What matters much more is if you are familiar with it and can maintain it easily
15:37:56 <Oeje1> jlouis: What's next do you think?
15:38:18 <shapr> jlouis: I'd argue that Debian increases speed of change with binary packages.
15:38:44 <SyntaxNinja> I came to the same conclusion as jlouis and decided to standardize on Debian, to become very familiar with it, and I'm pleased with the results.
15:38:51 <shapr> 'Speed of change' is usually my priority.
15:39:04 <jlouis> Oeje1: I have no clue. NetBSD fills the gap quite well right now.
15:39:32 <jlouis> shapr: define speed of change. I do not know what you mean by it.
15:39:34 <shapr> But I agree that familiarity is more important than most factors.
15:40:06 <musasabi> BSDs are very stable and need usually less maintenance than the linux boxes - but they suffer from applications only tested on linux introducing portablity bugs.
15:40:08 <shapr> jlouis: The ability to quickly and safely do operations like install/remove/upgrade/patch/etc
15:40:12 <_metaperl> musasabi: there are many reasons to avoid mixing HTML and Haskell. First, you cannot using w3c validation on the HTML. Second, it confuses syntax editors. Third, it does not separate M,V,C
15:40:34 <Oeje1> It's like the "Brazilian Jiu Jitsu beats Karate any day" argument.
15:40:49 <_metaperl> I get in this argument all the time about HTML::Mason - php-like thing for Perl...
15:41:08 <shapr> _metaperl: Well, write a layer on top of webforms :-)
15:41:20 <jlouis> shapr: ah.
15:41:29 <_metaperl> there's really no argument. all other data processing is handled separate from the data. for some reason, when it comes to HTML, people seem to want to climb in with their data
15:41:42 <shapr> jlouis: Same for programming, speed of change is stuff like unit tests checking to see if I've broken something else, etc
15:41:52 <musasabi> _metaperl: having MVC is a double edged sword - it means coding three components instead of one.
15:41:54 <_metaperl> musasabi: what if you want to use the same HTML in 2 different contexts?
15:43:07 <musasabi> _metaperl: most of the time I need to protype something working first and when the specs are out then do the fancy html - so yes I like to be able to autogenerate it.
15:43:11 <_metaperl> musasabi: what about common look and feel. E.g., a nav bar which must have a different <A> highlighted based on which page is visited
15:43:41 <_metaperl> one of these days I have to see what Adam did with SMLweb
15:43:50 <_metaperl> he's built a lot of our portal for hcoop.net using it
15:43:54 <jlouis> shapr: for me, speed of change is also static type systems. I tend to have the right idea the first time, but am unable to get all the details right wrt types. Then the type inference engine gets it right for me
15:43:59 <shapr> The hswebforms examples look like they can handle common look and feel and same html in different contexts.
15:44:07 <_metaperl> oh really
15:44:21 <shapr> jlouis: Yeah, I agree. Type inferencing is a great speed of change bonus.
15:44:45 <jlouis> Too add further: Data.Set, Data.Map. Nuff said
15:45:00 <takuan> hoi shapr
15:45:09 <takuan> == rtega btw
15:45:12 <shapr> _metaperl: Look at login.hs and record.hs
15:45:15 <shapr> takuan: ah, ok
15:45:23 <musasabi> hswebforms is a bunch of ideas 1) web forms like functional forms, 2) autogenerating online validation (javascript - not in the darcs repository yet), 3) nifty code to automatically derive things from HaskellDB tables.
15:45:24 <jlouis> the SML basis library does not contain Functors for Sets and Maps. Besides Functors are too hard to play with for a full program
15:45:27 <takuan> in case you still remember the nick ;)
15:45:42 <shapr> takuan: Yes, of course :-)
15:45:51 <jlouis> (A Functor in SML is not the same as a Functor in Haskell)
15:45:55 <shapr> musasabi: Oh I'm looking forward to number 3!
15:46:37 <shapr> That'll let users automatically derive web forms from any existing table, or write up a HaskellDB description and generate the SQL tables and the web forms automagically.
15:46:47 <shapr> That would make my life so much easier.
15:47:17 <jlouis> that would be rather cool
15:47:40 <musasabi> shapr: 3) works already but is very unpolished.
15:49:06 <shapr> _metaperl: Check this out: http://www.sandr.dds.nl/FunctionalForms/index.html
15:49:36 <shapr> This is getting very close to my dream of doing "deriving WebPublish" on an ADT
15:49:57 <shapr> Actually, wouldn't "deriving HaskellDB" be possible as well?
15:50:16 <shapr> Something like SerTH that persists with HaskellDB?
15:51:27 <musasabi> shapr: I could write a "deriving HaskellDB" in TH tomorrow ;)
15:52:19 <shapr> That would be nifty, though I'm not sure how many HaskellDB users are out there.
15:52:20 <musasabi> but for the 3) I have few better interfaces in my head (use a kind of constrained fold on the Records to make the display customizable).
15:53:21 <musasabi> as for SerTH serializing into HaskellDB the problem is mostly in the SQL end - there is no good generic way to store binary data in a SQL database.
16:13:53 <poptarts> greetigns
16:14:52 <musasabi> evening
16:17:54 <_metaperl> poptarts: greetings
16:55:22 <shapr> @yow ! excitement!
16:55:23 <lambdabot> A dwarf is passing out somewhere in Detroit!
16:55:44 <gord> Hmm.  Very quiet.
16:55:57 <poptarts> it is indeed
16:56:04 * shapr sings
16:56:11 <poptarts> it's quiet in #lisp too
16:56:34 <shapr> I'm having fun, doing something hackish with Flippi
16:56:42 <gord> Okay, so I'll strike up some (hopefully pithy) conversation about what I'm working on...
16:56:53 <shapr> gord: Hey, what are you working on?
16:56:58 <poptarts> who ever heard of people having fun programming?
16:57:22 * Enveigler thinks about asking a question regarding the inconsistancies in the monads interface ... but thinks better of it.
16:57:29 <ozone> shapr: flippac visited you, or vice versa?
16:57:46 <gord> Well, I'm working on a Haskell-implemented replacement for a filesystem.
16:58:00 <shapr> Enveigler: Have you seen some inconsistencies?
16:58:14 <shapr> ozone: Nah, Flippi is flippac's wiki.
16:58:21 <shapr> gord: Oh, that sounds cool.
16:58:22 <ozone> oh!
16:58:38 <ozone> right, that also makes sense. :)
16:58:56 <gord> I don't want a fully ADT database or anything ambitious like that, I just want a simple networked (rather than hierarchical) database with a query language and transactions.
16:59:04 <shapr> I'm doing macros by hacking the parse/replace into getPage
17:00:11 <shapr> After that works, I just need to add darcs support and FLM 0.1 will be ready to go.
17:00:20 <gord> FLM?
17:00:33 <shapr> Fermat's Last Margin
17:00:48 <shapr> What is it? A distributed decentralized wiki-based darcs-backed research paper annotation tool called Fermat's Last Margin.
17:00:59 <shapr> How does it work? In short, wget the pdf/ps, throw it into imagemagick, create wiki pages for the resulting page images, and save text annotations into the darcs repo. If your repo is http accessible, anyone can grab your per-page annotations, and you can grab theirs.
17:01:08 <shapr> That's also 100% of the FLM docs so far :-)
17:01:48 <gord> Cool. :)
17:02:17 <Number17> that sounds awesome
17:02:30 <shapr> The idea came to me when Pseudonym mentioned that he'd found some problems with the CoMonads paper, and then a month later, someone else showed up saying the same thing, and then two months later, yet another person...
17:02:38 <shapr> So I realized that research papers need to have comments enabled.
17:03:27 <shapr> I write notes in the margins of my books and printed papers, but I can't share those notes with other people, nor can I grep them.
17:04:02 <shapr> Of course, it'll be hard to doodle kangaroo mice into wiki margins.
17:04:31 <Number17> unless, of course you add a javascript drawing thing or something for that purpose ;)
17:04:43 <shapr> Or maybe SVG support
17:04:47 <Number17> jes
17:04:48 <shapr> Right, good idea!
17:05:02 <gord> shapr: FLM is actually related to what I'm working on.
17:05:12 <shapr> gord: Are you working on executable ethics?
17:05:16 <Number17> IIRC someone already made an mspaint type thing in JS; can't remember the name of it though
17:05:18 <gord> Yup. :)
17:05:34 <shapr> gord: Executable ethics is a brilliant idea imho.
17:05:38 <Number17> It nice how people are using more special purpose apps for organizing information now
17:05:58 <shapr> ozone: How's code treating you?
17:06:06 <gord> Can we introduce it properly to other people here?
17:06:51 <shapr> I'm not sure I can, you may be able to.
17:07:19 <gord> The basic idea is for each user to have one (or several) databases, guarded by an agent.  This is similar to running a web server, but the idea is that the stuff in the database can be quantified.
17:08:20 <gord> Somewhat related to the Semantic Web, but hopefully with an easier API.
17:09:06 <gord> "Executable ethics" means that a person defines how their agent interacts with the rest of the world, what it allows other agents to do with your database.
17:09:36 <shapr> Seems equal to security to me.
17:09:42 <shapr> I think security in general is codified ethics.
17:10:11 <gord> In the world of 2050, people no longer talk to one another, they just put stuff in their computers and write programs to govern what other programs learn. ;P
17:11:12 <gord> My specific application is for direct democracy, so that people can participate in surveys and referenda without the nuisance of giving explicit permission every time somebody wants to ask them a question.
17:11:29 <shapr> Hm, that's a neat application.
17:12:05 <wagle> blue pill?
17:12:32 <gord> Or red pill?  I don't remember what does what. :)
17:12:56 <wagle> blue pill to stay in the matrix.  red pill to exit into the real world
17:13:17 <gord> I don't want to _live_ in the matrix, I just want to query it. :)
17:13:46 <gord> Pledge is the name of a financial accounting application that I'm working on to implement this model.
17:14:04 <shapr> You should write this all up somewhere.
17:14:35 <wagle> hmm..  interesting!  what language are you writing this in?
17:14:37 <KrispyKringle> sounds interesting.
17:14:39 * KrispyKringle just got here
17:14:46 <gord> I want to be able to query my friends' agents to find out things like "what was your favorite movie of 2005", and then I can review the results and decide what I want to do.
17:15:06 <ozone> shapr: not too bad, i was on tv last night thanks to my coding (for work, not for academia :)
17:15:16 <ozone> so, that was something different
17:15:25 <KrispyKringle> It seems terribly inefficient, gord. Wouldn't that mean that we'd all have to fill our databases in completely, rather than just the things that other peoplewant to know?
17:15:34 <KrispyKringle> sort of on-demand versus, well, not on-demand. ;)
17:15:47 <ozone> shapr: though i'll probably be changing job soon, got an interview with some folks today
17:15:50 <gord> At shapr's advice, I'm prototyping the backend in Haskell, but I do have plans for a C querying API.
17:15:53 <shapr> ozone: What next?
17:15:59 <KrispyKringle> ew, C?
17:16:05 <wagle> KrispyKringle: think lazy.  it asks you when it doesnt know something
17:16:31 <KrispyKringle> wagle: So it fills in the database as you reply to queries, but it caches your answers to deal with duplicate queries?
17:16:40 <gord> Yeah, I'd only put stuff in my db if I really cared about it, or if I wanted to cache an answer for the future.
17:16:40 <KrispyKringle> essentially...
17:16:42 <wagle> maybe
17:17:05 <wagle> i just started thinking about this twist on things
17:17:52 <KrispyKringle> How do you recognize differently worded queries as the same? or is there going to be a well-defined structure for querying? And even so, how would youi idenfity, say, user:favorite:movie as equal to user:favorite:film, if you allow arbitrary queries?
17:17:58 <KrispyKringle> or is there a fixed schema?
17:18:22 <shapr> Isn't this where ontologies come in?
17:18:45 <KrispyKringle> could be. that's not something i'm familiar with.
17:19:02 <shapr> I wonder if we'll end up with a completely static written language like China's "same over 1000 years" written forms.
17:19:12 <wagle> i'd worry about aggregate attacks
17:19:21 <gord> Yes, and I think the main difference between Semantic Web and Pledge is that Pledge is usually going to deal with stuff that has no formal ontology.
17:19:47 <shapr> Is that like exploring the mind map of the other person?
17:19:53 <gord> Yes.
17:20:01 <KrispyKringle> semantic web seems to assume that you *have* to formalize it because you can't just sort of pick stuff out of plaintext, though.
17:20:05 <shapr> Hm, I've always wanted to look at other peoples' brains!
17:20:07 <gord> It's like sorting through somebody's home directory.
17:20:09 <KrispyKringle> from what little I've seen.
17:20:16 <shapr> Oh, I like that idea.
17:20:28 <shapr> Lots of times I've wished I could publish most of my home dir for public browsing.
17:20:32 <gord> (A really fun experience, if you've ever done it on the GNU machines.)
17:20:46 <KrispyKringle> But if it's just browsing without any understanding of the semantics, it's basically ust a personal webpage. :)
17:20:53 <KrispyKringle> So you have to have some classification.
17:21:25 <ozone> shapr: possibly a place called rising sun
17:21:26 <gord> That's where the accounting stuff comes into play.  It quantifies interactions, but to make sense of it, you have to agree on subjects, objects, etc.
17:21:35 <ozone> shapr: http://www.rsp.com.au/
17:21:53 <KrispyKringle> gord: Well, so a grammar, but also identify synonyms, things like that, right?
17:22:02 <KrispyKringle> This is the part that sounds tricky (and really neat).
17:22:46 <gord> So, another difference is that I'm wanting to start quantifying things *before* the ontologies are agreed upon.
17:23:22 <shapr> ozone: wow!
17:23:42 <shapr> I know someone else doing that sort of stuff.
17:23:55 <ozone> yeah?  Is he enjoying it? :)
17:23:59 <ozone> he/she
17:24:02 <ozone> or he-she
17:24:18 <shapr> Last I heard, yes.
17:24:28 <shapr> Did stuff for Shrek 2 and some others.
17:24:35 <shapr> He's using Python though.
17:24:45 <ozone> ah, coolness
17:24:59 <ozone> i'll be at their research division (if all goes well), so not directly involved with doing the effects
17:25:07 <ozone> will be writing tools for the artists and all that
17:25:27 <shapr> Jerry seems to do a bit of both.
17:26:01 <shapr> ozone: Sounds like an awesome job, I hope you get it :-)
17:26:37 <ozone> cheers, so do i :}
17:28:24 <gord> KrispyKringle: The tricky part is definitely the neat part.  I guess the heart of what I'm working on is that the underlying filesystem/database structure has to be very understandable to non-computer people, which will give them a reason to put stuff in it.  Publishing a web page is hard work for people, but keeping track of their expenditures and rating things are work that everybody has to do at some point.
17:28:50 <gord> A wiki/blog with quantities, maybe?
17:28:59 <shapr> I'd start out with something like TheBrain
17:29:19 <gord> I've seen that a long time ago, and been inspired by it.
17:29:44 <shapr> Keeping track of accounting would be a lot easier if cash registers gave computer readable data, whether it's bluetooth, wifi, or an easily scanned format on the back of the receipt
17:29:56 <gord> Yeah.
17:30:18 <shapr> Actually, hey, you could get the stores to keep customer accessible records only if the customer has a loyalty card.
17:30:28 <KrispyKringle> gord: right, the ability to somehow simply tag data and publish it based on some automatic transforms that interpret the metadata sounds very cool to me.
17:30:38 <shapr> That would make everybody happy, the stores would be able to tune their sales, and customers would get their data.
17:30:40 <KrispyKringle> So I could say, "generate a webpage that contains a list of all the projects I'm working on that are using Haskell."
17:30:47 <KrispyKringle> Something I've wnated for a while, in fact ;)
17:31:16 <KrispyKringle> OF course, then we'd spend hours a day tagging our data, and in a few years some columnist in the NYTimes would write about how computers only make our lives more complex by making us spend hours tagging ou rdata before we can save time by publishing it, but...
17:31:49 <gord> I think that programming is not very hard, but interacting with data is.
17:31:49 <shapr> I think most tagging would be transparent.
17:32:00 <shapr> Favorite film of 2004? just ask your DVD player.
17:32:06 <gord> Right. :)
17:32:08 <KrispyKringle> shapr: good point.
17:32:16 <KrispyKringle> i was being slightly facetious with the NYTimes comment, but... ;)
17:32:24 <shapr> Combine that with the receipt info for movies you've seen, and tada
17:32:50 <shapr> Then you could even weight the movie theater differently than the DVD player.
17:33:00 <shapr> "What genre am I most willing to pay to see in the theater? What genre do I prefer to see at home?"
17:33:14 <shapr> Movie companies might figure out that 'chick flicks' should go onto DVD *first*!
17:33:27 <KrispyKringle> shapr: biased by the fact that i usually can't find *good* movies at the theater.
17:33:34 <shapr> That's a good point too.
17:33:55 <KrispyKringle> I mean, not that I didn't like Batman.
17:34:01 <KrispyKringle> But the theater that carries Batman usually doesn't have high art.
17:34:05 <shapr> Our movie theater is somewhat small here, but they have excellent movies.. Kurasawa films in fact.
17:34:29 <shapr> Oh they had Jaws and a bunch of Spaghetti westerns too, that was great.
17:34:33 <KrispyKringle> hehe
17:34:40 <KrispyKringle> I saw Downfall last night. That was good.
17:35:03 <shapr> Anyway, if we could access the data we produce, it would be useful for us.
17:35:37 <gord> I think that I've come up with a data structure that's simpler than the filesystem, and more flexible.
17:35:38 <shapr> Have you read a book called EarthWeb? I think a bounty system might be more useful than people realize.
17:36:06 <gord> http://fig.org/pledge/0.2/o-dev.php
17:36:25 <gord> What kind of bounty system?
17:38:00 <shapr> A symbiotic bounty system, where people pledge purchases to start new markets.
17:38:11 <gord> Ahhh, interesting.
17:38:40 <shapr> Market research can tune what you've got, but it's not so good at coming up with what you don't have.
17:38:43 <gord> That kind of thing is happening with various free software organizations that collect pledges for developers to implement new features.
17:39:00 <shapr> Right, but it's harder to do outside of software.
17:40:32 <shapr> For example, no Haskell pledges :-(
17:40:40 <shapr> And I don't want to write C or PHP!
17:41:33 <gord> If I had money, I'd pledge you to write Pledge for me. ;)
17:41:38 <shapr> haha
17:42:07 <shapr> That would be interesting. I'd have fun encoding ethics into something like pi-calculus.
17:44:37 <KrispyKringle> Yeah, I wanted to point out, gord, that I feel honor bound to warn you that PHP is an evil that must be stopped.
17:44:39 <shapr> You could do all sorts of crazy stuff with that. Computational cultural studies would flourish.
17:44:40 <KrispyKringle> Don't use it!
17:44:57 <shapr> I use PHP all the time. It has much power as a bad example.
17:45:11 <ozone> i like autrijus's "powered by phd" logo
17:45:24 <shapr> Actually, PHP is a good example of a DSL.
17:45:35 <KrispyKringle> Yeah, a *shitty* DSL.
17:45:37 <KrispyKringle> hehe
17:45:39 <gord> Now that I've found the light, I'll be doing the heavy lifting in Haskell.
17:45:42 <ozone> shapr: i wouldn't call PHP a DSL ...
17:45:56 <KrispyKringle> ozone: Why not? It matches the definition.
17:46:15 <gord> But, I'm actually quite language-agnostic.  I expect to implement interfaces to the underlying db in all sorts of languages.
17:46:29 <ozone> KrispyKringle: what's domain-specific about it?
17:46:42 <ozone> it's a pretty general-purpose programming languages
17:46:42 <shapr> It's for doing HTML 'scripting'
17:46:44 <ozone> -s
17:46:45 <KrispyKringle> ozone: builtins like $_POST or $_GET.
17:46:50 <KrispyKringle> I see what you're saying.
17:47:06 <KrispyKringle> It's not as domain specific as some, but I scoff at even considering it for anything but web scripting (though unfortunately, others don't).
17:47:20 <shapr> Just because people use PHP to make GTK apps doesn't make it a GP PL in my book.
17:47:35 <gord> I program embedded systems in C and ASM, so PHP looks like a walk in the park. :)
17:47:46 <shapr> Central Park... after dark...
17:48:19 <ozone> fair enough, to each their own
17:48:21 <KrispyKringle> jesus. I google "C# fork" and I get a lot of stuff on tuning forks.
17:48:30 <shapr> haha
17:48:44 <shapr> ozone: Seriously though, can you give a better idea of where you put the edge of general-purpose?
17:49:17 <ozone> shapr: mmm, i think PHP is similar enough to other languages that i'd declare it general-purpose
17:49:35 <ozone> that it has great libraries and support for HTML/HTTP is a nice thing
17:49:43 <ozone> but i don't think it's quite enough to put it in the DSL category
17:50:20 <KrispyKringle> Right, so library support probably doesn't make something a DSL, IMO.
17:50:25 <KrispyKringle> Because library features aren't language features.
17:50:25 <gord> I implemented a Lisp dialect in PHP, as well as a Forth.
17:50:47 <shapr> Well, PHP has a zillion web-oriented built-ins.
17:50:48 <ozone> (disclaimer: i've only used php to do very very small tasks, so i might be missing its html/http features)
17:51:13 <KrispyKringle>  but PHP does have some specific builtins.
17:51:25 <ozone> shapr: i think that you can use it outside of the web nearly disqualifies it as a DSL
17:51:25 <KrispyKringle> $_GET, $_POST are examples. All the other global vars.
17:51:42 <KrispyKringle> built (non-library) functions for web and database stuff.
17:51:52 <Igloo> Does anyone have a cunning way of getting a mapping from tags to what they can contain in HTML in a simple format?
17:51:58 <gord> But the global vars aren't builtins: when you run PHP from the command line, the're not there.
17:52:06 <shapr> As an extreme example, you could write real programs with unlambda, but you wouldn't want to...
17:52:12 <KrispyKringle> gord: They're there. They're just unassigned. Right?
17:52:30 <shapr> Igloo: suck the info out of the DTD with HaXml?
17:52:42 <KrispyKringle> Igloo: What? You want to extract the contents of tags? Do what shapr said.
17:53:06 <Igloo> KrispyKringle: Not of an actual document. I want like "html -> body,head"
17:53:31 <Igloo> shapr: I'd rather not depend on an XML library, which is why the "simple format" bit  :-(
17:53:36 <gord> KrispyKringle: `$ php -i | grep GET'  returns nothing at all.
17:53:58 <shapr> Can you use Dtd2Haskell just for the ADTs it generates?
17:55:13 <Igloo> That would still depend on haxml
17:55:19 <jlouis> what are we discussing?
17:55:27 <shapr> My definition of a DSL has been "something with builtins and semantics tuned towards a specific purpose." PHP does have the built-ins, but doesn't have any unusual semantics. So I guess it's a halfway point.
17:55:57 <shapr> Igloo: Can you rip out the part of HaXml that does Dtd2Haskell?
17:56:12 <gord> Thanks for the chat, all... I've gotta run.
17:56:18 <shapr> I think you'll have to duplicate it if you don't want to rip it out of HaXml.
17:57:55 <KrispyKringle> Igloo: wait, so you just want a tree representing the XML structure?
17:57:59 <shapr> HXmlToolbox uses regex validation, maybe they have a simpler approach?
17:58:08 <KrispyKringle> You could ust use HaXml to do that, as shapr said, since it'll parse XML for you.
17:58:09 <shapr> I don't know how they generate the regexes.
17:58:16 <KrispyKringle> ASsuming we're talking XHTML and not something prior.
17:58:18 <Igloo> KrispyKringle: The potential structure, yes
17:58:52 * Igloo is currently failing to even find the interesting bit of the DTD  :-)
17:59:14 <Igloo> Ah, I missed a "-1"
18:03:21 <MachinShin> hey all
18:10:48 <wagle> machine mind?
18:20:14 <KrispyKringle> Igloo: Sorry. I was working. Um.
18:20:41 <KrispyKringle> So anyway, Igloo, I believe you can use an existing XML library to parse the structure into some custom data types that are easily traversable, but I haven't used HaXml for a while.
18:21:05 <KrispyKringle> An alternative would be to use Parsec or similar to parse the tree, to walk over it as you go, meaning you can ignore the actual data within tags.
18:21:15 <KrispyKringle> Anyway, I'm going to head home from work now, so I hope one of those suggestions is useful. :)
19:21:16 <autrijus> http://conferences.oreillynet.com/cs/eurooscon/view/e_sess/7231 # yay :)
20:09:27 <Gahhh> so who participated in ICFP ?
20:10:18 <heatsink> Why does GHC complain "varying number of arguments" for a well-typed function?
20:12:36 <heatsink> Yea, I guess that was a silly question. It just bugs me for no good reason.
20:15:01 <Lunar^> heatsink: check for typos
20:15:15 <heatsink> No typos.
20:15:23 <Lunar^> missing parens?
20:15:32 <heatsink> f _ [] = error "empty"
20:15:46 <heatsink> f g = foldr1 g -- error
20:15:52 <heatsink> f g l = foldr1 g l -- OK
20:16:01 <Lunar^> yeah, that's normal
20:16:12 <Gahhh> oops
20:16:13 <Lunar^> heatsink: the first line defines a function that takes 2 arguments
20:16:21 <Lunar^> heatsink: the second defines a function that takes only one
20:17:16 <Lunar^> heatsink: It's the pattern matching needs that blocks here
20:22:04 <heatsink> It makes sense that the compiler would expect to see two arguments
20:38:29 * shapr hugs lament
20:38:34 * shapr hugs lambdabot 
20:39:03 <dons> lambdabot's machine mysteriously crashed :/
20:39:05 <shapr> That may have been an error in nick completion, but there's no disadvantage in having extra hugs in the world.
20:39:11 <dons> after 219 days uptime
20:39:13 <shapr> Aww
20:39:34 <shapr> Hey, did you hear about the new crash logger in the Linux kernel?
20:40:00 <dons> nope?
20:40:24 <shapr> It's a minimal separate kernel to jump to, since most kernel crashes are such that you can't log anything.
20:40:35 <dons> oh, that's interesting!
20:40:37 <Gahhh> what if it crashes ?
20:40:39 <Gahhh> mwahaah
20:40:46 <dons> minimal kernel, eh?
20:40:48 <shapr> Sounds like the ultimate in uptime to me, just jump back to a new kernel.
20:41:08 <dons> sounds like yi, too, don't you think?
20:41:16 <shapr> Debian can upgrade almost anything on the fly, now we may be able to upgrade the kernel too!
20:41:21 <shapr> Yeah, very much like Yi.
20:41:42 <dons> the yi paper is all about promoting absolutely minimal static cores
20:41:49 <shapr> Yeah, they should use that instead.
20:41:54 <dons> i should chase this up
20:42:20 <shapr> Yi is somewhat related to microkernels as well.
20:42:31 <dons> yep
20:42:41 <shapr> Speaking of which, have you heard about the L4 Microkernel in Haskell project?
20:42:46 <dons> yeah!
20:42:52 <dons> how cool is that!
20:42:57 <shapr> very :-)
20:43:17 <dons> should get some of the L4 hackers round unsw (who also know haskell) to work on it...
21:09:09 <heatsink> We have a kernel dump, Captain!
21:09:13 <heatsink> Switch to emergency backup!
21:10:48 <reffie> linux supports kernel dumps?
22:02:23 <gord> Does anybody have ideas on how to use Parsec in an interactive program?  I'd like to use it for parsing a network protocol and generating responses.
22:04:36 <gord> I think I'm stymied because Parsec has its own GenParser monad, which isn't the IO monad, so I have nowhere to put my IO actions. :(
22:12:45 * heatsink thinks continuations might do the trick...
22:13:30 <gord> I have a good understanding of continuations outside of Haskell, but haven't used them in Haskell.  Can you elaborate a little on your muse?
22:13:51 * heatsink is trying to figure it out
22:14:26 <Cale> gord: You can have parsers return IO actions as results, or use parsers inside IO actions to parse data into some format which would be useful for determining the IO actions to be performed.
22:15:36 <heatsink> Will it be one command per line of input?
22:16:33 <Cale> for example, read a string, pass it to a parser (using "parse", say) which might return a nice abstract representation, which is then used by the IO action to determine a response.
22:18:04 <gord> Hmm.  Let me think.
22:18:20 <gord> It won't be one command per line, most of the commands are multiline.
22:19:12 <gord> The syntax is similar to sexps... nested brackets, so it's not clear when the packet ends until you parse it.
22:21:23 <gord> Maybe I am asking too much for Parsec to do a protocol.
22:28:42 <gord> heatsink: No dice with continuations... they need another monad, which still means incompatibility with Parsec's GenParser monad.
22:31:03 <heatsink> gord: I noticed, but I want to see if it works if I cheat.
22:31:16 <gord> Cheat? ;)
22:31:20 <heatsink> unsafePerformIO :)
22:34:42 <gord> OMG!  OMG!  Run away!  I just read the documentation on unsafePerformIO, and it scares me.
22:35:20 <Cale> It should :)
22:40:21 <gord> Cale: Could you describe more about the idea of returning IO actions as results?
22:40:58 <gord> I think that may be closest to what I have in mind, since I would use Parsec to parse a single packet, return the actions, perform them, then loop.
22:41:31 <Cale> well, yeah, you can do just that, though it might be slightly awkward.
22:42:12 <gord> How do I assemble a list of actions, and perform them?
22:42:34 <Cale> just how you normally do - IO actions are first class values.
22:43:14 <Cale> You can string them together with "do" or with bind (>>=) and such.
22:44:11 <ski> or just use library function e.g. sequence
22:44:30 <gord> So the type of my parser would be `Parser [IO ()]'.  Cool.
22:45:00 <ski> @type sequence
22:45:04 <Cale> ah, you mean like that, yes sequence
22:45:05 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
22:45:08 <ski> @type sequence_
22:45:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
22:46:22 <gord> Is hGetContents lazy?  (I'm too lazy to test it right now.)
22:46:48 <gord> Argh.
22:47:33 <Cale> yes
22:48:05 <gord> I'm getting confused.  I need something to *feed* to my parser, and if I can't get the input handle into a lazy list of chars or something, I'm back where I started from (trying to mix IO monad with Parsec's GenParser monad).
22:48:24 <dons> you need a lexer?
22:49:16 <gord> For incremental parsing, everything I can think of that would be a lexer needs to be in the IO monad, but Parsec can't take any IO monad stuff as input.
22:49:53 <dons> needs to be in the IO monad?? like, what, alex (NO), ctk (NO), hand-written (NO) ?
22:49:54 * gord wishes he had better terminology than `IO monad stuff'
22:50:23 <gord> I'm trying to get Parsec to parse interactively.
22:50:45 <gord> I can't break up my input into packets without parsing them, and it seems that I can't parse the input without breaking it up into packets.
22:51:58 <gord> By `packet', I mean `complete command', or `thing to react to'.
22:56:17 <Cale> gord: what exactly is the protocol that you're parsing?
22:56:34 <gord> A transactional database query language.
22:57:18 <gord> It's basically a programming language with quoted strings, nested brackets, etc.
22:57:48 <Cale> There's no clear way to tell when a request is over apart from parsing it?
22:58:29 <gord> Uhm.  Yes.  The quoted strings are the killer.
22:58:38 <Cale> ah
22:59:25 <Cale> and you're going to keep the connection open and send many requests, which you need handled as soon as they can be determined to be complete
22:59:57 <gord> Yes, that's the behaviour I'm after.
23:00:47 <gord> Okay, I'm firing off an e-mail to daan:
23:00:54 <gord> I'm a fan of Parsec, and a Haskell newbie, and wanted to ask about the possibility of using Parsec for incremental parsing.  I want to describe an interactive network protocol with Parsec's combinators.
23:01:02 <gord> My (limited) understanding is that the GenParser monad is incompatible with the IO monad, and so I have a bootstrap problem.  My protocol is sufficiently complex that I can't break up a stream into packets without parsing them, but my Parsec parser doesn't seem to be able to deal with input from an IO stream.
23:01:19 <gord> Does that sum it up?
23:01:48 <Cale> yeah.
23:02:09 <Cale> It would be nice if there was a monad transformer version of Parsec.
23:02:22 <gord> Ahh.  That's what I'd like to hear.
23:02:47 <gord> What would it look like, and what would it give?  I'd be happy to work on it if I had some pointers.
23:04:15 <gord> I'm reading http://www.nomaware.com/monads/ right now.
23:05:01 <Cale> Well, monad transformers let you take one sort of monad and wrap it in another neatly, using "lift :: Monad m => m a -> t m a" to lift actions from the inner to the outer monad.
23:06:29 <gord> Is there "unlift" or "lower"?
23:07:49 <Cale> Not for monad transformers -- what would the type be?
23:07:57 <Cale> Monad m => t m a -> m a?
23:08:27 <Cale> That shouldn't in general be possible, because the t adds more structure that might not be representable in the monad m.
23:08:36 <gord> Ahh, okay.
23:09:28 <dons> though we do have join
23:09:31 <dons> @type Monad.join
23:09:32 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
23:09:37 <autrijus> unsafePerformMonad
23:09:54 <Cale> yeah, it's not quite the same thing, but it's somewhat related.
23:09:58 <autrijus> unsafePerformM :: Monad m => m a -> a
23:10:06 <Cale> heh
23:10:17 <autrijus> hmm, maybe make it into a class Unsafe :)
23:10:37 <gord> Aieee!
23:10:51 <dons> autrijus is a bad person, don't listen to him.
23:11:00 * autrijus pouts and purrs
23:11:01 <dons> hehehe
23:11:08 <gord> So it looks like one doesn't need a PhD to do I/O in Haskell, but one needs it in order to do interactive parsing. ;P
23:11:41 <dons> nah, tis easy. just use laziness, right?
23:12:10 <gord> That's what I'm curious about.... is there a way to convert an IO handle into a lazy list of chars?
23:12:29 <dons> @type hGetContents
23:12:30 <heatsink> dons: not quite, because interactiveness means that the input and output get mixed up.
23:12:30 <lambdabot> bzzt
23:12:36 <dons> @type Prelude.hGetContents
23:12:38 <lambdabot> bzzt
23:12:43 <dons> why am I being silly
23:12:50 <autrijus> @type System.IO.hGetContents
23:12:51 <lambdabot> GHC.IOBase.Handle -> IO String
23:12:57 <autrijus> ;)
23:13:07 <gord> Yeah.  It's in the IO monad.
23:13:21 <autrijus> gord: the point being you should structure all interactive parts in IO monad
23:13:23 <dons> but then you take that string and feed it to your lazy lexer and parser?
23:13:26 <autrijus> so we can put all your logic outside it
23:13:57 <dons> this can definitely be done. Yi's interface is a lazy, interactive parser
23:14:25 <dons> it's good that I don't have to type all the input into my editor before getting some output ;)
23:14:59 <gord> autrijus: It seems the only nasty thing is that I want to use Parsec for the parsing, and it doesn't want to be abused in that way.
23:15:24 <autrijus> gord: you can have parsec parse partially
23:15:44 <autrijus> or, you can do what pugs does and use, horrors, unsafePerformIO in parsec to get more contents!
23:15:59 <dons> argh!
23:16:02 <autrijus> (my paper talked a bit about why and how to make it safe.)
23:16:05 <dons> see, i told you he was a bad person.
23:16:13 <autrijus> dons: it does not violate the unsafePerform variants :)
23:16:14 <gord> Very bad, from my first impression. ;)
23:16:19 <autrijus> er, I mean, invariants
23:16:33 <dons> teehehe
23:16:34 <autrijus> freudian slip
23:17:21 <gord> autrijus: Since you chose it for pugs, you must have had a good reason.  Is there really no change to Parsec that could make this usage less hackish?
23:18:02 <autrijus> gord: I have thought to make Parser a ParserT on top of IO.
23:18:11 <autrijus> it turns out it may just kill its performance.
23:18:22 <gord> Oh.  Too bad. :(
23:18:24 <autrijus> not to mention harming the laziness part
23:18:47 <Cale> Parsec already doesn't seem too willing to lazily produce output.
23:18:49 <autrijus> you can make yourself feel better:
23:19:02 <autrijus> doIO :: IO a -> a
23:19:06 <autrijus> doIO = unsafePerformIO
23:19:06 <autrijus> there
23:19:13 <gord> ROTFL.
23:19:24 <dons> hmm. alex doesn't either, btw.
23:19:38 <dons> but is parsec really non-lazy if you feed it a lazy list?
23:19:46 <autrijus> bbiab :) &
23:19:47 <Cale> it seems that way
23:20:06 <dons> no parsec grammars for yi then.
23:21:14 * gord should try Yi sometime.
23:21:16 <Cale> ones = (do char '1'; xs <- ones; return (1 : xs)) <|> (return [])
23:21:20 <Cale> parse ones "" (repeat '1')
23:21:35 <Cale> bottom, no output
23:21:41 <dons> :/
23:22:25 <dons> i wonder if it is the lookahead causing trouble?
23:23:18 <gord> Seems to me that the lookahead should only matter when there's a failure.
23:26:30 <gord> Scary.  The unsafePerformIO way is looking more and more appealing.
23:26:37 <ski> hm
23:26:52 <Cale> Someone must have written a ParserT
23:27:01 <Cale> and if not, then someone should :)
23:27:23 <gord> Is that a good first project for a Haskell newbie?
23:29:21 <gord> 12 googles for haskell parsert, most of which are in passing on mailing lists circa 2002.
23:31:10 <lispyoncrank> wait, haskell parsers?  as in a parser for haskell syntax?
23:31:27 <lispyoncrank> i'm pretty sure GHC has one as a library
23:31:53 <Cale> no, parsers for other languages written in Haskell
23:31:53 <ski> i think the parses must wait for the whole parse to finish, before knowing for sure that it succeeds
23:32:05 <ski> s/parses/parser/
23:32:35 <ski> parse ones "" (repeat '1') :: Either ParseError [Integer]
23:32:39 <lispyoncrank> oh, well, there is Parsec
23:33:10 <lispyoncrank> or maybe a ParserT is different
23:33:31 <lispyoncrank> i wrote an elisp parser this weekend using Parsec
23:33:34 <Cale> http://www.informatik.uni-bonn.de/III/forschung/publikationen/tr/reports/IAI-TR-96-9.ps.gz has some information that looks useful
23:33:38 <ski> a ParserT could possibly do effects before failing, yes
23:33:50 <lispyoncrank> what is the T for?
23:33:56 <gord> Yup, that's the idea.
23:34:00 <ski> Transformer
23:34:04 <Cale> It indicates that it's a monad transformer.
23:34:58 <lispyoncrank> why would you want to do effects before failing?
23:35:01 <ski> possibly one could make some parser that (lazily) returns a possible partial parse tree .. hm
23:35:08 <Cale> That is, one could use parsers with types of the form (ParserT IO a) which use lift (someIOAction) to produce side effects while parsing.
23:35:55 <ski> lispyoncrack : so you can have an interactive system actually doing stuff, even if the next thing you're going to type in will contain a parse error ?
23:36:19 <gord> What's the difference between (ParserT IO a) and (ParserT (IO a)) ?
23:36:23 <ski> maybe what we need is guarranteed non-failure parsers ..
23:36:36 <ski> ParserT (IO a)  would be a kind error
23:36:40 <Cale> gord: the second would be a kind error
23:36:42 <Cale> yeah
23:37:33 <dblhelix> gord: in general f (a b) is always different from f a b
23:37:41 <gord> Oh.  Right.
23:38:05 <dblhelix> application associates to the left, that is
23:38:26 <ski> if we know a parser will not (cannot) fail, then we can possibly pull out the initial results of the parse, even when the whole parse is not finished
23:39:05 <gord> Some kind of `commit' protocol to say that the stream so far can be considered a transaction, maybe?
23:39:19 <ski> hm, maybe .. possibly
23:39:30 <gord> Like lining up a bunch of IO actions, but only executing them if somebody higher says to do so?
23:39:31 <Cale> well, it's really the notion that there are certain checkpoints during the parse where we all of a sudden know what we have is correct. I suppose it's somewhat like cut in Prolog.
23:39:46 <dblhelix> ski: but are there interesting non-trivial examples of parsers that know they succeed without consuming the entire input?
23:40:14 <dblhelix> ski: or, at least, before constructing the entire parse tree?
23:40:42 <ski> (a very simple example of a non-failure parser would be one that reads lines, and parses each line in some way, putting results into an output lazy list, if a line has a parse error, we just skip that line's result in the list)
23:40:47 <gord> That assumes the parse is a tree.  If it's a list, we might have something valid after each element is parsed.
23:40:59 <gord> ski: Right.  What you said. :)
23:41:25 <dblhelix> I can think of a parser that consumes all available input and produces a constant; that can easily be done
23:41:29 <ski> better would of course be to actively/explicitely imform the user of the parse error :)
23:43:10 <dblhelix> ski: but why wouldn't you be able to construct such parsers with, say, parsec?
23:43:20 <ski> maybe you can
23:43:31 <dblhelix> ski: I really think you can
23:43:32 <ski> i'm just thinking around a little ..
23:43:50 <Cale> It's annoying that parsec doesn't even seem to have a way to get the rest of the string at the end of a parse, which it carries around anyway.
23:43:51 <dblhelix> ski: that never hurts :)
23:44:17 <gord> dblhelix: You can't if you don't want to consume the entire input, unless you use unsafePerformIO, because Parsec's monad doesn't mix with IO.
23:44:30 <ski> Cale : example of why/when you'd want that ?
23:44:37 <Cale> ski: in this example
23:44:56 <gord> At least that's been the result of the discussion so far, started because I wanted to use Parsec for exactly this problem.
23:45:29 <gord> I want Parsec, but for interactive applications (interleaved input/output).
23:45:44 <Cale> ski: the goal is to parse a bunch of commands interactively. You could simply write a parser to parse one of them, capturing the rest of the input, and then execute your action before passing the rest of input to the parser again.
23:45:45 <ski> it's an interesting problem  (e.g. related to lazy LP)
23:46:46 * dblhelix will think about this some more, during lunch or so
23:47:04 <dblhelix> for now, it's back to work though
23:47:58 <ski> Cale : hm, can't you "capture
23:48:00 <ski> bah
23:48:14 <ski> Cale : hm, can't you "capture" the rest of the input by reading chars til eof ?
23:48:46 <ski> Cale : were you wanting to invoke 'parse' only once ? or repeatedly ?
23:48:49 <Cale> ski: except that Parsec is too strict.
23:48:51 <dblhelix> ski: you can, but it should be done lazily
23:48:55 <Cale> repeatedly
23:49:18 <ski> m, right
23:51:46 <Cale> ReadP is lazy enough
23:51:56 <gord> ReadP?
23:52:03 <Cale> and also returns the end of the string
23:52:06 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text.ParserCombinators.ReadP.html
23:52:31 <Cale> you use it in a similar fashion to Parsec
23:52:59 <dblhelix> but why can't you just use getState in a Parsec parser that uses State to holds its state?
23:54:40 <Cale> ah
23:54:44 <Cale> getInput
23:54:48 <Cale> that's what we need
23:55:00 <dblhelix> Cale: you're welcome ;)
23:55:08 <Cale> yes, thanks :)
23:55:51 <Cale> gord: you can just write the parser for a single transaction, and at the end, have it return some representation of what needs to be done, along with the result of getInput
23:56:07 <Cale> well, let me test something...
23:56:23 <gord> That comes back to the question of how do I get an I/O handle into a lazy list of chars, not in the IO monad?
23:56:26 <Cale> yes, that appears to work
23:56:40 <Cale> oh, you'll still be in the IO monad at the top level
23:56:48 <gord> What does getInput return, though?
23:57:01 <Cale> getInput returns the unparsed part of the input
23:57:12 <Cale> (it's in the Parse monad)
23:57:18 <Cale> er Parser
23:57:23 <dblhelix> gord: the remaining stream of tokens
23:57:54 <gord> I see that, but the problem is this: the only ways to invoke a Parsec parser are for a list not in the IO monad, or for a filename.
23:58:19 <Cale> gord, that's fine :)
23:58:21 <gord> I have an IO Handle, so what do I give Parsec?
23:58:41 <Cale> @type hGetContents
23:58:42 <lambdabot> bzzt
23:58:45 <Cale> @type IO.hGetContents
23:58:47 <lambdabot> GHC.IOBase.Handle -> IO String
23:59:31 <gord> Maybe I don't understand.
23:59:38 <Cale> so it will look something like:
23:59:45 <gord> Is that a lazy string?
23:59:52 <musasabi> gord: yes.
23:59:53 <Cale> handle <- connectTo blah blah...
