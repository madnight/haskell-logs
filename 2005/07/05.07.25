00:26:55 <jader> hello, noob here. i cant seem to compile the demo from gtk2hs. i havent played with compiling things yet. the most complex thing i did was to play with hugs. anyways i installed gtk2hs debs from apt.  Can't find module `Graphics.UI.Gtk'
00:27:15 <jader> i tried symlinking the hi files it was looking for but more errors show up
00:27:28 <jader> ghc --make ButtonBox.hs -o buttonbox <- command i used
00:27:31 <jader> anyone?
00:27:33 <jader> =)
00:34:11 <dblhelix> :) okay, using a 'real' keyboard now (well, it has a windows key on it, but I can just ignore that)
00:35:30 <shapr> jader: You may need a -package gtk2hs (or something like that)
00:35:42 <shapr> jader: does "ghc-pkg -l | grep gtk " show anything?
00:36:55 <jader> text, net, hssource, glade, gtk2 <- it shows this line
00:39:29 <jader> shapr, just tried "-package gtk2
00:39:29 <jader> "
00:39:34 <jader> it works...
00:39:44 <jader> but it seems that theres an error
00:39:54 <jader> thanks anyway... =)
00:40:02 <jader> ill look at this first
00:40:04 <jader> =)
00:46:54 <shapr> Good to make some progress :-)
01:21:38 <musasabi> How do I get c2hs to remove prefixes from type names?
01:42:06 <dblhelix> anyone succeeded in compiling Lemmih's SDL binding on Mac OS?
01:42:54 <dblhelix> I gave it a quick try last weekend, but it didn't build out of the box
01:45:36 <shapr> @yow !
01:45:37 <lambdabot> Couldn't find fortune file
01:45:48 <shapr> dons: So um, should I email a fortune file to you?
01:48:04 <shapr> hyv√§√§ huomenta musasabi!
01:48:22 <shapr> jader: Does it work now?
01:54:15 <musasabi> god morning shapr
01:54:44 <shapr> How's code?
02:06:28 <xerox> musasabi: did you find how to do it?
02:06:55 <xerox> 'lo people.
02:06:59 <Mon5414> hey guess what, the brazillian dude was innocent :D
02:08:43 <dblhelix> Mon5414: I take that the smiley is a typo?
02:08:57 <Mon5414> ow yeah sorry lol
02:09:04 <Mon5414> it was supposed to be the S
02:09:07 <Mon5414> which is next to the D
02:09:25 <Mon5414> :S
02:09:26 <Mon5414> there
02:13:08 <musasabi> xerox: no, I named them by hand.
02:14:38 <dons> shapr, i'll fix it in the next hour or so, just been a bit busy today
02:14:48 <dons> i have a fortune file around here somewhere
03:33:12 <jyp> @seen dons
03:33:13 <lambdabot> dons is in #haskell. Last spoke 1 hour, 18 minutes and 24 seconds
03:33:13 <lambdabot> ago.
03:42:45 <dcoutts> JaffaCake, re your email about threads and GUIs, I wrote a little article yesterday, expanding on the stuff in the email. In particular the first half gives some motivation as to why we might want to use threads in Haskell GUIs
03:42:46 <dcoutts> http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/
03:43:16 <JaffaCake> dcoutts: great, I'll take a read, thanks
03:54:28 <jader> noob here. im having probs with gtk2hs. This shows up at first:
03:54:33 <jader> Can't find module `Graphics.UI.Gtk'
03:54:40 <jader> so i did a little symlinking but errors like these shows next:
03:54:50 <dcoutts> ok, what are you doing that gives that error
03:54:51 <jader> World.hs:17: Variable not in scope: `set'
03:55:04 <jader> i pulled the demos from cvs dunno if things changed. the debian version of gtk2hs installed is 0.9.6 and im using ghc6.2.2
03:55:20 <dcoutts> oh, sadly that's too old :-(
03:55:32 <dcoutts> you need Gtk2Hs 0.9.8 for the current demos
03:55:44 <jader> ic
03:55:56 <jader> i guess the debs arent updated
03:55:57 <dcoutts> We're getting closer to having up-to-date debs
03:56:13 <dcoutts> for now, you can build from the source tarball
03:56:27 <dcoutts> it should "Just Work"tm
03:56:40 <jader> will do that
03:56:45 <dcoutts> cool
03:56:54 <jader> im still new to haskell... its only been a week
03:57:28 <dcoutts> well I'm glade Gtk2Hs has grabbed your interest :-)
03:58:27 <jader> hehe. i like gtk better than wx
03:58:31 <jader> im gnome biased
03:58:32 <jader> hehe
03:58:45 <dcoutts> I know the feeling :-)
03:58:53 <jader> just cant w8 for the debs... im only borrowing this pc thats why i cant do compiling stuff right now. =)
03:59:02 <jader> my laptop broke... =(
03:59:18 <dcoutts> Don't worry, I've been buggin the debian packaging people for weeks now :-)
03:59:24 <dcoutts> Hi Igloo!
03:59:51 <dcoutts> Igloo, btw, do you want a stapshot tarball with the .cabal files you wanted?
04:00:15 <jader> dcoutts, hehe. if we had bindings for gstreamer that would be lots a fun.
04:01:03 <jader> anyone know of existing bindings for audio playback?
04:10:13 <shapr> Igloo wrote some gstreamer bindings.
04:12:23 <jader> shapr, url? =)
04:16:32 <jader> gtg peeps.. thanks for all the help. gotta sleep. byebye.
04:24:54 <sylvan> dcoutts: have you tried just havina a main OS "worker thread" for the GTK binding and having all gui calls send an "IO a" (along with possibly an MVar for returning the result) to a channel which this GUI-thread just picks off an itme at a time?
04:25:56 <dcoutts> sylvan, that was more-or-less JaffaCake's suggested solution. I've not tried it yet. I'll give it a go. But I fear it may add quite a bit of overhead.
04:26:24 <dcoutts> many GUI calls are really very small (just getting info out of C structs)
04:26:39 <sylvan> MVar and Chans are not that expensive.. Plus, you could send a huge batch of GUI-calls in one go
04:26:57 <dcoutts> except that may GUI calls need a reply
04:26:59 <JaffaCake> sylvan: that's pretty much what I said on haskell-cafe this morning :)
04:27:15 <sylvan> ah... should look through my email more often then =)
04:27:22 <dcoutts> :-)
04:27:42 <sylvan> well if it needs a reply you get it through an MVar
04:27:48 <dcoutts> yep
04:27:59 <dcoutts> JaffaCake, convinced about the usefullness of threads for GUIs yet? :-)
04:28:00 <JaffaCake> dcoutts: I thought you'd send a whole computation over the channel, not just a single call that needs a reply
04:28:21 <dcoutts> JaffaCake, er, right yes
04:28:33 <JaffaCake> it's performance week, I've pushed your article on the stack for now...
04:28:41 <dcoutts> ok
04:28:45 <sylvan> exactly.. You could send like 100 calls at once and internally those calls will work just as they do now with regards to returning values etc. Only the very last result will need to go via an MVar
04:29:28 <dcoutts> though it makes using the GUI with threads rather a pain, all very explicit (like the explicit locking they do in C)
04:29:55 <dcoutts> wrapping all sequences of GUI calls from other threads in gdk_threads_enter()/gdk_threads_leave()
04:30:09 <sylvan> Will it? Just put "doGuiStuff $ " at the very  beginning of all GUI-actions and then do everything as normal inside that...
04:30:21 <sylvan> where doGuiStuff just puts it in the Chan
04:30:21 <dcoutts> it means you always need to know if your in the main GUI thread or not
04:30:38 <JaffaCake> true
04:31:08 <dcoutts> so it makes it hard to have libraries of reusable GUI code
04:31:11 <sylvan> Well you could make sure that nothing the user ever does is in the main GUI thread, all the main thread does is accept stuff via a Chan and "perform it"
04:31:34 <dcoutts> except that callbacks happen in the main GUI thread
04:31:53 <sylvan> ah..
04:32:25 <sylvan> Well that could be changed? Have all callbacks do a forkIO and pass along the Chan that they should use to communicate with the GUI worker thread
04:32:55 <dcoutts> and I suspect that one would have to be a bit careful about not deadlocking the main loop if one posted GUI requests back to the main loop when the main loop is already waiting for an answer from a event handler/callback
04:32:56 <JaffaCake> another thing you could do is implement your own cooperative multi-threading library, it's pretty trivial
04:33:26 <dcoutts> JaffaCake, interesting
04:34:02 <dcoutts> JaffaCake, how does that work / what does that give us?
04:36:02 <JaffaCake> I haven't really thought this through.. but I imagine you could have a global "run queue" of IO actions, with an explicit yield operation to put the current IO action to the back of the queue, and a mini scheduler to just run each one in turn
04:36:25 <dcoutts> right
04:37:37 <JaffaCake> newtype Cont = Maybe (IO Cont)
04:37:47 <JaffaCake> threads have type (IO Cont)
04:38:13 <JaffaCake> yield :: IO Cont -> IO Cont
04:38:58 <Igloo> dcoutts: Not for a month or so
04:39:00 <dcoutts> so what's the advantage of this sytem? how does a user use one of these threads?
04:39:59 <dcoutts> Igloo, ok, 0.9.8.1 will be out by then. I hope it does all you need!
04:40:08 <JaffaCake> the advantage is you can do it all in Haskell and it works with the threaded RTS, the disadvantage is that it's co-operative multithreading, and all your threads have to have a certain type
04:41:27 <JaffaCake> oh, and blocking is a bit tricky
04:41:50 <dcoutts> JaffaCake, I don't quite "get it" yet. How does this interact with the Gtk event loop?
04:42:20 <JaffaCake> the main thread runs the mini-scheduler at regular intervals
04:42:34 <dcoutts> ah, ok
04:43:15 <dcoutts> so then threads need to explicitly yield to not block the main loop
04:43:23 <JaffaCake> yup
04:43:33 <dcoutts> so, eg the raytracing example won't work :-(
04:43:51 <dcoutts> because the raytracer is not incremental, it just does it all in one go
04:43:53 <JaffaCake> oh... I'll take a look then
04:44:38 <dcoutts> which is arguably not very good design (it doing it all in one go) but a lot of software is written this way
04:45:29 <dcoutts> and it's a bit hard to tell everyone "no you must split everything up so that no individual computation lasts for longer than 20ms"
04:45:36 <shapr> Good Haskell code is usually incremental.
04:46:07 <dcoutts> true
04:47:08 <shapr> I think that's because incremental code usually has fewer space leaks and the ability to deal with infinite lists.
04:47:19 <shapr> Or maybe it's vice versa.
04:47:24 * shapr wonders about that.
04:47:48 <dcoutts> but it's not always so nice
04:48:24 <shapr> Well, it's rarely as simple as all-at-once code.
04:48:32 * shapr thinks about that more.
04:49:12 <dcoutts> shapr, well I can't really go tell boegel that his code is no good!
04:49:14 <shapr> I guess it depends on how you structure the code.
04:49:19 <shapr> Yeah, true :-)
04:49:45 <dcoutts> it was written originally as a commandline tool where there was no need for it to be incremental
04:50:02 <shapr> Yeah, good point.
04:50:44 <dcoutts> it would be nicer if it were incremental, even when using threads and a GUI since then we could get a % completion on the progress bar...
04:50:56 <dcoutts> rather than just an activity indicator
04:52:04 <shapr> Maybe one day I'll write a TMR article about the connection between incremental code, laziness, and lack of space leaks.
04:52:56 <dcoutts> shapr, oh speaking of TMR, the article I might borrow from that I was talking about yesterday is here:
04:52:57 <dcoutts> http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/
04:53:24 <dcoutts> I'll also base it on the ants visuliser from last years ICFPC
04:55:34 <shapr> dcoutts: Oh this looks excellent, especially since it builds on an earlier TMR article!
04:55:53 <dcoutts> does it?
04:56:17 <dcoutts> boegel hasn't written about HRay has he?
04:56:22 <ski> incremental, in what sense ?
04:56:47 <shapr> Er, I thought boegel wrote a TMR article about HRay? Maybe I'm confused...
04:57:16 <dcoutts> shapr, oh, it was about a "memory" game he made up for the article
04:57:34 <shapr> It's unfinished - http://www.haskell.org/tmrwiki/HRay
04:58:01 <dcoutts> oh, right, well yes, that'll be nice
05:06:07 <Itkovian> shapr: I thought he'd finish it as soon as he gets back from France ...
05:06:31 <Itkovian> shapr: btw, you weren't in Ostend yesterday by any chance? I saw a guy who looked remarkably like you
05:08:18 <shapr> Definitely not!
05:08:29 <shapr> Though I was reading about Ostend, if that helps any...
05:14:38 <TheHunter> dcoutts, sorry about that :tags thing. It was in ghci-6.5.20050720, I didn't check 0722 and ghci-0723 was broken. the 0724-tarball is smaller than the others, so I doubt it works.
05:15:12 <dcoutts> TheHunter, np
05:29:21 <musasabi> What is the best way to keep some foreign objects alive at least as long as an another foreign object?
05:30:58 <musasabi> e.g. call "freeFoo" (imported via FFI) on foo1...fooN (the set may change dynamically), after "freeBar" has been called on bar (a ForeignPtr)
05:31:20 <musasabi> Foreign.Concurrent seems to offer an easy way but is there a portable one?
05:35:57 <musasabi> or is it possible with that either? the docs say "In general, it is not recommended to use finalizers on separate objects with ordering constraints between them. To express the ordering robustly requires explicit synchronisation using MVars between the finalizers, but even then the runtime sometimes runs multiple finalizers sequentially in a single thread (for performance reasons), so synchronisation between finalizers could result in artificial dead
05:36:13 <Mon5414> whats the semantics of mplus for Maybe?
05:37:27 <norpan> Mon5414: it will take the first if both are Just
05:39:54 <musasabi> Mon5414: mplus (Just v) _ = Just v; mplus _ x = x
05:41:09 <ski> Mon5414 : see http://www.haskell.org/hawiki/MonadPlus
05:46:20 <Mon5414> k thanks
05:48:09 <bourbaki> hidiho
06:06:58 <CosmicRay> metaperl: did you get your printf question figured out/
06:14:37 <ski> heh, Stream is both a Monad and a Comonad
06:15:53 <Philippa_> well yeah, it's just a lazy list
06:16:51 <ski> but return for Stream is not similar to return for [] ..
06:18:00 <Philippa_> point. What does the Stream monad look like then? (am pretty sure I'd figured there was more than one sane monad on top of lists)
06:18:09 <ski> (clarification : not talking about potentially-finite streams, here)
06:18:59 <esap> return x = let r = (x:r) in r  ?
06:19:18 <ski> yes
06:20:30 <ski> (i realized the Monad Stream instance a few days ago, and just saw that Ross Paterson also has constructed it http://darcs.complete.org/fptools/libraries/arrows/Data/Stream.hs)
06:22:10 <ski> join takes the diagonal, so to speak
06:22:49 <esap> Is (>>=) the same as function application on the first element of the stream? Or mapping the stream?
06:23:56 <ski> hm
06:24:17 <Enveigler> shapr: You said "You can use export hiding and accessor aliases, or you can add the name of the type directly to the record"--any pointers?
06:24:21 <Enveigler> dcoutts: Are you aware of anyone successfully installing sourceforge/gtk2hs/gtk2hs-0.9.8.exe? I've pulled it from two different mirrors and the install fails immediately with "Invalid RootKey value"?
06:24:53 <esap> hmm.. interesting implementation in Paterson's code.
06:25:24 <dcoutts> Enveigler, really? not seen that one before
06:25:41 <dcoutts> you can check the md5sums if you think it might be corrupted
06:27:05 <dcoutts> Enveigler, you can run it with /LOG="gtk2hs.log" and see what that says
06:27:16 <ski> esap : what do you mean by functor application ?
06:27:32 <ski> fmap f (shd xs) ?
06:27:45 <esap> ski: functor?
06:27:55 <ski> ah, misread
06:28:40 <esap> ski: I had implementation that said: (Stream x _) >>= f = f x
06:28:59 <esap> ski: But I suppose that might not be correct
06:29:11 <ski> hm, would that satisfy monadic laws ?
06:29:20 * esap hasn't checked :-(
06:29:37 * ski tries to remember his code (doesn't have it here)
06:29:45 <Enveigler> @paste
06:29:46 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:30:08 <esap> Paterson's code is clearly different, so I'm inclined to try to think about it further..
06:30:17 <ski> i think the repeat,diagonal version satisfies the left,right unit and associativity laws for return and join
06:30:59 <ski> i derived my (>>=) from return and join, (but haven't looked very much at it) so i don't know offhand if patersons (>>=) is different
06:31:09 <esap> I wonder if Paterson's implementation is lazy on the first argument.
06:31:39 <esap> probably is. I'd use pattern matching anyway for that.
06:32:20 * ski wrote his version in MessageDispathing style, first (in comments)
06:33:11 <ski> (bah ..Dispatching)
06:35:43 <esap> It's actually very interesting thing that the >>= takes the diagonal. Very powerful operation.
06:35:50 <esap> I though the function applicatfgio
06:36:02 <esap> I though the function application was powerful, but diagonalization is even better :-)
06:37:20 <ski> yes, it's interesting
06:38:47 <ski> hm, (haven't seen the 'function application' version before), but it reminds me of JerzyCarmaczuk's (or how it's spelled) code for calculating derivatives in haskell ..
06:39:30 <esap> Well it's just probable that I've got it wrong, because I didn't look at the monad laws when I wrote that.
06:39:49 <Enveigler> dcoutts: see http://sial.org/pbot/11966
06:41:48 <dcoutts> Enveigler, ok taking a look...
06:42:16 <Enveigler> There's not much to see unfortunately...
06:42:20 <esap> I wonder if my adjunction instance is wrong as well due to the same issue.
06:52:39 <ski> (esap : btw, have you seen Tarmo Uustalu's and Varmo Vene's Signals and comonads, http://types2004.lri.fr/SLIDES/uustalu.pdf ?)
06:53:46 <esap> I'm seen some papers by him, but I'm not sure about that. I'll look at it.
06:54:07 <dcoutts> Enveigler, it looks like an odd registry problem
06:54:28 <dcoutts> sadly my windows box is not nearby, It'll have to wait a bit
06:55:23 <Enveigler> dcoutts: Okay. (BTW: Where on SF are the md5s listed? I just loked again and I cannot see them. )
06:55:29 <esap> ski: At least I disagree with his statement that arrows are not as simple as monads :-)
06:57:23 <esap> Also I wonder if it's reasonable to ignore things in an instance of counit and cobind of a comonad.
06:58:39 <ski> hm, ignore what ?
06:59:19 <esap> there are implementation of the product comonad, which reads like  counit (a :- _) = a  ; cobind k p@(_ :- e) = k p :- e
06:59:34 <ski> (btw, i'm not sure that, at least the current, arrow classes are so simple/right ..)
06:59:48 <ski> ah, that
06:59:50 <esap> Which implements the operations as projections.
07:00:02 <ski> ?
07:00:08 <ski> projections ?
07:00:34 <ski> btw, that cobind doesn't discard anything ..
07:00:46 <ski> rather, it duplicates (the env)
07:00:52 <esap> counit (a :- _) = a  is a projection to second component of a :- e. Ah right.
07:01:00 <ski> yes
07:01:03 <esap> I mean, first component.
07:01:08 <dcoutts> Enveigler, oh sorry the md5sum is not on the SF pages, it's 4c9778073a049b923a373b6594279831
07:01:31 <sylvan> dcoutts: Which version of GTK+ should I download in order to play with GTK2Hs?
07:01:43 <Enveigler> dcoutts: Right. That's what I get: 4c9778073a049b923a373b6594279831 *gtk2hs-0.9.8.exe
07:01:50 <ski> esap : so, in linear logic, that env must be copyable/discardable (which is a specific instance of comonoid :)
07:02:10 <dcoutts> Enveigler, however it looks from the log like it's not currupted but something going wrong in the scripts that run early in the setup
07:02:15 <esap> ski: Maybe it's ok, in the dual sense to 'return', which is supposed not to ignore anything of its arguments.
07:02:23 <dcoutts> sylvan, on unix you mean?
07:02:32 <sylvan> windows
07:02:45 <Enveigler> That's what I thought also, but it was worth eliminating the obvious ::0
07:02:46 <dcoutts> oh, we reccomend Gtk+ 2.6.8
07:02:53 <sylvan> ok
07:02:56 <dcoutts> Enveigler, yep
07:02:57 <esap> ski: So I suppose counit of the comonad should be an epimorphism.
07:03:20 <dcoutts> sylvan, the Gtk 2.6 series is much better on windows than 2.4 was
07:03:36 <esap> ski: But I'm really stretching my understanding here .-)
07:03:52 <ski> esap : hm, must return in a monad be a mono ? :)
07:04:06 <sylvan> okay... Does GTK look like native windows or is it like Java where the GUI looks the "java way"?
07:04:25 <esap> ski: Well not really. But it's pretty hard to implement return without doing that.
07:04:39 <esap> ski: and without ignoring the whole argument.
07:04:58 <esap> ski: In a sense, since you can't constrain the argument in any way, you either have to use it all, or not use it at all.
07:05:19 <ski> so maybe one can in other cats ..
07:05:24 <ski> s/so//
07:05:32 <dcoutts> sylvan, since Gtk+ 2.6 on windows it looks native
07:06:01 * Enveigler goes off to upggrade gtk...
07:06:16 <dcoutts> sylvan, I was about to say that the windows installation instructions explained this but I juse noticed that it was a broken link on the download page, fixed now.
07:06:21 <dcoutts> http://haskell.org/gtk2hs/download/
07:06:25 <dcoutts> http://haskell.org/gtk2hs/archives/2005/06/24/installing-on-windows/
07:07:46 <esap> ski: I think you can only use properties common to all objects in the category to implement return. Because the implementation of 'return' doesn't know the exact type of the argument.
07:08:17 <sylvan> hmm trying the examples (buttonbox) I get "can't load dll glib 2.0"... Doesn't GTK+ put the dlls in the system dir or something?
07:09:21 <esap> ski: I suppose there can be a category that allows the implementation of return to actually inspect the contents of the argument to return. But it's pretty special-purpose, at least.
07:10:38 <esap> ski: In practice, I don't remember seeing a category like that that would have a useful monad instance.
07:11:07 <esap> ski: But I suppose some dynamic-typing monad could be one.
07:11:37 <ski> esap : i guess i'm trying to relate to parametricity .. and my current intuitive partial understanding of that is that a value of a universal quantor can only be passed around and discarded/duplicated (and, for types, used as a type for values .. ?). or rather, this latter property implies parametricity (question if the converse implication hold .. ?)
07:11:57 <ski> (hm, that was maybe a little convoluted ..)
07:12:01 <dcoutts> sylvan, no, it adds it's bin directory to the PATH so it should be able to find them that way
07:12:29 <ski> esap : dynamic-typing monad ?
07:12:56 <dcoutts> sylvan, the installer ought to check that the gtk bin dir is on the path to prevent exactly that situation
07:13:12 <esap> ski: a monad in a category that provides mechanism to dynamically inspect most-specific types of arbitrary objects.
07:13:15 <dcoutts> sylvan, we're you running from an existing console window?
07:13:44 <ski> (esap : anyway, e.g. i'm not sure if e.g. things like 'reverse :: forall n :: Nat. forall a :: *. Vector n a -> Vector n a' could be parametric in 'n')
07:13:44 <esap> ski: Some category that has both monad instance and a dynamic_cast, in essence.
07:14:03 <dcoutts> sylvan, the PATH env var might not have been updated if you use a console window that was opened before Gtk got installed
07:14:47 <ski> esap : mhm, hm
07:14:47 <sylvan> hmm.. the path env is updated, and it seems to be pointing to the right place, but it still doesn't work
07:16:15 <sylvan> If I just build it and click the exe I get "can't find gdk_window_set_accept_focus in DLL file libgdk-win32-2.0-0.dll"
07:16:42 <sylvan> If I run it through ghci I getLoading package glib-0.9.8 ... can't load .so/.DLL for: glib-2.0 (addDLL: unknow
07:16:42 <sylvan> n error)
07:16:47 <bourbaki> http://codemages.sf.net/textures.exe
07:16:55 <bourbaki> if someone is interested in my fluid sim :)
07:17:17 <dcoutts> sylvan, yes it doesn't yet work with ghci, for the gory details see: http://sourceforge.net/mailarchive/message.php?msg_id=11297970
07:17:30 <sylvan> ah... but clicking the exe should work right?
07:18:19 <dcoutts> sylvan, it sounds like it's the wrong version or something somehow. Check the properties ofr the libgdk-win32-2.0-0.dll, see what version it is
07:18:28 <dcoutts> yes the exe should work
07:18:38 <wilx> Hm.
07:18:52 <wilx> Any ideas how I could compile darcs on FreeBSD 5.4 for FreeBSD 4.10?
07:18:59 <sylvan> 2.6.8.0
07:19:10 <dcoutts> hmm, that's what we want
07:19:34 <sylvan> strange
07:19:38 <dcoutts> indeed
07:19:39 <ulfdoz_> I've tried this on netbsd and failed as I ran out of swap. :)
07:20:13 <sylvan> it seems to find it but it complains that it can't find the procedure start adress for gdk_window_set_accept_focus...
07:20:21 <dcoutts> sylvan, just on the off chance you could try Gtk+ 2.6.7, but I thought I'd heard that people were using 2.6.8 ok (it was built against 2.6.7)
07:20:40 <sylvan> okay...
07:22:08 <dcoutts> sylvan, the other test you can try is to copy the gtk-demo.exe program into another dir and try running that
07:22:27 <dcoutts> it may be you have another version of gtk on the path that is being picked up first
07:22:42 <sylvan> is gtk-demo.exe from gtk+ or gtk2hs?
07:22:47 <dcoutts> from gtk+
07:22:52 <sylvan> ok
07:23:02 <sylvan> I'm pretty sure I don't have any other gtk in the path (just checked)
07:23:13 <dcoutts> ok (there goes that theory)
07:24:38 <sylvan> installing 2.6.7 now
07:25:09 <Enveigler> dcoutts: I just came across this "For software developers I would suggest that unless you need to use 2.6-only features, you continue to build against GLib and GTK+ 2.4 headers and libraries, even if the run-time environment will be 2.6." --Just thought it worth mentioning?
07:26:47 <dcoutts> Enveigler, the installer will work with Gtk+ 2.4, but we provide one built against 2.6 too so you can use the new features
07:27:16 <sylvan> now the gtk2hs installer says that gtk+ is not in the path, which it most definatly is...
07:27:30 <dcoutts> hmm, what is the path?
07:27:36 <sylvan> d:\program\GTK
07:27:48 <esap> ski:†I just updated my understanding about parametricity (by reading parts of Wadler's paper on theorem's for free). His interpretation of types as relations is somewhat strange.
07:27:59 <sylvan> which is exactly what's in thte PATH variable
07:28:10 <sylvan> (via GTK_BASE_PATH or something like that)
07:28:11 <dcoutts> sylvan, but it should be d:\program\GTK\bin, the gtk2hs installer is right to complain
07:28:13 <Enveigler> Okay. I was just looking to find all the bits for 2.6 and saw that. I remember having some trouble getting 2.4 to work before finding a full set of dependancies.
07:28:23 <sylvan> yes, \bin is there too, sorry
07:28:26 <dcoutts> ok
07:28:46 <dcoutts> in lower case (there was a case sensitivity issue before)
07:29:17 <ski> esap : think i've skimmed that some, but not gotten bery much understanding ..
07:29:50 <esap> ski: The essential thing about parametricity is to understand the relationship between subtypes and relations.
07:29:58 <sylvan> seems to be the correct case
07:30:06 <dcoutts> hmmm
07:30:19 <ski> bah, i thought i'd managed to derive (>>=) from fmap and join, but then i noted i had an equation of form X = X :(
07:30:28 <esap> ski: I mean sub*sets* not subtypes.
07:30:35 <ski> oki
07:30:38 <dcoutts> and you started the gtk2hs installer after installing gtk ? (so the path will have been updated)
07:30:43 <sylvan> yep
07:30:49 <sylvan> gtk-demo.exe works, btw
07:30:55 <dcoutts> ok
07:31:07 <dcoutts> can I see a log? gtk2hs-0.9.8.exe /LOG="gtk2hs.log"
07:31:57 <dcoutts> (I hate windows isntallers)
07:32:35 * Enveigler concurs
07:33:29 <sylvan> extremly strange.. If I run the installer from a command window I get "installation corrupt" but if I double click it in explorer it starts up okay
07:33:56 <dcoutts> that is strange indeed
07:33:58 <esap> ski: The thing is, there are two interpretations of a type. One identifies type with a set of values, and another identifies a type with the identity function.
07:34:27 <sylvan> and creating a shortcut with the LOG thing made the installer stop complaining about not finding GTK+ in the path...
07:34:27 <dcoutts> I sometimes wonder if we need a seperate #gtk2hs support channel :-)
07:34:52 <esap> ski: The difference between these two are that the first one allows values to be black boxes, whereas the second considers values as white boxes (part of interface).
07:35:15 <dcoutts> perhaps it was environment issues, the command line window does not update it's env vars after it's started
07:35:19 <ski> esap : hm is that related to 'newtype Equal a b = E (forall f. f a -> f b)' ?
07:35:53 <sylvan> Well i restarted a new cmd window... Anyhow, GTK+ 2.6.7 installed, Gtk2Hs installed, the same problem occurs
07:36:19 <dcoutts> it says?
07:36:40 <ski> esap : 'values' as normal/canonical forms of expressions ?
07:36:45 <esap> ski: That clearly has the relation point of view, in the sense that 'a' and 'b' are identified, when there is an identity function going from one type to another.
07:37:09 <esap> ski: since 'f' can be anything, the function stored there can only be the identity function.
07:37:17 <esap> ski: even if 'a' and 'b' are different.
07:37:22 <dcoutts> is there a free windows tool that will tell us the .dlls that a program will pick up when it runs?
07:37:27 <sylvan> can't find process start adress gdk_window_set_accept_focus in Dll file libgdk-win32-2.0-0.dll
07:37:36 <dcoutts> I know there is one that comes with MS VS
07:38:07 <dcoutts> we want to verify that it's picking up the right path for the .dlls
07:38:07 <ski> esap : *iirc*, the only possibly functions that can actually be put there is identity function  (otherwise, they could also be isos .. i'm not fully sure ..)
07:38:19 <dcoutts> sylvan, oh, here's another experiment...
07:38:24 <Enveigler> dcoutts: Yes on the free tool thing. PEBrowse.exe .. I'll find a link
07:38:24 <dcoutts> (a short one)
07:38:32 <dcoutts> Enveigler, cheers
07:38:51 <esap> ski: Yea, the point there is that the arrow can be used as a proof that 'a' and 'b' have the same type, because there is a function that is guaranteed to be the identity that goes from 'a' to 'b'.
07:39:09 <esap> ski: The static type of 'a' and 'b' can still be different.
07:39:20 <esap> ski: even if at run-time there is a proof of they being the same type.
07:39:24 <dcoutts> sylvan, copy the gtk2hs demo you compiled into Gtk's bin dir and run it from there. (Windows favours .dlls from the same directory to ones on the path)
07:40:14 <sylvan> strange. now it just exits...
07:40:23 <dcoutts> oh great :-(
07:40:27 <esap> ski: But anyway, this uses the idea that id_A and A are essentially the same thing.
07:40:36 <sylvan> ah, but that was the calc demo, buttonbox seemed to work!
07:40:47 <ski> esap : itym, it can be statically unknown if 'a' and 'b' are same (e.g. existentially quantified) ?
07:40:49 <sylvan> so maybe there are old gtk dlls in my system dirs yeah?
07:40:49 <dcoutts> sylvan, oh yes, the calc needs the .glade file too
07:40:58 <esap> ski: in a sense, the object is only identified by its "public" properties.
07:41:17 <dcoutts> sylvan, yes I would guess so. Now if only my installer could detect that...
07:41:26 <esap> ski: yes. You could have two type variables which are proven to be the same type at run-time.
07:41:39 <sylvan> yep... there was... see if I can find an uninstaller for that or I'll just remove them manually
07:41:46 <dcoutts> sylvan, let's see if Enveigler's dll tool will shed some light on the situation
07:41:53 <dcoutts> oh, ok you found it?
07:41:57 <sylvan> it was 2.4 in windows\system
07:41:58 <sylvan> yep
07:42:02 <dcoutts> ah!
07:42:02 <ski> esap : so (i'd say) they are the same type, just that's not statically known
07:42:30 <dcoutts> sylvan, which is of course on the path (except that we don't notice it!)
07:42:33 <esap> ski: you can write coerce :: Equal a b -> a -> b to do the conversion.
07:42:45 <ski> indeed
07:43:05 <dcoutts> sylvan, so perhaps what I shuould do is check for each .dll in the gtk\bin dir that it is the first on the path
07:43:17 <Enveigler_> dcoutts: http://www.smidgeonsoft.com/ PEBrowse or PEBrowse Interactive.
07:43:19 <dcoutts> or at least for a representative sample
07:43:23 <esap> ski: yea, that's one way to lift run-time type information into static type information.
07:43:36 <dcoutts> Enveigler, cheers
07:43:38 <ski> esap : um, what is ?
07:43:51 <esap> ski: Using Equal and proving at run-time that two types are the same.
07:43:59 <ski> esap : m
07:44:19 <esap> ski: then using this information statically.
07:44:50 <esap> ski: By pattern matching on the proof object.
07:44:53 <ski> esap : except the system doesn't automatically know that the types are equal, as soon as it sees a value of type 'Equal a b' in context  (didn't Epigram have something like this ?)
07:45:13 <dcoutts> sylvan, so all the demos are working now?
07:45:21 <esap> ski: right, you have to use 'coerce' yourself.
07:45:28 <musasabi> Does c2hs support FunPtrs (for finalizers of ForeignPtrs) ?
07:45:41 <sylvan> haven't tried all yet.. I'm switching to 2.6.8 again, and trying to manually remove all gtk stuff from windows\system
07:45:53 <dcoutts> ok
07:46:10 <dcoutts> musasabi, not directly no I don't think so
07:46:14 <ski> esap : and the optimisation system/implementation might e.g. not know that the op is O(0) and essentially id (i.e. a noop)
07:46:32 <dcoutts> musasabi, it'll generate types which use ForeignPtrs, but it's up to you which finalizer to use
07:46:34 <esap> ski: Right, usually it doesn't.
07:47:11 <musasabi> dcoutts: I am having lots of code with a foreignPtr and a free function, but they have to be declared manually which is quite painfull for many types.
07:47:20 <ski> (esap : that would be an point in favour of having the system recognise the situation automatically, so one don't have to do coerces ..)
07:47:28 <esap> ski: And since Haskell types have undefined as element, it cannot know that the proofs are always correct.
07:47:28 <sylvan> yep, everything seems to work now
07:47:51 <ski> esap : m, right ..
07:47:51 <dcoutts> musasabi, oh I see what you mean you want some shortcut for creating the FunPtrs declerations, yes that would be nice gtk2hs does those manually too. Send a feature request to the c2hs mailing list.
07:48:03 <dcoutts> sylvan, excelent (phew!)
07:48:23 <esap> ski: Which is why programmer has to give the proof himself.
07:48:31 <ski> esap : maybe it could begin by forcing the proof .. hmm
07:48:32 <sylvan> =)
07:49:17 <ski> esap : no, that won't help .. ('const undefined')
07:49:24 <musasabi> dcoutts: how did you solve in gtk2hs the problem of FunPtr foreign imports requiring -fvia-c/-fasm for ghci?
07:49:28 <esap> ski: Well it does force the proof. It gives out "quantified type variable ... is unified with another quantified type variable ..." error if the proof is not correct :-)
07:49:53 <esap> ski: you can force it to accept it by using unsafeCoerce#
07:50:10 <ski> esap : "force" as in 'seq' ..
07:50:23 <dcoutts> musasabi, I don't think it was ever a problem. What problem do you find?
07:51:24 <musasabi> "Illegal foreign declaration: requires via-C or native code generation (-fvia-C) \n When checking declaration: \n foreign import ccall safe "static TLS.h &gnutls_anon_free_server_credentials" gnutls_anon_free_server_credentials :: FunPtr (Ptr AnonymousServerCredentials -> IO ())"
07:51:31 <esap> ski: With GADTs, you can build types that require proof.
07:51:41 <esap> ski: like the Equal.
07:51:53 <ski> esap : hm, how do you mean ?
07:51:59 <esap> ski: or data EqType a b where { EqType :: EqType c c }
07:52:16 <dcoutts> musasabi, hmm never seen that, you're comping with -fffi?
07:52:49 <dcoutts> what is the "static .." bit?
07:53:01 <ski> esap : EqType 'a' 'a' :: EqType Int Float
07:53:08 <ski> hm
07:53:11 <ski> forget that
07:53:46 <esap> ski: There is no argument to the constructor, so it's somewhat harder to come up with proofs.
07:53:57 <musasabi> dcoutts: yes, ghci -fffi -lgnutls -fglasgow-exts  TLS.hs
07:54:21 <dcoutts> what does static mean? I've never seen that
07:54:21 <esap> ski: But you can do it with pattern matching.
07:54:31 <ski> esap : now i see what that def. means .. interesting :)
07:54:33 <esap> ski: assuming you can prove that the types are equal.
07:54:35 <musasabi> the static bit is not in the source code, which is 'foreign import ccall safe "TLS.h &gnutls_anon_free_server_credentials" gnutls_anon_free_server_credentials :: FunPtr (Ptr AnonymousServerCredentials -> IO ())'
07:55:43 <dcoutts> so you're loading this up with ghci?
07:55:50 <ski> esap : refl :: EqType a a; refl = EqType;  trans :: EqType a b -> EqType b c -> EqType a c; trans EqType EqType = EqType
07:56:10 <esap> ski: yes.
07:56:26 <dcoutts> musasabi, right I think ghci can't handle that, you need to compile with ghc and then load it up with ghci
07:56:34 <ski> esap : hm .. *thinks* .. ah, now i see how symm is done :)   interesting indeed :)
07:56:38 <musasabi> hmm, ok.
07:56:44 <dcoutts> musasabi, the ghci byte code generatror can't handle those kind of ffi decls
07:57:08 <esap> ski: Of course, if you use 'undefined', 'error' or 'unsafeCoerce#', I think it's possible to break it. But at run-time it will then go into an infinite loop, or raise an exception.
07:57:22 <ski> esap : m
07:57:43 <ski> (except possibly unsafeCoerce#)
07:57:47 <musasabi> dcoutts: thanks, I'll just use ghc then.
07:57:55 <esap> ski: right, it'll probably just crash.
07:58:07 <dcoutts> that's what we do, but then the final result works ok in ghci
07:58:41 * ski is about to give up deriving (>>=) without looking at patersons version .. :/
08:00:35 <esap> ski: Hmm. Actually, it's hard to come up with an example using unsafeCoerce# that would do it.
08:01:28 <ski> crash ? or work ?
08:01:48 <esap> ski: coerce ((unsafeCoerce# :: () -> EqType Int Float) ()) 10   --> 1.4e-44
08:02:08 <esap> But this is very evil.
08:03:11 <ski> yep
08:05:13 <esap> But if you avoid those evil things, EqType forces you to actually prove things. And it's sometimes pretty hard to do.
08:06:02 <vincenz> hello
08:06:53 <esap> For example, it took me some time to find out that I can use 'symm' to prove an implemenation of control operation to work correctly.
08:08:19 <ski> esap : mhm, care to explain/url ?
08:08:40 <esap> ski: see http://www.kotiposti.net/epulkkin/ControlOperation.txt it's an implementation of the control operation in my compiler framework.
08:08:59 <esap> ski: Especially, see eval_unit and eval_counit.
08:09:06 <esap> ski: It uses coerce.
08:09:07 <ski> arg, i'm an idiot ! my join is obviously worng ! :(
08:11:04 <esap> ski: Earlier, I had used unsafeCoerce# in there.
08:15:07 <esap> ski: The types of eval_unit and eval_counit are:  eval_unit :: m f g dom cod -> arr dom a (g (f a)) and eval_counit :: m f g dom cod -> arr cod (f (g a)) a
08:15:28 <esap> ski: where m and arr are existentially quantified.
08:19:13 <ski> esap : hm, i think i don't understand much of that, currently ..
08:19:56 <ski> hm, how do you get existentially quantified tyvars in a typeclass ?
08:20:00 <esap> ski: compare it with http://haskell.org/hawiki/ControlOperation
08:20:46 <ski> also, which tyvars are the (two) args of the class AdjointEval ?
08:21:13 <esap> ski: arr and m
08:21:19 <esap> ski: in that order
08:22:03 <ski> ?? <esap> ski: where m and arr are existentially quantified.
08:22:17 * esap nods.
08:22:43 <esap> ski: the type class existentially quantifies the variables.
08:23:06 <ski> if they're args, then they are neither universally or existentially qunatified, no ?
08:23:15 <ski> hm
08:23:23 * ski tries to think about that
08:23:28 <esap> ski: In the sense, that the instance definition can rely on the concrete types.
08:24:46 <ski> concrete, known types, not unknown types
08:25:17 <esap> ski: right. But instance declaration has the specify the types.
08:25:24 <esap> ski: s/the/to/
08:25:41 <ski> hm, so ?
08:25:58 <ski> hm
08:26:01 <esap> ski: This means the type variable is existentially quantified.
08:26:10 <ski> i'm not sure ..
08:26:28 <esap> ski: Because the class declares that *there exists* some types for which instances exist.
08:26:45 <esap> ski: then instance provides the actual implementations.
08:27:44 <esap> ski: Of course, the *user* can use either existentially or universally quantified type variables.
08:27:46 <ski> hm, data Eq a = MkEq {eq :: a -> a -> Bool}; eqBool :: Eq Bool; eqBool = MkEq {eq = \b0 b1 -> not (xor b0 b1)};
08:29:19 <ski> i think existentially qunatified would be   data SomeEq = forall a. MkSEq (Eq a);  someEqBool :: SomeEq; someEqBool = MkSEq eqBool;
08:29:21 <Enveigler_> dcoutts: Did your sucess with sylvan suggest anything that might help with my problem?
08:29:34 <ski> s/qunatified/quantified/
08:29:39 <esap> ski: Yes, that's existentially quantified.
08:29:43 <dcoutts> Enveigler_, I don't think so :-(
08:30:11 <ski> esap : so it seems to me the instance corresponds to eqBool, not to someEqBool ..
08:30:26 <Enveigler_> 'K. I'll continue my fight with Foreign.Storable then :)
08:30:35 <esap> ski: I mean, think about the connection between the class and the instance, and how the compiler resolves the relationship between them.
08:30:43 <ski> maybe one can't compare like this .. but it still isn't clear to me, in any case
08:31:08 <esap> ski: It's actually possible I'm here confusing relations and existential quantification.
08:32:28 <esap> ski: the class is clearly a relation. But to me it seems that the type variables that are specified in the class head are actually existentially quantified (Compare with type variables that are not declared in the class head but that are used in the functions, those are universally quantified)
08:33:01 <ski> anyway, to me the tyvars in the class seems similar to the 'a' parameter to 'Eq' above, i.e. it's lambda-bound, not forall-bound or exists-bound ..
08:33:10 <esap> ski: For example: class Monad m where { return :: a -> m a ; ... } The 'a' is universally quantified and 'm' is existentially quantified.
08:33:10 <ski> relation, how ?
08:33:45 <ski> data Monad m = MkM {return :: forall a. a -> m a ; ...}
08:33:49 <esap> ski: A class is clearly a way to declare a relation between the declared type variables.
08:34:08 <ski> not same as quantifying 'm' with exists, as i see it ..
08:34:21 <ski> esap : aha, you meant in that sense
08:34:36 <ski> (sorry, a bit tired atm)
08:36:05 <ski> i.e. i think the tyvar in the class is lambdabound
08:36:06 <ski> hm
08:36:08 <esap> ski: Ok, there's a difference between the existentially quantified version and the class version.
08:36:23 <esap> ski: But I'm not sure how the variables become lambda-bound there.
08:36:57 <ski> i'm not either :), just that it is, in the corresponding dict type
08:37:16 <esap> ski: Ah, you're thinking about the translation.
08:37:47 <ski> hm, if we have a relation  p = \(x,y). ..some logic formula possibly using x and/or y..
08:38:01 <ski> esap : i'm trying to *compare* with the translation ..
08:38:26 <esap> ski: Hmm.. I wouldn't describe relations like that.
08:38:28 <ski> then, we can instead say forall x y. p (x,y) <=> ..the same logic formula..
08:38:55 <ski> (which means the same thing)
08:39:17 <ski> so, possibly, we can in a class get some corresponding 'forall' .. hmm
08:40:48 <ski> an instance can (i think) be thought of as a clause for the predicate/relation/class coupled with proof for the method type (i.e. method impls)
08:41:13 <ski> esap : i'm not sure how to continue
08:42:08 <esap> I think the problem is that duals of concepts are too close to each other, it's very easy to confuse them.
08:42:40 <ski> 'class Foo a b | a -> b; instance Int Bool' ==> ':- pred foo(star,star).  :- mode foo(in,out) is det.  p(int,bool).'
08:42:49 <ski> esap : which duals ?
08:44:14 <esap> ski: there is some kind of duality between relations (e.g. monomorphisms r : R -> AxB) and type classes.
08:44:17 <ski> (the target there is in Mercury, a statically typed Prolog descendant)
08:44:57 <esap> ski: But I'm having some trouble placing things in context, e.g. which part of it corresponds to which part in the dual.
08:44:59 <ski> esap : hm, you don't mean 'correspondance' instead of 'duality' ?
08:45:15 <esap> ski: I mean both, I think.
08:45:48 <ski> i'm not sure how they'd be duals ..
08:46:41 <esap> ski: Think of R -> AxB. Dual of that is something like a function (AxB=>V) -> (R=>V) which is an epimorphism.
08:46:55 <bourbaki> hidiho esap
08:46:59 <esap> ski: Where 'V' is an injective object.
08:47:01 <bourbaki> TheHunter hi
08:47:02 <esap> bourbaki: hi.
08:47:29 <bourbaki> http://codemages.sf.net/Unbenannt2.bmp
08:47:35 <bourbaki> a shot of my fluid sim
08:48:05 <ski> esap : que?
08:48:28 <esap> ski: que?
08:48:37 <bourbaki> que que?
08:48:42 <ski> esap : wouldn't dual of mono R -> AxB be epi A+B -> S ?
08:48:48 <ski> (for some S)
08:49:03 <ski> (hm, make that s/S/Q/ for quotient)
08:49:39 <esap> ski: yea, also that :-)
08:49:45 <ski> esap : that above looks like a CPS kinda thing ..
08:50:13 <ski> (also, what's an injective object ?)
08:51:56 <esap> ski: An object V is an injective object, if for every monomorphism f : X -> Y and every g : X -> V there exists h : Y -> V such that h . f = g
08:52:20 <esap> ski: That's a definition from Lawvere&Rosebrugh, page 124.
08:53:35 <esap> ski: And actually, V is injective, iff for every mono f : X -> Y,  (Y=>V) -> (X=>V) is surjective.
08:54:30 <esap> ski: I mean, f=>V : (Y=>V) -> (X=>V) is surjective.
08:54:49 <ski> mhm
08:56:13 <ski> hm, the (f,g) pairs seems to be a partial morphisms from Y to V
08:56:19 <ski> s/pairs/pair/
08:57:36 <esap> partial morphism?
08:59:36 <ski> a partial morphism from A to B consists of a morphism from a subobject of a, to B
09:00:17 <ski> i.e. the subobject is some object S with a mono S -> A (rather, it's an equiv class of such)
09:00:49 <ski> defined in Abstract and Concrete Categories, e.g. (which is available on the net, now :)
09:04:51 <esap> A good example of an injective object is the subobject classifier.
09:05:00 <bourbaki> http://codemages.sf.net/textures.avi a video of the fluid app
09:05:19 <ski> esap : hm, that might make sense :)
09:06:15 <ski> (partial morphisms are related to subobject classifier)
09:06:46 <ski> iirc one can define subobj. class. with help of part. mor.
09:07:17 * shapr wants some amphetamorphisms
09:07:41 <ski> ('Abs and Conc Cats' is a book on CT, available on net, in case it wasn't clear)
09:07:45 <ski> shapr : :)
09:08:21 <esap> ski: I suppose it's this one: http://www.math.uni-bremen.de/~dmb/acc.pdf
09:08:58 <wilx> bourbaki, what codec does it use? my mplayer doesn't know it.
09:09:45 <bourbaki> hm it might be a pretty new one ... how can i see what codec it is?
09:10:31 <wilx> Hm, dunno :)
09:11:20 <esap> ski: There is actually an excercise in Lawvere&Rosebrugh asking to prove that the subobject classifier is injective in any topos, as well as any X=>S, where S is the subobject classifier.
09:12:05 <bourbaki> wilx sry ...
09:12:32 <esap> ski: Anyway, I think we were talking about type classes and relations.
09:13:57 <ski> m, yes (for some reason my browser is very slow atm, so will take some time to check the link ..)
09:14:26 <esap> yea, the link was very slow.
09:15:58 <ski> (no, my browser has been slow for some hour now ..)
09:16:33 <ski> anyway, i think i dowloaded Abs and Conc Cats from a link on wikipedia (possibly main CT article)
09:16:42 <ski> s/dowloaded/downloaded/
09:19:12 <wilx> Hm, when I try to compile latest darcs with wx GUI the configure test for WX dies on missing pthread_* stuff during linking.
09:19:30 <wilx> I guess it is missing -threaded or something, isn't it?
09:20:28 <ski> esap : yes, that link would be the book, yes
09:20:49 <ski> (esap : iirc partial morphism is in last chapter)
09:23:01 <esap> What's this. He says "Since there is no satisfactory categorical concept of subobject or of embedding, partial morphisms will be defined with respect to an arbitrary class M of morphisms, ...". Hmm.. what does he mean there is no good concept of subobject in category theory?
09:23:40 <ski> not in all categories
09:24:17 <esap> So subobject cannot be defined as a (domain of a) monomorphism?
09:24:57 <ski> i think i've mention before that they relativize subobject to a class of morphisms M, e.g. mono, or extremal mono, strong mono, swell mono, etc ..
09:25:36 <esap> ah ok.
09:26:09 <ski> i think they reason like mono-subobj doesn't give satisfactory "part of object" concept in all categories
09:26:29 <ski> e.g. some kind of topological cats, iirc
09:26:57 <ski> (in some example, M wasn't even a subclass of mono ..)
09:29:35 <esap> I've never really had time to digest all the different kinds of mono :-), only split mono and "ordinary mono".
09:31:26 <ski> me too(TM)
09:32:08 <ski> (well, there was some that was the same as "being equalizer of some two morphs", but i don't recall which that was)
09:32:29 <esap> ski: Yea, I remember hearing about that one too.
09:33:23 <esap> But I've thought a lot about the connection between monomorphisms and epimorphisms.
09:33:44 <ski> in what way ?
09:34:08 <esap> well several ways. There is a cancellation property in both.
09:34:35 <esap> Also, mono is used for representing subobjects. An epi can be used to represent equivalence classes.
09:35:14 <esap> And partitions.
09:36:55 <esap> An epi will in a sense lose distinctions between elements of its domain.
09:37:12 <esap> Whereas a mono will preserve distinctions.
09:37:19 <shapr> gnumacs sucks :-( I hate getting random crashes where the whole editor just disappears.
09:39:02 <esap> random crashes with emacs?
09:39:09 <ski> esap : hm
09:39:12 <shapr> Yeah, gnumacs does that on my system.
09:39:24 <ski> esap : epis for quotient objects ! :)
09:40:10 <ski> esap : except that quotient object classifiers seems to be rare (in "ordinary" cats) :(
09:40:25 <esap> ski: quotient object classifiers?
09:40:44 <ski> esap : i'm not sure that that 'lose/preserve' is correct/good duality ..
09:40:58 <esap> ski: It's not a duality.
09:40:58 <ski> esap : dual of subobject classifier, of course :)
09:41:16 <esap> ski: yea, of course :-)
09:41:16 <ski> epi is dual to mono, no ?
09:42:35 <esap> ski: but note that properties are dual to elements.
09:42:44 * Heffalump wonders if anyone knows how to build a profiling version of HaXml
09:43:20 <esap> ski: and since a subobject classifier has one or more elements (e.g. true, false, ...), I suppose a quotient object classifier should classify properties.
09:45:14 <esap> ski: Actually, I guess a quotient object classifier would be like Bool->Bool functions :-)
09:48:51 <esap> ski: Though I'm not sure if I'm assuming some set-theory related assumption that is not true in general categories.
09:50:48 <Lemmih> Heffalump: The cabalized HaXml?
09:51:07 <Speck> "The Prelude contains a number of classes defining monads are they are used in Haskell."  from section 9.1 on haskell.org/tutorial
09:51:21 <Heffalump> lemmih: well, 1.13
09:51:21 <Speck> kind of a funky sentence
09:51:27 <Heffalump> I don't care how I install it really.
09:51:41 <Lemmih> Heffalump: Is it cabalized?
09:52:23 <Heffalump> umm, it has a cabal file. I'm not sure if it's part of the standard build process.
09:54:14 <ski> esap : hm, maybe (re 'like Bool -> Bool')
09:54:22 * shapr hugs Haskell
09:54:35 <shapr> After a few hours of wading through Python code, Haskell makes me feel good.
09:55:32 <Lemmih> Heffalump: You can pass --enable-library-profiling to configure if it's cabalized.
09:55:42 <Heffalump> ok, ta
09:55:50 <dcoutts> Heffalump, if I recall correctly the latest HaXml has two build systems, it's old one and one using cabal
09:56:13 <ski> esap : yes, i call dual of 'generalized elements' and 'T-element'   'generalized properties' and 'P-property'
09:56:34 <reffie> y friends!
09:56:39 <reffie> i got a job offer!
09:56:45 <shapr> yay!
09:57:04 <esap> ski: ok. And a A-property is an arrow p : A -> V, for some V.
09:57:19 <ski> esap : hm, could one call 'Omega-property'  'global property' ? (Omega = subobj. classif.)
09:57:40 <ski> esap : ?
09:57:52 <esap> ski: I wouldn't call them global, because it classifies only subobjects :-)
09:58:06 <ski> esap : i'd say an A-property of B is an arrow B -> A
09:58:06 <esap> ski: But of course, subobjects are very important.
09:58:19 <esap> ski: ah ok, that way :-)
09:58:36 <ski> esap : compare with T-element of U being T -> U
09:58:54 <esap> ski: true.
09:59:18 * reffie dances around the channel
09:59:29 <shapr> reffie: What job?
09:59:40 <reffie> shapr software engineer
09:59:51 <shapr> cool, whereat?
09:59:55 <ski> reffie : nice
10:00:01 <reffie> google
10:00:28 <ski> esap : why'd want to have your kind of 'A-property' ? (curious)
10:01:15 <esap> ski: what do you mean? My mixup with A and V with the naming? :-)
10:01:40 <ski> esap : of cource, sub-object classifier are not dual to usual "pointing objects" like e.g. terminal  (maybe the correct would be separator and coseparator ?)
10:02:02 <ski> esap : oh, it was just a mixup ? :-o
10:02:23 * esap nods.
10:02:40 <esap> Yea, A-property of V and V-property of A are too similar for me.
10:02:51 <ski> (i.e. correct for speaking about 'global element' and 'global property' ..)
10:04:27 <esap> ski: hmm.. I think the name 'global element' comes from the fact that the generalized element starts from the empty context (="1"). For a global property, I suppose you would then need to consider arrows A -> 0, (~continuations).
10:04:47 <ski> of course, when one in one context just speaks about a specific P-properties (for some specific P), one'd prolly state P at beginning, at later just use 'property of/over A' meaing 'P-property ...'
10:05:05 <ski> esap : maybe, i'm not sure
10:05:25 <ski> esap : possibly it'd be better to start from separator/coseparator instead ?
10:07:04 <esap> hmm.. good idea.
10:07:29 <_Codex> 1 is separator... So any separator would work there..
10:07:59 <ski> esap : hm, e.g. in linear logic based category, a possibly more natural "pointer object" for generalized elements, would be the unit of multiplicative conjunction (i.e. tensor), instead of unit of additive conj. (i.e. with = cat. prod.)
10:08:31 <ski> esap : hm, possibly better example : consider pointed sets, surely the zero object is not a good "pointer" ?
10:08:41 <esap> heh
10:09:00 <Heffalump> Lemmih: with what version of cabal does --enable-library-profiling work?
10:09:25 <ski> (esap : better as in you have better chance of following what i mean :)
10:09:57 <Lemmih> Heffalump: It's pretty new. Probably 1.1.1
10:10:17 <esap> ski: I was thinking the huge difference between the dual categories was the same difference as the difference between elements and properties.
10:11:15 * Speck ponders. what if mplus were called (++) and mzero were called nil
10:11:30 <esap> ski: So for properties, the initial object would kind of have the same meaning as the terminal object has for elements.
10:11:32 <dcoutts> hey reffie does that mean you'll be able to get more SoC projects to go towoards Haskell next year? :-) (Though we were very pleased to get one)
10:11:33 <ski> esap : hm, possibly (not quite sure what you mean)
10:11:48 <_Codex> esap: huh? isn't property just a set of elements? (with some common "property" attached to all elements of the set)
10:11:51 <reffie> dcoutts hehe we'll see :P
10:11:59 <ski> esap : in the dual cat, right ?
10:12:20 <ski> _Codex : *generalized* property (in terms of CT)
10:12:22 <esap> codex: well that's the subobject generated by the property (in Set)
10:12:36 <dcoutts> reffie, congratulations btw :-)
10:12:37 <esap> ski: yes.
10:13:45 <reffie> dcoutts thanks :P
10:13:49 <esap> codex: subobjects and properties are not the same thing, even if in Set, there is a one-to-one correspondence (due to special axiom in Set).
10:14:21 <esap> codex: I mean, for properties involving the subobject classifier.
10:14:36 <ski> Omega-properties
10:16:15 <_Codex> esap: well, property would mean "something common attached to all elements", and the subobject would mean "all the elements with the property"? i.e. A -> ? vs T -> bool?
10:16:55 <ski> bool being Omega in Set
10:17:11 <dcoutts> reffie, we managed to get the Google SoC project for Gtk2Hs + cairo integration because one of the engineers involvind in the project at Google was a keep ocaml+cairo+gtk hacker! (could hardly have been any better targeted!)
10:17:17 <esap> codex: Right.
10:17:24 <dcoutts> keop/keen
10:17:28 <_Codex> T -> bool meaning characteristic function of the (sub)set of T.
10:17:43 <ski> _Codex : your first would be a ?-property of A, and the second a bool-property of T
10:18:59 <ski> the something common attached to all elements of A could e.g. be a bool element
10:19:17 <ski> A -> bool  i.e. bool-property of A
10:19:36 <ski> but other (generalized) properties are possible, with this terminology
10:21:35 <ski> (_Codex : or did i misinterpret your first A -> ? example ?)
10:22:44 <Lemmih> Was EuroHaskell last month?
10:22:47 <_Codex> ski: that sounds right. A->? is clearly ?-property of A.
10:23:33 <ski> _Codex : yes, just wasn't fully sure you intended that to be interpreted as a kind of property at all ..
10:24:26 * CosmicRay begins his Haskell port of CDK
10:24:52 <_Codex> ski: but the 2nd example, I was thinking A is subset of T. So T->bool would be defining what A is all about.
10:25:12 <Lemmih> CosmicRay: CDK?
10:25:22 <CosmicRay> Lemmih: Curses Development Kit
10:26:02 <_Codex> so the T->bool would not be a property of T (or bool-property or anything like that).
10:26:13 <yosemite> I'm getting "undefined reference to `GHCziTopHandler_runMainIO_closure'" when linking using ghc6 on debian.  Is there some package that I'm missing here?
10:27:21 <ski> _Codex : so '?' = 'T' ?
10:28:36 <_Codex> ski: hmm, no.
10:30:08 <_Codex> ski: more like: T->A; A->?;   ==> T -> ?. Both T->bool and A -> ? is needed so that the composition works. The other side defines subset of all elements, the other defines the property and what you can do with it? :)
10:30:25 <yosemite> odd it appears that I had a stale .hi file or something
10:31:22 * esap starts thinking about subobject classifiers in Cat.
10:31:25 <_Codex> but maybe I'm thinking it a little strange way.
10:34:22 * esap has to get something to eat though.
10:35:41 <dcoutts> CosmicRay, so CDK has a rather inflexable main loop?
10:36:22 <dcoutts> as I recently had yet another idea suggested to me, but it depends on the Gtk+ main loop api being quite flexable
10:37:59 <Heffalump> is -prof -caf-all known broken in GHC 6.4?
10:39:36 <Heffalump> without -O (so -via-C I think)
10:43:57 <shapr> rgrig: Learning Haskell?
10:44:22 <Lemmih> shapr: When's EuroHaskell 2005?
10:44:33 <rgrig> shapr: yep
10:44:42 <shapr> Lemmih: There might be one in September just after ICFP.
10:44:50 <shapr> rgrig: Have any questions or need some pointers?
10:45:30 <rgrig> shapr: what is eurohaskell? and, no, i don't have any particular question right now.. i just entered to see what kind of discussions happen in here.
10:46:25 <Lemmih> shapr: There might?
10:46:26 <shapr> EuroHaskell is something like an academic lan party.
10:46:58 <shapr> Lemmih: Right, I'm not yet certain.
10:47:14 <shapr> That is, I may not be able to organize/attend. Others could though.
10:47:15 <CosmicRay> dcoutts: actually it seems that CDK is not event-driven
10:47:18 <ski> (_Codex,esap : hm, logs say i missed a few lines .. (and some of my last lines didn't make it across))
10:47:19 <CosmicRay> dcoutts: now that I look at it.
10:47:29 <CosmicRay> dcoutts: the problem is that it is not thread-safe though
10:47:38 * Lemmih has been training on his uni for the occasion.
10:47:49 <ski> _Codex : mhm ? because if you had A -i-> T -c-> bool with i injecticve (mono), then c would be the classifier of A as a subobject of T ..
10:47:55 <ski> esap : anyway, having quotient-object classifiers would be interesting .. but i guess one can still work some with only plain copartial morphisms (hm, better name for those ?)
10:48:04 <ski> (esap : hm, we were originally talking about type classes and relations .. :)
10:48:23 <shapr> Lemmih: cool, want to talk about new tricks on #unicycling?
10:48:55 <rgrig> shapr: cool, what's a "lan party"? :)
10:49:16 <Lemmih> shapr: But there will be a EuroHaskell'05, right?
10:49:48 * ski goes for food, too
10:50:26 <shapr> rgrig: A "lan party" is where a bunch of people bring their computers to play network games. An academic lan party is where a bunch of people get together to have the same sort of social, geeky, and not necessarily productive fun but more focussed on something academic. I guess.
10:51:39 <rgrig> shapr: so it's not something that happens over the Net?
10:52:07 <shapr> For EuroHaskell 2004, some people got together in person, but everyone was still on IRC too.
10:52:20 <Heffalump> shapr: is EuroHaskell 2005 happening, then?
10:52:45 <Heffalump> oh, /me reads scrollback
10:52:51 <shapr> I'm not sure, dons mentioned that he would be in Europe for a week or two after ICFP, so it might happen then.
10:52:56 * Heffalump is in Tallinn until the Sunday.
10:53:14 <Heffalump> but I don't have any spare holiday
10:56:00 <shapr> Heffalump: I'll tell you when I have more details.
10:56:35 <Igloo> In .se again?
10:57:10 <shapr> I think so, but if there's another central location that would be an option.
10:57:24 <Lemmih> How about Copenhagen? (:
10:58:24 <shapr> Possibly, it depends on on whether locals can organize a place to meet and maybe internet.
10:58:54 <CosmicRay> hmm, are there any automatic C interface generators other than c2hs?
10:59:01 <CosmicRay> @wiki c2hs
10:59:01 <lambdabot> http://www.haskell.org/hawiki/c2hs
10:59:04 <shapr> That's one nice thing about Chalmers, we can likely get John Hughes and others to do part of the organizing, and maybe even show up and give a talk.
10:59:24 <Igloo> hsc2hs does less, but has less overhead
11:00:10 <CosmicRay> yeah, I'm familiar with hsc
11:00:14 <Heffalump> it's not really an automatic interface generator, is it?
11:00:19 <CosmicRay> Heffalump: right
11:00:25 <CosmicRay> it just makes it easier to manually build one
11:05:14 <CosmicRay> hmm, it appears c2hs is not as automatic as I have been lead to believe, either
11:10:48 * Enveigler_ twitche
11:12:18 <basti_> hi
11:12:41 <dcoutts> CosmicRay, you mean it doesn't generate haskell modules for you?
11:13:05 <CosmicRay> not automatically, just from looking at a .h
11:13:11 <CosmicRay> I have to say "make this function with this type"
11:13:15 <CosmicRay> and it just uses the .h for assistance
11:13:23 <BigDuke> anyone ever worked with Text.Regex
11:13:33 <BigDuke> i cant get it to do very simple stuff
11:13:37 <dcoutts> CosmicRay, that'd be nice, but I suspect it'd never quite do what you want
11:13:47 <BigDuke> like matching one word :S
11:14:03 <dcoutts> CosmicRay, but it might provide a useful starting point, and c2hs has all the infrastructure to build such a tool
11:14:44 <basti_> @hugs matchRegex (mkRegex "test") "test"
11:14:49 <lambdabot> Variable not in scope: `matchRegex'
11:14:56 <basti_> hmm
11:15:00 <dcoutts> CosmicRay, for gtk2hs we generate .chs modules from the gtk .h files, but we use a custom .h scanner because a generic one wouldn't understand the style of our binding (modeling GObjects and such like)
11:15:14 <basti_> BigDuke: this results in (Just []) which seems to be a reasonable answer.
11:15:53 <CosmicRay> hmm, interesting
11:15:54 <BigDuke> hmm
11:16:03 <rgrig> @hugs 1+1
11:16:05 <lambdabot> 2
11:16:08 <basti_> BigDuke: "Nothing" would be strange.
11:16:08 <rgrig> wow :)
11:16:19 <BigDuke> it just consumes
11:16:19 <BigDuke> ?
11:17:14 <ski> is @hugs alias for @eval ?
11:17:21 <dcoutts> CosmicRay, our system is actually rather complex, we use a perl program we pinched from the gtk# people which generates xml representations of the API (at a fairly high level) and then we have a custom code generator which spits out .chs files
11:17:25 <basti_> BigDuke: no, i think, things like "test(test)test" would then return something inside the Just?
11:17:45 <BigDuke> owww wait
11:17:55 <BigDuke> boy it has been a while heheh, thanks
11:19:04 <dcoutts> CosmicRay, someone on one the haskell list was talking about a new tool "ffigen" or hsffigen or something similar whihc would actualy generate bindings from .h files I think
11:19:47 <CosmicRay> dcoutts: ahh, thanks, I do see a ffigen site
11:21:25 <dcoutts> hmm, not sure that's the one
11:21:33 <dcoutts> let me try and find the email...
11:22:43 <dcoutts> CosmicRay, ah! "hsffig"
11:23:09 <dcoutts> @google Announce: Yet Another Tool to Generate FFI
11:23:11 <lambdabot> http://www.opensubscriber.com/message/haskell-cafe@haskell.org/1607371.html
11:23:39 <dcoutts> http://www.golubovsky.org/repos/hsffig/README
11:23:42 <basti_> BigDuke: so does it work or not?
11:23:49 <BigDuke> hmmm
11:24:23 <BigDuke> mkRegex "DATA[:space:]*([:alpha:]+)" should match "DATA      Foo" shouldnt it?
11:24:33 <BigDuke> and return Foo
11:24:43 <basti_> I'd think so, yes
11:25:31 <basti_> Just "Foo" that is
11:25:38 <BigDuke> it doesnt
11:26:27 <basti_> [:alpha:] doesnt work there
11:26:45 <BigDuke> weird, thought that was posix
11:27:38 <CosmicRay> is it just me or is golubovsky.org very, very slow?
11:28:20 <basti_> Text.Regex> matchRegex (mkRegex "Test ([[:alpha:]]+)") "Test TestTest"
11:28:21 <basti_> Just ["TestTest"]
11:28:28 <BigDuke> yeah
11:28:35 <BigDuke> classes should have extra brackets
11:28:41 <BigDuke> :S
11:28:43 <BigDuke> my bad again
11:30:38 <rgrig> why does (matchRegex (mkRegex "test") "test") return (Just []) ?
11:31:02 <Heffalump> Just ... indicates success
11:31:06 <Heffalump> and [] is the list of bindings
11:31:23 <Heffalump> since "text" doesn't request any bindings, the list is empty
11:31:37 * basti_ nods
11:31:51 <rgrig> aha.. I thought it is the list of substrings that match..
11:32:01 <rgrig> so the whole string has to match the regex?
11:32:25 <rgrig> (in order to get Just)
11:32:39 <basti_> yes. Match = just, doesn't match = nothing
11:33:40 <Igloo> But "foobar" matches "b", just not "^b$"
11:36:01 <rgrig> Igloo: you are confusing me :p
11:36:24 <rgrig> Igloo: if there are multiple substrings that match the regex and the regex has bindings, what is returned?
11:37:43 <basti_> the first I'd say
11:38:42 <basti_> because of maximal munch
11:38:56 <Igloo> I think it should follow the rules in http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html
12:02:11 <liyang> Another Nottingham person? o.O
12:08:35 <Heffalump> Nottingham and Oxford are both quite well represented on here, if you count people who have been at those places as well as people who are.
12:25:05 <astrolabe> I downloaded hugs onto my machine at work, but winhugs doesn't evaluate expressions there.  Plain hugs works fine though.
12:29:21 <ski> winhugs doesn't evaluate expressions ??
12:29:57 <ski> what does it do then ?
12:29:58 <astrolabe> Well I typed 3 + 2 at the prompt and it printed a blank line and a new prompt.
12:30:15 <ski> weird
12:30:28 <astrolabe> When I tried to call a function from my file, it did the same thing and didn't create a file it should have done.
12:30:36 <ski> hm, maybe it uses strange color settings ?
12:31:08 <ski> what bg and fg color do you have ?
12:31:11 <astrolabe> I'm always having twilight zone moments with computers, it is normally me being dumb.
12:31:45 <astrolabe> I'm at home now, so I can't check.
12:31:50 <ski> ok
12:32:25 <ski> and you just started winhugs ?
12:32:54 <astrolabe> I've had it at home for a while, but I''ve switched to GHC here.
12:33:04 <ski> (i think i at times have encountered some bug which makes it to hang, and not print anything .. hm, not even a prompt actually)
12:33:31 <ski> sorry. you just started winhugs and typed "3 + 2" (nothing more before) ?
12:34:06 <astrolabe> Ah no, I think I had 'added' my program.
12:34:20 <ski> hm, sounds weird anyway ..
12:34:29 <astrolabe> Mabe i should try re-starting :)
12:34:38 <ski> winhugs ? or windows ? :)
12:35:38 <astrolabe> :)  Well you have to restart windows everytime you press return, or it won't accept the new data.
12:37:39 <ski> heh
12:40:20 <Speck> got an ot question, does anyone know of a mobile sip phone? something that could discover my wireless network, or even something tied into a sattelite connection?
12:42:01 <dcoutts> @seen SyntaxNinja
12:42:02 <lambdabot> I saw SyntaxNinja leaving #haskell 2 days, 19 hours, 42 minutes and
12:42:02 <lambdabot> 38 seconds ago.
12:46:26 <BigDuke> no-one made a regex generator for Text.Regex? seems useful
12:56:28 <dcoutts> anyone know the darcs repo for cabal? It's not obvious on the website
12:56:28 <dcoutts> oh, found it
12:56:54 <swiert> liyang: sorry, I wasn't paying attention. Are you Graham's new PhD student?
12:57:54 <liyang> swiert: *nod*
12:58:17 <swiert> ok - nice to "meet" you.
12:58:20 <liyang> :)
12:58:36 <swiert> when do you plan on starting?
12:59:05 <liyang> Ah, you're one of Thorsten's students. :)
12:59:24 <liyang> January. Still doing an MSc down here in London. :-/
12:59:27 <swiert> yep. Just started.
12:59:48 <BigDuke> damn, i would never move to another country for my study
12:59:50 <BigDuke> i think
12:59:55 <swiert> We're actually getting quite a few new phd students - so that should be good.
13:00:17 <liyang> BigDuke: there are few places I could move to... there's the language thing to begin with.
13:01:00 <BigDuke> for me, its more that i want to stay in my homeland
13:01:17 <swiert> BigDuke - where are you now?
13:01:37 <BigDuke> les pays bas
13:01:46 <liyang> swiert: *nod*
13:01:51 <swiert> Utrecht?
13:02:00 <liyang> Will be up to visit before January :)
13:02:07 <BigDuke> stuck in ehv
13:02:13 <Philippa_> swiert: you're in snotts now?
13:02:49 <Philippa_> I really should pay more attention to what's actually going on in CSiT :-)
13:03:13 <swiert> Philippa: yes and no. I'm here on and off.
13:03:32 <Philippa_> ah. I'm here pretty much all the time. May or may not even be studying again come january
13:03:39 <liyang> Philippa_: where are you btw? I never figured that one out.
13:03:41 <swiert> I plan to make the definitive move in September.
13:04:10 <swiert> BigDuke: ehv?
13:04:13 <Philippa_> liyang: I'm a suspended student at UoN. I'm living in dunkirk - in fact, my road's next to uni park campus
13:04:22 <BigDuke> eindhoven :)
13:04:28 <liyang> *nod*
13:04:29 <BigDuke> the city of lights
13:04:45 <Philippa_> can get more specific than that sometime you fancy a drink or something :-)
13:05:16 <liyang> I don't really drink but sure, I don't object to others. :)
13:05:31 <Philippa_> drink is optionally non-alcoholic, really :-)
13:05:40 <liyang> True. heh.
13:05:56 <swiert> liyang: if you don't drink, you may want to reconsider about .nott.
13:06:06 * Philippa_ laughs
13:06:17 <Philippa_> not too big a deal I would've thought, it's always amusing being sober when nobody else is
13:06:19 <liyang> swiert: <g>
13:06:26 <wagle> "if you dont really drink, then drink this, it isnt really alcoholic"
13:07:05 <liyang> I can tell from a good ten paces away. :p
13:07:10 <Philippa_> swiert: offer goes for you too btw :-) If nothing else I've got way too much spare time
13:07:21 <Philippa_> heh, my boyfriend usually can too - he can't stand most beer
13:08:12 <swiert> thanks - at the moment I'm pretty busy trying to find a decent place to stay.
13:08:31 <swiert> what I've got now in Beeston lasts till September.
13:08:47 <Philippa_> I know a couple of folks who're in a bit of trouble over that, I might be able to put you in touch?
13:09:47 <swiert> the thing is - my gf is also moving over, we're looking for a place for the two of us.
13:10:16 <Philippa_> fair enough. It's pretty expensive finding somewhere for two, good luck
13:10:46 <swiert> well - unfurnished goes for 450 - 500 pounds.
13:10:51 <liyang> um...
13:11:06 <liyang> I'm paying 490 per month.
13:11:08 <liyang> For half a flat. :p~~~
13:11:10 <Philippa_> which part of town?
13:11:15 <Philippa_> (though that was still more'n'we had spare, and more'n'we're going to for quite some time
13:11:21 <Philippa_> liyang: *ouch*
13:11:30 <liyang> *cough*London*cough*
13:11:41 <Philippa_> point
13:12:44 <gauge> lazy jones baby
13:12:47 <gauge> ow, wrong chan
13:13:02 <liyang> Anything I'll be getting in Notts can only be considered bloody cheap. XD
13:13:31 <Philippa_> ~£200/month for a room in a 4-6 bedroom house is about typical, maybe slightly more depending on where you look
13:24:31 <Igloo> Hmm, borrowing code from people with different attitudes on warnings to you can cause a lot of noise
13:26:37 <CosmicRay> Igloo: in your bts, are you using an existing haskell web toolkit, are did you roll your own?
13:26:50 <Igloo> Rolled my own
13:27:03 <Igloo> But the basic (HTML -> HTML) idea is from WASP
13:27:29 <CosmicRay> would it be suitable as a general-purpose library?
13:27:49 <Igloo> Yes
13:28:11 <Igloo> I should hack it so TH isn't needed for building, really
13:28:49 <Igloo> What do you want it for, OOI?
13:29:00 <CosmicRay> just curious
13:29:51 * CosmicRay discovers a port of gtk 2.2 to curses
13:30:05 <Igloo> Oh, rats. I'm linking tons of WASH into all my executables now
13:30:15 <wagle> libaa?
13:30:20 <CosmicRay> no, cursed
13:30:25 <Khisanth> CosmicRay: cursed gtk?
13:30:29 <CosmicRay> http://zemljanka.sourceforge.net/cursed/
13:30:31 <CosmicRay> yup
13:30:34 <Khisanth> :)
13:34:39 <dcoutts> CosmicRay, that's silly! :-)
13:34:56 <CosmicRay> dcoutts: otoh, it may save me from having to write a new Haskell binding
13:35:07 <CosmicRay> AND has the advantage that a single program could target both X and ncurses ;-)
13:35:20 <dcoutts> that's true, but only if the thing works
13:35:24 <CosmicRay> it seems that is does
13:35:35 <dcoutts> still? not just gtk 2.2
13:35:48 <wagle> if its not libaa, then its not purdy 'nuf
13:35:59 <CosmicRay> wagle: libaa isn't what you want for displaying text on-screen
13:36:04 <CosmicRay> dcoutts: eh?
13:36:14 <_metaperl> I would like to know what parenthesis I can eliminate from this function definition
13:36:19 <_metaperl> payoutPerYearPerMagazine = payoutPerYear / (length (momMagazines ++ myMagazines\
13:36:19 <_metaperl> ))
13:36:37 <Igloo> The outer ones
13:37:02 <wagle> hmm..  apparently i did mean aalib
13:37:06 <dcoutts> CosmicRay, what I mean is, it looks like it hasn't been updated in a while. I wonder if it works with the latest version of gtk
13:37:52 <CosmicRay> dcoutts: ah.  yes, I am wondering that too.
13:37:58 <wagle> recursive text!  what more could you want?
13:38:05 <CosmicRay> heh
13:39:41 <_metaperl> Igloo: thanks
13:40:24 <Igloo> CosmicRay: Did you package WASH for Debian at one point, or did I imagine that?
13:42:42 <dcoutts> @seen SyntaxNinja
13:42:43 <lambdabot> I saw SyntaxNinja leaving #haskell 2 days, 20 hours, 43 minutes and
13:42:43 <lambdabot> 19 seconds ago.
13:42:53 <dcoutts> oh I already asked that
13:43:05 <dcoutts> we've got a cabal patch to send in :-)
13:43:20 <dcoutts> thanks to der_eq :-)
13:46:47 <Igloo> Oh, does Wash.Mail.MailParser not actually parse the MIME bits of a mail for me?
13:52:43 <CosmicRay> Igloo: Yes, I did package WASH for debian
13:52:46 <CosmicRay> Igloo: I think it is in sid already
13:52:56 <CosmicRay> Igloo: I think it does...
13:53:05 <CosmicRay> something somewhere in WASH does, anyway ;-)
13:53:18 <CosmicRay> parseMessageFromString
13:53:21 <CosmicRay> then digestMessage
13:53:38 <CosmicRay> from MailParser.
13:53:59 <Igloo> Ah, digestMessage is what I was missing. Thanks
14:01:39 <basti_> hmm would anyone of you send me a batch of spam mails in a .zip or something?
14:02:09 <dcoutts> basti_, how many do you want? 100? 10,000? :-)
14:02:29 <basti_> ~200 would be nice
14:02:50 <dcoutts> basti_, I can't do you more than 15,228 :-)
14:03:33 <astrolabe> Well, you could post is address on the internet
14:03:34 <basti_> that must be harsh
14:03:41 <basti_> i only get a few spams each day
14:03:45 <dcoutts> I seem to get a lot of "small cap" ones recently
14:03:57 <dcoutts> also goes by the name "penny stocks"
14:04:03 <basti_> astrolabe: i thought about this.
14:04:16 <dcoutts> basti_, email address?
14:05:04 <basti_> -msg-
14:07:16 <Heffalump> have you got enough?
14:07:36 <basti_> nothing did arrive yet.
14:08:49 <wagle> my computer is downloading 4.000000000000001 MB
14:09:21 <wagle> this is winme..  betcha linux cant do that!
14:20:10 <hatchetmn> with regexps, can i group without him thinking he must return it....
14:20:55 <basti_> uhm?
14:22:09 <hatchetmn> ok i have the following pattern "[[:alpha:]]+[[:space:]][[:alpha:]]+" which i want to do many times
14:22:24 <dcoutts> who's a cabal developer/contributor around here? Igloo?
14:22:28 <hatchetmn> simply putting a * behind it doesnt seem to work
14:22:36 <Igloo> Don't think so
14:22:44 <hatchetmn> ow wait
14:22:47 <basti_> hatchetmn: put braces around it?
14:23:05 <Igloo> If this is your patch, why not send it to wherever the website suggests (or darcs send if that's configured)?
14:23:37 <Igloo> parentheses
14:23:42 <dcoutts> it's more of a policy question
14:24:35 <hatchetmn> braces dont seem to work
14:24:46 <basti_> actually i think i meant parenthenses
14:24:47 <Igloo> Hmm, Wash.Mail has left an =20 in my test mail
14:25:12 <basti_> "round braces" vs. "curly braces"
14:25:18 <hatchetmn> the problem is that "([[:alpha:]]+)[[:space:]]([[:alpha:]]+)" returns two things...but if i but parenthesis around the whole thing and a +...that will also return the whole thing
14:25:27 <dcoutts> so we've (well der_eq added) a patch to cabal to add a "./setup configure --with-ghci" flag so that it will build the ghci .o file during "./setup build" rather than "./setup register"
14:25:40 <hatchetmn> second but=put
14:25:44 <dcoutts> we think this should be the default policy
14:26:22 <dcoutts> the question is do other people need the current behaviour
14:27:26 <dcoutts> we could imaging adding ./setup configure --withouth-ghci and then adding a ./setup register --with-ghci option
14:27:46 <dcoutts> so that people who really want the ghci libs to be built at register time could have that
14:27:50 <hatchetmn> you see my prob basti_ ?
14:28:17 <basti_> hatchetmn: yes
14:28:34 <dcoutts> (apparantly some rpm packages don't include the ghci .o files but they are built at install time)
14:28:42 <dcoutts> Igloo, am I making sense?
14:28:46 <hatchetmn> it must be a common problem i reckon...
14:29:25 <basti_> hatchetmn: hmm.
14:29:28 <Igloo> I'd suggest the libraries list is the best place to discuss that, so that everyone interested could have their say
14:29:46 <dcoutts> yeah, ok
14:29:48 <Igloo> I think debian wants the same as you, FWIW
14:30:42 <dcoutts> ok, well propose --with-ghci be default (ie the option won't actually exist) and we'll add --without-ghci as an option
14:31:02 <dcoutts> (won't actually exist since it'll be the default!)
14:32:11 <Igloo> It might want to exist anyway so you can override --without-ghci
14:32:54 <sylvan> What was the reason for not allowing a forkOSinThisThreadRightHere construct again? To allow concurrent programs to call a C lib from the same OS thread even though there may be several haskell threads...
14:34:11 <hatchetmn> basti_, maybe non-capturing subgroups is what i need
14:35:13 <hatchetmn> hmm not really
14:35:20 <basti_> hatchetmn: hmm
14:35:26 <basti_> hatchetmn: i dont have a good idea i think
14:35:39 <hatchetmn> if i make the outer group non-capturing it ignores every result within the group....
14:35:40 <hatchetmn> ok
14:35:56 <basti_> i think this is buried in the way regexes work
14:36:33 <vegai> hmm
14:36:34 <vegai> http://mosnews.com/news/2005/07/25/spammerdead.shtml
14:37:08 <basti_> thats what you get
14:38:12 <vegai> perhaps the killer should get a medal..
14:58:20 <BigDuke> wtf, posix regexp expressions dont have non-capturing groups?
15:05:32 <BigDuke> or it does
15:05:34 <BigDuke> or it doesnt
15:05:45 <Khisanth> try it and see?
15:06:56 <BigDuke> in normal languages, you do "(?: .... )"
15:07:09 <BigDuke> here it complains "Text.Regex.Posix.regcomp: error in pattern"
15:07:29 <Khisanth> I don't know about normal but that is in Perl :)
15:07:41 <BigDuke> so i dont know if the syntax is simply different or that it cant handle non-capturing groups
15:07:54 <BigDuke> (which would render Text.Regex useless)
15:08:28 <Khisanth> not useless perhaps more ... verbose/baroque(?) patterns :)
15:10:47 <BigDuke> uhm, how would i ignore the result of a groups surrounding multiple subgroups without that construct?
15:12:22 <BigDuke> i think i¬¥ll just rip john meachams regexp stuff and skip Text.Regexp
15:13:35 <thedward_> multiple passes
15:14:03 <BigDuke> multiple passes?
15:14:13 <BigDuke> and what if the nr of passes are unknown?
15:15:20 <thedward> you can programmatically generate the regular expressions as appropriate
15:15:45 <thedward> I know I've seen reference to Text.Regex.PCRE somewhere
15:15:47 <BigDuke> but you'd have to know how many times which is dependent upon the input string?
15:17:23 <thedward> how exactly you would do it would depend on exactly what you are trying to accomplish. most cases where you would use a non-capturing subgroup could be rewritten as one pass that grabs the match plus the chunk you don't want, then a second pass that removes the chunk you don't want
15:17:48 <BigDuke> hmmm
15:18:01 <BigDuke> that does sound rather god awful
15:18:06 <BigDuke> time to sleep
15:18:08 <BigDuke> later and thanks
16:31:59 <Enveigler> Quiet.
16:38:42 <astrolabe> shhhh. They're asleep.
16:40:45 <dcoutts> BANG!
16:42:33 <dcoutts> astrolabe, they must be sleeping deeply
16:42:40 <TheHunter> @moo
16:43:00 <dcoutts> @ping
16:43:05 <lambdabot> bzzt
16:43:07 <TheHunter> @botsnack
16:43:08 <lambdabot> :)
16:43:17 <TheHunter>  @ping -> @kind
16:43:31 <dcoutts> ?
16:43:39 <dcoutts> @kind
16:43:40 <TheHunter> @ping []
16:43:40 <lambdabot> bzzt
16:43:41 <lambdabot> * -> *
16:44:15 <dcoutts> ping is aliased to kind? odd
16:44:31 <TheHunter> no, it's dons' autocorrection feature
16:44:40 <TheHunter> @ki Maybe
16:44:41 <lambdabot> * -> *
16:44:45 <TheHunter> @
16:44:46 <lambdabot> Maybe you meant: all-dicts arr babel botsnack code define definitions
16:44:46 <lambdabot> del-definition devils dice dict dict-help docs dummy dynamic-load
16:44:46 <lambdabot> dynamic-reload dynamic-unload easton echo elements elite eurohaskell
16:44:46 <lambdabot> eval fact fact-cons fact-delete fact-set fact-snoc fact-update
16:44:46 <lambdabot> foldoc fortune gazetteer get-definition ghc google help hitchcock
16:44:48 <lambdabot> hoogle hoogle+ index jargon join karma karma+ karma- kind lambda
16:44:50 <lambdabot> learn leave libsrc listchans listcommands listmodules lojban moo
16:44:52 <lambdabot> [6 @more lines]
16:44:54 <TheHunter> @l
16:44:55 <lambdabot> Maybe you meant: lambda learn leave libsrc listchans listcommands
16:44:55 <lambdabot> listmodules lojban pl
16:45:13 <dcoutts> it autorrects quite far if it gets kind from ping :-)
16:47:47 <Enveigler> I don't suppose anyone knows of any examples of mapping moderatly complex C structures with Haskell? The only one I found so far is http://paste.lisp.org/display/6098 but 3 doubles is rather simple compared to what I'm attempting (and failing dismally) to do.
16:49:18 <dcoutts> Enveigler, we do some more complex ones in Gtk2Hs
16:49:33 <dcoutts> let me find a good one...
16:49:44 <Enveigler> Yes, but I cannot install gtk2hs :(
16:50:38 <dcoutts> you can look at the sources :-)
16:50:54 <dcoutts> get the tarball and look at gtk/Graphics/UI/Gtk/General/Structs.hsc
16:51:36 <dcoutts> there are a couple simple ones, like points and rectangles
16:51:46 <dcoutts> but there is also GCValues whihc is more complex
16:51:51 <dcoutts> or just bigger
16:53:00 <dcoutts> it uses hsc2hs to calculate the structure offsets
16:53:05 <Enveigler> I do have the sources, but I got very confused by the relationship between  .hsc .chs .pp and .hs files. I can't work out which leads to what?
16:53:39 <dcoutts> there are two ffi pre-processors, hsc2hs (.hsc -> .hs) and c2hs (.chs -> .hs)
16:54:01 <dcoutts> and then just ordinary cpp (*.pp -> *)
16:54:41 <dcoutts> hsc2hs is good for binding structures c2hs is better for binding functions
16:55:15 <dcoutts> you might not need either though
16:55:37 <dcoutts> since the offsets you've got don't come from a C struct decleration but from a spec
16:55:51 <dcoutts> so you would probably just hard code the offsets
16:56:10 <Enveigler> Okay. I'll try to track one of those through.
16:57:38 <dcoutts> there ought to be just a simple way of reading ints, bytes etc out of a open file, hmmm
16:58:13 <dcoutts> perhaps someone has a module that does that
17:00:31 <Enveigler> is "#type" a preprocessor macro/directive or ?
17:02:30 <dcoutts> er...
17:02:41 <Enveigler> I think I got how to deal  with structs that are basically arrays. A collection of things if the same type, but I get lost how to deal with structs that contain 3 ulongs, 2 ushorts, 1 long and a unsized array of either unsigned byte or signed shortes or pairs of signed shorts.
17:03:07 <Enveigler> As in data Color = Color (#type guint16) (#type guint16) (#type guint16)
17:03:17 <dcoutts> that's what the GVValues demonstrates
17:03:34 <dcoutts> a struct with a bunch of miscelanious bits
17:04:06 <dcoutts> #type converts primitive C types to Haskell FFI types, eg int -> CInt
17:09:58 <Enveigler> Okay, but is that a Haskell thing or a directive to one of the preprocessors?
17:10:37 <Enveigler> Also, unless grep is lying to me, "GVValues" doesn't appear anywhere in the gtk2hs tarball?
17:13:50 <ulfdoz_> bye
17:14:39 <Enveigler> GCValues lookes promising
17:18:20 <Enveigler> Ah yes. Thanks dcoutts. That clarifies many things.
17:19:05 <metaperl> I would appreciate some feedback on how    you would solve tis problem. Given a list of Int how would you generate a list indicating the number of times each Int showed up in the list? E.g. for [1,2,3,2,4,5,2] the output would be [(1,1), (2,3),(3,1),(4,1),(5,1)]
17:19:34 <metaperl> I suppose there is a Prelude function for this operation, which I believe is commonly called frequency counting
17:20:06 <TheHunter> @type map (head Control.Arrow.&&& length) . group . Data.List.sort
17:20:07 <lambdabot> bzzt
17:20:32 <TheHunter> hmm
17:20:48 <Beelsebob> theHunter... if that were right it would need Ord a => [a], not just Eq a => [a]
17:20:59 <TheHunter> @type map (head Control.Arrow.&&& length) . Data.List.group . Data.List.sort
17:21:01 <lambdabot> forall a.
17:21:01 <lambdabot>                          (Ord a) =>
17:21:01 <lambdabot>                          [a] -> [(a, Int)]
17:21:23 <TheHunter> Beelsebob, he wanted to start from a list of Ints.
17:21:39 <Beelsebob> yeh... but it's always nice to come up with a general solution
17:21:45 * Enveigler still can find no reference to "#type". Google drops non ascii characters and 'type' on it's own comes up rather a lot in reference to Haskell.
17:21:55 <TheHunter> @plugs map (head Control.Arrow.&&& length) . Data.List.group . Data.List.sort $ [1,2,3,2,4,5,2]
17:21:57 <lambdabot> [(1,1),(2,3),(3,1),(4,1),(5,1)]
17:22:41 <dcoutts> Enveigler, that #{type ... } construct is a special hsc2hs thing
17:22:54 <metaperl> that is way above my head TheHunter
17:22:55 <TheHunter> well it's an O(n^2) vs. O(n * log n) issue, and almost every Eq can also be made an Ord
17:23:09 <Beelsebob> *almost* every
17:23:24 <metaperl> I had thought of sorting it and folding it
17:23:31 <Enveigler> data Color = Color (#type guint16) (#type guint16) (#type guint16)
17:23:43 <TheHunter> let's go through it in small steps:
17:23:45 <Beelsebob> anyway, there should be a way of making that n*log(n) without the sort
17:24:00 <TheHunter> @plugs sort [1,2,3,2,4,5,2]
17:24:01 <lambdabot> [1,2,2,2,3,4,5]
17:24:05 <metaperl> yes
17:24:17 <TheHunter> @plugs Data.List.group [1,2,2,2,3,4,5]
17:24:18 <lambdabot> [[1],[2,2,2],[3],[4],[5]]
17:24:33 <dcoutts> Enveigler, so hsc2hs translates that to: data Color = Color (Word16) (Word16) (Word16)
17:24:38 <metaperl> ah
17:25:06 <TheHunter> now, head &&& length is \x -> (head xs, length xs)
17:40:26 <TheHunter> map (\x -> (head xs, length xs)) [[1],[2,2,2],[3],[4],[5]]
17:40:26 <TheHunter> @plugs map (\x -> (head xs, length xs)) [[1],[2,2,2],[3],[4],[5]]
17:40:26 <lambdabot> Variable not in scope: `xs'
17:40:26 <TheHunter> @plugs map (\xs -> (head xs, length xs)) [[1],[2,2,2],[3],[4],[5]]
17:40:26 <lambdabot> [(1,1),(2,3),(3,1),(4,1),(5,1)]
17:40:26 <TheHunter> Beelsebob, sure, there are faster ways, but this is haskell, we don't care about constant factors.
17:40:26 <Enveigler> dcoutts: Okay. If .hsc is the input to hsc2hs, are the resultant .hs files in the tarball or are then generated at build time?
17:40:26 <metaperl> that makes sense to me
17:40:26 <Beelsebob> theHunter: I wasn't talking about being faster, I was talking about having the right type ;)
17:40:26 <metaperl> but I cant imagine that Simon thompson expected knowledge of that approach for exercise 6.32 in his book...
17:40:26 <TheHunter> i'm pretty sure it's either Ord a => ... or it's O(n^2)
17:40:26 <metaperl> the map part is easy by this part of the book. I suppose if I knew how to write the sort and group, I would be ok
17:40:26 <metaperl> maybe apt-get source ghc6 would be the way to see the implementation of group() and sort()?
17:40:26 <TheHunter> @libsrc Data.List
17:40:26 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
17:40:26 <metaperl> my complete.org is fairly complete! :)
17:40:26 <metaperl> TheHunter: thanks for your help
17:40:26 <TheHunter> np
17:40:26 <Enveigler> @docs hsc2hs
17:40:26 <lambdabot> hsc2hs not available
17:40:26 <TheHunter> @pl \xs -> (head xs, length xs)
17:40:26 <lambdabot> liftM2 (,) head length
17:40:26 <Beelsebob> metaperl: I know for a fact that SJT hasn't ever done all the exercises in his book
17:40:26 <metaperl> actually Thompson lists this exercise as a "Project' so I guess he was expecting it to take some time
17:40:26 <metaperl> Beelsebob: interesting
17:40:26 <Beelsebob> he says that he quite often gets emails saying "wtf?" and then goes "actually, this exercise is really hard"
17:40:26 <metaperl> its an EXCELLENT book so far up to chapter 6 though. Far better than any free material available for Haskell
17:40:26 <dcoutts> Enveigler, the generated .hs files are not in the tarball, they get done at build time
17:40:26 <metaperl> Beelsebob: how do you know SJT's experiences with the book?
17:40:26 <Beelsebob> metaperl: he's head of my department
17:40:26 <metaperl> oh, your IP address says a lot
17:40:26 <metaperl> lol
17:40:26 <Beelsebob> hehe
17:40:26 <metaperl> are you undergrad?
17:40:26 <Beelsebob> no
17:40:26 <dcoutts> Enveigler, if you really want to look at the built .hs files you can build on windows using the msys shell
17:40:26 <Beelsebob> postgrad
17:40:26 <metaperl> I thought you were a freelance software developer by profession Beelsebob
17:40:26 <metaperl> postdoc?
17:40:26 <Beelsebob> no... PhD student... and freelance software developer
17:40:26 <Beelsebob> http://www.cs.kent.ac.uk/people/rpg/tatd2/
17:40:26 <Beelsebob> hmm... I can make this logerithmic in good cases...
17:40:26 <Beelsebob> and n^2 in bad cases
17:40:26 <Beelsebob> but I'm sure there should be a way of making it n*log(n) in general
17:40:26 <Beelsebob> in fact... it's linear in good cases
17:40:26 <Beelsebob> but that's beside the point
17:40:26 <TheHunter> logarithmic?
17:40:26 <Beelsebob> n*log(n) I meant
17:40:26 <metaperl> Beelsebob: since you're into tracing, do you work on HAT? And did you use graphviz to make those directed graphs at your website?
17:40:26 <Beelsebob> but it's actually linear in good cases
17:40:26 <Beelsebob> metaperl: yes, and yes
17:40:26 <metaperl> :)
17:40:26 <Beelsebob> that tool takes a hat trace, strips out the stuff that a huuman doesn't care about, and creats a dot file
17:40:26 <Beelsebob> the problem is no nice way to devide the group into two
17:40:26 <TheHunter> think about how many equality tests you need to do to prove that n objects are different.
17:40:26 <Beelsebob> indeed
17:40:26 <Beelsebob> so yeh... it is indeed an n^2
17:40:26 <Beelsebob> bastard
17:40:26 <metaperl> TheHunter: my solution in perl for this would have been to keep incrementing members of an associative array, passing through the data one time
17:40:26 <Beelsebob> ah well... I can do it linear best case, that's good enough
17:40:26 <Beelsebob> (and n^2 worst)
17:40:26 <Beelsebob> that's a good point
17:40:26 <metaperl> my @counted = map { $tally{$_}++ } @int ;
17:40:26 <metaperl> done!
17:40:26 <Igloo> n log n if you have an Ord instance
17:40:29 <Philippa_> metaperl: any reason not to do that in Haskell?
17:40:33 <Beelsebob> igloo: that's what I was trying to avoid
17:41:04 <metaperl> Philippa_: the Data.IntMap class in ghc6.4 looks perfect for this. I'm running 6.2.2 and the classes dont seem as rich in this area (Data.FiniteMap to be precise)
17:41:32 <Philippa_> yeah, Data.FiniteMap works but that's about all you can say for it
17:41:47 <Philippa_> 'course, you mean /Type/, right? ;-)
17:42:37 <metaperl> Philippa_: oh, yes.
17:43:06 <TheHunter> @type foldr (\k -> Data.Map.insertWith (+) k 1) Data.Map.empty
17:43:08 <lambdabot> forall k
17:43:08 <lambdabot>                        a.
17:43:08 <lambdabot>                     (Ord k, Num a) =>
17:43:08 <lambdabot>                     [k] -> Data.Map.Map k a
17:43:16 <Philippa_> not that perl5 really has classes either, though
17:43:39 <metaperl> Philippa_: it does!
17:43:40 * Enveigler_ gives up for another day.
17:43:48 <Enveigler_> Night all.
17:44:12 <metaperl> Philippa_: but associative arrays come without the need for libraries
17:44:21 <metaperl> they are ultra-handy and widely used
17:44:22 <Philippa_> metaperl: not at the language level IIRC
17:44:44 <metaperl> I work for a company that serves 50% of all ads on the internet and we use Perl for 98% of our programming owrk
17:44:57 <metaperl> Philippa_: the package keyword is part of the Perl5 language
17:45:18 <metaperl> you can create objects, define packages. etc ,etc
17:45:29 <metaperl> not perl4, but certainly part of perl5
17:45:40 <Philippa_> yeah. But that's your lot - YA module facility and build OO on top of that and a few other features
17:46:14 <metaperl> perl5 is probably the best language ever written. Perl 6 will be the worst language ever... objects in Perl5 are beautiful, seamless, and graceful
17:46:27 * Beelsebob slaps metaperl
17:46:33 <Beelsebob> that's blasphemy in here
17:46:34 <metaperl> lol
17:47:28 <Beelsebob> buh... I'm dreading seeing SJT tomorrow actually... he's examining me in my viva for my qualifying disertation
17:47:56 * metaperl points Beelsebob to http://sequence.complete.org/node/40 (pumping out the functionality: quality of language versus quantity of useful code)
17:48:51 <metaperl> Haskell actually is the highest quality *language* but it has an inversely proportional amount of useful corporate-ready modules (perl5's dominion --- see CPAN) and applications (php's dominion)
17:49:28 <metaperl> perl5 is the ultimate grab-n-go-download-and-fill-functional-gap language
17:49:44 <Philippa_> find me a H-M typechecker in it? ;-)
17:49:53 * heatsink saw one of those
17:50:11 <metaperl> yes, I spend 90% of my time fixing bugs and grumbling about how none of this would've existed with a rigorous type system
17:50:15 <Philippa_> well yeah, and I've got one in modula-2 of all languages on here somewhere
17:50:17 <heatsink> http://www.cs.berkeley.edu/~nikitab/courses/cs263/hm.html
17:50:35 <Philippa_> metaperl: you seem to be adding a point where there wasn't one
17:50:43 <metaperl> ?
17:50:53 <metaperl> i dont understand what you mean
17:50:58 <Philippa_> I asked for a piece of functionality, that's all. Didn't say it was to typecheck /perl/ code, did I?
17:51:20 <metaperl> i'm lost
17:51:39 <Philippa_> OK, maybe I misread you instead
17:51:44 <metaperl> by functionality I mean practical things that companies want
17:52:07 <Philippa_> yeah, I know. This 1-woman company is asking for... ;-)
17:52:10 <metaperl> CGI, database, HTML parsing (pragmatically), regular expressions
17:52:16 <heatsink> , programmers
17:52:18 <heatsink> ;)
17:52:41 <metaperl> cosmicray has done a lot to make Haskell more corporate-ready
17:52:58 <metaperl> I was amazed at all he had in MissingH
17:53:18 <Beelsebob> there's still a basic problem with Haskell though
17:53:18 <Philippa_> yeah. Fact is, in terms of being used as anything other than a research language, Haskell's waaaaaay back compared to perl
17:53:33 <Beelsebob> people have an inhearant hatred for anything different
17:53:42 <Igloo> Isn't missingh primarily code that already existed elsewhere? Or is that just the bits I've looked at?
17:54:02 <Beelsebob> I spent a chunk of yesterday trying to explain to a bunch of mac coders why strong types and no side effects are good
17:54:03 <heatsink> I think it's more a dislike for learning a new way to do something they can already do
17:54:13 <metaperl> but Larry Wall once said: "Your brain is wired to think like Perl"... and it appears that for a large part of the bell curve, Perl hits the sweet spot. It requires a complete change of mindset to learn Haskell, but it is improving my Perl coding ability tremendously
17:54:14 <Philippa_> Beelsebob: true. Though a lot could be done just by giving it a better record system
17:54:48 <metaperl> Beelsebob: when haskell has things like phpMyAdmin, OpenOffice Writer, Mozilla, then your argument will hold water
17:54:50 <Philippa_> metaperl: my brain really isn't wired to think like perl, and I was actively trying to invent things like monads for myself
17:54:51 <Beelsebob> I don't think this lot even looked that far
17:54:56 <metaperl> people want *results* not soundness
17:55:11 <metaperl> Philippa_: you are beyond the middle of the bell curve, that's all
17:55:21 <Beelsebob> metaperl: precicely... but it won't ever be used to write those things until you convince people to use it for them
17:55:46 <Philippa_> metaperl: that and straight into the things perl really doesn't do as well as other languages
17:55:48 <Beelsebob> if no one writes OpenOffice in Haskell, then no one thinks haskell's good, so no one writes anything in it
17:56:11 <Philippa_> "no side effects" is a bad pitch for most folks
17:56:16 <Philippa_> it's not what you get in practice at all
17:56:22 <metaperl> Beelsebob: some of it has to do with the fact that most programmers are in America and functional programming is a European thing... until America starts accepting European culture, procedural programming will continue to rule
17:56:29 <Philippa_> "no unexpected side effects" is more like it
17:56:32 <Beelsebob> well... yes... except that's actually how the discussion started
17:56:43 <Philippa_> they picked it up not you, I take it?
17:56:55 <Beelsebob> because it all started with "where's LongMul gone????"
17:57:04 <metaperl> are you all familar with the Haskerl project? it seemed to die
17:57:18 <Beelsebob> and I suggested #define LongMul(x,y) ((long long)(x) * (long long)(y))
17:57:30 <Beelsebob> which is unsafe in the presence of side effects
17:57:39 <Beelsebob> ... and so the discussion started
17:57:49 <Pseudonym> Someone on LtU once quipped that programming languages develop an implicit theory about what they're "for".
17:57:53 <metaperl> I still have a small program that I tried to do division in today... I'm getting type errors because some of the data is Int and some Fractional... that sort of thing is handled for you in Perl and PHP and Scheme/Lisp
17:58:02 <Pseudonym> Declarative languages tend to get used to implement their own compilers.
17:58:08 <metaperl> Haskell is not DWIM
17:58:21 <Pseudonym> Hence, there develops an implicit theory that declarative languages are good for writing compilers.
17:58:25 <Beelsebob> metaperl: that's kind of the point ;)
17:58:30 <hyrax42> what means DWIM
17:58:31 <Pseudonym> (Which _is_ true.)
17:58:34 <Igloo> DWIM is far worse when you don't mean quite what it thinks you do, though
17:58:55 <Igloo> Or when you forget a dereference or something
17:59:04 <Philippa_> yeah. Having the language let you step out of the integers when you really really didn't mean to is not good
17:59:14 <metaperl> I think I said it best when I said Haskell is like the Federal Government: you have to do things it's way and it keeps rejecting you on every little technicality until you get it just right
17:59:26 <metaperl> but once you do it, you have a pretty strong partner on your side
17:59:29 <metaperl> :)
17:59:31 <Philippa_> that's only on the low level though
17:59:44 <Philippa_> on a higher level it's the opposite - I've not seen any language bend to my will in quite the same way
17:59:45 <Igloo> "until you get it just right" sounds like another way of saying "until you stop getting it wrong" to me  :-)
17:59:46 <Pseudonym> The problem with that analogy is that unlike the Federal Government, Haskell is flexible.
18:00:07 <Philippa_> yeah, try doing Parsec on tax forms
18:00:12 <Pseudonym> The way I'd put it is that Haskell lets you think big.
18:00:23 <Philippa_> (I get the impression the forms over there are trying to be turing complete)
18:00:41 <Pseudonym> You can think big thoughts, and Haskell will take care of the small mistakes.
18:01:06 <Beelsebob> indeed
18:01:30 <Beelsebob> this is kinda why debuggers are hard to write for it...
18:01:35 <Pseudonym> Right.
18:01:40 <Beelsebob> you have to catch the big logical mistakes
18:01:43 <Pseudonym> Debuggers are optimised for finding small mistakes.
18:01:47 <Beelsebob> not the simple little bugs
18:01:55 <Beelsebob> which are far easier to point out
18:02:07 <Pseudonym> The big problem here is that debugger technology hasn't caught up with programming language technology.
18:02:17 <Philippa_> hmm. Most of my bugs really are simple little ones - I should probably start using bigger identifiers
18:02:30 <Beelsebob> hmm?
18:02:34 <Beelsebob> how do you mean?
18:02:51 <Pseudonym> Even people who use 1980-era programming languages are using 1960-era debuggers.
18:02:58 <Beelsebob> heh
18:03:04 <Beelsebob> that's true enough
18:03:04 <Philippa_> most of them're small typos or equivalently thinkos where I've just typed the wrong thing entirely
18:03:15 <Philippa_> only I've a habit of 1-3 char identifiers, which doesn't help
18:03:29 <Beelsebob> you mean things like typing <= rather than >?
18:03:31 <Philippa_> (I only use ones that length for parameters and temporaries)
18:03:33 <Beelsebob> (etc)
18:03:39 <Philippa_> yeah, or i for i', or j for i
18:03:52 <Beelsebob> yeh... these are things I'd class as logical errors
18:03:53 <metaperl> can someone explain how to fix the type errors in this program: http://www.hcoop.net/~terry/haskell/tmp/magazines.hs
18:03:58 <Beelsebob> some of them may be subconcious
18:04:19 <Beelsebob> but they're a flaw in how the program should carry out it's computation, rather than a flaw in the surrounding stuff
18:04:26 <Beelsebob> ... like freeing something twice
18:04:26 * Igloo made a 68 letter function name during the ICFP contest. But that's because Duncan is obsessed with long names, and I just stuck an extra few chars on one of his  :-)
18:04:36 <Beelsebob> lol
18:04:43 <Philippa_> heh
18:04:44 <Igloo> (findAdjacentNodesWithShortestDistanceToTargetForCopWithTransAvoiding if you're wondering)
18:04:51 <Beelsebob> heh
18:04:52 <reffie> heh.
18:05:15 <Igloo> (I added "WithTransAvoiding" to take the prize)
18:05:16 <Philippa_> yeah, I do tend to use that style of function name - though I've not had anything that long
18:05:19 <Beelsebob> this is one of the things I like about objective-C... it allows for mid-fix functions (or methods actually)
18:05:48 <metaperl> Igloo: I'm thinking that function should have been polymorphic on what you were finding adjacent nodes for
18:05:52 <Beelsebob> so you can have methods like [someObject findEdgesIn:something thatMatch:somethingElse]
18:05:54 <Philippa_> yeah, that only helps you on invocation though
18:06:08 <metaperl> findAdjacentNodesFor (type Cop)
18:06:11 <Philippa_> and /having/ to use the parm names would really piss me off
18:06:19 <metaperl> findAdjacentnodesFor (type Robber)
18:06:38 <Heffalump> metaperl: specifying the semantics would have been tricky
18:06:43 <Beelsebob> hmm? I think it's a good thing to enforce actually
18:06:46 <metaperl> Cop is a variable in a sense and there should be different functions based on whether cop or robber
18:06:49 <Heffalump> and we were in a it of a rush for some unknown reason
18:07:01 <Heffalump> s/it of a rush/bit of a rush/
18:07:05 <metaperl> or the function belonged in a module Cop
18:07:10 <metaperl> making Cop redundant
18:07:34 <Philippa_> Beelsebob: depends on the situation. There're places where it'll make code much less readable, not more
18:07:36 <metaperl> I sure do have a lot to say for someone who is only on chapter 6 of SJT's book :)
18:07:48 <Igloo> Also, the "WithTrans" bit only makes sense for cops, not robbers
18:07:52 <Beelsebob> hmm, not sure, I'll believe you when I see one
18:07:57 <Philippa_> One of the things I really appreciate about haskell's syntax is the amount of white space where there'd be line noise in other langs
18:08:15 <Philippa_> it makes it a lot easier for me to follow the actual structure of code
18:08:26 <metaperl> one things I like about Haskell is darcs
18:08:53 <Heffalump> what was "WithTrans"?
18:09:21 <Igloo> The transport it currently has
18:09:24 <Heffalump> oh yes
18:09:38 <metaperl> do any famous Haskellers use this_style instead of thisStyle?
18:09:46 <Igloo> Am I a famous Haskeller?
18:09:54 <metaperl> Igloo: yes... or rather skilled
18:10:02 <metaperl> s/famous/competent
18:10:12 * Igloo actually uses a horrific mixture due to different influences nowadays, which I'm sure isn't good
18:10:32 <Philippa_> I often find my horrible mixes settle down into something new after a few months
18:10:44 <Philippa_> the only problem is that the something new's often not at home in any language
18:10:53 <Number17> is creating a finite state automata a good thing for a haskell novice to learn about monads with?
18:11:05 <Igloo> I'm tempted to decide to change to fooBar for line width reasons
18:11:08 <Beelsebob> as an example, today I was playing with QuickCheck... `tests config gen rnd1 (ntest+1) nfail (stamp result:stamps) (failed + 1)' would be a lot clearer as `runTestsWithConfig:config generator:gen randomSeed:rnd1 runTests:(ntests+1) badTests:nfail resultsList:(stamp result:stamps) numFailures:(failed + 1)'
18:11:26 <Beelsebob> I would have figured out what it was doing far faster
18:12:04 * Heffalump uses a horrific mixture too
18:12:26 <Philippa_> Number17: potentially, yeah
18:12:34 <Beelsebob> I mean, what do the variables do in this call: `tests config (evaluate a) rnd 0 0 [] 0'?
18:12:39 <Philippa_> depends on exactly what your FSA's supposed to do
18:13:05 <metaperl> Number17: the wiki has a monad tutorial and nomaware.com has a tutorial too...
18:13:06 <Number17> Philippa_:  well not much at all; just go from state to state based on an input; no actual functionality
18:13:27 <Number17> I was reading a thing called "All About Monads"
18:13:36 <Beelsebob> what a silly thing to read ;)
18:13:37 <Beelsebob> *g*
18:13:45 <Philippa_> 'k. There's no real sense to making that monadic - you can do it with a plain function. OTOH, extend it slightly and you'll end up with a parsing monad
18:13:45 * Beelsebob waits for the philipa slap
18:13:51 <Beelsebob> :o
18:13:56 <Beelsebob> didn't expect that
18:14:31 <gzl> Number17: all about monads is good.
18:16:12 <metaperl> why is this giving me a type error: freq_count = map (\xs -> (head xs, length xs)) $ group $ sort
18:16:31 <Beelsebob> do you want . not $ ?
18:16:56 <metaperl> I dont think so... you can use $ anywhere . is used right?
18:17:03 <Igloo> No
18:17:09 <metaperl> f . g is the same as f $ g
18:17:17 <Igloo> no
18:17:22 <metaperl> ok, why not?
18:17:25 <Igloo> f . g is the same as \x -> f $ g x
18:17:38 <Igloo> f $ g is the same as f g
18:17:39 <TheHunter> f $ g $ x is the same as f . g $ x, that's all
18:18:05 <metaperl> i was just trying to pipe my results from function to function
18:18:12 <Beelsebob> yeh... you want . then
18:18:24 <Beelsebob> `after'
18:18:25 <gzl> yeah, be careful about $
18:18:48 <Pseudonym> Standard complaint: This is a fault with $.
18:18:59 <metaperl> yes, I'm still lost
18:19:00 <Pseudonym> $ should be left-associative, then it wouldn't be so redundant.
18:19:00 <Igloo> How's that?
18:19:22 <Igloo> It would be more redundant, surely?
18:19:24 <metaperl> $ was designed to reduce the amount of parentheses you use I believe
18:19:33 <Igloo> You couldn't use it to get rid of parentheses then
18:19:43 <Pseudonym> f (g x) y could be written f $ g x $ y
18:19:55 <Pseudonym> And f (g (x y)) could be written f . g . x $ y
18:20:06 <Pseudonym> At the moment, there's no easy way to remove the parentheses in f (g x) y
18:20:07 <metaperl> I'm so lost
18:20:10 * Igloo hates it when operators are mixed like that
18:20:14 <metaperl> f takes to arguments Pseudonym?
18:20:16 <Heffalump> <aol>
18:20:20 <Heffalump> (to Igloo)
18:20:20 <TheHunter> you could write f `id` g x `id` y
18:20:28 <Pseudonym> Yikes.
18:20:30 <Heffalump> lol
18:20:40 <dons> nice :)
18:20:45 <metaperl> is f binary or unary?
18:20:49 <Pseudonym> However, that doesn't solve the SECOND problem.
18:20:51 <Pseudonym> Which is...
18:20:53 <Beelsebob> unary
18:21:04 <Beelsebob> ... in the second
18:21:08 <Beelsebob> binary in the first
18:21:15 <Pseudonym> Suppose you have f (g x) y, and you want (g x) to be evaluated before caling.
18:21:23 <Pseudonym> In my scheme, you could write f $! g x $ y
18:21:35 <Beelsebob> can you now... that's interesting
18:21:37 <TheHunter> that's a good point
18:21:38 <Pseudonym> Because, of course, $! would have the same associativity as $.
18:21:50 <Pseudonym> Making $! right-associative makes no sense.
18:21:59 <Heffalump> how would you get (x y) to be evaluated before calling for f (g (x y)) ?
18:22:02 <Igloo> Won't `id` have the default right associativity?
18:22:08 <Pseudonym> f . g $! x y
18:22:32 <Pseudonym> Or f (g $! x y)
18:22:38 <Heffalump> so f . g . x $ y but f . g $! x y ?
18:22:59 <Heffalump> and what if you want g (x y) evaluated first
18:23:05 <Pseudonym> f $! g (x y)
18:23:15 <Heffalump> I spy parentheses..
18:23:24 <Pseudonym> Yes, but the point isn't to remove all parentheses.
18:23:25 <metaperl> in SJT's book, $ is not introduced until p.457, but . is introduced on p. 11. If I had only learned haskell from this book instead of free-form, I would not have had the problem I had
18:23:34 <Igloo> $! is annoying because if you remove redundant $!s in   f $! x $! y   then the core changes as x gets evaluated first, breaking the simplest sanity check I know of that it really was redundant
18:23:40 <Pseudonym> It's to allow you to strictly evaluate whatever arguments you need.
18:23:58 <Pseudonym> At the moment, there's no easy way to evaluate (g x) in the call f (g x) y
18:24:13 <Beelsebob> I don't think CR ever taught us of the existance of $
18:24:23 <Beelsebob> . was introduced in about the second lecture
18:24:24 <Heffalump> (f $! (g x)) y
18:24:25 <heatsink> flip f y $ g x
18:24:33 <Igloo> What we really need is the juxtaposition! operator, but that's hard to write
18:24:36 <Heffalump> in fact
18:24:40 <Heffalump> (f $! g x) y
18:24:47 <Heffalump> and yes, wot Igloo said
18:24:52 <Beelsebob> igloo: what?
18:24:57 <Pseudonym> Yes, you can do that, but it obscures the fact that f takes two arguments.
18:25:10 <metaperl> actually SJT doesnt discuss $ at all.. p.457 is Appendix C of the book!
18:25:11 <Igloo> Maybe (<unicodesmallnonbreakingspace>!) or something?  :-)
18:25:11 <Heffalump> so does almost all curried programming
18:25:20 <Beelsebob> pseudonim: actually, I think it makes it clearer
18:25:23 * Heffalump wishes he still lived in Oxford
18:25:26 <Beelsebob> I can see the currying going on
18:25:32 <Pseudonym> OK, try this.
18:25:34 <Heffalump> (so I could go round to Igloo's and shoot him)
18:25:36 <metaperl> Heffalump: where do you live now?
18:25:39 <Pseudonym> f x y z, where you want x and z evaluated.
18:25:39 <Igloo> :-)
18:25:40 * Beelsebob is very glad he doesn't live near oxford now
18:25:42 <Heffalump> metaperl: Cambridge
18:25:49 <Pseudonym> (f $! x) y $! z
18:25:58 <Pseudonym> Is it obvious that f takes three arguments?
18:26:08 <Igloo> Sadly I suspect all such characters will be whitespace rather than symbol. Such lack of foresight...
18:26:22 <Beelsebob> no, but it's the latter $! that mixes me up though, not the explicit currying
18:26:43 <Pseudonym> f $! x $ y $! x is about as clear as such a thing could get, IMO.
18:26:47 <Pseudonym> Without explicit lets.
18:26:53 <Pseudonym> f $! x $ y $! z
18:27:00 <Igloo> $! is a thing to be discouraged anyway
18:27:01 <Beelsebob> (((f x) y) z) is as clear as it can get IMHO
18:27:02 <TheHunter> what we need is a prefix !x meaning shift (\k -> x `seq` k x) and a low-prec prefix # meaning reset...
18:27:45 <Pseudonym> My biggest problem is that ($) is supposed to be a low-precedece "applY'.
18:27:48 <Heffalump> Godwin's law of #haskell: Any conversation of sufficient length will inevitably lead to continuations being mentioned
18:28:00 <TheHunter> so # f !x y !z
18:28:04 <Pseudonym> Buit it isn't.
18:28:20 <Heffalump> IMO it's meant to be a right-associative low-precedence 'apply'. Which it is.
18:28:46 <Pseudonym> Where is the discussion which says it's meant to be right-associative?
18:29:14 * Pseudonym isn't convinced that a lot of thought was put into it
18:29:32 <Pseudonym> Especially since a $ b $ c is the same as a . b $ c
18:29:35 <Heffalump> page 110 of the Haskell report
18:29:49 <Heffalump> "-- right-associating infix application operators"
18:29:58 <Heffalump> "-- (useful in continuation-passing style)"
18:29:59 <Pseudonym> Yes, where's the discussion which led to that?
18:30:08 <Pseudonym> Oh, interesting.
18:30:12 * Pseudonym hadn't spotted that
18:30:15 * Pseudonym thinks
18:30:22 <Pseudonym> IS it useful in continuation-passing style?
18:30:39 <Heffalump> I don't know, and I don't care. I find it useful for other things :-)
18:30:42 <Pseudonym> :-)
18:31:31 <Heffalump> I'm going to bed. Like I did about 90 minutes ago, except that a bug was annoying me so I got up to track it down.
18:31:35 <Pseudonym> I think I see the reasoning now, but surely when you're doing manual CPS, the more interesting continuations take more than one argument anyway.
18:32:03 <Pseudonym> And when you're not, the monad syntax is more convenient.
18:32:06 <Pseudonym> Anyway.
18:32:18 <Pseudonym> Yes, go to bed.
18:32:19 <Pseudonym> :-)
18:32:43 <metaperl> freq_count = map (\xs -> (head xs, length xs)) . group . sort  -- error due to monomorphism restriction... any idea why? and how to fix it?
18:33:20 <TheHunter> -fno-monomorphism-restriction :P
18:33:31 <Igloo> Give it a type signature
18:33:32 <metaperl> they said give the func a type signaure
18:33:48 <metaperl> yes, but I think i would have to use type class notiation to do so and I dont know that yet
18:33:52 <TheHunter> seriously, if you want to declare a lists of Ints on top-level, you have to give it a signature
18:34:06 <metaperl> top-level?
18:34:13 <TheHunter> or use integers in the first place
18:34:16 <metaperl> monomorphism?
18:34:24 <palomer> hello, can you have a cbv call/cc?
18:34:27 <TheHunter> you prolly have code like
18:34:31 <metaperl> Ints are small , 32-bit numbers...
18:34:34 <TheHunter> xs = [1,2,3,2,3,1,3]
18:34:59 <metaperl> no, I hae nothing like that yet
18:35:03 <TheHunter> the type of xs defaults to [Integer]
18:35:06 <metaperl> palomer: hello. I remember you from #sml
18:35:12 <palomer> metaperl: hello
18:35:35 <metaperl> oh, and length() returns Int
18:35:39 <metaperl> and that's the issue
18:36:29 <TheHunter> yes, for some reason the writers of the haskell report didn't trust the specialization abilities of haskell compilers.
18:37:13 <Igloo> It's not just that
18:37:28 <TheHunter> that's why we have things like length :: [a] -> Int and (Eq a) => a -> [(a, b)] -> Maybe b
18:37:43 <metaperl> ghci is freaking out... what type signature would work? everything I try is giving it a fit
18:37:45 <Igloo> Oh, I thought you were talking about the MR, sorry
18:38:17 <metaperl> [a] -> [(a,Int)] and [a] -> [(a,Integer)] both fail
18:38:23 <Igloo> Ord a => [a] -> [(a, Int)]
18:38:33 <metaperl> oh ok
18:39:00 <Igloo> I think ghc would have suggested adding Ord a to the context of the first one, but I'm not sure
18:39:12 <metaperl> no, it was not that specific
18:39:30 <metaperl> it gave a voluminous error message but nothing I could put into practice :)
18:39:37 <metaperl> it just intimidated me, that's all
18:39:45 <Igloo> :-)
18:43:26 <palomer> are there papers showing the relation between cbv lambda calculus and cbn lambda calculus?
18:47:17 <TheHunter> off-topic question. How would one go about ordering computer stuff in the us? any decent price comparison sites/trustworthy and cheap online shops?
18:47:51 <heatsink> TheHunter: pricegrabber bizrate
18:48:44 <TheHunter> thanks. Do you think they will accept my crappy visa debit card or will i have to use my german credit card where i have to pay additional fees?
18:49:32 <heatsink> dunno
18:49:38 <liyang> Visa debit should be fine.
18:49:47 <liyang> I've bought stuff from the US before with mine.
18:49:56 <TheHunter> great!
18:50:08 <dons> i've bought stuff from the us too, with a visa debit card
18:50:09 <liyang> Your German bank might (read: will) charge you a small fee for the conversion though.
18:50:34 <TheHunter> the visa is an american one.
18:50:37 <liyang> (Mine charges me something like 1.5% or something.)
18:50:44 <liyang> oh, in that case you're fine.
18:50:48 <TheHunter> i think it's 1% here.
18:50:56 <liyang> *nod*
18:51:56 <MachinShin> hey all
18:52:39 <dons> ooh, ghc error of the day: yi-static: internal error: TSO object entered!
18:53:02 <dons> @remember ghc yi-static: internal error: TSO object entered!
18:53:05 <dons> @quote ghc
18:53:06 <lambdabot>  Unexpected strictness annotation
18:53:09 <dons> @quote ghc
18:53:10 <lambdabot>  ARGH! Jump uses %esi or %edi with -monly-2-regs
18:53:33 <dons> @quote
18:53:34 <lambdabot> reffie says: yi is clearly the editor of the future.
18:53:36 <dons> hehe
18:53:45 <reffie> :D
19:04:55 <mwc> @seen dcoutts_
19:04:55 <lambdabot> dcoutts_ is in #haskell. I don't know when dcoutts_ last spoke.
19:05:16 <mwc> dcoutts: how's progress on that 0.9.8.1 release?
19:27:01 <metaperl> what is the way to take a contiugous slice of a list?  If I have [1,2,3,4,5] and I want to get elements at indices 2 through 4 into a list, what do I do?
19:27:35 <lispy> @hoogle a -> a -> [a]
19:27:36 <lambdabot> Prelude.enumFromTo :: Enum a => (a -> a -> [a])
19:27:36 <lambdabot> Prelude.enumFromThen :: Enum a => (a -> a -> [a])
19:27:36 <lambdabot> List.genericReplicate :: Integral a => (a -> b -> [b])
19:27:46 <lispy> hmm...not what i meant
19:27:51 <dons> @eval take 3 $ drop 2 "haskell"
19:27:53 <lambdabot> "ske"
19:27:57 <gzl> yeah, take and drop
19:28:11 <lispy> metaperl: look at the Index module
19:28:22 <lispy> oh, take and drop are good
19:28:26 <metaperl> Index module? that's different from Data.List?
19:28:42 <lispy> maybe index isn't it'sown module
19:28:49 <dons> @eval let slice n m s = take m (drop n s) in slice 2 3 "haskell"
19:28:51 <lambdabot> "ske"
19:28:51 <lispy> i saw it in Array
19:28:59 <metaperl> ah, sweet
19:30:44 <lispy> @eval drop 2 (take 3 "haskell")
19:30:45 <lambdabot> "s"
19:30:57 <lispy> heh, just remember that order matters :)
19:31:45 <gzl> alternatively, if you have an ordered list, and you want to slice by value rather than index, you could use list comprehensions
19:32:50 <dons> @eval take 3 . snd . splitAt 2 $ "haskell"
19:32:51 <lambdabot> "ske"
19:32:53 <dons> no reason
19:33:13 <gzl> what?
19:33:36 <gzl> sorry, i don't see what your example has to do with what i said
19:33:52 <dons> it wasn't related, i was just playing with splitAt :)
19:34:04 <gzl> ah, i see. :)
19:35:54 <wagle> i think that with an ordered list you'd want to stop applying the predicate when it returned true, and just return the tail at that point
19:36:43 <wagle> hmm..  there some variant of drop___
19:36:51 <gzl> you could also use takeWhile/dropWhile
19:36:57 <gzl> I mean, there are lots of ways of doing it
19:37:26 <dons> a little surprising we don't have a slice n m = take m . drop n
19:37:41 <dons> only a little
19:37:44 <wagle> ah..  it was dropwhile that is was trying to remember
19:38:55 <wagle> s/is/i/
19:55:47 <metaperl> -- ok, who wants to de-newbie-ize this :)
19:55:47 <metaperl> all_correlation xs = map (\i -> correlation i) [0 .. ((length xs)-1)]
19:55:47 <metaperl>     where
19:55:47 <metaperl>       correlation i = ( (xs!!i) , (preceding i) ++ (following i))
19:55:47 <metaperl>       preceding i = take i xs
19:55:47 <metaperl>       following i = drop (i+1) xs
19:57:04 <gzl> isn't xs!!i equal to i in this case?
19:57:14 <TheHunter> \i -> correlation i ==> correlation
19:57:16 <gzl> and what's the point of this function?
19:57:16 <metaperl> gzl: only in this case
19:57:29 <TheHunter> ((length xs)-1) ==> length xs - 1
19:57:29 <gzl> well, you've defined correlation only for that case, so who cares about the others?
19:57:30 <metaperl> TheHunter: ==> is haskell syntax?
19:57:40 <metaperl> oh, you are doing source-to-source transformations
19:58:06 <gzl> you stuck correlation in a where clause so it's only visible inside all_correlation
19:58:06 <TheHunter> no, i mean you can write "correlation" instead of "\i -> correlation i"
19:58:08 <metaperl> gzl: correlation is not dependant on sl
19:58:17 <gzl> what's sl?
19:59:16 <metaperl> gzl: I need to take your questions one at a time
19:59:24 <TheHunter> ( (xs!!i) , (preceding i) ++ (following i)) ==> (xs!!i , preceding i ++ following i)
19:59:27 <metaperl> first, xs!!i means take the ith element of xs
19:59:37 <gzl> correct
19:59:53 <metaperl> therefore i is not necessarily equal to xs!!i
20:00:17 <gzl> it is when your list is [0 .. n]
20:00:29 <gzl> and that's hardcoded here
20:00:35 <TheHunter> it would probably better to define that thing recursively:
20:00:38 <metaperl> gzl: yes, but there is no guarantee for the list to be that way... where is it hardcoded that way?
20:00:44 <TheHunter> allCorrelations [] = []
20:01:12 <gzl> metaperl: you've written [0 .. length xs - 1] there...
20:01:40 <TheHunter> allCorrelations (x:xs) = (x,xs): map (first (x:)) (allCorrelations xs)
20:02:01 <TheHunter> (where first f (x,y) = (f x, y) as in Control.Arrow)
20:02:10 <metaperl> gzl: you are 100% correct!
20:02:29 <metaperl> omg TheHunter your notation turned into smily faces... hold on
20:03:38 <TheHunter> you should honor the first rule of haskell's lexical structure: applications binds tightest.
20:04:19 <metaperl> TheHunter: I dont know how that rule of lexical structure applies to me
20:05:08 <gzl> ok, can you answer my second question now? :)
20:06:02 <metaperl> gzl: what was it?
20:06:28 <gzl> what is the point of this function?
20:07:03 <TheHunter_> presumably the next excersize is to write a permutations function...
20:08:04 <metaperl> this function gives you the amazon.com experience where when you select a certain item, you have a list of all items that other people have bought when they bought that item
20:08:41 <metaperl> so the list represents a set of items bought by a customer. I am recoding that list into a list of correlations
20:10:26 <metaperl> this is exercise 6.32 in SJT's Haskell book
20:10:43 <TheHunter_> s/first/second/
20:11:12 <TheHunter_> am i right about exercise 6.33?
20:11:46 <metaperl> TheHunter_: thats the end of he chapter
20:13:55 <gzl> is this the correct output for input [0..3]?
20:13:57 <gzl> [(0,[1,2,3]),(1,[0,2,3]),(2,[0,1,3]),(3,[0,1,2])]
20:14:20 <TheHunter_> permutations [] = [[]]; permutations xs = do (x,xs') <- allCombinations; map (x:) (permutations xs')
20:14:42 <gzl> if so, perhaps this is easier to read than your original solution:
20:14:42 <lisppaste2> metaperl pasted "is this right TheHunter?" at http://paste.lisp.org/display/10207
20:14:45 <gzl> correlation xs = [ (x, except x) | x <- xs ]
20:14:48 <gzl>     where except x = [ y | y <- xs, y /= x ]
20:14:52 <gzl> woops, sorry for the extra space.
20:15:29 <TheHunter_> what's ?
20:15:40 <metaperl> gzl: that's a nice function man
20:15:40 <gzl> it's the end of a list comprehension.
20:15:42 * gzl scratches head
20:16:47 <metaperl> gzl: I guess you're wondering why we are going to such great lengths here :)
20:16:51 <TheHunter_> let select [] = []; select (x:xs) = (x,xs): map (second (x:)) (select xs) in select [0..4]
20:16:56 <TheHunter_> @plugs let select [] = []; select (x:xs) = (x,xs): map (second (x:)) (select xs) in select [0..4]
20:16:57 <lambdabot> [(0,[1,2,3,4]),(1,[0,2,3,4]),(2,[0,1,3,4]),(3,[0,1,2,4]),(4,[0,1,2,3]
20:16:57 <lambdabot> )]
20:17:03 <gzl> metaperl: i know why you are, you're a newbie
20:17:09 <metaperl> lol
20:17:28 <metaperl> I think very mechanically and procedurally. What you did was create a definition for the solution!
20:18:09 <metaperl> @type first
20:18:10 <lambdabot> bzzt
20:18:15 <metaperl> what do first and second do?
20:18:18 <TheHunter_> it breaks down though, if there's no Eq for the list's elements or if elements appear multiple times.
20:18:37 <TheHunter_> second f (x,y) = (x, f y)
20:18:47 <gzl> yes, that's true. I was assuming the kind of list he had hardcoded in the original question
20:19:36 <gzl> unless it's needed i don't see the reason for going nuts with a general solution, though. :)
20:20:35 <gzl> also, even if the assumption is flawed, since he's a newbie, always helps to see more solutions, i think. by the way, i'm only calling you a newbie because i seem to remember you calling yourself one, if you're not, apologies :)
20:21:30 <metaperl> where is this IRC channel logged? I need to get TheHunter_'s text sans emoticons
20:21:38 <metaperl> my IRC client has smileys all over the place
20:21:47 <gzl> check the topic
20:21:50 <gzl> might be something there
20:22:09 --- topic: set to '' by metaperl
20:22:13 <metaperl> oops
20:22:17 <metaperl> :)
20:22:27 <TheHunter_> i'm not producing any smilies, am I?
20:22:37 <metaperl> oh yes
20:22:50 <TheHunter_> you have a weird irc client.
20:22:53 <metaperl> all of your code above has smileys in it... my IRC client has been re-configured not to put them in
20:23:05 <metaperl> someone reset the topic
20:23:16 <gzl> TheHunter_: ah, your 'select' solution is cool.
20:23:51 <gzl> metaperl: also, it's often useful to try to think in terms of definitions
20:24:15 <TheHunter_> in fact i try to avoid smileys as much as possible, only use them if i fear the one i'm talking to doesn't get that i'm joking.
20:24:26 <metaperl> gzl: yes, here's an example of me doing so: http://scannedinavian.org/~metaperl/haskell/is-beautiful/top-down-is-easy/
20:24:29 <gzl> TheHunter_: you have (x:)
20:24:40 <gzl> it's not really a smiley
20:24:48 <TheHunter_> what kind of sick irc client would render that as a smiley?
20:24:50 <metaperl> it saw the :)
20:24:52 <gzl> who knows
20:24:54 <gzl> not mine
20:25:02 <metaperl> I have two smileys in a row in most cases in your code above
20:25:20 <TheHunter_> so (x: is a smiley?
20:25:25 <metaperl> kvirc is my IRC client... it has tiled windows which I need.. you guys are just on one channel.. I'm on like 8 or 9
20:25:41 <metaperl> I turned off smileys i can't tell you and I dont intend to turn it back on :)
20:25:52 <TheHunter_> oki
20:26:03 <gzl> actually, I'm on 14 channels.
20:26:31 * TheHunter_ is only in one channel
20:26:49 <gzl> this is one of the better ones i'm in.
20:27:03 <{[mono]}> I'm on infinitely many channels lazily
20:27:06 <gzl> actually for signal/noise ratio it's probably the best by a good margin
20:27:16 * {[mono]} dilutes #haskell
20:27:20 <TheHunter_> ok, i'm heading to bed.
20:27:21 <gzl> #math is good but gets lots of dolts
20:27:21 <metaperl> gzl: what irc client do you use?
20:27:25 <gzl> irssi
20:27:26 <metaperl> TheHunter_: good night
20:28:22 <metaperl> gzl: can you see what is happening in numerous channels at once?
20:28:55 <gzl> no, because my eyes can only look at one thing at a time.
20:29:19 <metaperl> I scan all my windows continuously... kvirc tiles them all for me
20:29:39 <gzl> i hop back and forth by window number, though irssi does let you split windows
20:29:43 <metaperl> hydrairc was great when I was a windows users... it had a little message box that showed output from all channels
20:29:52 <gzl> you *can* do that
20:30:02 <gzl> but you're the first person i've met who has actually wanted to
20:30:06 <metaperl> plus kvirc can popup a KDE message dialog whe nI am switched to a differnt virtual desktop
20:30:27 <gzl> i'm not trying to convert you
20:35:43 <gzl> metaperl: how is this list of correlations supposed to be used?
20:36:49 * lament hugs irssi
20:37:18 <metaperl> gzl: it's jus an exercise in SJT's book... you take a receipt of purchases and calculate the correlations
20:38:45 <metaperl> gzl: your is probably slower because it does element comparisons... mine and Hunter's simply dice up the list
20:39:17 <gzl> that may well be
20:39:36 <gzl> but i still like mine. i can read mine. :)
20:40:48 <gzl> i like thehunter's too
20:41:37 <gzl> so when did you start with haskell? i thought i've seen you around here for a long time
20:51:42 <gzl> metaperl: here's another: correlation xs = [ (x, filter (/= x) xs) | x <- xs ]
20:53:12 <gzl> same basic idea
20:56:35 <fnord123> Hi all. quick question I dont see in doco's online: what does it mean to have a list with ! preceding it?
20:57:10 <gzl> example?
20:57:23 <fnord123> data URList = URList ![URAction] ![URAction]
20:57:28 <lispy> fnord123: that makes things strict when used in a data declaration
20:57:58 <fnord123> what effect does being strict have
20:58:48 <lispy> i'm not sure, i just read it somewhere :)
20:58:59 <lispy> have you cehcked the haskell 98 report?
20:59:11 <fnord123> found a description: http://www.haskell.org/ghc/docs/latest/html/libraries/haskell-src/Language.Haskell.Syntax.html
20:59:15 <fnord123> i haven't
21:00:58 <heatsink> Strict means that it's evaluated as soon as the constructor is evaluated.
21:01:10 <lispy> ah,i was just going to askthat
21:01:33 <heatsink> By default it's lazy, which means that it's not evaluated until value is used in a case expression.
21:02:55 <fnord123> oh. why didnt the spec use 'eager' since that's the nomenclature as far as i was aware
21:04:36 <fnord123> i guess it's not important now that i know what it means thanks.
21:06:06 <lispy> fnord123: strict is pretty common terminology too
21:06:23 <lispy> fnord123: and i'm not sure if it's exactly the same as eager
21:08:31 <fnord123> k
21:36:19 <conal> i think of "strict" & "non-strict" as semantic, while "eager" and "lazy" are corresponding implementation techniques
21:41:09 <{[mono]}> Yes indeed.
21:47:28 <Pseudonym> Being brought up on the Peyton-Jones book, I distinguish "lazy" from "fully lazy" and am not sure what "non-strict" means.
21:52:42 <SamB> what is the difference between lazy and fully lazy?
21:57:46 <Pseudonym> Fully lazy ensures that MFEs are computed at most once.
21:58:08 <Pseudonym> Fully lazy = lazy + MFE abstraction + let floating
21:58:22 <Pseudonym> (Though MFE abstraction is automatic in the STG machine.)
21:59:58 <palomer> is there a calculus with streams?
22:00:13 <Pseudonym> Pi calculus?
22:01:32 <palomer> seems that Pi calculus has much more than streams
22:01:40 <palomer> like, I want something that's lambda calculus + streams
22:01:41 <Pseudonym> Yes.
22:01:43 <Pseudonym> Ah.
22:11:08 <fnord123> pi calculus has channels . i dont know about streams...
22:11:52 <genixpro> does anyone know of a good haskell or lisp tutorial on the web for imperitive programms like me?
22:12:03 <Korollary> there you go
22:12:10 <genixpro> lol
22:12:29 <genixpro> u followed me
22:12:34 <Korollary> no, I was here
22:12:42 <genixpro> dstalker
22:14:02 <palomer> the SICP covers some mutability in scheme
22:18:38 <palomer> call by value is dual to call by name
22:18:42 <palomer> this paper looks screwed up
22:22:50 <palomer> Here is a speculation about one possible application of
22:22:50 <palomer> these ideas. Call-by-name can be inefficient because a single
22:22:50 <palomer> term may be evaluated many times. Call-by-need avoids
22:22:50 <palomer> this inefficiency by overwriting a term with its value the
22:22:50 <palomer> first time it is evaluated.
22:23:03 <palomer> EH?
22:23:29 <palomer> oh, they have another definition of term
22:51:26 <Enveigler> @index assert
22:51:27 <lambdabot> Control.Exception, Test.HUnit.Base, Test.HUnit
22:51:48 <Enveigler> @docs Control.Exception
22:51:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Exception.html
22:59:25 <Enveigler> @index trace
22:59:25 <lambdabot> Debug.Trace
22:59:36 <Enveigler> @docs Debug,Trace
22:59:37 <lambdabot> Debug,Trace not available
22:59:43 <Enveigler> @docs Debug.Trace
22:59:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug.Trace.html
23:42:00 <Enveigler_> @index dir
23:42:01 <lambdabot> bzzt
23:42:09 <Enveigler_> @index directory
23:42:10 <lambdabot> bzzt
23:42:20 <dons> directory?
23:42:33 <Enveigler_> As in filing system
23:43:09 <dons> @hoogle Directory
23:43:10 <lambdabot> Directory.createDirectory :: (FilePath -> (IO ()))
23:43:10 <lambdabot> Directory.renameDirectory :: (FilePath -> FilePath -> (IO ()))
23:43:10 <lambdabot> Directory.getCurrentDirectory :: (IO FilePath)
23:43:25 <dons> @hoogle+
23:43:27 <lambdabot> Directory.removeDirectory :: (FilePath -> (IO ()))
23:43:27 <lambdabot> Directory.setCurrentDirectory :: (FilePath -> (IO ()))
23:43:27 <lambdabot> Directory.doesDirectoryExist :: (FilePath -> (IO Bool))
23:43:29 <dons> etc
23:43:43 <Enveigler_> Thanks.
23:43:47 <dons> though we use System.Directory these days
23:44:00 <Enveigler_> @docs System.Directory
23:44:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System.Directory.html
23:44:02 <dons> (same interface though)
23:44:20 <dons> hoogle just doesn't know about non-H98 libs yet
23:45:51 <Enveigler_> I was looking to traverse directory (ala opendir)
23:46:18 <Enveigler_> ...which will be under something.Posix I guess
23:46:32 <Enveigler_> @hoogle opendir
23:47:03 <Enveigler_> @index Posix
23:47:03 <lambdabot> bzzt
23:47:18 <dons> getDirectoryContents?
23:47:35 <dons> @type System.Directory.getDirectoryContents
23:47:37 <lambdabot> FilePath -> IO [FilePath]
23:48:22 <Enveigler_> Is that a lazy list?
23:53:25 <flodin> morning
23:58:26 <Enveigler_> Great, Thanks!
