00:15:45 <gaal> @index (RealFrac a) => a -> a
00:15:45 <lambdabot> bzzt
00:16:01 <ski> @hoogle (RealFrac a) => a -> a
00:16:03 <lambdabot> Prelude.log :: Floating a => (a -> a)
00:16:07 <ski> hm
00:16:25 <gaal> i have 3.14 . what function returns 0.14 ?
00:17:30 <gaal> i tried doing if myself with floor and stuff but ran into many silly type errors
00:17:45 <Speck> (-3)
00:18:13 <gaal> Speck, thanks, I need a slightly generalized version of that.
00:18:17 <ski> \x -> x - floor x   should work
00:18:22 <Speck> :-P
00:18:38 <ski> can't remember if there's a specific such already
00:19:13 <lispy> @plugs (\x -> x - floor x) 1
00:19:18 <lambdabot>   Ambiguous type variable `b' in these top-level constraints:
00:19:18 <lambdabot>   `Integral b' arising from use of `floor'
00:19:33 <ski> @type floor
00:19:34 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
00:19:37 <dons> add a type constraint
00:19:38 <mflux_> I wonder if that's the best way though, they are after all floating points
00:19:39 <ski> ah
00:20:02 * ski wonders if theres a floor that doesn't convert the type
00:20:02 <lispy> hmm...i can't seem to recall previous lines of input in this irc client :(
00:20:15 <ski> otherwise i guess one has to do like
00:20:33 <ski> @type \x -> x - fromIntegral (floor x)
00:20:35 <lambdabot> forall b.
00:20:35 <lambdabot>             (RealFrac b) =>
00:20:35 <lambdabot>             b -> b
00:20:48 <lispy> @plugs (\x -> x - floor x) (1::Float)
00:20:50 <lambdabot> <Plugins.Eval>:1:
00:20:50 <lambdabot>   No instance for (Integral Float)
00:20:50 <lambdabot>   arising from use of `floor'
00:21:06 <lispy> ski: ah yeah okay
00:21:27 <Itkovian> hi lispy, how's the bashrc?
00:21:36 <lispy> Itkovian: pretty good
00:21:54 <lispy> Itkovian: i _just_ got the copy from my darcs repo installed
00:22:01 <Itkovian> heh
00:22:11 <gaal> thanks guys
00:22:20 <lispy> i had to add two checks for my host and it's good to go
00:23:53 <Speck> I liked my simple section
00:24:05 <Itkovian> hmm ..
00:24:22 <gaal> Spec, so did I :)
00:24:31 <gaal> s/c/ck/
00:24:47 <dons> @code
00:24:48 <lambdabot> Html.hs: selected            ::           HtmlAttr
00:25:09 <lispy> @vixen how was your 4th of july?
00:25:12 <lambdabot> how? it depends...
00:26:33 <Speck> boo, bad eliza bot
00:26:47 <tessier_> haskell needs a theme song. Then it would be cool and everyone would use it.
00:26:55 <lispy> Itkovian: emacs is not happy with me
00:27:22 <lispy> tessier_: like this? "I ain't no hollaback girl..."
00:27:44 <tessier_> Preferably something with proper grammar.
00:27:51 <lispy> heh
00:27:52 <tessier_> and diction
00:28:13 <lispy> i just have that song stuck in my head...
00:28:25 <tessier_> I don't think I've ever heard that. Who sings it?
00:28:56 <Speck> What about a book in the style of Seuss (like this : http://www.willamette.edu/~fruehr/haskell/SeussFinal2.JPG )
00:36:38 <gaal> by the way, is there a version of hoogle i can run locally?
00:38:42 <dons> yep
00:38:53 <dons> but you'll probably have to ask ndm
00:39:44 <gaal> cheers.
00:42:11 <gaal> my code works now -- thanks folks -- but it issues a warning i'm not sure i understand. i'm trying to look at the picoseconds part of a rational describing a time:
00:42:14 <gaal> picosec x = floor ((x - fromIntegral (floor x)) * 1000000000000)
00:42:31 <gennet1> tessier_: gwen stefani
00:43:08 <dons> why not write (10^12) or whatever that big number is?
00:43:10 <gennet1> lispy: my deepest condolences. may i recommend some audioslave; or even seismic anomaly. less pop. more pop crushing
00:43:18 <gaal> dons - sure
00:43:29 <gaal> (it is)
00:43:41 * dons did some picosecond work last week
00:43:47 <gaal> but the warning is about default constraints
00:44:08 <dons> oh, then add a type annotation
00:44:12 <dons> so defaults don't apply
00:44:13 <gaal> Warning: Defaulting the following constraint(s) to type `Integer' `Integral b' arising from use of `floor' at src/Pugs/Prim.hs..
00:44:15 <lispy> gennet1: heh
00:44:27 <dons> add your own Integer constraint, if its an Integer you want
00:44:30 <lispy> Ï€
00:44:43 <gaal> but why isn't it obvious it's an Integer?
00:45:07 <gaal> (I'm still new to Haskell)
00:45:42 <dons> you're just being warned that it's decided on Integer for you, which may be a different representation to the one you think you're getting
00:46:06 <dons> in thi scase, Integer is just right.
00:46:08 <lispy> @plugs (1000000000000 :: Int)
00:46:14 <lambdabot> -727379968
00:46:20 <dons> exactly
00:46:23 <gaal> actually, come to think of it i'm probably better off not using a rational to try to contain both the seconds and the fractional seconds part.
00:46:40 <gaal> because surely that would lose granularity?
00:46:58 <dons> @type System.CPUTime.getCPUTime
00:46:59 <lambdabot> IO Integer
00:47:21 <dons> oh, just picoseconds since epoch or some such
00:47:33 <dons> you could use a ClockTime ?
00:47:40 <gaal> i am --
00:48:19 <gaal> i'm implementing perl's localtime, which takes an integer and returns a list, and essentially flattened CalendarTime
00:48:22 <dons> data ClockTime = TOD Integer Integer
00:48:34 <dons> ok, cool.
00:49:02 <gaal> yes, that's what i'm using: wct x = TOD (sec x) (picosec x), where sec compensates for perl's different idea of an epoch.
00:50:17 <tessier_> hoogle?
00:50:28 <gaal> but i was thinking (this function isn't completely specced yet), it had better take two integers too rather than one rational if the user wants subsecond granularity.
00:51:10 <dons> you checking out what code is already in Time.hs ?
00:51:18 <dons> maybe you'll get some ideas from that code
00:51:34 <dons> (rather than just the api)
00:52:20 <gaal> let me look for my copy of the sources :)
00:54:36 <Itkovian> http://www.oopsla.org/2005/ShowEvent.do?id=19
00:55:03 <gaal> dons, thanks for the tip, from which i learn that picosecs aren't even standard
00:55:36 <tessier_> hmm
00:55:44 <dons> gaal, yep :/
00:55:51 <tessier_> Has anyone written applications for palm pda's in haskell?
00:55:53 <dons> then again, 10^12 is pretty fine-grained
00:56:02 <tessier_> Or any functional lang?
00:56:09 <dons> tessier_, nhc's been ported to the palm
00:56:10 <gennet1> Itkovian: waaaah! c# can do haskell? Noooooooooooooo......
00:56:19 <tessier_> Since they are all going to Linux it should be possible.
00:56:21 <tessier_> dons: cool!
00:56:32 <lispy> is latex not in darwinports?
00:56:53 <dons> there's a thread of research on running haskell in low-memory environment since the early 90s
00:57:54 <dons> anthony sloane would be one guy to talk to -- he's involved in running nhc on the palm
00:58:53 <earthy> well, the nhc port to the palm is anything but available. ;)
00:59:21 <dons> yes,  that's true.
00:59:35 <tessier_> Anything but available? Does that mean it is available or not available?
00:59:49 <dons> not available.
00:59:52 <tessier_> ok
01:00:04 <dons> he's working on a new port using the current nhc cvs, I think.
01:00:12 <dons> there's been a few commits of late
01:04:11 <dons> i think it may not even be that hard to port nhc to an arm running linux
01:06:54 <stefanw> what about haskell on cell phones?
01:07:41 <dons> hmm, I don't know of any work there. but there must be erlang running on some phones, surely?
01:08:16 <dons> nhc on arm is pretty close though.
01:09:04 <stefanw> one would need an nhc bytecode interpreter written in java, I guess
01:10:40 <dons> we can't run machine code?
01:11:39 <pejo> dons, is erlang ported to any kind of small systems?
01:12:17 <dons> wasn't it invented for that kind of problem?
01:12:42 <dons> or do phone switches have lots of ram?
01:13:28 <jewel> I'm sure they do
01:13:50 <pejo> dons, Erlang/OTP seems to be avail for Solaris (sparc), Windows NT and VxWorks (CPU32, PowerPC 603, PowerPC 860) according to www.erlang.se.
01:14:06 <pejo> dons, and there's an article describing porting of HiPe to AMD64.
01:14:21 <stefanw> dons: well, I don't know exactly which OS cell phones usually run, but java is available on nearly all cell phones
01:14:46 <tessier_> Wow, there's a #erlang
01:14:53 <dons> true. compiling to java isn't too hard though. its been done for haskell 4 or 5 times
01:15:02 <tessier_> So many languages to choose from and not any one of them is significantly better than another.
01:16:01 <dons> would be interesting to map nhc bytecode to a java bytecode + runtime
01:16:18 <dons> that's the main problem, porting the runtime to java.
01:16:42 <dons> oh, and the fact that its kind of hard to develop on a cell phone, isn't it?
01:17:18 <tessier_> You don't actually develope *on* the phone. ;P
01:17:52 <tessier_> Imagine *really* developing on the phone...better add all of your haskell function names to the t9 dictionary. :)
01:18:01 <dons> well, I'm wondering if its easy to get access to the appropriate devel environment?
01:18:11 <dons> not open source, right?
01:18:22 <stefanw> dons: yeah, that would be a cool hack, I guess. It's not that difficult to develop on a cell phone, there are emulators and you can use Java Micro Edition
01:18:34 <dons> ah, ok. cool.
01:18:49 <dons> right. it's just Java I guess :)
01:21:55 <dons> this would be a good summer thesis project I think. haskell on java cellphone
01:22:04 <dons> would make the haskell on java work relevant again
01:22:14 <dons> and combines the low-mem stuff done for nhc
01:22:17 <dons> hmm....
01:24:10 <earthy> ofcourse, if you realise that GHC itself was once developed on machines with ~4Mo memory...
01:24:29 <dons> hehehe
01:24:30 <earthy> your perspective on memory-usage does change
01:24:46 <dons> I have a mail from Lennart somewhere where he talks about running in 700k
01:25:18 <dons> now 70M is not unusual
01:29:14 <pejo> earthy, but it wasn't the same compiler back then though. And it probably did a lot less. (And my desktop usually sits on a machine with 4+Gb mem, I can spare a couple of hundred Mb if thats necessary).
01:30:40 <earthy> true enough, but it was still Haskell
01:31:56 <gennet1> earthy: i was wondering yesterday if there was a feasible way to extend the primitive types in haskell such that you could get C/C++ level control over memory and so on
01:35:15 <earthy> gennet1: there is C/C++ level control over memory, isn't there?
01:37:14 <earthy> look at the Foreign.C stuff
01:37:41 <dons> we already can control memory, like earthy says.
01:37:44 <earthy> and the Foreign.Storable stuff
01:37:49 <dons> or you can use primops if you're up for it.
01:38:02 <earthy> and look at HoP/House
01:38:15 <gennet1> earthy: hypothetical situation: i want a sparse vector data structure, such that the sparsity is encoded into the type; so getting any element is a constant time operation, not dependent on the size of the vector or the sparsity; also, multiplication would take the minimum number of operations needed; but the main point is that the type system should not impose any runtime overhead.
01:38:41 <gennet1> good point about HoP/House; I'd almost entirely forgotten about it
01:39:19 <earthy> I think I understand what you want
01:39:24 <earthy> that is technically possible
01:39:43 <dons> yi (and lots of other programs) use raw bytes on the other side of the ffi
01:39:45 <dons> darcs too
01:40:08 <earthy> but it won't really gain you much, as you have extra pointer derefs upon thunk-evaluation anyway
01:41:03 <gennet1> even if i force it to be eager to the lowest layers?
01:41:26 <dons> functional data structures are almost always the way to go, unless you need a lot of mutability, or really large flat structures
01:41:29 * dons generalises
01:42:52 * tessier_ is still trying to figure out what a functional data structure is
01:43:31 <gennet1> dons: sure; but my hypothetical situation is one in which a "normal" C implementation is about 5x slower than a stupidly templated C++ version; so speed gets to be the first problem, after correctness; I've been prototyping in haskell, and the transition into C++ is painful every time, so I was wishing for C++ style control over memory in Haskell
01:44:02 <dons> so we have the ffi for that :)
01:44:14 <dons> malloc, alloca, free, ... all the favourites!
01:44:45 <dons> you can evenregister foreign ptrs with the GC, and let the runtime free them for you :)
01:44:47 <tuomov> tessier_: a functional data structure can share a lot of data with other copies of it
01:44:56 <tuomov> (whatever the official term was)
01:45:10 <earthy> tessier_: read http://www.eecs.usma.edu/Personnel/okasaki/pubs.html#cup98
01:46:03 <gennet1> dons: true; my current work, when finished, would be suitable for being made into a module via ffi; but it seems to lie just a little too far into the machine world (</matrix-quote>) to actually be feasibly done in haskell
01:46:21 <gennet1> i guess i just want the one language to rule them all ;)
01:46:48 * ski grins evilly
01:49:01 <dons> ah, performance. all depends on how you think about the data
01:49:23 <dons> there's unfortunately much undocumented magic in getting good haskell performance
01:49:37 <gennet1> the laziness makes it worse
01:49:46 <gennet1> to think about, that is
01:50:00 <earthy> one language to rule them all, one language to find them, one language to bring them all and in the darkness enthrall them, in the land of ICFP, where the programmers lie?
01:51:15 <dons> maybe laziness makes it harder to think about. maybe.
01:51:35 <dons> throwing 'length' around big [a] is probably bad ;)0
01:52:11 <gennet1> throwing length around a big list is bad in any language
01:52:51 <pejo> gennet1, heh, makes it worse for machines it seems like too. "The cache behaviour of large lazy functional programs on stock hardware" implies lots of cache misses.
01:53:44 <gennet1> pejo: i can imagine
01:54:04 <dons> lots of computed gotos
01:54:11 <gennet1> it should (theortically, yadayada) be possible to use the static type info to generate optimal code though
01:54:44 <pejo> gennet1, please define optimal in this context.
01:56:19 <gennet1> there was a paper referenced from lambda-the-u recently about how they worked out all the constraints needed to get a machine generated FFT routine to be on par with FFTW in terms of machine op-codes; as I understand it, type is all about encoding static constraints; so it should be possible, given a sufficiently good compiler and sufficient effort in refining the type of various things, to get code output that is on par with hand optimized 
01:56:40 * gennet1 thinks that's a lot of handwaving
02:02:15 <pejo> gennet1, that said you had to use domain specific knowledge afaik. And it was on par with FFTW wrt number of fp operations.
02:02:58 <gennet1> is domain specific knowledge different from a sufficiently defined type?
02:03:11 <gennet1> (the latter term being just something i made up)
02:03:36 <gennet1> for example, monads have some algebraic identities which are not observed by the compiler -- it simple assumes them
02:06:27 <poetix> @yow
02:06:29 <lambdabot> ... this must be what it's like to be a COLLEGE GRADUATE!!
02:06:56 <poetix> Funnny, that's what I was thinking this morning as I read through chapter 5 of TaPL on the bus...
02:09:34 <tessier_> TaPL?
02:09:43 <tessier_> Try another Pita, Larry?
02:10:42 <ski> Types and Programming Languages http://www.cis.upenn.edu/~bcpierce/tapl/
02:10:50 <musasabi> Has anyone had panics with "Unify.unifyTauTyLists: mismatched type lists!" in GHC 6.4?
02:10:56 <jyp> @google TaPL
02:10:58 <lambdabot> http://www.landman.org/tapl/
02:11:19 <jyp> Tulsa Association of Petroleum Landmen :)
02:12:42 <gennet1> @google TaPL programming
02:12:44 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
02:12:59 <tessier_> @google gay sex
02:13:01 <lambdabot> http://www.gayonthenet.net/
02:13:03 <tessier_> hah
02:13:16 <Itkovian> err ...
02:13:31 <tessier_> hehehe...I kill me. :)
02:13:52 <tessier_> IRC at work is bad. Coworkers see me laughing and think I'm nuts.
02:14:36 <gennet1> @moo
02:14:55 <gennet1> wait; did we disable that one?
02:16:28 <earthy> musasabi: I've seen that on the ghc bugs mailinglist
02:16:36 <earthy> not experienced it myself though
02:19:50 <musasabi> hmm ok, that means that someone has reported it => no need to try to find a simple test case.
02:33:30 <TheHunter> musasabi, better check current cvs-ghc first.
02:38:02 * shapr throws lambdas
02:39:23 * poetix catches and applies
02:39:34 <poetix> (\x -> x x) (\x -> x x)
02:39:52 <poetix> @t (\x -> xx) (\x -> x x)
02:39:53 <lambdabot> Maybe you meant: timein todo todo-add todo-delete topic-cons topic-
02:39:53 <lambdabot> init topic-null topic-snoc topic-tail topic-tell type pl wn
02:39:59 <poetix> @type (\x -> xx) (\x -> x x)
02:40:05 <lambdabot> bzzt
02:40:08 <ski> poetix :  hah, luckily, that'll not get past ethe occurs check
02:41:17 <poetix> So when are they going to add infinite types to Haskell? I want infinite types!
02:41:30 <TheHunter> just use newtype.
02:42:47 <shapr> Is there an infinity symbol in unicode?
02:42:59 <ski> newtype U a = MkU {unU :: U a -> a}
02:43:31 <ski> poetix : you can write bigOmega using that isomorphism
02:44:05 * poetix boggles
02:44:34 <wilx> Hmm....
02:45:33 <wilx> @ti
02:45:46 <wilx> @timein
02:45:50 <wilx> @timein Prague
02:45:52 <lambdabot>  Tuesday, July 5, 2005 at 11:46:53 AM CEST
02:46:00 <wilx> @ti Prague
02:46:02 <lambdabot>  Tuesday, July 5, 2005 at 11:47:03 AM CEST
02:46:05 <wilx> Nice.
02:49:31 <shapr> Neat, I got an email from SPJ. He said #haskell should be mentioned on http://www.haskell.org/mailinglist.html
02:50:17 <gennet1> does that mean he's going to stalk #haskell? oh yes oh yes oh yes </fanboi>
02:56:15 <wilx> :)
03:00:39 <musasabi> Has anyone gotten a working fold or map on type-indexed structures (HLists etc).
03:01:00 <musasabi> With HList I get errors when trying e.g. "hMap (const 'f') (hCons True hNil)".
03:02:00 <musasabi> It seems that the Apply class needs some help (class Apply f x y | f x -> y where ...; instance Apply (x->y) x y where ...") but I am not sure how to make it work.
03:03:13 <musasabi> In the example case it complains about "No instance for (Apply (b -> Char) Bool e')", although I think it should be able infer b=Bool - but that does not seem to work.
03:10:54 <xerox> They call it UMTS :-)
03:14:23 <xerox> 420kbps connection via cellphone, it's great.
03:14:26 <xerox> dcoutts_: ping!
03:16:34 <earthy> highly expensive also, I'd say
03:17:31 <xerox> The first 400Mb are free, then 0.03eurocent /kb
03:17:44 <xerox> By the way, I should go, see you later :--)
03:18:46 <earthy> ;)
03:28:20 <earthy> why does my pringles can seem to list the way the can is built and can be thrown away in swedish?
03:46:38 <poetix> @yow
03:46:40 <lambdabot> Well, O.K.  I'll compromise with my principles because of EXISTENTIAL
03:46:41 <lambdabot> DESPAIR!
03:47:08 <poetix> Is there a source file for these (zippy.txt)? Are they randomly generated?
03:48:48 <poetix> I seem to recall SPJ referring to Haskellers as pinheads...
03:49:10 <poetix> @google wearing the hair shirt
03:49:11 <lambdabot> http://research.microsoft.com/Users/simonpj/papers/haskell-retrospective/
03:50:55 <poetix> Yow! A smallish rather POINTY-HEADED USER-BASE makes Haskell NIMBLE!
03:52:54 <earthy> not pinheaded though
03:52:59 <earthy> :P
04:17:02 <Itkovian_> nice presentation
04:31:33 * shapr throws lambdas at beelsebob 
04:31:33 <Tue13706> is a loop stride of +1 most common?
04:31:45 <Tue13706> or is that a false statement
04:31:46 <shapr> What's a loop stride?
04:32:00 <Tue13706> the amount you increase a loopindex with each iteration
04:32:10 <dons> loops? what's a loop? ;)
04:32:24 <dons> we have maps and folds here ..
04:32:34 <shapr> Right, what's up with loops?
04:32:37 * shapr checks the channel
04:32:45 <shapr> Man I thought I was on #python for a sec
04:32:53 <dons> yow!1
04:33:17 <Tue13706> ok i get the msg :)
04:33:24 <dons> Tue13706: maybe you want: repeat
04:33:57 <dons> or there's dozens of other ways to do repeated actions
04:34:09 <shapr> I like using 'until'
04:34:10 <dons> and good old recursion for the old skool
04:34:30 * beelsebob eats the lambdas and evaluates them
04:36:21 <dons> I never understood why we don't have repeatM and repeatM_
04:37:29 <dons> though repeat and a sequence_ might do the trick
04:40:07 * shapr beats lambdabot's lambda into weak head abnormal form
04:40:40 <dons> is lambdabot misbehaving?
04:40:50 <shapr> No, I'm just a sadist.
04:40:51 <dons> or is shapr misbehooving?
04:40:56 <shapr> Yes!
04:40:57 <beelsebob> @botsnack
04:40:58 <lambdabot> :)
04:41:27 <shapr> hej dblhelix
04:41:35 * beelsebob wonders how you hoov
04:41:35 <dblhelix> hi shapr
04:41:54 <beelsebob> or behoov even
04:42:05 <shapr> beelsebob: It involves cloven hooves obviously.
04:42:24 <beelsebob> well yes, but I'm the one with them
04:42:31 * shapr Pans the cameracopia around to focus the stream of veggies on beelsebob 
04:43:02 <beelsebob> you know it's significantly hotter than that in hell
04:43:22 <shapr> I wouldn't know, never visited.
04:43:34 <beelsebob> you should come stay some time
04:43:40 <xerox> Hi friends!
04:43:49 <beelsebob> lo
04:44:32 <shapr> hiya xerox, how's the sunny south treating you?
04:45:06 <xerox> Let's say I'm enjoying the weather :-)
04:45:19 <xerox> I finally managed to get a connection, woo.
04:46:29 <shapr> yay!
04:46:50 <xerox> It's hard to try to code on vacation..
04:47:39 <beelsebob> why on earth would you do a silly thing like that?
04:48:00 <xerox> beelsebob: because I'm doing paid work :)
04:48:14 <beelsebob> hmm... perhaps not a vacation then?
04:48:18 <xerox> beelsebob: http://code.google.com/summerofcode.html
04:48:28 <xerox> Both.. :)
04:48:28 <poetix> @type replicateM
04:48:34 <lambdabot> bzzt
04:48:45 <beelsebob> cool
04:48:47 <poetix> @type Control.Monad.replicateM
04:48:50 <lambdabot> forall a (m :: * -> *).
04:48:50 <lambdabot>           (Monad m) =>
04:48:50 <lambdabot>           Int -> m a -> m [a]
04:56:26 <shapr> shazam!
05:02:03 <musasabi> Anyone have nice new code?
05:03:23 <Itkovian_> nope
05:03:35 <shapr> I have a bunch of boring for-pay Python code.
05:04:02 * TFK wrote a Haskell solution for problem #55 from the Euler Project
05:05:15 <xerox> TFK: any url?
05:05:29 <TFK> http://mathschallenge.net/index.php?section=project&ref=view&id=55
05:05:40 <TFK> (It is very easy, of course.)
05:08:21 <Itkovian> hmm, seems like a nice question
05:10:27 <tromp> although reversing decimal digits is a rather arbitary operation on number
05:10:37 <tromp> numbers
05:11:00 <xerox> tromp: what do you mean?
05:11:02 <Itkovian> so how did you do it? first thing that comes to mind is a show $ (\x -> (read x) + (read $ reverse x)) ...
05:11:17 <tromp> the 3xn+1 problem is so much nicer
05:11:32 <Itkovian> hey, don't go bashing TFK
05:12:10 <TFK> revNum = read . reverse . show
05:13:26 <tromp> it'll be faster to use bcd:)
05:13:37 <TFK> bcd?
05:13:43 <tromp> binary coded decimal
05:13:52 <tromp> stores each digit in 4 bits
05:14:39 <beelsebob> I'm not sure I care what's faster in this situation... I'd just want a neat solution that anyone can read
05:14:41 <Itkovian> faster: yes, more elagant: no, imo
05:14:57 <earthy> tromp: it wouldn't look much different, toplevel
05:14:59 <TFK> Well, my computer crunched the numbers for that problem with my totally naive code in under a few minutes.
05:15:23 <tromp> ok, then go for the concise code
05:15:57 <TFK> I'll post it right after I get it to compile... apparently I changed something and now it barfs o_O
05:17:48 <earthy> so, what do you in fact do? run 50 iterations of revAndAdd on each number?
05:18:02 <earthy> and see if you hit a palindrome along the way?
05:18:06 <earthy> if not it's Lychrel?
05:18:39 <TFK> Unless it's really smart in its laziness, yes, it builds a list of rev-and-add-ed numbers.
05:19:58 <TFK> http://hbin.dyndns.org/pastebin/64.html <--- this should work
05:21:37 <beelsebob> looks sensible
05:21:48 <beelsebob> I think I'd use a filter to pull out the palindromes
05:21:51 <beelsebob> and then use and
05:21:57 <beelsebob> because that will get done lazily
05:22:09 <TFK> filter and and?
05:22:10 <beelsebob> ... unless I'm being stupid
05:22:30 <TFK> What do you mean by "and"?
05:23:18 <beelsebob> isLychrel n = and . filter (\x -> x /= revNum x) (take 50 (makeRev n))
05:23:34 <beelsebob> @type and
05:23:39 <lambdabot> [Bool] -> Bool
05:23:54 <beelsebob> bah... I meant or anyway
05:23:56 <TFK> o_O?!
05:23:57 <xerox> @pl \x -> x /= revNum x
05:23:57 <beelsebob> stupid bob
05:23:58 <lambdabot> ap (/=) revNum
05:24:01 <xerox> :-)
05:24:18 <beelsebob> true enough... I was just pulling code from the pastebin
05:24:33 <beelsebob> ((/=) . revNum)
05:24:41 <beelsebob> no... that doesn' work
05:24:45 <beelsebob> dumb bob
05:24:47 <TFK> Of course, I could use a curry there :-/
05:25:22 <TFK> maybe o.o
05:26:06 * TFK sticks to the lambda
05:26:11 <beelsebob> isLychrel n = or . filter (\x -> x /= revNum x) (take 50 (makeRev n))
05:26:22 <TFK> What do and and or do?
05:26:29 <TFK> @index and
05:26:29 <lambdabot> Data.List, Prelude
05:26:38 <beelsebob> take a list of booleans and and them all
05:26:41 <beelsebob> or or them all
05:26:46 <shapr> shazbot!
05:26:54 <beelsebob> or [True, False, False] = True
05:27:04 <beelsebob> and [True, False, False] = False
05:27:07 <beelsebob> ....
05:27:13 <TFK> Ah. How would that be lazy, however?
05:27:23 <beelsebob> it's a fold iirc
05:27:32 <sick_jacken> and quits as soon as it hits False i presume :)
05:27:41 <beelsebob> that will become true as soon as it hits true
05:27:47 <Itkovian> TFK lazy as in the sens that in e.g. C && and || short-circuit
05:27:49 <shapr> Hiya sick_jacken, do you have a cold?
05:28:11 * TFK will stick to his old code
05:28:22 <shapr> What happened to the famous $DAY + RNG nicknames?
05:28:24 <sick_jacken> nah, its the name of one half of my favorite rap formation
05:28:41 <TFK> Although I wonder if takeWhile would be better, since it only evaluates the length of a list which it already evaluated.
05:29:18 <TFK> will length be lazy in that code I posted?
05:29:19 <beelsebob> what, and compare it with 50?
05:29:34 <TFK> Well, yes.
05:29:43 <beelsebob> no... there's no way for it to tell that length is monotonic
05:30:10 <TFK> er?
05:30:45 <sick_jacken> if the argument to length grows, length grows no?
05:30:56 <beelsebob> yes... you know that... the compiler doesn't
05:31:13 <TFK> The point is, will length stop after it has been determined that it is >=1 ?
05:31:15 <sick_jacken> ow ok
05:31:17 <beelsebob> no
05:31:24 <TFK> Shucks.
05:31:38 <beelsebob> because it doesn't know that length grows with input size
05:32:01 <beelsebob> it might be that after 6 recursions, the length function always returns 0
05:32:34 <TFK> Maybe I could pattern match it, then?
05:32:45 <kuribas> isn't "length l >= 1" the same as "not (null l)"?
05:32:59 <beelsebob> myLength [] = 0
05:32:59 <beelsebob> myLength (a:b:c:d:e:f:[]) = 0
05:32:59 <beelsebob> myLength (x:xs) = myLength xs + 1
05:33:12 <xerox> uh?
05:33:18 <beelsebob> yeh... (not . (== [])) would work
05:33:29 <sick_jacken> not . null too :)
05:33:34 <TFK> kuribas, heh, I think that that was the function I was looking for! :-)
05:33:49 <xerox> beelsebob: null doesn't need the Eq constraint while ==[], if you care
05:33:57 <TFK> Looks much less like C now, too ;-)
05:34:01 <beelsebob> ah... interesting
05:34:09 <beelsebob> that's useful to know
05:34:55 <earthy> yeah, that was easy, that lychrel thingy
05:35:02 <TFK> So in that case of if null rs ... will it be lazy?
05:35:21 <beelsebob> it will... it will discover it's longer than no elements and give up
05:35:48 <earthy> takeWhile (< 10000) $ lychrelsWithin 50
05:35:51 <earthy> [196,295,394,493,592,689,691,788,790,879,887,978,986,1495,1497,1585,1587 ...
05:36:08 * xerox throws lambdas
05:36:31 <earthy> barring bugs in my code, that's 246 Lychrel numbers under 10000
05:37:42 * shapr throws redexes
05:38:02 <earthy> nice thingy, TFK. ;)
05:38:08 <earthy> now to speed it up. ;)
05:38:21 <TFK> Hey, don't let me stop you!
05:38:27 * shapr votes for simple code that's easy to understand
05:38:33 <beelsebob> a way to make it more efficient would be to go a bit farther with 196 -- because if you go to 51 itterations you can show 887 is one too
05:38:37 <beelsebob> ... and so on
05:38:38 <earthy> lychrelsWithin y = filter (not . (hasPalindromeWithin y)) ints
05:38:42 <xerox> TFK: paste it!
05:38:43 <earthy> hasPalindromeWithin y x = any isPalindrome $ take y $ revvedAndAdded x
05:38:51 <earthy> revvedAndAdded x = iterate revAndAdd x
05:38:53 <earthy> revAndAdd x = x + revNum x
05:38:58 <earthy> isPalindrome x = (revNum x) == x
05:39:09 <TFK> beelsebob, but the requirement is 50 iterations. Otherwise the answer won't be "correct".
05:39:49 <beelsebob> tfk: that's why you do it over 50, mark 196, then do an extra itteration and mark 887... then an extra and mark 1675....
05:40:40 <TFK> I don't follow...
05:41:00 <beelsebob> well... if you do 51 itterations for 196, then you've done 50 itterations for 887
05:41:22 <sick_jacken> memoiresation
05:41:23 <beelsebob> and most of the work was done for you in working on 196
05:41:28 <sick_jacken> modula spelling errors
05:41:36 <beelsebob> haha
05:41:37 <sick_jacken> modulo spelling errors
05:41:54 * earthy thinks memoisation might not result in much speedup
05:42:07 <beelsebob> s/[:incorrectly spelled:]/correct(\0)/
05:42:37 <xerox> spelt?
05:42:53 <earthy> hm. my code is quite a different approach from yours, TFK
05:43:07 <beelsebob> thing is that for each time you do a memorization, you remove 50 itterations that have to be performed on another number
05:43:17 <earthy> do you?
05:43:40 <beelsebob> yes - you have to do one calculation to find that 887 is one, rather than 50
05:43:44 <sick_jacken> i dont know earthy, do you?
05:43:54 <earthy> beelsebob: explain.
05:44:06 <shapr> Yeah, I know earthy, he's some guy on #haskell
05:44:14 <beelsebob> well... If I've calculated all the reverses for 196
05:44:18 <beelsebob> (50 of them)
05:44:25 <beelsebob> all you have to do is the 51st one
05:44:33 <beelsebob> and you show that 887 is also one
05:44:41 <xerox> ttyl
05:44:42 * xerox &
05:44:51 <beelsebob> repeat for the 52nd one and you get that 1675 is one
05:44:53 <beelsebob> etc
05:44:57 <sick_jacken> shapr, to which msg from earthy were you reacting exactly?
05:45:12 <beelsebob> rather than having to do 50 itterations for 887, and 50 itterations for 1675
05:45:15 * earthy sees
05:45:26 <beelsebob> so you get a 50 times speedup in the worst cases
05:45:34 <beelsebob> but no speedup in the best cases
05:45:42 <earthy> take 50 $ revvedAndAdded 196
05:45:43 <earthy> [196,887,1675,7436
05:45:44 <beelsebob> should do something
05:47:11 <beelsebob> so.. you would have to go through the first 10k numbers, and add each one you find to a list of them... when you then come to calculate any number you have to check if you haven't already found it to be a lycherl number
05:47:59 <earthy> so, you're saying, if you filter out numbers that are in a revvedAndAdded stream from the ints that you still have to examine, then the longest run under the number you're going to would be the number you'd add to the number of iterations to gain the strongest speedup
05:47:59 <TFK> earthy, feel free to paste it :-)
05:48:34 <beelsebob> yep
05:49:40 <beelsebob> I guess kinda like a sive for primes... but... less effective
05:49:47 <earthy> not really
05:49:54 <earthy> not if you do positive as well as negative memo
05:50:14 <beelsebob> hm... I don't thing that positiive will gain you much
05:50:26 <beelsebob> oh... actually, maybe it would
05:50:27 <earthy> take 50 $ revvedAndAdded 1
05:50:35 <earthy> take 50 $ revvedAndAdded 1
05:50:35 <earthy> [1,2,4,8,16,77,154,605,1111,2222,4444,8888,17776
05:50:47 <beelsebob> yeh... so you con bin all of them from the search
05:52:30 <Itkovian> is it known how many 'threads' there are?
05:52:45 <TFK> But filtering from the 10,000 list is already O(n), innit?
05:53:00 <beelsebob> yeh... but the operations don't cost much
05:53:00 <earthy> TFK: um, yeah.
05:53:09 <beelsebob> wheras reverse and add costs a lot more
05:53:20 <earthy> but the constant factor is huge
05:53:31 <beelsebob> and it could easily be done lazily
05:53:31 <earthy> plus, if you were to extend it to larger numbers
05:53:37 <TFK> You guys time it and tell me the results :-)
05:53:38 <earthy> it won't work anymore
05:54:05 <TFK> Why not?
05:54:13 <earthy> go over 10677....
05:54:21 <beelsebob> yeh... and carry on...
05:54:29 <beelsebob> you'll probably find another palindrome
05:54:30 <earthy> you won't know how many iterations you need to run into a plaindrome
05:54:37 <earthy> palindrome
05:54:48 <beelsebob> yeh... so maybe positives are a bad plan
05:54:59 <beelsebob> but filtering out negatives works fine
05:55:03 <earthy> exactly
05:55:18 <earthy> where negatives are known to have palindromes
05:55:18 <TFK> makeRev 11000 works just fine here...
05:55:48 <beelsebob> earthy: not what I meant... negatives as in ones where you've found nothing after 50 steps
05:56:20 <beelsebob> gotta go see my supervisor... bbl
05:58:32 <earthy> TFK: that's not the issue
05:58:51 <earthy> isLychrel, in your code, is stuck to 50 iterations
05:59:01 <TFK> Or less.
05:59:06 <TFK> (If its really lazy)
05:59:22 <earthy> yes, but if a palindrome is only found after, say, 500 iterations, your code won't find it
05:59:37 <TFK> Of course. That's not the requirement, either.
06:00:14 <earthy> not in the exercise, no
06:00:51 <earthy> but, if you want to calculate all true Lychrel's under a certain number......
06:00:55 <Itkovian> is checking for equality of lists lazy?
06:01:19 <Philippa> I imagine it short-circuits, yes
06:01:29 <Itkovian> earthy: checking for a true Lychrel is not possible imho.
06:01:51 <Itkovian> only if you actually find a palindrome can you claim something, otherwise, you can conclude nothing
06:02:12 <earthy> true enough
06:02:45 <earthy> by enumeration, you can only conclude with certainty that numbers have palindromes under enough iterations
06:03:26 <earthy> so, what if you want to generate all numbers that are known to have palindromes
06:03:35 <earthy> this can be enumerated after all
06:03:57 <Itkovian> true
06:04:04 <Itkovian> well ...
06:04:06 <Itkovian> no
06:04:12 <earthy> no?
06:04:15 <Itkovian> hmm
06:04:22 <Itkovian> yes, but it may take a really long time
06:04:35 <earthy> enumeration can run infinetly long, true
06:04:45 <Itkovian> ok, it's possible, but here too, you can not impose a limit on the number of iterations ...
06:04:51 <earthy> true
06:05:18 <Itkovian> the enumeration will run for an infiotite time, but checking for all numbers under a certain level is feasible, though imo nothing can be claimed
06:05:24 <Itkovian> wrt to time limits
06:05:34 * earthy nods
06:10:53 <earthy> owh, that's weird
06:11:10 <earthy> either TFK's code has a bug, or mine does
06:11:32 <TFK> Probably yours ;-)
06:11:36 <earthy> really?
06:11:45 <earthy> @pastepage
06:11:47 <lambdabot> Unknown command, try @listcommands.
06:11:48 <TFK> I've talked to a person who got a correct submission, and my answer matched his.
06:11:59 <TFK> earthy, hbin.dyndns.org
06:13:30 <earthy> http://hbin.dyndns.org/pastebin/65.html
06:13:38 <Itkovian> TFK: how many did you find beneath 10000?
06:13:41 <earthy> my answer comes out 3 lower
06:13:51 <Itkovian> I nfind 246
06:14:59 <earthy> ah, got the difference
06:15:37 <earthy> are *zero* iterations of reverse and add enough?
06:15:44 <earthy> or must you always perform at least one? :)
06:15:52 <earthy> before checking for a palindrome?
06:16:24 <Itkovian> no, I think you need to do at least one?
06:16:53 <earthy> in that case, my code is wrong.
06:16:59 <Itkovian> so is 246 correct?
06:17:07 <Itkovian> I'll post my code on the paste page
06:17:12 <Itkovian> comments are welcome
06:17:43 <jlouis> shapr: http://www.haskell.org/tmrwiki/OnTreapsAndRandomization ;)
06:17:57 <jlouis> most of it finished. It will probably be ready around 00:00
06:18:28 <earthy> if you *have* to do at least one step, the number is 249, yes
06:18:38 <earthy> i.e.: some palindromes are lychrels
06:18:51 <earthy> possibly lychrels
06:19:11 <Itkovian> hmm
06:19:13 <earthy> makes the code faster, even. ;)
06:19:21 <earthy> slightly so
06:19:26 <sick_jacken> hey dudes. they're just numbers :P
06:19:29 <earthy> it seems ;)
06:19:29 <Itkovian> dang, then I am missing somewhere
06:19:38 <Itkovian> number are cool.
06:19:48 <sick_jacken> sure, on my sandwich
06:20:24 <earthy> Itkovian: do you mark 4994 as possibly a Lychrel number or not?
06:20:31 <Itkovian> erm
06:20:42 <poetix> jlouis: Treaps look a bit like randomly balanced trees?
06:20:52 <Itkovian> nope
06:20:54 <Itkovian> hmm
06:21:00 <earthy> well, it is one. ;)
06:21:04 <Itkovian> dang
06:21:35 <Itkovian> ok, then I just need to take the tail of the list, eh :-)
06:22:17 <Itkovian> heh
06:22:18 <Itkovian> solved
06:22:56 <Itkovian> let's see how that number changes in terms of the iterations
06:22:56 <earthy> okay, on this machine, my code is some 5s faster than TFK's code
06:23:02 <earthy> and cleaner to boot
06:23:02 <Itkovian> hmm ...
06:23:08 <Itkovian> how fast is that then?
06:23:25 <earthy> my code takes about 18s to run
06:23:29 <earthy> TFK's about 23s
06:23:45 <TFK> Itkovian, 249, afaik
06:23:53 <earthy> TFK: the 249 is right
06:24:12 <Itkovian> I have 249 now, after earthy's example
06:24:22 <TFK> 4994 is a Lychrel number because it says so in the problem description ;-)
06:24:26 <earthy> exactly. :)
06:24:39 <earthy> there's 3 palindromes under 10000 that are thought to be lychrels
06:25:14 <TFK> earthy, how long did your code run overall?
06:25:20 <earthy> 18s
06:25:47 <earthy> that's in ghci
06:25:48 <earthy> btw
06:25:59 <Itkovian> heh earthy I beat you by one second ;-0)
06:26:00 <TFK> That's a substantial difference, then.
06:26:22 <Itkovian> I have 4,59 and earthy has 5.6 seconds
06:26:36 <Itkovian> 1.5 GHz g4
06:26:45 <earthy> [4994,8778,9999] are the 3 palindromes that are under 10000 that are thought to be lychrels
06:26:53 <earthy> and the 3 numbers you did count and we didn't, at first. ;)
06:27:04 <earthy> oooh, I wanna see your code, itkovian
06:27:08 <TFK> Nope, at first I didn't count them as well ;-)
06:27:10 <Itkovian> see the paste pasge
06:27:13 <Itkovian> @paste
06:27:14 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:27:32 <TFK> But then I reread the problem description, and realized my horrible sins :-/
06:27:49 <Itkovian> hehe
06:27:55 <Itkovian> horrible, eh
06:28:13 <earthy> ah!
06:28:15 <Itkovian> those times were ghc 6.4 -O2
06:28:20 <Itkovian> what did I do wrong?
06:28:22 <earthy> Itkovian: try changing that Int to Integer
06:28:23 <earthy> :)
06:28:37 <earthy> that's probably where the speed diff is
06:28:43 <Itkovian> the iterations Int?
06:29:12 <Itkovian> otherwise I use Integers, no?
06:29:15 <jlouis> poetix: exactly ;)
06:29:26 <earthy> Itkovian: since basically your code is identical to mine
06:29:33 <Itkovian> hmm
06:29:38 <poetix> jlouis: like this then: http://www.codepoetics.com/code/rbt.hs
06:29:39 <Itkovian> but take needs an Int, eh
06:29:44 <Itkovian> @type take
06:29:49 <lambdabot> forall a. Int -> [a] -> [a]
06:30:21 <earthy> ah, no, I know where the diff is
06:30:31 <earthy> you've taken read and show out of the main loop
06:30:51 <Itkovian> erm, no
06:31:01 <earthy> erm, yes.
06:31:02 <Itkovian> it's exactly in the loop ...
06:31:14 <Itkovian> the palin iterate loop ...
06:31:17 <earthy> the main loop in your case has only one read/show combo
06:31:19 <earthy> mine has 2
06:31:23 <Itkovian> ah, well ...
06:31:29 <Itkovian> too bad, eh ;-)
06:31:36 <Itkovian> I pass along Strings
06:31:39 <earthy> exactly
06:31:44 <jlouis> poetix: yes, there are similarities
06:31:45 <Itkovian> ok.
06:31:47 <earthy> I pass along Integers
06:31:55 <Itkovian> that would explain it
06:32:05 <poetix> jlouis: well, there goes *my* TMR article...;)
06:32:19 <earthy> but the solution is otherwise identical
06:32:42 <Itkovian> ok
06:32:42 <jlouis> poetix: haha
06:32:48 <Itkovian> so we both rock then, eh
06:33:01 <poetix> jlouis: Looks good, though.
06:33:19 <Itkovian> if there's anything more important than my ego around, I want it caught and shot _now_
06:33:22 <Itkovian> ;-)
06:34:10 <earthy> oh, no, I can improve on your soluion
06:34:12 <earthy> solution
06:34:18 <Itkovian> ok
06:34:25 <Itkovian> show me
06:34:36 <Itkovian> can you post it to the paste page?
06:34:40 <earthy> instead of   not $ null $ filter isPalin $  use   any isPalin $
06:35:06 <Itkovian> ok.
06:35:11 <Itkovian> good idea
06:35:12 <earthy> that does not need to run through the entire list of 50 iterations
06:35:22 <Itkovian> true
06:35:32 * Itkovian changes that
06:36:21 <TFK> $-abuse :-/
06:37:27 <Itkovian> hmm ... speedup is 0.09 seconds
06:38:13 <Itkovian> did a few reruns, so the code is in the cache ... we have 0.6 secodns difference now earthy
06:39:03 <shapr> poetix, jlouis: You guys could collaborate on an article.
06:39:14 <Itkovian> at least 25 iterations are needed
06:39:42 <metaperl> shapr: whither asciidoc?
06:39:44 <musasabi> I think I am starting to get hold of a polymorphic record fold combinator :-)
06:40:05 <earthy> hm. weird. ;)
06:40:06 * Itkovian does 1000 iterations
06:40:09 <earthy> oh well ;)
06:40:09 <poetix> shapr: Looks to me like he's almost there already.
06:40:17 <earthy> enough play ;)
06:40:33 <poetix> shapr: On the other hand, I want to do something on mutable data structures for the I/O series...
06:41:52 <shapr> Sounds good.
06:42:05 <Itkovian> TFK: what do you mean by $ abuse? Don't you like that style or do you think it's better to use () and . more often?
06:42:28 <shapr> metaperl: Haven't checked it out yet.
06:43:04 <poetix> shapr: It seems to me that IORefs encourage you to think of mutable memory as an external device, something outside the program - like an in-memory database
06:43:16 <TFK> I think it's better to mix 'em tastefully. (Don't ask me to provide metrics for tasteful $/./() style :-/ )
06:43:28 <shapr> poetix: interesting viewpoint...
06:43:49 * tomdavie farts
06:43:57 <earthy> if it turns unreadable: split the expression, think up a new name
06:43:57 <Matt-W> poetix: I thought of them a bit like that when I read about them a while back
06:44:13 <Matt-W> since I haven't used IOrefs anywhere serious though I don't know how well that translates into real programming
06:44:48 <shapr> tomdavie: Watch out, you might blow yourself away.
06:45:07 <tomdavie> I might... I might blow us all up too
06:45:24 <Matt-W> only if there are sparks flying
06:45:56 <shapr> poetix: I'm still stuck on your stateless Zope idea, I think that's a real winner, if I can figure out how it works well enough to see how to implement it.
06:46:23 <poetix> Matt-W: A data structure using IORefs could be seen as an in-memory database exposing a particular API...
06:46:38 <Matt-W> poetix: indeed it could
06:47:28 <poetix> shapr: I think yi has some of the answers, but need to get to know it better.
06:47:54 <poetix> shapr: Particularly like the way yi hot-swaps - the localisation of state in the yi core
06:48:14 <poetix> shapr: So each plug-in receives its entire state as a parameter on start-up (or restart, as may be)
06:48:55 <poetix> shapr: That seems to me to be very close to how Haskell On Heat might work.
06:49:03 <Itkovian> earthy: take is lazy, no? so increasing the number of iterations is only nefast for real Lychrel numbers, yes?
06:50:14 <earthy> um. no
06:50:58 <earthy> at least, in my solution it wasn't
06:52:02 <earthy> ummm.
06:52:16 <earthy> ik raaskal
06:52:20 <earthy> disregard that
06:52:23 <earthy> yeah, take is lazy
06:52:55 <earthy> but going up in iterations is *costly*
06:53:00 <earthy> as you hit really big numbers
06:53:12 <earthy> and bignumcalc is expensive
06:54:34 <Itkovian> yeah that's true
06:54:50 <sick_jacken> i wish bol came to bring my book :S
06:54:52 <sick_jacken> i need it
06:57:13 <shapr> Bah, I'll bbl, my local bike shop needs help to order the right spokes...
06:57:14 * shapr sighs
06:57:39 <sick_jacken> good thing you only got one wheel
06:57:40 <sick_jacken> lol
06:58:20 <earthy> 'your laptop will be fixed early next week'... I call... 'probably we can have it by thursday'
06:58:57 <sick_jacken> hmm, are you *that* convincing over the phone :P
06:59:34 <earthy> the first statement was last friday
06:59:42 <earthy> so, they are late.
06:59:56 <sick_jacken> ow in that sense
07:02:28 <sick_jacken> i thought those ibooks never broke down :P
07:03:22 <earthy> well, they do.
07:03:59 <Spark> thats because youve been a victim of marketting
07:04:24 <earthy> all notebooks break down
07:04:26 <Spark> in related news, the titanic is unsinkable :)
07:04:34 <sick_jacken> huh, but mac is the best thing in the world isnt it? like ipod is the best mp3 player?
07:04:41 * sick_jacken his world crumbles
07:05:02 <aheller> Spark: At the moment, that happens to be true, no?
07:05:42 <Spark> i think the definition is not typesafe
07:05:55 <Spark> the titanic is not of type float
07:06:09 <sick_jacken> that was a prepared one
07:06:10 <sick_jacken> :)
07:06:36 <Spark> not at all, embarassingly enough :)
07:06:48 * aheller recoils in horror.
07:07:40 <Fide> hi
07:21:31 <jlouis> shapr: theres a whole article more now. I just have to clean up a couple of bits
07:22:11 <poetix> shapr: Are you going to release TMR this month now, or hold it back until  next month?
07:26:55 <Speck> Re:  (Don't ask me to provide metrics for tasteful $/./() style :-/ ), I find that composition is used when one is expressing an algorithm that composes multiple functions, application ($) is used when one wants to separate the functions main algorithmic logic from something like show, and parens are used when the first two don't apply or make the code less readable
07:27:41 <Itkovian> ok, that sounds clear enough. now to apply it :-)
07:30:27 <Speck> shapr, a stateless zope in haskell?
07:33:23 <TheHunter> Itkovian, as we're already critisizing your style, there are many unnecessary parens. Application _always_ binds tightest, so you should write e.g. filter (not . allowsPalindrome iterations).
07:33:39 <Itkovian> ok
07:33:50 <sick_jacken> it binds reallllll tight
07:35:46 <Speck> function calls suffocate their arguments
07:36:01 <sick_jacken> annexation
07:36:07 <juhp> dons: is there a recommended hs-plugins snapshot for ghc-6.4?
07:39:22 <metaperl> why am I getting an error at ".." in this function?
07:39:26 <metaperl> superimposeImageRow i1 i2 yCoord wth =
07:39:26 <metaperl>     [ siPointLogic i1 i2 x yCoord | x <- 0 .. (wth - 1) ]
07:39:40 <TheHunter> x <- [0..wth-1]
07:39:54 <metaperl> no spaces allowed I take it
07:39:57 <sick_jacken> is Data.Graph nice to use? or is there a better lib out there?
07:40:02 <TheHunter> no spaces are ok.
07:40:09 <sick_jacken> experiences? recommendations?
07:40:14 <Speck> is (..) a function?
07:40:17 <Speck> @index (..)
07:40:18 <lambdabot> bzzt
07:40:19 <mauke> metaperl: you need [ ]
07:40:27 <sick_jacken> it just exports everything in the module Speck
07:40:29 <metaperl> aaaaaaahh, now I see the light :)
07:40:38 <mauke> there is no .. operator, only [a .. b] syntax
07:40:51 <TheHunter> @index enumFromTo
07:40:53 <lambdabot> Prelude
07:40:56 <sick_jacken> ow like that lol
07:40:59 <Speck> ah
07:41:03 <sick_jacken> i thought the module Bla (..)
07:41:05 <sick_jacken> :D
07:45:13 <bourbaki> hi
07:47:19 <Itkovian> these euler problems seem to be quite easy to solve using haskell
07:47:30 <bourbaki> what euler probs?
07:48:44 <Itkovian> http://mathschallenge.net/index.php?section=project
07:48:44 <TFK> Itkovian, try SPOJ problems.
07:48:57 <Itkovian> TFK: hey, I'm just starting eh :-)
07:49:20 <TFK> SPOJ problems are a bit closer to "useful" code in nature.
07:49:34 <TFK> Although they do have a lot of math-specific problems.
07:50:02 <Itkovian> ah, ok
07:50:04 <Itkovian> url?
07:50:11 <TFK> spoj.sphere.pl
07:50:56 <TFK> I have no idea how to rewrite some solutions I've submitted in Python into Haskell.
07:51:17 * TFK needs to seek more enlightment
07:51:59 <TFK> More enligthment juice!
07:54:09 <Itkovian> ask edison
07:55:26 <Itkovian> TFK: for what does the ACC stand? the number of accepted submissions that passed the tests?
07:55:36 <Itkovian> seems low to me, especially for problem no 1 :-)
07:56:06 <shapr> poetix: This month now.
07:56:27 <sick_jacken> ascending chain condition?
07:56:31 <wilx> Somebody make me a time machine. I want see the ICFP entries!!!
07:56:55 <lisppaste2> metaperl pasted "easy debugging" at http://paste.lisp.org/display/9653
07:56:56 <poetix> shapr: Cool.
07:56:59 <Itkovian> gotta go
07:57:24 <TFK> Itkovian, percent that got accepted from all the other submissions, methinks.
07:57:45 <TFK> And yes, 43% for problem #1 doesn't speak well of the submitters :-/
07:57:55 <TFK> A few problems there are trivial.
07:58:22 <TFK> A few are Just For Fun, a bunch test for knowledge of classical algorithms, and a lot are totally kick-ass ;-)
07:59:02 <sick_jacken> .pl or the euler tfk?
07:59:12 <TFK> SPOJ
07:59:26 <sick_jacken> spoj more challenging than euler?
07:59:31 <TFK> (.pl is for Poland, there are lots of Polish sites, but only one SPOJ ;-)
07:59:47 <TFK> sick_jacken, try some of the "challenge" problems ;-)
07:59:56 <sick_jacken> in this context, it was pretty unambigously what i meant i think :)
08:00:17 <TFK> True. Call me a pedant :-/
08:00:50 <shapr> poetix: Yeah, I hate waiting, and I'm not sure how long it'll take to finish my ArrowsIntro
08:01:04 <TFK> At any case, I didn't look too much into those Euler problems. A few I can solve, others look very difficult.
08:01:34 <shapr> jlouis: mind if I reformat your Notes into footnotes?
08:02:09 <TFK> Anyhoo, Haskell (as are most other languages) are underrepresented on SPOJ, I'd say. Get on it! :-P
08:02:19 <TFK> (to it?)
08:02:47 <Igloo> Either is fine
08:02:48 <shapr> They both work.
08:03:03 <TFK> Ah, good, thanks ^_^
08:03:47 <shapr> For a task you can "Get on it!", "Get to it!", and "Go to it!" among other things.
08:04:21 <sick_jacken> get off to it
08:04:36 <poetix> Barry White?
08:04:42 <sick_jacken> rip
08:04:58 <poetix> "You go, girl!"
08:06:08 <poetix> "Yo, [profane term of endearment], it's time to get busy!"
08:06:13 <jlouis> shapr: not at all
08:06:31 <jlouis> shapr: I am not too experienced in moin-moin formatting ;)
08:07:30 <poetix> "Get your code on!"
08:07:40 <TFK> :-)
08:07:47 * TFK does All About Monads excersizes
08:09:25 <earthy> oeh! monad exercises! oeh!
08:09:26 <earthy> where?
08:09:46 <sick_jacken> http://monadeuler.org
08:09:51 * poetix can lift three monads in each hand
08:10:31 <earthy> monadeuler.org could not be found
08:10:39 <sick_jacken> duh haha
08:11:41 <earthy> oh, pity, I did those alreaady
08:11:51 <poetix> Did you mean: modular
08:11:59 <TFK> http://www.nomaware.com/monads/html/exercises.html
08:17:29 <earthy> google was helpful
08:19:32 <TFK> excersize 1 passed!
08:23:33 <basti_> hi!
08:23:53 <TFK> yo
08:24:35 <basti_> whazzup.
08:26:16 <sick_jacken> Monadic Computational Logics in HOL
08:26:21 <sick_jacken> sounds sick to me :D
08:26:29 <TFK> HOL?
08:26:38 <earthy> by Lutz Schroeder and Till Mossakowski?
08:26:50 <earthy> it's pretty much what I'm doing, currently
08:27:04 <basti_> HOL is a proof system
08:27:05 <sick_jacken> there's a 3 year phd position available in that project
08:27:08 <sick_jacken> so i read
08:27:31 <earthy> they're taking a somewhat different road to slightly different goals
08:27:37 <earthy> but the base direction is the same
08:28:06 <sick_jacken> so is your stuff going to kick them in the behind?
08:28:12 <earthy> nope
08:28:14 <earthy> that is
08:28:23 <earthy> it's going to coexist
08:29:12 <basti_> hmm has anyone had a look into coq?
08:29:18 <sick_jacken> why god why is there so much written about dependence analysis
08:29:21 <basti_> coq seems to be pretty haskelly in a way
08:29:21 <metaperl> *Main> [0..(-5)]
08:29:22 <metaperl> []
08:29:22 <metaperl> *Main> [0 downTo (-5)]
08:29:25 <sick_jacken> im lost in the woods
08:29:44 <metaperl> basti_: what do you think of Scala? It seems very Haskellish
08:29:46 <metaperl> to me
08:29:59 <sick_jacken> @plugs reverse . enumFromTo (-5) $ 0
08:30:05 <basti_> scala?
08:30:28 <lambdabot> [0,-1,-2,-3,-4,-5]
08:30:58 <metaperl> sick_jacken: thanks... kinda wordy... but thanks
08:31:02 <basti_> http://scala.epfl.ch/
08:31:38 <sick_jacken> yeah there's no enumToFrom i guess
08:32:05 * Beelsebob hang around looking bored
08:32:19 * basti_ puts a firecracker under Beelsebob's butt
08:32:24 <sick_jacken> @plugs take 5 . iterate (-1) $ 0
08:32:25 <Beelsebob> OWWWWW!
08:32:40 <lambdabot> <Plugins.Eval>:1:
08:32:40 <lambdabot>   No instance for (Num (a -> a))
08:32:40 <lambdabot>   arising from the literal `1'
08:33:16 <basti_> anyone wanna discuss possible similarities between the fast lazy lexers and a possible solution to the "tab completion problem"?
08:33:27 <sick_jacken> @plugs take 5 . iterate (flip (-) 1) $ 0
08:33:44 <Beelsebob> as long as you don't have any more fire crackers
08:33:52 <lambdabot> [0,-1,-2,-3,-4]
08:34:00 <sick_jacken> @plugs take 6 . iterate (flip (-) 1) $ 0
08:34:06 <sick_jacken> that one is lazy metaperl
08:34:17 <sick_jacken> so maybe that one is better to use
08:34:22 <lambdabot> [0,-1,-2,-3,-4,-5]
08:34:41 <metaperl> its a small numberset, so it doesnt matter
08:34:58 <sick_jacken> true
08:35:07 <sick_jacken> didnt know what the application was and if lazyness was needed
08:36:17 <sick_jacken> is it me btw or did lambdabot get slower?
08:36:27 <sick_jacken> or respond slower
08:36:29 <basti_> the bot smokes dope
08:36:37 <Beelsebob> I thought he'd been slower today
08:37:22 <TFK> Hmm. Maybe is already an instance of MonadPlus, right?
08:37:47 <jlouis> oy Philippa
08:38:01 <TFK> Ah, only inside Control.Monad o_O?!
08:39:26 <TFK> mplus-ing two Maybe instances works when importing Control.Monad with Maybe, but not when importing only Maybe. Why?
08:39:42 <TFK> The docs for Maybe say that it is an instance of MonadPlus, so...
08:39:44 <sick_jacken> maybe because Maybe doesnt export mplus?
08:39:47 <sick_jacken> i dont know
08:40:02 <TFK> How can it not export functions that it defines?
08:40:15 <TheHunter> @index MonadPlus
08:40:21 <sick_jacken> isnt it MonadPlus that defines it?
08:40:23 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
08:40:23 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
08:40:23 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
08:40:38 <TheHunter> MonadPlus is only defined in Control.Monad
08:40:50 <TFK> That was my conclusion, but since the docs say that Maybe makes Maybe an instance of MonadPlus...
08:41:01 <sick_jacken> anyway, im off
08:41:04 <sick_jacken> later
08:42:06 <TFK> Well, I expect Maybe to be instanciated as MonadPlus inside the Maybe module, since the docs say so o_O
08:42:34 <TheHunter> @libsrc Data.Maybe
08:42:34 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/Maybe.hs
08:43:24 * TFK shrugs
08:43:46 <TFK> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Maybe.html <--- Instances: MonadPlus Maybe <--- this is what I would expect, then.
08:44:04 <TFK> Oh well.
08:44:56 <TheHunter> Data.Maybe imports the instance from Control.Monad, and haddock just repeats it.
08:46:03 <shapr> Hm, where's the GHC SMP paper?
08:46:20 <TFK> Then why doesn't it export the functions it defines itself? After all, it already imports the necessary definitions.
08:47:45 <JaffaCake> shapr: http://www.haskell.org/~simonmar/papers/multiproc.pdf
08:48:14 <Beelsebob> http://www.apple.com/ <-- christ I didn't realise apple sold songs so fast
08:48:50 <TheHunter> wait, it doesn't even import Control.Monad. Anyway, that's just the way haddock works.
08:52:34 <Speck> Beelsebob, wow.... haha I wonder if it's an accurate representation
08:52:50 <Beelsebob> speck: you clicked it and seen the contest?
08:52:54 <Beelsebob> the prize is insane
08:53:25 <Beelsebob> 10000 songs, 10 iPods, 50 songs for each of them, and flights, accomodation, and tickets to see Coldplay
08:56:06 <Philippa> ISP phone tech support are bastards, news at 11. Oh to get a direct line to the engineer types who realise I have a clue in three seconds flat...
09:02:43 <Speck> the mathschallenge web site is really fun...
09:04:05 <Speck> I'm trying to master writing in point-free style
09:07:32 <Philippa> true mastery lies in not using your skills ;-)
09:08:01 <basti_> *g*
09:16:09 <tessier_> Hello all!
09:16:12 <tessier_> http://pastebin.ca/16950
09:16:18 <tessier_> Anyone see a problem with that code?
09:16:37 <tessier_> guess.hs:19:12: parse error on input `doGuesssing'
09:16:40 <shapr> JaffaCake: thanks!
09:17:01 <Beelsebob> you need to indent it another char
09:17:03 <tessier_> Jaffa cake...that sounds familiar. Isn't that like a snacky thing?
09:17:08 <Beelsebob> or 4
09:17:15 <tessier_> Beelsebob: 8 spaces are required?
09:17:22 <shapr> Yeah, like a Debbie Cake
09:17:26 <Beelsebob> no.. 4 more
09:17:47 <Beelsebob> to align it with the first statement in the do
09:18:58 <Beelsebob> also, it would be easy to do that without the IO monad in anything but main
09:19:23 <tessier_> What needs to be aligned with the first statement in the do?
09:19:32 <Beelsebob> you'd just need doGuessing does
09:19:35 <tessier_> And I still don't understand what a monad is. I'm just getting started.
09:19:39 <shapr> y0 SyntaxNinja
09:19:47 <shapr> tessier_: Monads are really simple, I'll explain them to you sometime.
09:19:57 <Speck> What would be a good lazy way of finding the first True in a [Bool]?
09:20:12 <tessier_> Page 33 of YAHT has the doGuessing all the way against the left margin
09:20:17 <Beelsebob> speck: and
09:20:24 <Beelsebob> or even
09:20:27 <shapr> A monad is just an abstraction like OOP is an abstraction.
09:20:33 <Muad_Dib> Monads are just a way to hide something, right? :P
09:20:40 <Speck> actually my thought was wrong
09:20:46 <shapr> Yeah, the same way you hide stuff in objects.
09:20:55 <shapr> But you use different camoflauge with monads :-)
09:20:56 <Beelsebob> tessier... is it within an if expression
09:21:04 * Muad_Dib at least got one thing right from his AFP course :)
09:21:10 <tessier_> Actually, I do undersatnd that monads are a way to hide the purely functional program internals from the very stateful and non-functional outside world
09:22:07 <Beelsebob> yeh... and they shouldn't really be used for what you're doing... you should be using the monad to generate a list of inputs, and then passing that to a function that lazily generates outputs
09:22:11 <shapr> err... once you're familiar with the pure code, I'll tell you about monads. They're not complicated or difficult, but it's easier if you understand parameterized types, big lambda statements, etc
09:22:12 <Philippa> tessier_: wrong
09:22:48 <Philippa> In the context of IO, they're a way to hide the world (considered as a value) from the rest of the program that might try to do physically impossible things like duplicate it
09:24:03 <tessier_> Philippa: Duplicate it? What do you mean?
09:24:09 <Muad_Dib> the IO monad can be seen as something like World -> World
09:24:15 <Muad_Dib> at least something like that :P
09:24:33 <Philippa> right. Only if you have two Worlds, you can do stuff on one, decide you don't like the results and use the other to do something different and return that
09:24:43 <Muad_Dib> heeh
09:24:44 <Philippa> except you can't, because that would require looking into the future
09:24:47 <Muad_Dib> that was not what i mean :P
09:25:04 <Muad_Dib> i meant more like something they do in that programming language Clean
09:25:06 <Philippa> no, but it's a problem with letting the user actually write World -> World funcs
09:25:06 <xs> isn't that what forkIO does..?
09:25:28 <Philippa> xs: no, forkIO effectively puts the other thread into the World
09:25:31 <shapr> JaffaCake: Plan on adding non-stop GC to go along with parallel GC? Would be nifty.
09:25:47 <xs> Philippa: hm! ok, thanks
09:26:01 <tessier_> Philippa: Are you referring to the immutability of functional programs?
09:26:07 <Philippa> tessier_: no, I am not
09:26:30 <Philippa> do you understand the idea of a World -> World function Muad_Dib's given?
09:26:30 <SyntaxNinja> heya shapr
09:26:31 <tessier_> What does "World" mean?
09:26:34 <tessier_> Nope
09:26:41 <Philippa> a type that represents a complete state-of-the-universe
09:26:43 <tessier_> I'm on page 33 of YAHT. :)
09:27:04 <Muad_Dib> tessier_: the idea of a functional language is that given a function, if you put something in, you get the same result as any other time you put exact the same thing in
09:27:16 <tessier_> Muad_Dib: Got it...
09:27:21 <shapr> SyntaxNinja: How was your trip?
09:27:34 <Muad_Dib> tessier_: however, if you try to read a file from you disk by giving it your filename, this is not true
09:27:35 <Philippa> so you run the program by feeding in the initial state and seeing what the resulting state-of-the-universe looks like (complete with time having passed, things in the universe having been altered by the program etc etc)
09:27:51 <Speck> my computer is too slow/has too little memory to figure out the first digit that is divisible by all the numbers [1..20[
09:27:54 <Muad_Dib> so that what i meant with including the world (state-of-the-universe)
09:27:54 <tessier_> Muad_Dib: Because the file might not always return the same contents?
09:28:02 <Muad_Dib> indeed
09:28:10 <tessier_> That makes sense...
09:28:15 <SyntaxNinja> shapr: my road trip? been back > a week. it was good.
09:28:18 <Philippa> tessier_: bingo. It effectively needs the state of the file (and by extension for all IO generally, the state of the entire universe) as a parameter
09:28:35 <Philippa> now, consider this little program:
09:28:42 <SyntaxNinja> shapr: for some reason, we had a bunch of folks from my school here in portland over the weekend, all coincidentally, so we had some parties :)
09:29:36 <Philippa> \world -> let universeA = frig world, universeB = screw world in (if (good universeA) then universeA else universeB)
09:29:49 <Philippa> (fill in your own values of frig, screw and good)
09:30:12 <Philippa> that program runs two parallel universes. We can't do that with our computers...
09:30:23 <Philippa> bit of a problem, yes?
09:30:25 <shapr> aww
09:30:31 <Muad_Dib> screw world = replace [(linux -> windows),(haskell -> lisp)]
09:30:43 <Beelsebob> lol
09:31:21 <wagle> so just create two universes, and run them in parallel.  whats the problem.  [note: wagle only skimmed the scrollback]
09:31:25 <Beelsebob> good world = world `contains` MacOS && world `contains` Haskell
09:31:45 <tessier_> When you say two universes do you mean two real physical universes or two threads to run simultaneously?
09:31:52 <Philippa> tessier_: the former
09:32:18 <tessier_> What does the function good do in your above example?
09:32:25 <Philippa> it's a predicate
09:32:27 <tessier_> You have two universes and what are you checking for?
09:32:29 <Philippa> good :: World -> Bool
09:32:35 <tessier_> ah
09:32:36 <Philippa> don't care
09:32:42 <Muad_Dib> tessier_: it was just an example from Philippai
09:32:48 <Muad_Dib> why we dont want  functions including worlds :)
09:32:50 <Philippa> just "do I like this version of events?"
09:32:59 <shapr> Does call-by-need guarantee that only one thunk is 'needed' at a time? Intuitively I think yes, does that sound right?
09:33:28 <monochrom> I don't know what "at a time" means.
09:33:37 <shapr> Can a call ever need to eval two thunks at the same time? I can't think of any way it could.
09:33:40 <wagle> huh..  sounds interesting.  i hope i can find this when i get back
09:34:40 <shapr> I'm reading the GHC SMP paper, and it has a point where thread A is eval'ing a thunk, and thread B needs the value of that thunk.
09:34:42 <Philippa> tessier_: to prevent this duplication, we wrap the World up in a structure that prevents its duplication - that structure's the IO monad, which conceptually is just a fancy variation of a State monad with state :: World
09:35:14 <shapr> Thread B blocks until A is done, but I wonder, could B instead look for another possible thunk it could eval?
09:35:15 <Speck> [x | x <- [1..], test [1..20] x]     where test makes sure that x is divisible by all elements of the list runs FOREVER on my machine
09:35:28 <Speck> *evenly divisible
09:35:41 <monochrom> Ah, probably not.
09:36:00 <poetix> shapr: Call-by-need is lazy call-by-name (it says here: TaPL p. 57) - each call is a redex reduction, a replacement of one term by the value returned by a thunk - so one term at a time, I guess...
09:36:03 <Speck> (and not just because it's an infinite list... I get no results)
09:36:07 <Beelsebob> of course it does... it's trying every item in the infinite list of naturals
09:36:11 <shapr> I think that cbn means that there can only be one outstanding thunk at any time.
09:36:27 <Speck> if I test [1..10] I get a bunch of results really fast
09:36:28 <Beelsebob> m'kay, that is odd
09:36:41 <Speck> so either the first number is really high or somethings screwy
09:36:50 <tessier_> I still don't see why it would try to duplicate the world.
09:37:07 <Philippa> tessier_: the let statement does that
09:37:31 <Philippa> it uses "world" twice, generating two different universes (universeA, universeB) in the process
09:37:38 <shapr> poetix: Can you think of a term that will have two different but equal thunks to eval at the same time?
09:37:44 <tessier_> Philippa: So...don't do that! :)
09:37:52 <shapr> Actually, I probably can think of some.
09:37:59 <Philippa> tessier_: so prevent that from happening. We're not lispers here
09:38:12 <tessier_> What does lisp have to do with anything?
09:38:24 <bourbaki> tessier_: did you check out the links i gave you?
09:38:42 <shapr> For example, (const 1 2 + const 1 3) has two different but equal thunks to eval.
09:38:54 <shapr> Food, bbl
09:39:17 <Muad_Dib> lisp doesnt have to do anything with anything, thats the problem :P
09:39:57 <Philippa> if you're lucky, in lisp your program would crash with a failure-to-split-universe error. If you're unlucky, it'd try to actually do it
09:40:01 <poetix> shapr: Given that order of evaluation doesn't matter, surely any function with more than one argument has a choice of which to call on first...?
09:40:18 <Philippa> either way, that's worse than being able to do everything that's valid and nothing that's invalid, which is what the IO monad gives you
09:40:31 <Philippa> shit, you could write asm in the IO monad given the write IO actions
09:40:34 <Philippa> *right
09:40:48 <tessier_> Philippa: And to think people were worried about high energy physicists creating a singularity or something which would destroy the universe when really it's those darn lispers...
09:41:05 <tessier_> Of course if the general public heard about this they would demand the nuking of San Francisco
09:42:23 <tessier_> bourbaki: realtimerendering etc?
09:42:34 <bourbaki> tessier_: yep
09:42:53 <bourbaki> who was it again who wrote this fluid solver in haskell again?
09:43:01 <bourbaki> someone posted a video in here some time back
09:43:41 <tessier_> bourbaki: Yes, I did. Pretty cool. It'll be a while before I'm really up to playing with that stuff though.
09:43:43 * poetix demands the nuking of San Francisco, just to be on the safe side
09:43:59 <Philippa> tessier_: I'm surprised the "Moral Majority" haven't demanded that already
09:44:38 <Muad_Dib> well, whats wrong with San Francisco?
09:46:01 <Speck> could someone run this to see if it returns any results?   [x | x <- [1..], all ((==) 0) (map (mod x) [1..20])]
09:46:40 <jlouis> lispers claim again and again that the order of evaluation doesn't matter for any real programs
09:46:43 <jlouis> hehe
09:46:56 <Speck> replacing [1..20] with [1..10] returns the correct results (quickly), but [1..20] is perhaps too intensive for my coLinux setup
09:47:00 <jlouis> I disagree
09:47:53 <Igloo> It's going to have to get up to at least 9699690, Speck
09:48:09 <monochrom> Speck if you even bump 10 up to 11 you get significant slowdown already.
09:48:33 <Speck> maybe there's a better algorithm
09:48:43 <monochrom> Think of the mathematical significance of what the program is searching.  Then you'll understand why it takes time.
09:48:44 <Muad_Dib> there probably is one
09:48:48 <Muad_Dib> since this is just brute force
09:48:50 <Speck> my math skillz are poor
09:49:36 <Speck> I guess I could skip by 20
09:49:47 <monochrom> You are asking for something divisible by 1, 2, ... 20.  The first answer may be near 20!.  It will take time to even count up from 1 to that.
09:50:43 <monochrom> head [x | x <- [1..], all ((==) 0) (map (mod x) [1..20])]
09:50:56 <monochrom> That will just give the first answer.  No infinity.
09:51:16 <Speck> true, but it will still take time
09:51:50 <Igloo> It's equal to map (* lcm [1..20]) [1..]
09:51:50 <monochrom> If the answer is N then the program has to take O(N) time because it is a for loop from 1 to N quite simply.
09:51:53 <jlouis> you can of course rule 4, 8, 16 out
09:52:00 <Igloo> so you just need to find a decent lcm implementation  :-)
09:52:01 <monochrom> Ah lcm yes!
09:52:03 <jlouis> and 9
09:52:18 <Igloo> Although you can probably do that more intelligently given you know the input is [1..n]
09:52:32 <monochrom> @type foldl1
09:52:34 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
09:52:46 <monochrom> @eval foldl1 lcm [1..20]
09:52:47 <lambdabot> (line 1, column 15):
09:52:47 <lambdabot> unexpected "."
09:52:47 <lambdabot> expecting simple term
09:53:00 <monochrom> @eval [1..20]
09:53:02 <lambdabot> (line 1, column 4):
09:53:02 <lambdabot> unexpected "."
09:53:02 <lambdabot> expecting simple term
09:53:18 <Speck> snap, I think I found it by skipping by 20
09:53:23 <monochrom> @eval foldl1 lcm [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
09:53:25 <lambdabot> unbound variable: foldl1
09:53:50 <Speck> haha, yes I found it!
09:53:54 <jlouis> Prelude> foldl1 lcm [1..20]
09:53:54 <jlouis> 232792560
09:54:23 <Speck> of course that was much faster
09:54:49 <monochrom> @eval foldl (+) 0 [1,2]
09:54:51 <lambdabot> (line 1, column 8):
09:54:51 <lambdabot> unexpected "+"
09:54:51 <lambdabot> expecting simple term
09:55:01 <monochrom> This is extremely broken.
09:55:07 <Igloo> You want @plugs
09:55:12 <monochrom> Ah!  Sorry.
09:55:23 <monochrom> @plugs foldr1 lcm [1..20]
09:55:26 <lambdabot> 232792560
09:55:27 * Speck is 2% genius for mathschallenge!
09:55:53 <jlouis> in general n * 232792560 is the infinite list you want
09:56:23 <Speck> thanks everyone, now I know about lcm
09:56:46 <monochrom> [ n * foldr1 lcm [1..20] | n <- [1..] ]   heh heh heh
09:57:31 <monochrom> or foldl1
09:57:47 <monochrom> @plugs foldl'
09:57:49 <lambdabot> <Plugins.Eval>:1:
09:57:49 <lambdabot>   No instance for (Show ((a -> b -> a) -> a -> [b] -> a))
09:57:49 <lambdabot>   arising from use of `show'
09:57:57 <monochrom> Ah!
10:04:50 <tessier_> Muad_Dib: So from these pdf slides you sent me it looks like a monad takes a world and returns a world.
10:05:04 <tessier_> But on the backend it is reading IO and writing IO to/from the real world
10:05:43 <TFK> Excersize 2 complete!
10:06:46 <Muad_Dib> tessier_: the world thing is only there for intuition
10:06:56 <Muad_Dib> it is not really there
10:07:02 <tessier_> hmm
10:07:46 <Beelsebob> hahaha... A few years ago a psychic in florida sued a MRI facility. Her claim was that the MRI had robbed her of her psychic abilities.
10:07:57 <Beelsebob> According to her lawyer, "She had no idea this would happen."
10:08:16 <TFK> A Russian astrologer sued NASA as well.
10:08:28 <TFK> Nothing new there...
10:08:32 <Beelsebob> yeh... that's where this came up
10:08:48 <TFK> I believe Uri Geller sued a bunch of people (and either lost or withdrew his lawsuits).
10:09:07 <Beelsebob> quite frankly... go the russians... the americans deserve their pants sued off
10:09:15 <Beelsebob> they do it to everyone else anywoy
10:09:15 <tessier_> A big problem is that I'm just not getting a lot of this mathematical notation
10:09:19 <TFK> Crazy people do the funniest things.
10:09:41 <Beelsebob> strange... funny people do the craziest things
10:11:41 <basti_> back
10:11:52 <Beelsebob> front
10:14:36 <tessier_> side
10:16:01 <TFK> Excersize 3 complete!
10:16:42 <Beelsebob> may I offer both woo, and yay
10:17:30 <TFK> How much?
10:17:41 <Beelsebob> A small amount
10:19:41 <TFK> An mzero?
10:20:34 <TFK> Well, I've even improved Excersize 2.
10:21:11 * Beelsebob wonders why his not connection is being so lame
10:23:53 <Oejet> Hej, Lemmih.
10:24:03 <Lemmih> Hejsa, Oejet (:
10:25:43 <TFK> MMm, Oejet, Ð¿Ñ€Ð¸Ð²ÐµÑ‚ :-)
10:26:28 <tessier_> Beelsebob: Sometimes I have a not connection too
10:26:34 * Lemmih has yearned 1000 dkk by clearing a garden this weekend.
10:26:47 <tessier_> dkk?
10:26:48 <Beelsebob> heh... yeh, unfortunately, this is meant to be a 100MB/s connection
10:26:50 <tessier_> kroners?
10:26:57 <Lemmih> tessier_: Yep.
10:26:57 <Beelsebob> and a net connection at that
10:27:03 <tessier_> Lemmih: Wow, good guess. :)
10:27:05 <basti_> whats a dkk in euro?
10:27:48 <Lemmih> 1000 dkk == 134 euro
10:28:02 <basti_> i c
10:28:12 <basti_> how long did that take?
10:28:45 <basti_> 6 hours?
10:28:52 <Lemmih> 10 work hours over one and a half day.
10:29:07 <basti_> hmm
10:29:11 <basti_> still good for manual work :)
10:30:04 <Lemmih> I even got a bit tanned.
10:30:11 <Oejet> TFK: ÐºÐ°Ðº Ð´ÐµÐ»Ð°?
10:30:12 <basti_> :)
10:30:35 <TFK> Oejet, Ð²ÑÑ‘ Ð² Ð¿Ð¾Ñ€ÑÐ´ÐºÐµ. Ð Ñƒ Ñ‚ÐµÐ±Ñ?
10:30:58 * Oejet is hauling books at a school which needs its book deposit moved.
10:31:56 <TFK> Moved to your neighbourhood? ;-)
10:32:51 <dcoutts> juhp, cheers for updating the gtk2hs FC4 rpms :-)
10:32:55 <Oejet> Nah, just moved between different floors at the school.  We are four people working since thursday.
10:38:24 <TFK> Oh, so you are taking part in the moving procedure.
10:39:31 <Oejet> TFK: Thus the use of the term "hauling". :-)
10:40:13 <TFK> Do I look like an English-speaking person? :-/
10:40:54 * TFK pokes Excersize 4 with a stick
10:42:35 <Oejet> Ñ‚Ñ„Ðº, Ñ…Ð¾Ñ€Ð¾ÑˆÐ¾ ÑÐ¿Ð°ÑÐ¸Ð±Ð¾.
10:43:07 <Oejet> Phew, that was a lot of key searching. :-/
10:44:43 <TFK> So, you're still studying Russian, I gather?
10:45:33 <Oejet> TFK: Level two begins after the summer break, and I plan to attend.
10:45:47 <TFK> w00t! :-D
10:53:27 <TFK> How I "constrict" polymoprhic functions to some one instance? I have parent :: (MonadPlus m) => Sheep -> m Sheep, but what happens if I want to use it in the context of Maybe or List?
10:53:57 <TFK> (I want to do it on a case-by-case basis, not change the type of the actual definition.)
10:59:20 <TFK> Well, using it in context helps.
11:00:09 <TFK> Guess I solved completed all those funky excersizes! Now to compare answers...
11:13:30 * Beelsebob discovers that Safari renders pages lazily
11:14:30 <TFK> http://hbin.dyndns.org/pastebin/66.html <--- question included in the code. Please answer ^_^
11:15:28 <TFK> AAM gave a much better answer, it seems.
11:16:25 <musasabi> TFK: it works because "parents" always returns a list.
11:16:52 <TFK> musasabi, yes, but in the definition of grandparent I use 'parent', not 'parents'
11:18:04 <TFK> It works if I substitute parent for parents, which would make sense, but why does it work the other way around?
11:18:44 <monochrom> It comes down to type-checking "map parent (parent s)"
11:19:48 <TFK> Yes, but it appears to pass the type-check!
11:20:12 <Beelsebob> yes... because you're applying map to a list
11:20:15 <monochrom> what would be the most general type of "map parent (parent s)" ?
11:20:17 <musasabi> TFK: it will have the type [m Sheep]
11:20:41 <monochrom> Ask the computer.
11:20:51 <TFK> musasabi, the result of map, yes. But map takes a list as its second argument, but parent s is not necessarily a list.
11:20:58 * TFK is on it
11:23:46 <musasabi> TFK: "map parent (parent s)", "parents s" will be [Sheep], and parent has the type "(MonadPlus m) => Sheep -> m Sheep" so the map will be: map :: ((MonadPlus m) => Sheep -> m Sheep) -> [Sheep] -> [m Sheep] (with m taken into the outside context)
11:24:23 <musasabi> TFK: try ":t map parent" in ghci.
11:24:38 <TFK> I can't seem to properly load the file in question into GHCi :-/
11:25:16 <TFK> So map forces the second parent call to assume the List type.
11:25:51 <monochrom> YES!  YOUR EYES ARE FINALLY OPEN!
11:26:06 <TFK> You could've said so in the beginning.
11:26:08 <TFK> ;-)
11:26:27 <monochrom> I did ask the guiding question.
11:27:06 <monochrom> No eloquence of mine could replace you seeing it with your own eyes.
11:27:26 <TFK> My question was, "since when did parent s return a list?" and the answer was "since map overloaded the second call and forced it to return a list."
11:27:39 <TFK> Simplicity > eloquence ;-)
11:28:29 <axiom> hi, sry for dumb question: what is the comment sign in haskell?
11:28:38 <TFK> --
11:28:39 <Beelsebob> --
11:28:41 <axiom> thx
11:28:42 <dcoutts> -- this is a single line comment
11:28:44 <Beelsebob> or {- -}
11:28:48 <TFK> Or, for multiline comments, {- foo -}
11:28:54 <Beelsebob> note... there must be a space after --
11:29:04 <axiom> thank you
11:29:06 <TFK> Why?
11:29:09 <monochrom> No, now that you're in a convinced state, you no longer know that the answer would be non-simple and non-convincing to the previous you.
11:29:22 <Beelsebob> TFK: because anfthing else can be overloaded
11:29:32 <Beelsebob> (--|) = (+)
11:29:42 <jlouis> shapr: now with fixes and actually tested/working code
11:29:55 <TFK> Well, it just compiled.
11:30:06 <dcoutts> TFK, it's not essential but if you write "--*" for example it'll get interpreted as an operator
11:30:28 <TFK> Ah. Shucks.
11:32:54 <monochrom> True, I could say "map parent" forces its argument "parent s :: [Sheep]"
11:33:40 <TFK> Forces the second argument, but doesn't force the first.
11:33:57 <monochrom> Still it is a greater experience to be nudged towards the answer than to be told the answer.
11:34:09 <musasabi> Can one create an isInstanceOfClass operator in Haskell? e.g. to have a class that shows things that have Show defined for them and "?" for other cases?
11:34:53 <TFK> monochrom, there were two key points: (1) a call got overloaded "silently" and (2) one call got overloaded, the other one didn't.
11:35:59 <monochrom> Yes.  There is no monomorphism restriction in this setting.
11:37:34 <monochrom> It would suck if one use of == in the program as Int->Int->Bool causes all other occurences of == in the same program to take on that same type.
11:38:19 <TFK> Well, I don't really know the internals of the typing system.
11:38:54 <TFK> Although, it clears up slowly :-)
11:39:07 <monochrom> No, don't worry about the internals.  Do worry about the externals.
11:39:45 <monochrom> The external is just like performing a resolution proof.
11:39:58 <TFK> I'm familiar somewhat with the symptoms, but not their causes.
11:40:11 <TFK> Define "resolution proof"
11:40:37 <monochrom> a method of writing proofs by unification.  unification is a fancy term for matching.
11:41:05 <TFK> "writing proofs"?
11:41:29 <monochrom> You may have two axioms: 2::Int,  (==)::a->a->Bool
11:41:57 <monochrom> You can ask the type of x in 2+x.
11:42:54 <monochrom> To do that you match the Int of 2 with the a of (==).  The only thing you can do is to say "aha so a=Int".  This process is called unification.
11:43:18 <monochrom> So you deduce that x::Int is required.
11:43:27 <TFK> Don't you mean (+) ?
11:43:47 <monochrom> Err yuck.  Yeah.  Change + to == please.
11:44:22 <monochrom> The method of proving things by applying unification to axioms repeatedly is called resolution.
11:44:35 <TFK> So, (+) :: (Num a) => a -> a -> a
11:44:57 <monochrom> I guess I'll stick with == throughout.  The type of 2==x etc.
11:44:59 <TFK> Aha...
11:45:36 <TFK> still, x can be any number. 2.0, for example.
11:45:44 <TFK> Aren't those called Integrals in Haskell?
11:46:01 <monochrom> Yeah I have simplified the story.
11:46:19 <monochrom> 2 is overloaded, too.
11:46:21 <TFK> So, it's  all quite complicated :-/
11:46:33 <TFK> Anyhow, it kinda works, so that's not a big problem (yet) :-)
11:48:04 <TFK> A general question: how often do people write their own, custom monads?
11:48:19 <monochrom> Not too often.
11:48:21 <astrolabe> LOL  I asked that yesterday
11:48:40 <monochrom> Already a lot of different monads covering different uses.
11:49:09 <TFK> AAM showcases 9, but I assume that there's way more than that in the stdlib, right?
11:49:25 <monochrom> To further reduce the incentive for writing a new one, there is a library for combining different monads (some restrictions apply) in case you need combined features.
11:49:51 <TFK> So these are the mythical monad combinators. AAM covers those, too :-/
11:50:57 <TFK> Well, I'm almost through with Part I! Yuppie! And now, shower!
11:53:35 <monochrom> Most of the time you just use a canned one.  If that doesn't help, sometimes you can just write glue code to glue two or three together.  Very seldom do you need to write from scratch.
11:55:21 <monochrom> See Control.Monad in ghc or equivalent.  99% of known applications of monads is covered.
11:56:48 <monochrom> Another 0.9% is covered by Text.ParserCombinators.Parsec :)
12:23:06 <Itkovian> evening
12:23:11 <Beelsebob> evening
12:25:30 <basti_> re
12:27:33 <andersca> shapr?
12:37:52 <basti_> anyone!?
12:37:59 <smott> hm
12:38:02 <Beelsebob> what?
12:38:12 <basti_> ah just wanted to check if people are alive
12:38:41 <Beelsebob> nearly
12:38:43 <smott> how am i supposed to pass around lots of state without it being a pain to modify it each time
12:38:47 <Beelsebob> I think I'll be undead in 10 days time
12:38:55 <andersca> shapr: http://www.coolabah.com/sweden/youknow.html
12:39:00 <Beelsebob> with the state monad?
12:39:14 <smott> oh, monads :(
12:39:28 <Beelsebob> also... if you want to do that... rethink your algorithm
12:39:43 <Beelsebob> there's usually an alternative that doesn't need mutations of states
12:39:59 <smott> well it's a game...
12:40:18 <smott> with lots of state, and its modification
12:40:21 <Beelsebob> hmm... probably best done with a monad then
12:40:29 <Beelsebob> :/
12:40:40 <Beelsebob> or... a big field
12:41:04 <Beelsebob> that you thread through your functions
12:41:24 <smott> i thought nesting stuff in data declarations would work but now i have to write functions to get/set each bit
12:41:45 <Beelsebob> or functions that patern match it out
12:41:53 <Beelsebob> which can be nice and can be nasty
12:42:03 * Beelsebob sits around emailing itunes500@apple.com
12:42:03 <smott> right now it's pretty nasty
12:42:40 <Beelsebob> fields would probably be your best option, if you're wanting to avoid monads
12:42:44 <Beelsebob> (wise IMHO)
12:42:59 <smott> what are fields?
12:43:23 <Beelsebob> essentially records
12:43:35 * Beelsebob goes in hunt of some good sample code
12:45:18 <Beelsebob> is there a pastebox anywhere about?
12:45:45 <smott> http://paste.lisp.org/new/haskell
12:47:01 <lisppaste2> beelsebob pasted "Jam" at http://paste.lisp.org/display/9661
12:47:21 <Beelsebob> that's a reasonable example
12:48:06 <smott> oh yeah, that's basically what i'm doing now
12:48:26 <Beelsebob> ah, okay... I think that's as neat as you get
12:49:45 <Beelsebob> I should perhaps split that call up a bit
12:49:49 <Beelsebob> for it is silly
12:50:23 <Beelsebob> ... and muchly scheme like
12:53:36 <smott> this might work. i don't know, i'll just have to try. thanks
12:53:48 <aheller> does the state monad require the use (let alone understanding) of fundeps?
12:54:16 <Beelsebob> buh?
12:54:30 * Beelsebob shows how much I use monads *g*
12:54:57 <aheller> :)
12:55:32 <aheller> I keep seeing examples which use the random number generator and use newtype to get things done.
12:56:18 <Beelsebob> yeh... I tend to have a wrapper that (if necessary generates a random seed), and does all the IO
12:56:26 <Beelsebob> and then all the rest of the program is pure
12:56:49 <Beelsebob> I will usually have at most 2 monadic functions in any app
12:56:58 <aheller> indeed; I'm being a little stubborn in wanting to understand the code I'm using while at the same time not wanting to go on to fundeps until I understand monads ;)
12:58:21 <Beelsebob> heh... I do that too
13:00:27 <monochrom> the state monad does not require fundeps.
13:00:34 * Beelsebob wonders why the top 50 widgets section on apple.com has 6 widgets in
13:01:46 <aheller> monochrom: could you refer me to a good example of one off the top of your head?
13:01:58 <aheller> I may have just missed it on google.
13:08:45 <monochrom> I like http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
13:09:31 <monochrom> Also I wrote http://www.cs.utoronto.ca/~trebla/fp/ see lecture 12
13:10:15 <aheller> on my way, thanks!
13:16:17 <shapr> alrighty now
13:18:42 <shapr> yargh!
13:19:11 <poetix> shapr: Stubbed yr toe?
13:19:58 <TFK> Hmm. Is there a demand for a GUI frontend to GHCi?
13:20:16 <awarth> hello all
13:20:27 <TFK> hi ho!
13:20:32 <smott> doesn't anyone think accessing data in a C-struct like fassion (struct1.struct2.member) would be convenient?
13:20:53 * poetix is a reformed deconstructionist
13:20:55 <Speck> What would the structs be?
13:21:01 <smott> records i guess
13:21:17 <shapr> hiya awarth
13:21:20 <Speck> named fields?
13:21:41 <shapr> smott: It'd be cool if that automatically let me generate accessors to bitfield structures.
13:21:59 <poetix> I guess you want a syntax transformation from foo.bar.baz to baz (bar foo)
13:22:31 <Speck> function composition is similar (except backwards)
13:22:35 <poetix> (baz . bar) foo
13:22:47 <TFK> aheller, I've been reading All About Monads ( http://www.nomaware.com/monads/html/index.html ) and it's pretty good, provided you know anything up to monads. It also has an explanation of the State monad, although it uses random number generators :-/
13:23:09 <poetix> It was said of Ginger Rogers that she had to do everything Fred Astaire did, only in high heels, and backwards...
13:23:11 <aheller> TFK: the straw which caused me to bother others :)
13:23:13 <Speck> I think All About Monads could be improved by adding simpler example code.
13:23:15 <awarth> here's a question about hashtables, i'm wondering if anyone may be able to help... Data.Hashtable uses the IO monad: this means you can't use Hashtable in transactions (STM). Do you guys know if there's something I'm missing? Am I going to implement my own hashtable if I'm going to try to use it with STM?
13:23:20 <TFK> ah, heh
13:23:31 <TFK> So you don't like All About Monads, Part I?
13:23:46 <poetix> awarth: Monad Transformers might help there
13:24:14 <Speck> I like part 1. I was talking more specifically about part... I guess it was 3 with the examples for each monad in 98
13:24:23 <awarth> poetix: do you have any links I can take a look at to get a little more info on monad transformers?
13:24:43 <aheller> I'm just muddling around, waiting for the giant monad stick to smack me into enlightenment.  I was just hoping not to have to worry about fundeps until after I felt comfortable with monads.  it may not be possible.
13:25:03 <Speck> autrijus says that fundeps are simple
13:25:26 <Speck> not that I understand them :-P
13:25:45 <TFK> Speck, that would be Part 2 (Part 3 talks about combinators and transformers and stuff o_O), and I'm not sure that they list all the monads.
13:26:00 <TFK> What are fundeps?
13:26:09 <poetix> awarth: I think the nomaware tutorial covers them in part iii
13:26:09 <Muad_Dib> functional dependencies?
13:26:16 <Speck> good question :-)
13:26:17 <aheller> so I have read.
13:26:21 <TFK> What are functional dependencies?
13:26:28 <awarth> poetix: thanks, i'll have a look.
13:26:50 <Speck> I haven't seen a very tutorial-oriented explanation of fundeps. The only thing that pops out is in the ghc user guide
13:26:55 <TFK> aheller, anyhoo, it is a good idea to be familiar with monads. Part 1 does this pretty gently, with the Maybe monad and sheep-cloning experiments ;-)
13:27:06 <aheller> Yeah; I ran through that.
13:27:18 <Speck> sheep cloning was a funny example; I liked it a lot
13:27:35 <TFK> What is enlightment in regards to monads anyway? After all, isn't every monad different?
13:27:47 <TFK> So you have to grok it one  by one. No?
13:28:15 <Speck> my enlightenment was that a monad is anything but concrete. knowing that something is a monad isn't anywhere near enough information to know what it does or how it is to be used.
13:28:18 <monochrom> you can handwave.
13:28:22 <aheller> So far as I'm concerned, things eventually just make sense to me, or never do.  I'm looking for the equivalent of muscle memory with them before I move on.
13:28:23 <poetix> The monad laws mean that
13:28:28 <poetix> oops
13:28:45 * poetix was going to say what the monad laws meant, but had a fuzzy moment
13:29:07 <Speck> I know the third one is associativity (or whatever that principle is called in math)
13:29:14 <poetix> Monads...notions of computation...Wadler...blether...
13:29:23 <Speck> (a+b) + c == a + (b + c)
13:29:29 <TFK> Well, I can now say more or less what monads do, technically. But the question is formulated wrongly, I think. It's like classes - saying that something is a class doesn't really say much.
13:29:49 <monochrom> A C++ student would not ask "so what is meant by + ?"  note that + can be overloaded at will.
13:30:23 <monochrom> A monad simply means a data type that overloads "return" and ">>=".
13:30:26 <poetix> Monads allow you to express the structure of computations in various ways - sometimes it's sequencing, sometimes it's backtracking, sometimes it's threaded state, but it all has to do with the environment your computations take place in
13:30:44 <monochrom> There are of course some expectations of the overloader.
13:30:48 <TFK> monochrom, and possibly fail, and maybe other functions I don't remember.
13:30:57 <jlouis> monochrom: yes, but >>= has to be associative and there has to be an id monad
13:31:02 <jlouis> from left and right
13:31:09 <TFK> id monad?
13:31:09 <jlouis> AFAIR
13:31:23 <monochrom> You expect a+(b+c) = (a+b)+c holds for all overloading.  Similar expectation for >>=
13:31:28 <xs> identity monad is just normal function application.
13:31:31 <jlouis> something which is a neutral element
13:31:48 <TFK> neutral element?
13:31:55 <TFK> mzero in MonadPlus?
13:32:35 <monochrom> You are also allowed to break the expectations.  The compiler can't check.  You have to warn the user.
13:32:55 <monochrom> (Normally you try not to break.)
13:33:07 <Muad_Dib> jlouis: it is supposed to be
13:33:15 <Muad_Dib> jlouis: associativity i mean
13:33:25 <Muad_Dib> but i can perfectly find define it in such a way that it doesnt hold :P
13:33:47 <Muad_Dib> like monochrom says :)
13:34:31 <TFK> Speck, at any case, the formal laws aren't that important. It's (supposed to be) "common sense".
13:34:52 <Speck> monads, being that they are from category theory, definitely fall under the umbrella of "generalized abstract nonsense"
13:35:04 <Speck> the meat of monads, imo, are already in type classes
13:35:25 <TFK> Speck, hehe.
13:35:59 <shapr> I'd call it late binding with definable semantics.
13:36:11 <TFK> I don't know anything about category theory, but again, asking "what are monads good for" will get you (me) the same answer as to the question "what are classes good for".
13:36:28 <shapr> Yeah, abstractions hide complexity.
13:36:31 <monochrom> It is very common to press on the question "so what *is* a monad?" and this is a very hard question to answer.  It is uncommon to ask of C++ "so every time I see a+b I have to look up the class implementation because it *could* be *anything*?" and somehow people call that a non-issue.  There is much double-standard here.
13:36:37 <TFK> shapr, and this is why people tend to stay away from Haskell, it's not English :-/
13:36:50 <shapr> The way I look at it, a monad is a way to turn the significance of a type into a pipeline that does the same thing.
13:37:06 <Muad_Dib> well
13:37:12 * Muad_Dib just likes to type do all the time ;P
13:37:15 <shapr> TFK: I've come up with a simpler explanation recently.
13:37:27 <shapr> Monads are very similar to metaclasses.
13:37:34 <TFK> "What is a monad" has a definitive answer, i.e., "every type class with return and >>= functions which obey some laws".
13:37:45 <TFK> I never did learn metaclasses in Python ^_^;;
13:37:47 <Speck> shapr, perl 6 metaclasses or smalltalk metaclasses?
13:37:53 <TheHunter> monads are means to sequence computational effects.
13:37:55 <shapr> smalltalk metaclasses
13:38:04 <araujo> shapr, please continue :-)
13:38:15 <shapr> TFK: I'll explain metaclasses quick and easy...
13:38:17 <poetix> Unfortunately, Wadler's "notions of computation" is very vague. But it's actually the best description of what monads bring to programming that I know.
13:38:22 <aheller> monochrom: I'm pretty much with you; but '+' is much more natural to me than >>= and return; getting that naturalness with monads is what I was talking about, at lesat.
13:38:52 <monochrom> Perhaps Stroustrup was clever in not introducing typeclasses and not giving a name to classes that overload +.  Lacking a name as a handle, you cannot ask certain hard questions.
13:38:52 <poetix> Dammit, not Wadler
13:38:54 <poetix> Moggi
13:39:11 <lament> monads are evil beasts designed to drive you insane.
13:39:14 <shapr> A class defines the behaviour of an object. A metaclass defines how a class behaves. That is, you can change stuff like inheritance, subclassing, initialization, etc. Is that clear?
13:39:41 <TFK> Kinda.
13:39:42 <shapr> Does everyone understand the idea behind metaclasses now?
13:39:56 <Muad_Dib> shapr is giving us a free lecture :D
13:39:59 <poetix> Monads define how computations proceed: sequentially, with threaded state, with explicit continuations, with nondeterministic semantics
13:40:09 * poetix is butting in unhelpfully, as usual
13:40:17 <TFK> You gotta use English.
13:40:22 <monochrom> Suppose C++ had a way for you to declare that a class that overloads + is called a "monoid".  You would be asking "so what is a monoid, what is all this abstract algebra commutativity shite" all day long just as well.
13:40:33 <shapr> You know how python's OOP and Java's OOP are slighly different? Both of those are metaclass instances, that is, they are each definitions of how 'classes' can behave.
13:41:10 <shapr> So, you can redefine how the 'class' abstraction works with metaclasses.
13:41:27 <lament> "slightly"
13:41:31 <shapr> Monads are just like that, they're an abstraction that you can redefine.
13:41:46 <TFK> Isn't anything?
13:42:08 <poetix> Monads provide a language for expressing meta-computational abstractions
13:42:08 <TFK> *everything
13:42:23 <shapr> Nah, you can't change how classes behave in Python without making new metaclass instances.
13:42:31 <monochrom> So, in Haskell, a data type that overloads +,-,etc is called "Num", and a data type that overloads >>=,return,etc is called "Monad", and the latter is found to be so practically useful that Haskell provides special syntactic sugar support.  That's it.
13:42:33 <poetix> The computation happens "in" the monad
13:42:40 <shapr> But monads are always about changing behaviour.
13:42:58 <TFK> shapr, you can redefine functions. Function is an abstraction, so your point is fuzzy.
13:43:11 <TFK> Polymorphism can be about changing behaviour.
13:43:25 <monochrom> And before you ask "what is a monad" I think you should first ask "what is a num".  You would be surprised how much you assume and how little you know about possible Num's.
13:44:02 <shapr> Function is an abstraction that hides a piece of code under a name. Monad and OOP are abstractions that hide how pieces of code are plugged together.
13:44:03 <TFK> Speck, anyhow, this stuff is only going to go through the fingers, so don't despair! (At least, that's what I tell myself all the time.)
13:44:43 <Muad_Dib> monochrom: "what is a .." questions also can go on for way to long
13:44:47 <Speck> shapr, I think you're giving monads a little too much credit :-P
13:44:49 <Muad_Dib> i mean: what is a house?
13:45:16 <poetix> All the cool kids are using Arrows nowadays anyway
13:45:17 <monochrom> I prefer to discuss what can one do with ___
13:45:23 <shapr> Speck: how so?
13:45:36 <aheller> monochrom: but again, and I don't mean to sound snippy, how much do I know about what >>= means?
13:46:05 <shapr> Software engineering is all about compositionality of code.
13:46:23 <Speck> shapr, well what you said really only applies to monadic code, because pieces of code don't fit together (in that sense) in fp, because your code is just one big function
13:46:25 <TFK> "compositionality"?
13:46:41 <poetix> "ability to be composed"
13:46:48 <shapr> Speck: huh?
13:47:03 <monochrom> ah aheller, you're right on that, we are less familiar with >>= examples than + examples.  Nonetheless my point stands.  The what-is question is overrated and irrelevant.  What-for is more important.
13:47:31 <TheHunter> lemme throw in another random remark: monads are a way to define your own embedded higher-order domain specific lanuage (that shares haskell's types).
13:47:40 * TFK cries
13:47:45 <aheller> :)
13:47:47 <Speck> shapr, I'm clarifying that when you say "abstractinos that hide how pieces of code are plugged together" you mean pieces of monadic code
13:48:09 <Speck> because non-monadic code is (obviously) not plugging together pure code
13:48:18 <Speck> err, not plugged together by monads
13:48:23 <TFK> aheller, well, >>= is a function that takes a value trapped in a monad ("monadic value", or whatever), takes a function that can eat the actually value that is trapped inside the monad, and return a new value trapped in said monad. (Right?)
13:48:30 <Beelsebob> monochrom: actually, what is is *exactly* what's interesting to me
13:48:35 <shapr> OOP plugs pieces of code together in a defined manner also.
13:48:36 <Muad_Dib> liftM
13:48:53 <Muad_Dib> shapr: thats why we have Subject Oriented programming :P
13:49:13 <monochrom> Find a person on the street.  Grill him on "so what is a number?"  All you will get is examples and applications.  You won't get anything of the form "0 := empty set, suc n := ..."
13:49:13 <aheller> TFK: Right; and I will feel 'comfortable' with monads when that is natural to me the way '+' or '<<' is in c++.
13:49:22 <shapr> Manager Oriented Programming is so much more popular!
13:49:38 <Muad_Dib> what is manager oriented programming?
13:49:47 <monochrom> And do we care about what "is" a number?  No, we only care how we can use them and what they achieve.
13:49:58 <poetix> My manager tells me he wants a new feature by midday, and I program it for him.
13:50:04 <shapr> Speck: Anyway, OOP is about being able to predict the behaviour of code after the system has plugged together the pieces for you, right?
13:50:07 <TFK> aheller, you're probably thinking "what is it good for". I have little idea :-/ but the point is that that is the wrong question - it can be good for many things, just like classes. You can use a class to abstract all kinds of things, and same for the monad. What kinds of things? Many kinds of thing. You (me) won't know until you (me) will try ;-)
13:50:16 <Beelsebob> yeh... but ask a guy who has to help people understand numbers
13:50:24 <TFK> aheller, that's the point, it only goes down through the fingers. Did you do Part 1 excersizes?
13:50:28 <Beelsebob> and you're likely to get an in depth explanation
13:50:38 <Speck> shapr, if the benefit of predictability is the ability to reason about the code, then yes
13:50:44 <TFK> shapr, is it?
13:50:50 <monochrom> I think it took each of us 5 years to learn enough about numbers to use them.
13:51:03 <TFK> I don't think that anybody thinks about that kind of stuff. People's reasoning is much more simple.
13:51:05 <poetix> Who was it who said you don't understand mathematics, you get used to it?
13:51:05 <Beelsebob> :? and about 25 to use monads?
13:51:14 <shapr> Right compositionality is "being able to reason about the code both together and apart"
13:51:22 <Beelsebob> heh... someone wise poetix
13:51:24 <aheller> TFK: I'm really interested because it's new and neat and, quite possibly useful.  But mostly the two former.  I have done the exercises, I understand what you've told me.
13:51:27 <monochrom> And that's just for making sense of 45+89!  Wouldn't it be reasonable to expect at least one month for >>= ? :)
13:51:48 <TFK> aheller, we're kinda in the same boat, then ;-)
13:52:01 <poetix> It's actually really hard to learn maths if you insist on understanding everything straight away - often the understanding is only attainable after a lot of "getting used to"
13:52:02 <shapr> Speck: so, um, are we in violent agreement that OOP and Monads are similar abstractions?
13:52:03 <Beelsebob> sounds reasonable... that's about how long it took me to pick it up
13:52:14 <shapr> Where the heck was I going with this discussion anyway?
13:52:24 <poetix> shapr: You're doing great...
13:52:30 <Muad_Dib> to bed i think...
13:52:48 <Beelsebob> heh... *wonders if that's a good plan*
13:52:48 <shapr> hoi hlub
13:52:53 <shapr> Muad_Dib: probably so
13:53:09 * poetix is just starting to absorb Church numerals...
13:53:14 <Speck> shapr, possibly and probably. I was just saying that monads<-->fp are about the same as oop<-->fp in that respect
13:53:34 <shapr> In what respect?
13:53:43 <Beelsebob> what, both monads and OOP are horrible
13:53:44 * Beelsebob ducks
13:53:48 <aheller> church numerals are awesome.
13:53:52 <shapr> poetix: church numerals succ
13:53:56 <Beelsebob> lol
13:53:58 <monochrom> haha
13:53:59 <poetix> shapr: haha
13:54:07 <Beelsebob> no... church numerals pred....
13:54:09 <Beelsebob> no wait...
13:54:17 <Speck> shapr, in that they abstract in equally different ways from fp
13:54:44 <poetix> Church numerals are like polo mints: after a while, you're succing a zero
13:54:51 <shapr> Speck: Ok yeah, we're in violent agreement then. Most people don't seperate monads from fp.
13:55:07 <Beelsebob> thing is... Haskell doesn't actually use church numerals
13:55:36 <poetix> Nobody *uses* Church numerals (do they? maybe in unlambda...)
13:55:48 <Beelsebob> I think lisps do
13:55:53 * Speck packs up his laptop to leave work. later all
13:55:54 * aheller finally find the apropos quote: Bridges would not be safer if only people who knew the proper definition of a real number were allowed to design them.
13:56:00 <shapr> They're handy for type trix
13:56:14 <poetix> shapr: e.g.?
13:56:37 <shapr> I like Speck, perceptive person.
13:57:04 <shapr> I wanna be perceptive one day too!
13:57:21 * shapr tries to learn perception from poetix 
13:57:29 * poetix crosses his eyes
13:59:13 <TFK> It's interesting to see people try to explain monads in a few sentences, it's kinda like programmers trying to explain OOP to someone who never programmed before ;-)
13:59:24 <Beelsebob> mmm... melted yorkie
13:59:45 <TFK> Or maybe a Prolog programmer? o_O
14:00:16 <Beelsebob> hmm no... prolog programmers usually have some idea about other languages
14:00:16 <shapr> TFK: Yeah, I think that's a good comparison.
14:00:32 <TFK> Beelsebob, assume they don't. Haskell is my first FP language o_O
14:00:41 <Beelsebob> :)
14:00:41 <TFK> And Python my first "real" one.
14:00:49 * Beelsebob slaps TFK
14:00:59 <Beelsebob> *Haskell* is your first real one
14:01:02 <shapr> I'm going to publish TMR without my arrows intro and just finish the article when I can.
14:01:11 <TFK> o.o;
14:01:18 <shapr> If that's soon, I'll postscript it into TMR4, otherwise, TMR5
14:01:25 <poetix> shapr: Are there any good suggestions for a special syntax for arrows?
14:01:28 <TFK> Beelsebob, only after I write code that will make me super-rich in it.
14:01:36 <Beelsebob> haha
14:01:40 <musasabi> evening.
14:01:47 <TFK> howdy ho.
14:01:52 <poetix> bon soir
14:01:54 <Beelsebob> you need to buy a mac and start using HOC then
14:02:02 <TFK> Soooo! Is there a demand for a graphical frontend to GHCi, a la WinHugs?
14:02:05 <monochrom> TMR could use a pragmatic introduction to monads.  The name TMR notwithstanding.
14:02:09 <TFK> HOC?
14:02:18 <Beelsebob> Haskell-Objective-C bridge
14:02:28 <shapr> jlouis: Would you create a simple user page with some contact info?
14:02:30 <Beelsebob> lets you write cocoa in Haskell
14:02:33 <TFK> Why would I want to use Objective C? o.o
14:02:39 <shapr> monochrom: quick write it up :-)
14:02:40 <Beelsebob> you wouldn't
14:02:43 <TFK> Ah, good point.
14:02:46 <Beelsebob> that's why you'd use Haskell
14:02:52 <musasabi> Objective C is not bad, but there are better things.
14:02:57 <shapr> poetix: there is a special arrows syntax, I should mention it in my article.
14:03:01 <monochrom> One that is written in the spirit of what I said, i.e., the what-is question is unproductive, self-torture.
14:03:07 <TFK> But, Cocoa doesn't sound portable, so it's a limited demographic, innit?
14:03:08 <Beelsebob> having said that... OC is quite nice... but it's horribly weak
14:03:11 <musasabi> (it is nice as compared to C++ in the OO sense)
14:03:33 <TFK> Nobody wants a GUI for GHCi?... o.o
14:03:53 <monochrom> gui for ghci = eclipse haskell plugin :)
14:04:07 <Beelsebob> TFK: Yeh ... that's the point... if you get it *right* on the Mac you make millions... if you get it right anywhere else you end up competing against lots of people
14:04:17 * poetix is underwhelmed by Eclipse
14:04:20 <Beelsebob> ditto
14:04:41 <aheller> monochrom: I like your method very much, but I really do feel like it needs to give some intuition...  I should stop repeating myself, but I'm eager to read the article :)
14:04:51 * monochrom sends "unlines (repeat "Eclipse")" to poetix.
14:05:09 <Beelsebob> haha
14:05:20 <Beelsebob> that's a type error
14:05:22 <TFK> Beelsebob, hmm, good point.
14:05:24 <poetix> jEdit is a better editor, IMO
14:05:29 <shapr> I can't think of anything useful to say in my editorial...
14:05:31 <Beelsebob> you forgot to quote the quotes :P
14:06:03 <Beelsebob> IMHO SEE is fantastic... but that's ust me
14:06:05 <TFK> Anyhow, I just might start writing a GUI for GHCi, then o.o
14:06:07 * monochrom hates the idea of escapes
14:06:15 <TFK> Down with the dosbox!
14:06:23 <poetix> Beelsebob: SEE?
14:06:28 <Beelsebob> SubEthaEdit
14:06:36 <Beelsebob> www.codingmonkeys.de
14:06:45 <shapr> Ok, I need prepublishing feedback for the TMR4 issue...
14:07:01 <poetix> Oh, that collaborative editor thingy...
14:07:18 <Beelsebob> yeh... it's a stunning editor even when it's not being collaberative
14:07:21 <shapr> http://www.haskell.org/tmrwiki/IssueFour
14:07:26 <Beelsebob> it has everything I need and nothing more
14:07:36 <lispy> what is it?
14:07:45 <Beelsebob> it's an editor
14:07:47 * lispy thinks he walked in on an interesting topic
14:08:01 <Beelsebob> that allows multiple people on the network to edit the same file at the same time
14:08:14 <Beelsebob> it's Ã¼ber neat
14:08:19 * poetix is not allowed to view that page
14:08:34 <Beelsebob> http://www.dusoft.co.uk/freebies.php <-- Haskell mode for it
14:08:47 <TFK> Beelsebob, is the mode good?
14:09:00 <Beelsebob> TFK: You tell me... I wrote it ;)
14:09:02 <lispy> Beelsebob: what is the url or name of the editor?
14:09:13 <Beelsebob> lispy: SubEthaEDIT
14:09:21 <Beelsebob> www.codingmonkeys.de
14:09:28 <shapr> Any obvious flaws or errors in the Fourth issue of TMR?
14:09:36 <shapr> I'd like to know before I send out the announcement.
14:09:39 <musasabi> shapr: maybe how new libraries are popping steadely up (and maybe the need to unify language parser libraries to avoid duplication)
14:09:42 * poetix is reading Wouter's article
14:09:43 <lispy> Beelsebob: ah, okay
14:09:54 <shapr> musasabi: oh, good idea.
14:10:18 <TFK> Beelsebob, WOO! I'll give it a go :-D
14:10:45 <lispy> Beelsebob: it looks like irc
14:10:58 <TFK> Currently I've been using Textpad, which has some shortcomings.
14:11:00 <Beelsebob> TFK: only problem I know of is that data types don't get added to the menu at the top
14:11:14 <Beelsebob> lispy: no... you're editing... not just adding lines
14:11:22 <Beelsebob> you can go fiddle with any bit of the file
14:11:25 <TFK> shapr, "You are not allowed to view this page."
14:11:30 <lispy> Beelsebob: i edit the lines people type sometimes...
14:11:32 <shapr> Which one?
14:11:38 <lispy> Beelsebob: erc lets me do that :)
14:11:39 <TFK> http://www.haskell.org/tmrwiki/IssueFour
14:11:45 <Beelsebob> lispy: that's because you use emacs
14:11:54 <lispy> I'm using ERC Version 5.0.1 $Revision: 1.726.2.3 $ with GNU Emacs 21.3.1 (i386-redhat-linux-gnu, X toolkit, Xaw3d scroll bars, built 2005-02-03)!
14:12:03 <TFK> You don't love me anymore ;_;
14:12:32 <Beelsebob> you gave up on colloquy then?
14:12:55 <shapr> TFK: ok, now try it.
14:13:47 <TFK> WOO!
14:14:00 <lispy> Beelsebob: i'm at work, so the laptop doesn't work here
14:14:08 <lispy> Beelsebob: and perhaps i might, erc has a lot of charm
14:14:13 <Beelsebob> ah... okay... doesn't wori there?
14:14:34 <Beelsebob> s/(.*)i /\1k /
14:15:05 <lispy> Beelsebob: ya, they have a crazy internet setup thingy. I could probably make it work, but I only see connection software for linux and windows...
14:15:25 <Beelsebob> ah... what kind of internet connection is it?
14:16:05 <astrolabe> Excellent, the new TMR
14:16:05 <lispy> they use LEAP or E-something-TLS
14:16:28 <shapr> astrolabe: Can you run through TMR and see if you spot any errors or omissions?
14:16:34 <Beelsebob>  /Applications/Internet Connect
14:16:37 <lispy> for my work computer i had to install some cisco software to authenticate
14:16:41 <Beelsebob> will set up VPNs for you
14:16:50 <astrolabe> I'm about to have a bath, but when I get out, I will.
14:16:55 <shapr> Ok, thanks.
14:16:57 <Beelsebob> probably there's no mac software because you don't need any
14:17:11 <lispy> maybe
14:17:19 <musasabi> Has anyone tried paircoding with SubEthaEdit and the Haskell-mode it adds? Seems quite tasty...
14:17:22 <lispy> either way, i feel weird hooking my personal computre into their network
14:17:31 <shapr> I'm going to disappear and do paying work, so any errors or omissions you guys see in the next few minutes will be appreciated.
14:17:36 <Beelsebob> musasbi: paircoding?
14:17:44 <poetix> In the AG article, penultimate section:  "In essence, a monad describes how sequence computations" is grammatically wobbly
14:17:46 <shapr> pair programming
14:17:49 <Beelsebob> lispy: fair enough
14:18:00 <Beelsebob> oh... yeh... it works really nicely actually
14:18:10 <Beelsebob> you have to establish who's coding though
14:18:45 <Beelsebob> you can even have several people working on several bits in pairs
14:19:05 <poetix> Also /possibly/ inaccurate - notions of sequencing aren't the only notions of computation that monads can implement.
14:19:23 <shapr> musasabi: what about new libs popping up steadily?
14:19:32 <Beelsebob> only annoyance I have with SEE is that it doesn't support proxies, so it doesn't work from behind a big firewall
14:19:58 <TFK> SEE doesn't work under Linux and Windows. Yay.
14:20:04 <poetix> Otherwise: great article, intriguing topic
14:20:07 <Beelsebob> TFK: fraid not :(
14:20:24 <Beelsebob> it came out when bonjour was mac only
14:20:52 <astrolabe> Phillipa is a scream
14:21:33 <musasabi> shapr: e.g. the matrix libs, the coming of a time library.
14:22:23 <shapr> Are those available?
14:22:24 <Beelsebob> TFK: you could probably pretty easily write a linux/win client... the beep protocol is pretty straightforward
14:22:26 <shapr> hmm
14:22:43 <TFK> Beelsebob, all I want is a simple Haskell editor :-/
14:22:51 <poetix> astrolabe: more a stifled *umppphhh!*...
14:22:56 <Beelsebob> ah... fair enough
14:23:10 <Beelsebob> TFK: http://www.apple.com/ibook
14:23:12 <Beelsebob> *g*
14:23:35 <TFK> you won't grin for long. x86 is waiting.
14:23:40 <monochrom> Outlook Express has a fine editor.
14:23:48 <Beelsebob> true... but what differentce does that make
14:23:58 <Beelsebob> I like the OS, not the insides of the box
14:24:14 <monochrom> Imagine an editor that lets you email your Haskell programs to friends!
14:24:28 <Beelsebob> monochrom: no... imagine an email client
14:24:39 <TFK> Imagine the gmail interface.
14:24:53 <astrolabe> Imagine all the people...
14:24:56 <Beelsebob> heh... actually... OS X mail's interface is nicer
14:25:09 <musasabi> shapr: the GSL binding exist and there has been much discussion about the right way to do higher level abstractions.
14:25:20 <shapr> Ah, right
14:27:22 <lispy> ya know, collaborative text editing should be possible with emacs using the multi-tty patches
14:27:23 <shapr> jlouis: Also, I'm not sure I spelled your name perfectly :-)
14:28:07 <lispy> of course it dosen't yet support some of those fancy features like letting you know whos where and claiming which parts, the but the essential functionality that you can build on top of is there
14:28:30 <Beelsebob> yeh
14:28:31 <shapr> emacs already does collab editing several ways.
14:28:53 <lispy> shapr: oh?
14:29:04 <shapr> See the page I started long ago - http://c2.com/cgi/wiki?VirtualPairProgramming
14:29:13 <Beelsebob> the thing about SEE is it does everything nicely, the way I expect things to work... and it doesn't expect me to learn ctrl-x-ctrl-s just to get out of the damn thing
14:29:44 <aheller> lucky that, 'cause it wouldn't work in emacs either :)
14:30:02 <Beelsebob> good point
14:30:04 <Beelsebob> *g*
14:30:14 <Beelsebob> I can't even remember how to exit emacs
14:30:24 <Beelsebob> it must be better than vi
14:30:25 <poetix> ctrl-x ctrl-c
14:30:28 <lispy> shapr: ah, multi-tty improves the emacs server substantially
14:30:39 <aheller> eh, you're comfortable with file->save and file->quit; why not C-x C-s, C-x C-c
14:30:40 <Beelsebob> there's only one combo I remember for vi, and it's :q!
14:31:12 <shapr> hiya ToniEisner
14:31:43 <Beelsebob> I don't like ctrl-x ctrl-s ctrl-x ctrl-c because (a) it's twice as complicated as cmnd-s cmnd-q, and (b) it's not how every other app on my computer behaves
14:31:47 <Beelsebob> consistancy is good
14:31:56 <ToniEisner> Hi
14:32:01 <Beelsebob> lo
14:32:06 <aheller> Beelsebob: Eh.  consistency is consistent.
14:32:34 <Beelsebob> yes... and it stops me having to learn different key combos for every app I use
14:32:53 <Beelsebob> I have a 99.9% chance that cmnd-s cmnd-q will save and exit in *every* app
14:32:55 <shapr> Beelsebob: use diskkey
14:33:14 <Beelsebob> shapr: my point is... I don't have to
14:33:20 <monochrom> voice recognition is the future.
14:33:31 <Beelsebob> heh... that's what bill gates says anyway
14:33:34 <monochrom> "computer, go to emacs, DIE!"
14:33:57 <Beelsebob> personally, I think it's slow and clunky... I'd much rather have brain path recognition
14:34:16 <monochrom> Bill Gates and I read 1984 too much.
14:34:22 <Beelsebob> hehe
14:34:29 <Beelsebob> or watched too much star trek
14:34:31 <SyntaxNinja> is there a open in haskell as powerful as fopen?
14:34:41 <Beelsebob> pink and orange buttons are the way to go!
14:34:49 <Beelsebob> syntax ninja: yes... the FFI
14:34:50 <Beelsebob> *g*
14:35:07 <monochrom> You find a common voice-activated editor in 1984.  Used in all offices.
14:35:19 <lispy> SyntaxNinja: powerful in what way?
14:35:20 <Beelsebob> uhhuh :)
14:35:24 <xs> SyntaxNinja: what's missing?
14:35:42 <Beelsebob> you find a voice activated editor in Macintosh System 1 in 1984 *g*
14:35:56 <monochrom> fopen is not very powerful.
14:36:01 <lament> how does haskell manage to be so pretty and yet so unwieldy?
14:36:15 <monochrom> beauty is unwieldly
14:36:33 <shapr> Seems wieldy to me.
14:36:39 <Beelsebob> because you have to *think* to make a beautiful program
14:36:44 <TFK> Beauty is in the eye of the beholder.
14:36:44 <lispy> lament: those were high priority design goals ;)
14:36:46 <monochrom> In all fairy tales, all beautiful and nice women get jealousy and hatred.
14:37:03 <shapr> lament: How unwieldy?
14:37:07 <lament> lispy: ah :)
14:37:07 <xs> not sleeping beauty.
14:37:20 <SyntaxNinja> when I try to open a block device, it complains that an unknown file type
14:37:25 <musasabi> Why are partially applied type synonyms forbidden in GHC?
14:37:30 <lament> shapr: it just seems so hard to write actual programs in it.
14:37:35 <shapr> lament: For what reason?
14:37:38 <shapr> What's hard?
14:37:54 <Beelsebob> I find it very easy actally
14:37:59 <lispy> SyntaxNinja: but you can open it with fopen?
14:38:06 <SyntaxNinja> yup
14:38:14 <Beelsebob> I tend to build useful haskell programs in a day, and useful O-C apps in a month
14:38:15 <SyntaxNinja> I tried the fdOpen or whatever in System.Posix.IO as well
14:38:19 <xs> lispy: fopen will not stat the file to check that kind of thing. it seems quite crazy to do that..
14:38:21 <lispy> SyntaxNinja: hmm...that does sound like a short coming...
14:38:22 <lament> shapr: the bizarreness.
14:38:39 <lament> bah, nevermind me, i'm just trolling.
14:38:43 <Igloo> I have a feeling it's deliberate - comments in the code might explain why
14:38:53 <SyntaxNinja> Igloo: you're talking about fopen?
14:39:08 <Igloo> Yup
14:39:36 <monochrom> heh comments in ghc explaining why haskell is deliberately unwieldly
14:40:03 <monochrom> -- This is the part for IO monads
14:40:34 <monochrom> -- We deliberately make monads sound scary so as to scare away the C programmers on the street.
14:40:38 <TFK> lament, shame on you.
14:40:43 <Beelsebob> haha
14:40:57 <monochrom> -- Don't want any competition in productive programming!
14:41:08 <SyntaxNinja> and I thought haskell was turing complete...
14:41:19 <Beelsebob> ... it is
14:41:27 * lispy boggles
14:41:35 <shapr> musasabi: Whaddya think? Suggestions for improving the editorial?
14:41:44 <TFK> monochrom, the joke's on Haskell, actually :-(
14:41:52 <lispy> SyntaxNinja: so if you open a block device, how will you write to it?
14:42:02 <lispy> or do you plan on writing...
14:42:10 <SyntaxNinja> lispy: idono... seek to a position and write to it?
14:42:12 <shapr> lament: Seriously though, what's the hard part?
14:42:15 <monochrom> shapr: beg for money... :)
14:42:29 <lispy> SyntaxNinja: may i ask what the goal is?  what are you writing?
14:42:37 <xs> SyntaxNinja: you need to guarantee that you'll write one "block" and read one "block" each time..
14:42:58 <lament> shapr: i'm not sure. I think haskell not being python is the hard part :)
14:42:58 <shapr> Oh, I can add that. "Albert Lai suggested that I beg for money to fund my trip to the Commercial Users of Functional Programing."
14:43:13 <SyntaxNinja> lispy: I've got this binary module for doign binary IO
14:43:20 <monochrom> haha
14:43:29 <shapr> lament: Ah, I know that difficulty. If you keep working at it, enlightenment will happen.
14:43:56 <lispy> SyntaxNinja: uh...you're writing it in haskell?
14:44:07 <lispy> SyntaxNinja: i dunno, this topic confuses me...
14:44:11 * lispy begins to weep
14:44:12 <lament> okay.
14:44:22 <shapr> Anymore TMR comments before I bail out and do some actual work?
14:44:38 <aheller> whereas my problem with python was that it was never enough of haskell.
14:45:13 <TFK> aheller, did you use thy itertools?
14:45:24 <SyntaxNinja> lispy: please, don't cry.
14:45:57 <aheller> TFK: I stopped using python when my perl hating boss quit :)
14:46:05 <lispy> SyntaxNinja: but...but, i'm so confused!
14:46:10 <TFK> aheller, I'll take that as a "no".
14:46:11 <poetix> y'all have seen this before... http://codepoetics.com/poetix/index.php?p=107
14:46:16 <aheller> :)
14:46:17 <TFK> What about generators?
14:46:23 <SyntaxNinja> lispy: what I meant was, please don't cry... here.
14:46:26 <SyntaxNinja> ;)
14:46:29 <lispy> SyntaxNinja: i wish you luck...and would recommend the ffi :)
14:46:51 <SyntaxNinja> lispy: yes, the FFI is becomming increasingly attractive.
14:47:09 <lispy> SyntaxNinja: you've had too much beer if you start dating the API...
14:47:24 <aheller> TFK: I really didn't get into python at all; and got even more turned off when said boss made me remove all my list comprehensions.  I did read something about generators that made my eyes bleed a bit, though.
14:47:32 <poetix> At least the API *lets* you interface with it...
14:47:42 <TFK> aheller, remove list comprehensions?...
14:47:52 <TFK> I'd hate Python as well if I used it like C++.
14:47:56 <SyntaxNinja> lispy: you introduced us...
14:48:12 <monochrom> I didn't know that some people phear list comprehension.
14:48:17 <aheller> TFK: Precisely.
14:49:06 <aheller> The people in my office thought they were too unreadable.
14:49:12 <lispy> SyntaxNinja: i'm just giving a friendly warning.  I've seen it happen...and it's never a good thing.  Stick to humans, that's my advice.
14:49:16 <shapr> Nested list comps can be fun.
14:49:22 <TFK> I'd say that generators and their kin are the best part about Python.
14:50:05 <aheller> shapr: like I said, he made me take them out; he thought they were unreadable :)
14:50:11 <monochrom> python list comprehension is already much more readable than haskell list comprehension
14:50:12 <poetix> shapr: I wanted to write a parser for PHP a while ago, but was put off by the fact that no-one seems to have a grammar for the language...
14:50:27 <musasabi> shapr: looks nice :-)
14:50:28 <poetix> aheller: That is truly tragic
14:50:29 <TFK> aheller, he sucks. Don't listen to him. Python is a good language.
14:50:47 <monochrom> I know various imperatively minded friends who find python list comprehension completely intuitive.
14:50:51 <SyntaxNinja> shapr: more fun than APIs?
14:50:51 <Igloo> I think a parser fo the PHP bit whould be simple enough to write
14:50:54 <aheller> Many people out there like python.  I think it's great that there out there using languages that are Not C (much as i live C).
14:50:58 <Igloo> s/parser/grammar/
14:50:58 <TFK> poetix, Joel Spolsky's FogCreek have an ASP-to-PHP compiler ;-)
14:51:07 <ToniEisner> doe's anybody know if there is irc library for haskell
14:51:11 <lispy> coming from a math bg, list comprehensions (in haskell) are perfect
14:51:14 <poetix> TFK: don't talk to me about Spolsky...
14:51:28 <TFK> poetix, you two are sworn enemies?
14:51:37 <shapr> ToniEisner: check out lament
14:51:42 <lispy> ToniEisner: it may be possible to extract one from the source of lambdabot
14:51:43 <shapr> ToniEisner: um, I meant lambdabot
14:51:47 <ToniEisner> shapr: thks
14:51:58 <lispy> ToniEisner: and if you did, i'm sure people would be greatful
14:52:00 <poetix> TFK: Nothing personal, I just find myself in violent disagreement with his published utterances on a regular basis
14:52:07 <TFK> aheller, ah, so what else do you program in besides C (and Haskell)?
14:52:09 <monochrom> I actually first heard of python list comprehensions from very pragmatic, untheoretical programmers.
14:52:52 <TFK> poetix, I won't talk to you about him, then. That doesn't mean I won't talk to everybody else, though >-)
14:52:53 <aheller> TFK: perl and ruby, at the moment.  My resume exists to catch word searches, but mostly those two lately.
14:52:55 <monochrom> They said "hey mono, this is the best thing since sliced bread, you should check out python!  <list comprehension example>"
14:53:21 <ToniEisner> the also said this about cobol :-)
14:53:26 <TFK> Python had map before LCs.
14:53:28 <ToniEisner> and object cobol
14:53:34 <shapr> I think Spolsky is an idiot.
14:53:42 <TFK> Ooooh.
14:53:46 <TFK> That hurts.
14:53:46 <aheller> oh, and scheme.
14:53:51 * TFK is a Spolsky fanboy
14:53:57 <shapr> I mean, "I rarely find articles by Joel Spolsky that furnish me with useful information"
14:54:07 * shapr salvages some shreds of tact.
14:54:15 <TFK> You must be very smart.
14:54:27 <shapr> I doubt that.
14:54:39 <TFK> Don't be humble now.
14:54:41 <shapr> I think I just learn from my mistakes.
14:54:42 <TFK> ;-)
14:54:45 <hlub>  /quit bye
14:54:50 <shapr> bye hlub
14:55:10 <poetix> Spolsky is all about hanging on to your mistakes, and making supposedly pragmatic excuses for them
14:55:16 <TFK> I wouldn't say that LCs are the best thing. But they probably look cooler than anything else.
14:55:26 <TFK> poetix, ah, you mean like Apps Hungarian?
14:55:46 <poetix> Or that whole thing about never getting rid of legacy code, no matter how crufty
14:56:05 <TFK> He never quite said that.
14:56:36 <shapr> Aanyways... tell me if you find any TMR errors! I'm off to announce this issue and then work.
14:57:06 <monochrom> shapr should not worry about errors.
14:57:38 <monochrom> afterall, more errors in this issue is good.  It means next issue he has more to write in the editorial.
14:57:57 <poetix> TFK: no, I suppose he didn't quite. But he urges a very conservative approach...
14:58:10 <monochrom> (He won't have to fill the space with "Albert suggested me to beg for money" :) )
14:58:12 * poetix thinks "productivity" means deleting lines of code
14:58:51 <TFK> His point seems to be backed by empirical evidence.
15:00:14 <poetix> That's his stance: the "real world" is on his side. But there are other ways - the corner cases he says legacy code addresses should be triangulated by test cases, then you can rewrite aggressively with confidence that you're not losing anything
15:00:52 * lstna spends so much time biting his tongue here...
15:01:35 <poetix> anyhow, gotta go now - bedtime...
15:01:52 <TFK> He ran away :-/
15:02:03 <lstna> he does that.
15:02:15 <TFK> Frequently?
15:02:16 * Beelsebob farts
15:03:07 <TFK> You are not a very nice person.
15:03:21 <Beelsebob> did I ever say I was?
15:03:25 <xs> ze english
15:04:13 * lstna thinks he's got as much from this forum as he is likely to get. See ya TFK. Good luck with your conversion to the one true way.
15:04:29 <TFK> Pardon?
15:04:36 <Beelsebob> ???
15:04:49 <Beelsebob> The True Source?
15:04:57 <Beelsebob> only the dark one can weild that
15:04:58 <TFK> You mean you got sick on #haskell because... he left.
15:05:09 <TFK> wb o.o
15:05:28 <TFK> He did not just leave again.
15:05:38 <Beelsebob> he did
15:05:55 <TFK> :-/
15:06:00 <TFK> Shalom.
15:06:10 <pipe> ma kore
15:06:30 <Beelsebob> hmm... I need something to do that (a) gets words written and (b) doesn't involve writing
15:06:39 <lispy> heh
15:06:46 <lispy> Beelsebob: hire a note taker?
15:06:49 <xs> type >>= printer
15:07:01 <TFK> stam, medarim al haha'im.
15:07:04 <TFK> *medabrim
15:07:25 <pipe> TFK: ok... how old did you say you were?
15:07:33 <TFK> 18.
15:07:46 <pipe> haha'im is what for you?
15:08:00 <TFK> Ale and whenches, of course.
15:08:19 <Beelsebob> sounds like a good plan to me
15:12:03 <TFK> It's funny, because on rereading http://www.joelonsoftware.com/articles/fog0000000069.html , poetix'es rant doesn't seem relevant.
15:19:14 <MachinShin> hey all
15:19:36 <TFK> hello
15:28:14 <Beelsebob> tbh... I think that article is rubbish
15:28:33 <Beelsebob> starting from scratch is bad iff you were not the original coder
15:28:56 <Beelsebob> because the original coder knows all the idiosyncracies, and can design around them second time
15:30:04 <TFK> "It's important to remember that when you start from scratch there is absolutely no reason to believe that you are going to do a better job than you did the first time. First of all, you probably don't even have the same programming team that worked on version one, so you don't actually have "more experience". You're just going to make most of the old mistakes again, and introduce some new problems that weren't in the original version."
15:30:54 <Beelsebob> that only really applies if you're writing a big monolithic piece of crap
15:31:04 <TFK> There's no way you're gonna keep that much information in your head. And you shouldn't.
15:31:34 <Beelsebob> if you wrote it modularly, there's probably a lot of good stuff you keep, and there's a few things you know are crap, and you know why they're crap
15:31:50 <TFK> He is talking exactly about rewriting *entire* products from scratch, without maintaining the old code-base.
15:32:04 <Beelsebob> yeh... okay... that is perhaps a silly idea
15:32:20 <TFK> "Even fairly major architectural changes can be done without throwing away the code."
15:32:28 <Beelsebob> but the idea that you shouldn't refactor the 2 page long function with `hairy bits' is just silly
15:32:36 <TFK> He never said that.
15:32:47 <esap> The good thing about writing from scratch is that you can change your earlier decisions. The bad thing about it is the same.
15:33:01 <Beelsebob> Why is it a mess?
15:33:01 <Beelsebob> "Well," they say, "look at this function. It is two pages long! None of this stuff belongs in there! I don't know what half of these API calls are for."
15:33:04 <Beelsebob> ...
15:33:25 <Beelsebob> he's saying all the hairs are bug fixes
15:33:37 <Beelsebob> which most likely they are...
15:33:44 <Beelsebob> but that doesn't stop them not belonging there
15:33:56 <TFK> esap, that is a problem indeed. But the real mistake is in stopping maintaining the old code.
15:34:15 <esap> Probably the hairs are the error handling, the cases that you never realize are there before you run into them.
15:34:26 <TFK> esap, this is why he gave the Microsoft example to contrast Netscape. They may have taken a bit hit financially, but not strategically.
15:34:38 * esap hasn't seen the whole discussion.
15:35:10 <TFK> esap, some people seem to have the wrong impressions about what Joel Spolsky said.
15:36:22 <TFK> Beelsebob, he never said to not refactor it. He said that *rewriting* it is bad. Refactoring is not rewriting.
15:36:29 <Beelsebob> true
15:36:45 <Beelsebob> but... it's often better to rewrite than to refactor
15:36:59 <Beelsebob> admittedly... in small chunks only
15:37:10 <TFK> Yes, if you grok that code perfectly.
15:37:22 <TFK> If you know what each and every line does.
15:37:27 <Beelsebob> yep
15:37:37 <TFK> ...but many won't bother.
15:41:18 <esap> The problem with refactoring is that it's hard to explain to managers why you're spending that time on a code without producing any new functionality. This problem unfortunately is not there for rewrites, even if they take lots more time :-)
15:41:57 <TFK> "But throwing away the whole program is a dangerous folly, and if Netscape actually had some adult supervision with software industry experience, they might not have shot themselves in the foot so badly."
15:42:37 <TFK> I recall that another thing that Joel said, is that not having a (former) programmer as your/the companies' boss is dangerous.
15:42:55 <Beelsebob> heh
15:42:57 <Beelsebob> yes
15:43:10 <monochrom> Having a former programmer as boss is also dangerous.
15:43:13 <Beelsebob> that kind of boss has no concept of what is possible
15:43:54 <monochrom> The former programmer says "cobol had always worked when I was your age, what's with this new python thingie!"
15:43:57 <TFK> monochrom, what isn't dangerous, then?
15:44:24 <TFK> monochrom, I didn't mean "former" like that :-/
15:44:29 <monochrom> haha
15:44:41 <TFK> I mean that Bill Gates probably doesn't touch any code anymore.
15:44:41 <esap> monochrom: so true. I've seen many examples of that.
15:44:59 <Beelsebob> did he ever?
15:45:04 <Beelsebob> I thought he stole it?
15:45:11 <TFK> Ahahaha.
15:45:45 <monochrom> Bill Gates is fine.  Not too many programmers are as open-minded as Bill Gates though.  Those become old grumpy bosses.
15:46:29 <esap> It takes effort to accept new "cool" stuff as better than what you were accustomed to do.
15:46:30 <TFK> Joel is open-minded ;-)
15:46:38 <astrolabe> I can't access the "Why attribute grammars matter" TMR article.  It says 'You are not allowed to view this page'.
15:46:54 <TFK> That's always true.
15:47:16 <TFK> astrolabe, I'd try to contact shapr, he's the boss.
15:47:18 <monochrom> So, I'm saying, by the law of the excluded middle, we're doomed.
15:47:47 <astrolabe> TFK: Thanks, will do
15:49:54 <monochrom> You can probably prove that Bill Gates steals a lot of ideas from others.  Notice that this also proves that he is not one of those "I had always used goto, who needs while-loops" people.
15:50:36 <lispy> monochrom: it's true tho, goto is more general
15:50:49 <monochrom> yeah yeah, continuation etc.
15:50:55 <lispy> screw high-level loop constructs, haskell doesn't have them
15:51:10 <TFK> lispy, Haskell doesn't have goto either.
15:51:17 <lispy> TFK: sssh....
15:51:31 <monochrom> How about: "I had always used on ... goto ..., who needs polymorphism!" hahaha
15:51:32 <lispy> does it have CPS?
15:51:40 <TFK> AFAIK, altair basic was original. DOS was purchased, not "stolen". What else... GUI OS? Was done before Windows. Did the Linux WMs "steal" ideas?
15:51:40 <esap> goto is a high-level control construct [think coroutines, very similar to "goto"].
15:52:15 <lispy> free software always steals ideas
15:52:21 <lispy> and borrows code from each other
15:52:30 <lispy> not sure it's a good source of analogies
15:52:39 <Beelsebob> TFK: Everyone stole ideas except for apple and Xerox
15:52:44 <Beelsebob> (apple bought them)
15:52:49 <monochrom> haha
15:53:05 <lispy> don't for get smalltalk
15:53:12 <Beelsebob> hehe
15:53:13 <TFK> MS did some nasty things, and probably will continue doing them, but they're just easiest to hate.
15:53:15 <lispy> or was smalltalk xerox?
15:53:27 <TFK> Bell Labs, maybe?
15:53:33 <Beelsebob> lispy: the GUI?
15:53:37 <Beelsebob> Xerox PARC
15:54:01 <lispy> i think of smalltalk as the whole model-view-controller thing, good idea for expressing GUI
15:54:17 <lispy> and that was probably xerox parc
15:54:18 <Beelsebob> uhhuh
15:54:25 <Beelsebob> don't know about that
15:54:35 * esap thinks of MVC as _the_ link between OO and FP.
15:54:48 <lispy> MVC?
15:54:53 <Beelsebob> All the cocoa books credit NeXT and all the NoXT books credit smalltalx
15:54:55 <esap> Model-View-Controller
15:54:56 <lispy> oh n/m
15:54:58 <lispy> yeah i'm slow :)
15:55:27 <Beelsebob> hmm... I appear to have invented an OS... go NoXT go!
15:55:37 <lispy> esap: could you elaborate on that point?  sounds interesting...
15:56:17 <esap> lispy: in MVC, M and V are often reusable, so they use OO methodology [just name the file names with the data]. The controller is the algorithm, that is, FP design.
15:56:33 <lispy> oh, okay
15:56:43 <Beelsebob> hmm... that's not the way I've always thought about it
15:56:46 <lispy> esap: yeah, that is a nice way of thinking of it.
15:56:58 <Beelsebob> I've always thought that the Model worked in a very FP way
15:57:09 <Beelsebob> you tend to chuck it a request and get back some data
15:57:34 <Beelsebob> the controller tended to act as an interface between an OO view and an FP model
15:58:42 <esap> hmm.. I'm not quite sure how the model would be done in FP way. How are the files named? [This is my method of finding out what kind of design is used, if the file names denote data, then it's OO. If they denote actions/verbs, then it's FP]
15:59:57 <Beelsebob> hmm, perhaps we have slightly differing interpretations of MVC... the way I've always learned it, the M doesn't *have* to be file based
16:00:03 <Beelsebob> it is merely a backend
16:00:14 <Beelsebob> thot you can say *give me this interesting fact*
16:00:27 <Beelsebob> and it does the processing and gives you back an answer
16:01:11 <esap> Normally what I would do in a model is to represent the reality, e.g. have things like "account", "balance sheet" as individual parts of model [each described in separate file]
16:01:43 <lispy> esap: i think it would be interesting to play with MVC where you make the rule that M-V must be OO, and C can only be either a database or FP
16:01:49 <Beelsebob> indeed - but I wouldn't necessarily be doing it in files
16:02:33 <lispy> or maybe i don't fully understand the distinction between the three, perhaps M should be the database...
16:02:38 <Beelsebob> perhaps I'm just overly pampered with CoreData
16:03:21 <esap> beelsebob: What do you mean with "file-based"? I'm talking about source code file names.
16:03:30 <Beelsebob> ah... okay...
16:03:34 <Beelsebob> why do they matter then?
16:03:48 <lispy> they matter in the way comments matter
16:03:50 <esap> beelsebob: Because you can distinguish different styles of code by looking at the file names.
16:04:11 <Beelsebob> yeh... so... your model as you say will typically be something like `account'
16:04:44 <Beelsebob> which is something *very* functional... you say, give me the ballance, and it goes away and does a calculation and gives you an answer
16:04:44 * esap nods. That denotes it's OO design.
16:05:18 <lispy> Beelsebob: but isn't the 'give me the balance' defined in C?
16:05:20 <esap> Because then each source code file corresponds to some piece of data, and it can then only contain things that relate to that data.
16:05:27 <Beelsebob> lispy: not if it's me
16:05:35 <lispy> just the interface to it is given by the model
16:05:49 <Beelsebob> esap: true... but in the same way, I define files like VSExp in my haskell
16:05:56 <Beelsebob> that defines the VSExp data type
16:06:02 <Beelsebob> and a lot of stuff relating to it
16:06:43 <esap> beelsebob: ok, maybe I need to be more accurate. OO design is described when the file names describe data *stored* somewhere, not data *communicated* somewhere.
16:07:08 <Beelsebob> m'kay
16:07:13 <TFK> A GUI for GHCi, anyone?
16:07:21 <Beelsebob> heh... why?
16:07:36 <Beelsebob> I have a UI... I type an expression, it gets evaluated
16:07:41 <Beelsebob> that's good enough for me
16:07:47 <TFK> Because it's nicer than a dosbox?...
16:08:04 <lispy> TFK: well, you can run GHCI inside of emacs, does that count ;)
16:08:11 <TFK> No o.o
16:08:20 <Beelsebob> this is why I don't use emacs
16:08:21 * esap just runs ghci in xterm.
16:08:27 <TFK> I'm just wondering is there is a demand for such a GUI.
16:08:30 <Beelsebob> itas a god damn text editor!
16:08:35 <TFK> Becuase I'm probably going to write one o.o
16:08:53 <Beelsebob> what I would like is a GUI for hmake
16:09:03 <TFK> Dunno what it is.
16:09:06 <lispy> TFK: well, what would you want the gui to do that the commandline interface doesn't?  Or what would make it worth while..
16:09:40 <TFK> lispy, for me? Bigger fonts, nicer colours, easier copy/paste facilities.
16:09:55 <lispy> i mean, maybe there should be a window devoted to types, you type something and it always gives just the type.  No evaluation.
16:09:56 <Beelsebob> don't you mean a nice editor then?
16:10:15 <Beelsebob> hmm, that would be a cool feature
16:10:26 <TFK> Beelsebob, that's a thought, if it's hooked into GHCi.
16:10:30 <lispy> TFK: okay, syntax highlighting i can see.
16:10:34 <TFK> But making a frontend looks easier than an IDE.
16:10:54 <TFK> I'm not going to do syntax highlighting. The shell isn't useful enough to warrant one, I think.
16:10:57 <lispy> TFK: something that helps me locate type errors would be very nice
16:11:11 <Beelsebob> hmm... isn't SPJ working on integrating GHC with VS anyway?
16:11:16 <TFK> lispy, how would I do that? Parse the error messages?
16:11:24 <TFK> I don't have VS.
16:11:41 <TFK> Beelsebob, say, how does GTK fare on OS X?
16:12:13 <lispy> TFK: you'd probably have to hook into the type checker.  I read a paper by some peeps that were doing that.  They had a HTML haskell code browser that ran a modified type checker to help you locate type errors at the source.
16:12:14 <Beelsebob> TFK: as well as anything else.
16:12:29 <lispy> Beelsebob: that's not really fair
16:12:43 <TFK> lispy, sounds like more of an IDE thing. I'll just start from a simple front end :-)
16:12:47 <Beelsebob> but in general, no mac user is going to use something that doesn't fit *exactly* with the rest of Mac OS
16:12:55 <lispy> TFK: it's getting better, but it doesn't _yet_ run as a native gui thingy.  Requires X11 support still
16:13:05 <Beelsebob> it's just one of the OS's little odities, the users really like the UI consistant
16:13:08 <TFK> Beelsebob, so you wouldn't object to a frontend in GTK (if you were ever to use one in the first place)?
16:13:24 <TFK> lispy, yup, I've heard of that. Are they planning to fix it, though?
16:13:31 <Beelsebob> TFK: You'd be hard pushed to extract me from SEE and a terminal window
16:13:42 <lispy> TFK: well, yeah, but it's not easy dealing with propreitary software
16:14:03 <TFK> Beelsebob, same for Windows, but I have my issues with wx.
16:14:25 <Beelsebob> heh... doesn't everyone
16:14:26 <TFK> wx doesn't seem to have too much trouble.
16:14:39 <Beelsebob> IMHO... trying to make a GUI app cross platform is a silly idea
16:14:48 <Beelsebob> sure.. make the backend cross platform
16:14:55 <Beelsebob> but code a different GUI for each one
16:15:02 <Beelsebob> nad respect how that platform works
16:15:09 <TFK> Beelsebob, needless code duplication.
16:15:14 <TFK> wx seems to respect that.
16:15:32 <TFK> Beelsebob, I was talking about the general idea of using GTK apps.
16:15:33 <Beelsebob> TFK: from a programmer's perspective yes... from a users perspective... *needed* chandes
16:15:39 * Beelsebob changes
16:15:53 <Beelsebob> and no... wx doesn't respect the odities of platforms...
16:16:01 <Beelsebob> you still get the same UI everywhere
16:16:05 <TFK> Suppose there was a supa-1337 Haskell IDE in GTK. Would you use that?
16:16:22 <Beelsebob> don't know... depends what was 1337 about it
16:16:22 <lispy> TFK: emacs already comes in GTK ;)
16:16:30 <Beelsebob> rofl
16:16:33 <lament> note how many programs (MS office for one) even have completely different icons on OS X
16:16:43 <lament> just to fit better with the rest of the OS
16:16:43 <TFK> Beelsebob, it's supa-1337. All the features you want.
16:16:52 <esap> I think having a cross-platform GUI work differently with all oddities of different platforms requires complete rewrite of the application logic.
16:16:53 <TFK> Or at least better than what you have right now.
16:17:02 <lament> Beelsebob's right, you just can't "copy" an interface onto another platform and expect it to fit
16:17:02 <Beelsebob> TFK: You mean SEE and Terminal, but with an inconsistant UI?
16:17:13 <lispy> TFK: i don't know if i'd use it.  One of my editor requirements is running on a terminal.
16:17:32 <TFK> lispy, come on man, you know what I mean :-/
16:17:41 <lispy> TFK: i am being serious tho
16:17:42 <Beelsebob> as lament says... Word 2k4 and 2k3 are *completely* different
16:17:47 <Speck> I just started using emacs for haskell, how do I load the file in ghci?
16:17:53 <Speck> the buffer, rather
16:17:59 <lispy> TFK: so, here's what to do. Don't listen to me, because i'm not in your target audience.
16:18:10 <Beelsebob> yeh... nor me
16:18:12 <Beelsebob> *g*
16:18:31 <TFK> Provided you're OK with using a GUI and provided you'd be interested in using that software, would you decide to not use that software if it is written in GTK (and you are a non-Gnome user)?
16:18:32 <lispy> Speck: have you turned on haskell mode and ghci?
16:18:38 <TFK> Would you prefer Qt or wx?
16:18:50 <Speck> lispy, haskell mode appears to be working (syntax hilighting)
16:18:54 <Beelsebob> TFK: Cocoa :)
16:19:00 <lispy> Speck: if you have try C-h m <RET>  that will tell you a bunch of key bindings
16:19:01 <TFK> lispy, I realize that you are serious, but as you said, different target audience :-)
16:19:06 <lament> TFK: if there was something 1337 that required me to run X11, i probably wouldn't use it
16:19:15 <TFK> Beelsebob, I take that as a "no" to all alternatives, then?
16:19:16 <lament> TFK: i hate using X11 in os x
16:19:24 <Beelsebob> TFK: yep :)
16:19:34 <TFK> OS X users are picky :-/
16:19:38 <Beelsebob> very
16:19:41 <lament> yep :)
16:19:45 <lispy> Speck: also, it should be in the menus
16:19:51 <TFK> lament, how about Qt? (Is Qt free for OS X?)
16:19:57 <Speck> I see the menus, but I don't know how to use them :-P
16:20:00 <lispy> Speck: i usually use :r, so i don't remember the binding, maybe C-c C-l
16:20:03 <TFK> Although that's irrelevant, since there are no Haskell bindings in Qt :-/
16:20:07 <Beelsebob> TFK: Yes... but it *still* doesn't behave in the exact same way
16:20:10 <lament> oh yeah, menus are another thing for X11 apps :)
16:20:13 <lispy> Speck: that's what most of the language environments use for loading
16:20:19 <lament> all programs have their menus on top of the screen
16:20:28 <lament> except X11 programs, which have their menu inside the program window
16:20:35 <lament> how unsexy is that
16:20:55 <TFK> A total turnoff...
16:21:02 <Beelsebob> note... top of the screen is better... you can easily ram your mouse to the top... you have to aim to hit a window edge
16:21:20 <lament> i'm not arguing for relative advantages of menu placement types
16:21:23 <Beelsebob> hehe
16:21:24 <TFK> Oh yes, I totally see the light now.
16:21:32 <lament> just saying that X11 would be inconsistent
16:21:37 <Beelsebob> TFK: the poit is that it's different
16:21:40 <lispy> Speck: another thing to try when you get stumped in emacs is, C-h a, that lets you search through all the functions currently loaded, so you can search for 'load', then search in that buffer for 'haskell'
16:21:44 <TFK> Yes, I realize the point.
16:21:52 <Speck> ic
16:21:53 <Beelsebob> and OS X users will not like you for doing something needlessly different
16:22:05 <TFK> I was just wondering how repulsive would that be, exactly. And how much more functionality did the software need to pack to overcome the repulsive factor.
16:22:48 <Beelsebob> the thing is I don't *want* more functionality... more functionality would just add bloat for me
16:22:58 <lament> Beelsebob: speaking of ramming the mouse, isn't it dumb how you can't fully maximize windows in OS X
16:23:02 <TFK> It's not needless by far. I have my reasons for using GTK both as a programmer, and a user (at least under Windows). And it seems that most of Haskell devs use Linux anyway, so that's a non-issue for them.
16:23:03 <Beelsebob> (which isn't to say there aren't people who don't want it)
16:23:05 <lament> to take up the entire screen (except for the dock)
16:23:20 <TFK> Beelsebob, that depends on how said functionality is incorporated.
16:23:35 <lament> when you maximize a window with a scrollbar, when you move mouse as far to the right as it can go, you move it past the scrollbar
16:23:41 <lament> OS X sucks :(
16:23:46 <Beelsebob> lament: no... it lets you multitask... windows become as big as they need to be to efficiently display data
16:24:04 <Beelsebob> anyway... just alt-click the plus
16:24:12 <lispy> TFK: i think your plan is great.  Go ahead with it, then if osx users complain, ask them to help by writing a GUI.  Or here's another idea.  Use hs-plugins to make the gui pluggable.
16:24:20 <lament> Beelsebob: oh! i didn't know that
16:24:22 <TFK> I don't have a plan o.o;;
16:24:30 <TFK> I was just wondering for the far, far future.
16:24:35 <Beelsebob> doesn't work everywhere
16:24:45 <Beelsebob> ... some apps don't like their windows that big
16:24:45 <lispy> TFK: your plan was to start out simple and implement something you would use.  That's where good software starts.
16:24:51 <Beelsebob> but it usually does
16:24:52 <lament> wait no, it doesn't work in Firefox
16:24:56 <TFK> You're right there ;-)
16:24:58 <lament> which is the main case in point
16:25:03 <Beelsebob> true
16:25:06 <TFK> And thanks for the encouragement. So I'll go through with it.
16:25:13 <lispy> TFK: cool
16:25:15 <Beelsebob> personally... I prefer the zoom behaviour
16:25:26 <Beelsebob> but it should be an option
16:25:29 <lament> i want my firefox to be as big as it can
16:25:41 <lament> same with my IRC terminal
16:25:43 <Beelsebob> does it not remember the window size you set?
16:25:51 <Beelsebob> (like all cocoa apps)
16:25:53 <lament> it does
16:25:56 <TFK> lament, get a vacuum pump o_O
16:26:02 <lament> but then, sometimes i accidentally move it :)
16:26:06 <Beelsebob> heh
16:26:12 <lament> in windows, you can't move a maximized window
16:26:18 <lament> and it's grea.t
16:26:24 <Beelsebob> heh... I hate that
16:26:27 <lament> in KDE you can do that too.
16:26:32 <Beelsebob> it *really* irritates me
16:26:33 <lament> and it's also great.
16:26:58 <lament> with Expose, there's little reason not to have all your windows fully maximized.
16:27:07 <Beelsebob> actually no
16:27:19 <Beelsebob> Expose does a really bad layout if your windows are maximised
16:27:31 <Beelsebob> it works much better if their all different sizes
16:27:44 <Beelsebob> because it maintains the relative sizes of windows
16:28:51 <Beelsebob> I think it's a case of agree to disagree... the option *should* be there
16:29:37 <lament> yep yep
16:29:46 <lament> but alas
16:29:54 <Beelsebob> ohhh... the current iTunes free song is really good
16:29:59 <lament> Macs in general are'nt exactly about customizability
16:30:13 <lament> there're more like, "there's exactly one way to do it"
16:30:15 <lament> *they're
16:30:16 <Beelsebob> okay... that was really randow
16:30:30 <Beelsebob> load up BBC news... and get presented by a pair of tits
16:30:30 <lament> also itunes is a horrible monster :)
16:30:41 <Beelsebob> iTunes fucking rocks my world
16:30:44 <wilx> Hmmm.
16:31:02 <lament> The best music player is still ogg123
16:32:10 <Beelsebob> I've never even heard of it
16:32:30 <Beelsebob> I just like being able to plug in iPod and forget about it
16:32:52 <lament> ogg123 is the command line ogg player without any functionality :)
16:33:14 <Beelsebob> heh... sounds like I would like it... iff I used ogg for anything
16:33:19 * TFK roots for mplayer
16:33:32 * TFK goes to sleep
16:33:32 <lament> well, i guess you're screwed because you have an ipod and those things dont' even know ogg
16:33:35 <Beelsebob> unfortunately AAC is a bit more standard
16:35:55 <Beelsebob> damn it... the iTunes free song just made me buy an album
16:36:15 <lament> eww.
16:36:20 <lament> you buy music!?
16:36:23 <Beelsebob> I don't think the 1 and 2g iPods ore even powerful enough to decode ogg
16:36:30 <lament> you're a true mac user :)
16:36:59 <Beelsebob> well... It kinda comes from expecting people to pay for my software
16:37:10 <Beelsebob> if I do that... then really I should buy software too
16:37:25 <Beelsebob> and then it makes little sense to say music is any different
16:37:31 * Pseudonym has never paid for Beelsebob's software
16:37:39 <Pseudonym> But I hardly consider myself a pirate.
16:37:52 <Beelsebob> yeh... but do you use my software?
16:37:58 <Pseudonym> Not that I'm aware of.
16:38:03 <Beelsebob> there you go then
16:38:08 <Beelsebob> I buy software I use
16:38:15 <Beelsebob> I buy music I listen to
16:38:29 <lispy> i don't, good software should be free
16:38:43 <Beelsebob> it *should*... but isn't necessarily
16:38:57 <lispy> (I mean the source freedoms BTW)
16:39:03 <Beelsebob> indeed
16:39:15 <lament> doesn't itunes sell music with horrible DRM?
16:39:22 <lispy> but having said that i own a copy of XP and now OS X
16:39:29 <Beelsebob> no... it sells it with quite nice DRM actually
16:39:35 <lispy> uh...
16:39:38 <Beelsebob> you can put it on up to 5 computers
16:39:40 <lispy> oxymoron....
16:39:40 <lament> there's no such thing as "nice DRM", i'm afraid
16:39:43 <Beelsebob> and you can burn CDs
16:39:54 <Beelsebob> and re-rip it (which removes the DRM)
16:39:56 <Pseudonym> Sure there is.  There's advisory DRM.
16:39:58 <lament> can i put it on my player? Somehow i doubt it
16:40:04 <Beelsebob> I can
16:40:09 <Pseudonym> Advisory DRM is like a copyright licence.
16:40:11 <lament> I can't
16:40:16 <lament> what format is it in?
16:40:19 <lispy> Pseudonym: can be it a copyleft license?
16:40:25 <Pseudonym> Don't see why not.
16:40:29 <Beelsebob> AAC... that doesn't mean I can't make an ogg
16:40:42 <lament> by burning and reripping?
16:40:42 <Pseudonym> Putting in a bit or a packet which says "please don't copy this" is perfectly reasonable IMO.
16:40:48 <Beelsebob> indeed
16:40:54 <lament> seems pretty dumb
16:40:59 <Beelsebob> why?
16:41:10 <Beelsebob> I burn to a disk image and rip from that
16:41:14 <lament> much much more effort than just pirating the song
16:41:30 <Beelsebob> ah no... but you're the one that's pirating it
16:41:35 <lament> yep :)
16:41:38 <Beelsebob> I have exerted a *lot* less effort
16:42:45 <lament> besides, converting from one lossful format to another is not the greatest thing to do
16:42:50 <Beelsebob> anyway... just at the moment I stand a chance of winning 10 iPods, 10500 free songs, and 4 tickets to see coldplay live (along with flights and hotels)
16:42:59 <Beelsebob> lament: true... which is why I use AAC
16:43:09 <lament> my player doesn't play AAC.
16:43:11 <Beelsebob> and there's nothing to stop you using FLAC or ALC
16:43:21 <Beelsebob> I'm pretty sure it does actually
16:43:23 <lament> I can buy stuff in FLAC?
16:43:26 <Beelsebob> it's just mpeg4
16:43:38 <Beelsebob> no... you can just rerip it into flac
16:43:56 <lament> if it's just mpeg4, how does DRM work?
16:44:36 <Beelsebob> it's encrypted,iTunes knows the public key
16:44:51 <lament> ah, then it's not just mpeg4 - how would my player be able to play it?
16:45:06 <Beelsebob> no... AAC is just mpeg4
16:45:17 * metaperl_vc wonders if he accidentally joined #warezzzz
16:45:19 <lament> oh, so it's not AAC? :)
16:45:20 <Beelsebob> what you buy from the iTMS is encrypted AAC
16:45:25 <lispy> metaperl_vc: yup
16:45:27 <lament> I see.
16:45:29 <metaperl_vc> :)
16:45:35 <Beelsebob> lament is trying to make it so
16:45:37 <Speck> if I have a function of type [a -> a], how do I get a list of the application of those functions against a number, i.e. [a]
16:45:41 <lament> well, my player doesn't play encrypted AAC :(
16:45:46 <lispy> @snoc the new home of #warezzzz
16:45:48 <lambdabot> Unknown command, try @listcommands.
16:45:52 <Igloo> map ($ 4)
16:45:53 <lispy> hmm....
16:45:57 <Beelsebob> spec: zipWith ($)
16:46:00 <lispy> @listcommands
16:46:01 <lambdabot> all-dicts arr babel botsnack code define definitions devils dice
16:46:01 <lambdabot> dict dict-help docs dummy easton echo elements eurohaskell eval fact
16:46:01 <lambdabot> fact-cons fact-delete fact-set fact-snoc fact-update foldoc fortune
16:46:01 <lambdabot> gazetteer get-definition ghc google help hitchcock hoogle index
16:46:01 <lambdabot> jargon karma karma+ karma- kind learn libsrc listchans listcommands
16:46:03 <lambdabot> listmodules lojban moo more paste pl pl-resume plugs pointless
16:46:05 <lambdabot> prelude quote remember resume seen source spell state timein todo
16:46:07 <lambdabot> [3 @more lines]
16:46:16 <lispy> @more
16:46:16 <lambdabot> todo-add topic-cons topic-init topic-null topic-snoc topic-tail
16:46:16 <lambdabot> topic-tell type uptime vera version vixen web1913 where where+ wiki
16:46:16 <lambdabot> wikipedia wn world02 yow
16:46:27 <lament> what does snoc stand for?
16:46:27 <lispy> oh, topic-cons and topic-snoc
16:46:30 <lament> ahhhh
16:46:35 <lispy> cons snoc
16:46:48 <lispy> yeah, it does the reverse...clever eh?
16:46:51 <lament> you lisp freaks
16:46:56 <lispy> er?
16:47:01 <metaperl_vc> Speck: [a -> a] means a function which takes as its sole arguement, a list of functions which take something of type a and returns something as type a... just making sure I understand you
16:47:15 <lispy> lament: i've never heard snoc in a lisp conversation
16:47:27 <lament> lispy: i've never heard cons in a haskell conversation
16:47:31 <Beelsebob> metaperl: I think he wanted [a -> a] -> [a] -> [a]
16:47:43 <lispy> lament: FFIW, i was in a class on haskell when i learned about snoc :)
16:47:59 <lament> hah
16:48:04 <Beelsebob> @type (zipwith ($))
16:48:10 <lambdabot> bzzt
16:48:14 <Beelsebob> really?
16:48:17 <lispy> @hoogle [a->a] -> [a] -> [a]
16:48:18 <lambdabot> Monad.ap :: Monad a => ((a (b -> c)) -> (a b) -> (a c))
16:48:33 <Beelsebob> @hoogle [a -> b] -> [a] -> [b]
16:48:34 <lambdabot> Monad.ap :: Monad a => ((a (b -> c)) -> (a b) -> (a c))
16:48:37 <Beelsebob> bah
16:48:44 <Beelsebob> oh... no, that's good
16:48:49 <Igloo> @type (zipWith ($))
16:48:50 <lambdabot> forall b b1. [b1 -> b] -> [b1] -> [b]
16:49:00 <Beelsebob> oh... chears Igloo
16:49:06 * Beelsebob smacks head
16:49:09 <lispy> what does Monad.ap do?
16:49:16 <Speck> err, I wanted [a->a] -> a -> [a]
16:49:25 <Beelsebob> oh
16:49:42 <lispy> @hoogle [a->a] -> a -> [a]
16:49:43 <lambdabot> Prelude.scanr :: ((a -> b -> b) -> b -> [a] -> [b])
16:49:43 <Beelsebob> map ($ a)
16:49:53 <lispy> heh, hoogle rocks :)
16:50:00 <Beelsebob> yeh... it does
16:50:06 <Speck> oh, I never thought about using $ like that
16:50:07 <Beelsebob> neil mitchel is cool
16:50:09 <lispy> it gives me functions and i have no clue what they do :)
16:50:15 <lament> hahaha
16:50:18 <Beelsebob> haha
16:50:34 <metaperl_vc> can someone explain that? map ($ a)
16:50:34 <Beelsebob> that's why it links you to docs about them on the page
16:50:42 <Speck> it's a section
16:50:48 <lament> @hoogle a -> b -> c -> d -> e
16:50:49 <lispy> @type ($)
16:50:50 <lambdabot> Prelude.undefined :: a
16:50:50 <Speck> think (+ 2)
16:50:50 <lambdabot> forall b a. (a -> b) -> a -> b
16:51:01 <Beelsebob> metaperl map the function that applies things to a, over a list of function
16:51:03 <Beelsebob> +s
16:51:08 <metaperl_vc> (+ 2) is a curried + function expecting one argument for it to fire
16:51:31 <Igloo> lispy: I think if you tried to think of what something with scanr's type could do you could only come up with around 2 reasonable definitions
16:51:31 <lament> @hoogle
16:51:32 <lambdabot> HOOGLE - Haskell API Search
16:52:00 * lament wants to hoogle a->b but is afraid
16:52:06 <jlouis> when shapr comes back, tell him his wish is my command ;)
16:52:07 <Beelsebob> http://www-users.cs.york.ac.uk/~ndm/hoogle/
16:52:14 <Igloo> One of the cool, and surprising, things about types IMO  :-)
16:52:19 <Beelsebob> lament: lambdabot will only give one result
16:52:27 <lament> @hoogle a -> b
16:52:28 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => (a -> b)
16:52:31 <lament> haha
16:52:39 <Beelsebob> lament: use the website
16:52:39 <lament> that's not fun!
16:52:52 <Beelsebob> http://www-users.cs.york.ac.uk/~ndm/cgi-bin/hoogle-cgi?a%20-%3E%20b
16:52:59 <lament> that's fun
16:53:02 <metaperl_vc> oh, so to think of ($ a), I need to think of what is always to the right "$" and that it a function... so we have created a function which expects a as input and we will map across a list of them
16:53:10 <metaperl_vc> I mean left of $
16:53:18 <Beelsebob> yep
16:53:33 <Beelsebob> so each of the functions in the list gets applied to a
16:54:04 <Beelsebob> If neil ever gives me the ssource I'll write XHoogle properly
16:54:53 <TheHunter> darcs get http://www-users.cs.york.ac.uk/~ndm/darcs/hoogle
16:55:21 <Beelsebob> bah... silly bob
16:55:46 <Beelsebob> I should write more of salmon too
16:55:58 <Beelsebob> that will integrate with hoogle quite nicely
16:57:19 <lispy> Igloo: perhaps, i would guess that it curries the first argument with the second and maps it onto the list
16:57:44 <lispy> @plugs scanr (+) 1 [1..4]
16:57:50 <lambdabot> [11,10,8,5,1]
16:58:01 <Beelsebob> ???
16:58:18 <Beelsebob> @plugs scanr (+) 1 [1]
16:58:20 <lambdabot> [2,1]
16:58:32 <Beelsebob> @plugs scanr (+) 1 [2]
16:58:33 <lambdabot> [3,1]
16:58:36 <Beelsebob> odd
16:58:44 <TheHunter> map (foldr (+) 1) $ tails [1..4]
16:58:47 <lispy> not at all what i expected...
16:58:52 <TheHunter> @plugs map (foldr (+) 1) $ tails [1..4]
16:58:54 <lambdabot> [11,10,8,5,1]
16:59:05 <Beelsebob> it takes the second argument and the last item of the list and applies the function, then it takes the penultimate item from the end and the result, and so on. It returns the list of intermediate and final results.
16:59:47 <lispy> i have no idea when i would want that...but the function i described is something i do from time to time
17:00:02 <Beelsebob> heh
17:00:12 <Beelsebob> neither do I... but it's what it does
17:00:18 <Beelsebob> http://www-users.cs.york.ac.uk/~ndm/hoogle/generated/Prelude.f.scanr.htm
17:00:26 <Igloo> Oh, scanl is probably more natural to reason about, actually. the *r's seem a bit wierd when you first meet them I think
17:01:31 <Beelsebob> heh... odd... foldr I find much more natural than foldl
17:02:13 <Igloo> A trivial example of when you might want it (scanl in this case) is if you want to get the list of all factorials, say
17:02:16 <Igloo> @plugs scanl (*) 1 [1..10]
17:02:18 <lambdabot> [1,1,2,6,24,120,720,5040,40320,362880,3628800]
17:02:36 <Igloo> Beelsebob: Did you when you first saw it, though?
17:02:44 <Beelsebob> igloo: yes
17:03:15 <Beelsebob> @plugs scanl (+) 1 [1..10]
17:03:16 <lambdabot> [1,2,4,7,11,16,22,29,37,46,56]
17:03:35 <Beelsebob> hmm... there should be a way of writing fibs with this
17:03:41 <Igloo> Fair enough. I think generally people aren't thinking about the structure of a list the first time they see foldr, so working from left to right applying an operation makes more sense
17:06:21 <Beelsebob> http://news.bbc.co.uk/1/hi/world/europe/4653423.stm
17:08:16 <Philippa> newsflash: if you're going to crossdress, going for "extremely well-endowed" will get you read every time :-)
17:08:21 <Igloo> Oh, nhc98 built
17:08:26 * Igloo pokes it suspiciously
17:08:26 <Beelsebob> :)
17:08:33 <Beelsebob> nhc is nice
17:08:36 <Beelsebob> stop poking it
17:08:45 <egg> ?
17:09:04 <Beelsebob> lo egg
17:09:17 <Beelsebob> sorry for the quip last time you joined... I couldn't resist
17:09:32 <Philippa> you ended up with egg on your face for that one?
17:09:34 <Philippa> (yeah, me either)
17:09:35 * egg builds DHC
17:09:50 <lispy> DHC?
17:09:52 <Beelsebob> philippa: boom boom tish
17:10:49 * egg (yeah just another Dummy Haskell Compiler)
17:11:01 <Beelsebob> another?
17:11:10 <egg> joke -_-
17:11:25 <egg> (cold)
17:11:31 * Beelsebob cold egg?
17:11:34 * Beelsebob eats egg
17:11:37 <Beelsebob> :P
17:11:55 <lispy> hmm..
17:11:59 <Beelsebob> hehe
17:12:05 <lispy> i'm sorry egg, please come back!
17:12:23 * Beelsebob wonders how often he's heard that
17:12:53 <Igloo> Ah, it was gcc 3.4.3 it was failing for people. Maybe it'll work OK with 4.
17:12:57 <Philippa> maybe he just doesn't like guys going down on him
17:13:02 <Beelsebob> igloo: what's that?
17:13:07 <Beelsebob> nhc?
17:13:10 <Igloo> yup
17:13:19 <Beelsebob> are you using v1.18?
17:13:25 <Igloo> yup
17:13:32 <Beelsebob> what's the error?
17:14:09 <Igloo> The problem is the heap being allocated in the top half of the address space, which breaks nhc98's assumptions
17:14:23 <Beelsebob> oh... okay... fair enough
17:14:27 <Beelsebob> never heard of that one
17:14:47 <Beelsebob> I wonder if Tom knows about that in re-writing it
17:15:23 <Igloo> Is Tom a student somehow connected with Malcolm?
17:15:37 <Igloo> Or is he the guy doing hte literate RTS?
17:15:56 <Beelsebob> kindof... he's Colin Runciman's student... he's re-writing nhc to dump a Hat trace from the heap as it goes
17:16:04 <Beelsebob> rather than neading the program transformation
17:16:32 <Igloo> OK...Malcolm said he had a student working on it, so I guess that's him
17:16:37 <Beelsebob> probably
17:16:44 <Igloo> I don't suppose you know when he expects to have it finished do you?
17:17:02 <Beelsebob> I think the last I heard was a month or two... but I wouldn't rely on me
17:17:09 <Beelsebob> I'll ask him again tomorrow
17:17:15 <Igloo> OK, cool, thanks  :-)
17:19:16 <Beelsebob> actually... come to think about it...
17:19:28 <Beelsebob> Malcolm did mention he had an undergrad poking about with nhc
17:19:41 <Beelsebob> it was only in the vaguest of terms though
17:20:09 <Beelsebob> so that may be it too
17:20:35 <Beelsebob> anyway... g'night
17:39:22 <SyntaxNinja> does anyone know how this function from System.IO.Posix is supposed to work? createFile :: FilePath -> FileMode -> IO Fd
17:39:39 <SyntaxNinja> in particular, FileMode is = CMode and I can't find any docs on that.
17:40:33 <SyntaxNinja> like, how do I construct a CMode, no idea.
17:41:16 <Igloo> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System.Posix.Files.html
17:42:06 <SyntaxNinja> Igloo: ahh, thanks
17:48:09 <Speck> @pl \x xs -> any (==0) $ map (mod x) xs
17:48:09 <lambdabot> (any (0 ==) .) . map . mod
17:48:13 <wagle> @index CMode
17:48:14 <lambdabot> System.Posix.Types, System.Posix
17:48:19 <Speck> z0mg...
17:49:03 <Speck> I still can't grok point-free
17:52:15 <Speck> @pl \xs x -> any (0==) $ map (mod x) xs
17:52:16 <lambdabot> (any (0 ==) .) . flip (map . mod)
17:52:23 <Speck> oooh, flippy
17:52:44 <wagle> need to practise like practising a piano
18:18:52 <mugwump> I'm getting compile differences between ghc -O and ghc -O0; any hints for tracking it down?
18:19:47 <Igloo> "compile differences"?
18:20:07 <mugwump> well, quite considerable differences.  one leaves me with an object file and the other a hard compile error :)
18:20:37 <Igloo> What error?
18:21:12 <mugwump> Well, compiling src/Pugs/Embed/Perl5.hs in pugs, it's a compile error in an included C header file
18:21:23 <Igloo> Which one works?
18:21:27 <mugwump> -O0
18:21:33 <Igloo> Try -O -fasm
18:22:32 <mugwump> Igloo++  # worked!
18:22:51 <Igloo> You should still fix the root problem, though
18:23:47 <mugwump> ok, so that option uses the native code generator rather than gcc?
18:23:52 <Igloo> yup
18:25:29 <mugwump> so I should pick over the output of a -C run?
18:27:35 <Igloo> It's probably easiest to cut the files down until you have a tiny test case in which either the problem is obvious or you can file a bug report against something
18:28:51 <dons> @seen juhp
18:28:53 <lambdabot> juhp is in #haskell. Last spoke 10 hours, 52 minutes and 45 seconds
18:28:53 <lambdabot> ago.
18:29:36 <dons> juhp, there's no hs-plugins snapshots atm. only the darcs version
18:35:31 <aheller> so, I'm coming up against my first problems with garbage collection.  I have a file full of characters, and I want the unique ones, so I thought to myself, why not just dump them in a set?
18:36:17 <aheller> but yet I seem to run out of heap...  I feel like laziness should save me, but I'm not sure how, and I was wondering if advice could be had?
18:36:46 <aheller> main = do file <- readFile "file"
18:36:46 <aheller> 	  putStr (show . setToList $ mkSet file)
18:39:01 <Cale> aheller: hmm... what is the file like? That shouldn't be too bad.
18:39:11 <Cale> aheller: perhaps try the new Set interface?
18:39:45 <wagle> how big is the file?  how big is the heap?
18:39:48 <aheller> 1220 lines, 100K
18:40:17 <wagle> which version of which haskell system?
18:40:25 <dons> sounds like a simple space leak
18:40:53 <aheller> hugs of some stripe... trying to figure out how much heap I have...
18:41:13 <aheller> Version November 2003
18:42:15 <aheller> 250K heap.
18:42:30 <dons> 250k?
18:42:43 <aheller> Current settings: +.quR -stglQwkIT -h250000 -p"%s> " -r$$ -c40
18:42:43 <mje> hi, I've noticed that the haskell libraries have a datatype called inductive graph; but what IS and inductive graph?
18:42:45 <mugwump> Igloo: is a minimal test case minimal when it includes â€œ#include "perl.h"â€ ?  ;)
18:42:52 <wagle> 100K chars will take about 500K bytes
18:42:58 <mje> and->an
18:43:07 <wagle> make the heap bigger
18:43:18 <aheller> ah; is that doable inside hugs, do you know?
18:43:37 <aheller> and is there no way to compel laziness to save me?
18:43:45 <dons> mje, check the paper on the fgl library, by erwig
18:43:49 <Igloo> mugwump: If you've removed all the irrelevant lines in perl.h, then yes  :-)
18:44:01 <mugwump> oh great :)
18:44:12 <dons> mje, http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP01
18:44:14 <Cale> I took a 1.5MB text file and did about the same in ghci 6.4, and it worked fine without adjusting any settings.
18:44:14 <aheller> I know there are fewer than 50000 unique characters in the file...
18:44:25 <mje> dons: thanks
18:44:36 <wagle> aheller: unicode?
18:44:43 <aheller> nope.
18:44:47 <wagle> ascii?
18:44:51 <aheller> yeah.
18:44:57 <wagle> 256 unique
18:45:01 <wagle> or 128
18:45:43 <aheller> indeed; certainly much less than 50K, which would push up against my stack, which was why I was wondering if there's a way to rejigger my code so that it got GC'd...
18:46:03 <wagle> could write your own set constructor that accumulates the set while traversing the list, forgetting heads
18:46:04 <dons> do you have ghc installed?
18:46:05 <mugwump> Igloo: ok, so I've got the .hc file down to 811 bytes, but how is it that it doesn't include the file with the problem?
18:46:20 <aheller> dons: yeah, trying it now....
18:46:22 <mugwump> ie, it's missing the #include "perl.h"
18:46:29 <Igloo> eh?
18:46:34 <wagle> ..  or try another set library
18:46:54 * Igloo meant the testcase should be an .hs file rather than .hc, incidentally
18:47:42 <mugwump> well, what I'm trying to do is get gcc's input out of it, so I can look at stripping out everything irrelevant
18:47:54 <mugwump> -C doesn't seem to give me something I can pass to gcc
18:48:16 <aheller> yeah, ghci bitched about using the wrong set impl and then got the result out faster than hugs took to blow its stack.
18:48:24 <aheller> I'm running out of excuses to use ghci, it seems.
18:48:31 <Igloo> If you run ghc -v -keep-tmp-files it'll show you what commands it runs on what files
18:48:46 <Igloo> So you can then repeat the commands on the files it leaves over (in /tmp)
18:48:55 <mugwump> hey that's useful
18:49:05 <wagle> @index mkSet
18:49:06 <lambdabot> Data.Set
18:49:10 <Igloo> Some of the -v output if gcc telling you what subcommands /it/ is running, so you don't need to rerun those by hand
18:49:21 <Igloo> (I think they're all indented by at least 1 space)
18:49:38 <Cale> mkSet is now called fromList, and setToList is now called toList
18:51:32 <aheller> huh.  Thanks alot.
18:51:52 <aheller> Now to make emacs use ghci instead.
18:52:36 <wagle> aheller: use a newer Hugs..  the March 2005 hugs's Data.Set.mkSet shouldnt leak
18:53:03 <aheller> huh.  I wonder where I got mine, then, 'cause I wasn't playing with haskell in 2003...
18:53:46 <wagle> i was using the 2003 one until about a week or two ago...
18:59:19 <wagle> @source Data.Set.mkSet
18:59:20 <lambdabot> lambdabot 3p47, GHC 6.4 (OpenBSD i386)
18:59:20 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:01:08 <dons> there's no '@source'
19:01:56 <wagle> isnt there something that prints the source code?
19:02:14 <dons> @code
19:02:15 <lambdabot> Concurrent.hs: newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)
19:02:22 <dons> but it only prints random code
19:02:34 <wagle> oohh..  useful!  8)
19:02:50 <dons> fun anyway
19:07:17 <aheller> there's no standard Application Layer networking library, is there?
19:07:49 <monochrom> that would require a standard application.
19:07:57 <aheller> ?
19:08:22 <monochrom> If all applications used the same protocol, there would be a standard application layer.
19:08:31 * wagle heard that the great thing about standards was that there were so many to choose from
19:08:33 <aheller> But they do; http :)
19:08:37 * wagle isnt being helpful
19:08:45 <monochrom> Ah, but there is a http library indeed.
19:08:48 <aheller> :)
19:09:17 <monochrom> wagle has a point.  why do you consider http to be more standard than irc?
19:09:19 <wagle> you know about haskell.org?  (specifically http://haskell.org/libraries/)
19:10:07 <aheller> I don't; I was making a joke about how it seems that http is the new UDP.
19:10:14 <monochrom> Aha.
19:10:55 <monochrom> The answer is that all firewalls let through http and nothing else. :)
19:11:14 <aheller> I know.  It just makes me sad.
19:11:36 <aheller> clearly my sense of humor is on a level with my coding ability.
19:11:50 <monochrom> that last one is funny. :)
19:12:13 <aheller> thanks :)
19:13:10 <mugwump> heck, so running -O0 actually drastically changes the way that compilation works
19:15:13 <dons> changes the way compilatin works?
19:15:29 <dons> it turns of optimisations, and enables -fasm
19:16:43 <mugwump> looks to me like -O0 only assembles with gcc, but -O uses gcc for compilation too
19:17:00 <mugwump> based on comparing the output of the -v -keep-tmp-files
19:17:12 <dons> yes. like I said, -fasm is enabled ;)
19:17:23 <dons> -O turns on -fvia-C
19:17:30 <dons> you can use -fvia-C with -Onot, if you like
19:17:41 <mugwump> oh.  duh, ok
19:20:13 <Speck> seems like haskell should have a prime factorization algorithm somewhere
19:20:28 <Speck> just can't find it
19:20:51 * Speck is practicing point-free eloqution
19:21:04 <Speck> elocution, rather
19:22:38 <dons> there's gcd forall a. (Integral a) => a -> a -> a, fwiw
19:22:50 <Pseudonym> http://andrew.bromage.org/darcs/
19:23:19 <dons> @type GHC.Prim.gcdInt#
19:23:20 <lambdabot> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
19:23:23 <dons> ooh. primops :}
19:24:53 <Speck> oro...
19:35:25 <mje> :q
19:35:28 <mje> oopse
19:35:40 <dons> :q!
19:35:59 <Pseudonym> ^X^C
19:37:04 <wagle> ctl-alt-del
20:39:45 <Speck> @pl \xs -> xs == reverse xs
20:39:46 <lambdabot> ap (==) reverse
20:45:48 <Speck> @hoogle [Char] -> Int
20:45:50 <lambdabot> Prelude.length :: ([a] -> Int)
20:45:59 <Speck> @hoogle [Char] -> Num
20:46:00 <lambdabot> List.genericLength :: Integral a => ([b] -> a)
20:46:06 <Speck> :-/
20:46:17 <Speck> oh, read
21:05:38 <Speck> night
21:15:19 <lispy_> anyone around?
21:15:50 <lispy_> i need a network thingy tested real quick.  I'm trying to figure out if port 25 is being blocked...
21:15:57 <lispy_> telnet codersbase.com 25
21:16:05 <lispy_> if it connects let me know
21:16:30 <Pseudonym> telnet: Unable to connect to remote host: Connection refused
21:16:37 <lispy_> i see
21:16:56 <lispy_> i think my ISP started blocking port 25 from *some* ip's without telling anyone
21:16:58 <dons> nmap is good
21:17:10 <Pseudonym> Yeah, but I don't use nmap without permission.
21:17:15 <Pseudonym> Otherwise you'll REALLY get blocked.
21:17:51 <dons> :/
21:18:37 <dons> I only nmap people who nmap me first :}
21:18:52 <Pseudonym> Yeah, I'd say that's implicit permission.
21:18:53 * lispy_ is nmap'ing himself :)
21:19:04 <Pseudonym> I nmap myself, too.
21:19:06 <Pseudonym> Oooer.
21:19:31 * Pseudonym waits for Philippa to make a rude comment
21:19:53 <lispy_> heh
21:20:06 <dons> huh
21:27:00 * lispy_ upgrades his no-ip.com account so he can receive mail on non-standard ports
21:27:05 <lispy_> i'll show my isp! :)
21:27:12 * lispy_ empties his wallet
22:58:04 <Pseudonym> Does anyone know who this is?
22:58:08 <Pseudonym> http://catamorphism.livejournal.com/
23:10:00 <dons> get your steaming hot hs-plugins 0.9.10! :)
23:20:33 * seafood burns hand on hs-plugins
23:20:51 <lispy_> heh
23:21:05 * lispy_ puts some hot mits on
23:21:08 <dons> ouch, told you it was hot!
23:23:56 <ski> Burning Hands: Wizard Level 1, Range: 0,Casting Time: 1,Duration: Instant, Saving Throw: 1/2,Area of Effect: The caster
23:24:10 <lispy_> lol
23:24:38 <lispy_> omg...i haven't laughed that much at a D&D joke in....man...maybe ever
23:26:28 <ski> hehehehe
23:27:49 <ski> sddddddddddddddddddddddddddddddddd
23:27:56 <ski> stupic cat
