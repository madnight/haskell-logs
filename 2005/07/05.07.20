00:07:15 <xerox> moin
00:18:09 <Oejet> xerox: Ciao.
00:19:08 <xerox> Oejet: hi, how's code? :)
00:20:26 <Oejet> Not great, I'm on an XP machine now, so I don't have all the nice compilers. :-)
00:21:25 <xerox> GHC runs nicely! :-)
00:22:21 <Oejet> xerox: I know, but I don't feel comfortable on the command promt and in Wordpad.
00:23:06 <dons> @version
00:23:07 <lambdabot> lambdabot 3p54, GHC 6.4.1 (OpenBSD i386)
00:23:07 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:23:07 <xerox> That's why you get Emacs on win32 I think!
00:23:15 <xerox> Hello dons!
00:23:51 <dons> lambdabot is back up on a shiny new machine. let me  know if any commands appear to have stopped working
00:24:28 <xerox> @hoogle mapAccumR
00:24:29 <lambdabot> List.mapAccumR :: ((a -> b -> (a, c)) -> a -> [b] -> (a, [c]))
00:24:34 <Oejet> xerox: Not when you pay 6 Eurocent per MB, you don't.
00:24:35 <xerox> All korrect.
00:24:44 <xerox> Oejet: we are in the same situation, sigh :-(
00:25:06 <Oejet> Yeah, sigh.
00:25:09 <xerox> Mine's ever worse, 0.03 eur(kb.
00:25:14 <xerox> s/(/\//
00:25:47 <Oejet> â‚¬/KB?
00:26:13 <xerox> That was "0.03 eur/kb"
00:26:50 <xerox> But I got a "good" promotion with this cellphone, the first 400Mb are free.
00:27:58 <Oejet> 0.03 â‚¬/kilobit = 250â‚¬/MB!
00:28:15 <xerox> :-/
00:30:05 <xerox> Then you get here other 400Mb for 20eur, that's the best you'd get here :-\
00:31:51 <Oejet> b = bit, B = byte, at least in Denmark.  Are you on the road, or can't you get a wire connection at home?
00:33:28 <xerox> The former, fortunately :-)
00:34:43 <xerox> It is 0.03eur/kilobyte, actually.
00:38:56 <xerox> Oejet: do you actually pay 0.06 â‚¬, or 0.06 eurocent?
00:39:53 <Oejet> 0.06 â‚¬/MB.
00:40:08 <xerox> Unicode problems :-)
00:40:16 <xerox> Eur.
00:40:20 <Oejet> 0.06 Euro/MB.
00:56:26 <earthy> that's cheap
00:57:29 * earthy pays EUR 1.50/MB
00:57:37 <earthy> when on the mobile, that is
00:58:32 <earthy> ten times that when I'm outside the dutch borders.
00:58:33 <xerox> Sob :(
00:59:00 <earthy> which, weirdly enough, is the only place the mobile data actually works...
01:00:36 <Oejet> It's odd, one would think that the mobile phone infrastructure is way cheaper to run than lines.
01:01:22 <earthy> but the lines have already been paid for
01:01:35 <earthy> big difference
01:03:13 <xerox> In Italy we have high costs for DSLs too.
01:07:58 <earthy> ADSL is like EUR 20 a month for entry level
01:10:10 <earthy> that's all-you-can-eat 512 kbps down 256 kbps up
01:14:29 <Wed10960>  ok....compilation just hang my box :S
01:16:00 <Wed10960> when using UUAG wrappers...how can you put something in the AG that is dependent upon something you draw out of the AG...they are not circular dependent, basically one pass up and then calculation outside the AG....then passing down...
01:16:10 <Wed10960> but i think the wrapper syntax using a record is causing the problem
01:18:19 <Wed10960> let res = wrap_File (sem_File ast) ( Inh_File { in = ...} )
01:18:50 <xerox> earthy: I read some articles and even a petition about fees in Italy being much higher than in the rest of Europe, counting the bandwidth.
01:23:11 <Wed10960> i cant get res without providing the inherited attributes....but i need to use some part of res to calculate the inherited attributes....
01:23:31 <Wed10960> is it the recordsyntax that makes it hang? cause in principle it should be possible
01:33:23 <Wed10960> ok ok, im moving the calculation inside AG, have it your way
02:04:01 <Wed10960> @pl f . (\x y -> y)
02:04:03 <lambdabot> f . const id
02:04:13 <Wed10960> smartass
02:04:32 <Wed10960> @pl f . (\x y -> g x y)
02:04:33 <lambdabot> f . g
02:04:46 <Wed10960> @pl (\x -> x) . (\x y -> g x y)
02:04:47 <lambdabot> g
02:04:52 <Wed10960> @pl (\x -> z) . (\x y -> g x y)
02:04:53 <lambdabot> const z
02:05:01 <Wed10960> @pl (\x -> h x) . (\x y -> g x y)
02:05:02 <lambdabot> h . g
02:05:22 <Wed10960> nm lambdabot
02:05:40 <xerox> Wed10960: what are you trying to do?
02:08:17 <Wed10960> trying what he makes of a composition of a unary followed by a binary function where the first two arguments of the composed thing should go into the rightmost function
02:08:57 <Wed10960> (f .) . g i think
02:09:03 <Wed10960> "(f .) . g"
02:09:32 <Wed10960> @plugs ((id .) . const) 1 2
02:09:34 <lambdabot> 1
02:09:40 <Wed10960> @plugs ((id .) . const) 2 1
02:09:41 <lambdabot> 2
04:00:00 * jyp loves lilo's ads
04:03:27 <Wed10960> @pl (\x y -> (f . (g x y)))
04:03:29 <lambdabot> ((f .) .) . g
04:04:04 <Wed10960> @pl (\x y -> (f  (g x y)))
04:04:05 <lambdabot> (f .) . g
04:27:23 <Lemmih> Would it be wise to buy both TAPL and ATTAPL?
04:27:48 <Wed10960> i did
04:27:53 <Wed10960> but still not touched the latter
04:27:54 <Wed10960> hehehe
04:28:19 <Wed10960> so you may start with the former and by the time you're ready for the latter it will be reduced in price maybe :D
04:32:03 <Lemmih> Can't get any of them used. *sigh*
04:32:17 <Wed10960> ow like that
04:32:25 <Wed10960> i bought them new
04:32:46 <Wed10960> one of them i needed for school, so my parents paid for it :D
04:34:38 <Lemmih> That might work for me too.
04:35:17 <Wed10960> luckily i followed a lot of interesting courses that needed that kind of literature
04:35:25 <Wed10960> so my parents pay for those books no problem
04:39:59 <Lemmih> I just I were a student then I would get 10% off on all books plus economical support from the state. *deep sigh*
04:41:29 <Wed10960> ow, i thought you were
04:41:34 <Wed10960> sorry :)
04:41:39 <Wed10960> @hoogle filterM
04:41:40 <lambdabot> Monad.filterM :: Monad a => ((b -> (a Bool)) -> [b] -> (a [b]))
04:41:43 <Wed10960> awesome
04:42:29 <Wed10960> @hoogle mapM
04:42:30 <lambdabot> Prelude.mapM :: Monad a => ((b -> (a c)) -> [b] -> (a [c]))
04:42:30 <lambdabot> Maybe.mapMaybe :: ((a -> (Maybe b)) -> [a] -> [b])
04:42:30 <lambdabot> Prelude.mapM_ :: Monad a => ((b -> (a c)) -> [b] -> (a ()))
04:42:44 <Wed10960> :t liftM
04:42:47 <Wed10960> ow lol
04:42:58 <Wed10960> @hoogle liftM
04:42:59 <lambdabot> Monad.liftM :: Monad a => ((b -> c) -> (a b) -> (a c))
04:42:59 <lambdabot> Monad.liftM3 :: Monad a => ((b -> c -> d -> e) -> (a b) -> (a c) -> (
04:42:59 <lambdabot> a d) -> (a e))
04:42:59 <lambdabot> Monad.liftM2 :: Monad a => ((b -> c -> d) -> (a b) -> (a c) -> (a d))
04:43:56 <dblhelix> why does hoogle output liftM3 before liftM2?
04:44:13 <dblhelix> does it think it is more general because its type has more type variables?
04:44:23 <Wed10960> maybe its walking its resulttree in a predefined order
04:47:08 <Wed10960> @plugs liftM (Set.filter (`elem` [1,2,3])) $ Data.Map.singleton [] (Data.Set.fromList [1,6])
04:47:10 <lambdabot> Variable not in scope: `Set.filter'
04:47:20 <Wed10960> @plugs Control.Monad.liftM (Data.Set.filter (`elem` [1,2,3])) $ Data.Map.singleton [] (Data.Set.fromList [1,6])
04:47:22 <lambdabot> Variable not in scope: `Data.Set.filter'
04:47:47 <Wed10960> @hoogle filter
04:47:48 <lambdabot> Prelude.filter :: ((a -> Bool) -> [a] -> [a])
04:47:48 <lambdabot> Monad.filterM :: Monad a => ((b -> (a Bool)) -> [b] -> (a [b]))
04:47:54 <Wed10960> ow right Data is not incorporated
04:57:40 <Lemmih> Weird. It's cheaper and faster to buy the books in the UK and then mail them to Denmark.
04:58:59 <ozone> Lemmih: it's cheaper here to buy a (single) book from amazon in the usa and ship it to australia, than buying it over here
05:07:27 <dcoutts> xerox, just FYI: I got the code generator to produce some output for the cairo headers (not very useful probably) but more usefully, it should be possible to generate the docs for each function from the cairo docs
05:08:09 <dcoutts> xerox, I've got it extracting the docs fine, it just needs a tweak to get it to match up the docs with the appropriate functions
05:11:48 <dcoutts> xerox, so we can probably generate something which at least could be used to cut'n'paste haddock format docs from
05:13:35 <dcoutts> xerox, not that I'm trying to make more work for you! just experimenting to see if docs might be possible to do later
05:14:15 <ndm> Wed10960, not yet - i'm working on it as we speak
05:17:36 <Wed10960> a nice ndm
05:17:46 <Wed10960> that will be a very usefull feature
05:18:23 <ndm> yeah, trying to hack hugs to output the required information
05:27:12 <CosmicRay> any docs on using FFI with C++ anywhere?
05:28:55 <Wed10960> just one comment somewhere saying you go to hell and get your soul ripped for eternity if you do
05:29:08 <CosmicRay> ah, well.  that's encouraging.
05:29:29 <CosmicRay> course they say the same thing about unsafePerformIO and I have (carefully) used it without any ill effects ;-)
05:29:46 <Wed10960> the ill-effect is the hell and ripping part too i guess
05:29:52 <dcoutts> CosmicRay, wxhaskell does it, I think they use extern C { ... } and then link to the appropriate C functions
05:29:59 <CosmicRay> hmm.
05:30:25 <CosmicRay> I have here a C++ library that relies on being able to define a custom class that overrides some methods, as a key way of customizing behavior
05:30:30 <CosmicRay> I wonder how this could be modeled in haskell
05:31:15 <dcoutts> by a C++ class that inherits from the said class and delegates it implementation to a haskell implementation
05:31:46 <CosmicRay> a haskell implementation being something like a data object full of functions?
05:31:59 <dcoutts> yes, a record of functions in Haskell, one for each overridden method
05:32:19 <earthy> wxHaskell does not do it.
05:32:27 <earthy> wxHaskell binds to the eiffel bindings
05:32:38 <CosmicRay> earthy: wxHaskell simply doesn't support overriding classes?
05:32:52 <earthy> the eiffel team seems to have partly handcrafted a C interface to the C++ classes
05:32:53 <dcoutts> earthy, but I think the eiffel bindings generate a C API from the C++ API
05:33:08 <earthy> partly generate, yes
05:33:46 <earthy> anyway, Daan does not have a solution :)
05:34:02 <Wed10960> then again...daan is at m$
05:34:03 <Wed10960> :)
05:34:49 <dcoutts> CosmicRay, for Gtk+ I'm thinking of taking the solution I outlined above to implement the GtkTreeModel interfaces in Haskell
05:36:11 <CosmicRay> my other option for this project (a text-mode widget set) is a tcl binding that resembles tk
05:36:31 <CosmicRay> I'm wondering, is there a "preferred" gui library for haskell?  If so, is it based on tk?  And which tk gui library is preferred?
05:36:46 <CosmicRay> there may be some advantage to using something that has a very similar interface to tk
05:37:15 <dcoutts> there is no  "preferred" gui library for haskell
05:37:30 <CosmicRay> how about a preferred tk binding?
05:38:48 <dcoutts> not sure, check HTk and TclHaskell
05:39:31 <dcoutts> HTk looks like it was updated more recently (2003 vs 2001)
05:40:01 <dcoutts> there is also FranTk
05:40:32 <CosmicRay> yes, it seems that few of these tk libraries were updated recently
05:40:38 <dcoutts> sadly
05:40:42 <CosmicRay> I saw one yesterday that advertised being compatible with ghc 4.0
05:41:03 <dcoutts> the active ones I know of are bindings to wxWidgets, Gtk+ and FLTK
05:42:18 <CosmicRay> hmm.
05:43:43 <CosmicRay> so it sounds liek there is not really much advantage in the grand scheme of things to use a binding that could be unified with a tk binding down the road?
05:44:43 <dcoutts> probably not
05:44:52 <metaperl> why does no one say anything when I ask if Scala reminds them of Haskell? http://scala.epfl.ch/
05:45:25 <metaperl> dcoutts: thanks for the feedback on non-deterministic output of Haskell programs. it helped a lot , especially the suggestion to use output redirection
05:45:54 <dcoutts> metaperl, oh, good :-)
05:46:15 <metaperl> I finally finished that exercise after a month of hacking at it
05:47:06 <dcoutts> lazy IO should generally be avoided unless you know what you're doing (in some circumstances it's just the right tool for the job)
05:47:14 <metaperl> I hope a haskell entry does well in this year's ICFP contest
05:47:22 <dcoutts> me too! :-)
05:47:29 <Wed10960> maybe because "..It smoothly integrates features of object-oriented and functional languages.." was on that site
05:47:30 <Wed10960> :D
05:48:07 <dcoutts> metaperl,  I'm not so hopefull for my team's entry however
05:48:22 <metaperl> dcoutts: did it run?
05:48:29 <dcoutts> yep :-)
05:48:30 <metaperl> dcoutts: were you on dons' team?
05:49:01 <dcoutts> no, apparently dons team were inspired to enter this year due to our success last year :-)
05:49:54 <metaperl> good, we have at least 2 entries. increases the probability of success
05:50:50 <dcoutts> last year there were 8 Haskell entires (if I recall correctly)
05:51:16 <metaperl> Wed10960: that's a good point. How could I hae compared that language to Haskell when I look at their quicksort example: http://scala.epfl.ch/examples/files/sort1.html
06:03:36 <musasabi> metaperl: that looks a little bit like ruby too.
06:04:00 <metaperl> musasabi: and Pascal.. I dont know what I was thinking
06:14:45 <jyp> @seen dons
06:14:46 <lambdabot> dons is in #haskell. Last spoke 5 hours, 50 minutes and 54 seconds
06:14:46 <lambdabot> ago.
06:16:25 <musasabi> Is cvs.haskell.org down?
06:25:52 <ozone> jyp: he's likely asleep, it's ~11:30pm here
06:26:01 <ozone> (the boy sleeps early :)
06:28:26 <jyp> ozone: thanks for the info
06:29:47 <jyp> @seen basti
06:29:49 <lambdabot> I haven't seen basti.
06:29:55 <jyp> @seen _basti
06:29:57 <lambdabot> I haven't seen _basti.
06:29:59 <jyp> gah
06:30:38 <dons> moin
06:31:22 <jyp> well for the record I got a "new" scheme for yi-Emacs bindings
06:31:38 <jyp> and I wanted some feedback
06:32:06 <dons> cool :)
06:33:31 <dons> maybe send me an email if there's lots of details. it's late now, and I'm heading off
06:33:49 <ozone> oh, the man is up
06:34:05 <ozone> bye blue-hair man!
06:34:22 <jyp> There's isn't much details... The code should be self-explanatory
06:34:29 <jyp> I'll post to the wiki
06:34:36 <jyp> seems best
06:34:44 <dons> well, if it's stable, you can send it in and start emacs2
06:34:56 <dons> i don't mind having alternate binding implementations
06:35:04 <jyp> cool
06:35:29 <dons> there's no "true path", as this is kind of a new area.
06:35:44 <dons> well, maybe there is a true path, we just don't know what it is yet
06:35:52 <jyp> :)
06:36:12 <dons> so darcs send, and I'll commit it in the morning (10 hrs or so)
06:36:17 <ozone> there is no true path until phil wadler writes a paper about it with a catchy name
06:36:50 <dons> hehe
06:37:51 <jyp> Ok then; I need to clean it up and comment the "path"  I wish to take; then it's send.
06:38:20 <dons> sounds good. maybe name it Emacs2 or such, and add a --as=emacs2 line to Yi.hs -- so we can invoked it from the command line
06:38:41 <dons> see the editorFM in Yi.hs
06:40:25 <jyp> got it
06:42:17 <dons> nitol!
06:50:45 <jyp> gnite
06:50:53 <jyp> and gotta go too
06:53:03 <Lunar^> CosmicRay: here?
06:53:12 <xhaju> hi
06:55:57 <Oeje1> xhaju: Hello, there.
06:56:30 <xhaju> hello Oejel
07:17:05 <JaffaCake> http://www.haskell.org/hawiki/GhcPerformance
07:17:18 <JaffaCake> please add stuff to this page that you come across
07:23:26 <Philippa_> Are semi-silly/weird suggestions okay?
07:25:54 <Philippa_> (just added one)
07:27:42 <Lemmih> What's x87?
07:28:14 <Philippa_> what was the x86 maths co-pro
07:31:56 <JaffaCake> Lemmih: yes, the x86 floating point processor
07:32:12 <JaffaCake> GHC's NCG can now generate floating pt code for either x87 or SSE2
07:32:24 <JaffaCake> although the SSE2 code is so far only enabled for x86_64
07:33:30 <Philippa_> does my suggestion seem daft or not, btw? It occurs to me that it could be a good way to avoid space leaks on occasion, stuff like that
07:33:47 <JaffaCake> Philippa_: do you mean anti-laziness, not anti-strictness?
07:35:20 <Philippa_> that's probably a better term, though I was thinking of how it's sort of the opposite of a strictness annotation - "it'll always be evaluated for you" vs "it'll never be evaluated for you"
07:35:32 <JaffaCake> I can see there might be a use for that, I'm not sure how to implement it (yet)
07:35:54 <Igloo> If I understand correctly I'd call it anti-sharing
07:36:02 <JaffaCake> yes
07:36:04 <Philippa_> yeah, anti-sharing's the intention
07:36:13 * esap goes to read the logs...
07:36:57 <Igloo> Are you just thinkging of   let x = ... in x+x   or also things like   (\x -> x + x)   ?
07:37:15 <Igloo> The second would make my head hurt, I think  :-)
07:37:29 <Wed24877> hooray, second freeze while compiling :S
07:38:11 <Philippa_> Igloo: er?
07:39:30 * Igloo has probably misunderstood you if that didn't make sense. Don't worry about it
07:39:43 <Wed24877> how can i arrange that im always able to interrupt the compiling proces....cause i couldnt move my mouse nothing
07:40:11 <JaffaCake> Wed24877: what OS?
07:40:25 <Wed24877> fedora
07:41:08 <JaffaCake> if you're swapping, then you might want to put a limit on GHC's heap usage with +RTS -M128m (for example)
07:41:09 <Lemmih> Buy more RAM.
07:41:27 <Wed24877> this is a corporate pc
07:41:30 <Wed24877> not my call
07:41:34 <JaffaCake> plugging in some more ram is preferable, yes
07:41:39 <Wed24877> i know :)
07:42:09 <Wed24877> its ridiculous, because i only have 104MB free at this moment
07:42:20 <Wed24877> an 406MB used
07:42:25 <Wed24877> not counting swap
07:43:08 <JaffaCake> Linux uses a lot for disk cache, but the cache will reduce in size as you use more for programs
07:44:01 <Wed24877> so if i currently have 108MB free....what would a good limit for the ghc heap be?
07:44:38 <Spark> the cache being full of mp3s
07:44:41 <Spark> such is life
07:44:56 <JaffaCake> if the machine has 512M, then you should be fine
07:45:27 <Wed24877> hmm, thats the thing..i thought i was fine still it freezed two times on me today
07:45:40 <JaffaCake> what are you compiling?
07:46:05 <Wed24877> a really large uuag program doing program analysis on a C program
07:46:07 <Lemmih> JaffaCake: What happened to -fnumbers-strict, btw? I can find it in the documentation but GHC 6.4 doesn't recognize it.
07:46:30 <JaffaCake> oops, I think it was removed a while back
07:47:29 <JaffaCake> I'll fix the docs, thanks
07:50:07 <Wed24877> JaffaCake, im listening to internetradio all day...could that be causing the big mem usage? that would be strange...but so would 406MB usage of mem without doing something special
07:51:30 <JaffaCake> Wed24877: try running top, and press 'M'
07:51:46 <JaffaCake> see who's using all that memory
07:53:14 <Wed24877> i see kdeinit 5 times, 20mb each....but im running gnome
07:56:05 <Wed24877> probably because i started a kde app
07:58:01 <JaffaCake> it's possible your compile is going crazy .. try watching it with top
07:58:16 <JaffaCake> and put a limit on, something like +RTS -M256m
07:59:48 <Wed24877> wtffff after one succesful compilation my free mem is 350MB .....
08:08:01 <Wed24877> is Text.Regex funky?
08:09:06 <Igloo> It will have forced stuff out of the disk cache to make room for the compilation, leaving more free mem when it finished, I suspect
08:09:21 <Wed24877> yeah, i like it
08:09:25 <Wed24877> force is good
08:20:30 <void-> Hi, is there a good SDL binding for haskell (ghc)?
08:22:18 <pejo> JaffaCake, as for the GhcPerformance list in the wiki, I presume the Laszlo Nemeth isn't the author who was written Trauer Roman and Wie Der Stein Fällt Roman? :-)
08:22:58 <Lemmih> void-: Try http://scannedinavian.org/~lemmih/SDLstable (darcs repo), then you can judge it yourself.
08:24:42 <void-> Lemmih: Ok. Thanks!
08:25:20 <Lemmih> You'll need GHC 6.4, btw.
08:27:01 <void-> No problem, I'm quite new to haskell so I have a fresh install =)
08:48:28 <bourbaki> moin
09:48:20 <Lemmih> Morning, SyntaxNinja.
10:11:28 <SyntaxNinja> hiya Lemmih
10:11:30 <SyntaxNinja> how are you?
10:12:47 <Lemmih> Good. Thinking about buying TAPL and ATTAPL but they're kinda expensive.
10:13:11 <Lemmih> Oh, gotta go. Dinner time.
10:13:16 <SyntaxNinja> l8r
10:13:47 <wilx> @wiki
10:13:48 <lambdabot> http://www.haskell.org/hawiki/
10:16:08 <Oeje1> @chocolateCake
10:16:09 <lambdabot> Unknown command, try @listcommands.
10:17:12 <Speck> What we need more of. Is science.
10:17:50 <wilx> Hmm...
10:18:01 <Oeje1> More science?  Higher taxes, I say!
10:18:12 <wilx> Many links on http://www.haskell.org/bookshelf/ are broken.
10:19:01 <Oeje1> What's the overall income tax in the US?
10:20:20 <SyntaxNinja> Lemmih: I want to get TAPL to
10:20:23 <_metaperl> Oeje1: I'm sure it varies from person to person. I make 7500/month but after taxes I get 5000/month. I'm pretty sure I will get a refund come tax time
10:21:56 <Oeje1> Whoa, that's 33%.
10:22:15 <_metaperl> yes, as a salaried person, I think that's about normal
10:22:24 <_metaperl> I do get medical/dental benefits also
10:23:09 <Igloo> 60k after tax still seems like a very respectable salary to me, even if it is in USD
10:23:15 <Igloo> Then again, I'm just a poor student  :-)
10:23:20 <Philippa_> beats the crap out of what I live on
10:23:33 <Philippa_> and USD in the US isn't so bad as USD outside
10:23:41 <Oeje1> Hm, interesting, I thought it was much lower.  What does the government use all that tax money for?
10:24:02 <Igloo> Fighting terror?  :-)
10:24:17 <metaperl_> Igloo: the problem is the job is in Westlake Village, CA. An 1 bedroom apartment is 1300/month here
10:24:44 <metaperl_> I have decided to move to urban Los Angeles and take a 1.5 hour bus ride to Westlake Village so that my rent is only 450/month.
10:25:04 <pejo> Oeje1, you pay federal income tax if you make too much money. Some states don't have a state income tax, I'm guessing Alaska, Florida, Nevada, New Hampshire, South Dakota, Tennessee, Texas, Washington och Wyoming are among those. ;)
10:25:47 <Oeje1> pejo: Ah, someone told me that recently, I now remember.
10:26:50 <metaperl_> pejo: it's not that simple. My mom had a low-paying part-time job and owed around 7,000 in income tax
10:27:02 <metaperl_> and she lived/worked in South Carolina, a rather low-income state
10:27:26 <metaperl_> full-time job gives the best tax situation. contractors and part-time people get shanked by the tax system
10:27:29 <pejo> metaperl, she had to pay federal income tax with a low paying job?
10:27:57 <metaperl_> she had to pay (and is still paying with about a 70% interest rate penalty) all that income tax
10:28:14 <Oeje1> Ouch.
10:29:19 <pejo> metaperl, is it federal income tax she's paying though?
10:29:47 <SyntaxNinja> Igloo: at least the world is a much safer place now.  think of the children.
10:30:53 <Oeje1> SyntaxNinja: Hehe, yes the children.
10:31:24 <lightstep> 33% income tax doesn't sound high
10:32:08 <Oeje1> It's above my impression at least.
10:33:39 <pejo> Oeje, http://taxes.yahoo.com/rates.html, http://taxes.yahoo.com/statereport.html
10:34:38 <Speck> delaware and oregon don't have sales tax woo!
10:34:50 <SyntaxNinja> nor does PA if I recall
10:34:52 <SyntaxNinja> <--- oregon
10:34:56 <SyntaxNinja> w00h00
10:35:08 <Speck> I live in maryland, but I go to delaware to buy cigarettes
10:35:12 <SyntaxNinja> but we're not allowed to pump our own gass
10:35:16 <SyntaxNinja> gas
10:35:37 <arjanoosting> Igloo: When will you upload a new version of ghc6 to unstable? Are you waiting until xorg is build on all architectures?
10:36:15 <bringert> Igloo: NewCGI now has basic support for multipart/form-data
10:36:28 <Igloo> arjanoosting: When 6.4.1 is released (6.4 doesn't compile with gcc 4, and I doubt it has a hope of reaching testing anyway)
10:36:34 <Igloo> bringert: Nifty, thanks1
10:36:45 <Igloo> I'll try to give it a whirl tonight
10:37:28 <bringert> no fancy content-transfer-encoding stuff, so it probably only works for text file uploads atm
10:38:16 <Igloo> OK
10:45:02 <Speck> fundeps are "almost definitely" going to get into haskell2 right?
10:45:28 <Igloo> Haskell 2 is showing no signs of actually happening AFAIK
10:45:40 <Igloo> But I imagine so
10:45:41 <Speck> oh, interesting
10:46:11 <Igloo> It's not actively "not happening", it's just not actually happening TTBOMK
10:46:22 <Speck> ttbomk?
10:46:25 <Speck> oh I got it
10:47:13 <Lemmih> TTBOMK?
10:47:23 <Speck> to the best of my knowledge
10:47:36 <Speck> afaict
10:47:39 <Speck> :-P
10:48:43 <Speck> well haskell98 is certainly good enough to last for a long time, but I think that stuff like fundeps would be good for cleaning up the stdlib at the very least
10:49:11 <CosmicRay> yes, I think there are quite a few weaknesses in haskell98
10:49:20 <CosmicRay> there are a lot of useful things in haskell that are impossible with pure haskell98
10:49:28 * Igloo doesn't think it's good enough as it doesn't let you use things like the state monad
10:49:35 <Philippa_> I'd like to see a Haskell2 on hold at least long enough to see how boxy types interact with everything else
10:49:45 <CosmicRay> overlapping instances, undecidable instances, concurrency, and FFI to name a few
10:49:49 <Igloo> boxy types?
10:49:54 <Philippa_> yeah, the ST monad's really important for a lot of purposes
10:49:57 <CosmicRay> Igloo: they're square.
10:50:10 <Igloo> ST? I meant StateT
10:50:27 <Philippa_> Igloo: the latest inference algo variant. Handles impredicative types
10:50:42 <Philippa_> and thus hopefully lets you have the "any member of this type class" type too
10:50:53 <Speck> oooh
10:51:12 <Igloo> Doesn't impredicative => undecidable, or does my memory fail me?
10:51:13 <Speck> Num becomes a true-ish type?
10:51:26 <Philippa_> for inference yes, for checking no
10:51:56 <Philippa_> so it's rank-n++
10:52:03 * Igloo would rather Haskell 2 hurried up, personally. We can always have a Haskell 3  :-)
10:52:34 <Speck> haskell has a lot of research momentum behind it, standardizing would be a long and hard process
10:52:41 <Speck> consolidating so many efforts
10:52:44 <Philippa_> Meh. Standardising on support for impredicative types has a lot of benefits
10:52:51 <Philippa_> Speck: so what else is new?
10:53:00 <Speck> nothing, I guess
10:53:07 <CosmicRay> Speck: the longer we wait, the more difficult it will be.
10:53:15 <Igloo> Yeah, but you can do that in a ghc extension, and have time to find all the things that need tweaking
10:53:24 <Speck> fast good and well still holds true, I assume
10:53:42 <Speck> err, wait a second, that isn't what it was... fast, cheap, and well
10:53:49 <Philippa_> fast, cheap, good is the usual one
10:54:02 <lightstep> the Good Thing to do is make some backward-incompatible changes to the libarary
10:54:06 <Speck> and I guess cheap doesn't really apply, so we can pick fast and good :-)
10:54:24 <Speck> I say screw backwards compatability
10:54:40 <astrolabe> Would haskell 2 be back compatable.
10:54:48 <astrolabe> ?
10:54:58 <pejo> Speck, thats the way to go, considering the results from the recent GHC Survey.
10:55:01 <CosmicRay> astrolabe: if we call it Haskell XP, it doesn't have to be :-)
10:55:12 <astrolabe> :)
10:55:19 <CosmicRay> then we can also have Haskell XP SP2, which totally screws everything ;-)
10:55:29 <lightstep> i hope the syntax will be compatible
10:55:45 <CosmicRay> really, I wouldn't see why not
10:55:55 <CosmicRay> a lot of ideas in haskell are already present in ghc as extensions
10:56:00 <CosmicRay> some are even in hugs
10:56:03 <CosmicRay> a few in nhc98
10:56:08 <Igloo> There might be a few new keywords (like forall, exist)
10:56:15 <lightstep> let x = 2 in x == y == z
10:56:17 <Speck> existential types?
10:56:22 <CosmicRay> I think too that it would make sense to split off the standard library from the language
10:56:25 <astrolabe> The trouble with that is in 30 years time, there will be half a dozen different haskells all being developed with
10:56:26 <Igloo> mdo
10:56:31 <CosmicRay> except perhaps for a small base that can be built upon
10:56:33 <Speck> I learned about them in Z, but I never really understood the implications
10:56:42 <bringert> Igloo: it looks like web browsers (at least firefox) don't do any transfer encoding, so binary file uploads work already
10:56:45 <CosmicRay> astrolabe: right, that's why it's important to not let the standard lag too much
10:56:49 <Igloo> Isn't that already done?
10:56:58 <Igloo> bringert: Cool, ta
10:57:05 <CosmicRay> the haskell standard is already 7 years old
10:57:28 <CosmicRay> how long was it from the previous haskell standard to haskell 98?
10:57:32 <CosmicRay> (what was the previous one called?)
10:57:35 <Speck> 1.4?
10:57:40 <CosmicRay> ah right
10:57:45 <Speck> which apparently had monad comprehensions, which I think should come back!
10:57:45 <CosmicRay> that does ring a bell
10:57:46 <Igloo> There's probably a history in the report
10:57:57 <Igloo> If not, on haskell.org somewhere
10:57:57 <SyntaxNinja> sometimes I have the feeling that if people started shouting, a new standard would begin.
10:58:01 <astrolabe> Maybe they should standardize now before Haskell takes over the world, and it's too late.
10:58:11 <CosmicRay> NEW STANDARDS TIME!  WHO'S WITH ME?
10:58:14 <Speck> astrolabe, that's what I'm thinking
10:58:18 * Speck screams with CosmicRay
10:58:22 <Igloo> I think some of the really important things H2 would need to fix aren't decided yet, though
10:58:31 <CosmicRay> Igloo: there's always time for H2.1
10:58:32 <Igloo> e.g. monomorphism replacement, principal types
10:58:33 <astrolabe> Speck:  I agree.  Monad comps sound cool
10:58:39 <SyntaxNinja> Igloo: they won't get decided either, unti they start to try to decide them.
10:58:55 <Igloo> SyntaxNinja: Start deciding, then  :-)
10:58:57 <Speck> the only problem was the error messages were confusing for new users. a better solution would be to fix the error messages :-P
10:59:32 <pejo> Speck, that could require some research though.
10:59:56 <Speck> probably
10:59:57 <SyntaxNinja> CosmicRay: I'm with you :)
11:00:00 <SyntaxNinja> but for now, meeting time
11:00:01 * SyntaxNinja &
11:00:25 <astrolabe> Well, if you get confused, don't use monad comps till you understand them.
11:01:22 <Speck> the problem is that list comprehensions were subsumed by monad comprehensions
11:02:09 <Philippa_> fixing the error messages can be pretty difficult
11:02:17 <astrolabe> The conference that decided Haskell was necessary was in 1987, so five versions in 11 years.
11:02:24 <Speck> I didn't see any examples of what the error messages looked like
11:02:32 <Speck> because it was well after my time
11:02:34 <autrijus> what's the use of nonlist monad comprehensions again?
11:02:37 <Philippa_> as really it amounts to injecting specific information about certain prelude types
11:03:03 <Speck> autrijus, concise syntax, really. I think you can do the same stuff with do notation
11:03:10 <autrijus> example?
11:03:50 <Speck> don't look at me. I just read about them and thought they could be cool!
11:04:53 <Speck> I think that the precieved benefit was a good query syntax for any monad, not just lists
11:05:08 <astrolabe> Something like [concat a b | a <- getLine | b <- getLine]
11:05:30 <metaperl_> @type concat
11:05:36 <lambdabot> forall a. [[a]] -> [a]
11:05:53 <Speck> and perhaps more potential for optimizations under the hood
11:07:09 <pejo> Speaking of optimizations, there is a Laszlo Nemeth mentioned on the GhcPerformance page in the wiki. Does anyone have a link to his home page or similar? My googlefu is near 0 obviously, I only found a german writer by that name.
11:09:34 <Speck> monad comprehensions are expressable as catamorphisms, which open up a world of fusion laws (from some pdf found on google)
11:10:15 <astrolabe> Ah I get it.  I should have said [a ++ b | a <- getLine | b <- getLine]
11:13:39 * CosmicRay posts to -cafe about stndards.
11:13:52 <CosmicRay> now I would like to ask a question about Windows. :-)
11:14:19 <CosmicRay> I have someone trying to use missingh on windows
11:14:23 <CosmicRay> windows apparently has no unix package
11:14:29 <CosmicRay> so he disabled that in the cabal file
11:14:40 <CosmicRay> now he gets an error message saying that SYstem.Posix.Process doesn't exist
11:14:56 <CosmicRay> however, his filesystem has System.Posix...
11:14:59 <CosmicRay> any ideas?
11:15:14 <CosmicRay> am I going to have to use hscpp to disable these files on windows?
11:15:23 <CosmicRay> is there a way to disable the dep on the unix package on windows only (in cabal?)
11:15:53 <Igloo> Windows doesn't have some or all of System.Posix
11:16:18 <CosmicRay> so I should probably just not even build my modules that rely on it, on windows...
11:16:24 <CosmicRay> so then the question is, can cabal help me with this?
11:17:03 <CosmicRay> Igloo: that's unfortunate, since there are some functions there that have no more generic System.whatever equivolent, yet easily could
11:17:12 <Igloo> Like what?
11:17:20 <Igloo> I'm sure patches will be accepted  :-)  (for ghc 6.6)
11:18:34 <Igloo> Hmm, my monad-transformer-chain type synonym no longer fits on 1 line
11:19:50 <CosmicRay> I'll have to check, it's been a few months since I wrote this code
11:20:39 <CosmicRay> Igloo: I think some of the stuff in System.Posix.Files and System.Posix.Types had no other way to get at
11:20:42 <CosmicRay> ... checking...
11:21:15 <Igloo> GHC doesn't come with any file locking functions, right?
11:21:35 <CosmicRay> well, it apparently auto-locks handles, but yes, afaik you're right and it sucks
11:21:57 * Igloo needs inter-process locking
11:22:44 <CosmicRay> for instance, afaik there's no modificationTime function outside Posix, even though every FS supports it
11:23:11 <CosmicRay> I think epochTime has no business being in posix
11:23:27 <CosmicRay> mkstemp should be standard
11:24:47 <CosmicRay> I don't really know what System.Posix.Error does, but it looks standard enough to me
11:24:52 <Philippa_> I'm fairly sure there's a last modification time outside posix
11:25:16 <CosmicRay> ahh, you're right.
11:25:24 <CosmicRay> a surprising amount of stat() information isn't
11:25:49 <CosmicRay> I like python's approach: stat() is the standard interface, and on non-Posix OSs, as much of the stat structure as possible is filled in
11:27:17 <tuomov> it sucks that the writer of System.Posix has tried to reinvent the wheel instead of directly copying the posix C names
11:27:28 <CosmicRay> yes
11:27:33 <CosmicRay> ditto for some Network code
11:28:18 <CosmicRay> damn you, setCurrentDirectory :-)
11:28:22 <CosmicRay> that one bites me every time
11:28:41 <CosmicRay> somebody must have come from a Java background :-)
11:31:00 <Speck> hehe, "Monads for nothing, theorems for free."
11:31:35 <Speck> setCurrentDirectory bites me on windows a lot... darn windows path delimeters
11:32:17 <CosmicRay> heh
11:32:20 <CosmicRay> I was wondering about that
11:32:29 <CosmicRay> now that I have a windows user for missingh
11:32:38 <CosmicRay> does haskell support "/" as a delimeter on windows?
11:32:52 <CosmicRay> or must we go the annoying java way of querying the system for it?  if the latter, where is it?
11:32:59 <musasabi> Well you are not forced to use the standard network code - there are nicer interfaces ;)
11:33:11 <CosmicRay> musasabi: oh?  ones that support ipv6 or ssl, perhaps?
11:33:39 <musasabi> ipv6 yes, ssl not at the moment.
11:34:08 <CosmicRay> musasabi: nice.  url?
11:34:35 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/network-alt/
11:34:44 <musasabi> ssl tends to add evil library dependencies.
11:35:45 <CosmicRay> well gnutls looks a good bit less evil than openssl, from the brief glance I've given it
11:35:55 <CosmicRay> I've decided to package up some sort of curses widget set for haskell first
11:35:56 <CosmicRay> then tls
11:36:05 <musasabi> How portable is gnutls?
11:36:11 <CosmicRay> musasabi: very
11:37:02 <musasabi> I think I can hack that into network-alt as an optional component.
11:37:28 <CosmicRay> http://josefsson.org/autobuild-logs/gnutls.html
11:38:05 <CosmicRay> it seems to be supported everywhere except windows
11:38:08 <CosmicRay> the situation there is unclear
11:38:24 <CosmicRay> it seems that it theoretically is buildable there but some prerequisites are difficult
11:38:27 <CosmicRay> not sure
11:38:55 <CosmicRay> AFAIK there is no universal ssl toolkit that runs on both *ix and windows
11:38:56 <Speck> I don't think we can ignore windows, as much as I wish we could
11:39:14 <CosmicRay> Speck: I suspect that we will have to have separate support for whatever windows uses
11:39:41 <Speck> true
11:39:43 <musasabi> Windows supports openssl but that had many problems at least a few years ago.
11:39:53 <CosmicRay> musasabi: yes, and openssl has serious license issues
11:40:06 <CosmicRay> musasabi: for that reason I don't think it can be a serious candidate on any platform
11:41:06 <musasabi> true.
11:41:16 <Speck> I didn't know that
11:41:23 <musasabi> I'll look into interfacing with gnutls tonight.
11:41:27 <CosmicRay> Speck: http://www.gnome.org/~markmc/openssl-and-the-gpl.html
11:41:46 <CosmicRay> Speck: ironically, it is a problem for both GPL users and developers of proprietary software, but not for BSD or MIT users
11:42:12 * Speck likes BSD and MIT anyway
11:42:14 <CosmicRay> hmm, apparently mozilla has a library
11:42:21 <CosmicRay> <-- GPLer
11:42:39 <CosmicRay> musasabi: ever looked at this: http://www.mozilla.org/projects/security/pki/nss/
11:42:45 <CosmicRay> musasabi: I haven't, but it ought to be portable
11:43:48 <musasabi> hmm that is a point too.
11:44:01 <CosmicRay> apparently certified in 18 platforms, including *ix and windows
11:44:04 <CosmicRay> that may be the way to go then
11:44:10 * musasabi uses BSD for most things as I don't want to think about licences.
11:44:14 <CosmicRay> assuming the api is sane and the code is bug-free
11:44:24 <CosmicRay> musasabi: s/BSD/GPL/ and you've described me ;-)
11:45:01 <musasabi> The best case would be something "keep this file free but you can link into whatever you want" from my perspective.
11:45:20 <musasabi> and LGPL is not an option in Haskell afaik.
11:45:22 <astrolabe> I don't understand GPL, and I find it a pain.
11:45:46 <pejo> CosmicRay, why is the openssl license a problem for the proprietary users?
11:45:48 <Philippa_> I have stronger views against GPL in a lot of circumstances, I tend to BSD
11:45:53 <CosmicRay> musasabi: it works out to pretty much the same as BSD
11:45:59 <CosmicRay> pejo: because of the mandatory advertising clauses
11:46:31 <astrolabe> I don't like the idea that all software should be open.  I must be getting old.
11:46:37 <Speck> is the haskell standard licensed or each implementation?
11:46:42 <musasabi> CosmicRay: as Haskell does not do dynamic linking isn't LGPL quite worthless?
11:46:50 <pejo> CosmicRay, the original bsd license had that too. People seems to use source code under that license anyways?
11:47:01 <CosmicRay> musasabi: no, LGPL was written in the pre-dynamic linking days anyway
11:47:14 <mwelsh> can anyone here think of a way for a haskell program to read a binary file containing a sequence of float's?  the preferred signature would be like Current :: File -> Float; Next :: File -> Float
11:47:31 <CosmicRay> pejo: well, there were a lot of problems.  It caused considerable angst, and UC Berkeley made it pretty clear long ago that they wouldn't enforce it
11:47:38 <CosmicRay> pejo: they finally removed that clause more recently
11:47:42 <Speck> astrolabe, more likely you're getting practical than old (though they do have a strong correlation, we mustn't imply causation)
11:48:07 <Lemmih> mwelsh: Familiar with IO in Haskell?
11:48:07 <pejo> CosmicRay, dang. How old is LGPL?
11:48:10 <Speck> Sometimes I wish we never concieved of "worth" in the first place :-\
11:48:23 <metaperl_> @seen shapr
11:48:24 <lambdabot> I saw shapr leaving #haskell 8 hours, 24 minutes and 13 seconds ago.
11:48:26 <astrolabe> Speck: Thanks, but that doesn't explain why I mutter to myself.
11:48:31 <mwelsh> Lemmih: vaguely.  i can figure out most of it
11:48:39 <CosmicRay> pejo: 1991-ish
11:48:56 <Philippa_> there're teenagers who mutter to themselves, no biggie
11:49:02 <Speck> who doesn't mutter to themselves? I posit that only the trule insane speak only to others.
11:49:05 <CosmicRay> pejo: maybe 1989
11:49:07 <Lemmih> mwelsh: How are the floats separated in the file?
11:49:25 <mwelsh> they arent.  its a dump from a C program
11:49:46 <CosmicRay> mwelsh: so they are binary flots in some arbitrary cpu's representation?
11:49:55 <musasabi> CosmicRay: is there any good discussion of the issue? I thougth that lgpl made static linking a no-no, but I might very well be wrong.
11:49:58 <pejo> CosmicRay, Ok. http://www.iecc.com/linker/linker10.html claims SunOS introduced it in late 80's.
11:50:13 <Speck> astrolabe, sometime I feel like F/OSS is a conspiracy devised by large corporations to get college age CS students to do their work for free
11:50:23 <CosmicRay> pejo: hmm.  in any case, I don't think it was considered at the time lgpl was drafted
11:50:25 <mwelsh> its the standard type for C.  you mean the size of a float varies from proc to proc?
11:50:30 <Philippa_> musasabi: not completely, but if you statically link to a lib you need to offer the object files separately
11:50:33 <mwelsh> i thought they were all 16 bits
11:50:38 <CosmicRay> Speck: you wouldn't feel that way if you use gpl ;-)
11:50:39 <mwelsh> or 32 or whatever
11:50:50 <Philippa_> yeah, then it's an RMS conspiracy - much better!
11:50:51 <CosmicRay> mwelsh: internal representation varies even if the size does not
11:51:14 <mwelsh> hmm
11:51:18 <CosmicRay> mwelsh: incidentally, I think the size *does* vary.  I'm reasonably sure that float on an alpha is at least 32 bits
11:51:19 <mwelsh> well thats a problem
11:51:24 <astrolabe> Google's got a link to a cool moon map.
11:51:35 <CosmicRay> astrolabe: yup.  zoom in.  ;-)
11:51:41 <mwelsh> lol, queso
11:51:43 <Speck> CosmicRay, look at apple; they're found a way to use gpl :-)
11:51:50 <CosmicRay> mwelsh: I know for certain that arm represents them differently than everything else
11:51:59 <musasabi> Philippa_: so that means that every haskell app linking to a LGPL haskell library would need to provide *.{hi,o} (if they are not free) ?
11:52:02 <pejo> CosmicRay, lets not start a  flame war. GPL isn't a panacea. Lots of companies use BSD based stuff for their appliances since it's not GPL'd, for example.
11:52:13 <CosmicRay> pejo: I know
11:52:24 <mwelsh> CosmicRay: so as far as you know, haskell cannot read a binary file of C floats?
11:52:32 <Speck> screw flame wars, what we need is a good old fashioned HOLY WAR
11:52:52 <Philippa_> RMS vs people who like to eat?
11:53:16 <astrolabe> C doesn't define how big floats are
11:53:16 <Speck> the problem with rms' being so disagreeable is that he's right a lot of the time
11:53:23 <mwelsh> CosmicRay, how about if I were to convert the file to text... although then the file would be about 0.5 gig
11:53:31 <CosmicRay> mwelsh: well, it could if you decode it yourself using Data.Bits.  Otherwise, I'd suggest writing a trivial C function that takes a Word16 or whatever the float is on your cpu and converts it into a Haskell float
11:53:42 <CosmicRay> mwelsh: that would be the easiest way.
11:53:48 <CosmicRay> mwelsh: why write it out?  write a C filter
11:53:51 <Philippa_> yeah. Often he's right in an "in an ideal world" kinda way though. The transitional programme is less than perfect
11:53:53 <CosmicRay> it could be just a few lines long
11:54:12 <Speck> Philippa_, I sympathize with him on that level though. I am very much an idealist.
11:54:12 <CosmicRay> mwelsh: your C program can read the binary data on stdin and emit numbers on stdout, one per line
11:54:28 <CosmicRay> I recognize that there are sometimes pressures on companies that can make the GPL inappropriate.
11:54:37 <Lemmih> mwelsh: System.IO.hGetBuf and some peeking should also do it.
11:54:43 <CosmicRay> at the same time, I believe that these are seriously exaggerated, and generally motivated by greed
11:54:49 <Speck> Philippa_, and on some level I think that anyone writing in a purely functional programming language has to be somewhat an idealist :-P
11:54:50 <jlouis> as long as you are on the smaller floats it is IEE 754 (32 and 64 bit floats) and the representation is the same. If you take floats bigger than that, there is no standard, x86 has 80 bit floats and ppc has 128 bit floats for instance
11:54:55 <dfd> Hello
11:55:00 <Lemmih> Hello dfd.
11:55:05 <CosmicRay> I view it as a bug that the American (and now, Western) view of economics has greed as its top asset
11:55:10 <Philippa_> Speck: you're talking to someone who makes pure FPLs as impure as needed on demand :-)
11:55:20 <CosmicRay> and I believe RMS is right that the GPL-inspired world has the greatest net good
11:55:23 <Speck> oh, the enemy! :-P
11:55:25 <pejo> CosmicRay, the "pressure" you're talking about could for example be "making a product that is better than our competitors". And most companies like profit.
11:55:36 <CosmicRay> phone, brb
11:55:44 <Philippa_> CosmicRay: quite possibly. Unfortunately, my dependencies aren't solely software
11:56:14 <pejo> (Lets not argue whether a good product is necessary or not, for most companies it's a clear advantage).
11:56:23 <tuomov> s/better/looks sexier to customers/
11:56:54 <CosmicRay> back
11:57:16 <Lemmih> Wrong number?
11:57:21 <CosmicRay> pejo: sure, but let's extrapolate: why shouldn't the pressure be to "making the best possible product" instead of "making the better product"
11:57:27 <CosmicRay> Lemmih: almost ;-)
11:57:55 <CosmicRay> pejo: if indeed the goal was to be the best possible, then the "standing on the shoulders of giants" approach makes a lot of sense, and it *also* makes sense to collaborate with otehrs
11:58:04 <pejo> CosmicRay, because the pressure is to make money, not charity?
11:58:07 <Philippa_> def. "best possible"
11:58:11 <Speck> I have a dream. I dream of a world where people will act not in the interests of garnering assets in the pursuit of worth, but where my brothers and sisters will find their motivation in the infinite possibilities of the future. I dream of a world where the progress of science and philosophy can stand up and crush the allmighty dollar, where anyone with a dream can change the course of history.
11:58:20 <CosmicRay> pejo: no, because the pressure is to make money *for onesself*
11:58:23 <cventers_> cventers_
11:58:32 <Philippa_> to put it another way, is cost involved in the decision anywhere?
11:58:55 <tuomov> s/oneself/shareholders/
11:59:01 <SyntaxNinja> woo CosmicRay already posts to the haskell mailing list :)
11:59:06 <Philippa_> Speck: many of us are motivated by the infinite possibilities of the future. Especially those involving starvation
11:59:06 <CosmicRay> as a consumer, if corporations vigorously embraced the use of the GPL, I would find myself able to chose from a wider variety of better, cheaper products
11:59:22 <CosmicRay> SyntaxNinja: get me fired up about something and I'm liable to start the fire :-)
11:59:23 <Philippa_> CosmicRay: now make it work for physical products
11:59:50 <pejo> CosmicRay, I don't think any company wants more competition.
11:59:54 <esap> The problem lies with money. Money isn't general-purpose enough. You can't buy everything with money. That's the problem. It has been used as if money could buy anything.
11:59:56 <Speck> Philippa_, more of a fear of the future
12:00:16 <CosmicRay> pejo: indeed.  what is in the interest of the corporation is not in the interest of the consumer.
12:00:27 <Speck> esap, I see it as more general than just money, but the way we view worth in general
12:00:28 <pejo> CosmicRay, when you apply for a job - do you think "I hope the company gets the best person possible for the job" or "I hope I get the job so I can pay my bills"?
12:00:37 <CosmicRay> pejo: most economists and philosophers would say that competition is not only healthy but required in a capatalist society
12:00:45 <CosmicRay> pejo: and indeed there are laws to make sure it happens
12:00:53 <tuomov> in capitalist economics, "worth" is one-dimensional
12:00:58 <tuomov> and that's a problem
12:01:05 <Philippa_> bingo
12:01:05 <CosmicRay> pejo: "I hope I'm the best person possible"
12:01:13 <esap> pejo: It's more like "I hope the company is any good" :-)
12:01:19 <CosmicRay> esap: that too ;-)
12:02:01 <Philippa_> oh, that reminds me
12:02:08 * Philippa_ starts writing a mail to Conor
12:02:11 <Philippa_> (looong overdue)
12:02:56 <CosmicRay> pejo: I don't want to hold a job where I'm not the most qualified applicant anyway
12:03:21 <CosmicRay> pejo: I would be unhappy with a job that paid 2x my current salary if I found it to be boring or unproductive.
12:03:34 <CosmicRay> pejo: I'd rather accomplish something of value
12:04:10 <astrolabe> If you have free trade, worth has to be a one-dimensional quantitiy
12:04:15 <tuomov> being able to do something one thinks is worth something is important, but so is a non-authoritarian environment
12:04:30 <pejo> CosmicRay, sure, money is only useful to a certain extent. Once the basics are covered it's of questionable value. How many years wouuld you work without salary with those challenging questions that are fun and productive?
12:04:58 <Philippa_> astrolabe: no it doesn't
12:05:00 <Speck> is anyone here familiar with the text of "comprehending monads"? it appears that some of the terms have changed (e.g., unit is now called return it seems). But I can't seem to figure out what 'join' is analagous to.
12:05:01 <esap> Value and money are different.
12:05:06 <Philippa_> trade doesn't have to involve money
12:05:12 <CosmicRay> pejo: I didn't say I'd never take a boring/whatever job, just that I would be less happy there
12:05:34 <CosmicRay> pejo: obviously I would be happier having shelter and my wife and I not starving than having a fulfilling job
12:05:46 <astrolabe> Phillipa, but if it is free trade, it will involve money, because people are free to use it if they want to.
12:05:48 <jlouis> Speck: what is the type of ''join''?
12:06:07 <CosmicRay> pejo: otoh, I don't believe that GPL and "revenue" are antithetical
12:06:08 <Speck> M (M x) -> M x
12:06:18 <jlouis> @type >>
12:06:19 <lambdabot> bzzt
12:06:23 <CosmicRay> pejo: in fact, some companies are doing a great job of profiting from GPL'd software
12:06:25 <jlouis> @type (>>)
12:06:26 <CosmicRay> IBM for instance
12:06:26 <esap> @type join
12:06:27 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
12:06:28 <lambdabot> bzzt
12:06:37 <Philippa_> astrolabe: one of many dimensions
12:06:37 <CosmicRay> and IBM has even put a lot of GPL'd code out there themselves
12:06:53 <Philippa_> there's nothing preventing free barter
12:07:05 <tuomov> GPL just means you can't make money from replicating bits
12:07:11 <CosmicRay> no, it doesn't.
12:07:21 <Philippa_> it does in most situations in practice
12:07:29 <Speck> jlouis, doesn't seem to really fit. join is used, for example in the list monad, to [[1,2],[3] => [1,2,3], but it's generalized to all monads
12:07:31 <astrolabe> CosmicRay: but if half-life II were released under GPL...
12:07:33 <CosmicRay> GPL means that if you distribute the software, you must include all the original freedoms (which means the source and an acceptable license)
12:07:39 <pejo> CosmicRay, if they have a failed project they can always give out a couple of million lines of code under an open source license. "free" publicity since the costs are already paid.
12:07:40 <tuomov> you have to actually have some service to sell instead of cashing on work already done
12:07:44 <CosmicRay> I can completely legally charge you $3000 for a copy of a GPL'd program
12:08:01 <Philippa_> yes, and I can completely legally DL it for free. In practice, you won't sell any
12:08:02 <jlouis> Speck: I believe it is still called join
12:08:06 <CosmicRay> pejo: IBM has made some significant contributions to the linux kernel, for instance
12:08:18 <KrispyKringle> Philippa_: you'd sell the first copy :P
12:08:22 <Speck> jlouis, is it a monadic combinator?
12:08:35 <CosmicRay> Philippa_: of course you could.  but in practice, there are people that *do* sell GPL'd software
12:08:45 <tuomov> CosmicRay: aix is not failed?
12:08:49 <Speck> @type Monad.join
12:08:50 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
12:08:51 <seebyr> hm, "instance Eq Tr a where ..." ends up in "Syntax error in instance head (constructor expected)"... what's wrong? (Tr a is a binary tree of a defined using "data Tr a = Lf | Nd a (Tr a) (Tr a)"
12:08:59 <musasabi> Is MPL (mozilla public license) viral in any sense (the NSS library) ?
12:09:01 <Speck> ah, there it is
12:09:01 <Philippa_> Sure. But very few who make a sizeable amount of money by doing nothing but selling GPL software
12:09:05 <CosmicRay> tuomov: they're not contributing AIX technology to Linux, it's OS/2 technology....  oh wait....
12:09:08 <CosmicRay> :-)
12:09:22 * CosmicRay points to redhat
12:09:23 <esap> Selling GPL software is harder, because you don't get money for free.
12:09:24 <pejo> CosmicRay, as for IBM's profits - they don't have to make an OS to their hardware, something previously considered a cost. They're selling services, of course they want other people to make their software.
12:09:34 <Speck> musasabi, most mozilla stuff is triple-licensed, which means it is probably available in a BSD-like form too
12:09:36 <Philippa_> don't deadrat attempt to provide some kind of support?
12:09:51 <CosmicRay> Philippa_: sure.  could you really sell software without doing so?
12:10:01 <CosmicRay> well, M$ aside...
12:10:14 <Philippa_> yes. There're folks selling linux distros on CD for ~the distribution cost + time
12:10:22 <CosmicRay> pejo: they find it in their best interest to make publically-available contributions to linux
12:10:35 <pejo> CosmicRay, as for RH - a lot of their profit was from all the money they gained before the dot-com crash.
12:10:44 <CosmicRay> Philippa_: ok, sure, but they're not making $1000 per copy ;-)
12:10:56 <CosmicRay> pejo: I hear RHEL is doing well, for some strange reason
12:11:05 <Philippa_> Right. And you can't do that *just* by selling GPLed software. You sell software + support, which is a different game
12:11:09 <CosmicRay> I have no idea why people think RHEL is good for an enterprise, but oh well
12:11:21 <jlouis> Speck: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Monad.html#v%3Ajoin
12:11:31 <Speck> jlouis, thanks
12:11:31 * Philippa_ just wants to know how new projects are supposed to get bankrolled
12:11:35 <CosmicRay> Philippa_: you could apply the same argument to proprietary software, and conclude that no large proprietary company makes money selling just sfotware either
12:11:35 <pejo> CosmicRay, becuase RHEL sort of offers what the proprietary unix vendors have done for many years now. Almost atleast.
12:11:46 <Philippa_> especially startup
12:11:49 <CosmicRay> pejo: "crap"? ;-)
12:11:50 <tuomov> and selling services is honest business, (intellectual) property income is not
12:12:35 <Philippa_> CosmicRay: I think you'll find a lot of folks would happily pay for various kinds of software sans support for a reduction that doesn't necessarily drop things down to a fiver a pop
12:12:39 <CosmicRay> RH does not have any clue what it means to make an enterprise distro, imho.  debian is far more suitable
12:12:39 <pejo> CosmicRay, have you actually worked with system administration in a larger scale?
12:12:50 <CosmicRay> pejo: yes
12:12:58 <Speck> are monads in haskell still, as wadler described them, "strong monads in a cartesian closed category"
12:13:08 <pejo> CosmicRay, and you didn't find it worthwhile to pay for support?
12:13:42 <CosmicRay> pejo: hardware support, yes.  software support, less so.  I'd rather have an os that is stable to start with and internally fixable if there's a problem.
12:13:47 <esap> Speck: they added 'fail' to the Monad class.
12:14:04 <CosmicRay> An enterprise server OS should be of the type that you can turn it on and just let it be and it will Just Work
12:14:11 <CosmicRay> security updates shouldn't break anything
12:14:15 <tuomov> not all so-called admins are unix gurus, so backup support may be useful to have
12:14:29 <CosmicRay> tuomov: sure, and any number of companies will sell you that for any OS, including debian
12:14:38 <tuomov> yep
12:14:51 <CosmicRay> an OS upgrade shouldn't require an OS reinstall or more than a few minutes' downtime
12:14:55 <sbeyer> *grml*
12:15:01 <CosmicRay> it should also be replicable
12:15:10 <pejo> CosmicRay, so what do you do when you want this ancient release of AIX to support 16+Tb nfs shares? Oh, you call your vendor and they'll fix it.
12:15:17 * astrolabe wants some property income.  I'll have to get some property I suppose :(
12:15:31 <CosmicRay> pejo: more likely, you call your vendor and they: 1) ask "what's NFS?" 2) laugh
12:15:37 <CosmicRay> (#2 if you reach tier 2 support)
12:15:45 <sbeyer> *tryagain:)* <seebyr> hm, "instance Eq Tr a where ..." ends up in "Syntax error in instance head (constructor expected)"... what's wrong? (Tr a is a binary tree of a defined using "data Tr a = Lf | Nd a (Tr a) (Tr a)"
12:15:57 * CosmicRay has apparently placed one too many support calls in his time :-)
12:16:07 <tuomov> one nice thing about free software is indeed that it decentralises support also: anyone can put up a support shop and have full access to code
12:16:17 <tuomov> down with huge monopoly businesses
12:16:36 <pejo> CosmicRay, I don't share your experiences with the support. (And a friend worked for tier 3 support at IBM, he fixed exactly that).
12:16:45 <astrolabe> Who would voluntarily write software for really dull applications?
12:16:47 <norpan> sbeyer: you can't do an instance like that
12:16:53 <CosmicRay> I will grant you that IBM support is a good bit better than most
12:17:06 <norpan> sbeyer: instance Eq (Tr a)
12:17:10 <CosmicRay> pejo: however they had to send out two different techs just to figure out which drive in our RAID was dead
12:17:22 <sbeyer> norpan, thank you %)
12:17:27 <sbeyer> norpan, sometimes it's too easy ;)
12:17:33 <esap> astrolabe: There will always be a specialized niche for custom-built software.
12:17:48 <CosmicRay> pejo: and could not describe to me (relatively new to the "AIX way" [screwed up]) how to figure it out myself
12:17:57 <pejo> CosmicRay, sending out two guys doesn't take longer than one guy. They're still on site within a couple of hours.
12:17:59 <CosmicRay> die smitty die die
12:18:00 <astrolabe> esap:  I don't think that's what I'm talking about
12:18:07 <CosmicRay> pejo: I didn't say "on the same day"
12:18:25 <norpan> sbeyer: you proabaly will require equality on a, so: instance Eq a => Eq (Tr a)
12:18:41 <CosmicRay> pejo: it was some big mess, they had to coordinate between their hardware and software departments, escalate things, etc, etc.
12:18:43 <pejo> CosmicRay, haha. Sometimes you have bad luck with the support. Escalate your case to someone that can handle it. Sun just sends us new drives when they're broken.
12:18:44 <esap> astrolabe: oh, maybe I'm mixing two different discussions here :-)
12:19:04 <CosmicRay> pejo: yes, presumably sun hardware has a friendly light that tells you which drive is the bad one ;-)
12:19:11 <CosmicRay> pejo: our power64 box does not
12:19:24 <CosmicRay> pejo: sun may even have helpful os diagnostics
12:19:53 <jlouis> this is IBM. Errors can't happen in our presence
12:20:02 <pejo> CosmicRay, it depends. Ultra10's are just a slow PC, basically.
12:20:03 <CosmicRay> pejo: aix has os diagnostics that can spew out page upon page of numbers.  the problem is that the manual that describes how to interpret them exists only on some AIX support rep's desk in New York, inbetween "this page intentionally left blank" sections ;-)
12:20:47 <CosmicRay> in any case, our HP server (running Debian) popped a drive once.  The hardware and software both told me which drive it was.  We had the replacement installed by the following morning with zero downtime.
12:20:51 <pejo> jlouis, thats not my experience with IBM hardware though. Always a shitload of numerical stuff that you can look up in a big stack of papers somewhere.
12:21:08 <CosmicRay> this was also funny.  The IBM guys couldn't figure out amongst themselves whether or not we had to reboot the machine after replacing the drive
12:21:18 <pejo> Heh, ok. Obviously CosmicRay has found those numbers too.
12:21:22 <CosmicRay> hehe
12:21:44 <CosmicRay> so they insisted that we reboot the box to make sure everything was safe.
12:21:49 <CosmicRay> that sucked.
12:22:08 <pejo> CosmicRay, ugh. Sounds weird. You sure you're paying for your support? :-)
12:22:23 <CosmicRay> pejo: oh yes, I had our contract numbers memorized that week ;-)
12:22:33 <CosmicRay> (you *know* there will be more than one...)
12:23:25 <CosmicRay> pejo: don't you love how everything on IBM has an error message?
12:23:29 <CosmicRay> $ /bin/cat asdf
12:23:30 <CosmicRay> cathper: 0652-050 Cannot open asdf.
12:23:39 <CosmicRay> somewhere -- and who knows where -- there will be a paragraph on 0652-050.
12:24:01 <CosmicRay> err, that "hper" is obviously stray ;-)
12:24:36 <CosmicRay> I like this Network.Alt.
12:25:27 <Speck> hmm, monad comprehensions seem to only work with monads that define mzero
12:25:46 <CosmicRay> pejo: shall we now recount the many ways in which smit sucks? ;-)
12:25:58 <CosmicRay> around here is it spelled with an h...
12:26:18 <Speck> or, perhaps more precisely, are monoids
12:26:57 <pejo> CosmicRay, http://www.rz.uni-hohenheim.de/betriebssysteme/unix/aix/aix_4.3.3_doc/base_doc/nav/Books/nav_28.htm seems to have most values. I don't fiddle with IBM stuff professionally so I don't know where all the good information might be though.
12:27:12 <CosmicRay> pejo: 5.1L here though
12:28:02 <CosmicRay> oh goody:
12:28:04 <CosmicRay> http://www.rz.uni-hohenheim.de/betriebssysteme/unix/aix/aix_4.3.3_doc/base_doc/usr/share/man/info/en_US/a_doc_lib/aixprob/msgdnref/7digitrecov.htm#SSwAi262s17
12:28:18 <CosmicRay> the error message from cat turns out to be unique to cat
12:28:31 <CosmicRay> I am so pleased that ibm thought of that.
12:28:44 <CosmicRay> now I can "wait until downloading has finished" before trying cat again.
12:28:46 <CosmicRay> heh
12:28:51 <CosmicRay> ibm cracks me up
12:30:38 <pejo> CosmicRay, a friend described AIX as a floor of concrete which you can run a tank over and over again and it will still hold up, IRIX as a japanese paper house and Solaris somewhere in between. I'm convinced he's correct. ;)
12:31:20 <pejo> Oh well. This is drifting way OT, and it's bedtime for me. Nite!
12:32:01 <CosmicRay> pejo: hehe
12:32:03 * Speck ponders arrow comprehensions
12:32:10 <CosmicRay> pejo: that is frighteningly apt
12:32:22 <CosmicRay> aix is about as flexible as the concrete as well ;-)
12:37:37 <esap> stability is good.
12:45:20 <CosmicRay> yes it is
12:45:28 <CosmicRay> utility is good as well.
12:47:21 <esap> The trick is how to build systems that are both stable and flexible. Those two things are in some sense opposite.
12:47:40 <CosmicRay> yup
12:47:46 <CosmicRay> that's one reason I like debian
12:48:22 * esap agrees about Debian.
12:49:55 <mikehammad> does anyone know if template haskell syntax derives Typeable?
12:50:33 <astrolabe> Spec: Are you implying that monoid means monad with zero?
12:50:48 <Lemmih> mikehammad: Template Haskell Syntex?
12:50:55 <Lemmih> *Syntax?
12:51:01 <mikehammad> the data definitions for TH syntax, yes
12:51:09 <astrolabe> That would really suck I think, because monoid means something else in maths.
12:51:45 <Lemmih> mikehammad: Exp? Decl?
12:52:20 <Lemmih> s/Decl/Dec/ I must be tired.
12:52:28 <mikehammad> i probably need decl and exp
12:52:44 <mikehammad> but the hdocs i'm looking at don't mention anything about typeable
12:53:51 <Lemmih> Neither Dec or Exp are members of Typeable.
12:54:03 <mikehammad> doh
12:54:25 <Lemmih> What are you trying to accomplish?
12:55:00 <mikehammad> i'm writing a TH program that does a simple variable substitution on a term
12:56:50 <Lemmih> Why do you need Dec and Exp to be instances of Typeable?
12:57:14 <mikehammad> i'd rather not write the boilerplate to traverse them
13:00:01 <musasabi> CosmicRay: it appears that gnutls has at least some windows support.
13:01:13 <astrolabe> Has anyone written anything about formatting haskell?
13:04:38 <Philippa_> I've not really seen any explicit guidelines - I tend to use minimal indenting but line things up with the constructs they're attached to where relevant (and given sufficient horizontal space)
13:05:46 <astrolabe> Do you start a new line before or after 'where'?  Or both?
13:06:01 <Philippa_> usually before
13:06:19 <Philippa_> I'd do after if I needed the horizontal space badly enough, but only then
13:06:56 <Philippa_> sorta mirrors how I'd do an outermost-expression let
13:06:57 <astrolabe> Thanks.  and thanks for offering to explain something to me last night, I wondered why my computer was beeping at me, and I've just worked it out :)
13:07:03 <Philippa_> heh
13:07:17 <Philippa_> read enough of the papers to not want the quickie version?
13:08:17 <astrolabe> I suspect I haven't read enough to understand anything quick.  Reading papers suits me well, because I can repeat until it goes in.
13:10:13 <Philippa_> fair enough
13:10:28 <Philippa_> I'm good at quick intuitions, but they're not necessarily too helpful if you're lacking background
13:11:24 <Itkovian> evening
13:11:56 <astrolabe> hia
13:33:47 <shapr> @seen TheHunter
13:33:48 <lambdabot> I saw TheHunter leaving #haskell 19 days, 20 hours, 20 minutes and 1
13:33:48 <lambdabot> second ago, and I have missed 18 days, 5 hours, 20 minutes and 19
13:33:48 <lambdabot> seconds since then.
13:34:02 <shapr> Oh yeah, he's on his way to the USA.
13:35:02 <shapr> Has anyone else tried to do IO monadic quickcheck properties with QuickCheckM?
13:35:09 <shapr> Or any monadic properties?
13:40:43 * SyntaxNinja jumps over shapr on a unicycle
13:40:53 <SyntaxNinja> (shapr is on the unicycle, that is)
13:41:13 <shapr> No unicycling today, we had so much rain it flooded our building.
13:41:26 <shapr> It also killed internet for much of the day.
13:41:52 <SyntaxNinja> OMG! They killed the internet!
13:43:09 <kaol> gasp, we have to live without the intarweb?!
13:43:20 <CosmicRay> gasp, we have to live without gopher?!
13:44:27 * CosmicRay uploaded a new gopher to sid today.
13:44:31 <CosmicRay> so it's on my mind ;-)
13:44:52 <shapr> CosmicRay: Hey, I want you to write a column for TMR.
13:44:59 <shapr> "Pragmatic Haskell"
13:45:04 <CosmicRay> hmm, sounds interesting
13:45:25 <kaol> cool, firefox does gopher:// too. I remember trying mozilla sometime when it didn't.
13:45:28 <CosmicRay> my annoying 5-days-a-week summer semester class ends at the end of next week, too
13:45:35 <CosmicRay> kaol: yes, that bugged me for years
13:46:04 <CosmicRay> actually, firefox is about to support gopher *properly*, too ;-)
13:46:09 <CosmicRay> when version 1.1 comes out
13:46:20 <CosmicRay> at one point, mozilla displayed firefox as a global filesystem, which was cool
13:46:24 <CosmicRay> but they had it rather broken
13:46:31 <CosmicRay> you could also mount gopherspace in konqueror at one time
13:47:42 <CosmicRay> shapr: what do you think ought to be covered in such an article?
13:51:37 <shapr> CosmicRay: How to do useful everyday stuff with Haskell.
13:51:52 <shapr> I'd suggest starting with a tour of MissingH.
13:52:18 <shapr> I was happy to discover pipeFrom yesterday.
13:52:32 <shapr> I couldn't find os.command in the standard libraries.
13:55:16 <CosmicRay> shapr: That would be a lot of fun.  I've got myself convinced that MissingH is useful.  Might be nice to have others thinking that too ;-)
13:58:27 * CosmicRay disappears
14:03:22 <jdrake> what is the easiest way to bootstrap ghc? I am build in cygwin. The build guide does not seem to be available (404).
14:04:05 <musasabi> jdrake: first install a binary package then build from source.
14:06:30 <jdrake> I am not sure if that is really practical. The build environment looks like unix to the configure script and friends, but any ghc I download will think it looks like a windows default layout.
14:11:11 <astrolabe> jdrake: Do you have this? http://www.reed.edu/~carlislp/ghc6-doc/users_guide/sec-installing-bin-distrib.html
14:13:17 <astrolabe> @pl \x -> 'a' < x && ' h' > x
14:13:18 <lambdabot> (line 1, column 18):
14:13:18 <lambdabot> unexpected "'"
14:13:18 <lambdabot> expecting space or simple term
14:15:02 <kaol> @pl \x -> 'a' < x && 'h' > x
14:15:04 <lambdabot> liftM2 (&&) ('a' <) ('h' >)
14:15:12 <jdrake> astrolabe, i specifically need to build a source version for cygwin because I need to compile another package that must behave in the unix like environment.
14:15:15 <astrolabe> kaol: thanks
14:15:51 <astrolabe> jdrake: sorry, I don't know enough to help
14:16:37 <jdrake> thank you anyway
14:17:11 <astrolabe> Should I be able to use that liftM2 for that monad without importing anything except Monad?
14:17:35 <jdrake> Is there another compiler I can use to boostrap?
14:18:13 <Lemmih> jdrake: Why can't use GHC?
14:18:57 <jdrake> Lemmih, the binary of GHC is not a cygwin binary and I am building in a cygwin environment - they will not be compatible (the paths given to the binary will be wrong)
14:19:49 <Lemmih> Huh. You can use 'normal' Windows apps from cygwin just fine.
14:20:44 <jdrake> normal windows apps will not know about unix-like paths
14:20:57 <Lemmih> They don't have to.
14:21:54 <Lemmih> You just need a compiler that can compile Glasgow Haskell and the binary GHC for windows can do just that.
14:22:09 <shrimpx> hm what does @pl do?
14:22:25 <jdrake> i will try it then
14:22:31 <astrolabe> shrimpx: It converts functions to a 'pointless' form
14:22:36 <shrimpx> oh ok
14:22:41 * SyntaxNinja pokes shrimpx
14:22:44 <shrimpx> so nothing interesting
14:22:51 <shrimpx> SyntaxNinja: hi
14:22:57 <SyntaxNinja> @pl \x -> x + 1
14:22:58 <lambdabot> (1 +)
14:23:07 <astrolabe> @pl @pl
14:23:08 <lambdabot> (line 1, column 1):
14:23:08 <lambdabot> unexpected "@"
14:23:08 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
14:23:08 <lambdabot> expression
14:24:04 <Lemmih> @pl \x -> x * 2
14:24:05 <lambdabot> (2 *)
14:25:12 <wagle> http://moon.google.com/   zoom all the way in
14:25:15 <Lemmih> Uh, that's wrong.
14:26:00 <Igloo> It assumes some things are commutative
14:26:23 <wagle> @pl \x -> x - 1
14:26:24 <lambdabot> subtract 1
14:26:32 <shrimpx> lambdabot: @pl \x -> \y -> (x || y) && (y || x)
14:26:33 <lambdabot> liftM2 ap (((&&) .) . (||)) (flip (||))
14:26:37 <astrolabe> wagle: yeah it's cool
14:26:39 <wagle> @pl \x -> x `div` 2
14:26:40 <lambdabot> (`div` 2)
14:26:54 <shrimpx> pointfree style is ridiculous
14:27:03 <wagle> how does it know what commutes and what doesnt
14:27:15 <Igloo> It's hardcoded I believe
14:27:25 <liyang> Pointless!
14:27:26 <Igloo> shrimpx: It's sometimes clearer
14:27:27 <wagle> shrimpx: my understanding is that that is the point (of, uh, pointless)
14:27:34 <astrolabe> Shrimpx: I disagree
14:27:43 <shrimpx> astrolabe: some people do
14:27:53 <wagle> shrimpx: you mind isnt bent enough
14:28:08 <wagle> your
14:29:30 <SyntaxNinja> shrimpx: do you always use the 'do' syntax"
14:29:39 <shrimpx> no
14:30:00 <shrimpx> sometimes >>,>>= is more readable
14:30:24 <liyang> Also =<<
14:31:07 <shrimpx> then again i don't code all that much haskell :)
14:31:40 <liyang> And I've recently taken to using `ap` rather than lots of y <- x; let z = f y; sequences.
14:35:06 <astrolabe> What does "Warning: Pattern match(es) are overlapped" mean?
14:35:37 <metaperl> astrolabe: it sounds like 2 different guards could match on input data
14:36:39 <astrolabe> metaperl: thanks.  Yes, bug spotted.
14:36:42 <SyntaxNinja> astrolabe: the patterns might be out of order, from less specific to more specific
14:37:20 <astrolabe> SyntaxNinja: danker
14:37:50 <SyntaxNinja> astrolabe: no problem, just don't let it happen again ;)
14:37:53 <shrimpx> SyntaxNinja: i'm listening to the PADS talk right now =)
14:38:40 <SyntaxNinja> shrimpx: another one?
14:38:49 <shrimpx> pretty much the same thing
14:39:09 <shrimpx> the talk she gave at galois was being prepared for this summer school
14:39:26 <SyntaxNinja> I only went to the first talk, wantd to go to the 2nd, but too far from my project to bill it.
14:40:16 <shrimpx> heh
14:40:28 <SyntaxNinja> I wonder if she has seen parsec; I don't really know her background
14:40:58 <shrimpx> that was suggested a minute ago; she thinks parsec is fundamentally different but i disagree
14:42:04 <SyntaxNinja> oh, you're in a talk right now? heh
14:42:11 <SyntaxNinja> you should take questions from the IRC channel
14:42:18 <shrimpx> haha
14:44:35 <shrimpx> i asked about parsec =)
14:44:38 <shrimpx> she doesn't knwo what it is
14:44:57 <shrimpx> but she's familiar with parser combinator libs
14:45:02 <astrolabe> Storm out!
14:45:22 <shrimpx> scientists putting bread on the table... we all do it =)
14:49:02 <SyntaxNinja> ah, so she should look at parsec. I mean, it doesn't solve her problem at all, but she might derive some inspiration
15:09:30 * Speck packs up and leaves work
15:37:37 <shapr> oh YEAH?
15:38:27 * jyp is scared
15:38:54 <shapr> hiya jyp, how's code?
15:39:37 <jyp> Fine I guess... I submitted some emacs-yi stuff to dons
15:40:28 <shapr> Oh is it in the repo yet?
15:40:30 * shapr pulls
15:40:31 <jyp> Today is Belgium 175 anniversary celebration, so rejoince, everyone :)
15:40:41 <shapr> yay!
15:40:47 <jyp> He said he'd put in at 'bout 10
15:41:10 <jyp> Emacs2
15:41:19 <shapr> spiffy
15:41:31 <shapr> Does it support nested keystrokes?
15:41:38 <shapr> Oh, I want to see, is your repo http accessible?
15:41:56 <jyp> I'm not http-enabled :/
15:41:57 <shapr> I'm particularly unhappy with emacs the last week.
15:41:58 <shapr> aww
15:42:11 <jyp> It's very basic yet
15:42:30 <jyp> I did the most simple thing I could imagine in order to build up on that
15:42:44 <shapr> If it's easy to bind new keys, I'll be thrilled.
15:42:50 <jyp> What would you mean by nested keystrokes ?
15:42:58 <shapr> I've never gotten around to doing much for yi.
15:43:00 <jyp> It should be easy
15:43:02 <shapr> Stuff like C-c C-x
15:43:41 <jyp> rebinding, it was one of my goals
15:43:46 <shapr> ah, excellent
15:44:22 <jyp> If you want I can forward the patch to you
15:44:25 <shapr> yes please!
15:44:30 <shapr> shae@ScannedInAvian.com
15:44:48 <shapr> Though I have nasty TMDA spam protection.
15:47:53 <shapr> I got it, and have applied it.
15:47:58 * shapr check it out.
15:48:32 <jyp> I just uploaded it there in any case: http://users.skynet.be/jyp/patch
15:49:04 <shapr> Oh, that's nice.
15:49:38 <jyp> You're welcome
15:49:39 <shapr> I think [ ("C-x k", killBuffer) , ... ] will be great.
15:50:01 <shapr> What you have now is quite usable though.
15:50:04 <jyp> It's just a matter of writing a parser for keys
15:50:30 <jyp> I still have problems with meta keys
15:50:38 <shapr> why?
15:50:48 <shapr> What's the problem?
15:50:59 <jyp> I don't get the keystrokes at the expected time
15:51:16 <jyp> for example, if I type M-x:
15:51:22 * shapr tries it
15:51:45 <jyp> I get '\ESC', but 'x' is delayed till the next keystroke
15:52:04 <jyp> I don't have any idea why
15:52:12 <shapr> Strange
15:52:18 <shapr> dons will probably know.
15:52:30 <shapr> Do you use 'make' to build the keymap?
15:52:53 <jyp> I think so; it get compiled in yi-static
15:53:07 <jyp> yi-static --as=emacs2
15:53:10 <jyp> or something
15:53:20 * shapr rebuilds
15:56:40 <shapr> Foo, I get the same error.
15:57:00 <shapr> Yi.hs:38:0: \n Failed to load interface for `Yi.Keymap.Emacs2': \n Could not find module `Yi.Keymap.Emacs2': \n it is not a module in the current program, or in any known package.
15:57:23 <shapr> Do I need to add Emacs2 to the Makefile or yi.conf ?
15:57:39 <jyp> Yes... to yi.conf
15:57:40 <shapr> ah, maybe ExposedModules?
15:57:43 <jyp> I forgot
15:58:08 <jyp> along with the other keymaps
15:58:34 <shapr> yay!
15:58:38 * shapr boings happily
15:58:50 <jyp> I didn't put that in the patch because it was hacked & slashed to heavily here
15:59:11 <jyp> :)
15:59:29 <shapr> Next Yi needs some convention for eval'ing inline Haskell, like doing C-x C-e at the end of (global-set-key ...)
16:00:30 <jyp> yup
16:00:44 <jyp> "eval" is supported in hs-plugins, isn't it ?
16:00:59 <jyp> ...since our bot friend seems to show
16:01:18 * jyp reflects at his poor grammar
16:01:48 <shapr> Yes, it's supported. But how to call inline code?
16:02:55 <jyp> Isn't it just a special case? Or is there something I miss ?
16:03:04 <jyp> What do you want to do exactly ?
16:04:30 <shapr> I want to rebind keys from inside Yi
16:05:25 <jyp> I would suggest replacing the command by in the KList by its name (string)
16:05:32 <jyp> and use eval everytime
16:06:56 <jyp> Slow perhaps ... but workable till hs-plugins becomes more clever
16:07:35 <jyp> Or maybe too slow for practical use... I got no idea
16:07:55 <shapr> I don't know either, but I'll try it.
16:13:42 <thedward> there is eval for Haskell?
16:14:19 <jyp> @plugs sum [1..100]
16:14:25 <lambdabot> 5050
16:14:47 <jyp> it's very much like it
16:14:48 <jyp> :)
16:20:27 <wagle> @plugs dim sum
16:20:28 <lambdabot> Variable not in scope: `dim'
16:21:06 <jyp> nice :)
16:21:34 <shapr> @plugs dim sum "rice!" where dim = \x y -> map sum $ Data.Char.ord y
16:21:35 <lambdabot> parse error on input `where'
16:21:38 <shapr> whoops
16:22:05 <wagle> where not supported..  let is, though
16:22:30 <shapr> @plugs let dim x y = sum $ map Data.Char.ord y in dim sum "rice!"
16:22:31 <lambdabot> 452
16:23:35 <jyp> @plugs let dim x y = x $ map Data.Char.ord y in dim sum "rice!"
16:23:36 <lambdabot> 452
16:23:41 <jyp> maybe
16:23:59 <shapr> oh right
16:24:04 <jyp> ;)
16:24:13 <shapr> @pl dim x y = x $ map Data.Char.ord y
16:24:14 <lambdabot> dim = (. (((map Data . Char) .) . ord))
16:24:32 <jyp> omfg
16:24:32 <wagle> @pl (\x -> (x `div` 10) * 100 + 100 `div` 2 + (x `rem` 10)
16:24:33 <lambdabot> (line 1, column 55):
16:24:33 <lambdabot> unexpected end of input
16:24:33 <lambdabot> expecting variable, "(", operator, "+", "-" or ")"
16:24:41 <shapr> @plugs let dim = (. (((map Data . Char) .) . ord)) in dim sum "rice!"
16:24:42 <lambdabot> Data constructor not in scope: `Data'Data constructor not in scope: `
16:24:42 <lambdabot> Char'
16:24:42 <wagle> @pl (\x -> (x `div` 10) * 100 + 100 `div` 2 + (x `rem` 10))
16:24:43 <lambdabot> liftM2 (+) ((50 +) . (100 *) . (`div` 10)) (`rem` 10)
16:24:49 * shapr laughs
16:25:19 <wagle> let answer = liftM2 (+) ((50 +) . (100 *) . (`div` 10)) (`rem` 10) in answer 42
16:25:42 <wagle> @plugslet answer = liftM2 (+) ((50 +) . (100 *) . (`div` 10)) (`rem` 10) in answer 42
16:25:43 <lambdabot> Unknown command, try @listcommands.
16:25:58 <wagle> @plugs let answer = liftM2 (+) ((50 +) . (100 *) . (`div` 10)) (`rem` 10) in answer 42
16:25:59 <lambdabot> <Plugins.Eval>:1:
16:25:59 <lambdabot>   No instance for (Monad ((->) a))
16:25:59 <lambdabot>   arising from use of `liftM2'
16:26:05 * wagle kicks lag
16:27:02 <jyp> Man, we'll soon be able to tell jokes exclusively in @pl & @plugs
16:28:04 <shapr> truly :-)
16:28:30 <jyp> besides that, any comment on my Emacs2.hs ?
16:28:48 <shapr> I like it.
16:29:00 * jyp likes to hear that
16:29:23 <shapr> The error messages are fun too.
16:29:28 <shapr> readArg' _ _ [] = error "readArg': holy crap"
16:29:37 <shapr> insertNextC _ _ _ = error "dont bug me"
16:29:54 <jyp> really, this -Wall -Werror is annoying :)
16:30:18 <thedward> @plug 5
16:30:20 <lambdabot> 5
16:30:25 <thedward> @plug let uniq (x:xs) = ( x : ( filter (\y -> y /= x) ( uniq xs ) ) ); uniq [] = []  in uniq "abracadabra"
16:30:26 <lambdabot> "abrcd"
16:30:30 <shapr> I'm still not sure why meta doesn't work.
16:30:34 <shapr> Or, works with a delay.
16:31:05 <jyp> Must be in the lower layers...
16:31:13 <shapr> I'd like to have a 'pretty names' module that gives verbose names to quitE insertE downE etc.
16:31:27 <shapr> And I'd like to have some way to get rid of liftC
16:31:36 <shapr> That would simplify the keymap.
16:32:07 <jyp> well most usages of liftC will be wrapped in the actual commands in the future
16:32:19 <shapr> Maybe only let the keymap hold Actions and always apply liftC?
16:32:55 <jyp> they need to support argument (C-u) and other stuff unfortunately
16:33:02 <shapr> Yeah, true.
16:33:33 <shapr> Still, normalKlist looks like what I expect to see in an emacs keybinding list.
16:34:23 <jyp> Yeah well, everything that's there should be given a name (emacs-compliant ideally)
16:34:36 <shapr> Yeah, I agree.
16:34:38 <jyp> and put in some module for users to pick from
16:34:48 <jyp> but I got lazy at that point :p
16:34:53 <shapr> I understand :-)
16:35:06 <shapr> distribute the minimum usable code and then see what other people contribute.
16:35:17 <jyp> good idea :)
16:35:25 <jyp> we'll see what dons says
16:36:28 <wagle> @plug map (chr . (+1) . ord) "hal"
16:36:30 <lambdabot> "ibm"
16:36:49 <jyp> Also, do you also think CPS should be replaced by monadic stuff ?
16:37:27 <wagle> @type call-with-current-monad
16:37:29 <lambdabot> bzzt
16:38:05 <wagle> isnt >>= already MPS?
16:38:07 <shapr> I don't know.
16:38:56 <jyp> I think it should, but I'm afraid of the possibe loss of lazyness
16:39:10 <jyp> and induced "memory leaks"
16:44:09 <jyp> Well I think I'll just try it while the code base is still tiny
16:47:24 <Pseudonym> Greetings.
16:47:47 * jyp bows
16:51:22 <shapr> g'day Pseudonym
17:01:20 <jyp> gnite folks
17:19:21 <palomer> what happens to types of terms when they're CPSified
17:22:40 <palomer> s/to types/to the types
17:23:27 <Pseudonym> I believe (not sure) that type A becomes forall b. (A -> b) -> b
17:23:29 <Pseudonym> But I could be wrong.
17:29:05 <wagle> @type \k -> k 1
17:29:07 <lambdabot> forall t t1. (Num t1) => (t1 -> t) -> t
17:29:28 <wagle> @type 1
17:29:30 <lambdabot> forall t. (Num t) => t
17:29:46 <wagle> looksm like it
17:45:53 <shapr> Anyone else here uses MissingH?
17:46:03 <shapr> Shouldn't this work? --> (pid1,result1) <- pipeFrom "/usr/bin/dc" ["--expression='1 1 + f'"]
17:46:17 <shapr> result1 ends up being "''' (047) unimplemented\n2\n''' (047) unimplemented\n"
17:46:21 <shapr> instead of "2"
17:50:16 <shapr> How do you guys get the output of an external command?
17:54:45 <shapr> Hm, seems to be a problem only with dc.
17:56:50 <autrijus> shapr: runInteractiveProcess
17:57:59 <shapr> thanks
17:58:27 <shapr> I think dc doesn't like to be run in batch mode.
18:02:31 <shapr> Oh wait, I do get the answer, between two lines of unimplemented.
18:15:10 <dons> you're using dc to do math from haskell?
18:15:48 <shapr> Sort of. You remember the math error in GHC? I want to test GHC Math against dc.
18:15:55 <shapr> That's my QuickCheck IO prototype test.
18:16:02 <dons> ah ha!!
18:16:24 <dons> mm. and dc isn't linked against libgmp either, so that's good
18:16:39 <shapr> IO QC Properties will kick butt, but first I have to write a user's guide.
18:17:03 <shapr> In fact, once I get it figured out I'll use it to test my Zope code too.
18:17:27 <dons> please! quickcheckM was kinda really undocumented, if i recall.
18:17:39 <shapr> Yeah, I thought so too, but I've grown tired of waiting.
18:17:50 <dons> good good
18:18:01 <shapr> Hey, what do you think of jyp's Keymap?
18:18:18 <dons> seems nice and clean.
18:18:26 <dons> it's in the yi repo now
18:18:33 <shapr> Also, any ideas for interactive eval? What about eval selected region or something?
18:18:53 <dons> selected region would be easy, though we'd need marks first
18:19:15 <dons> eval via compiled System.Eval should work -- i had a prototype going a few months ago
18:19:33 <dons> i'll get a chance soon I think to work on this
18:19:39 <shapr> Spiffy.
18:19:55 <dons> of course, you can always just edit Config.hs and hit :reload
18:20:01 <dons> or even :reboot
18:20:04 <shapr> Yeah, true.
18:20:09 <dons> but maybe that's not yet bound in the emacs mode
18:20:17 <shapr> Easy to fix though
18:20:25 <dons> yep
18:20:26 <shapr> And synhl is really the next big chunk.
18:20:53 <dons> yeah. i'm hoping dcoutts gets interested enough in hide2 to start hacking on yi ..
18:20:58 <shapr> I think Yi will really take off when it has synhl. It's a lot of work though.
18:21:56 <dons> ah, not so much, at least for just one language.
18:22:09 <dons> we're still getting new contributors, which is good
18:22:42 <dons> also, I'd like at least one of the basic non-lisp emacs interfaces done.
18:22:47 <dons> like the `mg' editor's interface.
18:23:13 <dons> just emacs bindings, no elisp, then people can use Yi without caring about vim or emacs
18:23:22 <shapr> What's mg?
18:23:30 <dons> you should read the Yi paper ;)
18:23:37 <shapr> I did, but I don't remember mg.
18:23:40 * shapr looks again
18:23:44 <dons> it's a very fast emacs clone written by the bsd hackers
18:24:03 <dons> mg - emacs-like text editor
18:24:06 <shapr> Oh, I remember, I had problems with yi.ps
18:24:17 <dons> oh?
18:24:20 <dons> what about yi.pdf?
18:24:29 <shapr> yi.pdf works fine.
18:24:43 <dons> what was wrong with yi.ps?
18:24:45 <shapr> Lemme try to download yi.ps again to see if it's just a temporary error.
18:25:19 <shapr> Ok, never mind :-)
18:25:20 <metaperl> shapr: thanks for setting up my darcs repo. This darcs thing is infectiously easy to use :)
18:25:25 <shapr> metaperl: Yeah, darcs r0xx
18:25:30 <dons> hmm. in fact, maybe I could whip up an mg binding today. seems pretty easy
18:26:11 <shapr> I'll send in a pretty names patch if I get around to it.
18:26:54 <dons> hey shapr, i'm coming over to europe in september, btw
18:27:06 <shapr> Emacs users are used to verbose names, save-buffers-kill-emacs for example.
18:27:08 <shapr> Which part?
18:27:17 <dons> estonia, and surrounds, I guess
18:27:18 <shapr> I may be moving soon...
18:27:33 <shapr> Ah yeah, ICFP et al.
18:27:36 <dons> yep
18:27:54 <shapr> Are you guys hanging around any before or after ICFP?
18:28:07 <dons> I plan to hang around for a week or two after
18:28:13 <shapr> Oh nifty
18:28:19 <dons> just got to work out where to go!
18:28:19 <shapr> Any plans for that week or two?
18:28:27 <dons> not yet
18:28:31 <shapr> Want to learn to unicycle? :-)
18:28:38 <shapr> Do some pair programming maybe?
18:28:48 <dons> hey, that would be pretty fun :)
18:28:52 <dons> maybe we could get yi done.
18:28:57 <shapr> Yeah, that would be nice.
18:29:04 <metaperl> pair programming sounds much safer than unicycling :)
18:29:18 <shapr> I'm much more productive in a pair programming situation.
18:29:29 <shapr> group flow and all that.
18:29:40 <shapr> metaperl: C'mon, you haven't even tried unicycling!
18:29:52 <metaperl> when I was young I tried it
18:29:56 <shapr> And?
18:30:03 <dons> yeah. during the icfp contest we found pair programming quite useful.
18:30:03 <Beelsebob> unicycling's very safe
18:30:12 <shapr> dons: It's a ways from .ee to .se
18:30:18 <metaperl> it was fun. I just remember that French guy jumping off that 30 foot slope
18:30:22 <dons> oh it seems so small on the map :}
18:30:30 <Pseudonym> Pair programming can get you beaten up.
18:30:37 <Beelsebob> and believe it or not I have injured myself worse programming
18:30:38 <shapr> Might be easier/cheaper to have a surprise EuroHaskell at chalmers.
18:31:03 <shapr> I'm somewhere between 800 and 1000 km north of Chalmers.
18:31:12 <dons> oh! that far.
18:31:21 <dons> cold cold north
18:31:21 <shapr> And Chalmers is quite a ways northwest of ICFP.
18:31:39 <dons> mm. a EuroHaskell would be good.
18:31:45 <shapr> Does lambdabot convert long,lat pairs into distance?
18:31:56 <dons> no, is there a site to do this?
18:31:59 * shapr dunno
18:32:05 <dons> sounds like a good plugin
18:32:07 * cm shapr
18:32:33 <Pseudonym> I have a book on my bookshelf entitled "Geodesy and map projections" if you care.
18:32:48 <dons> :)
18:33:00 * shapr cm
18:33:03 <cm> :)
18:33:20 <dons> shapr, i'll look into maybe getting to chalmers
18:33:48 <shapr> Awright. There's a possibility I'll be elsewhere by September, not sure.
18:33:49 <dons> shapr, did you know peteg is back in sydney
18:34:13 <dons> so I can pester him personally about any haskell code of his that isn't online
18:34:23 <shapr> I knew he was back in .au, but I don't really know how or why. But then, it's not my business anyway....
18:34:52 <dons> heh
18:34:52 <shapr> Oh, I got him to send me the code for his lucid/synchrone project.
18:35:11 <shapr> I wish he'd update PLog too :-) I broke my local copy somehow...
18:35:18 <dons> maybe I can give my darcs talk again, and get him to use darcs
18:35:29 <shapr> Hey, good idea. Everyone should use darcs!
18:35:52 <shapr> I think a good Haskell blog for me would be a simple mapping from wiki format to RSS.
18:36:17 <Pseudonym> Speaking of wiki format, how's FLM coming?
18:36:20 <shapr> I've noticed that RSS is the new browser/email mix for blogs at least.
18:36:21 <Pseudonym> Have you done anything recently?
18:36:26 <shapr> Well, no :-)
18:36:32 <shapr> Still almost done.
18:37:11 <shapr> I would say soon, but I dunno.
18:37:11 <shapr> I
18:37:24 <Pseudonym> You could write a TMR article about it, then margin-note the article with FLM.
18:37:35 <shapr> How about I release whatever I've got next weekend and ask for users to help finish whatever isn't? :-)
18:37:38 <Pseudonym> :-)
18:37:58 <shapr> I do get regular requests for a copy of FLM, so I'm sure it'd have some users at least.
18:38:37 <dons> GHC performance issues page: http://www.haskell.org/hawiki/GhcPerformance
18:38:41 <shapr> hey TheHunter!
18:38:56 <TheHunter> evening everybody.
18:39:00 <shapr> TheHunter: How's the new place?
18:39:05 <Speck> wb TheHunter
18:39:06 <dons> hey TheHunter!
18:39:17 <shapr> Can I ask you about QuickCheckM? :-)
18:39:26 <TheHunter> it's ok, i guess. Gotta get the air conditioning working...
18:39:43 <shapr> Have you met any cool people yet?
18:40:15 <TheHunter> well, i moved in just about 20 minutes ago, and i
18:40:15 <dons> where are you now, TheHunter?
18:40:21 <TheHunter> 'm dead tired, so no.
18:40:33 <TheHunter> i'm at msu now.
18:40:39 <TheHunter> michigan state.
18:41:02 <dons> hehe! so I can't come and pester you in .de after all
18:41:27 <TheHunter> you're going to .de?
18:41:35 <shapr> TheHunter: Any excitement flying and/or getting set up?
18:41:41 <dons> europe in sept.
18:42:00 <dons> just trying to come up with a list of people to see and places to go
18:42:16 <dons> TheHunter, what are you up to at msu?
18:42:45 <TheHunter> flying is pretty boring and i couldn't sleep because some mother couldn't control their children.
18:43:08 <TheHunter> doing mathematics, topology stuff.
18:43:36 <aheller> what kind?
18:43:59 <TheHunter> not completely decided yet
18:45:35 <TheHunter> for now, i just have to do an english course.
18:45:48 <TheHunter> s/do/attend/
18:45:56 <shapr> Your IRC english is just fine :-) How's your spoken english?
18:47:10 <dons> TheHunter should get #haskell karma for logging on to irc 20 mins after moving in :)
18:47:11 <TheHunter> i think it's ok. But they wanna be sure because I'll prolly be a teaching assistant
18:47:15 <dons> @karma+ TheHunter
18:47:16 <lambdabot> TheHunter's karma raised to 3.
18:48:50 <shapr> dons: 956 km between Chalmers and my apartment. 678 km between Chalmers and Tallin. 651 km between me and Tallin.
18:48:58 <shapr> @karma+ TheHunter
18:49:00 <lambdabot> TheHunter's karma raised to 4.
18:49:15 <shapr> I can never connect the cables that quickly, I always lose something.
18:49:58 <dons> oh, so you're much closer to estonia than chalmers!
18:50:09 <dons> s/than you are to chalmers/
18:50:18 <shapr> Yeah, weird. I didn't know that.
18:50:37 <shapr> Too bad international flights always go via Gothenburg or Stockholm.
18:50:48 <dons> right.
18:51:11 <shapr> I've been thinking about optimizing that sort of thing in general.
18:52:11 <shapr> For example, if you have a mobile phone and a destination, you could use an interactive app to find your choice of tradeoff between time and payment.
18:52:29 <shapr> Basically, bus and taxi services could be the same thing if everything was dynamically scheduled.
18:52:39 <dons> that would be really useful, and something that would benefit from automation
18:53:50 <shapr> Rather than having set routes, you say where you want to go, when you want to go, how much you're willing to pay, and a fudge factor.  Then the system comes back with 'peak' times and how much each will cost you.
18:54:23 <shapr> At one extreme you pay lots for a taxi for one right now, at the other extreme you pay almost nothing for a bus whenever there are enough people.
18:55:09 <dons> yep. so the problem would be just getting accurate data from the operators of the transit systems, I reckon
18:55:37 <shapr> The same thing applies to mobile phones as well, I wanted to start a metropolitan ISP here, where you give away free wireless where source and destination are inside the metro net, but you pay for traffic that goes into the 'net proper.
18:55:56 <shapr> Then you also sell wifi-talkies :-)
18:56:13 <shapr> Most of the people I call are inside the city.
18:57:00 <shapr> That would kill the big monopolies here.
18:57:07 <dons> mm. that's cool. i had an idea for a wifi phone using an arm processor on a little linux card-sized board we have here at unsw
18:57:10 <shapr> Wouldn't work in .au though, too much open space.
18:57:18 <dons> well, not outside of sydney
18:57:46 <shapr> In heavily urbanized areas, a packet could jump among metro nets to the destination. It wouldn't be fast, but it would be free.
18:58:02 <dons> yeah. so a lot lot cheaper than mobile rates
18:58:25 <dons> which must charge 100s of $ per gigabyte, considering the cost of sms
18:59:17 <shapr> Oh, I thought of a way to kill the MPAA and the RIAA, just put wifi onto all the digital music players, with the default settings being all files accesible read-only. If you include a keyword searching app, then people have the darcs model of p2p music sharing, no wires required.
18:59:58 <aheller> doesn't itunes do that with whatever rendevouz is called now on laptops?
19:00:15 <shapr> I don't know, I've never used itunes, rendevouz, or owned a laptop.
19:00:27 <hyrax42> aheller, yes
19:00:30 <aheller> ah.  striking out there, then.
19:00:31 <aheller> :)
19:00:32 <hyrax42> but cripled more and more
19:00:38 <hyrax42> with each . release
19:01:04 <shapr> wifi on the player would be the biggest change, but would require hackable players.
19:01:20 <shapr> That's the biggest block right now. I *wish* my iriver were hackable, I could do so much more!
19:01:30 <dons> as seen on darcs-devel@: Mentioning mapM_ always impresses people at dinner parties
19:01:38 * shapr snickers
19:02:11 <shapr> TheHunter: Are you going to keep a blog of your adventures? I'd definitely read it.
19:02:20 * shapr suspects TheHunter is already asleep.
19:06:43 <Speck> that or moving more stuff
19:10:39 <TheHunter> yes, i was moving stuff. But I gotta go to bed now. See you soon.
19:11:34 <shapr> Too bad I can't derive Arbitrary for simple types.
19:12:38 <autrijus> doesn't DriFT do that for you?
19:12:57 <shapr> Probably, but I've never gotten around to learning DriFT
19:13:26 <autrijus> and it doesn't.
19:13:55 <shapr> I think I could hack the Template Haskell deriving code from SerTH to do Arbitrary as well.
19:14:10 <shapr> Yeah, that would definitely work.
19:14:30 <autrijus> cool
19:14:45 <autrijus> although if you do that, the same thing can be used as a DriFT template as well.
19:14:53 <shapr> Hm, neat.
19:24:16 <shapr> I'd like to have somefunc x = error ("somefunc can't handle" ++ show x) as my fallthrough cases for all of my pattern match functions, is there someway I can use a default show instance if nothing exists?
19:26:19 <shapr> By the way, excellent legal live music torrents here: http://bt.etree.org/
19:26:24 * shapr goes back to Haskelling
19:26:33 <shapr> Hiya neilc
19:26:36 <shapr> How's code?
19:27:02 <neilc> hey shapr
19:27:16 <neilc> pretty good, although i need to use C at the moment...
19:27:26 <shapr> Can you generate it from Haskell? :-)
19:27:38 <neilc> heh, unfortunately not
19:27:59 <neilc> (modifying a 250,000 LOC C application, so... :) )
19:29:21 <shapr> Yow, what does it do?
19:29:45 <neilc> it's postgres
19:29:53 <neilc> i.e. implements an rdbms
19:29:57 <shapr> Oh. Well, that's interesting.
19:31:06 <shapr> Are you doing something cool to postgres?
19:31:41 <neilc> i think so, at any rate :)
19:31:51 <neilc> implementing a prototype of a synchronous multimaster replication system
19:31:59 <shapr> Oh, that *is* cool.
19:32:08 <shapr> I desperately wanted that a few years back.
19:32:14 <shapr> Specifically for postgres.
19:32:18 <neilc> ah, cool
19:32:28 <neilc> yeah, we've needed a good MM system for a while
19:32:34 <neilc> it's a fair bit of work, tho :)
19:32:52 <aheller> is that thing I was looking at earlier today?  http://pgcluster.projects.postgresql.org/ ?
19:33:01 <shapr> My coworker and I ended up doing something incredibly hackish instead.
19:33:24 <neilc> aheller: nope, www.slony2.org (not much info there yet, unfortunately)
19:33:36 <neilc> aheller: this is still pre-pre-alpha, so...
19:33:46 <neilc> shapr: heh, yeah, a lot of replication stuff gets done that way
19:34:28 <aheller> neilc: still quite neat.
19:35:09 <neilc> aheller: the pgcluster stuff? yeah, i guess, i haven't looked at it much
19:35:25 <neilc> shapr: what are you working on, btw?
19:36:21 <aheller> neilc: I meant that you're making your own, but the pgcluster stuff is neat too :)
19:36:49 <neilc> aheller: ah :)
19:39:52 <shapr> neilc: Getting QuickCheck to do IO properties at the moment.
19:42:36 <neilc> shapr: ah, cool -- yeah, quickcheck seemed neat
19:54:18 <cm> "For the nerds in the audience, ? combines Java, PHP/MediaWiki, and AJAX in order to offend as many developers as possible in a single go."
19:54:48 <aheller> * shudder *
19:56:28 * autrijus ponders QuickCheck for QuickBasic
19:57:05 * autrijus dismisses it as a futile idea
19:59:39 <shapr> It's amazing how quickly you can fill up a drive with bittorrent and etree.org.
20:01:04 * autrijus resists a /dev/random joke
20:01:36 <shapr> Yeah, but it's no fun to listen to dev/random while coding.
20:01:52 <autrijus> very true
20:02:05 * autrijus is finally adding Arbitary instances to PIL nodes
20:02:10 <shapr> ooh!
20:02:22 <autrijus> "SYB with class" finally convinced me
20:02:27 <autrijus> the "shrink" declaration is too good.
20:02:37 <shapr> SYB has a QuickCheck shrink declaration??
20:02:38 <shapr> wha?
20:02:44 <autrijus> see that paper.
20:02:46 <autrijus> it's amazing.
20:03:06 <autrijus> it's about using SYB to write Arbitary instances that can do generic shrinking.
20:03:12 <autrijus> and user-extensible too.
20:03:21 * shapr looks
20:03:23 <autrijus> it's design pattern at its finest.
20:03:59 <shapr> Wow, awesome!
20:04:04 <autrijus> took me 3hr of re reading the three SYB papers for the idea to fully sink in
20:04:07 <autrijus> but it's awesome.
20:04:16 <shapr> Too bad there isn't an actual version of QuickCheck with Shrink.
20:04:21 <shapr> I guess it's time to fork my own.
20:04:43 <autrijus> SYB3.zip has Shrink.hs
20:05:02 <autrijus> you may find that useful
20:05:16 <autrijus> yeah, I'd be happy to see a QuickCheck adapter that makes use of it -- have you prodded the QC team?
20:06:05 <shapr> I've prodded them repeatedly to get something released.
20:06:13 <shapr> I'll do it one more time, and then I'll fork my own.
20:06:31 <autrijus> to no avail?
20:06:35 <shapr> Greetings nowl, learning Haskell?
20:06:46 <nowl> yep
20:07:19 <shapr> Koen said that QC2 wasn't ready for release, and that they wanted to write a tutorial for the QCm parts, and that he might make a release when  the term was over, since he wanted to use the Chalmers students to work out the bugs.
20:07:24 <shapr> nowl: Got any questions?
20:07:57 <nowl> shapr: not yet, thanks for asking though
20:08:01 <sh10151> It is 11:08; ABS, ALPHABETIC, ARCSIN,  ARCCOS, ARCTAN.
20:08:34 <shapr> yow, it's 5am
20:08:40 <autrijus> it is 11:08 here.
20:09:00 <shapr> I have too many papers open.
20:09:15 <autrijus> ditto.
20:09:19 <autrijus> lyf so short etc
20:09:28 <Pseudonym> Can't buy time.
20:09:32 <shapr> I want that on a tshirt.
20:09:43 <autrijus> what on a tshirt? "can't buy time?"
20:09:48 <shapr> I think the pragprog guys were going to print tshirts with that slogan, did they ever do it?
20:09:50 <shapr> lyf so short
20:09:54 <autrijus> ah.
20:10:21 <hyrax42> sun up yet, shapr
20:10:23 <hyrax42> :o
20:10:25 <hyrax42> ?
20:10:48 <Pseudonym> "I have no time!"  -- Evariste Galois
20:11:00 <shapr> Yeah, we only have an hour or two of dark at the moment.
20:11:12 <hyrax42> dark or dusk?
20:11:15 <hyrax42> or twilight
20:11:33 <Pseudonym> Mind you, the night that Galois wrote that was probably the most productive all-nigher in mathematical history.
20:11:40 <Pseudonym> nighter
20:11:41 <shapr> It was real dark tonight, but that might be from the clouds.
20:14:05 <hyrax42> well I should best go to sleep
20:14:18 <shapr> Me too
20:14:20 <hyrax42> night
20:14:25 <hyrax42> morning, even
20:14:26 <Pseudonym> Night.
20:14:36 <shapr> I wish I could get gv and xpdf to not show the margins, I don't read 'em
20:14:55 <autrijus> is galois.com named after Galois?
20:15:10 <shapr> Galois Connection I think.
20:15:11 <Pseudonym> Yes, more or less.
20:15:23 <autrijus> it took me a while to realize that Erlang was named after Erlang.
20:15:26 <Pseudonym> A Galois connection is an adjunction between posets.
20:15:42 <Pseudonym> Which is a kind of a modern generalisation of what Galois actually wrote.
20:19:20 <gzl> there are some other interesting ones
20:19:24 <gzl> but the original one is the best :)
20:31:46 <tautologico> so, does anyone here use/recommend a latex package for typesetting proof trees ? what about some program to help write the trees ?
20:35:05 <Pseudonym> http://math.ucsd.edu/~sbuss/ResearchWeb/bussproofs/
20:35:25 <tautologico> Pseudonym, do you use it ?
20:35:47 <Pseudonym> Nope, but I have heard it mentioned.
20:36:49 <tautologico> I found this link, but given sometimes you have many packages for the same thing, I didn't know if there were others
20:38:39 <Pseudonym> My LaTeX companion circa mid-90s doesn't say anything, unfortunately.
20:38:58 <tautologico> I guess the new edition neither
20:40:38 <tautologico> btw I found this
20:40:39 <tautologico> http://www.phil.cam.ac.uk/teaching_staff/Smith/LaTeX/
20:41:17 <tautologico> latex for logicians... besides documentation for the proof tree package, there is info about packages for commutative diagrams and etc
20:48:10 <palomer> ah crap, I missed the answer to my question
21:05:05 * shapr gets weird inconsistent results when testing against dc, so gives up an goes to sleep
21:05:22 <mwc> dc the calculator?
21:05:27 <shapr> yup
21:05:42 <mwc> Turns out all my GHC crashes were caused by bad ram
21:05:43 <mwc> that's a releif
21:05:47 <shapr> yay!
21:05:54 <mwc> Just gotta wait to exchange it now :(
21:06:39 <mwc> I can't stand having only 512 MB of RAM
21:06:57 <mwc> like having my hands in lead gloves or something
21:07:44 <Korollary> on windows ?
21:08:34 <mwc> No, OS X, but it's page thrashing against a 5400 RPM notebook hard disk
21:08:53 <Pseudonym> I can't stand only having a 2GHz processor.
21:09:16 <mwc> Pah, that's nothing, you're IO Bound anyways
21:09:20 <Korollary> I am on a 2GHz celeron, 256Mb and win xp home. Joy.
21:09:20 <palomer> how do the types of terms change with CPSification?
21:09:27 <Pseudonym> Not on this program I'm not.
21:09:33 <mwc> My problem is just a huge IO bottleneck
21:11:34 <mwc> can somebody suggest what Haskell "idiom" I need to use to tackle this problem? I need to keep going to a deeper level until I reach a given tolerance
21:11:53 <mwc> Having trouble figuring out what that looks like functionally
21:12:06 <Pseudonym> Is it some kind of tree that you're traversing?
21:12:18 <Pseudonym> Conceptually?
21:12:47 <mwc> No, it's an integration algorithm where I need to use the N'th result when N and N-1 differ by some margin
21:13:10 <SyntaxNinja> ls
21:13:16 <Korollary> grep SyntaxNinja
21:13:16 <mwc> I was thinking of making an infinite list of depth to infinity
21:13:18 <Pseudonym> rm -rf ~
21:13:44 <mwc> and then creating another list of differences and then searching through that to get the index I need
21:13:55 <SyntaxNinja> Lemmih: alive?
21:14:08 <mwc> but that seems uncessarily complicated
21:14:17 <Pseudonym> Well, you don't need to create a list of differences as such.
21:14:22 <SyntaxNinja> hi Korollary
21:14:32 <Pseudonym> You can create a traversal function which examines items two at a time.
21:14:40 <Pseudonym> So you actually need the index, not just the value?
21:15:35 <mwc> No, the value. Something like: for( i = 1; i <= MAX_STEP; ++i) { R = calculate(); if (R_WITHIN_TOLERANCE) BREAK; else continue;}
21:16:12 <mwc> it's trivially to do by recursion but I don't actually know how far I have to go
21:16:17 <mwc> so I don't know how to start it
21:16:29 <MachinShin> hey all
21:16:37 <Pseudonym> examineList (x1:x2:xs)
21:16:45 <Pseudonym>     | (x2 - x1) < tolerance = x2
21:16:54 <Pseudonym>     | otherwise      = examineList (x2:xs)
21:16:56 <Korollary> hi SyntaxNinja
21:16:56 <Pseudonym> You mean like that?
21:17:19 <mwc> hmmm that should do it
21:17:28 <Pseudonym> Also useful:
21:17:30 <Pseudonym> @type iterate
21:17:32 <lambdabot> forall a. (a -> a) -> a -> [a]
21:17:41 <Pseudonym> @plugs take 10 (iterate (+1) 0)
21:17:43 <lambdabot> [0,1,2,3,4,5,6,7,8,9]
21:17:56 <Pseudonym> @plugs take 10 (iterate (\x -> x + sin x) 1)
21:17:58 <lambdabot> [1.0,1.8414709848078965,2.80506170934973,3.135276332899716,3.
21:17:58 <lambdabot> 141592611590653,3.141592653589793,3.141592653589793,3.141592653589793,
21:17:58 <lambdabot> 3.141592653589793,3.141592653589793]
21:18:24 <Pseudonym> Useful for fixpoint computations.
21:18:27 <mwc> kk, I think I got it now
21:18:45 <mwc> Heh, funny you should mention that... I was going to be doing an implementation of Steffensen's method next
21:21:31 <palomer> how would one interpret the type ((a -> m b) -> m a) -> m a
21:22:15 <palomer> I interpret f: A -> B as "forall terms in a, f(a) is in B"
21:23:05 <Korollary> you are forgetting the context part
21:23:20 <Korollary> probably (Monad m) =>
21:23:29 <palomer> callCC :: ((a -> m b) -> m a) -> m a
21:23:30 <mwc> I read that as a function taking a function as a parameter that maps a to a HOT over B, which produces a HOT over a, said function gives a HOT over a
21:23:34 <palomer> http://haskell.org/hawiki/MonadCont
21:23:50 <palomer> HOT?
21:24:43 <mwc> higher order type
21:25:04 <palomer> what's that?
21:25:15 <mwc> it
21:25:27 <mwc> it's a type that's "defined for a type."
21:25:42 <palomer> a parametric type?
21:25:43 <mwc> like a tree of ints vs. a tree of floats vs. a tree of strings
21:26:01 <mwc> it's sort of a general idea that I'm probably bastardizing wrt Haskell
21:26:14 <mwc> palomer: that's how I see it, yes
21:26:37 <palomer> mwc: oh, I see here the confusion is
21:26:45 <palomer> Korollary was right, (Monad m) => ...
21:27:49 <palomer> so b and a may not be parametric
21:29:17 <Korollary> Yes they can be
21:29:34 <Korollary> the constraint is only on ,
21:29:36 <Korollary> err m
21:30:04 <palomer> they can
21:30:08 <palomer> but they may not
21:30:18 <palomer> ah, the problem is in the interpretation of may not
21:30:24 <palomer> cool, found a new ambiguity in english
21:30:47 <Pseudonym> There are a lot of ambiguities in every natural language.
21:30:50 <ezra_> a and b are the parameters, it doesn't matter what they are
21:31:13 <palomer> "may not" can mean "absolutely not" or "it may be the case that its not"
21:31:30 <palomer> ok, so how do you interpret that type?
21:31:42 <Pseudonym> Thyme flies like keeping the front of your trousers closed AND smelling like herbs.
21:31:59 <palomer> Pseudonym: quite ambiguous
21:32:16 <palomer> little girl's school
21:32:45 <Pseudonym> That one isn't ambiguous.
21:33:00 <Pseudonym> Since it doesn't make sense that there's a school with only one student.
21:33:08 <Pseudonym> It's ambiguous when spoken, but not when written.
21:33:21 <Pseudonym> little girl's school vs little girls' school
21:33:22 <ezra_> I think that a -> m b is the type of the continuation.
21:33:33 <palomer> little girls' school
21:33:47 <ezra_> callCC will call a function (of type continuation -> m a) and return its result.
21:34:01 <ezra_> (where "continuation" abbreviates the type a -> m b)
21:34:01 <palomer> Pseudonym: it is ambiguous, since its either the school that belongs to the little girl or a small school containing a single girl
21:34:28 <mwc> palomer: and yet people talk just fine...
21:34:38 <palomer> mwc: I never said they didn't!
21:34:42 <mwc> you can't parse any natural language
21:34:48 <Pseudonym> I'm not aware of any schools containing a single girl.
21:34:49 <Korollary> mwc: lawyers may disagree with that heh. damn legalese...
21:34:54 <Pseudonym> Unless everyone else is sick.
21:34:55 <ezra_> natural languages have the neat feature that you can say, "Did you mean X or Y?"
21:35:10 <Korollary> Pseudonym: like that school they were trying to evacuate in Die Hard 3 ?
21:35:12 <Pseudonym> Which is possible in a school of, say, seven students.
21:35:19 <Pseudonym> Haven't seen it.
21:35:24 <mwc> Korollary: yess, that's the linguistic abortion of trying to make natural language absolute
21:35:45 <palomer> ezra_: given a type a inhabited by terms T, what terms inhabit m a?
21:36:04 * Korollary refers to mwc as "The MWC" henceforward
21:37:56 <ezra_> palomer: it's abstracted away from any concrete example; "m a" is "a, modified by m" but since m is another parameter of sorts,
21:38:06 <ezra_> it could modify a in different ways.
21:38:47 <palomer> ah, so it depends on which monad we use?
21:39:12 <ezra_> yes
21:40:03 <palomer> that's freaky
21:40:20 <ezra_> yeah, I think it is pretty freaky
21:40:40 <Korollary> it doesn't really 'depend'. It more like 'allows' any type of the monad class.
21:40:48 <palomer> callCC :: ((a -> m b) -> m a) -> m a <--- in this case, how would I get an inhabitant of (m a) given inhabitants of a and b?
21:41:27 <palomer> or, rather, what do I apply to callCC?
21:41:45 <ezra_> I've never done it in haskell myself!
21:42:21 <ezra_> Do you simply use the name of the monad, like: "IO a"?
21:42:24 <palomer> ok, say I'm given a term t: ((a->b)->a), how would I get a term of a?
21:42:35 <palomer> ezra_: I have to admit, I'm pretty lost
21:42:56 <ezra_> Oh, again it's abstracted. You can choose what *real* type you want to work with,
21:43:00 <Korollary> palomer: have you read the tutorial's section on type classes and monads yet ? Studying call/cc could be very confusing without.
21:43:04 <ezra_> say integers.
21:43:30 <palomer> it depends on the types?
21:43:51 <ezra_> K said it best, it doesn't depend on the type--the type, basically, doesn't matter.
21:43:52 <palomer> Korollary: I would have to understand monads first
21:44:12 <palomer> ok, so can I simply apply callCC to t?
21:45:05 <palomer> Korollary: I would have to learn about monads first
21:45:06 <ezra_> i'm not the best person to answer, since I don't know much concrete haskell syntax
21:45:13 <palomer> Korollary: and I've yet to find a good monad tutorial
21:45:20 <ezra_> I'm speaking from what I know of ML
21:45:40 <palomer> (((a->b)->a)->a is not a valid ML type
21:45:46 <Korollary> palomer: how many have you read ? I'd recommend Nomaware's and Tackling the awkward squad.
21:46:06 <palomer> nomaware starts off assuming you've used the maybe nomad
21:46:10 <palomer> monad
21:46:22 <palomer> while I've barely used haskell
21:46:25 <palomer> (but am well versed in sml)
21:46:28 <Korollary> that's not how I recall
21:46:47 <ezra_> p.: you're saying that type is not inhabited in ML?
21:47:00 <Korollary> anyway, try http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/
21:47:10 <Korollary> by the guy who wrote the ghc compiler
21:47:32 <ezra_> the monad helps you out in that. For example, the "Maybe" monad is like "option" in SML basis.
21:47:50 <palomer> ezra_: yup
21:48:06 <musasabi> Maybe is just defined as "data Maybe a = Just a | Nothing"
21:48:20 <palomer> oh, that's a monad?
21:48:22 <ezra_> There is a valid function ((a -> b option) -> a option) -> a option, since you can return NONE (or Nothing) in each case
21:48:54 <ezra_> A monad is a type constructor ("class" in Haskell terminology?) that has certain features.
21:52:12 <ezra_> namely those in this section... http://www.nomaware.com/monads/html/meet.html#maybe
21:53:21 <palomer> ahhh
21:53:25 <palomer> now you tell me
21:54:00 <ezra_> heh heh.
21:54:15 <ezra_> ("class" was wrong, by the way, that's something different in Haskell :-p)
21:54:35 <palomer> i assume we're only talking about datatypes
21:54:42 <palomer> so this only works for certain datatypes
21:55:28 <palomer> why don't they just put that in the first page
21:55:31 <ezra_> yeah, and a monad has a way that you can "automatically" put values of "a" into "m a"
21:55:38 <palomer> "a monad is a datatype which satisfies the following conditions"
21:55:54 <ezra_> everything about monads is a little obscured in category theory terminology, imo
21:56:52 <palomer> so what does  f:m a -> m b say?
21:57:08 <palomer> or do we have to define the monad for this to make sense?
21:58:17 <ezra_> to say anything concrete about it, yes.
21:58:18 <palomer> f: m a -> m b    <---this means "m is a datatype satisfying conditions ..., so m a is a type which depends both on a and on m, ditto for m b"
21:59:09 <ezra_> m is constrained only by the previous line, "(Monad m) =>"
21:59:27 <ezra_> which is like saying, "given a Monad m"...
21:59:39 <palomer> or "given a datatype m satisfying the conditions... "
22:00:05 <ezra_> right. the word "Monad" is defined elsewhere, somewhere in the Haskell innards.
22:00:39 <gzl> have you looked at the nomaware tutorial?
22:00:49 <palomer> so I could apply f to any term c a where c is a monad constructor with parameter a
22:01:08 <palomer> gzl: hullo gzl, I started reading it but was immediately turned off by the haskellishness
22:01:42 <gzl> ...
22:01:42 <ezra_> Note that "m" only appears in the result types of the functions, so you're not applying anything TO a term of "m a"...
22:01:56 <gzl> so why are you making someone repeat the stuff in the tutorial? :P
22:02:02 <gzl> anyway, whatever
22:02:18 <ezra_> yeah, if you're not interested in haskell, what are you in it for?
22:02:40 <palomer> ezra_: eh? it appears on both sides of the implication
22:02:59 <palomer> ezra_: I'm interested in realizibility theory
22:03:16 <ezra_> hmm; I don't know anything about that.
22:03:31 <palomer> yeah, don't worry
22:03:32 <gzl> well and good, but if you want to learn about a haskell feature, it seems silly to complain about haskell
22:03:41 <palomer> I never complained about haskell!
22:03:46 <palomer> but I don't know much haskell
22:03:54 <palomer> so reading that tutorial is kind of useless
22:04:09 <gzl> you could get some of Moggi's papers if you prefer categories
22:04:11 <ezra_> i think it's a fairly good one, there are much more theoretical treatments, though
22:04:17 <palomer> categories, bleh
22:04:23 <gzl> do you like anything?
22:04:34 <palomer> yes, realizibility theory
22:04:37 <palomer> operational semantics
22:04:39 <Pseudonym> BTW, nobody actually read's Moggi's papers.
22:04:40 <palomer> model theory
22:04:43 <palomer> proof theory
22:04:51 <gzl> Pseudonym: right, everyone reads nomaware. or some equivalent. :)
22:04:51 <Pseudonym> We get Phil Wadler to read them for us and then explain them in more papers.
22:05:12 <Pseudonym> Yeah, and then the nomaware tutorial is in turn based on Wadler.
22:05:23 <SyntaxNinja> someone needs to kick Lemmih out of bed.
22:05:45 <gzl> sure
22:05:50 <gzl> yeah, Wadler is good
22:06:09 <ezra_> oh, palomer, i misunderstood which function you were talking about.
22:06:15 <gzl> but you have to be willing to read *something*.
22:06:29 <ezra_> in callCC, the inner function is GIVEN a function that converts from things of type "a" to things of type "m b"
22:07:04 <ezra_> in functional programming, Monads are usually (often?) used to qualify the result type of a function...
22:08:52 <ezra_> but it sounds like you're interested in something more theoretical.
22:09:00 <palomer> nonono
22:09:11 <palomer> gimme the applied stuff
22:09:25 <gzl> you need to sit down with the documentation and play around with it for a bit
22:09:32 <ezra_> yeah, +1 gzl
22:09:38 <palomer> for a -> m a to work, m would need to have a constant constructor, no?
22:10:55 <palomer>        s/to work/to be inhabited
22:11:47 <ezra_> a monad m is fundamentally defined as something for which there is a function unit : a -> m a
22:11:54 <JohnMeacham> Hmm.. I am having some oddness building gtk2hs from the src rpm
22:12:17 <palomer> ahh
22:12:54 <palomer> ezra_: a function unit for every type a, inhabited or not?
22:13:05 <palomer> ezra_: isn't that equivalent to having a constant constructor?
22:13:15 <gzl> I think it's more intuitive to think of the definition facilitiating the purpose of the monad rather than vice versa
22:13:43 <JohnMeacham> It appears to have installed itself into /usr/lib64/ghc/6.4/gtk2hs rather than the proper (i think) /usr/lib64/ghc-6.4.1.20050626/ any ideas? it built perfectly, but the package didn't register and it dropped the files in an odd place.
22:14:07 <gzl> it's defined the way it is in order to make certain things work
22:14:20 <ezra_> yeah, i'm not sure whether that requires a constant constructor or not.
22:14:31 <gzl> so I think you would be better off trying to understand what the definition is trying to accomplish rather than the definition itself
22:14:38 <gzl> at least at first
22:14:39 <gzl> that's my 2 cents
22:15:27 <palomer> gzl: I find that to better understand a definition, one should look for equivalences
22:16:23 <gzl> I find that it's easier if you first play with the end result and try to understand its purpose and then go back to see how that purpose is accomplished
22:16:27 <gzl> but that's a matter of taste
22:17:07 <palomer> if there's a function a -> m a for any a, then there can't be a function m a -> a, right?
22:17:30 <gzl> no, not exactly.
22:17:48 <ezra_> it depends on the type system, doesn't it?
22:17:59 <palomer> we'll use the haskell type system
22:18:01 <ezra_> in some systems, there might be a value that is a member of all types?
22:18:25 <palomer> that would suck
22:18:34 <gzl> it's often called bottom
22:18:40 <ezra_> yeah.
22:18:43 <ezra_> why would that suck?
22:18:57 <palomer> you lose any relationship with proof theory
22:19:31 <ezra_> hm; well that might not be a problem for lots of haskell programmers.
22:19:49 <gzl> or for most people in general ;p
22:19:57 <palomer> every type is inhabited in haskell?
22:20:00 <palomer> that's _crazy_
22:21:09 <ezra_> i don't know if that's true or not...
22:21:23 <gzl> it is
22:22:05 <gzl> (haskell has a bottom type)
22:22:12 <palomer> oh my.
22:22:33 <ezra_> neat!
22:22:35 <palomer> so a -> m a is always inhabited!
22:22:44 <palomer> so everything is a monad
22:22:57 <ezra_> is that done forcibly, just by including the unique bottom value?
22:23:13 <gzl> i don't know how it's implemented
22:23:23 <dons> @eval undefined
22:23:24 <lambdabot> Ambiguous type variable `a' in the top-level constraint
22:23:28 <dons> @eval undefined :: ()
22:23:29 <lambdabot> Fail: Prelude.undefined
22:23:36 <dons> bottom
22:23:45 <gzl> cheater. defining it as undefined.
22:23:53 <gzl> who would think to look for it there :)
22:24:39 <ezra_> and that inhabits a type like a -> b ?
22:24:50 <dons> @eval undefined :: Int -> Bool
22:24:52 <lambdabot> <Plugins.Eval>:1:
22:24:52 <lambdabot>   No instance for (Show (Int -> Bool))
22:24:52 <lambdabot>   arising from use of `show'
22:25:21 <dons> @eval (undefined :: Int -> Bool) 2
22:25:23 <lambdabot> Fail: Prelude.undefined
22:25:37 <ezra_> whoa! neat
22:25:39 <palomer> Int -> Bool isn't empty, is it?
22:25:52 <SyntaxNinja> dons: have you written cabal-and-load yet? :)
22:25:54 <gzl> huh?
22:26:06 <ezra_> @eval (undefined :: a -> b)
22:26:07 <lambdabot> <Plugins.Eval>:1:
22:26:07 <lambdabot>   No instance for (Show (a -> b))
22:26:07 <lambdabot>   arising from use of `show'
22:26:34 <dons> SyntaxNinja, not yet :) been busy with papers and reviews. however, that's all done as of yesterday, so I'll hopefully get time in the next couple of weeks
22:26:39 <palomer> so, erm, the condition on monads is superfluous, unless you say "non bottom inhabitant"
22:26:52 <SyntaxNinja> sweeeet
22:26:57 <gzl> ezra_: try @eval (undefined :: a -> b) 2
22:27:01 <palomer> yeah, adding a bottom element really screws up proof theory
22:27:12 <dons> @eval (undefined :: a -> a) 2
22:27:13 <lambdabot> Fail: Prelude.undefined
22:27:21 <ezra_> perfect!
22:27:36 <gzl> ezra_: it's a function, so i guess it helps to apply it ot some random thing like 2
22:27:58 <SyntaxNinja> Lemmih: you write the most complex-to-build haskell software I have ever used, and that's saying something ;)
22:27:58 <ezra_> yeah, it sounds like it just has no way to print a function value.
22:28:00 <dons> in order for @eval to allow it, it has to be convinced that it is Show'able
22:28:18 <dons> and (->) types aren't
22:28:29 <ezra_> it's odd that it's letting us apply undefined :: a -> a to 2
22:28:34 <dons> why?
22:28:35 <palomer> oh
22:28:55 <ezra_> shouldn't we have to concretify "a" to some real type?
22:29:06 <dons> the type system will do that for us :)
22:29:27 <dons> there's a constraint coming from the '2' that makes the result Showable
22:29:28 <ezra_> oh, ok; so it converts it to Int -> Int before applying...
22:29:35 <dons> nah, Num a => a
22:30:12 <dons> @eval (undefined :: Num a => a -> (a,a)) (2 :: Num a => a)
22:30:13 <lambdabot> Fail: Prelude.undefined
22:30:21 <dons> undefined for all!
22:30:21 <ezra_> ok.
22:30:28 <gzl> so what is realizability theory?
22:31:13 <palomer> gzl: the art of finding inhabitants of types
22:31:20 <palomer> some types have some _really_ interesting inhabitants
22:31:45 <palomer> for example, one type has the property that all its inhabitants will sort a list of integers
22:32:08 <ezra_> palomer, are you familiar with the language Epigram?
22:32:32 <palomer> ezra_: never heard of it
22:32:47 <gzl> what is interesting about the fact that all inhabitants of a type sort integers?
22:33:05 <ezra_> it becomes a contract,
22:33:09 <ezra_> a type which specifies behavior.
22:33:16 <palomer> gzl: programming becomes an exercise in finding inhabitants
22:33:18 <ezra_> Epigram is a real language which is built around this principle
22:34:08 <gzl> i don't see how what you're doing is much different from the normal way of doing things
22:34:41 <palomer> oh, finding inhabitants becomes an exercise in proving tautologies
22:34:59 <palomer> ezra_: this looks fascinating
22:35:00 <ezra_> Here http://www.cs.nott.ac.uk/~txa/publ/ydtm.pdf
22:35:15 <gzl> ok, so what's an example? say I want to sort a list of integers. how would you think about that?
22:35:23 <ezra_> That's a very readable paper where McBride & co. work up precisely that example.
22:36:18 <palomer> ok, you would need to find an inhabitant of forall(lst). L[lst] -> L[sort(lst)]
22:36:22 <ezra_> In epigram, you write the type of a function first, and the IDE starts spitting out the framework of the function, since it knows so much.
22:36:27 <ezra_> (from the type)
22:36:55 <gzl> palomer: ok, and how is finding an inhabitant of that type different from doing the normal thing of finding an appropriate sorting algorithm?
22:37:14 <pejo> ezra, are dependent types related to this somehow?
22:37:17 <palomer> where L[x] = forall^1 X. (Xnull -> forall y.forall z. (N[y]->L[z]) -> Xx)
22:37:25 <gzl> pejo: heavily, it looks like
22:37:29 <ezra_> yes, Epigram is based on the idea of dependent types.
22:37:45 <palomer> gzl: well, you can't mess up. the program you find _must_ sort the list
22:38:04 <ezra_> But, palomer, does that make it any easier?
22:38:06 <palomer> actually, you can mess up in one place, if you write term equalities which are false
22:38:10 <gzl> exactly, how is that easier?
22:38:18 <palomer> err, it's correct
22:38:23 <palomer> I don't know if its easy yet
22:38:42 <palomer> it'll probably become easier than normal programming
22:38:48 <ezra_> so i guess it gives you a static guarantee of correctness...
22:38:52 <palomer> but its the correctness thats exciting
22:38:54 <ezra_> at least when that's provable.
22:39:04 <palomer> ezra_: the "program" is the proof
22:39:08 <Pseudonym> I'm not convinced of that, palomer.
22:39:17 <palomer> convinced of what?
22:39:26 <Pseudonym> That it'll become easier than normal programming.
22:39:49 <gzl> is the idea that the compiler will check that the function you've written actually does inhabit that type?
22:39:49 <palomer> I'm pretty sure it will, since the computer will be able to handle cases automatically
22:39:50 <Pseudonym> The problem is that expressing the types will become just as hard as programming.
22:39:53 <Pseudonym> And just as hard to debug.
22:40:03 <gzl> yeah, that already happens in Haskell
22:40:04 <palomer> Pseudonym: you express datatypes in the same way as in sml
22:40:20 <gzl> half the effort is coming up with the type signature
22:40:46 <Pseudonym> There has been a lot of work with formal specifications in general.
22:40:46 <pejo> gzl, can always leave it out though.
22:40:51 <Pseudonym> And checking programs against specifications.
22:40:54 <palomer> oh, well you ask yourself: is there a set of injective functions who's images are mutually exclusive but the union spans the space? if so, those are your constructors
22:41:00 <gzl> pejo: sure
22:41:16 <palomer> oh, and the space has to be the least set closed by those functions
22:41:16 <Pseudonym> The problem is that when the specifications get tricky, they become as hard to write as the program itself.
22:41:28 <Pseudonym> And sometimes they get harder to debug.
22:41:38 <ezra_> But maybe some problems are the revers--
22:41:42 <ezra_> where the spec is easier than the program?
22:41:50 <Pseudonym> Sure.  Like sorting integers.
22:41:56 <palomer> the spec is almost always easier than the program
22:42:00 <ezra_> right.
22:42:06 <Pseudonym> In general, not so.
22:42:07 <ezra_> (right to pseudo)
22:42:12 <palomer> besides, you can write a spec in a language similar to english
22:42:27 <palomer> Pseudonym: give me an example
22:42:39 <palomer> and you can enrich the language of the spec to become more readable to humans
22:42:43 <Pseudonym> OK, I'm thinking of a compiler transformation, like partial redundancy elimination.
22:43:07 <palomer> Pseudonym: you'd have to explain me the whole theory
22:43:08 <Pseudonym> I would say that expressing that in types would be just as hard as implementing it in a language like Haskell.
22:43:16 <pejo> palomer, heh. And we all see what a success those plain english languages are.
22:43:30 <palomer> pejo: a subset of english, of course
22:43:49 <Pseudonym> Partial redundancy elimination is a transformation on the internal representation of a program inside a compiler.
22:44:03 <Pseudonym> The basic idea is that you move code across loops and join points.
22:44:05 <Pseudonym> For example:
22:44:23 <Pseudonym> if (c) { foo; } else { bar; x = t; }   x = t;
22:44:40 <Pseudonym> The x = t is evaluated twice along one of the code paths, but not both.
22:44:45 <Pseudonym> So you transform into:
22:44:54 <Pseudonym> if (c) { foo; x = t; } else { bar; x = t; }
22:45:24 <Pseudonym> The trouble is that you'd have to express it in such a way that you can capture what it means for a compiler transformation to preserve the meaning of a program.
22:45:41 <palomer> yes, of course
22:45:47 <palomer> you need a clear idea of what you're doing
22:46:12 <Pseudonym> My point is that expressing constraints like that would be just as hard as writing code to do it.
22:46:16 <ezra_> well, if you have a formal semantics, maybe that whole bundle of propositions becomes one type, with a short name (brainstorming here)
22:46:36 <palomer> Pseudonym: but then you can show those constraints to someone who knows the theory and say "tell me if sentences 1 through 5 are true"
22:46:49 <palomer> then you move to another guy and say "is sentence 6 true?"
22:46:51 <palomer> etc...
22:46:57 <palomer> if everyone agrees that the sentences are true
22:47:00 <Pseudonym> Yes, but you do that in a code review, too.
22:47:03 <palomer> your program is correct
22:47:18 <Pseudonym> Only you do it with code.
22:47:33 <palomer> yes
22:47:35 <Pseudonym> I'm not saying this is a bad idea, necessarily.
22:47:41 <palomer> which is not a language humans can deal with
22:47:53 <Pseudonym> I'm just saying that all it does is shift work around.  It doesn't necessarily _reduce_ work.
22:47:53 <palomer> the whole point of a specification is that its in a language closer to something we can deal with
22:48:23 <palomer> it may not reduce work, but it ensures correctness, and can largely reduce work in some areas
22:48:38 <palomer> furthermore, the reviewer does not need to know how to program
22:49:01 <palomer> so reviews are quicker and cheaper
22:49:03 <Pseudonym> Yes, they do.  Specification languages are declarative programming languages in disguise.
22:49:50 <Pseudonym> Taking the sorting of integers example, I reckon if you showed me the type, there'd be a direct translation into Prolog.
22:50:05 <palomer> the type has a direct translation to sml
22:50:05 <Pseudonym> The program would be slow, but it'd work.
22:50:11 <Pseudonym> Right, there you go.
22:50:14 <Pseudonym> So it is programming.
22:50:21 <palomer> who cares about the type?
22:50:47 <Pseudonym> My point is that the person concocting the type is programming in a high-level declarative language.
22:50:52 <dons> already you can write proofs in Isabelle and generate programs from those proofs/types
22:50:57 <dons> generate ML programs
22:51:02 <Pseudonym> Right.
22:51:10 <Pseudonym> Those proofs are constructive, no?
22:51:21 <palomer> of course
22:51:25 <Pseudonym> So they're programs.
22:51:25 <dons> yeah, it feels like writing complex haskell types
22:51:47 <Pseudonym> Proofs are programs.  Ask Curry and Howard if you need more info.
22:52:26 <dons> yeah, so with more complex type systems, we just do more programming on the type level
22:52:34 <palomer> the curry howard isomorphism simply gives a homomorphism of proofs into lambda terms
22:52:55 <palomer> however, to have the types specify the terms is specification theory
22:53:12 <Pseudonym> I agree with that, but it's still programming.
22:53:30 <Pseudonym> It's even more declarative, but it's still programming.
22:53:33 <palomer> to build the program IS programming
22:53:41 <palomer> but to check it is closer to english
22:53:53 <palomer> there's the rub
22:53:54 <Pseudonym> To build the specification is programming.
22:54:02 <palomer> you can build the specification as you go along
22:54:25 <Pseudonym> OK, then you can check the program against the specification.
22:54:33 <Pseudonym> So debugging the program reduces to debugging the specification.
22:54:42 <palomer> yes
22:54:46 <Pseudonym> And since the specification is also a program...
22:55:01 <Pseudonym> Debugging the program reduces to debugging ANOTHER program.
22:55:18 <palomer> the specification is not a program per say
22:55:31 <palomer> it's a set of sentences in some language
22:55:42 <palomer> for which we care only about truth
22:56:02 <palomer> so, if I say "if you sort an empty list you get an empty list back" you nod your head
22:56:08 <Pseudonym> SeRight.
22:56:11 <Pseudonym> Right.
22:56:12 <Pseudonym> sort [] = []
22:56:14 <Pseudonym> Next?
22:56:23 <Pseudonym> Or in Prolog:
22:56:26 <Pseudonym> sort([], []).
22:56:31 <palomer> the theory is very young, so the specifications aren't very developed
22:57:00 <Pseudonym> Sure, I understand that.
22:57:14 <Pseudonym> I don't think work on specification theory is a waste of time by any means.
22:57:40 <Pseudonym> My point is that any sufficiently expressive specification language must be a programming language.
22:58:00 <Pseudonym> In which case we're not actually writing a specification, we're programming in a higher-level more-declarative language.
22:58:02 <palomer> yeah, you COULD think of it as a programming language
22:58:17 <palomer> BUT
22:58:24 <palomer> the compiler may never terminate
22:58:32 <palomer> since the language is too high level
22:58:48 * dons should find the Haskell-type level quick sort program
22:58:48 <Pseudonym> SUre.
22:58:54 <ezra_> that doesn't seem like an advantage
22:59:20 <palomer> ezra_: it makes checking the specification easier
22:59:24 <Korollary> dons should help me with optimizing permutation generation ;)
22:59:31 <Pseudonym> ezra_: Think of a compiler which is just a front end.
22:59:34 <palomer> also, this method of programming makes you state your assumptions explicitly when you program
22:59:39 <Pseudonym> It just reads in the program and then checks it.
22:59:39 <pejo> palomer, how is non-termination helping checking the specification?
22:59:47 <dons> ah, here it is: www.cse.unsw.edu.au/~dons/qs.transcript
22:59:49 <Pseudonym> It's the checking which is the tricky bit.
23:00:06 <ezra_> you're saying that non-termination is an acceptable disadvantage for something so powerful?
23:00:09 <palomer> pejo: well, you have to do all the hard work for the compiler
23:00:20 <palomer> pejo: that would be the "programming" part
23:00:28 <Pseudonym> ezra_: In theory, Haskell typechecking or C++ template instantiation can fail to terminate today.
23:00:38 <ezra_> sure.
23:00:44 <Korollary> C++ templates have a depth length iirc
23:00:44 <Pseudonym> So it's not exactly a _dis_advantage.
23:00:45 <dons> the type-level qsort is due to Roman Leshchinskiy
23:01:01 <Pseudonym> Korollary: They have a mandated minimum depth.
23:01:08 <ezra_> I just didn't understand how that point would refute "palomer's language is a programming language"
23:01:21 <Korollary> oh I thought it was a maximum
23:01:26 <Korollary> dear c++
23:01:30 <Korollary> what could I do without it
23:01:41 <Pseudonym> I'm not knocking specification theory at all, because for all I know, this hypothetical specification language might be much more pleasant to program in.
23:01:51 <Pseudonym> But it's still programming.
23:01:59 <Korollary> Pseudonym: there are some business types who want XML -> assembly lol
23:02:03 <Korollary> er UML
23:02:13 <palomer> ezra_: this is how it works: you build your datatypes, then you try to prove a formula. to prove this formula, you'll need to make assumptions in a restrained language which is easy to read for humans. once you're done proving the formula, then you have a compiled program. proving the formula can be thought of as "compiling"
23:02:29 <Pseudonym> Yeah, well.  Those business types don't understand that UML is useless for design.
23:02:37 <Pseudonym> It's great for documenting an existing design.
23:02:38 <Korollary> shhh dont tell them
23:02:42 <Pseudonym> But useless for coming up with one.
23:03:04 <Pseudonym> OK, "great" might be an overstatement.
23:03:28 <Korollary> with my infinite wisdom I will command the computer with UML to write business apps. Yes.
23:03:32 <ezra_> palomer: I like the idea of declaring your assumptions, and living by your contracts.
23:03:33 <Pseudonym> s/great/empirically useful/
23:04:04 <ezra_> But I'm partial to Pseudonym's claim that, well, it doesn't make programming any easier because the specification language is basically (as complex as) a programming languages.
23:04:10 <ezra_> s/languages/language/
23:04:20 <Korollary> Pseudonym: UML is nice, but the industry has this undying thirst to find the next TLA and blow it out of proportion.
23:04:26 <Pseudonym> Indeed.
23:04:36 <palomer> ah, here's the deal, the language in which you state your assumptions is something much closer to english
23:04:37 <Pseudonym> UML also doesn't help if your program isn't 100% object oriented.
23:04:54 <Pseudonym> OK, so it's like programming in declarative COBOL.
23:04:54 <Korollary> which is something blown out of proportion as well.
23:05:03 * Pseudonym shudders
23:05:07 <ezra_> "closer" in what sense? I used to hear that said about BASIC (as opposed to asm)
23:05:08 <palomer> ezra_: and basically, you're only stating things that are true, like "if a is an integer divisible by 4, then its divisible by 2"
23:05:22 <Korollary> I used to know Cobol. I dont remember any. all that without therapy. I was lucky.
23:06:09 <Pseudonym> In Prolog, you'd write that as something like this:
23:06:15 <ezra_> palomer, if I understand you right, the specification is "easier" to create and check because it's slightly looser than the actual proof, which may still be hard.
23:06:26 <Pseudonym> :- 0 is A mod 4 => 0 is A mod 2.
23:06:36 <ezra_> "looser" in that there are many sort algorithms but only one definition of "sorted"
23:07:11 <palomer> Pseudonym: what about "if there exist an integer divisible by 4, then there exists an integer divisible by 2"
23:07:29 <Korollary> lol somewhat backwards . I would want to write "A mod 4 is 0..."
23:07:35 <palomer> ezra_: the specification is much looser than the proof
23:07:45 <Pseudonym> all [A] ( 0 is A mod 4 => 0 is A mod 2 )
23:07:46 <ezra_> for some applications, i'd buy that.
23:07:55 <palomer> ezra_: and finding the proof is probably as hard as programming
23:08:01 <Korollary> Pseudonym: that's not exactly right
23:08:22 <Pseudonym> NO, that's true.
23:08:31 <ezra_> palomer: ok, i can accept that.
23:08:34 <Pseudonym> some [A] ( 0 is A mod 4 ) => some [A] ( 0 is A mod 2 )
23:08:50 <Korollary> that is the right translation
23:09:01 <Pseudonym> Anyway.
23:09:04 <palomer> ezra_: and the computer can help you program automatically along the way
23:09:15 <ezra_> palomer, you really must check out Epigram because it is very much organized around this principle.
23:09:32 <ezra_> I'm still not sure about the practical usability of a system like that, but I think you make a decent case.
23:09:49 <Pseudonym> I think there's a good case for undergraduate computer science problems.
23:10:00 <Pseudonym> Or something that's already formally specified, like relational database systems.
23:10:24 <palomer> well yes, to implement something you need to know exactly how it works
23:10:27 <Pseudonym> However, for example, graphical user interface behaviour is notoriously hard to specify.
23:10:33 <palomer> or, rather, exactly what it does
23:10:37 <Korollary> iirc, they don't strictly adhere to the mathematical definition for db's in practice.
23:10:43 <palomer> oh, yes, gui programming will be impossible
23:10:52 <palomer> BUT, parsing is easy:O)
23:11:00 <Pseudonym> So is specifying heuristic systems.  Say you want to solve an NP hard problem as well as you can.
23:11:16 <palomer> oh, righto, performance right now is abysmal
23:11:18 <Pseudonym> Obviously your specification should NOT specify that the NP hard problem must be solved.
23:11:42 <palomer> and ,erm, right now we can only specify functions which terminate
23:11:48 <ezra_> Pseudo--you're speaking of approximation problems?
23:11:59 <ezra_> or rather, approximation algorithms
23:12:04 <Pseudonym> Right.
23:12:08 <palomer> again, the subject is really new
23:12:32 <Pseudonym> So I think it's interesting, and I think it'll find niches.
23:12:42 <Pseudonym> But I don't expect it to be revolutionary.
23:13:12 <palomer> yeah, programming elevators and such, or mission critical systems
23:13:13 <ezra_> pseudo, what revolutionary problem are *you* working on? ;-)
23:13:22 <palomer> but I think that the programming ideas will be used in other languages
23:13:31 <Korollary> biotech maybe
23:13:38 <Pseudonym> ezra_: The problem I'm working on was revolutionary once.
23:13:48 <Pseudonym> I'm just fleshing out the details. :-)
23:13:52 <palomer> and another advantage is that this system shows you _exactly_ how your reasoning translates into a program
23:14:04 <ezra_> ...do tell!
23:14:22 <Pseudonym> Oh, it's information retrieval.  I'd say, for example, that Google is pretty revolutionary.
23:14:50 <ezra_> ah. i don't know how specifiable that is.
23:15:03 <Korollary> mmm pagerank
23:15:05 <Pseudonym> But then, I suppose that high-level programming is pretty revolutionary, too.
23:15:41 <Korollary> we can go back in time to 1960 and write in Lisp.
23:15:46 <ezra_> i'm all in favor of a proliferation of programming styles.
23:16:06 <Pseudonym> So am I, so long as they work together.
23:16:21 <Pseudonym> If I can write the bits of my system in whatever language is most appropriate to that bit.
23:16:45 <ezra_> are you thinking of the need for glue code, and the impedance mismatch between different languages?
23:16:53 <Pseudonym> Yes.
23:16:57 <palomer> my dream is that one day we'll be able to write specifications in a large unambiguous subset of english
23:17:00 <palomer> or...lojban
23:17:19 <ezra_> that's a big problem, i think--impedance mismatch.
23:17:27 <ezra_> lots of man-hours get wasted on that glue code
23:17:30 <Pseudonym> My suspicion is that those specifications will read like legal documents.
23:18:42 <palomer> could be:O
23:18:45 <Pseudonym> I'm actually reading "Death Sentence" at the moment.  If modern managerial and political language is the future of specifications...
23:18:53 <Pseudonym> Well, let's just say there's more poetry in Perl.
23:19:05 <ezra_> here, here
23:19:40 <Korollary> Perl does have an unambiguous syntax at least
23:20:06 <ezra_> i'm not positive....
23:20:38 <Korollary> I looked into Perl6. I still dont like it.
23:20:44 <palomer> bleh
23:21:03 <palomer> I'm hooked on sml...so elegant
23:21:07 <palomer> but its library is crap
23:21:07 <Pseudonym> So just look at the Pugs source code.
23:22:03 <Korollary> C# 3.0 will rock, of course.
23:22:55 <ezra_> well, i've got to drop off. i enjoyed this; see you all again sometime...?
23:23:04 <Korollary> we're here 24/7
23:23:15 <ezra_> great
23:24:18 <palomer> err, I'll probably come more often
23:24:33 <palomer> btw, what do the types of terms become when they're CPSified?
23:24:53 <Pseudonym> Oh, I thought I answered that one.
23:24:58 <Pseudonym> I _believe_ it's this:
23:25:08 <Pseudonym> A becomes forall t. (A -> t) -> t
23:26:25 <ski> of course it depends if it's the by-value or by-name CPS transform
23:26:42 <ski> s/if/on if/
23:29:11 <ski> one can have two mutually recursive transforms, one for values, and one for expressions
23:30:07 <ski> [[t]]_e = forall alpha. ([[t]]_v -> alpha) -> alpha
23:30:30 <ski> [[t0 -> t1]]_v = [[t0]]_v -> [[t1]]_e
23:31:13 <ski> [[a]]_v = a  -- for tyvars a, and at least for some basic types (like Int, etc ..)
23:31:29 <ski> (btw, this is for by-value CPS transform)
23:32:35 <ski> palomer : all clear ?
23:38:04 <palomer> by value cps
23:38:38 <palomer> ski: and, erm, I don't have values in my calculus
23:39:06 <palomer> Pseudonym: you probably did, but my scroll window only goes so far
23:39:30 <ski> http://tunes.org/~nef/logs/haskell/05.07.20
23:39:54 <ski> palomer : what kind of calculus do you have ?
23:40:10 <ski> and you want some kind of CPS transform ?  for what ?
23:40:16 <palomer> typed lambda calculus
23:40:18 <palomer> call by value
23:40:43 <ski> "<palomer> ski: and, erm, I don't have values in my calculus" ?
23:40:52 <palomer> nope, only terms
23:41:36 <palomer> and the type system is second order predicate calculus (with forall, SO forall and implication)
23:41:57 <palomer> so integers are expressed as church numerals (usually)
23:42:08 <ski> if you have e.g. '(\x. x) ((\x.x) (\x.x))'  don't you simplify the argument '((\x.x) (\x.x))' before substution into the function '(\x. x)' ?
23:42:42 <palomer> my calculus is confluent
23:43:17 <palomer> but, erm, left most reductions
23:43:18 <ski> re forall, do you have corresponding "big-lambda" taking types on the term level ?
23:43:43 <palomer> ah, no
23:43:46 <ski> what do you mean by saying that you have call-by-value ?
23:43:47 <palomer> not even for small lambda
23:43:55 <ski> ?
23:44:37 <palomer> actually no, it's not left most reduction
23:44:57 <ski> by big-lambda i mean stuff like     (/\a. \x : a. x) : forall a. a -> a
23:45:08 <palomer> yeah, this is how my type system works:
23:45:21 <palomer> a is of type T iff a is a proof of T
23:45:32 <ski> ok
23:45:46 <palomer> first and second order specification/abstraction don't change the term
23:45:51 <palomer> and implication does the usual shtick
23:46:01 <palomer> so you end up with terms in pure lambda calculus
23:46:12 <ski> so do you have explicit or implicit proof term constructions for e.g. forall introduction and elimination ?
23:46:20 <palomer> yeah
23:46:24 <palomer> they don't change the term
23:46:40 <palomer> ditto for second order forall
23:46:43 <ski> i take that as meaning implicit suchwise ..
23:46:50 <palomer> hmm?
23:47:09 <ski> i.e not  (/\a. \x : a. x) : forall a. a -> a   rather   (\x : a. x) : forall a. a -> a
23:47:21 <palomer> the terms type by A -> A are the same as the terms typed by forall^0.A (A->A)
23:47:43 <ski> only if A doen't occur anywhere else, surely ?
23:47:49 <palomer> (\x.x) : forall a. a -> a
23:48:16 <palomer> ski: A -> A is a formula
23:48:21 <ski> yes
23:48:29 <palomer> so where could A occur elsewhere?
23:48:41 <palomer> oh, write, there are no given types
23:48:45 <palomer> s/write/right
23:48:46 <ski> assumptions ?
23:48:48 <palomer> none
23:48:59 <palomer> (and yes, this calculus is useful)
23:49:14 <ski> f : A -> A |-  (\x. f (f x)) : A -> A
23:49:45 <palomer> ski: sure
23:50:49 <palomer> now, I want to use the cbv CPSification on these terms
23:51:01 <ski> you have this kind of assumptions, typing free variables, yes ?
23:51:24 <palomer> the axiom rule?
23:51:39 <palomer> x: A |- x:A
23:51:43 <ski> e.g. yes
23:51:49 <palomer> yup
23:52:28 <ski> so, the type A (of the term x there) can not be the same as the type forall A. A
23:53:01 <palomer> "be the same" = "have the same inhabitants" ?
23:53:17 <ski> yes
23:53:24 <palomer> but, err, A is not provable
23:53:26 <ski> (sorry for being imprecise)
23:53:30 <palomer> neither is forall A.A
23:53:43 <ski> A is provable, under the assumption of A
23:53:52 <ski> x:A |- x:A
23:54:09 <ski> same with
23:54:16 <ski>  f : A -> A |- (\x. f (f x)) : A -> A
23:54:24 <ski> surely that is not the same as
23:54:29 <palomer> oh, I see your parenthesis now
23:54:29 <ski>  f : A -> A |- (\x. f (f x)) : forall A. A -> A
23:54:36 <palomer> no, they differ under the assumption x:A
23:54:44 <ski> right
23:55:28 <ski> terms may in general have fre variables, so i thought it would be incorrect to say "the terms type by A -> A are the same as the terms typed by forall^0.A (A->A)"
23:55:41 <ski> (another case if you'd said "closed terms")
23:55:54 <palomer> ski: in this case, they're the same up to alpha/beta equivalence
23:56:00 <palomer> but it's a fluke
23:56:15 <palomer> actually, it's not a fluke
23:56:16 <palomer> it's true
23:56:34 <palomer> since the first thing you do is use forall^0 intro
23:56:43 <palomer> which is almost identical to forall intro
23:56:54 <palomer> oh, right, that's what you said
23:57:26 <ski> yes, the intro rule requires the var being quantified to not appear in assumptions
23:58:02 <palomer> yeah
23:58:07 <ski> hm, is your 'forall^0' first order ?  (and 'forall' second order ?)
23:58:18 <palomer> nono, forall^0 is second order
23:58:25 <palomer> it's a forall on all 0ary predicates
23:58:35 <ski> ok
23:58:54 <ski> yes, i see that now that i look more closesly :)
23:59:24 <ski> ok, so you want cbv CPS transformation on your terms, then ..
23:59:24 <palomer> second order elim is a little more complicated
23:59:29 <palomer> yeah
