00:48:50 <frederik> woot, got WASH compile time down from 17 minutes to 2 minutes (on 2.8GHz pentium 4)
00:49:31 <stefanw> what did you do?
00:52:49 <dons> stefanw, run it in another thread while sleeping, of course ;)
00:56:34 <frederik> i broke up some of the large modules since ghc compile time is super-linear in module size
00:56:40 <frederik> and i removed some unused modules
00:56:56 <frederik> (HTMLPrelude* are no longer used right?)
00:58:07 <stefanw> I don't know, but you are right, the autogenerated modules are pretty bihg
00:58:33 <frederik> well HTMLPrelude* are not documented or used by any other WASH modules
01:00:39 <frederik> it seems silly that you have to split up modules though. i sent something to glasgow-haskell-bugs but no responses. not sure if it got through
01:01:55 <stefanw> hm, a quick fix would be too limit the size of a module :-))
01:41:39 <lispy> hm...so quiet
01:45:15 <der_eq> too quiet...
01:47:54 <TheHunter> @moo
01:48:55 <TheHunter> @arr
01:48:56 <lambdabot> Aye Aye Cap'n
01:49:02 <TheHunter> @yow
01:49:04 <lambdabot> Yow!  Is my fallout shelter termite proof?
01:49:45 <TheHunter> @ghc
01:49:46 <lambdabot>  Duplicate instance declarations
01:49:50 <TheHunter> @code
01:49:51 <lambdabot> Error.hs: throwIfNull :: String -> IO (Ptr a) -> IO (Ptr a)
01:58:14 <pejo> When trying to run the test suite I get framework failures. The testlib seems to be written in Python. So I tried with Python 2.0, 2.1 and 2.3.3 in hope of finding a version that would just work out of the box. It claims the compile failed.
01:58:37 <pejo> No test001.comp.stderr is created. When running the compiler with exactly the same flags in my shell it works like a charm.
02:00:39 <pejo> (Except that the tests seems to use sh-syntax for redirecting stderr, but I presume the test suite runs the correct shell?)
02:08:45 <lispy> @code
02:08:46 <lambdabot> PArr.hs: sliceP :: Int -> Int -> [:e:] -> [:e:]
02:08:57 <lispy> er, :e:?
02:09:04 <lispy> what the heck is that?
02:09:35 <TheHunter> @index sumP
02:09:36 <lambdabot> bzzt
02:09:37 <autrijus> [::] is builtin syntaxof parallel haskell
02:09:55 <autrijus> denoting a strict array
02:14:59 <autrijus> @vixen software transactional memory
02:15:01 <lambdabot> what are you
02:16:29 <lispy> transactional memory?
02:16:33 <lispy> that's extreme
02:17:41 <autrijus> really? I thought it's just a nice idea
02:19:05 <lispy> doesn't it have a lot of overhead?
02:19:26 <lispy> so if you had transactional memory wouldn't everything you do have a lot of overhead...
02:19:54 <lispy> Natural Causes
02:19:54 <lispy> 87%
02:19:54 <lispy> Disease
02:19:54 <lispy> 73%
02:19:54 <lispy> Bomb
02:19:55 <lispy> 67%
02:19:57 <lispy> Posion
02:19:59 <lispy> bleh
02:20:01 <lispy> sarry
02:20:23 <lispy> those are my results from a quiz on how i'll die :)
02:21:01 <autrijus> lispy: no, it does not; see http://homepages.inf.ed.ac.uk/wadler/linksetaps/slides/peyton-jones.ppt and http://research.microsoft.com/Users/simonpj/papers/stm/ :)
02:30:47 <jlouis> lispy: stm doesn't have a lot of overhead. Not more so than a typical locking semantics stuff
02:31:31 <autrijus> and considerably lower for complex systems where it's very hard to get the optimal synchronisation sequence.
02:32:31 <jlouis> the solution is interesting. Though the first thing I would build with it would be a messaging queue
02:32:52 <autrijus> there's TChan and TVar.
02:33:15 <autrijus> for channels and shared storage. you also get TMVar for locks
02:33:36 <jlouis> strike last line by me out then
02:33:41 <autrijus> :)
02:38:37 <pejo> Is the start point for ghc programs __stginit_Main_ normally?
02:55:08 <dons> pejo, yep
02:57:30 <TheHunter> moin dons, how's icfpc going?
02:58:11 <dons> good, I think :)
02:58:22 <dons> though we fell into a ghc code gen bug at one point
02:58:34 <dons> and just surived some scheduler issues :}
02:59:08 <TheHunter> hehe.
02:59:33 <dons> 4 hrs to go!
04:01:20 <wilx> Yay!
04:01:35 <wilx> How long is it going to take for the judges to give their ruling?
04:02:20 <TFK> When all the bribe money has arrived.
04:02:33 <wilx> :D
04:02:44 <wilx> Judges' prize essays due  	   	Monday, July 18th, 9:00am CDT (UTC-5)
04:03:09 <wilx> o_O
04:03:37 <wilx> How does it work? Do we get to see the solutions before their ruling?
04:07:16 <Igloo> what solutions?
04:07:26 <dons> there are solutions now?
04:07:31 <Igloo> The essay is only about your entry
04:07:54 <dons> how lovely it would be if there was *the solution* ;)
04:08:21 <Igloo> Well, 2 years ago there was  :-)
04:08:34 <wilx> Heh, ok, the entries then. :)
04:08:43 <Igloo> Well, probably a set of optimal solutions rather than a unique one
04:08:59 <dons> ah, ok.
04:09:01 <wilx> I just want to see how different the entries are etc...
04:09:05 * dons goes back to hack
04:09:30 <wilx> I looked at the ant collony problem entries and it was very interesting :)
04:12:11 <Igloo> dons: Eh? You haven't finished yet? Geez  :-)
04:24:07 <dons> hehe
05:27:54 <pejo> Igloo, about my question yesterday - there seems to be some sort of PIC support thats started (but not completed for sparc), hence the trouble.
06:16:14 <Igloo> So, I guess it must be time to start writing the robber now
06:16:36 <dons> oh, that's a good idea Igloo!
06:16:50 <dons> @karma+ Igloo
06:16:51 <lambdabot> Igloo's karma raised to 1.
06:16:53 <autrijus> @eval True == otherwise
06:16:53 <lambdabot> type error
06:17:06 <dons> @plugs otherwise
06:17:11 <lambdabot> True
06:17:17 <autrijus> @plugs True == otherwise
06:17:19 <lambdabot> True
06:17:39 <autrijus> @plugs otherwise == (True == otherwise)
06:17:40 <lambdabot> True
06:17:53 <autrijus> how is @eval different from @plugs?
06:18:50 <arjanb> the first one is only an extended lambda calculus evaluator
06:21:12 <Igloo> Maybe mv @eval @lambda; ln -s @plugs @eval would be a good idea
06:21:20 <dons> good idea
06:21:29 <dons> will do
06:21:40 <dons> @timein Sydney
06:21:43 <lambdabot>  Sunday, July 10, 2005 at 11:22:45 PM EST
06:21:47 <dons> @timein London
06:21:50 <lambdabot>  Sunday, July 10, 2005 at 2:22:50 PM BST
06:21:52 <dons> @timein Chicago
06:21:54 <lambdabot>  Sunday, July 10, 2005 at 8:22:56 AM CDT
06:27:43 * dons is out of here!
06:27:48 <dons> nitol!
06:27:53 <Igloo> g'night
06:27:56 <Igloo> And g'luck
06:27:58 <Beelsebob> night
06:35:38 <asd> #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team
06:35:42 <asd> #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team
06:35:46 <asd> #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team #fazlamesai Turkish Linux Team
06:36:11 <Beelsebob> Yay! Spam lovely spam
06:46:15 <wilx> omg
06:54:57 <autrijus> @pl \x y -> foo x
06:54:58 <lambdabot> const . foo
06:55:11 <autrijus> @pl \x y -> foo y
06:55:12 <lambdabot> const foo
06:55:16 <autrijus> right. of course.
07:06:08 <TheHunter_> i did it again: *** Exception: typecheck/TcSimplify.lhs:(2090,13)-(2091,60): Non-exhaustive patterns in case
07:06:48 <Beelsebob> hmm?
07:07:36 <TheHunter_> that's a ghc bug.
07:07:58 <Beelsebob> it certainly is
07:08:24 <TheHunter_> probably not a severe one, as i'm thinking what I wrote you give an error message anyway.
07:08:41 <TheHunter_> i'd expected some kind of unresolved overloading
07:09:38 <TheHunter_> well, let's see if it's fixed in the latest snapshot...
07:11:29 <Beelsebob> probably the missing case is... _ -> error "Unresolved overloading"
07:20:37 <dcoutts> yay! icfp contest over :-)
07:21:14 <dons> yay sleep :)
07:21:45 <dcoutts> :-) how did it go dons?
07:22:50 <dons> hey, ok I reckon. but it's pretty hard to exploit all the information ...
07:23:19 <dons> how about you guys?
07:26:02 <adept> too much information to consider in order to come up with good strategy, i think
07:26:12 <adept> almost undoable with one-man team
07:26:16 * adept sighs
07:26:54 * dons throws sympathy over to adept
07:27:28 <adept> dons: how about you? what's your submitted startegy, briefly?
07:27:58 <adept> I ended up with sophisticated robber which statically evaluated all possible moves using set of evaluation strategies
07:28:33 <adept> and cop with keeps search-map of locations where robber could be, and moves, plans and votes taking that map into account
07:28:44 <adept> I was unable to do more in time allotted
07:31:43 <dons> i enjoyed some of our timeout and computation  code
07:32:21 <dons> computing in spare cycles in haskell, and having hard deadlines for results, can be tricky with laziness
07:32:43 <wilx> Spare cycles?
07:33:20 <adept> dons: let me guess, forkIO, weighted queue of results computed so far in some mvar, and taking head of the queue on timeout?
07:33:39 <adept> dons: btw, do you plan to share your code?
07:34:12 <dons> oh, probably. i'd have to talk to the other guys
07:34:54 <dons> yeah, basically that's the idea
07:35:05 <wilx> Huh.
07:35:18 <wilx> Sophisticated.
07:35:37 <dons> its fun to squeeze out 5 seconds from each timeslot :)
07:35:51 <dons> so you end up having nearly 20 seconds to compute moves
07:36:09 <adept> wilx: i doubt if there is way to do it any other way :)
07:36:12 <wilx> What was the limit?
07:36:37 <adept> dons: my problem was to come up with strategy powerfull enough to consume 5 seconds :)
07:36:44 <wilx> adept, well, I did read the specification and the first thing that I thought about was purely action-reaction stuff.
07:37:03 <adept> wilx: client-server setup, and client had to respond to each server message within 5 seconds
07:37:16 <wilx> Hm.
07:37:47 <adept> wilx: "whenever you have to produce a message, you must do so within 5-second limit"(quote)
07:41:11 <dons> well, it was fun. and i learnt some new tricks. so it was worth the 4 days i reckon
07:41:44 <dons> however, time for some sleep now. /me  sleeps
07:43:00 <dcoutts> adept, yes, we didn't really have enought to compute to think about doing the concurrency stuff to make full use of available time
07:44:44 <dcoutts> I agree about the information overload. Lots of different possible strategies, each with tradeoffs and disadvantages
07:45:45 <adept> dcoutts: how many ppl was in your team?
07:45:50 <adept> and how much code?
07:45:51 <dcoutts> adept, 3
07:46:02 <dcoutts> adept, what lines of code?
07:47:28 <adept> you know, like in 'wc -l *.hs' :)
07:47:42 <dcoutts> one better, using sloccount...
07:48:23 <adept> i'm not sure that sloccount could grok haskell
07:48:29 <dcoutts> it does :-)
07:48:36 <dcoutts> Total Physical Source Lines of Code (SLOC)                = 4,137
07:49:12 <dcoutts> I love the high value sloccount gives to Haskell programmers!
07:49:18 <dcoutts> Total Estimated Cost to Develop                           = $ 119,995
07:49:19 <dcoutts>  (average salary = $56,286/year, overhead = 2.40).
07:49:45 <dcoutts> that's assuming anyone actually wanted the program however :-)
07:50:42 <dcoutts> wc -l */*.hs
07:50:42 <dcoutts>   5498 total
07:51:00 <adept> i dont have sloccount handy, so it's 'wc -l' for me. 1237 non-empty lines
07:51:19 <dcoutts> some of that total includes support tools
07:51:24 <adept> or 1458 including non-empty
07:53:04 <adept> it's good to see that in the "wc scale" my team of one made roughly 26% of you team of three :)
07:53:25 <dcoutts> :-)
07:54:12 <dcoutts> you can't see how much ugly and redundant code we've got :-) (yet)
07:54:35 <adept> "yet"? does this mean that you'll share your code? great!
07:54:52 <dcoutts> I'm sure we will
08:09:49 <cm_> moo
08:10:27 <Akshaal> woo
08:13:15 <ape> off topic, but how is one supposed to make big life decisions? i'm young
08:13:40 <ape> this channel i think has lots of old and experienced men
08:13:47 <Spark> flip a coin
08:13:56 * adept strokes his beard
08:14:37 <adept> have you seen "interstate 60". there was nifty decision-making ball there :)
08:15:09 <ape> didn't see it, but this is serious shit i'm talking about, life and death
08:17:36 <cm_> decide pro life :)
08:17:54 <adept> do you seriously expect anyone to give it more thought than you?
08:18:29 <ape> thing is, i think i know what to do, but *everyone* i talk to tells me the opposite
08:18:54 <ape> and all logic and everything says that they are right, but i just feel like i gotta do this
08:20:34 <cm_> you realize we've no idea what the problem is about ;)
08:20:42 <cm_> so all we can do is stroke our beards and nod :)
08:21:10 <ape> do you really all have beards?
08:21:14 <adept> well, consider that 1)once you begin to act, you should have no regrets, 2)at some point in the future you will die, so any regrets you'll have wont last forever. Then decide.
08:21:51 * adept really has beard
08:22:10 * metaperl has stubble
08:22:17 <metaperl> too lazy to comb/groom
08:22:40 <metaperl> my facial hair and this apartment are both stubble due to excessive IRC/Haskell/gaming
08:23:06 <cm_> i don't :p
08:23:17 <jewel> ape, I don't think a haskell channel is the right place to ask
08:23:21 <metaperl> cm == "Clean Man"
08:23:26 <cm_> :)
08:23:39 <ape> i don't know where else :|
08:23:48 <ape> well, if anyone is interested in helping me a bit more, please pm me
08:24:33 <metaperl> ape: I wish you the best of luck
08:24:53 <ape> thanks man
08:24:54 <metaperl> David Icke is my guiding light at the moment
08:25:18 <metaperl> but just one of many I have had... I will pm you
08:29:19 <Akshaal> on topic, but is there any plans for good unicode support in haskell/ghc?
08:29:44 <autrijus> Akshaal: Unicode char library is builtin for 6.4.1
08:30:07 <Akshaal> as GHC.Unicode?
08:30:17 <autrijus> I think just as Char
08:30:29 <autrijus> but maybe internally as GHC.?
08:33:51 <Akshaal> hmm... Char is already unicode, but there is no peekCUTF8String, peekCUTF16String, peekCUTF832String, withCUTF8... and so on. even putStr and co can't handle unicode in accordance with locale
08:34:49 <autrijus> ah, you're talking about encodings.
08:34:52 <autrijus> different things altogether.
08:35:18 <Akshaal> maybe :)
08:40:31 <Akshaal> so nothing new there?
08:40:48 <autrijus> not afaics. Pugs and darcs uses UTF8.lhs to do encoding
08:40:51 <autrijus> works reasonably well.
08:43:09 * Akshaal writes wrapper for taglib, which uses utf8 as internal encoding
08:43:29 <Akshaal> not a good idea to include utf8.lhs in every program and library :(
08:49:33 * Akshaal sighs
09:23:40 <frederik> is there a reason for WASH to come in so many separate packages?
09:28:57 <dcoutts> I'm finally allowed to officially announce "Project to add cairo support to Gtk2Hs wins Google Summer of Code grant"
09:29:09 <dcoutts> that's xerox to you and me :-)
09:31:19 <dcoutts> so congratulations to xerox for winning his project funding grant
09:32:32 <cm_> :>
09:33:33 <frederik> what is cairo?
09:33:55 <ape> vector drawing api
09:35:56 <dcoutts> http://www.cairographics.org/
09:36:56 <dcoutts> it getting used in the upcomming versions of lots of desktop things, like Gtk+, mozilla, OpenOffice
09:37:51 <dcoutts> it does high quality vector graphics in multiple output formats (X11 + OpenGL acceleration, psf, ps, svg, png, jpeg etc)
09:37:58 <dcoutts> psf/pdf
09:38:35 <dcoutts> oh, and Win32 and that Mac Quartz thingy
09:40:04 <ape> i also think there is ascii output support
09:40:16 <dcoutts> really? crazy :-)
09:40:31 <frederik> is there a gnuplot frontend? :)
09:40:42 <dcoutts> not yet :-)
09:43:53 <frederik> is darcs get different from just a copy?
09:58:25 <MarcWeber> Is there an option which can be added to ghc to produce smaller executables?
09:58:57 <dcoutts> there's the "split-obs" feature, however it's rather hard to use
09:59:11 <dcoutts> otherwise the best you can do is just to use strip
10:00:15 <MarcWeber> dcoutts: That has reduced file size from >400kb to 175 kb ... That's much better but big enough for just calculating some fibanocci numbers..
10:00:28 <dcoutts> apparantly the ghc devs are goin to make "split-obs" easier to use and then it'll be used by cabal (on supported platforms) so cabalised packages will be able to take advantage of smaller lib files
10:00:47 <dcoutts> MarcWeber, ghc's default links in quite a bit of stuff unfortunately
10:01:21 <dcoutts> apparently jhc's hello world is significantly smaller
10:02:08 <dcoutts> then the other thing is that hopefully we'll be getting shared library support so that'll improve things
10:03:16 <MarcWeber> Why are there so few projects on sourceforge written in haskell?
10:03:26 <MarcWeber> What is jhc?
10:03:34 <dcoutts> maybe because sourceforge doesn't use darcs :-)
10:03:44 <dcoutts> @google jhc haskell compiler
10:03:47 <lambdabot> http://repetae.net/john/computer/jhc/
10:04:19 <dcoutts> MarcWeber, jhc is still somewhat experimental
10:06:09 <MarcWeber> dcoutts: I see. *g* Haven't found it in gentoo portage tree and neither on bugs.gentoo.org where new ebuilds appear the first ..
10:07:03 <dcoutts> no, I asked John Meacham and he said it's not ready for packaging yet, but when it is I'm sure we'll get an ebuild out for it
10:08:53 <MachinShin> hey all
10:11:36 <MarcWeber> dcoutts: Where are most haskell projects hosted, then?
10:11:58 <cm_> scannedinavian.org ;)
10:13:29 <adept> icfpc.plt-scheme.org :)
10:16:57 <pejo> Speaking of binary size, is there any (recent) research in the area?
10:17:20 <basti_> you mean why binaries are so small?
10:19:03 <pejo> basti, heh, good time to jump into the discussion. ;)
10:19:10 <basti_> *G*
10:38:49 <Akshaal> which policy uses ghc about adding new function in modules?
10:39:40 <Akshaal> in standard modules
10:41:43 <Akshaal> ocaml is very conservative here, what is about haskell/ghc?
10:43:40 <Itkovian> evening
10:43:41 <Igloo> x.y can change interfaces, x.y.z can't
10:44:05 <Igloo> And the Haskell 98 interfaces are fixed, and those marked as stable are almost as fixed
10:48:45 <Akshaal> Igloo: it means that System.IO has no chances to include withOpenFile, withOpenBinaryFile, but Foreign.ForeignPtr has chance to include getForeignPtrFinalizer ?
10:49:35 <Igloo> Oh, adding things might be possible even with a stable interface
10:49:52 <Igloo> libraries@haskell.org is probably the place to ask about such things
10:50:04 <Akshaal> ok
10:50:09 <Akshaal> tnx
10:50:36 <wilx> Mhm.
10:50:50 <wilx> What was the name of the library with alternative IO?
10:51:53 <Akshaal> BinaryIO or smth like it
10:56:16 <wilx> @wiki
10:56:17 <lambdabot> http://www.haskell.org/hawiki/
10:57:52 <basti_> uhm
10:57:58 <basti_> whats that alternative IO?
10:58:15 <basti_> http://haskell.org/hawiki/BinaryIo
10:58:54 <wilx> I remember it was something incomplete that tried to use type classes to abstract out files/sockets/etc. IO...
10:59:18 <basti_> aha.
11:02:11 <wilx> @hgoogle MissingH
11:02:12 <lambdabot> Maybe you meant: google hoogle
11:02:16 <wilx> @hoogle MissingH
11:05:14 <wilx> http://darcs.complete.org/missingh.lgpl/MissingH/IO/HVIO.hs
11:05:16 <wilx> This is it.
11:06:21 <metaperl> complete.org is.... fairly complete :) blog site and darcs there
11:18:40 <wilx> Bah, it depends on package "unix" :(
11:28:17 <Akshaal> what is current status of hackage ?
11:29:39 <Akshaal> Demo hosted by Shae Erisson: http://scannedinavian.org/cgi-bin/hackage/hackage
11:29:49 <Akshaal> The requested URL /cgi-bin/hackage/hackage was not found on this server.
12:06:39 <Helmutt> Hi all! I'm trying to learn haskell... But there is one thing (ok, maybe more things) I don't understand. For example how do I get a specific item out of a list or tuple. Since I've programmed python very much, I'm used to use mylist[theitem] , how do I do it in haskell?
12:07:04 <Beelsebob> either you pattern match it
12:07:13 <Beelsebob> or you use the selectors (fst, and snd)
12:07:18 <Helmutt> pattern match?
12:07:21 <Beelsebob> well...
12:07:40 <Beelsebob> myFunction (x, y) = x + y
12:07:54 <Beelsebob> will grab the items out of the touple and add them
12:07:58 <Beelsebob> tuple*
12:08:10 <Akshaal> Helmutt: l = [1,2,3,4]; frst = l !! 0, scnd = l !! 1, thrd = l !! 2 and so on...
12:08:22 <Beelsebob> (myFunction :: Num a => (a, a) -> a)
12:08:36 <Beelsebob> akshaal: that's lists, not tuples
12:09:06 <Akshaal> Beelsebob: i know, but he asked about list and tuples
12:09:12 <Beelsebob> oh, sorry
12:09:23 <Helmutt> Aha! Okey, so the !! thingie is used to get list items and types is used with tuples?
12:09:30 <Beelsebob> still, for lists, the index function iss bad... should use the pattern match again
12:09:48 <Helmutt> Why is it bad?
12:09:59 <Akshaal> O(n)
12:10:00 <Beelsebob> because it requires linear time
12:10:13 <Akshaal> where n - index
12:10:16 <Beelsebob> myOtherFunction [] = something
12:10:16 <Beelsebob> myOtherFunction (x:xs) = x + myOtherFunction xs
12:10:57 <Helmutt> Yes but that's do add all of the items, if I want to get speccific items?
12:11:03 <Helmutt> *specific
12:11:13 <Beelsebob> then you do want the index function
12:11:20 <Beelsebob> but it's very rare that you want to do that
12:11:29 <Helmutt> ok
12:11:37 <Beelsebob> and if you need to access random indexes, you should probably redesign your algorithm
12:11:51 <Helmutt> yeah :D
12:11:52 <Akshaal> sure :)
12:12:04 <Beelsebob> out of interest, what do you want to do where you need to grab random indexes?
12:14:52 <Helmutt> I dont want to grab random indexes, I'm just curious, or how I spell that :D
12:15:01 <Beelsebob> fair enough
12:15:08 <Beelsebob> btw... it's quite easy to define...
12:15:37 <Beelsebob> (!!) :: Integral a => [b] -> a -> b
12:15:55 <Beelsebob> (!!) (x:xs) 0 = x
12:16:10 <Beelsebob> (!!) (x:xs) n = xs !! (n - 1)
12:29:11 <Akshaal> mmm
12:29:23 <Akshaal> how to strip spaces from end of string?
12:29:58 <Beelsebob> nieve: reverse . dropWhile (== ' ') . reverse
12:30:06 <Beelsebob> na√Øve
12:30:10 <Akshaal> heh, really
12:30:37 <Beelsebob> probably actually not much less efficient than a non-na√Øve solution
12:31:43 <Akshaal> which encoding uses this channel?
12:31:48 <Akshaal> utf/
12:31:48 <Akshaal> ?
12:33:44 <Beelsebob> dropSpaces [] = []
12:33:44 <Beelsebob> dropSpaces (x:xs)
12:33:44 <Beelsebob>   | x == ' ' = if null r then [] else ' ':r where r = dropSpaces xs
12:33:44 <Beelsebob>   | otherwise = x:dropSpaces xs
12:33:52 <Beelsebob> no idea what encoding it is
12:35:04 <Akshaal> Beelsebob: tnx
12:35:23 <Beelsebob> don't know if that's right... I just typed it into IRC
12:35:33 <Beelsebob> and you'll want a type signature
12:46:10 <basti_> hmm
12:46:27 * basti_ wants to implement a "tab completion".
12:46:47 <basti_> i could maybe rewrite a lexer for that
12:47:09 <basti_> but i dont know how feasible that is
12:48:52 <jlouis> utf-8 is the encoding
12:49:49 <basti_> yes.
12:49:59 <Akshaal> "non-na√Øve" which character is between 'a' and 'v' here?
12:50:03 <Akshaal> i?
12:50:09 <basti_> an i "trema"
12:50:13 <basti_> ;)
12:50:17 <basti_> "i trema"
12:50:29 <basti_> with diaresis. two dots.
12:50:47 <basti_> √§√∂√º√ü√Ñ√ñ√ú < can you read this?
12:51:01 <basti_> aou(szligature)AOU?
12:51:45 <Akshaal> can't
12:51:55 <Akshaal> Œ¡◊≈“Œœ≈ À¡À … ‘Ÿ :)
12:52:19 <jlouis> Beelsebob: dropSpaces can also be programmed as a foldr-variant
12:52:56 <Beelsebob> I guessed as much
12:53:18 <basti_> Akshaal: bad.
12:56:36 <Beelsebob> —Å–¥—Ä–∞—Ç–≤–∏?
12:56:43 <Beelsebob> bah... missed a c
12:57:06 <Beelsebob> can't spell russian, anyway
13:00:07 <tuomov> ‚Üê‚Üì‚Üí‚Üë
13:00:21 * Beelsebob left down right up!
13:00:46 <Akshaal> tuomov: how did you setup utf8 for irssi?
13:00:58 <tuomov> charconv module
13:01:15 <tuomov> cvs irssi should also include character set support directly
13:01:40 <tuomov> google for norpan charconv irssi
13:02:07 <tuomov> some of the files should include instructions... you will unfortunately need irssi sources to compile it
13:03:40 <tuomov> if you only use utf-8, it should be simpler than that
13:03:53 <tuomov> /set term_type utf-8 or something
13:04:30 <Akshaal> no, I have channels with native charset
13:04:35 <tuomov> but I am on some backwards channels (in ircnet) where people oppose moving to utf-8
13:07:40 <Beelsebob> heh... probably using mIRC on windows... which supports UTF really baddly
13:08:18 <tuomov> software should include options to turn off stupid KiBs to simple k:s and M:s as those are appearing in way too many programs
13:08:29 <frederik> how do i make cabal install in a user package db? configure --user doesn't work :(
13:08:32 <tuomov> wasting my precious screen space and looking stupid
13:09:11 <Beelsebob> toumov: ???
13:09:25 <Beelsebob> what's a KiB?
13:09:29 <tuomov> kibibyte
13:09:38 <basti_> kiba?
13:09:46 <tuomov> a stupid hack that is supposed to "fix" marketdroids thinking kb=1000 bytes
13:09:56 <Beelsebob> ah... okay
13:10:10 <Beelsebob> why does it waste screenspace?
13:10:27 <tuomov> so now supposedly kb=1000 bytes, and KiB=1024 bytes
13:10:35 <tuomov> but I'm never going to switch to such stupid notations
13:10:47 <tuomov> uses two characters more than necessary
13:10:48 <Beelsebob> eh... kb is kilobit
13:10:49 <Akshaal> :)
13:10:53 <tuomov> whatever
13:11:18 <tuomov> and looks stupid
13:11:24 <Beelsebob> yeh... true
13:11:25 <tuomov> sounds even more stupid
13:11:27 <dbremner> tuomov - my understanding is that KiB et al are the SI units.
13:11:38 <tuomov> what's bits have to do with SI anyway?
13:11:47 <Beelsebob> personally I think the solution is to slap the marketing idiots
13:11:51 <tuomov> k in context of bytes = 1024. period.
13:11:59 <Beelsebob> stop them trying to say things are bigger than they are
13:12:14 <tuomov> k = 1000 in context of bytes is absolutely useless
13:13:20 <tuomov> so why use an awful notation for what is the normal thing to talk about
13:13:29 <tuomov> or an even more awful name
13:13:33 <ustenzel> pah, 1024 is equally useless.  i mean, what's that in hex?  0x400 -- completely useless.
13:13:51 <Beelsebob> yes... the point is it's 1000000000 in bin though
13:13:55 <ustenzel> we need prefixes for 2^8, 2^16 and so forth!
13:14:09 <Beelsebob> true
13:14:15 <Beelsebob> let's make them up then!
13:14:20 <ustenzel> Beelsebob: Right on the spot!  *10* zeroes!  Useless!
13:14:42 <ustenzel> there should be 8 of them, that would be an intelligent solution.
13:14:46 <tuomov> anyway, I hate increasingly many programs displaying KiB and MiB and GiB  and having no option to display plain old kB and MB and GBs or even just plain k, M, G
13:14:55 <dbremner> tuomov - http://physics.nist.gov/cuu/Units/binary.html I'm not thrilled with the idea, but it's no more or less useless than any number of other standards.
13:15:32 <tuomov> it's totally worthless
13:15:55 <tuomov> a waste of ink and screen space at the most
13:16:15 <Beelsebob> so... 2^8 is from now on the chunk, and 2^16 the blown chunk?
13:16:25 <Beelsebob> *g*
13:16:29 <tuomov> the moment ls -h starts displaying kibis I'll fork the world
13:16:51 <ustenzel> Yeah!  And make 2^32 an overblown chunk, too!
13:17:20 <tuomov> (or switch to windows or something)
13:17:32 <Beelsebob> and then I can blow chunks when I'm out drinking, and when I'm not :)
13:17:55 <Beelsebob> ustnzel: 2^24 surely
13:18:25 <ustenzel> i don't think so.
13:18:56 <Beelsebob> well... 2^10, 2^20, 2^30, so surely 2^8, 2^16, 2^24
13:18:59 <ustenzel> linear growth causes performance problems, we should go for exponential groth right away.
13:19:09 <tuomov> hmm.. at least lynx has option to display bytes/sec...
13:19:10 <Beelsebob> that is exponential growth
13:19:19 <ustenzel> ...but i certainly could live with that, too :)
13:19:19 <Beelsebob> it's linear growth in the exponent
13:19:26 <tuomov> it's quite unreadable, but at least I won't see ugly KiBs
13:20:03 <Beelsebob> @listcommands
13:20:04 <lambdabot> all-dicts arr babel botsnack code define definitions devils dice
13:20:04 <lambdabot> dict dict-help docs dummy easton echo elements eurohaskell eval fact
13:20:04 <lambdabot> fact-cons fact-delete fact-set fact-snoc fact-update foldoc fortune
13:20:04 <lambdabot> gazetteer get-definition ghc google help hitchcock hoogle hoogle+
13:20:04 <lambdabot> index jargon karma karma+ karma- kind learn libsrc listchans
13:20:06 <lambdabot> listcommands listmodules lojban moo more paste pl pl-resume plugs
13:20:08 <lambdabot> pointless prelude quote remember resume seen source spell state
13:20:10 <lambdabot> [3 @more lines]
13:20:40 <Beelsebob> @plugs 15000000000 / (2 ^ 8)
13:20:45 <lambdabot> 5.859375e7
13:21:19 <Beelsebob> @plugs 15000000 / (2^24)
13:21:20 <lambdabot> 0.8940696716308594
13:21:33 <Beelsebob> hmm... I have a 0.9 overblown chunk iPod
13:21:50 <Beelsebob> no I don't
13:21:54 <Beelsebob> I just can't count
13:22:16 <Beelsebob> @plugs 900 / (2^8)
13:22:17 <lambdabot> 3.515625
13:22:29 <Beelsebob> I have a 3 superoverblown chunk iPod
13:26:59 <frederik> so no one knows how to make cabal install in the user's package.conf? i can't believe it's not a feature
13:35:20 <Igloo> --user
13:52:01 <putter> Hi, I'm trying to wrap Text.Printf.printf in a catch.  printf is PrintfType r => String -> r, where r can be String or IO a.  catch is IO a -> (Exception -> IO a) -> IO a.  I'm not managing to get it quite right.  Any suggestions?  Thanks.
13:53:32 <dcoutts> it really does depend on wether you're using printf in a pure fashion or in the IO monad
13:53:44 <dcoutts> you can only catch exceptions in the IO monad
13:58:33 <dcoutts> frederik, re your email on Haskell-cafe, you need to use --user when calling ./setup register --user
13:59:10 <dcoutts> from ./setup register --help:
13:59:10 <dcoutts> --user         upon registration, register this package in the user's local package database
14:15:53 * tumbleweed blows mournfully across the desolate plains of #haskell
14:16:21 <poetix> Sorry...I've done that gag before...
14:16:55 <dcoutts> :-)
14:22:36 <heatsink> How do I declare a variable's type, using a type variable bound in an enclosing scope?
14:22:46 <lightstep> why is Text.Printf.printf so backwards?
14:23:36 <heatsink> huh?
14:24:03 <heatsink> it looks okay to me.
14:24:22 <lightstep> you can't compose it with any other function
14:24:36 <lightstep> you aren't type-safer than passing the parameters in a list
14:26:41 <heatsink> You can't have a function whose type depends on the data passed to it.
14:27:29 <Itkovian> pompompom
14:27:34 * Itkovian procrastinates
14:27:36 <heatsink> Template haskell uses typesafe printf as its running example.  It involves running code at compile-time to typecheck the code.
14:27:37 * shapr too
14:27:47 <heatsink> user-supplied code
14:27:53 <lightstep> i know that
14:28:05 <heatsink> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:28:25 <heatsink> (that's for the question I asked eralier)
14:38:03 <shapr> Is CosmicRay's fptools repo sync'd with the cvs repo? I'd like to know get into the GHC bug week via darcs.
14:39:50 <poetix> shapr: Re: the libraries list, and parsers...
14:39:53 <shapr> ?
14:39:56 <shapr> oh right
14:40:06 <poetix> Is anyone working on a PHP parser at the moment?
14:40:14 <shapr> I still haven't really released IssueFour because I've been convinced I'll get my ArrowsIntro finished.
14:40:31 <shapr> I don't know of anyone working on a PHP parser, you want to lead that project? :-)
14:40:58 <poetix> I probably lack the time, skillz and personal qualities...
14:41:09 <poetix> On the other hand, it's an itch I've had before
14:41:17 <poetix> And I would like to scratch it some time.
14:41:25 <Itkovian> poetix: what would you use a PHP parser for?
14:41:36 <shapr> I'd use it to build PHP lint tools.
14:41:54 <poetix> To map out PHP apps like WordPress, and generate representations of their structure - dependencies, where all the functions were, that sort of thing
14:41:57 <shapr> Or possibly a PHP compiler.
14:42:51 <poetix> So that when you downloaded something like Drupal or Wordpress, and wanted to hack it for some reason, you could run a quick survey on the source directory and get back useful information about where everything was, which functions called which other functions, etc.
14:43:44 <poetix> A full parser probably isn't needed for that, but there are other possible uses for an AST
14:43:49 <poetix> Refactoring tools, for instance.
14:43:55 <poetix> There's a lot of bad PHP code out there...
14:44:43 <shapr> Yeah, wagle described highlevel tools that fix low level problems as 'sewage treatment', I find that poignant.
14:44:54 <Itkovian> poetix: like ctags, eh :-)
14:45:19 <poetix> Ah, yes, just like that.
14:45:32 <poetix> (I think - never seen ctags before about 30 seconds ago)
14:46:30 * poetix notes shapr's tendency to encourage people to do useful stuff they're not sure they're capable of doing
14:46:33 <Itkovian> it tags all the functions, variables, etc. in a tree with c, Java, ... code so your editor can use it to browse the code, e.g. in vim, you cn hop to the definition of a function, variable, get a list of places where function F is defined etc.
14:46:54 * Itkovian thinks poetix hits the nail right on
14:47:07 <Itkovian> we might also add 'that he himself hasn't time for'
14:47:18 <shapr> poetix: People get better by practicing above their level. The project may not 'succeed' by commercial standards, but I define success by learning and hopefully some code.
14:47:28 <Itkovian> shapr: true
14:47:42 <poetix> Yes: something like that. For PHP. In Haskell. So PHP-ers find themselves deriving real benefits from a Haskell app. Think of it as an outreach project.
14:47:48 <shapr> haha
14:48:07 <poetix> Well, just look at what's been happening with pugs...
14:48:14 <shapr> Yeah, pugs is great.
14:48:29 <shapr> So, is there a PHP spec somewhere?
14:48:36 <poetix> Well, that's sort of the problem.
14:48:42 <poetix> There's no EBNF, that I can find.
14:49:02 <shapr> Is there any sort of formal description? Or do people just use the source?
14:49:12 <Igloo> From what I know if it the syntax is very simple
14:49:16 <poetix> And I expect there's some variation between versions, too, especially between PHP 4.x and PHP 5
14:49:22 <Igloo> e.g. they don't have sugar for regexps or lambads
14:49:59 <shapr> Probably best to start with the most recent version and work your way back.
14:50:12 <poetix> I think it is simple. But there are gotchas all over the place. Like unrecognised tokens in array indices are automatically assumed to be strings for hashtable lookup...
14:50:20 <shapr> Ah, here's a PHP4 SableCC grammar...
14:50:30 <poetix> Ooh, where?
14:50:39 <Itkovian> yeah, but autrijus is a good coder, and obviously a fast learner ..
14:50:40 <shapr> Link at the bottom of http://www.php.net/manual/en/langref.php
14:51:00 <shapr> Itkovian: and he was practicing above his level at the start
14:51:13 <poetix> @foo[bar] is assumed to mean @foo["bar"] if bar is not defined.
14:51:13 <lambdabot> Unknown command, try @listcommands.
14:51:19 <Itkovian> well, he's certainly over my head. way over ...
14:51:32 <Itkovian> poetix: you might argue that such code is _bad_
14:51:36 <shapr> But that's how you get higher, you start climbing :-)
14:51:48 <poetix> Itkovian: I think it's completely awful...
14:51:49 <Itkovian> I am encouraging my wife not to follow her boss' example in htis
14:52:06 <Itkovian> she argued for two weeks with him that he should use $_POST!
14:53:14 <Itkovian> my padawan is sleeping very badly
14:53:25 <poetix> PHP has some really jaw-dropping warts. And yet - even LtU runs on PHP.
14:53:41 <Itkovian> poetix: yes, on drupal :-)
14:54:12 <poetix> I think designers of any Future Wonderful Web Language should study PHP carefully.
14:54:50 <poetix> They must overmaster their urge to recoil from its suckiness, and understand what makes it hum.
14:55:00 * poetix must take a break for a moment...
14:55:50 <Itkovian> I think PHP is quite good, but I cringe at the fact that you need not declare variables
14:56:08 <shapr> I wonder if PArrows can handle a PHP parser.
14:56:09 * shapr tries
14:56:47 <jlouis> Itkovian: I think the last version makes you change that
14:56:54 * Itkovian tries to understand PArrows
14:58:48 <Igloo> Hmm, anyone know where ghc-as-a-package lives?
15:01:04 <Itkovian> Igloo: on what distro?
15:01:25 <Itkovian> jlouis: I have no idea ... only used PHP4.x
15:01:37 <RemiTurk> hi all
15:01:44 <Itkovian> but it is a good thing to change it. Oh my, some people I know will cringe
15:01:53 <Itkovian> to my great delight, I might add
15:01:57 <Igloo> On no distro. I want docs for it
15:03:34 <Itkovian> I can't follow ...
15:03:39 <Itkovian> Enlighten me
15:04:54 <jlouis> Itkovian: it is a prerequisite for proper programming
15:05:06 <Itkovian> true
15:05:25 <Itkovian> well ... it eliminates sometimes obscure bugs
15:07:14 <Itkovian> shapr: can't you just release Issue Four and get back to work on your article by next issue?
15:07:42 <shapr> Yeah, I think I'll do that. I was hoping to stick to five articles per issue though.
15:08:34 <jlouis> then you have to write fast
15:09:52 <Itkovian> shapr: It doesn't really matter imo, as long as there are more than three ...
15:11:37 <jlouis> the summer might actually be the dead period
15:11:47 <xerox> Good evening people.
15:11:50 * Itkovian should finish his Lsystem patch
15:12:17 <Itkovian> jlouis: well, boegel's got an article that's nearly finished, and shapr too, so ...
15:24:52 <shapr> Is gcc managed by something other than update-alternatives?
15:27:53 <Itkovian> err
15:39:55 * poetix looks forward to reading shapr's Arrows article
15:45:25 <jlouis> it is good
15:45:35 <xerox> Goodnight people.
15:49:56 <Beelsebob> woohoo!
15:50:13 * Beelsebob photographs his second rare species
15:50:23 <Itkovian> a mirror?
15:50:31 <Beelsebob> hnuh?
15:50:42 <Itkovian> think about it
15:50:48 <Beelsebob> me?
15:51:09 <Itkovian> yes.
15:51:12 <Itkovian> :-)
15:51:23 <Beelsebob> actually, I just got a photo of a Halyzia 16-guttata, also known as the orange 16 spot ladybird
15:51:31 <Beelsebob> which apparently is rare in Britain
15:51:52 <Itkovian> import restrictions, eh.
15:51:56 <Beelsebob> ... not as good as my last shot (of a scarce blue tailed damselfly) which was thought to be extinct in Kent
15:52:48 <RemiTurk> hm, I hope that doesn't mean you're here to photograph rare programming languages? ;)
15:52:57 <Beelsebob> haha
15:53:34 <Beelsebob> no... I'm here to help spread a programing language that is beginning to become more common
15:53:52 <Beelsebob> haha... the ladybird just flew onto my lamp
15:54:04 <Beelsebob> then realised it was boiling hot and made a quick exit
15:54:08 <jlouis> haskell rocks
15:54:17 <jlouis> so does scarce blue tailed damselflies
15:54:31 <RemiTurk> :)
15:54:39 <Beelsebob> he's currently cleaning himself on a jug
15:55:11 <jlouis> you projected him with a dimension gun?
15:55:21 <Itkovian> maybe we need a spreadHaskell campaign eh
15:55:24 <Beelsebob> ?
15:55:33 <Beelsebob> hehe
15:56:26 <Beelsebob> hmm... I've never seen a beetle's tongue before
15:56:40 <jlouis> when you get hit by a dim. gun, you loose a dimension. Hard game to play... hitting a person once in 3 dimensions is hard. But hitting them twice or even thrice proves to be difficult
15:57:06 <jlouis> ok, I should head to bed
15:57:30 <Beelsebob> heh
15:57:54 <Beelsebob> heh... he's just fallen into a wine glass
15:58:02 <Beelsebob> lucky there wasn't any wine left in it
15:58:16 <RemiTurk> rare & drunk...
15:58:42 <Beelsebob> indeed
15:58:47 <Beelsebob> haha... he's now red
15:58:53 <Beelsebob> I think that makes him rarer
15:59:11 <RemiTurk> I think I now need to arrest you for molesting rare animals ;)
15:59:14 <Beelsebob> the only ever half red half orange 16 spotted ladybird
16:02:18 <lispy> @hoogle (a->b) -> [a] -> IO [b]
16:02:20 <lambdabot> No matches, try a more general search
16:02:36 <lispy> @hoogle (a->b) -> [a] -> m [b]
16:02:38 <lambdabot> No matches, try a more general search
16:03:05 <Beelsebob> @hoogle a -> IO a
16:03:06 <lambdabot> System.getEnv :: (String -> (IO String))
16:03:06 <lambdabot> Prelude.return :: Monad a => (b -> (a b))
16:03:06 <lambdabot> Prelude.ioError :: (IOError -> (IO a))
16:03:16 <Beelsebob> :)
16:03:24 <Beelsebob> return . map
16:04:17 <jlouis> @type return . map
16:04:22 <lambdabot> forall (m :: * -> *) a b.
16:04:22 <lambdabot>       (Monad m) =>
16:04:22 <lambdabot>       (a -> b) -> m ([a] -> [b])
16:04:39 <jlouis> ah yes, of course
16:05:27 <Beelsebob> http://www.cs.kent.ac.uk/people/rpg/tatd2/shit.png
16:06:14 <jlouis> oh
16:06:17 <RemiTurk> @type (return.) . map
16:06:18 <lambdabot> forall (m :: * -> *) a b.
16:06:18 <lambdabot>        (Monad m) =>
16:06:18 <lambdabot>        (a -> b) -> [a] -> m [b]
16:07:00 <RemiTurk> @type fmap (fmap return) fmap
16:07:01 <lambdabot> forall (m :: * -> *) (f :: * -> *) a b.
16:07:01 <lambdabot>          (Functor ((->) (a -> b)),
16:07:01 <lambdabot>           Functor ((->) (f a)),
16:07:01 <lambdabot>           Monad m,
16:07:01 <lambdabot>           Functor f) =>
16:07:03 <lambdabot>          (a -> b) -> f a -> m (f b)
16:09:18 <RemiTurk> (using instance Functor ((->) r))
16:09:37 <TheHunter> @type Control.Monad.Reader.fmap (fmap return) fmap
16:09:38 <lambdabot> forall (m :: *
16:09:38 <lambdabot>                      -> *)
16:09:38 <lambdabot>                    (f :: * -> *)
16:09:38 <lambdabot>                    a
16:09:38 <lambdabot>                    b.
16:09:40 <lambdabot>                 (Monad m, Functor f) =>
16:09:42 <lambdabot>                 (a -> b) -> f a -> m (f b)
16:10:56 * RemiTurk wonders whether to prefer nasty class constraints or kind stuff
16:14:12 <lispy> well my lisp interpreter works for builtin functions
16:14:26 <lispy> so now i need a lambda abstraction and a way to bind things
16:14:31 <lispy> then i'll have the lisp basics
16:15:48 * RemiTurk notices your nick :)
16:16:10 * RemiTurk never implemented a lisp. Am I disqualified as a functional programmer now?
16:17:22 <lispy> heh
16:17:29 <lispy> i'm trying to implement elisp
16:17:40 <lispy> and i'm finding it has some oddities, such as #' and ' are the same
16:18:26 <lispy> actually
16:18:42 <lispy> i guess that's not an oddity...(just tested it with another lisp)
16:19:00 <lispy> (apply '+ '(1 2 3))
16:19:04 <lispy> ==> 6
16:19:37 <RemiTurk> hm, I've heard elisp is a living nightmare
16:19:51 <RemiTurk> and the only lisp still using dynamic scoping
16:20:16 <RemiTurk> or perhaps I'm just getting overheated on this still-far-too-hot-attic at 01:23
16:20:39 <lispy> elisp is a night mare
16:21:49 <lispy> and i bet my finding that #' and ' behave the same is a special case with apply and symbols that have function bindings
16:22:31 <RemiTurk> well, I hope you'll keep it there then, as I think I'd better go to bed now
16:22:36 <RemiTurk> good night and good luck with it
16:22:48 <lispy> heh, good night
16:23:02 <SyntaxNinja> w00t
16:33:30 <shapr> Is there a tutorial that explains how to implement a simple language with Haskell?
16:35:35 <Lunar^> shapr: Mh... there's this harroth thing
16:35:57 <Lunar^> http://perlcabal.org/~nothingmuch/harrorth/doc/
16:36:11 <shapr> Ah, by nothingmuch
16:36:36 <shapr> Oh this looks like fun!
16:36:41 <shapr> Lunar^: Good url, thanks!
16:37:52 <SyntaxNinja> hi shapr
16:38:40 <shapr> hiya SyntaxNinja
16:39:17 <shapr> nothingmuch: Hey, you want to turn this into a TMR article?
16:40:56 <nothingmuch> TMR?
16:41:19 <nothingmuch> harrorth will be getting more attention soon, btw
16:41:34 <shapr> The Monad.Reader
16:41:51 <shapr> I've been looking for a tutorial on how to implement a minimal language in Haskell.
16:42:09 <shapr> Since that seems to be one of the killer applications of Haskell, seems like there should be more docs about it.
16:42:09 <nothingmuch> uh, sure
16:42:14 <nothingmuch> even in it's current states?
16:42:16 <nothingmuch> state?
16:42:27 <nothingmuch> harrorth is full of mistakes (intentionally)
16:42:31 <nothingmuch> i haven't resolved them all
16:42:51 <nothingmuch> well, they weren't made intentionally, but they are logged as part of the process and will be cleaned up as part of the tutorial
16:42:59 <nothingmuch> lightstep has his own forth
16:43:11 <nothingmuch> much more "haskellish", since he actually knows what he's doing
16:43:12 <nothingmuch> ;-)
16:43:38 <shapr> I'm still in 02.kwid so far...
16:43:57 <shapr> Looks good from what I've seen.
16:43:59 <nothingmuch> ah... 05.kwid gets interesting
16:44:12 <nothingmuch> 08.kwid and 09.kwid will have a sane forth, eventually
16:47:12 <lispy> kwid? is that a radio station? ;)
16:47:34 * shapr laughs at the monad description
16:47:43 <shapr> "Monads are, as you probably may have heard, representations of computations, and err, things that can fail, and uhm, more stuff. Forget about that for now."
16:48:16 <shapr> That's a good description, nobody really needs to know as long as it works.
16:49:04 <nothingmuch> lispy: kwid is a format like wikis use for writing documentation
16:49:12 <shapr> But better, afaict
16:49:19 <nothingmuch> shapr: both Reader and IO are dissected to death later on
16:49:26 <shapr> Ah, fun.
16:49:44 <nothingmuch> by far the worst is a full trace of Reader's >>= interoperating with local
16:49:50 <nothingmuch> through a short action
16:49:59 * shapr didn't get that
16:50:04 <shapr> The worst dissection?
16:50:12 <nothingmuch> yes
16:50:22 <nothingmuch> it's just a full reduction with explanation of what's going on
16:50:26 <nothingmuch> so it takes a long while
16:50:46 <shapr> oh, I see.
16:51:09 <shapr> I think most people would learn monads faster if they'd do that.
16:51:22 <nothingmuch> exactly why i  tried it ;-)
16:51:43 <nothingmuch> again, this is my learning process typed down
16:52:02 <nothingmuch> i didn't know anything till I tried it, and then I wrote about it
16:52:06 <nothingmuch> so the quality is low
16:52:10 <shapr> The full reduction worked for me.
16:52:10 <nothingmuch> but the flow is good
16:58:23 <nothingmuch> shapr: if you are still interested by the time you are through, ping me at nothingmuch@woobling.org
16:58:30 <shapr> Ok
16:58:52 <shapr> I will still be interested.
16:59:09 <nothingmuch> a possible plan is to take the finished harrorth and extract a tighter article out of it
16:59:46 <shapr> That sounds good.
17:04:39 * cm grabs a keyboard
17:05:14 * wagle wonders if anyone has seen his keyboard?
17:05:26 <Pseudonym> Yes, I've still got it, sorry.
17:05:35 <Pseudonym> You don't happen to have my coax crimper, do you?
17:05:49 <wagle> is that yours?
17:06:03 <Pseudonym> Has it got a wire stripper on it?
17:06:05 <wagle> sorry about dulling it
17:06:13 <Pseudonym> If so, probably is.
17:06:40 * Pseudonym wonders how wagle is operating his machine to use IRC
17:06:48 <wagle> i lost the key to my bike lock, and had to cut the cable
17:07:39 <wagle> cut and paste
17:07:51 <wagle> still have my mouse
17:14:17 <cm> "Practical type inference for arbitrary-rank types" is nice, pretty readable.
17:16:03 <cm> (except that I wouldn't use names like Sigma etc.)
17:16:24 <shapr> Sigma Freud?
17:17:11 <Pseudonym> "You only need to know the names of three or four Greek letters to do type theory."  -- attributed to Alex Aiken
17:19:10 <cm> I guess it's appealing to use sigma, rho, etc. directly from the typing rules.. but I find it incredibly hard to associate a concept with an "opaque name", so I always switched back and forth between the typing rules box and the source code (was reading the pdf)
17:19:32 <Pseudonym> I'm told that Aiken is really, really quotable.
17:19:38 <Pseudonym> Anyone here met him?
17:20:11 <cm> I'm afraid I don't know him ;)
17:20:42 <cm> shapr: any "progress" on your filtered todo list? ;)
17:20:51 <shapr> ?
17:21:05 <Pseudonym> "My understanding of Prolog is that there's only one algorithm, which is exponential backtracking search."
17:21:30 <ski> heh
17:21:48 <cm> shapr: you know, your list of cool unsolved problems you didn't feel like publishing unfiltered.
17:21:59 <shapr> Oh that one.
17:22:28 <shapr> Progress on that list tends to be sporadic at best.
17:22:41 <Pseudonym> Oh, my favourite Aiken quote:
17:22:50 <Pseudonym> "Turner was a card-carrying Communist... until he invented Miranda and he discovered he could make some money off it."
17:23:18 <shapr> cm: Possibly, Michael Salib helped clear up some ideas.
17:26:26 <cm> Mr. StarKiller, the guy who made the coolest Python-related presentation ever? ;)
17:26:48 <shapr> Yep, him.
17:26:53 <shapr> He spent a few days here recently.
17:27:13 <cm> Nice :)
17:27:41 <cm> Where's "here"?
17:27:51 <shapr> At my apartment.
17:28:01 <shapr> It was fun, he's a cool guy.
17:28:08 <cm> I mean, which country are you living in again?
17:28:12 <shapr> Sweden
17:29:09 <cm> Ah
17:29:25 <shapr> Have you rejoined Europe?
17:36:04 <Beelsebob> no, we still have the penis that is norway :)
17:37:26 <Pseudonym> I think they prefer "Citizen of the World for a Hundred Years".
17:58:32 <cm> shapr: no, Sept 4 I will
18:29:57 <cm> why again is forall a. a -> a less polymorphic than forall a. [a] -> [a]?
18:30:21 <cm> never mind.
20:01:14 <dons> @elite haskell is for cool hackers.
20:01:15 <lambdabot> HA$ke11 Is fOR c0Ol |-|a(xERS.
20:03:23 <heatsink> Come on, that's not the way to spell hackers.
20:03:51 <dons> it seems to produce different varients
20:03:56 <dons> each time
20:03:59 <dons> @elite hacker
20:04:00 <lambdabot> HAcKer
20:04:03 <dons> @elite hacker
20:04:04 <lambdabot> hAcK3r
20:04:07 <dons> @elite hacker
20:04:08 <lambdabot> H4cxER
20:05:19 <heatsink> @elite H4cxER
20:05:19 <lambdabot> H4cxer
20:05:25 <heatsink> @elite H4cxer
20:05:26 <lambdabot> |-|4CxeR
20:05:33 <heatsink> @elite |-|4CxeR
20:05:34 <lambdabot> |-|4(xer
20:05:42 <heatsink> @elite |-|4(xer
20:05:43 <lambdabot> |-|4(X3R
20:05:56 <dons> @elite heatsink is a cool hacker.
20:05:57 <heatsink> I suspect this will converge to a fixpoint
20:05:58 <lambdabot> |-|E4TSINk Is 4 c0o1 |-|4cxEr.
20:07:12 <lament> @elite w
20:07:13 <lambdabot> w
20:07:20 <lament> boring
20:07:26 <lament> @elite wwwwwww
20:07:27 <lambdabot> WWwW\/\/WW
20:07:36 <lament> @elite eeeeeeeeeeeee
20:07:36 <lambdabot> e33eEee3EEeEe
20:07:37 <dons> feel free to send more mappings
20:07:51 <dons> it lives in  Plugins/Elite.hs
20:07:54 <dons> @version
20:07:55 <lambdabot> lambdabot 3p47, GHC 6.4 (OpenBSD i386)
20:07:55 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:24:23 <heatsink> @elite you are
20:24:24 <lambdabot> YOu ar3
20:24:26 <heatsink> @elite you are
20:24:27 <lambdabot> y0u 4r3
20:24:28 <heatsink> @elite you are
20:24:29 <lambdabot> Y0U 4re
20:25:09 <heatsink> word translations never happen at the beginning or end of a phrase
20:25:19 <heatsink> because there are no spaces...
20:58:28 <Pseudonym> @elite haxor
20:58:29 <lambdabot> H4x0r
20:58:44 <Pseudonym> @elite haskell is 4 leet haxorz
20:58:45 <lambdabot> Hask3L| iz 4 133T hax0RZ
20:58:50 <Pseudonym> Perfect!
20:59:53 <heatsink> where do I import Modules from?
21:00:16 <dons> Modules is generated by GenModules
21:00:40 <dons> but why do you want to import it?
21:00:51 <autrijus> @elite ((a -> b) -> a) -> a
21:00:52 <heatsink> because Main.hs imports it
21:00:52 <lambdabot> ((a -> 8) -> a) -> 4
21:01:13 <dons> oh, you're just trying to find where it lives?
21:01:19 <heatsink> yea
21:01:33 <dons> $ make
21:01:34 <dons> Generating module list ... done.
21:01:46 <dons> that's producing Modules.hs in the `pwd`
21:06:11 <heatsink> hs-plugins make register gives me errors
21:06:15 <heatsink> hmm
21:06:41 <dons> more info..?
21:08:35 <heatsink> env LIBDIR=/usr/local/lib/hs-plugins ghc-pkg -u < src/altdata/altdata.conf.in
21:08:43 <heatsink> Reading package info from stdin... ghc-pkg: Line 1: Invalid syntax (no colon after field name)
21:09:59 <dons> hmmm.
21:10:13 <dons> that conf file looks right to me.
21:10:17 <dons> ghc 6.4?
21:10:21 <heatsink> yes
21:10:39 <dons> anything wrong with src/altdata/altdata.conf.in ?
21:10:41 <heatsink> Are there curly braces in your conf file?
21:11:01 <dons> curly braces?
21:11:07 <dons> only in the 6.2.2 version
21:12:11 <heatsink> So ghc-pkg broke compatibility between that and 6.4.
21:12:49 <dons> there's two differennt conf files generated. hs-plugins should handle htat.
21:12:57 <dons> does ghc-pkg refere to ghc-pkg-6.4?
21:13:35 <heatsink> yes
21:14:16 <heatsink> I think I built this when ghc 6.2.2 was installed
21:14:27 <dons> oh.
21:14:47 <dons> cleaan it out and start over
21:14:58 <dons> btw, you should see this, roughly: http://www.cse.unsw.edu.au/~dons/altdata.conf.in
21:15:00 <heatsink> make clean doesn't delete all the files...
21:15:15 <dons> make distclean ?
21:15:53 <heatsink> oh
21:17:20 <heatsink> Hmm, I'm still getting similar looking conf.in files after a distclean
21:17:41 <heatsink> I have hs-plugins-20050218, should i get something newer?
21:18:18 <dons> why not get the latest stable release, then :)
21:18:26 <dons> 0.9.10
21:19:09 <dons> @where hs-plugins
21:19:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
21:19:31 <heatsink> @where waldo
21:19:32 <lambdabot> I know nothing about waldo.
21:19:42 <heatsink> drat.
21:22:38 * heatsink looks for the Language.Haskell.Hsx module
21:23:31 <heatsink> is it HSX11?
21:25:05 <dons> @where hsx
21:25:06 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
21:34:03 <vegai> ah, new hs-plugins. Excellent
21:34:47 <dons> vegai, what are you using hs-plugins for?
21:35:34 <vegai> for lambdabot
21:35:40 <vegai> ITP.
21:35:55 <dons> oh, right ;)
21:36:03 <dons> ITP?
21:36:11 <vegai> Intention to Package (for Archlinux :)
21:36:22 <dons> ah, cool.
21:36:42 <vegai> that distro has the downside that old packages are seldom supported. So, we're 'stuck' with ghc-6.4
21:37:10 <dons> there's a port script for openbsd ports in scripts/openbsd-ports that might be helpful
21:37:25 <dons> yeah right. so you needed a new release to get 6.4 support.
21:37:31 <vegai> yep
21:52:56 * heatsink waits for lambdabot to log on
21:55:15 <heatsink> oh well
22:51:50 <MachinShin> night all
23:04:28 <lispy> *Main> evil "(+ 1 2 3 4 5)"
23:04:28 <lispy> evil "(+ 1 2 3 4 5)"
23:04:29 <lispy> 15
23:04:40 <lispy> my interpreter is getting better, little by little ;)
23:04:50 <Pseudonym> Lambdabot module?
23:05:01 <lispy> no
23:05:04 <Pseudonym> :-(
23:05:17 <lispy> @evil (+ 1 2 3 4 5)
23:05:18 <lambdabot> (line 1, column 2):
23:05:18 <lambdabot> unexpected "+"
23:05:18 <lambdabot> expecting simple term
23:05:25 <lispy> heh
23:05:57 <lispy> the next thing on my list is 'let' and after let is 'lambda'
23:06:06 <lispy> i figure once i have those two i can define functions
23:07:00 <lispy> well, okay i'll need setq alos
23:10:01 <dons> hehe, lambdabot is the standard user interface library for new interpreters these days ...
23:13:06 <Itkovian> meuning
