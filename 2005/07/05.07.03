00:08:29 <Speck> @type []
00:08:31 <lambdabot> [] :: forall a. [a]
00:08:43 <Speck> oooo
00:09:34 <lispy> @type ()
00:09:36 <lambdabot> () :: ()
00:26:18 <astrolabe> @type (,)
00:26:20 <lambdabot> (,) :: forall b a. a -> b -> (a, b)
00:51:18 <basti_> yo!
01:41:24 <basti_> lispy grows `'s
01:42:14 <lispy```> yeh
01:42:26 <lispy```> erc doesn't appear to ping the server
01:42:34 <basti_> oh
01:42:35 <basti_> thats bad
01:42:41 <lispy```> so if no one speaks i get reconnected periodically
01:42:47 <basti_> o0
01:42:50 <basti_> how bizarre
01:43:04 <lispy> i think my router is to blame
01:43:33 <basti_> no why? it would certainly route PONG's if they came
01:43:51 <basti_> they'd go over the same connection you're talking on
01:44:28 <lispy> but my router drops idle connections
01:44:34 <lispy> because it's evil
01:44:34 <basti_> oh
01:44:35 <basti_> okay
01:44:49 <basti_> you need a keepalive
01:44:50 <basti_> =)
01:45:01 <lispy> yeah
01:45:11 <lispy> erc is supposed to ping every 90 seconds
01:45:17 <basti_> but it doesnt
01:45:33 <lispy> i'm not really sure :)
01:45:47 <lispy> but the behavior i'm seeing would indicate that it is not pinging
01:45:56 <basti_> how about spying with tcpdump?
01:46:22 <lispy> perhaps
01:52:19 <shapr> gah
01:52:33 <basti_> hi shae
01:52:40 <lispy> maybe something else is wrong
01:52:49 <shapr> y0
01:54:45 <dblhelix> shapr: it's been quite a while since I dropped in here---how's Fermat's Last Theorem?
01:55:07 <basti_> margin
01:55:10 <basti_> =)
01:55:24 <dblhelix> dblhelix: ehm ... yes :)
01:59:35 <shapr> dblhelix: Still unreleased, sadly.
01:59:52 <shapr> I have a smart programmer spending a few days with me, maybe we'll hack on it some.
02:00:08 <dblhelix> shapr: what's keeping you?
02:01:14 * basti_ .oÂ° ( irc )
02:01:18 <shapr> Nothing really, I just need to add page read macros and darcs support.
02:02:06 <dblhelix> ah, well, good luck---I'm looking forward to seeing it released
02:02:09 <shapr> Who knows, maybe I'll add one of those pieces today.
02:02:10 <shapr> Ok, cool :-)
02:02:19 <basti_> shapr did you pull the latest yi patches?
02:02:27 <shapr> No, but I can do that now.
02:02:35 <basti_> do so and have a look at C-u
02:04:11 <lispy`> basti_: i think something worse is wrong, it seems erc is reconnecting far too often to be my router
02:04:24 <shapr> lispy`: Install bitlbee
02:04:29 <basti_> lispy`: did you already try tcpdumping?
02:05:01 * basti_ uses irssi for irc, and for irc only, and is pretty happy with it
02:05:08 <shapr> bitlbee is a local irc server, that should work if anything will.
02:05:15 <lispy`> basti_: no, i didn't but if it were my router, then there would have to be at least 10 minutes of inactivity for the connection to be dropped
02:05:21 <basti_> of course i understand when for example delYsid uses ERC ;)
02:05:28 <basti_> hmm yes i see
02:05:47 <lispy`> i've never really had problems with erc
02:05:59 <lispy`> we replaced our dsl modem last night
02:06:20 <lispy`> because it was dropping connection too often, i wonder if the one one just reconnects immediately
02:06:34 <lispy`> that could explain the behavior
02:06:57 <basti_> hmm i see
02:07:06 <basti_> dsl is kinda brittle sometimes yes.
02:07:06 <basti_> =)
02:49:22 <basti_> shapr: so did you try C-u
02:49:26 * basti_ wants affirmation
03:23:42 <shapr> basti_: Nah, I got distracted trying to build Yi
03:23:56 <basti_> trying?!
03:24:00 <basti_> whats wrong?
03:24:19 <shapr> I'm trying to get haskell-src-exts working for me.
03:24:37 <basti_> ohhh.
03:24:40 <basti_> been there, done that
03:54:25 <shapr> swiert_: Is your AGs article ready to go?
03:55:29 <swiert_> yep - I'd appreciate it if someone proofread it one more time and checked if they can get the examples working.
03:55:50 <swiert_> other than that its pretty much good to go
03:56:20 <shapr> ok
03:56:58 <shapr> I'd like to publish the next issue today.
03:57:26 <swiert_> sounds good.
03:58:46 <swiert_> shapr: did you get Yi working?
04:03:49 <shapr> swiert_: Not yet
04:04:17 <shapr> I have some paying work I need to do today as well as TMR work.
04:04:20 <swiert_> hmm - I had some trouble building the src-exts as well.
04:04:37 <swiert_> so I was curious
04:04:39 <shapr> Which darcs repo are you using?
04:07:05 <swiert_> yi or haskell-src?
04:07:16 <shapr> haskell-src-exts
04:07:53 <basti_> what problem do you have building it?
04:08:01 <swiert_> hang on let me check
04:09:00 <shapr> I get "Could not find module `System.Plugins':"
04:09:17 <dcoutts> shapr, just change it for Plugins
04:09:38 <dcoutts> the hs-plugins doesn't seem to have been moved to System.* yet
04:09:41 <swiert_> I get: Setup.hs: internal error: stg_ap_v_ret
04:09:58 <swiert_> which is a bit worrying.
04:10:08 <dcoutts> swiert_, using an amd64 machine with ghc 6.4?
04:10:25 <basti_> o0
04:10:34 <swiert_> no - powerpc with ghc 6.4
04:10:46 <dcoutts> oh, duno then :-(
04:11:43 <shapr> dcoutts: Change what?
04:11:48 <dcoutts> shapr, after fixing that I got another problem, can't remember what it was
04:11:55 <shapr> Oh, s/System.Plugins/Plugins
04:12:04 <dcoutts> yes
04:12:47 <dcoutts> presumably there is an unreleased hs-plugins version somewhere that lives under System.Plugins
04:13:04 <shapr> Strangely, the hs-plugins darcs repo appears to be under System.Plugins
04:13:23 * basti_ used the latest hs-plugins that was available
04:13:37 <basti_> not after getting confused by many ghc's remains hanging around
04:13:48 <shapr> oh?
04:13:51 <dcoutts> oh, well maybe you don't need to do that change, last time I looked at the hs-plugins repo it was not under Syetem.* yet
04:14:30 <basti_> i had the plugins installed, but because of some stupidity, it was installed for a different ghc than was used for compiling
04:14:38 <shapr> Silly question, how much ram does everyone here have? I have 512mb and it feels so small.
04:14:52 * basti_ has 512 and its always sufficient
04:14:58 <astrolabe> 2.5G  :)
04:15:08 <shapr> astrolabe: That sounds much nicer.
04:15:12 <basti_> i survived with 64k. everything more is pure luxury.
04:15:12 <basti_> ;)
04:15:16 <dcoutts> 1G
04:15:34 <basti_> what do you do that 512 mb of mem is not enough?
04:15:42 <dcoutts> run c2hs? :-)
04:15:44 <basti_> greenhouse effect simulations?
04:16:07 <shapr> I had the 16k ram expansion cartridge for the Sinclair, got it up to 48k total (I think). That felt roomy.
04:16:19 <astrolabe> I wrote a hex game program that kept a big search tree.  Even with 2G it is still rubbish.
04:16:30 <shapr> I wouldn't want to port GHC to the Sinclair though.
04:16:57 * astrolabe only had 16k 
04:17:11 <dcoutts> 32K BBC(b)
04:17:22 <shapr> I've heard of the BBC, never seen one though.
04:17:23 <astrolabe> but compared to the zx81 that felt like loads
04:17:37 <basti_> i mean, i started programming on a thing that could keep just over 1000 "instructions"
04:17:46 <basti_> whatever an instruction was in bits
04:18:05 <astrolabe> Are we having a 'come on then if you think you're old enough' competition?
04:18:08 <shapr> Ah, the bad old days.
04:18:18 <basti_> *g*
04:18:28 <shapr> I think I'm just trying to refresh my perspective so that 512MB will feel like way too much again :-)
04:18:53 <dcoutts> shapr, http://www.old-computers.com/museum/computer.asp?c=29
04:19:03 <basti_> no but honestly, i just about never run out of memory with my code
04:19:17 <basti_> when i do image processing maybe
04:20:54 <shapr> dcoutts: nifty
04:21:31 <shapr> I hope we get back to usable and cheap home kits with some of the new tech, maybe optical.
04:22:24 <shapr> I enjoy living on the bleeding edge where you need to build it yourself.
04:23:10 <astrolabe> Perhaps you can define the sophistication of a language by how easy it is to accidently use up all the system resources.
04:23:22 <basti_> heheh
04:23:40 <basti_> shapr: but you can do easy and cheap home stuff, with FPGA
04:23:40 <dcoutts> in that case prolog wins hands down
04:24:01 <astrolabe> FPGAs cheap?
04:24:20 <basti_> pretty cheap.
04:24:28 <basti_> of course depends on your demands
04:24:39 <basti_> but, affordeable
04:24:47 <shapr> You can buy a PCI card and FPGA for not too much money. You can spend as much as way too much money if you prefer.
04:24:52 <astrolabe> I guess you need a machine to program them, even to make 1.
04:25:11 <shapr> Actually not, you can make netlists yourself, from what I hear.
04:25:24 <basti_> astrolabe: thats right. but actually we all have one.
04:25:26 <shapr> http://en.wikipedia.org/wiki/Netlist
04:25:30 <basti_> you can but it hurts.
04:25:51 <astrolabe> Doh I get it
04:26:07 <shapr> I'd like to get the specs for older Intel microcode, then we could all have FPGAs.
04:27:31 <dcoutts> so where's the Haskell embeded domain specific language for programming FPGAs?
04:28:05 <shapr> Lava did that.
04:29:25 <shapr> Hardware design and simulation with Haskell isn't rare: Hawk, Hydra, BlueSpec, Chalmer's SoC project, etc
04:29:39 <astrolabe> How often does a haskell programmer define a new monad?
04:29:50 <shapr> When you need new semantics.
04:30:32 * astrolabe thinks
04:31:09 <TheHunter_> define like newtype deriving: quite often. implement a new monad from scratch: almost never.
04:31:18 <astrolabe> Oh and another thing.  Why is >>= called bind and not <-  ?
04:31:41 <TheHunter_> because <- is kinda syntactic sugar for >>=
04:31:52 <astrolabe> Ah thanks.
05:33:13 <pejo> I'll just throw my question out, it's probably quite ghc specific but I hope someone can offer some insight.
05:36:08 <wilx> ...
05:36:20 <pejo> I'd like to split out the native code generation from ghc, to feed it with other stuff. It doesn't seem very self contained though - the surgery seems a lot harder than trivial if one wishes to try to minimize the code changes to avoid clashes with future
05:36:22 <pejo> updates.
05:37:10 <dcoutts> there will be GHC as a library in GHC 6.6, I don't know if that'll provide access to the native code generator but it's worth looking into
05:39:14 <pejo> dcoutts, oh, nice. Any idea if any work is done on it yet/any pointers?
05:39:39 <dcoutts> check out the ghc cvs HEAD to see the status of it
05:40:58 <dcoutts> I believe that it is more aimed at the frontends (to help out IDEs and other tools) but it may provide an interface to the code generator too (probably via C--)
05:41:37 <dcoutts> if it doesn't provide that access yet it might be worth mentioning to the devs that you are interested in it
05:41:58 <dcoutts> pejo, what's your application? sounds interesting
05:42:56 <pejo> dcoutts, I have too much sparetime, so I thought I'd  plug it in to an experimental compiler for a start. '
05:43:35 <dcoutts> I wish I had too mucg spare time!
05:44:49 <michaelw> re spare time - did anybody import ghc into a darcs repo already?
05:45:37 <TheHunter> @libsrc Prelude
05:45:38 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Prelude.hs
05:51:11 <basti_> re
06:01:56 <pejo> dcoutts, if you had - you would just use it. :-)
06:02:49 <dcoutts> yeah, too true
06:09:24 <pejo> dcoutts, ah, found a commit from 03/18 which moves global state into DynFlags for the GHC API. Got something to work from now, thanks.
06:09:35 <dcoutts> cool
06:24:57 <pejo> dcoutts, heh, the API stuff is listed in the survey. I should have thought of that.
06:25:17 <basti_> re
06:29:02 * basti_ bounces
06:30:01 <dcoutts> pejo, I can't see from the GHC module that exports the api that it gives access to the code generator. Did you find anything?
06:35:47 <pejo> dcoutts, no, the "entrance" to the code generator is nativeCodeGen, only place that calls it in HEAD seems to be CodeOutput.lhs, which it was in 6.4 as well.
06:36:12 * basti_ wants fun
06:36:59 <dcoutts> pejo, hmm yes I see
06:37:27 <dcoutts> basti_, write us an IDE in Haskell! :-) that'd be fun
06:37:51 <basti_> I'm working at yi-emacs, does that count?
06:38:00 <dcoutts> actually yes it does
06:38:13 <basti_> did you pull yi?
06:38:17 <dcoutts> My dream is to base hIDE 2 on yi
06:38:41 <basti_> hIDE is somewhat associated to fudgets?
06:38:53 <dcoutts> I couldn't build Yi last time I tried because of problems with hs-plugins and gh 6.4
06:39:05 * basti_ sighs
06:39:12 <basti_> compatibility where are you.
06:39:32 <dcoutts> no hIDE 1 was an IDE for Haskell in Haskell using Gtk+. It was quite cool.
06:39:51 <basti_> oh i think ive seen a screenshot
06:40:17 <basti_> im very curious in the haskell windowing environment direction
06:40:24 <dcoutts> http://www.haskell.org/hawiki/HaskellIde
06:40:36 <basti_> did anyone ever try to wrap some existing toolkit (like wxwidgets) in arrows?
06:41:05 <basti_> yay.
06:41:10 <dcoutts> basti_, well I never miss an opportunity to market Gtk2Hs :-) someone has got an arrow layer for Gtk2Hs, let me find it...
06:41:34 <basti_> yes i've seen the screenshots.
06:41:43 <Heffalump> what benefits do arrows give over monads for this?
06:41:44 <basti_> :-O
06:41:47 <dcoutts> http://kevin.atkinson.dhs.org/fg/
06:41:54 <Heffalump> (I can sort of see why they might, but I can't see the details in my head)
06:42:12 <pejo> basti, hm. I think Magnus Carlsson did a bunch of that stuff when he was at Chalmers.
06:42:24 <basti_> well it seems that a graphical interface somewhat works like a lazy automaton or parser or whatever
06:42:31 <basti_> pejo: who?
06:42:34 <dcoutts> Heffalump, I guess it's much like the stream processor ideas from Fudgets but without the dangers of time leaks
06:42:51 <Heffalump> hmm, right
06:43:09 * Heffalump tries to learn javascript. Ick.
06:43:22 <basti_> and that arrows would be great for that purpose...
06:43:29 <basti_> javascript is nice
06:43:37 <dcoutts> Heffalump, ha ha! er.. I mean "oh, I'm sorry to hear that"
06:43:38 <tmccort> I'm using the Eclipse haskell plugin but how do I stop it from compiling after saving a source file?
06:43:43 <basti_> have you guys heard about... whats it called? booklets?
06:43:57 <Heffalump> I just want to be able to draw a box on an image and be told the coordinates I drew it at.
06:44:13 * basti_ .oÂ° ( ? )
06:44:47 <pejo> basti, hm. I ended up at http://www.cs.chalmers.se/Cs/Research/Functional/Fudgets/. Probably not what you were looking for.
06:45:49 <basti_> pejo: well i had a look into it but couldnt build it
06:45:53 <basti_> it seems nice though
06:46:32 <dcoutts> Heffalump, we're getting cairo bindings some time in the next couple months which should be really nice for drawing stuff
06:47:52 <Heffalump> I doubt it helps with my Javascript problem :-)
06:48:03 <dcoutts> oh, right :-)
06:49:27 <pejo> basti, did you get the source from http://www.cse.ogi.edu/~hallgren/untested/? It seems to be from 2005 atleast.
06:49:43 <basti_> hmm no
06:49:49 <basti_> ill check it out in a minut
06:52:12 <basti_> pejo: which one of those is the sources?
06:52:55 <pejo> basti, in Source_code directory? I'd guess Fudgets, since Alfa is some logic framework thing afiak.
06:53:45 <basti_> in Fudgets i just find lib/ and bin/
06:54:02 <basti_> ah got it
06:55:04 <basti_> yup
06:55:28 <basti_> trying to build
06:57:13 <basti_> mv: Aufruf von stat fÃ¼r ,,xtypes/objs/o/hbc/*.o" nicht mÃ¶glich: Datei oder Verzeichnis nicht gefunden
06:57:16 <basti_> HEAP=-H16Mg SOURCES="" ./hmklib
06:57:19 <basti_> ./hmklib: line 14: hbcmake: command not found
06:57:21 <basti_> make[1]: *** [objects] Fehler 127
06:59:53 <pejo> basti, heh. http://www.cs.chalmers.se/pub/users/hallgren/Alfa/Haskell/hbcmake-970521.tar.gz, but thats since 1997.
07:00:27 <basti_> =)
07:06:08 <pejo> dcoutts, ok, ghc is a nasty beast. I thought it wouldn't be too hard to add an interface for the code generator but I was obviously wrong.
07:06:50 <dcoutts> yeah, you'd want the ghc devs to add an interface to the ghc api, it'd be hard to do yourself
07:15:10 <pejo> Heh. I bet they'd be delighted to do free work for some loon on the net.
07:17:48 <basti_> ...or we build a dynamically typed shell first
07:21:20 * basti_ dissolves a pack of yum yum noodles
07:37:26 <basti_> 4:20 diaphone test was postponed to 4:39
07:37:31 <basti_> please wear ear protection
07:38:03 * basti_ oooooOOOoooooOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPRT!
07:39:14 <tessier_> pejo: Doing free work for loons on the net is what FOSS is all about! :)
07:40:10 <xs> is referential transparency one of the preconditions for confluence?
07:40:56 <basti_> :-o
07:43:24 <pejo> tessier_, well, I won't prevent you from fixing my problem. :-)
07:43:55 <tessier_> xs: I once had confluence but the doctor gave me some medicine for it and now I'm all better.
07:45:05 <xs> tessier_: i'm glad you recovered! at least you were referentially transparent with a weak equality.
07:45:11 <xs> weren't.
07:53:45 <tessier_> xs: Yeah, I really hate it when that happens.
08:16:46 * esap got some panic messages again from GHC :-(
08:17:16 <dcoutts> @seen TFK
08:17:17 <lambdabot> I saw TFK leaving #haskell 17 hours, 30 minutes and 50 seconds ago.
08:18:21 <dcoutts> esap, pah! that's nothing I've got it to make glibc complain about heap corruption (but it might be my fault - ffi things)
08:19:53 <esap> dcoutts: ok, maybe this isn't that bad. Just non-exhaustive patterns in zip_ty_env :-)
08:21:06 <esap> dcoutts: The problem is, it's doing it in a file that has 300 lines of type declarations, so it's very hard to know which part actually produces the problem.
08:21:35 <dcoutts> if it's a non-exhaustive pattern it gives you the line number doesn't it?
08:21:52 <esap> dcoutts: But the line number refers to internals of GHC :-)
08:22:05 <dcoutts> oh, then it is a ghc bug
08:22:45 <dcoutts> oh I see ghc fails when compiling your module. submit a bug report
08:24:12 <esap> I'm planning to. But first I need to figure out what part of my module does it, so I have something useful to refer to in the bug report.
08:24:22 <dcoutts> sure
08:25:20 <tessier_> Just file a bug saying "It's broke, fix it". They'll understand.
08:25:59 <esap> I tried that last time, they wanted more info :-)
08:27:04 <tessier_> heh
08:28:12 <esap> Actually, last time I said "here's the panic message from the compiler, I suppose since it says the line number, you should be able to fix the problem at that line".
08:30:21 <esap> The problem was obvious from the error message ("Non-exhaustive patterns"). But I suppose having a good test case is even better.
08:39:15 <esap> oh found it. it had the following unfinished line: "     TTerminalFunctor :: TFunctor " If I remove that, it'll all work.
09:12:34 <lstna> howdy ski
09:14:58 <ski> gogd evening lstna
09:17:34 <esap> Hmm.. How can you represent functors that are not injective on objects in Haskell?
09:18:12 * basti_ doesnt have a dim clue
09:18:15 <ski> except K ?
09:18:29 <esap> K?
09:18:31 <ski> hm
09:18:48 <ski> or maybe not
09:19:04 <ski> thought of  newtype K c a = MkK c
09:19:05 * basti_ wonders
09:19:32 <basti_> hm
09:19:39 <ski> but that's maybe a little different ..
09:19:41 <esap> maybe something like newtype K a = MkK Integer. It ignores the argument.
09:20:04 <ski> yeah, like my "K c" does, for any c
09:20:15 <basti_> why would people want something like that?
09:20:28 <ski> instance Functor (K c) where fmap f (MkK c) = MkK c
09:20:38 <esap> basti: You can use it to represent properties of categories.
09:20:50 <ski> it's not injective, in some sense
09:20:57 <basti_> i see
09:21:22 <ski> but it's very trivial noninjectiveness, i guess
09:21:36 <ski> can one build more interesting ?
09:21:48 <basti_> hmm.
09:21:49 <TheHunter> i'm pretty sure anything else is impossible.
09:21:58 <esap> basti: It's like the way of considering an arrow p : A -> V as a property of type A, the same approach, but for Cat category.
09:22:19 <basti_> arrows can be interpreted as properties? :)
09:22:46 <ski> of course :)
09:22:55 <esap> basti: yes. (I'm reading this from Lawvere: Sets for Mathematics)
09:22:58 <basti_> i knew that functions can be conclusions
09:23:01 <ski> at least CT arrows/morphisms
09:23:07 <basti_> ah THESE arrows.
09:23:13 <basti_> yes thats clear
09:23:17 <basti_> i thought the >>> arrows
09:23:20 <TheHunter> SamB, see, it's confusing people.
09:23:27 <basti_> yes.
09:24:17 <esap> TheHunter: Why do you say it's impossible?
09:24:33 <ski> basti_ : unless i'm missing something that makes >>> arrows unlike CT arrows, the former should also prolly allow e.g using arrows are props, like the latter
09:24:39 <basti_> we dont have much choice in making functors do we?
09:24:54 <basti_> ski: yes i thought so too, kind of on another level.
09:25:04 <basti_> but i dont think this makes much sense.
09:25:07 <esap> TheHunter: Or do you mean "impossible in Haskell"?
09:25:10 <ski> (s/are/as)
09:25:15 <ski> heh
09:25:59 <TheHunter> 'impossible in haskell', of course
09:27:36 <TheHunter> that is, impossible using the Functor type class.
09:28:13 <esap> The Functor type class is pretty limited anyway.
09:28:47 <TheHunter> it's limited to endofunctors, for a start.
09:28:47 <basti_> is it possible to do an effective type system on unrestricted types (types of any order)?
09:28:58 <ski> i guess the reason could be that we can not 'dispatch' on type arguments (which are always types in haskell), but only either not use them (like in K), or use them as types of (or in) arguments (or results) of e.g. constructors of the type defined
09:29:23 <ski> basti_ : 'unrestricted types' ?
09:29:30 <basti_> like coq has
09:29:42 <ski> not sure what you mean ?
09:29:48 <ski> type kind sort ... ?
09:29:56 <basti_> well for example, you cant only reason about objects
09:30:00 <basti_> but also about all objects
09:30:00 <ski> or having types taking values as args, etc ?
09:30:10 <basti_> or alls of all objects (reasioning about functions)
09:30:31 <ski> impredicativity ??
09:30:31 <basti_> actually they kind of go together dont they?
09:30:38 <basti_> sorry i dont know that term
09:32:40 <ski> (and i'm not sure of what you mean :)
09:32:47 <basti_> what is impredicativity?
09:33:25 <TheHunter> allowing types like [forall a. (a -> a) -> (a -> a)]
09:33:45 <bourbaki> hidiho
09:33:47 <basti_> and i mean, coq has a type system that supports basically everything (types of any order). I just don't know if its as sane (and could be similar to) as haskell's or if it gives some problems.
09:34:02 <basti_> hmm.
09:34:06 <basti_> i dont know if coq does that.
09:34:16 <TheHunter> coq has a dependent type system, afaik
09:34:20 <ski> e.g. like in  (forall a. a -> a)  you can substitute a type scheme (with foralls) for a, not just a type  like specialize the a in (forall a. a -> a) to (forall b. [b] -> [b]) yields (forall b. [b] -> [b]) -> (forall b. [b] -> [b])
09:34:53 <basti_> hmm actually what i had in mind is rather about the number of "levels"
09:34:57 <basti_> as in types, kinds...
09:36:00 <basti_> would it be possible to build one that does everything that haskell does on the type level on any level?
09:36:57 <TheHunter> didn't you say coq allows that?
09:37:08 <basti_> well yes but the type system is kinda "witness" based
09:37:28 <basti_> you're always typing types, which is unlike haskell
09:37:38 <basti_> hmm
09:37:59 <basti_> at least i FELT it was very tendious sometimes
09:38:46 <lispy> @vixen hi
09:38:50 <ski> you mean types are not inferred ? or that you have to have explicit type arguments to "polymorphic" functions ?
09:38:50 <lambdabot> hello there
09:39:33 <basti_> hmm
09:39:35 * basti_ wonders a little more
09:39:59 <TheHunter> omega (http://www.cs.pdx.edu/~sheard/Omega/index.html) might do something like this, but i'm not sure what you're getting at.
09:40:21 <basti_> oh im not aiming specifically
09:41:13 <basti_> mmm this guy has a great page ... I'll have a look at that omega
09:43:10 <dcoutts> @seen TFK
09:43:11 <lambdabot> I saw TFK leaving #haskell 18 hours, 56 minutes and 44 seconds ago.
09:44:23 <dcoutts> I've got TFK's irc client working :-). It uncovered 2 seperate bugs in Gtk2Hs.
09:44:59 <dcoutts> but it now seems to work, multi-threading and all :-)
09:46:14 <ski> esap : if you're interested .. hm, yesterday i pondered derivatives of types .. and it seems like (e ^) corresponds to Bag
09:47:00 <basti_> :-i
09:47:08 <basti_> e^?
09:47:11 <basti_> e like 2.71?
09:47:12 <ski> yeah
09:47:17 <ski> yeah :)
09:47:36 <basti_> are you resolving types by generating functions or wtf?
09:47:59 <ski> just taking the derivatives of types :-P
09:48:05 <basti_> but. HOW?
09:48:24 <ski> D (\x. f x + g x) x = D f x + D g x
09:48:25 <ski> etc
09:48:42 <ski> '+'  is named 'Either' in haskell
09:48:43 <basti_> and what is + in types?
09:48:44 <basti_> oh
09:48:46 <basti_> ok
09:48:59 <ski> and '*' is '(,)'
09:49:03 <basti_> of course
09:49:58 * basti_ has to think about it
09:50:04 <ski> conor mcbride has a paper where he discuss some like this, and some tentative applications
09:50:58 <ski> (also there are other persons. .. think i saw some in a CT book)
09:51:15 <ski> basti_ : Zipper seems related to derivatives of types
09:51:46 <ski> maybe i should tell you an intuition for what the derivative of a type (with respect to a tyvar) is ? :)
09:53:33 <ski> or give a simple haskell example ?
09:54:57 <SyntaxNinja> Igloo: alive?
09:55:02 <Igloo> yup
09:55:46 <TheHunter> is there an antiderivative of the identity functor?
09:56:09 <SyntaxNinja> Igloo: so for now we've decided to include libraries with the compilers, and conflict with the virtual packages of those libraries?
09:56:41 <ski> TheHunter : wouldn't every constant functor (iso to 'K c' for some 'c') be a such ?
09:57:05 <TheHunter> wait, are we deriving types or functors?
09:57:29 <ski> not totally sure :)
09:57:35 <TheHunter> i guess my question is what 1/2x^2 corresponds to.
09:57:57 <ski> why that example ?
09:58:34 <TheHunter> just out of curiosity. And to compute the power series 1 + x + ...
09:58:52 <ski> ('1/(1-x)' corresponds to 'List x', in some sense, iirc)
09:59:05 <ski> 1 + x + ? + ...
09:59:07 <ski> ?
09:59:21 <TheHunter> 1 + x + 1/2 x^2 + ...
09:59:29 <ski> ok
09:59:31 <lispy> e?
09:59:33 <TheHunter> yeah, 1 + x + x^2 + ... is a list.
09:59:33 <lisppaste2> metaperl pasted "tracing a function call" at http://paste.lisp.org/display/9610
09:59:52 <lispy> oh wait, not e
10:00:02 * basti_ :-o
10:00:36 <ski> TheHunter : 1 + x + 1/2 * x^2 + 1/6 * x^3 + ..  yes ?
10:00:52 <TheHunter> yes.
10:01:18 <basti_> hmm the "lift" operation is something like an operator on the type level isnt it?
10:01:18 <metaperl> how can I trace the evaluation of a function? My question is posted here:  http://paste.lisp.org/display/9610
10:01:34 <TheHunter> that looks indeed like a bag.
10:01:42 <jyp> metaperl: is 'hat' a viable option for you ?
10:02:10 <basti_> metaperl: quick an dirty? unsafePerformIO
10:02:20 <Igloo> SyntaxNinja: include libraries with the compilers and provide them is what I currently do. I should be conflicting too, but I'm not yet (and it doesn't actually matter as it happens)
10:03:19 <basti_> is this how deforestration works? knowing things about certain combination of funtions and then regrouping them?
10:03:42 <SyntaxNinja> Igloo: have we found a way to remove the packages from compilers so we can install them separately? cabal for instance?
10:03:42 <basti_> [i'm be tempted to think that this would be pretty easy on a symbolic level
10:03:45 <Heffalump> deforestation is eliminating intermediate data structures
10:03:47 <jyp> metaperl: or maybe http://www.haskell.org/ghc/docs/latest/html/libraries/base/Debug.Trace.html
10:03:47 <ski> basti_ : which 'lift' operation ?
10:03:54 <basti_> ski: liftM
10:03:57 <SyntaxNinja> Igloo: for ghc, it's easy, but not sure who should do it.
10:04:07 <metaperl> jyp: I'm looking thru these right now: http://www.haskell.org/libraries/#tracing
10:04:23 <ski> basti_ : liftM = fmap
10:04:23 <TheHunter> could x(x-1)/2 -  be the 'type of two-element sets'?
10:04:36 <basti_> ski: then fmap.
10:04:45 <ski> basti_ : it's the functor map. and a monad is a functor (plus some extra things)
10:04:58 <SyntaxNinja> Igloo: that is, should my separate cabal package do it, or should ghc come without the library out-of-box
10:05:10 <basti_> so is this how deforestration works?
10:05:13 <jyp> metaperl: I recommand hat, but its libraries support is lacking :/
10:05:30 <basti_> as in, finding sets of functions that can be "unlifted"?
10:05:51 <ski> TheHunter : hmm
10:05:52 <dblhelix> ski: iirc, not all monads are functors (most of them are however)
10:05:55 <jyp> so if it's not a viable option for you, using Debug.Trace is a good solution
10:06:10 <metaperl> i need an example of using Debug.Trace
10:06:15 <ski> dblhelix : all monads *ought* to be functors !  how's that ? :)
10:06:18 <metaperl> the docs dont have one
10:06:52 <jyp> metaperl: I'll write something ...
10:06:56 * dblhelix tries to think of a monad that makes sense which is not a functor... ;)
10:06:59 <jyp> gimme a minute
10:07:03 <dcoutts> metaperl, trace ("the value of foo = " ++ show bar) $ theRestOfTheProgram ...
10:07:16 <ski> TheHunter : not totally sure, but i doubt it
10:07:40 <ski> hm
10:07:42 <ski> or maybe
10:07:44 <Igloo> SyntaxNinja: It needs to come without the library or the cunning deps script won't work
10:08:06 <dcoutts> metaperl, specifically, it works a bit like seq in that it'll actually do the debug output at the point that the second argument is demanded
10:08:48 <ski> dblhelix : btw, if a monad satisfies the 3 monad laws, i think one can then derive that it satisfy the 2 functor laws
10:09:22 <TheHunter> ski, well i prolly meant x(x+1)/2
10:09:32 <astrolabe> I think there is an extra law if a monad is a functor
10:09:32 <TheHunter> but this is all pure speculation.
10:09:59 <ski> astrolabe : hm, you could be right about that. lemme think
10:10:01 <SyntaxNinja> ooh, cunning deps script?
10:10:09 <SyntaxNinja> Igloo: so does ghc 6.4 come with cabal now?
10:10:10 <TheHunter> dblhelix, a monad _is_ a functor with additional stuff.
10:10:22 <Igloo> As in a recent mail I sent you
10:10:26 <dblhelix> ski, astrolabe: yes there is
10:10:38 <Igloo> 6.4 comes with cabal now
10:10:40 <metaperl> dcoutts: I see. Thanks. It looks like hat is worth the time to learn
10:10:40 <SyntaxNinja> Igloo: in the haxml thread?
10:10:48 <Igloo> yup
10:10:51 <SyntaxNinja> Igloo: can it be removed? :)
10:11:01 <dblhelix> ski, astrolabe: fmap f xs  ==  xs >>= return . f
10:11:19 <Igloo> OK, but it'll probably wait until the gcc-4 transition happens
10:11:22 <lisppaste2> jyp annotated #9610 with "possibility" at http://paste.lisp.org/display/9610#1
10:11:31 <ski> dblhelix : ma >>= return = ma   return a >>= amb = amb a   (ma >>= amb) >>= bmc = ma >>= (\a -> amb a >>= bmc)
10:11:42 <ski> dblhelix : ya, i know
10:11:43 <Igloo> compilers never need the cabal package to just register a library, right?
10:11:49 <astrolabe> so why isn't monad a subclass of functor?
10:12:00 <ski> dblhelix : or rather, that's the def of liftM for monads
10:12:12 <SyntaxNinja> Igloo: right, there's still ghc-pkg.
10:12:13 <ski> astrolabe : who knows ?
10:12:27 <Igloo> And hugs and nhc98 too?
10:12:31 * basti_ installs axiom
10:12:37 <Igloo> (your cabal package will be making binary packages for all 3, right?)
10:12:51 <SyntaxNinja> Igloo: so what do you want me to do in the meantime? I don't want to remove the external cabal package if I'm going to re-add it really soon
10:13:29 <SyntaxNinja> compilers only need cabal ot install cabal packages.
10:13:29 <Igloo> Nothing, I guess  :-)
10:13:47 <Igloo> DYM "to build cabal packages"?
10:14:05 <ski> dblhelix : functor laws   fmap id = id   fmap (g . f) = fmap g . fmap f
10:14:12 <SyntaxNinja> Igloo: in any case, I disagree with the 'grave' status of this bug, because fixing it won't fix those packages, their build-depends need to get fixed.
10:14:25 <Igloo> Why?
10:14:26 <SyntaxNinja> you asked about registration, not building
10:14:29 <ski> dblhelix : so, if fmap = liftM, you should check those def for s/fmap/liftM/
10:14:30 <dblhelix> ski: I think I do know the laws ;)
10:14:49 <Igloo> What do you mean by "compilers only need cabal ot install cabal packages"?
10:14:50 <TheHunter> it follows easily from the monad laws.
10:14:59 <SyntaxNinja> Igloo: because they depend on cabal, if I remove it they will break anyway
10:15:12 <dcoutts> SyntaxNinja, Igloo btw, did you ever decide what the file extension of the files that you feed to ghc-pkg ought to be? they're not .cabal files.
10:15:24 <Igloo> No, ghc6 Provides: libghc6-cabal-dev
10:15:30 <SyntaxNinja> Igloo: the compilers can still install packages just the way they used to, but they won't be able to install using cabal if cabal is not instaled.
10:15:36 <dblhelix> ski: well, indeed, by just taking fmap = liftM all follows trivially---question remains: why isn't Monad a subclass of Functor
10:15:43 <ski> hm
10:15:54 <ski> maybe they somehow missed it ?
10:15:58 <Igloo> dcoutts: All I decided was they shouldn't be .cabal and I want something that is a .cabal in there too  :-)
10:15:59 <ski> or
10:16:01 <TheHunter> that was a mistake the haskell 98 committee made.
10:16:22 <SyntaxNinja> dcoutts: that's sorta up to ghc. they're usually pkg.conf, but it doesn't matter.
10:16:27 <Igloo> What does "install using cabal" mean? Is that what our packages do?
10:16:33 <TheHunter> earlier versions of haskell had the same superclass relationship.
10:16:39 <dblhelix> ski: well, demanding the extra law for instances of both classes gives away that they thought about it
10:16:48 <ski> thought it would maybe be confusing to define the functor instance as fmap = liftM (which depends on Monad), and then define the Monad instance, .. sortof mutually recursive instance defs .. almost
10:17:18 <SyntaxNinja> Igloo: maybe if you explain your question, "compilers never need the cabal package to just register a library, right?" the answer is that if you want to build / install / register a cabal package, then yes, you need cabal.
10:17:20 <ski> dblhelix : what would this extra law be ?  (can't remember)
10:17:25 <dblhelix> ski: of course, because, for sure, not all functors are monads
10:17:36 <dblhelix> ski: I just told you :) fmap f xs  ==  xs >>= return . f
10:18:06 <ski> dblhelix : what problem should that make ? (re not all functors are monads)
10:18:10 <Igloo> What I mean is, if a cabal package is Debianised for Debian, does it need to depend on libghc6-cabal-dev?
10:18:12 <SyntaxNinja> dcoutts: are you writing the package.conf file by hand?
10:18:26 <Igloo> (or lib{nhc98,hugs}-cabal-dev)
10:18:38 <ski> dblhelix : but that just says that fmap = liftM, given liftM
10:18:46 <dblhelix> ski: that's not a problem, but just a reason for a mutually recursive definition to make no sense
10:18:48 <TheHunter> ski, the prelude documentation demands that all Functors which are also Monads should satisfy fmap = liftM
10:18:56 <TheHunter> s/are/be/
10:18:59 <SyntaxNinja> Igloo: depend? or build-depend?
10:19:04 <Igloo> depend
10:19:23 <SyntaxNinja> oh yeah, technically, they should
10:19:27 <ski> dblhelix : i guess what would maybe be nice would be to have a sort of default declaration in Monad of the fmap member of Functor (which would then be a superclass of Monad)
10:19:30 <dblhelix> ski: indeed, the law just demand that; no one said it would be rocket science
10:19:32 <SyntaxNinja> because post-inst should run ./setup register, not ghc-pkg register
10:19:43 <ski> TheHunter : ok (wasn't sure if that was demanded or not)
10:20:12 <SyntaxNinja> since the package might do funny stuff during register
10:20:25 <Igloo> OK. But your cabal package doesn't rely on cabal either for building or installing?
10:20:26 <ski> dblhelix : i have occationally wanted something like that, in other circumstances, i think
10:21:00 <Igloo> And you will be building all 3 of lib{ghc6,nhc98,hugs}-cabal-dev?
10:21:46 <dcoutts> SyntaxNinja, yes we generate the package description files during the build, by substituting using autoconf
10:22:16 <TheHunter> ski, there's a proposal: http://repetae.net/john/recent/out/supertyping.html
10:22:33 <lisppaste2> metaperl pasted "creating a compile-able main (help needed)" at http://paste.lisp.org/display/9613
10:22:41 <ski> TheHunter : ty
10:22:50 <TheHunter> and i remember ross paterson supporting something like this.
10:23:58 <dblhelix> TheHunter, ski: could it be that The Hunter is referring to this? http://www.haskell.org/pipermail/libraries/2005-March/003453.html
10:24:42 <TheHunter> yeah, that's the thread where I messed everything up by mixing up sub- and superclass.
10:25:22 <TheHunter> however, i never actually heard an argument why the dropped the superclass relationship in haskell98
10:25:39 <ski> TheHunter : interesting  (making a supertype of the record of methods, by restriction, 'tseems)
10:26:02 <ski> TheHunter : what relationship ?
10:26:17 <TheHunter> Functor => Monad.
10:26:23 <ski> k
10:26:24 <lispy> TheHunter: ah, superclassing looks cool
10:26:27 * ski reads the thread
10:27:10 * ski briefly wonders if it would be possible to have more restricted types of the methods in the superclass, added like that
10:27:49 <metaperl> {- haha! solved it: -} main = putStrLn $ show (newHeight imgA imgB)
10:28:02 <metaperl> I need to change this so that it is an acceptable mashow is what I was needing
10:28:21 <SyntaxNinja> Igloo: my cabal package doesn't reply on the installed cabal package, no.
10:28:29 <jyp> metaperl: you can also use 'print" instead of "putStrLn . show"
10:28:40 <SyntaxNinja> Igloo: right, all 3
10:28:49 * dblhelix goes for a walk and thinks about superclasses
10:28:51 <SyntaxNinja> dcoutts: so you're not using cabal?
10:28:59 <dblhelix> cu
10:29:22 <lispy> jyp: main = print $ newHeight imgA imgB ?
10:29:41 <ski> m
10:29:50 <SyntaxNinja> Igloo: cabal doesn't do anything for nhc yet, so those packages have to be done by hand.
10:30:20 <SyntaxNinja> Igloo: so any timeframe for removing cabal from ghc6.4?
10:30:22 <lispy> hmm..nick completion in x-chat is not very intelligent...
10:30:23 <jyp> lispy: yup
10:30:34 * TheHunter 's gotta go
10:31:08 <Igloo> SyntaxNinja: I'm confused; what has to be done by hand?
10:32:02 <SyntaxNinja> Igloo: you can't build a cabal package for nhc yet
10:32:39 <SyntaxNinja> Igloo: so if I need to build a libnhc98-cabal-dev, then I need to do it in the makefile or smething
10:33:42 <Igloo> I'd rather not remove cabal if the replacement isn't ready yet, that's all...
10:34:13 <Igloo> gcc is nearly v4 now according to d-d
10:34:25 <Igloo> A few days away I think
10:34:27 <Heffalump> so the world is going to end for a few months?
10:34:36 <Heffalump> or can nhc keep building with an old gcc?
10:36:09 <SyntaxNinja> Igloo: cabal can be ready whenever.
10:36:13 <Igloo> I don't think I'll bother, partly because it's not trivial
10:36:29 <tessier_> There Is No Cabal
10:36:48 <Igloo> I suspect that if it doesn't work and Malcolm doesn't think it will imminently I'll recommend we drop nhc98 versions of libraries for now
10:38:57 <SyntaxNinja> Igloo: if what doesn't work?
10:39:04 <Igloo> nhc98+gcc4
10:39:37 <SyntaxNinja> Igloo: so in the mean time, those packages will remain broken?
10:39:53 <Igloo> which packages?
10:40:03 <SyntaxNinja> the ones that depend on cabal
10:40:26 <SyntaxNinja> Igloo: I could upload a new cabal that depends on 6.4, but that would also be broken
10:40:36 <Igloo> yes. But it's possible they'd need to be recompiled once ghc is built with gcc 4 anyway
10:40:37 <SyntaxNinja> so I need to wait for the new 6.4
10:40:58 <SyntaxNinja> OK I'll file a new bug about removing cabal from 6.4 and make my 'grave' bug depend on that one
10:41:21 <Igloo> Can bugs depend on each other now?
10:41:41 <Igloo> If you're going to make a bug about removing cabal, please file it against all 3 impls
10:42:36 <SyntaxNinja> ok
10:45:12 <SyntaxNinja> Igloo: should they be 'grave'?
10:46:24 <Igloo> I don't think I'd make them grave. It doesn't matter much anyway, because the severity's not going to affect when I fix them  :-)
10:49:47 <SyntaxNinja> you made this libghc6-cabal-dev bug grave since it causes packages to be uninstallable, so likewise it seems like this bug should be grave
10:52:16 <Igloo> Everything would be fine if libghc6-cabal-dev didn't exist, so I don't see why
10:52:27 <lisppaste2> metaperl pasted "creating a hat object module for imported code" at http://paste.lisp.org/display/9615
10:53:02 <Igloo> Oh, I suppose libghc6-cabal-dev is uninstallable. Well, like I say, it doesn't really matter as far as I'm concerned  :-)
10:54:26 <SyntaxNinja> Igloo: did you mean for there to be two bugs, btw, sinced someone had alreayd filed bug: 311835
10:55:41 <SyntaxNinja> you think I should remove libghc6-cabal-dev in the meantime?
10:55:49 <Igloo> I suspect I didn't see that as it's against the source package, but I'm not sure
10:56:05 <SyntaxNinja> you were included in the discussion ;)
10:56:14 <SyntaxNinja> so do you mind if I close yours as a dup?
10:56:32 <Igloo> Sure, but I'd probably forgotten it existed by then  :-)
10:56:34 <jyp> metaperl: obviously hmake doesn't behave correctly :/
10:57:44 <Igloo> I don't think removing it is worthwhile, as it'll hopefully only be for a few days
10:58:25 <Igloo> They're slightly different things, actually. His says h-c fails to build, mine says the binaries are uninstallable. Probably better to merge them if anything.
10:58:27 <SyntaxNinja> oi
10:58:29 <SyntaxNinja> er ok
11:15:26 <metaperl> jyp: I agree
11:16:06 <metaperl> jyp: maybe I should've built from above both files instead of in one directory. i'll try it
11:21:48 <metaperl> no, that failed as well. here's the message i'm posting to HAT on GMANE: http://www.hcoop.net/~terry/haskell/craft-of-fp/q/hat1.txt
11:26:46 <basti_> @pl \x -> case x of A -> 1 ; B -> 2
11:26:47 <lambdabot> (line 1, column 19):
11:26:47 <lambdabot> unexpected ">" or "-"
11:26:47 <lambdabot> expecting variable, "(", operator or end of input
11:26:54 <basti_> @pl \x->case x of A -> 1 ; B -> 2
11:26:56 <lambdabot> (line 1, column 17):
11:26:56 <lambdabot> unexpected ">" or "-"
11:26:56 <lambdabot> expecting variable, "(", operator or end of input
11:27:02 <basti_> @pl \x->case x of {A -> 1 ; B -> 2}
11:27:03 <lambdabot> (line 1, column 15):
11:27:03 <lambdabot> unexpected "{"
11:27:03 <lambdabot> expecting variable, "(", operator or end of input
11:27:08 <basti_> @pl \x->case x of {A => 1 ; B => 2}
11:27:09 <lambdabot> (line 1, column 15):
11:27:09 <lambdabot> unexpected "{"
11:27:09 <lambdabot> expecting variable, "(", operator or end of input
11:27:10 <basti_> gnnna
11:27:13 * basti_ shrugs
11:32:44 <ski> bast_ : what's A and B ?
11:33:30 <basti_> arbitary constructors
11:33:42 <basti_> just wanted to see what happens
11:33:44 <basti_> :)
12:54:17 * SamB thinks TheHunter has a VERY long attention span
13:14:30 <poetix> Anyone build a web server in Haskell lately?
13:15:14 <Speck> I know of at least one web server written in Haskell, but I've never used it.
13:15:39 <Speck> The concurrent haskell paper was built around a web server, iirc.
13:15:45 <poetix> I've been looking at the paper
13:16:01 <poetix> There's one approach they didn't try, which might be worth investigating
13:16:24 <Speck> ?
13:16:41 <poetix> That is to handle incoming connections and parse HTTP messages on a single thread, then spawn new threads after the parsing has been done
13:17:36 <poetix> A bit like using Twisted and using threads for the parts of the request handling that block
13:18:17 <poetix> They say that a monolithic process with I/O multiplexing is fast but awkward to program
13:19:03 <poetix> But don't consider having a multiplexing point of entry, then using threads at the point where the response is being constructed
13:20:09 <Speck> seems like a good approach
13:20:35 <poetix> (I guess with lightweight user-mode threads there's no particular advantage to having a thread pool - they don't discuss that either)
13:22:39 <poetix> I was wondering if anyone had done any work in that area since the paper was written.
13:24:34 <Speck> I'm not sure, but I'm sure someone around here has a clue :-)
13:26:14 <poetix> shapr will know why I'm asking...
13:27:34 <poetix> Have to come back at a busier time, and bug people about it then!
14:19:06 <det> @yow
14:19:07 <lambdabot> CONGRATULATIONS!  Now should I make thinly veiled comments about
14:19:07 <lambdabot> DIGNITY, self-esteem and finding TRUE FUN in your RIGHT VENTRICLE??
14:20:00 <TheHunter> @listcommands topic
14:20:02 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-
14:20:02 <lambdabot> init topic-null
14:23:48 <TheHunter> hmm, topic should be a zipper.
15:19:53 <cm> hello, functional lovers
15:20:11 <ski> good night cm
15:20:29 <cm> hello ski-san
15:20:45 <ski> heh
15:24:39 <ski> hiya Raziel
15:25:21 <Raziel> hi
15:25:53 <ski> learning haskell ?
15:26:21 <Raziel> discovering it :)
15:26:35 <ski> oki
15:26:38 <Raziel> i'm reading a short introduction, and it seems to be interesting
15:26:55 <ski> (hm, which one ?)
15:27:08 <Raziel> the official one ---> http://www.haskell.org/aboutHaskell.html
15:27:13 <ski> aha
15:28:41 <ski> you'll prolly then want to look at some tutorials (or maybe even borrow/buy books)
15:28:45 <ski> hi lstna_
15:29:25 <lstna_> Evening ski
15:30:22 <Raziel> maybe
15:30:35 * TheHunter swears at System.Time
15:30:42 <ski> Raziel : http://www.haskell.org/learning.html has info on that (btw, many ppl think e.g. "Yet another haskel tutoriall" is gentler than "A Gentle Introduction to Haskell" :)  (also this http://www.haskell.org/~pairwise/intro/intro.html can possibly be interesting, too)
15:30:44 <Raziel> I'll read some tutorials
15:30:57 <Raziel> hum, thanks :D
15:31:01 <ski> Raziel : and of course you can ask questions here and on the other forums :)
15:31:40 <ski> (other being mailing lists, and comp.lang.functional at usenet)
15:33:08 <TheHunter> i guess that's one of the libraries noone has ever used before.
15:35:13 <cm> hey dons, are you there?
15:35:50 <cm> lambdabot
15:35:54 <cm> lambdabot, help :)
15:36:16 <TheHunter> @botsnack you there?
15:36:17 <lambdabot> :)
15:36:30 <TheHunter> cm, what's your problem?
15:36:36 <lstna_> ski: I read the backtrace of the stuff about Functor and Monads  and suparclasses earlier. Very intriguing. (Not that I can add anything sensible to the conversation, but untriguing none the less.
15:36:57 <cm> TheHunter: i want lambdabot to tell shapr a message when he comes back on
15:37:33 <TheHunter> i'm afraid we don't have a module that's capable of doing that right now.
15:38:48 <cm> mhm
15:38:55 <SamB> that would be a great module! you should write one!
15:39:29 <cm> lemme try
15:39:31 <SamB> then, later, you could generalize it to support people other than shapr ;-)
15:39:35 <cm> in the meanwhile:
15:39:37 <cm> @todo-add tell shapr to visit http://www.cs.umd.edu/hcil/treemap-history/
15:39:38 <lambdabot> Entry added to the todo list
15:39:50 <cm> SamB :-)
15:39:55 <cm> shapr is the nexus of our information flow
15:40:23 <cm> i'll try to write such a plugin :)
15:40:40 <SamB> it should be much easier than a plugin to summon shapr ;-)
15:41:02 <cm> :)
15:41:45 <TheHunter> cm, Seen.hs is the place where to draw inspirations from.
15:42:13 <cm> I need to get darcs & lambdabot first, but thanks :-)
15:42:41 <TheHunter> oh, that may take a while
15:42:49 <TheHunter> @wiki Lambdabot/Installation
15:42:50 <lambdabot> http://www.haskell.org/hawiki/Lambdabot/Installation
15:43:12 <TheHunter> @todo-add TheHunter incorporate @wiki Lambdabot/Installation into lambdabot's documentation
15:43:13 <lambdabot> Entry added to the todo list
15:43:55 <TheHunter> goddamWikiNames!
15:44:20 <SamB> if lambdabot still has that config file written in Haskell, you might want to change it before compiling rather than after...
15:44:48 <ski> lstna_ : ok. (yes it is)
15:46:41 <TheHunter> slight update: http://www.haskell.org/hawiki/LambdaBot_2fInstallation
15:53:12 <TheHunter> @wn picosecond
15:53:14 <lambdabot> *** "picosecond" wn "WordNet (r) 2.0"
15:53:14 <lambdabot> picosecond
15:53:14 <lambdabot>   n : one trillionth of a second; one thousandth of a nanosecond
15:53:44 <TheHunter> 10^{-12} ?
15:54:26 <cm> @wn nanosecond
15:54:28 <lambdabot> *** "nanosecond" wn "WordNet (r) 2.0"
15:54:28 <lambdabot> nanosecond
15:54:28 <lambdabot>   n : one billionth of a second; one thousandth of a microsecond
15:54:29 <cm> think recursive :p
15:54:50 <cm> but yeah
15:55:50 <TheHunter> wtf? data TimeDiff = TimeDiff {tdYear :: Int, tdMonth :: Int, tdDay :: Int ...
15:56:12 <TheHunter> how long is a month supposed to be?
15:56:15 * cm waits for gmp
16:01:19 <TheHunter> @index threadDelay
16:01:21 <lambdabot> GHC.Conc, Control.Concurrent
16:01:25 <cm> @index shapr
16:01:26 <lambdabot> bzzt
16:01:29 <TheHunter> @type GHC.Conc threadDelay
16:01:30 <cm> :(
16:01:35 <lambdabot> bzzt
16:01:37 <TheHunter> @type GHC.Conc.threadDelay
16:01:38 <lambdabot> GHC.Conc.threadDelay :: Int -> IO ()
16:03:26 <TheHunter> @foldoc foo
16:03:26 <TheHunter> @foldoc foo
16:03:26 <TheHunter> @foldoc foo
16:03:27 <TheHunter> @foldoc foo
16:03:27 <TheHunter> @foldoc foo
16:03:28 <thbot> *** "foo" foldoc "The Free On-line Dictionary of Computing (27 SEP
16:03:28 <thbot> 03)"
16:03:28 <thbot> foo
16:03:28 <thbot>  
16:03:28 <thbot>    <jargon> /foo/ A sample name for absolutely anything,
16:03:28 <lambdabot> *** "foo" foldoc "The Free On-line Dictionary of Computing (27 SEP
16:03:28 <lambdabot> 03)"
16:03:28 <lambdabot> foo
16:03:28 <lambdabot>  
16:03:28 <lambdabot>    <jargon> /foo/ A sample name for absolutely anything,
16:03:28 <thbot>    especially programs and files (especially {scratch files}).
16:03:28 <lambdabot>    especially programs and files (especially {scratch files}).
16:03:31 <thbot>    First on the standard list of {metasyntactic variables} used
16:03:31 <lambdabot>    First on the standard list of {metasyntactic variables} used
16:04:00 <TheHunter> ah, crap.
16:04:11 <cm> :-)
16:09:03 <TheHunter> ok, flood protection seems to work.
16:10:00 <TheHunter> though the code contains variables named 'foo', 'bar' and 'baz'.
16:13:01 * cm gets haskell-src-ext
16:17:19 <cm> TheHunter: there's a cd hs-plugins missing ;)
16:18:18 <TheHunter> oki, fixed.
16:19:10 <cm> are you german?
16:19:51 <TheHunter> yes.
16:19:56 <cm> moin :)
16:20:26 <TheHunter> moin.
16:21:00 <TheHunter> you're studying in canada?
16:21:30 <cm> working here until september
16:21:41 <cm> then going back to study in .de :)
16:21:50 <cm> how's wuerzburg? ;-)
16:22:30 <TheHunter> fine, though i'll leave it behind real soon.
16:24:08 <cm> what you gonna do?
16:25:04 <TheHunter> resume my studying in the us.
16:25:35 <cm> which semester are you in atm?
16:26:16 <TheHunter> in the 6th.
16:26:44 <cm> aight
16:27:01 <TheHunter> how bout you?
16:27:16 <cm> will start uni this fall
16:27:22 <cm> 0th :-)
16:27:27 <TheHunter> but i'm studying math, no cs.
16:27:33 <TheHunter> *not
16:28:09 <TheHunter> which uni?
16:28:13 <cm> i'm kinda undecided between both, i'll try to take courses as if i was studying both for now (i think in the 1st semester there's 100% overlap anyway)
16:28:30 <Spark> does anyone know any papers on the comparative expressive power of synchronisation constructs
16:28:32 <cm> maybe karlsruhe, maybe munich/saarbruecken/aachen
16:28:42 <cm> got any recommendations? :-)
16:30:11 <TheHunter> i'd say munich
16:30:45 <TheHunter> that's what i think i shoulda done.
16:30:47 <astrolabe> for the beer?
16:31:00 <cm> why do you think so?
16:32:33 <TheHunter> it's considered to be a very good uni (lmu), and i've heard good things from people studying there.
16:33:07 <TheHunter> being at a small uni (such as me) has some disadvantages.
16:33:30 <TheHunter> well the other names you've mentioned aren't small either.
16:37:39 <TheHunter> btw, what are you working as?
16:37:46 <cm> graphics programmer
16:38:39 <TheHunter> interesting. i've never actually programmed anything besides toy programs.
16:39:28 <TheHunter> sounds like c++?
16:39:36 <cm> it's a lot of fun, but i feel more formal/theoretical education will be a good thing to have, and university life a thing you shouldn't miss
16:39:55 <cm> yeah, c++ and some shader languages
16:39:56 <TheHunter> yeah, definetely.
16:43:21 <cm> i'm kinda fond of C++, so that's not too bad ;)
16:43:43 <Pseudonym> If you're fond of C++ _and_ Haskell, that clearly means you know how to use C++ properly.
16:43:53 <cm> hello Pseudonym
16:43:59 <Pseudonym> G'day.
16:44:43 <Pseudonym> cm: Where are you working?
16:44:54 <cm> Ubisoft
16:45:02 <cm> (Montreal)
16:45:20 <Pseudonym> Oh, GAMES.
16:45:23 * Pseudonym hacks and spits
16:45:30 <Pseudonym> The black sheep of the graphics industry.
16:45:34 <cm> :)
16:45:38 <Pseudonym> Unfortunately, also the biggest sheep.
16:45:51 <cm> do you have moral problems with game industry?
16:46:07 <Pseudonym> I have moral problems with the way that the game industry treats its employees.
16:46:23 <Pseudonym> Things might be different in Canada from what I've heard about the US.
16:47:25 <Pseudonym> But certainly, games have a reputation for not taking engineering seriously.
16:47:35 <Pseudonym> Because of the tight margins and deadlines.
16:47:55 <Philippa> let's just say that on PS2 you take it seriously or you don't get to publish...
16:48:18 <Pseudonym> Not necessarily.
16:48:25 <cm> that easpouse thing was quite a bad read, i agree.
16:48:26 <Pseudonym> You're not encouraged to write reusable code, for example.
16:48:50 <Philippa> perhaps, but if there's no call for it that's not an issue
16:48:54 <cm> on the other hand, there are quitea few people actually "loving" their job, who are glad to work long hours (such as me ;)
16:48:59 <Philippa> reusability is only good if you're going to reuse it
16:49:13 <Pseudonym> You'd think there would be a lot of scope for reuse between games.
16:49:17 <Philippa> and often instead an excuse for code that's largely crap
16:49:28 <Pseudonym> Well, true.
16:49:30 <Philippa> Yeah. And most of /that/ does get resused
16:49:32 <Philippa> *reused
16:49:37 <Philippa> "here's how to push a crapload of polys"
16:49:57 <Pseudonym> Admittedly I'm talking a lot about things of which I have no first-hand experience.
16:50:00 <Philippa> but a lot of the rest is more specific than you might think
16:50:04 <cm> I believe many people don't throw away their engine after the game has shipped; they'd rather replace subsystems/evolve it.
16:50:07 <cm> Epic might be a prominent example.
16:50:11 <Pseudonym> And visual effects code isn't necessarily any prettier.
16:50:25 <Pseudonym> There's one shader I saw from The Matrix... you don't wanna see it.
16:50:28 <tmccort> Why do Haskell programs use so much memory?
16:50:31 <Philippa> cm: yeah, this is much what I'm hearing from other folks too
16:50:37 <Philippa> Pseudonym: that's a shader. It's /asm/, FFS
16:50:37 <cm> But graphics code for instance is hard to reuse if you want to stay cutting edge.
16:50:45 <Philippa> definitely
16:50:46 <cm> hey Philippa :)
16:50:50 <Philippa> one reason I don't do graphics :-)
16:50:51 <Philippa> 'lo
16:50:53 <cm> :)
16:51:11 <Philippa> 'mafraid I'm going to bed soon, spent all weekend in london, am shattered and have to travel again tomorrow...
16:51:19 <Pseudonym> Where you going?
16:51:24 <cm> what did you do at london?
16:51:25 <tmccort> shaders aren't really in asm anymore
16:51:33 <tmccort> there are high level shaders languages.
16:51:38 <cm> they are, if you want real performance :P
16:51:50 <Philippa> yeah, now it's portable asm with some slight expression syntax. woo.
16:51:50 <tmccort> The compilers do a fine gob.
16:51:52 <tmccort> job
16:51:59 <cm> i don't think so
16:52:05 <tmccort> Unreal 2007 shaders are high level.
16:52:09 <Philippa> mostly met up with friends and hung around soho. Oh, and London Pride was on, but by the time I'd got there it wasn't much special
16:52:27 <cm> Epic made a concious choice to not care about those cycles they miss.
16:52:31 <Pseudonym> No, high-level shading languages are pretty high-level.
16:52:35 <Philippa> and you've gotta love it when there's loads of "yay gays! go lesbians!" and no mention of bisexuality
16:52:36 <Pseudonym> THey're not just portable asm.
16:53:03 <Pseudonym> Though I disagree that the compilers do a fine job. :-)
16:53:04 <Philippa> Pseudonym: the ones for current hardware shaders're getting on for it though
16:53:13 <Philippa> (portable asm in the same way C is, sure)
16:53:19 <tmccort> HLSL is the DirectX one and Cg is the OpenGL one.
16:53:40 <cm> And the HLSL compiler still has a long way to go to compete with hand-optimized code ;)
16:53:47 <Pseudonym> Right.
16:53:59 <Philippa> cm: yeah, Epic've pretty much made themselves out of knowing when to just eat more cycles
16:54:17 <Philippa> one of the main reasons their engine's increasingly more popular than the latest from Id
16:54:17 <Pseudonym> There are several reasons why they don't.  Mostly because graphics vendors like nVIDIA tend to hire graphics people, not compiler people.
16:54:42 <cm> I don't agree with what I can read online about their graphics/shader architecture.
16:54:45 <tmccort> The Unreal 2007 engine is just amazing.
16:55:00 <cm> tmccort: it won't be cutting edge by 2007 ;)
16:55:11 <cm> but that's okay, being cutting edge is surely not their primary goal.
16:55:21 <tmccort> Well what else compares with it now?
16:55:22 <cm> (and it makes total sense)
16:55:25 <Pseudonym> I haven't looked closely at Cg, but I know that RenderMan SL's type system is very, very difficult to understand.
16:55:36 <tmccort> A hell of alot of games announced at E3 use the Unreal engine.
16:55:39 <Pseudonym> And the Pixar compiler contains at least two clear mistakes that I'm aware of.
16:55:42 <Pseudonym> Type-related.
16:55:45 <cm> tmccort: exactly.
16:56:10 <cm> tmccort: also, consider that it's 2005, and people are carefully hiding what they will release. not many people have to market their engine.
16:56:15 <cm> *in 2007
16:57:48 <cm> Epic stands out by a well-developed (and -inspired ;) tool suite, IMO.
16:57:57 <tmccort> Yeah... graphics cards will probably be pretty insane by 2007 as well.
16:58:28 <cm> :-)
16:59:01 <tmccort> I hear Epic will be supporting that AGEIA dedicated physics card as well.
16:59:31 <Philippa> cm: heard any more about the next unrealscript yet? Both Tim and psyk've been dropping fun hints about it
17:00:36 <cm> Philippa: no, but I personally believe it's more of a next-next-gen thing ;)
17:01:13 <tmccort> Learning haskell is hell :(
17:01:36 <cm> probably won't be in use until UE4/5, /me thinks
17:02:09 <cm> but it's very exciting to have someone like Tim Sweeney working on it, with the "power" of basically being able to "force" many people into using it
17:02:30 * cm winks and goes off to hack some shaders ;)
17:02:38 <astrolabe> tmccort: It is difficult!
17:02:53 <jlouis> tmccort: If hell is twisting your brain, yes ;)
17:02:56 * lstna_ agrees
17:03:29 <tmccort> I'm looking at the lambdabot code and I don't get anything... besides Main.hs :P
17:03:49 <jlouis> tmccort: Start by reading Util.hs
17:03:50 <cm> TheHunter: does lambdabot compile on win32?
17:04:05 <tmccort> I asked that a few days ago :)
17:04:22 <tmccort> It uses Posix so no... n ot without modification.
17:04:28 <TheHunter> what was that?
17:04:37 <cm> whether lambdabot compiled on win32?
17:04:39 <cm> -?
17:05:00 <TheHunter> well it can't be very compliated to get it working.
17:05:05 <cm> so if i strip out the POSIX stuff I might be able to compile it? just want to type-check stuff, will probably be enough
17:05:13 <TheHunter> you probably have to add some ifdefs.
17:06:21 <TheHunter> most of the stuff is already conditionally excluded, but since i couldn't test it, I probably broke it.
17:06:28 <jlouis> tmccort: then go on with IRC.hs. It is actually that which runs lambdabot. The rest is modules hooked onto IRC.hs
17:06:57 <TheHunter> s/IRC.hs/Lambdabot.hs/
17:07:08 <tmccort> jlouis, I am reading IRC.hs :P
17:07:23 <jlouis> haha
17:07:40 <jlouis> I have no working darcs here at the moment. I am a long way back in hacking lambdabot
17:07:53 <tmccort> What does $ mean?
17:08:10 <ski> application
17:08:15 <ski> f $ x = f x
17:08:18 <jlouis> f $ x = f x
17:08:19 <jlouis> bleh
17:08:45 <ski> foo $ bar x $ baz y   is the same as   foo (bar x (baz y))
17:08:55 <jlouis> instead of writing a set of parentheses, you break it up with $ as ski showed
17:09:06 <tmccort> That's horrible :|
17:09:14 <Speck> it works due to its extremely low precedence
17:09:20 <ski> $ is just a righ-associative operator
17:09:22 <Cale> infixr 0  $
17:09:42 <Cale> tmccort: horrible?
17:10:00 <tmccort> I prefer parens.
17:10:01 <ski> can be handy if it's many nested calls
17:10:10 <tmccort> I'm a C/C++ programmer.
17:10:19 <Speck> it's used sparingly
17:10:30 <astrolabe> It is just an option for writing things, sometimes parens will be better
17:10:35 <tmccort> I would perfer them even more if I was a scheme programmer :)
17:10:41 <Cale> I tend to use some mixture of $ and parens depending on how I'm actually thinking about the computation.
17:10:47 <ski> also, can be handy if some subexpr continue for many lines (e.g. lambda and/or do-expr and/or let-expr)
17:10:54 <tmccort> Maybe I just have to get used to them
17:11:16 <jlouis> tmccort: at least you need to be comfortable with others using them
17:11:32 <ski> (or understand what it means)
17:11:50 <TheHunter> it makes some changes local changes that otherwise would involve adding a closing paren at the end.
17:12:31 <jlouis> I did not like $ at the beginning
17:12:37 <tmccort> How do you know when it ends? I'm looking at runIrc and don't get it.
17:12:46 <Speck> end of the expression
17:13:00 <TheHunter> and using parens makes it often easier for humans to parse.
17:13:25 <TheHunter> *using few parens
17:13:29 <Speck> my biggest haskell pet peeve is single-char variable names (though sometimes and perhaps often they _are_ the best choice)
17:13:43 <astrolabe> Are the rules of precidence for haskell explained somewhere?
17:14:20 <Cale> astrolabe: in the Report
17:14:36 <astrolabe> doh.  silly me
17:15:09 <tmccort> I'm not sure how I feel about the lazy aspect of the language though
17:15:13 <Cale> tmccort: runIrc in lambdabot? The usage with try?
17:15:14 <ski> Speck : yes, often in polymorphic code (especially with many different type vars in the type), it's more or less futile to come up with something more specific than 'object' or 'value' anyway
17:15:40 <ski> good night shapr
17:15:44 <TheHunter> Speck, that's because much of the information that is encoded in variable  names in other languages is already present in the type of that thing.
17:15:53 <tmccort> Cale the usage with withSocketsDo in runIrc
17:15:58 <Cale> ah
17:16:11 <TheHunter> stupid withSocketsDo
17:16:15 <shapr> g'night ski
17:16:53 <Cale> well, it parses as withSocketsDo (do ...rest of do block...)
17:17:23 <ski> you can think of it a bit like a for-block or something
17:18:17 <Cale> withSocketsDo just wraps an IO computation with network system init/shutdown stuff, whenever that's needed.
17:18:46 <tmccort> Do I want to know what Concurrency is? :P
17:18:46 <Cale> (apparently only needed on Windows, but harmless on other platforms)
17:19:00 <TheHunter> and it breaks code that perfectly works under unix on windows.
17:19:13 <Cale> TheHunter: hm?
17:19:47 <TheHunter> if you didn't use withSocketsDo, that is.
17:19:57 <Cale> ah
17:20:21 * ski grins at small comp. game article in newspaper
17:20:41 <TheHunter> that's just not something the user should do. And if you decide to put something like that anyway, it should behave identically on all platforms.
17:21:09 <Cale> tmccort: Concurrency is just the ability to have multiple threads in a program running at the same time.
17:21:43 <tmccort> I see.
17:22:22 <tmccort> Is Haskell GHC faster then Java and use less memory? Or is it the other way around.
17:22:49 <astrolabe> probably the other way round
17:23:23 <Cale> I'd suspect that GHC produces faster code than Java, but then again I've heard that Java's been getting faster in its recent iterations.
17:23:36 <Speck> then again, so is GHC
17:23:41 <Cale> yeah
17:24:01 <tmccort> Doesn't the laziness cause problems?
17:24:05 <Cale> Also, it's hard to compare with such different languages.
17:24:13 <Cale> Laziness can also make things faster :)
17:25:01 <astrolabe> for what it's worth http://shootout.alioth.debian.org/
17:25:13 <tmccort> Yeah, i'm looking at that now.
17:25:32 <Speck> aaah, benchmarketing!
17:25:42 <astrolabe> I think the big advantage of functional programming is in developer time, not cpu time
17:26:11 <tmccort> fasta is really bad. Probably a poor implementation
17:26:12 * shapr agrees
17:26:23 <astrolabe> but that doesn't include time to grok the language :)
17:26:37 <TheHunter> i don't expect GHC to be any faster than Java in most cases, even a harmless sum [1..n] has horrible performance.
17:27:21 <tmccort> 8-11 for CPU time in favor of Java on the shootout
17:27:45 <tmccort> full cpu time rather
17:27:46 <Cale> Haskell doesn't seem any harder to teach to people who are new to programming. It's just changing the way that you program which seems to be the hard part. :)
17:28:08 <shapr> Yeah, that's seems true to me.
17:28:09 * cm wonders why [1..n] (n :: Integer) is a [Integer] and not a Sequence a => a Integer or however you spell that.
17:28:15 <cm> shapr!
17:28:21 <shapr> y0 cm
17:28:29 <cm> @todo
17:28:30 <shapr> I just looked at TreeMaps, they're interesting.
17:28:32 <lambdabot> 0. dons: Release lambdabot 3.0
17:28:32 <cm> :)
17:28:34 <lambdabot> 1. SamB: A way to get multiple results from a google search
17:28:36 <lambdabot> 2. SamB: @get-shapr summons shapr instantly
17:28:38 <lambdabot> 3. SamB: bare @part either gives error message or parts the channel
17:28:41 <lambdabot> the command was given on
17:28:42 <lambdabot> 4. SamB: stop mangling long urls
17:28:44 <lambdabot> 5. dons: improve formatting of @dict
17:29:01 <cm> the pictures seemed kindof inspiring wrt to the "programming directly on the syntax tree" talk we had a while ago
17:29:07 <cm> (and for other stuff)
17:29:21 <shapr> Hm, I hadn't thought of that.
17:29:25 <shapr> That's a neat idea.
17:29:35 <astrolabe> tmccort: the haskell code for fasta has the fewest code lines
17:30:12 <tmccort> It also uses 37 times more memory then Java
17:30:50 <astrolabe> Yeah, but it would be possible to recode it so it was longer but more efficient
17:31:05 <astrolabe> It depends on your priorities
17:31:27 <tmccort> "Note: This code has not been optimized *at all*."
17:31:37 <TheHunter> well, the shootout has some strange kind of code: http://shootout.alioth.debian.org/great/benchmark.php?test=wc&lang=ghc&id=0&sort=fullcpu
17:31:38 <jlouis> hehe
17:32:23 <shapr> I like the Haskell version of the pi spigot.
17:33:27 <tmccort> Could you write a good webserver in Haskell?
17:34:37 <TheHunter> g'night everyone
17:34:53 <astrolabe> night Hunter
17:35:36 <tmccort> I don't think I even want to know what a monad is as I don't like them already.
17:35:52 <Cale> Monads are okay
17:36:55 <astrolabe> monads are very cool, but they do make my head hurt at the moment.
17:37:20 <jlouis> indeed monads are cool. There are a lot of people disagreeing with us however
17:37:31 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
17:37:44 <ows> hi folks!
17:37:52 <ows> is haskell based on some formal method?
17:38:00 <astrolabe> hi ows
17:38:13 <jlouis> ows: define formal method?
17:38:37 <jlouis> ows: if you mean complete big-step operational semantics, then no
17:38:48 <astrolabe> There are some quite clever mathematical / CS ideas behind it
17:39:14 <shapr> tmccort: There is a good webserver in Haskell.
17:39:17 <ows> "techniques for the specification, development and verification of software" (in this case)
17:39:36 <ows> formal techniques
17:40:07 <jlouis> model checking?
17:40:14 <jlouis> static analysis
17:40:17 <ows> kind of z notation
17:40:27 <shapr> ows: Have you read the QuickCheck papers?
17:40:37 <Spark> formal methods
17:40:51 <ows> http://vl.zuser.org/pub/zglossary.ps.Z
17:41:10 <shapr> There's also Martin SjÃ¶gren's beginning of an automatic Haskell code proof tool.
17:41:22 <monochrom> haskell is not based on some formal method.  in the usual sense of that phrase.
17:41:42 <ows> shapr: http://www.cs.chalmers.se/~rjmh/QuickCheck/ ?
17:42:04 <shapr> That's it, especially the second QuickCheck paper, which specifically covers model verfication.
17:42:26 <ows> do you know z formal method?
17:42:59 <monochrom> I have seen some Z.  Not enough to say "know".
17:44:19 <Cale> tmccort: You might try reading that link I pasted. It's an introduction to monads which I wrote based on the way that I tend to think about them. They're sort of abstract enough that any number of analogies might be made, but I find the "containers" one to be a bit better in terms of concreteness than "computations" when starting out.
17:45:42 <astrolabe> cale: it is a really good page.  Thanks.
17:45:59 <Cale> http://www.nomaware.com/monads/html/ is also a great tutorial on monads
17:48:30 <astrolabe> I don't think monads are a good place to start learning haskell though.
17:49:08 <Cale> Well, you want to know a bit about the type system first :)
17:49:46 <Speck> definitely start with values and types
17:50:01 <Cale> I talked to my philosophy prof at one point, and she had studied algebraic topology, so already knew what monads were, but not how they related to programming. That was interesting :)
17:50:28 <ski> heh
17:51:14 <astrolabe> I don't remember monads from the algebraic topology I did, or even from the category theory.
17:51:37 <astrolabe> Sounds as though she was quite advanced
17:53:45 <tmccort> I'm just trying to decide is the application that I'm planning should be written in Haskell. I was going to write it in Java but was planning to learn haskell and get into functional programming anyway so...
17:54:54 <astrolabe> what is the application?
17:56:22 <Cale> tmccort: Have you been pointed at "Yet Another Haskell Tutorial"?
17:56:35 <tmccort> Kind of a distributed swarm based webserver. Kind of a BitTorrent for websites.
17:57:03 <tmccort> Cale, I'm about halfway through it.
17:57:56 <monochrom> there is a book on the predicate transformer semantics saying how it is analogous to algebraic topology.  it's scary.
17:58:40 <astrolabe> monochrom: sounds interesting (and scary)
18:00:13 <tmccort> I think mathematics is getting to much for humans.
18:00:22 <monochrom> http://www.amazon.com/exec/obidos/tg/detail/-/0521420369/qid=1120438850/sr=8-1/ref=sr_8_xs_ap_i1_xgl14/104-5450380-1300761?v=glance&s=books&n=507846
18:00:22 <tmccort> too
18:00:46 <Spark> tmccort: humans are very good at using tools
18:01:13 <tmccort> Yes, like computers to turn everything into formal proofs ;)
18:01:25 <Spark> exactly
18:02:10 <Spark> thats progress though
18:02:11 <tmccort> I wonder if anything like that will ever get made.
18:02:35 <astrolabe> I think people can do maths, and coding by at each stage ignoring most of the context and concentrating on some detail.  I guess, that method might run out of steam at some point.  Then we'll be in trouble.
18:03:04 <tmccort> By that time we'll probably have cybornetic implants.
18:03:24 <cm> i think you can have a good enough idea of the whole thing (at least in coding, i've no good idea of the equivalent in maths)
18:03:42 <cm> implants would be great to give you a couple of more registers :-)
18:03:50 <cm> -of
18:04:30 <tmccort> It would be cool to be able to learn anything in just a couple of minutes.
18:04:44 <tmccort> Learning right now is such a bother.
18:05:00 <astrolabe> cm: I disagree, to think about 1000 lines of code you have to forget the fine structure, which is a different kind of concentrating on a 'detail' (except detail isn't a good word for it anymore).
18:05:23 <cm> yeah, because it's not detail and that's what i'm saying :)
18:05:51 <astrolabe> Ah.  Well you agree with what I think, just not what I said. :)
18:06:59 <cm> :)
18:07:18 <cm> Probably just since I'm not sure what you're saying :-)
18:07:41 <cm> I think it's well-possible to "understand" a 1MLOC code base for a useful definition of "understand".
18:07:56 <cm> (I WANT TO DISAGREE, RARRRR! :-)
18:07:58 <Spark> with coding you can consider a unit in an arbitrary context though
18:08:04 <Spark> like, pre and post conditions of a function
18:08:16 <monochrom> Yeah, it's called "documentation".
18:08:20 <Spark> principal typings as well
18:08:22 <monochrom> or "specification"
18:08:43 <cm> or the algorithm would be "division&conquer" or "segmentation", depending on the split.
18:08:51 <monochrom> You have to write down what environmental assumptions your module makes.
18:09:08 <cm> you can also ask the compiler ;)
18:09:21 <cm> but these are just short-cuts..
18:09:22 <astrolabe> sorry can't argue now.... need bed
18:09:26 <cm> nn
18:10:35 <tmccort> So what would be a better choice for my application?
18:11:09 <cm> .oO(implants)
18:17:06 <malig> anyone here do much in the way of generating C from haskell?
18:19:05 <malig> I want do be able to have the C types exposed to the haskell typechecker (ie: have newtype Cint, newtype Cfloat instead of data Ctype = Cint Int | Cfloat Float)
18:19:33 <malig> but I can't think of any way to do that and still be able to describe C functions without them basically being inlined everywhere
18:19:33 <dons> newtype Cint = .. ?/
18:19:39 <Igloo> The FFI addendum defines Foreign.C.Types.CInt etc
18:19:57 <dons> that's probably what you're looking, yes.
18:20:00 <malig> I'm not trying to interface... I'm trying to generate C code from haskell
18:20:15 <dons> s/looking for/
18:20:28 <Igloo> Give up now, dons  :-)
18:20:35 <malig> (actually, I'm trying to generate LLVM asm, but it's close enough to C)
18:20:36 <Igloo> I'm not following exactly what you want, malig
18:21:29 <Igloo> Oh, you want the Haskell type checker to check the C programs you create are well-typed?
18:21:34 <malig> yes!
18:22:43 <dons> there's work on domain specific languages where they do roughly this
18:22:56 <Igloo> The easiest way is probably with a small "obviously correct" library of functions that manipulate the abstract datatypes, and use a phantom type for the C type
18:25:08 <tmccort> That's wonderful... the wxhaskell install doesn't work.
18:27:04 <shapr> malig: What about generating C--?
18:27:40 <autrijus> is there standalone C-- emitter?
18:27:42 <autrijus> in haskell that is
18:27:46 <malig> If you've got a good example of someone doing that, that'd be great to seee
18:28:00 <shapr> GHC has the Cmm backend, I'm not sure if it's standalone.
18:28:15 <Igloo> Is this something GADTs should be good at, incidentally?
18:28:19 <malig> I'm a little afraid off the ghc source :P
18:28:20 <dons> shapr, you having trouble buildling Yi?
18:28:41 <dons> autrijus, you could dump the ghc cmm code
18:28:49 <dons> or just rip out the ppr
18:29:41 <shapr> dons: Yeah, can't find System.Plugins
18:30:00 <autrijus> the ppr looks stdalone enough
18:30:11 <cm> autrijus of pugs fame..
18:30:23 <autrijus> hm, FastString Outputable
18:30:23 <shapr> C'mon, autrijus is a common enough first name.
18:30:27 <dons> shapr, just need latest darcs hs-plugins
18:30:33 <autrijus> those are internal to ghc?
18:30:37 <dons> latest == since about start of may
18:31:07 <dons> autrijus, yep. but you can replace them with Strings, I'd think
18:31:14 <shapr> darcs pull -a && autoreconf && ./configure && make  and then make install as root, right?
18:31:25 <autrijus> 'kay. I'll check it out in my copious free time :)
18:32:02 <dons> shapr, sounds right to me.
18:32:08 * shapr tries again
18:32:26 <dons> Sun May 15 14:55:38 EST 2005  Don Stewart <dons@cse.unsw.edu.au>
18:32:27 <shapr> I've had a cold for a week, so most likely user error on my part.
18:32:27 <dons>   * HEADS UP: Move modules under the System.* and Language.* namespace
18:32:33 <shapr> Foo, same thing :-(
18:32:43 <shapr> Do I need to make clean in those trees first?
18:33:00 * shapr tries that
18:33:22 <dons> oh, you'll need to unregister the old libs perhaps
18:33:45 <dons> as the whole structure changed -- there's no 'eval' now, for example
18:34:22 <dons> check that your package.conf only has 'plugins', 'hi' and 'altdata' after you make register
18:35:10 <shapr> What did it have before?
18:36:00 <dons> I'm thinking that the now-non-existent old packages are still in the package.conf
18:36:02 <metaperl> shapr: have you looked at asciidoc for formatting plain-text to both ascii and HTML and PDF: http://www.methods.co.nz/asciidoc/
18:36:24 <shapr> doh, I forgot to do make register
18:36:29 <shapr> I always think that's part of make install.
18:36:53 <metaperl> shapr: this is in regards to publishing TMR (asciidoc)
18:36:54 <shapr> metaperl: No, I'll check it out.
18:37:21 <metaperl> I've enjoyed using it for my personal stuff quite a bit
18:37:41 <shapr> How do you compare it to kwid?
18:38:54 <shapr> yay, yi builds!
18:39:15 <Spark> how is yi pronounced
18:39:21 <dons> yee
18:39:31 <Spark> sounds a bit retarded doesnt it
18:39:43 <shapr> Nah, sounds like the source of all righteousness.
18:40:05 <shapr> It's also the most recursive name available.
18:40:23 <dons> Spark, you can pronounce it however you like.
18:40:28 <shapr> Since it's the Y combinator applied to I combinator.
18:40:36 <shapr> Anyway, sleeptime for me.
18:40:37 * shapr &
18:40:42 <Spark> heh
18:40:47 <dons> @eval Y I
18:40:50 <lambdabot> out of fuel - use @resume to continue
18:40:53 <dons> hehe
18:40:54 <Spark> @resume
18:40:56 <lambdabot> out of fuel - use @resume to continue
18:41:01 <rabican> anyone here using haskel and linux for a website? without any oher prorams or webserves etc?
18:41:47 <autrijus> dons: hm, I noticed the chinese character "Yi" for the first time
18:42:05 <autrijus> it's funny though, because one among its meanings is "semantics"
18:42:11 <dons> oh, that's nice :)
18:42:23 <autrijus> so placing it next to "just syntax" creates a nice effect :)
18:42:32 <autrijus> why did you pick that word in the first place?
18:42:41 <dons> hehe. that's unintended. I wasn't aware of the `semantics' meaning.
18:42:57 <autrijus> ah. "meaning", "semantics" is its original meatning
18:42:58 <dons> we where tossing ideas around here last October, I think.
18:43:00 <autrijus> meaning
18:43:54 <autrijus> *nod*. I guess you used its more everyday meaning, "righteousness"
18:43:56 <dons> i think we liked yi because of eval Y I, and then came upon the chinese word which worked reasonably well.
18:44:00 <dons> yep.
18:45:23 <autrijus> @eval Y
18:45:24 <lambdabot> <<EM Dynamic -> EM Dynamic>>
18:45:26 <autrijus> @eval Y Y
18:45:29 <lambdabot> out of fuel - use @resume to continue
18:45:44 <dons> @get-def Y
18:45:45 <lambdabot> Y = \f.U(\g.f(U g))
18:45:46 <dons> @get-def I
18:45:47 <lambdabot> I = \x.x
18:45:54 <dons> @get-def U
18:45:55 <lambdabot> U = \f. f f
18:46:47 <dons> @eval (\f.(\f. f f)(\g.f((\f. f f)g))) (\x.x)
18:46:49 <lambdabot> out of fuel - use @resume to continue
18:46:52 <dons> heh, it works.
18:48:03 <autrijus> in which sense is "Y I" "the most recursive name available"?
18:48:13 * autrijus does not get what 'most recursive' means
18:48:27 <dons> hehe. true.
18:48:48 <dons> it must be the only acronym which is actually bottom when evaluated
18:49:10 <dons> ie. the name is directly lambda calculus
18:49:23 <autrijus> but surely "YY" or other names work as well?
18:49:23 <dons> so that was the motivation, if I recall
18:49:36 <dons> yes. other lambda calc names would work.
18:49:41 <dons> but no projects have them ;)
18:50:16 <dons> so "most recursive" == of the project names that exists, this is the only one that is executable code that doesn't terminate
18:50:39 <autrijus> *nod*
18:50:58 <dons> typical lambda-geek joke, really
18:51:47 <autrijus> just like a certain vulture capital firm
18:53:45 <autrijus> Yk = (L L L L L L L L L L L L L L L L L L L L L L L L L L L L)
18:53:49 <autrijus>     where L = ?abcdefghijklmnopqstuvwxyzr.(r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
18:54:02 <autrijus> er, the '?' there should be a '\'
18:54:22 * autrijus trieds to figure out why this is a fixpoint combinator
18:56:44 <malig> I wish I could get that on a tshirt
18:56:58 <malig> but it seems a little long to fit
18:58:29 <dons> that's why you want "Y I"
18:59:26 <rabican> hello
18:59:36 <rabican> can I build websites using haskell for ecommerce?
18:59:39 <rabican> on linux?
18:59:54 <autrijus> nothing can stop you, so the answer is 'yes'
18:59:58 <rabican> will haskell programming give me an edge in the maket
19:00:00 <rabican> ?
19:00:12 <rabican> spreadsheets are amazing to me
19:00:25 <rabican> I fi can build a site with something that allows that over the web then wow
19:00:29 <rabican> its could be stellar
19:00:50 <autrijus> you mean like http://www.myspreadsheet.com/?
19:01:33 <rabican> something to run a business on
19:02:14 <rabican> on thats interesting
19:02:26 <rabican> but firm get fearful of data outside corp control
19:02:43 <rabican> Im talkabout about doing lamp like development without the a and p
19:02:48 <rabican> or m
19:02:53 <rabican> just linux and haskell
19:03:06 <rabican> also, haskell is not a lisp is it?
19:03:11 <autrijus> that'd be entirely possible. a lot of fun, too. I'm not sure how practical it is, though :)
19:03:15 <cm> but LH is a weird acronym.
19:03:44 <cm> you should call it Haskell on Rails, given sufficient marketing skills you will be wealthy and people will be happy :-)
19:03:54 <autrijus> riiight :)
19:04:17 <autrijus> rabican: no, haskell is not a lisp.
19:05:51 <cm> or maybe call it 'whoops' for "web/haskell/oop system"
19:05:58 <cm> the 'oop' part is good for marketing :)
19:06:11 <cm> damn, i should become a naming consultant :D
19:07:56 <malig> rats, looks like the cmm generator in ghc doesn't do quite what I wanted... some good inspirations though
19:08:18 <rabican> hey
19:08:24 <rabican> im serious im starting a company
19:08:28 <rabican> www.geocities.net
19:08:31 <cm> :o
19:08:40 <rabican> and I fI can use something powerful like haskell to make things easy
19:08:44 <rabican> then I could get rich
19:08:54 <rabican> I dont care if its cheesy marketing crap
19:08:57 <rabican> Illl sell out
19:09:18 <rabican> what compiler should i use to learn haskell ?
19:09:21 <rabican> hugs?
19:09:28 <dons> not a compiler.
19:09:28 <gzl> GHC is good
19:09:31 <dons> try ghc.
19:12:32 <cm> autrijus, do you have a full-time job? your apparent progress on pugs is very scary
19:14:55 <cm> (in the positive sense, ofc)
19:15:13 <rabican> ghc it is then
19:15:29 <rabican> and do you reccomend haskell over other tool for website building
19:15:30 <rabican> ?
19:15:44 <rabican> do you prefer it to python perl php ruby etc?
19:15:55 <gzl> it depends
19:16:12 <gzl> if you're writing CGIs with WASH, it's rather annoying
19:16:33 <cm> you have less choice of already existant libraries for the web domain than in other languages
19:16:57 <cm> but i strongly believe you could do great
19:17:04 <gzl> I haven't looked at the other options in Haskell but my impression is that there aren't that many of them
19:17:13 <gzl> and nothing dramatically better than WASH
19:18:50 <cm> i agree
19:19:14 <cm> shapr, what do you think about Wadler's Links?
19:21:55 <rabican> so how does wash stack up against other LAMP ish combination?
19:22:35 <cm> it's more like the (A)P in LAMP
19:27:47 <autrijus> cm: yes, I own a small consulting company
19:28:00 <autrijus> cm: so you can see I refer to $job in my journal from time to time
19:28:09 <autrijus> (and also my $job makes use of perl, pugs, haskell)
19:28:24 <autrijus> so it's a plus, not a minus, to my progress on pugs
19:29:16 <cm> very nice
19:31:48 <cm> autrijus: how much of your time do you spend on pugs these days (as a fraction of your entire "work" time), if I may ask?
19:32:08 <autrijus> cm: in last month it's like 100% of my waking time
19:32:18 <autrijus> now I'm back to taiwan I expect it to be 50% or so
19:32:53 <cm> was that the month of your "hacking at conferences all over the world" trip? :-)
19:33:52 <autrijus> yup
19:34:01 <autrijus> got lots of work done
19:34:12 <autrijus> now I can go back and actually understand ATTaPL :)
19:34:37 <cm> :-)
19:34:54 <cm> i haven't read more than the type inference chapter yet ;(
19:35:45 <autrijus> the lyf so short the craft so long to lerne
19:38:36 <cm> indeed
20:01:44 <reffie> http://astraldream.net/~refugee/Screenshot-34.png
20:06:35 <cm> need a medic!
20:06:57 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueThree","ICFP Contest! http://icfpc.plt-scheme.org/"]' by juhp
20:52:33 <ows> night all
21:03:15 <lstna_> @timein edt
21:03:18 <lambdabot>  Sorry, don't know this city
21:03:39 <lstna_> @timein EDT
21:03:40 <lambdabot>  Sorry, don't know this city
21:03:49 <malig> @timin boston
21:03:51 <lambdabot>  Monday, July 4, 2005 at 12:04:52 AM EDT
21:04:00 <lstna_> @Is boston EDT?
21:04:01 <lambdabot> Maybe you meant: msg pl wn
21:04:02 <malig> yup
21:04:15 <wagle> @timein timbuktu
21:04:17 <lambdabot>  Sorry, don't know this city
21:04:20 <lstna_> Great, thanks.
21:04:47 <wagle> that is the correct time for boston
21:05:32 <lstna_> I was trying to work out when Deep Impact impacts my time
21:05:54 <wagle> deep impact?
21:06:54 <lstna_> Space mission that throwing a 600kilo lump of metal into teh Tempel 1 comet in a few hours time.
21:07:11 <wagle> oh yeah
21:07:24 <lstna_> http://www.nasa.gov/mission_pages/deepimpact/main/index.html
21:07:56 <malig> not supposed to be visible by naked eye, right?
21:08:27 * wagle 's battery dies
21:08:32 <wagle> ta ta
21:09:46 <lstna_> They list a "viewing opportunities" link javascript:openNASAWindow('http://deepimpact.umd.edu/amateur/outreach/index.shtml#events'), but I (trying) to watch the images from the on-board camara
22:38:08 <MachinShin> hey all
23:04:51 <egg> Does Parrot beat Pugs?
23:05:56 <Pseudonym> No, they're on friendly terms.  No physical violence whatsoever.
23:08:53 <Khisanth> egg: how many channels did you just ask that question in?
23:10:11 <egg> (silly) ... 3
23:11:46 <Pseudonym> I think you scared him off.
23:12:44 <Khisanth> hmm he should have asked his next question in here though :)
