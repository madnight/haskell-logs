00:29:11 <sunym> how to flush the output or how to set the stdout properties(so when print will be flush auto) in ghc
00:30:00 <ski> @type System.IO.hFlush
00:30:02 <lambdabot> GHC.IOBase.Handle -> IO ()
00:30:54 <Lemmih> @type System.IO.hSetBuffering
00:30:56 <lambdabot> GHC.IOBase.Handle
00:30:56 <lambdabot>          -> GHC.IOBase.BufferMode
00:30:56 <lambdabot>          -> IO ()
00:31:08 <ski> if you have line buffering, then i think it shoudl flush at newlines, though
00:31:19 <ski> m
00:35:23 <sunym> ski: ah, because my print is "something\n",so i run this code on my plain term again and have the result with new line flush effect, so i think this must the emacs pipe problem or style
00:38:38 <ski> sunym : what does 'System.IO.hGetBuffering System.IO.stdout' return ?
00:42:25 <sunym> NoBuffering:-(
00:43:21 <ski> then you could try changing that to LineBuffering
00:44:01 <Speck> anyone know of (free) papers online about fusion techniques for effectless functional programming?
00:48:32 <sunym> oh, i test the buffer mode in ghci in plain term the result is NoBuffering, but if i compiled using ghc and test in plain term the result is LineBuffering,and run the samy binary in emacs shell the result is BlockBuffering, i use ghc6.4 WindowsXP GNU emacs 22.0 for Win32
00:53:32 <ski> sunym : so, you can set the buffering to the one you want in main, yes ?
00:55:36 <sunym> yes, laziness will ruin the code!
01:12:41 <dblhelix> iirc, emacs won't allow you to use NoBuffering, though
01:15:33 <sunym> dblhelix: what do you mean "won't allow", could you give some detail?
01:18:35 <dblhelix> sunym: if you run you're program within the emacs shell, emacs will ensure that you can use backspace etc. to edit the line you're typing; hence, a program that consumes its input character by character, as opposed to line by line, is bound to conflict with emacs way of going
01:20:30 <sunym> but that is Input NOT Output
01:21:20 <dblhelix> sunym: that's true :) I did not follow all of the conversation, I'm sorry
01:23:34 <sunym> that's ok,:-P
01:41:46 <Speck> Does anyone use ghc on windows here?
01:42:13 <dblhelix> not frequently, but, yeah, sometimes
01:43:54 <Speck> I'm wonder what development environment to set up
01:44:15 <lightstep> vim
01:44:24 <Speck> without using cygwin
01:44:26 <Matt-W> vim!
01:44:30 <lightstep> you have gvim for windows
01:44:33 <Speck> aha
01:44:55 <lightstep> or you can use yi
01:45:08 <Speck> I could never get all the dependencies to compile
01:48:06 <sunym> GNU emacs for Windows
01:48:45 <Speck> yeah, emacs looks nice too, but I'm already familiar with the vim keybindings
01:49:00 <Speck> I'm a little curious about eclipse too, or a more fully-featured ide
01:50:17 <Tue5372> isn't there some command that will delete everything from one opening bracket to the corresponding closing one? it seems a very useful operation
01:50:19 <Tue5372> in vim btw
01:51:02 <sunym> i know there is a haskell plugin for eclipse but i never use the eclipse or the plugin.
01:52:17 <Speck> I don't know all the commands :-) just enough to get by with a few shortcuts
01:54:08 <Speck> I wonder if I can use haskell with the visual studio .net that I already have
01:54:24 <Tue5372> sounds sluggish :)
01:56:13 <Speck> it's not so bad
01:56:20 <lightstep> Tue5372, d%
01:56:29 <Tue5372> sweeet
01:56:33 <Tue5372> quite logical actually
01:56:38 <lightstep> if you're on the opening brace, otherwise click % a couple of times
01:56:51 <sunym> Tue5372: which editor do you use?
01:57:03 <Tue5372> w skips a word, dw deletes a word.....% goes to the corr. closing bracket...so d% is logical indeed
01:57:25 <Tue5372> sunym, currently i like to use vim with split windows for multiple files
01:57:35 <Tue5372> i have a makefile to compile etc.
01:59:29 * Speck is interested in hIDE 2
01:59:29 <sunym> oh, i am not familir with vim, at least you can ask this question in #vim
02:01:12 <Tue5372> didnt think of it sunym, my sincere apologies
02:20:38 <musasabi> When defining "plus" in epigram why does it make "plus x y []" => (typing) "plus x y [<= rec x]" (escape)  the "rec x" brown meaning an error?
03:28:50 <Speck> hmm... can I pass my current buffer in gvim to ghci?
03:29:10 <Speck> it would be sweet to be able to switch between them, calling reload and such
03:43:17 <Lemmih> @seen SyntaxNinja
03:43:19 <lambdabot> I saw SyntaxNinja leaving #haskell 10 hours, 11 minutes and 52
03:43:19 <lambdabot> seconds ago.
04:12:02 <ski> hm, multi-parm classes is surely an experimental feature, right ?
04:12:28 <musasabi> yes.
04:12:37 <musasabi> But a quite stable experimental feature.
04:13:23 <ski> added them to hawiki/ExperimentalFeatures
04:16:49 * shapr throws redexes
04:17:13 <shapr> Speck: C-c C-l in emacs
04:18:53 <ski> hm, what was the name of the parsing lib using arrows ?
04:21:08 <Lemmih> PArrow?
04:28:35 <Tue5372> Polishing Parsing Arrows....brrr
04:28:36 <Tue5372> :P
04:30:32 <ski> ah..
04:30:43 <ski> weird that google didn't find PArrow
04:30:53 <ski> found it via scannedinavian :)
04:31:00 <shapr> strange
04:32:15 <ski> i got an idea regarding parsing ..
04:32:54 <ski> or more specifically, regarding a problem someone here had a few days ago
04:33:37 <ski> (and it might be able to solve it, using an arrowic parser)
04:34:19 <Lemmih> What problem did someone have here a few days ago?
04:34:37 <Tue5372> a parse error?
04:36:28 <ski> the person was trying to use Parsec interactively, getting a lazy list of commands back from Parsec
04:37:18 <ski> but Parsec would not yield any result until it knows all commands parses correctly  (iirc)
04:38:50 <ski> more or less  parseCommands = do {cmd <- parseCommand; cmds <- parseCommands; return (cmd:cmds)}
04:44:47 <Lemmih> lazyParse p src inp
04:44:47 <Lemmih>     = case parse (liftM2 (,) p getInput) src inp of
04:44:47 <Lemmih>         Right (a,rest) -> a:lazyParse p src rest; Left _ -> []
04:44:54 <Lemmih> Like that?
04:48:00 <ski> that'd prolly work, i think
04:48:35 <ski> (i think the person wanted to not always end parsing on parse error, though)
04:48:45 <ski> can you make that into a parser ?
04:48:52 <Philippa_> a little extra-monadic code ought to fix the problem
04:49:28 <Philippa_> have the parser return what's left of the input (Parsec can do that) as well as the result, keep manually invoking Parsec
04:50:44 <Lemmih> Philippa_: Isn't that exactly what my 'lazyParse' function is doing?
04:52:14 <Philippa_> probably :-)
04:52:21 <Philippa_> yea
04:52:24 <Philippa_> my bad
04:52:29 <Philippa_> walked in too late
04:54:09 <Tue5372> omg finding bugs is so rewarding
04:56:36 <ski> lazyParser p = do {src <- getSource; inp <- getInput; return (lazyParse p src inp)}   ?
04:58:54 <ski> anyway, i had another idea .. if we knew parsing the rest of the commands would be deterministic, we could prolly have the first element available before having finished parsing rest
05:00:02 <ski> and i think we can't do that with monads .... arrows on the other hand ..
05:02:18 <musasabi> ski: with monads the the idea is to have the parser return (command,restOfInput)
05:02:25 <Lemmih> How can a lazy parser make sense? Isn't it like: do hGetContents someHandle; hGetLine someHandle?
05:02:59 <ski> yes, it's a bit similar
05:03:21 <ski> musasabi : i was looking for a way to do it inside the parser ..
05:03:35 <Lemmih> (ie. since we don't know how much the lazy parser will consume we can't continue the parsing)
05:04:01 <shapr> Aren't parsers always lazy?
05:04:03 <ski> hm
05:04:04 <musasabi> ski: so you want to embed your processing inside the parser?
05:04:12 <shapr> ohh
05:04:22 <ski> Lemmih : sorry, misread your example code ..
05:04:30 <musasabi> That would work if the parser would be a monad/arrow transformer I think.
05:04:45 <ski> musasabi : yes, that could possibly work too
05:06:09 <ski> musasabi : s/he wanted to have interleaved parsing and processing. whether what s/he wanted more specifically requires feedback from processing to parser, i don't know.  i was looking for lazy parsing
05:07:32 <musasabi> ski: you could define a function like lazyParser :: Parser (Command,Input) -> Input -> [Command]
05:08:19 <ski> musasabi : hm, can you explain that ?
05:08:22 <ski> shapr : consider    parseCmds = do {exitCmd; return []} <+> do {cmd <- parseCmd; cmds <- parseCmds; return (cmd:cmds)}
05:10:01 <ski> shapr : when the parser knows that the recursive 'parseCmds' will not yield a parse error, then the whole call will not yield a parse error, so then it can yield the answer which is the first 'cmd' and the rest of them
05:10:05 <musasabi> given a "runParser :: Parser a -> Input -> Maybe a" (a simplification), lazyParser p inp = loop inp where loop inp = let Just (x,y) = runParser p inp in (x:loop y)
05:10:45 <Lemmih> ^^ That's pretty much what I pasted.
05:11:10 <ski> shapr : so it has to wait for 'parseCmds' to successfully end, before it can commit to the whole parsing giving 'cmd:cmds'
05:11:14 <musasabi> Lemmih: point.
05:12:12 <shapr> ski: I don't get it, but that's probably lack of sleep on my part.
05:14:52 <ski> musasabi : that's still extra-monadic
05:15:43 <musasabi> extra-monadic?
05:15:44 <ski> i'm pondering about an "intra-" solution
05:15:57 <ski> <Philippa_> a little extra-monadic code ought to fix the problem
05:16:16 * Lemmih still doesn't see how a lazy monadic parser can make sense.
05:16:36 <musasabi> ski: newtype MyMonad a = MyMonad { State [Command] a } ;)
05:17:02 <shapr> call me sleepless, but how are monadic parsers strict?
05:17:02 <musasabi> tr/{}/()
05:17:18 <Lemmih> shapr: "getCommands = do cmd <- getCommand; cmds <- getCommands; return (cmd:cmds)" doesn't terminate unless 'getCommand' is bottom.
05:17:32 <ski> if we are sure 'parseCmds' can't fail, then it can't hurt having 'cmd' (result from 'parseCmd') available, before 'parseCmds' have finished, no ?
05:17:52 <shapr> ohhh
05:18:00 <Philippa_> musasabi: extra-monadic => "outside the monad"
05:18:04 <shapr> Isn't this where mfix gets used?
05:18:49 <Philippa_> FWIW, you can probably wrap around any and all of the changes made in parsec - dump out all the relevant state info into pureland, then return /that/ into an outer parser which puts all the state in place
05:18:56 <musasabi> extra-monadic => with extra monads ;)
05:19:13 <ski> (Lemmih : ".. unless 'getCommand' is bottom." ?)
05:19:19 <shapr> The Y combinator doesn't have a type in HM, so use fix, right?
05:19:41 <ski> HM ?
05:19:41 <Philippa_> right. Which is most likely the Y combinator wrapped in a compiler-hack coerce :-)
05:20:13 <shapr> hindely-milner
05:20:29 <ski> y :: (a -> a) -> a   -- surely ?
05:20:30 <shapr> @type mfix
05:20:42 <lambdabot> bzzt
05:20:46 <shapr> Nah, the Y combinator is \x -> x x
05:20:48 <shapr> @hoogle mfix
05:20:54 <Lemmih> ski: If 'getCommand' is, say, undefined.
05:21:04 <ski> shapr : i thought that was called U ?
05:21:06 <shapr> @index mfix
05:21:07 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer,
05:21:07 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
05:21:07 <lambdabot> Control.Monad.Error
05:21:16 <shapr> @type Control.Monad.Fix.mfix
05:21:17 <Philippa_> yeah. Y's the complex-omega-variant
05:21:18 <lambdabot> forall (m :: * -> *) a.
05:21:18 <lambdabot>          (Control.Monad.Fix.MonadFix m) =>
05:21:18 <lambdabot>          (a -> m a) -> m a
05:21:33 <Philippa_> ski: the problem is that H-M won't type that
05:21:45 <Philippa_> it can represent the type, but it can't assign that type to the Y operator
05:22:04 <Philippa_> which means you need a fixpoint operator as a part of the language itself
05:22:05 <ski> (Philippa_ : because of occurs-check, yes (in OCaml, you can type it with -rectypes option))
05:23:36 <shapr> I think mfix is specifically for situations like the lazy getCommands.
05:24:03 * ski is trying to figure out how mfix could be used to do this ..
05:24:19 <ski> but i'm not sure mfix can solve it ..
05:25:00 <ski> (even if we had an mfix for a parsing monad .. is there any such ?)
05:25:03 <shapr> Maybe I'm just confused. No, I know I'm confused from lack of sleep, but I could also be wrong about mfix ;-)
05:25:29 <Philippa_> mfix for a parsing monad strikes me as scary
05:25:45 <Philippa_> AFAIC it's just there to let you treat do as letrec rather than let IYSWIM
05:26:13 <ski> i was thinking a parsing arrow could have a static info about determinism, which you could possibly use to solve this prob
05:27:10 <ski> (thinking of lazy parsers as a bit similar to lazy predicates in logic programming .. :)
05:29:08 <musasabi> does mfix offer any guarantees about order?
05:31:24 <ski> dunno
05:39:50 <Philippa_> I'm not aware of any
05:52:53 <bringert> I'm looking for a Haskell MIME implementation. igloo told me there's some in WASHMail, anyone know of any others?
05:53:19 <shapr> I think someone else had even less of a mime implementation, but iirc it wasn't even usable.
05:53:41 <shapr> When I wrote curryspondence, WASHMail was the only usable option.
05:53:51 <bringert> I need it to implement support for multipart/form-data in my CGI module (basically for file uploads)
05:54:19 <bringert> is the MIME support there complete enough for using it for input?
05:55:00 <musasabi> bringert: last time I looked it worked, but didn't scale.
05:55:07 <bringert> hmm
05:55:21 <bringert> well, I'll use it to start with then nyway
05:55:26 <bringert> anyway
05:55:43 <musasabi> bringert: if you get it to handle ~30mb file uploads I would be very interested.
05:56:07 <bringert> I'm a fan of code now, optimize later
05:56:56 <bringert> so I'll try to get it working first
05:57:07 <bringert> but of course the goal is to be able to handle large files
05:57:19 <bringert> might need to do some FFI stuff or use temp files
05:57:34 <Tue5372> hey how much overhead is there concerned with calling a C function?
05:58:13 <bringert> but I figure that's optimization => leave for later
05:58:55 <bringert> Tue5372: afaik not very much, but you may need to marshal data between Haskell and C types
05:59:45 <bringert> not always necessary though, for example if you keep the data in a C array
05:59:47 <Tue5372> aha because i've got two choices....implement an equationsolver in haskell or call some piece of c code that does it
06:00:00 <bringert> do you have the C code already?
06:00:19 <Tue5372> uhm....im trying to find some on the internet
06:00:26 <Tue5372> i reckon there has to be someone that implemented it
06:00:48 <Tue5372> its for solving linear diophantine equations with linear constraints
06:02:54 <bringert> which WASHMail version is the best to build on? Peter Thiemann's? the one in missingh? heard something about a WASH - new gen yesterday
06:03:00 <bringert> or are they all the same?
06:03:16 <shapr> They're all the same.
06:07:33 <Igloo> Peter's will be at least as new as missingh's, I imagine
06:07:49 <Igloo> If you find any others, please let me know, BTW
06:08:02 <shapr> Sounds like another community needed project.
06:08:27 <Igloo> Only if WASH's isn't sufficient
06:08:27 <bringert> shapr: which does?
06:08:37 <shapr> A decent MIME library.
06:08:41 <xerox> Hiya.
06:08:42 <bringert> ah, right
06:08:42 * Igloo hasn't looked at it properly
06:09:02 <bringert> I'll play a little with it
06:09:05 <shapr> WASHMail wasn't a full MIME implementation when I used it.
06:09:37 <bringert> Peter doesn't like type signatures, does he?
06:09:49 <bringert> shapr: do you remember what was missing?
06:11:42 <lightstep> @docs wash
06:11:43 <lambdabot> wash not available
06:12:13 <shapr> Not really. I used it to snip content out of singlepart mime emails, but I had some sort of problems with multipart. I think maybe the multipart support was fragile in several ways.
06:12:43 <shapr> Too bad there's not yet a unit test culture in the Haskell world.
06:12:48 <shapr> It's getting better though :-)
06:12:56 <shapr> Unit tests are geek docs.
06:13:53 <lightstep> it should be really simple to parse email messages lazily
06:14:12 <bringert> from RFC2045 (MIME): "In particular, compatibility was always favored over elegance."
06:14:14 * Igloo updates his newcgi repo and finds it infested with tabs again
06:14:15 <bringert> great
06:14:18 <lightstep> (though i never read rfc822 and such)
06:14:25 <bringert> sorry Igloo
06:14:29 <Igloo> :-)
06:14:36 <Igloo> You haven't uncommented the undecidable instance, BTW
06:14:43 <bringert> right
06:15:00 <bringert> I was playing with it, trying to be clever
06:15:08 <bringert> didn't succeed
06:15:17 <Igloo> Oh, I misread the patch
06:15:37 <Igloo> Sorry, I thought "Added -fallow-overlapping-instances for the MonadTrans -> MonadCGI instance" meant you'd added it to the requirements for the module
06:16:06 <Igloo> In fact, I completely misread it, because it was overlapping rather than undecidable you were talking about  :-)
06:16:06 <bringert> ah, no
06:16:33 <bringert> hmm, why does emacs use tabs? I have (setq indent-tabs-mode nil)
06:16:40 <bringert> does haskell mode turn tabs back on?
06:17:04 <shapr> I hope not, that would suck.
06:17:07 * shapr stabs tabs
06:17:29 <Igloo> I doubt cleverness is possible as it's essentially an instance of the '"default instance" declaration' rationale for undecidable instances in http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#undecidable-instances
06:18:40 <bringert> maybe some kind of Oleg-like trick with fundeps?
06:18:54 <bringert> probably not though
06:18:55 <shapr> ooh, an Oleg trick.
06:19:15 <Igloo> Why have you kept the io function, OOI? Backwards compatibility?
06:19:22 <shapr> C'mon, an Oleg worth of type trickery can solve just about anything.
06:20:18 <bringert> Igloo: yeah
06:20:35 <bringert> not that there is a lot of code use the module yet
06:20:35 <Igloo> It might be worth having a {-# DEPRECATED io "use liftIO instead" #-} (or whatever the syntax is) in there, then
06:20:57 <bringert> I like having a short name for it, but I guess it's pretty useless
06:21:16 <bringert> I think I could just remove it, the module is clearly marked experimental
06:21:23 <Igloo> True
06:21:52 <bringert> I think about the only thing relying on it is my FastCGI module
06:24:55 <shapr> privet bringert
06:24:58 <bringert> hmm, I think NewCGI should reexport liftIO
06:25:12 <bringert> dobryj den shapr
06:25:17 <shapr> :-)
06:25:30 * shapr bounces cheerfully
06:25:34 <bringert> or is that stupid?
06:25:57 <shapr> I have the urge to pick up a slavic language.
06:26:40 <bringert> Igloo: another reason to keep io is that then users will find it in the haddock for NewCGI
06:26:59 <bringert> but I think I'll remove it for elegance
06:27:13 <Igloo> I don't have strong feelings either way
06:35:15 <bringert> Igloo: where are the tabs
06:36:08 <bringert> don't know how they get there
06:36:15 * bringert doesn't know much about emacs
06:36:38 <Igloo> The first one is on line 129, whose text is "Handle -- ^ Handle that input will be read from"
06:37:44 <bringert> hmm, must be haskell mode that does it
06:37:50 <bringert> or am I being stupid
06:38:00 <shapr> haskell-mode does man strange things.
06:38:02 <shapr> many
06:38:26 <shapr> Like leaving the point in weird places when indenting.
06:38:36 <xerox> Awfully right.
06:40:40 <shapr> hiya sunym
06:40:56 <sunym> hi shapr
06:41:01 <shapr> How's code?
06:41:18 <bringert> hmm, looks like haskell-mode uses tabs in comments, and spaces in code
06:41:39 <sunym> ?
06:41:57 <shapr> sunym: Well, if code is life, then asking "how's code?" is the same as "how's life?" right?
06:42:21 <shapr> bringert: that's bizarre.
06:42:50 <sunym> oh,great
06:43:14 <bringert> I'm probably wrong, but that seems to be it. what do you guys use to not have that problem?
06:43:18 * ski confesses he's at times pasted in tabs before comments ..
06:43:35 <bringert> could someone verify that that's what's actually happening?
06:43:37 <Philippa_> bringert: another editor? :-)
06:43:42 <bringert> :-)
06:43:53 <shapr> bringert: gnumacs or xemacs? what version of haskell-mode?
06:44:16 <bringert> normal emacs, haskell mode 1.45
06:44:35 <shapr> I'd suggest upgrading to haskell-mode 2.0
06:44:39 <ski> (as to why .. to get things easily aligned, even if not first non-whitespace on line)
06:44:57 <bringert> ah, cool, didn't know it existed
06:47:16 <musasabi> Can epigram be used for practical purposes?
06:47:45 <shapr> Ask Conor :-)
06:47:55 <Philippa_> not the last I heard, but that was a while back
06:47:58 <shapr> I vaguely recall that IO was a problem, but I'm not sure if that's changed.
06:48:11 <shapr> Or ask edwinb, who did some (much?) of the epigram implementation.
06:48:19 <Philippa_> I wouldn't be surprised if they were concentrating on things other than IO and built-in types though
06:48:45 <Philippa_> or I could knock on the relevant doors tomorrow as I'm going to be seeing my tutor anyway?
06:48:59 <bringert> aahh, haskell mode 2.0 fixes the problem
06:49:06 <shapr> yay
06:49:07 <bringert> now to find the stupid tabs
06:49:20 <bringert> is there a simple way to highlight tabs in emacs?
06:49:40 * musasabi just wants to play with a nice system where types are equal to proofs.
06:50:03 <ski> bringert : you could search for them ..
06:50:15 <shapr> bringert: yes, lemme try to remember..
06:50:17 <ski> musasabi : ?
06:50:28 <shapr> It's M-x whitespace- something
06:50:51 <shapr> It turns spaces one color and tabs another color.
06:50:52 <sunym> highlight tabs in emacs,i think that must be awkward
06:51:26 <shapr> There are also save-hooks you can add to remove trailing whitespace, warn about saving tabs, etc
06:51:55 <bringert> I found M-x untabify
06:52:59 <musasabi> ski: types seem just one kind of assertion about the program - I am looking at a system which mixes different kinds of assertions together into a whole.
06:53:34 <bringert> Igloo: ok, tabs fixed and io removed
06:53:47 <shapr> Programatica does some of that, it has a 'certificate'(?) that can be QuickCheck, HUnit, Alfa proof, or something else.
06:53:48 <ski> musasabi : ok  (looked like you misquoted curry-howard)
06:54:06 <shapr> Speaking of which, why aren't there any proof-oriented programming tools?
06:54:11 <Igloo> Cool, thanks  :-)
06:55:00 <shapr> musasabi: I wonder if Epigram could do QuickCheck properties as types :-)
06:57:37 <musasabi> shapr: I think such checks should be the same kind property of a value as a type is.
06:58:17 <shapr> iirc, functions and types don't have much difference in Epigram.
06:58:25 <musasabi> shapr: but with types each value is associated with one property (namely the type). In this system it would have a set of properties.
06:59:04 <shapr> Oh, hm.
06:59:14 <ski> musasabi : in which system ?  the one you imagine ?
06:59:30 <musasabi> yes.
06:59:44 <Philippa_> sounds like you just want a type-level "and"
07:00:36 * ski has imagined about system where types are like single-arity preds, and you can have multi-arity ones, like e.g. one saying that two lists has the same length
07:02:03 <musasabi> Philippa_: just having a type-level and would make the types unbearably long in practise - the system would need some refinement.
07:06:22 <shapr> Man, it's hard to find interesting mailing lists and websites these days. Neither ll1-discuss nor LtU are particularly inspiring.
07:07:18 <musasabi> e.g. for subtraction one has normally subtract :: Num n. n -> n, but adding also "subtract x y == y + (subtract x y)". Of course such properties are not interesting to writte into type signatures but they are very ncie to automatically new definitions.
07:07:19 <shapr> Maybe I'm not looking hard enough.
07:07:52 <musasabi> *nice to automatically check new definitions.
07:08:15 <shapr> I wish typeclasses had a place to add such properties.
07:10:28 * shapr reads PCL
07:12:07 <xerox> Nice book!
07:13:04 <shapr> PCL stands for Pure Concatenative Language in this case.
07:13:51 <thedward> here it is a library
07:13:59 <ski> shapr : url ?
07:14:07 <thedward> so reading the PCL sounds quite daunting to me. :)
07:14:20 <shapr> ski: It's not released yet.
07:14:38 <thedward> what are other concatenative languages besides (secret) joy?
07:14:40 <ski> shapr : is it a book ?
07:14:53 <ski> shapr : paper ?
07:15:03 <tomdavie> I just found the USPS's page on how to pack a hippo
07:15:05 <shapr> thedward: There are quite a few that are somewhat concatenative like Factor, J, K, etc
07:15:17 <shapr> ski: None of those yet :-)
07:15:38 <shapr> thedward: Of course, PostScript and Forth are concatenative.
07:15:42 * thedward adds to his google queue
07:15:49 <ski> shapr : would you mind telling what it is ? :)
07:16:22 <ski> XY, also, i think
07:16:23 <shapr> ski: It's a partial investigation into a typed version of Joy.
07:16:42 <ski> shapr : musasabi's ?
07:16:46 <shapr> yes
07:19:37 * shapr boing happily
07:19:52 * ski finds Finite-State Non-Concatenative Morphotactics, Kenneth R. Beesley and Lauri Karttunen
07:20:20 <ski> now i just wonder what Morphotactics is .. :)
07:20:29 * shapr has no clue
07:20:41 <shapr> musasabi: Is Lauri Karttunen related to you?
07:22:12 <ski> (hmm, it mentions the word "transducer" .. does anyone know what a transducer is ?)
07:22:26 <musasabi> shapr: no, I don't think so.
07:22:30 <ski> (i have encountered it before)
07:23:38 <shapr> @wn transducer
07:23:40 <lambdabot> *** "transducer" wn "WordNet (r) 2.0"
07:23:40 <lambdabot> transducer
07:23:40 <lambdabot>   n : an electrical device that converts one form of energy into
07:23:40 <lambdabot>    another
07:23:50 <shapr> Not sure what that means though.
07:26:30 <ski> http://www.cse.ogi.edu/~jl/wg2.8/Harrogate.html#Shivers
07:27:07 <ski> (that's where i've seen it before)
07:27:35 <Tue5372> electrical energy into movement...would that classify as a transducer :P
07:27:44 <Tue5372> or vice versa
07:29:35 <xerox> Bye bye.
07:30:37 <ski> bye xerox
07:31:34 <shapr> cya xerox
07:34:51 <Igloo> Is Peter Simons here?
07:35:12 <shapr> He's peti when he's here.
07:35:40 <Igloo> OK, ta
07:36:33 <Igloo> Can anyone confirm or deny you can't do case (x :: CInt) of in cvs ghc any more?
07:37:17 <musasabi> Igloo: if you have a complete example I can try.
07:38:10 <Igloo> case 5 :: Foreign.C.CInt of 5 -> 'x'    in ghci should do it
07:40:21 <musasabi> works.
07:40:28 <Igloo> Thanks
07:40:32 <Igloo> How up-to-date is that?
07:40:34 <musasabi> This was ghc-6.5.20050714.
07:40:43 <Igloo> OK, thanks
08:06:13 <CosmicRay> morning metaperl
08:06:27 <metaperl> CosmicRay: good morning
08:23:08 <shapr> JaffaCake: Do you think non-stop GC is easily parallelizable?
08:23:22 <JaffaCake> no.  next question :)
08:23:45 <shapr> There's an interesting thread on ll1-discuss about multi-core capable languages... I'm tactfully advertising your paper, of course :-)
08:23:59 <JaffaCake> oh thanks :)
08:24:07 <JaffaCake> I should get on that mailing list
08:24:45 <shapr> It's occasionally interesting, same for LtU. Not much else is though. (outside of the Haskell mailing lists, which are often interesting).
08:25:15 <JaffaCake> I'm not confident that we could make a GC that runs in parallel with the mutator, and make it fast
08:25:40 <JaffaCake> I do read LtU, but I tend to skim the discussions
08:25:50 <shapr> Personally, I'm interested in something that will scale to hundreds of cores, I think that's coming sooner than most language communities expect.
08:26:23 <shapr> Not that I have enough clue to suggest anything that will scale that well.
08:27:05 <JaffaCake> memory bandwidth will be the bottleneck for sure... with 100s of cores, I'm not sure a single memory bus still makes sense
08:27:07 <shapr> Do you think SMP GHC will end up having parallel GC?
08:27:16 <JaffaCake> probably, yes
08:27:28 <shapr> I have an idea to fix the memory bottleneck, not that anyone will listen to me :-)
08:27:45 <shapr> It also increases yield per die...
08:27:47 <ski> musasabi : ping
08:27:49 * genneth will
08:27:51 <musasabi> pong
08:27:56 <JaffaCake> go on?
08:28:14 <autrijus> hey JaffaCake. sorry I got caught up in $work
08:28:16 <ski> musasabi : why GADT in hawiki/CodeExamples ?
08:28:26 <JaffaCake> autrijus: hiya
08:28:34 <shapr> Basically, use a 'quilt' of cpu and memory/cache on each die, with interconnects on all sides. Have you seen the floor tiles that are hexagons with squares between them?
08:28:38 <autrijus> JaffaCake: I wonder if glibc prevented the bug from manifesting to you
08:29:06 <autrijus> but this is just a wild guess without any rational evidence
08:29:12 <genneth> shapr: transputer style?
08:29:14 <shapr> If you want small cpus and big local memory, make the hexagons the memory and the squares the cpus, and put interconnects on all sides.
08:29:23 <shapr> genneth: Yeah, but more like the Cell taken to extremes.
08:29:28 <JaffaCake> autrijus: I don't know, but I also tried it on my FreeBSD 4.11 box which doesn't have glibc
08:29:36 <genneth> shapr: the latest blue gene stuff does it that way
08:29:45 <autrijus> JaffaCake: riight. hopefully I'll get timeslices tomorrow
08:30:01 <genneth> shapr: doesn't really make a great shared-memory system however, which makes a lot of things harder
08:30:28 <JaffaCake> that'd be great... 6.4.1 will be in a few weeks, it'd be nice to nail this one before then
08:30:29 <CosmicRay> ok, so I am thinking of making Haskell bindings to gnutls and CDK (Curses Development Kit)
08:30:31 <CosmicRay> where can I find info on how to make FFI play nice with I/O?
08:30:34 <CosmicRay> and threads?
08:30:43 <musasabi> ski: because it was more readable - the code came from an other thing which was GHC specific anyways.
08:30:55 <musasabi> ski: but feel free to change it if you want.
08:30:55 <CosmicRay> (specifically, how to make FFI calls into gnutls not starve other threads that have used forkIO)
08:31:07 <shapr> That'll increase die yield in several ways. First of all, more hexagons of the same area fit onto a circular die than squares of equal area. Second of all, if everything is interconnected you don't saw them apart, you just sell the die whole, and price it by the number of cores, memory banks and interconnects that work.
08:31:11 <autrijus> JaffaCake: oh, I saw on the wiki that the GHC.Unicode fix is _not_ in 6.4.1
08:31:16 <autrijus> is that true?
08:31:30 <JaffaCake> CosmicRay: use -threaded, and declare any foreign calls that may block as "safe"
08:31:42 <autrijus> I had hoped I can ditch the horrible hack of bundling GHC.Unicode with Pugs
08:31:48 <CosmicRay> JaffaCake: that easy, eh?
08:31:54 <CosmicRay> wow.
08:32:02 <JaffaCake> autrijus: I changed my mind and put it in
08:32:03 <shapr> genneth: How does shared memory fit in?
08:32:04 <CosmicRay> where's the catch? ;-)
08:32:13 <autrijus> JaffaCake++ # mind-changer
08:32:20 <CosmicRay> heh
08:32:28 <JaffaCake> lol
08:32:36 <genneth> genneth: i've always found that non-shared memory concurrency is harder to program for; you basically need to connect up the elements manually, which doesn really scale
08:32:37 <autrijus> JaffaCake: maybe take a few secs to update http://haskell.org/hawiki/GhcUnicode then?
08:32:49 * JaffaCake takes a look
08:32:49 <autrijus> I don't know enough to fix dgolubovsky's writeup 
08:33:04 <CosmicRay> that brings up another question.  I have a library that I build with cabal.  Should I really be building n versions of the library, with different permutations of threading and profiling options?  If so, is there an automated way to do that?
08:33:07 * genneth meant to start that with shapr:
08:33:17 <CosmicRay> what happens if someone uses a library not build with -threaded in a threaded program?
08:33:33 <CosmicRay> and vice versa?
08:33:39 <shapr> genneth: If you use the immutable approach, it's not hard at all.
08:33:42 <JaffaCake> autrijus: he knows what the situation is, I'll ask Dimitry to update it
08:33:42 <CosmicRay> and does the answer depend on whether said library is pure haskell?
08:33:56 <musasabi> JaffaCake: did you get the NetBSD account (for ghc autoconf testing?) you needed sometime ago?
08:34:16 <ski> musasabi : mhm ..
08:34:27 <JaffaCake> musasabi: I don't remember, sorry
08:34:31 <genneth> shapr: i'm not following
08:34:39 <autrijus> JaffaCake: cool, thanks!
08:34:48 <shapr> genneth: NUMA needs cache coherency because memory can be changed in place. If you don't do that, there aren't any problems.
08:34:57 <JaffaCake> CosmicRay: -threaded doesn't affect the code you build, only the RTS it gets linked with
08:35:04 <CosmicRay> ok.
08:35:06 <JaffaCake> CosmicRay: unlike -prof
08:35:09 <shapr> That also gives you other speedups because short lived cells never leave the cache.
08:35:43 <shapr> genneth: Basically, take the Haskell approach to memory management, and apply that to hardware.
08:35:54 <genneth> aahh...
08:36:06 <genneth> that is interesting
08:36:19 <shapr> I thought that up myself, but I'm not the first person to think along those lines.
08:36:29 <shapr> Henry Baker has some really cool writings on GC.
08:36:45 <genneth> i suppose if you're using something like haskell, it could be mapped very easily
08:37:07 <genneth> though lots of "normal" algorithms wouldn't work as efficiently
08:37:15 <Igloo> JaffaCake: Oh, BTW, someone in #darcs was wishing for a FBSD amd64 ghc. Do you plan to make one?
08:37:24 <shapr> genneth: http://home.pipeline.com/~hbaker1/
08:37:28 <shapr> genneth: Whyso?
08:37:44 <JaffaCake> Igloo: I don't have a box, but it should be an easy port
08:37:47 <genneth> shapr: in-place sorting...
08:38:17 <shapr> genneth: iirc, 10 to 13 percent of the raw hardware speed is spent keeping the caches coherent with only two CPUs, I think it might be worth the benefit.
08:38:34 <ski> musasabi : btw, re mfix laws, http://www.haskell.org/hawiki/FixedPointCombinator
08:38:37 <shapr> With a large enough cache, you get the same effect as in-place sorting.
08:38:42 <Igloo> JaffaCake: OK, ta
08:38:46 <musasabi> ski: thanks.
08:39:16 <genneth> shapr: indeed; i'm just thinking that it would need some sufficiently different algorithms being applied; not a problem, of course
08:39:34 <autrijus> JaffaCake: define easy port?
08:39:37 <shapr> Each memory 'chunk' can be GC'd separately, and it's more like having layers of transactions, GC on L1 cache will cascade data to the L2 cache, and L2 cache will cascade to main memory.
08:40:03 <autrijus> (I have a fbsd amd64 and I can share a ssh account -- actually tobez@freebsd.org (Gruber on freenode) may have one as well)
08:40:12 <JaffaCake> autrijus: as in very little patching required, just boring bootstrapping stuff
08:40:13 <genneth> shapr: on that page you linked.... "thermodynamics of garbage collection"?! i'm loving that from a physicist point of view
08:40:39 <shapr> Henry Baker is awesome, check out his waste of bandwidth page: http://home.pipeline.com/~hbaker1/gratuitous.html
08:40:43 <genneth> autrijus: i can voluteer a linux amd64 box too
08:41:14 <JaffaCake> autrijus: I might be tempted to take you up on that... amd64 gives me a warm fuzzy feeling
08:41:23 <Igloo> :-)
08:41:28 <CosmicRay> autrijus: do you have amd64 running on freebsd presently?  someone is asking about it in #darcs
08:41:31 <autrijus> JaffaCake: sure... give me a .ssh/authorized_key :)
08:41:35 <autrijus> CosmicRay: I do
08:41:39 <autrijus> autrijus.org is that
08:41:42 <genneth> shapr: that paper is wonderful! it's in my native language!
08:41:45 <autrijus> and it annoys me I can't run pugs there.
08:42:08 <CosmicRay> autrijus: have you posted the binaries anywhere?
08:42:24 <autrijus> CosmicRay: I have amd64 running on freebsd
08:42:32 <autrijus> I do not have ghc running on amd64 running on freebsd ;)
08:42:33 <shapr> genneth: Anyway, I have a whole separate timeline running in my brain that involves Haskell being the most efficient language for existing hardware.
08:42:39 <CosmicRay> autrijus: ah.
08:42:42 <ski> shapr : :)
08:42:53 <shapr> Now I just have to change the future!
08:43:18 <ski> shapr : not change. declare
08:43:25 <shapr> Ah right!
08:43:56 <shapr> Funny thing is that this alternate future will make for more efficient computers in general.
08:44:16 <autrijus> but in that future, a black monolith will be discovered on the moon
08:44:23 <autrijus> and robots will turn into dirty cops.
08:44:40 <shapr> Happily, we have garbage collection, and white paint.
08:44:53 <autrijus> "How will your Bots take advantage of the new imperative nature of the formerly functional Utopian society? Will they thrive, or can they merely survive?"
08:44:58 * shapr paints the monolith a pretty color.
08:45:11 <CosmicRay> http://cgi.ebay.co.uk/ws/eBayISAPI.dll?ViewItem&item=5789263206&rd=1&sspagename=STRK%3AMEWA%3AIT&rd=1
08:45:15 <CosmicRay> speaking of the monolith.
08:45:40 <pejo> shapr, will you be around on irc this evening?
08:45:45 <shapr> pejo: maybe, why?
08:45:52 * Enveigler_ thinks copying GC is like gas-guzzling cars. Environmentally unsound. Don't discard--Re-use :)
08:46:34 <shapr> I wonder why no one has thought of changing the unit shape of cpus to fit more onto a die. It seems pretty obvious.
08:46:42 <pejo> shapr, just saw the discussion, but I have to work for a while for the moment. :-)
08:46:46 <shapr> Ah, ok :-)
08:47:01 <shapr> Sure, dump your response here and I'll see them at some poin.t
08:47:14 <pejo> shapr, about CPU shapes: wasn't that slashdotted today? Some rpi.edu-guy using 3d.
08:47:19 <shapr> I dunno
08:47:59 <shapr> Oh that's different.
08:48:00 <pejo> shapr, "Researchers create 3-dimensional chips" - http://hardware.slashdot.org/hardware/05/07/18/2216225.shtml?tid=126&tid=137
08:48:16 <shapr> It's a good idea, but a different idea.
08:49:03 * JaffaCake thinks 2-dimensional chips would be a neat trick
08:49:26 <shapr> I think something equally interesting would be tetrahedrons with optical couplers on the inside and chips on the outside. You'd get a higher density of interconnects with existing technology.
08:49:33 * genneth wonders how a relativistic 4d chip would get digested
08:49:38 <ski> autrijus : http://www.minusvisionen.de/images/Kubrick%20Monolith.jpg ?
08:49:42 <shapr> genneth: They sort of exist already.
08:49:56 <autrijus> ski: rather, http://icfpc.plt-scheme.org/
08:50:38 <genneth> shapr: there's a project by ibm storage guys making cubes of harddisks, with 6 capacitative pads; you stack 'em and get a big castle of highly redundant (in many ways) storage
08:50:38 <shapr> Rapid Single Flux Quantum ICs can teleport bits to different parts of the chip.
08:51:00 <ski> autrijus : mwuahaha
08:51:16 <shapr> That's the way to get real connectivity, forget about wires and just teleport the bits :-)
08:51:49 <shapr> genneth: I'd like to extend that idea to computers in general, I think I've told you before?
08:52:02 <genneth> i don't think so
08:52:23 <shapr> You'd never run out of PCI slots if computer components tiled in 3D.
08:52:36 <shapr> You'd also be able to run out and buy another CPU, more RAM, another drive, etc
08:53:30 <shapr> Not that operating systems can support that yet. Linux is closest.
08:53:40 <genneth> i think that's where the ibm push for "grid" is going
08:54:09 <genneth> lots of little computers, not necessarily homogenous, and software that will use any available hardware
08:54:13 <shapr> I think that's where computers should be going in general.
08:54:31 <shapr> I want to write a program and have it automagically scale to the limits of the algorithm, not the limits of the hardware I own right now.
08:55:51 <genneth> I think massive concurrency is still a problem without workable solution
08:55:59 <genneth> and i think i'm going to miss my bus
08:56:09 <shapr> I've thought about processing 'chunklets' too, where you buy a twenty dollar endotherm chempack from a nearby vending machine, and once you have a big computation set up, push the button to freeze your laptop CPU
08:56:46 <shapr> This is why I never get anything useful done, too many fun things to think about :-)
08:57:39 <KrispyKringle>  /quit
08:57:41 <KrispyKringle> doh
08:58:07 <CosmicRay> shapr: tsk!  that sounds interesting ;-)
08:58:47 <shapr> CosmicRay: which one?
08:59:13 <CosmicRay> shapr: the freezing the cpu thing
08:59:24 <shapr> Oh, yeah I think that one would be neat.
08:59:44 <shapr> It'd be reusable too, just put the used chempak back into the vending machine when done.
09:00:08 <CosmicRay> maybe there should be liquid nitrogen dispensers.
09:00:37 <shapr> They're not very portable.
09:00:46 <ski> (hm, seems there's a black monolith in 2001: A Space Odyssey)
09:00:47 <shapr> That's why I decided on a chempack.
09:01:01 <CosmicRay> shapr: you *have* put some thought into this :-)
09:02:14 <shapr> Another possibility is to run RSFQ circuits on the desktop, and plain old silicon for portable hardware.
09:06:23 <ski> (apparently there's a black monolith in Seattle)
09:07:05 <shapr> CosmicRay: There is a really crazy solution I've thought of that involves heat semiconductors, but I've never found anything like tat.
09:07:38 <shapr> If you happen to discover some material that only conducts heat in one direction, I've thought of some very cool tech that it would allow.
09:17:22 <Lemmih> Good morning, SyntaxNinja.
09:17:25 <shapr> Why would Neel Krishnaswami say that mutability affects automatic parallelization possibilities?
09:18:55 <shapr> http://article.gmane.org/gmane.comp.lang.lightweight/3632
09:19:19 <shapr> Why would heavy use of mutation affect automatic parallelization?
09:20:21 <shapr> Oh, I think I understand.
09:20:32 <musasabi> Because it makes harder to figure out valid execution schedules?
09:21:01 <shapr> Yeah, I think he's saying that the current implementation doesn't lend itself well to automatic parallelization.
09:22:21 <shapr> I hadn't realized that call-by-value will make automatic parallelization work out nicely.
09:22:57 <shapr> Makes perfect sense once you think about it though.
09:24:07 <araujo> Hello
09:24:09 <araujo> Is this the channel to ask about the haskell language?
09:24:24 <tomdavie> if you like
09:25:07 <shapr> araujo: do you have a Haskell question?
09:25:35 <araujo> Yes i do.
09:25:41 <araujo> What is haskell? :-]
09:25:54 <tomdavie> hehe... it's a beautiful pure functional language
09:26:02 <tomdavie> with strong typing and lazy evaluation
09:26:06 <tomdavie> did I miss anything?
09:26:27 <KrispyKringle> Probably better if you check the main page of http://www.haskell.org/ :)
09:26:44 <shapr> Oh, it has Simons too. Lots of them.
09:26:55 <tomdavie> that's a good point to make
09:27:01 <tomdavie> lots of simons and a colin
09:27:34 <araujo> haha
09:27:52 <ski> also with static but inferred typing
09:29:22 <kaol> dpkg's source code is ugly. I'd so like to rewrite it in haskell... if only time and other constraints didn't prevent me from doing that.
09:29:44 <shapr> Go for it!
09:30:21 <kaol> and as a problem domain it seems to fit snugly into what haskell is good at
09:30:33 <tomdavie> force everyone running debian to have ghc!!!!
09:30:34 <tomdavie> *g*
09:30:37 <vegai> kaol: "Awym
09:30:40 <vegai> kaol: "Awv
09:30:43 <vegai> oh bugger
09:30:52 <vegai> kaol: "Anything"? =) I tried to type
09:31:19 <kaol> tomdavie: force? isn't ghc a compiler?
09:31:41 <kaol> what'd they need ghc for to run it?
09:31:46 <tomdavie> yes... but if you start writing dpkg in haskell they'll need ghc
09:31:53 <tomdavie> ... or nhc, but hay
09:31:56 <tomdavie> hey*
09:32:04 <tomdavie> some sort of haskell compiler
09:32:10 <kaol> few people are about to hack on dpkg, only use it
09:32:24 <tomdavie> yes... but debian is source only
09:32:35 <kaol> no it isn't, you're thinking of gentoo
09:32:43 <tomdavie> they both are IIRC
09:32:47 <edwinb> debian isn't
09:32:55 <tomdavie> oh... okay, I thought it was
09:33:02 <KrispyKringle> No. .debs are binaries.
09:33:02 <shapr> Debian is mostly binary.
09:33:03 <edwinb> I'm using it now, and I'm far too lazy to compile everything...
09:33:08 <tomdavie> heh
09:33:18 <tomdavie> to be fair... gentoo is as easy as debian
09:33:28 <tomdavie> s/apt-get/emerge/
09:33:28 <edwinb> Maybe it could use ghci to load packages dynamically though ;)
09:33:41 <shapr> Right, dpkg that uses hs-plugins .
09:33:45 * shapr grins evilly
09:33:48 <tomdavie> hehe... *g*
09:34:09 <tomdavie> so... you want everyone to get ghc *before* dpkg?
09:34:17 <edwinb> I suppose you'd have to...
09:34:19 <tomdavie> note... ghc from source is *hard*
09:34:38 <shapr> It's easy on debian.
09:34:55 <tomdavie> doesn't that rely on dpkg though?
09:35:03 <edwinb> How do you think dpkg gets installed?
09:35:07 <shapr> Debian doesn't build everything from source.
09:35:20 <shapr> The installer installs binary debs.
09:35:26 <tomdavie> yes... but if dpkg relies on running haskell code dynamically
09:35:31 <tomdavie> you need ghc before it
09:35:46 <shapr> Right, so you'd install a binary deb.
09:36:00 <kaol> sigh... maybe I'll just try to fix this one bug now and not start refactoring it into a haskell implementation.
09:36:05 <tomdavie> okay... so you just grab a binary ghc?
09:36:36 <shapr> You don't have to build anything from source with Debian. Never, if you're fine with the available packages.
09:36:54 <edwinb> I've hardly ever found anything that isn't packaged for debian.
09:36:55 * shapr stabs gnumacs
09:37:03 <edwinb> Just weird stuff...
09:37:50 <tomdavie> heh... btw... anyone know why 99% of Haskell stuff is hard-masked in portage?
09:38:01 <tomdavie> (everything but ghc I think)
09:38:38 <tomdavie> I know it all works... I've got a gentoo box running with pretty much every haskell package I could think of... but none of it installed with emerge
09:39:27 <KrispyKringle> tomdavie: as in, the're in package.masks?
09:39:39 <KrispyKringle> not just masked by arch?
09:39:46 <tomdavie> pass... as in if you try to emerge them it tells you they're hard masked
09:39:50 <tomdavie> in big red letters
09:39:52 <SyntaxNinja> hi Lemmih
09:40:24 <Lemmih> SyntaxNinja: I've finished the installer script for cabal-get.
09:40:24 <shapr> JaffaCake: Hey, is it possible that a blocked thread in SMP GHC could have another thunk to eval?
09:41:27 <KrispyKringle> tomdavie: ah. well, things are usually so due to security bugs, stability issues, known problems...
09:41:40 <KrispyKringle> Ask the maintainer. Or search bugzilla for relevant bugs.
09:41:46 <KrispyKringle> You can always contribute updated ebuilds ;)
09:41:58 <tomdavie> indeed
09:42:03 <shapr> JaffaCake: At first glance it seemed that call-by-need would always have only one thunk in front, but then I thought about something like (const 1 2 + const 1 3). Those const calls seem to be two equal thunks. Am I confused?
09:42:11 <tomdavie> but I can't even be arsed to do fink packages
09:42:26 <tomdavie> so to do gentoo ones too would be rather extravagant
09:44:57 <KrispyKringle> tomdavie: sure. I'm lazy, too. :P
09:57:35 <Beelsebob> evening again
09:59:00 <ski> (shapr : btw, wanted that link on signal functions and comonads ?)
09:59:05 <shapr> sure
10:00:18 <ski> http://types2004.lri.fr/SLIDES/uustalu.pdf
10:00:27 <ski> (it's slides)
10:00:43 <ski> (abstract : http://types2004.lri.fr/abstracts/abstract7.txt)
10:04:49 <shapr> JaffaCake: Do you think Ennals' speculative evaluation would improve the performance of the average SMP GHC binary?
10:04:51 <ski> hmmm, wonder if Alberto Pardo and Varmo Vene know about each others work ?  (http://plc.inf.elte.hu/cefp/vene.html)
10:05:48 <ski> (hm, s/Alberto Pardo/Tarmo Uustalu/, and it seems they do)
10:05:57 <lispy> speculative evaluation?  is that sort of like it's not always as lazy as it can be?
10:06:22 <shapr> Wow, Uustalu says comonads can replace arrows for signal processing?
10:06:32 <shapr> Ok, time to learn about comonads.
10:06:38 <shapr> lispy: right, exactly.
10:06:48 <ski> shapr : :)
10:06:58 <lispy> heh, i feel so behind (i'm still learning monands and arrows aren't even on the list yet)
10:07:04 <shapr> Uustalu must be either Estonian or Finnish.
10:07:33 <shapr> lispy: s'okay, you know stuff I don't know, at some point I'll say "gee what's X" and you'll say "Oh, I know all about those."
10:07:34 <ski> Estonian
10:07:47 <shapr> Well all learn from each other.
10:08:09 <lispy> shapr: heh, but you never ask me about inline skates ;)
10:08:38 <shapr> I may, I own a pair.
10:08:47 <shapr> Haven't used them much since I got into unicycling though.
10:09:00 <lispy> ah, recreation, aggressive, speed or hockey?
10:09:11 <lispy> unicycling could be fun
10:09:55 <lispy> i'd like to play more hockey, but i'm afraid of injuries and i'm not that interested in joining a league just to learn to play
10:10:17 <shapr> You could try unicycle hockey.
10:10:24 <lispy> oh!
10:10:50 <lispy> i've seen donkey basketball, i have a feeling unicycle hockey would be of a similar challenge
10:11:01 <shapr> What's donkey basketball?
10:11:13 <lispy> the players all ride donkies
10:11:30 <shapr> Wow, scary.
10:11:51 <lispy> when i was in the 4th grade our teachers put on a donkey basketball match between themselves as a fund raiser :)
10:12:13 <shapr> That's bizarre.
10:13:13 <lispy> it adds a fair bit of choas to the game
10:13:26 <shapr> lispy: http://enhjulingsfolket.se/img/photos.big/emil.jpg
10:13:51 <lispy> nice, so it is a real game
10:14:30 <lispy> is anyone going to VL/HCC this year?  If so it would be nice to meet #haskell denizens in person
10:15:31 <lispy> i think i was stood up for a phone meeting...
10:16:24 <shapr> I'll call you, what's your number?
10:16:28 <lispy> heh
10:16:40 <Lemmih> VL/HCC?
10:17:12 <lispy> Lemmih: visual languages and human centric computing, iirc
10:18:16 <lispy> it's in Texas this year :(
10:18:31 <SyntaxNinja> does anyone know how to turn off page numbering w/ the acm sigplan template?
10:18:53 <SyntaxNinja> nm
10:19:09 <lispy> Lemmih: http://viscomp.utdallas.edu/vlhcc05/
10:23:29 * Igloo does the hates-CSS dance
10:23:39 <lispy> CSS dance?
10:23:46 <lispy> you got invited?
10:23:48 <Speck> anyone know of a way to get gvim/win32 to send the current buffer to ghci?
10:23:49 <shapr> Is that where you jump up and down on your CSS book?
10:24:01 * Igloo fails to grok lispy
10:24:14 <Igloo> shapr: I'm sure it would be if I had one  :-)
10:24:37 <lispy> Igloo: sorry, it sounded like a formal dance....I didn't get invited to any dances.  Guess i'm not popular :)
10:25:22 * Speck fox-trots around CSS3 unsupported selector syntax
10:32:59 <Speck> nobody knows about vim/ghci interaction?
10:33:53 <Lemmih> Speck: Did you check the wiki?
10:34:22 <Speck> it says how to set up compiler support for ghc somewhere on there
10:34:28 <Speck> but that isn't exactly what I'm looking for
10:34:48 <thedward> Speck: how about :! ghci %
10:35:03 <Speck> oh... let me try
10:35:07 <thedward> that works under Linux in any case
10:36:01 <Speck> "empty file name for %" ?
10:36:09 <Speck> I guess I need to save it first
10:36:48 <Speck> but it would be nice to be able to use a reference to the actual buffer, so I could make little changes and reload without having to save
10:37:15 <lispy> ghci is actually pretty nice to work with outside of your editor
10:37:31 <lispy> it has tab completion on file names, and you can use :r to reload the file
10:37:57 <Speck> oh, darn. windows paths don't play nice with ghci (assuming Directory.setCurrentDirectory) because they delimiters need to be escaped
10:38:20 <Speck> though perhaps it's gvim's responsibility to escape them
10:38:48 <lispy> yeah, it seems like emacs/win32 converts paths as you use them
10:39:24 <lispy> s/\//\\/g
10:39:43 * lispy makes some vim art
10:40:03 <Speck> can I use that against the string sent by %?
10:40:10 <Speck> I'm not so good with vim
10:40:28 <lispy> no clue, i have about -><- much knowldge of the vi family of editors
10:40:59 <Speck> I should ask on #vim anyway
10:42:23 <lispy> actually, if they need to be escaped my search/replace isn't enough, you'd need s/\//\\\\/g or similar
10:43:19 <lispy> if there are spaces in the path name you may also need quote markes around the path
10:45:08 <Speck> yeah there are definitely spaces in the path name, but :cd C:\Path With\Spaces works
10:47:38 <Beelsebob> :o
10:47:40 <Beelsebob> how silly
10:48:20 <Speck> (um, it works if you escape the \)
10:54:55 <shapr> ski: That's interesting. I'll have to pick up more on comonads soon.
10:55:23 <ski> shapr : yep
10:56:08 <musasabi> How do comonads work without linear types?
10:59:18 <ski> just like monads do, i guess ?
10:59:51 <ski> musasabi : just because an OI-comonad requires linear types does not mean all comonads do
11:00:28 <Philippa_> it just means comonads doesn't support quite the same flavour of sequencing as monads
11:02:02 * Philippa_ still doesn't feel she's seen a good use for a comonad that didn't feel mind-bending (which may be insufficient time adjusting to them and perhaps lack of an equivalent to do notation)
11:04:43 <musasabi> So what would be an example where a comonad works well in Haskell?
11:04:57 <Philippa_> don't look at me :-)
11:05:37 <Philippa_> I sorta need to bidirectionalise some of my mental wiring to handle the idea properly, it's just not making sense for me
11:06:22 * musasabi thinks of it as pull vs push.
11:06:29 <shapr> Yeah, it looks the same to me.
11:06:43 <shapr> My first intuition is pulling a value out of an environment, for example.
11:07:05 <Philippa_> yeah, but it doesn't make any sense to me why I'd want to do that with a comonad instead
11:07:15 <ski> i think we haven't yet found out much how to use comonads
11:08:01 <shapr> From what Uustalo says, comonads have many of the advantages of arrows in certain situations.
11:08:11 <shapr> And none of the problems that arrows can have.
11:08:14 <ski> at least for signal processing
11:08:22 <Philippa_> in what way none of the problems?
11:08:35 <ski> i have no idea if comonads can be used for parsing, e.g.
11:09:42 <astrolabe> is there a state co-monad?
11:09:57 <ski> state-in-context comonad, it's called
11:10:01 <shapr> I think it's more an environment.
11:10:47 <Philippa_> yeah, I just don't get a good grip on how the info flow goes
11:10:52 <Philippa_> I mean, environment is a subset of state to me...
11:11:12 <shapr> Yeah, I know what you mean.
11:11:13 <ski> Philippa_ : i think shapr may be referring to that comonads are already recognized and known in CT, but we don't know exactly what an arrow is (rather, 'should be')
11:11:38 <Philippa_> I thought arrows corresponded closely to freyd categories?
11:11:55 <astrolabe> If monad and comonad can both be used for IO, maybe there is a generalisation of both that can be.
11:12:07 <ski> i think, for comonads to be more useful, people need to come up with useful intuitions
11:12:13 <shapr> Uustalo says that comonads are as basic and simple as monads, but arrows definitely aren't.
11:12:36 <ski> and this (Uusatalu and Vene) is a step towards that
11:12:52 <Philippa_> is this a new paper I've not seen?
11:13:01 <ski> slides
11:13:18 <ski> Philippa_ : http://types2004.lri.fr/SLIDES/uustalu.pdf
11:14:25 <ski> astrolabe : i think comonads can be used for IO, but i think it requires a uniqueness/linear typesystem (and Haskell doesn't have that .. but Clean does, hm :)
11:14:52 <Philippa_> which is a way of saying "they don't actively /prevent/ IO", as ordinary functions suffice given such a system...
11:15:27 <musasabi> ski: hakking uniqueness into GHC is trivial.
11:15:32 <musasabi> *hacking
11:16:15 <ski> i guess it's sortof a "lucky coincidence" that the IO monad don't require uniqueness/linear types
11:16:16 <ski> musasabi : you think so ?
11:16:16 <autrijus> as demonstrated by Hacle
11:16:45 <autrijus> oh, nvm, Hacle is the other way around.
11:16:53 <ski> yes
11:16:58 <Philippa_> ski: it's a bit more than luck. Monads support sequencing, that's why you don't need a type system capable of enforcing it for you
11:17:00 <autrijus> need Cleha
11:17:49 <musasabi> ski: there are already linear implicit parameters - linear non-implicit parameters should not be much harder.
11:18:19 <ski> Philippa_ : IO a  =  *World -> *(*World,a)  in Clean terms, it's just that with IO as an ADT in haskell, the linearity is happily hidden/contained inside the type, so we don't actually need a linear typesystem in haskell for IO (monad)
11:18:34 <musasabi> Of course there is the question with no monomorphism restriction and them interacting.
11:18:51 <ski> musasabi : but that's not the same, i think
11:19:12 <Philippa_> ski: I know
11:19:14 <ski> (also linear implicit parameters is unsafe, of course)
11:20:06 <Philippa_> I just consider this more-than-an-accident. Monads represent potentially-higher-order, potentially-sequenced computations. In a computing context, that's what they /do/. Oh look, it turns out computations-with-IO are such beasts...
11:20:07 <ski> Philippa_ : so apparently i don't understand your remark about monads supporting sequencing ..
11:20:29 <Philippa_> the basic monadic operations actively support the possibility of sequencing
11:20:57 <Philippa_> you don't really need to build it on top of the monad ops, there just happens to be a class of monads where the sequencing's irrelevant (commutative monads)
11:21:08 <ski> Philippa_ : they also, in the case of IO, actively prohibit discard or duplicate on the hidden state
11:21:50 <Philippa_> nope, they just don't offer it. It's plenty possible to have discarding and/or duplication in a state monad
11:22:03 <ski> with extra ops, yes
11:22:12 <ski> i was talking of the ones in monad class
11:22:18 <ski> hm
11:22:26 <Philippa_> yeah. But the monad laws aren't such that you can't build those ops and still have a monad
11:22:52 <ski> (so, i was prolly misrepresenting it a bit ..)
11:23:18 <ski> Philippa_ : you're correct (should have watched my words better :)
11:24:31 <ski> musasabi : i'm not sure how you'd get linearity by making implicit linear parameters explicit .. ?
11:24:43 <Philippa_> basically, that's the combination of features that leads me to think it's not so much an accident as monads being fundamentally the right structure. Nothing extra, nothing insufficient. OK, you might want the first-order-computations-only variant, but hey
11:25:27 <musasabi> ski: by issuing the error for Split in a lazy fashion?
11:25:49 <ski> Philippa_ : i guess the question must then be : being fundamentally the right structure for what ? :)
11:26:23 <ski> musasabi : error ??
11:27:47 <musasabi> ski: currently is just does a "split" (defined as a typeclass) if the parameters is used many times - instead of that issue an error if there is no such instance.
11:27:51 <Philippa_> ski: amongst other things, IO :-) But more generally, monads're a really good structure for semantics that feel like haskell-with-side-effects. The side-effects necessitate the sequencing, and it wouldn't feel like haskell if you only had first-order computations...
11:29:36 <Philippa_> (yes, I'm taking an insufficiently-general notion of 'side effects' here)
11:30:10 <ski> Philippa_ : there are other interesting monads, than state-based ones ..
11:30:40 <Philippa_> I'm fully aware. Most of them have some kind of notion of sequencing though, even if it's only evaluation dependencies
11:30:42 <ski> musasabi : you're suggesting giving that error at run-time somehow ??
11:31:43 <musasabi> compile time would be fine (if the variables are not polymorphic)
11:31:48 <ski> Philippa_ : i agree that the basic monads ops enforce what i like to call "logical sequencing" (as opposed to actual lowlevel sequencing)
11:31:54 <musasabi> but have to visit a friend ->
11:32:19 <Philippa_> ski: that's all I mean when I say sequencing. Same sense that monoids have sequencing.
11:32:20 <ski> musasabi : sorry, but just don't understand how this would relate to linear typesystems ..
11:32:22 <ski> musasabi : oki
11:32:35 <ski> Philippa_ : ok
11:33:04 <musasabi> ski: I'll try to explain later, but then I could be wrong too.
11:33:17 <ski> musasabi : ok, ty
11:33:41 <ski> sometimes i want a type class Monad m => MonadPar m where mpar :: m a -> m b -> m (a,b)
11:33:56 <ski> for doing effects (more or less) in parallel
11:36:12 <Philippa_> that's not a bad idea - sort of a more specific extension of whichever of the arrow classes it is
11:36:25 <Philippa_> oh, basic arrows, duh
11:36:48 <Philippa_> would you have any laws requiring some kind of "in parallel" effect?
11:39:14 <ski> well, of course the obvious laws with one of the input actions being pure
11:40:03 <Philippa_> yeah. Nothing more specific than the arrow instance laws though?
11:40:17 <ski> i'm not sure
11:40:49 <ski> one could have a commutativity law, that would require full parallelity
11:41:05 <Philippa_> mebbe two classes, one with one without?
11:41:16 <Philippa_> (the former being a subclass of the latter, of course)
11:41:20 <ski> that would exclude things such as an interleaving monad
11:41:24 <ski> yes, maybe that
11:42:36 <ski> anyway, i more or less began thinking some on this because some persons were saying that monads enforced sequencing :)
11:43:27 <ski> (as in "logical sequencing")
11:43:50 <Philippa_> yeah. They don't enforce, they support
11:43:55 <ski> (the answer to that being : only if you just combine with >>= (or derivatives))
11:43:56 <Speck> I got vim to send the current buffer to ghci, if anyone's interested: command -nargs=0 GHCi :exec "!ghci \"".escape(expand("%:p"),'\')."\""
11:45:07 <Philippa_> I'm not grokking those slides sufficiently. It doesn't feel like enough context
11:45:38 * ski need to look more at them, also
11:46:04 <ski> (would be nice to have some transcript of the talk .. or video ..)
11:46:14 <ski> (or a full paper version !)
11:46:50 <Philippa_> it's the bit where I'm not seeing much use of cobind and counit that throws me, it doesn't /look/ like a full example...
11:47:39 <Philippa_> I mean, just a simple "here we throw loaded sample data through a basic filter we've hacked up, retrieve the result and dump it out through a playData action" app would do
11:48:49 <astrolabe> I got as far as the defn of kleisli category, and had to have a lie-down
11:49:10 <Philippa_> I tend not to look at things via CT unless I want to clarify an intuition or two
11:49:31 <Philippa_> I don't need the generality in a computing context, and I /do/ need computing-relevant intuitions
11:49:43 <ski> astrolabe : you can try skipping that, and look at the later examples in haskell :)
11:49:58 <astrolabe> I'm a lot more familiar with CT that with all this computer nonsense ;)
11:50:26 <ski> oh ;)
11:51:13 <Philippa_> I'm slowly developing a knack for reading CT-based stuff into computing terms, but it's taking time
11:52:02 <Philippa_> and it doesn't handle anything too hairy and/or novel-to-me, either
11:52:24 <Philippa_> *blinks*
11:52:43 <Philippa_> if I've understood idioms properly, they're going to be /really/ useful tools for low-level hacking
11:53:41 <astrolabe> You mean like device drivers? or something else?
11:55:43 <Philippa_> the usual application I tend to have in mind is a certain level of console coding, but drivers'd be another potential example
12:00:09 <astrolabe> Makes you wonder what languages will be like in 50 years
12:00:54 <Philippa_> something dependantly-typed may or may not've gone semi-mainstream (it'll probably never be genuinely so, or else commonly not used to its full power)
12:00:58 <Philippa_> beyond that... more of the same, I suspect
12:01:04 <sond> where are these slides you are talking about? :)
12:01:17 <Philippa_> I /am/ hoping we'll get a better C than C though, and I think something FPL-derived is the thing to do it
12:01:29 <vegai> something like in "Minority Report", perhaps...
12:01:43 <vegai> I'm not sure if I'm kidding
12:01:43 <Philippa_> http://types2004.lri.fr/SLIDES/uustalu.pdf <- they're about comonads for signal processing
12:02:22 <Philippa_> I suspect there'll be a horrific lightweight-vs-industry-developing-the-retarded-way conflict that as usual'll go to the industrially-developed crap solutions
12:02:53 <Philippa_> only they'll have the usual big interop advantage that makes the other stuff too awkward for mainstream use, etc etc etc. But hey, continuation of current trends
12:02:54 <vegai> yes, I guess pessimism is a reasonable choice
12:03:21 <Philippa_> they're reinventing FP as XML, I hate to think what they'll do with dependant typing
12:06:10 <KrispyKringle> So has anyone here recently had an argument with someone over whether programming is computer science?
12:06:24 <KrispyKringle> I'm curious to hear some points of view. Given that my coworkers just gave me an earfull.
12:06:27 <Philippa_> nope. I'd probably be on the "no" side
12:06:52 <Philippa_> OTOH, knowledge from computer science is frequently useful for the purpose of programming, much as engineers apply scientific knowledge
12:07:03 <Philippa_> why, you just got the "you're too theoretical" one?
12:07:04 <KrispyKringle> Philippa_: I'm on the no side, too, but they didn't agree ;)
12:07:20 <tuomov> programming is at beast handicraft and at worst engineering
12:07:21 <Philippa_> ask them when they last discovered something novel? :-)
12:07:25 <tuomov> s/beast/best/
12:07:39 <KrispyKringle> Philippa_: Well, it was two-on-one, and they were a bit too roudy for me to keep up. ;)
12:07:48 <KrispyKringle> Philippa_: I said just that, that programming is a vocation, not an academic discipline.
12:08:10 <Philippa_> you want to be careful about the definition of "academic discipline" there
12:08:22 <KrispyKringle> I quoted the Knuth "Programming is to computer science as telescopes are to astronomy." ;)
12:08:30 <Philippa_> (consider logic and the use thereof, if it helps)
12:08:50 <Philippa_> the formalisation of processes certainly can be considered an academic discipline
12:09:18 <Philippa_> OTOH, that's not what most programmers're doing in any but the obvious/trivial sense
12:09:23 <KrispyKringle> Perhaps. I was going from the point of view that many professional programmers aren't very good, but these guys seemed not to consider *bad* coding as coding.
12:09:28 <KrispyKringle> Right.
12:09:39 <KrispyKringle> There's some abstraction to what they're doing, but not much.
12:09:42 <KrispyKringle> Not much of value.
12:09:59 <Philippa_> as a rule of thumb, it's stopped being academic when you're doing it for 'real world' non-research purposes
12:10:17 <Philippa_> then you're merely applying what you learnt as an academic. See engineering again.
12:10:22 <KrispyKringle> Heh. These guys would flip a shit if they heard you say that ;)
12:10:24 <shapr> hiya perspectival
12:10:25 <KrispyKringle> But I agree.
12:10:45 <KrispyKringle>  They argued that, since CS is generally in the Engineering department (it is at my school), it's fundamentally applied.
12:11:04 <Philippa_> in the sense that applied maths is, but not in the sense that physics is applied maths
12:11:10 <KrispyKringle> But I think that's a little silly, as well, because the engineering department doesn't teach how to build a bridge or how to design a car; they teach the concepts behind those designs.
12:11:14 <KrispyKringle> Right.
12:11:30 <KrispyKringle> I said that asking what academic discipline programming is is like asking what academic discipline actuarial work is.
12:11:33 <Philippa_> well, CS courses attempt to teach some of the concepts behind software designs too
12:11:35 <KrispyKringle> It's not mathematics, at that point.
12:11:46 <KrispyKringle> Which is why CS courses are more than just programming. :)
12:12:03 <Philippa_> right. When I'm sitting about toying with type system designs, it's not programming I'm doing
12:12:11 <Philippa_> (when I go out to implement a checker, sure...)
12:12:11 <tuomov> TCS is applied mathematics, but there's a lot more than that to CS
12:12:19 <shapr> TCS?
12:12:23 <tuomov> theoretical..
12:12:23 <Philippa_> Theoretical CS
12:12:25 <shapr> oh
12:12:30 <shapr> Yeah, I agree.
12:12:47 <Philippa_> tuomov: yeah. A lot of that's research that could be held to belong to other disciplines, mind
12:12:56 <KrispyKringle> I'm browsing the c2.com wiki on this subject, now, because they always have interesting concepts...
12:12:57 <tuomov> psychology and so on..
12:13:17 <Philippa_> you sure you don't mean "XP dogma" rather than interesting concepts? ;-)
12:13:18 <Speck> horrible flame wars, however
12:14:03 <KrispyKringle> XP dogma?
12:14:08 <shapr> Only XP dogma I've seen if from people who don't know what XP is, but try to 'convert the infidel' anyway.
12:14:13 <KrispyKringle> Speck: Oh, please. I read FARK. That's a horrible flamewar :P
12:14:15 <tuomov> Also some times numerical analysis, mathematical optimisation and so on are counted as cs, sometimes as (applied) maths
12:14:20 <KrispyKringle> Oh, Xtreme Programming?
12:14:21 <KrispyKringle> heh
12:14:22 <Philippa_> shapr: yeah. I was mostly being snarky
12:14:36 <Speck> Wesley Crusher from star trek is a moderator on fark, I hear.
12:14:41 <Philippa_> tuomov: yeah. I'm inclined to consider them largely applied maths, but also note that much CS is too
12:15:00 <Philippa_> it's applied maths that is about computation and is useful/relevant to CS, IYSWIM
12:15:10 <KrispyKringle> tuomov: Right. And I'm mostly from the applied side, myself. Theoretical computer science is often too abstract for me. But that doesn't change my opinion that I'm not a genius just 'cause I can churn out code, despite what the monkeys on Slashdot might think.
12:15:13 <Philippa_> (see "physics is applied maths")
12:15:24 <KrispyKringle> yea
12:15:52 <Philippa_> yeah. Certainly by, say, the 95th percentile most folks're capable of some simple level of code. 95th percentile just ain't genius, folks
12:15:56 <shapr> It's true, there's a lot of dogma surrounding 'methodologies', but the original idea was just like TMR, trying to get research into production.
12:16:11 <tuomov> theoretical physics is applied maths.. in the rest of physics maths can be applied but there's a lot more than that to it too
12:16:43 <KrispyKringle> Philippa_: Yeah. I think a lot of it is ego-stroking.
12:16:53 <Philippa_> tuomov: of course. Hell, sooner or later there's some CS/physics crossover. There's a smallish quantumn programming project going on at UoN
12:16:56 <KrispyKringle> Perhaps also backed by the assumption that you make more as a coder than an academic, so you must have more value.
12:17:23 <Philippa_> well yeah, slashdot has a lot of folks who believe a little too much in the market
12:17:31 * shapr agrees
12:18:02 <Philippa_> (either the actual one, or the theoretical one free of all the things they consider distortions, though nobody can agree 100% on what they are)
12:18:44 <Philippa_> accounting for the value of academics is difficult, and billing for it more so, therefore they get undervalued
12:18:49 <tuomov> the theoretical one where everyone is equally rich and succesfull so monopolies don't form etc...
12:18:56 <KrispyKringle> Oh, of course. It's full of monkeys. I mean that nearly literally; half the people on there are the human version of lower primates.
12:19:15 <Philippa_> tuomov: that's the stupid-theoretical one. The whole point of competition is that not everybody will be equal
12:19:31 <tuomov> and thus markets monopolise
12:19:46 <KrispyKringle> But these guys I was arguing with are smart people, perhaps smarter than I am, who are reasonably successful employees at one of the most successful software companies in the world. I'm annoyed that they, also, think this way.
12:19:58 <tuomov> so a totally free market is practically impossible
12:20:21 <Philippa_> no market is free of second-order effects. Therefore no market works the way the idealised first-order model says they will
12:20:49 <Philippa_> to put it another way, who said evolution has your best interests in mind?
12:20:56 <shapr> KrispyKringle: Yeah, but they're employees, right?
12:21:02 <KrispyKringle> shapr: yeah.
12:21:08 <KrispyKringle> shapr: So obviously they're biased.
12:21:11 <shapr> Yup.
12:21:18 <KrispyKringle> Just as I am, since I intend to pursue higher education over professional work, most likely.
12:21:56 <shapr> Why not point them to the Richard Hamming "You and Your Research" speech and ask them what they think the most important problems are in CS?
12:22:35 <Philippa_> I'm fairly happy with a comparatively inexpensive lifestyle - as a result, I really don't feel the need for a silly income and don't think my value-to-society has anything to do with it (except in the sense that while drawing on benefits I'm costing society)
12:23:19 <KrispyKringle> Philippa_: maybe not, but I have to admit that pulling in the big bucks has a bit of a draw, for me, at least. ;)
12:23:29 <tuomov> Philippa_: metoo
12:23:54 * Philippa_ would appreciate it if living space were cheaper in this country, that's about it
12:24:09 <tuomov> well, that..
12:24:27 <KrispyKringle> I want to be able to afford the next line of Powerbooks...
12:24:30 <KrispyKringle> ...but maybe that's just me.
12:24:35 <KrispyKringle> I'm going to grab some lunch real quick, though.
12:24:46 <KrispyKringle> Back in a few to continue putting off real work.
12:24:54 <tuomov> I don't need all the latest techno gizmos..
12:24:55 <shapr> I view myself as something of a fence sitter, I'd rather work in the industry, but I am unable to resist reading about and commiting acts of research.
12:25:01 <Philippa_> I'd like to afford the next batch of consoles (all of them) during their mainstream life, things like that. But that's no big deal. I don't need the high-end computer
12:25:11 <Philippa_> shapr: R&D in industry?
12:25:23 <tuomov> s/R&//
12:25:24 <shapr> Hm, could be.
12:25:31 <Philippa_> you strike me as a development-in-the-sense-of-applying-research type
12:25:38 <shapr> Yes, definitely.
12:25:38 <Philippa_> tuomov: the R tends to be secondary in that sense
12:25:57 <shapr> Sad thing is that I don't get much chance to do that.
12:26:20 <shapr> Where outside of Haskell is recent research entering usable programming language implementations?
12:26:31 <tuomov> I used to be an "R&D Engineer" and I didn't see much of R or even D
12:26:39 <Philippa_> how recent? Erlang was
12:27:00 <Philippa_> I get the impression some gamedev R&D folks get to have a lot of fun
12:27:12 <shapr> Yeah, I'd like to get into gamedev R&D.
12:27:19 <shapr> How about two years recent?
12:27:25 <tuomov> gamedev is becoming too mature an industry I think
12:27:35 <shapr> imho, any sane industry would put research conclusions into practice asap.
12:27:35 <tuomov> It would've been much more fun in the good old times
12:27:48 <shapr> hiya BigDuke, how's code?
12:27:54 <Philippa_> it still needs its R&D folks to offer those building the engines a pile of techniques, even if it's mainly middleware companies doing that
12:28:08 <Philippa_> shapr: depends - there's a lot to be said for tried-and-tested
12:28:19 <BigDuke> hey shapr, it appears bugfree after i pulled out 3 important ones :)
12:28:24 <tuomov> the research is done in unis, the companies just implement someone's research
12:28:35 <tuomov> and optimise the few bits out
12:28:49 <tuomov> or that's how it usually is in .fi anyway
12:28:50 <shapr> Maybe I should get into a University after all.
12:29:13 <Philippa_> and pick out which techniques play well together, make them scale, etc etc etc. Secondary-research-and-Development
12:29:22 <shapr> So much cool stuff going on, House, Oleg's Zipper of SubContinuations, SMP GHC, STM, GADTs...
12:29:27 <Philippa_> making content production scale's an interesting one
12:29:40 <shapr> BigDuke: Cool, what code are you working on?
12:29:49 <Philippa_> aside from the inference algo GADTs aren't all that new AIUI
12:30:11 <shapr> Yeah, but I'd like to see what they can do in practice.
12:30:20 <BigDuke> context-sensitive interprocedural dataflow analysis by means of embellished monotone frameworks, where i synthesize the transfer functions using UUAG.
12:32:38 <shapr> BigDuke: Ah yes, I remember now.
12:38:16 <ski> @yay
12:38:19 <lambdabot> I have a TINY BOWL in my HEAD
12:38:39 <ski> FootNote works nicely in hawiki
12:42:10 <Philippa_> oh?
12:42:20 * Philippa_ would occasionally like footnotes on the TMR wiki
12:46:17 <CosmicRay> shapr: mind if I poll shaprpedia for a moment? :-)
12:46:31 <CosmicRay> shapr: do you know of any curses-based widget toolkits other than cdk, ctk, and tvision?
12:46:50 <shapr> Sorry, I know nothing about curses.
12:47:05 <CosmicRay> bummer
12:47:12 <shapr> I only know about stuff I've gotten interested in using myself, at which point I investigate thoroughly.
12:47:41 <CosmicRay> I've decided that we need a good text-mode toolkit binding for haskell.
12:48:32 <shapr> Have you investigated ginsu and whatever it uses?
12:48:41 <CosmicRay> then, I can... *tada*  write a haskell-based gopher client.
12:48:42 <Philippa_> I'd appreciate something I could also play with from *doze
12:48:48 <CosmicRay> shapr: yes, it is more low-level
12:48:58 <CosmicRay> Philippa_: tvision can, but its license is questionable
12:49:01 <Philippa_> basic drawing but no widgets kinda thing?
12:49:07 <Philippa_> in what way?
12:49:23 <Philippa_> (bear in mind I consider the GPL 'questionable' ;-)
12:49:38 <CosmicRay> Philippa_: right, ginsu has an interface to curses, which is more of "put a character here and make it bold" rather than "give me a dialog box with this title and tell me when they hit ok"
12:49:59 <CosmicRay> Philippa_: borland supposedly public-domained the thing, but a lot of files still say "copyright (c) 19xx borland, all rights reserved"
12:50:07 <Philippa_> ah
12:50:27 <CosmicRay> it looks like cdk is aware of windows but will probably require cygwin.
12:50:28 <CosmicRay> hmm.
12:50:47 <Philippa_> I'd really want something that works from mingw
12:50:54 <Philippa_> (IOW, the usual GHC distro)
12:51:48 <musasabi> Does windows support the ansi terminal codes?
12:52:08 <Philippa_> dunno. I suspect you'd have to write a translation layer
12:52:15 <CosmicRay> you'd have to have curses anyway
12:52:20 <norpan> ansi it supports
12:52:21 <Philippa_> under DOS there was a device driver that did it
12:52:54 * CosmicRay still remembers DEVICE=ANSI.SYS in those config.sys files
12:52:58 <CosmicRay> those were the days....
12:52:58 <Philippa_> yeah. I'm fairly sure you could port curses to run via a console window or similar if nothing else
12:53:12 * CosmicRay posts a blog post, hopefully someone will turn up with something
12:54:35 <musasabi> CosmicRay: would you like a very small prototype to go with it?
12:55:01 <CosmicRay> musasabi: with what, a widget library?
12:56:52 <CosmicRay> sure, a prototype with a library would be good... do you know of a good widget set?
13:00:52 <musasabi> CosmicRay: I think I have a little thing displaying (using ansi codes as backend) widgets written in Hasekll somewhere, but I never did spend much time with it.
13:01:16 <CosmicRay> hm.
13:01:30 <CosmicRay> sounds interesting, but probably not portable enough I'm afraid
13:02:05 <ustenzel> CosmicRay: freshmeat turns up CK (http://www.ch-werner.de/ck/), which is like Tk, but for curses.  and there's newt, but that is based on slang.
13:02:30 <CosmicRay> ustenzel: what search terms did you use on fm?  I tried there but got only stuff I hadn't heard about
13:02:34 <CosmicRay> thanks for these links
13:03:04 <ustenzel> curses and toolkit :)
13:03:07 <musasabi> CosmicRay: it turns out to work out in most environments. (and in those it doesn't work compiling curses is also usually nontrivial)
13:03:18 <CosmicRay> musasabi: what about windows?
13:03:30 <ustenzel> CosmicRay: but don't ask for details... i can't even find a homepage for newt.
13:03:46 <CosmicRay> heh, I almost clicked on newt.org
13:04:19 <CosmicRay> hmmph.
13:04:21 <CosmicRay> Recent upstream versions can be found at: http://fedora.redhat.com/
13:04:27 <CosmicRay> (regarding newt)
13:04:43 <musasabi> CosmicRay: ansi codes worked at least for DOS apps inside windows.
13:06:44 <musasabi> Needs either ansi.sys or ansi.com through.
13:11:47 <thedward> since starting to learn haskell, I find myself using map and grep alot more in perl
13:12:05 <norpan> since i learned haskell i find myself not using perl at all
13:12:11 <qbert> lol
13:12:31 <shapr> Since I learned Haskell, I find myself dissatisfied with mainstream programming culture.
13:13:03 <norpan> luckily you don't have to sail in the main stream
13:13:14 <shapr> I still feel pretty close.
13:14:50 <thedward> I don't /have/ to use perl, but I don't think I could get my current project done fast enough in Haskell. maybe the next one.
13:15:28 <norpan> i need something like mmap for windows
13:15:35 <tuomov> I've found myself dissatisfied with the mainstream programming culture long before I learned of haskell
13:15:54 <tuomov> (or software culture in general)
13:17:27 <CosmicRay> norpan: all you have to do is find an IE exploit and you're close enough ;-)
13:20:10 <norpan> there must be some api function, but what is it called
13:22:23 <tuomov> hmm.. google is tracking search results you check these days
13:22:39 <tuomov> the results are redirections
13:22:49 <tuomov> time for a filtering proxy..
13:23:13 <CosmicRay> hmm.  how about a haskell binding to tk.  exists?
13:24:14 <ski> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/yahu.html ?
13:24:21 <wagle> @hoogle tk
13:24:47 <wagle> @seen lambdabot
13:24:48 <lambdabot> Yes, I'm here.
13:25:06 <wagle> @hoogle tk
13:25:18 <wagle> @google haskell tk
13:25:19 <lambdabot> http://www.informatik.uni-bremen.de/~ewk/WB.html
13:25:30 <ski> http://www.dcs.gla.ac.uk/~meurig/TclHaskell/ ?
13:25:47 <wagle> seems to be bunches
13:26:22 <wagle> tcl and tk are pretty easy to call to and from C..  and so the FFi should also be easy
13:26:32 <musasabi> There are many tk bindings.
13:27:17 <ski> (also http://www.cs.chalmers.se/~sydow/envs/overview.html :)
13:27:38 <musasabi> http://www.haskell.org/FranTk/
13:27:44 <wagle> huh..  i wonder if thats why the groddy stuff always wins.  if its clean and simple, then its easy to compete, and easy to get lost in the swamp of competition
13:28:06 <wagle> hmm..  i think it was FranTk that i was trying to think of
13:28:06 <Enveigler_> norpan: Maybe http://msdn.microsoft.com/library/en-us/dngenlib/html/msdn_manamemo.asp?frame=true
13:28:14 <norpan> ah "MapVievOfFile"
13:29:02 <norpan> just found it
13:29:14 <norpan> was looking under memory functions but it's a file function of course
13:35:12 <CosmicRay> musasabi: yes, I'm seeing that there are many Tk bindings.
13:35:19 <CosmicRay> the question is, which ones are current and which ones do people use?
13:35:27 <CosmicRay> some of these proudly proclaim compatibility with GHC 4
13:36:28 <CosmicRay> to which I say, "this is not the binding for me" :-)
13:37:27 <wagle> if java 1.5 is java 5, then isnt ghc 6.4 ghc 4?  B|
13:37:35 <CosmicRay> haha
13:39:13 <CosmicRay> leave the StudlyNumbering to Sun
13:50:23 <SyntaxNinja> @seen xerox
13:50:23 <lambdabot> xerox is in #haskell. Last spoke 6 hours, 20 minutes and 47 seconds
13:50:23 <lambdabot> ago.
14:13:50 <astrolabe> @pl \x -> x>3 && x<5
14:13:52 <lambdabot> liftM2 (&&) (> 3) (< 5)
14:14:07 <astrolabe> Why does it use a monadic function?
14:14:11 <astrolabe> What is the monad?
14:17:55 <Speck> @google All About Monads
14:17:56 <lambdabot> http://www.nomaware.com/monads/html/
14:18:11 <Speck> err, nm
14:18:29 <arjanb> the monad is of type (r->)
14:18:37 <Speck> thought you said "what is _a_ monad"
14:18:41 <Speck> then I read your nick
14:19:18 <astrolabe> :)  Thanks both
14:20:29 * Speck leaves from work now
15:29:36 <astrolabe> Does anyone know any references for Hindley-Milner type systems?
15:29:53 <Philippa_> in what way?
15:29:56 <Philippa_> how much info do you need?
15:30:08 <Philippa_> and do you just want basic H-M, or more than that?
15:30:13 <astrolabe> I need an introduction really :)
15:30:22 <Philippa_> (there's some info in TAPL and more in ATTAPL, for example)
15:30:33 <astrolabe> then I'll be in a better position to judge
15:30:45 <Philippa_> cardelli's Basic Polymorphic Typechecking'll get you past the basics
15:31:09 <Philippa_> though it doesn't cover too much theory - either you'll get enough intuition from it to work out a formalisation or you won't, IYSWIM
15:31:17 <wagle> basic simple type theory?
15:31:28 <wagle> (the book)
15:31:56 <astrolabe> Thanks.  Any web references?
15:32:03 <Philippa_> Cardelli's paper's available online
15:32:26 <Philippa_> it contains modula-2 code for a checker, too
15:32:40 <Philippa_> (I don't know modula-2 but was reasonably able to port it to Haskell - it ain't too bad, IOW)
15:32:58 <astrolabe> Cool thanks.  Is your code available?
15:33:17 <wagle> modula-2 is pretty much pascal with modules
15:33:38 <wagle> http://www.amazon.com/exec/obidos/tg/detail/-/0521465184/qid=1121812429/sr=8-1/ref=pd_bbs_1/102-1687799-2966558?v=glance&s=books&n=507846
15:35:11 <ski> this is a simple intro to typing and inference  Polymorphic Type Inference,
15:35:11 <ski> Michael I. Schwartzbach, http://citeseer.ist.psu.edu/14244.html
15:35:15 <Philippa_> astrolabe: no, on account of it sucking
15:35:29 <Philippa_> it was a port-to-get-it-to-run, not a port for pedagogical purposes. Though I may do one sometime
15:35:42 <Philippa_> Oh, you might want to try Typing Haskell In Haskell
15:36:07 <astrolabe> :)  I suspect if you saw my efforts at haskell you wouldn't say that.
15:36:45 <astrolabe> Thanks everyone, that should be enough to shut me up for a bit.
17:59:02 <palomer> anyone has any references on continuation based IO?
18:01:51 <wagle> palomer: can you be more specific?
18:02:45 <palomer> like, how does it work
18:02:56 <palomer> how do you use it
18:02:57 <palomer> etc...
18:03:05 <cm> explicitely passing the continuation to any I/O function
18:03:08 <wagle> what used it?
18:03:13 <wagle> what uses it?
18:03:38 <wagle> "the" continuation, or "a" continuation?
18:04:00 <cm> readNumber (\number -> printNumber number (\_ -> exit 1))
18:04:14 <wagle> (sorry, i can think of a dozen ways to do it, so trying to reduce the cases)
18:05:22 <palomer> cm: and how does exit work?
18:05:46 <wagle> exit 1 k = 1
18:06:03 <cm> it would exit the program, hence needs no continuation
18:06:04 <wagle> readnumber k = k (<read>)
18:06:26 <cm> wagle: hehe. :}
18:06:48 <wagle> printNumber n k = (<print> n) THEN k ()
18:07:14 <palomer> wagle: are you CPSifying?
18:07:28 <cm> palomer: he's sketching a possible implementation
18:07:29 <wagle> everything in cm's system would have to be written in continuation passing style ("stackless")
18:07:35 <cm> palomer: "readNumber (\number -> printNumber number (\_ -> exit 1))" is CPS
18:08:16 <palomer> hrm
18:08:26 <wagle> palomer: i'm just defining things that assume CPS
18:08:36 <palomer> how would you guys represent the integers in a CPSified system?
18:08:46 <cm> like normal integer variables
18:09:00 <cm> the point is that I/O-functions never return
18:09:11 <palomer> (and don't say the CPSification of the integers)
18:09:24 <cm> i don't understand your question.
18:09:26 <dons> it's how values are passed, not their representation, that changes
18:09:48 <palomer> hrm?
18:10:21 <palomer> you change application?
18:10:55 <dons> see the above readNumber example
18:11:08 <cm> when you evaluate readNumber k, what happens is that the implementation asks for the number and then calls the continuation with the given number.
18:11:08 <palomer> I understand it
18:11:09 <wagle> (1 + 2) + 3 = (\a -> (\b -> (\c -> (\v -> k (v + c)) (a + b)) 3) 1) 2)
18:11:58 <dons> @karma+ wagle
18:11:59 <lambdabot> wagle's karma raised to 1.
18:12:10 <cm> :-)
18:12:16 <palomer> wagle: what about \x\f f(f(x)) ?
18:12:29 <palomer> damnit, I wish there was some good, simple paper on CPSification
18:12:46 <wagle> EOPL (book)
18:12:54 <palomer> what's it stand for?
18:13:13 <cm> End Of Programming Languages :o
18:13:15 <wagle> Essentials of Programming Languages, Friedman, et al
18:13:16 <palomer> oh, right, elements of programming language
18:13:22 <palomer> I'll get it
18:13:34 <palomer> but, erm, what's the CPSification of \x\f f(f(x)) ?
18:13:40 <cm> did someone here watch "The Wedding Crashers"? ;)
18:13:55 <cm> \x\f\k k(f(f(x)))
18:14:01 <palomer> really/
18:14:03 <palomer> ?
18:14:07 <cm> pretty much
18:14:13 <wagle> \x f k -> f x (\v -> f v k)
18:14:27 <palomer> is there a calculus based on continuations ? (other than krivine's calculus)
18:14:44 <palomer> wagle: aren't you missing an f?
18:14:56 <wagle> matthias felleisen might have some continuation stuff
18:15:01 <cm> wagle: oh, hah.
18:15:13 <wagle> andrew appel has a bunch of stuff about compiling with continuations.
18:15:20 <cm> indeed @karma+
18:15:21 <cm> ;)
18:15:22 <wagle> palomer: i call f twice
18:15:23 <palomer> I don't like papers who start talking about scheme and scheme semantics to explain continuations
18:15:33 <palomer> oh, righto
18:16:08 <wagle> scheme has "real" continuations, haskell doesn't, ml doesnt (i think)
18:16:12 <palomer> I like it when they stick to pure lambda calculus
18:16:47 <wagle> felleisen hase "pure" lambda calculus stuff with continuations
18:17:20 <wagle> s/hase/has/
20:05:06 <MachinShin> hey all
20:05:28 * shapr yarghs at QuickCheckM
20:06:04 <shapr> I may give in and commit my firt act of unsafePerformIO.
20:06:13 <shapr> Long have I kept my virtue...
20:10:45 <dons> repent! repent!
20:11:33 <shapr> Show me how to get around unsafePerformIO and I'll repent.
20:11:39 <MachinShin> said the tick-toc-man
20:12:59 <shapr> "Finally, we can convert monadic properties back to ordinary ones, given a "run function" for the underlying monad, "
20:13:19 <shapr> So, how to get a (m Property -> Property) where m is IO?
20:20:33 <gzl> unsafePerformIO has the type you're looking for.
20:20:39 <gzl> give in.
20:20:40 <gzl> :)
20:22:32 <dons> so do they provide a runPropertyM ?
20:29:13 <shapr> Nah, just monadic
20:44:10 <shapr> Is there something like rawSystem where I can execute a command and get the output?
20:44:56 <geoffb> I've started a thread in #perl6 regarding books and/or papers that are considered classics, must-reads for CS people that really want to understand how & why -- and it occurs to me lambdafolk would have quite a bit of valuable input there.
20:45:32 <geoffb> Any suggestions?  I will be collating the results, and can post them somewhere if desired -- but at the least they will go in Pugs' READTHEM file
20:45:40 <shapr> I suggest SICP and The Pragmatic Programmer.
20:45:49 <shapr> TaPL for type theory.
20:46:13 <shapr> Oh, I suggest Richard P. Gabriel's writings for software engineering.
20:46:15 <geoffb> Could you expand those?  With authors, if possible (otherwise I'll happily google)
20:46:28 <geoffb> SICP and TaPL I mean
20:46:38 <geoffb> TPP we already had.  :-)
20:46:38 <shapr> SICP - http://mitpress.mit.edu/sicp/
20:47:15 <shapr> TaPL - http://www.cis.upenn.edu/~bcpierce/tapl/
20:47:50 <geoffb> thank you.  Any others?
20:48:01 <shapr> These days I'm beginning to think that it's necessary to understand the Curry-Howard isomorphism to understand more about why.
20:48:49 <shapr> I like Analysis Patterns, it's more about applied everyday stuff, like tPP.
20:49:13 <shapr> For must-read, only SICP and tPP.
20:49:33 <shapr> LtU has a bunch of suggestions, they like CTM.
20:50:22 <geoffb> CTM?
20:50:37 <geoffb> And where would I learn about the "Curry-Howard isomorphism"?
20:50:54 <geoffb> For Analysis Patterns I'm assuming Fowler . . . .
20:51:00 <shapr> Yup, that's it.
20:51:27 <shapr> Analysis Patterns is quite dense, sort of like a really massive steak :-)
20:52:30 <geoffb> heh, we already have a quite a few dense books in our list, so it's in good company
20:52:31 <shapr> I'm not sure where best to learn about the CH isomorphism. But in short, it says that executable code and first order logic are the same thing.
20:53:03 <geoffb> nod
20:53:17 <geoffb> What book is "CTM"?
20:53:18 <shapr> ctm - http://www2.info.ucl.ac.be/people/PVR/book.html
20:53:23 <geoffb> heh, jinx
20:53:48 <shapr> It was 'pinch, poke, you owe me a coke' in Alabama in the 80s
20:54:22 <geoffb> heh
20:54:43 <geoffb> "Jinx, you owe me a Coke" was how I learned it
20:54:45 <shapr> There's a thread on LtU about classic books, I'm trying to find it now.
20:54:53 <geoffb> mmm, good.
20:54:57 <shapr> Where did you grow up?
20:55:39 <geoffb> The whole #perl6 thread started with me wondering if someone had already compiled such a list, and where you could find it -- it just seems like a super-FAQ.
20:56:01 <geoffb> California (Northern), Idaho, Hawaii, Rhode Island -- mostly the first two.
20:57:06 <shapr> Yeah, it's a FAQ on places like http://lambda-the-ultimate.org/
20:57:24 <shapr> I don't keep up with the entire list though, only the next steps for me.
20:57:40 <geoffb> nod.
20:58:33 <geoffb> I initially assumed someone had to have started a list on a wiki somewhere . . . .
20:59:07 * geoffb idly tries a few googles
20:59:17 <shapr> Ward's Wiki has a list.
21:00:20 <shapr> Ah, here's something - http://lambda-the-ultimate.org/node/view/492#comment-3784 this comment and the entire thread contains suggestions.
21:01:33 <shapr> This is good for those of us who are poor and cannot afford to buy books - http://www.cs.uu.nl/people/franka/ref
21:01:59 <shapr> I'd like to see the list when you get it ready.
21:03:43 <geoffb> thanks for your suggestions, I'm chasing links now.
21:03:46 <geoffb> and will do.
21:05:45 <geoffb> Wow, the c2.com wiki has a LOT of book lists
21:05:56 <shapr> Yup
21:06:54 * Gahhh is still waiting for his copy of TaPL
21:42:11 <MachinShin> night all.
22:48:56 <dons> lambdabot's going down for its yearly service
23:05:46 <Wed9886> Tap o' the mornin' to ya
