00:08:32 <hyrax42> yay
00:08:33 <hyrax42> :/
00:12:26 <Korollary> lol
00:57:49 <lispy> @hoogle GLUT
00:57:55 <lispy> @hoogle GLUT.init
00:57:56 <lambdabot> Prelude.undefined :: a
00:57:56 <lambdabot> Prelude.minBound :: Bounded a => a
00:57:56 <lambdabot> Prelude.maxBound :: Bounded a => a
00:58:11 <lispy> @hoogle init
00:58:12 <lambdabot> Prelude.init :: ([a] -> [a])
00:58:12 <lambdabot> List.inits :: ([a] -> [[a]])
00:58:12 <lambdabot> Prelude.isInfinite :: RealFloat a => (a -> Bool)
01:38:51 <xerox> Ciao.
01:41:13 * lispy learns about using HOpenGL and is blinded by the beauty of monads
01:42:36 <lispy> http://www.tfh-berlin.de/~panitz/hopengl/skript.pdf
02:57:26 <ulfdoz> g'moring.
03:28:18 <jyp> @seen dons
03:28:19 <lambdabot> dons is in #haskell. Last spoke 6 hours, 47 minutes and 45 seconds
03:28:19 <lambdabot> ago.
03:37:37 <kaol> what kind of support does haskell have for l10n?
03:38:55 <ibid> i'm sure you can do magic with your own bindings to gettext
03:39:07 <ibid> but i am not aware of any readymade infrastructure
04:19:04 <foxy> @index (:=)
04:19:05 <lambdabot> Control.Parallel.Strategies
05:46:19 <MarcWeber> What is haskellLibTracker on sourceforge?
05:46:55 <Lemmih> Does it track Haskell libraries?
05:52:02 <MarcWeber> Lemmih: What does this mean? I've found the haskell-libs project on sourceforge but I don't know how to get information about what the libraries do..
05:57:35 <Lemmih> Look at their names.
05:58:25 <Lemmih> Directories like 'brainfuck', 'chess' and 'hashtable' says it all.
06:01:00 <Philippa_> brainfuck doesn't if you don't know what brainfuck is
06:01:33 <resiak> It at least gives an accurate suggestion.
06:02:34 <Lemmih> google+brainfuck = everything you need to know about brainfuck.
06:14:39 <astrolabe> I guess haskellLibTracker is this http://www.scannedinavian.org/repos/hlibs/haskellLibTracker/
06:26:42 <MarcWeber> Lemmih: Your'e right.. If you know what it is the name says everything you need.. ;)
06:28:16 <shapr> wooo
06:28:33 <dcoutts> something going right shapr?
06:28:56 <shapr> Yeah, life is good.
06:29:07 <dcoutts> good :-)
06:29:54 <shapr> Things going right in your life too? How's your Coker?
06:30:14 <dcoutts> it's very nice thanks :-) and I just moved into a new flat, so all is good
06:31:12 <shapr> I sort of thought you were joking when you said "Who needs a bus when you have a Coker?" But I'm starting to understand. My 26" with the 3" tire is really fast!
06:31:40 <dcoutts> and besides, you'd never fit it in a bus
06:31:51 <shapr> I can go fast enough that I can't run out of UPDs... and Cokers must be way faster.
06:32:17 <shapr> I averaged 12km/h around the lake yesterday.
06:32:20 <dcoutts> yeah, I got a big speed increase going from by 28" to the coker 30" with 2" tyre
06:32:31 <dcoutts> that's pretty good
06:33:03 <dcoutts> I've been clocked at 15mph on my 28" one, not sure about the coker, but much faster
06:33:25 <dcoutts> the guy I bought it off said he could hit 24mph!
06:33:28 <shapr> Wow!
06:33:49 <dcoutts> so I probably do something like 12-15 mph average on the flat
06:34:29 <shapr> Can you hop up onto curbs with a Coker?
06:34:58 <dcoutts> not hop, but ride straight up
06:35:07 <dcoutts> (sometimes)
06:35:11 <dcoutts> but I tend not to
06:35:40 <shapr> Is the Coker tire volume larger than a 3" tire on a 26" rim?
06:35:56 <dcoutts> hmm, not sure
06:36:09 <shapr> I know I can ride over just about anything.
06:36:59 <dcoutts> you could work it out (if you were a geometer)
06:37:22 * shapr writes some Haskell code to calculate it.
06:37:30 <dcoutts> 2" diameter tyre on a 36" rim vs 3" diameter tyre on a 26" rim
06:37:50 <dcoutts> what's the formula for the volume of a torus ?
06:38:03 <shapr> Intuition says that the 36" tire must be larger volume.
06:38:13 <dcoutts> probably
06:38:31 <shapr> I doubt my 65mm rim makes that much difference.
06:38:39 <dcoutts> @google volume torus
06:38:41 <lambdabot> http://whistleralley.com/torus/torus.htm
06:38:49 <shapr> http://en.wikipedia.org/wiki/Torus
06:39:12 <shapr> V = 2pi^2Rr^2
06:40:46 <dcoutts> what's R here?
06:40:58 <shapr> I think that's 18, and r is 1
06:41:05 <dcoutts> ah yees
06:41:33 <shapr> Or, 13 and 1.5 in my case.
06:41:37 <dcoutts> yep
06:41:45 <shapr> @plugs pi
06:41:59 <dcoutts> @plugs 2 * pi ^ 2 * 18 * 1^2
06:42:02 <lambdabot> 3.141592653589793
06:42:03 <lambdabot> 355.3057584392169
06:42:12 <dcoutts> @plugs 2 * pi ^ 2 * 13 * 1.5^2
06:42:15 <lambdabot> 577.3718574637273
06:42:23 <shapr> !
06:42:25 <dcoutts> oh!
06:42:35 <dcoutts> our intuition was way out
06:42:48 <shapr> Shocking!
06:42:53 <dcoutts> indeed
06:43:04 <shapr> That does explain why I can ride over just about anything though.
06:43:19 <dcoutts> Isn't maths great. I was only joking when I said we should calculate it ;-)
06:43:24 * shapr grins
06:43:39 <shapr> @plugs 2 * pi ^ 2 * 12 * 1.5^2
06:43:41 <lambdabot> 532.9586376588253
06:43:56 <shapr> That's for my KH24.
06:44:37 <dcoutts> @plugs 2 * pi ^ 2 * (28/2) * (1.5/2)^2
06:44:41 <lambdabot> 155.44626931715737
06:44:48 <dcoutts> that's for my 28" street one
06:45:06 <dcoutts> which was strictly on road!
06:45:11 <shapr> @plugs 2 * pi ^ 2 * 13 * 1.85^2 -- Including soon to be released Endomorph 3.7" tire
06:45:12 <lambdabot> parse error (possibly incorrect indentation)
06:45:22 <shapr> @plugs 2 * pi ^ 2 * 13 * (1.85^2)
06:45:25 <lambdabot> 878.2467476309365
06:45:29 <astrolabe> Wierd that the naive formulas for area and volume are exact.
06:46:08 <shapr> astrolabe: It's pretty much the volume/area of a cylinder.
06:46:14 <dcoutts> @plugs 3 -- does plugs not like comments?
06:46:15 <lambdabot> parse error (possibly incorrect indentation)
06:46:25 <shapr> Too bad
06:46:44 <shapr> Maybe that's so people can't do {- inline -} ?
06:46:57 <shapr> Oops, I meant {-# #-}
06:47:01 <astrolabe> shapr: That's what I mean.  A torus apparently has exactly the same surface area and volume as the corresponding cylinder
06:47:06 <dcoutts> but what would be wrong with that?
06:47:20 <shapr> Yeah, cylinders and torii are intuitively the same thing.
06:47:46 <dcoutts> hmm but you'd have thought the deformation would change volume or surface area
06:47:47 <shapr> I just dropped my cylinder and it bent. Now I have a torus.
06:48:36 <shapr> Nah, think of a balloon animal, where a cylindrical shape would be the same volume as a donut.
06:48:54 <dcoutts> I guess so
06:49:50 <dcoutts> yes, the volume must obviously be the same, and so the surface area must be the same too
06:50:02 <astrolabe> ok.  I see it.
06:50:37 <astrolabe> I wouldn't say it was obvious though, and I was a geometer.
06:50:40 <dcoutts> Q.E.D. proof by balloon animals
06:50:43 * shapr laughs
06:51:13 <shapr> I suspect balloon animals are not often brought up in math classes.
06:51:48 <astrolabe> Another wierd one is that a sphere has the same surface area as the curved part of the cylinder that just contains it.
06:52:15 <astrolabe> And if you slice both of them at the same height, then the bits you cut off have the same area too.
06:54:35 * shapr thinks about that.
06:54:52 <shapr> Oh, I see. That makes perfect sense.
06:55:32 <astrolabe> It strikes me as a bit odd.
06:56:56 <astrolabe> I've got a bug at the moment that may or may not be haskell related.
06:57:37 <astrolabe> I've got a programme that reads from the standard input and writes to the standard output.
06:58:02 <astrolabe> When I just run it and use the keyboard/monitor it appears to work fine.
06:59:09 <astrolabe> But when I someone else's code runs my executable, it doesn't seem to see the output (but the input gets to my code).
06:59:27 <dcoutts> sounds like a buffering problem
06:59:47 <dcoutts> when it's attached to a terminal it probably uses no buffering
07:00:07 <dcoutts> but when it's attached to a pipe it's probably using block buffering
07:00:24 <dcoutts> and since it doesn't fill the block buffer you get no output
07:00:41 <dcoutts> @index hFlush
07:00:43 <lambdabot> System.IO
07:01:25 <astrolabe> That sounds sensible.  It is a good job you aren't closer dcoutts.  I might kiss you (which I suspect wouldn't be pleasant for either of us).
07:01:29 <dcoutts> use can either use hFlush after outputting a message, or use less buffering (ie none)
07:01:36 <dcoutts> :-)
07:02:09 <dcoutts> hmm time for tea...
07:02:36 <Excalibor> greetings
07:05:00 <shapr> yeah, tea
07:05:03 <shapr> hiya Excalibor
07:14:23 <astrolabe> dcoutts:  That works!  Thanks alot.
07:14:37 <Excalibor> hey
07:14:40 <dcoutts> cool
07:14:59 <Excalibor> time for some cook cleaning for me...
07:15:01 <Excalibor> brb
07:21:13 <frederik> the haskell-mode.el file in "http://www.iro.umontreal.ca/~monnier/elisp/haskell-mode-2.0.tar.gz" says "Version: 1.43", did an old version get packaged or is this normal?
07:26:06 <luqui> what's the usual way in haskell to represent a set
07:26:15 <Enveigler> @type mapM
07:26:20 <lambdabot> forall b (m :: * -> *) a.
07:26:20 <lambdabot>    (Monad m) =>
07:26:20 <lambdabot>    (a -> m b) -> [a] -> m [b]
07:26:29 <dcoutts> luqui, Data.Set
07:26:53 <luqui> how can I find docs, btw
07:26:53 <dcoutts> or for simple small sets people often just use lists
07:27:15 <dcoutts> luqui, http://haskell.org/ghc/docs/latest/html/libraries/index.html
07:27:25 <luqui> thanks much
07:31:18 <TheHunter> @docs Data.Set
07:31:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Set.html
07:38:37 <luqui> the most elegant way to do: \x -> foo x y
07:38:52 <luqui> can lambdabot tell me that?
07:39:06 <dcoutts> @pl \x -> foo x y
07:39:06 <lambdabot> flip foo y
07:39:19 <luqui> lambdabot is very cool
07:39:21 <dcoutts> not sure that it's beter however :-)
07:39:33 <luqui> well, I was looking for a function like that
07:39:41 <luqui> but as a reader, I would probably find the lambda easier to understand
07:39:41 <dcoutts> ok
07:39:52 <dcoutts> indeed, it's more explicit
07:39:53 <luqui> but I'm not writing this for anybody else ;-)
07:40:17 <dcoutts> in that case, point free style all the way!
07:40:52 <TheHunter> @pl \x -> x `foo` y
07:40:53 <lambdabot> (`foo` y)
07:41:21 <dcoutts> and even less readable :-)
07:41:43 <dcoutts> we need @obfuscate
07:41:55 <luqui> :-)
07:42:59 <shapr> Oh, good idea!
07:43:51 <dcoutts> shapr, it could just apply random meaning-preserving transformations
07:44:27 <dcoutts> it could even be pluggable where you can add new transforms
07:45:02 <shapr> Yeah, excellent idea!
07:45:15 <dcoutts> I wanted to do this to write a proof-of-concept highly polymorphic virus and send it back to my colleagues at the anti-virus company I used to work for :-)
07:45:48 <dcoutts> just to see if they could understand it
07:47:46 <astrolabe> Do you get polymorphic viruses?  How do they detect them?
07:48:43 <dcoutts> well actually existing polymorphic viruses are not all that polymorphic so it's not too hard
07:49:33 <astrolabe> I see.  A good job virus writers aren't brighter.
07:49:55 <dcoutts> yeah, or the anti-viurs people would have a hard time
07:50:57 <Igloo> Enough people are stupid enough that virus/worm/... writers don't have to be clever, though
07:51:11 <shapr> Sadly, yes.
07:51:30 <shapr> Really polymorphic viruses wouldn't be too hard, but the Dark Avenger was the best I've seen.
07:53:16 <dcoutts> the anti-virus writers use absolutely antiquated languages to write their virus detection programs
07:53:34 <dcoutts> if you had a really sophicticated virus they'd be stuffed
07:54:38 <astrolabe> Surely the programmer is more important than the language?
07:55:17 <dcoutts> in particular they tend to have very limited program state so if you had something that required a linear amount of memory to recognise then they'd be stuffed
07:55:40 <dcoutts> provably :-)
07:56:18 <dcoutts> of course they can cheat and not recognise the thing exactly and just hope that not too many innocent files match their virus signature
07:57:19 <luqui> hmmm, how do I tell haskell how to resolve an ambiguous occurrence of a function
07:57:30 <dcoutts> use the module prefix
07:57:30 <luqui> do I say something when I'm importing, like "don't import this one"
07:57:40 <dcoutts> import Foo hiding (bar)
07:57:56 <dcoutts> or import qualifed Foo
07:58:03 <dcoutts> and then use Foo.bar
07:58:15 <luqui> oh, neat
07:58:44 <dcoutts> or you can even import everything except one function and import that one qualified:
07:58:59 <dcoutts> import Foo hiding (bar)
07:59:02 <dcoutts> import qualifed Foo (bar)
07:59:25 <luqui> well, thanks
08:01:06 <astrolabe> When that happens, I get worried that there has been some disaster.
08:01:41 <dcoutts> I've had it happen that everyone but me dissapeared
08:01:57 <astrolabe> That would totally freak me out :)
08:02:03 <dcoutts> I wondered if I'd said something wrong :-) or been too smelly
08:02:12 <astrolabe> LOL
08:46:26 <Enveigler_> @index read
08:46:27 <lambdabot> Text.Read, Prelude
08:46:46 <Enveigler_> @type Text.Read
08:46:52 <lambdabot> bzzt
08:47:07 <Lemmih> Text.Read is a module.
08:47:09 <Enveigler_> @type Text.Read.read
08:47:11 <lambdabot> forall a. (Read a) => String -> a
08:47:58 <Enveigler_> @type Read
08:47:59 <lambdabot> bzzt
08:50:55 <Enveigler_> @index words
08:50:56 <lambdabot> Data.List, Prelude
08:52:43 <Enveigler_> @index interact
08:52:44 <lambdabot> System.IO, Prelude
09:00:19 <Enveigler_> @index primGetCOntents
09:00:20 <lambdabot> bzzt
09:00:26 <Enveigler_> @index primGetContents
09:00:27 <lambdabot> bzzt
09:03:46 <Enveigler_> How the heck does interact manage to supply Strings (rather than IO Strings) to it's argument function?
09:04:58 <Enveigler_> @docs primGetCOntents
09:05:00 <lambdabot> primGetCOntents not available
09:05:06 <Enveigler_> @docs primGetContents
09:05:06 <lambdabot> primGetContents not available
09:05:47 <dcoutts> Enveigler_, interact uses getContents to get a lazy input string
09:06:02 <Lemmih> @type let myInteract fn = mapM_ putStrLn =<< fmap (fn.lines) System.IO.getContents in myInteract
09:06:03 <lambdabot> ([String]
09:06:03 <lambdabot>                                 -> [String])
09:06:03 <lambdabot>                                 -> IO ()
09:07:02 <Lemmih> Urk.
09:07:42 <Enveigler_> Right. But if data originates via IO, then isn't it's type (usually) IO <type>, because there is no way to remove the data from it's IO wrapper?
09:07:45 <Lemmih> @type let myInteract fn = putStrLn =<< fmap fn System.IO.getContents in myInteract
09:07:47 <lambdabot> (String
09:07:47 <lambdabot>                            -> String)
09:07:47 <lambdabot>                            -> IO ()
09:07:51 <Lemmih> There we go.
09:08:17 <dcoutts> from ghc's system.IO:
09:08:18 <Enveigler_> That should probably tell me somethig  Lemmih--but it doesn't.
09:08:19 <dcoutts> interact        ::  (String -> String) -> IO ()
09:08:19 <dcoutts> interact f      =   do s <- getContents
09:08:19 <dcoutts>                        putStr (f s)
09:08:39 <dcoutts> Enveigler_, does seeing the code help?
09:09:54 <dcoutts> @type getContents
09:09:56 <lambdabot> IO String
09:10:17 <Enveigler_> dcoutts: Not in this case because it's more a question of how it (whether interact or getContents or primGetContents) manages to bypass the restriction that data originating voa IO cannot become a non-IO<type>?
09:10:35 <dcoutts> by the magic of lazy IO
09:10:57 <dcoutts> @type unsafeInterleaveIO
09:10:58 <lambdabot> bzzt
09:11:07 <musasabi> I don't think there is any "IO a -> a " transformation, just unsafeInterleaveIO :: IO a -> IO a.
09:11:13 <Enveigler_> Hmmm. I had enough of "magic" in Perl. I thought that Haskell would be different.
09:11:28 <dcoutts> @type System.IO.Unsafe.unsafeInterleaveIO
09:11:29 <lambdabot> forall a. IO a -> IO a
09:11:40 <dcoutts> Enveigler_, ok, it's not really magic
09:11:49 <Lemmih> @wiki ThatAnnoyingIoType
09:11:50 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIoType
09:12:29 <wilx> @type System.IO.Unsafe.unsafePerformIO
09:12:30 <lambdabot> forall a. IO a -> a
09:12:30 <dcoutts> it's a useful trick, it allows the actual IO to be deffered until when it's needed
09:12:43 <Enveigler_> I just got called for food. Continue later I hope?
09:12:48 <dcoutts> ok
09:39:56 <batkins_> when i type "fac 0 = 1" into hugs' interactive mode, i get an "unexpected =" error.  what am i dong wrong?
09:41:08 <vegai> the interpreter doesn't work like regular source files do
09:41:42 <dcoutts> batkins_, in ghci you can say: let fac 0 = 1
09:41:49 <dcoutts> but you can't do it in hugs :-(
09:42:09 <batkins_> dcoutts: oh cool, that worked
09:42:33 <dcoutts> not sure you can define multiple clause functions like that however
09:42:46 <dcoutts> I doubt you can say:
09:42:48 <dcoutts> let fac 0 = 1
09:42:52 <dcoutts> let fac n = ...
09:42:55 <batkins_> dcoutts: so should i put them in a file and load that in?
09:43:02 <Igloo> You can, but it won't do what you want
09:43:12 <Igloo> let fac 0 = 1; fac n = ...
09:43:18 <batkins_> yeah i tried it and get a stack overflow for fac 3
09:43:21 <Igloo> will work
09:43:36 <batkins_> Igloo: thanks
09:43:43 <batkins_> Igloo: that works
09:44:19 <dcoutts> batkins_, because what Igloo was saying aobut "it won't do what you want" is that if you write it like this:
09:44:27 <dcoutts> let fac 0 = 1
09:44:28 <dcoutts> let fac n = ...
09:44:41 <dcoutts> then the second definition masks the first one
09:44:47 <batkins_> what's the typical way to write and test haskell code then?  should i be writing it in files and then loading the files into the interpreter?
09:44:51 <batkins_> dcoutts: yeah that's what i figured
09:44:58 <dcoutts> and so there is no clause for 0, and so you get the stack overflow
09:45:05 <vegai> that's what they usually do, yeah
09:45:35 <vegai> and for seriouser:) things, automated tests
09:45:43 <dcoutts> vim/emacs/nedit/gedit open in one window and a terminal window with ghci
09:46:03 <batkins_> dcoutts: and then just :reload whenever i make a change?
09:46:06 <dcoutts> and then save the file and in ghci say ":r" for reload
09:46:07 <dcoutts> yep
09:46:21 <aheller> batkins_: with all the interaction goo turned on in emacs, C-c C-l tosses the source file into the inferior-haskell buffer, also.
09:46:45 <batkins_> aheller: ah ok that's even better
09:47:02 <dcoutts> I think a Haskell IDE should allow you to work 'live' without having to save/reload
09:48:04 <aheller> dcoutts: My brains a little fried, but are there any like that around for other languages?
09:48:21 <dcoutts> there is for VB :-)
09:48:31 <aheller> well, sign me up! </sarcasm>
09:48:37 <dcoutts> not sure really about others
09:49:03 <dcoutts> it makes less sense to do that sort of thing in an imperitive language
09:49:18 <dcoutts> since there you've got to worry about the current state of the program
09:49:35 <dcoutts> interactive development in Haskell should be better in that respect
09:49:51 <aheller> I was just thinking about it.  eclipse tricks you (for java) by compiling every time you save, and dr. scheme, at least last time I used it, still wanted you to load a whole file at a time.
09:51:21 <dcoutts> you'd want something reasonably clever that can still evaluate functions even when bits of your script are not well formed
09:52:00 <dcoutts> so you can be writing new code and still run bits you'd written before (so long as they did not depend on the new stuff)
09:52:22 <dcoutts> that'd put the "Interative" in IDE !
09:52:51 <aheller> I'm still not totally natural with laziness, but I feel like it might be easy to trick the thing into infinite loops.
09:59:32 <metaperl> yet another poetic waxing onhaskell: http://scannedinavian.org/~metaperl/haskell/is-beautiful/pipeline-philosophy/
10:00:54 <dcoutts> I'm finnishing my little article on multi-threaded GUI programming...
10:01:10 <dcoutts> it's really needs more cool screenshots though :-)
10:04:07 <Enveigler_> @type return
10:04:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
10:04:36 <dcoutts> Enveigler_, ignore the "forall (m :: * -> *) a." bit, it's just confusing
10:04:56 <dcoutts> Monad m => a -> m a
10:05:30 <dcoutts> so you see what return is doing? (just by looking at the type)
10:05:42 <Enveigler_> So return just wraps the thing of type a in a monad?
10:05:48 <dcoutts> exactly
10:06:01 <dcoutts> and it works for any monad you like
10:06:24 <aheller> I never understood why "return".
10:06:58 <dcoutts> it could also have been called "lift" or something like that
10:07:07 <Enveigler_> That implies that I could start with something wrapped in an IO monad, unwrap it inside the do, the return it wrapped in a State monad?
10:07:33 * jyp recalls 'unit' of the good old days
10:07:36 <dcoutts> Enveigler_, you could not do that because look at the type of (>==)
10:07:52 <dcoutts> er (>>=) sorry
10:07:57 <dcoutts> @type (>==)
10:07:58 <lambdabot> bzzt
10:08:01 <dcoutts> doh!
10:08:03 <dcoutts> @type (>>=)
10:08:05 <lambdabot> forall (m :: * -> *) b a.
10:08:05 <lambdabot>    (Monad m) =>
10:08:05 <lambdabot>    m a -> (a -> m b) -> m b
10:08:22 <jyp> only one 'm'
10:08:49 <Enveigler_> So return decides the type of monad it returns from the type of the monad it was "passed"?
10:09:41 <dcoutts> you could think of it as the monad type 'm' for 'return' is worked out from the context in which it is used
10:09:53 <jyp> you can think of it as late binding
10:10:47 <dcoutts> sometimes it was because it was passed something which fixes the type, other times it is because it's the result that gets used with a particular type that fixes it
10:11:16 <dcoutts> so as you can see, return does not have 'm' as part of the type of it's input arguments
10:11:53 <dcoutts> it is possible to make examples that are ambiguous
10:12:03 <dcoutts> but it doesn't happen often
10:12:10 * Enveigler_ thinks "smoke and mirrors" -- but less smoke than previously :)
10:12:14 <dcoutts> @type read . show
10:12:16 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
10:12:24 <dcoutts> hmm
10:13:16 <dcoutts> Enveigler_, there is a perfectly well defined algorithm for infering the types of everything in a Haskell program
10:13:46 <dcoutts> so it looks a bit heuristinc "just work it out from the context" but actually it's rigerously defined
10:15:03 <dcoutts> it's called the "HM type system" and the "HM type inference algorithm"
10:15:26 <Enveigler_> dcoutts: I'm sure you're right. I'm less concerned by the "rigorously defined" part and more concerned with "will my brain ever grasp the hueristic"  :)
10:15:38 <dcoutts> yeah :-)
10:16:02 <dcoutts> you'll get used to it, it becomes intuitive eventually
10:17:16 <aheller> @plugs return 0 >>= \x -> x : [2]
10:17:18 <lambdabot> [0,2]
10:17:41 <aheller> If I'm understanding right, one figures that return is list's because I used : [2], no?
10:17:48 <mauke> @pl \x -> x : [2]
10:17:49 <lambdabot> (: [2])
10:18:18 <mauke> @type \x -> x : [2]
10:18:20 <lambdabot> forall a. (Num a) => a -> [a]
10:18:41 <Enveigler_> No matter where I start in, I always end up at the same place.There is all this (bizarre) syntax and semantics required to achieve sequentiallity, that just falls out intuatively in imperative (and even some functional) languages.
10:19:01 <mauke> aheller: yes
10:19:21 <mauke> >>= is a -> m b, and your function is a -> [a]
10:19:30 <mauke> so the m in this case must be []
10:19:31 <Enveigler_> I know you guys are convinced that the purity and laziness it allows are great benefits, but I'm still trying to get to grips with what they are.
10:19:36 <dcoutts> Enveigler_, if you stick to the 'do' notation it's not so odd
10:20:18 <dcoutts> but yes, you should be trying to write as much stuff as possible in the 'pure' style rather than using the IO monad all over the place
10:21:27 <aheller> @plugs return 0 >>= \x -> Just x
10:21:29 <lambdabot> Just 0
10:21:36 <Enveigler_> Yeah! I can see the temptation to write one enormous main = do ... block for every program, but that kind of defeats the object I think.
10:21:39 * aheller has a fine appreciation for the trivial.
10:22:25 <dcoutts> Enveigler_, yes, it's an approach that too many beginners take
10:24:29 <Enveigler_> And that brings me back to Control.Monad.liftM I think.
10:24:56 <dcoutts> meaning?
10:26:30 <Enveigler_> Oh. Sorry. When I first started I was given a piece of code that used liftM, but I couldn't understand the concept of "lifting". I asked here for clarification, but no of the explainations really penetrated my think skull.
10:26:58 <dcoutts> right
10:27:10 <dcoutts> you see the connection to "return" now?
10:27:20 <Enveigler_> I think that it is the key to my understanding how to segregate the monadic from the functional.
10:29:35 <Enveigler_> Yes. liftM unwraps an inbound monad, supplies it's payload to the argument function and then rewraps the result in the (a?) monad
10:29:51 <dcoutts> @type liftM
10:29:53 <lambdabot> bzzt
10:29:59 <dcoutts> @type Monad.liftM
10:30:01 <lambdabot> forall r (m :: * -> *) a1.
10:30:01 <lambdabot>      (Monad m) =>
10:30:01 <lambdabot>      (a1 -> r) -> m a1 -> m r
10:30:52 <dcoutts> Enveigler_, yes thats right (m monad you mean)
10:30:53 <jyp> @pl \x-> x > 5 && x < 10
10:30:54 <lambdabot> liftM2 (&&) (> 5) (< 10)
10:31:06 <jyp> a classic
10:31:34 <basti_> hi all
10:31:44 * jyp bows
10:31:59 <dcoutts> jyp, we're tring not to confuse people :-)
10:32:08 <Enveigler_> It allow me to write pure functions that operate on type a and return type r and liftM will "convert" that function to operate on inputs of type M a and return values of type M r.
10:32:22 <dcoutts> yes
10:32:30 <jyp> It should be an enlightening example :)
10:33:18 <dcoutts> it could easily be an exam question! "What does the following code do: liftM2 (&&) (> 5) (< 10)"
10:33:26 <dcoutts> and the studets would go wtf!
10:33:49 <dcoutts> @type Monad.liftM2 (&&) (> 5) (< 10)
10:33:50 <pejo> dcoutts, hopefully thats for the advanced fp class
10:33:51 <lambdabot> forall a.
10:33:51 <lambdabot>             (Monad ((->) a), Ord a, Num a) =>
10:33:51 <lambdabot>             a -> Bool
10:33:55 <jyp> Good to know I'm past the 'wtf' stage then :)
10:34:01 <Igloo> @pl \x-> x > 5 && x < 10 && x /= 8
10:34:02 <lambdabot> liftM2 (&&) (> 5) (liftM2 (&&) (< 10) (8 /=))
10:34:38 * Enveigler_ runs away screaming..............
10:34:43 <aheller> jyp: I'm not :).  What's the monad there?
10:34:53 <dcoutts> eno-away, just what I was thinking!
10:34:57 <jyp> (Int ->)
10:35:04 <dcoutts> err Enveigler_ I meant
10:35:15 <Enveigler_> :)
10:35:35 <dcoutts> **** xchat autocomplete!
10:36:43 <aheller> jyp: I've never seen something like that.  It seems to make sense.  Is there a document about monads like that?
10:36:44 <Enveigler_> Guesswork. The && is monadic because it shortciruits?
10:36:54 <jyp> Sure...
10:37:01 <Enveigler_> shortcircuits
10:37:15 <dcoutts> && shortcircuits because of lazyness
10:37:34 <jyp> Functional Programming with Overloading and Higher-Order Polymorphism, Mark P Jones (http://www.cse.ogi.edu/~mpj/)
10:37:39 <dcoutts> (and because of the way it's defined)
10:38:14 <aheller> jyp: thanks.
10:38:24 <jyp> I hope it's what you want.
10:39:20 <Enveigler_> Hmmm. If expr op expr is functional, then it implies that either expression can be resolved first. But (i'm guessing) that && the left hand side has to be resolved and if false the right hand side is never evaluated?
10:39:40 <aheller> jyp: well, in my copious free time.
10:39:54 <dcoutts> Enveigler_, take a look at the definition of (&&)
10:40:46 <dcoutts> (&&)                    :: Bool -> Bool -> Bool
10:40:46 <dcoutts> True  && x              =  x
10:40:46 <dcoutts> False && _              =  False
10:41:13 <dcoutts> so it pattern matches on the first agument which forces it to be evaluated
10:41:34 <dcoutts> but it never pattern matches on the second so does not force it's evaluation
10:42:23 <Enveigler_> dcoutts: Okay. So I really shoudl have run away when Monad.liftM2 (&&) (> 5) (< 10) came up :)
10:42:36 <dcoutts> it could have been defined the other way round (except that it would have really confused people)
10:42:37 <jyp> naaah
10:42:39 <dcoutts> yes, probably
10:42:45 <jyp> :p
10:43:18 <basti_> so how does monadic && happen?
10:43:57 <Igloo> && isn't monadic, it's being lifted into a monad
10:44:38 <basti_> ah okay.
10:44:40 <dcoutts> Enveigler_, my point is that there is nothing built in to language that makes '&&' do short circut evluation, it can be defined withing the language to be left-shortcircut, right-shortcircut or (Pascal-style) no-shortcircut
10:44:46 <basti_> get it yes.
10:45:29 <jyp> let (^.^) = facetious
10:45:50 * jyp is proud to be able to tell haskell jokes, at last
10:45:53 <jyp> :))
10:45:58 <dcoutts> :-)
10:46:28 <dcoutts> so we should welcome you to guruhood jyp? :-)
10:46:35 <jyp> rofl
10:46:56 <dcoutts> "I'm not a Haskell guru, I just play one on #haskell"
10:47:15 <dcoutts> that's what I do :-)
10:47:23 <jyp> Don't we all ?
10:47:30 <dcoutts> :-)
10:47:41 <jyp> That's what makes this place enjoyable ;)
10:47:41 * Enveigler_ was sooo close to reinstalling ghc there for a few minutes...
10:47:57 <dcoutts> except for JaffaCake who is indesputably a Haskell guru :-)
10:48:27 <jyp> His first name is Simon ? ;)
10:48:41 <dcoutts> yes
10:48:49 <jyp> ok then :)
10:48:51 <dcoutts> one of "The Simons"
10:48:55 <basti_> which one?
10:49:00 <basti_> oh
10:49:02 * basti_ did whois
10:49:13 * Enveigler_ wonders if a deed pole will help?
10:49:27 <basti_> btw. what is SPJ's nick on here? i heard he shows up now and then?
10:49:40 <dcoutts> does he really?
10:49:58 <basti_> i dont know. I wouldnt even know his nick.
10:50:26 <Heffalump> the occasional time he did show up it was something fairly obvious
10:50:28 <Igloo> He did a couple of times. One of them as GHC_Simon or similar
10:50:35 <basti_> i see
10:50:37 <Enveigler_> That's the nice thing about anonimity. YOu can never quite be sure...
10:51:27 <aheller> says the person calling himself Enveigler... :)
10:51:38 <Enveigler_> :)
10:54:39 <jyp> google "Simon Peyton Jones nickname haskell" ==> Mr. Haskell himself :)
10:56:17 <jyp> this search engine is getting better with each day
10:56:46 <basti_> good would have been if it had found his nickname ;)
11:12:03 <dcoutts> I've added an article on multi-threaded GUIs to the Gtk2Hs FAQ section, any feedback would be cool
11:12:23 <dcoutts> I know it needs more screenshots of the stuff it's describing
11:12:41 <dcoutts> http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/
11:17:18 <jyp> dcoutts: I don't miss the screenshots
11:17:47 <dcoutts> I was thinking of a screenshot showing how HRay doesn't update it's display while it's rendering
11:18:19 <jyp> you need a video then :-)
11:18:33 <dcoutts> and I should actually write the code that'd do the "all singing all dancing" HIG compliant progress dialog
11:19:07 <dcoutts> well, just something that shows a window having been dragged over HRay and it not updating would do
11:20:10 <jyp> indeed
11:20:11 <dcoutts> jyp, but a video would be cool :-)
11:22:39 <jyp> Imho the last paragraph could benefit a bit more explanation...
11:23:04 <jyp> Especially I'm not sure about this: "If it there were some support from the Haskell runtime to get the events and timeouts that the Haskell side is waiting on ..."
11:24:21 <dcoutts> jyp, ok, any suggestion?
11:25:07 <jyp> Well, I don't, but I can explain what I don't understand...
11:25:13 <dcoutts> :-) right
11:25:28 <dcoutts> perhaps an example?
11:25:40 <jyp> You say "The Haskell runtime system knows all the events that would wake up Haskell threads"
11:25:46 <dcoutts> yep
11:25:59 <dcoutts> ok, it's not very clear :-)
11:26:06 <jyp> its seems contradictory wrt. the previous quote
11:26:14 <dcoutts> hmm
11:27:09 <dcoutts> oh I see what you mean
11:27:45 <dcoutts> so the Haskell system itself knows about these events, but to make things work I need it to tell me what they all are
11:28:04 <jyp> Ok ;)
11:28:23 <dcoutts> I'll see if I can re-phrase that last paragraph...
11:29:00 <jyp> Maybe it's just me though
11:29:16 <dcoutts> probably not
11:29:44 <dcoutts> the problem is that I understand what I'm saying!
11:32:39 <Enveigler> dcoutts: Are haskell's threads user, kernel or both?
11:33:52 <dcoutts> Enveigler, mostly user
11:34:27 <Enveigler> Preemptive or cooperative?
11:34:34 <Lemmih> What's a kernel thread?
11:34:36 <dcoutts> depends on the Haskell system
11:34:48 <cm> Lemmih: OS thread
11:34:51 <dcoutts> ghc uses preemptive, hugs uses cooperative
11:35:18 <Enveigler> Thanks.
11:35:22 <dcoutts> GHC can do some clever stuff with OS threads to make sure that the Haskell threads do not all get blocked when making a forign call into C land
11:35:29 <Lemmih> cm: The threads you get with pthread?
11:35:52 <cm> I guess.. the threads you get with CreateThread(). :)
11:36:39 <dcoutts> Enveigler, and JaffaCake (and others) are working on SMP support for GHC, to allow GHC to use multiple OS threads to run Haskell threads at the same time
11:36:53 <Enveigler> dcoutts: I'd like to read more about that clever stuff.
11:37:14 <Enveigler> Ah. *That's* what I've been searching for.
11:37:28 <dcoutts> the best place is probably some papers by JaffaCake
11:37:31 <Enveigler> Any pointers on the implementation?
11:37:42 <jyp> It's in the works atm
11:37:57 <pejo> Enveigler, www.haskell.org/~simonmar has his publications on a link.
11:38:00 <dcoutts> @google publications simon marlow
11:38:02 <lambdabot> http://www.haskell.org/~simonmar/bib/bib.html
11:38:35 <dcoutts> Enveigler, try this one: http://www.haskell.org/~simonmar/bib/concffi04_abstract.html
11:39:22 <Enveigler> Thanks.
11:40:05 <dcoutts> the paper on the web server is quite nice
11:41:41 <Enveigler> I've been think ing about how to combine user threads and kernel threads seemlessly for a long time--it'll be nice to see how other approach it.
11:44:03 <dcoutts> Enveigler, it's much easier to do in Haskell than in something like C/C++ because the language abstraction allows the runtime layer much more flexablity than in C
11:44:24 <dcoutts> eg, you've read about the 1:1 vs M:N threading models in C?
11:46:28 <Enveigler> No. I've not read about that.
11:47:15 <Enveigler> Or at least, not that I recognise by that nomenclature
11:47:25 <dcoutts> look for the NPTL stuff
11:49:42 <dcoutts> the RedHat devs built a 1:1 threading model implementation of pthreads, the IBM devs built a M:N model but the 1:1 was the one that went into linux in the end
11:51:24 <Enveigler> Okay. I've not really gotten to thinking about threads in Haskell. Hell, I'm still hung up on monads :)
11:52:58 <dcoutts> My original point was that the advantages of the M:N model are really hard to get in C, but with the extra abstraction layer in Haskell is quite possible (indeed it's what GHC does)
11:55:06 <Enveigler> The model I've been persuing (outside of Haskell) is the idea that each thunk is a user thread dispatched on a single OS thread. But any think that involves IO or OS interaction (or possibly dynamic library interaction) get's queued to one or more other OS threads, with the originating user thread/thunk blocking until it recieves the result from the queued operation on the other thread. (Badly described, but maybe you can see wh
11:56:55 <musasabi> Enveigler: that is more or less what GHC does with -threaded.
11:58:59 <Enveigler> musasabi: I'm just reading the paper.
11:59:55 <sylvan> any more info on what "-threaded" does?
12:00:24 <MachinShin> hey all
12:00:28 <musasabi> sylvan: use multiple OS threads for safe FFI calls.
12:00:48 <sylvan> is it just "map haskell threads onto a pool of OS threads", or is it something more like implicie parallelism
12:01:12 <sylvan> okay.. so a function like foo = bar1 + bar2 won't get executed on two processors?
12:01:18 <dcoutts> no
12:01:37 <sylvan> that would be sweet.. hard to decide when its worthwhile to do, maybe, but still pretty sweet...
12:01:54 <dcoutts> there's seperate research into that issue
12:02:07 <sylvan> pH?
12:02:20 <dcoutts> amongst others
12:02:45 <dcoutts> also, be careful to distinguish concurrency from parallelism
12:02:52 <sylvan> Seems uniquely suited for purely functinal languages
12:03:04 <dcoutts> and even that from this IO and FFI question
12:03:44 <dcoutts> GHC currently uses multiple OS threads to do FFI things, but only a single OS thread is running Haskell code at once
12:04:16 <dcoutts> the new SMP GHC will use multiple OS threads to run Haskell threads simultaniously
12:04:21 <sylvan> Enveiglers suggestion would be fun to try out.. Each thunk gets wrapped in a "forkIO" (which may bet mapped to a different OS thread)... If you have a massively multi-core processor that may speed things up considerably...
12:04:49 <musasabi> implicit parallelism is not really worth on current commodity hardware - but it will become much sweeter in the future.
12:05:11 <dcoutts> the problem generally is that the parallelism is quite fine grained and so overheads can swamp any advantages
12:05:36 <sylvan> yeah, hard to know which thunk is faster to compute on the current thread than it is to compute on another thread
12:05:43 <dcoutts> I worked at Cray once and they had a machine that could execute thousands of threads on a single core
12:06:23 <dcoutts> every time one thread would stall due to reading/writing to memory it'd swtich to the next thread
12:06:26 <sylvan> but still... it would be intresting to see what happens if you just spawn a new lightweight thread for each thunk and then those lightweight threads gets mapped to N OS threads (depending on the number of CPUs available)... Maybe its slower, maybe its faster..
12:06:49 <sylvan> If an 8 core CPU can run a program 2-3x faster then its worth it
12:07:02 <sylvan> imo
12:07:07 <musasabi> sylvan: there is no point in parallelism more than the number of (logical) cores in the cpu.
12:07:11 <Heffalump> once you have the SMP machinery in place, speculatively creating threads ought to be relatively cheap
12:07:13 <dcoutts> it seemed to me to be near ultimate lightweight thread hardware support
12:07:38 <sylvan> might be a killer-app for haskell then..
12:08:30 <sylvan> It'll look good in benchmarks at least... A C app running on a 32x CPU could very well be a tenth as fast as the same app in Haskell
12:09:12 <dcoutts> even if the Haskell app is being rather wasteful of the threads
12:10:14 <musasabi> personally I think parallelism annotations are much better than blind parallel computation.
12:10:21 <sylvan> musasabi: yes but it might be easier to spawn a lightweight thread for everything rather than picking N computations... So you may have 200 lightweights threads active, but only 8 cores.. But many of those lightweight threads are blocking, waiting for other threads.. At least there are plenty of stuff for those 8 cores to do...
12:10:36 * Enveigler would love to get his hands on one of IBM's GRID machines...
12:11:28 <sylvan> musasabi: for now, yes. But I think it will be hard to manually annotate a program to use available resources well on a 32, 64 or 128 core CPU...
12:11:52 <sylvan> Unless it's something inherently parallell, like ray tracing or something...
12:14:38 <dcoutts> musasabi, there is already the 'par' function
12:14:43 <musasabi> sylvan: first off many apps are not cpu-bound. If the app is cpu-bound then to take advantage of the multiple cpus on needs an algorithm which can be efficiently paralized - and adding a minimal strategy somewhere is not much bother.
12:14:50 <dcoutts> @index par
12:14:51 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
12:15:02 <dcoutts> @type Control.Parallel.par
12:15:03 <lambdabot> forall b a. a -> b -> b
12:15:14 <musasabi> dcoutts: yes, and the clean folks have some research with parallelism annotations (or strategies as they call them)
12:15:35 <dcoutts> you use it like 'seq' but it evaluates the first argument in another thread
12:16:18 <dcoutts> see Control.Parallel.Strategies
12:16:52 <dcoutts> musasabi, I'm not sure how colsely that relates to the research in Clean
12:17:00 <dcoutts> but it seems a similar idea/approach
12:21:13 <metaperl> I need associatve array facilities for Haskell. I need to map from an Int to and Int and I need to be able to increment the values of certain keys (even if this means returning an entire new associative array)
12:21:30 <jyp> Data.Map ?
12:21:34 <Heffalump> Data.IntMap
12:21:41 * metaperl looks at DAta.Map and Data.IntMap
12:21:49 <lispy> @hoogle Int -> Int
12:21:51 <lambdabot> Prelude.id :: (a -> a)
12:21:51 <lambdabot> Prelude.succ :: Enum a => (a -> a)
12:21:51 <lambdabot> Prelude.fromEnum :: Enum a => (a -> Int)
12:22:00 <Heffalump> (these are ghc 6.4, if you're on 6.2, use Data.FiniteMap)
12:22:38 <jyp> Oh yeah, in haskell you should always ask yourself if you're not better off with plain functions instead of assoc arrays
12:22:46 <metaperl> jyp and Heffalump: thanks
12:22:57 * jyp tips his hat
12:23:08 <metaperl> jyp: I dont think so in this case... I need an associative array
12:23:37 <jyp> It was more a note to self than anything ;)
12:23:56 <metaperl> actually Simon Thompson has not nitroduced GHC or libraries, so I think he wants us to do all that by ourselves, but I'm not writing a bunch of code for that for this particular problem
12:24:34 <metaperl> if this were homework for his class, of course I would slug it out. But since this is self-study, I'm taking the low road :)
12:25:32 <lispy> it's good to learn how it's done, and then use off the shelf stuff in practice :)
12:26:02 <metaperl> I suppose...
12:26:08 <metaperl> but I havent the patience mate
12:26:27 <metaperl> it's so much easier to chat-type in British English than American English :)
12:27:35 <lispy> depends i guess.  I grew up with American English, so I find it easier :)
12:33:53 <aheller> metaperl: haven't vs. don't have?
12:34:12 <metaperl> aheller: yes... for starters
12:34:51 <aheller> ah.  I always figured I'd just read enough fantasy to screw up my normal word order :)
12:34:56 <metaperl> how do I find out where Debian installed ghc6-doc on my system?
12:34:57 <dcoutts> jyp, I've modified the last paragraph of the multi-threaded GUI article a bit (it's now the last 2 paras)
12:34:57 <dcoutts> http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/
12:35:11 <metaperl> ghc6-docs excuse me
12:35:59 <lispy> dcoutts: cool!
12:36:36 <Heffalump> metaperl: dpkg -l ghc6-docs
12:36:42 <Heffalump> but /usr/share/doc/ghc6-docs/
12:36:44 * jyp reads
12:36:46 <Heffalump> and I think it is ghc6-doc
12:37:24 <metaperl> Heffalump: that doesnt list where the files are... but you are right about the pkg name
12:37:37 <dcoutts> lispy, any feedback would be apreciated
12:37:45 <Heffalump> I think I meant -L
12:37:55 <Heffalump> which was what I nearly said then got confused and changed it
12:39:00 <jyp> dcoutts: Crystal clear now... Just an extra word in "If it there"
12:39:43 <dcoutts> jyp, oh yes, ta
12:40:00 <dcoutts> fixed
12:40:42 <dcoutts> I now talk about "event sources" which is probably clearer than just "events"
12:42:16 <dcoutts> I'm beginning to wonder if threads could eliminate IORefs from GUIs entirely...
12:42:47 <dcoutts> eg you do traditional consle/file IO without the need for IORefs (mostly)
12:42:56 <dcoutts> why does GUI programming need it?
12:43:22 <dcoutts> because of the inferted nature of control flow that comes from using an event driven system
12:43:28 <dcoutts> inferted/inverted
12:43:44 <jyp> That's tomorrow's blog entry :)
12:43:51 <dcoutts> hah!
12:44:23 <jyp> A nice blog btw, gratz :)
12:44:31 <dcoutts> I'll first try restructuring one of my gui progs to see if I'm talking nonsense :-)
12:44:37 <dcoutts> jyp, ta
12:45:14 <dcoutts> (it's not really a blog, at least it shouldn't be :-) )
12:45:42 <dcoutts> mind you it's not exaclty an FAQ or a tutorial article... hmmm
12:46:01 <jyp> ha...
12:46:28 <dcoutts> it's a tutorial artice with a big wadge of implementation notes at the end
12:46:55 <dcoutts> maybe I should seperate it somewhat
12:47:14 <jyp> I'm confused; I clicked back a few times and it seems that it's paolo's blog about hscairo
12:47:27 <jyp> Or I'm really confused
12:47:31 <dcoutts> paolo does have a blog on our site
12:47:47 <dcoutts> and we are using blogging software for our website
12:47:55 <dcoutts> but overall it's not a blog :-)
12:48:00 <dcoutts> confused now?
12:48:03 <dcoutts> :-)
12:48:43 <jyp> Ok, all entries are presented as a continuous blog but there're unrelated
12:49:03 <dcoutts> oh, yes, it does span categories, that's not so good
12:49:21 <dcoutts> I wonder if we can fix that... I'll talk to our web dude
12:49:33 <dcoutts> @seen gour
12:49:34 <lambdabot> I saw gour leaving #haskell 3 months, 2 days, 15 hours, 10 minutes
12:49:34 <lambdabot> and 2 seconds ago, and I have missed 1 month, 2 days, 3 hours, 58
12:49:34 <lambdabot> minutes and 7 seconds since then.
12:49:48 <dcoutts> hmm, he clearly doesn't come here often enough :-)
12:50:47 <jyp> lambdabot's logging seems comprehensive :)
12:50:59 <dcoutts> down to the second :-)
13:04:19 <dcoutts> I've split the article into two pages with a warning about the gory details ahead :-)
13:05:55 <jyp> btw, what are current developpments of gtk2hs, beside cairo?
13:06:38 <dcoutts> we'll be putting out a bug fix release real soon now
13:06:41 <dcoutts> 0.9.8.1
13:07:12 <jyp> Is Axel still with you ?
13:07:13 <dcoutts> then for 0.9.9 we hope to add some TreeView improvments and a few other things
13:07:21 <dcoutts> yes (thankfully)
13:07:28 <jyp> Ah good
13:08:06 <dcoutts> I really need Axel, we review each others stuff and bounce ideas around
13:08:24 <jyp> I'm looking forward for Treeview improvements, as you know :)
13:08:28 <dcoutts> yes
13:08:55 <dcoutts> It's just I've been announcing most of the releases and doing other marketing stuff recently
13:09:03 <dcoutts> Axel is a bit quieter :-)
13:09:12 <jyp> Though I've been putting chinese on the background for the moment... But it'll backfire
13:09:59 <jyp> indeed
13:10:23 <jyp> Good marketing is important though, even for open source projects
13:10:33 <dcoutts> yes
13:11:01 <dcoutts> I managed to get us on the gnome news page, and we're now sending all release announcments to the gnome announce list too
13:11:02 <jyp> (as much as I hate admitting it :))
13:11:20 <dcoutts> also, having a cool website has really helped (thanks gour!)
13:11:25 <jyp> good
13:11:28 * Heffalump grumbles, I just lost £39 by dithering for a few hours about booking flights to estonia
13:11:46 <dcoutts> Axel and I were not really web developers, so our old web site was ugly
13:11:48 <jyp> I'm really looking forward to see haskell getting a bit more 'mainstream'
13:11:57 <dcoutts> indeed
13:12:13 <jyp> and thus good GUIs are a requirement
13:12:21 <dcoutts> yeah
13:12:34 <int80_h> you mean it's not mainstream now?
13:12:58 <jyp> haha... #of companies using haskell = 1.5
13:13:00 * int80_h wonders if he wandered in to some alternate universe where everyone is crazy about java and no one has ever heard of haskell.
13:13:31 * Heffalump knows of at least three companies using Haskell
13:13:46 <jyp> j2ee forever(
13:13:53 * int80_h notices Mr. Spock has a goatee in this universe and gets concerned.
13:14:59 <int80_h> Heffalump ae one of those three i California?
13:15:11 <kaol> IIRC evil Spock wasn't that evil after all
13:15:15 <int80_h> are , in
13:15:28 <int80_h> yeah but the goatee itself scares me.
13:16:26 <jyp> Anyone recalls the parodic South Park episode name ?.
13:17:07 <jyp> ? "Spookyfish"
13:17:15 <jyp> Hail internet
13:17:18 <jyp> :p
13:18:37 <int80_h> As a newbie, my impression is that haskell is moving right along to mainstream status.
13:18:56 <jyp> I'm into it since 3/4 years
13:19:02 <jyp> progress is amazing
13:19:49 <dcoutts> jyp, what are the big improvements would you say?
13:19:53 <jyp> We just need some underground agent at PriceWaterHouse to whispersneak the name in a managerial ear, and boom.
13:20:03 <jyp> Libraries
13:20:22 <jyp> User base
13:20:45 <int80_h> specifically I got hopefull when I saw the work being done to help haskel play nicely with the Outside World (tm)
13:21:27 <dcoutts> yes, the standardised FFI was crucial I think
13:21:54 <dcoutts> I'm hoping that cabal will be similarly excelent
13:22:32 <jyp> Oh yes... I can't wait to see hackage (or somesuch) be real
13:23:05 <dcoutts> and allowing easy packaging of cabal things for linux distros
13:23:44 <dcoutts> so haskell libs can be installed on your ordinary linux desktop/sever really easily
13:23:56 <dcoutts> Windows support has been quite important too
13:24:07 <jyp> I thougt this one was almost completed; thanks to Isaac efforts
13:24:15 <dcoutts> ghc used to be a pain to run on windows I beleive
13:24:27 <dcoutts> oh, yes, it's really good now
13:24:28 <jyp> I never had the problem
13:24:38 <dcoutts> it used to be cygwin only
13:24:57 <dcoutts> we've got lots more windows users than we used to
13:25:41 <jyp> Yeah, Someday we'll rule the world (tm)
13:25:57 <dcoutts> mwhahhah
13:26:04 <jyp> rofl
13:26:59 <int80_h> Am I delirious to think Fp is The Next Big Thing?
13:26:59 <jyp> Damn we got echelon on our asses now
13:27:27 * int80_h hates this keyboard and is going to switch it out Real Soon Now
13:27:29 <dcoutts> I think the industry hasn't quite been fully disolusioned with OOP yet
13:27:48 <jyp> Yeah, they need to burn out the Java fad
13:27:54 <jyp> but it's coming
13:27:58 <jyp> I thinh
13:28:01 <jyp> k
13:29:01 <jyp> I think there were two showstoppers in the past, lack of real world libraries; and performance
13:29:15 <jyp> they're both almost fixed
13:29:35 <jyp> ... and paradigm shift
13:29:52 <int80_h> well there's that little problem of most programmers being not much more than drones.
13:30:05 <jyp> but as caml, ruby etc. get publicity it benefits haskell
13:30:07 <int80_h> that's the one, paradigm shift
13:30:21 <int80_h> caml is getting publicity?
13:30:21 <wilx> Sorry to disappoint ou guys but I think that OOP is here to stay :)
13:30:29 <dcoutts> int80_h, most coders at my last job were drones
13:30:33 <int80_h> of course OOp is here to stay, but is java?
13:30:35 <jyp> burn the infidels!!!
13:30:43 <jyp> =)
13:30:50 <int80_h> why not smalltalk, the way god intended.
13:31:34 <dcoutts> wilx, so what should our strategy for taking over the world be then? :-)
13:31:56 <wilx> Heh, dunno, I ain't no strategist.
13:31:57 <Khisanth> hmm a programmer relying on god for his/her program to work .... :)
13:32:00 <int80_h> let's start bytelling all the java clones that the best jobs are being offered on the moon.
13:33:31 <vegai> int80_h: FP was the First Big Thing
14:02:04 <conal> here's a plan for Haskell getting more use in the world: use it to implement a few cool & useful DSLs with compilers that generate JVM code and therefore run everywhere.
14:03:25 <jyp> More than one JVM projects have been started but none have succeeded if I'm correct
14:03:48 <conal> and the languages would either be embedded in Haskell or very Haskell-like.  share lots of infrastructure among these language implementations and make them interoperable.
14:04:11 <dcoutts> jyp, but they were doing something slightly different if I understand correctly
14:04:49 <Khisanth> pugs will probably get there at some point :)
14:05:35 <jyp> well I'm not sure... There's also the CIL (.net) target in ghc that is in an unfinished state
14:06:24 <dcoutts> jyp, true, but what conal is suggesting is somewhat different than just adding a JVM or CIL backend to ghc
14:06:56 <dcoutts> jyp, 's along the lines of what he's done before with PAN and similar systems
14:07:07 <conal> right.
14:07:34 <conal> though a jvm/cil backend to ghc could do the trick also.
14:07:42 <jyp> Ok, I got it
14:07:43 <dcoutts> PAN (at least the first incarnation) was a Haskell embeded DSL that generated optimised C code
14:08:01 <jyp> I sread
14:08:06 <jyp> I misread
14:08:47 <dcoutts> conal, I'm not sure sure, wasn't it the fact that you were able to manipulate the AST of your DSL that allowed you do to the stuff you needed? Having a CIL ghc backend wouldn't help there.
14:09:00 <conal> i'd love to find help in porting Pan so it runs on other platforms, including mac, linux, jvm, & cil.
14:09:35 <dcoutts> A linux with gcc port shouldn't be too hard...
14:09:58 <dcoutts> and then it needs turning into a GIMP plugin...
14:10:28 <conal> dcoutts: i got speed by getting to the ASTs and doing tons of rewriting.  but without *any* domain-specific knowledge.  so i've always believed that ghc could do as well, with some tweaking and a few new flags.
14:11:05 <conal> dcoutts: yes&yes!  any takers to help with such a port?
14:11:37 <conal> (gcc & gimp)
14:12:06 <dcoutts> really? hmm you reckon the right combination of ghc optimisations (turned up sufficiently strongly) would do it?
14:12:22 <conal> yes, i do.
14:12:28 <dcoutts> it was mostly inlining and loop hoisting right?
14:12:47 <conal> yes, followed by lots of rewriting.
14:13:12 <conal> the loop hoisting would probably be the trickiest part, since ghc core doesn't have explicit loops.
14:13:24 <dcoutts> the gist of the rewriting being to make everything first order?
14:13:55 <lispy> iirc a lot of the rewriting is algebraic simplification
14:13:59 <conal> dcoutts: ??
14:14:09 <conal> lispy: right.
14:14:16 <dcoutts> oh, ok
14:14:27 <dcoutts> it's not got explicit loops, but it's got representations of recursion, so it can recognise loops
14:15:12 <conal> that's my hope.
14:15:14 <dcoutts> eg, I think they've got an optimisation that is supposed to be able to hoist case tests out of loops
14:15:32 <lispy> conal: i bet if you had a site where people could see the progress and todo list as well as download a VCS snapshot of the code and send in patches that the port would really take off
14:15:42 <dcoutts> Manuel makes use of it in his array research
14:16:06 <dcoutts> conal, yes, a darcs repo would be a good first step
14:16:29 <conal> that sounds like great advice.  thanks.  then advertise it on the haskell list?
14:16:35 <lispy> yeah
14:16:39 <dcoutts> yes, and here
14:17:11 <conal> i like that idea.
14:17:19 <dcoutts> conal, and it'll get you familiar with darcs which is "The Future"tm
14:17:50 <lispy> if you need help with darcs there is a wiki (you can get there from darcs.net) and there is a channel here on freenode, #darcs
14:18:06 <conal> dcoutts: that'd be helpful.  i use darcs now in a very simple way.  i haven't yet set up my own externally-visible repo.
14:18:23 <conal> lispy: thanks for the pointers.
14:18:36 <lispy> conal: ah, that's generally as easy as putting a repo in ~/public_html
14:18:41 <dcoutts> I believe it's as simple as having your darcs repo in a web-acessable location
14:19:04 <dcoutts> that at least allows remote read access
14:19:21 <conal> do other users need accounts on the server in order to contribute?
14:19:25 <dcoutts> and people can prepare patches and use "darcs send" to email them to you
14:19:42 <dcoutts> so no, other people do not need accounts at all!
14:19:44 <lispy> and then people can use 'darcs send' to send in patches.  You'll get them in  your email, then you save the attachment and do 'darcs apply <savedattachement>'
14:20:04 <dcoutts> so you get to be the gatekeeper on incoming patches
14:20:09 <conal> oh.  that sounds very simple.
14:20:21 <lispy> conal: if you want to have co-maintainers then the wiki has ways to give people write access without giving them a shell account
14:20:34 <dcoutts> and if you get regular contributors you can set things up such that their patches don't have to always go via you
14:20:52 <dcoutts> lispy, we seem to be saying the same thing at the same time ;-)
14:20:53 <lispy> and procmail can be setup to automatically apply patches
14:21:02 <lispy> dcoutts: yeah, i noticed that :)
14:21:23 * lispy shuts up
14:21:38 <dcoutts> lispy, let's answer conal's questions alternately :-)
14:21:43 <dcoutts> conal, next?
14:21:44 <lispy> hehe
14:22:08 <conal> so i could get started pretty easily and then learn from there.
14:22:21 <lispy> conal: using darcs isn't all roses.  I've been seeing real problems with it when using it on my homedir, but that's also a 600+ MB repository.
14:22:53 <dcoutts> one of the focuses of recent darcs development has been on performance, especially for larger repos
14:22:59 <conal> lispy: oh.  why do you darcs you homedir?
14:23:04 <conal> dcoutts: glad to hear it.
14:23:06 <lispy> conal: yes, that's the nice thing about darcs.  It lets you starrt out with barely any infrastructure
14:23:21 <dcoutts> (and problem cases like conflicting patches)
14:23:39 <lispy> conal: two reasons 1) to synchronize my data across several accounts/machines 2) to have a history of the synchronization
14:24:14 <conal> lispy: by 2, do you mean backup/history?
14:24:22 <lispy> i tried to do the same thing with CVS and nearly stopped using VCS for good ;)
14:24:33 * jyp waves
14:24:42 <lispy> conal: yeah, i can go back and get old versions of files if i ever need to
14:25:05 <conal> i see.  that's how i use darcs locally.  comforting.
14:25:56 <lispy> conal: it works quite well unless you have a large patch (say 10 megs of data in a single patch) or you have a very large repository
14:27:05 <lispy> i some way or another created a conflict in on my homedir and right now i'm waiting for darcs to resolve the conflict on my "central" copy
14:27:24 <dcoutts> conal, is there a way to download the latest pan sources? I don't see it on the web site
14:27:59 <dcoutts> I've found a "Windows installer for the sources to the Pan compiler" but that won't help me much :-)
14:28:12 <conal> i'll look ...
14:28:13 <dcoutts> oh wait...
14:28:21 <lispy> dcoutts: maybe you could use wine?
14:28:35 <dcoutts> got a zip file, much better
14:29:05 <dcoutts> didn't see that the first time
14:29:20 <conal> dcoutts: good.
14:30:04 <lispy> i have to say, i'm tempted to try out monotone for backing up my homedir.  I have a hunch it will give me better performance.
14:30:19 <lispy> but i'd hate to stop using darcs
14:30:33 <dcoutts> lispy, or try git :-)
14:30:55 <lispy> is git any good?
14:31:02 <conal> i'd love to have this port.  i can't even run the pan compiler myself anymore.  it relied on a very obsolete GUI library (wtl).  so i'll set up a Pan porting project with darcs and let folks know.
14:31:05 <lispy> it was designed with performance in mind wasn't it?
14:31:15 <dcoutts> yep, and large repos
14:31:31 <lispy> conal: good luck.
14:31:36 <dcoutts> conal, about the license, how open is it?
14:31:54 <dcoutts> eg would making it into a gimp plugin be possible legally?
14:33:44 <conal> dcoutts:  oh yeah, the license.  iirc, it allowed people to use & tweak the sources if tweaks are sent back to microsoft.  it doesn't say whom at ms though.
14:35:31 <conal> here's the text:
14:35:31 <conal> 	*You may do anything you want with the Software source code for non-commercial research or non-commercial teaching purposes free of charge, provided that you agree to the following:
14:35:31 <conal> 	*To make freely available to others the source code of any modifications or additions you make to the Software source code, and any related documentation, solely and exclusively under the same terms as this License.
14:35:31 <conal>       	* That Microsoft is granted back, without limitations, the rights to reproduce, install, use, modify, distribute and transfer your source modifications or additions in source and/or object code formats.
14:35:40 <Heffalump> might it be better to start from scratch from that point of view? Is there a lot of detailed work in Pan's code, as opposed to the work put into working out what's a good technique?
14:36:54 <conal> heffalump: hi.  yes.  it might ineed be better to start over.  not sure.  any opinions?
14:37:13 <dcoutts> conal, you don't work for MS anymore right?
14:37:56 <dcoutts> so it might be tricky to ask if PAN can be released under the same license as say GHC ?
14:38:02 <Heffalump> I think if you want to make a go of something as an open-source project, you'll have to get free of that licence.
14:38:31 <conal> dcoutts: right.  i left MS about 2 1/2 years ago.
14:38:51 <lispy> since MS doesn't use PAN as a source of income maybe they will be willing to just give it away
14:39:23 <dcoutts> conal, I wonder if it'd help if any of the remining Haskell MS people were to ask about releasing it
14:39:31 <dcoutts> remining/remaining
14:39:42 <xerox> Evening, people!
14:39:48 <dcoutts> xerox!
14:40:29 <dcoutts> speaing of Haskell and cool graphics... xerox, how's it going?
14:41:00 <conal> i haven't paid enough attention to license issues to understand how the current Pan license is problemmatic.  any clarifications?
14:41:19 <dcoutts> conal, well suppose we made a GIMP plugin...
14:41:32 <xerox> It's going nicely - I've been reading some code, but the most of the time was spent on the beach lastly. :-)
14:41:32 <dcoutts> no one would be able to use it for a serious purpose
14:41:58 <dcoutts> conal, just for "non-commercial research"
14:42:11 <dcoutts> xerox, sounds good :-)
14:42:13 <Heffalump> it also wouldn't be able to do stuff like go into Debian
14:42:38 <conal> dcoutts: so for any kind of business.  makes senes.
14:42:58 <dcoutts> and similarly, the GIMP people would not be able to accept it as part of the plugins they distribute
14:43:02 <Heffalump> basically, that licence is only useful for playing around a bit. Noone will really take it seriously in the open-source community.
14:43:19 <conal> got it.  thanks.
14:43:35 <xerox> I've also been enjoyning a "relative" doing a "process" to Dan Brown.  He's a Leonardo's studious - his father made me a coin when I was junger, with the machine invented by L. heh.
14:44:19 <lispy> conal: the best thing would be to get it relicensed.  I've never dealt with MS to know if they would be open to that.
14:44:38 <dcoutts> conal, even though most open source projects never get used seriously (especially Haskell ones!), people like to believe that they *could*, otherwise it's a bit de-motivating :-)
14:45:17 <conal> i'm convinced.  so either get Pan relicensed differently with help from MSR Cambridge or start a unhindered reimplementation.
14:45:17 <wilx> :)
14:45:18 <shapr> I think there's quite a bit of reuse of Haskell open source, especially in areas where's the code is the only existing option.
14:46:47 <xerox> He seem to have wrote quite a number of Leonardo's book: http://www.campusi.com/author_Alessandro_Vezzosi.htm !  :-)
14:48:18 <conal> xerox: what did you mean by a "process" to Dan Brown?  (i like Dan Brown.)
14:49:23 <Heffalump> I have a feeling that MS won't make it very easy to relicence Pan. GHC is a special case because MSR really wanted to hire Simon PJ and GHC was already under that licence.
14:50:36 <Heffalump> but there's no real benefit to MS to relicensing it, and they are pretty hostile to the OS community these days. And there's no real reason for anyone inside to push for it.
14:51:37 <conal> fortunately it's easy for me to ask.  i could say i want some help getting it working again, as it depends on the obsolete gui library.  i don't need to volunteer info about the goal of making it multi-platform.
14:51:51 <Igloo> conal: Dan Brown as in the author?
14:52:03 <conal> igloo: yes.
14:52:36 <dcoutts> conal, I'm currently trying to rip the gui bits out and get a command-line only compiler
14:52:47 <Igloo> How many of his books have you read?
14:52:48 <shapr> xerox: Well, Dan Brown is entertaining, but not serious history :-)
14:52:55 <dcoutts> so none of that idl nonsense :-)
14:53:15 <astrolabe> shapr: I was going to say that!
14:53:34 <shapr> On the good side, it's better visibility for Leonardo Da Vinci, and that's always good.
14:54:16 * Igloo read dVC first, and thought it was good fun. Then A&D which seemed to be pretty much isomorphic to dVC, which was a bit disappointing, but it was DF that I found /really/ painful
14:54:17 <conal> igloo: i guess i've read three.  the author i'm especially enjoying right now, though, is Daniel Quinn.  Kimberly Burchett put me onto him..
14:54:21 <shapr> I got a lot of my interest in programming and inventing from a massive book on Leonardo my mother owned. It included many pages of his sketch books.
14:54:24 <astrolabe> What did he invent the unicycle or something?  ;)
14:55:06 <shapr> Igloo: I was thinking of reading A&D next, I've only read dVC.
14:55:15 <conal> dcoutts: great.  that'll simplify things considerably
14:56:08 <hyrax42> no!
14:56:11 <hyrax42> say it ain't so
14:56:22 <hyrax42> da vinci code and reading another
14:56:22 <hyrax42> ?
14:56:24 <hyrax42> :(
14:56:40 <shapr> Well, I'm completely out of fiction books to read.
14:56:41 <Igloo> languagelog has some interesting criticism of him from a literary PoV too, e.g. http://itre.cis.upenn.edu/~myl/languagelog/archives/000844.html
14:56:50 <hyrax42> hardly an excuse
14:56:51 <hyrax42> hmph!
14:57:04 <lispy> shapr: into harry potter at all?
14:57:11 <shapr> lispy: Read 'em all.
14:57:16 <conal> shapr: i recommend Ishmael or The Story of "B", by Daniel Quinn.
14:57:19 <xerox> shapr: exactly :-)
14:57:30 <xerox> (sorry, connection problems <grin>)
14:57:31 <lispy> shapr: ah, okay, same here :)
14:57:37 <shapr> conal: Thanks, I'll look those up.
14:58:08 <shapr> I had a lot of fun reading baen.com/library
14:58:11 <shapr> I read those over the summer.
14:58:20 <hyrax42> shapr, read Foucault's Pendulum?
14:58:25 <conal> shapr:  cool.  you might notice philosophical connections with nonviolent communication
14:58:53 <shapr> hyrax42: Yeah, it was cute.
14:59:15 <shapr> I'd like to read it in Italian, but I doubt I'll pick up Italian anytime soon.
14:59:25 <hyrax42> hmm
14:59:26 <shapr> I have been reading some fiction original written in Swedish, that's cool.
14:59:26 <Heffalump> surely communication is inherently nonviolent? :-)
14:59:31 * shapr smacks Heffalump 
14:59:42 <hyrax42> well there are better books than Dan Brown's to read
15:00:02 <shapr> hyrax42: Yeah, but I've read everything I have access to, except for a very small number of books, including Angels & Demons.
15:00:16 <hyrax42> well given the situation, it might be excusable
15:00:22 <hyrax42> :p
15:00:28 <Heffalump> shapr: sticks and stones... :-p
15:00:47 <shapr> So, if you know of good free online books, I'm interested.
15:00:58 * Heffalump books for ICFP (etc)
15:00:58 <shapr> I've looked through Project Gutenberg, but it's hard to find something I want to read.
15:01:03 <hyrax42> you could hit up the good old Project Gutenburg
15:01:05 <hyrax42> ah
15:01:12 <hyrax42> well there's stuff there
15:01:13 <hyrax42> ?
15:01:14 <astrolabe> I read the invisable man online (well, on my pda)
15:01:14 <hyrax42> :/
15:01:17 <shapr> If you have recommendations, I'm listening :-)
15:01:18 <hyrax42> I never looked much
15:01:36 <conal> shapr:  Try my favorite author: http://barrie.thefreelibrary.com
15:01:37 <hyrax42> War of the Worlds is the only one I can think of due to recent movie events
15:01:56 <hyrax42> Lewis Carol's stuff should be there
15:01:58 <hyrax42> Jane Austen?
15:02:06 <shapr> I've read Jane Austen.
15:02:29 <conal> wow:  lots more jm barrie books online:http://onlinebooks.library.upenn.edu/webbin/book/search?author=barrie+j+m&amode=start
15:02:36 <shapr> In high school, I read the entire library in the first six months. Admittedly, it was a small school :-)
15:02:40 <astrolabe> Shakespear?
15:02:48 <shapr> I haven't read Shakespeare yet.
15:03:01 <astrolabe> Tough going, I know.
15:03:13 <shapr> Not that, just that I get frustrated cause I miss so many of the jokes.
15:03:29 <astrolabe> Yeah, it is better for me to read it with a commentry.
15:03:38 <astrolabe> You could get the sonnets though.
15:03:47 <shapr> That's a good idea.
15:07:15 <shapr> conal: I think I'll enjoy reading Barrie, thanks for the suggestion.
15:08:07 <shapr> I'll try Shakespeare too, I wonder if it's easier to understand now that I'm a bit older.
15:08:48 <cm> how old are you?
15:09:34 <shapr> I was born on the same day as the guy who won the Tour de France.
15:11:16 <Igloo> Did you win the Tour de France? On a unicycle?
15:11:22 <shapr> No, maybe next year ;-)
15:11:29 <astrolabe> shapr: I find it is easier these days for some reason.
15:11:45 <shapr> astrolabe: I wonder if it's because of increased life experience?
15:12:00 <shapr> I'm thirty three now, and the last time I really tried to read Shakespeare I was in my early twenties.
15:12:37 <astrolabe> shapr: That might increase my apprechiation, but I think mostly it is an increased vocabulary.
15:13:03 <cm> different priorities in life :)
15:13:38 <heatsink> grammar also was a little bit different five hundred years ago.
15:13:42 <astrolabe> Maybe also grammar.  Apparently english was an inflected language then, and they didn't have present participles.
15:13:54 <astrolabe> heatsink: snap.
15:14:13 <heatsink> I learned "tu" in spanish class before I understood "thee".
15:14:15 <lispy> inflected?
15:14:57 * astrolabe finds he has to look it up again :(
15:15:04 <heatsink> I have a kind question... http://www.haskell.org/hawiki/HaskellIrcPastePage
15:15:11 <dcoutts> @hoogle Int -> Double
15:15:12 <lambdabot> Prelude.toEnum :: Enum a => (Int -> a)
15:15:12 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => (a -> b)
15:15:12 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => (a -> b)
15:16:10 <ulfdoz> bye
15:16:25 <astrolabe> Can't find it.  I think it means that different persons get different forms of the verb.
15:16:28 <heatsink> unkay bye ulfdoz
15:16:35 <dcoutts> conal, can you recall what the type of "fromInt" was supposed to be?
15:16:45 <dcoutts> it's not a function that exists anymore
15:16:48 <astrolabe> He goeth etc.
15:17:01 <heatsink> English is still that way.
15:17:09 <shapr> @type fromInteger
15:17:10 <lambdabot> forall a. (Num a) => Integer -> a
15:17:13 <heatsink> He are, I is, They am.
15:17:38 <shapr> dcoutts: fromIntegral . fromInteger ?
15:17:45 <conal> probably like fromInteger, but s/Integer/Int
15:17:50 <dcoutts> shapr, ok, I;ll try
15:18:17 <astrolabe> heatsink.  only a little.  'to be' has different forms, but most verbs just put an 's' on the second person singular.
15:18:28 <dcoutts> @type fromIntegral . fromInteger
15:18:29 <lambdabot> forall b. (Num b) => Integer -> b
15:19:07 <wagle> heatsink: type Data = (Int,Int,Int)
15:19:08 <wagle> type TempMin = Int
15:19:22 <wagle> stupid paste
15:19:40 <wagle> heatsink: can't use type synonym in instance head
15:20:07 <dcoutts> shapr, it's the other way round :-)  fromInteger . fromIntegral
15:20:17 <heatsink> oh.  That's annoying.
15:21:33 <Igloo> fromInteger . fromIntegral == fromIntegral
15:22:02 <shapr> dcoutts: oops
15:22:02 <wagle> oh..  hmmm..  ghci appears to try to expand type synonyms before anything else..
15:22:13 <wagle> hugs just made the complaint i gave
15:22:45 <Igloo> hugs is following what the report says
15:22:48 * heatsink writes do {x <- FooProc $ blah; y <- FooProc $ bla x; FooProc $ blah; FooProc $ blah}
15:22:54 <wagle> type synonyms are macros?
15:23:16 <heatsink> I guess you're right.
15:23:19 <Igloo> In some sense, I guess, but macros aren't an official concept in Haskell 98
15:23:24 <heatsink> I hadn't thought of 'em as macros.
15:23:51 <wagle> man, i hated that in pascal, too
15:24:45 <Enveigler> How do I tell if the version of ghc I have has thread support?
15:24:49 <lispy> type synonyms are just meant as a secondary notation really
15:27:53 <dcoutts> Enveigler, what ghc version are you using?
15:28:19 <dcoutts> and which sort of thread support do you mean? it comes in various flavours :-)
15:28:40 <Enveigler> C:\ghc\ghc-6.4\bin>ghc -V
15:28:40 <Enveigler> The Glorious Glasgow Haskell Compilation System, version 6.4
15:28:53 <dcoutts> well that's the latest version
15:29:51 <Enveigler> And I'm not really sure what I mean by thread support, but you mentioned -thread earlier today and I'm not sure if that's a build time or runtime option?
15:30:20 <dcoutts> the -threaded is a option you can pass to ghc when linking your program
15:30:34 <dcoutts> it's available in ghc-6.4 (and I think it was in 6.2 too)
15:30:51 <dcoutts> it says to use the threaded rts
15:31:11 <dcoutts> which is the thing that allows calling out to C to not block all other Haskell threads
15:31:41 <Enveigler_> dcoutts: Great. Thanks.
15:34:19 <Enveigler_> Night all.
16:13:48 <astrolabe> How do I evaluate a list of functions at a point?  ie I have [a->b] and a, and I want [b] ?
16:15:33 <dcoutts> [ f a | f <- fs ]
16:16:07 <dcoutts> astrolabe, see?
16:16:13 <astrolabe> Thanks, haskell is so cool!
16:16:17 <astrolabe> Yes, thanks.
16:16:23 <dcoutts> :-)
16:23:14 <conal> or, of course, "map ($a) fs"
16:23:39 <dcoutts> @pl [ f a | f <- fs ]
16:23:40 <lambdabot> [f a | f <- fs]
16:23:49 <conal> i was just wondering the same.
16:24:00 <dcoutts> hmmpf @pl doesn't support list comprehsnions
16:24:05 <conal> :(
16:24:07 <dcoutts> @pl map ($a) fs
16:24:08 <lambdabot> map ($ a) fs
16:24:19 <dcoutts> oh, of course
16:24:30 <Lemmih> and '[ f a | f <- fs ]' is already pointless.
16:24:44 <dcoutts> @pl map (\f -> f a) fs
16:24:45 <lambdabot> map (flip id a) fs
16:25:06 <dcoutts> interesting
16:25:19 <dcoutts> @type flip id
16:25:20 <lambdabot> forall b c. b -> (b -> c) -> c
16:25:28 <dcoutts> @type ($)
16:25:29 <Lemmih> Oh wait. It *is* pointed.
16:25:29 <lambdabot> forall b a. (a -> b) -> a -> b
16:25:40 <conal> flip id == flip ($)
16:25:51 * Lemmih goes back to sleep.
16:26:02 <conal> so flip id a == flip ($) a == ($ a)
16:26:32 <dcoutts> yes, I see
16:26:51 <conal> i'm guessing that's what you meant by "oh, of course"
16:27:21 <dcoutts> I was realising that the expression was already point free
16:27:52 <conal> in that list comprehension desugars to point-free form?
16:28:21 <dcoutts> I knew list comps, turn into map & filter
16:29:18 <TheHunter> @pl [(|) (f a) ((<-) f fs)]
16:29:19 <lambdabot> [f a | (f <- fs)]
16:30:12 <dcoutts> huh? that's not even ok syntax
16:30:23 <TheHunter> @pl [(<-) ((|) (f a) f) fs]
16:30:24 <lambdabot> [f a | f <- fs]
16:30:48 <dcoutts> I don't get the (|) bit
16:30:57 <dcoutts> and neither does ghci :-)
16:31:18 <TheHunter>  @pl's parser isn't a haskell parser.
16:31:20 <goron_> dcoutts: Most likely it's TheHunter's own little hack.
16:31:45 <TheHunter> thus it does not know that '<-' and '|' are special and treats them just like normal operators.
16:31:53 <goron_> TheHunter contributed some code to lambdabot if I recall correctly.
16:32:20 <TheHunter> supporting list comprehensions is on the 'todo list'
16:32:21 <dcoutts> TheHunter, I see :-)
16:32:27 <dcoutts> cool
16:32:42 <dcoutts> so list comprehensions are point free?
16:32:54 <goron_> TheHunter: do you use Haskell mode (emacs)?
16:32:57 <TheHunter> list comprehensions are clearly pointful.
16:33:02 <dcoutts> the "f <- fs"  looks like a point to me
16:33:03 <TheHunter> no, i use vim.
16:33:37 <goron_> TheHunter: Has vim any useful Haskell mode (beyond the one available 1.5 years ago)?
16:34:09 <TheHunter> i don't think so. I didn't even get hasktags to work.
16:34:21 <dcoutts> TheHunter, so you'll just translate the list comps into the equivalent map & filter expressions and then run the normal pl on that?
16:34:37 <TheHunter> yes, that's the idea.
16:35:45 <goron_> TheHunter: why do you want everything pointless?
16:36:06 <TheHunter> but @pl's parser is an ugly hack and hard to extend. And it has exponential complexity.
16:36:18 <dcoutts> goron_, because it's funny?
16:37:02 <dcoutts> TheHunter, you can't use the existing Haskell parser?
16:37:43 <goron_> dcoutts: No, some people only use pointfree code. I don't understand their motivations, though.
16:38:22 <dcoutts> TheHunter, Language.Haskell.Parser?
16:38:29 <reffie> http://people.freebsd.org/~ssouhlal/stuff/ninni7.jpg
16:38:46 <goron_> reffie: I have her .emacs file :)
16:38:49 <TheHunter> goron_, i'm not one of those people. pointless style is usually an obfuscation, but it helps every now and then.
16:38:56 <dcoutts> goron_, apparently point-free code can be easer to manipulate algabraicly
16:38:56 <goron_> reffie: I was jealous of it.
16:38:57 <reffie> goron_ that would be mine :P
16:39:09 <goron_> reffie: :?
16:39:14 <TheHunter> dcoutts, there was some argument against that i don't recall right know.
16:39:20 <reffie> goron_ .emacs
16:39:26 <goron_> reffie: Did you pass it to her, or are you her?
16:39:43 <reffie> goron_ her pictures are on my web space
16:40:08 <dcoutts> TheHunter, in general it's not that great since it doesn't understand any extensions etc, but for pl, you only need H98
16:40:09 <goron_> reffie: The geek with webspace... oooeehhh. ;)
16:40:19 <reffie> goron_ heh.
16:40:53 <goron_> reffie: configuring emacs is an addictive.
16:40:59 <goron_> er strip an
16:42:27 <goron_> reffie: http://people.freebsd.org/~ssouhlal/stuff/reffie_gets_eaten_by_monster.jpg
16:42:34 <goron_> lol
16:42:37 <reffie> :P
16:42:38 <dcoutts> nice
16:42:59 <goron_> reffie: Did she draw it?
16:43:04 <reffie> no
16:43:07 <reffie> someone else did
16:43:22 <heatsink> was that a soft pencil?
16:43:28 <reffie> i have no clue
16:45:41 <goron_> reffie: Her name is evil for my vocal chords, though.
16:45:52 <reffie> ?
16:45:52 <reffie> why
16:47:40 <goron_> reffie: It's just an uncommon name here. Ofcourse I can say it.
16:47:58 <reffie> it's not her real name
16:48:03 <goron_> Whose company is OffMyServer? I saw the name before.
16:48:19 <reffie> google is your friend?
16:48:52 <batkins_> is haskell considered purely functional?  does the existence of do disqualify it?
16:48:56 <goron_> reffie: I meant more like who on IRC. I thought somebody in the channel owned it.
16:49:04 <goron_> batkins_: yes, no.
16:49:15 <reffie> goron_ hm
16:52:14 <goron_> reffie: OffMyServer doesn't state who the owner is. So, it seems that Google also wouldn't.
16:52:21 <dcoutts> conal, I got Compiler.lhs to build
16:52:24 <reffie> goron_ :(
16:53:04 <dcoutts> conal, only backend left after stripping out everything that wouldn't build is Standalone :-)
16:53:18 <dcoutts> no more UI, DirectX, COM :-)
16:53:44 <dcoutts> I'm not sure if there's anything left that will work however...
16:54:24 <dcoutts> conal, how would I create a C code file from a simple pan demo?
16:54:50 <dcoutts> and what would the interface of the generated C code be?
16:54:58 <TheHunter> does Language.Haskell.Parser treat fixities correctly?
16:55:42 <dcoutts> TheHunter, probably easiest way is to experiment, or look at the code :-(
16:57:07 <goron_> What are fixities? (dict.org is down)
16:57:51 <goron_> Well, not really down, it's being blocked by my proxy.
16:57:57 <TheHunter> argh, ghci-6.5.20050723 is broken.
16:58:00 <Pseudonym> The fixity of an operator is whether it's prefix, postfix or infix.
16:58:06 <goron_> Oh, ok.
16:58:20 <Pseudonym> At least that's all that's relevant in most languages.
16:58:27 <Pseudonym> Prolog has a very rich set of fixities.
16:58:31 <astrolabe> and it's precidence
16:58:37 <astrolabe> *its
16:58:42 <Pseudonym> Precedence is different from fixity.
16:58:44 <goron_> Pseudonym: I don't now any language that's postfix.
16:58:48 <goron_> er know
16:58:52 <Pseudonym> There's a postfix ++ and -- in C.
16:58:57 <goron_> ah, yes
16:58:59 <goron_> I do know.
16:59:01 <goron_> heh
16:59:02 <Pseudonym> :-)
16:59:21 <Igloo> That's not how it tends to be used in Haskell, IME
16:59:21 <Igloo> fixity is, e.g., infixl 5
16:59:24 <Pseudonym> Basically, in an operator grammar, each operator is defined by precedence, associativity and fixity.
16:59:27 <dcoutts> Haskell only has infix (except prefix -)
16:59:37 <goron_> And no compiler implementor knows how to do it correctly. :D
17:00:06 <dcoutts> I don't know why Haskell doesn't allow prefix and postfix operators
17:00:16 <goron_> For clarity.
17:00:18 <Pseudonym> It did pre-98.
17:00:24 <goron_> I guess
17:00:29 <dcoutts> Pseudonym, really? cool
17:00:30 <Pseudonym> It was removed because H98 was a simplification.
17:00:44 <dcoutts> hmmm
17:00:48 <Pseudonym> And they arguably didn't add that much.
17:01:13 <goron_> pre-98... ancient history.
17:01:21 <dcoutts> but think of the obfsucation possabilites!
17:01:23 <astrolabe> Pseudonym: I stand corrected.
17:02:55 <astrolabe> "A fixity declaration gives the fixity and binding precedence of one or more operators"
17:03:18 <Pseudonym> Right.
17:03:32 <Pseudonym> Hmmm.
17:03:50 <Pseudonym> In fact, there are three things there.
17:04:04 <Pseudonym> "infix" - fixity, "l" - associativity, "5" - precedence
17:04:44 <goron_> Pseudonym: But the infix is redundant information.
17:04:53 <Pseudonym> It wasn't pre-H98.
17:05:00 <goron_> Pseudonym: no, but it is now.
17:05:04 <goron_> :)
17:05:11 <Pseudonym> Sure, but they just kept the same syntax.
17:05:15 <dcoutts> so we could still bring it back :-)
17:05:18 <Pseudonym> Right.
17:05:24 <goron_> Just like you having an appendix.
17:05:35 <goron_> Lazyness of evolution.
17:05:55 <Pseudonym> But as dcoutts just pointed out, it's also future-proofing.
17:06:09 <metaperl> Pseudonym: would you be willing to write a C++ version of quicksort that used templates so that the "Why Haskell Matters" article is more objective?
17:06:24 <Pseudonym> Er... OK.
17:06:34 <Pseudonym> I think I have one around here somewhere.
17:06:43 <goron_> Have you seen the Qi language?
17:06:50 <metaperl> goron_: no
17:06:52 <metaperl> goron_: link?
17:07:00 <Pseudonym> Actually I think it's a ternary quicksort.
17:07:07 <Igloo> Even if I wasn't going to give a choice ever, I'd still say infix
17:07:10 <goron_> metaperl: http://www.lambdassociates.org/
17:09:49 <metaperl> goron_: I'm reading. Thanks
17:12:02 <metaperl> interesting assertions about it's type system
17:12:31 <goron_> Check out the examples.
17:12:46 <goron_> It's infinitely cool.
17:13:11 <metaperl> :)
17:13:12 <goron_> You can do advanced type hackery, without .... type hackery.
17:13:38 <metaperl> on thing that has bothered me about the Haskell type classes is that you cannot have quantity limits on a type
17:13:58 <goron_> The problem might be that the code can not be compiled to native code yet.
17:14:14 <goron_> (and I didn't get it too install yet on my system)
17:14:17 <metaperl> e.g. a binary tree cannot be a specialization of a tree with the restriction of it having two nodes max per parent
17:14:24 <goron_> (but I didn't try very hard)
17:14:27 <metaperl> there's no way to force that restriction at type-level
17:14:40 <metaperl> if any expert cares to straighten me out, I'm all ears :)
17:14:55 <dcoutts> metaperl, you want to do what exactly?
17:15:26 <goron_> dcoutts: Didn't you ask about list comprehensions earlier?
17:15:43 <dcoutts> goron_, yep
17:16:14 <metaperl> let's say I have a type Tree in which a node can have any number of children... a reasonable subtype of Tree might be BinaryTree, which is limited by it having only two children per parent... but you cannot enforce said restriction when defining the type ... so where would you?
17:16:19 <goron_> dcoutts: Then this is probably something you don't want to know yet,
17:16:32 <dcoutts> goron_, we were talking about point free style
17:16:45 <dcoutts> (I'm not a Haskell newbie)
17:16:47 <metaperl> I think dcoutts was on the winning ICFP team last year
17:16:49 <metaperl> :)
17:16:51 <Cale> metaperl: there may be a way to do that, but it would be somewhat unwieldy
17:16:52 <goron_> dcoutts: Oh, ok.
17:16:55 <metaperl> d is for duncan
17:17:02 <dcoutts> metaperl, :-)
17:17:03 <goron_> Oh, I know you.
17:17:06 <Cale> metaperl: Have you read the HList paper?
17:17:11 <goron_> We talked earlier.
17:17:14 <metaperl> Cale: but isn't it important? no I havent read that
17:17:29 <dcoutts> goron_, remind me
17:17:41 <dcoutts> (too many irc nick to remember!)
17:17:59 <Cale> http://homepages.cwi.nl/~ralf/HList/
17:18:01 <goron_> dcoutts: I will dig in the logs(same problem here)
17:18:25 <dcoutts> metaperl, you might be able to do something cunning with an encoding of numbers as types
17:18:36 <Cale> metaperl: I haven't found that to be too much of a restriction... if you want both types to have common functionality, you can make them both members of a typeclass.
17:19:04 <dcoutts> eg have a general Tree with a parameter that represents its degree, encoded in some manner
17:19:21 <Cale> Sure, it would be nice to have certain things automatically derived from the most general implementation on rose trees
17:19:55 <dcoutts> obviously with dependent types this would be trivial...
17:20:26 <Cale> A lot of those sorts of things (map and fold, etc over general tree-like structures) can be done with generic Haskell if it's really an issue.
17:24:13 <goron_> dcoutts: We talked about the implementation of theming GUIs.
17:24:26 <dcoutts> oh right, I remember
17:24:30 <goron_> http://tunes.org/~nef/logs/haskell/05.06.02
17:39:19 <sylvan> metaperl, psudonum: the c++ version in "why haskell matters" does use templates, only none of the examples use libraries... At any rate it wasn't meant as a direct comparison, but if one were to make a direct comparison using STL isn't exactly fair either since that's highly geared towards that type of operations, whereas the haskell qsort is concise because the _language_ is concise
17:54:53 <TheHunter> oh, goron_ is gone. I just found out the current ghci-cvs can produce a tags file readable by vim.
17:55:22 <dcoutts> how does that work then? I use vim
17:56:11 <TheHunter> you type :ta -c at the ghci prompt. It's not overly smart but definitely an improvement.
17:56:31 <dcoutts> ok
17:57:00 <TheHunter> of course, i only noticed that because ':t foo' no longer works :(
17:57:21 <dcoutts> oh, that's not good
17:57:28 <Igloo> heh
17:57:38 <Igloo> Does it get confused about ambiguity or something?
17:58:01 <TheHunter> yep, :t could mean :type or :tags.
17:58:10 <dcoutts> if so, can't we have defaults? I can't live without :t !
17:58:30 <dcoutts> that should be ":t (!)" :-)
18:00:10 <wagle> @type (!)
18:00:11 <lambdabot> bzzt
18:00:20 <wagle> >)
18:00:29 <dcoutts> @type (Array.!)
18:00:30 <lambdabot> forall e i.
18:00:30 <lambdabot>      (GHC.Arr.Ix i) =>
18:00:30 <lambdabot>      GHC.Arr.Array i e -> i -> e
18:00:45 <dcoutts> @type (!!)
18:00:46 <lambdabot> forall a. [a] -> Int -> a
18:00:47 <Igloo> Doesn't quite have the same ring, sadly
18:00:57 <Igloo> Ah, !! might do it
18:01:11 <wagle> that should be ":t (Array.!)" *<8-)
18:01:38 <dcoutts> I think Igloo's right
18:02:09 <wagle> @type (!?!)
18:02:11 <lambdabot> bzzt
18:02:21 <wagle> @index (!?!)
18:02:22 <lambdabot> bzzt
18:02:26 <wagle> 8(
18:02:38 <dcoutts> @type wtf (!!?)
18:02:39 <lambdabot> bzzt
18:02:48 <Igloo> I usually am.
18:02:53 <TheHunter> hasktags still doesn't work :(
18:03:06 <dcoutts> Igloo, yeah yeah
18:03:09 <Igloo> :-)
18:03:14 <dcoutts> :-)
18:16:04 <TheHunter> ah, http://www.haskell.org/pipermail/cvs-ghc/2005-June/025436.html
18:17:18 <dcoutts> TheHunter, you've sent in your bug report already or shall I do it?
18:17:57 <TheHunter> no, i haven't, you can go ahead.
18:18:06 <dcoutts> ok
18:22:12 <dcoutts> done
18:23:06 <TheHunter> great!
18:59:24 <Enveigler_> @type Monad.liftM
18:59:25 <lambdabot> forall r (m :: * -> *) a1.
18:59:25 <lambdabot>      (Monad m) =>
18:59:25 <lambdabot>      (a1 -> r) -> m a1 -> m r
19:00:00 <Enveigler_> @type mapM
19:00:01 <lambdabot> forall b (m :: * -> *) a.
19:00:01 <lambdabot>    (Monad m) =>
19:00:01 <lambdabot>    (a -> m b) -> [a] -> m [b]
19:00:10 <dcoutts> this is clearer: Monad m => (a -> b) -> (m a -> m b)
19:00:28 <Enveigler_> Morning dcoutts :)
19:00:43 <dcoutts> I should go to bed!
19:00:44 <Enveigler_> I've learnt to ignore the first bit.
19:01:15 <dcoutts> but also the names of the vars are not so helpful in that first one
19:01:18 <Enveigler_> I tried to sleep, but my brain wouldn't shut down.
19:02:51 <Enveigler_> I'm just going over our earlier conversation .. I think some stuff clicked for me and I want to reenforce it while it's still making sense.
19:03:18 <dcoutts> yep
19:03:19 <fnord123> hello all. Quick question about building darcs on OSX - I'm getting a problem linking stringify - it says __DISCARD__ isn't defined. However, a quick grep agrees its not defined as no one even refers to it.
19:03:26 <fnord123> anyone know a workaround to this?
19:03:54 <dcoutts> fnord123, if no-one here knows you might try #darcs
19:04:31 <fnord123> didnt know about that one. cheers
19:04:38 <aheller> fnord123: I had a bunch of trouble with ghc-6.2 vs ghc-6.4 whin I tried...
19:04:39 <dcoutts> np
19:04:41 <aheller> but that was a while ago.
19:04:56 <Igloo> That's a GHC problem, not a darcs problem
19:06:24 <Enveigler_> How do I read a binary file in Haskell?
19:06:51 <dcoutts> reading it is easy, parsing it is the tricky one
19:07:06 <dcoutts> its it a file where you choose the format, or externally defined?
19:07:28 <Enveigler_> Externally defined (badly) .wav format
19:08:42 <dcoutts> well you can use the Foreign features, ie read the data into memory and then use peek
19:09:02 <Enveigler_> I was thinking abut trying to use gtk2hs to plot wav files on the screen. and then (maybe) trying to implement the Wavelet Transform.
19:09:03 <dcoutts> or you could use ghc's Binary module (a bit tricky to start with)
19:09:11 <dcoutts> cool
19:09:33 <dcoutts> you've come to the right place for gtk2hs questions :-)
19:10:02 <Enveigler_> It's something I've been playing with in Perl, but Haskell would be much better suited to doing the heavy math
19:10:30 <dcoutts> I wonder if it'd be possible to get parsec to help with binary files
19:10:53 <Enveigler_> Well, if you've got a sample "pop up a canvas and plot some polylines" code I'll take that to get me started
19:11:12 <dcoutts> what's a polyline ?
19:11:55 <Enveigler_> It might be easier to pre-process the .wavs with Perl and write the datapoints in a words freindly format intitally.
19:12:16 <dcoutts> maybe
19:12:19 <Enveigler_> just a line connecting a series of points.
19:12:33 <dcoutts> straight lines connecting points?
19:12:40 <Enveigler_> Yes.
19:12:50 <dcoutts> ok, not too hard then
19:13:51 <dcoutts> the demo/graphic/Drawing.hs should help
19:14:26 <dcoutts> it draws a bunch of connected straight lines on a canvas
19:14:58 <Enveigler_> That comes with the gtk2hs install?
19:15:22 <dcoutts> it's in the Gtk2Hs tarball, but doesn't typically get installed
19:16:19 <Enveigler_> I haven't installed gtk2hs yet. I'll go look now.
19:17:07 <Enveigler_> The gtk method is GdkDrawable::draw_lines probably invoked on a pixmap.
19:17:27 <dcoutts> yep
19:17:49 <dcoutts> you can see it in the demo, eg: drawLines win gc [(30,30),(width-30,height-30),(width-30,30),(30,height-30)]
19:19:53 <Enveigler_> Great. gtk2hs is downloading..but it'll take aabout 1/2 hour.
19:20:06 <dcoutts> slow connection :-(
19:20:16 <wagle> i installed gtk2hs last night..  a couple of the demos didnt work
19:20:27 <dcoutts> wagle, really,which ones
19:20:47 <Enveigler_> Yeah. 56k (40k most times). I'm too far from my local exchange for ADSL
19:20:49 <dcoutts> (I'm just working on the 0.9.8.1 bug fix release)
19:23:19 <dcoutts> Enveigler_, actually it shouldn't be too hard to do WAV parsing in Haskell, the WAV has a fixed header right?
19:23:21 <wagle> mozembed, sourceview wouldnt compile..  two more died on startup
19:24:28 <dcoutts> wagle, the mozembed and sourceview packages failed during build, or the were simply disabled (because deps were missing)?
19:24:51 <Enveigler_> There are multiple formats. The forst header idenmtifies the second and that describes the interpretation of the data section.
19:24:51 <wagle> i dont remember
19:25:21 <dcoutts> wagle, a full bug report would be much apreciated :-
19:25:28 <dcoutts> :-)
19:26:34 <dcoutts> Enveigler_, so you'd create a Haskell data type (probably a record) representing the header and then make it an instance of Storable, using peekByteOff
19:26:56 <Enveigler_> Sounds scary :)
19:27:21 <wagle> a lot of the buttons were in swedish [?]
19:27:32 <Enveigler_> I'm guessing that the multiple formats (see http://www.borg.com/~jglatt/tech/wave.htm) could be taken care of by some sort of varient record.
19:27:47 <dcoutts> then you'd use one of the functions from Foreign.Marshal.Alloc to allocate the space and then use hGetBuf to read it in
19:28:05 <dcoutts> Enveigler_, yes a reasonable approach
19:28:31 <dcoutts> wagle, huh?
19:28:57 <dcoutts> wagle, I didn't think we had any translatable bits
19:29:09 <dcoutts> perhaps some of the stock buttons have translations
19:29:15 <shapr> wagle: talar du inte svenska? Det Ã¤r sÃ¥ lÃ¤tt!
19:29:42 <wagle> @babbelfish 8-p
19:29:43 <lambdabot> Unknown command, try @listcommands.
19:29:46 * shapr grins
19:30:14 <shapr> That was just some smart remarks about Swedish being so easy to understand :-)
19:30:32 <wagle> i'm not easy
19:30:44 <wagle> afslut
19:31:02 <shapr> adaptive functional ... ?
19:31:03 <wagle> ^^^ is that swedish?
19:31:33 <shapr> Could be actually. I think it's avslut for "close", but that's pretty close.
19:32:22 <wagle> its a stock button, but i didnt figure out where it was holding the strings
19:32:31 <dcoutts> gotta go.. (need to reboot into amd64 mode to build some binary packages of ghc for gentoo)
19:35:07 * shapr boings cheerfully
19:36:17 * Pseudonym yawns
19:36:21 <aheller> shapr: I meant to ask, is there a similarity between steele's pseudomonads in that paper you referenced and arrows?
19:39:44 <shapr> aheller: I'm not sure. I remember that Steele's monad flavors and Espinoza's striated monads and some other stuff all happened at about the same time before monad transformers were deemed the best choice.
19:39:49 <shapr> g'day Beelsebob
19:40:31 <Beelsebob> mornin
19:40:49 * Beelsebob just had a rediculous argument on #macdev
19:41:08 <Beelsebob> ... I know it was going down hill when one of them claimed that the parser was not part of a compiler
19:41:16 <Beelsebob> and that compilers were given an AST
19:41:17 <aheller> :)
19:46:23 <Enveigler_> dcoutts: http://heanet.dl.sourceforge.net/sourceforge/gtk2hs/gtk2hs-0.9.8.exe doesn't install. It fails at the first click with "Invalid rootkey value"?
19:46:34 <Enveigler_> Oh. He left.
19:46:51 <Enveigler_> Hi shapr
19:48:43 <wagle> some compilers ARE given AST's..  take a look at LLVM
19:49:52 <Beelsebob> yeh... but 99.99% of them arent
19:50:02 <Beelsebob> and given that the example was cc
19:50:15 <Beelsebob> this statement was in fact bullshit
19:50:33 <wagle> scheme compilers parse s-expressions (from heap memory), not strings
19:50:51 <Beelsebob> hmmm?
19:50:55 <wagle> LLVM is a modification of gcc
19:51:05 <Beelsebob> presumably at some point these have been read from a file though
19:51:15 <Beelsebob> and processed into s-expressions
19:51:16 <wagle> not with macros
19:51:21 <Beelsebob> hmm?
19:51:28 <wagle> or other on-line program generators
19:51:47 <Beelsebob> ah, i see
19:53:07 <wagle> still, he should have realized that he was making a radical statement
19:53:17 <Beelsebob> indeed
19:53:30 <Beelsebob> and being that we were talking about fairly normal circumstances
19:53:44 <wagle> and things could quite reasonably be argued either way
19:54:06 <Beelsebob> ... in fact, I was merely giving parsing as a good example of what functional languages could do
19:54:23 <Beelsebob> and he was attempting to ask where was parsing ever used...
19:54:27 <Beelsebob> silly person
19:54:36 <wagle> well, more than compilers use parsers
19:54:54 <shapr> hiya Enveigler_
19:55:02 <Beelsebob> indeed
19:55:07 <Beelsebob> just a good example
19:55:12 <shapr> Enveigler_: How's your wrestling match with Haskell going?
19:55:41 <Enveigler_> Sloowly. But I am trying again.
19:56:42 <Beelsebob> damn it... how has my peircing got infected now?????
19:56:43 <shapr> I hope it works out well for you :-)
19:56:48 <Enveigler_> I got fired up to try and parse a wav file and plot the data using gtk2hs--but I can't get the latter to install :)
19:57:01 <Beelsebob> It's been infection free and healed for bloody ages, and now it gets infected?
19:57:06 <shapr> Enveigler_: That sounds like a nifty application, I'd like to plot out wav filse.
19:57:37 <shapr> The closest I get to a piercing is the pins on my MUni pedals =)
19:58:01 <Enveigler_> I've got it going (kinda) in Perl, but then I thought I'd like to try and implement the Wavelet Transform and Haskell is better for that.
19:59:04 <Enveigler_> Right now I'm trying to understand how to use the Foriegn.Stroable stuff that dcoutts pointed me at.
20:00:14 <Enveigler_> "Piercing pins" Sounds painful :)
20:02:21 <Beelsebob> hmm?
20:02:28 <Beelsebob> piercing pins?
20:03:27 <Enveigler_> " piercing is the pins" -- I misread :)
20:03:46 <Beelsebob> heh
20:03:55 <Beelsebob> yeh... now those *are* painful
20:04:18 <Beelsebob> you should try unicycling bare footed with aluminium spikes sticking out of your pedals
20:04:51 <Enveigler_> Brings back painful memories of my chain snapping ridding up a 1 in 7 hill. &*
20:05:09 <Beelsebob> hehe... this is why uikes are good...
20:05:13 <Enveigler_> riding even.
20:05:13 <Beelsebob> no chain
20:05:50 <Beelsebob> ... unless you're on a giraphe, in which case you get what you deserve ;)
20:06:02 <Enveigler_> I tried a uni once for about an hour. When I started getting bruises on my bruises I decided enough was enough.
20:06:16 <Beelsebob> hehe
20:06:30 <Beelsebob> ROFL @ google news...
20:06:36 <Beelsebob> current top story:
20:06:40 <Beelsebob> "Why does this page look this way?
20:06:40 <Beelsebob> New York Times - 26 minutes ago
20:06:40 <Beelsebob> It appears that your Web browser can not find this page's style and presentation information. You are welcome to use the page as is or, for the best experience, upgrade your browser to its latest version by ... "
20:07:32 <aheller> My roommate saw the more upsetting "UK Police Say More Innocents Could Die In Bomb Hunt"
20:07:53 <Beelsebob> heh... which is a misleading headline
20:07:58 <Enveigler_> I thought I might be good at it, I can (could) balance my trail bike (motorbike) on the rear wheel for ages.. But the need to waggle ones legs to inject power is a whole different kettle of fish.
20:08:08 <fnord123> "is it possible that more innocents could die in the bomb hunt?"
20:08:17 <Beelsebob> because what the actually said was "we can't guarentee we won't fuck up and shoot the wrong person again"
20:08:18 <aheller> The definition of a political blunder: they screwed up by telling the truth.
20:08:24 <Beelsebob> heh
20:08:55 <Beelsebob> enveigler: yeh... it's not so much that as having to do it continuously
20:09:06 <Beelsebob> ... this becomes useful when you want to stay in the same place
20:09:19 <fnord123> at least we dont have fox news here saying we should all be like sheep and comply with police. at least they call them murderers :)
20:09:31 <Enveigler_> STanding is easier. Sitting easier still :)
20:10:38 <Beelsebob> tbh... I hope nothing happens to the cop... it was the wrong decision, but it could just as easily have been the right one
20:11:13 <shapr> Enveigler_: Unicycling is great fun, you should try it.
20:11:18 <aheller> Beelsebob: I'm hearing a whole lot more sketchy stuff lately.
20:11:19 <Enveigler_> It's a tough call. Shoot and risk the innocent one, Dont shoot and risk the innocent 100 (including yourself) when he triggers the bomb.
20:11:22 <fnord123> why cant the bombers bomb the offices of the daily mail or the sun :-/
20:11:29 <shapr> fnord123: ha!
20:11:54 <shapr> I guess bombers require their weekly/daily dose of chick wearing only underwear.
20:11:59 <shapr> What're they called, page 5 girls?
20:11:59 <Enveigler_> I did once shapr. ! hour, and 30+ bruises later I decided it wasn;t for me.
20:12:04 <fnord123> page3
20:12:26 <Beelsebob> enveigler: my logic says don't shoot, because it's possible that the trigger is based on him relaxing his grip on something... so you're still risking those hundred others even if you kill him
20:12:33 <shapr> Enveigler_: It gets better. If you come to any of the Haskell parties I'll show you a much more comfortable unicycle seat.
20:13:03 <Beelsebob> hehe, as will I... but I suspect shapr's is nicer
20:13:08 <aheller> Certainly a shoot to kill policy will only increase the liklihood of them using dead-man's switches.
20:13:12 <fnord123> my logic says "oh look im a plain clothes cop so maybe he thought i was just some guy waving a gun and trying to murder him. oh look I am!"
20:13:32 <shapr> Enveigler_: This is me at EuroHaskell 2004 - http://andersca.org/gallery/eurohaskell/p1010015
20:13:51 <Beelsebob> except that it would kind of become clear when the guy with the gun yells "STOP! ARMED POLICE!"
20:14:06 <Enveigler_> Balance on a motor bike is controlled by planting the feet and arms and wiggling the upper body.
20:14:32 <Enveigler_> A uni is like being at a nudist colony--there's nowhere to put your hands ;)
20:14:33 <fnord123> i saw no reports that suggested they identified themselves
20:14:34 <Beelsebob> shapr: that's a miyatta saddle isn't it?
20:14:45 <Beelsebob> enveigler: lol
20:15:04 <metaperl> lol @ Enveigler_ 's unicycle quote !!! ROFL!!
20:15:38 * aheller finally realizes Enveigler_ was talking about pockets.
20:15:45 <metaperl> the "bruises" one has hilarious
20:16:23 <shapr> Enveigler_: That's good!
20:16:36 * Beelsebob takes photo of current uike setup
20:17:32 <Enveigler_> shapr: Nice pic.
20:19:25 * Enveigler_ thinks about the corrolation between unicyclists and haskellers--is there someting about "doing it the hard way"?  :)
20:20:27 <heatsink> minimalism, perhaps?
20:20:49 <fnord123> gnight
20:21:05 <shapr> I think it's about elegance.
20:21:11 <shapr> You just don't need all those extra crutches :-)
20:21:50 <Beelsebob> http://www.cs.kent.ac.uk/people/rpg/tatd2/uike.jpg
20:21:57 <Beelsebob> (bob's current toy)
20:23:03 <metaperl> after look at that picture of shapr my crotch is begging me to stay FAAAR away from unicycles
20:23:11 <shapr> metaperl: It's not that bad :-P
20:23:14 <Beelsebob> haha
20:23:21 <shapr> Beelsebob: Nice uni
20:23:25 <Beelsebob> it's only bad if you get a suicide mount wrong
20:23:27 <metaperl> it looks ... welll... shall we say... uncomfortable
20:23:39 <Beelsebob> it's fine... unless you mount wrong
20:23:51 <Beelsebob> note... a suicide mount means let go of the uike and jump
20:24:04 * Enveigler_ bows to shapr's elegance.
20:24:09 <shapr> metaperl: Here's the right way to do that - http://www.freewebs.com/andrewcarter/basictips.htm#nutbreaker
20:24:36 <Beelsebob> that about sums it up, yeh
20:25:12 <metaperl> me and my nuts are staying in front of this terminal and having fun with haskell and IRC.. thank you very much
20:25:21 <Beelsebob> haha
20:25:31 <metaperl> i was a skateboarder from age 17 to 30
20:26:03 <metaperl> I have enough injuries from that young male disease of Ego already... broken ankle, fractured wrist. I should have punctured lungs but I am lucky
20:26:46 <metaperl> I hit a pothole and high speed and fuckin' flew threw the air about 5 feet before landing and sliding 5 feet more
20:27:05 <metaperl> my ribs were killing me but luckily not really killing me
20:28:18 <shapr> Unicycles have larger wheels, can usually handle potholes.
20:28:25 <Beelsebob> hmm, there's not much you can do to injure yourself on a uike
20:28:38 <Beelsebob> the worst I've done is a couple of "superman dismount"s
20:29:25 <shapr> Anyway, it's not about Ego for me, it's about exploring elegance. Unis are much more agile and expressive than bicycles.
20:29:43 <Beelsebob> indeed
20:29:52 <shapr> So far I've only injured myself once on my uni, I got my first ever stitches last year.
20:30:08 <Beelsebob> it's quite fun when a porter tries to stop you for cycling... so you stop, reverse a little, and ride round him
20:31:32 <shapr> My unicycle injury happened because I fell forward onto gravel, and the gravel acted a bit like ball bearings. While sliding forward my kneepad slid down and I got gravel in my knee.
20:31:45 <Beelsebob> yeh - same thing's happened to me
20:32:01 <Beelsebob> I stopped about 10-15m from the uike
20:32:13 <Beelsebob> got a pretty good scar for that one
20:32:15 <shapr> Nowadays I have combined ankle/shin/knee pads, they don't slide at all.
20:32:36 <Beelsebob> yeh, I don't wear mine unless I'm doing muni stuff
20:32:47 <Beelsebob> but for muni it's all really important
20:32:54 <Beelsebob> especially the ancle ones
20:33:01 <Beelsebob> pretty easy to twist an ancle
20:33:45 * Enveigler_ sudders. Re-living painful memories of gravel rash aquired dismounting a m/bike at around 60 mph.
20:34:48 <Beelsebob> I was well pissed off when I broke my ankle
20:35:06 <Beelsebob> I'd just ridden over the local hill, and then got off, taken off the guards
20:35:08 <Beelsebob> walked in
20:35:16 <Beelsebob> and twisted it on the steps into the house
20:35:22 <shapr> Ow, that's gotta suck.
20:35:51 <Beelsebob> yeh... ankles only tend to suck the next day
20:36:17 <Beelsebob> 'twas the same when I last broke it... I broke it while on top of a hill (walking) and walked all the way back on it fine
20:36:45 <Beelsebob> was only the next day that it was the size of a football and so sore a feather would make me scream
20:39:28 <shapr> I've never broken anything, for some reason.
20:39:53 <Beelsebob> jammy
20:40:00 <Beelsebob> I hadn't until about a year ago
20:40:11 <Beelsebob> ... or at least I didn't think I had
20:41:21 <Beelsebob> when I broke my ankle (first time) they asked if I'd done it before... and showed me an old break that I had had since I was 12 or 13
20:41:28 <Beelsebob> ... but I don't ever remember doing it
20:42:08 <shapr> Huh, wow
20:43:03 <Beelsebob> then in the last year I've broken my ankle twice, my elbow, and my finger
20:44:25 <Beelsebob> it's rather disconcerting when you realise that your elbow isn't meant to go in the direction it is
20:45:49 <shapr> yikc
20:53:32 <Enveigler> Hmm. Mapping compound data structures is hard.
20:56:45 <shapr> How so?
20:58:15 <Enveigler> Cos I don't know how to do it? :)
20:58:42 <aheller> Gah!  Is there some babystep way to get the state monad to do something?
21:00:23 <shapr> aheller: I think there are some tutorials on the wiki.
21:00:46 <aheller> I have no idea what my block is here.
21:00:50 <Enveigler> ...and I'm perpetually confused about when I should be using data and when I should use type (and newtype)?
21:02:05 <Beelsebob> hmm, why are you confused about that?
21:03:14 <shapr> I could add explicit uses of those to HaskellDemo.
21:05:39 <Enveigler> Beelsebob: Maybe because there is a distinct lack of examples on using Storable to map compound data structures with varient formats?
21:06:02 <Beelsebob> fair enough
21:06:05 <Enveigler> vis: http://ccrma.stanford.edu/CCRMA/Courses/422/projects/WaveFormat/
21:14:07 <shapr> @yow !
21:14:08 <lambdabot> Couldn't find fortune file
21:16:32 <dons> i haven't installed the fortunes since lambdabot's machine got fixed
21:18:00 * dons comes to the conclusion that emacs is elegant (at least micro emacs  (mg))
21:25:04 <gzl> microemacs?
21:29:06 <dons> the mg editor
21:29:28 <dons> used to be called micro gnu emacs
21:32:37 <tewk_> Hey what does the $ mean in the following expresion?    charInc x   = chr $ 1 + ord x
21:33:40 <shapr> Roughly, it replaces parentheses.
21:33:56 <shapr> It's a low precedence application operator.
21:38:59 <liyang> It's as if you'd typed: charInc x = chr (1 + ord x)
21:39:25 <liyang> (most of the time.)
21:40:30 <tewk_> shapr: thanks
21:59:20 <Enveigler> Are field names in a global namespace?
22:03:05 <Enveigler> As in data A = A { x::type, y::type } data B = B { x::type, y::type } the x and Y in types A & B conflict?
22:03:32 <seafood> Yes.
22:03:56 <Enveigler> Oh dear.
22:07:42 <Enveigler> That's a pain.
22:08:46 <shapr> There are several ways around that. You can use export hiding and accessor aliases, or you can add the name of the type directly to the record.
22:08:59 <shapr> I've heard of more, but I don't remember them at the moment.
22:12:41 <aleator> Hello.
22:13:19 <shapr> hiya aleator
22:13:59 <aleator> I have yet another ffi question. Now I have Ptr a and I need Ptr (Ptr a). How do I get it?
22:22:05 * shapr knows nothing about the FFI
22:25:00 <aleator> Well.. I just have somewhat compulsive desire to do things in haskell that I should do in c..
22:29:19 <dons> aleator, that's a very natural reaction
22:33:03 <aleator> Well, it leads to wrestling with ffi a lot.
22:37:55 <shapr> aleator: Want to write a "How to C clearly with Haskell" tutorial for TMR?
22:40:22 <aleator> Yes. Once I know how to.
22:43:52 <aleator> Hmm.. withDoublePtr ptr fun = alloca $ \p -> do {poke p ptr; fun p}
22:44:07 <aleator> What does that look to someone not in monady morning stupor?
22:44:23 <aleator> monady- > monday
22:44:25 * shapr is deep in the monday morning stupor.
22:44:33 <aleator> :)
22:44:34 <shapr> aleator: I thought it was a purposeful pun :-)
22:45:00 <aleator> Wasn't. Atleast conscious.
22:45:04 <shapr> heh, still good
22:46:10 <aleator> The mean thing about this ffi is that it's pretty hard to tell when it is really working, instead of just looking like it.
22:48:13 <pejo> When trying to link my program the linker says "Undefined symbols: \n_ghc_memcmp\n_ghc_memcmp_off\n...". These are defined in PrimPacked.lhs via FFI (I'm guessing), and PrimPacked.o is one of the objects being linked. (This is with CVS head, if that makes any difference). Any good ideas how to whack it?
23:09:46 <shapr> godmorgon pejo
23:10:19 <shapr> g'day ChronoWiz
23:10:29 * shapr throws comonads
23:17:08 <dons> shapr, , you might like to try out yi --as=mg, it must be around 70% of micro emacs now
23:20:38 <MachinShin> good night all
23:23:12 <shapr> dons: Hey, you know Linus uses microemacs?
23:23:43 <Korollary> that is sad
23:23:50 <Korollary> welcome to 1992
23:27:20 <shapr> Well, if it works for him...
23:27:58 <shapr> FP and lambda calculus has been around a few years longer, and they haven't exactly been championed by the industry.
23:28:09 <dons> most of the openbsd hackers use mg, or at least they hack it
23:28:39 <shapr> Anyway, Yi subsumes all of that :-)
23:28:53 <dons> well, its moving forward anyway.
23:29:20 <shapr> Soon as synhl is ready, I'm moving into my roomy new editor.
23:29:23 <dons> i'll soon be at a point where i have to work on syn hl, caause everything else is done.
23:29:49 <dons> one more thing is marks and buffer regions, but that should be fairly simple
23:30:30 <dons> hey, what's the output of: xmodmap | grep Meta
23:30:36 <dons> on anyone's machine?
23:31:12 <dons> (I'm trying to work out why some people don't have an Alt that sets the Meta bit)
23:31:12 <dblhelix> dons: does "unable to open display ''" count?
23:31:16 <dons> hehe
23:31:29 <dons> doesn't count
23:31:36 <dblhelix> I figured
23:32:04 <shapr> dons: Because of software brokenness
23:32:32 <dons> yep, but I think as anyone can use xmodmap to force Alt to be Meta
23:32:36 <shapr> In gtk1 days, gnome assumed that Alt was Meta, even if it didn't have Meta assigned on the keyboard.
23:32:51 <dons> (the problem if it isn't is that using Esc as Meta introduces a 1sec timeout delay under ncurses)
23:32:59 <dblhelix> reminds me that I should be using my using my usb keyboard again, instead of typing directly on my laptop ...
23:33:15 <shapr> Many popular open source apps/libs assume that Alt is Meta.
23:33:25 <dons> leading to an issue where the the char following an ESC won't be passed until the next char after
23:33:52 <dons> it makes things easier for  Yi if Alt is Meta
23:34:06 <dons> then no Esc timeout issues in emacs mode when hitting M-x and friends
23:34:28 <dons> maybe this is why no emacs editor uses ncurses
23:35:02 <shapr> Coupla years ago, for my IBM clicky keyboard, I reconfigured Alt_R to be Hyper or something, but Gnome and six or either other popular apps refused to listen. Alt_R was still Meta, in about half the apps I used :-/
23:35:17 <dons> heh.
23:35:56 <dons> ok, so i put a comment in saying that yi wants you to use Alt as Meta
23:36:02 <dons> if you use emacs modes
23:36:02 <ulfdoz_> re
23:36:09 <shapr> And of course, "patches accepted"
23:36:24 <dons> I think it is a big patch :) we'd have to stop using ncurses
23:36:36 <shapr> Well, how hard to make an OpenGL widget?
23:36:43 <dons> nah, not too hard.
23:37:03 <dons> so this isn't a problem with any gui, just in the console
23:37:49 <dons> i tried to convince a summer student to do an OpenGL gui for yi, but he hasn't got back to me on that :}
23:38:12 <shapr> Would totally kick ass.
23:39:17 <shapr> Is there an existing framework for some sort of OpenGL backed utf-8 text widget thing?
23:39:41 <dons> no idea.
23:40:38 <shapr> On my desktop X, utf-8 displays are slow, but OpenGL is fast.
23:42:37 <pejo> dons, mod4        Meta_L (0xea),  Meta_R (0xee)
23:42:50 <dons> mod4. hmm.
23:43:10 <dons> maybe i should put a little hint on how to set   Alt to be Meta using xmodmap
23:43:21 <pejo> Dont' take my advise on anything like this though, I'm running a swedish layout on a Sun type 6 keyboard.
23:43:33 <dons> crikey!
23:44:20 <pejo> dons, um. Did you want meta or did you want alt?
23:44:44 <dons> I wanted Meta and Alt to be the same :)
23:44:55 <dons> (I think)
23:45:17 <pejo> Uh. Ok.
23:45:28 <shapr> dons: mod1        Meta_R (0x71),  Meta_L (0x40),  Meta_L (0x9c)
23:45:45 <pejo> shapr, morning! (late reply).
23:45:47 <dons> hmm.
23:46:03 <shapr> dons: Don't take my setup as standard, heavily modified dvorak layout on a kinesis keyboard.
23:46:33 <dons> all you people with crazy layouts
23:46:35 <stefanw> dons:   mod1        Alt_L (0x40),  Alt_L (0x7d),  Meta_L (0x9c)
23:46:50 <pejo> (Speaking of keyboard layouts, Sun decided that us swedes should run the Swahili layout in Solaris/x86_64).
23:50:28 <dons> @eval isPrefixOf "sw" "swahili"
23:50:30 <lambdabot> True
23:50:33 <dons> closee enough :)
23:51:38 <dons> @eval map (isPrefixOf "sw") ["swedish","swahili"]
23:51:39 <lambdabot> [True,True]
23:51:49 <dons> or maybe the swahili are complaining about there silly swedish layouts
23:52:06 <pejo> Well, except that their layout isn't even close to the english qwerty. :-)
23:52:20 <dons> nah, so they complain a lot!
23:52:41 <shapr> I thought sv for svenska was the layout name?
23:53:01 <dons> yeah, that sounds right
23:54:22 <pejo> shapr, it is. Sun just delivered with 'sw' when you picked swedish during the installation.
23:54:40 <shapr> yow
