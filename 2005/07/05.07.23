01:02:02 <xerox> 'mornin
01:02:22 * xerox worships the #haskell logs.
01:03:23 <ski> hehe
01:03:31 <ski> good morning
01:13:24 <pejo> Can one send mail to ghc-bugs without having to be subscribed, or will it just bounce?
01:14:42 <ibid> if there is a subscriber-only setting, it'll likely just vanish, not bounce, if the sebder is not subbed
01:14:53 <ibid> but i don't know if that setting is in force
01:16:20 <pejo> It bounces to ghc-users, if not subscribed.
01:16:34 <ski> i sent a mail to ghc-bugs a while ago (not being subscribed), and iirc it went through some moderators, but made it to the list
01:16:44 <ibid> yeah, moderators
01:16:51 <ski> possibly they have changed it since, dunno
01:17:00 <ibid> my experience with those is that they never get back to my mail
01:17:48 <pejo> Ah. Ok, thanks.
01:18:56 <vegai> morning
01:19:13 <aleator> Yeah.. Morning.
01:20:27 <aleator> Quick question if someone wise is awake: I have a Ptr and I want an array. Where do I look?
01:22:18 <xerox> unsafeCoerce?
01:23:48 <xerox> @hoogle unsafeCoerce
01:24:11 <xerox> @index unsafeCoerce#
01:24:12 <lambdabot> bzzt
01:24:24 <xerox> @index unsafeCoerce
01:24:25 <lambdabot> bzzt
01:26:18 <ski> aleator : what kind of array ?
01:26:57 <ski> (from ffi docs) "A value of type Ptr a represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type a. .."
01:28:02 <aleator> ski: IOArray, (I think)
01:28:48 <ski> just peeking and poking the Ptr does not suffice ?
01:30:07 <aleator> Well, I guess they would..
01:30:20 <aleator> Needs some sugar on top though..
01:30:23 <aleator> Thanks all.
01:30:47 <ski> hm, possibly you can use 'peekArray :: Storable a => Int -> Ptr a -> IO [a]' combined with a creation of an IOArray (if you don't mind the copying and the copy semantics instead of overlay ..)
01:31:21 <pejo> How do I find out current version of MacOS X? "uname" just seems to give the Darwin Kernel release. Or is that enough?
01:31:35 <pejo> (For a bug report, that is).
01:32:04 <ski> ("uname -a" ? just guessing ..)
01:32:39 <pejo> ski, that gives the darwin kernel version and such. Bet they'll ask though.
01:32:45 <pejo> (If they need more information, that is).
01:33:31 <ski> m
01:45:45 <dons> @type GHC.Base.unsafeCoerce#
01:45:50 <lambdabot> forall b a. a -> b
01:47:12 <vegai> hey, dons
01:47:17 <vegai> @paste
01:47:17 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
01:47:33 <vegai> do you have an idea what might be broken with my hs-plugins there?
03:01:51 <bourbaki> moin
03:03:07 <astrolabe> morning bourbaki
03:29:09 <dons> vegai, there's a bug in runplugs and ghc 6.4, i must have comitted my debugging info by mistake
03:29:29 <dons> the bug is: setNonBlockingFD: invalid argument (Bad file descriptor)
03:29:41 <dons> and I haven't been able to work otu what the problem is
03:30:39 <dons> to get a working runplugs, you need to get hsplugins 0.9.8 and build it with ghc-6.2.2, and then install the runplugs you get.
03:30:54 <dons> (you don't need to install hs-plugins, just the runplugs binary built with 6.2.2)
03:31:11 <vegai> mmkay
03:31:55 <dons> i'd love to find this bug. there's some recent changes to System.Process that might be the fix, but I haven't tried them yet
03:32:21 <dons> it's really weird, because plugs works, but not runplugs
03:39:56 <vegai> hmm, so lambdabot uses runplugs in a separate process?
03:39:59 <vegai> @plugs 1+3
03:40:06 <lambdabot> 4
03:40:54 <vegai> is there some problem with using it via an API?
03:43:46 <dcoutts> xerox, you still here?
03:44:32 <xerox> dcoutts: luckily enough I just connected :-)  Hiya!
05:32:59 * Number17 has discovered that haskell's function call syntax is not at all like C's
05:33:11 <Number17> C syntax working sometimes confused me
05:34:02 <Number17> the call syntax is pretty cool though, now that I've figured it out
05:34:24 * Number17 has never programmed in any other functional language than lisp
05:34:41 <ibid> actually, the syntax is fairly similar, it's just customarily used differently :)
05:34:59 <ibid> the only difference is that haskell allows you to drop parens in some cases
05:35:23 <Number17> well, I see it is very similar to lisp; but from the looks of the rest of the syntax, I was trying to use C synatx
05:35:26 <Number17> *syntax
05:35:37 <ibid> theoretically, you can write a C function that can be called like f(x)(y)(z)
05:35:50 <ibid> (it's just a lot of work)
05:36:01 <Number17> I like the haskell syntax now though
05:36:10 <ibid> and it's fairly easy to write a Haskell function that can be called like f(x,y,z)
05:36:33 <Philippa_> yeah, the haskell syntax is pretty cool on the whole
05:36:57 <Number17> it's just very ... different from anything else I've used
05:38:08 <Philippa_> yeah. Saner, for one :-)
05:43:30 <Number17> w00t! my haskell postfix calculator now works; now time to try something more complicated
06:32:02 <dcoutts> hmm, how do I get an old version of a darcs repo
06:32:35 <dcoutts> eg I want to see the initial checkin, without any of the later patches
06:32:49 <xerox> darcs revert
06:32:53 <Igloo> darcs init; darcs pull y d
06:33:22 <Igloo> y d in response to the prompts, not on the command line)
06:33:54 <xerox> Err.  Right.
06:34:10 <dcoutts> ok..
06:35:08 <dcoutts> yay, cheers Igloo
07:14:02 <sylvan> What was that tool someone wrote to interface between haskell and c++?
07:15:03 <Philippa_> hacanon?
07:16:07 <sylvan> hmm.. maybe that's it..
07:16:21 <sylvan> does it work well?
07:16:56 <Philippa_> never tried it
07:17:07 <sylvan> ok
07:18:26 <shapr> There's also hsffig
07:18:47 <sylvan> anyone tried it?
07:19:17 <shapr> There's an hsffig tutorial on the Wiki, and possibly a tutorial in the next TMR.
07:19:38 <shapr> I've not tried any of them, can't help you there.
07:21:43 * shapr convolutes Enveigler
07:22:44 * Enveigler_ convolves
07:22:53 * shapr grins
07:23:01 <shapr> hiya Enveigler_, making any progress?
07:23:46 <Enveigler_> Still reading vanRoy&Haradi It's a big book
07:24:32 <shapr> Yeah, it's good stuff.
07:24:58 <Enveigler_> You've read it?
07:25:07 <shapr> A little bit of the draft.
07:25:24 <shapr> More importantly, I've seen PvR talking on LtU a lot.
07:25:29 <shapr> He's quite clueful.
07:26:06 <shapr> I don't agree with everything he says, but I do agree with most.
07:26:17 <Enveigler_> I'm finding it very enlightenling. I like that he (they) acknowledge the importance of a programmer's intuition.
07:26:40 <Philippa_> anybody who claims there shouldn't be any needs shooting
07:26:49 <Philippa_> that, or handing off to the robots for use as a fuel cell
07:28:07 <shapr> It's that time again, time to start whining about the lack of TMR articles.
07:28:09 <Enveigler_> For now, I'm trying not to either agree or disagree. I'm just allowing it to wash over me as I follow it step by step. I think I may have a better understanding of the issues surrounding FP that currently make me so uncomfortable by the end. Then, maybe, I'll be in a position to reach some informed conclusions.
07:28:15 <shapr> I think I'll write something simple about unit testing with HUnit.
07:28:31 <shapr> Enveigler_: I think that's exactly the right approach.
07:29:05 <shapr> Philippa_: Think you'll have something for the next TMR?
07:29:23 <Philippa_> as in, for a week's time?
07:29:25 <Philippa_> unlikely
07:29:31 <shapr> Ok
07:29:32 <Philippa_> the one after, quite possibly
07:29:45 <shapr> What do you think about the Practical Graph Handling article?
07:29:56 <Philippa_> if you're willing to take a quarter-sized article, I could serialise the type system thing
07:30:14 <Philippa_> I didn't read it in depth, was feeling a bit dopey when I looked and haven't gone back for some reason
07:30:23 <Enveigler_> Probably. My attempting to explore my discomfort with those that have either never felt it, or already trancended it is frustrating for both parties. :(
07:30:28 <shapr> I keep bouncing off the second part, I forget why.
07:30:45 <xerox> I keep talking the wrong path in abstractions.
07:30:57 <xerox> *taking, even
07:31:03 <dcoutts> xerox, hey, don't take it so hard! :-)
07:31:12 * xerox grumbles
07:31:32 <dcoutts> poor xerox is on a steep learning curve :-)
07:31:49 <shapr> xerox: Where's your blog again?
07:32:07 <shapr> xerox: Oh, the reason my blog doesn't do RSS is because PLog doesn't do RSS bodies, and I haven't fixed it.
07:32:07 <dcoutts> http://haskell.org/gtk2hs/archives/category/cairo/
07:32:09 <xerox> I made <http://haskell.galois.com/~paolo/>
07:32:16 <xerox> As a redirect for Duncan's url.
07:32:18 <shapr> I tried to fix PLog, but it's not easily modified.
07:32:30 <xerox> shapr: oh :(
07:32:31 <Philippa_> Enveigler_: I felt some discomfort at first, but it may well not've been the same as your discomfort...
07:32:43 <xerox> dcoutts: that url is rather long :-)
07:32:47 <shapr> I realized that more people read the RSS than will ever read the actual website, so I've decided my blog should be a wiki-markup -> RSS transformer.
07:32:57 <xerox> You acn get the feed appending "feed/rss/" if you will.
07:33:10 <xerox> *can, even
07:33:19 <dcoutts> xerox, true, but it's linked directly from the Gtk2Hs front page
07:34:22 <Enveigler_> Philippa_ From reading your articles in TMR, you have a way better grounding in formal math than I -- your discomforts were probably at a rather higher level than mine :)
07:34:33 <shapr> w00, I got thanks on xerox' blog!
07:34:38 * shapr boings happily
07:34:41 <xerox> shapr: that's probably the case.
07:34:58 <Philippa_> Enveigler_: my articles show /any/ grounding in formal math? :-)
07:35:04 <dcoutts> appending "feed/" will give you rss 2.0, "feed/rss/" will give rss 0.92, "feed/atom/" gives you atom format (whatever that is!)
07:35:22 <shapr> Atom is one of those other rss flavor.
07:35:29 <shapr> I can never get them all straight in my hed.
07:35:32 <Philippa_> most of what I have now I didn't have when I started learning FP - I'd got about as far as the basic set theory course at uni
07:35:33 <shapr> head*
07:35:40 * shapr needs more stimulants.
07:36:05 <Philippa_> shapr: turn Flippi into a blogging tool? It shouldn't be too hard
07:36:08 <shapr> Happily my prescription for stimulants was renewed yesterday.
07:36:11 <shapr> Philippa_: yes!
07:36:21 <Philippa_> change the default page, a few things like that...
07:36:45 <Philippa_> oh, make it spit out RSS I guess, so you'd have to replace Network.CGI with a modified version that lets you generate RSS, but hey
07:37:17 <shapr> I think that would be an effective blogging tool.
07:38:07 <shapr> I'd want to modify RecentChanges to include contents in RSS format, that'd be the entirety of the RSS feed.
07:38:58 <xerox> This mobile connection have bad influences on remote screen sessions.  Aww.
07:39:12 <xerox> What did I miss?
07:40:01 <shapr> Nothing exciting
07:40:01 <dcoutts> not much
07:41:06 <Philippa_> shapr: modify Network.CGI's wrapper to take a (String,String) pair (content-type, content), go from there?
07:41:12 <xerox> Ah, it logged, tough.  Yes, I must thank a lot of people :-D
07:41:37 <xerox> I don't know if I explaine myself well, but seeing people moving around you is _really_ motivating, for real.
07:41:44 <xerox> explained, even.
07:42:21 <shapr> xerox: Well, if you start a cool project, others will help you make it real.
07:43:10 <shapr> TMR is a good example of that.
07:43:24 <shapr> dcoutts: Hey, think you'll have time for a gtk2hs article soon?
07:43:29 <xerox> Indeed.
07:43:54 <shapr> mikael: Want to write a TMR article? :-)
07:44:17 <shapr> autrijus: Want to put up more Pugs writings for the next TMR? (in a week?)
07:44:24 <shapr> chucky: Want to write about HaskellDB for TMR?
07:44:52 <xerox> TMR-begging quotes generator on the way for Lambdabot.
07:44:57 <shapr> haha
07:45:17 <metaperl> import MissingH.Printf is not working for me... how do I import MissingH so that I can use the vsprintf function?
07:45:23 <shapr> It should be a lambdabot plugin that asks channel members for articles on subjects randomly generated from a list of Haskell buzzwords.
07:45:40 <xerox> That's what I was thinking, yeh :-)
07:46:08 <shapr> metaperl: I can import it just fine.
07:46:55 <metaperl> import MissingH.Printf
07:47:01 <shapr> yep
07:47:33 <metaperl> that is what I have.. on Scanned in fact: http://scannedinavian.org/~metaperl/haskell/craft-of-fp/ex/ex64.hs
07:49:40 * shapr installs MissingH on ScannedInAvian
07:53:29 <Spark> i thought that said "scandinavian"
07:53:54 <Spark> ah, is that the point
07:53:56 <Spark> fair enough :)
07:54:22 <dcoutts> shapr, probably not very soon :-( I keep finding things I'm supposed to be doing
07:54:27 <Spark> im only retarded at weekends
07:54:39 <dcoutts> shapr, I'll do it eventually though, promise! :-)
07:54:55 <lisppaste2> metaperl pasted "help needed finding lexical error" at http://paste.lisp.org/display/10144
07:59:07 <arjanb> infix functions need ` instead of '
07:59:17 <shapr> dcoutts: That's cool.
08:00:02 <dcoutts> shapr, certainly by the Gtk2Hs 1.0 relase :-)
08:00:49 <shapr> Spark: The name comes from an irc joke, I said I was a linux fanatic living on the internet, though my body is in Sweden. Therefore I am a digital penguin and a person living in Sweden/Finland.
08:01:44 <Spark> my irc clients broken
08:01:57 <Spark> well, ncurses is broken i think
08:02:01 <Spark> its not wrapping lines any more
08:02:22 <Spark> Therefore I am...
08:02:51 <liyang> shapr: nothing to do with RFC1149 then. :-/
08:27:02 <shapr> liyang: Not yet.
08:39:04 <shapr> @yow !
08:39:05 <lambdabot> Couldn't find fortune file
08:50:35 <Spark> @moo
08:52:38 <metaperl> it seems that people don't Haskell makes me feel good: http://scannedinavian.org/~metaperl/haskell/is-beautiful/top-down-is-easy/
08:53:38 <shapr> people don't what?
08:54:10 <shapr> metaperl: Yeah, nice snippet :-)
08:54:16 <metaperl> that was something I had typed about 1 hour ago... I had typed: people dont seem to answer questions posted here via paste.lisp.org
08:54:18 <metaperl> shapr: thanks
08:54:23 <shapr> metaperl: So you want to write a newbie column?
08:54:35 <metaperl> well I am 100% qualified to do so :)
08:54:37 <metaperl> lol
08:54:38 <shapr> :-)
08:55:02 <metaperl> World-Class Newbie metaperl authors yet another earth-shaking commentary
08:55:21 <metaperl> yeah, I would like to write such a column
08:55:56 <metaperl> asciidoc is great for authoring things
08:56:05 <shapr> Ok, create an account - http://www.haskell.org/tmrwiki/UserPreferences - and I'll add you to the Authors
08:56:27 <shapr> I suspect you'll use TerrenceBrannon ?
08:58:37 <metaperl> yes TerrenceBrannon
09:01:12 <shapr> Ok, you're in.
09:01:13 <metaperl> shapr: how do you filter out spam?
09:01:23 <shapr> On the wiki?
09:01:35 <metaperl> you list your email address on the tmrwiki and it seems you dont care about harvesters
09:01:47 <metaperl> no... at your email address
09:01:59 <metaperl> ok I have registered there
09:02:05 <shapr> I use tmda
09:02:11 <shapr> It's evil, but then I don't like email much.
09:03:05 <metaperl> i see.. I just deal with the spam for now... but I'm just getting info on approaches... TMDA is my preferred approach too...
09:03:23 <metaperl> I'm going to get some carrot juice across the way... be back later... still havent showered either
09:15:59 <Enveigler_> @type split
09:16:03 <lambdabot> bzzt
09:16:14 <shapr> @index split
09:16:15 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, GHC.Exts, Language.
09:16:15 <lambdabot> Haskell.TH.Ppr, System.Random
09:16:49 <Enveigler_> Hmm. Is there a function for split lists?
09:16:50 <Khisanth> any suggestion on something to try writing for the purpose of learning Haskell? :)
09:17:56 <shapr> Khisanth: Parsers are good to start with.
09:27:35 <Enveigler> @index splitAt
09:27:35 <lambdabot> Data.List, Prelude
09:27:50 <Enveigler> @google Data.List splitAt
09:27:52 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
09:30:26 <Enveigler> @google Prelude splitAt
09:30:28 <lambdabot> http://www.cs.uu.nl/~afie/haskell/tourofprelude.html
10:30:44 <Heffalump> what are the obvious places to look for a stack overflow?
10:30:58 <dcoutts> your code?
10:31:12 <dcoutts> sorry. ahem.
10:31:15 <Heffalump> :-p
10:31:20 <Heffalump> might be your code, you know.
10:31:31 <Heffalump> (but it isn't)
10:31:34 <dcoutts> oohh!
10:31:54 <Heffalump> cos obviously I'd have to be desperate to use your code.
10:32:17 <Heffalump> (Or need a decent GUI for ant simulation or be participating in a programming contest or want to use Gtk2Hs or ...)
10:33:03 <Heffalump> anyway. Are stack overflows generally just caused by too deep recursion, or is there something more subtle?
10:33:08 <dcoutts> oh yes, that's what I was doing, improving the ant GUI
10:34:02 <dcoutts> as far as I know, it's just too deep recursion (usually due to infinite recursion)
10:35:58 <Heffalump> should doing a fold over a list of length 400000 cause it?
10:37:03 <Heffalump> oh, hmm, foldr is recursive like that.
10:37:56 <metaperl> how come the output literally shows \n instead of printing the lines with carriage returns at the end?
10:38:01 <metaperl> print $ unlines ["hi","there"]
10:38:21 <{|mono|}> @plugs shows (10::Int) "hello"
10:38:26 <lambdabot> "10hello"
10:38:34 <dcoutts> metaperl, because print calls show, and show of a string includes the " " bits and the escaping
10:38:48 <metaperl> dcoutts: what to use to get human-readable output?
10:39:01 <dcoutts> you might want: putStrLn $ unlines ["hi","there"]
10:39:02 <Lemmih> @type putStrLn
10:39:03 <lambdabot> String -> IO ()
10:39:14 <dcoutts> @plugs putStrLn $ unlines ["hi","there"]
10:39:15 <lambdabot> No IO allowed
10:39:28 <dcoutts> oh of course
10:39:47 <{|mono|}> @plugs (shows 10 . (++ "x") . shows 9) ""
10:39:49 <lambdabot> "109x"
10:39:56 <metaperl> putStr works just fine... dcoutts: thanks
10:40:14 <dcoutts> np
11:00:31 <dcoutts> shapr, is it ok if a TMR article is not entriely original? eg is it ok to base it on the same material as has been partly published in other forms? eg i'm writing a couple FAQs for the Gtk2Hs web site and I'd like to use the same material later for a Gtk2Hs TMR article. Is that ok?
11:01:24 <Heffalump> I think autrijus did the same thing about Pugs
11:01:32 <dcoutts> right
11:11:25 <lispy> dcoutts: i think the point is to help people get started with haskell using it for real applications.  So if it fits that, I bet shapr would say it's a good article
11:11:40 <shapr> dcoutts: Yeah, that's fine
11:11:46 <dcoutts> ok, cheers
11:12:04 <shapr> Just as lispy said, if it helps people get started, it's good stuff.
11:12:20 <lispy> yay! ;)
11:12:28 <dcoutts> shapr, and it should give you a preview of what I'll talk about
11:12:38 <shapr> Sounds good to me.
11:12:52 <dcoutts> I'll ping you when it's up. I'm writing about multi-threaded GUIs.
11:13:10 <shapr> Ah, that will be interesting.
11:13:14 <lispy> cool
11:13:15 <dcoutts> about how it's really easy (and cool) to do :-)
11:13:31 <shapr> Really? Using STM?
11:14:08 <dcoutts> no, not even  MVars, just doing things like putting long running actions in threads etc
11:15:03 <dcoutts> or structuring the program to use threads like an IRC client that uses one thread to listen to the network and another to keep the gui reactive
11:15:12 <yosemite> before I look to google, does anyone know about a sexp style system that does haskell style type checking?
11:15:37 <shapr> yosemite: Maybe HScheme, the Scheme written on top of Haskell?
11:15:46 <yosemite> I'll take a look thanks
11:20:30 <Lemmih> Isn't Scheme too dynamic for a HM typesystem?
11:22:28 <shapr> Man, LtU is going downhill.
11:23:47 <ibid> hmmh, haskell-unsafe should really use release names instead of stable/testing/unstable
11:23:49 <yosemite> shapr: how so?
11:24:54 <Igloo> Hmm, but s/t/u is what goes in changes files, so that would just be something else to keep up-to-date
11:25:30 <yosemite> Lemmih: r5rs proper probably is too dynamic, but I'm thinking about something that is kinda haskell wrapped in sexps
11:25:40 <ibid> Igloo: at least add symlinks
11:25:48 <ibid> Igloo: so that one can point apt at a code name
11:25:51 <shapr> yosemite: Worthwhile discussions come from those who investigate because they want to know more. Time wasting discussions come from those who have conclusions they want to reinforce.
11:26:00 <ibid> and you should really rename stable to oldstable there
11:26:55 <yosemite> ahh, like the dynamic languages thread
11:27:50 <shapr> Whenever people start insulting each other or questioning each other's cluefulness or ancestry or whatever, then the discussion has reached the 'wasting my time' stage.
11:29:40 <shapr> What we have today is not perfect. Better languages will appear in the future. We have the seeds for those better languages now. I want to get my mands on those new and better languages as soon as possible. You can't ignore any part of CS, all parts are worthwhile, all parts are the best tool for some situation.
11:29:50 <shapr> um s/mands/hands/
11:30:41 <reffie> Google
11:30:52 * shapr hugs Google.
11:31:19 <ibid> oh great, gtk2hs in h-u is uninstallable, at least on sarge
11:33:24 <ibid> also on sid
11:33:31 <ibid> is h-u maintained?
11:33:47 <Igloo> h-u itself is, the stuff in it isn't necessarily
11:34:38 <Igloo> I have some more up-to-date gtk2hs debs somewhere, but I was waiting until there was a release with .cabal files in before making the dependencies right
11:34:44 <ibid> ok
11:35:03 * ibid really never got the point of h-u. why not debian experimental?
11:35:24 <Igloo> Without the deps they're not really more useful than compiling it yourself
11:35:54 <ibid> obviously, with deps
11:36:01 <Igloo> Uploading to d-e requires waiting for NEW (not so bad these days) and has a stronger implication that something will actually be maintained in Debian soon
11:36:52 <ibid> i mean, is the existence of debs in h-u a sign that that package is spoken for in the debian sense?
11:36:59 <ibid> and maintained... :)
11:36:59 <dcoutts> Igloo, we can't do .cabal files, (at least not do it and pretend that they have a great chance of eing correct) since we're not using the cabal build system
11:37:23 <dcoutts> Igloo, you must have various other libs that do not use cabal yet
11:37:29 <Igloo> If it's in h-u then you should probably talk to whoever made it, but it's not an official claim like a Debian ITP is
11:38:21 <ibid> well, the packaged gtk2hs seems to be unusable currently, which is a shame
11:38:21 <dcoutts> Igloo, the next bugfix release (0.9.8.1) will have the .cabal files renamed to something else so they do not get confused for cabal files! :-)
11:38:26 <Igloo> dcoutts: Nothing with inter-package deps, I don't think
11:38:51 <ibid> i was planning on using it for my next project, and i don't like non-debbed stuff
11:38:59 <dcoutts> Igloo, you mean intra-package deps?
11:39:13 <ibid> should i assume that doing it myself would be doomed to failure at this point?
11:39:23 <Igloo> I mean inter-cabal-package deps, whether inter-Debian-package or intra-Debian-package
11:39:26 <ibid> (ie there is something holding it up)
11:39:36 <dcoutts> ibid, it builds from source on debain just fine
11:39:45 <ibid> dcoutts: from debian source, too?
11:39:55 <Igloo> ibid: If you want to make proper debs then I'll try to dig up what I made
11:40:30 <dcoutts> ibid, I don't know about .debs but building from the 0.9.8 tarball is fine
11:40:50 <ibid> Igloo: i might be interested in trying
11:41:00 <ibid> but if i do, i'd want to do it the itp way
11:41:00 <Igloo> but I'd rather what I have now wasn't distributed as it won't just work
11:41:09 <dcoutts> Igloo, well wxHaskell and c2hs have non-cabal build systems that use multiple packages
11:41:10 <Igloo> That's fine
11:41:26 <Igloo> Effectively neither are in Debian
11:41:34 <dcoutts> oh, right
11:41:34 <Igloo> (c2hs technically is but is unmaintained)
11:41:36 <ibid> of course, i'll have to catch up in haskell packaging
11:41:51 <ibid> back when i did that, there were none of the infrastructure that there is now :)
11:41:53 <Igloo> ibid: I've done all of that that can be done, I think
11:41:59 <dcoutts> c2hs put out another relase the other day (or do you mean the c2hs debs are unmaintained)
11:42:05 <Igloo> c2hs debs
11:42:09 <dcoutts> the latest c2hs uses cabal btw
11:42:12 <rafl> Maybe someone want's to package hsx? I need it for another package but I'm really stuck in packaging it myself..
11:42:43 <Igloo> c2hs now has renewed interest by marcot, so hopefully it will be maintained in Debian in ~ a month when everything else is working  :-)
11:42:55 <Igloo> rafl: What is that?
11:43:26 <dcoutts> Igloo, well I could create some 'dummy' cabal files for Gtk2Hs if it'd help your dependency tool, but they will not actually be used by the build system
11:43:46 <shapr> If you mean the extended Haskell source parser, it already has a cabal package.
11:43:58 <Igloo> dcoutts: As long as you keep them up-to-date (preferably with a tool that can check), that'd be fine by me
11:44:14 <ibid> Igloo: if you want to let me have a look at what you have in private, i think easiest is to mail me at ajk@d.o
11:44:26 <rafl> Igloo: haskell-source-exts: http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
11:45:06 <dcoutts> Igloo, I'd use the same thing as the current build system uses for creating the package config files (which I erroniously called .cabal files)
11:45:24 <Igloo> Ah, that'd be good
11:45:25 <dcoutts> so it'd stay in sync with the actual package config files
11:45:33 <shapr> rafl: It's already packaged, grab the darcs repo and use cabal to install it.
11:45:40 * ibid goes off for a while
11:45:44 <rafl> shapr: I mean packaged for Debian.
11:46:49 <dcoutts> Igloo, ok then I'll do that. But I still need a name for the "installed package info" files. We sued to call the pre-ghc-6.4 ones ".pkg" files. How about ".pkg-ghc-6.4+" ?
11:49:42 <Igloo> dcoutts: It doesn't really bother me as long as it's not .cabal  :-)
11:49:51 <dcoutts> yeah
11:50:06 <Igloo> rafl: Is that used by pugs?
11:51:04 <rafl> Igloo: hs-plugins uses it and itself enables pugs to use inline haskell code and to load haskell modules dynamically.
11:51:24 <Igloo> Oh, OK. I wonder why hs-plugins wants it
11:52:18 <Igloo> ajk: YHM
11:52:24 <Igloo> Err, ibid too  :-)
11:52:45 <ibid> Igloo: YHM?
11:52:51 <Igloo> You Have Mail
11:52:54 <ibid> heh
11:54:48 <vegai> TMAOTP
11:56:41 <rafl> Igloo: It want's it: Rebuilding dependencies ... Could not find module `Language.Haskell.Hsx'
11:58:16 <TheHunter> rafl, see http://www.haskell.org/hawiki/LambdaBot_2fInstallation
11:58:27 <ibid> vegai: hm?
11:58:52 <vegai> Too M___ Acronyms O_ This P_____
11:58:54 <ibid> Igloo: not yet arrived. is it big?
11:59:01 <Igloo> No
11:59:06 <Igloo> ajk@debian.org, right?
11:59:07 <ibid> Phannel? :)
11:59:10 <ibid> yeah
11:59:28 <ibid> give it a minute or ten :)
11:59:49 <rafl> TheHunter: I need Debian packages for it.
11:59:50 * ibid wears the debconf tshirt the first time now
12:00:05 <Igloo> 2005-07-23 19:53:13 1DwP7X-0004ST-00 => ajk@debian.org R=lookuphost T=remote_smt
12:00:09 <Igloo> p H=master.debian.org [146.82.138.7]
12:01:08 <Igloo> rafl: What's the packaging problem OOI?
12:01:53 <rafl> Igloo: It needs haskell-source-exts installed before trhsx can be compiled.
12:01:57 <ibid> well, either master is slow or the dns blacklists i use are slow
12:02:31 <Igloo> ah, right
12:05:05 <ibid> Jul 23 21:53:18 flowerpot courierd: newmsg,id=000511AE.42E2921E.0000157D: dns; master.debian.org (master.debian.org [::ffff:146.82.138.7])
12:05:08 <ibid> Jul 23 21:53:18 flowerpot courierd: newmsg,id=000511AE.42E2921E.0000157D: dns; master.debian.org (master.debian.org [::ffff:146.82.138.7])
12:05:11 <ibid> argh
12:05:14 <ibid> one is enough :)
12:05:20 <ibid> that's the last entry my logs have about master
12:06:16 <Igloo> master's turning mail around very snappily for me
12:06:37 * ibid tries disabling the dnsbls
12:11:09 <rafl> Igloo: So, any idea on that? Can I specify include paths or something to the setup binary created with ghc6 -package Cabal *cabal -o setup?
12:11:58 <Igloo> rafl: I'd have to look at it, and I don't have time right now, sorry
12:13:20 <rafl> Igloo: OK. I also write patches for dh_haskell to support multiple cabal files per src-package. I'll send it to you. Maybe it'll help.
13:05:01 <jyp> @yow
13:05:02 <lambdabot> Couldn't find fortune file
13:05:19 * jyp rolls on the floor laughing
13:05:33 <jyp> man that was a good one
13:05:38 <vegai> @yow
13:05:38 <lambdabot> Couldn't find fortune file
13:05:44 <vegai> wow, what are the odds?
13:05:50 <vegai> perhaps 1.
13:06:00 <vegai> @yow
13:06:01 <lambdabot> Couldn't find fortune file
13:06:10 <vegai> I'm becoming more and more convinced that lambdabot can't find the fortune file
13:06:12 <vegai> @yow
13:06:13 <lambdabot> Couldn't find fortune file
13:06:26 <vegai> it's highly probable now.
13:06:26 <dcoutts> or maybe it's fortune file just contains one entry...
13:06:35 <vegai> oh! indeed
13:06:53 * jyp laughs
13:06:54 <dcoutts> that'd be an odd joke
13:26:11 <lament> @yow
13:26:12 <lambdabot> Couldn't find fortune file
13:26:15 <lament> wow
13:26:59 <lament> this is one of those cases
13:27:16 <lament> where probability theory says the chance of next fortune being the same again is as small as ever
13:27:28 <lament> but instinct says that it's actually quite high
13:27:31 <lament> @yow
13:27:32 <lambdabot> Couldn't find fortune file
13:27:38 <lament> and instinct is correct!
13:27:44 <lispy> heh
13:27:49 <lispy> @yow
13:27:50 <lambdabot> Couldn't find fortune file
13:27:52 <lispy> OMG!
13:28:12 * lispy waits for the planets to align
13:49:37 <ibid> Igloo: it went to my spambox, heh
13:49:55 <Igloo> Charming  :-)
13:52:26 <ibid> Igloo: if i get something out of that, how do you like to settle maintainership? :)
13:52:53 <Igloo> If you want to maintain it, feel free
13:53:05 <ibid> ok
13:53:12 <ibid> you don't want comaintainership?
13:53:14 <Igloo> Otherwise I probably will in a couple of months
13:53:21 <ibid> ok
13:53:33 <ibid> i'll itp it when and if i'm sure i'll get it done
13:53:36 <Igloo> How would you work co maintainership?
13:53:49 <ibid> Igloo: haven't tried it yet :)
13:53:59 <ibid> Igloo: i'm sure something can be worked out
13:54:09 <Igloo> Well, we can work something out later if we want to  :-)
13:54:12 <ibid> :)
13:54:45 <ibid> i think the tradition is to have it in a vcs with commit access for all comaints
13:59:39 <wagle> !lennahc cri na ni deppart m'i !pleh
14:00:57 <jyp>  /kick wagle  ?
14:06:30 <wagle> !hcuo
14:07:02 <lispy> is that like a sneeze?
14:07:30 * lispy expected lambdabot to respond to "!hcuo" with "bless you wagle"
14:10:34 <wagle> (8
14:27:42 * Itkovian just found out about Text.Printf
14:27:44 <Itkovian> nice
14:29:32 <Beelsebob> heh
14:29:54 * Beelsebob just finished `refactoring' some Obj-C
14:29:59 * Beelsebob is amazed it still works
14:30:10 <Itkovian> nice
14:30:49 <Itkovian> I've been offline for almost a week ... fixing some windhoos machines, tearing out trees in the garden, ...
14:31:05 <Beelsebob> sounds more fun than my week
14:31:23 <Beelsebob> in which I mostly finished my miniThesis
14:31:27 <Beelsebob> viva on Tuesday
14:32:34 <Itkovian> I need to submit a final paper, but I'm on holiday ... pfft.
14:32:44 <Beelsebob> holiday? What's that?
14:32:48 <Itkovian> I mean final version of an accepted paper
14:32:57 <Beelsebob> :)
14:33:03 <Itkovian> It's a time where you do chores you can do during work
14:33:10 <Itkovian> can't that was
14:33:43 <lispy> Itkovian: that's the best definition of holiday i've heard
14:33:46 <Beelsebob> heh
14:33:53 <Beelsebob> sounds very accurate
14:34:03 <Itkovian> it is, it is
14:35:23 <metaperl> what do I import to get the find() function?
14:35:25 <metaperl> @type find
14:35:27 <lambdabot> bzzt
14:35:33 <Beelsebob> @hoogle find
14:35:34 <lambdabot> List.find :: ((a -> Bool) -> [a] -> (Maybe a))
14:35:34 <lambdabot> List.findIndex :: ((a -> Bool) -> [a] -> (Maybe Int))
14:35:34 <lambdabot> List.findIndices :: ((a -> Bool) -> [a] -> [Int])
14:35:39 <Beelsebob> List apparently
14:39:29 <metaperl> I'm guessing it is Data.List
14:40:36 <wagle> i'm refactoring some tcl/tk..  harhar
14:41:48 <lispy> wow, applying all the darcs patches can take a long time
14:41:56 <Beelsebob> I take it that that's more `refactoring'
14:42:01 <Beelsebob> not refactoring
14:42:22 <lispy> uh?
14:42:37 <Igloo> Are you using 1.0.4pre1, lispy?
14:42:40 <Beelsebob> as in... you *think* it does the same, not it does the same
14:43:01 <lispy> Igloo: i'm using 1.0.3 to grab darcs-unstable
14:44:28 <Igloo> That's OK then  :-)
14:44:31 <lispy> darcs get had some 3335 patches to grab and apply :)
14:45:00 <Igloo> 1.0.4pre1 should be significantly faster, that's all
14:45:11 <lispy> ah, cool, i was hoping to upgrade
14:46:44 <lispy> i'm compiling gcc4 at the same time, so i can't expect it too be too fast :)
14:47:02 <Beelsebob> haha
14:49:41 <Itkovian> night all
14:58:46 <Igloo> Hmm, I wish exporting (Foo, foo) was different to (Foo(foo)) (by not allowing updates with the former, only accesses)
15:06:08 * shapr burbles
15:06:32 <lispy> uhoh, not a burble
15:07:00 <wagle> hey no fair!  i was burbling first!
15:12:58 <astrolabe> I've got my copy of the report :)
15:13:17 * Beelsebob flibbles
15:13:50 <astrolabe> Having a paper copy makes programming, and just browsing a lot easier.
15:14:34 <wagle> i could never get the blink tag to work on paper
15:15:08 <shapr> Don't they call that macromedia flash these days?
15:15:32 <astrolabe> You need special glasses.
15:15:34 <Beelsebob> wagle: that's why it's easier ;)
15:15:41 <yosemite> *Main> let i = setBit (0::Int32) 31
15:15:41 <yosemite> *Main> shiftR i 31
15:15:41 <yosemite> -1
15:15:46 <yosemite> ^-- is this a bug?
15:15:51 <lispy> shapr: yes
15:16:03 <yosemite> I was expecting 1
15:16:12 <wagle> Beelsebob gets the ka-ching cymbal sound
15:16:19 <Beelsebob> hehe
15:16:44 <Beelsebob> yosemite: try a shiftL
15:16:56 <Beelsebob> all you did was flip the sign bit
15:18:02 <jyp> @lojban brivla
15:18:04 <lambdabot> ERROR: 501 Syntax error, illegal parameters
15:18:13 <shapr> Oops
15:18:18 <wagle> @index setBit
15:18:19 <lambdabot> Data.Bits, Foreign
15:18:44 <Beelsebob> @botsnack
15:18:44 <lambdabot> :)
15:18:56 <Igloo> It depends what shiftR is defined to do
15:19:01 <yosemite> hmm, I think I see where I missed an asssumption
15:19:04 <Beelsebob> I assume shift right
15:19:15 <Beelsebob> and introduce 1s to the left
15:19:28 <wagle> i get the correct value
15:19:32 <yosemite> Shift the argument right (signed) by the specified number of bits
15:19:40 <Igloo> It looks like it copies the rightmost bit for Int32. I don't know what the spec is
15:19:40 <yosemite> I missed the signed part
15:19:57 <yosemite> I'm using Data.Bits.shiftR
15:21:01 <wagle> @index Int32
15:21:03 <lambdabot> Data.Int, Foreign
15:21:45 <wagle> Prelude Data.Int Data.Bits> setBit(0::Int32) 31
15:21:45 <wagle> -2147483648
15:22:06 <wagle> OOOohh
15:22:11 <wagle> sigh
15:22:48 <wagle> @index shiftR
15:22:50 <lambdabot> Data.Bits, Foreign
15:23:17 <yosemite> I see my mistake
15:23:26 <yosemite> I should be using Word32 and not Int32
15:25:05 <wagle> oh, thats cool..  one ShiftR for unsigned, and one for signed..  was looking for the docs for ShiftR
15:26:32 <wagle> @index Word32
15:26:33 <lambdabot> Data.Word, Foreign, Graphics.SOE
15:26:41 <wagle> GAH
15:27:45 <wagle> oh man, i like that overloading
15:46:50 <yosemite> great, now I have something of minor utility.  A commandline program that takes an ip and a netmask and prints out all of the addresses in the network
15:47:06 <lispy> cool
15:47:07 <shapr> Does it also show broadcast addresses?
15:47:26 <yosemite> yeah it just goes [networkaddr .. broadcast ]
15:47:35 <lispy> yosemite: i wrote something like that once (in bash) to find my school's mail server :)
15:47:41 <wagle> broadcast doesnt have to be all 1's
15:48:05 <wagle> though thats the usual convention
15:48:33 <yosemite> I don't know if this catches weird netmasks
15:48:59 <yosemite> I wrote something like it in python before for some reason that I now cannot remember
15:49:21 <lispy> Igloo: should all the tests in 'make test' pass?
15:49:31 <lispy> Igloo: i had at least one failure
15:49:43 <lispy> Igloo: this is of course refering to darcns
15:49:47 <lispy> er darcs
15:50:25 <Igloo> In test, they should
15:50:35 <Igloo> Are you sure you didn't have an unexpected pass?
15:50:49 <lispy> pull.....................ok 2/11
15:50:50 <lispy> #     Failed test (pull.pl at line 44)
15:50:50 <lispy> #                   '
15:50:50 <lispy> # darcs failed:  user error (Error applying patch to working dir:
15:50:50 <lispy> # takeFile ./one/date.t-0 in /Users/dagit/local-data/darcs-unstable/tests/temp1: failed (Unknown error: 0))
15:51:09 <lispy> Igloo: i haven't change the code since the get, i just ran make test to make sure it was happy
15:51:42 <Igloo> What filesystem is that?
15:51:50 <lispy> this is on Mac OSX
15:51:56 <lispy> so i think HFS+ maybe?
15:52:54 <lispy> I also see "1/4 unexpectedly succeeded"
15:53:58 <Igloo> Hmm, it looks like rc < 0 but errno == 0
15:54:15 <Beelsebob> could it be that you have two files named the same with different cases?
15:55:47 <astrolabe> I'm getting pointer withdrawal
15:55:50 <Igloo> Is that repeatable, lispy?
15:56:04 <lispy> Igloo: i'll find out
15:58:03 <lispy> Igloo: yes
15:58:23 <lispy> $ umask
15:58:24 <lispy> 0077
15:58:28 <lispy> could it be my umask?
15:58:29 <Igloo> OK, can you print fd and errno in compat.c sloppy_atomic_create before the if please?
15:59:36 <Igloo> And put "print errno" on the line before the "if errno == eEXIST" in takeFile in Lock.lhs?
16:00:20 <Igloo> (it might be easier to see what's going on if you look at tests.pl and run the necessary commands by hand. I'm not sure if the test stuff will confuse the output)
16:00:31 <Igloo> Bah, tests/pull.pl I meant
16:00:48 <lispy> i can't read perl, so lets add these debug statements first
16:01:02 <Igloo> (oh, and don't forget the \n when printing on the C side. You might need #include <errno.h> too)
16:01:42 <Igloo> You shouldn't really need to be able to read perl. It looks like shell with some extra cruft
16:02:34 <lispy> No instance for (Show Foreign.C.Error.Errno)
16:03:20 <Igloo> *sigh*. case errno of Errno e -> print e
16:03:31 <Igloo> You might need to import Errno(Errno) from Foreign.C
16:03:55 <Igloo> (sighing at lack of Show instances, not at you  :-)  )
16:04:21 <Igloo> (you can do   cd tests; perl perl_harness pull.pl   to just run that test, incidentally)
16:05:07 <lispy> Igloo: understood on all accounts, i was kind of annoyed at the lack of show as well
16:06:59 <ral1> Has anyone read the article on Solving Sudoku on the tmr wiki?
16:07:00 <ral1> http://www.haskell.org/tmrwiki/SolvingSudoku
16:07:17 <lispy> no, i've not heard of sudoku before
16:07:28 <shapr> I read it!
16:07:42 <shapr> Probably because I'm the editor of TMR...
16:07:57 <ral1> lispy: well, there's the link.  I've not heard of it either.  It's a number game based on a grid of digits that is a fad in London, or wherever people read the times.
16:08:03 <ral1> shapr: I noticed.
16:08:07 <ral1> Long time, no write.
16:08:12 <ral1> I fade in and out.
16:08:18 <shapr> Yeah, me too
16:08:38 <ral1> shapr: Well, I have mad respect for you.  You seem to have incredible haskell skills.
16:08:45 <ral1> I'm more of a jack of all trades.
16:09:13 <shapr> My Haskillz aren't really that wonderful, I don't think. I'm just interested in a lot of stuff.
16:09:15 <Heffalump> who wrote that article?
16:09:23 <shapr> Poetix, aka Dominic Fox.
16:09:26 <ral1> I haven't don't really master things, but I'm still young, so I'm hoping/expecting that one day here, I'm going to master all of my different interests at once.
16:09:59 <shapr> Poetix is a cool guy, he has a master's degree in English or English Literature, I forget which.
16:10:22 <ral1> In fact imagining the structure causing this imagined event is one of the major distractions keeping me from mastering anything.
16:10:35 <ral1> Well, I still don't quite know what monads are about.
16:10:41 <shapr> abstraction!
16:10:46 <ral1> Yeah?
16:10:51 <ral1> I feel like I have this intuition for them.
16:10:55 <ral1> But I can't use them.
16:10:59 <ral1> So I must not understand them.
16:11:02 <shapr> Yeah, monads are sort of like metaclasses.
16:11:02 <lispy> i can use other peoples monads, and i can define simple monads, but i don't think i really get them
16:11:08 <ral1> I thought that reading this article could help me.
16:11:15 <ral1> shapr: I'm just not followin' ya.
16:11:18 <ral1> But I'm listening.
16:11:32 <shapr> Well, Cale wrote a really cool monad tutorial, lemme get the url.
16:11:42 <shapr> http://www.haskell.org/hawiki/MonadsAsContainers
16:12:14 <lispy> one think i wonder is, if lazy evaluation makes IO tricky, why are monads the right way to bring back sequencing?
16:12:40 <shapr> Because monads make later computations explicitly dependent on earlier computations.
16:13:04 <Igloo> s/make/can make/  :-)
16:13:09 <lispy> but so do blocks of code in say, C
16:13:25 <Igloo> lispy: Are we waiting for that to compile, BTW?
16:13:25 <wagle> i thought the bind / join.fmap isomorphism was just for some monads
16:13:32 <lispy> Igloo: very much soo
16:13:34 <shapr> Yeah, but if C used call-by-need, things would be different.
16:13:39 <Igloo> OK, cool
16:14:06 <ral1> shapr: what do you mean, if C used call-by-need
16:14:17 <lispy> Igloo: it would be fater, but gcc is still boostrapping :)
16:14:43 <lispy> shapr: yeah...
16:14:45 <Igloo> I was just checking we weren't waiting for each other
16:15:02 <TheHunter> wagle, (=<<) = (join .) . fmap follows from the laws that monads+functors should satisfy.
16:15:36 <wagle> people have told me this, but never give the examples
16:15:40 <shapr> ral1: Do you know call-by-need evaluation?
16:15:49 <ral1> shapr: no.
16:16:03 <TheHunter> wagle, you want me to proof it?
16:16:09 <shapr> Oh, I want to see it!
16:16:12 <lispy> shapr: okay, so how do monads make the dependency explicit?
16:16:30 <TheHunter> @docs Prelude
16:16:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
16:16:32 <wagle> doesnt address what they told me
16:16:53 <wagle> me, i like the join.fmap
16:17:12 <wagle> definition
16:17:18 <shapr> Because monads are (a -> m a) and the m a ends up being a -> m a and then you get (a -> (a -> (a -> ...)))
16:17:34 <ral1> question: I was working on some functions relevant to number theory (specifically gauss's lemma and quadratic reciprocity, if you know some number theory).   what you do is map functions over a list again and again.  The list always has integers, so somehow, I guessed that monads might be the right way to think about this.  I couldn't get it to work, but was my intuition right?
16:17:35 <wagle> when i saw that, it was a major step towards grokking monads
16:17:55 <lispy> shapr: heh, okay.  Also looks a lot like a lisp style list
16:17:59 <ral1> shapr: that's helpful.
16:18:28 <ral1> The process of understanding monads is really beautiful.
16:19:15 <ral1> There is a long period (not necessarily long in time) during which you understand the idea intuitively, but not practically.  I think that I have stretched this period (in time) about as long as possible.
16:20:04 <ral1> In fact, I'm in the middle of my second book on Category Theory, the readings of which were entirely inspired by monads in Haskell.  And I still don't even faintly understand monads in Haskell (in a practical sense).
16:20:29 <wagle> ral1: which cat theory books?
16:20:46 <lispy> this is a big problem for people learning to effectively program in Haskell, IMHO
16:20:54 <lispy> monads are hard to grok
16:21:02 <lispy> not hard to use, but hard to grok fully
16:21:17 <wagle> i think most programmers are never going to understand monads
16:21:44 <ral1> wagle: Conceptual Mathematics: A First Introduction to Categories, by Bill Lawvere, and Steve Schanuel, and now Sets For Mathematics (actually a book on CT; don't be decieved) by Lawvere.
16:22:22 <lispy> is category theory good? I 've heard it's so general that it's annoying
16:22:27 <ral1> lispy:  Well, could you recommend some exercises so that I can learn how to _use_ monads?
16:22:31 <wagle> ahh..  the latter looks interesting..
16:22:38 <ral1> lispy: It is better than any drug.
16:22:41 <Igloo> You don't need a full understand of monads to be able to use the important ones as black boxes
16:22:47 <lispy> ral1: um...programming :)
16:23:07 <Igloo> No more than you need to no about tlb caches etc to write something in C
16:23:18 <lispy> ral1: write your own list data type without using the builtin list, and then make it a monad
16:23:30 <wagle> write a scheme interpreter, then add a symbol table and/or gensym..  8)
16:23:35 <ral1> lisp: I'm laughing out loud.  Man, I really do love Category Theory.  It seriously gets me high.  But I used to feel that way about programming.  I am trying to get back into coding.
16:23:50 <lispy> wagle: i'm in the process of doing something similar, how will monads help?
16:23:54 <ral1> uhhh.  I may need a little more help with those exercises.  Maybe not.
16:24:14 * Igloo plugs bark as a nice example of lots of layered monad transformers  :-)
16:24:32 <ral1> plugs bark?
16:24:36 <wagle> lispy: you dont have a global var to track the gensym counter
16:24:57 <ral1> lispy: Who on earth said that CT is annoying?
16:25:10 <Igloo> darcs get http://urchin.earth.li/darcs/ian/bts/
16:25:29 <lispy> ral1: um....i don't remeber now, people i know
16:25:30 <wagle> i'll probably be back in a bit
16:25:37 <lispy> wagle: hmm...
16:25:41 <lispy> wagle: see ya
16:25:47 <lispy> Igloo: it just built
16:25:50 <Igloo> Probably actually too big to be easy to get an understanding of how the transformers make things easier, actually
16:26:03 <Igloo> Hmm, too many "actually"s
16:26:25 <ral1> lispy: Well, you should be able to get your friends together a bit after you read Conceptual Mathematics.
16:26:57 <lispy> ral1: is that pretty good? I have a bachelors in math, but i never studied CT
16:27:32 <Igloo> lispy: And?  :-)
16:27:51 <astrolabe> I don't see how something can be so general it's annoying, unless it is so general that nothing non-obvious holds, which is not the case for CT.
16:28:10 <lispy> Igloo: i'm going to paste in to a pastebin, one momement :)
16:28:21 <shapr> I think CT is like really pedantic common sense.
16:28:45 <ral1> lispy: Oh My G-d!!  You have a bachelors in math!!!?? You're going to _love_ it!   I promise you'll love it.  I have a bachelors in math too.  I read that book, and I was just like, wtf?  Why didn't they just teach this stuff to begin with.
16:28:55 <lisppaste2> lispy pasted "darcs test" at http://paste.lisp.org/display/10155
16:28:58 <ral1> well, obviously i disagree with shapr.
16:29:00 <ral1> But maybe not.
16:29:06 <dcoutts> I didn't find that studying category theory helped me understand monads
16:29:13 <ral1> It depends on whether we think pedantic common sense is good and important.
16:29:29 <ral1> Hm.  I guess I'm in the minority.   Maybe I ought to shut up.
16:29:32 <lispy> ral1: heh, so Conceptual Mathematics, aye?
16:29:40 <lispy> Igloo: did you see that URL?
16:29:44 <ral1> lispy: Yes.
16:29:50 <ral1> Just promise me you'll write me after you read it.
16:30:00 <dcoutts> it was interesting for giving another explanation to ordinary functions, types, type constructors and polymorphic functions
16:30:03 <astrolabe> I found a lot of proofs in category theory were difficult, even though each stage was beneath trivial (or maybe because of that).
16:30:06 * Enveigler_ twitches
16:30:08 <Igloo> Yes, I'm just being confused by the output
16:30:11 <shapr> Oh yeah, I think pedantic common sense is good and important, definitely.
16:30:21 <shapr> Enveigler_: Too much coffee?
16:30:23 <ral1> lispy: I made a little website about people that I know who have read the book, or been influenced by it.
16:30:38 <lispy> ral1: cool, i'm googling it now
16:30:50 <lispy> Igloo: okay, let me know if i can help
16:31:04 <Enveigler_> No. I'm tempted to provide counterpoint opinion, but I'm not qualified to do so :)
16:31:22 <Igloo> takeFile: errno="13"   is what you made takeFile print, right?
16:31:33 <lispy> ya
16:31:38 <astrolabe> Enveigler_: Don't let THAT stop you.
16:31:46 <Igloo> On the line above "if errno == eEXIST"?
16:31:53 <lispy> yes
16:31:54 <ral1> ok.  Then I agree with shapr.  But the word pedantic seems to imply something negative about the pedant's attitude.  Maybe I would prefer "Important common sense" or "friendly common sense" or "clear and obvious common sense" or even (if you must) "redundant common sense"
16:32:13 <shapr> I think pedantic just means "really really picky".
16:32:24 <ral1> o.
16:32:30 <ral1> Then I agree, I think.
16:32:40 <Igloo> Where does getCurrentDirectory come from in Workaround.hs?
16:32:40 <shapr> @wn pedantic
16:32:43 <lambdabot> *** "pedantic" wn "WordNet (r) 2.0"
16:32:43 <lambdabot> pedantic
16:32:43 <lambdabot>   adj : marked by a narrow focus on or display of learning
16:32:43 <lambdabot>     especially its trivial aspects [syn: {academic}, {donnish}]
16:32:51 <lispy> Igloo: what do you mean?
16:33:06 <astrolabe> shapr: I'm not sure what you mean by common sense.  How can common sense have an opinion about the uniqueness of adjoint functors for instance?
16:33:12 <shapr> So, Category Theory is really really picky and exact about relationships among/between things.
16:33:13 <Igloo> It'll either be imported from somewhere or defined in that file
16:33:52 <shapr> astrolabe: Humans can keep track of very convoluted social relationships, I think CT is sort of the same thing, but not necessarily about people.
16:33:54 <lispy> man, this gcc install is really slowing this down
16:34:42 <astrolabe> shapr:  Do you mean in a way that the rest of mathematics doesn't?
16:34:46 <shapr> Some of the gossip I've heard from college girls would have required CT just to keep track of who's doing what to whom.
16:35:11 <astrolabe> shapr: I think that stuff is formally undecideable.
16:35:13 <ral1> no.  Then it's the opposite.  Category Theory (ironically) allows you to explain ideas with a minimal amount of mathematics.  So there is no focus on the display of learning.  Arguably, the decision to work with abstractions may be motivated by the desire to obfuscate, but this is a standard paradox with abstraction.  Anyone who knows haskell and cares what other people think about it have thought about this problem a lot.
16:35:30 <lispy> Igloo: import System.Directory(getCurrentDirectory)
16:35:36 <ral1> shapr: that's a fine use for category theory, even when the relationships are quite simple.
16:35:42 * Igloo is fairly sure the problem is going to be getCurrentDirectory resetting errno
16:35:50 <shapr> astrolabe: What? Gossip is formally undecidabe? =)
16:36:01 <ral1> So I'm reading this tutorial (MonadsAsContainers)
16:36:32 <astrolabe> I think one cool thing about CT is also a cool thing about monads.  It shows you that the same thing is going on in apparently different cases.
16:36:48 <lispy> ral1: that will help you understand monads quite a bit. especially that list exercise i mentioned
16:37:09 <ral1> astrolabe: Righto.  Have you read Wadler's papers on this?
16:37:24 <ral1> lispy: Thanks.  I'm all excited now.
16:37:34 <ral1> Did anyone read my question above on number theory?
16:37:35 <astrolabe> shapr:  Only college girl gossip about who's doing what to whom.  Boy's gossip is trivial.
16:37:39 <Igloo> Can you try it with    throwErrno $ "takeLock "++s++" in "++pwd   replace with   ioError (errnoToIOError ("takeLock "++s++" in "++pwd) errno Nothing Nothing)   please?
16:37:40 <ral1> I could post the code somewhere.
16:37:54 <lispy> Igloo: sure, umm...where?
16:38:05 <astrolabe> ral1: no I haven't.  I know I should.
16:38:09 <shapr> astrolabe: I've heard office gossip that's pretty convoluted.
16:38:20 <Igloo> takeFile in Lock. And I meant takeFile in the strings up there too  :-)
16:38:41 <lispy> okay, hang on
16:38:45 <ral1> astrolabe: I think you'll be surprised.  He writes to be understood.
16:38:47 <Enveigler_> astrolabe: Making Batter and bread is essentially the same thing despite the difference in the end product--but, does knowing that make the making of either easier? More intative or productive?
16:39:06 <astrolabe> ral1: Were you talking about calculating whether one number was a quadratic residue modulo another using factorisation and the theorem aurem?
16:39:26 <Heffalump> to get a time profile, I compile with ghc -prof then run with +RTS -p -RTS, right?
16:39:27 <ral1> astrolabe: And I agree.  Monads are the one thing which really really sold me on Category Theory.  But once I got into it, I found all kinds of other reasons to love it.
16:39:46 <ral1> No.  What's the theorem aurem?  So you know some NT.  I could post the code.
16:39:51 <ral1> It is about gauss's lemma.
16:40:10 <Igloo> Heff: You probably want to compile with -auto-all too
16:40:14 <ral1> I wanted to code up a tutorial for gauss's lemma using haskell, because I think that haskell.
16:40:28 <Heffalump> ah, yes, that's what I was forgetting.
16:40:38 <Heffalump> I was wondering why everything was just being charged to CAFs with no breakdown
16:40:39 <astrolabe> Enveigler:  Seeing analogies is the most important method of understanding the world, I think.
16:41:54 <ral1> Because gauss's lemma is _about_ mapping functions over a list.  It is hard for people to understand this theorem for that reason, because such a technique is not too common in mathematics (not so explicitly, but it could, and maybe should, be more common).
16:42:18 <astrolabe> ral1: The theorem aurem (golden theorem) is the big quadratic reciprocity theorem (at least at my unexaulted level).  For primes p and q, it relates the quadratic character of the residues of p mod q and q mod p.  It is an amazing result.
16:42:36 <ral1> If someone understood haskell, then an explanation of gauss's lemma (and then the famous quadratic reciprocity theorem) would be almost trivial.
16:42:46 <ral1> It would be just like reading an easy piece of code.
16:42:52 <Enveigler_> Astrolabe: Agreed. But the main purpose of analogies is to simplify the thing being analogized. So far, I find monads far from a simplification of the sequential steps in other langguages :(
16:43:00 <ral1> astrolabe: Yes.  we're thinking of the same theorem.  Indeed a beautiful and mysterious result.
16:43:26 <ral1> Enveigler_: Hang in there.  I'm having trouble grocking monads too.
16:44:24 <astrolabe> Enveigler_:  You could just try using monads for a bit, and trying to understand them when you are more familiar with them.
16:44:43 <astrolabe> ral1:  What is the list you are mapping over?
16:45:07 <Enveigler_> That's the thing ral1: I think I got them pretty much straigh t away (without making any claims to being able to _use_ them). My problem is that I find that the theory obscures the practice.
16:45:14 <ral1> Other languages either have structures which are more awkward (If not more difficult) than monads, or they are impure, in which case, you don't have a real guarantee of correctness.  Bad things might happen down the road, and you are less able to scale your programs.  Using monads makes your programs tight like math proofs.
16:45:25 <Enveigler_> Astrolabe: See, I told you I wasn't qualified :)
16:45:43 <ral1> Enveigler_: Yes.  I'm definitely being too theoretical here.
16:46:04 <ral1> Like I said, there is a part of me that wants to prolong the innocence of a purely theoretical understanding.
16:46:12 <ral1> not even theoretical.  Purely intuitive.
16:46:22 <astrolabe> Enveigler_: My point wasn't so much that you were as that if that was necessary, then I'd have to shut up.
16:46:52 <Enveigler_> 'K :)
16:47:06 <ral1> astrolabe: You take an [Int] and then you square each element, then you reduce each element modulo p.
16:47:12 <wagle> Enveigler_: do you know about aspect-oriented-programming or program-slicing?
16:47:33 <ral1> In another version of the proof, you take an [Int] and you multiply a through the whole thing and then count the ones greater than p/2.
16:47:45 <ral1> Sorry that I am not being at all clear here as regards the mathematics.
16:48:03 <ral1> Anyway, I emailed someone who had written some rsa-number-theory package.
16:48:27 <ral1> It would be cool to write this theorem out as a function in haskell.  If it's out there already, I can't find it.
16:48:36 <Heffalump> wagle: I know something about both, if that helps :-)
16:48:38 <lispy> i wrote an rsa thingy in haskell, but didn't release it
16:48:47 <astrolabe> ral1: I think I know the proof you are talking about.
16:48:48 <lispy> i even use miller-rabin to generate primes
16:48:54 <ral1> Actually, I've been thinking a lot lately about writing number theory in haskell.  Not necessarily to compute, but to explain.  Some of it wouldn't be at all useful.
16:48:57 <Enveigler_> wagle: kinda. Using traits.mixings to composite behaviours rather than inherit them?
16:49:00 <ral1> but then who knows...
16:49:41 <ral1> lispy: that's cool.  That's what this one uses.  I don't know much cryptography.
16:49:47 <astrolabe> ral1: I'm not sure I quite follow you.  Are you thinking list comprehensions?
16:50:00 <lispy> ral1: i know just enough to be dangerous
16:50:03 <ral1> No.  I don't think so.
16:50:09 <lispy> ral1: but not enough to actually be secure
16:50:10 <ral1> lispy: Are you sure?
16:50:14 <wagle> to mix and overload my metaphors, i see (one thing that) monad's (do is) slicing out aspects of side-effect chains
16:50:46 <lispy> ral1: well, i know that i generate strong psuedo primes, but i don't actually know if they are good enough to use for daily crytographic purposes
16:50:53 <wagle> in an imperative language, you often have to mix that all together in one pot
16:51:26 <wagle> (i'm pushing for intuition, not accuracy or precision, by the way)
16:52:33 <Enveigler_> I hadn't thought of it that way wagle, but it makes some sense. The problem from my (imperative) persepctive is that it seems inside out
16:52:52 <wagle> so it appears to be easier in a imperative language, but it (speculation) is harder to be correct (and/or reason about, say concurrency/parallelism)
16:53:58 <astrolabe> My latest 'insight' about monads, I got from a paper.  It is that monads allow you to increase the number of functions between two types in such a way that these generalised functions are still composable in a sensible way.
16:54:07 <Heffalump> hmm. How do I get a profile that includes the library functions I called?
16:54:18 <Enveigler_> I think it is fair to say it is harder to *prove* correctness--but then I am not entirely sold on the benefits of proofs anyway.
16:54:33 <ral1> Enveigler_: Is it possible that its that perspective itself that is inside out?
16:54:53 <ral1> wagle: And I don't think that it's really easier to reason in an imperative language either.  It's just different.
16:55:11 <ral1> astrolabe: interesting.  What paper?
16:55:33 <lisppaste2> lispy annotated #10155 with "make test after our changes" at http://paste.lisp.org/display/10155#1
16:55:58 <astrolabe> ral1: ahem:  I should say that I've done a lot of interpretation, and may have introduced errors :)
16:56:00 <wagle> ral1: note that i said "appears to be easier"
16:57:39 <Enveigler_> Quite possible ral1, but it has served me for 25+ years as a professional programmer--it's hard to give it up without a fight ;)
16:57:47 <astrolabe> ra1:  It was the def^n of kleisli category in this: (not really a paper) http://types2004.lri.fr/SLIDES/uustalu.pdf
16:57:48 <wagle> i think in terms of compilers and partial evaluators, etc.  so I see something quite different from most people when i look at a C program...
16:58:24 <Enveigler_> I read something in an entirely different context earlier today that seems appropriate " ...  the majority of the articles and books (if not all of them) are written by math people, for the math people, in a language which even most of the math people themselves cannot understand what is going on...."
16:59:08 <astrolabe> Enveigler_: LOL
17:00:38 <ral1> Enveigler_: Don't worry.  We still don't prove most things.  It's just that programming in languages which are purely functional are more modular.  They have these theoretical properties, sure, and maybe these theoretical properties, like the _possibility_ or rigorous proof within the language are what some people get excited about and talk about, but what's really going on here, technically, is that the programs are simply more modu
17:01:29 <wagle> programatica is working on proofs for haskell programs
17:02:22 <Enveigler_> "the programs are simply more modu" Is that true ral1? Have you looked Oz?
17:02:53 <ral1> Until monads, though, there were certain important things (usually relating to time) like state, IO and randomness, which were conspicuously, even prohibitively difficult in functional programming.  So Functional programmers had to choose between really awkward syntax or making their languages impure.
17:02:59 <ral1> Monads fixed everything.
17:03:06 <ral1> Enveigler_: Googling oz.
17:03:49 <ral1> Enveigler_: re: a fight.  I think it's worth a fight.
17:03:52 <Enveigler_> ral1: http://www.mozart-oz.org/documentation/system/index.html
17:04:27 <wagle> huh.  i was just looking at mozart/oz a couple days ago..  i wonder what lead me there
17:06:15 <Enveigler_> That's why I'm still coming here. Despite all my reservations and frustrations, I have this nagging at the back of my brain that if I stick at it, the penny will drop and I see something that I am currently missing
17:06:35 <ral1> Enveigler_:  re quote on math:  That's absolutely true.  One of the aims of CT, one of its uses in recent decades, is to organize mathematics, by providing a unified foundation, thus making the disparate branches of math mutually decipherable.
17:06:46 <wagle> ... might have been The Quest for a Linear Logic Programming Language that wasnt based on the intuitionistic fragment lolli was
17:07:09 <ral1> I think that the idea is very much like ideas of valuing documentation and human readability and code reusability  in software.
17:07:46 <ral1> Enveigler_: When you start to code a function, do you first write out the type signature?
17:07:56 <Enveigler_> Wagle: Yu might find  http://www.ulb.ac.be/di/rwuyts/INFO020_2003/vanRoyHaridi2003-book.pdf interesting. I'm waiting for the real ting to arrive, but the pdf makes for an interesting alternate view of things.
17:09:06 <astrolabe> Woah 939 pages!
17:09:10 <Enveigler_> I haven't done a great deal of Haskell. It's too frustrating. I'm hoping to use Oz as a stepping stone.
17:09:21 <Enveigler_> Yeah; It's big.
17:10:25 <astrolabe> Too big for acrobat on my computer :(
17:12:23 <wagle> i didnt buy the original macintosh because the wysiwyg could only handle up to 3 pages..
17:12:28 <astrolabe> Enveigler_:  Is it the monads that you find frustrating?
17:12:40 <ral1> Enveigler_: I'm sorry that you find it frustrating.  Maybe it would help if you had a good teacher.
17:12:55 <wagle> Enveigler_: that looks familier
17:13:40 <ral1> Many smart hand considerate haskell missionaries have written good tutorials, but that doesn't always help.  Sometimes, you need to be almost all set up with some context to get going.
17:15:19 <wagle> i find most tutorials try to give some pure idea and hide important stuff from you.  if your intuition either doesnt automatically figure the missing stuff out (or gets it wrong!) then you end up very confused/uncomfortable
17:15:37 <wagle> s/important/important, but grody,/
17:16:03 <ral1> wagle: Well, just so you know, I am a bit of a newbie myself.  So I hope that none of this comes across as weathered advice.
17:16:11 <Enveigler_> The docs mostly. The type signatures (which is all you get by way of docs for much of Haskell) doesn't tell me how to /use/ the functions. What I think I need to do isget comfortable with the basics, but programming yet another version of factorial just doesn't float my boat. One or two examples that solve a real problem from a specification and then refine it might help.
17:16:18 <ral1> I agree.  But in fairness, it's hard to write a good tutorial.
17:16:20 <wagle> "here's the IO monad, but we arent going to tell you what the interpreter does with values of type IO"
17:18:31 <wagle> i hagve about 4 completely different notions of what continuations are in my head, and i can interchange between them pretty freely..  but people teaching continuations (in my experience) insist that there is Only One Way To Understand Them" ...
17:18:39 <wagle> s/hagve/have/
17:19:42 <wagle> i only bring up continuations because thats the first main place i experienced this phenomenon..  but it appears elsewhere
17:19:58 <{|mono|}> they do the same thing to monads.
17:20:21 <{|mono|}> or rather, they talk about monads the same way.
17:20:29 <wagle> i suspect its a difference between what i call algebraists and geometers..
17:20:32 <ral1> Enveigler_:  The significance of type signatures is one easy thing to miss.  For example, what do you think this function does? zip :: [a] -> [b] -> [(a,b)]
17:21:03 <wagle> algebraists see syntax..  geometers visualize meaning
17:21:22 <wagle> i'm a geometer..  i really dont understand algebraists
17:21:24 <ral1> wagle: that's not entirely fair...
17:21:38 <ral1> wagle: But there's truth in it.
17:22:04 <wagle> ral1: i bought it up to see what more light could be shone upon it
17:22:09 <astrolabe> I'm almost sort of an algerbraic geometer :)
17:22:10 <{|mono|}> I visualize meaning as funny syntax
17:22:40 <astrolabe> I would say analysts see syntax, algebraists see structure.
17:23:19 <ral1> astrolabe: wagle: Algebraists see meeing through syntax.  Geometers see meaning through their sense of space.  The best is when you do both at once.
17:23:22 <ral1> astrolabe: good one.
17:23:25 <Enveigler> ral1: It builds a list of tuples from two lists.
17:23:44 <Enveigler> But that doesn't tell me when I would want to do that.
17:24:05 <ral1> Enveigler: Right, and how does it build the tuple?  Make a guess.
17:24:25 <ral1> let's say I called zip [1,2,3] [4,5,6].
17:25:01 <Enveigler> => [(1,4) (2,5) (3,6 ]
17:25:09 <Enveigler> ^)
17:25:28 <ral1> Precicely.
17:25:29 <wagle> i took program verification.  was very exciting to compute things like binary chop without and not have to worry about off-by-one errors..  then i tried to program, and just tripped over myself...
17:25:37 <astrolabe> Clearly you can't tell what most functions do just from their type signatures though.  You need more documentation before you can use them.
17:25:44 <{|mono|}> It is rare to think of programs or data or types as geometric objects.
17:25:52 <wagle> i had to forget all that insight before i could program again
17:26:12 <wagle> i cant represent my thinking about programs in first-order-logic
17:26:17 <Enveigler> But your missing the point. If I want to process parrallel arrays, why bother building tuples from them?
17:26:51 <wagle> Enveigler_: i never saw the description of what you are trying to do (tuples?  parallel arrays?)
17:26:52 <ral1> astrolabe: Documentation is very important.  But having strong types usually gets you further to an understanding of a function than what you expected.
17:27:21 <ral1> wagle: I was just demonstrating to Enveigler how useful type signatures can be.
17:27:26 <Enveigler> wagle: I have a simple picture of continuations: A continuation is a thread that gets suspended when it returns and can be restarted from the point of return by re-invoking the continuation.
17:27:28 <ral1> wagle: I gave zip as an example.
17:27:39 <{|mono|}> Either that, or you have to let go of thinking and programming, and start calculating instead.
17:28:29 <ral1> Just checking: Am I the only one who thinks it's totally creepy that this conversation is archived and can be searched by anyone forever?
17:28:39 <Heffalump> no, I don't like it either
17:28:39 <wagle> since then i've tried to expand my knowledge of logic (non-classical, substructural, etc) and am ready to give it another stab
17:28:58 <ral1> s/totally creepy/kinda creepy/
17:29:03 <{|mono|}> I don't think you need much more than classical logic.
17:29:11 <Heffalump> well, I don't mind it particularly for technical conversations, which are probably the majority of conversations. But I like to chat too.
17:29:31 <{|mono|}> "forever is a long, long time..."
17:29:32 <ral1> {|mono|} No way!!  Classical logic thinks that not^2 = zero!
17:29:52 <ral1> Heffalump: right.
17:29:55 <wagle> i sent an email around 1984..  i remember thinking "whoa!  if he saves this and shows up someplace, i'm going to be embarrassed!"..  it showed up on the web about 3 years ago
17:30:13 <ral1> wagle: Creepy, creepy, creepy.
17:30:20 <{|mono|}> 1984 is a sensitive number.
17:30:21 <wagle> (i'd decided "nah!  i'll never see that again")
17:30:38 <ral1> I hope no one googles me for "creepy"
17:31:08 <wagle> @google ral1 creepy
17:31:10 <lambdabot> http://forums.egullet.com/lofiversion/index.php/t46613.html
17:31:25 <astrolabe> I guess these days anything that gets into a computer could be kept.  The only difference is we know it is happening with this chat.
17:31:25 <ral1> Bwaaaah!  Get it off me!
17:31:48 <ral1> astrolabe: and with gmail.
17:32:10 <astrolabe> gmail?
17:32:17 <ral1> google's mail service.
17:32:34 <astrolabe> are you going to tell me it's encrypted?
17:32:43 <ral1> no, it's the opposite of encrypted.
17:32:53 <ral1> It's mined for advertising and archived forever.
17:33:08 <astrolabe> Wow
17:33:30 <{|mono|}> My words are full of wisdom.  More people should save them up and read them more.
17:33:37 <ral1> And let's not talk about a certain act by a certain country-lover.
17:33:52 * Enveigler has a gmal account, but has only sent 1 email and recieved two from it--one of those was the Welcome from the Gmail team message :)
17:34:11 <ral1> Enveigler: It's well desigined software and so is tempting to use.
17:34:27 <wagle> ral1: is http://home.flash.net/~ral1/ you?
17:34:30 <astrolabe> If they get a better understanding of psychology, they'll have personality profiles of each of us.
17:34:55 <Enveigler> Indeed, their the new MS.
17:35:13 <ral1> astrolabe: No, man.  It's there already.
17:35:31 <ral1> Sorry to get us off topic.  I just wanted to check that I'm not the only one who's a bit creep'd out.
17:35:35 <ral1> Moving on...
17:36:52 <Heffalump> I did suggest shapr consider removing the logging, but he wasn't keen. Anyway, I'm off to bed.
17:37:02 <wagle> gnite
17:37:10 <astrolabe> Too late now ral1:  Your meandering has been automatically registered.  You will receive punishment when these records are analysed.
17:37:23 <ral1> Heffalump: I'm with shapr.  If we removed the logging, we would not have easy access, but anyone who wanted to could.
17:37:37 <Heffalump> it'd be unlikely to end up in google, though
17:37:39 <Enveigler> Here's a question. Does anyone have a standalone haskell program that reads some numbers from a file, processes those numbers using some pure functions and the writes the results back to (another) file?
17:38:05 <ral1> astrolabe: Or less dramatically, when I apply for jobs programming in Haskell, they will certainly search this channel.  This has already happened.
17:38:32 <Heffalump> there are jobs programming in Haskell? :-)
17:38:54 <astrolabe> I suppose a secret username would stop casual searches.
17:39:01 <wagle> Heffalump: a few
17:39:07 <Heffalump> (well, I know of a few, but mostly they are US defence contractors, which isn't much use to non-US citizens)
17:39:18 <ral1> astrolabe: I met a girl on the internet, rather than sending me her picture, she suggested that I google her name to find it myself.  okay.... So I search and I find an amazon book review in which she's talking about her troubled former marriage.  It didn't really turn me off, but it was probably something that she wanted to tell me about on her own later.
17:39:24 <ral1> Heffalump: very few.
17:39:57 <ral1> astrolabe: A secret username is a good temp solution.
17:40:09 <wagle> Heffalump: i can think of a number of employees who arent US citizens
17:40:29 <ral1> The best though is developing a proper understanding (even outside of geekdom) of privacy.
17:40:35 <Heffalump> wagle: yeah, ok, but I had the impression Galois is only hiring US citizens right now
17:41:02 <wagle> less expensive to get clearances, i'm sure
17:41:11 <ral1> Sh*t.  Enveigler quit.  I wanted to post him/her some code.
17:41:32 <Heffalump> I thought non-US citizens basically can't get clearances.
17:41:38 <Enveigler> Still here--that was my previous incarnation.
17:41:46 <wagle> Heffalump: i dont know
17:41:50 <ral1> ah.  Good.  So, do you know some number theory?
17:42:58 <astrolabe> Enveigler: were you just after an example so you could see how it was done?
17:43:10 * Heffalump really goes to bed
17:43:30 <wagle> ls
17:44:17 * astrolabe goes to bed too.
17:44:19 <Enveigler> I'd like to see several programs of that type and see how much of them I understand and also re-write them in a couple of other languages to geta feel for how they compare.
17:44:48 <Enveigler> ral1: What's Number Theory?
17:44:53 <Enveigler> :)
17:45:04 <{|mono|}> main = interact (unwords . map show . mypurefunc . map read . words)  where mypurefunc xs = map (+ 1) xs
17:45:43 <{|mono|}> The above program probably reads a stream of numbers from stdin, adds one to each, and outputs the results to stdout.
17:46:29 <Enveigler> Okay, but I want to able to process the numbers several times conditionally upon the result derived from earlier passes?
17:46:34 <{|mono|}> You can probably replace mypurefunc to do very funny things.
17:46:50 <{|mono|}> Do all that in mypurefunc.
17:47:11 <ral1> Enveigler: Perfect.  So how do you feel about learning a little number theory with your haskell.
17:47:16 <{|mono|}> The parameter xs holds the entire stream of numbers.  Do whatever you want to it.
17:47:26 <ral1> Is there some standard way to post code, or should I just post it to my home sight?
17:47:33 <ral1> s/sight/site/
17:47:44 <wagle> @paste
17:47:45 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
17:47:49 <{|mono|}> mypurefunc xs is Turing-complete.
17:48:01 <wagle> ral1: ^^^
17:48:31 <Enveigler> Well. The "mathematicians write for mathematicians" quote came from an article about the Wavelet Transform
17:48:51 <{|mono|}> mypurefunc xs = if sum xs > 0 then map (+ 1) xs else map (* 2) xs
17:48:56 <wagle> main=do{l<-getLine;if(l/="42")then(putStrLn l>>main)else(return())}
17:49:18 <wagle> oops wrong one
17:49:18 <ral1> Enveigler: I think it's a good quote and and an important point.
17:49:27 <ral1> Too many mathematicians write in Perl, so to speak.
17:49:37 <{|mono|}> This mypurefunc first sums up all the numbers.  If the sum is positive, it outputs each number plus one; otherwise it outputs each number times two.
17:49:43 <Enveigler> Oh. If only they would :)
17:50:05 <wagle> main=getContents>>=mapM(\s->print$product[2|c<-s,c`elem`"TDLF"]).lines
17:50:05 <{|mono|}> This will use quite some memory because the entire list has to be stored in memory.
17:50:39 <Enveigler> Mono: Right. That's one problem.
17:50:41 <{|mono|}> The ANSI C equivalent is forced to use similarly much memory too.
17:51:02 <wagle> third shortest kamil-in-haskell on SPOJ
17:51:16 <Enveigler> Not really because I can address the file as an array.
17:51:26 <{|mono|}> That is not ANSI C.
17:51:55 <wagle> what isnt ansi C?
17:51:59 <{|mono|}> "ANSI C equivalent"  all three words are important.  I phrase myself very carefully.
17:52:33 <ral1> I'm going to go get some dinner.  When I come back after an hour, I'll post some code.  I'm really excited because I think that I can explain fun number theory stuff and fun haskell stuff at the same time to someone who doesn't know either. (but you should know some haskell)
17:52:53 <{|mono|}> "ANSI" so you don't have mmap.  "equivalent" so you must still read from stdin and can't really fseek.
17:52:58 <Enveigler> ral1: Okay, I'll watch for it.
17:53:34 <Enveigler> mono: I did originally say "from a file", hence I could seek.
17:53:39 <wagle> if that is ansi C, why should we care?
17:55:09 <lispy> hhmmm...i dont' think gcc will finish compiling in my lifetime
17:55:28 <wagle> lispy: no, thats ghc
17:55:33 <{|mono|}> Given a few minutes I can replace "interact" by something that reads from one file and writes to another file.
17:56:03 <lispy> wagle: that did eventually finish tho :)
17:56:50 <wagle> lispy: eclipse didnt finish indexing gcc source..
17:57:25 <wagle> nono..  s/indexing/caching the types for the/
17:58:22 <{|mono|}> No, replacing "interact" does not allow me to fseek.
17:58:45 <wagle> anyone know 2-D canvas graphics for java or haskell?
17:59:07 <{|mono|}> You can no longer keep mypurefunc pure if you want it to fseek.
17:59:42 <Enveigler> mono: Right. So now you're into using fmap and/or liftM?
17:59:44 <lispy`> wagle: i don't have eclispe
18:00:19 <wagle> lispy`: just trying to find something that didnt actually finish with gcc
18:00:25 * Enveigler did graphics in Java a couple of years ago...I might remember something?
18:00:59 <lispy> aren't graphics one of the things java sucks at?
18:01:20 <lispy> i seem to remember someone trying to tell me that, but i have no idea..
18:01:51 <wagle> Enveigler: i have a old tcl/tk script that i'm hacking the bejeezus out of, and really would like to port it to haskell or java (or both, as an experiment)..
18:02:24 <wagle> the main thing is i want graphical objects on a canvas that i can click on, toggle, move, etc
18:02:56 <Enveigler> Doesn't Haskell have an interface to GTK2?
18:02:56 <wagle> tk makes this way easy..  but tcl isnt nice for large programs
18:03:13 <dons> Enveigler, yes, a rather good one. gtk2hs
18:03:26 <wagle> tk /= gtk
18:03:43 <Enveigler> I never used tcl. tk is okay, but resource hungary if you need to hit test (which you do for picking and drag&drop).
18:04:53 <Enveigler> No, but GTK is a very rich library. Most of tk maps in a reasonable way to gtk2 (I think--I haven't don;t anything very dramatic with either).
18:05:27 <Enveigler> dons: Is gtk2hs a separate download?
18:06:45 <wagle> haha..  gtk2hs + gtk-osx
18:08:26 <{|mono|}> Perhaps one can write a pure function for the first pass, another pure function for the second pass, and "main" to open files and call these pure functions and fseek at the right time.
18:08:41 <wagle> i learned tk in the early 90's, and its done all the gui i really needed (except when i ported a win32 3-d graphics app to x11/motif, and made a library i called ezwidgets (that was inspired by tk) to abstract out the complex motif gui to a simple gui api
18:09:25 <wagle> {|mono|}: what do you mean about pure function vs fseek?
18:10:47 <wagle> .. but i've been thinking i needed to learn gtk
18:11:14 <Enveigler> from what language wagle?
18:11:22 <wagle> Enveigler: yes
18:11:23 <wagle> 8)
18:11:29 <Enveigler> :)
18:12:02 <Enveigler> I've been twiddling with it from Perl--it's pretty easy.
18:12:43 <lispy> i like that gtk has a layout manager
18:12:55 <Enveigler> But perl no longer satisfies my aspirations.
18:13:10 <wagle> well, i've been hacking the gcc source for a while to add security features, so the combination has had me in this love-hate thing with C..  the thought of programming a GUI in C hasnt been very..  appealing..  as a result
18:13:12 * lispy hates perl and will use anything else
18:13:43 <wagle> i like perl4..  but want nested data strucures
18:14:09 * Enveigler thinks Perl is a fine langauge for getting stuff done in quickly, but wants more.
18:14:11 <wagle> perl4 is a nice sysadmin language
18:14:11 <lispy> i hate the syntax and the semantics :)
18:14:53 <lispy> wagle: i hear that, but i've never been able to get the job doneusing it
18:14:58 * Enveigler feels a little that way about Haskell so far. strokes for folks I guess.
18:15:15 <lispy> i had an OS class, and i cranked through the C assignments in no time, but the perl ones felt like hell :)
18:15:48 <wagle> perls fine for that..  a couple years ago in a newsgroup, someone had 40 lines of very hairy perl code and wanted help simplifying it..  i algebraically transformed it to a simple/obvious program half the size, but didnt test it because i didnt know how..  he checked it and it worked perfectly
18:15:53 * Enveigler is not at all keen on C -- but when nothing else works, it always does.
18:16:42 <wagle> there IS a bit of a learning curve getting used to the perl syntax..  and it IS horrible until you get over that
18:16:44 <lispy> C is not friendly to humans, but it is very useful
18:17:23 <lispy> wagle: and then there are all the hidden features (pitfalls?) you have to learn about
18:17:43 <wagle> i dont get what the big bugaboo about referential transparency is..  context sensitive algebraic transformations arent THAT hard
18:17:48 <Enveigler> I had much less trouble with Perl's syntax than Haskell 2d whitespace significant stuff.
18:18:21 <wagle> isnt haskell whitespace the same as python's?
18:18:33 * wagle never learned python
18:18:39 <Enveigler> Probably, but I hated Python also.
18:18:41 <Enveigler> :)
18:18:43 <wagle> hahah
18:18:52 <lispy> Enveigler: yes, the whitespace rules of haskell are unfortunate, i tend to use {} and ; just to avoid dealing with them
18:19:23 <Enveigler> I think that is an easier way to go also lispy.
18:19:40 <wagle> i hate python because everytime a gui shatters on some border condition, i find that its written in python
18:20:43 <wagle> it would help if the xemacs haskell mode would indent the way you wanted
18:21:05 <wagle> i have to fight it too often
18:21:19 <Enveigler> I am not aware that I use anything written in Python, and I discarded it quite quickly after installing it. Ruby was prefereable. Ruby is nice, just too slow.
18:21:25 <lispy> yes, emacs can't handle haskell because it doesn't parse the language.  It's a very, very sad "feature" of emacs
18:21:27 <Cale> The whitespace rules of Haskell are nice.
18:21:35 <wagle> like, it doesnt seem to know about case statements
18:21:50 * Enveigler can't handle emacs. <<Full stop.
18:21:59 <lispy> wagle: there is an extended haskell mode for emacs that lets you hit tab again to try a different alignment.  but it's not very good
18:22:09 <wagle> i learned the whitespace rules from the original haskell report
18:22:21 <Cale> I like the simple indent haskell-mode
18:22:31 <wagle> lispy: repeated tabs never hit anything reasonable..
18:22:36 <Cale> (rather than the smart one which cycles)
18:23:32 <wagle> vi is for programmers who cant handle emacs
18:23:36 <TheHunter> the layout rule is fine for everything except let, but 'where' is usually much nicer anyway.
18:23:38 * wagle runs
18:23:59 <Cale> TheHunter: what's the problem with let?
18:24:39 <TheHunter> actually, the problem happens with if+let, i though it was let's fault, but maybe it's actually if's
18:25:12 <Cale> Paste page?
18:25:37 <dons> wagle, nah, vi is just emacs with a different interface ;)
18:25:50 <lispy> the other thing i hate in Haskell is ($)
18:26:04 <dons> the emacs and vim bindings in yi are about the same length now (for about the same features)
18:26:05 <lispy> dons: don't you mean vim
18:26:27 <wagle> lispy: s/($)/(id::a->b)/
18:26:46 <Cale> id :: (a->b) -> (a->b)
18:26:57 <lispy> @type id
18:27:01 <dons> well, vi is to mg (a small emacs-alike), as vim is to a slightly stripped-down emacs
18:27:02 <lambdabot> forall a. a -> a
18:27:05 <wagle> Cale is correct, sorry
18:27:11 <Cale> @type ($)
18:27:12 <lambdabot> forall b a. (a -> b) -> a -> b
18:27:17 <wagle> i should slowed down..  i'm juggling
18:27:35 <dons> but all the differences are just syntax anyway
18:27:36 <wagle> shoulda
18:27:42 <dons> underneath these editors all do the same thing
18:27:46 <Cale> lispy: why would you hate ($)?
18:28:01 <TheHunter> Cale, http://hbin.dyndns.org/pastebin/72.html
18:28:02 <lispy> Cale: for me, it makes the code much harder to read
18:28:32 <dons> @seen jyp
18:28:34 <lambdabot> I saw jyp leaving #haskell 2 hours, 8 minutes and 24 seconds ago.
18:28:36 <wagle> oh..  you hate $, not ($)
18:28:47 <TheHunter> lispy, i find everthing which is nested deeper than 2 levels of parenthesis hard to read.
18:28:56 <wagle> i think it tends to get overused
18:29:13 <dons> hmm. that may be true.
18:29:33 <dons> maybe we should have had language support for a $
18:29:42 <lispy> TheHunter: yes, but i think $ compounds the problem by changing the rules in the middle of parens
18:29:48 <Cale> lispy: It helps reduce parens, which is good. It's just function application with really low precedence.
18:30:24 <Cale> TheHunter: are you sure you don't want the return to be back 2 spaces?
18:30:35 <Cale> (i.e. in the do, and not the let?)
18:31:17 <wagle> hmm..  gth2hs is still version 0...
18:31:57 <TheHunter> wagle, (re repeatedly hitting tab). I prefer an indentation style where everything is indented at fixed levels because otherwise the code tends to much too the right and changes in previous lines mess up everything.
18:32:07 <TheHunter> Cale, you're right.
18:32:57 <wagle> TheHunter: i find it wants to go way too far right (or not enough)
18:34:15 <wagle> i want the patterns only slightly indented from the case keyword, not 30 spaces indented
18:35:03 <Cale> What would be nice is an editor which parses Haskell and indents things according to the offside rule dynamically if previous lines are changed.
18:35:28 <wagle> Cale: yesyesyesyesyesyesyesyesyesyesyesyesyesyesyesyes
18:36:03 <lispy> yeah, but emacs's engine would have to be ignored
18:36:21 <lispy> it just uses regexps...
18:36:28 <Cale> yi should eventually do that :)
18:36:30 <wagle> in the olde days we had hybrid structure editors that'd generate emacs editors that'd do just that!  </curmudgeon>
18:37:08 <wagle> its all done with attribute grammars, i tell you
18:37:16 <lispy> i agree
18:37:24 <lispy> attribute grammars would be nice here
18:37:40 <shapr> We gotta hack on Yi, get it movin.
18:37:49 <Cale> Doing syntax colouring with regexps seems silly
18:37:57 * shapr agrees
18:38:13 <wagle> especially when the regexps get it wrong
18:38:26 <lispy> it was done for performance reasons
18:38:33 <lispy> remember, emacs is ancient
18:38:52 <lispy> but, in this day and age, lets use a parser!
18:38:59 <lispy> let's just build ghc right in
18:39:02 <wagle> uhh..  the emacs hybrid structure editors were circa 1985
18:39:15 <lispy> have it tell you about type errors as they happen :)
18:39:32 <lispy> 1985 was a long time ago
18:39:40 <lispy> moore's law and all
18:39:50 <wagle> lispy: i did exactly that (type checking from spj's book)
18:40:15 <dons> shapr, I think Yi is getting going again. there's been 100 commits since yi 0.1.0 came out
18:40:17 <lispy> wagle: cool! how long till we have it in yi :)
18:40:22 <shapr> dons: awesome!
18:40:54 <wagle> i'm need to figure out how to (efficiently) implement attribute grammars in haskell
18:41:01 <shapr> dons: The next step I'm most interested in is the parser/synhl framework. Have you eval'd more thunks on that subject?
18:41:19 <dons> jyp has been helping a lot, for example, i'm about to commit a KillRing.hs patch for the emacs mode from him.
18:41:24 <wagle> i still have this rewriting-in-place habit i'm having trouble with
18:41:28 <lispy> wagle: there is haskell preprocessor that will generate haskell from attribute grammars.  There is a TMR about it
18:41:44 <shapr> Whoa spiffy!
18:42:00 <dons> haven't forced any more thunks on that yet, but we will have to soon. they'll be demanded soon ;)
18:42:01 <wagle> synhl?
18:42:08 <shapr> Wow, lotsa patches in the last few days.
18:42:13 <dons> I want synhl before the haskell workshop anyway
18:42:25 <dons> gives me a good deadline to get  Yi in top form
18:42:30 <wagle> whens the haskell workshop?
18:42:37 <dons> Sep 30
18:42:40 <shapr> As far as I can tell, something like the Semantic Bovinator would be a good approach.
18:42:42 <wagle> where?
18:42:52 <dons> estonia
18:42:58 <wagle> the semantic mountain builder?
18:43:04 <dons> == long flight from .au :}
18:43:07 <Igloo> Are you presenting anything about it, dons?
18:43:14 <dons> yep.
18:43:19 <Igloo> Cool
18:43:31 <shapr> If the parser generator framework is part of Yi, and the users just write a language spec, then it's easy to upgrade the framework and keep it all sane.
18:43:39 <wagle> whats synhl?
18:43:43 <Igloo> Do you have a plan for parsing, synhl and intermediate brokenness?
18:43:45 <shapr> One of the downsides of emacs many modes is that each one does its own thing.
18:44:00 <shapr> wagle: syntax highlighting
18:44:04 <wagle> ah
18:44:07 <wagle> thx
18:44:11 <lispy> Igloo: i'm finally sending in that patch to change ***DARCS*** to ***END OF DESCRIPTION***, but i'm holding off on the other 2 changes
18:44:21 <Igloo> OK, cool
18:44:51 * shapr thinks of various existing Haskell parser generator frameworks
18:44:55 <lispy> shapr: that and it was designed so that you can only have one major mode at a time, it would have almost been better to have seperate "applications" instead of major modes
18:45:04 <shapr> Yeah, true.
18:45:19 <wagle> i have a notion of how to do hybrid structure editors in my head (including work on the structure of comments and literate programming, but i'm still working my way up to that
18:45:53 <shapr> Strafunski has SDF2Haskell, that's one possibility.
18:45:59 <lispy> one way to think of emacs, is that it's a virtual machine.  So it's really it's own OS sitting on custom hardware.
18:46:27 * Enveigler loved teco, but hates emacs !)
18:46:37 <lispy> and if you view it that way, it has a lot in common with old school mac
18:47:21 <wagle> emacs started out as a TUI os
18:47:34 <lispy> Enveigler: did you ever hear about that comparison  of line noise and teco (the language) apparently, there was a lot of overlap :)
18:47:34 <wagle> emacs started out as a windows/TUI os
18:47:53 <lispy> TUI = text user interface?
18:48:00 <wagle> you dont start up emacs, you boot into it, and stay there for days and weeks
18:48:06 <wagle> lispy: yeah..  8)
18:48:12 <shapr> SDF2Haskell might already have integration with the ATerm library, that would give a nice format form parse trees.
18:48:31 <dons> hmm. that's interesting.
18:48:35 <lispy> wagle: so have you seen the tool that generates haskell from attribute grammars?
18:48:41 <lispy> wagle: i get the feeling you'd like it
18:49:17 <Enveigler> Yes! I think all but 10 or so of the 256 8-bit chars had significance, and many had dual purposes when combined, but it was (at the time) so cool compared to anything else available (ED & EDT)
18:49:30 <dons> i also want to look at SimonMs Visual Haskell paper that came out : http://www.cs.uu.nl/~daan/hw2005/program.html
18:49:51 <shapr> dons: This looks nice - http://www.cs.vu.nl/Strafunski/arch.jpeg
18:50:09 <shapr> I haven't used SDF before though.
18:50:45 <wagle> lispy: where is it?
18:50:54 <lispy> wagle: hang on
18:51:06 <lispy> wagle: it was in a TMR article about attribute grammars
18:51:15 <shapr> Also depends on whether SDF handles incremental parsing at all.
18:51:24 <lispy> wagle: http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter
18:52:13 <shapr> Though I disagree with parts of that Attribute Grammars article.
18:52:15 <lispy> so if the ghc RTS can be turned into a microkernel (there is a group doing that) and Yi is in haskell, you could have the modern equivalent of a lispmachine, but this time it could all be done in haskell :)
18:52:17 * wagle 's head explodes
18:52:30 <shapr> lispy: Yup, that's the secret goal.. oops
18:52:37 <lispy> hehe
18:52:42 <shapr> HaskellM
18:52:43 <wagle> ..  letting each fragment head on separate tangents
18:53:16 <lispy> i'm interested in attribute grammars from a language design perspective
18:53:47 <shapr> Yeah, I think AGs as traversal tools is ... well... inferior to monads.
18:53:49 <lispy> i have a hunch, that if your language can be described by a simple attribute grammar, then you'll have a more learnable language
18:53:57 * shapr thought that was sufficiently tactful.
18:54:02 <lispy> heh
18:54:39 <shapr> dons: Doesn't look too scary - http://www.cwi.nl/themes/sen1/sdf2-demo/index.html
18:54:41 <lispy> and actually, i've been trying to use something that isn't as powerful as attribute grammars (you can think of AG as a generalization)
18:55:20 <lispy> writing an OS would be a lot more fun if you didn't have to write drivers
18:55:37 <shapr> So, first you write a driver generator.
18:55:51 <lispy> dealing with weird (read proprietary) hardware is no fun
18:56:04 <shapr> Don't do hat.
18:56:16 <shapr> I look forward to open source cars.
18:56:26 <lispy> lol
18:56:31 <lispy> omg....
18:56:46 <shapr> Emebedded systems in cars have gotten complicated enough that bugs are becoming a real problem.
18:56:48 <lispy> that's not the kind of driver i meant :)
18:56:53 <dons> shapr, hmm. looks  simple enough.
18:56:57 <wagle> oh!  its about to run me over!  lemme reprogram it
18:57:31 <shapr> One of the expensive cars had a problem where the OS would crash occasionally while driving. Volvo? BMW? Something like that.
18:57:39 <shapr> Caused a few wrecks when it happened on the interstate.
18:58:03 <lispy> Igloo: hmm...if i can't pass the test suite locally, i can't submit patches. BUT, the test suite failure I'm seeing is not real.  What should I do?
18:58:18 <wagle> i've seen the computer on the light rail here crash..  several times
18:58:27 <lispy> wagle: where do you live?
18:58:29 <shapr> lispy: Patch the test suite?
18:58:42 <wagle> lispy: portland oregon
18:58:49 <lispy> wagle: ah!
18:58:52 <shapr> wagle: Have you met SyntaxNinja?
18:58:53 <lispy> wagle: i'm from corvallis
18:59:07 <lispy> wagle: currently in San Jose for the summer tho
18:59:16 <shapr> wagle: Know of any Haskell jobs in Portland?
18:59:30 <lispy> wagle: if you're a linux geek (or bsd) you should checkout #orlug
18:59:39 <shapr> I'm tired, time for sleep
18:59:39 <lispy> shapr: there is a company...Galois
18:59:40 * shapr &
19:00:35 <wagle> http://www.haskell.org/hawiki/HaskellUserLocations
19:00:42 <metaperl> I am having a type issue. Could someone help me with this: http://rafb.net/paste/results/dpUzET24.html
19:01:06 <wagle> shapr: not in person (yet), but i suspect i will next month
19:01:17 <wagle> shapr: galois
19:02:46 <wagle> metaperl: Int is a 32 bit value, Integer is a bignum..  not the same at all
19:04:04 <TheHunter> metaperl, the error message doesn't belong to the code you posted, does it? i can't find `ordr' anywhere
19:04:24 <wagle> TheHunter: type BarCode = Int
19:04:33 <wagle> Couldn't match `BarCode' against `Integer'
19:04:36 <wagle> ...
19:04:48 <TheHunter> wagle,     In the second argument of `map', namely `ordr'
19:05:15 <TheHunter> i'm currently guessing he defined ordr = [123,...] and the monomorphism restriction kicked in.
19:06:15 <wagle> ohh..  i figured maybe  map fun ordr = ...
19:06:44 <wagle> in any case, the problem is that Int wont unify with Integer
19:07:17 <wagle> why do people post questions, then disappear?
19:07:21 <wagle> heh
19:08:29 <lispy> because they want to be annoyngi
19:08:31 <lispy> :)
19:08:33 <wagle> http://www.borked.us/irc/piespy/orlug/
19:08:47 <wagle> yer the center of the universe!
19:09:10 <lispy> that must be an old one, largos has been gone for a while :)
19:09:37 <lispy> piespy is a neat idea
19:10:18 <wagle> what you doing for the summer?
19:10:40 <lispy> internship with ibm, i'm working on this thing....hang on a sec, i'll give you the url
19:11:12 <metaperl> TheHunter: ordr is just a list of numbers: [234,67,3214,893]
19:11:21 <lispy> http://www.alphaworks.ibm.com/tech/adieu  and http://instantapps.org/
19:11:33 <lispy> the second url has a flash demo
19:11:40 <metaperl> wagle: how do I convert Integer to Int
19:11:50 <lispy> metaperl: try fromIntegral
19:12:03 <TheHunter> metaperl, probably just giving ordr a type signature will do:
19:12:06 <wagle> ordr = [...] :: [Int]
19:12:09 <lispy> @hoogle Integer -> Int
19:12:10 <lambdabot> Prelude.fromEnum :: Enum a => (a -> Int)
19:12:10 <lambdabot> Prelude.fromInteger :: Num a => (Integer -> a)
19:12:10 <lambdabot> Prelude.floatDigits :: RealFloat a => (a -> Int)
19:12:25 <wagle> or add the line ordr :: [Int]
19:12:37 <dons> @hoogle+
19:12:38 <lambdabot> Prelude.exponent :: RealFloat a => (a -> Int)
19:12:38 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => (a -> b)
19:12:38 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => (a -> b)
19:13:26 <wagle> metaperl: do you want Int (32 bits) or Integer (unbounded precision)?
19:13:53 <wagle> you probably do not want to convert back and forth between Int and Integer
19:13:55 <metaperl> wagle: typing the input list as [BarCode] fixed it, per TheHunter suggestion
19:14:17 <TheHunter> -fno-monomorphism-restriction fixes that kind of thing, too.
19:14:47 <lispy> heh, what about -fDWIM ;)
19:15:31 <wagle> hey!  i'm being oppressed!  http://www.scannedinavian.org/~shae/haskellers.large.png
19:16:43 <wagle> hmm.. conal must be at microsoft
19:16:47 <lispy> shapr: are you finish or swedish?
19:16:58 <lispy> wagle: his CV says he's no where
19:17:09 <lispy> wagle: but i know he was at MS at one point
19:17:34 <wagle> he's north of me, and thats prolly seattle area
19:17:59 <lispy> i'm not on there
19:18:13 <lispy> but i guess i _just_ added myself to the list
19:18:13 <wagle> well, fix it!
19:18:34 <lispy> how?
19:19:02 <lispy> doh!stupid safari, i just nuked all my tabs and it didn't say anything
19:19:21 <wagle> when i poked shapr, he said that i should generate my own image and repoint to it..  i just waited a couple weeks for him to bother to update
19:20:26 <lispy> heh
19:20:30 <lispy> i don't have xearth
19:20:37 <lispy> so there!
19:20:47 <lispy> but, hey why doesn't the server just do it?
19:20:53 <wagle> i got it on my mac..
19:21:17 <lispy> i could installit....
19:22:18 <wagle> 8-p   NOTE: ADIEU works only with Internet Explorer!
19:22:40 <lispy> lame huh....
19:22:50 <lispy> the next version will support firefox
19:22:58 <dons> we need a flat map for haskellers, the southern hemisphere doesn't get much of a look in...
19:23:31 <lispy> yeah, i can't even seeyou
19:25:06 <lispy> geez, it's 19:26 and it's still 90degrees outside
19:25:36 <lispy> which for the international crowd is 32
19:25:37 <wagle> you oregonian you
19:26:27 <lispy> wagle: it's rained once since i came here on June 18th, and when i say rained, i use the term loosely.  I had to stare hard at the ground to be sure it was even wet
19:27:13 <lispy> it's no wonder that all the hills arebrows
19:27:15 <lispy> er brown
19:28:46 <wagle> the instantapps demo doesnt look like a non-programmer can do it
19:30:29 <lispy> dons: we need a "Mercator" view
19:30:36 <lispy> wagle: haha, yes!
19:30:43 <lispy> wagle: that's the part i'm working on....
19:30:45 <dons> wagle, yep.
19:30:57 <wagle> oic
19:31:15 <lispy> wagle: but i'm glad you noticed
19:31:20 <lispy> wagle: was it the "xpath"?
19:31:33 <lispy> or the indexof(blah)+1 stuff?
19:32:00 <wagle> extract ibm / aapl stock wuote
19:32:25 <wagle> (they then correct the wuote -> quote typo..  8)
19:33:11 <lispy> hmm..i don't remember that part :)
19:36:01 <wagle> ah.  well, i'm not running win2k or winxp..
19:36:36 <lispy> yeah :(
19:37:09 <lispy> what i think is funny, is that they guy that did that demo, thinks the xpath he uses is selecting the stockquote from the spot he highlighted.  But he's wrong.
19:37:26 <lispy> it's selecting it from a spot before that on the page.
19:37:30 <lispy> he got lucky....
19:38:07 <wagle> so its robust!
19:38:38 <wagle> *8-D
19:38:42 <wagle> *<8-D
19:38:47 <lispy> yeah, we could really use an automated screen scraper
19:39:29 <lispy> something that lets you pop open a webbrowser and show it what you want, and then learn from that (including figuring out what URL to use, and which parts of the page you care about)
19:40:31 <lispy> it could watch you visit weather.com, punch in a zipcode and highlight the temperature you care about, then build an Adieu sheet that automates it
19:40:42 <lispy> but i think that's beyond the scope of this summer :)
19:41:01 <Korollary> AI assisted webbrowsing would be fine.
19:41:32 <Korollary> "warning: this thread posting is a troll. refrain from replying."
19:41:36 <lispy> Korollary: especially if it could pickout ads and throw them away :)
19:42:14 <wagle> how do you get the stupid macosx finder to show you all the files?!?!
19:42:41 <lispy> the hidden ones?
19:42:43 <lispy> no clue
19:42:49 <lispy> i use a terminal for that
19:43:23 <Korollary> no, the ideal is a distributed application that registers hits on ad sites but the data is all confusing: bought harry Potter, then some Metallica, then some diapers and checked out WW2 history sites. Who is this person?
19:43:49 <wagle> i generally do that, but this time i really do want to use the gui
19:44:18 <wagle> it wont let me see /usr (and thus /usr/local/src/foo/docs/...)
19:44:28 <metaperl> I need some help writing a function to search a list: http://rafb.net/paste/results/iEWTAH19.html
19:45:12 <lispy> wagle: try "open /usr/local/src/foo/docs/"
19:47:22 <lispy> or even "open /usr"
19:47:28 <wagle> hah.  /.hidden
19:47:29 <Korollary> metaperl: how about findMe name [] = ""; findMe name ((b,n,p):xs) = if n == name then b else findMe xs
19:47:55 <metaperl> Korollary: thanks
19:48:32 <Korollary> oops
19:48:37 <Korollary> I didnt check the types
19:48:52 <Korollary> you need to return -1 instead of ""
19:49:00 <Korollary> or a custom data type
19:49:18 <Korollary> like data SearchResult = Int | NotFound
19:49:24 <lispy> wagle: i don't have taht, i have other stuff...but not /.hidden
19:50:50 <wagle> $ grep usr /.hidden
19:50:50 <wagle> usr
19:51:19 * ral1 goes to bed
19:52:30 <lispy> i wonder why i don't have /.hidden
19:52:48 <lispy> i mean, /usr is hidden, so why don't i have a /.hidden
19:52:58 <Korollary> why is any of it hidden
19:53:28 <lispy> Korollary: you'll have to ask Steve Jobs :)
19:53:35 * Korollary drives to Cupertino
19:53:45 * Enveigler wonders if he missed ral1's posted example?
19:54:39 <Korollary> lispy: do you have write access to the aforementioned files in osx ?
19:56:44 <lispy> Korollary: it doesn't exist on my system
19:56:50 <lispy> so no :)
19:57:35 <lispy> i'd try to find it with spotlight but you can't search for files that start with .
19:57:51 <lispy> trying to find it with fin
19:57:53 <lispy> er find
19:58:42 <wagle> haha..  /.hidden musta been a hold-over from 10.2
19:59:00 <lispy> that could be
19:59:04 <wagle> i even rebooted, and it still wont show me /usr
19:59:20 <lispy> well, open /usr will take you right there
19:59:27 <gzl> what is the issue?
19:59:31 <wagle> i want to go there from the gui
19:59:39 <gzl> oh, that's simple
19:59:50 <wagle> ooooook
19:59:58 <gzl> defaults write com.apple.finder AppleShowAllFiles 1
20:00:01 <gzl> then restart the FInder
20:00:14 <wagle> bwahaha
20:00:35 <gzl> was that what you were looking for?
20:00:42 <wagle> quite likely
20:01:01 <gzl> for some of these features, they have settings without a UI
20:01:07 <gzl> so you access the stuff through defaults
20:01:21 <gzl> for example, pinning the Dock to the left or right side
20:01:22 <lispy> what is defaults?
20:01:36 <wagle> lookit all that...  stuff!
20:01:37 <gzl> % whatis defaults
20:01:37 <gzl> defaults(1)              - access the Mac OS X user defaults system
20:01:49 <lispy> or better yet, how do yourestart the finder
20:02:18 <gzl> hold option and click-hold on the Finder in the dock
20:02:23 <gzl> there'll be a Relaunch option
20:02:28 <lispy> ah, yeah, i just used forcequit
20:02:33 <gzl> yeah, force quit does the same thing
20:02:42 <wagle> no gui, eh?
20:02:47 <gzl> wagle: no
20:02:56 <gzl> lispy: you use defaults to set preferences for applications
20:03:09 <gzl> but it's basically useful when they have preferences that don't have a gui
20:03:15 <lispy> hmm...not sure i like tihs
20:03:51 <lispy> seeing things i just didn't want to see
20:04:28 <gzl> there's a reason it's off by default :)
20:05:27 <lispy> gzl: i wish it were more customizable
20:05:57 <lispy> defaults write com.apple.finder AppleShowAllFiles 0.5
20:09:09 <wagle> but, hey, it works now..  now i see too much..
20:09:12 <wagle> wheee
20:09:38 <gzl> lispy: haha
20:10:13 <wagle> gzl: thanks...  how'd you find that?
20:10:27 <gzl> I've been using the OS for a long time and just know
20:10:39 <gzl> but you can do "defaults read com.apple.finder" to look at what they have
20:10:50 <gzl> that's generally how people find them
20:11:04 <wagle> AppleShowAllFiles wasnt even listed
20:11:04 <lispy> is defaults like a commandline version of MS's registry?
20:11:31 <gzl> I think you're mistaken
20:11:31 <gzl> % defaults read com.apple.finder | grep AppleShowAllFiles
20:11:31 <gzl>     AppleShowAllFiles = 0;
20:11:47 <gzl> lispy: it's not a registry, no
20:11:55 <wagle> i grepped for it in the output of defaults read
20:12:02 * gzl scratches head
20:12:03 <gzl> so did I
20:12:11 <wagle> found com.apple.finder
20:12:36 <wagle> well, you've turned it off and on a bunch of times
20:13:05 <wagle> also,. i upgraded from 10.2 to 10.3..  not fresh install
20:13:34 <gzl> lispy: it just edits ~/Library/Preferences/com.apple.finder.plist (or whatever the relevant file is)
20:14:37 <gzl> wagle: this is an old setting, though
20:14:47 <gzl> wagle: this has been around since before 10.0, iirc
20:14:48 <wagle> dunno
20:14:57 <gzl> it's quite old
20:15:05 <wagle> whats /.hidden then?
20:15:19 <gzl> .hidden is a file that describes which files in / to not display
20:15:33 <wagle> when?
20:15:41 <gzl> when what?
20:15:49 <wagle> when does it not display them?
20:16:07 <gzl> in the Finder, it will never display the files named there
20:16:16 <wagle> it did
20:16:35 <wagle> when AppleShowAllFiles was 1
20:16:43 <gzl> it did what?
20:16:48 <gzl> you're being a little vague :)
20:17:19 <wagle> it displayed the files in /.hidden when AppleShowAllFiles was 1
20:17:26 <gzl> yes, that will override .hidden
20:17:33 <gzl> and will show everything
20:17:42 <gzl> (as it says)
20:17:53 <wagle> it did not display them when AppleShowAllFiles was not set
20:18:10 <gzl> yes, that's the expected behavior
20:18:23 <wagle> i removed /usr from /.hidden when AppleShowAllFiles was not set, and it did not show /usr
20:18:33 <gzl> hmm
20:18:48 <wagle> i rebooted, and still no /usr
20:18:59 <lispy> i suspect .hidden is no longer used, i don't have it for example
20:19:09 <gzl> that may well be
20:19:32 <gzl> however, I have certain custom directories I've added to it
20:19:34 <gzl> that do not display
20:19:45 <lispy> i don't think /.hidden is in the spirit of unix, but ~/.hidden would be
20:20:12 <gzl> they should probably have a /etc/hidden and ~/.hidden
20:20:21 <gzl> that overrides the global one
20:23:58 <dons> @code
20:23:59 <lambdabot> Base.hs: instance IArray UArray Int where
20:28:00 <gzl> ohh, I see what they did
20:29:22 <gzl> lispy: it's deprecated in Tiger because Tiger stores the attribute in the file itself
20:29:46 <gzl> via extended attributes
20:32:10 <lispy> gzl: how do i edit those?
20:32:58 <gzl> hmm, or did they
20:33:07 <gzl> hold on, now I'm not so sure.
20:33:20 <gzl> I'm sure that it's deprecated and that it's being stored in the file itself
20:33:26 <gzl> I'm not sure whether it's stored in the extended attributes
20:37:58 <wagle> ld: Undefined symbols:
20:37:59 <wagle> _GraphicsziUIziGtkziAbstractziContainer_containerBorderWidth_closure
20:38:01 <wagle> ...
20:38:21 <wagle> trying to compile a gtk2hs helloworld
20:38:40 <wagle> with ghc helloworld.hs
20:38:47 <wagle> what am i doing wrong?
20:38:56 <lispy> wagle: that looks like a java function name
20:39:22 <wagle> ghc prolly mangles too
20:39:39 <wagle> ___stginit_GraphicsziUIziGtk_
20:40:02 <lispy> heh, i never thought about it that way, but i guess the java API just contains pre-mangled names
20:40:33 <dons> zi == "."
20:40:38 <gzl> lispy: ok, figured it out. do /Developer/Tools/SetFile -a V <filename>
20:40:42 <wagle> linker would complain about the mangled versions of the names
20:40:56 <gzl> lispy: it is stored in extended attributes
20:41:19 <gzl> that should give you your customizability
20:42:00 <gzl> it at least works on a test file I tried
20:42:14 <lispy> gzl: is it a toggle?
20:42:28 <gzl> yeah, lowercase is off, uppercase is on
20:42:39 <gzl> but try it out on test files first
20:43:18 <gzl> hmm, making files visible again isn't working for me
20:45:53 <wagle> haha..  i b0rked my desktop showing all the hidden files
20:46:11 <lispy> wagle: good job...what do you mean b0rked?
20:46:15 <lispy> what happened?
20:46:38 <wagle> leet speak for broken
20:46:49 <wagle> 1337, that is
20:47:23 <lispy> well, i know borked
20:47:33 <lispy> i want to know what happned
20:48:23 <wagle> i now had more objects on my desktop than places to put them..  and now its showing Servers and Network..  etc
20:49:10 <wagle> hidden is prolly more broken now than they want to release..  hence the difficulty
20:49:30 <wagle> gzl: you are using 10.4?
20:49:53 <lispy> i'm using 10.3
20:49:53 <gzl> yes
20:49:54 <lispy> er .4
20:50:00 <lispy> tigger
20:50:04 <gzl> no, /.hidden is deprecated
20:50:13 <gzl> doesn't do anything anymore
20:50:23 <wagle> my /.hidden had a 2003 timestamp
20:50:38 <lispy> gzl: ever get those files to show up again using setfile?
20:50:53 <gzl> not yet
20:50:57 <gzl> still looking around
20:51:06 * lispy avoids setfile for a bit
20:52:10 <gzl> oh, there it is
20:52:17 <gzl> I guess I didn't cycle the Finder properly or something
20:52:51 <gzl> ok, here's the deal. SetFile -a V foo will make foo invisible and does not require cycling Finder, -a v foo will make foo visible but does require a Finder restart
20:53:32 <gzl> toy around with some test files to make yourself confident that it works
20:53:44 <gzl> but people are using this without complaints, it seems like
20:54:28 <gzl> ah, yeah, there's something on macosxhints.com about it
20:54:31 <wagle> doesnt work if showallfiles is set, i guess
20:54:42 <gzl> yeah, that probably overrides that stuff
20:55:17 <gzl> lispy: if you want to know about extended attributes on OS X, here's the place to start: http://arstechnica.com/reviews/os/macosx-10.4.ars/7
20:55:51 <gzl> they're still sort of in "testing mode," as the document will explain
20:56:32 <gzl> ah, this is good
20:56:34 <wagle> well, killall finder is much nicer than restart
20:56:41 <gzl> yeah
20:56:56 <gzl> now I can finally make this stupid shit in my Documents folder disappear
20:57:43 <wagle> wooo!
20:57:59 <wagle> i can see /usr now!
20:58:03 <gzl> :)
20:58:11 * gzl blows away ~/Documents/Microsoft User Data
20:58:13 <wagle> without all the other crud..
20:58:33 <gzl> yeah, I bet extended attributes will start getting really cool in 10.5.
20:58:40 <wagle> cool.. thanks..  coffee shop is closing now..  c'yall
20:58:44 <gzl> later, np
21:01:10 <wagle> that was all on macosxhints?
21:02:10 <gzl> it actually was, though I sort of figured it out "manually" because that page didn't come up when I was googling around elsewhere.
21:02:18 <gzl> I found it through the Apple developer documentation
21:02:21 <wagle> anyone know whats wrong with my gtk2hs libs?
21:02:56 <gzl> in general, macosxhints is extremely useful
21:04:05 <gzl> oh, also, you can use /Developer/Tools/GetFileInfo to actually list the attributes for a given file (which SetFile, somewhat stupidly, doesn't do)
21:13:17 <wagle> ooo..  ghc --make
21:14:18 <wagle> what does --make add?
21:15:49 <gzl> how else do you compile stuff?
21:16:15 <wagle> i've just used ghc foo.hs
21:16:49 <gzl> oh, this follows dependencies and links them together
21:16:58 <gzl> so you could just do ghc --make Main.hs
21:17:09 <gzl> and it chases the imports and stuff
21:18:06 <gzl> I don't think it's needed unless you have a program with multiple modules
21:19:59 <wagle> hmm..  now i know something more (generally i just use ghci/hugs)
21:20:03 <wagle> thanks
21:20:12 * wagle really gets kicked out now
21:23:08 <gzl> yeah I frequently use ghci too
21:23:12 <gzl> I don't like hugs much though
21:57:25 <lispy> lets all log off at the same time
21:57:28 <lispy> shall we
22:59:54 <foxy> @index when
22:59:55 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
22:59:55 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
22:59:55 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
23:15:59 <lispy> @hoogle when
23:16:01 <lambdabot> Monad.when :: Monad a => (Bool -> (a ()) -> (a ()))
