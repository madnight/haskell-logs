00:08:47 <Tue23324> meuning
00:13:55 <musasabi> I
00:13:59 <musasabi> morning
00:20:16 * Tue23324 pokes earthy
00:20:46 <dblhelix> Tue23324: earthy is on his way to France
00:20:55 <Tue23324> ow really?
00:21:11 <dblhelix> at least, I thought he was supposed to leave today
00:21:18 <Tue23324> phd students dont get to have vacation
00:21:21 <Tue23324> i thought
00:21:35 <Tue23324> 3/4 years of non-stop hard ploughing
00:21:39 * dblhelix begs to differ ;)
00:21:56 <dblhelix> although you're quite right about the ploughing
00:22:36 <Tue23324> i mean, it should be 3/4 years of spartican life for the good of science
00:22:36 <Tue23324> lol
00:23:22 <dblhelix> from where I'm standing, science is better served if our batteries get reloaded from time to time
00:23:33 <Tue23324> :D
00:23:42 <Tue23324> shouldnt have bought such a rip-off ibook :P
00:24:07 <dblhelix> why not?
00:24:22 * dblhelix loves his iBook (glad it's a G4 though ;))
00:24:37 <Tue23324> i can never get used to that mac system of having one toolbar for all programs
00:24:40 <Tue23324> to dynamic for me
00:24:42 <Tue23324> too
00:25:22 <dblhelix> I was amazed how soon it got used to working on a mac
00:25:28 <flodin> i'm going to do a bignum library as my first haskell learning project
00:25:46 <flodin> or rather, I am doing one, i got addition working the other day
00:25:51 <dblhelix> flodin: why don't you just do hello world? ;)
00:25:56 <dblhelix> or parser combinators
00:25:58 <flodin> well i did hello world hehe
00:26:06 <flodin> that doesn't count as a project
00:26:10 <Tue23324> im doing a regex generating library hehehe
00:26:14 <Tue23324> because making a string sucks
00:26:42 <Tue23324> although its actually only for my documentation
00:26:43 <dblhelix> I'm going for some coffee :)
00:26:48 <Tue23324> (y)
00:26:49 <flodin> parser combinators i will do later probably. But that's a bigger, much more serious project
00:27:10 <dblhelix> flodin: you think so? mmm ...
00:27:12 <flodin> i've done a fairly complicated parser in C++ that I'm planning to rewrite in haskell
00:27:16 <Tue23324> hehehe
00:27:23 <Tue23324> oww i'll just do that later
00:27:41 <Tue23324> you mean you are going to make a parser or a parser combinator library flodin ?
00:27:55 <flodin> a parser
00:27:59 <Tue23324> ow ok
00:28:04 <Tue23324> :)
00:28:04 <dblhelix> why would you rewrite stuff that's complicated in C++ in Haskell? why not just take the Haskell approach and find out it does not have to be that complicated?
00:28:15 <Tue23324> parser combinator library would be a big second project indeed ;)
00:28:24 <Tue23324> yeah, no porting
00:28:47 <Tue23324> that only generates crap haskell and you saying.."see how crap haskell is"
00:28:54 * dblhelix really gets some coffee now
00:28:58 <Tue23324> :)
00:29:24 <flodin> uh... well. Call it what you like... I need to achieve the same functionality by writing it in haskell. The point of rewriting it in haskell of course is to make it less complicated
00:29:51 <jyp> No topic ?
00:29:56 <flodin> i realized i spend a lot of my time just writing functions to emulate what haskell already does
00:30:39 <flodin> and this is not the kind of project that's mature enough to need low-level optimizations. I need abstraction and ability to quickly restructure the program
00:31:31 <flodin> but, anyway. I've got some way to go before that :)
00:33:08 <flodin> the first concern that's begun to surface is hiding implementation details. I've got a lot of functions along the lines of "add_mantissa_with_carry_helper" and so on. What's the appropriate way of avoiding pollution of the user's namespace? Can I (and should I) prevent those functions from being called at all?
00:33:40 <flodin> (called by the user, that is)
00:34:27 <jyp> You should & can
00:34:53 <jyp> module Name ( exported list by comma ) where ...
00:37:31 <jyp> dons: do you read me ?
00:37:45 <jyp> :)
00:37:49 <flodin> ahh alright. And what of constructors? I'm currently representing my number as an infinite list of digits and an exponent, i.e. I have data BigNum = BigNum [Int] Int. The problem is that not all values are legal, but I can't prevent the user from constructing illegal values. What I'd really like is some kind of initial transformation, so the constructor takes a Num and converts it to the internal representation
00:38:35 <dblhelix> flodin: that typically calls for abstract data types
00:38:47 <flodin> "BigNum 1.5" would generate BigNum [1, 5] 1
00:39:01 <dblhelix> hide your data constructors behind a module boundary and provide smart constructors instead
00:39:15 <jyp> export only the functions that build valid values
00:39:27 <dblhelix> i.e. smart constructors :)
00:39:29 <flodin> ok
00:39:36 <jyp> constructors are hidden by default in the scheme I outlined above
00:40:04 <jyp> dblhelix: yah :)
00:41:18 <dons> jyp, yep. but battery will die in 30 seconds :)
00:41:27 <jyp> farewell then
00:41:34 <jyp> I'll answer your mail
00:42:08 <dons> ok. i agree with the plan to switch the command line over to a minibuffer -- or is it a plan to have a minibuffer as well as a (read only) command line?
00:42:21 <jyp> I'm unsure
00:42:25 <dons> having just a mini buffer would be nice
00:42:32 <jyp> maybe vi needs a command line
00:42:45 <dons> well, vi and friends use the existing cmdline field in the Editor
00:42:50 <jyp> And I think emacs too... the overlay I mentioned
00:42:59 <dons> which, as you say, is a hack -- it reproduces editor code
00:43:09 <dons> yep. so where do msgE write to?
00:43:33 <jyp> over the minibuffer; when it's not active
00:43:49 <dons> right. ok. that sounds reasonable
00:43:49 <jyp> or maybe even when it is, for a short time
00:43:56 <jyp> I know it's annoying...
00:44:08 <jyp> this doesn't need to be done exaclty this way
00:44:18 <dons> yeah, but any editing should really be done in a real buffer, i agree
00:44:25 <dons> so our hand is forced on this matter
00:44:30 <jyp> Agreed then :)
00:44:48 <dons> i implemented some more emacs primitives for you -- check out the bindings in Mg.hs
00:45:09 <jyp> thanks :)
00:45:12 <dons> currently I'm cleaning up the handling of windows versus buffers, for listBuffersE, for example
00:46:09 <jyp> good
00:46:20 <dons> anyway, Battery life estimate: 1 minutes, so maybe I will leave now :)
00:46:29 * jyp waves
00:46:33 <Tue23324> any recommendations for a regex library in haskell (since Text.Regex is only posix)
00:47:49 <jyp> 'only' posix ?
00:48:10 <Tue23324> no non-capturing groups sucks
00:49:00 <Tue23324> it is non existent in the world of posix regex afaik
00:49:46 <jyp> maybe you'll like http://www.cs.chalmers.se/~d00nibro/harp/examples.html
00:50:10 <jyp> that's not really regeces, but neat nonetheless
00:51:20 <Tue23324> i will have a look
00:51:21 <Tue23324> ty
00:52:03 <jyp> your're welcome
00:52:38 <jyp> On a different subject, anyone knows why topic's blank & logs are empty ?
00:53:02 * dblhelix has no idea
00:54:12 --- topic: set to 'Someone please fix the logs & topic' by jyp
01:01:34 --- topic: set to 'Someone please fix the logs & topic -> ok' by Tue23324
01:01:37 <Tue23324> :D
01:01:47 <Tue23324> that shouldnt be possible right?
01:03:33 <jyp> Why, the computers have a life of their own now ? ;)
01:04:44 <Tue23324> hsc2hs should already be part of ghc no? cause my install is broken i think
01:04:52 <jyp> People for ethical treatment of machines has struck again :p
01:05:07 <jyp> yup
01:07:22 <Tue23324> hmm
01:07:39 <Tue23324> i installed the ghc64 and ghc64-prof package under fedora, but no hsc2hs
01:19:44 <Tue23324> well, it sure as hell aint in the ghc64 package from fedorahaskell repos
01:43:43 <aleator> Tue23324: is hsc2hs same as c2hs? That is on fedorahaskell.
01:44:22 <Tue23324> i did another install of package ghc instead of ghc64 and it worked :S
01:48:08 <xerox> Hiya.
01:48:33 <shapr> @yow !
01:48:35 <lambdabot> Couldn't find fortune file
01:50:26 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFour","We put the Funk in Funktion"]' by shapr
01:55:23 <joelk> shapr, I remember once seeing here that someone was working on an article about common function composition patterns for TMR. Is that still in the works for the next issue?
01:57:11 <shapr> joelk: I don't think so. But you could write it :-)
01:57:45 <shapr> Do you remember who was writing the article?
01:59:25 <shapr> It would be a cool article, I wonder who suggested it.
02:02:27 <joelk> hehe. I don't remember... I ask because someone else was trying to figure out how to do something that came down to (f .) . g, so I thought it would've been great if I could have pointed them to that article. Of course I can't remember who *that* was either.
02:03:08 <joelk> I thought it would be a cool article too. I, unfortunately, am not yet qualified.
02:06:38 <bourbaki> moin
02:08:20 <williamvergara> hi
02:08:29 <williamvergara> can someone explain me what is
02:08:41 <williamvergara> foldl
02:08:54 <williamvergara> and how can i use it?
02:10:21 <bourbaki> i cant sry
02:16:44 <Speck> do you know what foldr is?
02:17:06 <Speck> @ williamvergara
02:17:07 <lambdabot> Maybe you meant: all-dicts arr babel botsnack code define definitions
02:17:07 <lambdabot> del-definition devils dice dict dict-help docs dummy dynamic-load
02:17:07 <lambdabot> dynamic-reload dynamic-unload easton echo elements elite eurohaskell
02:17:07 <lambdabot> eval fact fact-cons fact-delete fact-set fact-snoc fact-update
02:17:07 <lambdabot> foldoc fortune gazetteer get-definition ghc google help hitchcock
02:17:09 <lambdabot> hoogle hoogle+ index jargon join karma karma+ karma- kind lambda
02:17:11 <lambdabot> learn leave libsrc listchans listcommands listmodules lojban moo
02:17:13 <lambdabot> [6 @more lines]
02:17:14 <Speck> oh darn....
02:19:36 <Speck> @hoogle foldl
02:19:37 <lambdabot> Prelude.foldl :: ((a -> b -> a) -> a -> [b] -> a)
02:19:37 <lambdabot> Prelude.foldl1 :: ((a -> a -> a) -> [a] -> a)
02:22:31 <williamvergara> sorry guys i was reading in a boot about it ( the craft of functional programming)
02:22:35 <williamvergara> in think i get it
02:23:50 <Speck> it's an abstraction of a common pattern of structured recursion
02:24:08 <Speck> basically, if you're recursing in this very common way, it's better to write it as a fold in haskell
02:27:24 <Speck> you might be interested in unfolds also
02:27:53 <williamvergara> thanx, now i think i have it almost clear
02:29:50 <Speck> if you're interested in the theory, a google search for catamorphism might bring up more math-related results
02:31:15 <dblhelix> in addition I can recommend Lex Augustijn's paper on sorting morphisms
02:32:07 <ulfdoz> re
02:33:24 <williamvergara> thanx a lot guys
02:39:40 <Speck> dblhelix, oh, a new paper. It appears to be more readable than the bananas paper
02:40:12 <dblhelix> well, new ... it has been around for quite some time, I guess
02:40:53 <Speck> I meant new to me
02:40:56 <dblhelix> it was presented at AFP 1999
02:41:01 <dblhelix> Speck: ah, okay
02:41:02 <Speck> it uses gopher for syntax. it has to be old :-P
02:41:14 <dblhelix> as said, I can recommend it
02:41:22 <Tue23324> k im losing it
02:49:56 <Tue23324> did ANYONE ever used Text.Regex and know if there exist such a thing as non-capturing parenthesis in this lib?
02:50:14 <Speck> would an optimizing haskell compiler be able to manipulate a list in-place more easily if folds are used?
02:50:20 <Speck> (and do they?)
02:50:39 <Speck> sorry tue; never used it
02:51:30 <Tue23324> this is frustrating the #@$ out of me
02:54:02 <dons> @eval let (#@$) = map in let ($@#) = Char.toUpper in (#@$)($@#)"yow!"
02:54:04 <lambdabot> "YOW!"
02:54:44 * dons decides to find a fortune file
02:57:25 * xerox pokes dons
02:58:14 * dons pokes xerox
02:58:22 <dons> how's code xerox-google-man?
02:58:44 <xerox> Rather fun :-)  People is also great.
02:58:54 <dons> cool.
02:59:08 <dons> see we've made some Yi progress too? emacs modes flying along
02:59:11 <xerox> But it is indeed difficult to code on vacation :-)
02:59:16 <dons> ah true.
02:59:28 * xerox bounces happily
02:59:45 <xerox> I'll darcs pull while at home, bandwidth costs too much here :(
02:59:54 <dons> hehe
03:00:03 <xerox> Did you see my blog, I had some issues with the telephone company too :(
03:00:18 <dons> oh, I didn't know you had a blog!
03:01:06 <xerox> http://haskell.galois.com/~paolo/  Setted up for the occasion.
03:01:18 <xerox> Sat? even
03:01:44 <dons> Set up for ..
03:02:29 * dblhelix subscribes
03:03:03 <xerox> This morning there is something wrong with me, I had to send a mail 5 times before specifying the correct To: address...
03:03:28 <Tue23324> hehe
03:03:53 <Tue23324> in that case, there's something wrong with me too. I didnt succeed in getting non-capturing grouping working this complete morning
03:17:18 <dons> @yow
03:17:19 <lambdabot> HELLO, everybody, I'm a HUMAN!!
03:17:31 <ibid> no youä're not, you're a bot
03:18:31 <jyp> @yaow !
03:18:32 <lambdabot> Tex SEX!  The HOME of WHEELS!  The dripping of COFFEE!!  Take me
03:18:32 <lambdabot> to
03:18:32 <lambdabot> Minnesota but don't EMBARRASS me!!
03:18:45 <lambdabot> ibid, how do you know?
03:19:21 * jyp laughs
03:20:18 <ibid> lambdabot: it says so on your nick :)
03:21:36 <lambdabot> oh, oops! my NICK is showing
03:23:19 <ibid> :)
03:23:33 <jyp> Anyone knows why http://meme.b9.com/cview.html?channel=haskell&date=today is empty ?
03:23:44 <xerox> sssssh <grin>
03:23:50 * jyp insists
03:23:55 <ibid> nobody's talked today? ;)
03:24:37 <jyp> For some reason it's hard to believe
03:24:49 <ibid> i wonder why
03:38:29 <dcoutts> xerox, how's it going?
03:39:08 <xerox> dcoutts: well so far, the hscairo code is not so underadable as I tough ;)
03:39:17 <dcoutts> :-)
03:39:27 <dcoutts> all those monads?
03:39:33 <xerox> Some monad mysteries .
03:39:40 <xerox> Yeah, you got the point :)
03:40:13 <dcoutts> well, feel free to bug me if you think you're getting stuck
03:40:37 <xerox> I'll do, promise :)
03:41:34 <xerox> Gotta run now, *hungry*.
03:41:40 <dcoutts> bye
03:42:17 <musasabi> Wrapping gnutls was suprisingly easy, now to make the API cleaner...
03:42:22 <dcoutts> @seen mwc
03:42:23 <lambdabot> I saw mwc leaving #haskell 7 hours, 35 minutes and 54 seconds ago,
03:42:23 <lambdabot> and I have missed 2 minutes and 49 seconds since then.
03:48:24 <musasabi> dcoutts: Would you be willing to BSD license System.Glib.Attributes? I am thinking of harmonizing my code to that as more people are familiar with those than the hs-fltk properties.
03:48:56 <dcoutts> musasabi, that would be excelent, we're trying to harmnise with hscairo's attributes at the moment too
03:49:34 <dcoutts> I think we can build an API that serves everyone
03:50:02 <dcoutts> which would be, not quite System.Glib.Attributes, but using more classes
03:50:11 <dcoutts> still the same user facing API however
03:50:40 <shapr> @yow !
03:50:41 <lambdabot> I'm having a MID-WEEK CRISIS!
03:50:46 <shapr> dons: yay!
03:51:15 <shapr> @fortune
03:51:16 <lambdabot> There was a young man of Kildare
03:51:16 <lambdabot> Who was fucking a girl on the stair.
03:51:16 <lambdabot> 	The bannister broke,
03:51:16 <lambdabot> 	But he doubled his stroke
03:51:16 <lambdabot> And finished her off in mid-air.
03:51:24 <dcoutts> musasabi, for hscairo we need monads other than IO, and in Gtk2Hs we are going to need attribute types that hold more information than just getter/setter so classes would help there
03:51:26 <shapr> Hm, that's interesting.
03:52:01 <dcoutts> shapr, where do these limeriks come from!?
03:52:04 <musasabi> dcoutts: sounds interesting - having a more general interface is going to be nice...
03:53:02 <dcoutts> musasabi, would you have need of something more general?
03:53:05 <shapr> dcoutts: The fortune file I assume.
03:53:06 <shapr> @fortune
03:53:07 <lambdabot> Hackathon Moose (or other Ex-Magnificent-Forest-Creature) Barbecue
03:53:07 <lambdabot>  
03:53:07 <lambdabot> 30 cups oil
03:53:07 <lambdabot> 15 cups Soy sauce
03:53:07 <lambdabot> 5 cups Worcestershire Sauce
03:53:09 <lambdabot> 40 tsp dry mustard
03:53:11 <lambdabot> 20 tsp black pepper
03:53:13 <lambdabot> [23 @more lines]
03:53:22 <shapr> Hm, that's interesting also.
03:53:25 <dcoutts> shapr, oh right, of course
03:53:41 <shapr> I wonder where dons found this fortune file? It definitely includes nifty stuff.
03:53:44 <shapr> @fortune
03:53:45 <lambdabot> Fbbare be yngre, trarenyf jvyy bja lbh.
03:53:49 <shapr> um...
03:54:39 <musasabi> dcoutts: maybe something like an attribute whose parameter type depends on the current type, but I think that can be done with the current system too. (e.g. foo :: Foo a b => ReadWriteAttr a b b)
03:55:20 <dcoutts> interesting
03:55:22 <reffie> good morning!
03:55:42 <jyp> ... east coast!
03:55:45 <reffie> or afternoon
03:56:13 <dcoutts> reffie, yes, still morning (3 min to midday)
03:56:21 <shapr> @plugs map (Data.Char.chr .(13+) .Data.Char.ord) "Fbbare be yngre, trarenyf jvyy bja lbh."
03:56:23 <lambdabot> "Soon\DELr-or-\134{t\DELr9-\129\DELn\DELr{\134s-w\131\134\134-own-
03:56:23 <lambdabot> you;"
03:56:28 <shapr> hmm
03:56:30 <reffie> 3 mins to 1pm here, dcoutts :P
03:56:49 <dcoutts> reffie, good afternoon!
03:56:57 <jyp> Haskell's a euro-thing, huh ?
03:57:10 <reffie> my sleep schedule is a bit off
03:57:19 <dcoutts> jyp, except for all the Australians
03:57:22 <shapr> jyp: Not totally - http://www.haskell.org/hawiki/HaskellUserLocations
03:57:49 <dcoutts> musasabi, I'll go see about hacking something up, I'll email it
03:57:57 <dcoutts> musasabi, you can see what you think
03:58:00 <jyp> shapr: that's what I was looking for :)
03:58:13 <shapr> Oh, I left all the aussies off of the latest HaskellUserLocations pix, oops.
03:58:28 <musasabi> dcoutts: thanks.
04:13:30 <dons> shapr, yeah. no antipodes on your map!
04:16:13 <timbod> Hi shapr - was issue 4 of tmr announced? I didn't know of it until I read #haskell's current topic.
04:26:34 * jyp selfishly addd self on map
04:30:27 <Tue23324> @hoogle String -> Maybe Int
04:30:29 <lambdabot> Prelude.fail :: Monad a => (String -> (a b))
04:30:29 <lambdabot> Prelude.error :: (String -> a)
04:30:29 <lambdabot> List.elemIndex :: Eq => (a -> [a] -> (Maybe Int))
04:30:46 <Tue23324> @hoogle String -> (Maybe Int)
04:30:47 <lambdabot> Prelude.fail :: Monad a => (String -> (a b))
04:30:47 <lambdabot> Prelude.error :: (String -> a)
04:30:47 <lambdabot> List.elemIndex :: Eq => (a -> [a] -> (Maybe Int))
04:33:10 <dons> @eval map (\c -> chr $ if ord c <= ord 'm' then ord c + 13 else ord c - 13) "Fbbare be yngre, trarenyf jvyy bja lbh"
04:33:12 <lambdabot> "Sooner-or-later9-generals-will-own-you"
04:37:11 <dcoutts> musasabi, I'm trying to figure out the correct functional dependencies... maybe you can help
04:37:27 <dcoutts> I've currently got:
04:37:29 <dcoutts> class ReadableAttribute a m o d | a -> m, a -> d where
04:37:29 <dcoutts>   getter :: a -> o -> m d
04:37:46 <dcoutts> but we need something more involving the opbject type 'o'
04:38:21 <dcoutts> so the current rules say that the attribute type determines the monad and the data
04:38:37 <dcoutts> perhaps we just need (a -> o) too?
04:38:44 <dcoutts> let me try...
04:38:46 <dons> oh, that's kinda funny: http://blogs.sun.com/roller/page/ThinGuy?entry=the_war_on_terror_as
04:39:23 <dcoutts> musasabi, yep, that works, it makes sense too I guess
04:39:32 <jyp> dons: while I'm at it, capitalise word doesn't seem to behave well
04:39:42 <dons> yeah, spotted that. will fix.
04:39:47 <dons> (went in untested :}
04:39:56 <jyp> no problem
04:40:02 <jyp> just to let you know
04:40:04 <dcoutts> musasabi, because a typeical example of such an attribute type is: data GeneralAttr m o a b = ...
04:40:33 <dcoutts> and so that contains the 'o' the 'm' and the 'd' (well, the 'a' & 'b' whihc are really just 'd')
04:41:02 <dcoutts> so if you know the whole attribute type, it determines all the others
05:09:40 <Tue23324> how can i link a library to my haskell app with ghc
05:09:50 <Tue23324> -llibpcre is not working
05:10:32 <Lemmih> Try -lpcre
05:10:50 <Tue23324> ah nice
05:10:57 <Tue23324> how can i know which name i should use btw?
05:11:03 <Tue23324> where can i lookup this info
05:11:54 <dons> custom is not to have a 'lib' prefix
05:12:48 <tomdavie> yeh, -lxxx indicates search the library directories for libxxx.a or libxxx.dylib
05:15:11 <Lemmih> Jaffa Kree!
05:16:15 * tomdavie eats jaffacake
05:16:34 <JaffaCake> yo #haskell
05:16:47 <Tue23324> ah ok, so basically it does a search in whatever is my lib dir with libxxx.a
05:16:49 <Tue23324> check
05:19:17 <Philippa> tomdavie: I'm not sure I wanted to know that ;-)
05:19:22 <Philippa> afternoon
05:19:56 <jyp> nasty :p
05:20:03 <dblhelix> ouch
05:20:53 <tomdavie> philippa: lol
05:26:45 <tomdavie> anyone know where to get good hard standing tent pegs in britain?
05:27:18 <musasabi> dcoutts: don't all the properties in a given set call need to be in the same fixed monad?
05:27:26 <dcoutts> yes
05:27:55 <dcoutts> musasabi, that's enforced by:
05:27:57 <dcoutts> -- | A set or update operation on an attribute.
05:27:57 <dcoutts> data Monad m => AttrOp m o = ...
05:28:09 <musasabi> dcoutts: also I want to use the same attribute with multiple types of objects if possible.
05:28:22 <dcoutts> the monad is a parameter to the "AttrOp"eration
05:28:46 <dcoutts> you can use multiple attributes in one set call, but only one object
05:29:10 <dcoutts> but your attribute type can be parameterised by the object and value types
05:29:16 <dcoutts> (and indeed the monad)
05:29:36 <musasabi> good, that sounds generic enough for my needs.
05:34:58 <dcoutts> I'll send it shortly, I'm just checking that ordanary IO attributes work ok with the interface
05:35:07 <dcoutts> ie for gtk2hs
05:45:06 <Cale> dcoutts: do you know anything about hscairo? It doesn't seem to build for me - first there were some easy API changes I could fix (renamed constants), and then I ran into actual type errors, there seems to be some type constructors which aren't defined anywhere.
05:46:05 <dcoutts> Cale, xerox is working on it for his Google Summer of Code project, see: http://haskell.org/gtk2hs/archives/2005/07/10/gtk2hs-cairo-project/
05:46:40 <dcoutts> Cale, I'm not quite sure when we'll see the first buildable results, you'll have to ask xerox
05:46:44 <Cale> ah, okay :)
05:47:01 <dcoutts> he's got a blog you can follow; http://haskell.org/gtk2hs/archives/category/cairo/
05:47:12 <dcoutts> or RSS feed:  http://haskell.org/gtk2hs/archives/category/cairo/feed/
05:52:06 <xerox> He's even here now ;-)
05:52:13 <dcoutts> indeed :-)
05:52:20 <Cale> ah, xerox, how's that coming along?
05:52:53 <xerox> I'm slowly making my way through hscairo code, it's too hot today :)
06:42:10 <Raziel> er
06:42:21 <Lemmih> Indeed.
08:01:05 * CosmicRay ITP's hsffig
08:01:33 <Lemmih> ITP?
08:07:32 <CosmicRay> Lemmih: Intent To Package, for Debian
08:07:44 <CosmicRay> it means I will be uploading the package to Debian
08:07:47 <vegai> why just Debian? =)
08:08:37 <CosmicRay> because I'm a Debian developer and not a developer for any other OS
08:08:45 <CosmicRay> (hsffig is not something I wrote)
08:08:49 <vegai> oh, oh.
08:12:47 <astrolabe> Does anyone have any suggestions about how I could learn to write Haskell code that is space/time efficient?
08:13:46 <tromp> it's something of a black art
08:14:31 <dcoutts> astrolabe, you could write an excelent new ghc heap analysis program :-)
08:14:37 <astrolabe> Well, it seems black from here.  Black against a black background.
08:15:03 <astrolabe> dcoutts:  I'm only a beginner.
08:15:25 <tromp> i made some program as efficient as i could. and it still was 50 times slower than java
08:15:39 <tromp> and no-one seemed to know how to speed it up more
08:15:54 <astrolabe> tromp:  That was some game code wasn't it?  I lost my link to it.
08:16:00 <Igloo> Practise is the best way. Looking at core and strictness annotations, profiling output etc help
08:16:06 <tromp> yeah, fhourstones connect-4 solver
08:16:21 <Igloo> tromp: YM no-one was interested enough to look at it properly  :-P
08:16:55 <tromp> right Igloo :-)
08:17:03 <goron> I got Qi running :-)
08:17:43 <tromp> someone admitted that doing bit operations on 64 bit ints is simply not optimized in ghc
08:17:52 <astrolabe> Igloo: I can't find 'core annotations' in the report.  Do you have a link?
08:18:06 <Igloo> Oh, that was mentioned in the performance todo list, I think
08:18:09 <tromp> that part alone was over 20 times slower
08:18:24 <Igloo> astrolabe: I think it's in the GHC users guide
08:18:31 <astrolabe> thanks
08:18:32 <Igloo> Probably the bit about faster/quicker/...
08:18:47 <dcoutts> astrolabe, sorry, I was only joking really. But we do need better tools, it would mean figuring out the space behaviour of you program would be less of a black art.
08:18:55 <astrolabe> Ah that sounds a good place to look.
08:24:53 * kzm seems to remember a library to color text (ASCII escapes), but has forgotten where.  Any pointers?
08:25:13 <dcoutts> kzm, hscolour
08:25:23 <dcoutts> or was it hscolor
08:26:00 <astrolabe> tromp: GHC are asking people to report 'overly slow' GHC-compiled programs.  http://www.haskell.org/ghc/docs/latest/html/users_guide/faster.html
08:26:10 <dcoutts> ftp://ftp.cs.york.ac.uk/pub/haskell/contrib/hscolur-1.1.tar.gz
08:26:35 <dcoutts> kzm, it contains a module which does colourd text on the console
08:26:50 <dcoutts> the prog itself is for syntax highliting haskell
08:27:08 <tromp> thx, astrolabe
08:27:18 <dcoutts> ftp://ftp.cs.york.ac.uk/pub/haskell/contrib/hscolour-1.1.tar.gz
08:27:18 <kzm> dcoutts, thanks.  Any standard way to do formatting, btw?  I want to output justified columns.  Easy to do, but if there's a standard way, that'd be better.
08:27:22 <dcoutts> sorry can't spell
08:27:44 <dcoutts> you can use the pretty printer combinators for indenting and things
08:28:17 <kzm> Which are they?
08:28:32 * kzm thinks he saw a prettyprint module somewhere...
08:29:58 <kzm> Text.PrettyPrint.HughesPJ.Doc -- is this really a good name for a module in the ghc distribution (which I assume it is) :-)
08:31:32 <kzm> (I guess it's actually a type, the module is called HughesPJ, apparently)
08:31:42 <Igloo> I think Text.PrettyPrint reexports it
08:31:52 <Igloo> What better name would you suggest?
08:32:10 <kzm> Yes, the name just leaks out from GHC's :b
08:32:20 <Igloo> eh?
08:32:44 <Igloo> Naming individual implementations of things, and cabal packages of certain implementations of things, is a tricky business IMO
08:32:46 <kzm> If I :b Text.PrettyPrint, everything is shown with the HPJ module name.
08:33:34 <Igloo> Oh, right. Well that's the more stable name to use anyway
08:34:01 <kzm> Just my opinion, but I think the naming occasionally goes overboard a bit.   Text.ParserCombinators.Parsec is a mouth..or I guess, handful to type.
08:34:26 <Igloo> You aren't suggesting alternatives...  :-)
08:34:41 <kzm> That's right. :-)
08:35:01 * kzm doesn't know Text.PP, but thinks Text.Parsec would do nicely.
08:35:12 <kzm> for instance.
08:36:40 <kzm> I'm not sure the ParserCombinators give you anything, as it is unlikely that we'd ever have two modules called Parsec, and even then, Text will suffice to disambiguate them.
08:36:44 <kzm> IMO.
08:36:51 <Igloo> That's not the issue
08:37:10 <Igloo> The point is that all the parser combinator libraries should be in the same place, and not mixed in with everything else that comes under Text.
08:37:28 <kzm> Okay.
08:37:38 <kzm> Why is it important?
08:37:57 <Igloo> Because that's the whole point of a hierarchial namespace
09:02:22 <Philippa> Text.Parsing.Parsec might've been nicer though
09:05:01 <CosmicRay> Igloo: have you any interest in maintaining c2hs?  the current maintainer seems mia
09:05:12 <CosmicRay> the existing package is set Architecture: i386 and requires ghc5 (!)
09:05:46 <Igloo> CosmicRay: marcot is interested; see debian-haskell
09:05:54 <Igloo> Perhaps you'd be interested in sponsoring him?
09:07:08 * CosmicRay checks the archives
09:07:14 <Igloo> Typo "ilbrary" in your hsffig description, BTW
09:07:28 <CosmicRay> thanks
09:08:08 * CosmicRay prepares to receive 50 e-mails telling him that
09:14:10 <_metaperl> lol
09:14:22 <CosmicRay> happens every time I post an ITP on -devel
09:14:38 <CosmicRay> at least it's not as bad as bugtraq.  There, you get 50 automated vacation messages.
09:16:06 <musasabi> CosmicRay: about the ssl bindings we discussed some time back - I should have gnutls bindings in a releasable state next week.
09:17:04 <CosmicRay> NICE!
09:18:07 <Igloo> I think Isaac plans to make newer cabals available in Debian one way or another, BTW
09:18:16 <CosmicRay> yeah
09:18:20 <CosmicRay> I remember the discussion
09:18:23 <CosmicRay> but they're not there now
09:18:33 <CosmicRay> shouldn't be hard to include cabal in the package for the moment
09:18:43 <CosmicRay> (source) package
09:18:47 <Igloo> I think they should follow an installable ghc fairly quickly, though
09:19:09 <Igloo> Yeah, true. I'm just adverse to expending effort with the intention to revert it shortly afterwards  :-)
09:19:26 <CosmicRay> Igloo: my experience with debian is that "shortly" can mean anything from 5 hours to 3 years ;-)
09:19:32 <Igloo> :-)
09:26:00 * Lemmih pokes shapr.
10:06:20 <autrijus> hm, chromatic is hitting this bug in Pugs:
10:06:26 <autrijus> "Outstanding finalizers are no longer run at the end of program execution. Before, GHC was attempting to guarantee that finalizers were always run, but in fact it failed to provide this guarnatee in some cases. Providing this guarantee in general is hard, maybe impossible.
10:06:30 <autrijus> "
10:06:42 <autrijus> object finalizers were executed consistently in 6.2.2 before
10:07:10 <autrijus> and performGC doesn't fix the problem. is it one of the known "won't fix" problems? is there known workarounds?
10:08:12 <musasabi> autrijus: afaik there is no really good workaround.
10:08:17 <autrijus> :-/
10:08:43 <autrijus> is there bad workarounds?
10:08:53 <autrijus> I can only think of one, namely implementing refcounting(!) and arena handling
10:09:05 <autrijus> but that's significant work
10:09:23 <autrijus> and introduces leaks
10:09:36 <musasabi> wrap the application in an runAtExit wrapper and register cleanup handlers there, but that is not pretty.
10:10:09 <autrijus> yeah and I need to walk the dep graph myself
10:10:13 <autrijus> which sucks
10:10:23 * autrijus ponders a global mutable runAtExit.
10:10:43 <autrijus> nah. too messy
10:10:52 <autrijus> and the finalizers are closures
10:10:57 <autrijus> so they really need the env around
10:11:22 <autrijus> "Before, GHC was attempting to guarantee that finalizers were always run, but in fact it failed to provide this guarnatee in some cases. Providing this guarantee in general is hard, maybe impossible.
10:11:27 <autrijus> "
10:11:42 * autrijus mumbles something about rigorous approach, baby, and dishwater
10:11:57 <autrijus> I mean, bathwater. freudian slip.
10:13:22 <autrijus> so hm. register the finalizer in mutable storage; when the finalizer is run, it removes itself; at exit, run all the remaining finalizers, and forbid introduction of new finalizers in this phase
10:13:26 <autrijus> that may work.
10:24:58 <Enveigler_> dcoutts: ping
10:51:47 <Fide> hi
10:51:54 <CosmicRay> hello
10:52:38 <Fide> I must ask some stupid questions about haskell ;)
10:52:45 <CosmicRay> go right ahead
10:53:16 <Fide> first: is String a list of chars?
10:53:23 <CosmicRay> indeed it is
10:53:25 <thedward> ooh. I know that one. yes.
10:53:51 <CosmicRay> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AString
10:54:05 <CosmicRay> the Prelude is the "automatically imported" module in Haskell
10:54:12 <CosmicRay> in there, you can see this definition:
10:54:15 <Fide> then is this valid?
10:54:20 <CosmicRay> type String = [Char]
10:54:23 <Fide> isValid x:[] = x == 'x'
10:54:33 <Fide> isValid is String -> Bool
10:54:42 <dcoutts> nearly, it's missing some brackets
10:55:23 <dcoutts> you need brackets round the "x:[]" bit
10:55:38 <CosmicRay> parens, rather.
10:55:45 <liyang> Or you can write [x] instead.
10:56:02 <CosmicRay> however, this is not entirely correct
10:56:11 <CosmicRay> because you haven't matched the case where the string is more than one character long.
10:56:12 <Fide> x:xs is valid I thought
10:56:16 <CosmicRay> a correct definition would be:
10:56:24 <CosmicRay> isValid [x] = x == 'x'
10:56:28 <CosmicRay> isValid _ = False
10:56:33 <Fide> I mean that worked
10:56:54 <CosmicRay> Fide: isValid (x:xs) = x == 'x' is safer
10:57:08 <CosmicRay> I thought the parens were required in some cases...
10:57:23 <CosmicRay> or rather (x:[])
10:57:52 <Fide> (x:[]) == [x]?
10:57:54 <CosmicRay> but note that you will get a compilation warning, and a run-time exception, if you don't have the wildcard entry that matches strings of lengths other than 1 char
10:57:59 <CosmicRay> Fide: correct
10:58:04 <Fide> I see
10:58:18 <Fide> [x] is much better I think
10:58:21 <CosmicRay> the "_" in the second line I posted matches anything
10:58:32 <CosmicRay> Fide: yeah, it is more intuitive.  to haskell they are the same.
10:59:11 <dcoutts> Fide, the point is that the pattern [x] (or (x:[]) ) only matches lists of length 1, so if the function gets given something longer it's going to be an error
10:59:44 <CosmicRay> right.  If you have only the one pattern, then (isValid "x12345") will cause a crash at runtime
10:59:51 <liyang> (Or shorter, for that matter. The empty string will also fail.)
10:59:52 <Fide> dcoutts: yes it's that I want
10:59:54 <CosmicRay> though the compiler will warn you about that (non-exhaustive parrents)
11:00:04 <Fide> *what
11:00:15 <CosmicRay> Fide: you could, of course, also say: isValid x = x == "x"
11:00:15 <Fide> excuse me for my bad english
11:00:34 <CosmicRay> in that case, you are comparing the entire string, so it will be valid for all cases.
11:01:08 <dcoutts> Fide, do you really want the program to crash when running (isValid "x12345") ?
11:01:28 <dcoutts> presumably you want it to return False or somthing like that?
11:01:29 <amendes> Hello! Does anybody know if there exists any monadic aproach to sets? Particularly, do notation for sets?
11:01:30 <Fide> dcoutts: it's the head one
11:01:48 <Fide> dcoutts: I should write the EBNF in haskell
11:02:25 <dcoutts> Fide, I don't think I understand what you are trying to do :-)
11:02:47 <CosmicRay> amendes: it seems the people that would know that are not in the channel at the moment
11:03:12 <CosmicRay> amendes: however, you might try posting to the haskell-cafe mailing list
11:03:14 <dcoutts> Fide, if you can gurarantee that the isValid function will always be used with strings of length 1 then it will be ok, but otherwise...
11:03:29 <amendes> CosmicRay: thanks, and who are those people? :)
11:03:39 <CosmicRay> amendes: I would suspect probably igloo or shapr
11:03:45 <dcoutts> amendes, I expect it's possible since lists are instances of Monad
11:04:07 <Igloo> With Data.Set you'll probably have problems due to the Ord constraint
11:04:07 <amendes> dcoutts: Sets can't be made instance of Monad, unfortunately
11:04:15 <amendes> Igloo: that's right
11:04:24 <dcoutts> oh, right, forgot about that
11:04:28 <amendes> CosmicRay: thank you
11:05:16 <amendes> Someone told me that there was a haskell extension which provides do-notation for sets... I can't find it, so I am asking :)
11:05:26 <Fide> http://rafb.net/paste/results/9A2s0H71.html <-- looks that correct?
11:05:26 <Igloo> Doesn't ring a bell
11:05:30 <dcoutts> if only: data Ord a => Set a = ...  did what you expected it to do, it'd be ok
11:05:46 <Fide> dcoutts: I should check Strings like the EBNF I got
11:06:30 <dcoutts> Fide, oh the code you've got there looks fine, it has cases for [], [x] (x:xs)
11:06:39 <CosmicRay> Fide: line 5 looks suspicious
11:06:45 <autrijus> musasabi: woot, I solved the global finalization problem. reasonably cleanly, even.
11:06:51 <CosmicRay> Fide: I don't see a definition of tail or init anywhere
11:07:02 <Enveigler_> dcoutts: Did you wirk out what registry key the gtk2hs installer was failing to find?
11:07:05 <CosmicRay> Fide: also, True and False must be given with leading caps (that is, "True", not "true")
11:07:25 <dcoutts> Enveigler_, sorry, not yet
11:07:28 <CosmicRay> Fide: you might find this Haskell Tutorial helpful: http://www.isi.edu/%7Ehdaume/htut/
11:07:50 <Enveigler_> 'K thanks.
11:07:52 <autrijus> do { objRef <- mkWeakPtr obj (Just $ objectFinalizer env obj); modifyIORef _GlobalFinalizer (>> finalize objRef) }
11:08:05 <dcoutts> Enveigler_, I'll be looking into it as we're doing a bugfix release and I'll be updating the windows installer
11:08:08 <autrijus> that's it, with _GlobalFinalizer = unsafePerformIO $ newIORef (return ())
11:08:44 <Enveigler_> I just wondered if there was anything I could do to help you track down the problem?
11:09:26 <dcoutts> Enveigler_, hmm, I'll go check on my windows machine and see, thank's for the offer (I'll re-appear shortly as dcoutts_)
11:09:29 <musasabi> autrijus: What did you do?
11:09:37 <Enveigler_> 'k
11:10:15 <dcoutts> Enveigler_, you'll have to remind me where you pasted the installer log
11:10:21 <Fide> CosmicRay: thanks
11:10:32 <Enveigler_> Hmmm...? brb
11:10:52 <musasabi> I think that works, but won't the app slowly leak memory?
11:11:21 <autrijus> musasabi: hm, leak how?
11:11:23 <Fide> hmm I get an error :/
11:11:35 <autrijus> oh, right, one thunk per obj.
11:11:52 <autrijus> but can't remove them... well maybe if using Data.Map with key as the StableName
11:11:58 <autrijus> and inside the finalizer do a removal
11:11:59 <musasabi> autrijus: the empty weak pointers left behind in the global finalizers after the objects they have been removed.
11:12:01 <autrijus> but that's slow
11:12:02 <dcoutts> Enveigler_, you gave me a link to where you'd pasted the Gtk2Hs installer log, I need reminding where it was
11:12:04 <Fide> Does not match [a] -> [a] <-- how should I understand that?
11:12:07 <musasabi> autrijus: yes.
11:12:13 <autrijus> so I'd rather leak one thunk per obj
11:12:38 <musasabi> What about using a global mutable doubly linked list of finalizers?
11:12:52 <autrijus> how would that prevent leak?
11:13:00 <musasabi> and remove the cell from there when the finalizer is run.
11:13:11 <Enveigler_> dcoutts: Yes, I'm trying to find it... MIght be quicker to repaste?
11:13:13 <Lemmih> Fide: What doesn't match '[a] -> [a]'?
11:13:16 <autrijus> how is it faster than Data.Map?
11:13:41 <musasabi> no lookup necessary, I'll try to figure out whether it works.
11:13:54 <autrijus> I'm confused :)
11:14:36 <Fide> Lemmih: the Type error
11:14:40 <Fide> -the
11:15:09 <Fide> Lemmih: expression x == tail *** Type : Char
11:15:11 <Lemmih> The type error doesn't match '[a] -> [a]'? (:
11:15:18 <Enveigler_> dcoutts: http://sial.org/pbot/11966
11:15:25 <Fide> but x and tail should be Char
11:15:28 <CosmicRay> Fide: that's because tail is a function that takes one parameter
11:15:33 <CosmicRay> but you have not passed any parameters to it
11:15:44 <Fide> ahh
11:16:03 <CosmicRay> (tail "abcdefgh") would return "bcdefgh"
11:16:15 <musasabi> autrijus: five minutes and I'll have the example code up.
11:16:16 <CosmicRay> that's why I said before that your use of "tail" and "init" both looked suspicious
11:16:18 <Fide> init too I think
11:16:49 <CosmicRay> yes, it also takes a parameter.
11:17:04 <CosmicRay> you will probably need to write it something like isValid (init foo)
11:17:39 <Fide> hmm I see [x] == (tail xs)?
11:17:56 <CosmicRay> no, not exactly.
11:18:04 <CosmicRay> in your pattern isValid (x:xs)....
11:18:14 <CosmicRay> let's say you had instead written isValid list...
11:18:19 <CosmicRay> then (head list) would be the same as x
11:18:24 <CosmicRay> and (tail list) would be the same as xs
11:18:31 <Fide> but hugs tells me, that he has problems with Char an [Char]
11:18:45 <autrijus> musasabi: cool, thanks!
11:18:48 <CosmicRay> paste an updated version please, so we can see what's going on
11:19:39 <Fide> it works :)
11:19:47 <Fide> isValid (x:xs) = if [x] == (tail xs) then isValid (init xs) else False
11:19:47 <Fide> isValid (x:xs) = if [x] == (tail xs) then isValid (init xs) else False
11:19:50 <Fide> args
11:20:20 <CosmicRay> ok.  I'm not sure I understand what you're trying to do, but that does look syntactically correct ;-)
11:20:46 <Fide> it's an EBNF
11:21:11 <Fide> S = 'x' | 'a' S 'a' | ... | 'z' S 'z'.
11:21:23 <CosmicRay> ah.
11:21:41 <Fide> Strings like x, axa aaaxaaa or xxxxx are valid ones
11:22:08 <CosmicRay> Fide: I think there is a more beautiful way to represent that in Haskell.
11:22:13 <CosmicRay> let me experiment for a sec.
11:22:47 <Fide> I need an easier way, not a beautiful on :D
11:22:52 <Fide> *one
11:23:04 <CosmicRay> according to that spec, also the strng abxba is valid, yes?
11:23:16 <Fide> yes
11:23:43 <Fide> the language is uneven
11:26:38 <Fide> huh? I get False with abcxcba
11:28:05 <dcoutts_> Enveigler_, ok, I'm looking at the code and your installer log...
11:28:12 <Fide> hmm more than 3 letters are false oO
11:28:45 <dcoutts_> Enveigler_, if I can't figure it out, I might build you another installer with more logging output in it
11:29:07 <mwc> dcoutts_: good afternoon
11:29:46 <dcoutts_> mwc, hello
11:30:00 <dcoutts_> you had a question earlier?
11:30:11 <CosmicRay> Fide: I have almost something for you
11:30:22 <mwc> I was wondering if you were planning on making an 0.9.8.1 release soon
11:30:33 <dcoutts_> working on the release as we speak
11:30:33 <mwc> sounded before like you had everything marshalled up for it
11:30:51 <mwc> excellent! Then I'll put together the portfile
11:31:14 <dcoutts_> mwc, I can probably give you something to test within a couple hours, just working on the win32 installer atm.
11:31:36 <dcoutts_> mwc, is that a FreeBSD portfile?
11:31:39 <mwc> oh, I just need a tgz somewhere
11:31:43 <mwc> dcoutts_: darwinports
11:31:49 <Fide> CosmicRay: I found it, it was the using of tail instead of last
11:31:55 <dcoutts_> mwc, oh right
11:32:13 <goron> dcoutts: I found a spelling error in one of your papers about partial evaluation. Interested?
11:32:15 <dcoutts_> mwc, I'll ping you when I've got a tar.gz ready
11:32:22 <mwc> thank you kindly
11:32:25 <dcoutts_> goron, hmm, yeah ok
11:32:35 <Enveigler_> okay dcoutts, Just yell if there is anything I can do.
11:32:44 <dcoutts_> Enveigler_, yep
11:32:46 <goron> dcoutts: http://web.comlab.ox.ac.uk/oucl/work/duncan.coutts/papers/prg_conference_abstract.pdf
11:32:57 <goron> dcoutts: Search for "it".
11:33:03 <goron> dcoutts: It should be "is".
11:33:10 <dcoutts_> goron, ok ta
11:33:19 <mwc> goron: heh, not too many occurences of it I bet :P
11:33:28 <Fide> CosmicRay: that tutorial is too large, I have only one week to learn haskell basics
11:33:33 <goron> mwc: It is in the beginning
11:33:39 <mwc> goron: ah, okay
11:33:46 <CosmicRay> Fide: heh
11:34:02 <Fide> and my exam is not heskall only :/
11:34:28 <CosmicRay> I want to keep you coming back after your exam ;-)
11:34:53 <mwc> CosmicRay: are you the #haskell designated preacher? :P
11:35:09 <goron> No, that's shapr.
11:35:19 <CosmicRay> mwc: I'm just substituting
11:35:21 <goron> But maybe he took over the task.
11:35:22 <Fide> I have understand lot of things, but some importand like data or type I need to learn :/
11:37:02 <CosmicRay> you know, parsec would make this look almost exactly like BNF.
11:37:06 <CosmicRay> ;-)
11:38:19 <Fide> EBNF is cool, but I like BNF more
11:38:36 <Fide> because it reminds me pascal :)
11:39:02 <mwc> And that's a good thing?
11:39:04 <Fide> *remembers me
11:39:10 <goron> EBNF is a superset of BNF, so it should be cooler.
11:39:47 <CosmicRay> Fide: try this one
11:39:49 <Fide> BNF makes more fun than EBNF
11:39:54 <CosmicRay> isValid :: String -> Bool
11:39:54 <CosmicRay> isValid "x" = True
11:39:54 <CosmicRay> isValid l
11:39:54 <CosmicRay>         | length l >= 3 = head l == last l && isValid (drop 1 . init $ l)
11:39:54 <CosmicRay>         | otherwise = False
11:40:13 <CosmicRay> probably uses some syntax not covered by your class ;-)
11:40:26 <Fide> I have 1h for this test oO
11:40:50 <mwc> probably should be studying then, instead of wasting around on IRC :P
11:40:53 <Fide> CosmicRay: but this sounds, that x is false?
11:41:07 <CosmicRay> nope.. let me explain how this works.
11:41:23 <CosmicRay> If you call isValid with the string "x", the first definition matches, and it returns true.
11:41:28 <Fide> oh I see "x" = True
11:41:43 <CosmicRay> if you call it with any other string of at least three characters, it evaluates this: head l == last l && isValid (drop 1 . init $ l)
11:41:57 <CosmicRay> since you need a Bool, you can eliminate the "if" statements from here.
11:42:14 <Fide> drop 1?
11:42:14 <CosmicRay> we know that in order to return True, the first and last characters of the string must match, and the middle must also be valid.
11:42:28 <CosmicRay> so, (head l == last l) insures that the first and last chars match.
11:42:36 <CosmicRay> now, we construct the list to pass to isValid
11:42:38 <Fide> and what this dot means?
11:42:51 <CosmicRay> "drop x l" returns l with the first x elements removed, so it removes the first character
11:42:57 <CosmicRay> init removes the last character
11:43:10 <dcoutts_> Enveigler_, I think I've found the problem
11:43:11 <CosmicRay> the . is function composition -- that is, f . g $ x  is the same as f(g(x))
11:43:22 <autrijus> musasabi: I need to sleep in a bit... if you happen to have code, send it to autrijus at autrijus dot org, otherwise no worries about it
11:43:26 <CosmicRay> so it could have been written (drop 1 (init l))
11:43:31 <Fide> same like tail?
11:43:32 <dcoutts_> Enveigler_, it looks like it was my fault :-)
11:43:41 <CosmicRay> yes, or with tail.
11:44:00 <musasabi> autrijus: ok.
11:44:07 <CosmicRay>         | length l >= 3 = head l == last l && isValid (tail . init $ l)
11:44:12 <CosmicRay> is also valid for that line and does the same thing.
11:44:27 <autrijus> thanks! &
11:44:27 <Fide> isValid tail init l == isValid (drop 1 . init $ l)?
11:44:29 <CosmicRay> now, the "otherwise" line corresponds with the length test.
11:45:02 <CosmicRay> Fide: almost... isValid (tail (init l))  is the same as  isValid (drop 1 . init $ l)
11:45:08 <CosmicRay> which is also the same as isValid (tail . init $ l)
11:45:17 <CosmicRay> and the same as isValid ((tail . init) l)
11:45:34 <Fide> you does not need the () or have I missunderstood that?
11:45:41 <CosmicRay> no, you do need that.
11:45:55 <CosmicRay> if you say just "isValid tail init l", then the compiler will treat isValid as a function that takes three parameters.
11:46:06 <CosmicRay> it will try to pass the function tail, the function init, and the list l to isValid.
11:46:11 <liyang> Why not just isValid s = s == reverse s && case length s `divMod` 2 of { (l, 1) -> s !! l == 'x' ; _ -> False }  ?
11:46:16 <CosmicRay> of course, isValid takes only one parameter, so you will get a compiler error
11:46:37 <Khisanth> mmm Haskell golf
11:46:48 <CosmicRay> liyang: because we were trying to write *readable* code ;-)
11:47:01 <liyang> CosmicRay: that's perfectly readable. :p
11:47:01 <Fide> CosmicRay: why? I mean isValid::String->Bool is clear
11:47:18 <liyang> (okay, remove the braces and use indentation instead.)
11:47:20 <CosmicRay> Fide: because you separate parameters to a function with spaces.
11:47:39 <CosmicRay> that's like saying that you expect strlen(strcat, printf, 5) to work.
11:47:50 <CosmicRay> it's nonsense to the compiler, basically.
11:47:54 <Fide> not like TCL?
11:48:19 <Enveigler_> dcoutts: Nah. It's these darn installer generators. Too damn complicated.
11:48:24 <CosmicRay> probably not.  I don't know tcl anymore but it's probably quite different from haskell
11:50:00 <dcoutts_> Enveigler_, so the error message was quite right "Invalid RootKey value" I was using a registery function and using a variable to indicate which registery section to look in, but the variable had never been set :-). Oops.
11:50:33 <dcoutts_> Enveigler_, I'lm builiding the installer again for you to have a go
11:50:43 <Fide> I thought like that: isValid needs one Parameter, therefore it takes tail, but tail is a function which wants a parameter aswell and took init that wants a parameter also and took l which is a list and init returns a list to tail that returns a list to isValid that tries to match
11:51:02 <Fide> but now *grml*
11:51:10 <CosmicRay> Fide: the trouble with that is that it is perfectly natural for Haskell functions to take other functions as parameters
11:51:14 <CosmicRay> for instance, the map function does that
11:51:46 <Enveigler_> dcoutts: Great. Thanks.
11:51:50 <Fide> but I need ()
11:51:52 <goron> Anyone into lambda calculus :D
11:51:53 <goron> IIλ . Iλ Iλ Q IIQ .K KKKKIλ . Iλ KKKIIIλ . Iλ Iλ Q IIQ .K KKKKIλ . Iλ KKKIλ . .KKK
11:52:04 <mjl69> hi, can I ask a beginner's question here about running hugs for the first time?  I can not enter a simple definition as demonstrated in 2 dozen short lessons (lesson 2).  For example name = "mjl69" I get Syntax error in input (unexpected `=')
11:52:26 <goron> AH, crap. KDE3.4->GTK2.6 UTF-8 conversion is broken :(
11:52:50 <CosmicRay> Fide: Right.  The parens () will disambiguate the situation.
11:52:55 <goron> mjl69: yes
11:53:06 <goron> mjl69: That's not possible in Hugs.
11:53:08 <Lemmih> mjl69: Write declarations in a file and then load it in Hugs.
11:53:24 <mjl69> oh.  cool.  Thanks.
11:54:18 <mjl69> formulas that evaluate to boolean work so I was working through this way.
11:54:20 <goron> mjl69: In ghci you can do e.g. let a =1 in a
11:54:48 <Igloo> You can do that in hugs too
11:54:56 <Igloo> "let a = 1" is what you can do in ghci only
11:55:24 <goron> Igloo: Ok (I hate Hugs), which explains my Hugs ignorance.
11:55:39 <Igloo> What's to hate?
11:56:27 <goron> When I learned Haskell, it didn't work a lot of times(mostly because of bad system administration(I guess)).
11:56:53 <goron> So, mostly non-rational arguments, really.
11:57:08 * CosmicRay AFKs for the SPI meeting
11:57:15 <mjl69> goron, Lemmih, Igloo: thanks.  maybe entering in file the best way to go for me.  I will look at ghci too.  Thanks again for help!
11:57:16 <dcoutts_> Enveigler_, http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.8-r1.exe
11:57:23 <Igloo> CosmicRay: The IRC SPI meeting?
11:57:34 <CosmicRay> Igloo: yup, irc.oftc.net #spi
11:57:46 <goron> Was 0.98 with OpenGL support?
11:57:55 <goron> er 0.9.8
11:57:56 <Igloo> So what, you use speech2text or something?  :-)
11:58:10 <dcoutts_> Enveigler_, however the error you got was already on an error path! so installing that will still give you an errro, but hopefully it will be an informative error. Please tell me what error you get
11:58:51 <dcoutts_> goron, were you asking me?
11:59:09 <goron> dcoutts: Anyone with GTKHS knowledge.
11:59:32 <dcoutts_> sorry, wan't clear if you were talking about Gtk2Hs or something else :-)
11:59:38 <goron> dcoutts: I was already looking at the webpage.
11:59:43 <Enveigler_> dcoutts: Okay. It's downloading now. Back in 20 mins or so.
11:59:48 <dcoutts_> no, 0.9.8 does not have OpenGl support
12:00:07 <dcoutts_> it's something in the pipeline, and it'll be there sooner if you help :-)
12:00:39 <dcoutts_> we've been busy with bug fixing rather than new features recently (and the cairo stuff)
12:01:09 <dcoutts_> (which is a whopping big new feature!)
12:02:14 <dcoutts_> Enveigler_, sorry we sort of assume everyone's got broadband, the windows installer has actually got 4 seperate builds, which is great for ease of use - except for modem users :-(
12:04:16 <goron> dcoutts: OpenGL was planned for 0.9.9.
12:04:19 <Igloo> What are the 4?
12:04:32 <Igloo> (you could always have the individually as well as the all-in-one)
12:05:57 <dcoutts_> goron, well, if it gets done in time, it depends on demand
12:06:30 <dcoutts_> goron, if you've got some spare time to contribute I'm sure it'd help
12:07:07 <dcoutts_> we've got a code generator which does most of it for you, and you don't need to understand the rest of Gtk2Hs todo it
12:07:51 <goron> dcoutts_: Do you have some clear-defined TODO list?
12:07:56 <dcoutts_> it's mostly a metter of spending some time getting it to build ok and then testing it out
12:08:05 <dcoutts_> goron, we can make one if you're interested
12:09:10 <goron> dcoutts_: I am mostly busy with learning Lisp and Qi at this moment, but thanks for the offer. Knowing a bit GTK has some value.
12:09:31 <dcoutts_> ok
12:28:57 <Enveigler> dcoutts: I need to get the devel version of GTK+. I only have the runtime version.
12:30:08 <dcoutts_> Enveigler, right and does that error message match reality? did you only downloaded the runtime version?
12:31:45 <Enveigler> dcoutts: Yes. That was all that was required to use GTK from either Perl or Ocaml.
12:32:13 <dcoutts_> sorry Enveigler it's another big download I'm afraid :-(
12:32:32 <dcoutts_> the reason is that ghc uses the C header files when compiling apps that use gtk
12:33:06 <dcoutts_> it can even inline C calls from Gtk2Hs into your own modules, and in that case it needs the .h files
12:33:15 <Enveigler> Yes. 9MB v 4.5MB (hence my original choice :) But NP, It'll give me time to watch the end of Enterprise :)
12:33:31 <dcoutts_> it also needs the lib files to link with
12:34:10 <dcoutts_> it might be possilbe in future to do it, but not at the moment :-(
12:34:30 * Lemmih hugs his broadband connection.
12:34:31 <Enveigler> Back in a while.
12:34:50 <kolmodin> I downloaded the ghc cvs (the whole fptools dir) and run ./configure, it says: config.status: error: cannot find input file: mk/config.h.in
12:35:01 * Enveigler curses the distance from my house to the local exchange.
12:35:04 * goron shouts -Japan style- "Me too" :D
12:35:11 <kolmodin> what have I missed? can't find any of that in the installation manual..
12:35:34 <dcoutts_> kolmodin, let me check my ghc cvs version...
12:35:42 <kolmodin> dcoutts_: ok
12:35:55 <Lemmih> kolmodin: Did you check the GHC CVS cheat sheet?
12:35:58 <goron> kolmodin: You did read the compile instructionsm, right?
12:36:03 <goron> er -m
12:36:44 <kolmodin> Lemmih, goron: I did
12:36:52 <Lemmih> You should checkout fpconfig, not fptools.
12:37:25 <Lemmih> Did you run autoreconfig?
12:37:52 <dcoutts_> kolmodin, sounds like Lemmih's spotted it, the ghc cvs checkout procdure is very odd, easy to make mistakes
12:38:10 <kolmodin> I ran autoconf
12:38:12 <dcoutts_> you did the fpconfig bit?
12:38:22 <kolmodin> no....
12:38:28 <kolmodin> :)
12:38:36 <kolmodin> sounds like I missed something
12:39:04 <dcoutts_> the CVS instructions say to checkout the fpconfig bit and then checkout the other bits like ghc, libraries, hslibs etc
12:39:15 <dcoutts_> it's easy to get it wrong
12:46:21 <goron> dcoutts: Very true
12:46:40 <goron> dcoutts: Almost everyone makes a mistake compiling it the first time.
12:47:32 <dcoutts_> and I seem to manage to mess it up often when trying to cvs update
12:49:49 <goron> Maybe a HE_DUDE_THIS_COMPILES_FROM_CVS script would solve it all(since in reality it's mostly the user who does something wrong).
12:50:12 <dcoutts_> I'm sure that'd help
12:53:55 <kolmodin> hmm.. it didn't work
12:59:46 <goron> I am reading a text that says:"At the time of writing 3.8 GHz machines are on sale".
12:59:50 <goron> rofl
13:00:17 <dcoutts_> I thought they were
13:00:18 <Lemmih> eh?
13:00:21 <Spark> maybe it was written in the future
13:00:25 <goron> I think there must have been some space-time anomaly that I didn't notice.
13:00:51 <Enveigler> dcoutts: That fixed it. I've tried the Hello and Graphic demos so far and they both build and run clean.
13:01:12 <dcoutts_> I thought the most expensive & hot P4's "exreem" were 3.8
13:01:18 <dcoutts_> Enveigler, oh, great!
13:01:24 <wagle> maybe thats the RF frequency
13:01:41 <goron> dcoutts_: yes, thus *not* _on_sale_.
13:01:47 <dcoutts_> oh, ok
13:02:07 <Enveigler> concurrent also
13:02:29 <dcoutts_> Enveigler, the interesting ones are the calc, concurrent & fastdraw ones
13:02:42 <goron> dcoutts_: Is your GTK work for a research project? Or why do you work on it?
13:02:54 <dcoutts_> goron, because it's cool
13:03:16 <goron> dcoutts_: ok
13:03:19 <kolmodin> :)
13:04:03 <kolmodin> do you guys have a fptools/mk/config.h.in ?
13:04:58 <tic> moo moo moo
13:05:11 <Enveigler> Yep. fastdraw and calc also both work fine (except calc can't divide by 13 it seems) but the program runs fine.
13:05:38 <Enveigler> dcoutts: I'm kidding about the /13 :)
13:06:00 <kolmodin> ah, there... it might work now
13:06:00 <dcoutts_> Enveigler, I was just about to check my code :-)
13:07:18 <kolmodin> ok, it works fine now. I ran autoconf instead of autoreconf
13:07:40 <dcoutts_> hmm, autoreconf should be the right one
13:07:53 <kolmodin> no, that was the error :)
13:07:59 <kolmodin> when I ran autoreconf it worked :)
13:08:05 <dcoutts_> ok!
13:09:59 <kolmodin> hi tic :)
13:10:07 <tic> hi kolmodin
13:31:55 <perspectival> Is anybody here on a FreeBSD system?
13:32:27 <Beelsebob> in userland, yes...
13:32:29 <xerox> Hi people.
13:32:33 <dcoutts_> hi xerox
13:32:34 <Beelsebob> (OS X)
13:32:37 <Beelsebob> lo xerox
13:32:39 <xerox> dcoutts_: hiya!  Did you see Evan posting? :-)
13:32:47 <dcoutts_> I did. yes
13:32:59 <dcoutts_> I'll reply when I'm not so busy :-)
13:33:10 <xerox> Great :)
13:33:10 <dcoutts_> interesting to hear from him though
13:33:16 <xerox> Indeed.
13:33:17 <perspectival> <nod> I was wondering about the status of the Hugs Graphics Library port on FreeBSD
13:33:37 <perspectival> I'm trying to run excercises from SOE in Hugs
13:34:24 <dcoutts_> perspectival, it's one of my longer term plans to have Gtk2Hs provide the HGL interface, but that doesn't help you now :-)
13:34:46 <perspectival> I import the module SOEGraphics.hs, but it pulls in an X11 module called GraphicsUtils.hs, which in turn depends on a module called Concurrent
13:35:04 <Lemmih> JaffaCake: Why was -fnumbers-strict removed, btw? It sounds nice.
13:35:14 <xerox> dcoutts_: I've been talking with Abe, he likes AIM it seems :)
13:35:17 <perspectival> I've figured out that Concurrent is now "Control.Concurrent", but if I fix that, then more module errors pop up
13:35:54 <perspectival> that would be awesome if GTK2HS came with the HGL
13:36:49 <perspectival> Unfortunately the GTK2HS port on FreeBSD is marked broken; I've had to compile it (0.98) myself recently
13:36:56 <perspectival> Haven't had a chance to test it yet ;-)
13:37:26 <dcoutts_> perspectival, I should ping the FreeBSD port maintainers
13:37:46 <perspectival> yeah, I think quite a few things aren't up-to-date
13:38:00 <perspectival> Helium is marked as broken as well
13:45:50 <mwc> Is there an article around on setting up an autoconf'd haskell project?
13:45:55 <mwc> didn't see one on the Wiki
13:46:26 <dcoutts_> don't think so, mostly people just copy stuff from other autoconf'd haskell projects
13:46:48 <dcoutts_> or they use Cabal, whcih is better if can do what you need
13:51:44 <mwc> I'm partial to SCons, but I'd like to slim down my build reqs
14:32:42 <lispy`> anyone know of a library in haskell (or lisp) that does markov stuff? (chains or models)
14:33:16 <lispy`> i'd implement it myself but i'm having a hard time finding a gentle introduction to markov stuff.
14:33:30 <lispy`> so if you have a good guide to markov things i'd be happy with that as well
14:36:03 * shapr yawns
14:36:31 * lispy` waves at shapr
14:36:36 <shapr> hiya lispy`
14:36:58 <lispy`> shapr: what time is it in your part of the world?
14:37:00 <lispy`> must be late?
14:37:07 <shapr> nearly midnight
14:37:46 <shapr> I've wrapped my schedule around again, hoping to start getting up at 5am and unicycling before breakfast.
14:38:46 <lispy`> oh, wow
14:38:47 <goron> lispy`: What do you like more? Lisp or Haskell?
14:38:57 <lispy`> goron: yes!
14:39:05 <jyp> lispy`: markov chains are just graph annotated with probabilites right ?
14:39:17 <jyp> ... on edges
14:39:20 <lispy`> my bot is already written in lisp, so that would mean less code converting :)
14:39:25 * SamB like's haskell a lot better because it is so much easier to figure out what things can be used together
14:39:34 <lispy`> jyp: perhaps, i'm not sure :)
14:39:50 <jyp> iirc my course on them, yes :)
14:39:51 <SamB> er, likes...
14:40:02 <lispy`> goron: i like both, which one i like more depends on the weather
14:40:13 <jyp> what do you want to do with those ?
14:40:18 <goron> lispy`: I learned Lisp the last three days.
14:40:52 <goron> lispy`: The emacs integration is good. Lisp is truly portable asm.
14:41:02 <lispy`> i want to implment megahal in either lisp or haskell, i've tried reading the source, but it's very hard to untangle the algorithm.  If i understand the paper abotu megahal, all you really need are two 4th order markov models
14:41:18 <shapr> That sounds likely.
14:41:21 <SamB> megahal is interesting how?
14:41:30 <shapr> Isn't there already markov code in the fptools repo?
14:41:43 <SamB> isn't it mainly interesting because of how stupid it is?
14:41:55 <lispy`> SamB: if you log into #{} you can talk with my megahal bot, it's just for fun
14:41:56 <shapr> At least there's a simplistic viterbi algorithm in the voice recognition code in fptools.
14:41:57 * goron is with SamB
14:42:18 <shapr> I think markov chains are cool.
14:42:49 <shapr> Actually, megahal could be repurposed to generate random Haskell source for testing.
14:42:57 <lispy`> heh
14:43:06 <lispy`> shapr: this is true, or random input in general
14:43:16 <shapr> It would be a neat way to find bugs.
14:43:18 * goron hates prefix for operators though...
14:44:14 <shapr> For example, feed megahal the GHC source, then loop 1. generate random sources 2. compile them until GHC crashes or goes into an infinte loop.
14:44:18 <goron> shapr: Have you seen Qi already?
14:44:30 <shapr> Is that the quantum programming language?
14:44:35 <goron> No
14:44:46 <shapr> Oh, maybe not..
14:44:55 <shapr> But I'll have to look at it tomorrow, I'm off to sleep now.
14:45:00 <goron> http://www.lambdassociates.org/
14:45:06 <goron> Google will never find it.
14:45:17 <shapr> Oh, I have looked at this shortly.
14:45:34 <goron> I only like the type system.
14:45:47 <xerox> Back online, folks.
14:46:21 <goron> Types are used to express invariants in statically typed languages.
14:46:35 <goron> In OOP languages they use classes, which also are types.
14:46:54 <goron> In Qi you can use functions to define types.
14:47:19 <goron> It looks pretty much like the ultimate type system.
14:48:00 <goron> I don't like the rest of the syntax of Qi though, now I looked to it somewhat better.
14:48:23 <shapr> I'm falling over asleep, I'll take a look and talk to you about it next time I see you.
14:48:25 * shapr &
14:48:32 <goron> night
14:49:09 <Philippa> goron: how does Qi compare to the dependantly typed languages, or Omega?
14:49:32 <goron> Philippa: I think you can express dependency in Qi. I haven't done it, though.
14:50:17 <goron> Philippa: I don't know Omega. (I haven't followed a course in Type Systems).
14:51:11 <goron> Philippa: I am reading the documentation to find out how it's implemented.
15:01:51 <Philippa> goron: what facilities does it actually offer?
15:02:12 <Philippa> There're a number of well-studied typed lambda calculi that offer type-level functions
15:02:13 <goron> Philippa: Did you check the examples on the website?
15:02:33 <Philippa> d'oh. Doing so
15:02:45 <goron> Philippa: Do you also know implementations?
15:03:26 <goron> (of well-studied lambda calculi that offer type-level functions?)
15:04:41 <Philippa> there're a couple with TaPL
15:04:53 <Philippa> (lambda-omega and system F-omega)
15:05:09 <Philippa> turing complete type systems're nothing new, the fun's in making them usable
15:06:17 <goron> Philippa: I have a pretty good idea of how the syntax should look, but I guess tying it to a theorem prover is the real "fun".
15:06:50 <Philippa> see, there're a few fundamentally different approaches...
15:07:12 <Philippa> eg do you want to base it around logic programming or functional programming? Do you want complete separation of types and values, or do you want dependant types?
15:07:36 <Philippa> (of course, you can always give values such precise types that they're effectively lifted into types /anyway/)
15:11:32 <goron> Are proofs also cached in implementations?
15:12:45 <Philippa> not any I've played with directly myself, but I wouldn't be surprised if there are some that do
15:12:56 <Philippa> 'sprobably not /too/ hard to pull some kind of memoisation stunt
15:18:20 <goron> Philippa: How hard is it to write this kind of type checkers?
15:18:45 <Philippa> for a really lame just-does-it implementation? Not that much harder than H-M AIUI
15:18:53 <Philippa> read TaPL?
15:19:05 <goron> What is H-M AIUI?
15:19:19 <goron> no
15:19:53 <jyp> One book to rule them all
15:22:02 <goron> Philippa: What is H-M AIUI?
15:22:21 <Philippa> two separate acronyms, for one
15:22:27 <Philippa> Hindley-Milner, As I Understand It
15:22:43 <goron> Yes, I already understand two seconds before you posted that :D
15:22:55 <goron> er understood it
15:22:56 <{[mono]}> Hindley-Milner artificial intelligence user interface
15:23:20 <goron> that last part was also one parsing of me :D
15:24:15 <goron> Why isn't everybody using those type systems? Are they too slow?
15:24:40 <{[mono]}> some people have not heard of it
15:24:55 <jyp> Why isn't everybody using haskell, btw ?
15:24:59 <jyp> :p
15:25:04 <{[mono]}> some people want some kind of subtyping e.g. object obsessity pomposity (oop)
15:25:22 <{[mono]}> some people simply like to be dynamically typed
15:25:48 <{[mono]}> some people want some kind of dependent typing
15:26:03 <{[mono]}> some people don't type
15:26:27 <Philippa> goron: they've historically been really damn clunky, with no good partial inference algorithm
15:27:14 <Philippa> imagine having to explicitly type everything in a haskell program and work from there
15:27:26 <Beelsebob> ... I do
15:27:31 <goron> Philippa: Well, I actually do.
15:27:47 <Beelsebob> type signatures are documentation
15:27:55 * goron is with Beelsebob 
15:28:00 <Beelsebob> and a double check of your thought process
15:28:04 <Philippa> I don't. I might annotate some of my function definitions, but the little one-shot lambdas I hand into filter?
15:28:21 <goron> No, inline lambda's I don't type.
15:28:31 <Beelsebob> I make named functions for that sort of thing
15:28:38 <Beelsebob> in a where clause
15:28:40 <goron> I only type top-level functions.
15:28:53 <Philippa> Beelsebob: I do that if they're actually complicated
15:28:55 <Beelsebob> only time I would leave a type signature off is passing a section in
15:28:58 <goron> (and some stuff needs to be typed)
15:29:16 <goron> (for choosing e.g. the correct instance)
15:29:35 <Philippa> goron: imagine manually typing all the lambdas a do statement generates for you. Been scared off yet?
15:29:55 <Beelsebob> haha, yeh... that would be a bit harsh
15:29:56 <goron> Philippa: yes, thanks for the horror picture floating though my mind.
15:30:05 <goron> er through
15:30:20 <Philippa> right. This is why System F-omega historically hasn't been used for real-world code :-)
15:31:00 <goron> In Qi you can decide by yourself what you want to type.
15:31:20 <Philippa> that's because Qi's built on top of a dynamically typed language though
15:31:30 <Beelsebob> hmm... a 41MB download had better do more than just "address an issue with browsing photos that have been auto-rotated by a camera."
15:31:49 <goron> Philippa: Implementation details are not relevant for the spec.
15:32:22 <goron> Philippa: Qi could also be implemented in Haskell.
15:32:35 <Philippa> let me rephrase: that's because Qi is a dynamically-typed language with optional static checking
15:32:44 <goron> Philippa: Yes
15:32:58 <goron> Philippa: But isn't that a good thing?
15:33:13 <goron> Like:"Type what you want to type".
15:33:18 <Philippa> depends who you talk to
15:33:31 <Beelsebob> oh... that sounds like a talk I went to at ETAPS
15:33:49 <goron> The type-nazi's can type everything, while Joe Idiot types nothing.
15:33:58 <Beelsebob> except that the idea there was hybrid memory consumption prooving
15:34:08 <Philippa> and then some poor bastard still has to use Joe Idiot's code
15:34:08 <Beelsebob> that made static checking easy
15:34:20 <Beelsebob> but required some nifty dynamic runtime
15:34:35 <Beelsebob> (although again not as heavyweight as a fully dynamic implementation)
15:34:41 <goron> Philippa: By market laws Joe Idiot will die (or not)
15:35:09 <Beelsebob> goron: unfortunately, managers are not interested in how good your code is
15:35:16 <Beelsebob> they're interested in how fast you code
15:35:24 <Philippa> goron: Joe Idiot is alive and kicking
15:35:36 <Beelsebob> so the guy that does it the slow good way and has to deal with joe idiot's code is more likely to die
15:35:48 <goron> Philippa: I know, so then there must be something stupid.
15:35:55 <goron> Philippa: The consumers?
15:35:59 <Philippa> right. The money's in fast and good - 'cos you can't have those two and cheap anyway
15:36:22 <goron> And mostly the money is in fast.
15:36:35 <Philippa> that depends very much on where you are
15:36:45 <Philippa> there're places where lack of good is quite literally fatal
15:36:54 <goron> I mean quantitatively.
15:37:22 <Philippa> embedded's not a small business, put it that way
15:37:53 <goron> embedded code is not secure code most of the times.
15:38:10 <Philippa> no, but it's frequently safety critical
15:38:14 <goron> Yes
15:38:23 <goron> But they are engineered.
15:38:36 <Philippa> so?
15:38:38 <goron> They have trees of all possible scenario's.
15:38:56 <goron> They keep things manageable.
15:39:02 <Philippa> and then have to make very very certain they don't accidentally break that
15:40:06 <goron> Although, I wonder whether the code quality is really good.
15:40:08 <Philippa> if you're embedded /and/ realtime, the engineering's every bit as complex as that involved in keeping code secure - if not more so
15:40:13 <Philippa> def. "code quality"
15:40:37 <goron> yes, realtime programming is hard.
15:41:01 <goron> Because you most likely hit performance walls sooner or later.
15:41:12 <goron> And need to hack things to make up for it.
15:41:39 <Philippa> generally that's not the issue at all. Knowing for absolute certain you're done by time t is
15:42:19 <Philippa> the slower-average algo with better worst case complexity is vastly preferable...
15:42:38 <goron> Philippa: Yes
15:42:59 <goron> Philippa: But calculating how many cycles some computation takes isn't that hard.
15:43:17 <Philippa> that depends rather a lot on the computation and on what you know about the input
15:43:20 <goron> Well, it depends on the hardware.
15:43:54 <goron> I guess it's hard to put good bounds on the hardware.
15:44:08 <goron> Pessimistic bounds are not hard ofcourse.
15:44:42 <goron> And concurrency in real-time systems?
16:52:30 <MarcWeber> Do you think it's enough to read on or two tutorials or is there a also a book which you would recommend to learn haskell properly?
16:52:45 <ibid> depends on your background
16:53:23 <MarcWeber> ibid: no functional language but a couple of others (Java/C/C++/pascal/vb(.net))..
16:53:29 <Pseudonym> Do you naturally pick up programming languages quickly?
16:53:39 <MarcWeber> Pseudonym: Not haskell ;)
16:53:45 <Pseudonym> :-)
16:54:26 <MarcWeber> But it's not necessary to have everythin repeated many times if you mean that
16:54:56 <Pseudonym> Personally, I find the best way to learn a new language is to pick a task, and try it.
16:55:08 <Pseudonym> As you find something you don't know, learn about it.
16:55:22 <Pseudonym> Unfortunately, that doesn't work so well with Haskell because I/O is the hardest bit to learn.
16:55:24 <MarcWeber> Pseudonym: You have to know that there is s.th. new
16:55:27 <lispy`> MarcWeber: based on the languages you said you know, haskell make take some time...spend some time learning to map functions on to lists, and spend some time with recursion
16:56:10 <Pseudonym> Something that I found helpful with my first Haskell-like language (which was Miranda, a precursor to Haskell) was to use it as a calculator.
16:56:14 <lispy`> MarcWeber: i'm guess that the syntax is easy right?
16:56:22 <Pseudonym> As I needed a new calculator-like task, I wrote it in Miranda.
16:56:28 <ibid> MarcWeber: i might recommend one of the textbooks at http://haskell.org/bookshelf/#textbooks
16:56:40 <Pseudonym> Eventually, my "desk calculator" could handle polynomials and symbolic differentiation.
16:56:44 <Pseudonym> And all sorts of cool stuff.
16:56:55 <ibid> MarcWeber: i like the craft best, but the school of expression has its fans too
16:56:57 <lispy`> MarcWeber: does this make any sense?  map (+1) [1,2,3]
16:57:13 <lispy`> MarcWeber: (just testing where you are currently)
16:57:16 <ibid> MarcWeber: the bird one is also good
16:57:16 <MarcWeber> lispy`: recursion isn't that uncommon.. I've already understood maps,folds
16:57:36 <MarcWeber> lispy`: The same as map (\x -> x+1) 1:2:3:[] ?
16:57:40 <lispy`> MarcWeber: ah, good, so adapting to functional programming won't be so hard?
16:57:51 <lispy`> MarcWeber: looks right
16:57:57 <MarcWeber> lispy`: I've gone throuh 70 pages of haskell tutorial already..
16:58:05 <lispy`> @eval map (\x -> x+1) 1:2:3:[]
16:58:09 <lambdabot> <Plugins.Eval>:1:
16:58:09 <lambdabot>   No instance for (Num [a])
16:58:09 <lambdabot>   arising from the literal `3'
16:58:24 <lispy`> is that because fo the monomorphic restirction?
16:58:32 <lispy`> @eval map (\x -> x+1) (1:2:3:[] ::[Int])
16:58:34 <lambdabot> [2,3,4]
16:58:45 <Pseudonym> @eval map (\x -> x+1) (1:2:3:[])
16:58:46 <lambdabot> [2,3,4]
16:58:53 <Pseudonym> It's due to lack of parentheses.
16:59:00 <ibid> lispy`: there is no nontrivial polymorphism there
16:59:00 <lispy`> ah, okay
16:59:17 <Pseudonym> Remember, function application binds the tightest.
16:59:31 <lispy`> right
17:00:44 <MarcWeber> I want to learn haskell to know how much time it can save you compared to a C++ like language
17:01:00 <Pseudonym> Right.
17:01:04 <MarcWeber> And therefore it's necessary to also learn the advanced features (I think)
17:01:15 <Pseudonym> Not necessarily.
17:01:40 <Pseudonym> I think a lot of the time savings come from idioms, not features.
17:01:41 <lispy`> I would consider Monads an advanced feature (perhaps they are only intermediate), and you'll need IO which is a monad
17:01:52 <MarcWeber> Pseudonym, lispy` Which kind of user interaction do you use? commandline? gui?
17:02:07 <Pseudonym> I don't tend to write Haskell programs like that.
17:02:13 <lispy`> me either
17:02:15 <MarcWeber> lispy`: That's my next goal..
17:02:17 <Pseudonym> I either use the GHCi command line or write batch jobs.
17:02:29 <Pseudonym> But that's just me.
17:02:37 <Pseudonym> And lispy, apparently.
17:02:39 <MarcWeber> So you both use haskell as scripting language?
17:02:50 <lispy`> what is a scripting language :)
17:02:56 <Pseudonym> No, I use it for batch jobs.
17:03:00 <Pseudonym> Or pipes.
17:03:12 <Pseudonym> But mostly I use it as a glorified calculator.
17:03:19 <{[mono]}> me too
17:03:28 <Pseudonym> I write scripts in Haskell, then interact with them on the GHCi command line.
17:03:37 <lispy`> MarcWeber: one thing i wrote recently was an embedded language.  You write a haskell program and when you run it, it outputs a procmailrc file.
17:03:44 <Pseudonym> So it's a calculator which can do anything at all.
17:03:56 <Pseudonym> Oh, yeah, I do code generation, too.
17:04:01 <Pseudonym> But that's a batch job.
17:04:02 <{[mono]}> http://www.cs.utoronto.ca/~trebla/calculator.lhs :)
17:04:38 <lispy`> MarcWeber: if you are curious about usre interactino, maybe Yi would be a good thing to look at.  It's an editor written in hasakell
17:04:41 <lispy`> er haskell
17:04:46 <Pseudonym> Hey, that's my fibonacci algorithm!
17:05:04 <Pseudonym> I think.
17:05:15 <{[mono]}> it's everyone's fibonacci algorithm.
17:05:19 <Pseudonym> :-)
17:05:22 <Beelsebob> that's a bit over complicated
17:05:23 * Igloo doesn't think to /use/ certain monads you need to be advanced
17:05:24 <lispy`> MarcWeber: i also like to implement algorithms in haskell, I've implemented a few graph algorithms, RSA, knights tour, and a few others
17:05:25 <{[mono]}> every educated one, at least.
17:05:37 <Pseudonym> It's not my Euclidean algorithm, though.
17:06:08 <Beelsebob> fib = ((!!) (fibs 1 1) where fibs x y = x:(fibs y (x+y)
17:06:08 <lispy`> MarcWeber: i'm trying to code up an elisp interpreter, but it's going slow, or rather i don't spend much time on it
17:06:09 <Pseudonym> http://cvs.sourceforge.net/viewcvs.py/haskell-libs/libs/maths/euclidean/
17:06:17 <Beelsebob> as effecient, and much neeter
17:06:25 <lispy`> Igloo: hey, what should i do about that test that fails with darcs-unstable?
17:06:26 <Pseudonym> No, it's NOT as efficient.
17:06:35 <Beelsebob> really, what more does it do?
17:06:36 <Pseudonym> lispy's (and mine) computes fib n in O(log n) time.
17:06:40 <lispy`> Igloo: i realized i can't send in any patches as long as it's "broken"
17:06:46 <Pseudonym> Yours computes it in O(n) time.
17:06:54 <Beelsebob> as do all fib algorithms
17:07:07 <Beelsebob> don't they?
17:07:08 <Igloo> lispy`: You should point me at something that describes the semantics of errno
17:07:09 <lispy`> Pseudonym: er, my what?
17:07:10 <Igloo> And yes you can
17:07:22 <Igloo> You just need to record with --no-test
17:07:26 <lispy`> ah
17:07:29 <Beelsebob> the one shown is O(n)
17:07:39 <lispy`> Igloo: i didn't even thing to check for --no-test
17:07:40 <Pseudonym> And the one that lispy showed is O(log n).
17:07:54 <lispy`> Igloo: what do you mean by the semantics?  There are the man pages, but i assume you've seen that
17:08:03 <Beelsebob> pseudonym: for generating the whole list????
17:08:12 <Pseudonym> No, for generating one number.
17:08:17 <lispy`> Pseudonym: I think you're confusing me with someone else :)
17:08:20 <Beelsebob> oh, okay
17:08:25 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/Math/Fibonacci.hs
17:08:27 <Beelsebob> I was meaning the infinite list
17:08:29 <Pseudonym> Oh, sorry, mono's.
17:08:31 <Pseudonym> Duh.
17:09:08 <{[mono]}> There are still a lot of people in the dark age.
17:09:35 <lispy`> oh, i used infinite lists the other day to make a complex problem simple
17:10:21 <{[mono]}> perhaps it was a simple problem with complex non-infinite-list solutions. :)
17:10:28 <Igloo> Hmm, OK, that's what I expected
17:10:35 <lispy`> i had a certain type of graph i needed to create, and i wante to enumerate all of them at various sizes. the combinatorics to count them was easy, but generating them all was tricky.  so I created an infinite list of random instances, and then use nub and take :)
17:11:26 * Igloo thinks rewriting appropriate bits of compat.c in Haskell is the best way forward
17:11:27 <lispy`> it wasn't the fastest way to generate them, but it was simple to code up, and it was fast enough for what i was doing
17:11:34 <{[mono]}> you're evil!
17:11:58 <Pseudonym> :-)
17:12:21 <Pseudonym> The other thing is I tend to use lazy evaluation a lot more than I used to.
17:12:28 <lispy`> Igloo: so you think there is some bug in compat.c that is resetting errno?  could it be that the errono is set in one thread (say the C thread) and that the haskell stuff can't see the value because it's in a different thread?
17:12:32 <Pseudonym> For example, I wrote a simple final gathering raytracer in Haskell recently.
17:12:54 <Pseudonym> When I do a ray intersection, I return every possible piece of information.
17:13:01 <lispy`> ah, nice
17:13:04 <Pseudonym> And if the caller doesn't need it, it doesn't get evaluated.
17:13:22 <Igloo> I suspect it'll be the getCurrentDirectory that's resetting it, but the whole thing feels far too fragile
17:13:31 <Pseudonym> http://andrew.bromage.org/test3.png <- No irradiance cache, no FG importance sampling, so it's slow and noisy
17:13:33 <Igloo> And little bits of C should be avoided wherever possible IMO
17:13:36 <Pseudonym> But it works.
17:14:02 <lispy`> Igloo: i tried moving the errno <- blah line in the code up to right where rc is set, but errno was still zero
17:14:47 <Igloo> It's throwErrno that is the problem, not errno
17:15:26 <lispy`> Pseudonym: not bad, is the noise from round off errors?
17:15:32 <Pseudonym> No.
17:15:34 <lispy`> Igloo: ah
17:15:38 <Pseudonym> It's from... well, read the TMR article.
17:15:44 <Pseudonym> When it gets written. :-)
17:15:52 <lispy`> hehe, i was just going to ask :)
17:15:56 <Pseudonym> But basically, it's from variance.
17:16:07 <Pseudonym> You're estimating the value of some pixel.
17:16:09 <Pseudonym> By sampling.
17:16:20 <Pseudonym> High variance results in noise.
17:16:46 <heatsink> Why is the noise so unevenly distributed, for example on the ceiling?
17:17:00 <lispy`> thats' where the light source is, i think
17:17:02 <Pseudonym> There's a light source just below the ceiling.
17:17:33 <Pseudonym> The biggest contribution to the illumination on the centre of the ceiling is the light source, since it's right THERE.
17:17:37 <lispy`> you have more rays of light, and hence more samples near a light source right?
17:17:53 <Pseudonym> No.  And that's the problem.
17:18:08 <Pseudonym> That's the reason it's so noisy.
17:18:08 <heatsink> Oh, I see.
17:18:23 <Pseudonym> The system doesn't know where to sample the most.
17:18:24 <lispy`> ah, so you need more, but you don't have more
17:18:27 <Pseudonym> Right.
17:18:31 <Pseudonym> And this is part of the article.
17:18:41 <lispy`> well, now that we've solved that, lets move on to, oh....world peace?
17:18:45 <heatsink> There's another noise stripe on the left wall
17:18:45 <Pseudonym> It's about the difference between a photon and it's adjoint.
17:19:02 <{[mono]}> w00t! photons have adjoints?!
17:19:04 <Pseudonym> More about that later.
17:19:08 <Pseudonym> Oh, yes, they do. :-)
17:19:18 <lispy`> Pseudonym: well, i can't wait to read it. I helped write GRT (a common lisp ray tracer) but the ray tracing was the part i never understood :)
17:19:37 * {[mono]} writes paper "Photons as Galois Connections"
17:19:48 <Pseudonym> That's what I'm trying to concentrate on in the article.  Giving a solid mathematical basis for what rendering actually is.
17:19:54 <Pseudonym> In the context of a simple raytracer.
17:20:08 <lispy`> Pseudonym: i really can't wait now
17:20:24 <lispy`> stop chatting and get back to writing ;)
17:20:28 <Pseudonym> :-)
17:20:46 <Pseudonym> A few people are trying to write renderers in Haskell (e.g. HRay).  So I figured I'd help them out.
17:21:11 <MarcWeber> lispy`: Thanks Yi is a great link!
17:21:23 <gzl> what?
17:21:24 * heatsink wonders why continuations are used in the explanation of something that doesn't involve continuations
17:21:27 <gzl> photons have adjoints?
17:21:34 <Pseudonym> Yes, they do.
17:21:39 <Spark> photons are functions between lattices?
17:21:57 <lispy`> MarcWeber: don't thank me thank dons, he's the author :)
17:22:08 <Pseudonym> Spark: Read the damn article.
17:22:16 <lispy`> but it's not out yet!
17:22:18 <lispy`> ;)
17:22:19 <Pseudonym> :-)
17:22:34 <lispy`> you can't RTFM when the FM isn't finished ;)
17:22:47 <Pseudonym> Well the next TMR is supposedly coming out on 1 August.
17:22:54 <Pseudonym> So you don't have to wait long.
17:22:56 <gzl> wait, you mean photons as in light, correct?
17:22:59 <Pseudonym> Right.
17:23:03 * gzl scratches head vigorously
17:23:17 <gzl> so ... what's going on? :)
17:23:23 <Pseudonym> Free clue: "Adjoint" meant something to mathematicians before category theory came along.
17:23:27 <ulfdoz> bye
17:24:18 <MarcWeber> dons: Thank's for the great example Yi! I'll have look at it right now
17:24:44 <lispy`> Pseudonym: as in adjoint matricies?
17:24:48 <Pseudonym> Right.
17:25:00 * lispy` struggles to recall linear algebra
17:25:18 <MarcWeber> Why not ask wikipedia? ;)
17:25:24 <Spark> shame i dont know any maths :)
17:25:32 <Pseudonym> Well, it's general linear algebra.  More like Hermitian operator algebra.
17:25:45 <Pseudonym> Don't know any quantum mechanics either, eh?
17:26:30 <Pseudonym> This is all explained in the article, anyway.
17:26:35 <Pseudonym> I think.
17:26:39 <lispy`> i don't know any quantum mechanics, but i did at some point know adjoint matracies.  I'll have to review them when i get a chance
17:26:41 * Pseudonym hasn't actually written the explanation yet
17:27:03 <lispy`> i left all my books at home this summer :(
17:27:03 <Pseudonym> The actual details of forming adjoint matrices are completely unimportant.
17:27:16 <Pseudonym> To the article, anyway.
17:27:30 <lispy`> yes, but i don't even remember what makes them different
17:27:39 <lispy`> at this point i just remember the term
17:28:09 <MarcWeber> lispy`: There are two online pdf books of matheplanet (written in English).. I can look for the link if you want..
17:28:18 <lispy`> a lot of my lin. alg. knowledge is getting hard to recall
17:28:20 <Pseudonym> Or you can just read the article.
17:28:33 <Pseudonym> lispy, are you a TMR author?
17:28:38 <lispy`> MarcWeber: cool, i'll just google it, i can't read them right now :)
17:29:04 <lispy`> Pseudonym: no, i'm flattered that you would think i might be, but alas i have nothing interesting to say :)
17:29:15 <Spark> what is tmr?
17:29:20 <lispy`> the monad reader
17:29:25 <Spark> ah
17:29:26 <lispy`> @google the monad reader
17:29:28 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
17:29:37 <Pseudonym> :-)
17:29:51 <Pseudonym> Anyway.
17:29:54 <Pseudonym> Free cakes!
17:29:58 <Pseudonym> Be back in an hour or so.
17:30:06 <lispy`> heh
17:30:09 * lispy` waves
17:41:47 <MarcWeber> http://aux.planetmath.org/book/fem-pdf/ (vol1.pdf and vol2.pdf.. Have fun..;)
17:43:01 <gzl> what are they?
17:43:14 <MarcWeber> free encyclopedia of mathematics.. ;)
17:43:31 <gzl> isn't that what planetmath itself is?
17:44:05 <Beelsebob> :(
17:44:12 <MarcWeber> gzl: Don't know that well. I've told lispy` about those books that's why I've pasted this link
17:44:14 <Beelsebob> the Shuttle's been damaged in the launch
17:45:06 <gzl> MarcWeber: well, planetmath is an encyclopedia
17:46:25 <Igloo> It was published; those might be the published text
17:46:45 <gzl> aha
18:13:51 * heatsink vaguely remembers hearing a conversation about combining the state monad with the error monad a while ago
18:14:00 * heatsink thinks it understands what it means now
18:14:14 * heatsink hates not being able to understand concepts until after it reinvents them
18:20:24 <dcoutts> musasabi, sorry it took so long, but I finally emailed you my suggestion for an attributes module and an example using it for normal IO attributes
18:34:24 <MarcWeber> dons: Are you around? I get this error when compiling yi: ghc-6.2: unknown package name: plugins
18:35:15 <Beelsebob> run ghc-pkg?
18:35:33 <MarcWeber> Beelsebob: no.
18:35:39 <MarcWeber> Never heard..
18:35:45 <Beelsebob> eh?
18:35:50 * Beelsebob confused
18:36:15 <Beelsebob> (i.e. list the packages)
18:36:21 <MarcWeber> Sorry.. Have translated you statement ino "Have you run.."
18:36:27 <Beelsebob> ... do you have hs-plugins installed properly
18:36:34 <Beelsebob> ah, okay
18:36:47 <Beelsebob> I meant try running it and see what it tells you
18:38:43 <Beelsebob> what does `ghc-pkg list | grep plugins' tell you?
18:38:58 <MarcWeber> Wait.. emerging hs-plugins has helped..
18:39:07 <Beelsebob> ... that would
18:40:56 <Beelsebob> while we're at it... you're obviously a gentooer
18:41:08 <Beelsebob> you ever had emerge world fuck sudo over?
18:41:53 <MarcWeber> ??
18:42:03 <Beelsebob> I ran an emerge world today
18:42:09 <Beelsebob> now sudo's fucked
18:42:15 <mikehammad> is anyone familiar with the ghc package for gentoo?
18:42:21 <dons> MarcWeber, you need hs-plugins installed
18:42:40 <MarcWeber> dons: Thanks! Beelsebob already told me.. how to start it now? ghci?
18:42:40 <Beelsebob> familiar as in I have it running mike?
18:42:40 <dons> since you're using ghc-6.2, you'll need hs-plugins 0.9.8 i think
18:43:17 <mikehammad> so, i built ghc-6.4 from portage, but it's only a stage-1 build
18:43:23 <mikehammad> hence, no template haskell
18:43:49 <Beelsebob> hmm, odd, I think mine built all the way
18:44:06 <Beelsebob> I have a couple of users using template haskell so it must have
18:44:30 <mikehammad> huh
18:44:38 <dons> MarcWeber: ./yi-static README would work
18:44:45 <dons> (if you've already built yi)
18:44:55 <mikehammad> when i try to compile something with TH it says i'm using a stage-1 install
18:44:57 <MarcWeber> dons Thanks! Works great (except of :h ;))
18:45:10 <Beelsebob> bisare
18:45:18 * dons has to remind himself whhat :h does?
18:45:21 <Beelsebob> worked fine with no weird options here
18:45:22 <dons> oh. :help -- right!
18:47:02 <dons> if you get latest yi from the darcs repo, we've also got a couple of emacs modes going (though vi/vim sounds like your thing)
18:47:20 <MarcWeber> dons: i'm vi user ;) and there is something odd I can't compile
18:48:05 <MarcWeber> Beelsebob: sudo is fucked? What do you mean?
18:48:35 <MarcWeber> Beelsebob: sudo $LOGNAME doesn't work either?
18:48:44 <Beelsebob> I mean fucked... ``sudo: Account expired or PAM config lacks an "account" section for sudo, contact your system administrator''
18:49:11 <Beelsebob> I suspect that emerge world went and sat on the sudoers file
18:49:38 <MarcWeber> Beelsebob: Think you should ask at #gentoo
18:49:45 <Beelsebob> probably a good plan
18:49:54 <dcoutts> mikehammad, gentoo's ghc-6.4 has got TH, what was the problem?
18:49:56 <Beelsebob> I was gonna play with booting into SU when I get to it tomorrow
18:50:01 <Beelsebob> and then start asking
18:51:07 <Beelsebob> ... after all, it's still running, just I can't get root access
18:51:15 <mikehammad> when i try to compile something with TH i get "./MMult.hs:33:27:
18:51:15 <mikehammad>     Template Haskell splice illegal in a stage-1 compiler
18:51:15 <mikehammad>       baseC 5 5
18:51:15 <mikehammad> "
18:52:04 <dcoutts> hmm, most odd, the ghc ebuild should do a full build
18:52:08 <dcoutts> what arch?
18:52:12 <dcoutts> not amd64 is it?
18:52:16 <mikehammad> i'm on ~amd64
18:52:16 <mikehammad> haha
18:52:23 <mikehammad> that's always my problem
18:52:30 <dcoutts> probably
18:52:45 <dcoutts> TH is related to ghci which also doen't work
18:52:52 <mikehammad> doh
18:53:06 <Beelsebob> :(
18:53:06 <mikehammad> any idea why?
18:53:08 <dcoutts> we hope it'll all be working on amd64 in ghc-6.4.1
18:53:15 <Beelsebob> that'll be why it was fine on my P4
18:53:32 <dcoutts> mikehammad, just not implemented yet for amd64 by the time ghc 6.4 was released
18:53:48 <MarcWeber> dons: CWString.hsc:69: error: `GHC' undeclared (first use in this function) (this error occurs when using darcs version)
18:53:49 <mikehammad> it's not a big deal, i have 32-bit chroot
18:54:21 <lispy__> MarcWeber: that error occurs at run time?
18:54:28 <MarcWeber> At compile time
18:54:34 <lispy__> MarcWeber: compiling Yi
18:54:43 <lispy__> MarcWeber: or one of the dependencies?
18:54:47 <MarcWeber> Yi
18:54:53 <MarcWeber> darcs version
18:55:15 <lispy__> MarcWeber: hmm....what is your gcc version? (Not sure if Yi needs gcc)
18:55:42 <MarcWeber> The latest source..tar.gz version is no problem..
18:55:42 <lispy__> MarcWeber: and what is the version of hsc2hs?
18:55:52 <lispy__> oh, hmm....
18:55:56 <MarcWeber> gcc version 3.3.5-20050130 (Gentoo 3.3.5.20050130-r1, ssp-3.3.5.20050130-1, pie-8.7.7.1)
18:56:01 <lispy__> let me do a darcs update and see if i get that error
18:56:02 <dons> hmm
18:56:12 <MarcWeber> hsc2hs version 0.65
18:56:27 <MarcWeber>  darcs get --partial --set-scripts-executable http://www.cse.unsw.edu.au/~dons/yi
18:56:53 <mikehammad> can someone tell me the url for pantheon?
18:57:44 <lispy__> MarcWeber: building it now....we should know in a second
18:58:20 <MarcWeber> dons: Do you know wether it's possible to catch the key combination <Ctrl-Shift-Upper K>?
18:58:27 <lispy__> MarcWeber: can you upgrade hsc2hs, I have version 0.66 and the compile seems to be fine
18:59:02 <lispy__> MarcWeber: is upper a modifier key?
18:59:44 <lispy__> if not, then wouldn't that be the same as <Ctrl-Shift K> ?
18:59:58 <MarcWeber> It's to late .. No just shift or upper, but not both ;(
18:59:58 <lispy__> and Ctrl+shift+k shouldn't be a problem
19:00:05 <MarcWeber> vi Can't do that.
19:01:13 <MarcWeber> I'm adding lines to portage.keywords all the time ;)
19:01:16 <lispy__> MarcWeber: look in Yi/Keymap/Vi.hs maybe there is an example of code for doing that :)
19:01:30 <MarcWeber> Wow!
19:02:35 <lispy__> MarcWeber: well, i was able to build Yi, not a single errro
19:02:48 <lispy__> so i guess upgrade hsc2hs and try again
19:11:02 <Pseudonym> Back.
19:11:43 <dons> MarcWeber, problems solved?
19:12:29 <lispy__> dons: i just realized that :$ isn't implemented
19:13:13 <dons> last line of file?
19:13:21 <dons> that's easy enough
19:13:30 * dons hacks
19:14:22 <lispy__> dons: cool, thanks
19:14:30 <lispy__> i tihnk Marc fell asleep :)
19:16:21 <MarcWeber> No. ghci-bin-6.4 is blocking hs-plugins.. :*(
19:17:05 <lispy__> MarcWeber: blocking it in what way?  your package manager doesn't want to do it?
19:17:16 <MarcWeber> Yes.
19:20:32 <dons> :$ done
19:24:46 <dons> maybe grab hs-plugins from darcs and install it locally?
19:25:30 <Beelsebob> yeh, I had trouble using portage to get hs-plugins
19:25:47 <Beelsebob> it built first time from source packages though
19:26:05 * Igloo times dons at 7 mins per command. Now if someone could just count the number fo commands vim has we can work out how long until we have a complete replacement  :-)
19:26:28 <Beelsebob> haha
19:26:53 * Beelsebob doesn't like his editor to be an OS
19:27:11 <Beelsebob> but that's a battle that's been fought many times and isn't worth fighting the first time even
19:27:56 <Pseudonym> Everyone knows that Perl is a better OS than Emacs.
19:28:12 <Beelsebob> heh
19:28:27 * Beelsebob just gets on and uses SubEthaEdit
19:28:53 <ezra_> hip hip SubEthaEdit
19:29:06 <Beelsebob> ???
19:29:12 <ezra_> hurray
19:29:17 <Beelsebob> I see?
19:29:19 <Beelsebob> :/
19:29:27 <Beelsebob> you a user?
19:29:31 <lispy__> Beelsebob: hopefully, with Yi you won't have to have an OS unless you want to be running those plugins
19:29:31 <ezra_> i love SubEthaEdit, yeah
19:29:40 <dons> oh, I actually wandered off half way though there.
19:29:42 <Beelsebob> :) cool
19:29:44 <dons> so more like 3 mins :}
19:29:51 <Beelsebob> using my syntax highlighter? *g*
19:30:00 <lispy__> that's quick,i'm going to have to grab a newer version now :)
19:30:09 <ezra_> i haven't been doing haskell in s.e.e.
19:30:12 <Beelsebob> ... that still needs to be fixed to put data structures in the menu
19:32:34 * Beelsebob goes to bed
19:37:49 <Pseudonym> Oh dear.
19:37:55 <Pseudonym> http://www.monzy.com/intro/drama_lyrics.html
19:38:05 <Pseudonym> The frightening thing is pretty much anyone here would get most of the references.
19:38:50 <lispy__> MarcWeber: if you want an example of a haskell program written by someone relatively new to haskell, you can check out the procmail program i wrote: http://www.codersbase.com/Autoproc
19:39:06 <lispy__> it may also be handy if you use procmail :)
19:44:41 <MarcWeber> Perhaps give an example on the website
19:45:34 <MarcWeber> Now it worked (compiling yi from darcs..)
19:47:29 <lispy__> MarcWeber: oh, i should give an example autoproc program and the corresponding procmail?  yeah, that's a good idea
19:47:38 <dons> MacrWeber, an example on the Yi website?
19:47:47 <MarcWeber> Or just link to Rules.hs :)
19:47:54 <lispy__> true
19:47:59 <dons> oh, procmail
19:48:02 <lispy__> i need to fix up the language
19:48:24 <MarcWeber> lispy__: What the hell is that at the end subject "1" .||. subject "2"..?
19:48:45 <lispy__> MarcWeber: test cases, to make sure i generate code correctly
19:49:08 <MarcWeber> and rules' = sarah' ++ nwn' ? Do you think I want to add the rules at different places ? ;)
19:49:31 <wagle> nwn?
19:49:48 <lispy__> MarcWeber: you probably don't want to use everything in there ;)
19:49:56 <MarcWeber> wagle: Get autoproc and see Rules.hs
19:50:07 <lispy__> wagle: never winter nights, it filtered emails from my buddies about playing the game :)
19:50:36 <MarcWeber> lispy__: IMHO: I don't want to write a name of a rule more often then necessary.. ;)
19:50:44 <lispy__> MarcWeber:  i should put together a tutorial, that Rules.hs files shows pretty much everything you can do, twice :)
19:51:02 <lispy__> MarcWeber: ya, that's one of the brain dead problems with my language, i'm open to suggestions
19:51:24 <wagle> lispy__: where do you play?
19:52:03 <lispy__> wagle: we haven't in about a year :)
19:52:04 <MarcWeber> I don't know yet what <filter>' means.. but you already have the list generated at the beginning rules= [spamc, ... So why not use fold?
19:52:09 <lispy__> wagle: but corvallis is where we used to play
19:52:21 <wagle> ah..  LAN, not WAN
19:52:25 <lispy__> MarcWeber: which line?
19:52:34 <lispy__> wagle: ya, we never really thought about doing it WAN
19:53:04 <MarcWeber> lines 24 and 204
19:53:04 <lispy__> MarcWeber: OH
19:53:16 <lispy__> MarcWeber: that's because i have everything in there defined twice, to show two different ways to do it
19:53:21 <wagle> a lot of servers out there
19:53:26 <lispy__> i forget at the moment what the difference was....hang on
19:54:06 <lispy__> MarcWeber: BTW, that website is a wiki so feel free to edit it if you think it's confusing :)
19:54:11 <lispy__> or send me patches with darcs
19:54:53 <lispy__> MarcWeber: oh, i remember now, classifiers are a different approach to the underlying mechanism for sorting
19:55:15 <MarcWeber> lispy__: I sort my mails by the ^TO field (mailinglists / inbox/ some friends .. that's all so I'm not sure wether I want to learn another configuration.. and I think there are still other programs to sort mail, have you checked thosse?)
19:55:18 <lispy__> MarcWeber: consider them experimental, one problem with using them is that they have to modify the email (they add custom headers)
19:55:42 <MarcWeber> uh? Don't want any script to do that ;)
19:55:51 <lispy__> MarcWeber: if you sort of ^TO then it's really easy to write rules
19:56:06 <MarcWeber> lispy__: Then I don't need them :)
19:56:14 <lispy__> MarcWeber: if you don't like your email to be modified use the top set of rules
19:56:26 <MarcWeber> lispy__: Can you tell me how to call darcs to update your folder and not create a new one?
19:56:40 <lispy__> MarcWeber: i mean, it's easy to write autoproc rules, you can use the simpleFoo sorting functions
19:56:49 <lispy__> MarcWeber: darcs pull
19:57:29 <MarcWeber> lispy__: What can be easier than copy 3 lines and paste them and change two words? ;)
19:57:44 <lispy__> for example, rogan = sortByFrom (Addr "creswick") (mailbox "rogan") just takes mail from creswick and puts it in the rogan folder :)
19:58:06 <lispy__> MarcWeber: well, the idea behind autoproc syntax is that it's less error prone
19:58:19 <MarcWeber> What does "sort" mean?
19:58:32 <MarcWeber> Ah.. Ok. .sort  where I want..
19:58:49 <lispy__> yeah, it places the email into a particular folder
19:58:50 <MarcWeber> I had the picture of sorting alphabetically in mind.
20:00:11 <lispy__> one thing to remember is that it's procmail that will do the sorting, not the haskell program you're writing
20:01:05 <lispy__> so you still have to setup procmail ;)
20:01:15 <metaperl> I have a question about short-circuiting in list comprehensions here: http://scannedinavian.org/repos/craft-of-fp/ex/ex7.hs   -- i'd appreciate some feedback on it
20:01:43 <lispy__> MarcWeber: after explaining some of the short comings i can see why no one has been excited about autoproc :)
20:03:07 <MarcWeber> lispy__: The first file you look at is Rules.hs and its 242 lines long! So everyone will ask: Is this better then my know .procmailrc? It would be better to provide some small alternative Rules.hs fles
20:03:33 <lispy__> oka
20:03:43 <lispy__> yeah, that's all of my rules twice :)
20:03:56 <MarcWeber> Will be back in some min
20:05:57 <metaperl> I have a question about short-circuiting in list comprehensions here: http://scannedinavian.org/repos/craft-of-fp/ex/ex7.hs   -- i'd appreciate some feedback on it
20:06:17 <lispy__> MarcWeber: BTW, the reason for classifiers is that they allow you to apply all of your checks/tests and then sort the emails based on their results, so you can do it out of order or whatever
20:18:45 <liyang> metaperl: it looks rather sparse...
20:19:27 <lispy__> MarcWeber thanks for the input, i'll try to make notes on the wiki
20:37:09 <MarcWeber> dons: What does this errror mean?
20:37:12 <MarcWeber> Rebuilding dependencies... Yi/Core.hs: can't locate import `Data.Map'
20:40:24 <dons> hmm. you're using ghc 6.2.2?
20:40:40 <dons> or you switched between 6.4 and 6.2.2 without running configure again?
20:41:21 <dons> I have a suspicion that yi in darcs depends on ghc 6.4 at the moment
20:41:27 <dons> (for silly reasons)
20:41:59 <lispy__> being compatible with old software is a nice bonus, but i don't think it's a healthy thing to strive for
20:42:12 <MarcWeber> How to remove the files produced by configure?
20:42:23 <MarcWeber> I run it at least twice to make sure..
20:42:27 <dons> make clean
20:42:33 <dons> make distclean might be better
20:42:50 <lispy__> you may also need to add FAST=y
20:42:52 <dons> lispy__, well Yi should work with 6.2.2, but i only check for sure prior to a release
20:43:01 <MarcWeber> I get the same error?
20:43:04 <dons> ah, yep, lispy__'s right.
20:44:13 <dons> foldM is my new favourite function
20:44:16 <MarcWeber> Now this command :
20:44:18 <MarcWeber> make distclean FAST=y; ./configure; make
20:44:22 <MarcWeber> results in
20:44:24 <lispy__> dons: i think i've had to add that every time on my machine
20:44:42 <lispy__> @hoogle foldM
20:44:43 <lambdabot> Monad.foldM :: Monad a => ((b -> c -> (a b)) -> b -> [c] -> (a b))
20:45:50 <lispy__> @eval foldM (:) 1 [2..3]
20:45:52 <lambdabot> <Plugins.Eval>:1:
20:45:52 <lambdabot>   No instances for (Num [a], Enum [a])
20:45:52 <lambdabot>   arising from the literal `3'
20:45:55 <Enveigler> Aren't those brackets unbalanced?
20:46:19 <dons> lookks ook to me.
20:46:47 <lispy__> what was wrong with the code i tried to eval
20:46:52 <lispy__> @type (:)
20:46:53 <lambdabot> forall a. a -> [a] -> [a]
20:47:01 <Enveigler> Hmm. Must be my eyes. Time to try fpr sleep I think.
20:47:48 <lispy__> @eval foldM (:) 1 [[2..3]]
20:47:49 <lambdabot> [1,2,3]
20:48:15 <lispy__> so what is a realistic use of foldM?
20:51:48 <dons> folding a monadic action over a set of values, with a start argument
20:52:14 <dons> >foldM f a1 [x1, x2, ..., xm ]
20:52:15 <dons> ==
20:52:15 <dons> >	do
20:52:15 <dons> >	  a2 <- f a1 x1
20:52:15 <dons> >	  a3 <- f a2 x2
20:52:17 <dons> >	  ...
20:52:19 <dons> >	  f am xm
20:52:38 <dons> like fold, but you thread state
20:52:49 <lispy__> OH
20:52:50 <lispy__> nice
20:52:57 <lispy__> i need to learn how to use it
20:54:08 <MarcWeber> Can you run the risk of using to much lambda functions and therefor defining some functions more the once and generate to much code?
20:55:13 <Korollary> you're asking if the optimizer's folding of constants applies to pure functions as well ?
20:56:20 <MarcWeber> No.. I've read some parts of a tuturial.. It seems that it's common to use lines like this: List.SortBy (flip compare) mylist
20:57:01 <MarcWeber> And if you use this sort functions more then once you run the risk of definining it every time again and again..
20:57:13 <MarcWeber> and I don't know wether the ghc will notice that.
20:58:16 <MarcWeber> Using C++ you can decide wether you want to use inline functions.
20:58:40 <Korollary> (flip compare) is a constant, too. That's what I meant.
21:08:32 <joelk> lispy__: Ask for a practical use of foldM, get:
21:08:32 <joelk> @plugs let fac = head . foldM ((return .) . (*)) 1 . enumFromTo 2 :: (Num a, Enum a) => a -> a in map fac [1..5]
21:08:32 <joelk> :-)
21:08:34 <lambdabot> [1,2,6,24,120]
21:09:06 <lispy__> nice
21:09:48 <joelk> that would be some sort of mutant on the "evolution of a haskell programmer" track!
21:10:01 <MarcWeber> dons: I've reinstalled the folder containing the darcs repository.. Still the same error (GHC undeclared).. I'll have a look at the old code, first ;)
21:10:40 <dons> this happens when you type `make' ?
21:11:33 <MarcWeber> this happens after chmod +x configure; ./configure; make
21:11:50 <dons> any other output?
21:19:00 <metaperl> liyang: i was playing a game when you responded to me... did you comment on my short-circuiting question?
21:21:07 <liyang> metaperl: is that really supposed to read (x_) -> x on the last line?
21:21:21 <metaperl> let me see
21:21:30 <metaperl> yes, it returns the first digit in the list
21:21:45 <liyang> (and where can I find the defn of digits...?)
21:21:57 <liyang> Surely, it should say (x : _) -> x then?
21:22:00 <metaperl> liyang: it just returns all the digits from a string using isDigit
21:22:14 <metaperl> oh
21:22:32 <liyang> (and how is str passed to the digits function?)
21:23:10 <metaperl> oh
21:23:16 <metaperl> let me darcs push it
21:24:18 <liyang> By the looks of it, list generation will be short circuited as soon as the first digit comes out. But that depends on the definition of digits... I think.
21:27:16 <metaperl> liyang: ok, the darcs version is up: http://scannedinavian.org/~metaperl/haskell/craft-of-fp/ex/ex7.hs
21:28:04 <metaperl> digits is just a list comprehension:  [c |  c <- str , isDigit c]
21:28:16 <metaperl> digits is just a list comprehension: digits str =  [c |  c <- str , isDigit c]
21:29:48 <hyrax42> is that book recommended?
21:29:51 <hyrax42> my library doesn't have it
21:30:10 <hyrax42> or let's break to active: would you recommend that book?
21:30:59 <liyang> *nod* Yup. Looks list generation will be short circuited. (I mean, it'd be shorted for any definition of digits anyway; what I was thinking of earlier was whether it'd require an entire scan through the input string. Which depends on how digits is defined.)
21:31:16 <liyang> Gah. 05:30. Off to bed.
21:31:20 <liyang> Night night...
21:31:25 <metaperl> liyang: goodnight thanks
21:35:39 <luqui> is there a way that I can get a haskellbot for offline use?
21:35:50 <luqui> or just that one feature that I can't remember that will refactor your functions
21:35:54 <shapr> You mean a lambdabot instance?
21:36:04 <Pseudonym> G'day shapr.
21:36:10 <shapr> g'day Pseudonym, how's code?
21:36:11 <luqui> in the form of a command line program or something?
21:36:15 <Pseudonym> Not bad, not bad.
21:36:15 <mwc_> shapr: you got night yet?
21:36:25 <Pseudonym> More to the point, I actually have a TMR article in the works.
21:36:29 <ski> good morning #haskell
21:36:31 <shapr> mwc_: A little bit, though I'm still having trouble sleeping.
21:36:35 <shapr> Pseudonym: excellent!
21:36:37 <ski> hi shapr
21:36:55 <mwc_> shapr: I know what you mean; I'm having some sort of chronic fatigue syndrome now
21:37:18 <mwc_> I fall asleep after eating a meal; I have to sleep in the middle of the afternoon
21:37:24 <shapr> luqui: you could run a local irc daemon, or you could integrate most of the lambdabot plugins into ghci or something.
21:37:34 * ski slept all of yesterday
21:37:54 <shapr> mwc_: I have the opposite problem sadly. I slept from midnight to 2:30am and I have been unable to get back to sleep.
21:38:05 <luqui> anyway, what's the thing that will "dump" a function for you in its most concise form?
21:38:08 <mwc_> I'm hacking together a quantum computer simulator in Haskell
21:38:21 <mwc_> I've christened her "Haqus"
21:38:27 <mwc_> er, "Hoqus"
21:38:28 <shapr> I rested quietly for four hours with earplugs and a black cloth over my eyes, still can't sleep.
21:38:32 <ski> @pl \f g x y -> f (g x y)
21:38:32 <lambdabot> (.) . (.)
21:38:40 <mwc_> shapr: try that with some melatonin
21:38:41 <shapr> mwc_: I assume the successor will be Poqus?
21:38:48 <metaperl> shapr: ever tried a brainwave generator?
21:38:49 <Pseudonym> Actually, what would be useful is a quantum computing monad.
21:38:54 <mwc_> shapr: hah, if I recode it in Prolog :P
21:39:09 <luqui> mmkay, is there a module that does that?
21:39:11 <metaperl> if you have windows there is a free one... otherwise a hemi-sync cd should put you to sleep
21:39:19 <mwc_> Pseudonym: yeah, you could hook up an NMR QC via USB
21:39:19 <Pseudonym> With each parallel "universe" obeying Bose-Einstein or Fermi-Dirac statistics.
21:39:59 <Pseudonym> Imagine a nondeterminism monad where each nondeterministic choice had amplitudes.
21:40:07 <mwc_> woah
21:40:26 <mwc_> so instead of a monad encoding a state; it encodes a superposition of states
21:40:33 <Pseudonym> Right.
21:40:46 <mwc_> but if you take the value of the monad, do you only get one value?
21:40:55 <Pseudonym> Then we can port GHC to a laser-cooled Caesium ion array.
21:41:10 <Pseudonym> That's a good question.
21:41:23 <Pseudonym> Presumably you do if you call the observe method, yes.,
21:41:24 <mwc_> after my research; I'd say I'm partial to the NMR implementations
21:41:56 <mwc_> "Sorry professor; I observed the parser monad and it decohered."
21:42:06 <Pseudonym> :-)
21:42:14 <Pseudonym> However, since Haskell is lazy, that might not be so bad.
21:42:20 <Pseudonym> And pure.
21:42:58 <Pseudonym> Unfortunately, if you write a quantum monad _transformer_, every "lift" operation would collapse the state.
21:43:12 <mwc_> I stand by my choice of haskell "A lazy language for a lazy student."
21:43:17 <Pseudonym> So maybe it's not so useful.
21:44:20 <ski> hm, why'd lift collapse ?
21:44:38 <mwc_> its not so much that it would collapse
21:45:08 <mwc_> but the interaction would cause the systems to entangle
21:45:30 * mwc_ diggs the Morgan-Everett Many Worlds Hypothesis
21:46:12 <mwc_> question; what would #haskell recommend for a structure for storing complex values for a sparsely populated space over Int
21:46:18 <mwc_> I'm thinking Data.Map
21:46:47 <sh10151> complex values meaning complex numbers?
21:46:49 <lispy__> what is a complex value?
21:47:19 <dons> IntMap ?
21:47:23 <mwc_> but at the same time I wonder if it wouldn't be more efficient to implement my own structure over [(Int,Complex)]
21:47:47 <lispy__> if this were any other language i would say use a hash table
21:47:58 <lispy__> but that's because it's nice easy to use thing
21:48:03 <mwc_> you think?
21:48:23 <dons> Data.IntMap: An efficient implementation of maps from integer keys to values.
21:48:23 <mwc_> I was going to encode the computational basis vectors into Ints (or maybe Integer)
21:48:42 <lispy__> well, i'd go with easy to use over efficient, at least until you have evidence that it's not efficient
21:48:51 <mwc_> dons: sounds like what I'm looking for; just looking into it
21:48:58 <ski> mwc_ : what's 'Morgan-Everett Many Worlds Hypothesis' ?
21:48:59 <lispy__> oh, well use Data.IntMap, that sounds great
21:49:04 <dons> "(much) faster on insertions and deletions when compared to a generic .. Data.Map"
21:49:14 <mwc_> dons: sounds like what I'm looking for
21:49:52 <mikehammad> can anyone here help me with template haskell?
21:50:35 <mwc_> ski: wikipedia has a good article on it; the jist of it is that you have parallel universes corresponding to each possible measurement
21:51:26 <mwc_> and then every measurement causes an interaction of the systems that "selects" on of the outcome universes; or rather; that the systems continue to evolve independently in parallel universes
21:52:35 <metaperl> mikehammad: I cant help with TH, but there was a Monad Reader article on it (issue 2 i believe)
21:53:05 <metaperl> the TH author (Igloo) is here... he might be afk now though
21:53:07 <ski> mwc : so it's just 'many worlds interpretation/hypothesis' ?
21:53:10 <metaperl> @seen Igloo
21:53:12 <lambdabot> Igloo is in #haskell. Last spoke 2 hours, 27 minutes and 5 seconds
21:53:12 <lambdabot> ago.
21:53:12 <mwc> ski: yeah
21:53:41 <mikehammad> ok i might check back later then
21:53:44 <mikehammad> thans!
21:54:21 * ski has a idea about superposition being related to 'with' in linear logic ..
21:54:34 <mwc> linear logic?
21:54:38 <ski> yes
21:54:46 * lispy__ pulls up a chair
21:54:52 <mwc> never heard of it; I'm just a poor dumb applied mathematician
21:54:52 <ski> invented by Jean-Yves Girard
21:55:03 <mwc> that name sounds familiar
21:55:06 <mwc> what else has he done?
21:55:42 <ski> hm, iirc he did stuff with System F
21:56:58 <metaperl> can anyone think of a primitive recursive function to find the unique members of a list?
21:57:20 <ski> anyway, in linear logic, the usual connectives split into two, each
21:58:26 <mwc> metaperl: only if its a sorted list
21:58:35 <ski> 'with' (aka 'additive conjunction') represents two possibilities in which both are potentially true, but not (necessarily) at the same time. you have to *choose* which one you want.  e.g. "do you want tea or coffee"
21:59:02 <metaperl> there is a perl module called Quantum::Superpositions that does what you seem to be talking about
21:59:19 <ski> mwc : wanna know some more ?
21:59:32 <mwc> sure, #physics maybe
22:00:11 <Pseudonym> Yeah, I was at the conference where Damian presented that paper.
22:00:34 <Pseudonym> The thing is, it's not actually quantum computing, and I told him so.
22:00:47 <Pseudonym> He had an "all" operator, which you can't do in quantum mechanics.
22:02:16 <metaperl> i see
22:02:35 <Pseudonym> Well you can't visit all alternate universes and see what's happening there.
22:02:40 <luqui> actually, there is a perl module called Quantum::Entanglement that does what you seem to be talking about
22:02:42 <mwc> metaperl: if you have the luxury of a sorted list, there's: unique (x1:x2:xs) | x1 == x2 = unique x1:xs | otherwise = x1 : unique x2 : xs
22:02:48 <mwc> with the obvious base base
22:02:59 <luqui> Quantum::Superpositions is just a programming convenience; Entanglement is more like actual simulation
22:02:59 <liyang> Quantum::Superpositions does pretty much what the List monad does. ;)
22:03:09 <Pseudonym> Right.
22:03:37 <Pseudonym> Except that in addition, Quantum::Superpositions doesn't have amplitudes.
22:03:43 * liyang went to Damian's talk on it at an Belfast Perlmongers meeting too. XD
22:04:13 * Pseudonym used to work at Monash, where Damian... probably still works
22:04:22 <liyang> I see. :)
22:04:42 <liyang> (Now really. I should be in bed. >.<;;)
22:05:03 <metaperl> Damian just put out a book: "Perl Best Practices"
22:05:10 <metaperl> unique xs = map head $ filter (\xs -> length xs == 1) $ (group . sort) xs -- my solution
22:05:31 <metaperl> but mwc's is really fresh
22:06:49 <liyang> @hoogle nub
22:06:50 <lambdabot> List.nub :: Eq a => ([a] -> [a])
22:06:50 <lambdabot> List.nubBy :: ((a -> a -> Bool) -> [a] -> [a])
22:07:27 <Korollary> for some reason the word "hoogle" cracks me up.
22:08:04 <liyang> metaperl: unique = nub . sort :)
22:08:21 <metaperl> liyang: you're supposed to be in bed :)
22:08:30 <metaperl> thanks for the input though :)
22:08:32 <liyang> D:
22:09:32 <metaperl> liyang: you dont have to sort it first
22:10:41 <Pseudonym> Unfortunately, it seems that "-oogle" to indicate a search engine seems to be the new "-gate" to indicate a scandal.
22:11:00 <Pseudonym> And it makes just about as much sense, too.
22:11:01 <liyang> Now why did I think nub only removed adjacent equal elements?
22:11:16 <Pseudonym> No idea.
22:11:21 <Pseudonym> There was something that did that once.
22:11:23 <Pseudonym> noDups, I think.
22:11:44 <metaperl> what's the lambdabot command to see the source of nub?
22:12:01 <metaperl> it pulls things from darcs.complete.org
22:34:41 <ski> @libsrc Data.List.nub
22:34:42 <lambdabot> Data.List.nub not available
22:34:44 <ski> bah
22:38:31 <Korollary> this is what the report says it "could" be
22:38:36 <Korollary> nub []           =  []
22:38:41 <Korollary> nub (x:xs)       =  x : nub (filter (\y -> not (x == y)) xs)
22:39:55 <luqui> is there any way to pattern match based on the return type of a function argument?
22:40:12 <shapr> y0 tobehz, wassup?
22:40:15 <tobehz> hi
22:40:25 <shapr> Are you learning Haskell?
22:40:40 <Korollary> luqui: I don't understand your question.
22:40:41 <ski> luqui : in what way, do you mean ?
22:40:47 <tobehz> dunno, I don't even know what 'functional' programming is. so I have to read up.
22:40:50 <luqui> so  foo :: (a -> Bool) -> b  is different from foo :: (a -> b) -> c
22:41:11 <shapr> tobehz: Do you want urls to descriptive documents and such?
22:41:13 <luqui> If you pass me a function that returns a Bool, I do something different than if you pass me any other kind of function
22:41:25 <tobehz> I guess that would be nice. :]
22:41:46 * luqui begins to question whether that's computationally possible...
22:41:51 <Korollary> luqui: haskell is statically typed. You absolutely know what kind of function you are passed in.
22:42:01 <luqui> yeah
22:42:16 <luqui> so I'm trying to do something different based on that function's return type
22:42:16 <shapr> tobehz: Ok, what about these - http://en.wikipedia.org/wiki/Functional_programming http://www.md.chalmers.se/~rjmh/Papers/whyfp.html http://www.haskell.org/hawiki/HaskellDemo
22:42:37 <luqui> ...
22:42:45 <luqui> hmm, I wonder if I'm just looking at the problem all wrong
22:42:51 <shapr> tobehz: Alternatively, I can give you my anecdotal description of the differences.
22:42:59 <Korollary> luqui: if it's short, why not state what you are trying to do.
22:43:00 * kaol thinks that the alternative to functional is broken
22:43:15 <luqui> I'm making a junction monad
22:43:21 <palomer> hello, can anyone recommend any papers contrasting and comparing call by name and call by value (apart from plotkin's paper)
22:43:25 <luqui> a <- any [1,2,3]
22:43:59 <luqui> if a < 2 then something else something -- tries to match the conditional if possible
22:44:16 <luqui> it's like the list monad, but um... hmm
22:44:19 <luqui> I wonder how it's different
22:44:54 <luqui> ahh yes, the all combinator
22:45:02 <luqui> a <- all [1,2,3]
22:45:06 <luqui> a < 2  -- false
22:45:09 * Korollary has just got his copy of TaPL
22:45:12 <luqui> b <- any [1,2,3]
22:45:15 <luqui> b < 2 -- true
22:47:22 <tobehz> sapr: I'd like your anecdotal description. I don't understand how you can program if there is no order of execution, isn't that required to making your program do what it is suppose to do? O_o
22:47:26 <Korollary> palomer: are you trying to learn about the definitions, or are you beyond that ?
22:47:26 <tobehz> shapr*
22:48:10 <luqui> geez... I can't figure how I would make:
22:48:13 <luqui> b <- any [1,2,3]
22:48:18 <luqui> b > 5  -- false
22:48:20 <luqui> work at all
22:48:32 <luqui> I can only think of how to make it not execute the rest
22:49:00 <palomer> Korollary, the formal definitions would be nice
22:49:12 <Korollary> palomer: let me see if I can dig up a link for you
22:49:19 <palomer> Korollary, give me everything you've got! (I'll print it all out while im still in school)
22:51:29 <palomer> Korollary, cbv and cbn seem like reduction strategies right now
22:52:49 <Korollary> they are
22:53:46 <palomer> or, they could be a set of axioms
22:53:55 <palomer> in which case even if 2 terms have the same normal forms, they may not be equivalent!
22:54:04 <palomer> they're which?
22:54:20 <Korollary> palomer: http://www.cs.uiowa.edu/~slonnegr/plf/
22:54:28 <Korollary> It's in chapter 5
22:57:18 <palomer> can they also be regarded as a set of axioms, such that 2 terms are equal if they reduce to the same term?
22:57:30 <Korollary> tobehz: You don't *always* have to specify the execution order. Once you learn more about FP, you'll realize how the compiler can take care of it for you.
22:59:09 <tobehz> well, functional programming is kind of like math, right?
22:59:17 <tobehz> (atleast that's what I understoof for the wikipedia link)
22:59:21 <tobehz> understood*
22:59:29 <Korollary> tobehz: all programming is like math. a la turing machines.
22:59:38 <tobehz> ok so
22:59:48 <tobehz> math is pretty much procedural, right?
23:00:04 <hyrax42> not really
23:00:05 <hyrax42> I think
23:00:09 <tobehz> you find x, you find y, then you plug them in, and get your answer, you need to do some things before others
23:00:28 <Korollary> palomer: They are not axioms. You have a choice to evaluate one of them before the other. It's arbitrary.
23:00:42 <Pseudonym> There's a school of thought that maths should be constructive.
23:00:55 <hyrax42> I like my squre roots
23:00:55 <hyrax42> thanks
23:01:07 <tobehz> or does the compiler rearrange code for you, so that your program executes as intended, without requiring the actual line of execution to be correct?
23:01:07 <Korollary> tobehz: If there's a dependency, in haskell the compiler will take care of it for you. You don't have to explicity order the computations.
23:01:08 <Pseudonym> Proofs of existence which of something which don't actually construct that something seem a little weird to such people.
23:01:15 <tobehz> ohh, I see.
23:01:29 <Korollary> Pseudonym: weaselwords again ?
23:02:18 <Korollary> I am splitting infinitives. Why...
23:02:31 <palomer> Korollary, do they have completely formal definitions?
23:02:37 <tobehz> so functional programming is like thoughtful programming? you could put in a formula, try to compile, realize you forgot the variable you needed, add it to the end, and recompile, and it would order it to execute properly so that the expression got the variable you added?
23:02:46 <tobehz> (a little drawn out, but hopefully you get the point)
23:02:50 <Korollary> palomer: that's as formal as it gets imho
23:04:42 <Korollary> tobehz: you don't need to recompile. why not an example: "let {a=c; b=a; c=2} in b" will give you 2. You don't need to worry about the order of "a=c" versus "c=2".
23:05:26 <palomer> there's no formal mathematical definition? like "a category is a set of objects and a set of arrows such that" or "a group is a set with an operation" or "a function A->B is a subset of ..." ?
23:05:51 <Korollary> palomer: heh you said the magic word. I'd have to refer you to Pseudonym...
23:06:11 <tobehz> Korollary: I see.
23:07:04 <Korollary> palomer: That entire chapter is a pretty formal mathematical definition of lambda calculus, tho, so I don't know what it lacks for you.
23:08:33 <palomer> erm, I know what the language of lambda calculus is
23:08:51 <palomer> it seems that cbn and cbv are both sets of axioms
23:09:09 <palomer> like M
23:09:26 <palomer> M -> M' implies M N -> M N'
23:10:24 <palomer> err
23:10:24 <palomer> M -> M' implies M N -> M' N
23:10:33 <Korollary> Umm, my (probably incorrect) understanding makes me think of them as rules of inference instead.
23:10:53 <Pseudonym> Korollary: That's not a weasel word.  That's just jargon.
23:11:23 <Pseudonym> One of the nice things about category theory is that pretty much all proofs are constructive.
23:11:32 <Pseudonym> Proving the existence of something results in an algorithm to make it.
23:11:52 <palomer> sure, rules of inference and axioms are practically equivalent
23:11:53 <Korollary> interesting
23:13:12 <palomer> to make the category?
23:13:15 <Korollary> I am just hooked on weaselwords.
23:13:21 <palomer> constructions from intuitionistic proofs isn't as easy as you think. in fact, we can only do it for silly theorems
23:13:29 <musasabi> morning
23:13:50 <palomer> well, maybe not too silly
23:16:04 <palomer> so, erm, anyone have the rules of inference of cbn and cbv?
23:17:27 <tobehz> Korollary: thanks for your little example. maybe this weekend I will try to write a little haskell program, assuming I'm not still inundated with work :(
23:20:23 <Korollary> palomer: I have one more pdf for you
23:20:51 <palomer> oh, cool
23:22:28 <Korollary> This seems to have proofs
23:22:30 <Korollary> http://scholar.google.com/url?sa=U&q=http://www.cs.ru.nl/~erikb/onderwijs/T3/materiaal/lambda.pdf
23:22:56 <Korollary> page 30 has normal form vs applicative
23:25:12 <palomer> yes yes, I know this theorem
23:25:43 <palomer> I've actually seen a novel proof of this
23:25:52 <palomer> it's the lack of formality of cbn and cbv which bothers me
23:25:52 <palomer> so noone has the inference rules?
23:29:10 <palomer> getting late
23:29:10 <palomer> I'm off
23:29:10 <palomer> night!
23:29:17 <ski> m, night
