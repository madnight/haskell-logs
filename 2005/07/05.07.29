00:06:14 <palomer> hrm
00:07:19 <palomer> if t is a term of type A, what type is CPS[[A]] using a smart CPS which doesn't keep administrative redexes?
00:12:15 <ski> palomer : same as the usual one, i think
00:35:29 <palomer> well, yes, the usual one works too, because of subject reduction
00:35:52 <palomer> hrm, are types stable under beta expansion?
00:37:15 <palomer> it's certainly not stable under alpha expansion
00:45:39 <ski> alpha expansion ?
00:46:30 <ski> eta expansion ??  alpha conversion ??
00:47:00 <vikasg> ski, alpha conversion ~= renaming a formal parameter
00:47:15 <ski> vikasg : indeed
00:47:31 <ski> hi palomer`
00:47:36 <palomer`> hullo
00:47:50 <palomer`> would anyone happen to know what the cps transform of call/cc is?
00:47:59 <ski> <ski> alpha expansion ?
00:48:03 <ski> <ski> eta expansion ??  alpha conversion ??
00:48:59 <palomer`> alpha expansion: t -> \x. t x
00:49:13 <palomer`> errr, thats eta expansion
00:49:15 <ski> that's eta expansion
00:49:19 <ski> yep
00:49:24 <palomer`> there is no alpha expansion:O
00:49:40 <vikasg> palomer, do you mean (define (call/cc f k) (f k)) ?
00:49:44 <ski> cbv_CPS[[call/cc]] = \k0. k0 (\f. \k1. f (\x. \k2. k1 x) k0)    iirc
00:49:58 <palomer`> oh my
00:50:01 <palomer`> and call by name?
00:50:29 <ski> hm, lets see if i recall ..
00:52:28 <palomer`> you bind k2 but never use it
00:52:38 <ski> indeed
00:52:50 <ski> hm
00:53:02 <palomer`> you wouldnt happen to have a url, would you? (i dont trust my recopying)
00:53:05 <ski> cbv_CPS[[call/cc]] = \k0. k0 (\f. \k1. f (\x. \k2. k1 x) k1)
00:53:12 <ski> should be
00:53:23 <palomer`> again, you dont use k2!
00:53:30 * ski 's taking it from memory
00:53:34 <ski> indeed
00:53:38 <ski> that is by design
00:55:58 <ski> hm, i reconstructed a cbn_CPS[[call/cc]] here, but i'm not sure it's correct
00:56:10 <ski> not as used to the cbn versions ..
00:56:45 <palomer`> you guys should add it to the haskell wiki
00:56:48 <palomer`> that would rock
00:57:17 <ski> palomer` : you seemed to think the cbv version was complicated .. you can get different degrees of it by doing different variants
00:58:26 <ski> e.g. cbv_CPS[[call/cc ef]] = \k0. cbv_CPS[[ef]] (\f. f (\x. \k1. k0 x) k0)
01:00:10 <ski> or cbv_CPS[[let/cc k in ea]] = \k. cbv_CPS[[ea]] k
01:00:43 <palomer`> are you sure of all of these?
01:00:50 <wilx> Huh, darcs-devel ml is oddly threaded.
01:01:18 <palomer`> im about to do some heavy duty lambda calculus deductions, and I need to be 100% sure these are right
01:01:27 <ski> or  cbv_CPS[[callcc ef]] = \k0. cbv_CPS[[ef]] (\f. f k0 k0)    cbv_CPS[[throw ek ex]] = \k0. cbv_CPS[[ek]] cbv_CPS[[ex]]
01:02:03 <ski> palomer` : i'm taking from mem, so to be sure i should go through them in detail first ..  and prolly look at some papers also :)
01:03:37 <ski> palomer` : i was more or less trying to show some of the possible variants
01:04:35 <palomer`> got any papers?
01:05:09 <ski> um, i was having the abstracting/representing control papers in mind, actually :)
01:06:44 * ski goes looking in them ..
01:07:18 <palomer`> given that: if x and y are variables, i want to show that if [[u x]] = [[y]] and [[t u]] = [[x]] then [[call/cc t]] = [[x]] where = is beta/eta equivalence
01:08:19 <palomer`> (is this even true?)
01:08:37 <palomer`> actually, i want to show it true for any x,y
01:09:23 <palomer`> [[]] can be either cbn or cbv CPS
01:11:40 <ski> hm, so u is essentially \x.y ?
01:12:19 <palomer`> why would it be?
01:12:33 <ski> hm
01:12:57 <ski> x and y are different vars, yes ?
01:13:03 <palomer`> yeah
01:13:18 <palomer`> i chose x and y to get the easiest case
01:14:26 <ski> so 'u x' seems to ignore 'x' and purely return 'y'  (if it not in some way still manages to be nonpure ..)
01:14:48 <ski> that seems to suggest u x = \_. y   methinks
01:15:08 <palomer`> u may contain call/cc
01:15:16 <ski> possibly
01:15:37 <ski> but, i'm not sure it may contain call/cc in any "malign" way ..
01:15:51 <ski> given that the result should be = [[y]]
01:15:55 <ski> which is pure
01:16:56 <palomer`> [[u x]] is pure anyways
01:17:39 <ski> yes
01:17:40 <palomer`> and [[\z.y]] = \k.k (\z.\c.c y)
01:17:50 <palomer`> which is not =y
01:17:51 <ski> m
01:18:40 <ski> why would it ?
01:18:54 <palomer`> by definition of [[]]
01:19:37 <ski> sorry, just wondered why you stated 'which is not =y'
01:19:40 <palomer`> but, you may disprove my statement by assuming u = \z.y
01:20:07 <palomer`> surely that term isnt alpha/beta/eta equivalent to y
01:20:31 <ski> agreed
01:20:51 * ski does not remember implying so
01:21:13 <palomer`> <ski> that seems to suggest u x = \_. y   methinks
01:21:31 <ski> urg
01:21:36 <ski> typo
01:21:41 <ski> indeed you are right
01:21:45 <ski> that is rubbish
01:21:49 <ski> should have been
01:22:01 <ski> ... suggest u = \_. y
01:22:07 <palomer`> oh, right
01:22:12 <palomer`> this is a solution
01:22:18 <palomer`> though not the only one
01:22:27 <ski> possibly not, anyway
01:24:20 <ski> so we have [[t u]] = [[x]], which seems to suggest that t does not use it's argument ..
01:24:48 <ski> if so, then surely [[call/cc t]] = [[x]] ..
01:26:03 <ski> so .. the 'seems to suggest' parts should be formalizable, in some way ..
01:26:14 <ski> palomer` : do you agree ?
01:26:34 <palomer`> why must [[call/cc t]] = [[x]]?
01:30:22 <ski> intuitively, the call/cc application passes the current continuation (possibly packaged up in some way) to t, and if t ignores it's argument and always returns x, surely it will return x here also ..
01:31:24 <ski> s/it's/its/
01:32:41 <palomer`> any idea how to do this formally?
01:32:42 <ulfdoz_> re
01:35:39 <ski> palomer` : hm, no .. never done much formal proofs with continuations .. :/
01:36:45 <palomer`> if i know that CPS[[t u]] is in {CLS[[a]]: a in X} for some set X, is there a term v such that v (t u) is always in X?
01:38:41 <palomer`> make that CPS[[t u]] is in closure{CPS[[a]]:a in X} where closure is the alpha/beta/eta closure, X is already closed
01:39:49 <ski> dunno
01:39:58 <palomer`> :O
01:40:01 * palomer` kills CPS
01:40:07 <palomer`> ski: got those urls?
01:40:17 <ski> (hm, can t depend on any of t,u,X ?)
01:40:48 <palomer`> nope
01:41:13 * ski looks puzzled at palomar`
01:41:17 <ski> which urls ?
01:41:27 <palomer`> for the CPS trasformations
01:41:29 <palomer`> the papers
01:41:32 <ski> bah s/can t/can v/
01:42:12 <palomer`> ski: nope
01:42:44 <ski> http://citeseer.ist.psu.edu/danvy92representing.html and http://citeseer.csail.mit.edu/danvy90abstracting.html ?
01:43:33 <palomer`> the ones on the haskell page..the second one doesnt
01:43:35 <palomer`> it i read it
01:43:37 <palomer`> very good
01:43:37 <ski> (palomer` : btw, those are the continuation papers i remember the titles of best :)
01:43:55 * ski thought he put both at the wiki ..
01:44:00 <palomer`> neither does the first
01:44:09 <palomer`> yeah, on the haskell wiki
01:44:25 <palomer`> oh wait, it might
01:44:36 <palomer`> but the file is borked
01:44:45 <ski> ?
01:45:24 <palomer`> http://citeseer.ist.psu.edu/danvy92representing.html
01:45:34 <palomer`> the ps file is borked
01:45:53 <ski> doesn't work at all ?
01:46:34 <palomer`> works
01:46:39 <palomer`> but i cant backtrack
01:46:41 <palomer`> opened the pdf
01:46:56 <palomer`> and doesnt mention call/cc
01:47:05 <palomer`> though it has other control operators
01:47:52 <ski> mentions 'escape' which is more or less the same thing, i think
01:47:53 <tuomov> what packages do I need to install on fedora to have working ghc?
01:47:58 <tuomov> the ghc64 package seems to be missing hsc2hs
02:25:25 <jyp> hello shapr
02:25:36 <shapr> hiya jyp
02:26:35 <jyp> It will soon be time to check Yi again :)
02:26:45 <dons> hey jyp
02:27:01 <shapr> I don't think there will be five TMR articles ready for August 1st, so no issue this month.
02:27:23 <jyp> hey dons
02:28:40 <jyp> shapr: I start a new job on 1st august... So I'll be busy from then
02:29:23 <shapr> Ah cool, what's your new job?
02:29:26 <jyp> so if my article needs work, it will be easier if you tell before anyway
02:29:26 <dons> congrats!
02:29:36 <jyp> Oh thanks :)
02:30:28 <jyp> Working on the plane-filghts scheduling application in europe
02:30:55 <dons> not in haskell, I guess ..
02:30:58 <dons> :}
02:31:04 <jyp> Ada
02:31:19 <jyp> ... a tradition
02:31:28 <dons> hehe
02:33:42 <shapr> hey jewel
02:34:58 <reffie> morning
02:36:10 <Fri15151> very alive ocaml community.....asked a question couple of hours ago...no activity at all
02:36:12 <Fri15151> :S
02:36:38 <jewel>  /msg shapr hi
02:37:07 <musasabi> morning
02:47:52 <shapr> hyvää huomenta musasabi
02:57:49 * jyp 's out for lunch
03:03:11 * shapr pulls the latest Yi
03:03:49 <dons> try out --as=mg and --as=emacs2, we're heading towards something reasonable for emacs, I think
03:04:12 <shapr> w00!
03:04:26 <dons> C-x C-f in --as=emacs2 is nice, and will be extended this weekend hopefully
03:04:43 <dons> it actually uses the minibuffer as a normal buffer, which is nice
03:05:09 <dons> --as=mg does M-x well, but only lisp-ish functions Mg provides
03:08:02 <shapr> Hey, I found some docs bugs for GHC, "unrecognised flags: -fdolambda-eta-expansion -fmax-simplifier-iterations -fnumbers-strict"
03:08:44 <shapr> Too bad I can't just file a patch.
03:09:06 <dons> lookkks like -fdo-lambda-eta-expansion should be valid?
03:09:59 <dons> but numbers-strict seems to have gone (?) in 6.4.1
03:11:26 <dons> oh, its in the src, but not recognized: -fdolambda-eta-expansion
03:11:31 <shapr> At least -fdo-eta-reduction still works.
03:11:32 <dons> hmmm.
03:13:23 <goron> Anyone familiar with Yi? I get this: yi: /usr/local/lib/yi/HSyi.o: unknown symbol `iconv'
03:13:23 <goron> yi: user error (resolveObjs failed with <<False>>)
03:13:46 <reffie> h
03:13:59 <shapr> goron: Do you have the iconv lib installed?
03:14:10 <goron> shapr: Most likely not.
03:14:23 <goron> shapr: But then the configuration script is flawed.
03:14:32 * goron installs iconv
03:14:33 * shapr dunno
03:14:45 <dons> hmm. the configure script should find it
03:15:04 <dons> checking for libiconv... yes
03:15:37 <goron> dons: It should be in my configure log, right?
03:15:48 <dons> should be
03:15:53 * goron checks
03:16:55 <goron> configure:2823: checking for libiconv in -liconv
03:16:55 <goron> configure:2856: gcc -o conftest -g -O2   conftest.c -liconv  -lncurses  >&5
03:16:55 <goron> /usr/bin/ld: cannot find -licon
03:17:08 <goron> So, it's in the script only it doesn't halt on it.
03:17:21 <dons> is the result = no ?
03:17:37 <dons> if so, then I should turn this into a fatal eerror
03:17:39 <goron> configure:2811: result: no
03:17:40 <goron> configure:2823: checking for libiconv in -liconv
03:17:40 <goron> configure:2856: gcc -o conftest -g -O2   conftest.c -liconv  -lncurses  >&5
03:17:40 <goron> /usr/bin/ld: cannot find -liconv
03:17:40 <goron> configure:2859: $? = 1
03:17:42 <goron> configure: failed program was:
03:17:44 <goron> #line 2830 "configure"
03:17:48 <goron> #include "confdefs.h"
03:18:03 <goron> I am not sure whether line 2811 refers to iconv or something that's above it.
03:18:42 <dons> that result is for another test. what''s the next result down?
03:18:47 <goron> int
03:18:47 <goron> main ()
03:18:47 <goron> {
03:18:47 <goron>     to always fail with ENOSYS.  Some functions are actually named
03:18:49 <goron>     something starting with __ and the normal name is an alias.  */
03:18:51 <goron> #if defined (__stub_libiconv) || defined (__stub___libiconv)
03:18:53 <goron> choke me
03:18:55 <goron> #else
03:18:57 <goron> f = libiconv;
03:18:59 <goron> #endif
03:19:01 <goron>   ;
03:19:03 <goron>   return 0;
03:19:04 <goron> }
03:19:06 <goron> configure:2955: result: no
03:19:09 <goron> I think this is it.
03:19:17 <dons> yep.
03:19:24 <dons> so I have to make the error fatal. well spotted
03:19:56 <goron> ty
03:19:57 <shapr> Yi tech support responds instantly!
03:20:05 <goron> Yes, that's good.
03:20:21 <goron> dons: another bug....
03:20:26 <Lemmih> shapr: Have you ever bought anything from municycle.com?
03:20:38 <shapr> Lemmih: Nah, only unicycle.com and unicycle.se
03:20:43 <goron> dons: Your license is LGPL, but you enclosed the GPL license.
03:20:50 <shapr> Lemmih: But I think municycle.com is part of the same franchise, isn't it?
03:20:54 <dons> oh, my license for yi is GPL
03:21:00 <goron> oh.
03:21:06 <dons> I must have been using my LGPL license script by accident
03:21:07 <shapr> I think municycle.com is unicycle.com for .de
03:21:09 <goron> then it's hs-plugins I guess.
03:21:17 <dons> hs-plugins is LGPL
03:21:23 <goron> Ok, my error.
03:21:58 <goron> dons: I talked to some Emacs guru's and they said you could override any function (C or Lisp) in Emacs.
03:22:07 <goron> dons: Your paper claims this is not true.
03:22:38 <dons> how can you override functoins in the static core?
03:22:51 <goron> dons: you can use "advice".
03:23:11 <goron> dons: I have never done it and have no experience with it.
03:23:35 <shapr> goron: You can't override the code that runs before advice loads.
03:24:04 <dons> that sounds right, and was my understanding of how emacs worked
03:24:07 <goron> shapr: ok (You are a Emacs guru?)
03:24:15 <shapr> Maybe
03:24:34 * goron is a new Emacs user. 
03:24:39 <shapr> I have the record for most number of libraries loaded at once on #emacs (959 I think), I have a 1400 line .emacs (though I should factor out more libraries).
03:24:52 <dons> the yi paper is that *any* functionality other than just loading code should be overridable
03:25:07 <shapr> I've written a few elisp libraries of my own, though nothing popular.
03:25:30 <goron> dons: But isn't advice for loading code too?
03:25:46 <dons> I don't know, we'd have to find out how this advice stuff works
03:26:03 <shapr> Advice is like pointcuts in AOP.
03:26:14 <goron> shapr: ok
03:26:18 <shapr> In fact, they're exactly the same thing, but one is elisp and one is OOP.
03:26:23 <dons> shapr says something unintelligible to me
03:26:26 <shapr> Advice has three ops, before, after, and replace.
03:26:29 <goron> Aspects
03:26:42 <dons> ah, that AOP
03:26:55 <dons> replace, eh?
03:27:05 <shapr> dons: Each function call can be 'advised' by adding another function call that happens before, after, or instead.
03:27:18 <shapr> There's also 'around' calls, but they're obvious just a combination of before and after.
03:27:23 <dons> right. so they do what? rewrite the code?
03:27:27 <goron> dons: What is meant by overridden anyway? Is the old code really "unloaded"?
03:27:39 <dons> the old code is gone in yi
03:28:07 <goron> dons: ok
03:29:02 <shapr> dons: For example, I could write a save-hook that would check to see if the file saved was in a darcs repo, then record the changes whenever I save. That would be an after.
03:29:52 <goron> Do bugs still get solved it darcs?
03:29:58 <goron> er in
03:30:30 <shapr> I think so.
03:30:39 <dons> goron, I think the paper really talks about how emacs historically worked, anyway, as in how it is described in stallman's paper. and we take that model further. so I don't think the advice is directly an issue, though it is certainly interesting
03:31:04 <dons> I will fire up my emacs and see if I can find out how this stuff works
03:31:10 <shapr> goron: Thing is, emacs cannot edit itself, and then reload itself with the changes in effect, it takes lots of compilation instead.
03:31:12 * dons installed emacs this week!
03:31:41 <goron> Doesn't Yi recompiles everything too?
03:32:01 <shapr> Yi can edit itself and then save state, recompile the app, unload the application, reload the new app code, and reload the state in 0.2 seconds.
03:32:13 <dons> you need to recompile the code, but you don't need to quit yi or lose any state to switch to the new code
03:32:37 <shapr> Yes, but Yi is dynamically loaded on top of a tiny static core, so it's all transparent.
03:32:46 <dons> yeah.
03:32:48 <goron> shapr: 0.2 seconds is nice. On a dual G5 ;)
03:33:05 <shapr> How fast can you recompile Emacs?
03:33:09 <yaarg> hrm yi looks interesting...
03:33:32 <shapr> Have you ever looked at the emacs internals? The code is not pretty, nor is it easily changed, imho.
03:33:48 <dons> I checked out some of the C code, and got scared :}
03:34:19 * goron learned Lisp, but didn't see any advantages when compared to Haskell(with or without TH). 
03:34:21 <shapr> The emacs developers have been fighting for years to get the elisp engine factored out into something replaceable, but it's never happened. That's scary enough in itself.
03:35:07 <shapr> emacs has a lot of good points, but I don't think its bad points will be fixed while RMS is alive.
03:35:39 <goron> But shouldn't it be easier to just call executables, that work on e.g. Aterms/XML/whatever you want.
03:35:57 <goron> Instead of loading code in your own process?
03:36:21 <shapr> You're assuming an OS... what about Yi on House? It'd be much like a Lisp Machine, but for Haskell...
03:36:23 <goron> er wouldn't
03:36:38 <goron> shapr: yes, I was.
03:36:55 <dons> I reckon Yi on House would be really cool :)
03:36:59 <goron> shapr: I don't think an OS based on Yi is practical.
03:37:19 <dons> no, an OS based on House :) but they can use yi as the standard editor :)
03:37:20 <shapr> It's an OS based on the GHC RTS, but Yi could run on it.
03:37:41 <goron> shapr: But then you assume an OS too.
03:37:48 <dons> and just have --as=emacs,vi,vim,nano,mg etc so noone would need to install any other editor
03:37:56 * goron knows House (but I didn't get what shapr meant)
03:38:05 <goron> "knows" (I ran it once)
03:38:16 <dons> @karma+ goron
03:38:17 <lambdabot> goron's karma raised to 1.
03:38:37 <goron> @karma goron
03:38:38 <lambdabot> You have a karma of 1
03:38:40 <goron> :D
03:38:54 <goron> Educated guesses rule.
03:39:08 <magnus-> Hi, I have a small problem where the function I type at the repl doesn't infer to the type that I expect
03:39:16 <goron> Good user interface.
03:39:25 <shapr> I do think ATerms are a good AST format.
03:39:30 <vikasg> magnus-, you can't define functions at the repl
03:40:13 <goron> magnus-: repl? That's Lisp jargon.
03:40:20 <dblhelix> vikasg: why not?
03:40:25 <magnus-> goron: I am a lisper
03:40:31 <dblhelix> goron: read eval print loop
03:40:39 <goron> dblhelix: I know.
03:40:45 <shapr> goron: Why do you think it'd be easier to call separate executables?
03:40:48 <dblhelix> goron: ah, okay, sorry
03:40:49 <goron> dblhelix: Because nobody implemented it.
03:41:15 <magnus-> vikasg: let square x = x*x works for me
03:41:21 <shapr> You can define functions with "let foo x = x + 1" in GHC.
03:41:32 <vikasg> ah yes
03:41:34 <dons> goron, I just patched configure for iconv, so maybe you could pull the patch and try it, if you haven't installed iconv yet?
03:41:38 <shapr> There's also the interactive compiler "hi" that's part of hmake.
03:41:42 <dblhelix> magnus-: what's your function?
03:41:42 <shapr> And there's hs-plugins too.
03:41:46 <goron> shapr: On good OS's the speed doesn't matter that much, and you have language independence right away.
03:42:10 <shapr> goron: But how does that apply to the reloadability of elisp vs Yi?
03:42:19 <magnus-> dblhelix: anywhere I can paste it?
03:42:25 <shapr> @paste
03:42:25 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:42:40 <magnus-> thanks
03:42:56 <goron> shapr: Well, essentially you would have invented a language to call executables (it's called a scripting language) ;)
03:43:03 <goron> shapr: so... never mind.
03:43:07 * shapr grins
03:43:51 <goron> dons: I already installed iconv, so probably the issue won't come up.
03:44:25 <dons> ok. well, it should be a fatal error in configure now, anyway
03:44:42 <ulfdoz_> Is there some document about the monad concept for the real stupid newbie? I haven't really understood it yet.
03:44:42 <goron> dons: Your autoconf script assumed autoconf.
03:44:57 <goron> dons: You should better use the samba autoconf script.
03:45:00 <vikasg> ulfdoz_, get in line :)
03:45:05 <dblhelix> ulfdoz_: I like "all about monads"
03:45:12 <goron> dons: It searches for autoconf253 etc.
03:45:17 <dblhelix> @google "all about monads"
03:45:19 <lambdabot> http://www.nomaware.com/monads/html/
03:45:29 <dons> oh, my autoconf script assumes autoconf?
03:45:29 <ulfdoz_> dblhelix: I tried to read it, but I felt confused after about the half of it.
03:45:31 <goron> dons: To enhance portability.
03:45:45 <dblhelix> ulfdoz_: ah, understandable
03:45:52 <goron> dons: I know that sounded funny.
03:46:00 <vikasg> ulfdoz_, I had some success with the parser combinator papers
03:46:04 <dons> I don't find any reference to autoconf253 in the code?
03:46:14 <dons> the yi code
03:46:23 <goron> dons: In Samba there is.
03:46:24 <dblhelix> ulfdoz_: we were discussing this yesterday, but didn't come with a nice solution, i.e. a good way to get the grasp of monads
03:46:43 <goron> dons: Nobody with FreeBSD has autoconf.
03:46:50 <vikasg> ulfdoz_, check out Graham Hutton's papers on monadic parsing
03:46:54 <goron> dons: Everybody has autoconf<insert version number>
03:47:02 <dons> ok. sure.
03:47:15 <goron> dons: I think I can look it up
03:47:18 <dons> but usually they have, i.e. an AUTOCONF_VERSION variable
03:47:33 <dons> at least that's what my OpenBSD machine has
03:47:50 <dons> but what autoconf script are you talking about anyway?
03:47:53 <pejo> goron, checking 5.3-RELEASE-p5 here has a autoconf in /usr/local, among with autoconf213?
03:48:28 <dons> oh, though I see hs-plugins has an autogen.sh that calls `autoconf'
03:48:31 <goron> pejo: I am on 5.4-STABLE and I don't have it.
03:48:33 <goron> ## Look for autoheader
03:48:33 <goron> ##
03:48:33 <goron> for i in $TESTAUTOHEADER; do
03:48:33 <goron>         if which $i > /dev/null 2>&1; then
03:48:33 <goron>                 if test `$i --version | head -n 1 | cut -d.  -f 2 | tr -d [:a$
03:48:35 <goron>                         AUTOHEADER=$i
03:48:35 <dons> but that's not my code -- blame ozone
03:48:36 <goron>                         AUTOHEADERFOUND="1"
03:48:38 <goron>                         break
03:48:40 <goron>                 fi
03:48:44 <goron>         fi
03:48:46 <goron> done
03:48:48 <goron> Something like this.
03:48:50 <goron> Only then for autoconf.
03:49:11 <goron> oops forgot a couple of lines:
03:49:14 <goron> TESTAUTOCONF="autoconf autoconf253 autoconf-2.53 autoconf2.50"
03:49:14 <goron> AUTOHEADERFOUND="0"
03:49:14 <goron> AUTOCONFFOUND="0"
03:49:30 <dons> is there a file or line of code in yi that is a problem, I'm asto what you're asking for?
03:49:44 <dons>  /I'm confused as to/
03:49:49 <ulfdoz_> vikasg: Thx, found it.
03:50:28 <dons> as far as I can see, I don't have an `autoconf' script. configure.ac and configure don't call autoconf, at least.
03:50:32 <goron> dons: autogen.sh
03:50:39 <goron> dons: Your one line super script.
03:51:01 <dons> oh right. like I said -- its in hs-plugins, its not my code, and i'll darcs remove it now
03:51:07 <dblhelix> magnus-: are you having troubles pasting the code, or did you found a solution to your problem
03:51:10 <dblhelix> ?
03:51:13 <goron> dons: oh, ok/.
03:51:57 <magnus-> Okay, took a while, now it's pasted at http://www.haskell.org/hawiki/HaskellIrcPastePage?action=show
03:52:15 <goron> dons: I always thought hs-plugins was your code, but apparently I was wrong.
03:52:45 <dons> no, i'm one of the authors. but you didn't say till just then that you were talking about hs-plugins
03:52:52 <magnus-> dblhelix: trouble pasting... sorry for that
03:52:56 <dons> the author of autogen.sh was not me, however ;)
03:53:20 <goron> dons: Ah, ok. (yes, I wasn't that clear).
03:53:20 <dons> and I exercise my authority now to darcs remove it anyway
03:53:33 <dblhelix> magnus-: don't you want reduceMany [] = []?
03:53:57 <magnus-> dblhelix: No, I want reduceMany [] n = n
03:54:17 <dblhelix> ah, ok
03:54:41 * dons darcs pushes autogen.sh into oblivion
03:55:02 <dons>     R ./autogen.sh
03:55:03 <dons> hehe
03:55:08 <goron> :)
03:55:57 <shapr> Bittorrent hashes size specified chunks of the concatenation of all files in a torrent. What's the right way to get chunks across file boundaries? I'm using 'take chunksize' on concat on the result of mapM readFile filenames. But the check is failing...
03:57:00 <goron> dons: This => Warning: Yi.Syntax.Syntax: the following names could not be resolved:
03:57:00 <goron>  String IO Map Int Maybe
03:57:05 <goron> dons: is normal right?
03:57:13 <dons> yep. silly haddock
03:57:33 <dblhelix> magnus-: ok, but if i apply eta expansion to the second case i get reduceMany (h :t) n = reduce h (reduceMany t) n
03:57:43 <goron> dons: Do you also have a make uninstall target?
03:57:47 <goron> dons: I missed that one.
03:57:48 <xerox> magnus-: but the<Interrupted by dblhelix>
03:57:50 <dons> don't bother installing
03:57:54 <dons> just use ./yi-static
03:57:57 <dons> or ./yi-inplace
03:57:58 <xerox> Lunchtime, anyway :-)
03:58:04 <goron> I already did.
03:58:08 <shapr> Mmm, lunch. I want lunch too.
03:58:08 <dons> unless you plan on serious use, of course
03:58:11 <goron> (install it)
03:58:17 <dblhelix> magnus-: still, reduce expects only two arguments
03:58:33 <dblhelix> magnus-: you see?
03:58:44 <magnus-> dblhelix: let me think a moment
03:59:00 <dons> no uninstall. but find /usr/local -newer config.log will probably telll you what was installed
03:59:15 <dons> should just be bin/yi* and lib/yi*
03:59:23 <dons> oh, and share/*
04:00:22 <magnus-> dblhelix: I think you are missing an $ there
04:00:27 <dblhelix> magnus-: I think you want reduceMany (h : t) = reduce h . reduceMany t
04:00:57 <magnus-> dblhelix: I'll try that
04:00:58 * dons goes hunting for avocadoes
04:01:01 <dblhelix> magnus-: no, I'm not: it's the same as (reduce h $ reduce t) n
04:01:14 <dblhelix> /s/reduce t/reduceMany t
04:01:38 <magnus-> dblhelix: aha...
04:01:51 <magnus-> dblhelix: replacing $ with . fixed the problem!
04:01:51 <dblhelix> magnus-: let me know if that works for you: (.) instead of ($)
04:02:04 <dblhelix> magnus-: ok
04:02:10 <magnus-> Thanks
04:02:14 <dblhelix> magnus-: now try to understand why ;)
04:02:19 <dblhelix> magnus-: you're welcome
04:02:25 <magnus-> dblhelix: I will
04:03:13 <dblhelix> I usually first write a function fully eta expanded and reduce after I got it right that way
04:05:15 <wilx> Ooops, I sent out patch to darcs-devel that I didn't want to send...
04:06:33 * dons awaits illicit patches to arrive :)
04:07:07 <goron> dons: How is find defined when you don't give a pathname?
04:07:17 <magnus-> dblhelix: I see... It seems that $ and . have different binding strengths on the right side which is causing my problems
04:07:20 <goron> dons: Will it just use / then?
04:07:24 <dons> goron, in which mode?
04:07:44 <goron> dons: oops
04:07:53 <goron> dons: never mind.
04:08:19 <dblhelix> magnus-: in general, you don't want ($) when going pointless
04:08:32 <magnus-> dblhelix: I see
04:08:35 <dblhelix> magnus-: going pointless, you typically need (.)
04:08:48 <wilx> Huh.
04:08:52 <magnus-> dblhelix: I misunderstood what $ does I think.
04:08:55 <wilx> This is odd.
04:08:56 <wilx> D:\WilX\tmp\darcs>darcs send --sign --to=v.haisman@sh.cvut.cz
04:09:00 <wilx> This is what I typed.
04:09:07 <wilx> I intended to send it to me.
04:09:19 <wilx> And it went to darcs-devel instead.
04:09:41 <dblhelix> magnus-: it's useful for elimating parentheses: f (g (h x)) can be written as f $ g $ h x
04:09:44 <magnus-> dblhelix: $ is actually just syntactic sugar I now realize
04:10:39 <magnus-> dblhelix: Thank you for the help, it's 100% clear to me now :)
04:10:42 <dblhelix> it's right associative function application
04:10:52 <dblhelix> magnus-: glad to be of any help
04:11:39 <magnus-> uh oh, it's not syntactic sugar, it's a real function
04:11:43 * vikasg wonders why function application isn't right associative by default
04:11:59 <magnus-> vikasg: you might like concatenative languages
04:12:13 <dblhelix> magnus-:  yes: ($) :: (a -> b) -> a -> b; f $ a = f a
04:12:25 <vikasg> hm, yes, I've been meaning to check out Joy
04:12:27 <mflux> vikasg, hmm, so you would prefer ((func 1) 2) instead of func 1 2?
04:12:54 <dblhelix> vikasg: right associative function application and currying don't mix too well ;)
04:13:00 <vikasg> ah
04:14:48 <goron> Why is it called point-free when in fact it's full of points?
04:14:57 <magnus-> so it's simple if disregarding associativity, binding strength etc... $ = apply, . = compose
04:15:14 <dblhelix> magnus-: yes
04:16:46 <mflux> goron, hmm. maybe it refers to the pouch where the points come from?
04:17:37 <goron> mflux: Could you refrase that without 'pouch'?
04:18:12 <mflux> I don't think I can
04:18:50 <mflux> maybe the notation has something to do with the mathematical lambda notation?
04:18:58 <mflux> s/notation/name/
04:21:31 <goron> This means that a function definition avoids, as much as possible, variables for objects that are not functions (lists, numbers, ...) and defines new functions by application of higher order functions. In other words, point-free function definitions avoid unnecessary lambda-abstractions and also recursion in the definition.
04:21:47 <goron> Still the name is confusing.
04:23:03 <vikasg> I think "points-free" is the same as what is called "implicit definition" in the J world
04:25:06 <dcoutts> @seen xerox
04:25:07 <lambdabot> xerox is in #haskell. Last spoke 27 minutes and 8 seconds ago.
04:25:22 <dblhelix> dcoutts: he went out for lunch
04:25:31 <dcoutts> dblhelix, ok
04:26:21 <dcoutts> xerox, you've seen that cairo 0.6 just came out. They claim it's the last API *change* before 1.0 (although not the last API *addition*)
04:27:36 <musasabi> Has anyone defined joy-like recursion combinators in Haskell?
04:35:48 <goron> dons: ./yi-inplace gives the same error. yi-static works, though.
04:35:57 * goron afk
04:38:37 <shapr> How would a 20 bit sha1 hash map into 40 characters of text?
04:38:54 <shapr> oh wait, FF?
04:38:57 * shapr smacks himself
04:39:26 <dcoutts> hex?
04:39:31 <shapr> Yeah, exactly...
04:39:35 <dcoutts> vexed?
04:39:44 <shapr> I am hexed and vexed ;-)
04:40:01 <dcoutts> @remember shapr I am hexed and vexed ;-)
04:40:14 <dcoutts> @help remember
04:40:15 <lambdabot>  @quote <nick>/@quote-add <nick> <quote>
04:40:15 <lambdabot> Quote somebody, or a random person, or save a memorable quote
04:40:34 <shapr> Speaking of hexen, the company I half own is "webwitches" which translates into "webbhäxor" in Swedish.
04:40:38 <dons> goron, what error did yi-inplace produce?
04:40:50 * shapr feels 7331
04:41:09 <dblhelix> shapr: webheksen in dutch :)
04:41:11 <goron> yi_: /usr/home/ron/yi/HSyi.o: unknown symbol `iconv'
04:41:11 <goron> yi_: user error (resolveObjs failed with <<False>>)
04:41:44 <dcoutts> shapr, "webbhxor" sounds somewhat l3t3
04:41:46 <dons> hmm.maybe you didn't regenerate yi.conf after rerunning configure after installing iconv?
04:42:03 <shapr> dcoutts: It's webbha"xor, a with dots.
04:42:30 <dons> no matter, if yi-static works, then iconv is found. if you want, try make distclean, and rebuild
04:42:38 <dcoutts> ok :-), not "w3bhax0r"
04:42:39 <shapr> utf8 chars don't always show up on text terminals.
04:45:32 <goron> checking for libiconv... no
04:45:32 <goron> configure: error: You need libiconv to run Yi
04:45:44 <goron> dons: I am sure your check works :p
04:45:46 <shapr> yay!
04:45:53 <goron> dons: It only works a bit too well, I guess.
04:46:31 <dons> if it is installed somewhere that gcc can't see, then you'll need to set LDFLAGS and CPPFLAGS
04:46:48 <dons> $ echo $LDFLAGS
04:46:48 <dons> -L/usr/local/lib
04:46:54 <goron> dons: It's installed via ports (which should be standard.
04:47:15 <goron> LDFLAGS: Undefined variable.
04:47:33 <dons> umm. export LDFLAGS=-L/usr/local/lib on zsh/bash
04:47:42 <dons> export CPPFLAGS=-I/usr/local/include
04:47:55 <dons> I require these on my BSD box
04:48:18 <goron> Oh, I was in sh ;)
04:49:20 <goron> yay
04:50:58 <musasabi> btw
04:51:08 <musasabi> is anyone going to ICFP in Tallin?
04:51:18 <dons> me!
04:51:37 <dons> just have to survive a 20 hr flight first :}
04:53:11 <goron> dons: Ok, yi-inplace works now too.
04:53:17 <dons> yay!
04:53:40 <dons> so it was just libiconv not installed, then not visible after all
04:55:12 <goron> yes
04:55:24 <goron> Well, it wasn't installed in the first place.
04:55:33 * musasabi ponders going to the haskell workshop as travel is ~free to Tallin.
04:55:53 <dons> ~free?
04:56:10 <goron> dons: It seems backspace is not working in yi emacs mode.
04:56:11 <Fri15151> his mum pays?
04:56:11 <musasabi> dons: I live in Helsinki and the ships are about 20e to Tallin.
04:56:18 <dons> as in, so cheap from Helsinki ...
04:56:20 <dons> oh, yeah
04:56:35 <dons> goron, how about --as=mg ?
04:57:00 <dons> I don't think the two emacs modes are as generous as the modes I have written regarding what counts as a delete key
04:57:07 <goron> dons:  that works.
04:57:19 <dons> (mg is the emacs mode I wrote)
04:57:28 <dons> I noticed this today too
04:57:46 <goron> darcs blaim `other emacs mode`
04:58:17 <dons> darcs failed:  Invalid command 'blame'!
04:58:54 <dons> musasabi, do you think it is feasible to take a day trip from Tallinn to Helsinki?
05:01:43 <musasabi> dons: that is very feasible (although I haven't done it from the Tallinn end)
05:01:55 <goron> I know it's an invalid command. I just wanted to know who wrote it.
05:02:05 <dons> cool! I will got to Helsinki then :)
05:04:40 <dons> goron, there are 3 emacs modes, emacs, emacs2, and mg
05:05:06 * vikasg works throught eopl in Haskell
05:05:10 <goron> Ok, I was talking about "emacs".
05:05:18 <dons> ok, try emacs2 perhaps
05:05:28 <dons> jyp has been working on that this week
05:06:20 <goron> KDE 3.4.1 is pretty buggy :( It just looks like I just finished patience on W95.
05:07:19 <goron> Hmm, no, I think it's FF.
05:12:06 <dcoutts> dons, I was just trying Yi and got the same problem about iconv.
05:12:32 <dcoutts> dons, on linux iconv is part of glibc rather than a seperate library
05:12:54 <dons> you got the problem on linux?
05:13:07 <dcoutts> dons, yes
05:13:14 <dons> hmm.
05:13:16 <dcoutts> there is no iconv
05:13:39 <dons> oh, I'd forgotten that
05:13:45 <dons> so the test is wrong
05:13:53 <dcoutts> there is a seperate iconv, but it's described like so:
05:13:55 <dcoutts> *  dev-libs/libiconv [ Masked ]
05:13:56 <dcoutts>       Latest version available: 1.7
05:13:56 <dcoutts>       Latest version installed: [ Not Installed ]
05:13:56 <dcoutts>       Size of downloaded files: 2,872 kB
05:13:56 <dcoutts>       Homepage:    http://www.gnu.org/software/libiconv/
05:13:57 <dcoutts>       Description: This is a fork of the glibc iconv implementation that is incompatible. it may break things.
05:14:14 <dons> yeah, you only need libiconv on bsd, basically.
05:14:27 <dons> that's why it was non-fatal to configure
05:14:34 <dcoutts> can I hack the configure.ac ? :-)
05:14:35 <dons> but I just made it a fatal error :)
05:14:55 <dons> well, you could try undoing the most recent patch, or just hack!
05:15:16 <dcoutts> darcs unrecord or rollback?
05:15:22 <dcoutts> or unpull?
05:15:34 <dons> unpull the most recent patch, does that work?
05:15:42 <dcoutts> let me see...
05:16:51 <dcoutts> dons, well ./configure now works, lets see if it builds...
05:17:06 <dons> yeah, it'll probably be ok -- i test nightly on linux.
05:17:13 <dcoutts> dons, ok :-)
05:17:39 <dons> thanks for the test :)
05:17:47 <dcoutts> np
05:19:52 <CosmicRay> shapr: can I run bounce an idea off you?
05:20:17 <xerox> dcoutts: hiya, yep, I saw that and I feel good about it :)
05:20:36 <dcoutts> xerox, yeah I bet, just in time!
05:20:53 <dcoutts> you've got a stable target now :-)
05:28:57 <flodin> in ghci I can use let x = foo to introduce a new identifier, but how can i declare its type?
05:29:11 <CosmicRay> flodin: let x = (foo)::Strnig
05:29:22 <xerox> flodin: let <name> = <Intterrupted by CosmicRay>
05:29:26 <flodin> :P
05:29:30 <flodin> thanks
05:37:04 <dcoutts> xerox, do you have some intermediate status report for google you need to do?
05:37:42 <xerox> Not really, if I had completed the 50% of the project I could have done one to get the 50% of the remainder of the sum, but I'm prolly not at that point.
05:38:24 <dcoutts> ok, I was thinking it'd be cool to do an intermediate Gtk2Hs release with a preview of the cairo stuff at some point
05:38:48 <xerox> I'm preparing to go home this two days (I'll be back tomorrow, in fact)
05:38:57 <xerox> After I'll be concentrating and we could do it :)
05:39:04 <dcoutts> oh right, nice
05:39:24 <dcoutts> I told you I'm going to be away for a week, starting in one weeks time
05:39:37 <dcoutts> but I'll be about a bit this comming week
05:39:51 <dcoutts> only in the evenings however
05:41:26 <xerox> Yup, noted :)
05:45:36 <dcoutts> dons, building hs-plugins seems to barf when there are multiple versions of Cabal installed (which is a common situation since ghc provides Cabal too)
05:45:55 <dcoutts> Rebuilding dependencies ... ghc-6.4: Error; multiple packages match Cabal: Cabal-1.0, Cabal-1.1.1
05:46:14 <dcoutts> presumably it's specifying -package Cabal
05:46:53 <dcoutts> does it need to do that? Cabal is usually an exposed package so it could just use whichever version is currently exposed and not worry about it :-)
05:47:54 <seafood> Well, I think that's an error from GHC not the build scripts of hs-plugins.
05:48:29 <seafood> Probably because dons just put "Cabal" as a dependency.
05:48:35 <dcoutts> seafood, true it ghc produceing the error but caused by a command that the hs-plugins build system ran
05:48:37 <seafood> GHC won't know which one to use.
05:48:45 <dcoutts> seafood, yes that's probably it
05:49:10 <dcoutts> hence my suggestion to leave it off and it should just work
05:50:29 <dons> dcoutts, yeah, it's specifying -package Cabal
05:50:49 <dcoutts> I'll remove it and see if that works
05:51:00 <dons> yeah, I seem to recall it working
05:51:09 <dons> but perhaps I just added it explicitly to make sure
05:51:37 <dcoutts> apparently ghc-6.4.1 is not going to be so fussy when you say -package Cabal
05:51:45 <dcoutts> it'll just pick the exposed one or something
05:51:58 <dcoutts> yeah, that works now
05:52:11 <dons> ok. i'll remove the dep and see if the tests still work
05:52:16 <dcoutts> ok
06:00:18 <dons> dcoutts, looks good. will commit, cheers.
06:00:43 <dcoutts> ok good
06:01:47 <xerox> bye now.
06:01:53 <dcoutts> bye xerox
06:05:00 <shapr> CosmicRay: bounce!
06:05:28 <shapr> Man I love unicycling. I still can't beat my average of 12km/h though.
06:05:57 <mflux> I guess they don't have transmission/gears?
06:06:09 <mflux> so it might be tough to beat it
06:06:15 <mflux> (by more than a margin)
06:06:19 <shapr> Nah, I just have to get in better shape.
06:06:26 <CosmicRay> shapr: hey!
06:06:30 <shapr> y0!
06:06:41 <CosmicRay> shapr: So yesterday it occured to me that maybe I ought to start a Haskell Weekly News thing
06:06:46 <CosmicRay> shapr: sorta like the Debian Weekly News
06:06:50 <mflux> if it had chains they would need to be real tiht..
06:06:54 <mflux> and tight too
06:06:56 <shapr> CosmicRay: Yeah!
06:07:13 <shapr> mflux: unicycles with chains are called giraffes
06:07:15 <CosmicRay> shapr: post an e-mail on haskell-general and maybe the sequence once a week, updating people on what was discussed in the lists, notable new releases, etc.
06:07:19 <CosmicRay> shapr: cool ;-)
06:07:43 <CosmicRay> shapr: also, today is the last day of my nasty summer class.  woohoo.  So, I think I can whip up something for TMR in the next few weeks
06:07:45 <jyp> CosmicRay: neato
06:07:48 <shapr> CosmicRay: Yay!
06:07:51 <mflux> shapr, I was thinking it wouldn't be any taller
06:07:56 <mflux> shapr, infact it could be shorter!
06:08:12 * CosmicRay goes about setting up a darcs repo for HWN ;-)
06:08:19 <mflux> not much not much though
06:08:20 <shapr> I'm going to finally release IssueFour with the ready articles.
06:08:28 <mflux> and those still don't have any gears?
06:08:41 <autrijus> greetings
06:08:48 <shapr> mflux: giraffes do have gears, but there's not much point in going fast with those.
06:08:55 <CosmicRay> shapr: also the FSM article should be out of copyright in time to go into the 9/1 issue.
06:09:05 <jyp> HWN?
06:09:13 <shapr> George Barnes IV did design a giraffe-style speed unicycle, it went quite fast.
06:09:26 <CosmicRay> jyp: Haskell Weekly News.  the idea shapr and I have just been tossing around
06:09:54 <jyp> Im stoopid
06:10:12 <shapr> HWN would be for summarizing mailing list traffic, interesting events, that sort of thing.
06:10:34 <CosmicRay> http://www.debian.org/News/weekly/ is the idea
06:10:35 <shapr> I'd suggest basing it on the LWN.net structure.
06:10:45 <CosmicRay> there's that option too
06:10:54 <CosmicRay> shapr: have you seen DWN before?
06:11:05 <shapr> Yeah, but I don't remember what it looks like. I'll look at it now.
06:11:08 <autrijus> anyone got some links to calculi that does soft typing/incremental typing? I'm working with F<:, but encoding dynamics or partial dynamics there is a bit messy
06:11:49 <CosmicRay> I guess I thought of DWN first because we'd be more on that scale than LWN, at least to start with I guess ;-)
06:12:24 <CosmicRay> the other thing I like about it is that it has links directly to the list archives all over the place, and since it's one page, it can be e-mailed each week
06:12:27 <CosmicRay> which I find useful
06:12:48 <shapr> LWN also does announcements though.
06:12:48 <CosmicRay> http://lists.debian.org/debian-news/debian-news-2005/msg00033.html
06:12:54 <CosmicRay> that's an example of an e-mailed edition
06:12:56 <shapr> What about a mix of both?
06:13:28 <CosmicRay> I'm not very familiar with LWN, do you have an example of what it does differently?
06:13:52 <shapr> Look at this - http://lwn.net/Articles/143646/
06:14:16 <CosmicRay> ah, so you're suggesting larger free-standing articles as well?
06:14:18 <shapr> Sections are: Front page, Security, Kernel development, Distributions, Development, Linux in the news, Announcements
06:14:36 <shapr> Not necessarily, but at least a separate section for app/lib announcements.
06:14:48 <dcoutts> dons, here's an ugly problem with packages and registering and such like (which I bumped into while trying to build yi)
06:15:33 <CosmicRay> shapr: ahh, I think I'm understanding you now.  Let's see if I am..  what you're suggesting is still a single e-mail/page per week, but structured into different sections so it's easy to find what a person is looking for?  Still be about the same size as DWN but with a little more organization?
06:15:43 <shapr> CosmicRay: Right, exactly.
06:15:44 <dcoutts> dons, so I built hs-plugins and it used Cabal-1.1.1 because that's the version that is exposed. But for some reason ghc-pkg decided to register it agsinst Cabal-1.0 !
06:15:51 <CosmicRay> shapr: cool.  I like it.
06:16:40 <dcoutts> dons, so the means that now Cabal-1.0 and Cabal-1.1.1 are exposed and so nothing can be compiled since it's ambiguous (Cabal-1.0 is not directly exposed but since hs-plugins is exposed it means it's dependencies are also exposed)
06:17:07 <dcoutts> dons, so we end up with:
06:17:08 <dcoutts> ghc-6.4: Error: module 'Distribution.Compat.ReadP' is exposed by package Cabal-1.0 and package Cabal-1.1.1
06:17:43 <dcoutts> this must be a ghc-pkg problem, if a package.conf files says "depends: Cabal" then it should resolve that to the exposed version
06:18:17 <dcoutts> (though it won't help if it's been built by specifying an explicit version, eg -package Cabal-1.0)
06:18:24 <dcoutts> what a mess :-(
06:19:11 <dcoutts> this is one reason we need Cabal because it makes sure the thing is built and registed with consistent versions of dependent packages
06:20:40 <dcoutts> dons, but at least I've got Yi built and working! :-)
06:21:21 * shapr cheers
06:22:06 <Igloo> Does hs-plugins use cabal itself, or does it just use it for building?
06:23:48 <dcoutts> Igloo, it's not quite clear to me, you'll have to ask dons
06:23:57 <dcoutts> Igloo, any suggestions on this mess? :-)
06:25:48 <dons> hmm.
06:25:56 <dons> hs-plugins does use Cabal
06:26:03 <dons> at runtime, to parse package.conf files
06:26:14 <Igloo> Ah, OK
06:26:52 <dons> messy messy
06:26:55 <Igloo> And no, no suggestions
06:27:45 <dcoutts> except to bug JaffaCake :-)
06:28:01 <Igloo> Won't 6.4.1 already fix it?
06:28:14 * Igloo AFKs
06:28:25 <dcoutts> by doing what? just picking the currently exposed version
06:28:58 <dons> time for me to get some sleep, but i'll read the logs and have a look tomorrow
06:28:59 <dcoutts> it'd be an improvement but there would still be cases where it wouldn't work
06:29:11 <dcoutts> right, g'night dons
06:29:22 <dons> nitol!
06:29:37 <dcoutts> the problem is that ghc-pkg just doesn't know which version you built against
06:29:45 <dcoutts> it can only guess
06:30:43 <dcoutts> the currently exposed version is the most likely but you could have used any version my explicitly specifying a version
06:31:15 <dcoutts> though in that case you would be well advised to but that explict version in the package.conf file too!
06:31:21 <dcoutts> but/put
06:31:32 <CosmicRay> shapr: for links to mailing list posts, what do you think is best: the archives on haskell.org or gmane.org?
06:31:46 <shapr> hm, good question.
06:32:21 <shapr> I don't know, what are the dis/advantages of each?
06:32:24 <musasabi> What would be the correct place in the hierarchical namespace for a gnutls wrapper - Network.TLS (or even Network.GnuTLS) ?
06:32:43 <CosmicRay> musasabi: that sounds good to me
06:32:46 <shapr> I read the haskell mailing lists via gmane, so either is fine with me.
06:35:07 <Igloo> Exposed beat unexposed, higer beats lower or something. There was a discussion about it on a list recently
06:35:34 <dcoutts> Igloo, so you think this is fixed in 6.4.1 ?
06:35:50 <Igloo> I thought so
06:36:11 <dcoutts> ok, I'll not send a bug report just yet then
06:37:08 <beelsebob> evening all
06:40:46 <shapr> hiya beelsebob
06:41:05 <beelsebob> bah... stupid terminal buffering
06:44:08 <shapr> Yay, my bittorrent hash checking is beginning to work!
06:44:19 * shapr hops happily
06:44:25 <beelsebob> :)
06:44:32 <CosmicRay> nice!
06:44:44 <beelsebob> my declarative debugger is beginning to work
06:44:52 <CosmicRay> shapr: out of couriosity, what motivated you to writing a BT client?
06:44:59 <CosmicRay> my ldap binding is beginning to work
06:45:00 <shapr> Sure is slow though, I gotta switch to one of the fast io layers.
06:45:03 <beelsebob> despite the worlds most horribly twisted knot of lazy computation
06:45:12 <shapr> CosmicRay: bt.etree.org
06:45:13 <CosmicRay> shapr: all that marshalling to and from 32-bit chars probably
06:46:19 <shapr> I have 1Mb/sec both up and down, so I'd like to run a bunch of torrents at once so I can download faster and make lots of data available to others. But the python bittorrents are slow when running multiple torrents.
06:50:53 <shapr> CosmicRay: Mostly just cause it seemed like fun.
06:51:09 <shapr> And it hasn't stopped being fun yet, so I'm still hacking on it.
06:51:58 <CosmicRay> shapr: that's an excellent reason.
06:52:59 <shapr> I need to find a faster way to sha1 several gb of data though.
06:53:37 <Speck> ffi to c?
06:54:02 <shapr> I may do that, but not till the whole deal works. I can handle slow for the moment.
06:54:23 <Speck> good plan. make it work well before you make it work fast
06:55:53 <pejo> Heh, yeah. This is just one of those moments begging for quotes from Knuth.
06:56:33 <shapr> I've noticed I get most of my code done when I do whatever seems like fun at the time.
06:57:19 <beelsebob> why the hell does this cause a type error?
06:57:20 <beelsebob> mkQuestions :: NodeExp -> [Bool] -> [String]
06:57:20 <beelsebob> mkQuestions = fst . mkQuestionsPair
06:57:20 <beelsebob> mkQuestionsPair :: NodeExp -> [Bool] -> ([String], Bool)
06:57:31 <shapr> These days I'm just trying to make sure to put that fun code into a darcs repo, and also make sure that whenever I finish a hacking session, make sure that the recorded code is consistent enough that I don't mind publishing it.
06:58:04 <shapr> If I keep that up, I can just share anything I write.
06:58:46 <CosmicRay> shapr: I have the same philosophy
06:59:17 <metaperl> good morning!
06:59:31 <shapr> hiya metaperl
06:59:33 <Igloo> shapr: Do you get files from the beginning straight through?
06:59:35 <metaperl> I'm off today --- moving to a Buddhist dormitory/monastery --- www.ibmc.info
06:59:43 <shapr> Igloo: I don't understand?
06:59:48 <arjanb> beelsebob: mkQuestions n = fst . mkQuestionsPair n
06:59:50 <shapr> Igloo: Oh, yes.
07:00:12 <Igloo> Then a slow SHA1 will probably be able to keep up with your network connection
07:00:23 <beelsebob> m'kay, that's just dumb
07:00:28 <Igloo> You just need to get the SHA1 computation happening at the same time as the download
07:00:53 <metaperl> arjanb: why couldn't he use points-free style?
07:00:55 <shapr> Igloo: A torrent has chunks of a certain size and sha1 hashes for each chunk. Chunks can cross file boundaries. When resuming downloads you need to check the sha1 hashes of all chunks so far.
07:01:10 <arjanb> becuase of the type of (.)
07:01:27 <Speck> @type (.)
07:01:32 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
07:01:37 <shapr> metaperl: Sounds like fun.
07:01:41 <metaperl> torrent? I'm a bittorrent freak. I like Azureus. But then again eDonkey consumes torrent,  kazaa, gnutella, and a host of other networks
07:01:42 <Igloo> You can store the SHA1 with each chunk to avoid recomputing it each time
07:02:20 <Speck> shapr do you have any of this bt client published anywhere?
07:02:22 <metaperl> aha. the "-> a" is what requires the n
07:02:22 <shapr> metaperl: I'm writing a bittorrent client in Haskell. The file part is mostly done, the network part is next.
07:02:27 <arjanb> @pl (\ a b -> fst . foo a b)
07:02:27 <lambdabot> ((fst .) .) . foo
07:02:33 <shapr> Speck: Not yet, but I can publish it if you want.
07:02:40 <metaperl> shapr: where is the bt protocol specified?
07:02:42 <Speck> shapr, just tell me when you do :-)
07:02:53 <shapr> metaperl: http://www.bittorrent.com/protocol.html <-- This is a very simple protocol.
07:03:21 <shapr> Speck: I'll need to get a license from Sebastian Sylvan. He wrote the BEncode part.
07:03:35 <Speck> ah I see
07:03:54 <metaperl> I want to get Gilda Radner's performance of "Roseanna Danna" via bittorrent, but its not there
07:04:02 <metaperl> that was so funny back in the day
07:04:04 <shapr> But his code is only about forty lines.
07:04:15 <metaperl> Roseanna,,,, Roseanna Danna
07:04:55 <shapr> I wrote some QuickCheck tests, found some bugs in his code, added some render code that turns a Bencode adt back into Bencode format... you'll see ...
07:07:02 <Speck> sounds fun :-D
07:07:07 <genneth> shapr, i was joking about a bt client in haskell the other day
07:07:28 <shapr> Now you can be serious!
07:07:32 <shapr> It's easier than I expected.
07:08:28 <CosmicRay> this will be cool.  I don't like the python torrent clients very much.
07:08:36 <genneth> it always is with haskell
07:08:42 <shapr> It'll be cool if people hack on it and improve it :-)
07:08:43 <CosmicRay> plus, having it in haskell could lead to all sorts of neat possibilities.
07:08:53 <shapr> My major issue is that I want to run a bunch of torrents at once with no loss of efficiency.
07:08:59 * genneth wave enthuithiastically
07:09:37 <genneth> shapr: have you heard of robocode
07:09:55 <shapr> Vaguely...
07:10:05 <shapr> robot programming game?
07:10:11 <genneth> yep
07:10:30 <genneth> it's a great tool to get people interested in java
07:10:45 <shapr> Ah, you'd like to see one for Haskell?
07:10:46 <genneth> i was reading about yampa the other day
07:10:56 <genneth> yes
07:11:05 <shapr> Oh yampa robot soccer would make a great robocode clone.
07:11:24 <genneth> i'm wondering if there is a haskell-java bridge
07:12:16 <genneth> i suspect that the more advanced algos are simpler to express in haskell than java
07:12:56 <shapr> Yeah, there's a haskell-java bridge. It'd be cool to integrate that with robocode.
07:13:28 * shapr suspects that hashing even 500mb will take ages
07:14:09 <genneth> can't you off load to a C FFI bit for that?
07:14:20 <genneth> in fact, i'm sure you already do
07:14:57 <shapr> I'm using Igloo's SHA1 code right now. It seems to work, that's all I care about at the moment.
07:15:13 <mflux> so how fast does it hash?
07:15:29 <shapr> The fact that it's taking half an hour to hash 422mb is likely my naive file reading code if anything.
07:16:20 <Igloo> The darcs version has better optimised, but also tied up with the FastPackedStrings
07:16:33 <shapr> Are FastPackedStrings much trouble?
07:17:41 <Igloo> If you just want to SHA1 a file then probably not
07:17:42 <Speck> CosmicRay, I got debian linux on the os quiz :-P
07:17:54 <musasabi> Is there a fix for cabal to clean up .chi and .h files in conjunction of c2hs ?
07:17:56 <CosmicRay> Speck: not fair! ;-)
07:18:08 <CosmicRay> someone on planet did too.
07:18:09 <CosmicRay> sigh.
07:18:52 * Speck chortles, however, and looks at his ubuntu box
07:19:07 <ozone> musasabi: sounds like a good suggestion for the next version of cabal ...
07:19:15 <ozone> might want to email the libraries list about that
07:33:09 <shapr> heya kowey, ltns
07:34:45 <kowey> hey there
07:34:48 <kowey> erm...
07:34:50 <kowey> ltns
07:34:51 <kowey> ?
07:34:58 <shapr> long time no see
07:35:06 <kowey> :-)
07:35:11 <shapr> @wtf is ltns
07:35:14 <lambdabot> *** "is" wn "WordNet (r) 2.0"
07:35:14 <lambdabot> is
07:35:14 <lambdabot>   See {be}
07:35:14 <lambdabot> No match for "ltns".
07:35:36 <shapr> Ok, this sha1 is officially way too slow.
07:35:49 <beelsebob> I'm sure this would be much nicer in CPS
07:35:56 <beelsebob> but I can't quite see how to do it
07:36:24 <shapr> kowey: How's code?
07:36:52 <kowey> well... having some linking woes
07:36:57 <kowey> not really haskell related
07:37:06 <kowey> well... wxhaskell
07:37:25 <kowey> trying to get it working on Tiger with the new wxWidgets that comes preinstalled
07:38:11 <kowey> (taking a break from all that profiling i was doing since my last visit)
07:39:21 <beelsebob> bah... I appear to have broken lazyness again
07:40:17 <beelsebob> my debugger wants you to answer several questions before it asks them now
07:40:42 <kowey> anyone know a good channel to ask about low-level mac stuff? like linking woes?
07:40:50 <beelsebob> macdev
07:41:01 <beelsebob> they're not too friendly
07:41:06 <beelsebob> but it's worth a try
07:41:40 <thedward> "MacOS X: Friendly, so the users don't have to be." ?
07:41:46 <kowey> hmm... so far #haskell and #wxwidgets are very nice... i'll poke my head in nervously
07:41:59 <beelsebob> lol
07:42:05 * shapr grins
07:42:08 <beelsebob> actually, usually the users are very friendly
07:42:55 <beelsebob> but unfortunately that channel is full of people who think they know everything about everything and rarely succeed in answering your question except with a snide comment
07:43:12 <beelsebob> usually asking why you would want to do such a stupid thing in the first place
07:45:40 <thedward> ah
07:45:50 <thedward> is it possible to nest guards?
07:45:59 <beelsebob> how so?
07:46:21 <thedward> I want to have a guard where one of the conditions leads to another guard
07:46:24 <thedward> or is that just silly?
07:46:32 <beelsebob> ah... you probably want a case within the guard
07:47:21 <thedward> hmm
07:49:39 <thedward> but I can't put arbitrary expressions as selectors in a case construction
07:49:49 <beelsebob> ?
07:49:52 <beelsebob> what like?
07:50:11 <thedward> like "foo(x+1) ^ 2" or some such
07:50:18 <thedward> err
07:50:20 <thedward> not like that , actually
07:50:29 <thedward> something that would return boolean
07:50:35 <beelsebob> note... you *can* use guards in a case
07:50:42 <thedward> case just lets you do pattern matching, doesn't it?
07:50:45 <thedward> oh. hm
07:50:55 <beelsebob> case x of y | z == x ^ y -> something
07:52:26 <thedward> I think I am approaching this the wrong way.
07:55:06 <beelsebob> I think I am too... this needs to be done with CPS
08:06:11 <beelsebob> woo yay!
08:06:28 <beelsebob> This is actually becoming really simple now I've figured out what I'm doing
08:06:35 <Speck> Can someone give me a quick example for creating a Data.Map with 1 => "one" and 2 => "two" ?
08:07:28 <shapr> probably something like "import Data.Map as M where map = fromList [(1,"one"),(2,"two")]
08:08:07 <Speck> ah
08:08:34 <Speck> I was wondering if the constructor syntax was preferable
08:09:08 <shapr> Oh, I don't know. That's just what I've used with Data.FiniteMap. I've heard Data.Map is better than FiniteMap in many ways.
08:09:27 <shapr> I haven't yet used Data.Map, I don't know.
08:12:59 <shapr> What's a good cheesy name for a Bittorrent implementation in Haskell?
08:13:35 <shapr> LambdaTorrent? Combinatorrent?
08:13:41 <ibid> hattorrent ;)
08:13:46 <shapr> heh!
08:14:46 <Khisanth> Abhorrent
08:14:49 <shapr> Torrentula?
08:15:44 <thedward> Torrential?
08:16:10 <shapr> Yeah, but that's a real word, hard to google for.
08:17:49 <shapr> I think I'll call it combinatorrent for the moment, and hope for a cheesier suggestion.
08:18:29 <ibid> my current thinking is it's best to avoid all that cuteness, since too much cuteness can kill you (and there already is almost too much:)
08:19:20 <shapr> I like cute, non-serious names. I think the Haskell world has enough seriousness.
08:19:38 <shapr> I remember cute silly names better than serious ones, but that may not be true for everyone.
08:20:04 <kaol> as long as they're not common words or single letters
08:20:16 <CosmicRay> shapr: \torrent? ;-)
08:20:24 <shapr> Right, googlability is important for software names.
08:20:28 <ibid> i've been trying to find unused completely different ordinary words
08:20:30 <shapr> CosmicRay: Also hard to google for.
08:20:46 <tuomov> CurryTorrent
08:21:10 <shapr> tuomov: That would make for a lovely logo, flying spicy food!
08:21:21 <ibid> for example, my msc project was called ebba (a swedish female name, named after the receptionist in wallander's workplace)
08:21:28 <CosmicRay> hmm, brainstorming: Horrent, LazyTorrent, ForkTorrent, ByteTorrent
08:21:39 <ibid> wallander being a fictional swedish cop
08:21:40 <dcoutts> {\lambda}torrent would make for a nice logo
08:21:43 <mflux> horrent.
08:21:54 <shapr> CosmicRay: oh, LazyTorrent is tempting.
08:21:57 <ibid> i still like hattorrent, or hatorrent
08:22:07 <vegai> use UTF8 and a real lambda
08:22:16 <dcoutts> vegai, yes exaclty
08:22:17 <ibid> vegai: hard to google :)
08:22:36 <dcoutts> well only for I logo I guess
08:23:03 <dcoutts> I think the package managers would have a fit! :-) they only like lower case ascii
08:23:11 <vegai> ibid: googling "haskell torrent client" should work in any case...
08:23:21 <ibid> also, what would the debian ftp-masters say of a package named λtorrent :)
08:23:35 <beelsebob> hehe
08:23:40 <CosmicRay> ibid: they'll get back to you next March
08:23:41 <beelsebob> make it OS X only then :P
08:23:44 <vegai> what a weird lambda symbol on my fontset
08:24:04 <tuomov> mine too
08:24:06 <ibid> CosmicRay: nonono, march, no year specified :)
08:24:11 <CosmicRay> hehe
08:24:14 * ibid used to be a ftp-master. he knows :)
08:24:24 <tuomov> -.
08:24:25 <tuomov> ||
08:24:27 <tuomov> something like that
08:24:45 <tuomov> wouldn't have recognised it for lambda in other context
08:25:06 <vegai> tuomov: terminus?
08:25:10 <tuomov> misc-fixed
08:25:13 <beelsebob> @paste
08:25:14 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:25:16 <vegai> ah. Same here, you see
08:25:19 <CosmicRay> note to self: ibid knows about the cabal.  appease ibid at all costs.
08:25:30 <Igloo> CosmicRay: Can you tell me what System.Info.os is on Windows please?
08:25:37 <vegai> I guess they were too lazy to be creative with the special symbols
08:25:41 <ibid> CosmicRay: i'm ex-cabal, i'm of no use :)
08:25:47 <CosmicRay> Igloo: give me about 2 minutes to boot it up...
08:25:51 <Speck> odd... Map.lookup returns the value in a monad :-|
08:25:54 <ibid> there is no cabal
08:25:56 <tuomov> no wonder I couldn't find lambda in the unicode character map :)
08:25:58 <ibid> except the haskell cabal
08:26:02 <ibid> keep no other cabals
08:26:03 <ibid> ;)
08:26:09 <CosmicRay> ibid: of course, that's what we'd expect you to say.
08:26:20 * CosmicRay watches ibid prove a negative
08:26:37 <ibid> these are not the cabals you are looking for
08:26:43 <vegai> fnord
08:26:58 <CosmicRay> ibid: mingw23
08:26:59 <CosmicRay> err
08:27:01 <CosmicRay> mingw32
08:27:06 <Igloo> Thanks
08:27:32 <shapr> Poo, some sort of error in darcs.cgi, "Can't call method "mtime" on an undefined value at darcs.cgi line 195."
08:27:53 <shapr> Anyway, can you guys darcs get http://www.ScannedInAvian.org/repos/combinatorrent ?
08:28:34 <vegai> nope
08:28:36 <shapr> It doesn't do much yet. Next step is to use FastPackedString and SHA1 from darcs. It looks like it'll be easy enough.
08:28:38 <vegai> libcurl: HTTP error (404?)
08:28:42 <Igloo> shapr: If you could track down the problem that'd be great
08:28:56 <Igloo> Sounds like it'll be permissions, though
08:29:19 <shapr> Probably so.
08:31:57 <shapr> Huh, libcurl couldn't resolve host?
08:32:16 <ibid> 404 is not foun, not resolve error
08:32:40 <CosmicRay> anyone know if musasabi has a homepage somewhere?
08:32:44 <CosmicRay> or darcs repos? ;-)
08:32:44 <ibid> vegai: but was it 404?
08:32:59 <shapr> vegai: ok, now?
08:36:43 <ibid> CosmicRay: are you now the world's foremost gopher expert? ;)
08:36:49 <shapr> Igloo: I can darcs get, but browsing the repo gives the same darcs.cgi error.
08:36:54 <ibid> (just read the latest dsa)
08:37:14 <Igloo> shapr: Try tweaking the cgi script to be a bit more informative
08:37:17 <shapr> Anyway, I'd be hacking in the FastPackedString and SHA1 from darcs right now if I weren't going to see music tonight.
08:38:13 <shapr> darcs.cgi is in Perl.
08:39:36 <shapr> Can anyone darcs get combinatorrent?
08:39:58 <beelsebob> is interact buggered in ghc's implementation?
08:40:48 <Igloo> You might need to change the buffering mode
08:41:06 <beelsebob> hmm?
08:41:38 <shapr> Well, I'm off, if any does cute stuff to the BT code, send me patches.
08:48:00 <beelsebob> is it polite to delete things from the bottom of the paste page?
08:48:40 <CosmicRay> shapr: will you be back later?
08:48:50 <CosmicRay> shapr: I have issue 1 of HWN almost banged out.
08:49:35 <ibid> HWN?
08:49:39 <ibid> ahh
08:49:43 <CosmicRay> ibid: Haskell Weekly News
08:50:08 <ibid> took a while to connect that to an earlier request you made on another channel :)
08:50:23 <CosmicRay> hehe
08:50:33 <CosmicRay> I also talked about it with shapr on this one
08:50:52 <ibid> that i didn't notice :)
08:51:07 <musasabi> CosmicRay: how many hours till a deadline of notices to it?
08:51:12 <CosmicRay> hmm, wow, did the GHC performance week actually happen almost a month ago?
08:51:37 <CosmicRay> musasabi: I'm planning to send it out Monday or Tuesday.  send any stories to jgoerzen@complete.org please
08:51:59 <beelsebob> @paste
08:52:00 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:52:05 <musasabi> oh, no hurry then.
08:52:06 <CosmicRay> musasabi: btw is your current development on gnutls up anywhere?  I'm thinking of a "new works in progress" section or something
08:52:13 <beelsebob> anyone see why laziness is breaking there?
08:52:19 <beelsebob> (top two pastes)
08:52:27 <CosmicRay> where people that have some code, not finished, can announce it and interested people could join in
08:52:48 <musasabi> CosmicRay: I will publish it "when it is ready" which is about ~5-8 hours of hacking.
08:52:54 <CosmicRay> sweet.
09:00:01 <vegai> shapr: worked that time
09:23:07 <beelsebob> woo yay!
09:23:11 <beelsebob> sorted it out
09:24:09 <Lemmih> Greetings SyntaxNinja.
09:27:01 <musasabi> Does c2hs {#import Module#} really not support hierarchical modules - or am I doing something wrong?
09:30:28 <musasabi> I try to do {#import Network.GnuTLS.Internals#} and it complains "c2hs: Network.chi not found in: ."
09:32:34 <SyntaxNinja> hi Lemmih!
09:32:39 <SyntaxNinja> Lemmih: got anything for me? :)
09:32:43 <dcoutts> musasabi, oh yes that was one of the patches that I needed to send to Manuel, the hierarchical modules support. Thank's for reminding me! :-)
09:33:21 * SyntaxNinja is working from home today.
09:33:24 <SyntaxNinja> laptops rule!
09:33:40 <dcoutts> musasabi, it's supported in the Gtk2Hs fork of c2hs, I can send you the patch against the latest c2hs darcs repo if you like.
09:34:14 <musasabi> dcoutts: well I can avoid the {#import #} at the moment and use just a plain import, but I will need it sometime in future.
09:34:32 <musasabi> I'll try to live with vanilla c2hs to make building easier.
09:34:47 <dcoutts> musasabi, ok, I'll just send the patch to Manuel, hopefully there'll be another release soon
09:34:52 <musasabi> Thanks.
09:40:06 <Lemmih> I didn't get my key signed *sigh*
09:40:12 <Lemmih> Couldn't find the guy.
09:40:48 * SyntaxNinja wiggles eyebrows in the general direction of: http://www.cs.ru.nl/~marko/tfp05/programme.html
09:40:48 <Lemmih> But I'll do it first thing monday morning, promise.
09:40:52 <SyntaxNinja> Lemmih: OK cool.
09:41:04 <dcoutts> musasabi, actualy would you mind seeing if this patch does what you need? It's slightly difficult for me to see if I've included all the necessary changes.
09:41:20 <Igloo> SyntaxNinja: Cool  :-)
09:41:26 * SyntaxNinja wiggles other eyebrow in the general direction of: http://www.cs.uu.nl/~daan/hw2005/program.html
09:41:28 <Igloo> SyntaxNinja: Are you staying for ICFP/HW?
09:41:33 <SyntaxNinja> Igloo: ja
09:42:01 <Igloo> Ah, yes, I'd already seen that but forgot about it
09:42:20 <SyntaxNinja> I'm ashamed to admit that I got an email a week ago telling me it got into TFP, but it just looked like an automated email telling me they received my paper and the accceptance notice was way at the bottom.
09:42:25 <musasabi> dcoutts: I can test it if you want - I just need very basic {#import Foo.Bar #} and nothing else.
09:42:55 <Igloo> SyntaxNinja: Is halfs OS?
09:42:55 <dcoutts> musasabi, ok that's all the patch does (I hope). email?
09:43:26 <SyntaxNinja> Igloo: it will be.
09:43:28 <musasabi> ekarttun at cs helsinki fi
09:43:31 <Igloo> What's it for?
09:44:02 <SyntaxNinja> Igloo: the 'interesting' parts for galois are not goign to be published or opensourced, but all the rest of the framework will be, so it'll just be a general-purpose filesystem for experimentation.
09:44:21 <Igloo> WDYM by "filesystem"?
09:44:26 <SyntaxNinja> Lunar^: wrote FUSE bindings for Haskell, so you can mount it under Linux
09:44:56 <SyntaxNinja> Igloo: you know, like ext3, ffs, fat32, whatever.
09:45:16 <Igloo> OK, so a traditional on-disk FS, but written using Haskell?
09:45:22 <SyntaxNinja> ja
09:45:26 <lispy`> ah, cool
09:45:27 <Igloo> OK, thanks
09:45:30 <lispy`> and it's fast?
09:45:34 <SyntaxNinja> um
09:45:35 <lispy`> or at least fast enough?
09:45:39 <SyntaxNinja> it goes :)
09:45:45 <lispy`> hehe
09:45:49 <lispy`> fair 'nough
09:46:00 <SyntaxNinja> it's actually not fast enough, but I also haven't done any tuning or even removed the debugging output, so we don't know yet.
09:46:16 <lispy`> okay
09:46:26 <basti_> hi all!
09:46:29 <SyntaxNinja> I actually expect that it'll be passable
09:46:33 <Lemmih> hi basti_!
09:46:51 * basti_ will continue work on yi-emacs this weekend
09:47:27 <dcoutts> musasabi, ok it's sent
09:48:03 <dcoutts> musasabi, you know the latest c2hs needs Cabal > 1.0
09:49:05 <musasabi> yes, I am already using 1.0.1
09:49:15 <dcoutts> ok
09:52:50 <SyntaxNinja> cabal!
09:52:52 <dcoutts> SyntaxNinja, when you/we/someone does the build-tools-depends: feature, it'd be nice if Cabal refuses to use any tool that's not explictly listed there. That way we can force package authors to give correct dependencies. :-)
10:01:05 <basti_> @pl \x y -> x==y
10:01:06 <lambdabot> (==)
10:01:06 <basti_> argh
10:01:10 <basti_> @pl \(x,y) -> x==y
10:01:11 <lambdabot> uncurry (==)
10:03:28 <SyntaxNinja> dcoutts: hm. interesting idea
10:04:00 <SyntaxNinja> dcoutts: it would be better, IMO, if there were just a warning, since if we made a mistake there, it would cripple their build.
10:04:43 <SyntaxNinja> most of the warnings come during configure... we could try to do it then, but that means trying to figure out what tools they need.
10:04:44 <Igloo> There should at least be a flag to make it an error
10:05:03 <Igloo> I don't really understand what you mean, though
10:08:06 <dcoutts> SyntaxNinja, but if it's only a warning it would cripple our build :-)
10:09:27 <dcoutts> SyntaxNinja, so long as the warning is visible to the pacakge author that would be ok, though as Igloo says making it fatal would be an useful safty feature for us packagers who worry about untracked dependencies
10:09:51 <dcoutts> or at least allowing it to be made fatal with some flag
10:10:59 <dcoutts> SyntaxNinja, anyway it'd only cripple their build for 10 seconds while they go fix the .cabal file and start building again. I'm sure the error message could tell them exactly what they need to do.
10:12:53 <SyntaxNinja> dcoutts: what I'm saying is, what if we mess up in such a way that it's not possible for them to express the tool dependency correctly, and so they cannot build their system at all.
10:13:01 <SyntaxNinja> but yeah, a --force option or something might do the trick.
10:13:27 <SyntaxNinja> for instance, let's say that the system requires c2hs > 1.0, but the 1.2 version has changed the --version string, so cabal can't figure out what version of c2hs is installed
10:13:39 <SyntaxNinja> (since it can't parse the output from --version)
10:13:56 <SyntaxNinja> so there's an error, even though no error really exists, and the packager is screwed.
10:14:04 <dcoutts> then they bodge it by just saying: build-tool-depends: c2hs
10:14:08 <dcoutts> with no version number at all
10:14:20 <SyntaxNinja> so we can specifically try to not mess up in that case, but I'm just saying that there might be tricky cases out there that would cause the system not to build.
10:14:29 <SyntaxNinja> and not leave the author with a workaround.
10:14:43 <SyntaxNinja> but I kinda like hte idea of making it an error, with a --force option available.
10:14:44 <dcoutts> I'mnot sure our tool dependencies are that complex are they?
10:14:55 <SyntaxNinja> you mean without versino numbers?
10:15:11 <dcoutts> yes, without a version number
10:15:21 <dcoutts> then cabal would not try to check the c2hs version number
10:15:37 <dcoutts> (which we already agreed is tricky for cabal to do)
10:15:41 <SyntaxNinja> I think they'll have version nubmers in the dependencies, at least for gentoo / debian and humans, if not for the simple build infrastructure itself.
10:15:53 <SyntaxNinja> anyway, that was just an example of my concern.
10:16:28 <dcoutts> I think it would be perfectly ok for Cabal not to check version numbers itself (except ghc) and leave that to package management systems
10:17:00 <dcoutts> yes ok, I think you're right, default to fatal error and allow --force as a last resort workaround for package authors
10:40:42 <dcoutts> musasabi, did you get a chance to try that c2hs patch? is it ok to send on to Manuel?
10:52:59 <musasabi> dcoutts: just tested it, seems to solve the problem and work fine.
10:55:25 <mwc> dcoutts: you already got my blessing on it
10:55:30 <mwc> musasabi: you on OS X too?
10:57:27 <musasabi> mwc: no, that was about a patch to c2hs fixing hierarchical namespace support.
10:57:37 * musasabi runs BSDs and linux at home.
10:57:40 <mwc> ah
10:57:54 <mwc> so then its a completely different issue than mine
10:57:58 <musasabi> yes.
10:59:19 <musasabi> Has anyone gotten cabal + foreign export to work? I get linker errors when trying to use the produced library complaining the foreign exported symbol (living in the _stub.c) is undefined.
11:06:52 <SyntaxNinja> musasabi: you need a newer cabal
11:07:10 <SyntaxNinja> musasabi: that wasn't implemented until 1.1.1
11:08:54 <dcoutts> musasabi, ok thanks a lot for testing it, I'll send it to Manuel
11:09:20 <musasabi> darcs 1.0.2 seems to crash when pulling from cabal repository, I'll try via the darcs get route.
11:14:40 <mwc> That's some mighty powerful netsplitting today
11:41:01 <astrolabe> How is the expression a b $$ c parsed if  and $$ have the same precidence, but one is infixr and the other infixl?
11:44:46 <Igloo> I think you get an error
11:45:58 <wilx> Well...I would say left to right.
11:46:11 <wilx> (a LL b) $$ c
11:46:17 <dcoutts> astrolabe, what does ghc say?
11:46:35 <arjanb> it's an error according to haskell report
11:46:51 <wilx> The r part of infixr only says that when there is more of this operator in line it is right associative.
11:46:52 <astrolabe> dcoutts_: I don't know.
11:47:06 <wilx> Strange.
11:47:37 <astrolabe> arjanb:  Where in the report is it?
11:48:52 <arjanb> http://www.haskell.org/onlinereport/exps.html#expressions
11:50:15 <astrolabe> Thanks.
12:02:50 * Beelsebob sits around looking bored
12:02:53 <Beelsebob> entertain me!
12:03:06 <Beelsebob> *g*
12:03:19 * Lemmih starts juggling on his unicycle.
12:03:36 <Beelsebob> oh oh oh! Do rubensteins!
12:05:11 <Beelsebob> lemmih, you going to IFL?
12:05:24 <Lemmih> IFL?
12:05:49 <Beelsebob> International workshop on functional languages (insert other words here that I can't remember)
12:05:53 <Beelsebob> and I'll take that as a no
12:05:55 <Beelsebob> *g*
12:06:21 <Beelsebob> was wondering if we could do a joint talk on how to pass clubs on unicycles *g*
12:07:02 <Lemmih> (:
12:07:27 <SyntaxNinja> Beelsebob: ICFP?
12:07:51 <Beelsebob> fraid not... budgets won't stretch to ireland *and* estonia
12:12:05 <SyntaxNinja> ooh, ireland?
12:13:41 <Beelsebob> Dublin
12:13:56 <Beelsebob> https://www.cs.tcd.ie/ifl05/
12:35:11 <RemiTurk> good evening
12:35:20 <Lemmih> Yo.
12:36:18 <Igloo> Any opinions on http://urchin.earth.li/~ian/haskell2.html ?
12:41:20 <RemiTurk> the two h98 addendums won't cause much flamewars I'd think :)
12:41:48 <Beelsebob> rather than heredocs how about tripple quoted strings (ala python)
12:41:58 <Igloo> What's one of them?
12:42:27 <Beelsebob> you start a string with """ and end it with """, anything in between is taken as verbatim
12:42:28 <dcoutts> Igloo, I certainly agree with the "datatypeconstraints" one
12:42:28 <Igloo> Hmm, maybe just allowing \n in strings, actually
12:42:36 <Beelsebob> including new lines etc
12:43:27 <RemiTurk> I certainly agree that _something_ should be done about the problem "datatypeconstraints" is about, but I'm not sure _what_ solution would be best
12:43:43 <Igloo> Is there another proposal?
12:43:52 <RemiTurk> I don't know
12:44:05 * Igloo doesn't know of any others, and can't see any issues with this one
12:44:45 <dcoutts> Igloo, I don't understand the recordaccessor one
12:44:46 * RemiTurk sees (and once a year/month/whatever actually encounters) a problem, but didn't think all that much about solutions
12:45:02 <Beelsebob> I don't like the flexiblesection idea
12:45:31 <dcoutts> Igloo, can't you just not export Foo or foo to get the implementation hiding that you want
12:45:31 <RemiTurk> I'm not sure about it either, though I'd quote like something simpler than \x -> (x,1)
12:45:53 <Igloo> dcoutts: I want "foo bar" to work but not "bar { foo = 3 }"
12:46:52 * RemiTurk agrees with removing the monomorphism-restriction, and wouldn't mind at all if ~ would be reserved for unary negation (I hope it wouldn't clash with lazy patterns?)
12:47:00 <dcoutts> Igloo, so they can be used as acces but not for update?
12:47:14 <Igloo> yup
12:47:32 <Igloo> RemiTurk: Oh, hmm, good point
12:47:33 <dcoutts> yeah, ok I see
12:47:38 <RemiTurk> and actually, I really don't like the current record update syntax. I'd much prefer update-functions
12:47:59 <Igloo> I think it's just about OK as negative patterns have to be numeric literals, I think
12:48:56 <dcoutts> Igloo, for flexiblesection: how about (,1) instead of (_,1)
12:49:03 <Beelsebob> that would work
12:49:04 <dcoutts> Igloo, it matches (,)
12:49:28 <Beelsebob> in fact... would it be possible to make (,) a function
12:49:29 <Igloo> dcoutts: Doesn't work with user defined datatypes
12:49:32 <RemiTurk> hm
12:49:33 <Beelsebob> that tupples things
12:49:34 <Speck> Igloo, wouldn't polymorphic types work for your "partialtypes" section?
12:49:38 <Igloo> (,) /is/ a function
12:49:39 <dcoutts> Igloo, otherwise in your syntax (,) = (_,_)
12:49:51 <Igloo> Speck: HDYM?
12:49:52 <dcoutts> hmm
12:49:53 <RemiTurk> "f ~42 = ()" gives "f undefined => ()"
12:49:56 <Beelsebob> igloo... then why can't I just use ((,) 1)
12:50:00 <Speck> HDYM?
12:50:15 <basti_> Beelsebob: i can do that!
12:50:24 <basti_> Beelsebob: i just can't show the result.
12:50:26 <Igloo> Beelsebob: You can, but the cases for (_,2) and (_,2,_) are much uglier
12:50:41 <Igloo> HDYM = How Do You Mean
12:50:43 <Beelsebob> ((flip (,)) 2)
12:50:47 <Beelsebob> isn't that bad
12:50:48 <RemiTurk> and I wouldn't mind if tuples became syntax sugar for something HList-like
12:51:03 <RemiTurk> (so "fst" would return the first element of _any_ tuple)
12:51:12 <Speck> Igloo, I don't get what you mean I guess. You say it isn't polymorphic with regards to the second element of the tuple, but it seems to be :-|
12:51:13 <basti_> Template Haskell?
12:51:44 <Beelsebob> igloo: in that case... why not make an extension to sections for infix operators in general... so I can write (2 (,))
12:51:53 <Beelsebob> and it automatically flips (,)
12:52:31 <Beelsebob> or (2 (-)) etc.
12:52:35 <basti_> sad that `(,)` doesnt work
12:52:52 <basti_> would be really readable =)
12:53:06 <Speck> ack. gtg home now. later all
12:53:16 <RemiTurk> (http://www.haskell.org//pipermail/haskell-cafe/2005-March/009321.html for my tuples-as-syn-sugar idea)
12:53:21 <RemiTurk> bye
12:53:35 <Igloo> Speck: The idea is that is has type    (a, Just (Just (Just Int))) -> (b, Just (Just (Just Int))) and we want to constrain a and b without having to write out the rest of the type
12:53:46 <RemiTurk> Beelsebob: (2 (-)) can be a valid haskell expression right now
12:53:49 <basti_> actually i think simplicity is more important than generality in that case
12:54:03 <Beelsebob> remi: I never said it would be backwards compatable ;)
12:54:09 <Igloo> Beelsebob: 2 (,) already has a meaning. Also, it won't help for (,,)
12:54:13 <basti_> actually that stuff is *really* general, more general than most stuff i've seen
12:54:45 <Igloo> Thanks all for your comments, BTW!
12:54:55 <RemiTurk> np
12:55:22 <RemiTurk> MPTC + FD I'm not sure about, given the current research on associated (data)types
12:55:35 <dcoutts> Igloo, I'm still hoping that someone comes up with a better general solution than MPTC+FunDeps+Undecidable instances
12:55:40 <basti_> oh i know why `(,)` doesnt work.
12:55:54 <basti_> (a,b) is already the infix form of ,
12:56:01 <basti_> it wouldn't make anything better writing it without ()
12:56:07 <RemiTurk> circuminfix? ;)
12:56:13 <basti_> .)
12:56:14 <dcoutts> it starts out nice but gets incomprehensable eventually (see HList)
12:56:18 * Igloo doesn't really care how it works as long as I can use the idiom at the bottom and the StateT monad transformer  :-)
12:56:39 <Igloo> dcoutts: So just don't use HList class stuff
12:56:48 <dcoutts> I don't :-)
12:56:55 * basti_ wants lambda matching first =)
12:57:09 <dcoutts> basti_, oh yes, that'd be nice
12:57:09 <basti_> far more important...
12:57:14 <RemiTurk> dcoutts: have you read the associated (data)types papers? (they're _not_ equivalent though)
12:57:23 <RemiTurk> lambda matching?
12:57:39 <basti_> yes like case a of  (\x->y) ->
12:57:42 <RemiTurk> as in \1 -> True; \x -> False or something like that?
12:57:48 <basti_> yes
12:57:53 <basti_> where \1 wouldnt be valid
12:57:56 <dcoutts> RemiTurk, I've not, I'll get round to it eventaully
12:58:21 <dcoutts> basti_, and if you're adding patterns then you also get gaurds
12:58:31 <RemiTurk> dcoutts, they were an interesting read, though I'd have to read them again to be able to say much more useful about them ;)
12:58:38 <dcoutts> \x | condition -> ...
12:58:39 <basti_> dcoutts: that wouldnt make much sense though
12:58:56 <basti_> dcoutts: it would be equivalent to the "are 2 functions equal?" problem
12:59:09 <dcoutts> basti_, huh?
12:59:30 <basti_> i mean... suppose you have a function like f x = f (x-1)
12:59:45 <RemiTurk> "case a of  (\x->y) ->" does sound like a solution for the halting problem... is that what you mean?
12:59:54 <basti_> RemiTurk: :P
13:00:13 <basti_> (halting problem is equal to function equality? or even stronger?)
13:00:39 <dcoutts> \x | condition1 -> ...
13:00:40 <dcoutts>    | condition2 -> ...
13:00:40 <dcoutts>    | otherwise -> ...
13:00:47 <dcoutts> I don't see the problem
13:00:48 <goron> Ah.. the halting problem is easy. Step 1 wait an infinite time Step2 Check whether the program halted.        ;)
13:00:56 <RemiTurk> lol
13:00:57 <Beelsebob> lol
13:00:58 <basti_> dcoutts: not all conditions might be easily recognized.
13:00:59 <basti_> lol
13:01:18 <Beelsebob> @paste
13:01:19 <dcoutts> basti_, it's exaclt the same as with a named function
13:01:19 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:01:25 <basti_> dcoutts: we're not talking about the same problem.
13:01:28 <RemiTurk> you cannot, in general, have instance Eq (a->b) without solving the HP
13:01:32 <dcoutts> basti_, ok :-)
13:01:39 <basti_> dcoutts: i just didnt recognize it
13:01:46 <RemiTurk> which is a bit what "case a of (\x -> y) -> ..." seems to suggest
13:02:05 <basti_> RemiTurk: but you *could* have a function that recognizes if a value needs a parameter or not
13:02:10 <basti_> i doubt it would make much sense though.
13:02:14 <RemiTurk> certainly
13:02:15 <dcoutts> basti_, so what is lamda matching? (I thought you meant pattens in lambdas)
13:02:26 <RemiTurk> one might even define a typeclass for it? (using undecidable instances probably)
13:02:41 <basti_> dcoutts: you can recognize if a value needs a parameter ("is a function") or not.
13:03:03 * RemiTurk runs for his tea
13:03:16 <basti_> you could check if there's a -> in the type at runtime
13:03:34 <Beelsebob> what do I need to add to this to get the pretty yellow boxen? http://www.haskell.org/hawiki/HaskellIrcQuotePage
13:03:46 <Beelsebob> note... IRC Quote page :)
13:03:58 <Beelsebob> and... can we add @quote to lambdabot?
13:04:32 <basti_> it would need some semantics... like... what happens to the matched variable?
13:05:13 <basti_> It's "just kidding" type of stuff though. It is possible to achieve similar effects via the type system, so you don't strictly need it
13:06:02 <efuzzyone> question, data Quadruple a b  = Quadruple a a b b; firstTwo (Quadruple u v x y) = u:v  , whats mistake am I making?
13:06:24 <basti_> v isnt a list.
13:06:31 <basti_> try u:v:[] maybe?
13:06:56 <basti_> you know that you can have this sort of things easier? ;)
13:07:14 <Beelsebob> anyone on how to add the pretty yellow boxen?
13:07:25 <basti_> Beelsebob: why dont you look how the others did it?
13:07:42 <Beelsebob> I've been trying to figure it out
13:07:51 <Beelsebob> I can't see any difference in what I did and what they did
13:08:06 <Beelsebob> ah... newlines
13:08:14 <basti_> :)
13:08:16 * Beelsebob smacks head
13:08:58 <basti_> efuzzyone: ?
13:14:53 <basti_> i like that, asking questions and then not reacting :)
13:16:28 <dcoutts> basti_, interesting, do you have any link describing lambda matching a bit more?
13:18:26 <basti_> dcoutts: its "just kidding" type of stuff. I suspect it is (in the way i formulated it) equal to the halting problem or something. If you want to do something like that, search for "scrap your boilerplate"
13:18:44 <dcoutts> basti_, oh ok
13:19:05 <basti_> its entirely possible to do something similar, it just isnt formulated as "matching away lambdas"
13:19:21 <dcoutts> right
13:19:41 <basti_> TH does this at compile time, and "scrap your boilerplate" does it at runtime
13:20:24 <basti_> you could do something like data FunOrVal a = Fun (a->(FunOrVal a)) | Val a
13:33:20 <SyntaxNinja> dcoutts: are you happy with the direction of the cabal discussion?
13:34:51 <flodin> hmm do you think there's a way you could prove, in some situations, that two infinite lists are the same?
13:35:27 <flodin> for instance, if I define fib [1, 1] ++ [(a+b) | (a, b) <- zip fib (tail fib)] then i know that fib == fib
13:35:43 <flodin> but if i type "fib == fib" ghc will eat up all my memory and die
13:36:33 <CosmicRay> shapr: ping
13:36:43 <lament> sounds like not something computers are good for
13:37:13 <flodin> the reason i ask is that i'm toying with an infinite-precision library and it's working nicely for adding and subtracting but i can't compare if two results are the same
13:37:55 <flodin> 10/3 == 10/3 would loop forever
13:37:59 <flodin> comparing 3's
13:38:41 <flodin> *number library
13:39:42 <astrolabe> flodin: I think comparing two infinite lists wouldn't be possible, but maybe you could compare generation rules under some circumstances.
13:40:09 <flodin> yeah essentially "fib" is the generation rule, and you can see that fib == fib
13:42:01 <lispy`> wouldn't you store 10/3 as a rational?  then surely you could put both in lowest terms and compare the integer components?
13:42:03 <astrolabe> I guess you would need the generation rules in a more abstract form than haskell code.   To spot 10/3 = 10/3 is easy if you store them as rational numbers.
13:43:01 <flodin> well i'm only storing sign, mantissa and exponent. The computation for the mantissa continues infinitely, but you only need to print as much of the value as you need
13:43:22 <flodin> the exponent essentially just gives a multiplication factor, since the mantissa is always between 0 and 1
13:43:57 * lispy` feels strongly that arbitrary precision should be done over the field of rationals
13:43:59 <astrolabe> I don't think you can do it then.
13:44:02 <musasabi> SyntaxNinja: I updated to the latest cabal from CVS but the foreign external errors continue.
13:44:22 <astrolabe> lispy: but what about square roots?
13:44:31 <lispy`> astrolabe: approximate :)
13:44:43 <astrolabe> and what about 1 e -100?
13:45:01 <lispy`> astrolabe: not sure what number that is
13:45:05 <flodin> lispy`: to me it seems that whatever method you use to store there will always be numbers that can't be represented. Unless you provide possibility for an infinite number of decimals
13:45:13 <astrolabe> 10 ^ (-100)
13:45:44 <astrolabe> You can represent all reals with an infinite continued fraction.
13:45:48 <lispy`> astrolabe: are you worried about the space required to store that?
13:46:09 <astrolabe> lispy: Yeah, space and the time to compute with them.
13:46:23 <lispy`> astrolabe: do it lazily :)
13:46:39 <astrolabe> flodin:  You would want to recognise that 0.99999... = 1.00000...
13:47:26 <flodin> possibly, but for now i'll be happy if 0.99999... = 0.99999
13:47:42 <lispy`> a lot of implemenations with arbitrary precision floats require an implicit or explicit number of digits to be given.  A sort of cut-off on computations.
13:48:19 <lispy`> take for example, dc
13:48:56 <lispy`> if you type 3k 10 3 /p it will print 3.333
13:50:07 <astrolabe> Maybe you could do arbitrary precision with continued fractions, but I think that when you wanted an answer out, the computation would take a long time.
13:50:33 <lispy`> astrolabe: well, and how do you know what the continued fraction should be, in general?
13:51:04 <lispy`> and there are equivalent continued fractions that a computer may not be able to compare directly
13:51:34 <flodin> i think i will just see if x-y is sufficiently close to 0
13:51:36 <astrolabe> lispy:  I don't understand the question, and isn't this what you meant by doing arbitrary precision with rationals?
13:52:05 <astrolabe> Can you give an example of equivalent ones?
13:52:14 <lispy`> astrolabe: perhaps my stance isn't as clearly thought as i had thoguht :)
13:52:54 <lispy`> astrolabe: no, and i have to go in a few minutes, but they must exist
13:53:06 <lispy`> i'm sure we can figure a couple out if we work at it
13:53:15 <astrolabe> I think knuth has stuff about rational arithmatic
13:53:27 * RemiTurk comes back from his tea.
13:53:28 <lispy`> oh, i bet he would
13:53:57 <astrolabe> I think that if you demand that the numerators are 1, then the representation is unique.
13:54:11 <flodin> *Main> take 10000 fib == take 10000 fib
13:54:11 <flodin> True
13:54:11 <lispy`> astrolabe: that may be true
13:54:21 <astrolabe> It might take an infinite amout of time to calculate the first term though :)
13:55:00 <lispy`> astrolabe: there may be a weaker assumption than numerator is 1 to get uniquness
13:55:21 <lispy`> maybe gcd(numerator,denominator) =1 for each term
13:56:14 <astrolabe> 1+5/3 == 2 +2/3
13:56:49 <lispy`> so perhaps they can only have on term which is > 1, and the gcd=1?
13:57:19 <astrolabe> 1+2/1 = 2+ 1/1  :)
13:57:24 <lispy`> astrolabe: but that's probabbly the same as the one you suggested
13:57:45 * RemiTurk wonders what the difference between HaskellIrcQuotePage and QuotesPage (on the hawiki) is supposed to be
13:57:59 <dcoutts> SyntaxNinja, re: cabal discussion, yes I'm quite happy with the way things are going
13:58:08 <lispy`> astrolabe: in that example tho, it's important to note that our system would say 1/1 = 1
13:58:09 <astrolabe> Yeah, I think the numerator=1 continued fractions have nice properties.
13:58:14 <lispy`> astrolabe: and same with 2/1
13:58:52 <astrolabe> Yeah, sorry I also meant that denomonators were >1
13:59:23 <lispy`> with the exception of the firt term right?
13:59:31 <astrolabe> At each stage forming the fraction, you subtract the whole-number part, and then invert.
13:59:31 <lispy`> it's okay for that one to have a 1 for the denom?
13:59:37 <lispy`> okay
13:59:43 <lispy`> well, i gotta go
13:59:46 * lispy` waves
13:59:49 <astrolabe> Ok  byeeee
14:03:34 <Excedrin> is it possible to define functions at the Hugs top level without :loading a file?
14:03:53 <basti_> try something like:  let f x = x+1
14:04:04 <basti_> just works in ghci though
14:04:27 <Igloo> It's not possible in hugs
14:04:42 <astrolabe> You could use (\x -> x+1) 5 of course.
14:05:06 <RemiTurk> or let f x = x + 1 in f 5
14:05:36 <RemiTurk> which is a poor substitute for ghci's let, IMO
14:05:49 <basti_> i'm rarely feeling the urge to do so, though
14:12:02 <Enveigler_> dcoutts: How do I handle bigendian versus littleendian when marshalling binary data?
14:17:23 <dcoutts> Enveigler_, there is no special support as far as I know. You can do the appropriate bit twiddling in Haskell code however.
14:17:52 <dcoutts> Enveigler_, see the ghc Binary.hs module for an idea of how to do effecient low level bit twiddling
14:19:56 <Enveigler_> Thanks. It's mostly byte swapping rather than bit-twiddling but I'll take a look.
14:22:44 <dcoutts> Enveigler_, the bit of code in Binary.hs for reading writing 64 bit ints does the sort of byte level things you want
14:29:16 <dcoutts> SyntaxNinja, I think Brian will be able to make a build system with his IDE that implementes the cabal interface (and has many more features that only the IDE uses) but I think it's not doable to wrap an arbitary cabal-conforming build system and have the features that his IDE needs.
14:32:27 <RemiTurk> good night
14:33:38 <Enveigler_> Is there an html or ftp interface to the haskell source tree?
14:34:04 <dcoutts> SyntaxNinja, and in my opinion, that's a perfectly reasonable way for things to stay
14:39:16 <musasabi> Enveigler_: see http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/
14:40:55 <Enveigler_> Thanks musasabi. Kinda hard to search for a particular file though.
14:48:43 <Enveigler_> Geez. That is clumsy.
14:49:19 <TheHunter> maybe you like CosmicRay's darcs repo better:
14:49:23 <TheHunter> @libsrc Prelude
14:49:24 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Prelude.hs
14:51:41 <Enveigler_> Sorry. I managed to located the file okay. It was the mechanism used to byte swap a 64-bit value that took me as rather cumbersome.
14:53:32 <Enveigler_> Oring all the 8 bit values out of the 64-bit value and then oring them all back together. If you treat the 64-bit value as a string of 8 bytes and simply reverse them you achieve the same thing much more cheaply.
14:57:14 <SyntaxNinja> dcoutts: OTOH, I think VS just assumes that everyone is using the simple build interfac3e.
14:57:34 <SyntaxNinja> so maybe it would be good to have some way to tell if that's the case, idono.
14:57:59 <SyntaxNinja> but I don't want to encourage people to throw up their hands and say, "every package has to use the simple build interface"
14:58:20 <SyntaxNinja> actually, VS will "mostly" work for any package, I think, but just certain features aren't available unless the package works w/ Simple.
15:02:10 <musasabi> SyntaxNinja: should the foreign export thing work under the latest CVS cabal?
15:02:18 <SyntaxNinja> musasabi: yeah
15:03:25 <dcoutts> SyntaxNinja, right yes, people just need to be clear that it doesn't work with every build system, that infact it got it's own build system that uses the .cabal info.
15:03:54 <dcoutts> SyntaxNinja, or to put it another way, it's another implementation of the simple builb systesm without user hooks
15:04:49 <dcoutts> it implements the cabal interface, it doesn't (and can't) use it
15:05:07 <musasabi> it produces the dist/build/IOWrap_stub.o, but it doesn't get into the .a file with the cvs checkout of tonight.
15:18:53 <SyntaxNinja> musasabi: you're not using the stable branch or anything, are you? can you try it w/ the 1.1.1 tarball from the web page?
15:19:03 * SyntaxNinja spams libraries@ some more
15:19:24 <dcoutts> heh heh, I've been playing that game too
15:19:55 <SyntaxNinja> dcoutts: the way I see it is that I'd prefer to add cool features like brian is suggesting to cabal directly, and in a compiler and OS-independent way, rather than expose the innerds of cabal so people can use it in a very non-portable way.
15:20:18 <dcoutts> SyntaxNinja, sounds eminantly reasonable
15:20:24 <SyntaxNinja> I mean, he's saying that he needs more info from cabal so he can go around cabal to make building better, when really it's best to just make cabal smarter about building!
15:20:43 <dcoutts> indeed
15:20:44 <musasabi> "HSCabal-1.1.2"
15:20:45 <SyntaxNinja> is brian on here, by chance?
15:21:02 <dcoutts> the re-linking in --make is slated to go away
15:21:05 <SyntaxNinja> hm. I think 1.1.2 should work indeed.
15:21:19 <SyntaxNinja> dcoutts: oh yeah? I was going to implement a cabal workaround Real Soon Now.
15:21:37 <dcoutts> SyntaxNinja, and indeed there's no particular reason Cabal has to use --make, it's the obvious initial choice but not essential
15:21:40 <SyntaxNinja> but erum. is it actually GHC that does the linking?
15:21:50 <SyntaxNinja> I thought cabal did the linking itself.
15:21:54 <dcoutts> yes it's ghc doing the linking
15:22:09 <dcoutts> well for programs it's ghc
15:22:21 <dcoutts> for libs it's cabal invoking ar and ld
15:22:22 <SyntaxNinja> dcoutts: right.  for libraries cabal does it.
15:22:28 <musasabi> Is there a good way to debug this? It is not on the "ar" commandline as seen by -v9.
15:22:51 <SyntaxNinja> musasabi: what's that? the _stub files aren't listed in the "ar" command line?
15:22:56 <SyntaxNinja> musasabi: do you have the source handy?
15:23:16 <SyntaxNinja> go into Distribution/Simple/Build.hs and search for stubObjs
15:23:25 <dcoutts> SyntaxNinja, for example for all the evils of Gtk2Hs's automake-based build system it is very quick at rebuilding when little or nothing has changed
15:24:08 <SyntaxNinja> it's almost getting to the point that I only have time to integrate patches and not write new stuff myself.
15:24:19 <SyntaxNinja> unfortunitely, that's partly because I have to keep in sync w/ cvs by hand.
15:24:38 <SyntaxNinja> this is why Lemmih has to get off hsi butt and build the hackage tools on their server without making me have to do it :P
15:24:57 <dcoutts> SyntaxNinja, and that's because it's maintains a cache of the dependency tree in the form of file modification times, where as ghc --make has to read every file to build its dep graph
15:25:34 <SyntaxNinja> dcoutts: yeah, makes sense
15:25:44 * Igloo gets confued trying to explain the problem with hugs' now file IO and locale stuff
15:25:49 * musasabi looks at the source
15:25:58 <SyntaxNinja> dcoutts: I kinda like the idea of a cabal daemon, started w/ "./setup build --continuous"
15:26:15 <SyntaxNinja> then all the other tools can talk to cabal directly.
15:26:17 <dcoutts> that'd be interesting
15:26:34 <Lemmih> Is that portable?
15:26:47 <dcoutts> SyntaxNinja, so, it'd be a nice little project for someone to do to do a more make like implementation of (re)building
15:26:52 <SyntaxNinja> Lemmih: it would have to be done in a portable way; I'm sure there are portable ways... windows has sockets, right?
15:27:04 <dcoutts> yep, everyone's got sockets
15:27:26 <SyntaxNinja> dcoutts: yeah, and the big advantage there is that it would be portable to other compilers (like nhc, which doesn't have a --make flag)
15:27:41 <dcoutts> that's a good point too
15:27:56 <SyntaxNinja> hm. is there a higher-level communication mechanism, like xml-rpc, but via sockets?
15:27:56 <dcoutts> or a port of hmake to cabal
15:28:06 <dcoutts> DBus!
15:28:15 <SyntaxNinja> yeah, I tried ripping the dependency analysis tool out of hmake, but it was kinda ingrained.
15:28:27 <SyntaxNinja> I did clean i tup a bit to make it more possible, though.
15:28:36 <Lemmih> xml-rpc got lots of dependencies.
15:28:53 <dcoutts> you could ask the hmake author for some help
15:29:12 <SyntaxNinja> I keep hoping that malcolm will get excited about cabal and 1) port hmake features to cabal 2) rewrite hmake using the Distribution library  and 3) make cabal work for nhc98
15:29:18 <SyntaxNinja> oh, I've talked to him, he doesn't have a lot of time, though.
15:29:25 <dcoutts> ho hum
15:30:05 <SyntaxNinja> musasabi: the suspense is killing me.
15:30:41 <dcoutts> Lemmih, tell me about it! I was trying to package xml-rpc for Gentoo. lots of deps...
15:31:17 <dcoutts> and several of them dont have tarballs available or they've got wierd tarballs
15:32:25 <dcoutts> Lemmih, actually Igloo was right of course we do have to allow the tarball name to differ from the name of the .cabal file if we assume that multi-package cabal thingies will happen
15:33:01 <dcoutts> Lemmih, eg gtk2hs = { glib, gtk, glade, gconf, sourceview, mozembed, ... }
15:33:22 <musasabi> SyntaxNinja: stubObjs is calculated into [], altough "libModules pkg_descr" has the modules necessary.
15:33:45 <Lemmih> I can install them with cabal-get since they are in my local HackageDB. Made it easier to test cabal-get on my other machine.
15:33:59 <Lemmih> dcoutts: But that probably wont happen in a near future (:
15:34:06 <dcoutts> SyntaxNinja, what are your current thoughts on multi-package cabal thingies? Are you going for it or considering alternative approaches?
15:34:45 <dcoutts> it's not obvious that multi-package cabal things are necessary (and I speak as gtk2hs maintainer which is an obvious example of such a thing)
15:35:09 <dcoutts> because why can't they be split out into multiple cabal packages?
15:35:35 <dcoutts> if our tools can handle the deps then it doesn't increase the burden on the users too much
15:35:53 * musasabi starts looking at moduleToFilePath
15:36:24 <dcoutts> the main reason we package it the way we do now is so that there is a single tarball for users to download; ./configure; make install
15:36:50 <dcoutts> that's because the distribution tools have historically been lacking
15:37:49 <dcoutts> if hackage / distro package management tools make it easy to install multiple pacakges easily and deal with dependeicies then we wouldn't need to distribute in such a monolithic manner
15:38:50 <musasabi> SyntaxNinja: I think the problem is that the stub file is dist/build/IOWrap_stub.o when cabal is looking for dist/build/Network/GnuTLS/IOWrap_stub.o
15:39:12 <Lemmih> musasabi: That problem should be fixed in HEAD.
15:39:34 <dcoutts> afterall, what is the purpose in seperating a system out into multiple package size chunks if you're going to just tie them all together again
15:39:35 <Lemmih> s/should be/is/
15:39:55 <dcoutts> this would also reduce the need for optional sections
15:42:33 <musasabi> Lemmih: seems that HEAD is missing some patch to make it work (or then I have something seriously wrong)
15:44:54 <Lemmih> musasabi: What does line 514 in $fptools/ghc/compiler/main/DriverPipeline.hs say?
15:45:18 <Lemmih> (it should say: "| Just d <- odir = d `joinFileName` persistent")
15:45:31 <musasabi> umm that is ghc not cabal ;)
15:45:45 <Lemmih> Indeed. It was a bug in GHC.
15:45:59 <musasabi> ahh.
15:46:03 <SyntaxNinja> dcoutts: yeah, the multiple cabal packages per tarball is mostly for convinience of packagers and source tarball users.
15:46:45 * SyntaxNinja is glad lemmih knew
15:47:00 <dcoutts> SyntaxNinja, are there any plans for it? I'd love to convert Gtk2Hs to use Cabal.
15:47:03 <Lemmih> musasabi: GHC ignored the path of the output file if an output directory was specified.
15:47:26 <SyntaxNinja> dcoutts: yes, it's top on my list
15:47:31 <SyntaxNinja> after patches
15:47:37 <dcoutts> SyntaxNinja, oh ok, cool.
15:48:09 <dcoutts> SyntaxNinja, any hints on how it might look / work?
15:48:16 <musasabi> if I add the IOWrap_stub.c as c-sources cabal puts it into the archive two times.
15:48:38 <SyntaxNinja> dcoutts: I haven't really thought it through... I think basically you'll have multiple .cabal files in one tarball, and they can depend on each-other
15:48:46 <SyntaxNinja> thenc abal does a dependency analys between them to see which one to build first
15:49:14 <SyntaxNinja> that's basically all there is to the idea, I guess.
15:49:32 <SyntaxNinja> it's very useful in the situation where you hav ea handful of executables which depend on a single library.
15:49:39 <dcoutts> right. you know that they don't actually need to be registerd first, even if there are deps between the packages
15:50:04 <dcoutts> the Gtk2Hs build system does not register it's packages in a local package database
15:50:17 <dcoutts> it increases build parallelism too
15:50:27 <Lemmih> musasabi: You can link it into the right directory.
15:50:28 <SyntaxNinja> it'll probably register them locally, in case the register step is required for them to work.
15:50:58 <dcoutts> I don't think it is required (unless the hooks depend on it)
15:51:01 <SyntaxNinja> musasabi: yeah, add an ln or move or something to preBuild or something?
15:51:35 <dcoutts> SyntaxNinja, since it's new behaviour you can say it's not going to register them untill they're all done
15:51:45 <SyntaxNinja> dcoutts: well, it might be kinda tricky because a package might have information like what include directries to look at, etc, basically anything in .ghc-packages
15:51:53 <SyntaxNinja> I mean, register them locally
15:52:16 <SyntaxNinja> so if we don't do a register step, then we have to duplicate all that tricky behavior that ghc-pkg / ghc take care of with the -package flag.
15:52:19 <dcoutts> that's ok too, all the Gtk2Hs packages have differnt includes
15:53:20 <dcoutts> I guess that's true, using -package foo saves you having to keep those command line args about
15:53:47 <dcoutts> well I'd suggest you specify that it will not necessarily register them locally, to leave it open
15:53:49 <SyntaxNinja> yeah. so there may be some trickiness still, I'm not sure.
15:54:18 <dcoutts> it's an advantage because it keeps the dependency tree much looser which reduces rebuilds
15:55:26 <SyntaxNinja> how's that?
15:55:30 <dcoutts> it means you typically get a rebuild whenever the package changes rather than just a module that you use in the package changing
15:56:06 <dcoutts> each module that imports something from the package now depends on every module in the package rather than just the modules it uses
15:57:05 <SyntaxNinja> yeah, it depends I guess; it'll still be possible to write things the old way
15:57:14 <dcoutts> and increasing the ability to do parallel builds is also nice, using make -j2 (or soon: ghc --make -j2)
15:57:27 <SyntaxNinja> so if you don't want MyMain.hs to depend on myLib.a, then you should do it the old fassioned way
15:57:43 <SyntaxNinja> by making MyMain depend only on the modules it needs to depend on
15:57:49 <dcoutts> I'm just suggesting you specify it in such a way that it leave the option open to that style of implementation
15:58:11 <SyntaxNinja> but I think people in gneeral would prefer the abstraction where the Main modules (or whatever) depend on the whole package / lib rather than individual modules.
15:58:19 <SyntaxNinja> even if it means longer comp times in some situations.  maybe I'm wrong.
15:59:00 <dcoutts> they can think of it that way, but underneath you can extract advantages by not implementing it that way
15:59:47 <SyntaxNinja> perhaps; but in practice, it's a little hard to do.  probably we'll do it the "wrong" way first and then someone will submit an optimizing patch ;)
16:00:38 <dcoutts> sure, so just leave the option open by not saying that there will be a register hook invoked before any other modules in other packages start to be built
16:01:00 <dcoutts> just don't specify it such that it over-serialises the build steps
16:01:19 <dcoutts> we can make it really take advantage of it later
16:01:33 <dcoutts> initially just do what's quickest to implement :-)
16:04:21 <Lemmih> @seen shapr
16:04:22 <lambdabot> shapr is in #haskell. Last spoke 7 hours, 22 minutes and 43 seconds
16:04:22 <lambdabot> ago.
16:06:25 * SyntaxNinja nods
16:06:33 <dcoutts> SyntaxNinja, interestingly, we found that our build system became simpler when we removed the intermediate package registration
16:08:39 <dcoutts> SyntaxNinja, you've read the paper "recursive make consider harmful" ?
16:21:26 <SyntaxNinja> dcoutts: yeah.
16:22:03 <SyntaxNinja> dcoutts: that's a good paper; that's one thing that helped me realize two things 1) make is little more than a glorified dependency analyzer and 2) most people don't even use the dependency analizer right ;)
16:22:13 <dcoutts> yeah :-)
16:23:01 <dcoutts> So the Gtk2Hs build system works mostly like that, whole project build from the top level dir. Quite different than say the fptools system.
16:23:36 <dcoutts> We really can run make and have it do nothing and only take a fraction of a second to that :-)
16:24:06 <SyntaxNinja> the build system works mosty like what exactly?
16:24:29 <dcoutts> like as reccomended in that paper
16:24:47 <dcoutts> 'whole project make' with one single dep graph
16:26:11 <dcoutts> the results are quite good but the implementation is not so nice, make + automake are just not nice!
16:29:25 <SyntaxNinja> yeah, it's hugely difficult to get a single directory graph and to make it flexible.
16:30:11 <dcoutts> and to make it flexible? I'm not sure I know what you mean
16:34:00 <SyntaxNinja> the advantage of recursive make is in its modularity
16:34:09 <dcoutts> sure
16:34:31 <SyntaxNinja> but monolitic make is the correct way, but now you have one big make system instead of a bunch of small ones
16:34:41 <dcoutts> though one can use various 'include' techniques
16:34:53 <SyntaxNinja> right (that's why I said "system" instead of "file")
16:35:00 <dcoutts> right
16:35:19 <SyntaxNinja> but even then, I have found it to be more fragile than recursive make because changing things in one place impacts everything else
16:35:39 <dcoutts> but that's because it really does impact everywhere else :-)
16:35:45 <dcoutts> recursive make it just hiding it
16:36:06 <dcoutts> (or it's because there are unnecessary deps)
16:36:33 <dcoutts> but yes, building the correct dep graph is not at all easy
16:36:35 <SyntaxNinja> I mean that altering one bit of hte make system impacts changes elsewhere; not that changing a single file impacts the whole tree (which is correct)
16:36:50 <dcoutts> oh, ok
16:37:00 <SyntaxNinja> like, let's say you move a file, in recursive make, you change the makefile in that directory
16:37:12 <SyntaxNinja> but with monolithic make, you gotta go elsewhere and find where that file is mentioned
16:37:19 <SyntaxNinja> although you could use includes to fix that, so it's not a good example, I guess.
16:37:32 <dcoutts> I was just about to say... :-)
16:38:01 <dcoutts> also, it's not much use using make as an example here since we all agree that it is horrible :-)
16:38:25 <dcoutts> there are many things we could do more simply if make we're not such a horrible language
16:38:29 <SyntaxNinja> even if I can't come up w/ an example ;)
16:39:09 <dcoutts> my main gripe is that it's ability to handle generated deps is very poor
16:39:43 <dcoutts> ie deps that you don't actually know until you're part way through the build
16:39:52 <SyntaxNinja> yeah
16:40:39 <dcoutts> eg you only know the deps between all the .hs/.hi/.o files once you've run cpp + c2hs over the .chs files to get the .hs files
16:47:41 <dcoutts> SyntaxNinja, here's an offer: we've got two new gentoo recruits who have been working with us on gentoo haskell + cabal packaging issues with us (they were the primary authors of recent patches we've sent). I'm going to be away for a couple weeks but if you've got any small features you want implemented (especially if it'll help packagers) then ping kosmikus and see if we have any spare patch-writing capacity :-).
16:49:00 <dcoutts> SyntaxNinja, you know of course we're interested in things like ./setup register --local and ./setup configure --with-optimisations
16:50:53 <Igloo> Is anyone who knows about Windows programming around?
16:51:27 <musasabi> It seems that the GHC from yesterday still gets the _stub files wrong - although in a different way.
16:51:41 <Lemmih> musasabi: How so?
16:51:54 <musasabi> It creates dist/build/src/Network/GnuTLS/IOWrap_stub.o and Cabal looks for dist/build/Network/GnuTLS/IOWrap_stub.o
16:52:24 <Enveigler_> Igloo: I know some?
16:52:25 <musasabi> where src is from hs-sources-dirs.
16:52:25 <Lemmih> Heh.
16:52:57 <Igloo> I've heard that Windows uses unicode for filenames; do you know any details on that?
16:53:00 <Lemmih> Don't think that is a GHC bug though.
16:53:21 <Igloo> e.g. what type would the file opening function take on Windows?
16:53:47 <musasabi> Lemmih: a cabal one then?
16:53:57 <musasabi> it works if I don't have hs-sources-dirs.
16:55:40 <Lemmih> Actually, it most definitely is a GHC bug. The [M]_stub.o file should be placed together with M.o.
16:56:19 <efuzzyone> !lisppaste
16:56:43 <Lemmih> lisppaste2: url
16:57:23 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
16:58:13 <Enveigler_> There are two APIs CreateFile() and CreateFileA(). The former takes a standard c string, the latter takes a double-byte char string. Is isn't exactly Unicode, but near enough to a utf-16 string for most purposes.
16:58:35 <Igloo> OK, thanks
16:58:43 <lisppaste2> efuzzyone pasted "datatype question" at http://paste.lisp.org/display/10331
16:58:57 <efuzzyone> Lemmih: thanks
16:59:43 <efuzzyone> I am trying to solve this question, and I have got the solution, but I don't like the way I have done it. Is there a better way to do it?
17:01:01 <Enveigler_> Igloo: Substitute CreateFileA() and CreateFileW() in the above.
17:01:15 <Enveigler_> A for ANSI and W for WIDE.
17:01:23 <Igloo> *nod*
17:02:26 <Enveigler_> For more info try http://msdn.microsoft.com/library/default.asp?url=/library/en-us/fileio/fs/naming_a_file.asp
17:09:47 <efuzzyone> or let me rephrase my question, is there any simple way of writing much shorter code for this question?
17:10:20 <SyntaxNinja> dcoutts: sounds good :)
17:10:35 <musasabi> efuzzyone: data TuppleMaybe4 a b c d = TupleM4 (Maybe a) (Maybe b) (Maybe c) (Maybe d)
17:11:03 <efuzzyone> what about the functions?
17:11:07 <SyntaxNinja> musasabi: can you please report that to the GHC guys?
17:11:14 <SyntaxNinja> they'll forward it to me (or fix it) if they think it's a cabla bug
17:11:39 <musasabi> SyntaxNinja: I'll try to make a simple test case in the morning.
17:12:08 <musasabi> efuzzyone: tupple1 (TupleM4 a _ _ _) = a, tupple2 (TupleM4 _ b _ _) = b
17:12:12 <efuzzyone> thanks, i think i can write the function
17:12:51 <SyntaxNinja> musasabi: actually, if it's a ghc bug, you can probaly just describe it, and simon will slap his forhead (again)
17:13:18 <SyntaxNinja> if it's a cabal bug, then simon can slap my forehead, figuratively
17:13:58 <efuzzyone> musasabi: the question, originally wanted me to have 4 constructors, so if I keep 4 different constructors, is that the only way? the function defined separately for different constructors.
17:14:44 <musasabi> efuzzyone: yes, if you want four different constructors then you want four different cases for the functions.
17:15:08 <efuzzyone> ok. thanks. it answers my question
17:16:55 <Igloo> Has anyone got any comments on http://urchin.earth.li/~ian/filenames.txt ?
17:17:16 <efuzzyone> musasabi: the code which you suggested, doesn't work
17:20:04 <musasabi> SyntaxNinja: I sent a mail with a description of the problem.
17:20:53 <efuzzyone> musasabi: Maybe gets a type conflict with integer/char types
17:21:35 <dcoutts> Igloo, mm, we have that problem in Gtk2Hs too, we don't know in what form to return file names from the file selector. Unicode means you can display it to the user. "Raw" bytes are probably needed to reliably open the file using standard IO functions.
17:21:56 <musasabi> http://youzen.b2.fi/~musasabi/a.hs worked for me.
17:23:29 <Igloo> You need to let the user decide what to do if conversion to unicode fails, so I think it has to be raw bytes for you
17:23:38 <efuzzyone> ok, the way I was expecting it to be called was wrong, I was thinking that I can directly pass integers/char, didn't realize that I need to use constructors to create those types. thanks
17:24:12 <dcoutts> Igloo, but we've even got a problem if conversion to unicod succeds
17:24:32 <dcoutts> because it might not convert back 1-1
17:24:38 <SyntaxNinja> musasabi: cool
17:25:01 <Igloo> Only if you normalise it
17:26:00 <Igloo> Anyway, given I think rawbytes is the answer, that's not an issue  :-)
17:26:15 <dcoutts> and the thing is 99% of the time it just works so it's a pain for app developers to have to use encdoding conversion all the time
17:26:23 <Igloo> (or maybe FileName in this proposal)
17:26:29 <dcoutts> maybe
17:26:57 <dcoutts> maybe (in a positive sense :-) )
17:28:00 <dcoutts> since it would allow you to get something which can be used a string in a UI or passed to openFile
17:31:34 <dons> moin
17:31:55 <dcoutts> morning indeed
17:32:18 <dons> mm. post-doc job at York
17:32:25 <dons> if only I was a post-doc
17:32:37 <dcoutts> :-)
17:35:29 <dons> @seen basti_
17:35:30 <lambdabot> I saw basti_ leaving #haskell 2 hours, 30 minutes and 28 seconds ago.
17:36:47 * Cale writes mathematica code... SymmetricTensorExp[m_Times, L_] := With[{ps := Permutations[Map[SymmetricTensor[#, L] &, MonomialFactors[m]]]}, MonomialCoefficient[m] (1/Length[ps]) Total[ Map[Apply[TensorTimes, #] &, ps]]]
17:38:06 * heatsink was extremely frustrated that Mathematica variables in recursive function calls behaved in no manner that I could undersand
17:38:35 <Cale> if you have some specific code, I can try to figure out what's wrong
17:39:28 <heatsink> It was a while ago; I don't have or need it anymore.  Thanks anyway.
17:39:39 <dcoutts> dons, yi feature request for the vim mode: make <ins> key do the right thing. ie it behaves like 'i' I think
17:39:44 <dons> Cale, if i squint, it looks like fp
17:39:57 <dcoutts> dons, or who does the vim keybindins for yi?
17:40:01 <dons> dcoutts, will do! easy-peasy
17:40:13 <dons> yep, i'm the everything but emacs* and joe guy
17:40:34 <dcoutts> dons, cool :-) I can only use vim, vi scares me!
17:41:08 <dons> hehe, yeah it's kind of like a broken vim
17:41:48 * heatsink liked ix better... vii and viii were premature releases
17:42:27 <dcoutts> indeed VIM is not even syntactially correct
17:42:44 <dcoutts> it should probably be MVI
17:42:50 <dons> yeah, <insert> is a synonym for `i'
17:43:05 <dcoutts> dons, I can darcs pull then?
17:43:17 <dons> not yet..
17:43:38 <dons> need to find key defn for insert
17:44:13 <lament> vim is not a number
17:44:16 <lament> it's a word
17:44:40 <lament> (vi is not a word, so it must be a number)
17:45:18 <heatsink> it's only a word in Esperanto.
17:45:30 <lament> oh, i'm sure it's a word in a bunch of languages.
17:45:46 <dons> keySIC
17:46:59 <dcoutts> dons, then the other feature I missed from vim was highlighting the search item
17:47:51 <dcoutts> dons, btw this doesn't turn into a huge list of missing vim features, I only actually use a very small number of vim features (mostly because I don't know the keys for the others!)
17:47:52 <dons> yeah, that's a todo
17:48:11 <dons> ok, try pulling that patch
17:48:16 <dcoutts> ok...
17:48:35 <dons> hmm. maybe not.
17:48:47 * dons should test more.
17:49:21 <Igloo> <ins> actually toggles between insert and replace modes when in one or the other, BTW
17:49:35 <dons> yeah, I saw that in the vim docs
17:49:38 <dcoutts> oh yes, true
17:49:48 * Beelsebob yawns
17:49:53 <Beelsebob> how goes it?
17:50:12 <dcoutts> not that such toggling is a useful thing, it trips me up more than it is useful
17:50:27 <dcoutts> in fact I don't even use replace mode
17:50:39 <dcoutts> I've never seen the use case
17:50:48 <dons> you don't use `R'
17:51:06 <Igloo> I use it, and toggle between the two, all the time
17:51:15 <dons> it's good to overwrite a sequence of chars without modifying the length of the buffer or line
17:51:42 <dons> so good for hacking binaries ;)
17:52:17 <dons> ah ha. <insert> == \331
17:52:26 <Igloo> Eeek
17:52:35 <Igloo> Don't you use curses or anything?
17:52:54 <dons> keyIC
17:52:59 <dons> yeah, I use curses
17:53:10 <dons> and was trying to work out what code <insert> mapped to
17:53:14 <dons> in this case, keyIC
17:53:42 <Igloo> Ah, OK. I think.
17:53:54 <dons> (keyIC is a curses name)
17:54:04 <Igloo> Why not just search in getch(3ncurses) though?
17:55:03 <dons> oh, I guess I could have done that ;)0
17:56:28 <Speck> what about the CDK bindings that cosmicray is doing?
17:56:39 <Speck> maybe not low-level enough
17:56:57 <dons> dcoutts, maybe try that
17:59:08 <dcoutts> dons, yay, that works :-)
18:01:30 <dcoutts> dons, so when do we get Haskell syntax highliting? :-)
18:01:40 <dons> I know I know.
18:01:47 <dcoutts> ;-)
18:01:47 <dons> it will have to be  done during August
18:02:00 <dons> since I want syn hl in my hw talk ;)
18:02:31 <dcoutts> syn hl hw?
18:02:55 <dons> sorry. yi-speak. syn hl == syntax highlighting. hw== haskell workshop ;)
18:03:07 <dcoutts> ah
18:03:16 <dcoutts> yes, that would be nice
18:03:17 <Beelsebob> oh dear... I can tell I'm not going to like that editer
18:03:34 <dcoutts> no syntax highliting for Beelsebob ?
18:03:55 <Beelsebob> no... no having to know that hl means syntax highlighting for beelsebob
18:04:04 <Beelsebob> I wrote the syntax highlighter for SEE
18:04:26 <dcoutts> ah yes well hopefully that just yi-developer-speak :-)
18:04:28 <dons> it doesn't mean hl in yi though ;) just in irc
18:04:49 <dons> yes, yi-developer-speak.
18:04:57 <Beelsebob> ah, akay
18:06:00 <dcoutts> dons, so you do a lot of your own buffer management, I fear that may not interact too well with ordinary gui text view widgets...
18:06:50 <dcoutts> the Gtk text view widget is MVC but only uses one implementation of the buffer, the buffer is not an interface
18:07:23 <dons> yeah, this is known. at least the window management isn't portable as is
18:07:41 <dons> we've got a draft ui typeclass for handling proper guis though
18:07:49 <dcoutts> so how would you cope, even in a system dependent way?
18:08:12 <dcoutts> you have different buffers for different UIs?
18:08:26 <dcoutts> so you can use an external buffer
18:08:37 <dons> no. maybe for gtk we'd have to pass a pointer to our buffer somehow?
18:08:44 <dons> it's just a byte array in C land
18:08:53 <dcoutts> the Gtk buffer isn't
18:08:55 <gzl> Beelsebob: the haskell one?
18:09:02 <Beelsebob> gzl: yes
18:09:27 <dcoutts> it contains tags and marks and who knows what else, it's more like a "piece table"
18:09:28 <gzl> Beelsebob: it doesn't highlight function names and arguments for me
18:09:35 <gzl> the only thing it seemed to do was 'do'
18:09:39 <Beelsebob> and yes I know... data types need to go in the menu
18:09:44 <Beelsebob> indeed it doesn't
18:10:02 <Beelsebob> it highlights keywords, type signatures and warious other gubins
18:10:11 <dons> hmm. it could be that the model used by text view widgets constrains the editor too much, or maybe there are commonalities
18:10:21 <Beelsebob> unfortunately, Haskell's too complex to recognise these things with just regexps
18:10:23 <dons> in which case we could have a GTKBuffer instance for the Buffer class
18:10:27 <Beelsebob> which is all SEE provides
18:10:43 <dcoutts> dons, yes perhaps, the gtk text buffer is quite flexable
18:10:45 <Beelsebob> comments and strings and the like
18:11:07 <dcoutts> but it is restricted to doing everything in IO, but then perhaps you are already
18:11:12 <dons> yep
18:11:20 <dons> mutable everything!
18:11:29 <dcoutts> heh heh heh :-)
18:11:33 <gzl> Beelsebob: I see
18:11:40 <dons> side effect me now!
18:11:59 <dcoutts> duncan kicks dons
18:12:08 <dcoutts> in the side
18:12:11 <dons> it's more like a state monad on io though, in practice
18:12:14 <Beelsebob> gzl: you'll note that I pull out function names for the menu... but the only way to do that is that any word preceeding a :: is a function name
18:12:23 <Beelsebob> which is a nasty hack
18:12:27 <gzl> ah, I see
18:12:40 <dons> just it uses an global IORef to hang on to these (possibly huge) buffers
18:12:45 <Beelsebob> I can't recognise actual function definitions
18:13:38 <Beelsebob> anyway... do you want function names coloured... and if so, what for?
18:14:00 <Beelsebob> surely the indenting shows you
18:16:50 <dcoutts> dons, what sort of oprtations do you need to do on your buffer? anything fancy?
18:21:53 <dons> nothing fancy. check the Buffer.hs class
18:22:12 <dcoutts> dons, and then control flow becomes more odd with a gui, it gets somewhat inverted because everytinh is events
18:22:35 <dcoutts> unless you use threads and have all gui events posted to a "yi buffer management" thread
18:23:02 <dcoutts> in which case it's more like a blocking "read a char at a time" sort of thing
18:23:13 <dcoutts> which is maybe the better approach
18:23:28 <dcoutts> unless you've already got the inverted event driven model
18:24:04 <dons> that's the way to go. we use threads already for gathering input
18:24:21 <dcoutts> ok, Gtk2Hs can do threads
18:24:31 <dcoutts> not so sure about wx...
18:25:34 <dons> but some restructuring was indicated by wolfgangT when he had a go at the wx ui for yi
18:26:06 <dons> I think he basically worked out what needed to change to support both kinds of uis
18:26:23 <dcoutts> oh ok, and he wasn't using threads
18:28:10 <dons> only the existing char-at-a-time-over-a-channel thread, I think
18:28:20 <dcoutts> right
18:28:53 <dons> I think he solved most of the issues by passing the yi functions he needed into the ui, so he could call back when events werre triggerred
18:29:23 <dcoutts> right, that's what I was thinking of when I said inversion of control
18:49:53 * Beelsebob punches cocoa
18:50:24 <SyntaxNinja> no violence
18:51:03 <Beelsebob> why not... it's being annoying
18:51:08 * dons drinks cocoa
18:53:17 <SyntaxNinja> Beelsebob: just let go of all references to it, and the runtime system will garbage collect it, and you will be at peace.
18:53:41 <Beelsebob> unfortunately cocoa doesn't do GC
18:53:50 <Beelsebob> referenece counting fun
18:54:30 <Beelsebob> and I will be at piece... with no money... I need to get the next release of defaulter out the door
18:56:41 <SyntaxNinja> what's defaulter?
18:58:22 <Beelsebob> http://www.dusoft.co.uk/defaulter.php
18:59:30 <Igloo> Woo. a php page that doesn't let my browser see its contents because it thinks it's IE.
19:00:55 <Beelsebob> hehe, well change your ident string
19:01:05 <Beelsebob> unfortunately IE completely fucks up that page
19:01:15 <Beelsebob> and sseing as I'm selling mac software, I don't give a shut
19:01:16 <Beelsebob> shit*
19:04:28 <Beelsebob> ohhh... new serenity trailer!
19:20:17 <SyntaxNinja> serenity!
19:20:25 <Korollary> serenity now !
19:21:25 <Beelsebob> http://www.apple.com/trailers/universal/serenity/trailer_2/large.html
19:22:31 <Korollary> ah
19:22:46 <Korollary> weird, I was just in the middle of installing quicktime.
19:57:24 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueThree","We put the Funk in Funktion"]' by TheHunter
20:06:17 <TheHunter> hmm, maybe it's really out...
20:06:29 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFour","We put the Funk in Funktion"]' by TheHunter
21:48:06 <wagle> wow..  what sleaze.  you download the serenity trailer from their website, and it tries to phone home
21:53:55 <wagle> (after taking an hour to download it)
21:55:11 <Enveigler_> @index getCOntents
21:55:12 <lambdabot> bzzt
21:55:15 <Enveigler_> @index getContents
21:55:16 <lambdabot> System.IO, Prelude
21:55:33 <Enveigler_> @docs Prelude.getContents
21:55:33 <lambdabot> Prelude.getContents not available
21:55:39 <Enveigler_> @docs Prelude
21:55:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
21:57:10 <wagle> @docs getContents
21:57:11 <lambdabot> getContents not available
21:57:32 <wagle> oh well
22:03:33 <lispy_> serenity?
22:04:11 <lispy_> a movie?
22:04:25 <Enveigler_> @index liftM
22:04:26 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
22:04:26 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
22:04:26 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
22:05:58 <Enveigler_> @type Control.Monad.liftM
22:06:07 <lambdabot> forall r (m :: * -> *) a1.
22:06:07 <lambdabot>         (Monad m) =>
22:06:07 <lambdabot>         (a1 -> r) -> m a1 -> m r
22:07:03 <lispy_> @eval liftM (+1) [1..2]
22:07:09 <lambdabot> [2,3]
22:09:30 <lispy_> @eval liftM head (Just [1..10])
22:09:51 <lambdabot> Just 1
22:11:57 <Enveigler_> Here's the problem, I'm reading a file using readFile which gives IO String. I want to break that down into a list of words, but words takes String. So how do I apply words to an IO String?
22:12:25 <dons> do s <- readFile ; let w = words s
22:12:33 <dons> or with liftM, to be fancy
22:14:40 <dons> @type Monad.liftM words $ readFile "f"
22:14:41 <lambdabot> IO [String]
22:14:58 <dons> @type readFile "f" >>= return . words
22:15:00 <lambdabot> IO [String]
22:15:28 <dons> @type do s <- readFile "f" ; return ( words s )
22:15:30 <lambdabot> IO [String]
22:15:31 <dons> etc etc.
22:16:14 <Enveigler_> type readFile
22:16:31 <Enveigler_> @type readFile
22:16:33 <lambdabot> FilePath -> IO String
22:16:42 <Enveigler_> @type words
22:16:43 <lambdabot> String -> [String]
22:17:43 <Enveigler_> How does do s <- readFile ; let w = words s, Allow words to take s::IO String?
22:18:09 <dons> it doesn't, it removes the IO from the string, and passes the pure value to words
22:19:04 <dons> s  :: String in the above
22:19:32 <Enveigler_> in do s <- readFile?
22:20:06 <dons> yeah
22:20:33 <Enveigler_> so <- is removing the IO
22:21:24 <dons> it is syntax for binding variables to values returned from IO computations
22:22:26 <dons> same as readFile "f" >>= \s -> let w = words s  ...
22:23:24 <dons> we have some moand tutorials around here somewhere, they might be worth a read
22:23:27 <lispy_> Enveigler_: if you think of a monad as a container then yes <- is syntatactic sugar for removing the container
22:24:20 <dons> right. whereas I was working with the monads as sequential computation model, which is supposed to be more confusing :}
22:27:46 <lispy_> dons: i find that overwhelming people with many different perspectives is the best way to confuse them ;)
22:28:50 <dons> yeah. I'm sorry, I wasn't being a particularly good tutor
22:29:31 <lispy_> dons: i'm just teasing
22:29:47 <lispy_> you were doing fine, i just wanted to throw in my $0.02
22:30:58 <dons> sometimes I forget and just throw code a people, oh well
22:32:09 <dons> Enveigler, seriously, we do have some well written tutorials about monads. I think they're on the wiki
22:32:24 <dons> @where hawiki
22:32:25 <lambdabot> http://haskell.org/hawiki/
22:33:03 <lispy_> @where monads
22:33:04 <lambdabot> I know nothing about monads.
22:33:10 <lispy_> lambdabot: liar!
22:33:23 <Enveigler_> dons: I've almost certainly read them
22:33:33 <dons> lambdabot's full of monads, and really is a liar it seems
22:36:07 <palomer> hrm, the literature on monads sucks:O
22:36:11 <dcoutts> hey dons, how do I tell lambdabot that I'm on holiday so if wonder where I've gone it can tell them :-)
22:36:13 <palomer> I wish there was a SICP for monads
22:36:20 <palomer> are there any books that explain them well?
22:36:54 <liyang> (They're big scary things from category theory! Despair! ;_;)
22:37:03 <dons> dcoutts, oh, that's a good idea. an @away would be useful
22:37:18 <dons> or a @reallyaway
22:37:44 <dcoutts> @reallyaway I'm performing in a play at the Edinburgh Fringe Festival, back in two weeks.
22:37:45 <lambdabot> Unknown command, try @listcommands.
22:37:55 <dcoutts> :-)
22:37:59 <dons> ok. will hack now!
22:38:17 <dcoutts> you've not got long, my bus goes in an hour! :-)
22:38:50 <liyang> Bus? To Edinburgh? Are you insane? o.O
22:38:59 <wagle> "The Littl Monader"
22:39:05 <wagle> "The Little Monader"
22:39:25 <dcoutts> liyang, no bus to Cablridge to rehurse for a week then train to Edinburgh.
22:39:33 <dcoutts> Cablridge/Cabmbridge
22:39:57 <liyang> ah. :)
22:40:11 <dcoutts> look, it's me!: http://www.twoshadesofblue.org.uk/twoshades.php?cast=display#company
22:40:31 <liyang> What play will you be in? I could point people your way. :) (Gah. Already typed this line.)
22:40:32 <dcoutts> (with much less hair than I have now :-) )
22:41:07 <dcoutts> We're doing two plays, I'm in "The Wind in the Willows"
22:41:24 <dcoutts> i'm playing the Chief Weasel
22:41:49 <dcoutts> but we're more like ultra-nast resivor dogs style ganster weasles :-)
22:41:52 <palomer> wagle: the little monader is a book?
22:41:54 <dons> cool!
22:41:55 <dcoutts> excelent fun
22:42:04 <dons> @karma+ dcoutts
22:42:04 <lambdabot> dcoutts's karma raised to 1.
22:42:34 <dcoutts> hah! You're supposed to tell me to break a leg, not rais my karma :-)
22:43:01 <palomer> man, I wish I went to a swank american university
22:43:08 <dcoutts> I particularly like the bit in the play where we get to beat the **** out of Mole. heh heh heh
22:43:17 <dons> @karma- dcoutts
22:43:17 <dons> @karma- dcoutts
22:43:17 <lambdabot> dcoutts's karma lowered to 0.
22:43:18 <lambdabot> dcoutts's karma lowered to -1.
22:43:26 <dcoutts> Sorry, just getting into character. Ahem.
22:43:35 <dons> hehe
22:44:43 <dons> bah, too hard to modify @seen quickly. i'll look at the idea though
22:45:16 <dcoutts> oh yes that'd be the most useful since that's what people check most when they're after someone
22:45:48 <dons> yeah, I was thinking that if @seen said you were away, it could check a map of nicks to msgs for an optional reason why you're not here
22:46:14 <dons> just need to extend the @seen state a little
22:46:42 <dcoutts> dons, hmm, but I was thinking of still being in the channel, since my machine will still be on
22:47:01 <dcoutts> so even though I'm here, I'm really not
22:47:24 <dons> oh, ok. so we make it an alternate seen state, here/nothere/here-but-not-really-here
22:48:44 <dcoutts> hmm, I wonder if my irc client will help.
22:49:08 <dons> yeah, set an /away value for now
22:49:17 <dons> though lambdabot is good if you're not connected at all
22:49:24 <dcoutts> dons, If I mark myself as away for a sec, you address a remark to me. See if my irc client reports an away message to you
22:49:39 <dcoutts> ok I'm marked as away
22:49:56 <dons> "-- dcoutts is away: I'm away on holiday
22:50:09 <dons> that was via a msg
22:50:16 <dons> dcoutts: testing
22:50:21 <dons> does nothing though
22:50:26 <dcoutts> oh, ho hum
22:50:35 <dcoutts> that would be more useful
22:51:19 <dons>  /whois should also report your status
22:51:25 <dcoutts> true
22:51:53 <dcoutts> well I better carry ow with packing...
23:21:11 <Enveigler_> @type readRoads = do x <- readFile "data"; return $ words x
23:21:17 <lambdabot> bzzt
23:24:07 <Enveigler_> @type do x <- readFile "data"; return $ words x
23:24:09 <lambdabot> IO [String]
23:27:32 <Enveigler_> @docs Control.Monad.liftM
23:27:33 <lambdabot> Control.Monad.liftM not available
23:27:45 <Enveigler_> @docs Control.Monad
23:27:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Monad.html
23:53:58 <Enveigler_> @type return $ liftM  words $ readFile "route.dat"
23:54:03 <lambdabot> bzzt
23:54:16 <Enveigler_> @type liftM  words $ readFile "route.dat"
23:54:17 <lambdabot> bzzt
23:54:42 <Enveigler_> @type Monad.liftM  words $ readFile "route.dat"
23:54:44 <lambdabot> IO [String]
23:54:52 <Enveigler_> @type return Monad.liftM  words $ readFile "route.dat"
23:54:53 <lambdabot> bzzt
23:55:00 <Enveigler_> @type return $ Monad.liftM  words $ readFile "route.dat"
23:55:02 <lambdabot> forall (m :: *
23:55:02 <lambdabot>                        -> *).
23:55:02 <lambdabot>                   (Monad m) =>
23:55:02 <lambdabot>                   m (IO [String])
23:59:31 <lispy_> @type do { f <- readFile "route.data"; return (words f) }
23:59:33 <lambdabot> IO [String]
