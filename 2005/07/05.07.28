00:04:52 <shapr> @yow !
00:04:53 <lambdabot> Now that I have my "APPLE", I comprehend COST ACCOUNTING!!
00:05:01 <shapr> Good morning #haskell!
00:05:10 <vikasg> morning shapr
00:05:16 <dblhelix> morning, shapr
00:05:20 <shapr> How's code in the rest of the world?
00:05:21 <Korollary> bon jour
00:05:42 <shapr> salut Korollary, parlez vous fran√ßais?
00:06:05 <dblhelix> code's fine, but I have some troubles bringing joy to the rest of the world... allow me to elaborate
00:06:21 <Korollary> shapr: nope
00:06:35 <Korollary> code is bloated, undertested and rushed out the door to "meet the customer's expectations"
00:06:42 <dblhelix> a good friend of mine, actually my former business partner, is a pretty good coder
00:07:07 <dblhelix> however, he's not a believer yet: he does that stuff with imperative languages and so
00:07:26 <shapr> Korollary: Sounds familiar. I'm self-employed, so I have the luxury to push for high quality solutions that cost the customer more in the short term but less in the long term.
00:08:16 <dblhelix> but he is willing to have a look at functional programming now
00:08:30 <shapr> dblhelix: Cool! Bring him by #haskell!
00:09:03 <dblhelix> however, he does not get excited just by writing a fibonacci program or anything
00:09:14 <Korollary> nor do I, actually
00:09:20 <shapr> We can show him what we like about FP, and maybe he'll find something that interests him too.
00:09:42 <dblhelix> what he is looking for is (quote:) a small little coding project that makes him think "wow, this kicks ass, haskell kicks ass, I kick ass!"
00:09:53 <Korollary> is the yi code well commented ?
00:10:21 <shapr> dblhelix: darcs? pugs?
00:10:26 <Korollary> that's something a perl coder would say
00:10:42 <dblhelix> shapr: not quite sure if that qualifies as small
00:10:52 <Korollary> I thought yi would qualify
00:11:17 <dblhelix> Korollary: mmm, perhaps
00:11:18 <shapr> It's hard to have something that's both small and uniquely nifty.
00:11:32 <dblhelix> shapr: yeah, that's the problem
00:11:57 <shapr> I'm writing a bittorrent client, the code is small.
00:12:09 <Korollary> it doesnt have to be nifty per se. It ought to be a project familiar to many, and well commented.
00:12:18 <Thu21670> you get paid for writing haskell bittorrent clients?
00:12:24 <shapr> Nah, I'm doing this for fun.
00:12:35 <dblhelix> it would be cool if he could write something that's immediately useful to him
00:12:52 <shapr> Does he use Bittorrent?
00:13:10 <dblhelix> shapr: I'm not sure, could be
00:13:35 <Korollary> under 100 lines of code, haskell doesn't beat other languages in productivity per se unless the subject is highly algorithmic. Typically java or perl will dominate by the sheer size of their libraries.
00:13:56 <shapr> I only have parsing code so far, though it's nearly done.
00:14:04 <dblhelix> he dove into Lua some time ago and wrote a small extension for a game he is writing that let users easily configurate stuff etc.
00:14:16 <shapr> Yeah, Lua is cool that way.
00:14:25 * shapr uses ion3
00:14:53 <dblhelix> a learned phyton and wrote a utility for publishing his web pages per ftp...
00:15:07 <dblhelix> so, I guess, he is looking for that kind of experience
00:15:34 <dblhelix> /s/a learned/he learned
00:15:54 <shapr> You could point him to parsec, that's probably Haskell's killer application.
00:17:01 <dblhelix> shapr: yes I thought of that, but perhaps I should make him write his own parser combinators first, then let him have a look at monads, and then introduce him to parsec
00:17:40 <reffie> parsec rocks
00:17:42 * dblhelix can't remember how he became a believer in the first place (seems so long ago)
00:18:35 <shapr> Parser combinators are pretty amazing any.
00:18:38 <shapr> anyway
00:20:13 <dblhelix> I'll think about his some more and send him an e-mail this afternoon
00:20:18 <dblhelix> thanks guys
00:20:43 <dblhelix> shapr: if I lure him into coming to #haskell, will you give him the tour?
00:20:51 <shapr> Sure yeah, if I'm here.
00:21:10 <dblhelix> aren't you always? :)
00:21:44 <shapr> Not always ;-)
00:22:43 <Thu21670> luring an unwary person into haskel tttt
00:23:02 <shapr> I'd say it's just showing them another good option for programming.
00:23:20 <Korollary> does anyone use Nice with Java ?
00:23:47 <dblhelix> Thu21670: who guided you on your first steps in the Haskell world? Jeroen F.?
00:24:22 <Thu21670> nooo, it was mr Wishnu with a very vague story about command and conquer
00:24:50 <Thu21670> after that i thought haskell was horsecrap
00:24:57 <Korollary> lol
00:25:08 <dblhelix> yeah, for me it was Wishnu too :)
00:25:51 <Thu21670> amongst friends we have a well known saying referring to that class "now we have foo, we can make world"
00:26:17 <dblhelix> it took the course on grammars and parsing to make me a Real Believer
00:26:50 <vikasg> I seem to be able to use Parsec without really understanding monads. Is that a bad thing?
00:27:05 <dblhelix> vikasg: no, that's fine
00:27:13 <Thu21670> dblhelix, believer in what way?
00:27:37 <dblhelix> Thu21670: that haskell is Good
00:28:40 <dblhelix> vikasg: I think it's critical for successfully learning haskell that monads can be used without really knowing the concept in detail
00:29:16 <vikasg> just get a gut feeling for them, you mean?
00:29:21 <dblhelix> nam reputate: every program lives in a monad to begin with
00:29:25 <Thu21670> i think its critical for monads to be succesful haha
00:29:50 <dblhelix> vikasg: yes and then eventually read the "all about monads" tutorial
00:30:30 <kosmikus> if you can use both IO and Parsec without understanding the monad concept, then there's not really that much to learn anymore ...
00:30:31 <vikasg> I tried reading it already and couldn't make much of it :)
00:30:34 <Thu21670> i dont think there was a moment for me when i thought....ow hellll yeah haskell is tha shizznit.....i was just like...ok...haskell...fine by me
00:30:35 <lightstep> it's misleading. i read it, and i still don't understand what a monad is
00:31:01 <dblhelix> vikasg: don't try to find your way through it in just one day... take your time and you'll do fine
00:31:37 <vikasg> dblhelix, every now and then I seem to get a pretty good handle on monads, and then it just slips away ...
00:31:43 <Thu21670> yeah, have a nice hot cup of coco and do monads and arrows in one evening :P
00:31:48 <vikasg> I'm waiting for the day of enlightenment :)
00:31:49 <dblhelix> vikasg, lightstep: i'm aware of monads being hard to teach
00:32:12 <Thu21670> i had a course where doaitse crashed in all the monads basically hahaha
00:32:21 <kosmikus> dblhelix: but why is that?
00:32:27 <Thu21670> it gave me that "now we have foo, we can make world" experience
00:32:34 <kosmikus> I definitely found "foldr" much harder to understand than monads
00:32:39 <Thu21670> yeah
00:32:48 <Thu21670> i agree with kosmikus. foldr was sooo magical
00:32:55 <dblhelix> Thu21670: AFP? "get your brain cooked in 45 minutes?"
00:33:10 <Thu21670> dblhelix, yeah...hey maybe you were in that class with me
00:33:15 <Thu21670> now i think of it
00:33:29 <lightstep> dblhelix, the typeclass is not that hard. but i don't know the definition of a monad (i do know the definition of a monoid, for example)
00:33:33 <dblhelix> kosmikus: I learned about folder through augusteijn's paper... that made it real easy
00:35:48 <dblhelix> kosmikus, lightstep: it's hard to explain what  binds the different monads on a more conceptual level than just being instances of a certain type class
00:36:04 <kosmikus> yes, but I don't see why that's necessary
00:36:44 <Thu21670> well, because we get AFP
00:36:45 <Thu21670> :)
00:36:53 <dblhelix> the Maybe monad is easy to grasp in isolation and so is the Reader monad, but why should one learn them in connection with each other?
00:38:13 <kosmikus> if I'm learning Haskell, I shouldn't be forced to learn CT, should I? nor is it really important to be able to "define my own monads" ...
00:38:18 <dblhelix> but if you do present them connected, people start wondering how they are connected and that info, I guess, just isn't there
00:39:00 <kosmikus> they're concepts that support a form of sequencing
00:39:07 <kosmikus> that's all the connection there is
00:39:19 <dblhelix> and that's enough, right?
00:39:39 <kosmikus> I wouldn't put any more theoretical burden on a poor Haskell learner
00:39:56 <dblhelix> generalizing map to fmap is useful on its own too, no need for CT there either
00:39:59 <Thu21670> me personally, i crave the sickness that is monads.
00:40:10 <Thu21670> thats why i crack my head over it on a regular basis
00:40:19 <kosmikus> you sound like Doaitse
00:40:28 <Thu21670> indoctrination maybe ;)
00:40:46 <Thu21670> call it brainWASH
00:41:00 <dblhelix> and what about monad transformers?
00:41:12 <vikasg> even learning CT wouldn't be so bad if someone had written "CT for Haskellers"
00:42:44 <jyp> CT?
00:42:52 <jewel> category theory
00:42:54 <Thu21670> ow those transformers reallllly hit the sickness factor with me
00:42:59 <jyp> ah:)
00:43:15 <Thu21670> i kind of like it when i look at something and i think...damnnn that's just plain sick
00:43:40 <Thu21670> maybe thats why im also a big fan of wildboys and viva la bam :p
00:44:05 <dblhelix> alarm went off in CGN... "get your brain cooked in 45 seconds"
00:44:07 <kosmikus> I'm not convinced of transformers
00:44:15 <vikasg> Thu21670, that's sick
00:44:32 <dblhelix> kosmikus: they work for me, but it's quite cumbersome sometimes
00:44:45 <dblhelix> kosmikus: I'm not convinced of any alternative either
00:44:49 <kosmikus> dblhelix: I definitely don't think it's necessary to learn about them at an early stage
00:45:05 <jyp> Nothing's sick with transformers... Think of a calculus of semantics, sort of
00:45:14 <dblhelix> I did fine not knowing about them for two or three years or so
00:45:33 <dblhelix> then came those memorable 45 AFP minutes with doaitse
00:46:05 <kosmikus> well, afp is afp after all
00:46:17 <dblhelix> because: why just teach all monads one can think of in 45 minutes, if one could also incorporate the theory of transformers :)
00:46:20 <Thu21670> jyp, if doaitse breaks it down to you about transformers.....
00:46:21 <Thu21670> it is
00:46:22 <Thu21670> :D
00:46:43 <Thu21670> but that's exactly why i like his classes so much lol :)
00:46:58 <jyp> m'kay :p
00:47:11 <dblhelix> afp was fun, anyway
00:48:37 <kosmikus> dblhelix: btw, is bastiaan on vacation currently?
00:48:55 <dblhelix> kosmikus: yes, he left last friday
00:49:03 <kosmikus> ok
00:49:42 <dblhelix> it seems like everyone is on vacation around here
00:50:33 <kosmikus> I recall that feeling
00:51:32 <dblhelix> it does explain the 2nd floor alarm going off at 9:45am, though
00:51:57 <dblhelix> not a time one expects to be the first
00:52:13 <dblhelix> one arriving
00:53:52 <Thu21670> or someone is 'moving' the computers again
00:53:53 <Thu21670> haha
00:54:24 <dblhelix> Thu21670: actually it was henk van lingen who triggered it, lol :)
00:54:58 <dblhelix> kosmikus: all settled in bonn? what will you and ralf be doing the next couple of months?
00:59:42 <kosmikus> all secret ;)
00:59:51 <dblhelix> :)
01:00:58 <Thu21670> certainly not to discuss on a channel where potential idea-hijackers reside
01:02:18 <Thu21670> @hoogle push
01:02:22 <Thu21670> @hoogle pop
01:04:21 <basti_> kosmikus: i'm not!
01:04:24 <basti_> whats up?
01:05:27 <basti_> I'll be off soon though
01:06:21 <kosmikus> basti_: you're not what?
01:06:49 <dblhelix> kosmikus, basti_: on vacation... other bastiaan
01:07:19 <basti_> ahh
01:07:24 <dblhelix> :)
01:07:27 <kosmikus> ahh
01:07:27 <basti_> theres another bastiaan with two a on here??
01:07:47 <dblhelix> not here (channel) but here (utrecht)
01:08:23 <dblhelix> in .nl it's hard to find one with one "a", actually
01:08:50 <basti_> yes thats why i'm written like that too... my mom had dutch parents
01:09:05 <Thu21670> ahhhh see now the circle is rond again
01:09:33 <kosmikus> :)
01:09:59 <basti_> .)
01:10:11 <Thu21670> i dont get it...why is (:) not in the List module?
01:10:12 <dblhelix> time to get some work done though: those programs don't analyse themselves
01:10:26 <dblhelix> Thu21670: it's in the prelude
01:10:35 <Thu21670> i know
01:10:39 <Thu21670> but why not in List
01:10:41 <kosmikus> basti_: you probably spend lots of time convincing everyone you can spell your name correctly
01:11:01 <dblhelix> prelude does not import List
01:11:17 <dblhelix> and [] is only defined once
01:11:18 <basti_> kosmikus: yes
01:11:21 <dblhelix> you do the math
01:12:52 <basti_> < bbl though
01:13:46 <Thu21670> im not good in math and i still think everything (within reason) concerning list should reside in List
01:14:35 <dblhelix> then you'll end up dismantling the prelude
01:15:26 <dblhelix> the prelude contains everything that is considered essential to common usage of the language... lists fit in that category
01:15:54 <Thu21670> true, although it struck me as confusion having to look in two places for stuff where i'd expect it to be in List
01:15:56 <dblhelix> but I'm really not up for a discussion on library design
01:16:04 <Thu21670> no, work
01:16:11 <dblhelix> :) yes, work
01:17:59 <kosmikus> hi ozone
01:49:39 <Thu21670> @pl (\x -> x ++ pipo)
01:49:40 <lambdabot> (++ pipo)
01:49:46 <Thu21670> fair enough
01:51:01 <jyp> @pl \x y z -> x y x z
01:51:02 <lambdabot> join flip
01:51:12 <jyp> ow yeah
01:52:07 <dblhelix> ?? which monad?
01:52:26 <dblhelix> @type Control.Monad.join flip
01:52:27 <lambdabot> bzzt
01:52:37 <dblhelix> @type join
01:52:39 <lambdabot> bzzt
01:52:46 <dblhelix> @type Control.Monad.join
01:52:48 <lambdabot> forall a (m :: * -> *).
01:52:48 <lambdabot>         (Monad m) =>
01:52:48 <lambdabot>         m (m a) -> m a
01:53:13 <dblhelix> which join is pl referring to?
01:53:45 <jyp> no idea :)
01:54:27 <jyp> haaaa...
01:54:54 <jyp> @type  \x y z -> x y x z
01:54:56 <lambdabot> bzzt
01:54:59 <jyp> :))
01:55:01 <dons> hehe
01:55:10 <dblhelix> ah, duh
01:55:30 <dons> jyp, re mark/point patch. nice :) maybe we could use an IntMap though?
01:55:31 <dblhelix> maybe pl should be hooked up to the type checker
01:55:54 <dons> well, we could just agree to only rewrite stuff that @type accepts, but that would be boring :}
01:56:19 <dblhelix> confusion is excitement?
01:56:34 <dblhelix> :)
01:56:46 <dons> well, it rewrites stuff without having to type everything.
01:56:50 <jyp> dons: maybe; after all the discussion on the libraries list I don't know which one is more efficient in our context...
01:57:02 <dons> so good for abritary chunks of code, without contexxt
01:57:18 <dons> @pl flip yi-code yi-code'
01:57:18 <lambdabot> flip yi - code yi - code'
01:57:35 <dons> oh, I should read the discussion, jyp
01:58:21 <dons> the point is accessed all the time, but I'm not sure if using a Map would cause any loss
01:58:25 <dons> I should profile
01:58:49 <jyp> Truth is I chose Map out of simplicity; in case we'd want another index type
01:59:01 <dons> ah!
01:59:07 <dons> another index type, eh?
01:59:22 <dons> what did you have in mind? strings?
01:59:25 <jyp> Or if a plain list should be preferred
01:59:47 <dons> oh, I assumed you rejected the [Int] for performance of lookup :)
01:59:48 <jyp> ... or plain arrays
02:00:14 <jyp> I just thought it was the most flexible solution
02:00:18 <dons> yeah, I'd use arrays if Map turns out to be slow, however, I shall quantify the cost
02:00:41 <dons> Map is ok for now
02:00:54 <dons> I'll do some profiling just to check though
02:01:22 <dons> did you try out the new implementation of C-x C-f ?
02:01:26 <jyp> I'm trying to find the benchmarks already done by others
02:01:32 <jyp> yup
02:01:34 <dons> does it behave the way you think?
02:01:39 <dons> you think it should?
02:01:42 <jyp> it does :)
02:02:15 <jyp> Only local keymap remains to be done iirc
02:02:24 <dons> well you can do that with a metaM
02:02:36 <dons> when switching to the minibuffer
02:02:46 <dons> pass in a  keymap containing the bindings you want
02:02:57 <jyp> what if I switch windows while in the minibuffer ?
02:03:15 <Thu21670> what's "duits grof volkoren tarwe-rogge zuurdesembrood" in english?
02:03:24 <dons> oh, we'd need  to rebind window switching to reset the normal bindings
02:03:28 <dons> this is a hack, yes.
02:03:54 <jyp> In the end I suppose we'll need buffer-local modes anyway, won't we ?
02:03:58 <dons> we can instead just associatee keymaps with buffers, and automatically switch
02:04:03 <jyp> so this can be deferred till then
02:04:07 <dons> yep.
02:04:55 <dons> a Map Unique Keymap in Editor could work, and window switch would use this to also throw a metaM to set the keymap
02:05:16 <musasabi> How are the plans for syntax highlighting in Yi ?
02:05:17 <dons> @babel en de duits grof volkoren tarwe-rogge zuurdesembrood
02:05:19 <lambdabot>  duits grof volkoren tarwe-rogge zuurdesembrood
02:05:33 <dons> @babel de en duits grof volkoren tarwe-rogge zuurdesembrood
02:05:35 <lambdabot>  duits grof tarwe rogge volkoren zuurdesembrood
02:05:40 <dons> maybe that's not .de ?
02:06:02 <dons> musasabi, the plans are in slowly defrosting..
02:06:13 <dons> and will be ready to eat soon, hopefully :)
02:06:21 <dons> once I run out of smaller things to hack on
02:06:41 * jyp 's fault :)
02:07:01 <dons> nah, I want emacs done. lots of people want that
02:07:56 * musasabi just wants something like vim with good Haskell support :-)
02:08:08 <Enveigler_> Thu21670: Something about "German (grof?) people rye-wheat sourdoe bread."
02:08:11 <jyp> Not that I worship emacs, but I really can't live without a decent emulation
02:09:06 <dons> a guiding principle of yi is that we should be able to emulate any editor keystroke interface -- i wrote a paper about it ;) so emacs should be finished
02:09:18 <Thu21670> Enveigler_, hey i think thats pretty accurate
02:09:22 <jyp> next I'll try to tackle the killring
02:09:55 <dons> sounds good.
02:09:58 <Thu21670> coarse-grain German rye-wheat sourdoe bread, that is what im eating
02:10:16 <Enveigler_> Thu: I couldn't figure what "grof" means though.
02:10:20 <dons> babel's just too dumb to know about that stuff?
02:10:29 <dons> @babel en de hello mr. robot
02:10:31 <lambdabot>  hallo Herr robot
02:10:35 <Thu21670> grof is like how coarse the grain in the bread is
02:10:41 <Thu21670> how processed it is
02:10:45 <dons> @babel en de my language robot is broken
02:10:47 <lambdabot>  mein Sprachenroboter ist defekt
02:11:03 <dons> hehe
02:11:05 <Enveigler_> Sounds tasty!
02:11:23 <jyp> what's the engine behind @babel ?
02:11:41 <dons> babelfish
02:11:47 <dons> @help babel
02:11:48 <lambdabot> usage: babel lang lang phrase
02:11:58 <dons> @google babelfish
02:12:00 <lambdabot> http://babelfish.altavista.com/
02:12:08 <mflux_> I wouldn't mind if babelfish had language recognition too
02:12:14 <mflux_> "anything to english, please"
02:12:43 <mflux_> I've sometimes accidently classified dutch as being german
02:14:45 <jyp> dons: what's the state/plans of ghci in hs-plugins btw ?
02:15:23 <dons> I'd like to add support for an eval based on ghci's bytecode interpreter
02:15:40 <dons> it's abit of work, but I've scheduled it for sometime in the next 10 months or so
02:15:59 <jyp> As you might have heard, I'd like to use that for rebindings
02:16:02 <dons> then we get a haskell prompt in yi, for one.
02:16:27 <jyp> instead of having to tag everything with strings
02:16:29 <dons> rebindings of the form: bind xyz some >>= yi >> code?
02:17:04 <Thu21670> Enveigler_, it is. It is so nutricious though :D i only have to eat a couple of slices a day
02:17:10 <jyp> maybe; I'm not sure to understand you code :)
02:17:30 <jyp> I thought; rebindind keys
02:17:43 <dons> rather than, say, keystroke macros? bindings of keys to sets of other, already bounds, keys?
02:18:04 <dons> keystroke macros can already be done -- just by having a dynamic table of bindings (see :map in vi/vim mode)
02:18:18 <dons> bindings to new haskell actions on the fly, that needs eval.
02:18:45 <jyp> I'll have a look at :map
02:19:08 <dons> you could, couldn't you, bind C-x C-f, say, to whatever action, say, C-x C-s is bound too?
02:19:17 <dons> just by updating the binding table?
02:19:46 <dons> (this kind of thing is much easier using the dynamically contructed lexer keymaps)
02:19:51 <jyp> I thought binding to any Action value defined
02:20:10 <dons> ah, right. any Action, using its Haskell name?
02:20:15 <jyp> up
02:20:16 <jyp> yup
02:20:31 <dons> yeah, so that needs eval
02:20:54 <dons> which also then lets us write new Actions
02:21:30 <dons> since eval is quite new, this is definitely research-ish, I think. But I already plan to work on this
02:22:07 <dons> but a simple version could already be done with hs-plugins compiled eval, a la @eval
02:22:19 <dons> like an @eval that has Yi code in-scope
02:22:33 <jyp> I also would like to accept to bind (Int -> Action) and automatically feed in the universal arguement
02:23:35 <jyp> that would require ":t" to work there too...
02:24:02 <dons> well, it would have to be well typed. i don't understand the problem here, though
02:24:20 <dons> (I don't know enough emacs yet to know about the universal argument ;)
02:24:30 <jyp> C-u stuff
02:24:43 <dons> oh, I know what it's bound to, just not what it does
02:24:51 <jyp> Ok :)
02:25:18 <stefanw> C-u is good for optional arguments
02:25:31 <jyp> well as I understand it commands can have an argument and emacs feeds the C-u stuff to them as appropriate
02:25:57 <dons> paprika$ grep --context=1 "c_ 'u'" Mg.hs
02:25:57 <dons>   ("universal-argument",
02:25:57 <dons>         [[c_ 'u']],
02:26:00 <dons>         errorE "universal-argument unimplemented"),
02:26:05 <dons> :}
02:26:21 <jyp> I got it more or less working in emacs2
02:26:30 <dons> ok, I will have a look.
02:26:33 <jyp> though it's a bit tedious as it is
02:26:47 <jyp> that's why I'd like type-reflection...
02:26:56 <jyp> It can be done using typeclasses as it is
02:26:57 <dons> hmm. Dynamics?
02:27:19 <jyp> but since I plan long-term... I'm gonna wait for the ghci stuff :)
02:27:24 <dons> I'm just a little reluctant to model the very lispish stuff in yi though
02:27:35 <dons> we should have nice haskelly versions instead.
02:27:44 <dons> but if its just an interface issue, then it doen't matter
02:27:46 <jyp> I'm all with you on this one
02:28:49 <dons> anyway, keep the commits rolling in :) we're up to 160 since the last release, so that's good progress
02:29:14 <jyp> It's just an idea to hande the argument; if you have a better one I'll be glad to implement it
02:29:24 <jyp> sounds good
02:29:36 <dons> the *true* minibuffer implementation is taking a bit longer, but I'll try to get it done by the weekend
02:30:12 <jyp> cool
02:31:57 <Thu21670> @pl (\x -> concat $ x : clown)
02:31:58 <lambdabot> join . (: clown)
02:32:50 <Thu21670> @type join
02:32:51 <lambdabot> bzzt
02:32:56 <Thu21670> @index join
02:32:57 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
02:32:57 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
02:32:57 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
02:33:07 <Thu21670> @type Control.Monad.join
02:33:09 <lambdabot> forall a (m :: * -> *).
02:33:09 <lambdabot>         (Monad m) =>
02:33:09 <lambdabot>         m (m a) -> m a
02:33:27 <mauke> ah, right
02:33:29 <Thu21670> @hugs join [[1],[2]]
02:33:30 <lambdabot> [1,2]
02:35:34 <jyp> dons: http://www.haskell.org/pipermail/libraries/2004-May/002189.html
02:35:45 <jyp> IntMap wins hands down :)
02:36:27 <jyp> ... and we can have a million marks in a buffer without much problems :p
02:36:55 <williamvergara> hi
02:37:03 <williamvergara> im a totally noob
02:37:12 <williamvergara> and i have a very easy question
02:37:21 <jyp> please ask :)
02:37:44 <williamvergara> im tryingo emplement the insertionsort in haskell
02:38:09 <dons> jyp, cool. maybe import IntMap in Yi.Map, and for ghc < 640 make IntMap a synonym for FiniteMap
02:38:18 <dons> then just import Yi.Map.IntMap
02:38:34 <williamvergara> ??
02:38:38 <dons> so we can use it for >= 640, but not break ghc 6.2.2 bulids
02:38:58 <dons> williamvergara, you're having trouble with the implementation?
02:39:17 <williamvergara> i mean, i want to write it
02:39:24 <williamvergara> dont load it
02:40:04 <dons> what are you having trouble with?
02:40:52 <williamvergara> lets go step by step
02:40:57 <williamvergara> here is the first line
02:41:31 <williamvergara> insertionSort :: (Ord a) => [a] -> [a]
02:41:53 <williamvergara> insertionSort xs = foldl einf[] xs
02:42:31 <williamvergara>   where einf :: Ord a => [a] -> a -> [a]
02:42:42 <williamvergara>     einf [] x = [x]
02:43:20 <williamvergara>     einf(y:ys) x | x>=y        =x:y:ys
02:43:49 <jyp> bzzt
02:43:53 <williamvergara>                              | otherwise = y: einf ys x
02:44:02 <williamvergara> thats it
02:44:37 <williamvergara> first, i dont understand quiete well which is the diference between => and ->
02:45:48 <jyp> Those are completely different things
02:46:00 <jyp> first be sure to understand what -> means
02:46:10 <jyp> then read up on type-classes
02:46:33 <williamvergara> i know what -> means
02:47:08 <jyp> You know what a type class is ?
02:48:47 * jyp is out for lunch
02:50:20 <williamvergara> i know
02:50:39 <williamvergara> but isnt it certainly more involved with object programming
02:50:47 <williamvergara> and not with functional programming?
02:50:52 <williamvergara> im just asking
02:51:18 <vikasg> type classes are not exactly "object oriented programming"
02:51:28 <dblhelix> williamvergara: class in OO is different from type classes in Haskell
02:51:52 <vikasg> type classes give you one kind of polymorphism
02:52:13 <dblhelix> williamvergara: if you do want to compare type classes with OO features, they are better mapped to interfaces
02:52:50 <dblhelix> williamvergara: but better to forget about OO completely when playing with Haskell :)
02:54:35 <vikasg> it must have been quite painful to program in Haskell before type classes
02:55:14 <williamvergara> ok
02:55:16 <dons> i guess it looked like lazy ML ;)
02:55:21 <metaperl> any darcsters here? why would darcs get http://ScannedInAvian.org/repos/craft-of\
02:55:21 <metaperl> -fp only get the original version of a file instead of the latest version?
02:56:08 <metaperl> the correct cmdline is:
02:56:08 <metaperl> darcs get http://ScannedInAvian.org/repos/craft-of-fp
02:57:23 <metaperl> but the question remains
03:02:50 <Thu21670> the OO part of ocaml appeared weird to me
03:02:55 <Thu21670> but it could just have been me
03:05:42 <vikasg> does anyone use the OO parts of Ocaml?
03:06:09 * vikasg Literate haskell is nice
03:08:43 <Thu21670> i never felt like using the OO part. but there is bound to be a group of people using that part of OCaml
03:08:50 <Thu21670> maybe even the majority...i dont know
03:09:34 <pejo> vikasg, looking at the book and C-- sources I'd say  they use the OO stuff.
03:11:13 <pejo> But take my statement with a grain of salt, I don't know Ocaml and noweb.
03:14:33 <dons> hehe
03:26:04 <vikasg> main = do args <- getArgs
03:26:11 <vikasg> how do I map putStr on args now?
03:26:25 <musasabi> mapM_ putStrLn args ?
03:26:47 <vikasg> oh, so there's an monadic version of map as well
03:28:12 <musasabi> yes.
03:29:34 <musasabi> Control.Monad contains lots of nifty functions.
03:29:44 <dons> @type map
03:29:45 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
03:29:47 <dons> @type mapM
03:29:48 <lambdabot> forall b (m :: * -> *) a.
03:29:48 <lambdabot>    (Monad m) =>
03:29:48 <lambdabot>    (a -> m b) -> [a] -> m [b]
03:29:53 <dons> @type foldl
03:29:55 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
03:30:28 <vikasg> ok
03:30:29 <dons> @type Monad.foldM
03:30:30 <lambdabot> forall a (m :: * -> *) b.
03:30:30 <lambdabot>      (Monad m) =>
03:30:30 <lambdabot>      (a -> b -> m a) -> a -> [b] -> m a
03:32:35 <musasabi> btw why isn't mapM_ defined as "mapM_ [] = return (); mapM_ (c:cs) = c >> mapM_ cs" (wouldn't that be more efficient than the current way) ?
03:35:09 <dons> hmm. mapM_ f as      =  sequence_ (map f as)
03:35:46 <dons> sequence_ ms     =  foldr (>>) (return ()) ms
03:36:24 <dons> I would agree with you musasabi, but I wonder if the inlining resolves this anyway
03:37:05 <musasabi> point, it shouldn't matter with -O
03:37:20 <jyp> dons: I recall there's a bug in intmap as in the 6.4 distro: http://www.haskell.org/pipermail/libraries/2005-July/004071.html
03:37:24 <musasabi> I didn't think of that.
03:38:20 <dons> jyp, oh, but  I think that was fixed (ah, but only in HEAD and stable)
03:39:51 <dons> well, you can leave it as is, if you want. maybe put a TODO
03:40:54 <kolmodin> JaffaCake: about the 'ghc-pkg best' command, do you think it should print hidden packages aswell or not? perhaps a --non-hidden flag?
03:41:58 <jyp> dons: as ToDo will I tag it
03:42:18 <musasabi> What is the good way to wrap time_t from with FFI (and get sensible values into Haskell) ?
03:42:25 <musasabi> s/from//
03:43:43 <vikasg> my code suffers from too many parentheses
03:44:01 <JaffaCake> kolmodin: I think 'ghc-pkg list Cabal' should list all Cabal packages (including hidden), and additionally we might need 'ghc-pkg latest Cabal' to list the latest version of Cabal
03:44:06 <vikasg> how can I better write putStrLn (show (length . words) fstr))
03:44:28 <jyp> use $ maybe
03:44:38 <JaffaCake> I think as far as possible we should ignore exposed/hidden
03:45:24 <jyp> vikasg: putStrLn $ show $ length $ words $ fstr
03:45:31 <vikasg> jyp, thanks
03:46:18 <jyp> vikasg: or, (putStrLn . show . length . words ) fstr
03:46:24 <dcoutts> JaffaCake, we were wondering if we could have a flag to make the ghc-pkg output more parseable?
03:46:49 <JaffaCake> sure, what did you have in mind?
03:46:52 <vikasg> I think the first version reads better
03:46:53 <dcoutts> JaffaCake, eg ghc-pkg list Cabal --some-sensible-flag-for-use-in-scripts
03:47:27 <dcoutts> kolmodin, any good suggestion for such a flag name?
03:47:44 <JaffaCake> what format do you want for the output?
03:47:48 <jyp> vikasg: me too, some don't
03:48:06 <dcoutts> JaffaCake, just a sequence of tokens seperated by spaces
03:48:31 <dcoutts> Cabal-1.0 Cabal-1.1.2 Cabal-1.2
03:48:43 <dcoutts> so ignoring which package file they come from
03:48:54 <JaffaCake> ok, so omit the package database filenames, and omit the parentheses for hidden packages?
03:48:56 <dcoutts> no commas etc
03:49:04 <kolmodin> dcoutts: that's the format of the output of my current patch
03:49:07 <dcoutts> yes, no parens
03:49:14 <JaffaCake> right
03:49:19 <kolmodin> except I kept the parentesis
03:49:33 <dcoutts> oh, not so sure about that one
03:49:52 <kolmodin> kosmikus idea, not mine :)
03:49:55 <dcoutts> kolmodin, for consistenct it should probably only be enabled by a flag
03:50:16 <dcoutts> kolmodin, also that way we can do: ghc-pkg list --parsable
03:50:27 <dcoutts> to get the full list in a convenient way
03:50:38 <kolmodin> dcoutts: yeah
03:51:25 <dcoutts> rather than the "ghc-pkg list <name>" being a different style to "ghc-pkg list" which would be a little inconsistent
03:51:44 <kolmodin> so 'ghc-pkg list MyPackage' lists the packages as usual but filtered and sorted
03:51:59 <dcoutts> yep
03:52:17 <dcoutts> and think of a good flag name for the other format
03:52:18 <kolmodin> add --parsable to get it in a single list without parentesis
03:52:41 <dcoutts> yes
03:53:14 <kolmodin> how about 'ghc-pkg latest/best'? should it show hidden packages?
03:53:43 <dcoutts> JaffaCake, your opinion was that it should right?
03:54:01 <JaffaCake> I think so, yes
03:54:38 <JaffaCake> if this is for gtk2hs, then you probably should be using -hide-all-packages
03:54:58 <dcoutts> JaffaCake, no this is for the gentoo package management
03:55:10 <JaffaCake> ah
03:55:38 <JaffaCake> for turning Cabal packages into ebuilds?
03:55:41 <dcoutts> I do use -hide-all-packages or maybe -hide-package glib for Gtk2Hs
03:55:45 <dcoutts> JaffaCake, yes
03:55:56 <dcoutts> we're trying to automate everything!
03:56:27 <JaffaCake> so why do you need to call ghc-pkg?
03:56:45 <dcoutts> so we can reflect the hackage collection in gentoo's dev-haskell/* category with the minimum of manual work
03:57:03 <JaffaCake> I'd have thought the cabal->ebuild would be independent of the environment
03:57:04 <dcoutts> sorry that was part of the previous bit, not an answer :-)
03:57:23 <JaffaCake> right, I think it's a great plan
03:57:33 <dcoutts> well the package management it more closely tied to the compiler that you might hope
03:58:06 <dcoutts> we're unfortunately mostly underneath the abstraction that cabal provides
03:58:26 <dcoutts> (which is sometimes tricky because we need more information than cabal tells us)
03:59:37 <dcoutts> fro example if we're going to allow multiple versions of libraries to be installed simultaniously then we need to use ghc-pkg
03:59:50 <dcoutts> we need to manually register and re-register packages
04:00:05 <dcoutts> because we can't run "./setup register"
04:00:54 <dcoutts> as that would either not work in the sandbox, or mean running 'arbitrary' programs as root on the live filesystem which would be rather agains gentoo packaging policy :-)
05:03:53 <Thu21670> lol
05:04:20 <Thu21670> my two days were spent on some library that turned out to be interesting but not obviously useful
05:04:20 <Thu21670> :D
05:04:36 <Thu21670> i built a layer on top of Text.Regex so that i could use the UU parsing combinators
05:05:46 <Thu21670> so p <*> q still means recognize p and then q....but p doesnt have to match the beginning of the inputstream...(which would be required with a parser) and between p and q could be arbitrary goo.
05:35:32 <tewk> Learning haskell, what does   Couldn't match `IOException' against `Exception', When checking the pattern: ErrorCall "__timeout",   mean?
05:36:57 <Lemmih> Can you paste the entire line, please?
05:39:16 <tewk> I'm trying to compile hws-wp with ghc 6.4, the problem is in Util.hs:153.  Do you guys have some type of flood/paste server or do you just paste directly to the channel?
05:39:29 <Lemmih> @paste
05:39:29 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:43:01 <musasabi> tewk: hws as in the Haskell Web Server?
05:44:45 <tewk> musasabi: yes
05:44:56 <tewk> with plugins -wp
05:45:46 <tewk> Lemmih: ok I added my bug to HaskellIrcPastePage
05:47:36 <Lemmih> Make sure that 'catch' is imported from Control.Exception
05:47:50 <musasabi> I have a version of the original which compiles with 6.4 if you want to look at that - might have a solution.
05:48:07 <Lemmih> @type catch
05:48:09 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
05:48:15 <Lemmih> @type Control.Exception.catch
05:48:16 <lambdabot> forall a.
05:48:16 <lambdabot>          IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
05:49:27 <musasabi> http://youzen.b2.fi/~musasabi/hws-20050728.tar.gz
05:49:34 <Lemmih> shapr: ACK?
05:49:39 <tewk> musasabi: Sure I'd like to get it, is there a current cvs, svn, thanks
05:59:12 <CosmicRay> woohoo!  ftp-master is back!
05:59:59 * CosmicRay sets about uploading the latest missingh and hssffig
06:14:01 <musasabi> Any idea when GHC 6.4 will enter Etch ?
06:14:43 <dcoutts> musasabi, not before 6.4.1 is out I'd guess :-) but then what do I know
06:16:23 <CosmicRay> hmm, is etch the new testing?
06:19:22 <shapr> Lemmih: SYN
06:19:58 <musasabi> CosmicRay: yes.
06:20:09 <radu_g> hello. is there a function to detect if a number is prime in GHC's libraries?
06:20:14 <CosmicRay> musasabi: I suspect the c++ stuff is keeping it out at the moment.
06:20:29 <shapr> jiihaa
06:20:39 <mflux_> radu_g, I don't think so. It would defeat the prime example of writing a program that outputs prime numbers ;)
06:21:14 <shapr> heh, prime example
06:21:23 <musasabi> isn't that quite unrelated?
06:22:03 <mflux_> a simplistic implementation would be just filter isPrime [1..] then
06:22:45 <mflux_> but I suppose actual (efficient) isPrime implementation for haskell are available too
09:08:21 <SyntaxNinja> w00t
09:08:37 <reffie> advice is the only thing that people like giving more than they like receiving.
09:11:23 <samc> what about a kick in the nadgers?
09:16:27 <reffie> that too
09:23:50 <dcoutts> SyntaxNinja, I've got a 5 character cabal patch for you...
09:24:25 <CosmicRay> SyntaxNinja: I've got trouble with building a FFI app with hug
09:24:28 <CosmicRay> hugs
09:24:47 <dcoutts> SyntaxNinja, or should I send you a darcs patch?
09:24:57 <CosmicRay> SyntaxNinja: it appears to not be linkning in my C glue file
09:25:03 <dcoutts> Lemmih, we've ween wondering about hackage...
09:25:10 <Lemmih> Oh.
09:25:25 <dcoutts> it's been a bit quiet
09:25:45 <CosmicRay> SyntaxNinja: you can try it by darcs get http://darcs.complete.org/ldap-haskell; cd ldap-haskell; make setup; ./setup configure --hugs; ./setup build -v
09:26:11 <dcoutts> Lemmih, we want to build a tool that queries the hackage collection and generates gentoo ebuilds
09:26:25 <dcoutts> Lemmih, we want to automate as much as we can
09:26:32 <Lemmih> Sounds neat.
09:26:54 <dcoutts> it seems that the hackage cgi thing is down
09:27:36 <dcoutts> and I was wondering if we could persuade you to make hackage enforce some policy...
09:27:50 <Lemmih> The hackage cgi?
09:27:58 <dcoutts> yeah
09:28:34 <Lemmih> URL?
09:29:01 <dcoutts> http://scannedinavian.org/cgi-bin/hackage/hackage
09:29:12 <dcoutts> which is linked from http://www.haskell.org/cabal/hackage/
09:29:12 <SyntaxNinja> dcoutts: yes!
09:29:27 <SyntaxNinja> CosmicRay: it's not linking the _stub file?
09:29:31 <Lemmih> http://www.haskell.org/cabal/hackage/ haven't been updated since 2004 or something like that (:
09:29:37 <CosmicRay> SyntaxNinja: I see no _stub file referenced at all
09:29:51 <dcoutts> SyntaxNinja, which? you want be to tell you the 5 character change or you want the darcs patch
09:30:03 <SyntaxNinja> dcoutts: darcs patch, please.
09:30:12 <Lemmih> Greetings SyntaxNinja.
09:30:14 <SyntaxNinja> <--- has been spending too much time outside :)
09:30:16 <SyntaxNinja> Lemmih:  y0
09:30:23 <dcoutts> SyntaxNinja, it's basically to remove util from the Cabal build-depends because it's not used and it breaks things
09:30:27 <SyntaxNinja> CosmicRay: can you clarify your question? which cabal are you using?
09:30:32 <dcoutts> SyntaxNinja, but i'll send you a darcs patch
09:30:38 <SyntaxNinja> dcoutts: are you sure it can be removed?
09:30:44 <dcoutts> seems to build fine
09:30:51 <SyntaxNinja> dcoutts: hide or remove the util package and make sure it still builds
09:30:57 <dcoutts> ok
09:31:07 <dcoutts> well it's already hidden
09:31:20 <dcoutts> so just removing it from the build-depends should be enough to tes
09:31:26 <Lemmih> dcoutts: What kind of policy do you want HackageDB to enforce?
09:31:30 <CosmicRay> SyntaxNinja: the version in GHC
09:31:31 <dcoutts> tes/test
09:31:52 <dcoutts> Lemmih, the naming concentions and layout of the tarballs
09:32:29 <dcoutts> Lemmih, and what ever policy it is we want to enforce we should make sure that Cabal's "sdist" command does the right thing
09:33:57 <dcoutts> Lemmih, for example if the cabal package is "XmlRpc" version "2005.6.12" then the tarball should be "XmlRpc-2005.6.12.tar.gz"
09:34:05 <dcoutts> or lower case, I don't mind
09:34:19 <dcoutts> preferable lower case, but that's not so important
09:34:38 <dcoutts> and it should unpack to a dir "XmlRpc-2005.6.12/"
09:35:04 <dcoutts> some packages are called one thing but then the cabal package is called something else!
09:35:16 <dcoutts> how are we supposed to track dependencies in that case! :-)
09:35:55 <dcoutts> eg the XmlRpc package is called "HaXR"
09:36:23 <dcoutts> so where's the connection between the cabal package name which is what the dependencies talk about and the name of the tarball?
09:36:37 <dcoutts> what will hackage call know it by?
09:36:51 <roconnor> @ What The Hack
09:36:52 <lambdabot> Maybe you meant: all-dicts arr babel botsnack code define definitions
09:36:52 <lambdabot> del-definition devils dice dict dict-help docs dummy dynamic-load
09:36:52 <lambdabot> dynamic-reload dynamic-unload easton echo elements elite eurohaskell
09:36:52 <lambdabot> eval fact fact-cons fact-delete fact-set fact-snoc fact-update
09:36:52 <lambdabot> foldoc fortune gazetteer get-definition ghc google help hitchcock
09:36:54 <lambdabot> hoogle hoogle+ index jargon join karma karma+ karma- kind lambda
09:36:56 <lambdabot> learn leave libsrc listchans listcommands listmodules lojban moo
09:36:58 <lambdabot> [6 @more lines]
09:37:01 <Lemmih> It will call it XmlRpc and save it in XmlRpc-[version].tgz
09:37:13 <roconnor> that wasn't for you lambdabot
09:37:14 <dcoutts> Lemmih, that's good :-)
09:37:45 <Lemmih> It doesn't enforce how it unpacks but that would be trivial to add.
09:37:51 <dcoutts> Lemmih, some sanity so that our tools have a chance of working is all we want
09:38:27 <dcoutts> otherwise each package will require manual tweaking and we won't be able to mirror the hackage collection wither fully or make updates quickly
09:38:46 <dcoutts> whihc would be a sad loss for the users
09:38:56 <dcoutts> automation is the key
09:39:48 <Lemmih> As the author of cabal-get, I can relate to that.
09:39:49 <Igloo> dcoutts: How will this work when you have multiple cabal packages in a tarball?
09:40:00 <dcoutts> Igloo, it's an interesting question
09:40:03 <dcoutts> not sure yet
09:40:26 <dcoutts> we'd need some way of relating the "distribution" name to the package names
09:40:32 <beelsebob> evening all
09:40:40 <beelsebob> @hoogle (a -> b -> b) -> m b -> [a] -> m b
09:40:41 <lambdabot> Prelude.zipWith :: ((a -> b -> c) -> [a] -> [b] -> [c])
09:40:41 <lambdabot> Monad.liftM2 :: Monad a => ((b -> c -> d) -> (a b) -> (a c) -> (a d))
09:40:41 <lambdabot> List.intersectBy :: ((a -> a -> Bool) -> [a] -> [a] -> [a])
09:40:46 <Lemmih> Evening beelsebob.
09:40:59 <beelsebob> bah...
09:41:10 * Igloo looks at the CUFP lineup and wishes he was going
09:41:11 <beelsebob> is there a version of foldr for use in a monad?
09:41:17 <Lemmih> Kick ass! I just got my visa card.
09:41:28 <dcoutts> beelsebob, foldM
09:41:29 * Lemmih goes on an internet shopping spree.
09:41:32 <dcoutts> @type foldM
09:41:38 <lambdabot> bzzt
09:41:41 <dcoutts> @type foldrM
09:41:43 <lambdabot> bzzt
09:41:50 <beelsebob> @hoogle foldM
09:41:50 <dcoutts> @type Monad.foldM
09:41:51 <lambdabot> Monad.foldM :: Monad a => ((b -> c -> (a b)) -> b -> [c] -> (a b))
09:41:52 <lambdabot> forall a (m :: * -> *) b.
09:41:52 <lambdabot>      (Monad m) =>
09:41:52 <lambdabot>      (a -> b -> m a) -> a -> [b] -> m a
09:42:20 <SyntaxNinja> CosmicRay: you need 1.1.1 to get it to link the _stub files.
09:44:36 <dcoutts> SyntaxNinja, does cabal typically build libs with -O ?
09:44:44 <beelsebob> hmm, actually, I think I just realised how to do this outwith any monad
09:44:49 <beelsebob> :)(
09:45:29 <TheHunter> @pl \c n xs -> (\n' -> foldr c n' xs) `fmap` n
09:45:30 <lambdabot> flip . (fmap .) . flip . foldr
09:45:44 <SyntaxNinja> dcoutts: no, I don't think so.
09:45:50 <SyntaxNinja> dcoutts: you would have to add it.
09:45:54 <SyntaxNinja> (to the ghc-options)
09:45:58 <dcoutts> oh
09:46:25 <dcoutts> hmm, we donmally build all the progs/libs we install using -I
09:46:30 <dcoutts> -O I mean
09:46:41 <roconnor> Hey, what tools do we have for creating (not parsing) XML?
09:46:48 <dcoutts> donmally/normally
09:49:08 <dcoutts> SyntaxNinja, would you accept a patch that added a flag to "/setup configure" to control building with optimisations?
09:49:40 <dcoutts> SyntaxNinja, ie not full control over all command line flags, just optimisations
09:50:38 <beelsebob> hehe... this is horribly convoluted
09:50:47 <Igloo> Sounds good to me
09:51:01 <dcoutts> SyntaxNinja, I think it should be up to the user/packager what optimisation level to use rather than just specifying in the Cabal file
09:51:12 <dcoutts> Igloo, you were agreing with me?
09:51:31 <Igloo> dcoutts: There's a first time for everything  :-)
09:51:38 <dcoutts> ha! :-)
09:52:03 <SyntaxNinja> dcoutts: yeah. adding ops would be fine. I agree it belongs in configure.
09:52:23 <dcoutts> can you think of a sensible name for the flag?
09:52:56 <dcoutts> and would you make it the default or not?
09:53:11 <Igloo> -O and { --optimise or --with-optimisation } would be good IMO
09:53:33 <dcoutts> --with-optimisation / --without-optimisation
09:53:45 <dcoutts> would fit the existing patten of flags
09:53:53 <musasabi> How about --with-hc-flags ?
09:54:05 <dcoutts> or perhaps --enable-optimisation / --disable-optimisation
09:54:10 <Igloo> OK. I think it's common enough that -O -O0 -O1 should work too, though
09:54:15 <musasabi> as sometimes one wishes to add other flags too.
09:54:17 <dcoutts> musasabi, that'd be too specific to the compiler
09:54:31 <dcoutts> musasabi, you can add things in the cabal file
09:54:45 <dcoutts> these are options that the user of the package might want
09:54:49 <musasabi> dcoutts: Well when building a package the options are specific to a compiler (e.g. either --hugs or --ghc)
09:55:13 <Igloo> You might want a ghc-opts-optimisation which default to -O ghc-opts (or whatever the options names are called)
09:55:14 <dcoutts> musasabi, well, see what SyntaxNinja says :-)
10:03:23 <lispy`> Igloo: any luck with the errno bug? anything else I can do to help?
10:04:33 <beelsebob> argh! What's happened to the interleve function????
10:04:39 <Igloo> interleave
10:04:45 <beelsebob> oh... duh
10:04:47 <Igloo> lispy`: The patch removing compat.c should fix it
10:05:09 <lispy`> Igloo: ah, has it been pushed?
10:05:23 <lispy`> Igloo: i haven't been paying a lot of attention on darcs-devel
10:05:29 <Igloo> No
10:19:16 <SyntaxNinja> dcoutts: ghc and gcc both use the same flags, right?
10:19:36 <dcoutts> SyntaxNinja, they use a lot of the same flags
10:19:45 <dcoutts> many ghc flags are modeled on gcc flags
10:19:55 <dcoutts> eg -O is the same
10:20:23 <dcoutts> -O0 -O1 -O2 -I -l -o
10:22:40 <SyntaxNinja> it would be nice to control the optimization level
10:22:50 <SyntaxNinja> maybe --optimization=1 ?
10:22:59 <dcoutts> yes it could apply to C code too
10:23:14 <dcoutts> eg a good default is -O to ghc and -O2 to gcc
10:23:36 <dcoutts> eg most linux distros build most packages by default with gcc -O2
10:24:04 <dcoutts> and the equivalent 'normal' optimisation level is of course just -O
10:24:09 <dcoutts> for ghc I mean
10:24:17 <lispy`> Igloo: (reading darcs devel now) should I try the patch you sent in on os x?
10:24:29 <lispy`> Igloo: is it reasonable to expect it to "just work"
10:24:41 <dcoutts> I'm not sure the haskell systems have that many usefull levels of optimisation
10:25:43 <beelsebob> bah... why isn't this being lazy
10:25:54 <dcoutts> we could start with just "--optimisation" and if jhc comes along with N levels of optimisation then we could allow "--optimisation=5"
10:26:16 <pejo> dcoutts, isn't the diff between O2 and O3 in gcc basically more unrolling and inlining? That could be applied for Haskell too I guess.
10:26:18 <beelsebob> where's the pastebin gone?
10:26:24 <dcoutts> but it's a bit hard to compare levels across compilers, hugs/nhc/ghc/jhc/gcc etc
10:26:37 <Lemmih> @paste
10:26:38 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
10:26:59 <dcoutts> pejo, yes, there is -O2 for ghc but it's not much different to -O most of the time, same goes for gcc and -O2/-O3
10:27:20 <beelsebob> do I just edit the wiki page then?
10:29:02 <beelsebob> @paste
10:29:03 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
10:29:12 <beelsebob> anyone see why that isn't producing a question straight off
10:29:38 <beelsebob> it should be able to evaluate the first item without any input
10:30:09 * CosmicRay returns
10:30:25 <vegai> buffering?
10:30:34 <CosmicRay> SyntaxNinja: what are _stub files?
10:30:44 <beelsebob> ... but it's got an unlines
10:30:45 <CosmicRay> SyntaxNinja: also I can't use 1.1.x until it's in sid (hint hint)
10:30:49 <beelsebob> it should get a new line char
10:31:10 <CosmicRay> I just have a hand-written file named glue.c that is listed on the c-sources line
10:31:24 <CosmicRay> incidentally, I can now connect and bind to a ldap server through haskell, woohoo ;-)
10:31:51 <SyntaxNinja> dcouttsghc already allows multiple levels, right?
10:32:01 <SyntaxNinja> CosmicRay: tell Igloo to tell JaffaCake that.
10:32:16 <CosmicRay> SyntaxNinja: eh?  aren't you going to be uploading newer cabals to sid?
10:32:17 <SyntaxNinja> CosmicRay: _stub files are some junk that ghc produces in ordr to link some C junk to other junk or something :)
10:32:25 <Igloo> ehwhat?
10:32:32 <CosmicRay> sounds fun, and not necessarily related to hugs ;-)
10:32:32 <SyntaxNinja> CosmicRay: can't upload any Haskell stuff until 6.4.1 is out, right?
10:32:34 <beelsebob> no ideas on why that doesn't produce output lazily?
10:32:45 <CosmicRay> SyntaxNinja: nah, I'm uploading now
10:32:54 <SyntaxNinja> CosmicRay: can you 'splain what the problem is?
10:33:19 <beelsebob> ohhh wait... I think I might know it... intersperse relies on knowing that the next element is not the empty list
10:33:32 <SyntaxNinja> CosmicRay: I thought that ghc was broken on the autobuilders or something
10:33:47 <CosmicRay> SyntaxNinja: it's not installable in sid
10:33:51 <CosmicRay> SyntaxNinja: so yes, you're right.
10:34:06 <CosmicRay> SyntaxNinja: however for anyone that installed it before whatever c++ library in sid disappeared, it still works fine.
10:34:40 <SyntaxNinja> does that include the autobuilder?
10:34:45 <CosmicRay> SyntaxNinja: likely not
10:34:55 <SyntaxNinja> so you can upload it, but it won't build
10:35:18 <CosmicRay> right.
10:35:28 <CosmicRay> but it will build for anybody that already has ghc installed.
10:35:39 <CosmicRay> so people can build it manually if they so desire
10:35:42 <SyntaxNinja> CosmicRay: but they have to download the source package nad build it by hand
10:35:43 * SyntaxNinja nods
10:35:49 <CosmicRay> in the meantime, the old version sticks around on the other archs, so no harm done.
10:35:57 <SyntaxNinja> so idono, I was just planning to upload a new cabal when the new ghc comes out.
10:36:15 <CosmicRay> SyntaxNinja: I'd say, go for it now.  let us all get a head start on testing things.
10:36:41 <dcoutts> SyntaxNinja, so ghc-6.4.1 is still going to have Cabal-1.0 or the new Cabal-1.2 ?
10:36:44 <CosmicRay> so everything but i386 will be lagged.  it'll be fixed whenever igloo uploads a ghc with the correct c++ library dependencies
10:36:51 <CosmicRay> speaking of which, why hasn't that happened, igloo? ;-)
10:36:58 <SyntaxNinja> CosmicRay: thing is, this version of ghc is a pain to update Cabal on
10:37:04 <SyntaxNinja> but maybe we should do that anyway
10:37:04 <CosmicRay> ah.
10:37:16 <SyntaxNinja> dcoutts: it'll have 1.0 plus some bug fixes.
10:37:18 <CosmicRay> SyntaxNinja: from what I remember, a little dpkg-divert should help you out
10:37:20 <Igloo> Because 6.4.1 isn't released yet and 6.4 doesn't build with gcc 4
10:37:45 <SyntaxNinja> so to make a long story short... blame simon ;)
10:37:54 <CosmicRay> Igloo: you can specifically build-depn on gcc-3.3 and use /usr/bin/gcc-3.3
10:37:55 <dcoutts> SyntaxNinja, ok, that's fine, we'll just force Cabal-1.2 on our users :-)
10:37:59 * lispy` likes long stories
10:38:06 <SyntaxNinja> your users blame you, you blame me, I'll blame igloo, igloo can blame simon, and simon can blame the gcc hackers or something.
10:38:20 <CosmicRay> SyntaxNinja: so in the end, it's all RMS's fault.
10:38:25 <SyntaxNinja> I blame RMS
10:38:25 <Igloo> Yeah, but with 6.4.1 so close to release it isn't worth the hassle IMO
10:38:32 <lispy`> SyntaxNinja: and then the gcc hackers should blame the users
10:38:45 <CosmicRay> <debian> do we really know that 6.4.1 is close? </debian>
10:38:46 <SyntaxNinja> or the C standards comittee?
10:38:57 * CosmicRay has been burned enough times by assuming that a release of something is imminent
10:39:15 <SyntaxNinja> (for those who don't know, CosmicRay did time)
10:39:20 <lispy`> SyntaxNinja: oh, they could blame Intel for creating their new instructions that gcc is trying to cater to
10:39:24 <CosmicRay> SyntaxNinja: K&R.  bastards working for a monopolistic phone company.
10:39:46 <CosmicRay> lispy`: hah
10:39:50 <SyntaxNinja> oh phones have something to do with this? maybe we can somehow blame tmobile
10:40:08 <CosmicRay> SyntaxNinja: yeah, K&R were working for a division of AT&T when they invented C
10:40:09 <lispy`> and Intel can blame users for wanting faster processors :)
10:40:33 <lispy`> blaming tombile would be fine
10:40:35 <lispy`> ur fun
10:40:44 <CosmicRay> <-- still fairly happy with cingular
10:40:56 <CosmicRay> I'm for blaming sprint.
10:41:06 <lispy`> especially if we can prove that cell phones are the source of the problem
10:41:07 <CosmicRay> err, sorry, SprintNextel.
10:41:26 <lispy`> "Er, Ghc release is late, because of cell phones."
10:41:42 <lispy`> "If you just look at this blame graph, it is clear to see..."
10:41:45 <CosmicRay> yes, if SyntaxNinja hadn't had to spend so much time struggling to make his cellphone work, he could have had a working cabal in ghc 6.4  (grin, duck, run)
10:42:08 <lispy`> the blame graph never lies!
10:42:33 <CosmicRay> Igloo: looks like vorlon is planning to nmu ghc6
10:42:40 <CosmicRay> Igloo: would it be ok with you if I did so?
10:43:06 <Igloo> Only if you do it properly, e.g. binary upload on all arches
10:43:34 <CosmicRay> eh?  why would I have to do a binary upload on more than one arch?  the autobuilder would get it on all the others, just like usual
10:43:45 <Igloo> When ghc6 isn't installable?
10:43:48 <CosmicRay> oh.
10:43:55 <CosmicRay> crap.
10:44:18 <CosmicRay> that's going to take vorlon's assistance to fix even when you get ghc6.4.1 then isn't it.
10:44:37 <Igloo> Why? There's an alpha machine again now, isn't there? Or do I misremember the rumours
10:44:58 <CosmicRay> Igloo: most of us regular dd's don't have access to install things as root on debian boxen
10:45:18 <CosmicRay> much less add a library from stable to an unstable environment
10:45:18 <Igloo> No, nor does vorlon. But we can all mail debian-admin@
10:45:48 <Igloo> You don't actually need to add the library, you just have to unpack the old ghc deb and it'll work
10:45:51 <CosmicRay> Igloo: in all seriousness, it would be good to get this ball rolling now, and not wait for ghc641.  debian-admin is not known for rapid response
10:46:00 <CosmicRay> hmm hmm.
10:46:05 <Igloo> I find them quick at install requests
10:46:37 <CosmicRay> have you tried an install request on this many archs before? ;-)
10:47:04 <Igloo> yes
10:47:17 * CosmicRay bows to igloo's optimism
10:51:13 <CosmicRay> hmm, it looks like some of the debian developer machines have ghc6 on them already.
10:51:43 <Igloo> Told you I'd done this before  :-)
10:51:47 <CosmicRay> heh
10:51:59 <Igloo> Any with ghc on have too old a chroot to use, of course
10:52:14 <CosmicRay> not necessarily
10:52:24 <CosmicRay> they could have ghc6 installed before doing the upgrade
10:52:43 <CosmicRay> ...or not.
10:52:44 <Igloo> If ghc is installed then the new libgmp-dev isn't
10:52:49 <CosmicRay> I just noticed that.
10:52:57 <CosmicRay> crap.
10:59:17 <SyntaxNinja> has anyone heard anything from TFP? they were supposed to give paper feedback by the 22nd
11:01:38 <SyntaxNinja> @seen shapr
11:01:39 <lambdabot> I saw shapr leaving #haskell 2 hours, 38 minutes and 57 seconds ago.
11:03:41 <SyntaxNinja> is it normal to hear back if your paper was not accepted?
11:04:26 <Igloo> Yes
11:04:50 <Igloo> I'd mail a suitable address if it's been this long
11:06:55 <kosmikus> I've heard from someone who has heard back
11:07:03 <kosmikus> it's strange, I'd also ask
11:09:18 <SyntaxNinja> maybe spamassassin got it...
11:11:39 <lispy`> heh, the SyntaxNinja thwarted by the SpamAssassin ;)
11:12:42 <SyntaxNinja> apparently not
11:19:24 <CosmicRay> I have a C function that has a parameter of type char **outvalue.  That is, I need to pass it a pointer to a location in memory where it writes out a pointer to a string.
11:19:29 <CosmicRay> how can I model this with FFI?
11:19:45 <CosmicRay> foreign.ptr doesn't seem to have any "create a pointer to a pointer" functions
11:20:15 <Igloo> Make and read pointers as you would in C
11:20:42 <wilx> @ghc
11:20:43 <lambdabot>  Use -fallow-incoherent-instances
11:20:45 <Igloo> peek is the reading one. They're in Foreign.* somewhere
11:21:06 <CosmicRay> so I need to use alloca to allocate space for a pointer?
11:21:22 * SyntaxNinja dereferences CosmicRay
11:21:40 <CosmicRay> yeah peek and poke I can do, I'm just not sure how to generate the pointer-to-a-pointer-to-a-char thingy from haskell
11:21:56 <CosmicRay> SyntaxNinja: hah, too many stars in front of my name!
11:22:15 <lispy`> @hoogle peek
11:22:16 * CosmicRay hops around in an anonymous region of memory somehwere
11:22:32 <CosmicRay> actually what 'll need is peekCString
11:22:38 <CosmicRay> lispy`: it's in foreign.c.string
11:22:53 <CosmicRay> but that's only after I've managed to pass this pointer to a pointer beast to c
11:22:59 <lispy`> CosmicRay: yeah, i just hoped maybe lambdabot could find it :)
11:23:31 <CosmicRay> lispy`: foreign.storable
11:23:40 <Igloo> CosmicRay: Are you interested in doing windows compatibility stuff for darcs BTW?
11:23:42 <CosmicRay> so I'll basically do a peek . peekCString
11:23:57 <CosmicRay> Igloo: not really, but I can test random quick things for you.
11:24:07 <CosmicRay> I try to avoid windows as much as possible
11:24:07 <Igloo> OK
11:24:12 <CosmicRay> but I do use ghc and darcs there on occasion
11:24:41 <CosmicRay> using windows makes me annoyed and irritable.
11:24:46 <wilx> Windows is the only OS!
11:25:06 * CosmicRay fires up winnuke and points it at wilx
11:25:06 <wilx> And I shall smite thee for you are pagan!
11:25:10 <Igloo> wilx: Are you interested in the above, then?  :-)
11:25:30 <wilx> Huh.
11:25:42 <CosmicRay> haha
11:25:56 <wilx> Dunno, I probably don't know enough of either Haskell or Darcs internals.
11:25:57 <CosmicRay> Igloo: everyone seems to back away from you when it comes right down to working on windows, don't they :-)
11:25:59 <wilx> What is there to do?
11:26:22 <CosmicRay> wilx: keep your machine booted long enough between malware and BSOD attacks to see if stuff compiles? ;-)
11:26:30 <wilx> lol
11:26:51 <wilx> I dont get BSODs.
11:27:02 <CosmicRay> note: you may need to disconnect the network and have your machine annointed with holy water to achieve this.
11:27:05 <Igloo> wilx: Fix up my latest patch to make it work on Windows, basically
11:28:16 <wilx> Hm, I have actually never tried to compile Darcs here.
11:28:19 <wilx> Let me try...
11:28:39 * CosmicRay idly wonders how it is that ghc works on windows, in the absence of any installed C compiler, assembler, or linker.
11:28:49 <Igloo> I'm not desparate yet as there are other people who have done this sort of thing in the past, so it's likely one of them will step up again this time  :-)
11:29:00 <Igloo> It bundles gcc et al with it, I think
11:29:04 <wilx> CosmicRay, GHC ships with GCC and Perl.
11:29:12 <lispy`> Perl?
11:29:13 <thedward> so, ghc outputs c-code ?
11:29:16 * lispy` sobs
11:29:21 <CosmicRay> oh, interesting.  I noticed perl but I must have missed gcc.
11:29:23 <Speck> sigh... oh what it is to be a student employee in the it dept. of one's school, and to listen to all the managers rail against common sense
11:29:38 <CosmicRay> Speck: this is not limited to schools
11:29:46 <wilx> Hehe.
11:29:48 <Speck> yes, but I don't get to do anything about it
11:29:57 <CosmicRay> Speck: this too is not limited to schools
11:30:02 <Speck> boo
11:30:09 <samc> down with common sense!
11:30:14 <CosmicRay> Speck: don't think it gets any better when you graduate.
11:30:22 <CosmicRay> Speck: now, get out there and show some enthusiasm! :-)
11:30:24 <Speck> "let's add a miscelaneous field!"
11:30:37 <Speck> "what type of field?"
11:30:39 <Speck> "a string!"
11:30:44 <SyntaxNinja> thedward: ghc _can_ output C clode.
11:31:01 <Philippa_> can it output portable C code though?
11:31:11 <SyntaxNinja> yeah, that's the point.
11:31:11 <CosmicRay> Philippa_: ooo, good question.
11:31:14 <CosmicRay> Philippa_: no.  ;-)
11:31:23 <SyntaxNinja> well, what do you mean by portable ;)
11:31:27 <CosmicRay> nhc98 could possibly though
11:31:34 <musasabi> jhc can output portable C.
11:31:36 <Igloo> nhc does
11:31:47 <SyntaxNinja> what's non-portable about ghc's code? I've found it portable.
11:31:48 <Igloo> Well, FSVO portable
11:32:09 <wilx> Who builds the Windows binaries of Darcs anyway?
11:32:11 <CosmicRay> SyntaxNinja: it works on only machines running the same os and cpu with the ghc rts installed? ;-)
11:32:21 <CosmicRay> wilx: some guy that's linked on the wiki
11:32:45 <CosmicRay> hmm, I shoudl really install a virus scanner on my windows environment ;-)
11:33:25 <Speck> your first mistake was hooking it up to the internet
11:33:33 <SyntaxNinja> CosmicRay: oh, someone wants to compile to C and then ship that C code to another machine or something?
11:33:45 <CosmicRay> sounds like it
11:33:54 <CosmicRay> at least that's what portable means to me.
11:34:10 <SyntaxNinja> I'm sure you can cross-compile :)
11:34:32 <CosmicRay> oh yes, of course.  if the planets are properly aligned and the gods are smiling upon you.
11:34:47 <CosmicRay> otherwise, you shall be cursed to a life full of AIX-related compiler hell!
11:34:47 <SyntaxNinja> <--- does it often :P
11:34:53 <SyntaxNinja> but someone else builds GHC for me.
11:34:58 <CosmicRay> SyntaxNinja: cheater
11:35:13 <CosmicRay> SyntaxNinja: you're cross compiling from, what, debian x86 to debian amd64? ;-)
11:35:55 <CosmicRay> SyntaxNinja: you need to get out more!  live life on the edge.  cross-compile from HPUX to AIX!
11:36:03 <CosmicRay> that should be loads of fun!
11:36:45 <samc> yes, that sounds like "getting out more" :P
11:36:51 <CosmicRay> hehe
11:36:51 * lispy` shivers at the mention of HPUX
11:37:05 <CosmicRay> lispy`: nothing at the mention of AIX? ;-)
11:37:58 <CosmicRay> autrijus would shiver for you if he were here ;-)
11:43:15 <SyntaxNinja> Lunar^: alive?
11:43:55 <SyntaxNinja> hmm. if your'e callng Haskell from a C program, and you have multiple C threads, I notice that when the C threads are blocked, none of the Haskell threads get run
11:44:55 <SyntaxNinja> makes me wonder that if I'm using an MVar to coordinate mutex between the Hsakell threads, whether the mutex is actually working, since we may have multiple C threads or something.
11:45:27 <Igloo> You probably want to link with -threaded
11:46:53 <SyntaxNinja> what does that do, exactly?
11:49:34 <Igloo> Links with the threaded RTS
11:50:11 <SyntaxNinja> hmm
11:50:15 <SyntaxNinja> I'll play w/ that. thanks.
11:51:29 <mwc> dcoutts_: having some trouble getting shared libraries built
11:53:29 <dcoutts> mwc, I have no idea how to build shared libs on the OSX :-(
11:53:54 <dcoutts> they're not supported by ghc yet on linux so I've not seen how to do it
11:55:01 <mwc> yeah, well, GCHI can't run any gtk2hs stuff then
11:55:37 <mwc> I'd think that libtool would be able to do it; its a matter of linking, not compiling afaik; so long as the compiler generates PIC
11:56:09 <mwc> other than that your release checks out on OS X
12:02:05 <mwc> dcoutts: hmm, all the demos except gconf work; it dies on launch with Glib errors
12:06:05 <dcoutts> mwc, ghci can't use the .o files like on other platforms?
12:06:31 <dcoutts> mwc, what happens with gconf? (I didn't realise OSX had gconf!)
12:07:15 <dcoutts> mwc, if you can tell me how to build shared libs then I'll see how hard it'd be ton ntegrate that into our build system
12:08:00 <mwc> dcoutts: looks like ghci is trying to dylib; yeah, I built gconf and gnome
12:08:40 <mwc> Loading package glib-0.9.8 ... can't load .so/.DLL for: HSglib (dlopen(libHSglib.dylib, 10): image not found)
12:09:34 <dcoutts> so ghci on OSX only looks for shared libs then I guess :-(
12:10:01 <mwc> yah, apparently. I should ask Wolfgang Thaller
12:14:10 <efuzzyone> ,lisppaste2
12:14:23 <efuzzyone> !lisppaste2
12:14:29 <Lemmih> lisppaste2: url
12:14:29 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:14:47 <efuzzyone> thanks
12:15:36 <Lemmih> No problem. Got a Haskell question?
12:16:17 <mwc> dcoutts: I'm only finding .a static libs around, no objects
12:16:19 <basti_> do records work in ghc6? if so, how?
12:17:19 <lisppaste2> efuzzyone pasted "haskell interaction question" at http://paste.lisp.org/display/10279
12:17:41 <dcoutts> mwc, ah, no the ghci .o files are built when you register using ghc-pkg --auto-ghci-libs
12:17:58 <mwc> aha; I just used ghc-pkg register
12:18:06 <mwc> I'll fix that
12:18:23 <efuzzyone> yes, i am trying to leanr haskell, and i have written some code, but I am stuck with some doubts
12:19:07 <dcoutts> mwc, this'll all be much easier when cabal supports multiple packages and we can cabalise Gtk2Hs
12:19:48 <Lemmih> efuzzyone: It looks fine except 'foldl (+) 0 list' should be 'return (foldl (+) 0 list)' and 'input <- getLine' is indented too much.
12:19:51 <basti_> efuzzyone: thats that "damn IO thing"...
12:21:26 <efuzzyone> thanks, it executes but func, doesn't return anything, do I have to explicilty call show?
12:21:57 <basti_> the probem is that IO [a] can't be shown
12:22:44 <efuzzyone> i didn't really get it. any workaround?
12:23:06 <Lemmih> efuzzyone: Yes, you have to pretty print and output it yourself.
12:23:31 <efuzzyone> or maybe, i need to read more to understand it, but for time being, is there any way I can output the result
12:23:33 <Lemmih> Try typing 'it' after you've called 'func'.
12:24:17 <efuzzyone> works, thanks
12:26:08 <efuzzyone> is askForNumber an IO action?
12:26:25 <Lemmih> Yes.
12:26:41 <efuzzyone> ok.
12:27:29 <mwc> dcoutts: okay, my bad; I need to fix the registartion stuff. back in a bit
12:27:31 <Lemmih> GHC will tell you the type of any expression if you type ':type [expression]'
12:28:00 <wilx> Huff.
12:28:12 <wilx> I finally can type make for darcs.
12:28:23 <wilx> And I don't have System.Posix....
12:28:31 <wilx> Is that the problem?
12:31:29 <CosmicRay> that's normal on windows
12:31:34 <CosmicRay> well you probably have a small subset of system.posix
12:32:18 <Igloo> If you've applied the patch from the mailing list then yes
12:32:26 <esap> Is there a way to prove that template haskell -generated meta information and the corresponding compile-time types match? I mean, in the sense that I'd like to prove some types equivalent for the type checker based on information generated via TH at run-time using the Equal stuff?
12:32:56 <wilx> I haven't applied anything manually, I only darcs pull'd the source.
12:33:03 <dcoutts> Lemmih, did you say eariler that there is a new hackage page? rather than http://www.haskell.org/cabal/hackage/
12:33:04 <Igloo> Some of it (at least stdout_is_a_pipe) ought to be implementable using System.Posix.Internals that you do have, I think
12:33:16 <Igloo> Hmm, I'd expect it to build then
12:33:47 <Lemmih> dcoutts: Nothing official yet.
12:35:23 <wilx> Hmm, where is SYS variable in GNUmakfile supposed to get defined?
12:35:58 <Igloo> autoconf.mk(.in)
12:36:08 <wilx> I see, it is empty after configure here...
12:36:43 <dcoutts> Lemmih, ok, ping me when there's something to try, I'm eager to get some automation tools built
12:39:08 <wilx> In configure.ac, there is case $target, I don't see it defined anywhere.
12:41:22 <wilx> Should it be defined by something like AC_CANONICAL_TARGET and friends?
12:45:36 * Igloo doesn't know autoconf details
12:46:38 <wilx> Hmm, I added the trio of AC_CANONICAL_* macros into configure.ac and copied over config.sub and config.guess and that case statement now works as expected.
12:47:52 <Lemmih> dcoutts: I just have to get my key signed. Then I can install HackageDB on its permanent server.
12:47:58 <wilx> So far it keeps compiling...
12:48:04 <dcoutts> Lemmih, cool
12:56:29 <CosmicRay> hmm, any nice way to marshall [String] into char[][] in C?
13:05:38 <wilx> I think that the silence says it all :)
13:05:54 <BigDuke> yeah. dont do drugs
13:05:57 <BigDuke> and dont do C
13:06:28 <CosmicRay> heh
13:08:31 <mwc_> C has its purposes
13:09:00 <thedward> mwc_: bootstrapping?
13:15:02 <BigDuke> mwc, sure it has its purposes, so do maggots
13:15:42 <mwc> BigDuke: if you ever get a festering wound; you'll learn to appreciate the little bastards
13:16:11 <BigDuke> that accurately describes the use of C indeed
13:16:34 <mwc> BigDuke: but seriously; C is necessary; where'd any HLL be without a kernel and runtime support? :P
13:16:37 <BigDuke> but i think you'll want to use lab maggots....and C is just a dirty maggot
13:17:44 <mwc> Haskell... is like a girl I met at a strange bar I decided to check out on a whim. And she knew some freaky stuff...
13:18:18 <BigDuke> i dont prefer to get the inside on your affairs with women having gender issues
13:18:22 <BigDuke> thanks...but no thank you
13:18:35 <mwc> I guess that would make Java one of those pretentious social climbing girls from highschool.
13:21:32 <Philippa_> BigDuke: careful on that one. It's those of us who don't have gender issues you want to worry about
13:21:55 <BigDuke> no, its the girl in that bar Philippa_
13:22:06 <BigDuke> you're right about that
13:23:12 <Philippa_> those of us who don't have gender issues are far more comfortable using our strap-ons :-)
13:23:21 <musasabi> gender is a little thing, there are far more important things about people.
13:23:41 <Philippa_> now now, the guys get upset when you tell them it's a "little thing"...
13:24:09 <musasabi> Philippa_: gender can be problematic with strap ons if one is not carefull ;)
13:24:48 <BigDuke> why would anyone care if a women told you your thing is little
13:25:14 <Philippa_> apparently it's unmanning or something...
13:25:29 <Philippa_> not that I'd care, I always did prefer silicone anyway
13:25:45 * basti_ invites everyone to #touch-my-monads
13:26:20 <BigDuke> unmanning? weird. I'd say let the women jibber all she wants
13:26:27 <BigDuke> cant think why it would affect another
13:26:58 <musasabi> silicone lacks a little bit in touch as compared to a living thing, but if the person on the other end knows what (s)he is doing then it is not a problem.
13:26:58 <lispy`> CosmicRay: i haven't used AIX yet, so no i don't shiver at the sound of it yet :)
13:27:42 <Philippa_> yeah, and they just don't make penises in some of those shapes
13:28:37 <BigDuke> haha Philippa_ being the big girl saying she wants size of an arm?
13:29:00 <Philippa_> BigDuke: nah, if I wanted a dildo that size I'd have one :-)
13:29:02 <SyntaxNinja> alert! alert! off topic!
13:29:09 <Philippa_> there're little things like texture to consider...
13:29:20 <BigDuke> i can imagine it wouldnt help to reproduce if it was wide like a pepsi can and long as an arm
13:29:31 <Philippa_> you're assuming I want to...
13:29:33 <BigDuke> ah the sandpaper type :)
13:29:54 <BigDuke> no im just reasoning why these sizes are not present in nature
13:30:13 <Philippa_> I don't /care/ why...
13:31:39 <BigDuke> im not here to spew stuff that you care about
13:31:52 <BigDuke> its not #philippas_private_chat
13:33:41 <musasabi> What was the name of the comonad paper which was talked here in the few past weeks?
13:34:23 <wilx> Hmm, ok.
13:34:44 <Philippa_> nor is it #BigDuke'sPrivateChat. Cope.
13:34:48 <Philippa_> musasabi: the one about signals?
13:34:50 <Philippa_> gimme a mo
13:35:12 <wilx> Igloo, CosmicRay, I successfuly built darcs.
13:35:26 <BigDuke> thats because it probably isnt a legal name anyway lol
13:35:43 <musasabi> Philippa_: yes, that one.
13:36:03 <Philippa_> http://types2004.lri.fr/SLIDES/uustalu.pdf (dunno 'bout the title, can always grab it again)
13:36:23 <musasabi> Thanks.
13:37:52 <wilx> Hm, but I get this: darcs: C:/Documents and Settings/WilX/Local Settings/Temp/old-darcs-4: getDirectoryContents: failed (No error)
13:37:57 <wilx> On darcs diff.
13:38:10 <wilx> And on most of the tests of make check.
13:39:17 <Philippa_> musasabi: I didn't quite get the point reading through it, though as it was slides rather than a paper that's kinda to be expected I guess. I'd need to see more code to get a feel for it though
13:42:11 <musasabi> Yes, that seems quite vague - but then again I am not very familiar with signal transformers so it is hard to see other cases where comonads would make sense.
13:42:41 <Philippa_> I'm not even seeing how strongly they make sense here compared to, say, arrows
13:42:48 <Philippa_> (which suggests I'm missing the point badly)
13:49:57 <TheHunter> well, just like you can embed monadic functions into arrows using the Kleisli Arrow, you can form a CoKleisli Arrow that represents comonadic functions (i'm sure you can also define a coapply).
13:51:06 <Philippa_> that kinda figures
13:52:16 <musasabi> But what do CoMonads really offer (in addition to being simpler from a theoretic pov) ?
13:54:08 <TheHunter> dammit, i can't access my water right now, it has become ice in the fridge!
13:54:55 <TheHunter> maybe higher-order constructions are easier, just like with monads.
13:55:48 <Philippa_> I actually have a more general issue, I'm just not getting when I'd want that particular pattern. Very much a case of 'my brain is stuck'
13:57:06 * TheHunter has never used stream transformers and doesn't know how useful they are.
13:59:52 <TheHunter> Ross Paterson write: "This enables us to mimic dataflow languages, in which an infinite list represents all the values of a variable, or Kahn networks, in which a list represents all the values that pass through a channel."
13:59:58 <TheHunter> *writes
14:01:06 <TheHunter> i actually did this excercise once, but it didn't occur to me that the arrow came from a comonad.
14:16:12 <lightstep> Clean compiles to ABC byte code. is it better than the GHC native code compiler?
14:18:20 <TheHunter> this might allow to draw at least some conclusions comparing ghc and clean: http://www-users.cs.york.ac.uk/~mfn/hacle/
14:19:05 <Beelsebob> who's mfn???
14:21:21 <Beelsebob> mathew nayler... *wonders why he never came across him*
14:21:35 <liyang> I keep thinking it's Matthew Naylor. But it's not.
14:21:41 <Beelsebob> it is
14:21:52 <Beelsebob> I just linked from the comp sci people page to that
14:21:58 <liyang> o.O
14:22:01 <liyang> You're right.
14:22:21 <liyang> I haven't spoken to him in over two years. >.<;;
14:22:38 <liyang> There's someone else here with the initials m.*n from York...
14:23:12 <Beelsebob> Mark Nicholson?
14:23:31 <liyang> Not sure.
14:23:55 <BigDuke> pfff will it ever cooldown
14:24:00 * wilx whistles
14:24:02 <Beelsebob> what?
14:24:02 <BigDuke> wtf man, its freakin 23:23
14:24:04 * liyang went to school with Matthew...
14:24:14 <Beelsebob> uhhuh?
14:24:37 * Beelsebob is wondering how he missed a Haskeller at York
14:25:03 <liyang> (His dad was the head of IT. XD)
14:25:16 <Beelsebob> :/
14:25:24 <Beelsebob> I may want to shoot his dad then *g*
14:25:39 <Beelsebob> although having said that, IT at York was way better than here
14:25:56 <liyang> (I mean, at our school in Belfast.)
14:26:11 <liyang> I should take that as a hint to get back in contact with Matt.
14:26:24 <Beelsebob> ah, okay
14:27:02 <Beelsebob> hehe, this is ludicrous
14:27:27 <Beelsebob> I love writing programs that have functions with arguments that are what they return
14:27:42 <Beelsebob> there's something really wonderful in the fact that it works
14:28:15 <roconnor> I did make install with haxml, but how do I load it into a ghci session?
14:28:16 <liyang> You mean id?
14:28:21 <Beelsebob> no
14:28:39 <Philippa_> just knowing the argument survives longer than the function invocation?
14:28:41 <Beelsebob> I mean result lists that feed back into the function call
14:28:41 * liyang doesn't understand what Beelsebob means.
14:29:03 <liyang> Beelsebob: you mean tying the knot?
14:29:08 <Beelsebob> indeed
14:29:16 <liyang> ah, *nod*
14:29:25 <Beelsebob> it would be horrible to do feedback like this in C
14:29:32 <Beelsebob> it's a piece of piss here
14:32:25 <roconnor> there we go, it's called Text.XML.HaXml
14:45:03 * TheHunter wonders if that stream thing generalizes to any zipper, i.e. if f is a comonad, then there is a suitable zipper zf which is can be made a comonad as well.
14:45:18 <flodin> eek, hugs segfaults on me :\
14:46:24 <mwc> flodin: the only time I've seen that happen; I had bad ram
14:46:35 <dcoutts> SyntaxNinja, I feel I may have been going on too much about packaging recently! [there goes another email to libraries@haskell.org ...]
14:46:51 <flodin> nah this is reproducible, i doubt the same source causes exactly the same bits to be allocated each time
14:47:07 <flodin> and it doesn't happen if i undo the change i just did
14:47:19 <mwc> spooky
14:47:47 <flodin> i'm not doing anything weird either, this is my first haskell project besides "hello world"
14:48:03 <BigDuke> well thats a good start then
14:48:03 <BigDuke> hehe
14:48:31 <dcoutts> xerox, you around?
14:50:42 <flodin> i'm probably getting an infinite recursion, it locks up for a moment before it dumps core
14:51:05 <TheHunter> how much code is that?
14:51:20 <flodin> 14 lines
14:51:28 <mwc> flodin: did you define your base case BEFORE the general>
14:51:28 <TheHunter> @paste
14:51:29 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:51:38 <flodin> mwc: yeah
14:51:57 <mwc> k, that's how I learned that patterns are matched in order :P
14:52:10 <SyntaxNinja> dcoutts: I blame youf or any further "we should actually just completely change the way cabal works andd start from scratch" emails ;)
14:52:30 <mwc> sounds like a plan
14:52:40 * wilx pokes Igloo
14:53:26 <SyntaxNinja> @seen shapr
14:53:27 <lambdabot> I saw shapr leaving #haskell 6 hours, 30 minutes and 46 seconds ago.
14:53:35 <dcoutts> SyntaxNinja, actually I'm not suggesting that at all, i'm actually fairly happy with the way cabal is going
14:53:37 <dcoutts> :-)
14:54:17 <dcoutts> the .cabal file stuff is very declarative and just what we need for discovering dependencies and such like
14:54:18 <SyntaxNinja> dcoutts: no, it was Brian ? who said that, but it's your fault ;)
14:54:31 <dcoutts> oh right, ok it's my fault :-)
14:54:41 <SyntaxNinja> dcoutts: yeah, I agree with the mail you just posted, I just want to get people making the correct distinctions between what should be declarative and what should be in the Setup file.
14:54:51 <flodin> TheHunter: am i meant to just edit the wiki page? I've just done that and put the code there
14:55:15 <flodin> it crashes when you evaluate "sub_mantissa [1, 0, 0] [2,0]"
14:55:27 <dcoutts> SyntaxNinja, yes, and optional dependendencies is a can of worms :-)
14:56:08 <flodin> oops i think i forgot a definition. bignum_base should be 10
14:56:43 <SyntaxNinja> I think 10 is the biggest number we should need actually.
14:56:47 <dcoutts> SyntaxNinja, I'd say most of the complexity in a package system is in the dependency resolution and it's caused by optional this and virtual that, and versioning etc.
14:57:01 <SyntaxNinja> dcoutts: yeah.
14:57:14 <dcoutts> only go there if it's really necessary
14:57:33 <flodin> well i can see the cause of the error now
14:57:33 <SyntaxNinja> dcoutts: I would actually sorta like cabal to become a generic package system; I think there are projects that do that, though, and I know I'm not going to be the one to make cabal into that.
14:58:08 <flodin> the second match should pass t down in its recursive call, not h:t
14:59:02 <dcoutts> SyntaxNinja, yes there are other generic packaging systems but they mostly ignore the native package manager which is not always good
14:59:27 <TheHunter> flodin, thanks, segfault here, too. I'm not very familiar with hugs, but that shouldn't happen...
15:00:50 <dcoutts> SyntaxNinja, btw if you want help with discovering things like alex versions, happy versions etc then ping me, we've got some code for that
15:02:29 <dcoutts> SyntaxNinja, in fact you could initally get away without properly supporting checking the version numbers of happy, if the .cabal file says happy >= 1.15 then the package manager is going to ensure that's there anyway. cheat.
15:03:09 <TheHunter> flodin, you can try ghci, it usually has better error messages and handles this example more gracefully.
15:04:20 <flodin> i = interactive?
15:05:04 <TheHunter> yes, it's just like hugs, except it lets you define things with 'let foo = 3'
15:05:17 <flodin> ahh neat
15:06:23 <flodin> i also got more (justified) warnings from ghci
15:06:49 <flodin> but now, it's bedtime.
15:06:59 <flodin> thanks for help
15:07:08 <TheHunter> g'night
15:07:08 <SyntaxNinja> dcoutts: why do you handle checking the version of happy and such?
15:07:15 <SyntaxNinja> doesn't the package manager tell yout hat?
15:07:23 <thedward> how does a let clause combine with guards?
15:08:09 <dcoutts> SyntaxNinja, sorry I meant "I" rather than "we". I've got code for that in Gtk2Hs and c2hs.
15:08:28 <dcoutts> for checking ghc and happy
15:08:53 <dcoutts> ghc is easy: ghc --numeric-version
15:09:39 <SyntaxNinja> i
15:09:40 <SyntaxNinja> er
15:09:40 <SyntaxNinja> ic
15:10:04 <dcoutts> happy is more tricky, we use: sed "s/[[^0-9.]*\([0-9.]*\) .*]/\1/"
15:10:06 <dcoutts> !!
15:10:13 <dcoutts> not so nice!
15:11:11 <dcoutts> unfortunately it's rather important to be able to do this kind of check since things really will break if happy is too old
15:12:13 <SyntaxNinja> yeah, but then the new versino of happy changes the way it outputs its version numbers and everything breaks.
15:12:33 <dcoutts> it seems not to very much
15:13:02 <dcoutts> we can ask everyone to provide --numeric-version but we're still left with the current versions
15:13:46 <dcoutts> SyntaxNinja, or as I say you can just ignore the versions and leave it to package managers to deal with
15:13:57 <SyntaxNinja> yeah, that's what I was thinking :)
15:14:17 <dcoutts> that'd be an ok solution
15:15:04 <thedward> Do hugs and ghc automatically do memoization?
15:15:05 <dcoutts> the gentoo folk certainly wouldn't complain, it'd give us a feature over regual cabal :-)
15:15:28 <SyntaxNinja> what's this regual cabal you speak of?!?!
15:15:28 <dcoutts> (apart from automatic dependency resolution of course)
15:15:41 <dcoutts> regual/regular
15:15:47 <thedward> that is if I call the same function with the same arguments twice, will it calculate it twice, or just use the value from the first time?
15:15:57 <thedward> (assuming I'm not doing IO or monadic stuff)
15:16:59 <Philippa_> it (probably, in absence of neat optimisations) won't use the value from first time
15:17:19 <Philippa_> the trick is to only actually have one call
15:17:33 <Philippa_> then pass that value around, evaluated or otherwise
15:18:01 <Philippa_> now, if the optimiser does a common subexpression elimination you're laughing
15:18:33 <thedward> does doing something like "where foo = bar" or "let foo = bar" and then using foo count for that?
15:19:13 <thedward> I assume so, since my program runs much faster that way.
15:20:08 <thedward> I think the laziness is confusing me. If foo = bar, shouldn't passing foo be equivalent to passing bar?
15:20:57 <SyntaxNinja> kinda, but it only has to evaluate "what is foo" once
15:21:24 <thedward> how is that different than doing memoization?
15:21:46 <SyntaxNinja> I think you were asking if it does so automatically, which it probably doesn't (-O2 might change that?)
15:22:39 <SyntaxNinja> it's much easier for the compiler to say "foo... I know what foo's value is" than to say "x+y+z-a... I know what x+y+z-a is!"
15:22:50 <SyntaxNinja> so maybe it memorizes symbols but not expressions
15:23:12 <thedward> hmm
15:23:18 <thedward> that is starting to make sense to me
15:23:27 <SyntaxNinja> since they don't have side effects, it IS semantically the same to pass foo and bar, but that doesn't mean that they'll take the same amount of time.
15:24:43 <thedward> I probably shouldn't be worrying at all about efficiency at this point anyway, but I was really surprised at how much different adding a where class made to execution time for my dinky little program.
15:25:06 <Philippa_> SyntaxNinja: it memoises single values
15:25:25 <Philippa_> which symbols refer to
15:25:45 <SyntaxNinja> Philippa_: I see.
15:26:32 <Philippa_> foo = (something complex) works just as well, and it'll give a thunk rather than just substituting in the something complex
15:32:20 <thedward> thanks, that makes sense
15:33:54 <mwc_> dcoutts: got gtk2hs working through ghci on Mac OS X now
15:43:15 * wilx bounces around...
15:45:18 <dcoutts> mwc_, cool, how did you get it working with ghci?
15:54:58 <Igloo> wilx: Are you here?
15:56:43 <wilx> Yup.
15:57:45 <Igloo> How do these 2 patches differ? And why isn't your autoconf finding its own config.{guess,sub}?
15:58:13 <Igloo> (bias)
15:59:09 <wilx> I first added the two files and then realized that they are rather old and replaced them with newer versions.
15:59:20 <wilx> So the 2nd email contains two patches.
15:59:50 <wilx> And config.{guess,sub} seem to be not autoconf's but automake's files.
16:00:04 <wilx> At least that is where I found them under share/automake-1.9
16:01:11 <Igloo> Sorry, I meant autotools
16:01:20 <Igloo> Anyway, why doesn't it find its own?
16:01:46 <wilx> Dunno, because it is Mingw? :)
16:02:30 <Igloo> Hmm, or maybe they just aren't needed if you don't use those variables
16:02:37 <Igloo> Why do you think they're needed
16:02:38 <Igloo> ?
16:03:08 <wilx> Because of the case statement that is in configure.ac around line 378.
16:03:30 <Igloo> Hmm, OK
16:03:35 <wilx> It sets SYS depending on what is in $target.
16:03:51 <wilx> And $target gets defined by one of the AC_CANONICAL_ macros.
16:04:25 <wilx> I am not sure but it could be that only the AC_CANONICAL_TARGET macro is really needed for it to work.
16:04:29 <wilx> I haven't tried though.
16:05:12 <Enveigler> dcoutts: The gtk library method signal_connect() allows an extra, "user data" parameter to be passed when setting up the call back that gets passed back to the callback when the event occurs. Is there any similar provision in the gtk2hs binding?
16:05:14 <Igloo> I'm confused because it must have worked for someone somehow in the past
16:07:36 <Igloo> Right, adding AC_CANONICAL_TARGET makes it complain about not having config.sub, so the only question is why that is necessary for you but not whoever has built darcs in the past
16:08:20 <wilx> Well, dunno. Probably because not many people build darcs on Windows.
16:08:24 <dcoutts> Enveigler, in Haskell that kind of thing is trivial :-) so we don't need to bind that form of callback
16:08:36 <Igloo> No, but someone has done in the past  :-)
16:09:10 <dcoutts> Enveigler, since you can use an arbitrary closure for your callback it can have extra arguments that you give it
16:09:56 <Enveigler> Okay. I just need to read more then. Thanks.
16:10:01 <dcoutts> Enveigler, eg: button `onClicked` myHandler foo bar baz
16:10:06 <wilx> Igloo, I have no idea, I never tried to build it before today.
16:10:23 <wilx> It could be worth asking the other guy, how he builds it.
16:10:47 <Igloo> I'm just asking the list now
16:10:58 <dcoutts> Enveigler, so in that example myHandler takes extra parameters which are being set at the time we connect
16:13:38 <Enveigler> Okay. In Perl/Ocaml, I can pass the same reference to 2 event handlers and have effects from one (update of mouse pos x y) be available to another (say configure). I guess that means I need a ST Monad or IORef to convey the state between the two. I'll try that tomorrow.
16:14:38 <Enveigler> (The penny will drop one day).
16:15:25 <Enveigler> G'night.
16:18:31 <_metaperl> no convo on #haskell for 6 hours??? I can't believe this...
16:19:17 <_metaperl> hello all... I had frozen out of #haskell and did not know it
16:23:11 <wilx> Igloo, btw, while it has compiled it gives me this "darcs.exe: d:/WilX/tmp/darcs/_darcs/current: getDirectoryContents: failed (No error)" to almost any command.
16:23:23 <wilx> This was for "darcs whatsnew".
17:05:46 <Igloo> wilx: Hmm, I wonder if you are using the wrong thing of cygwin/mingw/whateveritis
17:06:22 <wilx> It should be plain Mingw.
17:06:58 <ulfdoz> bye
17:07:29 * Igloo has no idea what darcs should be compiled or used with
17:12:53 <Beelsebob> boo!
17:12:53 <kaol> eek!
17:12:53 * lispy` runs and hides
17:12:53 * wilx calls Ghost Busters hot line.
17:12:53 <Beelsebob> who you gonna call!
17:12:53 <wilx> _The_ Ghost Busters.
17:12:53 <Beelsebob> OMG... Type errors actually worked in Objective-C!!!!
17:12:53 <Beelsebob> It even got the types right!
17:12:53 <wilx> And they're gonna bust your ass into that electric thing of theirs.
17:12:53 * Beelsebob throws an Objective-C type error at wilx
17:13:07 * wilx fences Beelsebob attack with C++ template.
17:13:26 * lispy` hides behind a lambda abstraction
17:13:44 * Beelsebob prods wilx with a true polymorphic type
17:14:32 * lispy` tries to push a monad towards wilx
17:14:43 <wilx> Eeek!!!
17:14:50 * Beelsebob blocks it with a cunning use of interact
17:15:33 * wilx breaks out using unsafePerformIO
17:15:56 * Beelsebob watches wilx explode
17:16:05 <Beelsebob> well you were warned it was unsafe!
17:16:21 * lispy` thinks, "What a fun game Haskell would make" :)
17:16:58 <wilx> I cannot die.
17:17:17 * wilx summons the powers of Phoenix singleton to aid
17:17:20 <Pseudonym> That's because Haskell is safe.
17:18:12 * lispy` wonders how many times "unsafePerformIO" has been worked into lewd jokes by haskell programmers
17:18:28 <wilx> :)
17:18:29 <Beelsebob> haha
17:19:07 <sylvan> what the hell are you people doing? Sheesh! I leave you alone for five minutes and this happens...
17:19:24 * lispy` feels sheepish and then starts cleaning up
17:19:29 <lispy`> sorry, sylvan
17:19:41 <sylvan> don't let it happen again!
17:20:14 * lispy` slips on an improperly curried function
17:23:42 <Beelsebob> ewwww... saltanas
17:24:25 <lispy`> saltanas?  is that a cross between bananas and saltines?
17:25:30 <Beelsebob> no... an odd sort of rasin
17:25:35 <Beelsebob> found in bad curries
17:25:44 <Pseudonym> You mean sultanas.
17:25:47 <Beelsebob> I do
17:25:48 <Pseudonym> Named after the wife of the SUltan.
17:26:12 <lispy`> i like my interpretation more
17:26:28 <Beelsebob> so do I... I don't have to think about bad curry
17:26:35 * lispy` tries to invent a teleportation chamber so he can combine the DNA of a saltine with the DNA of a banana
17:43:54 <mwc> damn; seems like I missed all the fun :(
17:44:30 * lispy` hides the rest of the fun before mwc can find it
17:45:22 <mwc> seems to be a weird bug in GHCi on OS X; I had to manually set DYLD_FALLBACK_LIBRARY_PATH to the locations of the libraries
17:45:43 <mwc> couldn't find libm.dylib in /usr/local ; etc
17:45:56 <lispy`> mwc: binary or dports?
17:46:01 <mwc> lispy`: dports
17:46:03 <lispy`> mwc: i use dports and i haven't had a problem
17:46:21 <mwc> lispy`: this was to get gtk2hs working from within ghci
17:46:23 <lispy`> is there something i could do to test it out?
17:46:25 <lispy`> AH
17:47:20 <mwc> works fine if you compile it; just interactive use has that little snag
17:51:11 * mwc just watched The Jacket
17:55:10 <Pseudonym> The Jacket?
18:00:43 <autrijus> chromatic, on hacking Pugs to create a unit testing framework for Perl 6
18:00:50 * esap gets "Failed binder lookup:" panic from GHC-6.4. :-(
18:00:55 <autrijus> "My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency."
18:01:03 <autrijus> # http://www.perl.com/lpt/a/2005/07/28/test_builder_p6.html
18:01:47 <dons> hehe
18:02:57 <autrijus> trace is absolutely indispensible, as Hat still won't handle pugs in the forseeable future
18:03:28 <Pseudonym> @quote chromatic My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
18:03:29 <lambdabot> chromatic My productivity increased when Autrijus told me about
18:03:29 <lambdabot> Haskell's trace function. He called it a refreshing desert in the
18:03:29 <lambdabot> oasis of referential transparency. hasn't said anything memorable
18:03:33 <Pseudonym> @quote chromatic
18:03:35 <lambdabot> chromatic hasn't said anything memorable
18:03:39 <Pseudonym> Hrm.
18:04:13 <Pseudonym> Can't remember how to do that.
18:06:37 <TheHunter> @help quote
18:06:37 <lambdabot>  @quote [nick] - quote somebody randomly
18:06:49 <TheHunter> hmm.
18:06:55 <dcoutts> @quote TheHunter
18:06:55 <lambdabot> TheHunter hasn't said anything memorable
18:06:58 <dons> to record a quote, use @remember foo foo's quote
18:07:00 <TheHunter> @help remember
18:07:00 <lambdabot>  @remember <nick> quote - record some memorable phrase
18:07:15 <Pseudonym> @remember chromatic My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
18:07:24 <TheHunter> @listcommands quote
18:07:25 <lambdabot> quote provides: fortune yow arr
18:07:28 <Pseudonym> The problem is that it's not obvious that @quote and @remember are related.
18:07:40 <Pseudonym> @quote Pseudonym
18:07:41 <lambdabot>  Lazy evalution is really, really trippy.
18:08:01 * Pseudonym still isn't sure why that was considered quotable
18:08:37 <dons> ok, I will consider this a bug report about @quote, and will patch the module
18:08:37 <TheHunter> @listcommands remember
18:08:38 <lambdabot> babel provides: babel remember quote timein ghc
18:08:51 <dons> problem is that remember/quote aren't in the Quote module :}
18:08:53 <TheHunter> the 'quote' module should be renamed.
18:08:59 <Pseudonym> Something like @addquote would make more sense.
18:09:20 <dons>  @quote-add would fit the existinng naming scheme
18:09:35 <dons> i'll tweak the help msg for now
18:09:45 <Pseudonym> Right.
18:10:00 <dons> and alias quote-add for remember, that's easy
18:14:14 <TheHunter> does anybody know a zipper that is more powerful than the "data Zipper dir a = Zipping a (dir -> a -> Zipper dir a) | ZipDone a deriving Show" zipper but still polymorphic over the datastructure used?
18:22:32 <wilx> Hmm, does GHC have some kind of native support for Win32 api?
18:22:47 <Lemmih> Native support?
18:22:53 <wilx> E.g. System.Win32 instead of System.POSIX?
18:22:55 <dcoutts> wilx, yes in the win32 module
18:23:03 <dcoutts> win32 package rather
18:24:30 <dcoutts> mwc, so how did you build the shared libs for Gtk2Hs?
18:24:47 <wilx> Hmm, there are no docs for it.
18:24:48 <wilx> Odd.
18:25:06 <dcoutts> wilx, probably because the docs were generated on linux :-)
18:25:18 <wilx> Discrimination!
18:26:09 <mwc> dcoutts: I used the --auto-ghci-libs flag to ghc-pkg; worked like a charm
18:26:29 <mwc> just had to add some system library paths to the dyld fallback path so that it could find libgmodule and libm
18:26:32 <wilx> Well, it should be possible to generate the docs even without Windows, or am I wrong?
18:26:54 <dcoutts> mwc, oh right, not so bad then :-)
18:27:44 <mwc> hugh, buddy!
18:28:58 <wilx> Ah.
18:29:09 <wilx> There are docs in my local copy.
18:30:39 <wilx> Hmpf.
18:30:52 <wilx> But it lacks binding for CreateHardlink.
18:42:03 <dons> @help quote
18:42:04 <lambdabot>  @quote <nick>/@quote-add <nick> <quote>
18:42:04 <lambdabot> Quote somebody, or a random person, or save a memorable quote
18:42:40 <dons> @version
18:42:40 <lambdabot> lambdabot 3p55, GHC 6.4.1 (OpenBSD i386)
18:42:40 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:50:02 <Beelsebob> bah... badnesss
18:51:19 <Beelsebob> "We might have four areas of the wing leading edge where there might have been an impact."
18:51:51 <Beelsebob> apparently the camera on the ISS has picked up minor damage to the shuttle's wings
19:00:25 * Beelsebob prods lispy in the underscore
19:01:10 <CosmicRay> aw rats, no shapr.
19:01:23 <Beelsebob> @seen shapr
19:01:23 <lambdabot> I saw shapr leaving #haskell 10 hours, 38 minutes and 42 seconds ago.
19:01:42 <CosmicRay> rats.  he's probably sleeping or something.
19:01:49 <Beelsebob> guess he must have a life or something
19:02:01 <Beelsebob> *g*
19:03:30 <lispy_> probably out cycling :)
19:04:43 <Beelsebob> wish there was somewhere good to cycle here
19:08:03 <CosmicRay> plenty of good places to cycle here.  unfortunately no good way to get from home to those places on a cycle.
19:08:22 <CosmicRay> (hilly rural 2-lane road with no shoulder == not bike-friendly)
19:11:34 <joelk> what is the haskell equivalent of wait?
19:15:43 <dons> as in wait for a thread?
19:16:34 <dons> for processes, we have waitForProcess
19:17:17 <dons> for threads check the Control.Concurrent library
19:17:21 <dons> @where hier
19:17:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:17:56 <joelk> what about just a time delay?
19:18:36 <Lemmih> @index threadDelay
19:18:37 <lambdabot> GHC.Conc, Control.Concurrent
19:21:59 <metaperl> joelk: you are asking these questions at the right time. dons just finished writing similar things for ICFP :)
19:22:07 <joelk> actually, Lemmih, you're just the person I was looking for. I was lookin at scannedinavian.org/~lemmih. Do you have those SDL/OpenGL translations of NeHe code handy by any chance.
19:23:11 <dons> heh, yeah there's some thread stuff in the icfp entry, for sure.
19:23:22 <dons> though stefanw is the main man behind that
19:23:39 <metaperl> would anyone care to improve my implementation of splitAt: http://rafb.net/paste/results/SGNpcN93.html
19:23:50 <metaperl> i'm so proud, I wrote it all by myself :)
19:23:55 <dons> but we already have a splitAt ;)
19:24:01 <metaperl> it looks ugly but at least it's homebrewed
19:24:02 <TheHunter> the closest thing to wait is probably takeMVar
19:24:26 <metaperl> well, SJT still thinks its a good exercise. It's 7.14 in his book
19:24:39 <dons> i agree with TheHunter, there's a few ways to do this with threads, and MVars are the usual thingo
19:25:08 <dons> or possibly x <- tryTakeMVar mvar if you're feeling adventurous
19:25:51 <TheHunter> yeah, that's better
19:25:57 <TheHunter> metaperl, what's the 1 case for?
19:26:08 <joelk> I just meant putting a timed delay between two IO () events.
19:26:15 <metaperl> TheHunter: that was just there during my iterative development
19:26:25 <metaperl> what's the command to ask lambdabot for ghc source for something
19:27:13 <TheHunter> @help libsrc
19:27:14 <lambdabot> library source
19:27:43 <metaperl> @libsrc splitAt
19:27:43 <lambdabot> splitAt not available
19:27:51 <metaperl> @libsrc Data.List
19:27:52 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
19:29:15 <TheHunter> metaperl, also there are some very superfluous parens.
19:29:27 <metaperl> yes, I dont know when parens are necessary
19:29:53 <metaperl> the Prelude def of genericSplitAt was eye-opening... I never knew where could be used that way!
19:30:04 <TheHunter> just leave em out, you'll get a type error when they would've been necessary.
19:30:13 <metaperl> lol
19:30:18 <metaperl> the trailblazer approach
19:30:57 <TheHunter> you only have to know: application binds tightest, special syntax (let, (,),..., if) binds loosest.
19:31:09 <dons> we have  libsrc? that snuck in without me noticing :}
19:31:33 <TheHunter> it's not like in C where every precedence mistake has horrible consequences.
19:31:47 <lispy_> dons: i found a yi bug
19:32:07 <lispy_> dons: but i need to check with the latest version and see if i can make a minimal test case
19:33:06 <lispy_> dons: i was using vim mode, and i was hitting 'x' to deleted characters from a line that wrapped and it got confused either in the redisplay code or somewhere and the screen wasn't synced with the file contents
19:33:58 <metaperl> can you use pattern-matching in where clauses? E.g., where myfunc 0 = 5 myfunc 2 = 3
19:33:58 <mwc> aren't they normally out of sync; until you commit changes?
19:34:04 <dons> joelk, use threadDelay then
19:34:13 <dons> hmm
19:34:17 <mwc> metaperl: yeah
19:34:22 <metaperl> mwc: thanks
19:34:23 <CosmicRay> joelk: I think that is in Control.Concurrent
19:34:33 <lispy_> mwc: well, the information on the screen was garbage
19:34:35 <dons> lispy_ check with the latest yi, then send me a reproducible sequence of keystrokes, please :)
19:34:40 <metaperl> CosmicRay is gracing us with his presence in the wee hours of the Eastern night :)
19:34:45 <lispy_> dons: working on it :)
19:35:01 <dons> mmwc, you talking about yi being normally out of sync?
19:35:12 <CosmicRay> metaperl: hehe
19:35:15 <dons> isn't that the emacs way of doing things?
19:35:16 <metaperl> CosmicRay: you know Rays are a Theosophical concept? I know where you got your name, but still...
19:35:43 <metaperl> the emacs way is obsolete. M-x all-hail-xemacs
19:35:45 <CosmicRay> metaperl: no idea, hmm.
19:35:47 <dons> in yi, the screen redisplays the buffer contents after each edit action, and we let ncurses work out the optimal way to minimise the redisplay
19:35:49 <CosmicRay> interesting.
19:36:37 <dons> there's no performance issue anymore that would justify letting the screen and the buffer get out of sync, I think. maybe in 1982 there was
19:37:14 <dons> its easy enough to let a redisplay thread wait on the buffer MVar, and redraw when it is filled
19:37:16 <lispy_> dons: well, terminals are slow still, but I agree.
19:37:35 <dons> have you noticed any slowness in yi though?
19:37:45 <lispy_> i haven't used it a lot yet
19:37:48 <dons> ok.
19:37:55 <lispy_> i've been trying to remember to use it instead of vi
19:38:01 <dons> oh!
19:38:05 <dons> @karma+ lispy
19:38:06 <lambdabot> lispy's karma raised to 1.
19:38:14 <lispy_> heh
19:38:15 <dons> well, it does make a usable vi I think
19:38:23 <CosmicRay> metaperl: this splitAt problem is interesting.
19:38:24 * CosmicRay bites
19:38:28 <dons> and someone else uses it as a nano for commit messages
19:38:36 <lispy_> cool
19:39:02 <lispy_> it's a little slower at startup that plain vi, but only a fraction of a second
19:39:22 <dons> hmm. makes me think that the future haskell operating system should come with yi, and symlinks to yi --as=emacs, yi --as=vi, vim, nano, mg, ee etc..
19:39:43 <dons> lispy, true. the cost of the dynamic framework comes in with small buffer sizes
19:39:50 <dons> yi-static should be close to vi speed  though
19:40:14 <lispy_> yeah, i've been thinking i should make a script like yi --as=mg, but I don't know how to pass all the parameters to yi (/me is not good at shell scripting)
19:40:34 <dons> with moderate to large buffers, yi beats vi by miles though. i have a graph somewhere where vi took 3 mins to load a buffer that took about 8 secs in yi :}
19:40:46 <CosmicRay> metaperl: what do you think of http://rafb.net/paste/results/KOoPWL92.html
19:40:49 <lispy_> dons: yeah, it's in your paper
19:41:09 <dons> I don't think I have the graph that includes all the small static editors though
19:41:23 <lispy_> dons: i tried to write a buffer for large strings in lisp and it was slower than emacs, and i see your code is faster than emacs :)
19:42:15 <dons> yeah, well compiled functional code *should* beat interpreted lisp :)
19:42:32 <lispy_> this was compiled lisp :)  on a high performance lisp compiler (sbcl)
19:42:40 <dons> oh, oops :)
19:42:50 <lispy_> although, in the version of sbcl i was using strings were not fully optimized as they are now
19:42:56 <dons> we must thank SimonM's IO hackery
19:43:15 <dons> and the FFI, long may it reign
19:43:29 <lispy_> how much of Yi is in C?
19:43:31 <lispy_> none?
19:43:35 <dons> hmm, about 4 lines :)
19:43:43 <lispy_> heh, what do they do?
19:43:50 <dons> out of 5000 loc
19:44:33 <dons> just a function for walking raw bytes in memory really fast
19:44:41 <dons>         while (p < q && c < n)
19:44:42 <dons>             if (*p++ == '\n') c++;
19:44:42 <CosmicRay> ahh, here we go.  three lines.
19:44:44 <CosmicRay> msplitAt 0 xs = ([], xs)
19:44:44 <CosmicRay> msplitAt 1 (x:xs) = ([x], xs)
19:44:44 <CosmicRay> msplitAt n (x:xs) = (\(a, b) -> (x:a, b)) $ msplitAt (n-1) xs
19:44:44 <lispy_> i'm often surprised by the performance of GHC
19:45:20 <dons> if we get some imperative loops in the C-- backend of GHC, maybe I can convince GHC to generate something close to this one day
19:45:44 <dons> with primops, you can get surprisingly close sometime
19:47:47 <metaperl> CosmicRay: fascinating approach
19:47:57 <lispy_> dons: i wonder if my terminal is just screwed up
19:48:20 <CosmicRay> metaperl: the paste is pretty similar but uses a case instead of the anonymous function for pattern matching
19:48:37 <CosmicRay> metaperl: your case for msplitAt 1 could be optimized in the same way and would give you the same number of lines of code as the past
19:48:39 <CosmicRay> e
19:48:44 <CosmicRay> but thanks ;-)
19:48:51 <lispy_> dons: nope, it's Yi
19:49:16 <dons> no, it could be yi. well, for one if there are tabs or control chars in  the file, yi doesn't redraw them properly
19:49:20 <dons> this is a todo
19:49:33 <lispy_> dons: it's a Makefile
19:49:38 <lispy_> dons: so it has tabs :)
19:49:40 <dons> oh, tabs galore
19:49:45 <dons> its probable just that then
19:49:58 <lispy_> okay, i won't bother with a full bug report
19:50:03 <dons> can you remove the tabs and see if it still happens though?
19:50:08 <lispy_> ah, yeah
19:50:57 <lispy_> dons: it's fine without tabs
19:51:36 <dons> ok. I'll (+1) my fix-up-gui-tabs todo entry
19:52:08 <lispy_> i could try to fix it
19:52:18 <lispy_> with a little guidance perhaps
19:52:31 <dons> well, its a little tricky, as it involves several layers of yi.
19:52:43 <dons> i do intend to get round to it soon though
19:52:52 <dons> as it is kind of important to support tabs ;)
19:52:57 <dons> (stupid tabs)
19:53:04 <lispy_> alright, since i'm new to the Yi code maybe I shouldn't start with it :)
19:53:18 <dons> yeah, starting with a keymap and working from there is the usual way to get into yi hacking
19:53:27 <dons> or a new gui if you're a little more ambitious
19:53:45 <dons> also, porting to a new OS is another way
19:54:10 <CosmicRay> metaperl: hmm, in all of these cases, the case for msplitAt 1 could be completely eliminated.
19:54:17 <CosmicRay> all you need is 0 and n
19:54:19 <lispy_> ah, yeah taking dcoutts's gtk tutorial and using it to do a gtk interface wouldn't be a bad idea :)
19:54:41 <dons> that would be really cool :)
19:55:08 <dons> hmm. and just getting something hacked up mightn't be so hard (just displaying the text in the first case)
19:55:45 <lispy_> yeah, more than i'm up to tonight tho, but maybe this weekend
19:55:57 <lispy_> i put up my start at an elisp interpreter
19:56:02 <CosmicRay> lispy_: do you have a url to this tutorial?  I may be needing such a thing in the not-so-distant future
19:56:13 <lispy_> CosmicRay: let me look
19:58:09 <lispy_> CosmicRay: it's at this site http://haskell.org/gtk2hs/  but that's not the direct url, still searching
19:59:05 <lispy_> CosmicRay: and there is this http://haskell.org/gtk2hs/documentation/
19:59:15 <CosmicRay> thanks lispy
19:59:28 <lispy_> CosmicRay: ah, here it is http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/
19:59:33 <lispy_> that's the one i was thinking of
19:59:34 <TheHunter> dons, Failed to load interface for `Yi.Undo': ..., any idea?
19:59:54 <TheHunter> (using ghc-6.5)
20:00:47 <dons> hmm.
20:01:03 <TheHunter> have they changed recursive modules again?
20:01:14 <dons> $ ./yi-inplace README should work.
20:01:21 <dons> what about ./yi-static?
20:01:38 <dons> what does $ ./yi-static --version say?
20:01:49 <dons> GHC 6.4.20050506 works for me
20:02:14 <TheHunter> there's no ./yi-static.
20:02:20 <dons> !
20:02:45 <TheHunter> i can't compile it...
20:02:55 <dons> hmm :/
20:03:11 <dons> last night the ghc .hi format changed, which would break hs-plugins
20:03:25 <dons> so just running make must fail?
20:03:35 <TheHunter> yep.
20:03:41 <TheHunter> hs-plugins compiled fine.
20:03:54 <dons> what error? the above `Failed to load interface ... ' ?
20:04:21 <TheHunter> yes.
20:04:32 <dons> yi should work with both old and new formats, however, I have a machine with latest ghc on it, i'll try it out
20:04:47 <dons> maybe they tweaked the format (hmm, rings a bell)
20:17:05 <dons> TheHunter, does: make way=static work?
20:17:59 <TheHunter> lemme check.
20:18:22 <TheHunter> in any case, lambdabot works fine.
20:18:24 <dons> hmm, though with last night's 6.5 I get:
20:18:25 <dons> gmake: *** [yi.conf] Error 127
20:18:25 <dons> gmake: *** Deleting file `yi.conf'
20:18:40 <dons> (make way=static)
20:18:53 <TheHunter> nope, same error.
20:19:11 <TheHunter> i actually had that error, too, but it disappeared somehow.
20:19:17 <dons> oh, no ghc-pkg it seems
20:19:39 <TheHunter> it's probably a recursive modules issue.
20:19:54 <dons> my yi.conf issue is due to GHC_PKG being unset for some reason
20:20:02 <TheHunter> or possibly, ghc-6.5 broke {-# SOURCE #-}, whatever that does
20:20:05 <dons> well, all my recursive modules built fine
20:21:29 <dons> oops, then we get:
20:21:30 <dons> Yi.hi :
20:21:30 <dons>   Interface file inconsistency:
20:21:30 <dons>     home-package module `Yi.Editor' is mentioned,
20:21:30 <dons>     but does not appear in the dependencies of the interface
20:21:42 <dons> ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):
20:21:42 <dons>         forkM Declaration for staticzumain{v}
20:21:44 <dons> :}
20:22:29 <TheHunter> the strange thing is ghci Yi/Buffer.hs works fine.
20:23:20 <TheHunter> ok, i did "ghc --make Yi/Buffer.hs", now the compilation goes on...
20:24:01 <dons> hmm. you don't have stable on your machine somewhere/
20:24:05 <dons> 6.4.1 works ok
20:24:15 <dons> but 6.5 is being very weird for me
20:24:30 <TheHunter> sure, i could install stable, but 6.5 is much more fun.
20:24:54 <dons> ok, /me debugs
20:25:11 <TheHunter> alright, i finally arrived at your error message.
20:26:53 <dons> this one I haven't worked out yet
20:27:26 <TheHunter> well, it doesn't matter much, i can just use 6.4. Thanks.
20:30:34 <TheHunter> ok, i've got it. Yay!
20:30:54 <TheHunter> instead of "ghc -Wall -Werror -Icbits -Imk -funbox-strict-fields -O2 -fasm -threaded  -package-conf yi.conf -package yi -c Main.hs -o Main.o -ohi Main.hi"
20:31:11 <TheHunter> i used "ghc --make -Wall -Werror -Icbits -Imk -funbox-strict-fields -O2 -fasm -threaded  -package-conf yi.conf -package yi -c Main.hs -o Main.o"
20:32:06 <dons> oh. hmm. but that probably included the Yi/* modules as direct dependencies
20:32:14 <dons> which would break dynamic loading, I think
20:32:21 <dons> well, break dynamic reloading
20:32:32 <dons> but its enough for testing ./yi-static at least
20:33:14 <TheHunter> how do I test dynamic reloading?
20:33:48 <dons> try :reboot in the vim mode (the default mode)
20:34:06 <dons> using ./yi-inplace
20:34:32 <TheHunter> it doesn't give me an error.
20:34:53 <dons> hmm. ok :)
20:35:32 <dons> could be that  the tricks I needed to avoid linking modules directly are obsolete in 6.5
20:35:45 <dons> as the -I flag semantics changed slightly
20:36:08 <dons> oh, Main.hs isn't what I was worried about -- my mistake
20:36:20 <dons> it's Boot.hs where it matters if modules are linked directly
20:36:32 <dons> Using --make on Main.hs should generate a working yi-static, I  think
20:37:43 <TheHunter> hmm, it doesn't remember the column when moving to a shorter line, is that intentional?
20:38:35 <dons> not implemented
20:38:40 <dons> todo list :)
20:38:59 <dons> just needs to add a goal column value to the dynamic state
20:39:46 <TheHunter> must resist temtation to check out the Keymap/Vim source, gotta go to bed :)
20:40:29 <TheHunter> is syntax highlighting in sight?
20:40:48 <dons> not yet, a month or two
20:40:55 <dons> maybe August is the month.
20:41:01 <dons> I want it done by Sept 30.
20:41:15 <dons> its doable, just a bit of extended hacking
20:41:59 <TheHunter> hehe, after that there'll be no excuse to use vim any more.
20:42:29 <dons> yeah, I reckon so
20:44:15 <TheHunter> is vim mode supposed to be an exact vim copy or will it already include improvements?
20:44:48 <dons> I was thinking having a basic vim copy, but then starting a vim improved + haskellish mode
20:45:04 <dons> just like vi is a supposed-to-be vi implementation
20:45:10 <dons> like vi-compatible mode in vim :)
20:45:23 <dons> we want vim-compatible mode in yi, + a true yi mode
20:45:26 <TheHunter> that makes sense.
20:46:17 <dons> our interface grammars are easy to design (as they're just lexer defns) so we can probably create some interesting modes
20:47:02 <TheHunter> that sound promising, i'll have to look into the code.
21:54:24 <joelk> ls
21:54:30 <joelk> doh!
21:56:34 <lispy_> drwxr-xr-x    2 joelk joelk     4096 Jan 30 09:56 pr0n/
21:56:41 <dons> ls: doh!: No such file or directory
21:56:57 <dons> lispy is much cheekier
21:57:11 <lispy_> i borrowed it from a bot in another channel ;)
21:58:00 <joelk> jokes on you, that's my other machine! :-)
21:58:20 <lispy_> dons: i put gtk gui for darcs on my todo list, but i had to give it a low priority, so i'm going to have to be productive in order to work on it :)
21:58:31 <lispy_> er not darcs
21:58:33 <lispy_> yi
21:58:35 * lispy_ can't type
21:59:08 * Korollary infers instead
22:00:12 <lispy_> a gtk gui for darcs could be nice too.  There was a wxwidgets one,  but i think it bit rotted
22:03:27 <dons> a gui for darcs?
22:03:33 <dons> sounds tricky
22:03:48 <dons> or are there already guis for rcs'?
22:04:09 <lispy_> well, the wxwidgets one as i understand it, was basically a domain specific command line, mostly meant for windows users
22:04:37 <dons> ah right. I was thinking some tricksy graphical thingo
22:04:55 <lispy_> there is a plugin for eclipse, and there is talk of having a dependency graph
22:05:05 <lispy_> but, i haven't tried it
22:06:26 <Korollary> nice gui's are hard to do. more art than science.
22:07:02 <gzl> it's often relatively easy to make cocoa gui wrappers for command line tools, fwiw
22:07:07 <lispy_> Korollary: i agree, but the HCI researchers would like to think it can be scienced
22:07:31 <gzl> of course, it would only work on os x. maybe not worth the tradeoff
22:08:05 <lispy_> gzl: well, if windows had some similar thing it could be worth the trade off.  Sometimes it's best to have a gui that matches the environment
22:08:19 <gzl> yeah, that's why i was saying.
22:08:42 <lispy_> mayke tcl/tk could be used in windows
22:08:50 <lispy_> and on linux for that matter
22:09:54 <gzl> for example, http://www.cocoadevcentral.com/articles/000025.php
22:09:56 <Korollary> Not in terms of display of state, but for the purposes of communicating with the computer, is there a graphical method of an application that beats any commandline interface for the same app ?
22:09:58 <lispy_> although, i think that one windows cvs client has the right idea, what is it called tortuise?  (like a turtle, but I can't spell)
22:10:14 <Korollary> tortoise ?
22:10:24 <lispy_> ah, yes
22:10:32 <gzl> Korollary: it depends on what your definition of "beats" is
22:10:47 <lispy_> tortoise cvs is nice because it integrates with windows explorer, so you don't really have to know it's there
22:10:52 <Korollary> gzl: beats in the sense that you would say ickk and go back to the graphical input method.
22:11:12 <gzl> I feel that way about patch
22:11:50 <lispy_> command line tends to be good when  you know what you want to do, and you don't want anything to get in the way
22:12:09 <lispy_> GUI seems to be better when you need assistance because you're not a professional user
22:12:22 <gzl> that's not necessarily true
22:12:32 <gzl> sometimes the command line version is just more annoying
22:12:50 <Korollary> clicking on the file menu is identical to typing "help". They both present you with commands to choose from.
22:13:13 <Speck> guis for editors at nice as long as they have excellent keybindings.
22:13:20 <gzl> you have to do more work to format your interactions with the command line utility
22:13:43 <lispy_> gzl: yes, but if you can type faster than you can point (as is the case with me) it's often worth it
22:13:52 <gzl> yes, and i usually use the command line too
22:14:00 <lispy_> unless, you need a lot of description to make up for the pointing
22:14:09 <gzl> my point is just that i don't think it's correct to assume people who prefer a gui tool in some cases are not professionals
22:14:11 <Korollary> I never use Emacs' file menu, or other menus. Not because emacs' file menu is inferior to the file menus of other editors, tho
22:14:15 <gzl> and who cares if they are or aren't
22:14:48 <gzl> it's a matter of taste
22:15:04 <lispy_> gzl: hmmm...my wording was perhaps bad.  I just meant that for that particular program or use the user is not....um....so experienced that thinking how to use it is second nature
22:15:30 <gzl> yeah. another example is diff
22:15:44 <lispy_> and i know, sometimes, a gui is just better
22:15:46 <Korollary> How many times do you prefer to choose "Copy" from the edit menu instead of pressing ctrl-c et al ?
22:15:48 <gzl> i'd much rather view diffs in a gui editor than view raw diff output or something
22:16:11 <dons> oh diff -u isn't so bad
22:16:18 <lispy_> gzl: my experience is the other way, i really like diff -u | less
22:16:20 <Korollary> gzl: That's what I meant by display of state. In that sense you cannot beat a graphical output. I am talking about talking to the computer.
22:17:05 <gzl> if *you* like diff -u, great. :)
22:17:19 <Korollary> I prefer diff within emacs
22:17:21 <lispy_> gzl: :)
22:17:41 <lispy_> Korollary: i should try that more often since i tend to be in emacs quite a bit
22:17:52 <Korollary> I live in emacs
22:18:07 <Korollary> shell, ghci, python interpreter, etc.
22:19:34 <gzl> yeah, i know somebody like that
22:19:39 <gzl> i found it slightly odd :)
22:19:43 <gzl> but i can see why someone would like it
22:21:06 <lispy_> Korollary: i don't really like a shell in emacs, i never can seem to navigate the scroll back, is there a trick to it?
22:21:10 <Korollary> I'm looking at Firefox, or X-Chat, and don't see anything I particularly like about the GUI that's "unlike" cli.
22:21:32 <lispy_> Korollary: i'm not following you
22:21:39 <Korollary> lispy_: It should work just like a normal buffer.
22:21:49 <gzl> yeah, isn't that annoying though?
22:21:54 <gzl> you can't do up arrow for history
22:21:58 <Korollary> yes you can
22:22:10 <gzl> my cursor just moves up int he buffer like you said
22:22:19 <lispy_> Korollary: i use M-x term
22:22:20 <Korollary> Meta-P I think
22:22:40 <Korollary> M-x shell is what I use
22:22:41 <lispy_> Korollary: maybe i should be using M-x shell instead
22:22:48 <gzl> what's the difference again?
22:22:50 <gzl> I always forget
22:22:57 <lispy_> term is a terminal emulator
22:23:11 <lispy_> shell is a shell, like bash or tcsh
22:23:18 <gzl> yeah, term behaves like a normal terminal
22:23:21 <lispy_> so with term you have to run bash still :)
22:23:42 <Korollary> yeah meta-p gives you what you want in a shell buffer
22:23:49 <lispy_> i tihnk my objection to shell was that it doesn't interpret my prompt correctly
22:23:51 <gzl> yeah, just tried it
22:23:59 <gzl> lispy_: yes, I had the same problem
22:24:04 <Korollary> command completion works as well
22:24:07 <gzl> I just set a custom prompt in my emacs startup
22:24:21 <gzl> Korollary: is there any major benefit to this, though?
22:24:28 <Korollary> you can set which shell interpreter you want to run
22:24:55 <gzl> sorry, I don't follow.
22:24:57 <Korollary> gzl: benefit to what ?
22:24:58 <lispy_> what are the choices?
22:25:04 <Korollary> you can choose any shell
22:25:13 <gzl> benefit to using a shell in emacs versus a normal terminal
22:25:22 <lispy_> Korollary: so i can set M-x shell to act  like bash?
22:25:30 <Korollary> gzl: I do copy-paste a lot for example.
22:25:31 <gzl> lispy_: yes
22:25:39 <gzl> lispy_: mine runs zsh
22:25:53 <lispy_> gzl: but we're not talking about M-x term?
22:25:58 <gzl> no, shell
22:26:02 <lispy_> hmm....
22:26:05 <gzl> though in M-x term it prompts me for what I want to run
22:26:09 <gzl> so I just type in /bin/zsh
22:26:16 <gzl> and it's the same thing
22:26:25 <Korollary> lispy_: Type M-x customize-appropos, then shell
22:26:59 <gzl> there are some really nice things in tuareg for ocaml that i wish haskell had
22:27:20 <Korollary> yeah I read about them. autocompile on save buffer, etc, right ?
22:27:22 <lispy_> hmm.... shell file name is set to bash, but my prompt looks all funny
22:27:44 <gzl> well,  one I liked a lot is if you have your cursor in the middle of a function definition
22:28:04 <gzl> you can hit some key combo and it'll paste the definition in your ocaml toplevel and run it
22:28:17 <Korollary> ah
22:28:27 <Korollary> python mode has that, iirc
22:28:29 <gzl> and usually i was running the editor and toplevel in one split window
22:28:38 <gzl> so it's really handy
22:28:59 <Korollary> do you use ocaml more than haskell ?
22:29:07 <gzl> no, I haven't used ocaml in a while
22:29:12 <gzl> not since last year
22:29:26 <gzl> but i don't use haskell much either, though i like it
22:29:51 <Korollary> haskell wass just too elegant for me to try to learn ocaml. I did want to, tho, because of performance. oh well.
22:30:06 <gzl> +. is almost annoying enough for me to not use ocaml
22:30:20 <Korollary> yeah. type classes are great.
22:30:39 <gzl> considering i only use haskell for fun, i see no reason to switch back to ocaml
22:30:42 <gzl> yeah
22:31:09 <gzl> i used java at work generally, and if not that i'd be using the internally developed language
22:31:27 <Korollary> I bet it's like java too
22:31:36 <gzl> the internal one? no, not at all
22:32:02 <lispy_> yeah, i use Haskell for fun, and also because i need a language like haskell or lisp if i'm going to get my one man projects off the ground, i can't spend all my time implementing all the details in C
22:32:08 <gzl> it's not really easy to compare it easily to anything i can think of
22:32:30 <Korollary> lispy_: or you can drop the projects :)
22:33:06 <gzl> and for some things, there's just no reason to use haskell; i wrote something tiny in shell script the other day, which was much easier
22:33:34 <Korollary> haskell is ok for script usage unless you really need CPAN like libraries.
22:33:52 <gzl> i just had to run a bunch of utilities in sequence
22:34:02 <gzl> very little actual logic
22:34:30 <Korollary> I started with rewriting some python scripts in haskell actually
22:35:13 <gzl> if i had some scripts that actually did some work, then i'd use a proper language and not just shell
22:35:31 <gzl> but i don't :)
22:35:51 <Korollary> I had this script that renamed mp3's using a numbering scheme
22:36:08 <gzl> example?
22:37:23 <Korollary> they are renamed to "000 =-= Michael Jackson & G.W.Bush -- Live at Neverland" where the 0-padding depends on total number of mp3s. Earliest file gets the smallest number.
22:37:44 <gzl> earliest by date modified, or what?
22:37:47 <Korollary> yeah
22:37:54 <gzl> ok
22:37:58 <Korollary> without using system()
22:39:27 <Korollary> nowadays I play with the language shootout benchmarks
22:40:53 <mflux> korollary, so how big was that program?
22:41:05 <Korollary> mflux: which, the mp3 renamer ?
22:41:11 <mflux> yes
22:41:27 <Korollary> about 20% longer than the python version
22:41:30 <Korollary> lemme see if I can find it
22:45:23 <Korollary> 68 lines sheesh
22:47:04 <mflux> did it just use the original file names or id3 tags?
22:47:13 <Korollary> ok, 48 lines without comments. The python version was 28 lines
22:47:24 <Korollary> mflux: just the original file names
22:50:17 <Korollary> heh, I didnt even use the do-notation. such a noob
22:54:08 <Pseudonym> Anyone know how to do a footnote in MoinMoin?
22:54:27 <Pseudonym> Ah, found it.
23:27:19 <vdrab> hello #haskell. I know quite a few of you are also python programmers so i was wondering how you would get similar behaviour to haskell's algebraic data types in python...? I can see that the time-honoured binary tree example translates nicely to a bunch of Node classes, but what about more complex examples like, say, small domain specific languages? Has anyone ever given this one some thought?
23:28:36 <flodin> domain specific languages are done within the language, and looks like a language extension. I can't imagine how that would be done in python, but of course i may just have a bad imagination
23:29:45 <vikasg> you might try Logix if you want DSLs
23:30:20 <vdrab> Logix is a programming language, or some library?
23:30:55 <vikasg> Logix extends Python with macro-writing-ability and such
23:31:04 <vdrab> oh i see... sweet
23:32:15 <vdrab> it 's just that python seems to have operator overloading and pretty printing and such, so there must be a __somewhat__„ÄÄpainless way of doing it... : )
23:32:47 <vdrab> but then that may be a question for #python i guess
23:32:49 <vdrab> thanks guys
23:32:53 <vikasg> yes, sometimes I think Python is just begging for neat hacks
23:34:34 <vdrab> yes. it 's picked my curiosity for some reason....
